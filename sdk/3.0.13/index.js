var Ci = Object.defineProperty;
var Pi = (a, u, c) => u in a ? Ci(a, u, { enumerable: !0, configurable: !0, writable: !0, value: c }) : a[u] = c;
var Ft = (a, u, c) => (Pi(a, typeof u != "symbol" ? u + "" : u, c), c);
import React, { useState, useEffect, useContext, useMemo, useRef, useLayoutEffect } from "react";
import ReactDOM from "react-dom";
var commonjsGlobal$1 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs$2(a) {
  return a && a.__esModule && Object.prototype.hasOwnProperty.call(a, "default") ? a.default : a;
}
function getAugmentedNamespace(a) {
  if (a.__esModule)
    return a;
  var u = a.default;
  if (typeof u == "function") {
    var c = function l() {
      return this instanceof l ? Reflect.construct(u, arguments, this.constructor) : u.apply(this, arguments);
    };
    c.prototype = u.prototype;
  } else
    c = {};
  return Object.defineProperty(c, "__esModule", { value: !0 }), Object.keys(a).forEach(function(l) {
    var v = Object.getOwnPropertyDescriptor(a, l);
    Object.defineProperty(c, l, v.get ? v : {
      enumerable: !0,
      get: function() {
        return a[l];
      }
    });
  }), c;
}
var lib$2 = {};
function e(a) {
  this.message = a;
}
e.prototype = new Error(), e.prototype.name = "InvalidCharacterError";
var r$2 = typeof window < "u" && window.atob && window.atob.bind(window) || function(a) {
  var u = String(a).replace(/=+$/, "");
  if (u.length % 4 == 1)
    throw new e("'atob' failed: The string to be decoded is not correctly encoded.");
  for (var c, l, v = 0, p = 0, _ = ""; l = u.charAt(p++); ~l && (c = v % 4 ? 64 * c + l : l, v++ % 4) ? _ += String.fromCharCode(255 & c >> (-2 * v & 6)) : 0)
    l = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(l);
  return _;
};
function t(a) {
  var u = a.replace(/-/g, "+").replace(/_/g, "/");
  switch (u.length % 4) {
    case 0:
      break;
    case 2:
      u += "==";
      break;
    case 3:
      u += "=";
      break;
    default:
      throw "Illegal base64url string!";
  }
  try {
    return function(c) {
      return decodeURIComponent(r$2(c).replace(/(.)/g, function(l, v) {
        var p = v.charCodeAt(0).toString(16).toUpperCase();
        return p.length < 2 && (p = "0" + p), "%" + p;
      }));
    }(u);
  } catch {
    return r$2(u);
  }
}
function n(a) {
  this.message = a;
}
function o(a, u) {
  if (typeof a != "string")
    throw new n("Invalid token specified");
  var c = (u = u || {}).header === !0 ? 0 : 1;
  try {
    return JSON.parse(t(a.split(".")[c]));
  } catch (l) {
    throw new n("Invalid token specified: " + l.message);
  }
}
n.prototype = new Error(), n.prototype.name = "InvalidTokenError";
const jwtDecode_esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  InvalidTokenError: n,
  default: o
}, Symbol.toStringTag, { value: "Module" })), require$$0$3 = /* @__PURE__ */ getAugmentedNamespace(jwtDecode_esm);
var getRandomValues, rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues && (getRandomValues = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto < "u" && typeof msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto), !getRandomValues))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return getRandomValues(rnds8);
}
const REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function validate$2(a) {
  return typeof a == "string" && REGEX.test(a);
}
var byteToHex = [];
for (var i$2 = 0; i$2 < 256; ++i$2)
  byteToHex.push((i$2 + 256).toString(16).substr(1));
function stringify(a) {
  var u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, c = (byteToHex[a[u + 0]] + byteToHex[a[u + 1]] + byteToHex[a[u + 2]] + byteToHex[a[u + 3]] + "-" + byteToHex[a[u + 4]] + byteToHex[a[u + 5]] + "-" + byteToHex[a[u + 6]] + byteToHex[a[u + 7]] + "-" + byteToHex[a[u + 8]] + byteToHex[a[u + 9]] + "-" + byteToHex[a[u + 10]] + byteToHex[a[u + 11]] + byteToHex[a[u + 12]] + byteToHex[a[u + 13]] + byteToHex[a[u + 14]] + byteToHex[a[u + 15]]).toLowerCase();
  if (!validate$2(c))
    throw TypeError("Stringified UUID is invalid");
  return c;
}
var _nodeId, _clockseq, _lastMSecs = 0, _lastNSecs = 0;
function v1(a, u, c) {
  var l = u && c || 0, v = u || new Array(16);
  a = a || {};
  var p = a.node || _nodeId, _ = a.clockseq !== void 0 ? a.clockseq : _clockseq;
  if (p == null || _ == null) {
    var k = a.random || (a.rng || rng)();
    p == null && (p = _nodeId = [k[0] | 1, k[1], k[2], k[3], k[4], k[5]]), _ == null && (_ = _clockseq = (k[6] << 8 | k[7]) & 16383);
  }
  var O = a.msecs !== void 0 ? a.msecs : Date.now(), D = a.nsecs !== void 0 ? a.nsecs : _lastNSecs + 1, F = O - _lastMSecs + (D - _lastNSecs) / 1e4;
  if (F < 0 && a.clockseq === void 0 && (_ = _ + 1 & 16383), (F < 0 || O > _lastMSecs) && a.nsecs === void 0 && (D = 0), D >= 1e4)
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  _lastMSecs = O, _lastNSecs = D, _clockseq = _, O += 122192928e5;
  var H = ((O & 268435455) * 1e4 + D) % 4294967296;
  v[l++] = H >>> 24 & 255, v[l++] = H >>> 16 & 255, v[l++] = H >>> 8 & 255, v[l++] = H & 255;
  var Z = O / 4294967296 * 1e4 & 268435455;
  v[l++] = Z >>> 8 & 255, v[l++] = Z & 255, v[l++] = Z >>> 24 & 15 | 16, v[l++] = Z >>> 16 & 255, v[l++] = _ >>> 8 | 128, v[l++] = _ & 255;
  for (var ee = 0; ee < 6; ++ee)
    v[l + ee] = p[ee];
  return u || stringify(v);
}
function parse$3(a) {
  if (!validate$2(a))
    throw TypeError("Invalid UUID");
  var u, c = new Uint8Array(16);
  return c[0] = (u = parseInt(a.slice(0, 8), 16)) >>> 24, c[1] = u >>> 16 & 255, c[2] = u >>> 8 & 255, c[3] = u & 255, c[4] = (u = parseInt(a.slice(9, 13), 16)) >>> 8, c[5] = u & 255, c[6] = (u = parseInt(a.slice(14, 18), 16)) >>> 8, c[7] = u & 255, c[8] = (u = parseInt(a.slice(19, 23), 16)) >>> 8, c[9] = u & 255, c[10] = (u = parseInt(a.slice(24, 36), 16)) / 1099511627776 & 255, c[11] = u / 4294967296 & 255, c[12] = u >>> 24 & 255, c[13] = u >>> 16 & 255, c[14] = u >>> 8 & 255, c[15] = u & 255, c;
}
function stringToBytes(a) {
  a = unescape(encodeURIComponent(a));
  for (var u = [], c = 0; c < a.length; ++c)
    u.push(a.charCodeAt(c));
  return u;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8", URL$1 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35(a, u, c) {
  function l(v, p, _, k) {
    if (typeof v == "string" && (v = stringToBytes(v)), typeof p == "string" && (p = parse$3(p)), p.length !== 16)
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    var O = new Uint8Array(16 + v.length);
    if (O.set(p), O.set(v, p.length), O = c(O), O[6] = O[6] & 15 | u, O[8] = O[8] & 63 | 128, _) {
      k = k || 0;
      for (var D = 0; D < 16; ++D)
        _[k + D] = O[D];
      return _;
    }
    return stringify(O);
  }
  try {
    l.name = a;
  } catch {
  }
  return l.DNS = DNS, l.URL = URL$1, l;
}
function md5$3(a) {
  if (typeof a == "string") {
    var u = unescape(encodeURIComponent(a));
    a = new Uint8Array(u.length);
    for (var c = 0; c < u.length; ++c)
      a[c] = u.charCodeAt(c);
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(a), a.length * 8));
}
function md5ToHexEncodedArray(a) {
  for (var u = [], c = a.length * 32, l = "0123456789abcdef", v = 0; v < c; v += 8) {
    var p = a[v >> 5] >>> v % 32 & 255, _ = parseInt(l.charAt(p >>> 4 & 15) + l.charAt(p & 15), 16);
    u.push(_);
  }
  return u;
}
function getOutputLength(a) {
  return (a + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(a, u) {
  a[u >> 5] |= 128 << u % 32, a[getOutputLength(u) - 1] = u;
  for (var c = 1732584193, l = -271733879, v = -1732584194, p = 271733878, _ = 0; _ < a.length; _ += 16) {
    var k = c, O = l, D = v, F = p;
    c = md5ff(c, l, v, p, a[_], 7, -680876936), p = md5ff(p, c, l, v, a[_ + 1], 12, -389564586), v = md5ff(v, p, c, l, a[_ + 2], 17, 606105819), l = md5ff(l, v, p, c, a[_ + 3], 22, -1044525330), c = md5ff(c, l, v, p, a[_ + 4], 7, -176418897), p = md5ff(p, c, l, v, a[_ + 5], 12, 1200080426), v = md5ff(v, p, c, l, a[_ + 6], 17, -1473231341), l = md5ff(l, v, p, c, a[_ + 7], 22, -45705983), c = md5ff(c, l, v, p, a[_ + 8], 7, 1770035416), p = md5ff(p, c, l, v, a[_ + 9], 12, -1958414417), v = md5ff(v, p, c, l, a[_ + 10], 17, -42063), l = md5ff(l, v, p, c, a[_ + 11], 22, -1990404162), c = md5ff(c, l, v, p, a[_ + 12], 7, 1804603682), p = md5ff(p, c, l, v, a[_ + 13], 12, -40341101), v = md5ff(v, p, c, l, a[_ + 14], 17, -1502002290), l = md5ff(l, v, p, c, a[_ + 15], 22, 1236535329), c = md5gg(c, l, v, p, a[_ + 1], 5, -165796510), p = md5gg(p, c, l, v, a[_ + 6], 9, -1069501632), v = md5gg(v, p, c, l, a[_ + 11], 14, 643717713), l = md5gg(l, v, p, c, a[_], 20, -373897302), c = md5gg(c, l, v, p, a[_ + 5], 5, -701558691), p = md5gg(p, c, l, v, a[_ + 10], 9, 38016083), v = md5gg(v, p, c, l, a[_ + 15], 14, -660478335), l = md5gg(l, v, p, c, a[_ + 4], 20, -405537848), c = md5gg(c, l, v, p, a[_ + 9], 5, 568446438), p = md5gg(p, c, l, v, a[_ + 14], 9, -1019803690), v = md5gg(v, p, c, l, a[_ + 3], 14, -187363961), l = md5gg(l, v, p, c, a[_ + 8], 20, 1163531501), c = md5gg(c, l, v, p, a[_ + 13], 5, -1444681467), p = md5gg(p, c, l, v, a[_ + 2], 9, -51403784), v = md5gg(v, p, c, l, a[_ + 7], 14, 1735328473), l = md5gg(l, v, p, c, a[_ + 12], 20, -1926607734), c = md5hh(c, l, v, p, a[_ + 5], 4, -378558), p = md5hh(p, c, l, v, a[_ + 8], 11, -2022574463), v = md5hh(v, p, c, l, a[_ + 11], 16, 1839030562), l = md5hh(l, v, p, c, a[_ + 14], 23, -35309556), c = md5hh(c, l, v, p, a[_ + 1], 4, -1530992060), p = md5hh(p, c, l, v, a[_ + 4], 11, 1272893353), v = md5hh(v, p, c, l, a[_ + 7], 16, -155497632), l = md5hh(l, v, p, c, a[_ + 10], 23, -1094730640), c = md5hh(c, l, v, p, a[_ + 13], 4, 681279174), p = md5hh(p, c, l, v, a[_], 11, -358537222), v = md5hh(v, p, c, l, a[_ + 3], 16, -722521979), l = md5hh(l, v, p, c, a[_ + 6], 23, 76029189), c = md5hh(c, l, v, p, a[_ + 9], 4, -640364487), p = md5hh(p, c, l, v, a[_ + 12], 11, -421815835), v = md5hh(v, p, c, l, a[_ + 15], 16, 530742520), l = md5hh(l, v, p, c, a[_ + 2], 23, -995338651), c = md5ii(c, l, v, p, a[_], 6, -198630844), p = md5ii(p, c, l, v, a[_ + 7], 10, 1126891415), v = md5ii(v, p, c, l, a[_ + 14], 15, -1416354905), l = md5ii(l, v, p, c, a[_ + 5], 21, -57434055), c = md5ii(c, l, v, p, a[_ + 12], 6, 1700485571), p = md5ii(p, c, l, v, a[_ + 3], 10, -1894986606), v = md5ii(v, p, c, l, a[_ + 10], 15, -1051523), l = md5ii(l, v, p, c, a[_ + 1], 21, -2054922799), c = md5ii(c, l, v, p, a[_ + 8], 6, 1873313359), p = md5ii(p, c, l, v, a[_ + 15], 10, -30611744), v = md5ii(v, p, c, l, a[_ + 6], 15, -1560198380), l = md5ii(l, v, p, c, a[_ + 13], 21, 1309151649), c = md5ii(c, l, v, p, a[_ + 4], 6, -145523070), p = md5ii(p, c, l, v, a[_ + 11], 10, -1120210379), v = md5ii(v, p, c, l, a[_ + 2], 15, 718787259), l = md5ii(l, v, p, c, a[_ + 9], 21, -343485551), c = safeAdd(c, k), l = safeAdd(l, O), v = safeAdd(v, D), p = safeAdd(p, F);
  }
  return [c, l, v, p];
}
function bytesToWords(a) {
  if (a.length === 0)
    return [];
  for (var u = a.length * 8, c = new Uint32Array(getOutputLength(u)), l = 0; l < u; l += 8)
    c[l >> 5] |= (a[l / 8] & 255) << l % 32;
  return c;
}
function safeAdd(a, u) {
  var c = (a & 65535) + (u & 65535), l = (a >> 16) + (u >> 16) + (c >> 16);
  return l << 16 | c & 65535;
}
function bitRotateLeft(a, u) {
  return a << u | a >>> 32 - u;
}
function md5cmn(a, u, c, l, v, p) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(u, a), safeAdd(l, p)), v), c);
}
function md5ff(a, u, c, l, v, p, _) {
  return md5cmn(u & c | ~u & l, a, u, v, p, _);
}
function md5gg(a, u, c, l, v, p, _) {
  return md5cmn(u & l | c & ~l, a, u, v, p, _);
}
function md5hh(a, u, c, l, v, p, _) {
  return md5cmn(u ^ c ^ l, a, u, v, p, _);
}
function md5ii(a, u, c, l, v, p, _) {
  return md5cmn(c ^ (u | ~l), a, u, v, p, _);
}
var v3 = v35("v3", 48, md5$3);
const v3$1 = v3;
function v4(a, u, c) {
  a = a || {};
  var l = a.random || (a.rng || rng)();
  if (l[6] = l[6] & 15 | 64, l[8] = l[8] & 63 | 128, u) {
    c = c || 0;
    for (var v = 0; v < 16; ++v)
      u[c + v] = l[v];
    return u;
  }
  return stringify(l);
}
function f$1(a, u, c, l) {
  switch (a) {
    case 0:
      return u & c ^ ~u & l;
    case 1:
      return u ^ c ^ l;
    case 2:
      return u & c ^ u & l ^ c & l;
    case 3:
      return u ^ c ^ l;
  }
}
function ROTL(a, u) {
  return a << u | a >>> 32 - u;
}
function sha1$1(a) {
  var u = [1518500249, 1859775393, 2400959708, 3395469782], c = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof a == "string") {
    var l = unescape(encodeURIComponent(a));
    a = [];
    for (var v = 0; v < l.length; ++v)
      a.push(l.charCodeAt(v));
  } else
    Array.isArray(a) || (a = Array.prototype.slice.call(a));
  a.push(128);
  for (var p = a.length / 4 + 2, _ = Math.ceil(p / 16), k = new Array(_), O = 0; O < _; ++O) {
    for (var D = new Uint32Array(16), F = 0; F < 16; ++F)
      D[F] = a[O * 64 + F * 4] << 24 | a[O * 64 + F * 4 + 1] << 16 | a[O * 64 + F * 4 + 2] << 8 | a[O * 64 + F * 4 + 3];
    k[O] = D;
  }
  k[_ - 1][14] = (a.length - 1) * 8 / Math.pow(2, 32), k[_ - 1][14] = Math.floor(k[_ - 1][14]), k[_ - 1][15] = (a.length - 1) * 8 & 4294967295;
  for (var H = 0; H < _; ++H) {
    for (var Z = new Uint32Array(80), ee = 0; ee < 16; ++ee)
      Z[ee] = k[H][ee];
    for (var X = 16; X < 80; ++X)
      Z[X] = ROTL(Z[X - 3] ^ Z[X - 8] ^ Z[X - 14] ^ Z[X - 16], 1);
    for (var ne = c[0], Q = c[1], ae = c[2], j = c[3], ue = c[4], he = 0; he < 80; ++he) {
      var fe = Math.floor(he / 20), be = ROTL(ne, 5) + f$1(fe, Q, ae, j) + ue + u[fe] + Z[he] >>> 0;
      ue = j, j = ae, ae = ROTL(Q, 30) >>> 0, Q = ne, ne = be;
    }
    c[0] = c[0] + ne >>> 0, c[1] = c[1] + Q >>> 0, c[2] = c[2] + ae >>> 0, c[3] = c[3] + j >>> 0, c[4] = c[4] + ue >>> 0;
  }
  return [c[0] >> 24 & 255, c[0] >> 16 & 255, c[0] >> 8 & 255, c[0] & 255, c[1] >> 24 & 255, c[1] >> 16 & 255, c[1] >> 8 & 255, c[1] & 255, c[2] >> 24 & 255, c[2] >> 16 & 255, c[2] >> 8 & 255, c[2] & 255, c[3] >> 24 & 255, c[3] >> 16 & 255, c[3] >> 8 & 255, c[3] & 255, c[4] >> 24 & 255, c[4] >> 16 & 255, c[4] >> 8 & 255, c[4] & 255];
}
var v5 = v35("v5", 80, sha1$1);
const v5$1 = v5, nil = "00000000-0000-0000-0000-000000000000";
function version$5(a) {
  if (!validate$2(a))
    throw TypeError("Invalid UUID");
  return parseInt(a.substr(14, 1), 16);
}
const esmBrowser = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  NIL: nil,
  parse: parse$3,
  stringify,
  v1,
  v3: v3$1,
  v4,
  v5: v5$1,
  validate: validate$2,
  version: version$5
}, Symbol.toStringTag, { value: "Module" })), require$$1$4 = /* @__PURE__ */ getAugmentedNamespace(esmBrowser);
let EnhancedMap$1 = class extends Map {
  /**
   * If key has a mapping already returns the currently associated value. If
   * there is no mapping, calls the computer which must return a value V.
   * The value is then stored for given key and returned.
   * @param key Key
   * @param computer Computer which is called only if key has no mapping yet.
   * @return Existing value if the key already existed, or the newly computed value.
   */
  computeIfAbsent(u, c) {
    if (this.has(u))
      return this.get(u);
    const l = c(u);
    return this.set(u, l), l;
  }
  /**
   * If the key exists already calls given computer, if the key does not exist
   * this method does nothing.
   *
   * The computer is called with current key and current value associated. The
   * computer can return a (new) value V or undefined. When undefined is returned
   * the key is removed from this map, when a V is returned the key is updated
   * with the new value V.
   * @param key Key
   * @param computer Computer which is called only if the key has a mapping already
   * @return Undefined if the key has no mapping, otherwise the value returned from computer
   */
  computeIfPresent(u, c) {
    const l = this.get(u);
    if (l === void 0)
      return;
    const v = c(u, l);
    return v !== void 0 ? this.set(u, v) : this.delete(u), v;
  }
  /**
   * Computes a value for given key, the computer can return a value V (in which case the map
   * will set the value for given key), if it returns undefined the mapping for key K will be
   * removed.
   * @param key Key to compute
   * @param computer Computer which is called, note that the currentValue argument contains the existing
   *                 value or is undefined when no mapping exists for the key.
   * @return The newly computed value
   */
  compute(u, c) {
    const l = this.get(u), v = c(u, l);
    return v ? this.set(u, v) : this.delete(u), v;
  }
};
var InternalLogLevel$1;
(function(a) {
  a[a.Trace = 0] = "Trace", a[a.Debug = 1] = "Debug", a[a.Info = 2] = "Info", a[a.Warn = 3] = "Warn", a[a.Error = 4] = "Error";
})(InternalLogLevel$1 || (InternalLogLevel$1 = {}));
function getInternalLogger$1(a) {
  return provider$1.getLogger(a);
}
const INTERNAL_LOGGING_SETTINGS$1 = {
  /**
   * Changes the log level for the internal logging (for all new and existing loggers)
   * @param level New log level
   */
  setInternalLogLevel: (a) => provider$1.changeLogLevel(a),
  /**
   * Changes where messages are written to for all new and existing loggers),
   * by default they are written to the console.
   * @param fnOutput Function to write messages to
   */
  setOutput: (a) => provider$1.changeOutput(a),
  /**
   * Resets the log level and output back to defaults (level to error and writing to console)
   * for all new and existing loggers.
   */
  reset: () => provider$1.reset()
};
let InternalLoggerImpl$1 = class {
  constructor(u, c, l) {
    this._name = u, this._level = c, this._fnOutput = l;
  }
  trace(u) {
    this.log(InternalLogLevel$1.Trace, u);
  }
  debug(u) {
    this.log(InternalLogLevel$1.Debug, u);
  }
  error(u, c) {
    this.log(InternalLogLevel$1.Error, u, c);
  }
  info(u) {
    this.log(InternalLogLevel$1.Info, u);
  }
  warn(u, c) {
    this.log(InternalLogLevel$1.Warn, u, c);
  }
  setLevel(u) {
    this._level = u;
  }
  setOutput(u) {
    this._fnOutput = u;
  }
  log(u, c, l) {
    this._level > u || this._fnOutput(`${InternalLogLevel$1[this._level].toString()} <INTERNAL LOGGER> ${this._name} ${c()}${l ? `
` + l.stack : ""}`);
  }
}, InternalProviderImpl$1 = class Kt {
  constructor() {
    this._loggers = new EnhancedMap$1(), this._logLevel = InternalLogLevel$1.Error, this._fnOutput = Kt.logConsole;
  }
  getLogger(u) {
    return this._loggers.computeIfAbsent(u, (c) => new InternalLoggerImpl$1(c, this._logLevel, this._fnOutput));
  }
  changeLogLevel(u) {
    this._logLevel = u, this._loggers.forEach((c) => c.setLevel(u));
  }
  changeOutput(u) {
    this._fnOutput = u, this._loggers.forEach((c) => c.setOutput(this._fnOutput));
  }
  reset() {
    this.changeLogLevel(InternalLogLevel$1.Error), this._fnOutput = Kt.logConsole, this._loggers.forEach((u) => u.setOutput(this._fnOutput));
  }
  static logConsole(u) {
    console && console.log && console.log(u);
  }
};
const provider$1 = new InternalProviderImpl$1();
var InternalLogger$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  get InternalLogLevel() {
    return InternalLogLevel$1;
  },
  getInternalLogger: getInternalLogger$1,
  INTERNAL_LOGGING_SETTINGS: INTERNAL_LOGGING_SETTINGS$1
}), LogLevel$2;
(function(a) {
  a[a.Trace = 0] = "Trace", a[a.Debug = 1] = "Debug", a[a.Info = 2] = "Info", a[a.Warn = 3] = "Warn", a[a.Error = 4] = "Error", a[a.Fatal = 5] = "Fatal";
})(LogLevel$2 || (LogLevel$2 = {}));
(function(a) {
  function u(c) {
    switch (c.toLowerCase()) {
      case "trace":
        return a.Trace;
      case "debug":
        return a.Debug;
      case "info":
        return a.Info;
      case "warn":
        return a.Warn;
      case "error":
        return a.Error;
      case "fatal":
        return a.Fatal;
      default:
        return;
    }
  }
  a.toLogLevel = u;
})(LogLevel$2 || (LogLevel$2 = {}));
let CoreLoggerImpl$1 = class mi {
  constructor(u) {
    this._runtime = u;
  }
  get id() {
    return this._runtime.id;
  }
  get logLevel() {
    return this._runtime.level;
  }
  get runtimeSettings() {
    return Object.assign({}, this._runtime);
  }
  set runtimeSettings(u) {
    this._runtime = u;
  }
  trace(u, ...c) {
    this.logMessage(LogLevel$2.Trace, u, c);
  }
  debug(u, ...c) {
    this.logMessage(LogLevel$2.Debug, u, c);
  }
  info(u, ...c) {
    this.logMessage(LogLevel$2.Info, u, c);
  }
  warn(u, ...c) {
    this.logMessage(LogLevel$2.Warn, u, c);
  }
  error(u, ...c) {
    this.logMessage(LogLevel$2.Error, u, c);
  }
  fatal(u, ...c) {
    this.logMessage(LogLevel$2.Fatal, u, c);
  }
  logMessage(u, c, l) {
    if (this._runtime.level > u)
      return;
    const v = Date.now(), p = typeof c == "string" ? c : c(), _ = mi.getErrorAndArgs(l);
    switch (this._runtime.channel.type) {
      case "RawLogChannel":
        this._runtime.channel.write({
          message: p,
          exception: _.error,
          args: _.args,
          timeInMillis: v,
          level: u,
          logNames: this._runtime.name
        }, this._runtime.argumentFormatter);
        return;
      case "LogChannel":
        this._runtime.channel.write(this.createLogMessage(p, u, _, v));
        break;
    }
  }
  formatArgValue(u) {
    try {
      return this._runtime.argumentFormatter(u);
    } catch {
      return `>>ARG CONVERT FAILED: '${u !== void 0 ? u.toString() : "undefined"}'<<`;
    }
  }
  createLogMessage(u, c, l, v) {
    let p;
    const _ = l.error, k = l.args;
    _ && (p = `${_.name}: ${_.message}`, _.stack && (p += `@
${_.stack}`));
    const O = this._runtime.dateFormatter(v);
    let D = LogLevel$2[c].toUpperCase();
    D.length < 5 && (D += " ");
    const F = typeof this._runtime.name == "string" ? this._runtime.name : this._runtime.name.join(", "), H = typeof k < "u" && k.length > 0 ? " [" + k.map((ee) => this.formatArgValue(ee)).join(", ") + "]" : "";
    return {
      message: O + " " + D + " [" + F + "] " + u + H,
      error: p
    };
  }
  static getErrorAndArgs(u) {
    if (u.length === 0)
      return {};
    let c, l;
    const v = u[0];
    if (v instanceof Error)
      return c = v, l = u.length > 1 ? u.slice(1) : void 0, { error: c, args: l };
    if (typeof v == "function") {
      const p = v();
      return p instanceof Error ? (c = p, l = u.length > 1 ? u.slice(1) : void 0, { error: c, args: l }) : u.length === 1 ? Array.isArray(p) ? { args: p.length > 0 ? p : void 0 } : { args: p } : Array.isArray(p) ? { args: [...p, ...u.slice(1)] } : { args: [p, ...u.slice(1)] };
    }
    return { args: u };
  }
};
function padStart$1(a, u, c = " ") {
  return padInternal$1(a, u, "start", c);
}
function padEnd$1(a, u, c = " ") {
  return padInternal$1(a, u, "end", c);
}
function maxLengthStringValueInArray$1(a) {
  return a.map((u) => u.length).reduce((u, c) => c > u ? c : u, 0);
}
function padInternal$1(a, u, c, l = " ") {
  if (u <= a.length)
    return a;
  if (l.length > 1)
    throw new Error(`Fill char must be one char exactly, it is: ${l.length}`);
  const v = u - a.length;
  let p = "";
  for (let _ = 0; _ < v; _++)
    p += l;
  return c === "start" ? p + a : a + p;
}
function formatArgument$1(a) {
  return a === void 0 ? "undefined" : JSON.stringify(a);
}
function formatDate$1(a) {
  const u = new Date(a), c = u.getFullYear(), l = padStart$1((u.getMonth() + 1).toString(), 2, "0"), v = padStart$1(u.getDate().toString(), 2, "0"), p = padStart$1(u.getHours().toString(), 2, "0"), _ = padStart$1(u.getMinutes().toString(), 2, "0"), k = padStart$1(u.getSeconds().toString(), 2, "0"), O = padStart$1(u.getMilliseconds().toString(), 2, "0");
  return `${c}-${l}-${v} ${p}:${_}:${k},${O}`;
}
let ConsoleLogChannel$1 = class {
  constructor() {
    this.type = "LogChannel";
  }
  write(u) {
    console && console.log && console.log(u.message + (u.error ? `
${u.error}` : ""));
  }
};
var DefaultChannels$1;
(function(a) {
  function u() {
    return new ConsoleLogChannel$1();
  }
  a.createConsoleChannel = u;
})(DefaultChannels$1 || (DefaultChannels$1 = {}));
let LogProviderImpl$1 = class Wt {
  constructor(u, c) {
    this._log = getInternalLogger$1("core.impl.LogProviderImpl"), this._name = u, this._settings = c, this._loggers = new EnhancedMap$1(), this._idToKeyMap = new EnhancedMap$1(), this._globalRuntimeSettings = { level: c.level, channel: c.channel }, this._nextLoggerId = 1, this._log.trace(() => `Created LogProviderImpl with settings: ${JSON.stringify(this._settings)}`);
  }
  get runtimeSettings() {
    return Object.assign(Object.assign({}, this._settings), { level: this._globalRuntimeSettings.level, channel: this._globalRuntimeSettings.channel });
  }
  getLogger(u) {
    return this.getOrCreateLogger(u);
  }
  updateLoggerRuntime(u, c) {
    this._log.debug(() => `Updating logger ${u.id} runtime settings using: '${JSON.stringify(c)}'`);
    const l = this._idToKeyMap.get(u.id);
    return l === void 0 ? (this._log.warn(() => `Cannot update logger with id: ${u.id}, it was not found.`), !1) : (this._loggers.computeIfPresent(l, (v, p) => (p.runtimeSettings = Wt.mergeRuntimeSettingsIntoLogRuntime(p.runtimeSettings, c), p)), !0);
  }
  updateRuntimeSettings(u) {
    this._log.debug(() => `Updating global runtime settings and updating existing loggers runtime settings using: '${JSON.stringify(u)}'`), this._globalRuntimeSettings = {
      /* It's unclear, but not checking explicitly on undefined here makes the test fail, it makes no sense as level is a number | undefined essentially. */
      level: u.level !== void 0 ? u.level : this._globalRuntimeSettings.level,
      channel: u.channel !== void 0 ? u.channel : this._globalRuntimeSettings.channel
    }, this._loggers.forEach((c) => c.runtimeSettings = Wt.mergeRuntimeSettingsIntoLogRuntime(c.runtimeSettings, u));
  }
  /**
   * Removes all state and loggers, it reverts back to as it was after initial construction.
   */
  clear() {
    this._loggers.clear(), this._idToKeyMap.clear(), this._globalRuntimeSettings = Object.assign({}, this._settings), this._nextLoggerId = 1;
  }
  getOrCreateLogger(u) {
    const c = Wt.createKey(u), l = this._loggers.computeIfAbsent(c, () => {
      const v = {
        level: this._globalRuntimeSettings.level,
        channel: this._globalRuntimeSettings.channel,
        id: this.nextLoggerId(),
        name: u,
        argumentFormatter: this._settings.argumentFormatter,
        dateFormatter: this._settings.dateFormatter
      };
      return new CoreLoggerImpl$1(v);
    });
    return this._idToKeyMap.computeIfAbsent(l.id, () => c), l;
  }
  nextLoggerId() {
    const u = this._name + "_" + this._nextLoggerId;
    return this._nextLoggerId++, u;
  }
  static mergeRuntimeSettingsIntoLogRuntime(u, c) {
    return Object.assign(Object.assign({}, u), {
      /* It's unclear, but not checking explicitly on undefined here makes the test fail, it makes no sense as level is a number | undefined essentially. */
      level: c.level !== void 0 ? c.level : u.level,
      channel: c.channel !== void 0 ? c.channel : u.channel
    });
  }
  static createKey(u) {
    return typeof u == "string" ? u : u.join(",");
  }
};
function createLogProvider$1(a, u) {
  return new LogProviderImpl$1(a, u);
}
var index$4 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  EnhancedMap: EnhancedMap$1,
  padStart: padStart$1,
  padEnd: padEnd$1,
  maxLengthStringValueInArray: maxLengthStringValueInArray$1
});
class ArrayLogChannel {
  constructor() {
    this._buffer = [], this.type = "LogChannel";
  }
  write(u) {
    this._buffer.push(u);
  }
  get logMessages() {
    return this._buffer;
  }
  get messages() {
    return this._buffer.map((u) => u.message);
  }
}
class ArrayRawLogChannel {
  constructor() {
    this._buffer = [], this.type = "RawLogChannel";
  }
  write(u, c) {
    this._buffer.push(u);
  }
  get messages() {
    return this._buffer.map((u) => u.message);
  }
  get errors() {
    return this._buffer.map((u) => u.exception);
  }
  get size() {
    return this._buffer.length;
  }
  get rawMessages() {
    return this._buffer;
  }
  clear() {
    this._buffer = [];
  }
}
class TestControlMessage {
  constructor() {
    this._messages = [], this.write = this.write.bind(this);
  }
  get messages() {
    return this._messages;
  }
  write(u) {
    this._messages.push(u);
  }
  clear() {
    this._messages = [];
  }
}
var TestClasses = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArrayLogChannel,
  ArrayRawLogChannel,
  TestControlMessage
});
const typescriptLogging_esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  $internal: InternalLogger$1,
  $test: TestClasses,
  get DefaultChannels() {
    return DefaultChannels$1;
  },
  get LogLevel() {
    return LogLevel$2;
  },
  createLogProvider: createLogProvider$1,
  formatArgument: formatArgument$1,
  formatDate: formatDate$1,
  util: index$4
}, Symbol.toStringTag, { value: "Module" })), require$$2$2 = /* @__PURE__ */ getAugmentedNamespace(typescriptLogging_esm);
var layoutapi = {}, lib$1 = {}, lib = {}, Metadata = {};
Object.defineProperty(Metadata, "__esModule", { value: !0 });
Metadata.Metadata = void 0;
Metadata.Metadata = function(u) {
  const c = /* @__PURE__ */ new Map(), l = {
    set(v, p) {
      if (v = normalizeKey(v), Array.isArray(p))
        if (p.length === 0)
          c.delete(v);
        else {
          for (const _ of p)
            validate$1(v, _);
          c.set(v, v.endsWith("-bin") ? p : [p.join(", ")]);
        }
      else
        validate$1(v, p), c.set(v, [p]);
      return l;
    },
    append(v, p) {
      v = normalizeKey(v), validate$1(v, p);
      let _ = c.get(v);
      return _ == null && (_ = [], c.set(v, _)), _.push(p), v.endsWith("-bin") || c.set(v, [_.join(", ")]), l;
    },
    delete(v) {
      v = normalizeKey(v), c.delete(v);
    },
    get(v) {
      var p;
      return v = normalizeKey(v), (p = c.get(v)) === null || p === void 0 ? void 0 : p[0];
    },
    getAll(v) {
      var p;
      return v = normalizeKey(v), (p = c.get(v)) !== null && p !== void 0 ? p : [];
    },
    has(v) {
      return v = normalizeKey(v), c.has(v);
    },
    [Symbol.iterator]() {
      return c[Symbol.iterator]();
    }
  };
  if (u != null) {
    const v = isIterable$1(u) ? u : Object.entries(u);
    for (const [p, _] of v)
      l.set(p, _);
  }
  return l;
};
function normalizeKey(a) {
  return a.toLowerCase();
}
function validate$1(a, u) {
  if (!/^[0-9a-z_.-]+$/.test(a))
    throw new Error(`Metadata key '${a}' contains illegal characters`);
  if (a.endsWith("-bin")) {
    if (!(u instanceof Uint8Array))
      throw new Error(`Metadata key '${a}' ends with '-bin', thus it must have binary value`);
  } else {
    if (typeof u != "string")
      throw new Error(`Metadata key '${a}' doesn't end with '-bin', thus it must have string value`);
    if (!/^[ -~]*$/.test(u))
      throw new Error(`Metadata value '${u}' of key '${a}' contains illegal characters`);
  }
}
function isIterable$1(a) {
  return Symbol.iterator in a;
}
var Status = {};
(function(a) {
  Object.defineProperty(a, "__esModule", { value: !0 }), a.Status = void 0, function(u) {
    u[u.OK = 0] = "OK", u[u.CANCELLED = 1] = "CANCELLED", u[u.UNKNOWN = 2] = "UNKNOWN", u[u.INVALID_ARGUMENT = 3] = "INVALID_ARGUMENT", u[u.DEADLINE_EXCEEDED = 4] = "DEADLINE_EXCEEDED", u[u.NOT_FOUND = 5] = "NOT_FOUND", u[u.ALREADY_EXISTS = 6] = "ALREADY_EXISTS", u[u.PERMISSION_DENIED = 7] = "PERMISSION_DENIED", u[u.RESOURCE_EXHAUSTED = 8] = "RESOURCE_EXHAUSTED", u[u.FAILED_PRECONDITION = 9] = "FAILED_PRECONDITION", u[u.ABORTED = 10] = "ABORTED", u[u.OUT_OF_RANGE = 11] = "OUT_OF_RANGE", u[u.UNIMPLEMENTED = 12] = "UNIMPLEMENTED", u[u.INTERNAL = 13] = "INTERNAL", u[u.UNAVAILABLE = 14] = "UNAVAILABLE", u[u.DATA_LOSS = 15] = "DATA_LOSS", u[u.UNAUTHENTICATED = 16] = "UNAUTHENTICATED";
  }(a.Status || (a.Status = {}));
})(Status);
var MethodDescriptor = {};
Object.defineProperty(MethodDescriptor, "__esModule", { value: !0 });
var CallOptions = {};
Object.defineProperty(CallOptions, "__esModule", { value: !0 });
var ClientMiddleware = {};
Object.defineProperty(ClientMiddleware, "__esModule", { value: !0 });
var composeClientMiddleware$1 = {};
Object.defineProperty(composeClientMiddleware$1, "__esModule", { value: !0 });
composeClientMiddleware$1.composeClientMiddleware = void 0;
function composeClientMiddleware(a, u) {
  return (c, l) => u({
    ...c,
    next: (v, p) => a({ ...c, request: v }, p)
  }, l);
}
composeClientMiddleware$1.composeClientMiddleware = composeClientMiddleware;
var ClientError$1 = {}, cjs = {}, helpers = {};
helpers.__esModule = void 0;
helpers.__esModule = !0;
var objectSetPrototypeOfIsDefined = typeof Object.setPrototypeOf == "function", objectGetPrototypeOfIsDefined = typeof Object.getPrototypeOf == "function", objectDefinePropertyIsDefined = typeof Object.defineProperty == "function", objectCreateIsDefined = typeof Object.create == "function", objectHasOwnPropertyIsDefined = typeof Object.prototype.hasOwnProperty == "function", setPrototypeOf = function(u, c) {
  objectSetPrototypeOfIsDefined ? Object.setPrototypeOf(u, c) : u.__proto__ = c;
};
helpers.setPrototypeOf = setPrototypeOf;
var getPrototypeOf$1 = function(u) {
  return objectGetPrototypeOfIsDefined ? Object.getPrototypeOf(u) : u.__proto__ || u.prototype;
};
helpers.getPrototypeOf = getPrototypeOf$1;
var ie8ObjectDefinePropertyBug = !1, defineProperty$1 = function a(u, c, l) {
  if (objectDefinePropertyIsDefined && !ie8ObjectDefinePropertyBug)
    try {
      Object.defineProperty(u, c, l);
    } catch {
      ie8ObjectDefinePropertyBug = !0, a(u, c, l);
    }
  else
    u[c] = l.value;
};
helpers.defineProperty = defineProperty$1;
var hasOwnProperty$g = function(u, c) {
  return objectHasOwnPropertyIsDefined ? u.hasOwnProperty(u, c) : u[c] === void 0;
};
helpers.hasOwnProperty = hasOwnProperty$g;
var objectCreate$1 = function(u, c) {
  if (objectCreateIsDefined)
    return Object.create(u, c);
  var l = function() {
  };
  l.prototype = u;
  var v = new l();
  if (typeof c > "u")
    return v;
  if (typeof c == "null")
    throw new Error("PropertyDescriptors must not be null.");
  if (typeof c == "object")
    for (var p in c)
      hasOwnProperty$g(c, p) && (v[p] = c[p].value);
  return v;
};
helpers.objectCreate = objectCreate$1;
(function(a) {
  a.__esModule = void 0, a.__esModule = !0;
  var u = helpers, c = u.setPrototypeOf, l = u.getPrototypeOf, v = u.defineProperty, p = u.objectCreate, _ = new Error().toString() === "[object Error]", k = "";
  function O(D) {
    var F = this.constructor, H = F.name || function() {
      var Q = F.toString().match(/^function\s*([^\s(]+)/);
      return Q === null ? k || "Error" : Q[1];
    }(), Z = H === "Error", ee = Z ? k : H, X = Error.apply(this, arguments);
    if (c(X, l(this)), !(X instanceof F) || !(X instanceof O)) {
      var X = this;
      Error.apply(this, arguments), v(X, "message", {
        configurable: !0,
        enumerable: !1,
        value: D,
        writable: !0
      });
    }
    if (v(X, "name", {
      configurable: !0,
      enumerable: !1,
      value: ee,
      writable: !0
    }), Error.captureStackTrace && Error.captureStackTrace(
      X,
      Z ? O : F
    ), X.stack === void 0) {
      var ne = new Error(D);
      ne.name = X.name, X.stack = ne.stack;
    }
    return _ && v(X, "toString", {
      configurable: !0,
      enumerable: !1,
      value: function() {
        return (this.name || "Error") + (typeof this.message > "u" ? "" : ": " + this.message);
      },
      writable: !0
    }), X;
  }
  k = O.name || "ExtendableError", O.prototype = p(Error.prototype, {
    constructor: {
      value: Error,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }), a.ExtendableError = O, a.default = a.ExtendableError;
})(cjs);
Object.defineProperty(ClientError$1, "__esModule", { value: !0 });
ClientError$1.ClientError = void 0;
const ts_error_1$1 = cjs, Status_1$1 = Status;
class ClientError extends ts_error_1$1.ExtendableError {
  constructor(u, c, l) {
    super(`${u} ${Status_1$1.Status[c]}: ${l}`), this.path = u, this.code = c, this.details = l, this.name = "ClientError", Object.defineProperty(this, "@@nice-grpc", {
      value: !0
    }), Object.defineProperty(this, "@@nice-grpc:ClientError", {
      value: !0
    });
  }
  static [Symbol.hasInstance](u) {
    return this !== ClientError ? this.prototype.isPrototypeOf(u) : typeof u == "object" && u !== null && (u.constructor === ClientError || u["@@nice-grpc:ClientError"] === !0 || u.name === "ClientError" && u["@@nice-grpc"] === !0);
  }
}
ClientError$1.ClientError = ClientError;
var CallContext = {};
Object.defineProperty(CallContext, "__esModule", { value: !0 });
var ServerMiddleware = {};
Object.defineProperty(ServerMiddleware, "__esModule", { value: !0 });
var composeServerMiddleware$1 = {};
Object.defineProperty(composeServerMiddleware$1, "__esModule", { value: !0 });
composeServerMiddleware$1.composeServerMiddleware = void 0;
function composeServerMiddleware(a, u) {
  return (c, l) => a({
    ...c,
    next: (v, p) => u({ ...c, request: v }, p)
  }, l);
}
composeServerMiddleware$1.composeServerMiddleware = composeServerMiddleware;
var ServerError$1 = {};
Object.defineProperty(ServerError$1, "__esModule", { value: !0 });
ServerError$1.ServerError = void 0;
const ts_error_1 = cjs, Status_1 = Status;
class ServerError extends ts_error_1.ExtendableError {
  constructor(u, c) {
    super(`${Status_1.Status[u]}: ${c}`), this.code = u, this.details = c, this.name = "ServerError", Object.defineProperty(this, "@@nice-grpc", {
      value: !0
    }), Object.defineProperty(this, "@@nice-grpc:ServerError", {
      value: !0
    });
  }
  static [Symbol.hasInstance](u) {
    return this !== ServerError ? this.prototype.isPrototypeOf(u) : typeof u == "object" && u !== null && (u.constructor === ServerError || u["@@nice-grpc:ServerError"] === !0 || u.name === "ServerError" && u["@@nice-grpc"] === !0);
  }
}
ServerError$1.ServerError = ServerError;
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(l, v, p, _) {
    _ === void 0 && (_ = p);
    var k = Object.getOwnPropertyDescriptor(v, p);
    (!k || ("get" in k ? !v.__esModule : k.writable || k.configurable)) && (k = { enumerable: !0, get: function() {
      return v[p];
    } }), Object.defineProperty(l, _, k);
  } : function(l, v, p, _) {
    _ === void 0 && (_ = p), l[_] = v[p];
  }), c = commonjsGlobal$1 && commonjsGlobal$1.__exportStar || function(l, v) {
    for (var p in l)
      p !== "default" && !Object.prototype.hasOwnProperty.call(v, p) && u(v, l, p);
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), c(Metadata, a), c(Status, a), c(MethodDescriptor, a), c(CallOptions, a), c(ClientMiddleware, a), c(composeClientMiddleware$1, a), c(ClientError$1, a), c(CallContext, a), c(ServerMiddleware, a), c(composeServerMiddleware$1, a), c(ServerError$1, a);
})(lib);
var serviceDefinitions = {}, grpcWeb = {};
Object.defineProperty(grpcWeb, "__esModule", { value: !0 });
grpcWeb.isGrpcWebServiceDefinition = grpcWeb.fromGrpcWebServiceDefinition = void 0;
function fromGrpcWebServiceDefinition(a) {
  const u = {};
  for (const [c, l] of Object.entries(a)) {
    if (c === "serviceName")
      continue;
    const v = l;
    u[uncapitalize(c)] = {
      path: `/${a.serviceName}/${c}`,
      requestStream: v.requestStream,
      responseStream: v.responseStream,
      requestDeserialize: v.requestType.deserializeBinary,
      requestSerialize: (p) => p.serializeBinary(),
      responseDeserialize: v.responseType.deserializeBinary,
      responseSerialize: (p) => p.serializeBinary(),
      options: {}
    };
  }
  return u;
}
grpcWeb.fromGrpcWebServiceDefinition = fromGrpcWebServiceDefinition;
function isGrpcWebServiceDefinition(a) {
  return "prototype" in a;
}
grpcWeb.isGrpcWebServiceDefinition = isGrpcWebServiceDefinition;
function uncapitalize(a) {
  return a.length === 0 ? a : a[0].toLowerCase() + a.slice(1);
}
var tsProto = {};
Object.defineProperty(tsProto, "__esModule", { value: !0 });
tsProto.isTsProtoServiceDefinition = tsProto.fromTsProtoServiceDefinition = void 0;
function fromTsProtoServiceDefinition(a) {
  const u = {};
  for (const [c, l] of Object.entries(a.methods)) {
    const v = l.requestType.encode, p = l.requestType.fromPartial, _ = l.responseType.encode, k = l.responseType.fromPartial;
    u[c] = {
      path: `/${a.fullName}/${l.name}`,
      requestStream: l.requestStream,
      responseStream: l.responseStream,
      requestDeserialize: l.requestType.decode,
      requestSerialize: p != null ? (O) => v(p(O)).finish() : (O) => v(O).finish(),
      responseDeserialize: l.responseType.decode,
      responseSerialize: k != null ? (O) => _(k(O)).finish() : (O) => _(O).finish(),
      options: l.options
    };
  }
  return u;
}
tsProto.fromTsProtoServiceDefinition = fromTsProtoServiceDefinition;
function isTsProtoServiceDefinition(a) {
  return "name" in a && "fullName" in a && "methods" in a;
}
tsProto.isTsProtoServiceDefinition = isTsProtoServiceDefinition;
Object.defineProperty(serviceDefinitions, "__esModule", { value: !0 });
serviceDefinitions.toGrpcWebMethodDefinition = serviceDefinitions.normalizeServiceDefinition = void 0;
const grpc_web_1$5 = grpcWeb, ts_proto_1 = tsProto;
function normalizeServiceDefinition(a) {
  return (0, grpc_web_1$5.isGrpcWebServiceDefinition)(a) ? (0, grpc_web_1$5.fromGrpcWebServiceDefinition)(a) : (0, ts_proto_1.isTsProtoServiceDefinition)(a) ? (0, ts_proto_1.fromTsProtoServiceDefinition)(a) : a;
}
serviceDefinitions.normalizeServiceDefinition = normalizeServiceDefinition;
function toGrpcWebMethodDefinition(a) {
  const [, u, c] = a.path.split("/");
  return {
    service: {
      serviceName: u
    },
    methodName: c,
    requestStream: a.requestStream,
    responseStream: a.responseStream,
    requestType: class {
      constructor() {
        throw new Error("Unexpected instantiation");
      }
      static deserializeBinary(l) {
        return a.requestDeserialize(l);
      }
    },
    responseType: class {
      constructor() {
        throw new Error("Unexpected instantiation");
      }
      static deserializeBinary(l) {
        return a.responseDeserialize(l);
      }
    }
  };
}
serviceDefinitions.toGrpcWebMethodDefinition = toGrpcWebMethodDefinition;
var channel = {};
Object.defineProperty(channel, "__esModule", { value: !0 });
channel.createChannel = void 0;
function createChannel(a, u) {
  return { address: a, transport: u };
}
channel.createChannel = createChannel;
var ClientFactory = {}, createBidiStreamingMethod$1 = {}, grpcWebClient_umd = { exports: {} };
(function(a, u) {
  (function(c, l) {
    a.exports = l();
  })(commonjsGlobal$1, function() {
    return c = { 418: function(v, p) {
      (function(_, k) {
        for (var O in k)
          _[O] = k[O];
      })(p, function(_) {
        var k = {};
        function O(D) {
          if (k[D])
            return k[D].exports;
          var F = k[D] = { i: D, l: !1, exports: {} };
          return _[D].call(F.exports, F, F.exports, O), F.l = !0, F.exports;
        }
        return O.m = _, O.c = k, O.i = function(D) {
          return D;
        }, O.d = function(D, F, H) {
          O.o(D, F) || Object.defineProperty(D, F, { configurable: !1, enumerable: !0, get: H });
        }, O.n = function(D) {
          var F = D && D.__esModule ? function() {
            return D.default;
          } : function() {
            return D;
          };
          return O.d(F, "a", F), F;
        }, O.o = function(D, F) {
          return Object.prototype.hasOwnProperty.call(D, F);
        }, O.p = "", O(O.s = 1);
      }([function(_, k, O) {
        Object.defineProperty(k, "__esModule", { value: !0 });
        var D = O(3), F = function() {
          function H(Z, ee) {
            Z === void 0 && (Z = {}), ee === void 0 && (ee = { splitValues: !1 });
            var X, ne = this;
            this.headersMap = {}, Z && (typeof Headers < "u" && Z instanceof Headers ? D.getHeaderKeys(Z).forEach(function(Q) {
              D.getHeaderValues(Z, Q).forEach(function(ae) {
                ee.splitValues ? ne.append(Q, D.splitHeaderValue(ae)) : ne.append(Q, ae);
              });
            }) : typeof (X = Z) == "object" && typeof X.headersMap == "object" && typeof X.forEach == "function" ? Z.forEach(function(Q, ae) {
              ne.append(Q, ae);
            }) : typeof Map < "u" && Z instanceof Map ? Z.forEach(function(Q, ae) {
              ne.append(ae, Q);
            }) : typeof Z == "string" ? this.appendFromString(Z) : typeof Z == "object" && Object.getOwnPropertyNames(Z).forEach(function(Q) {
              var ae = Z[Q];
              Array.isArray(ae) ? ae.forEach(function(j) {
                ne.append(Q, j);
              }) : ne.append(Q, ae);
            }));
          }
          return H.prototype.appendFromString = function(Z) {
            for (var ee = Z.split(`\r
`), X = 0; X < ee.length; X++) {
              var ne = ee[X], Q = ne.indexOf(":");
              if (Q > 0) {
                var ae = ne.substring(0, Q).trim(), j = ne.substring(Q + 1).trim();
                this.append(ae, j);
              }
            }
          }, H.prototype.delete = function(Z, ee) {
            var X = D.normalizeName(Z);
            if (ee === void 0)
              delete this.headersMap[X];
            else {
              var ne = this.headersMap[X];
              if (ne) {
                var Q = ne.indexOf(ee);
                Q >= 0 && ne.splice(Q, 1), ne.length === 0 && delete this.headersMap[X];
              }
            }
          }, H.prototype.append = function(Z, ee) {
            var X = this, ne = D.normalizeName(Z);
            Array.isArray(this.headersMap[ne]) || (this.headersMap[ne] = []), Array.isArray(ee) ? ee.forEach(function(Q) {
              X.headersMap[ne].push(D.normalizeValue(Q));
            }) : this.headersMap[ne].push(D.normalizeValue(ee));
          }, H.prototype.set = function(Z, ee) {
            var X = D.normalizeName(Z);
            if (Array.isArray(ee)) {
              var ne = [];
              ee.forEach(function(Q) {
                ne.push(D.normalizeValue(Q));
              }), this.headersMap[X] = ne;
            } else
              this.headersMap[X] = [D.normalizeValue(ee)];
          }, H.prototype.has = function(Z, ee) {
            var X = this.headersMap[D.normalizeName(Z)];
            if (!Array.isArray(X))
              return !1;
            if (ee !== void 0) {
              var ne = D.normalizeValue(ee);
              return X.indexOf(ne) >= 0;
            }
            return !0;
          }, H.prototype.get = function(Z) {
            var ee = this.headersMap[D.normalizeName(Z)];
            return ee !== void 0 ? ee.concat() : [];
          }, H.prototype.forEach = function(Z) {
            var ee = this;
            Object.getOwnPropertyNames(this.headersMap).forEach(function(X) {
              Z(X, ee.headersMap[X]);
            }, this);
          }, H.prototype.toHeaders = function() {
            if (typeof Headers < "u") {
              var Z = new Headers();
              return this.forEach(function(ee, X) {
                X.forEach(function(ne) {
                  Z.append(ee, ne);
                });
              }), Z;
            }
            throw new Error("Headers class is not defined");
          }, H;
        }();
        k.BrowserHeaders = F;
      }, function(_, k, O) {
        Object.defineProperty(k, "__esModule", { value: !0 });
        var D = O(0);
        k.BrowserHeaders = D.BrowserHeaders;
      }, function(_, k, O) {
        Object.defineProperty(k, "__esModule", { value: !0 }), k.iterateHeaders = function(D, F) {
          for (var H = D[Symbol.iterator](), Z = H.next(); !Z.done; )
            F(Z.value[0]), Z = H.next();
        }, k.iterateHeadersKeys = function(D, F) {
          for (var H = D.keys(), Z = H.next(); !Z.done; )
            F(Z.value), Z = H.next();
        };
      }, function(_, k, O) {
        Object.defineProperty(k, "__esModule", { value: !0 });
        var D = O(2);
        k.normalizeName = function(F) {
          if (typeof F != "string" && (F = String(F)), /[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(F))
            throw new TypeError("Invalid character in header field name");
          return F.toLowerCase();
        }, k.normalizeValue = function(F) {
          return typeof F != "string" && (F = String(F)), F;
        }, k.getHeaderValues = function(F, H) {
          var Z = F;
          if (Z instanceof Headers && Z.getAll)
            return Z.getAll(H);
          var ee = Z.get(H);
          return ee && typeof ee == "string" ? [ee] : ee;
        }, k.getHeaderKeys = function(F) {
          var H = F, Z = {}, ee = [];
          return H.keys ? D.iterateHeadersKeys(H, function(X) {
            Z[X] || (Z[X] = !0, ee.push(X));
          }) : H.forEach ? H.forEach(function(X, ne) {
            Z[ne] || (Z[ne] = !0, ee.push(ne));
          }) : D.iterateHeaders(H, function(X) {
            var ne = X[0];
            Z[ne] || (Z[ne] = !0, ee.push(ne));
          }), ee;
        }, k.splitHeaderValue = function(F) {
          var H = [];
          return F.split(", ").forEach(function(Z) {
            Z.split(",").forEach(function(ee) {
              H.push(ee);
            });
          }), H;
        };
      }]));
    }, 617: function(v, p, _) {
      Object.defineProperty(p, "__esModule", { value: !0 }), p.ChunkParser = p.ChunkType = p.encodeASCII = p.decodeASCII = void 0;
      var k, O = _(65);
      function D(Q) {
        return (ae = Q) === 9 || ae === 10 || ae === 13 || Q >= 32 && Q <= 126;
        var ae;
      }
      function F(Q) {
        for (var ae = 0; ae !== Q.length; ++ae)
          if (!D(Q[ae]))
            throw new Error("Metadata is not valid (printable) ASCII");
        return String.fromCharCode.apply(String, Array.prototype.slice.call(Q));
      }
      function H(Q) {
        return (128 & Q.getUint8(0)) == 128;
      }
      function Z(Q) {
        return Q.getUint32(1, !1);
      }
      function ee(Q, ae, j) {
        return Q.byteLength - ae >= j;
      }
      function X(Q, ae, j) {
        if (Q.slice)
          return Q.slice(ae, j);
        var ue = Q.length;
        j !== void 0 && (ue = j);
        for (var he = new Uint8Array(ue - ae), fe = 0, be = ae; be < ue; be++)
          he[fe++] = Q[be];
        return he;
      }
      p.decodeASCII = F, p.encodeASCII = function(Q) {
        for (var ae = new Uint8Array(Q.length), j = 0; j !== Q.length; ++j) {
          var ue = Q.charCodeAt(j);
          if (!D(ue))
            throw new Error("Metadata contains invalid ASCII");
          ae[j] = ue;
        }
        return ae;
      }, function(Q) {
        Q[Q.MESSAGE = 1] = "MESSAGE", Q[Q.TRAILERS = 2] = "TRAILERS";
      }(k = p.ChunkType || (p.ChunkType = {}));
      var ne = function() {
        function Q() {
          this.buffer = null, this.position = 0;
        }
        return Q.prototype.parse = function(ae, j) {
          if (ae.length === 0 && j)
            return [];
          var ue, he = [];
          if (this.buffer == null)
            this.buffer = ae, this.position = 0;
          else if (this.position === this.buffer.byteLength)
            this.buffer = ae, this.position = 0;
          else {
            var fe = this.buffer.byteLength - this.position, be = new Uint8Array(fe + ae.byteLength), ke = X(this.buffer, this.position);
            be.set(ke, 0);
            var Te = new Uint8Array(ae);
            be.set(Te, fe), this.buffer = be, this.position = 0;
          }
          for (; ; ) {
            if (!ee(this.buffer, this.position, 5))
              return he;
            var q = X(this.buffer, this.position, this.position + 5), z = new DataView(q.buffer, q.byteOffset, q.byteLength), P = Z(z);
            if (!ee(this.buffer, this.position, 5 + P))
              return he;
            var S = X(this.buffer, this.position + 5, this.position + 5 + P);
            if (this.position += 5 + P, H(z))
              return he.push({ chunkType: k.TRAILERS, trailers: (ue = S, new O.Metadata(F(ue))) }), he;
            he.push({ chunkType: k.MESSAGE, data: S });
          }
        }, Q;
      }();
      p.ChunkParser = ne;
    }, 8: function(v, p) {
      var _;
      Object.defineProperty(p, "__esModule", { value: !0 }), p.httpStatusToCode = p.Code = void 0, function(k) {
        k[k.OK = 0] = "OK", k[k.Canceled = 1] = "Canceled", k[k.Unknown = 2] = "Unknown", k[k.InvalidArgument = 3] = "InvalidArgument", k[k.DeadlineExceeded = 4] = "DeadlineExceeded", k[k.NotFound = 5] = "NotFound", k[k.AlreadyExists = 6] = "AlreadyExists", k[k.PermissionDenied = 7] = "PermissionDenied", k[k.ResourceExhausted = 8] = "ResourceExhausted", k[k.FailedPrecondition = 9] = "FailedPrecondition", k[k.Aborted = 10] = "Aborted", k[k.OutOfRange = 11] = "OutOfRange", k[k.Unimplemented = 12] = "Unimplemented", k[k.Internal = 13] = "Internal", k[k.Unavailable = 14] = "Unavailable", k[k.DataLoss = 15] = "DataLoss", k[k.Unauthenticated = 16] = "Unauthenticated";
      }(_ = p.Code || (p.Code = {})), p.httpStatusToCode = function(k) {
        switch (k) {
          case 0:
            return _.Internal;
          case 200:
            return _.OK;
          case 400:
            return _.InvalidArgument;
          case 401:
            return _.Unauthenticated;
          case 403:
            return _.PermissionDenied;
          case 404:
            return _.NotFound;
          case 409:
            return _.Aborted;
          case 412:
            return _.FailedPrecondition;
          case 429:
            return _.ResourceExhausted;
          case 499:
            return _.Canceled;
          case 500:
            return _.Unknown;
          case 501:
            return _.Unimplemented;
          case 503:
            return _.Unavailable;
          case 504:
            return _.DeadlineExceeded;
          default:
            return _.Unknown;
        }
      };
    }, 934: function(v, p, _) {
      Object.defineProperty(p, "__esModule", { value: !0 }), p.client = void 0;
      var k = _(65), O = _(617), D = _(8), F = _(346), H = _(57), Z = _(882);
      p.client = function(ne, Q) {
        return new ee(ne, Q);
      };
      var ee = function() {
        function ne(Q, ae) {
          this.started = !1, this.sentFirstMessage = !1, this.completed = !1, this.closed = !1, this.finishedSending = !1, this.onHeadersCallbacks = [], this.onMessageCallbacks = [], this.onEndCallbacks = [], this.parser = new O.ChunkParser(), this.methodDefinition = Q, this.props = ae, this.createTransport();
        }
        return ne.prototype.createTransport = function() {
          var Q = this.props.host + "/" + this.methodDefinition.service.serviceName + "/" + this.methodDefinition.methodName, ae = { methodDefinition: this.methodDefinition, debug: this.props.debug || !1, url: Q, onHeaders: this.onTransportHeaders.bind(this), onChunk: this.onTransportChunk.bind(this), onEnd: this.onTransportEnd.bind(this) };
          this.props.transport ? this.transport = this.props.transport(ae) : this.transport = H.makeDefaultTransport(ae);
        }, ne.prototype.onTransportHeaders = function(Q, ae) {
          if (this.props.debug && F.debug("onHeaders", Q, ae), this.closed)
            this.props.debug && F.debug("grpc.onHeaders received after request was closed - ignoring");
          else if (ae !== 0) {
            this.responseHeaders = Q, this.props.debug && F.debug("onHeaders.responseHeaders", JSON.stringify(this.responseHeaders, null, 2));
            var j = X(Q);
            this.props.debug && F.debug("onHeaders.gRPCStatus", j);
            var ue = j && j >= 0 ? j : D.httpStatusToCode(ae);
            this.props.debug && F.debug("onHeaders.code", ue);
            var he = Q.get("grpc-message") || [];
            if (this.props.debug && F.debug("onHeaders.gRPCMessage", he), this.rawOnHeaders(Q), ue !== D.Code.OK) {
              var fe = this.decodeGRPCStatus(he[0]);
              this.rawOnError(ue, fe, Q);
            }
          }
        }, ne.prototype.onTransportChunk = function(Q) {
          var ae = this;
          if (this.closed)
            this.props.debug && F.debug("grpc.onChunk received after request was closed - ignoring");
          else {
            var j = [];
            try {
              j = this.parser.parse(Q);
            } catch (ue) {
              return this.props.debug && F.debug("onChunk.parsing error", ue, ue.message), void this.rawOnError(D.Code.Internal, "parsing error: " + ue.message);
            }
            j.forEach(function(ue) {
              if (ue.chunkType === O.ChunkType.MESSAGE) {
                var he = ae.methodDefinition.responseType.deserializeBinary(ue.data);
                ae.rawOnMessage(he);
              } else
                ue.chunkType === O.ChunkType.TRAILERS && (ae.responseHeaders ? (ae.responseTrailers = new k.Metadata(ue.trailers), ae.props.debug && F.debug("onChunk.trailers", ae.responseTrailers)) : (ae.responseHeaders = new k.Metadata(ue.trailers), ae.rawOnHeaders(ae.responseHeaders)));
            });
          }
        }, ne.prototype.onTransportEnd = function() {
          if (this.props.debug && F.debug("grpc.onEnd"), this.closed)
            this.props.debug && F.debug("grpc.onEnd received after request was closed - ignoring");
          else if (this.responseTrailers !== void 0) {
            var Q = X(this.responseTrailers);
            if (Q !== null) {
              var ae = this.responseTrailers.get("grpc-message"), j = this.decodeGRPCStatus(ae[0]);
              this.rawOnEnd(Q, j, this.responseTrailers);
            } else
              this.rawOnError(D.Code.Internal, "Response closed without grpc-status (Trailers provided)");
          } else {
            if (this.responseHeaders === void 0)
              return void this.rawOnError(D.Code.Unknown, "Response closed without headers");
            var ue = X(this.responseHeaders), he = this.responseHeaders.get("grpc-message");
            if (this.props.debug && F.debug("grpc.headers only response ", ue, he), ue === null)
              return void this.rawOnEnd(D.Code.Unknown, "Response closed without grpc-status (Headers only)", this.responseHeaders);
            var fe = this.decodeGRPCStatus(he[0]);
            this.rawOnEnd(ue, fe, this.responseHeaders);
          }
        }, ne.prototype.decodeGRPCStatus = function(Q) {
          if (!Q)
            return "";
          try {
            return decodeURIComponent(Q);
          } catch {
            return Q;
          }
        }, ne.prototype.rawOnEnd = function(Q, ae, j) {
          var ue = this;
          this.props.debug && F.debug("rawOnEnd", Q, ae, j), this.completed || (this.completed = !0, this.onEndCallbacks.forEach(function(he) {
            if (!ue.closed)
              try {
                he(Q, ae, j);
              } catch (fe) {
                setTimeout(function() {
                  throw fe;
                }, 0);
              }
          }));
        }, ne.prototype.rawOnHeaders = function(Q) {
          this.props.debug && F.debug("rawOnHeaders", Q), this.completed || this.onHeadersCallbacks.forEach(function(ae) {
            try {
              ae(Q);
            } catch (j) {
              setTimeout(function() {
                throw j;
              }, 0);
            }
          });
        }, ne.prototype.rawOnError = function(Q, ae, j) {
          var ue = this;
          j === void 0 && (j = new k.Metadata()), this.props.debug && F.debug("rawOnError", Q, ae), this.completed || (this.completed = !0, this.onEndCallbacks.forEach(function(he) {
            if (!ue.closed)
              try {
                he(Q, ae, j);
              } catch (fe) {
                setTimeout(function() {
                  throw fe;
                }, 0);
              }
          }));
        }, ne.prototype.rawOnMessage = function(Q) {
          var ae = this;
          this.props.debug && F.debug("rawOnMessage", Q.toObject()), this.completed || this.closed || this.onMessageCallbacks.forEach(function(j) {
            if (!ae.closed)
              try {
                j(Q);
              } catch (ue) {
                setTimeout(function() {
                  throw ue;
                }, 0);
              }
          });
        }, ne.prototype.onHeaders = function(Q) {
          this.onHeadersCallbacks.push(Q);
        }, ne.prototype.onMessage = function(Q) {
          this.onMessageCallbacks.push(Q);
        }, ne.prototype.onEnd = function(Q) {
          this.onEndCallbacks.push(Q);
        }, ne.prototype.start = function(Q) {
          if (this.started)
            throw new Error("Client already started - cannot .start()");
          this.started = !0;
          var ae = new k.Metadata(Q || {});
          ae.set("content-type", "application/grpc-web+proto"), ae.set("x-grpc-web", "1"), this.transport.start(ae);
        }, ne.prototype.send = function(Q) {
          if (!this.started)
            throw new Error("Client not started - .start() must be called before .send()");
          if (this.closed)
            throw new Error("Client already closed - cannot .send()");
          if (this.finishedSending)
            throw new Error("Client already finished sending - cannot .send()");
          if (!this.methodDefinition.requestStream && this.sentFirstMessage)
            throw new Error("Message already sent for non-client-streaming method - cannot .send()");
          this.sentFirstMessage = !0;
          var ae = Z.frameRequest(Q);
          this.transport.sendMessage(ae);
        }, ne.prototype.finishSend = function() {
          if (!this.started)
            throw new Error("Client not started - .finishSend() must be called before .close()");
          if (this.closed)
            throw new Error("Client already closed - cannot .send()");
          if (this.finishedSending)
            throw new Error("Client already finished sending - cannot .finishSend()");
          this.finishedSending = !0, this.transport.finishSend();
        }, ne.prototype.close = function() {
          if (!this.started)
            throw new Error("Client not started - .start() must be called before .close()");
          if (this.closed)
            throw new Error("Client already closed - cannot .close()");
          this.closed = !0, this.props.debug && F.debug("request.abort aborting request"), this.transport.cancel();
        }, ne;
      }();
      function X(ne) {
        var Q = ne.get("grpc-status") || [];
        if (Q.length > 0)
          try {
            var ae = Q[0];
            return parseInt(ae, 10);
          } catch {
            return null;
          }
        return null;
      }
    }, 346: function(v, p) {
      Object.defineProperty(p, "__esModule", { value: !0 }), p.debug = void 0, p.debug = function() {
        for (var _ = [], k = 0; k < arguments.length; k++)
          _[k] = arguments[k];
        console.debug ? console.debug.apply(null, _) : console.log.apply(null, _);
      };
    }, 607: function(v, p, _) {
      Object.defineProperty(p, "__esModule", { value: !0 }), p.grpc = void 0;
      var k, O = _(418), D = _(57), F = _(229), H = _(540), Z = _(210), ee = _(859), X = _(8), ne = _(938), Q = _(35), ae = _(934);
      (k = p.grpc || (p.grpc = {})).setDefaultTransport = D.setDefaultTransportFactory, k.CrossBrowserHttpTransport = ee.CrossBrowserHttpTransport, k.FetchReadableStreamTransport = F.FetchReadableStreamTransport, k.XhrTransport = Z.XhrTransport, k.WebsocketTransport = H.WebsocketTransport, k.Code = X.Code, k.Metadata = O.BrowserHeaders, k.client = function(j, ue) {
        return ae.client(j, ue);
      }, k.invoke = ne.invoke, k.unary = Q.unary;
    }, 938: function(v, p, _) {
      Object.defineProperty(p, "__esModule", { value: !0 }), p.invoke = void 0;
      var k = _(934);
      p.invoke = function(O, D) {
        if (O.requestStream)
          throw new Error(".invoke cannot be used with client-streaming methods. Use .client instead.");
        var F = k.client(O, { host: D.host, transport: D.transport, debug: D.debug });
        return D.onHeaders && F.onHeaders(D.onHeaders), D.onMessage && F.onMessage(D.onMessage), D.onEnd && F.onEnd(D.onEnd), F.start(D.metadata), F.send(D.request), F.finishSend(), { close: function() {
          F.close();
        } };
      };
    }, 65: function(v, p, _) {
      Object.defineProperty(p, "__esModule", { value: !0 }), p.Metadata = void 0;
      var k = _(418);
      Object.defineProperty(p, "Metadata", { enumerable: !0, get: function() {
        return k.BrowserHeaders;
      } });
    }, 57: function(v, p, _) {
      Object.defineProperty(p, "__esModule", { value: !0 }), p.makeDefaultTransport = p.setDefaultTransportFactory = void 0;
      var k = _(859), O = function(D) {
        return k.CrossBrowserHttpTransport({ withCredentials: !1 })(D);
      };
      p.setDefaultTransportFactory = function(D) {
        O = D;
      }, p.makeDefaultTransport = function(D) {
        return O(D);
      };
    }, 229: function(v, p, _) {
      var k = this && this.__assign || function() {
        return (k = Object.assign || function(H) {
          for (var Z, ee = 1, X = arguments.length; ee < X; ee++)
            for (var ne in Z = arguments[ee])
              Object.prototype.hasOwnProperty.call(Z, ne) && (H[ne] = Z[ne]);
          return H;
        }).apply(this, arguments);
      };
      Object.defineProperty(p, "__esModule", { value: !0 }), p.detectFetchSupport = p.FetchReadableStreamTransport = void 0;
      var O = _(65), D = _(346);
      p.FetchReadableStreamTransport = function(H) {
        return function(Z) {
          return function(ee, X) {
            return ee.debug && D.debug("fetchRequest", ee), new F(ee, X);
          }(Z, H);
        };
      };
      var F = function() {
        function H(Z, ee) {
          this.cancelled = !1, this.controller = self.AbortController && new AbortController(), this.options = Z, this.init = ee;
        }
        return H.prototype.pump = function(Z, ee) {
          var X = this;
          if (this.reader = Z, this.cancelled)
            return this.options.debug && D.debug("Fetch.pump.cancel at first pump"), void this.reader.cancel().catch(function(ne) {
              X.options.debug && D.debug("Fetch.pump.reader.cancel exception", ne);
            });
          this.reader.read().then(function(ne) {
            if (ne.done)
              return X.options.onEnd(), ee;
            X.options.onChunk(ne.value), X.pump(X.reader, ee);
          }).catch(function(ne) {
            X.cancelled ? X.options.debug && D.debug("Fetch.catch - request cancelled") : (X.cancelled = !0, X.options.debug && D.debug("Fetch.catch", ne.message), X.options.onEnd(ne));
          });
        }, H.prototype.send = function(Z) {
          var ee = this;
          fetch(this.options.url, k(k({}, this.init), { headers: this.metadata.toHeaders(), method: "POST", body: Z, signal: this.controller && this.controller.signal })).then(function(X) {
            if (ee.options.debug && D.debug("Fetch.response", X), ee.options.onHeaders(new O.Metadata(X.headers), X.status), !X.body)
              return X;
            ee.pump(X.body.getReader(), X);
          }).catch(function(X) {
            ee.cancelled ? ee.options.debug && D.debug("Fetch.catch - request cancelled") : (ee.cancelled = !0, ee.options.debug && D.debug("Fetch.catch", X.message), ee.options.onEnd(X));
          });
        }, H.prototype.sendMessage = function(Z) {
          this.send(Z);
        }, H.prototype.finishSend = function() {
        }, H.prototype.start = function(Z) {
          this.metadata = Z;
        }, H.prototype.cancel = function() {
          var Z = this;
          this.cancelled ? this.options.debug && D.debug("Fetch.cancel already cancelled") : (this.cancelled = !0, this.controller ? (this.options.debug && D.debug("Fetch.cancel.controller.abort"), this.controller.abort()) : this.options.debug && D.debug("Fetch.cancel.missing abort controller"), this.reader ? (this.options.debug && D.debug("Fetch.cancel.reader.cancel"), this.reader.cancel().catch(function(ee) {
            Z.options.debug && D.debug("Fetch.cancel.reader.cancel exception", ee);
          })) : this.options.debug && D.debug("Fetch.cancel before reader"));
        }, H;
      }();
      p.detectFetchSupport = function() {
        return typeof Response < "u" && Response.prototype.hasOwnProperty("body") && typeof Headers == "function";
      };
    }, 859: function(v, p, _) {
      Object.defineProperty(p, "__esModule", { value: !0 }), p.CrossBrowserHttpTransport = void 0;
      var k = _(229), O = _(210);
      p.CrossBrowserHttpTransport = function(D) {
        if (k.detectFetchSupport()) {
          var F = { credentials: D.withCredentials ? "include" : "same-origin" };
          return k.FetchReadableStreamTransport(F);
        }
        return O.XhrTransport({ withCredentials: D.withCredentials });
      };
    }, 210: function(v, p, _) {
      var k, O = this && this.__extends || (k = function(Q, ae) {
        return (k = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(j, ue) {
          j.__proto__ = ue;
        } || function(j, ue) {
          for (var he in ue)
            Object.prototype.hasOwnProperty.call(ue, he) && (j[he] = ue[he]);
        })(Q, ae);
      }, function(Q, ae) {
        function j() {
          this.constructor = Q;
        }
        k(Q, ae), Q.prototype = ae === null ? Object.create(ae) : (j.prototype = ae.prototype, new j());
      });
      Object.defineProperty(p, "__esModule", { value: !0 }), p.stringToArrayBuffer = p.MozChunkedArrayBufferXHR = p.XHR = p.XhrTransport = void 0;
      var D = _(65), F = _(346), H = _(849);
      p.XhrTransport = function(Q) {
        return function(ae) {
          if (H.detectMozXHRSupport())
            return new ee(ae, Q);
          if (H.detectXHROverrideMimeTypeSupport())
            return new Z(ae, Q);
          throw new Error("This environment's XHR implementation cannot support binary transfer.");
        };
      };
      var Z = function() {
        function Q(ae, j) {
          this.options = ae, this.init = j;
        }
        return Q.prototype.onProgressEvent = function() {
          this.options.debug && F.debug("XHR.onProgressEvent.length: ", this.xhr.response.length);
          var ae = this.xhr.response.substr(this.index);
          this.index = this.xhr.response.length;
          var j = ne(ae);
          this.options.onChunk(j);
        }, Q.prototype.onLoadEvent = function() {
          this.options.debug && F.debug("XHR.onLoadEvent"), this.options.onEnd();
        }, Q.prototype.onStateChange = function() {
          this.options.debug && F.debug("XHR.onStateChange", this.xhr.readyState), this.xhr.readyState === XMLHttpRequest.HEADERS_RECEIVED && this.options.onHeaders(new D.Metadata(this.xhr.getAllResponseHeaders()), this.xhr.status);
        }, Q.prototype.sendMessage = function(ae) {
          this.xhr.send(ae);
        }, Q.prototype.finishSend = function() {
        }, Q.prototype.start = function(ae) {
          var j = this;
          this.metadata = ae;
          var ue = new XMLHttpRequest();
          this.xhr = ue, ue.open("POST", this.options.url), this.configureXhr(), this.metadata.forEach(function(he, fe) {
            ue.setRequestHeader(he, fe.join(", "));
          }), ue.withCredentials = !!this.init.withCredentials, ue.addEventListener("readystatechange", this.onStateChange.bind(this)), ue.addEventListener("progress", this.onProgressEvent.bind(this)), ue.addEventListener("loadend", this.onLoadEvent.bind(this)), ue.addEventListener("error", function(he) {
            j.options.debug && F.debug("XHR.error", he), j.options.onEnd(he.error);
          });
        }, Q.prototype.configureXhr = function() {
          this.xhr.responseType = "text", this.xhr.overrideMimeType("text/plain; charset=x-user-defined");
        }, Q.prototype.cancel = function() {
          this.options.debug && F.debug("XHR.abort"), this.xhr.abort();
        }, Q;
      }();
      p.XHR = Z;
      var ee = function(Q) {
        function ae() {
          return Q !== null && Q.apply(this, arguments) || this;
        }
        return O(ae, Q), ae.prototype.configureXhr = function() {
          this.options.debug && F.debug("MozXHR.configureXhr: setting responseType to 'moz-chunked-arraybuffer'"), this.xhr.responseType = "moz-chunked-arraybuffer";
        }, ae.prototype.onProgressEvent = function() {
          var j = this.xhr.response;
          this.options.debug && F.debug("MozXHR.onProgressEvent: ", new Uint8Array(j)), this.options.onChunk(new Uint8Array(j));
        }, ae;
      }(Z);
      function X(Q, ae) {
        var j = Q.charCodeAt(ae);
        if (j >= 55296 && j <= 56319) {
          var ue = Q.charCodeAt(ae + 1);
          ue >= 56320 && ue <= 57343 && (j = 65536 + (j - 55296 << 10) + (ue - 56320));
        }
        return j;
      }
      function ne(Q) {
        for (var ae = new Uint8Array(Q.length), j = 0, ue = 0; ue < Q.length; ue++) {
          var he = String.prototype.codePointAt ? Q.codePointAt(ue) : X(Q, ue);
          ae[j++] = 255 & he;
        }
        return ae;
      }
      p.MozChunkedArrayBufferXHR = ee, p.stringToArrayBuffer = ne;
    }, 849: function(v, p) {
      var _;
      function k() {
        if (_ !== void 0)
          return _;
        if (XMLHttpRequest) {
          _ = new XMLHttpRequest();
          try {
            _.open("GET", "https://localhost");
          } catch {
          }
        }
        return _;
      }
      function O(D) {
        var F = k();
        if (!F)
          return !1;
        try {
          return F.responseType = D, F.responseType === D;
        } catch {
        }
        return !1;
      }
      Object.defineProperty(p, "__esModule", { value: !0 }), p.detectXHROverrideMimeTypeSupport = p.detectMozXHRSupport = p.xhrSupportsResponseType = void 0, p.xhrSupportsResponseType = O, p.detectMozXHRSupport = function() {
        return typeof XMLHttpRequest < "u" && O("moz-chunked-arraybuffer");
      }, p.detectXHROverrideMimeTypeSupport = function() {
        return typeof XMLHttpRequest < "u" && XMLHttpRequest.prototype.hasOwnProperty("overrideMimeType");
      };
    }, 540: function(v, p, _) {
      Object.defineProperty(p, "__esModule", { value: !0 }), p.WebsocketTransport = void 0;
      var k, O = _(346), D = _(617);
      (function(H) {
        H[H.FINISH_SEND = 1] = "FINISH_SEND";
      })(k || (k = {}));
      var F = new Uint8Array([1]);
      p.WebsocketTransport = function() {
        return function(H) {
          return function(Z) {
            Z.debug && O.debug("websocketRequest", Z);
            var ee, X = function(ae) {
              if (ae.substr(0, 8) === "https://")
                return "wss://" + ae.substr(8);
              if (ae.substr(0, 7) === "http://")
                return "ws://" + ae.substr(7);
              throw new Error("Websocket transport constructed with non-https:// or http:// host.");
            }(Z.url), ne = [];
            function Q(ae) {
              if (ae === k.FINISH_SEND)
                ee.send(F);
              else {
                var j = ae, ue = new Int8Array(j.byteLength + 1);
                ue.set(new Uint8Array([0])), ue.set(j, 1), ee.send(ue);
              }
            }
            return { sendMessage: function(ae) {
              ee && ee.readyState !== ee.CONNECTING ? Q(ae) : ne.push(ae);
            }, finishSend: function() {
              ee && ee.readyState !== ee.CONNECTING ? Q(k.FINISH_SEND) : ne.push(k.FINISH_SEND);
            }, start: function(ae) {
              (ee = new WebSocket(X, ["grpc-websockets"])).binaryType = "arraybuffer", ee.onopen = function() {
                var j;
                Z.debug && O.debug("websocketRequest.onopen"), ee.send((j = "", ae.forEach(function(ue, he) {
                  j += ue + ": " + he.join(", ") + `\r
`;
                }), D.encodeASCII(j))), ne.forEach(function(ue) {
                  Q(ue);
                });
              }, ee.onclose = function(j) {
                Z.debug && O.debug("websocketRequest.onclose", j), Z.onEnd();
              }, ee.onerror = function(j) {
                Z.debug && O.debug("websocketRequest.onerror", j);
              }, ee.onmessage = function(j) {
                Z.onChunk(new Uint8Array(j.data));
              };
            }, cancel: function() {
              Z.debug && O.debug("websocket.abort"), ee.close();
            } };
          }(H);
        };
      };
    }, 35: function(v, p, _) {
      Object.defineProperty(p, "__esModule", { value: !0 }), p.unary = void 0;
      var k = _(65), O = _(934);
      p.unary = function(D, F) {
        if (D.responseStream)
          throw new Error(".unary cannot be used with server-streaming methods. Use .invoke or .client instead.");
        if (D.requestStream)
          throw new Error(".unary cannot be used with client-streaming methods. Use .client instead.");
        var H = null, Z = null, ee = O.client(D, { host: F.host, transport: F.transport, debug: F.debug });
        return ee.onHeaders(function(X) {
          H = X;
        }), ee.onMessage(function(X) {
          Z = X;
        }), ee.onEnd(function(X, ne, Q) {
          F.onEnd({ status: X, statusMessage: ne, headers: H || new k.Metadata(), message: Z, trailers: Q });
        }), ee.start(F.metadata), ee.send(F.request), ee.finishSend(), { close: function() {
          ee.close();
        } };
      };
    }, 882: function(v, p) {
      Object.defineProperty(p, "__esModule", { value: !0 }), p.frameRequest = void 0, p.frameRequest = function(_) {
        var k = _.serializeBinary(), O = new ArrayBuffer(k.byteLength + 5);
        return new DataView(O, 1, 4).setUint32(0, k.length, !1), new Uint8Array(O, 5).set(k), new Uint8Array(O);
      };
    } }, l = {}, function v(p) {
      if (l[p])
        return l[p].exports;
      var _ = l[p] = { exports: {} };
      return c[p].call(_.exports, _, _.exports, v), _.exports;
    }(607);
    var c, l;
  });
})(grpcWebClient_umd);
var grpcWebClient_umdExports = grpcWebClient_umd.exports;
class AbortError extends Error {
  constructor() {
    super("The operation has been aborted"), this.message = "The operation has been aborted", this.name = "AbortError", typeof Error.captureStackTrace == "function" && Error.captureStackTrace(this, this.constructor);
  }
}
function isAbortError(a) {
  return typeof a == "object" && a !== null && a.name === "AbortError";
}
function throwIfAborted(a) {
  if (a.aborted)
    throw new AbortError();
}
function rethrowAbortError(a) {
  if (isAbortError(a))
    throw a;
}
function catchAbortError(a) {
  if (!isAbortError(a))
    throw a;
}
function execute(a, u) {
  return new Promise((c, l) => {
    if (a.aborted) {
      l(new AbortError());
      return;
    }
    let v, p = !1;
    function _() {
      p || (p = !0, v != null && v());
    }
    const k = u((O) => {
      c(O), _();
    }, (O) => {
      l(O), _();
    });
    if (!p) {
      const O = () => {
        const D = k();
        D == null ? l(new AbortError()) : D.then(() => {
          l(new AbortError());
        }, (F) => {
          l(F);
        }), _();
      };
      a.addEventListener("abort", O), v = () => {
        a.removeEventListener("abort", O);
      };
    }
  });
}
function abortable(a, u) {
  if (a.aborted) {
    const c = () => {
    };
    u.then(c, c);
  }
  return execute(a, (c, l) => (u.then(c, l), () => {
  }));
}
function delay$1(a, u) {
  return execute(a, (c) => {
    const l = typeof u == "number" ? u : u.getTime() - Date.now(), v = setTimeout(c, l);
    return () => {
      clearTimeout(v);
    };
  });
}
function forever(a) {
  return execute(a, () => () => {
  });
}
function waitForEvent(a, u, c, l) {
  return execute(a, (v) => {
    let p, _ = !1;
    return p = listen(u, c, (...O) => {
      v(O.length > 1 ? O : O[0]), _ = !0, p != null && p();
    }, l), _ && p(), () => {
      _ = !0, p != null && p();
    };
  });
}
function listen(a, u, c, l) {
  if (isEventTarget(a))
    return a.addEventListener(u, c, l), () => a.removeEventListener(u, c, l);
  if (isJQueryStyleEventEmitter(a))
    return a.on(u, c), () => a.off(u, c);
  if (isNodeStyleEventEmitter(a))
    return a.addListener(u, c), () => a.removeListener(u, c);
  throw new Error("Invalid event target");
}
function isNodeStyleEventEmitter(a) {
  return isFunction$4(a.addListener) && isFunction$4(a.removeListener);
}
function isJQueryStyleEventEmitter(a) {
  return isFunction$4(a.on) && isFunction$4(a.off);
}
function isEventTarget(a) {
  return isFunction$4(a.addEventListener) && isFunction$4(a.removeEventListener);
}
const isFunction$4 = (a) => typeof a == "function";
var browser$g = { exports: {} };
const _global = typeof self < "u" ? self : typeof window < "u" ? window : (
  /* otherwise */
  void 0
);
if (!_global)
  throw new Error(
    "Unable to find global scope. Are you sure this is running in the browser?"
  );
if (!_global.AbortController)
  throw new Error(
    'Could not find "AbortController" in the global scope. You need to polyfill it first'
  );
browser$g.exports = _global.AbortController;
browser$g.exports.default = _global.AbortController;
var browserExports$2 = browser$g.exports;
const AbortController$1 = /* @__PURE__ */ getDefaultExportFromCjs$2(browserExports$2);
function all(a, u) {
  return new Promise((c, l) => {
    if (a.aborted) {
      l(new AbortError());
      return;
    }
    const v = new AbortController$1(), p = u(v.signal);
    if (p.length === 0) {
      c([]);
      return;
    }
    const _ = () => {
      v.abort();
    };
    a.addEventListener("abort", _);
    let k;
    const O = new Array(p.length);
    let D = 0;
    function F() {
      D += 1, D === p.length && (a.removeEventListener("abort", _), k != null ? l(k.reason) : c(O));
    }
    for (const [H, Z] of p.entries())
      Z.then((ee) => {
        O[H] = ee, F();
      }, (ee) => {
        v.abort(), (k == null || !isAbortError(ee) && isAbortError(k.reason)) && (k = { reason: ee }), F();
      });
  });
}
function race$2(a, u) {
  return new Promise((c, l) => {
    if (a.aborted) {
      l(new AbortError());
      return;
    }
    const v = new AbortController$1(), p = u(v.signal), _ = () => {
      v.abort();
    };
    a.addEventListener("abort", _);
    let k = 0;
    function O(F) {
      v.abort(), k += 1, k === p.length && (a.removeEventListener("abort", _), F.status === "fulfilled" ? c(F.value) : l(F.reason));
    }
    let D;
    for (const F of p)
      F.then((H) => {
        D == null && (D = { status: "fulfilled", value: H }), O(D);
      }, (H) => {
        (D == null || !isAbortError(H) && (D.status === "fulfilled" || isAbortError(D.reason))) && (D = { status: "rejected", reason: H }), O(D);
      });
  });
}
async function retry$1(a, u, c = {}) {
  const { baseMs: l = 1e3, maxDelayMs: v = 15e3, onError: p, maxAttempts: _ = 1 / 0 } = c;
  let k = 0;
  const O = () => {
    k = -1;
  };
  for (; ; )
    try {
      return await u(a, k, O);
    } catch (D) {
      if (rethrowAbortError(D), k >= _)
        throw D;
      let F;
      if (k === -1)
        F = 0;
      else {
        const H = Math.min(v, Math.pow(2, k) * l);
        F = Math.round(H * (1 + Math.random()) / 2);
      }
      p && p(D, k, F), F !== 0 && await delay$1(a, F), k += 1;
    }
}
function spawn(a, u) {
  if (a.aborted)
    return Promise.reject(new AbortError());
  const c = [], l = new AbortController$1(), v = l.signal, p = () => {
    l.abort();
  };
  a.addEventListener("abort", p);
  const _ = () => {
    a.removeEventListener("abort", p);
  }, k = /* @__PURE__ */ new Set(), O = () => {
    for (const H of k)
      H.abort();
  };
  v.addEventListener("abort", O);
  const D = () => {
    v.removeEventListener("abort", O);
  };
  let F = new Promise((H, Z) => {
    let ee, X;
    ne((Q) => u(Q, {
      defer(ae) {
        c.push(ae);
      },
      fork: ne
    })).join().then((Q) => {
      l.abort(), ee = { value: Q };
    }, (Q) => {
      l.abort(), (!isAbortError(Q) || X == null) && (X = { error: Q });
    });
    function ne(Q) {
      if (v.aborted)
        return {
          abort() {
          },
          async join() {
            throw new AbortError();
          }
        };
      const ae = new AbortController$1(), j = ae.signal, ue = Q(j), he = {
        abort() {
          ae.abort();
        },
        join: () => ue
      };
      return k.add(he), ue.catch(catchAbortError).catch((fe) => {
        X = { error: fe }, l.abort();
      }).finally(() => {
        k.delete(he), k.size === 0 && (X != null ? Z(X.error) : H(ee.value));
      }), he;
    }
  });
  return F = F.finally(() => {
    _(), D();
    let H = Promise.resolve();
    for (let Z = c.length - 1; Z >= 0; Z--)
      H = H.finally(c[Z]);
    return H;
  }), F;
}
function run(a) {
  const u = new AbortController$1(), c = a(u.signal).catch(catchAbortError);
  return () => (u.abort(), c);
}
const es = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AbortError,
  abortable,
  all,
  catchAbortError,
  delay: delay$1,
  execute,
  forever,
  isAbortError,
  race: race$2,
  rethrowAbortError,
  retry: retry$1,
  run,
  spawn,
  throwIfAborted,
  waitForEvent
}, Symbol.toStringTag, { value: "Module" })), require$$1$3 = /* @__PURE__ */ getAugmentedNamespace(es);
var AsyncSink$1 = {};
Object.defineProperty(AsyncSink$1, "__esModule", { value: !0 });
AsyncSink$1.AsyncSink = void 0;
const ARRAY_VALUE = "value", ARRAY_ERROR = "error";
class AsyncSink {
  constructor() {
    this._ended = !1, this._values = [], this._resolvers = [];
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  write(u) {
    this._push({ type: ARRAY_VALUE, value: u });
  }
  error(u) {
    this._push({ type: ARRAY_ERROR, error: u });
  }
  _push(u) {
    if (this._ended)
      throw new Error("AsyncSink already ended");
    if (this._resolvers.length > 0) {
      const { resolve: c, reject: l } = this._resolvers.shift();
      u.type === ARRAY_ERROR ? l(u.error) : c({ done: !1, value: u.value });
    } else
      this._values.push(u);
  }
  next() {
    if (this._values.length > 0) {
      const { type: u, value: c, error: l } = this._values.shift();
      return u === ARRAY_ERROR ? Promise.reject(l) : Promise.resolve({ done: !1, value: c });
    }
    return this._ended ? Promise.resolve({ done: !0 }) : new Promise((u, c) => {
      this._resolvers.push({ resolve: u, reject: c });
    });
  }
  end() {
    for (; this._resolvers.length > 0; )
      this._resolvers.shift().resolve({ done: !0 });
    this._ended = !0;
  }
}
AsyncSink$1.AsyncSink = AsyncSink;
var isAsyncIterable$1 = {};
Object.defineProperty(isAsyncIterable$1, "__esModule", { value: !0 });
isAsyncIterable$1.isAsyncIterable = void 0;
function isAsyncIterable(a) {
  return a != null && Symbol.asyncIterator in a;
}
isAsyncIterable$1.isAsyncIterable = isAsyncIterable;
var convertMetadata = {}, buffer$3 = {}, base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [], revLookup = [], Arr = typeof Uint8Array < "u" ? Uint8Array : Array, code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$1 = 0, len = code.length; i$1 < len; ++i$1)
  lookup[i$1] = code[i$1], revLookup[code.charCodeAt(i$1)] = i$1;
revLookup[45] = 62;
revLookup[95] = 63;
function getLens(a) {
  var u = a.length;
  if (u % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var c = a.indexOf("=");
  c === -1 && (c = u);
  var l = c === u ? 0 : 4 - c % 4;
  return [c, l];
}
function byteLength(a) {
  var u = getLens(a), c = u[0], l = u[1];
  return (c + l) * 3 / 4 - l;
}
function _byteLength(a, u, c) {
  return (u + c) * 3 / 4 - c;
}
function toByteArray(a) {
  var u, c = getLens(a), l = c[0], v = c[1], p = new Arr(_byteLength(a, l, v)), _ = 0, k = v > 0 ? l - 4 : l, O;
  for (O = 0; O < k; O += 4)
    u = revLookup[a.charCodeAt(O)] << 18 | revLookup[a.charCodeAt(O + 1)] << 12 | revLookup[a.charCodeAt(O + 2)] << 6 | revLookup[a.charCodeAt(O + 3)], p[_++] = u >> 16 & 255, p[_++] = u >> 8 & 255, p[_++] = u & 255;
  return v === 2 && (u = revLookup[a.charCodeAt(O)] << 2 | revLookup[a.charCodeAt(O + 1)] >> 4, p[_++] = u & 255), v === 1 && (u = revLookup[a.charCodeAt(O)] << 10 | revLookup[a.charCodeAt(O + 1)] << 4 | revLookup[a.charCodeAt(O + 2)] >> 2, p[_++] = u >> 8 & 255, p[_++] = u & 255), p;
}
function tripletToBase64(a) {
  return lookup[a >> 18 & 63] + lookup[a >> 12 & 63] + lookup[a >> 6 & 63] + lookup[a & 63];
}
function encodeChunk(a, u, c) {
  for (var l, v = [], p = u; p < c; p += 3)
    l = (a[p] << 16 & 16711680) + (a[p + 1] << 8 & 65280) + (a[p + 2] & 255), v.push(tripletToBase64(l));
  return v.join("");
}
function fromByteArray(a) {
  for (var u, c = a.length, l = c % 3, v = [], p = 16383, _ = 0, k = c - l; _ < k; _ += p)
    v.push(encodeChunk(a, _, _ + p > k ? k : _ + p));
  return l === 1 ? (u = a[c - 1], v.push(
    lookup[u >> 2] + lookup[u << 4 & 63] + "=="
  )) : l === 2 && (u = (a[c - 2] << 8) + a[c - 1], v.push(
    lookup[u >> 10] + lookup[u >> 4 & 63] + lookup[u << 2 & 63] + "="
  )), v.join("");
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(a, u, c, l, v) {
  var p, _, k = v * 8 - l - 1, O = (1 << k) - 1, D = O >> 1, F = -7, H = c ? v - 1 : 0, Z = c ? -1 : 1, ee = a[u + H];
  for (H += Z, p = ee & (1 << -F) - 1, ee >>= -F, F += k; F > 0; p = p * 256 + a[u + H], H += Z, F -= 8)
    ;
  for (_ = p & (1 << -F) - 1, p >>= -F, F += l; F > 0; _ = _ * 256 + a[u + H], H += Z, F -= 8)
    ;
  if (p === 0)
    p = 1 - D;
  else {
    if (p === O)
      return _ ? NaN : (ee ? -1 : 1) * (1 / 0);
    _ = _ + Math.pow(2, l), p = p - D;
  }
  return (ee ? -1 : 1) * _ * Math.pow(2, p - l);
};
ieee754.write = function(a, u, c, l, v, p) {
  var _, k, O, D = p * 8 - v - 1, F = (1 << D) - 1, H = F >> 1, Z = v === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, ee = l ? 0 : p - 1, X = l ? 1 : -1, ne = u < 0 || u === 0 && 1 / u < 0 ? 1 : 0;
  for (u = Math.abs(u), isNaN(u) || u === 1 / 0 ? (k = isNaN(u) ? 1 : 0, _ = F) : (_ = Math.floor(Math.log(u) / Math.LN2), u * (O = Math.pow(2, -_)) < 1 && (_--, O *= 2), _ + H >= 1 ? u += Z / O : u += Z * Math.pow(2, 1 - H), u * O >= 2 && (_++, O /= 2), _ + H >= F ? (k = 0, _ = F) : _ + H >= 1 ? (k = (u * O - 1) * Math.pow(2, v), _ = _ + H) : (k = u * Math.pow(2, H - 1) * Math.pow(2, v), _ = 0)); v >= 8; a[c + ee] = k & 255, ee += X, k /= 256, v -= 8)
    ;
  for (_ = _ << v | k, D += v; D > 0; a[c + ee] = _ & 255, ee += X, _ /= 256, D -= 8)
    ;
  a[c + ee - X] |= ne * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(a) {
  const u = base64Js, c = ieee754, l = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  a.Buffer = F, a.SlowBuffer = fe, a.INSPECT_MAX_BYTES = 50;
  const v = 2147483647;
  a.kMaxLength = v;
  const { Uint8Array: p, ArrayBuffer: _, SharedArrayBuffer: k } = globalThis;
  F.TYPED_ARRAY_SUPPORT = O(), !F.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function O() {
    try {
      const de = new p(1), ce = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(ce, p.prototype), Object.setPrototypeOf(de, ce), de.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(F.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (F.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(F.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (F.isBuffer(this))
        return this.byteOffset;
    }
  });
  function D(de) {
    if (de > v)
      throw new RangeError('The value "' + de + '" is invalid for option "size"');
    const ce = new p(de);
    return Object.setPrototypeOf(ce, F.prototype), ce;
  }
  function F(de, ce, ve) {
    if (typeof de == "number") {
      if (typeof ce == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return X(de);
    }
    return H(de, ce, ve);
  }
  F.poolSize = 8192;
  function H(de, ce, ve) {
    if (typeof de == "string")
      return ne(de, ce);
    if (_.isView(de))
      return ae(de);
    if (de == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof de
      );
    if (we(de, _) || de && we(de.buffer, _) || typeof k < "u" && (we(de, k) || de && we(de.buffer, k)))
      return j(de, ce, ve);
    if (typeof de == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const Pe = de.valueOf && de.valueOf();
    if (Pe != null && Pe !== de)
      return F.from(Pe, ce, ve);
    const Be = ue(de);
    if (Be)
      return Be;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof de[Symbol.toPrimitive] == "function")
      return F.from(de[Symbol.toPrimitive]("string"), ce, ve);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof de
    );
  }
  F.from = function(de, ce, ve) {
    return H(de, ce, ve);
  }, Object.setPrototypeOf(F.prototype, p.prototype), Object.setPrototypeOf(F, p);
  function Z(de) {
    if (typeof de != "number")
      throw new TypeError('"size" argument must be of type number');
    if (de < 0)
      throw new RangeError('The value "' + de + '" is invalid for option "size"');
  }
  function ee(de, ce, ve) {
    return Z(de), de <= 0 ? D(de) : ce !== void 0 ? typeof ve == "string" ? D(de).fill(ce, ve) : D(de).fill(ce) : D(de);
  }
  F.alloc = function(de, ce, ve) {
    return ee(de, ce, ve);
  };
  function X(de) {
    return Z(de), D(de < 0 ? 0 : he(de) | 0);
  }
  F.allocUnsafe = function(de) {
    return X(de);
  }, F.allocUnsafeSlow = function(de) {
    return X(de);
  };
  function ne(de, ce) {
    if ((typeof ce != "string" || ce === "") && (ce = "utf8"), !F.isEncoding(ce))
      throw new TypeError("Unknown encoding: " + ce);
    const ve = be(de, ce) | 0;
    let Pe = D(ve);
    const Be = Pe.write(de, ce);
    return Be !== ve && (Pe = Pe.slice(0, Be)), Pe;
  }
  function Q(de) {
    const ce = de.length < 0 ? 0 : he(de.length) | 0, ve = D(ce);
    for (let Pe = 0; Pe < ce; Pe += 1)
      ve[Pe] = de[Pe] & 255;
    return ve;
  }
  function ae(de) {
    if (we(de, p)) {
      const ce = new p(de);
      return j(ce.buffer, ce.byteOffset, ce.byteLength);
    }
    return Q(de);
  }
  function j(de, ce, ve) {
    if (ce < 0 || de.byteLength < ce)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (de.byteLength < ce + (ve || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let Pe;
    return ce === void 0 && ve === void 0 ? Pe = new p(de) : ve === void 0 ? Pe = new p(de, ce) : Pe = new p(de, ce, ve), Object.setPrototypeOf(Pe, F.prototype), Pe;
  }
  function ue(de) {
    if (F.isBuffer(de)) {
      const ce = he(de.length) | 0, ve = D(ce);
      return ve.length === 0 || de.copy(ve, 0, 0, ce), ve;
    }
    if (de.length !== void 0)
      return typeof de.length != "number" || We(de.length) ? D(0) : Q(de);
    if (de.type === "Buffer" && Array.isArray(de.data))
      return Q(de.data);
  }
  function he(de) {
    if (de >= v)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + v.toString(16) + " bytes");
    return de | 0;
  }
  function fe(de) {
    return +de != de && (de = 0), F.alloc(+de);
  }
  F.isBuffer = function(ce) {
    return ce != null && ce._isBuffer === !0 && ce !== F.prototype;
  }, F.compare = function(ce, ve) {
    if (we(ce, p) && (ce = F.from(ce, ce.offset, ce.byteLength)), we(ve, p) && (ve = F.from(ve, ve.offset, ve.byteLength)), !F.isBuffer(ce) || !F.isBuffer(ve))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (ce === ve)
      return 0;
    let Pe = ce.length, Be = ve.length;
    for (let ze = 0, Je = Math.min(Pe, Be); ze < Je; ++ze)
      if (ce[ze] !== ve[ze]) {
        Pe = ce[ze], Be = ve[ze];
        break;
      }
    return Pe < Be ? -1 : Be < Pe ? 1 : 0;
  }, F.isEncoding = function(ce) {
    switch (String(ce).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, F.concat = function(ce, ve) {
    if (!Array.isArray(ce))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (ce.length === 0)
      return F.alloc(0);
    let Pe;
    if (ve === void 0)
      for (ve = 0, Pe = 0; Pe < ce.length; ++Pe)
        ve += ce[Pe].length;
    const Be = F.allocUnsafe(ve);
    let ze = 0;
    for (Pe = 0; Pe < ce.length; ++Pe) {
      let Je = ce[Pe];
      if (we(Je, p))
        ze + Je.length > Be.length ? (F.isBuffer(Je) || (Je = F.from(Je)), Je.copy(Be, ze)) : p.prototype.set.call(
          Be,
          Je,
          ze
        );
      else if (F.isBuffer(Je))
        Je.copy(Be, ze);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      ze += Je.length;
    }
    return Be;
  };
  function be(de, ce) {
    if (F.isBuffer(de))
      return de.length;
    if (_.isView(de) || we(de, _))
      return de.byteLength;
    if (typeof de != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof de
      );
    const ve = de.length, Pe = arguments.length > 2 && arguments[2] === !0;
    if (!Pe && ve === 0)
      return 0;
    let Be = !1;
    for (; ; )
      switch (ce) {
        case "ascii":
        case "latin1":
        case "binary":
          return ve;
        case "utf8":
        case "utf-8":
          return yt(de).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ve * 2;
        case "hex":
          return ve >>> 1;
        case "base64":
          return J(de).length;
        default:
          if (Be)
            return Pe ? -1 : yt(de).length;
          ce = ("" + ce).toLowerCase(), Be = !0;
      }
  }
  F.byteLength = be;
  function ke(de, ce, ve) {
    let Pe = !1;
    if ((ce === void 0 || ce < 0) && (ce = 0), ce > this.length || ((ve === void 0 || ve > this.length) && (ve = this.length), ve <= 0) || (ve >>>= 0, ce >>>= 0, ve <= ce))
      return "";
    for (de || (de = "utf8"); ; )
      switch (de) {
        case "hex":
          return te(this, ce, ve);
        case "utf8":
        case "utf-8":
          return U(this, ce, ve);
        case "ascii":
          return T(this, ce, ve);
        case "latin1":
        case "binary":
          return L(this, ce, ve);
        case "base64":
          return $(this, ce, ve);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return me(this, ce, ve);
        default:
          if (Pe)
            throw new TypeError("Unknown encoding: " + de);
          de = (de + "").toLowerCase(), Pe = !0;
      }
  }
  F.prototype._isBuffer = !0;
  function Te(de, ce, ve) {
    const Pe = de[ce];
    de[ce] = de[ve], de[ve] = Pe;
  }
  F.prototype.swap16 = function() {
    const ce = this.length;
    if (ce % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let ve = 0; ve < ce; ve += 2)
      Te(this, ve, ve + 1);
    return this;
  }, F.prototype.swap32 = function() {
    const ce = this.length;
    if (ce % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let ve = 0; ve < ce; ve += 4)
      Te(this, ve, ve + 3), Te(this, ve + 1, ve + 2);
    return this;
  }, F.prototype.swap64 = function() {
    const ce = this.length;
    if (ce % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let ve = 0; ve < ce; ve += 8)
      Te(this, ve, ve + 7), Te(this, ve + 1, ve + 6), Te(this, ve + 2, ve + 5), Te(this, ve + 3, ve + 4);
    return this;
  }, F.prototype.toString = function() {
    const ce = this.length;
    return ce === 0 ? "" : arguments.length === 0 ? U(this, 0, ce) : ke.apply(this, arguments);
  }, F.prototype.toLocaleString = F.prototype.toString, F.prototype.equals = function(ce) {
    if (!F.isBuffer(ce))
      throw new TypeError("Argument must be a Buffer");
    return this === ce ? !0 : F.compare(this, ce) === 0;
  }, F.prototype.inspect = function() {
    let ce = "";
    const ve = a.INSPECT_MAX_BYTES;
    return ce = this.toString("hex", 0, ve).replace(/(.{2})/g, "$1 ").trim(), this.length > ve && (ce += " ... "), "<Buffer " + ce + ">";
  }, l && (F.prototype[l] = F.prototype.inspect), F.prototype.compare = function(ce, ve, Pe, Be, ze) {
    if (we(ce, p) && (ce = F.from(ce, ce.offset, ce.byteLength)), !F.isBuffer(ce))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof ce
      );
    if (ve === void 0 && (ve = 0), Pe === void 0 && (Pe = ce ? ce.length : 0), Be === void 0 && (Be = 0), ze === void 0 && (ze = this.length), ve < 0 || Pe > ce.length || Be < 0 || ze > this.length)
      throw new RangeError("out of range index");
    if (Be >= ze && ve >= Pe)
      return 0;
    if (Be >= ze)
      return -1;
    if (ve >= Pe)
      return 1;
    if (ve >>>= 0, Pe >>>= 0, Be >>>= 0, ze >>>= 0, this === ce)
      return 0;
    let Je = ze - Be, je = Pe - ve;
    const Ke = Math.min(Je, je), x = this.slice(Be, ze), se = ce.slice(ve, Pe);
    for (let Se = 0; Se < Ke; ++Se)
      if (x[Se] !== se[Se]) {
        Je = x[Se], je = se[Se];
        break;
      }
    return Je < je ? -1 : je < Je ? 1 : 0;
  };
  function q(de, ce, ve, Pe, Be) {
    if (de.length === 0)
      return -1;
    if (typeof ve == "string" ? (Pe = ve, ve = 0) : ve > 2147483647 ? ve = 2147483647 : ve < -2147483648 && (ve = -2147483648), ve = +ve, We(ve) && (ve = Be ? 0 : de.length - 1), ve < 0 && (ve = de.length + ve), ve >= de.length) {
      if (Be)
        return -1;
      ve = de.length - 1;
    } else if (ve < 0)
      if (Be)
        ve = 0;
      else
        return -1;
    if (typeof ce == "string" && (ce = F.from(ce, Pe)), F.isBuffer(ce))
      return ce.length === 0 ? -1 : z(de, ce, ve, Pe, Be);
    if (typeof ce == "number")
      return ce = ce & 255, typeof p.prototype.indexOf == "function" ? Be ? p.prototype.indexOf.call(de, ce, ve) : p.prototype.lastIndexOf.call(de, ce, ve) : z(de, [ce], ve, Pe, Be);
    throw new TypeError("val must be string, number or Buffer");
  }
  function z(de, ce, ve, Pe, Be) {
    let ze = 1, Je = de.length, je = ce.length;
    if (Pe !== void 0 && (Pe = String(Pe).toLowerCase(), Pe === "ucs2" || Pe === "ucs-2" || Pe === "utf16le" || Pe === "utf-16le")) {
      if (de.length < 2 || ce.length < 2)
        return -1;
      ze = 2, Je /= 2, je /= 2, ve /= 2;
    }
    function Ke(se, Se) {
      return ze === 1 ? se[Se] : se.readUInt16BE(Se * ze);
    }
    let x;
    if (Be) {
      let se = -1;
      for (x = ve; x < Je; x++)
        if (Ke(de, x) === Ke(ce, se === -1 ? 0 : x - se)) {
          if (se === -1 && (se = x), x - se + 1 === je)
            return se * ze;
        } else
          se !== -1 && (x -= x - se), se = -1;
    } else
      for (ve + je > Je && (ve = Je - je), x = ve; x >= 0; x--) {
        let se = !0;
        for (let Se = 0; Se < je; Se++)
          if (Ke(de, x + Se) !== Ke(ce, Se)) {
            se = !1;
            break;
          }
        if (se)
          return x;
      }
    return -1;
  }
  F.prototype.includes = function(ce, ve, Pe) {
    return this.indexOf(ce, ve, Pe) !== -1;
  }, F.prototype.indexOf = function(ce, ve, Pe) {
    return q(this, ce, ve, Pe, !0);
  }, F.prototype.lastIndexOf = function(ce, ve, Pe) {
    return q(this, ce, ve, Pe, !1);
  };
  function P(de, ce, ve, Pe) {
    ve = Number(ve) || 0;
    const Be = de.length - ve;
    Pe ? (Pe = Number(Pe), Pe > Be && (Pe = Be)) : Pe = Be;
    const ze = ce.length;
    Pe > ze / 2 && (Pe = ze / 2);
    let Je;
    for (Je = 0; Je < Pe; ++Je) {
      const je = parseInt(ce.substr(Je * 2, 2), 16);
      if (We(je))
        return Je;
      de[ve + Je] = je;
    }
    return Je;
  }
  function S(de, ce, ve, Pe) {
    return ge(yt(ce, de.length - ve), de, ve, Pe);
  }
  function E(de, ce, ve, Pe) {
    return ge(Xe(ce), de, ve, Pe);
  }
  function I(de, ce, ve, Pe) {
    return ge(J(ce), de, ve, Pe);
  }
  function M(de, ce, ve, Pe) {
    return ge(Ge(ce, de.length - ve), de, ve, Pe);
  }
  F.prototype.write = function(ce, ve, Pe, Be) {
    if (ve === void 0)
      Be = "utf8", Pe = this.length, ve = 0;
    else if (Pe === void 0 && typeof ve == "string")
      Be = ve, Pe = this.length, ve = 0;
    else if (isFinite(ve))
      ve = ve >>> 0, isFinite(Pe) ? (Pe = Pe >>> 0, Be === void 0 && (Be = "utf8")) : (Be = Pe, Pe = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const ze = this.length - ve;
    if ((Pe === void 0 || Pe > ze) && (Pe = ze), ce.length > 0 && (Pe < 0 || ve < 0) || ve > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    Be || (Be = "utf8");
    let Je = !1;
    for (; ; )
      switch (Be) {
        case "hex":
          return P(this, ce, ve, Pe);
        case "utf8":
        case "utf-8":
          return S(this, ce, ve, Pe);
        case "ascii":
        case "latin1":
        case "binary":
          return E(this, ce, ve, Pe);
        case "base64":
          return I(this, ce, ve, Pe);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return M(this, ce, ve, Pe);
        default:
          if (Je)
            throw new TypeError("Unknown encoding: " + Be);
          Be = ("" + Be).toLowerCase(), Je = !0;
      }
  }, F.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function $(de, ce, ve) {
    return ce === 0 && ve === de.length ? u.fromByteArray(de) : u.fromByteArray(de.slice(ce, ve));
  }
  function U(de, ce, ve) {
    ve = Math.min(de.length, ve);
    const Pe = [];
    let Be = ce;
    for (; Be < ve; ) {
      const ze = de[Be];
      let Je = null, je = ze > 239 ? 4 : ze > 223 ? 3 : ze > 191 ? 2 : 1;
      if (Be + je <= ve) {
        let Ke, x, se, Se;
        switch (je) {
          case 1:
            ze < 128 && (Je = ze);
            break;
          case 2:
            Ke = de[Be + 1], (Ke & 192) === 128 && (Se = (ze & 31) << 6 | Ke & 63, Se > 127 && (Je = Se));
            break;
          case 3:
            Ke = de[Be + 1], x = de[Be + 2], (Ke & 192) === 128 && (x & 192) === 128 && (Se = (ze & 15) << 12 | (Ke & 63) << 6 | x & 63, Se > 2047 && (Se < 55296 || Se > 57343) && (Je = Se));
            break;
          case 4:
            Ke = de[Be + 1], x = de[Be + 2], se = de[Be + 3], (Ke & 192) === 128 && (x & 192) === 128 && (se & 192) === 128 && (Se = (ze & 15) << 18 | (Ke & 63) << 12 | (x & 63) << 6 | se & 63, Se > 65535 && Se < 1114112 && (Je = Se));
        }
      }
      Je === null ? (Je = 65533, je = 1) : Je > 65535 && (Je -= 65536, Pe.push(Je >>> 10 & 1023 | 55296), Je = 56320 | Je & 1023), Pe.push(Je), Be += je;
    }
    return B(Pe);
  }
  const Y = 4096;
  function B(de) {
    const ce = de.length;
    if (ce <= Y)
      return String.fromCharCode.apply(String, de);
    let ve = "", Pe = 0;
    for (; Pe < ce; )
      ve += String.fromCharCode.apply(
        String,
        de.slice(Pe, Pe += Y)
      );
    return ve;
  }
  function T(de, ce, ve) {
    let Pe = "";
    ve = Math.min(de.length, ve);
    for (let Be = ce; Be < ve; ++Be)
      Pe += String.fromCharCode(de[Be] & 127);
    return Pe;
  }
  function L(de, ce, ve) {
    let Pe = "";
    ve = Math.min(de.length, ve);
    for (let Be = ce; Be < ve; ++Be)
      Pe += String.fromCharCode(de[Be]);
    return Pe;
  }
  function te(de, ce, ve) {
    const Pe = de.length;
    (!ce || ce < 0) && (ce = 0), (!ve || ve < 0 || ve > Pe) && (ve = Pe);
    let Be = "";
    for (let ze = ce; ze < ve; ++ze)
      Be += Ie[de[ze]];
    return Be;
  }
  function me(de, ce, ve) {
    const Pe = de.slice(ce, ve);
    let Be = "";
    for (let ze = 0; ze < Pe.length - 1; ze += 2)
      Be += String.fromCharCode(Pe[ze] + Pe[ze + 1] * 256);
    return Be;
  }
  F.prototype.slice = function(ce, ve) {
    const Pe = this.length;
    ce = ~~ce, ve = ve === void 0 ? Pe : ~~ve, ce < 0 ? (ce += Pe, ce < 0 && (ce = 0)) : ce > Pe && (ce = Pe), ve < 0 ? (ve += Pe, ve < 0 && (ve = 0)) : ve > Pe && (ve = Pe), ve < ce && (ve = ce);
    const Be = this.subarray(ce, ve);
    return Object.setPrototypeOf(Be, F.prototype), Be;
  };
  function Ce(de, ce, ve) {
    if (de % 1 !== 0 || de < 0)
      throw new RangeError("offset is not uint");
    if (de + ce > ve)
      throw new RangeError("Trying to access beyond buffer length");
  }
  F.prototype.readUintLE = F.prototype.readUIntLE = function(ce, ve, Pe) {
    ce = ce >>> 0, ve = ve >>> 0, Pe || Ce(ce, ve, this.length);
    let Be = this[ce], ze = 1, Je = 0;
    for (; ++Je < ve && (ze *= 256); )
      Be += this[ce + Je] * ze;
    return Be;
  }, F.prototype.readUintBE = F.prototype.readUIntBE = function(ce, ve, Pe) {
    ce = ce >>> 0, ve = ve >>> 0, Pe || Ce(ce, ve, this.length);
    let Be = this[ce + --ve], ze = 1;
    for (; ve > 0 && (ze *= 256); )
      Be += this[ce + --ve] * ze;
    return Be;
  }, F.prototype.readUint8 = F.prototype.readUInt8 = function(ce, ve) {
    return ce = ce >>> 0, ve || Ce(ce, 1, this.length), this[ce];
  }, F.prototype.readUint16LE = F.prototype.readUInt16LE = function(ce, ve) {
    return ce = ce >>> 0, ve || Ce(ce, 2, this.length), this[ce] | this[ce + 1] << 8;
  }, F.prototype.readUint16BE = F.prototype.readUInt16BE = function(ce, ve) {
    return ce = ce >>> 0, ve || Ce(ce, 2, this.length), this[ce] << 8 | this[ce + 1];
  }, F.prototype.readUint32LE = F.prototype.readUInt32LE = function(ce, ve) {
    return ce = ce >>> 0, ve || Ce(ce, 4, this.length), (this[ce] | this[ce + 1] << 8 | this[ce + 2] << 16) + this[ce + 3] * 16777216;
  }, F.prototype.readUint32BE = F.prototype.readUInt32BE = function(ce, ve) {
    return ce = ce >>> 0, ve || Ce(ce, 4, this.length), this[ce] * 16777216 + (this[ce + 1] << 16 | this[ce + 2] << 8 | this[ce + 3]);
  }, F.prototype.readBigUInt64LE = V(function(ce) {
    ce = ce >>> 0, Oe(ce, "offset");
    const ve = this[ce], Pe = this[ce + 7];
    (ve === void 0 || Pe === void 0) && Fe(ce, this.length - 8);
    const Be = ve + this[++ce] * 2 ** 8 + this[++ce] * 2 ** 16 + this[++ce] * 2 ** 24, ze = this[++ce] + this[++ce] * 2 ** 8 + this[++ce] * 2 ** 16 + Pe * 2 ** 24;
    return BigInt(Be) + (BigInt(ze) << BigInt(32));
  }), F.prototype.readBigUInt64BE = V(function(ce) {
    ce = ce >>> 0, Oe(ce, "offset");
    const ve = this[ce], Pe = this[ce + 7];
    (ve === void 0 || Pe === void 0) && Fe(ce, this.length - 8);
    const Be = ve * 2 ** 24 + this[++ce] * 2 ** 16 + this[++ce] * 2 ** 8 + this[++ce], ze = this[++ce] * 2 ** 24 + this[++ce] * 2 ** 16 + this[++ce] * 2 ** 8 + Pe;
    return (BigInt(Be) << BigInt(32)) + BigInt(ze);
  }), F.prototype.readIntLE = function(ce, ve, Pe) {
    ce = ce >>> 0, ve = ve >>> 0, Pe || Ce(ce, ve, this.length);
    let Be = this[ce], ze = 1, Je = 0;
    for (; ++Je < ve && (ze *= 256); )
      Be += this[ce + Je] * ze;
    return ze *= 128, Be >= ze && (Be -= Math.pow(2, 8 * ve)), Be;
  }, F.prototype.readIntBE = function(ce, ve, Pe) {
    ce = ce >>> 0, ve = ve >>> 0, Pe || Ce(ce, ve, this.length);
    let Be = ve, ze = 1, Je = this[ce + --Be];
    for (; Be > 0 && (ze *= 256); )
      Je += this[ce + --Be] * ze;
    return ze *= 128, Je >= ze && (Je -= Math.pow(2, 8 * ve)), Je;
  }, F.prototype.readInt8 = function(ce, ve) {
    return ce = ce >>> 0, ve || Ce(ce, 1, this.length), this[ce] & 128 ? (255 - this[ce] + 1) * -1 : this[ce];
  }, F.prototype.readInt16LE = function(ce, ve) {
    ce = ce >>> 0, ve || Ce(ce, 2, this.length);
    const Pe = this[ce] | this[ce + 1] << 8;
    return Pe & 32768 ? Pe | 4294901760 : Pe;
  }, F.prototype.readInt16BE = function(ce, ve) {
    ce = ce >>> 0, ve || Ce(ce, 2, this.length);
    const Pe = this[ce + 1] | this[ce] << 8;
    return Pe & 32768 ? Pe | 4294901760 : Pe;
  }, F.prototype.readInt32LE = function(ce, ve) {
    return ce = ce >>> 0, ve || Ce(ce, 4, this.length), this[ce] | this[ce + 1] << 8 | this[ce + 2] << 16 | this[ce + 3] << 24;
  }, F.prototype.readInt32BE = function(ce, ve) {
    return ce = ce >>> 0, ve || Ce(ce, 4, this.length), this[ce] << 24 | this[ce + 1] << 16 | this[ce + 2] << 8 | this[ce + 3];
  }, F.prototype.readBigInt64LE = V(function(ce) {
    ce = ce >>> 0, Oe(ce, "offset");
    const ve = this[ce], Pe = this[ce + 7];
    (ve === void 0 || Pe === void 0) && Fe(ce, this.length - 8);
    const Be = this[ce + 4] + this[ce + 5] * 2 ** 8 + this[ce + 6] * 2 ** 16 + (Pe << 24);
    return (BigInt(Be) << BigInt(32)) + BigInt(ve + this[++ce] * 2 ** 8 + this[++ce] * 2 ** 16 + this[++ce] * 2 ** 24);
  }), F.prototype.readBigInt64BE = V(function(ce) {
    ce = ce >>> 0, Oe(ce, "offset");
    const ve = this[ce], Pe = this[ce + 7];
    (ve === void 0 || Pe === void 0) && Fe(ce, this.length - 8);
    const Be = (ve << 24) + // Overflow
    this[++ce] * 2 ** 16 + this[++ce] * 2 ** 8 + this[++ce];
    return (BigInt(Be) << BigInt(32)) + BigInt(this[++ce] * 2 ** 24 + this[++ce] * 2 ** 16 + this[++ce] * 2 ** 8 + Pe);
  }), F.prototype.readFloatLE = function(ce, ve) {
    return ce = ce >>> 0, ve || Ce(ce, 4, this.length), c.read(this, ce, !0, 23, 4);
  }, F.prototype.readFloatBE = function(ce, ve) {
    return ce = ce >>> 0, ve || Ce(ce, 4, this.length), c.read(this, ce, !1, 23, 4);
  }, F.prototype.readDoubleLE = function(ce, ve) {
    return ce = ce >>> 0, ve || Ce(ce, 8, this.length), c.read(this, ce, !0, 52, 8);
  }, F.prototype.readDoubleBE = function(ce, ve) {
    return ce = ce >>> 0, ve || Ce(ce, 8, this.length), c.read(this, ce, !1, 52, 8);
  };
  function De(de, ce, ve, Pe, Be, ze) {
    if (!F.isBuffer(de))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (ce > Be || ce < ze)
      throw new RangeError('"value" argument is out of bounds');
    if (ve + Pe > de.length)
      throw new RangeError("Index out of range");
  }
  F.prototype.writeUintLE = F.prototype.writeUIntLE = function(ce, ve, Pe, Be) {
    if (ce = +ce, ve = ve >>> 0, Pe = Pe >>> 0, !Be) {
      const je = Math.pow(2, 8 * Pe) - 1;
      De(this, ce, ve, Pe, je, 0);
    }
    let ze = 1, Je = 0;
    for (this[ve] = ce & 255; ++Je < Pe && (ze *= 256); )
      this[ve + Je] = ce / ze & 255;
    return ve + Pe;
  }, F.prototype.writeUintBE = F.prototype.writeUIntBE = function(ce, ve, Pe, Be) {
    if (ce = +ce, ve = ve >>> 0, Pe = Pe >>> 0, !Be) {
      const je = Math.pow(2, 8 * Pe) - 1;
      De(this, ce, ve, Pe, je, 0);
    }
    let ze = Pe - 1, Je = 1;
    for (this[ve + ze] = ce & 255; --ze >= 0 && (Je *= 256); )
      this[ve + ze] = ce / Je & 255;
    return ve + Pe;
  }, F.prototype.writeUint8 = F.prototype.writeUInt8 = function(ce, ve, Pe) {
    return ce = +ce, ve = ve >>> 0, Pe || De(this, ce, ve, 1, 255, 0), this[ve] = ce & 255, ve + 1;
  }, F.prototype.writeUint16LE = F.prototype.writeUInt16LE = function(ce, ve, Pe) {
    return ce = +ce, ve = ve >>> 0, Pe || De(this, ce, ve, 2, 65535, 0), this[ve] = ce & 255, this[ve + 1] = ce >>> 8, ve + 2;
  }, F.prototype.writeUint16BE = F.prototype.writeUInt16BE = function(ce, ve, Pe) {
    return ce = +ce, ve = ve >>> 0, Pe || De(this, ce, ve, 2, 65535, 0), this[ve] = ce >>> 8, this[ve + 1] = ce & 255, ve + 2;
  }, F.prototype.writeUint32LE = F.prototype.writeUInt32LE = function(ce, ve, Pe) {
    return ce = +ce, ve = ve >>> 0, Pe || De(this, ce, ve, 4, 4294967295, 0), this[ve + 3] = ce >>> 24, this[ve + 2] = ce >>> 16, this[ve + 1] = ce >>> 8, this[ve] = ce & 255, ve + 4;
  }, F.prototype.writeUint32BE = F.prototype.writeUInt32BE = function(ce, ve, Pe) {
    return ce = +ce, ve = ve >>> 0, Pe || De(this, ce, ve, 4, 4294967295, 0), this[ve] = ce >>> 24, this[ve + 1] = ce >>> 16, this[ve + 2] = ce >>> 8, this[ve + 3] = ce & 255, ve + 4;
  };
  function ye(de, ce, ve, Pe, Be) {
    $e(ce, Pe, Be, de, ve, 7);
    let ze = Number(ce & BigInt(4294967295));
    de[ve++] = ze, ze = ze >> 8, de[ve++] = ze, ze = ze >> 8, de[ve++] = ze, ze = ze >> 8, de[ve++] = ze;
    let Je = Number(ce >> BigInt(32) & BigInt(4294967295));
    return de[ve++] = Je, Je = Je >> 8, de[ve++] = Je, Je = Je >> 8, de[ve++] = Je, Je = Je >> 8, de[ve++] = Je, ve;
  }
  function pe(de, ce, ve, Pe, Be) {
    $e(ce, Pe, Be, de, ve, 7);
    let ze = Number(ce & BigInt(4294967295));
    de[ve + 7] = ze, ze = ze >> 8, de[ve + 6] = ze, ze = ze >> 8, de[ve + 5] = ze, ze = ze >> 8, de[ve + 4] = ze;
    let Je = Number(ce >> BigInt(32) & BigInt(4294967295));
    return de[ve + 3] = Je, Je = Je >> 8, de[ve + 2] = Je, Je = Je >> 8, de[ve + 1] = Je, Je = Je >> 8, de[ve] = Je, ve + 8;
  }
  F.prototype.writeBigUInt64LE = V(function(ce, ve = 0) {
    return ye(this, ce, ve, BigInt(0), BigInt("0xffffffffffffffff"));
  }), F.prototype.writeBigUInt64BE = V(function(ce, ve = 0) {
    return pe(this, ce, ve, BigInt(0), BigInt("0xffffffffffffffff"));
  }), F.prototype.writeIntLE = function(ce, ve, Pe, Be) {
    if (ce = +ce, ve = ve >>> 0, !Be) {
      const Ke = Math.pow(2, 8 * Pe - 1);
      De(this, ce, ve, Pe, Ke - 1, -Ke);
    }
    let ze = 0, Je = 1, je = 0;
    for (this[ve] = ce & 255; ++ze < Pe && (Je *= 256); )
      ce < 0 && je === 0 && this[ve + ze - 1] !== 0 && (je = 1), this[ve + ze] = (ce / Je >> 0) - je & 255;
    return ve + Pe;
  }, F.prototype.writeIntBE = function(ce, ve, Pe, Be) {
    if (ce = +ce, ve = ve >>> 0, !Be) {
      const Ke = Math.pow(2, 8 * Pe - 1);
      De(this, ce, ve, Pe, Ke - 1, -Ke);
    }
    let ze = Pe - 1, Je = 1, je = 0;
    for (this[ve + ze] = ce & 255; --ze >= 0 && (Je *= 256); )
      ce < 0 && je === 0 && this[ve + ze + 1] !== 0 && (je = 1), this[ve + ze] = (ce / Je >> 0) - je & 255;
    return ve + Pe;
  }, F.prototype.writeInt8 = function(ce, ve, Pe) {
    return ce = +ce, ve = ve >>> 0, Pe || De(this, ce, ve, 1, 127, -128), ce < 0 && (ce = 255 + ce + 1), this[ve] = ce & 255, ve + 1;
  }, F.prototype.writeInt16LE = function(ce, ve, Pe) {
    return ce = +ce, ve = ve >>> 0, Pe || De(this, ce, ve, 2, 32767, -32768), this[ve] = ce & 255, this[ve + 1] = ce >>> 8, ve + 2;
  }, F.prototype.writeInt16BE = function(ce, ve, Pe) {
    return ce = +ce, ve = ve >>> 0, Pe || De(this, ce, ve, 2, 32767, -32768), this[ve] = ce >>> 8, this[ve + 1] = ce & 255, ve + 2;
  }, F.prototype.writeInt32LE = function(ce, ve, Pe) {
    return ce = +ce, ve = ve >>> 0, Pe || De(this, ce, ve, 4, 2147483647, -2147483648), this[ve] = ce & 255, this[ve + 1] = ce >>> 8, this[ve + 2] = ce >>> 16, this[ve + 3] = ce >>> 24, ve + 4;
  }, F.prototype.writeInt32BE = function(ce, ve, Pe) {
    return ce = +ce, ve = ve >>> 0, Pe || De(this, ce, ve, 4, 2147483647, -2147483648), ce < 0 && (ce = 4294967295 + ce + 1), this[ve] = ce >>> 24, this[ve + 1] = ce >>> 16, this[ve + 2] = ce >>> 8, this[ve + 3] = ce & 255, ve + 4;
  }, F.prototype.writeBigInt64LE = V(function(ce, ve = 0) {
    return ye(this, ce, ve, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), F.prototype.writeBigInt64BE = V(function(ce, ve = 0) {
    return pe(this, ce, ve, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function Me(de, ce, ve, Pe, Be, ze) {
    if (ve + Pe > de.length)
      throw new RangeError("Index out of range");
    if (ve < 0)
      throw new RangeError("Index out of range");
  }
  function Ne(de, ce, ve, Pe, Be) {
    return ce = +ce, ve = ve >>> 0, Be || Me(de, ce, ve, 4), c.write(de, ce, ve, Pe, 23, 4), ve + 4;
  }
  F.prototype.writeFloatLE = function(ce, ve, Pe) {
    return Ne(this, ce, ve, !0, Pe);
  }, F.prototype.writeFloatBE = function(ce, ve, Pe) {
    return Ne(this, ce, ve, !1, Pe);
  };
  function Ue(de, ce, ve, Pe, Be) {
    return ce = +ce, ve = ve >>> 0, Be || Me(de, ce, ve, 8), c.write(de, ce, ve, Pe, 52, 8), ve + 8;
  }
  F.prototype.writeDoubleLE = function(ce, ve, Pe) {
    return Ue(this, ce, ve, !0, Pe);
  }, F.prototype.writeDoubleBE = function(ce, ve, Pe) {
    return Ue(this, ce, ve, !1, Pe);
  }, F.prototype.copy = function(ce, ve, Pe, Be) {
    if (!F.isBuffer(ce))
      throw new TypeError("argument should be a Buffer");
    if (Pe || (Pe = 0), !Be && Be !== 0 && (Be = this.length), ve >= ce.length && (ve = ce.length), ve || (ve = 0), Be > 0 && Be < Pe && (Be = Pe), Be === Pe || ce.length === 0 || this.length === 0)
      return 0;
    if (ve < 0)
      throw new RangeError("targetStart out of bounds");
    if (Pe < 0 || Pe >= this.length)
      throw new RangeError("Index out of range");
    if (Be < 0)
      throw new RangeError("sourceEnd out of bounds");
    Be > this.length && (Be = this.length), ce.length - ve < Be - Pe && (Be = ce.length - ve + Pe);
    const ze = Be - Pe;
    return this === ce && typeof p.prototype.copyWithin == "function" ? this.copyWithin(ve, Pe, Be) : p.prototype.set.call(
      ce,
      this.subarray(Pe, Be),
      ve
    ), ze;
  }, F.prototype.fill = function(ce, ve, Pe, Be) {
    if (typeof ce == "string") {
      if (typeof ve == "string" ? (Be = ve, ve = 0, Pe = this.length) : typeof Pe == "string" && (Be = Pe, Pe = this.length), Be !== void 0 && typeof Be != "string")
        throw new TypeError("encoding must be a string");
      if (typeof Be == "string" && !F.isEncoding(Be))
        throw new TypeError("Unknown encoding: " + Be);
      if (ce.length === 1) {
        const Je = ce.charCodeAt(0);
        (Be === "utf8" && Je < 128 || Be === "latin1") && (ce = Je);
      }
    } else
      typeof ce == "number" ? ce = ce & 255 : typeof ce == "boolean" && (ce = Number(ce));
    if (ve < 0 || this.length < ve || this.length < Pe)
      throw new RangeError("Out of range index");
    if (Pe <= ve)
      return this;
    ve = ve >>> 0, Pe = Pe === void 0 ? this.length : Pe >>> 0, ce || (ce = 0);
    let ze;
    if (typeof ce == "number")
      for (ze = ve; ze < Pe; ++ze)
        this[ze] = ce;
    else {
      const Je = F.isBuffer(ce) ? ce : F.from(ce, Be), je = Je.length;
      if (je === 0)
        throw new TypeError('The value "' + ce + '" is invalid for argument "value"');
      for (ze = 0; ze < Pe - ve; ++ze)
        this[ze + ve] = Je[ze % je];
    }
    return this;
  };
  const oe = {};
  function A(de, ce, ve) {
    oe[de] = class extends ve {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: ce.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${de}]`, this.stack, delete this.name;
      }
      get code() {
        return de;
      }
      set code(Be) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: Be,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${de}]: ${this.message}`;
      }
    };
  }
  A(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(de) {
      return de ? `${de} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), A(
    "ERR_INVALID_ARG_TYPE",
    function(de, ce) {
      return `The "${de}" argument must be of type number. Received type ${typeof ce}`;
    },
    TypeError
  ), A(
    "ERR_OUT_OF_RANGE",
    function(de, ce, ve) {
      let Pe = `The value of "${de}" is out of range.`, Be = ve;
      return Number.isInteger(ve) && Math.abs(ve) > 2 ** 32 ? Be = re(String(ve)) : typeof ve == "bigint" && (Be = String(ve), (ve > BigInt(2) ** BigInt(32) || ve < -(BigInt(2) ** BigInt(32))) && (Be = re(Be)), Be += "n"), Pe += ` It must be ${ce}. Received ${Be}`, Pe;
    },
    RangeError
  );
  function re(de) {
    let ce = "", ve = de.length;
    const Pe = de[0] === "-" ? 1 : 0;
    for (; ve >= Pe + 4; ve -= 3)
      ce = `_${de.slice(ve - 3, ve)}${ce}`;
    return `${de.slice(0, ve)}${ce}`;
  }
  function le(de, ce, ve) {
    Oe(ce, "offset"), (de[ce] === void 0 || de[ce + ve] === void 0) && Fe(ce, de.length - (ve + 1));
  }
  function $e(de, ce, ve, Pe, Be, ze) {
    if (de > ve || de < ce) {
      const Je = typeof ce == "bigint" ? "n" : "";
      let je;
      throw ze > 3 ? ce === 0 || ce === BigInt(0) ? je = `>= 0${Je} and < 2${Je} ** ${(ze + 1) * 8}${Je}` : je = `>= -(2${Je} ** ${(ze + 1) * 8 - 1}${Je}) and < 2 ** ${(ze + 1) * 8 - 1}${Je}` : je = `>= ${ce}${Je} and <= ${ve}${Je}`, new oe.ERR_OUT_OF_RANGE("value", je, de);
    }
    le(Pe, Be, ze);
  }
  function Oe(de, ce) {
    if (typeof de != "number")
      throw new oe.ERR_INVALID_ARG_TYPE(ce, "number", de);
  }
  function Fe(de, ce, ve) {
    throw Math.floor(de) !== de ? (Oe(de, ve), new oe.ERR_OUT_OF_RANGE(ve || "offset", "an integer", de)) : ce < 0 ? new oe.ERR_BUFFER_OUT_OF_BOUNDS() : new oe.ERR_OUT_OF_RANGE(
      ve || "offset",
      `>= ${ve ? 1 : 0} and <= ${ce}`,
      de
    );
  }
  const Ze = /[^+/0-9A-Za-z-_]/g;
  function qe(de) {
    if (de = de.split("=")[0], de = de.trim().replace(Ze, ""), de.length < 2)
      return "";
    for (; de.length % 4 !== 0; )
      de = de + "=";
    return de;
  }
  function yt(de, ce) {
    ce = ce || 1 / 0;
    let ve;
    const Pe = de.length;
    let Be = null;
    const ze = [];
    for (let Je = 0; Je < Pe; ++Je) {
      if (ve = de.charCodeAt(Je), ve > 55295 && ve < 57344) {
        if (!Be) {
          if (ve > 56319) {
            (ce -= 3) > -1 && ze.push(239, 191, 189);
            continue;
          } else if (Je + 1 === Pe) {
            (ce -= 3) > -1 && ze.push(239, 191, 189);
            continue;
          }
          Be = ve;
          continue;
        }
        if (ve < 56320) {
          (ce -= 3) > -1 && ze.push(239, 191, 189), Be = ve;
          continue;
        }
        ve = (Be - 55296 << 10 | ve - 56320) + 65536;
      } else
        Be && (ce -= 3) > -1 && ze.push(239, 191, 189);
      if (Be = null, ve < 128) {
        if ((ce -= 1) < 0)
          break;
        ze.push(ve);
      } else if (ve < 2048) {
        if ((ce -= 2) < 0)
          break;
        ze.push(
          ve >> 6 | 192,
          ve & 63 | 128
        );
      } else if (ve < 65536) {
        if ((ce -= 3) < 0)
          break;
        ze.push(
          ve >> 12 | 224,
          ve >> 6 & 63 | 128,
          ve & 63 | 128
        );
      } else if (ve < 1114112) {
        if ((ce -= 4) < 0)
          break;
        ze.push(
          ve >> 18 | 240,
          ve >> 12 & 63 | 128,
          ve >> 6 & 63 | 128,
          ve & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return ze;
  }
  function Xe(de) {
    const ce = [];
    for (let ve = 0; ve < de.length; ++ve)
      ce.push(de.charCodeAt(ve) & 255);
    return ce;
  }
  function Ge(de, ce) {
    let ve, Pe, Be;
    const ze = [];
    for (let Je = 0; Je < de.length && !((ce -= 2) < 0); ++Je)
      ve = de.charCodeAt(Je), Pe = ve >> 8, Be = ve % 256, ze.push(Be), ze.push(Pe);
    return ze;
  }
  function J(de) {
    return u.toByteArray(qe(de));
  }
  function ge(de, ce, ve, Pe) {
    let Be;
    for (Be = 0; Be < Pe && !(Be + ve >= ce.length || Be >= de.length); ++Be)
      ce[Be + ve] = de[Be];
    return Be;
  }
  function we(de, ce) {
    return de instanceof ce || de != null && de.constructor != null && de.constructor.name != null && de.constructor.name === ce.name;
  }
  function We(de) {
    return de !== de;
  }
  const Ie = function() {
    const de = "0123456789abcdef", ce = new Array(256);
    for (let ve = 0; ve < 16; ++ve) {
      const Pe = ve * 16;
      for (let Be = 0; Be < 16; ++Be)
        ce[Pe + Be] = de[ve] + de[Be];
    }
    return ce;
  }();
  function V(de) {
    return typeof BigInt > "u" ? Ee : de;
  }
  function Ee() {
    throw new Error("BigInt not supported");
  }
})(buffer$3);
const Buffer$O = buffer$3.Buffer, Blob$1 = buffer$3.Blob, BlobOptions = buffer$3.BlobOptions, Buffer$1$1 = buffer$3.Buffer, File = buffer$3.File, FileOptions = buffer$3.FileOptions, INSPECT_MAX_BYTES = buffer$3.INSPECT_MAX_BYTES, SlowBuffer$1 = buffer$3.SlowBuffer, TranscodeEncoding = buffer$3.TranscodeEncoding, atob$1 = buffer$3.atob, btoa$1 = buffer$3.btoa, constants$1 = buffer$3.constants, isAscii = buffer$3.isAscii, isUtf8 = buffer$3.isUtf8, kMaxLength = buffer$3.kMaxLength, kStringMaxLength = buffer$3.kStringMaxLength, resolveObjectURL = buffer$3.resolveObjectURL, transcode = buffer$3.transcode, dist$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Blob: Blob$1,
  BlobOptions,
  Buffer: Buffer$1$1,
  File,
  FileOptions,
  INSPECT_MAX_BYTES,
  SlowBuffer: SlowBuffer$1,
  TranscodeEncoding,
  atob: atob$1,
  btoa: btoa$1,
  constants: constants$1,
  default: Buffer$O,
  isAscii,
  isUtf8,
  kMaxLength,
  kStringMaxLength,
  resolveObjectURL,
  transcode
}, Symbol.toStringTag, { value: "Module" }));
var base64$2 = { exports: {} };
(function(a, u) {
  (function(c, l) {
    a.exports = l();
  })(typeof self < "u" ? self : typeof window < "u" ? window : commonjsGlobal$1, function() {
    var c = "3.7.2", l = c, v = typeof atob == "function", p = typeof btoa == "function", _ = typeof Buffer$O == "function", k = typeof TextDecoder == "function" ? new TextDecoder() : void 0, O = typeof TextEncoder == "function" ? new TextEncoder() : void 0, D = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", F = Array.prototype.slice.call(D), H = function(pe) {
      var Me = {};
      return pe.forEach(function(Ne, Ue) {
        return Me[Ne] = Ue;
      }), Me;
    }(F), Z = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/, ee = String.fromCharCode.bind(String), X = typeof Uint8Array.from == "function" ? Uint8Array.from.bind(Uint8Array) : function(pe, Me) {
      return Me === void 0 && (Me = function(Ne) {
        return Ne;
      }), new Uint8Array(Array.prototype.slice.call(pe, 0).map(Me));
    }, ne = function(pe) {
      return pe.replace(/=/g, "").replace(/[+\/]/g, function(Me) {
        return Me == "+" ? "-" : "_";
      });
    }, Q = function(pe) {
      return pe.replace(/[^A-Za-z0-9\+\/]/g, "");
    }, ae = function(pe) {
      for (var Me, Ne, Ue, oe, A = "", re = pe.length % 3, le = 0; le < pe.length; ) {
        if ((Ne = pe.charCodeAt(le++)) > 255 || (Ue = pe.charCodeAt(le++)) > 255 || (oe = pe.charCodeAt(le++)) > 255)
          throw new TypeError("invalid character found");
        Me = Ne << 16 | Ue << 8 | oe, A += F[Me >> 18 & 63] + F[Me >> 12 & 63] + F[Me >> 6 & 63] + F[Me & 63];
      }
      return re ? A.slice(0, re - 3) + "===".substring(re) : A;
    }, j = p ? function(pe) {
      return btoa(pe);
    } : _ ? function(pe) {
      return Buffer$O.from(pe, "binary").toString("base64");
    } : ae, ue = _ ? function(pe) {
      return Buffer$O.from(pe).toString("base64");
    } : function(pe) {
      for (var Me = 4096, Ne = [], Ue = 0, oe = pe.length; Ue < oe; Ue += Me)
        Ne.push(ee.apply(null, pe.subarray(Ue, Ue + Me)));
      return j(Ne.join(""));
    }, he = function(pe, Me) {
      return Me === void 0 && (Me = !1), Me ? ne(ue(pe)) : ue(pe);
    }, fe = function(pe) {
      if (pe.length < 2) {
        var Me = pe.charCodeAt(0);
        return Me < 128 ? pe : Me < 2048 ? ee(192 | Me >>> 6) + ee(128 | Me & 63) : ee(224 | Me >>> 12 & 15) + ee(128 | Me >>> 6 & 63) + ee(128 | Me & 63);
      } else {
        var Me = 65536 + (pe.charCodeAt(0) - 55296) * 1024 + (pe.charCodeAt(1) - 56320);
        return ee(240 | Me >>> 18 & 7) + ee(128 | Me >>> 12 & 63) + ee(128 | Me >>> 6 & 63) + ee(128 | Me & 63);
      }
    }, be = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g, ke = function(pe) {
      return pe.replace(be, fe);
    }, Te = _ ? function(pe) {
      return Buffer$O.from(pe, "utf8").toString("base64");
    } : O ? function(pe) {
      return ue(O.encode(pe));
    } : function(pe) {
      return j(ke(pe));
    }, q = function(pe, Me) {
      return Me === void 0 && (Me = !1), Me ? ne(Te(pe)) : Te(pe);
    }, z = function(pe) {
      return q(pe, !0);
    }, P = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g, S = function(pe) {
      switch (pe.length) {
        case 4:
          var Me = (7 & pe.charCodeAt(0)) << 18 | (63 & pe.charCodeAt(1)) << 12 | (63 & pe.charCodeAt(2)) << 6 | 63 & pe.charCodeAt(3), Ne = Me - 65536;
          return ee((Ne >>> 10) + 55296) + ee((Ne & 1023) + 56320);
        case 3:
          return ee((15 & pe.charCodeAt(0)) << 12 | (63 & pe.charCodeAt(1)) << 6 | 63 & pe.charCodeAt(2));
        default:
          return ee((31 & pe.charCodeAt(0)) << 6 | 63 & pe.charCodeAt(1));
      }
    }, E = function(pe) {
      return pe.replace(P, S);
    }, I = function(pe) {
      if (pe = pe.replace(/\s+/g, ""), !Z.test(pe))
        throw new TypeError("malformed base64.");
      pe += "==".slice(2 - (pe.length & 3));
      for (var Me, Ne = "", Ue, oe, A = 0; A < pe.length; )
        Me = H[pe.charAt(A++)] << 18 | H[pe.charAt(A++)] << 12 | (Ue = H[pe.charAt(A++)]) << 6 | (oe = H[pe.charAt(A++)]), Ne += Ue === 64 ? ee(Me >> 16 & 255) : oe === 64 ? ee(Me >> 16 & 255, Me >> 8 & 255) : ee(Me >> 16 & 255, Me >> 8 & 255, Me & 255);
      return Ne;
    }, M = v ? function(pe) {
      return atob(Q(pe));
    } : _ ? function(pe) {
      return Buffer$O.from(pe, "base64").toString("binary");
    } : I, $ = _ ? function(pe) {
      return X(Buffer$O.from(pe, "base64"));
    } : function(pe) {
      return X(M(pe), function(Me) {
        return Me.charCodeAt(0);
      });
    }, U = function(pe) {
      return $(B(pe));
    }, Y = _ ? function(pe) {
      return Buffer$O.from(pe, "base64").toString("utf8");
    } : k ? function(pe) {
      return k.decode($(pe));
    } : function(pe) {
      return E(M(pe));
    }, B = function(pe) {
      return Q(pe.replace(/[-_]/g, function(Me) {
        return Me == "-" ? "+" : "/";
      }));
    }, T = function(pe) {
      return Y(B(pe));
    }, L = function(pe) {
      if (typeof pe != "string")
        return !1;
      var Me = pe.replace(/\s+/g, "").replace(/={0,2}$/, "");
      return !/[^\s0-9a-zA-Z\+/]/.test(Me) || !/[^\s0-9a-zA-Z\-_]/.test(Me);
    }, te = function(pe) {
      return {
        value: pe,
        enumerable: !1,
        writable: !0,
        configurable: !0
      };
    }, me = function() {
      var pe = function(Me, Ne) {
        return Object.defineProperty(String.prototype, Me, te(Ne));
      };
      pe("fromBase64", function() {
        return T(this);
      }), pe("toBase64", function(Me) {
        return q(this, Me);
      }), pe("toBase64URI", function() {
        return q(this, !0);
      }), pe("toBase64URL", function() {
        return q(this, !0);
      }), pe("toUint8Array", function() {
        return U(this);
      });
    }, Ce = function() {
      var pe = function(Me, Ne) {
        return Object.defineProperty(Uint8Array.prototype, Me, te(Ne));
      };
      pe("toBase64", function(Me) {
        return he(this, Me);
      }), pe("toBase64URI", function() {
        return he(this, !0);
      }), pe("toBase64URL", function() {
        return he(this, !0);
      });
    }, De = function() {
      me(), Ce();
    }, ye = {
      version: c,
      VERSION: l,
      atob: M,
      atobPolyfill: I,
      btoa: j,
      btoaPolyfill: ae,
      fromBase64: T,
      toBase64: q,
      encode: q,
      encodeURI: z,
      encodeURL: z,
      utob: ke,
      btou: E,
      decode: T,
      isValid: L,
      fromUint8Array: he,
      toUint8Array: U,
      extendString: me,
      extendUint8Array: Ce,
      extendBuiltins: De
    };
    return ye.Base64 = {}, Object.keys(ye).forEach(function(pe) {
      return ye.Base64[pe] = ye[pe];
    }), ye;
  });
})(base64$2);
var base64Exports = base64$2.exports;
Object.defineProperty(convertMetadata, "__esModule", { value: !0 });
convertMetadata.convertMetadataFromGrpcWeb = convertMetadata.convertMetadataToGrpcWeb = void 0;
const grpc_web_1$4 = grpcWebClient_umdExports, nice_grpc_common_1$5 = lib, js_base64_1 = base64Exports;
function convertMetadataToGrpcWeb(a) {
  const u = new grpc_web_1$4.grpc.Metadata();
  for (const [c, l] of a)
    for (const v of l)
      u.append(c, typeof v == "string" ? v : js_base64_1.Base64.fromUint8Array(v));
  return u;
}
convertMetadata.convertMetadataToGrpcWeb = convertMetadataToGrpcWeb;
function convertMetadataFromGrpcWeb(a) {
  const u = (0, nice_grpc_common_1$5.Metadata)();
  for (const [c, l] of Object.entries(a.headersMap))
    u.set(c, c.endsWith("-bin") ? l.map((v) => js_base64_1.Base64.toUint8Array(v)) : l);
  return u;
}
convertMetadata.convertMetadataFromGrpcWeb = convertMetadataFromGrpcWeb;
var __importDefault$h = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(createBidiStreamingMethod$1, "__esModule", { value: !0 });
createBidiStreamingMethod$1.createBidiStreamingMethod = void 0;
const nice_grpc_common_1$4 = lib, grpc_web_1$3 = grpcWebClient_umdExports, abort_controller_x_1$4 = require$$1$3, node_abort_controller_1$3 = __importDefault$h(browserExports$2), AsyncSink_1$1 = AsyncSink$1, service_definitions_1$4 = serviceDefinitions, isAsyncIterable_1$3 = isAsyncIterable$1, convertMetadata_1$3 = convertMetadata;
function createBidiStreamingMethod(a, u, c, l) {
  const v = (0, service_definitions_1$4.toGrpcWebMethodDefinition)(a), p = {
    path: a.path,
    requestStream: a.requestStream,
    responseStream: a.responseStream,
    options: a.options
  };
  async function* _(O, D) {
    if (!(0, isAsyncIterable_1$3.isAsyncIterable)(O))
      throw new Error("A middleware passed invalid request to next(): expected a single message for bidirectional streaming method");
    const { metadata: F = (0, nice_grpc_common_1$4.Metadata)(), signal: H = new node_abort_controller_1$3.default().signal, onHeader: Z, onTrailer: ee } = D, X = new node_abort_controller_1$3.default(), ne = new AsyncSink_1$1.AsyncSink(), Q = grpc_web_1$3.grpc.client(v, {
      host: u.address,
      transport: u.transport
    });
    Q.onHeaders((ue) => {
      Z == null || Z((0, convertMetadata_1$3.convertMetadataFromGrpcWeb)(ue));
    }), Q.onMessage((ue) => {
      ne.write(ue);
    }), Q.onEnd((ue, he, fe) => {
      ee == null || ee((0, convertMetadata_1$3.convertMetadataFromGrpcWeb)(fe)), ue === grpc_web_1$3.grpc.Code.OK ? ne.end() : ne.error(new nice_grpc_common_1$4.ClientError(a.path, +ue, he));
    }), Q.start((0, convertMetadata_1$3.convertMetadataToGrpcWeb)(F));
    let ae;
    pipeRequest$1(X.signal, O, Q, a).then(() => {
      Q.finishSend();
    }, (ue) => {
      (0, abort_controller_x_1$4.isAbortError)(ue) || (ae = ue, Q.close(), ne.end());
    });
    const j = () => {
      ne.error(new abort_controller_x_1$4.AbortError()), X.abort(), Q.close();
    };
    H.addEventListener("abort", j);
    try {
      yield* ne;
    } finally {
      if (X.abort(), H.removeEventListener("abort", j), (0, abort_controller_x_1$4.throwIfAborted)(H), ae)
        throw ae;
    }
  }
  const k = c == null ? _ : (O, D) => c({
    method: p,
    requestStream: !0,
    request: O,
    responseStream: !0,
    next: _
  }, D);
  return (O, D) => {
    const H = k(O, {
      ...l,
      ...D
    })[Symbol.asyncIterator]();
    return {
      [Symbol.asyncIterator]() {
        return {
          async next() {
            const Z = await H.next();
            return Z.done && Z.value != null ? await H.throw(new Error("A middleware returned a message, but expected to return void for bidirectional streaming method")) : Z;
          },
          return() {
            return H.return();
          },
          throw(Z) {
            return H.throw(Z);
          }
        };
      }
    };
  };
}
createBidiStreamingMethod$1.createBidiStreamingMethod = createBidiStreamingMethod;
async function pipeRequest$1(a, u, c, l) {
  for await (const v of u)
    (0, abort_controller_x_1$4.throwIfAborted)(a), c.send({
      serializeBinary: () => l.requestSerialize(v)
    });
}
var createClientStreamingMethod$1 = {}, __importDefault$g = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(createClientStreamingMethod$1, "__esModule", { value: !0 });
createClientStreamingMethod$1.createClientStreamingMethod = void 0;
const nice_grpc_common_1$3 = lib, grpc_web_1$2 = grpcWebClient_umdExports, abort_controller_x_1$3 = require$$1$3, node_abort_controller_1$2 = __importDefault$g(browserExports$2), service_definitions_1$3 = serviceDefinitions, isAsyncIterable_1$2 = isAsyncIterable$1, convertMetadata_1$2 = convertMetadata;
function createClientStreamingMethod(a, u, c, l) {
  const v = (0, service_definitions_1$3.toGrpcWebMethodDefinition)(a), p = {
    path: a.path,
    requestStream: a.requestStream,
    responseStream: a.responseStream,
    options: a.options
  };
  async function* _(O, D) {
    if (!(0, isAsyncIterable_1$2.isAsyncIterable)(O))
      throw new Error("A middleware passed invalid request to next(): expected a single message for client streaming method");
    const { metadata: F = (0, nice_grpc_common_1$3.Metadata)(), signal: H = new node_abort_controller_1$2.default().signal, onHeader: Z, onTrailer: ee } = D;
    return await (0, abort_controller_x_1$3.execute)(H, (X, ne) => {
      const Q = new node_abort_controller_1$2.default();
      let ae;
      const j = grpc_web_1$2.grpc.client(v, {
        host: u.address,
        transport: u.transport
      });
      return j.onHeaders((ue) => {
        Z == null || Z((0, convertMetadata_1$2.convertMetadataFromGrpcWeb)(ue));
      }), j.onMessage((ue) => {
        ae = ue;
      }), j.onEnd((ue, he, fe) => {
        ee == null || ee((0, convertMetadata_1$2.convertMetadataFromGrpcWeb)(fe)), Q.abort(), ue === grpc_web_1$2.grpc.Code.OK ? X(ae) : ne(new nice_grpc_common_1$3.ClientError(a.path, +ue, he));
      }), j.start((0, convertMetadata_1$2.convertMetadataToGrpcWeb)(F)), pipeRequest(Q.signal, O, j, a).then(() => {
        j.finishSend();
      }, (ue) => {
        (0, abort_controller_x_1$3.isAbortError)(ue) || (ne(ue), j.close());
      }), () => {
        Q.abort(), j.close();
      };
    });
  }
  const k = c == null ? _ : (O, D) => c({
    method: p,
    requestStream: !0,
    request: O,
    responseStream: !1,
    next: _
  }, D);
  return async (O, D) => {
    const H = k(O, {
      ...l,
      ...D
    })[Symbol.asyncIterator]();
    let Z = await H.next();
    for (; ; ) {
      if (!Z.done) {
        Z = await H.throw(new Error("A middleware yielded a message, but expected to only return a message for client streaming method"));
        continue;
      }
      if (Z.value == null) {
        Z = await H.throw(new Error("A middleware returned void, but expected to return a message for client streaming method"));
        continue;
      }
      return Z.value;
    }
  };
}
createClientStreamingMethod$1.createClientStreamingMethod = createClientStreamingMethod;
async function pipeRequest(a, u, c, l) {
  for await (const v of u)
    (0, abort_controller_x_1$3.throwIfAborted)(a), c.send({
      serializeBinary: () => l.requestSerialize(v)
    });
}
var createServerStreamingMethod$1 = {}, __importDefault$f = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(createServerStreamingMethod$1, "__esModule", { value: !0 });
createServerStreamingMethod$1.createServerStreamingMethod = void 0;
const grpc_web_1$1 = grpcWebClient_umdExports, abort_controller_x_1$2 = require$$1$3, AsyncSink_1 = AsyncSink$1, nice_grpc_common_1$2 = lib, node_abort_controller_1$1 = __importDefault$f(browserExports$2), service_definitions_1$2 = serviceDefinitions, convertMetadata_1$1 = convertMetadata, isAsyncIterable_1$1 = isAsyncIterable$1;
function createServerStreamingMethod(a, u, c, l) {
  const v = (0, service_definitions_1$2.toGrpcWebMethodDefinition)(a), p = {
    path: a.path,
    requestStream: a.requestStream,
    responseStream: a.responseStream,
    options: a.options
  };
  async function* _(O, D) {
    if ((0, isAsyncIterable_1$1.isAsyncIterable)(O))
      throw new Error("A middleware passed invalid request to next(): expected a single message for server streaming method");
    const { metadata: F = (0, nice_grpc_common_1$2.Metadata)(), signal: H = new node_abort_controller_1$1.default().signal, onHeader: Z, onTrailer: ee } = D, X = new AsyncSink_1.AsyncSink(), ne = grpc_web_1$1.grpc.client(v, {
      host: u.address,
      transport: u.transport
    });
    ne.onHeaders((ae) => {
      Z == null || Z((0, convertMetadata_1$1.convertMetadataFromGrpcWeb)(ae));
    }), ne.onMessage((ae) => {
      X.write(ae);
    }), ne.onEnd((ae, j, ue) => {
      ee == null || ee((0, convertMetadata_1$1.convertMetadataFromGrpcWeb)(ue)), ae === grpc_web_1$1.grpc.Code.OK ? X.end() : X.error(new nice_grpc_common_1$2.ClientError(a.path, +ae, j));
    }), ne.start((0, convertMetadata_1$1.convertMetadataToGrpcWeb)(F)), ne.send({
      serializeBinary: () => a.requestSerialize(O)
    }), ne.finishSend();
    const Q = () => {
      X.error(new abort_controller_x_1$2.AbortError()), ne.close();
    };
    H.addEventListener("abort", Q);
    try {
      yield* X;
    } finally {
      H.removeEventListener("abort", Q), (0, abort_controller_x_1$2.throwIfAborted)(H);
    }
  }
  const k = c == null ? _ : (O, D) => c({
    method: p,
    requestStream: !1,
    request: O,
    responseStream: !0,
    next: _
  }, D);
  return (O, D) => {
    const H = k(O, {
      ...l,
      ...D
    })[Symbol.asyncIterator]();
    return {
      [Symbol.asyncIterator]() {
        return {
          async next() {
            const Z = await H.next();
            return Z.done && Z.value != null ? await H.throw(new Error("A middleware returned a message, but expected to return void for server streaming method")) : Z;
          },
          return() {
            return H.return();
          },
          throw(Z) {
            return H.throw(Z);
          }
        };
      }
    };
  };
}
createServerStreamingMethod$1.createServerStreamingMethod = createServerStreamingMethod;
var createUnaryMethod$1 = {}, __importDefault$e = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(createUnaryMethod$1, "__esModule", { value: !0 });
createUnaryMethod$1.createUnaryMethod = void 0;
const nice_grpc_common_1$1 = lib, grpc_web_1 = grpcWebClient_umdExports, abort_controller_x_1$1 = require$$1$3, node_abort_controller_1 = __importDefault$e(browserExports$2), service_definitions_1$1 = serviceDefinitions, isAsyncIterable_1 = isAsyncIterable$1, convertMetadata_1 = convertMetadata;
function createUnaryMethod(a, u, c, l) {
  const v = (0, service_definitions_1$1.toGrpcWebMethodDefinition)(a), p = {
    path: a.path,
    requestStream: a.requestStream,
    responseStream: a.responseStream,
    options: a.options
  };
  async function* _(O, D) {
    if ((0, isAsyncIterable_1.isAsyncIterable)(O))
      throw new Error("A middleware passed invalid request to next(): expected a single message for unary method");
    const { metadata: F = (0, nice_grpc_common_1$1.Metadata)(), signal: H = new node_abort_controller_1.default().signal, onHeader: Z, onTrailer: ee } = D;
    return await (0, abort_controller_x_1$1.execute)(H, (X, ne) => {
      let Q;
      const ae = grpc_web_1.grpc.client(v, {
        host: u.address,
        transport: u.transport
      });
      return ae.onHeaders((j) => {
        Z == null || Z((0, convertMetadata_1.convertMetadataFromGrpcWeb)(j));
      }), ae.onMessage((j) => {
        Q = j;
      }), ae.onEnd((j, ue, he) => {
        ee == null || ee((0, convertMetadata_1.convertMetadataFromGrpcWeb)(he)), j === grpc_web_1.grpc.Code.OK ? X(Q) : ne(new nice_grpc_common_1$1.ClientError(a.path, +j, ue));
      }), ae.start((0, convertMetadata_1.convertMetadataToGrpcWeb)(F)), ae.send({
        serializeBinary: () => a.requestSerialize(O)
      }), ae.finishSend(), () => {
        ae.close();
      };
    });
  }
  const k = c == null ? _ : (O, D) => c({
    method: p,
    requestStream: !1,
    request: O,
    responseStream: !1,
    next: _
  }, D);
  return async (O, D) => {
    const H = k(O, {
      ...l,
      ...D
    })[Symbol.asyncIterator]();
    let Z = await H.next();
    for (; ; ) {
      if (!Z.done) {
        Z = await H.throw(new Error("A middleware yielded a message, but expected to only return a message for unary method"));
        continue;
      }
      if (Z.value == null) {
        Z = await H.throw(new Error("A middleware returned void, but expected to return a message for unary method"));
        continue;
      }
      return Z.value;
    }
  };
}
createUnaryMethod$1.createUnaryMethod = createUnaryMethod;
Object.defineProperty(ClientFactory, "__esModule", { value: !0 });
ClientFactory.createClient = ClientFactory.createClientFactory = void 0;
const nice_grpc_common_1 = lib, service_definitions_1 = serviceDefinitions, createBidiStreamingMethod_1 = createBidiStreamingMethod$1, createClientStreamingMethod_1 = createClientStreamingMethod$1, createServerStreamingMethod_1 = createServerStreamingMethod$1, createUnaryMethod_1 = createUnaryMethod$1;
function createClientFactory() {
  return createClientFactoryWithMiddleware();
}
ClientFactory.createClientFactory = createClientFactory;
function createClient(a, u, c) {
  return createClientFactory().create(a, u, c);
}
ClientFactory.createClient = createClient;
function createClientFactoryWithMiddleware(a) {
  return {
    use(u) {
      return createClientFactoryWithMiddleware(a == null ? u : (0, nice_grpc_common_1.composeClientMiddleware)(a, u));
    },
    create(u, c, l = {}) {
      const v = {}, p = Object.entries((0, service_definitions_1.normalizeServiceDefinition)(u));
      for (const [_, k] of p) {
        const O = {
          ...l["*"],
          ...l[_]
        };
        k.requestStream ? k.responseStream ? v[_] = (0, createBidiStreamingMethod_1.createBidiStreamingMethod)(k, c, a, O) : v[_] = (0, createClientStreamingMethod_1.createClientStreamingMethod)(k, c, a, O) : k.responseStream ? v[_] = (0, createServerStreamingMethod_1.createServerStreamingMethod)(k, c, a, O) : v[_] = (0, createUnaryMethod_1.createUnaryMethod)(k, c, a, O);
      }
      return v;
    }
  };
}
var Client = {};
Object.defineProperty(Client, "__esModule", { value: !0 });
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(v, p, _, k) {
    k === void 0 && (k = _);
    var O = Object.getOwnPropertyDescriptor(p, _);
    (!O || ("get" in O ? !p.__esModule : O.writable || O.configurable)) && (O = { enumerable: !0, get: function() {
      return p[_];
    } }), Object.defineProperty(v, k, O);
  } : function(v, p, _, k) {
    k === void 0 && (k = _), v[k] = p[_];
  }), c = commonjsGlobal$1 && commonjsGlobal$1.__exportStar || function(v, p) {
    for (var _ in v)
      _ !== "default" && !Object.prototype.hasOwnProperty.call(p, _) && u(p, v, _);
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.Status = a.Metadata = a.composeClientMiddleware = a.ClientError = void 0;
  var l = lib;
  Object.defineProperty(a, "ClientError", { enumerable: !0, get: function() {
    return l.ClientError;
  } }), Object.defineProperty(a, "composeClientMiddleware", { enumerable: !0, get: function() {
    return l.composeClientMiddleware;
  } }), Object.defineProperty(a, "Metadata", { enumerable: !0, get: function() {
    return l.Metadata;
  } }), Object.defineProperty(a, "Status", { enumerable: !0, get: function() {
    return l.Status;
  } }), c(serviceDefinitions, a), c(channel, a), c(ClientFactory, a), c(Client, a);
})(lib$1);
var dist$2 = {}, api$4 = {}, umd = { exports: {} };
(function(a, u) {
  var c = function(l) {
    Object.defineProperty(l, "__esModule", {
      value: !0
    }), l.default = void 0;
    /**
     * @license
     * Copyright 2009 The Closure Library Authors
     * Copyright 2020 Daniel Wirtz / The long.js Authors.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
     * SPDX-License-Identifier: Apache-2.0
     */
    var v = null;
    try {
      v = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
    } catch {
    }
    function p($, U, Y) {
      this.low = $ | 0, this.high = U | 0, this.unsigned = !!Y;
    }
    p.prototype.__isLong__, Object.defineProperty(p.prototype, "__isLong__", {
      value: !0
    });
    function _($) {
      return ($ && $.__isLong__) === !0;
    }
    function k($) {
      var U = Math.clz32($ & -$);
      return $ ? 31 - U : U;
    }
    p.isLong = _;
    var O = {}, D = {};
    function F($, U) {
      var Y, B, T;
      return U ? ($ >>>= 0, (T = 0 <= $ && $ < 256) && (B = D[$], B) ? B : (Y = Z($, 0, !0), T && (D[$] = Y), Y)) : ($ |= 0, (T = -128 <= $ && $ < 128) && (B = O[$], B) ? B : (Y = Z($, $ < 0 ? -1 : 0, !1), T && (O[$] = Y), Y));
    }
    p.fromInt = F;
    function H($, U) {
      if (isNaN($))
        return U ? ke : be;
      if (U) {
        if ($ < 0)
          return ke;
        if ($ >= ue)
          return S;
      } else {
        if ($ <= -he)
          return E;
        if ($ + 1 >= he)
          return P;
      }
      return $ < 0 ? H(-$, U).neg() : Z($ % j | 0, $ / j | 0, U);
    }
    p.fromNumber = H;
    function Z($, U, Y) {
      return new p($, U, Y);
    }
    p.fromBits = Z;
    var ee = Math.pow;
    function X($, U, Y) {
      if ($.length === 0)
        throw Error("empty string");
      if (typeof U == "number" ? (Y = U, U = !1) : U = !!U, $ === "NaN" || $ === "Infinity" || $ === "+Infinity" || $ === "-Infinity")
        return U ? ke : be;
      if (Y = Y || 10, Y < 2 || 36 < Y)
        throw RangeError("radix");
      var B;
      if ((B = $.indexOf("-")) > 0)
        throw Error("interior hyphen");
      if (B === 0)
        return X($.substring(1), U, Y).neg();
      for (var T = H(ee(Y, 8)), L = be, te = 0; te < $.length; te += 8) {
        var me = Math.min(8, $.length - te), Ce = parseInt($.substring(te, te + me), Y);
        if (me < 8) {
          var De = H(ee(Y, me));
          L = L.mul(De).add(H(Ce));
        } else
          L = L.mul(T), L = L.add(H(Ce));
      }
      return L.unsigned = U, L;
    }
    p.fromString = X;
    function ne($, U) {
      return typeof $ == "number" ? H($, U) : typeof $ == "string" ? X($, U) : Z($.low, $.high, typeof U == "boolean" ? U : $.unsigned);
    }
    p.fromValue = ne;
    var Q = 65536, ae = 1 << 24, j = Q * Q, ue = j * j, he = ue / 2, fe = F(ae), be = F(0);
    p.ZERO = be;
    var ke = F(0, !0);
    p.UZERO = ke;
    var Te = F(1);
    p.ONE = Te;
    var q = F(1, !0);
    p.UONE = q;
    var z = F(-1);
    p.NEG_ONE = z;
    var P = Z(-1, 2147483647, !1);
    p.MAX_VALUE = P;
    var S = Z(-1, -1, !0);
    p.MAX_UNSIGNED_VALUE = S;
    var E = Z(0, -2147483648, !1);
    p.MIN_VALUE = E;
    var I = p.prototype;
    I.toInt = function() {
      return this.unsigned ? this.low >>> 0 : this.low;
    }, I.toNumber = function() {
      return this.unsigned ? (this.high >>> 0) * j + (this.low >>> 0) : this.high * j + (this.low >>> 0);
    }, I.toString = function(U) {
      if (U = U || 10, U < 2 || 36 < U)
        throw RangeError("radix");
      if (this.isZero())
        return "0";
      if (this.isNegative())
        if (this.eq(E)) {
          var Y = H(U), B = this.div(Y), T = B.mul(Y).sub(this);
          return B.toString(U) + T.toInt().toString(U);
        } else
          return "-" + this.neg().toString(U);
      for (var L = H(ee(U, 6), this.unsigned), te = this, me = ""; ; ) {
        var Ce = te.div(L), De = te.sub(Ce.mul(L)).toInt() >>> 0, ye = De.toString(U);
        if (te = Ce, te.isZero())
          return ye + me;
        for (; ye.length < 6; )
          ye = "0" + ye;
        me = "" + ye + me;
      }
    }, I.getHighBits = function() {
      return this.high;
    }, I.getHighBitsUnsigned = function() {
      return this.high >>> 0;
    }, I.getLowBits = function() {
      return this.low;
    }, I.getLowBitsUnsigned = function() {
      return this.low >>> 0;
    }, I.getNumBitsAbs = function() {
      if (this.isNegative())
        return this.eq(E) ? 64 : this.neg().getNumBitsAbs();
      for (var U = this.high != 0 ? this.high : this.low, Y = 31; Y > 0 && !(U & 1 << Y); Y--)
        ;
      return this.high != 0 ? Y + 33 : Y + 1;
    }, I.isZero = function() {
      return this.high === 0 && this.low === 0;
    }, I.eqz = I.isZero, I.isNegative = function() {
      return !this.unsigned && this.high < 0;
    }, I.isPositive = function() {
      return this.unsigned || this.high >= 0;
    }, I.isOdd = function() {
      return (this.low & 1) === 1;
    }, I.isEven = function() {
      return (this.low & 1) === 0;
    }, I.equals = function(U) {
      return _(U) || (U = ne(U)), this.unsigned !== U.unsigned && this.high >>> 31 === 1 && U.high >>> 31 === 1 ? !1 : this.high === U.high && this.low === U.low;
    }, I.eq = I.equals, I.notEquals = function(U) {
      return !this.eq(
        /* validates */
        U
      );
    }, I.neq = I.notEquals, I.ne = I.notEquals, I.lessThan = function(U) {
      return this.comp(
        /* validates */
        U
      ) < 0;
    }, I.lt = I.lessThan, I.lessThanOrEqual = function(U) {
      return this.comp(
        /* validates */
        U
      ) <= 0;
    }, I.lte = I.lessThanOrEqual, I.le = I.lessThanOrEqual, I.greaterThan = function(U) {
      return this.comp(
        /* validates */
        U
      ) > 0;
    }, I.gt = I.greaterThan, I.greaterThanOrEqual = function(U) {
      return this.comp(
        /* validates */
        U
      ) >= 0;
    }, I.gte = I.greaterThanOrEqual, I.ge = I.greaterThanOrEqual, I.compare = function(U) {
      if (_(U) || (U = ne(U)), this.eq(U))
        return 0;
      var Y = this.isNegative(), B = U.isNegative();
      return Y && !B ? -1 : !Y && B ? 1 : this.unsigned ? U.high >>> 0 > this.high >>> 0 || U.high === this.high && U.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(U).isNegative() ? -1 : 1;
    }, I.comp = I.compare, I.negate = function() {
      return !this.unsigned && this.eq(E) ? E : this.not().add(Te);
    }, I.neg = I.negate, I.add = function(U) {
      _(U) || (U = ne(U));
      var Y = this.high >>> 16, B = this.high & 65535, T = this.low >>> 16, L = this.low & 65535, te = U.high >>> 16, me = U.high & 65535, Ce = U.low >>> 16, De = U.low & 65535, ye = 0, pe = 0, Me = 0, Ne = 0;
      return Ne += L + De, Me += Ne >>> 16, Ne &= 65535, Me += T + Ce, pe += Me >>> 16, Me &= 65535, pe += B + me, ye += pe >>> 16, pe &= 65535, ye += Y + te, ye &= 65535, Z(Me << 16 | Ne, ye << 16 | pe, this.unsigned);
    }, I.subtract = function(U) {
      return _(U) || (U = ne(U)), this.add(U.neg());
    }, I.sub = I.subtract, I.multiply = function(U) {
      if (this.isZero())
        return this;
      if (_(U) || (U = ne(U)), v) {
        var Y = v.mul(this.low, this.high, U.low, U.high);
        return Z(Y, v.get_high(), this.unsigned);
      }
      if (U.isZero())
        return this.unsigned ? ke : be;
      if (this.eq(E))
        return U.isOdd() ? E : be;
      if (U.eq(E))
        return this.isOdd() ? E : be;
      if (this.isNegative())
        return U.isNegative() ? this.neg().mul(U.neg()) : this.neg().mul(U).neg();
      if (U.isNegative())
        return this.mul(U.neg()).neg();
      if (this.lt(fe) && U.lt(fe))
        return H(this.toNumber() * U.toNumber(), this.unsigned);
      var B = this.high >>> 16, T = this.high & 65535, L = this.low >>> 16, te = this.low & 65535, me = U.high >>> 16, Ce = U.high & 65535, De = U.low >>> 16, ye = U.low & 65535, pe = 0, Me = 0, Ne = 0, Ue = 0;
      return Ue += te * ye, Ne += Ue >>> 16, Ue &= 65535, Ne += L * ye, Me += Ne >>> 16, Ne &= 65535, Ne += te * De, Me += Ne >>> 16, Ne &= 65535, Me += T * ye, pe += Me >>> 16, Me &= 65535, Me += L * De, pe += Me >>> 16, Me &= 65535, Me += te * Ce, pe += Me >>> 16, Me &= 65535, pe += B * ye + T * De + L * Ce + te * me, pe &= 65535, Z(Ne << 16 | Ue, pe << 16 | Me, this.unsigned);
    }, I.mul = I.multiply, I.divide = function(U) {
      if (_(U) || (U = ne(U)), U.isZero())
        throw Error("division by zero");
      if (v) {
        if (!this.unsigned && this.high === -2147483648 && U.low === -1 && U.high === -1)
          return this;
        var Y = (this.unsigned ? v.div_u : v.div_s)(this.low, this.high, U.low, U.high);
        return Z(Y, v.get_high(), this.unsigned);
      }
      if (this.isZero())
        return this.unsigned ? ke : be;
      var B, T, L;
      if (this.unsigned) {
        if (U.unsigned || (U = U.toUnsigned()), U.gt(this))
          return ke;
        if (U.gt(this.shru(1)))
          return q;
        L = ke;
      } else {
        if (this.eq(E)) {
          if (U.eq(Te) || U.eq(z))
            return E;
          if (U.eq(E))
            return Te;
          var te = this.shr(1);
          return B = te.div(U).shl(1), B.eq(be) ? U.isNegative() ? Te : z : (T = this.sub(U.mul(B)), L = B.add(T.div(U)), L);
        } else if (U.eq(E))
          return this.unsigned ? ke : be;
        if (this.isNegative())
          return U.isNegative() ? this.neg().div(U.neg()) : this.neg().div(U).neg();
        if (U.isNegative())
          return this.div(U.neg()).neg();
        L = be;
      }
      for (T = this; T.gte(U); ) {
        B = Math.max(1, Math.floor(T.toNumber() / U.toNumber()));
        for (var me = Math.ceil(Math.log(B) / Math.LN2), Ce = me <= 48 ? 1 : ee(2, me - 48), De = H(B), ye = De.mul(U); ye.isNegative() || ye.gt(T); )
          B -= Ce, De = H(B, this.unsigned), ye = De.mul(U);
        De.isZero() && (De = Te), L = L.add(De), T = T.sub(ye);
      }
      return L;
    }, I.div = I.divide, I.modulo = function(U) {
      if (_(U) || (U = ne(U)), v) {
        var Y = (this.unsigned ? v.rem_u : v.rem_s)(this.low, this.high, U.low, U.high);
        return Z(Y, v.get_high(), this.unsigned);
      }
      return this.sub(this.div(U).mul(U));
    }, I.mod = I.modulo, I.rem = I.modulo, I.not = function() {
      return Z(~this.low, ~this.high, this.unsigned);
    }, I.countLeadingZeros = function() {
      return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
    }, I.clz = I.countLeadingZeros, I.countTrailingZeros = function() {
      return this.low ? k(this.low) : k(this.high) + 32;
    }, I.ctz = I.countTrailingZeros, I.and = function(U) {
      return _(U) || (U = ne(U)), Z(this.low & U.low, this.high & U.high, this.unsigned);
    }, I.or = function(U) {
      return _(U) || (U = ne(U)), Z(this.low | U.low, this.high | U.high, this.unsigned);
    }, I.xor = function(U) {
      return _(U) || (U = ne(U)), Z(this.low ^ U.low, this.high ^ U.high, this.unsigned);
    }, I.shiftLeft = function(U) {
      return _(U) && (U = U.toInt()), (U &= 63) === 0 ? this : U < 32 ? Z(this.low << U, this.high << U | this.low >>> 32 - U, this.unsigned) : Z(0, this.low << U - 32, this.unsigned);
    }, I.shl = I.shiftLeft, I.shiftRight = function(U) {
      return _(U) && (U = U.toInt()), (U &= 63) === 0 ? this : U < 32 ? Z(this.low >>> U | this.high << 32 - U, this.high >> U, this.unsigned) : Z(this.high >> U - 32, this.high >= 0 ? 0 : -1, this.unsigned);
    }, I.shr = I.shiftRight, I.shiftRightUnsigned = function(U) {
      return _(U) && (U = U.toInt()), (U &= 63) === 0 ? this : U < 32 ? Z(this.low >>> U | this.high << 32 - U, this.high >>> U, this.unsigned) : U === 32 ? Z(this.high, 0, this.unsigned) : Z(this.high >>> U - 32, 0, this.unsigned);
    }, I.shru = I.shiftRightUnsigned, I.shr_u = I.shiftRightUnsigned, I.rotateLeft = function(U) {
      var Y;
      return _(U) && (U = U.toInt()), (U &= 63) === 0 ? this : U === 32 ? Z(this.high, this.low, this.unsigned) : U < 32 ? (Y = 32 - U, Z(this.low << U | this.high >>> Y, this.high << U | this.low >>> Y, this.unsigned)) : (U -= 32, Y = 32 - U, Z(this.high << U | this.low >>> Y, this.low << U | this.high >>> Y, this.unsigned));
    }, I.rotl = I.rotateLeft, I.rotateRight = function(U) {
      var Y;
      return _(U) && (U = U.toInt()), (U &= 63) === 0 ? this : U === 32 ? Z(this.high, this.low, this.unsigned) : U < 32 ? (Y = 32 - U, Z(this.high << Y | this.low >>> U, this.low << Y | this.high >>> U, this.unsigned)) : (U -= 32, Y = 32 - U, Z(this.low << Y | this.high >>> U, this.high << Y | this.low >>> U, this.unsigned));
    }, I.rotr = I.rotateRight, I.toSigned = function() {
      return this.unsigned ? Z(this.low, this.high, !1) : this;
    }, I.toUnsigned = function() {
      return this.unsigned ? this : Z(this.low, this.high, !0);
    }, I.toBytes = function(U) {
      return U ? this.toBytesLE() : this.toBytesBE();
    }, I.toBytesLE = function() {
      var U = this.high, Y = this.low;
      return [Y & 255, Y >>> 8 & 255, Y >>> 16 & 255, Y >>> 24, U & 255, U >>> 8 & 255, U >>> 16 & 255, U >>> 24];
    }, I.toBytesBE = function() {
      var U = this.high, Y = this.low;
      return [U >>> 24, U >>> 16 & 255, U >>> 8 & 255, U & 255, Y >>> 24, Y >>> 16 & 255, Y >>> 8 & 255, Y & 255];
    }, p.fromBytes = function(U, Y, B) {
      return B ? p.fromBytesLE(U, Y) : p.fromBytesBE(U, Y);
    }, p.fromBytesLE = function(U, Y) {
      return new p(U[0] | U[1] << 8 | U[2] << 16 | U[3] << 24, U[4] | U[5] << 8 | U[6] << 16 | U[7] << 24, Y);
    }, p.fromBytesBE = function(U, Y) {
      return new p(U[4] << 24 | U[5] << 16 | U[6] << 8 | U[7], U[0] << 24 | U[1] << 16 | U[2] << 8 | U[3], Y);
    };
    var M = p;
    return l.default = M, "default" in l ? l.default : l;
  }({});
  a.exports = c;
})(umd);
var umdExports = umd.exports, indexMinimal = {}, minimal$1 = {}, aspromise = asPromise;
function asPromise(a, u) {
  for (var c = new Array(arguments.length - 1), l = 0, v = 2, p = !0; v < arguments.length; )
    c[l++] = arguments[v++];
  return new Promise(function(k, O) {
    c[l] = function(F) {
      if (p)
        if (p = !1, F)
          O(F);
        else {
          for (var H = new Array(arguments.length - 1), Z = 0; Z < H.length; )
            H[Z++] = arguments[Z];
          k.apply(null, H);
        }
    };
    try {
      a.apply(u || null, c);
    } catch (D) {
      p && (p = !1, O(D));
    }
  });
}
var base64$1 = {};
(function(a) {
  var u = a;
  u.length = function(k) {
    var O = k.length;
    if (!O)
      return 0;
    for (var D = 0; --O % 4 > 1 && k.charAt(O) === "="; )
      ++D;
    return Math.ceil(k.length * 3) / 4 - D;
  };
  for (var c = new Array(64), l = new Array(123), v = 0; v < 64; )
    l[c[v] = v < 26 ? v + 65 : v < 52 ? v + 71 : v < 62 ? v - 4 : v - 59 | 43] = v++;
  u.encode = function(k, O, D) {
    for (var F = null, H = [], Z = 0, ee = 0, X; O < D; ) {
      var ne = k[O++];
      switch (ee) {
        case 0:
          H[Z++] = c[ne >> 2], X = (ne & 3) << 4, ee = 1;
          break;
        case 1:
          H[Z++] = c[X | ne >> 4], X = (ne & 15) << 2, ee = 2;
          break;
        case 2:
          H[Z++] = c[X | ne >> 6], H[Z++] = c[ne & 63], ee = 0;
          break;
      }
      Z > 8191 && ((F || (F = [])).push(String.fromCharCode.apply(String, H)), Z = 0);
    }
    return ee && (H[Z++] = c[X], H[Z++] = 61, ee === 1 && (H[Z++] = 61)), F ? (Z && F.push(String.fromCharCode.apply(String, H.slice(0, Z))), F.join("")) : String.fromCharCode.apply(String, H.slice(0, Z));
  };
  var p = "invalid encoding";
  u.decode = function(k, O, D) {
    for (var F = D, H = 0, Z, ee = 0; ee < k.length; ) {
      var X = k.charCodeAt(ee++);
      if (X === 61 && H > 1)
        break;
      if ((X = l[X]) === void 0)
        throw Error(p);
      switch (H) {
        case 0:
          Z = X, H = 1;
          break;
        case 1:
          O[D++] = Z << 2 | (X & 48) >> 4, Z = X, H = 2;
          break;
        case 2:
          O[D++] = (Z & 15) << 4 | (X & 60) >> 2, Z = X, H = 3;
          break;
        case 3:
          O[D++] = (Z & 3) << 6 | X, H = 0;
          break;
      }
    }
    if (H === 1)
      throw Error(p);
    return D - F;
  }, u.test = function(k) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(k);
  };
})(base64$1);
var eventemitter = EventEmitter$2;
function EventEmitter$2() {
  this._listeners = {};
}
EventEmitter$2.prototype.on = function(u, c, l) {
  return (this._listeners[u] || (this._listeners[u] = [])).push({
    fn: c,
    ctx: l || this
  }), this;
};
EventEmitter$2.prototype.off = function(u, c) {
  if (u === void 0)
    this._listeners = {};
  else if (c === void 0)
    this._listeners[u] = [];
  else
    for (var l = this._listeners[u], v = 0; v < l.length; )
      l[v].fn === c ? l.splice(v, 1) : ++v;
  return this;
};
EventEmitter$2.prototype.emit = function(u) {
  var c = this._listeners[u];
  if (c) {
    for (var l = [], v = 1; v < arguments.length; )
      l.push(arguments[v++]);
    for (v = 0; v < c.length; )
      c[v].fn.apply(c[v++].ctx, l);
  }
  return this;
};
var float = factory(factory);
function factory(a) {
  return typeof Float32Array < "u" ? function() {
    var u = new Float32Array([-0]), c = new Uint8Array(u.buffer), l = c[3] === 128;
    function v(O, D, F) {
      u[0] = O, D[F] = c[0], D[F + 1] = c[1], D[F + 2] = c[2], D[F + 3] = c[3];
    }
    function p(O, D, F) {
      u[0] = O, D[F] = c[3], D[F + 1] = c[2], D[F + 2] = c[1], D[F + 3] = c[0];
    }
    a.writeFloatLE = l ? v : p, a.writeFloatBE = l ? p : v;
    function _(O, D) {
      return c[0] = O[D], c[1] = O[D + 1], c[2] = O[D + 2], c[3] = O[D + 3], u[0];
    }
    function k(O, D) {
      return c[3] = O[D], c[2] = O[D + 1], c[1] = O[D + 2], c[0] = O[D + 3], u[0];
    }
    a.readFloatLE = l ? _ : k, a.readFloatBE = l ? k : _;
  }() : function() {
    function u(l, v, p, _) {
      var k = v < 0 ? 1 : 0;
      if (k && (v = -v), v === 0)
        l(1 / v > 0 ? (
          /* positive */
          0
        ) : (
          /* negative 0 */
          2147483648
        ), p, _);
      else if (isNaN(v))
        l(2143289344, p, _);
      else if (v > 34028234663852886e22)
        l((k << 31 | 2139095040) >>> 0, p, _);
      else if (v < 11754943508222875e-54)
        l((k << 31 | Math.round(v / 1401298464324817e-60)) >>> 0, p, _);
      else {
        var O = Math.floor(Math.log(v) / Math.LN2), D = Math.round(v * Math.pow(2, -O) * 8388608) & 8388607;
        l((k << 31 | O + 127 << 23 | D) >>> 0, p, _);
      }
    }
    a.writeFloatLE = u.bind(null, writeUintLE), a.writeFloatBE = u.bind(null, writeUintBE);
    function c(l, v, p) {
      var _ = l(v, p), k = (_ >> 31) * 2 + 1, O = _ >>> 23 & 255, D = _ & 8388607;
      return O === 255 ? D ? NaN : k * (1 / 0) : O === 0 ? k * 1401298464324817e-60 * D : k * Math.pow(2, O - 150) * (D + 8388608);
    }
    a.readFloatLE = c.bind(null, readUintLE), a.readFloatBE = c.bind(null, readUintBE);
  }(), typeof Float64Array < "u" ? function() {
    var u = new Float64Array([-0]), c = new Uint8Array(u.buffer), l = c[7] === 128;
    function v(O, D, F) {
      u[0] = O, D[F] = c[0], D[F + 1] = c[1], D[F + 2] = c[2], D[F + 3] = c[3], D[F + 4] = c[4], D[F + 5] = c[5], D[F + 6] = c[6], D[F + 7] = c[7];
    }
    function p(O, D, F) {
      u[0] = O, D[F] = c[7], D[F + 1] = c[6], D[F + 2] = c[5], D[F + 3] = c[4], D[F + 4] = c[3], D[F + 5] = c[2], D[F + 6] = c[1], D[F + 7] = c[0];
    }
    a.writeDoubleLE = l ? v : p, a.writeDoubleBE = l ? p : v;
    function _(O, D) {
      return c[0] = O[D], c[1] = O[D + 1], c[2] = O[D + 2], c[3] = O[D + 3], c[4] = O[D + 4], c[5] = O[D + 5], c[6] = O[D + 6], c[7] = O[D + 7], u[0];
    }
    function k(O, D) {
      return c[7] = O[D], c[6] = O[D + 1], c[5] = O[D + 2], c[4] = O[D + 3], c[3] = O[D + 4], c[2] = O[D + 5], c[1] = O[D + 6], c[0] = O[D + 7], u[0];
    }
    a.readDoubleLE = l ? _ : k, a.readDoubleBE = l ? k : _;
  }() : function() {
    function u(l, v, p, _, k, O) {
      var D = _ < 0 ? 1 : 0;
      if (D && (_ = -_), _ === 0)
        l(0, k, O + v), l(1 / _ > 0 ? (
          /* positive */
          0
        ) : (
          /* negative 0 */
          2147483648
        ), k, O + p);
      else if (isNaN(_))
        l(0, k, O + v), l(2146959360, k, O + p);
      else if (_ > 17976931348623157e292)
        l(0, k, O + v), l((D << 31 | 2146435072) >>> 0, k, O + p);
      else {
        var F;
        if (_ < 22250738585072014e-324)
          F = _ / 5e-324, l(F >>> 0, k, O + v), l((D << 31 | F / 4294967296) >>> 0, k, O + p);
        else {
          var H = Math.floor(Math.log(_) / Math.LN2);
          H === 1024 && (H = 1023), F = _ * Math.pow(2, -H), l(F * 4503599627370496 >>> 0, k, O + v), l((D << 31 | H + 1023 << 20 | F * 1048576 & 1048575) >>> 0, k, O + p);
        }
      }
    }
    a.writeDoubleLE = u.bind(null, writeUintLE, 0, 4), a.writeDoubleBE = u.bind(null, writeUintBE, 4, 0);
    function c(l, v, p, _, k) {
      var O = l(_, k + v), D = l(_, k + p), F = (D >> 31) * 2 + 1, H = D >>> 20 & 2047, Z = 4294967296 * (D & 1048575) + O;
      return H === 2047 ? Z ? NaN : F * (1 / 0) : H === 0 ? F * 5e-324 * Z : F * Math.pow(2, H - 1075) * (Z + 4503599627370496);
    }
    a.readDoubleLE = c.bind(null, readUintLE, 0, 4), a.readDoubleBE = c.bind(null, readUintBE, 4, 0);
  }(), a;
}
function writeUintLE(a, u, c) {
  u[c] = a & 255, u[c + 1] = a >>> 8 & 255, u[c + 2] = a >>> 16 & 255, u[c + 3] = a >>> 24;
}
function writeUintBE(a, u, c) {
  u[c] = a >>> 24, u[c + 1] = a >>> 16 & 255, u[c + 2] = a >>> 8 & 255, u[c + 3] = a & 255;
}
function readUintLE(a, u) {
  return (a[u] | a[u + 1] << 8 | a[u + 2] << 16 | a[u + 3] << 24) >>> 0;
}
function readUintBE(a, u) {
  return (a[u] << 24 | a[u + 1] << 16 | a[u + 2] << 8 | a[u + 3]) >>> 0;
}
var inquire_1 = inquire;
function inquire(moduleName) {
  try {
    var mod = eval("quire".replace(/^/, "re"))(moduleName);
    if (mod && (mod.length || Object.keys(mod).length))
      return mod;
  } catch (a) {
  }
  return null;
}
var utf8$2 = {};
(function(a) {
  var u = a;
  u.length = function(l) {
    for (var v = 0, p = 0, _ = 0; _ < l.length; ++_)
      p = l.charCodeAt(_), p < 128 ? v += 1 : p < 2048 ? v += 2 : (p & 64512) === 55296 && (l.charCodeAt(_ + 1) & 64512) === 56320 ? (++_, v += 4) : v += 3;
    return v;
  }, u.read = function(l, v, p) {
    var _ = p - v;
    if (_ < 1)
      return "";
    for (var k = null, O = [], D = 0, F; v < p; )
      F = l[v++], F < 128 ? O[D++] = F : F > 191 && F < 224 ? O[D++] = (F & 31) << 6 | l[v++] & 63 : F > 239 && F < 365 ? (F = ((F & 7) << 18 | (l[v++] & 63) << 12 | (l[v++] & 63) << 6 | l[v++] & 63) - 65536, O[D++] = 55296 + (F >> 10), O[D++] = 56320 + (F & 1023)) : O[D++] = (F & 15) << 12 | (l[v++] & 63) << 6 | l[v++] & 63, D > 8191 && ((k || (k = [])).push(String.fromCharCode.apply(String, O)), D = 0);
    return k ? (D && k.push(String.fromCharCode.apply(String, O.slice(0, D))), k.join("")) : String.fromCharCode.apply(String, O.slice(0, D));
  }, u.write = function(l, v, p) {
    for (var _ = p, k, O, D = 0; D < l.length; ++D)
      k = l.charCodeAt(D), k < 128 ? v[p++] = k : k < 2048 ? (v[p++] = k >> 6 | 192, v[p++] = k & 63 | 128) : (k & 64512) === 55296 && ((O = l.charCodeAt(D + 1)) & 64512) === 56320 ? (k = 65536 + ((k & 1023) << 10) + (O & 1023), ++D, v[p++] = k >> 18 | 240, v[p++] = k >> 12 & 63 | 128, v[p++] = k >> 6 & 63 | 128, v[p++] = k & 63 | 128) : (v[p++] = k >> 12 | 224, v[p++] = k >> 6 & 63 | 128, v[p++] = k & 63 | 128);
    return p - _;
  };
})(utf8$2);
var pool_1 = pool;
function pool(a, u, c) {
  var l = c || 8192, v = l >>> 1, p = null, _ = l;
  return function(O) {
    if (O < 1 || O > v)
      return a(O);
    _ + O > l && (p = a(l), _ = 0);
    var D = u.call(p, _, _ += O);
    return _ & 7 && (_ = (_ | 7) + 1), D;
  };
}
var longbits, hasRequiredLongbits;
function requireLongbits() {
  if (hasRequiredLongbits)
    return longbits;
  hasRequiredLongbits = 1, longbits = u;
  var a = requireMinimal();
  function u(p, _) {
    this.lo = p >>> 0, this.hi = _ >>> 0;
  }
  var c = u.zero = new u(0, 0);
  c.toNumber = function() {
    return 0;
  }, c.zzEncode = c.zzDecode = function() {
    return this;
  }, c.length = function() {
    return 1;
  };
  var l = u.zeroHash = "\0\0\0\0\0\0\0\0";
  u.fromNumber = function(_) {
    if (_ === 0)
      return c;
    var k = _ < 0;
    k && (_ = -_);
    var O = _ >>> 0, D = (_ - O) / 4294967296 >>> 0;
    return k && (D = ~D >>> 0, O = ~O >>> 0, ++O > 4294967295 && (O = 0, ++D > 4294967295 && (D = 0))), new u(O, D);
  }, u.from = function(_) {
    if (typeof _ == "number")
      return u.fromNumber(_);
    if (a.isString(_))
      if (a.Long)
        _ = a.Long.fromString(_);
      else
        return u.fromNumber(parseInt(_, 10));
    return _.low || _.high ? new u(_.low >>> 0, _.high >>> 0) : c;
  }, u.prototype.toNumber = function(_) {
    if (!_ && this.hi >>> 31) {
      var k = ~this.lo + 1 >>> 0, O = ~this.hi >>> 0;
      return k || (O = O + 1 >>> 0), -(k + O * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
  }, u.prototype.toLong = function(_) {
    return a.Long ? new a.Long(this.lo | 0, this.hi | 0, !!_) : { low: this.lo | 0, high: this.hi | 0, unsigned: !!_ };
  };
  var v = String.prototype.charCodeAt;
  return u.fromHash = function(_) {
    return _ === l ? c : new u(
      (v.call(_, 0) | v.call(_, 1) << 8 | v.call(_, 2) << 16 | v.call(_, 3) << 24) >>> 0,
      (v.call(_, 4) | v.call(_, 5) << 8 | v.call(_, 6) << 16 | v.call(_, 7) << 24) >>> 0
    );
  }, u.prototype.toHash = function() {
    return String.fromCharCode(
      this.lo & 255,
      this.lo >>> 8 & 255,
      this.lo >>> 16 & 255,
      this.lo >>> 24,
      this.hi & 255,
      this.hi >>> 8 & 255,
      this.hi >>> 16 & 255,
      this.hi >>> 24
    );
  }, u.prototype.zzEncode = function() {
    var _ = this.hi >> 31;
    return this.hi = ((this.hi << 1 | this.lo >>> 31) ^ _) >>> 0, this.lo = (this.lo << 1 ^ _) >>> 0, this;
  }, u.prototype.zzDecode = function() {
    var _ = -(this.lo & 1);
    return this.lo = ((this.lo >>> 1 | this.hi << 31) ^ _) >>> 0, this.hi = (this.hi >>> 1 ^ _) >>> 0, this;
  }, u.prototype.length = function() {
    var _ = this.lo, k = (this.lo >>> 28 | this.hi << 4) >>> 0, O = this.hi >>> 24;
    return O === 0 ? k === 0 ? _ < 16384 ? _ < 128 ? 1 : 2 : _ < 2097152 ? 3 : 4 : k < 16384 ? k < 128 ? 5 : 6 : k < 2097152 ? 7 : 8 : O < 128 ? 9 : 10;
  }, longbits;
}
var hasRequiredMinimal;
function requireMinimal() {
  return hasRequiredMinimal || (hasRequiredMinimal = 1, function(a) {
    var u = a;
    u.asPromise = aspromise, u.base64 = base64$1, u.EventEmitter = eventemitter, u.float = float, u.inquire = inquire_1, u.utf8 = utf8$2, u.pool = pool_1, u.LongBits = requireLongbits(), u.isNode = !!(typeof commonjsGlobal$1 < "u" && commonjsGlobal$1 && commonjsGlobal$1.process && commonjsGlobal$1.process.versions && commonjsGlobal$1.process.versions.node), u.global = u.isNode && commonjsGlobal$1 || typeof window < "u" && window || typeof self < "u" && self || commonjsGlobal$1, u.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    ), u.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    ), u.isInteger = Number.isInteger || /* istanbul ignore next */
    function(p) {
      return typeof p == "number" && isFinite(p) && Math.floor(p) === p;
    }, u.isString = function(p) {
      return typeof p == "string" || p instanceof String;
    }, u.isObject = function(p) {
      return p && typeof p == "object";
    }, u.isset = /**
     * Checks if a property on a message is considered to be present.
     * @param {Object} obj Plain object or message instance
     * @param {string} prop Property name
     * @returns {boolean} `true` if considered to be present, otherwise `false`
     */
    u.isSet = function(p, _) {
      var k = p[_];
      return k != null && p.hasOwnProperty(_) ? typeof k != "object" || (Array.isArray(k) ? k.length : Object.keys(k).length) > 0 : !1;
    }, u.Buffer = function() {
      try {
        var v = u.inquire("buffer").Buffer;
        return v.prototype.utf8Write ? v : (
          /* istanbul ignore next */
          null
        );
      } catch {
        return null;
      }
    }(), u._Buffer_from = null, u._Buffer_allocUnsafe = null, u.newBuffer = function(p) {
      return typeof p == "number" ? u.Buffer ? u._Buffer_allocUnsafe(p) : new u.Array(p) : u.Buffer ? u._Buffer_from(p) : typeof Uint8Array > "u" ? p : new Uint8Array(p);
    }, u.Array = typeof Uint8Array < "u" ? Uint8Array : Array, u.Long = /* istanbul ignore next */
    u.global.dcodeIO && /* istanbul ignore next */
    u.global.dcodeIO.Long || /* istanbul ignore next */
    u.global.Long || u.inquire("long"), u.key2Re = /^true|false|0|1$/, u.key32Re = /^-?(?:0|[1-9][0-9]*)$/, u.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/, u.longToHash = function(p) {
      return p ? u.LongBits.from(p).toHash() : u.LongBits.zeroHash;
    }, u.longFromHash = function(p, _) {
      var k = u.LongBits.fromHash(p);
      return u.Long ? u.Long.fromBits(k.lo, k.hi, _) : k.toNumber(!!_);
    };
    function c(v, p, _) {
      for (var k = Object.keys(p), O = 0; O < k.length; ++O)
        (v[k[O]] === void 0 || !_) && (v[k[O]] = p[k[O]]);
      return v;
    }
    u.merge = c, u.lcFirst = function(p) {
      return p.charAt(0).toLowerCase() + p.substring(1);
    };
    function l(v) {
      function p(_, k) {
        if (!(this instanceof p))
          return new p(_, k);
        Object.defineProperty(this, "message", { get: function() {
          return _;
        } }), Error.captureStackTrace ? Error.captureStackTrace(this, p) : Object.defineProperty(this, "stack", { value: new Error().stack || "" }), k && c(this, k);
      }
      return (p.prototype = Object.create(Error.prototype)).constructor = p, Object.defineProperty(p.prototype, "name", { get: function() {
        return v;
      } }), p.prototype.toString = function() {
        return this.name + ": " + this.message;
      }, p;
    }
    u.newError = l, u.ProtocolError = l("ProtocolError"), u.oneOfGetter = function(p) {
      for (var _ = {}, k = 0; k < p.length; ++k)
        _[p[k]] = 1;
      return function() {
        for (var O = Object.keys(this), D = O.length - 1; D > -1; --D)
          if (_[O[D]] === 1 && this[O[D]] !== void 0 && this[O[D]] !== null)
            return O[D];
      };
    }, u.oneOfSetter = function(p) {
      return function(_) {
        for (var k = 0; k < p.length; ++k)
          p[k] !== _ && delete this[p[k]];
      };
    }, u.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: !0
    }, u._configure = function() {
      var v = u.Buffer;
      if (!v) {
        u._Buffer_from = u._Buffer_allocUnsafe = null;
        return;
      }
      u._Buffer_from = v.from !== Uint8Array.from && v.from || /* istanbul ignore next */
      function(_, k) {
        return new v(_, k);
      }, u._Buffer_allocUnsafe = v.allocUnsafe || /* istanbul ignore next */
      function(_) {
        return new v(_);
      };
    };
  }(minimal$1)), minimal$1;
}
var writer$2 = Writer$1, util$9 = requireMinimal(), BufferWriter$1, LongBits$1 = util$9.LongBits, base64 = util$9.base64, utf8$1 = util$9.utf8;
function Op(a, u, c) {
  this.fn = a, this.len = u, this.next = void 0, this.val = c;
}
function noop$7() {
}
function State(a) {
  this.head = a.head, this.tail = a.tail, this.len = a.len, this.next = a.states;
}
function Writer$1() {
  this.len = 0, this.head = new Op(noop$7, 0, 0), this.tail = this.head, this.states = null;
}
var create$3 = function a() {
  return util$9.Buffer ? function() {
    return (Writer$1.create = function() {
      return new BufferWriter$1();
    })();
  } : function() {
    return new Writer$1();
  };
};
Writer$1.create = create$3();
Writer$1.alloc = function a(u) {
  return new util$9.Array(u);
};
util$9.Array !== Array && (Writer$1.alloc = util$9.pool(Writer$1.alloc, util$9.Array.prototype.subarray));
Writer$1.prototype._push = function a(u, c, l) {
  return this.tail = this.tail.next = new Op(u, c, l), this.len += c, this;
};
function writeByte(a, u, c) {
  u[c] = a & 255;
}
function writeVarint32(a, u, c) {
  for (; a > 127; )
    u[c++] = a & 127 | 128, a >>>= 7;
  u[c] = a;
}
function VarintOp(a, u) {
  this.len = a, this.next = void 0, this.val = u;
}
VarintOp.prototype = Object.create(Op.prototype);
VarintOp.prototype.fn = writeVarint32;
Writer$1.prototype.uint32 = function a(u) {
  return this.len += (this.tail = this.tail.next = new VarintOp(
    (u = u >>> 0) < 128 ? 1 : u < 16384 ? 2 : u < 2097152 ? 3 : u < 268435456 ? 4 : 5,
    u
  )).len, this;
};
Writer$1.prototype.int32 = function a(u) {
  return u < 0 ? this._push(writeVarint64, 10, LongBits$1.fromNumber(u)) : this.uint32(u);
};
Writer$1.prototype.sint32 = function a(u) {
  return this.uint32((u << 1 ^ u >> 31) >>> 0);
};
function writeVarint64(a, u, c) {
  for (; a.hi; )
    u[c++] = a.lo & 127 | 128, a.lo = (a.lo >>> 7 | a.hi << 25) >>> 0, a.hi >>>= 7;
  for (; a.lo > 127; )
    u[c++] = a.lo & 127 | 128, a.lo = a.lo >>> 7;
  u[c++] = a.lo;
}
Writer$1.prototype.uint64 = function a(u) {
  var c = LongBits$1.from(u);
  return this._push(writeVarint64, c.length(), c);
};
Writer$1.prototype.int64 = Writer$1.prototype.uint64;
Writer$1.prototype.sint64 = function a(u) {
  var c = LongBits$1.from(u).zzEncode();
  return this._push(writeVarint64, c.length(), c);
};
Writer$1.prototype.bool = function a(u) {
  return this._push(writeByte, 1, u ? 1 : 0);
};
function writeFixed32(a, u, c) {
  u[c] = a & 255, u[c + 1] = a >>> 8 & 255, u[c + 2] = a >>> 16 & 255, u[c + 3] = a >>> 24;
}
Writer$1.prototype.fixed32 = function a(u) {
  return this._push(writeFixed32, 4, u >>> 0);
};
Writer$1.prototype.sfixed32 = Writer$1.prototype.fixed32;
Writer$1.prototype.fixed64 = function a(u) {
  var c = LongBits$1.from(u);
  return this._push(writeFixed32, 4, c.lo)._push(writeFixed32, 4, c.hi);
};
Writer$1.prototype.sfixed64 = Writer$1.prototype.fixed64;
Writer$1.prototype.float = function a(u) {
  return this._push(util$9.float.writeFloatLE, 4, u);
};
Writer$1.prototype.double = function a(u) {
  return this._push(util$9.float.writeDoubleLE, 8, u);
};
var writeBytes = util$9.Array.prototype.set ? function a(u, c, l) {
  c.set(u, l);
} : function a(u, c, l) {
  for (var v = 0; v < u.length; ++v)
    c[l + v] = u[v];
};
Writer$1.prototype.bytes = function a(u) {
  var c = u.length >>> 0;
  if (!c)
    return this._push(writeByte, 1, 0);
  if (util$9.isString(u)) {
    var l = Writer$1.alloc(c = base64.length(u));
    base64.decode(u, l, 0), u = l;
  }
  return this.uint32(c)._push(writeBytes, c, u);
};
Writer$1.prototype.string = function a(u) {
  var c = utf8$1.length(u);
  return c ? this.uint32(c)._push(utf8$1.write, c, u) : this._push(writeByte, 1, 0);
};
Writer$1.prototype.fork = function a() {
  return this.states = new State(this), this.head = this.tail = new Op(noop$7, 0, 0), this.len = 0, this;
};
Writer$1.prototype.reset = function a() {
  return this.states ? (this.head = this.states.head, this.tail = this.states.tail, this.len = this.states.len, this.states = this.states.next) : (this.head = this.tail = new Op(noop$7, 0, 0), this.len = 0), this;
};
Writer$1.prototype.ldelim = function a() {
  var u = this.head, c = this.tail, l = this.len;
  return this.reset().uint32(l), l && (this.tail.next = u.next, this.tail = c, this.len += l), this;
};
Writer$1.prototype.finish = function a() {
  for (var u = this.head.next, c = this.constructor.alloc(this.len), l = 0; u; )
    u.fn(u.val, c, l), l += u.len, u = u.next;
  return c;
};
Writer$1._configure = function(a) {
  BufferWriter$1 = a, Writer$1.create = create$3(), BufferWriter$1._configure();
};
var writer_buffer = BufferWriter, Writer = writer$2;
(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
var util$8 = requireMinimal();
function BufferWriter() {
  Writer.call(this);
}
BufferWriter._configure = function() {
  BufferWriter.alloc = util$8._Buffer_allocUnsafe, BufferWriter.writeBytesBuffer = util$8.Buffer && util$8.Buffer.prototype instanceof Uint8Array && util$8.Buffer.prototype.set.name === "set" ? function(u, c, l) {
    c.set(u, l);
  } : function(u, c, l) {
    if (u.copy)
      u.copy(c, l, 0, u.length);
    else
      for (var v = 0; v < u.length; )
        c[l++] = u[v++];
  };
};
BufferWriter.prototype.bytes = function a(u) {
  util$8.isString(u) && (u = util$8._Buffer_from(u, "base64"));
  var c = u.length >>> 0;
  return this.uint32(c), c && this._push(BufferWriter.writeBytesBuffer, c, u), this;
};
function writeStringBuffer(a, u, c) {
  a.length < 40 ? util$8.utf8.write(a, u, c) : u.utf8Write ? u.utf8Write(a, c) : u.write(a, c);
}
BufferWriter.prototype.string = function a(u) {
  var c = util$8.Buffer.byteLength(u);
  return this.uint32(c), c && this._push(writeStringBuffer, c, u), this;
};
BufferWriter._configure();
var reader = Reader$1, util$7 = requireMinimal(), BufferReader$1, LongBits = util$7.LongBits, utf8 = util$7.utf8;
function indexOutOfRange(a, u) {
  return RangeError("index out of range: " + a.pos + " + " + (u || 1) + " > " + a.len);
}
function Reader$1(a) {
  this.buf = a, this.pos = 0, this.len = a.length;
}
var create_array = typeof Uint8Array < "u" ? function a(u) {
  if (u instanceof Uint8Array || Array.isArray(u))
    return new Reader$1(u);
  throw Error("illegal buffer");
} : function a(u) {
  if (Array.isArray(u))
    return new Reader$1(u);
  throw Error("illegal buffer");
}, create$2 = function a() {
  return util$7.Buffer ? function(c) {
    return (Reader$1.create = function(v) {
      return util$7.Buffer.isBuffer(v) ? new BufferReader$1(v) : create_array(v);
    })(c);
  } : create_array;
};
Reader$1.create = create$2();
Reader$1.prototype._slice = util$7.Array.prototype.subarray || /* istanbul ignore next */
util$7.Array.prototype.slice;
Reader$1.prototype.uint32 = /* @__PURE__ */ function a() {
  var u = 4294967295;
  return function() {
    if (u = (this.buf[this.pos] & 127) >>> 0, this.buf[this.pos++] < 128 || (u = (u | (this.buf[this.pos] & 127) << 7) >>> 0, this.buf[this.pos++] < 128) || (u = (u | (this.buf[this.pos] & 127) << 14) >>> 0, this.buf[this.pos++] < 128) || (u = (u | (this.buf[this.pos] & 127) << 21) >>> 0, this.buf[this.pos++] < 128) || (u = (u | (this.buf[this.pos] & 15) << 28) >>> 0, this.buf[this.pos++] < 128))
      return u;
    if ((this.pos += 5) > this.len)
      throw this.pos = this.len, indexOutOfRange(this, 10);
    return u;
  };
}();
Reader$1.prototype.int32 = function a() {
  return this.uint32() | 0;
};
Reader$1.prototype.sint32 = function a() {
  var u = this.uint32();
  return u >>> 1 ^ -(u & 1) | 0;
};
function readLongVarint() {
  var a = new LongBits(0, 0), u = 0;
  if (this.len - this.pos > 4) {
    for (; u < 4; ++u)
      if (a.lo = (a.lo | (this.buf[this.pos] & 127) << u * 7) >>> 0, this.buf[this.pos++] < 128)
        return a;
    if (a.lo = (a.lo | (this.buf[this.pos] & 127) << 28) >>> 0, a.hi = (a.hi | (this.buf[this.pos] & 127) >> 4) >>> 0, this.buf[this.pos++] < 128)
      return a;
    u = 0;
  } else {
    for (; u < 3; ++u) {
      if (this.pos >= this.len)
        throw indexOutOfRange(this);
      if (a.lo = (a.lo | (this.buf[this.pos] & 127) << u * 7) >>> 0, this.buf[this.pos++] < 128)
        return a;
    }
    return a.lo = (a.lo | (this.buf[this.pos++] & 127) << u * 7) >>> 0, a;
  }
  if (this.len - this.pos > 4) {
    for (; u < 5; ++u)
      if (a.hi = (a.hi | (this.buf[this.pos] & 127) << u * 7 + 3) >>> 0, this.buf[this.pos++] < 128)
        return a;
  } else
    for (; u < 5; ++u) {
      if (this.pos >= this.len)
        throw indexOutOfRange(this);
      if (a.hi = (a.hi | (this.buf[this.pos] & 127) << u * 7 + 3) >>> 0, this.buf[this.pos++] < 128)
        return a;
    }
  throw Error("invalid varint encoding");
}
Reader$1.prototype.bool = function a() {
  return this.uint32() !== 0;
};
function readFixed32_end(a, u) {
  return (a[u - 4] | a[u - 3] << 8 | a[u - 2] << 16 | a[u - 1] << 24) >>> 0;
}
Reader$1.prototype.fixed32 = function a() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange(this, 4);
  return readFixed32_end(this.buf, this.pos += 4);
};
Reader$1.prototype.sfixed32 = function a() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange(this, 4);
  return readFixed32_end(this.buf, this.pos += 4) | 0;
};
function readFixed64() {
  if (this.pos + 8 > this.len)
    throw indexOutOfRange(this, 8);
  return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}
Reader$1.prototype.float = function a() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange(this, 4);
  var u = util$7.float.readFloatLE(this.buf, this.pos);
  return this.pos += 4, u;
};
Reader$1.prototype.double = function a() {
  if (this.pos + 8 > this.len)
    throw indexOutOfRange(this, 4);
  var u = util$7.float.readDoubleLE(this.buf, this.pos);
  return this.pos += 8, u;
};
Reader$1.prototype.bytes = function a() {
  var u = this.uint32(), c = this.pos, l = this.pos + u;
  if (l > this.len)
    throw indexOutOfRange(this, u);
  return this.pos += u, Array.isArray(this.buf) ? this.buf.slice(c, l) : c === l ? new this.buf.constructor(0) : this._slice.call(this.buf, c, l);
};
Reader$1.prototype.string = function a() {
  var u = this.bytes();
  return utf8.read(u, 0, u.length);
};
Reader$1.prototype.skip = function a(u) {
  if (typeof u == "number") {
    if (this.pos + u > this.len)
      throw indexOutOfRange(this, u);
    this.pos += u;
  } else
    do
      if (this.pos >= this.len)
        throw indexOutOfRange(this);
    while (this.buf[this.pos++] & 128);
  return this;
};
Reader$1.prototype.skipType = function(a) {
  switch (a) {
    case 0:
      this.skip();
      break;
    case 1:
      this.skip(8);
      break;
    case 2:
      this.skip(this.uint32());
      break;
    case 3:
      for (; (a = this.uint32() & 7) !== 4; )
        this.skipType(a);
      break;
    case 5:
      this.skip(4);
      break;
    default:
      throw Error("invalid wire type " + a + " at offset " + this.pos);
  }
  return this;
};
Reader$1._configure = function(a) {
  BufferReader$1 = a, Reader$1.create = create$2(), BufferReader$1._configure();
  var u = util$7.Long ? "toLong" : (
    /* istanbul ignore next */
    "toNumber"
  );
  util$7.merge(Reader$1.prototype, {
    int64: function() {
      return readLongVarint.call(this)[u](!1);
    },
    uint64: function() {
      return readLongVarint.call(this)[u](!0);
    },
    sint64: function() {
      return readLongVarint.call(this).zzDecode()[u](!1);
    },
    fixed64: function() {
      return readFixed64.call(this)[u](!0);
    },
    sfixed64: function() {
      return readFixed64.call(this)[u](!1);
    }
  });
};
var reader_buffer = BufferReader, Reader = reader;
(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
var util$6 = requireMinimal();
function BufferReader(a) {
  Reader.call(this, a);
}
BufferReader._configure = function() {
  util$6.Buffer && (BufferReader.prototype._slice = util$6.Buffer.prototype.slice);
};
BufferReader.prototype.string = function a() {
  var u = this.uint32();
  return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + u, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + u, this.len));
};
BufferReader._configure();
var rpc = {}, service = Service, util$5 = requireMinimal();
(Service.prototype = Object.create(util$5.EventEmitter.prototype)).constructor = Service;
function Service(a, u, c) {
  if (typeof a != "function")
    throw TypeError("rpcImpl must be a function");
  util$5.EventEmitter.call(this), this.rpcImpl = a, this.requestDelimited = !!u, this.responseDelimited = !!c;
}
Service.prototype.rpcCall = function a(u, c, l, v, p) {
  if (!v)
    throw TypeError("request must be specified");
  var _ = this;
  if (!p)
    return util$5.asPromise(a, _, u, c, l, v);
  if (!_.rpcImpl) {
    setTimeout(function() {
      p(Error("already ended"));
    }, 0);
    return;
  }
  try {
    return _.rpcImpl(
      u,
      c[_.requestDelimited ? "encodeDelimited" : "encode"](v).finish(),
      function(O, D) {
        if (O)
          return _.emit("error", O, u), p(O);
        if (D === null) {
          _.end(
            /* endedByRPC */
            !0
          );
          return;
        }
        if (!(D instanceof l))
          try {
            D = l[_.responseDelimited ? "decodeDelimited" : "decode"](D);
          } catch (F) {
            return _.emit("error", F, u), p(F);
          }
        return _.emit("data", D, u), p(null, D);
      }
    );
  } catch (k) {
    _.emit("error", k, u), setTimeout(function() {
      p(k);
    }, 0);
    return;
  }
};
Service.prototype.end = function a(u) {
  return this.rpcImpl && (u || this.rpcImpl(null, null, null), this.rpcImpl = null, this.emit("end").off()), this;
};
(function(a) {
  var u = a;
  u.Service = service;
})(rpc);
var roots = {};
(function(a) {
  var u = a;
  u.build = "minimal", u.Writer = writer$2, u.BufferWriter = writer_buffer, u.Reader = reader, u.BufferReader = reader_buffer, u.util = requireMinimal(), u.rpc = rpc, u.roots = roots, u.configure = c;
  function c() {
    u.util._configure(), u.Writer._configure(u.BufferWriter), u.Reader._configure(u.BufferReader);
  }
  c();
})(indexMinimal);
var minimal = indexMinimal, struct$2 = {};
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(j, ue, he, fe) {
    fe === void 0 && (fe = he), Object.defineProperty(j, fe, { enumerable: !0, get: function() {
      return ue[he];
    } });
  } : function(j, ue, he, fe) {
    fe === void 0 && (fe = he), j[fe] = ue[he];
  }), c = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(j, ue) {
    Object.defineProperty(j, "default", { enumerable: !0, value: ue });
  } : function(j, ue) {
    j.default = ue;
  }), l = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(j) {
    if (j && j.__esModule)
      return j;
    var ue = {};
    if (j != null)
      for (var he in j)
        he !== "default" && Object.hasOwnProperty.call(j, he) && u(ue, j, he);
    return c(ue, j), ue;
  }, v = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(j) {
    return j && j.__esModule ? j : { default: j };
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.ListValue = a.Value = a.Struct_FieldsEntry = a.Struct = a.nullValueToNumber = a.nullValueToJSON = a.nullValueFromJSON = a.NullValue = a.protobufPackage = void 0;
  const p = v(umdExports), _ = l(minimal);
  a.protobufPackage = "google.protobuf";
  var k;
  (function(j) {
    j.NULL_VALUE = "NULL_VALUE";
  })(k = a.NullValue || (a.NullValue = {}));
  function O(j) {
    switch (j) {
      case 0:
      case "NULL_VALUE":
        return k.NULL_VALUE;
      default:
        throw new ne.Error("Unrecognized enum value " + j + " for enum NullValue");
    }
  }
  a.nullValueFromJSON = O;
  function D(j) {
    switch (j) {
      case k.NULL_VALUE:
        return "NULL_VALUE";
      default:
        return "UNKNOWN";
    }
  }
  a.nullValueToJSON = D;
  function F(j) {
    switch (j) {
      case k.NULL_VALUE:
        return 0;
      default:
        return 0;
    }
  }
  a.nullValueToNumber = F;
  function H() {
    return { fields: {} };
  }
  a.Struct = {
    encode(j, ue = _.Writer.create()) {
      return Object.entries(j.fields).forEach(([he, fe]) => {
        fe !== void 0 && a.Struct_FieldsEntry.encode({ key: he, value: fe }, ue.uint32(10).fork()).ldelim();
      }), ue;
    },
    decode(j, ue) {
      const he = j instanceof _.Reader ? j : new _.Reader(j);
      let fe = ue === void 0 ? he.len : he.pos + ue;
      const be = H();
      for (; he.pos < fe; ) {
        const ke = he.uint32();
        switch (ke >>> 3) {
          case 1:
            const Te = a.Struct_FieldsEntry.decode(he, he.uint32());
            Te.value !== void 0 && (be.fields[Te.key] = Te.value);
            break;
          default:
            he.skipType(ke & 7);
            break;
        }
      }
      return be;
    },
    fromJSON(j) {
      return {
        fields: Q(j.fields) ? Object.entries(j.fields).reduce((ue, [he, fe]) => (ue[he] = fe, ue), {}) : {}
      };
    },
    toJSON(j) {
      const ue = {};
      return ue.fields = {}, j.fields && Object.entries(j.fields).forEach(([he, fe]) => {
        ue.fields[he] = fe;
      }), ue;
    },
    fromPartial(j) {
      var ue;
      const he = H();
      return he.fields = Object.entries((ue = j.fields) !== null && ue !== void 0 ? ue : {}).reduce((fe, [be, ke]) => (ke !== void 0 && (fe[be] = ke), fe), {}), he;
    },
    wrap(j) {
      const ue = H();
      return j !== void 0 && Object.keys(j).forEach((he) => {
        ue.fields[he] = j[he];
      }), ue;
    },
    unwrap(j) {
      const ue = {};
      return Object.keys(j.fields).forEach((he) => {
        ue[he] = j.fields[he];
      }), ue;
    }
  };
  function Z() {
    return { key: "", value: void 0 };
  }
  a.Struct_FieldsEntry = {
    encode(j, ue = _.Writer.create()) {
      return j.key !== "" && ue.uint32(10).string(j.key), j.value !== void 0 && a.Value.encode(a.Value.wrap(j.value), ue.uint32(18).fork()).ldelim(), ue;
    },
    decode(j, ue) {
      const he = j instanceof _.Reader ? j : new _.Reader(j);
      let fe = ue === void 0 ? he.len : he.pos + ue;
      const be = Z();
      for (; he.pos < fe; ) {
        const ke = he.uint32();
        switch (ke >>> 3) {
          case 1:
            be.key = he.string();
            break;
          case 2:
            be.value = a.Value.unwrap(a.Value.decode(he, he.uint32()));
            break;
          default:
            he.skipType(ke & 7);
            break;
        }
      }
      return be;
    },
    fromJSON(j) {
      return {
        key: ae(j.key) ? String(j.key) : "",
        value: ae(j == null ? void 0 : j.value) ? j.value : void 0
      };
    },
    toJSON(j) {
      const ue = {};
      return j.key !== void 0 && (ue.key = j.key), j.value !== void 0 && (ue.value = j.value), ue;
    },
    fromPartial(j) {
      var ue, he;
      const fe = Z();
      return fe.key = (ue = j.key) !== null && ue !== void 0 ? ue : "", fe.value = (he = j.value) !== null && he !== void 0 ? he : void 0, fe;
    }
  };
  function ee() {
    return {
      nullValue: void 0,
      numberValue: void 0,
      stringValue: void 0,
      boolValue: void 0,
      structValue: void 0,
      listValue: void 0
    };
  }
  a.Value = {
    encode(j, ue = _.Writer.create()) {
      return j.nullValue !== void 0 && ue.uint32(8).int32(F(j.nullValue)), j.numberValue !== void 0 && ue.uint32(17).double(j.numberValue), j.stringValue !== void 0 && ue.uint32(26).string(j.stringValue), j.boolValue !== void 0 && ue.uint32(32).bool(j.boolValue), j.structValue !== void 0 && a.Struct.encode(a.Struct.wrap(j.structValue), ue.uint32(42).fork()).ldelim(), j.listValue !== void 0 && a.ListValue.encode(a.ListValue.wrap(j.listValue), ue.uint32(50).fork()).ldelim(), ue;
    },
    decode(j, ue) {
      const he = j instanceof _.Reader ? j : new _.Reader(j);
      let fe = ue === void 0 ? he.len : he.pos + ue;
      const be = ee();
      for (; he.pos < fe; ) {
        const ke = he.uint32();
        switch (ke >>> 3) {
          case 1:
            be.nullValue = O(he.int32());
            break;
          case 2:
            be.numberValue = he.double();
            break;
          case 3:
            be.stringValue = he.string();
            break;
          case 4:
            be.boolValue = he.bool();
            break;
          case 5:
            be.structValue = a.Struct.unwrap(a.Struct.decode(he, he.uint32()));
            break;
          case 6:
            be.listValue = a.ListValue.unwrap(a.ListValue.decode(he, he.uint32()));
            break;
          default:
            he.skipType(ke & 7);
            break;
        }
      }
      return be;
    },
    fromJSON(j) {
      return {
        nullValue: ae(j.nullValue) ? O(j.nullValue) : void 0,
        numberValue: ae(j.numberValue) ? Number(j.numberValue) : void 0,
        stringValue: ae(j.stringValue) ? String(j.stringValue) : void 0,
        boolValue: ae(j.boolValue) ? !!j.boolValue : void 0,
        structValue: Q(j.structValue) ? j.structValue : void 0,
        listValue: Array.isArray(j.listValue) ? [...j.listValue] : void 0
      };
    },
    toJSON(j) {
      const ue = {};
      return j.nullValue !== void 0 && (ue.nullValue = j.nullValue !== void 0 ? D(j.nullValue) : void 0), j.numberValue !== void 0 && (ue.numberValue = j.numberValue), j.stringValue !== void 0 && (ue.stringValue = j.stringValue), j.boolValue !== void 0 && (ue.boolValue = j.boolValue), j.structValue !== void 0 && (ue.structValue = j.structValue), j.listValue !== void 0 && (ue.listValue = j.listValue), ue;
    },
    fromPartial(j) {
      var ue, he, fe, be, ke, Te;
      const q = ee();
      return q.nullValue = (ue = j.nullValue) !== null && ue !== void 0 ? ue : void 0, q.numberValue = (he = j.numberValue) !== null && he !== void 0 ? he : void 0, q.stringValue = (fe = j.stringValue) !== null && fe !== void 0 ? fe : void 0, q.boolValue = (be = j.boolValue) !== null && be !== void 0 ? be : void 0, q.structValue = (ke = j.structValue) !== null && ke !== void 0 ? ke : void 0, q.listValue = (Te = j.listValue) !== null && Te !== void 0 ? Te : void 0, q;
    },
    wrap(j) {
      const ue = ee();
      if (j === null)
        ue.nullValue = k.NULL_VALUE;
      else if (typeof j == "boolean")
        ue.boolValue = j;
      else if (typeof j == "number")
        ue.numberValue = j;
      else if (typeof j == "string")
        ue.stringValue = j;
      else if (Array.isArray(j))
        ue.listValue = j;
      else if (typeof j == "object")
        ue.structValue = j;
      else if (typeof j < "u")
        throw new Error("Unsupported any value type: " + typeof j);
      return ue;
    },
    unwrap(j) {
      if ((j == null ? void 0 : j.stringValue) !== void 0)
        return j.stringValue;
      if ((j == null ? void 0 : j.numberValue) !== void 0)
        return j.numberValue;
      if ((j == null ? void 0 : j.boolValue) !== void 0)
        return j.boolValue;
      if ((j == null ? void 0 : j.structValue) !== void 0)
        return j.structValue;
      if ((j == null ? void 0 : j.listValue) !== void 0)
        return j.listValue;
      if ((j == null ? void 0 : j.nullValue) !== void 0)
        return null;
    }
  };
  function X() {
    return { values: [] };
  }
  a.ListValue = {
    encode(j, ue = _.Writer.create()) {
      for (const he of j.values)
        a.Value.encode(a.Value.wrap(he), ue.uint32(10).fork()).ldelim();
      return ue;
    },
    decode(j, ue) {
      const he = j instanceof _.Reader ? j : new _.Reader(j);
      let fe = ue === void 0 ? he.len : he.pos + ue;
      const be = X();
      for (; he.pos < fe; ) {
        const ke = he.uint32();
        switch (ke >>> 3) {
          case 1:
            be.values.push(a.Value.unwrap(a.Value.decode(he, he.uint32())));
            break;
          default:
            he.skipType(ke & 7);
            break;
        }
      }
      return be;
    },
    fromJSON(j) {
      return {
        values: Array.isArray(j == null ? void 0 : j.values) ? [...j.values] : []
      };
    },
    toJSON(j) {
      const ue = {};
      return j.values ? ue.values = j.values.map((he) => he) : ue.values = [], ue;
    },
    fromPartial(j) {
      var ue;
      const he = X();
      return he.values = ((ue = j.values) === null || ue === void 0 ? void 0 : ue.map((fe) => fe)) || [], he;
    },
    wrap(j) {
      const ue = X();
      return ue.values = j ?? [], ue;
    },
    unwrap(j) {
      return j.values;
    }
  };
  var ne = (() => {
    if (typeof ne < "u")
      return ne;
    if (typeof self < "u")
      return self;
    if (typeof window < "u")
      return window;
    if (typeof commonjsGlobal$1 < "u")
      return commonjsGlobal$1;
    throw "Unable to locate global object";
  })();
  _.util.Long !== p.default && (_.util.Long = p.default, _.configure());
  function Q(j) {
    return typeof j == "object" && j !== null;
  }
  function ae(j) {
    return j != null;
  }
})(struct$2);
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(x, se, Se, xe) {
    xe === void 0 && (xe = Se), Object.defineProperty(x, xe, { enumerable: !0, get: function() {
      return se[Se];
    } });
  } : function(x, se, Se, xe) {
    xe === void 0 && (xe = Se), x[xe] = se[Se];
  }), c = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(x, se) {
    Object.defineProperty(x, "default", { enumerable: !0, value: se });
  } : function(x, se) {
    x.default = se;
  }), l = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(x) {
    if (x && x.__esModule)
      return x;
    var se = {};
    if (x != null)
      for (var Se in x)
        Se !== "default" && Object.hasOwnProperty.call(x, Se) && u(se, x, Se);
    return c(se, x), se;
  }, v = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(x) {
    return x && x.__esModule ? x : { default: x };
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.LayoutServiceDefinition = a.LayoutServiceClientImpl = a.LayerServiceDefinition = a.LayerServiceClientImpl = a.Event = a.LayerEvent = a.LayoutEvent = a.BatchLayerRequest_BatchItem = a.BatchLayerRequest = a.BatchDeleteLayerRequest = a.DeleteLayerPayload = a.UpdateLayerRequest = a.GetLayerRequest = a.CreateLayerRequest = a.ListLayersResponse = a.ListLayersRequest = a.PartialLayerWithID = a.PartialLayer = a.LayerAnimation = a.DeleteLayoutResponse = a.DeleteLayoutRequest = a.DeleteLayoutPayload = a.UpdateLayoutRequest = a.GetLayoutRequest = a.CreateLayoutRequest = a.ListLayoutsResponse = a.ListLayoutsRequest = a.PartialLayout = a.BatchLayerResponse_BatchLayerItem = a.BatchLayerResponse = a.DeleteLayerResponse = a.DeleteLayerRequest = a.Layer = a.Layout = a.Transition_TransitionStinger = a.Transition_TransitionStingerCut = a.Transition_TransitionSwipe = a.Transition_TransitionCrossfade = a.Transition_TransitionFadeToColor = a.Transition_TransitionCut = a.Transition_TransitionMediaType = a.Transition = a.transition_TransitionSwipeTypeToNumber = a.transition_TransitionSwipeTypeToJSON = a.transition_TransitionSwipeTypeFromJSON = a.Transition_TransitionSwipeType = a.transition_TransitionDirectionToNumber = a.transition_TransitionDirectionToJSON = a.transition_TransitionDirectionFromJSON = a.Transition_TransitionDirection = a.eventTypeToNumber = a.eventTypeToJSON = a.eventTypeFromJSON = a.EventType = a.eventSubTypeToNumber = a.eventSubTypeToJSON = a.eventSubTypeFromJSON = a.EventSubType = a.requestAnimationModeToNumber = a.requestAnimationModeToJSON = a.requestAnimationModeFromJSON = a.RequestAnimationMode = a.layoutTypeToNumber = a.layoutTypeToJSON = a.layoutTypeFromJSON = a.LayoutType = a.protobufPackage = void 0;
  const p = v(umdExports), _ = l(minimal), k = struct$2;
  a.protobufPackage = "apis.layout.v2";
  var O;
  (function(x) {
    x.LAYOUT_TYPE_UNSPECIFIED = "LAYOUT_TYPE_UNSPECIFIED", x.LAYOUT_TYPE_SCENELESS = "LAYOUT_TYPE_SCENELESS", x.LAYOUT_TYPE_SCENE = "LAYOUT_TYPE_SCENE";
  })(O = a.LayoutType || (a.LayoutType = {}));
  function D(x) {
    switch (x) {
      case 0:
      case "LAYOUT_TYPE_UNSPECIFIED":
        return O.LAYOUT_TYPE_UNSPECIFIED;
      case 1:
      case "LAYOUT_TYPE_SCENELESS":
        return O.LAYOUT_TYPE_SCENELESS;
      case 2:
      case "LAYOUT_TYPE_SCENE":
        return O.LAYOUT_TYPE_SCENE;
      default:
        throw new Je.Error("Unrecognized enum value " + x + " for enum LayoutType");
    }
  }
  a.layoutTypeFromJSON = D;
  function F(x) {
    switch (x) {
      case O.LAYOUT_TYPE_UNSPECIFIED:
        return "LAYOUT_TYPE_UNSPECIFIED";
      case O.LAYOUT_TYPE_SCENELESS:
        return "LAYOUT_TYPE_SCENELESS";
      case O.LAYOUT_TYPE_SCENE:
        return "LAYOUT_TYPE_SCENE";
      default:
        return "UNKNOWN";
    }
  }
  a.layoutTypeToJSON = F;
  function H(x) {
    switch (x) {
      case O.LAYOUT_TYPE_UNSPECIFIED:
        return 0;
      case O.LAYOUT_TYPE_SCENELESS:
        return 1;
      case O.LAYOUT_TYPE_SCENE:
        return 2;
      default:
        return 0;
    }
  }
  a.layoutTypeToNumber = H;
  var Z;
  (function(x) {
    x.REQUEST_ANIMATION_MODE_UNSPECIFIED = "REQUEST_ANIMATION_MODE_UNSPECIFIED", x.REQUEST_ANIMATION_MODE_PARALLEL = "REQUEST_ANIMATION_MODE_PARALLEL", x.REQUEST_ANIMATION_MODE_SERIES = "REQUEST_ANIMATION_MODE_SERIES";
  })(Z = a.RequestAnimationMode || (a.RequestAnimationMode = {}));
  function ee(x) {
    switch (x) {
      case 0:
      case "REQUEST_ANIMATION_MODE_UNSPECIFIED":
        return Z.REQUEST_ANIMATION_MODE_UNSPECIFIED;
      case 1:
      case "REQUEST_ANIMATION_MODE_PARALLEL":
        return Z.REQUEST_ANIMATION_MODE_PARALLEL;
      case 2:
      case "REQUEST_ANIMATION_MODE_SERIES":
        return Z.REQUEST_ANIMATION_MODE_SERIES;
      default:
        throw new Je.Error("Unrecognized enum value " + x + " for enum RequestAnimationMode");
    }
  }
  a.requestAnimationModeFromJSON = ee;
  function X(x) {
    switch (x) {
      case Z.REQUEST_ANIMATION_MODE_UNSPECIFIED:
        return "REQUEST_ANIMATION_MODE_UNSPECIFIED";
      case Z.REQUEST_ANIMATION_MODE_PARALLEL:
        return "REQUEST_ANIMATION_MODE_PARALLEL";
      case Z.REQUEST_ANIMATION_MODE_SERIES:
        return "REQUEST_ANIMATION_MODE_SERIES";
      default:
        return "UNKNOWN";
    }
  }
  a.requestAnimationModeToJSON = X;
  function ne(x) {
    switch (x) {
      case Z.REQUEST_ANIMATION_MODE_UNSPECIFIED:
        return 0;
      case Z.REQUEST_ANIMATION_MODE_PARALLEL:
        return 1;
      case Z.REQUEST_ANIMATION_MODE_SERIES:
        return 2;
      default:
        return 0;
    }
  }
  a.requestAnimationModeToNumber = ne;
  var Q;
  (function(x) {
    x.EVENT_SUB_TYPE_UNSPECIFIED = "EVENT_SUB_TYPE_UNSPECIFIED", x.EVENT_SUB_TYPE_CREATE = "EVENT_SUB_TYPE_CREATE", x.EVENT_SUB_TYPE_UPDATE = "EVENT_SUB_TYPE_UPDATE", x.EVENT_SUB_TYPE_DELETE = "EVENT_SUB_TYPE_DELETE", x.EVENT_SUB_TYPE_BATCH = "EVENT_SUB_TYPE_BATCH";
  })(Q = a.EventSubType || (a.EventSubType = {}));
  function ae(x) {
    switch (x) {
      case 0:
      case "EVENT_SUB_TYPE_UNSPECIFIED":
        return Q.EVENT_SUB_TYPE_UNSPECIFIED;
      case 1:
      case "EVENT_SUB_TYPE_CREATE":
        return Q.EVENT_SUB_TYPE_CREATE;
      case 2:
      case "EVENT_SUB_TYPE_UPDATE":
        return Q.EVENT_SUB_TYPE_UPDATE;
      case 3:
      case "EVENT_SUB_TYPE_DELETE":
        return Q.EVENT_SUB_TYPE_DELETE;
      case 4:
      case "EVENT_SUB_TYPE_BATCH":
        return Q.EVENT_SUB_TYPE_BATCH;
      default:
        throw new Je.Error("Unrecognized enum value " + x + " for enum EventSubType");
    }
  }
  a.eventSubTypeFromJSON = ae;
  function j(x) {
    switch (x) {
      case Q.EVENT_SUB_TYPE_UNSPECIFIED:
        return "EVENT_SUB_TYPE_UNSPECIFIED";
      case Q.EVENT_SUB_TYPE_CREATE:
        return "EVENT_SUB_TYPE_CREATE";
      case Q.EVENT_SUB_TYPE_UPDATE:
        return "EVENT_SUB_TYPE_UPDATE";
      case Q.EVENT_SUB_TYPE_DELETE:
        return "EVENT_SUB_TYPE_DELETE";
      case Q.EVENT_SUB_TYPE_BATCH:
        return "EVENT_SUB_TYPE_BATCH";
      default:
        return "UNKNOWN";
    }
  }
  a.eventSubTypeToJSON = j;
  function ue(x) {
    switch (x) {
      case Q.EVENT_SUB_TYPE_UNSPECIFIED:
        return 0;
      case Q.EVENT_SUB_TYPE_CREATE:
        return 1;
      case Q.EVENT_SUB_TYPE_UPDATE:
        return 2;
      case Q.EVENT_SUB_TYPE_DELETE:
        return 3;
      case Q.EVENT_SUB_TYPE_BATCH:
        return 4;
      default:
        return 0;
    }
  }
  a.eventSubTypeToNumber = ue;
  var he;
  (function(x) {
    x.EVENT_TYPE_UNSPECIFIED = "EVENT_TYPE_UNSPECIFIED", x.EVENT_TYPE_LAYOUT = "EVENT_TYPE_LAYOUT", x.EVENT_TYPE_LAYER = "EVENT_TYPE_LAYER";
  })(he = a.EventType || (a.EventType = {}));
  function fe(x) {
    switch (x) {
      case 0:
      case "EVENT_TYPE_UNSPECIFIED":
        return he.EVENT_TYPE_UNSPECIFIED;
      case 1:
      case "EVENT_TYPE_LAYOUT":
        return he.EVENT_TYPE_LAYOUT;
      case 2:
      case "EVENT_TYPE_LAYER":
        return he.EVENT_TYPE_LAYER;
      default:
        throw new Je.Error("Unrecognized enum value " + x + " for enum EventType");
    }
  }
  a.eventTypeFromJSON = fe;
  function be(x) {
    switch (x) {
      case he.EVENT_TYPE_UNSPECIFIED:
        return "EVENT_TYPE_UNSPECIFIED";
      case he.EVENT_TYPE_LAYOUT:
        return "EVENT_TYPE_LAYOUT";
      case he.EVENT_TYPE_LAYER:
        return "EVENT_TYPE_LAYER";
      default:
        return "UNKNOWN";
    }
  }
  a.eventTypeToJSON = be;
  function ke(x) {
    switch (x) {
      case he.EVENT_TYPE_UNSPECIFIED:
        return 0;
      case he.EVENT_TYPE_LAYOUT:
        return 1;
      case he.EVENT_TYPE_LAYER:
        return 2;
      default:
        return 0;
    }
  }
  a.eventTypeToNumber = ke;
  var Te;
  (function(x) {
    x.TRANSITION_DIRECTION_UNSPECIFIED = "TRANSITION_DIRECTION_UNSPECIFIED", x.TRANSITION_DIRECTION_LEFT = "TRANSITION_DIRECTION_LEFT", x.TRANSITION_DIRECTION_RIGHT = "TRANSITION_DIRECTION_RIGHT", x.TRANSITION_DIRECTION_UP = "TRANSITION_DIRECTION_UP", x.TRANSITION_DIRECTION_DOWN = "TRANSITION_DIRECTION_DOWN";
  })(Te = a.Transition_TransitionDirection || (a.Transition_TransitionDirection = {}));
  function q(x) {
    switch (x) {
      case 0:
      case "TRANSITION_DIRECTION_UNSPECIFIED":
        return Te.TRANSITION_DIRECTION_UNSPECIFIED;
      case 1:
      case "TRANSITION_DIRECTION_LEFT":
        return Te.TRANSITION_DIRECTION_LEFT;
      case 2:
      case "TRANSITION_DIRECTION_RIGHT":
        return Te.TRANSITION_DIRECTION_RIGHT;
      case 3:
      case "TRANSITION_DIRECTION_UP":
        return Te.TRANSITION_DIRECTION_UP;
      case 4:
      case "TRANSITION_DIRECTION_DOWN":
        return Te.TRANSITION_DIRECTION_DOWN;
      default:
        throw new Je.Error("Unrecognized enum value " + x + " for enum Transition_TransitionDirection");
    }
  }
  a.transition_TransitionDirectionFromJSON = q;
  function z(x) {
    switch (x) {
      case Te.TRANSITION_DIRECTION_UNSPECIFIED:
        return "TRANSITION_DIRECTION_UNSPECIFIED";
      case Te.TRANSITION_DIRECTION_LEFT:
        return "TRANSITION_DIRECTION_LEFT";
      case Te.TRANSITION_DIRECTION_RIGHT:
        return "TRANSITION_DIRECTION_RIGHT";
      case Te.TRANSITION_DIRECTION_UP:
        return "TRANSITION_DIRECTION_UP";
      case Te.TRANSITION_DIRECTION_DOWN:
        return "TRANSITION_DIRECTION_DOWN";
      default:
        return "UNKNOWN";
    }
  }
  a.transition_TransitionDirectionToJSON = z;
  function P(x) {
    switch (x) {
      case Te.TRANSITION_DIRECTION_UNSPECIFIED:
        return 0;
      case Te.TRANSITION_DIRECTION_LEFT:
        return 1;
      case Te.TRANSITION_DIRECTION_RIGHT:
        return 2;
      case Te.TRANSITION_DIRECTION_UP:
        return 3;
      case Te.TRANSITION_DIRECTION_DOWN:
        return 4;
      default:
        return 0;
    }
  }
  a.transition_TransitionDirectionToNumber = P;
  var S;
  (function(x) {
    x.TRANSITION_SWIPE_TYPE_UNSPECIFIED = "TRANSITION_SWIPE_TYPE_UNSPECIFIED", x.TRANSITION_SWIPE_TYPE_COMBINED = "TRANSITION_SWIPE_TYPE_COMBINED", x.TRANSITION_SWIPE_TYPE_SOURCE = "TRANSITION_SWIPE_TYPE_SOURCE", x.TRANSITION_SWIPE_TYPE_DESTINATION = "TRANSITION_SWIPE_TYPE_DESTINATION";
  })(S = a.Transition_TransitionSwipeType || (a.Transition_TransitionSwipeType = {}));
  function E(x) {
    switch (x) {
      case 0:
      case "TRANSITION_SWIPE_TYPE_UNSPECIFIED":
        return S.TRANSITION_SWIPE_TYPE_UNSPECIFIED;
      case 1:
      case "TRANSITION_SWIPE_TYPE_COMBINED":
        return S.TRANSITION_SWIPE_TYPE_COMBINED;
      case 2:
      case "TRANSITION_SWIPE_TYPE_SOURCE":
        return S.TRANSITION_SWIPE_TYPE_SOURCE;
      case 3:
      case "TRANSITION_SWIPE_TYPE_DESTINATION":
        return S.TRANSITION_SWIPE_TYPE_DESTINATION;
      default:
        throw new Je.Error("Unrecognized enum value " + x + " for enum Transition_TransitionSwipeType");
    }
  }
  a.transition_TransitionSwipeTypeFromJSON = E;
  function I(x) {
    switch (x) {
      case S.TRANSITION_SWIPE_TYPE_UNSPECIFIED:
        return "TRANSITION_SWIPE_TYPE_UNSPECIFIED";
      case S.TRANSITION_SWIPE_TYPE_COMBINED:
        return "TRANSITION_SWIPE_TYPE_COMBINED";
      case S.TRANSITION_SWIPE_TYPE_SOURCE:
        return "TRANSITION_SWIPE_TYPE_SOURCE";
      case S.TRANSITION_SWIPE_TYPE_DESTINATION:
        return "TRANSITION_SWIPE_TYPE_DESTINATION";
      default:
        return "UNKNOWN";
    }
  }
  a.transition_TransitionSwipeTypeToJSON = I;
  function M(x) {
    switch (x) {
      case S.TRANSITION_SWIPE_TYPE_UNSPECIFIED:
        return 0;
      case S.TRANSITION_SWIPE_TYPE_COMBINED:
        return 1;
      case S.TRANSITION_SWIPE_TYPE_SOURCE:
        return 2;
      case S.TRANSITION_SWIPE_TYPE_DESTINATION:
        return 3;
      default:
        return 0;
    }
  }
  a.transition_TransitionSwipeTypeToNumber = M;
  function $() {
    return {
      fromLayoutIds: [],
      cut: void 0,
      crossfade: void 0,
      fadeToColor: void 0,
      swipe: void 0,
      stinger: void 0
    };
  }
  a.Transition = {
    encode(x, se = _.Writer.create()) {
      for (const Se of x.fromLayoutIds)
        se.uint32(10).string(Se);
      return x.cut !== void 0 && a.Transition_TransitionCut.encode(x.cut, se.uint32(82).fork()).ldelim(), x.crossfade !== void 0 && a.Transition_TransitionCrossfade.encode(x.crossfade, se.uint32(90).fork()).ldelim(), x.fadeToColor !== void 0 && a.Transition_TransitionFadeToColor.encode(x.fadeToColor, se.uint32(98).fork()).ldelim(), x.swipe !== void 0 && a.Transition_TransitionSwipe.encode(x.swipe, se.uint32(106).fork()).ldelim(), x.stinger !== void 0 && a.Transition_TransitionStinger.encode(x.stinger, se.uint32(114).fork()).ldelim(), se;
    },
    decode(x, se) {
      const Se = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Se.len : Se.pos + se;
      const Ae = $();
      for (; Se.pos < xe; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 1:
            Ae.fromLayoutIds.push(Se.string());
            break;
          case 10:
            Ae.cut = a.Transition_TransitionCut.decode(Se, Se.uint32());
            break;
          case 11:
            Ae.crossfade = a.Transition_TransitionCrossfade.decode(Se, Se.uint32());
            break;
          case 12:
            Ae.fadeToColor = a.Transition_TransitionFadeToColor.decode(Se, Se.uint32());
            break;
          case 13:
            Ae.swipe = a.Transition_TransitionSwipe.decode(Se, Se.uint32());
            break;
          case 14:
            Ae.stinger = a.Transition_TransitionStinger.decode(Se, Se.uint32());
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return Ae;
    },
    fromJSON(x) {
      return {
        fromLayoutIds: Array.isArray(x == null ? void 0 : x.fromLayoutIds) ? x.fromLayoutIds.map((se) => String(se)) : [],
        cut: Ke(x.cut) ? a.Transition_TransitionCut.fromJSON(x.cut) : void 0,
        crossfade: Ke(x.crossfade) ? a.Transition_TransitionCrossfade.fromJSON(x.crossfade) : void 0,
        fadeToColor: Ke(x.fadeToColor) ? a.Transition_TransitionFadeToColor.fromJSON(x.fadeToColor) : void 0,
        swipe: Ke(x.swipe) ? a.Transition_TransitionSwipe.fromJSON(x.swipe) : void 0,
        stinger: Ke(x.stinger) ? a.Transition_TransitionStinger.fromJSON(x.stinger) : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.fromLayoutIds ? se.fromLayoutIds = x.fromLayoutIds.map((Se) => Se) : se.fromLayoutIds = [], x.cut !== void 0 && (se.cut = x.cut ? a.Transition_TransitionCut.toJSON(x.cut) : void 0), x.crossfade !== void 0 && (se.crossfade = x.crossfade ? a.Transition_TransitionCrossfade.toJSON(x.crossfade) : void 0), x.fadeToColor !== void 0 && (se.fadeToColor = x.fadeToColor ? a.Transition_TransitionFadeToColor.toJSON(x.fadeToColor) : void 0), x.swipe !== void 0 && (se.swipe = x.swipe ? a.Transition_TransitionSwipe.toJSON(x.swipe) : void 0), x.stinger !== void 0 && (se.stinger = x.stinger ? a.Transition_TransitionStinger.toJSON(x.stinger) : void 0), se;
    },
    fromPartial(x) {
      var se;
      const Se = $();
      return Se.fromLayoutIds = ((se = x.fromLayoutIds) === null || se === void 0 ? void 0 : se.map((xe) => xe)) || [], Se.cut = x.cut !== void 0 && x.cut !== null ? a.Transition_TransitionCut.fromPartial(x.cut) : void 0, Se.crossfade = x.crossfade !== void 0 && x.crossfade !== null ? a.Transition_TransitionCrossfade.fromPartial(x.crossfade) : void 0, Se.fadeToColor = x.fadeToColor !== void 0 && x.fadeToColor !== null ? a.Transition_TransitionFadeToColor.fromPartial(x.fadeToColor) : void 0, Se.swipe = x.swipe !== void 0 && x.swipe !== null ? a.Transition_TransitionSwipe.fromPartial(x.swipe) : void 0, Se.stinger = x.stinger !== void 0 && x.stinger !== null ? a.Transition_TransitionStinger.fromPartial(x.stinger) : void 0, Se;
    }
  };
  function U() {
    return { url: "", volume: 0 };
  }
  a.Transition_TransitionMediaType = {
    encode(x, se = _.Writer.create()) {
      return x.url !== "" && se.uint32(10).string(x.url), x.volume !== 0 && se.uint32(17).double(x.volume), se;
    },
    decode(x, se) {
      const Se = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Se.len : Se.pos + se;
      const Ae = U();
      for (; Se.pos < xe; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 1:
            Ae.url = Se.string();
            break;
          case 2:
            Ae.volume = Se.double();
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return Ae;
    },
    fromJSON(x) {
      return {
        url: Ke(x.url) ? String(x.url) : "",
        volume: Ke(x.volume) ? Number(x.volume) : 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.url !== void 0 && (se.url = x.url), x.volume !== void 0 && (se.volume = x.volume), se;
    },
    fromPartial(x) {
      var se, Se;
      const xe = U();
      return xe.url = (se = x.url) !== null && se !== void 0 ? se : "", xe.volume = (Se = x.volume) !== null && Se !== void 0 ? Se : 0, xe;
    }
  };
  function Y() {
    return {};
  }
  a.Transition_TransitionCut = {
    encode(x, se = _.Writer.create()) {
      return se;
    },
    decode(x, se) {
      const Se = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Se.len : Se.pos + se;
      const Ae = Y();
      for (; Se.pos < xe; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return Ae;
    },
    fromJSON(x) {
      return {};
    },
    toJSON(x) {
      return {};
    },
    fromPartial(x) {
      return Y();
    }
  };
  function B() {
    return { durationMs: 0, backgroundColor: "" };
  }
  a.Transition_TransitionFadeToColor = {
    encode(x, se = _.Writer.create()) {
      return x.durationMs !== 0 && se.uint32(8).int32(x.durationMs), x.backgroundColor !== "" && se.uint32(18).string(x.backgroundColor), se;
    },
    decode(x, se) {
      const Se = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Se.len : Se.pos + se;
      const Ae = B();
      for (; Se.pos < xe; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 1:
            Ae.durationMs = Se.int32();
            break;
          case 2:
            Ae.backgroundColor = Se.string();
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return Ae;
    },
    fromJSON(x) {
      return {
        durationMs: Ke(x.durationMs) ? Number(x.durationMs) : 0,
        backgroundColor: Ke(x.backgroundColor) ? String(x.backgroundColor) : ""
      };
    },
    toJSON(x) {
      const se = {};
      return x.durationMs !== void 0 && (se.durationMs = Math.round(x.durationMs)), x.backgroundColor !== void 0 && (se.backgroundColor = x.backgroundColor), se;
    },
    fromPartial(x) {
      var se, Se;
      const xe = B();
      return xe.durationMs = (se = x.durationMs) !== null && se !== void 0 ? se : 0, xe.backgroundColor = (Se = x.backgroundColor) !== null && Se !== void 0 ? Se : "", xe;
    }
  };
  function T() {
    return { durationMs: 0 };
  }
  a.Transition_TransitionCrossfade = {
    encode(x, se = _.Writer.create()) {
      return x.durationMs !== 0 && se.uint32(8).int32(x.durationMs), se;
    },
    decode(x, se) {
      const Se = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Se.len : Se.pos + se;
      const Ae = T();
      for (; Se.pos < xe; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 1:
            Ae.durationMs = Se.int32();
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return Ae;
    },
    fromJSON(x) {
      return {
        durationMs: Ke(x.durationMs) ? Number(x.durationMs) : 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.durationMs !== void 0 && (se.durationMs = Math.round(x.durationMs)), se;
    },
    fromPartial(x) {
      var se;
      const Se = T();
      return Se.durationMs = (se = x.durationMs) !== null && se !== void 0 ? se : 0, Se;
    }
  };
  function L() {
    return {
      durationMs: 0,
      direction: Te.TRANSITION_DIRECTION_UNSPECIFIED,
      combinedAnimation: S.TRANSITION_SWIPE_TYPE_UNSPECIFIED
    };
  }
  a.Transition_TransitionSwipe = {
    encode(x, se = _.Writer.create()) {
      return x.durationMs !== 0 && se.uint32(8).int32(x.durationMs), x.direction !== Te.TRANSITION_DIRECTION_UNSPECIFIED && se.uint32(16).int32(P(x.direction)), x.combinedAnimation !== S.TRANSITION_SWIPE_TYPE_UNSPECIFIED && se.uint32(24).int32(M(x.combinedAnimation)), se;
    },
    decode(x, se) {
      const Se = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Se.len : Se.pos + se;
      const Ae = L();
      for (; Se.pos < xe; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 1:
            Ae.durationMs = Se.int32();
            break;
          case 2:
            Ae.direction = q(Se.int32());
            break;
          case 3:
            Ae.combinedAnimation = E(Se.int32());
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return Ae;
    },
    fromJSON(x) {
      return {
        durationMs: Ke(x.durationMs) ? Number(x.durationMs) : 0,
        direction: Ke(x.direction) ? q(x.direction) : Te.TRANSITION_DIRECTION_UNSPECIFIED,
        combinedAnimation: Ke(x.combinedAnimation) ? E(x.combinedAnimation) : S.TRANSITION_SWIPE_TYPE_UNSPECIFIED
      };
    },
    toJSON(x) {
      const se = {};
      return x.durationMs !== void 0 && (se.durationMs = Math.round(x.durationMs)), x.direction !== void 0 && (se.direction = z(x.direction)), x.combinedAnimation !== void 0 && (se.combinedAnimation = I(x.combinedAnimation)), se;
    },
    fromPartial(x) {
      var se, Se, xe;
      const Ae = L();
      return Ae.durationMs = (se = x.durationMs) !== null && se !== void 0 ? se : 0, Ae.direction = (Se = x.direction) !== null && Se !== void 0 ? Se : Te.TRANSITION_DIRECTION_UNSPECIFIED, Ae.combinedAnimation = (xe = x.combinedAnimation) !== null && xe !== void 0 ? xe : S.TRANSITION_SWIPE_TYPE_UNSPECIFIED, Ae;
    }
  };
  function te() {
    return { cutPointMs: 0, media: void 0 };
  }
  a.Transition_TransitionStingerCut = {
    encode(x, se = _.Writer.create()) {
      return x.cutPointMs !== 0 && se.uint32(8).int32(x.cutPointMs), x.media !== void 0 && a.Transition_TransitionMediaType.encode(x.media, se.uint32(18).fork()).ldelim(), se;
    },
    decode(x, se) {
      const Se = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Se.len : Se.pos + se;
      const Ae = te();
      for (; Se.pos < xe; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 1:
            Ae.cutPointMs = Se.int32();
            break;
          case 2:
            Ae.media = a.Transition_TransitionMediaType.decode(Se, Se.uint32());
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return Ae;
    },
    fromJSON(x) {
      return {
        cutPointMs: Ke(x.cutPointMs) ? Number(x.cutPointMs) : 0,
        media: Ke(x.media) ? a.Transition_TransitionMediaType.fromJSON(x.media) : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.cutPointMs !== void 0 && (se.cutPointMs = Math.round(x.cutPointMs)), x.media !== void 0 && (se.media = x.media ? a.Transition_TransitionMediaType.toJSON(x.media) : void 0), se;
    },
    fromPartial(x) {
      var se;
      const Se = te();
      return Se.cutPointMs = (se = x.cutPointMs) !== null && se !== void 0 ? se : 0, Se.media = x.media !== void 0 && x.media !== null ? a.Transition_TransitionMediaType.fromPartial(x.media) : void 0, Se;
    }
  };
  function me() {
    return { cut: void 0 };
  }
  a.Transition_TransitionStinger = {
    encode(x, se = _.Writer.create()) {
      return x.cut !== void 0 && a.Transition_TransitionStingerCut.encode(x.cut, se.uint32(10).fork()).ldelim(), se;
    },
    decode(x, se) {
      const Se = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Se.len : Se.pos + se;
      const Ae = me();
      for (; Se.pos < xe; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 1:
            Ae.cut = a.Transition_TransitionStingerCut.decode(Se, Se.uint32());
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return Ae;
    },
    fromJSON(x) {
      return {
        cut: Ke(x.cut) ? a.Transition_TransitionStingerCut.fromJSON(x.cut) : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.cut !== void 0 && (se.cut = x.cut ? a.Transition_TransitionStingerCut.toJSON(x.cut) : void 0), se;
    },
    fromPartial(x) {
      const se = me();
      return se.cut = x.cut !== void 0 && x.cut !== null ? a.Transition_TransitionStingerCut.fromPartial(x.cut) : void 0, se;
    }
  };
  function Ce() {
    return {
      id: "",
      width: 0,
      height: 0,
      metadata: void 0,
      projectId: void 0,
      collectionId: void 0,
      type: void 0,
      transitions: [],
      requestMetadata: void 0
    };
  }
  a.Layout = {
    encode(x, se = _.Writer.create()) {
      x.id !== "" && se.uint32(10).string(x.id), x.width !== 0 && se.uint32(16).int32(x.width), x.height !== 0 && se.uint32(24).int32(x.height), x.metadata !== void 0 && k.Value.encode(k.Value.wrap(x.metadata), se.uint32(50).fork()).ldelim(), x.projectId !== void 0 && se.uint32(58).string(x.projectId), x.collectionId !== void 0 && se.uint32(66).string(x.collectionId), x.type !== void 0 && se.uint32(72).int32(H(x.type));
      for (const Se of x.transitions)
        a.Transition.encode(Se, se.uint32(82).fork()).ldelim();
      return x.requestMetadata !== void 0 && k.Value.encode(k.Value.wrap(x.requestMetadata), se.uint32(810).fork()).ldelim(), se;
    },
    decode(x, se) {
      const Se = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Se.len : Se.pos + se;
      const Ae = Ce();
      for (; Se.pos < xe; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 1:
            Ae.id = Se.string();
            break;
          case 2:
            Ae.width = Se.int32();
            break;
          case 3:
            Ae.height = Se.int32();
            break;
          case 6:
            Ae.metadata = k.Value.unwrap(k.Value.decode(Se, Se.uint32()));
            break;
          case 7:
            Ae.projectId = Se.string();
            break;
          case 8:
            Ae.collectionId = Se.string();
            break;
          case 9:
            Ae.type = D(Se.int32());
            break;
          case 10:
            Ae.transitions.push(a.Transition.decode(Se, Se.uint32()));
            break;
          case 101:
            Ae.requestMetadata = k.Value.unwrap(k.Value.decode(Se, Se.uint32()));
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return Ae;
    },
    fromJSON(x) {
      return {
        id: Ke(x.id) ? String(x.id) : "",
        width: Ke(x.width) ? Number(x.width) : 0,
        height: Ke(x.height) ? Number(x.height) : 0,
        metadata: Ke(x == null ? void 0 : x.metadata) ? x.metadata : void 0,
        projectId: Ke(x.projectId) ? String(x.projectId) : void 0,
        collectionId: Ke(x.collectionId) ? String(x.collectionId) : void 0,
        type: Ke(x.type) ? D(x.type) : void 0,
        transitions: Array.isArray(x == null ? void 0 : x.transitions) ? x.transitions.map((se) => a.Transition.fromJSON(se)) : [],
        requestMetadata: Ke(x == null ? void 0 : x.requestMetadata) ? x.requestMetadata : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.id !== void 0 && (se.id = x.id), x.width !== void 0 && (se.width = Math.round(x.width)), x.height !== void 0 && (se.height = Math.round(x.height)), x.metadata !== void 0 && (se.metadata = x.metadata), x.projectId !== void 0 && (se.projectId = x.projectId), x.collectionId !== void 0 && (se.collectionId = x.collectionId), x.type !== void 0 && (se.type = x.type !== void 0 ? F(x.type) : void 0), x.transitions ? se.transitions = x.transitions.map((Se) => Se ? a.Transition.toJSON(Se) : void 0) : se.transitions = [], x.requestMetadata !== void 0 && (se.requestMetadata = x.requestMetadata), se;
    },
    fromPartial(x) {
      var se, Se, xe, Ae, Ye, et, dt, St, tt;
      const at = Ce();
      return at.id = (se = x.id) !== null && se !== void 0 ? se : "", at.width = (Se = x.width) !== null && Se !== void 0 ? Se : 0, at.height = (xe = x.height) !== null && xe !== void 0 ? xe : 0, at.metadata = (Ae = x.metadata) !== null && Ae !== void 0 ? Ae : void 0, at.projectId = (Ye = x.projectId) !== null && Ye !== void 0 ? Ye : void 0, at.collectionId = (et = x.collectionId) !== null && et !== void 0 ? et : void 0, at.type = (dt = x.type) !== null && dt !== void 0 ? dt : void 0, at.transitions = ((St = x.transitions) === null || St === void 0 ? void 0 : St.map((kt) => a.Transition.fromPartial(kt))) || [], at.requestMetadata = (tt = x.requestMetadata) !== null && tt !== void 0 ? tt : void 0, at;
    }
  };
  function De() {
    return {
      type: "",
      data: void 0,
      x: void 0,
      y: void 0,
      width: void 0,
      height: void 0,
      rotation: 0,
      opacity: 0,
      scale: 0,
      hidden: !1,
      children: void 0,
      metadata: void 0,
      id: "",
      layoutId: "",
      requestMetadata: void 0,
      requestAnimation: []
    };
  }
  a.Layer = {
    encode(x, se = _.Writer.create()) {
      x.type !== "" && se.uint32(10).string(x.type), x.data !== void 0 && k.Struct.encode(k.Struct.wrap(x.data), se.uint32(18).fork()).ldelim(), x.x !== void 0 && k.Value.encode(k.Value.wrap(x.x), se.uint32(26).fork()).ldelim(), x.y !== void 0 && k.Value.encode(k.Value.wrap(x.y), se.uint32(34).fork()).ldelim(), x.width !== void 0 && k.Value.encode(k.Value.wrap(x.width), se.uint32(42).fork()).ldelim(), x.height !== void 0 && k.Value.encode(k.Value.wrap(x.height), se.uint32(50).fork()).ldelim(), x.rotation !== 0 && se.uint32(57).double(x.rotation), x.opacity !== 0 && se.uint32(65).double(x.opacity), x.scale !== 0 && se.uint32(73).double(x.scale), x.hidden === !0 && se.uint32(80).bool(x.hidden), x.children !== void 0 && k.ListValue.encode(k.ListValue.wrap(x.children), se.uint32(98).fork()).ldelim(), x.metadata !== void 0 && k.Value.encode(k.Value.wrap(x.metadata), se.uint32(114).fork()).ldelim(), x.id !== "" && se.uint32(802).string(x.id), x.layoutId !== "" && se.uint32(818).string(x.layoutId), x.requestMetadata !== void 0 && k.Value.encode(k.Value.wrap(x.requestMetadata), se.uint32(810).fork()).ldelim();
      for (const Se of x.requestAnimation)
        a.LayerAnimation.encode(Se, se.uint32(826).fork()).ldelim();
      return se;
    },
    decode(x, se) {
      const Se = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Se.len : Se.pos + se;
      const Ae = De();
      for (; Se.pos < xe; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 1:
            Ae.type = Se.string();
            break;
          case 2:
            Ae.data = k.Struct.unwrap(k.Struct.decode(Se, Se.uint32()));
            break;
          case 3:
            Ae.x = k.Value.unwrap(k.Value.decode(Se, Se.uint32()));
            break;
          case 4:
            Ae.y = k.Value.unwrap(k.Value.decode(Se, Se.uint32()));
            break;
          case 5:
            Ae.width = k.Value.unwrap(k.Value.decode(Se, Se.uint32()));
            break;
          case 6:
            Ae.height = k.Value.unwrap(k.Value.decode(Se, Se.uint32()));
            break;
          case 7:
            Ae.rotation = Se.double();
            break;
          case 8:
            Ae.opacity = Se.double();
            break;
          case 9:
            Ae.scale = Se.double();
            break;
          case 10:
            Ae.hidden = Se.bool();
            break;
          case 12:
            Ae.children = k.ListValue.unwrap(k.ListValue.decode(Se, Se.uint32()));
            break;
          case 14:
            Ae.metadata = k.Value.unwrap(k.Value.decode(Se, Se.uint32()));
            break;
          case 100:
            Ae.id = Se.string();
            break;
          case 102:
            Ae.layoutId = Se.string();
            break;
          case 101:
            Ae.requestMetadata = k.Value.unwrap(k.Value.decode(Se, Se.uint32()));
            break;
          case 103:
            Ae.requestAnimation.push(a.LayerAnimation.decode(Se, Se.uint32()));
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return Ae;
    },
    fromJSON(x) {
      return {
        type: Ke(x.type) ? String(x.type) : "",
        data: je(x.data) ? x.data : void 0,
        x: Ke(x == null ? void 0 : x.x) ? x.x : void 0,
        y: Ke(x == null ? void 0 : x.y) ? x.y : void 0,
        width: Ke(x == null ? void 0 : x.width) ? x.width : void 0,
        height: Ke(x == null ? void 0 : x.height) ? x.height : void 0,
        rotation: Ke(x.rotation) ? Number(x.rotation) : 0,
        opacity: Ke(x.opacity) ? Number(x.opacity) : 0,
        scale: Ke(x.scale) ? Number(x.scale) : 0,
        hidden: Ke(x.hidden) ? !!x.hidden : !1,
        children: Array.isArray(x.children) ? [...x.children] : void 0,
        metadata: Ke(x == null ? void 0 : x.metadata) ? x.metadata : void 0,
        id: Ke(x.id) ? String(x.id) : "",
        layoutId: Ke(x.layoutId) ? String(x.layoutId) : "",
        requestMetadata: Ke(x == null ? void 0 : x.requestMetadata) ? x.requestMetadata : void 0,
        requestAnimation: Array.isArray(x == null ? void 0 : x.requestAnimation) ? x.requestAnimation.map((se) => a.LayerAnimation.fromJSON(se)) : []
      };
    },
    toJSON(x) {
      const se = {};
      return x.type !== void 0 && (se.type = x.type), x.data !== void 0 && (se.data = x.data), x.x !== void 0 && (se.x = x.x), x.y !== void 0 && (se.y = x.y), x.width !== void 0 && (se.width = x.width), x.height !== void 0 && (se.height = x.height), x.rotation !== void 0 && (se.rotation = x.rotation), x.opacity !== void 0 && (se.opacity = x.opacity), x.scale !== void 0 && (se.scale = x.scale), x.hidden !== void 0 && (se.hidden = x.hidden), x.children !== void 0 && (se.children = x.children), x.metadata !== void 0 && (se.metadata = x.metadata), x.id !== void 0 && (se.id = x.id), x.layoutId !== void 0 && (se.layoutId = x.layoutId), x.requestMetadata !== void 0 && (se.requestMetadata = x.requestMetadata), x.requestAnimation ? se.requestAnimation = x.requestAnimation.map((Se) => Se ? a.LayerAnimation.toJSON(Se) : void 0) : se.requestAnimation = [], se;
    },
    fromPartial(x) {
      var se, Se, xe, Ae, Ye, et, dt, St, tt, at, kt, rt, ut, wt, nt, it;
      const bt = De();
      return bt.type = (se = x.type) !== null && se !== void 0 ? se : "", bt.data = (Se = x.data) !== null && Se !== void 0 ? Se : void 0, bt.x = (xe = x.x) !== null && xe !== void 0 ? xe : void 0, bt.y = (Ae = x.y) !== null && Ae !== void 0 ? Ae : void 0, bt.width = (Ye = x.width) !== null && Ye !== void 0 ? Ye : void 0, bt.height = (et = x.height) !== null && et !== void 0 ? et : void 0, bt.rotation = (dt = x.rotation) !== null && dt !== void 0 ? dt : 0, bt.opacity = (St = x.opacity) !== null && St !== void 0 ? St : 0, bt.scale = (tt = x.scale) !== null && tt !== void 0 ? tt : 0, bt.hidden = (at = x.hidden) !== null && at !== void 0 ? at : !1, bt.children = (kt = x.children) !== null && kt !== void 0 ? kt : void 0, bt.metadata = (rt = x.metadata) !== null && rt !== void 0 ? rt : void 0, bt.id = (ut = x.id) !== null && ut !== void 0 ? ut : "", bt.layoutId = (wt = x.layoutId) !== null && wt !== void 0 ? wt : "", bt.requestMetadata = (nt = x.requestMetadata) !== null && nt !== void 0 ? nt : void 0, bt.requestAnimation = ((it = x.requestAnimation) === null || it === void 0 ? void 0 : it.map((ot) => a.LayerAnimation.fromPartial(ot))) || [], bt;
    }
  };
  function ye() {
    return { layoutId: "", layerId: "", payload: void 0 };
  }
  a.DeleteLayerRequest = {
    encode(x, se = _.Writer.create()) {
      return x.layoutId !== "" && se.uint32(10).string(x.layoutId), x.layerId !== "" && se.uint32(18).string(x.layerId), x.payload !== void 0 && a.DeleteLayerPayload.encode(x.payload, se.uint32(26).fork()).ldelim(), se;
    },
    decode(x, se) {
      const Se = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Se.len : Se.pos + se;
      const Ae = ye();
      for (; Se.pos < xe; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 1:
            Ae.layoutId = Se.string();
            break;
          case 2:
            Ae.layerId = Se.string();
            break;
          case 3:
            Ae.payload = a.DeleteLayerPayload.decode(Se, Se.uint32());
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return Ae;
    },
    fromJSON(x) {
      return {
        layoutId: Ke(x.layoutId) ? String(x.layoutId) : "",
        layerId: Ke(x.layerId) ? String(x.layerId) : "",
        payload: Ke(x.payload) ? a.DeleteLayerPayload.fromJSON(x.payload) : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.layoutId !== void 0 && (se.layoutId = x.layoutId), x.layerId !== void 0 && (se.layerId = x.layerId), x.payload !== void 0 && (se.payload = x.payload ? a.DeleteLayerPayload.toJSON(x.payload) : void 0), se;
    },
    fromPartial(x) {
      var se, Se;
      const xe = ye();
      return xe.layoutId = (se = x.layoutId) !== null && se !== void 0 ? se : "", xe.layerId = (Se = x.layerId) !== null && Se !== void 0 ? Se : "", xe.payload = x.payload !== void 0 && x.payload !== null ? a.DeleteLayerPayload.fromPartial(x.payload) : void 0, xe;
    }
  };
  function pe() {
    return { id: "", layoutId: "", requestMetadata: void 0 };
  }
  a.DeleteLayerResponse = {
    encode(x, se = _.Writer.create()) {
      return x.id !== "" && se.uint32(10).string(x.id), x.layoutId !== "" && se.uint32(18).string(x.layoutId), x.requestMetadata !== void 0 && k.Value.encode(k.Value.wrap(x.requestMetadata), se.uint32(802).fork()).ldelim(), se;
    },
    decode(x, se) {
      const Se = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Se.len : Se.pos + se;
      const Ae = pe();
      for (; Se.pos < xe; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 1:
            Ae.id = Se.string();
            break;
          case 2:
            Ae.layoutId = Se.string();
            break;
          case 100:
            Ae.requestMetadata = k.Value.unwrap(k.Value.decode(Se, Se.uint32()));
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return Ae;
    },
    fromJSON(x) {
      return {
        id: Ke(x.id) ? String(x.id) : "",
        layoutId: Ke(x.layoutId) ? String(x.layoutId) : "",
        requestMetadata: Ke(x == null ? void 0 : x.requestMetadata) ? x.requestMetadata : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.id !== void 0 && (se.id = x.id), x.layoutId !== void 0 && (se.layoutId = x.layoutId), x.requestMetadata !== void 0 && (se.requestMetadata = x.requestMetadata), se;
    },
    fromPartial(x) {
      var se, Se, xe;
      const Ae = pe();
      return Ae.id = (se = x.id) !== null && se !== void 0 ? se : "", Ae.layoutId = (Se = x.layoutId) !== null && Se !== void 0 ? Se : "", Ae.requestMetadata = (xe = x.requestMetadata) !== null && xe !== void 0 ? xe : void 0, Ae;
    }
  };
  function Me() {
    return {
      layers: [],
      layoutId: "",
      requestMetadata: void 0,
      requestAnimationMode: Z.REQUEST_ANIMATION_MODE_UNSPECIFIED
    };
  }
  a.BatchLayerResponse = {
    encode(x, se = _.Writer.create()) {
      for (const Se of x.layers)
        a.BatchLayerResponse_BatchLayerItem.encode(Se, se.uint32(18).fork()).ldelim();
      return x.layoutId !== "" && se.uint32(26).string(x.layoutId), x.requestMetadata !== void 0 && k.Value.encode(k.Value.wrap(x.requestMetadata), se.uint32(802).fork()).ldelim(), x.requestAnimationMode !== Z.REQUEST_ANIMATION_MODE_UNSPECIFIED && se.uint32(808).int32(ne(x.requestAnimationMode)), se;
    },
    decode(x, se) {
      const Se = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Se.len : Se.pos + se;
      const Ae = Me();
      for (; Se.pos < xe; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 2:
            Ae.layers.push(a.BatchLayerResponse_BatchLayerItem.decode(Se, Se.uint32()));
            break;
          case 3:
            Ae.layoutId = Se.string();
            break;
          case 100:
            Ae.requestMetadata = k.Value.unwrap(k.Value.decode(Se, Se.uint32()));
            break;
          case 101:
            Ae.requestAnimationMode = ee(Se.int32());
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return Ae;
    },
    fromJSON(x) {
      return {
        layers: Array.isArray(x == null ? void 0 : x.layers) ? x.layers.map((se) => a.BatchLayerResponse_BatchLayerItem.fromJSON(se)) : [],
        layoutId: Ke(x.layoutId) ? String(x.layoutId) : "",
        requestMetadata: Ke(x == null ? void 0 : x.requestMetadata) ? x.requestMetadata : void 0,
        requestAnimationMode: Ke(x.requestAnimationMode) ? ee(x.requestAnimationMode) : Z.REQUEST_ANIMATION_MODE_UNSPECIFIED
      };
    },
    toJSON(x) {
      const se = {};
      return x.layers ? se.layers = x.layers.map((Se) => Se ? a.BatchLayerResponse_BatchLayerItem.toJSON(Se) : void 0) : se.layers = [], x.layoutId !== void 0 && (se.layoutId = x.layoutId), x.requestMetadata !== void 0 && (se.requestMetadata = x.requestMetadata), x.requestAnimationMode !== void 0 && (se.requestAnimationMode = X(x.requestAnimationMode)), se;
    },
    fromPartial(x) {
      var se, Se, xe, Ae;
      const Ye = Me();
      return Ye.layers = ((se = x.layers) === null || se === void 0 ? void 0 : se.map((et) => a.BatchLayerResponse_BatchLayerItem.fromPartial(et))) || [], Ye.layoutId = (Se = x.layoutId) !== null && Se !== void 0 ? Se : "", Ye.requestMetadata = (xe = x.requestMetadata) !== null && xe !== void 0 ? xe : void 0, Ye.requestAnimationMode = (Ae = x.requestAnimationMode) !== null && Ae !== void 0 ? Ae : Z.REQUEST_ANIMATION_MODE_UNSPECIFIED, Ye;
    }
  };
  function Ne() {
    return { create: void 0, update: void 0, delete: void 0 };
  }
  a.BatchLayerResponse_BatchLayerItem = {
    encode(x, se = _.Writer.create()) {
      return x.create !== void 0 && a.Layer.encode(x.create, se.uint32(10).fork()).ldelim(), x.update !== void 0 && a.Layer.encode(x.update, se.uint32(18).fork()).ldelim(), x.delete !== void 0 && a.DeleteLayerResponse.encode(x.delete, se.uint32(26).fork()).ldelim(), se;
    },
    decode(x, se) {
      const Se = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Se.len : Se.pos + se;
      const Ae = Ne();
      for (; Se.pos < xe; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 1:
            Ae.create = a.Layer.decode(Se, Se.uint32());
            break;
          case 2:
            Ae.update = a.Layer.decode(Se, Se.uint32());
            break;
          case 3:
            Ae.delete = a.DeleteLayerResponse.decode(Se, Se.uint32());
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return Ae;
    },
    fromJSON(x) {
      return {
        create: Ke(x.create) ? a.Layer.fromJSON(x.create) : void 0,
        update: Ke(x.update) ? a.Layer.fromJSON(x.update) : void 0,
        delete: Ke(x.delete) ? a.DeleteLayerResponse.fromJSON(x.delete) : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.create !== void 0 && (se.create = x.create ? a.Layer.toJSON(x.create) : void 0), x.update !== void 0 && (se.update = x.update ? a.Layer.toJSON(x.update) : void 0), x.delete !== void 0 && (se.delete = x.delete ? a.DeleteLayerResponse.toJSON(x.delete) : void 0), se;
    },
    fromPartial(x) {
      const se = Ne();
      return se.create = x.create !== void 0 && x.create !== null ? a.Layer.fromPartial(x.create) : void 0, se.update = x.update !== void 0 && x.update !== null ? a.Layer.fromPartial(x.update) : void 0, se.delete = x.delete !== void 0 && x.delete !== null ? a.DeleteLayerResponse.fromPartial(x.delete) : void 0, se;
    }
  };
  function Ue() {
    return {
      width: void 0,
      height: void 0,
      metadata: void 0,
      projectId: void 0,
      collectionId: void 0,
      type: void 0,
      transitions: [],
      requestMetadata: void 0
    };
  }
  a.PartialLayout = {
    encode(x, se = _.Writer.create()) {
      x.width !== void 0 && se.uint32(16).int32(x.width), x.height !== void 0 && se.uint32(24).int32(x.height), x.metadata !== void 0 && k.Value.encode(k.Value.wrap(x.metadata), se.uint32(50).fork()).ldelim(), x.projectId !== void 0 && se.uint32(58).string(x.projectId), x.collectionId !== void 0 && se.uint32(66).string(x.collectionId), x.type !== void 0 && se.uint32(72).int32(H(x.type));
      for (const Se of x.transitions)
        a.Transition.encode(Se, se.uint32(82).fork()).ldelim();
      return x.requestMetadata !== void 0 && k.Value.encode(k.Value.wrap(x.requestMetadata), se.uint32(810).fork()).ldelim(), se;
    },
    decode(x, se) {
      const Se = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Se.len : Se.pos + se;
      const Ae = Ue();
      for (; Se.pos < xe; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 2:
            Ae.width = Se.int32();
            break;
          case 3:
            Ae.height = Se.int32();
            break;
          case 6:
            Ae.metadata = k.Value.unwrap(k.Value.decode(Se, Se.uint32()));
            break;
          case 7:
            Ae.projectId = Se.string();
            break;
          case 8:
            Ae.collectionId = Se.string();
            break;
          case 9:
            Ae.type = D(Se.int32());
            break;
          case 10:
            Ae.transitions.push(a.Transition.decode(Se, Se.uint32()));
            break;
          case 101:
            Ae.requestMetadata = k.Value.unwrap(k.Value.decode(Se, Se.uint32()));
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return Ae;
    },
    fromJSON(x) {
      return {
        width: Ke(x.width) ? Number(x.width) : void 0,
        height: Ke(x.height) ? Number(x.height) : void 0,
        metadata: Ke(x == null ? void 0 : x.metadata) ? x.metadata : void 0,
        projectId: Ke(x.projectId) ? String(x.projectId) : void 0,
        collectionId: Ke(x.collectionId) ? String(x.collectionId) : void 0,
        type: Ke(x.type) ? D(x.type) : void 0,
        transitions: Array.isArray(x == null ? void 0 : x.transitions) ? x.transitions.map((se) => a.Transition.fromJSON(se)) : [],
        requestMetadata: Ke(x == null ? void 0 : x.requestMetadata) ? x.requestMetadata : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.width !== void 0 && (se.width = Math.round(x.width)), x.height !== void 0 && (se.height = Math.round(x.height)), x.metadata !== void 0 && (se.metadata = x.metadata), x.projectId !== void 0 && (se.projectId = x.projectId), x.collectionId !== void 0 && (se.collectionId = x.collectionId), x.type !== void 0 && (se.type = x.type !== void 0 ? F(x.type) : void 0), x.transitions ? se.transitions = x.transitions.map((Se) => Se ? a.Transition.toJSON(Se) : void 0) : se.transitions = [], x.requestMetadata !== void 0 && (se.requestMetadata = x.requestMetadata), se;
    },
    fromPartial(x) {
      var se, Se, xe, Ae, Ye, et, dt, St;
      const tt = Ue();
      return tt.width = (se = x.width) !== null && se !== void 0 ? se : void 0, tt.height = (Se = x.height) !== null && Se !== void 0 ? Se : void 0, tt.metadata = (xe = x.metadata) !== null && xe !== void 0 ? xe : void 0, tt.projectId = (Ae = x.projectId) !== null && Ae !== void 0 ? Ae : void 0, tt.collectionId = (Ye = x.collectionId) !== null && Ye !== void 0 ? Ye : void 0, tt.type = (et = x.type) !== null && et !== void 0 ? et : void 0, tt.transitions = ((dt = x.transitions) === null || dt === void 0 ? void 0 : dt.map((at) => a.Transition.fromPartial(at))) || [], tt.requestMetadata = (St = x.requestMetadata) !== null && St !== void 0 ? St : void 0, tt;
    }
  };
  function oe() {
    return { projectId: void 0, collectionId: void 0, type: void 0 };
  }
  a.ListLayoutsRequest = {
    encode(x, se = _.Writer.create()) {
      return x.projectId !== void 0 && se.uint32(10).string(x.projectId), x.collectionId !== void 0 && se.uint32(18).string(x.collectionId), x.type !== void 0 && se.uint32(24).int32(H(x.type)), se;
    },
    decode(x, se) {
      const Se = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Se.len : Se.pos + se;
      const Ae = oe();
      for (; Se.pos < xe; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 1:
            Ae.projectId = Se.string();
            break;
          case 2:
            Ae.collectionId = Se.string();
            break;
          case 3:
            Ae.type = D(Se.int32());
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return Ae;
    },
    fromJSON(x) {
      return {
        projectId: Ke(x.projectId) ? String(x.projectId) : void 0,
        collectionId: Ke(x.collectionId) ? String(x.collectionId) : void 0,
        type: Ke(x.type) ? D(x.type) : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.projectId !== void 0 && (se.projectId = x.projectId), x.collectionId !== void 0 && (se.collectionId = x.collectionId), x.type !== void 0 && (se.type = x.type !== void 0 ? F(x.type) : void 0), se;
    },
    fromPartial(x) {
      var se, Se, xe;
      const Ae = oe();
      return Ae.projectId = (se = x.projectId) !== null && se !== void 0 ? se : void 0, Ae.collectionId = (Se = x.collectionId) !== null && Se !== void 0 ? Se : void 0, Ae.type = (xe = x.type) !== null && xe !== void 0 ? xe : void 0, Ae;
    }
  };
  function A() {
    return { layouts: [] };
  }
  a.ListLayoutsResponse = {
    encode(x, se = _.Writer.create()) {
      for (const Se of x.layouts)
        a.Layout.encode(Se, se.uint32(10).fork()).ldelim();
      return se;
    },
    decode(x, se) {
      const Se = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Se.len : Se.pos + se;
      const Ae = A();
      for (; Se.pos < xe; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 1:
            Ae.layouts.push(a.Layout.decode(Se, Se.uint32()));
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return Ae;
    },
    fromJSON(x) {
      return {
        layouts: Array.isArray(x == null ? void 0 : x.layouts) ? x.layouts.map((se) => a.Layout.fromJSON(se)) : []
      };
    },
    toJSON(x) {
      const se = {};
      return x.layouts ? se.layouts = x.layouts.map((Se) => Se ? a.Layout.toJSON(Se) : void 0) : se.layouts = [], se;
    },
    fromPartial(x) {
      var se;
      const Se = A();
      return Se.layouts = ((se = x.layouts) === null || se === void 0 ? void 0 : se.map((xe) => a.Layout.fromPartial(xe))) || [], Se;
    }
  };
  function re() {
    return { layout: void 0 };
  }
  a.CreateLayoutRequest = {
    encode(x, se = _.Writer.create()) {
      return x.layout !== void 0 && a.PartialLayout.encode(x.layout, se.uint32(18).fork()).ldelim(), se;
    },
    decode(x, se) {
      const Se = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Se.len : Se.pos + se;
      const Ae = re();
      for (; Se.pos < xe; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 2:
            Ae.layout = a.PartialLayout.decode(Se, Se.uint32());
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return Ae;
    },
    fromJSON(x) {
      return {
        layout: Ke(x.layout) ? a.PartialLayout.fromJSON(x.layout) : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.layout !== void 0 && (se.layout = x.layout ? a.PartialLayout.toJSON(x.layout) : void 0), se;
    },
    fromPartial(x) {
      const se = re();
      return se.layout = x.layout !== void 0 && x.layout !== null ? a.PartialLayout.fromPartial(x.layout) : void 0, se;
    }
  };
  function le() {
    return { layoutId: "" };
  }
  a.GetLayoutRequest = {
    encode(x, se = _.Writer.create()) {
      return x.layoutId !== "" && se.uint32(10).string(x.layoutId), se;
    },
    decode(x, se) {
      const Se = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Se.len : Se.pos + se;
      const Ae = le();
      for (; Se.pos < xe; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 1:
            Ae.layoutId = Se.string();
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return Ae;
    },
    fromJSON(x) {
      return {
        layoutId: Ke(x.layoutId) ? String(x.layoutId) : ""
      };
    },
    toJSON(x) {
      const se = {};
      return x.layoutId !== void 0 && (se.layoutId = x.layoutId), se;
    },
    fromPartial(x) {
      var se;
      const Se = le();
      return Se.layoutId = (se = x.layoutId) !== null && se !== void 0 ? se : "", Se;
    }
  };
  function $e() {
    return { layoutId: "", layout: void 0 };
  }
  a.UpdateLayoutRequest = {
    encode(x, se = _.Writer.create()) {
      return x.layoutId !== "" && se.uint32(10).string(x.layoutId), x.layout !== void 0 && a.PartialLayout.encode(x.layout, se.uint32(26).fork()).ldelim(), se;
    },
    decode(x, se) {
      const Se = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Se.len : Se.pos + se;
      const Ae = $e();
      for (; Se.pos < xe; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 1:
            Ae.layoutId = Se.string();
            break;
          case 3:
            Ae.layout = a.PartialLayout.decode(Se, Se.uint32());
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return Ae;
    },
    fromJSON(x) {
      return {
        layoutId: Ke(x.layoutId) ? String(x.layoutId) : "",
        layout: Ke(x.layout) ? a.PartialLayout.fromJSON(x.layout) : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.layoutId !== void 0 && (se.layoutId = x.layoutId), x.layout !== void 0 && (se.layout = x.layout ? a.PartialLayout.toJSON(x.layout) : void 0), se;
    },
    fromPartial(x) {
      var se;
      const Se = $e();
      return Se.layoutId = (se = x.layoutId) !== null && se !== void 0 ? se : "", Se.layout = x.layout !== void 0 && x.layout !== null ? a.PartialLayout.fromPartial(x.layout) : void 0, Se;
    }
  };
  function Oe() {
    return { requestMetadata: void 0 };
  }
  a.DeleteLayoutPayload = {
    encode(x, se = _.Writer.create()) {
      return x.requestMetadata !== void 0 && k.Value.encode(k.Value.wrap(x.requestMetadata), se.uint32(802).fork()).ldelim(), se;
    },
    decode(x, se) {
      const Se = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Se.len : Se.pos + se;
      const Ae = Oe();
      for (; Se.pos < xe; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 100:
            Ae.requestMetadata = k.Value.unwrap(k.Value.decode(Se, Se.uint32()));
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return Ae;
    },
    fromJSON(x) {
      return {
        requestMetadata: Ke(x == null ? void 0 : x.requestMetadata) ? x.requestMetadata : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.requestMetadata !== void 0 && (se.requestMetadata = x.requestMetadata), se;
    },
    fromPartial(x) {
      var se;
      const Se = Oe();
      return Se.requestMetadata = (se = x.requestMetadata) !== null && se !== void 0 ? se : void 0, Se;
    }
  };
  function Fe() {
    return { layoutId: "", payload: void 0 };
  }
  a.DeleteLayoutRequest = {
    encode(x, se = _.Writer.create()) {
      return x.layoutId !== "" && se.uint32(10).string(x.layoutId), x.payload !== void 0 && a.DeleteLayoutPayload.encode(x.payload, se.uint32(18).fork()).ldelim(), se;
    },
    decode(x, se) {
      const Se = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Se.len : Se.pos + se;
      const Ae = Fe();
      for (; Se.pos < xe; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 1:
            Ae.layoutId = Se.string();
            break;
          case 2:
            Ae.payload = a.DeleteLayoutPayload.decode(Se, Se.uint32());
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return Ae;
    },
    fromJSON(x) {
      return {
        layoutId: Ke(x.layoutId) ? String(x.layoutId) : "",
        payload: Ke(x.payload) ? a.DeleteLayoutPayload.fromJSON(x.payload) : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.layoutId !== void 0 && (se.layoutId = x.layoutId), x.payload !== void 0 && (se.payload = x.payload ? a.DeleteLayoutPayload.toJSON(x.payload) : void 0), se;
    },
    fromPartial(x) {
      var se;
      const Se = Fe();
      return Se.layoutId = (se = x.layoutId) !== null && se !== void 0 ? se : "", Se.payload = x.payload !== void 0 && x.payload !== null ? a.DeleteLayoutPayload.fromPartial(x.payload) : void 0, Se;
    }
  };
  function Ze() {
    return { id: "", requestMetadata: void 0 };
  }
  a.DeleteLayoutResponse = {
    encode(x, se = _.Writer.create()) {
      return x.id !== "" && se.uint32(18).string(x.id), x.requestMetadata !== void 0 && k.Value.encode(k.Value.wrap(x.requestMetadata), se.uint32(802).fork()).ldelim(), se;
    },
    decode(x, se) {
      const Se = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Se.len : Se.pos + se;
      const Ae = Ze();
      for (; Se.pos < xe; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 2:
            Ae.id = Se.string();
            break;
          case 100:
            Ae.requestMetadata = k.Value.unwrap(k.Value.decode(Se, Se.uint32()));
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return Ae;
    },
    fromJSON(x) {
      return {
        id: Ke(x.id) ? String(x.id) : "",
        requestMetadata: Ke(x == null ? void 0 : x.requestMetadata) ? x.requestMetadata : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.id !== void 0 && (se.id = x.id), x.requestMetadata !== void 0 && (se.requestMetadata = x.requestMetadata), se;
    },
    fromPartial(x) {
      var se, Se;
      const xe = Ze();
      return xe.id = (se = x.id) !== null && se !== void 0 ? se : "", xe.requestMetadata = (Se = x.requestMetadata) !== null && Se !== void 0 ? Se : void 0, xe;
    }
  };
  function qe() {
    return {
      properties: [],
      durationMs: 0,
      delayMs: void 0,
      easingMode: void 0
    };
  }
  a.LayerAnimation = {
    encode(x, se = _.Writer.create()) {
      for (const Se of x.properties)
        se.uint32(10).string(Se);
      return x.durationMs !== 0 && se.uint32(16).int32(x.durationMs), x.delayMs !== void 0 && se.uint32(32).int32(x.delayMs), x.easingMode !== void 0 && se.uint32(42).string(x.easingMode), se;
    },
    decode(x, se) {
      const Se = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Se.len : Se.pos + se;
      const Ae = qe();
      for (; Se.pos < xe; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 1:
            Ae.properties.push(Se.string());
            break;
          case 2:
            Ae.durationMs = Se.int32();
            break;
          case 4:
            Ae.delayMs = Se.int32();
            break;
          case 5:
            Ae.easingMode = Se.string();
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return Ae;
    },
    fromJSON(x) {
      return {
        properties: Array.isArray(x == null ? void 0 : x.properties) ? x.properties.map((se) => String(se)) : [],
        durationMs: Ke(x.durationMs) ? Number(x.durationMs) : 0,
        delayMs: Ke(x.delayMs) ? Number(x.delayMs) : void 0,
        easingMode: Ke(x.easingMode) ? String(x.easingMode) : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.properties ? se.properties = x.properties.map((Se) => Se) : se.properties = [], x.durationMs !== void 0 && (se.durationMs = Math.round(x.durationMs)), x.delayMs !== void 0 && (se.delayMs = Math.round(x.delayMs)), x.easingMode !== void 0 && (se.easingMode = x.easingMode), se;
    },
    fromPartial(x) {
      var se, Se, xe, Ae;
      const Ye = qe();
      return Ye.properties = ((se = x.properties) === null || se === void 0 ? void 0 : se.map((et) => et)) || [], Ye.durationMs = (Se = x.durationMs) !== null && Se !== void 0 ? Se : 0, Ye.delayMs = (xe = x.delayMs) !== null && xe !== void 0 ? xe : void 0, Ye.easingMode = (Ae = x.easingMode) !== null && Ae !== void 0 ? Ae : void 0, Ye;
    }
  };
  function yt() {
    return {
      type: void 0,
      data: void 0,
      x: void 0,
      y: void 0,
      width: void 0,
      height: void 0,
      rotation: void 0,
      opacity: void 0,
      scale: void 0,
      hidden: void 0,
      children: void 0,
      parentId: void 0,
      metadata: void 0,
      requestMetadata: void 0,
      requestAnimation: []
    };
  }
  a.PartialLayer = {
    encode(x, se = _.Writer.create()) {
      x.type !== void 0 && se.uint32(10).string(x.type), x.data !== void 0 && k.Struct.encode(k.Struct.wrap(x.data), se.uint32(18).fork()).ldelim(), x.x !== void 0 && k.Value.encode(k.Value.wrap(x.x), se.uint32(26).fork()).ldelim(), x.y !== void 0 && k.Value.encode(k.Value.wrap(x.y), se.uint32(34).fork()).ldelim(), x.width !== void 0 && k.Value.encode(k.Value.wrap(x.width), se.uint32(42).fork()).ldelim(), x.height !== void 0 && k.Value.encode(k.Value.wrap(x.height), se.uint32(50).fork()).ldelim(), x.rotation !== void 0 && se.uint32(57).double(x.rotation), x.opacity !== void 0 && se.uint32(65).double(x.opacity), x.scale !== void 0 && se.uint32(73).double(x.scale), x.hidden !== void 0 && se.uint32(80).bool(x.hidden), x.children !== void 0 && k.ListValue.encode(k.ListValue.wrap(x.children), se.uint32(98).fork()).ldelim(), x.parentId !== void 0 && se.uint32(106).string(x.parentId), x.metadata !== void 0 && k.Value.encode(k.Value.wrap(x.metadata), se.uint32(114).fork()).ldelim(), x.requestMetadata !== void 0 && k.Value.encode(k.Value.wrap(x.requestMetadata), se.uint32(802).fork()).ldelim();
      for (const Se of x.requestAnimation)
        a.LayerAnimation.encode(Se, se.uint32(826).fork()).ldelim();
      return se;
    },
    decode(x, se) {
      const Se = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Se.len : Se.pos + se;
      const Ae = yt();
      for (; Se.pos < xe; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 1:
            Ae.type = Se.string();
            break;
          case 2:
            Ae.data = k.Struct.unwrap(k.Struct.decode(Se, Se.uint32()));
            break;
          case 3:
            Ae.x = k.Value.unwrap(k.Value.decode(Se, Se.uint32()));
            break;
          case 4:
            Ae.y = k.Value.unwrap(k.Value.decode(Se, Se.uint32()));
            break;
          case 5:
            Ae.width = k.Value.unwrap(k.Value.decode(Se, Se.uint32()));
            break;
          case 6:
            Ae.height = k.Value.unwrap(k.Value.decode(Se, Se.uint32()));
            break;
          case 7:
            Ae.rotation = Se.double();
            break;
          case 8:
            Ae.opacity = Se.double();
            break;
          case 9:
            Ae.scale = Se.double();
            break;
          case 10:
            Ae.hidden = Se.bool();
            break;
          case 12:
            Ae.children = k.ListValue.unwrap(k.ListValue.decode(Se, Se.uint32()));
            break;
          case 13:
            Ae.parentId = Se.string();
            break;
          case 14:
            Ae.metadata = k.Value.unwrap(k.Value.decode(Se, Se.uint32()));
            break;
          case 100:
            Ae.requestMetadata = k.Value.unwrap(k.Value.decode(Se, Se.uint32()));
            break;
          case 103:
            Ae.requestAnimation.push(a.LayerAnimation.decode(Se, Se.uint32()));
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return Ae;
    },
    fromJSON(x) {
      return {
        type: Ke(x.type) ? String(x.type) : void 0,
        data: je(x.data) ? x.data : void 0,
        x: Ke(x == null ? void 0 : x.x) ? x.x : void 0,
        y: Ke(x == null ? void 0 : x.y) ? x.y : void 0,
        width: Ke(x == null ? void 0 : x.width) ? x.width : void 0,
        height: Ke(x == null ? void 0 : x.height) ? x.height : void 0,
        rotation: Ke(x.rotation) ? Number(x.rotation) : void 0,
        opacity: Ke(x.opacity) ? Number(x.opacity) : void 0,
        scale: Ke(x.scale) ? Number(x.scale) : void 0,
        hidden: Ke(x.hidden) ? !!x.hidden : void 0,
        children: Array.isArray(x.children) ? [...x.children] : void 0,
        parentId: Ke(x.parentId) ? String(x.parentId) : void 0,
        metadata: Ke(x == null ? void 0 : x.metadata) ? x.metadata : void 0,
        requestMetadata: Ke(x == null ? void 0 : x.requestMetadata) ? x.requestMetadata : void 0,
        requestAnimation: Array.isArray(x == null ? void 0 : x.requestAnimation) ? x.requestAnimation.map((se) => a.LayerAnimation.fromJSON(se)) : []
      };
    },
    toJSON(x) {
      const se = {};
      return x.type !== void 0 && (se.type = x.type), x.data !== void 0 && (se.data = x.data), x.x !== void 0 && (se.x = x.x), x.y !== void 0 && (se.y = x.y), x.width !== void 0 && (se.width = x.width), x.height !== void 0 && (se.height = x.height), x.rotation !== void 0 && (se.rotation = x.rotation), x.opacity !== void 0 && (se.opacity = x.opacity), x.scale !== void 0 && (se.scale = x.scale), x.hidden !== void 0 && (se.hidden = x.hidden), x.children !== void 0 && (se.children = x.children), x.parentId !== void 0 && (se.parentId = x.parentId), x.metadata !== void 0 && (se.metadata = x.metadata), x.requestMetadata !== void 0 && (se.requestMetadata = x.requestMetadata), x.requestAnimation ? se.requestAnimation = x.requestAnimation.map((Se) => Se ? a.LayerAnimation.toJSON(Se) : void 0) : se.requestAnimation = [], se;
    },
    fromPartial(x) {
      var se, Se, xe, Ae, Ye, et, dt, St, tt, at, kt, rt, ut, wt, nt;
      const it = yt();
      return it.type = (se = x.type) !== null && se !== void 0 ? se : void 0, it.data = (Se = x.data) !== null && Se !== void 0 ? Se : void 0, it.x = (xe = x.x) !== null && xe !== void 0 ? xe : void 0, it.y = (Ae = x.y) !== null && Ae !== void 0 ? Ae : void 0, it.width = (Ye = x.width) !== null && Ye !== void 0 ? Ye : void 0, it.height = (et = x.height) !== null && et !== void 0 ? et : void 0, it.rotation = (dt = x.rotation) !== null && dt !== void 0 ? dt : void 0, it.opacity = (St = x.opacity) !== null && St !== void 0 ? St : void 0, it.scale = (tt = x.scale) !== null && tt !== void 0 ? tt : void 0, it.hidden = (at = x.hidden) !== null && at !== void 0 ? at : void 0, it.children = (kt = x.children) !== null && kt !== void 0 ? kt : void 0, it.parentId = (rt = x.parentId) !== null && rt !== void 0 ? rt : void 0, it.metadata = (ut = x.metadata) !== null && ut !== void 0 ? ut : void 0, it.requestMetadata = (wt = x.requestMetadata) !== null && wt !== void 0 ? wt : void 0, it.requestAnimation = ((nt = x.requestAnimation) === null || nt === void 0 ? void 0 : nt.map((bt) => a.LayerAnimation.fromPartial(bt))) || [], it;
    }
  };
  function Xe() {
    return {
      id: "",
      type: void 0,
      data: void 0,
      x: void 0,
      y: void 0,
      width: void 0,
      height: void 0,
      rotation: void 0,
      opacity: void 0,
      scale: void 0,
      hidden: void 0,
      children: void 0,
      parentId: void 0,
      metadata: void 0,
      requestMetadata: void 0,
      requestAnimation: []
    };
  }
  a.PartialLayerWithID = {
    encode(x, se = _.Writer.create()) {
      x.id !== "" && se.uint32(8002).string(x.id), x.type !== void 0 && se.uint32(10).string(x.type), x.data !== void 0 && k.Struct.encode(k.Struct.wrap(x.data), se.uint32(18).fork()).ldelim(), x.x !== void 0 && k.Value.encode(k.Value.wrap(x.x), se.uint32(26).fork()).ldelim(), x.y !== void 0 && k.Value.encode(k.Value.wrap(x.y), se.uint32(34).fork()).ldelim(), x.width !== void 0 && k.Value.encode(k.Value.wrap(x.width), se.uint32(42).fork()).ldelim(), x.height !== void 0 && k.Value.encode(k.Value.wrap(x.height), se.uint32(50).fork()).ldelim(), x.rotation !== void 0 && se.uint32(57).double(x.rotation), x.opacity !== void 0 && se.uint32(65).double(x.opacity), x.scale !== void 0 && se.uint32(73).double(x.scale), x.hidden !== void 0 && se.uint32(80).bool(x.hidden), x.children !== void 0 && k.ListValue.encode(k.ListValue.wrap(x.children), se.uint32(98).fork()).ldelim(), x.parentId !== void 0 && se.uint32(106).string(x.parentId), x.metadata !== void 0 && k.Value.encode(k.Value.wrap(x.metadata), se.uint32(114).fork()).ldelim(), x.requestMetadata !== void 0 && k.Value.encode(k.Value.wrap(x.requestMetadata), se.uint32(802).fork()).ldelim();
      for (const Se of x.requestAnimation)
        a.LayerAnimation.encode(Se, se.uint32(826).fork()).ldelim();
      return se;
    },
    decode(x, se) {
      const Se = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Se.len : Se.pos + se;
      const Ae = Xe();
      for (; Se.pos < xe; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 1e3:
            Ae.id = Se.string();
            break;
          case 1:
            Ae.type = Se.string();
            break;
          case 2:
            Ae.data = k.Struct.unwrap(k.Struct.decode(Se, Se.uint32()));
            break;
          case 3:
            Ae.x = k.Value.unwrap(k.Value.decode(Se, Se.uint32()));
            break;
          case 4:
            Ae.y = k.Value.unwrap(k.Value.decode(Se, Se.uint32()));
            break;
          case 5:
            Ae.width = k.Value.unwrap(k.Value.decode(Se, Se.uint32()));
            break;
          case 6:
            Ae.height = k.Value.unwrap(k.Value.decode(Se, Se.uint32()));
            break;
          case 7:
            Ae.rotation = Se.double();
            break;
          case 8:
            Ae.opacity = Se.double();
            break;
          case 9:
            Ae.scale = Se.double();
            break;
          case 10:
            Ae.hidden = Se.bool();
            break;
          case 12:
            Ae.children = k.ListValue.unwrap(k.ListValue.decode(Se, Se.uint32()));
            break;
          case 13:
            Ae.parentId = Se.string();
            break;
          case 14:
            Ae.metadata = k.Value.unwrap(k.Value.decode(Se, Se.uint32()));
            break;
          case 100:
            Ae.requestMetadata = k.Value.unwrap(k.Value.decode(Se, Se.uint32()));
            break;
          case 103:
            Ae.requestAnimation.push(a.LayerAnimation.decode(Se, Se.uint32()));
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return Ae;
    },
    fromJSON(x) {
      return {
        id: Ke(x.id) ? String(x.id) : "",
        type: Ke(x.type) ? String(x.type) : void 0,
        data: je(x.data) ? x.data : void 0,
        x: Ke(x == null ? void 0 : x.x) ? x.x : void 0,
        y: Ke(x == null ? void 0 : x.y) ? x.y : void 0,
        width: Ke(x == null ? void 0 : x.width) ? x.width : void 0,
        height: Ke(x == null ? void 0 : x.height) ? x.height : void 0,
        rotation: Ke(x.rotation) ? Number(x.rotation) : void 0,
        opacity: Ke(x.opacity) ? Number(x.opacity) : void 0,
        scale: Ke(x.scale) ? Number(x.scale) : void 0,
        hidden: Ke(x.hidden) ? !!x.hidden : void 0,
        children: Array.isArray(x.children) ? [...x.children] : void 0,
        parentId: Ke(x.parentId) ? String(x.parentId) : void 0,
        metadata: Ke(x == null ? void 0 : x.metadata) ? x.metadata : void 0,
        requestMetadata: Ke(x == null ? void 0 : x.requestMetadata) ? x.requestMetadata : void 0,
        requestAnimation: Array.isArray(x == null ? void 0 : x.requestAnimation) ? x.requestAnimation.map((se) => a.LayerAnimation.fromJSON(se)) : []
      };
    },
    toJSON(x) {
      const se = {};
      return x.id !== void 0 && (se.id = x.id), x.type !== void 0 && (se.type = x.type), x.data !== void 0 && (se.data = x.data), x.x !== void 0 && (se.x = x.x), x.y !== void 0 && (se.y = x.y), x.width !== void 0 && (se.width = x.width), x.height !== void 0 && (se.height = x.height), x.rotation !== void 0 && (se.rotation = x.rotation), x.opacity !== void 0 && (se.opacity = x.opacity), x.scale !== void 0 && (se.scale = x.scale), x.hidden !== void 0 && (se.hidden = x.hidden), x.children !== void 0 && (se.children = x.children), x.parentId !== void 0 && (se.parentId = x.parentId), x.metadata !== void 0 && (se.metadata = x.metadata), x.requestMetadata !== void 0 && (se.requestMetadata = x.requestMetadata), x.requestAnimation ? se.requestAnimation = x.requestAnimation.map((Se) => Se ? a.LayerAnimation.toJSON(Se) : void 0) : se.requestAnimation = [], se;
    },
    fromPartial(x) {
      var se, Se, xe, Ae, Ye, et, dt, St, tt, at, kt, rt, ut, wt, nt, it;
      const bt = Xe();
      return bt.id = (se = x.id) !== null && se !== void 0 ? se : "", bt.type = (Se = x.type) !== null && Se !== void 0 ? Se : void 0, bt.data = (xe = x.data) !== null && xe !== void 0 ? xe : void 0, bt.x = (Ae = x.x) !== null && Ae !== void 0 ? Ae : void 0, bt.y = (Ye = x.y) !== null && Ye !== void 0 ? Ye : void 0, bt.width = (et = x.width) !== null && et !== void 0 ? et : void 0, bt.height = (dt = x.height) !== null && dt !== void 0 ? dt : void 0, bt.rotation = (St = x.rotation) !== null && St !== void 0 ? St : void 0, bt.opacity = (tt = x.opacity) !== null && tt !== void 0 ? tt : void 0, bt.scale = (at = x.scale) !== null && at !== void 0 ? at : void 0, bt.hidden = (kt = x.hidden) !== null && kt !== void 0 ? kt : void 0, bt.children = (rt = x.children) !== null && rt !== void 0 ? rt : void 0, bt.parentId = (ut = x.parentId) !== null && ut !== void 0 ? ut : void 0, bt.metadata = (wt = x.metadata) !== null && wt !== void 0 ? wt : void 0, bt.requestMetadata = (nt = x.requestMetadata) !== null && nt !== void 0 ? nt : void 0, bt.requestAnimation = ((it = x.requestAnimation) === null || it === void 0 ? void 0 : it.map((ot) => a.LayerAnimation.fromPartial(ot))) || [], bt;
    }
  };
  function Ge() {
    return { layoutId: "" };
  }
  a.ListLayersRequest = {
    encode(x, se = _.Writer.create()) {
      return x.layoutId !== "" && se.uint32(10).string(x.layoutId), se;
    },
    decode(x, se) {
      const Se = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Se.len : Se.pos + se;
      const Ae = Ge();
      for (; Se.pos < xe; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 1:
            Ae.layoutId = Se.string();
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return Ae;
    },
    fromJSON(x) {
      return {
        layoutId: Ke(x.layoutId) ? String(x.layoutId) : ""
      };
    },
    toJSON(x) {
      const se = {};
      return x.layoutId !== void 0 && (se.layoutId = x.layoutId), se;
    },
    fromPartial(x) {
      var se;
      const Se = Ge();
      return Se.layoutId = (se = x.layoutId) !== null && se !== void 0 ? se : "", Se;
    }
  };
  function J() {
    return { layers: [] };
  }
  a.ListLayersResponse = {
    encode(x, se = _.Writer.create()) {
      for (const Se of x.layers)
        a.Layer.encode(Se, se.uint32(10).fork()).ldelim();
      return se;
    },
    decode(x, se) {
      const Se = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Se.len : Se.pos + se;
      const Ae = J();
      for (; Se.pos < xe; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 1:
            Ae.layers.push(a.Layer.decode(Se, Se.uint32()));
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return Ae;
    },
    fromJSON(x) {
      return {
        layers: Array.isArray(x == null ? void 0 : x.layers) ? x.layers.map((se) => a.Layer.fromJSON(se)) : []
      };
    },
    toJSON(x) {
      const se = {};
      return x.layers ? se.layers = x.layers.map((Se) => Se ? a.Layer.toJSON(Se) : void 0) : se.layers = [], se;
    },
    fromPartial(x) {
      var se;
      const Se = J();
      return Se.layers = ((se = x.layers) === null || se === void 0 ? void 0 : se.map((xe) => a.Layer.fromPartial(xe))) || [], Se;
    }
  };
  function ge() {
    return { layoutId: "", layer: void 0 };
  }
  a.CreateLayerRequest = {
    encode(x, se = _.Writer.create()) {
      return x.layoutId !== "" && se.uint32(10).string(x.layoutId), x.layer !== void 0 && a.PartialLayer.encode(x.layer, se.uint32(18).fork()).ldelim(), se;
    },
    decode(x, se) {
      const Se = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Se.len : Se.pos + se;
      const Ae = ge();
      for (; Se.pos < xe; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 1:
            Ae.layoutId = Se.string();
            break;
          case 2:
            Ae.layer = a.PartialLayer.decode(Se, Se.uint32());
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return Ae;
    },
    fromJSON(x) {
      return {
        layoutId: Ke(x.layoutId) ? String(x.layoutId) : "",
        layer: Ke(x.layer) ? a.PartialLayer.fromJSON(x.layer) : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.layoutId !== void 0 && (se.layoutId = x.layoutId), x.layer !== void 0 && (se.layer = x.layer ? a.PartialLayer.toJSON(x.layer) : void 0), se;
    },
    fromPartial(x) {
      var se;
      const Se = ge();
      return Se.layoutId = (se = x.layoutId) !== null && se !== void 0 ? se : "", Se.layer = x.layer !== void 0 && x.layer !== null ? a.PartialLayer.fromPartial(x.layer) : void 0, Se;
    }
  };
  function we() {
    return { layoutId: "", layerId: "" };
  }
  a.GetLayerRequest = {
    encode(x, se = _.Writer.create()) {
      return x.layoutId !== "" && se.uint32(10).string(x.layoutId), x.layerId !== "" && se.uint32(18).string(x.layerId), se;
    },
    decode(x, se) {
      const Se = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Se.len : Se.pos + se;
      const Ae = we();
      for (; Se.pos < xe; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 1:
            Ae.layoutId = Se.string();
            break;
          case 2:
            Ae.layerId = Se.string();
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return Ae;
    },
    fromJSON(x) {
      return {
        layoutId: Ke(x.layoutId) ? String(x.layoutId) : "",
        layerId: Ke(x.layerId) ? String(x.layerId) : ""
      };
    },
    toJSON(x) {
      const se = {};
      return x.layoutId !== void 0 && (se.layoutId = x.layoutId), x.layerId !== void 0 && (se.layerId = x.layerId), se;
    },
    fromPartial(x) {
      var se, Se;
      const xe = we();
      return xe.layoutId = (se = x.layoutId) !== null && se !== void 0 ? se : "", xe.layerId = (Se = x.layerId) !== null && Se !== void 0 ? Se : "", xe;
    }
  };
  function We() {
    return { layoutId: "", layerId: "", layer: void 0 };
  }
  a.UpdateLayerRequest = {
    encode(x, se = _.Writer.create()) {
      return x.layoutId !== "" && se.uint32(10).string(x.layoutId), x.layerId !== "" && se.uint32(18).string(x.layerId), x.layer !== void 0 && a.PartialLayer.encode(x.layer, se.uint32(26).fork()).ldelim(), se;
    },
    decode(x, se) {
      const Se = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Se.len : Se.pos + se;
      const Ae = We();
      for (; Se.pos < xe; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 1:
            Ae.layoutId = Se.string();
            break;
          case 2:
            Ae.layerId = Se.string();
            break;
          case 3:
            Ae.layer = a.PartialLayer.decode(Se, Se.uint32());
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return Ae;
    },
    fromJSON(x) {
      return {
        layoutId: Ke(x.layoutId) ? String(x.layoutId) : "",
        layerId: Ke(x.layerId) ? String(x.layerId) : "",
        layer: Ke(x.layer) ? a.PartialLayer.fromJSON(x.layer) : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.layoutId !== void 0 && (se.layoutId = x.layoutId), x.layerId !== void 0 && (se.layerId = x.layerId), x.layer !== void 0 && (se.layer = x.layer ? a.PartialLayer.toJSON(x.layer) : void 0), se;
    },
    fromPartial(x) {
      var se, Se;
      const xe = We();
      return xe.layoutId = (se = x.layoutId) !== null && se !== void 0 ? se : "", xe.layerId = (Se = x.layerId) !== null && Se !== void 0 ? Se : "", xe.layer = x.layer !== void 0 && x.layer !== null ? a.PartialLayer.fromPartial(x.layer) : void 0, xe;
    }
  };
  function Ie() {
    return { requestMetadata: void 0 };
  }
  a.DeleteLayerPayload = {
    encode(x, se = _.Writer.create()) {
      return x.requestMetadata !== void 0 && k.Value.encode(k.Value.wrap(x.requestMetadata), se.uint32(802).fork()).ldelim(), se;
    },
    decode(x, se) {
      const Se = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Se.len : Se.pos + se;
      const Ae = Ie();
      for (; Se.pos < xe; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 100:
            Ae.requestMetadata = k.Value.unwrap(k.Value.decode(Se, Se.uint32()));
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return Ae;
    },
    fromJSON(x) {
      return {
        requestMetadata: Ke(x == null ? void 0 : x.requestMetadata) ? x.requestMetadata : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.requestMetadata !== void 0 && (se.requestMetadata = x.requestMetadata), se;
    },
    fromPartial(x) {
      var se;
      const Se = Ie();
      return Se.requestMetadata = (se = x.requestMetadata) !== null && se !== void 0 ? se : void 0, Se;
    }
  };
  function V() {
    return { id: "", requestMetadata: void 0 };
  }
  a.BatchDeleteLayerRequest = {
    encode(x, se = _.Writer.create()) {
      return x.id !== "" && se.uint32(10).string(x.id), x.requestMetadata !== void 0 && k.Value.encode(k.Value.wrap(x.requestMetadata), se.uint32(802).fork()).ldelim(), se;
    },
    decode(x, se) {
      const Se = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Se.len : Se.pos + se;
      const Ae = V();
      for (; Se.pos < xe; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 1:
            Ae.id = Se.string();
            break;
          case 100:
            Ae.requestMetadata = k.Value.unwrap(k.Value.decode(Se, Se.uint32()));
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return Ae;
    },
    fromJSON(x) {
      return {
        id: Ke(x.id) ? String(x.id) : "",
        requestMetadata: Ke(x == null ? void 0 : x.requestMetadata) ? x.requestMetadata : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.id !== void 0 && (se.id = x.id), x.requestMetadata !== void 0 && (se.requestMetadata = x.requestMetadata), se;
    },
    fromPartial(x) {
      var se, Se;
      const xe = V();
      return xe.id = (se = x.id) !== null && se !== void 0 ? se : "", xe.requestMetadata = (Se = x.requestMetadata) !== null && Se !== void 0 ? Se : void 0, xe;
    }
  };
  function Ee() {
    return {
      layoutId: "",
      layers: [],
      requestMetadata: void 0,
      requestAnimationMode: void 0
    };
  }
  a.BatchLayerRequest = {
    encode(x, se = _.Writer.create()) {
      x.layoutId !== "" && se.uint32(10).string(x.layoutId);
      for (const Se of x.layers)
        a.BatchLayerRequest_BatchItem.encode(Se, se.uint32(18).fork()).ldelim();
      return x.requestMetadata !== void 0 && k.Value.encode(k.Value.wrap(x.requestMetadata), se.uint32(802).fork()).ldelim(), x.requestAnimationMode !== void 0 && se.uint32(808).int32(ne(x.requestAnimationMode)), se;
    },
    decode(x, se) {
      const Se = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Se.len : Se.pos + se;
      const Ae = Ee();
      for (; Se.pos < xe; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 1:
            Ae.layoutId = Se.string();
            break;
          case 2:
            Ae.layers.push(a.BatchLayerRequest_BatchItem.decode(Se, Se.uint32()));
            break;
          case 100:
            Ae.requestMetadata = k.Value.unwrap(k.Value.decode(Se, Se.uint32()));
            break;
          case 101:
            Ae.requestAnimationMode = ee(Se.int32());
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return Ae;
    },
    fromJSON(x) {
      return {
        layoutId: Ke(x.layoutId) ? String(x.layoutId) : "",
        layers: Array.isArray(x == null ? void 0 : x.layers) ? x.layers.map((se) => a.BatchLayerRequest_BatchItem.fromJSON(se)) : [],
        requestMetadata: Ke(x == null ? void 0 : x.requestMetadata) ? x.requestMetadata : void 0,
        requestAnimationMode: Ke(x.requestAnimationMode) ? ee(x.requestAnimationMode) : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.layoutId !== void 0 && (se.layoutId = x.layoutId), x.layers ? se.layers = x.layers.map((Se) => Se ? a.BatchLayerRequest_BatchItem.toJSON(Se) : void 0) : se.layers = [], x.requestMetadata !== void 0 && (se.requestMetadata = x.requestMetadata), x.requestAnimationMode !== void 0 && (se.requestAnimationMode = x.requestAnimationMode !== void 0 ? X(x.requestAnimationMode) : void 0), se;
    },
    fromPartial(x) {
      var se, Se, xe, Ae;
      const Ye = Ee();
      return Ye.layoutId = (se = x.layoutId) !== null && se !== void 0 ? se : "", Ye.layers = ((Se = x.layers) === null || Se === void 0 ? void 0 : Se.map((et) => a.BatchLayerRequest_BatchItem.fromPartial(et))) || [], Ye.requestMetadata = (xe = x.requestMetadata) !== null && xe !== void 0 ? xe : void 0, Ye.requestAnimationMode = (Ae = x.requestAnimationMode) !== null && Ae !== void 0 ? Ae : void 0, Ye;
    }
  };
  function de() {
    return { create: void 0, update: void 0, delete: void 0 };
  }
  a.BatchLayerRequest_BatchItem = {
    encode(x, se = _.Writer.create()) {
      return x.create !== void 0 && a.PartialLayer.encode(x.create, se.uint32(10).fork()).ldelim(), x.update !== void 0 && a.PartialLayerWithID.encode(x.update, se.uint32(18).fork()).ldelim(), x.delete !== void 0 && a.BatchDeleteLayerRequest.encode(x.delete, se.uint32(26).fork()).ldelim(), se;
    },
    decode(x, se) {
      const Se = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Se.len : Se.pos + se;
      const Ae = de();
      for (; Se.pos < xe; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 1:
            Ae.create = a.PartialLayer.decode(Se, Se.uint32());
            break;
          case 2:
            Ae.update = a.PartialLayerWithID.decode(Se, Se.uint32());
            break;
          case 3:
            Ae.delete = a.BatchDeleteLayerRequest.decode(Se, Se.uint32());
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return Ae;
    },
    fromJSON(x) {
      return {
        create: Ke(x.create) ? a.PartialLayer.fromJSON(x.create) : void 0,
        update: Ke(x.update) ? a.PartialLayerWithID.fromJSON(x.update) : void 0,
        delete: Ke(x.delete) ? a.BatchDeleteLayerRequest.fromJSON(x.delete) : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.create !== void 0 && (se.create = x.create ? a.PartialLayer.toJSON(x.create) : void 0), x.update !== void 0 && (se.update = x.update ? a.PartialLayerWithID.toJSON(x.update) : void 0), x.delete !== void 0 && (se.delete = x.delete ? a.BatchDeleteLayerRequest.toJSON(x.delete) : void 0), se;
    },
    fromPartial(x) {
      const se = de();
      return se.create = x.create !== void 0 && x.create !== null ? a.PartialLayer.fromPartial(x.create) : void 0, se.update = x.update !== void 0 && x.update !== null ? a.PartialLayerWithID.fromPartial(x.update) : void 0, se.delete = x.delete !== void 0 && x.delete !== null ? a.BatchDeleteLayerRequest.fromPartial(x.delete) : void 0, se;
    }
  };
  function ce() {
    return { create: void 0, update: void 0, delete: void 0 };
  }
  a.LayoutEvent = {
    encode(x, se = _.Writer.create()) {
      return x.create !== void 0 && a.Layout.encode(x.create, se.uint32(10).fork()).ldelim(), x.update !== void 0 && a.Layout.encode(x.update, se.uint32(18).fork()).ldelim(), x.delete !== void 0 && a.DeleteLayoutResponse.encode(x.delete, se.uint32(26).fork()).ldelim(), se;
    },
    decode(x, se) {
      const Se = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Se.len : Se.pos + se;
      const Ae = ce();
      for (; Se.pos < xe; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 1:
            Ae.create = a.Layout.decode(Se, Se.uint32());
            break;
          case 2:
            Ae.update = a.Layout.decode(Se, Se.uint32());
            break;
          case 3:
            Ae.delete = a.DeleteLayoutResponse.decode(Se, Se.uint32());
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return Ae;
    },
    fromJSON(x) {
      return {
        create: Ke(x.create) ? a.Layout.fromJSON(x.create) : void 0,
        update: Ke(x.update) ? a.Layout.fromJSON(x.update) : void 0,
        delete: Ke(x.delete) ? a.DeleteLayoutResponse.fromJSON(x.delete) : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.create !== void 0 && (se.create = x.create ? a.Layout.toJSON(x.create) : void 0), x.update !== void 0 && (se.update = x.update ? a.Layout.toJSON(x.update) : void 0), x.delete !== void 0 && (se.delete = x.delete ? a.DeleteLayoutResponse.toJSON(x.delete) : void 0), se;
    },
    fromPartial(x) {
      const se = ce();
      return se.create = x.create !== void 0 && x.create !== null ? a.Layout.fromPartial(x.create) : void 0, se.update = x.update !== void 0 && x.update !== null ? a.Layout.fromPartial(x.update) : void 0, se.delete = x.delete !== void 0 && x.delete !== null ? a.DeleteLayoutResponse.fromPartial(x.delete) : void 0, se;
    }
  };
  function ve() {
    return {
      create: void 0,
      update: void 0,
      delete: void 0,
      batch: void 0
    };
  }
  a.LayerEvent = {
    encode(x, se = _.Writer.create()) {
      return x.create !== void 0 && a.Layer.encode(x.create, se.uint32(10).fork()).ldelim(), x.update !== void 0 && a.Layer.encode(x.update, se.uint32(18).fork()).ldelim(), x.delete !== void 0 && a.DeleteLayerResponse.encode(x.delete, se.uint32(26).fork()).ldelim(), x.batch !== void 0 && a.BatchLayerResponse.encode(x.batch, se.uint32(34).fork()).ldelim(), se;
    },
    decode(x, se) {
      const Se = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Se.len : Se.pos + se;
      const Ae = ve();
      for (; Se.pos < xe; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 1:
            Ae.create = a.Layer.decode(Se, Se.uint32());
            break;
          case 2:
            Ae.update = a.Layer.decode(Se, Se.uint32());
            break;
          case 3:
            Ae.delete = a.DeleteLayerResponse.decode(Se, Se.uint32());
            break;
          case 4:
            Ae.batch = a.BatchLayerResponse.decode(Se, Se.uint32());
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return Ae;
    },
    fromJSON(x) {
      return {
        create: Ke(x.create) ? a.Layer.fromJSON(x.create) : void 0,
        update: Ke(x.update) ? a.Layer.fromJSON(x.update) : void 0,
        delete: Ke(x.delete) ? a.DeleteLayerResponse.fromJSON(x.delete) : void 0,
        batch: Ke(x.batch) ? a.BatchLayerResponse.fromJSON(x.batch) : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.create !== void 0 && (se.create = x.create ? a.Layer.toJSON(x.create) : void 0), x.update !== void 0 && (se.update = x.update ? a.Layer.toJSON(x.update) : void 0), x.delete !== void 0 && (se.delete = x.delete ? a.DeleteLayerResponse.toJSON(x.delete) : void 0), x.batch !== void 0 && (se.batch = x.batch ? a.BatchLayerResponse.toJSON(x.batch) : void 0), se;
    },
    fromPartial(x) {
      const se = ve();
      return se.create = x.create !== void 0 && x.create !== null ? a.Layer.fromPartial(x.create) : void 0, se.update = x.update !== void 0 && x.update !== null ? a.Layer.fromPartial(x.update) : void 0, se.delete = x.delete !== void 0 && x.delete !== null ? a.DeleteLayerResponse.fromPartial(x.delete) : void 0, se.batch = x.batch !== void 0 && x.batch !== null ? a.BatchLayerResponse.fromPartial(x.batch) : void 0, se;
    }
  };
  function Pe() {
    return { layout: void 0, layer: void 0 };
  }
  a.Event = {
    encode(x, se = _.Writer.create()) {
      return x.layout !== void 0 && a.LayoutEvent.encode(x.layout, se.uint32(10).fork()).ldelim(), x.layer !== void 0 && a.LayerEvent.encode(x.layer, se.uint32(18).fork()).ldelim(), se;
    },
    decode(x, se) {
      const Se = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Se.len : Se.pos + se;
      const Ae = Pe();
      for (; Se.pos < xe; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 1:
            Ae.layout = a.LayoutEvent.decode(Se, Se.uint32());
            break;
          case 2:
            Ae.layer = a.LayerEvent.decode(Se, Se.uint32());
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return Ae;
    },
    fromJSON(x) {
      return {
        layout: Ke(x.layout) ? a.LayoutEvent.fromJSON(x.layout) : void 0,
        layer: Ke(x.layer) ? a.LayerEvent.fromJSON(x.layer) : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.layout !== void 0 && (se.layout = x.layout ? a.LayoutEvent.toJSON(x.layout) : void 0), x.layer !== void 0 && (se.layer = x.layer ? a.LayerEvent.toJSON(x.layer) : void 0), se;
    },
    fromPartial(x) {
      const se = Pe();
      return se.layout = x.layout !== void 0 && x.layout !== null ? a.LayoutEvent.fromPartial(x.layout) : void 0, se.layer = x.layer !== void 0 && x.layer !== null ? a.LayerEvent.fromPartial(x.layer) : void 0, se;
    }
  };
  class Be {
    constructor(se) {
      this.rpc = se, this.ListLayers = this.ListLayers.bind(this), this.CreateLayer = this.CreateLayer.bind(this), this.GetLayer = this.GetLayer.bind(this), this.UpdateLayer = this.UpdateLayer.bind(this), this.DeleteLayer = this.DeleteLayer.bind(this), this.Batch = this.Batch.bind(this);
    }
    ListLayers(se) {
      const Se = a.ListLayersRequest.encode(se).finish();
      return this.rpc.request("apis.layout.v2.LayerService", "ListLayers", Se).then((Ae) => a.ListLayersResponse.decode(new _.Reader(Ae)));
    }
    CreateLayer(se) {
      const Se = a.CreateLayerRequest.encode(se).finish();
      return this.rpc.request("apis.layout.v2.LayerService", "CreateLayer", Se).then((Ae) => a.Layer.decode(new _.Reader(Ae)));
    }
    GetLayer(se) {
      const Se = a.GetLayerRequest.encode(se).finish();
      return this.rpc.request("apis.layout.v2.LayerService", "GetLayer", Se).then((Ae) => a.Layer.decode(new _.Reader(Ae)));
    }
    UpdateLayer(se) {
      const Se = a.UpdateLayerRequest.encode(se).finish();
      return this.rpc.request("apis.layout.v2.LayerService", "UpdateLayer", Se).then((Ae) => a.Layer.decode(new _.Reader(Ae)));
    }
    DeleteLayer(se) {
      const Se = a.DeleteLayerRequest.encode(se).finish();
      return this.rpc.request("apis.layout.v2.LayerService", "DeleteLayer", Se).then((Ae) => a.DeleteLayerResponse.decode(new _.Reader(Ae)));
    }
    Batch(se) {
      const Se = a.BatchLayerRequest.encode(se).finish();
      return this.rpc.request("apis.layout.v2.LayerService", "Batch", Se).then((Ae) => a.BatchLayerResponse.decode(new _.Reader(Ae)));
    }
  }
  a.LayerServiceClientImpl = Be, a.LayerServiceDefinition = {
    name: "LayerService",
    fullName: "apis.layout.v2.LayerService",
    methods: {
      /** List all layers */
      listLayers: {
        name: "ListLayers",
        requestType: a.ListLayersRequest,
        requestStream: !1,
        responseType: a.ListLayersResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Create a layer
       * buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
       * buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE
       */
      createLayer: {
        name: "CreateLayer",
        requestType: a.CreateLayerRequest,
        requestStream: !1,
        responseType: a.Layer,
        responseStream: !1,
        options: {}
      },
      /**
       * Get a single layer
       * buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
       * buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE
       */
      getLayer: {
        name: "GetLayer",
        requestType: a.GetLayerRequest,
        requestStream: !1,
        responseType: a.Layer,
        responseStream: !1,
        options: {}
      },
      /**
       * Update a layer
       * buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
       * buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE
       */
      updateLayer: {
        name: "UpdateLayer",
        requestType: a.UpdateLayerRequest,
        requestStream: !1,
        responseType: a.Layer,
        responseStream: !1,
        options: {}
      },
      /** Delete a layer */
      deleteLayer: {
        name: "DeleteLayer",
        requestType: a.DeleteLayerRequest,
        requestStream: !1,
        responseType: a.DeleteLayerResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Batch update
       * buf:lint:ignore RPC_REQUEST_STANDARD_NAME
       * buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
       */
      batch: {
        name: "Batch",
        requestType: a.BatchLayerRequest,
        requestStream: !1,
        responseType: a.BatchLayerResponse,
        responseStream: !1,
        options: {}
      }
    }
  };
  class ze {
    constructor(se) {
      this.rpc = se, this.ListLayouts = this.ListLayouts.bind(this), this.CreateLayout = this.CreateLayout.bind(this), this.GetLayout = this.GetLayout.bind(this), this.UpdateLayout = this.UpdateLayout.bind(this), this.DeleteLayout = this.DeleteLayout.bind(this);
    }
    ListLayouts(se) {
      const Se = a.ListLayoutsRequest.encode(se).finish();
      return this.rpc.request("apis.layout.v2.LayoutService", "ListLayouts", Se).then((Ae) => a.ListLayoutsResponse.decode(new _.Reader(Ae)));
    }
    CreateLayout(se) {
      const Se = a.CreateLayoutRequest.encode(se).finish();
      return this.rpc.request("apis.layout.v2.LayoutService", "CreateLayout", Se).then((Ae) => a.Layout.decode(new _.Reader(Ae)));
    }
    GetLayout(se) {
      const Se = a.GetLayoutRequest.encode(se).finish();
      return this.rpc.request("apis.layout.v2.LayoutService", "GetLayout", Se).then((Ae) => a.Layout.decode(new _.Reader(Ae)));
    }
    UpdateLayout(se) {
      const Se = a.UpdateLayoutRequest.encode(se).finish();
      return this.rpc.request("apis.layout.v2.LayoutService", "UpdateLayout", Se).then((Ae) => a.Layout.decode(new _.Reader(Ae)));
    }
    DeleteLayout(se) {
      const Se = a.DeleteLayoutRequest.encode(se).finish();
      return this.rpc.request("apis.layout.v2.LayoutService", "DeleteLayout", Se).then((Ae) => a.DeleteLayoutResponse.decode(new _.Reader(Ae)));
    }
  }
  a.LayoutServiceClientImpl = ze, a.LayoutServiceDefinition = {
    name: "LayoutService",
    fullName: "apis.layout.v2.LayoutService",
    methods: {
      /** Get all layouts owned by the user. */
      listLayouts: {
        name: "ListLayouts",
        requestType: a.ListLayoutsRequest,
        requestStream: !1,
        responseType: a.ListLayoutsResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Create a new layout
       * buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
       * buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE
       */
      createLayout: {
        name: "CreateLayout",
        requestType: a.CreateLayoutRequest,
        requestStream: !1,
        responseType: a.Layout,
        responseStream: !1,
        options: {}
      },
      /**
       * Get a layout
       * buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
       * buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE
       */
      getLayout: {
        name: "GetLayout",
        requestType: a.GetLayoutRequest,
        requestStream: !1,
        responseType: a.Layout,
        responseStream: !1,
        options: {}
      },
      /**
       * Update a layout
       * buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
       * buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE
       */
      updateLayout: {
        name: "UpdateLayout",
        requestType: a.UpdateLayoutRequest,
        requestStream: !1,
        responseType: a.Layout,
        responseStream: !1,
        options: {}
      },
      /** Delete a layout */
      deleteLayout: {
        name: "DeleteLayout",
        requestType: a.DeleteLayoutRequest,
        requestStream: !1,
        responseType: a.DeleteLayoutResponse,
        responseStream: !1,
        options: {}
      }
    }
  };
  var Je = (() => {
    if (typeof Je < "u")
      return Je;
    if (typeof self < "u")
      return self;
    if (typeof window < "u")
      return window;
    if (typeof commonjsGlobal$1 < "u")
      return commonjsGlobal$1;
    throw "Unable to locate global object";
  })();
  _.util.Long !== p.default && (_.util.Long = p.default, _.configure());
  function je(x) {
    return typeof x == "object" && x !== null;
  }
  function Ke(x) {
    return x != null;
  }
})(api$4);
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(v, p, _, k) {
    k === void 0 && (k = _), Object.defineProperty(v, k, { enumerable: !0, get: function() {
      return p[_];
    } });
  } : function(v, p, _, k) {
    k === void 0 && (k = _), v[k] = p[_];
  }), c = commonjsGlobal$1 && commonjsGlobal$1.__exportStar || function(v, p) {
    for (var _ in v)
      _ !== "default" && !p.hasOwnProperty(_) && u(p, v, _);
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.layoutApiEventMap = void 0;
  const l = api$4;
  c(api$4, a), a.layoutApiEventMap = {
    [l.EventType.EVENT_TYPE_LAYOUT]: "layout",
    [l.EventType.EVENT_TYPE_LAYER]: "layer",
    [l.EventType.EVENT_TYPE_UNSPECIFIED]: "unspecified"
  };
})(dist$2);
var api$3 = {}, browser$f = !1;
const __viteBrowserExternal = {}, __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" })), require$$3 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
var logger = {};
class EnhancedMap extends Map {
  /**
   * If key has a mapping already returns the currently associated value. If
   * there is no mapping, calls the computer which must return a value V.
   * The value is then stored for given key and returned.
   * @param key Key
   * @param computer Computer which is called only if key has no mapping yet.
   * @return Existing value if the key already existed, or the newly computed value.
   */
  computeIfAbsent(u, c) {
    if (this.has(u))
      return this.get(u);
    const l = c(u);
    return this.set(u, l), l;
  }
  /**
   * If the key exists already calls given computer, if the key does not exist
   * this method does nothing.
   *
   * The computer is called with current key and current value associated. The
   * computer can return a (new) value V or undefined. When undefined is returned
   * the key is removed from this map, when a V is returned the key is updated
   * with the new value V.
   * @param key Key
   * @param computer Computer which is called only if the key has a mapping already
   * @return Undefined if the key has no mapping, otherwise the value returned from computer
   */
  computeIfPresent(u, c) {
    const l = this.get(u);
    if (l === void 0)
      return;
    const v = c(u, l);
    return v !== void 0 ? this.set(u, v) : this.delete(u), v;
  }
  /**
   * Computes a value for given key, the computer can return a value V (in which case the map
   * will set the value for given key), if it returns undefined the mapping for key K will be
   * removed.
   * @param key Key to compute
   * @param computer Computer which is called, note that the currentValue argument contains the existing
   *                 value or is undefined when no mapping exists for the key.
   * @return The newly computed value
   */
  compute(u, c) {
    const l = this.get(u), v = c(u, l);
    return v ? this.set(u, v) : this.delete(u), v;
  }
}
var InternalLogLevel;
(function(a) {
  a[a.Trace = 0] = "Trace", a[a.Debug = 1] = "Debug", a[a.Info = 2] = "Info", a[a.Warn = 3] = "Warn", a[a.Error = 4] = "Error";
})(InternalLogLevel || (InternalLogLevel = {}));
function getInternalLogger(a) {
  return provider.getLogger(a);
}
const INTERNAL_LOGGING_SETTINGS = {
  /**
   * Changes the log level for the internal logging (for all new and existing loggers)
   * @param level New log level
   */
  setInternalLogLevel: (a) => provider.changeLogLevel(a),
  /**
   * Changes where messages are written to for all new and existing loggers),
   * by default they are written to the console.
   * @param fnOutput Function to write messages to
   */
  setOutput: (a) => provider.changeOutput(a),
  /**
   * Resets the log level and output back to defaults (level to error and writing to console)
   * for all new and existing loggers.
   */
  reset: () => provider.reset()
};
class InternalLoggerImpl {
  constructor(u, c, l) {
    this._name = u, this._level = c, this._fnOutput = l;
  }
  trace(u) {
    this.log(InternalLogLevel.Trace, u);
  }
  debug(u) {
    this.log(InternalLogLevel.Debug, u);
  }
  error(u, c) {
    this.log(InternalLogLevel.Error, u, c);
  }
  info(u) {
    this.log(InternalLogLevel.Info, u);
  }
  warn(u, c) {
    this.log(InternalLogLevel.Warn, u, c);
  }
  setLevel(u) {
    this._level = u;
  }
  setOutput(u) {
    this._fnOutput = u;
  }
  log(u, c, l) {
    this._level > u || this._fnOutput(`${InternalLogLevel[this._level].toString()} <INTERNAL LOGGER> ${this._name} ${c()}${l ? `
` + l.stack : ""}`);
  }
}
class InternalProviderImpl {
  constructor() {
    this._loggers = new EnhancedMap(), this._logLevel = InternalLogLevel.Error, this._fnOutput = InternalProviderImpl.logConsole;
  }
  getLogger(u) {
    return this._loggers.computeIfAbsent(u, (c) => new InternalLoggerImpl(c, this._logLevel, this._fnOutput));
  }
  changeLogLevel(u) {
    this._logLevel = u, this._loggers.forEach((c) => c.setLevel(u));
  }
  changeOutput(u) {
    this._fnOutput = u, this._loggers.forEach((c) => c.setOutput(this._fnOutput));
  }
  reset() {
    this.changeLogLevel(InternalLogLevel.Error), this._fnOutput = InternalProviderImpl.logConsole, this._loggers.forEach((u) => u.setOutput(this._fnOutput));
  }
  static logConsole(u) {
    console && console.log && console.log(u);
  }
}
const provider = new InternalProviderImpl();
var InternalLogger = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  get InternalLogLevel() {
    return InternalLogLevel;
  },
  getInternalLogger,
  INTERNAL_LOGGING_SETTINGS
}), LogLevel$1;
(function(a) {
  a[a.Trace = 0] = "Trace", a[a.Debug = 1] = "Debug", a[a.Info = 2] = "Info", a[a.Warn = 3] = "Warn", a[a.Error = 4] = "Error", a[a.Fatal = 5] = "Fatal";
})(LogLevel$1 || (LogLevel$1 = {}));
(function(a) {
  function u(c) {
    switch (c.toLowerCase()) {
      case "trace":
        return a.Trace;
      case "debug":
        return a.Debug;
      case "info":
        return a.Info;
      case "warn":
        return a.Warn;
      case "error":
        return a.Error;
      case "fatal":
        return a.Fatal;
      default:
        return;
    }
  }
  a.toLogLevel = u;
})(LogLevel$1 || (LogLevel$1 = {}));
class CoreLoggerImpl {
  constructor(u) {
    this._runtime = u;
  }
  get id() {
    return this._runtime.id;
  }
  get logLevel() {
    return this._runtime.level;
  }
  get runtimeSettings() {
    return Object.assign({}, this._runtime);
  }
  set runtimeSettings(u) {
    this._runtime = u;
  }
  trace(u, ...c) {
    this.logMessage(LogLevel$1.Trace, u, c);
  }
  debug(u, ...c) {
    this.logMessage(LogLevel$1.Debug, u, c);
  }
  info(u, ...c) {
    this.logMessage(LogLevel$1.Info, u, c);
  }
  warn(u, ...c) {
    this.logMessage(LogLevel$1.Warn, u, c);
  }
  error(u, ...c) {
    this.logMessage(LogLevel$1.Error, u, c);
  }
  fatal(u, ...c) {
    this.logMessage(LogLevel$1.Fatal, u, c);
  }
  logMessage(u, c, l) {
    if (this._runtime.level > u)
      return;
    const v = Date.now(), p = typeof c == "string" ? c : c(), _ = CoreLoggerImpl.getErrorAndArgs(l);
    switch (this._runtime.channel.type) {
      case "RawLogChannel":
        this._runtime.channel.write({
          message: p,
          exception: _.error,
          args: _.args,
          timeInMillis: v,
          level: u,
          logNames: this._runtime.name
        }, this._runtime.argumentFormatter);
        return;
      case "LogChannel":
        this._runtime.channel.write(this.createLogMessage(p, u, _, v));
        break;
    }
  }
  formatArgValue(u) {
    try {
      return this._runtime.argumentFormatter(u);
    } catch {
      return `>>ARG CONVERT FAILED: '${u !== void 0 ? u.toString() : "undefined"}'<<`;
    }
  }
  createLogMessage(u, c, l, v) {
    let p;
    const _ = l.error, k = l.args;
    _ && (p = `${_.name}: ${_.message}`, _.stack && (p += `@
${_.stack}`));
    const O = this._runtime.dateFormatter(v);
    let D = LogLevel$1[c].toUpperCase();
    D.length < 5 && (D += " ");
    const F = typeof this._runtime.name == "string" ? this._runtime.name : this._runtime.name.join(", "), H = typeof k < "u" && k.length > 0 ? " [" + k.map((ee) => this.formatArgValue(ee)).join(", ") + "]" : "";
    return {
      message: O + " " + D + " [" + F + "] " + u + H,
      error: p
    };
  }
  static getErrorAndArgs(u) {
    if (u.length === 0)
      return {};
    let c, l;
    const v = u[0];
    if (v instanceof Error)
      return c = v, l = u.length > 1 ? u.slice(1) : void 0, { error: c, args: l };
    if (typeof v == "function") {
      const p = v();
      return p instanceof Error ? (c = p, l = u.length > 1 ? u.slice(1) : void 0, { error: c, args: l }) : u.length === 1 ? Array.isArray(p) ? { args: p.length > 0 ? p : void 0 } : { args: p } : Array.isArray(p) ? { args: [...p, ...u.slice(1)] } : { args: [p, ...u.slice(1)] };
    }
    return { args: u };
  }
}
function padStart(a, u, c = " ") {
  return padInternal(a, u, "start", c);
}
function padEnd(a, u, c = " ") {
  return padInternal(a, u, "end", c);
}
function maxLengthStringValueInArray(a) {
  return a.map((u) => u.length).reduce((u, c) => c > u ? c : u, 0);
}
function padInternal(a, u, c, l = " ") {
  if (u <= a.length)
    return a;
  if (l.length > 1)
    throw new Error(`Fill char must be one char exactly, it is: ${l.length}`);
  const v = u - a.length;
  let p = "";
  for (let _ = 0; _ < v; _++)
    p += l;
  return c === "start" ? p + a : a + p;
}
function formatArgument(a) {
  return a === void 0 ? "undefined" : JSON.stringify(a);
}
function formatDate(a) {
  const u = new Date(a), c = u.getFullYear(), l = padStart((u.getMonth() + 1).toString(), 2, "0"), v = padStart(u.getDate().toString(), 2, "0"), p = padStart(u.getHours().toString(), 2, "0"), _ = padStart(u.getMinutes().toString(), 2, "0"), k = padStart(u.getSeconds().toString(), 2, "0"), O = padStart(u.getMilliseconds().toString(), 2, "0");
  return `${c}-${l}-${v} ${p}:${_}:${k},${O}`;
}
class ConsoleLogChannel {
  constructor() {
    this.type = "LogChannel";
  }
  write(u) {
    console && console.log && console.log(u.message + (u.error ? `
${u.error}` : ""));
  }
}
var DefaultChannels;
(function(a) {
  function u() {
    return new ConsoleLogChannel();
  }
  a.createConsoleChannel = u;
})(DefaultChannels || (DefaultChannels = {}));
class LogProviderImpl {
  constructor(u, c) {
    this._log = getInternalLogger("core.impl.LogProviderImpl"), this._name = u, this._settings = c, this._loggers = new EnhancedMap(), this._idToKeyMap = new EnhancedMap(), this._globalRuntimeSettings = { level: c.level, channel: c.channel }, this._nextLoggerId = 1, this._log.trace(() => `Created LogProviderImpl with settings: ${JSON.stringify(this._settings)}`);
  }
  get runtimeSettings() {
    return Object.assign(Object.assign({}, this._settings), { level: this._globalRuntimeSettings.level, channel: this._globalRuntimeSettings.channel });
  }
  getLogger(u) {
    return this.getOrCreateLogger(u);
  }
  updateLoggerRuntime(u, c) {
    this._log.debug(() => `Updating logger ${u.id} runtime settings using: '${JSON.stringify(c)}'`);
    const l = this._idToKeyMap.get(u.id);
    return l === void 0 ? (this._log.warn(() => `Cannot update logger with id: ${u.id}, it was not found.`), !1) : (this._loggers.computeIfPresent(l, (v, p) => (p.runtimeSettings = LogProviderImpl.mergeRuntimeSettingsIntoLogRuntime(p.runtimeSettings, c), p)), !0);
  }
  updateRuntimeSettings(u) {
    this._log.debug(() => `Updating global runtime settings and updating existing loggers runtime settings using: '${JSON.stringify(u)}'`), this._globalRuntimeSettings = {
      /* It's unclear, but not checking explicitly on undefined here makes the test fail, it makes no sense as level is a number | undefined essentially. */
      level: u.level !== void 0 ? u.level : this._globalRuntimeSettings.level,
      channel: u.channel !== void 0 ? u.channel : this._globalRuntimeSettings.channel
    }, this._loggers.forEach((c) => c.runtimeSettings = LogProviderImpl.mergeRuntimeSettingsIntoLogRuntime(c.runtimeSettings, u));
  }
  /**
   * Removes all state and loggers, it reverts back to as it was after initial construction.
   */
  clear() {
    this._loggers.clear(), this._idToKeyMap.clear(), this._globalRuntimeSettings = Object.assign({}, this._settings), this._nextLoggerId = 1;
  }
  getOrCreateLogger(u) {
    const c = LogProviderImpl.createKey(u), l = this._loggers.computeIfAbsent(c, () => {
      const v = {
        level: this._globalRuntimeSettings.level,
        channel: this._globalRuntimeSettings.channel,
        id: this.nextLoggerId(),
        name: u,
        argumentFormatter: this._settings.argumentFormatter,
        dateFormatter: this._settings.dateFormatter
      };
      return new CoreLoggerImpl(v);
    });
    return this._idToKeyMap.computeIfAbsent(l.id, () => c), l;
  }
  nextLoggerId() {
    const u = this._name + "_" + this._nextLoggerId;
    return this._nextLoggerId++, u;
  }
  static mergeRuntimeSettingsIntoLogRuntime(u, c) {
    return Object.assign(Object.assign({}, u), {
      /* It's unclear, but not checking explicitly on undefined here makes the test fail, it makes no sense as level is a number | undefined essentially. */
      level: c.level !== void 0 ? c.level : u.level,
      channel: c.channel !== void 0 ? c.channel : u.channel
    });
  }
  static createKey(u) {
    return typeof u == "string" ? u : u.join(",");
  }
}
function createLogProvider(a, u) {
  return new LogProviderImpl(a, u);
}
var index$3 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  EnhancedMap,
  padStart,
  padEnd,
  maxLengthStringValueInArray
});
class CategoryImpl {
  constructor(u, c, l, v) {
    this._children = [], this._logger = u, this._name = c, this._parent = l, this._fnGetOrCreateChildCategory = v;
  }
  get name() {
    return this._name;
  }
  get parent() {
    return this._parent;
  }
  get path() {
    const u = [];
    let c = this;
    for (; c !== void 0; )
      u.push(c.name), c = c.parent;
    return u.reverse();
  }
  get children() {
    return [...this._children];
  }
  addChild(u) {
    if (u.parent !== this)
      throw new Error(`Cannot add child '${u.name}', expected parent '${this._name} but got ${u.parent ? u.parent.name : "undefined"}'`);
    this._children.push(u);
  }
  getChildCategory(u) {
    const c = this._children.find((l) => l.name === u);
    return c !== void 0 ? c : this._fnGetOrCreateChildCategory(u, this);
  }
  get id() {
    return this._logger.id;
  }
  get logLevel() {
    return this._logger.logLevel;
  }
  get runtimeSettings() {
    return this._logger.runtimeSettings;
  }
  get logger() {
    return this._logger;
  }
  trace(u, ...c) {
    this._logger.trace(u, ...c);
  }
  debug(u, ...c) {
    this._logger.debug(u, ...c);
  }
  info(u, ...c) {
    this._logger.info(u, ...c);
  }
  warn(u, ...c) {
    this._logger.warn(u, ...c);
  }
  error(u, ...c) {
    this._logger.error(u, ...c);
  }
  fatal(u, ...c) {
    this._logger.fatal(u, ...c);
  }
}
const CATEGORY_PATH_SEPARATOR = "#";
class CategoryProviderImpl {
  constructor(u, c) {
    this._name = u, this._initialConfig = c, this._categoryStorage = new CategoryStorage(u, c);
  }
  get name() {
    return this._name;
  }
  get config() {
    return this._initialConfig;
  }
  get runtimeConfig() {
    return this._categoryStorage.getCurrentRuntimeConfig();
  }
  getCategory(u, c) {
    return this._categoryStorage.getOrCreateCategory(u, c);
  }
  updateRuntimeSettingsCategory(u, c) {
    this._categoryStorage.updateRuntimeSettingsCategory(u, c);
  }
  updateRuntimeSettings(u) {
    this._categoryStorage.updateRuntimeSettings(u);
  }
  /** Returns all currently registered categories */
  getRegisteredCategories() {
    return this._categoryStorage.getRegisteredCategories();
  }
  /** Get a category by path, note that paths must be separated by #, e.g. root#child1#child1_1 */
  getCategoryByPath(u) {
    return this._categoryStorage.getCategoryByPath(u);
  }
}
class CategoryStorage {
  constructor(u, c) {
    this._categoriesById = /* @__PURE__ */ new Map(), this._categoriesByPath = /* @__PURE__ */ new Map(), this._categoryProviderName = u, this._allowSameCategoryName = c.allowSameCategoryName, this._logProvider = createLogProvider(u, Object.assign({}, c)), this.getOrCreateCategory = this.getOrCreateCategory.bind(this);
  }
  getOrCreateCategory(u, c) {
    if (u.indexOf(CATEGORY_PATH_SEPARATOR) !== -1)
      throw new Error(`Cannot create category '${u}', name cannot contain a '${CATEGORY_PATH_SEPARATOR}'.`);
    const l = c !== void 0 ? this.getParentCategory(c) : void 0;
    return l === void 0 ? this.getOrCreateRootCategory(u) : this.getOrCreateChildCategory(u, l);
  }
  updateRuntimeSettingsCategory(u, c) {
    if (!u.id.startsWith(this._categoryProviderName))
      throw new Error(`Category '${u.name}' with LogId '${u.id}' is from a different CategoryProvider, cannot mix categories between providers.`);
    const l = this._categoriesById.get(u.id);
    l !== void 0 && (this._logProvider.updateLoggerRuntime(l.logger, { level: c.level }), !(c.disableRecursion !== void 0 && c.disableRecursion) && l.children.forEach((v) => this.updateRuntimeSettingsCategory(v, c)));
  }
  updateRuntimeSettings(u) {
    this._logProvider.updateRuntimeSettings(u);
  }
  getCurrentRuntimeConfig() {
    return Object.assign(Object.assign({}, this._logProvider.runtimeSettings), { allowSameCategoryName: this._allowSameCategoryName });
  }
  /** Returns all currently registered categories */
  getRegisteredCategories() {
    return [...this._categoriesById.values()];
  }
  /** Get a category by path, note that paths must be separated by #, e.g. root#child1#child1_1 */
  getCategoryByPath(u) {
    return this._categoriesByPath.get(u);
  }
  getParentCategory(u) {
    let c;
    if (CategoryStorage.isLogId(u)) {
      if (c = this._categoriesById.get(u), c === void 0)
        throw new Error(`Parent category was not found by LogId '${u}'. Are you sure you passed in the correct argument?`);
    } else if (c = this._categoriesById.get(u.id), c === void 0)
      throw new Error(`Parent category '${u.name}' was not found by it's LogId '${u.id}'. Are you sure you passed in the correct parent category?`);
    return c;
  }
  getOrCreateRootCategory(u) {
    const c = this._categoriesByPath.get(u);
    if (c) {
      if (!this._allowSameCategoryName)
        throw new Error(`Category '${u} already exists, config flag allowSameCategoryName=false - therefore matching version 1 behavior (hence this Error)`);
      return c;
    }
    const l = this._logProvider.getLogger(u), v = new CategoryImpl(l, u, void 0, this.getOrCreateCategory);
    return this._categoriesById.set(v.id, v), this._categoriesByPath.set(u, v), v;
  }
  getOrCreateChildCategory(u, c) {
    if (!c.id.startsWith(this._categoryProviderName))
      throw new Error(`Parent category '${c.name}' with LogId '${c.id}' is from a different CategoryProvider, cannot mix categories between providers.`);
    const l = [...c.path, u].join(CATEGORY_PATH_SEPARATOR), v = this._categoriesByPath.get(l);
    if (v) {
      if (!this._allowSameCategoryName)
        throw new Error(`Child category '${u} already exists for parent category ${c.name}, config flag allowSameCategoryName=false - therefore matching version 1 behavior (hence this Error)`);
      return v;
    }
    const p = this._logProvider.getLogger(l);
    this._logProvider.updateLoggerRuntime(p, {
      level: c.logger.runtimeSettings.level,
      channel: c.logger.runtimeSettings.channel
    });
    const _ = new CategoryImpl(p, u, c, this.getOrCreateCategory);
    return this._categoriesById.set(_.id, _), this._categoriesByPath.set(_.path.join(CATEGORY_PATH_SEPARATOR), _), c.addChild(_), _;
  }
  static isLogId(u) {
    return typeof u == "string";
  }
}
class CategoryControlProviderImpl {
  constructor(u, c) {
    this._provider = u, this._messageChannel = c, this._originalLogLevels = CategoryControlProviderImpl.loadCurrentGroupLogLevels(u);
  }
  get name() {
    return this._provider.name;
  }
  /**
   * Shows current settings.
   */
  showSettings() {
    let u = `Available categories (CategoryProvider '${this._provider.name}'):
`;
    const c = this.createCategoryInfoHierarchy(), l = c.size.toString().length, v = index$3.maxLengthStringValueInArray([...c.values()].map((_) => _.category.name + " ".repeat(_.depth))), p = [...c.values()].map((_, k) => CategoryControlProviderImpl.createSettingLineCategory(_, k, l, v));
    u += p.join(`
`) + (p.length > 0 ? `
` : ""), this._messageChannel(u);
  }
  help() {
    const u = `You can use the following commands (CategoryProvider ${this._provider.name}):
  showSettings()
    Shows the current configuration settings.
  update(level: CategoryControlProviderLogLevel, categoryId?: number | string, noRecurse?: boolean)
    Change the log level for a category (by default recursively).
      @param level      The log level to set - must be one of 'trace', 'debug', 'info', 'warn', 'error' or 'fatal'
      @param categoryId The category id or path of a category (e.g. root#child1) to update. Use showSettings() for id and/or name.
                        When omitted, it applies the level to all categories recursively.
  reset()
    Resets the log levels of the config groups back to when this control provider was created.
  save()
    Saves the current log levels for all categories of this provider. Use restore() to load last saved state.
  restore()
    Restore stored saved state, if any. Log levels will be set according to the saved state.
  help()
    Shows this help.
`;
    this._messageChannel(u);
  }
  reset() {
    const u = new Map(this._provider.getRegisteredCategories().map((c) => [c.id, c]));
    this._originalLogLevels.forEach((c, l) => {
      const v = u.get(l);
      v !== void 0 && this._provider.updateRuntimeSettingsCategory(v, { level: c, disableRecursion: !0 }), u.delete(l);
    }), u.forEach((c) => {
      c.parent !== void 0 && this._provider.updateRuntimeSettingsCategory(c, { level: c.parent.logLevel, disableRecursion: !0 });
    }), this._originalLogLevels = CategoryControlProviderImpl.loadCurrentGroupLogLevels(this._provider), this._messageChannel("Successfully reset log levels back to original state (from when this CategoryControlProvider was created).");
  }
  save() {
    if (!localStorage) {
      this._messageChannel("Cannot save state, localStorage is not available.");
      return;
    }
    const u = this._provider.getRegisteredCategories().filter((l) => l.parent === void 0).map((l) => CategoryControlProviderImpl.createCategorySaveData(l)), c = {
      name: this._provider.name,
      rootCategories: u
    };
    localStorage.setItem(this.createKey(), JSON.stringify(c)), this._messageChannel(`Successfully saved state for CategoryControlProvider '${this._provider.name}'.`);
  }
  restore(u) {
    const c = u !== void 0 ? u : !0;
    if (!localStorage) {
      c && this._messageChannel(`Will not attempt to restore state for CategoryControlProvider '${this._provider.name}', localStorage is not available.`);
      return;
    }
    const l = this.createKey(), v = localStorage.getItem(l);
    if (v === null) {
      c && this._messageChannel(`Cannot restore state for CategoryControlProvider '${this._provider.name}', no data available.`);
      return;
    }
    try {
      const p = JSON.parse(v);
      if (this._provider.name !== p.name) {
        c && this._messageChannel(`Cannot restore state for CategoryControlProvider '${this._provider.name}', data is not for provider - found name '${p.name}'.`);
        return;
      }
      this.restoreBySaveData(p, c), this._messageChannel(`Successfully restored state for CategoryControlProvider '${this._provider.name}'`), this._originalLogLevels = CategoryControlProviderImpl.loadCurrentGroupLogLevels(this._provider);
    } catch {
      localStorage.removeItem(l), this._messageChannel(`Cannot restore state for CategoryControlProvider '${this._provider.name}', data is not valid. Invalid data removed from localStorage.`);
    }
  }
  update(u, c, l) {
    typeof c > "u" ? this.updateAll(u) : typeof c == "number" ? this.updateByIndex(u, c, l !== void 0 ? l : !1) : this.updateByPath(u, c, l !== void 0 ? l : !1);
  }
  updateAll(u) {
    const c = LogLevel$1.toLogLevel(u);
    this._provider.getRegisteredCategories().filter((l) => l.parent === void 0).forEach((l) => this._provider.updateRuntimeSettingsCategory(l, { level: c })), this._messageChannel(`Updated all categories to use log level '${u.toLowerCase()}'`);
  }
  updateByPath(u, c, l) {
    const v = this._provider.getCategoryByPath(c);
    if (v === void 0) {
      this._messageChannel(`Failed to find a provider by path '${c}', please make sure to separate the parts by a ${CATEGORY_PATH_SEPARATOR}.`);
      return;
    }
    this._provider.updateRuntimeSettingsCategory(v, { level: LogLevel$1.toLogLevel(u), disableRecursion: l }), this._messageChannel(`Successfully updated category '${v.name}' with path '${c}' to log level '${u.toLowerCase()}'${l ? "" : " and recursively applied to children (if any)"}.`);
  }
  updateByIndex(u, c, l) {
    if (c < 0) {
      this._messageChannel(`Cannot update category by index '${c}', it is negative.`);
      return;
    }
    const v = this.createCategoryInfoHierarchy();
    if (c >= v.size) {
      this._messageChannel(`Cannot update category by index '${c}', it is outside of the range of available categories, use showSettings() to see the indices.`);
      return;
    }
    const p = [...v.values()][c].category;
    this._provider.updateRuntimeSettingsCategory(p, { level: LogLevel$1.toLogLevel(u), disableRecursion: l }), this._messageChannel(`Successfully updated category '${p.name}' by index '${c}' to log level '${u.toLowerCase()}'${l ? "" : " and recursively applied to children (if any)"}.`);
  }
  restoreBySaveData(u, c) {
    const l = (v, p) => {
      const _ = p.length > 0 ? p + CATEGORY_PATH_SEPARATOR + v.name : v.name, k = this._provider.getCategoryByPath(_);
      if (k !== void 0) {
        const O = LogLevel$1.toLogLevel(v.level);
        O !== void 0 ? this._provider.updateRuntimeSettingsCategory(k, { level: O, disableRecursion: !0 }) : c && this._messageChannel(`CategoryControlProvider '${this._provider.name}' - cannot restore log level for category path '${_}', log level is invalid.`);
        for (const D of v.children)
          l(D, _);
      } else
        c && this._messageChannel(`CategoryControlProvider '${this._provider.name}' - failed to find a Category by path '${_}', will not restore category (and children)`);
    };
    for (const v of u.rootCategories)
      l(v, "");
  }
  createKey() {
    return `CategoryProvider-${this._provider.name}`;
  }
  createCategoryInfoHierarchy() {
    const u = /* @__PURE__ */ new Map();
    return this._provider.getRegisteredCategories().filter((l) => l.parent === void 0).forEach((l) => CategoryControlProviderImpl.addCategoryInfoHierarchy(l, 0, u)), u;
  }
  static createCategorySaveData(u) {
    return {
      name: u.name,
      level: LogLevel$1[u.logLevel],
      children: u.children.map((c) => this.createCategorySaveData(c))
    };
  }
  static loadCurrentGroupLogLevels(u) {
    return new Map(u.getRegisteredCategories().map((c) => [c.id, c.logLevel]));
  }
  static createSettingLineCategory(u, c, l, v) {
    const _ = " ".repeat(u.depth) + u.category.name;
    return `  [${index$3.padStart(c.toString(), l)}, ${index$3.padEnd(_, v)} (level=${index$3.padEnd(u.logLevel, 5)})]`;
  }
  static addCategoryInfoHierarchy(u, c, l) {
    l.set(u.id, {
      category: u,
      logLevel: LogLevel$1[u.logLevel],
      depth: c
    }), u.children.forEach((v) => this.addCategoryInfoHierarchy(v, c + 1, l));
  }
}
function categoryConfigDebug(a) {
  return `CategoryConfig=level: ${LogLevel$1[a.level].toString()}, allowSameCategoryName=${a.allowSameCategoryName}`;
}
class CategoryProviderService {
  constructor() {
    this._log = InternalLogger.getInternalLogger("category.impl.CategoryProviderService"), this._providers = new index$3.EnhancedMap();
  }
  createLogProvider(u, c) {
    const l = this._providers.compute(u, (v, p) => {
      if (p)
        throw new Error(`CategoryProvider with name '${u}' already exists, cannot create another.`);
      const _ = mergeWithDefaults(c);
      return this._log.debug(() => `Creating new CategoryProvider with name '${u}', using config settings '${categoryConfigDebug(_)}'.`), new CategoryProviderImpl(u, _);
    });
    if (l)
      return l;
    throw new Error("No CategoryProvider? This is a bug.");
  }
  getCategoryControl(u) {
    const c = u || ((l) => {
      if (console && console.log)
        console.log(l);
      else
        throw new Error("Cannot use console (it is not present), please specify a custom function to write to.");
    });
    return {
      help: () => c(CategoryProviderService.help()),
      showSettings: () => c(this.showSettings()),
      getProvider: (l) => this.getCategoryControlProviderByIdOrName(l, c)
    };
  }
  clear() {
    this._providers.clear();
  }
  /* Functions for CategoryControl follow */
  showSettings() {
    let u = `Available CategoryProviders:
`;
    const c = this._providers.size.toString().length, l = index$3.maxLengthStringValueInArray([...this._providers.keys()]), v = [...this._providers.entries()].map((p, _) => {
      const k = p[0];
      return `  [${index$3.padStart(_.toString(), c)}, ${index$3.padEnd(k, l)}]`;
    });
    return u += v.join(`
`) + (v.length > 0 ? `
` : ""), u;
  }
  getCategoryControlProviderByIdOrName(u, c) {
    if (typeof u == "string") {
      const v = this._providers.get(u);
      if (v === void 0)
        throw new Error(`Provider with name '${u}' does not exist.`);
      return new CategoryControlProviderImpl(v, c);
    }
    const l = [...this._providers.values()];
    if (u < 0 || u >= l.length)
      throw new Error(`Provider with index '${u}' does not exist (outside of range).`);
    return new CategoryControlProviderImpl(l[u], c);
  }
  static help() {
    return `You can use the following commands:
  showSettings()
    Shows the current configuration settings.
  getProvider: (id: number | string): CategoryControlProvider
    Get access to a CategoryControlProvider to change log levels.
      @param id The id (use showSettings to see) or name of the provider
  help()
    Shows this help.
`;
  }
}
const CATEGORY_PROVIDER_SERVICE = new CategoryProviderService(), CATEGORY_LOG_CONTROL = (a) => CATEGORY_PROVIDER_SERVICE.getCategoryControl(a);
function mergeWithDefaults(a) {
  const u = {
    channel: DefaultChannels.createConsoleChannel(),
    allowSameCategoryName: !0,
    level: LogLevel$1.Error,
    dateFormatter: formatDate,
    argumentFormatter: formatArgument
  };
  return a ? {
    channel: a.channel ? a.channel : u.channel,
    allowSameCategoryName: a.allowSameCategoryName !== void 0 ? a.allowSameCategoryName : u.allowSameCategoryName,
    level: a.level ? a.level : u.level,
    dateFormatter: a.dateFormatter ? a.dateFormatter : u.dateFormatter,
    argumentFormatter: a.argumentFormatter ? a.argumentFormatter : u.argumentFormatter
  } : u;
}
var CategoryProvider;
(function(a) {
  function u(l, v) {
    return CATEGORY_PROVIDER_SERVICE.createLogProvider(l, v);
  }
  a.createProvider = u;
  function c() {
    CATEGORY_PROVIDER_SERVICE.clear();
  }
  a.clear = c;
})(CategoryProvider || (CategoryProvider = {}));
const typescriptLoggingCategory_esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CATEGORY_LOG_CONTROL,
  get CategoryProvider() {
    return CategoryProvider;
  }
}, Symbol.toStringTag, { value: "Module" })), require$$1$2 = /* @__PURE__ */ getAugmentedNamespace(typescriptLoggingCategory_esm);
Object.defineProperty(logger, "__esModule", { value: !0 });
logger.logger = void 0;
const typescript_logging_1 = require$$2$2, typescript_logging_category_style_1 = require$$1$2;
logger.logger = typescript_logging_category_style_1.CategoryProvider.createProvider("ApiStream", { allowSameCategoryName: !0, level: typescript_logging_1.LogLevel.Warn });
var version$4 = "1.0.27", __createBinding$3 = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(a, u, c, l) {
  l === void 0 && (l = c);
  var v = Object.getOwnPropertyDescriptor(u, c);
  (!v || ("get" in v ? !u.__esModule : v.writable || v.configurable)) && (v = { enumerable: !0, get: function() {
    return u[c];
  } }), Object.defineProperty(a, l, v);
} : function(a, u, c, l) {
  l === void 0 && (l = c), a[l] = u[c];
}), __setModuleDefault$3 = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(a, u) {
  Object.defineProperty(a, "default", { enumerable: !0, value: u });
} : function(a, u) {
  a.default = u;
}), __importStar$3 = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(a) {
  if (a && a.__esModule)
    return a;
  var u = {};
  if (a != null)
    for (var c in a)
      c !== "default" && Object.prototype.hasOwnProperty.call(a, c) && __createBinding$3(u, a, c);
  return __setModuleDefault$3(u, a), u;
}, __importDefault$d = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(api$3, "__esModule", { value: !0 });
api$3.ApiClient = void 0;
const NiceGrpc$1 = __importStar$3(lib$1), abort_controller_x_1 = require$$1$3, detect_node_1 = __importDefault$d(browser$f), NodeTransport = __importStar$3(require$$3), logger_1 = logger, clientVersion$1 = version$4;
class ApiClient {
  constructor(u, c, l, v, p, _) {
    this.sessionId = u, this.sdkVersion = l, this.version = clientVersion$1, this.apiLogCallback = p, this.eventLogCallback = _, this.log = logger_1.logger.getCategory(v), this.channel = NiceGrpc$1.createChannel(c, detect_node_1.default ? NodeTransport.NodeHttpTransport() : void 0), this.clientFactory = NiceGrpc$1.createClientFactory().use(this.logMiddleware.bind(this));
  }
  async *logMiddleware(u, c) {
    const { path: l } = u.method;
    try {
      const v = yield* u.next(u.request, c);
      if (this.log.debug(`-> ${l}: ok`), this.log.trace(`${JSON.stringify(u.request)} -> ${l}: ${JSON.stringify(v)}`), this.apiLogCallback) {
        let p = l.split("/"), _ = p[1].split("."), k = _[_.length - 1], O = _[_.length - 2], D = _[_.length - 3], F = p[2];
        this.apiLogCallback(D, k, F, u.request, v);
      }
      return v;
    } catch (v) {
      throw this.log.trace(`${JSON.stringify(u.request)} -> ${l}`), v instanceof NiceGrpc$1.ClientError ? this.log.warn(`-> ${l}: error: ${NiceGrpc$1.Status[v.code]}: ${v.details}`) : (0, abort_controller_x_1.isAbortError)(v) ? this.log.warn(`-> ${l}: cancel`) : this.log.warn(`-> ${l}: error: ${v == null ? void 0 : v.stack}`), v;
    }
  }
  setAccessToken(u) {
    (this.accessToken == null || this.accessToken != u) && (this.log.debug("access token refreshed"), this.accessToken = u, this.setup());
  }
  makeGrpcMetadata() {
    let u = NiceGrpc$1.Metadata({
      Authorization: `Bearer ${this.accessToken}`,
      Version: this.version,
      SessionId: this.sessionId
    });
    return this.sdkVersion != null && u.set("SdkVersion", this.sdkVersion), u;
  }
  setup() {
    let u = {
      metadata: this.makeGrpcMetadata()
    };
    this._setup(u);
  }
  _setup(u) {
  }
}
api$3.ApiClient = ApiClient;
var decorator = {};
Object.defineProperty(decorator, "__esModule", { value: !0 });
decorator.RequiresSdkAuthentication = void 0;
function RequiresSdkAuthentication() {
  return function(a, u) {
    const c = Symbol(u);
    Object.defineProperty(a, u, {
      get: function() {
        if (!this[c])
          throw new Error("Please authenticate ApiStream by calling apiStream.load( accessToken )");
        return this[c];
      },
      set: function(l) {
        this[c] = l;
      }
    });
  };
}
decorator.RequiresSdkAuthentication = RequiresSdkAuthentication;
var __createBinding$2 = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(a, u, c, l) {
  l === void 0 && (l = c);
  var v = Object.getOwnPropertyDescriptor(u, c);
  (!v || ("get" in v ? !u.__esModule : v.writable || v.configurable)) && (v = { enumerable: !0, get: function() {
    return u[c];
  } }), Object.defineProperty(a, l, v);
} : function(a, u, c, l) {
  l === void 0 && (l = c), a[l] = u[c];
}), __setModuleDefault$2 = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(a, u) {
  Object.defineProperty(a, "default", { enumerable: !0, value: u });
} : function(a, u) {
  a.default = u;
}), __decorate = commonjsGlobal$1 && commonjsGlobal$1.__decorate || function(a, u, c, l) {
  var v = arguments.length, p = v < 3 ? u : l === null ? l = Object.getOwnPropertyDescriptor(u, c) : l, _;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    p = Reflect.decorate(a, u, c, l);
  else
    for (var k = a.length - 1; k >= 0; k--)
      (_ = a[k]) && (p = (v < 3 ? _(p) : v > 3 ? _(u, c, p) : _(u, c)) || p);
  return v > 3 && p && Object.defineProperty(u, c, p), p;
}, __importStar$2 = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(a) {
  if (a && a.__esModule)
    return a;
  var u = {};
  if (a != null)
    for (var c in a)
      c !== "default" && Object.prototype.hasOwnProperty.call(a, c) && __createBinding$2(u, a, c);
  return __setModuleDefault$2(u, a), u;
}, __metadata = commonjsGlobal$1 && commonjsGlobal$1.__metadata || function(a, u) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
    return Reflect.metadata(a, u);
};
Object.defineProperty(layoutapi, "__esModule", { value: !0 });
layoutapi.LayoutApi = void 0;
__importStar$2(lib$1);
const LayoutApiModel = __importStar$2(dist$2), api_1$1 = api$3, decorator_1 = decorator, LOG_CATEGORY$1 = "LayoutApi";
class LayoutApi extends api_1$1.ApiClient {
  constructor(u, c, l, v, p) {
    super(u, l, v, LOG_CATEGORY$1, p), this.handlers = {}, this.eventApi = c, this.eventApi.on("event", { name: `${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:*`, ignoreSessionEvents: !0 }, (_) => {
      var k;
      const [, O] = _.name.split(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:`), [D, F] = O.split(":"), H = _.payload;
      for (const Z of (k = this.handlers[D]) !== null && k !== void 0 ? k : [])
        Z(Object.values(H).find((ee) => !!ee), F);
    });
  }
  _setup(u) {
    this.layer = this.clientFactory.create(LayoutApiModel.LayerServiceDefinition, this.channel, {
      "*": u
    }), this.layout = this.clientFactory.create(LayoutApiModel.LayoutServiceDefinition, this.channel, {
      "*": u
    });
  }
  /**
   * Subscribe to all events for a given layout.
   *
   * @param layoutId - the id of the layout to which you want to subscribe to layout events
   */
  async subscribeToLayout(u) {
    await Promise.all([
      this.eventApi.subscribe(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:${LayoutApiModel.EventType.EVENT_TYPE_LAYER}:*`, { target: { layoutId: u } }),
      this.eventApi.subscribe(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:${LayoutApiModel.EventType.EVENT_TYPE_LAYOUT}:*`, { target: { layoutId: u } })
    ]);
  }
  /**
   * Unsubscribe from all events for a given layout.
   *
   * @param layoutId - the id of the layout to which you want to unsubscribe to layout events
   */
  async unsubscribeFromLayout(u) {
    await Promise.all([
      this.eventApi.unsubscribe(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:${LayoutApiModel.EventType.EVENT_TYPE_LAYER}:*`, { target: { layoutId: u } }),
      this.eventApi.unsubscribe(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:${LayoutApiModel.EventType.EVENT_TYPE_LAYOUT}:*`, { target: { layoutId: u } })
    ]);
  }
  /**
   * Subscribe to all events for layouts in a project.
   *
   * @param collectionId - the id of the collection the layouts are in.
   * @param projectId - the id of the project the layouts are in.
   */
  async subscribeToLayoutsInProject(u, c) {
    await Promise.all([
      this.eventApi.subscribe(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:${LayoutApiModel.EventType.EVENT_TYPE_LAYER}:*`, { target: { collectionId: u, projectId: c } }),
      this.eventApi.subscribe(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:${LayoutApiModel.EventType.EVENT_TYPE_LAYOUT}:*`, { target: { collectionId: u, projectId: c } })
    ]);
  }
  /**
   * Unsubscribe from all events for layouts in a project.
   *
   * @param collectionId - the id of the collection the layouts are in.
   * @param projectId - the id of the project the layouts are in.
   */
  async unsubscribeFromLayoutsInProject(u, c) {
    await Promise.all([
      this.eventApi.unsubscribe(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:${LayoutApiModel.EventType.EVENT_TYPE_LAYER}:*`, { target: { collectionId: u, projectId: c } }),
      this.eventApi.unsubscribe(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:${LayoutApiModel.EventType.EVENT_TYPE_LAYOUT}:*`, { target: { collectionId: u, projectId: c } })
    ]);
  }
  /**
   * Register an event handler
   *
   * @param type Type of event
   * @param handler
   */
  on(u, c) {
    var l;
    this.handlers[u] = (l = this.handlers[u]) !== null && l !== void 0 ? l : [], this.handlers[u].push(c);
  }
  /**
   * Unregister an event handler
   *
   * @param type Type of event
   * @param handler
   */
  off(u, c) {
    this.handlers[u] = this.handlers[u].filter((l) => l !== c);
  }
}
LayoutApi.LAYOUTAPI_EVENT_PREFIX = "apistream:layout";
__decorate([
  (0, decorator_1.RequiresSdkAuthentication)(),
  __metadata("design:type", Object)
], LayoutApi.prototype, "layout", void 0);
__decorate([
  (0, decorator_1.RequiresSdkAuthentication)(),
  __metadata("design:type", Object)
], LayoutApi.prototype, "layer", void 0);
layoutapi.LayoutApi = LayoutApi;
var liveapi = {}, api$2 = {}, httpbody = {}, any = {}, __importDefault$c = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(any, "__esModule", { value: !0 });
any.Any = any.protobufPackage = void 0;
const minimal_1$5 = __importDefault$c(minimal);
any.protobufPackage = "google.protobuf";
function createBaseAny() {
  return { typeUrl: "", value: new Uint8Array() };
}
any.Any = {
  encode(a, u = minimal_1$5.default.Writer.create()) {
    return a.typeUrl !== "" && u.uint32(10).string(a.typeUrl), a.value.length !== 0 && u.uint32(18).bytes(a.value), u;
  },
  decode(a, u) {
    const c = a instanceof minimal_1$5.default.Reader ? a : new minimal_1$5.default.Reader(a);
    let l = u === void 0 ? c.len : c.pos + u;
    const v = createBaseAny();
    for (; c.pos < l; ) {
      const p = c.uint32();
      switch (p >>> 3) {
        case 1:
          v.typeUrl = c.string();
          break;
        case 2:
          v.value = c.bytes();
          break;
        default:
          c.skipType(p & 7);
          break;
      }
    }
    return v;
  },
  fromJSON(a) {
    return {
      typeUrl: isSet$5(a.typeUrl) ? String(a.typeUrl) : "",
      value: isSet$5(a.value) ? bytesFromBase64$1(a.value) : new Uint8Array()
    };
  },
  toJSON(a) {
    const u = {};
    return a.typeUrl !== void 0 && (u.typeUrl = a.typeUrl), a.value !== void 0 && (u.value = base64FromBytes$1(a.value !== void 0 ? a.value : new Uint8Array())), u;
  },
  fromPartial(a) {
    var u, c;
    const l = createBaseAny();
    return l.typeUrl = (u = a.typeUrl) !== null && u !== void 0 ? u : "", l.value = (c = a.value) !== null && c !== void 0 ? c : new Uint8Array(), l;
  }
};
var globalThis$5 = (() => {
  if (typeof globalThis$5 < "u")
    return globalThis$5;
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof commonjsGlobal$1 < "u")
    return commonjsGlobal$1;
  throw "Unable to locate global object";
})();
function bytesFromBase64$1(a) {
  if (globalThis$5.Buffer)
    return Uint8Array.from(globalThis$5.Buffer.from(a, "base64"));
  {
    const u = globalThis$5.atob(a), c = new Uint8Array(u.length);
    for (let l = 0; l < u.length; ++l)
      c[l] = u.charCodeAt(l);
    return c;
  }
}
function base64FromBytes$1(a) {
  if (globalThis$5.Buffer)
    return globalThis$5.Buffer.from(a).toString("base64");
  {
    const u = [];
    return a.forEach((c) => {
      u.push(String.fromCharCode(c));
    }), globalThis$5.btoa(u.join(""));
  }
}
function isSet$5(a) {
  return a != null;
}
var __importDefault$b = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(httpbody, "__esModule", { value: !0 });
httpbody.HttpBody = httpbody.protobufPackage = void 0;
const minimal_1$4 = __importDefault$b(minimal), any_1 = any;
httpbody.protobufPackage = "google.api";
function createBaseHttpBody() {
  return { contentType: "", data: new Uint8Array(), extensions: [] };
}
httpbody.HttpBody = {
  encode(a, u = minimal_1$4.default.Writer.create()) {
    a.contentType !== "" && u.uint32(10).string(a.contentType), a.data.length !== 0 && u.uint32(18).bytes(a.data);
    for (const c of a.extensions)
      any_1.Any.encode(c, u.uint32(26).fork()).ldelim();
    return u;
  },
  decode(a, u) {
    const c = a instanceof minimal_1$4.default.Reader ? a : new minimal_1$4.default.Reader(a);
    let l = u === void 0 ? c.len : c.pos + u;
    const v = createBaseHttpBody();
    for (; c.pos < l; ) {
      const p = c.uint32();
      switch (p >>> 3) {
        case 1:
          v.contentType = c.string();
          break;
        case 2:
          v.data = c.bytes();
          break;
        case 3:
          v.extensions.push(any_1.Any.decode(c, c.uint32()));
          break;
        default:
          c.skipType(p & 7);
          break;
      }
    }
    return v;
  },
  fromJSON(a) {
    return {
      contentType: isSet$4(a.contentType) ? String(a.contentType) : "",
      data: isSet$4(a.data) ? bytesFromBase64(a.data) : new Uint8Array(),
      extensions: Array.isArray(a == null ? void 0 : a.extensions) ? a.extensions.map((u) => any_1.Any.fromJSON(u)) : []
    };
  },
  toJSON(a) {
    const u = {};
    return a.contentType !== void 0 && (u.contentType = a.contentType), a.data !== void 0 && (u.data = base64FromBytes(a.data !== void 0 ? a.data : new Uint8Array())), a.extensions ? u.extensions = a.extensions.map((c) => c ? any_1.Any.toJSON(c) : void 0) : u.extensions = [], u;
  },
  fromPartial(a) {
    var u, c, l;
    const v = createBaseHttpBody();
    return v.contentType = (u = a.contentType) !== null && u !== void 0 ? u : "", v.data = (c = a.data) !== null && c !== void 0 ? c : new Uint8Array(), v.extensions = ((l = a.extensions) === null || l === void 0 ? void 0 : l.map((p) => any_1.Any.fromPartial(p))) || [], v;
  }
};
var globalThis$4 = (() => {
  if (typeof globalThis$4 < "u")
    return globalThis$4;
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof commonjsGlobal$1 < "u")
    return commonjsGlobal$1;
  throw "Unable to locate global object";
})();
function bytesFromBase64(a) {
  if (globalThis$4.Buffer)
    return Uint8Array.from(globalThis$4.Buffer.from(a, "base64"));
  {
    const u = globalThis$4.atob(a), c = new Uint8Array(u.length);
    for (let l = 0; l < u.length; ++l)
      c[l] = u.charCodeAt(l);
    return c;
  }
}
function base64FromBytes(a) {
  if (globalThis$4.Buffer)
    return globalThis$4.Buffer.from(a).toString("base64");
  {
    const u = [];
    return a.forEach((c) => {
      u.push(String.fromCharCode(c));
    }), globalThis$4.btoa(u.join(""));
  }
}
function isSet$4(a) {
  return a != null;
}
var field_mask = {}, __importDefault$a = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(field_mask, "__esModule", { value: !0 });
field_mask.FieldMask = field_mask.protobufPackage = void 0;
const minimal_1$3 = __importDefault$a(minimal);
field_mask.protobufPackage = "google.protobuf";
function createBaseFieldMask() {
  return { paths: [] };
}
field_mask.FieldMask = {
  encode(a, u = minimal_1$3.default.Writer.create()) {
    for (const c of a.paths)
      u.uint32(10).string(c);
    return u;
  },
  decode(a, u) {
    const c = a instanceof minimal_1$3.default.Reader ? a : new minimal_1$3.default.Reader(a);
    let l = u === void 0 ? c.len : c.pos + u;
    const v = createBaseFieldMask();
    for (; c.pos < l; ) {
      const p = c.uint32();
      switch (p >>> 3) {
        case 1:
          v.paths.push(c.string());
          break;
        default:
          c.skipType(p & 7);
          break;
      }
    }
    return v;
  },
  fromJSON(a) {
    return {
      paths: typeof a == "string" ? a.split(",").filter(Boolean) : Array.isArray(a == null ? void 0 : a.paths) ? a.paths.map(String) : []
    };
  },
  toJSON(a) {
    return a.paths.join(",");
  },
  fromPartial(a) {
    var u;
    const c = createBaseFieldMask();
    return c.paths = ((u = a.paths) === null || u === void 0 ? void 0 : u.map((l) => l)) || [], c;
  },
  wrap(a) {
    const u = createBaseFieldMask();
    return u.paths = a, u;
  },
  unwrap(a) {
    return a.paths;
  }
};
var struct$1 = {};
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(X) {
    return X && X.__esModule ? X : { default: X };
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.ListValue = a.Value = a.Struct_FieldsEntry = a.Struct = a.nullValueToNumber = a.nullValueToJSON = a.nullValueFromJSON = a.NullValue = a.protobufPackage = void 0;
  const c = u(minimal);
  a.protobufPackage = "google.protobuf";
  var l;
  (function(X) {
    X.NULL_VALUE = "NULL_VALUE";
  })(l = a.NullValue || (a.NullValue = {}));
  function v(X) {
    switch (X) {
      case 0:
      case "NULL_VALUE":
        return l.NULL_VALUE;
      default:
        throw new H.Error("Unrecognized enum value " + X + " for enum NullValue");
    }
  }
  a.nullValueFromJSON = v;
  function p(X) {
    switch (X) {
      case l.NULL_VALUE:
        return "NULL_VALUE";
      default:
        throw new H.Error("Unrecognized enum value " + X + " for enum NullValue");
    }
  }
  a.nullValueToJSON = p;
  function _(X) {
    switch (X) {
      case l.NULL_VALUE:
        return 0;
      default:
        throw new H.Error("Unrecognized enum value " + X + " for enum NullValue");
    }
  }
  a.nullValueToNumber = _;
  function k() {
    return { fields: {} };
  }
  a.Struct = {
    encode(X, ne = c.default.Writer.create()) {
      return Object.entries(X.fields).forEach(([Q, ae]) => {
        ae !== void 0 && a.Struct_FieldsEntry.encode({ key: Q, value: ae }, ne.uint32(10).fork()).ldelim();
      }), ne;
    },
    decode(X, ne) {
      const Q = X instanceof c.default.Reader ? X : new c.default.Reader(X);
      let ae = ne === void 0 ? Q.len : Q.pos + ne;
      const j = k();
      for (; Q.pos < ae; ) {
        const ue = Q.uint32();
        switch (ue >>> 3) {
          case 1:
            const he = a.Struct_FieldsEntry.decode(Q, Q.uint32());
            he.value !== void 0 && (j.fields[he.key] = he.value);
            break;
          default:
            Q.skipType(ue & 7);
            break;
        }
      }
      return j;
    },
    fromJSON(X) {
      return {
        fields: Z(X.fields) ? Object.entries(X.fields).reduce((ne, [Q, ae]) => (ne[Q] = ae, ne), {}) : {}
      };
    },
    toJSON(X) {
      const ne = {};
      return ne.fields = {}, X.fields && Object.entries(X.fields).forEach(([Q, ae]) => {
        ne.fields[Q] = ae;
      }), ne;
    },
    fromPartial(X) {
      var ne;
      const Q = k();
      return Q.fields = Object.entries((ne = X.fields) !== null && ne !== void 0 ? ne : {}).reduce((ae, [j, ue]) => (ue !== void 0 && (ae[j] = ue), ae), {}), Q;
    },
    wrap(X) {
      const ne = k();
      return X !== void 0 && Object.keys(X).forEach((Q) => {
        ne.fields[Q] = X[Q];
      }), ne;
    },
    unwrap(X) {
      const ne = {};
      return Object.keys(X.fields).forEach((Q) => {
        ne[Q] = X.fields[Q];
      }), ne;
    }
  };
  function O() {
    return { key: "", value: void 0 };
  }
  a.Struct_FieldsEntry = {
    encode(X, ne = c.default.Writer.create()) {
      return X.key !== "" && ne.uint32(10).string(X.key), X.value !== void 0 && a.Value.encode(a.Value.wrap(X.value), ne.uint32(18).fork()).ldelim(), ne;
    },
    decode(X, ne) {
      const Q = X instanceof c.default.Reader ? X : new c.default.Reader(X);
      let ae = ne === void 0 ? Q.len : Q.pos + ne;
      const j = O();
      for (; Q.pos < ae; ) {
        const ue = Q.uint32();
        switch (ue >>> 3) {
          case 1:
            j.key = Q.string();
            break;
          case 2:
            j.value = a.Value.unwrap(a.Value.decode(Q, Q.uint32()));
            break;
          default:
            Q.skipType(ue & 7);
            break;
        }
      }
      return j;
    },
    fromJSON(X) {
      return { key: ee(X.key) ? String(X.key) : "", value: ee(X == null ? void 0 : X.value) ? X.value : void 0 };
    },
    toJSON(X) {
      const ne = {};
      return X.key !== void 0 && (ne.key = X.key), X.value !== void 0 && (ne.value = X.value), ne;
    },
    fromPartial(X) {
      var ne, Q;
      const ae = O();
      return ae.key = (ne = X.key) !== null && ne !== void 0 ? ne : "", ae.value = (Q = X.value) !== null && Q !== void 0 ? Q : void 0, ae;
    }
  };
  function D() {
    return {
      nullValue: void 0,
      numberValue: void 0,
      stringValue: void 0,
      boolValue: void 0,
      structValue: void 0,
      listValue: void 0
    };
  }
  a.Value = {
    encode(X, ne = c.default.Writer.create()) {
      return X.nullValue !== void 0 && ne.uint32(8).int32(_(X.nullValue)), X.numberValue !== void 0 && ne.uint32(17).double(X.numberValue), X.stringValue !== void 0 && ne.uint32(26).string(X.stringValue), X.boolValue !== void 0 && ne.uint32(32).bool(X.boolValue), X.structValue !== void 0 && a.Struct.encode(a.Struct.wrap(X.structValue), ne.uint32(42).fork()).ldelim(), X.listValue !== void 0 && a.ListValue.encode(a.ListValue.wrap(X.listValue), ne.uint32(50).fork()).ldelim(), ne;
    },
    decode(X, ne) {
      const Q = X instanceof c.default.Reader ? X : new c.default.Reader(X);
      let ae = ne === void 0 ? Q.len : Q.pos + ne;
      const j = D();
      for (; Q.pos < ae; ) {
        const ue = Q.uint32();
        switch (ue >>> 3) {
          case 1:
            j.nullValue = v(Q.int32());
            break;
          case 2:
            j.numberValue = Q.double();
            break;
          case 3:
            j.stringValue = Q.string();
            break;
          case 4:
            j.boolValue = Q.bool();
            break;
          case 5:
            j.structValue = a.Struct.unwrap(a.Struct.decode(Q, Q.uint32()));
            break;
          case 6:
            j.listValue = a.ListValue.unwrap(a.ListValue.decode(Q, Q.uint32()));
            break;
          default:
            Q.skipType(ue & 7);
            break;
        }
      }
      return j;
    },
    fromJSON(X) {
      return {
        nullValue: ee(X.nullValue) ? v(X.nullValue) : void 0,
        numberValue: ee(X.numberValue) ? Number(X.numberValue) : void 0,
        stringValue: ee(X.stringValue) ? String(X.stringValue) : void 0,
        boolValue: ee(X.boolValue) ? !!X.boolValue : void 0,
        structValue: Z(X.structValue) ? X.structValue : void 0,
        listValue: Array.isArray(X.listValue) ? [...X.listValue] : void 0
      };
    },
    toJSON(X) {
      const ne = {};
      return X.nullValue !== void 0 && (ne.nullValue = X.nullValue !== void 0 ? p(X.nullValue) : void 0), X.numberValue !== void 0 && (ne.numberValue = X.numberValue), X.stringValue !== void 0 && (ne.stringValue = X.stringValue), X.boolValue !== void 0 && (ne.boolValue = X.boolValue), X.structValue !== void 0 && (ne.structValue = X.structValue), X.listValue !== void 0 && (ne.listValue = X.listValue), ne;
    },
    fromPartial(X) {
      var ne, Q, ae, j, ue, he;
      const fe = D();
      return fe.nullValue = (ne = X.nullValue) !== null && ne !== void 0 ? ne : void 0, fe.numberValue = (Q = X.numberValue) !== null && Q !== void 0 ? Q : void 0, fe.stringValue = (ae = X.stringValue) !== null && ae !== void 0 ? ae : void 0, fe.boolValue = (j = X.boolValue) !== null && j !== void 0 ? j : void 0, fe.structValue = (ue = X.structValue) !== null && ue !== void 0 ? ue : void 0, fe.listValue = (he = X.listValue) !== null && he !== void 0 ? he : void 0, fe;
    },
    wrap(X) {
      const ne = D();
      if (X === null)
        ne.nullValue = l.NULL_VALUE;
      else if (typeof X == "boolean")
        ne.boolValue = X;
      else if (typeof X == "number")
        ne.numberValue = X;
      else if (typeof X == "string")
        ne.stringValue = X;
      else if (Array.isArray(X))
        ne.listValue = X;
      else if (typeof X == "object")
        ne.structValue = X;
      else if (typeof X < "u")
        throw new Error("Unsupported any value type: " + typeof X);
      return ne;
    },
    unwrap(X) {
      if ((X == null ? void 0 : X.stringValue) !== void 0)
        return X.stringValue;
      if ((X == null ? void 0 : X.numberValue) !== void 0)
        return X.numberValue;
      if ((X == null ? void 0 : X.boolValue) !== void 0)
        return X.boolValue;
      if ((X == null ? void 0 : X.structValue) !== void 0)
        return X.structValue;
      if ((X == null ? void 0 : X.listValue) !== void 0)
        return X.listValue;
      if ((X == null ? void 0 : X.nullValue) !== void 0)
        return null;
    }
  };
  function F() {
    return { values: [] };
  }
  a.ListValue = {
    encode(X, ne = c.default.Writer.create()) {
      for (const Q of X.values)
        a.Value.encode(a.Value.wrap(Q), ne.uint32(10).fork()).ldelim();
      return ne;
    },
    decode(X, ne) {
      const Q = X instanceof c.default.Reader ? X : new c.default.Reader(X);
      let ae = ne === void 0 ? Q.len : Q.pos + ne;
      const j = F();
      for (; Q.pos < ae; ) {
        const ue = Q.uint32();
        switch (ue >>> 3) {
          case 1:
            j.values.push(a.Value.unwrap(a.Value.decode(Q, Q.uint32())));
            break;
          default:
            Q.skipType(ue & 7);
            break;
        }
      }
      return j;
    },
    fromJSON(X) {
      return { values: Array.isArray(X == null ? void 0 : X.values) ? [...X.values] : [] };
    },
    toJSON(X) {
      const ne = {};
      return X.values ? ne.values = X.values.map((Q) => Q) : ne.values = [], ne;
    },
    fromPartial(X) {
      var ne;
      const Q = F();
      return Q.values = ((ne = X.values) === null || ne === void 0 ? void 0 : ne.map((ae) => ae)) || [], Q;
    },
    wrap(X) {
      const ne = F();
      return ne.values = X ?? [], ne;
    },
    unwrap(X) {
      return X.values;
    }
  };
  var H = (() => {
    if (typeof H < "u")
      return H;
    if (typeof self < "u")
      return self;
    if (typeof window < "u")
      return window;
    if (typeof commonjsGlobal$1 < "u")
      return commonjsGlobal$1;
    throw "Unable to locate global object";
  })();
  function Z(X) {
    return typeof X == "object" && X !== null;
  }
  function ee(X) {
    return X != null;
  }
})(struct$1);
var timestamp$2 = {}, __importDefault$9 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(timestamp$2, "__esModule", { value: !0 });
timestamp$2.Timestamp = timestamp$2.protobufPackage = void 0;
const long_1$2 = __importDefault$9(umdExports), minimal_1$2 = __importDefault$9(minimal);
timestamp$2.protobufPackage = "google.protobuf";
function createBaseTimestamp$1() {
  return { seconds: 0, nanos: 0 };
}
timestamp$2.Timestamp = {
  encode(a, u = minimal_1$2.default.Writer.create()) {
    return a.seconds !== 0 && u.uint32(8).int64(a.seconds), a.nanos !== 0 && u.uint32(16).int32(a.nanos), u;
  },
  decode(a, u) {
    const c = a instanceof minimal_1$2.default.Reader ? a : new minimal_1$2.default.Reader(a);
    let l = u === void 0 ? c.len : c.pos + u;
    const v = createBaseTimestamp$1();
    for (; c.pos < l; ) {
      const p = c.uint32();
      switch (p >>> 3) {
        case 1:
          v.seconds = longToNumber$2(c.int64());
          break;
        case 2:
          v.nanos = c.int32();
          break;
        default:
          c.skipType(p & 7);
          break;
      }
    }
    return v;
  },
  fromJSON(a) {
    return {
      seconds: isSet$3(a.seconds) ? Number(a.seconds) : 0,
      nanos: isSet$3(a.nanos) ? Number(a.nanos) : 0
    };
  },
  toJSON(a) {
    const u = {};
    return a.seconds !== void 0 && (u.seconds = Math.round(a.seconds)), a.nanos !== void 0 && (u.nanos = Math.round(a.nanos)), u;
  },
  fromPartial(a) {
    var u, c;
    const l = createBaseTimestamp$1();
    return l.seconds = (u = a.seconds) !== null && u !== void 0 ? u : 0, l.nanos = (c = a.nanos) !== null && c !== void 0 ? c : 0, l;
  }
};
var globalThis$3 = (() => {
  if (typeof globalThis$3 < "u")
    return globalThis$3;
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof commonjsGlobal$1 < "u")
    return commonjsGlobal$1;
  throw "Unable to locate global object";
})();
function longToNumber$2(a) {
  if (a.gt(Number.MAX_SAFE_INTEGER))
    throw new globalThis$3.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  return a.toNumber();
}
minimal_1$2.default.util.Long !== long_1$2.default && (minimal_1$2.default.util.Long = long_1$2.default, minimal_1$2.default.configure());
function isSet$3(a) {
  return a != null;
}
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(b) {
    return b && b.__esModule ? b : { default: b };
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.S3ACL = a.projectBroadcastPhaseToNumber = a.projectBroadcastPhaseToJSON = a.projectBroadcastPhaseFromJSON = a.ProjectBroadcastPhase = a.videoCodecRateControlModeToNumber = a.videoCodecRateControlModeToJSON = a.videoCodecRateControlModeFromJSON = a.VideoCodecRateControlMode = a.audioCodecToNumber = a.audioCodecToJSON = a.audioCodecFromJSON = a.AudioCodec = a.videoCodecProfileToNumber = a.videoCodecProfileToJSON = a.videoCodecProfileFromJSON = a.VideoCodecProfile = a.videoCodecToNumber = a.videoCodecToJSON = a.videoCodecFromJSON = a.VideoCodec = a.renderingQualityToNumber = a.renderingQualityToJSON = a.renderingQualityFromJSON = a.RenderingQuality = a.audioChannelLayoutToNumber = a.audioChannelLayoutToJSON = a.audioChannelLayoutFromJSON = a.AudioChannelLayout = a.videoColorSpaceToNumber = a.videoColorSpaceToJSON = a.videoColorSpaceFromJSON = a.VideoColorSpace = a.imageFormatToNumber = a.imageFormatToJSON = a.imageFormatFromJSON = a.ImageFormat = a.webhookSubtypeToNumber = a.webhookSubtypeToJSON = a.webhookSubtypeFromJSON = a.WebhookSubtype = a.webhookTypeToNumber = a.webhookTypeToJSON = a.webhookTypeFromJSON = a.WebhookType = a.broadcastTriggerToNumber = a.broadcastTriggerToJSON = a.broadcastTriggerFromJSON = a.BroadcastTrigger = a.protobufPackage = void 0, a.RtmpPullAddress = a.SrtPushAddress = a.SourceRtmpPushAddress = a.Encoding = a.AudioEncoding = a.VideoEncoding = a.VideoCodecRateControl = a.Rendering = a.AudioRendering = a.VideoRendering = a.UpdateAccountConfigurationResponse = a.UpdateAccountConfigurationRequest = a.GetAccountConfigurationResponse = a.GetAccountConfigurationRequest = a.AccountConfiguration = a.AccountConfigurationHook = a.WebhookConfiguration = a.WebhookResponse = a.WebhookRequest = a.eventTypeToNumber = a.eventTypeToJSON = a.eventTypeFromJSON = a.EventType = a.eventSubTypeToNumber = a.eventSubTypeToJSON = a.eventSubTypeFromJSON = a.EventSubType = a.connectStateToNumber = a.connectStateToJSON = a.connectStateFromJSON = a.ConnectState = a.projectBroadcastErrorToNumber = a.projectBroadcastErrorToJSON = a.projectBroadcastErrorFromJSON = a.ProjectBroadcastError = a.roleToNumber = a.roleToJSON = a.roleFromJSON = a.Role = a.regionToNumber = a.regionToJSON = a.regionFromJSON = a.Region = a.sourceTriggerActionToNumber = a.sourceTriggerActionToJSON = a.sourceTriggerActionFromJSON = a.SourceTriggerAction = a.s3ACLToNumber = a.s3ACLToJSON = a.s3ACLFromJSON = void 0, a.UpdateProjectResponse = a.UpdateProjectRequest = a.CreateProjectResponse = a.CreateProjectRequest = a.GetCollectionsResponse = a.GetCollectionsRequest = a.DeleteCollectionResponse = a.DeleteCollectionRequest = a.UpdateCollectionResponse = a.UpdateCollectionRequest = a.GetCollectionResponse = a.GetCollectionRequest = a.CreateCollectionResponse = a.CreateCollectionRequest = a.Collection = a.Project = a.Destination = a.Source = a.ProjectBroadcastStatus = a.DirectIngestUrl = a.LatLong = a.WebRtcAccess = a.WebRtc = a.HostedWebRtc = a.Composition = a.ExternalComposition = a.SceneComposition = a.StudioSdkComposition = a.PreviewAddress = a.PreviewWebRtcAddress = a.PreviewHlsPullAddress = a.ProjectTrigger = a.WebRtcTrigger = a.SourceTrigger = a.DestinationAddress = a.S3StorageAddress = a.ObjectStoragePackaging = a.HlsPackaging = a.HlsLifecycle = a.HlsLifecycleVod = a.HlsLifecycleLive = a.DestinationAgoraPushAddress = a.DestinationSrtPushAddress = a.DestinationRtmpPushAddress = a.SourceAddress = a.RuntimeSourceAddress = a.DirectSrtAddress = a.DirectRTMPAddress = a.DynamicAddress = a.SrtPullAddress = void 0, a.CreateGuestAccessTokenResponse = a.CreateGuestAccessTokenRequest = a.GuestAccessToken = a.GuestAccessTokenExchange = a.GuestAccessTokenDirect = a.CreateAccessTokenResponse = a.CreateAccessTokenRequest = a.GetSourcePlaylistResponse = a.GetSourcePlaylistRequest = a.RemoveSourceFromProjectResponse = a.RemoveSourceFromProjectRequest = a.UpdateSourceResponse = a.UpdateSourceRequest = a.GetSourcesResponse = a.GetSourcesRequest = a.GetSourceResponse = a.GetSourceRequest = a.UpdateSourceInProjectResponse = a.UpdateSourceInProjectRequest = a.AddSourceToProjectResponse = a.AddSourceToProjectRequest = a.DeleteSourceResponse = a.DeleteSourceRequest = a.CreateSourceResponse = a.CreateSourceRequest = a.UpdateDestinationResponse = a.UpdateDestinationRequest = a.DeleteDestinationResponse = a.DeleteDestinationRequest = a.GetDestinationResponse = a.GetDestinationRequest = a.CreateDestinationResponse = a.CreateDestinationRequest = a.StopProjectWebRtcResponse = a.StopProjectWebRtcRequest = a.StartProjectWebRtcResponse = a.StartProjectWebRtcRequest = a.GetProjectBroadcastStatusResponse = a.GetProjectBroadcastStatusRequest = a.GetProjectBroadcastSnapshotResponse = a.GetProjectBroadcastSnapshotRequest = a.GetProjectResponse = a.GetProjectRequest = a.StopProjectBroadcastResponse = a.StopProjectBroadcastRequest = a.StartProjectBroadcastResponse = a.StartProjectBroadcastRequest_DynamicSourcesEntry = a.StartProjectBroadcastRequest = a.DeleteProjectResponse = a.DeleteProjectRequest = void 0, a.PublicAuthenticationServiceDefinition = a.PublicAuthenticationServiceClientImpl = a.AuthenticationServiceDefinition = a.AuthenticationServiceClientImpl = a.BackendAuthenticationServiceDefinition = a.BackendAuthenticationServiceClientImpl = a.SourceServiceDefinition = a.SourceServiceClientImpl = a.DestinationServiceDefinition = a.DestinationServiceClientImpl = a.ProjectServiceDefinition = a.ProjectServiceClientImpl = a.CollectionServiceDefinition = a.CollectionServiceClientImpl = a.AccountConfigurationServiceDefinition = a.AccountConfigurationServiceClientImpl = a.LiveEvent = a.SourceEvent = a.ProjectEvent = a.DestinationEvent = a.CollectionEvent = a.SourceStateEvent = a.SourceRemoveEvent = a.SourceAddEvent = a.SourceUpdateEvent = a.SourceDeleteEvent = a.SourceCreateEvent = a.CollectionUpdateEvent = a.CollectionDeleteEvent = a.CollectionCreateEvent = a.ProjectBroadcastStateEvent = a.ProjectUpdateEvent = a.ProjectDeleteEvent = a.ProjectCreateEvent = a.DestinationStateEvent = a.DestinationUpdateEvent = a.DestinationDeleteEvent = a.DestinationCreateEvent = a.GetTestTokenResponse = a.GetTestTokenRequest = a.GetJsonWebKeySetResponse = a.GetJsonWebKeySetRequest = a.JsonWebKey = a.GuestCodeRedirectResponse = a.GuestCodeRedirectRequest = a.GuestCode = a.RefreshAccessTokenResponse = a.RefreshAccessTokenRequest = a.CreateWebRtcAccessTokenResponse = a.CreateWebRtcAccessTokenRequest = void 0;
  const c = u(minimal), l = httpbody, v = field_mask, p = struct$1, _ = timestamp$2;
  a.protobufPackage = "live.v21";
  var k;
  (function(b) {
    b.BROADCAST_TRIGGER_UNSPECIFIED = "BROADCAST_TRIGGER_UNSPECIFIED", b.BROADCAST_TRIGGER_API = "BROADCAST_TRIGGER_API", b.BROADCAST_TRIGGER_SOURCE = "BROADCAST_TRIGGER_SOURCE", b.BROADCAST_TRIGGER_INTEGRATION = "BROADCAST_TRIGGER_INTEGRATION";
  })(k = a.BroadcastTrigger || (a.BroadcastTrigger = {}));
  function O(b) {
    switch (b) {
      case 0:
      case "BROADCAST_TRIGGER_UNSPECIFIED":
        return k.BROADCAST_TRIGGER_UNSPECIFIED;
      case 1:
      case "BROADCAST_TRIGGER_API":
        return k.BROADCAST_TRIGGER_API;
      case 2:
      case "BROADCAST_TRIGGER_SOURCE":
        return k.BROADCAST_TRIGGER_SOURCE;
      case 3:
      case "BROADCAST_TRIGGER_INTEGRATION":
        return k.BROADCAST_TRIGGER_INTEGRATION;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum BroadcastTrigger");
    }
  }
  a.broadcastTriggerFromJSON = O;
  function D(b) {
    switch (b) {
      case k.BROADCAST_TRIGGER_UNSPECIFIED:
        return "BROADCAST_TRIGGER_UNSPECIFIED";
      case k.BROADCAST_TRIGGER_API:
        return "BROADCAST_TRIGGER_API";
      case k.BROADCAST_TRIGGER_SOURCE:
        return "BROADCAST_TRIGGER_SOURCE";
      case k.BROADCAST_TRIGGER_INTEGRATION:
        return "BROADCAST_TRIGGER_INTEGRATION";
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum BroadcastTrigger");
    }
  }
  a.broadcastTriggerToJSON = D;
  function F(b) {
    switch (b) {
      case k.BROADCAST_TRIGGER_UNSPECIFIED:
        return 0;
      case k.BROADCAST_TRIGGER_API:
        return 1;
      case k.BROADCAST_TRIGGER_SOURCE:
        return 2;
      case k.BROADCAST_TRIGGER_INTEGRATION:
        return 3;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum BroadcastTrigger");
    }
  }
  a.broadcastTriggerToNumber = F;
  var H;
  (function(b) {
    b.WEBHOOK_TYPE_UNSPECIFIED = "WEBHOOK_TYPE_UNSPECIFIED", b.WEBHOOK_TYPE_HOOK = "WEBHOOK_TYPE_HOOK", b.WEBHOOK_TYPE_EVENT = "WEBHOOK_TYPE_EVENT";
  })(H = a.WebhookType || (a.WebhookType = {}));
  function Z(b) {
    switch (b) {
      case 0:
      case "WEBHOOK_TYPE_UNSPECIFIED":
        return H.WEBHOOK_TYPE_UNSPECIFIED;
      case 1:
      case "WEBHOOK_TYPE_HOOK":
        return H.WEBHOOK_TYPE_HOOK;
      case 2:
      case "WEBHOOK_TYPE_EVENT":
        return H.WEBHOOK_TYPE_EVENT;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum WebhookType");
    }
  }
  a.webhookTypeFromJSON = Z;
  function ee(b) {
    switch (b) {
      case H.WEBHOOK_TYPE_UNSPECIFIED:
        return "WEBHOOK_TYPE_UNSPECIFIED";
      case H.WEBHOOK_TYPE_HOOK:
        return "WEBHOOK_TYPE_HOOK";
      case H.WEBHOOK_TYPE_EVENT:
        return "WEBHOOK_TYPE_EVENT";
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum WebhookType");
    }
  }
  a.webhookTypeToJSON = ee;
  function X(b) {
    switch (b) {
      case H.WEBHOOK_TYPE_UNSPECIFIED:
        return 0;
      case H.WEBHOOK_TYPE_HOOK:
        return 1;
      case H.WEBHOOK_TYPE_EVENT:
        return 2;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum WebhookType");
    }
  }
  a.webhookTypeToNumber = X;
  var ne;
  (function(b) {
    b.WEBHOOK_SUBTYPE_UNSPECIFIED = "WEBHOOK_SUBTYPE_UNSPECIFIED", b.WEBHOOK_SUBTYPE_START_BROADCAST = "WEBHOOK_SUBTYPE_START_BROADCAST", b.WEBHOOK_SUBTYPE_START_WEBRTC = "WEBHOOK_SUBTYPE_START_WEBRTC", b.WEBHOOK_SUBTYPE_JOIN_WEBRTC = "WEBHOOK_SUBTYPE_JOIN_WEBRTC";
  })(ne = a.WebhookSubtype || (a.WebhookSubtype = {}));
  function Q(b) {
    switch (b) {
      case 0:
      case "WEBHOOK_SUBTYPE_UNSPECIFIED":
        return ne.WEBHOOK_SUBTYPE_UNSPECIFIED;
      case 1:
      case "WEBHOOK_SUBTYPE_START_BROADCAST":
        return ne.WEBHOOK_SUBTYPE_START_BROADCAST;
      case 2:
      case "WEBHOOK_SUBTYPE_START_WEBRTC":
        return ne.WEBHOOK_SUBTYPE_START_WEBRTC;
      case 3:
      case "WEBHOOK_SUBTYPE_JOIN_WEBRTC":
        return ne.WEBHOOK_SUBTYPE_JOIN_WEBRTC;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum WebhookSubtype");
    }
  }
  a.webhookSubtypeFromJSON = Q;
  function ae(b) {
    switch (b) {
      case ne.WEBHOOK_SUBTYPE_UNSPECIFIED:
        return "WEBHOOK_SUBTYPE_UNSPECIFIED";
      case ne.WEBHOOK_SUBTYPE_START_BROADCAST:
        return "WEBHOOK_SUBTYPE_START_BROADCAST";
      case ne.WEBHOOK_SUBTYPE_START_WEBRTC:
        return "WEBHOOK_SUBTYPE_START_WEBRTC";
      case ne.WEBHOOK_SUBTYPE_JOIN_WEBRTC:
        return "WEBHOOK_SUBTYPE_JOIN_WEBRTC";
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum WebhookSubtype");
    }
  }
  a.webhookSubtypeToJSON = ae;
  function j(b) {
    switch (b) {
      case ne.WEBHOOK_SUBTYPE_UNSPECIFIED:
        return 0;
      case ne.WEBHOOK_SUBTYPE_START_BROADCAST:
        return 1;
      case ne.WEBHOOK_SUBTYPE_START_WEBRTC:
        return 2;
      case ne.WEBHOOK_SUBTYPE_JOIN_WEBRTC:
        return 3;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum WebhookSubtype");
    }
  }
  a.webhookSubtypeToNumber = j;
  var ue;
  (function(b) {
    b.IMAGE_FORMAT_UNSPECIFIED = "IMAGE_FORMAT_UNSPECIFIED", b.IMAGE_FORMAT_JPEG = "IMAGE_FORMAT_JPEG";
  })(ue = a.ImageFormat || (a.ImageFormat = {}));
  function he(b) {
    switch (b) {
      case 0:
      case "IMAGE_FORMAT_UNSPECIFIED":
        return ue.IMAGE_FORMAT_UNSPECIFIED;
      case 1:
      case "IMAGE_FORMAT_JPEG":
        return ue.IMAGE_FORMAT_JPEG;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum ImageFormat");
    }
  }
  a.imageFormatFromJSON = he;
  function fe(b) {
    switch (b) {
      case ue.IMAGE_FORMAT_UNSPECIFIED:
        return "IMAGE_FORMAT_UNSPECIFIED";
      case ue.IMAGE_FORMAT_JPEG:
        return "IMAGE_FORMAT_JPEG";
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum ImageFormat");
    }
  }
  a.imageFormatToJSON = fe;
  function be(b) {
    switch (b) {
      case ue.IMAGE_FORMAT_UNSPECIFIED:
        return 0;
      case ue.IMAGE_FORMAT_JPEG:
        return 1;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum ImageFormat");
    }
  }
  a.imageFormatToNumber = be;
  var ke;
  (function(b) {
    b.VIDEO_COLOR_SPACE_UNSPECIFIED = "VIDEO_COLOR_SPACE_UNSPECIFIED", b.VIDEO_COLOR_SPACE_YUV420 = "VIDEO_COLOR_SPACE_YUV420";
  })(ke = a.VideoColorSpace || (a.VideoColorSpace = {}));
  function Te(b) {
    switch (b) {
      case 0:
      case "VIDEO_COLOR_SPACE_UNSPECIFIED":
        return ke.VIDEO_COLOR_SPACE_UNSPECIFIED;
      case 1:
      case "VIDEO_COLOR_SPACE_YUV420":
        return ke.VIDEO_COLOR_SPACE_YUV420;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum VideoColorSpace");
    }
  }
  a.videoColorSpaceFromJSON = Te;
  function q(b) {
    switch (b) {
      case ke.VIDEO_COLOR_SPACE_UNSPECIFIED:
        return "VIDEO_COLOR_SPACE_UNSPECIFIED";
      case ke.VIDEO_COLOR_SPACE_YUV420:
        return "VIDEO_COLOR_SPACE_YUV420";
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum VideoColorSpace");
    }
  }
  a.videoColorSpaceToJSON = q;
  function z(b) {
    switch (b) {
      case ke.VIDEO_COLOR_SPACE_UNSPECIFIED:
        return 0;
      case ke.VIDEO_COLOR_SPACE_YUV420:
        return 1;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum VideoColorSpace");
    }
  }
  a.videoColorSpaceToNumber = z;
  var P;
  (function(b) {
    b.AUDIO_CHANNEL_LAYOUT_UNSPECIFIED = "AUDIO_CHANNEL_LAYOUT_UNSPECIFIED", b.AUDIO_CHANNEL_LAYOUT_STEREO = "AUDIO_CHANNEL_LAYOUT_STEREO";
  })(P = a.AudioChannelLayout || (a.AudioChannelLayout = {}));
  function S(b) {
    switch (b) {
      case 0:
      case "AUDIO_CHANNEL_LAYOUT_UNSPECIFIED":
        return P.AUDIO_CHANNEL_LAYOUT_UNSPECIFIED;
      case 1:
      case "AUDIO_CHANNEL_LAYOUT_STEREO":
        return P.AUDIO_CHANNEL_LAYOUT_STEREO;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum AudioChannelLayout");
    }
  }
  a.audioChannelLayoutFromJSON = S;
  function E(b) {
    switch (b) {
      case P.AUDIO_CHANNEL_LAYOUT_UNSPECIFIED:
        return "AUDIO_CHANNEL_LAYOUT_UNSPECIFIED";
      case P.AUDIO_CHANNEL_LAYOUT_STEREO:
        return "AUDIO_CHANNEL_LAYOUT_STEREO";
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum AudioChannelLayout");
    }
  }
  a.audioChannelLayoutToJSON = E;
  function I(b) {
    switch (b) {
      case P.AUDIO_CHANNEL_LAYOUT_UNSPECIFIED:
        return 0;
      case P.AUDIO_CHANNEL_LAYOUT_STEREO:
        return 1;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum AudioChannelLayout");
    }
  }
  a.audioChannelLayoutToNumber = I;
  var M;
  (function(b) {
    b.RENDERING_QUALITY_UNSPECIFIED = "RENDERING_QUALITY_UNSPECIFIED", b.RENDERING_QUALITY_STANDARD = "RENDERING_QUALITY_STANDARD", b.RENDERING_QUALITY_HIGH = "RENDERING_QUALITY_HIGH";
  })(M = a.RenderingQuality || (a.RenderingQuality = {}));
  function $(b) {
    switch (b) {
      case 0:
      case "RENDERING_QUALITY_UNSPECIFIED":
        return M.RENDERING_QUALITY_UNSPECIFIED;
      case 1:
      case "RENDERING_QUALITY_STANDARD":
        return M.RENDERING_QUALITY_STANDARD;
      case 2:
      case "RENDERING_QUALITY_HIGH":
        return M.RENDERING_QUALITY_HIGH;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum RenderingQuality");
    }
  }
  a.renderingQualityFromJSON = $;
  function U(b) {
    switch (b) {
      case M.RENDERING_QUALITY_UNSPECIFIED:
        return "RENDERING_QUALITY_UNSPECIFIED";
      case M.RENDERING_QUALITY_STANDARD:
        return "RENDERING_QUALITY_STANDARD";
      case M.RENDERING_QUALITY_HIGH:
        return "RENDERING_QUALITY_HIGH";
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum RenderingQuality");
    }
  }
  a.renderingQualityToJSON = U;
  function Y(b) {
    switch (b) {
      case M.RENDERING_QUALITY_UNSPECIFIED:
        return 0;
      case M.RENDERING_QUALITY_STANDARD:
        return 1;
      case M.RENDERING_QUALITY_HIGH:
        return 2;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum RenderingQuality");
    }
  }
  a.renderingQualityToNumber = Y;
  var B;
  (function(b) {
    b.VIDEO_CODEC_UNSPECIFIED = "VIDEO_CODEC_UNSPECIFIED", b.VIDEO_CODEC_H264 = "VIDEO_CODEC_H264";
  })(B = a.VideoCodec || (a.VideoCodec = {}));
  function T(b) {
    switch (b) {
      case 0:
      case "VIDEO_CODEC_UNSPECIFIED":
        return B.VIDEO_CODEC_UNSPECIFIED;
      case 1:
      case "VIDEO_CODEC_H264":
        return B.VIDEO_CODEC_H264;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum VideoCodec");
    }
  }
  a.videoCodecFromJSON = T;
  function L(b) {
    switch (b) {
      case B.VIDEO_CODEC_UNSPECIFIED:
        return "VIDEO_CODEC_UNSPECIFIED";
      case B.VIDEO_CODEC_H264:
        return "VIDEO_CODEC_H264";
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum VideoCodec");
    }
  }
  a.videoCodecToJSON = L;
  function te(b) {
    switch (b) {
      case B.VIDEO_CODEC_UNSPECIFIED:
        return 0;
      case B.VIDEO_CODEC_H264:
        return 1;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum VideoCodec");
    }
  }
  a.videoCodecToNumber = te;
  var me;
  (function(b) {
    b.VIDEO_CODEC_PROFILE_UNSPECIFIED = "VIDEO_CODEC_PROFILE_UNSPECIFIED", b.VIDEO_CODEC_PROFILE_BASELINE = "VIDEO_CODEC_PROFILE_BASELINE", b.VIDEO_CODEC_PROFILE_MAIN = "VIDEO_CODEC_PROFILE_MAIN", b.VIDEO_CODEC_PROFILE_HIGH = "VIDEO_CODEC_PROFILE_HIGH";
  })(me = a.VideoCodecProfile || (a.VideoCodecProfile = {}));
  function Ce(b) {
    switch (b) {
      case 0:
      case "VIDEO_CODEC_PROFILE_UNSPECIFIED":
        return me.VIDEO_CODEC_PROFILE_UNSPECIFIED;
      case 2:
      case "VIDEO_CODEC_PROFILE_BASELINE":
        return me.VIDEO_CODEC_PROFILE_BASELINE;
      case 3:
      case "VIDEO_CODEC_PROFILE_MAIN":
        return me.VIDEO_CODEC_PROFILE_MAIN;
      case 4:
      case "VIDEO_CODEC_PROFILE_HIGH":
        return me.VIDEO_CODEC_PROFILE_HIGH;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum VideoCodecProfile");
    }
  }
  a.videoCodecProfileFromJSON = Ce;
  function De(b) {
    switch (b) {
      case me.VIDEO_CODEC_PROFILE_UNSPECIFIED:
        return "VIDEO_CODEC_PROFILE_UNSPECIFIED";
      case me.VIDEO_CODEC_PROFILE_BASELINE:
        return "VIDEO_CODEC_PROFILE_BASELINE";
      case me.VIDEO_CODEC_PROFILE_MAIN:
        return "VIDEO_CODEC_PROFILE_MAIN";
      case me.VIDEO_CODEC_PROFILE_HIGH:
        return "VIDEO_CODEC_PROFILE_HIGH";
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum VideoCodecProfile");
    }
  }
  a.videoCodecProfileToJSON = De;
  function ye(b) {
    switch (b) {
      case me.VIDEO_CODEC_PROFILE_UNSPECIFIED:
        return 0;
      case me.VIDEO_CODEC_PROFILE_BASELINE:
        return 2;
      case me.VIDEO_CODEC_PROFILE_MAIN:
        return 3;
      case me.VIDEO_CODEC_PROFILE_HIGH:
        return 4;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum VideoCodecProfile");
    }
  }
  a.videoCodecProfileToNumber = ye;
  var pe;
  (function(b) {
    b.AUDIO_CODEC_UNSPECIFIED = "AUDIO_CODEC_UNSPECIFIED", b.AUDIO_CODEC_AAC = "AUDIO_CODEC_AAC";
  })(pe = a.AudioCodec || (a.AudioCodec = {}));
  function Me(b) {
    switch (b) {
      case 0:
      case "AUDIO_CODEC_UNSPECIFIED":
        return pe.AUDIO_CODEC_UNSPECIFIED;
      case 1:
      case "AUDIO_CODEC_AAC":
        return pe.AUDIO_CODEC_AAC;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum AudioCodec");
    }
  }
  a.audioCodecFromJSON = Me;
  function Ne(b) {
    switch (b) {
      case pe.AUDIO_CODEC_UNSPECIFIED:
        return "AUDIO_CODEC_UNSPECIFIED";
      case pe.AUDIO_CODEC_AAC:
        return "AUDIO_CODEC_AAC";
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum AudioCodec");
    }
  }
  a.audioCodecToJSON = Ne;
  function Ue(b) {
    switch (b) {
      case pe.AUDIO_CODEC_UNSPECIFIED:
        return 0;
      case pe.AUDIO_CODEC_AAC:
        return 1;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum AudioCodec");
    }
  }
  a.audioCodecToNumber = Ue;
  var oe;
  (function(b) {
    b.VIDEO_CODEC_RATE_CONTROL_MODE_UNSPECIFIED = "VIDEO_CODEC_RATE_CONTROL_MODE_UNSPECIFIED", b.VIDEO_CODEC_RATE_CONTROL_MODE_CBR = "VIDEO_CODEC_RATE_CONTROL_MODE_CBR";
  })(oe = a.VideoCodecRateControlMode || (a.VideoCodecRateControlMode = {}));
  function A(b) {
    switch (b) {
      case 0:
      case "VIDEO_CODEC_RATE_CONTROL_MODE_UNSPECIFIED":
        return oe.VIDEO_CODEC_RATE_CONTROL_MODE_UNSPECIFIED;
      case 1:
      case "VIDEO_CODEC_RATE_CONTROL_MODE_CBR":
        return oe.VIDEO_CODEC_RATE_CONTROL_MODE_CBR;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum VideoCodecRateControlMode");
    }
  }
  a.videoCodecRateControlModeFromJSON = A;
  function re(b) {
    switch (b) {
      case oe.VIDEO_CODEC_RATE_CONTROL_MODE_UNSPECIFIED:
        return "VIDEO_CODEC_RATE_CONTROL_MODE_UNSPECIFIED";
      case oe.VIDEO_CODEC_RATE_CONTROL_MODE_CBR:
        return "VIDEO_CODEC_RATE_CONTROL_MODE_CBR";
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum VideoCodecRateControlMode");
    }
  }
  a.videoCodecRateControlModeToJSON = re;
  function le(b) {
    switch (b) {
      case oe.VIDEO_CODEC_RATE_CONTROL_MODE_UNSPECIFIED:
        return 0;
      case oe.VIDEO_CODEC_RATE_CONTROL_MODE_CBR:
        return 1;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum VideoCodecRateControlMode");
    }
  }
  a.videoCodecRateControlModeToNumber = le;
  var $e;
  (function(b) {
    b.PROJECT_BROADCAST_PHASE_UNSPECIFIED = "PROJECT_BROADCAST_PHASE_UNSPECIFIED", b.PROJECT_BROADCAST_PHASE_NOT_RUNNING = "PROJECT_BROADCAST_PHASE_NOT_RUNNING", b.PROJECT_BROADCAST_PHASE_WAITING = "PROJECT_BROADCAST_PHASE_WAITING", b.PROJECT_BROADCAST_PHASE_STARTING = "PROJECT_BROADCAST_PHASE_STARTING", b.PROJECT_BROADCAST_PHASE_RUNNING = "PROJECT_BROADCAST_PHASE_RUNNING", b.PROJECT_BROADCAST_PHASE_STOPPING = "PROJECT_BROADCAST_PHASE_STOPPING", b.PROJECT_BROADCAST_PHASE_STOPPED = "PROJECT_BROADCAST_PHASE_STOPPED", b.PROJECT_BROADCAST_PHASE_ARCHIVED = "PROJECT_BROADCAST_PHASE_ARCHIVED";
  })($e = a.ProjectBroadcastPhase || (a.ProjectBroadcastPhase = {}));
  function Oe(b) {
    switch (b) {
      case 0:
      case "PROJECT_BROADCAST_PHASE_UNSPECIFIED":
        return $e.PROJECT_BROADCAST_PHASE_UNSPECIFIED;
      case 1:
      case "PROJECT_BROADCAST_PHASE_NOT_RUNNING":
        return $e.PROJECT_BROADCAST_PHASE_NOT_RUNNING;
      case 2:
      case "PROJECT_BROADCAST_PHASE_WAITING":
        return $e.PROJECT_BROADCAST_PHASE_WAITING;
      case 3:
      case "PROJECT_BROADCAST_PHASE_STARTING":
        return $e.PROJECT_BROADCAST_PHASE_STARTING;
      case 4:
      case "PROJECT_BROADCAST_PHASE_RUNNING":
        return $e.PROJECT_BROADCAST_PHASE_RUNNING;
      case 5:
      case "PROJECT_BROADCAST_PHASE_STOPPING":
        return $e.PROJECT_BROADCAST_PHASE_STOPPING;
      case 6:
      case "PROJECT_BROADCAST_PHASE_STOPPED":
        return $e.PROJECT_BROADCAST_PHASE_STOPPED;
      case 7:
      case "PROJECT_BROADCAST_PHASE_ARCHIVED":
        return $e.PROJECT_BROADCAST_PHASE_ARCHIVED;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum ProjectBroadcastPhase");
    }
  }
  a.projectBroadcastPhaseFromJSON = Oe;
  function Fe(b) {
    switch (b) {
      case $e.PROJECT_BROADCAST_PHASE_UNSPECIFIED:
        return "PROJECT_BROADCAST_PHASE_UNSPECIFIED";
      case $e.PROJECT_BROADCAST_PHASE_NOT_RUNNING:
        return "PROJECT_BROADCAST_PHASE_NOT_RUNNING";
      case $e.PROJECT_BROADCAST_PHASE_WAITING:
        return "PROJECT_BROADCAST_PHASE_WAITING";
      case $e.PROJECT_BROADCAST_PHASE_STARTING:
        return "PROJECT_BROADCAST_PHASE_STARTING";
      case $e.PROJECT_BROADCAST_PHASE_RUNNING:
        return "PROJECT_BROADCAST_PHASE_RUNNING";
      case $e.PROJECT_BROADCAST_PHASE_STOPPING:
        return "PROJECT_BROADCAST_PHASE_STOPPING";
      case $e.PROJECT_BROADCAST_PHASE_STOPPED:
        return "PROJECT_BROADCAST_PHASE_STOPPED";
      case $e.PROJECT_BROADCAST_PHASE_ARCHIVED:
        return "PROJECT_BROADCAST_PHASE_ARCHIVED";
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum ProjectBroadcastPhase");
    }
  }
  a.projectBroadcastPhaseToJSON = Fe;
  function Ze(b) {
    switch (b) {
      case $e.PROJECT_BROADCAST_PHASE_UNSPECIFIED:
        return 0;
      case $e.PROJECT_BROADCAST_PHASE_NOT_RUNNING:
        return 1;
      case $e.PROJECT_BROADCAST_PHASE_WAITING:
        return 2;
      case $e.PROJECT_BROADCAST_PHASE_STARTING:
        return 3;
      case $e.PROJECT_BROADCAST_PHASE_RUNNING:
        return 4;
      case $e.PROJECT_BROADCAST_PHASE_STOPPING:
        return 5;
      case $e.PROJECT_BROADCAST_PHASE_STOPPED:
        return 6;
      case $e.PROJECT_BROADCAST_PHASE_ARCHIVED:
        return 7;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum ProjectBroadcastPhase");
    }
  }
  a.projectBroadcastPhaseToNumber = Ze;
  var qe;
  (function(b) {
    b.S3ACL_UNSPECIFIED = "S3ACL_UNSPECIFIED", b.S3ACL_PRIVATE = "S3ACL_PRIVATE", b.S3ACL_PUBLIC_READ = "S3ACL_PUBLIC_READ", b.S3ACL_PUBLIC_READ_WRITE = "S3ACL_PUBLIC_READ_WRITE", b.S3ACL_AUTHENTICATED_READ = "S3ACL_AUTHENTICATED_READ", b.S3ACL_BUCKET_OWNER_READ = "S3ACL_BUCKET_OWNER_READ", b.S3ACL_BUCKET_OWNER_FULL_CONTROL = "S3ACL_BUCKET_OWNER_FULL_CONTROL";
  })(qe = a.S3ACL || (a.S3ACL = {}));
  function yt(b) {
    switch (b) {
      case 0:
      case "S3ACL_UNSPECIFIED":
        return qe.S3ACL_UNSPECIFIED;
      case 1:
      case "S3ACL_PRIVATE":
        return qe.S3ACL_PRIVATE;
      case 2:
      case "S3ACL_PUBLIC_READ":
        return qe.S3ACL_PUBLIC_READ;
      case 3:
      case "S3ACL_PUBLIC_READ_WRITE":
        return qe.S3ACL_PUBLIC_READ_WRITE;
      case 4:
      case "S3ACL_AUTHENTICATED_READ":
        return qe.S3ACL_AUTHENTICATED_READ;
      case 5:
      case "S3ACL_BUCKET_OWNER_READ":
        return qe.S3ACL_BUCKET_OWNER_READ;
      case 6:
      case "S3ACL_BUCKET_OWNER_FULL_CONTROL":
        return qe.S3ACL_BUCKET_OWNER_FULL_CONTROL;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum S3ACL");
    }
  }
  a.s3ACLFromJSON = yt;
  function Xe(b) {
    switch (b) {
      case qe.S3ACL_UNSPECIFIED:
        return "S3ACL_UNSPECIFIED";
      case qe.S3ACL_PRIVATE:
        return "S3ACL_PRIVATE";
      case qe.S3ACL_PUBLIC_READ:
        return "S3ACL_PUBLIC_READ";
      case qe.S3ACL_PUBLIC_READ_WRITE:
        return "S3ACL_PUBLIC_READ_WRITE";
      case qe.S3ACL_AUTHENTICATED_READ:
        return "S3ACL_AUTHENTICATED_READ";
      case qe.S3ACL_BUCKET_OWNER_READ:
        return "S3ACL_BUCKET_OWNER_READ";
      case qe.S3ACL_BUCKET_OWNER_FULL_CONTROL:
        return "S3ACL_BUCKET_OWNER_FULL_CONTROL";
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum S3ACL");
    }
  }
  a.s3ACLToJSON = Xe;
  function Ge(b) {
    switch (b) {
      case qe.S3ACL_UNSPECIFIED:
        return 0;
      case qe.S3ACL_PRIVATE:
        return 1;
      case qe.S3ACL_PUBLIC_READ:
        return 2;
      case qe.S3ACL_PUBLIC_READ_WRITE:
        return 3;
      case qe.S3ACL_AUTHENTICATED_READ:
        return 4;
      case qe.S3ACL_BUCKET_OWNER_READ:
        return 5;
      case qe.S3ACL_BUCKET_OWNER_FULL_CONTROL:
        return 6;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum S3ACL");
    }
  }
  a.s3ACLToNumber = Ge;
  var J;
  (function(b) {
    b.SOURCE_TRIGGER_ACTION_UNSPECIFIED = "SOURCE_TRIGGER_ACTION_UNSPECIFIED", b.SOURCE_TRIGGER_ACTION_IGNORE = "SOURCE_TRIGGER_ACTION_IGNORE", b.SOURCE_TRIGGER_ACTION_OR = "SOURCE_TRIGGER_ACTION_OR";
  })(J = a.SourceTriggerAction || (a.SourceTriggerAction = {}));
  function ge(b) {
    switch (b) {
      case 0:
      case "SOURCE_TRIGGER_ACTION_UNSPECIFIED":
        return J.SOURCE_TRIGGER_ACTION_UNSPECIFIED;
      case 1:
      case "SOURCE_TRIGGER_ACTION_IGNORE":
        return J.SOURCE_TRIGGER_ACTION_IGNORE;
      case 3:
      case "SOURCE_TRIGGER_ACTION_OR":
        return J.SOURCE_TRIGGER_ACTION_OR;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum SourceTriggerAction");
    }
  }
  a.sourceTriggerActionFromJSON = ge;
  function we(b) {
    switch (b) {
      case J.SOURCE_TRIGGER_ACTION_UNSPECIFIED:
        return "SOURCE_TRIGGER_ACTION_UNSPECIFIED";
      case J.SOURCE_TRIGGER_ACTION_IGNORE:
        return "SOURCE_TRIGGER_ACTION_IGNORE";
      case J.SOURCE_TRIGGER_ACTION_OR:
        return "SOURCE_TRIGGER_ACTION_OR";
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum SourceTriggerAction");
    }
  }
  a.sourceTriggerActionToJSON = we;
  function We(b) {
    switch (b) {
      case J.SOURCE_TRIGGER_ACTION_UNSPECIFIED:
        return 0;
      case J.SOURCE_TRIGGER_ACTION_IGNORE:
        return 1;
      case J.SOURCE_TRIGGER_ACTION_OR:
        return 3;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum SourceTriggerAction");
    }
  }
  a.sourceTriggerActionToNumber = We;
  var Ie;
  (function(b) {
    b.REGION_UNSPECIFIED = "REGION_UNSPECIFIED", b.REGION_US_EAST_1 = "REGION_US_EAST_1", b.REGION_US_EAST_2 = "REGION_US_EAST_2", b.REGION_US_WEST_1 = "REGION_US_WEST_1", b.REGION_US_WEST_2 = "REGION_US_WEST_2", b.REGION_US_CENTRAL_1 = "REGION_US_CENTRAL_1", b.REGION_AP_SOUTHEAST_1 = "REGION_AP_SOUTHEAST_1", b.REGION_AP_SOUTHEAST_2 = "REGION_AP_SOUTHEAST_2", b.REGION_AP_SOUTH_1 = "REGION_AP_SOUTH_1", b.REGION_CA_EAST_1 = "REGION_CA_EAST_1", b.REGION_EU_CENTRAL_1 = "REGION_EU_CENTRAL_1", b.REGION_EU_WEST_1 = "REGION_EU_WEST_1";
  })(Ie = a.Region || (a.Region = {}));
  function V(b) {
    switch (b) {
      case 0:
      case "REGION_UNSPECIFIED":
        return Ie.REGION_UNSPECIFIED;
      case 1:
      case "REGION_US_EAST_1":
        return Ie.REGION_US_EAST_1;
      case 2:
      case "REGION_US_EAST_2":
        return Ie.REGION_US_EAST_2;
      case 3:
      case "REGION_US_WEST_1":
        return Ie.REGION_US_WEST_1;
      case 4:
      case "REGION_US_WEST_2":
        return Ie.REGION_US_WEST_2;
      case 5:
      case "REGION_US_CENTRAL_1":
        return Ie.REGION_US_CENTRAL_1;
      case 10:
      case "REGION_AP_SOUTHEAST_1":
        return Ie.REGION_AP_SOUTHEAST_1;
      case 11:
      case "REGION_AP_SOUTHEAST_2":
        return Ie.REGION_AP_SOUTHEAST_2;
      case 15:
      case "REGION_AP_SOUTH_1":
        return Ie.REGION_AP_SOUTH_1;
      case 20:
      case "REGION_CA_EAST_1":
        return Ie.REGION_CA_EAST_1;
      case 30:
      case "REGION_EU_CENTRAL_1":
        return Ie.REGION_EU_CENTRAL_1;
      case 31:
      case "REGION_EU_WEST_1":
        return Ie.REGION_EU_WEST_1;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum Region");
    }
  }
  a.regionFromJSON = V;
  function Ee(b) {
    switch (b) {
      case Ie.REGION_UNSPECIFIED:
        return "REGION_UNSPECIFIED";
      case Ie.REGION_US_EAST_1:
        return "REGION_US_EAST_1";
      case Ie.REGION_US_EAST_2:
        return "REGION_US_EAST_2";
      case Ie.REGION_US_WEST_1:
        return "REGION_US_WEST_1";
      case Ie.REGION_US_WEST_2:
        return "REGION_US_WEST_2";
      case Ie.REGION_US_CENTRAL_1:
        return "REGION_US_CENTRAL_1";
      case Ie.REGION_AP_SOUTHEAST_1:
        return "REGION_AP_SOUTHEAST_1";
      case Ie.REGION_AP_SOUTHEAST_2:
        return "REGION_AP_SOUTHEAST_2";
      case Ie.REGION_AP_SOUTH_1:
        return "REGION_AP_SOUTH_1";
      case Ie.REGION_CA_EAST_1:
        return "REGION_CA_EAST_1";
      case Ie.REGION_EU_CENTRAL_1:
        return "REGION_EU_CENTRAL_1";
      case Ie.REGION_EU_WEST_1:
        return "REGION_EU_WEST_1";
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum Region");
    }
  }
  a.regionToJSON = Ee;
  function de(b) {
    switch (b) {
      case Ie.REGION_UNSPECIFIED:
        return 0;
      case Ie.REGION_US_EAST_1:
        return 1;
      case Ie.REGION_US_EAST_2:
        return 2;
      case Ie.REGION_US_WEST_1:
        return 3;
      case Ie.REGION_US_WEST_2:
        return 4;
      case Ie.REGION_US_CENTRAL_1:
        return 5;
      case Ie.REGION_AP_SOUTHEAST_1:
        return 10;
      case Ie.REGION_AP_SOUTHEAST_2:
        return 11;
      case Ie.REGION_AP_SOUTH_1:
        return 15;
      case Ie.REGION_CA_EAST_1:
        return 20;
      case Ie.REGION_EU_CENTRAL_1:
        return 30;
      case Ie.REGION_EU_WEST_1:
        return 31;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum Region");
    }
  }
  a.regionToNumber = de;
  var ce;
  (function(b) {
    b.ROLE_UNSPECIFIED = "ROLE_UNSPECIFIED", b.ROLE_HOST = "ROLE_HOST", b.ROLE_COHOST = "ROLE_COHOST", b.ROLE_CONTRIBUTOR = "ROLE_CONTRIBUTOR", b.ROLE_GUEST = "ROLE_GUEST", b.ROLE_VIEWER = "ROLE_VIEWER", b.ROLE_RENDERER = "ROLE_RENDERER", b.ROLE_PLATFORM = "ROLE_PLATFORM", b.ROLE_IMPERSONATE = "ROLE_IMPERSONATE";
  })(ce = a.Role || (a.Role = {}));
  function ve(b) {
    switch (b) {
      case 0:
      case "ROLE_UNSPECIFIED":
        return ce.ROLE_UNSPECIFIED;
      case 1:
      case "ROLE_HOST":
        return ce.ROLE_HOST;
      case 2:
      case "ROLE_COHOST":
        return ce.ROLE_COHOST;
      case 3:
      case "ROLE_CONTRIBUTOR":
        return ce.ROLE_CONTRIBUTOR;
      case 4:
      case "ROLE_GUEST":
        return ce.ROLE_GUEST;
      case 5:
      case "ROLE_VIEWER":
        return ce.ROLE_VIEWER;
      case 6:
      case "ROLE_RENDERER":
        return ce.ROLE_RENDERER;
      case 7:
      case "ROLE_PLATFORM":
        return ce.ROLE_PLATFORM;
      case 8:
      case "ROLE_IMPERSONATE":
        return ce.ROLE_IMPERSONATE;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum Role");
    }
  }
  a.roleFromJSON = ve;
  function Pe(b) {
    switch (b) {
      case ce.ROLE_UNSPECIFIED:
        return "ROLE_UNSPECIFIED";
      case ce.ROLE_HOST:
        return "ROLE_HOST";
      case ce.ROLE_COHOST:
        return "ROLE_COHOST";
      case ce.ROLE_CONTRIBUTOR:
        return "ROLE_CONTRIBUTOR";
      case ce.ROLE_GUEST:
        return "ROLE_GUEST";
      case ce.ROLE_VIEWER:
        return "ROLE_VIEWER";
      case ce.ROLE_RENDERER:
        return "ROLE_RENDERER";
      case ce.ROLE_PLATFORM:
        return "ROLE_PLATFORM";
      case ce.ROLE_IMPERSONATE:
        return "ROLE_IMPERSONATE";
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum Role");
    }
  }
  a.roleToJSON = Pe;
  function Be(b) {
    switch (b) {
      case ce.ROLE_UNSPECIFIED:
        return 0;
      case ce.ROLE_HOST:
        return 1;
      case ce.ROLE_COHOST:
        return 2;
      case ce.ROLE_CONTRIBUTOR:
        return 3;
      case ce.ROLE_GUEST:
        return 4;
      case ce.ROLE_VIEWER:
        return 5;
      case ce.ROLE_RENDERER:
        return 6;
      case ce.ROLE_PLATFORM:
        return 7;
      case ce.ROLE_IMPERSONATE:
        return 8;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum Role");
    }
  }
  a.roleToNumber = Be;
  var ze;
  (function(b) {
    b.PROJECT_BROADCAST_ERROR_UNSPECIFIED = "PROJECT_BROADCAST_ERROR_UNSPECIFIED", b.PROJECT_BROADCAST_ERROR_INTERNAL = "PROJECT_BROADCAST_ERROR_INTERNAL", b.PROJECT_BROADCAST_ERROR_DURATION_EXCEEDED = "PROJECT_BROADCAST_ERROR_DURATION_EXCEEDED";
  })(ze = a.ProjectBroadcastError || (a.ProjectBroadcastError = {}));
  function Je(b) {
    switch (b) {
      case 0:
      case "PROJECT_BROADCAST_ERROR_UNSPECIFIED":
        return ze.PROJECT_BROADCAST_ERROR_UNSPECIFIED;
      case 1:
      case "PROJECT_BROADCAST_ERROR_INTERNAL":
        return ze.PROJECT_BROADCAST_ERROR_INTERNAL;
      case 2:
      case "PROJECT_BROADCAST_ERROR_DURATION_EXCEEDED":
        return ze.PROJECT_BROADCAST_ERROR_DURATION_EXCEEDED;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum ProjectBroadcastError");
    }
  }
  a.projectBroadcastErrorFromJSON = Je;
  function je(b) {
    switch (b) {
      case ze.PROJECT_BROADCAST_ERROR_UNSPECIFIED:
        return "PROJECT_BROADCAST_ERROR_UNSPECIFIED";
      case ze.PROJECT_BROADCAST_ERROR_INTERNAL:
        return "PROJECT_BROADCAST_ERROR_INTERNAL";
      case ze.PROJECT_BROADCAST_ERROR_DURATION_EXCEEDED:
        return "PROJECT_BROADCAST_ERROR_DURATION_EXCEEDED";
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum ProjectBroadcastError");
    }
  }
  a.projectBroadcastErrorToJSON = je;
  function Ke(b) {
    switch (b) {
      case ze.PROJECT_BROADCAST_ERROR_UNSPECIFIED:
        return 0;
      case ze.PROJECT_BROADCAST_ERROR_INTERNAL:
        return 1;
      case ze.PROJECT_BROADCAST_ERROR_DURATION_EXCEEDED:
        return 2;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum ProjectBroadcastError");
    }
  }
  a.projectBroadcastErrorToNumber = Ke;
  var x;
  (function(b) {
    b.CONNECT_STATE_UNSPECIFIED = "CONNECT_STATE_UNSPECIFIED", b.CONNECT_STATE_CONNECTED = "CONNECT_STATE_CONNECTED", b.CONNECT_STATE_DISCONNECTED = "CONNECT_STATE_DISCONNECTED";
  })(x = a.ConnectState || (a.ConnectState = {}));
  function se(b) {
    switch (b) {
      case 0:
      case "CONNECT_STATE_UNSPECIFIED":
        return x.CONNECT_STATE_UNSPECIFIED;
      case 1:
      case "CONNECT_STATE_CONNECTED":
        return x.CONNECT_STATE_CONNECTED;
      case 2:
      case "CONNECT_STATE_DISCONNECTED":
        return x.CONNECT_STATE_DISCONNECTED;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum ConnectState");
    }
  }
  a.connectStateFromJSON = se;
  function Se(b) {
    switch (b) {
      case x.CONNECT_STATE_UNSPECIFIED:
        return "CONNECT_STATE_UNSPECIFIED";
      case x.CONNECT_STATE_CONNECTED:
        return "CONNECT_STATE_CONNECTED";
      case x.CONNECT_STATE_DISCONNECTED:
        return "CONNECT_STATE_DISCONNECTED";
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum ConnectState");
    }
  }
  a.connectStateToJSON = Se;
  function xe(b) {
    switch (b) {
      case x.CONNECT_STATE_UNSPECIFIED:
        return 0;
      case x.CONNECT_STATE_CONNECTED:
        return 1;
      case x.CONNECT_STATE_DISCONNECTED:
        return 2;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum ConnectState");
    }
  }
  a.connectStateToNumber = xe;
  var Ae;
  (function(b) {
    b.EVENT_SUB_TYPE_UNSPECIFIED = "EVENT_SUB_TYPE_UNSPECIFIED", b.EVENT_SUB_TYPE_CREATE = "EVENT_SUB_TYPE_CREATE", b.EVENT_SUB_TYPE_UPDATE = "EVENT_SUB_TYPE_UPDATE", b.EVENT_SUB_TYPE_DELETE = "EVENT_SUB_TYPE_DELETE", b.EVENT_SUB_TYPE_ADD = "EVENT_SUB_TYPE_ADD", b.EVENT_SUB_TYPE_REMOVE = "EVENT_SUB_TYPE_REMOVE", b.EVENT_SUB_TYPE_STATE = "EVENT_SUB_TYPE_STATE";
  })(Ae = a.EventSubType || (a.EventSubType = {}));
  function Ye(b) {
    switch (b) {
      case 0:
      case "EVENT_SUB_TYPE_UNSPECIFIED":
        return Ae.EVENT_SUB_TYPE_UNSPECIFIED;
      case 1:
      case "EVENT_SUB_TYPE_CREATE":
        return Ae.EVENT_SUB_TYPE_CREATE;
      case 2:
      case "EVENT_SUB_TYPE_UPDATE":
        return Ae.EVENT_SUB_TYPE_UPDATE;
      case 3:
      case "EVENT_SUB_TYPE_DELETE":
        return Ae.EVENT_SUB_TYPE_DELETE;
      case 4:
      case "EVENT_SUB_TYPE_ADD":
        return Ae.EVENT_SUB_TYPE_ADD;
      case 5:
      case "EVENT_SUB_TYPE_REMOVE":
        return Ae.EVENT_SUB_TYPE_REMOVE;
      case 6:
      case "EVENT_SUB_TYPE_STATE":
        return Ae.EVENT_SUB_TYPE_STATE;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum EventSubType");
    }
  }
  a.eventSubTypeFromJSON = Ye;
  function et(b) {
    switch (b) {
      case Ae.EVENT_SUB_TYPE_UNSPECIFIED:
        return "EVENT_SUB_TYPE_UNSPECIFIED";
      case Ae.EVENT_SUB_TYPE_CREATE:
        return "EVENT_SUB_TYPE_CREATE";
      case Ae.EVENT_SUB_TYPE_UPDATE:
        return "EVENT_SUB_TYPE_UPDATE";
      case Ae.EVENT_SUB_TYPE_DELETE:
        return "EVENT_SUB_TYPE_DELETE";
      case Ae.EVENT_SUB_TYPE_ADD:
        return "EVENT_SUB_TYPE_ADD";
      case Ae.EVENT_SUB_TYPE_REMOVE:
        return "EVENT_SUB_TYPE_REMOVE";
      case Ae.EVENT_SUB_TYPE_STATE:
        return "EVENT_SUB_TYPE_STATE";
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum EventSubType");
    }
  }
  a.eventSubTypeToJSON = et;
  function dt(b) {
    switch (b) {
      case Ae.EVENT_SUB_TYPE_UNSPECIFIED:
        return 0;
      case Ae.EVENT_SUB_TYPE_CREATE:
        return 1;
      case Ae.EVENT_SUB_TYPE_UPDATE:
        return 2;
      case Ae.EVENT_SUB_TYPE_DELETE:
        return 3;
      case Ae.EVENT_SUB_TYPE_ADD:
        return 4;
      case Ae.EVENT_SUB_TYPE_REMOVE:
        return 5;
      case Ae.EVENT_SUB_TYPE_STATE:
        return 6;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum EventSubType");
    }
  }
  a.eventSubTypeToNumber = dt;
  var St;
  (function(b) {
    b.EVENT_TYPE_UNSPECIFIED = "EVENT_TYPE_UNSPECIFIED", b.EVENT_TYPE_COLLECTION = "EVENT_TYPE_COLLECTION", b.EVENT_TYPE_PROJECT = "EVENT_TYPE_PROJECT", b.EVENT_TYPE_SOURCE = "EVENT_TYPE_SOURCE", b.EVENT_TYPE_DESTINATION = "EVENT_TYPE_DESTINATION";
  })(St = a.EventType || (a.EventType = {}));
  function tt(b) {
    switch (b) {
      case 0:
      case "EVENT_TYPE_UNSPECIFIED":
        return St.EVENT_TYPE_UNSPECIFIED;
      case 1:
      case "EVENT_TYPE_COLLECTION":
        return St.EVENT_TYPE_COLLECTION;
      case 2:
      case "EVENT_TYPE_PROJECT":
        return St.EVENT_TYPE_PROJECT;
      case 4:
      case "EVENT_TYPE_SOURCE":
        return St.EVENT_TYPE_SOURCE;
      case 5:
      case "EVENT_TYPE_DESTINATION":
        return St.EVENT_TYPE_DESTINATION;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum EventType");
    }
  }
  a.eventTypeFromJSON = tt;
  function at(b) {
    switch (b) {
      case St.EVENT_TYPE_UNSPECIFIED:
        return "EVENT_TYPE_UNSPECIFIED";
      case St.EVENT_TYPE_COLLECTION:
        return "EVENT_TYPE_COLLECTION";
      case St.EVENT_TYPE_PROJECT:
        return "EVENT_TYPE_PROJECT";
      case St.EVENT_TYPE_SOURCE:
        return "EVENT_TYPE_SOURCE";
      case St.EVENT_TYPE_DESTINATION:
        return "EVENT_TYPE_DESTINATION";
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum EventType");
    }
  }
  a.eventTypeToJSON = at;
  function kt(b) {
    switch (b) {
      case St.EVENT_TYPE_UNSPECIFIED:
        return 0;
      case St.EVENT_TYPE_COLLECTION:
        return 1;
      case St.EVENT_TYPE_PROJECT:
        return 2;
      case St.EVENT_TYPE_SOURCE:
        return 4;
      case St.EVENT_TYPE_DESTINATION:
        return 5;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum EventType");
    }
  }
  a.eventTypeToNumber = kt;
  function rt() {
    return { userId: "", collectionId: "", projectId: "", triggerMetadata: void 0, trigger: void 0 };
  }
  a.WebhookRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.userId !== "" && C.uint32(10).string(b.userId), b.collectionId !== "" && C.uint32(18).string(b.collectionId), b.projectId !== "" && C.uint32(26).string(b.projectId), b.triggerMetadata !== void 0 && p.Value.encode(p.Value.wrap(b.triggerMetadata), C.uint32(34).fork()).ldelim(), b.trigger !== void 0 && C.uint32(40).int32(F(b.trigger)), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = rt();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.userId = N.string();
            break;
          case 2:
            ie.collectionId = N.string();
            break;
          case 3:
            ie.projectId = N.string();
            break;
          case 4:
            ie.triggerMetadata = p.Value.unwrap(p.Value.decode(N, N.uint32()));
            break;
          case 5:
            ie.trigger = O(N.int32());
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        userId: Le(b.userId) ? String(b.userId) : "",
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : "",
        triggerMetadata: Le(b == null ? void 0 : b.triggerMetadata) ? b.triggerMetadata : void 0,
        trigger: Le(b.trigger) ? O(b.trigger) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.userId !== void 0 && (C.userId = b.userId), b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.projectId !== void 0 && (C.projectId = b.projectId), b.triggerMetadata !== void 0 && (C.triggerMetadata = b.triggerMetadata), b.trigger !== void 0 && (C.trigger = b.trigger !== void 0 ? D(b.trigger) : void 0), C;
    },
    fromPartial(b) {
      var C, N, _e, ie, Re;
      const gt = rt();
      return gt.userId = (C = b.userId) !== null && C !== void 0 ? C : "", gt.collectionId = (N = b.collectionId) !== null && N !== void 0 ? N : "", gt.projectId = (_e = b.projectId) !== null && _e !== void 0 ? _e : "", gt.triggerMetadata = (ie = b.triggerMetadata) !== null && ie !== void 0 ? ie : void 0, gt.trigger = (Re = b.trigger) !== null && Re !== void 0 ? Re : void 0, gt;
    }
  };
  function ut() {
    return {};
  }
  a.WebhookResponse = {
    encode(b, C = c.default.Writer.create()) {
      return C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = ut();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {};
    },
    toJSON(b) {
      return {};
    },
    fromPartial(b) {
      return ut();
    }
  };
  function wt() {
    return { enabled: !1, url: "", timeoutMs: void 0 };
  }
  a.WebhookConfiguration = {
    encode(b, C = c.default.Writer.create()) {
      return b.enabled === !0 && C.uint32(8).bool(b.enabled), b.url !== "" && C.uint32(18).string(b.url), b.timeoutMs !== void 0 && C.uint32(24).uint32(b.timeoutMs), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = wt();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.enabled = N.bool();
            break;
          case 2:
            ie.url = N.string();
            break;
          case 3:
            ie.timeoutMs = N.uint32();
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        enabled: Le(b.enabled) ? !!b.enabled : !1,
        url: Le(b.url) ? String(b.url) : "",
        timeoutMs: Le(b.timeoutMs) ? Number(b.timeoutMs) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.enabled !== void 0 && (C.enabled = b.enabled), b.url !== void 0 && (C.url = b.url), b.timeoutMs !== void 0 && (C.timeoutMs = Math.round(b.timeoutMs)), C;
    },
    fromPartial(b) {
      var C, N, _e;
      const ie = wt();
      return ie.enabled = (C = b.enabled) !== null && C !== void 0 ? C : !1, ie.url = (N = b.url) !== null && N !== void 0 ? N : "", ie.timeoutMs = (_e = b.timeoutMs) !== null && _e !== void 0 ? _e : void 0, ie;
    }
  };
  function nt() {
    return { startBroadcast: void 0, startWebrtc: void 0, joinWebrtc: void 0 };
  }
  a.AccountConfigurationHook = {
    encode(b, C = c.default.Writer.create()) {
      return b.startBroadcast !== void 0 && a.WebhookConfiguration.encode(b.startBroadcast, C.uint32(10).fork()).ldelim(), b.startWebrtc !== void 0 && a.WebhookConfiguration.encode(b.startWebrtc, C.uint32(18).fork()).ldelim(), b.joinWebrtc !== void 0 && a.WebhookConfiguration.encode(b.joinWebrtc, C.uint32(26).fork()).ldelim(), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = nt();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.startBroadcast = a.WebhookConfiguration.decode(N, N.uint32());
            break;
          case 2:
            ie.startWebrtc = a.WebhookConfiguration.decode(N, N.uint32());
            break;
          case 3:
            ie.joinWebrtc = a.WebhookConfiguration.decode(N, N.uint32());
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        startBroadcast: Le(b.startBroadcast) ? a.WebhookConfiguration.fromJSON(b.startBroadcast) : void 0,
        startWebrtc: Le(b.startWebrtc) ? a.WebhookConfiguration.fromJSON(b.startWebrtc) : void 0,
        joinWebrtc: Le(b.joinWebrtc) ? a.WebhookConfiguration.fromJSON(b.joinWebrtc) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.startBroadcast !== void 0 && (C.startBroadcast = b.startBroadcast ? a.WebhookConfiguration.toJSON(b.startBroadcast) : void 0), b.startWebrtc !== void 0 && (C.startWebrtc = b.startWebrtc ? a.WebhookConfiguration.toJSON(b.startWebrtc) : void 0), b.joinWebrtc !== void 0 && (C.joinWebrtc = b.joinWebrtc ? a.WebhookConfiguration.toJSON(b.joinWebrtc) : void 0), C;
    },
    fromPartial(b) {
      const C = nt();
      return C.startBroadcast = b.startBroadcast !== void 0 && b.startBroadcast !== null ? a.WebhookConfiguration.fromPartial(b.startBroadcast) : void 0, C.startWebrtc = b.startWebrtc !== void 0 && b.startWebrtc !== null ? a.WebhookConfiguration.fromPartial(b.startWebrtc) : void 0, C.joinWebrtc = b.joinWebrtc !== void 0 && b.joinWebrtc !== null ? a.WebhookConfiguration.fromPartial(b.joinWebrtc) : void 0, C;
    }
  };
  function it() {
    return { broadcastConcurrency: void 0, hooks: void 0 };
  }
  a.AccountConfiguration = {
    encode(b, C = c.default.Writer.create()) {
      return b.broadcastConcurrency !== void 0 && C.uint32(16).int32(b.broadcastConcurrency), b.hooks !== void 0 && a.AccountConfigurationHook.encode(b.hooks, C.uint32(26).fork()).ldelim(), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = it();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 2:
            ie.broadcastConcurrency = N.int32();
            break;
          case 3:
            ie.hooks = a.AccountConfigurationHook.decode(N, N.uint32());
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        broadcastConcurrency: Le(b.broadcastConcurrency) ? Number(b.broadcastConcurrency) : void 0,
        hooks: Le(b.hooks) ? a.AccountConfigurationHook.fromJSON(b.hooks) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.broadcastConcurrency !== void 0 && (C.broadcastConcurrency = Math.round(b.broadcastConcurrency)), b.hooks !== void 0 && (C.hooks = b.hooks ? a.AccountConfigurationHook.toJSON(b.hooks) : void 0), C;
    },
    fromPartial(b) {
      var C;
      const N = it();
      return N.broadcastConcurrency = (C = b.broadcastConcurrency) !== null && C !== void 0 ? C : void 0, N.hooks = b.hooks !== void 0 && b.hooks !== null ? a.AccountConfigurationHook.fromPartial(b.hooks) : void 0, N;
    }
  };
  function bt() {
    return {};
  }
  a.GetAccountConfigurationRequest = {
    encode(b, C = c.default.Writer.create()) {
      return C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = bt();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {};
    },
    toJSON(b) {
      return {};
    },
    fromPartial(b) {
      return bt();
    }
  };
  function ot() {
    return { accountConfiguration: void 0 };
  }
  a.GetAccountConfigurationResponse = {
    encode(b, C = c.default.Writer.create()) {
      return b.accountConfiguration !== void 0 && a.AccountConfiguration.encode(b.accountConfiguration, C.uint32(10).fork()).ldelim(), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = ot();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.accountConfiguration = a.AccountConfiguration.decode(N, N.uint32());
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        accountConfiguration: Le(b.accountConfiguration) ? a.AccountConfiguration.fromJSON(b.accountConfiguration) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.accountConfiguration !== void 0 && (C.accountConfiguration = b.accountConfiguration ? a.AccountConfiguration.toJSON(b.accountConfiguration) : void 0), C;
    },
    fromPartial(b) {
      const C = ot();
      return C.accountConfiguration = b.accountConfiguration !== void 0 && b.accountConfiguration !== null ? a.AccountConfiguration.fromPartial(b.accountConfiguration) : void 0, C;
    }
  };
  function ct() {
    return { broadcastConcurrency: void 0, hooks: void 0, updateMask: void 0 };
  }
  a.UpdateAccountConfigurationRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.broadcastConcurrency !== void 0 && C.uint32(16).int32(b.broadcastConcurrency), b.hooks !== void 0 && a.AccountConfigurationHook.encode(b.hooks, C.uint32(26).fork()).ldelim(), b.updateMask !== void 0 && v.FieldMask.encode(v.FieldMask.wrap(b.updateMask), C.uint32(34).fork()).ldelim(), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = ct();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 2:
            ie.broadcastConcurrency = N.int32();
            break;
          case 3:
            ie.hooks = a.AccountConfigurationHook.decode(N, N.uint32());
            break;
          case 4:
            ie.updateMask = v.FieldMask.unwrap(v.FieldMask.decode(N, N.uint32()));
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        broadcastConcurrency: Le(b.broadcastConcurrency) ? Number(b.broadcastConcurrency) : void 0,
        hooks: Le(b.hooks) ? a.AccountConfigurationHook.fromJSON(b.hooks) : void 0,
        updateMask: Le(b.updateMask) ? v.FieldMask.unwrap(v.FieldMask.fromJSON(b.updateMask)) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.broadcastConcurrency !== void 0 && (C.broadcastConcurrency = Math.round(b.broadcastConcurrency)), b.hooks !== void 0 && (C.hooks = b.hooks ? a.AccountConfigurationHook.toJSON(b.hooks) : void 0), b.updateMask !== void 0 && (C.updateMask = v.FieldMask.toJSON(v.FieldMask.wrap(b.updateMask))), C;
    },
    fromPartial(b) {
      var C, N;
      const _e = ct();
      return _e.broadcastConcurrency = (C = b.broadcastConcurrency) !== null && C !== void 0 ? C : void 0, _e.hooks = b.hooks !== void 0 && b.hooks !== null ? a.AccountConfigurationHook.fromPartial(b.hooks) : void 0, _e.updateMask = (N = b.updateMask) !== null && N !== void 0 ? N : void 0, _e;
    }
  };
  function Pt() {
    return { accountConfiguration: void 0 };
  }
  a.UpdateAccountConfigurationResponse = {
    encode(b, C = c.default.Writer.create()) {
      return b.accountConfiguration !== void 0 && a.AccountConfiguration.encode(b.accountConfiguration, C.uint32(10).fork()).ldelim(), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = Pt();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.accountConfiguration = a.AccountConfiguration.decode(N, N.uint32());
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        accountConfiguration: Le(b.accountConfiguration) ? a.AccountConfiguration.fromJSON(b.accountConfiguration) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.accountConfiguration !== void 0 && (C.accountConfiguration = b.accountConfiguration ? a.AccountConfiguration.toJSON(b.accountConfiguration) : void 0), C;
    },
    fromPartial(b) {
      const C = Pt();
      return C.accountConfiguration = b.accountConfiguration !== void 0 && b.accountConfiguration !== null ? a.AccountConfiguration.fromPartial(b.accountConfiguration) : void 0, C;
    }
  };
  function st() {
    return { height: void 0, width: void 0, framerate: void 0, colorSpace: void 0 };
  }
  a.VideoRendering = {
    encode(b, C = c.default.Writer.create()) {
      return b.height !== void 0 && C.uint32(8).uint32(b.height), b.width !== void 0 && C.uint32(16).uint32(b.width), b.framerate !== void 0 && C.uint32(29).float(b.framerate), b.colorSpace !== void 0 && C.uint32(32).int32(z(b.colorSpace)), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = st();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.height = N.uint32();
            break;
          case 2:
            ie.width = N.uint32();
            break;
          case 3:
            ie.framerate = N.float();
            break;
          case 4:
            ie.colorSpace = Te(N.int32());
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        height: Le(b.height) ? Number(b.height) : void 0,
        width: Le(b.width) ? Number(b.width) : void 0,
        framerate: Le(b.framerate) ? Number(b.framerate) : void 0,
        colorSpace: Le(b.colorSpace) ? Te(b.colorSpace) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.height !== void 0 && (C.height = Math.round(b.height)), b.width !== void 0 && (C.width = Math.round(b.width)), b.framerate !== void 0 && (C.framerate = b.framerate), b.colorSpace !== void 0 && (C.colorSpace = b.colorSpace !== void 0 ? q(b.colorSpace) : void 0), C;
    },
    fromPartial(b) {
      var C, N, _e, ie;
      const Re = st();
      return Re.height = (C = b.height) !== null && C !== void 0 ? C : void 0, Re.width = (N = b.width) !== null && N !== void 0 ? N : void 0, Re.framerate = (_e = b.framerate) !== null && _e !== void 0 ? _e : void 0, Re.colorSpace = (ie = b.colorSpace) !== null && ie !== void 0 ? ie : void 0, Re;
    }
  };
  function lt() {
    return { channelLayout: void 0 };
  }
  a.AudioRendering = {
    encode(b, C = c.default.Writer.create()) {
      return b.channelLayout !== void 0 && C.uint32(8).int32(I(b.channelLayout)), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = lt();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.channelLayout = S(N.int32());
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        channelLayout: Le(b.channelLayout) ? S(b.channelLayout) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.channelLayout !== void 0 && (C.channelLayout = b.channelLayout !== void 0 ? E(b.channelLayout) : void 0), C;
    },
    fromPartial(b) {
      var C;
      const N = lt();
      return N.channelLayout = (C = b.channelLayout) !== null && C !== void 0 ? C : void 0, N;
    }
  };
  function It() {
    return { video: void 0, audio: void 0, quality: void 0, targetLatency: void 0, complexity: void 0 };
  }
  a.Rendering = {
    encode(b, C = c.default.Writer.create()) {
      return b.video !== void 0 && a.VideoRendering.encode(b.video, C.uint32(10).fork()).ldelim(), b.audio !== void 0 && a.AudioRendering.encode(b.audio, C.uint32(18).fork()).ldelim(), b.quality !== void 0 && C.uint32(24).int32(Y(b.quality)), b.targetLatency !== void 0 && C.uint32(32).uint32(b.targetLatency), b.complexity !== void 0 && C.uint32(40).int32(b.complexity), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = It();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.video = a.VideoRendering.decode(N, N.uint32());
            break;
          case 2:
            ie.audio = a.AudioRendering.decode(N, N.uint32());
            break;
          case 3:
            ie.quality = $(N.int32());
            break;
          case 4:
            ie.targetLatency = N.uint32();
            break;
          case 5:
            ie.complexity = N.int32();
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        video: Le(b.video) ? a.VideoRendering.fromJSON(b.video) : void 0,
        audio: Le(b.audio) ? a.AudioRendering.fromJSON(b.audio) : void 0,
        quality: Le(b.quality) ? $(b.quality) : void 0,
        targetLatency: Le(b.targetLatency) ? Number(b.targetLatency) : void 0,
        complexity: Le(b.complexity) ? Number(b.complexity) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.video !== void 0 && (C.video = b.video ? a.VideoRendering.toJSON(b.video) : void 0), b.audio !== void 0 && (C.audio = b.audio ? a.AudioRendering.toJSON(b.audio) : void 0), b.quality !== void 0 && (C.quality = b.quality !== void 0 ? U(b.quality) : void 0), b.targetLatency !== void 0 && (C.targetLatency = Math.round(b.targetLatency)), b.complexity !== void 0 && (C.complexity = Math.round(b.complexity)), C;
    },
    fromPartial(b) {
      var C, N, _e;
      const ie = It();
      return ie.video = b.video !== void 0 && b.video !== null ? a.VideoRendering.fromPartial(b.video) : void 0, ie.audio = b.audio !== void 0 && b.audio !== null ? a.AudioRendering.fromPartial(b.audio) : void 0, ie.quality = (C = b.quality) !== null && C !== void 0 ? C : void 0, ie.targetLatency = (N = b.targetLatency) !== null && N !== void 0 ? N : void 0, ie.complexity = (_e = b.complexity) !== null && _e !== void 0 ? _e : void 0, ie;
    }
  };
  function Rt() {
    return { mode: void 0, targetBitrate: void 0, maxKeyFrameInterval: void 0 };
  }
  a.VideoCodecRateControl = {
    encode(b, C = c.default.Writer.create()) {
      return b.mode !== void 0 && C.uint32(8).int32(le(b.mode)), b.targetBitrate !== void 0 && C.uint32(16).uint32(b.targetBitrate), b.maxKeyFrameInterval !== void 0 && C.uint32(24).uint32(b.maxKeyFrameInterval), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = Rt();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.mode = A(N.int32());
            break;
          case 2:
            ie.targetBitrate = N.uint32();
            break;
          case 3:
            ie.maxKeyFrameInterval = N.uint32();
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        mode: Le(b.mode) ? A(b.mode) : void 0,
        targetBitrate: Le(b.targetBitrate) ? Number(b.targetBitrate) : void 0,
        maxKeyFrameInterval: Le(b.maxKeyFrameInterval) ? Number(b.maxKeyFrameInterval) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.mode !== void 0 && (C.mode = b.mode !== void 0 ? re(b.mode) : void 0), b.targetBitrate !== void 0 && (C.targetBitrate = Math.round(b.targetBitrate)), b.maxKeyFrameInterval !== void 0 && (C.maxKeyFrameInterval = Math.round(b.maxKeyFrameInterval)), C;
    },
    fromPartial(b) {
      var C, N, _e;
      const ie = Rt();
      return ie.mode = (C = b.mode) !== null && C !== void 0 ? C : void 0, ie.targetBitrate = (N = b.targetBitrate) !== null && N !== void 0 ? N : void 0, ie.maxKeyFrameInterval = (_e = b.maxKeyFrameInterval) !== null && _e !== void 0 ? _e : void 0, ie;
    }
  };
  function Ve() {
    return { codec: void 0, rateControl: void 0, profile: void 0 };
  }
  a.VideoEncoding = {
    encode(b, C = c.default.Writer.create()) {
      return b.codec !== void 0 && C.uint32(8).int32(te(b.codec)), b.rateControl !== void 0 && a.VideoCodecRateControl.encode(b.rateControl, C.uint32(18).fork()).ldelim(), b.profile !== void 0 && C.uint32(32).int32(ye(b.profile)), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = Ve();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.codec = T(N.int32());
            break;
          case 2:
            ie.rateControl = a.VideoCodecRateControl.decode(N, N.uint32());
            break;
          case 4:
            ie.profile = Ce(N.int32());
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        codec: Le(b.codec) ? T(b.codec) : void 0,
        rateControl: Le(b.rateControl) ? a.VideoCodecRateControl.fromJSON(b.rateControl) : void 0,
        profile: Le(b.profile) ? Ce(b.profile) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.codec !== void 0 && (C.codec = b.codec !== void 0 ? L(b.codec) : void 0), b.rateControl !== void 0 && (C.rateControl = b.rateControl ? a.VideoCodecRateControl.toJSON(b.rateControl) : void 0), b.profile !== void 0 && (C.profile = b.profile !== void 0 ? De(b.profile) : void 0), C;
    },
    fromPartial(b) {
      var C, N;
      const _e = Ve();
      return _e.codec = (C = b.codec) !== null && C !== void 0 ? C : void 0, _e.rateControl = b.rateControl !== void 0 && b.rateControl !== null ? a.VideoCodecRateControl.fromPartial(b.rateControl) : void 0, _e.profile = (N = b.profile) !== null && N !== void 0 ? N : void 0, _e;
    }
  };
  function He() {
    return { codec: void 0 };
  }
  a.AudioEncoding = {
    encode(b, C = c.default.Writer.create()) {
      return b.codec !== void 0 && C.uint32(8).int32(Ue(b.codec)), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = He();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.codec = Me(N.int32());
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { codec: Le(b.codec) ? Me(b.codec) : void 0 };
    },
    toJSON(b) {
      const C = {};
      return b.codec !== void 0 && (C.codec = b.codec !== void 0 ? Ne(b.codec) : void 0), C;
    },
    fromPartial(b) {
      var C;
      const N = He();
      return N.codec = (C = b.codec) !== null && C !== void 0 ? C : void 0, N;
    }
  };
  function Qe() {
    return { video: void 0, audio: void 0 };
  }
  a.Encoding = {
    encode(b, C = c.default.Writer.create()) {
      return b.video !== void 0 && a.VideoEncoding.encode(b.video, C.uint32(10).fork()).ldelim(), b.audio !== void 0 && a.AudioEncoding.encode(b.audio, C.uint32(18).fork()).ldelim(), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = Qe();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.video = a.VideoEncoding.decode(N, N.uint32());
            break;
          case 2:
            ie.audio = a.AudioEncoding.decode(N, N.uint32());
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        video: Le(b.video) ? a.VideoEncoding.fromJSON(b.video) : void 0,
        audio: Le(b.audio) ? a.AudioEncoding.fromJSON(b.audio) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.video !== void 0 && (C.video = b.video ? a.VideoEncoding.toJSON(b.video) : void 0), b.audio !== void 0 && (C.audio = b.audio ? a.AudioEncoding.toJSON(b.audio) : void 0), C;
    },
    fromPartial(b) {
      const C = Qe();
      return C.video = b.video !== void 0 && b.video !== null ? a.VideoEncoding.fromPartial(b.video) : void 0, C.audio = b.audio !== void 0 && b.audio !== null ? a.AudioEncoding.fromPartial(b.audio) : void 0, C;
    }
  };
  function pt() {
    return {
      enabled: void 0,
      key: void 0,
      url: void 0,
      baseUrl: void 0,
      previewUrl: void 0,
      ingestId: void 0,
      secure: void 0,
      ingestType: void 0
    };
  }
  a.SourceRtmpPushAddress = {
    encode(b, C = c.default.Writer.create()) {
      return b.enabled !== void 0 && C.uint32(8).bool(b.enabled), b.key !== void 0 && C.uint32(18).string(b.key), b.url !== void 0 && C.uint32(26).string(b.url), b.baseUrl !== void 0 && C.uint32(34).string(b.baseUrl), b.previewUrl !== void 0 && C.uint32(42).string(b.previewUrl), b.ingestId !== void 0 && C.uint32(50).string(b.ingestId), b.secure !== void 0 && C.uint32(56).bool(b.secure), b.ingestType !== void 0 && C.uint32(66).string(b.ingestType), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = pt();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.enabled = N.bool();
            break;
          case 2:
            ie.key = N.string();
            break;
          case 3:
            ie.url = N.string();
            break;
          case 4:
            ie.baseUrl = N.string();
            break;
          case 5:
            ie.previewUrl = N.string();
            break;
          case 6:
            ie.ingestId = N.string();
            break;
          case 7:
            ie.secure = N.bool();
            break;
          case 8:
            ie.ingestType = N.string();
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        enabled: Le(b.enabled) ? !!b.enabled : void 0,
        key: Le(b.key) ? String(b.key) : void 0,
        url: Le(b.url) ? String(b.url) : void 0,
        baseUrl: Le(b.baseUrl) ? String(b.baseUrl) : void 0,
        previewUrl: Le(b.previewUrl) ? String(b.previewUrl) : void 0,
        ingestId: Le(b.ingestId) ? String(b.ingestId) : void 0,
        secure: Le(b.secure) ? !!b.secure : void 0,
        ingestType: Le(b.ingestType) ? String(b.ingestType) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.enabled !== void 0 && (C.enabled = b.enabled), b.key !== void 0 && (C.key = b.key), b.url !== void 0 && (C.url = b.url), b.baseUrl !== void 0 && (C.baseUrl = b.baseUrl), b.previewUrl !== void 0 && (C.previewUrl = b.previewUrl), b.ingestId !== void 0 && (C.ingestId = b.ingestId), b.secure !== void 0 && (C.secure = b.secure), b.ingestType !== void 0 && (C.ingestType = b.ingestType), C;
    },
    fromPartial(b) {
      var C, N, _e, ie, Re, gt, Ct, Dt;
      const Lt = pt();
      return Lt.enabled = (C = b.enabled) !== null && C !== void 0 ? C : void 0, Lt.key = (N = b.key) !== null && N !== void 0 ? N : void 0, Lt.url = (_e = b.url) !== null && _e !== void 0 ? _e : void 0, Lt.baseUrl = (ie = b.baseUrl) !== null && ie !== void 0 ? ie : void 0, Lt.previewUrl = (Re = b.previewUrl) !== null && Re !== void 0 ? Re : void 0, Lt.ingestId = (gt = b.ingestId) !== null && gt !== void 0 ? gt : void 0, Lt.secure = (Ct = b.secure) !== null && Ct !== void 0 ? Ct : void 0, Lt.ingestType = (Dt = b.ingestType) !== null && Dt !== void 0 ? Dt : void 0, Lt;
    }
  };
  function mt() {
    return {
      enabled: void 0,
      streamId: void 0,
      url: void 0,
      baseUrl: void 0,
      previewUrl: void 0,
      ingestId: void 0,
      ingestType: void 0
    };
  }
  a.SrtPushAddress = {
    encode(b, C = c.default.Writer.create()) {
      return b.enabled !== void 0 && C.uint32(8).bool(b.enabled), b.streamId !== void 0 && C.uint32(18).string(b.streamId), b.url !== void 0 && C.uint32(26).string(b.url), b.baseUrl !== void 0 && C.uint32(34).string(b.baseUrl), b.previewUrl !== void 0 && C.uint32(42).string(b.previewUrl), b.ingestId !== void 0 && C.uint32(50).string(b.ingestId), b.ingestType !== void 0 && C.uint32(58).string(b.ingestType), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = mt();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.enabled = N.bool();
            break;
          case 2:
            ie.streamId = N.string();
            break;
          case 3:
            ie.url = N.string();
            break;
          case 4:
            ie.baseUrl = N.string();
            break;
          case 5:
            ie.previewUrl = N.string();
            break;
          case 6:
            ie.ingestId = N.string();
            break;
          case 7:
            ie.ingestType = N.string();
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        enabled: Le(b.enabled) ? !!b.enabled : void 0,
        streamId: Le(b.streamId) ? String(b.streamId) : void 0,
        url: Le(b.url) ? String(b.url) : void 0,
        baseUrl: Le(b.baseUrl) ? String(b.baseUrl) : void 0,
        previewUrl: Le(b.previewUrl) ? String(b.previewUrl) : void 0,
        ingestId: Le(b.ingestId) ? String(b.ingestId) : void 0,
        ingestType: Le(b.ingestType) ? String(b.ingestType) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.enabled !== void 0 && (C.enabled = b.enabled), b.streamId !== void 0 && (C.streamId = b.streamId), b.url !== void 0 && (C.url = b.url), b.baseUrl !== void 0 && (C.baseUrl = b.baseUrl), b.previewUrl !== void 0 && (C.previewUrl = b.previewUrl), b.ingestId !== void 0 && (C.ingestId = b.ingestId), b.ingestType !== void 0 && (C.ingestType = b.ingestType), C;
    },
    fromPartial(b) {
      var C, N, _e, ie, Re, gt, Ct;
      const Dt = mt();
      return Dt.enabled = (C = b.enabled) !== null && C !== void 0 ? C : void 0, Dt.streamId = (N = b.streamId) !== null && N !== void 0 ? N : void 0, Dt.url = (_e = b.url) !== null && _e !== void 0 ? _e : void 0, Dt.baseUrl = (ie = b.baseUrl) !== null && ie !== void 0 ? ie : void 0, Dt.previewUrl = (Re = b.previewUrl) !== null && Re !== void 0 ? Re : void 0, Dt.ingestId = (gt = b.ingestId) !== null && gt !== void 0 ? gt : void 0, Dt.ingestType = (Ct = b.ingestType) !== null && Ct !== void 0 ? Ct : void 0, Dt;
    }
  };
  function vt() {
    return { url: "" };
  }
  a.RtmpPullAddress = {
    encode(b, C = c.default.Writer.create()) {
      return b.url !== "" && C.uint32(10).string(b.url), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = vt();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.url = N.string();
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { url: Le(b.url) ? String(b.url) : "" };
    },
    toJSON(b) {
      const C = {};
      return b.url !== void 0 && (C.url = b.url), C;
    },
    fromPartial(b) {
      var C;
      const N = vt();
      return N.url = (C = b.url) !== null && C !== void 0 ? C : "", N;
    }
  };
  function ht() {
    return { url: "" };
  }
  a.SrtPullAddress = {
    encode(b, C = c.default.Writer.create()) {
      return b.url !== "" && C.uint32(10).string(b.url), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = ht();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.url = N.string();
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { url: Le(b.url) ? String(b.url) : "" };
    },
    toJSON(b) {
      const C = {};
      return b.url !== void 0 && (C.url = b.url), C;
    },
    fromPartial(b) {
      var C;
      const N = ht();
      return N.url = (C = b.url) !== null && C !== void 0 ? C : "", N;
    }
  };
  function Et() {
    return { id: void 0 };
  }
  a.DynamicAddress = {
    encode(b, C = c.default.Writer.create()) {
      return b.id !== void 0 && C.uint32(10).string(b.id), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = Et();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.id = N.string();
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { id: Le(b.id) ? String(b.id) : void 0 };
    },
    toJSON(b) {
      const C = {};
      return b.id !== void 0 && (C.id = b.id), C;
    },
    fromPartial(b) {
      var C;
      const N = Et();
      return N.id = (C = b.id) !== null && C !== void 0 ? C : void 0, N;
    }
  };
  function Tt() {
    return { enabled: void 0, secure: !1 };
  }
  a.DirectRTMPAddress = {
    encode(b, C = c.default.Writer.create()) {
      return b.enabled !== void 0 && C.uint32(8).bool(b.enabled), b.secure === !0 && C.uint32(16).bool(b.secure), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = Tt();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.enabled = N.bool();
            break;
          case 2:
            ie.secure = N.bool();
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        enabled: Le(b.enabled) ? !!b.enabled : void 0,
        secure: Le(b.secure) ? !!b.secure : !1
      };
    },
    toJSON(b) {
      const C = {};
      return b.enabled !== void 0 && (C.enabled = b.enabled), b.secure !== void 0 && (C.secure = b.secure), C;
    },
    fromPartial(b) {
      var C, N;
      const _e = Tt();
      return _e.enabled = (C = b.enabled) !== null && C !== void 0 ? C : void 0, _e.secure = (N = b.secure) !== null && N !== void 0 ? N : !1, _e;
    }
  };
  function Ot() {
    return { enabled: void 0, secure: !1 };
  }
  a.DirectSrtAddress = {
    encode(b, C = c.default.Writer.create()) {
      return b.enabled !== void 0 && C.uint32(8).bool(b.enabled), b.secure === !0 && C.uint32(16).bool(b.secure), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = Ot();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.enabled = N.bool();
            break;
          case 2:
            ie.secure = N.bool();
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        enabled: Le(b.enabled) ? !!b.enabled : void 0,
        secure: Le(b.secure) ? !!b.secure : !1
      };
    },
    toJSON(b) {
      const C = {};
      return b.enabled !== void 0 && (C.enabled = b.enabled), b.secure !== void 0 && (C.secure = b.secure), C;
    },
    fromPartial(b) {
      var C, N;
      const _e = Ot();
      return _e.enabled = (C = b.enabled) !== null && C !== void 0 ? C : void 0, _e.secure = (N = b.secure) !== null && N !== void 0 ? N : !1, _e;
    }
  };
  function Nt() {
    return { rtmpPull: void 0, srtPull: void 0, directRtmpPush: void 0, directSrtPush: void 0 };
  }
  a.RuntimeSourceAddress = {
    encode(b, C = c.default.Writer.create()) {
      return b.rtmpPull !== void 0 && a.RtmpPullAddress.encode(b.rtmpPull, C.uint32(10).fork()).ldelim(), b.srtPull !== void 0 && a.SrtPullAddress.encode(b.srtPull, C.uint32(18).fork()).ldelim(), b.directRtmpPush !== void 0 && a.DirectRTMPAddress.encode(b.directRtmpPush, C.uint32(26).fork()).ldelim(), b.directSrtPush !== void 0 && a.DirectSrtAddress.encode(b.directSrtPush, C.uint32(34).fork()).ldelim(), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = Nt();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.rtmpPull = a.RtmpPullAddress.decode(N, N.uint32());
            break;
          case 2:
            ie.srtPull = a.SrtPullAddress.decode(N, N.uint32());
            break;
          case 3:
            ie.directRtmpPush = a.DirectRTMPAddress.decode(N, N.uint32());
            break;
          case 4:
            ie.directSrtPush = a.DirectSrtAddress.decode(N, N.uint32());
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        rtmpPull: Le(b.rtmpPull) ? a.RtmpPullAddress.fromJSON(b.rtmpPull) : void 0,
        srtPull: Le(b.srtPull) ? a.SrtPullAddress.fromJSON(b.srtPull) : void 0,
        directRtmpPush: Le(b.directRtmpPush) ? a.DirectRTMPAddress.fromJSON(b.directRtmpPush) : void 0,
        directSrtPush: Le(b.directSrtPush) ? a.DirectSrtAddress.fromJSON(b.directSrtPush) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.rtmpPull !== void 0 && (C.rtmpPull = b.rtmpPull ? a.RtmpPullAddress.toJSON(b.rtmpPull) : void 0), b.srtPull !== void 0 && (C.srtPull = b.srtPull ? a.SrtPullAddress.toJSON(b.srtPull) : void 0), b.directRtmpPush !== void 0 && (C.directRtmpPush = b.directRtmpPush ? a.DirectRTMPAddress.toJSON(b.directRtmpPush) : void 0), b.directSrtPush !== void 0 && (C.directSrtPush = b.directSrtPush ? a.DirectSrtAddress.toJSON(b.directSrtPush) : void 0), C;
    },
    fromPartial(b) {
      const C = Nt();
      return C.rtmpPull = b.rtmpPull !== void 0 && b.rtmpPull !== null ? a.RtmpPullAddress.fromPartial(b.rtmpPull) : void 0, C.srtPull = b.srtPull !== void 0 && b.srtPull !== null ? a.SrtPullAddress.fromPartial(b.srtPull) : void 0, C.directRtmpPush = b.directRtmpPush !== void 0 && b.directRtmpPush !== null ? a.DirectRTMPAddress.fromPartial(b.directRtmpPush) : void 0, C.directSrtPush = b.directSrtPush !== void 0 && b.directSrtPush !== null ? a.DirectSrtAddress.fromPartial(b.directSrtPush) : void 0, C;
    }
  };
  function At() {
    return { rtmpPush: void 0, srtPush: void 0, rtmpPull: void 0, srtPull: void 0, dynamic: void 0 };
  }
  a.SourceAddress = {
    encode(b, C = c.default.Writer.create()) {
      return b.rtmpPush !== void 0 && a.SourceRtmpPushAddress.encode(b.rtmpPush, C.uint32(10).fork()).ldelim(), b.srtPush !== void 0 && a.SrtPushAddress.encode(b.srtPush, C.uint32(18).fork()).ldelim(), b.rtmpPull !== void 0 && a.RtmpPullAddress.encode(b.rtmpPull, C.uint32(26).fork()).ldelim(), b.srtPull !== void 0 && a.SrtPullAddress.encode(b.srtPull, C.uint32(34).fork()).ldelim(), b.dynamic !== void 0 && a.DynamicAddress.encode(b.dynamic, C.uint32(42).fork()).ldelim(), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = At();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.rtmpPush = a.SourceRtmpPushAddress.decode(N, N.uint32());
            break;
          case 2:
            ie.srtPush = a.SrtPushAddress.decode(N, N.uint32());
            break;
          case 3:
            ie.rtmpPull = a.RtmpPullAddress.decode(N, N.uint32());
            break;
          case 4:
            ie.srtPull = a.SrtPullAddress.decode(N, N.uint32());
            break;
          case 5:
            ie.dynamic = a.DynamicAddress.decode(N, N.uint32());
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        rtmpPush: Le(b.rtmpPush) ? a.SourceRtmpPushAddress.fromJSON(b.rtmpPush) : void 0,
        srtPush: Le(b.srtPush) ? a.SrtPushAddress.fromJSON(b.srtPush) : void 0,
        rtmpPull: Le(b.rtmpPull) ? a.RtmpPullAddress.fromJSON(b.rtmpPull) : void 0,
        srtPull: Le(b.srtPull) ? a.SrtPullAddress.fromJSON(b.srtPull) : void 0,
        dynamic: Le(b.dynamic) ? a.DynamicAddress.fromJSON(b.dynamic) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.rtmpPush !== void 0 && (C.rtmpPush = b.rtmpPush ? a.SourceRtmpPushAddress.toJSON(b.rtmpPush) : void 0), b.srtPush !== void 0 && (C.srtPush = b.srtPush ? a.SrtPushAddress.toJSON(b.srtPush) : void 0), b.rtmpPull !== void 0 && (C.rtmpPull = b.rtmpPull ? a.RtmpPullAddress.toJSON(b.rtmpPull) : void 0), b.srtPull !== void 0 && (C.srtPull = b.srtPull ? a.SrtPullAddress.toJSON(b.srtPull) : void 0), b.dynamic !== void 0 && (C.dynamic = b.dynamic ? a.DynamicAddress.toJSON(b.dynamic) : void 0), C;
    },
    fromPartial(b) {
      const C = At();
      return C.rtmpPush = b.rtmpPush !== void 0 && b.rtmpPush !== null ? a.SourceRtmpPushAddress.fromPartial(b.rtmpPush) : void 0, C.srtPush = b.srtPush !== void 0 && b.srtPush !== null ? a.SrtPushAddress.fromPartial(b.srtPush) : void 0, C.rtmpPull = b.rtmpPull !== void 0 && b.rtmpPull !== null ? a.RtmpPullAddress.fromPartial(b.rtmpPull) : void 0, C.srtPull = b.srtPull !== void 0 && b.srtPull !== null ? a.SrtPullAddress.fromPartial(b.srtPull) : void 0, C.dynamic = b.dynamic !== void 0 && b.dynamic !== null ? a.DynamicAddress.fromPartial(b.dynamic) : void 0, C;
    }
  };
  function Mt() {
    return { key: void 0, url: "" };
  }
  a.DestinationRtmpPushAddress = {
    encode(b, C = c.default.Writer.create()) {
      return b.key !== void 0 && C.uint32(10).string(b.key), b.url !== "" && C.uint32(18).string(b.url), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = Mt();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.key = N.string();
            break;
          case 2:
            ie.url = N.string();
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        key: Le(b.key) ? String(b.key) : void 0,
        url: Le(b.url) ? String(b.url) : ""
      };
    },
    toJSON(b) {
      const C = {};
      return b.key !== void 0 && (C.key = b.key), b.url !== void 0 && (C.url = b.url), C;
    },
    fromPartial(b) {
      var C, N;
      const _e = Mt();
      return _e.key = (C = b.key) !== null && C !== void 0 ? C : void 0, _e.url = (N = b.url) !== null && N !== void 0 ? N : "", _e;
    }
  };
  function $t() {
    return { url: "" };
  }
  a.DestinationSrtPushAddress = {
    encode(b, C = c.default.Writer.create()) {
      return b.url !== "" && C.uint32(18).string(b.url), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = $t();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 2:
            ie.url = N.string();
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { url: Le(b.url) ? String(b.url) : "" };
    },
    toJSON(b) {
      const C = {};
      return b.url !== void 0 && (C.url = b.url), C;
    },
    fromPartial(b) {
      var C;
      const N = $t();
      return N.url = (C = b.url) !== null && C !== void 0 ? C : "", N;
    }
  };
  function Bt() {
    return { appId: "", channelId: "", userId: "" };
  }
  a.DestinationAgoraPushAddress = {
    encode(b, C = c.default.Writer.create()) {
      return b.appId !== "" && C.uint32(10).string(b.appId), b.channelId !== "" && C.uint32(18).string(b.channelId), b.userId !== "" && C.uint32(26).string(b.userId), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = Bt();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.appId = N.string();
            break;
          case 2:
            ie.channelId = N.string();
            break;
          case 3:
            ie.userId = N.string();
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        appId: Le(b.appId) ? String(b.appId) : "",
        channelId: Le(b.channelId) ? String(b.channelId) : "",
        userId: Le(b.userId) ? String(b.userId) : ""
      };
    },
    toJSON(b) {
      const C = {};
      return b.appId !== void 0 && (C.appId = b.appId), b.channelId !== void 0 && (C.channelId = b.channelId), b.userId !== void 0 && (C.userId = b.userId), C;
    },
    fromPartial(b) {
      var C, N, _e;
      const ie = Bt();
      return ie.appId = (C = b.appId) !== null && C !== void 0 ? C : "", ie.channelId = (N = b.channelId) !== null && N !== void 0 ? N : "", ie.userId = (_e = b.userId) !== null && _e !== void 0 ? _e : "", ie;
    }
  };
  function Ut() {
    return { playlistCount: void 0, fileCount: void 0 };
  }
  a.HlsLifecycleLive = {
    encode(b, C = c.default.Writer.create()) {
      return b.playlistCount !== void 0 && C.uint32(8).int32(b.playlistCount), b.fileCount !== void 0 && C.uint32(16).int32(b.fileCount), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = Ut();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.playlistCount = N.int32();
            break;
          case 2:
            ie.fileCount = N.int32();
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        playlistCount: Le(b.playlistCount) ? Number(b.playlistCount) : void 0,
        fileCount: Le(b.fileCount) ? Number(b.fileCount) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.playlistCount !== void 0 && (C.playlistCount = Math.round(b.playlistCount)), b.fileCount !== void 0 && (C.fileCount = Math.round(b.fileCount)), C;
    },
    fromPartial(b) {
      var C, N;
      const _e = Ut();
      return _e.playlistCount = (C = b.playlistCount) !== null && C !== void 0 ? C : void 0, _e.fileCount = (N = b.fileCount) !== null && N !== void 0 ? N : void 0, _e;
    }
  };
  function xt() {
    return { maxDuration: void 0 };
  }
  a.HlsLifecycleVod = {
    encode(b, C = c.default.Writer.create()) {
      return b.maxDuration !== void 0 && C.uint32(8).int32(b.maxDuration), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = xt();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.maxDuration = N.int32();
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { maxDuration: Le(b.maxDuration) ? Number(b.maxDuration) : void 0 };
    },
    toJSON(b) {
      const C = {};
      return b.maxDuration !== void 0 && (C.maxDuration = Math.round(b.maxDuration)), C;
    },
    fromPartial(b) {
      var C;
      const N = xt();
      return N.maxDuration = (C = b.maxDuration) !== null && C !== void 0 ? C : void 0, N;
    }
  };
  function Jt() {
    return { vod: void 0, live: void 0 };
  }
  a.HlsLifecycle = {
    encode(b, C = c.default.Writer.create()) {
      return b.vod !== void 0 && a.HlsLifecycleVod.encode(b.vod, C.uint32(10).fork()).ldelim(), b.live !== void 0 && a.HlsLifecycleLive.encode(b.live, C.uint32(18).fork()).ldelim(), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = Jt();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.vod = a.HlsLifecycleVod.decode(N, N.uint32());
            break;
          case 2:
            ie.live = a.HlsLifecycleLive.decode(N, N.uint32());
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        vod: Le(b.vod) ? a.HlsLifecycleVod.fromJSON(b.vod) : void 0,
        live: Le(b.live) ? a.HlsLifecycleLive.fromJSON(b.live) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.vod !== void 0 && (C.vod = b.vod ? a.HlsLifecycleVod.toJSON(b.vod) : void 0), b.live !== void 0 && (C.live = b.live ? a.HlsLifecycleLive.toJSON(b.live) : void 0), C;
    },
    fromPartial(b) {
      const C = Jt();
      return C.vod = b.vod !== void 0 && b.vod !== null ? a.HlsLifecycleVod.fromPartial(b.vod) : void 0, C.live = b.live !== void 0 && b.live !== null ? a.HlsLifecycleLive.fromPartial(b.live) : void 0, C;
    }
  };
  function Gt() {
    return { lifecycle: void 0, segmentDuration: void 0 };
  }
  a.HlsPackaging = {
    encode(b, C = c.default.Writer.create()) {
      return b.lifecycle !== void 0 && a.HlsLifecycle.encode(b.lifecycle, C.uint32(10).fork()).ldelim(), b.segmentDuration !== void 0 && C.uint32(16).int32(b.segmentDuration), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = Gt();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.lifecycle = a.HlsLifecycle.decode(N, N.uint32());
            break;
          case 2:
            ie.segmentDuration = N.int32();
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        lifecycle: Le(b.lifecycle) ? a.HlsLifecycle.fromJSON(b.lifecycle) : void 0,
        segmentDuration: Le(b.segmentDuration) ? Number(b.segmentDuration) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.lifecycle !== void 0 && (C.lifecycle = b.lifecycle ? a.HlsLifecycle.toJSON(b.lifecycle) : void 0), b.segmentDuration !== void 0 && (C.segmentDuration = Math.round(b.segmentDuration)), C;
    },
    fromPartial(b) {
      var C;
      const N = Gt();
      return N.lifecycle = b.lifecycle !== void 0 && b.lifecycle !== null ? a.HlsLifecycle.fromPartial(b.lifecycle) : void 0, N.segmentDuration = (C = b.segmentDuration) !== null && C !== void 0 ? C : void 0, N;
    }
  };
  function Yt() {
    return { hls: void 0 };
  }
  a.ObjectStoragePackaging = {
    encode(b, C = c.default.Writer.create()) {
      return b.hls !== void 0 && a.HlsPackaging.encode(b.hls, C.uint32(10).fork()).ldelim(), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = Yt();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.hls = a.HlsPackaging.decode(N, N.uint32());
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { hls: Le(b.hls) ? a.HlsPackaging.fromJSON(b.hls) : void 0 };
    },
    toJSON(b) {
      const C = {};
      return b.hls !== void 0 && (C.hls = b.hls ? a.HlsPackaging.toJSON(b.hls) : void 0), C;
    },
    fromPartial(b) {
      const C = Yt();
      return C.hls = b.hls !== void 0 && b.hls !== null ? a.HlsPackaging.fromPartial(b.hls) : void 0, C;
    }
  };
  function Zt() {
    return {
      region: "",
      bucket: "",
      prefix: void 0,
      accessKey: "",
      secretKey: "",
      token: void 0,
      tokenDuration: void 0,
      acl: void 0,
      endpoint: void 0,
      packaging: void 0
    };
  }
  a.S3StorageAddress = {
    encode(b, C = c.default.Writer.create()) {
      return b.region !== "" && C.uint32(10).string(b.region), b.bucket !== "" && C.uint32(18).string(b.bucket), b.prefix !== void 0 && C.uint32(26).string(b.prefix), b.accessKey !== "" && C.uint32(34).string(b.accessKey), b.secretKey !== "" && C.uint32(42).string(b.secretKey), b.token !== void 0 && C.uint32(50).string(b.token), b.tokenDuration !== void 0 && C.uint32(56).int32(b.tokenDuration), b.acl !== void 0 && C.uint32(64).int32(Ge(b.acl)), b.endpoint !== void 0 && C.uint32(74).string(b.endpoint), b.packaging !== void 0 && a.ObjectStoragePackaging.encode(b.packaging, C.uint32(82).fork()).ldelim(), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = Zt();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.region = N.string();
            break;
          case 2:
            ie.bucket = N.string();
            break;
          case 3:
            ie.prefix = N.string();
            break;
          case 4:
            ie.accessKey = N.string();
            break;
          case 5:
            ie.secretKey = N.string();
            break;
          case 6:
            ie.token = N.string();
            break;
          case 7:
            ie.tokenDuration = N.int32();
            break;
          case 8:
            ie.acl = yt(N.int32());
            break;
          case 9:
            ie.endpoint = N.string();
            break;
          case 10:
            ie.packaging = a.ObjectStoragePackaging.decode(N, N.uint32());
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        region: Le(b.region) ? String(b.region) : "",
        bucket: Le(b.bucket) ? String(b.bucket) : "",
        prefix: Le(b.prefix) ? String(b.prefix) : void 0,
        accessKey: Le(b.accessKey) ? String(b.accessKey) : "",
        secretKey: Le(b.secretKey) ? String(b.secretKey) : "",
        token: Le(b.token) ? String(b.token) : void 0,
        tokenDuration: Le(b.tokenDuration) ? Number(b.tokenDuration) : void 0,
        acl: Le(b.acl) ? yt(b.acl) : void 0,
        endpoint: Le(b.endpoint) ? String(b.endpoint) : void 0,
        packaging: Le(b.packaging) ? a.ObjectStoragePackaging.fromJSON(b.packaging) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.region !== void 0 && (C.region = b.region), b.bucket !== void 0 && (C.bucket = b.bucket), b.prefix !== void 0 && (C.prefix = b.prefix), b.accessKey !== void 0 && (C.accessKey = b.accessKey), b.secretKey !== void 0 && (C.secretKey = b.secretKey), b.token !== void 0 && (C.token = b.token), b.tokenDuration !== void 0 && (C.tokenDuration = Math.round(b.tokenDuration)), b.acl !== void 0 && (C.acl = b.acl !== void 0 ? Xe(b.acl) : void 0), b.endpoint !== void 0 && (C.endpoint = b.endpoint), b.packaging !== void 0 && (C.packaging = b.packaging ? a.ObjectStoragePackaging.toJSON(b.packaging) : void 0), C;
    },
    fromPartial(b) {
      var C, N, _e, ie, Re, gt, Ct, Dt, Lt;
      const qt = Zt();
      return qt.region = (C = b.region) !== null && C !== void 0 ? C : "", qt.bucket = (N = b.bucket) !== null && N !== void 0 ? N : "", qt.prefix = (_e = b.prefix) !== null && _e !== void 0 ? _e : void 0, qt.accessKey = (ie = b.accessKey) !== null && ie !== void 0 ? ie : "", qt.secretKey = (Re = b.secretKey) !== null && Re !== void 0 ? Re : "", qt.token = (gt = b.token) !== null && gt !== void 0 ? gt : void 0, qt.tokenDuration = (Ct = b.tokenDuration) !== null && Ct !== void 0 ? Ct : void 0, qt.acl = (Dt = b.acl) !== null && Dt !== void 0 ? Dt : void 0, qt.endpoint = (Lt = b.endpoint) !== null && Lt !== void 0 ? Lt : void 0, qt.packaging = b.packaging !== void 0 && b.packaging !== null ? a.ObjectStoragePackaging.fromPartial(b.packaging) : void 0, qt;
    }
  };
  function jt() {
    return { rtmpPush: void 0, agora: void 0, s3Storage: void 0, srtPush: void 0 };
  }
  a.DestinationAddress = {
    encode(b, C = c.default.Writer.create()) {
      return b.rtmpPush !== void 0 && a.DestinationRtmpPushAddress.encode(b.rtmpPush, C.uint32(10).fork()).ldelim(), b.agora !== void 0 && a.DestinationAgoraPushAddress.encode(b.agora, C.uint32(18).fork()).ldelim(), b.s3Storage !== void 0 && a.S3StorageAddress.encode(b.s3Storage, C.uint32(26).fork()).ldelim(), b.srtPush !== void 0 && a.DestinationSrtPushAddress.encode(b.srtPush, C.uint32(34).fork()).ldelim(), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = jt();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.rtmpPush = a.DestinationRtmpPushAddress.decode(N, N.uint32());
            break;
          case 2:
            ie.agora = a.DestinationAgoraPushAddress.decode(N, N.uint32());
            break;
          case 3:
            ie.s3Storage = a.S3StorageAddress.decode(N, N.uint32());
            break;
          case 4:
            ie.srtPush = a.DestinationSrtPushAddress.decode(N, N.uint32());
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        rtmpPush: Le(b.rtmpPush) ? a.DestinationRtmpPushAddress.fromJSON(b.rtmpPush) : void 0,
        agora: Le(b.agora) ? a.DestinationAgoraPushAddress.fromJSON(b.agora) : void 0,
        s3Storage: Le(b.s3Storage) ? a.S3StorageAddress.fromJSON(b.s3Storage) : void 0,
        srtPush: Le(b.srtPush) ? a.DestinationSrtPushAddress.fromJSON(b.srtPush) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.rtmpPush !== void 0 && (C.rtmpPush = b.rtmpPush ? a.DestinationRtmpPushAddress.toJSON(b.rtmpPush) : void 0), b.agora !== void 0 && (C.agora = b.agora ? a.DestinationAgoraPushAddress.toJSON(b.agora) : void 0), b.s3Storage !== void 0 && (C.s3Storage = b.s3Storage ? a.S3StorageAddress.toJSON(b.s3Storage) : void 0), b.srtPush !== void 0 && (C.srtPush = b.srtPush ? a.DestinationSrtPushAddress.toJSON(b.srtPush) : void 0), C;
    },
    fromPartial(b) {
      const C = jt();
      return C.rtmpPush = b.rtmpPush !== void 0 && b.rtmpPush !== null ? a.DestinationRtmpPushAddress.fromPartial(b.rtmpPush) : void 0, C.agora = b.agora !== void 0 && b.agora !== null ? a.DestinationAgoraPushAddress.fromPartial(b.agora) : void 0, C.s3Storage = b.s3Storage !== void 0 && b.s3Storage !== null ? a.S3StorageAddress.fromPartial(b.s3Storage) : void 0, C.srtPush = b.srtPush !== void 0 && b.srtPush !== null ? a.DestinationSrtPushAddress.fromPartial(b.srtPush) : void 0, C;
    }
  };
  function Xt() {
    return { sourceId: "", start: void 0, stop: void 0 };
  }
  a.SourceTrigger = {
    encode(b, C = c.default.Writer.create()) {
      return b.sourceId !== "" && C.uint32(10).string(b.sourceId), b.start !== void 0 && C.uint32(16).int32(We(b.start)), b.stop !== void 0 && C.uint32(24).int32(We(b.stop)), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = Xt();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.sourceId = N.string();
            break;
          case 2:
            ie.start = ge(N.int32());
            break;
          case 3:
            ie.stop = ge(N.int32());
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        sourceId: Le(b.sourceId) ? String(b.sourceId) : "",
        start: Le(b.start) ? ge(b.start) : void 0,
        stop: Le(b.stop) ? ge(b.stop) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.sourceId !== void 0 && (C.sourceId = b.sourceId), b.start !== void 0 && (C.start = b.start !== void 0 ? we(b.start) : void 0), b.stop !== void 0 && (C.stop = b.stop !== void 0 ? we(b.stop) : void 0), C;
    },
    fromPartial(b) {
      var C, N, _e;
      const ie = Xt();
      return ie.sourceId = (C = b.sourceId) !== null && C !== void 0 ? C : "", ie.start = (N = b.start) !== null && N !== void 0 ? N : void 0, ie.stop = (_e = b.stop) !== null && _e !== void 0 ? _e : void 0, ie;
    }
  };
  function Qt() {
    return { stop: void 0 };
  }
  a.WebRtcTrigger = {
    encode(b, C = c.default.Writer.create()) {
      return b.stop !== void 0 && C.uint32(24).int32(We(b.stop)), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = Qt();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 3:
            ie.stop = ge(N.int32());
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { stop: Le(b.stop) ? ge(b.stop) : void 0 };
    },
    toJSON(b) {
      const C = {};
      return b.stop !== void 0 && (C.stop = b.stop !== void 0 ? we(b.stop) : void 0), C;
    },
    fromPartial(b) {
      var C;
      const N = Qt();
      return N.stop = (C = b.stop) !== null && C !== void 0 ? C : void 0, N;
    }
  };
  function er() {
    return { source: void 0 };
  }
  a.ProjectTrigger = {
    encode(b, C = c.default.Writer.create()) {
      return b.source !== void 0 && a.SourceTrigger.encode(b.source, C.uint32(10).fork()).ldelim(), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = er();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.source = a.SourceTrigger.decode(N, N.uint32());
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { source: Le(b.source) ? a.SourceTrigger.fromJSON(b.source) : void 0 };
    },
    toJSON(b) {
      const C = {};
      return b.source !== void 0 && (C.source = b.source ? a.SourceTrigger.toJSON(b.source) : void 0), C;
    },
    fromPartial(b) {
      const C = er();
      return C.source = b.source !== void 0 && b.source !== null ? a.SourceTrigger.fromPartial(b.source) : void 0, C;
    }
  };
  function tr() {
    return { enabled: void 0, url: void 0 };
  }
  a.PreviewHlsPullAddress = {
    encode(b, C = c.default.Writer.create()) {
      return b.enabled !== void 0 && C.uint32(8).bool(b.enabled), b.url !== void 0 && C.uint32(18).string(b.url), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = tr();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.enabled = N.bool();
            break;
          case 2:
            ie.url = N.string();
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        enabled: Le(b.enabled) ? !!b.enabled : void 0,
        url: Le(b.url) ? String(b.url) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.enabled !== void 0 && (C.enabled = b.enabled), b.url !== void 0 && (C.url = b.url), C;
    },
    fromPartial(b) {
      var C, N;
      const _e = tr();
      return _e.enabled = (C = b.enabled) !== null && C !== void 0 ? C : void 0, _e.url = (N = b.url) !== null && N !== void 0 ? N : void 0, _e;
    }
  };
  function rr() {
    return { enabled: void 0, displayName: void 0, participantId: void 0 };
  }
  a.PreviewWebRtcAddress = {
    encode(b, C = c.default.Writer.create()) {
      return b.enabled !== void 0 && C.uint32(8).bool(b.enabled), b.displayName !== void 0 && C.uint32(18).string(b.displayName), b.participantId !== void 0 && C.uint32(26).string(b.participantId), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = rr();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.enabled = N.bool();
            break;
          case 2:
            ie.displayName = N.string();
            break;
          case 3:
            ie.participantId = N.string();
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        enabled: Le(b.enabled) ? !!b.enabled : void 0,
        displayName: Le(b.displayName) ? String(b.displayName) : void 0,
        participantId: Le(b.participantId) ? String(b.participantId) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.enabled !== void 0 && (C.enabled = b.enabled), b.displayName !== void 0 && (C.displayName = b.displayName), b.participantId !== void 0 && (C.participantId = b.participantId), C;
    },
    fromPartial(b) {
      var C, N, _e;
      const ie = rr();
      return ie.enabled = (C = b.enabled) !== null && C !== void 0 ? C : void 0, ie.displayName = (N = b.displayName) !== null && N !== void 0 ? N : void 0, ie.participantId = (_e = b.participantId) !== null && _e !== void 0 ? _e : void 0, ie;
    }
  };
  function nr() {
    return { webrtc: void 0 };
  }
  a.PreviewAddress = {
    encode(b, C = c.default.Writer.create()) {
      return b.webrtc !== void 0 && a.PreviewWebRtcAddress.encode(b.webrtc, C.uint32(18).fork()).ldelim(), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = nr();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 2:
            ie.webrtc = a.PreviewWebRtcAddress.decode(N, N.uint32());
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { webrtc: Le(b.webrtc) ? a.PreviewWebRtcAddress.fromJSON(b.webrtc) : void 0 };
    },
    toJSON(b) {
      const C = {};
      return b.webrtc !== void 0 && (C.webrtc = b.webrtc ? a.PreviewWebRtcAddress.toJSON(b.webrtc) : void 0), C;
    },
    fromPartial(b) {
      const C = nr();
      return C.webrtc = b.webrtc !== void 0 && b.webrtc !== null ? a.PreviewWebRtcAddress.fromPartial(b.webrtc) : void 0, C;
    }
  };
  function ir() {
    return { rendererUrl: void 0, version: void 0 };
  }
  a.StudioSdkComposition = {
    encode(b, C = c.default.Writer.create()) {
      return b.rendererUrl !== void 0 && C.uint32(10).string(b.rendererUrl), b.version !== void 0 && C.uint32(18).string(b.version), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = ir();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.rendererUrl = N.string();
            break;
          case 2:
            ie.version = N.string();
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        rendererUrl: Le(b.rendererUrl) ? String(b.rendererUrl) : void 0,
        version: Le(b.version) ? String(b.version) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.rendererUrl !== void 0 && (C.rendererUrl = b.rendererUrl), b.version !== void 0 && (C.version = b.version), C;
    },
    fromPartial(b) {
      var C, N;
      const _e = ir();
      return _e.rendererUrl = (C = b.rendererUrl) !== null && C !== void 0 ? C : void 0, _e.version = (N = b.version) !== null && N !== void 0 ? N : void 0, _e;
    }
  };
  function ar() {
    return { rendererUrl: void 0, selectedLayoutId: void 0, debug: void 0 };
  }
  a.SceneComposition = {
    encode(b, C = c.default.Writer.create()) {
      return b.rendererUrl !== void 0 && C.uint32(10).string(b.rendererUrl), b.selectedLayoutId !== void 0 && C.uint32(18).string(b.selectedLayoutId), b.debug !== void 0 && C.uint32(24).bool(b.debug), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = ar();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.rendererUrl = N.string();
            break;
          case 2:
            ie.selectedLayoutId = N.string();
            break;
          case 3:
            ie.debug = N.bool();
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        rendererUrl: Le(b.rendererUrl) ? String(b.rendererUrl) : void 0,
        selectedLayoutId: Le(b.selectedLayoutId) ? String(b.selectedLayoutId) : void 0,
        debug: Le(b.debug) ? !!b.debug : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.rendererUrl !== void 0 && (C.rendererUrl = b.rendererUrl), b.selectedLayoutId !== void 0 && (C.selectedLayoutId = b.selectedLayoutId), b.debug !== void 0 && (C.debug = b.debug), C;
    },
    fromPartial(b) {
      var C, N, _e;
      const ie = ar();
      return ie.rendererUrl = (C = b.rendererUrl) !== null && C !== void 0 ? C : void 0, ie.selectedLayoutId = (N = b.selectedLayoutId) !== null && N !== void 0 ? N : void 0, ie.debug = (_e = b.debug) !== null && _e !== void 0 ? _e : void 0, ie;
    }
  };
  function or() {
    return { url: "" };
  }
  a.ExternalComposition = {
    encode(b, C = c.default.Writer.create()) {
      return b.url !== "" && C.uint32(10).string(b.url), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = or();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.url = N.string();
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { url: Le(b.url) ? String(b.url) : "" };
    },
    toJSON(b) {
      const C = {};
      return b.url !== void 0 && (C.url = b.url), C;
    },
    fromPartial(b) {
      var C;
      const N = or();
      return N.url = (C = b.url) !== null && C !== void 0 ? C : "", N;
    }
  };
  function dr() {
    return { external: void 0, studioSdk: void 0, scene: void 0 };
  }
  a.Composition = {
    encode(b, C = c.default.Writer.create()) {
      return b.external !== void 0 && a.ExternalComposition.encode(b.external, C.uint32(10).fork()).ldelim(), b.studioSdk !== void 0 && a.StudioSdkComposition.encode(b.studioSdk, C.uint32(18).fork()).ldelim(), b.scene !== void 0 && a.SceneComposition.encode(b.scene, C.uint32(34).fork()).ldelim(), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = dr();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.external = a.ExternalComposition.decode(N, N.uint32());
            break;
          case 2:
            ie.studioSdk = a.StudioSdkComposition.decode(N, N.uint32());
            break;
          case 4:
            ie.scene = a.SceneComposition.decode(N, N.uint32());
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        external: Le(b.external) ? a.ExternalComposition.fromJSON(b.external) : void 0,
        studioSdk: Le(b.studioSdk) ? a.StudioSdkComposition.fromJSON(b.studioSdk) : void 0,
        scene: Le(b.scene) ? a.SceneComposition.fromJSON(b.scene) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.external !== void 0 && (C.external = b.external ? a.ExternalComposition.toJSON(b.external) : void 0), b.studioSdk !== void 0 && (C.studioSdk = b.studioSdk ? a.StudioSdkComposition.toJSON(b.studioSdk) : void 0), b.scene !== void 0 && (C.scene = b.scene ? a.SceneComposition.toJSON(b.scene) : void 0), C;
    },
    fromPartial(b) {
      const C = dr();
      return C.external = b.external !== void 0 && b.external !== null ? a.ExternalComposition.fromPartial(b.external) : void 0, C.studioSdk = b.studioSdk !== void 0 && b.studioSdk !== null ? a.StudioSdkComposition.fromPartial(b.studioSdk) : void 0, C.scene = b.scene !== void 0 && b.scene !== null ? a.SceneComposition.fromPartial(b.scene) : void 0, C;
    }
  };
  function ur() {
    return { enabled: void 0 };
  }
  a.HostedWebRtc = {
    encode(b, C = c.default.Writer.create()) {
      return b.enabled !== void 0 && C.uint32(8).bool(b.enabled), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = ur();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.enabled = N.bool();
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { enabled: Le(b.enabled) ? !!b.enabled : void 0 };
    },
    toJSON(b) {
      const C = {};
      return b.enabled !== void 0 && (C.enabled = b.enabled), C;
    },
    fromPartial(b) {
      var C;
      const N = ur();
      return N.enabled = (C = b.enabled) !== null && C !== void 0 ? C : void 0, N;
    }
  };
  function cr() {
    return { hosted: void 0 };
  }
  a.WebRtc = {
    encode(b, C = c.default.Writer.create()) {
      return b.hosted !== void 0 && a.HostedWebRtc.encode(b.hosted, C.uint32(10).fork()).ldelim(), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = cr();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.hosted = a.HostedWebRtc.decode(N, N.uint32());
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { hosted: Le(b.hosted) ? a.HostedWebRtc.fromJSON(b.hosted) : void 0 };
    },
    toJSON(b) {
      const C = {};
      return b.hosted !== void 0 && (C.hosted = b.hosted ? a.HostedWebRtc.toJSON(b.hosted) : void 0), C;
    },
    fromPartial(b) {
      const C = cr();
      return C.hosted = b.hosted !== void 0 && b.hosted !== null ? a.HostedWebRtc.fromPartial(b.hosted) : void 0, C;
    }
  };
  function lr() {
    return { accessToken: "", participantId: void 0 };
  }
  a.WebRtcAccess = {
    encode(b, C = c.default.Writer.create()) {
      return b.accessToken !== "" && C.uint32(10).string(b.accessToken), b.participantId !== void 0 && C.uint32(26).string(b.participantId), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = lr();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.accessToken = N.string();
            break;
          case 3:
            ie.participantId = N.string();
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        accessToken: Le(b.accessToken) ? String(b.accessToken) : "",
        participantId: Le(b.participantId) ? String(b.participantId) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.accessToken !== void 0 && (C.accessToken = b.accessToken), b.participantId !== void 0 && (C.participantId = b.participantId), C;
    },
    fromPartial(b) {
      var C, N;
      const _e = lr();
      return _e.accessToken = (C = b.accessToken) !== null && C !== void 0 ? C : "", _e.participantId = (N = b.participantId) !== null && N !== void 0 ? N : void 0, _e;
    }
  };
  function fr() {
    return { latitude: 0, longitude: 0 };
  }
  a.LatLong = {
    encode(b, C = c.default.Writer.create()) {
      return b.latitude !== 0 && C.uint32(9).double(b.latitude), b.longitude !== 0 && C.uint32(17).double(b.longitude), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = fr();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.latitude = N.double();
            break;
          case 2:
            ie.longitude = N.double();
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        latitude: Le(b.latitude) ? Number(b.latitude) : 0,
        longitude: Le(b.longitude) ? Number(b.longitude) : 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.latitude !== void 0 && (C.latitude = b.latitude), b.longitude !== void 0 && (C.longitude = b.longitude), C;
    },
    fromPartial(b) {
      var C, N;
      const _e = fr();
      return _e.latitude = (C = b.latitude) !== null && C !== void 0 ? C : 0, _e.longitude = (N = b.longitude) !== null && N !== void 0 ? N : 0, _e;
    }
  };
  function pr() {
    return { dynamicId: void 0, sourceId: void 0, rtmpPush: void 0, srtPush: void 0 };
  }
  a.DirectIngestUrl = {
    encode(b, C = c.default.Writer.create()) {
      return b.dynamicId !== void 0 && C.uint32(10).string(b.dynamicId), b.sourceId !== void 0 && C.uint32(18).string(b.sourceId), b.rtmpPush !== void 0 && a.SourceRtmpPushAddress.encode(b.rtmpPush, C.uint32(82).fork()).ldelim(), b.srtPush !== void 0 && a.SrtPushAddress.encode(b.srtPush, C.uint32(90).fork()).ldelim(), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = pr();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.dynamicId = N.string();
            break;
          case 2:
            ie.sourceId = N.string();
            break;
          case 10:
            ie.rtmpPush = a.SourceRtmpPushAddress.decode(N, N.uint32());
            break;
          case 11:
            ie.srtPush = a.SrtPushAddress.decode(N, N.uint32());
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        dynamicId: Le(b.dynamicId) ? String(b.dynamicId) : void 0,
        sourceId: Le(b.sourceId) ? String(b.sourceId) : void 0,
        rtmpPush: Le(b.rtmpPush) ? a.SourceRtmpPushAddress.fromJSON(b.rtmpPush) : void 0,
        srtPush: Le(b.srtPush) ? a.SrtPushAddress.fromJSON(b.srtPush) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.dynamicId !== void 0 && (C.dynamicId = b.dynamicId), b.sourceId !== void 0 && (C.sourceId = b.sourceId), b.rtmpPush !== void 0 && (C.rtmpPush = b.rtmpPush ? a.SourceRtmpPushAddress.toJSON(b.rtmpPush) : void 0), b.srtPush !== void 0 && (C.srtPush = b.srtPush ? a.SrtPushAddress.toJSON(b.srtPush) : void 0), C;
    },
    fromPartial(b) {
      var C, N;
      const _e = pr();
      return _e.dynamicId = (C = b.dynamicId) !== null && C !== void 0 ? C : void 0, _e.sourceId = (N = b.sourceId) !== null && N !== void 0 ? N : void 0, _e.rtmpPush = b.rtmpPush !== void 0 && b.rtmpPush !== null ? a.SourceRtmpPushAddress.fromPartial(b.rtmpPush) : void 0, _e.srtPush = b.srtPush !== void 0 && b.srtPush !== null ? a.SrtPushAddress.fromPartial(b.srtPush) : void 0, _e;
    }
  };
  function vr() {
    return {
      collectionId: "",
      projectId: "",
      broadcastId: void 0,
      duration: void 0,
      start: void 0,
      stop: void 0,
      phase: $e.PROJECT_BROADCAST_PHASE_UNSPECIFIED,
      region: void 0,
      datacenter: void 0,
      directIngests: []
    };
  }
  a.ProjectBroadcastStatus = {
    encode(b, C = c.default.Writer.create()) {
      b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.projectId !== "" && C.uint32(18).string(b.projectId), b.broadcastId !== void 0 && C.uint32(26).string(b.broadcastId), b.duration !== void 0 && C.uint32(32).uint32(b.duration), b.start !== void 0 && _.Timestamp.encode(Ht(b.start), C.uint32(42).fork()).ldelim(), b.stop !== void 0 && _.Timestamp.encode(Ht(b.stop), C.uint32(50).fork()).ldelim(), b.phase !== $e.PROJECT_BROADCAST_PHASE_UNSPECIFIED && C.uint32(56).int32(Ze(b.phase)), b.region !== void 0 && C.uint32(64).int32(de(b.region)), b.datacenter !== void 0 && C.uint32(74).string(b.datacenter);
      for (const N of b.directIngests)
        a.DirectIngestUrl.encode(N, C.uint32(82).fork()).ldelim();
      return C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = vr();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.projectId = N.string();
            break;
          case 3:
            ie.broadcastId = N.string();
            break;
          case 4:
            ie.duration = N.uint32();
            break;
          case 5:
            ie.start = zt(_.Timestamp.decode(N, N.uint32()));
            break;
          case 6:
            ie.stop = zt(_.Timestamp.decode(N, N.uint32()));
            break;
          case 7:
            ie.phase = Oe(N.int32());
            break;
          case 8:
            ie.region = V(N.int32());
            break;
          case 9:
            ie.datacenter = N.string();
            break;
          case 10:
            ie.directIngests.push(a.DirectIngestUrl.decode(N, N.uint32()));
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : "",
        broadcastId: Le(b.broadcastId) ? String(b.broadcastId) : void 0,
        duration: Le(b.duration) ? Number(b.duration) : void 0,
        start: Le(b.start) ? String(b.start) : void 0,
        stop: Le(b.stop) ? String(b.stop) : void 0,
        phase: Le(b.phase) ? Oe(b.phase) : $e.PROJECT_BROADCAST_PHASE_UNSPECIFIED,
        region: Le(b.region) ? V(b.region) : void 0,
        datacenter: Le(b.datacenter) ? String(b.datacenter) : void 0,
        directIngests: Array.isArray(b == null ? void 0 : b.directIngests) ? b.directIngests.map((C) => a.DirectIngestUrl.fromJSON(C)) : []
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.projectId !== void 0 && (C.projectId = b.projectId), b.broadcastId !== void 0 && (C.broadcastId = b.broadcastId), b.duration !== void 0 && (C.duration = Math.round(b.duration)), b.start !== void 0 && (C.start = b.start), b.stop !== void 0 && (C.stop = b.stop), b.phase !== void 0 && (C.phase = Fe(b.phase)), b.region !== void 0 && (C.region = b.region !== void 0 ? Ee(b.region) : void 0), b.datacenter !== void 0 && (C.datacenter = b.datacenter), b.directIngests ? C.directIngests = b.directIngests.map((N) => N ? a.DirectIngestUrl.toJSON(N) : void 0) : C.directIngests = [], C;
    },
    fromPartial(b) {
      var C, N, _e, ie, Re, gt, Ct, Dt, Lt, qt;
      const Vt = vr();
      return Vt.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", Vt.projectId = (N = b.projectId) !== null && N !== void 0 ? N : "", Vt.broadcastId = (_e = b.broadcastId) !== null && _e !== void 0 ? _e : void 0, Vt.duration = (ie = b.duration) !== null && ie !== void 0 ? ie : void 0, Vt.start = (Re = b.start) !== null && Re !== void 0 ? Re : void 0, Vt.stop = (gt = b.stop) !== null && gt !== void 0 ? gt : void 0, Vt.phase = (Ct = b.phase) !== null && Ct !== void 0 ? Ct : $e.PROJECT_BROADCAST_PHASE_UNSPECIFIED, Vt.region = (Dt = b.region) !== null && Dt !== void 0 ? Dt : void 0, Vt.datacenter = (Lt = b.datacenter) !== null && Lt !== void 0 ? Lt : void 0, Vt.directIngests = ((qt = b.directIngests) === null || qt === void 0 ? void 0 : qt.map((Ri) => a.DirectIngestUrl.fromPartial(Ri))) || [], Vt;
    }
  };
  function yr() {
    return { collectionId: "", sourceId: "", metadata: void 0, preview: void 0, address: void 0 };
  }
  a.Source = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.sourceId !== "" && C.uint32(18).string(b.sourceId), b.metadata !== void 0 && p.Value.encode(p.Value.wrap(b.metadata), C.uint32(26).fork()).ldelim(), b.preview !== void 0 && a.PreviewAddress.encode(b.preview, C.uint32(34).fork()).ldelim(), b.address !== void 0 && a.SourceAddress.encode(b.address, C.uint32(50).fork()).ldelim(), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = yr();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.sourceId = N.string();
            break;
          case 3:
            ie.metadata = p.Value.unwrap(p.Value.decode(N, N.uint32()));
            break;
          case 4:
            ie.preview = a.PreviewAddress.decode(N, N.uint32());
            break;
          case 6:
            ie.address = a.SourceAddress.decode(N, N.uint32());
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        sourceId: Le(b.sourceId) ? String(b.sourceId) : "",
        metadata: Le(b == null ? void 0 : b.metadata) ? b.metadata : void 0,
        preview: Le(b.preview) ? a.PreviewAddress.fromJSON(b.preview) : void 0,
        address: Le(b.address) ? a.SourceAddress.fromJSON(b.address) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.sourceId !== void 0 && (C.sourceId = b.sourceId), b.metadata !== void 0 && (C.metadata = b.metadata), b.preview !== void 0 && (C.preview = b.preview ? a.PreviewAddress.toJSON(b.preview) : void 0), b.address !== void 0 && (C.address = b.address ? a.SourceAddress.toJSON(b.address) : void 0), C;
    },
    fromPartial(b) {
      var C, N, _e;
      const ie = yr();
      return ie.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", ie.sourceId = (N = b.sourceId) !== null && N !== void 0 ? N : "", ie.metadata = (_e = b.metadata) !== null && _e !== void 0 ? _e : void 0, ie.preview = b.preview !== void 0 && b.preview !== null ? a.PreviewAddress.fromPartial(b.preview) : void 0, ie.address = b.address !== void 0 && b.address !== null ? a.SourceAddress.fromPartial(b.address) : void 0, ie;
    }
  };
  function gr() {
    return {
      collectionId: "",
      projectId: "",
      destinationId: "",
      metadata: void 0,
      enabled: void 0,
      address: void 0,
      timeout: void 0
    };
  }
  a.Destination = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.projectId !== "" && C.uint32(18).string(b.projectId), b.destinationId !== "" && C.uint32(26).string(b.destinationId), b.metadata !== void 0 && p.Value.encode(p.Value.wrap(b.metadata), C.uint32(34).fork()).ldelim(), b.enabled !== void 0 && C.uint32(40).bool(b.enabled), b.address !== void 0 && a.DestinationAddress.encode(b.address, C.uint32(50).fork()).ldelim(), b.timeout !== void 0 && C.uint32(56).uint32(b.timeout), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = gr();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.projectId = N.string();
            break;
          case 3:
            ie.destinationId = N.string();
            break;
          case 4:
            ie.metadata = p.Value.unwrap(p.Value.decode(N, N.uint32()));
            break;
          case 5:
            ie.enabled = N.bool();
            break;
          case 6:
            ie.address = a.DestinationAddress.decode(N, N.uint32());
            break;
          case 7:
            ie.timeout = N.uint32();
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : "",
        destinationId: Le(b.destinationId) ? String(b.destinationId) : "",
        metadata: Le(b == null ? void 0 : b.metadata) ? b.metadata : void 0,
        enabled: Le(b.enabled) ? !!b.enabled : void 0,
        address: Le(b.address) ? a.DestinationAddress.fromJSON(b.address) : void 0,
        timeout: Le(b.timeout) ? Number(b.timeout) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.projectId !== void 0 && (C.projectId = b.projectId), b.destinationId !== void 0 && (C.destinationId = b.destinationId), b.metadata !== void 0 && (C.metadata = b.metadata), b.enabled !== void 0 && (C.enabled = b.enabled), b.address !== void 0 && (C.address = b.address ? a.DestinationAddress.toJSON(b.address) : void 0), b.timeout !== void 0 && (C.timeout = Math.round(b.timeout)), C;
    },
    fromPartial(b) {
      var C, N, _e, ie, Re, gt;
      const Ct = gr();
      return Ct.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", Ct.projectId = (N = b.projectId) !== null && N !== void 0 ? N : "", Ct.destinationId = (_e = b.destinationId) !== null && _e !== void 0 ? _e : "", Ct.metadata = (ie = b.metadata) !== null && ie !== void 0 ? ie : void 0, Ct.enabled = (Re = b.enabled) !== null && Re !== void 0 ? Re : void 0, Ct.address = b.address !== void 0 && b.address !== null ? a.DestinationAddress.fromPartial(b.address) : void 0, Ct.timeout = (gt = b.timeout) !== null && gt !== void 0 ? gt : void 0, Ct;
    }
  };
  function br() {
    return {
      collectionId: "",
      projectId: "",
      metadata: void 0,
      rendering: void 0,
      encoding: void 0,
      sources: [],
      destinations: [],
      composition: void 0,
      maxDuration: void 0,
      webrtc: void 0,
      triggers: [],
      location: void 0,
      guestCodes: []
    };
  }
  a.Project = {
    encode(b, C = c.default.Writer.create()) {
      b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.projectId !== "" && C.uint32(18).string(b.projectId), b.metadata !== void 0 && p.Value.encode(p.Value.wrap(b.metadata), C.uint32(26).fork()).ldelim(), b.rendering !== void 0 && a.Rendering.encode(b.rendering, C.uint32(34).fork()).ldelim(), b.encoding !== void 0 && a.Encoding.encode(b.encoding, C.uint32(42).fork()).ldelim();
      for (const N of b.sources)
        a.Source.encode(N, C.uint32(50).fork()).ldelim();
      for (const N of b.destinations)
        a.Destination.encode(N, C.uint32(58).fork()).ldelim();
      b.composition !== void 0 && a.Composition.encode(b.composition, C.uint32(66).fork()).ldelim(), b.maxDuration !== void 0 && C.uint32(72).uint32(b.maxDuration), b.webrtc !== void 0 && a.WebRtc.encode(b.webrtc, C.uint32(82).fork()).ldelim();
      for (const N of b.triggers)
        a.ProjectTrigger.encode(N, C.uint32(90).fork()).ldelim();
      b.location !== void 0 && a.LatLong.encode(b.location, C.uint32(98).fork()).ldelim();
      for (const N of b.guestCodes)
        a.GuestCode.encode(N, C.uint32(106).fork()).ldelim();
      return C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = br();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.projectId = N.string();
            break;
          case 3:
            ie.metadata = p.Value.unwrap(p.Value.decode(N, N.uint32()));
            break;
          case 4:
            ie.rendering = a.Rendering.decode(N, N.uint32());
            break;
          case 5:
            ie.encoding = a.Encoding.decode(N, N.uint32());
            break;
          case 6:
            ie.sources.push(a.Source.decode(N, N.uint32()));
            break;
          case 7:
            ie.destinations.push(a.Destination.decode(N, N.uint32()));
            break;
          case 8:
            ie.composition = a.Composition.decode(N, N.uint32());
            break;
          case 9:
            ie.maxDuration = N.uint32();
            break;
          case 10:
            ie.webrtc = a.WebRtc.decode(N, N.uint32());
            break;
          case 11:
            ie.triggers.push(a.ProjectTrigger.decode(N, N.uint32()));
            break;
          case 12:
            ie.location = a.LatLong.decode(N, N.uint32());
            break;
          case 13:
            ie.guestCodes.push(a.GuestCode.decode(N, N.uint32()));
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : "",
        metadata: Le(b == null ? void 0 : b.metadata) ? b.metadata : void 0,
        rendering: Le(b.rendering) ? a.Rendering.fromJSON(b.rendering) : void 0,
        encoding: Le(b.encoding) ? a.Encoding.fromJSON(b.encoding) : void 0,
        sources: Array.isArray(b == null ? void 0 : b.sources) ? b.sources.map((C) => a.Source.fromJSON(C)) : [],
        destinations: Array.isArray(b == null ? void 0 : b.destinations) ? b.destinations.map((C) => a.Destination.fromJSON(C)) : [],
        composition: Le(b.composition) ? a.Composition.fromJSON(b.composition) : void 0,
        maxDuration: Le(b.maxDuration) ? Number(b.maxDuration) : void 0,
        webrtc: Le(b.webrtc) ? a.WebRtc.fromJSON(b.webrtc) : void 0,
        triggers: Array.isArray(b == null ? void 0 : b.triggers) ? b.triggers.map((C) => a.ProjectTrigger.fromJSON(C)) : [],
        location: Le(b.location) ? a.LatLong.fromJSON(b.location) : void 0,
        guestCodes: Array.isArray(b == null ? void 0 : b.guestCodes) ? b.guestCodes.map((C) => a.GuestCode.fromJSON(C)) : []
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.projectId !== void 0 && (C.projectId = b.projectId), b.metadata !== void 0 && (C.metadata = b.metadata), b.rendering !== void 0 && (C.rendering = b.rendering ? a.Rendering.toJSON(b.rendering) : void 0), b.encoding !== void 0 && (C.encoding = b.encoding ? a.Encoding.toJSON(b.encoding) : void 0), b.sources ? C.sources = b.sources.map((N) => N ? a.Source.toJSON(N) : void 0) : C.sources = [], b.destinations ? C.destinations = b.destinations.map((N) => N ? a.Destination.toJSON(N) : void 0) : C.destinations = [], b.composition !== void 0 && (C.composition = b.composition ? a.Composition.toJSON(b.composition) : void 0), b.maxDuration !== void 0 && (C.maxDuration = Math.round(b.maxDuration)), b.webrtc !== void 0 && (C.webrtc = b.webrtc ? a.WebRtc.toJSON(b.webrtc) : void 0), b.triggers ? C.triggers = b.triggers.map((N) => N ? a.ProjectTrigger.toJSON(N) : void 0) : C.triggers = [], b.location !== void 0 && (C.location = b.location ? a.LatLong.toJSON(b.location) : void 0), b.guestCodes ? C.guestCodes = b.guestCodes.map((N) => N ? a.GuestCode.toJSON(N) : void 0) : C.guestCodes = [], C;
    },
    fromPartial(b) {
      var C, N, _e, ie, Re, gt, Ct, Dt;
      const Lt = br();
      return Lt.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", Lt.projectId = (N = b.projectId) !== null && N !== void 0 ? N : "", Lt.metadata = (_e = b.metadata) !== null && _e !== void 0 ? _e : void 0, Lt.rendering = b.rendering !== void 0 && b.rendering !== null ? a.Rendering.fromPartial(b.rendering) : void 0, Lt.encoding = b.encoding !== void 0 && b.encoding !== null ? a.Encoding.fromPartial(b.encoding) : void 0, Lt.sources = ((ie = b.sources) === null || ie === void 0 ? void 0 : ie.map((qt) => a.Source.fromPartial(qt))) || [], Lt.destinations = ((Re = b.destinations) === null || Re === void 0 ? void 0 : Re.map((qt) => a.Destination.fromPartial(qt))) || [], Lt.composition = b.composition !== void 0 && b.composition !== null ? a.Composition.fromPartial(b.composition) : void 0, Lt.maxDuration = (gt = b.maxDuration) !== null && gt !== void 0 ? gt : void 0, Lt.webrtc = b.webrtc !== void 0 && b.webrtc !== null ? a.WebRtc.fromPartial(b.webrtc) : void 0, Lt.triggers = ((Ct = b.triggers) === null || Ct === void 0 ? void 0 : Ct.map((qt) => a.ProjectTrigger.fromPartial(qt))) || [], Lt.location = b.location !== void 0 && b.location !== null ? a.LatLong.fromPartial(b.location) : void 0, Lt.guestCodes = ((Dt = b.guestCodes) === null || Dt === void 0 ? void 0 : Dt.map((qt) => a.GuestCode.fromPartial(qt))) || [], Lt;
    }
  };
  function Sr() {
    return { collectionId: "", metadata: void 0, projects: [], sources: [] };
  }
  a.Collection = {
    encode(b, C = c.default.Writer.create()) {
      b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.metadata !== void 0 && p.Value.encode(p.Value.wrap(b.metadata), C.uint32(18).fork()).ldelim();
      for (const N of b.projects)
        a.Project.encode(N, C.uint32(26).fork()).ldelim();
      for (const N of b.sources)
        a.Source.encode(N, C.uint32(34).fork()).ldelim();
      return C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = Sr();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.metadata = p.Value.unwrap(p.Value.decode(N, N.uint32()));
            break;
          case 3:
            ie.projects.push(a.Project.decode(N, N.uint32()));
            break;
          case 4:
            ie.sources.push(a.Source.decode(N, N.uint32()));
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        metadata: Le(b == null ? void 0 : b.metadata) ? b.metadata : void 0,
        projects: Array.isArray(b == null ? void 0 : b.projects) ? b.projects.map((C) => a.Project.fromJSON(C)) : [],
        sources: Array.isArray(b == null ? void 0 : b.sources) ? b.sources.map((C) => a.Source.fromJSON(C)) : []
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.metadata !== void 0 && (C.metadata = b.metadata), b.projects ? C.projects = b.projects.map((N) => N ? a.Project.toJSON(N) : void 0) : C.projects = [], b.sources ? C.sources = b.sources.map((N) => N ? a.Source.toJSON(N) : void 0) : C.sources = [], C;
    },
    fromPartial(b) {
      var C, N, _e, ie;
      const Re = Sr();
      return Re.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", Re.metadata = (N = b.metadata) !== null && N !== void 0 ? N : void 0, Re.projects = ((_e = b.projects) === null || _e === void 0 ? void 0 : _e.map((gt) => a.Project.fromPartial(gt))) || [], Re.sources = ((ie = b.sources) === null || ie === void 0 ? void 0 : ie.map((gt) => a.Source.fromPartial(gt))) || [], Re;
    }
  };
  function _r() {
    return { metadata: void 0 };
  }
  a.CreateCollectionRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.metadata !== void 0 && p.Value.encode(p.Value.wrap(b.metadata), C.uint32(10).fork()).ldelim(), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = _r();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.metadata = p.Value.unwrap(p.Value.decode(N, N.uint32()));
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { metadata: Le(b == null ? void 0 : b.metadata) ? b.metadata : void 0 };
    },
    toJSON(b) {
      const C = {};
      return b.metadata !== void 0 && (C.metadata = b.metadata), C;
    },
    fromPartial(b) {
      var C;
      const N = _r();
      return N.metadata = (C = b.metadata) !== null && C !== void 0 ? C : void 0, N;
    }
  };
  function Er() {
    return { collection: void 0 };
  }
  a.CreateCollectionResponse = {
    encode(b, C = c.default.Writer.create()) {
      return b.collection !== void 0 && a.Collection.encode(b.collection, C.uint32(10).fork()).ldelim(), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = Er();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.collection = a.Collection.decode(N, N.uint32());
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { collection: Le(b.collection) ? a.Collection.fromJSON(b.collection) : void 0 };
    },
    toJSON(b) {
      const C = {};
      return b.collection !== void 0 && (C.collection = b.collection ? a.Collection.toJSON(b.collection) : void 0), C;
    },
    fromPartial(b) {
      const C = Er();
      return C.collection = b.collection !== void 0 && b.collection !== null ? a.Collection.fromPartial(b.collection) : void 0, C;
    }
  };
  function Tr() {
    return { collectionId: "", populateProjects: void 0, populateSources: void 0 };
  }
  a.GetCollectionRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.populateProjects !== void 0 && C.uint32(16).bool(b.populateProjects), b.populateSources !== void 0 && C.uint32(24).bool(b.populateSources), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = Tr();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.populateProjects = N.bool();
            break;
          case 3:
            ie.populateSources = N.bool();
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        populateProjects: Le(b.populateProjects) ? !!b.populateProjects : void 0,
        populateSources: Le(b.populateSources) ? !!b.populateSources : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.populateProjects !== void 0 && (C.populateProjects = b.populateProjects), b.populateSources !== void 0 && (C.populateSources = b.populateSources), C;
    },
    fromPartial(b) {
      var C, N, _e;
      const ie = Tr();
      return ie.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", ie.populateProjects = (N = b.populateProjects) !== null && N !== void 0 ? N : void 0, ie.populateSources = (_e = b.populateSources) !== null && _e !== void 0 ? _e : void 0, ie;
    }
  };
  function wr() {
    return { collection: void 0 };
  }
  a.GetCollectionResponse = {
    encode(b, C = c.default.Writer.create()) {
      return b.collection !== void 0 && a.Collection.encode(b.collection, C.uint32(10).fork()).ldelim(), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = wr();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.collection = a.Collection.decode(N, N.uint32());
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { collection: Le(b.collection) ? a.Collection.fromJSON(b.collection) : void 0 };
    },
    toJSON(b) {
      const C = {};
      return b.collection !== void 0 && (C.collection = b.collection ? a.Collection.toJSON(b.collection) : void 0), C;
    },
    fromPartial(b) {
      const C = wr();
      return C.collection = b.collection !== void 0 && b.collection !== null ? a.Collection.fromPartial(b.collection) : void 0, C;
    }
  };
  function kr() {
    return { collectionId: "", updateMask: void 0, metadata: void 0 };
  }
  a.UpdateCollectionRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.updateMask !== void 0 && v.FieldMask.encode(v.FieldMask.wrap(b.updateMask), C.uint32(18).fork()).ldelim(), b.metadata !== void 0 && p.Value.encode(p.Value.wrap(b.metadata), C.uint32(26).fork()).ldelim(), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = kr();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.updateMask = v.FieldMask.unwrap(v.FieldMask.decode(N, N.uint32()));
            break;
          case 3:
            ie.metadata = p.Value.unwrap(p.Value.decode(N, N.uint32()));
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        updateMask: Le(b.updateMask) ? v.FieldMask.unwrap(v.FieldMask.fromJSON(b.updateMask)) : void 0,
        metadata: Le(b == null ? void 0 : b.metadata) ? b.metadata : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.updateMask !== void 0 && (C.updateMask = v.FieldMask.toJSON(v.FieldMask.wrap(b.updateMask))), b.metadata !== void 0 && (C.metadata = b.metadata), C;
    },
    fromPartial(b) {
      var C, N, _e;
      const ie = kr();
      return ie.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", ie.updateMask = (N = b.updateMask) !== null && N !== void 0 ? N : void 0, ie.metadata = (_e = b.metadata) !== null && _e !== void 0 ? _e : void 0, ie;
    }
  };
  function Ir() {
    return { collection: void 0 };
  }
  a.UpdateCollectionResponse = {
    encode(b, C = c.default.Writer.create()) {
      return b.collection !== void 0 && a.Collection.encode(b.collection, C.uint32(10).fork()).ldelim(), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = Ir();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.collection = a.Collection.decode(N, N.uint32());
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { collection: Le(b.collection) ? a.Collection.fromJSON(b.collection) : void 0 };
    },
    toJSON(b) {
      const C = {};
      return b.collection !== void 0 && (C.collection = b.collection ? a.Collection.toJSON(b.collection) : void 0), C;
    },
    fromPartial(b) {
      const C = Ir();
      return C.collection = b.collection !== void 0 && b.collection !== null ? a.Collection.fromPartial(b.collection) : void 0, C;
    }
  };
  function Rr() {
    return { collectionId: "", force: void 0 };
  }
  a.DeleteCollectionRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.force !== void 0 && C.uint32(16).bool(b.force), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = Rr();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.force = N.bool();
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        force: Le(b.force) ? !!b.force : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.force !== void 0 && (C.force = b.force), C;
    },
    fromPartial(b) {
      var C, N;
      const _e = Rr();
      return _e.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", _e.force = (N = b.force) !== null && N !== void 0 ? N : void 0, _e;
    }
  };
  function Cr() {
    return { sourcesDeleted: 0, projectsDeleted: 0, projectIdsStopped: [] };
  }
  a.DeleteCollectionResponse = {
    encode(b, C = c.default.Writer.create()) {
      b.sourcesDeleted !== 0 && C.uint32(8).uint32(b.sourcesDeleted), b.projectsDeleted !== 0 && C.uint32(16).uint32(b.projectsDeleted);
      for (const N of b.projectIdsStopped)
        C.uint32(26).string(N);
      return C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = Cr();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.sourcesDeleted = N.uint32();
            break;
          case 2:
            ie.projectsDeleted = N.uint32();
            break;
          case 3:
            ie.projectIdsStopped.push(N.string());
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        sourcesDeleted: Le(b.sourcesDeleted) ? Number(b.sourcesDeleted) : 0,
        projectsDeleted: Le(b.projectsDeleted) ? Number(b.projectsDeleted) : 0,
        projectIdsStopped: Array.isArray(b == null ? void 0 : b.projectIdsStopped) ? b.projectIdsStopped.map((C) => String(C)) : []
      };
    },
    toJSON(b) {
      const C = {};
      return b.sourcesDeleted !== void 0 && (C.sourcesDeleted = Math.round(b.sourcesDeleted)), b.projectsDeleted !== void 0 && (C.projectsDeleted = Math.round(b.projectsDeleted)), b.projectIdsStopped ? C.projectIdsStopped = b.projectIdsStopped.map((N) => N) : C.projectIdsStopped = [], C;
    },
    fromPartial(b) {
      var C, N, _e;
      const ie = Cr();
      return ie.sourcesDeleted = (C = b.sourcesDeleted) !== null && C !== void 0 ? C : 0, ie.projectsDeleted = (N = b.projectsDeleted) !== null && N !== void 0 ? N : 0, ie.projectIdsStopped = ((_e = b.projectIdsStopped) === null || _e === void 0 ? void 0 : _e.map((Re) => Re)) || [], ie;
    }
  };
  function Pr() {
    return {};
  }
  a.GetCollectionsRequest = {
    encode(b, C = c.default.Writer.create()) {
      return C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = Pr();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {};
    },
    toJSON(b) {
      return {};
    },
    fromPartial(b) {
      return Pr();
    }
  };
  function Or() {
    return { collections: [] };
  }
  a.GetCollectionsResponse = {
    encode(b, C = c.default.Writer.create()) {
      for (const N of b.collections)
        a.Collection.encode(N, C.uint32(10).fork()).ldelim();
      return C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = Or();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.collections.push(a.Collection.decode(N, N.uint32()));
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collections: Array.isArray(b == null ? void 0 : b.collections) ? b.collections.map((C) => a.Collection.fromJSON(C)) : []
      };
    },
    toJSON(b) {
      const C = {};
      return b.collections ? C.collections = b.collections.map((N) => N ? a.Collection.toJSON(N) : void 0) : C.collections = [], C;
    },
    fromPartial(b) {
      var C;
      const N = Or();
      return N.collections = ((C = b.collections) === null || C === void 0 ? void 0 : C.map((_e) => a.Collection.fromPartial(_e))) || [], N;
    }
  };
  function Mr() {
    return {
      collectionId: "",
      metadata: void 0,
      rendering: void 0,
      encoding: void 0,
      composition: void 0,
      maxDuration: void 0,
      webrtc: void 0,
      location: void 0
    };
  }
  a.CreateProjectRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.metadata !== void 0 && p.Value.encode(p.Value.wrap(b.metadata), C.uint32(18).fork()).ldelim(), b.rendering !== void 0 && a.Rendering.encode(b.rendering, C.uint32(26).fork()).ldelim(), b.encoding !== void 0 && a.Encoding.encode(b.encoding, C.uint32(34).fork()).ldelim(), b.composition !== void 0 && a.Composition.encode(b.composition, C.uint32(42).fork()).ldelim(), b.maxDuration !== void 0 && C.uint32(48).uint32(b.maxDuration), b.webrtc !== void 0 && a.WebRtc.encode(b.webrtc, C.uint32(58).fork()).ldelim(), b.location !== void 0 && a.LatLong.encode(b.location, C.uint32(74).fork()).ldelim(), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = Mr();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.metadata = p.Value.unwrap(p.Value.decode(N, N.uint32()));
            break;
          case 3:
            ie.rendering = a.Rendering.decode(N, N.uint32());
            break;
          case 4:
            ie.encoding = a.Encoding.decode(N, N.uint32());
            break;
          case 5:
            ie.composition = a.Composition.decode(N, N.uint32());
            break;
          case 6:
            ie.maxDuration = N.uint32();
            break;
          case 7:
            ie.webrtc = a.WebRtc.decode(N, N.uint32());
            break;
          case 9:
            ie.location = a.LatLong.decode(N, N.uint32());
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        metadata: Le(b == null ? void 0 : b.metadata) ? b.metadata : void 0,
        rendering: Le(b.rendering) ? a.Rendering.fromJSON(b.rendering) : void 0,
        encoding: Le(b.encoding) ? a.Encoding.fromJSON(b.encoding) : void 0,
        composition: Le(b.composition) ? a.Composition.fromJSON(b.composition) : void 0,
        maxDuration: Le(b.maxDuration) ? Number(b.maxDuration) : void 0,
        webrtc: Le(b.webrtc) ? a.WebRtc.fromJSON(b.webrtc) : void 0,
        location: Le(b.location) ? a.LatLong.fromJSON(b.location) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.metadata !== void 0 && (C.metadata = b.metadata), b.rendering !== void 0 && (C.rendering = b.rendering ? a.Rendering.toJSON(b.rendering) : void 0), b.encoding !== void 0 && (C.encoding = b.encoding ? a.Encoding.toJSON(b.encoding) : void 0), b.composition !== void 0 && (C.composition = b.composition ? a.Composition.toJSON(b.composition) : void 0), b.maxDuration !== void 0 && (C.maxDuration = Math.round(b.maxDuration)), b.webrtc !== void 0 && (C.webrtc = b.webrtc ? a.WebRtc.toJSON(b.webrtc) : void 0), b.location !== void 0 && (C.location = b.location ? a.LatLong.toJSON(b.location) : void 0), C;
    },
    fromPartial(b) {
      var C, N, _e;
      const ie = Mr();
      return ie.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", ie.metadata = (N = b.metadata) !== null && N !== void 0 ? N : void 0, ie.rendering = b.rendering !== void 0 && b.rendering !== null ? a.Rendering.fromPartial(b.rendering) : void 0, ie.encoding = b.encoding !== void 0 && b.encoding !== null ? a.Encoding.fromPartial(b.encoding) : void 0, ie.composition = b.composition !== void 0 && b.composition !== null ? a.Composition.fromPartial(b.composition) : void 0, ie.maxDuration = (_e = b.maxDuration) !== null && _e !== void 0 ? _e : void 0, ie.webrtc = b.webrtc !== void 0 && b.webrtc !== null ? a.WebRtc.fromPartial(b.webrtc) : void 0, ie.location = b.location !== void 0 && b.location !== null ? a.LatLong.fromPartial(b.location) : void 0, ie;
    }
  };
  function Ar() {
    return { project: void 0 };
  }
  a.CreateProjectResponse = {
    encode(b, C = c.default.Writer.create()) {
      return b.project !== void 0 && a.Project.encode(b.project, C.uint32(10).fork()).ldelim(), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = Ar();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.project = a.Project.decode(N, N.uint32());
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { project: Le(b.project) ? a.Project.fromJSON(b.project) : void 0 };
    },
    toJSON(b) {
      const C = {};
      return b.project !== void 0 && (C.project = b.project ? a.Project.toJSON(b.project) : void 0), C;
    },
    fromPartial(b) {
      const C = Ar();
      return C.project = b.project !== void 0 && b.project !== null ? a.Project.fromPartial(b.project) : void 0, C;
    }
  };
  function Nr() {
    return {
      collectionId: "",
      projectId: "",
      updateMask: void 0,
      metadata: void 0,
      rendering: void 0,
      encoding: void 0,
      composition: void 0,
      maxDuration: void 0,
      webrtc: void 0,
      location: void 0
    };
  }
  a.UpdateProjectRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.projectId !== "" && C.uint32(18).string(b.projectId), b.updateMask !== void 0 && v.FieldMask.encode(v.FieldMask.wrap(b.updateMask), C.uint32(26).fork()).ldelim(), b.metadata !== void 0 && p.Value.encode(p.Value.wrap(b.metadata), C.uint32(34).fork()).ldelim(), b.rendering !== void 0 && a.Rendering.encode(b.rendering, C.uint32(42).fork()).ldelim(), b.encoding !== void 0 && a.Encoding.encode(b.encoding, C.uint32(50).fork()).ldelim(), b.composition !== void 0 && a.Composition.encode(b.composition, C.uint32(58).fork()).ldelim(), b.maxDuration !== void 0 && C.uint32(64).uint32(b.maxDuration), b.webrtc !== void 0 && a.WebRtc.encode(b.webrtc, C.uint32(74).fork()).ldelim(), b.location !== void 0 && a.LatLong.encode(b.location, C.uint32(82).fork()).ldelim(), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = Nr();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.projectId = N.string();
            break;
          case 3:
            ie.updateMask = v.FieldMask.unwrap(v.FieldMask.decode(N, N.uint32()));
            break;
          case 4:
            ie.metadata = p.Value.unwrap(p.Value.decode(N, N.uint32()));
            break;
          case 5:
            ie.rendering = a.Rendering.decode(N, N.uint32());
            break;
          case 6:
            ie.encoding = a.Encoding.decode(N, N.uint32());
            break;
          case 7:
            ie.composition = a.Composition.decode(N, N.uint32());
            break;
          case 8:
            ie.maxDuration = N.uint32();
            break;
          case 9:
            ie.webrtc = a.WebRtc.decode(N, N.uint32());
            break;
          case 10:
            ie.location = a.LatLong.decode(N, N.uint32());
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : "",
        updateMask: Le(b.updateMask) ? v.FieldMask.unwrap(v.FieldMask.fromJSON(b.updateMask)) : void 0,
        metadata: Le(b == null ? void 0 : b.metadata) ? b.metadata : void 0,
        rendering: Le(b.rendering) ? a.Rendering.fromJSON(b.rendering) : void 0,
        encoding: Le(b.encoding) ? a.Encoding.fromJSON(b.encoding) : void 0,
        composition: Le(b.composition) ? a.Composition.fromJSON(b.composition) : void 0,
        maxDuration: Le(b.maxDuration) ? Number(b.maxDuration) : void 0,
        webrtc: Le(b.webrtc) ? a.WebRtc.fromJSON(b.webrtc) : void 0,
        location: Le(b.location) ? a.LatLong.fromJSON(b.location) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.projectId !== void 0 && (C.projectId = b.projectId), b.updateMask !== void 0 && (C.updateMask = v.FieldMask.toJSON(v.FieldMask.wrap(b.updateMask))), b.metadata !== void 0 && (C.metadata = b.metadata), b.rendering !== void 0 && (C.rendering = b.rendering ? a.Rendering.toJSON(b.rendering) : void 0), b.encoding !== void 0 && (C.encoding = b.encoding ? a.Encoding.toJSON(b.encoding) : void 0), b.composition !== void 0 && (C.composition = b.composition ? a.Composition.toJSON(b.composition) : void 0), b.maxDuration !== void 0 && (C.maxDuration = Math.round(b.maxDuration)), b.webrtc !== void 0 && (C.webrtc = b.webrtc ? a.WebRtc.toJSON(b.webrtc) : void 0), b.location !== void 0 && (C.location = b.location ? a.LatLong.toJSON(b.location) : void 0), C;
    },
    fromPartial(b) {
      var C, N, _e, ie, Re;
      const gt = Nr();
      return gt.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", gt.projectId = (N = b.projectId) !== null && N !== void 0 ? N : "", gt.updateMask = (_e = b.updateMask) !== null && _e !== void 0 ? _e : void 0, gt.metadata = (ie = b.metadata) !== null && ie !== void 0 ? ie : void 0, gt.rendering = b.rendering !== void 0 && b.rendering !== null ? a.Rendering.fromPartial(b.rendering) : void 0, gt.encoding = b.encoding !== void 0 && b.encoding !== null ? a.Encoding.fromPartial(b.encoding) : void 0, gt.composition = b.composition !== void 0 && b.composition !== null ? a.Composition.fromPartial(b.composition) : void 0, gt.maxDuration = (Re = b.maxDuration) !== null && Re !== void 0 ? Re : void 0, gt.webrtc = b.webrtc !== void 0 && b.webrtc !== null ? a.WebRtc.fromPartial(b.webrtc) : void 0, gt.location = b.location !== void 0 && b.location !== null ? a.LatLong.fromPartial(b.location) : void 0, gt;
    }
  };
  function $r() {
    return { project: void 0, broadcastUpdated: !1 };
  }
  a.UpdateProjectResponse = {
    encode(b, C = c.default.Writer.create()) {
      return b.project !== void 0 && a.Project.encode(b.project, C.uint32(10).fork()).ldelim(), b.broadcastUpdated === !0 && C.uint32(16).bool(b.broadcastUpdated), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = $r();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.project = a.Project.decode(N, N.uint32());
            break;
          case 2:
            ie.broadcastUpdated = N.bool();
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        project: Le(b.project) ? a.Project.fromJSON(b.project) : void 0,
        broadcastUpdated: Le(b.broadcastUpdated) ? !!b.broadcastUpdated : !1
      };
    },
    toJSON(b) {
      const C = {};
      return b.project !== void 0 && (C.project = b.project ? a.Project.toJSON(b.project) : void 0), b.broadcastUpdated !== void 0 && (C.broadcastUpdated = b.broadcastUpdated), C;
    },
    fromPartial(b) {
      var C;
      const N = $r();
      return N.project = b.project !== void 0 && b.project !== null ? a.Project.fromPartial(b.project) : void 0, N.broadcastUpdated = (C = b.broadcastUpdated) !== null && C !== void 0 ? C : !1, N;
    }
  };
  function Dr() {
    return { collectionId: "", projectId: "", force: void 0 };
  }
  a.DeleteProjectRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.projectId !== "" && C.uint32(18).string(b.projectId), b.force !== void 0 && C.uint32(24).bool(b.force), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = Dr();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.projectId = N.string();
            break;
          case 3:
            ie.force = N.bool();
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : "",
        force: Le(b.force) ? !!b.force : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.projectId !== void 0 && (C.projectId = b.projectId), b.force !== void 0 && (C.force = b.force), C;
    },
    fromPartial(b) {
      var C, N, _e;
      const ie = Dr();
      return ie.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", ie.projectId = (N = b.projectId) !== null && N !== void 0 ? N : "", ie.force = (_e = b.force) !== null && _e !== void 0 ? _e : void 0, ie;
    }
  };
  function Lr() {
    return { broadcastStopped: !1, layoutsDeleted: 0 };
  }
  a.DeleteProjectResponse = {
    encode(b, C = c.default.Writer.create()) {
      return b.broadcastStopped === !0 && C.uint32(8).bool(b.broadcastStopped), b.layoutsDeleted !== 0 && C.uint32(16).uint32(b.layoutsDeleted), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = Lr();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.broadcastStopped = N.bool();
            break;
          case 2:
            ie.layoutsDeleted = N.uint32();
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        broadcastStopped: Le(b.broadcastStopped) ? !!b.broadcastStopped : !1,
        layoutsDeleted: Le(b.layoutsDeleted) ? Number(b.layoutsDeleted) : 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.broadcastStopped !== void 0 && (C.broadcastStopped = b.broadcastStopped), b.layoutsDeleted !== void 0 && (C.layoutsDeleted = Math.round(b.layoutsDeleted)), C;
    },
    fromPartial(b) {
      var C, N;
      const _e = Lr();
      return _e.broadcastStopped = (C = b.broadcastStopped) !== null && C !== void 0 ? C : !1, _e.layoutsDeleted = (N = b.layoutsDeleted) !== null && N !== void 0 ? N : 0, _e;
    }
  };
  function Br() {
    return {
      collectionId: "",
      projectId: "",
      webrtcStart: void 0,
      async: void 0,
      dynamicSources: {},
      triggerMetadata: void 0
    };
  }
  a.StartProjectBroadcastRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.projectId !== "" && C.uint32(18).string(b.projectId), b.webrtcStart !== void 0 && C.uint32(24).bool(b.webrtcStart), b.async !== void 0 && C.uint32(32).bool(b.async), Object.entries(b.dynamicSources).forEach(([N, _e]) => {
        a.StartProjectBroadcastRequest_DynamicSourcesEntry.encode({ key: N, value: _e }, C.uint32(42).fork()).ldelim();
      }), b.triggerMetadata !== void 0 && p.Value.encode(p.Value.wrap(b.triggerMetadata), C.uint32(58).fork()).ldelim(), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = Br();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.projectId = N.string();
            break;
          case 3:
            ie.webrtcStart = N.bool();
            break;
          case 4:
            ie.async = N.bool();
            break;
          case 5:
            const gt = a.StartProjectBroadcastRequest_DynamicSourcesEntry.decode(N, N.uint32());
            gt.value !== void 0 && (ie.dynamicSources[gt.key] = gt.value);
            break;
          case 7:
            ie.triggerMetadata = p.Value.unwrap(p.Value.decode(N, N.uint32()));
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : "",
        webrtcStart: Le(b.webrtcStart) ? !!b.webrtcStart : void 0,
        async: Le(b.async) ? !!b.async : void 0,
        dynamicSources: Ii(b.dynamicSources) ? Object.entries(b.dynamicSources).reduce((C, [N, _e]) => (C[N] = a.RuntimeSourceAddress.fromJSON(_e), C), {}) : {},
        triggerMetadata: Le(b == null ? void 0 : b.triggerMetadata) ? b.triggerMetadata : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.projectId !== void 0 && (C.projectId = b.projectId), b.webrtcStart !== void 0 && (C.webrtcStart = b.webrtcStart), b.async !== void 0 && (C.async = b.async), C.dynamicSources = {}, b.dynamicSources && Object.entries(b.dynamicSources).forEach(([N, _e]) => {
        C.dynamicSources[N] = a.RuntimeSourceAddress.toJSON(_e);
      }), b.triggerMetadata !== void 0 && (C.triggerMetadata = b.triggerMetadata), C;
    },
    fromPartial(b) {
      var C, N, _e, ie, Re, gt;
      const Ct = Br();
      return Ct.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", Ct.projectId = (N = b.projectId) !== null && N !== void 0 ? N : "", Ct.webrtcStart = (_e = b.webrtcStart) !== null && _e !== void 0 ? _e : void 0, Ct.async = (ie = b.async) !== null && ie !== void 0 ? ie : void 0, Ct.dynamicSources = Object.entries((Re = b.dynamicSources) !== null && Re !== void 0 ? Re : {}).reduce((Dt, [Lt, qt]) => (qt !== void 0 && (Dt[Lt] = a.RuntimeSourceAddress.fromPartial(qt)), Dt), {}), Ct.triggerMetadata = (gt = b.triggerMetadata) !== null && gt !== void 0 ? gt : void 0, Ct;
    }
  };
  function Ur() {
    return { key: "", value: void 0 };
  }
  a.StartProjectBroadcastRequest_DynamicSourcesEntry = {
    encode(b, C = c.default.Writer.create()) {
      return b.key !== "" && C.uint32(10).string(b.key), b.value !== void 0 && a.RuntimeSourceAddress.encode(b.value, C.uint32(18).fork()).ldelim(), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = Ur();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.key = N.string();
            break;
          case 2:
            ie.value = a.RuntimeSourceAddress.decode(N, N.uint32());
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        key: Le(b.key) ? String(b.key) : "",
        value: Le(b.value) ? a.RuntimeSourceAddress.fromJSON(b.value) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.key !== void 0 && (C.key = b.key), b.value !== void 0 && (C.value = b.value ? a.RuntimeSourceAddress.toJSON(b.value) : void 0), C;
    },
    fromPartial(b) {
      var C;
      const N = Ur();
      return N.key = (C = b.key) !== null && C !== void 0 ? C : "", N.value = b.value !== void 0 && b.value !== null ? a.RuntimeSourceAddress.fromPartial(b.value) : void 0, N;
    }
  };
  function xr() {
    return { broadcastId: "" };
  }
  a.StartProjectBroadcastResponse = {
    encode(b, C = c.default.Writer.create()) {
      return b.broadcastId !== "" && C.uint32(10).string(b.broadcastId), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = xr();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.broadcastId = N.string();
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { broadcastId: Le(b.broadcastId) ? String(b.broadcastId) : "" };
    },
    toJSON(b) {
      const C = {};
      return b.broadcastId !== void 0 && (C.broadcastId = b.broadcastId), C;
    },
    fromPartial(b) {
      var C;
      const N = xr();
      return N.broadcastId = (C = b.broadcastId) !== null && C !== void 0 ? C : "", N;
    }
  };
  function Fr() {
    return { collectionId: "", projectId: "", webrtcStop: void 0 };
  }
  a.StopProjectBroadcastRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.projectId !== "" && C.uint32(18).string(b.projectId), b.webrtcStop !== void 0 && C.uint32(24).bool(b.webrtcStop), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = Fr();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.projectId = N.string();
            break;
          case 3:
            ie.webrtcStop = N.bool();
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : "",
        webrtcStop: Le(b.webrtcStop) ? !!b.webrtcStop : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.projectId !== void 0 && (C.projectId = b.projectId), b.webrtcStop !== void 0 && (C.webrtcStop = b.webrtcStop), C;
    },
    fromPartial(b) {
      var C, N, _e;
      const ie = Fr();
      return ie.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", ie.projectId = (N = b.projectId) !== null && N !== void 0 ? N : "", ie.webrtcStop = (_e = b.webrtcStop) !== null && _e !== void 0 ? _e : void 0, ie;
    }
  };
  function qr() {
    return {};
  }
  a.StopProjectBroadcastResponse = {
    encode(b, C = c.default.Writer.create()) {
      return C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = qr();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {};
    },
    toJSON(b) {
      return {};
    },
    fromPartial(b) {
      return qr();
    }
  };
  function Vr() {
    return { collectionId: "", projectId: "", status: void 0 };
  }
  a.GetProjectRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.projectId !== "" && C.uint32(18).string(b.projectId), b.status !== void 0 && C.uint32(24).bool(b.status), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = Vr();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.projectId = N.string();
            break;
          case 3:
            ie.status = N.bool();
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : "",
        status: Le(b.status) ? !!b.status : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.projectId !== void 0 && (C.projectId = b.projectId), b.status !== void 0 && (C.status = b.status), C;
    },
    fromPartial(b) {
      var C, N, _e;
      const ie = Vr();
      return ie.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", ie.projectId = (N = b.projectId) !== null && N !== void 0 ? N : "", ie.status = (_e = b.status) !== null && _e !== void 0 ? _e : void 0, ie;
    }
  };
  function Jr() {
    return { project: void 0, status: void 0 };
  }
  a.GetProjectResponse = {
    encode(b, C = c.default.Writer.create()) {
      return b.project !== void 0 && a.Project.encode(b.project, C.uint32(10).fork()).ldelim(), b.status !== void 0 && a.ProjectBroadcastStatus.encode(b.status, C.uint32(18).fork()).ldelim(), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = Jr();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.project = a.Project.decode(N, N.uint32());
            break;
          case 2:
            ie.status = a.ProjectBroadcastStatus.decode(N, N.uint32());
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        project: Le(b.project) ? a.Project.fromJSON(b.project) : void 0,
        status: Le(b.status) ? a.ProjectBroadcastStatus.fromJSON(b.status) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.project !== void 0 && (C.project = b.project ? a.Project.toJSON(b.project) : void 0), b.status !== void 0 && (C.status = b.status ? a.ProjectBroadcastStatus.toJSON(b.status) : void 0), C;
    },
    fromPartial(b) {
      const C = Jr();
      return C.project = b.project !== void 0 && b.project !== null ? a.Project.fromPartial(b.project) : void 0, C.status = b.status !== void 0 && b.status !== null ? a.ProjectBroadcastStatus.fromPartial(b.status) : void 0, C;
    }
  };
  function Gr() {
    return { collectionId: "", projectId: "", format: void 0 };
  }
  a.GetProjectBroadcastSnapshotRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.projectId !== "" && C.uint32(18).string(b.projectId), b.format !== void 0 && C.uint32(24).int32(be(b.format)), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = Gr();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.projectId = N.string();
            break;
          case 3:
            ie.format = he(N.int32());
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : "",
        format: Le(b.format) ? he(b.format) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.projectId !== void 0 && (C.projectId = b.projectId), b.format !== void 0 && (C.format = b.format !== void 0 ? fe(b.format) : void 0), C;
    },
    fromPartial(b) {
      var C, N, _e;
      const ie = Gr();
      return ie.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", ie.projectId = (N = b.projectId) !== null && N !== void 0 ? N : "", ie.format = (_e = b.format) !== null && _e !== void 0 ? _e : void 0, ie;
    }
  };
  function Wr() {
    return { format: ue.IMAGE_FORMAT_UNSPECIFIED, image: new Uint8Array() };
  }
  a.GetProjectBroadcastSnapshotResponse = {
    encode(b, C = c.default.Writer.create()) {
      return b.format !== ue.IMAGE_FORMAT_UNSPECIFIED && C.uint32(8).int32(be(b.format)), b.image.length !== 0 && C.uint32(18).bytes(b.image), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = Wr();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.format = he(N.int32());
            break;
          case 2:
            ie.image = N.bytes();
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        format: Le(b.format) ? he(b.format) : ue.IMAGE_FORMAT_UNSPECIFIED,
        image: Le(b.image) ? wi(b.image) : new Uint8Array()
      };
    },
    toJSON(b) {
      const C = {};
      return b.format !== void 0 && (C.format = fe(b.format)), b.image !== void 0 && (C.image = ki(b.image !== void 0 ? b.image : new Uint8Array())), C;
    },
    fromPartial(b) {
      var C, N;
      const _e = Wr();
      return _e.format = (C = b.format) !== null && C !== void 0 ? C : ue.IMAGE_FORMAT_UNSPECIFIED, _e.image = (N = b.image) !== null && N !== void 0 ? N : new Uint8Array(), _e;
    }
  };
  function Hr() {
    return { collectionId: "", projectId: "" };
  }
  a.GetProjectBroadcastStatusRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.projectId !== "" && C.uint32(18).string(b.projectId), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = Hr();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.projectId = N.string();
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : ""
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.projectId !== void 0 && (C.projectId = b.projectId), C;
    },
    fromPartial(b) {
      var C, N;
      const _e = Hr();
      return _e.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", _e.projectId = (N = b.projectId) !== null && N !== void 0 ? N : "", _e;
    }
  };
  function Kr() {
    return { status: void 0 };
  }
  a.GetProjectBroadcastStatusResponse = {
    encode(b, C = c.default.Writer.create()) {
      return b.status !== void 0 && a.ProjectBroadcastStatus.encode(b.status, C.uint32(10).fork()).ldelim(), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = Kr();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.status = a.ProjectBroadcastStatus.decode(N, N.uint32());
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { status: Le(b.status) ? a.ProjectBroadcastStatus.fromJSON(b.status) : void 0 };
    },
    toJSON(b) {
      const C = {};
      return b.status !== void 0 && (C.status = b.status ? a.ProjectBroadcastStatus.toJSON(b.status) : void 0), C;
    },
    fromPartial(b) {
      const C = Kr();
      return C.status = b.status !== void 0 && b.status !== null ? a.ProjectBroadcastStatus.fromPartial(b.status) : void 0, C;
    }
  };
  function Yr() {
    return { collectionId: "", projectId: "" };
  }
  a.StartProjectWebRtcRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.projectId !== "" && C.uint32(18).string(b.projectId), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = Yr();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.projectId = N.string();
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : ""
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.projectId !== void 0 && (C.projectId = b.projectId), C;
    },
    fromPartial(b) {
      var C, N;
      const _e = Yr();
      return _e.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", _e.projectId = (N = b.projectId) !== null && N !== void 0 ? N : "", _e;
    }
  };
  function Zr() {
    return {};
  }
  a.StartProjectWebRtcResponse = {
    encode(b, C = c.default.Writer.create()) {
      return C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = Zr();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {};
    },
    toJSON(b) {
      return {};
    },
    fromPartial(b) {
      return Zr();
    }
  };
  function jr() {
    return { collectionId: "", projectId: "" };
  }
  a.StopProjectWebRtcRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.projectId !== "" && C.uint32(18).string(b.projectId), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = jr();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.projectId = N.string();
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : ""
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.projectId !== void 0 && (C.projectId = b.projectId), C;
    },
    fromPartial(b) {
      var C, N;
      const _e = jr();
      return _e.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", _e.projectId = (N = b.projectId) !== null && N !== void 0 ? N : "", _e;
    }
  };
  function Xr() {
    return {};
  }
  a.StopProjectWebRtcResponse = {
    encode(b, C = c.default.Writer.create()) {
      return C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = Xr();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {};
    },
    toJSON(b) {
      return {};
    },
    fromPartial(b) {
      return Xr();
    }
  };
  function Qr() {
    return {
      collectionId: "",
      projectId: "",
      metadata: void 0,
      address: void 0,
      enabled: void 0,
      timeout: void 0
    };
  }
  a.CreateDestinationRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.projectId !== "" && C.uint32(18).string(b.projectId), b.metadata !== void 0 && p.Value.encode(p.Value.wrap(b.metadata), C.uint32(26).fork()).ldelim(), b.address !== void 0 && a.DestinationAddress.encode(b.address, C.uint32(42).fork()).ldelim(), b.enabled !== void 0 && C.uint32(48).bool(b.enabled), b.timeout !== void 0 && C.uint32(56).uint32(b.timeout), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = Qr();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.projectId = N.string();
            break;
          case 3:
            ie.metadata = p.Value.unwrap(p.Value.decode(N, N.uint32()));
            break;
          case 5:
            ie.address = a.DestinationAddress.decode(N, N.uint32());
            break;
          case 6:
            ie.enabled = N.bool();
            break;
          case 7:
            ie.timeout = N.uint32();
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : "",
        metadata: Le(b == null ? void 0 : b.metadata) ? b.metadata : void 0,
        address: Le(b.address) ? a.DestinationAddress.fromJSON(b.address) : void 0,
        enabled: Le(b.enabled) ? !!b.enabled : void 0,
        timeout: Le(b.timeout) ? Number(b.timeout) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.projectId !== void 0 && (C.projectId = b.projectId), b.metadata !== void 0 && (C.metadata = b.metadata), b.address !== void 0 && (C.address = b.address ? a.DestinationAddress.toJSON(b.address) : void 0), b.enabled !== void 0 && (C.enabled = b.enabled), b.timeout !== void 0 && (C.timeout = Math.round(b.timeout)), C;
    },
    fromPartial(b) {
      var C, N, _e, ie, Re;
      const gt = Qr();
      return gt.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", gt.projectId = (N = b.projectId) !== null && N !== void 0 ? N : "", gt.metadata = (_e = b.metadata) !== null && _e !== void 0 ? _e : void 0, gt.address = b.address !== void 0 && b.address !== null ? a.DestinationAddress.fromPartial(b.address) : void 0, gt.enabled = (ie = b.enabled) !== null && ie !== void 0 ? ie : void 0, gt.timeout = (Re = b.timeout) !== null && Re !== void 0 ? Re : void 0, gt;
    }
  };
  function en() {
    return { destination: void 0 };
  }
  a.CreateDestinationResponse = {
    encode(b, C = c.default.Writer.create()) {
      return b.destination !== void 0 && a.Destination.encode(b.destination, C.uint32(10).fork()).ldelim(), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = en();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.destination = a.Destination.decode(N, N.uint32());
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { destination: Le(b.destination) ? a.Destination.fromJSON(b.destination) : void 0 };
    },
    toJSON(b) {
      const C = {};
      return b.destination !== void 0 && (C.destination = b.destination ? a.Destination.toJSON(b.destination) : void 0), C;
    },
    fromPartial(b) {
      const C = en();
      return C.destination = b.destination !== void 0 && b.destination !== null ? a.Destination.fromPartial(b.destination) : void 0, C;
    }
  };
  function tn() {
    return { collectionId: "", projectId: "", destinationId: "" };
  }
  a.GetDestinationRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.projectId !== "" && C.uint32(18).string(b.projectId), b.destinationId !== "" && C.uint32(26).string(b.destinationId), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = tn();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.projectId = N.string();
            break;
          case 3:
            ie.destinationId = N.string();
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : "",
        destinationId: Le(b.destinationId) ? String(b.destinationId) : ""
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.projectId !== void 0 && (C.projectId = b.projectId), b.destinationId !== void 0 && (C.destinationId = b.destinationId), C;
    },
    fromPartial(b) {
      var C, N, _e;
      const ie = tn();
      return ie.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", ie.projectId = (N = b.projectId) !== null && N !== void 0 ? N : "", ie.destinationId = (_e = b.destinationId) !== null && _e !== void 0 ? _e : "", ie;
    }
  };
  function rn() {
    return { destination: void 0 };
  }
  a.GetDestinationResponse = {
    encode(b, C = c.default.Writer.create()) {
      return b.destination !== void 0 && a.Destination.encode(b.destination, C.uint32(10).fork()).ldelim(), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = rn();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.destination = a.Destination.decode(N, N.uint32());
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { destination: Le(b.destination) ? a.Destination.fromJSON(b.destination) : void 0 };
    },
    toJSON(b) {
      const C = {};
      return b.destination !== void 0 && (C.destination = b.destination ? a.Destination.toJSON(b.destination) : void 0), C;
    },
    fromPartial(b) {
      const C = rn();
      return C.destination = b.destination !== void 0 && b.destination !== null ? a.Destination.fromPartial(b.destination) : void 0, C;
    }
  };
  function nn() {
    return { collectionId: "", projectId: "", destinationId: "", force: void 0 };
  }
  a.DeleteDestinationRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.projectId !== "" && C.uint32(18).string(b.projectId), b.destinationId !== "" && C.uint32(26).string(b.destinationId), b.force !== void 0 && C.uint32(32).bool(b.force), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = nn();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.projectId = N.string();
            break;
          case 3:
            ie.destinationId = N.string();
            break;
          case 4:
            ie.force = N.bool();
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : "",
        destinationId: Le(b.destinationId) ? String(b.destinationId) : "",
        force: Le(b.force) ? !!b.force : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.projectId !== void 0 && (C.projectId = b.projectId), b.destinationId !== void 0 && (C.destinationId = b.destinationId), b.force !== void 0 && (C.force = b.force), C;
    },
    fromPartial(b) {
      var C, N, _e, ie;
      const Re = nn();
      return Re.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", Re.projectId = (N = b.projectId) !== null && N !== void 0 ? N : "", Re.destinationId = (_e = b.destinationId) !== null && _e !== void 0 ? _e : "", Re.force = (ie = b.force) !== null && ie !== void 0 ? ie : void 0, Re;
    }
  };
  function an() {
    return { broadcastUpdated: !1 };
  }
  a.DeleteDestinationResponse = {
    encode(b, C = c.default.Writer.create()) {
      return b.broadcastUpdated === !0 && C.uint32(8).bool(b.broadcastUpdated), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = an();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.broadcastUpdated = N.bool();
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { broadcastUpdated: Le(b.broadcastUpdated) ? !!b.broadcastUpdated : !1 };
    },
    toJSON(b) {
      const C = {};
      return b.broadcastUpdated !== void 0 && (C.broadcastUpdated = b.broadcastUpdated), C;
    },
    fromPartial(b) {
      var C;
      const N = an();
      return N.broadcastUpdated = (C = b.broadcastUpdated) !== null && C !== void 0 ? C : !1, N;
    }
  };
  function sn() {
    return {
      collectionId: "",
      projectId: "",
      destinationId: "",
      updateMask: void 0,
      metadata: void 0,
      address: void 0,
      enabled: void 0,
      timeout: void 0
    };
  }
  a.UpdateDestinationRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.projectId !== "" && C.uint32(18).string(b.projectId), b.destinationId !== "" && C.uint32(26).string(b.destinationId), b.updateMask !== void 0 && v.FieldMask.encode(v.FieldMask.wrap(b.updateMask), C.uint32(34).fork()).ldelim(), b.metadata !== void 0 && p.Value.encode(p.Value.wrap(b.metadata), C.uint32(42).fork()).ldelim(), b.address !== void 0 && a.DestinationAddress.encode(b.address, C.uint32(50).fork()).ldelim(), b.enabled !== void 0 && C.uint32(56).bool(b.enabled), b.timeout !== void 0 && C.uint32(64).uint32(b.timeout), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = sn();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.projectId = N.string();
            break;
          case 3:
            ie.destinationId = N.string();
            break;
          case 4:
            ie.updateMask = v.FieldMask.unwrap(v.FieldMask.decode(N, N.uint32()));
            break;
          case 5:
            ie.metadata = p.Value.unwrap(p.Value.decode(N, N.uint32()));
            break;
          case 6:
            ie.address = a.DestinationAddress.decode(N, N.uint32());
            break;
          case 7:
            ie.enabled = N.bool();
            break;
          case 8:
            ie.timeout = N.uint32();
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : "",
        destinationId: Le(b.destinationId) ? String(b.destinationId) : "",
        updateMask: Le(b.updateMask) ? v.FieldMask.unwrap(v.FieldMask.fromJSON(b.updateMask)) : void 0,
        metadata: Le(b == null ? void 0 : b.metadata) ? b.metadata : void 0,
        address: Le(b.address) ? a.DestinationAddress.fromJSON(b.address) : void 0,
        enabled: Le(b.enabled) ? !!b.enabled : void 0,
        timeout: Le(b.timeout) ? Number(b.timeout) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.projectId !== void 0 && (C.projectId = b.projectId), b.destinationId !== void 0 && (C.destinationId = b.destinationId), b.updateMask !== void 0 && (C.updateMask = v.FieldMask.toJSON(v.FieldMask.wrap(b.updateMask))), b.metadata !== void 0 && (C.metadata = b.metadata), b.address !== void 0 && (C.address = b.address ? a.DestinationAddress.toJSON(b.address) : void 0), b.enabled !== void 0 && (C.enabled = b.enabled), b.timeout !== void 0 && (C.timeout = Math.round(b.timeout)), C;
    },
    fromPartial(b) {
      var C, N, _e, ie, Re, gt, Ct;
      const Dt = sn();
      return Dt.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", Dt.projectId = (N = b.projectId) !== null && N !== void 0 ? N : "", Dt.destinationId = (_e = b.destinationId) !== null && _e !== void 0 ? _e : "", Dt.updateMask = (ie = b.updateMask) !== null && ie !== void 0 ? ie : void 0, Dt.metadata = (Re = b.metadata) !== null && Re !== void 0 ? Re : void 0, Dt.address = b.address !== void 0 && b.address !== null ? a.DestinationAddress.fromPartial(b.address) : void 0, Dt.enabled = (gt = b.enabled) !== null && gt !== void 0 ? gt : void 0, Dt.timeout = (Ct = b.timeout) !== null && Ct !== void 0 ? Ct : void 0, Dt;
    }
  };
  function dn() {
    return { destination: void 0, broadcastUpdated: !1 };
  }
  a.UpdateDestinationResponse = {
    encode(b, C = c.default.Writer.create()) {
      return b.destination !== void 0 && a.Destination.encode(b.destination, C.uint32(10).fork()).ldelim(), b.broadcastUpdated === !0 && C.uint32(16).bool(b.broadcastUpdated), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = dn();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.destination = a.Destination.decode(N, N.uint32());
            break;
          case 2:
            ie.broadcastUpdated = N.bool();
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        destination: Le(b.destination) ? a.Destination.fromJSON(b.destination) : void 0,
        broadcastUpdated: Le(b.broadcastUpdated) ? !!b.broadcastUpdated : !1
      };
    },
    toJSON(b) {
      const C = {};
      return b.destination !== void 0 && (C.destination = b.destination ? a.Destination.toJSON(b.destination) : void 0), b.broadcastUpdated !== void 0 && (C.broadcastUpdated = b.broadcastUpdated), C;
    },
    fromPartial(b) {
      var C;
      const N = dn();
      return N.destination = b.destination !== void 0 && b.destination !== null ? a.Destination.fromPartial(b.destination) : void 0, N.broadcastUpdated = (C = b.broadcastUpdated) !== null && C !== void 0 ? C : !1, N;
    }
  };
  function un() {
    return { collectionId: "", metadata: void 0, address: void 0, preview: void 0 };
  }
  a.CreateSourceRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.metadata !== void 0 && p.Value.encode(p.Value.wrap(b.metadata), C.uint32(18).fork()).ldelim(), b.address !== void 0 && a.SourceAddress.encode(b.address, C.uint32(26).fork()).ldelim(), b.preview !== void 0 && a.PreviewAddress.encode(b.preview, C.uint32(34).fork()).ldelim(), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = un();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.metadata = p.Value.unwrap(p.Value.decode(N, N.uint32()));
            break;
          case 3:
            ie.address = a.SourceAddress.decode(N, N.uint32());
            break;
          case 4:
            ie.preview = a.PreviewAddress.decode(N, N.uint32());
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        metadata: Le(b == null ? void 0 : b.metadata) ? b.metadata : void 0,
        address: Le(b.address) ? a.SourceAddress.fromJSON(b.address) : void 0,
        preview: Le(b.preview) ? a.PreviewAddress.fromJSON(b.preview) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.metadata !== void 0 && (C.metadata = b.metadata), b.address !== void 0 && (C.address = b.address ? a.SourceAddress.toJSON(b.address) : void 0), b.preview !== void 0 && (C.preview = b.preview ? a.PreviewAddress.toJSON(b.preview) : void 0), C;
    },
    fromPartial(b) {
      var C, N;
      const _e = un();
      return _e.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", _e.metadata = (N = b.metadata) !== null && N !== void 0 ? N : void 0, _e.address = b.address !== void 0 && b.address !== null ? a.SourceAddress.fromPartial(b.address) : void 0, _e.preview = b.preview !== void 0 && b.preview !== null ? a.PreviewAddress.fromPartial(b.preview) : void 0, _e;
    }
  };
  function cn() {
    return { source: void 0 };
  }
  a.CreateSourceResponse = {
    encode(b, C = c.default.Writer.create()) {
      return b.source !== void 0 && a.Source.encode(b.source, C.uint32(10).fork()).ldelim(), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = cn();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.source = a.Source.decode(N, N.uint32());
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { source: Le(b.source) ? a.Source.fromJSON(b.source) : void 0 };
    },
    toJSON(b) {
      const C = {};
      return b.source !== void 0 && (C.source = b.source ? a.Source.toJSON(b.source) : void 0), C;
    },
    fromPartial(b) {
      const C = cn();
      return C.source = b.source !== void 0 && b.source !== null ? a.Source.fromPartial(b.source) : void 0, C;
    }
  };
  function ln() {
    return { collectionId: "", sourceId: "", force: void 0 };
  }
  a.DeleteSourceRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.sourceId !== "" && C.uint32(18).string(b.sourceId), b.force !== void 0 && C.uint32(24).bool(b.force), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = ln();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.sourceId = N.string();
            break;
          case 3:
            ie.force = N.bool();
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        sourceId: Le(b.sourceId) ? String(b.sourceId) : "",
        force: Le(b.force) ? !!b.force : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.sourceId !== void 0 && (C.sourceId = b.sourceId), b.force !== void 0 && (C.force = b.force), C;
    },
    fromPartial(b) {
      var C, N, _e;
      const ie = ln();
      return ie.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", ie.sourceId = (N = b.sourceId) !== null && N !== void 0 ? N : "", ie.force = (_e = b.force) !== null && _e !== void 0 ? _e : void 0, ie;
    }
  };
  function fn() {
    return { projectIdsUpdated: [] };
  }
  a.DeleteSourceResponse = {
    encode(b, C = c.default.Writer.create()) {
      for (const N of b.projectIdsUpdated)
        C.uint32(26).string(N);
      return C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = fn();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 3:
            ie.projectIdsUpdated.push(N.string());
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        projectIdsUpdated: Array.isArray(b == null ? void 0 : b.projectIdsUpdated) ? b.projectIdsUpdated.map((C) => String(C)) : []
      };
    },
    toJSON(b) {
      const C = {};
      return b.projectIdsUpdated ? C.projectIdsUpdated = b.projectIdsUpdated.map((N) => N) : C.projectIdsUpdated = [], C;
    },
    fromPartial(b) {
      var C;
      const N = fn();
      return N.projectIdsUpdated = ((C = b.projectIdsUpdated) === null || C === void 0 ? void 0 : C.map((_e) => _e)) || [], N;
    }
  };
  function hn() {
    return { collectionId: "", projectId: "", sourceId: "", trigger: void 0 };
  }
  a.AddSourceToProjectRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.projectId !== "" && C.uint32(18).string(b.projectId), b.sourceId !== "" && C.uint32(26).string(b.sourceId), b.trigger !== void 0 && a.SourceTrigger.encode(b.trigger, C.uint32(34).fork()).ldelim(), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = hn();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.projectId = N.string();
            break;
          case 3:
            ie.sourceId = N.string();
            break;
          case 4:
            ie.trigger = a.SourceTrigger.decode(N, N.uint32());
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : "",
        sourceId: Le(b.sourceId) ? String(b.sourceId) : "",
        trigger: Le(b.trigger) ? a.SourceTrigger.fromJSON(b.trigger) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.projectId !== void 0 && (C.projectId = b.projectId), b.sourceId !== void 0 && (C.sourceId = b.sourceId), b.trigger !== void 0 && (C.trigger = b.trigger ? a.SourceTrigger.toJSON(b.trigger) : void 0), C;
    },
    fromPartial(b) {
      var C, N, _e;
      const ie = hn();
      return ie.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", ie.projectId = (N = b.projectId) !== null && N !== void 0 ? N : "", ie.sourceId = (_e = b.sourceId) !== null && _e !== void 0 ? _e : "", ie.trigger = b.trigger !== void 0 && b.trigger !== null ? a.SourceTrigger.fromPartial(b.trigger) : void 0, ie;
    }
  };
  function pn() {
    return { project: void 0, broadcastUpdated: !1 };
  }
  a.AddSourceToProjectResponse = {
    encode(b, C = c.default.Writer.create()) {
      return b.project !== void 0 && a.Project.encode(b.project, C.uint32(10).fork()).ldelim(), b.broadcastUpdated === !0 && C.uint32(16).bool(b.broadcastUpdated), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = pn();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.project = a.Project.decode(N, N.uint32());
            break;
          case 2:
            ie.broadcastUpdated = N.bool();
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        project: Le(b.project) ? a.Project.fromJSON(b.project) : void 0,
        broadcastUpdated: Le(b.broadcastUpdated) ? !!b.broadcastUpdated : !1
      };
    },
    toJSON(b) {
      const C = {};
      return b.project !== void 0 && (C.project = b.project ? a.Project.toJSON(b.project) : void 0), b.broadcastUpdated !== void 0 && (C.broadcastUpdated = b.broadcastUpdated), C;
    },
    fromPartial(b) {
      var C;
      const N = pn();
      return N.project = b.project !== void 0 && b.project !== null ? a.Project.fromPartial(b.project) : void 0, N.broadcastUpdated = (C = b.broadcastUpdated) !== null && C !== void 0 ? C : !1, N;
    }
  };
  function mn() {
    return { collectionId: "", projectId: "", sourceId: "", updateMask: void 0, trigger: void 0 };
  }
  a.UpdateSourceInProjectRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.projectId !== "" && C.uint32(18).string(b.projectId), b.sourceId !== "" && C.uint32(26).string(b.sourceId), b.updateMask !== void 0 && v.FieldMask.encode(v.FieldMask.wrap(b.updateMask), C.uint32(34).fork()).ldelim(), b.trigger !== void 0 && a.SourceTrigger.encode(b.trigger, C.uint32(42).fork()).ldelim(), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = mn();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.projectId = N.string();
            break;
          case 3:
            ie.sourceId = N.string();
            break;
          case 4:
            ie.updateMask = v.FieldMask.unwrap(v.FieldMask.decode(N, N.uint32()));
            break;
          case 5:
            ie.trigger = a.SourceTrigger.decode(N, N.uint32());
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : "",
        sourceId: Le(b.sourceId) ? String(b.sourceId) : "",
        updateMask: Le(b.updateMask) ? v.FieldMask.unwrap(v.FieldMask.fromJSON(b.updateMask)) : void 0,
        trigger: Le(b.trigger) ? a.SourceTrigger.fromJSON(b.trigger) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.projectId !== void 0 && (C.projectId = b.projectId), b.sourceId !== void 0 && (C.sourceId = b.sourceId), b.updateMask !== void 0 && (C.updateMask = v.FieldMask.toJSON(v.FieldMask.wrap(b.updateMask))), b.trigger !== void 0 && (C.trigger = b.trigger ? a.SourceTrigger.toJSON(b.trigger) : void 0), C;
    },
    fromPartial(b) {
      var C, N, _e, ie;
      const Re = mn();
      return Re.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", Re.projectId = (N = b.projectId) !== null && N !== void 0 ? N : "", Re.sourceId = (_e = b.sourceId) !== null && _e !== void 0 ? _e : "", Re.updateMask = (ie = b.updateMask) !== null && ie !== void 0 ? ie : void 0, Re.trigger = b.trigger !== void 0 && b.trigger !== null ? a.SourceTrigger.fromPartial(b.trigger) : void 0, Re;
    }
  };
  function vn() {
    return { project: void 0 };
  }
  a.UpdateSourceInProjectResponse = {
    encode(b, C = c.default.Writer.create()) {
      return b.project !== void 0 && a.Project.encode(b.project, C.uint32(10).fork()).ldelim(), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = vn();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.project = a.Project.decode(N, N.uint32());
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { project: Le(b.project) ? a.Project.fromJSON(b.project) : void 0 };
    },
    toJSON(b) {
      const C = {};
      return b.project !== void 0 && (C.project = b.project ? a.Project.toJSON(b.project) : void 0), C;
    },
    fromPartial(b) {
      const C = vn();
      return C.project = b.project !== void 0 && b.project !== null ? a.Project.fromPartial(b.project) : void 0, C;
    }
  };
  function yn() {
    return { collectionId: "", sourceId: "" };
  }
  a.GetSourceRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.sourceId !== "" && C.uint32(26).string(b.sourceId), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = yn();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 3:
            ie.sourceId = N.string();
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        sourceId: Le(b.sourceId) ? String(b.sourceId) : ""
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.sourceId !== void 0 && (C.sourceId = b.sourceId), C;
    },
    fromPartial(b) {
      var C, N;
      const _e = yn();
      return _e.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", _e.sourceId = (N = b.sourceId) !== null && N !== void 0 ? N : "", _e;
    }
  };
  function gn() {
    return { source: void 0 };
  }
  a.GetSourceResponse = {
    encode(b, C = c.default.Writer.create()) {
      return b.source !== void 0 && a.Source.encode(b.source, C.uint32(10).fork()).ldelim(), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = gn();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.source = a.Source.decode(N, N.uint32());
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { source: Le(b.source) ? a.Source.fromJSON(b.source) : void 0 };
    },
    toJSON(b) {
      const C = {};
      return b.source !== void 0 && (C.source = b.source ? a.Source.toJSON(b.source) : void 0), C;
    },
    fromPartial(b) {
      const C = gn();
      return C.source = b.source !== void 0 && b.source !== null ? a.Source.fromPartial(b.source) : void 0, C;
    }
  };
  function Sn() {
    return { collectionId: "" };
  }
  a.GetSourcesRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = Sn();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { collectionId: Le(b.collectionId) ? String(b.collectionId) : "" };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), C;
    },
    fromPartial(b) {
      var C;
      const N = Sn();
      return N.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", N;
    }
  };
  function _n() {
    return { sources: [] };
  }
  a.GetSourcesResponse = {
    encode(b, C = c.default.Writer.create()) {
      for (const N of b.sources)
        a.Source.encode(N, C.uint32(10).fork()).ldelim();
      return C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = _n();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.sources.push(a.Source.decode(N, N.uint32()));
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { sources: Array.isArray(b == null ? void 0 : b.sources) ? b.sources.map((C) => a.Source.fromJSON(C)) : [] };
    },
    toJSON(b) {
      const C = {};
      return b.sources ? C.sources = b.sources.map((N) => N ? a.Source.toJSON(N) : void 0) : C.sources = [], C;
    },
    fromPartial(b) {
      var C;
      const N = _n();
      return N.sources = ((C = b.sources) === null || C === void 0 ? void 0 : C.map((_e) => a.Source.fromPartial(_e))) || [], N;
    }
  };
  function En() {
    return {
      collectionId: "",
      sourceId: "",
      updateMask: void 0,
      metadata: void 0,
      address: void 0,
      preview: void 0
    };
  }
  a.UpdateSourceRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.sourceId !== "" && C.uint32(26).string(b.sourceId), b.updateMask !== void 0 && v.FieldMask.encode(v.FieldMask.wrap(b.updateMask), C.uint32(34).fork()).ldelim(), b.metadata !== void 0 && p.Value.encode(p.Value.wrap(b.metadata), C.uint32(42).fork()).ldelim(), b.address !== void 0 && a.SourceAddress.encode(b.address, C.uint32(50).fork()).ldelim(), b.preview !== void 0 && a.PreviewAddress.encode(b.preview, C.uint32(58).fork()).ldelim(), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = En();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 3:
            ie.sourceId = N.string();
            break;
          case 4:
            ie.updateMask = v.FieldMask.unwrap(v.FieldMask.decode(N, N.uint32()));
            break;
          case 5:
            ie.metadata = p.Value.unwrap(p.Value.decode(N, N.uint32()));
            break;
          case 6:
            ie.address = a.SourceAddress.decode(N, N.uint32());
            break;
          case 7:
            ie.preview = a.PreviewAddress.decode(N, N.uint32());
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        sourceId: Le(b.sourceId) ? String(b.sourceId) : "",
        updateMask: Le(b.updateMask) ? v.FieldMask.unwrap(v.FieldMask.fromJSON(b.updateMask)) : void 0,
        metadata: Le(b == null ? void 0 : b.metadata) ? b.metadata : void 0,
        address: Le(b.address) ? a.SourceAddress.fromJSON(b.address) : void 0,
        preview: Le(b.preview) ? a.PreviewAddress.fromJSON(b.preview) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.sourceId !== void 0 && (C.sourceId = b.sourceId), b.updateMask !== void 0 && (C.updateMask = v.FieldMask.toJSON(v.FieldMask.wrap(b.updateMask))), b.metadata !== void 0 && (C.metadata = b.metadata), b.address !== void 0 && (C.address = b.address ? a.SourceAddress.toJSON(b.address) : void 0), b.preview !== void 0 && (C.preview = b.preview ? a.PreviewAddress.toJSON(b.preview) : void 0), C;
    },
    fromPartial(b) {
      var C, N, _e, ie;
      const Re = En();
      return Re.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", Re.sourceId = (N = b.sourceId) !== null && N !== void 0 ? N : "", Re.updateMask = (_e = b.updateMask) !== null && _e !== void 0 ? _e : void 0, Re.metadata = (ie = b.metadata) !== null && ie !== void 0 ? ie : void 0, Re.address = b.address !== void 0 && b.address !== null ? a.SourceAddress.fromPartial(b.address) : void 0, Re.preview = b.preview !== void 0 && b.preview !== null ? a.PreviewAddress.fromPartial(b.preview) : void 0, Re;
    }
  };
  function Tn() {
    return { source: void 0, broadcastUpdated: !1 };
  }
  a.UpdateSourceResponse = {
    encode(b, C = c.default.Writer.create()) {
      return b.source !== void 0 && a.Source.encode(b.source, C.uint32(10).fork()).ldelim(), b.broadcastUpdated === !0 && C.uint32(16).bool(b.broadcastUpdated), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = Tn();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.source = a.Source.decode(N, N.uint32());
            break;
          case 2:
            ie.broadcastUpdated = N.bool();
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        source: Le(b.source) ? a.Source.fromJSON(b.source) : void 0,
        broadcastUpdated: Le(b.broadcastUpdated) ? !!b.broadcastUpdated : !1
      };
    },
    toJSON(b) {
      const C = {};
      return b.source !== void 0 && (C.source = b.source ? a.Source.toJSON(b.source) : void 0), b.broadcastUpdated !== void 0 && (C.broadcastUpdated = b.broadcastUpdated), C;
    },
    fromPartial(b) {
      var C;
      const N = Tn();
      return N.source = b.source !== void 0 && b.source !== null ? a.Source.fromPartial(b.source) : void 0, N.broadcastUpdated = (C = b.broadcastUpdated) !== null && C !== void 0 ? C : !1, N;
    }
  };
  function wn() {
    return { collectionId: "", projectId: "", sourceId: "", force: void 0 };
  }
  a.RemoveSourceFromProjectRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.projectId !== "" && C.uint32(18).string(b.projectId), b.sourceId !== "" && C.uint32(26).string(b.sourceId), b.force !== void 0 && C.uint32(32).bool(b.force), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = wn();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.projectId = N.string();
            break;
          case 3:
            ie.sourceId = N.string();
            break;
          case 4:
            ie.force = N.bool();
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : "",
        sourceId: Le(b.sourceId) ? String(b.sourceId) : "",
        force: Le(b.force) ? !!b.force : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.projectId !== void 0 && (C.projectId = b.projectId), b.sourceId !== void 0 && (C.sourceId = b.sourceId), b.force !== void 0 && (C.force = b.force), C;
    },
    fromPartial(b) {
      var C, N, _e, ie;
      const Re = wn();
      return Re.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", Re.projectId = (N = b.projectId) !== null && N !== void 0 ? N : "", Re.sourceId = (_e = b.sourceId) !== null && _e !== void 0 ? _e : "", Re.force = (ie = b.force) !== null && ie !== void 0 ? ie : void 0, Re;
    }
  };
  function kn() {
    return { project: void 0, broadcastUpdated: !1 };
  }
  a.RemoveSourceFromProjectResponse = {
    encode(b, C = c.default.Writer.create()) {
      return b.project !== void 0 && a.Project.encode(b.project, C.uint32(10).fork()).ldelim(), b.broadcastUpdated === !0 && C.uint32(16).bool(b.broadcastUpdated), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = kn();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.project = a.Project.decode(N, N.uint32());
            break;
          case 2:
            ie.broadcastUpdated = N.bool();
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        project: Le(b.project) ? a.Project.fromJSON(b.project) : void 0,
        broadcastUpdated: Le(b.broadcastUpdated) ? !!b.broadcastUpdated : !1
      };
    },
    toJSON(b) {
      const C = {};
      return b.project !== void 0 && (C.project = b.project ? a.Project.toJSON(b.project) : void 0), b.broadcastUpdated !== void 0 && (C.broadcastUpdated = b.broadcastUpdated), C;
    },
    fromPartial(b) {
      var C;
      const N = kn();
      return N.project = b.project !== void 0 && b.project !== null ? a.Project.fromPartial(b.project) : void 0, N.broadcastUpdated = (C = b.broadcastUpdated) !== null && C !== void 0 ? C : !1, N;
    }
  };
  function In() {
    return { collectionId: "", sourceId: "", accessToken: void 0 };
  }
  a.GetSourcePlaylistRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.sourceId !== "" && C.uint32(26).string(b.sourceId), b.accessToken !== void 0 && C.uint32(34).string(b.accessToken), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = In();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 3:
            ie.sourceId = N.string();
            break;
          case 4:
            ie.accessToken = N.string();
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        sourceId: Le(b.sourceId) ? String(b.sourceId) : "",
        accessToken: Le(b.accessToken) ? String(b.accessToken) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.sourceId !== void 0 && (C.sourceId = b.sourceId), b.accessToken !== void 0 && (C.accessToken = b.accessToken), C;
    },
    fromPartial(b) {
      var C, N, _e;
      const ie = In();
      return ie.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", ie.sourceId = (N = b.sourceId) !== null && N !== void 0 ? N : "", ie.accessToken = (_e = b.accessToken) !== null && _e !== void 0 ? _e : void 0, ie;
    }
  };
  function Rn() {
    return { manifest: "" };
  }
  a.GetSourcePlaylistResponse = {
    encode(b, C = c.default.Writer.create()) {
      return b.manifest !== "" && C.uint32(10).string(b.manifest), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = Rn();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.manifest = N.string();
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { manifest: Le(b.manifest) ? String(b.manifest) : "" };
    },
    toJSON(b) {
      const C = {};
      return b.manifest !== void 0 && (C.manifest = b.manifest), C;
    },
    fromPartial(b) {
      var C;
      const N = Rn();
      return N.manifest = (C = b.manifest) !== null && C !== void 0 ? C : "", N;
    }
  };
  function Cn() {
    return { serviceUserId: "", displayName: void 0, role: void 0, maxDuration: void 0 };
  }
  a.CreateAccessTokenRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.serviceUserId !== "" && C.uint32(10).string(b.serviceUserId), b.displayName !== void 0 && C.uint32(34).string(b.displayName), b.role !== void 0 && C.uint32(16).int32(Be(b.role)), b.maxDuration !== void 0 && C.uint32(24).uint32(b.maxDuration), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = Cn();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.serviceUserId = N.string();
            break;
          case 4:
            ie.displayName = N.string();
            break;
          case 2:
            ie.role = ve(N.int32());
            break;
          case 3:
            ie.maxDuration = N.uint32();
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        serviceUserId: Le(b.serviceUserId) ? String(b.serviceUserId) : "",
        displayName: Le(b.displayName) ? String(b.displayName) : void 0,
        role: Le(b.role) ? ve(b.role) : void 0,
        maxDuration: Le(b.maxDuration) ? Number(b.maxDuration) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.serviceUserId !== void 0 && (C.serviceUserId = b.serviceUserId), b.displayName !== void 0 && (C.displayName = b.displayName), b.role !== void 0 && (C.role = b.role !== void 0 ? Pe(b.role) : void 0), b.maxDuration !== void 0 && (C.maxDuration = Math.round(b.maxDuration)), C;
    },
    fromPartial(b) {
      var C, N, _e, ie;
      const Re = Cn();
      return Re.serviceUserId = (C = b.serviceUserId) !== null && C !== void 0 ? C : "", Re.displayName = (N = b.displayName) !== null && N !== void 0 ? N : void 0, Re.role = (_e = b.role) !== null && _e !== void 0 ? _e : void 0, Re.maxDuration = (ie = b.maxDuration) !== null && ie !== void 0 ? ie : void 0, Re;
    }
  };
  function Pn() {
    return { accessToken: "" };
  }
  a.CreateAccessTokenResponse = {
    encode(b, C = c.default.Writer.create()) {
      return b.accessToken !== "" && C.uint32(10).string(b.accessToken), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = Pn();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.accessToken = N.string();
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { accessToken: Le(b.accessToken) ? String(b.accessToken) : "" };
    },
    toJSON(b) {
      const C = {};
      return b.accessToken !== void 0 && (C.accessToken = b.accessToken), C;
    },
    fromPartial(b) {
      var C;
      const N = Pn();
      return N.accessToken = (C = b.accessToken) !== null && C !== void 0 ? C : "", N;
    }
  };
  function On() {
    return { displayName: "", serviceUserId: void 0 };
  }
  a.GuestAccessTokenDirect = {
    encode(b, C = c.default.Writer.create()) {
      return b.displayName !== "" && C.uint32(10).string(b.displayName), b.serviceUserId !== void 0 && C.uint32(18).string(b.serviceUserId), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = On();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.displayName = N.string();
            break;
          case 2:
            ie.serviceUserId = N.string();
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        displayName: Le(b.displayName) ? String(b.displayName) : "",
        serviceUserId: Le(b.serviceUserId) ? String(b.serviceUserId) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.displayName !== void 0 && (C.displayName = b.displayName), b.serviceUserId !== void 0 && (C.serviceUserId = b.serviceUserId), C;
    },
    fromPartial(b) {
      var C, N;
      const _e = On();
      return _e.displayName = (C = b.displayName) !== null && C !== void 0 ? C : "", _e.serviceUserId = (N = b.serviceUserId) !== null && N !== void 0 ? N : void 0, _e;
    }
  };
  function Mn() {
    return { maxDuration: void 0 };
  }
  a.GuestAccessTokenExchange = {
    encode(b, C = c.default.Writer.create()) {
      return b.maxDuration !== void 0 && C.uint32(8).uint32(b.maxDuration), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = Mn();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.maxDuration = N.uint32();
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { maxDuration: Le(b.maxDuration) ? Number(b.maxDuration) : void 0 };
    },
    toJSON(b) {
      const C = {};
      return b.maxDuration !== void 0 && (C.maxDuration = Math.round(b.maxDuration)), C;
    },
    fromPartial(b) {
      var C;
      const N = Mn();
      return N.maxDuration = (C = b.maxDuration) !== null && C !== void 0 ? C : void 0, N;
    }
  };
  function An() {
    return { direct: void 0, exchange: void 0 };
  }
  a.GuestAccessToken = {
    encode(b, C = c.default.Writer.create()) {
      return b.direct !== void 0 && a.GuestAccessTokenDirect.encode(b.direct, C.uint32(10).fork()).ldelim(), b.exchange !== void 0 && a.GuestAccessTokenExchange.encode(b.exchange, C.uint32(18).fork()).ldelim(), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = An();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.direct = a.GuestAccessTokenDirect.decode(N, N.uint32());
            break;
          case 2:
            ie.exchange = a.GuestAccessTokenExchange.decode(N, N.uint32());
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        direct: Le(b.direct) ? a.GuestAccessTokenDirect.fromJSON(b.direct) : void 0,
        exchange: Le(b.exchange) ? a.GuestAccessTokenExchange.fromJSON(b.exchange) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.direct !== void 0 && (C.direct = b.direct ? a.GuestAccessTokenDirect.toJSON(b.direct) : void 0), b.exchange !== void 0 && (C.exchange = b.exchange ? a.GuestAccessTokenExchange.toJSON(b.exchange) : void 0), C;
    },
    fromPartial(b) {
      const C = An();
      return C.direct = b.direct !== void 0 && b.direct !== null ? a.GuestAccessTokenDirect.fromPartial(b.direct) : void 0, C.exchange = b.exchange !== void 0 && b.exchange !== null ? a.GuestAccessTokenExchange.fromPartial(b.exchange) : void 0, C;
    }
  };
  function Nn() {
    return {
      collectionId: "",
      projectId: "",
      maxDuration: void 0,
      role: ce.ROLE_UNSPECIFIED,
      token: void 0,
      url: void 0
    };
  }
  a.CreateGuestAccessTokenRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.projectId !== "" && C.uint32(18).string(b.projectId), b.maxDuration !== void 0 && C.uint32(24).uint32(b.maxDuration), b.role !== ce.ROLE_UNSPECIFIED && C.uint32(32).int32(Be(b.role)), b.token !== void 0 && a.GuestAccessToken.encode(b.token, C.uint32(42).fork()).ldelim(), b.url !== void 0 && C.uint32(50).string(b.url), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = Nn();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.projectId = N.string();
            break;
          case 3:
            ie.maxDuration = N.uint32();
            break;
          case 4:
            ie.role = ve(N.int32());
            break;
          case 5:
            ie.token = a.GuestAccessToken.decode(N, N.uint32());
            break;
          case 6:
            ie.url = N.string();
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : "",
        maxDuration: Le(b.maxDuration) ? Number(b.maxDuration) : void 0,
        role: Le(b.role) ? ve(b.role) : ce.ROLE_UNSPECIFIED,
        token: Le(b.token) ? a.GuestAccessToken.fromJSON(b.token) : void 0,
        url: Le(b.url) ? String(b.url) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.projectId !== void 0 && (C.projectId = b.projectId), b.maxDuration !== void 0 && (C.maxDuration = Math.round(b.maxDuration)), b.role !== void 0 && (C.role = Pe(b.role)), b.token !== void 0 && (C.token = b.token ? a.GuestAccessToken.toJSON(b.token) : void 0), b.url !== void 0 && (C.url = b.url), C;
    },
    fromPartial(b) {
      var C, N, _e, ie, Re;
      const gt = Nn();
      return gt.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", gt.projectId = (N = b.projectId) !== null && N !== void 0 ? N : "", gt.maxDuration = (_e = b.maxDuration) !== null && _e !== void 0 ? _e : void 0, gt.role = (ie = b.role) !== null && ie !== void 0 ? ie : ce.ROLE_UNSPECIFIED, gt.token = b.token !== void 0 && b.token !== null ? a.GuestAccessToken.fromPartial(b.token) : void 0, gt.url = (Re = b.url) !== null && Re !== void 0 ? Re : void 0, gt;
    }
  };
  function $n() {
    return { accessToken: "", url: void 0 };
  }
  a.CreateGuestAccessTokenResponse = {
    encode(b, C = c.default.Writer.create()) {
      return b.accessToken !== "" && C.uint32(10).string(b.accessToken), b.url !== void 0 && C.uint32(18).string(b.url), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = $n();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.accessToken = N.string();
            break;
          case 2:
            ie.url = N.string();
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        accessToken: Le(b.accessToken) ? String(b.accessToken) : "",
        url: Le(b.url) ? String(b.url) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.accessToken !== void 0 && (C.accessToken = b.accessToken), b.url !== void 0 && (C.url = b.url), C;
    },
    fromPartial(b) {
      var C, N;
      const _e = $n();
      return _e.accessToken = (C = b.accessToken) !== null && C !== void 0 ? C : "", _e.url = (N = b.url) !== null && N !== void 0 ? N : void 0, _e;
    }
  };
  function Dn() {
    return { collectionId: "", projectId: "", displayName: "" };
  }
  a.CreateWebRtcAccessTokenRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.projectId !== "" && C.uint32(18).string(b.projectId), b.displayName !== "" && C.uint32(26).string(b.displayName), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = Dn();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.projectId = N.string();
            break;
          case 3:
            ie.displayName = N.string();
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : "",
        displayName: Le(b.displayName) ? String(b.displayName) : ""
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.projectId !== void 0 && (C.projectId = b.projectId), b.displayName !== void 0 && (C.displayName = b.displayName), C;
    },
    fromPartial(b) {
      var C, N, _e;
      const ie = Dn();
      return ie.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", ie.projectId = (N = b.projectId) !== null && N !== void 0 ? N : "", ie.displayName = (_e = b.displayName) !== null && _e !== void 0 ? _e : "", ie;
    }
  };
  function Ln() {
    return { webrtcAccess: void 0 };
  }
  a.CreateWebRtcAccessTokenResponse = {
    encode(b, C = c.default.Writer.create()) {
      return b.webrtcAccess !== void 0 && a.WebRtcAccess.encode(b.webrtcAccess, C.uint32(18).fork()).ldelim(), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = Ln();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 2:
            ie.webrtcAccess = a.WebRtcAccess.decode(N, N.uint32());
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { webrtcAccess: Le(b.webrtcAccess) ? a.WebRtcAccess.fromJSON(b.webrtcAccess) : void 0 };
    },
    toJSON(b) {
      const C = {};
      return b.webrtcAccess !== void 0 && (C.webrtcAccess = b.webrtcAccess ? a.WebRtcAccess.toJSON(b.webrtcAccess) : void 0), C;
    },
    fromPartial(b) {
      const C = Ln();
      return C.webrtcAccess = b.webrtcAccess !== void 0 && b.webrtcAccess !== null ? a.WebRtcAccess.fromPartial(b.webrtcAccess) : void 0, C;
    }
  };
  function Bn() {
    return {};
  }
  a.RefreshAccessTokenRequest = {
    encode(b, C = c.default.Writer.create()) {
      return C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = Bn();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {};
    },
    toJSON(b) {
      return {};
    },
    fromPartial(b) {
      return Bn();
    }
  };
  function Un() {
    return {};
  }
  a.RefreshAccessTokenResponse = {
    encode(b, C = c.default.Writer.create()) {
      return C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = Un();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {};
    },
    toJSON(b) {
      return {};
    },
    fromPartial(b) {
      return Un();
    }
  };
  function xn() {
    return { collectionId: "", projectId: "", code: "", url: "", autoDelete: void 0 };
  }
  a.GuestCode = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.projectId !== "" && C.uint32(18).string(b.projectId), b.code !== "" && C.uint32(26).string(b.code), b.url !== "" && C.uint32(34).string(b.url), b.autoDelete !== void 0 && _.Timestamp.encode(Ht(b.autoDelete), C.uint32(42).fork()).ldelim(), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = xn();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.projectId = N.string();
            break;
          case 3:
            ie.code = N.string();
            break;
          case 4:
            ie.url = N.string();
            break;
          case 5:
            ie.autoDelete = zt(_.Timestamp.decode(N, N.uint32()));
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : "",
        code: Le(b.code) ? String(b.code) : "",
        url: Le(b.url) ? String(b.url) : "",
        autoDelete: Le(b.autoDelete) ? String(b.autoDelete) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.projectId !== void 0 && (C.projectId = b.projectId), b.code !== void 0 && (C.code = b.code), b.url !== void 0 && (C.url = b.url), b.autoDelete !== void 0 && (C.autoDelete = b.autoDelete), C;
    },
    fromPartial(b) {
      var C, N, _e, ie, Re;
      const gt = xn();
      return gt.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", gt.projectId = (N = b.projectId) !== null && N !== void 0 ? N : "", gt.code = (_e = b.code) !== null && _e !== void 0 ? _e : "", gt.url = (ie = b.url) !== null && ie !== void 0 ? ie : "", gt.autoDelete = (Re = b.autoDelete) !== null && Re !== void 0 ? Re : void 0, gt;
    }
  };
  function Fn() {
    return { serviceId: "", code: "" };
  }
  a.GuestCodeRedirectRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.serviceId !== "" && C.uint32(10).string(b.serviceId), b.code !== "" && C.uint32(18).string(b.code), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = Fn();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.serviceId = N.string();
            break;
          case 2:
            ie.code = N.string();
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        serviceId: Le(b.serviceId) ? String(b.serviceId) : "",
        code: Le(b.code) ? String(b.code) : ""
      };
    },
    toJSON(b) {
      const C = {};
      return b.serviceId !== void 0 && (C.serviceId = b.serviceId), b.code !== void 0 && (C.code = b.code), C;
    },
    fromPartial(b) {
      var C, N;
      const _e = Fn();
      return _e.serviceId = (C = b.serviceId) !== null && C !== void 0 ? C : "", _e.code = (N = b.code) !== null && N !== void 0 ? N : "", _e;
    }
  };
  function qn() {
    return {};
  }
  a.GuestCodeRedirectResponse = {
    encode(b, C = c.default.Writer.create()) {
      return C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = qn();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {};
    },
    toJSON(b) {
      return {};
    },
    fromPartial(b) {
      return qn();
    }
  };
  function Vn() {
    return { alg: "", kty: "", use: "", kid: "", e: "", n: "" };
  }
  a.JsonWebKey = {
    encode(b, C = c.default.Writer.create()) {
      return b.alg !== "" && C.uint32(10).string(b.alg), b.kty !== "" && C.uint32(18).string(b.kty), b.use !== "" && C.uint32(26).string(b.use), b.kid !== "" && C.uint32(34).string(b.kid), b.e !== "" && C.uint32(42).string(b.e), b.n !== "" && C.uint32(50).string(b.n), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = Vn();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.alg = N.string();
            break;
          case 2:
            ie.kty = N.string();
            break;
          case 3:
            ie.use = N.string();
            break;
          case 4:
            ie.kid = N.string();
            break;
          case 5:
            ie.e = N.string();
            break;
          case 6:
            ie.n = N.string();
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        alg: Le(b.alg) ? String(b.alg) : "",
        kty: Le(b.kty) ? String(b.kty) : "",
        use: Le(b.use) ? String(b.use) : "",
        kid: Le(b.kid) ? String(b.kid) : "",
        e: Le(b.e) ? String(b.e) : "",
        n: Le(b.n) ? String(b.n) : ""
      };
    },
    toJSON(b) {
      const C = {};
      return b.alg !== void 0 && (C.alg = b.alg), b.kty !== void 0 && (C.kty = b.kty), b.use !== void 0 && (C.use = b.use), b.kid !== void 0 && (C.kid = b.kid), b.e !== void 0 && (C.e = b.e), b.n !== void 0 && (C.n = b.n), C;
    },
    fromPartial(b) {
      var C, N, _e, ie, Re, gt;
      const Ct = Vn();
      return Ct.alg = (C = b.alg) !== null && C !== void 0 ? C : "", Ct.kty = (N = b.kty) !== null && N !== void 0 ? N : "", Ct.use = (_e = b.use) !== null && _e !== void 0 ? _e : "", Ct.kid = (ie = b.kid) !== null && ie !== void 0 ? ie : "", Ct.e = (Re = b.e) !== null && Re !== void 0 ? Re : "", Ct.n = (gt = b.n) !== null && gt !== void 0 ? gt : "", Ct;
    }
  };
  function Jn() {
    return {};
  }
  a.GetJsonWebKeySetRequest = {
    encode(b, C = c.default.Writer.create()) {
      return C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = Jn();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {};
    },
    toJSON(b) {
      return {};
    },
    fromPartial(b) {
      return Jn();
    }
  };
  function Gn() {
    return { keys: [] };
  }
  a.GetJsonWebKeySetResponse = {
    encode(b, C = c.default.Writer.create()) {
      for (const N of b.keys)
        a.JsonWebKey.encode(N, C.uint32(10).fork()).ldelim();
      return C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = Gn();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.keys.push(a.JsonWebKey.decode(N, N.uint32()));
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { keys: Array.isArray(b == null ? void 0 : b.keys) ? b.keys.map((C) => a.JsonWebKey.fromJSON(C)) : [] };
    },
    toJSON(b) {
      const C = {};
      return b.keys ? C.keys = b.keys.map((N) => N ? a.JsonWebKey.toJSON(N) : void 0) : C.keys = [], C;
    },
    fromPartial(b) {
      var C;
      const N = Gn();
      return N.keys = ((C = b.keys) === null || C === void 0 ? void 0 : C.map((_e) => a.JsonWebKey.fromPartial(_e))) || [], N;
    }
  };
  function Wn() {
    return {};
  }
  a.GetTestTokenRequest = {
    encode(b, C = c.default.Writer.create()) {
      return C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = Wn();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {};
    },
    toJSON(b) {
      return {};
    },
    fromPartial(b) {
      return Wn();
    }
  };
  function Hn() {
    return { accessToken: "" };
  }
  a.GetTestTokenResponse = {
    encode(b, C = c.default.Writer.create()) {
      return b.accessToken !== "" && C.uint32(10).string(b.accessToken), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = Hn();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.accessToken = N.string();
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { accessToken: Le(b.accessToken) ? String(b.accessToken) : "" };
    },
    toJSON(b) {
      const C = {};
      return b.accessToken !== void 0 && (C.accessToken = b.accessToken), C;
    },
    fromPartial(b) {
      var C;
      const N = Hn();
      return N.accessToken = (C = b.accessToken) !== null && C !== void 0 ? C : "", N;
    }
  };
  function zn() {
    return { collectionId: "", projectId: "", destinationId: "", destination: void 0 };
  }
  a.DestinationCreateEvent = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.projectId !== "" && C.uint32(18).string(b.projectId), b.destinationId !== "" && C.uint32(26).string(b.destinationId), b.destination !== void 0 && a.Destination.encode(b.destination, C.uint32(34).fork()).ldelim(), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = zn();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.projectId = N.string();
            break;
          case 3:
            ie.destinationId = N.string();
            break;
          case 4:
            ie.destination = a.Destination.decode(N, N.uint32());
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : "",
        destinationId: Le(b.destinationId) ? String(b.destinationId) : "",
        destination: Le(b.destination) ? a.Destination.fromJSON(b.destination) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.projectId !== void 0 && (C.projectId = b.projectId), b.destinationId !== void 0 && (C.destinationId = b.destinationId), b.destination !== void 0 && (C.destination = b.destination ? a.Destination.toJSON(b.destination) : void 0), C;
    },
    fromPartial(b) {
      var C, N, _e;
      const ie = zn();
      return ie.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", ie.projectId = (N = b.projectId) !== null && N !== void 0 ? N : "", ie.destinationId = (_e = b.destinationId) !== null && _e !== void 0 ? _e : "", ie.destination = b.destination !== void 0 && b.destination !== null ? a.Destination.fromPartial(b.destination) : void 0, ie;
    }
  };
  function Kn() {
    return { collectionId: "", projectId: "", destinationId: "" };
  }
  a.DestinationDeleteEvent = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.projectId !== "" && C.uint32(18).string(b.projectId), b.destinationId !== "" && C.uint32(26).string(b.destinationId), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = Kn();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.projectId = N.string();
            break;
          case 3:
            ie.destinationId = N.string();
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : "",
        destinationId: Le(b.destinationId) ? String(b.destinationId) : ""
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.projectId !== void 0 && (C.projectId = b.projectId), b.destinationId !== void 0 && (C.destinationId = b.destinationId), C;
    },
    fromPartial(b) {
      var C, N, _e;
      const ie = Kn();
      return ie.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", ie.projectId = (N = b.projectId) !== null && N !== void 0 ? N : "", ie.destinationId = (_e = b.destinationId) !== null && _e !== void 0 ? _e : "", ie;
    }
  };
  function Yn() {
    return { collectionId: "", projectId: "", destinationId: "", updateMask: [], destination: void 0 };
  }
  a.DestinationUpdateEvent = {
    encode(b, C = c.default.Writer.create()) {
      b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.projectId !== "" && C.uint32(18).string(b.projectId), b.destinationId !== "" && C.uint32(26).string(b.destinationId);
      for (const N of b.updateMask)
        C.uint32(34).string(N);
      return b.destination !== void 0 && a.Destination.encode(b.destination, C.uint32(42).fork()).ldelim(), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = Yn();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.projectId = N.string();
            break;
          case 3:
            ie.destinationId = N.string();
            break;
          case 4:
            ie.updateMask.push(N.string());
            break;
          case 5:
            ie.destination = a.Destination.decode(N, N.uint32());
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : "",
        destinationId: Le(b.destinationId) ? String(b.destinationId) : "",
        updateMask: Array.isArray(b == null ? void 0 : b.updateMask) ? b.updateMask.map((C) => String(C)) : [],
        destination: Le(b.destination) ? a.Destination.fromJSON(b.destination) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.projectId !== void 0 && (C.projectId = b.projectId), b.destinationId !== void 0 && (C.destinationId = b.destinationId), b.updateMask ? C.updateMask = b.updateMask.map((N) => N) : C.updateMask = [], b.destination !== void 0 && (C.destination = b.destination ? a.Destination.toJSON(b.destination) : void 0), C;
    },
    fromPartial(b) {
      var C, N, _e, ie;
      const Re = Yn();
      return Re.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", Re.projectId = (N = b.projectId) !== null && N !== void 0 ? N : "", Re.destinationId = (_e = b.destinationId) !== null && _e !== void 0 ? _e : "", Re.updateMask = ((ie = b.updateMask) === null || ie === void 0 ? void 0 : ie.map((gt) => gt)) || [], Re.destination = b.destination !== void 0 && b.destination !== null ? a.Destination.fromPartial(b.destination) : void 0, Re;
    }
  };
  function Zn() {
    return { collectionId: "", projectId: "", destinationId: "", connect: void 0 };
  }
  a.DestinationStateEvent = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.projectId !== "" && C.uint32(18).string(b.projectId), b.destinationId !== "" && C.uint32(26).string(b.destinationId), b.connect !== void 0 && C.uint32(32).int32(xe(b.connect)), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = Zn();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.projectId = N.string();
            break;
          case 3:
            ie.destinationId = N.string();
            break;
          case 4:
            ie.connect = se(N.int32());
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : "",
        destinationId: Le(b.destinationId) ? String(b.destinationId) : "",
        connect: Le(b.connect) ? se(b.connect) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.projectId !== void 0 && (C.projectId = b.projectId), b.destinationId !== void 0 && (C.destinationId = b.destinationId), b.connect !== void 0 && (C.connect = b.connect !== void 0 ? Se(b.connect) : void 0), C;
    },
    fromPartial(b) {
      var C, N, _e, ie;
      const Re = Zn();
      return Re.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", Re.projectId = (N = b.projectId) !== null && N !== void 0 ? N : "", Re.destinationId = (_e = b.destinationId) !== null && _e !== void 0 ? _e : "", Re.connect = (ie = b.connect) !== null && ie !== void 0 ? ie : void 0, Re;
    }
  };
  function jn() {
    return { collectionId: "", projectId: "", project: void 0 };
  }
  a.ProjectCreateEvent = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.projectId !== "" && C.uint32(18).string(b.projectId), b.project !== void 0 && a.Project.encode(b.project, C.uint32(26).fork()).ldelim(), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = jn();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.projectId = N.string();
            break;
          case 3:
            ie.project = a.Project.decode(N, N.uint32());
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : "",
        project: Le(b.project) ? a.Project.fromJSON(b.project) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.projectId !== void 0 && (C.projectId = b.projectId), b.project !== void 0 && (C.project = b.project ? a.Project.toJSON(b.project) : void 0), C;
    },
    fromPartial(b) {
      var C, N;
      const _e = jn();
      return _e.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", _e.projectId = (N = b.projectId) !== null && N !== void 0 ? N : "", _e.project = b.project !== void 0 && b.project !== null ? a.Project.fromPartial(b.project) : void 0, _e;
    }
  };
  function Xn() {
    return { collectionId: "", projectId: "" };
  }
  a.ProjectDeleteEvent = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.projectId !== "" && C.uint32(18).string(b.projectId), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = Xn();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.projectId = N.string();
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : ""
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.projectId !== void 0 && (C.projectId = b.projectId), C;
    },
    fromPartial(b) {
      var C, N;
      const _e = Xn();
      return _e.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", _e.projectId = (N = b.projectId) !== null && N !== void 0 ? N : "", _e;
    }
  };
  function Qn() {
    return { collectionId: "", projectId: "", updateMask: [], project: void 0 };
  }
  a.ProjectUpdateEvent = {
    encode(b, C = c.default.Writer.create()) {
      b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.projectId !== "" && C.uint32(18).string(b.projectId);
      for (const N of b.updateMask)
        C.uint32(26).string(N);
      return b.project !== void 0 && a.Project.encode(b.project, C.uint32(34).fork()).ldelim(), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = Qn();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.projectId = N.string();
            break;
          case 3:
            ie.updateMask.push(N.string());
            break;
          case 4:
            ie.project = a.Project.decode(N, N.uint32());
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : "",
        updateMask: Array.isArray(b == null ? void 0 : b.updateMask) ? b.updateMask.map((C) => String(C)) : [],
        project: Le(b.project) ? a.Project.fromJSON(b.project) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.projectId !== void 0 && (C.projectId = b.projectId), b.updateMask ? C.updateMask = b.updateMask.map((N) => N) : C.updateMask = [], b.project !== void 0 && (C.project = b.project ? a.Project.toJSON(b.project) : void 0), C;
    },
    fromPartial(b) {
      var C, N, _e;
      const ie = Qn();
      return ie.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", ie.projectId = (N = b.projectId) !== null && N !== void 0 ? N : "", ie.updateMask = ((_e = b.updateMask) === null || _e === void 0 ? void 0 : _e.map((Re) => Re)) || [], ie.project = b.project !== void 0 && b.project !== null ? a.Project.fromPartial(b.project) : void 0, ie;
    }
  };
  function ei() {
    return { collectionId: "", projectId: "", broadcastId: "", phase: void 0, error: void 0 };
  }
  a.ProjectBroadcastStateEvent = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.projectId !== "" && C.uint32(18).string(b.projectId), b.broadcastId !== "" && C.uint32(26).string(b.broadcastId), b.phase !== void 0 && C.uint32(32).int32(Ze(b.phase)), b.error !== void 0 && C.uint32(40).int32(Ke(b.error)), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = ei();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.projectId = N.string();
            break;
          case 3:
            ie.broadcastId = N.string();
            break;
          case 4:
            ie.phase = Oe(N.int32());
            break;
          case 5:
            ie.error = Je(N.int32());
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : "",
        broadcastId: Le(b.broadcastId) ? String(b.broadcastId) : "",
        phase: Le(b.phase) ? Oe(b.phase) : void 0,
        error: Le(b.error) ? Je(b.error) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.projectId !== void 0 && (C.projectId = b.projectId), b.broadcastId !== void 0 && (C.broadcastId = b.broadcastId), b.phase !== void 0 && (C.phase = b.phase !== void 0 ? Fe(b.phase) : void 0), b.error !== void 0 && (C.error = b.error !== void 0 ? je(b.error) : void 0), C;
    },
    fromPartial(b) {
      var C, N, _e, ie, Re;
      const gt = ei();
      return gt.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", gt.projectId = (N = b.projectId) !== null && N !== void 0 ? N : "", gt.broadcastId = (_e = b.broadcastId) !== null && _e !== void 0 ? _e : "", gt.phase = (ie = b.phase) !== null && ie !== void 0 ? ie : void 0, gt.error = (Re = b.error) !== null && Re !== void 0 ? Re : void 0, gt;
    }
  };
  function ti() {
    return { collectionId: "", collection: void 0 };
  }
  a.CollectionCreateEvent = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.collection !== void 0 && a.Collection.encode(b.collection, C.uint32(18).fork()).ldelim(), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = ti();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.collection = a.Collection.decode(N, N.uint32());
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        collection: Le(b.collection) ? a.Collection.fromJSON(b.collection) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.collection !== void 0 && (C.collection = b.collection ? a.Collection.toJSON(b.collection) : void 0), C;
    },
    fromPartial(b) {
      var C;
      const N = ti();
      return N.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", N.collection = b.collection !== void 0 && b.collection !== null ? a.Collection.fromPartial(b.collection) : void 0, N;
    }
  };
  function ri() {
    return { collectionId: "" };
  }
  a.CollectionDeleteEvent = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = ri();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { collectionId: Le(b.collectionId) ? String(b.collectionId) : "" };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), C;
    },
    fromPartial(b) {
      var C;
      const N = ri();
      return N.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", N;
    }
  };
  function ni() {
    return { collectionId: "", updateMask: [], collection: void 0 };
  }
  a.CollectionUpdateEvent = {
    encode(b, C = c.default.Writer.create()) {
      b.collectionId !== "" && C.uint32(10).string(b.collectionId);
      for (const N of b.updateMask)
        C.uint32(18).string(N);
      return b.collection !== void 0 && a.Collection.encode(b.collection, C.uint32(26).fork()).ldelim(), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = ni();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.updateMask.push(N.string());
            break;
          case 3:
            ie.collection = a.Collection.decode(N, N.uint32());
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        updateMask: Array.isArray(b == null ? void 0 : b.updateMask) ? b.updateMask.map((C) => String(C)) : [],
        collection: Le(b.collection) ? a.Collection.fromJSON(b.collection) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.updateMask ? C.updateMask = b.updateMask.map((N) => N) : C.updateMask = [], b.collection !== void 0 && (C.collection = b.collection ? a.Collection.toJSON(b.collection) : void 0), C;
    },
    fromPartial(b) {
      var C, N;
      const _e = ni();
      return _e.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", _e.updateMask = ((N = b.updateMask) === null || N === void 0 ? void 0 : N.map((ie) => ie)) || [], _e.collection = b.collection !== void 0 && b.collection !== null ? a.Collection.fromPartial(b.collection) : void 0, _e;
    }
  };
  function ii() {
    return { collectionId: "", sourceId: "", source: void 0 };
  }
  a.SourceCreateEvent = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.sourceId !== "" && C.uint32(18).string(b.sourceId), b.source !== void 0 && a.Source.encode(b.source, C.uint32(26).fork()).ldelim(), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = ii();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.sourceId = N.string();
            break;
          case 3:
            ie.source = a.Source.decode(N, N.uint32());
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        sourceId: Le(b.sourceId) ? String(b.sourceId) : "",
        source: Le(b.source) ? a.Source.fromJSON(b.source) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.sourceId !== void 0 && (C.sourceId = b.sourceId), b.source !== void 0 && (C.source = b.source ? a.Source.toJSON(b.source) : void 0), C;
    },
    fromPartial(b) {
      var C, N;
      const _e = ii();
      return _e.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", _e.sourceId = (N = b.sourceId) !== null && N !== void 0 ? N : "", _e.source = b.source !== void 0 && b.source !== null ? a.Source.fromPartial(b.source) : void 0, _e;
    }
  };
  function ai() {
    return { collectionId: "", sourceId: "" };
  }
  a.SourceDeleteEvent = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.sourceId !== "" && C.uint32(18).string(b.sourceId), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = ai();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.sourceId = N.string();
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        sourceId: Le(b.sourceId) ? String(b.sourceId) : ""
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.sourceId !== void 0 && (C.sourceId = b.sourceId), C;
    },
    fromPartial(b) {
      var C, N;
      const _e = ai();
      return _e.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", _e.sourceId = (N = b.sourceId) !== null && N !== void 0 ? N : "", _e;
    }
  };
  function oi() {
    return { collectionId: "", sourceId: "", updateMask: [], source: void 0 };
  }
  a.SourceUpdateEvent = {
    encode(b, C = c.default.Writer.create()) {
      b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.sourceId !== "" && C.uint32(18).string(b.sourceId);
      for (const N of b.updateMask)
        C.uint32(26).string(N);
      return b.source !== void 0 && a.Source.encode(b.source, C.uint32(34).fork()).ldelim(), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = oi();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.sourceId = N.string();
            break;
          case 3:
            ie.updateMask.push(N.string());
            break;
          case 4:
            ie.source = a.Source.decode(N, N.uint32());
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        sourceId: Le(b.sourceId) ? String(b.sourceId) : "",
        updateMask: Array.isArray(b == null ? void 0 : b.updateMask) ? b.updateMask.map((C) => String(C)) : [],
        source: Le(b.source) ? a.Source.fromJSON(b.source) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.sourceId !== void 0 && (C.sourceId = b.sourceId), b.updateMask ? C.updateMask = b.updateMask.map((N) => N) : C.updateMask = [], b.source !== void 0 && (C.source = b.source ? a.Source.toJSON(b.source) : void 0), C;
    },
    fromPartial(b) {
      var C, N, _e;
      const ie = oi();
      return ie.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", ie.sourceId = (N = b.sourceId) !== null && N !== void 0 ? N : "", ie.updateMask = ((_e = b.updateMask) === null || _e === void 0 ? void 0 : _e.map((Re) => Re)) || [], ie.source = b.source !== void 0 && b.source !== null ? a.Source.fromPartial(b.source) : void 0, ie;
    }
  };
  function si() {
    return { collectionId: "", sourceId: "", projectId: "", source: void 0 };
  }
  a.SourceAddEvent = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.sourceId !== "" && C.uint32(18).string(b.sourceId), b.projectId !== "" && C.uint32(26).string(b.projectId), b.source !== void 0 && a.Source.encode(b.source, C.uint32(34).fork()).ldelim(), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = si();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.sourceId = N.string();
            break;
          case 3:
            ie.projectId = N.string();
            break;
          case 4:
            ie.source = a.Source.decode(N, N.uint32());
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        sourceId: Le(b.sourceId) ? String(b.sourceId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : "",
        source: Le(b.source) ? a.Source.fromJSON(b.source) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.sourceId !== void 0 && (C.sourceId = b.sourceId), b.projectId !== void 0 && (C.projectId = b.projectId), b.source !== void 0 && (C.source = b.source ? a.Source.toJSON(b.source) : void 0), C;
    },
    fromPartial(b) {
      var C, N, _e;
      const ie = si();
      return ie.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", ie.sourceId = (N = b.sourceId) !== null && N !== void 0 ? N : "", ie.projectId = (_e = b.projectId) !== null && _e !== void 0 ? _e : "", ie.source = b.source !== void 0 && b.source !== null ? a.Source.fromPartial(b.source) : void 0, ie;
    }
  };
  function di() {
    return { collectionId: "", sourceId: "", projectId: "" };
  }
  a.SourceRemoveEvent = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.sourceId !== "" && C.uint32(18).string(b.sourceId), b.projectId !== "" && C.uint32(26).string(b.projectId), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = di();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.sourceId = N.string();
            break;
          case 3:
            ie.projectId = N.string();
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        sourceId: Le(b.sourceId) ? String(b.sourceId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : ""
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.sourceId !== void 0 && (C.sourceId = b.sourceId), b.projectId !== void 0 && (C.projectId = b.projectId), C;
    },
    fromPartial(b) {
      var C, N, _e;
      const ie = di();
      return ie.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", ie.sourceId = (N = b.sourceId) !== null && N !== void 0 ? N : "", ie.projectId = (_e = b.projectId) !== null && _e !== void 0 ? _e : "", ie;
    }
  };
  function ui() {
    return { collectionId: "", projectId: "", sourceId: "", connect: void 0 };
  }
  a.SourceStateEvent = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.projectId !== "" && C.uint32(18).string(b.projectId), b.sourceId !== "" && C.uint32(26).string(b.sourceId), b.connect !== void 0 && C.uint32(32).int32(xe(b.connect)), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = ui();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.projectId = N.string();
            break;
          case 3:
            ie.sourceId = N.string();
            break;
          case 4:
            ie.connect = se(N.int32());
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : "",
        sourceId: Le(b.sourceId) ? String(b.sourceId) : "",
        connect: Le(b.connect) ? se(b.connect) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.projectId !== void 0 && (C.projectId = b.projectId), b.sourceId !== void 0 && (C.sourceId = b.sourceId), b.connect !== void 0 && (C.connect = b.connect !== void 0 ? Se(b.connect) : void 0), C;
    },
    fromPartial(b) {
      var C, N, _e, ie;
      const Re = ui();
      return Re.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", Re.projectId = (N = b.projectId) !== null && N !== void 0 ? N : "", Re.sourceId = (_e = b.sourceId) !== null && _e !== void 0 ? _e : "", Re.connect = (ie = b.connect) !== null && ie !== void 0 ? ie : void 0, Re;
    }
  };
  function ci() {
    return { create: void 0, update: void 0, delete: void 0 };
  }
  a.CollectionEvent = {
    encode(b, C = c.default.Writer.create()) {
      return b.create !== void 0 && a.CollectionCreateEvent.encode(b.create, C.uint32(10).fork()).ldelim(), b.update !== void 0 && a.CollectionUpdateEvent.encode(b.update, C.uint32(18).fork()).ldelim(), b.delete !== void 0 && a.CollectionDeleteEvent.encode(b.delete, C.uint32(26).fork()).ldelim(), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = ci();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.create = a.CollectionCreateEvent.decode(N, N.uint32());
            break;
          case 2:
            ie.update = a.CollectionUpdateEvent.decode(N, N.uint32());
            break;
          case 3:
            ie.delete = a.CollectionDeleteEvent.decode(N, N.uint32());
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        create: Le(b.create) ? a.CollectionCreateEvent.fromJSON(b.create) : void 0,
        update: Le(b.update) ? a.CollectionUpdateEvent.fromJSON(b.update) : void 0,
        delete: Le(b.delete) ? a.CollectionDeleteEvent.fromJSON(b.delete) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.create !== void 0 && (C.create = b.create ? a.CollectionCreateEvent.toJSON(b.create) : void 0), b.update !== void 0 && (C.update = b.update ? a.CollectionUpdateEvent.toJSON(b.update) : void 0), b.delete !== void 0 && (C.delete = b.delete ? a.CollectionDeleteEvent.toJSON(b.delete) : void 0), C;
    },
    fromPartial(b) {
      const C = ci();
      return C.create = b.create !== void 0 && b.create !== null ? a.CollectionCreateEvent.fromPartial(b.create) : void 0, C.update = b.update !== void 0 && b.update !== null ? a.CollectionUpdateEvent.fromPartial(b.update) : void 0, C.delete = b.delete !== void 0 && b.delete !== null ? a.CollectionDeleteEvent.fromPartial(b.delete) : void 0, C;
    }
  };
  function li() {
    return { create: void 0, update: void 0, delete: void 0, state: void 0 };
  }
  a.DestinationEvent = {
    encode(b, C = c.default.Writer.create()) {
      return b.create !== void 0 && a.DestinationCreateEvent.encode(b.create, C.uint32(10).fork()).ldelim(), b.update !== void 0 && a.DestinationUpdateEvent.encode(b.update, C.uint32(18).fork()).ldelim(), b.delete !== void 0 && a.DestinationDeleteEvent.encode(b.delete, C.uint32(26).fork()).ldelim(), b.state !== void 0 && a.DestinationStateEvent.encode(b.state, C.uint32(34).fork()).ldelim(), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = li();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.create = a.DestinationCreateEvent.decode(N, N.uint32());
            break;
          case 2:
            ie.update = a.DestinationUpdateEvent.decode(N, N.uint32());
            break;
          case 3:
            ie.delete = a.DestinationDeleteEvent.decode(N, N.uint32());
            break;
          case 4:
            ie.state = a.DestinationStateEvent.decode(N, N.uint32());
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        create: Le(b.create) ? a.DestinationCreateEvent.fromJSON(b.create) : void 0,
        update: Le(b.update) ? a.DestinationUpdateEvent.fromJSON(b.update) : void 0,
        delete: Le(b.delete) ? a.DestinationDeleteEvent.fromJSON(b.delete) : void 0,
        state: Le(b.state) ? a.DestinationStateEvent.fromJSON(b.state) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.create !== void 0 && (C.create = b.create ? a.DestinationCreateEvent.toJSON(b.create) : void 0), b.update !== void 0 && (C.update = b.update ? a.DestinationUpdateEvent.toJSON(b.update) : void 0), b.delete !== void 0 && (C.delete = b.delete ? a.DestinationDeleteEvent.toJSON(b.delete) : void 0), b.state !== void 0 && (C.state = b.state ? a.DestinationStateEvent.toJSON(b.state) : void 0), C;
    },
    fromPartial(b) {
      const C = li();
      return C.create = b.create !== void 0 && b.create !== null ? a.DestinationCreateEvent.fromPartial(b.create) : void 0, C.update = b.update !== void 0 && b.update !== null ? a.DestinationUpdateEvent.fromPartial(b.update) : void 0, C.delete = b.delete !== void 0 && b.delete !== null ? a.DestinationDeleteEvent.fromPartial(b.delete) : void 0, C.state = b.state !== void 0 && b.state !== null ? a.DestinationStateEvent.fromPartial(b.state) : void 0, C;
    }
  };
  function fi() {
    return { create: void 0, update: void 0, delete: void 0, state: void 0 };
  }
  a.ProjectEvent = {
    encode(b, C = c.default.Writer.create()) {
      return b.create !== void 0 && a.ProjectCreateEvent.encode(b.create, C.uint32(10).fork()).ldelim(), b.update !== void 0 && a.ProjectUpdateEvent.encode(b.update, C.uint32(18).fork()).ldelim(), b.delete !== void 0 && a.ProjectDeleteEvent.encode(b.delete, C.uint32(26).fork()).ldelim(), b.state !== void 0 && a.ProjectBroadcastStateEvent.encode(b.state, C.uint32(34).fork()).ldelim(), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = fi();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.create = a.ProjectCreateEvent.decode(N, N.uint32());
            break;
          case 2:
            ie.update = a.ProjectUpdateEvent.decode(N, N.uint32());
            break;
          case 3:
            ie.delete = a.ProjectDeleteEvent.decode(N, N.uint32());
            break;
          case 4:
            ie.state = a.ProjectBroadcastStateEvent.decode(N, N.uint32());
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        create: Le(b.create) ? a.ProjectCreateEvent.fromJSON(b.create) : void 0,
        update: Le(b.update) ? a.ProjectUpdateEvent.fromJSON(b.update) : void 0,
        delete: Le(b.delete) ? a.ProjectDeleteEvent.fromJSON(b.delete) : void 0,
        state: Le(b.state) ? a.ProjectBroadcastStateEvent.fromJSON(b.state) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.create !== void 0 && (C.create = b.create ? a.ProjectCreateEvent.toJSON(b.create) : void 0), b.update !== void 0 && (C.update = b.update ? a.ProjectUpdateEvent.toJSON(b.update) : void 0), b.delete !== void 0 && (C.delete = b.delete ? a.ProjectDeleteEvent.toJSON(b.delete) : void 0), b.state !== void 0 && (C.state = b.state ? a.ProjectBroadcastStateEvent.toJSON(b.state) : void 0), C;
    },
    fromPartial(b) {
      const C = fi();
      return C.create = b.create !== void 0 && b.create !== null ? a.ProjectCreateEvent.fromPartial(b.create) : void 0, C.update = b.update !== void 0 && b.update !== null ? a.ProjectUpdateEvent.fromPartial(b.update) : void 0, C.delete = b.delete !== void 0 && b.delete !== null ? a.ProjectDeleteEvent.fromPartial(b.delete) : void 0, C.state = b.state !== void 0 && b.state !== null ? a.ProjectBroadcastStateEvent.fromPartial(b.state) : void 0, C;
    }
  };
  function hi() {
    return {
      create: void 0,
      update: void 0,
      delete: void 0,
      add: void 0,
      remove: void 0,
      state: void 0
    };
  }
  a.SourceEvent = {
    encode(b, C = c.default.Writer.create()) {
      return b.create !== void 0 && a.SourceCreateEvent.encode(b.create, C.uint32(10).fork()).ldelim(), b.update !== void 0 && a.SourceUpdateEvent.encode(b.update, C.uint32(18).fork()).ldelim(), b.delete !== void 0 && a.SourceDeleteEvent.encode(b.delete, C.uint32(26).fork()).ldelim(), b.add !== void 0 && a.SourceAddEvent.encode(b.add, C.uint32(34).fork()).ldelim(), b.remove !== void 0 && a.SourceRemoveEvent.encode(b.remove, C.uint32(42).fork()).ldelim(), b.state !== void 0 && a.SourceStateEvent.encode(b.state, C.uint32(50).fork()).ldelim(), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = hi();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.create = a.SourceCreateEvent.decode(N, N.uint32());
            break;
          case 2:
            ie.update = a.SourceUpdateEvent.decode(N, N.uint32());
            break;
          case 3:
            ie.delete = a.SourceDeleteEvent.decode(N, N.uint32());
            break;
          case 4:
            ie.add = a.SourceAddEvent.decode(N, N.uint32());
            break;
          case 5:
            ie.remove = a.SourceRemoveEvent.decode(N, N.uint32());
            break;
          case 6:
            ie.state = a.SourceStateEvent.decode(N, N.uint32());
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        create: Le(b.create) ? a.SourceCreateEvent.fromJSON(b.create) : void 0,
        update: Le(b.update) ? a.SourceUpdateEvent.fromJSON(b.update) : void 0,
        delete: Le(b.delete) ? a.SourceDeleteEvent.fromJSON(b.delete) : void 0,
        add: Le(b.add) ? a.SourceAddEvent.fromJSON(b.add) : void 0,
        remove: Le(b.remove) ? a.SourceRemoveEvent.fromJSON(b.remove) : void 0,
        state: Le(b.state) ? a.SourceStateEvent.fromJSON(b.state) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.create !== void 0 && (C.create = b.create ? a.SourceCreateEvent.toJSON(b.create) : void 0), b.update !== void 0 && (C.update = b.update ? a.SourceUpdateEvent.toJSON(b.update) : void 0), b.delete !== void 0 && (C.delete = b.delete ? a.SourceDeleteEvent.toJSON(b.delete) : void 0), b.add !== void 0 && (C.add = b.add ? a.SourceAddEvent.toJSON(b.add) : void 0), b.remove !== void 0 && (C.remove = b.remove ? a.SourceRemoveEvent.toJSON(b.remove) : void 0), b.state !== void 0 && (C.state = b.state ? a.SourceStateEvent.toJSON(b.state) : void 0), C;
    },
    fromPartial(b) {
      const C = hi();
      return C.create = b.create !== void 0 && b.create !== null ? a.SourceCreateEvent.fromPartial(b.create) : void 0, C.update = b.update !== void 0 && b.update !== null ? a.SourceUpdateEvent.fromPartial(b.update) : void 0, C.delete = b.delete !== void 0 && b.delete !== null ? a.SourceDeleteEvent.fromPartial(b.delete) : void 0, C.add = b.add !== void 0 && b.add !== null ? a.SourceAddEvent.fromPartial(b.add) : void 0, C.remove = b.remove !== void 0 && b.remove !== null ? a.SourceRemoveEvent.fromPartial(b.remove) : void 0, C.state = b.state !== void 0 && b.state !== null ? a.SourceStateEvent.fromPartial(b.state) : void 0, C;
    }
  };
  function pi() {
    return {
      collection: void 0,
      destination: void 0,
      project: void 0,
      source: void 0,
      unspecified: void 0
    };
  }
  a.LiveEvent = {
    encode(b, C = c.default.Writer.create()) {
      return b.collection !== void 0 && a.CollectionEvent.encode(b.collection, C.uint32(10).fork()).ldelim(), b.destination !== void 0 && a.DestinationEvent.encode(b.destination, C.uint32(18).fork()).ldelim(), b.project !== void 0 && a.ProjectEvent.encode(b.project, C.uint32(26).fork()).ldelim(), b.source !== void 0 && a.SourceEvent.encode(b.source, C.uint32(34).fork()).ldelim(), b.unspecified !== void 0 && C.uint32(40).int32((0, p.nullValueToNumber)(b.unspecified)), C;
    },
    decode(b, C) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let _e = C === void 0 ? N.len : N.pos + C;
      const ie = pi();
      for (; N.pos < _e; ) {
        const Re = N.uint32();
        switch (Re >>> 3) {
          case 1:
            ie.collection = a.CollectionEvent.decode(N, N.uint32());
            break;
          case 2:
            ie.destination = a.DestinationEvent.decode(N, N.uint32());
            break;
          case 3:
            ie.project = a.ProjectEvent.decode(N, N.uint32());
            break;
          case 4:
            ie.source = a.SourceEvent.decode(N, N.uint32());
            break;
          case 5:
            ie.unspecified = (0, p.nullValueFromJSON)(N.int32());
            break;
          default:
            N.skipType(Re & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collection: Le(b.collection) ? a.CollectionEvent.fromJSON(b.collection) : void 0,
        destination: Le(b.destination) ? a.DestinationEvent.fromJSON(b.destination) : void 0,
        project: Le(b.project) ? a.ProjectEvent.fromJSON(b.project) : void 0,
        source: Le(b.source) ? a.SourceEvent.fromJSON(b.source) : void 0,
        unspecified: Le(b.unspecified) ? (0, p.nullValueFromJSON)(b.unspecified) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collection !== void 0 && (C.collection = b.collection ? a.CollectionEvent.toJSON(b.collection) : void 0), b.destination !== void 0 && (C.destination = b.destination ? a.DestinationEvent.toJSON(b.destination) : void 0), b.project !== void 0 && (C.project = b.project ? a.ProjectEvent.toJSON(b.project) : void 0), b.source !== void 0 && (C.source = b.source ? a.SourceEvent.toJSON(b.source) : void 0), b.unspecified !== void 0 && (C.unspecified = b.unspecified !== void 0 ? (0, p.nullValueToJSON)(b.unspecified) : void 0), C;
    },
    fromPartial(b) {
      var C;
      const N = pi();
      return N.collection = b.collection !== void 0 && b.collection !== null ? a.CollectionEvent.fromPartial(b.collection) : void 0, N.destination = b.destination !== void 0 && b.destination !== null ? a.DestinationEvent.fromPartial(b.destination) : void 0, N.project = b.project !== void 0 && b.project !== null ? a.ProjectEvent.fromPartial(b.project) : void 0, N.source = b.source !== void 0 && b.source !== null ? a.SourceEvent.fromPartial(b.source) : void 0, N.unspecified = (C = b.unspecified) !== null && C !== void 0 ? C : void 0, N;
    }
  };
  class vi {
    constructor(C, N) {
      this.service = (N == null ? void 0 : N.service) || "live.v21.AccountConfigurationService", this.rpc = C, this.GetAccountConfiguration = this.GetAccountConfiguration.bind(this), this.UpdateAccountConfiguration = this.UpdateAccountConfiguration.bind(this);
    }
    GetAccountConfiguration(C) {
      const N = a.GetAccountConfigurationRequest.encode(C).finish();
      return this.rpc.request(this.service, "GetAccountConfiguration", N).then((ie) => a.GetAccountConfigurationResponse.decode(new c.default.Reader(ie)));
    }
    UpdateAccountConfiguration(C) {
      const N = a.UpdateAccountConfigurationRequest.encode(C).finish();
      return this.rpc.request(this.service, "UpdateAccountConfiguration", N).then((ie) => a.UpdateAccountConfigurationResponse.decode(new c.default.Reader(ie)));
    }
  }
  a.AccountConfigurationServiceClientImpl = vi, a.AccountConfigurationServiceDefinition = {
    name: "AccountConfigurationService",
    fullName: "live.v21.AccountConfigurationService",
    methods: {
      /** get account configuration */
      getAccountConfiguration: {
        name: "GetAccountConfiguration",
        requestType: a.GetAccountConfigurationRequest,
        requestStream: !1,
        responseType: a.GetAccountConfigurationResponse,
        responseStream: !1,
        options: {}
      },
      /** update account configuration */
      updateAccountConfiguration: {
        name: "UpdateAccountConfiguration",
        requestType: a.UpdateAccountConfigurationRequest,
        requestStream: !1,
        responseType: a.UpdateAccountConfigurationResponse,
        responseStream: !1,
        options: {}
      }
    }
  };
  class yi {
    constructor(C, N) {
      this.service = (N == null ? void 0 : N.service) || "live.v21.CollectionService", this.rpc = C, this.CreateCollection = this.CreateCollection.bind(this), this.GetCollection = this.GetCollection.bind(this), this.GetCollections = this.GetCollections.bind(this), this.UpdateCollection = this.UpdateCollection.bind(this), this.DeleteCollection = this.DeleteCollection.bind(this);
    }
    CreateCollection(C) {
      const N = a.CreateCollectionRequest.encode(C).finish();
      return this.rpc.request(this.service, "CreateCollection", N).then((ie) => a.CreateCollectionResponse.decode(new c.default.Reader(ie)));
    }
    GetCollection(C) {
      const N = a.GetCollectionRequest.encode(C).finish();
      return this.rpc.request(this.service, "GetCollection", N).then((ie) => a.GetCollectionResponse.decode(new c.default.Reader(ie)));
    }
    GetCollections(C) {
      const N = a.GetCollectionsRequest.encode(C).finish();
      return this.rpc.request(this.service, "GetCollections", N).then((ie) => a.GetCollectionsResponse.decode(new c.default.Reader(ie)));
    }
    UpdateCollection(C) {
      const N = a.UpdateCollectionRequest.encode(C).finish();
      return this.rpc.request(this.service, "UpdateCollection", N).then((ie) => a.UpdateCollectionResponse.decode(new c.default.Reader(ie)));
    }
    DeleteCollection(C) {
      const N = a.DeleteCollectionRequest.encode(C).finish();
      return this.rpc.request(this.service, "DeleteCollection", N).then((ie) => a.DeleteCollectionResponse.decode(new c.default.Reader(ie)));
    }
  }
  a.CollectionServiceClientImpl = yi, a.CollectionServiceDefinition = {
    name: "CollectionService",
    fullName: "live.v21.CollectionService",
    methods: {
      /**
       * Create Collection
       *
       * Create a new collection of related projects and collection live sources
       */
      createCollection: {
        name: "CreateCollection",
        requestType: a.CreateCollectionRequest,
        requestStream: !1,
        responseType: a.CreateCollectionResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Get Collection
       *
       * Get an existing collection of related projects and collection live
       * sources
       */
      getCollection: {
        name: "GetCollection",
        requestType: a.GetCollectionRequest,
        requestStream: !1,
        responseType: a.GetCollectionResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Get Collections
       *
       * Get all collections owned by the user
       */
      getCollections: {
        name: "GetCollections",
        requestType: a.GetCollectionsRequest,
        requestStream: !1,
        responseType: a.GetCollectionsResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Update Collection
       *
       * Update select collection document data
       */
      updateCollection: {
        name: "UpdateCollection",
        requestType: a.UpdateCollectionRequest,
        requestStream: !1,
        responseType: a.UpdateCollectionResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Delete Collection
       *
       * Delete a collection of related projects and collection live sources
       */
      deleteCollection: {
        name: "DeleteCollection",
        requestType: a.DeleteCollectionRequest,
        requestStream: !1,
        responseType: a.DeleteCollectionResponse,
        responseStream: !1,
        options: {}
      }
    }
  };
  class gi {
    constructor(C, N) {
      this.service = (N == null ? void 0 : N.service) || "live.v21.ProjectService", this.rpc = C, this.CreateProject = this.CreateProject.bind(this), this.GetProject = this.GetProject.bind(this), this.DeleteProject = this.DeleteProject.bind(this), this.UpdateProject = this.UpdateProject.bind(this), this.StartProjectBroadcast = this.StartProjectBroadcast.bind(this), this.StopProjectBroadcast = this.StopProjectBroadcast.bind(this), this.StartProjectWebRtc = this.StartProjectWebRtc.bind(this), this.StopProjectWebRtc = this.StopProjectWebRtc.bind(this), this.GetProjectBroadcastSnapshot = this.GetProjectBroadcastSnapshot.bind(this), this.GetProjectBroadcastStatus = this.GetProjectBroadcastStatus.bind(this);
    }
    CreateProject(C) {
      const N = a.CreateProjectRequest.encode(C).finish();
      return this.rpc.request(this.service, "CreateProject", N).then((ie) => a.CreateProjectResponse.decode(new c.default.Reader(ie)));
    }
    GetProject(C) {
      const N = a.GetProjectRequest.encode(C).finish();
      return this.rpc.request(this.service, "GetProject", N).then((ie) => a.GetProjectResponse.decode(new c.default.Reader(ie)));
    }
    DeleteProject(C) {
      const N = a.DeleteProjectRequest.encode(C).finish();
      return this.rpc.request(this.service, "DeleteProject", N).then((ie) => a.DeleteProjectResponse.decode(new c.default.Reader(ie)));
    }
    UpdateProject(C) {
      const N = a.UpdateProjectRequest.encode(C).finish();
      return this.rpc.request(this.service, "UpdateProject", N).then((ie) => a.UpdateProjectResponse.decode(new c.default.Reader(ie)));
    }
    StartProjectBroadcast(C) {
      const N = a.StartProjectBroadcastRequest.encode(C).finish();
      return this.rpc.request(this.service, "StartProjectBroadcast", N).then((ie) => a.StartProjectBroadcastResponse.decode(new c.default.Reader(ie)));
    }
    StopProjectBroadcast(C) {
      const N = a.StopProjectBroadcastRequest.encode(C).finish();
      return this.rpc.request(this.service, "StopProjectBroadcast", N).then((ie) => a.StopProjectBroadcastResponse.decode(new c.default.Reader(ie)));
    }
    StartProjectWebRtc(C) {
      const N = a.StartProjectWebRtcRequest.encode(C).finish();
      return this.rpc.request(this.service, "StartProjectWebRtc", N).then((ie) => a.StartProjectWebRtcResponse.decode(new c.default.Reader(ie)));
    }
    StopProjectWebRtc(C) {
      const N = a.StopProjectWebRtcRequest.encode(C).finish();
      return this.rpc.request(this.service, "StopProjectWebRtc", N).then((ie) => a.StopProjectWebRtcResponse.decode(new c.default.Reader(ie)));
    }
    GetProjectBroadcastSnapshot(C) {
      const N = a.GetProjectBroadcastSnapshotRequest.encode(C).finish();
      return this.rpc.request(this.service, "GetProjectBroadcastSnapshot", N).then((ie) => a.GetProjectBroadcastSnapshotResponse.decode(new c.default.Reader(ie)));
    }
    GetProjectBroadcastStatus(C) {
      const N = a.GetProjectBroadcastStatusRequest.encode(C).finish();
      return this.rpc.request(this.service, "GetProjectBroadcastStatus", N).then((ie) => a.GetProjectBroadcastStatusResponse.decode(new c.default.Reader(ie)));
    }
  }
  a.ProjectServiceClientImpl = gi, a.ProjectServiceDefinition = {
    name: "ProjectService",
    fullName: "live.v21.ProjectService",
    methods: {
      /**
       * Create Project
       *
       * Create a new project
       */
      createProject: {
        name: "CreateProject",
        requestType: a.CreateProjectRequest,
        requestStream: !1,
        responseType: a.CreateProjectResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Get Project
       *
       * Get an existing project
       */
      getProject: {
        name: "GetProject",
        requestType: a.GetProjectRequest,
        requestStream: !1,
        responseType: a.GetProjectResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Delete Project
       *
       * Delete a project
       */
      deleteProject: {
        name: "DeleteProject",
        requestType: a.DeleteProjectRequest,
        requestStream: !1,
        responseType: a.DeleteProjectResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Update Project
       *
       * Updates a project
       */
      updateProject: {
        name: "UpdateProject",
        requestType: a.UpdateProjectRequest,
        requestStream: !1,
        responseType: a.UpdateProjectResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Start Broadcast
       *
       * Start broadcasting a project
       */
      startProjectBroadcast: {
        name: "StartProjectBroadcast",
        requestType: a.StartProjectBroadcastRequest,
        requestStream: !1,
        responseType: a.StartProjectBroadcastResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Stop Broadcast
       *
       * Stop broadcasting a project
       */
      stopProjectBroadcast: {
        name: "StopProjectBroadcast",
        requestType: a.StopProjectBroadcastRequest,
        requestStream: !1,
        responseType: a.StopProjectBroadcastResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Start WebRTC
       *
       * Start WebRTC services
       */
      startProjectWebRtc: {
        name: "StartProjectWebRtc",
        requestType: a.StartProjectWebRtcRequest,
        requestStream: !1,
        responseType: a.StartProjectWebRtcResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Stop WebRTC
       *
       * Stop WebRTC services
       */
      stopProjectWebRtc: {
        name: "StopProjectWebRtc",
        requestType: a.StopProjectWebRtcRequest,
        requestStream: !1,
        responseType: a.StopProjectWebRtcResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Get Snapshot
       *
       * Get a snapshot of the current output frame of the broadcast
       */
      getProjectBroadcastSnapshot: {
        name: "GetProjectBroadcastSnapshot",
        requestType: a.GetProjectBroadcastSnapshotRequest,
        requestStream: !1,
        responseType: a.GetProjectBroadcastSnapshotResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Get Broadcast Status
       *
       * Get the broadcast status of the project
       */
      getProjectBroadcastStatus: {
        name: "GetProjectBroadcastStatus",
        requestType: a.GetProjectBroadcastStatusRequest,
        requestStream: !1,
        responseType: a.GetProjectBroadcastStatusResponse,
        responseStream: !1,
        options: {}
      }
    }
  };
  class bi {
    constructor(C, N) {
      this.service = (N == null ? void 0 : N.service) || "live.v21.DestinationService", this.rpc = C, this.CreateDestination = this.CreateDestination.bind(this), this.GetDestination = this.GetDestination.bind(this), this.UpdateDestination = this.UpdateDestination.bind(this), this.DeleteDestination = this.DeleteDestination.bind(this);
    }
    CreateDestination(C) {
      const N = a.CreateDestinationRequest.encode(C).finish();
      return this.rpc.request(this.service, "CreateDestination", N).then((ie) => a.CreateDestinationResponse.decode(new c.default.Reader(ie)));
    }
    GetDestination(C) {
      const N = a.GetDestinationRequest.encode(C).finish();
      return this.rpc.request(this.service, "GetDestination", N).then((ie) => a.GetDestinationResponse.decode(new c.default.Reader(ie)));
    }
    UpdateDestination(C) {
      const N = a.UpdateDestinationRequest.encode(C).finish();
      return this.rpc.request(this.service, "UpdateDestination", N).then((ie) => a.UpdateDestinationResponse.decode(new c.default.Reader(ie)));
    }
    DeleteDestination(C) {
      const N = a.DeleteDestinationRequest.encode(C).finish();
      return this.rpc.request(this.service, "DeleteDestination", N).then((ie) => a.DeleteDestinationResponse.decode(new c.default.Reader(ie)));
    }
  }
  a.DestinationServiceClientImpl = bi, a.DestinationServiceDefinition = {
    name: "DestinationService",
    fullName: "live.v21.DestinationService",
    methods: {
      /**
       * Create Destination
       *
       * Create a new Destination
       */
      createDestination: {
        name: "CreateDestination",
        requestType: a.CreateDestinationRequest,
        requestStream: !1,
        responseType: a.CreateDestinationResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Get Destination
       *
       * Get an existing Destination.
       */
      getDestination: {
        name: "GetDestination",
        requestType: a.GetDestinationRequest,
        requestStream: !1,
        responseType: a.GetDestinationResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Update Destination
       *
       * Update a destination
       */
      updateDestination: {
        name: "UpdateDestination",
        requestType: a.UpdateDestinationRequest,
        requestStream: !1,
        responseType: a.UpdateDestinationResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Delete Destination
       *
       * Delete a destination
       */
      deleteDestination: {
        name: "DeleteDestination",
        requestType: a.DeleteDestinationRequest,
        requestStream: !1,
        responseType: a.DeleteDestinationResponse,
        responseStream: !1,
        options: {}
      }
    }
  };
  class Si {
    constructor(C, N) {
      this.service = (N == null ? void 0 : N.service) || "live.v21.SourceService", this.rpc = C, this.CreateSource = this.CreateSource.bind(this), this.DeleteSource = this.DeleteSource.bind(this), this.UpdateSource = this.UpdateSource.bind(this), this.UpdateSourceInProject = this.UpdateSourceInProject.bind(this), this.GetSource = this.GetSource.bind(this), this.GetSources = this.GetSources.bind(this), this.AddSourceToProject = this.AddSourceToProject.bind(this), this.RemoveSourceFromProject = this.RemoveSourceFromProject.bind(this), this.GetSourcePlaylist = this.GetSourcePlaylist.bind(this);
    }
    CreateSource(C) {
      const N = a.CreateSourceRequest.encode(C).finish();
      return this.rpc.request(this.service, "CreateSource", N).then((ie) => a.CreateSourceResponse.decode(new c.default.Reader(ie)));
    }
    DeleteSource(C) {
      const N = a.DeleteSourceRequest.encode(C).finish();
      return this.rpc.request(this.service, "DeleteSource", N).then((ie) => a.DeleteSourceResponse.decode(new c.default.Reader(ie)));
    }
    UpdateSource(C) {
      const N = a.UpdateSourceRequest.encode(C).finish();
      return this.rpc.request(this.service, "UpdateSource", N).then((ie) => a.UpdateSourceResponse.decode(new c.default.Reader(ie)));
    }
    UpdateSourceInProject(C) {
      const N = a.UpdateSourceInProjectRequest.encode(C).finish();
      return this.rpc.request(this.service, "UpdateSourceInProject", N).then((ie) => a.UpdateSourceInProjectResponse.decode(new c.default.Reader(ie)));
    }
    GetSource(C) {
      const N = a.GetSourceRequest.encode(C).finish();
      return this.rpc.request(this.service, "GetSource", N).then((ie) => a.GetSourceResponse.decode(new c.default.Reader(ie)));
    }
    GetSources(C) {
      const N = a.GetSourcesRequest.encode(C).finish();
      return this.rpc.request(this.service, "GetSources", N).then((ie) => a.GetSourcesResponse.decode(new c.default.Reader(ie)));
    }
    AddSourceToProject(C) {
      const N = a.AddSourceToProjectRequest.encode(C).finish();
      return this.rpc.request(this.service, "AddSourceToProject", N).then((ie) => a.AddSourceToProjectResponse.decode(new c.default.Reader(ie)));
    }
    RemoveSourceFromProject(C) {
      const N = a.RemoveSourceFromProjectRequest.encode(C).finish();
      return this.rpc.request(this.service, "RemoveSourceFromProject", N).then((ie) => a.RemoveSourceFromProjectResponse.decode(new c.default.Reader(ie)));
    }
    GetSourcePlaylist(C) {
      const N = a.GetSourcePlaylistRequest.encode(C).finish();
      return this.rpc.request(this.service, "GetSourcePlaylist", N).then((ie) => l.HttpBody.decode(new c.default.Reader(ie)));
    }
  }
  a.SourceServiceClientImpl = Si, a.SourceServiceDefinition = {
    name: "SourceService",
    fullName: "live.v21.SourceService",
    methods: {
      /**
       * Create Collection Live Source
       *
       * Create a new live source in a collection
       * ### Permissions
       * * scope: `SCOPE_VAPI_CREATE`
       */
      createSource: {
        name: "CreateSource",
        requestType: a.CreateSourceRequest,
        requestStream: !1,
        responseType: a.CreateSourceResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Delete Live Source
       *
       * Deletes a live source from a collection
       */
      deleteSource: {
        name: "DeleteSource",
        requestType: a.DeleteSourceRequest,
        requestStream: !1,
        responseType: a.DeleteSourceResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Update Source
       *
       * Update attributes of the Source.
       */
      updateSource: {
        name: "UpdateSource",
        requestType: a.UpdateSourceRequest,
        requestStream: !1,
        responseType: a.UpdateSourceResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Update Source
       *
       * Update attributes of the Source.
       */
      updateSourceInProject: {
        name: "UpdateSourceInProject",
        requestType: a.UpdateSourceInProjectRequest,
        requestStream: !1,
        responseType: a.UpdateSourceInProjectResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Get Source
       *
       * Get an existing source in a project
       */
      getSource: {
        name: "GetSource",
        requestType: a.GetSourceRequest,
        requestStream: !1,
        responseType: a.GetSourceResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Get Source
       *
       * Get existing sources in a collection
       */
      getSources: {
        name: "GetSources",
        requestType: a.GetSourcesRequest,
        requestStream: !1,
        responseType: a.GetSourcesResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Add Source to Project
       *
       * Add a source to a project
       */
      addSourceToProject: {
        name: "AddSourceToProject",
        requestType: a.AddSourceToProjectRequest,
        requestStream: !1,
        responseType: a.AddSourceToProjectResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Delete Source From Project
       *
       * Removes a source from a project.
       */
      removeSourceFromProject: {
        name: "RemoveSourceFromProject",
        requestType: a.RemoveSourceFromProjectRequest,
        requestStream: !1,
        responseType: a.RemoveSourceFromProjectResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Get the HLS playlist for a source.
       * buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
       */
      getSourcePlaylist: {
        name: "GetSourcePlaylist",
        requestType: a.GetSourcePlaylistRequest,
        requestStream: !1,
        responseType: l.HttpBody,
        responseStream: !1,
        options: {}
      }
    }
  };
  class _i {
    constructor(C, N) {
      this.service = (N == null ? void 0 : N.service) || "live.v21.BackendAuthenticationService", this.rpc = C, this.CreateAccessToken = this.CreateAccessToken.bind(this);
    }
    CreateAccessToken(C) {
      const N = a.CreateAccessTokenRequest.encode(C).finish();
      return this.rpc.request(this.service, "CreateAccessToken", N).then((ie) => a.CreateAccessTokenResponse.decode(new c.default.Reader(ie)));
    }
  }
  a.BackendAuthenticationServiceClientImpl = _i, a.BackendAuthenticationServiceDefinition = {
    name: "BackendAuthenticationService",
    fullName: "live.v21.BackendAuthenticationService",
    methods: {
      /**
       * Create Access Token
       *
       * Create an access token for a session host
       */
      createAccessToken: {
        name: "CreateAccessToken",
        requestType: a.CreateAccessTokenRequest,
        requestStream: !1,
        responseType: a.CreateAccessTokenResponse,
        responseStream: !1,
        options: {}
      }
    }
  };
  class Ei {
    constructor(C, N) {
      this.service = (N == null ? void 0 : N.service) || "live.v21.AuthenticationService", this.rpc = C, this.CreateGuestAccessToken = this.CreateGuestAccessToken.bind(this), this.RefreshAccessToken = this.RefreshAccessToken.bind(this), this.CreateWebRtcAccessToken = this.CreateWebRtcAccessToken.bind(this);
    }
    CreateGuestAccessToken(C) {
      const N = a.CreateGuestAccessTokenRequest.encode(C).finish();
      return this.rpc.request(this.service, "CreateGuestAccessToken", N).then((ie) => a.CreateGuestAccessTokenResponse.decode(new c.default.Reader(ie)));
    }
    RefreshAccessToken(C) {
      const N = a.RefreshAccessTokenRequest.encode(C).finish();
      return this.rpc.request(this.service, "RefreshAccessToken", N).then((ie) => a.RefreshAccessTokenResponse.decode(new c.default.Reader(ie)));
    }
    CreateWebRtcAccessToken(C) {
      const N = a.CreateWebRtcAccessTokenRequest.encode(C).finish();
      return this.rpc.request(this.service, "CreateWebRtcAccessToken", N).then((ie) => a.CreateWebRtcAccessTokenResponse.decode(new c.default.Reader(ie)));
    }
  }
  a.AuthenticationServiceClientImpl = Ei, a.AuthenticationServiceDefinition = {
    name: "AuthenticationService",
    fullName: "live.v21.AuthenticationService",
    methods: {
      /**
       * Create Guest Access Token
       *
       * Create an access token for a guest
       */
      createGuestAccessToken: {
        name: "CreateGuestAccessToken",
        requestType: a.CreateGuestAccessTokenRequest,
        requestStream: !1,
        responseType: a.CreateGuestAccessTokenResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Refresh Access Token
       *
       * Forcibly refresh an access token prior to expiration
       */
      refreshAccessToken: {
        name: "RefreshAccessToken",
        requestType: a.RefreshAccessTokenRequest,
        requestStream: !1,
        responseType: a.RefreshAccessTokenResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Create WebRTC Access Token
       *
       * Create a WebRTC Access Token
       */
      createWebRtcAccessToken: {
        name: "CreateWebRtcAccessToken",
        requestType: a.CreateWebRtcAccessTokenRequest,
        requestStream: !1,
        responseType: a.CreateWebRtcAccessTokenResponse,
        responseStream: !1,
        options: {}
      }
    }
  };
  class Ti {
    constructor(C, N) {
      this.service = (N == null ? void 0 : N.service) || "live.v21.PublicAuthenticationService", this.rpc = C, this.GetJsonWebKeySet = this.GetJsonWebKeySet.bind(this), this.GuestCodeRedirect = this.GuestCodeRedirect.bind(this);
    }
    GetJsonWebKeySet(C) {
      const N = a.GetJsonWebKeySetRequest.encode(C).finish();
      return this.rpc.request(this.service, "GetJsonWebKeySet", N).then((ie) => a.GetJsonWebKeySetResponse.decode(new c.default.Reader(ie)));
    }
    GuestCodeRedirect(C) {
      const N = a.GuestCodeRedirectRequest.encode(C).finish();
      return this.rpc.request(this.service, "GuestCodeRedirect", N).then((ie) => a.GuestCodeRedirectResponse.decode(new c.default.Reader(ie)));
    }
  }
  a.PublicAuthenticationServiceClientImpl = Ti, a.PublicAuthenticationServiceDefinition = {
    name: "PublicAuthenticationService",
    fullName: "live.v21.PublicAuthenticationService",
    methods: {
      /**
       * Get Public Keys
       *
       * Get public keys used to sign access tokens
       */
      getJsonWebKeySet: {
        name: "GetJsonWebKeySet",
        requestType: a.GetJsonWebKeySetRequest,
        requestStream: !1,
        responseType: a.GetJsonWebKeySetResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Exchange Guest Access Token
       *
       * Exchange a guest access token with updated user identifiers
       */
      guestCodeRedirect: {
        name: "GuestCodeRedirect",
        requestType: a.GuestCodeRedirectRequest,
        requestStream: !1,
        responseType: a.GuestCodeRedirectResponse,
        responseStream: !1,
        options: {}
      }
    }
  };
  var _t = (() => {
    if (typeof _t < "u")
      return _t;
    if (typeof self < "u")
      return self;
    if (typeof window < "u")
      return window;
    if (typeof commonjsGlobal$1 < "u")
      return commonjsGlobal$1;
    throw "Unable to locate global object";
  })();
  function wi(b) {
    if (_t.Buffer)
      return Uint8Array.from(_t.Buffer.from(b, "base64"));
    {
      const C = _t.atob(b), N = new Uint8Array(C.length);
      for (let _e = 0; _e < C.length; ++_e)
        N[_e] = C.charCodeAt(_e);
      return N;
    }
  }
  function ki(b) {
    if (_t.Buffer)
      return _t.Buffer.from(b).toString("base64");
    {
      const C = [];
      return b.forEach((N) => {
        C.push(String.fromCharCode(N));
      }), _t.btoa(C.join(""));
    }
  }
  function Ht(b) {
    const C = new Date(b), N = C.getTime() / 1e3, _e = C.getTime() % 1e3 * 1e6;
    return { seconds: N, nanos: _e };
  }
  function zt(b) {
    let C = b.seconds * 1e3;
    return C += b.nanos / 1e6, new Date(C).toISOString();
  }
  function Ii(b) {
    return typeof b == "object" && b !== null;
  }
  function Le(b) {
    return b != null;
  }
})(api$2);
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(Z, ee, X, ne) {
    ne === void 0 && (ne = X);
    var Q = Object.getOwnPropertyDescriptor(ee, X);
    (!Q || ("get" in Q ? !ee.__esModule : Q.writable || Q.configurable)) && (Q = { enumerable: !0, get: function() {
      return ee[X];
    } }), Object.defineProperty(Z, ne, Q);
  } : function(Z, ee, X, ne) {
    ne === void 0 && (ne = X), Z[ne] = ee[X];
  }), c = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(Z, ee) {
    Object.defineProperty(Z, "default", { enumerable: !0, value: ee });
  } : function(Z, ee) {
    Z.default = ee;
  }), l = commonjsGlobal$1 && commonjsGlobal$1.__decorate || function(Z, ee, X, ne) {
    var Q = arguments.length, ae = Q < 3 ? ee : ne === null ? ne = Object.getOwnPropertyDescriptor(ee, X) : ne, j;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      ae = Reflect.decorate(Z, ee, X, ne);
    else
      for (var ue = Z.length - 1; ue >= 0; ue--)
        (j = Z[ue]) && (ae = (Q < 3 ? j(ae) : Q > 3 ? j(ee, X, ae) : j(ee, X)) || ae);
    return Q > 3 && ae && Object.defineProperty(ee, X, ae), ae;
  }, v = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(Z) {
    if (Z && Z.__esModule)
      return Z;
    var ee = {};
    if (Z != null)
      for (var X in Z)
        X !== "default" && Object.prototype.hasOwnProperty.call(Z, X) && u(ee, Z, X);
    return c(ee, Z), ee;
  }, p = commonjsGlobal$1 && commonjsGlobal$1.__metadata || function(Z, ee) {
    if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
      return Reflect.metadata(Z, ee);
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.LiveApi = void 0;
  const _ = v(lib$1), k = api$3, O = v(api$2), D = decorator, F = "LiveApi";
  class H extends k.ApiClient {
    constructor(ee, X, ne, Q, ae, j, ue) {
      super(ee, ne, j, F, ue), this.handlers = {}, this.eventApi = X, this.accessTokenRefreshCallback = Q, this.publicAuthentication = this.clientFactory.create(O.PublicAuthenticationServiceDefinition, this.channel), ae != null && (this.backendAuthentication = this.clientFactory.create(O.BackendAuthenticationServiceDefinition, this.channel, {
        "*": { metadata: _.Metadata({ "X-Api-Key": ae }) }
      }), this.accountConfiguration = this.clientFactory.create(O.AccountConfigurationServiceDefinition, this.channel, {
        "*": { metadata: _.Metadata({ "X-Api-Key": ae }) }
      })), this.eventApi.on("event", { name: `${H.LIVEAPI_EVENT_PREFIX}:*`, ignoreSessionEvents: !0, allowedSessionEvents: [`${H.LIVEAPI_EVENT_PREFIX}:EVENT_TYPE_PROJECT:EVENT_SUB_TYPE_STATE`] }, this.eventCallback.bind(this));
    }
    /**
    * Register an event handler
    *
    * @param type Type of event
    * @param handler
    */
    on(ee, X) {
      var ne;
      this.handlers[ee] = (ne = this.handlers[ee]) !== null && ne !== void 0 ? ne : [], this.handlers[ee].push(X);
    }
    /**
     * Unregister an event handler
     *
     * @param type Type of event
     * @param handler
     */
    off(ee, X) {
      this.handlers[ee] = this.handlers[ee].filter((ne) => ne !== X);
    }
    emitToHandlers(ee, X, ne) {
      var Q;
      for (const ae of (Q = this.handlers[ee]) !== null && Q !== void 0 ? Q : [])
        ae(Object.values(ne).find((j) => !!j), X);
    }
    async subscribeToCollection(ee) {
      await this.eventApi.subscribe(`${H.LIVEAPI_EVENT_PREFIX}:*`, { target: { collectionId: ee } });
    }
    async unsubscribeFromCollection(ee) {
      await this.eventApi.unsubscribe(`${H.LIVEAPI_EVENT_PREFIX}:*`, { target: { collectionId: ee } });
    }
    async subscribeToProject(ee, X) {
      await this.eventApi.subscribe(`${H.LIVEAPI_EVENT_PREFIX}:*`, { target: { collectionId: ee, projectId: X } });
    }
    async unsubscribeFromProject(ee, X) {
      await this.eventApi.unsubscribe(`${H.LIVEAPI_EVENT_PREFIX}:*`, { target: { collectionId: ee, projectId: X } });
    }
    eventCallback(ee) {
      let ne = ee.name.split(`${H.LIVEAPI_EVENT_PREFIX}:`)[1].split(":"), Q = O.eventTypeFromJSON(ne[0]), ae = O.eventSubTypeFromJSON(ne[1]);
      this.log.info("processing event: " + Q + "/" + ae), H.liveApiEventMap[Q] && this.emitToHandlers(Q, ae, ee.payload);
    }
    _setup(ee) {
      let X = this;
      ee.onHeader = function(ne) {
        let Q = ne.get("Authorization");
        if (Q != null) {
          const ae = Q.split(" ");
          if (ae.length == 2 && ae[0] == "Bearer") {
            let j = ae[1];
            X.log.info("received refresh token"), X.accessTokenRefreshCallback(j);
          }
        }
      }, this.collection = this.clientFactory.create(O.CollectionServiceDefinition, this.channel, {
        "*": ee
      }), this.project = this.clientFactory.create(O.ProjectServiceDefinition, this.channel, {
        "*": ee
      }), this.source = this.clientFactory.create(O.SourceServiceDefinition, this.channel, {
        "*": ee
      }), this.destination = this.clientFactory.create(O.DestinationServiceDefinition, this.channel, {
        "*": ee
      }), this.authentication = this.clientFactory.create(O.AuthenticationServiceDefinition, this.channel, {
        "*": ee
      });
    }
  }
  H.LIVEAPI_EVENT_PREFIX = "apistream:live", l([
    (0, D.RequiresSdkAuthentication)(),
    p("design:type", Object)
  ], H.prototype, "collection", void 0), l([
    (0, D.RequiresSdkAuthentication)(),
    p("design:type", Object)
  ], H.prototype, "project", void 0), l([
    (0, D.RequiresSdkAuthentication)(),
    p("design:type", Object)
  ], H.prototype, "source", void 0), l([
    (0, D.RequiresSdkAuthentication)(),
    p("design:type", Object)
  ], H.prototype, "destination", void 0), l([
    (0, D.RequiresSdkAuthentication)(),
    p("design:type", Object)
  ], H.prototype, "authentication", void 0), a.LiveApi = H, function(Z) {
    Z.liveApiEventMap = {
      [O.EventType.EVENT_TYPE_COLLECTION]: "collection",
      [O.EventType.EVENT_TYPE_PROJECT]: "project",
      [O.EventType.EVENT_TYPE_SOURCE]: "source",
      [O.EventType.EVENT_TYPE_DESTINATION]: "destination",
      [O.EventType.EVENT_TYPE_UNSPECIFIED]: "unspecified"
    };
  }(H = a.LiveApi || (a.LiveApi = {}));
})(liveapi);
var eventapi = {}, dist$1 = {}, api$1 = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(a, u) {
  return extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(c, l) {
    c.__proto__ = l;
  } || function(c, l) {
    for (var v in l)
      l.hasOwnProperty(v) && (c[v] = l[v]);
  }, extendStatics(a, u);
};
function __extends(a, u) {
  extendStatics(a, u);
  function c() {
    this.constructor = a;
  }
  a.prototype = u === null ? Object.create(u) : (c.prototype = u.prototype, new c());
}
function isFunction$3(a) {
  return typeof a == "function";
}
var _enable_super_gross_mode_that_will_cause_bad_things = !1, config$3 = {
  Promise: void 0,
  set useDeprecatedSynchronousErrorHandling(a) {
    if (a) {
      var u = /* @__PURE__ */ new Error();
      "" + u.stack;
    }
    _enable_super_gross_mode_that_will_cause_bad_things = a;
  },
  get useDeprecatedSynchronousErrorHandling() {
    return _enable_super_gross_mode_that_will_cause_bad_things;
  }
};
function hostReportError(a) {
  setTimeout(function() {
    throw a;
  }, 0);
}
var empty$3 = {
  closed: !0,
  next: function(a) {
  },
  error: function(a) {
    if (config$3.useDeprecatedSynchronousErrorHandling)
      throw a;
    hostReportError(a);
  },
  complete: function() {
  }
}, isArray$5 = /* @__PURE__ */ function() {
  return Array.isArray || function(a) {
    return a && typeof a.length == "number";
  };
}();
function isObject$9(a) {
  return a !== null && typeof a == "object";
}
var UnsubscriptionErrorImpl = /* @__PURE__ */ function() {
  function a(u) {
    return Error.call(this), this.message = u ? u.length + ` errors occurred during unsubscription:
` + u.map(function(c, l) {
      return l + 1 + ") " + c.toString();
    }).join(`
  `) : "", this.name = "UnsubscriptionError", this.errors = u, this;
  }
  return a.prototype = /* @__PURE__ */ Object.create(Error.prototype), a;
}(), UnsubscriptionError = UnsubscriptionErrorImpl, Subscription = /* @__PURE__ */ function() {
  function a(u) {
    this.closed = !1, this._parentOrParents = null, this._subscriptions = null, u && (this._ctorUnsubscribe = !0, this._unsubscribe = u);
  }
  return a.prototype.unsubscribe = function() {
    var u;
    if (!this.closed) {
      var c = this, l = c._parentOrParents, v = c._ctorUnsubscribe, p = c._unsubscribe, _ = c._subscriptions;
      if (this.closed = !0, this._parentOrParents = null, this._subscriptions = null, l instanceof a)
        l.remove(this);
      else if (l !== null)
        for (var k = 0; k < l.length; ++k) {
          var O = l[k];
          O.remove(this);
        }
      if (isFunction$3(p)) {
        v && (this._unsubscribe = void 0);
        try {
          p.call(this);
        } catch (H) {
          u = H instanceof UnsubscriptionError ? flattenUnsubscriptionErrors(H.errors) : [H];
        }
      }
      if (isArray$5(_))
        for (var k = -1, D = _.length; ++k < D; ) {
          var F = _[k];
          if (isObject$9(F))
            try {
              F.unsubscribe();
            } catch (Z) {
              u = u || [], Z instanceof UnsubscriptionError ? u = u.concat(flattenUnsubscriptionErrors(Z.errors)) : u.push(Z);
            }
        }
      if (u)
        throw new UnsubscriptionError(u);
    }
  }, a.prototype.add = function(u) {
    var c = u;
    if (!u)
      return a.EMPTY;
    switch (typeof u) {
      case "function":
        c = new a(u);
      case "object":
        if (c === this || c.closed || typeof c.unsubscribe != "function")
          return c;
        if (this.closed)
          return c.unsubscribe(), c;
        if (!(c instanceof a)) {
          var l = c;
          c = new a(), c._subscriptions = [l];
        }
        break;
      default:
        throw new Error("unrecognized teardown " + u + " added to Subscription.");
    }
    var v = c._parentOrParents;
    if (v === null)
      c._parentOrParents = this;
    else if (v instanceof a) {
      if (v === this)
        return c;
      c._parentOrParents = [v, this];
    } else if (v.indexOf(this) === -1)
      v.push(this);
    else
      return c;
    var p = this._subscriptions;
    return p === null ? this._subscriptions = [c] : p.push(c), c;
  }, a.prototype.remove = function(u) {
    var c = this._subscriptions;
    if (c) {
      var l = c.indexOf(u);
      l !== -1 && c.splice(l, 1);
    }
  }, a.EMPTY = function(u) {
    return u.closed = !0, u;
  }(new a()), a;
}();
function flattenUnsubscriptionErrors(a) {
  return a.reduce(function(u, c) {
    return u.concat(c instanceof UnsubscriptionError ? c.errors : c);
  }, []);
}
var rxSubscriber = /* @__PURE__ */ function() {
  return typeof Symbol == "function" ? /* @__PURE__ */ Symbol("rxSubscriber") : "@@rxSubscriber_" + /* @__PURE__ */ Math.random();
}(), Subscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this) || this;
    switch (p.syncErrorValue = null, p.syncErrorThrown = !1, p.syncErrorThrowable = !1, p.isStopped = !1, arguments.length) {
      case 0:
        p.destination = empty$3;
        break;
      case 1:
        if (!c) {
          p.destination = empty$3;
          break;
        }
        if (typeof c == "object") {
          c instanceof u ? (p.syncErrorThrowable = c.syncErrorThrowable, p.destination = c, c.add(p)) : (p.syncErrorThrowable = !0, p.destination = new SafeSubscriber(p, c));
          break;
        }
      default:
        p.syncErrorThrowable = !0, p.destination = new SafeSubscriber(p, c, l, v);
        break;
    }
    return p;
  }
  return u.prototype[rxSubscriber] = function() {
    return this;
  }, u.create = function(c, l, v) {
    var p = new u(c, l, v);
    return p.syncErrorThrowable = !1, p;
  }, u.prototype.next = function(c) {
    this.isStopped || this._next(c);
  }, u.prototype.error = function(c) {
    this.isStopped || (this.isStopped = !0, this._error(c));
  }, u.prototype.complete = function() {
    this.isStopped || (this.isStopped = !0, this._complete());
  }, u.prototype.unsubscribe = function() {
    this.closed || (this.isStopped = !0, a.prototype.unsubscribe.call(this));
  }, u.prototype._next = function(c) {
    this.destination.next(c);
  }, u.prototype._error = function(c) {
    this.destination.error(c), this.unsubscribe();
  }, u.prototype._complete = function() {
    this.destination.complete(), this.unsubscribe();
  }, u.prototype._unsubscribeAndRecycle = function() {
    var c = this._parentOrParents;
    return this._parentOrParents = null, this.unsubscribe(), this.closed = !1, this.isStopped = !1, this._parentOrParents = c, this;
  }, u;
}(Subscription), SafeSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v, p) {
    var _ = a.call(this) || this;
    _._parentSubscriber = c;
    var k, O = _;
    return isFunction$3(l) ? k = l : l && (k = l.next, v = l.error, p = l.complete, l !== empty$3 && (O = Object.create(l), isFunction$3(O.unsubscribe) && _.add(O.unsubscribe.bind(O)), O.unsubscribe = _.unsubscribe.bind(_))), _._context = O, _._next = k, _._error = v, _._complete = p, _;
  }
  return u.prototype.next = function(c) {
    if (!this.isStopped && this._next) {
      var l = this._parentSubscriber;
      !config$3.useDeprecatedSynchronousErrorHandling || !l.syncErrorThrowable ? this.__tryOrUnsub(this._next, c) : this.__tryOrSetError(l, this._next, c) && this.unsubscribe();
    }
  }, u.prototype.error = function(c) {
    if (!this.isStopped) {
      var l = this._parentSubscriber, v = config$3.useDeprecatedSynchronousErrorHandling;
      if (this._error)
        !v || !l.syncErrorThrowable ? (this.__tryOrUnsub(this._error, c), this.unsubscribe()) : (this.__tryOrSetError(l, this._error, c), this.unsubscribe());
      else if (l.syncErrorThrowable)
        v ? (l.syncErrorValue = c, l.syncErrorThrown = !0) : hostReportError(c), this.unsubscribe();
      else {
        if (this.unsubscribe(), v)
          throw c;
        hostReportError(c);
      }
    }
  }, u.prototype.complete = function() {
    var c = this;
    if (!this.isStopped) {
      var l = this._parentSubscriber;
      if (this._complete) {
        var v = function() {
          return c._complete.call(c._context);
        };
        !config$3.useDeprecatedSynchronousErrorHandling || !l.syncErrorThrowable ? (this.__tryOrUnsub(v), this.unsubscribe()) : (this.__tryOrSetError(l, v), this.unsubscribe());
      } else
        this.unsubscribe();
    }
  }, u.prototype.__tryOrUnsub = function(c, l) {
    try {
      c.call(this._context, l);
    } catch (v) {
      if (this.unsubscribe(), config$3.useDeprecatedSynchronousErrorHandling)
        throw v;
      hostReportError(v);
    }
  }, u.prototype.__tryOrSetError = function(c, l, v) {
    if (!config$3.useDeprecatedSynchronousErrorHandling)
      throw new Error("bad call");
    try {
      l.call(this._context, v);
    } catch (p) {
      return config$3.useDeprecatedSynchronousErrorHandling ? (c.syncErrorValue = p, c.syncErrorThrown = !0, !0) : (hostReportError(p), !0);
    }
    return !1;
  }, u.prototype._unsubscribe = function() {
    var c = this._parentSubscriber;
    this._context = null, this._parentSubscriber = null, c.unsubscribe();
  }, u;
}(Subscriber);
function canReportError(a) {
  for (; a; ) {
    var u = a, c = u.closed, l = u.destination, v = u.isStopped;
    if (c || v)
      return !1;
    l && l instanceof Subscriber ? a = l : a = null;
  }
  return !0;
}
function toSubscriber(a, u, c) {
  if (a) {
    if (a instanceof Subscriber)
      return a;
    if (a[rxSubscriber])
      return a[rxSubscriber]();
  }
  return !a && !u && !c ? new Subscriber(empty$3) : new Subscriber(a, u, c);
}
var observable = /* @__PURE__ */ function() {
  return typeof Symbol == "function" && Symbol.observable || "@@observable";
}();
function identity$1(a) {
  return a;
}
function pipe$2() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  return pipeFromArray(a);
}
function pipeFromArray(a) {
  return a.length === 0 ? identity$1 : a.length === 1 ? a[0] : function(c) {
    return a.reduce(function(l, v) {
      return v(l);
    }, c);
  };
}
var Observable = /* @__PURE__ */ function() {
  function a(u) {
    this._isScalar = !1, u && (this._subscribe = u);
  }
  return a.prototype.lift = function(u) {
    var c = new a();
    return c.source = this, c.operator = u, c;
  }, a.prototype.subscribe = function(u, c, l) {
    var v = this.operator, p = toSubscriber(u, c, l);
    if (v ? p.add(v.call(p, this.source)) : p.add(this.source || config$3.useDeprecatedSynchronousErrorHandling && !p.syncErrorThrowable ? this._subscribe(p) : this._trySubscribe(p)), config$3.useDeprecatedSynchronousErrorHandling && p.syncErrorThrowable && (p.syncErrorThrowable = !1, p.syncErrorThrown))
      throw p.syncErrorValue;
    return p;
  }, a.prototype._trySubscribe = function(u) {
    try {
      return this._subscribe(u);
    } catch (c) {
      config$3.useDeprecatedSynchronousErrorHandling && (u.syncErrorThrown = !0, u.syncErrorValue = c), canReportError(u) ? u.error(c) : console.warn(c);
    }
  }, a.prototype.forEach = function(u, c) {
    var l = this;
    return c = getPromiseCtor(c), new c(function(v, p) {
      var _;
      _ = l.subscribe(function(k) {
        try {
          u(k);
        } catch (O) {
          p(O), _ && _.unsubscribe();
        }
      }, p, v);
    });
  }, a.prototype._subscribe = function(u) {
    var c = this.source;
    return c && c.subscribe(u);
  }, a.prototype[observable] = function() {
    return this;
  }, a.prototype.pipe = function() {
    for (var u = [], c = 0; c < arguments.length; c++)
      u[c] = arguments[c];
    return u.length === 0 ? this : pipeFromArray(u)(this);
  }, a.prototype.toPromise = function(u) {
    var c = this;
    return u = getPromiseCtor(u), new u(function(l, v) {
      var p;
      c.subscribe(function(_) {
        return p = _;
      }, function(_) {
        return v(_);
      }, function() {
        return l(p);
      });
    });
  }, a.create = function(u) {
    return new a(u);
  }, a;
}();
function getPromiseCtor(a) {
  if (a || (a = Promise), !a)
    throw new Error("no Promise impl found");
  return a;
}
var subscribeToArray = function(a) {
  return function(u) {
    for (var c = 0, l = a.length; c < l && !u.closed; c++)
      u.next(a[c]);
    u.complete();
  };
}, subscribeToPromise = function(a) {
  return function(u) {
    return a.then(function(c) {
      u.closed || (u.next(c), u.complete());
    }, function(c) {
      return u.error(c);
    }).then(null, hostReportError), u;
  };
};
function getSymbolIterator() {
  return typeof Symbol != "function" || !Symbol.iterator ? "@@iterator" : Symbol.iterator;
}
var iterator = /* @__PURE__ */ getSymbolIterator(), subscribeToIterable = function(a) {
  return function(u) {
    var c = a[iterator]();
    do {
      var l = void 0;
      try {
        l = c.next();
      } catch (v) {
        return u.error(v), u;
      }
      if (l.done) {
        u.complete();
        break;
      }
      if (u.next(l.value), u.closed)
        break;
    } while (!0);
    return typeof c.return == "function" && u.add(function() {
      c.return && c.return();
    }), u;
  };
}, subscribeToObservable = function(a) {
  return function(u) {
    var c = a[observable]();
    if (typeof c.subscribe != "function")
      throw new TypeError("Provided object does not correctly implement Symbol.observable");
    return c.subscribe(u);
  };
}, isArrayLike$2 = function(a) {
  return a && typeof a.length == "number" && typeof a != "function";
};
function isPromise(a) {
  return !!a && typeof a.subscribe != "function" && typeof a.then == "function";
}
var subscribeTo = function(a) {
  if (a && typeof a[observable] == "function")
    return subscribeToObservable(a);
  if (isArrayLike$2(a))
    return subscribeToArray(a);
  if (isPromise(a))
    return subscribeToPromise(a);
  if (a && typeof a[iterator] == "function")
    return subscribeToIterable(a);
  var u = isObject$9(a) ? "an invalid object" : "'" + a + "'", c = "You provided " + u + " where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.";
  throw new TypeError(c);
}, SimpleInnerSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c) {
    var l = a.call(this) || this;
    return l.parent = c, l;
  }
  return u.prototype._next = function(c) {
    this.parent.notifyNext(c);
  }, u.prototype._error = function(c) {
    this.parent.notifyError(c), this.unsubscribe();
  }, u.prototype._complete = function() {
    this.parent.notifyComplete(), this.unsubscribe();
  }, u;
}(Subscriber), SimpleOuterSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u() {
    return a !== null && a.apply(this, arguments) || this;
  }
  return u.prototype.notifyNext = function(c) {
    this.destination.next(c);
  }, u.prototype.notifyError = function(c) {
    this.destination.error(c);
  }, u.prototype.notifyComplete = function() {
    this.destination.complete();
  }, u;
}(Subscriber);
function innerSubscribe(a, u) {
  if (!u.closed) {
    if (a instanceof Observable)
      return a.subscribe(u);
    var c;
    try {
      c = subscribeTo(a)(u);
    } catch (l) {
      u.error(l);
    }
    return c;
  }
}
function audit(a) {
  return function(c) {
    return c.lift(new AuditOperator(a));
  };
}
var AuditOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.durationSelector = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new AuditSubscriber(u, this.durationSelector));
  }, a;
}(), AuditSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.durationSelector = l, v.hasValue = !1, v;
  }
  return u.prototype._next = function(c) {
    if (this.value = c, this.hasValue = !0, !this.throttled) {
      var l = void 0;
      try {
        var v = this.durationSelector;
        l = v(c);
      } catch (_) {
        return this.destination.error(_);
      }
      var p = innerSubscribe(l, new SimpleInnerSubscriber(this));
      !p || p.closed ? this.clearThrottle() : this.add(this.throttled = p);
    }
  }, u.prototype.clearThrottle = function() {
    var c = this, l = c.value, v = c.hasValue, p = c.throttled;
    p && (this.remove(p), this.throttled = void 0, p.unsubscribe()), v && (this.value = void 0, this.hasValue = !1, this.destination.next(l));
  }, u.prototype.notifyNext = function() {
    this.clearThrottle();
  }, u.prototype.notifyComplete = function() {
    this.clearThrottle();
  }, u;
}(SimpleOuterSubscriber), Action = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    return a.call(this) || this;
  }
  return u.prototype.schedule = function(c, l) {
    return this;
  }, u;
}(Subscription), AsyncAction = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c, l) || this;
    return v.scheduler = c, v.work = l, v.pending = !1, v;
  }
  return u.prototype.schedule = function(c, l) {
    if (l === void 0 && (l = 0), this.closed)
      return this;
    this.state = c;
    var v = this.id, p = this.scheduler;
    return v != null && (this.id = this.recycleAsyncId(p, v, l)), this.pending = !0, this.delay = l, this.id = this.id || this.requestAsyncId(p, this.id, l), this;
  }, u.prototype.requestAsyncId = function(c, l, v) {
    return v === void 0 && (v = 0), setInterval(c.flush.bind(c, this), v);
  }, u.prototype.recycleAsyncId = function(c, l, v) {
    if (v === void 0 && (v = 0), v !== null && this.delay === v && this.pending === !1)
      return l;
    clearInterval(l);
  }, u.prototype.execute = function(c, l) {
    if (this.closed)
      return new Error("executing a cancelled action");
    this.pending = !1;
    var v = this._execute(c, l);
    if (v)
      return v;
    this.pending === !1 && this.id != null && (this.id = this.recycleAsyncId(this.scheduler, this.id, null));
  }, u.prototype._execute = function(c, l) {
    var v = !1, p = void 0;
    try {
      this.work(c);
    } catch (_) {
      v = !0, p = !!_ && _ || new Error(_);
    }
    if (v)
      return this.unsubscribe(), p;
  }, u.prototype._unsubscribe = function() {
    var c = this.id, l = this.scheduler, v = l.actions, p = v.indexOf(this);
    this.work = null, this.state = null, this.pending = !1, this.scheduler = null, p !== -1 && v.splice(p, 1), c != null && (this.id = this.recycleAsyncId(l, c, null)), this.delay = null;
  }, u;
}(Action), Scheduler = /* @__PURE__ */ function() {
  function a(u, c) {
    c === void 0 && (c = a.now), this.SchedulerAction = u, this.now = c;
  }
  return a.prototype.schedule = function(u, c, l) {
    return c === void 0 && (c = 0), new this.SchedulerAction(this, u).schedule(l, c);
  }, a.now = function() {
    return Date.now();
  }, a;
}(), AsyncScheduler = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    l === void 0 && (l = Scheduler.now);
    var v = a.call(this, c, function() {
      return u.delegate && u.delegate !== v ? u.delegate.now() : l();
    }) || this;
    return v.actions = [], v.active = !1, v.scheduled = void 0, v;
  }
  return u.prototype.schedule = function(c, l, v) {
    return l === void 0 && (l = 0), u.delegate && u.delegate !== this ? u.delegate.schedule(c, l, v) : a.prototype.schedule.call(this, c, l, v);
  }, u.prototype.flush = function(c) {
    var l = this.actions;
    if (this.active) {
      l.push(c);
      return;
    }
    var v;
    this.active = !0;
    do
      if (v = c.execute(c.state, c.delay))
        break;
    while (c = l.shift());
    if (this.active = !1, v) {
      for (; c = l.shift(); )
        c.unsubscribe();
      throw v;
    }
  }, u;
}(Scheduler), asyncScheduler = /* @__PURE__ */ new AsyncScheduler(AsyncAction), async$1 = asyncScheduler;
function isNumeric(a) {
  return !isArray$5(a) && a - parseFloat(a) + 1 >= 0;
}
function isScheduler(a) {
  return a && typeof a.schedule == "function";
}
function timer(a, u, c) {
  a === void 0 && (a = 0);
  var l = -1;
  return isNumeric(u) ? l = Number(u) < 1 && 1 || Number(u) : isScheduler(u) && (c = u), isScheduler(c) || (c = async$1), new Observable(function(v) {
    var p = isNumeric(a) ? a : +a - c.now();
    return c.schedule(dispatch$1, p, {
      index: 0,
      period: l,
      subscriber: v
    });
  });
}
function dispatch$1(a) {
  var u = a.index, c = a.period, l = a.subscriber;
  if (l.next(u), !l.closed) {
    if (c === -1)
      return l.complete();
    a.index = u + 1, this.schedule(a, c);
  }
}
function auditTime(a, u) {
  return u === void 0 && (u = async$1), audit(function() {
    return timer(a, u);
  });
}
function buffer$2(a) {
  return function(c) {
    return c.lift(new BufferOperator(a));
  };
}
var BufferOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.closingNotifier = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new BufferSubscriber(u, this.closingNotifier));
  }, a;
}(), BufferSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.buffer = [], v.add(innerSubscribe(l, new SimpleInnerSubscriber(v))), v;
  }
  return u.prototype._next = function(c) {
    this.buffer.push(c);
  }, u.prototype.notifyNext = function() {
    var c = this.buffer;
    this.buffer = [], this.destination.next(c);
  }, u;
}(SimpleOuterSubscriber);
function bufferCount(a, u) {
  return u === void 0 && (u = null), function(l) {
    return l.lift(new BufferCountOperator(a, u));
  };
}
var BufferCountOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.bufferSize = u, this.startBufferEvery = c, !c || u === c ? this.subscriberClass = BufferCountSubscriber : this.subscriberClass = BufferSkipCountSubscriber;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new this.subscriberClass(u, this.bufferSize, this.startBufferEvery));
  }, a;
}(), BufferCountSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.bufferSize = l, v.buffer = [], v;
  }
  return u.prototype._next = function(c) {
    var l = this.buffer;
    l.push(c), l.length == this.bufferSize && (this.destination.next(l), this.buffer = []);
  }, u.prototype._complete = function() {
    var c = this.buffer;
    c.length > 0 && this.destination.next(c), a.prototype._complete.call(this);
  }, u;
}(Subscriber), BufferSkipCountSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.bufferSize = l, p.startBufferEvery = v, p.buffers = [], p.count = 0, p;
  }
  return u.prototype._next = function(c) {
    var l = this, v = l.bufferSize, p = l.startBufferEvery, _ = l.buffers, k = l.count;
    this.count++, k % p === 0 && _.push([]);
    for (var O = _.length; O--; ) {
      var D = _[O];
      D.push(c), D.length === v && (_.splice(O, 1), this.destination.next(D));
    }
  }, u.prototype._complete = function() {
    for (var c = this, l = c.buffers, v = c.destination; l.length > 0; ) {
      var p = l.shift();
      p.length > 0 && v.next(p);
    }
    a.prototype._complete.call(this);
  }, u;
}(Subscriber);
function bufferTime(a) {
  var u = arguments.length, c = async$1;
  isScheduler(arguments[arguments.length - 1]) && (c = arguments[arguments.length - 1], u--);
  var l = null;
  u >= 2 && (l = arguments[1]);
  var v = Number.POSITIVE_INFINITY;
  return u >= 3 && (v = arguments[2]), function(_) {
    return _.lift(new BufferTimeOperator(a, l, v, c));
  };
}
var BufferTimeOperator = /* @__PURE__ */ function() {
  function a(u, c, l, v) {
    this.bufferTimeSpan = u, this.bufferCreationInterval = c, this.maxBufferSize = l, this.scheduler = v;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new BufferTimeSubscriber(u, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));
  }, a;
}(), Context = /* @__PURE__ */ function() {
  function a() {
    this.buffer = [];
  }
  return a;
}(), BufferTimeSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v, p, _) {
    var k = a.call(this, c) || this;
    k.bufferTimeSpan = l, k.bufferCreationInterval = v, k.maxBufferSize = p, k.scheduler = _, k.contexts = [];
    var O = k.openContext();
    if (k.timespanOnly = v == null || v < 0, k.timespanOnly) {
      var D = { subscriber: k, context: O, bufferTimeSpan: l };
      k.add(O.closeAction = _.schedule(dispatchBufferTimeSpanOnly, l, D));
    } else {
      var F = { subscriber: k, context: O }, H = { bufferTimeSpan: l, bufferCreationInterval: v, subscriber: k, scheduler: _ };
      k.add(O.closeAction = _.schedule(dispatchBufferClose, l, F)), k.add(_.schedule(dispatchBufferCreation, v, H));
    }
    return k;
  }
  return u.prototype._next = function(c) {
    for (var l = this.contexts, v = l.length, p, _ = 0; _ < v; _++) {
      var k = l[_], O = k.buffer;
      O.push(c), O.length == this.maxBufferSize && (p = k);
    }
    p && this.onBufferFull(p);
  }, u.prototype._error = function(c) {
    this.contexts.length = 0, a.prototype._error.call(this, c);
  }, u.prototype._complete = function() {
    for (var c = this, l = c.contexts, v = c.destination; l.length > 0; ) {
      var p = l.shift();
      v.next(p.buffer);
    }
    a.prototype._complete.call(this);
  }, u.prototype._unsubscribe = function() {
    this.contexts = null;
  }, u.prototype.onBufferFull = function(c) {
    this.closeContext(c);
    var l = c.closeAction;
    if (l.unsubscribe(), this.remove(l), !this.closed && this.timespanOnly) {
      c = this.openContext();
      var v = this.bufferTimeSpan, p = { subscriber: this, context: c, bufferTimeSpan: v };
      this.add(c.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, v, p));
    }
  }, u.prototype.openContext = function() {
    var c = new Context();
    return this.contexts.push(c), c;
  }, u.prototype.closeContext = function(c) {
    this.destination.next(c.buffer);
    var l = this.contexts, v = l ? l.indexOf(c) : -1;
    v >= 0 && l.splice(l.indexOf(c), 1);
  }, u;
}(Subscriber);
function dispatchBufferTimeSpanOnly(a) {
  var u = a.subscriber, c = a.context;
  c && u.closeContext(c), u.closed || (a.context = u.openContext(), a.context.closeAction = this.schedule(a, a.bufferTimeSpan));
}
function dispatchBufferCreation(a) {
  var u = a.bufferCreationInterval, c = a.bufferTimeSpan, l = a.subscriber, v = a.scheduler, p = l.openContext(), _ = this;
  l.closed || (l.add(p.closeAction = v.schedule(dispatchBufferClose, c, { subscriber: l, context: p })), _.schedule(a, u));
}
function dispatchBufferClose(a) {
  var u = a.subscriber, c = a.context;
  u.closeContext(c);
}
var InnerSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this) || this;
    return p.parent = c, p.outerValue = l, p.outerIndex = v, p.index = 0, p;
  }
  return u.prototype._next = function(c) {
    this.parent.notifyNext(this.outerValue, c, this.outerIndex, this.index++, this);
  }, u.prototype._error = function(c) {
    this.parent.notifyError(c, this), this.unsubscribe();
  }, u.prototype._complete = function() {
    this.parent.notifyComplete(this), this.unsubscribe();
  }, u;
}(Subscriber);
function subscribeToResult(a, u, c, l, v) {
  if (v === void 0 && (v = new InnerSubscriber(a, c, l)), !v.closed)
    return u instanceof Observable ? u.subscribe(v) : subscribeTo(u)(v);
}
var OuterSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u() {
    return a !== null && a.apply(this, arguments) || this;
  }
  return u.prototype.notifyNext = function(c, l, v, p, _) {
    this.destination.next(l);
  }, u.prototype.notifyError = function(c, l) {
    this.destination.error(c);
  }, u.prototype.notifyComplete = function(c) {
    this.destination.complete();
  }, u;
}(Subscriber);
function bufferToggle(a, u) {
  return function(l) {
    return l.lift(new BufferToggleOperator(a, u));
  };
}
var BufferToggleOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.openings = u, this.closingSelector = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new BufferToggleSubscriber(u, this.openings, this.closingSelector));
  }, a;
}(), BufferToggleSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.closingSelector = v, p.contexts = [], p.add(subscribeToResult(p, l)), p;
  }
  return u.prototype._next = function(c) {
    for (var l = this.contexts, v = l.length, p = 0; p < v; p++)
      l[p].buffer.push(c);
  }, u.prototype._error = function(c) {
    for (var l = this.contexts; l.length > 0; ) {
      var v = l.shift();
      v.subscription.unsubscribe(), v.buffer = null, v.subscription = null;
    }
    this.contexts = null, a.prototype._error.call(this, c);
  }, u.prototype._complete = function() {
    for (var c = this.contexts; c.length > 0; ) {
      var l = c.shift();
      this.destination.next(l.buffer), l.subscription.unsubscribe(), l.buffer = null, l.subscription = null;
    }
    this.contexts = null, a.prototype._complete.call(this);
  }, u.prototype.notifyNext = function(c, l) {
    c ? this.closeBuffer(c) : this.openBuffer(l);
  }, u.prototype.notifyComplete = function(c) {
    this.closeBuffer(c.context);
  }, u.prototype.openBuffer = function(c) {
    try {
      var l = this.closingSelector, v = l.call(this, c);
      v && this.trySubscribe(v);
    } catch (p) {
      this._error(p);
    }
  }, u.prototype.closeBuffer = function(c) {
    var l = this.contexts;
    if (l && c) {
      var v = c.buffer, p = c.subscription;
      this.destination.next(v), l.splice(l.indexOf(c), 1), this.remove(p), p.unsubscribe();
    }
  }, u.prototype.trySubscribe = function(c) {
    var l = this.contexts, v = [], p = new Subscription(), _ = { buffer: v, subscription: p };
    l.push(_);
    var k = subscribeToResult(this, c, _);
    !k || k.closed ? this.closeBuffer(_) : (k.context = _, this.add(k), p.add(k));
  }, u;
}(OuterSubscriber);
function bufferWhen(a) {
  return function(u) {
    return u.lift(new BufferWhenOperator(a));
  };
}
var BufferWhenOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.closingSelector = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new BufferWhenSubscriber(u, this.closingSelector));
  }, a;
}(), BufferWhenSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.closingSelector = l, v.subscribing = !1, v.openBuffer(), v;
  }
  return u.prototype._next = function(c) {
    this.buffer.push(c);
  }, u.prototype._complete = function() {
    var c = this.buffer;
    c && this.destination.next(c), a.prototype._complete.call(this);
  }, u.prototype._unsubscribe = function() {
    this.buffer = void 0, this.subscribing = !1;
  }, u.prototype.notifyNext = function() {
    this.openBuffer();
  }, u.prototype.notifyComplete = function() {
    this.subscribing ? this.complete() : this.openBuffer();
  }, u.prototype.openBuffer = function() {
    var c = this.closingSubscription;
    c && (this.remove(c), c.unsubscribe());
    var l = this.buffer;
    this.buffer && this.destination.next(l), this.buffer = [];
    var v;
    try {
      var p = this.closingSelector;
      v = p();
    } catch (_) {
      return this.error(_);
    }
    c = new Subscription(), this.closingSubscription = c, this.add(c), this.subscribing = !0, c.add(innerSubscribe(v, new SimpleInnerSubscriber(this))), this.subscribing = !1;
  }, u;
}(SimpleOuterSubscriber);
function catchError(a) {
  return function(c) {
    var l = new CatchOperator(a), v = c.lift(l);
    return l.caught = v;
  };
}
var CatchOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.selector = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new CatchSubscriber(u, this.selector, this.caught));
  }, a;
}(), CatchSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.selector = l, p.caught = v, p;
  }
  return u.prototype.error = function(c) {
    if (!this.isStopped) {
      var l = void 0;
      try {
        l = this.selector(c, this.caught);
      } catch (_) {
        a.prototype.error.call(this, _);
        return;
      }
      this._unsubscribeAndRecycle();
      var v = new SimpleInnerSubscriber(this);
      this.add(v);
      var p = innerSubscribe(l, v);
      p !== v && this.add(p);
    }
  }, u;
}(SimpleOuterSubscriber);
function scheduleArray(a, u) {
  return new Observable(function(c) {
    var l = new Subscription(), v = 0;
    return l.add(u.schedule(function() {
      if (v === a.length) {
        c.complete();
        return;
      }
      c.next(a[v++]), c.closed || l.add(this.schedule());
    })), l;
  });
}
function fromArray$1(a, u) {
  return u ? scheduleArray(a, u) : new Observable(subscribeToArray(a));
}
var NONE = {}, CombineLatestOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.resultSelector = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new CombineLatestSubscriber(u, this.resultSelector));
  }, a;
}(), CombineLatestSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.resultSelector = l, v.active = 0, v.values = [], v.observables = [], v;
  }
  return u.prototype._next = function(c) {
    this.values.push(NONE), this.observables.push(c);
  }, u.prototype._complete = function() {
    var c = this.observables, l = c.length;
    if (l === 0)
      this.destination.complete();
    else {
      this.active = l, this.toRespond = l;
      for (var v = 0; v < l; v++) {
        var p = c[v];
        this.add(subscribeToResult(this, p, void 0, v));
      }
    }
  }, u.prototype.notifyComplete = function(c) {
    (this.active -= 1) === 0 && this.destination.complete();
  }, u.prototype.notifyNext = function(c, l, v) {
    var p = this.values, _ = p[v], k = this.toRespond ? _ === NONE ? --this.toRespond : this.toRespond : 0;
    p[v] = l, k === 0 && (this.resultSelector ? this._tryResultSelector(p) : this.destination.next(p.slice()));
  }, u.prototype._tryResultSelector = function(c) {
    var l;
    try {
      l = this.resultSelector.apply(this, c);
    } catch (v) {
      this.destination.error(v);
      return;
    }
    this.destination.next(l);
  }, u;
}(OuterSubscriber);
function combineAll(a) {
  return function(u) {
    return u.lift(new CombineLatestOperator(a));
  };
}
function scheduleObservable(a, u) {
  return new Observable(function(c) {
    var l = new Subscription();
    return l.add(u.schedule(function() {
      var v = a[observable]();
      l.add(v.subscribe({
        next: function(p) {
          l.add(u.schedule(function() {
            return c.next(p);
          }));
        },
        error: function(p) {
          l.add(u.schedule(function() {
            return c.error(p);
          }));
        },
        complete: function() {
          l.add(u.schedule(function() {
            return c.complete();
          }));
        }
      }));
    })), l;
  });
}
function schedulePromise(a, u) {
  return new Observable(function(c) {
    var l = new Subscription();
    return l.add(u.schedule(function() {
      return a.then(function(v) {
        l.add(u.schedule(function() {
          c.next(v), l.add(u.schedule(function() {
            return c.complete();
          }));
        }));
      }, function(v) {
        l.add(u.schedule(function() {
          return c.error(v);
        }));
      });
    })), l;
  });
}
function scheduleIterable(a, u) {
  if (!a)
    throw new Error("Iterable cannot be null");
  return new Observable(function(c) {
    var l = new Subscription(), v;
    return l.add(function() {
      v && typeof v.return == "function" && v.return();
    }), l.add(u.schedule(function() {
      v = a[iterator](), l.add(u.schedule(function() {
        if (!c.closed) {
          var p, _;
          try {
            var k = v.next();
            p = k.value, _ = k.done;
          } catch (O) {
            c.error(O);
            return;
          }
          _ ? c.complete() : (c.next(p), this.schedule());
        }
      }));
    })), l;
  });
}
function isInteropObservable(a) {
  return a && typeof a[observable] == "function";
}
function isIterable(a) {
  return a && typeof a[iterator] == "function";
}
function scheduled(a, u) {
  if (a != null) {
    if (isInteropObservable(a))
      return scheduleObservable(a, u);
    if (isPromise(a))
      return schedulePromise(a, u);
    if (isArrayLike$2(a))
      return scheduleArray(a, u);
    if (isIterable(a) || typeof a == "string")
      return scheduleIterable(a, u);
  }
  throw new TypeError((a !== null && typeof a || a) + " is not observable");
}
function from(a, u) {
  return u ? scheduled(a, u) : a instanceof Observable ? a : new Observable(subscribeTo(a));
}
function combineLatest() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  var c = null;
  return typeof a[a.length - 1] == "function" && (c = a.pop()), a.length === 1 && isArray$5(a[0]) && (a = a[0].slice()), function(l) {
    return l.lift.call(from([l].concat(a)), new CombineLatestOperator(c));
  };
}
function of$1() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  var c = a[a.length - 1];
  return isScheduler(c) ? (a.pop(), scheduleArray(a, c)) : fromArray$1(a);
}
function map(a, u) {
  return function(l) {
    if (typeof a != "function")
      throw new TypeError("argument is not a function. Are you looking for `mapTo()`?");
    return l.lift(new MapOperator(a, u));
  };
}
var MapOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.project = u, this.thisArg = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new MapSubscriber(u, this.project, this.thisArg));
  }, a;
}(), MapSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.project = l, p.count = 0, p.thisArg = v || p, p;
  }
  return u.prototype._next = function(c) {
    var l;
    try {
      l = this.project.call(this.thisArg, c, this.count++);
    } catch (v) {
      this.destination.error(v);
      return;
    }
    this.destination.next(l);
  }, u;
}(Subscriber);
function mergeMap(a, u, c) {
  return c === void 0 && (c = Number.POSITIVE_INFINITY), typeof u == "function" ? function(l) {
    return l.pipe(mergeMap(function(v, p) {
      return from(a(v, p)).pipe(map(function(_, k) {
        return u(v, _, p, k);
      }));
    }, c));
  } : (typeof u == "number" && (c = u), function(l) {
    return l.lift(new MergeMapOperator(a, c));
  });
}
var MergeMapOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    c === void 0 && (c = Number.POSITIVE_INFINITY), this.project = u, this.concurrent = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new MergeMapSubscriber(u, this.project, this.concurrent));
  }, a;
}(), MergeMapSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    v === void 0 && (v = Number.POSITIVE_INFINITY);
    var p = a.call(this, c) || this;
    return p.project = l, p.concurrent = v, p.hasCompleted = !1, p.buffer = [], p.active = 0, p.index = 0, p;
  }
  return u.prototype._next = function(c) {
    this.active < this.concurrent ? this._tryNext(c) : this.buffer.push(c);
  }, u.prototype._tryNext = function(c) {
    var l, v = this.index++;
    try {
      l = this.project(c, v);
    } catch (p) {
      this.destination.error(p);
      return;
    }
    this.active++, this._innerSub(l);
  }, u.prototype._innerSub = function(c) {
    var l = new SimpleInnerSubscriber(this), v = this.destination;
    v.add(l);
    var p = innerSubscribe(c, l);
    p !== l && v.add(p);
  }, u.prototype._complete = function() {
    this.hasCompleted = !0, this.active === 0 && this.buffer.length === 0 && this.destination.complete(), this.unsubscribe();
  }, u.prototype.notifyNext = function(c) {
    this.destination.next(c);
  }, u.prototype.notifyComplete = function() {
    var c = this.buffer;
    this.active--, c.length > 0 ? this._next(c.shift()) : this.active === 0 && this.hasCompleted && this.destination.complete();
  }, u;
}(SimpleOuterSubscriber), flatMap = mergeMap;
function mergeAll(a) {
  return a === void 0 && (a = Number.POSITIVE_INFINITY), mergeMap(identity$1, a);
}
function concatAll() {
  return mergeAll(1);
}
function concat$1() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  return concatAll()(of$1.apply(void 0, a));
}
function concat() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  return function(c) {
    return c.lift.call(concat$1.apply(void 0, [c].concat(a)));
  };
}
function concatMap(a, u) {
  return mergeMap(a, u, 1);
}
function concatMapTo(a, u) {
  return concatMap(function() {
    return a;
  }, u);
}
function count(a) {
  return function(u) {
    return u.lift(new CountOperator(a, u));
  };
}
var CountOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.predicate = u, this.source = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new CountSubscriber(u, this.predicate, this.source));
  }, a;
}(), CountSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.predicate = l, p.source = v, p.count = 0, p.index = 0, p;
  }
  return u.prototype._next = function(c) {
    this.predicate ? this._tryPredicate(c) : this.count++;
  }, u.prototype._tryPredicate = function(c) {
    var l;
    try {
      l = this.predicate(c, this.index++, this.source);
    } catch (v) {
      this.destination.error(v);
      return;
    }
    l && this.count++;
  }, u.prototype._complete = function() {
    this.destination.next(this.count), this.destination.complete();
  }, u;
}(Subscriber);
function debounce$1(a) {
  return function(u) {
    return u.lift(new DebounceOperator(a));
  };
}
var DebounceOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.durationSelector = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new DebounceSubscriber(u, this.durationSelector));
  }, a;
}(), DebounceSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.durationSelector = l, v.hasValue = !1, v;
  }
  return u.prototype._next = function(c) {
    try {
      var l = this.durationSelector.call(this, c);
      l && this._tryNext(c, l);
    } catch (v) {
      this.destination.error(v);
    }
  }, u.prototype._complete = function() {
    this.emitValue(), this.destination.complete();
  }, u.prototype._tryNext = function(c, l) {
    var v = this.durationSubscription;
    this.value = c, this.hasValue = !0, v && (v.unsubscribe(), this.remove(v)), v = innerSubscribe(l, new SimpleInnerSubscriber(this)), v && !v.closed && this.add(this.durationSubscription = v);
  }, u.prototype.notifyNext = function() {
    this.emitValue();
  }, u.prototype.notifyComplete = function() {
    this.emitValue();
  }, u.prototype.emitValue = function() {
    if (this.hasValue) {
      var c = this.value, l = this.durationSubscription;
      l && (this.durationSubscription = void 0, l.unsubscribe(), this.remove(l)), this.value = void 0, this.hasValue = !1, a.prototype._next.call(this, c);
    }
  }, u;
}(SimpleOuterSubscriber);
function debounceTime(a, u) {
  return u === void 0 && (u = async$1), function(c) {
    return c.lift(new DebounceTimeOperator(a, u));
  };
}
var DebounceTimeOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.dueTime = u, this.scheduler = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new DebounceTimeSubscriber(u, this.dueTime, this.scheduler));
  }, a;
}(), DebounceTimeSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.dueTime = l, p.scheduler = v, p.debouncedSubscription = null, p.lastValue = null, p.hasValue = !1, p;
  }
  return u.prototype._next = function(c) {
    this.clearDebounce(), this.lastValue = c, this.hasValue = !0, this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext$1, this.dueTime, this));
  }, u.prototype._complete = function() {
    this.debouncedNext(), this.destination.complete();
  }, u.prototype.debouncedNext = function() {
    if (this.clearDebounce(), this.hasValue) {
      var c = this.lastValue;
      this.lastValue = null, this.hasValue = !1, this.destination.next(c);
    }
  }, u.prototype.clearDebounce = function() {
    var c = this.debouncedSubscription;
    c !== null && (this.remove(c), c.unsubscribe(), this.debouncedSubscription = null);
  }, u;
}(Subscriber);
function dispatchNext$1(a) {
  a.debouncedNext();
}
function defaultIfEmpty(a) {
  return a === void 0 && (a = null), function(u) {
    return u.lift(new DefaultIfEmptyOperator(a));
  };
}
var DefaultIfEmptyOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.defaultValue = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new DefaultIfEmptySubscriber(u, this.defaultValue));
  }, a;
}(), DefaultIfEmptySubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.defaultValue = l, v.isEmpty = !0, v;
  }
  return u.prototype._next = function(c) {
    this.isEmpty = !1, this.destination.next(c);
  }, u.prototype._complete = function() {
    this.isEmpty && this.destination.next(this.defaultValue), this.destination.complete();
  }, u;
}(Subscriber);
function isDate$1(a) {
  return a instanceof Date && !isNaN(+a);
}
var EMPTY = /* @__PURE__ */ new Observable(function(a) {
  return a.complete();
});
function empty$2(a) {
  return a ? emptyScheduled(a) : EMPTY;
}
function emptyScheduled(a) {
  return new Observable(function(u) {
    return a.schedule(function() {
      return u.complete();
    });
  });
}
function throwError(a, u) {
  return u ? new Observable(function(c) {
    return u.schedule(dispatch, 0, { error: a, subscriber: c });
  }) : new Observable(function(c) {
    return c.error(a);
  });
}
function dispatch(a) {
  var u = a.error, c = a.subscriber;
  c.error(u);
}
var Notification = /* @__PURE__ */ function() {
  function a(u, c, l) {
    this.kind = u, this.value = c, this.error = l, this.hasValue = u === "N";
  }
  return a.prototype.observe = function(u) {
    switch (this.kind) {
      case "N":
        return u.next && u.next(this.value);
      case "E":
        return u.error && u.error(this.error);
      case "C":
        return u.complete && u.complete();
    }
  }, a.prototype.do = function(u, c, l) {
    var v = this.kind;
    switch (v) {
      case "N":
        return u && u(this.value);
      case "E":
        return c && c(this.error);
      case "C":
        return l && l();
    }
  }, a.prototype.accept = function(u, c, l) {
    return u && typeof u.next == "function" ? this.observe(u) : this.do(u, c, l);
  }, a.prototype.toObservable = function() {
    var u = this.kind;
    switch (u) {
      case "N":
        return of$1(this.value);
      case "E":
        return throwError(this.error);
      case "C":
        return empty$2();
    }
    throw new Error("unexpected notification kind value");
  }, a.createNext = function(u) {
    return typeof u < "u" ? new a("N", u) : a.undefinedValueNotification;
  }, a.createError = function(u) {
    return new a("E", void 0, u);
  }, a.createComplete = function() {
    return a.completeNotification;
  }, a.completeNotification = new a("C"), a.undefinedValueNotification = new a("N", void 0), a;
}();
function delay(a, u) {
  u === void 0 && (u = async$1);
  var c = isDate$1(a), l = c ? +a - u.now() : Math.abs(a);
  return function(v) {
    return v.lift(new DelayOperator(l, u));
  };
}
var DelayOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.delay = u, this.scheduler = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new DelaySubscriber(u, this.delay, this.scheduler));
  }, a;
}(), DelaySubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.delay = l, p.scheduler = v, p.queue = [], p.active = !1, p.errored = !1, p;
  }
  return u.dispatch = function(c) {
    for (var l = c.source, v = l.queue, p = c.scheduler, _ = c.destination; v.length > 0 && v[0].time - p.now() <= 0; )
      v.shift().notification.observe(_);
    if (v.length > 0) {
      var k = Math.max(0, v[0].time - p.now());
      this.schedule(c, k);
    } else
      this.unsubscribe(), l.active = !1;
  }, u.prototype._schedule = function(c) {
    this.active = !0;
    var l = this.destination;
    l.add(c.schedule(u.dispatch, this.delay, {
      source: this,
      destination: this.destination,
      scheduler: c
    }));
  }, u.prototype.scheduleNotification = function(c) {
    if (this.errored !== !0) {
      var l = this.scheduler, v = new DelayMessage(l.now() + this.delay, c);
      this.queue.push(v), this.active === !1 && this._schedule(l);
    }
  }, u.prototype._next = function(c) {
    this.scheduleNotification(Notification.createNext(c));
  }, u.prototype._error = function(c) {
    this.errored = !0, this.queue = [], this.destination.error(c), this.unsubscribe();
  }, u.prototype._complete = function() {
    this.scheduleNotification(Notification.createComplete()), this.unsubscribe();
  }, u;
}(Subscriber), DelayMessage = /* @__PURE__ */ function() {
  function a(u, c) {
    this.time = u, this.notification = c;
  }
  return a;
}();
function delayWhen(a, u) {
  return u ? function(c) {
    return new SubscriptionDelayObservable(c, u).lift(new DelayWhenOperator(a));
  } : function(c) {
    return c.lift(new DelayWhenOperator(a));
  };
}
var DelayWhenOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.delayDurationSelector = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new DelayWhenSubscriber(u, this.delayDurationSelector));
  }, a;
}(), DelayWhenSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.delayDurationSelector = l, v.completed = !1, v.delayNotifierSubscriptions = [], v.index = 0, v;
  }
  return u.prototype.notifyNext = function(c, l, v, p, _) {
    this.destination.next(c), this.removeSubscription(_), this.tryComplete();
  }, u.prototype.notifyError = function(c, l) {
    this._error(c);
  }, u.prototype.notifyComplete = function(c) {
    var l = this.removeSubscription(c);
    l && this.destination.next(l), this.tryComplete();
  }, u.prototype._next = function(c) {
    var l = this.index++;
    try {
      var v = this.delayDurationSelector(c, l);
      v && this.tryDelay(v, c);
    } catch (p) {
      this.destination.error(p);
    }
  }, u.prototype._complete = function() {
    this.completed = !0, this.tryComplete(), this.unsubscribe();
  }, u.prototype.removeSubscription = function(c) {
    c.unsubscribe();
    var l = this.delayNotifierSubscriptions.indexOf(c);
    return l !== -1 && this.delayNotifierSubscriptions.splice(l, 1), c.outerValue;
  }, u.prototype.tryDelay = function(c, l) {
    var v = subscribeToResult(this, c, l);
    if (v && !v.closed) {
      var p = this.destination;
      p.add(v), this.delayNotifierSubscriptions.push(v);
    }
  }, u.prototype.tryComplete = function() {
    this.completed && this.delayNotifierSubscriptions.length === 0 && this.destination.complete();
  }, u;
}(OuterSubscriber), SubscriptionDelayObservable = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this) || this;
    return v.source = c, v.subscriptionDelay = l, v;
  }
  return u.prototype._subscribe = function(c) {
    this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(c, this.source));
  }, u;
}(Observable), SubscriptionDelaySubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this) || this;
    return v.parent = c, v.source = l, v.sourceSubscribed = !1, v;
  }
  return u.prototype._next = function(c) {
    this.subscribeToSource();
  }, u.prototype._error = function(c) {
    this.unsubscribe(), this.parent.error(c);
  }, u.prototype._complete = function() {
    this.unsubscribe(), this.subscribeToSource();
  }, u.prototype.subscribeToSource = function() {
    this.sourceSubscribed || (this.sourceSubscribed = !0, this.unsubscribe(), this.source.subscribe(this.parent));
  }, u;
}(Subscriber);
function dematerialize() {
  return function(u) {
    return u.lift(new DeMaterializeOperator());
  };
}
var DeMaterializeOperator = /* @__PURE__ */ function() {
  function a() {
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new DeMaterializeSubscriber(u));
  }, a;
}(), DeMaterializeSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c) {
    return a.call(this, c) || this;
  }
  return u.prototype._next = function(c) {
    c.observe(this.destination);
  }, u;
}(Subscriber);
function distinct(a, u) {
  return function(c) {
    return c.lift(new DistinctOperator(a, u));
  };
}
var DistinctOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.keySelector = u, this.flushes = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new DistinctSubscriber(u, this.keySelector, this.flushes));
  }, a;
}(), DistinctSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.keySelector = l, p.values = /* @__PURE__ */ new Set(), v && p.add(innerSubscribe(v, new SimpleInnerSubscriber(p))), p;
  }
  return u.prototype.notifyNext = function() {
    this.values.clear();
  }, u.prototype.notifyError = function(c) {
    this._error(c);
  }, u.prototype._next = function(c) {
    this.keySelector ? this._useKeySelector(c) : this._finalizeNext(c, c);
  }, u.prototype._useKeySelector = function(c) {
    var l, v = this.destination;
    try {
      l = this.keySelector(c);
    } catch (p) {
      v.error(p);
      return;
    }
    this._finalizeNext(l, c);
  }, u.prototype._finalizeNext = function(c, l) {
    var v = this.values;
    v.has(c) || (v.add(c), this.destination.next(l));
  }, u;
}(SimpleOuterSubscriber);
function distinctUntilChanged(a, u) {
  return function(c) {
    return c.lift(new DistinctUntilChangedOperator(a, u));
  };
}
var DistinctUntilChangedOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.compare = u, this.keySelector = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new DistinctUntilChangedSubscriber(u, this.compare, this.keySelector));
  }, a;
}(), DistinctUntilChangedSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.keySelector = v, p.hasKey = !1, typeof l == "function" && (p.compare = l), p;
  }
  return u.prototype.compare = function(c, l) {
    return c === l;
  }, u.prototype._next = function(c) {
    var l;
    try {
      var v = this.keySelector;
      l = v ? v(c) : c;
    } catch (k) {
      return this.destination.error(k);
    }
    var p = !1;
    if (this.hasKey)
      try {
        var _ = this.compare;
        p = _(this.key, l);
      } catch (k) {
        return this.destination.error(k);
      }
    else
      this.hasKey = !0;
    p || (this.key = l, this.destination.next(c));
  }, u;
}(Subscriber);
function distinctUntilKeyChanged(a, u) {
  return distinctUntilChanged(function(c, l) {
    return u ? u(c[a], l[a]) : c[a] === l[a];
  });
}
var ArgumentOutOfRangeErrorImpl = /* @__PURE__ */ function() {
  function a() {
    return Error.call(this), this.message = "argument out of range", this.name = "ArgumentOutOfRangeError", this;
  }
  return a.prototype = /* @__PURE__ */ Object.create(Error.prototype), a;
}(), ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl;
function filter(a, u) {
  return function(l) {
    return l.lift(new FilterOperator(a, u));
  };
}
var FilterOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.predicate = u, this.thisArg = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new FilterSubscriber(u, this.predicate, this.thisArg));
  }, a;
}(), FilterSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.predicate = l, p.thisArg = v, p.count = 0, p;
  }
  return u.prototype._next = function(c) {
    var l;
    try {
      l = this.predicate.call(this.thisArg, c, this.count++);
    } catch (v) {
      this.destination.error(v);
      return;
    }
    l && this.destination.next(c);
  }, u;
}(Subscriber), EmptyErrorImpl = /* @__PURE__ */ function() {
  function a() {
    return Error.call(this), this.message = "no elements in sequence", this.name = "EmptyError", this;
  }
  return a.prototype = /* @__PURE__ */ Object.create(Error.prototype), a;
}(), EmptyError = EmptyErrorImpl;
function throwIfEmpty(a) {
  return a === void 0 && (a = defaultErrorFactory), function(u) {
    return u.lift(new ThrowIfEmptyOperator(a));
  };
}
var ThrowIfEmptyOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.errorFactory = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new ThrowIfEmptySubscriber(u, this.errorFactory));
  }, a;
}(), ThrowIfEmptySubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.errorFactory = l, v.hasValue = !1, v;
  }
  return u.prototype._next = function(c) {
    this.hasValue = !0, this.destination.next(c);
  }, u.prototype._complete = function() {
    if (this.hasValue)
      return this.destination.complete();
    var c = void 0;
    try {
      c = this.errorFactory();
    } catch (l) {
      c = l;
    }
    this.destination.error(c);
  }, u;
}(Subscriber);
function defaultErrorFactory() {
  return new EmptyError();
}
function take(a) {
  return function(u) {
    return a === 0 ? empty$2() : u.lift(new TakeOperator(a));
  };
}
var TakeOperator = /* @__PURE__ */ function() {
  function a(u) {
    if (this.total = u, this.total < 0)
      throw new ArgumentOutOfRangeError();
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new TakeSubscriber(u, this.total));
  }, a;
}(), TakeSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.total = l, v.count = 0, v;
  }
  return u.prototype._next = function(c) {
    var l = this.total, v = ++this.count;
    v <= l && (this.destination.next(c), v === l && (this.destination.complete(), this.unsubscribe()));
  }, u;
}(Subscriber);
function elementAt(a, u) {
  if (a < 0)
    throw new ArgumentOutOfRangeError();
  var c = arguments.length >= 2;
  return function(l) {
    return l.pipe(filter(function(v, p) {
      return p === a;
    }), take(1), c ? defaultIfEmpty(u) : throwIfEmpty(function() {
      return new ArgumentOutOfRangeError();
    }));
  };
}
function endWith() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  return function(c) {
    return concat$1(c, of$1.apply(void 0, a));
  };
}
function every$1(a, u) {
  return function(c) {
    return c.lift(new EveryOperator(a, u, c));
  };
}
var EveryOperator = /* @__PURE__ */ function() {
  function a(u, c, l) {
    this.predicate = u, this.thisArg = c, this.source = l;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new EverySubscriber(u, this.predicate, this.thisArg, this.source));
  }, a;
}(), EverySubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v, p) {
    var _ = a.call(this, c) || this;
    return _.predicate = l, _.thisArg = v, _.source = p, _.index = 0, _.thisArg = v || _, _;
  }
  return u.prototype.notifyComplete = function(c) {
    this.destination.next(c), this.destination.complete();
  }, u.prototype._next = function(c) {
    var l = !1;
    try {
      l = this.predicate.call(this.thisArg, c, this.index++, this.source);
    } catch (v) {
      this.destination.error(v);
      return;
    }
    l || this.notifyComplete(!1);
  }, u.prototype._complete = function() {
    this.notifyComplete(!0);
  }, u;
}(Subscriber);
function exhaust() {
  return function(a) {
    return a.lift(new SwitchFirstOperator());
  };
}
var SwitchFirstOperator = /* @__PURE__ */ function() {
  function a() {
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new SwitchFirstSubscriber(u));
  }, a;
}(), SwitchFirstSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c) {
    var l = a.call(this, c) || this;
    return l.hasCompleted = !1, l.hasSubscription = !1, l;
  }
  return u.prototype._next = function(c) {
    this.hasSubscription || (this.hasSubscription = !0, this.add(innerSubscribe(c, new SimpleInnerSubscriber(this))));
  }, u.prototype._complete = function() {
    this.hasCompleted = !0, this.hasSubscription || this.destination.complete();
  }, u.prototype.notifyComplete = function() {
    this.hasSubscription = !1, this.hasCompleted && this.destination.complete();
  }, u;
}(SimpleOuterSubscriber);
function exhaustMap(a, u) {
  return u ? function(c) {
    return c.pipe(exhaustMap(function(l, v) {
      return from(a(l, v)).pipe(map(function(p, _) {
        return u(l, p, v, _);
      }));
    }));
  } : function(c) {
    return c.lift(new ExhaustMapOperator(a));
  };
}
var ExhaustMapOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.project = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new ExhaustMapSubscriber(u, this.project));
  }, a;
}(), ExhaustMapSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.project = l, v.hasSubscription = !1, v.hasCompleted = !1, v.index = 0, v;
  }
  return u.prototype._next = function(c) {
    this.hasSubscription || this.tryNext(c);
  }, u.prototype.tryNext = function(c) {
    var l, v = this.index++;
    try {
      l = this.project(c, v);
    } catch (p) {
      this.destination.error(p);
      return;
    }
    this.hasSubscription = !0, this._innerSub(l);
  }, u.prototype._innerSub = function(c) {
    var l = new SimpleInnerSubscriber(this), v = this.destination;
    v.add(l);
    var p = innerSubscribe(c, l);
    p !== l && v.add(p);
  }, u.prototype._complete = function() {
    this.hasCompleted = !0, this.hasSubscription || this.destination.complete(), this.unsubscribe();
  }, u.prototype.notifyNext = function(c) {
    this.destination.next(c);
  }, u.prototype.notifyError = function(c) {
    this.destination.error(c);
  }, u.prototype.notifyComplete = function() {
    this.hasSubscription = !1, this.hasCompleted && this.destination.complete();
  }, u;
}(SimpleOuterSubscriber);
function expand(a, u, c) {
  return u === void 0 && (u = Number.POSITIVE_INFINITY), u = (u || 0) < 1 ? Number.POSITIVE_INFINITY : u, function(l) {
    return l.lift(new ExpandOperator(a, u, c));
  };
}
var ExpandOperator = /* @__PURE__ */ function() {
  function a(u, c, l) {
    this.project = u, this.concurrent = c, this.scheduler = l;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new ExpandSubscriber(u, this.project, this.concurrent, this.scheduler));
  }, a;
}(), ExpandSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v, p) {
    var _ = a.call(this, c) || this;
    return _.project = l, _.concurrent = v, _.scheduler = p, _.index = 0, _.active = 0, _.hasCompleted = !1, v < Number.POSITIVE_INFINITY && (_.buffer = []), _;
  }
  return u.dispatch = function(c) {
    var l = c.subscriber, v = c.result, p = c.value, _ = c.index;
    l.subscribeToProjection(v, p, _);
  }, u.prototype._next = function(c) {
    var l = this.destination;
    if (l.closed) {
      this._complete();
      return;
    }
    var v = this.index++;
    if (this.active < this.concurrent) {
      l.next(c);
      try {
        var p = this.project, _ = p(c, v);
        if (!this.scheduler)
          this.subscribeToProjection(_, c, v);
        else {
          var k = { subscriber: this, result: _, value: c, index: v }, O = this.destination;
          O.add(this.scheduler.schedule(u.dispatch, 0, k));
        }
      } catch (D) {
        l.error(D);
      }
    } else
      this.buffer.push(c);
  }, u.prototype.subscribeToProjection = function(c, l, v) {
    this.active++;
    var p = this.destination;
    p.add(innerSubscribe(c, new SimpleInnerSubscriber(this)));
  }, u.prototype._complete = function() {
    this.hasCompleted = !0, this.hasCompleted && this.active === 0 && this.destination.complete(), this.unsubscribe();
  }, u.prototype.notifyNext = function(c) {
    this._next(c);
  }, u.prototype.notifyComplete = function() {
    var c = this.buffer;
    this.active--, c && c.length > 0 && this._next(c.shift()), this.hasCompleted && this.active === 0 && this.destination.complete();
  }, u;
}(SimpleOuterSubscriber);
function finalize(a) {
  return function(u) {
    return u.lift(new FinallyOperator(a));
  };
}
var FinallyOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.callback = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new FinallySubscriber(u, this.callback));
  }, a;
}(), FinallySubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.add(new Subscription(l)), v;
  }
  return u;
}(Subscriber);
function find$2(a, u) {
  if (typeof a != "function")
    throw new TypeError("predicate is not a function");
  return function(c) {
    return c.lift(new FindValueOperator(a, c, !1, u));
  };
}
var FindValueOperator = /* @__PURE__ */ function() {
  function a(u, c, l, v) {
    this.predicate = u, this.source = c, this.yieldIndex = l, this.thisArg = v;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new FindValueSubscriber(u, this.predicate, this.source, this.yieldIndex, this.thisArg));
  }, a;
}(), FindValueSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v, p, _) {
    var k = a.call(this, c) || this;
    return k.predicate = l, k.source = v, k.yieldIndex = p, k.thisArg = _, k.index = 0, k;
  }
  return u.prototype.notifyComplete = function(c) {
    var l = this.destination;
    l.next(c), l.complete(), this.unsubscribe();
  }, u.prototype._next = function(c) {
    var l = this, v = l.predicate, p = l.thisArg, _ = this.index++;
    try {
      var k = v.call(p || this, c, _, this.source);
      k && this.notifyComplete(this.yieldIndex ? _ : c);
    } catch (O) {
      this.destination.error(O);
    }
  }, u.prototype._complete = function() {
    this.notifyComplete(this.yieldIndex ? -1 : void 0);
  }, u;
}(Subscriber);
function findIndex(a, u) {
  return function(c) {
    return c.lift(new FindValueOperator(a, c, !0, u));
  };
}
function first(a, u) {
  var c = arguments.length >= 2;
  return function(l) {
    return l.pipe(a ? filter(function(v, p) {
      return a(v, p, l);
    }) : identity$1, take(1), c ? defaultIfEmpty(u) : throwIfEmpty(function() {
      return new EmptyError();
    }));
  };
}
var ObjectUnsubscribedErrorImpl = /* @__PURE__ */ function() {
  function a() {
    return Error.call(this), this.message = "object unsubscribed", this.name = "ObjectUnsubscribedError", this;
  }
  return a.prototype = /* @__PURE__ */ Object.create(Error.prototype), a;
}(), ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl, SubjectSubscription = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this) || this;
    return v.subject = c, v.subscriber = l, v.closed = !1, v;
  }
  return u.prototype.unsubscribe = function() {
    if (!this.closed) {
      this.closed = !0;
      var c = this.subject, l = c.observers;
      if (this.subject = null, !(!l || l.length === 0 || c.isStopped || c.closed)) {
        var v = l.indexOf(this.subscriber);
        v !== -1 && l.splice(v, 1);
      }
    }
  }, u;
}(Subscription), SubjectSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c) {
    var l = a.call(this, c) || this;
    return l.destination = c, l;
  }
  return u;
}(Subscriber), Subject = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u() {
    var c = a.call(this) || this;
    return c.observers = [], c.closed = !1, c.isStopped = !1, c.hasError = !1, c.thrownError = null, c;
  }
  return u.prototype[rxSubscriber] = function() {
    return new SubjectSubscriber(this);
  }, u.prototype.lift = function(c) {
    var l = new AnonymousSubject(this, this);
    return l.operator = c, l;
  }, u.prototype.next = function(c) {
    if (this.closed)
      throw new ObjectUnsubscribedError();
    if (!this.isStopped)
      for (var l = this.observers, v = l.length, p = l.slice(), _ = 0; _ < v; _++)
        p[_].next(c);
  }, u.prototype.error = function(c) {
    if (this.closed)
      throw new ObjectUnsubscribedError();
    this.hasError = !0, this.thrownError = c, this.isStopped = !0;
    for (var l = this.observers, v = l.length, p = l.slice(), _ = 0; _ < v; _++)
      p[_].error(c);
    this.observers.length = 0;
  }, u.prototype.complete = function() {
    if (this.closed)
      throw new ObjectUnsubscribedError();
    this.isStopped = !0;
    for (var c = this.observers, l = c.length, v = c.slice(), p = 0; p < l; p++)
      v[p].complete();
    this.observers.length = 0;
  }, u.prototype.unsubscribe = function() {
    this.isStopped = !0, this.closed = !0, this.observers = null;
  }, u.prototype._trySubscribe = function(c) {
    if (this.closed)
      throw new ObjectUnsubscribedError();
    return a.prototype._trySubscribe.call(this, c);
  }, u.prototype._subscribe = function(c) {
    if (this.closed)
      throw new ObjectUnsubscribedError();
    return this.hasError ? (c.error(this.thrownError), Subscription.EMPTY) : this.isStopped ? (c.complete(), Subscription.EMPTY) : (this.observers.push(c), new SubjectSubscription(this, c));
  }, u.prototype.asObservable = function() {
    var c = new Observable();
    return c.source = this, c;
  }, u.create = function(c, l) {
    return new AnonymousSubject(c, l);
  }, u;
}(Observable), AnonymousSubject = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this) || this;
    return v.destination = c, v.source = l, v;
  }
  return u.prototype.next = function(c) {
    var l = this.destination;
    l && l.next && l.next(c);
  }, u.prototype.error = function(c) {
    var l = this.destination;
    l && l.error && this.destination.error(c);
  }, u.prototype.complete = function() {
    var c = this.destination;
    c && c.complete && this.destination.complete();
  }, u.prototype._subscribe = function(c) {
    var l = this.source;
    return l ? this.source.subscribe(c) : Subscription.EMPTY;
  }, u;
}(Subject);
function groupBy(a, u, c, l) {
  return function(v) {
    return v.lift(new GroupByOperator(a, u, c, l));
  };
}
var GroupByOperator = /* @__PURE__ */ function() {
  function a(u, c, l, v) {
    this.keySelector = u, this.elementSelector = c, this.durationSelector = l, this.subjectSelector = v;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new GroupBySubscriber(u, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));
  }, a;
}(), GroupBySubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v, p, _) {
    var k = a.call(this, c) || this;
    return k.keySelector = l, k.elementSelector = v, k.durationSelector = p, k.subjectSelector = _, k.groups = null, k.attemptedToUnsubscribe = !1, k.count = 0, k;
  }
  return u.prototype._next = function(c) {
    var l;
    try {
      l = this.keySelector(c);
    } catch (v) {
      this.error(v);
      return;
    }
    this._group(c, l);
  }, u.prototype._group = function(c, l) {
    var v = this.groups;
    v || (v = this.groups = /* @__PURE__ */ new Map());
    var p = v.get(l), _;
    if (this.elementSelector)
      try {
        _ = this.elementSelector(c);
      } catch (D) {
        this.error(D);
      }
    else
      _ = c;
    if (!p) {
      p = this.subjectSelector ? this.subjectSelector() : new Subject(), v.set(l, p);
      var k = new GroupedObservable(l, p, this);
      if (this.destination.next(k), this.durationSelector) {
        var O = void 0;
        try {
          O = this.durationSelector(new GroupedObservable(l, p));
        } catch (D) {
          this.error(D);
          return;
        }
        this.add(O.subscribe(new GroupDurationSubscriber(l, p, this)));
      }
    }
    p.closed || p.next(_);
  }, u.prototype._error = function(c) {
    var l = this.groups;
    l && (l.forEach(function(v, p) {
      v.error(c);
    }), l.clear()), this.destination.error(c);
  }, u.prototype._complete = function() {
    var c = this.groups;
    c && (c.forEach(function(l, v) {
      l.complete();
    }), c.clear()), this.destination.complete();
  }, u.prototype.removeGroup = function(c) {
    this.groups.delete(c);
  }, u.prototype.unsubscribe = function() {
    this.closed || (this.attemptedToUnsubscribe = !0, this.count === 0 && a.prototype.unsubscribe.call(this));
  }, u;
}(Subscriber), GroupDurationSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, l) || this;
    return p.key = c, p.group = l, p.parent = v, p;
  }
  return u.prototype._next = function(c) {
    this.complete();
  }, u.prototype._unsubscribe = function() {
    var c = this, l = c.parent, v = c.key;
    this.key = this.parent = null, l && l.removeGroup(v);
  }, u;
}(Subscriber), GroupedObservable = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this) || this;
    return p.key = c, p.groupSubject = l, p.refCountSubscription = v, p;
  }
  return u.prototype._subscribe = function(c) {
    var l = new Subscription(), v = this, p = v.refCountSubscription, _ = v.groupSubject;
    return p && !p.closed && l.add(new InnerRefCountSubscription(p)), l.add(_.subscribe(c)), l;
  }, u;
}(Observable), InnerRefCountSubscription = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c) {
    var l = a.call(this) || this;
    return l.parent = c, c.count++, l;
  }
  return u.prototype.unsubscribe = function() {
    var c = this.parent;
    !c.closed && !this.closed && (a.prototype.unsubscribe.call(this), c.count -= 1, c.count === 0 && c.attemptedToUnsubscribe && c.unsubscribe());
  }, u;
}(Subscription);
function ignoreElements() {
  return function(u) {
    return u.lift(new IgnoreElementsOperator());
  };
}
var IgnoreElementsOperator = /* @__PURE__ */ function() {
  function a() {
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new IgnoreElementsSubscriber(u));
  }, a;
}(), IgnoreElementsSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u() {
    return a !== null && a.apply(this, arguments) || this;
  }
  return u.prototype._next = function(c) {
  }, u;
}(Subscriber);
function isEmpty() {
  return function(a) {
    return a.lift(new IsEmptyOperator());
  };
}
var IsEmptyOperator = /* @__PURE__ */ function() {
  function a() {
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new IsEmptySubscriber(u));
  }, a;
}(), IsEmptySubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c) {
    return a.call(this, c) || this;
  }
  return u.prototype.notifyComplete = function(c) {
    var l = this.destination;
    l.next(c), l.complete();
  }, u.prototype._next = function(c) {
    this.notifyComplete(!1);
  }, u.prototype._complete = function() {
    this.notifyComplete(!0);
  }, u;
}(Subscriber);
function takeLast(a) {
  return function(c) {
    return a === 0 ? empty$2() : c.lift(new TakeLastOperator(a));
  };
}
var TakeLastOperator = /* @__PURE__ */ function() {
  function a(u) {
    if (this.total = u, this.total < 0)
      throw new ArgumentOutOfRangeError();
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new TakeLastSubscriber(u, this.total));
  }, a;
}(), TakeLastSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.total = l, v.ring = new Array(), v.count = 0, v;
  }
  return u.prototype._next = function(c) {
    var l = this.ring, v = this.total, p = this.count++;
    if (l.length < v)
      l.push(c);
    else {
      var _ = p % v;
      l[_] = c;
    }
  }, u.prototype._complete = function() {
    var c = this.destination, l = this.count;
    if (l > 0)
      for (var v = this.count >= this.total ? this.total : this.count, p = this.ring, _ = 0; _ < v; _++) {
        var k = l++ % v;
        c.next(p[k]);
      }
    c.complete();
  }, u;
}(Subscriber);
function last$1(a, u) {
  var c = arguments.length >= 2;
  return function(l) {
    return l.pipe(a ? filter(function(v, p) {
      return a(v, p, l);
    }) : identity$1, takeLast(1), c ? defaultIfEmpty(u) : throwIfEmpty(function() {
      return new EmptyError();
    }));
  };
}
function mapTo(a) {
  return function(u) {
    return u.lift(new MapToOperator(a));
  };
}
var MapToOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.value = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new MapToSubscriber(u, this.value));
  }, a;
}(), MapToSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.value = l, v;
  }
  return u.prototype._next = function(c) {
    this.destination.next(this.value);
  }, u;
}(Subscriber);
function materialize() {
  return function(u) {
    return u.lift(new MaterializeOperator());
  };
}
var MaterializeOperator = /* @__PURE__ */ function() {
  function a() {
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new MaterializeSubscriber(u));
  }, a;
}(), MaterializeSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c) {
    return a.call(this, c) || this;
  }
  return u.prototype._next = function(c) {
    this.destination.next(Notification.createNext(c));
  }, u.prototype._error = function(c) {
    var l = this.destination;
    l.next(Notification.createError(c)), l.complete();
  }, u.prototype._complete = function() {
    var c = this.destination;
    c.next(Notification.createComplete()), c.complete();
  }, u;
}(Subscriber);
function scan(a, u) {
  var c = !1;
  return arguments.length >= 2 && (c = !0), function(v) {
    return v.lift(new ScanOperator(a, u, c));
  };
}
var ScanOperator = /* @__PURE__ */ function() {
  function a(u, c, l) {
    l === void 0 && (l = !1), this.accumulator = u, this.seed = c, this.hasSeed = l;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new ScanSubscriber(u, this.accumulator, this.seed, this.hasSeed));
  }, a;
}(), ScanSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v, p) {
    var _ = a.call(this, c) || this;
    return _.accumulator = l, _._seed = v, _.hasSeed = p, _.index = 0, _;
  }
  return Object.defineProperty(u.prototype, "seed", {
    get: function() {
      return this._seed;
    },
    set: function(c) {
      this.hasSeed = !0, this._seed = c;
    },
    enumerable: !0,
    configurable: !0
  }), u.prototype._next = function(c) {
    if (!this.hasSeed)
      this.seed = c, this.destination.next(c);
    else
      return this._tryNext(c);
  }, u.prototype._tryNext = function(c) {
    var l = this.index++, v;
    try {
      v = this.accumulator(this.seed, c, l);
    } catch (p) {
      this.destination.error(p);
    }
    this.seed = v, this.destination.next(v);
  }, u;
}(Subscriber);
function reduce(a, u) {
  return arguments.length >= 2 ? function(l) {
    return pipe$2(scan(a, u), takeLast(1), defaultIfEmpty(u))(l);
  } : function(l) {
    return pipe$2(scan(function(v, p, _) {
      return a(v, p, _ + 1);
    }), takeLast(1))(l);
  };
}
function max$1(a) {
  var u = typeof a == "function" ? function(c, l) {
    return a(c, l) > 0 ? c : l;
  } : function(c, l) {
    return c > l ? c : l;
  };
  return reduce(u);
}
function merge$2() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  var c = Number.POSITIVE_INFINITY, l = null, v = a[a.length - 1];
  return isScheduler(v) ? (l = a.pop(), a.length > 1 && typeof a[a.length - 1] == "number" && (c = a.pop())) : typeof v == "number" && (c = a.pop()), l === null && a.length === 1 && a[0] instanceof Observable ? a[0] : mergeAll(c)(fromArray$1(a, l));
}
function merge$1() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  return function(c) {
    return c.lift.call(merge$2.apply(void 0, [c].concat(a)));
  };
}
function mergeMapTo(a, u, c) {
  return c === void 0 && (c = Number.POSITIVE_INFINITY), typeof u == "function" ? mergeMap(function() {
    return a;
  }, u, c) : (typeof u == "number" && (c = u), mergeMap(function() {
    return a;
  }, c));
}
function mergeScan(a, u, c) {
  return c === void 0 && (c = Number.POSITIVE_INFINITY), function(l) {
    return l.lift(new MergeScanOperator(a, u, c));
  };
}
var MergeScanOperator = /* @__PURE__ */ function() {
  function a(u, c, l) {
    this.accumulator = u, this.seed = c, this.concurrent = l;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new MergeScanSubscriber(u, this.accumulator, this.seed, this.concurrent));
  }, a;
}(), MergeScanSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v, p) {
    var _ = a.call(this, c) || this;
    return _.accumulator = l, _.acc = v, _.concurrent = p, _.hasValue = !1, _.hasCompleted = !1, _.buffer = [], _.active = 0, _.index = 0, _;
  }
  return u.prototype._next = function(c) {
    if (this.active < this.concurrent) {
      var l = this.index++, v = this.destination, p = void 0;
      try {
        var _ = this.accumulator;
        p = _(this.acc, c, l);
      } catch (k) {
        return v.error(k);
      }
      this.active++, this._innerSub(p);
    } else
      this.buffer.push(c);
  }, u.prototype._innerSub = function(c) {
    var l = new SimpleInnerSubscriber(this), v = this.destination;
    v.add(l);
    var p = innerSubscribe(c, l);
    p !== l && v.add(p);
  }, u.prototype._complete = function() {
    this.hasCompleted = !0, this.active === 0 && this.buffer.length === 0 && (this.hasValue === !1 && this.destination.next(this.acc), this.destination.complete()), this.unsubscribe();
  }, u.prototype.notifyNext = function(c) {
    var l = this.destination;
    this.acc = c, this.hasValue = !0, l.next(c);
  }, u.prototype.notifyComplete = function() {
    var c = this.buffer;
    this.active--, c.length > 0 ? this._next(c.shift()) : this.active === 0 && this.hasCompleted && (this.hasValue === !1 && this.destination.next(this.acc), this.destination.complete());
  }, u;
}(SimpleOuterSubscriber);
function min(a) {
  var u = typeof a == "function" ? function(c, l) {
    return a(c, l) < 0 ? c : l;
  } : function(c, l) {
    return c < l ? c : l;
  };
  return reduce(u);
}
function refCount() {
  return function(u) {
    return u.lift(new RefCountOperator(u));
  };
}
var RefCountOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.connectable = u;
  }
  return a.prototype.call = function(u, c) {
    var l = this.connectable;
    l._refCount++;
    var v = new RefCountSubscriber(u, l), p = c.subscribe(v);
    return v.closed || (v.connection = l.connect()), p;
  }, a;
}(), RefCountSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.connectable = l, v;
  }
  return u.prototype._unsubscribe = function() {
    var c = this.connectable;
    if (!c) {
      this.connection = null;
      return;
    }
    this.connectable = null;
    var l = c._refCount;
    if (l <= 0) {
      this.connection = null;
      return;
    }
    if (c._refCount = l - 1, l > 1) {
      this.connection = null;
      return;
    }
    var v = this.connection, p = c._connection;
    this.connection = null, p && (!v || p === v) && p.unsubscribe();
  }, u;
}(Subscriber), ConnectableObservable = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this) || this;
    return v.source = c, v.subjectFactory = l, v._refCount = 0, v._isComplete = !1, v;
  }
  return u.prototype._subscribe = function(c) {
    return this.getSubject().subscribe(c);
  }, u.prototype.getSubject = function() {
    var c = this._subject;
    return (!c || c.isStopped) && (this._subject = this.subjectFactory()), this._subject;
  }, u.prototype.connect = function() {
    var c = this._connection;
    return c || (this._isComplete = !1, c = this._connection = new Subscription(), c.add(this.source.subscribe(new ConnectableSubscriber(this.getSubject(), this))), c.closed && (this._connection = null, c = Subscription.EMPTY)), c;
  }, u.prototype.refCount = function() {
    return refCount()(this);
  }, u;
}(Observable), connectableObservableDescriptor = /* @__PURE__ */ function() {
  var a = ConnectableObservable.prototype;
  return {
    operator: { value: null },
    _refCount: { value: 0, writable: !0 },
    _subject: { value: null, writable: !0 },
    _connection: { value: null, writable: !0 },
    _subscribe: { value: a._subscribe },
    _isComplete: { value: a._isComplete, writable: !0 },
    getSubject: { value: a.getSubject },
    connect: { value: a.connect },
    refCount: { value: a.refCount }
  };
}(), ConnectableSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.connectable = l, v;
  }
  return u.prototype._error = function(c) {
    this._unsubscribe(), a.prototype._error.call(this, c);
  }, u.prototype._complete = function() {
    this.connectable._isComplete = !0, this._unsubscribe(), a.prototype._complete.call(this);
  }, u.prototype._unsubscribe = function() {
    var c = this.connectable;
    if (c) {
      this.connectable = null;
      var l = c._connection;
      c._refCount = 0, c._subject = null, c._connection = null, l && l.unsubscribe();
    }
  }, u;
}(SubjectSubscriber);
function multicast(a, u) {
  return function(l) {
    var v;
    if (typeof a == "function" ? v = a : v = function() {
      return a;
    }, typeof u == "function")
      return l.lift(new MulticastOperator(v, u));
    var p = Object.create(l, connectableObservableDescriptor);
    return p.source = l, p.subjectFactory = v, p;
  };
}
var MulticastOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.subjectFactory = u, this.selector = c;
  }
  return a.prototype.call = function(u, c) {
    var l = this.selector, v = this.subjectFactory(), p = l(v).subscribe(u);
    return p.add(c.subscribe(v)), p;
  }, a;
}();
function observeOn(a, u) {
  return u === void 0 && (u = 0), function(l) {
    return l.lift(new ObserveOnOperator(a, u));
  };
}
var ObserveOnOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    c === void 0 && (c = 0), this.scheduler = u, this.delay = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new ObserveOnSubscriber(u, this.scheduler, this.delay));
  }, a;
}(), ObserveOnSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    v === void 0 && (v = 0);
    var p = a.call(this, c) || this;
    return p.scheduler = l, p.delay = v, p;
  }
  return u.dispatch = function(c) {
    var l = c.notification, v = c.destination;
    l.observe(v), this.unsubscribe();
  }, u.prototype.scheduleMessage = function(c) {
    var l = this.destination;
    l.add(this.scheduler.schedule(u.dispatch, this.delay, new ObserveOnMessage(c, this.destination)));
  }, u.prototype._next = function(c) {
    this.scheduleMessage(Notification.createNext(c));
  }, u.prototype._error = function(c) {
    this.scheduleMessage(Notification.createError(c)), this.unsubscribe();
  }, u.prototype._complete = function() {
    this.scheduleMessage(Notification.createComplete()), this.unsubscribe();
  }, u;
}(Subscriber), ObserveOnMessage = /* @__PURE__ */ function() {
  function a(u, c) {
    this.notification = u, this.destination = c;
  }
  return a;
}();
function onErrorResumeNext() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  return a.length === 1 && isArray$5(a[0]) && (a = a[0]), function(c) {
    return c.lift(new OnErrorResumeNextOperator(a));
  };
}
var OnErrorResumeNextOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.nextSources = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new OnErrorResumeNextSubscriber(u, this.nextSources));
  }, a;
}(), OnErrorResumeNextSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.destination = c, v.nextSources = l, v;
  }
  return u.prototype.notifyError = function() {
    this.subscribeToNextSource();
  }, u.prototype.notifyComplete = function() {
    this.subscribeToNextSource();
  }, u.prototype._error = function(c) {
    this.subscribeToNextSource(), this.unsubscribe();
  }, u.prototype._complete = function() {
    this.subscribeToNextSource(), this.unsubscribe();
  }, u.prototype.subscribeToNextSource = function() {
    var c = this.nextSources.shift();
    if (c) {
      var l = new SimpleInnerSubscriber(this), v = this.destination;
      v.add(l);
      var p = innerSubscribe(c, l);
      p !== l && v.add(p);
    } else
      this.destination.complete();
  }, u;
}(SimpleOuterSubscriber);
function pairwise() {
  return function(a) {
    return a.lift(new PairwiseOperator());
  };
}
var PairwiseOperator = /* @__PURE__ */ function() {
  function a() {
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new PairwiseSubscriber(u));
  }, a;
}(), PairwiseSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c) {
    var l = a.call(this, c) || this;
    return l.hasPrev = !1, l;
  }
  return u.prototype._next = function(c) {
    var l;
    this.hasPrev ? l = [this.prev, c] : this.hasPrev = !0, this.prev = c, l && this.destination.next(l);
  }, u;
}(Subscriber);
function not(a, u) {
  function c() {
    return !c.pred.apply(c.thisArg, arguments);
  }
  return c.pred = a, c.thisArg = u, c;
}
function partition(a, u) {
  return function(c) {
    return [
      filter(a, u)(c),
      filter(not(a, u))(c)
    ];
  };
}
function pluck() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  var c = a.length;
  if (c === 0)
    throw new Error("list of properties cannot be empty.");
  return function(l) {
    return map(plucker(a, c))(l);
  };
}
function plucker(a, u) {
  var c = function(l) {
    for (var v = l, p = 0; p < u; p++) {
      var _ = v != null ? v[a[p]] : void 0;
      if (_ !== void 0)
        v = _;
      else
        return;
    }
    return v;
  };
  return c;
}
function publish(a) {
  return a ? multicast(function() {
    return new Subject();
  }, a) : multicast(new Subject());
}
var BehaviorSubject = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c) {
    var l = a.call(this) || this;
    return l._value = c, l;
  }
  return Object.defineProperty(u.prototype, "value", {
    get: function() {
      return this.getValue();
    },
    enumerable: !0,
    configurable: !0
  }), u.prototype._subscribe = function(c) {
    var l = a.prototype._subscribe.call(this, c);
    return l && !l.closed && c.next(this._value), l;
  }, u.prototype.getValue = function() {
    if (this.hasError)
      throw this.thrownError;
    if (this.closed)
      throw new ObjectUnsubscribedError();
    return this._value;
  }, u.prototype.next = function(c) {
    a.prototype.next.call(this, this._value = c);
  }, u;
}(Subject);
function publishBehavior(a) {
  return function(u) {
    return multicast(new BehaviorSubject(a))(u);
  };
}
var AsyncSubject = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u() {
    var c = a !== null && a.apply(this, arguments) || this;
    return c.value = null, c.hasNext = !1, c.hasCompleted = !1, c;
  }
  return u.prototype._subscribe = function(c) {
    return this.hasError ? (c.error(this.thrownError), Subscription.EMPTY) : this.hasCompleted && this.hasNext ? (c.next(this.value), c.complete(), Subscription.EMPTY) : a.prototype._subscribe.call(this, c);
  }, u.prototype.next = function(c) {
    this.hasCompleted || (this.value = c, this.hasNext = !0);
  }, u.prototype.error = function(c) {
    this.hasCompleted || a.prototype.error.call(this, c);
  }, u.prototype.complete = function() {
    this.hasCompleted = !0, this.hasNext && a.prototype.next.call(this, this.value), a.prototype.complete.call(this);
  }, u;
}(Subject);
function publishLast() {
  return function(a) {
    return multicast(new AsyncSubject())(a);
  };
}
var QueueAction = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c, l) || this;
    return v.scheduler = c, v.work = l, v;
  }
  return u.prototype.schedule = function(c, l) {
    return l === void 0 && (l = 0), l > 0 ? a.prototype.schedule.call(this, c, l) : (this.delay = l, this.state = c, this.scheduler.flush(this), this);
  }, u.prototype.execute = function(c, l) {
    return l > 0 || this.closed ? a.prototype.execute.call(this, c, l) : this._execute(c, l);
  }, u.prototype.requestAsyncId = function(c, l, v) {
    return v === void 0 && (v = 0), v !== null && v > 0 || v === null && this.delay > 0 ? a.prototype.requestAsyncId.call(this, c, l, v) : c.flush(this);
  }, u;
}(AsyncAction), QueueScheduler = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u() {
    return a !== null && a.apply(this, arguments) || this;
  }
  return u;
}(AsyncScheduler), queueScheduler = /* @__PURE__ */ new QueueScheduler(QueueAction), queue$1 = queueScheduler, ReplaySubject = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    c === void 0 && (c = Number.POSITIVE_INFINITY), l === void 0 && (l = Number.POSITIVE_INFINITY);
    var p = a.call(this) || this;
    return p.scheduler = v, p._events = [], p._infiniteTimeWindow = !1, p._bufferSize = c < 1 ? 1 : c, p._windowTime = l < 1 ? 1 : l, l === Number.POSITIVE_INFINITY ? (p._infiniteTimeWindow = !0, p.next = p.nextInfiniteTimeWindow) : p.next = p.nextTimeWindow, p;
  }
  return u.prototype.nextInfiniteTimeWindow = function(c) {
    if (!this.isStopped) {
      var l = this._events;
      l.push(c), l.length > this._bufferSize && l.shift();
    }
    a.prototype.next.call(this, c);
  }, u.prototype.nextTimeWindow = function(c) {
    this.isStopped || (this._events.push(new ReplayEvent(this._getNow(), c)), this._trimBufferThenGetEvents()), a.prototype.next.call(this, c);
  }, u.prototype._subscribe = function(c) {
    var l = this._infiniteTimeWindow, v = l ? this._events : this._trimBufferThenGetEvents(), p = this.scheduler, _ = v.length, k;
    if (this.closed)
      throw new ObjectUnsubscribedError();
    if (this.isStopped || this.hasError ? k = Subscription.EMPTY : (this.observers.push(c), k = new SubjectSubscription(this, c)), p && c.add(c = new ObserveOnSubscriber(c, p)), l)
      for (var O = 0; O < _ && !c.closed; O++)
        c.next(v[O]);
    else
      for (var O = 0; O < _ && !c.closed; O++)
        c.next(v[O].value);
    return this.hasError ? c.error(this.thrownError) : this.isStopped && c.complete(), k;
  }, u.prototype._getNow = function() {
    return (this.scheduler || queue$1).now();
  }, u.prototype._trimBufferThenGetEvents = function() {
    for (var c = this._getNow(), l = this._bufferSize, v = this._windowTime, p = this._events, _ = p.length, k = 0; k < _ && !(c - p[k].time < v); )
      k++;
    return _ > l && (k = Math.max(k, _ - l)), k > 0 && p.splice(0, k), p;
  }, u;
}(Subject), ReplayEvent = /* @__PURE__ */ function() {
  function a(u, c) {
    this.time = u, this.value = c;
  }
  return a;
}();
function publishReplay(a, u, c, l) {
  c && typeof c != "function" && (l = c);
  var v = typeof c == "function" ? c : void 0, p = new ReplaySubject(a, u, l);
  return function(_) {
    return multicast(function() {
      return p;
    }, v)(_);
  };
}
function race$1() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  if (a.length === 1)
    if (isArray$5(a[0]))
      a = a[0];
    else
      return a[0];
  return fromArray$1(a, void 0).lift(new RaceOperator());
}
var RaceOperator = /* @__PURE__ */ function() {
  function a() {
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new RaceSubscriber(u));
  }, a;
}(), RaceSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c) {
    var l = a.call(this, c) || this;
    return l.hasFirst = !1, l.observables = [], l.subscriptions = [], l;
  }
  return u.prototype._next = function(c) {
    this.observables.push(c);
  }, u.prototype._complete = function() {
    var c = this.observables, l = c.length;
    if (l === 0)
      this.destination.complete();
    else {
      for (var v = 0; v < l && !this.hasFirst; v++) {
        var p = c[v], _ = subscribeToResult(this, p, void 0, v);
        this.subscriptions && this.subscriptions.push(_), this.add(_);
      }
      this.observables = null;
    }
  }, u.prototype.notifyNext = function(c, l, v) {
    if (!this.hasFirst) {
      this.hasFirst = !0;
      for (var p = 0; p < this.subscriptions.length; p++)
        if (p !== v) {
          var _ = this.subscriptions[p];
          _.unsubscribe(), this.remove(_);
        }
      this.subscriptions = null;
    }
    this.destination.next(l);
  }, u;
}(OuterSubscriber);
function race() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  return function(l) {
    return a.length === 1 && isArray$5(a[0]) && (a = a[0]), l.lift.call(race$1.apply(void 0, [l].concat(a)));
  };
}
function repeat(a) {
  return a === void 0 && (a = -1), function(u) {
    return a === 0 ? empty$2() : a < 0 ? u.lift(new RepeatOperator(-1, u)) : u.lift(new RepeatOperator(a - 1, u));
  };
}
var RepeatOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.count = u, this.source = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new RepeatSubscriber(u, this.count, this.source));
  }, a;
}(), RepeatSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.count = l, p.source = v, p;
  }
  return u.prototype.complete = function() {
    if (!this.isStopped) {
      var c = this, l = c.source, v = c.count;
      if (v === 0)
        return a.prototype.complete.call(this);
      v > -1 && (this.count = v - 1), l.subscribe(this._unsubscribeAndRecycle());
    }
  }, u;
}(Subscriber);
function repeatWhen(a) {
  return function(u) {
    return u.lift(new RepeatWhenOperator(a));
  };
}
var RepeatWhenOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.notifier = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new RepeatWhenSubscriber(u, this.notifier, c));
  }, a;
}(), RepeatWhenSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.notifier = l, p.source = v, p.sourceIsBeingSubscribedTo = !0, p;
  }
  return u.prototype.notifyNext = function() {
    this.sourceIsBeingSubscribedTo = !0, this.source.subscribe(this);
  }, u.prototype.notifyComplete = function() {
    if (this.sourceIsBeingSubscribedTo === !1)
      return a.prototype.complete.call(this);
  }, u.prototype.complete = function() {
    if (this.sourceIsBeingSubscribedTo = !1, !this.isStopped) {
      if (this.retries || this.subscribeToRetries(), !this.retriesSubscription || this.retriesSubscription.closed)
        return a.prototype.complete.call(this);
      this._unsubscribeAndRecycle(), this.notifications.next(void 0);
    }
  }, u.prototype._unsubscribe = function() {
    var c = this, l = c.notifications, v = c.retriesSubscription;
    l && (l.unsubscribe(), this.notifications = void 0), v && (v.unsubscribe(), this.retriesSubscription = void 0), this.retries = void 0;
  }, u.prototype._unsubscribeAndRecycle = function() {
    var c = this._unsubscribe;
    return this._unsubscribe = null, a.prototype._unsubscribeAndRecycle.call(this), this._unsubscribe = c, this;
  }, u.prototype.subscribeToRetries = function() {
    this.notifications = new Subject();
    var c;
    try {
      var l = this.notifier;
      c = l(this.notifications);
    } catch {
      return a.prototype.complete.call(this);
    }
    this.retries = c, this.retriesSubscription = innerSubscribe(c, new SimpleInnerSubscriber(this));
  }, u;
}(SimpleOuterSubscriber);
function retry(a) {
  return a === void 0 && (a = -1), function(u) {
    return u.lift(new RetryOperator(a, u));
  };
}
var RetryOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.count = u, this.source = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new RetrySubscriber(u, this.count, this.source));
  }, a;
}(), RetrySubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.count = l, p.source = v, p;
  }
  return u.prototype.error = function(c) {
    if (!this.isStopped) {
      var l = this, v = l.source, p = l.count;
      if (p === 0)
        return a.prototype.error.call(this, c);
      p > -1 && (this.count = p - 1), v.subscribe(this._unsubscribeAndRecycle());
    }
  }, u;
}(Subscriber);
function retryWhen(a) {
  return function(u) {
    return u.lift(new RetryWhenOperator(a, u));
  };
}
var RetryWhenOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.notifier = u, this.source = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new RetryWhenSubscriber(u, this.notifier, this.source));
  }, a;
}(), RetryWhenSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.notifier = l, p.source = v, p;
  }
  return u.prototype.error = function(c) {
    if (!this.isStopped) {
      var l = this.errors, v = this.retries, p = this.retriesSubscription;
      if (v)
        this.errors = void 0, this.retriesSubscription = void 0;
      else {
        l = new Subject();
        try {
          var _ = this.notifier;
          v = _(l);
        } catch (k) {
          return a.prototype.error.call(this, k);
        }
        p = innerSubscribe(v, new SimpleInnerSubscriber(this));
      }
      this._unsubscribeAndRecycle(), this.errors = l, this.retries = v, this.retriesSubscription = p, l.next(c);
    }
  }, u.prototype._unsubscribe = function() {
    var c = this, l = c.errors, v = c.retriesSubscription;
    l && (l.unsubscribe(), this.errors = void 0), v && (v.unsubscribe(), this.retriesSubscription = void 0), this.retries = void 0;
  }, u.prototype.notifyNext = function() {
    var c = this._unsubscribe;
    this._unsubscribe = null, this._unsubscribeAndRecycle(), this._unsubscribe = c, this.source.subscribe(this);
  }, u;
}(SimpleOuterSubscriber);
function sample(a) {
  return function(u) {
    return u.lift(new SampleOperator(a));
  };
}
var SampleOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.notifier = u;
  }
  return a.prototype.call = function(u, c) {
    var l = new SampleSubscriber(u), v = c.subscribe(l);
    return v.add(innerSubscribe(this.notifier, new SimpleInnerSubscriber(l))), v;
  }, a;
}(), SampleSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u() {
    var c = a !== null && a.apply(this, arguments) || this;
    return c.hasValue = !1, c;
  }
  return u.prototype._next = function(c) {
    this.value = c, this.hasValue = !0;
  }, u.prototype.notifyNext = function() {
    this.emitValue();
  }, u.prototype.notifyComplete = function() {
    this.emitValue();
  }, u.prototype.emitValue = function() {
    this.hasValue && (this.hasValue = !1, this.destination.next(this.value));
  }, u;
}(SimpleOuterSubscriber);
function sampleTime(a, u) {
  return u === void 0 && (u = async$1), function(c) {
    return c.lift(new SampleTimeOperator(a, u));
  };
}
var SampleTimeOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.period = u, this.scheduler = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new SampleTimeSubscriber(u, this.period, this.scheduler));
  }, a;
}(), SampleTimeSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.period = l, p.scheduler = v, p.hasValue = !1, p.add(v.schedule(dispatchNotification, l, { subscriber: p, period: l })), p;
  }
  return u.prototype._next = function(c) {
    this.lastValue = c, this.hasValue = !0;
  }, u.prototype.notifyNext = function() {
    this.hasValue && (this.hasValue = !1, this.destination.next(this.lastValue));
  }, u;
}(Subscriber);
function dispatchNotification(a) {
  var u = a.subscriber, c = a.period;
  u.notifyNext(), this.schedule(a, c);
}
function sequenceEqual(a, u) {
  return function(c) {
    return c.lift(new SequenceEqualOperator(a, u));
  };
}
var SequenceEqualOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.compareTo = u, this.comparator = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new SequenceEqualSubscriber(u, this.compareTo, this.comparator));
  }, a;
}(), SequenceEqualSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.compareTo = l, p.comparator = v, p._a = [], p._b = [], p._oneComplete = !1, p.destination.add(l.subscribe(new SequenceEqualCompareToSubscriber(c, p))), p;
  }
  return u.prototype._next = function(c) {
    this._oneComplete && this._b.length === 0 ? this.emit(!1) : (this._a.push(c), this.checkValues());
  }, u.prototype._complete = function() {
    this._oneComplete ? this.emit(this._a.length === 0 && this._b.length === 0) : this._oneComplete = !0, this.unsubscribe();
  }, u.prototype.checkValues = function() {
    for (var c = this, l = c._a, v = c._b, p = c.comparator; l.length > 0 && v.length > 0; ) {
      var _ = l.shift(), k = v.shift(), O = !1;
      try {
        O = p ? p(_, k) : _ === k;
      } catch (D) {
        this.destination.error(D);
      }
      O || this.emit(!1);
    }
  }, u.prototype.emit = function(c) {
    var l = this.destination;
    l.next(c), l.complete();
  }, u.prototype.nextB = function(c) {
    this._oneComplete && this._a.length === 0 ? this.emit(!1) : (this._b.push(c), this.checkValues());
  }, u.prototype.completeB = function() {
    this._oneComplete ? this.emit(this._a.length === 0 && this._b.length === 0) : this._oneComplete = !0;
  }, u;
}(Subscriber), SequenceEqualCompareToSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.parent = l, v;
  }
  return u.prototype._next = function(c) {
    this.parent.nextB(c);
  }, u.prototype._error = function(c) {
    this.parent.error(c), this.unsubscribe();
  }, u.prototype._complete = function() {
    this.parent.completeB(), this.unsubscribe();
  }, u;
}(Subscriber);
function shareSubjectFactory() {
  return new Subject();
}
function share() {
  return function(a) {
    return refCount()(multicast(shareSubjectFactory)(a));
  };
}
function shareReplay(a, u, c) {
  var l;
  return a && typeof a == "object" ? l = a : l = {
    bufferSize: a,
    windowTime: u,
    refCount: !1,
    scheduler: c
  }, function(v) {
    return v.lift(shareReplayOperator(l));
  };
}
function shareReplayOperator(a) {
  var u = a.bufferSize, c = u === void 0 ? Number.POSITIVE_INFINITY : u, l = a.windowTime, v = l === void 0 ? Number.POSITIVE_INFINITY : l, p = a.refCount, _ = a.scheduler, k, O = 0, D, F = !1, H = !1;
  return function(ee) {
    O++;
    var X;
    !k || F ? (F = !1, k = new ReplaySubject(c, v, _), X = k.subscribe(this), D = ee.subscribe({
      next: function(ne) {
        k.next(ne);
      },
      error: function(ne) {
        F = !0, k.error(ne);
      },
      complete: function() {
        H = !0, D = void 0, k.complete();
      }
    }), H && (D = void 0)) : X = k.subscribe(this), this.add(function() {
      O--, X.unsubscribe(), X = void 0, D && !H && p && O === 0 && (D.unsubscribe(), D = void 0, k = void 0);
    });
  };
}
function single(a) {
  return function(u) {
    return u.lift(new SingleOperator(a, u));
  };
}
var SingleOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.predicate = u, this.source = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new SingleSubscriber(u, this.predicate, this.source));
  }, a;
}(), SingleSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.predicate = l, p.source = v, p.seenValue = !1, p.index = 0, p;
  }
  return u.prototype.applySingleValue = function(c) {
    this.seenValue ? this.destination.error("Sequence contains more than one element") : (this.seenValue = !0, this.singleValue = c);
  }, u.prototype._next = function(c) {
    var l = this.index++;
    this.predicate ? this.tryNext(c, l) : this.applySingleValue(c);
  }, u.prototype.tryNext = function(c, l) {
    try {
      this.predicate(c, l, this.source) && this.applySingleValue(c);
    } catch (v) {
      this.destination.error(v);
    }
  }, u.prototype._complete = function() {
    var c = this.destination;
    this.index > 0 ? (c.next(this.seenValue ? this.singleValue : void 0), c.complete()) : c.error(new EmptyError());
  }, u;
}(Subscriber);
function skip(a) {
  return function(u) {
    return u.lift(new SkipOperator(a));
  };
}
var SkipOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.total = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new SkipSubscriber(u, this.total));
  }, a;
}(), SkipSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.total = l, v.count = 0, v;
  }
  return u.prototype._next = function(c) {
    ++this.count > this.total && this.destination.next(c);
  }, u;
}(Subscriber);
function skipLast(a) {
  return function(u) {
    return u.lift(new SkipLastOperator(a));
  };
}
var SkipLastOperator = /* @__PURE__ */ function() {
  function a(u) {
    if (this._skipCount = u, this._skipCount < 0)
      throw new ArgumentOutOfRangeError();
  }
  return a.prototype.call = function(u, c) {
    return this._skipCount === 0 ? c.subscribe(new Subscriber(u)) : c.subscribe(new SkipLastSubscriber(u, this._skipCount));
  }, a;
}(), SkipLastSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v._skipCount = l, v._count = 0, v._ring = new Array(l), v;
  }
  return u.prototype._next = function(c) {
    var l = this._skipCount, v = this._count++;
    if (v < l)
      this._ring[v] = c;
    else {
      var p = v % l, _ = this._ring, k = _[p];
      _[p] = c, this.destination.next(k);
    }
  }, u;
}(Subscriber);
function skipUntil(a) {
  return function(u) {
    return u.lift(new SkipUntilOperator(a));
  };
}
var SkipUntilOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.notifier = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new SkipUntilSubscriber(u, this.notifier));
  }, a;
}(), SkipUntilSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    v.hasValue = !1;
    var p = new SimpleInnerSubscriber(v);
    v.add(p), v.innerSubscription = p;
    var _ = innerSubscribe(l, p);
    return _ !== p && (v.add(_), v.innerSubscription = _), v;
  }
  return u.prototype._next = function(c) {
    this.hasValue && a.prototype._next.call(this, c);
  }, u.prototype.notifyNext = function() {
    this.hasValue = !0, this.innerSubscription && this.innerSubscription.unsubscribe();
  }, u.prototype.notifyComplete = function() {
  }, u;
}(SimpleOuterSubscriber);
function skipWhile(a) {
  return function(u) {
    return u.lift(new SkipWhileOperator(a));
  };
}
var SkipWhileOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.predicate = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new SkipWhileSubscriber(u, this.predicate));
  }, a;
}(), SkipWhileSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.predicate = l, v.skipping = !0, v.index = 0, v;
  }
  return u.prototype._next = function(c) {
    var l = this.destination;
    this.skipping && this.tryCallPredicate(c), this.skipping || l.next(c);
  }, u.prototype.tryCallPredicate = function(c) {
    try {
      var l = this.predicate(c, this.index++);
      this.skipping = !!l;
    } catch (v) {
      this.destination.error(v);
    }
  }, u;
}(Subscriber);
function startWith() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  var c = a[a.length - 1];
  return isScheduler(c) ? (a.pop(), function(l) {
    return concat$1(a, l, c);
  }) : function(l) {
    return concat$1(a, l);
  };
}
var nextHandle = 1, RESOLVED = /* @__PURE__ */ function() {
  return /* @__PURE__ */ Promise.resolve();
}(), activeHandles = {};
function findAndClearHandle(a) {
  return a in activeHandles ? (delete activeHandles[a], !0) : !1;
}
var Immediate = {
  setImmediate: function(a) {
    var u = nextHandle++;
    return activeHandles[u] = !0, RESOLVED.then(function() {
      return findAndClearHandle(u) && a();
    }), u;
  },
  clearImmediate: function(a) {
    findAndClearHandle(a);
  }
}, AsapAction = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c, l) || this;
    return v.scheduler = c, v.work = l, v;
  }
  return u.prototype.requestAsyncId = function(c, l, v) {
    return v === void 0 && (v = 0), v !== null && v > 0 ? a.prototype.requestAsyncId.call(this, c, l, v) : (c.actions.push(this), c.scheduled || (c.scheduled = Immediate.setImmediate(c.flush.bind(c, null))));
  }, u.prototype.recycleAsyncId = function(c, l, v) {
    if (v === void 0 && (v = 0), v !== null && v > 0 || v === null && this.delay > 0)
      return a.prototype.recycleAsyncId.call(this, c, l, v);
    c.actions.length === 0 && (Immediate.clearImmediate(l), c.scheduled = void 0);
  }, u;
}(AsyncAction), AsapScheduler = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u() {
    return a !== null && a.apply(this, arguments) || this;
  }
  return u.prototype.flush = function(c) {
    this.active = !0, this.scheduled = void 0;
    var l = this.actions, v, p = -1, _ = l.length;
    c = c || l.shift();
    do
      if (v = c.execute(c.state, c.delay))
        break;
    while (++p < _ && (c = l.shift()));
    if (this.active = !1, v) {
      for (; ++p < _ && (c = l.shift()); )
        c.unsubscribe();
      throw v;
    }
  }, u;
}(AsyncScheduler), asapScheduler = /* @__PURE__ */ new AsapScheduler(AsapAction), asap = asapScheduler, SubscribeOnObservable = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    l === void 0 && (l = 0), v === void 0 && (v = asap);
    var p = a.call(this) || this;
    return p.source = c, p.delayTime = l, p.scheduler = v, (!isNumeric(l) || l < 0) && (p.delayTime = 0), (!v || typeof v.schedule != "function") && (p.scheduler = asap), p;
  }
  return u.create = function(c, l, v) {
    return l === void 0 && (l = 0), v === void 0 && (v = asap), new u(c, l, v);
  }, u.dispatch = function(c) {
    var l = c.source, v = c.subscriber;
    return this.add(l.subscribe(v));
  }, u.prototype._subscribe = function(c) {
    var l = this.delayTime, v = this.source, p = this.scheduler;
    return p.schedule(u.dispatch, l, {
      source: v,
      subscriber: c
    });
  }, u;
}(Observable);
function subscribeOn(a, u) {
  return u === void 0 && (u = 0), function(l) {
    return l.lift(new SubscribeOnOperator(a, u));
  };
}
var SubscribeOnOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.scheduler = u, this.delay = c;
  }
  return a.prototype.call = function(u, c) {
    return new SubscribeOnObservable(c, this.delay, this.scheduler).subscribe(u);
  }, a;
}();
function switchMap(a, u) {
  return typeof u == "function" ? function(c) {
    return c.pipe(switchMap(function(l, v) {
      return from(a(l, v)).pipe(map(function(p, _) {
        return u(l, p, v, _);
      }));
    }));
  } : function(c) {
    return c.lift(new SwitchMapOperator(a));
  };
}
var SwitchMapOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.project = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new SwitchMapSubscriber(u, this.project));
  }, a;
}(), SwitchMapSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.project = l, v.index = 0, v;
  }
  return u.prototype._next = function(c) {
    var l, v = this.index++;
    try {
      l = this.project(c, v);
    } catch (p) {
      this.destination.error(p);
      return;
    }
    this._innerSub(l);
  }, u.prototype._innerSub = function(c) {
    var l = this.innerSubscription;
    l && l.unsubscribe();
    var v = new SimpleInnerSubscriber(this), p = this.destination;
    p.add(v), this.innerSubscription = innerSubscribe(c, v), this.innerSubscription !== v && p.add(this.innerSubscription);
  }, u.prototype._complete = function() {
    var c = this.innerSubscription;
    (!c || c.closed) && a.prototype._complete.call(this), this.unsubscribe();
  }, u.prototype._unsubscribe = function() {
    this.innerSubscription = void 0;
  }, u.prototype.notifyComplete = function() {
    this.innerSubscription = void 0, this.isStopped && a.prototype._complete.call(this);
  }, u.prototype.notifyNext = function(c) {
    this.destination.next(c);
  }, u;
}(SimpleOuterSubscriber);
function switchAll() {
  return switchMap(identity$1);
}
function switchMapTo(a, u) {
  return u ? switchMap(function() {
    return a;
  }, u) : switchMap(function() {
    return a;
  });
}
function takeUntil(a) {
  return function(u) {
    return u.lift(new TakeUntilOperator(a));
  };
}
var TakeUntilOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.notifier = u;
  }
  return a.prototype.call = function(u, c) {
    var l = new TakeUntilSubscriber(u), v = innerSubscribe(this.notifier, new SimpleInnerSubscriber(l));
    return v && !l.seenValue ? (l.add(v), c.subscribe(l)) : l;
  }, a;
}(), TakeUntilSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c) {
    var l = a.call(this, c) || this;
    return l.seenValue = !1, l;
  }
  return u.prototype.notifyNext = function() {
    this.seenValue = !0, this.complete();
  }, u.prototype.notifyComplete = function() {
  }, u;
}(SimpleOuterSubscriber);
function takeWhile(a, u) {
  return u === void 0 && (u = !1), function(c) {
    return c.lift(new TakeWhileOperator(a, u));
  };
}
var TakeWhileOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.predicate = u, this.inclusive = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new TakeWhileSubscriber(u, this.predicate, this.inclusive));
  }, a;
}(), TakeWhileSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.predicate = l, p.inclusive = v, p.index = 0, p;
  }
  return u.prototype._next = function(c) {
    var l = this.destination, v;
    try {
      v = this.predicate(c, this.index++);
    } catch (p) {
      l.error(p);
      return;
    }
    this.nextOrComplete(c, v);
  }, u.prototype.nextOrComplete = function(c, l) {
    var v = this.destination;
    l ? v.next(c) : (this.inclusive && v.next(c), v.complete());
  }, u;
}(Subscriber);
function noop$6() {
}
function tap(a, u, c) {
  return function(v) {
    return v.lift(new DoOperator(a, u, c));
  };
}
var DoOperator = /* @__PURE__ */ function() {
  function a(u, c, l) {
    this.nextOrObserver = u, this.error = c, this.complete = l;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new TapSubscriber(u, this.nextOrObserver, this.error, this.complete));
  }, a;
}(), TapSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v, p) {
    var _ = a.call(this, c) || this;
    return _._tapNext = noop$6, _._tapError = noop$6, _._tapComplete = noop$6, _._tapError = v || noop$6, _._tapComplete = p || noop$6, isFunction$3(l) ? (_._context = _, _._tapNext = l) : l && (_._context = l, _._tapNext = l.next || noop$6, _._tapError = l.error || noop$6, _._tapComplete = l.complete || noop$6), _;
  }
  return u.prototype._next = function(c) {
    try {
      this._tapNext.call(this._context, c);
    } catch (l) {
      this.destination.error(l);
      return;
    }
    this.destination.next(c);
  }, u.prototype._error = function(c) {
    try {
      this._tapError.call(this._context, c);
    } catch (l) {
      this.destination.error(l);
      return;
    }
    this.destination.error(c);
  }, u.prototype._complete = function() {
    try {
      this._tapComplete.call(this._context);
    } catch (c) {
      this.destination.error(c);
      return;
    }
    return this.destination.complete();
  }, u;
}(Subscriber), defaultThrottleConfig = {
  leading: !0,
  trailing: !1
};
function throttle(a, u) {
  return u === void 0 && (u = defaultThrottleConfig), function(c) {
    return c.lift(new ThrottleOperator(a, !!u.leading, !!u.trailing));
  };
}
var ThrottleOperator = /* @__PURE__ */ function() {
  function a(u, c, l) {
    this.durationSelector = u, this.leading = c, this.trailing = l;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new ThrottleSubscriber(u, this.durationSelector, this.leading, this.trailing));
  }, a;
}(), ThrottleSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v, p) {
    var _ = a.call(this, c) || this;
    return _.destination = c, _.durationSelector = l, _._leading = v, _._trailing = p, _._hasValue = !1, _;
  }
  return u.prototype._next = function(c) {
    this._hasValue = !0, this._sendValue = c, this._throttled || (this._leading ? this.send() : this.throttle(c));
  }, u.prototype.send = function() {
    var c = this, l = c._hasValue, v = c._sendValue;
    l && (this.destination.next(v), this.throttle(v)), this._hasValue = !1, this._sendValue = void 0;
  }, u.prototype.throttle = function(c) {
    var l = this.tryDurationSelector(c);
    l && this.add(this._throttled = innerSubscribe(l, new SimpleInnerSubscriber(this)));
  }, u.prototype.tryDurationSelector = function(c) {
    try {
      return this.durationSelector(c);
    } catch (l) {
      return this.destination.error(l), null;
    }
  }, u.prototype.throttlingDone = function() {
    var c = this, l = c._throttled, v = c._trailing;
    l && l.unsubscribe(), this._throttled = void 0, v && this.send();
  }, u.prototype.notifyNext = function() {
    this.throttlingDone();
  }, u.prototype.notifyComplete = function() {
    this.throttlingDone();
  }, u;
}(SimpleOuterSubscriber);
function throttleTime(a, u, c) {
  return u === void 0 && (u = async$1), c === void 0 && (c = defaultThrottleConfig), function(l) {
    return l.lift(new ThrottleTimeOperator(a, u, c.leading, c.trailing));
  };
}
var ThrottleTimeOperator = /* @__PURE__ */ function() {
  function a(u, c, l, v) {
    this.duration = u, this.scheduler = c, this.leading = l, this.trailing = v;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new ThrottleTimeSubscriber(u, this.duration, this.scheduler, this.leading, this.trailing));
  }, a;
}(), ThrottleTimeSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v, p, _) {
    var k = a.call(this, c) || this;
    return k.duration = l, k.scheduler = v, k.leading = p, k.trailing = _, k._hasTrailingValue = !1, k._trailingValue = null, k;
  }
  return u.prototype._next = function(c) {
    this.throttled ? this.trailing && (this._trailingValue = c, this._hasTrailingValue = !0) : (this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, { subscriber: this })), this.leading ? this.destination.next(c) : this.trailing && (this._trailingValue = c, this._hasTrailingValue = !0));
  }, u.prototype._complete = function() {
    this._hasTrailingValue ? (this.destination.next(this._trailingValue), this.destination.complete()) : this.destination.complete();
  }, u.prototype.clearThrottle = function() {
    var c = this.throttled;
    c && (this.trailing && this._hasTrailingValue && (this.destination.next(this._trailingValue), this._trailingValue = null, this._hasTrailingValue = !1), c.unsubscribe(), this.remove(c), this.throttled = null);
  }, u;
}(Subscriber);
function dispatchNext(a) {
  var u = a.subscriber;
  u.clearThrottle();
}
function defer(a) {
  return new Observable(function(u) {
    var c;
    try {
      c = a();
    } catch (v) {
      u.error(v);
      return;
    }
    var l = c ? from(c) : empty$2();
    return l.subscribe(u);
  });
}
function timeInterval(a) {
  return a === void 0 && (a = async$1), function(u) {
    return defer(function() {
      return u.pipe(scan(function(c, l) {
        var v = c.current;
        return { value: l, current: a.now(), last: v };
      }, { current: a.now(), value: void 0, last: void 0 }), map(function(c) {
        var l = c.current, v = c.last, p = c.value;
        return new TimeInterval(p, l - v);
      }));
    });
  };
}
var TimeInterval = /* @__PURE__ */ function() {
  function a(u, c) {
    this.value = u, this.interval = c;
  }
  return a;
}(), TimeoutErrorImpl = /* @__PURE__ */ function() {
  function a() {
    return Error.call(this), this.message = "Timeout has occurred", this.name = "TimeoutError", this;
  }
  return a.prototype = /* @__PURE__ */ Object.create(Error.prototype), a;
}(), TimeoutError = TimeoutErrorImpl;
function timeoutWith(a, u, c) {
  return c === void 0 && (c = async$1), function(l) {
    var v = isDate$1(a), p = v ? +a - c.now() : Math.abs(a);
    return l.lift(new TimeoutWithOperator(p, v, u, c));
  };
}
var TimeoutWithOperator = /* @__PURE__ */ function() {
  function a(u, c, l, v) {
    this.waitFor = u, this.absoluteTimeout = c, this.withObservable = l, this.scheduler = v;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new TimeoutWithSubscriber(u, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));
  }, a;
}(), TimeoutWithSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v, p, _) {
    var k = a.call(this, c) || this;
    return k.absoluteTimeout = l, k.waitFor = v, k.withObservable = p, k.scheduler = _, k.scheduleTimeout(), k;
  }
  return u.dispatchTimeout = function(c) {
    var l = c.withObservable;
    c._unsubscribeAndRecycle(), c.add(innerSubscribe(l, new SimpleInnerSubscriber(c)));
  }, u.prototype.scheduleTimeout = function() {
    var c = this.action;
    c ? this.action = c.schedule(this, this.waitFor) : this.add(this.action = this.scheduler.schedule(u.dispatchTimeout, this.waitFor, this));
  }, u.prototype._next = function(c) {
    this.absoluteTimeout || this.scheduleTimeout(), a.prototype._next.call(this, c);
  }, u.prototype._unsubscribe = function() {
    this.action = void 0, this.scheduler = null, this.withObservable = null;
  }, u;
}(SimpleOuterSubscriber);
function timeout(a, u) {
  return u === void 0 && (u = async$1), timeoutWith(a, throwError(new TimeoutError()), u);
}
function timestamp$1(a) {
  return a === void 0 && (a = async$1), map(function(u) {
    return new Timestamp$1(u, a.now());
  });
}
var Timestamp$1 = /* @__PURE__ */ function() {
  function a(u, c) {
    this.value = u, this.timestamp = c;
  }
  return a;
}();
function toArrayReducer(a, u, c) {
  return c === 0 ? [u] : (a.push(u), a);
}
function toArray$2() {
  return reduce(toArrayReducer, []);
}
function window$1(a) {
  return function(c) {
    return c.lift(new WindowOperator$1(a));
  };
}
var WindowOperator$1 = /* @__PURE__ */ function() {
  function a(u) {
    this.windowBoundaries = u;
  }
  return a.prototype.call = function(u, c) {
    var l = new WindowSubscriber$1(u), v = c.subscribe(l);
    return v.closed || l.add(innerSubscribe(this.windowBoundaries, new SimpleInnerSubscriber(l))), v;
  }, a;
}(), WindowSubscriber$1 = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c) {
    var l = a.call(this, c) || this;
    return l.window = new Subject(), c.next(l.window), l;
  }
  return u.prototype.notifyNext = function() {
    this.openWindow();
  }, u.prototype.notifyError = function(c) {
    this._error(c);
  }, u.prototype.notifyComplete = function() {
    this._complete();
  }, u.prototype._next = function(c) {
    this.window.next(c);
  }, u.prototype._error = function(c) {
    this.window.error(c), this.destination.error(c);
  }, u.prototype._complete = function() {
    this.window.complete(), this.destination.complete();
  }, u.prototype._unsubscribe = function() {
    this.window = null;
  }, u.prototype.openWindow = function() {
    var c = this.window;
    c && c.complete();
    var l = this.destination, v = this.window = new Subject();
    l.next(v);
  }, u;
}(SimpleOuterSubscriber);
function windowCount(a, u) {
  return u === void 0 && (u = 0), function(l) {
    return l.lift(new WindowCountOperator(a, u));
  };
}
var WindowCountOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.windowSize = u, this.startWindowEvery = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new WindowCountSubscriber(u, this.windowSize, this.startWindowEvery));
  }, a;
}(), WindowCountSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.destination = c, p.windowSize = l, p.startWindowEvery = v, p.windows = [new Subject()], p.count = 0, c.next(p.windows[0]), p;
  }
  return u.prototype._next = function(c) {
    for (var l = this.startWindowEvery > 0 ? this.startWindowEvery : this.windowSize, v = this.destination, p = this.windowSize, _ = this.windows, k = _.length, O = 0; O < k && !this.closed; O++)
      _[O].next(c);
    var D = this.count - p + 1;
    if (D >= 0 && D % l === 0 && !this.closed && _.shift().complete(), ++this.count % l === 0 && !this.closed) {
      var F = new Subject();
      _.push(F), v.next(F);
    }
  }, u.prototype._error = function(c) {
    var l = this.windows;
    if (l)
      for (; l.length > 0 && !this.closed; )
        l.shift().error(c);
    this.destination.error(c);
  }, u.prototype._complete = function() {
    var c = this.windows;
    if (c)
      for (; c.length > 0 && !this.closed; )
        c.shift().complete();
    this.destination.complete();
  }, u.prototype._unsubscribe = function() {
    this.count = 0, this.windows = null;
  }, u;
}(Subscriber);
function windowTime(a) {
  var u = async$1, c = null, l = Number.POSITIVE_INFINITY;
  return isScheduler(arguments[3]) && (u = arguments[3]), isScheduler(arguments[2]) ? u = arguments[2] : isNumeric(arguments[2]) && (l = Number(arguments[2])), isScheduler(arguments[1]) ? u = arguments[1] : isNumeric(arguments[1]) && (c = Number(arguments[1])), function(p) {
    return p.lift(new WindowTimeOperator(a, c, l, u));
  };
}
var WindowTimeOperator = /* @__PURE__ */ function() {
  function a(u, c, l, v) {
    this.windowTimeSpan = u, this.windowCreationInterval = c, this.maxWindowSize = l, this.scheduler = v;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new WindowTimeSubscriber(u, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));
  }, a;
}(), CountedSubject = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u() {
    var c = a !== null && a.apply(this, arguments) || this;
    return c._numberOfNextedValues = 0, c;
  }
  return u.prototype.next = function(c) {
    this._numberOfNextedValues++, a.prototype.next.call(this, c);
  }, Object.defineProperty(u.prototype, "numberOfNextedValues", {
    get: function() {
      return this._numberOfNextedValues;
    },
    enumerable: !0,
    configurable: !0
  }), u;
}(Subject), WindowTimeSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v, p, _) {
    var k = a.call(this, c) || this;
    k.destination = c, k.windowTimeSpan = l, k.windowCreationInterval = v, k.maxWindowSize = p, k.scheduler = _, k.windows = [];
    var O = k.openWindow();
    if (v !== null && v >= 0) {
      var D = { subscriber: k, window: O, context: null }, F = { windowTimeSpan: l, windowCreationInterval: v, subscriber: k, scheduler: _ };
      k.add(_.schedule(dispatchWindowClose, l, D)), k.add(_.schedule(dispatchWindowCreation, v, F));
    } else {
      var H = { subscriber: k, window: O, windowTimeSpan: l };
      k.add(_.schedule(dispatchWindowTimeSpanOnly, l, H));
    }
    return k;
  }
  return u.prototype._next = function(c) {
    for (var l = this.windows, v = l.length, p = 0; p < v; p++) {
      var _ = l[p];
      _.closed || (_.next(c), _.numberOfNextedValues >= this.maxWindowSize && this.closeWindow(_));
    }
  }, u.prototype._error = function(c) {
    for (var l = this.windows; l.length > 0; )
      l.shift().error(c);
    this.destination.error(c);
  }, u.prototype._complete = function() {
    for (var c = this.windows; c.length > 0; ) {
      var l = c.shift();
      l.closed || l.complete();
    }
    this.destination.complete();
  }, u.prototype.openWindow = function() {
    var c = new CountedSubject();
    this.windows.push(c);
    var l = this.destination;
    return l.next(c), c;
  }, u.prototype.closeWindow = function(c) {
    c.complete();
    var l = this.windows;
    l.splice(l.indexOf(c), 1);
  }, u;
}(Subscriber);
function dispatchWindowTimeSpanOnly(a) {
  var u = a.subscriber, c = a.windowTimeSpan, l = a.window;
  l && u.closeWindow(l), a.window = u.openWindow(), this.schedule(a, c);
}
function dispatchWindowCreation(a) {
  var u = a.windowTimeSpan, c = a.subscriber, l = a.scheduler, v = a.windowCreationInterval, p = c.openWindow(), _ = this, k = { action: _, subscription: null }, O = { subscriber: c, window: p, context: k };
  k.subscription = l.schedule(dispatchWindowClose, u, O), _.add(k.subscription), _.schedule(a, v);
}
function dispatchWindowClose(a) {
  var u = a.subscriber, c = a.window, l = a.context;
  l && l.action && l.subscription && l.action.remove(l.subscription), u.closeWindow(c);
}
function windowToggle(a, u) {
  return function(c) {
    return c.lift(new WindowToggleOperator(a, u));
  };
}
var WindowToggleOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.openings = u, this.closingSelector = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new WindowToggleSubscriber(u, this.openings, this.closingSelector));
  }, a;
}(), WindowToggleSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.openings = l, p.closingSelector = v, p.contexts = [], p.add(p.openSubscription = subscribeToResult(p, l, l)), p;
  }
  return u.prototype._next = function(c) {
    var l = this.contexts;
    if (l)
      for (var v = l.length, p = 0; p < v; p++)
        l[p].window.next(c);
  }, u.prototype._error = function(c) {
    var l = this.contexts;
    if (this.contexts = null, l)
      for (var v = l.length, p = -1; ++p < v; ) {
        var _ = l[p];
        _.window.error(c), _.subscription.unsubscribe();
      }
    a.prototype._error.call(this, c);
  }, u.prototype._complete = function() {
    var c = this.contexts;
    if (this.contexts = null, c)
      for (var l = c.length, v = -1; ++v < l; ) {
        var p = c[v];
        p.window.complete(), p.subscription.unsubscribe();
      }
    a.prototype._complete.call(this);
  }, u.prototype._unsubscribe = function() {
    var c = this.contexts;
    if (this.contexts = null, c)
      for (var l = c.length, v = -1; ++v < l; ) {
        var p = c[v];
        p.window.unsubscribe(), p.subscription.unsubscribe();
      }
  }, u.prototype.notifyNext = function(c, l, v, p, _) {
    if (c === this.openings) {
      var k = void 0;
      try {
        var O = this.closingSelector;
        k = O(l);
      } catch (ee) {
        return this.error(ee);
      }
      var D = new Subject(), F = new Subscription(), H = { window: D, subscription: F };
      this.contexts.push(H);
      var Z = subscribeToResult(this, k, H);
      Z.closed ? this.closeWindow(this.contexts.length - 1) : (Z.context = H, F.add(Z)), this.destination.next(D);
    } else
      this.closeWindow(this.contexts.indexOf(c));
  }, u.prototype.notifyError = function(c) {
    this.error(c);
  }, u.prototype.notifyComplete = function(c) {
    c !== this.openSubscription && this.closeWindow(this.contexts.indexOf(c.context));
  }, u.prototype.closeWindow = function(c) {
    if (c !== -1) {
      var l = this.contexts, v = l[c], p = v.window, _ = v.subscription;
      l.splice(c, 1), p.complete(), _.unsubscribe();
    }
  }, u;
}(OuterSubscriber);
function windowWhen(a) {
  return function(c) {
    return c.lift(new WindowOperator(a));
  };
}
var WindowOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.closingSelector = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new WindowSubscriber(u, this.closingSelector));
  }, a;
}(), WindowSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.destination = c, v.closingSelector = l, v.openWindow(), v;
  }
  return u.prototype.notifyNext = function(c, l, v, p, _) {
    this.openWindow(_);
  }, u.prototype.notifyError = function(c) {
    this._error(c);
  }, u.prototype.notifyComplete = function(c) {
    this.openWindow(c);
  }, u.prototype._next = function(c) {
    this.window.next(c);
  }, u.prototype._error = function(c) {
    this.window.error(c), this.destination.error(c), this.unsubscribeClosingNotification();
  }, u.prototype._complete = function() {
    this.window.complete(), this.destination.complete(), this.unsubscribeClosingNotification();
  }, u.prototype.unsubscribeClosingNotification = function() {
    this.closingNotification && this.closingNotification.unsubscribe();
  }, u.prototype.openWindow = function(c) {
    c === void 0 && (c = null), c && (this.remove(c), c.unsubscribe());
    var l = this.window;
    l && l.complete();
    var v = this.window = new Subject();
    this.destination.next(v);
    var p;
    try {
      var _ = this.closingSelector;
      p = _();
    } catch (k) {
      this.destination.error(k), this.window.error(k);
      return;
    }
    this.add(this.closingNotification = subscribeToResult(this, p));
  }, u;
}(OuterSubscriber);
function withLatestFrom() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  return function(c) {
    var l;
    typeof a[a.length - 1] == "function" && (l = a.pop());
    var v = a;
    return c.lift(new WithLatestFromOperator(v, l));
  };
}
var WithLatestFromOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.observables = u, this.project = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new WithLatestFromSubscriber(u, this.observables, this.project));
  }, a;
}(), WithLatestFromSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    p.observables = l, p.project = v, p.toRespond = [];
    var _ = l.length;
    p.values = new Array(_);
    for (var k = 0; k < _; k++)
      p.toRespond.push(k);
    for (var k = 0; k < _; k++) {
      var O = l[k];
      p.add(subscribeToResult(p, O, void 0, k));
    }
    return p;
  }
  return u.prototype.notifyNext = function(c, l, v) {
    this.values[v] = l;
    var p = this.toRespond;
    if (p.length > 0) {
      var _ = p.indexOf(v);
      _ !== -1 && p.splice(_, 1);
    }
  }, u.prototype.notifyComplete = function() {
  }, u.prototype._next = function(c) {
    if (this.toRespond.length === 0) {
      var l = [c].concat(this.values);
      this.project ? this._tryProject(l) : this.destination.next(l);
    }
  }, u.prototype._tryProject = function(c) {
    var l;
    try {
      l = this.project.apply(this, c);
    } catch (v) {
      this.destination.error(v);
      return;
    }
    this.destination.next(l);
  }, u;
}(OuterSubscriber);
function zip$1() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  var c = a[a.length - 1];
  return typeof c == "function" && a.pop(), fromArray$1(a, void 0).lift(new ZipOperator(c));
}
var ZipOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.resultSelector = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new ZipSubscriber(u, this.resultSelector));
  }, a;
}(), ZipSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.resultSelector = l, p.iterators = [], p.active = 0, p.resultSelector = typeof l == "function" ? l : void 0, p;
  }
  return u.prototype._next = function(c) {
    var l = this.iterators;
    isArray$5(c) ? l.push(new StaticArrayIterator(c)) : typeof c[iterator] == "function" ? l.push(new StaticIterator(c[iterator]())) : l.push(new ZipBufferIterator(this.destination, this, c));
  }, u.prototype._complete = function() {
    var c = this.iterators, l = c.length;
    if (this.unsubscribe(), l === 0) {
      this.destination.complete();
      return;
    }
    this.active = l;
    for (var v = 0; v < l; v++) {
      var p = c[v];
      if (p.stillUnsubscribed) {
        var _ = this.destination;
        _.add(p.subscribe());
      } else
        this.active--;
    }
  }, u.prototype.notifyInactive = function() {
    this.active--, this.active === 0 && this.destination.complete();
  }, u.prototype.checkIterators = function() {
    for (var c = this.iterators, l = c.length, v = this.destination, p = 0; p < l; p++) {
      var _ = c[p];
      if (typeof _.hasValue == "function" && !_.hasValue())
        return;
    }
    for (var k = !1, O = [], p = 0; p < l; p++) {
      var _ = c[p], D = _.next();
      if (_.hasCompleted() && (k = !0), D.done) {
        v.complete();
        return;
      }
      O.push(D.value);
    }
    this.resultSelector ? this._tryresultSelector(O) : v.next(O), k && v.complete();
  }, u.prototype._tryresultSelector = function(c) {
    var l;
    try {
      l = this.resultSelector.apply(this, c);
    } catch (v) {
      this.destination.error(v);
      return;
    }
    this.destination.next(l);
  }, u;
}(Subscriber), StaticIterator = /* @__PURE__ */ function() {
  function a(u) {
    this.iterator = u, this.nextResult = u.next();
  }
  return a.prototype.hasValue = function() {
    return !0;
  }, a.prototype.next = function() {
    var u = this.nextResult;
    return this.nextResult = this.iterator.next(), u;
  }, a.prototype.hasCompleted = function() {
    var u = this.nextResult;
    return !!(u && u.done);
  }, a;
}(), StaticArrayIterator = /* @__PURE__ */ function() {
  function a(u) {
    this.array = u, this.index = 0, this.length = 0, this.length = u.length;
  }
  return a.prototype[iterator] = function() {
    return this;
  }, a.prototype.next = function(u) {
    var c = this.index++, l = this.array;
    return c < this.length ? { value: l[c], done: !1 } : { value: null, done: !0 };
  }, a.prototype.hasValue = function() {
    return this.array.length > this.index;
  }, a.prototype.hasCompleted = function() {
    return this.array.length === this.index;
  }, a;
}(), ZipBufferIterator = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.parent = l, p.observable = v, p.stillUnsubscribed = !0, p.buffer = [], p.isComplete = !1, p;
  }
  return u.prototype[iterator] = function() {
    return this;
  }, u.prototype.next = function() {
    var c = this.buffer;
    return c.length === 0 && this.isComplete ? { value: null, done: !0 } : { value: c.shift(), done: !1 };
  }, u.prototype.hasValue = function() {
    return this.buffer.length > 0;
  }, u.prototype.hasCompleted = function() {
    return this.buffer.length === 0 && this.isComplete;
  }, u.prototype.notifyComplete = function() {
    this.buffer.length > 0 ? (this.isComplete = !0, this.parent.notifyInactive()) : this.destination.complete();
  }, u.prototype.notifyNext = function(c) {
    this.buffer.push(c), this.parent.checkIterators();
  }, u.prototype.subscribe = function() {
    return innerSubscribe(this.observable, new SimpleInnerSubscriber(this));
  }, u;
}(SimpleOuterSubscriber);
function zip() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  return function(l) {
    return l.lift.call(zip$1.apply(void 0, [l].concat(a)));
  };
}
function zipAll(a) {
  return function(u) {
    return u.lift(new ZipOperator(a));
  };
}
const operators = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  audit,
  auditTime,
  buffer: buffer$2,
  bufferCount,
  bufferTime,
  bufferToggle,
  bufferWhen,
  catchError,
  combineAll,
  combineLatest,
  concat,
  concatAll,
  concatMap,
  concatMapTo,
  count,
  debounce: debounce$1,
  debounceTime,
  defaultIfEmpty,
  delay,
  delayWhen,
  dematerialize,
  distinct,
  distinctUntilChanged,
  distinctUntilKeyChanged,
  elementAt,
  endWith,
  every: every$1,
  exhaust,
  exhaustMap,
  expand,
  filter,
  finalize,
  find: find$2,
  findIndex,
  first,
  flatMap,
  groupBy,
  ignoreElements,
  isEmpty,
  last: last$1,
  map,
  mapTo,
  materialize,
  max: max$1,
  merge: merge$1,
  mergeAll,
  mergeMap,
  mergeMapTo,
  mergeScan,
  min,
  multicast,
  observeOn,
  onErrorResumeNext,
  pairwise,
  partition,
  pluck,
  publish,
  publishBehavior,
  publishLast,
  publishReplay,
  race,
  reduce,
  refCount,
  repeat,
  repeatWhen,
  retry,
  retryWhen,
  sample,
  sampleTime,
  scan,
  sequenceEqual,
  share,
  shareReplay,
  single,
  skip,
  skipLast,
  skipUntil,
  skipWhile,
  startWith,
  subscribeOn,
  switchAll,
  switchMap,
  switchMapTo,
  take,
  takeLast,
  takeUntil,
  takeWhile,
  tap,
  throttle,
  throttleTime,
  throwIfEmpty,
  timeInterval,
  timeout,
  timeoutWith,
  timestamp: timestamp$1,
  toArray: toArray$2,
  window: window$1,
  windowCount,
  windowTime,
  windowToggle,
  windowWhen,
  withLatestFrom,
  zip,
  zipAll
}, Symbol.toStringTag, { value: "Module" })), require$$2$1 = /* @__PURE__ */ getAugmentedNamespace(operators);
var struct = {};
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(j, ue, he, fe) {
    fe === void 0 && (fe = he), Object.defineProperty(j, fe, { enumerable: !0, get: function() {
      return ue[he];
    } });
  } : function(j, ue, he, fe) {
    fe === void 0 && (fe = he), j[fe] = ue[he];
  }), c = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(j, ue) {
    Object.defineProperty(j, "default", { enumerable: !0, value: ue });
  } : function(j, ue) {
    j.default = ue;
  }), l = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(j) {
    if (j && j.__esModule)
      return j;
    var ue = {};
    if (j != null)
      for (var he in j)
        he !== "default" && Object.hasOwnProperty.call(j, he) && u(ue, j, he);
    return c(ue, j), ue;
  }, v = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(j) {
    return j && j.__esModule ? j : { default: j };
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.ListValue = a.Value = a.Struct_FieldsEntry = a.Struct = a.nullValueToNumber = a.nullValueToJSON = a.nullValueFromJSON = a.NullValue = a.protobufPackage = void 0;
  const p = v(umdExports), _ = l(minimal);
  a.protobufPackage = "google.protobuf";
  var k;
  (function(j) {
    j.NULL_VALUE = "NULL_VALUE";
  })(k = a.NullValue || (a.NullValue = {}));
  function O(j) {
    switch (j) {
      case 0:
      case "NULL_VALUE":
        return k.NULL_VALUE;
      default:
        throw new ne.Error("Unrecognized enum value " + j + " for enum NullValue");
    }
  }
  a.nullValueFromJSON = O;
  function D(j) {
    switch (j) {
      case k.NULL_VALUE:
        return "NULL_VALUE";
      default:
        return "UNKNOWN";
    }
  }
  a.nullValueToJSON = D;
  function F(j) {
    switch (j) {
      case k.NULL_VALUE:
        return 0;
      default:
        return 0;
    }
  }
  a.nullValueToNumber = F;
  function H() {
    return { fields: {} };
  }
  a.Struct = {
    encode(j, ue = _.Writer.create()) {
      return Object.entries(j.fields).forEach(([he, fe]) => {
        fe !== void 0 && a.Struct_FieldsEntry.encode({ key: he, value: fe }, ue.uint32(10).fork()).ldelim();
      }), ue;
    },
    decode(j, ue) {
      const he = j instanceof _.Reader ? j : new _.Reader(j);
      let fe = ue === void 0 ? he.len : he.pos + ue;
      const be = H();
      for (; he.pos < fe; ) {
        const ke = he.uint32();
        switch (ke >>> 3) {
          case 1:
            const Te = a.Struct_FieldsEntry.decode(he, he.uint32());
            Te.value !== void 0 && (be.fields[Te.key] = Te.value);
            break;
          default:
            he.skipType(ke & 7);
            break;
        }
      }
      return be;
    },
    fromJSON(j) {
      return {
        fields: Q(j.fields) ? Object.entries(j.fields).reduce((ue, [he, fe]) => (ue[he] = fe, ue), {}) : {}
      };
    },
    toJSON(j) {
      const ue = {};
      return ue.fields = {}, j.fields && Object.entries(j.fields).forEach(([he, fe]) => {
        ue.fields[he] = fe;
      }), ue;
    },
    fromPartial(j) {
      var ue;
      const he = H();
      return he.fields = Object.entries((ue = j.fields) !== null && ue !== void 0 ? ue : {}).reduce((fe, [be, ke]) => (ke !== void 0 && (fe[be] = ke), fe), {}), he;
    },
    wrap(j) {
      const ue = H();
      return j !== void 0 && Object.keys(j).forEach((he) => {
        ue.fields[he] = j[he];
      }), ue;
    },
    unwrap(j) {
      const ue = {};
      return Object.keys(j.fields).forEach((he) => {
        ue[he] = j.fields[he];
      }), ue;
    }
  };
  function Z() {
    return { key: "", value: void 0 };
  }
  a.Struct_FieldsEntry = {
    encode(j, ue = _.Writer.create()) {
      return j.key !== "" && ue.uint32(10).string(j.key), j.value !== void 0 && a.Value.encode(a.Value.wrap(j.value), ue.uint32(18).fork()).ldelim(), ue;
    },
    decode(j, ue) {
      const he = j instanceof _.Reader ? j : new _.Reader(j);
      let fe = ue === void 0 ? he.len : he.pos + ue;
      const be = Z();
      for (; he.pos < fe; ) {
        const ke = he.uint32();
        switch (ke >>> 3) {
          case 1:
            be.key = he.string();
            break;
          case 2:
            be.value = a.Value.unwrap(a.Value.decode(he, he.uint32()));
            break;
          default:
            he.skipType(ke & 7);
            break;
        }
      }
      return be;
    },
    fromJSON(j) {
      return {
        key: ae(j.key) ? String(j.key) : "",
        value: ae(j == null ? void 0 : j.value) ? j.value : void 0
      };
    },
    toJSON(j) {
      const ue = {};
      return j.key !== void 0 && (ue.key = j.key), j.value !== void 0 && (ue.value = j.value), ue;
    },
    fromPartial(j) {
      var ue, he;
      const fe = Z();
      return fe.key = (ue = j.key) !== null && ue !== void 0 ? ue : "", fe.value = (he = j.value) !== null && he !== void 0 ? he : void 0, fe;
    }
  };
  function ee() {
    return {
      nullValue: void 0,
      numberValue: void 0,
      stringValue: void 0,
      boolValue: void 0,
      structValue: void 0,
      listValue: void 0
    };
  }
  a.Value = {
    encode(j, ue = _.Writer.create()) {
      return j.nullValue !== void 0 && ue.uint32(8).int32(F(j.nullValue)), j.numberValue !== void 0 && ue.uint32(17).double(j.numberValue), j.stringValue !== void 0 && ue.uint32(26).string(j.stringValue), j.boolValue !== void 0 && ue.uint32(32).bool(j.boolValue), j.structValue !== void 0 && a.Struct.encode(a.Struct.wrap(j.structValue), ue.uint32(42).fork()).ldelim(), j.listValue !== void 0 && a.ListValue.encode(a.ListValue.wrap(j.listValue), ue.uint32(50).fork()).ldelim(), ue;
    },
    decode(j, ue) {
      const he = j instanceof _.Reader ? j : new _.Reader(j);
      let fe = ue === void 0 ? he.len : he.pos + ue;
      const be = ee();
      for (; he.pos < fe; ) {
        const ke = he.uint32();
        switch (ke >>> 3) {
          case 1:
            be.nullValue = O(he.int32());
            break;
          case 2:
            be.numberValue = he.double();
            break;
          case 3:
            be.stringValue = he.string();
            break;
          case 4:
            be.boolValue = he.bool();
            break;
          case 5:
            be.structValue = a.Struct.unwrap(a.Struct.decode(he, he.uint32()));
            break;
          case 6:
            be.listValue = a.ListValue.unwrap(a.ListValue.decode(he, he.uint32()));
            break;
          default:
            he.skipType(ke & 7);
            break;
        }
      }
      return be;
    },
    fromJSON(j) {
      return {
        nullValue: ae(j.nullValue) ? O(j.nullValue) : void 0,
        numberValue: ae(j.numberValue) ? Number(j.numberValue) : void 0,
        stringValue: ae(j.stringValue) ? String(j.stringValue) : void 0,
        boolValue: ae(j.boolValue) ? !!j.boolValue : void 0,
        structValue: Q(j.structValue) ? j.structValue : void 0,
        listValue: Array.isArray(j.listValue) ? [...j.listValue] : void 0
      };
    },
    toJSON(j) {
      const ue = {};
      return j.nullValue !== void 0 && (ue.nullValue = j.nullValue !== void 0 ? D(j.nullValue) : void 0), j.numberValue !== void 0 && (ue.numberValue = j.numberValue), j.stringValue !== void 0 && (ue.stringValue = j.stringValue), j.boolValue !== void 0 && (ue.boolValue = j.boolValue), j.structValue !== void 0 && (ue.structValue = j.structValue), j.listValue !== void 0 && (ue.listValue = j.listValue), ue;
    },
    fromPartial(j) {
      var ue, he, fe, be, ke, Te;
      const q = ee();
      return q.nullValue = (ue = j.nullValue) !== null && ue !== void 0 ? ue : void 0, q.numberValue = (he = j.numberValue) !== null && he !== void 0 ? he : void 0, q.stringValue = (fe = j.stringValue) !== null && fe !== void 0 ? fe : void 0, q.boolValue = (be = j.boolValue) !== null && be !== void 0 ? be : void 0, q.structValue = (ke = j.structValue) !== null && ke !== void 0 ? ke : void 0, q.listValue = (Te = j.listValue) !== null && Te !== void 0 ? Te : void 0, q;
    },
    wrap(j) {
      const ue = ee();
      if (j === null)
        ue.nullValue = k.NULL_VALUE;
      else if (typeof j == "boolean")
        ue.boolValue = j;
      else if (typeof j == "number")
        ue.numberValue = j;
      else if (typeof j == "string")
        ue.stringValue = j;
      else if (Array.isArray(j))
        ue.listValue = j;
      else if (typeof j == "object")
        ue.structValue = j;
      else if (typeof j < "u")
        throw new Error("Unsupported any value type: " + typeof j);
      return ue;
    },
    unwrap(j) {
      if ((j == null ? void 0 : j.stringValue) !== void 0)
        return j.stringValue;
      if ((j == null ? void 0 : j.numberValue) !== void 0)
        return j.numberValue;
      if ((j == null ? void 0 : j.boolValue) !== void 0)
        return j.boolValue;
      if ((j == null ? void 0 : j.structValue) !== void 0)
        return j.structValue;
      if ((j == null ? void 0 : j.listValue) !== void 0)
        return j.listValue;
      if ((j == null ? void 0 : j.nullValue) !== void 0)
        return null;
    }
  };
  function X() {
    return { values: [] };
  }
  a.ListValue = {
    encode(j, ue = _.Writer.create()) {
      for (const he of j.values)
        a.Value.encode(a.Value.wrap(he), ue.uint32(10).fork()).ldelim();
      return ue;
    },
    decode(j, ue) {
      const he = j instanceof _.Reader ? j : new _.Reader(j);
      let fe = ue === void 0 ? he.len : he.pos + ue;
      const be = X();
      for (; he.pos < fe; ) {
        const ke = he.uint32();
        switch (ke >>> 3) {
          case 1:
            be.values.push(a.Value.unwrap(a.Value.decode(he, he.uint32())));
            break;
          default:
            he.skipType(ke & 7);
            break;
        }
      }
      return be;
    },
    fromJSON(j) {
      return {
        values: Array.isArray(j == null ? void 0 : j.values) ? [...j.values] : []
      };
    },
    toJSON(j) {
      const ue = {};
      return j.values ? ue.values = j.values.map((he) => he) : ue.values = [], ue;
    },
    fromPartial(j) {
      var ue;
      const he = X();
      return he.values = ((ue = j.values) === null || ue === void 0 ? void 0 : ue.map((fe) => fe)) || [], he;
    },
    wrap(j) {
      const ue = X();
      return ue.values = j ?? [], ue;
    },
    unwrap(j) {
      return j.values;
    }
  };
  var ne = (() => {
    if (typeof ne < "u")
      return ne;
    if (typeof self < "u")
      return self;
    if (typeof window < "u")
      return window;
    if (typeof commonjsGlobal$1 < "u")
      return commonjsGlobal$1;
    throw "Unable to locate global object";
  })();
  _.util.Long !== p.default && (_.util.Long = p.default, _.configure());
  function Q(j) {
    return typeof j == "object" && j !== null;
  }
  function ae(j) {
    return j != null;
  }
})(struct);
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(q, z, P, S) {
    S === void 0 && (S = P), Object.defineProperty(q, S, { enumerable: !0, get: function() {
      return z[P];
    } });
  } : function(q, z, P, S) {
    S === void 0 && (S = P), q[S] = z[P];
  }), c = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(q, z) {
    Object.defineProperty(q, "default", { enumerable: !0, value: z });
  } : function(q, z) {
    q.default = z;
  }), l = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(q) {
    if (q && q.__esModule)
      return q;
    var z = {};
    if (q != null)
      for (var P in q)
        P !== "default" && Object.hasOwnProperty.call(q, P) && u(z, q, P);
    return c(z, q), z;
  }, v = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(q) {
    return q && q.__esModule ? q : { default: q };
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.EventServiceDefinition = a.EventServiceClientImpl = a.EventsStreamResponse = a.EventsStreamRequest = a.EventsStreamReconnectRequest = a.EventsStreamError = a.SubscribePayload = a.PublishEventResponse = a.PublishEventRequest = a.EventTarget = a.eventsStreamMessageTypeToNumber = a.eventsStreamMessageTypeToJSON = a.eventsStreamMessageTypeFromJSON = a.EventsStreamMessageType = a.protobufPackage = void 0;
  const p = v(umdExports), _ = l(minimal), k = require$$2$1, O = struct;
  a.protobufPackage = "apis.event.v2";
  var D;
  (function(q) {
    q.EVENTS_STREAM_MESSAGE_TYPE_UNSPECIFIED = "EVENTS_STREAM_MESSAGE_TYPE_UNSPECIFIED", q.EVENTS_STREAM_MESSAGE_TYPE_PING = "EVENTS_STREAM_MESSAGE_TYPE_PING", q.EVENTS_STREAM_MESSAGE_TYPE_ERROR = "EVENTS_STREAM_MESSAGE_TYPE_ERROR", q.EVENTS_STREAM_MESSAGE_TYPE_SUBSCRIBED = "EVENTS_STREAM_MESSAGE_TYPE_SUBSCRIBED", q.EVENTS_STREAM_MESSAGE_TYPE_UNSUBSCRIBED = "EVENTS_STREAM_MESSAGE_TYPE_UNSUBSCRIBED", q.EVENTS_STREAM_MESSAGE_TYPE_PUBLISHED = "EVENTS_STREAM_MESSAGE_TYPE_PUBLISHED";
  })(D = a.EventsStreamMessageType || (a.EventsStreamMessageType = {}));
  function F(q) {
    switch (q) {
      case 0:
      case "EVENTS_STREAM_MESSAGE_TYPE_UNSPECIFIED":
        return D.EVENTS_STREAM_MESSAGE_TYPE_UNSPECIFIED;
      case 1:
      case "EVENTS_STREAM_MESSAGE_TYPE_PING":
        return D.EVENTS_STREAM_MESSAGE_TYPE_PING;
      case 2:
      case "EVENTS_STREAM_MESSAGE_TYPE_ERROR":
        return D.EVENTS_STREAM_MESSAGE_TYPE_ERROR;
      case 3:
      case "EVENTS_STREAM_MESSAGE_TYPE_SUBSCRIBED":
        return D.EVENTS_STREAM_MESSAGE_TYPE_SUBSCRIBED;
      case 4:
      case "EVENTS_STREAM_MESSAGE_TYPE_UNSUBSCRIBED":
        return D.EVENTS_STREAM_MESSAGE_TYPE_UNSUBSCRIBED;
      case 5:
      case "EVENTS_STREAM_MESSAGE_TYPE_PUBLISHED":
        return D.EVENTS_STREAM_MESSAGE_TYPE_PUBLISHED;
      default:
        throw new be.Error("Unrecognized enum value " + q + " for enum EventsStreamMessageType");
    }
  }
  a.eventsStreamMessageTypeFromJSON = F;
  function H(q) {
    switch (q) {
      case D.EVENTS_STREAM_MESSAGE_TYPE_UNSPECIFIED:
        return "EVENTS_STREAM_MESSAGE_TYPE_UNSPECIFIED";
      case D.EVENTS_STREAM_MESSAGE_TYPE_PING:
        return "EVENTS_STREAM_MESSAGE_TYPE_PING";
      case D.EVENTS_STREAM_MESSAGE_TYPE_ERROR:
        return "EVENTS_STREAM_MESSAGE_TYPE_ERROR";
      case D.EVENTS_STREAM_MESSAGE_TYPE_SUBSCRIBED:
        return "EVENTS_STREAM_MESSAGE_TYPE_SUBSCRIBED";
      case D.EVENTS_STREAM_MESSAGE_TYPE_UNSUBSCRIBED:
        return "EVENTS_STREAM_MESSAGE_TYPE_UNSUBSCRIBED";
      case D.EVENTS_STREAM_MESSAGE_TYPE_PUBLISHED:
        return "EVENTS_STREAM_MESSAGE_TYPE_PUBLISHED";
      default:
        return "UNKNOWN";
    }
  }
  a.eventsStreamMessageTypeToJSON = H;
  function Z(q) {
    switch (q) {
      case D.EVENTS_STREAM_MESSAGE_TYPE_UNSPECIFIED:
        return 0;
      case D.EVENTS_STREAM_MESSAGE_TYPE_PING:
        return 1;
      case D.EVENTS_STREAM_MESSAGE_TYPE_ERROR:
        return 2;
      case D.EVENTS_STREAM_MESSAGE_TYPE_SUBSCRIBED:
        return 3;
      case D.EVENTS_STREAM_MESSAGE_TYPE_UNSUBSCRIBED:
        return 4;
      case D.EVENTS_STREAM_MESSAGE_TYPE_PUBLISHED:
        return 5;
      default:
        return 0;
    }
  }
  a.eventsStreamMessageTypeToNumber = Z;
  function ee() {
    return { collectionId: void 0, projectId: void 0, layoutId: void 0 };
  }
  a.EventTarget = {
    encode(q, z = _.Writer.create()) {
      return q.collectionId !== void 0 && z.uint32(42).string(q.collectionId), q.projectId !== void 0 && z.uint32(34).string(q.projectId), q.layoutId !== void 0 && z.uint32(10).string(q.layoutId), z;
    },
    decode(q, z) {
      const P = q instanceof _.Reader ? q : new _.Reader(q);
      let S = z === void 0 ? P.len : P.pos + z;
      const E = ee();
      for (; P.pos < S; ) {
        const I = P.uint32();
        switch (I >>> 3) {
          case 5:
            E.collectionId = P.string();
            break;
          case 4:
            E.projectId = P.string();
            break;
          case 1:
            E.layoutId = P.string();
            break;
          default:
            P.skipType(I & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(q) {
      return {
        collectionId: Te(q.collectionId) ? String(q.collectionId) : void 0,
        projectId: Te(q.projectId) ? String(q.projectId) : void 0,
        layoutId: Te(q.layoutId) ? String(q.layoutId) : void 0
      };
    },
    toJSON(q) {
      const z = {};
      return q.collectionId !== void 0 && (z.collectionId = q.collectionId), q.projectId !== void 0 && (z.projectId = q.projectId), q.layoutId !== void 0 && (z.layoutId = q.layoutId), z;
    },
    fromPartial(q) {
      var z, P, S;
      const E = ee();
      return E.collectionId = (z = q.collectionId) !== null && z !== void 0 ? z : void 0, E.projectId = (P = q.projectId) !== null && P !== void 0 ? P : void 0, E.layoutId = (S = q.layoutId) !== null && S !== void 0 ? S : void 0, E;
    }
  };
  function X() {
    return {
      name: "",
      payload: void 0,
      requestMetadata: void 0,
      target: void 0
    };
  }
  a.PublishEventRequest = {
    encode(q, z = _.Writer.create()) {
      return q.name !== "" && z.uint32(10).string(q.name), q.payload !== void 0 && O.Struct.encode(O.Struct.wrap(q.payload), z.uint32(18).fork()).ldelim(), q.requestMetadata !== void 0 && O.Value.encode(O.Value.wrap(q.requestMetadata), z.uint32(34).fork()).ldelim(), q.target !== void 0 && a.EventTarget.encode(q.target, z.uint32(26).fork()).ldelim(), z;
    },
    decode(q, z) {
      const P = q instanceof _.Reader ? q : new _.Reader(q);
      let S = z === void 0 ? P.len : P.pos + z;
      const E = X();
      for (; P.pos < S; ) {
        const I = P.uint32();
        switch (I >>> 3) {
          case 1:
            E.name = P.string();
            break;
          case 2:
            E.payload = O.Struct.unwrap(O.Struct.decode(P, P.uint32()));
            break;
          case 4:
            E.requestMetadata = O.Value.unwrap(O.Value.decode(P, P.uint32()));
            break;
          case 3:
            E.target = a.EventTarget.decode(P, P.uint32());
            break;
          default:
            P.skipType(I & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(q) {
      return {
        name: Te(q.name) ? String(q.name) : "",
        payload: ke(q.payload) ? q.payload : void 0,
        requestMetadata: Te(q == null ? void 0 : q.requestMetadata) ? q.requestMetadata : void 0,
        target: Te(q.target) ? a.EventTarget.fromJSON(q.target) : void 0
      };
    },
    toJSON(q) {
      const z = {};
      return q.name !== void 0 && (z.name = q.name), q.payload !== void 0 && (z.payload = q.payload), q.requestMetadata !== void 0 && (z.requestMetadata = q.requestMetadata), q.target !== void 0 && (z.target = q.target ? a.EventTarget.toJSON(q.target) : void 0), z;
    },
    fromPartial(q) {
      var z, P, S;
      const E = X();
      return E.name = (z = q.name) !== null && z !== void 0 ? z : "", E.payload = (P = q.payload) !== null && P !== void 0 ? P : void 0, E.requestMetadata = (S = q.requestMetadata) !== null && S !== void 0 ? S : void 0, E.target = q.target !== void 0 && q.target !== null ? a.EventTarget.fromPartial(q.target) : void 0, E;
    }
  };
  function ne() {
    return {
      name: "",
      payload: void 0,
      target: void 0,
      requestMetadata: void 0,
      id: ""
    };
  }
  a.PublishEventResponse = {
    encode(q, z = _.Writer.create()) {
      return q.name !== "" && z.uint32(10).string(q.name), q.payload !== void 0 && O.Struct.encode(O.Struct.wrap(q.payload), z.uint32(18).fork()).ldelim(), q.target !== void 0 && a.EventTarget.encode(q.target, z.uint32(26).fork()).ldelim(), q.requestMetadata !== void 0 && O.Value.encode(O.Value.wrap(q.requestMetadata), z.uint32(34).fork()).ldelim(), q.id !== "" && z.uint32(42).string(q.id), z;
    },
    decode(q, z) {
      const P = q instanceof _.Reader ? q : new _.Reader(q);
      let S = z === void 0 ? P.len : P.pos + z;
      const E = ne();
      for (; P.pos < S; ) {
        const I = P.uint32();
        switch (I >>> 3) {
          case 1:
            E.name = P.string();
            break;
          case 2:
            E.payload = O.Struct.unwrap(O.Struct.decode(P, P.uint32()));
            break;
          case 3:
            E.target = a.EventTarget.decode(P, P.uint32());
            break;
          case 4:
            E.requestMetadata = O.Value.unwrap(O.Value.decode(P, P.uint32()));
            break;
          case 5:
            E.id = P.string();
            break;
          default:
            P.skipType(I & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(q) {
      return {
        name: Te(q.name) ? String(q.name) : "",
        payload: ke(q.payload) ? q.payload : void 0,
        target: Te(q.target) ? a.EventTarget.fromJSON(q.target) : void 0,
        requestMetadata: Te(q == null ? void 0 : q.requestMetadata) ? q.requestMetadata : void 0,
        id: Te(q.id) ? String(q.id) : ""
      };
    },
    toJSON(q) {
      const z = {};
      return q.name !== void 0 && (z.name = q.name), q.payload !== void 0 && (z.payload = q.payload), q.target !== void 0 && (z.target = q.target ? a.EventTarget.toJSON(q.target) : void 0), q.requestMetadata !== void 0 && (z.requestMetadata = q.requestMetadata), q.id !== void 0 && (z.id = q.id), z;
    },
    fromPartial(q) {
      var z, P, S, E;
      const I = ne();
      return I.name = (z = q.name) !== null && z !== void 0 ? z : "", I.payload = (P = q.payload) !== null && P !== void 0 ? P : void 0, I.target = q.target !== void 0 && q.target !== null ? a.EventTarget.fromPartial(q.target) : void 0, I.requestMetadata = (S = q.requestMetadata) !== null && S !== void 0 ? S : void 0, I.id = (E = q.id) !== null && E !== void 0 ? E : "", I;
    }
  };
  function Q() {
    return { name: "", target: void 0 };
  }
  a.SubscribePayload = {
    encode(q, z = _.Writer.create()) {
      return q.name !== "" && z.uint32(10).string(q.name), q.target !== void 0 && a.EventTarget.encode(q.target, z.uint32(18).fork()).ldelim(), z;
    },
    decode(q, z) {
      const P = q instanceof _.Reader ? q : new _.Reader(q);
      let S = z === void 0 ? P.len : P.pos + z;
      const E = Q();
      for (; P.pos < S; ) {
        const I = P.uint32();
        switch (I >>> 3) {
          case 1:
            E.name = P.string();
            break;
          case 2:
            E.target = a.EventTarget.decode(P, P.uint32());
            break;
          default:
            P.skipType(I & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(q) {
      return {
        name: Te(q.name) ? String(q.name) : "",
        target: Te(q.target) ? a.EventTarget.fromJSON(q.target) : void 0
      };
    },
    toJSON(q) {
      const z = {};
      return q.name !== void 0 && (z.name = q.name), q.target !== void 0 && (z.target = q.target ? a.EventTarget.toJSON(q.target) : void 0), z;
    },
    fromPartial(q) {
      var z;
      const P = Q();
      return P.name = (z = q.name) !== null && z !== void 0 ? z : "", P.target = q.target !== void 0 && q.target !== null ? a.EventTarget.fromPartial(q.target) : void 0, P;
    }
  };
  function ae() {
    return { code: 0, message: "" };
  }
  a.EventsStreamError = {
    encode(q, z = _.Writer.create()) {
      return q.code !== 0 && z.uint32(8).int32(q.code), q.message !== "" && z.uint32(18).string(q.message), z;
    },
    decode(q, z) {
      const P = q instanceof _.Reader ? q : new _.Reader(q);
      let S = z === void 0 ? P.len : P.pos + z;
      const E = ae();
      for (; P.pos < S; ) {
        const I = P.uint32();
        switch (I >>> 3) {
          case 1:
            E.code = P.int32();
            break;
          case 2:
            E.message = P.string();
            break;
          default:
            P.skipType(I & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(q) {
      return {
        code: Te(q.code) ? Number(q.code) : 0,
        message: Te(q.message) ? String(q.message) : ""
      };
    },
    toJSON(q) {
      const z = {};
      return q.code !== void 0 && (z.code = Math.round(q.code)), q.message !== void 0 && (z.message = q.message), z;
    },
    fromPartial(q) {
      var z, P;
      const S = ae();
      return S.code = (z = q.code) !== null && z !== void 0 ? z : 0, S.message = (P = q.message) !== null && P !== void 0 ? P : "", S;
    }
  };
  function j() {
    return { reauthenticate: !1, beforeTimestamp: "" };
  }
  a.EventsStreamReconnectRequest = {
    encode(q, z = _.Writer.create()) {
      return q.reauthenticate === !0 && z.uint32(8).bool(q.reauthenticate), q.beforeTimestamp !== "" && z.uint32(18).string(q.beforeTimestamp), z;
    },
    decode(q, z) {
      const P = q instanceof _.Reader ? q : new _.Reader(q);
      let S = z === void 0 ? P.len : P.pos + z;
      const E = j();
      for (; P.pos < S; ) {
        const I = P.uint32();
        switch (I >>> 3) {
          case 1:
            E.reauthenticate = P.bool();
            break;
          case 2:
            E.beforeTimestamp = P.string();
            break;
          default:
            P.skipType(I & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(q) {
      return {
        reauthenticate: Te(q.reauthenticate) ? !!q.reauthenticate : !1,
        beforeTimestamp: Te(q.beforeTimestamp) ? String(q.beforeTimestamp) : ""
      };
    },
    toJSON(q) {
      const z = {};
      return q.reauthenticate !== void 0 && (z.reauthenticate = q.reauthenticate), q.beforeTimestamp !== void 0 && (z.beforeTimestamp = q.beforeTimestamp), z;
    },
    fromPartial(q) {
      var z, P;
      const S = j();
      return S.reauthenticate = (z = q.reauthenticate) !== null && z !== void 0 ? z : !1, S.beforeTimestamp = (P = q.beforeTimestamp) !== null && P !== void 0 ? P : "", S;
    }
  };
  function ue() {
    return {
      correlationId: void 0,
      subscribe: void 0,
      unsubscribe: void 0,
      publish: void 0,
      ping: void 0
    };
  }
  a.EventsStreamRequest = {
    encode(q, z = _.Writer.create()) {
      return q.correlationId !== void 0 && z.uint32(10).string(q.correlationId), q.subscribe !== void 0 && a.SubscribePayload.encode(q.subscribe, z.uint32(802).fork()).ldelim(), q.unsubscribe !== void 0 && a.SubscribePayload.encode(q.unsubscribe, z.uint32(810).fork()).ldelim(), q.publish !== void 0 && a.PublishEventRequest.encode(q.publish, z.uint32(818).fork()).ldelim(), q.ping !== void 0 && z.uint32(826).string(q.ping), z;
    },
    decode(q, z) {
      const P = q instanceof _.Reader ? q : new _.Reader(q);
      let S = z === void 0 ? P.len : P.pos + z;
      const E = ue();
      for (; P.pos < S; ) {
        const I = P.uint32();
        switch (I >>> 3) {
          case 1:
            E.correlationId = P.string();
            break;
          case 100:
            E.subscribe = a.SubscribePayload.decode(P, P.uint32());
            break;
          case 101:
            E.unsubscribe = a.SubscribePayload.decode(P, P.uint32());
            break;
          case 102:
            E.publish = a.PublishEventRequest.decode(P, P.uint32());
            break;
          case 103:
            E.ping = P.string();
            break;
          default:
            P.skipType(I & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(q) {
      return {
        correlationId: Te(q.correlationId) ? String(q.correlationId) : void 0,
        subscribe: Te(q.subscribe) ? a.SubscribePayload.fromJSON(q.subscribe) : void 0,
        unsubscribe: Te(q.unsubscribe) ? a.SubscribePayload.fromJSON(q.unsubscribe) : void 0,
        publish: Te(q.publish) ? a.PublishEventRequest.fromJSON(q.publish) : void 0,
        ping: Te(q.ping) ? String(q.ping) : void 0
      };
    },
    toJSON(q) {
      const z = {};
      return q.correlationId !== void 0 && (z.correlationId = q.correlationId), q.subscribe !== void 0 && (z.subscribe = q.subscribe ? a.SubscribePayload.toJSON(q.subscribe) : void 0), q.unsubscribe !== void 0 && (z.unsubscribe = q.unsubscribe ? a.SubscribePayload.toJSON(q.unsubscribe) : void 0), q.publish !== void 0 && (z.publish = q.publish ? a.PublishEventRequest.toJSON(q.publish) : void 0), q.ping !== void 0 && (z.ping = q.ping), z;
    },
    fromPartial(q) {
      var z, P;
      const S = ue();
      return S.correlationId = (z = q.correlationId) !== null && z !== void 0 ? z : void 0, S.subscribe = q.subscribe !== void 0 && q.subscribe !== null ? a.SubscribePayload.fromPartial(q.subscribe) : void 0, S.unsubscribe = q.unsubscribe !== void 0 && q.unsubscribe !== null ? a.SubscribePayload.fromPartial(q.unsubscribe) : void 0, S.publish = q.publish !== void 0 && q.publish !== null ? a.PublishEventRequest.fromPartial(q.publish) : void 0, S.ping = (P = q.ping) !== null && P !== void 0 ? P : void 0, S;
    }
  };
  function he() {
    return {
      correlationId: void 0,
      sessionId: void 0,
      event: void 0,
      pong: void 0,
      error: void 0,
      subscribed: void 0,
      unsubscribed: void 0,
      published: void 0,
      reconnectBefore: void 0
    };
  }
  a.EventsStreamResponse = {
    encode(q, z = _.Writer.create()) {
      return q.correlationId !== void 0 && z.uint32(18).string(q.correlationId), q.sessionId !== void 0 && z.uint32(26).string(q.sessionId), q.event !== void 0 && a.PublishEventResponse.encode(q.event, z.uint32(802).fork()).ldelim(), q.pong !== void 0 && z.uint32(1602).string(q.pong), q.error !== void 0 && a.EventsStreamError.encode(q.error, z.uint32(1610).fork()).ldelim(), q.subscribed !== void 0 && a.SubscribePayload.encode(q.subscribed, z.uint32(1618).fork()).ldelim(), q.unsubscribed !== void 0 && a.SubscribePayload.encode(q.unsubscribed, z.uint32(1626).fork()).ldelim(), q.published !== void 0 && a.PublishEventResponse.encode(q.published, z.uint32(1634).fork()).ldelim(), q.reconnectBefore !== void 0 && a.EventsStreamReconnectRequest.encode(q.reconnectBefore, z.uint32(1642).fork()).ldelim(), z;
    },
    decode(q, z) {
      const P = q instanceof _.Reader ? q : new _.Reader(q);
      let S = z === void 0 ? P.len : P.pos + z;
      const E = he();
      for (; P.pos < S; ) {
        const I = P.uint32();
        switch (I >>> 3) {
          case 2:
            E.correlationId = P.string();
            break;
          case 3:
            E.sessionId = P.string();
            break;
          case 100:
            E.event = a.PublishEventResponse.decode(P, P.uint32());
            break;
          case 200:
            E.pong = P.string();
            break;
          case 201:
            E.error = a.EventsStreamError.decode(P, P.uint32());
            break;
          case 202:
            E.subscribed = a.SubscribePayload.decode(P, P.uint32());
            break;
          case 203:
            E.unsubscribed = a.SubscribePayload.decode(P, P.uint32());
            break;
          case 204:
            E.published = a.PublishEventResponse.decode(P, P.uint32());
            break;
          case 205:
            E.reconnectBefore = a.EventsStreamReconnectRequest.decode(P, P.uint32());
            break;
          default:
            P.skipType(I & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(q) {
      return {
        correlationId: Te(q.correlationId) ? String(q.correlationId) : void 0,
        sessionId: Te(q.sessionId) ? String(q.sessionId) : void 0,
        event: Te(q.event) ? a.PublishEventResponse.fromJSON(q.event) : void 0,
        pong: Te(q.pong) ? String(q.pong) : void 0,
        error: Te(q.error) ? a.EventsStreamError.fromJSON(q.error) : void 0,
        subscribed: Te(q.subscribed) ? a.SubscribePayload.fromJSON(q.subscribed) : void 0,
        unsubscribed: Te(q.unsubscribed) ? a.SubscribePayload.fromJSON(q.unsubscribed) : void 0,
        published: Te(q.published) ? a.PublishEventResponse.fromJSON(q.published) : void 0,
        reconnectBefore: Te(q.reconnectBefore) ? a.EventsStreamReconnectRequest.fromJSON(q.reconnectBefore) : void 0
      };
    },
    toJSON(q) {
      const z = {};
      return q.correlationId !== void 0 && (z.correlationId = q.correlationId), q.sessionId !== void 0 && (z.sessionId = q.sessionId), q.event !== void 0 && (z.event = q.event ? a.PublishEventResponse.toJSON(q.event) : void 0), q.pong !== void 0 && (z.pong = q.pong), q.error !== void 0 && (z.error = q.error ? a.EventsStreamError.toJSON(q.error) : void 0), q.subscribed !== void 0 && (z.subscribed = q.subscribed ? a.SubscribePayload.toJSON(q.subscribed) : void 0), q.unsubscribed !== void 0 && (z.unsubscribed = q.unsubscribed ? a.SubscribePayload.toJSON(q.unsubscribed) : void 0), q.published !== void 0 && (z.published = q.published ? a.PublishEventResponse.toJSON(q.published) : void 0), q.reconnectBefore !== void 0 && (z.reconnectBefore = q.reconnectBefore ? a.EventsStreamReconnectRequest.toJSON(q.reconnectBefore) : void 0), z;
    },
    fromPartial(q) {
      var z, P, S;
      const E = he();
      return E.correlationId = (z = q.correlationId) !== null && z !== void 0 ? z : void 0, E.sessionId = (P = q.sessionId) !== null && P !== void 0 ? P : void 0, E.event = q.event !== void 0 && q.event !== null ? a.PublishEventResponse.fromPartial(q.event) : void 0, E.pong = (S = q.pong) !== null && S !== void 0 ? S : void 0, E.error = q.error !== void 0 && q.error !== null ? a.EventsStreamError.fromPartial(q.error) : void 0, E.subscribed = q.subscribed !== void 0 && q.subscribed !== null ? a.SubscribePayload.fromPartial(q.subscribed) : void 0, E.unsubscribed = q.unsubscribed !== void 0 && q.unsubscribed !== null ? a.SubscribePayload.fromPartial(q.unsubscribed) : void 0, E.published = q.published !== void 0 && q.published !== null ? a.PublishEventResponse.fromPartial(q.published) : void 0, E.reconnectBefore = q.reconnectBefore !== void 0 && q.reconnectBefore !== null ? a.EventsStreamReconnectRequest.fromPartial(q.reconnectBefore) : void 0, E;
    }
  };
  class fe {
    constructor(z) {
      this.rpc = z, this.Stream = this.Stream.bind(this), this.Publish = this.Publish.bind(this);
    }
    Stream(z) {
      const P = z.pipe(k.map((E) => a.EventsStreamRequest.encode(E).finish()));
      return this.rpc.bidirectionalStreamingRequest("apis.event.v2.EventService", "Stream", P).pipe(k.map((E) => a.EventsStreamResponse.decode(new _.Reader(E))));
    }
    Publish(z) {
      const P = a.PublishEventRequest.encode(z).finish();
      return this.rpc.request("apis.event.v2.EventService", "Publish", P).then((E) => a.PublishEventResponse.decode(new _.Reader(E)));
    }
  }
  a.EventServiceClientImpl = fe, a.EventServiceDefinition = {
    name: "EventService",
    fullName: "apis.event.v2.EventService",
    methods: {
      /**
       * Stream Events
       * buf:lint:ignore RPC_REQUEST_STANDARD_NAME
       * buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
       */
      stream: {
        name: "Stream",
        requestType: a.EventsStreamRequest,
        requestStream: !0,
        responseType: a.EventsStreamResponse,
        responseStream: !0,
        options: {}
      },
      /**
       * Publish Event
       * buf:lint:ignore RPC_REQUEST_STANDARD_NAME
       * buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
       */
      publish: {
        name: "Publish",
        requestType: a.PublishEventRequest,
        requestStream: !1,
        responseType: a.PublishEventResponse,
        responseStream: !1,
        options: {}
      }
    }
  };
  var be = (() => {
    if (typeof be < "u")
      return be;
    if (typeof self < "u")
      return self;
    if (typeof window < "u")
      return window;
    if (typeof commonjsGlobal$1 < "u")
      return commonjsGlobal$1;
    throw "Unable to locate global object";
  })();
  _.util.Long !== p.default && (_.util.Long = p.default, _.configure());
  function ke(q) {
    return typeof q == "object" && q !== null;
  }
  function Te(q) {
    return q != null;
  }
})(api$1);
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(l, v, p, _) {
    _ === void 0 && (_ = p), Object.defineProperty(l, _, { enumerable: !0, get: function() {
      return v[p];
    } });
  } : function(l, v, p, _) {
    _ === void 0 && (_ = p), l[_] = v[p];
  }), c = commonjsGlobal$1 && commonjsGlobal$1.__exportStar || function(l, v) {
    for (var p in l)
      p !== "default" && !v.hasOwnProperty(p) && u(v, l, p);
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.eventsApiSupportedEvents = a.eventsApiEventRpcCalls = void 0, c(api$1, a), a.eventsApiEventRpcCalls = {
    ping: "pong",
    publish: "published",
    subscribe: "subscribed",
    unsubscribe: "unsubscribed"
  }, a.eventsApiSupportedEvents = [...Object.values(a.eventsApiEventRpcCalls), "error", "event", "reconnectBefore"];
})(dist$1);
var ws = null;
typeof WebSocket < "u" ? ws = WebSocket : typeof MozWebSocket < "u" ? ws = MozWebSocket : typeof commonjsGlobal$1 < "u" ? ws = commonjsGlobal$1.WebSocket || commonjsGlobal$1.MozWebSocket : typeof window < "u" ? ws = window.WebSocket || window.MozWebSocket : typeof self < "u" && (ws = self.WebSocket || self.MozWebSocket);
var browser$e = ws, matcher = { exports: {} }, escapeStringRegexp$1 = (a) => {
  if (typeof a != "string")
    throw new TypeError("Expected a string");
  return a.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
};
const escapeStringRegexp = escapeStringRegexp$1, regexpCache = /* @__PURE__ */ new Map();
function sanitizeArray(a, u) {
  if (!Array.isArray(a))
    switch (typeof a) {
      case "string":
        a = [a];
        break;
      case "undefined":
        a = [];
        break;
      default:
        throw new TypeError(`Expected '${u}' to be a string or an array, but got a type of '${typeof a}'`);
    }
  return a.filter((c) => {
    if (typeof c != "string") {
      if (typeof c > "u")
        return !1;
      throw new TypeError(`Expected '${u}' to be an array of strings, but found a type of '${typeof c}' in the array`);
    }
    return !0;
  });
}
function makeRegexp(a, u) {
  u = {
    caseSensitive: !1,
    ...u
  };
  const c = a + JSON.stringify(u);
  if (regexpCache.has(c))
    return regexpCache.get(c);
  const l = a[0] === "!";
  l && (a = a.slice(1)), a = escapeStringRegexp(a).replace(/\\\*/g, "[\\s\\S]*");
  const v = new RegExp(`^${a}$`, u.caseSensitive ? "" : "i");
  return v.negated = l, regexpCache.set(c, v), v;
}
matcher.exports = (a, u, c) => {
  if (a = sanitizeArray(a, "inputs"), u = sanitizeArray(u, "patterns"), u.length === 0)
    return [];
  const l = u[0][0] === "!";
  u = u.map((p) => makeRegexp(p, c));
  const v = [];
  for (const p of a) {
    let _ = l;
    for (const k of u)
      k.test(p) && (_ = !k.negated);
    _ && v.push(p);
  }
  return v;
};
matcher.exports.isMatch = (a, u, c) => (a = sanitizeArray(a, "inputs"), u = sanitizeArray(u, "patterns"), u.length === 0 ? !1 : a.some((l) => u.every((v) => {
  const p = makeRegexp(v, c), _ = p.test(l);
  return p.negated ? !_ : _;
})));
var matcherExports = matcher.exports, __createBinding$1 = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(a, u, c, l) {
  l === void 0 && (l = c);
  var v = Object.getOwnPropertyDescriptor(u, c);
  (!v || ("get" in v ? !u.__esModule : v.writable || v.configurable)) && (v = { enumerable: !0, get: function() {
    return u[c];
  } }), Object.defineProperty(a, l, v);
} : function(a, u, c, l) {
  l === void 0 && (l = c), a[l] = u[c];
}), __setModuleDefault$1 = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(a, u) {
  Object.defineProperty(a, "default", { enumerable: !0, value: u });
} : function(a, u) {
  a.default = u;
}), __importStar$1 = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(a) {
  if (a && a.__esModule)
    return a;
  var u = {};
  if (a != null)
    for (var c in a)
      c !== "default" && Object.prototype.hasOwnProperty.call(a, c) && __createBinding$1(u, a, c);
  return __setModuleDefault$1(u, a), u;
}, __importDefault$8 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(eventapi, "__esModule", { value: !0 });
eventapi.EventApi = void 0;
const EventApiModel = __importStar$1(dist$1), isomorphic_ws_1 = __importDefault$8(browser$e), uuid_1 = require$$1$4, NiceGrpc = __importStar$1(lib$1), matcher_1 = matcherExports, api_1 = api$3, clientVersion = version$4, WS_PING_INTERVAL = 2e4, WS_PING_TIMEOUT = 1e4, WS_RECONNECT_DELAY = 2e3, WS_MAX_BADAUTH_ATTEMPTS = 3, LOG_CATEGORY = "EventApi";
class EventApi extends api_1.ApiClient {
  constructor(u, c, l, v, p, _) {
    super(u, c, v, LOG_CATEGORY, p, _), this.websocketServer = l, this.subscriptions = /* @__PURE__ */ new Set(), this.eventHandlers = {}, this.calls = {}, this.messageQueue = [], this.websocketReady = !1, this.reconnectionAttempts = 0, this.badAuthentication = !1, this.eventsClient = null;
  }
  /**
   * Publish a custom event
   *
   * note: if this session has an established stream, all custom
   * events will use that transport.
   *
   * @param request
   * @returns
   */
  publish(...u) {
    return this.websocketReady ? this.call("publish", u[0]) : this.eventsClient.publish(...u);
  }
  /**
   * Open the connection
   */
  connect() {
    if (!this.ws) {
      this.cleanup();
      const u = this.accessToken, c = [`version=${clientVersion}`, `sessionid=${this.sessionId}`];
      this.sdkVersion && c.push(`sdkversion=${this.sdkVersion}`), this.ws = new isomorphic_ws_1.default(`${this.websocketServer}/stream?${c.join("&")}`, [
        "Bearer",
        this.accessToken
      ]);
      let l;
      this.ws.addEventListener("message", (v) => {
        const p = JSON.parse(v.data.toString()), _ = p.result;
        if (p.error && (l = p.error, this.handleEvent("error", {
          error: {
            code: p.code,
            message: p.message
          }
        }), ["You do not have permission to this resource", "You do not have permission to this resource"].includes(p.message) && (this.badAuthentication = !0)), !_)
          return;
        _.reconnectBefore && _.reconnectBefore.reauthenticate && this.accessToken === u && (this.badAuthentication = !0);
        const k = EventApiModel.eventsApiSupportedEvents.find((O) => !!_[O]);
        k && this.handleEvent(k, _);
      }), this.ws.addEventListener("open", () => {
        this.log.info("websocket connected"), this.call("ping", "hello", { timeout: WS_PING_TIMEOUT, skipQueue: !0 }).then(() => {
          this.ready();
        }).catch((v) => {
          !l && v.message !== "Stream connection closed" && this.disconnect("hello timeout");
        });
      }), this.ws.addEventListener("close", (v) => {
        var p;
        l ? this.reconnect(`${(p = l == null ? void 0 : l.message) !== null && p !== void 0 ? p : "unknown"}`) : this.reconnect(`closed - ${v.reason || v.code}`);
      }), this.ws.addEventListener("error", (v) => {
        l = v;
      });
    }
  }
  /**
   * Subscribe to an event
   *
   * note: if a connection does not exist, one will be established.
   *
   * @param type
   * @param payload
   */
  async subscribe(u, c = {}) {
    return this.call("subscribe", { name: u, ...c }).then(() => {
      this.subscriptions.add(JSON.stringify({ name: u, ...c }));
    });
  }
  /**
   * Unsubscribe from an event
   * @param type
   * @param payload
   */
  async unsubscribe(u, c = {}) {
    this.subscriptions.delete(JSON.stringify({ name: u, payload: c })), await this.call("unsubscribe", { name: u, ...c });
  }
  on(u, c, l) {
    const v = l || c, p = {
      ignoreSessionEvents: !1,
      allowedSessionEvents: [],
      ...l ? c : {}
    };
    this.eventHandlers[u] || (this.eventHandlers[u] = []), this.eventHandlers[u].push({
      ...p,
      handler: v
    });
  }
  off(u, c, l) {
    var v;
    const p = l || c, _ = {
      ignoreSessionEvents: !1,
      allowedSessionEvents: [],
      ...l ? c : {}
    };
    this.eventHandlers[u] = ((v = this.eventHandlers[u]) !== null && v !== void 0 ? v : []).filter((k) => !(k.ignoreSessionEvents === _.ignoreSessionEvents && k.allowedSessionEvents === _.allowedSessionEvents && k.handler === p && k.name === _.name));
  }
  /**
   * Disconnect the websocket connection
   */
  disconnect(u) {
    this.log.warn(`disconnected from events reason=${u}`), Object.values(this.calls).forEach((c) => {
      clearTimeout(c.timeout), c.reject(new Error("Stream connection closed"));
    }), this.calls = {}, this.cleanup();
  }
  _setup(u) {
    this.eventsClient = this.clientFactory.create(EventApiModel.EventServiceDefinition, this.channel, {
      "*": u
    }), this.badAuthentication && (this.badAuthentication = !1, this.reconnectionAttempts = 0, this.reconnect("updated token"));
  }
  /**
   * Called when the websocket is ready.
   */
  ready() {
    this.reconnectionAttempts = 0, this.badAuthentication = !1, this.websocketReady = !0, this.handleEvent("connected", { connected: void 0 });
    for (const u of this.subscriptions.values())
      this.send({ subscribe: JSON.parse(u), correlationId: (0, uuid_1.v4)() });
    for (const u of this.messageQueue)
      this.send(u);
    this.messageQueue = [], this.pingLoop = setInterval(() => {
      this.ping();
    }, WS_PING_INTERVAL);
  }
  ping() {
    this.call("ping", `${+/* @__PURE__ */ new Date()}`, { timeout: WS_PING_TIMEOUT }).catch(() => {
      this.reconnect("connection stalled");
    });
  }
  /**
   * Reconnect event stream
   *
   * @param reason Rec
   */
  reconnect(u) {
    this.disconnect(u), this.reconnectTimeout = setTimeout(() => {
      if (this.reconnectionAttempts++, this.badAuthentication && this.reconnectionAttempts >= WS_MAX_BADAUTH_ATTEMPTS) {
        this.log.warn("Maximum number of reconnection attempts reached with bad authentication, please re-authenticate the SDK");
        return;
      }
      this.connect();
    }, WS_RECONNECT_DELAY);
  }
  /**
   * Send a raw message to the websocket.
   *
   * @param data
   */
  send(u) {
    this.ws && this.ws.readyState === this.ws.OPEN ? this.ws.send(JSON.stringify(u)) : this.log.warn("Message sent to a disconnected stream");
  }
  /**
   * Process a stream event
   *
   * @param name the name of the event
   * @param payload the full event stream payload
   *
   * @returns void
   */
  handleEvent(u, c) {
    var l;
    if (this.calls[c.correlationId]) {
      const v = EventApiModel.eventsApiEventRpcCalls[this.calls[c.correlationId].method] === u, p = !!c.error;
      if (v || p) {
        this.resolveCall(u, c);
        return;
      }
    }
    for (const v of (l = this.eventHandlers[u]) !== null && l !== void 0 ? l : []) {
      if (u === "event" && c.event) {
        if (c.sessionId === this.sessionId && v.ignoreSessionEvents && !v.allowedSessionEvents.includes(c.event.name)) {
          this.log.trace("ignoring user event from self: " + c.event.name + ", payload.sessionId=" + c.sessionId + ", this.sessionId");
          continue;
        }
        if (v.name && !(0, matcher_1.isMatch)(c.event.name, v.name))
          continue;
        if (this.eventLogCallback) {
          let p, _ = c.event.name, k;
          if (c.event.name.startsWith(EventApi.APISTREAM_EVENT_PREFIX)) {
            let O = c.event.name.split(":");
            O.length == 4 && (p = O[1], _ = O[2], k = O[3]), this.eventLogCallback(p, _, k, c);
          }
        }
      } else if (c.sessionId === this.sessionId && v.ignoreSessionEvents) {
        this.log.trace("ignoring event from self: " + c.event.name + ", payload.sessionId=" + c.sessionId + ", this.sessionId");
        continue;
      }
      this.log.trace("processing event: payload.sessionId=" + c.sessionId + ", this.sessionId"), v.handler(c ? c[u] : void 0, { isFromCurrentSession: c.sessionId === this.sessionId });
    }
  }
  /**
   * Make an RPC call
   *
   * Initiates an async request via the stream. A correlationId is generated and used to track
   * responses and errors. A handler is registered
   *
   * @param method request method to call
   * @param payload payload to send
   * @param opts timeout
   * @returns
   */
  async call(u, c, l = { timeout: 2e4, skipQueue: !1 }) {
    this.ws || this.connect();
    const v = (0, uuid_1.v4)();
    return new Promise((p, _) => {
      const k = setTimeout(() => {
        delete this.calls[v], _(new Error("Request timed out"));
      }, l.timeout);
      this.calls[v] = { resolve: p, reject: _, timeout: k, method: u }, this.websocketReady || l.skipQueue ? this.send({ [u]: c, correlationId: v }) : this.messageQueue.push({ [u]: c, correlationId: v });
    });
  }
  /**
   * Handler for `.call()`
   *
   * Handle response events for a socket call.
   *
   * @param name name of responding event
   * @param payload payload of the event
   * @returns void
   */
  resolveCall(u, c) {
    const l = this.calls[c.correlationId];
    if (l) {
      if (clearTimeout(l.timeout), delete this.calls[c.correlationId], u === "error" && c.error) {
        l.reject(new NiceGrpc.ClientError("error", c.error.code, c.error.message));
        return;
      }
      l.resolve(c[u]);
    }
  }
  /**
   * Cleanup connection
   *
   * This cleans up the local state for a given websocket connection.
   */
  cleanup() {
    clearTimeout(this.pingLoop), clearTimeout(this.reconnectTimeout), this.websocketReady = !1, this.ws && (this.ws.onclose = function() {
    }, this.ws.close(), this.ws = null);
  }
}
eventapi.EventApi = EventApi;
EventApi.APISTREAM_EVENT_PREFIX = "apistream";
var livekit = {}, __importDefault$7 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(livekit, "__esModule", { value: !0 });
livekit.LiveKitUtils = void 0;
const jwt_decode_1 = __importDefault$7(require$$0$3);
class LiveKitUtils {
  static decodeJwt(u) {
    return (0, jwt_decode_1.default)(u, { header: !1 });
  }
  static isRoomAdmin(u) {
    return LiveKitUtils.decodeJwt(u).video.roomAdmin;
  }
  static getRoomName(u) {
    return LiveKitUtils.decodeJwt(u).video.room;
  }
}
livekit.LiveKitUtils = LiveKitUtils;
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(Te, q, z, P) {
    P === void 0 && (P = z);
    var S = Object.getOwnPropertyDescriptor(q, z);
    (!S || ("get" in S ? !q.__esModule : S.writable || S.configurable)) && (S = { enumerable: !0, get: function() {
      return q[z];
    } }), Object.defineProperty(Te, P, S);
  } : function(Te, q, z, P) {
    P === void 0 && (P = z), Te[P] = q[z];
  }), c = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(Te, q) {
    Object.defineProperty(Te, "default", { enumerable: !0, value: q });
  } : function(Te, q) {
    Te.default = q;
  }), l = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(Te) {
    if (Te && Te.__esModule)
      return Te;
    var q = {};
    if (Te != null)
      for (var z in Te)
        z !== "default" && Object.prototype.hasOwnProperty.call(Te, z) && u(q, Te, z);
    return c(q, Te), q;
  }, v = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(Te) {
    return Te && Te.__esModule ? Te : { default: Te };
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.ApiStream = a.LiveKitUtils = a.EventApiModel = a.LayoutApiModel = a.LiveApiModel = void 0;
  const p = v(require$$0$3), _ = require$$1$4, k = require$$2$2, O = layoutapi, D = liveapi, F = eventapi, H = l(api$2);
  a.LiveApiModel = H;
  const Z = l(dist$2);
  a.LayoutApiModel = Z;
  const ee = l(dist$1);
  a.EventApiModel = ee;
  const X = livekit;
  Object.defineProperty(a, "LiveKitUtils", { enumerable: !0, get: function() {
    return X.LiveKitUtils;
  } });
  const ne = logger, Q = version$4, ae = {
    dev: "http://127.0.0.1:8081",
    stage: "https://live.silly.horse/grpcweb/live/v2",
    prod: "https://live.api.stream/grpcweb/live/v2"
  }, j = {
    dev: "https://live.silly.horse/grpcweb/layout/v2",
    stage: "https://live.silly.horse/grpcweb/layout/v2",
    prod: "https://live.api.stream/grpcweb/layout/v2"
  }, ue = {
    dev: "wss://live.silly.horse/event/v2",
    stage: "wss://live.silly.horse/event/v2",
    prod: "wss://live.api.stream/event/v2"
  }, he = {
    dev: "https://live.silly.horse/grpcweb/event/v2",
    stage: "https://live.silly.horse/grpcweb/event/v2",
    prod: "https://live.api.stream/grpcweb/event/v2"
  }, fe = {
    dev: "wss://live.silly.horse/webrtc/v2",
    stage: "wss://live.silly.horse/webrtc/v2",
    prod: "wss://live.api.stream/webrtc/v2"
  }, be = {
    dev: "https://live.silly.horse/webrtc/v2",
    stage: "https://live.silly.horse/webrtc/v2",
    prod: "https://live.api.stream/webrtc/v2"
  };
  class ke {
    /**
     * Create an ApiStream API Client
     */
    constructor(q = {}) {
      var z;
      const P = {
        env: "prod",
        logLevel: "Warn",
        ...q
      };
      this.env = P.env;
      let S = (0, _.v4)();
      P.sessionId != null && (S = P.sessionId), this.log = ne.logger.getCategory("ApiStream"), this.setLogLevel(P.env == "dev" ? "Trace" : P.logLevel);
      const E = (z = P.overrideEndpoints) !== null && z !== void 0 ? z : {};
      E.liveApiServer == null && (E.liveApiServer = ae[this.env]), E.layoutApiServer == null && (E.layoutApiServer = j[this.env]), E.eventApiServer == null && (E.eventApiServer = he[this.env]), E.eventApiWebSocketServer == null && (E.eventApiWebSocketServer = ue[this.env]), this.eventApi = new F.EventApi(S, E.eventApiServer, E.eventApiWebSocketServer, P.sdkVersion, P.apiLogCallback, P.eventLogCallback), this.layoutApi = new O.LayoutApi(S, this.eventApi, E.layoutApiServer, P.sdkVersion, P.apiLogCallback), this.liveApi = new D.LiveApi(S, this.eventApi, E.liveApiServer, this.setAccessToken.bind(this), P.apiKey, P.sdkVersion, P.apiLogCallback), this.eventApi.on("reconnectBefore", (I) => {
        I.reauthenticate && this.liveApi.authentication.refreshAccessToken({}).catch(() => {
        });
      }), this.log.info("api.stream: sessionid=" + S + ", version=" + Q + ", sdkVersion=" + P.sdkVersion);
    }
    /**
     * Returns the live api client
     *
     * @returns the live api client
     */
    LiveApi() {
      return this.liveApi;
    }
    /**
     * Returns the layout api client
     *
     * @returns the layout api client
     */
    LayoutApi() {
      return this.layoutApi;
    }
    /**
     * Returns the layout api client
     *
     * @returns the layout api client
     */
    EventApi() {
      return this.eventApi;
    }
    setLogLevel(q) {
      try {
        let z = k.LogLevel.toLogLevel(q);
        ne.logger.updateRuntimeSettings({
          level: z
        });
      } catch {
        this.log.warn(`unknown logging level ${q}`);
      }
    }
    setAccessToken(q) {
      this.decodedAccessToken = ke.decodeAccessToken(q), this.log.debug("setting accessToken", q, this.decodedAccessToken), this.layoutApi.setAccessToken(q), this.liveApi.setAccessToken(q), this.eventApi.setAccessToken(q);
    }
    getAccessToken() {
      return this.decodedAccessToken;
    }
    /**
     * Are we running as a guest role?
     *
     * @returns {(ApiStream.GuestProject | null)} return the active project if running as a guest role
     */
    getGuestProject() {
      return this.decodedAccessToken.guestControl;
    }
    /**
     * Initialize the api library and check if we are running inside of the rendering engine
     * @async
     * @param {string} accessToken - a valid ApiStream access token
     * @returns {(ApiStream.GuestProject | null)} if we are operating inside of the rendering engine, this is the active project
     */
    async load(q) {
      if (q == null && typeof window < "u") {
        let z = this.parseQuery();
        z.get(ke.ACCESS_TOKEN_QUERY_PARAM) != null && (q = z.get(ke.ACCESS_TOKEN_QUERY_PARAM));
      }
      return q != null && (this.setAccessToken(q), this.decodedAccessToken.guestControl != null) ? (this.log.info("loading guest token and exchanging"), await this.LiveApi().authentication.refreshAccessToken({}), this.log.info("auto-loading project = " + JSON.stringify(this.decodedAccessToken.guestControl)), this.decodedAccessToken.guestControl) : null;
    }
    /**
     * get the signaling address of the appropriate livekit webrtc server
     *
     * @param {boolean} admin - if true, return the admin (vs. client) address
     * @returns {string} the address of the appropriate livekit webrtc server
     */
    getLiveKitServer(q = !1) {
      return q ? be[this.env] : fe[this.env];
    }
    parseQuery() {
      let q = window.location.search, z = /* @__PURE__ */ new Map(), P = (q[0] === "?" ? q.substr(1) : q).split("&");
      for (let S = 0; S < P.length; S++) {
        let E = P[S].split("=");
        E.length == 2 && (z.set(decodeURIComponent(E[0]), decodeURIComponent(E[1] || "")), this.log.debug(`found query param: ${decodeURIComponent(E[0])}=${decodeURIComponent(E[1] || "")}`));
      }
      return z;
    }
    static decodeAccessToken(q) {
      let z = (0, p.default)(q, { header: !1 }), P = {
        serviceUserId: z.user.serviceUserId,
        userId: z.user.userId,
        displayName: z.user.displayName,
        trial: z.user.trial,
        demo: z.user.demo
      };
      return z.guestControl != null && (P.guestControl = {
        collectionId: z.guestControl.collectionId,
        projectId: z.guestControl.projectId,
        role: H.roleFromJSON(z.guestControl.role)
      }), P;
    }
  }
  a.ApiStream = ke, ke.ACCESS_TOKEN_QUERY_PARAM = "at";
})(lib$2);
const config$2 = (a) => ({
  defaults: {
    previewTokenDuration: 1e3 * 60 * 60,
    guestTokenDuration: 1e3 * 60 * 60 * 12,
    transforms: {
      RoomParticipant: "LS-Room-Participant",
      Image: "LS-Image",
      Banner: "LS-Banner",
      Text: "LS-Text"
    }
  }
});
var fastDeepEqual = function a(u, c) {
  if (u === c)
    return !0;
  if (u && c && typeof u == "object" && typeof c == "object") {
    if (u.constructor !== c.constructor)
      return !1;
    var l, v, p;
    if (Array.isArray(u)) {
      if (l = u.length, l != c.length)
        return !1;
      for (v = l; v-- !== 0; )
        if (!a(u[v], c[v]))
          return !1;
      return !0;
    }
    if (u.constructor === RegExp)
      return u.source === c.source && u.flags === c.flags;
    if (u.valueOf !== Object.prototype.valueOf)
      return u.valueOf() === c.valueOf();
    if (u.toString !== Object.prototype.toString)
      return u.toString() === c.toString();
    if (p = Object.keys(u), l = p.length, l !== Object.keys(c).length)
      return !1;
    for (v = l; v-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(c, p[v]))
        return !1;
    for (v = l; v-- !== 0; ) {
      var _ = p[v];
      if (!a(u[_], c[_]))
        return !1;
    }
    return !0;
  }
  return u !== u && c !== c;
};
const deepEqual = /* @__PURE__ */ getDefaultExportFromCjs$2(fastDeepEqual), global$1 = globalThis || void 0 || self;
var freeGlobal = typeof global$1 == "object" && global$1 && global$1.Object === Object && global$1, freeSelf = typeof self == "object" && self && self.Object === Object && self, root = freeGlobal || freeSelf || Function("return this")(), Symbol$1 = root.Symbol, objectProto$m = Object.prototype, hasOwnProperty$f = objectProto$m.hasOwnProperty, nativeObjectToString$1 = objectProto$m.toString, symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : void 0;
function getRawTag(a) {
  var u = hasOwnProperty$f.call(a, symToStringTag$1), c = a[symToStringTag$1];
  try {
    a[symToStringTag$1] = void 0;
    var l = !0;
  } catch {
  }
  var v = nativeObjectToString$1.call(a);
  return l && (u ? a[symToStringTag$1] = c : delete a[symToStringTag$1]), v;
}
var objectProto$l = Object.prototype, nativeObjectToString = objectProto$l.toString;
function objectToString$7(a) {
  return nativeObjectToString.call(a);
}
var nullTag = "[object Null]", undefinedTag = "[object Undefined]", symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
function baseGetTag(a) {
  return a == null ? a === void 0 ? undefinedTag : nullTag : symToStringTag && symToStringTag in Object(a) ? getRawTag(a) : objectToString$7(a);
}
function isObjectLike$7(a) {
  return a != null && typeof a == "object";
}
var symbolTag$6 = "[object Symbol]";
function isSymbol$3(a) {
  return typeof a == "symbol" || isObjectLike$7(a) && baseGetTag(a) == symbolTag$6;
}
function arrayMap$1(a, u) {
  for (var c = -1, l = a == null ? 0 : a.length, v = Array(l); ++c < l; )
    v[c] = u(a[c], c, a);
  return v;
}
var isArray$4 = Array.isArray, INFINITY$4 = 1 / 0, symbolProto$2 = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString = symbolProto$2 ? symbolProto$2.toString : void 0;
function baseToString(a) {
  if (typeof a == "string")
    return a;
  if (isArray$4(a))
    return arrayMap$1(a, baseToString) + "";
  if (isSymbol$3(a))
    return symbolToString ? symbolToString.call(a) : "";
  var u = a + "";
  return u == "0" && 1 / a == -INFINITY$4 ? "-0" : u;
}
var reWhitespace = /\s/;
function trimmedEndIndex(a) {
  for (var u = a.length; u-- && reWhitespace.test(a.charAt(u)); )
    ;
  return u;
}
var reTrimStart = /^\s+/;
function baseTrim(a) {
  return a && a.slice(0, trimmedEndIndex(a) + 1).replace(reTrimStart, "");
}
function isObject$8(a) {
  var u = typeof a;
  return a != null && (u == "object" || u == "function");
}
var NAN$3 = NaN, reIsBadHex$3 = /^[-+]0x[0-9a-f]+$/i, reIsBinary$3 = /^0b[01]+$/i, reIsOctal$3 = /^0o[0-7]+$/i, freeParseInt$3 = parseInt;
function toNumber$3(a) {
  if (typeof a == "number")
    return a;
  if (isSymbol$3(a))
    return NAN$3;
  if (isObject$8(a)) {
    var u = typeof a.valueOf == "function" ? a.valueOf() : a;
    a = isObject$8(u) ? u + "" : u;
  }
  if (typeof a != "string")
    return a === 0 ? a : +a;
  a = baseTrim(a);
  var c = reIsBinary$3.test(a);
  return c || reIsOctal$3.test(a) ? freeParseInt$3(a.slice(2), c ? 2 : 8) : reIsBadHex$3.test(a) ? NAN$3 : +a;
}
function identity(a) {
  return a;
}
var asyncTag = "[object AsyncFunction]", funcTag$3 = "[object Function]", genTag$2 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction$2(a) {
  if (!isObject$8(a))
    return !1;
  var u = baseGetTag(a);
  return u == funcTag$3 || u == genTag$2 || u == asyncTag || u == proxyTag;
}
var coreJsData = root["__core-js_shared__"], maskSrcKey = function() {
  var a = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return a ? "Symbol(src)_1." + a : "";
}();
function isMasked(a) {
  return !!maskSrcKey && maskSrcKey in a;
}
var funcProto$3 = Function.prototype, funcToString$3 = funcProto$3.toString;
function toSource(a) {
  if (a != null) {
    try {
      return funcToString$3.call(a);
    } catch {
    }
    try {
      return a + "";
    } catch {
    }
  }
  return "";
}
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reIsHostCtor = /^\[object .+?Constructor\]$/, funcProto$2 = Function.prototype, objectProto$k = Object.prototype, funcToString$2 = funcProto$2.toString, hasOwnProperty$e = objectProto$k.hasOwnProperty, reIsNative = RegExp(
  "^" + funcToString$2.call(hasOwnProperty$e).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative(a) {
  if (!isObject$8(a) || isMasked(a))
    return !1;
  var u = isFunction$2(a) ? reIsNative : reIsHostCtor;
  return u.test(toSource(a));
}
function getValue(a, u) {
  return a == null ? void 0 : a[u];
}
function getNative(a, u) {
  var c = getValue(a, u);
  return baseIsNative(c) ? c : void 0;
}
var WeakMap$2 = getNative(root, "WeakMap"), objectCreate = Object.create, baseCreate = /* @__PURE__ */ function() {
  function a() {
  }
  return function(u) {
    if (!isObject$8(u))
      return {};
    if (objectCreate)
      return objectCreate(u);
    a.prototype = u;
    var c = new a();
    return a.prototype = void 0, c;
  };
}();
function apply(a, u, c) {
  switch (c.length) {
    case 0:
      return a.call(u);
    case 1:
      return a.call(u, c[0]);
    case 2:
      return a.call(u, c[0], c[1]);
    case 3:
      return a.call(u, c[0], c[1], c[2]);
  }
  return a.apply(u, c);
}
function copyArray(a, u) {
  var c = -1, l = a.length;
  for (u || (u = Array(l)); ++c < l; )
    u[c] = a[c];
  return u;
}
var HOT_COUNT = 800, HOT_SPAN = 16, nativeNow = Date.now;
function shortOut(a) {
  var u = 0, c = 0;
  return function() {
    var l = nativeNow(), v = HOT_SPAN - (l - c);
    if (c = l, v > 0) {
      if (++u >= HOT_COUNT)
        return arguments[0];
    } else
      u = 0;
    return a.apply(void 0, arguments);
  };
}
function constant(a) {
  return function() {
    return a;
  };
}
var defineProperty = function() {
  try {
    var a = getNative(Object, "defineProperty");
    return a({}, "", {}), a;
  } catch {
  }
}(), baseSetToString = defineProperty ? function(a, u) {
  return defineProperty(a, "toString", {
    configurable: !0,
    enumerable: !1,
    value: constant(u),
    writable: !0
  });
} : identity;
const baseSetToString$1 = baseSetToString;
var setToString = shortOut(baseSetToString$1);
function arrayEach(a, u) {
  for (var c = -1, l = a == null ? 0 : a.length; ++c < l && u(a[c], c, a) !== !1; )
    ;
  return a;
}
function baseFindIndex$1(a, u, c, l) {
  for (var v = a.length, p = c + (l ? 1 : -1); l ? p-- : ++p < v; )
    if (u(a[p], p, a))
      return p;
  return -1;
}
function baseIsNaN$1(a) {
  return a !== a;
}
function strictIndexOf(a, u, c) {
  for (var l = c - 1, v = a.length; ++l < v; )
    if (a[l] === u)
      return l;
  return -1;
}
function baseIndexOf$1(a, u, c) {
  return u === u ? strictIndexOf(a, u, c) : baseFindIndex$1(a, baseIsNaN$1, c);
}
var MAX_SAFE_INTEGER$2 = 9007199254740991, reIsUint$1 = /^(?:0|[1-9]\d*)$/;
function isIndex$1(a, u) {
  var c = typeof a;
  return u = u ?? MAX_SAFE_INTEGER$2, !!u && (c == "number" || c != "symbol" && reIsUint$1.test(a)) && a > -1 && a % 1 == 0 && a < u;
}
function baseAssignValue(a, u, c) {
  u == "__proto__" && defineProperty ? defineProperty(a, u, {
    configurable: !0,
    enumerable: !0,
    value: c,
    writable: !0
  }) : a[u] = c;
}
function eq(a, u) {
  return a === u || a !== a && u !== u;
}
var objectProto$j = Object.prototype, hasOwnProperty$d = objectProto$j.hasOwnProperty;
function assignValue(a, u, c) {
  var l = a[u];
  (!(hasOwnProperty$d.call(a, u) && eq(l, c)) || c === void 0 && !(u in a)) && baseAssignValue(a, u, c);
}
function copyObject(a, u, c, l) {
  var v = !c;
  c || (c = {});
  for (var p = -1, _ = u.length; ++p < _; ) {
    var k = u[p], O = l ? l(c[k], a[k], k, c, a) : void 0;
    O === void 0 && (O = a[k]), v ? baseAssignValue(c, k, O) : assignValue(c, k, O);
  }
  return c;
}
var nativeMax$2 = Math.max;
function overRest(a, u, c) {
  return u = nativeMax$2(u === void 0 ? a.length - 1 : u, 0), function() {
    for (var l = arguments, v = -1, p = nativeMax$2(l.length - u, 0), _ = Array(p); ++v < p; )
      _[v] = l[u + v];
    v = -1;
    for (var k = Array(u + 1); ++v < u; )
      k[v] = l[v];
    return k[u] = c(_), apply(a, this, k);
  };
}
function baseRest(a, u) {
  return setToString(overRest(a, u, identity), a + "");
}
var MAX_SAFE_INTEGER$1 = 9007199254740991;
function isLength$1(a) {
  return typeof a == "number" && a > -1 && a % 1 == 0 && a <= MAX_SAFE_INTEGER$1;
}
function isArrayLike$1(a) {
  return a != null && isLength$1(a.length) && !isFunction$2(a);
}
function isIterateeCall(a, u, c) {
  if (!isObject$8(c))
    return !1;
  var l = typeof u;
  return (l == "number" ? isArrayLike$1(c) && isIndex$1(u, c.length) : l == "string" && u in c) ? eq(c[u], a) : !1;
}
var objectProto$i = Object.prototype;
function isPrototype$1(a) {
  var u = a && a.constructor, c = typeof u == "function" && u.prototype || objectProto$i;
  return a === c;
}
function baseTimes$1(a, u) {
  for (var c = -1, l = Array(a); ++c < a; )
    l[c] = u(c);
  return l;
}
var argsTag$4 = "[object Arguments]";
function baseIsArguments(a) {
  return isObjectLike$7(a) && baseGetTag(a) == argsTag$4;
}
var objectProto$h = Object.prototype, hasOwnProperty$c = objectProto$h.hasOwnProperty, propertyIsEnumerable$2 = objectProto$h.propertyIsEnumerable, isArguments$2 = baseIsArguments(/* @__PURE__ */ function() {
  return arguments;
}()) ? baseIsArguments : function(a) {
  return isObjectLike$7(a) && hasOwnProperty$c.call(a, "callee") && !propertyIsEnumerable$2.call(a, "callee");
};
function stubFalse() {
  return !1;
}
var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports, freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module, moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2, Buffer$N = moduleExports$2 ? root.Buffer : void 0, nativeIsBuffer = Buffer$N ? Buffer$N.isBuffer : void 0, isBuffer$1 = nativeIsBuffer || stubFalse, argsTag$3 = "[object Arguments]", arrayTag$2 = "[object Array]", boolTag$4 = "[object Boolean]", dateTag$3 = "[object Date]", errorTag$2 = "[object Error]", funcTag$2 = "[object Function]", mapTag$5 = "[object Map]", numberTag$4 = "[object Number]", objectTag$5 = "[object Object]", regexpTag$3 = "[object RegExp]", setTag$5 = "[object Set]", stringTag$5 = "[object String]", weakMapTag$2 = "[object WeakMap]", arrayBufferTag$3 = "[object ArrayBuffer]", dataViewTag$4 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]", typedArrayTags = {};
typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = !0;
typedArrayTags[argsTag$3] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$3] = typedArrayTags[boolTag$4] = typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$3] = typedArrayTags[errorTag$2] = typedArrayTags[funcTag$2] = typedArrayTags[mapTag$5] = typedArrayTags[numberTag$4] = typedArrayTags[objectTag$5] = typedArrayTags[regexpTag$3] = typedArrayTags[setTag$5] = typedArrayTags[stringTag$5] = typedArrayTags[weakMapTag$2] = !1;
function baseIsTypedArray(a) {
  return isObjectLike$7(a) && isLength$1(a.length) && !!typedArrayTags[baseGetTag(a)];
}
function baseUnary(a) {
  return function(u) {
    return a(u);
  };
}
var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports, freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module, moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1, freeProcess = moduleExports$1 && freeGlobal.process, nodeUtil = function() {
  try {
    var a = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
    return a || freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch {
  }
}(), nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray, isTypedArray$1 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray, objectProto$g = Object.prototype, hasOwnProperty$b = objectProto$g.hasOwnProperty;
function arrayLikeKeys$1(a, u) {
  var c = isArray$4(a), l = !c && isArguments$2(a), v = !c && !l && isBuffer$1(a), p = !c && !l && !v && isTypedArray$1(a), _ = c || l || v || p, k = _ ? baseTimes$1(a.length, String) : [], O = k.length;
  for (var D in a)
    (u || hasOwnProperty$b.call(a, D)) && !(_ && // Safari 9 has enumerable `arguments.length` in strict mode.
    (D == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    v && (D == "offset" || D == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    p && (D == "buffer" || D == "byteLength" || D == "byteOffset") || // Skip index properties.
    isIndex$1(D, O))) && k.push(D);
  return k;
}
function overArg$2(a, u) {
  return function(c) {
    return a(u(c));
  };
}
var nativeKeys$1 = overArg$2(Object.keys, Object), objectProto$f = Object.prototype, hasOwnProperty$a = objectProto$f.hasOwnProperty;
function baseKeys$1(a) {
  if (!isPrototype$1(a))
    return nativeKeys$1(a);
  var u = [];
  for (var c in Object(a))
    hasOwnProperty$a.call(a, c) && c != "constructor" && u.push(c);
  return u;
}
function keys$2(a) {
  return isArrayLike$1(a) ? arrayLikeKeys$1(a) : baseKeys$1(a);
}
function nativeKeysIn(a) {
  var u = [];
  if (a != null)
    for (var c in Object(a))
      u.push(c);
  return u;
}
var objectProto$e = Object.prototype, hasOwnProperty$9 = objectProto$e.hasOwnProperty;
function baseKeysIn(a) {
  if (!isObject$8(a))
    return nativeKeysIn(a);
  var u = isPrototype$1(a), c = [];
  for (var l in a)
    l == "constructor" && (u || !hasOwnProperty$9.call(a, l)) || c.push(l);
  return c;
}
function keysIn(a) {
  return isArrayLike$1(a) ? arrayLikeKeys$1(a, !0) : baseKeysIn(a);
}
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
function isKey(a, u) {
  if (isArray$4(a))
    return !1;
  var c = typeof a;
  return c == "number" || c == "symbol" || c == "boolean" || a == null || isSymbol$3(a) ? !0 : reIsPlainProp.test(a) || !reIsDeepProp.test(a) || u != null && a in Object(u);
}
var nativeCreate = getNative(Object, "create");
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {}, this.size = 0;
}
function hashDelete(a) {
  var u = this.has(a) && delete this.__data__[a];
  return this.size -= u ? 1 : 0, u;
}
var HASH_UNDEFINED$2 = "__lodash_hash_undefined__", objectProto$d = Object.prototype, hasOwnProperty$8 = objectProto$d.hasOwnProperty;
function hashGet(a) {
  var u = this.__data__;
  if (nativeCreate) {
    var c = u[a];
    return c === HASH_UNDEFINED$2 ? void 0 : c;
  }
  return hasOwnProperty$8.call(u, a) ? u[a] : void 0;
}
var objectProto$c = Object.prototype, hasOwnProperty$7 = objectProto$c.hasOwnProperty;
function hashHas(a) {
  var u = this.__data__;
  return nativeCreate ? u[a] !== void 0 : hasOwnProperty$7.call(u, a);
}
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
function hashSet(a, u) {
  var c = this.__data__;
  return this.size += this.has(a) ? 0 : 1, c[a] = nativeCreate && u === void 0 ? HASH_UNDEFINED$1 : u, this;
}
function Hash$8(a) {
  var u = -1, c = a == null ? 0 : a.length;
  for (this.clear(); ++u < c; ) {
    var l = a[u];
    this.set(l[0], l[1]);
  }
}
Hash$8.prototype.clear = hashClear;
Hash$8.prototype.delete = hashDelete;
Hash$8.prototype.get = hashGet;
Hash$8.prototype.has = hashHas;
Hash$8.prototype.set = hashSet;
function listCacheClear() {
  this.__data__ = [], this.size = 0;
}
function assocIndexOf(a, u) {
  for (var c = a.length; c--; )
    if (eq(a[c][0], u))
      return c;
  return -1;
}
var arrayProto$1 = Array.prototype, splice$1 = arrayProto$1.splice;
function listCacheDelete(a) {
  var u = this.__data__, c = assocIndexOf(u, a);
  if (c < 0)
    return !1;
  var l = u.length - 1;
  return c == l ? u.pop() : splice$1.call(u, c, 1), --this.size, !0;
}
function listCacheGet(a) {
  var u = this.__data__, c = assocIndexOf(u, a);
  return c < 0 ? void 0 : u[c][1];
}
function listCacheHas(a) {
  return assocIndexOf(this.__data__, a) > -1;
}
function listCacheSet(a, u) {
  var c = this.__data__, l = assocIndexOf(c, a);
  return l < 0 ? (++this.size, c.push([a, u])) : c[l][1] = u, this;
}
function ListCache(a) {
  var u = -1, c = a == null ? 0 : a.length;
  for (this.clear(); ++u < c; ) {
    var l = a[u];
    this.set(l[0], l[1]);
  }
}
ListCache.prototype.clear = listCacheClear;
ListCache.prototype.delete = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
var Map$1 = getNative(root, "Map");
function mapCacheClear() {
  this.size = 0, this.__data__ = {
    hash: new Hash$8(),
    map: new (Map$1 || ListCache)(),
    string: new Hash$8()
  };
}
function isKeyable(a) {
  var u = typeof a;
  return u == "string" || u == "number" || u == "symbol" || u == "boolean" ? a !== "__proto__" : a === null;
}
function getMapData(a, u) {
  var c = a.__data__;
  return isKeyable(u) ? c[typeof u == "string" ? "string" : "hash"] : c.map;
}
function mapCacheDelete(a) {
  var u = getMapData(this, a).delete(a);
  return this.size -= u ? 1 : 0, u;
}
function mapCacheGet(a) {
  return getMapData(this, a).get(a);
}
function mapCacheHas(a) {
  return getMapData(this, a).has(a);
}
function mapCacheSet(a, u) {
  var c = getMapData(this, a), l = c.size;
  return c.set(a, u), this.size += c.size == l ? 0 : 1, this;
}
function MapCache(a) {
  var u = -1, c = a == null ? 0 : a.length;
  for (this.clear(); ++u < c; ) {
    var l = a[u];
    this.set(l[0], l[1]);
  }
}
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype.delete = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
var FUNC_ERROR_TEXT$2 = "Expected a function";
function memoize(a, u) {
  if (typeof a != "function" || u != null && typeof u != "function")
    throw new TypeError(FUNC_ERROR_TEXT$2);
  var c = function() {
    var l = arguments, v = u ? u.apply(this, l) : l[0], p = c.cache;
    if (p.has(v))
      return p.get(v);
    var _ = a.apply(this, l);
    return c.cache = p.set(v, _) || p, _;
  };
  return c.cache = new (memoize.Cache || MapCache)(), c;
}
memoize.Cache = MapCache;
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(a) {
  var u = memoize(a, function(l) {
    return c.size === MAX_MEMOIZE_SIZE && c.clear(), l;
  }), c = u.cache;
  return u;
}
var rePropName$1 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, reEscapeChar$1 = /\\(\\)?/g, stringToPath$1 = memoizeCapped(function(a) {
  var u = [];
  return a.charCodeAt(0) === 46 && u.push(""), a.replace(rePropName$1, function(c, l, v, p) {
    u.push(v ? p.replace(reEscapeChar$1, "$1") : l || c);
  }), u;
});
function toString$3(a) {
  return a == null ? "" : baseToString(a);
}
function castPath(a, u) {
  return isArray$4(a) ? a : isKey(a, u) ? [a] : stringToPath$1(toString$3(a));
}
var INFINITY$3 = 1 / 0;
function toKey(a) {
  if (typeof a == "string" || isSymbol$3(a))
    return a;
  var u = a + "";
  return u == "0" && 1 / a == -INFINITY$3 ? "-0" : u;
}
function baseGet(a, u) {
  u = castPath(u, a);
  for (var c = 0, l = u.length; a != null && c < l; )
    a = a[toKey(u[c++])];
  return c && c == l ? a : void 0;
}
function get(a, u, c) {
  var l = a == null ? void 0 : baseGet(a, u);
  return l === void 0 ? c : l;
}
function arrayPush(a, u) {
  for (var c = -1, l = u.length, v = a.length; ++c < l; )
    a[v + c] = u[c];
  return a;
}
var spreadableSymbol = Symbol$1 ? Symbol$1.isConcatSpreadable : void 0;
function isFlattenable(a) {
  return isArray$4(a) || isArguments$2(a) || !!(spreadableSymbol && a && a[spreadableSymbol]);
}
function baseFlatten(a, u, c, l, v) {
  var p = -1, _ = a.length;
  for (c || (c = isFlattenable), v || (v = []); ++p < _; ) {
    var k = a[p];
    u > 0 && c(k) ? u > 1 ? baseFlatten(k, u - 1, c, l, v) : arrayPush(v, k) : l || (v[v.length] = k);
  }
  return v;
}
function flatten(a) {
  var u = a == null ? 0 : a.length;
  return u ? baseFlatten(a, 1) : [];
}
function flatRest(a) {
  return setToString(overRest(a, void 0, flatten), a + "");
}
var getPrototype$1 = overArg$2(Object.getPrototypeOf, Object);
const getPrototype$2 = getPrototype$1;
var objectTag$4 = "[object Object]", funcProto$1 = Function.prototype, objectProto$b = Object.prototype, funcToString$1 = funcProto$1.toString, hasOwnProperty$6 = objectProto$b.hasOwnProperty, objectCtorString$1 = funcToString$1.call(Object);
function isPlainObject$3(a) {
  if (!isObjectLike$7(a) || baseGetTag(a) != objectTag$4)
    return !1;
  var u = getPrototype$2(a);
  if (u === null)
    return !0;
  var c = hasOwnProperty$6.call(u, "constructor") && u.constructor;
  return typeof c == "function" && c instanceof c && funcToString$1.call(c) == objectCtorString$1;
}
function baseSlice(a, u, c) {
  var l = -1, v = a.length;
  u < 0 && (u = -u > v ? 0 : v + u), c = c > v ? v : c, c < 0 && (c += v), v = u > c ? 0 : c - u >>> 0, u >>>= 0;
  for (var p = Array(v); ++l < v; )
    p[l] = a[l + u];
  return p;
}
function castSlice(a, u, c) {
  var l = a.length;
  return c = c === void 0 ? l : c, !u && c >= l ? a : baseSlice(a, u, c);
}
var rsAstralRange$2 = "\\ud800-\\udfff", rsComboMarksRange$3 = "\\u0300-\\u036f", reComboHalfMarksRange$3 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$3 = "\\u20d0-\\u20ff", rsComboRange$3 = rsComboMarksRange$3 + reComboHalfMarksRange$3 + rsComboSymbolsRange$3, rsVarRange$2 = "\\ufe0e\\ufe0f", rsZWJ$2 = "\\u200d", reHasUnicode = RegExp("[" + rsZWJ$2 + rsAstralRange$2 + rsComboRange$3 + rsVarRange$2 + "]");
function hasUnicode(a) {
  return reHasUnicode.test(a);
}
function asciiToArray(a) {
  return a.split("");
}
var rsAstralRange$1 = "\\ud800-\\udfff", rsComboMarksRange$2 = "\\u0300-\\u036f", reComboHalfMarksRange$2 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$2 = "\\u20d0-\\u20ff", rsComboRange$2 = rsComboMarksRange$2 + reComboHalfMarksRange$2 + rsComboSymbolsRange$2, rsVarRange$1 = "\\ufe0e\\ufe0f", rsAstral = "[" + rsAstralRange$1 + "]", rsCombo$2 = "[" + rsComboRange$2 + "]", rsFitz$1 = "\\ud83c[\\udffb-\\udfff]", rsModifier$1 = "(?:" + rsCombo$2 + "|" + rsFitz$1 + ")", rsNonAstral$1 = "[^" + rsAstralRange$1 + "]", rsRegional$1 = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair$1 = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsZWJ$1 = "\\u200d", reOptMod$1 = rsModifier$1 + "?", rsOptVar$1 = "[" + rsVarRange$1 + "]?", rsOptJoin$1 = "(?:" + rsZWJ$1 + "(?:" + [rsNonAstral$1, rsRegional$1, rsSurrPair$1].join("|") + ")" + rsOptVar$1 + reOptMod$1 + ")*", rsSeq$1 = rsOptVar$1 + reOptMod$1 + rsOptJoin$1, rsSymbol = "(?:" + [rsNonAstral$1 + rsCombo$2 + "?", rsCombo$2, rsRegional$1, rsSurrPair$1, rsAstral].join("|") + ")", reUnicode = RegExp(rsFitz$1 + "(?=" + rsFitz$1 + ")|" + rsSymbol + rsSeq$1, "g");
function unicodeToArray(a) {
  return a.match(reUnicode) || [];
}
function stringToArray(a) {
  return hasUnicode(a) ? unicodeToArray(a) : asciiToArray(a);
}
function createCaseFirst(a) {
  return function(u) {
    u = toString$3(u);
    var c = hasUnicode(u) ? stringToArray(u) : void 0, l = c ? c[0] : u.charAt(0), v = c ? castSlice(c, 1).join("") : u.slice(1);
    return l[a]() + v;
  };
}
var upperFirst = createCaseFirst("toUpperCase");
function capitalize(a) {
  return upperFirst(toString$3(a).toLowerCase());
}
function arrayReduce(a, u, c, l) {
  var v = -1, p = a == null ? 0 : a.length;
  for (l && p && (c = a[++v]); ++v < p; )
    c = u(c, a[v], v, a);
  return c;
}
function basePropertyOf(a) {
  return function(u) {
    return a == null ? void 0 : a[u];
  };
}
var deburredLetters = {
  // Latin-1 Supplement block.
  À: "A",
  Á: "A",
  Â: "A",
  Ã: "A",
  Ä: "A",
  Å: "A",
  à: "a",
  á: "a",
  â: "a",
  ã: "a",
  ä: "a",
  å: "a",
  Ç: "C",
  ç: "c",
  Ð: "D",
  ð: "d",
  È: "E",
  É: "E",
  Ê: "E",
  Ë: "E",
  è: "e",
  é: "e",
  ê: "e",
  ë: "e",
  Ì: "I",
  Í: "I",
  Î: "I",
  Ï: "I",
  ì: "i",
  í: "i",
  î: "i",
  ï: "i",
  Ñ: "N",
  ñ: "n",
  Ò: "O",
  Ó: "O",
  Ô: "O",
  Õ: "O",
  Ö: "O",
  Ø: "O",
  ò: "o",
  ó: "o",
  ô: "o",
  õ: "o",
  ö: "o",
  ø: "o",
  Ù: "U",
  Ú: "U",
  Û: "U",
  Ü: "U",
  ù: "u",
  ú: "u",
  û: "u",
  ü: "u",
  Ý: "Y",
  ý: "y",
  ÿ: "y",
  Æ: "Ae",
  æ: "ae",
  Þ: "Th",
  þ: "th",
  ß: "ss",
  // Latin Extended-A block.
  Ā: "A",
  Ă: "A",
  Ą: "A",
  ā: "a",
  ă: "a",
  ą: "a",
  Ć: "C",
  Ĉ: "C",
  Ċ: "C",
  Č: "C",
  ć: "c",
  ĉ: "c",
  ċ: "c",
  č: "c",
  Ď: "D",
  Đ: "D",
  ď: "d",
  đ: "d",
  Ē: "E",
  Ĕ: "E",
  Ė: "E",
  Ę: "E",
  Ě: "E",
  ē: "e",
  ĕ: "e",
  ė: "e",
  ę: "e",
  ě: "e",
  Ĝ: "G",
  Ğ: "G",
  Ġ: "G",
  Ģ: "G",
  ĝ: "g",
  ğ: "g",
  ġ: "g",
  ģ: "g",
  Ĥ: "H",
  Ħ: "H",
  ĥ: "h",
  ħ: "h",
  Ĩ: "I",
  Ī: "I",
  Ĭ: "I",
  Į: "I",
  İ: "I",
  ĩ: "i",
  ī: "i",
  ĭ: "i",
  į: "i",
  ı: "i",
  Ĵ: "J",
  ĵ: "j",
  Ķ: "K",
  ķ: "k",
  ĸ: "k",
  Ĺ: "L",
  Ļ: "L",
  Ľ: "L",
  Ŀ: "L",
  Ł: "L",
  ĺ: "l",
  ļ: "l",
  ľ: "l",
  ŀ: "l",
  ł: "l",
  Ń: "N",
  Ņ: "N",
  Ň: "N",
  Ŋ: "N",
  ń: "n",
  ņ: "n",
  ň: "n",
  ŋ: "n",
  Ō: "O",
  Ŏ: "O",
  Ő: "O",
  ō: "o",
  ŏ: "o",
  ő: "o",
  Ŕ: "R",
  Ŗ: "R",
  Ř: "R",
  ŕ: "r",
  ŗ: "r",
  ř: "r",
  Ś: "S",
  Ŝ: "S",
  Ş: "S",
  Š: "S",
  ś: "s",
  ŝ: "s",
  ş: "s",
  š: "s",
  Ţ: "T",
  Ť: "T",
  Ŧ: "T",
  ţ: "t",
  ť: "t",
  ŧ: "t",
  Ũ: "U",
  Ū: "U",
  Ŭ: "U",
  Ů: "U",
  Ű: "U",
  Ų: "U",
  ũ: "u",
  ū: "u",
  ŭ: "u",
  ů: "u",
  ű: "u",
  ų: "u",
  Ŵ: "W",
  ŵ: "w",
  Ŷ: "Y",
  ŷ: "y",
  Ÿ: "Y",
  Ź: "Z",
  Ż: "Z",
  Ž: "Z",
  ź: "z",
  ż: "z",
  ž: "z",
  Ĳ: "IJ",
  ĳ: "ij",
  Œ: "Oe",
  œ: "oe",
  ŉ: "'n",
  ſ: "s"
}, deburrLetter = basePropertyOf(deburredLetters);
const deburrLetter$1 = deburrLetter;
var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, rsComboMarksRange$1 = "\\u0300-\\u036f", reComboHalfMarksRange$1 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$1 = "\\u20d0-\\u20ff", rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1, rsCombo$1 = "[" + rsComboRange$1 + "]", reComboMark = RegExp(rsCombo$1, "g");
function deburr(a) {
  return a = toString$3(a), a && a.replace(reLatin, deburrLetter$1).replace(reComboMark, "");
}
var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
function asciiWords(a) {
  return a.match(reAsciiWord) || [];
}
var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
function hasUnicodeWord(a) {
  return reHasUnicodeWord.test(a);
}
var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange, rsApos$1 = "['’]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d", rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos$1 + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos$1 + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, reUnicodeWord = RegExp([
  rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
  rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
  rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
  rsUpper + "+" + rsOptContrUpper,
  rsOrdUpper,
  rsOrdLower,
  rsDigits,
  rsEmoji
].join("|"), "g");
function unicodeWords(a) {
  return a.match(reUnicodeWord) || [];
}
function words(a, u, c) {
  return a = toString$3(a), u = c ? void 0 : u, u === void 0 ? hasUnicodeWord(a) ? unicodeWords(a) : asciiWords(a) : a.match(u) || [];
}
var rsApos = "['’]", reApos = RegExp(rsApos, "g");
function createCompounder(a) {
  return function(u) {
    return arrayReduce(words(deburr(u).replace(reApos, "")), a, "");
  };
}
var camelCase$2 = createCompounder(function(a, u, c) {
  return u = u.toLowerCase(), a + (c ? capitalize(u) : u);
});
const camelCase$3 = camelCase$2;
function stackClear() {
  this.__data__ = new ListCache(), this.size = 0;
}
function stackDelete(a) {
  var u = this.__data__, c = u.delete(a);
  return this.size = u.size, c;
}
function stackGet(a) {
  return this.__data__.get(a);
}
function stackHas(a) {
  return this.__data__.has(a);
}
var LARGE_ARRAY_SIZE = 200;
function stackSet(a, u) {
  var c = this.__data__;
  if (c instanceof ListCache) {
    var l = c.__data__;
    if (!Map$1 || l.length < LARGE_ARRAY_SIZE - 1)
      return l.push([a, u]), this.size = ++c.size, this;
    c = this.__data__ = new MapCache(l);
  }
  return c.set(a, u), this.size = c.size, this;
}
function Stack(a) {
  var u = this.__data__ = new ListCache(a);
  this.size = u.size;
}
Stack.prototype.clear = stackClear;
Stack.prototype.delete = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
function baseAssign(a, u) {
  return a && copyObject(u, keys$2(u), a);
}
function baseAssignIn(a, u) {
  return a && copyObject(u, keysIn(u), a);
}
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports, freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module, moduleExports = freeModule && freeModule.exports === freeExports, Buffer$M = moduleExports ? root.Buffer : void 0, allocUnsafe = Buffer$M ? Buffer$M.allocUnsafe : void 0;
function cloneBuffer(a, u) {
  if (u)
    return a.slice();
  var c = a.length, l = allocUnsafe ? allocUnsafe(c) : new a.constructor(c);
  return a.copy(l), l;
}
function arrayFilter(a, u) {
  for (var c = -1, l = a == null ? 0 : a.length, v = 0, p = []; ++c < l; ) {
    var _ = a[c];
    u(_, c, a) && (p[v++] = _);
  }
  return p;
}
function stubArray() {
  return [];
}
var objectProto$a = Object.prototype, propertyIsEnumerable$1 = objectProto$a.propertyIsEnumerable, nativeGetSymbols$1 = Object.getOwnPropertySymbols, getSymbols = nativeGetSymbols$1 ? function(a) {
  return a == null ? [] : (a = Object(a), arrayFilter(nativeGetSymbols$1(a), function(u) {
    return propertyIsEnumerable$1.call(a, u);
  }));
} : stubArray;
function copySymbols(a, u) {
  return copyObject(a, getSymbols(a), u);
}
var nativeGetSymbols = Object.getOwnPropertySymbols, getSymbolsIn = nativeGetSymbols ? function(a) {
  for (var u = []; a; )
    arrayPush(u, getSymbols(a)), a = getPrototype$2(a);
  return u;
} : stubArray;
function copySymbolsIn(a, u) {
  return copyObject(a, getSymbolsIn(a), u);
}
function baseGetAllKeys(a, u, c) {
  var l = u(a);
  return isArray$4(a) ? l : arrayPush(l, c(a));
}
function getAllKeys(a) {
  return baseGetAllKeys(a, keys$2, getSymbols);
}
function getAllKeysIn(a) {
  return baseGetAllKeys(a, keysIn, getSymbolsIn);
}
var DataView$1 = getNative(root, "DataView"), Promise$1 = getNative(root, "Promise"), Set$1 = getNative(root, "Set"), mapTag$4 = "[object Map]", objectTag$3 = "[object Object]", promiseTag = "[object Promise]", setTag$4 = "[object Set]", weakMapTag$1 = "[object WeakMap]", dataViewTag$3 = "[object DataView]", dataViewCtorString = toSource(DataView$1), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap$2), getTag = baseGetTag;
(DataView$1 && getTag(new DataView$1(new ArrayBuffer(1))) != dataViewTag$3 || Map$1 && getTag(new Map$1()) != mapTag$4 || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set$1 && getTag(new Set$1()) != setTag$4 || WeakMap$2 && getTag(new WeakMap$2()) != weakMapTag$1) && (getTag = function(a) {
  var u = baseGetTag(a), c = u == objectTag$3 ? a.constructor : void 0, l = c ? toSource(c) : "";
  if (l)
    switch (l) {
      case dataViewCtorString:
        return dataViewTag$3;
      case mapCtorString:
        return mapTag$4;
      case promiseCtorString:
        return promiseTag;
      case setCtorString:
        return setTag$4;
      case weakMapCtorString:
        return weakMapTag$1;
    }
  return u;
});
const getTag$1 = getTag;
var objectProto$9 = Object.prototype, hasOwnProperty$5 = objectProto$9.hasOwnProperty;
function initCloneArray(a) {
  var u = a.length, c = new a.constructor(u);
  return u && typeof a[0] == "string" && hasOwnProperty$5.call(a, "index") && (c.index = a.index, c.input = a.input), c;
}
var Uint8Array$1 = root.Uint8Array;
function cloneArrayBuffer(a) {
  var u = new a.constructor(a.byteLength);
  return new Uint8Array$1(u).set(new Uint8Array$1(a)), u;
}
function cloneDataView(a, u) {
  var c = u ? cloneArrayBuffer(a.buffer) : a.buffer;
  return new a.constructor(c, a.byteOffset, a.byteLength);
}
var reFlags = /\w*$/;
function cloneRegExp(a) {
  var u = new a.constructor(a.source, reFlags.exec(a));
  return u.lastIndex = a.lastIndex, u;
}
var symbolProto$1 = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : void 0;
function cloneSymbol(a) {
  return symbolValueOf$1 ? Object(symbolValueOf$1.call(a)) : {};
}
function cloneTypedArray(a, u) {
  var c = u ? cloneArrayBuffer(a.buffer) : a.buffer;
  return new a.constructor(c, a.byteOffset, a.length);
}
var boolTag$3 = "[object Boolean]", dateTag$2 = "[object Date]", mapTag$3 = "[object Map]", numberTag$3 = "[object Number]", regexpTag$2 = "[object RegExp]", setTag$3 = "[object Set]", stringTag$4 = "[object String]", symbolTag$5 = "[object Symbol]", arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
function initCloneByTag(a, u, c) {
  var l = a.constructor;
  switch (u) {
    case arrayBufferTag$2:
      return cloneArrayBuffer(a);
    case boolTag$3:
    case dateTag$2:
      return new l(+a);
    case dataViewTag$2:
      return cloneDataView(a, c);
    case float32Tag$1:
    case float64Tag$1:
    case int8Tag$1:
    case int16Tag$1:
    case int32Tag$1:
    case uint8Tag$1:
    case uint8ClampedTag$1:
    case uint16Tag$1:
    case uint32Tag$1:
      return cloneTypedArray(a, c);
    case mapTag$3:
      return new l();
    case numberTag$3:
    case stringTag$4:
      return new l(a);
    case regexpTag$2:
      return cloneRegExp(a);
    case setTag$3:
      return new l();
    case symbolTag$5:
      return cloneSymbol(a);
  }
}
function initCloneObject(a) {
  return typeof a.constructor == "function" && !isPrototype$1(a) ? baseCreate(getPrototype$2(a)) : {};
}
var mapTag$2 = "[object Map]";
function baseIsMap(a) {
  return isObjectLike$7(a) && getTag$1(a) == mapTag$2;
}
var nodeIsMap = nodeUtil && nodeUtil.isMap, isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap, setTag$2 = "[object Set]";
function baseIsSet(a) {
  return isObjectLike$7(a) && getTag$1(a) == setTag$2;
}
var nodeIsSet = nodeUtil && nodeUtil.isSet, isSet$2 = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet, CLONE_DEEP_FLAG$3 = 1, CLONE_FLAT_FLAG$1 = 2, CLONE_SYMBOLS_FLAG$2 = 4, argsTag$2 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$2 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", funcTag$1 = "[object Function]", genTag$1 = "[object GeneratorFunction]", mapTag$1 = "[object Map]", numberTag$2 = "[object Number]", objectTag$2 = "[object Object]", regexpTag$1 = "[object RegExp]", setTag$1 = "[object Set]", stringTag$3 = "[object String]", symbolTag$4 = "[object Symbol]", weakMapTag = "[object WeakMap]", arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]", cloneableTags = {};
cloneableTags[argsTag$2] = cloneableTags[arrayTag$1] = cloneableTags[arrayBufferTag$1] = cloneableTags[dataViewTag$1] = cloneableTags[boolTag$2] = cloneableTags[dateTag$1] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag$1] = cloneableTags[numberTag$2] = cloneableTags[objectTag$2] = cloneableTags[regexpTag$1] = cloneableTags[setTag$1] = cloneableTags[stringTag$3] = cloneableTags[symbolTag$4] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = !0;
cloneableTags[errorTag$1] = cloneableTags[funcTag$1] = cloneableTags[weakMapTag] = !1;
function baseClone(a, u, c, l, v, p) {
  var _, k = u & CLONE_DEEP_FLAG$3, O = u & CLONE_FLAT_FLAG$1, D = u & CLONE_SYMBOLS_FLAG$2;
  if (c && (_ = v ? c(a, l, v, p) : c(a)), _ !== void 0)
    return _;
  if (!isObject$8(a))
    return a;
  var F = isArray$4(a);
  if (F) {
    if (_ = initCloneArray(a), !k)
      return copyArray(a, _);
  } else {
    var H = getTag$1(a), Z = H == funcTag$1 || H == genTag$1;
    if (isBuffer$1(a))
      return cloneBuffer(a, k);
    if (H == objectTag$2 || H == argsTag$2 || Z && !v) {
      if (_ = O || Z ? {} : initCloneObject(a), !k)
        return O ? copySymbolsIn(a, baseAssignIn(_, a)) : copySymbols(a, baseAssign(_, a));
    } else {
      if (!cloneableTags[H])
        return v ? a : {};
      _ = initCloneByTag(a, H, k);
    }
  }
  p || (p = new Stack());
  var ee = p.get(a);
  if (ee)
    return ee;
  p.set(a, _), isSet$2(a) ? a.forEach(function(Q) {
    _.add(baseClone(Q, u, c, Q, a, p));
  }) : isMap(a) && a.forEach(function(Q, ae) {
    _.set(ae, baseClone(Q, u, c, ae, a, p));
  });
  var X = D ? O ? getAllKeysIn : getAllKeys : O ? keysIn : keys$2, ne = F ? void 0 : X(a);
  return arrayEach(ne || a, function(Q, ae) {
    ne && (ae = Q, Q = a[ae]), assignValue(_, ae, baseClone(Q, u, c, ae, a, p));
  }), _;
}
var CLONE_DEEP_FLAG$2 = 1, CLONE_SYMBOLS_FLAG$1 = 4;
function cloneDeep$1(a) {
  return baseClone(a, CLONE_DEEP_FLAG$2 | CLONE_SYMBOLS_FLAG$1);
}
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function setCacheAdd(a) {
  return this.__data__.set(a, HASH_UNDEFINED), this;
}
function setCacheHas(a) {
  return this.__data__.has(a);
}
function SetCache(a) {
  var u = -1, c = a == null ? 0 : a.length;
  for (this.__data__ = new MapCache(); ++u < c; )
    this.add(a[u]);
}
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;
function arraySome(a, u) {
  for (var c = -1, l = a == null ? 0 : a.length; ++c < l; )
    if (u(a[c], c, a))
      return !0;
  return !1;
}
function cacheHas(a, u) {
  return a.has(u);
}
var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
function equalArrays(a, u, c, l, v, p) {
  var _ = c & COMPARE_PARTIAL_FLAG$5, k = a.length, O = u.length;
  if (k != O && !(_ && O > k))
    return !1;
  var D = p.get(a), F = p.get(u);
  if (D && F)
    return D == u && F == a;
  var H = -1, Z = !0, ee = c & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : void 0;
  for (p.set(a, u), p.set(u, a); ++H < k; ) {
    var X = a[H], ne = u[H];
    if (l)
      var Q = _ ? l(ne, X, H, u, a, p) : l(X, ne, H, a, u, p);
    if (Q !== void 0) {
      if (Q)
        continue;
      Z = !1;
      break;
    }
    if (ee) {
      if (!arraySome(u, function(ae, j) {
        if (!cacheHas(ee, j) && (X === ae || v(X, ae, c, l, p)))
          return ee.push(j);
      })) {
        Z = !1;
        break;
      }
    } else if (!(X === ne || v(X, ne, c, l, p))) {
      Z = !1;
      break;
    }
  }
  return p.delete(a), p.delete(u), Z;
}
function mapToArray(a) {
  var u = -1, c = Array(a.size);
  return a.forEach(function(l, v) {
    c[++u] = [v, l];
  }), c;
}
function setToArray(a) {
  var u = -1, c = Array(a.size);
  return a.forEach(function(l) {
    c[++u] = l;
  }), c;
}
var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2, boolTag$1 = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag = "[object Map]", numberTag$1 = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag$2 = "[object String]", symbolTag$3 = "[object Symbol]", arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
function equalByTag(a, u, c, l, v, p, _) {
  switch (c) {
    case dataViewTag:
      if (a.byteLength != u.byteLength || a.byteOffset != u.byteOffset)
        return !1;
      a = a.buffer, u = u.buffer;
    case arrayBufferTag:
      return !(a.byteLength != u.byteLength || !p(new Uint8Array$1(a), new Uint8Array$1(u)));
    case boolTag$1:
    case dateTag:
    case numberTag$1:
      return eq(+a, +u);
    case errorTag:
      return a.name == u.name && a.message == u.message;
    case regexpTag:
    case stringTag$2:
      return a == u + "";
    case mapTag:
      var k = mapToArray;
    case setTag:
      var O = l & COMPARE_PARTIAL_FLAG$4;
      if (k || (k = setToArray), a.size != u.size && !O)
        return !1;
      var D = _.get(a);
      if (D)
        return D == u;
      l |= COMPARE_UNORDERED_FLAG$2, _.set(a, u);
      var F = equalArrays(k(a), k(u), l, v, p, _);
      return _.delete(a), F;
    case symbolTag$3:
      if (symbolValueOf)
        return symbolValueOf.call(a) == symbolValueOf.call(u);
  }
  return !1;
}
var COMPARE_PARTIAL_FLAG$3 = 1, objectProto$8 = Object.prototype, hasOwnProperty$4 = objectProto$8.hasOwnProperty;
function equalObjects(a, u, c, l, v, p) {
  var _ = c & COMPARE_PARTIAL_FLAG$3, k = getAllKeys(a), O = k.length, D = getAllKeys(u), F = D.length;
  if (O != F && !_)
    return !1;
  for (var H = O; H--; ) {
    var Z = k[H];
    if (!(_ ? Z in u : hasOwnProperty$4.call(u, Z)))
      return !1;
  }
  var ee = p.get(a), X = p.get(u);
  if (ee && X)
    return ee == u && X == a;
  var ne = !0;
  p.set(a, u), p.set(u, a);
  for (var Q = _; ++H < O; ) {
    Z = k[H];
    var ae = a[Z], j = u[Z];
    if (l)
      var ue = _ ? l(j, ae, Z, u, a, p) : l(ae, j, Z, a, u, p);
    if (!(ue === void 0 ? ae === j || v(ae, j, c, l, p) : ue)) {
      ne = !1;
      break;
    }
    Q || (Q = Z == "constructor");
  }
  if (ne && !Q) {
    var he = a.constructor, fe = u.constructor;
    he != fe && "constructor" in a && "constructor" in u && !(typeof he == "function" && he instanceof he && typeof fe == "function" && fe instanceof fe) && (ne = !1);
  }
  return p.delete(a), p.delete(u), ne;
}
var COMPARE_PARTIAL_FLAG$2 = 1, argsTag$1 = "[object Arguments]", arrayTag = "[object Array]", objectTag$1 = "[object Object]", objectProto$7 = Object.prototype, hasOwnProperty$3 = objectProto$7.hasOwnProperty;
function baseIsEqualDeep(a, u, c, l, v, p) {
  var _ = isArray$4(a), k = isArray$4(u), O = _ ? arrayTag : getTag$1(a), D = k ? arrayTag : getTag$1(u);
  O = O == argsTag$1 ? objectTag$1 : O, D = D == argsTag$1 ? objectTag$1 : D;
  var F = O == objectTag$1, H = D == objectTag$1, Z = O == D;
  if (Z && isBuffer$1(a)) {
    if (!isBuffer$1(u))
      return !1;
    _ = !0, F = !1;
  }
  if (Z && !F)
    return p || (p = new Stack()), _ || isTypedArray$1(a) ? equalArrays(a, u, c, l, v, p) : equalByTag(a, u, O, c, l, v, p);
  if (!(c & COMPARE_PARTIAL_FLAG$2)) {
    var ee = F && hasOwnProperty$3.call(a, "__wrapped__"), X = H && hasOwnProperty$3.call(u, "__wrapped__");
    if (ee || X) {
      var ne = ee ? a.value() : a, Q = X ? u.value() : u;
      return p || (p = new Stack()), v(ne, Q, c, l, p);
    }
  }
  return Z ? (p || (p = new Stack()), equalObjects(a, u, c, l, v, p)) : !1;
}
function baseIsEqual(a, u, c, l, v) {
  return a === u ? !0 : a == null || u == null || !isObjectLike$7(a) && !isObjectLike$7(u) ? a !== a && u !== u : baseIsEqualDeep(a, u, c, l, baseIsEqual, v);
}
var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
function baseIsMatch(a, u, c, l) {
  var v = c.length, p = v, _ = !l;
  if (a == null)
    return !p;
  for (a = Object(a); v--; ) {
    var k = c[v];
    if (_ && k[2] ? k[1] !== a[k[0]] : !(k[0] in a))
      return !1;
  }
  for (; ++v < p; ) {
    k = c[v];
    var O = k[0], D = a[O], F = k[1];
    if (_ && k[2]) {
      if (D === void 0 && !(O in a))
        return !1;
    } else {
      var H = new Stack();
      if (l)
        var Z = l(D, F, O, a, u, H);
      if (!(Z === void 0 ? baseIsEqual(F, D, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, l, H) : Z))
        return !1;
    }
  }
  return !0;
}
function isStrictComparable(a) {
  return a === a && !isObject$8(a);
}
function getMatchData(a) {
  for (var u = keys$2(a), c = u.length; c--; ) {
    var l = u[c], v = a[l];
    u[c] = [l, v, isStrictComparable(v)];
  }
  return u;
}
function matchesStrictComparable(a, u) {
  return function(c) {
    return c == null ? !1 : c[a] === u && (u !== void 0 || a in Object(c));
  };
}
function baseMatches(a) {
  var u = getMatchData(a);
  return u.length == 1 && u[0][2] ? matchesStrictComparable(u[0][0], u[0][1]) : function(c) {
    return c === a || baseIsMatch(c, a, u);
  };
}
function baseHasIn(a, u) {
  return a != null && u in Object(a);
}
function hasPath(a, u, c) {
  u = castPath(u, a);
  for (var l = -1, v = u.length, p = !1; ++l < v; ) {
    var _ = toKey(u[l]);
    if (!(p = a != null && c(a, _)))
      break;
    a = a[_];
  }
  return p || ++l != v ? p : (v = a == null ? 0 : a.length, !!v && isLength$1(v) && isIndex$1(_, v) && (isArray$4(a) || isArguments$2(a)));
}
function hasIn(a, u) {
  return a != null && hasPath(a, u, baseHasIn);
}
var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
function baseMatchesProperty(a, u) {
  return isKey(a) && isStrictComparable(u) ? matchesStrictComparable(toKey(a), u) : function(c) {
    var l = get(c, a);
    return l === void 0 && l === u ? hasIn(c, a) : baseIsEqual(u, l, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}
function baseProperty(a) {
  return function(u) {
    return u == null ? void 0 : u[a];
  };
}
function basePropertyDeep(a) {
  return function(u) {
    return baseGet(u, a);
  };
}
function property(a) {
  return isKey(a) ? baseProperty(toKey(a)) : basePropertyDeep(a);
}
function baseIteratee(a) {
  return typeof a == "function" ? a : a == null ? identity : typeof a == "object" ? isArray$4(a) ? baseMatchesProperty(a[0], a[1]) : baseMatches(a) : property(a);
}
function createBaseFor(a) {
  return function(u, c, l) {
    for (var v = -1, p = Object(u), _ = l(u), k = _.length; k--; ) {
      var O = _[a ? k : ++v];
      if (c(p[O], O, p) === !1)
        break;
    }
    return u;
  };
}
var baseFor = createBaseFor();
const baseFor$1 = baseFor;
function baseForOwn(a, u) {
  return a && baseFor$1(a, u, keys$2);
}
function createBaseEach(a, u) {
  return function(c, l) {
    if (c == null)
      return c;
    if (!isArrayLike$1(c))
      return a(c, l);
    for (var v = c.length, p = u ? v : -1, _ = Object(c); (u ? p-- : ++p < v) && l(_[p], p, _) !== !1; )
      ;
    return c;
  };
}
var baseEach = createBaseEach(baseForOwn), now = function() {
  return root.Date.now();
}, FUNC_ERROR_TEXT$1 = "Expected a function", nativeMax$1 = Math.max, nativeMin = Math.min;
function debounce(a, u, c) {
  var l, v, p, _, k, O, D = 0, F = !1, H = !1, Z = !0;
  if (typeof a != "function")
    throw new TypeError(FUNC_ERROR_TEXT$1);
  u = toNumber$3(u) || 0, isObject$8(c) && (F = !!c.leading, H = "maxWait" in c, p = H ? nativeMax$1(toNumber$3(c.maxWait) || 0, u) : p, Z = "trailing" in c ? !!c.trailing : Z);
  function ee(be) {
    var ke = l, Te = v;
    return l = v = void 0, D = be, _ = a.apply(Te, ke), _;
  }
  function X(be) {
    return D = be, k = setTimeout(ae, u), F ? ee(be) : _;
  }
  function ne(be) {
    var ke = be - O, Te = be - D, q = u - ke;
    return H ? nativeMin(q, p - Te) : q;
  }
  function Q(be) {
    var ke = be - O, Te = be - D;
    return O === void 0 || ke >= u || ke < 0 || H && Te >= p;
  }
  function ae() {
    var be = now();
    if (Q(be))
      return j(be);
    k = setTimeout(ae, ne(be));
  }
  function j(be) {
    return k = void 0, Z && l ? ee(be) : (l = v = void 0, _);
  }
  function ue() {
    k !== void 0 && clearTimeout(k), D = 0, l = O = v = k = void 0;
  }
  function he() {
    return k === void 0 ? _ : j(now());
  }
  function fe() {
    var be = now(), ke = Q(be);
    if (l = arguments, v = this, O = be, ke) {
      if (k === void 0)
        return X(O);
      if (H)
        return clearTimeout(k), k = setTimeout(ae, u), ee(O);
    }
    return k === void 0 && (k = setTimeout(ae, u)), _;
  }
  return fe.cancel = ue, fe.flush = he, fe;
}
function last(a) {
  var u = a == null ? 0 : a.length;
  return u ? a[u - 1] : void 0;
}
function arrayEvery(a, u) {
  for (var c = -1, l = a == null ? 0 : a.length; ++c < l; )
    if (!u(a[c], c, a))
      return !1;
  return !0;
}
function baseEvery(a, u) {
  var c = !0;
  return baseEach(a, function(l, v, p) {
    return c = !!u(l, v, p), c;
  }), c;
}
function every(a, u, c) {
  var l = isArray$4(a) ? arrayEvery : baseEvery;
  return c && isIterateeCall(a, u, c) && (u = void 0), l(a, baseIteratee(u));
}
function baseMap(a, u) {
  var c = -1, l = isArrayLike$1(a) ? Array(a.length) : [];
  return baseEach(a, function(v, p, _) {
    l[++c] = u(v, p, _);
  }), l;
}
function parent(a, u) {
  return u.length < 2 ? a : baseGet(a, baseSlice(u, 0, -1));
}
function isEqual(a, u) {
  return baseIsEqual(a, u);
}
function isMatch(a, u) {
  return a === u || baseIsMatch(a, u, getMatchData(u));
}
var CLONE_DEEP_FLAG$1 = 1;
function iteratee(a) {
  return baseIteratee(typeof a == "function" ? a : baseClone(a, CLONE_DEEP_FLAG$1));
}
var kebabCase = createCompounder(function(a, u, c) {
  return a + (c ? "-" : "") + u.toLowerCase();
});
const kebabCase$1 = kebabCase;
function baseUnset(a, u) {
  return u = castPath(u, a), a = parent(a, u), a == null || delete a[toKey(last(u))];
}
function customOmitClone(a) {
  return isPlainObject$3(a) ? void 0 : a;
}
var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4, omit = flatRest(function(a, u) {
  var c = {};
  if (a == null)
    return c;
  var l = !1;
  u = arrayMap$1(u, function(p) {
    return p = castPath(p, a), l || (l = p.length > 1), p;
  }), copyObject(a, getAllKeysIn(a), c), l && (c = baseClone(c, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone));
  for (var v = u.length; v--; )
    baseUnset(c, u[v]);
  return c;
});
function baseSet(a, u, c, l) {
  if (!isObject$8(a))
    return a;
  u = castPath(u, a);
  for (var v = -1, p = u.length, _ = p - 1, k = a; k != null && ++v < p; ) {
    var O = toKey(u[v]), D = c;
    if (O === "__proto__" || O === "constructor" || O === "prototype")
      return a;
    if (v != _) {
      var F = k[O];
      D = l ? l(F, O, k) : void 0, D === void 0 && (D = isObject$8(F) ? F : isIndex$1(u[v + 1]) ? [] : {});
    }
    assignValue(k, O, D), k = k[O];
  }
  return a;
}
function basePickBy(a, u, c) {
  for (var l = -1, v = u.length, p = {}; ++l < v; ) {
    var _ = u[l], k = baseGet(a, _);
    c(k, _) && baseSet(p, castPath(_, a), k);
  }
  return p;
}
function baseSortBy(a, u) {
  var c = a.length;
  for (a.sort(u); c--; )
    a[c] = a[c].value;
  return a;
}
function compareAscending(a, u) {
  if (a !== u) {
    var c = a !== void 0, l = a === null, v = a === a, p = isSymbol$3(a), _ = u !== void 0, k = u === null, O = u === u, D = isSymbol$3(u);
    if (!k && !D && !p && a > u || p && _ && O && !k && !D || l && _ && O || !c && O || !v)
      return 1;
    if (!l && !p && !D && a < u || D && c && v && !l && !p || k && c && v || !_ && v || !O)
      return -1;
  }
  return 0;
}
function compareMultiple(a, u, c) {
  for (var l = -1, v = a.criteria, p = u.criteria, _ = v.length, k = c.length; ++l < _; ) {
    var O = compareAscending(v[l], p[l]);
    if (O) {
      if (l >= k)
        return O;
      var D = c[l];
      return O * (D == "desc" ? -1 : 1);
    }
  }
  return a.index - u.index;
}
function baseOrderBy(a, u, c) {
  u.length ? u = arrayMap$1(u, function(p) {
    return isArray$4(p) ? function(_) {
      return baseGet(_, p.length === 1 ? p[0] : p);
    } : p;
  }) : u = [identity];
  var l = -1;
  u = arrayMap$1(u, baseUnary(baseIteratee));
  var v = baseMap(a, function(p, _, k) {
    var O = arrayMap$1(u, function(D) {
      return D(p);
    });
    return { criteria: O, index: ++l, value: p };
  });
  return baseSortBy(v, function(p, _) {
    return compareMultiple(p, _, c);
  });
}
function basePick(a, u) {
  return basePickBy(a, u, function(c, l) {
    return hasIn(a, l);
  });
}
var pick = flatRest(function(a, u) {
  return a == null ? {} : basePick(a, u);
});
const pick$1 = pick;
function baseIndexOfWith(a, u, c, l) {
  for (var v = c - 1, p = a.length; ++v < p; )
    if (l(a[v], u))
      return v;
  return -1;
}
var arrayProto = Array.prototype, splice = arrayProto.splice;
function basePullAll(a, u, c, l) {
  var v = l ? baseIndexOfWith : baseIndexOf$1, p = -1, _ = u.length, k = a;
  for (a === u && (u = copyArray(u)), c && (k = arrayMap$1(a, baseUnary(c))); ++p < _; )
    for (var O = 0, D = u[p], F = c ? c(D) : D; (O = v(k, F, O, l)) > -1; )
      k !== a && splice.call(k, O, 1), splice.call(a, O, 1);
  return a;
}
function pullAll(a, u) {
  return a && a.length && u && u.length ? basePullAll(a, u) : a;
}
var pull$1 = baseRest(pullAll), sortBy = baseRest(function(a, u) {
  if (a == null)
    return [];
  var c = u.length;
  return c > 1 && isIterateeCall(a, u[0], u[1]) ? u = [] : c > 2 && isIterateeCall(u[0], u[1], u[2]) && (u = [u[0]]), baseOrderBy(a, baseFlatten(u, 1), []);
});
const sortBy$1 = sortBy, convert = (
  // Note: overloads in JSDoc can’t yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(a) {
    if (a == null)
      return ok;
    if (typeof a == "function")
      return castFactory(a);
    if (typeof a == "object")
      return Array.isArray(a) ? anyFactory(a) : propsFactory(a);
    if (typeof a == "string")
      return typeFactory(a);
    throw new Error("Expected function, string, or object as test");
  }
);
function anyFactory(a) {
  const u = [];
  let c = -1;
  for (; ++c < a.length; )
    u[c] = convert(a[c]);
  return castFactory(l);
  function l(...v) {
    let p = -1;
    for (; ++p < u.length; )
      if (u[p].apply(this, v))
        return !0;
    return !1;
  }
}
function propsFactory(a) {
  const u = (
    /** @type {Record<string, unknown>} */
    a
  );
  return castFactory(c);
  function c(l) {
    const v = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      l
    );
    let p;
    for (p in a)
      if (v[p] !== u[p])
        return !1;
    return !0;
  }
}
function typeFactory(a) {
  return castFactory(u);
  function u(c) {
    return c && c.type === a;
  }
}
function castFactory(a) {
  return u;
  function u(c, l, v) {
    return !!(looksLikeANode(c) && a.call(
      this,
      c,
      typeof l == "number" ? l : void 0,
      v || void 0
    ));
  }
}
function ok() {
  return !0;
}
function looksLikeANode(a) {
  return a !== null && typeof a == "object" && "type" in a;
}
function color$1(a) {
  return a;
}
const empty$1 = [], CONTINUE = !0, EXIT = !1, SKIP = "skip";
function visitParents(a, u, c, l) {
  let v;
  typeof u == "function" && typeof c != "function" ? (l = c, c = u) : v = u;
  const p = convert(v), _ = l ? -1 : 1;
  k(a, void 0, [])();
  function k(O, D, F) {
    const H = (
      /** @type {Record<string, unknown>} */
      O && typeof O == "object" ? O : {}
    );
    if (typeof H.type == "string") {
      const ee = (
        // `hast`
        typeof H.tagName == "string" ? H.tagName : (
          // `xast`
          typeof H.name == "string" ? H.name : void 0
        )
      );
      Object.defineProperty(Z, "name", {
        value: "node (" + (O.type + (ee ? "<" + ee + ">" : "")) + ")"
      });
    }
    return Z;
    function Z() {
      let ee = empty$1, X, ne, Q;
      if ((!u || p(O, D, F[F.length - 1] || void 0)) && (ee = toResult(c(O, F)), ee[0] === EXIT))
        return ee;
      if ("children" in O && O.children) {
        const ae = (
          /** @type {UnistParent} */
          O
        );
        if (ae.children && ee[0] !== SKIP)
          for (ne = (l ? ae.children.length : -1) + _, Q = F.concat(ae); ne > -1 && ne < ae.children.length; ) {
            const j = ae.children[ne];
            if (X = k(j, ne, Q)(), X[0] === EXIT)
              return X;
            ne = typeof X[1] == "number" ? X[1] : ne + _;
          }
      }
      return ee;
    }
  }
}
function toResult(a) {
  return Array.isArray(a) ? a : typeof a == "number" ? [CONTINUE, a] : a == null ? empty$1 : [a];
}
function visit(a, u, c, l) {
  let v, p, _;
  typeof u == "function" && typeof c != "function" ? (p = void 0, _ = u, v = c) : (p = u, _ = c, v = l), visitParents(a, p, k, v);
  function k(O, D) {
    const F = D[D.length - 1], H = F ? F.children.indexOf(O) : void 0;
    return _(O, H, F);
  }
}
const generateId = () => (Math.random() * 1e20).toString(36), insertAt$1 = (a = 0, u, c, l = !1) => [...c.slice(0, a), ...[u].flat(), ...c.slice(l ? a + 1 : a)], replaceItem$1 = (a, u, c) => {
  a = typeof a == "function" ? a : (v) => v === a;
  const l = c.findIndex(a);
  return l < 0 ? c : insertAt$1(l, u, c, !0);
}, swapIndex = (a, u, c) => {
  if (!c[a] || !c[u])
    return c;
  c = [...c];
  const l = c[a];
  return c[a] = c[u], c[u] = l, c;
}, swapItems = (a, u, c) => {
  const l = c.findIndex((p) => p === a), v = c.findIndex((p) => p === u);
  return l < 0 || v < 0 ? c : swapIndex(l, v, c);
}, toDataNode$1 = (a) => a ? {
  id: a.id,
  props: a.props,
  childIds: (a.children || []).map((u) => u.id)
} : null, toSceneNode = (a) => ({
  id: a.id,
  props: a.props,
  children: []
}), toSceneTree = (a, u) => {
  const c = a.find((v) => v.id === u);
  if (!c)
    return null;
  const l = c.childIds;
  return {
    id: c.id,
    props: c.props,
    children: l.map((v) => toSceneTree(a, v)).filter(Boolean)
  };
}, forEachDown$1 = (a, u) => {
  u(a), (a.children || []).forEach((l) => forEachDown$1(l, (v, p) => {
    u(v, p || a);
  }));
}, mapDown = (a, u) => {
  const c = u(a);
  return {
    ...c,
    children: ((c == null ? void 0 : c.children) || (a == null ? void 0 : a.children) || []).map((l) => mapDown(l, u))
  };
}, mapDownAsync = async (a, u) => {
  const c = (a == null ? void 0 : a.children) ?? [];
  return {
    ...await u(a),
    children: await Promise.all(c.map((l) => mapDownAsync(l, u)))
  };
}, getElementAttributes = (a) => Object.values(a.attributes).reduce((u, c) => ({
  ...u,
  [c.name]: c.value
}), {}), asArray = (a) => isArray$4(a) ? a : [a], sizeToNum = (a, u) => typeof a == "number" ? a : typeof a == "string" ? a.indexOf("%") > -1 ? parseFloat(a) / 100 * u : parseFloat(a) : 0, asSize = (a) => typeof a == "number" ? a + "px" : typeof a == "string" ? a.indexOf("%") > -1 ? parseFloat(a) + "%" : a : "0px", asDuration = (a) => typeof a == "string" ? a : typeof a == "number" ? a + "ms" : "0ms", find$1 = (a, u) => {
  if (!a)
    throw new Error("requires a tree to search");
  if (!u)
    throw new Error("requires a condition");
  const c = iteratee(u);
  let l;
  return visit(a, function(v) {
    if (c(v))
      return l = v, !1;
  }), l;
}, findAll = (a, u) => {
  if (!a)
    throw new Error("requires a tree to search");
  if (!u)
    throw new Error("requires a condition");
  const c = iteratee(u);
  let l = [];
  return visit(a, function(v) {
    c(v) && l.push(v);
  }), l;
}, lookupDevice = (a, u) => {
  const c = a.find((v) => v.label === u && v.kind === "videoinput"), l = a.find((v) => v.label === `Monitor of ${u}` && v.kind === "audioinput");
  if (c && l)
    return {
      videoDevice: c,
      audioDevice: l
    };
  if (c) {
    if (c.label === "Logitech BRIO (046d:085e)") {
      const v = a.find((p) => (
        /*(device.groupId === videoDevice.groupId) &&*/
        p.kind === "audioinput" && p.label === "Loopback Audio 2 (Virtual)"
      ));
      return {
        videoDevice: c,
        audioDevice: v
      };
    }
    if (c.label === "OBS Virtual Camera (m-de:vice)") {
      const v = a.find((p) => (
        /*(device.groupId === videoDevice.groupId) &&*/
        p.kind === "audioinput" && p.label === "Loopback Audio (Virtual)"
      ));
      return {
        videoDevice: c,
        audioDevice: v
      };
    }
    return {
      videoDevice: c,
      audioDevice: null
    };
  }
  return null;
}, connectDevice = async (a) => {
  const u = await navigator.mediaDevices.enumerateDevices(), c = lookupDevice(u, a);
  if (c) {
    const l = {
      video: {
        width: 999999,
        height: 999999,
        deviceId: {
          exact: c.videoDevice.deviceId
        }
      }
    };
    c.audioDevice && (l.audio = {
      autoGainControl: !1,
      channelCount: 2,
      echoCancellation: !1,
      // @ts-ignore: https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints/latency
      latency: 0,
      noiseSuppression: !1,
      sampleRate: 128e3,
      sampleSize: 16,
      deviceId: {
        exact: c.audioDevice.deviceId
      }
    });
    const v = await navigator.mediaDevices.getUserMedia(l);
    if (v)
      return v;
    console.warn(`No stream found for source ${a}.`);
  } else
    console.warn(`No device found for source ${a}.`);
}, values$1 = (a) => Array.from(a.values()), Logic = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  asArray,
  asDuration,
  asSize,
  camelCase: camelCase$3,
  cloneDeep: cloneDeep$1,
  connectDevice,
  debounce,
  deepEqual,
  every,
  find: find$1,
  findAll,
  forEachDown: forEachDown$1,
  generateId,
  getElementAttributes,
  insertAt: insertAt$1,
  isArray: isArray$4,
  isEqual,
  kebabCase: kebabCase$1,
  lookupDevice,
  mapDown,
  mapDownAsync,
  omit,
  pick: pick$1,
  pull: pull$1,
  replaceItem: replaceItem$1,
  sizeToNum,
  sortBy: sortBy$1,
  swapIndex,
  swapItems,
  toDataNode: toDataNode$1,
  toSceneNode,
  toSceneTree,
  values: values$1
}, Symbol.toStringTag, { value: "Module" }));
function getDefaultExportFromCjs$1(a) {
  return a && a.__esModule && Object.prototype.hasOwnProperty.call(a, "default") ? a.default : a;
}
var browser$d = { exports: {} }, process = browser$d.exports = {}, cachedSetTimeout, cachedClearTimeout;
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? cachedSetTimeout = setTimeout : cachedSetTimeout = defaultSetTimout;
  } catch {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    typeof clearTimeout == "function" ? cachedClearTimeout = clearTimeout : cachedClearTimeout = defaultClearTimeout;
  } catch {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(a) {
  if (cachedSetTimeout === setTimeout)
    return setTimeout(a, 0);
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout)
    return cachedSetTimeout = setTimeout, setTimeout(a, 0);
  try {
    return cachedSetTimeout(a, 0);
  } catch {
    try {
      return cachedSetTimeout.call(null, a, 0);
    } catch {
      return cachedSetTimeout.call(this, a, 0);
    }
  }
}
function runClearTimeout(a) {
  if (cachedClearTimeout === clearTimeout)
    return clearTimeout(a);
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout)
    return cachedClearTimeout = clearTimeout, clearTimeout(a);
  try {
    return cachedClearTimeout(a);
  } catch {
    try {
      return cachedClearTimeout.call(null, a);
    } catch {
      return cachedClearTimeout.call(this, a);
    }
  }
}
var queue = [], draining = !1, currentQueue, queueIndex = -1;
function cleanUpNextTick() {
  !draining || !currentQueue || (draining = !1, currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1, queue.length && drainQueue());
}
function drainQueue() {
  if (!draining) {
    var a = runTimeout(cleanUpNextTick);
    draining = !0;
    for (var u = queue.length; u; ) {
      for (currentQueue = queue, queue = []; ++queueIndex < u; )
        currentQueue && currentQueue[queueIndex].run();
      queueIndex = -1, u = queue.length;
    }
    currentQueue = null, draining = !1, runClearTimeout(a);
  }
}
process.nextTick = function(a) {
  var u = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var c = 1; c < arguments.length; c++)
      u[c - 1] = arguments[c];
  queue.push(new Item(a, u)), queue.length === 1 && !draining && runTimeout(drainQueue);
};
function Item(a, u) {
  this.fun = a, this.array = u;
}
Item.prototype.run = function() {
  this.fun.apply(null, this.array);
};
process.title = "browser";
process.browser = !0;
process.env = {};
process.argv = [];
process.version = "";
process.versions = {};
function noop$5() {
}
process.on = noop$5;
process.addListener = noop$5;
process.once = noop$5;
process.off = noop$5;
process.removeListener = noop$5;
process.removeAllListeners = noop$5;
process.emit = noop$5;
process.prependListener = noop$5;
process.prependOnceListener = noop$5;
process.listeners = function(a) {
  return [];
};
process.binding = function(a) {
  throw new Error("process.binding is not supported");
};
process.cwd = function() {
  return "/";
};
process.chdir = function(a) {
  throw new Error("process.chdir is not supported");
};
process.umask = function() {
  return 0;
};
var browserExports$1 = browser$d.exports;
const process$1 = /* @__PURE__ */ getDefaultExportFromCjs$1(browserExports$1);
function _mergeNamespaces(a, u) {
  return u.forEach(function(c) {
    c && typeof c != "string" && !Array.isArray(c) && Object.keys(c).forEach(function(l) {
      if (l !== "default" && !(l in a)) {
        var v = Object.getOwnPropertyDescriptor(c, l);
        Object.defineProperty(a, l, v.get ? v : {
          enumerable: !0,
          get: function() {
            return c[l];
          }
        });
      }
    });
  }), Object.freeze(a);
}
function assert$k(a, u) {
  if (!a)
    throw new Error(u);
}
const FLOAT32_MAX = 34028234663852886e22, FLOAT32_MIN = -34028234663852886e22, UINT32_MAX = 4294967295, INT32_MAX = 2147483647, INT32_MIN = -2147483648;
function assertInt32(a) {
  if (typeof a != "number")
    throw new Error("invalid int 32: " + typeof a);
  if (!Number.isInteger(a) || a > INT32_MAX || a < INT32_MIN)
    throw new Error("invalid int 32: " + a);
}
function assertUInt32(a) {
  if (typeof a != "number")
    throw new Error("invalid uint 32: " + typeof a);
  if (!Number.isInteger(a) || a > UINT32_MAX || a < 0)
    throw new Error("invalid uint 32: " + a);
}
function assertFloat32(a) {
  if (typeof a != "number")
    throw new Error("invalid float 32: " + typeof a);
  if (Number.isFinite(a) && (a > FLOAT32_MAX || a < FLOAT32_MIN))
    throw new Error("invalid float 32: " + a);
}
const enumTypeSymbol = Symbol("@bufbuild/protobuf/enum-type");
function getEnumType(a) {
  const u = a[enumTypeSymbol];
  return assert$k(u, "missing enum type on enum object"), u;
}
function setEnumType(a, u, c, l) {
  a[enumTypeSymbol] = makeEnumType(u, c.map((v) => ({
    no: v.no,
    name: v.name,
    localName: a[v.no]
  })));
}
function makeEnumType(a, u, c) {
  const l = /* @__PURE__ */ Object.create(null), v = /* @__PURE__ */ Object.create(null), p = [];
  for (const _ of u) {
    const k = normalizeEnumValue(_);
    p.push(k), l[_.name] = k, v[_.no] = k;
  }
  return {
    typeName: a,
    values: p,
    // We do not surface options at this time
    // options: opt?.options ?? Object.create(null),
    findName(_) {
      return l[_];
    },
    findNumber(_) {
      return v[_];
    }
  };
}
function makeEnum(a, u, c) {
  const l = {};
  for (const v of u) {
    const p = normalizeEnumValue(v);
    l[p.localName] = p.no, l[p.no] = p.localName;
  }
  return setEnumType(l, a, u), l;
}
function normalizeEnumValue(a) {
  return "localName" in a ? a : Object.assign(Object.assign({}, a), {
    localName: a.name
  });
}
class Message {
  /**
   * Compare with a message of the same type.
   */
  equals(u) {
    return this.getType().runtime.util.equals(this.getType(), this, u);
  }
  /**
   * Create a deep copy.
   */
  clone() {
    return this.getType().runtime.util.clone(this);
  }
  /**
   * Parse from binary data, merging fields.
   *
   * Repeated fields are appended. Map entries are added, overwriting
   * existing keys.
   *
   * If a message field is already present, it will be merged with the
   * new data.
   */
  fromBinary(u, c) {
    const l = this.getType(), v = l.runtime.bin, p = v.makeReadOptions(c);
    return v.readMessage(this, p.readerFactory(u), u.byteLength, p), this;
  }
  /**
   * Parse a message from a JSON value.
   */
  fromJson(u, c) {
    const l = this.getType(), v = l.runtime.json, p = v.makeReadOptions(c);
    return v.readMessage(l, u, p, this), this;
  }
  /**
   * Parse a message from a JSON string.
   */
  fromJsonString(u, c) {
    let l;
    try {
      l = JSON.parse(u);
    } catch (v) {
      throw new Error("cannot decode ".concat(this.getType().typeName, " from JSON: ").concat(v instanceof Error ? v.message : String(v)));
    }
    return this.fromJson(l, c);
  }
  /**
   * Serialize the message to binary data.
   */
  toBinary(u) {
    const c = this.getType(), l = c.runtime.bin, v = l.makeWriteOptions(u), p = v.writerFactory();
    return l.writeMessage(this, p, v), p.finish();
  }
  /**
   * Serialize the message to a JSON value, a JavaScript value that can be
   * passed to JSON.stringify().
   */
  toJson(u) {
    const c = this.getType(), l = c.runtime.json, v = l.makeWriteOptions(u);
    return l.writeMessage(this, v);
  }
  /**
   * Serialize the message to a JSON string.
   */
  toJsonString(u) {
    var c;
    const l = this.toJson(u);
    return JSON.stringify(l, null, (c = u == null ? void 0 : u.prettySpaces) !== null && c !== void 0 ? c : 0);
  }
  /**
   * Override for serialization behavior. This will be invoked when calling
   * JSON.stringify on this message (i.e. JSON.stringify(msg)).
   *
   * Note that this will not serialize google.protobuf.Any with a packed
   * message because the protobuf JSON format specifies that it needs to be
   * unpacked, and this is only possible with a type registry to look up the
   * message type.  As a result, attempting to serialize a message with this
   * type will throw an Error.
   *
   * This method is protected because you should not need to invoke it
   * directly -- instead use JSON.stringify or toJsonString for
   * stringified JSON.  Alternatively, if actual JSON is desired, you should
   * use toJson.
   */
  toJSON() {
    return this.toJson({
      emitDefaultValues: !0
    });
  }
  /**
   * Retrieve the MessageType of this message - a singleton that represents
   * the protobuf message declaration and provides metadata for reflection-
   * based operations.
   */
  getType() {
    return Object.getPrototypeOf(this).constructor;
  }
}
function makeMessageType(a, u, c, l) {
  var v;
  const p = (v = l == null ? void 0 : l.localName) !== null && v !== void 0 ? v : u.substring(u.lastIndexOf(".") + 1), _ = {
    [p]: function(k) {
      a.util.initFields(this), a.util.initPartial(k, this);
    }
  }[p];
  return Object.setPrototypeOf(_.prototype, new Message()), Object.assign(_, {
    runtime: a,
    typeName: u,
    fields: a.util.newFieldList(c),
    fromBinary(k, O) {
      return new _().fromBinary(k, O);
    },
    fromJson(k, O) {
      return new _().fromJson(k, O);
    },
    fromJsonString(k, O) {
      return new _().fromJsonString(k, O);
    },
    equals(k, O) {
      return a.util.equals(_, k, O);
    }
  }), _;
}
var ScalarType;
(function(a) {
  a[a.DOUBLE = 1] = "DOUBLE", a[a.FLOAT = 2] = "FLOAT", a[a.INT64 = 3] = "INT64", a[a.UINT64 = 4] = "UINT64", a[a.INT32 = 5] = "INT32", a[a.FIXED64 = 6] = "FIXED64", a[a.FIXED32 = 7] = "FIXED32", a[a.BOOL = 8] = "BOOL", a[a.STRING = 9] = "STRING", a[a.BYTES = 12] = "BYTES", a[a.UINT32 = 13] = "UINT32", a[a.SFIXED32 = 15] = "SFIXED32", a[a.SFIXED64 = 16] = "SFIXED64", a[a.SINT32 = 17] = "SINT32", a[a.SINT64 = 18] = "SINT64";
})(ScalarType || (ScalarType = {}));
var LongType;
(function(a) {
  a[a.BIGINT = 0] = "BIGINT", a[a.STRING = 1] = "STRING";
})(LongType || (LongType = {}));
function varint64read() {
  let a = 0, u = 0;
  for (let l = 0; l < 28; l += 7) {
    let v = this.buf[this.pos++];
    if (a |= (v & 127) << l, !(v & 128))
      return this.assertBounds(), [a, u];
  }
  let c = this.buf[this.pos++];
  if (a |= (c & 15) << 28, u = (c & 112) >> 4, !(c & 128))
    return this.assertBounds(), [a, u];
  for (let l = 3; l <= 31; l += 7) {
    let v = this.buf[this.pos++];
    if (u |= (v & 127) << l, !(v & 128))
      return this.assertBounds(), [a, u];
  }
  throw new Error("invalid varint");
}
function varint64write(a, u, c) {
  for (let p = 0; p < 28; p = p + 7) {
    const _ = a >>> p, k = !(!(_ >>> 7) && u == 0), O = (k ? _ | 128 : _) & 255;
    if (c.push(O), !k)
      return;
  }
  const l = a >>> 28 & 15 | (u & 7) << 4, v = !!(u >> 3);
  if (c.push((v ? l | 128 : l) & 255), !!v) {
    for (let p = 3; p < 31; p = p + 7) {
      const _ = u >>> p, k = !!(_ >>> 7), O = (k ? _ | 128 : _) & 255;
      if (c.push(O), !k)
        return;
    }
    c.push(u >>> 31 & 1);
  }
}
const TWO_PWR_32_DBL = 4294967296;
function int64FromString(a) {
  const u = a[0] === "-";
  u && (a = a.slice(1));
  const c = 1e6;
  let l = 0, v = 0;
  function p(_, k) {
    const O = Number(a.slice(_, k));
    v *= c, l = l * c + O, l >= TWO_PWR_32_DBL && (v = v + (l / TWO_PWR_32_DBL | 0), l = l % TWO_PWR_32_DBL);
  }
  return p(-24, -18), p(-18, -12), p(-12, -6), p(-6), u ? negate(l, v) : newBits(l, v);
}
function int64ToString(a, u) {
  let c = newBits(a, u);
  const l = c.hi & 2147483648;
  l && (c = negate(c.lo, c.hi));
  const v = uInt64ToString(c.lo, c.hi);
  return l ? "-" + v : v;
}
function uInt64ToString(a, u) {
  if ({
    lo: a,
    hi: u
  } = toUnsigned(a, u), u <= 2097151)
    return String(TWO_PWR_32_DBL * u + a);
  const c = a & 16777215, l = (a >>> 24 | u << 8) & 16777215, v = u >> 16 & 65535;
  let p = c + l * 6777216 + v * 6710656, _ = l + v * 8147497, k = v * 2;
  const O = 1e7;
  return p >= O && (_ += Math.floor(p / O), p %= O), _ >= O && (k += Math.floor(_ / O), _ %= O), k.toString() + decimalFrom1e7WithLeadingZeros(_) + decimalFrom1e7WithLeadingZeros(p);
}
function toUnsigned(a, u) {
  return {
    lo: a >>> 0,
    hi: u >>> 0
  };
}
function newBits(a, u) {
  return {
    lo: a | 0,
    hi: u | 0
  };
}
function negate(a, u) {
  return u = ~u, a ? a = ~a + 1 : u += 1, newBits(a, u);
}
const decimalFrom1e7WithLeadingZeros = (a) => {
  const u = String(a);
  return "0000000".slice(u.length) + u;
};
function varint32write(a, u) {
  if (a >= 0) {
    for (; a > 127; )
      u.push(a & 127 | 128), a = a >>> 7;
    u.push(a);
  } else {
    for (let c = 0; c < 9; c++)
      u.push(a & 127 | 128), a = a >> 7;
    u.push(1);
  }
}
function varint32read() {
  let a = this.buf[this.pos++], u = a & 127;
  if (!(a & 128))
    return this.assertBounds(), u;
  if (a = this.buf[this.pos++], u |= (a & 127) << 7, !(a & 128))
    return this.assertBounds(), u;
  if (a = this.buf[this.pos++], u |= (a & 127) << 14, !(a & 128))
    return this.assertBounds(), u;
  if (a = this.buf[this.pos++], u |= (a & 127) << 21, !(a & 128))
    return this.assertBounds(), u;
  a = this.buf[this.pos++], u |= (a & 15) << 28;
  for (let c = 5; a & 128 && c < 10; c++)
    a = this.buf[this.pos++];
  if (a & 128)
    throw new Error("invalid varint");
  return this.assertBounds(), u >>> 0;
}
function makeInt64Support() {
  const a = new DataView(new ArrayBuffer(8));
  if (typeof BigInt == "function" && typeof a.getBigInt64 == "function" && typeof a.getBigUint64 == "function" && typeof a.setBigInt64 == "function" && typeof a.setBigUint64 == "function" && (typeof process$1 != "object" || typeof process$1.env != "object" || process$1.env.BUF_BIGINT_DISABLE !== "1")) {
    const v = BigInt("-9223372036854775808"), p = BigInt("9223372036854775807"), _ = BigInt("0"), k = BigInt("18446744073709551615");
    return {
      zero: BigInt(0),
      supported: !0,
      parse(O) {
        const D = typeof O == "bigint" ? O : BigInt(O);
        if (D > p || D < v)
          throw new Error("int64 invalid: ".concat(O));
        return D;
      },
      uParse(O) {
        const D = typeof O == "bigint" ? O : BigInt(O);
        if (D > k || D < _)
          throw new Error("uint64 invalid: ".concat(O));
        return D;
      },
      enc(O) {
        return a.setBigInt64(0, this.parse(O), !0), {
          lo: a.getInt32(0, !0),
          hi: a.getInt32(4, !0)
        };
      },
      uEnc(O) {
        return a.setBigInt64(0, this.uParse(O), !0), {
          lo: a.getInt32(0, !0),
          hi: a.getInt32(4, !0)
        };
      },
      dec(O, D) {
        return a.setInt32(0, O, !0), a.setInt32(4, D, !0), a.getBigInt64(0, !0);
      },
      uDec(O, D) {
        return a.setInt32(0, O, !0), a.setInt32(4, D, !0), a.getBigUint64(0, !0);
      }
    };
  }
  const c = (v) => assert$k(/^-?[0-9]+$/.test(v), "int64 invalid: ".concat(v)), l = (v) => assert$k(/^[0-9]+$/.test(v), "uint64 invalid: ".concat(v));
  return {
    zero: "0",
    supported: !1,
    parse(v) {
      return typeof v != "string" && (v = v.toString()), c(v), v;
    },
    uParse(v) {
      return typeof v != "string" && (v = v.toString()), l(v), v;
    },
    enc(v) {
      return typeof v != "string" && (v = v.toString()), c(v), int64FromString(v);
    },
    uEnc(v) {
      return typeof v != "string" && (v = v.toString()), l(v), int64FromString(v);
    },
    dec(v, p) {
      return int64ToString(v, p);
    },
    uDec(v, p) {
      return uInt64ToString(v, p);
    }
  };
}
const protoInt64 = makeInt64Support();
var WireType;
(function(a) {
  a[a.Varint = 0] = "Varint", a[a.Bit64 = 1] = "Bit64", a[a.LengthDelimited = 2] = "LengthDelimited", a[a.StartGroup = 3] = "StartGroup", a[a.EndGroup = 4] = "EndGroup", a[a.Bit32 = 5] = "Bit32";
})(WireType || (WireType = {}));
class BinaryWriter {
  constructor(u) {
    this.stack = [], this.textEncoder = u ?? new TextEncoder(), this.chunks = [], this.buf = [];
  }
  /**
   * Return all bytes written and reset this writer.
   */
  finish() {
    this.chunks.push(new Uint8Array(this.buf));
    let u = 0;
    for (let v = 0; v < this.chunks.length; v++)
      u += this.chunks[v].length;
    let c = new Uint8Array(u), l = 0;
    for (let v = 0; v < this.chunks.length; v++)
      c.set(this.chunks[v], l), l += this.chunks[v].length;
    return this.chunks = [], c;
  }
  /**
   * Start a new fork for length-delimited data like a message
   * or a packed repeated field.
   *
   * Must be joined later with `join()`.
   */
  fork() {
    return this.stack.push({
      chunks: this.chunks,
      buf: this.buf
    }), this.chunks = [], this.buf = [], this;
  }
  /**
   * Join the last fork. Write its length and bytes, then
   * return to the previous state.
   */
  join() {
    let u = this.finish(), c = this.stack.pop();
    if (!c)
      throw new Error("invalid state, fork stack empty");
    return this.chunks = c.chunks, this.buf = c.buf, this.uint32(u.byteLength), this.raw(u);
  }
  /**
   * Writes a tag (field number and wire type).
   *
   * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.
   *
   * Generated code should compute the tag ahead of time and call `uint32()`.
   */
  tag(u, c) {
    return this.uint32((u << 3 | c) >>> 0);
  }
  /**
   * Write a chunk of raw bytes.
   */
  raw(u) {
    return this.buf.length && (this.chunks.push(new Uint8Array(this.buf)), this.buf = []), this.chunks.push(u), this;
  }
  /**
   * Write a `uint32` value, an unsigned 32 bit varint.
   */
  uint32(u) {
    for (assertUInt32(u); u > 127; )
      this.buf.push(u & 127 | 128), u = u >>> 7;
    return this.buf.push(u), this;
  }
  /**
   * Write a `int32` value, a signed 32 bit varint.
   */
  int32(u) {
    return assertInt32(u), varint32write(u, this.buf), this;
  }
  /**
   * Write a `bool` value, a variant.
   */
  bool(u) {
    return this.buf.push(u ? 1 : 0), this;
  }
  /**
   * Write a `bytes` value, length-delimited arbitrary data.
   */
  bytes(u) {
    return this.uint32(u.byteLength), this.raw(u);
  }
  /**
   * Write a `string` value, length-delimited data converted to UTF-8 text.
   */
  string(u) {
    let c = this.textEncoder.encode(u);
    return this.uint32(c.byteLength), this.raw(c);
  }
  /**
   * Write a `float` value, 32-bit floating point number.
   */
  float(u) {
    assertFloat32(u);
    let c = new Uint8Array(4);
    return new DataView(c.buffer).setFloat32(0, u, !0), this.raw(c);
  }
  /**
   * Write a `double` value, a 64-bit floating point number.
   */
  double(u) {
    let c = new Uint8Array(8);
    return new DataView(c.buffer).setFloat64(0, u, !0), this.raw(c);
  }
  /**
   * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.
   */
  fixed32(u) {
    assertUInt32(u);
    let c = new Uint8Array(4);
    return new DataView(c.buffer).setUint32(0, u, !0), this.raw(c);
  }
  /**
   * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.
   */
  sfixed32(u) {
    assertInt32(u);
    let c = new Uint8Array(4);
    return new DataView(c.buffer).setInt32(0, u, !0), this.raw(c);
  }
  /**
   * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.
   */
  sint32(u) {
    return assertInt32(u), u = (u << 1 ^ u >> 31) >>> 0, varint32write(u, this.buf), this;
  }
  /**
   * Write a `fixed64` value, a signed, fixed-length 64-bit integer.
   */
  sfixed64(u) {
    let c = new Uint8Array(8), l = new DataView(c.buffer), v = protoInt64.enc(u);
    return l.setInt32(0, v.lo, !0), l.setInt32(4, v.hi, !0), this.raw(c);
  }
  /**
   * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.
   */
  fixed64(u) {
    let c = new Uint8Array(8), l = new DataView(c.buffer), v = protoInt64.uEnc(u);
    return l.setInt32(0, v.lo, !0), l.setInt32(4, v.hi, !0), this.raw(c);
  }
  /**
   * Write a `int64` value, a signed 64-bit varint.
   */
  int64(u) {
    let c = protoInt64.enc(u);
    return varint64write(c.lo, c.hi, this.buf), this;
  }
  /**
   * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64(u) {
    let c = protoInt64.enc(u), l = c.hi >> 31, v = c.lo << 1 ^ l, p = (c.hi << 1 | c.lo >>> 31) ^ l;
    return varint64write(v, p, this.buf), this;
  }
  /**
   * Write a `uint64` value, an unsigned 64-bit varint.
   */
  uint64(u) {
    let c = protoInt64.uEnc(u);
    return varint64write(c.lo, c.hi, this.buf), this;
  }
}
class BinaryReader {
  constructor(u, c) {
    this.varint64 = varint64read, this.uint32 = varint32read, this.buf = u, this.len = u.length, this.pos = 0, this.view = new DataView(u.buffer, u.byteOffset, u.byteLength), this.textDecoder = c ?? new TextDecoder();
  }
  /**
   * Reads a tag - field number and wire type.
   */
  tag() {
    let u = this.uint32(), c = u >>> 3, l = u & 7;
    if (c <= 0 || l < 0 || l > 5)
      throw new Error("illegal tag: field no " + c + " wire type " + l);
    return [c, l];
  }
  /**
   * Skip one element on the wire and return the skipped data.
   * Supports WireType.StartGroup since v2.0.0-alpha.23.
   */
  skip(u) {
    let c = this.pos;
    switch (u) {
      case WireType.Varint:
        for (; this.buf[this.pos++] & 128; )
          ;
        break;
      case WireType.Bit64:
        this.pos += 4;
      case WireType.Bit32:
        this.pos += 4;
        break;
      case WireType.LengthDelimited:
        let l = this.uint32();
        this.pos += l;
        break;
      case WireType.StartGroup:
        let v;
        for (; (v = this.tag()[1]) !== WireType.EndGroup; )
          this.skip(v);
        break;
      default:
        throw new Error("cant skip wire type " + u);
    }
    return this.assertBounds(), this.buf.subarray(c, this.pos);
  }
  /**
   * Throws error if position in byte array is out of range.
   */
  assertBounds() {
    if (this.pos > this.len)
      throw new RangeError("premature EOF");
  }
  /**
   * Read a `int32` field, a signed 32 bit varint.
   */
  int32() {
    return this.uint32() | 0;
  }
  /**
   * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.
   */
  sint32() {
    let u = this.uint32();
    return u >>> 1 ^ -(u & 1);
  }
  /**
   * Read a `int64` field, a signed 64-bit varint.
   */
  int64() {
    return protoInt64.dec(...this.varint64());
  }
  /**
   * Read a `uint64` field, an unsigned 64-bit varint.
   */
  uint64() {
    return protoInt64.uDec(...this.varint64());
  }
  /**
   * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64() {
    let [u, c] = this.varint64(), l = -(u & 1);
    return u = (u >>> 1 | (c & 1) << 31) ^ l, c = c >>> 1 ^ l, protoInt64.dec(u, c);
  }
  /**
   * Read a `bool` field, a variant.
   */
  bool() {
    let [u, c] = this.varint64();
    return u !== 0 || c !== 0;
  }
  /**
   * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.
   */
  fixed32() {
    return this.view.getUint32((this.pos += 4) - 4, !0);
  }
  /**
   * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.
   */
  sfixed32() {
    return this.view.getInt32((this.pos += 4) - 4, !0);
  }
  /**
   * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.
   */
  fixed64() {
    return protoInt64.uDec(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `fixed64` field, a signed, fixed-length 64-bit integer.
   */
  sfixed64() {
    return protoInt64.dec(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `float` field, 32-bit floating point number.
   */
  float() {
    return this.view.getFloat32((this.pos += 4) - 4, !0);
  }
  /**
   * Read a `double` field, a 64-bit floating point number.
   */
  double() {
    return this.view.getFloat64((this.pos += 8) - 8, !0);
  }
  /**
   * Read a `bytes` field, length-delimited arbitrary data.
   */
  bytes() {
    let u = this.uint32(), c = this.pos;
    return this.pos += u, this.assertBounds(), this.buf.subarray(c, c + u);
  }
  /**
   * Read a `string` field, length-delimited data converted to UTF-8 text.
   */
  string() {
    return this.textDecoder.decode(this.bytes());
  }
}
function scalarEquals(a, u, c) {
  if (u === c)
    return !0;
  if (a == ScalarType.BYTES) {
    if (!(u instanceof Uint8Array) || !(c instanceof Uint8Array) || u.length !== c.length)
      return !1;
    for (let l = 0; l < u.length; l++)
      if (u[l] !== c[l])
        return !1;
    return !0;
  }
  switch (a) {
    case ScalarType.UINT64:
    case ScalarType.FIXED64:
    case ScalarType.INT64:
    case ScalarType.SFIXED64:
    case ScalarType.SINT64:
      return u == c;
  }
  return !1;
}
function scalarDefaultValue(a, u) {
  switch (a) {
    case ScalarType.BOOL:
      return !1;
    case ScalarType.UINT64:
    case ScalarType.FIXED64:
    case ScalarType.INT64:
    case ScalarType.SFIXED64:
    case ScalarType.SINT64:
      return u == 0 ? protoInt64.zero : "0";
    case ScalarType.DOUBLE:
    case ScalarType.FLOAT:
      return 0;
    case ScalarType.BYTES:
      return new Uint8Array(0);
    case ScalarType.STRING:
      return "";
    default:
      return 0;
  }
}
function scalarTypeInfo(a, u) {
  const c = u === void 0;
  let l = WireType.Varint, v = u === 0;
  switch (a) {
    case ScalarType.STRING:
      v = c || !u.length, l = WireType.LengthDelimited;
      break;
    case ScalarType.BOOL:
      v = u === !1;
      break;
    case ScalarType.DOUBLE:
      l = WireType.Bit64;
      break;
    case ScalarType.FLOAT:
      l = WireType.Bit32;
      break;
    case ScalarType.INT64:
      v = c || u == 0;
      break;
    case ScalarType.UINT64:
      v = c || u == 0;
      break;
    case ScalarType.FIXED64:
      v = c || u == 0, l = WireType.Bit64;
      break;
    case ScalarType.BYTES:
      v = c || !u.byteLength, l = WireType.LengthDelimited;
      break;
    case ScalarType.FIXED32:
      l = WireType.Bit32;
      break;
    case ScalarType.SFIXED32:
      l = WireType.Bit32;
      break;
    case ScalarType.SFIXED64:
      v = c || u == 0, l = WireType.Bit64;
      break;
    case ScalarType.SINT64:
      v = c || u == 0;
      break;
  }
  const p = ScalarType[a].toLowerCase();
  return [l, p, c || v];
}
function makeExtension(a, u, c, l) {
  let v;
  return {
    typeName: u,
    extendee: c,
    get field() {
      if (!v) {
        const p = typeof l == "function" ? l() : l;
        p.name = u.split(".").pop(), p.jsonName = "[".concat(u, "]"), v = a.util.newFieldList([p]).list()[0];
      }
      return v;
    },
    runtime: a
  };
}
function createExtensionContainer(a) {
  const u = a.field.localName, c = /* @__PURE__ */ Object.create(null);
  return c[u] = initExtensionField(a), [c, () => c[u]];
}
function initExtensionField(a) {
  const u = a.field;
  if (u.repeated)
    return [];
  if (u.default !== void 0)
    return u.default;
  switch (u.kind) {
    case "enum":
      return u.T.values[0].no;
    case "scalar":
      return scalarDefaultValue(u.T, u.L);
    case "message":
      const c = u.T, l = new c();
      return c.fieldWrapper ? c.fieldWrapper.unwrapField(l) : l;
    case "map":
      throw "map fields are not allowed to be extensions";
  }
}
function filterUnknownFields(a, u) {
  if (!u.repeated && (u.kind == "enum" || u.kind == "scalar")) {
    for (let c = a.length - 1; c >= 0; --c)
      if (a[c].no == u.no)
        return [a[c]];
    return [];
  }
  return a.filter((c) => c.no === u.no);
}
function makeProtoRuntime(a, u, c, l) {
  return {
    syntax: a,
    json: u,
    bin: c,
    util: l,
    makeMessageType(v, p, _) {
      return makeMessageType(this, v, p, _);
    },
    makeEnum,
    makeEnumType,
    getEnumType,
    makeExtension(v, p, _) {
      return makeExtension(this, v, p, _);
    }
  };
}
function wrapField(a, u) {
  return u instanceof Message || !a.fieldWrapper ? u : a.fieldWrapper.wrapField(u);
}
ScalarType.DOUBLE, ScalarType.FLOAT, ScalarType.INT64, ScalarType.UINT64, ScalarType.INT32, ScalarType.UINT32, ScalarType.BOOL, ScalarType.STRING, ScalarType.BYTES;
const unknownFieldsSymbol = Symbol("@bufbuild/protobuf/unknown-fields"), readDefaults = {
  readUnknownFields: !0,
  readerFactory: (a) => new BinaryReader(a)
}, writeDefaults = {
  writeUnknownFields: !0,
  writerFactory: () => new BinaryWriter()
};
function makeReadOptions$1(a) {
  return a ? Object.assign(Object.assign({}, readDefaults), a) : readDefaults;
}
function makeWriteOptions$1(a) {
  return a ? Object.assign(Object.assign({}, writeDefaults), a) : writeDefaults;
}
function makeBinaryFormatCommon() {
  return {
    makeReadOptions: makeReadOptions$1,
    makeWriteOptions: makeWriteOptions$1,
    listUnknownFields(a) {
      var u;
      return (u = a[unknownFieldsSymbol]) !== null && u !== void 0 ? u : [];
    },
    discardUnknownFields(a) {
      delete a[unknownFieldsSymbol];
    },
    writeUnknownFields(a, u) {
      const l = a[unknownFieldsSymbol];
      if (l)
        for (const v of l)
          u.tag(v.no, v.wireType).raw(v.data);
    },
    onUnknownField(a, u, c, l) {
      const v = a;
      Array.isArray(v[unknownFieldsSymbol]) || (v[unknownFieldsSymbol] = []), v[unknownFieldsSymbol].push({
        no: u,
        wireType: c,
        data: l
      });
    },
    readMessage(a, u, c, l, v) {
      const p = a.getType(), _ = v ? u.len : u.pos + c;
      let k, O;
      for (; u.pos < _ && ([k, O] = u.tag(), O != WireType.EndGroup); ) {
        const D = p.fields.find(k);
        if (!D) {
          const F = u.skip(O);
          l.readUnknownFields && this.onUnknownField(a, k, O, F);
          continue;
        }
        readField$1(a, u, D, O, l);
      }
      if (v && // eslint-disable-line @typescript-eslint/strict-boolean-expressions
      (O != WireType.EndGroup || k !== c))
        throw new Error("invalid end group tag");
    },
    readField: readField$1
  };
}
function readField$1(a, u, c, l, v) {
  let {
    repeated: p,
    localName: _
  } = c;
  switch (c.oneof && (a = a[c.oneof.localName], a.case != _ && delete a.value, a.case = _, _ = "value"), c.kind) {
    case "scalar":
    case "enum":
      const k = c.kind == "enum" ? ScalarType.INT32 : c.T;
      let O = readScalar$1;
      if (c.kind == "scalar" && c.L > 0 && (O = readScalarLTString), p) {
        let Z = a[_];
        if (l == WireType.LengthDelimited && k != ScalarType.STRING && k != ScalarType.BYTES) {
          let X = u.uint32() + u.pos;
          for (; u.pos < X; )
            Z.push(O(u, k));
        } else
          Z.push(O(u, k));
      } else
        a[_] = O(u, k);
      break;
    case "message":
      const D = c.T;
      p ? a[_].push(readMessageField(u, new D(), v, c)) : a[_] instanceof Message ? readMessageField(u, a[_], v, c) : (a[_] = readMessageField(u, new D(), v, c), D.fieldWrapper && !c.oneof && !c.repeated && (a[_] = D.fieldWrapper.unwrapField(a[_])));
      break;
    case "map":
      let [F, H] = readMapEntry(c, u, v);
      a[_][F] = H;
      break;
  }
}
function readMessageField(a, u, c, l) {
  const v = u.getType().runtime.bin, p = l == null ? void 0 : l.delimited;
  return v.readMessage(
    u,
    a,
    p ? l == null ? void 0 : l.no : a.uint32(),
    // eslint-disable-line @typescript-eslint/strict-boolean-expressions
    c,
    p
  ), u;
}
function readMapEntry(a, u, c) {
  const l = u.uint32(), v = u.pos + l;
  let p, _;
  for (; u.pos < v; ) {
    let [k] = u.tag();
    switch (k) {
      case 1:
        p = readScalar$1(u, a.K);
        break;
      case 2:
        switch (a.V.kind) {
          case "scalar":
            _ = readScalar$1(u, a.V.T);
            break;
          case "enum":
            _ = u.int32();
            break;
          case "message":
            _ = readMessageField(u, new a.V.T(), c, void 0);
            break;
        }
        break;
    }
  }
  if (p === void 0) {
    let k = scalarDefaultValue(a.K, LongType.BIGINT);
    p = a.K == ScalarType.BOOL ? k.toString() : k;
  }
  if (typeof p != "string" && typeof p != "number" && (p = p.toString()), _ === void 0)
    switch (a.V.kind) {
      case "scalar":
        _ = scalarDefaultValue(a.V.T, LongType.BIGINT);
        break;
      case "enum":
        _ = 0;
        break;
      case "message":
        _ = new a.V.T();
        break;
    }
  return [p, _];
}
function readScalarLTString(a, u) {
  const c = readScalar$1(a, u);
  return typeof c == "bigint" ? c.toString() : c;
}
function readScalar$1(a, u) {
  switch (u) {
    case ScalarType.STRING:
      return a.string();
    case ScalarType.BOOL:
      return a.bool();
    case ScalarType.DOUBLE:
      return a.double();
    case ScalarType.FLOAT:
      return a.float();
    case ScalarType.INT32:
      return a.int32();
    case ScalarType.INT64:
      return a.int64();
    case ScalarType.UINT64:
      return a.uint64();
    case ScalarType.FIXED64:
      return a.fixed64();
    case ScalarType.BYTES:
      return a.bytes();
    case ScalarType.FIXED32:
      return a.fixed32();
    case ScalarType.SFIXED32:
      return a.sfixed32();
    case ScalarType.SFIXED64:
      return a.sfixed64();
    case ScalarType.SINT64:
      return a.sint64();
    case ScalarType.UINT32:
      return a.uint32();
    case ScalarType.SINT32:
      return a.sint32();
  }
}
function writeMapEntry(a, u, c, l, v) {
  a.tag(c.no, WireType.LengthDelimited), a.fork();
  let p = l;
  switch (c.K) {
    case ScalarType.INT32:
    case ScalarType.FIXED32:
    case ScalarType.UINT32:
    case ScalarType.SFIXED32:
    case ScalarType.SINT32:
      p = Number.parseInt(l);
      break;
    case ScalarType.BOOL:
      assert$k(l == "true" || l == "false"), p = l == "true";
      break;
  }
  switch (writeScalar$1(a, c.K, 1, p, !0), c.V.kind) {
    case "scalar":
      writeScalar$1(a, c.V.T, 2, v, !0);
      break;
    case "enum":
      writeScalar$1(a, ScalarType.INT32, 2, v, !0);
      break;
    case "message":
      a.tag(2, WireType.LengthDelimited).bytes(v.toBinary(u));
      break;
  }
  a.join();
}
function writeMessageField(a, u, c, l) {
  const v = wrapField(c.T, l);
  c != null && c.delimited ? a.tag(c.no, WireType.StartGroup).raw(v.toBinary(u)).tag(c.no, WireType.EndGroup) : a.tag(c.no, WireType.LengthDelimited).bytes(v.toBinary(u));
}
function writeScalar$1(a, u, c, l, v) {
  let [p, _, k] = scalarTypeInfo(u, l);
  (!k || v) && a.tag(c, p)[_](l);
}
function writePacked(a, u, c, l) {
  if (!l.length)
    return;
  a.tag(c, WireType.LengthDelimited).fork();
  let [, v] = scalarTypeInfo(u);
  for (let p = 0; p < l.length; p++)
    a[v](l[p]);
  a.join();
}
function makeBinaryFormatProto3() {
  return Object.assign(Object.assign({}, makeBinaryFormatCommon()), {
    writeField,
    writeMessage(a, u, c) {
      const l = a.getType();
      for (const v of l.fields.byNumber()) {
        let p, _ = v.localName;
        if (v.oneof) {
          const k = a[v.oneof.localName];
          if (k.case !== _)
            continue;
          p = k.value;
        } else
          p = a[_];
        writeField(v, p, u, c);
      }
      return c.writeUnknownFields && this.writeUnknownFields(a, u), u;
    }
  });
}
function writeField(a, u, c, l) {
  const v = a.repeated;
  switch (a.kind) {
    case "scalar":
    case "enum":
      let p = a.kind == "enum" ? ScalarType.INT32 : a.T;
      if (v)
        if (a.packed)
          writePacked(c, p, a.no, u);
        else
          for (const _ of u)
            writeScalar$1(c, p, a.no, _, !0);
      else
        u !== void 0 && writeScalar$1(c, p, a.no, u, !!a.oneof || a.opt);
      break;
    case "message":
      if (v)
        for (const _ of u)
          writeMessageField(c, l, a, _);
      else
        u !== void 0 && writeMessageField(c, l, a, u);
      break;
    case "map":
      for (const [_, k] of Object.entries(u))
        writeMapEntry(c, l, a, _, k);
      break;
  }
}
let encTable = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split(""), decTable = [];
for (let a = 0; a < encTable.length; a++)
  decTable[encTable[a].charCodeAt(0)] = a;
decTable[45] = encTable.indexOf("+");
decTable[95] = encTable.indexOf("/");
const protoBase64 = {
  /**
   * Decodes a base64 string to a byte array.
   *
   * - ignores white-space, including line breaks and tabs
   * - allows inner padding (can decode concatenated base64 strings)
   * - does not require padding
   * - understands base64url encoding:
   *   "-" instead of "+",
   *   "_" instead of "/",
   *   no padding
   */
  dec(a) {
    let u = a.length * 3 / 4;
    a[a.length - 2] == "=" ? u -= 2 : a[a.length - 1] == "=" && (u -= 1);
    let c = new Uint8Array(u), l = 0, v = 0, p, _ = 0;
    for (let k = 0; k < a.length; k++) {
      if (p = decTable[a.charCodeAt(k)], p === void 0)
        switch (a[k]) {
          case "=":
            v = 0;
          case `
`:
          case "\r":
          case "	":
          case " ":
            continue;
          default:
            throw Error("invalid base64 string.");
        }
      switch (v) {
        case 0:
          _ = p, v = 1;
          break;
        case 1:
          c[l++] = _ << 2 | (p & 48) >> 4, _ = p, v = 2;
          break;
        case 2:
          c[l++] = (_ & 15) << 4 | (p & 60) >> 2, _ = p, v = 3;
          break;
        case 3:
          c[l++] = (_ & 3) << 6 | p, v = 0;
          break;
      }
    }
    if (v == 1)
      throw Error("invalid base64 string.");
    return c.subarray(0, l);
  },
  /**
   * Encode a byte array to a base64 string.
   */
  enc(a) {
    let u = "", c = 0, l, v = 0;
    for (let p = 0; p < a.length; p++)
      switch (l = a[p], c) {
        case 0:
          u += encTable[l >> 2], v = (l & 3) << 4, c = 1;
          break;
        case 1:
          u += encTable[v | l >> 4], v = (l & 15) << 2, c = 2;
          break;
        case 2:
          u += encTable[v | l >> 6], u += encTable[l & 63], c = 0;
          break;
      }
    return c && (u += encTable[v], u += "=", c == 1 && (u += "=")), u;
  }
};
function getExtension(a, u, c) {
  assertExtendee(u, a);
  const l = u.runtime.bin.makeReadOptions(c), v = filterUnknownFields(a.getType().runtime.bin.listUnknownFields(a), u.field), [p, _] = createExtensionContainer(u);
  for (const k of v)
    u.runtime.bin.readField(p, l.readerFactory(k.data), u.field, k.wireType, l);
  return _();
}
function setExtension(a, u, c, l) {
  assertExtendee(u, a);
  const v = u.runtime.bin.makeReadOptions(l), p = u.runtime.bin.makeWriteOptions(l);
  if (hasExtension(a, u)) {
    const D = a.getType().runtime.bin.listUnknownFields(a).filter((F) => F.no != u.field.no);
    a.getType().runtime.bin.discardUnknownFields(a);
    for (const F of D)
      a.getType().runtime.bin.onUnknownField(a, F.no, F.wireType, F.data);
  }
  const _ = p.writerFactory();
  let k = u.field;
  !k.opt && !k.repeated && (k.kind == "enum" || k.kind == "scalar") && (k = Object.assign(Object.assign({}, u.field), {
    opt: !0
  })), u.runtime.bin.writeField(k, c, _, p);
  const O = v.readerFactory(_.finish());
  for (; O.pos < O.len; ) {
    const [D, F] = O.tag(), H = O.skip(F);
    a.getType().runtime.bin.onUnknownField(a, D, F, H);
  }
}
function hasExtension(a, u) {
  const c = a.getType();
  return u.extendee.typeName === c.typeName && !!c.runtime.bin.listUnknownFields(a).find((l) => l.no == u.field.no);
}
function assertExtendee(a, u) {
  assert$k(a.extendee.typeName == u.getType().typeName, "extension ".concat(a.typeName, " can only be applied to message ").concat(a.extendee.typeName));
}
const jsonReadDefaults = {
  ignoreUnknownFields: !1
}, jsonWriteDefaults = {
  emitDefaultValues: !1,
  enumAsInteger: !1,
  useProtoFieldName: !1,
  prettySpaces: 0
};
function makeReadOptions(a) {
  return a ? Object.assign(Object.assign({}, jsonReadDefaults), a) : jsonReadDefaults;
}
function makeWriteOptions(a) {
  return a ? Object.assign(Object.assign({}, jsonWriteDefaults), a) : jsonWriteDefaults;
}
function makeJsonFormatCommon(a, u) {
  const c = u(writeEnum, writeScalar);
  return {
    makeReadOptions,
    makeWriteOptions,
    readMessage(l, v, p, _) {
      if (v == null || Array.isArray(v) || typeof v != "object")
        throw new Error("cannot decode message ".concat(l.typeName, " from JSON: ").concat(debugJsonValue(v)));
      _ = _ ?? new l();
      const k = /* @__PURE__ */ new Map(), O = p.typeRegistry;
      for (const [D, F] of Object.entries(v)) {
        const H = l.fields.findJsonName(D);
        if (H) {
          if (H.oneof) {
            if (F === null && H.kind == "scalar")
              continue;
            const Z = k.get(H.oneof);
            if (Z !== void 0)
              throw new Error("cannot decode message ".concat(l.typeName, ' from JSON: multiple keys for oneof "').concat(H.oneof.name, '" present: "').concat(Z, '", "').concat(D, '"'));
            k.set(H.oneof, D);
          }
          readField(_, F, H, p, l, a);
        } else {
          let Z = !1;
          if (O != null && O.findExtension && D.startsWith("[") && D.endsWith("]")) {
            const ee = O.findExtension(D.substring(1, D.length - 1));
            if (ee && ee.extendee.typeName == l.typeName) {
              Z = !0;
              const [X, ne] = createExtensionContainer(ee);
              readField(X, F, ee.field, p, ee, !0), setExtension(_, ee, ne(), p);
            }
          }
          if (!Z && !p.ignoreUnknownFields)
            throw new Error("cannot decode message ".concat(l.typeName, ' from JSON: key "').concat(D, '" is unknown'));
        }
      }
      return _;
    },
    writeMessage(l, v) {
      const p = l.getType(), _ = {};
      let k;
      try {
        for (const D of p.fields.byMember()) {
          let F;
          if (D.kind == "oneof") {
            const H = l[D.localName];
            if (H.value === void 0)
              continue;
            if (k = D.findField(H.case), !k)
              throw "oneof case not found: " + H.case;
            F = c(k, H.value, v);
          } else
            k = D, F = c(k, l[k.localName], v);
          F !== void 0 && (_[v.useProtoFieldName ? k.name : k.jsonName] = F);
        }
        const O = v.typeRegistry;
        if (O != null && O.findExtensionFor)
          for (const D of p.runtime.bin.listUnknownFields(l)) {
            const F = O.findExtensionFor(p.typeName, D.no);
            if (F && hasExtension(l, F)) {
              const H = getExtension(l, F, v), Z = c(F.field, H, v);
              Z !== void 0 && (_[F.field.jsonName] = Z);
            }
          }
      } catch (O) {
        const D = k ? "cannot encode field ".concat(p.typeName, ".").concat(k.name, " to JSON") : "cannot encode message ".concat(p.typeName, " to JSON"), F = O instanceof Error ? O.message : String(O);
        throw new Error(D + (F.length > 0 ? ": ".concat(F) : ""));
      }
      return _;
    },
    readScalar: (l, v, p) => readScalar(l, v, p, a),
    // eslint-disable-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-return
    writeScalar,
    debug: debugJsonValue
  };
}
function debugJsonValue(a) {
  if (a === null)
    return "null";
  switch (typeof a) {
    case "object":
      return Array.isArray(a) ? "array" : "object";
    case "string":
      return a.length > 100 ? "string" : '"'.concat(a.split('"').join('\\"'), '"');
    default:
      return String(a);
  }
}
function readField(a, u, c, l, v, p) {
  let _ = c.localName;
  if (c.oneof) {
    if (u === null && c.kind == "scalar")
      return;
    a = a[c.oneof.localName] = {
      case: _
    }, _ = "value";
  }
  if (c.repeated) {
    if (u === null)
      return;
    if (!Array.isArray(u))
      throw new Error("cannot decode field ".concat(v.typeName, ".").concat(c.name, " from JSON: ").concat(debugJsonValue(u)));
    const k = a[_];
    for (const O of u) {
      if (O === null)
        throw new Error("cannot decode field ".concat(v.typeName, ".").concat(c.name, " from JSON: ").concat(debugJsonValue(O)));
      let D;
      switch (c.kind) {
        case "message":
          D = c.T.fromJson(O, l);
          break;
        case "enum":
          if (D = readEnum(c.T, O, l.ignoreUnknownFields, !0), D === void 0)
            continue;
          break;
        case "scalar":
          try {
            D = readScalar(c.T, O, c.L, !0);
          } catch (F) {
            let H = "cannot decode field ".concat(v.typeName, ".").concat(c.name, " from JSON: ").concat(debugJsonValue(O));
            throw F instanceof Error && F.message.length > 0 && (H += ": ".concat(F.message)), new Error(H);
          }
          break;
      }
      k.push(D);
    }
  } else if (c.kind == "map") {
    if (u === null)
      return;
    if (typeof u != "object" || Array.isArray(u))
      throw new Error("cannot decode field ".concat(v.typeName, ".").concat(c.name, " from JSON: ").concat(debugJsonValue(u)));
    const k = a[_];
    for (const [O, D] of Object.entries(u)) {
      if (D === null)
        throw new Error("cannot decode field ".concat(v.typeName, ".").concat(c.name, " from JSON: map value null"));
      let F;
      switch (c.V.kind) {
        case "message":
          F = c.V.T.fromJson(D, l);
          break;
        case "enum":
          if (F = readEnum(c.V.T, D, l.ignoreUnknownFields, !0), F === void 0)
            continue;
          break;
        case "scalar":
          try {
            F = readScalar(c.V.T, D, LongType.BIGINT, !0);
          } catch (H) {
            let Z = "cannot decode map value for field ".concat(v.typeName, ".").concat(c.name, " from JSON: ").concat(debugJsonValue(u));
            throw H instanceof Error && H.message.length > 0 && (Z += ": ".concat(H.message)), new Error(Z);
          }
          break;
      }
      try {
        k[readScalar(c.K, c.K == ScalarType.BOOL ? O == "true" ? !0 : O == "false" ? !1 : O : O, LongType.BIGINT, !0).toString()] = F;
      } catch (H) {
        let Z = "cannot decode map key for field ".concat(v.typeName, ".").concat(c.name, " from JSON: ").concat(debugJsonValue(u));
        throw H instanceof Error && H.message.length > 0 && (Z += ": ".concat(H.message)), new Error(Z);
      }
    }
  } else
    switch (c.kind) {
      case "message":
        const k = c.T;
        if (u === null && k.typeName != "google.protobuf.Value") {
          if (c.oneof)
            throw new Error("cannot decode field ".concat(v.typeName, ".").concat(c.name, " from JSON: null is invalid for oneof field"));
          return;
        }
        a[_] instanceof Message ? a[_].fromJson(u, l) : (a[_] = k.fromJson(u, l), k.fieldWrapper && !c.oneof && (a[_] = k.fieldWrapper.unwrapField(a[_])));
        break;
      case "enum":
        const O = readEnum(c.T, u, l.ignoreUnknownFields, p);
        O !== void 0 && (a[_] = O);
        break;
      case "scalar":
        try {
          a[_] = readScalar(c.T, u, c.L, p);
        } catch (D) {
          let F = "cannot decode field ".concat(v.typeName, ".").concat(c.name, " from JSON: ").concat(debugJsonValue(u));
          throw D instanceof Error && D.message.length > 0 && (F += ": ".concat(D.message)), new Error(F);
        }
        break;
    }
}
function readScalar(a, u, c, l) {
  switch (a) {
    case ScalarType.DOUBLE:
    case ScalarType.FLOAT:
      if (u === null)
        return l ? 0 : void 0;
      if (u === "NaN")
        return Number.NaN;
      if (u === "Infinity")
        return Number.POSITIVE_INFINITY;
      if (u === "-Infinity")
        return Number.NEGATIVE_INFINITY;
      if (u === "" || typeof u == "string" && u.trim().length !== u.length || typeof u != "string" && typeof u != "number")
        break;
      const v = Number(u);
      if (Number.isNaN(v) || !Number.isFinite(v))
        break;
      return a == ScalarType.FLOAT && assertFloat32(v), v;
    case ScalarType.INT32:
    case ScalarType.FIXED32:
    case ScalarType.SFIXED32:
    case ScalarType.SINT32:
    case ScalarType.UINT32:
      if (u === null)
        return l ? 0 : void 0;
      let p;
      if (typeof u == "number" ? p = u : typeof u == "string" && u.length > 0 && u.trim().length === u.length && (p = Number(u)), p === void 0)
        break;
      return a == ScalarType.UINT32 ? assertUInt32(p) : assertInt32(p), p;
    case ScalarType.INT64:
    case ScalarType.SFIXED64:
    case ScalarType.SINT64:
      if (u === null)
        return l ? protoInt64.zero : void 0;
      if (typeof u != "number" && typeof u != "string")
        break;
      const _ = protoInt64.parse(u);
      return c ? _.toString() : _;
    case ScalarType.FIXED64:
    case ScalarType.UINT64:
      if (u === null)
        return l ? protoInt64.zero : void 0;
      if (typeof u != "number" && typeof u != "string")
        break;
      const k = protoInt64.uParse(u);
      return c ? k.toString() : k;
    case ScalarType.BOOL:
      if (u === null)
        return l ? !1 : void 0;
      if (typeof u != "boolean")
        break;
      return u;
    case ScalarType.STRING:
      if (u === null)
        return l ? "" : void 0;
      if (typeof u != "string")
        break;
      try {
        encodeURIComponent(u);
      } catch {
        throw new Error("invalid UTF8");
      }
      return u;
    case ScalarType.BYTES:
      if (u === null)
        return l ? new Uint8Array(0) : void 0;
      if (u === "")
        return new Uint8Array(0);
      if (typeof u != "string")
        break;
      return protoBase64.dec(u);
  }
  throw new Error();
}
function readEnum(a, u, c, l) {
  if (u === null)
    return l ? a.values[0].no : void 0;
  switch (typeof u) {
    case "number":
      if (Number.isInteger(u))
        return u;
      break;
    case "string":
      const v = a.findName(u);
      if (v || c)
        return v == null ? void 0 : v.no;
      break;
  }
  throw new Error("cannot decode enum ".concat(a.typeName, " from JSON: ").concat(debugJsonValue(u)));
}
function writeEnum(a, u, c, l) {
  var v;
  if (u === void 0)
    return u;
  if (!c && a.values[0].no === u)
    return;
  if (l)
    return u;
  if (a.typeName == "google.protobuf.NullValue")
    return null;
  const p = a.findNumber(u);
  return (v = p == null ? void 0 : p.name) !== null && v !== void 0 ? v : u;
}
function writeScalar(a, u, c) {
  if (u !== void 0)
    switch (a) {
      case ScalarType.INT32:
      case ScalarType.SFIXED32:
      case ScalarType.SINT32:
      case ScalarType.FIXED32:
      case ScalarType.UINT32:
        return assert$k(typeof u == "number"), u != 0 || c ? u : void 0;
      case ScalarType.FLOAT:
      case ScalarType.DOUBLE:
        return assert$k(typeof u == "number"), Number.isNaN(u) ? "NaN" : u === Number.POSITIVE_INFINITY ? "Infinity" : u === Number.NEGATIVE_INFINITY ? "-Infinity" : u !== 0 || c ? u : void 0;
      case ScalarType.STRING:
        return assert$k(typeof u == "string"), u.length > 0 || c ? u : void 0;
      case ScalarType.BOOL:
        return assert$k(typeof u == "boolean"), u || c ? u : void 0;
      case ScalarType.UINT64:
      case ScalarType.FIXED64:
      case ScalarType.INT64:
      case ScalarType.SFIXED64:
      case ScalarType.SINT64:
        return assert$k(typeof u == "bigint" || typeof u == "string" || typeof u == "number"), c || u != 0 ? u.toString(10) : void 0;
      case ScalarType.BYTES:
        return assert$k(u instanceof Uint8Array), c || u.byteLength > 0 ? protoBase64.enc(u) : void 0;
    }
}
function makeJsonFormatProto3() {
  return makeJsonFormatCommon(!0, (a, u) => function(l, v, p) {
    if (l.kind == "map") {
      const _ = {};
      switch (l.V.kind) {
        case "scalar":
          for (const [O, D] of Object.entries(v)) {
            const F = u(l.V.T, D, !0);
            assert$k(F !== void 0), _[O.toString()] = F;
          }
          break;
        case "message":
          for (const [O, D] of Object.entries(v))
            _[O.toString()] = D.toJson(p);
          break;
        case "enum":
          const k = l.V.T;
          for (const [O, D] of Object.entries(v)) {
            assert$k(D === void 0 || typeof D == "number");
            const F = a(k, D, !0, p.enumAsInteger);
            assert$k(F !== void 0), _[O.toString()] = F;
          }
          break;
      }
      return p.emitDefaultValues || Object.keys(_).length > 0 ? _ : void 0;
    } else if (l.repeated) {
      const _ = [];
      switch (l.kind) {
        case "scalar":
          for (let k = 0; k < v.length; k++)
            _.push(u(l.T, v[k], !0));
          break;
        case "enum":
          for (let k = 0; k < v.length; k++)
            _.push(a(l.T, v[k], !0, p.enumAsInteger));
          break;
        case "message":
          for (let k = 0; k < v.length; k++)
            _.push(v[k].toJson(p));
          break;
      }
      return p.emitDefaultValues || _.length > 0 ? _ : void 0;
    } else {
      if (v === void 0)
        return;
      switch (l.kind) {
        case "scalar":
          return u(l.T, v, !!l.oneof || l.opt || p.emitDefaultValues);
        case "enum":
          return a(l.T, v, !!l.oneof || l.opt || p.emitDefaultValues, p.enumAsInteger);
        case "message":
          return wrapField(l.T, v).toJson(p);
      }
    }
  });
}
function makeUtilCommon() {
  return {
    setEnumType,
    initPartial(a, u) {
      if (a === void 0)
        return;
      const c = u.getType();
      for (const l of c.fields.byMember()) {
        const v = l.localName, p = u, _ = a;
        if (_[v] !== void 0)
          switch (l.kind) {
            case "oneof":
              const k = _[v].case;
              if (k === void 0)
                continue;
              const O = l.findField(k);
              let D = _[v].value;
              O && O.kind == "message" && !(D instanceof O.T) ? D = new O.T(D) : O && O.kind === "scalar" && O.T === ScalarType.BYTES && (D = toU8Arr(D)), p[v] = {
                case: k,
                value: D
              };
              break;
            case "scalar":
            case "enum":
              let F = _[v];
              l.T === ScalarType.BYTES && (F = l.repeated ? F.map(toU8Arr) : toU8Arr(F)), p[v] = F;
              break;
            case "map":
              switch (l.V.kind) {
                case "scalar":
                case "enum":
                  if (l.V.T === ScalarType.BYTES)
                    for (const [ee, X] of Object.entries(_[v]))
                      p[v][ee] = toU8Arr(X);
                  else
                    Object.assign(p[v], _[v]);
                  break;
                case "message":
                  const Z = l.V.T;
                  for (const ee of Object.keys(_[v])) {
                    let X = _[v][ee];
                    Z.fieldWrapper || (X = new Z(X)), p[v][ee] = X;
                  }
                  break;
              }
              break;
            case "message":
              const H = l.T;
              if (l.repeated)
                p[v] = _[v].map((Z) => Z instanceof H ? Z : new H(Z));
              else if (_[v] !== void 0) {
                const Z = _[v];
                H.fieldWrapper ? /* We can't use BytesValue.typeName as that will create a circular import */ H.typeName === "google.protobuf.BytesValue" ? p[v] = toU8Arr(Z) : p[v] = Z : p[v] = Z instanceof H ? Z : new H(Z);
              }
              break;
          }
      }
    },
    equals(a, u, c) {
      return u === c ? !0 : !u || !c ? !1 : a.fields.byMember().every((l) => {
        const v = u[l.localName], p = c[l.localName];
        if (l.repeated) {
          if (v.length !== p.length)
            return !1;
          switch (l.kind) {
            case "message":
              return v.every((_, k) => l.T.equals(_, p[k]));
            case "scalar":
              return v.every((_, k) => scalarEquals(l.T, _, p[k]));
            case "enum":
              return v.every((_, k) => scalarEquals(ScalarType.INT32, _, p[k]));
          }
          throw new Error("repeated cannot contain ".concat(l.kind));
        }
        switch (l.kind) {
          case "message":
            return l.T.equals(v, p);
          case "enum":
            return scalarEquals(ScalarType.INT32, v, p);
          case "scalar":
            return scalarEquals(l.T, v, p);
          case "oneof":
            if (v.case !== p.case)
              return !1;
            const _ = l.findField(v.case);
            if (_ === void 0)
              return !0;
            switch (_.kind) {
              case "message":
                return _.T.equals(v.value, p.value);
              case "enum":
                return scalarEquals(ScalarType.INT32, v.value, p.value);
              case "scalar":
                return scalarEquals(_.T, v.value, p.value);
            }
            throw new Error("oneof cannot contain ".concat(_.kind));
          case "map":
            const k = Object.keys(v).concat(Object.keys(p));
            switch (l.V.kind) {
              case "message":
                const O = l.V.T;
                return k.every((F) => O.equals(v[F], p[F]));
              case "enum":
                return k.every((F) => scalarEquals(ScalarType.INT32, v[F], p[F]));
              case "scalar":
                const D = l.V.T;
                return k.every((F) => scalarEquals(D, v[F], p[F]));
            }
            break;
        }
      });
    },
    clone(a) {
      const u = a.getType(), c = new u(), l = c;
      for (const v of u.fields.byMember()) {
        const p = a[v.localName];
        let _;
        if (v.repeated)
          _ = p.map(cloneSingularField);
        else if (v.kind == "map") {
          _ = l[v.localName];
          for (const [k, O] of Object.entries(p))
            _[k] = cloneSingularField(O);
        } else
          v.kind == "oneof" ? _ = v.findField(p.case) ? {
            case: p.case,
            value: cloneSingularField(p.value)
          } : {
            case: void 0
          } : _ = cloneSingularField(p);
        l[v.localName] = _;
      }
      return c;
    }
  };
}
function cloneSingularField(a) {
  if (a === void 0)
    return a;
  if (a instanceof Message)
    return a.clone();
  if (a instanceof Uint8Array) {
    const u = new Uint8Array(a.byteLength);
    return u.set(a), u;
  }
  return a;
}
function toU8Arr(a) {
  return a instanceof Uint8Array ? a : new Uint8Array(a);
}
class InternalFieldList {
  constructor(u, c) {
    this._fields = u, this._normalizer = c;
  }
  findJsonName(u) {
    if (!this.jsonNames) {
      const c = {};
      for (const l of this.list())
        c[l.jsonName] = c[l.name] = l;
      this.jsonNames = c;
    }
    return this.jsonNames[u];
  }
  find(u) {
    if (!this.numbers) {
      const c = {};
      for (const l of this.list())
        c[l.no] = l;
      this.numbers = c;
    }
    return this.numbers[u];
  }
  list() {
    return this.all || (this.all = this._normalizer(this._fields)), this.all;
  }
  byNumber() {
    return this.numbersAsc || (this.numbersAsc = this.list().concat().sort((u, c) => u.no - c.no)), this.numbersAsc;
  }
  byMember() {
    if (!this.members) {
      this.members = [];
      const u = this.members;
      let c;
      for (const l of this.list())
        l.oneof ? l.oneof !== c && (c = l.oneof, u.push(c)) : u.push(l);
    }
    return this.members;
  }
}
function localFieldName(a, u) {
  const c = protoCamelCase(a);
  return u ? c : safeObjectProperty(safeMessageProperty(c));
}
function localOneofName(a) {
  return localFieldName(a, !1);
}
const fieldJsonName = protoCamelCase;
function protoCamelCase(a) {
  let u = !1;
  const c = [];
  for (let l = 0; l < a.length; l++) {
    let v = a.charAt(l);
    switch (v) {
      case "_":
        u = !0;
        break;
      case "0":
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        c.push(v), u = !1;
        break;
      default:
        u && (u = !1, v = v.toUpperCase()), c.push(v);
        break;
    }
  }
  return c.join("");
}
const reservedObjectProperties = /* @__PURE__ */ new Set([
  // names reserved by JavaScript
  "constructor",
  "toString",
  "toJSON",
  "valueOf"
]), reservedMessageProperties = /* @__PURE__ */ new Set([
  // names reserved by the runtime
  "getType",
  "clone",
  "equals",
  "fromBinary",
  "fromJson",
  "fromJsonString",
  "toBinary",
  "toJson",
  "toJsonString",
  // names reserved by the runtime for the future
  "toObject"
]), fallback = (a) => "".concat(a, "$"), safeMessageProperty = (a) => reservedMessageProperties.has(a) ? fallback(a) : a, safeObjectProperty = (a) => reservedObjectProperties.has(a) ? fallback(a) : a;
class InternalOneofInfo {
  constructor(u) {
    this.kind = "oneof", this.repeated = !1, this.packed = !1, this.opt = !1, this.default = void 0, this.fields = [], this.name = u, this.localName = localOneofName(u);
  }
  addField(u) {
    assert$k(u.oneof === this, "field ".concat(u.name, " not one of ").concat(this.name)), this.fields.push(u);
  }
  findField(u) {
    if (!this._lookup) {
      this._lookup = /* @__PURE__ */ Object.create(null);
      for (let c = 0; c < this.fields.length; c++)
        this._lookup[this.fields[c].localName] = this.fields[c];
    }
    return this._lookup[u];
  }
}
const proto3 = makeProtoRuntime("proto3", makeJsonFormatProto3(), makeBinaryFormatProto3(), Object.assign(Object.assign({}, makeUtilCommon()), {
  newFieldList(a) {
    return new InternalFieldList(a, normalizeFieldInfosProto3);
  },
  initFields(a) {
    for (const u of a.getType().fields.byMember()) {
      if (u.opt)
        continue;
      const c = u.localName, l = a;
      if (u.repeated) {
        l[c] = [];
        continue;
      }
      switch (u.kind) {
        case "oneof":
          l[c] = {
            case: void 0
          };
          break;
        case "enum":
          l[c] = 0;
          break;
        case "map":
          l[c] = {};
          break;
        case "scalar":
          l[c] = scalarDefaultValue(u.T, u.L);
          break;
      }
    }
  }
}));
function normalizeFieldInfosProto3(a) {
  var u, c, l, v;
  const p = [];
  let _;
  for (const k of typeof a == "function" ? a() : a) {
    const O = k;
    if (O.localName = localFieldName(k.name, k.oneof !== void 0), O.jsonName = (u = k.jsonName) !== null && u !== void 0 ? u : fieldJsonName(k.name), O.repeated = (c = k.repeated) !== null && c !== void 0 ? c : !1, k.kind == "scalar" && (O.L = (l = k.L) !== null && l !== void 0 ? l : LongType.BIGINT), k.oneof !== void 0) {
      const D = typeof k.oneof == "string" ? k.oneof : k.oneof.name;
      (!_ || _.name != D) && (_ = new InternalOneofInfo(D)), O.oneof = _, _.addField(O);
    }
    k.kind == "message" && (O.delimited = !1), O.packed = (v = k.packed) !== null && v !== void 0 ? v : k.kind == "enum" || k.kind == "scalar" && k.T != ScalarType.BYTES && k.T != ScalarType.STRING, p.push(O);
  }
  return p;
}
class Timestamp extends Message {
  constructor(u) {
    super(), this.seconds = protoInt64.zero, this.nanos = 0, proto3.util.initPartial(u, this);
  }
  fromJson(u, c) {
    if (typeof u != "string")
      throw new Error("cannot decode google.protobuf.Timestamp from JSON: ".concat(proto3.json.debug(u)));
    const l = u.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:Z|\.([0-9]{3,9})Z|([+-][0-9][0-9]:[0-9][0-9]))$/);
    if (!l)
      throw new Error("cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string");
    const v = Date.parse(l[1] + "-" + l[2] + "-" + l[3] + "T" + l[4] + ":" + l[5] + ":" + l[6] + (l[8] ? l[8] : "Z"));
    if (Number.isNaN(v))
      throw new Error("cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string");
    if (v < Date.parse("0001-01-01T00:00:00Z") || v > Date.parse("9999-12-31T23:59:59Z"))
      throw new Error("cannot decode message google.protobuf.Timestamp from JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive");
    return this.seconds = protoInt64.parse(v / 1e3), this.nanos = 0, l[7] && (this.nanos = parseInt("1" + l[7] + "0".repeat(9 - l[7].length)) - 1e9), this;
  }
  toJson(u) {
    const c = Number(this.seconds) * 1e3;
    if (c < Date.parse("0001-01-01T00:00:00Z") || c > Date.parse("9999-12-31T23:59:59Z"))
      throw new Error("cannot encode google.protobuf.Timestamp to JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive");
    if (this.nanos < 0)
      throw new Error("cannot encode google.protobuf.Timestamp to JSON: nanos must not be negative");
    let l = "Z";
    if (this.nanos > 0) {
      const v = (this.nanos + 1e9).toString().substring(1);
      v.substring(3) === "000000" ? l = "." + v.substring(0, 3) + "Z" : v.substring(6) === "000" ? l = "." + v.substring(0, 6) + "Z" : l = "." + v + "Z";
    }
    return new Date(c).toISOString().replace(".000Z", l);
  }
  toDate() {
    return new Date(Number(this.seconds) * 1e3 + Math.ceil(this.nanos / 1e6));
  }
  static now() {
    return Timestamp.fromDate(/* @__PURE__ */ new Date());
  }
  static fromDate(u) {
    const c = u.getTime();
    return new Timestamp({
      seconds: protoInt64.parse(Math.floor(c / 1e3)),
      nanos: c % 1e3 * 1e6
    });
  }
  static fromBinary(u, c) {
    return new Timestamp().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new Timestamp().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new Timestamp().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(Timestamp, u, c);
  }
}
Timestamp.runtime = proto3;
Timestamp.typeName = "google.protobuf.Timestamp";
Timestamp.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "seconds",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 2,
  name: "nanos",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}]);
const AudioCodec$1 = proto3.makeEnum("livekit.AudioCodec", [{
  no: 0,
  name: "DEFAULT_AC"
}, {
  no: 1,
  name: "OPUS"
}, {
  no: 2,
  name: "AAC"
}]), VideoCodec$1 = proto3.makeEnum("livekit.VideoCodec", [{
  no: 0,
  name: "DEFAULT_VC"
}, {
  no: 1,
  name: "H264_BASELINE"
}, {
  no: 2,
  name: "H264_MAIN"
}, {
  no: 3,
  name: "H264_HIGH"
}, {
  no: 4,
  name: "VP8"
}]), ImageCodec = proto3.makeEnum("livekit.ImageCodec", [{
  no: 0,
  name: "IC_DEFAULT"
}, {
  no: 1,
  name: "IC_JPEG"
}]), TrackType = proto3.makeEnum("livekit.TrackType", [{
  no: 0,
  name: "AUDIO"
}, {
  no: 1,
  name: "VIDEO"
}, {
  no: 2,
  name: "DATA"
}]), TrackSource = proto3.makeEnum("livekit.TrackSource", [{
  no: 0,
  name: "UNKNOWN"
}, {
  no: 1,
  name: "CAMERA"
}, {
  no: 2,
  name: "MICROPHONE"
}, {
  no: 3,
  name: "SCREEN_SHARE"
}, {
  no: 4,
  name: "SCREEN_SHARE_AUDIO"
}]), VideoQuality$1 = proto3.makeEnum("livekit.VideoQuality", [{
  no: 0,
  name: "LOW"
}, {
  no: 1,
  name: "MEDIUM"
}, {
  no: 2,
  name: "HIGH"
}, {
  no: 3,
  name: "OFF"
}]), ConnectionQuality$1 = proto3.makeEnum("livekit.ConnectionQuality", [{
  no: 0,
  name: "POOR"
}, {
  no: 1,
  name: "GOOD"
}, {
  no: 2,
  name: "EXCELLENT"
}, {
  no: 3,
  name: "LOST"
}]), ClientConfigSetting = proto3.makeEnum("livekit.ClientConfigSetting", [{
  no: 0,
  name: "UNSET"
}, {
  no: 1,
  name: "DISABLED"
}, {
  no: 2,
  name: "ENABLED"
}]), DisconnectReason = proto3.makeEnum("livekit.DisconnectReason", [{
  no: 0,
  name: "UNKNOWN_REASON"
}, {
  no: 1,
  name: "CLIENT_INITIATED"
}, {
  no: 2,
  name: "DUPLICATE_IDENTITY"
}, {
  no: 3,
  name: "SERVER_SHUTDOWN"
}, {
  no: 4,
  name: "PARTICIPANT_REMOVED"
}, {
  no: 5,
  name: "ROOM_DELETED"
}, {
  no: 6,
  name: "STATE_MISMATCH"
}, {
  no: 7,
  name: "JOIN_FAILURE"
}, {
  no: 8,
  name: "MIGRATION"
}, {
  no: 9,
  name: "SIGNAL_CLOSE"
}]), ReconnectReason = proto3.makeEnum("livekit.ReconnectReason", [{
  no: 0,
  name: "RR_UNKNOWN"
}, {
  no: 1,
  name: "RR_SIGNAL_DISCONNECTED"
}, {
  no: 2,
  name: "RR_PUBLISHER_FAILED"
}, {
  no: 3,
  name: "RR_SUBSCRIBER_FAILED"
}, {
  no: 4,
  name: "RR_SWITCH_CANDIDATE"
}]), SubscriptionError = proto3.makeEnum("livekit.SubscriptionError", [{
  no: 0,
  name: "SE_UNKNOWN"
}, {
  no: 1,
  name: "SE_CODEC_UNSUPPORTED"
}, {
  no: 2,
  name: "SE_TRACK_NOTFOUND"
}]), Room$1 = proto3.makeMessageType("livekit.Room", () => [{
  no: 1,
  name: "sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "empty_timeout",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 14,
  name: "departure_timeout",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 4,
  name: "max_participants",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 5,
  name: "creation_time",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 6,
  name: "turn_password",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 7,
  name: "enabled_codecs",
  kind: "message",
  T: Codec,
  repeated: !0
}, {
  no: 8,
  name: "metadata",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 9,
  name: "num_participants",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 11,
  name: "num_publishers",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 10,
  name: "active_recording",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 13,
  name: "version",
  kind: "message",
  T: TimedVersion
}]), Codec = proto3.makeMessageType("livekit.Codec", () => [{
  no: 1,
  name: "mime",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "fmtp_line",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
proto3.makeMessageType("livekit.PlayoutDelay", () => [{
  no: 1,
  name: "enabled",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 2,
  name: "min",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 3,
  name: "max",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}]);
const ParticipantPermission = proto3.makeMessageType("livekit.ParticipantPermission", () => [{
  no: 1,
  name: "can_subscribe",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 2,
  name: "can_publish",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 3,
  name: "can_publish_data",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 9,
  name: "can_publish_sources",
  kind: "enum",
  T: proto3.getEnumType(TrackSource),
  repeated: !0
}, {
  no: 7,
  name: "hidden",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 8,
  name: "recorder",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 10,
  name: "can_update_metadata",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 11,
  name: "agent",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}]), ParticipantInfo = proto3.makeMessageType("livekit.ParticipantInfo", () => [{
  no: 1,
  name: "sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "identity",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "state",
  kind: "enum",
  T: proto3.getEnumType(ParticipantInfo_State)
}, {
  no: 4,
  name: "tracks",
  kind: "message",
  T: TrackInfo,
  repeated: !0
}, {
  no: 5,
  name: "metadata",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 6,
  name: "joined_at",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 9,
  name: "name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 10,
  name: "version",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 11,
  name: "permission",
  kind: "message",
  T: ParticipantPermission
}, {
  no: 12,
  name: "region",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 13,
  name: "is_publisher",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 14,
  name: "kind",
  kind: "enum",
  T: proto3.getEnumType(ParticipantInfo_Kind)
}]), ParticipantInfo_State = proto3.makeEnum("livekit.ParticipantInfo.State", [{
  no: 0,
  name: "JOINING"
}, {
  no: 1,
  name: "JOINED"
}, {
  no: 2,
  name: "ACTIVE"
}, {
  no: 3,
  name: "DISCONNECTED"
}]), ParticipantInfo_Kind = proto3.makeEnum("livekit.ParticipantInfo.Kind", [{
  no: 0,
  name: "STANDARD"
}, {
  no: 1,
  name: "INGRESS"
}, {
  no: 2,
  name: "EGRESS"
}, {
  no: 3,
  name: "SIP"
}, {
  no: 4,
  name: "AGENT"
}]);
proto3.makeMessageType("livekit.Encryption", []);
const Encryption_Type = proto3.makeEnum("livekit.Encryption.Type", [{
  no: 0,
  name: "NONE"
}, {
  no: 1,
  name: "GCM"
}, {
  no: 2,
  name: "CUSTOM"
}]), SimulcastCodecInfo = proto3.makeMessageType("livekit.SimulcastCodecInfo", () => [{
  no: 1,
  name: "mime_type",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "mid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "cid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 4,
  name: "layers",
  kind: "message",
  T: VideoLayer,
  repeated: !0
}]), TrackInfo = proto3.makeMessageType("livekit.TrackInfo", () => [{
  no: 1,
  name: "sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "type",
  kind: "enum",
  T: proto3.getEnumType(TrackType)
}, {
  no: 3,
  name: "name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 4,
  name: "muted",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 5,
  name: "width",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 6,
  name: "height",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 7,
  name: "simulcast",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 8,
  name: "disable_dtx",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 9,
  name: "source",
  kind: "enum",
  T: proto3.getEnumType(TrackSource)
}, {
  no: 10,
  name: "layers",
  kind: "message",
  T: VideoLayer,
  repeated: !0
}, {
  no: 11,
  name: "mime_type",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 12,
  name: "mid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 13,
  name: "codecs",
  kind: "message",
  T: SimulcastCodecInfo,
  repeated: !0
}, {
  no: 14,
  name: "stereo",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 15,
  name: "disable_red",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 16,
  name: "encryption",
  kind: "enum",
  T: proto3.getEnumType(Encryption_Type)
}, {
  no: 17,
  name: "stream",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 18,
  name: "version",
  kind: "message",
  T: TimedVersion
}]), VideoLayer = proto3.makeMessageType("livekit.VideoLayer", () => [{
  no: 1,
  name: "quality",
  kind: "enum",
  T: proto3.getEnumType(VideoQuality$1)
}, {
  no: 2,
  name: "width",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 3,
  name: "height",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 4,
  name: "bitrate",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 5,
  name: "ssrc",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}]), DataPacket = proto3.makeMessageType("livekit.DataPacket", () => [{
  no: 1,
  name: "kind",
  kind: "enum",
  T: proto3.getEnumType(DataPacket_Kind)
}, {
  no: 4,
  name: "participant_identity",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "destination_identities",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 2,
  name: "user",
  kind: "message",
  T: UserPacket,
  oneof: "value"
}, {
  no: 3,
  name: "speaker",
  kind: "message",
  T: ActiveSpeakerUpdate,
  oneof: "value"
}, {
  no: 6,
  name: "sip_dtmf",
  kind: "message",
  T: SipDTMF,
  oneof: "value"
}]), DataPacket_Kind = proto3.makeEnum("livekit.DataPacket.Kind", [{
  no: 0,
  name: "RELIABLE"
}, {
  no: 1,
  name: "LOSSY"
}]), ActiveSpeakerUpdate = proto3.makeMessageType("livekit.ActiveSpeakerUpdate", () => [{
  no: 1,
  name: "speakers",
  kind: "message",
  T: SpeakerInfo,
  repeated: !0
}]), SpeakerInfo = proto3.makeMessageType("livekit.SpeakerInfo", () => [{
  no: 1,
  name: "sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "level",
  kind: "scalar",
  T: 2
  /* ScalarType.FLOAT */
}, {
  no: 3,
  name: "active",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}]), UserPacket = proto3.makeMessageType("livekit.UserPacket", () => [{
  no: 1,
  name: "participant_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "participant_identity",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "payload",
  kind: "scalar",
  T: 12
  /* ScalarType.BYTES */
}, {
  no: 3,
  name: "destination_sids",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 6,
  name: "destination_identities",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 4,
  name: "topic",
  kind: "scalar",
  T: 9,
  opt: !0
}]), SipDTMF = proto3.makeMessageType("livekit.SipDTMF", () => [{
  no: 3,
  name: "code",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 4,
  name: "digit",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), ParticipantTracks = proto3.makeMessageType("livekit.ParticipantTracks", () => [{
  no: 1,
  name: "participant_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "track_sids",
  kind: "scalar",
  T: 9,
  repeated: !0
}]), ServerInfo = proto3.makeMessageType("livekit.ServerInfo", () => [{
  no: 1,
  name: "edition",
  kind: "enum",
  T: proto3.getEnumType(ServerInfo_Edition)
}, {
  no: 2,
  name: "version",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "protocol",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}, {
  no: 4,
  name: "region",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "node_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 6,
  name: "debug_info",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), ServerInfo_Edition = proto3.makeEnum("livekit.ServerInfo.Edition", [{
  no: 0,
  name: "Standard"
}, {
  no: 1,
  name: "Cloud"
}]), ClientInfo = proto3.makeMessageType("livekit.ClientInfo", () => [{
  no: 1,
  name: "sdk",
  kind: "enum",
  T: proto3.getEnumType(ClientInfo_SDK)
}, {
  no: 2,
  name: "version",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "protocol",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}, {
  no: 4,
  name: "os",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "os_version",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 6,
  name: "device_model",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 7,
  name: "browser",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 8,
  name: "browser_version",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 9,
  name: "address",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 10,
  name: "network",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), ClientInfo_SDK = proto3.makeEnum("livekit.ClientInfo.SDK", [{
  no: 0,
  name: "UNKNOWN"
}, {
  no: 1,
  name: "JS"
}, {
  no: 2,
  name: "SWIFT"
}, {
  no: 3,
  name: "ANDROID"
}, {
  no: 4,
  name: "FLUTTER"
}, {
  no: 5,
  name: "GO"
}, {
  no: 6,
  name: "UNITY"
}, {
  no: 7,
  name: "REACT_NATIVE"
}, {
  no: 8,
  name: "RUST"
}, {
  no: 9,
  name: "PYTHON"
}, {
  no: 10,
  name: "CPP"
}]), ClientConfiguration = proto3.makeMessageType("livekit.ClientConfiguration", () => [{
  no: 1,
  name: "video",
  kind: "message",
  T: VideoConfiguration
}, {
  no: 2,
  name: "screen",
  kind: "message",
  T: VideoConfiguration
}, {
  no: 3,
  name: "resume_connection",
  kind: "enum",
  T: proto3.getEnumType(ClientConfigSetting)
}, {
  no: 4,
  name: "disabled_codecs",
  kind: "message",
  T: DisabledCodecs
}, {
  no: 5,
  name: "force_relay",
  kind: "enum",
  T: proto3.getEnumType(ClientConfigSetting)
}]), VideoConfiguration = proto3.makeMessageType("livekit.VideoConfiguration", () => [{
  no: 1,
  name: "hardware_encoder",
  kind: "enum",
  T: proto3.getEnumType(ClientConfigSetting)
}]), DisabledCodecs = proto3.makeMessageType("livekit.DisabledCodecs", () => [{
  no: 1,
  name: "codecs",
  kind: "message",
  T: Codec,
  repeated: !0
}, {
  no: 2,
  name: "publish",
  kind: "message",
  T: Codec,
  repeated: !0
}]), RTPDrift = proto3.makeMessageType("livekit.RTPDrift", () => [{
  no: 1,
  name: "start_time",
  kind: "message",
  T: Timestamp
}, {
  no: 2,
  name: "end_time",
  kind: "message",
  T: Timestamp
}, {
  no: 3,
  name: "duration",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}, {
  no: 4,
  name: "start_timestamp",
  kind: "scalar",
  T: 4
  /* ScalarType.UINT64 */
}, {
  no: 5,
  name: "end_timestamp",
  kind: "scalar",
  T: 4
  /* ScalarType.UINT64 */
}, {
  no: 6,
  name: "rtp_clock_ticks",
  kind: "scalar",
  T: 4
  /* ScalarType.UINT64 */
}, {
  no: 7,
  name: "drift_samples",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 8,
  name: "drift_ms",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}, {
  no: 9,
  name: "clock_rate",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}]);
proto3.makeMessageType("livekit.RTPStats", () => [{
  no: 1,
  name: "start_time",
  kind: "message",
  T: Timestamp
}, {
  no: 2,
  name: "end_time",
  kind: "message",
  T: Timestamp
}, {
  no: 3,
  name: "duration",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}, {
  no: 4,
  name: "packets",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 5,
  name: "packet_rate",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}, {
  no: 6,
  name: "bytes",
  kind: "scalar",
  T: 4
  /* ScalarType.UINT64 */
}, {
  no: 39,
  name: "header_bytes",
  kind: "scalar",
  T: 4
  /* ScalarType.UINT64 */
}, {
  no: 7,
  name: "bitrate",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}, {
  no: 8,
  name: "packets_lost",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 9,
  name: "packet_loss_rate",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}, {
  no: 10,
  name: "packet_loss_percentage",
  kind: "scalar",
  T: 2
  /* ScalarType.FLOAT */
}, {
  no: 11,
  name: "packets_duplicate",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 12,
  name: "packet_duplicate_rate",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}, {
  no: 13,
  name: "bytes_duplicate",
  kind: "scalar",
  T: 4
  /* ScalarType.UINT64 */
}, {
  no: 40,
  name: "header_bytes_duplicate",
  kind: "scalar",
  T: 4
  /* ScalarType.UINT64 */
}, {
  no: 14,
  name: "bitrate_duplicate",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}, {
  no: 15,
  name: "packets_padding",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 16,
  name: "packet_padding_rate",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}, {
  no: 17,
  name: "bytes_padding",
  kind: "scalar",
  T: 4
  /* ScalarType.UINT64 */
}, {
  no: 41,
  name: "header_bytes_padding",
  kind: "scalar",
  T: 4
  /* ScalarType.UINT64 */
}, {
  no: 18,
  name: "bitrate_padding",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}, {
  no: 19,
  name: "packets_out_of_order",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 20,
  name: "frames",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 21,
  name: "frame_rate",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}, {
  no: 22,
  name: "jitter_current",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}, {
  no: 23,
  name: "jitter_max",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}, {
  no: 24,
  name: "gap_histogram",
  kind: "map",
  K: 5,
  V: {
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }
}, {
  no: 25,
  name: "nacks",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 37,
  name: "nack_acks",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 26,
  name: "nack_misses",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 38,
  name: "nack_repeated",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 27,
  name: "plis",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 28,
  name: "last_pli",
  kind: "message",
  T: Timestamp
}, {
  no: 29,
  name: "firs",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 30,
  name: "last_fir",
  kind: "message",
  T: Timestamp
}, {
  no: 31,
  name: "rtt_current",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 32,
  name: "rtt_max",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 33,
  name: "key_frames",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 34,
  name: "last_key_frame",
  kind: "message",
  T: Timestamp
}, {
  no: 35,
  name: "layer_lock_plis",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 36,
  name: "last_layer_lock_pli",
  kind: "message",
  T: Timestamp
}, {
  no: 44,
  name: "packet_drift",
  kind: "message",
  T: RTPDrift
}, {
  no: 45,
  name: "report_drift",
  kind: "message",
  T: RTPDrift
}]);
const TimedVersion = proto3.makeMessageType("livekit.TimedVersion", () => [{
  no: 1,
  name: "unix_micro",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 2,
  name: "ticks",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}]), EncodedFileType = proto3.makeEnum("livekit.EncodedFileType", [{
  no: 0,
  name: "DEFAULT_FILETYPE"
}, {
  no: 1,
  name: "MP4"
}, {
  no: 2,
  name: "OGG"
}]), SegmentedFileProtocol = proto3.makeEnum("livekit.SegmentedFileProtocol", [{
  no: 0,
  name: "DEFAULT_SEGMENTED_FILE_PROTOCOL"
}, {
  no: 1,
  name: "HLS_PROTOCOL"
}]), SegmentedFileSuffix = proto3.makeEnum("livekit.SegmentedFileSuffix", [{
  no: 0,
  name: "INDEX"
}, {
  no: 1,
  name: "TIMESTAMP"
}]), ImageFileSuffix = proto3.makeEnum("livekit.ImageFileSuffix", [{
  no: 0,
  name: "IMAGE_SUFFIX_INDEX"
}, {
  no: 1,
  name: "IMAGE_SUFFIX_TIMESTAMP"
}]), StreamProtocol = proto3.makeEnum("livekit.StreamProtocol", [{
  no: 0,
  name: "DEFAULT_PROTOCOL"
}, {
  no: 1,
  name: "RTMP"
}]), EncodingOptionsPreset = proto3.makeEnum("livekit.EncodingOptionsPreset", [{
  no: 0,
  name: "H264_720P_30"
}, {
  no: 1,
  name: "H264_720P_60"
}, {
  no: 2,
  name: "H264_1080P_30"
}, {
  no: 3,
  name: "H264_1080P_60"
}, {
  no: 4,
  name: "PORTRAIT_H264_720P_30"
}, {
  no: 5,
  name: "PORTRAIT_H264_720P_60"
}, {
  no: 6,
  name: "PORTRAIT_H264_1080P_30"
}, {
  no: 7,
  name: "PORTRAIT_H264_1080P_60"
}]), EgressStatus = proto3.makeEnum("livekit.EgressStatus", [{
  no: 0,
  name: "EGRESS_STARTING"
}, {
  no: 1,
  name: "EGRESS_ACTIVE"
}, {
  no: 2,
  name: "EGRESS_ENDING"
}, {
  no: 3,
  name: "EGRESS_COMPLETE"
}, {
  no: 4,
  name: "EGRESS_FAILED"
}, {
  no: 5,
  name: "EGRESS_ABORTED"
}, {
  no: 6,
  name: "EGRESS_LIMIT_REACHED"
}]), RoomCompositeEgressRequest = proto3.makeMessageType("livekit.RoomCompositeEgressRequest", () => [{
  no: 1,
  name: "room_name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "layout",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "audio_only",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 4,
  name: "video_only",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 5,
  name: "custom_base_url",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 6,
  name: "file",
  kind: "message",
  T: EncodedFileOutput,
  oneof: "output"
}, {
  no: 7,
  name: "stream",
  kind: "message",
  T: StreamOutput,
  oneof: "output"
}, {
  no: 10,
  name: "segments",
  kind: "message",
  T: SegmentedFileOutput,
  oneof: "output"
}, {
  no: 8,
  name: "preset",
  kind: "enum",
  T: proto3.getEnumType(EncodingOptionsPreset),
  oneof: "options"
}, {
  no: 9,
  name: "advanced",
  kind: "message",
  T: EncodingOptions,
  oneof: "options"
}, {
  no: 11,
  name: "file_outputs",
  kind: "message",
  T: EncodedFileOutput,
  repeated: !0
}, {
  no: 12,
  name: "stream_outputs",
  kind: "message",
  T: StreamOutput,
  repeated: !0
}, {
  no: 13,
  name: "segment_outputs",
  kind: "message",
  T: SegmentedFileOutput,
  repeated: !0
}, {
  no: 14,
  name: "image_outputs",
  kind: "message",
  T: ImageOutput,
  repeated: !0
}]), WebEgressRequest = proto3.makeMessageType("livekit.WebEgressRequest", () => [{
  no: 1,
  name: "url",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "audio_only",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 3,
  name: "video_only",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 12,
  name: "await_start_signal",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 4,
  name: "file",
  kind: "message",
  T: EncodedFileOutput,
  oneof: "output"
}, {
  no: 5,
  name: "stream",
  kind: "message",
  T: StreamOutput,
  oneof: "output"
}, {
  no: 6,
  name: "segments",
  kind: "message",
  T: SegmentedFileOutput,
  oneof: "output"
}, {
  no: 7,
  name: "preset",
  kind: "enum",
  T: proto3.getEnumType(EncodingOptionsPreset),
  oneof: "options"
}, {
  no: 8,
  name: "advanced",
  kind: "message",
  T: EncodingOptions,
  oneof: "options"
}, {
  no: 9,
  name: "file_outputs",
  kind: "message",
  T: EncodedFileOutput,
  repeated: !0
}, {
  no: 10,
  name: "stream_outputs",
  kind: "message",
  T: StreamOutput,
  repeated: !0
}, {
  no: 11,
  name: "segment_outputs",
  kind: "message",
  T: SegmentedFileOutput,
  repeated: !0
}, {
  no: 13,
  name: "image_outputs",
  kind: "message",
  T: ImageOutput,
  repeated: !0
}]), ParticipantEgressRequest = proto3.makeMessageType("livekit.ParticipantEgressRequest", () => [{
  no: 1,
  name: "room_name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "identity",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "screen_share",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 4,
  name: "preset",
  kind: "enum",
  T: proto3.getEnumType(EncodingOptionsPreset),
  oneof: "options"
}, {
  no: 5,
  name: "advanced",
  kind: "message",
  T: EncodingOptions,
  oneof: "options"
}, {
  no: 6,
  name: "file_outputs",
  kind: "message",
  T: EncodedFileOutput,
  repeated: !0
}, {
  no: 7,
  name: "stream_outputs",
  kind: "message",
  T: StreamOutput,
  repeated: !0
}, {
  no: 8,
  name: "segment_outputs",
  kind: "message",
  T: SegmentedFileOutput,
  repeated: !0
}, {
  no: 9,
  name: "image_outputs",
  kind: "message",
  T: ImageOutput,
  repeated: !0
}]), TrackCompositeEgressRequest = proto3.makeMessageType("livekit.TrackCompositeEgressRequest", () => [{
  no: 1,
  name: "room_name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "audio_track_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "video_track_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 4,
  name: "file",
  kind: "message",
  T: EncodedFileOutput,
  oneof: "output"
}, {
  no: 5,
  name: "stream",
  kind: "message",
  T: StreamOutput,
  oneof: "output"
}, {
  no: 8,
  name: "segments",
  kind: "message",
  T: SegmentedFileOutput,
  oneof: "output"
}, {
  no: 6,
  name: "preset",
  kind: "enum",
  T: proto3.getEnumType(EncodingOptionsPreset),
  oneof: "options"
}, {
  no: 7,
  name: "advanced",
  kind: "message",
  T: EncodingOptions,
  oneof: "options"
}, {
  no: 11,
  name: "file_outputs",
  kind: "message",
  T: EncodedFileOutput,
  repeated: !0
}, {
  no: 12,
  name: "stream_outputs",
  kind: "message",
  T: StreamOutput,
  repeated: !0
}, {
  no: 13,
  name: "segment_outputs",
  kind: "message",
  T: SegmentedFileOutput,
  repeated: !0
}, {
  no: 14,
  name: "image_outputs",
  kind: "message",
  T: ImageOutput,
  repeated: !0
}]), TrackEgressRequest = proto3.makeMessageType("livekit.TrackEgressRequest", () => [{
  no: 1,
  name: "room_name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "track_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "file",
  kind: "message",
  T: DirectFileOutput,
  oneof: "output"
}, {
  no: 4,
  name: "websocket_url",
  kind: "scalar",
  T: 9,
  oneof: "output"
}]), EncodedFileOutput = proto3.makeMessageType("livekit.EncodedFileOutput", () => [{
  no: 1,
  name: "file_type",
  kind: "enum",
  T: proto3.getEnumType(EncodedFileType)
}, {
  no: 2,
  name: "filepath",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 6,
  name: "disable_manifest",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 3,
  name: "s3",
  kind: "message",
  T: S3Upload,
  oneof: "output"
}, {
  no: 4,
  name: "gcp",
  kind: "message",
  T: GCPUpload,
  oneof: "output"
}, {
  no: 5,
  name: "azure",
  kind: "message",
  T: AzureBlobUpload,
  oneof: "output"
}, {
  no: 7,
  name: "aliOSS",
  kind: "message",
  T: AliOSSUpload,
  oneof: "output"
}]), SegmentedFileOutput = proto3.makeMessageType("livekit.SegmentedFileOutput", () => [{
  no: 1,
  name: "protocol",
  kind: "enum",
  T: proto3.getEnumType(SegmentedFileProtocol)
}, {
  no: 2,
  name: "filename_prefix",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "playlist_name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 11,
  name: "live_playlist_name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 4,
  name: "segment_duration",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 10,
  name: "filename_suffix",
  kind: "enum",
  T: proto3.getEnumType(SegmentedFileSuffix)
}, {
  no: 8,
  name: "disable_manifest",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 5,
  name: "s3",
  kind: "message",
  T: S3Upload,
  oneof: "output"
}, {
  no: 6,
  name: "gcp",
  kind: "message",
  T: GCPUpload,
  oneof: "output"
}, {
  no: 7,
  name: "azure",
  kind: "message",
  T: AzureBlobUpload,
  oneof: "output"
}, {
  no: 9,
  name: "aliOSS",
  kind: "message",
  T: AliOSSUpload,
  oneof: "output"
}]), DirectFileOutput = proto3.makeMessageType("livekit.DirectFileOutput", () => [{
  no: 1,
  name: "filepath",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "disable_manifest",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 2,
  name: "s3",
  kind: "message",
  T: S3Upload,
  oneof: "output"
}, {
  no: 3,
  name: "gcp",
  kind: "message",
  T: GCPUpload,
  oneof: "output"
}, {
  no: 4,
  name: "azure",
  kind: "message",
  T: AzureBlobUpload,
  oneof: "output"
}, {
  no: 6,
  name: "aliOSS",
  kind: "message",
  T: AliOSSUpload,
  oneof: "output"
}]), ImageOutput = proto3.makeMessageType("livekit.ImageOutput", () => [{
  no: 1,
  name: "capture_interval",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 2,
  name: "width",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}, {
  no: 3,
  name: "height",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}, {
  no: 4,
  name: "filename_prefix",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "filename_suffix",
  kind: "enum",
  T: proto3.getEnumType(ImageFileSuffix)
}, {
  no: 6,
  name: "image_codec",
  kind: "enum",
  T: proto3.getEnumType(ImageCodec)
}, {
  no: 7,
  name: "disable_manifest",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 8,
  name: "s3",
  kind: "message",
  T: S3Upload,
  oneof: "output"
}, {
  no: 9,
  name: "gcp",
  kind: "message",
  T: GCPUpload,
  oneof: "output"
}, {
  no: 10,
  name: "azure",
  kind: "message",
  T: AzureBlobUpload,
  oneof: "output"
}, {
  no: 11,
  name: "aliOSS",
  kind: "message",
  T: AliOSSUpload,
  oneof: "output"
}]), S3Upload = proto3.makeMessageType("livekit.S3Upload", () => [{
  no: 1,
  name: "access_key",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "secret",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "region",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 4,
  name: "endpoint",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "bucket",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 6,
  name: "force_path_style",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 7,
  name: "metadata",
  kind: "map",
  K: 9,
  V: {
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
}, {
  no: 8,
  name: "tagging",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 9,
  name: "content_disposition",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), GCPUpload = proto3.makeMessageType("livekit.GCPUpload", () => [{
  no: 1,
  name: "credentials",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "bucket",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "endpoint",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), AzureBlobUpload = proto3.makeMessageType("livekit.AzureBlobUpload", () => [{
  no: 1,
  name: "account_name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "account_key",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "container_name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), AliOSSUpload = proto3.makeMessageType("livekit.AliOSSUpload", () => [{
  no: 1,
  name: "access_key",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "secret",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "region",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 4,
  name: "endpoint",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "bucket",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), StreamOutput = proto3.makeMessageType("livekit.StreamOutput", () => [{
  no: 1,
  name: "protocol",
  kind: "enum",
  T: proto3.getEnumType(StreamProtocol)
}, {
  no: 2,
  name: "urls",
  kind: "scalar",
  T: 9,
  repeated: !0
}]), EncodingOptions = proto3.makeMessageType("livekit.EncodingOptions", () => [{
  no: 1,
  name: "width",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}, {
  no: 2,
  name: "height",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}, {
  no: 3,
  name: "depth",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}, {
  no: 4,
  name: "framerate",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}, {
  no: 5,
  name: "audio_codec",
  kind: "enum",
  T: proto3.getEnumType(AudioCodec$1)
}, {
  no: 6,
  name: "audio_bitrate",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}, {
  no: 11,
  name: "audio_quality",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}, {
  no: 7,
  name: "audio_frequency",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}, {
  no: 8,
  name: "video_codec",
  kind: "enum",
  T: proto3.getEnumType(VideoCodec$1)
}, {
  no: 9,
  name: "video_bitrate",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}, {
  no: 12,
  name: "video_quality",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}, {
  no: 10,
  name: "key_frame_interval",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}]);
proto3.makeMessageType("livekit.UpdateLayoutRequest", () => [{
  no: 1,
  name: "egress_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "layout",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
proto3.makeMessageType("livekit.UpdateStreamRequest", () => [{
  no: 1,
  name: "egress_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "add_output_urls",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 3,
  name: "remove_output_urls",
  kind: "scalar",
  T: 9,
  repeated: !0
}]);
proto3.makeMessageType("livekit.ListEgressRequest", () => [{
  no: 1,
  name: "room_name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "egress_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "active",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}]);
proto3.makeMessageType("livekit.ListEgressResponse", () => [{
  no: 1,
  name: "items",
  kind: "message",
  T: EgressInfo,
  repeated: !0
}]);
proto3.makeMessageType("livekit.StopEgressRequest", () => [{
  no: 1,
  name: "egress_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
const EgressInfo = proto3.makeMessageType("livekit.EgressInfo", () => [{
  no: 1,
  name: "egress_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "room_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 13,
  name: "room_name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "status",
  kind: "enum",
  T: proto3.getEnumType(EgressStatus)
}, {
  no: 10,
  name: "started_at",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 11,
  name: "ended_at",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 18,
  name: "updated_at",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 21,
  name: "details",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 9,
  name: "error",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 4,
  name: "room_composite",
  kind: "message",
  T: RoomCompositeEgressRequest,
  oneof: "request"
}, {
  no: 14,
  name: "web",
  kind: "message",
  T: WebEgressRequest,
  oneof: "request"
}, {
  no: 19,
  name: "participant",
  kind: "message",
  T: ParticipantEgressRequest,
  oneof: "request"
}, {
  no: 5,
  name: "track_composite",
  kind: "message",
  T: TrackCompositeEgressRequest,
  oneof: "request"
}, {
  no: 6,
  name: "track",
  kind: "message",
  T: TrackEgressRequest,
  oneof: "request"
}, {
  no: 7,
  name: "stream",
  kind: "message",
  T: StreamInfoList,
  oneof: "result"
}, {
  no: 8,
  name: "file",
  kind: "message",
  T: FileInfo,
  oneof: "result"
}, {
  no: 12,
  name: "segments",
  kind: "message",
  T: SegmentsInfo,
  oneof: "result"
}, {
  no: 15,
  name: "stream_results",
  kind: "message",
  T: StreamInfo,
  repeated: !0
}, {
  no: 16,
  name: "file_results",
  kind: "message",
  T: FileInfo,
  repeated: !0
}, {
  no: 17,
  name: "segment_results",
  kind: "message",
  T: SegmentsInfo,
  repeated: !0
}, {
  no: 20,
  name: "image_results",
  kind: "message",
  T: ImagesInfo,
  repeated: !0
}]), StreamInfoList = proto3.makeMessageType("livekit.StreamInfoList", () => [{
  no: 1,
  name: "info",
  kind: "message",
  T: StreamInfo,
  repeated: !0
}]), StreamInfo = proto3.makeMessageType("livekit.StreamInfo", () => [{
  no: 1,
  name: "url",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "started_at",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 3,
  name: "ended_at",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 4,
  name: "duration",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 5,
  name: "status",
  kind: "enum",
  T: proto3.getEnumType(StreamInfo_Status)
}, {
  no: 6,
  name: "error",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), StreamInfo_Status = proto3.makeEnum("livekit.StreamInfo.Status", [{
  no: 0,
  name: "ACTIVE"
}, {
  no: 1,
  name: "FINISHED"
}, {
  no: 2,
  name: "FAILED"
}]), FileInfo = proto3.makeMessageType("livekit.FileInfo", () => [{
  no: 1,
  name: "filename",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "started_at",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 3,
  name: "ended_at",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 6,
  name: "duration",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 4,
  name: "size",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 5,
  name: "location",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), SegmentsInfo = proto3.makeMessageType("livekit.SegmentsInfo", () => [{
  no: 1,
  name: "playlist_name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 8,
  name: "live_playlist_name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "duration",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 3,
  name: "size",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 4,
  name: "playlist_location",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 9,
  name: "live_playlist_location",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "segment_count",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 6,
  name: "started_at",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 7,
  name: "ended_at",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}]), ImagesInfo = proto3.makeMessageType("livekit.ImagesInfo", () => [{
  no: 1,
  name: "image_count",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 2,
  name: "started_at",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 3,
  name: "ended_at",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}]), AutoParticipantEgress = proto3.makeMessageType("livekit.AutoParticipantEgress", () => [{
  no: 1,
  name: "preset",
  kind: "enum",
  T: proto3.getEnumType(EncodingOptionsPreset),
  oneof: "options"
}, {
  no: 2,
  name: "advanced",
  kind: "message",
  T: EncodingOptions,
  oneof: "options"
}, {
  no: 3,
  name: "file_outputs",
  kind: "message",
  T: EncodedFileOutput,
  repeated: !0
}, {
  no: 4,
  name: "segment_outputs",
  kind: "message",
  T: SegmentedFileOutput,
  repeated: !0
}]), AutoTrackEgress = proto3.makeMessageType("livekit.AutoTrackEgress", () => [{
  no: 1,
  name: "filepath",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "disable_manifest",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 2,
  name: "s3",
  kind: "message",
  T: S3Upload,
  oneof: "output"
}, {
  no: 3,
  name: "gcp",
  kind: "message",
  T: GCPUpload,
  oneof: "output"
}, {
  no: 4,
  name: "azure",
  kind: "message",
  T: AzureBlobUpload,
  oneof: "output"
}]);
proto3.makeMessageType("livekit.CreateRoomRequest", () => [{
  no: 1,
  name: "name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "empty_timeout",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 10,
  name: "departure_timeout",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 3,
  name: "max_participants",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 4,
  name: "node_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "metadata",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 6,
  name: "egress",
  kind: "message",
  T: RoomEgress
}, {
  no: 7,
  name: "min_playout_delay",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 8,
  name: "max_playout_delay",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 9,
  name: "sync_streams",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}]);
const RoomEgress = proto3.makeMessageType("livekit.RoomEgress", () => [{
  no: 1,
  name: "room",
  kind: "message",
  T: RoomCompositeEgressRequest
}, {
  no: 3,
  name: "participant",
  kind: "message",
  T: AutoParticipantEgress
}, {
  no: 2,
  name: "tracks",
  kind: "message",
  T: AutoTrackEgress
}]);
proto3.makeMessageType("livekit.ListRoomsRequest", () => [{
  no: 1,
  name: "names",
  kind: "scalar",
  T: 9,
  repeated: !0
}]);
proto3.makeMessageType("livekit.ListRoomsResponse", () => [{
  no: 1,
  name: "rooms",
  kind: "message",
  T: Room$1,
  repeated: !0
}]);
proto3.makeMessageType("livekit.DeleteRoomRequest", () => [{
  no: 1,
  name: "room",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
proto3.makeMessageType("livekit.DeleteRoomResponse", []);
proto3.makeMessageType("livekit.ListParticipantsRequest", () => [{
  no: 1,
  name: "room",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
proto3.makeMessageType("livekit.ListParticipantsResponse", () => [{
  no: 1,
  name: "participants",
  kind: "message",
  T: ParticipantInfo,
  repeated: !0
}]);
proto3.makeMessageType("livekit.RoomParticipantIdentity", () => [{
  no: 1,
  name: "room",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "identity",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
proto3.makeMessageType("livekit.RemoveParticipantResponse", []);
proto3.makeMessageType("livekit.MuteRoomTrackRequest", () => [{
  no: 1,
  name: "room",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "identity",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "track_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 4,
  name: "muted",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}]);
proto3.makeMessageType("livekit.MuteRoomTrackResponse", () => [{
  no: 1,
  name: "track",
  kind: "message",
  T: TrackInfo
}]);
proto3.makeMessageType("livekit.UpdateParticipantRequest", () => [{
  no: 1,
  name: "room",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "identity",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "metadata",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 4,
  name: "permission",
  kind: "message",
  T: ParticipantPermission
}, {
  no: 5,
  name: "name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
proto3.makeMessageType("livekit.UpdateSubscriptionsRequest", () => [{
  no: 1,
  name: "room",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "identity",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "track_sids",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 4,
  name: "subscribe",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 5,
  name: "participant_tracks",
  kind: "message",
  T: ParticipantTracks,
  repeated: !0
}]);
proto3.makeMessageType("livekit.UpdateSubscriptionsResponse", []);
proto3.makeMessageType("livekit.SendDataRequest", () => [{
  no: 1,
  name: "room",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "data",
  kind: "scalar",
  T: 12
  /* ScalarType.BYTES */
}, {
  no: 3,
  name: "kind",
  kind: "enum",
  T: proto3.getEnumType(DataPacket_Kind)
}, {
  no: 4,
  name: "destination_sids",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 6,
  name: "destination_identities",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 5,
  name: "topic",
  kind: "scalar",
  T: 9,
  opt: !0
}]);
proto3.makeMessageType("livekit.SendDataResponse", []);
proto3.makeMessageType("livekit.UpdateRoomMetadataRequest", () => [{
  no: 1,
  name: "room",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "metadata",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
const JobType = proto3.makeEnum("livekit.JobType", [{
  no: 0,
  name: "JT_ROOM"
}, {
  no: 1,
  name: "JT_PUBLISHER"
}]), WorkerStatus = proto3.makeEnum("livekit.WorkerStatus", [{
  no: 0,
  name: "WS_AVAILABLE"
}, {
  no: 1,
  name: "WS_FULL"
}]), JobStatus = proto3.makeEnum("livekit.JobStatus", [{
  no: 0,
  name: "JS_UNKNOWN"
}, {
  no: 1,
  name: "JS_SUCCESS"
}, {
  no: 2,
  name: "JS_FAILED"
}]);
proto3.makeMessageType("livekit.AgentInfo", () => [{
  no: 1,
  name: "id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "version",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
const Job = proto3.makeMessageType("livekit.Job", () => [{
  no: 1,
  name: "id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "type",
  kind: "enum",
  T: proto3.getEnumType(JobType)
}, {
  no: 3,
  name: "room",
  kind: "message",
  T: Room$1
}, {
  no: 4,
  name: "participant",
  kind: "message",
  T: ParticipantInfo,
  opt: !0
}]);
proto3.makeMessageType("livekit.WorkerMessage", () => [{
  no: 1,
  name: "register",
  kind: "message",
  T: RegisterWorkerRequest,
  oneof: "message"
}, {
  no: 2,
  name: "availability",
  kind: "message",
  T: AvailabilityResponse,
  oneof: "message"
}, {
  no: 3,
  name: "status",
  kind: "message",
  T: UpdateWorkerStatus,
  oneof: "message"
}, {
  no: 4,
  name: "job_update",
  kind: "message",
  T: JobStatusUpdate,
  oneof: "message"
}]);
proto3.makeMessageType("livekit.ServerMessage", () => [{
  no: 1,
  name: "register",
  kind: "message",
  T: RegisterWorkerResponse,
  oneof: "message"
}, {
  no: 2,
  name: "availability",
  kind: "message",
  T: AvailabilityRequest,
  oneof: "message"
}, {
  no: 3,
  name: "assignment",
  kind: "message",
  T: JobAssignment,
  oneof: "message"
}]);
const RegisterWorkerRequest = proto3.makeMessageType("livekit.RegisterWorkerRequest", () => [{
  no: 1,
  name: "type",
  kind: "enum",
  T: proto3.getEnumType(JobType)
}, {
  no: 2,
  name: "worker_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "version",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 4,
  name: "name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), RegisterWorkerResponse = proto3.makeMessageType("livekit.RegisterWorkerResponse", () => [{
  no: 1,
  name: "worker_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "server_version",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), AvailabilityRequest = proto3.makeMessageType("livekit.AvailabilityRequest", () => [{
  no: 1,
  name: "job",
  kind: "message",
  T: Job
}]), AvailabilityResponse = proto3.makeMessageType("livekit.AvailabilityResponse", () => [{
  no: 1,
  name: "job_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "available",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}]), JobStatusUpdate = proto3.makeMessageType("livekit.JobStatusUpdate", () => [{
  no: 1,
  name: "job_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "status",
  kind: "enum",
  T: proto3.getEnumType(JobStatus)
}, {
  no: 3,
  name: "error",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 4,
  name: "user_data",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), JobAssignment = proto3.makeMessageType("livekit.JobAssignment", () => [{
  no: 1,
  name: "job",
  kind: "message",
  T: Job
}]), UpdateWorkerStatus = proto3.makeMessageType("livekit.UpdateWorkerStatus", () => [{
  no: 1,
  name: "status",
  kind: "enum",
  T: proto3.getEnumType(WorkerStatus)
}]), SignalTarget = proto3.makeEnum("livekit.SignalTarget", [{
  no: 0,
  name: "PUBLISHER"
}, {
  no: 1,
  name: "SUBSCRIBER"
}]), StreamState = proto3.makeEnum("livekit.StreamState", [{
  no: 0,
  name: "ACTIVE"
}, {
  no: 1,
  name: "PAUSED"
}]), CandidateProtocol = proto3.makeEnum("livekit.CandidateProtocol", [{
  no: 0,
  name: "UDP"
}, {
  no: 1,
  name: "TCP"
}, {
  no: 2,
  name: "TLS"
}]), SignalRequest = proto3.makeMessageType("livekit.SignalRequest", () => [{
  no: 1,
  name: "offer",
  kind: "message",
  T: SessionDescription,
  oneof: "message"
}, {
  no: 2,
  name: "answer",
  kind: "message",
  T: SessionDescription,
  oneof: "message"
}, {
  no: 3,
  name: "trickle",
  kind: "message",
  T: TrickleRequest,
  oneof: "message"
}, {
  no: 4,
  name: "add_track",
  kind: "message",
  T: AddTrackRequest,
  oneof: "message"
}, {
  no: 5,
  name: "mute",
  kind: "message",
  T: MuteTrackRequest,
  oneof: "message"
}, {
  no: 6,
  name: "subscription",
  kind: "message",
  T: UpdateSubscription,
  oneof: "message"
}, {
  no: 7,
  name: "track_setting",
  kind: "message",
  T: UpdateTrackSettings,
  oneof: "message"
}, {
  no: 8,
  name: "leave",
  kind: "message",
  T: LeaveRequest,
  oneof: "message"
}, {
  no: 10,
  name: "update_layers",
  kind: "message",
  T: UpdateVideoLayers,
  oneof: "message"
}, {
  no: 11,
  name: "subscription_permission",
  kind: "message",
  T: SubscriptionPermission,
  oneof: "message"
}, {
  no: 12,
  name: "sync_state",
  kind: "message",
  T: SyncState,
  oneof: "message"
}, {
  no: 13,
  name: "simulate",
  kind: "message",
  T: SimulateScenario,
  oneof: "message"
}, {
  no: 14,
  name: "ping",
  kind: "scalar",
  T: 3,
  oneof: "message"
}, {
  no: 15,
  name: "update_metadata",
  kind: "message",
  T: UpdateParticipantMetadata,
  oneof: "message"
}, {
  no: 16,
  name: "ping_req",
  kind: "message",
  T: Ping,
  oneof: "message"
}]), SignalResponse = proto3.makeMessageType("livekit.SignalResponse", () => [{
  no: 1,
  name: "join",
  kind: "message",
  T: JoinResponse,
  oneof: "message"
}, {
  no: 2,
  name: "answer",
  kind: "message",
  T: SessionDescription,
  oneof: "message"
}, {
  no: 3,
  name: "offer",
  kind: "message",
  T: SessionDescription,
  oneof: "message"
}, {
  no: 4,
  name: "trickle",
  kind: "message",
  T: TrickleRequest,
  oneof: "message"
}, {
  no: 5,
  name: "update",
  kind: "message",
  T: ParticipantUpdate,
  oneof: "message"
}, {
  no: 6,
  name: "track_published",
  kind: "message",
  T: TrackPublishedResponse,
  oneof: "message"
}, {
  no: 8,
  name: "leave",
  kind: "message",
  T: LeaveRequest,
  oneof: "message"
}, {
  no: 9,
  name: "mute",
  kind: "message",
  T: MuteTrackRequest,
  oneof: "message"
}, {
  no: 10,
  name: "speakers_changed",
  kind: "message",
  T: SpeakersChanged,
  oneof: "message"
}, {
  no: 11,
  name: "room_update",
  kind: "message",
  T: RoomUpdate,
  oneof: "message"
}, {
  no: 12,
  name: "connection_quality",
  kind: "message",
  T: ConnectionQualityUpdate,
  oneof: "message"
}, {
  no: 13,
  name: "stream_state_update",
  kind: "message",
  T: StreamStateUpdate,
  oneof: "message"
}, {
  no: 14,
  name: "subscribed_quality_update",
  kind: "message",
  T: SubscribedQualityUpdate,
  oneof: "message"
}, {
  no: 15,
  name: "subscription_permission_update",
  kind: "message",
  T: SubscriptionPermissionUpdate,
  oneof: "message"
}, {
  no: 16,
  name: "refresh_token",
  kind: "scalar",
  T: 9,
  oneof: "message"
}, {
  no: 17,
  name: "track_unpublished",
  kind: "message",
  T: TrackUnpublishedResponse,
  oneof: "message"
}, {
  no: 18,
  name: "pong",
  kind: "scalar",
  T: 3,
  oneof: "message"
}, {
  no: 19,
  name: "reconnect",
  kind: "message",
  T: ReconnectResponse,
  oneof: "message"
}, {
  no: 20,
  name: "pong_resp",
  kind: "message",
  T: Pong,
  oneof: "message"
}, {
  no: 21,
  name: "subscription_response",
  kind: "message",
  T: SubscriptionResponse,
  oneof: "message"
}]), SimulcastCodec = proto3.makeMessageType("livekit.SimulcastCodec", () => [{
  no: 1,
  name: "codec",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "cid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), AddTrackRequest = proto3.makeMessageType("livekit.AddTrackRequest", () => [{
  no: 1,
  name: "cid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "type",
  kind: "enum",
  T: proto3.getEnumType(TrackType)
}, {
  no: 4,
  name: "width",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 5,
  name: "height",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 6,
  name: "muted",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 7,
  name: "disable_dtx",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 8,
  name: "source",
  kind: "enum",
  T: proto3.getEnumType(TrackSource)
}, {
  no: 9,
  name: "layers",
  kind: "message",
  T: VideoLayer,
  repeated: !0
}, {
  no: 10,
  name: "simulcast_codecs",
  kind: "message",
  T: SimulcastCodec,
  repeated: !0
}, {
  no: 11,
  name: "sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 12,
  name: "stereo",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 13,
  name: "disable_red",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 14,
  name: "encryption",
  kind: "enum",
  T: proto3.getEnumType(Encryption_Type)
}, {
  no: 15,
  name: "stream",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), TrickleRequest = proto3.makeMessageType("livekit.TrickleRequest", () => [{
  no: 1,
  name: "candidateInit",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "target",
  kind: "enum",
  T: proto3.getEnumType(SignalTarget)
}]), MuteTrackRequest = proto3.makeMessageType("livekit.MuteTrackRequest", () => [{
  no: 1,
  name: "sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "muted",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}]), JoinResponse = proto3.makeMessageType("livekit.JoinResponse", () => [{
  no: 1,
  name: "room",
  kind: "message",
  T: Room$1
}, {
  no: 2,
  name: "participant",
  kind: "message",
  T: ParticipantInfo
}, {
  no: 3,
  name: "other_participants",
  kind: "message",
  T: ParticipantInfo,
  repeated: !0
}, {
  no: 4,
  name: "server_version",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "ice_servers",
  kind: "message",
  T: ICEServer,
  repeated: !0
}, {
  no: 6,
  name: "subscriber_primary",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 7,
  name: "alternative_url",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 8,
  name: "client_configuration",
  kind: "message",
  T: ClientConfiguration
}, {
  no: 9,
  name: "server_region",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 10,
  name: "ping_timeout",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}, {
  no: 11,
  name: "ping_interval",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}, {
  no: 12,
  name: "server_info",
  kind: "message",
  T: ServerInfo
}, {
  no: 13,
  name: "sif_trailer",
  kind: "scalar",
  T: 12
  /* ScalarType.BYTES */
}]), ReconnectResponse = proto3.makeMessageType("livekit.ReconnectResponse", () => [{
  no: 1,
  name: "ice_servers",
  kind: "message",
  T: ICEServer,
  repeated: !0
}, {
  no: 2,
  name: "client_configuration",
  kind: "message",
  T: ClientConfiguration
}]), TrackPublishedResponse = proto3.makeMessageType("livekit.TrackPublishedResponse", () => [{
  no: 1,
  name: "cid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "track",
  kind: "message",
  T: TrackInfo
}]), TrackUnpublishedResponse = proto3.makeMessageType("livekit.TrackUnpublishedResponse", () => [{
  no: 1,
  name: "track_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), SessionDescription = proto3.makeMessageType("livekit.SessionDescription", () => [{
  no: 1,
  name: "type",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "sdp",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), ParticipantUpdate = proto3.makeMessageType("livekit.ParticipantUpdate", () => [{
  no: 1,
  name: "participants",
  kind: "message",
  T: ParticipantInfo,
  repeated: !0
}]), UpdateSubscription = proto3.makeMessageType("livekit.UpdateSubscription", () => [{
  no: 1,
  name: "track_sids",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 2,
  name: "subscribe",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 3,
  name: "participant_tracks",
  kind: "message",
  T: ParticipantTracks,
  repeated: !0
}]), UpdateTrackSettings = proto3.makeMessageType("livekit.UpdateTrackSettings", () => [{
  no: 1,
  name: "track_sids",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 3,
  name: "disabled",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 4,
  name: "quality",
  kind: "enum",
  T: proto3.getEnumType(VideoQuality$1)
}, {
  no: 5,
  name: "width",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 6,
  name: "height",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 7,
  name: "fps",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 8,
  name: "priority",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}]), LeaveRequest = proto3.makeMessageType("livekit.LeaveRequest", () => [{
  no: 1,
  name: "can_reconnect",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 2,
  name: "reason",
  kind: "enum",
  T: proto3.getEnumType(DisconnectReason)
}, {
  no: 3,
  name: "action",
  kind: "enum",
  T: proto3.getEnumType(LeaveRequest_Action)
}, {
  no: 4,
  name: "regions",
  kind: "message",
  T: RegionSettings
}]), LeaveRequest_Action = proto3.makeEnum("livekit.LeaveRequest.Action", [{
  no: 0,
  name: "DISCONNECT"
}, {
  no: 1,
  name: "RESUME"
}, {
  no: 2,
  name: "RECONNECT"
}]), UpdateVideoLayers = proto3.makeMessageType("livekit.UpdateVideoLayers", () => [{
  no: 1,
  name: "track_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "layers",
  kind: "message",
  T: VideoLayer,
  repeated: !0
}]), UpdateParticipantMetadata = proto3.makeMessageType("livekit.UpdateParticipantMetadata", () => [{
  no: 1,
  name: "metadata",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), ICEServer = proto3.makeMessageType("livekit.ICEServer", () => [{
  no: 1,
  name: "urls",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 2,
  name: "username",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "credential",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), SpeakersChanged = proto3.makeMessageType("livekit.SpeakersChanged", () => [{
  no: 1,
  name: "speakers",
  kind: "message",
  T: SpeakerInfo,
  repeated: !0
}]), RoomUpdate = proto3.makeMessageType("livekit.RoomUpdate", () => [{
  no: 1,
  name: "room",
  kind: "message",
  T: Room$1
}]), ConnectionQualityInfo = proto3.makeMessageType("livekit.ConnectionQualityInfo", () => [{
  no: 1,
  name: "participant_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "quality",
  kind: "enum",
  T: proto3.getEnumType(ConnectionQuality$1)
}, {
  no: 3,
  name: "score",
  kind: "scalar",
  T: 2
  /* ScalarType.FLOAT */
}]), ConnectionQualityUpdate = proto3.makeMessageType("livekit.ConnectionQualityUpdate", () => [{
  no: 1,
  name: "updates",
  kind: "message",
  T: ConnectionQualityInfo,
  repeated: !0
}]), StreamStateInfo = proto3.makeMessageType("livekit.StreamStateInfo", () => [{
  no: 1,
  name: "participant_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "track_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "state",
  kind: "enum",
  T: proto3.getEnumType(StreamState)
}]), StreamStateUpdate = proto3.makeMessageType("livekit.StreamStateUpdate", () => [{
  no: 1,
  name: "stream_states",
  kind: "message",
  T: StreamStateInfo,
  repeated: !0
}]), SubscribedQuality = proto3.makeMessageType("livekit.SubscribedQuality", () => [{
  no: 1,
  name: "quality",
  kind: "enum",
  T: proto3.getEnumType(VideoQuality$1)
}, {
  no: 2,
  name: "enabled",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}]), SubscribedCodec = proto3.makeMessageType("livekit.SubscribedCodec", () => [{
  no: 1,
  name: "codec",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "qualities",
  kind: "message",
  T: SubscribedQuality,
  repeated: !0
}]), SubscribedQualityUpdate = proto3.makeMessageType("livekit.SubscribedQualityUpdate", () => [{
  no: 1,
  name: "track_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "subscribed_qualities",
  kind: "message",
  T: SubscribedQuality,
  repeated: !0
}, {
  no: 3,
  name: "subscribed_codecs",
  kind: "message",
  T: SubscribedCodec,
  repeated: !0
}]), TrackPermission = proto3.makeMessageType("livekit.TrackPermission", () => [{
  no: 1,
  name: "participant_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "all_tracks",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 3,
  name: "track_sids",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 4,
  name: "participant_identity",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), SubscriptionPermission = proto3.makeMessageType("livekit.SubscriptionPermission", () => [{
  no: 1,
  name: "all_participants",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 2,
  name: "track_permissions",
  kind: "message",
  T: TrackPermission,
  repeated: !0
}]), SubscriptionPermissionUpdate = proto3.makeMessageType("livekit.SubscriptionPermissionUpdate", () => [{
  no: 1,
  name: "participant_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "track_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "allowed",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}]), SyncState = proto3.makeMessageType("livekit.SyncState", () => [{
  no: 1,
  name: "answer",
  kind: "message",
  T: SessionDescription
}, {
  no: 2,
  name: "subscription",
  kind: "message",
  T: UpdateSubscription
}, {
  no: 3,
  name: "publish_tracks",
  kind: "message",
  T: TrackPublishedResponse,
  repeated: !0
}, {
  no: 4,
  name: "data_channels",
  kind: "message",
  T: DataChannelInfo,
  repeated: !0
}, {
  no: 5,
  name: "offer",
  kind: "message",
  T: SessionDescription
}, {
  no: 6,
  name: "track_sids_disabled",
  kind: "scalar",
  T: 9,
  repeated: !0
}]), DataChannelInfo = proto3.makeMessageType("livekit.DataChannelInfo", () => [{
  no: 1,
  name: "label",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "id",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 3,
  name: "target",
  kind: "enum",
  T: proto3.getEnumType(SignalTarget)
}]), SimulateScenario = proto3.makeMessageType("livekit.SimulateScenario", () => [{
  no: 1,
  name: "speaker_update",
  kind: "scalar",
  T: 5,
  oneof: "scenario"
}, {
  no: 2,
  name: "node_failure",
  kind: "scalar",
  T: 8,
  oneof: "scenario"
}, {
  no: 3,
  name: "migration",
  kind: "scalar",
  T: 8,
  oneof: "scenario"
}, {
  no: 4,
  name: "server_leave",
  kind: "scalar",
  T: 8,
  oneof: "scenario"
}, {
  no: 5,
  name: "switch_candidate_protocol",
  kind: "enum",
  T: proto3.getEnumType(CandidateProtocol),
  oneof: "scenario"
}, {
  no: 6,
  name: "subscriber_bandwidth",
  kind: "scalar",
  T: 3,
  oneof: "scenario"
}, {
  no: 7,
  name: "disconnect_signal_on_resume",
  kind: "scalar",
  T: 8,
  oneof: "scenario"
}, {
  no: 8,
  name: "disconnect_signal_on_resume_no_messages",
  kind: "scalar",
  T: 8,
  oneof: "scenario"
}]), Ping = proto3.makeMessageType("livekit.Ping", () => [{
  no: 1,
  name: "timestamp",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 2,
  name: "rtt",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}]), Pong = proto3.makeMessageType("livekit.Pong", () => [{
  no: 1,
  name: "last_ping_timestamp",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 2,
  name: "timestamp",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}]), RegionSettings = proto3.makeMessageType("livekit.RegionSettings", () => [{
  no: 1,
  name: "regions",
  kind: "message",
  T: RegionInfo,
  repeated: !0
}]), RegionInfo = proto3.makeMessageType("livekit.RegionInfo", () => [{
  no: 1,
  name: "region",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "url",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "distance",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}]), SubscriptionResponse = proto3.makeMessageType("livekit.SubscriptionResponse", () => [{
  no: 1,
  name: "track_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "err",
  kind: "enum",
  T: proto3.getEnumType(SubscriptionError)
}]), IngressInput = proto3.makeEnum("livekit.IngressInput", [{
  no: 0,
  name: "RTMP_INPUT"
}, {
  no: 1,
  name: "WHIP_INPUT"
}, {
  no: 2,
  name: "URL_INPUT"
}]), IngressAudioEncodingPreset = proto3.makeEnum("livekit.IngressAudioEncodingPreset", [{
  no: 0,
  name: "OPUS_STEREO_96KBPS"
}, {
  no: 1,
  name: "OPUS_MONO_64KBS"
}]), IngressVideoEncodingPreset = proto3.makeEnum("livekit.IngressVideoEncodingPreset", [{
  no: 0,
  name: "H264_720P_30FPS_3_LAYERS"
}, {
  no: 1,
  name: "H264_1080P_30FPS_3_LAYERS"
}, {
  no: 2,
  name: "H264_540P_25FPS_2_LAYERS"
}, {
  no: 3,
  name: "H264_720P_30FPS_1_LAYER"
}, {
  no: 4,
  name: "H264_1080P_30FPS_1_LAYER"
}, {
  no: 5,
  name: "H264_720P_30FPS_3_LAYERS_HIGH_MOTION"
}, {
  no: 6,
  name: "H264_1080P_30FPS_3_LAYERS_HIGH_MOTION"
}, {
  no: 7,
  name: "H264_540P_25FPS_2_LAYERS_HIGH_MOTION"
}, {
  no: 8,
  name: "H264_720P_30FPS_1_LAYER_HIGH_MOTION"
}, {
  no: 9,
  name: "H264_1080P_30FPS_1_LAYER_HIGH_MOTION"
}]);
proto3.makeMessageType("livekit.CreateIngressRequest", () => [{
  no: 1,
  name: "input_type",
  kind: "enum",
  T: proto3.getEnumType(IngressInput)
}, {
  no: 9,
  name: "url",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "room_name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 4,
  name: "participant_identity",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "participant_name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 10,
  name: "participant_metadata",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 8,
  name: "bypass_transcoding",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 6,
  name: "audio",
  kind: "message",
  T: IngressAudioOptions
}, {
  no: 7,
  name: "video",
  kind: "message",
  T: IngressVideoOptions
}]);
const IngressAudioOptions = proto3.makeMessageType("livekit.IngressAudioOptions", () => [{
  no: 1,
  name: "name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "source",
  kind: "enum",
  T: proto3.getEnumType(TrackSource)
}, {
  no: 3,
  name: "preset",
  kind: "enum",
  T: proto3.getEnumType(IngressAudioEncodingPreset),
  oneof: "encoding_options"
}, {
  no: 4,
  name: "options",
  kind: "message",
  T: IngressAudioEncodingOptions,
  oneof: "encoding_options"
}]), IngressVideoOptions = proto3.makeMessageType("livekit.IngressVideoOptions", () => [{
  no: 1,
  name: "name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "source",
  kind: "enum",
  T: proto3.getEnumType(TrackSource)
}, {
  no: 3,
  name: "preset",
  kind: "enum",
  T: proto3.getEnumType(IngressVideoEncodingPreset),
  oneof: "encoding_options"
}, {
  no: 4,
  name: "options",
  kind: "message",
  T: IngressVideoEncodingOptions,
  oneof: "encoding_options"
}]), IngressAudioEncodingOptions = proto3.makeMessageType("livekit.IngressAudioEncodingOptions", () => [{
  no: 1,
  name: "audio_codec",
  kind: "enum",
  T: proto3.getEnumType(AudioCodec$1)
}, {
  no: 2,
  name: "bitrate",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 3,
  name: "disable_dtx",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 4,
  name: "channels",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}]), IngressVideoEncodingOptions = proto3.makeMessageType("livekit.IngressVideoEncodingOptions", () => [{
  no: 1,
  name: "video_codec",
  kind: "enum",
  T: proto3.getEnumType(VideoCodec$1)
}, {
  no: 2,
  name: "frame_rate",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}, {
  no: 3,
  name: "layers",
  kind: "message",
  T: VideoLayer,
  repeated: !0
}]), IngressInfo = proto3.makeMessageType("livekit.IngressInfo", () => [{
  no: 1,
  name: "ingress_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "stream_key",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 4,
  name: "url",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "input_type",
  kind: "enum",
  T: proto3.getEnumType(IngressInput)
}, {
  no: 13,
  name: "bypass_transcoding",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 6,
  name: "audio",
  kind: "message",
  T: IngressAudioOptions
}, {
  no: 7,
  name: "video",
  kind: "message",
  T: IngressVideoOptions
}, {
  no: 8,
  name: "room_name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 9,
  name: "participant_identity",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 10,
  name: "participant_name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 14,
  name: "participant_metadata",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 11,
  name: "reusable",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 12,
  name: "state",
  kind: "message",
  T: IngressState
}]), IngressState = proto3.makeMessageType("livekit.IngressState", () => [{
  no: 1,
  name: "status",
  kind: "enum",
  T: proto3.getEnumType(IngressState_Status)
}, {
  no: 2,
  name: "error",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "video",
  kind: "message",
  T: InputVideoState
}, {
  no: 4,
  name: "audio",
  kind: "message",
  T: InputAudioState
}, {
  no: 5,
  name: "room_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 7,
  name: "started_at",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 8,
  name: "ended_at",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 9,
  name: "resource_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 6,
  name: "tracks",
  kind: "message",
  T: TrackInfo,
  repeated: !0
}]), IngressState_Status = proto3.makeEnum("livekit.IngressState.Status", [{
  no: 0,
  name: "ENDPOINT_INACTIVE"
}, {
  no: 1,
  name: "ENDPOINT_BUFFERING"
}, {
  no: 2,
  name: "ENDPOINT_PUBLISHING"
}, {
  no: 3,
  name: "ENDPOINT_ERROR"
}, {
  no: 4,
  name: "ENDPOINT_COMPLETE"
}]), InputVideoState = proto3.makeMessageType("livekit.InputVideoState", () => [{
  no: 1,
  name: "mime_type",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "average_bitrate",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 3,
  name: "width",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 4,
  name: "height",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 5,
  name: "framerate",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}]), InputAudioState = proto3.makeMessageType("livekit.InputAudioState", () => [{
  no: 1,
  name: "mime_type",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "average_bitrate",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 3,
  name: "channels",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 4,
  name: "sample_rate",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}]);
proto3.makeMessageType("livekit.UpdateIngressRequest", () => [{
  no: 1,
  name: "ingress_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "room_name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 4,
  name: "participant_identity",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "participant_name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 9,
  name: "participant_metadata",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 8,
  name: "bypass_transcoding",
  kind: "scalar",
  T: 8,
  opt: !0
}, {
  no: 6,
  name: "audio",
  kind: "message",
  T: IngressAudioOptions
}, {
  no: 7,
  name: "video",
  kind: "message",
  T: IngressVideoOptions
}]);
proto3.makeMessageType("livekit.ListIngressRequest", () => [{
  no: 1,
  name: "room_name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "ingress_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
proto3.makeMessageType("livekit.ListIngressResponse", () => [{
  no: 1,
  name: "items",
  kind: "message",
  T: IngressInfo,
  repeated: !0
}]);
proto3.makeMessageType("livekit.DeleteIngressRequest", () => [{
  no: 1,
  name: "ingress_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
proto3.makeMessageType("livekit.WebhookEvent", () => [{
  no: 1,
  name: "event",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "room",
  kind: "message",
  T: Room$1
}, {
  no: 3,
  name: "participant",
  kind: "message",
  T: ParticipantInfo
}, {
  no: 9,
  name: "egress_info",
  kind: "message",
  T: EgressInfo
}, {
  no: 10,
  name: "ingress_info",
  kind: "message",
  T: IngressInfo
}, {
  no: 8,
  name: "track",
  kind: "message",
  T: TrackInfo
}, {
  no: 6,
  name: "id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 7,
  name: "created_at",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 11,
  name: "num_dropped",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}]);
proto3.makeMessageType("livekit.CreateSIPTrunkRequest", () => [{
  no: 1,
  name: "inbound_addresses",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 2,
  name: "outbound_address",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "outbound_number",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 4,
  name: "inbound_numbers_regex",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 9,
  name: "inbound_numbers",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 5,
  name: "inbound_username",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 6,
  name: "inbound_password",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 7,
  name: "outbound_username",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 8,
  name: "outbound_password",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
const SIPTrunkInfo = proto3.makeMessageType("livekit.SIPTrunkInfo", () => [{
  no: 1,
  name: "sip_trunk_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "inbound_addresses",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 3,
  name: "outbound_address",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 4,
  name: "outbound_number",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "inbound_numbers_regex",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 10,
  name: "inbound_numbers",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 6,
  name: "inbound_username",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 7,
  name: "inbound_password",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 8,
  name: "outbound_username",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 9,
  name: "outbound_password",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
proto3.makeMessageType("livekit.ListSIPTrunkRequest", []);
proto3.makeMessageType("livekit.ListSIPTrunkResponse", () => [{
  no: 1,
  name: "items",
  kind: "message",
  T: SIPTrunkInfo,
  repeated: !0
}]);
proto3.makeMessageType("livekit.DeleteSIPTrunkRequest", () => [{
  no: 1,
  name: "sip_trunk_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
const SIPDispatchRuleDirect = proto3.makeMessageType("livekit.SIPDispatchRuleDirect", () => [{
  no: 1,
  name: "room_name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "pin",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), SIPDispatchRuleIndividual = proto3.makeMessageType("livekit.SIPDispatchRuleIndividual", () => [{
  no: 1,
  name: "room_prefix",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "pin",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), SIPDispatchRule = proto3.makeMessageType("livekit.SIPDispatchRule", () => [{
  no: 1,
  name: "dispatch_rule_direct",
  kind: "message",
  T: SIPDispatchRuleDirect,
  oneof: "rule"
}, {
  no: 2,
  name: "dispatch_rule_individual",
  kind: "message",
  T: SIPDispatchRuleIndividual,
  oneof: "rule"
}]);
proto3.makeMessageType("livekit.CreateSIPDispatchRuleRequest", () => [{
  no: 1,
  name: "rule",
  kind: "message",
  T: SIPDispatchRule
}, {
  no: 2,
  name: "trunk_ids",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 3,
  name: "hide_phone_number",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}]);
const SIPDispatchRuleInfo = proto3.makeMessageType("livekit.SIPDispatchRuleInfo", () => [{
  no: 1,
  name: "sip_dispatch_rule_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "rule",
  kind: "message",
  T: SIPDispatchRule
}, {
  no: 3,
  name: "trunk_ids",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 4,
  name: "hide_phone_number",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}]);
proto3.makeMessageType("livekit.ListSIPDispatchRuleRequest", []);
proto3.makeMessageType("livekit.ListSIPDispatchRuleResponse", () => [{
  no: 1,
  name: "items",
  kind: "message",
  T: SIPDispatchRuleInfo,
  repeated: !0
}]);
proto3.makeMessageType("livekit.DeleteSIPDispatchRuleRequest", () => [{
  no: 1,
  name: "sip_dispatch_rule_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
proto3.makeMessageType("livekit.CreateSIPParticipantRequest", () => [{
  no: 1,
  name: "sip_trunk_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "sip_call_to",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "room_name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 4,
  name: "participant_identity",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
proto3.makeMessageType("livekit.SIPParticipantInfo", () => [{
  no: 1,
  name: "participant_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "participant_identity",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "room_name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global$1 < "u" ? global$1 : typeof self < "u" ? self : {};
function getDefaultExportFromCjs(a) {
  return a && a.__esModule && Object.prototype.hasOwnProperty.call(a, "default") ? a.default : a;
}
var loglevel$1 = { exports: {} };
(function(a) {
  (function(u, c) {
    a.exports ? a.exports = c() : u.log = c();
  })(commonjsGlobal, function() {
    var u = function() {
    }, c = "undefined", l = typeof window !== c && typeof window.navigator !== c && /Trident\/|MSIE /.test(window.navigator.userAgent), v = ["trace", "debug", "info", "warn", "error"];
    function p(ne, Q) {
      var ae = ne[Q];
      if (typeof ae.bind == "function")
        return ae.bind(ne);
      try {
        return Function.prototype.bind.call(ae, ne);
      } catch {
        return function() {
          return Function.prototype.apply.apply(ae, [ne, arguments]);
        };
      }
    }
    function _() {
      console.log && (console.log.apply ? console.log.apply(console, arguments) : Function.prototype.apply.apply(console.log, [console, arguments])), console.trace && console.trace();
    }
    function k(ne) {
      return ne === "debug" && (ne = "log"), typeof console === c ? !1 : ne === "trace" && l ? _ : console[ne] !== void 0 ? p(console, ne) : console.log !== void 0 ? p(console, "log") : u;
    }
    function O(ne, Q) {
      for (var ae = 0; ae < v.length; ae++) {
        var j = v[ae];
        this[j] = ae < ne ? u : this.methodFactory(j, ne, Q);
      }
      this.log = this.debug;
    }
    function D(ne, Q, ae) {
      return function() {
        typeof console !== c && (O.call(this, Q, ae), this[ne].apply(this, arguments));
      };
    }
    function F(ne, Q, ae) {
      return k(ne) || D.apply(this, arguments);
    }
    function H(ne, Q, ae) {
      var j = this, ue;
      Q = Q ?? "WARN";
      var he = "loglevel";
      typeof ne == "string" ? he += ":" + ne : typeof ne == "symbol" && (he = void 0);
      function fe(q) {
        var z = (v[q] || "silent").toUpperCase();
        if (!(typeof window === c || !he)) {
          try {
            window.localStorage[he] = z;
            return;
          } catch {
          }
          try {
            window.document.cookie = encodeURIComponent(he) + "=" + z + ";";
          } catch {
          }
        }
      }
      function be() {
        var q;
        if (!(typeof window === c || !he)) {
          try {
            q = window.localStorage[he];
          } catch {
          }
          if (typeof q === c)
            try {
              var z = window.document.cookie, P = z.indexOf(encodeURIComponent(he) + "=");
              P !== -1 && (q = /^([^;]+)/.exec(z.slice(P))[1]);
            } catch {
            }
          return j.levels[q] === void 0 && (q = void 0), q;
        }
      }
      function ke() {
        if (!(typeof window === c || !he)) {
          try {
            window.localStorage.removeItem(he);
            return;
          } catch {
          }
          try {
            window.document.cookie = encodeURIComponent(he) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
          } catch {
          }
        }
      }
      j.name = ne, j.levels = {
        TRACE: 0,
        DEBUG: 1,
        INFO: 2,
        WARN: 3,
        ERROR: 4,
        SILENT: 5
      }, j.methodFactory = ae || F, j.getLevel = function() {
        return ue;
      }, j.setLevel = function(q, z) {
        if (typeof q == "string" && j.levels[q.toUpperCase()] !== void 0 && (q = j.levels[q.toUpperCase()]), typeof q == "number" && q >= 0 && q <= j.levels.SILENT) {
          if (ue = q, z !== !1 && fe(q), O.call(j, q, ne), typeof console === c && q < j.levels.SILENT)
            return "No console available for logging";
        } else
          throw "log.setLevel() called with invalid level: " + q;
      }, j.setDefaultLevel = function(q) {
        Q = q, be() || j.setLevel(q, !1);
      }, j.resetLevel = function() {
        j.setLevel(Q, !1), ke();
      }, j.enableAll = function(q) {
        j.setLevel(j.levels.TRACE, q);
      }, j.disableAll = function(q) {
        j.setLevel(j.levels.SILENT, q);
      };
      var Te = be();
      Te == null && (Te = Q), j.setLevel(Te, !1);
    }
    var Z = new H(), ee = {};
    Z.getLogger = function(Q) {
      if (typeof Q != "symbol" && typeof Q != "string" || Q === "")
        throw new TypeError("You must supply a name when creating a logger.");
      var ae = ee[Q];
      return ae || (ae = ee[Q] = new H(Q, Z.getLevel(), Z.methodFactory)), ae;
    };
    var X = typeof window !== c ? window.log : void 0;
    return Z.noConflict = function() {
      return typeof window !== c && window.log === Z && (window.log = X), Z;
    }, Z.getLoggers = function() {
      return ee;
    }, Z.default = Z, Z;
  });
})(loglevel$1);
var loglevelExports$1 = loglevel$1.exports, LogLevel;
(function(a) {
  a[a.trace = 0] = "trace", a[a.debug = 1] = "debug", a[a.info = 2] = "info", a[a.warn = 3] = "warn", a[a.error = 4] = "error", a[a.silent = 5] = "silent";
})(LogLevel || (LogLevel = {}));
var LoggerNames;
(function(a) {
  a.Default = "livekit", a.Room = "livekit-room", a.Participant = "livekit-participant", a.Track = "livekit-track", a.Publication = "livekit-track-publication", a.Engine = "livekit-engine", a.Signal = "livekit-signal", a.PCManager = "livekit-pc-manager", a.PCTransport = "livekit-pc-transport", a.E2EE = "lk-e2ee";
})(LoggerNames || (LoggerNames = {}));
let livekitLogger = loglevelExports$1.getLogger("livekit");
const livekitLoggers = Object.values(LoggerNames).map((a) => loglevelExports$1.getLogger(a));
livekitLogger.setDefaultLevel(LogLevel.info);
function getLogger(a) {
  const u = loglevelExports$1.getLogger(a);
  return u.setDefaultLevel(livekitLogger.getLevel()), u;
}
function setLogLevel(a, u) {
  u && loglevelExports$1.getLogger(u).setLevel(a);
  for (const c of livekitLoggers)
    c.setLevel(a);
}
const workerLogger = loglevelExports$1.getLogger("lk-e2ee"), maxRetryDelay = 7e3, DEFAULT_RETRY_DELAYS_IN_MS = [0, 300, 2 * 2 * 300, 3 * 3 * 300, 4 * 4 * 300, maxRetryDelay, maxRetryDelay, maxRetryDelay, maxRetryDelay, maxRetryDelay];
class DefaultReconnectPolicy {
  constructor(u) {
    this._retryDelays = u !== void 0 ? [...u] : DEFAULT_RETRY_DELAYS_IN_MS;
  }
  nextRetryDelayInMs(u) {
    if (u.retryCount >= this._retryDelays.length)
      return null;
    const c = this._retryDelays[u.retryCount];
    return u.retryCount <= 1 ? c : c + Math.random() * 1e3;
  }
}
function __awaiter$3(a, u, c, l) {
  function v(p) {
    return p instanceof c ? p : new c(function(_) {
      _(p);
    });
  }
  return new (c || (c = Promise))(function(p, _) {
    function k(F) {
      try {
        D(l.next(F));
      } catch (H) {
        _(H);
      }
    }
    function O(F) {
      try {
        D(l.throw(F));
      } catch (H) {
        _(H);
      }
    }
    function D(F) {
      F.done ? p(F.value) : v(F.value).then(k, O);
    }
    D((l = l.apply(a, u || [])).next());
  });
}
function __values(a) {
  var u = typeof Symbol == "function" && Symbol.iterator, c = u && a[u], l = 0;
  if (c)
    return c.call(a);
  if (a && typeof a.length == "number")
    return {
      next: function() {
        return a && l >= a.length && (a = void 0), { value: a && a[l++], done: !a };
      }
    };
  throw new TypeError(u ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __asyncValues(a) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var u = a[Symbol.asyncIterator], c;
  return u ? u.call(a) : (a = typeof __values == "function" ? __values(a) : a[Symbol.iterator](), c = {}, l("next"), l("throw"), l("return"), c[Symbol.asyncIterator] = function() {
    return this;
  }, c);
  function l(p) {
    c[p] = a[p] && function(_) {
      return new Promise(function(k, O) {
        _ = a[p](_), v(k, O, _.done, _.value);
      });
    };
  }
  function v(p, _, k, O) {
    Promise.resolve(O).then(function(D) {
      p({ value: D, done: k });
    }, _);
  }
}
typeof SuppressedError == "function" && SuppressedError;
var events$2 = { exports: {} }, R$1 = typeof Reflect == "object" ? Reflect : null, ReflectApply$1 = R$1 && typeof R$1.apply == "function" ? R$1.apply : function a(u, c, l) {
  return Function.prototype.apply.call(u, c, l);
}, ReflectOwnKeys$1;
R$1 && typeof R$1.ownKeys == "function" ? ReflectOwnKeys$1 = R$1.ownKeys : Object.getOwnPropertySymbols ? ReflectOwnKeys$1 = function(u) {
  return Object.getOwnPropertyNames(u).concat(Object.getOwnPropertySymbols(u));
} : ReflectOwnKeys$1 = function(u) {
  return Object.getOwnPropertyNames(u);
};
function ProcessEmitWarning$1(a) {
  console && console.warn && console.warn(a);
}
var NumberIsNaN$1 = Number.isNaN || function a(u) {
  return u !== u;
};
function EventEmitter$1() {
  EventEmitter$1.init.call(this);
}
events$2.exports = EventEmitter$1;
events$2.exports.once = once$7;
EventEmitter$1.EventEmitter = EventEmitter$1;
EventEmitter$1.prototype._events = void 0;
EventEmitter$1.prototype._eventsCount = 0;
EventEmitter$1.prototype._maxListeners = void 0;
var defaultMaxListeners$1 = 10;
function checkListener$1(a) {
  if (typeof a != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof a);
}
Object.defineProperty(EventEmitter$1, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return defaultMaxListeners$1;
  },
  set: function(a) {
    if (typeof a != "number" || a < 0 || NumberIsNaN$1(a))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + a + ".");
    defaultMaxListeners$1 = a;
  }
});
EventEmitter$1.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
EventEmitter$1.prototype.setMaxListeners = function a(u) {
  if (typeof u != "number" || u < 0 || NumberIsNaN$1(u))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + u + ".");
  return this._maxListeners = u, this;
};
function _getMaxListeners$1(a) {
  return a._maxListeners === void 0 ? EventEmitter$1.defaultMaxListeners : a._maxListeners;
}
EventEmitter$1.prototype.getMaxListeners = function a() {
  return _getMaxListeners$1(this);
};
EventEmitter$1.prototype.emit = function a(u) {
  for (var c = [], l = 1; l < arguments.length; l++)
    c.push(arguments[l]);
  var v = u === "error", p = this._events;
  if (p !== void 0)
    v = v && p.error === void 0;
  else if (!v)
    return !1;
  if (v) {
    var _;
    if (c.length > 0 && (_ = c[0]), _ instanceof Error)
      throw _;
    var k = new Error("Unhandled error." + (_ ? " (" + _.message + ")" : ""));
    throw k.context = _, k;
  }
  var O = p[u];
  if (O === void 0)
    return !1;
  if (typeof O == "function")
    ReflectApply$1(O, this, c);
  else
    for (var D = O.length, F = arrayClone$1(O, D), l = 0; l < D; ++l)
      ReflectApply$1(F[l], this, c);
  return !0;
};
function _addListener$1(a, u, c, l) {
  var v, p, _;
  if (checkListener$1(c), p = a._events, p === void 0 ? (p = a._events = /* @__PURE__ */ Object.create(null), a._eventsCount = 0) : (p.newListener !== void 0 && (a.emit("newListener", u, c.listener ? c.listener : c), p = a._events), _ = p[u]), _ === void 0)
    _ = p[u] = c, ++a._eventsCount;
  else if (typeof _ == "function" ? _ = p[u] = l ? [c, _] : [_, c] : l ? _.unshift(c) : _.push(c), v = _getMaxListeners$1(a), v > 0 && _.length > v && !_.warned) {
    _.warned = !0;
    var k = new Error("Possible EventEmitter memory leak detected. " + _.length + " " + String(u) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    k.name = "MaxListenersExceededWarning", k.emitter = a, k.type = u, k.count = _.length, ProcessEmitWarning$1(k);
  }
  return a;
}
EventEmitter$1.prototype.addListener = function a(u, c) {
  return _addListener$1(this, u, c, !1);
};
EventEmitter$1.prototype.on = EventEmitter$1.prototype.addListener;
EventEmitter$1.prototype.prependListener = function a(u, c) {
  return _addListener$1(this, u, c, !0);
};
function onceWrapper$1() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function _onceWrap$1(a, u, c) {
  var l = {
    fired: !1,
    wrapFn: void 0,
    target: a,
    type: u,
    listener: c
  }, v = onceWrapper$1.bind(l);
  return v.listener = c, l.wrapFn = v, v;
}
EventEmitter$1.prototype.once = function a(u, c) {
  return checkListener$1(c), this.on(u, _onceWrap$1(this, u, c)), this;
};
EventEmitter$1.prototype.prependOnceListener = function a(u, c) {
  return checkListener$1(c), this.prependListener(u, _onceWrap$1(this, u, c)), this;
};
EventEmitter$1.prototype.removeListener = function a(u, c) {
  var l, v, p, _, k;
  if (checkListener$1(c), v = this._events, v === void 0)
    return this;
  if (l = v[u], l === void 0)
    return this;
  if (l === c || l.listener === c)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete v[u], v.removeListener && this.emit("removeListener", u, l.listener || c));
  else if (typeof l != "function") {
    for (p = -1, _ = l.length - 1; _ >= 0; _--)
      if (l[_] === c || l[_].listener === c) {
        k = l[_].listener, p = _;
        break;
      }
    if (p < 0)
      return this;
    p === 0 ? l.shift() : spliceOne$1(l, p), l.length === 1 && (v[u] = l[0]), v.removeListener !== void 0 && this.emit("removeListener", u, k || c);
  }
  return this;
};
EventEmitter$1.prototype.off = EventEmitter$1.prototype.removeListener;
EventEmitter$1.prototype.removeAllListeners = function a(u) {
  var c, l, v;
  if (l = this._events, l === void 0)
    return this;
  if (l.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : l[u] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete l[u]), this;
  if (arguments.length === 0) {
    var p = Object.keys(l), _;
    for (v = 0; v < p.length; ++v)
      _ = p[v], _ !== "removeListener" && this.removeAllListeners(_);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (c = l[u], typeof c == "function")
    this.removeListener(u, c);
  else if (c !== void 0)
    for (v = c.length - 1; v >= 0; v--)
      this.removeListener(u, c[v]);
  return this;
};
function _listeners$1(a, u, c) {
  var l = a._events;
  if (l === void 0)
    return [];
  var v = l[u];
  return v === void 0 ? [] : typeof v == "function" ? c ? [v.listener || v] : [v] : c ? unwrapListeners$1(v) : arrayClone$1(v, v.length);
}
EventEmitter$1.prototype.listeners = function a(u) {
  return _listeners$1(this, u, !0);
};
EventEmitter$1.prototype.rawListeners = function a(u) {
  return _listeners$1(this, u, !1);
};
EventEmitter$1.listenerCount = function(a, u) {
  return typeof a.listenerCount == "function" ? a.listenerCount(u) : listenerCount$1.call(a, u);
};
EventEmitter$1.prototype.listenerCount = listenerCount$1;
function listenerCount$1(a) {
  var u = this._events;
  if (u !== void 0) {
    var c = u[a];
    if (typeof c == "function")
      return 1;
    if (c !== void 0)
      return c.length;
  }
  return 0;
}
EventEmitter$1.prototype.eventNames = function a() {
  return this._eventsCount > 0 ? ReflectOwnKeys$1(this._events) : [];
};
function arrayClone$1(a, u) {
  for (var c = new Array(u), l = 0; l < u; ++l)
    c[l] = a[l];
  return c;
}
function spliceOne$1(a, u) {
  for (; u + 1 < a.length; u++)
    a[u] = a[u + 1];
  a.pop();
}
function unwrapListeners$1(a) {
  for (var u = new Array(a.length), c = 0; c < u.length; ++c)
    u[c] = a[c].listener || a[c];
  return u;
}
function once$7(a, u) {
  return new Promise(function(c, l) {
    function v(_) {
      a.removeListener(u, p), l(_);
    }
    function p() {
      typeof a.removeListener == "function" && a.removeListener("error", v), c([].slice.call(arguments));
    }
    eventTargetAgnosticAddListener$1(a, u, p, {
      once: !0
    }), u !== "error" && addErrorHandlerIfEventEmitter$1(a, v, {
      once: !0
    });
  });
}
function addErrorHandlerIfEventEmitter$1(a, u, c) {
  typeof a.on == "function" && eventTargetAgnosticAddListener$1(a, "error", u, c);
}
function eventTargetAgnosticAddListener$1(a, u, c, l) {
  if (typeof a.on == "function")
    l.once ? a.once(u, c) : a.on(u, c);
  else if (typeof a.addEventListener == "function")
    a.addEventListener(u, function v(p) {
      l.once && a.removeEventListener(u, v), c(p);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof a);
}
var eventsExports$1 = events$2.exports;
let logDisabled_ = !0, deprecationWarnings_ = !0;
function extractVersion(a, u, c) {
  const l = a.match(u);
  return l && l.length >= c && parseInt(l[c], 10);
}
function wrapPeerConnectionEvent(a, u, c) {
  if (!a.RTCPeerConnection)
    return;
  const l = a.RTCPeerConnection.prototype, v = l.addEventListener;
  l.addEventListener = function(_, k) {
    if (_ !== u)
      return v.apply(this, arguments);
    const O = (D) => {
      const F = c(D);
      F && (k.handleEvent ? k.handleEvent(F) : k(F));
    };
    return this._eventMap = this._eventMap || {}, this._eventMap[u] || (this._eventMap[u] = /* @__PURE__ */ new Map()), this._eventMap[u].set(k, O), v.apply(this, [_, O]);
  };
  const p = l.removeEventListener;
  l.removeEventListener = function(_, k) {
    if (_ !== u || !this._eventMap || !this._eventMap[u])
      return p.apply(this, arguments);
    if (!this._eventMap[u].has(k))
      return p.apply(this, arguments);
    const O = this._eventMap[u].get(k);
    return this._eventMap[u].delete(k), this._eventMap[u].size === 0 && delete this._eventMap[u], Object.keys(this._eventMap).length === 0 && delete this._eventMap, p.apply(this, [_, O]);
  }, Object.defineProperty(l, "on" + u, {
    get() {
      return this["_on" + u];
    },
    set(_) {
      this["_on" + u] && (this.removeEventListener(u, this["_on" + u]), delete this["_on" + u]), _ && this.addEventListener(u, this["_on" + u] = _);
    },
    enumerable: !0,
    configurable: !0
  });
}
function disableLog(a) {
  return typeof a != "boolean" ? new Error("Argument type: " + typeof a + ". Please use a boolean.") : (logDisabled_ = a, a ? "adapter.js logging disabled" : "adapter.js logging enabled");
}
function disableWarnings(a) {
  return typeof a != "boolean" ? new Error("Argument type: " + typeof a + ". Please use a boolean.") : (deprecationWarnings_ = !a, "adapter.js deprecation warnings " + (a ? "disabled" : "enabled"));
}
function log$1() {
  if (typeof window == "object") {
    if (logDisabled_)
      return;
    typeof console < "u" && typeof console.log == "function" && console.log.apply(console, arguments);
  }
}
function deprecated(a, u) {
  deprecationWarnings_ && console.warn(a + " is deprecated, please use " + u + " instead.");
}
function detectBrowser(a) {
  const u = {
    browser: null,
    version: null
  };
  if (typeof a > "u" || !a.navigator || !a.navigator.userAgent)
    return u.browser = "Not a browser.", u;
  const {
    navigator: c
  } = a;
  if (c.mozGetUserMedia)
    u.browser = "firefox", u.version = extractVersion(c.userAgent, /Firefox\/(\d+)\./, 1);
  else if (c.webkitGetUserMedia || a.isSecureContext === !1 && a.webkitRTCPeerConnection)
    u.browser = "chrome", u.version = extractVersion(c.userAgent, /Chrom(e|ium)\/(\d+)\./, 2);
  else if (a.RTCPeerConnection && c.userAgent.match(/AppleWebKit\/(\d+)\./))
    u.browser = "safari", u.version = extractVersion(c.userAgent, /AppleWebKit\/(\d+)\./, 1), u.supportsUnifiedPlan = a.RTCRtpTransceiver && "currentDirection" in a.RTCRtpTransceiver.prototype;
  else
    return u.browser = "Not a supported browser.", u;
  return u;
}
function isObject$7(a) {
  return Object.prototype.toString.call(a) === "[object Object]";
}
function compactObject(a) {
  return isObject$7(a) ? Object.keys(a).reduce(function(u, c) {
    const l = isObject$7(a[c]), v = l ? compactObject(a[c]) : a[c], p = l && !Object.keys(v).length;
    return v === void 0 || p ? u : Object.assign(u, {
      [c]: v
    });
  }, {}) : a;
}
function walkStats(a, u, c) {
  !u || c.has(u.id) || (c.set(u.id, u), Object.keys(u).forEach((l) => {
    l.endsWith("Id") ? walkStats(a, a.get(u[l]), c) : l.endsWith("Ids") && u[l].forEach((v) => {
      walkStats(a, a.get(v), c);
    });
  }));
}
function filterStats(a, u, c) {
  const l = c ? "outbound-rtp" : "inbound-rtp", v = /* @__PURE__ */ new Map();
  if (u === null)
    return v;
  const p = [];
  return a.forEach((_) => {
    _.type === "track" && _.trackIdentifier === u.id && p.push(_);
  }), p.forEach((_) => {
    a.forEach((k) => {
      k.type === l && k.trackId === _.id && walkStats(a, k, v);
    });
  }), v;
}
const logging = log$1;
function shimGetUserMedia$2(a, u) {
  const c = a && a.navigator;
  if (!c.mediaDevices)
    return;
  const l = function(k) {
    if (typeof k != "object" || k.mandatory || k.optional)
      return k;
    const O = {};
    return Object.keys(k).forEach((D) => {
      if (D === "require" || D === "advanced" || D === "mediaSource")
        return;
      const F = typeof k[D] == "object" ? k[D] : {
        ideal: k[D]
      };
      F.exact !== void 0 && typeof F.exact == "number" && (F.min = F.max = F.exact);
      const H = function(Z, ee) {
        return Z ? Z + ee.charAt(0).toUpperCase() + ee.slice(1) : ee === "deviceId" ? "sourceId" : ee;
      };
      if (F.ideal !== void 0) {
        O.optional = O.optional || [];
        let Z = {};
        typeof F.ideal == "number" ? (Z[H("min", D)] = F.ideal, O.optional.push(Z), Z = {}, Z[H("max", D)] = F.ideal, O.optional.push(Z)) : (Z[H("", D)] = F.ideal, O.optional.push(Z));
      }
      F.exact !== void 0 && typeof F.exact != "number" ? (O.mandatory = O.mandatory || {}, O.mandatory[H("", D)] = F.exact) : ["min", "max"].forEach((Z) => {
        F[Z] !== void 0 && (O.mandatory = O.mandatory || {}, O.mandatory[H(Z, D)] = F[Z]);
      });
    }), k.advanced && (O.optional = (O.optional || []).concat(k.advanced)), O;
  }, v = function(k, O) {
    if (u.version >= 61)
      return O(k);
    if (k = JSON.parse(JSON.stringify(k)), k && typeof k.audio == "object") {
      const D = function(F, H, Z) {
        H in F && !(Z in F) && (F[Z] = F[H], delete F[H]);
      };
      k = JSON.parse(JSON.stringify(k)), D(k.audio, "autoGainControl", "googAutoGainControl"), D(k.audio, "noiseSuppression", "googNoiseSuppression"), k.audio = l(k.audio);
    }
    if (k && typeof k.video == "object") {
      let D = k.video.facingMode;
      D = D && (typeof D == "object" ? D : {
        ideal: D
      });
      const F = u.version < 66;
      if (D && (D.exact === "user" || D.exact === "environment" || D.ideal === "user" || D.ideal === "environment") && !(c.mediaDevices.getSupportedConstraints && c.mediaDevices.getSupportedConstraints().facingMode && !F)) {
        delete k.video.facingMode;
        let H;
        if (D.exact === "environment" || D.ideal === "environment" ? H = ["back", "rear"] : (D.exact === "user" || D.ideal === "user") && (H = ["front"]), H)
          return c.mediaDevices.enumerateDevices().then((Z) => {
            Z = Z.filter((X) => X.kind === "videoinput");
            let ee = Z.find((X) => H.some((ne) => X.label.toLowerCase().includes(ne)));
            return !ee && Z.length && H.includes("back") && (ee = Z[Z.length - 1]), ee && (k.video.deviceId = D.exact ? {
              exact: ee.deviceId
            } : {
              ideal: ee.deviceId
            }), k.video = l(k.video), logging("chrome: " + JSON.stringify(k)), O(k);
          });
      }
      k.video = l(k.video);
    }
    return logging("chrome: " + JSON.stringify(k)), O(k);
  }, p = function(k) {
    return u.version >= 64 ? k : {
      name: {
        PermissionDeniedError: "NotAllowedError",
        PermissionDismissedError: "NotAllowedError",
        InvalidStateError: "NotAllowedError",
        DevicesNotFoundError: "NotFoundError",
        ConstraintNotSatisfiedError: "OverconstrainedError",
        TrackStartError: "NotReadableError",
        MediaDeviceFailedDueToShutdown: "NotAllowedError",
        MediaDeviceKillSwitchOn: "NotAllowedError",
        TabCaptureError: "AbortError",
        ScreenCaptureError: "AbortError",
        DeviceCaptureError: "AbortError"
      }[k.name] || k.name,
      message: k.message,
      constraint: k.constraint || k.constraintName,
      toString() {
        return this.name + (this.message && ": ") + this.message;
      }
    };
  }, _ = function(k, O, D) {
    v(k, (F) => {
      c.webkitGetUserMedia(F, O, (H) => {
        D && D(p(H));
      });
    });
  };
  if (c.getUserMedia = _.bind(c), c.mediaDevices.getUserMedia) {
    const k = c.mediaDevices.getUserMedia.bind(c.mediaDevices);
    c.mediaDevices.getUserMedia = function(O) {
      return v(O, (D) => k(D).then((F) => {
        if (D.audio && !F.getAudioTracks().length || D.video && !F.getVideoTracks().length)
          throw F.getTracks().forEach((H) => {
            H.stop();
          }), new DOMException("", "NotFoundError");
        return F;
      }, (F) => Promise.reject(p(F))));
    };
  }
}
function shimGetDisplayMedia$1(a, u) {
  if (!(a.navigator.mediaDevices && "getDisplayMedia" in a.navigator.mediaDevices) && a.navigator.mediaDevices) {
    if (typeof u != "function") {
      console.error("shimGetDisplayMedia: getSourceId argument is not a function");
      return;
    }
    a.navigator.mediaDevices.getDisplayMedia = function(l) {
      return u(l).then((v) => {
        const p = l.video && l.video.width, _ = l.video && l.video.height, k = l.video && l.video.frameRate;
        return l.video = {
          mandatory: {
            chromeMediaSource: "desktop",
            chromeMediaSourceId: v,
            maxFrameRate: k || 3
          }
        }, p && (l.video.mandatory.maxWidth = p), _ && (l.video.mandatory.maxHeight = _), a.navigator.mediaDevices.getUserMedia(l);
      });
    };
  }
}
function shimMediaStream(a) {
  a.MediaStream = a.MediaStream || a.webkitMediaStream;
}
function shimOnTrack$1(a) {
  if (typeof a == "object" && a.RTCPeerConnection && !("ontrack" in a.RTCPeerConnection.prototype)) {
    Object.defineProperty(a.RTCPeerConnection.prototype, "ontrack", {
      get() {
        return this._ontrack;
      },
      set(c) {
        this._ontrack && this.removeEventListener("track", this._ontrack), this.addEventListener("track", this._ontrack = c);
      },
      enumerable: !0,
      configurable: !0
    });
    const u = a.RTCPeerConnection.prototype.setRemoteDescription;
    a.RTCPeerConnection.prototype.setRemoteDescription = function() {
      return this._ontrackpoly || (this._ontrackpoly = (l) => {
        l.stream.addEventListener("addtrack", (v) => {
          let p;
          a.RTCPeerConnection.prototype.getReceivers ? p = this.getReceivers().find((k) => k.track && k.track.id === v.track.id) : p = {
            track: v.track
          };
          const _ = new Event("track");
          _.track = v.track, _.receiver = p, _.transceiver = {
            receiver: p
          }, _.streams = [l.stream], this.dispatchEvent(_);
        }), l.stream.getTracks().forEach((v) => {
          let p;
          a.RTCPeerConnection.prototype.getReceivers ? p = this.getReceivers().find((k) => k.track && k.track.id === v.id) : p = {
            track: v
          };
          const _ = new Event("track");
          _.track = v, _.receiver = p, _.transceiver = {
            receiver: p
          }, _.streams = [l.stream], this.dispatchEvent(_);
        });
      }, this.addEventListener("addstream", this._ontrackpoly)), u.apply(this, arguments);
    };
  } else
    wrapPeerConnectionEvent(a, "track", (u) => (u.transceiver || Object.defineProperty(u, "transceiver", {
      value: {
        receiver: u.receiver
      }
    }), u));
}
function shimGetSendersWithDtmf(a) {
  if (typeof a == "object" && a.RTCPeerConnection && !("getSenders" in a.RTCPeerConnection.prototype) && "createDTMFSender" in a.RTCPeerConnection.prototype) {
    const u = function(v, p) {
      return {
        track: p,
        get dtmf() {
          return this._dtmf === void 0 && (p.kind === "audio" ? this._dtmf = v.createDTMFSender(p) : this._dtmf = null), this._dtmf;
        },
        _pc: v
      };
    };
    if (!a.RTCPeerConnection.prototype.getSenders) {
      a.RTCPeerConnection.prototype.getSenders = function() {
        return this._senders = this._senders || [], this._senders.slice();
      };
      const v = a.RTCPeerConnection.prototype.addTrack;
      a.RTCPeerConnection.prototype.addTrack = function(k, O) {
        let D = v.apply(this, arguments);
        return D || (D = u(this, k), this._senders.push(D)), D;
      };
      const p = a.RTCPeerConnection.prototype.removeTrack;
      a.RTCPeerConnection.prototype.removeTrack = function(k) {
        p.apply(this, arguments);
        const O = this._senders.indexOf(k);
        O !== -1 && this._senders.splice(O, 1);
      };
    }
    const c = a.RTCPeerConnection.prototype.addStream;
    a.RTCPeerConnection.prototype.addStream = function(p) {
      this._senders = this._senders || [], c.apply(this, [p]), p.getTracks().forEach((_) => {
        this._senders.push(u(this, _));
      });
    };
    const l = a.RTCPeerConnection.prototype.removeStream;
    a.RTCPeerConnection.prototype.removeStream = function(p) {
      this._senders = this._senders || [], l.apply(this, [p]), p.getTracks().forEach((_) => {
        const k = this._senders.find((O) => O.track === _);
        k && this._senders.splice(this._senders.indexOf(k), 1);
      });
    };
  } else if (typeof a == "object" && a.RTCPeerConnection && "getSenders" in a.RTCPeerConnection.prototype && "createDTMFSender" in a.RTCPeerConnection.prototype && a.RTCRtpSender && !("dtmf" in a.RTCRtpSender.prototype)) {
    const u = a.RTCPeerConnection.prototype.getSenders;
    a.RTCPeerConnection.prototype.getSenders = function() {
      const l = u.apply(this, []);
      return l.forEach((v) => v._pc = this), l;
    }, Object.defineProperty(a.RTCRtpSender.prototype, "dtmf", {
      get() {
        return this._dtmf === void 0 && (this.track.kind === "audio" ? this._dtmf = this._pc.createDTMFSender(this.track) : this._dtmf = null), this._dtmf;
      }
    });
  }
}
function shimGetStats(a) {
  if (!a.RTCPeerConnection)
    return;
  const u = a.RTCPeerConnection.prototype.getStats;
  a.RTCPeerConnection.prototype.getStats = function() {
    const [l, v, p] = arguments;
    if (arguments.length > 0 && typeof l == "function")
      return u.apply(this, arguments);
    if (u.length === 0 && (arguments.length === 0 || typeof l != "function"))
      return u.apply(this, []);
    const _ = function(O) {
      const D = {};
      return O.result().forEach((H) => {
        const Z = {
          id: H.id,
          timestamp: H.timestamp,
          type: {
            localcandidate: "local-candidate",
            remotecandidate: "remote-candidate"
          }[H.type] || H.type
        };
        H.names().forEach((ee) => {
          Z[ee] = H.stat(ee);
        }), D[Z.id] = Z;
      }), D;
    }, k = function(O) {
      return new Map(Object.keys(O).map((D) => [D, O[D]]));
    };
    if (arguments.length >= 2) {
      const O = function(D) {
        v(k(_(D)));
      };
      return u.apply(this, [O, l]);
    }
    return new Promise((O, D) => {
      u.apply(this, [function(F) {
        O(k(_(F)));
      }, D]);
    }).then(v, p);
  };
}
function shimSenderReceiverGetStats(a) {
  if (!(typeof a == "object" && a.RTCPeerConnection && a.RTCRtpSender && a.RTCRtpReceiver))
    return;
  if (!("getStats" in a.RTCRtpSender.prototype)) {
    const c = a.RTCPeerConnection.prototype.getSenders;
    c && (a.RTCPeerConnection.prototype.getSenders = function() {
      const p = c.apply(this, []);
      return p.forEach((_) => _._pc = this), p;
    });
    const l = a.RTCPeerConnection.prototype.addTrack;
    l && (a.RTCPeerConnection.prototype.addTrack = function() {
      const p = l.apply(this, arguments);
      return p._pc = this, p;
    }), a.RTCRtpSender.prototype.getStats = function() {
      const p = this;
      return this._pc.getStats().then((_) => (
        /* Note: this will include stats of all senders that
         *   send a track with the same id as sender.track as
         *   it is not possible to identify the RTCRtpSender.
         */
        filterStats(_, p.track, !0)
      ));
    };
  }
  if (!("getStats" in a.RTCRtpReceiver.prototype)) {
    const c = a.RTCPeerConnection.prototype.getReceivers;
    c && (a.RTCPeerConnection.prototype.getReceivers = function() {
      const v = c.apply(this, []);
      return v.forEach((p) => p._pc = this), v;
    }), wrapPeerConnectionEvent(a, "track", (l) => (l.receiver._pc = l.srcElement, l)), a.RTCRtpReceiver.prototype.getStats = function() {
      const v = this;
      return this._pc.getStats().then((p) => filterStats(p, v.track, !1));
    };
  }
  if (!("getStats" in a.RTCRtpSender.prototype && "getStats" in a.RTCRtpReceiver.prototype))
    return;
  const u = a.RTCPeerConnection.prototype.getStats;
  a.RTCPeerConnection.prototype.getStats = function() {
    if (arguments.length > 0 && arguments[0] instanceof a.MediaStreamTrack) {
      const l = arguments[0];
      let v, p, _;
      return this.getSenders().forEach((k) => {
        k.track === l && (v ? _ = !0 : v = k);
      }), this.getReceivers().forEach((k) => (k.track === l && (p ? _ = !0 : p = k), k.track === l)), _ || v && p ? Promise.reject(new DOMException("There are more than one sender or receiver for the track.", "InvalidAccessError")) : v ? v.getStats() : p ? p.getStats() : Promise.reject(new DOMException("There is no sender or receiver for the track.", "InvalidAccessError"));
    }
    return u.apply(this, arguments);
  };
}
function shimAddTrackRemoveTrackWithNative(a) {
  a.RTCPeerConnection.prototype.getLocalStreams = function() {
    return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, Object.keys(this._shimmedLocalStreams).map((_) => this._shimmedLocalStreams[_][0]);
  };
  const u = a.RTCPeerConnection.prototype.addTrack;
  a.RTCPeerConnection.prototype.addTrack = function(_, k) {
    if (!k)
      return u.apply(this, arguments);
    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
    const O = u.apply(this, arguments);
    return this._shimmedLocalStreams[k.id] ? this._shimmedLocalStreams[k.id].indexOf(O) === -1 && this._shimmedLocalStreams[k.id].push(O) : this._shimmedLocalStreams[k.id] = [k, O], O;
  };
  const c = a.RTCPeerConnection.prototype.addStream;
  a.RTCPeerConnection.prototype.addStream = function(_) {
    this._shimmedLocalStreams = this._shimmedLocalStreams || {}, _.getTracks().forEach((D) => {
      if (this.getSenders().find((H) => H.track === D))
        throw new DOMException("Track already exists.", "InvalidAccessError");
    });
    const k = this.getSenders();
    c.apply(this, arguments);
    const O = this.getSenders().filter((D) => k.indexOf(D) === -1);
    this._shimmedLocalStreams[_.id] = [_].concat(O);
  };
  const l = a.RTCPeerConnection.prototype.removeStream;
  a.RTCPeerConnection.prototype.removeStream = function(_) {
    return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, delete this._shimmedLocalStreams[_.id], l.apply(this, arguments);
  };
  const v = a.RTCPeerConnection.prototype.removeTrack;
  a.RTCPeerConnection.prototype.removeTrack = function(_) {
    return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, _ && Object.keys(this._shimmedLocalStreams).forEach((k) => {
      const O = this._shimmedLocalStreams[k].indexOf(_);
      O !== -1 && this._shimmedLocalStreams[k].splice(O, 1), this._shimmedLocalStreams[k].length === 1 && delete this._shimmedLocalStreams[k];
    }), v.apply(this, arguments);
  };
}
function shimAddTrackRemoveTrack(a, u) {
  if (!a.RTCPeerConnection)
    return;
  if (a.RTCPeerConnection.prototype.addTrack && u.version >= 65)
    return shimAddTrackRemoveTrackWithNative(a);
  const c = a.RTCPeerConnection.prototype.getLocalStreams;
  a.RTCPeerConnection.prototype.getLocalStreams = function() {
    const F = c.apply(this);
    return this._reverseStreams = this._reverseStreams || {}, F.map((H) => this._reverseStreams[H.id]);
  };
  const l = a.RTCPeerConnection.prototype.addStream;
  a.RTCPeerConnection.prototype.addStream = function(F) {
    if (this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, F.getTracks().forEach((H) => {
      if (this.getSenders().find((ee) => ee.track === H))
        throw new DOMException("Track already exists.", "InvalidAccessError");
    }), !this._reverseStreams[F.id]) {
      const H = new a.MediaStream(F.getTracks());
      this._streams[F.id] = H, this._reverseStreams[H.id] = F, F = H;
    }
    l.apply(this, [F]);
  };
  const v = a.RTCPeerConnection.prototype.removeStream;
  a.RTCPeerConnection.prototype.removeStream = function(F) {
    this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, v.apply(this, [this._streams[F.id] || F]), delete this._reverseStreams[this._streams[F.id] ? this._streams[F.id].id : F.id], delete this._streams[F.id];
  }, a.RTCPeerConnection.prototype.addTrack = function(F, H) {
    if (this.signalingState === "closed")
      throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
    const Z = [].slice.call(arguments, 1);
    if (Z.length !== 1 || !Z[0].getTracks().find((ne) => ne === F))
      throw new DOMException("The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.", "NotSupportedError");
    if (this.getSenders().find((ne) => ne.track === F))
      throw new DOMException("Track already exists.", "InvalidAccessError");
    this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {};
    const X = this._streams[H.id];
    if (X)
      X.addTrack(F), Promise.resolve().then(() => {
        this.dispatchEvent(new Event("negotiationneeded"));
      });
    else {
      const ne = new a.MediaStream([F]);
      this._streams[H.id] = ne, this._reverseStreams[ne.id] = H, this.addStream(ne);
    }
    return this.getSenders().find((ne) => ne.track === F);
  };
  function p(D, F) {
    let H = F.sdp;
    return Object.keys(D._reverseStreams || []).forEach((Z) => {
      const ee = D._reverseStreams[Z], X = D._streams[ee.id];
      H = H.replace(new RegExp(X.id, "g"), ee.id);
    }), new RTCSessionDescription({
      type: F.type,
      sdp: H
    });
  }
  function _(D, F) {
    let H = F.sdp;
    return Object.keys(D._reverseStreams || []).forEach((Z) => {
      const ee = D._reverseStreams[Z], X = D._streams[ee.id];
      H = H.replace(new RegExp(ee.id, "g"), X.id);
    }), new RTCSessionDescription({
      type: F.type,
      sdp: H
    });
  }
  ["createOffer", "createAnswer"].forEach(function(D) {
    const F = a.RTCPeerConnection.prototype[D], H = {
      [D]() {
        const Z = arguments;
        return arguments.length && typeof arguments[0] == "function" ? F.apply(this, [(X) => {
          const ne = p(this, X);
          Z[0].apply(null, [ne]);
        }, (X) => {
          Z[1] && Z[1].apply(null, X);
        }, arguments[2]]) : F.apply(this, arguments).then((X) => p(this, X));
      }
    };
    a.RTCPeerConnection.prototype[D] = H[D];
  });
  const k = a.RTCPeerConnection.prototype.setLocalDescription;
  a.RTCPeerConnection.prototype.setLocalDescription = function() {
    return !arguments.length || !arguments[0].type ? k.apply(this, arguments) : (arguments[0] = _(this, arguments[0]), k.apply(this, arguments));
  };
  const O = Object.getOwnPropertyDescriptor(a.RTCPeerConnection.prototype, "localDescription");
  Object.defineProperty(a.RTCPeerConnection.prototype, "localDescription", {
    get() {
      const D = O.get.apply(this);
      return D.type === "" ? D : p(this, D);
    }
  }), a.RTCPeerConnection.prototype.removeTrack = function(F) {
    if (this.signalingState === "closed")
      throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
    if (!F._pc)
      throw new DOMException("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.", "TypeError");
    if (!(F._pc === this))
      throw new DOMException("Sender was not created by this connection.", "InvalidAccessError");
    this._streams = this._streams || {};
    let Z;
    Object.keys(this._streams).forEach((ee) => {
      this._streams[ee].getTracks().find((ne) => F.track === ne) && (Z = this._streams[ee]);
    }), Z && (Z.getTracks().length === 1 ? this.removeStream(this._reverseStreams[Z.id]) : Z.removeTrack(F.track), this.dispatchEvent(new Event("negotiationneeded")));
  };
}
function shimPeerConnection$1(a, u) {
  !a.RTCPeerConnection && a.webkitRTCPeerConnection && (a.RTCPeerConnection = a.webkitRTCPeerConnection), a.RTCPeerConnection && u.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(c) {
    const l = a.RTCPeerConnection.prototype[c], v = {
      [c]() {
        return arguments[0] = new (c === "addIceCandidate" ? a.RTCIceCandidate : a.RTCSessionDescription)(arguments[0]), l.apply(this, arguments);
      }
    };
    a.RTCPeerConnection.prototype[c] = v[c];
  });
}
function fixNegotiationNeeded(a, u) {
  wrapPeerConnectionEvent(a, "negotiationneeded", (c) => {
    const l = c.target;
    if (!((u.version < 72 || l.getConfiguration && l.getConfiguration().sdpSemantics === "plan-b") && l.signalingState !== "stable"))
      return c;
  });
}
var chromeShim = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  fixNegotiationNeeded,
  shimAddTrackRemoveTrack,
  shimAddTrackRemoveTrackWithNative,
  shimGetDisplayMedia: shimGetDisplayMedia$1,
  shimGetSendersWithDtmf,
  shimGetStats,
  shimGetUserMedia: shimGetUserMedia$2,
  shimMediaStream,
  shimOnTrack: shimOnTrack$1,
  shimPeerConnection: shimPeerConnection$1,
  shimSenderReceiverGetStats
});
function shimGetUserMedia$1(a, u) {
  const c = a && a.navigator, l = a && a.MediaStreamTrack;
  if (c.getUserMedia = function(v, p, _) {
    deprecated("navigator.getUserMedia", "navigator.mediaDevices.getUserMedia"), c.mediaDevices.getUserMedia(v).then(p, _);
  }, !(u.version > 55 && "autoGainControl" in c.mediaDevices.getSupportedConstraints())) {
    const v = function(_, k, O) {
      k in _ && !(O in _) && (_[O] = _[k], delete _[k]);
    }, p = c.mediaDevices.getUserMedia.bind(c.mediaDevices);
    if (c.mediaDevices.getUserMedia = function(_) {
      return typeof _ == "object" && typeof _.audio == "object" && (_ = JSON.parse(JSON.stringify(_)), v(_.audio, "autoGainControl", "mozAutoGainControl"), v(_.audio, "noiseSuppression", "mozNoiseSuppression")), p(_);
    }, l && l.prototype.getSettings) {
      const _ = l.prototype.getSettings;
      l.prototype.getSettings = function() {
        const k = _.apply(this, arguments);
        return v(k, "mozAutoGainControl", "autoGainControl"), v(k, "mozNoiseSuppression", "noiseSuppression"), k;
      };
    }
    if (l && l.prototype.applyConstraints) {
      const _ = l.prototype.applyConstraints;
      l.prototype.applyConstraints = function(k) {
        return this.kind === "audio" && typeof k == "object" && (k = JSON.parse(JSON.stringify(k)), v(k, "autoGainControl", "mozAutoGainControl"), v(k, "noiseSuppression", "mozNoiseSuppression")), _.apply(this, [k]);
      };
    }
  }
}
function shimGetDisplayMedia(a, u) {
  a.navigator.mediaDevices && "getDisplayMedia" in a.navigator.mediaDevices || a.navigator.mediaDevices && (a.navigator.mediaDevices.getDisplayMedia = function(l) {
    if (!(l && l.video)) {
      const v = new DOMException("getDisplayMedia without video constraints is undefined");
      return v.name = "NotFoundError", v.code = 8, Promise.reject(v);
    }
    return l.video === !0 ? l.video = {
      mediaSource: u
    } : l.video.mediaSource = u, a.navigator.mediaDevices.getUserMedia(l);
  });
}
function shimOnTrack(a) {
  typeof a == "object" && a.RTCTrackEvent && "receiver" in a.RTCTrackEvent.prototype && !("transceiver" in a.RTCTrackEvent.prototype) && Object.defineProperty(a.RTCTrackEvent.prototype, "transceiver", {
    get() {
      return {
        receiver: this.receiver
      };
    }
  });
}
function shimPeerConnection(a, u) {
  if (typeof a != "object" || !(a.RTCPeerConnection || a.mozRTCPeerConnection))
    return;
  !a.RTCPeerConnection && a.mozRTCPeerConnection && (a.RTCPeerConnection = a.mozRTCPeerConnection), u.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(v) {
    const p = a.RTCPeerConnection.prototype[v], _ = {
      [v]() {
        return arguments[0] = new (v === "addIceCandidate" ? a.RTCIceCandidate : a.RTCSessionDescription)(arguments[0]), p.apply(this, arguments);
      }
    };
    a.RTCPeerConnection.prototype[v] = _[v];
  });
  const c = {
    inboundrtp: "inbound-rtp",
    outboundrtp: "outbound-rtp",
    candidatepair: "candidate-pair",
    localcandidate: "local-candidate",
    remotecandidate: "remote-candidate"
  }, l = a.RTCPeerConnection.prototype.getStats;
  a.RTCPeerConnection.prototype.getStats = function() {
    const [p, _, k] = arguments;
    return l.apply(this, [p || null]).then((O) => {
      if (u.version < 53 && !_)
        try {
          O.forEach((D) => {
            D.type = c[D.type] || D.type;
          });
        } catch (D) {
          if (D.name !== "TypeError")
            throw D;
          O.forEach((F, H) => {
            O.set(H, Object.assign({}, F, {
              type: c[F.type] || F.type
            }));
          });
        }
      return O;
    }).then(_, k);
  };
}
function shimSenderGetStats(a) {
  if (!(typeof a == "object" && a.RTCPeerConnection && a.RTCRtpSender) || a.RTCRtpSender && "getStats" in a.RTCRtpSender.prototype)
    return;
  const u = a.RTCPeerConnection.prototype.getSenders;
  u && (a.RTCPeerConnection.prototype.getSenders = function() {
    const v = u.apply(this, []);
    return v.forEach((p) => p._pc = this), v;
  });
  const c = a.RTCPeerConnection.prototype.addTrack;
  c && (a.RTCPeerConnection.prototype.addTrack = function() {
    const v = c.apply(this, arguments);
    return v._pc = this, v;
  }), a.RTCRtpSender.prototype.getStats = function() {
    return this.track ? this._pc.getStats(this.track) : Promise.resolve(/* @__PURE__ */ new Map());
  };
}
function shimReceiverGetStats(a) {
  if (!(typeof a == "object" && a.RTCPeerConnection && a.RTCRtpSender) || a.RTCRtpSender && "getStats" in a.RTCRtpReceiver.prototype)
    return;
  const u = a.RTCPeerConnection.prototype.getReceivers;
  u && (a.RTCPeerConnection.prototype.getReceivers = function() {
    const l = u.apply(this, []);
    return l.forEach((v) => v._pc = this), l;
  }), wrapPeerConnectionEvent(a, "track", (c) => (c.receiver._pc = c.srcElement, c)), a.RTCRtpReceiver.prototype.getStats = function() {
    return this._pc.getStats(this.track);
  };
}
function shimRemoveStream(a) {
  !a.RTCPeerConnection || "removeStream" in a.RTCPeerConnection.prototype || (a.RTCPeerConnection.prototype.removeStream = function(c) {
    deprecated("removeStream", "removeTrack"), this.getSenders().forEach((l) => {
      l.track && c.getTracks().includes(l.track) && this.removeTrack(l);
    });
  });
}
function shimRTCDataChannel(a) {
  a.DataChannel && !a.RTCDataChannel && (a.RTCDataChannel = a.DataChannel);
}
function shimAddTransceiver(a) {
  if (!(typeof a == "object" && a.RTCPeerConnection))
    return;
  const u = a.RTCPeerConnection.prototype.addTransceiver;
  u && (a.RTCPeerConnection.prototype.addTransceiver = function() {
    this.setParametersPromises = [];
    let l = arguments[1] && arguments[1].sendEncodings;
    l === void 0 && (l = []), l = [...l];
    const v = l.length > 0;
    v && l.forEach((_) => {
      if ("rid" in _ && !/^[a-z0-9]{0,16}$/i.test(_.rid))
        throw new TypeError("Invalid RID value provided.");
      if ("scaleResolutionDownBy" in _ && !(parseFloat(_.scaleResolutionDownBy) >= 1))
        throw new RangeError("scale_resolution_down_by must be >= 1.0");
      if ("maxFramerate" in _ && !(parseFloat(_.maxFramerate) >= 0))
        throw new RangeError("max_framerate must be >= 0.0");
    });
    const p = u.apply(this, arguments);
    if (v) {
      const {
        sender: _
      } = p, k = _.getParameters();
      (!("encodings" in k) || // Avoid being fooled by patched getParameters() below.
      k.encodings.length === 1 && Object.keys(k.encodings[0]).length === 0) && (k.encodings = l, _.sendEncodings = l, this.setParametersPromises.push(_.setParameters(k).then(() => {
        delete _.sendEncodings;
      }).catch(() => {
        delete _.sendEncodings;
      })));
    }
    return p;
  });
}
function shimGetParameters(a) {
  if (!(typeof a == "object" && a.RTCRtpSender))
    return;
  const u = a.RTCRtpSender.prototype.getParameters;
  u && (a.RTCRtpSender.prototype.getParameters = function() {
    const l = u.apply(this, arguments);
    return "encodings" in l || (l.encodings = [].concat(this.sendEncodings || [{}])), l;
  });
}
function shimCreateOffer(a) {
  if (!(typeof a == "object" && a.RTCPeerConnection))
    return;
  const u = a.RTCPeerConnection.prototype.createOffer;
  a.RTCPeerConnection.prototype.createOffer = function() {
    return this.setParametersPromises && this.setParametersPromises.length ? Promise.all(this.setParametersPromises).then(() => u.apply(this, arguments)).finally(() => {
      this.setParametersPromises = [];
    }) : u.apply(this, arguments);
  };
}
function shimCreateAnswer(a) {
  if (!(typeof a == "object" && a.RTCPeerConnection))
    return;
  const u = a.RTCPeerConnection.prototype.createAnswer;
  a.RTCPeerConnection.prototype.createAnswer = function() {
    return this.setParametersPromises && this.setParametersPromises.length ? Promise.all(this.setParametersPromises).then(() => u.apply(this, arguments)).finally(() => {
      this.setParametersPromises = [];
    }) : u.apply(this, arguments);
  };
}
var firefoxShim = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  shimAddTransceiver,
  shimCreateAnswer,
  shimCreateOffer,
  shimGetDisplayMedia,
  shimGetParameters,
  shimGetUserMedia: shimGetUserMedia$1,
  shimOnTrack,
  shimPeerConnection,
  shimRTCDataChannel,
  shimReceiverGetStats,
  shimRemoveStream,
  shimSenderGetStats
});
function shimLocalStreamsAPI(a) {
  if (!(typeof a != "object" || !a.RTCPeerConnection)) {
    if ("getLocalStreams" in a.RTCPeerConnection.prototype || (a.RTCPeerConnection.prototype.getLocalStreams = function() {
      return this._localStreams || (this._localStreams = []), this._localStreams;
    }), !("addStream" in a.RTCPeerConnection.prototype)) {
      const u = a.RTCPeerConnection.prototype.addTrack;
      a.RTCPeerConnection.prototype.addStream = function(l) {
        this._localStreams || (this._localStreams = []), this._localStreams.includes(l) || this._localStreams.push(l), l.getAudioTracks().forEach((v) => u.call(this, v, l)), l.getVideoTracks().forEach((v) => u.call(this, v, l));
      }, a.RTCPeerConnection.prototype.addTrack = function(l) {
        for (var v = arguments.length, p = new Array(v > 1 ? v - 1 : 0), _ = 1; _ < v; _++)
          p[_ - 1] = arguments[_];
        return p && p.forEach((k) => {
          this._localStreams ? this._localStreams.includes(k) || this._localStreams.push(k) : this._localStreams = [k];
        }), u.apply(this, arguments);
      };
    }
    "removeStream" in a.RTCPeerConnection.prototype || (a.RTCPeerConnection.prototype.removeStream = function(c) {
      this._localStreams || (this._localStreams = []);
      const l = this._localStreams.indexOf(c);
      if (l === -1)
        return;
      this._localStreams.splice(l, 1);
      const v = c.getTracks();
      this.getSenders().forEach((p) => {
        v.includes(p.track) && this.removeTrack(p);
      });
    });
  }
}
function shimRemoteStreamsAPI(a) {
  if (!(typeof a != "object" || !a.RTCPeerConnection) && ("getRemoteStreams" in a.RTCPeerConnection.prototype || (a.RTCPeerConnection.prototype.getRemoteStreams = function() {
    return this._remoteStreams ? this._remoteStreams : [];
  }), !("onaddstream" in a.RTCPeerConnection.prototype))) {
    Object.defineProperty(a.RTCPeerConnection.prototype, "onaddstream", {
      get() {
        return this._onaddstream;
      },
      set(c) {
        this._onaddstream && (this.removeEventListener("addstream", this._onaddstream), this.removeEventListener("track", this._onaddstreampoly)), this.addEventListener("addstream", this._onaddstream = c), this.addEventListener("track", this._onaddstreampoly = (l) => {
          l.streams.forEach((v) => {
            if (this._remoteStreams || (this._remoteStreams = []), this._remoteStreams.includes(v))
              return;
            this._remoteStreams.push(v);
            const p = new Event("addstream");
            p.stream = v, this.dispatchEvent(p);
          });
        });
      }
    });
    const u = a.RTCPeerConnection.prototype.setRemoteDescription;
    a.RTCPeerConnection.prototype.setRemoteDescription = function() {
      const l = this;
      return this._onaddstreampoly || this.addEventListener("track", this._onaddstreampoly = function(v) {
        v.streams.forEach((p) => {
          if (l._remoteStreams || (l._remoteStreams = []), l._remoteStreams.indexOf(p) >= 0)
            return;
          l._remoteStreams.push(p);
          const _ = new Event("addstream");
          _.stream = p, l.dispatchEvent(_);
        });
      }), u.apply(l, arguments);
    };
  }
}
function shimCallbacksAPI(a) {
  if (typeof a != "object" || !a.RTCPeerConnection)
    return;
  const u = a.RTCPeerConnection.prototype, c = u.createOffer, l = u.createAnswer, v = u.setLocalDescription, p = u.setRemoteDescription, _ = u.addIceCandidate;
  u.createOffer = function(D, F) {
    const H = arguments.length >= 2 ? arguments[2] : arguments[0], Z = c.apply(this, [H]);
    return F ? (Z.then(D, F), Promise.resolve()) : Z;
  }, u.createAnswer = function(D, F) {
    const H = arguments.length >= 2 ? arguments[2] : arguments[0], Z = l.apply(this, [H]);
    return F ? (Z.then(D, F), Promise.resolve()) : Z;
  };
  let k = function(O, D, F) {
    const H = v.apply(this, [O]);
    return F ? (H.then(D, F), Promise.resolve()) : H;
  };
  u.setLocalDescription = k, k = function(O, D, F) {
    const H = p.apply(this, [O]);
    return F ? (H.then(D, F), Promise.resolve()) : H;
  }, u.setRemoteDescription = k, k = function(O, D, F) {
    const H = _.apply(this, [O]);
    return F ? (H.then(D, F), Promise.resolve()) : H;
  }, u.addIceCandidate = k;
}
function shimGetUserMedia(a) {
  const u = a && a.navigator;
  if (u.mediaDevices && u.mediaDevices.getUserMedia) {
    const c = u.mediaDevices, l = c.getUserMedia.bind(c);
    u.mediaDevices.getUserMedia = (v) => l(shimConstraints(v));
  }
  !u.getUserMedia && u.mediaDevices && u.mediaDevices.getUserMedia && (u.getUserMedia = (function(l, v, p) {
    u.mediaDevices.getUserMedia(l).then(v, p);
  }).bind(u));
}
function shimConstraints(a) {
  return a && a.video !== void 0 ? Object.assign({}, a, {
    video: compactObject(a.video)
  }) : a;
}
function shimRTCIceServerUrls(a) {
  if (!a.RTCPeerConnection)
    return;
  const u = a.RTCPeerConnection;
  a.RTCPeerConnection = function(l, v) {
    if (l && l.iceServers) {
      const p = [];
      for (let _ = 0; _ < l.iceServers.length; _++) {
        let k = l.iceServers[_];
        k.urls === void 0 && k.url ? (deprecated("RTCIceServer.url", "RTCIceServer.urls"), k = JSON.parse(JSON.stringify(k)), k.urls = k.url, delete k.url, p.push(k)) : p.push(l.iceServers[_]);
      }
      l.iceServers = p;
    }
    return new u(l, v);
  }, a.RTCPeerConnection.prototype = u.prototype, "generateCertificate" in u && Object.defineProperty(a.RTCPeerConnection, "generateCertificate", {
    get() {
      return u.generateCertificate;
    }
  });
}
function shimTrackEventTransceiver(a) {
  typeof a == "object" && a.RTCTrackEvent && "receiver" in a.RTCTrackEvent.prototype && !("transceiver" in a.RTCTrackEvent.prototype) && Object.defineProperty(a.RTCTrackEvent.prototype, "transceiver", {
    get() {
      return {
        receiver: this.receiver
      };
    }
  });
}
function shimCreateOfferLegacy(a) {
  const u = a.RTCPeerConnection.prototype.createOffer;
  a.RTCPeerConnection.prototype.createOffer = function(l) {
    if (l) {
      typeof l.offerToReceiveAudio < "u" && (l.offerToReceiveAudio = !!l.offerToReceiveAudio);
      const v = this.getTransceivers().find((_) => _.receiver.track.kind === "audio");
      l.offerToReceiveAudio === !1 && v ? v.direction === "sendrecv" ? v.setDirection ? v.setDirection("sendonly") : v.direction = "sendonly" : v.direction === "recvonly" && (v.setDirection ? v.setDirection("inactive") : v.direction = "inactive") : l.offerToReceiveAudio === !0 && !v && this.addTransceiver("audio", {
        direction: "recvonly"
      }), typeof l.offerToReceiveVideo < "u" && (l.offerToReceiveVideo = !!l.offerToReceiveVideo);
      const p = this.getTransceivers().find((_) => _.receiver.track.kind === "video");
      l.offerToReceiveVideo === !1 && p ? p.direction === "sendrecv" ? p.setDirection ? p.setDirection("sendonly") : p.direction = "sendonly" : p.direction === "recvonly" && (p.setDirection ? p.setDirection("inactive") : p.direction = "inactive") : l.offerToReceiveVideo === !0 && !p && this.addTransceiver("video", {
        direction: "recvonly"
      });
    }
    return u.apply(this, arguments);
  };
}
function shimAudioContext(a) {
  typeof a != "object" || a.AudioContext || (a.AudioContext = a.webkitAudioContext);
}
var safariShim = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  shimAudioContext,
  shimCallbacksAPI,
  shimConstraints,
  shimCreateOfferLegacy,
  shimGetUserMedia,
  shimLocalStreamsAPI,
  shimRTCIceServerUrls,
  shimRemoteStreamsAPI,
  shimTrackEventTransceiver
}), sdp$1 = { exports: {} };
(function(a) {
  const u = {};
  u.generateIdentifier = function() {
    return Math.random().toString(36).substring(2, 12);
  }, u.localCName = u.generateIdentifier(), u.splitLines = function(c) {
    return c.trim().split(`
`).map((l) => l.trim());
  }, u.splitSections = function(c) {
    return c.split(`
m=`).map((v, p) => (p > 0 ? "m=" + v : v).trim() + `\r
`);
  }, u.getDescription = function(c) {
    const l = u.splitSections(c);
    return l && l[0];
  }, u.getMediaSections = function(c) {
    const l = u.splitSections(c);
    return l.shift(), l;
  }, u.matchPrefix = function(c, l) {
    return u.splitLines(c).filter((v) => v.indexOf(l) === 0);
  }, u.parseCandidate = function(c) {
    let l;
    c.indexOf("a=candidate:") === 0 ? l = c.substring(12).split(" ") : l = c.substring(10).split(" ");
    const v = {
      foundation: l[0],
      component: {
        1: "rtp",
        2: "rtcp"
      }[l[1]] || l[1],
      protocol: l[2].toLowerCase(),
      priority: parseInt(l[3], 10),
      ip: l[4],
      address: l[4],
      // address is an alias for ip.
      port: parseInt(l[5], 10),
      // skip parts[6] == 'typ'
      type: l[7]
    };
    for (let p = 8; p < l.length; p += 2)
      switch (l[p]) {
        case "raddr":
          v.relatedAddress = l[p + 1];
          break;
        case "rport":
          v.relatedPort = parseInt(l[p + 1], 10);
          break;
        case "tcptype":
          v.tcpType = l[p + 1];
          break;
        case "ufrag":
          v.ufrag = l[p + 1], v.usernameFragment = l[p + 1];
          break;
        default:
          v[l[p]] === void 0 && (v[l[p]] = l[p + 1]);
          break;
      }
    return v;
  }, u.writeCandidate = function(c) {
    const l = [];
    l.push(c.foundation);
    const v = c.component;
    v === "rtp" ? l.push(1) : v === "rtcp" ? l.push(2) : l.push(v), l.push(c.protocol.toUpperCase()), l.push(c.priority), l.push(c.address || c.ip), l.push(c.port);
    const p = c.type;
    return l.push("typ"), l.push(p), p !== "host" && c.relatedAddress && c.relatedPort && (l.push("raddr"), l.push(c.relatedAddress), l.push("rport"), l.push(c.relatedPort)), c.tcpType && c.protocol.toLowerCase() === "tcp" && (l.push("tcptype"), l.push(c.tcpType)), (c.usernameFragment || c.ufrag) && (l.push("ufrag"), l.push(c.usernameFragment || c.ufrag)), "candidate:" + l.join(" ");
  }, u.parseIceOptions = function(c) {
    return c.substring(14).split(" ");
  }, u.parseRtpMap = function(c) {
    let l = c.substring(9).split(" ");
    const v = {
      payloadType: parseInt(l.shift(), 10)
      // was: id
    };
    return l = l[0].split("/"), v.name = l[0], v.clockRate = parseInt(l[1], 10), v.channels = l.length === 3 ? parseInt(l[2], 10) : 1, v.numChannels = v.channels, v;
  }, u.writeRtpMap = function(c) {
    let l = c.payloadType;
    c.preferredPayloadType !== void 0 && (l = c.preferredPayloadType);
    const v = c.channels || c.numChannels || 1;
    return "a=rtpmap:" + l + " " + c.name + "/" + c.clockRate + (v !== 1 ? "/" + v : "") + `\r
`;
  }, u.parseExtmap = function(c) {
    const l = c.substring(9).split(" ");
    return {
      id: parseInt(l[0], 10),
      direction: l[0].indexOf("/") > 0 ? l[0].split("/")[1] : "sendrecv",
      uri: l[1],
      attributes: l.slice(2).join(" ")
    };
  }, u.writeExtmap = function(c) {
    return "a=extmap:" + (c.id || c.preferredId) + (c.direction && c.direction !== "sendrecv" ? "/" + c.direction : "") + " " + c.uri + (c.attributes ? " " + c.attributes : "") + `\r
`;
  }, u.parseFmtp = function(c) {
    const l = {};
    let v;
    const p = c.substring(c.indexOf(" ") + 1).split(";");
    for (let _ = 0; _ < p.length; _++)
      v = p[_].trim().split("="), l[v[0].trim()] = v[1];
    return l;
  }, u.writeFmtp = function(c) {
    let l = "", v = c.payloadType;
    if (c.preferredPayloadType !== void 0 && (v = c.preferredPayloadType), c.parameters && Object.keys(c.parameters).length) {
      const p = [];
      Object.keys(c.parameters).forEach((_) => {
        c.parameters[_] !== void 0 ? p.push(_ + "=" + c.parameters[_]) : p.push(_);
      }), l += "a=fmtp:" + v + " " + p.join(";") + `\r
`;
    }
    return l;
  }, u.parseRtcpFb = function(c) {
    const l = c.substring(c.indexOf(" ") + 1).split(" ");
    return {
      type: l.shift(),
      parameter: l.join(" ")
    };
  }, u.writeRtcpFb = function(c) {
    let l = "", v = c.payloadType;
    return c.preferredPayloadType !== void 0 && (v = c.preferredPayloadType), c.rtcpFeedback && c.rtcpFeedback.length && c.rtcpFeedback.forEach((p) => {
      l += "a=rtcp-fb:" + v + " " + p.type + (p.parameter && p.parameter.length ? " " + p.parameter : "") + `\r
`;
    }), l;
  }, u.parseSsrcMedia = function(c) {
    const l = c.indexOf(" "), v = {
      ssrc: parseInt(c.substring(7, l), 10)
    }, p = c.indexOf(":", l);
    return p > -1 ? (v.attribute = c.substring(l + 1, p), v.value = c.substring(p + 1)) : v.attribute = c.substring(l + 1), v;
  }, u.parseSsrcGroup = function(c) {
    const l = c.substring(13).split(" ");
    return {
      semantics: l.shift(),
      ssrcs: l.map((v) => parseInt(v, 10))
    };
  }, u.getMid = function(c) {
    const l = u.matchPrefix(c, "a=mid:")[0];
    if (l)
      return l.substring(6);
  }, u.parseFingerprint = function(c) {
    const l = c.substring(14).split(" ");
    return {
      algorithm: l[0].toLowerCase(),
      // algorithm is case-sensitive in Edge.
      value: l[1].toUpperCase()
      // the definition is upper-case in RFC 4572.
    };
  }, u.getDtlsParameters = function(c, l) {
    return {
      role: "auto",
      fingerprints: u.matchPrefix(c + l, "a=fingerprint:").map(u.parseFingerprint)
    };
  }, u.writeDtlsParameters = function(c, l) {
    let v = "a=setup:" + l + `\r
`;
    return c.fingerprints.forEach((p) => {
      v += "a=fingerprint:" + p.algorithm + " " + p.value + `\r
`;
    }), v;
  }, u.parseCryptoLine = function(c) {
    const l = c.substring(9).split(" ");
    return {
      tag: parseInt(l[0], 10),
      cryptoSuite: l[1],
      keyParams: l[2],
      sessionParams: l.slice(3)
    };
  }, u.writeCryptoLine = function(c) {
    return "a=crypto:" + c.tag + " " + c.cryptoSuite + " " + (typeof c.keyParams == "object" ? u.writeCryptoKeyParams(c.keyParams) : c.keyParams) + (c.sessionParams ? " " + c.sessionParams.join(" ") : "") + `\r
`;
  }, u.parseCryptoKeyParams = function(c) {
    if (c.indexOf("inline:") !== 0)
      return null;
    const l = c.substring(7).split("|");
    return {
      keyMethod: "inline",
      keySalt: l[0],
      lifeTime: l[1],
      mkiValue: l[2] ? l[2].split(":")[0] : void 0,
      mkiLength: l[2] ? l[2].split(":")[1] : void 0
    };
  }, u.writeCryptoKeyParams = function(c) {
    return c.keyMethod + ":" + c.keySalt + (c.lifeTime ? "|" + c.lifeTime : "") + (c.mkiValue && c.mkiLength ? "|" + c.mkiValue + ":" + c.mkiLength : "");
  }, u.getCryptoParameters = function(c, l) {
    return u.matchPrefix(c + l, "a=crypto:").map(u.parseCryptoLine);
  }, u.getIceParameters = function(c, l) {
    const v = u.matchPrefix(c + l, "a=ice-ufrag:")[0], p = u.matchPrefix(c + l, "a=ice-pwd:")[0];
    return v && p ? {
      usernameFragment: v.substring(12),
      password: p.substring(10)
    } : null;
  }, u.writeIceParameters = function(c) {
    let l = "a=ice-ufrag:" + c.usernameFragment + `\r
a=ice-pwd:` + c.password + `\r
`;
    return c.iceLite && (l += `a=ice-lite\r
`), l;
  }, u.parseRtpParameters = function(c) {
    const l = {
      codecs: [],
      headerExtensions: [],
      fecMechanisms: [],
      rtcp: []
    }, p = u.splitLines(c)[0].split(" ");
    l.profile = p[2];
    for (let k = 3; k < p.length; k++) {
      const O = p[k], D = u.matchPrefix(c, "a=rtpmap:" + O + " ")[0];
      if (D) {
        const F = u.parseRtpMap(D), H = u.matchPrefix(c, "a=fmtp:" + O + " ");
        switch (F.parameters = H.length ? u.parseFmtp(H[0]) : {}, F.rtcpFeedback = u.matchPrefix(c, "a=rtcp-fb:" + O + " ").map(u.parseRtcpFb), l.codecs.push(F), F.name.toUpperCase()) {
          case "RED":
          case "ULPFEC":
            l.fecMechanisms.push(F.name.toUpperCase());
            break;
        }
      }
    }
    u.matchPrefix(c, "a=extmap:").forEach((k) => {
      l.headerExtensions.push(u.parseExtmap(k));
    });
    const _ = u.matchPrefix(c, "a=rtcp-fb:* ").map(u.parseRtcpFb);
    return l.codecs.forEach((k) => {
      _.forEach((O) => {
        k.rtcpFeedback.find((F) => F.type === O.type && F.parameter === O.parameter) || k.rtcpFeedback.push(O);
      });
    }), l;
  }, u.writeRtpDescription = function(c, l) {
    let v = "";
    v += "m=" + c + " ", v += l.codecs.length > 0 ? "9" : "0", v += " " + (l.profile || "UDP/TLS/RTP/SAVPF") + " ", v += l.codecs.map((_) => _.preferredPayloadType !== void 0 ? _.preferredPayloadType : _.payloadType).join(" ") + `\r
`, v += `c=IN IP4 0.0.0.0\r
`, v += `a=rtcp:9 IN IP4 0.0.0.0\r
`, l.codecs.forEach((_) => {
      v += u.writeRtpMap(_), v += u.writeFmtp(_), v += u.writeRtcpFb(_);
    });
    let p = 0;
    return l.codecs.forEach((_) => {
      _.maxptime > p && (p = _.maxptime);
    }), p > 0 && (v += "a=maxptime:" + p + `\r
`), l.headerExtensions && l.headerExtensions.forEach((_) => {
      v += u.writeExtmap(_);
    }), v;
  }, u.parseRtpEncodingParameters = function(c) {
    const l = [], v = u.parseRtpParameters(c), p = v.fecMechanisms.indexOf("RED") !== -1, _ = v.fecMechanisms.indexOf("ULPFEC") !== -1, k = u.matchPrefix(c, "a=ssrc:").map((Z) => u.parseSsrcMedia(Z)).filter((Z) => Z.attribute === "cname"), O = k.length > 0 && k[0].ssrc;
    let D;
    const F = u.matchPrefix(c, "a=ssrc-group:FID").map((Z) => Z.substring(17).split(" ").map((X) => parseInt(X, 10)));
    F.length > 0 && F[0].length > 1 && F[0][0] === O && (D = F[0][1]), v.codecs.forEach((Z) => {
      if (Z.name.toUpperCase() === "RTX" && Z.parameters.apt) {
        let ee = {
          ssrc: O,
          codecPayloadType: parseInt(Z.parameters.apt, 10)
        };
        O && D && (ee.rtx = {
          ssrc: D
        }), l.push(ee), p && (ee = JSON.parse(JSON.stringify(ee)), ee.fec = {
          ssrc: O,
          mechanism: _ ? "red+ulpfec" : "red"
        }, l.push(ee));
      }
    }), l.length === 0 && O && l.push({
      ssrc: O
    });
    let H = u.matchPrefix(c, "b=");
    return H.length && (H[0].indexOf("b=TIAS:") === 0 ? H = parseInt(H[0].substring(7), 10) : H[0].indexOf("b=AS:") === 0 ? H = parseInt(H[0].substring(5), 10) * 1e3 * 0.95 - 50 * 40 * 8 : H = void 0, l.forEach((Z) => {
      Z.maxBitrate = H;
    })), l;
  }, u.parseRtcpParameters = function(c) {
    const l = {}, v = u.matchPrefix(c, "a=ssrc:").map((k) => u.parseSsrcMedia(k)).filter((k) => k.attribute === "cname")[0];
    v && (l.cname = v.value, l.ssrc = v.ssrc);
    const p = u.matchPrefix(c, "a=rtcp-rsize");
    l.reducedSize = p.length > 0, l.compound = p.length === 0;
    const _ = u.matchPrefix(c, "a=rtcp-mux");
    return l.mux = _.length > 0, l;
  }, u.writeRtcpParameters = function(c) {
    let l = "";
    return c.reducedSize && (l += `a=rtcp-rsize\r
`), c.mux && (l += `a=rtcp-mux\r
`), c.ssrc !== void 0 && c.cname && (l += "a=ssrc:" + c.ssrc + " cname:" + c.cname + `\r
`), l;
  }, u.parseMsid = function(c) {
    let l;
    const v = u.matchPrefix(c, "a=msid:");
    if (v.length === 1)
      return l = v[0].substring(7).split(" "), {
        stream: l[0],
        track: l[1]
      };
    const p = u.matchPrefix(c, "a=ssrc:").map((_) => u.parseSsrcMedia(_)).filter((_) => _.attribute === "msid");
    if (p.length > 0)
      return l = p[0].value.split(" "), {
        stream: l[0],
        track: l[1]
      };
  }, u.parseSctpDescription = function(c) {
    const l = u.parseMLine(c), v = u.matchPrefix(c, "a=max-message-size:");
    let p;
    v.length > 0 && (p = parseInt(v[0].substring(19), 10)), isNaN(p) && (p = 65536);
    const _ = u.matchPrefix(c, "a=sctp-port:");
    if (_.length > 0)
      return {
        port: parseInt(_[0].substring(12), 10),
        protocol: l.fmt,
        maxMessageSize: p
      };
    const k = u.matchPrefix(c, "a=sctpmap:");
    if (k.length > 0) {
      const O = k[0].substring(10).split(" ");
      return {
        port: parseInt(O[0], 10),
        protocol: O[1],
        maxMessageSize: p
      };
    }
  }, u.writeSctpDescription = function(c, l) {
    let v = [];
    return c.protocol !== "DTLS/SCTP" ? v = ["m=" + c.kind + " 9 " + c.protocol + " " + l.protocol + `\r
`, `c=IN IP4 0.0.0.0\r
`, "a=sctp-port:" + l.port + `\r
`] : v = ["m=" + c.kind + " 9 " + c.protocol + " " + l.port + `\r
`, `c=IN IP4 0.0.0.0\r
`, "a=sctpmap:" + l.port + " " + l.protocol + ` 65535\r
`], l.maxMessageSize !== void 0 && v.push("a=max-message-size:" + l.maxMessageSize + `\r
`), v.join("");
  }, u.generateSessionId = function() {
    return Math.random().toString().substr(2, 22);
  }, u.writeSessionBoilerplate = function(c, l, v) {
    let p;
    const _ = l !== void 0 ? l : 2;
    return c ? p = c : p = u.generateSessionId(), `v=0\r
o=` + (v || "thisisadapterortc") + " " + p + " " + _ + ` IN IP4 127.0.0.1\r
s=-\r
t=0 0\r
`;
  }, u.getDirection = function(c, l) {
    const v = u.splitLines(c);
    for (let p = 0; p < v.length; p++)
      switch (v[p]) {
        case "a=sendrecv":
        case "a=sendonly":
        case "a=recvonly":
        case "a=inactive":
          return v[p].substring(2);
      }
    return l ? u.getDirection(l) : "sendrecv";
  }, u.getKind = function(c) {
    return u.splitLines(c)[0].split(" ")[0].substring(2);
  }, u.isRejected = function(c) {
    return c.split(" ", 2)[1] === "0";
  }, u.parseMLine = function(c) {
    const v = u.splitLines(c)[0].substring(2).split(" ");
    return {
      kind: v[0],
      port: parseInt(v[1], 10),
      protocol: v[2],
      fmt: v.slice(3).join(" ")
    };
  }, u.parseOLine = function(c) {
    const v = u.matchPrefix(c, "o=")[0].substring(2).split(" ");
    return {
      username: v[0],
      sessionId: v[1],
      sessionVersion: parseInt(v[2], 10),
      netType: v[3],
      addressType: v[4],
      address: v[5]
    };
  }, u.isValidSDP = function(c) {
    if (typeof c != "string" || c.length === 0)
      return !1;
    const l = u.splitLines(c);
    for (let v = 0; v < l.length; v++)
      if (l[v].length < 2 || l[v].charAt(1) !== "=")
        return !1;
    return !0;
  }, a.exports = u;
})(sdp$1);
var sdpExports = sdp$1.exports, SDPUtils = /* @__PURE__ */ getDefaultExportFromCjs(sdpExports), sdp = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: SDPUtils
}, [sdpExports]);
function shimRTCIceCandidate(a) {
  if (!a.RTCIceCandidate || a.RTCIceCandidate && "foundation" in a.RTCIceCandidate.prototype)
    return;
  const u = a.RTCIceCandidate;
  a.RTCIceCandidate = function(l) {
    if (typeof l == "object" && l.candidate && l.candidate.indexOf("a=") === 0 && (l = JSON.parse(JSON.stringify(l)), l.candidate = l.candidate.substring(2)), l.candidate && l.candidate.length) {
      const v = new u(l), p = SDPUtils.parseCandidate(l.candidate);
      for (const _ in p)
        _ in v || Object.defineProperty(v, _, {
          value: p[_]
        });
      return v.toJSON = function() {
        return {
          candidate: v.candidate,
          sdpMid: v.sdpMid,
          sdpMLineIndex: v.sdpMLineIndex,
          usernameFragment: v.usernameFragment
        };
      }, v;
    }
    return new u(l);
  }, a.RTCIceCandidate.prototype = u.prototype, wrapPeerConnectionEvent(a, "icecandidate", (c) => (c.candidate && Object.defineProperty(c, "candidate", {
    value: new a.RTCIceCandidate(c.candidate),
    writable: "false"
  }), c));
}
function shimRTCIceCandidateRelayProtocol(a) {
  !a.RTCIceCandidate || a.RTCIceCandidate && "relayProtocol" in a.RTCIceCandidate.prototype || wrapPeerConnectionEvent(a, "icecandidate", (u) => {
    if (u.candidate) {
      const c = SDPUtils.parseCandidate(u.candidate.candidate);
      c.type === "relay" && (u.candidate.relayProtocol = {
        0: "tls",
        1: "tcp",
        2: "udp"
      }[c.priority >> 24]);
    }
    return u;
  });
}
function shimMaxMessageSize(a, u) {
  if (!a.RTCPeerConnection)
    return;
  "sctp" in a.RTCPeerConnection.prototype || Object.defineProperty(a.RTCPeerConnection.prototype, "sctp", {
    get() {
      return typeof this._sctp > "u" ? null : this._sctp;
    }
  });
  const c = function(k) {
    if (!k || !k.sdp)
      return !1;
    const O = SDPUtils.splitSections(k.sdp);
    return O.shift(), O.some((D) => {
      const F = SDPUtils.parseMLine(D);
      return F && F.kind === "application" && F.protocol.indexOf("SCTP") !== -1;
    });
  }, l = function(k) {
    const O = k.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
    if (O === null || O.length < 2)
      return -1;
    const D = parseInt(O[1], 10);
    return D !== D ? -1 : D;
  }, v = function(k) {
    let O = 65536;
    return u.browser === "firefox" && (u.version < 57 ? k === -1 ? O = 16384 : O = 2147483637 : u.version < 60 ? O = u.version === 57 ? 65535 : 65536 : O = 2147483637), O;
  }, p = function(k, O) {
    let D = 65536;
    u.browser === "firefox" && u.version === 57 && (D = 65535);
    const F = SDPUtils.matchPrefix(k.sdp, "a=max-message-size:");
    return F.length > 0 ? D = parseInt(F[0].substring(19), 10) : u.browser === "firefox" && O !== -1 && (D = 2147483637), D;
  }, _ = a.RTCPeerConnection.prototype.setRemoteDescription;
  a.RTCPeerConnection.prototype.setRemoteDescription = function() {
    if (this._sctp = null, u.browser === "chrome" && u.version >= 76) {
      const {
        sdpSemantics: O
      } = this.getConfiguration();
      O === "plan-b" && Object.defineProperty(this, "sctp", {
        get() {
          return typeof this._sctp > "u" ? null : this._sctp;
        },
        enumerable: !0,
        configurable: !0
      });
    }
    if (c(arguments[0])) {
      const O = l(arguments[0]), D = v(O), F = p(arguments[0], O);
      let H;
      D === 0 && F === 0 ? H = Number.POSITIVE_INFINITY : D === 0 || F === 0 ? H = Math.max(D, F) : H = Math.min(D, F);
      const Z = {};
      Object.defineProperty(Z, "maxMessageSize", {
        get() {
          return H;
        }
      }), this._sctp = Z;
    }
    return _.apply(this, arguments);
  };
}
function shimSendThrowTypeError(a) {
  if (!(a.RTCPeerConnection && "createDataChannel" in a.RTCPeerConnection.prototype))
    return;
  function u(l, v) {
    const p = l.send;
    l.send = function() {
      const k = arguments[0], O = k.length || k.size || k.byteLength;
      if (l.readyState === "open" && v.sctp && O > v.sctp.maxMessageSize)
        throw new TypeError("Message too large (can send a maximum of " + v.sctp.maxMessageSize + " bytes)");
      return p.apply(l, arguments);
    };
  }
  const c = a.RTCPeerConnection.prototype.createDataChannel;
  a.RTCPeerConnection.prototype.createDataChannel = function() {
    const v = c.apply(this, arguments);
    return u(v, this), v;
  }, wrapPeerConnectionEvent(a, "datachannel", (l) => (u(l.channel, l.target), l));
}
function shimConnectionState(a) {
  if (!a.RTCPeerConnection || "connectionState" in a.RTCPeerConnection.prototype)
    return;
  const u = a.RTCPeerConnection.prototype;
  Object.defineProperty(u, "connectionState", {
    get() {
      return {
        completed: "connected",
        checking: "connecting"
      }[this.iceConnectionState] || this.iceConnectionState;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(u, "onconnectionstatechange", {
    get() {
      return this._onconnectionstatechange || null;
    },
    set(c) {
      this._onconnectionstatechange && (this.removeEventListener("connectionstatechange", this._onconnectionstatechange), delete this._onconnectionstatechange), c && this.addEventListener("connectionstatechange", this._onconnectionstatechange = c);
    },
    enumerable: !0,
    configurable: !0
  }), ["setLocalDescription", "setRemoteDescription"].forEach((c) => {
    const l = u[c];
    u[c] = function() {
      return this._connectionstatechangepoly || (this._connectionstatechangepoly = (v) => {
        const p = v.target;
        if (p._lastConnectionState !== p.connectionState) {
          p._lastConnectionState = p.connectionState;
          const _ = new Event("connectionstatechange", v);
          p.dispatchEvent(_);
        }
        return v;
      }, this.addEventListener("iceconnectionstatechange", this._connectionstatechangepoly)), l.apply(this, arguments);
    };
  });
}
function removeExtmapAllowMixed(a, u) {
  if (!a.RTCPeerConnection || u.browser === "chrome" && u.version >= 71 || u.browser === "safari" && u.version >= 605)
    return;
  const c = a.RTCPeerConnection.prototype.setRemoteDescription;
  a.RTCPeerConnection.prototype.setRemoteDescription = function(v) {
    if (v && v.sdp && v.sdp.indexOf(`
a=extmap-allow-mixed`) !== -1) {
      const p = v.sdp.split(`
`).filter((_) => _.trim() !== "a=extmap-allow-mixed").join(`
`);
      a.RTCSessionDescription && v instanceof a.RTCSessionDescription ? arguments[0] = new a.RTCSessionDescription({
        type: v.type,
        sdp: p
      }) : v.sdp = p;
    }
    return c.apply(this, arguments);
  };
}
function shimAddIceCandidateNullOrEmpty(a, u) {
  if (!(a.RTCPeerConnection && a.RTCPeerConnection.prototype))
    return;
  const c = a.RTCPeerConnection.prototype.addIceCandidate;
  !c || c.length === 0 || (a.RTCPeerConnection.prototype.addIceCandidate = function() {
    return arguments[0] ? (u.browser === "chrome" && u.version < 78 || u.browser === "firefox" && u.version < 68 || u.browser === "safari") && arguments[0] && arguments[0].candidate === "" ? Promise.resolve() : c.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), Promise.resolve());
  });
}
function shimParameterlessSetLocalDescription(a, u) {
  if (!(a.RTCPeerConnection && a.RTCPeerConnection.prototype))
    return;
  const c = a.RTCPeerConnection.prototype.setLocalDescription;
  !c || c.length === 0 || (a.RTCPeerConnection.prototype.setLocalDescription = function() {
    let v = arguments[0] || {};
    if (typeof v != "object" || v.type && v.sdp)
      return c.apply(this, arguments);
    if (v = {
      type: v.type,
      sdp: v.sdp
    }, !v.type)
      switch (this.signalingState) {
        case "stable":
        case "have-local-offer":
        case "have-remote-pranswer":
          v.type = "offer";
          break;
        default:
          v.type = "answer";
          break;
      }
    return v.sdp || v.type !== "offer" && v.type !== "answer" ? c.apply(this, [v]) : (v.type === "offer" ? this.createOffer : this.createAnswer).apply(this).then((_) => c.apply(this, [_]));
  });
}
var commonShim = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  removeExtmapAllowMixed,
  shimAddIceCandidateNullOrEmpty,
  shimConnectionState,
  shimMaxMessageSize,
  shimParameterlessSetLocalDescription,
  shimRTCIceCandidate,
  shimRTCIceCandidateRelayProtocol,
  shimSendThrowTypeError
});
function adapterFactory() {
  let {
    window: a
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    shimChrome: !0,
    shimFirefox: !0,
    shimSafari: !0
  };
  const c = log$1, l = detectBrowser(a), v = {
    browserDetails: l,
    commonShim,
    extractVersion,
    disableLog,
    disableWarnings,
    // Expose sdp as a convenience. For production apps include directly.
    sdp
  };
  switch (l.browser) {
    case "chrome":
      if (!chromeShim || !shimPeerConnection$1 || !u.shimChrome)
        return c("Chrome shim is not included in this adapter release."), v;
      if (l.version === null)
        return c("Chrome shim can not determine version, not shimming."), v;
      c("adapter.js shimming chrome."), v.browserShim = chromeShim, shimAddIceCandidateNullOrEmpty(a, l), shimParameterlessSetLocalDescription(a), shimGetUserMedia$2(a, l), shimMediaStream(a), shimPeerConnection$1(a, l), shimOnTrack$1(a), shimAddTrackRemoveTrack(a, l), shimGetSendersWithDtmf(a), shimGetStats(a), shimSenderReceiverGetStats(a), fixNegotiationNeeded(a, l), shimRTCIceCandidate(a), shimRTCIceCandidateRelayProtocol(a), shimConnectionState(a), shimMaxMessageSize(a, l), shimSendThrowTypeError(a), removeExtmapAllowMixed(a, l);
      break;
    case "firefox":
      if (!firefoxShim || !shimPeerConnection || !u.shimFirefox)
        return c("Firefox shim is not included in this adapter release."), v;
      c("adapter.js shimming firefox."), v.browserShim = firefoxShim, shimAddIceCandidateNullOrEmpty(a, l), shimParameterlessSetLocalDescription(a), shimGetUserMedia$1(a, l), shimPeerConnection(a, l), shimOnTrack(a), shimRemoveStream(a), shimSenderGetStats(a), shimReceiverGetStats(a), shimRTCDataChannel(a), shimAddTransceiver(a), shimGetParameters(a), shimCreateOffer(a), shimCreateAnswer(a), shimRTCIceCandidate(a), shimConnectionState(a), shimMaxMessageSize(a, l), shimSendThrowTypeError(a);
      break;
    case "safari":
      if (!safariShim || !u.shimSafari)
        return c("Safari shim is not included in this adapter release."), v;
      c("adapter.js shimming safari."), v.browserShim = safariShim, shimAddIceCandidateNullOrEmpty(a, l), shimParameterlessSetLocalDescription(a), shimRTCIceServerUrls(a), shimCreateOfferLegacy(a), shimCallbacksAPI(a), shimLocalStreamsAPI(a), shimRemoteStreamsAPI(a), shimTrackEventTransceiver(a), shimGetUserMedia(a), shimAudioContext(a), shimRTCIceCandidate(a), shimRTCIceCandidateRelayProtocol(a), shimMaxMessageSize(a, l), shimSendThrowTypeError(a), removeExtmapAllowMixed(a, l);
      break;
    default:
      c("Unsupported browser!");
      break;
  }
  return v;
}
adapterFactory({
  window: typeof window > "u" ? void 0 : window
});
const DECRYPTION_FAILURE_TOLERANCE = 10, E2EE_FLAG = "lk_e2ee", SALT = "LKFrameEncryptionKey", KEY_PROVIDER_DEFAULTS = {
  sharedKey: !1,
  ratchetSalt: SALT,
  ratchetWindowSize: 8,
  failureTolerance: DECRYPTION_FAILURE_TOLERANCE,
  keyringSize: 16
};
var KeyProviderEvent;
(function(a) {
  a.SetKey = "setKey", a.RatchetRequest = "ratchetRequest", a.KeyRatcheted = "keyRatcheted";
})(KeyProviderEvent || (KeyProviderEvent = {}));
var KeyHandlerEvent;
(function(a) {
  a.KeyRatcheted = "keyRatcheted";
})(KeyHandlerEvent || (KeyHandlerEvent = {}));
var EncryptionEvent;
(function(a) {
  a.ParticipantEncryptionStatusChanged = "participantEncryptionStatusChanged", a.EncryptionError = "encryptionError";
})(EncryptionEvent || (EncryptionEvent = {}));
var CryptorEvent;
(function(a) {
  a.Error = "cryptorError";
})(CryptorEvent || (CryptorEvent = {}));
function isE2EESupported() {
  return isInsertableStreamSupported() || isScriptTransformSupported();
}
function isScriptTransformSupported() {
  return typeof window.RTCRtpScriptTransform < "u";
}
function isInsertableStreamSupported() {
  return typeof window.RTCRtpSender < "u" && // @ts-ignore
  typeof window.RTCRtpSender.prototype.createEncodedStreams < "u";
}
class BaseKeyProvider extends eventsExports$1.EventEmitter {
  constructor() {
    let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    super(), this.onKeyRatcheted = (c, l) => {
      livekitLogger.debug("key ratcheted event received", {
        material: c,
        keyIndex: l
      });
    }, this.keyInfoMap = /* @__PURE__ */ new Map(), this.options = Object.assign(Object.assign({}, KEY_PROVIDER_DEFAULTS), u), this.on(KeyProviderEvent.KeyRatcheted, this.onKeyRatcheted);
  }
  /**
   * callback to invoke once a key has been set for a participant
   * @param key
   * @param participantIdentity
   * @param keyIndex
   */
  onSetEncryptionKey(u, c, l) {
    const v = {
      key: u,
      participantIdentity: c,
      keyIndex: l
    };
    if (!this.options.sharedKey && !c)
      throw new Error("participant identity needs to be passed for encryption key if sharedKey option is false");
    this.keyInfoMap.set("".concat(c ?? "shared", "-").concat(l ?? 0), v), this.emit(KeyProviderEvent.SetKey, v);
  }
  getKeys() {
    return Array.from(this.keyInfoMap.values());
  }
  getOptions() {
    return this.options;
  }
  ratchetKey(u, c) {
    this.emit(KeyProviderEvent.RatchetRequest, u, c);
  }
}
class LivekitError extends Error {
  constructor(u, c) {
    super(c || "an error has occured"), this.code = u;
  }
}
class ConnectionError extends LivekitError {
  constructor(u, c, l) {
    super(1, u), this.status = l, this.reason = c;
  }
}
class DeviceUnsupportedError extends LivekitError {
  constructor(u) {
    super(21, u ?? "device is unsupported");
  }
}
class TrackInvalidError extends LivekitError {
  constructor(u) {
    super(20, u ?? "track is invalid");
  }
}
class UnsupportedServer extends LivekitError {
  constructor(u) {
    super(10, u ?? "unsupported server");
  }
}
class UnexpectedConnectionState extends LivekitError {
  constructor(u) {
    super(12, u ?? "unexpected connection state");
  }
}
class NegotiationError extends LivekitError {
  constructor(u) {
    super(13, u ?? "unable to negotiate");
  }
}
var MediaDeviceFailure;
(function(a) {
  a.PermissionDenied = "PermissionDenied", a.NotFound = "NotFound", a.DeviceInUse = "DeviceInUse", a.Other = "Other";
})(MediaDeviceFailure || (MediaDeviceFailure = {}));
(function(a) {
  function u(c) {
    if (c && "name" in c)
      return c.name === "NotFoundError" || c.name === "DevicesNotFoundError" ? a.NotFound : c.name === "NotAllowedError" || c.name === "PermissionDeniedError" ? a.PermissionDenied : c.name === "NotReadableError" || c.name === "TrackStartError" ? a.DeviceInUse : a.Other;
  }
  a.getFailure = u;
})(MediaDeviceFailure || (MediaDeviceFailure = {}));
var RoomEvent;
(function(a) {
  a.Connected = "connected", a.Reconnecting = "reconnecting", a.Reconnected = "reconnected", a.Disconnected = "disconnected", a.ConnectionStateChanged = "connectionStateChanged", a.MediaDevicesChanged = "mediaDevicesChanged", a.ParticipantConnected = "participantConnected", a.ParticipantDisconnected = "participantDisconnected", a.TrackPublished = "trackPublished", a.TrackSubscribed = "trackSubscribed", a.TrackSubscriptionFailed = "trackSubscriptionFailed", a.TrackUnpublished = "trackUnpublished", a.TrackUnsubscribed = "trackUnsubscribed", a.TrackMuted = "trackMuted", a.TrackUnmuted = "trackUnmuted", a.LocalTrackPublished = "localTrackPublished", a.LocalTrackUnpublished = "localTrackUnpublished", a.LocalAudioSilenceDetected = "localAudioSilenceDetected", a.ActiveSpeakersChanged = "activeSpeakersChanged", a.ParticipantMetadataChanged = "participantMetadataChanged", a.ParticipantNameChanged = "participantNameChanged", a.RoomMetadataChanged = "roomMetadataChanged", a.DataReceived = "dataReceived", a.ConnectionQualityChanged = "connectionQualityChanged", a.TrackStreamStateChanged = "trackStreamStateChanged", a.TrackSubscriptionPermissionChanged = "trackSubscriptionPermissionChanged", a.TrackSubscriptionStatusChanged = "trackSubscriptionStatusChanged", a.AudioPlaybackStatusChanged = "audioPlaybackChanged", a.VideoPlaybackStatusChanged = "videoPlaybackChanged", a.MediaDevicesError = "mediaDevicesError", a.ParticipantPermissionsChanged = "participantPermissionsChanged", a.SignalConnected = "signalConnected", a.RecordingStatusChanged = "recordingStatusChanged", a.ParticipantEncryptionStatusChanged = "participantEncryptionStatusChanged", a.EncryptionError = "encryptionError", a.DCBufferStatusChanged = "dcBufferStatusChanged", a.ActiveDeviceChanged = "activeDeviceChanged";
})(RoomEvent || (RoomEvent = {}));
var ParticipantEvent;
(function(a) {
  a.TrackPublished = "trackPublished", a.TrackSubscribed = "trackSubscribed", a.TrackSubscriptionFailed = "trackSubscriptionFailed", a.TrackUnpublished = "trackUnpublished", a.TrackUnsubscribed = "trackUnsubscribed", a.TrackMuted = "trackMuted", a.TrackUnmuted = "trackUnmuted", a.LocalTrackPublished = "localTrackPublished", a.LocalTrackUnpublished = "localTrackUnpublished", a.ParticipantMetadataChanged = "participantMetadataChanged", a.ParticipantNameChanged = "participantNameChanged", a.DataReceived = "dataReceived", a.IsSpeakingChanged = "isSpeakingChanged", a.ConnectionQualityChanged = "connectionQualityChanged", a.TrackStreamStateChanged = "trackStreamStateChanged", a.TrackSubscriptionPermissionChanged = "trackSubscriptionPermissionChanged", a.TrackSubscriptionStatusChanged = "trackSubscriptionStatusChanged", a.MediaDevicesError = "mediaDevicesError", a.AudioStreamAcquired = "audioStreamAcquired", a.ParticipantPermissionsChanged = "participantPermissionsChanged", a.PCTrackAdded = "pcTrackAdded";
})(ParticipantEvent || (ParticipantEvent = {}));
var EngineEvent;
(function(a) {
  a.TransportsCreated = "transportsCreated", a.Connected = "connected", a.Disconnected = "disconnected", a.Resuming = "resuming", a.Resumed = "resumed", a.Restarting = "restarting", a.Restarted = "restarted", a.SignalResumed = "signalResumed", a.SignalRestarted = "signalRestarted", a.Closing = "closing", a.MediaTrackAdded = "mediaTrackAdded", a.ActiveSpeakersUpdate = "activeSpeakersUpdate", a.DataPacketReceived = "dataPacketReceived", a.RTPVideoMapUpdate = "rtpVideoMapUpdate", a.DCBufferStatusChanged = "dcBufferStatusChanged", a.ParticipantUpdate = "participantUpdate", a.RoomUpdate = "roomUpdate", a.SpeakersChanged = "speakersChanged", a.StreamStateChanged = "streamStateChanged", a.ConnectionQualityUpdate = "connectionQualityUpdate", a.SubscriptionError = "subscriptionError", a.SubscriptionPermissionUpdate = "subscriptionPermissionUpdate", a.RemoteMute = "remoteMute", a.SubscribedQualityUpdate = "subscribedQualityUpdate", a.LocalTrackUnpublished = "localTrackUnpublished", a.Offline = "offline";
})(EngineEvent || (EngineEvent = {}));
var TrackEvent;
(function(a) {
  a.Message = "message", a.Muted = "muted", a.Unmuted = "unmuted", a.Restarted = "restarted", a.Ended = "ended", a.Subscribed = "subscribed", a.Unsubscribed = "unsubscribed", a.UpdateSettings = "updateSettings", a.UpdateSubscription = "updateSubscription", a.AudioPlaybackStarted = "audioPlaybackStarted", a.AudioPlaybackFailed = "audioPlaybackFailed", a.AudioSilenceDetected = "audioSilenceDetected", a.VisibilityChanged = "visibilityChanged", a.VideoDimensionsChanged = "videoDimensionsChanged", a.VideoPlaybackStarted = "videoPlaybackStarted", a.VideoPlaybackFailed = "videoPlaybackFailed", a.ElementAttached = "elementAttached", a.ElementDetached = "elementDetached", a.UpstreamPaused = "upstreamPaused", a.UpstreamResumed = "upstreamResumed", a.SubscriptionPermissionChanged = "subscriptionPermissionChanged", a.SubscriptionStatusChanged = "subscriptionStatusChanged", a.SubscriptionFailed = "subscriptionFailed", a.TrackProcessorUpdate = "trackProcessorUpdate";
})(TrackEvent || (TrackEvent = {}));
function r$1(a, u, c) {
  var l, v, p;
  u === void 0 && (u = 50), c === void 0 && (c = {});
  var _ = (l = c.isImmediate) != null && l, k = (v = c.callback) != null && v, O = c.maxWait, D = Date.now(), F = [];
  function H() {
    if (O !== void 0) {
      var ee = Date.now() - D;
      if (ee + u >= O)
        return O - ee;
    }
    return u;
  }
  var Z = function() {
    var ee = [].slice.call(arguments), X = this;
    return new Promise(function(ne, Q) {
      var ae = _ && p === void 0;
      if (p !== void 0 && clearTimeout(p), p = setTimeout(function() {
        if (p = void 0, D = Date.now(), !_) {
          var ue = a.apply(X, ee);
          k && k(ue), F.forEach(function(he) {
            return (0, he.resolve)(ue);
          }), F = [];
        }
      }, H()), ae) {
        var j = a.apply(X, ee);
        return k && k(j), ne(j);
      }
      F.push({
        resolve: ne,
        reject: Q
      });
    });
  };
  return Z.cancel = function(ee) {
    p !== void 0 && clearTimeout(p), F.forEach(function(X) {
      return (0, X.reject)(ee);
    }), F = [];
  }, Z;
}
const commonVersionIdentifier = /version\/(\d+(\.?_?\d+)+)/i;
let browserDetails;
function getBrowser(a) {
  let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
  if (typeof a > "u" && typeof navigator > "u")
    return;
  const c = (a ?? navigator.userAgent).toLowerCase();
  if (browserDetails === void 0 || u) {
    const l = browsersList.find((v) => {
      let {
        test: p
      } = v;
      return p.test(c);
    });
    browserDetails = l == null ? void 0 : l.describe(c);
  }
  return browserDetails;
}
const browsersList = [
  {
    test: /firefox|iceweasel|fxios/i,
    describe(a) {
      return {
        name: "Firefox",
        version: getMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, a),
        os: a.toLowerCase().includes("fxios") ? "iOS" : void 0
      };
    }
  },
  {
    test: /chrom|crios|crmo/i,
    describe(a) {
      return {
        name: "Chrome",
        version: getMatch(/(?:chrome|chromium|crios|crmo)\/(\d+(\.?_?\d+)+)/i, a),
        os: a.toLowerCase().includes("crios") ? "iOS" : void 0
      };
    }
  },
  /* Safari */
  {
    test: /safari|applewebkit/i,
    describe(a) {
      return {
        name: "Safari",
        version: getMatch(commonVersionIdentifier, a),
        os: a.includes("mobile/") ? "iOS" : "macOS"
      };
    }
  }
];
function getMatch(a, u) {
  let c = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
  const l = u.match(a);
  return l && l.length >= c && l[c] || "";
}
var version$1$1 = "2.0.10";
const version$3 = version$1$1, protocolVersion = 12;
class CriticalTimers {
}
CriticalTimers.setTimeout = function() {
  return setTimeout(...arguments);
};
CriticalTimers.setInterval = function() {
  return setInterval(...arguments);
};
CriticalTimers.clearTimeout = function() {
  return clearTimeout(...arguments);
};
CriticalTimers.clearInterval = function() {
  return clearInterval(...arguments);
};
class VideoPreset {
  constructor(u, c, l, v, p) {
    if (typeof u == "object")
      this.width = u.width, this.height = u.height, this.aspectRatio = u.aspectRatio, this.encoding = {
        maxBitrate: u.maxBitrate,
        maxFramerate: u.maxFramerate,
        priority: u.priority
      };
    else if (c !== void 0 && l !== void 0)
      this.width = u, this.height = c, this.aspectRatio = u / c, this.encoding = {
        maxBitrate: l,
        maxFramerate: v,
        priority: p
      };
    else
      throw new TypeError("Unsupported options: provide at least width, height and maxBitrate");
  }
  get resolution() {
    return {
      width: this.width,
      height: this.height,
      frameRate: this.encoding.maxFramerate,
      aspectRatio: this.aspectRatio
    };
  }
}
const backupCodecs = ["vp8", "h264"], videoCodecs = ["vp8", "h264", "vp9", "av1"];
function isBackupCodec(a) {
  return !!backupCodecs.find((u) => u === a);
}
var AudioPresets;
(function(a) {
  a.telephone = {
    maxBitrate: 12e3
  }, a.speech = {
    maxBitrate: 2e4
  }, a.music = {
    maxBitrate: 32e3
  }, a.musicStereo = {
    maxBitrate: 48e3
  }, a.musicHighQuality = {
    maxBitrate: 64e3
  }, a.musicHighQualityStereo = {
    maxBitrate: 96e3
  };
})(AudioPresets || (AudioPresets = {}));
const VideoPresets = {
  h90: new VideoPreset(160, 90, 9e4, 20),
  h180: new VideoPreset(320, 180, 16e4, 20),
  h216: new VideoPreset(384, 216, 18e4, 20),
  h360: new VideoPreset(640, 360, 45e4, 20),
  h540: new VideoPreset(960, 540, 8e5, 25),
  h720: new VideoPreset(1280, 720, 17e5, 30),
  h1080: new VideoPreset(1920, 1080, 3e6, 30),
  h1440: new VideoPreset(2560, 1440, 5e6, 30),
  h2160: new VideoPreset(3840, 2160, 8e6, 30)
}, VideoPresets43 = {
  h120: new VideoPreset(160, 120, 7e4, 20),
  h180: new VideoPreset(240, 180, 125e3, 20),
  h240: new VideoPreset(320, 240, 14e4, 20),
  h360: new VideoPreset(480, 360, 33e4, 20),
  h480: new VideoPreset(640, 480, 5e5, 20),
  h540: new VideoPreset(720, 540, 6e5, 25),
  h720: new VideoPreset(960, 720, 13e5, 30),
  h1080: new VideoPreset(1440, 1080, 23e5, 30),
  h1440: new VideoPreset(1920, 1440, 38e5, 30)
}, ScreenSharePresets = {
  h360fps3: new VideoPreset(640, 360, 2e5, 3, "medium"),
  h360fps15: new VideoPreset(640, 360, 4e5, 15, "medium"),
  h720fps5: new VideoPreset(1280, 720, 8e5, 5, "medium"),
  h720fps15: new VideoPreset(1280, 720, 15e5, 15, "medium"),
  h720fps30: new VideoPreset(1280, 720, 2e6, 30, "medium"),
  h1080fps15: new VideoPreset(1920, 1080, 25e5, 15, "medium"),
  h1080fps30: new VideoPreset(1920, 1080, 5e6, 30, "medium"),
  // original resolution, without resizing
  original: new VideoPreset(0, 0, 7e6, 30, "medium")
};
function cloneDeep(a) {
  if (!(typeof a > "u"))
    return typeof structuredClone == "function" ? structuredClone(a) : JSON.parse(JSON.stringify(a));
}
const BACKGROUND_REACTION_DELAY = 5e3, recycledElements = [];
var VideoQuality;
(function(a) {
  a[a.LOW = 0] = "LOW", a[a.MEDIUM = 1] = "MEDIUM", a[a.HIGH = 2] = "HIGH";
})(VideoQuality || (VideoQuality = {}));
class Track extends eventsExports$1.EventEmitter {
  constructor(u, c) {
    let l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var v;
    super(), this.attachedElements = [], this.isMuted = !1, this.streamState = Track.StreamState.Active, this.isInBackground = !1, this._currentBitrate = 0, this.log = livekitLogger, this.appVisibilityChangedListener = () => {
      this.backgroundTimeout && clearTimeout(this.backgroundTimeout), document.visibilityState === "hidden" ? this.backgroundTimeout = setTimeout(() => this.handleAppVisibilityChanged(), BACKGROUND_REACTION_DELAY) : this.handleAppVisibilityChanged();
    }, this.log = getLogger((v = l.loggerName) !== null && v !== void 0 ? v : LoggerNames.Track), this.loggerContextCb = l.loggerContextCb, this.setMaxListeners(100), this.kind = c, this._mediaStreamTrack = u, this._mediaStreamID = u.id, this.source = Track.Source.Unknown;
  }
  get logContext() {
    var u;
    return Object.assign(Object.assign({}, (u = this.loggerContextCb) === null || u === void 0 ? void 0 : u.call(this)), getLogContextFromTrack(this));
  }
  /** current receive bits per second */
  get currentBitrate() {
    return this._currentBitrate;
  }
  get mediaStreamTrack() {
    return this._mediaStreamTrack;
  }
  /**
   * @internal
   * used for keep mediaStream's first id, since it's id might change
   * if we disable/enable a track
   */
  get mediaStreamID() {
    return this._mediaStreamID;
  }
  attach(u) {
    let c = "audio";
    this.kind === Track.Kind.Video && (c = "video"), this.attachedElements.length === 0 && Track.Kind.Video && this.addAppVisibilityListener(), u || (c === "audio" && (recycledElements.forEach((p) => {
      p.parentElement === null && !u && (u = p);
    }), u && recycledElements.splice(recycledElements.indexOf(u), 1)), u || (u = document.createElement(c))), this.attachedElements.includes(u) || this.attachedElements.push(u), attachToElement(this.mediaStreamTrack, u);
    const l = u.srcObject.getTracks(), v = l.some((p) => p.kind === "audio");
    return u.play().then(() => {
      this.emit(v ? TrackEvent.AudioPlaybackStarted : TrackEvent.VideoPlaybackStarted);
    }).catch((p) => {
      p.name === "NotAllowedError" ? this.emit(v ? TrackEvent.AudioPlaybackFailed : TrackEvent.VideoPlaybackFailed, p) : p.name === "AbortError" ? livekitLogger.debug("".concat(v ? "audio" : "video", " playback aborted, likely due to new play request")) : livekitLogger.warn("could not playback ".concat(v ? "audio" : "video"), p), v && u && l.some((_) => _.kind === "video") && p.name === "NotAllowedError" && (u.muted = !0, u.play().catch(() => {
      }));
    }), this.emit(TrackEvent.ElementAttached, u), u;
  }
  detach(u) {
    try {
      if (u) {
        detachTrack(this.mediaStreamTrack, u);
        const l = this.attachedElements.indexOf(u);
        return l >= 0 && (this.attachedElements.splice(l, 1), this.recycleElement(u), this.emit(TrackEvent.ElementDetached, u)), u;
      }
      const c = [];
      return this.attachedElements.forEach((l) => {
        detachTrack(this.mediaStreamTrack, l), c.push(l), this.recycleElement(l), this.emit(TrackEvent.ElementDetached, l);
      }), this.attachedElements = [], c;
    } finally {
      this.attachedElements.length === 0 && this.removeAppVisibilityListener();
    }
  }
  stop() {
    this.stopMonitor(), this._mediaStreamTrack.stop();
  }
  enable() {
    this._mediaStreamTrack.enabled = !0;
  }
  disable() {
    this._mediaStreamTrack.enabled = !1;
  }
  /* @internal */
  stopMonitor() {
    this.monitorInterval && clearInterval(this.monitorInterval);
  }
  /** @internal */
  updateLoggerOptions(u) {
    u.loggerName && (this.log = getLogger(u.loggerName)), u.loggerContextCb && (this.loggerContextCb = u.loggerContextCb);
  }
  recycleElement(u) {
    if (u instanceof HTMLAudioElement) {
      let c = !0;
      u.pause(), recycledElements.forEach((l) => {
        l.parentElement || (c = !1);
      }), c && recycledElements.push(u);
    }
  }
  handleAppVisibilityChanged() {
    return __awaiter$3(this, void 0, void 0, function* () {
      this.isInBackground = document.visibilityState === "hidden";
    });
  }
  addAppVisibilityListener() {
    isWeb() ? (this.isInBackground = document.visibilityState === "hidden", document.addEventListener("visibilitychange", this.appVisibilityChangedListener)) : this.isInBackground = !1;
  }
  removeAppVisibilityListener() {
    isWeb() && document.removeEventListener("visibilitychange", this.appVisibilityChangedListener);
  }
}
function attachToElement(a, u) {
  let c;
  u.srcObject instanceof MediaStream ? c = u.srcObject : c = new MediaStream();
  let l;
  a.kind === "audio" ? l = c.getAudioTracks() : l = c.getVideoTracks(), l.includes(a) || (l.forEach((v) => {
    c.removeTrack(v);
  }), c.addTrack(a)), (!isSafari() || !(u instanceof HTMLVideoElement)) && (u.autoplay = !0), u.muted = c.getAudioTracks().length === 0, u instanceof HTMLVideoElement && (u.playsInline = !0), u.srcObject !== c && (u.srcObject = c, (isSafari() || isFireFox()) && u instanceof HTMLVideoElement && setTimeout(() => {
    u.srcObject = c, u.play().catch(() => {
    });
  }, 0));
}
function detachTrack(a, u) {
  if (u.srcObject instanceof MediaStream) {
    const c = u.srcObject;
    c.removeTrack(a), c.getTracks().length > 0 ? u.srcObject = c : u.srcObject = null;
  }
}
(function(a) {
  let u;
  (function(D) {
    D.Audio = "audio", D.Video = "video", D.Unknown = "unknown";
  })(u = a.Kind || (a.Kind = {}));
  let c;
  (function(D) {
    D.Camera = "camera", D.Microphone = "microphone", D.ScreenShare = "screen_share", D.ScreenShareAudio = "screen_share_audio", D.Unknown = "unknown";
  })(c = a.Source || (a.Source = {}));
  let l;
  (function(D) {
    D.Active = "active", D.Paused = "paused", D.Unknown = "unknown";
  })(l = a.StreamState || (a.StreamState = {}));
  function v(D) {
    switch (D) {
      case u.Audio:
        return TrackType.AUDIO;
      case u.Video:
        return TrackType.VIDEO;
      default:
        return TrackType.DATA;
    }
  }
  a.kindToProto = v;
  function p(D) {
    switch (D) {
      case TrackType.AUDIO:
        return u.Audio;
      case TrackType.VIDEO:
        return u.Video;
      default:
        return u.Unknown;
    }
  }
  a.kindFromProto = p;
  function _(D) {
    switch (D) {
      case c.Camera:
        return TrackSource.CAMERA;
      case c.Microphone:
        return TrackSource.MICROPHONE;
      case c.ScreenShare:
        return TrackSource.SCREEN_SHARE;
      case c.ScreenShareAudio:
        return TrackSource.SCREEN_SHARE_AUDIO;
      default:
        return TrackSource.UNKNOWN;
    }
  }
  a.sourceToProto = _;
  function k(D) {
    switch (D) {
      case TrackSource.CAMERA:
        return c.Camera;
      case TrackSource.MICROPHONE:
        return c.Microphone;
      case TrackSource.SCREEN_SHARE:
        return c.ScreenShare;
      case TrackSource.SCREEN_SHARE_AUDIO:
        return c.ScreenShareAudio;
      default:
        return c.Unknown;
    }
  }
  a.sourceFromProto = k;
  function O(D) {
    switch (D) {
      case StreamState.ACTIVE:
        return l.Active;
      case StreamState.PAUSED:
        return l.Paused;
      default:
        return l.Unknown;
    }
  }
  a.streamStateFromProto = O;
})(Track || (Track = {}));
function mergeDefaultOptions(a, u, c) {
  var l;
  const v = (l = cloneDeep(a)) !== null && l !== void 0 ? l : {};
  return v.audio === !0 && (v.audio = {}), v.video === !0 && (v.video = {}), v.audio && mergeObjectWithoutOverwriting(v.audio, u), v.video && mergeObjectWithoutOverwriting(v.video, c), v;
}
function mergeObjectWithoutOverwriting(a, u) {
  return Object.keys(u).forEach((c) => {
    a[c] === void 0 && (a[c] = u[c]);
  }), a;
}
function constraintsForOptions(a) {
  const u = {};
  if (a.video)
    if (typeof a.video == "object") {
      const c = {}, l = c, v = a.video;
      Object.keys(v).forEach((p) => {
        switch (p) {
          case "resolution":
            mergeObjectWithoutOverwriting(l, v.resolution);
            break;
          default:
            l[p] = v[p];
        }
      }), u.video = c;
    } else
      u.video = a.video;
  else
    u.video = !1;
  return a.audio ? typeof a.audio == "object" ? u.audio = a.audio : u.audio = !0 : u.audio = !1, u;
}
function detectSilence(a) {
  let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 200;
  return __awaiter$3(this, void 0, void 0, function* () {
    const c = getNewAudioContext();
    if (c) {
      const l = c.createAnalyser();
      l.fftSize = 2048;
      const v = l.frequencyBinCount, p = new Uint8Array(v);
      c.createMediaStreamSource(new MediaStream([a.mediaStreamTrack])).connect(l), yield sleep(u), l.getByteTimeDomainData(p);
      const k = p.some((O) => O !== 128 && O !== 0);
      return c.close(), !k;
    }
    return !1;
  });
}
function getNewAudioContext() {
  const a = (
    // @ts-ignore
    typeof window < "u" && (window.AudioContext || window.webkitAudioContext)
  );
  if (a)
    return new a({
      latencyHint: "interactive"
    });
}
function sourceToKind(a) {
  return a === Track.Source.Microphone ? "audioinput" : a === Track.Source.Camera ? "videoinput" : void 0;
}
function screenCaptureToDisplayMediaStreamOptions(a) {
  var u, c;
  let l = (u = a.video) !== null && u !== void 0 ? u : !0;
  return a.resolution && a.resolution.width > 0 && a.resolution.height > 0 && (l = typeof l == "boolean" ? {} : l, isSafari() ? l = Object.assign(Object.assign({}, l), {
    width: {
      max: a.resolution.width
    },
    height: {
      max: a.resolution.height
    },
    frameRate: a.resolution.frameRate
  }) : l = Object.assign(Object.assign({}, l), {
    width: {
      ideal: a.resolution.width
    },
    height: {
      ideal: a.resolution.height
    },
    frameRate: a.resolution.frameRate
  })), {
    audio: (c = a.audio) !== null && c !== void 0 ? c : !1,
    video: l,
    // @ts-expect-error support for experimental display media features
    controller: a.controller,
    selfBrowserSurface: a.selfBrowserSurface,
    surfaceSwitching: a.surfaceSwitching,
    systemAudio: a.systemAudio,
    preferCurrentTab: a.preferCurrentTab
  };
}
function mimeTypeToVideoCodecString(a) {
  const u = a.split("/")[1].toLowerCase();
  if (!videoCodecs.includes(u))
    throw Error("Video codec not supported: ".concat(u));
  return u;
}
function getTrackPublicationInfo(a) {
  const u = [];
  return a.forEach((c) => {
    c.track !== void 0 && u.push(new TrackPublishedResponse({
      cid: c.track.mediaStreamID,
      track: c.trackInfo
    }));
  }), u;
}
function getLogContextFromTrack(a) {
  return a instanceof Track ? {
    trackID: a.sid,
    source: a.source,
    muted: a.isMuted,
    enabled: a.mediaStreamTrack.enabled,
    kind: a.kind,
    streamID: a.mediaStreamID,
    streamTrackID: a.mediaStreamTrack.id
  } : {
    trackID: a.trackSid,
    enabled: a.isEnabled,
    muted: a.isMuted,
    trackInfo: Object.assign({
      mimeType: a.mimeType,
      name: a.trackName,
      encrypted: a.isEncrypted,
      kind: a.kind,
      source: a.source
    }, a.track ? getLogContextFromTrack(a.track) : {})
  };
}
const separator = "|", ddExtensionURI = "https://aomediacodec.github.io/av1-rtp-spec/#dependency-descriptor-rtp-header-extension";
function unpackStreamId(a) {
  const u = a.split(separator);
  return u.length > 1 ? [u[0], a.substr(u[0].length + 1)] : [a, ""];
}
function sleep(a) {
  return __awaiter$3(this, void 0, void 0, function* () {
    return new Promise((u) => CriticalTimers.setTimeout(u, a));
  });
}
function supportsTransceiver() {
  return "addTransceiver" in RTCPeerConnection.prototype;
}
function supportsAddTrack() {
  return "addTrack" in RTCPeerConnection.prototype;
}
function supportsAV1() {
  if (!("getCapabilities" in RTCRtpSender) || isSafari())
    return !1;
  const a = RTCRtpSender.getCapabilities("video");
  let u = !1;
  if (a) {
    for (const c of a.codecs)
      if (c.mimeType === "video/AV1") {
        u = !0;
        break;
      }
  }
  return u;
}
function supportsVP9() {
  if (!("getCapabilities" in RTCRtpSender) || isFireFox())
    return !1;
  if (isSafari()) {
    const c = getBrowser();
    if (c != null && c.version && compareVersions(c.version, "16") < 0)
      return !1;
  }
  const a = RTCRtpSender.getCapabilities("video");
  let u = !1;
  if (a) {
    for (const c of a.codecs)
      if (c.mimeType === "video/VP9") {
        u = !0;
        break;
      }
  }
  return u;
}
function isSVCCodec(a) {
  return a === "av1" || a === "vp9";
}
function supportsSetSinkId(a) {
  return document ? (a || (a = document.createElement("audio")), "setSinkId" in a) : !1;
}
const setCodecPreferencesVersions = {
  Chrome: "100",
  Safari: "15",
  Firefox: "100"
};
function supportsSetCodecPreferences(a) {
  if (!isWeb() || !("setCodecPreferences" in a))
    return !1;
  const u = getBrowser();
  if (!(u != null && u.name) || !u.version)
    return !1;
  const c = setCodecPreferencesVersions[u.name];
  return c ? compareVersions(u.version, c) >= 0 : !1;
}
function isBrowserSupported() {
  return typeof RTCPeerConnection > "u" ? !1 : supportsTransceiver() || supportsAddTrack();
}
function isFireFox() {
  var a;
  return ((a = getBrowser()) === null || a === void 0 ? void 0 : a.name) === "Firefox";
}
function isSafari() {
  var a;
  return ((a = getBrowser()) === null || a === void 0 ? void 0 : a.name) === "Safari";
}
function isSafari17() {
  const a = getBrowser();
  return (a == null ? void 0 : a.name) === "Safari" && a.version.startsWith("17.");
}
function isMobile() {
  return isWeb() ? /Tablet|iPad|Mobile|Android|BlackBerry/.test(navigator.userAgent) : !1;
}
function isWeb() {
  return typeof document < "u";
}
function isReactNative() {
  return navigator.product == "ReactNative";
}
function isCloud(a) {
  return a.hostname.endsWith(".livekit.cloud") || a.hostname.endsWith(".livekit.run");
}
function getLKReactNativeInfo() {
  if (global$1 && global$1.LiveKitReactNativeGlobal)
    return global$1.LiveKitReactNativeGlobal;
}
function getReactNativeOs() {
  if (!isReactNative())
    return;
  let a = getLKReactNativeInfo();
  if (a)
    return a.platform;
}
function getDevicePixelRatio() {
  if (isWeb())
    return window.devicePixelRatio;
  if (isReactNative()) {
    let a = getLKReactNativeInfo();
    if (a)
      return a.devicePixelRatio;
  }
  return 1;
}
function compareVersions(a, u) {
  const c = a.split("."), l = u.split("."), v = Math.min(c.length, l.length);
  for (let p = 0; p < v; ++p) {
    const _ = parseInt(c[p], 10), k = parseInt(l[p], 10);
    if (_ > k)
      return 1;
    if (_ < k)
      return -1;
    if (p === v - 1 && _ === k)
      return 0;
  }
  return a === "" && u !== "" ? -1 : u === "" ? 1 : c.length == l.length ? 0 : c.length < l.length ? -1 : 1;
}
function roDispatchCallback(a) {
  for (const u of a)
    u.target.handleResize(u);
}
function ioDispatchCallback(a) {
  for (const u of a)
    u.target.handleVisibilityChanged(u);
}
let resizeObserver = null;
const getResizeObserver = () => (resizeObserver || (resizeObserver = new ResizeObserver(roDispatchCallback)), resizeObserver);
let intersectionObserver = null;
const getIntersectionObserver = () => (intersectionObserver || (intersectionObserver = new IntersectionObserver(ioDispatchCallback, {
  root: null,
  rootMargin: "0px"
})), intersectionObserver);
function getClientInfo() {
  var a;
  const u = new ClientInfo({
    sdk: ClientInfo_SDK.JS,
    protocol: protocolVersion,
    version: version$3
  });
  return isReactNative() && (u.os = (a = getReactNativeOs()) !== null && a !== void 0 ? a : ""), u;
}
function createDummyVideoStreamTrack() {
  let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 16, u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 16, c = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, l = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
  const v = document.createElement("canvas");
  v.width = a, v.height = u;
  const p = v.getContext("2d");
  p == null || p.fillRect(0, 0, v.width, v.height), l && p && (p.beginPath(), p.arc(a / 2, u / 2, 50, 0, Math.PI * 2, !0), p.closePath(), p.fillStyle = "grey", p.fill());
  const _ = v.captureStream(), [k] = _.getTracks();
  if (!k)
    throw Error("Could not get empty media stream video track");
  return k.enabled = c, k;
}
let emptyAudioStreamTrack;
function getEmptyAudioStreamTrack() {
  if (!emptyAudioStreamTrack) {
    const a = new AudioContext(), u = a.createOscillator(), c = a.createGain();
    c.gain.setValueAtTime(0, 0);
    const l = a.createMediaStreamDestination();
    if (u.connect(c), c.connect(l), u.start(), [emptyAudioStreamTrack] = l.stream.getAudioTracks(), !emptyAudioStreamTrack)
      throw Error("Could not get empty media stream audio track");
    emptyAudioStreamTrack.enabled = !1;
  }
  return emptyAudioStreamTrack.clone();
}
class Future {
  constructor(u, c) {
    this.onFinally = c, this.promise = new Promise((l, v) => __awaiter$3(this, void 0, void 0, function* () {
      this.resolve = l, this.reject = v, u && (yield u(l, v));
    })).finally(() => {
      var l;
      return (l = this.onFinally) === null || l === void 0 ? void 0 : l.call(this);
    });
  }
}
class Mutex {
  constructor() {
    this._locking = Promise.resolve(), this._locks = 0;
  }
  isLocked() {
    return this._locks > 0;
  }
  lock() {
    this._locks += 1;
    let u;
    const c = new Promise((v) => u = () => {
      this._locks -= 1, v();
    }), l = this._locking.then(() => u);
    return this._locking = this._locking.then(() => c), l;
  }
}
function isVideoCodec(a) {
  return videoCodecs.includes(a);
}
function unwrapConstraint(a) {
  if (typeof a == "string")
    return a;
  if (Array.isArray(a))
    return a[0];
  if (a.exact)
    return Array.isArray(a.exact) ? a.exact[0] : a.exact;
  if (a.ideal)
    return Array.isArray(a.ideal) ? a.ideal[0] : a.ideal;
  throw Error("could not unwrap constraint");
}
function toWebsocketUrl(a) {
  return a.startsWith("http") ? a.replace(/^(http)/, "ws") : a;
}
function toHttpUrl(a) {
  return a.startsWith("ws") ? a.replace(/^(ws)/, "http") : a;
}
const defaultId = "default";
class DeviceManager {
  static getInstance() {
    return this.instance === void 0 && (this.instance = new DeviceManager()), this.instance;
  }
  getDevices(u) {
    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
    var l;
    return __awaiter$3(this, void 0, void 0, function* () {
      if (((l = DeviceManager.userMediaPromiseMap) === null || l === void 0 ? void 0 : l.size) > 0) {
        livekitLogger.debug("awaiting getUserMedia promise");
        try {
          u ? yield DeviceManager.userMediaPromiseMap.get(u) : yield Promise.all(DeviceManager.userMediaPromiseMap.values());
        } catch {
          livekitLogger.warn("error waiting for media permissons");
        }
      }
      let v = yield navigator.mediaDevices.enumerateDevices();
      if (c && // for safari we need to skip this check, as otherwise it will re-acquire user media and fail on iOS https://bugs.webkit.org/show_bug.cgi?id=179363
      !(isSafari() && this.hasDeviceInUse(u)) && (v.length === 0 || v.some((_) => {
        const k = _.label === "", O = u ? _.kind === u : !0;
        return k && O;
      }))) {
        const _ = {
          video: u !== "audioinput" && u !== "audiooutput",
          audio: u !== "videoinput"
        }, k = yield navigator.mediaDevices.getUserMedia(_);
        v = yield navigator.mediaDevices.enumerateDevices(), k.getTracks().forEach((O) => {
          O.stop();
        });
      }
      return u && (v = v.filter((p) => p.kind === u)), v;
    });
  }
  normalizeDeviceId(u, c, l) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (c !== defaultId)
        return c;
      const v = yield this.getDevices(u), p = new Map(v.map((k) => [k.groupId, 0]));
      v.forEach((k) => {
        var O;
        return p.set(k.groupId, ((O = p.get(k.groupId)) !== null && O !== void 0 ? O : 0) + 1);
      });
      const _ = v.find((k) => {
        var O;
        return (l === k.groupId || ((O = p.get(k.groupId)) !== null && O !== void 0 ? O : 0) > 1) && k.deviceId !== defaultId;
      });
      return _ == null ? void 0 : _.deviceId;
    });
  }
  hasDeviceInUse(u) {
    return u ? DeviceManager.userMediaPromiseMap.has(u) : DeviceManager.userMediaPromiseMap.size > 0;
  }
}
DeviceManager.mediaDeviceKinds = ["audioinput", "audiooutput", "videoinput"];
DeviceManager.userMediaPromiseMap = /* @__PURE__ */ new Map();
const defaultDimensionsTimeout = 1e3;
class LocalTrack extends Track {
  get constraints() {
    return this._constraints;
  }
  /**
   *
   * @param mediaTrack
   * @param kind
   * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks
   * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK
   */
  constructor(u, c, l) {
    let v = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1, p = arguments.length > 4 ? arguments[4] : void 0;
    super(u, c, p), this._isUpstreamPaused = !1, this.handleTrackMuteEvent = () => this.debouncedTrackMuteHandler().catch(() => this.log.debug("track mute bounce got cancelled by an unmute event", this.logContext)), this.debouncedTrackMuteHandler = r$1(() => __awaiter$3(this, void 0, void 0, function* () {
      yield this.pauseUpstream();
    }), 5e3), this.handleTrackUnmuteEvent = () => __awaiter$3(this, void 0, void 0, function* () {
      this.debouncedTrackMuteHandler.cancel("unmute"), yield this.resumeUpstream();
    }), this.handleEnded = () => {
      this.isInBackground && (this.reacquireTrack = !0), this._mediaStreamTrack.removeEventListener("mute", this.handleTrackMuteEvent), this._mediaStreamTrack.removeEventListener("unmute", this.handleTrackUnmuteEvent), this.emit(TrackEvent.Ended, this);
    }, this.reacquireTrack = !1, this.providedByUser = v, this.muteLock = new Mutex(), this.pauseUpstreamLock = new Mutex(), this.processorLock = new Mutex(), this.restartLock = new Mutex(), this.setMediaStreamTrack(u, !0), this._constraints = u.getConstraints(), l && (this._constraints = l);
  }
  get id() {
    return this._mediaStreamTrack.id;
  }
  get dimensions() {
    if (this.kind !== Track.Kind.Video)
      return;
    const {
      width: u,
      height: c
    } = this._mediaStreamTrack.getSettings();
    if (u && c)
      return {
        width: u,
        height: c
      };
  }
  get isUpstreamPaused() {
    return this._isUpstreamPaused;
  }
  get isUserProvided() {
    return this.providedByUser;
  }
  get mediaStreamTrack() {
    var u, c;
    return (c = (u = this.processor) === null || u === void 0 ? void 0 : u.processedTrack) !== null && c !== void 0 ? c : this._mediaStreamTrack;
  }
  setMediaStreamTrack(u, c) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (u === this._mediaStreamTrack && !c)
        return;
      this._mediaStreamTrack && (this.attachedElements.forEach((v) => {
        detachTrack(this._mediaStreamTrack, v);
      }), this.debouncedTrackMuteHandler.cancel("new-track"), this._mediaStreamTrack.removeEventListener("ended", this.handleEnded), this._mediaStreamTrack.removeEventListener("mute", this.handleTrackMuteEvent), this._mediaStreamTrack.removeEventListener("unmute", this.handleTrackUnmuteEvent)), this.mediaStream = new MediaStream([u]), u && (u.addEventListener("ended", this.handleEnded), u.addEventListener("mute", this.handleTrackMuteEvent), u.addEventListener("unmute", this.handleTrackUnmuteEvent), this._constraints = u.getConstraints());
      let l;
      if (this.processor && u) {
        const v = yield this.processorLock.lock();
        try {
          if (this.log.debug("restarting processor", this.logContext), this.kind === "unknown")
            throw TypeError("cannot set processor on track of unknown kind");
          this.processorElement && (attachToElement(u, this.processorElement), this.processorElement.muted = !0), yield this.processor.restart({
            track: u,
            kind: this.kind,
            element: this.processorElement
          }), l = this.processor.processedTrack;
        } finally {
          v();
        }
      }
      this.sender && (yield this.sender.replaceTrack(l ?? u)), !this.providedByUser && this._mediaStreamTrack !== u && this._mediaStreamTrack.stop(), this._mediaStreamTrack = u, u && (this._mediaStreamTrack.enabled = !this.isMuted, yield this.resumeUpstream(), this.attachedElements.forEach((v) => {
        attachToElement(l ?? u, v);
      }));
    });
  }
  waitForDimensions() {
    let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : defaultDimensionsTimeout;
    var c;
    return __awaiter$3(this, void 0, void 0, function* () {
      if (this.kind === Track.Kind.Audio)
        throw new Error("cannot get dimensions for audio tracks");
      ((c = getBrowser()) === null || c === void 0 ? void 0 : c.os) === "iOS" && (yield sleep(10));
      const l = Date.now();
      for (; Date.now() - l < u; ) {
        const v = this.dimensions;
        if (v)
          return v;
        yield sleep(50);
      }
      throw new TrackInvalidError("unable to get track dimensions after timeout");
    });
  }
  /**
   * @returns DeviceID of the device that is currently being used for this track
   */
  getDeviceId() {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (this.source === Track.Source.ScreenShare)
        return;
      const {
        deviceId: u,
        groupId: c
      } = this._mediaStreamTrack.getSettings(), l = this.kind === Track.Kind.Audio ? "audioinput" : "videoinput";
      return DeviceManager.getInstance().normalizeDeviceId(l, u, c);
    });
  }
  mute() {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this.setTrackMuted(!0), this;
    });
  }
  unmute() {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this.setTrackMuted(!1), this;
    });
  }
  replaceTrack(u, c) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!this.sender)
        throw new TrackInvalidError("unable to replace an unpublished track");
      let l, v;
      return typeof c == "boolean" ? l = c : c !== void 0 && (l = c.userProvidedTrack, v = c.stopProcessor), this.providedByUser = l ?? !0, this.log.debug("replace MediaStreamTrack", this.logContext), yield this.setMediaStreamTrack(u), v && this.processor && (yield this.stopProcessor()), this;
    });
  }
  restart(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      const c = yield this.restartLock.lock();
      try {
        u || (u = this._constraints), this.log.debug("restarting track with constraints", Object.assign(Object.assign({}, this.logContext), {
          constraints: u
        }));
        const l = {
          audio: !1,
          video: !1
        };
        this.kind === Track.Kind.Video ? l.video = u : l.audio = u, this.attachedElements.forEach((_) => {
          detachTrack(this.mediaStreamTrack, _);
        }), this._mediaStreamTrack.removeEventListener("ended", this.handleEnded), this._mediaStreamTrack.stop();
        const p = (yield navigator.mediaDevices.getUserMedia(l)).getTracks()[0];
        return p.addEventListener("ended", this.handleEnded), this.log.debug("re-acquired MediaStreamTrack", this.logContext), yield this.setMediaStreamTrack(p), this._constraints = u, this.emit(TrackEvent.Restarted, this), this;
      } finally {
        c();
      }
    });
  }
  setTrackMuted(u) {
    this.log.debug("setting ".concat(this.kind, " track ").concat(u ? "muted" : "unmuted"), this.logContext), !(this.isMuted === u && this._mediaStreamTrack.enabled !== u) && (this.isMuted = u, this._mediaStreamTrack.enabled = !u, this.emit(u ? TrackEvent.Muted : TrackEvent.Unmuted, this));
  }
  get needsReAcquisition() {
    return this._mediaStreamTrack.readyState !== "live" || this._mediaStreamTrack.muted || !this._mediaStreamTrack.enabled || this.reacquireTrack;
  }
  handleAppVisibilityChanged() {
    const u = Object.create(null, {
      handleAppVisibilityChanged: {
        get: () => super.handleAppVisibilityChanged
      }
    });
    return __awaiter$3(this, void 0, void 0, function* () {
      yield u.handleAppVisibilityChanged.call(this), isMobile() && (this.log.debug("visibility changed, is in Background: ".concat(this.isInBackground), this.logContext), !this.isInBackground && this.needsReAcquisition && !this.isUserProvided && !this.isMuted && (this.log.debug("track needs to be reacquired, restarting ".concat(this.source), this.logContext), yield this.restart(), this.reacquireTrack = !1));
    });
  }
  stop() {
    var u;
    super.stop(), this._mediaStreamTrack.removeEventListener("ended", this.handleEnded), this._mediaStreamTrack.removeEventListener("mute", this.handleTrackMuteEvent), this._mediaStreamTrack.removeEventListener("unmute", this.handleTrackUnmuteEvent), (u = this.processor) === null || u === void 0 || u.destroy(), this.processor = void 0;
  }
  /**
   * pauses publishing to the server without disabling the local MediaStreamTrack
   * this is used to display a user's own video locally while pausing publishing to
   * the server.
   * this API is unsupported on Safari < 12 due to a bug
   **/
  pauseUpstream() {
    return __awaiter$3(this, void 0, void 0, function* () {
      const u = yield this.pauseUpstreamLock.lock();
      try {
        if (this._isUpstreamPaused === !0)
          return;
        if (!this.sender) {
          this.log.warn("unable to pause upstream for an unpublished track", this.logContext);
          return;
        }
        this._isUpstreamPaused = !0, this.emit(TrackEvent.UpstreamPaused, this);
        const c = getBrowser();
        if ((c == null ? void 0 : c.name) === "Safari" && compareVersions(c.version, "12.0") < 0)
          throw new DeviceUnsupportedError("pauseUpstream is not supported on Safari < 12.");
        yield this.sender.replaceTrack(null);
      } finally {
        u();
      }
    });
  }
  resumeUpstream() {
    return __awaiter$3(this, void 0, void 0, function* () {
      const u = yield this.pauseUpstreamLock.lock();
      try {
        if (this._isUpstreamPaused === !1)
          return;
        if (!this.sender) {
          this.log.warn("unable to resume upstream for an unpublished track", this.logContext);
          return;
        }
        this._isUpstreamPaused = !1, this.emit(TrackEvent.UpstreamResumed, this), yield this.sender.replaceTrack(this._mediaStreamTrack);
      } finally {
        u();
      }
    });
  }
  /**
   * Gets the RTCStatsReport for the LocalTrack's underlying RTCRtpSender
   * See https://developer.mozilla.org/en-US/docs/Web/API/RTCStatsReport
   *
   * @returns Promise<RTCStatsReport> | undefined
   */
  getRTCStatsReport() {
    var u;
    return __awaiter$3(this, void 0, void 0, function* () {
      return !((u = this.sender) === null || u === void 0) && u.getStats ? yield this.sender.getStats() : void 0;
    });
  }
  /**
   * Sets a processor on this track.
   * See https://github.com/livekit/track-processors-js for example usage
   *
   * @experimental
   *
   * @param processor
   * @param showProcessedStreamLocally
   * @returns
   */
  setProcessor(u) {
    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
    var l, v;
    return __awaiter$3(this, void 0, void 0, function* () {
      const p = yield this.processorLock.lock();
      try {
        this.log.debug("setting up processor", this.logContext), this.processorElement = (l = this.processorElement) !== null && l !== void 0 ? l : document.createElement(this.kind);
        const _ = {
          kind: this.kind,
          track: this._mediaStreamTrack,
          element: this.processorElement,
          audioContext: this.audioContext
        };
        if (yield u.init(_), this.processor && (yield this.stopProcessor()), this.kind === "unknown")
          throw TypeError("cannot set processor on track of unknown kind");
        if (attachToElement(this._mediaStreamTrack, this.processorElement), this.processorElement.muted = !0, this.processorElement.play().catch((k) => this.log.error("failed to play processor element", Object.assign(Object.assign({}, this.logContext), {
          error: k
        }))), this.processor = u, this.processor.processedTrack) {
          for (const k of this.attachedElements)
            k !== this.processorElement && c && (detachTrack(this._mediaStreamTrack, k), attachToElement(this.processor.processedTrack, k));
          yield (v = this.sender) === null || v === void 0 ? void 0 : v.replaceTrack(this.processor.processedTrack);
        }
        this.emit(TrackEvent.TrackProcessorUpdate, this.processor);
      } finally {
        p();
      }
    });
  }
  getProcessor() {
    return this.processor;
  }
  /**
   * Stops the track processor
   * See https://github.com/livekit/track-processors-js for example usage
   *
   * @experimental
   * @returns
   */
  stopProcessor() {
    var u, c;
    return __awaiter$3(this, void 0, void 0, function* () {
      this.processor && (this.log.debug("stopping processor", this.logContext), (u = this.processor.processedTrack) === null || u === void 0 || u.stop(), yield this.processor.destroy(), this.processor = void 0, (c = this.processorElement) === null || c === void 0 || c.remove(), this.processorElement = void 0, yield this._mediaStreamTrack.applyConstraints(this._constraints), yield this.setMediaStreamTrack(this._mediaStreamTrack, !0), this.emit(TrackEvent.TrackProcessorUpdate));
    });
  }
}
class E2EEManager extends eventsExports$1.EventEmitter {
  constructor(u) {
    super(), this.onWorkerMessage = (c) => {
      var l, v;
      const {
        kind: p,
        data: _
      } = c.data;
      switch (p) {
        case "error":
          livekitLogger.error(_.error.message), this.emit(EncryptionEvent.EncryptionError, _.error);
          break;
        case "initAck":
          _.enabled && this.keyProvider.getKeys().forEach((k) => {
            this.postKey(k);
          });
          break;
        case "enable":
          if (this.encryptionEnabled !== _.enabled && _.participantIdentity === ((l = this.room) === null || l === void 0 ? void 0 : l.localParticipant.identity))
            this.emit(EncryptionEvent.ParticipantEncryptionStatusChanged, _.enabled, this.room.localParticipant), this.encryptionEnabled = _.enabled;
          else if (_.participantIdentity) {
            const k = (v = this.room) === null || v === void 0 ? void 0 : v.getParticipantByIdentity(_.participantIdentity);
            if (!k)
              throw TypeError("couldn't set encryption status, participant not found".concat(_.participantIdentity));
            this.emit(EncryptionEvent.ParticipantEncryptionStatusChanged, _.enabled, k);
          }
          this.encryptionEnabled && this.keyProvider.getKeys().forEach((k) => {
            this.postKey(k);
          });
          break;
        case "ratchetKey":
          this.keyProvider.emit(KeyProviderEvent.KeyRatcheted, _.material, _.keyIndex);
          break;
      }
    }, this.onWorkerError = (c) => {
      livekitLogger.error("e2ee worker encountered an error:", {
        error: c.error
      }), this.emit(EncryptionEvent.EncryptionError, c.error);
    }, this.keyProvider = u.keyProvider, this.worker = u.worker, this.encryptionEnabled = !1;
  }
  /**
   * @internal
   */
  setup(u) {
    if (!isE2EESupported())
      throw new DeviceUnsupportedError("tried to setup end-to-end encryption on an unsupported browser");
    if (livekitLogger.info("setting up e2ee"), u !== this.room) {
      this.room = u, this.setupEventListeners(u, this.keyProvider);
      const c = {
        kind: "init",
        data: {
          keyProviderOptions: this.keyProvider.getOptions(),
          loglevel: workerLogger.getLevel()
        }
      };
      this.worker && (livekitLogger.info("initializing worker", {
        worker: this.worker
      }), this.worker.onmessage = this.onWorkerMessage, this.worker.onerror = this.onWorkerError, this.worker.postMessage(c));
    }
  }
  /**
   * @internal
   */
  setParticipantCryptorEnabled(u, c) {
    livekitLogger.debug("set e2ee to ".concat(u, " for participant ").concat(c)), this.postEnable(u, c);
  }
  /**
   * @internal
   */
  setSifTrailer(u) {
    !u || u.length === 0 ? livekitLogger.warn("ignoring server sent trailer as it's empty") : this.postSifTrailer(u);
  }
  setupEngine(u) {
    u.on(EngineEvent.RTPVideoMapUpdate, (c) => {
      this.postRTPMap(c);
    });
  }
  setupEventListeners(u, c) {
    u.on(RoomEvent.TrackPublished, (l, v) => this.setParticipantCryptorEnabled(l.trackInfo.encryption !== Encryption_Type.NONE, v.identity)), u.on(RoomEvent.ConnectionStateChanged, (l) => {
      l === ConnectionState.Connected && u.remoteParticipants.forEach((v) => {
        v.trackPublications.forEach((p) => {
          this.setParticipantCryptorEnabled(p.trackInfo.encryption !== Encryption_Type.NONE, v.identity);
        });
      });
    }).on(RoomEvent.TrackUnsubscribed, (l, v, p) => {
      var _;
      const k = {
        kind: "removeTransform",
        data: {
          participantIdentity: p.identity,
          trackId: l.mediaStreamID
        }
      };
      (_ = this.worker) === null || _ === void 0 || _.postMessage(k);
    }).on(RoomEvent.TrackSubscribed, (l, v, p) => {
      this.setupE2EEReceiver(l, p.identity, v.trackInfo);
    }).on(RoomEvent.SignalConnected, () => {
      if (!this.room)
        throw new TypeError("expected room to be present on signal connect");
      this.setParticipantCryptorEnabled(this.room.localParticipant.isE2EEEnabled, this.room.localParticipant.identity), c.getKeys().forEach((l) => {
        this.postKey(l);
      });
    }), u.localParticipant.on(ParticipantEvent.LocalTrackPublished, (l) => __awaiter$3(this, void 0, void 0, function* () {
      this.setupE2EESender(l.track, l.track.sender);
    })), c.on(KeyProviderEvent.SetKey, (l) => this.postKey(l)).on(KeyProviderEvent.RatchetRequest, (l, v) => this.postRatchetRequest(l, v));
  }
  postRatchetRequest(u, c) {
    if (!this.worker)
      throw Error("could not ratchet key, worker is missing");
    const l = {
      kind: "ratchetRequest",
      data: {
        participantIdentity: u,
        keyIndex: c
      }
    };
    this.worker.postMessage(l);
  }
  postKey(u) {
    let {
      key: c,
      participantIdentity: l,
      keyIndex: v
    } = u;
    var p;
    if (!this.worker)
      throw Error("could not set key, worker is missing");
    const _ = {
      kind: "setKey",
      data: {
        participantIdentity: l,
        isPublisher: l === ((p = this.room) === null || p === void 0 ? void 0 : p.localParticipant.identity),
        key: c,
        keyIndex: v
      }
    };
    this.worker.postMessage(_);
  }
  postEnable(u, c) {
    if (this.worker) {
      const l = {
        kind: "enable",
        data: {
          enabled: u,
          participantIdentity: c
        }
      };
      this.worker.postMessage(l);
    } else
      throw new ReferenceError("failed to enable e2ee, worker is not ready");
  }
  postRTPMap(u) {
    var c;
    if (!this.worker)
      throw TypeError("could not post rtp map, worker is missing");
    if (!(!((c = this.room) === null || c === void 0) && c.localParticipant.identity))
      throw TypeError("could not post rtp map, local participant identity is missing");
    const l = {
      kind: "setRTPMap",
      data: {
        map: u,
        participantIdentity: this.room.localParticipant.identity
      }
    };
    this.worker.postMessage(l);
  }
  postSifTrailer(u) {
    if (!this.worker)
      throw Error("could not post SIF trailer, worker is missing");
    const c = {
      kind: "setSifTrailer",
      data: {
        trailer: u
      }
    };
    this.worker.postMessage(c);
  }
  setupE2EEReceiver(u, c, l) {
    if (u.receiver) {
      if (!(l != null && l.mimeType) || l.mimeType === "")
        throw new TypeError("MimeType missing from trackInfo, cannot set up E2EE cryptor");
      this.handleReceiver(u.receiver, u.mediaStreamID, c, u.kind === "video" ? mimeTypeToVideoCodecString(l.mimeType) : void 0);
    }
  }
  setupE2EESender(u, c) {
    if (!(u instanceof LocalTrack) || !c) {
      c || livekitLogger.warn("early return because sender is not ready");
      return;
    }
    this.handleSender(c, u.mediaStreamID, void 0);
  }
  /**
   * Handles the given {@code RTCRtpReceiver} by creating a {@code TransformStream} which will inject
   * a frame decoder.
   *
   */
  handleReceiver(u, c, l, v) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (this.worker) {
        if (isScriptTransformSupported()) {
          const p = {
            kind: "decode",
            participantIdentity: l,
            trackId: c,
            codec: v
          };
          u.transform = new RTCRtpScriptTransform(this.worker, p);
        } else {
          if (E2EE_FLAG in u && v) {
            const O = {
              kind: "updateCodec",
              data: {
                trackId: c,
                codec: v,
                participantIdentity: l
              }
            };
            this.worker.postMessage(O);
            return;
          }
          let p = u.writableStream, _ = u.readableStream;
          if (!p || !_) {
            const O = u.createEncodedStreams();
            u.writableStream = O.writable, p = O.writable, u.readableStream = O.readable, _ = O.readable;
          }
          const k = {
            kind: "decode",
            data: {
              readableStream: _,
              writableStream: p,
              trackId: c,
              codec: v,
              participantIdentity: l
            }
          };
          this.worker.postMessage(k, [_, p]);
        }
        u[E2EE_FLAG] = !0;
      }
    });
  }
  /**
   * Handles the given {@code RTCRtpSender} by creating a {@code TransformStream} which will inject
   * a frame encoder.
   *
   */
  handleSender(u, c, l) {
    var v;
    if (!(E2EE_FLAG in u || !this.worker)) {
      if (!(!((v = this.room) === null || v === void 0) && v.localParticipant.identity) || this.room.localParticipant.identity === "")
        throw TypeError("local identity needs to be known in order to set up encrypted sender");
      if (isScriptTransformSupported()) {
        livekitLogger.info("initialize script transform");
        const p = {
          kind: "encode",
          participantIdentity: this.room.localParticipant.identity,
          trackId: c,
          codec: l
        };
        u.transform = new RTCRtpScriptTransform(this.worker, p);
      } else {
        livekitLogger.info("initialize encoded streams");
        const p = u.createEncodedStreams(), _ = {
          kind: "encode",
          data: {
            readableStream: p.readable,
            writableStream: p.writable,
            codec: l,
            trackId: c,
            participantIdentity: this.room.localParticipant.identity
          }
        };
        this.worker.postMessage(_, [p.readable, p.writable]);
      }
      u[E2EE_FLAG] = !0;
    }
  }
}
var QueueTaskStatus;
(function(a) {
  a[a.WAITING = 0] = "WAITING", a[a.RUNNING = 1] = "RUNNING", a[a.COMPLETED = 2] = "COMPLETED";
})(QueueTaskStatus || (QueueTaskStatus = {}));
class AsyncQueue {
  constructor() {
    this.pendingTasks = /* @__PURE__ */ new Map(), this.taskMutex = new Mutex(), this.nextTaskIndex = 0;
  }
  run(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      const c = {
        id: this.nextTaskIndex++,
        enqueuedAt: Date.now(),
        status: QueueTaskStatus.WAITING
      };
      this.pendingTasks.set(c.id, c);
      const l = yield this.taskMutex.lock();
      try {
        return c.executedAt = Date.now(), c.status = QueueTaskStatus.RUNNING, yield u();
      } finally {
        c.status = QueueTaskStatus.COMPLETED, this.pendingTasks.delete(c.id), l();
      }
    });
  }
  flush() {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this.run(() => __awaiter$3(this, void 0, void 0, function* () {
      }));
    });
  }
  snapshot() {
    return Array.from(this.pendingTasks.values());
  }
}
const passThroughQueueSignals = ["syncState", "trickle", "offer", "answer", "simulate", "leave"];
function canPassThroughQueue(a) {
  const u = passThroughQueueSignals.indexOf(a.case) >= 0;
  return livekitLogger.trace("request allowed to bypass queue:", {
    canPass: u,
    req: a
  }), u;
}
var SignalConnectionState;
(function(a) {
  a[a.CONNECTING = 0] = "CONNECTING", a[a.CONNECTED = 1] = "CONNECTED", a[a.RECONNECTING = 2] = "RECONNECTING", a[a.DISCONNECTING = 3] = "DISCONNECTING", a[a.DISCONNECTED = 4] = "DISCONNECTED";
})(SignalConnectionState || (SignalConnectionState = {}));
class SignalClient {
  get currentState() {
    return this.state;
  }
  get isDisconnected() {
    return this.state === SignalConnectionState.DISCONNECTING || this.state === SignalConnectionState.DISCONNECTED;
  }
  get isEstablishingConnection() {
    return this.state === SignalConnectionState.CONNECTING || this.state === SignalConnectionState.RECONNECTING;
  }
  constructor() {
    let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1, c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var l;
    this.rtt = 0, this.state = SignalConnectionState.DISCONNECTED, this.log = livekitLogger, this.resetCallbacks = () => {
      this.onAnswer = void 0, this.onLeave = void 0, this.onLocalTrackPublished = void 0, this.onLocalTrackUnpublished = void 0, this.onNegotiateRequested = void 0, this.onOffer = void 0, this.onRemoteMuteChanged = void 0, this.onSubscribedQualityUpdate = void 0, this.onTokenRefresh = void 0, this.onTrickle = void 0, this.onClose = void 0;
    }, this.log = getLogger((l = c.loggerName) !== null && l !== void 0 ? l : LoggerNames.Signal), this.loggerContextCb = c.loggerContextCb, this.useJSON = u, this.requestQueue = new AsyncQueue(), this.queuedRequests = [], this.closingLock = new Mutex(), this.connectionLock = new Mutex(), this.state = SignalConnectionState.DISCONNECTED;
  }
  get logContext() {
    var u, c;
    return (c = (u = this.loggerContextCb) === null || u === void 0 ? void 0 : u.call(this)) !== null && c !== void 0 ? c : {};
  }
  join(u, c, l, v) {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this.state = SignalConnectionState.CONNECTING, this.options = l, yield this.connect(u, c, l, v);
    });
  }
  reconnect(u, c, l, v) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!this.options) {
        this.log.warn("attempted to reconnect without signal options being set, ignoring", this.logContext);
        return;
      }
      return this.state = SignalConnectionState.RECONNECTING, this.clearPingInterval(), yield this.connect(u, c, Object.assign(Object.assign({}, this.options), {
        reconnect: !0,
        sid: l,
        reconnectReason: v
      }));
    });
  }
  connect(u, c, l, v) {
    this.connectOptions = l, u = toWebsocketUrl(u), u = u.replace(/\/$/, ""), u += "/rtc";
    const p = getClientInfo(), _ = createConnectionParams(c, p, l);
    return new Promise((k, O) => __awaiter$3(this, void 0, void 0, function* () {
      const D = yield this.connectionLock.lock();
      try {
        const F = () => __awaiter$3(this, void 0, void 0, function* () {
          this.close(), clearTimeout(H), O(new ConnectionError("room connection has been cancelled (signal)"));
        }), H = setTimeout(() => {
          this.close(), O(new ConnectionError("room connection has timed out (signal)"));
        }, l.websocketTimeout);
        v != null && v.aborted && F(), v == null || v.addEventListener("abort", F), this.log.debug("connecting to ".concat(u + _), this.logContext), this.ws && (yield this.close(!1)), this.ws = new WebSocket(u + _), this.ws.binaryType = "arraybuffer", this.ws.onopen = () => {
          clearTimeout(H);
        }, this.ws.onerror = (Z) => __awaiter$3(this, void 0, void 0, function* () {
          if (this.state !== SignalConnectionState.CONNECTED) {
            this.state = SignalConnectionState.DISCONNECTED, clearTimeout(H);
            try {
              const ee = yield fetch("http".concat(u.substring(2), "/validate").concat(_));
              if (ee.status.toFixed(0).startsWith("4")) {
                const X = yield ee.text();
                O(new ConnectionError(X, 0, ee.status));
              } else
                O(new ConnectionError("Internal error", 2, ee.status));
            } catch {
              O(new ConnectionError(
                "server was not reachable",
                1
                /* ConnectionErrorReason.ServerUnreachable */
              ));
            }
            return;
          }
          this.handleWSError(Z);
        }), this.ws.onmessage = (Z) => __awaiter$3(this, void 0, void 0, function* () {
          var ee, X, ne;
          let Q;
          if (typeof Z.data == "string") {
            const ae = JSON.parse(Z.data);
            Q = SignalResponse.fromJson(ae, {
              ignoreUnknownFields: !0
            });
          } else if (Z.data instanceof ArrayBuffer)
            Q = SignalResponse.fromBinary(new Uint8Array(Z.data));
          else {
            this.log.error("could not decode websocket message: ".concat(typeof Z.data), this.logContext);
            return;
          }
          if (this.state !== SignalConnectionState.CONNECTED) {
            let ae = !1;
            if (((ee = Q.message) === null || ee === void 0 ? void 0 : ee.case) === "join" ? (this.state = SignalConnectionState.CONNECTED, v == null || v.removeEventListener("abort", F), this.pingTimeoutDuration = Q.message.value.pingTimeout, this.pingIntervalDuration = Q.message.value.pingInterval, this.pingTimeoutDuration && this.pingTimeoutDuration > 0 && (this.log.debug("ping config", Object.assign(Object.assign({}, this.logContext), {
              timeout: this.pingTimeoutDuration,
              interval: this.pingIntervalDuration
            })), this.startPingInterval()), k(Q.message.value)) : this.state === SignalConnectionState.RECONNECTING && Q.message.case !== "leave" ? (this.state = SignalConnectionState.CONNECTED, v == null || v.removeEventListener("abort", F), this.startPingInterval(), ((X = Q.message) === null || X === void 0 ? void 0 : X.case) === "reconnect" ? k(Q.message.value) : (this.log.debug("declaring signal reconnected without reconnect response received", this.logContext), k(void 0), ae = !0)) : this.isEstablishingConnection && Q.message.case === "leave" ? O(new ConnectionError(
              "Received leave request while trying to (re)connect",
              4
              /* ConnectionErrorReason.LeaveRequest */
            )) : l.reconnect || O(new ConnectionError("did not receive join response, got ".concat((ne = Q.message) === null || ne === void 0 ? void 0 : ne.case, " instead"))), !ae)
              return;
          }
          this.signalLatency && (yield sleep(this.signalLatency)), this.handleSignalResponse(Q);
        }), this.ws.onclose = (Z) => {
          this.isEstablishingConnection && O(new ConnectionError("Websocket got closed during a (re)connection attempt")), this.log.warn("websocket closed", Object.assign(Object.assign({}, this.logContext), {
            reason: Z.reason,
            code: Z.code,
            wasClean: Z.wasClean,
            state: this.state
          })), this.handleOnClose(Z.reason);
        };
      } finally {
        D();
      }
    }));
  }
  close() {
    let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
    return __awaiter$3(this, void 0, void 0, function* () {
      const c = yield this.closingLock.lock();
      try {
        if (u && (this.state = SignalConnectionState.DISCONNECTING), this.ws) {
          this.ws.onmessage = null, this.ws.onopen = null, this.ws.onclose = null;
          const l = new Promise((v) => {
            this.ws ? this.ws.onclose = () => {
              v();
            } : v();
          });
          this.ws.readyState < this.ws.CLOSING && (this.ws.close(), yield Promise.race([l, sleep(250)])), this.ws = void 0;
        }
      } finally {
        u && (this.state = SignalConnectionState.DISCONNECTED), this.clearPingInterval(), c();
      }
    });
  }
  // initial offer after joining
  sendOffer(u) {
    this.log.debug("sending offer", Object.assign(Object.assign({}, this.logContext), {
      offerSdp: u.sdp
    })), this.sendRequest({
      case: "offer",
      value: toProtoSessionDescription(u)
    });
  }
  // answer a server-initiated offer
  sendAnswer(u) {
    return this.log.debug("sending answer", Object.assign(Object.assign({}, this.logContext), {
      answerSdp: u.sdp
    })), this.sendRequest({
      case: "answer",
      value: toProtoSessionDescription(u)
    });
  }
  sendIceCandidate(u, c) {
    return this.log.trace("sending ice candidate", Object.assign(Object.assign({}, this.logContext), {
      candidate: u
    })), this.sendRequest({
      case: "trickle",
      value: new TrickleRequest({
        candidateInit: JSON.stringify(u),
        target: c
      })
    });
  }
  sendMuteTrack(u, c) {
    return this.sendRequest({
      case: "mute",
      value: new MuteTrackRequest({
        sid: u,
        muted: c
      })
    });
  }
  sendAddTrack(u) {
    return this.sendRequest({
      case: "addTrack",
      value: u
    });
  }
  sendUpdateLocalMetadata(u, c) {
    return this.sendRequest({
      case: "updateMetadata",
      value: new UpdateParticipantMetadata({
        metadata: u,
        name: c
      })
    });
  }
  sendUpdateTrackSettings(u) {
    this.sendRequest({
      case: "trackSetting",
      value: u
    });
  }
  sendUpdateSubscription(u) {
    return this.sendRequest({
      case: "subscription",
      value: u
    });
  }
  sendSyncState(u) {
    return this.sendRequest({
      case: "syncState",
      value: u
    });
  }
  sendUpdateVideoLayers(u, c) {
    return this.sendRequest({
      case: "updateLayers",
      value: new UpdateVideoLayers({
        trackSid: u,
        layers: c
      })
    });
  }
  sendUpdateSubscriptionPermissions(u, c) {
    return this.sendRequest({
      case: "subscriptionPermission",
      value: new SubscriptionPermission({
        allParticipants: u,
        trackPermissions: c
      })
    });
  }
  sendSimulateScenario(u) {
    return this.sendRequest({
      case: "simulate",
      value: u
    });
  }
  sendPing() {
    return Promise.all([this.sendRequest({
      case: "ping",
      value: protoInt64.parse(Date.now())
    }), this.sendRequest({
      case: "pingReq",
      value: new Ping({
        timestamp: protoInt64.parse(Date.now()),
        rtt: protoInt64.parse(this.rtt)
      })
    })]);
  }
  sendLeave() {
    return this.sendRequest({
      case: "leave",
      value: new LeaveRequest({
        canReconnect: !1,
        reason: DisconnectReason.CLIENT_INITIATED
      })
    });
  }
  sendRequest(u) {
    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!c && !canPassThroughQueue(u) && this.state === SignalConnectionState.RECONNECTING) {
        this.queuedRequests.push(() => __awaiter$3(this, void 0, void 0, function* () {
          yield this.sendRequest(u, !0);
        }));
        return;
      }
      if (c || (yield this.requestQueue.flush()), this.signalLatency && (yield sleep(this.signalLatency)), !this.ws || this.ws.readyState !== this.ws.OPEN) {
        this.log.error("cannot send signal request before connected, type: ".concat(u == null ? void 0 : u.case), this.logContext);
        return;
      }
      const v = new SignalRequest({
        message: u
      });
      try {
        this.useJSON ? this.ws.send(v.toJsonString()) : this.ws.send(v.toBinary());
      } catch (p) {
        this.log.error("error sending signal message", Object.assign(Object.assign({}, this.logContext), {
          error: p
        }));
      }
    });
  }
  handleSignalResponse(u) {
    var c, l;
    const v = u.message;
    if (v == null) {
      this.log.debug("received unsupported message", this.logContext);
      return;
    }
    let p = !1;
    if (v.case === "answer") {
      const _ = fromProtoSessionDescription(v.value);
      this.onAnswer && this.onAnswer(_);
    } else if (v.case === "offer") {
      const _ = fromProtoSessionDescription(v.value);
      this.onOffer && this.onOffer(_);
    } else if (v.case === "trickle") {
      const _ = JSON.parse(v.value.candidateInit);
      this.onTrickle && this.onTrickle(_, v.value.target);
    } else
      v.case === "update" ? this.onParticipantUpdate && this.onParticipantUpdate((c = v.value.participants) !== null && c !== void 0 ? c : []) : v.case === "trackPublished" ? this.onLocalTrackPublished && this.onLocalTrackPublished(v.value) : v.case === "speakersChanged" ? this.onSpeakersChanged && this.onSpeakersChanged((l = v.value.speakers) !== null && l !== void 0 ? l : []) : v.case === "leave" ? this.onLeave && this.onLeave(v.value) : v.case === "mute" ? this.onRemoteMuteChanged && this.onRemoteMuteChanged(v.value.sid, v.value.muted) : v.case === "roomUpdate" ? this.onRoomUpdate && v.value.room && this.onRoomUpdate(v.value.room) : v.case === "connectionQuality" ? this.onConnectionQuality && this.onConnectionQuality(v.value) : v.case === "streamStateUpdate" ? this.onStreamStateUpdate && this.onStreamStateUpdate(v.value) : v.case === "subscribedQualityUpdate" ? this.onSubscribedQualityUpdate && this.onSubscribedQualityUpdate(v.value) : v.case === "subscriptionPermissionUpdate" ? this.onSubscriptionPermissionUpdate && this.onSubscriptionPermissionUpdate(v.value) : v.case === "refreshToken" ? this.onTokenRefresh && this.onTokenRefresh(v.value) : v.case === "trackUnpublished" ? this.onLocalTrackUnpublished && this.onLocalTrackUnpublished(v.value) : v.case === "subscriptionResponse" ? this.onSubscriptionError && this.onSubscriptionError(v.value) : v.case === "pong" || (v.case === "pongResp" ? (this.rtt = Date.now() - Number.parseInt(v.value.lastPingTimestamp.toString()), this.resetPingTimeout(), p = !0) : this.log.debug("unsupported message", Object.assign(Object.assign({}, this.logContext), {
        msgCase: v.case
      })));
    p || this.resetPingTimeout();
  }
  setReconnected() {
    for (; this.queuedRequests.length > 0; ) {
      const u = this.queuedRequests.shift();
      u && this.requestQueue.run(u);
    }
  }
  handleOnClose(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (this.state === SignalConnectionState.DISCONNECTED)
        return;
      const c = this.onClose;
      yield this.close(), this.log.debug("websocket connection closed: ".concat(u), Object.assign(Object.assign({}, this.logContext), {
        reason: u
      })), c && c(u);
    });
  }
  handleWSError(u) {
    this.log.error("websocket error", Object.assign(Object.assign({}, this.logContext), {
      error: u
    }));
  }
  /**
   * Resets the ping timeout and starts a new timeout.
   * Call this after receiving a pong message
   */
  resetPingTimeout() {
    if (this.clearPingTimeout(), !this.pingTimeoutDuration) {
      this.log.warn("ping timeout duration not set", this.logContext);
      return;
    }
    this.pingTimeout = CriticalTimers.setTimeout(() => {
      this.log.warn("ping timeout triggered. last pong received at: ".concat(new Date(Date.now() - this.pingTimeoutDuration * 1e3).toUTCString()), this.logContext), this.handleOnClose("ping timeout");
    }, this.pingTimeoutDuration * 1e3);
  }
  /**
   * Clears ping timeout (does not start a new timeout)
   */
  clearPingTimeout() {
    this.pingTimeout && CriticalTimers.clearTimeout(this.pingTimeout);
  }
  startPingInterval() {
    if (this.clearPingInterval(), this.resetPingTimeout(), !this.pingIntervalDuration) {
      this.log.warn("ping interval duration not set", this.logContext);
      return;
    }
    this.log.debug("start ping interval", this.logContext), this.pingInterval = CriticalTimers.setInterval(() => {
      this.sendPing();
    }, this.pingIntervalDuration * 1e3);
  }
  clearPingInterval() {
    this.log.debug("clearing ping interval", this.logContext), this.clearPingTimeout(), this.pingInterval && CriticalTimers.clearInterval(this.pingInterval);
  }
}
function fromProtoSessionDescription(a) {
  const u = {
    type: "offer",
    sdp: a.sdp
  };
  switch (a.type) {
    case "answer":
    case "offer":
    case "pranswer":
    case "rollback":
      u.type = a.type;
      break;
  }
  return u;
}
function toProtoSessionDescription(a) {
  return new SessionDescription({
    sdp: a.sdp,
    type: a.type
  });
}
function createConnectionParams(a, u, c) {
  var l;
  const v = new URLSearchParams();
  return v.set("access_token", a), c.reconnect && (v.set("reconnect", "1"), c.sid && v.set("sid", c.sid)), v.set("auto_subscribe", c.autoSubscribe ? "1" : "0"), v.set("sdk", isReactNative() ? "reactnative" : "js"), v.set("version", u.version), v.set("protocol", u.protocol.toString()), u.deviceModel && v.set("device_model", u.deviceModel), u.os && v.set("os", u.os), u.osVersion && v.set("os_version", u.osVersion), u.browser && v.set("browser", u.browser), u.browserVersion && v.set("browser_version", u.browserVersion), c.adaptiveStream && v.set("adaptive_stream", "1"), c.reconnectReason && v.set("reconnect_reason", c.reconnectReason.toString()), !((l = navigator.connection) === null || l === void 0) && l.type && v.set("network", navigator.connection.type), "?".concat(v.toString());
}
var parser$1 = {}, grammar$2 = { exports: {} }, grammar$1 = grammar$2.exports = {
  v: [{
    name: "version",
    reg: /^(\d*)$/
  }],
  o: [{
    // o=- 20518 0 IN IP4 203.0.113.1
    // NB: sessionId will be a String in most cases because it is huge
    name: "origin",
    reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,
    names: ["username", "sessionId", "sessionVersion", "netType", "ipVer", "address"],
    format: "%s %s %d %s IP%d %s"
  }],
  // default parsing of these only (though some of these feel outdated)
  s: [{
    name: "name"
  }],
  i: [{
    name: "description"
  }],
  u: [{
    name: "uri"
  }],
  e: [{
    name: "email"
  }],
  p: [{
    name: "phone"
  }],
  z: [{
    name: "timezones"
  }],
  // TODO: this one can actually be parsed properly...
  r: [{
    name: "repeats"
  }],
  // TODO: this one can also be parsed properly
  // k: [{}], // outdated thing ignored
  t: [{
    // t=0 0
    name: "timing",
    reg: /^(\d*) (\d*)/,
    names: ["start", "stop"],
    format: "%d %d"
  }],
  c: [{
    // c=IN IP4 10.47.197.26
    name: "connection",
    reg: /^IN IP(\d) (\S*)/,
    names: ["version", "ip"],
    format: "IN IP%d %s"
  }],
  b: [{
    // b=AS:4000
    push: "bandwidth",
    reg: /^(TIAS|AS|CT|RR|RS):(\d*)/,
    names: ["type", "limit"],
    format: "%s:%s"
  }],
  m: [{
    // m=video 51744 RTP/AVP 126 97 98 34 31
    // NB: special - pushes to session
    // TODO: rtp/fmtp should be filtered by the payloads found here?
    reg: /^(\w*) (\d*) ([\w/]*)(?: (.*))?/,
    names: ["type", "port", "protocol", "payloads"],
    format: "%s %d %s %s"
  }],
  a: [
    {
      // a=rtpmap:110 opus/48000/2
      push: "rtp",
      reg: /^rtpmap:(\d*) ([\w\-.]*)(?:\s*\/(\d*)(?:\s*\/(\S*))?)?/,
      names: ["payload", "codec", "rate", "encoding"],
      format: function(a) {
        return a.encoding ? "rtpmap:%d %s/%s/%s" : a.rate ? "rtpmap:%d %s/%s" : "rtpmap:%d %s";
      }
    },
    {
      // a=fmtp:108 profile-level-id=24;object=23;bitrate=64000
      // a=fmtp:111 minptime=10; useinbandfec=1
      push: "fmtp",
      reg: /^fmtp:(\d*) ([\S| ]*)/,
      names: ["payload", "config"],
      format: "fmtp:%d %s"
    },
    {
      // a=control:streamid=0
      name: "control",
      reg: /^control:(.*)/,
      format: "control:%s"
    },
    {
      // a=rtcp:65179 IN IP4 193.84.77.194
      name: "rtcp",
      reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,
      names: ["port", "netType", "ipVer", "address"],
      format: function(a) {
        return a.address != null ? "rtcp:%d %s IP%d %s" : "rtcp:%d";
      }
    },
    {
      // a=rtcp-fb:98 trr-int 100
      push: "rtcpFbTrrInt",
      reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/,
      names: ["payload", "value"],
      format: "rtcp-fb:%s trr-int %d"
    },
    {
      // a=rtcp-fb:98 nack rpsi
      push: "rtcpFb",
      reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,
      names: ["payload", "type", "subtype"],
      format: function(a) {
        return a.subtype != null ? "rtcp-fb:%s %s %s" : "rtcp-fb:%s %s";
      }
    },
    {
      // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
      // a=extmap:1/recvonly URI-gps-string
      // a=extmap:3 urn:ietf:params:rtp-hdrext:encrypt urn:ietf:params:rtp-hdrext:smpte-tc 25@600/24
      push: "ext",
      reg: /^extmap:(\d+)(?:\/(\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\S*)(?: (\S*))?/,
      names: ["value", "direction", "encrypt-uri", "uri", "config"],
      format: function(a) {
        return "extmap:%d" + (a.direction ? "/%s" : "%v") + (a["encrypt-uri"] ? " %s" : "%v") + " %s" + (a.config ? " %s" : "");
      }
    },
    {
      // a=extmap-allow-mixed
      name: "extmapAllowMixed",
      reg: /^(extmap-allow-mixed)/
    },
    {
      // a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32
      push: "crypto",
      reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,
      names: ["id", "suite", "config", "sessionConfig"],
      format: function(a) {
        return a.sessionConfig != null ? "crypto:%d %s %s %s" : "crypto:%d %s %s";
      }
    },
    {
      // a=setup:actpass
      name: "setup",
      reg: /^setup:(\w*)/,
      format: "setup:%s"
    },
    {
      // a=connection:new
      name: "connectionType",
      reg: /^connection:(new|existing)/,
      format: "connection:%s"
    },
    {
      // a=mid:1
      name: "mid",
      reg: /^mid:([^\s]*)/,
      format: "mid:%s"
    },
    {
      // a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a
      name: "msid",
      reg: /^msid:(.*)/,
      format: "msid:%s"
    },
    {
      // a=ptime:20
      name: "ptime",
      reg: /^ptime:(\d*(?:\.\d*)*)/,
      format: "ptime:%d"
    },
    {
      // a=maxptime:60
      name: "maxptime",
      reg: /^maxptime:(\d*(?:\.\d*)*)/,
      format: "maxptime:%d"
    },
    {
      // a=sendrecv
      name: "direction",
      reg: /^(sendrecv|recvonly|sendonly|inactive)/
    },
    {
      // a=ice-lite
      name: "icelite",
      reg: /^(ice-lite)/
    },
    {
      // a=ice-ufrag:F7gI
      name: "iceUfrag",
      reg: /^ice-ufrag:(\S*)/,
      format: "ice-ufrag:%s"
    },
    {
      // a=ice-pwd:x9cml/YzichV2+XlhiMu8g
      name: "icePwd",
      reg: /^ice-pwd:(\S*)/,
      format: "ice-pwd:%s"
    },
    {
      // a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33
      name: "fingerprint",
      reg: /^fingerprint:(\S*) (\S*)/,
      names: ["type", "hash"],
      format: "fingerprint:%s %s"
    },
    {
      // a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host
      // a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10
      // a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10
      // a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10
      // a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10
      push: "candidates",
      reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?(?: network-id (\d*))?(?: network-cost (\d*))?/,
      names: ["foundation", "component", "transport", "priority", "ip", "port", "type", "raddr", "rport", "tcptype", "generation", "network-id", "network-cost"],
      format: function(a) {
        var u = "candidate:%s %d %s %d %s %d typ %s";
        return u += a.raddr != null ? " raddr %s rport %d" : "%v%v", u += a.tcptype != null ? " tcptype %s" : "%v", a.generation != null && (u += " generation %d"), u += a["network-id"] != null ? " network-id %d" : "%v", u += a["network-cost"] != null ? " network-cost %d" : "%v", u;
      }
    },
    {
      // a=end-of-candidates (keep after the candidates line for readability)
      name: "endOfCandidates",
      reg: /^(end-of-candidates)/
    },
    {
      // a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...
      name: "remoteCandidates",
      reg: /^remote-candidates:(.*)/,
      format: "remote-candidates:%s"
    },
    {
      // a=ice-options:google-ice
      name: "iceOptions",
      reg: /^ice-options:(\S*)/,
      format: "ice-options:%s"
    },
    {
      // a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1
      push: "ssrcs",
      reg: /^ssrc:(\d*) ([\w_-]*)(?::(.*))?/,
      names: ["id", "attribute", "value"],
      format: function(a) {
        var u = "ssrc:%d";
        return a.attribute != null && (u += " %s", a.value != null && (u += ":%s")), u;
      }
    },
    {
      // a=ssrc-group:FEC 1 2
      // a=ssrc-group:FEC-FR 3004364195 1080772241
      push: "ssrcGroups",
      // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E
      reg: /^ssrc-group:([\x21\x23\x24\x25\x26\x27\x2A\x2B\x2D\x2E\w]*) (.*)/,
      names: ["semantics", "ssrcs"],
      format: "ssrc-group:%s %s"
    },
    {
      // a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV
      name: "msidSemantic",
      reg: /^msid-semantic:\s?(\w*) (\S*)/,
      names: ["semantic", "token"],
      format: "msid-semantic: %s %s"
      // space after ':' is not accidental
    },
    {
      // a=group:BUNDLE audio video
      push: "groups",
      reg: /^group:(\w*) (.*)/,
      names: ["type", "mids"],
      format: "group:%s %s"
    },
    {
      // a=rtcp-mux
      name: "rtcpMux",
      reg: /^(rtcp-mux)/
    },
    {
      // a=rtcp-rsize
      name: "rtcpRsize",
      reg: /^(rtcp-rsize)/
    },
    {
      // a=sctpmap:5000 webrtc-datachannel 1024
      name: "sctpmap",
      reg: /^sctpmap:([\w_/]*) (\S*)(?: (\S*))?/,
      names: ["sctpmapNumber", "app", "maxMessageSize"],
      format: function(a) {
        return a.maxMessageSize != null ? "sctpmap:%s %s %s" : "sctpmap:%s %s";
      }
    },
    {
      // a=x-google-flag:conference
      name: "xGoogleFlag",
      reg: /^x-google-flag:([^\s]*)/,
      format: "x-google-flag:%s"
    },
    {
      // a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0
      push: "rids",
      reg: /^rid:([\d\w]+) (\w+)(?: ([\S| ]*))?/,
      names: ["id", "direction", "params"],
      format: function(a) {
        return a.params ? "rid:%s %s %s" : "rid:%s %s";
      }
    },
    {
      // a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]
      // a=imageattr:* send [x=800,y=640] recv *
      // a=imageattr:100 recv [x=320,y=240]
      push: "imageattrs",
      reg: new RegExp(
        // a=imageattr:97
        "^imageattr:(\\d+|\\*)[\\s\\t]+(send|recv)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*)(?:[\\s\\t]+(recv|send)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*))?"
      ),
      names: ["pt", "dir1", "attrs1", "dir2", "attrs2"],
      format: function(a) {
        return "imageattr:%s %s %s" + (a.dir2 ? " %s %s" : "");
      }
    },
    {
      // a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8
      // a=simulcast:recv 1;4,5 send 6;7
      name: "simulcast",
      reg: new RegExp(
        // a=simulcast:
        "^simulcast:(send|recv) ([a-zA-Z0-9\\-_~;,]+)(?:\\s?(send|recv) ([a-zA-Z0-9\\-_~;,]+))?$"
      ),
      names: ["dir1", "list1", "dir2", "list2"],
      format: function(a) {
        return "simulcast:%s %s" + (a.dir2 ? " %s %s" : "");
      }
    },
    {
      // old simulcast draft 03 (implemented by Firefox)
      //   https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03
      // a=simulcast: recv pt=97;98 send pt=97
      // a=simulcast: send rid=5;6;7 paused=6,7
      name: "simulcast_03",
      reg: /^simulcast:[\s\t]+([\S+\s\t]+)$/,
      names: ["value"],
      format: "simulcast: %s"
    },
    {
      // a=framerate:25
      // a=framerate:29.97
      name: "framerate",
      reg: /^framerate:(\d+(?:$|\.\d+))/,
      format: "framerate:%s"
    },
    {
      // RFC4570
      // a=source-filter: incl IN IP4 239.5.2.31 10.1.15.5
      name: "sourceFilter",
      reg: /^source-filter: *(excl|incl) (\S*) (IP4|IP6|\*) (\S*) (.*)/,
      names: ["filterMode", "netType", "addressTypes", "destAddress", "srcList"],
      format: "source-filter: %s %s %s %s %s"
    },
    {
      // a=bundle-only
      name: "bundleOnly",
      reg: /^(bundle-only)/
    },
    {
      // a=label:1
      name: "label",
      reg: /^label:(.+)/,
      format: "label:%s"
    },
    {
      // RFC version 26 for SCTP over DTLS
      // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-5
      name: "sctpPort",
      reg: /^sctp-port:(\d+)$/,
      format: "sctp-port:%s"
    },
    {
      // RFC version 26 for SCTP over DTLS
      // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-6
      name: "maxMessageSize",
      reg: /^max-message-size:(\d+)$/,
      format: "max-message-size:%s"
    },
    {
      // RFC7273
      // a=ts-refclk:ptp=IEEE1588-2008:39-A7-94-FF-FE-07-CB-D0:37
      push: "tsRefClocks",
      reg: /^ts-refclk:([^\s=]*)(?:=(\S*))?/,
      names: ["clksrc", "clksrcExt"],
      format: function(a) {
        return "ts-refclk:%s" + (a.clksrcExt != null ? "=%s" : "");
      }
    },
    {
      // RFC7273
      // a=mediaclk:direct=963214424
      name: "mediaClk",
      reg: /^mediaclk:(?:id=(\S*))? *([^\s=]*)(?:=(\S*))?(?: *rate=(\d+)\/(\d+))?/,
      names: ["id", "mediaClockName", "mediaClockValue", "rateNumerator", "rateDenominator"],
      format: function(a) {
        var u = "mediaclk:";
        return u += a.id != null ? "id=%s %s" : "%v%s", u += a.mediaClockValue != null ? "=%s" : "", u += a.rateNumerator != null ? " rate=%s" : "", u += a.rateDenominator != null ? "/%s" : "", u;
      }
    },
    {
      // a=keywds:keywords
      name: "keywords",
      reg: /^keywds:(.+)$/,
      format: "keywds:%s"
    },
    {
      // a=content:main
      name: "content",
      reg: /^content:(.+)/,
      format: "content:%s"
    },
    // BFCP https://tools.ietf.org/html/rfc4583
    {
      // a=floorctrl:c-s
      name: "bfcpFloorCtrl",
      reg: /^floorctrl:(c-only|s-only|c-s)/,
      format: "floorctrl:%s"
    },
    {
      // a=confid:1
      name: "bfcpConfId",
      reg: /^confid:(\d+)/,
      format: "confid:%s"
    },
    {
      // a=userid:1
      name: "bfcpUserId",
      reg: /^userid:(\d+)/,
      format: "userid:%s"
    },
    {
      // a=floorid:1
      name: "bfcpFloorId",
      reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/,
      names: ["id", "mStream"],
      format: "floorid:%s mstrm:%s"
    },
    {
      // any a= that we don't understand is kept verbatim on media.invalid
      push: "invalid",
      names: ["value"]
    }
  ]
};
Object.keys(grammar$1).forEach(function(a) {
  var u = grammar$1[a];
  u.forEach(function(c) {
    c.reg || (c.reg = /(.*)/), c.format || (c.format = "%s");
  });
});
var grammarExports = grammar$2.exports;
(function(a) {
  var u = function(k) {
    return String(Number(k)) === k ? Number(k) : k;
  }, c = function(k, O, D, F) {
    if (F && !D)
      O[F] = u(k[1]);
    else
      for (var H = 0; H < D.length; H += 1)
        k[H + 1] != null && (O[D[H]] = u(k[H + 1]));
  }, l = function(k, O, D) {
    var F = k.name && k.names;
    k.push && !O[k.push] ? O[k.push] = [] : F && !O[k.name] && (O[k.name] = {});
    var H = k.push ? {} : (
      // blank object that will be pushed
      F ? O[k.name] : O
    );
    c(D.match(k.reg), H, k.names, k.name), k.push && O[k.push].push(H);
  }, v = grammarExports, p = RegExp.prototype.test.bind(/^([a-z])=(.*)/);
  a.parse = function(k) {
    var O = {}, D = [], F = O;
    return k.split(/(\r\n|\r|\n)/).filter(p).forEach(function(H) {
      var Z = H[0], ee = H.slice(2);
      Z === "m" && (D.push({
        rtp: [],
        fmtp: []
      }), F = D[D.length - 1]);
      for (var X = 0; X < (v[Z] || []).length; X += 1) {
        var ne = v[Z][X];
        if (ne.reg.test(ee))
          return l(ne, F, ee);
      }
    }), O.media = D, O;
  };
  var _ = function(k, O) {
    var D = O.split(/=(.+)/, 2);
    return D.length === 2 ? k[D[0]] = u(D[1]) : D.length === 1 && O.length > 1 && (k[D[0]] = void 0), k;
  };
  a.parseParams = function(k) {
    return k.split(/;\s?/).reduce(_, {});
  }, a.parseFmtpConfig = a.parseParams, a.parsePayloads = function(k) {
    return k.toString().split(" ").map(Number);
  }, a.parseRemoteCandidates = function(k) {
    for (var O = [], D = k.split(" ").map(u), F = 0; F < D.length; F += 3)
      O.push({
        component: D[F],
        ip: D[F + 1],
        port: D[F + 2]
      });
    return O;
  }, a.parseImageAttributes = function(k) {
    return k.split(" ").map(function(O) {
      return O.substring(1, O.length - 1).split(",").reduce(_, {});
    });
  }, a.parseSimulcastStreamList = function(k) {
    return k.split(";").map(function(O) {
      return O.split(",").map(function(D) {
        var F, H = !1;
        return D[0] !== "~" ? F = u(D) : (F = u(D.substring(1, D.length)), H = !0), {
          scid: F,
          paused: H
        };
      });
    });
  };
})(parser$1);
var grammar = grammarExports, formatRegExp = /%[sdv%]/g, format = function(a) {
  var u = 1, c = arguments, l = c.length;
  return a.replace(formatRegExp, function(v) {
    if (u >= l)
      return v;
    var p = c[u];
    switch (u += 1, v) {
      case "%%":
        return "%";
      case "%s":
        return String(p);
      case "%d":
        return Number(p);
      case "%v":
        return "";
    }
  });
}, makeLine = function(a, u, c) {
  var l = u.format instanceof Function ? u.format(u.push ? c : c[u.name]) : u.format, v = [a + "=" + l];
  if (u.names)
    for (var p = 0; p < u.names.length; p += 1) {
      var _ = u.names[p];
      u.name ? v.push(c[u.name][_]) : v.push(c[u.names[p]]);
    }
  else
    v.push(c[u.name]);
  return format.apply(null, v);
}, defaultOuterOrder = ["v", "o", "s", "i", "u", "e", "p", "c", "b", "t", "r", "z", "a"], defaultInnerOrder = ["i", "c", "b", "a"], writer$1 = function(a, u) {
  u = u || {}, a.version == null && (a.version = 0), a.name == null && (a.name = " "), a.media.forEach(function(p) {
    p.payloads == null && (p.payloads = "");
  });
  var c = u.outerOrder || defaultOuterOrder, l = u.innerOrder || defaultInnerOrder, v = [];
  return c.forEach(function(p) {
    grammar[p].forEach(function(_) {
      _.name in a && a[_.name] != null ? v.push(makeLine(p, _, a)) : _.push in a && a[_.push] != null && a[_.push].forEach(function(k) {
        v.push(makeLine(p, _, k));
      });
    });
  }), a.media.forEach(function(p) {
    v.push(makeLine("m", grammar.m[0], p)), l.forEach(function(_) {
      grammar[_].forEach(function(k) {
        k.name in p && p[k.name] != null ? v.push(makeLine(_, k, p)) : k.push in p && p[k.push] != null && p[k.push].forEach(function(O) {
          v.push(makeLine(_, k, O));
        });
      });
    });
  }), v.join(`\r
`) + `\r
`;
}, parser = parser$1, writer = writer$1, write = writer, parse$2 = parser.parse;
const startBitrateForSVC = 0.7, PCEvents = {
  NegotiationStarted: "negotiationStarted",
  NegotiationComplete: "negotiationComplete",
  RTPVideoPayloadTypes: "rtpVideoPayloadTypes"
};
class PCTransport extends eventsExports$1.EventEmitter {
  get pc() {
    return this._pc || (this._pc = this.createPC()), this._pc;
  }
  constructor(u) {
    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var l;
    super(), this.log = livekitLogger, this.pendingCandidates = [], this.restartingIce = !1, this.renegotiate = !1, this.trackBitrates = [], this.remoteStereoMids = [], this.remoteNackMids = [], this.negotiate = r$1((v) => __awaiter$3(this, void 0, void 0, function* () {
      this.emit(PCEvents.NegotiationStarted);
      try {
        yield this.createAndSendOffer();
      } catch (p) {
        if (v)
          v(p);
        else
          throw p;
      }
    }), 100), this.close = () => {
      this._pc && (this._pc.close(), this._pc.onconnectionstatechange = null, this._pc.oniceconnectionstatechange = null, this._pc.onicegatheringstatechange = null, this._pc.ondatachannel = null, this._pc.onnegotiationneeded = null, this._pc.onsignalingstatechange = null, this._pc.onicecandidate = null, this._pc.ondatachannel = null, this._pc.ontrack = null, this._pc.onconnectionstatechange = null, this._pc.oniceconnectionstatechange = null, this._pc = null);
    }, this.log = getLogger((l = c.loggerName) !== null && l !== void 0 ? l : LoggerNames.PCTransport), this.loggerOptions = c, this.config = u, this._pc = this.createPC();
  }
  createPC() {
    const u = new RTCPeerConnection(this.config);
    return u.onicecandidate = (c) => {
      var l;
      c.candidate && ((l = this.onIceCandidate) === null || l === void 0 || l.call(this, c.candidate));
    }, u.onicecandidateerror = (c) => {
      var l;
      (l = this.onIceCandidateError) === null || l === void 0 || l.call(this, c);
    }, u.oniceconnectionstatechange = () => {
      var c;
      (c = this.onIceConnectionStateChange) === null || c === void 0 || c.call(this, u.iceConnectionState);
    }, u.onsignalingstatechange = () => {
      var c;
      (c = this.onSignalingStatechange) === null || c === void 0 || c.call(this, u.signalingState);
    }, u.onconnectionstatechange = () => {
      var c;
      (c = this.onConnectionStateChange) === null || c === void 0 || c.call(this, u.connectionState);
    }, u.ondatachannel = (c) => {
      var l;
      (l = this.onDataChannel) === null || l === void 0 || l.call(this, c);
    }, u.ontrack = (c) => {
      var l;
      (l = this.onTrack) === null || l === void 0 || l.call(this, c);
    }, u;
  }
  get logContext() {
    var u, c;
    return Object.assign({}, (c = (u = this.loggerOptions).loggerContextCb) === null || c === void 0 ? void 0 : c.call(u));
  }
  get isICEConnected() {
    return this._pc !== null && (this.pc.iceConnectionState === "connected" || this.pc.iceConnectionState === "completed");
  }
  addIceCandidate(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (this.pc.remoteDescription && !this.restartingIce)
        return this.pc.addIceCandidate(u);
      this.pendingCandidates.push(u);
    });
  }
  setRemoteDescription(u) {
    var c;
    return __awaiter$3(this, void 0, void 0, function* () {
      let l;
      if (u.type === "offer") {
        let {
          stereoMids: v,
          nackMids: p
        } = extractStereoAndNackAudioFromOffer(u);
        this.remoteStereoMids = v, this.remoteNackMids = p;
      } else if (u.type === "answer") {
        const v = parse$2((c = u.sdp) !== null && c !== void 0 ? c : "");
        v.media.forEach((p) => {
          p.type === "audio" && this.trackBitrates.some((_) => {
            if (!_.transceiver || p.mid != _.transceiver.mid)
              return !1;
            let k = 0;
            if (p.rtp.some((D) => D.codec.toUpperCase() === _.codec.toUpperCase() ? (k = D.payload, !0) : !1), k === 0)
              return !0;
            let O = !1;
            for (const D of p.fmtp)
              if (D.payload === k) {
                D.config = D.config.split(";").filter((F) => !F.includes("maxaveragebitrate")).join(";"), _.maxbr > 0 && (D.config += ";maxaveragebitrate=".concat(_.maxbr * 1e3)), O = !0;
                break;
              }
            return O || _.maxbr > 0 && p.fmtp.push({
              payload: k,
              config: "maxaveragebitrate=".concat(_.maxbr * 1e3)
            }), !0;
          });
        }), l = write(v);
      }
      yield this.setMungedSDP(u, l, !0), this.pendingCandidates.forEach((v) => {
        this.pc.addIceCandidate(v);
      }), this.pendingCandidates = [], this.restartingIce = !1, this.renegotiate ? (this.renegotiate = !1, yield this.createAndSendOffer()) : u.type === "answer" && (this.emit(PCEvents.NegotiationComplete), u.sdp && parse$2(u.sdp).media.forEach((p) => {
        p.type === "video" && this.emit(PCEvents.RTPVideoPayloadTypes, p.rtp);
      }));
    });
  }
  createAndSendOffer(u) {
    var c;
    return __awaiter$3(this, void 0, void 0, function* () {
      if (this.onOffer === void 0)
        return;
      if (u != null && u.iceRestart && (this.log.debug("restarting ICE", this.logContext), this.restartingIce = !0), this._pc && this._pc.signalingState === "have-local-offer") {
        const p = this._pc.remoteDescription;
        if (u != null && u.iceRestart && p)
          yield this._pc.setRemoteDescription(p);
        else {
          this.renegotiate = !0;
          return;
        }
      } else if (!this._pc || this._pc.signalingState === "closed") {
        this.log.warn("could not createOffer with closed peer connection", this.logContext);
        return;
      }
      this.log.debug("starting to negotiate", this.logContext);
      const l = yield this.pc.createOffer(u), v = parse$2((c = l.sdp) !== null && c !== void 0 ? c : "");
      v.media.forEach((p) => {
        p.type === "audio" ? ensureAudioNackAndStereo(p, [], []) : p.type === "video" && (ensureVideoDDExtensionForSVC(p), this.trackBitrates.some((_) => {
          if (!p.msid || !_.cid || !p.msid.includes(_.cid))
            return !1;
          let k = 0;
          if (p.rtp.some((D) => D.codec.toUpperCase() === _.codec.toUpperCase() ? (k = D.payload, !0) : !1), k === 0)
            return !0;
          const O = Math.round(_.maxbr * startBitrateForSVC);
          for (const D of p.fmtp)
            if (D.payload === k) {
              D.config.includes("x-google-start-bitrate") || (D.config += ";x-google-start-bitrate=".concat(O));
              break;
            }
          return !0;
        }));
      }), yield this.setMungedSDP(l, write(v)), this.onOffer(l);
    });
  }
  createAndSetAnswer() {
    var u;
    return __awaiter$3(this, void 0, void 0, function* () {
      const c = yield this.pc.createAnswer(), l = parse$2((u = c.sdp) !== null && u !== void 0 ? u : "");
      return l.media.forEach((v) => {
        v.type === "audio" && ensureAudioNackAndStereo(v, this.remoteStereoMids, this.remoteNackMids);
      }), yield this.setMungedSDP(c, write(l)), c;
    });
  }
  createDataChannel(u, c) {
    return this.pc.createDataChannel(u, c);
  }
  addTransceiver(u, c) {
    return this.pc.addTransceiver(u, c);
  }
  addTrack(u) {
    if (!this._pc)
      throw new UnexpectedConnectionState("PC closed, cannot add track");
    return this._pc.addTrack(u);
  }
  setTrackCodecBitrate(u) {
    this.trackBitrates.push(u);
  }
  setConfiguration(u) {
    var c;
    if (!this._pc)
      throw new UnexpectedConnectionState("PC closed, cannot configure");
    return (c = this._pc) === null || c === void 0 ? void 0 : c.setConfiguration(u);
  }
  canRemoveTrack() {
    var u;
    return !!(!((u = this._pc) === null || u === void 0) && u.removeTrack);
  }
  removeTrack(u) {
    var c;
    return (c = this._pc) === null || c === void 0 ? void 0 : c.removeTrack(u);
  }
  getConnectionState() {
    var u, c;
    return (c = (u = this._pc) === null || u === void 0 ? void 0 : u.connectionState) !== null && c !== void 0 ? c : "closed";
  }
  getICEConnectionState() {
    var u, c;
    return (c = (u = this._pc) === null || u === void 0 ? void 0 : u.iceConnectionState) !== null && c !== void 0 ? c : "closed";
  }
  getSignallingState() {
    var u, c;
    return (c = (u = this._pc) === null || u === void 0 ? void 0 : u.signalingState) !== null && c !== void 0 ? c : "closed";
  }
  getTransceivers() {
    var u, c;
    return (c = (u = this._pc) === null || u === void 0 ? void 0 : u.getTransceivers()) !== null && c !== void 0 ? c : [];
  }
  getSenders() {
    var u, c;
    return (c = (u = this._pc) === null || u === void 0 ? void 0 : u.getSenders()) !== null && c !== void 0 ? c : [];
  }
  getLocalDescription() {
    var u;
    return (u = this._pc) === null || u === void 0 ? void 0 : u.localDescription;
  }
  getRemoteDescription() {
    var u;
    return (u = this.pc) === null || u === void 0 ? void 0 : u.remoteDescription;
  }
  getStats() {
    return this.pc.getStats();
  }
  getConnectedAddress() {
    var u;
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!this._pc)
        return;
      let c = "";
      const l = /* @__PURE__ */ new Map(), v = /* @__PURE__ */ new Map();
      if ((yield this._pc.getStats()).forEach((k) => {
        switch (k.type) {
          case "transport":
            c = k.selectedCandidatePairId;
            break;
          case "candidate-pair":
            c === "" && k.selected && (c = k.id), l.set(k.id, k);
            break;
          case "remote-candidate":
            v.set(k.id, "".concat(k.address, ":").concat(k.port));
            break;
        }
      }), c === "")
        return;
      const _ = (u = l.get(c)) === null || u === void 0 ? void 0 : u.remoteCandidateId;
      if (_ !== void 0)
        return v.get(_);
    });
  }
  setMungedSDP(u, c, l) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (c) {
        const v = u.sdp;
        u.sdp = c;
        try {
          this.log.debug("setting munged ".concat(l ? "remote" : "local", " description"), this.logContext), l ? yield this.pc.setRemoteDescription(u) : yield this.pc.setLocalDescription(u);
          return;
        } catch (p) {
          this.log.warn("not able to set ".concat(u.type, ", falling back to unmodified sdp"), Object.assign(Object.assign({}, this.logContext), {
            error: p,
            sdp: c
          })), u.sdp = v;
        }
      }
      try {
        l ? yield this.pc.setRemoteDescription(u) : yield this.pc.setLocalDescription(u);
      } catch (v) {
        let p = "unknown error";
        v instanceof Error ? p = v.message : typeof v == "string" && (p = v);
        const _ = {
          error: p,
          sdp: u.sdp
        };
        throw !l && this.pc.remoteDescription && (_.remoteSdp = this.pc.remoteDescription), this.log.error("unable to set ".concat(u.type), Object.assign(Object.assign({}, this.logContext), {
          fields: _
        })), new NegotiationError(p);
      }
    });
  }
}
function ensureAudioNackAndStereo(a, u, c) {
  let l = 0;
  a.rtp.some((v) => v.codec === "opus" ? (l = v.payload, !0) : !1), l > 0 && (a.rtcpFb || (a.rtcpFb = []), c.includes(a.mid) && !a.rtcpFb.some((v) => v.payload === l && v.type === "nack") && a.rtcpFb.push({
    payload: l,
    type: "nack"
  }), u.includes(a.mid) && a.fmtp.some((v) => v.payload === l ? (v.config.includes("stereo=1") || (v.config += ";stereo=1"), !0) : !1));
}
function ensureVideoDDExtensionForSVC(a) {
  var u, c, l, v;
  const p = (c = (u = a.rtp[0]) === null || u === void 0 ? void 0 : u.codec) === null || c === void 0 ? void 0 : c.toLowerCase();
  if (!isSVCCodec(p))
    return;
  let _ = 0;
  ((l = a.ext) === null || l === void 0 ? void 0 : l.some((O) => O.uri === ddExtensionURI ? !0 : (O.value > _ && (_ = O.value), !1))) || (v = a.ext) === null || v === void 0 || v.push({
    value: _ + 1,
    uri: ddExtensionURI
  });
}
function extractStereoAndNackAudioFromOffer(a) {
  var u;
  const c = [], l = [], v = parse$2((u = a.sdp) !== null && u !== void 0 ? u : "");
  let p = 0;
  return v.media.forEach((_) => {
    var k;
    _.type === "audio" && (_.rtp.some((O) => O.codec === "opus" ? (p = O.payload, !0) : !1), !((k = _.rtcpFb) === null || k === void 0) && k.some((O) => O.payload === p && O.type === "nack") && l.push(_.mid), _.fmtp.some((O) => O.payload === p ? (O.config.includes("sprop-stereo=1") && c.push(_.mid), !0) : !1));
  }), {
    stereoMids: c,
    nackMids: l
  };
}
const defaultVideoCodec = "vp8", publishDefaults = {
  audioPreset: AudioPresets.music,
  dtx: !0,
  red: !0,
  forceStereo: !1,
  simulcast: !0,
  screenShareEncoding: ScreenSharePresets.h1080fps15.encoding,
  stopMicTrackOnMute: !1,
  videoCodec: defaultVideoCodec,
  backupCodec: !0
}, audioDefaults = {
  autoGainControl: !0,
  echoCancellation: !0,
  noiseSuppression: !0
}, videoDefaults = {
  resolution: VideoPresets.h720.resolution
}, roomOptionDefaults = {
  adaptiveStream: !1,
  dynacast: !1,
  stopLocalTrackOnUnpublish: !0,
  reconnectPolicy: new DefaultReconnectPolicy(),
  disconnectOnPageLeave: !0,
  webAudioMix: !0
}, roomConnectOptionDefaults = {
  autoSubscribe: !0,
  maxRetries: 1,
  peerConnectionTimeout: 15e3,
  websocketTimeout: 15e3
};
var PCTransportState;
(function(a) {
  a[a.NEW = 0] = "NEW", a[a.CONNECTING = 1] = "CONNECTING", a[a.CONNECTED = 2] = "CONNECTED", a[a.FAILED = 3] = "FAILED", a[a.CLOSING = 4] = "CLOSING", a[a.CLOSED = 5] = "CLOSED";
})(PCTransportState || (PCTransportState = {}));
class PCTransportManager {
  get needsPublisher() {
    return this.isPublisherConnectionRequired;
  }
  get needsSubscriber() {
    return this.isSubscriberConnectionRequired;
  }
  get currentState() {
    return this.state;
  }
  constructor(u, c, l) {
    var v;
    this.peerConnectionTimeout = roomConnectOptionDefaults.peerConnectionTimeout, this.log = livekitLogger, this.updateState = () => {
      var p;
      const _ = this.state, k = this.requiredTransports.map((O) => O.getConnectionState());
      k.every((O) => O === "connected") ? this.state = PCTransportState.CONNECTED : k.some((O) => O === "failed") ? this.state = PCTransportState.FAILED : k.some((O) => O === "connecting") ? this.state = PCTransportState.CONNECTING : k.every((O) => O === "closed") ? this.state = PCTransportState.CLOSED : k.some((O) => O === "closed") ? this.state = PCTransportState.CLOSING : k.every((O) => O === "new") && (this.state = PCTransportState.NEW), _ !== this.state && (this.log.debug("pc state change: from ".concat(PCTransportState[_], " to ").concat(PCTransportState[this.state]), this.logContext), (p = this.onStateChange) === null || p === void 0 || p.call(this, this.state, this.publisher.getConnectionState(), this.subscriber.getConnectionState()));
    }, this.log = getLogger((v = l.loggerName) !== null && v !== void 0 ? v : LoggerNames.PCManager), this.loggerOptions = l, this.isPublisherConnectionRequired = !c, this.isSubscriberConnectionRequired = c, this.publisher = new PCTransport(u, l), this.subscriber = new PCTransport(u, l), this.publisher.onConnectionStateChange = this.updateState, this.subscriber.onConnectionStateChange = this.updateState, this.publisher.onIceConnectionStateChange = this.updateState, this.subscriber.onIceConnectionStateChange = this.updateState, this.publisher.onSignalingStatechange = this.updateState, this.subscriber.onSignalingStatechange = this.updateState, this.publisher.onIceCandidate = (p) => {
      var _;
      (_ = this.onIceCandidate) === null || _ === void 0 || _.call(this, p, SignalTarget.PUBLISHER);
    }, this.subscriber.onIceCandidate = (p) => {
      var _;
      (_ = this.onIceCandidate) === null || _ === void 0 || _.call(this, p, SignalTarget.SUBSCRIBER);
    }, this.subscriber.onDataChannel = (p) => {
      var _;
      (_ = this.onDataChannel) === null || _ === void 0 || _.call(this, p);
    }, this.subscriber.onTrack = (p) => {
      var _;
      (_ = this.onTrack) === null || _ === void 0 || _.call(this, p);
    }, this.publisher.onOffer = (p) => {
      var _;
      (_ = this.onPublisherOffer) === null || _ === void 0 || _.call(this, p);
    }, this.state = PCTransportState.NEW, this.connectionLock = new Mutex();
  }
  get logContext() {
    var u, c;
    return Object.assign({}, (c = (u = this.loggerOptions).loggerContextCb) === null || c === void 0 ? void 0 : c.call(u));
  }
  requirePublisher() {
    let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
    this.isPublisherConnectionRequired = u, this.updateState();
  }
  requireSubscriber() {
    let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
    this.isSubscriberConnectionRequired = u, this.updateState();
  }
  createAndSendPublisherOffer(u) {
    return this.publisher.createAndSendOffer(u);
  }
  setPublisherAnswer(u) {
    return this.publisher.setRemoteDescription(u);
  }
  removeTrack(u) {
    return this.publisher.removeTrack(u);
  }
  close() {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (this.publisher && this.publisher.getSignallingState() !== "closed") {
        const u = this.publisher;
        for (const c of u.getSenders())
          try {
            u.canRemoveTrack() && u.removeTrack(c);
          } catch (l) {
            this.log.warn("could not removeTrack", Object.assign(Object.assign({}, this.logContext), {
              error: l
            }));
          }
      }
      yield Promise.all([this.publisher.close(), this.subscriber.close()]), this.updateState();
    });
  }
  triggerIceRestart() {
    return __awaiter$3(this, void 0, void 0, function* () {
      this.subscriber.restartingIce = !0, this.needsPublisher && (yield this.createAndSendPublisherOffer({
        iceRestart: !0
      }));
    });
  }
  addIceCandidate(u, c) {
    return __awaiter$3(this, void 0, void 0, function* () {
      c === SignalTarget.PUBLISHER ? yield this.publisher.addIceCandidate(u) : yield this.subscriber.addIceCandidate(u);
    });
  }
  createSubscriberAnswerFromOffer(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this.log.debug("received server offer", Object.assign(Object.assign({}, this.logContext), {
        RTCSdpType: u.type,
        sdp: u.sdp,
        signalingState: this.subscriber.getSignallingState().toString()
      })), yield this.subscriber.setRemoteDescription(u), yield this.subscriber.createAndSetAnswer();
    });
  }
  updateConfiguration(u, c) {
    this.publisher.setConfiguration(u), this.subscriber.setConfiguration(u), c && this.triggerIceRestart();
  }
  ensurePCTransportConnection(u, c) {
    var l;
    return __awaiter$3(this, void 0, void 0, function* () {
      const v = yield this.connectionLock.lock();
      try {
        this.isPublisherConnectionRequired && this.publisher.getConnectionState() !== "connected" && this.publisher.getConnectionState() !== "connecting" && (this.log.debug("negotiation required, start negotiating", this.logContext), this.publisher.negotiate()), yield Promise.all((l = this.requiredTransports) === null || l === void 0 ? void 0 : l.map((p) => this.ensureTransportConnected(p, u, c)));
      } finally {
        v();
      }
    });
  }
  negotiate(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      return new Promise((c, l) => __awaiter$3(this, void 0, void 0, function* () {
        const v = setTimeout(() => {
          l("negotiation timed out");
        }, this.peerConnectionTimeout), p = () => {
          clearTimeout(v), l("negotiation aborted");
        };
        u.signal.addEventListener("abort", p), this.publisher.once(PCEvents.NegotiationStarted, () => {
          u.signal.aborted || this.publisher.once(PCEvents.NegotiationComplete, () => {
            clearTimeout(v), c();
          });
        }), yield this.publisher.negotiate((_) => {
          clearTimeout(v), l(_);
        });
      }));
    });
  }
  addPublisherTransceiver(u, c) {
    return this.publisher.addTransceiver(u, c);
  }
  addPublisherTrack(u) {
    return this.publisher.addTrack(u);
  }
  createPublisherDataChannel(u, c) {
    return this.publisher.createDataChannel(u, c);
  }
  /**
   * Returns the first required transport's address if no explicit target is specified
   */
  getConnectedAddress(u) {
    return u === SignalTarget.PUBLISHER ? this.publisher.getConnectedAddress() : u === SignalTarget.SUBSCRIBER ? this.publisher.getConnectedAddress() : this.requiredTransports[0].getConnectedAddress();
  }
  get requiredTransports() {
    const u = [];
    return this.isPublisherConnectionRequired && u.push(this.publisher), this.isSubscriberConnectionRequired && u.push(this.subscriber), u;
  }
  ensureTransportConnected(u, c) {
    let l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.peerConnectionTimeout;
    return __awaiter$3(this, void 0, void 0, function* () {
      if (u.getConnectionState() !== "connected")
        return new Promise((p, _) => __awaiter$3(this, void 0, void 0, function* () {
          const k = () => {
            this.log.warn("abort transport connection", this.logContext), CriticalTimers.clearTimeout(O), _(new ConnectionError(
              "room connection has been cancelled",
              3
              /* ConnectionErrorReason.Cancelled */
            ));
          };
          c != null && c.signal.aborted && k(), c == null || c.signal.addEventListener("abort", k);
          const O = CriticalTimers.setTimeout(() => {
            c == null || c.signal.removeEventListener("abort", k), _(new ConnectionError("could not establish pc connection"));
          }, l);
          for (; this.state !== PCTransportState.CONNECTED; )
            if (yield sleep(50), c != null && c.signal.aborted) {
              _(new ConnectionError(
                "room connection has been cancelled",
                3
                /* ConnectionErrorReason.Cancelled */
              ));
              return;
            }
          CriticalTimers.clearTimeout(O), c == null || c.signal.removeEventListener("abort", k), p();
        }));
    });
  }
}
const lossyDataChannel = "_lossy", reliableDataChannel = "_reliable", minReconnectWait = 2 * 1e3, leaveReconnect = "leave-reconnect";
var PCState;
(function(a) {
  a[a.New = 0] = "New", a[a.Connected = 1] = "Connected", a[a.Disconnected = 2] = "Disconnected", a[a.Reconnecting = 3] = "Reconnecting", a[a.Closed = 4] = "Closed";
})(PCState || (PCState = {}));
class RTCEngine extends eventsExports$1.EventEmitter {
  get isClosed() {
    return this._isClosed;
  }
  get pendingReconnect() {
    return !!this.reconnectTimeout;
  }
  constructor(u) {
    var c;
    super(), this.options = u, this.rtcConfig = {}, this.peerConnectionTimeout = roomConnectOptionDefaults.peerConnectionTimeout, this.fullReconnectOnNext = !1, this.subscriberPrimary = !1, this.pcState = PCState.New, this._isClosed = !0, this.pendingTrackResolvers = {}, this.reconnectAttempts = 0, this.reconnectStart = 0, this.attemptingReconnect = !1, this.joinAttempts = 0, this.maxJoinAttempts = 1, this.shouldFailNext = !1, this.log = livekitLogger, this.handleDataChannel = (l) => {
      let {
        channel: v
      } = l;
      return __awaiter$3(this, void 0, void 0, function* () {
        if (v) {
          if (v.label === reliableDataChannel)
            this.reliableDCSub = v;
          else if (v.label === lossyDataChannel)
            this.lossyDCSub = v;
          else
            return;
          this.log.debug("on data channel ".concat(v.id, ", ").concat(v.label), this.logContext), v.onmessage = this.handleDataMessage;
        }
      });
    }, this.handleDataMessage = (l) => __awaiter$3(this, void 0, void 0, function* () {
      var v, p;
      const _ = yield this.dataProcessLock.lock();
      try {
        let k;
        if (l.data instanceof ArrayBuffer)
          k = l.data;
        else if (l.data instanceof Blob)
          k = yield l.data.arrayBuffer();
        else {
          this.log.error("unsupported data type", Object.assign(Object.assign({}, this.logContext), {
            data: l.data
          }));
          return;
        }
        const O = DataPacket.fromBinary(new Uint8Array(k));
        ((v = O.value) === null || v === void 0 ? void 0 : v.case) === "speaker" ? this.emit(EngineEvent.ActiveSpeakersUpdate, O.value.value.speakers) : ((p = O.value) === null || p === void 0 ? void 0 : p.case) === "user" && this.emit(EngineEvent.DataPacketReceived, O.value.value, O.kind);
      } finally {
        _();
      }
    }), this.handleDataError = (l) => {
      const p = l.currentTarget.maxRetransmits === 0 ? "lossy" : "reliable";
      if (l instanceof ErrorEvent && l.error) {
        const {
          error: _
        } = l.error;
        this.log.error("DataChannel error on ".concat(p, ": ").concat(l.message), Object.assign(Object.assign({}, this.logContext), {
          error: _
        }));
      } else
        this.log.error("Unknown DataChannel error on ".concat(p), Object.assign(Object.assign({}, this.logContext), {
          event: l
        }));
    }, this.handleBufferedAmountLow = (l) => {
      const p = l.currentTarget.maxRetransmits === 0 ? DataPacket_Kind.LOSSY : DataPacket_Kind.RELIABLE;
      this.updateAndEmitDCBufferStatus(p);
    }, this.handleDisconnect = (l, v) => {
      if (this._isClosed)
        return;
      this.log.warn("".concat(l, " disconnected"), this.logContext), this.reconnectAttempts === 0 && (this.reconnectStart = Date.now());
      const p = (O) => {
        this.log.warn("could not recover connection after ".concat(this.reconnectAttempts, " attempts, ").concat(O, "ms. giving up"), this.logContext), this.emit(EngineEvent.Disconnected), this.close();
      }, _ = Date.now() - this.reconnectStart;
      let k = this.getNextRetryDelay({
        elapsedMs: _,
        retryCount: this.reconnectAttempts
      });
      if (k === null) {
        p(_);
        return;
      }
      l === leaveReconnect && (k = 0), this.log.debug("reconnecting in ".concat(k, "ms"), this.logContext), this.clearReconnectTimeout(), this.token && this.regionUrlProvider && this.regionUrlProvider.updateToken(this.token), this.reconnectTimeout = CriticalTimers.setTimeout(() => this.attemptReconnect(v).finally(() => this.reconnectTimeout = void 0), k);
    }, this.waitForRestarted = () => new Promise((l, v) => {
      this.pcState === PCState.Connected && l();
      const p = () => {
        this.off(EngineEvent.Disconnected, _), l();
      }, _ = () => {
        this.off(EngineEvent.Restarted, p), v();
      };
      this.once(EngineEvent.Restarted, p), this.once(EngineEvent.Disconnected, _);
    }), this.updateAndEmitDCBufferStatus = (l) => {
      const v = this.isBufferStatusLow(l);
      typeof v < "u" && v !== this.dcBufferStatus.get(l) && (this.dcBufferStatus.set(l, v), this.emit(EngineEvent.DCBufferStatusChanged, v, l));
    }, this.isBufferStatusLow = (l) => {
      const v = this.dataChannelForKind(l);
      if (v)
        return v.bufferedAmount <= v.bufferedAmountLowThreshold;
    }, this.handleBrowserOnLine = () => {
      this.client.currentState === SignalConnectionState.RECONNECTING && (this.clearReconnectTimeout(), this.attemptReconnect(ReconnectReason.RR_SIGNAL_DISCONNECTED));
    }, this.log = getLogger((c = u.loggerName) !== null && c !== void 0 ? c : LoggerNames.Engine), this.loggerOptions = {
      loggerName: u.loggerName,
      loggerContextCb: () => this.logContext
    }, this.client = new SignalClient(void 0, this.loggerOptions), this.client.signalLatency = this.options.expSignalLatency, this.reconnectPolicy = this.options.reconnectPolicy, this.registerOnLineListener(), this.closingLock = new Mutex(), this.dataProcessLock = new Mutex(), this.dcBufferStatus = /* @__PURE__ */ new Map([[DataPacket_Kind.LOSSY, !0], [DataPacket_Kind.RELIABLE, !0]]), this.client.onParticipantUpdate = (l) => this.emit(EngineEvent.ParticipantUpdate, l), this.client.onConnectionQuality = (l) => this.emit(EngineEvent.ConnectionQualityUpdate, l), this.client.onRoomUpdate = (l) => this.emit(EngineEvent.RoomUpdate, l), this.client.onSubscriptionError = (l) => this.emit(EngineEvent.SubscriptionError, l), this.client.onSubscriptionPermissionUpdate = (l) => this.emit(EngineEvent.SubscriptionPermissionUpdate, l), this.client.onSpeakersChanged = (l) => this.emit(EngineEvent.SpeakersChanged, l), this.client.onStreamStateUpdate = (l) => this.emit(EngineEvent.StreamStateChanged, l);
  }
  /** @internal */
  get logContext() {
    var u, c, l, v, p, _, k, O;
    return {
      room: (c = (u = this.latestJoinResponse) === null || u === void 0 ? void 0 : u.room) === null || c === void 0 ? void 0 : c.name,
      roomID: (v = (l = this.latestJoinResponse) === null || l === void 0 ? void 0 : l.room) === null || v === void 0 ? void 0 : v.sid,
      participant: (_ = (p = this.latestJoinResponse) === null || p === void 0 ? void 0 : p.participant) === null || _ === void 0 ? void 0 : _.identity,
      pID: (O = (k = this.latestJoinResponse) === null || k === void 0 ? void 0 : k.participant) === null || O === void 0 ? void 0 : O.sid
    };
  }
  join(u, c, l, v) {
    return __awaiter$3(this, void 0, void 0, function* () {
      this.url = u, this.token = c, this.signalOpts = l, this.maxJoinAttempts = l.maxRetries;
      try {
        this.joinAttempts += 1, this.setupSignalClientCallbacks();
        const p = yield this.client.join(u, c, l, v);
        return this._isClosed = !1, this.latestJoinResponse = p, this.subscriberPrimary = p.subscriberPrimary, this.pcManager || (yield this.configure(p)), this.subscriberPrimary || this.negotiate(), this.clientConfiguration = p.clientConfiguration, p;
      } catch (p) {
        if (p instanceof ConnectionError && p.reason === 1 && (this.log.warn("Couldn't connect to server, attempt ".concat(this.joinAttempts, " of ").concat(this.maxJoinAttempts), this.logContext), this.joinAttempts < this.maxJoinAttempts))
          return this.join(u, c, l, v);
        throw p;
      }
    });
  }
  close() {
    return __awaiter$3(this, void 0, void 0, function* () {
      const u = yield this.closingLock.lock();
      if (this.isClosed) {
        u();
        return;
      }
      try {
        this._isClosed = !0, this.emit(EngineEvent.Closing), this.removeAllListeners(), this.deregisterOnLineListener(), this.clearPendingReconnect(), yield this.cleanupPeerConnections(), yield this.cleanupClient();
      } finally {
        u();
      }
    });
  }
  cleanupPeerConnections() {
    var u;
    return __awaiter$3(this, void 0, void 0, function* () {
      yield (u = this.pcManager) === null || u === void 0 ? void 0 : u.close(), this.pcManager = void 0;
      const c = (l) => {
        l && (l.close(), l.onbufferedamountlow = null, l.onclose = null, l.onclosing = null, l.onerror = null, l.onmessage = null, l.onopen = null);
      };
      c(this.lossyDC), c(this.lossyDCSub), c(this.reliableDC), c(this.reliableDCSub), this.lossyDC = void 0, this.lossyDCSub = void 0, this.reliableDC = void 0, this.reliableDCSub = void 0;
    });
  }
  cleanupClient() {
    return __awaiter$3(this, void 0, void 0, function* () {
      yield this.client.close(), this.client.resetCallbacks();
    });
  }
  addTrack(u) {
    if (this.pendingTrackResolvers[u.cid])
      throw new TrackInvalidError("a track with the same ID has already been published");
    return new Promise((c, l) => {
      const v = setTimeout(() => {
        delete this.pendingTrackResolvers[u.cid], l(new ConnectionError("publication of local track timed out, no response from server"));
      }, 1e4);
      this.pendingTrackResolvers[u.cid] = {
        resolve: (p) => {
          clearTimeout(v), c(p);
        },
        reject: () => {
          clearTimeout(v), l(new Error("Cancelled publication by calling unpublish"));
        }
      }, this.client.sendAddTrack(u);
    });
  }
  /**
   * Removes sender from PeerConnection, returning true if it was removed successfully
   * and a negotiation is necessary
   * @param sender
   * @returns
   */
  removeTrack(u) {
    if (u.track && this.pendingTrackResolvers[u.track.id]) {
      const {
        reject: c
      } = this.pendingTrackResolvers[u.track.id];
      c && c(), delete this.pendingTrackResolvers[u.track.id];
    }
    try {
      return this.pcManager.removeTrack(u), !0;
    } catch (c) {
      this.log.warn("failed to remove track", Object.assign(Object.assign({}, this.logContext), {
        error: c
      }));
    }
    return !1;
  }
  updateMuteStatus(u, c) {
    this.client.sendMuteTrack(u, c);
  }
  get dataSubscriberReadyState() {
    var u;
    return (u = this.reliableDCSub) === null || u === void 0 ? void 0 : u.readyState;
  }
  getConnectedServerAddress() {
    var u;
    return __awaiter$3(this, void 0, void 0, function* () {
      return (u = this.pcManager) === null || u === void 0 ? void 0 : u.getConnectedAddress();
    });
  }
  /* @internal */
  setRegionUrlProvider(u) {
    this.regionUrlProvider = u;
  }
  configure(u) {
    var c;
    return __awaiter$3(this, void 0, void 0, function* () {
      if (this.pcManager && this.pcManager.currentState !== PCTransportState.NEW)
        return;
      this.participantSid = (c = u.participant) === null || c === void 0 ? void 0 : c.sid;
      const l = this.makeRTCConfiguration(u);
      this.pcManager = new PCTransportManager(l, u.subscriberPrimary, this.loggerOptions), this.emit(EngineEvent.TransportsCreated, this.pcManager.publisher, this.pcManager.subscriber), this.pcManager.onIceCandidate = (v, p) => {
        this.client.sendIceCandidate(v, p);
      }, this.pcManager.onPublisherOffer = (v) => {
        this.client.sendOffer(v);
      }, this.pcManager.onDataChannel = this.handleDataChannel, this.pcManager.onStateChange = (v, p, _) => __awaiter$3(this, void 0, void 0, function* () {
        if (this.log.debug("primary PC state changed ".concat(v), this.logContext), v === PCTransportState.CONNECTED) {
          const D = this.pcState === PCState.New;
          this.pcState = PCState.Connected, D && this.emit(EngineEvent.Connected, u);
        } else
          v === PCTransportState.FAILED && this.pcState === PCState.Connected && (this.pcState = PCState.Disconnected, this.handleDisconnect("peerconnection failed", _ === "failed" ? ReconnectReason.RR_SUBSCRIBER_FAILED : ReconnectReason.RR_PUBLISHER_FAILED));
        const k = this.client.isDisconnected || this.client.currentState === SignalConnectionState.RECONNECTING, O = [PCTransportState.FAILED, PCTransportState.CLOSING, PCTransportState.CLOSED].includes(v);
        k && O && !this._isClosed && this.emit(EngineEvent.Offline);
      }), this.pcManager.onTrack = (v) => {
        this.emit(EngineEvent.MediaTrackAdded, v.track, v.streams[0], v.receiver);
      }, this.createDataChannels();
    });
  }
  setupSignalClientCallbacks() {
    this.client.onAnswer = (u) => __awaiter$3(this, void 0, void 0, function* () {
      this.pcManager && (this.log.debug("received server answer", Object.assign(Object.assign({}, this.logContext), {
        RTCSdpType: u.type
      })), yield this.pcManager.setPublisherAnswer(u));
    }), this.client.onTrickle = (u, c) => {
      this.pcManager && (this.log.trace("got ICE candidate from peer", Object.assign(Object.assign({}, this.logContext), {
        candidate: u,
        target: c
      })), this.pcManager.addIceCandidate(u, c));
    }, this.client.onOffer = (u) => __awaiter$3(this, void 0, void 0, function* () {
      if (!this.pcManager)
        return;
      const c = yield this.pcManager.createSubscriberAnswerFromOffer(u);
      this.client.sendAnswer(c);
    }), this.client.onLocalTrackPublished = (u) => {
      var c;
      if (this.log.debug("received trackPublishedResponse", Object.assign(Object.assign({}, this.logContext), {
        cid: u.cid,
        track: (c = u.track) === null || c === void 0 ? void 0 : c.sid
      })), !this.pendingTrackResolvers[u.cid]) {
        this.log.error("missing track resolver for ".concat(u.cid), Object.assign(Object.assign({}, this.logContext), {
          cid: u.cid
        }));
        return;
      }
      const {
        resolve: l
      } = this.pendingTrackResolvers[u.cid];
      delete this.pendingTrackResolvers[u.cid], l(u.track);
    }, this.client.onLocalTrackUnpublished = (u) => {
      this.emit(EngineEvent.LocalTrackUnpublished, u);
    }, this.client.onTokenRefresh = (u) => {
      this.token = u;
    }, this.client.onRemoteMuteChanged = (u, c) => {
      this.emit(EngineEvent.RemoteMute, u, c);
    }, this.client.onSubscribedQualityUpdate = (u) => {
      this.emit(EngineEvent.SubscribedQualityUpdate, u);
    }, this.client.onClose = () => {
      this.handleDisconnect("signal", ReconnectReason.RR_SIGNAL_DISCONNECTED);
    }, this.client.onLeave = (u) => {
      u != null && u.canReconnect ? (this.fullReconnectOnNext = !0, this.handleDisconnect(leaveReconnect)) : (this.emit(EngineEvent.Disconnected, u == null ? void 0 : u.reason), this.close()), this.log.debug("client leave request", Object.assign(Object.assign({}, this.logContext), {
        reason: u == null ? void 0 : u.reason
      }));
    };
  }
  makeRTCConfiguration(u) {
    var c;
    const l = Object.assign({}, this.rtcConfig);
    if (!((c = this.signalOpts) === null || c === void 0) && c.e2eeEnabled && (this.log.debug("E2EE - setting up transports with insertable streams", this.logContext), l.encodedInsertableStreams = !0), u.iceServers && !l.iceServers) {
      const v = [];
      u.iceServers.forEach((p) => {
        const _ = {
          urls: p.urls
        };
        p.username && (_.username = p.username), p.credential && (_.credential = p.credential), v.push(_);
      }), l.iceServers = v;
    }
    return u.clientConfiguration && u.clientConfiguration.forceRelay === ClientConfigSetting.ENABLED && (l.iceTransportPolicy = "relay"), l.sdpSemantics = "unified-plan", l.continualGatheringPolicy = "gather_continually", l;
  }
  createDataChannels() {
    this.pcManager && (this.lossyDC && (this.lossyDC.onmessage = null, this.lossyDC.onerror = null), this.reliableDC && (this.reliableDC.onmessage = null, this.reliableDC.onerror = null), this.lossyDC = this.pcManager.createPublisherDataChannel(lossyDataChannel, {
      // will drop older packets that arrive
      ordered: !0,
      maxRetransmits: 0
    }), this.reliableDC = this.pcManager.createPublisherDataChannel(reliableDataChannel, {
      ordered: !0
    }), this.lossyDC.onmessage = this.handleDataMessage, this.reliableDC.onmessage = this.handleDataMessage, this.lossyDC.onerror = this.handleDataError, this.reliableDC.onerror = this.handleDataError, this.lossyDC.bufferedAmountLowThreshold = 65535, this.reliableDC.bufferedAmountLowThreshold = 65535, this.lossyDC.onbufferedamountlow = this.handleBufferedAmountLow, this.reliableDC.onbufferedamountlow = this.handleBufferedAmountLow);
  }
  setPreferredCodec(u, c, l) {
    if (!("getCapabilities" in RTCRtpReceiver))
      return;
    const v = RTCRtpReceiver.getCapabilities(c);
    if (!v)
      return;
    this.log.debug("get receiver capabilities", Object.assign(Object.assign({}, this.logContext), {
      cap: v
    }));
    const p = [], _ = [], k = [];
    v.codecs.forEach((O) => {
      const D = O.mimeType.toLowerCase();
      if (D === "audio/opus") {
        p.push(O);
        return;
      }
      if (!(D === "video/".concat(l))) {
        k.push(O);
        return;
      }
      if (l === "h264") {
        O.sdpFmtpLine && O.sdpFmtpLine.includes("profile-level-id=42e01f") ? p.push(O) : _.push(O);
        return;
      }
      p.push(O);
    }), supportsSetCodecPreferences(u) && u.setCodecPreferences(p.concat(_, k));
  }
  createSender(u, c, l) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (supportsTransceiver())
        return yield this.createTransceiverRTCRtpSender(u, c, l);
      if (supportsAddTrack())
        return this.log.warn("using add-track fallback", this.logContext), yield this.createRTCRtpSender(u.mediaStreamTrack);
      throw new UnexpectedConnectionState("Required webRTC APIs not supported on this device");
    });
  }
  createSimulcastSender(u, c, l, v) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (supportsTransceiver())
        return this.createSimulcastTransceiverSender(u, c, l, v);
      if (supportsAddTrack())
        return this.log.debug("using add-track fallback", this.logContext), this.createRTCRtpSender(u.mediaStreamTrack);
      throw new UnexpectedConnectionState("Cannot stream on this device");
    });
  }
  createTransceiverRTCRtpSender(u, c, l) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!this.pcManager)
        throw new UnexpectedConnectionState("publisher is closed");
      const v = [];
      u.mediaStream && v.push(u.mediaStream);
      const p = {
        direction: "sendonly",
        streams: v
      };
      l && (p.sendEncodings = l);
      const _ = yield this.pcManager.addPublisherTransceiver(u.mediaStreamTrack, p);
      return u.kind === Track.Kind.Video && c.videoCodec && (this.setPreferredCodec(_, u.kind, c.videoCodec), u.codec = c.videoCodec), _.sender;
    });
  }
  createSimulcastTransceiverSender(u, c, l, v) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!this.pcManager)
        throw new UnexpectedConnectionState("publisher is closed");
      const p = {
        direction: "sendonly"
      };
      v && (p.sendEncodings = v);
      const _ = yield this.pcManager.addPublisherTransceiver(c.mediaStreamTrack, p);
      if (l.videoCodec)
        return this.setPreferredCodec(_, u.kind, l.videoCodec), u.setSimulcastTrackSender(l.videoCodec, _.sender), _.sender;
    });
  }
  createRTCRtpSender(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!this.pcManager)
        throw new UnexpectedConnectionState("publisher is closed");
      return this.pcManager.addPublisherTrack(u);
    });
  }
  attemptReconnect(u) {
    var c, l, v;
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!this._isClosed) {
        if (this.attemptingReconnect) {
          livekitLogger.warn("already attempting reconnect, returning early", this.logContext);
          return;
        }
        (((c = this.clientConfiguration) === null || c === void 0 ? void 0 : c.resumeConnection) === ClientConfigSetting.DISABLED || // signaling state could change to closed due to hardware sleep
        // those connections cannot be resumed
        ((v = (l = this.pcManager) === null || l === void 0 ? void 0 : l.currentState) !== null && v !== void 0 ? v : PCTransportState.NEW) === PCTransportState.NEW) && (this.fullReconnectOnNext = !0);
        try {
          this.attemptingReconnect = !0, this.fullReconnectOnNext ? yield this.restartConnection() : yield this.resumeConnection(u), this.clearPendingReconnect(), this.fullReconnectOnNext = !1;
        } catch (p) {
          this.reconnectAttempts += 1;
          let _ = !0;
          p instanceof UnexpectedConnectionState ? (this.log.debug("received unrecoverable error", Object.assign(Object.assign({}, this.logContext), {
            error: p
          })), _ = !1) : p instanceof SignalReconnectError || (this.fullReconnectOnNext = !0), _ ? this.handleDisconnect("reconnect", ReconnectReason.RR_UNKNOWN) : (this.log.info("could not recover connection after ".concat(this.reconnectAttempts, " attempts, ").concat(Date.now() - this.reconnectStart, "ms. giving up"), this.logContext), this.emit(EngineEvent.Disconnected), yield this.close());
        } finally {
          this.attemptingReconnect = !1;
        }
      }
    });
  }
  getNextRetryDelay(u) {
    try {
      return this.reconnectPolicy.nextRetryDelayInMs(u);
    } catch (c) {
      this.log.warn("encountered error in reconnect policy", Object.assign(Object.assign({}, this.logContext), {
        error: c
      }));
    }
    return null;
  }
  restartConnection(u) {
    var c, l, v;
    return __awaiter$3(this, void 0, void 0, function* () {
      try {
        if (!this.url || !this.token)
          throw new UnexpectedConnectionState("could not reconnect, url or token not saved");
        this.log.info("reconnecting, attempt: ".concat(this.reconnectAttempts), this.logContext), this.emit(EngineEvent.Restarting), this.client.isDisconnected || (yield this.client.sendLeave()), yield this.cleanupPeerConnections(), yield this.cleanupClient();
        let p;
        try {
          if (!this.signalOpts)
            throw this.log.warn("attempted connection restart, without signal options present", this.logContext), new SignalReconnectError();
          p = yield this.join(u ?? this.url, this.token, this.signalOpts);
        } catch (_) {
          throw _ instanceof ConnectionError && _.reason === 0 ? new UnexpectedConnectionState("could not reconnect, token might be expired") : new SignalReconnectError();
        }
        if (this.shouldFailNext)
          throw this.shouldFailNext = !1, new Error("simulated failure");
        if (this.client.setReconnected(), this.emit(EngineEvent.SignalRestarted, p), yield this.waitForPCReconnected(), this.client.currentState !== SignalConnectionState.CONNECTED)
          throw new SignalReconnectError("Signal connection got severed during reconnect");
        (c = this.regionUrlProvider) === null || c === void 0 || c.resetAttempts(), this.emit(EngineEvent.Restarted);
      } catch (p) {
        const _ = yield (l = this.regionUrlProvider) === null || l === void 0 ? void 0 : l.getNextBestRegionUrl();
        if (_) {
          yield this.restartConnection(_);
          return;
        } else
          throw (v = this.regionUrlProvider) === null || v === void 0 || v.resetAttempts(), p;
      }
    });
  }
  resumeConnection(u) {
    var c;
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!this.url || !this.token)
        throw new UnexpectedConnectionState("could not reconnect, url or token not saved");
      if (!this.pcManager)
        throw new UnexpectedConnectionState("publisher and subscriber connections unset");
      this.log.info("resuming signal connection, attempt ".concat(this.reconnectAttempts), this.logContext), this.emit(EngineEvent.Resuming);
      let l;
      try {
        this.setupSignalClientCallbacks(), l = yield this.client.reconnect(this.url, this.token, this.participantSid, u);
      } catch (v) {
        let p = "";
        throw v instanceof Error && (p = v.message, this.log.error(v.message, Object.assign(Object.assign({}, this.logContext), {
          error: v
        }))), v instanceof ConnectionError && v.reason === 0 ? new UnexpectedConnectionState("could not reconnect, token might be expired") : v instanceof ConnectionError && v.reason === 4 ? v : new SignalReconnectError(p);
      }
      if (this.emit(EngineEvent.SignalResumed), l) {
        const v = this.makeRTCConfiguration(l);
        this.pcManager.updateConfiguration(v);
      } else
        this.log.warn("Did not receive reconnect response", this.logContext);
      if (this.shouldFailNext)
        throw this.shouldFailNext = !1, new Error("simulated failure");
      if (yield this.pcManager.triggerIceRestart(), yield this.waitForPCReconnected(), this.client.currentState !== SignalConnectionState.CONNECTED)
        throw new SignalReconnectError("Signal connection got severed during reconnect");
      this.client.setReconnected(), ((c = this.reliableDC) === null || c === void 0 ? void 0 : c.readyState) === "open" && this.reliableDC.id === null && this.createDataChannels(), this.emit(EngineEvent.Resumed);
    });
  }
  waitForPCInitialConnection(u, c) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!this.pcManager)
        throw new UnexpectedConnectionState("PC manager is closed");
      yield this.pcManager.ensurePCTransportConnection(c, u);
    });
  }
  waitForPCReconnected() {
    return __awaiter$3(this, void 0, void 0, function* () {
      this.pcState = PCState.Reconnecting, this.log.debug("waiting for peer connection to reconnect", this.logContext);
      try {
        if (yield sleep(minReconnectWait), !this.pcManager)
          throw new UnexpectedConnectionState("PC manager is closed");
        yield this.pcManager.ensurePCTransportConnection(void 0, this.peerConnectionTimeout), this.pcState = PCState.Connected;
      } catch (u) {
        throw this.pcState = PCState.Disconnected, new ConnectionError("could not establish PC connection, ".concat(u.message));
      }
    });
  }
  /* @internal */
  sendDataPacket(u, c) {
    return __awaiter$3(this, void 0, void 0, function* () {
      const l = u.toBinary();
      yield this.ensurePublisherConnected(c);
      const v = this.dataChannelForKind(c);
      v && v.send(l), this.updateAndEmitDCBufferStatus(c);
    });
  }
  /**
   * @internal
   */
  ensureDataTransportConnected(u) {
    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.subscriberPrimary;
    var l;
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!this.pcManager)
        throw new UnexpectedConnectionState("PC manager is closed");
      const v = c ? this.pcManager.subscriber : this.pcManager.publisher, p = c ? "Subscriber" : "Publisher";
      if (!v)
        throw new ConnectionError("".concat(p, " connection not set"));
      !c && !this.pcManager.publisher.isICEConnected && this.pcManager.publisher.getICEConnectionState() !== "checking" && this.negotiate();
      const _ = this.dataChannelForKind(u, c);
      if ((_ == null ? void 0 : _.readyState) === "open")
        return;
      const k = (/* @__PURE__ */ new Date()).getTime() + this.peerConnectionTimeout;
      for (; (/* @__PURE__ */ new Date()).getTime() < k; ) {
        if (v.isICEConnected && ((l = this.dataChannelForKind(u, c)) === null || l === void 0 ? void 0 : l.readyState) === "open")
          return;
        yield sleep(50);
      }
      throw new ConnectionError("could not establish ".concat(p, " connection, state: ").concat(v.getICEConnectionState()));
    });
  }
  ensurePublisherConnected(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      yield this.ensureDataTransportConnected(u, !1);
    });
  }
  /* @internal */
  verifyTransport() {
    return !(!this.pcManager || this.pcManager.currentState !== PCTransportState.CONNECTED || !this.client.ws || this.client.ws.readyState === WebSocket.CLOSED);
  }
  /** @internal */
  negotiate() {
    return __awaiter$3(this, void 0, void 0, function* () {
      return new Promise((u, c) => __awaiter$3(this, void 0, void 0, function* () {
        if (!this.pcManager) {
          c(new NegotiationError("PC manager is closed"));
          return;
        }
        this.pcManager.requirePublisher();
        const l = new AbortController(), v = () => {
          l.abort(), this.log.debug("engine disconnected while negotiation was ongoing", this.logContext), u();
        };
        this.isClosed && c("cannot negotiate on closed engine"), this.on(EngineEvent.Closing, v), this.pcManager.publisher.once(PCEvents.RTPVideoPayloadTypes, (p) => {
          const _ = /* @__PURE__ */ new Map();
          p.forEach((k) => {
            const O = k.codec.toLowerCase();
            isVideoCodec(O) && _.set(k.payload, O);
          }), this.emit(EngineEvent.RTPVideoMapUpdate, _);
        });
        try {
          yield this.pcManager.negotiate(l), u();
        } catch (p) {
          p instanceof NegotiationError && (this.fullReconnectOnNext = !0), this.handleDisconnect("negotiation", ReconnectReason.RR_UNKNOWN), c(p);
        } finally {
          this.off(EngineEvent.Closing, v);
        }
      }));
    });
  }
  dataChannelForKind(u, c) {
    if (c) {
      if (u === DataPacket_Kind.LOSSY)
        return this.lossyDCSub;
      if (u === DataPacket_Kind.RELIABLE)
        return this.reliableDCSub;
    } else {
      if (u === DataPacket_Kind.LOSSY)
        return this.lossyDC;
      if (u === DataPacket_Kind.RELIABLE)
        return this.reliableDC;
    }
  }
  /** @internal */
  sendSyncState(u, c) {
    var l, v;
    if (!this.pcManager) {
      this.log.warn("sync state cannot be sent without peer connection setup", this.logContext);
      return;
    }
    const p = this.pcManager.subscriber.getLocalDescription(), _ = this.pcManager.subscriber.getRemoteDescription(), k = (v = (l = this.signalOpts) === null || l === void 0 ? void 0 : l.autoSubscribe) !== null && v !== void 0 ? v : !0, O = new Array(), D = new Array();
    u.forEach((F) => {
      F.isDesired !== k && O.push(F.trackSid), F.isEnabled || D.push(F.trackSid);
    }), this.client.sendSyncState(new SyncState({
      answer: p ? toProtoSessionDescription({
        sdp: p.sdp,
        type: p.type
      }) : void 0,
      offer: _ ? toProtoSessionDescription({
        sdp: _.sdp,
        type: _.type
      }) : void 0,
      subscription: new UpdateSubscription({
        trackSids: O,
        subscribe: !k,
        participantTracks: []
      }),
      publishTracks: getTrackPublicationInfo(c),
      dataChannels: this.dataChannelsInfo(),
      trackSidsDisabled: D
    }));
  }
  /* @internal */
  failNext() {
    this.shouldFailNext = !0;
  }
  dataChannelsInfo() {
    const u = [], c = (l, v) => {
      (l == null ? void 0 : l.id) !== void 0 && l.id !== null && u.push(new DataChannelInfo({
        label: l.label,
        id: l.id,
        target: v
      }));
    };
    return c(this.dataChannelForKind(DataPacket_Kind.LOSSY), SignalTarget.PUBLISHER), c(this.dataChannelForKind(DataPacket_Kind.RELIABLE), SignalTarget.PUBLISHER), c(this.dataChannelForKind(DataPacket_Kind.LOSSY, !0), SignalTarget.SUBSCRIBER), c(this.dataChannelForKind(DataPacket_Kind.RELIABLE, !0), SignalTarget.SUBSCRIBER), u;
  }
  clearReconnectTimeout() {
    this.reconnectTimeout && CriticalTimers.clearTimeout(this.reconnectTimeout);
  }
  clearPendingReconnect() {
    this.clearReconnectTimeout(), this.reconnectAttempts = 0;
  }
  registerOnLineListener() {
    isWeb() && window.addEventListener("online", this.handleBrowserOnLine);
  }
  deregisterOnLineListener() {
    isWeb() && window.removeEventListener("online", this.handleBrowserOnLine);
  }
}
class SignalReconnectError extends Error {
}
class RegionUrlProvider {
  constructor(u, c) {
    this.lastUpdateAt = 0, this.settingsCacheTime = 3e3, this.attemptedRegions = [], this.serverUrl = new URL(u), this.token = c;
  }
  updateToken(u) {
    this.token = u;
  }
  isCloud() {
    return isCloud(this.serverUrl);
  }
  getServerUrl() {
    return this.serverUrl;
  }
  getNextBestRegionUrl(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!this.isCloud())
        throw Error("region availability is only supported for LiveKit Cloud domains");
      (!this.regionSettings || Date.now() - this.lastUpdateAt > this.settingsCacheTime) && (this.regionSettings = yield this.fetchRegionSettings(u));
      const c = this.regionSettings.regions.filter((l) => !this.attemptedRegions.find((v) => v.url === l.url));
      if (c.length > 0) {
        const l = c[0];
        return this.attemptedRegions.push(l), livekitLogger.debug("next region: ".concat(l.region)), l.url;
      } else
        return null;
    });
  }
  resetAttempts() {
    this.attemptedRegions = [];
  }
  /* @internal */
  fetchRegionSettings(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      const c = yield fetch("".concat(getCloudConfigUrl(this.serverUrl), "/regions"), {
        headers: {
          authorization: "Bearer ".concat(this.token)
        },
        signal: u
      });
      if (c.ok) {
        const l = yield c.json();
        return this.lastUpdateAt = Date.now(), l;
      } else
        throw new ConnectionError("Could not fetch region settings: ".concat(c.statusText), c.status === 401 ? 0 : void 0, c.status);
    });
  }
}
function getCloudConfigUrl(a) {
  return "".concat(a.protocol.replace("ws", "http"), "//").concat(a.host, "/settings");
}
const monitorFrequency = 2e3;
function computeBitrate(a, u) {
  if (!u)
    return 0;
  let c, l;
  return "bytesReceived" in a ? (c = a.bytesReceived, l = u.bytesReceived) : "bytesSent" in a && (c = a.bytesSent, l = u.bytesSent), c === void 0 || l === void 0 || a.timestamp === void 0 || u.timestamp === void 0 ? 0 : (c - l) * 8 * 1e3 / (a.timestamp - u.timestamp);
}
class LocalAudioTrack extends LocalTrack {
  /**
   *
   * @param mediaTrack
   * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks
   * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK
   */
  constructor(u, c) {
    let l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0, v = arguments.length > 3 ? arguments[3] : void 0, p = arguments.length > 4 ? arguments[4] : void 0;
    super(u, Track.Kind.Audio, c, l, p), this.stopOnMute = !1, this.monitorSender = () => __awaiter$3(this, void 0, void 0, function* () {
      if (!this.sender) {
        this._currentBitrate = 0;
        return;
      }
      let _;
      try {
        _ = yield this.getSenderStats();
      } catch (k) {
        this.log.error("could not get audio sender stats", Object.assign(Object.assign({}, this.logContext), {
          error: k
        }));
        return;
      }
      _ && this.prevStats && (this._currentBitrate = computeBitrate(_, this.prevStats)), this.prevStats = _;
    }), this.audioContext = v, this.checkForSilence();
  }
  setDeviceId(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this._constraints.deviceId === u && this._mediaStreamTrack.getSettings().deviceId === unwrapConstraint(u) ? !0 : (this._constraints.deviceId = u, this.isMuted || (yield this.restartTrack()), this.isMuted || unwrapConstraint(u) === this._mediaStreamTrack.getSettings().deviceId);
    });
  }
  mute() {
    const u = Object.create(null, {
      mute: {
        get: () => super.mute
      }
    });
    return __awaiter$3(this, void 0, void 0, function* () {
      const c = yield this.muteLock.lock();
      try {
        return this.isMuted ? (this.log.debug("Track already muted", this.logContext), this) : (this.source === Track.Source.Microphone && this.stopOnMute && !this.isUserProvided && (this.log.debug("stopping mic track", this.logContext), this._mediaStreamTrack.stop()), yield u.mute.call(this), this);
      } finally {
        c();
      }
    });
  }
  unmute() {
    const u = Object.create(null, {
      unmute: {
        get: () => super.unmute
      }
    });
    return __awaiter$3(this, void 0, void 0, function* () {
      const c = yield this.muteLock.lock();
      try {
        if (!this.isMuted)
          return this.log.debug("Track already unmuted", this.logContext), this;
        const l = this._constraints.deviceId && this._mediaStreamTrack.getSettings().deviceId !== unwrapConstraint(this._constraints.deviceId);
        return this.source === Track.Source.Microphone && (this.stopOnMute || this._mediaStreamTrack.readyState === "ended" || l) && !this.isUserProvided && (this.log.debug("reacquiring mic track", this.logContext), yield this.restartTrack()), yield u.unmute.call(this), this;
      } finally {
        c();
      }
    });
  }
  restartTrack(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      let c;
      if (u) {
        const l = constraintsForOptions({
          audio: u
        });
        typeof l.audio != "boolean" && (c = l.audio);
      }
      yield this.restart(c);
    });
  }
  restart(u) {
    const c = Object.create(null, {
      restart: {
        get: () => super.restart
      }
    });
    return __awaiter$3(this, void 0, void 0, function* () {
      const l = yield c.restart.call(this, u);
      return this.checkForSilence(), l;
    });
  }
  /* @internal */
  startMonitor() {
    isWeb() && (this.monitorInterval || (this.monitorInterval = setInterval(() => {
      this.monitorSender();
    }, monitorFrequency)));
  }
  setProcessor(u) {
    var c;
    return __awaiter$3(this, void 0, void 0, function* () {
      const l = yield this.processorLock.lock();
      try {
        if (!this.audioContext)
          throw Error("Audio context needs to be set on LocalAudioTrack in order to enable processors");
        this.processor && (yield this.stopProcessor());
        const v = {
          kind: this.kind,
          track: this._mediaStreamTrack,
          audioContext: this.audioContext
        };
        this.log.debug("setting up audio processor ".concat(u.name), this.logContext), yield u.init(v), this.processor = u, this.processor.processedTrack && (yield (c = this.sender) === null || c === void 0 ? void 0 : c.replaceTrack(this.processor.processedTrack)), this.emit(TrackEvent.TrackProcessorUpdate, this.processor);
      } finally {
        l();
      }
    });
  }
  /**
   * @internal
   * @experimental
   */
  setAudioContext(u) {
    this.audioContext = u;
  }
  getSenderStats() {
    var u;
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!(!((u = this.sender) === null || u === void 0) && u.getStats))
        return;
      const c = yield this.sender.getStats();
      let l;
      return c.forEach((v) => {
        v.type === "outbound-rtp" && (l = {
          type: "audio",
          streamId: v.id,
          packetsSent: v.packetsSent,
          packetsLost: v.packetsLost,
          bytesSent: v.bytesSent,
          timestamp: v.timestamp,
          roundTripTime: v.roundTripTime,
          jitter: v.jitter
        });
      }), l;
    });
  }
  checkForSilence() {
    return __awaiter$3(this, void 0, void 0, function* () {
      const u = yield detectSilence(this);
      return u && (this.isMuted || this.log.warn("silence detected on local audio track", this.logContext), this.emit(TrackEvent.AudioSilenceDetected)), u;
    });
  }
}
function mediaTrackToLocalTrack(a, u, c) {
  switch (a.kind) {
    case "audio":
      return new LocalAudioTrack(a, u, !1, void 0, c);
    case "video":
      return new LocalVideoTrack(a, u, !1, c);
    default:
      throw new TrackInvalidError("unsupported track type: ".concat(a.kind));
  }
}
const presets169 = Object.values(VideoPresets), presets43 = Object.values(VideoPresets43), presetsScreenShare = Object.values(ScreenSharePresets), defaultSimulcastPresets169 = [VideoPresets.h180, VideoPresets.h360], defaultSimulcastPresets43 = [VideoPresets43.h180, VideoPresets43.h360], computeDefaultScreenShareSimulcastPresets = (a) => [{
  scaleResolutionDownBy: 2,
  fps: a.encoding.maxFramerate
}].map((c) => {
  var l, v;
  return new VideoPreset(Math.floor(a.width / c.scaleResolutionDownBy), Math.floor(a.height / c.scaleResolutionDownBy), Math.max(15e4, Math.floor(a.encoding.maxBitrate / (Math.pow(c.scaleResolutionDownBy, 2) * (((l = a.encoding.maxFramerate) !== null && l !== void 0 ? l : 30) / ((v = c.fps) !== null && v !== void 0 ? v : 30))))), c.fps, a.encoding.priority);
}), videoRids = ["q", "h", "f"];
function computeVideoEncodings(a, u, c, l) {
  var v, p;
  let _ = l == null ? void 0 : l.videoEncoding;
  a && (_ = l == null ? void 0 : l.screenShareEncoding);
  const k = l == null ? void 0 : l.simulcast, O = l == null ? void 0 : l.scalabilityMode, D = l == null ? void 0 : l.videoCodec;
  if (!_ && !k && !O || !u || !c)
    return [{}];
  _ || (_ = determineAppropriateEncoding(a, u, c, D), livekitLogger.debug("using video encoding", _));
  const F = new VideoPreset(u, c, _.maxBitrate, _.maxFramerate, _.priority);
  if (O && isSVCCodec(D)) {
    const ee = new ScalabilityMode(O), X = [];
    if (ee.spatial > 3)
      throw new Error("unsupported scalabilityMode: ".concat(O));
    const ne = getBrowser();
    if (isSafari() || (ne == null ? void 0 : ne.name) === "Chrome" && compareVersions(ne == null ? void 0 : ne.version, "113") < 0) {
      for (let Q = 0; Q < ee.spatial; Q += 1)
        X.push({
          rid: videoRids[2 - Q],
          maxBitrate: _.maxBitrate / Math.pow(3, Q),
          maxFramerate: F.encoding.maxFramerate
        });
      X[0].scalabilityMode = O;
    } else
      X.push({
        maxBitrate: _.maxBitrate,
        maxFramerate: F.encoding.maxFramerate,
        /* @ts-ignore */
        scalabilityMode: O
      });
    return livekitLogger.debug("using svc encoding", {
      encodings: X
    }), X;
  }
  if (!k)
    return [_];
  let H = [];
  a ? H = (v = sortPresets(l == null ? void 0 : l.screenShareSimulcastLayers)) !== null && v !== void 0 ? v : defaultSimulcastLayers(a, F) : H = (p = sortPresets(l == null ? void 0 : l.videoSimulcastLayers)) !== null && p !== void 0 ? p : defaultSimulcastLayers(a, F);
  let Z;
  if (H.length > 0) {
    const ee = H[0];
    H.length > 1 && ([, Z] = H);
    const X = Math.max(u, c);
    if (X >= 960 && Z)
      return encodingsFromPresets(u, c, [ee, Z, F]);
    if (X >= 480)
      return encodingsFromPresets(u, c, [ee, F]);
  }
  return encodingsFromPresets(u, c, [F]);
}
function computeTrackBackupEncodings(a, u, c) {
  var l, v, p, _;
  if (!c.backupCodec || c.backupCodec === !0 || c.backupCodec.codec === c.videoCodec)
    return;
  u !== c.backupCodec.codec && livekitLogger.warn("requested a different codec than specified as backup", {
    serverRequested: u,
    backup: c.backupCodec.codec
  }), c.videoCodec = u, c.videoEncoding = c.backupCodec.encoding;
  const k = a.mediaStreamTrack.getSettings(), O = (l = k.width) !== null && l !== void 0 ? l : (v = a.dimensions) === null || v === void 0 ? void 0 : v.width, D = (p = k.height) !== null && p !== void 0 ? p : (_ = a.dimensions) === null || _ === void 0 ? void 0 : _.height;
  return computeVideoEncodings(a.source === Track.Source.ScreenShare, O, D, c);
}
function determineAppropriateEncoding(a, u, c, l) {
  const v = presetsForResolution(a, u, c);
  let {
    encoding: p
  } = v[0];
  const _ = Math.max(u, c);
  for (let k = 0; k < v.length; k += 1) {
    const O = v[k];
    if (p = O.encoding, O.width >= _)
      break;
  }
  if (l)
    switch (l) {
      case "av1":
        p = Object.assign({}, p), p.maxBitrate = p.maxBitrate * 0.7;
        break;
      case "vp9":
        p = Object.assign({}, p), p.maxBitrate = p.maxBitrate * 0.85;
        break;
    }
  return p;
}
function presetsForResolution(a, u, c) {
  if (a)
    return presetsScreenShare;
  const l = u > c ? u / c : c / u;
  return Math.abs(l - 16 / 9) < Math.abs(l - 4 / 3) ? presets169 : presets43;
}
function defaultSimulcastLayers(a, u) {
  if (a)
    return computeDefaultScreenShareSimulcastPresets(u);
  const {
    width: c,
    height: l
  } = u, v = c > l ? c / l : l / c;
  return Math.abs(v - 16 / 9) < Math.abs(v - 4 / 3) ? defaultSimulcastPresets169 : defaultSimulcastPresets43;
}
function encodingsFromPresets(a, u, c) {
  const l = [];
  if (c.forEach((v, p) => {
    if (p >= videoRids.length)
      return;
    const _ = Math.min(a, u), O = {
      rid: videoRids[p],
      scaleResolutionDownBy: Math.max(1, _ / Math.min(v.width, v.height)),
      maxBitrate: v.encoding.maxBitrate
    };
    v.encoding.maxFramerate && (O.maxFramerate = v.encoding.maxFramerate);
    const D = isFireFox() || p === 0;
    v.encoding.priority && D && (O.priority = v.encoding.priority, O.networkPriority = v.encoding.priority), l.push(O);
  }), isReactNative() && getReactNativeOs() === "ios") {
    let v;
    l.forEach((_) => {
      v ? _.maxFramerate && _.maxFramerate > v && (v = _.maxFramerate) : v = _.maxFramerate;
    });
    let p = !0;
    l.forEach((_) => {
      var k;
      _.maxFramerate != v && (p && (p = !1, livekitLogger.info("Simulcast on iOS React-Native requires all encodings to share the same framerate.")), livekitLogger.info('Setting framerate of encoding "'.concat((k = _.rid) !== null && k !== void 0 ? k : "", '" to ').concat(v)), _.maxFramerate = v);
    });
  }
  return l;
}
function sortPresets(a) {
  if (a)
    return a.sort((u, c) => {
      const {
        encoding: l
      } = u, {
        encoding: v
      } = c;
      return l.maxBitrate > v.maxBitrate ? 1 : l.maxBitrate < v.maxBitrate ? -1 : l.maxBitrate === v.maxBitrate && l.maxFramerate && v.maxFramerate ? l.maxFramerate > v.maxFramerate ? 1 : -1 : 0;
    });
}
class ScalabilityMode {
  constructor(u) {
    const c = u.match(/^L(\d)T(\d)(h|_KEY|_KEY_SHIFT){0,1}$/);
    if (!c)
      throw new Error("invalid scalability mode");
    if (this.spatial = parseInt(c[1]), this.temporal = parseInt(c[2]), c.length > 3)
      switch (c[3]) {
        case "h":
        case "_KEY":
        case "_KEY_SHIFT":
          this.suffix = c[3];
      }
  }
  toString() {
    var u;
    return "L".concat(this.spatial, "T").concat(this.temporal).concat((u = this.suffix) !== null && u !== void 0 ? u : "");
  }
}
const refreshSubscribedCodecAfterNewCodec = 5e3;
class LocalVideoTrack extends LocalTrack {
  /**
   *
   * @param mediaTrack
   * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks
   * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK
   */
  constructor(u, c) {
    let l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0, v = arguments.length > 3 ? arguments[3] : void 0;
    super(u, Track.Kind.Video, c, l, v), this.simulcastCodecs = /* @__PURE__ */ new Map(), this.monitorSender = () => __awaiter$3(this, void 0, void 0, function* () {
      if (!this.sender) {
        this._currentBitrate = 0;
        return;
      }
      let p;
      try {
        p = yield this.getSenderStats();
      } catch (k) {
        this.log.error("could not get audio sender stats", Object.assign(Object.assign({}, this.logContext), {
          error: k
        }));
        return;
      }
      const _ = new Map(p.map((k) => [k.rid, k]));
      if (this.prevStats) {
        let k = 0;
        _.forEach((O, D) => {
          var F;
          const H = (F = this.prevStats) === null || F === void 0 ? void 0 : F.get(D);
          k += computeBitrate(O, H);
        }), this._currentBitrate = k;
      }
      this.prevStats = _;
    }), this.senderLock = new Mutex();
  }
  get isSimulcast() {
    return !!(this.sender && this.sender.getParameters().encodings.length > 1);
  }
  /* @internal */
  startMonitor(u) {
    var c;
    if (this.signalClient = u, !isWeb())
      return;
    const l = (c = this.sender) === null || c === void 0 ? void 0 : c.getParameters();
    l && (this.encodings = l.encodings), !this.monitorInterval && (this.monitorInterval = setInterval(() => {
      this.monitorSender();
    }, monitorFrequency));
  }
  stop() {
    this._mediaStreamTrack.getConstraints(), this.simulcastCodecs.forEach((u) => {
      u.mediaStreamTrack.stop();
    }), super.stop();
  }
  pauseUpstream() {
    const u = Object.create(null, {
      pauseUpstream: {
        get: () => super.pauseUpstream
      }
    });
    var c, l, v, p, _;
    return __awaiter$3(this, void 0, void 0, function* () {
      yield u.pauseUpstream.call(this);
      try {
        for (var k = !0, O = __asyncValues(this.simulcastCodecs.values()), D; D = yield O.next(), c = D.done, !c; k = !0)
          p = D.value, k = !1, yield (_ = p.sender) === null || _ === void 0 ? void 0 : _.replaceTrack(null);
      } catch (F) {
        l = {
          error: F
        };
      } finally {
        try {
          !k && !c && (v = O.return) && (yield v.call(O));
        } finally {
          if (l)
            throw l.error;
        }
      }
    });
  }
  resumeUpstream() {
    const u = Object.create(null, {
      resumeUpstream: {
        get: () => super.resumeUpstream
      }
    });
    var c, l, v, p, _;
    return __awaiter$3(this, void 0, void 0, function* () {
      yield u.resumeUpstream.call(this);
      try {
        for (var k = !0, O = __asyncValues(this.simulcastCodecs.values()), D; D = yield O.next(), c = D.done, !c; k = !0) {
          p = D.value, k = !1;
          const F = p;
          yield (_ = F.sender) === null || _ === void 0 ? void 0 : _.replaceTrack(F.mediaStreamTrack);
        }
      } catch (F) {
        l = {
          error: F
        };
      } finally {
        try {
          !k && !c && (v = O.return) && (yield v.call(O));
        } finally {
          if (l)
            throw l.error;
        }
      }
    });
  }
  mute() {
    const u = Object.create(null, {
      mute: {
        get: () => super.mute
      }
    });
    return __awaiter$3(this, void 0, void 0, function* () {
      const c = yield this.muteLock.lock();
      try {
        return this.isMuted ? (this.log.debug("Track already muted", this.logContext), this) : (this.source === Track.Source.Camera && !this.isUserProvided && (this.log.debug("stopping camera track", this.logContext), this._mediaStreamTrack.stop()), yield u.mute.call(this), this);
      } finally {
        c();
      }
    });
  }
  unmute() {
    const u = Object.create(null, {
      unmute: {
        get: () => super.unmute
      }
    });
    return __awaiter$3(this, void 0, void 0, function* () {
      const c = yield this.muteLock.lock();
      try {
        return this.isMuted ? (this.source === Track.Source.Camera && !this.isUserProvided && (this.log.debug("reacquiring camera track", this.logContext), yield this.restartTrack()), yield u.unmute.call(this), this) : (this.log.debug("Track already unmuted", this.logContext), this);
      } finally {
        c();
      }
    });
  }
  setTrackMuted(u) {
    super.setTrackMuted(u);
    for (const c of this.simulcastCodecs.values())
      c.mediaStreamTrack.enabled = !u;
  }
  getSenderStats() {
    var u;
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!(!((u = this.sender) === null || u === void 0) && u.getStats))
        return [];
      const c = [], l = yield this.sender.getStats();
      return l.forEach((v) => {
        var p;
        if (v.type === "outbound-rtp") {
          const _ = {
            type: "video",
            streamId: v.id,
            frameHeight: v.frameHeight,
            frameWidth: v.frameWidth,
            framesPerSecond: v.framesPerSecond,
            framesSent: v.framesSent,
            firCount: v.firCount,
            pliCount: v.pliCount,
            nackCount: v.nackCount,
            packetsSent: v.packetsSent,
            bytesSent: v.bytesSent,
            qualityLimitationReason: v.qualityLimitationReason,
            qualityLimitationDurations: v.qualityLimitationDurations,
            qualityLimitationResolutionChanges: v.qualityLimitationResolutionChanges,
            rid: (p = v.rid) !== null && p !== void 0 ? p : v.id,
            retransmittedPacketsSent: v.retransmittedPacketsSent,
            targetBitrate: v.targetBitrate,
            timestamp: v.timestamp
          }, k = l.get(v.remoteId);
          k && (_.jitter = k.jitter, _.packetsLost = k.packetsLost, _.roundTripTime = k.roundTripTime), c.push(_);
        }
      }), c.sort((v, p) => {
        var _, k;
        return ((_ = p.frameWidth) !== null && _ !== void 0 ? _ : 0) - ((k = v.frameWidth) !== null && k !== void 0 ? k : 0);
      }), c;
    });
  }
  setPublishingQuality(u) {
    const c = [];
    for (let l = VideoQuality.LOW; l <= VideoQuality.HIGH; l += 1)
      c.push(new SubscribedQuality({
        quality: l,
        enabled: l <= u
      }));
    this.log.debug("setting publishing quality. max quality ".concat(u), this.logContext), this.setPublishingLayers(c);
  }
  setDeviceId(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this._constraints.deviceId === u && this._mediaStreamTrack.getSettings().deviceId === unwrapConstraint(u) ? !0 : (this._constraints.deviceId = u, this.isMuted || (yield this.restartTrack()), this.isMuted || unwrapConstraint(u) === this._mediaStreamTrack.getSettings().deviceId);
    });
  }
  restartTrack(u) {
    var c, l, v, p;
    return __awaiter$3(this, void 0, void 0, function* () {
      let _;
      if (u) {
        const F = constraintsForOptions({
          video: u
        });
        typeof F.video != "boolean" && (_ = F.video);
      }
      yield this.restart(_);
      try {
        for (var k = !0, O = __asyncValues(this.simulcastCodecs.values()), D; D = yield O.next(), c = D.done, !c; k = !0) {
          p = D.value, k = !1;
          const F = p;
          F.sender && (F.mediaStreamTrack = this.mediaStreamTrack.clone(), yield F.sender.replaceTrack(F.mediaStreamTrack));
        }
      } catch (F) {
        l = {
          error: F
        };
      } finally {
        try {
          !k && !c && (v = O.return) && (yield v.call(O));
        } finally {
          if (l)
            throw l.error;
        }
      }
    });
  }
  setProcessor(u) {
    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
    const l = Object.create(null, {
      setProcessor: {
        get: () => super.setProcessor
      }
    });
    var v, p, _, k, O, D;
    return __awaiter$3(this, void 0, void 0, function* () {
      if (yield l.setProcessor.call(this, u, c), !((O = this.processor) === null || O === void 0) && O.processedTrack)
        try {
          for (var F = !0, H = __asyncValues(this.simulcastCodecs.values()), Z; Z = yield H.next(), v = Z.done, !v; F = !0)
            k = Z.value, F = !1, yield (D = k.sender) === null || D === void 0 ? void 0 : D.replaceTrack(this.processor.processedTrack);
        } catch (ee) {
          p = {
            error: ee
          };
        } finally {
          try {
            !F && !v && (_ = H.return) && (yield _.call(H));
          } finally {
            if (p)
              throw p.error;
          }
        }
    });
  }
  addSimulcastTrack(u, c) {
    if (this.simulcastCodecs.has(u)) {
      this.log.error("".concat(u, " already added, skipping adding simulcast codec"), this.logContext);
      return;
    }
    const l = {
      codec: u,
      mediaStreamTrack: this.mediaStreamTrack.clone(),
      sender: void 0,
      encodings: c
    };
    return this.simulcastCodecs.set(u, l), l;
  }
  setSimulcastTrackSender(u, c) {
    const l = this.simulcastCodecs.get(u);
    l && (l.sender = c, setTimeout(() => {
      this.subscribedCodecs && this.setPublishingCodecs(this.subscribedCodecs);
    }, refreshSubscribedCodecAfterNewCodec));
  }
  /**
   * @internal
   * Sets codecs that should be publishing, returns new codecs that have not yet
   * been published
   */
  setPublishingCodecs(u) {
    var c, l, v, p, _, k, O;
    return __awaiter$3(this, void 0, void 0, function* () {
      if (this.log.debug("setting publishing codecs", Object.assign(Object.assign({}, this.logContext), {
        codecs: u,
        currentCodec: this.codec
      })), !this.codec && u.length > 0)
        return yield this.setPublishingLayers(u[0].qualities), [];
      this.subscribedCodecs = u;
      const D = [];
      try {
        for (c = !0, l = __asyncValues(u); v = yield l.next(), p = v.done, !p; c = !0) {
          O = v.value, c = !1;
          const F = O;
          if (!this.codec || this.codec === F.codec)
            yield this.setPublishingLayers(F.qualities);
          else {
            const H = this.simulcastCodecs.get(F.codec);
            if (this.log.debug("try setPublishingCodec for ".concat(F.codec), Object.assign(Object.assign({}, this.logContext), {
              simulcastCodecInfo: H
            })), !H || !H.sender) {
              for (const Z of F.qualities)
                if (Z.enabled) {
                  D.push(F.codec);
                  break;
                }
            } else
              H.encodings && (this.log.debug("try setPublishingLayersForSender ".concat(F.codec), this.logContext), yield setPublishingLayersForSender(H.sender, H.encodings, F.qualities, this.senderLock, this.log, this.logContext));
          }
        }
      } catch (F) {
        _ = {
          error: F
        };
      } finally {
        try {
          !c && !p && (k = l.return) && (yield k.call(l));
        } finally {
          if (_)
            throw _.error;
        }
      }
      return D;
    });
  }
  /**
   * @internal
   * Sets layers that should be publishing
   */
  setPublishingLayers(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      this.log.debug("setting publishing layers", Object.assign(Object.assign({}, this.logContext), {
        qualities: u
      })), !(!this.sender || !this.encodings) && (yield setPublishingLayersForSender(this.sender, this.encodings, u, this.senderLock, this.log, this.logContext));
    });
  }
  handleAppVisibilityChanged() {
    const u = Object.create(null, {
      handleAppVisibilityChanged: {
        get: () => super.handleAppVisibilityChanged
      }
    });
    return __awaiter$3(this, void 0, void 0, function* () {
      yield u.handleAppVisibilityChanged.call(this), isMobile() && this.isInBackground && this.source === Track.Source.Camera && (this._mediaStreamTrack.enabled = !1);
    });
  }
}
function setPublishingLayersForSender(a, u, c, l, v, p) {
  return __awaiter$3(this, void 0, void 0, function* () {
    const _ = yield l.lock();
    v.debug("setPublishingLayersForSender", Object.assign(Object.assign({}, p), {
      sender: a,
      qualities: c,
      senderEncodings: u
    }));
    try {
      const k = a.getParameters(), {
        encodings: O
      } = k;
      if (!O)
        return;
      if (O.length !== u.length) {
        v.warn("cannot set publishing layers, encodings mismatch", Object.assign(Object.assign({}, p), {
          encodings: O,
          senderEncodings: u
        }));
        return;
      }
      let D = !1;
      !1 && O[0].scalabilityMode || O.forEach((H, Z) => {
        var ee;
        let X = (ee = H.rid) !== null && ee !== void 0 ? ee : "";
        X === "" && (X = "q");
        const ne = videoQualityForRid(X), Q = c.find((ae) => ae.quality === ne);
        Q && H.active !== Q.enabled && (D = !0, H.active = Q.enabled, v.debug("setting layer ".concat(Q.quality, " to ").concat(H.active ? "enabled" : "disabled"), p), isFireFox() && (Q.enabled ? (H.scaleResolutionDownBy = u[Z].scaleResolutionDownBy, H.maxBitrate = u[Z].maxBitrate, H.maxFrameRate = u[Z].maxFrameRate) : (H.scaleResolutionDownBy = 4, H.maxBitrate = 10, H.maxFrameRate = 2)));
      }), D && (k.encodings = O, v.debug("setting encodings", Object.assign(Object.assign({}, p), {
        encodings: k.encodings
      })), yield a.setParameters(k));
    } finally {
      _();
    }
  });
}
function videoQualityForRid(a) {
  switch (a) {
    case "f":
      return VideoQuality.HIGH;
    case "h":
      return VideoQuality.MEDIUM;
    case "q":
      return VideoQuality.LOW;
    default:
      return VideoQuality.HIGH;
  }
}
function videoLayersFromEncodings(a, u, c, l) {
  if (!c)
    return [new VideoLayer({
      quality: VideoQuality.HIGH,
      width: a,
      height: u,
      bitrate: 0,
      ssrc: 0
    })];
  if (l) {
    const v = c[0].scalabilityMode, p = new ScalabilityMode(v), _ = [];
    for (let k = 0; k < p.spatial; k += 1)
      _.push(new VideoLayer({
        quality: VideoQuality.HIGH - k,
        width: Math.ceil(a / Math.pow(2, k)),
        height: Math.ceil(u / Math.pow(2, k)),
        bitrate: c[0].maxBitrate ? Math.ceil(c[0].maxBitrate / Math.pow(3, k)) : 0,
        ssrc: 0
      }));
    return _;
  }
  return c.map((v) => {
    var p, _, k;
    const O = (p = v.scaleResolutionDownBy) !== null && p !== void 0 ? p : 1;
    let D = videoQualityForRid((_ = v.rid) !== null && _ !== void 0 ? _ : "");
    return new VideoLayer({
      quality: D,
      width: Math.ceil(a / O),
      height: Math.ceil(u / O),
      bitrate: (k = v.maxBitrate) !== null && k !== void 0 ? k : 0,
      ssrc: 0
    });
  });
}
class RemoteTrack extends Track {
  constructor(u, c, l, v, p) {
    super(u, l, p), this.sid = c, this.receiver = v;
  }
  /** @internal */
  setMuted(u) {
    this.isMuted !== u && (this.isMuted = u, this._mediaStreamTrack.enabled = !u, this.emit(u ? TrackEvent.Muted : TrackEvent.Unmuted, this));
  }
  /** @internal */
  setMediaStream(u) {
    this.mediaStream = u;
    const c = (l) => {
      l.track === this._mediaStreamTrack && (u.removeEventListener("removetrack", c), this.receiver = void 0, this._currentBitrate = 0, this.emit(TrackEvent.Ended, this));
    };
    u.addEventListener("removetrack", c);
  }
  start() {
    this.startMonitor(), super.enable();
  }
  stop() {
    this.stopMonitor(), super.disable();
  }
  /**
   * Gets the RTCStatsReport for the RemoteTrack's underlying RTCRtpReceiver
   * See https://developer.mozilla.org/en-US/docs/Web/API/RTCStatsReport
   *
   * @returns Promise<RTCStatsReport> | undefined
   */
  getRTCStatsReport() {
    var u;
    return __awaiter$3(this, void 0, void 0, function* () {
      return !((u = this.receiver) === null || u === void 0) && u.getStats ? yield this.receiver.getStats() : void 0;
    });
  }
  /* @internal */
  startMonitor() {
    this.monitorInterval || (this.monitorInterval = setInterval(() => this.monitorReceiver(), monitorFrequency));
  }
}
class RemoteAudioTrack extends RemoteTrack {
  constructor(u, c, l, v, p, _) {
    super(u, c, Track.Kind.Audio, l, _), this.monitorReceiver = () => __awaiter$3(this, void 0, void 0, function* () {
      if (!this.receiver) {
        this._currentBitrate = 0;
        return;
      }
      const k = yield this.getReceiverStats();
      k && this.prevStats && this.receiver && (this._currentBitrate = computeBitrate(k, this.prevStats)), this.prevStats = k;
    }), this.audioContext = v, this.webAudioPluginNodes = [], p && (this.sinkId = p.deviceId);
  }
  /**
   * sets the volume for all attached audio elements
   */
  setVolume(u) {
    var c;
    for (const l of this.attachedElements)
      this.audioContext ? (c = this.gainNode) === null || c === void 0 || c.gain.setTargetAtTime(u, 0, 0.1) : l.volume = u;
    isReactNative() && this._mediaStreamTrack._setVolume(u), this.elementVolume = u;
  }
  /**
   * gets the volume of attached audio elements (loudest)
   */
  getVolume() {
    if (this.elementVolume)
      return this.elementVolume;
    if (isReactNative())
      return 1;
    let u = 0;
    return this.attachedElements.forEach((c) => {
      c.volume > u && (u = c.volume);
    }), u;
  }
  /**
   * calls setSinkId on all attached elements, if supported
   * @param deviceId audio output device
   */
  setSinkId(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      this.sinkId = u, yield Promise.all(this.attachedElements.map((c) => {
        if (supportsSetSinkId(c))
          return c.setSinkId(u);
      }));
    });
  }
  attach(u) {
    const c = this.attachedElements.length === 0;
    return u ? super.attach(u) : u = super.attach(), this.sinkId && supportsSetSinkId(u) && u.setSinkId(this.sinkId), this.audioContext && c && (this.log.debug("using audio context mapping", this.logContext), this.connectWebAudio(this.audioContext, u), u.volume = 0, u.muted = !0), this.elementVolume && this.setVolume(this.elementVolume), u;
  }
  detach(u) {
    let c;
    return u ? (c = super.detach(u), this.audioContext && (this.attachedElements.length > 0 ? this.connectWebAudio(this.audioContext, this.attachedElements[0]) : this.disconnectWebAudio())) : (c = super.detach(), this.disconnectWebAudio()), c;
  }
  /**
   * @internal
   * @experimental
   */
  setAudioContext(u) {
    this.audioContext = u, u && this.attachedElements.length > 0 ? this.connectWebAudio(u, this.attachedElements[0]) : u || this.disconnectWebAudio();
  }
  /**
   * @internal
   * @experimental
   * @param {AudioNode[]} nodes - An array of WebAudio nodes. These nodes should not be connected to each other when passed, as the sdk will take care of connecting them in the order of the array.
   */
  setWebAudioPlugins(u) {
    this.webAudioPluginNodes = u, this.attachedElements.length > 0 && this.audioContext && this.connectWebAudio(this.audioContext, this.attachedElements[0]);
  }
  connectWebAudio(u, c) {
    this.disconnectWebAudio(), this.sourceNode = u.createMediaStreamSource(c.srcObject);
    let l = this.sourceNode;
    this.webAudioPluginNodes.forEach((v) => {
      l.connect(v), l = v;
    }), this.gainNode = u.createGain(), l.connect(this.gainNode), this.gainNode.connect(u.destination), this.elementVolume && this.gainNode.gain.setTargetAtTime(this.elementVolume, 0, 0.1), u.state !== "running" && u.resume().then(() => {
      u.state !== "running" && this.emit(TrackEvent.AudioPlaybackFailed, new Error("Audio Context couldn't be started automatically"));
    }).catch((v) => {
      this.emit(TrackEvent.AudioPlaybackFailed, v);
    });
  }
  disconnectWebAudio() {
    var u, c;
    (u = this.gainNode) === null || u === void 0 || u.disconnect(), (c = this.sourceNode) === null || c === void 0 || c.disconnect(), this.gainNode = void 0, this.sourceNode = void 0;
  }
  getReceiverStats() {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!this.receiver || !this.receiver.getStats)
        return;
      const u = yield this.receiver.getStats();
      let c;
      return u.forEach((l) => {
        l.type === "inbound-rtp" && (c = {
          type: "audio",
          timestamp: l.timestamp,
          jitter: l.jitter,
          bytesReceived: l.bytesReceived,
          concealedSamples: l.concealedSamples,
          concealmentEvents: l.concealmentEvents,
          silentConcealedSamples: l.silentConcealedSamples,
          silentConcealmentEvents: l.silentConcealmentEvents,
          totalAudioEnergy: l.totalAudioEnergy,
          totalSamplesDuration: l.totalSamplesDuration
        });
      }), c;
    });
  }
}
const REACTION_DELAY = 100;
class RemoteVideoTrack extends RemoteTrack {
  constructor(u, c, l, v, p) {
    super(u, c, Track.Kind.Video, l, p), this.elementInfos = [], this.monitorReceiver = () => __awaiter$3(this, void 0, void 0, function* () {
      if (!this.receiver) {
        this._currentBitrate = 0;
        return;
      }
      const _ = yield this.getReceiverStats();
      _ && this.prevStats && this.receiver && (this._currentBitrate = computeBitrate(_, this.prevStats)), this.prevStats = _;
    }), this.debouncedHandleResize = r$1(() => {
      this.updateDimensions();
    }, REACTION_DELAY), this.adaptiveStreamSettings = v;
  }
  get isAdaptiveStream() {
    return this.adaptiveStreamSettings !== void 0;
  }
  /**
   * Note: When using adaptiveStream, you need to use remoteVideoTrack.attach() to add the track to a HTMLVideoElement, otherwise your video tracks might never start
   */
  get mediaStreamTrack() {
    return this._mediaStreamTrack;
  }
  /** @internal */
  setMuted(u) {
    super.setMuted(u), this.attachedElements.forEach((c) => {
      u ? detachTrack(this._mediaStreamTrack, c) : attachToElement(this._mediaStreamTrack, c);
    });
  }
  attach(u) {
    if (u ? super.attach(u) : u = super.attach(), this.adaptiveStreamSettings && this.elementInfos.find((c) => c.element === u) === void 0) {
      const c = new HTMLElementInfo(u);
      this.observeElementInfo(c);
    }
    return u;
  }
  /**
   * Observe an ElementInfo for changes when adaptive streaming.
   * @param elementInfo
   * @internal
   */
  observeElementInfo(u) {
    this.adaptiveStreamSettings && this.elementInfos.find((c) => c === u) === void 0 ? (u.handleResize = () => {
      this.debouncedHandleResize();
    }, u.handleVisibilityChanged = () => {
      this.updateVisibility();
    }, this.elementInfos.push(u), u.observe(), this.debouncedHandleResize(), this.updateVisibility()) : this.log.warn("visibility resize observer not triggered", this.logContext);
  }
  /**
   * Stop observing an ElementInfo for changes.
   * @param elementInfo
   * @internal
   */
  stopObservingElementInfo(u) {
    if (!this.isAdaptiveStream) {
      this.log.warn("stopObservingElementInfo ignored", this.logContext);
      return;
    }
    const c = this.elementInfos.filter((l) => l === u);
    for (const l of c)
      l.stopObserving();
    this.elementInfos = this.elementInfos.filter((l) => l !== u), this.updateVisibility(), this.debouncedHandleResize();
  }
  detach(u) {
    let c = [];
    if (u)
      return this.stopObservingElement(u), super.detach(u);
    c = super.detach();
    for (const l of c)
      this.stopObservingElement(l);
    return c;
  }
  /** @internal */
  getDecoderImplementation() {
    var u;
    return (u = this.prevStats) === null || u === void 0 ? void 0 : u.decoderImplementation;
  }
  getReceiverStats() {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!this.receiver || !this.receiver.getStats)
        return;
      const u = yield this.receiver.getStats();
      let c, l = "", v = /* @__PURE__ */ new Map();
      return u.forEach((p) => {
        p.type === "inbound-rtp" ? (l = p.codecId, c = {
          type: "video",
          framesDecoded: p.framesDecoded,
          framesDropped: p.framesDropped,
          framesReceived: p.framesReceived,
          packetsReceived: p.packetsReceived,
          packetsLost: p.packetsLost,
          frameWidth: p.frameWidth,
          frameHeight: p.frameHeight,
          pliCount: p.pliCount,
          firCount: p.firCount,
          nackCount: p.nackCount,
          jitter: p.jitter,
          timestamp: p.timestamp,
          bytesReceived: p.bytesReceived,
          decoderImplementation: p.decoderImplementation
        }) : p.type === "codec" && v.set(p.id, p);
      }), c && l !== "" && v.get(l) && (c.mimeType = v.get(l).mimeType), c;
    });
  }
  stopObservingElement(u) {
    const c = this.elementInfos.filter((l) => l.element === u);
    for (const l of c)
      this.stopObservingElementInfo(l);
  }
  handleAppVisibilityChanged() {
    const u = Object.create(null, {
      handleAppVisibilityChanged: {
        get: () => super.handleAppVisibilityChanged
      }
    });
    return __awaiter$3(this, void 0, void 0, function* () {
      yield u.handleAppVisibilityChanged.call(this), this.isAdaptiveStream && this.updateVisibility();
    });
  }
  updateVisibility() {
    var u, c;
    const l = this.elementInfos.reduce((k, O) => Math.max(k, O.visibilityChangedAt || 0), 0), v = !((c = (u = this.adaptiveStreamSettings) === null || u === void 0 ? void 0 : u.pauseVideoInBackground) !== null && c !== void 0) || c ? this.isInBackground : !1, p = this.elementInfos.some((k) => k.pictureInPicture), _ = this.elementInfos.some((k) => k.visible) && !v || p;
    if (this.lastVisible !== _) {
      if (!_ && Date.now() - l < REACTION_DELAY) {
        CriticalTimers.setTimeout(() => {
          this.updateVisibility();
        }, REACTION_DELAY);
        return;
      }
      this.lastVisible = _, this.emit(TrackEvent.VisibilityChanged, _, this);
    }
  }
  updateDimensions() {
    var u, c;
    let l = 0, v = 0;
    const p = this.getPixelDensity();
    for (const _ of this.elementInfos) {
      const k = _.width() * p, O = _.height() * p;
      k + O > l + v && (l = k, v = O);
    }
    ((u = this.lastDimensions) === null || u === void 0 ? void 0 : u.width) === l && ((c = this.lastDimensions) === null || c === void 0 ? void 0 : c.height) === v || (this.lastDimensions = {
      width: l,
      height: v
    }, this.emit(TrackEvent.VideoDimensionsChanged, this.lastDimensions, this));
  }
  getPixelDensity() {
    var u;
    const c = (u = this.adaptiveStreamSettings) === null || u === void 0 ? void 0 : u.pixelDensity;
    return c === "screen" ? getDevicePixelRatio() : c || (getDevicePixelRatio() > 2 ? 2 : 1);
  }
}
class HTMLElementInfo {
  get visible() {
    return this.isPiP || this.isIntersecting;
  }
  get pictureInPicture() {
    return this.isPiP;
  }
  constructor(u, c) {
    this.onVisibilityChanged = (l) => {
      var v;
      const {
        target: p,
        isIntersecting: _
      } = l;
      p === this.element && (this.isIntersecting = _, this.visibilityChangedAt = Date.now(), (v = this.handleVisibilityChanged) === null || v === void 0 || v.call(this));
    }, this.onEnterPiP = () => {
      var l;
      this.isPiP = !0, (l = this.handleVisibilityChanged) === null || l === void 0 || l.call(this);
    }, this.onLeavePiP = () => {
      var l;
      this.isPiP = !1, (l = this.handleVisibilityChanged) === null || l === void 0 || l.call(this);
    }, this.element = u, this.isIntersecting = c ?? isElementInViewport(u), this.isPiP = isWeb() && document.pictureInPictureElement === u, this.visibilityChangedAt = 0;
  }
  width() {
    return this.element.clientWidth;
  }
  height() {
    return this.element.clientHeight;
  }
  observe() {
    this.isIntersecting = isElementInViewport(this.element), this.isPiP = document.pictureInPictureElement === this.element, this.element.handleResize = () => {
      var u;
      (u = this.handleResize) === null || u === void 0 || u.call(this);
    }, this.element.handleVisibilityChanged = this.onVisibilityChanged, getIntersectionObserver().observe(this.element), getResizeObserver().observe(this.element), this.element.addEventListener("enterpictureinpicture", this.onEnterPiP), this.element.addEventListener("leavepictureinpicture", this.onLeavePiP);
  }
  stopObserving() {
    var u, c;
    (u = getIntersectionObserver()) === null || u === void 0 || u.unobserve(this.element), (c = getResizeObserver()) === null || c === void 0 || c.unobserve(this.element), this.element.removeEventListener("enterpictureinpicture", this.onEnterPiP), this.element.removeEventListener("leavepictureinpicture", this.onLeavePiP);
  }
}
function isElementInViewport(a) {
  let u = a.offsetTop, c = a.offsetLeft;
  const l = a.offsetWidth, v = a.offsetHeight, {
    hidden: p
  } = a, {
    opacity: _,
    display: k
  } = getComputedStyle(a);
  for (; a.offsetParent; )
    a = a.offsetParent, u += a.offsetTop, c += a.offsetLeft;
  return u < window.pageYOffset + window.innerHeight && c < window.pageXOffset + window.innerWidth && u + v > window.pageYOffset && c + l > window.pageXOffset && !p && (_ !== "" ? parseFloat(_) > 0 : !0) && k !== "none";
}
class TrackPublication extends eventsExports$1.EventEmitter {
  constructor(u, c, l, v) {
    var p;
    super(), this.metadataMuted = !1, this.encryption = Encryption_Type.NONE, this.log = livekitLogger, this.handleMuted = () => {
      this.emit(TrackEvent.Muted);
    }, this.handleUnmuted = () => {
      this.emit(TrackEvent.Unmuted);
    }, this.log = getLogger((p = v == null ? void 0 : v.loggerName) !== null && p !== void 0 ? p : LoggerNames.Publication), this.loggerContextCb = this.loggerContextCb, this.setMaxListeners(100), this.kind = u, this.trackSid = c, this.trackName = l, this.source = Track.Source.Unknown;
  }
  /** @internal */
  setTrack(u) {
    this.track && (this.track.off(TrackEvent.Muted, this.handleMuted), this.track.off(TrackEvent.Unmuted, this.handleUnmuted)), this.track = u, u && (u.on(TrackEvent.Muted, this.handleMuted), u.on(TrackEvent.Unmuted, this.handleUnmuted));
  }
  get logContext() {
    var u;
    return Object.assign(Object.assign({}, (u = this.loggerContextCb) === null || u === void 0 ? void 0 : u.call(this)), getLogContextFromTrack(this));
  }
  get isMuted() {
    return this.metadataMuted;
  }
  get isEnabled() {
    return !0;
  }
  get isSubscribed() {
    return this.track !== void 0;
  }
  get isEncrypted() {
    return this.encryption !== Encryption_Type.NONE;
  }
  /**
   * an [AudioTrack] if this publication holds an audio track
   */
  get audioTrack() {
    if (this.track instanceof LocalAudioTrack || this.track instanceof RemoteAudioTrack)
      return this.track;
  }
  /**
   * an [VideoTrack] if this publication holds a video track
   */
  get videoTrack() {
    if (this.track instanceof LocalVideoTrack || this.track instanceof RemoteVideoTrack)
      return this.track;
  }
  /** @internal */
  updateInfo(u) {
    this.trackSid = u.sid, this.trackName = u.name, this.source = Track.sourceFromProto(u.source), this.mimeType = u.mimeType, this.kind === Track.Kind.Video && u.width > 0 && (this.dimensions = {
      width: u.width,
      height: u.height
    }, this.simulcasted = u.simulcast), this.encryption = u.encryption, this.trackInfo = u, this.log.debug("update publication info", Object.assign(Object.assign({}, this.logContext), {
      info: u
    }));
  }
}
(function(a) {
  (function(u) {
    u.Desired = "desired", u.Subscribed = "subscribed", u.Unsubscribed = "unsubscribed";
  })(a.SubscriptionStatus || (a.SubscriptionStatus = {})), function(u) {
    u.Allowed = "allowed", u.NotAllowed = "not_allowed";
  }(a.PermissionStatus || (a.PermissionStatus = {}));
})(TrackPublication || (TrackPublication = {}));
class LocalTrackPublication extends TrackPublication {
  get isUpstreamPaused() {
    var u;
    return (u = this.track) === null || u === void 0 ? void 0 : u.isUpstreamPaused;
  }
  constructor(u, c, l, v) {
    super(u, c.sid, c.name, v), this.track = void 0, this.handleTrackEnded = () => {
      this.emit(TrackEvent.Ended);
    }, this.updateInfo(c), this.setTrack(l);
  }
  setTrack(u) {
    this.track && this.track.off(TrackEvent.Ended, this.handleTrackEnded), super.setTrack(u), u && u.on(TrackEvent.Ended, this.handleTrackEnded);
  }
  get isMuted() {
    return this.track ? this.track.isMuted : super.isMuted;
  }
  get audioTrack() {
    return super.audioTrack;
  }
  get videoTrack() {
    return super.videoTrack;
  }
  /**
   * Mute the track associated with this publication
   */
  mute() {
    var u;
    return __awaiter$3(this, void 0, void 0, function* () {
      return (u = this.track) === null || u === void 0 ? void 0 : u.mute();
    });
  }
  /**
   * Unmute track associated with this publication
   */
  unmute() {
    var u;
    return __awaiter$3(this, void 0, void 0, function* () {
      return (u = this.track) === null || u === void 0 ? void 0 : u.unmute();
    });
  }
  /**
   * Pauses the media stream track associated with this publication from being sent to the server
   * and signals "muted" event to other participants
   * Useful if you want to pause the stream without pausing the local media stream track
   */
  pauseUpstream() {
    var u;
    return __awaiter$3(this, void 0, void 0, function* () {
      yield (u = this.track) === null || u === void 0 ? void 0 : u.pauseUpstream();
    });
  }
  /**
   * Resumes sending the media stream track associated with this publication to the server after a call to [[pauseUpstream()]]
   * and signals "unmuted" event to other participants (unless the track is explicitly muted)
   */
  resumeUpstream() {
    var u;
    return __awaiter$3(this, void 0, void 0, function* () {
      yield (u = this.track) === null || u === void 0 ? void 0 : u.resumeUpstream();
    });
  }
}
var ConnectionQuality;
(function(a) {
  a.Excellent = "excellent", a.Good = "good", a.Poor = "poor", a.Lost = "lost", a.Unknown = "unknown";
})(ConnectionQuality || (ConnectionQuality = {}));
function qualityFromProto(a) {
  switch (a) {
    case ConnectionQuality$1.EXCELLENT:
      return ConnectionQuality.Excellent;
    case ConnectionQuality$1.GOOD:
      return ConnectionQuality.Good;
    case ConnectionQuality$1.POOR:
      return ConnectionQuality.Poor;
    case ConnectionQuality$1.LOST:
      return ConnectionQuality.Lost;
    default:
      return ConnectionQuality.Unknown;
  }
}
class Participant extends eventsExports$1.EventEmitter {
  get logContext() {
    var u, c;
    return Object.assign({}, (c = (u = this.loggerOptions) === null || u === void 0 ? void 0 : u.loggerContextCb) === null || c === void 0 ? void 0 : c.call(u));
  }
  get isEncrypted() {
    return this.trackPublications.size > 0 && Array.from(this.trackPublications.values()).every((u) => u.isEncrypted);
  }
  get isAgent() {
    var u, c;
    return (c = (u = this.permissions) === null || u === void 0 ? void 0 : u.agent) !== null && c !== void 0 ? c : !1;
  }
  /** @internal */
  constructor(u, c, l, v, p) {
    var _;
    super(), this.audioLevel = 0, this.isSpeaking = !1, this._connectionQuality = ConnectionQuality.Unknown, this.log = livekitLogger, this.log = getLogger((_ = p == null ? void 0 : p.loggerName) !== null && _ !== void 0 ? _ : LoggerNames.Participant), this.loggerOptions = p, this.setMaxListeners(100), this.sid = u, this.identity = c, this.name = l, this.metadata = v, this.audioTrackPublications = /* @__PURE__ */ new Map(), this.videoTrackPublications = /* @__PURE__ */ new Map(), this.trackPublications = /* @__PURE__ */ new Map();
  }
  getTrackPublications() {
    return Array.from(this.trackPublications.values());
  }
  /**
   * Finds the first track that matches the source filter, for example, getting
   * the user's camera track with getTrackBySource(Track.Source.Camera).
   */
  getTrackPublication(u) {
    for (const [, c] of this.trackPublications)
      if (c.source === u)
        return c;
  }
  /**
   * Finds the first track that matches the track's name.
   */
  getTrackPublicationByName(u) {
    for (const [, c] of this.trackPublications)
      if (c.trackName === u)
        return c;
  }
  get connectionQuality() {
    return this._connectionQuality;
  }
  get isCameraEnabled() {
    var u;
    const c = this.getTrackPublication(Track.Source.Camera);
    return !(!((u = c == null ? void 0 : c.isMuted) !== null && u !== void 0) || u);
  }
  get isMicrophoneEnabled() {
    var u;
    const c = this.getTrackPublication(Track.Source.Microphone);
    return !(!((u = c == null ? void 0 : c.isMuted) !== null && u !== void 0) || u);
  }
  get isScreenShareEnabled() {
    return !!this.getTrackPublication(Track.Source.ScreenShare);
  }
  get isLocal() {
    return !1;
  }
  /** when participant joined the room */
  get joinedAt() {
    return this.participantInfo ? new Date(Number.parseInt(this.participantInfo.joinedAt.toString()) * 1e3) : /* @__PURE__ */ new Date();
  }
  /** @internal */
  updateInfo(u) {
    return this.participantInfo && this.participantInfo.sid === u.sid && this.participantInfo.version > u.version ? !1 : (this.identity = u.identity, this.sid = u.sid, this._setName(u.name), this._setMetadata(u.metadata), u.permission && this.setPermissions(u.permission), this.participantInfo = u, this.log.trace("update participant info", Object.assign(Object.assign({}, this.logContext), {
      info: u
    })), !0);
  }
  /**
   * Updates metadata from server
   **/
  _setMetadata(u) {
    const c = this.metadata !== u, l = this.metadata;
    this.metadata = u, c && this.emit(ParticipantEvent.ParticipantMetadataChanged, l);
  }
  _setName(u) {
    const c = this.name !== u;
    this.name = u, c && this.emit(ParticipantEvent.ParticipantNameChanged, u);
  }
  /** @internal */
  setPermissions(u) {
    var c, l, v, p, _;
    const k = this.permissions, O = u.canPublish !== ((c = this.permissions) === null || c === void 0 ? void 0 : c.canPublish) || u.canSubscribe !== ((l = this.permissions) === null || l === void 0 ? void 0 : l.canSubscribe) || u.canPublishData !== ((v = this.permissions) === null || v === void 0 ? void 0 : v.canPublishData) || u.hidden !== ((p = this.permissions) === null || p === void 0 ? void 0 : p.hidden) || u.recorder !== ((_ = this.permissions) === null || _ === void 0 ? void 0 : _.recorder) || u.canPublishSources.length !== this.permissions.canPublishSources.length || u.canPublishSources.some((D, F) => {
      var H;
      return D !== ((H = this.permissions) === null || H === void 0 ? void 0 : H.canPublishSources[F]);
    });
    return this.permissions = u, O && this.emit(ParticipantEvent.ParticipantPermissionsChanged, k), O;
  }
  /** @internal */
  setIsSpeaking(u) {
    u !== this.isSpeaking && (this.isSpeaking = u, u && (this.lastSpokeAt = /* @__PURE__ */ new Date()), this.emit(ParticipantEvent.IsSpeakingChanged, u));
  }
  /** @internal */
  setConnectionQuality(u) {
    const c = this._connectionQuality;
    this._connectionQuality = qualityFromProto(u), c !== this._connectionQuality && this.emit(ParticipantEvent.ConnectionQualityChanged, this._connectionQuality);
  }
  /**
   * @internal
   */
  setAudioContext(u) {
    this.audioContext = u, this.audioTrackPublications.forEach((c) => (c.track instanceof RemoteAudioTrack || c.track instanceof LocalAudioTrack) && c.track.setAudioContext(u));
  }
  addTrackPublication(u) {
    u.on(TrackEvent.Muted, () => {
      this.emit(ParticipantEvent.TrackMuted, u);
    }), u.on(TrackEvent.Unmuted, () => {
      this.emit(ParticipantEvent.TrackUnmuted, u);
    });
    const c = u;
    switch (c.track && (c.track.sid = u.trackSid), this.trackPublications.set(u.trackSid, u), u.kind) {
      case Track.Kind.Audio:
        this.audioTrackPublications.set(u.trackSid, u);
        break;
      case Track.Kind.Video:
        this.videoTrackPublications.set(u.trackSid, u);
        break;
    }
  }
}
function trackPermissionToProto(a) {
  var u, c, l;
  if (!a.participantSid && !a.participantIdentity)
    throw new Error("Invalid track permission, must provide at least one of participantIdentity and participantSid");
  return new TrackPermission({
    participantIdentity: (u = a.participantIdentity) !== null && u !== void 0 ? u : "",
    participantSid: (c = a.participantSid) !== null && c !== void 0 ? c : "",
    allTracks: (l = a.allowAll) !== null && l !== void 0 ? l : !1,
    trackSids: a.allowedTrackSids || []
  });
}
class LocalParticipant extends Participant {
  /** @internal */
  constructor(u, c, l, v) {
    super(u, c, void 0, void 0, {
      loggerName: v.loggerName,
      loggerContextCb: () => this.engine.logContext
    }), this.pendingPublishing = /* @__PURE__ */ new Set(), this.pendingPublishPromises = /* @__PURE__ */ new Map(), this.participantTrackPermissions = [], this.allParticipantsAllowedToSubscribe = !0, this.encryptionType = Encryption_Type.NONE, this.handleReconnecting = () => {
      this.reconnectFuture || (this.reconnectFuture = new Future());
    }, this.handleReconnected = () => {
      var p, _;
      (_ = (p = this.reconnectFuture) === null || p === void 0 ? void 0 : p.resolve) === null || _ === void 0 || _.call(p), this.reconnectFuture = void 0, this.updateTrackSubscriptionPermissions();
    }, this.handleDisconnected = () => {
      var p, _;
      this.reconnectFuture && (this.reconnectFuture.promise.catch((k) => this.log.warn(k.message, this.logContext)), (_ = (p = this.reconnectFuture) === null || p === void 0 ? void 0 : p.reject) === null || _ === void 0 || _.call(p, "Got disconnected during reconnection attempt"), this.reconnectFuture = void 0);
    }, this.updateTrackSubscriptionPermissions = () => {
      this.log.debug("updating track subscription permissions", Object.assign(Object.assign({}, this.logContext), {
        allParticipantsAllowed: this.allParticipantsAllowedToSubscribe,
        participantTrackPermissions: this.participantTrackPermissions
      })), this.engine.client.sendUpdateSubscriptionPermissions(this.allParticipantsAllowedToSubscribe, this.participantTrackPermissions.map((p) => trackPermissionToProto(p)));
    }, this.onTrackUnmuted = (p) => {
      this.onTrackMuted(p, p.isUpstreamPaused);
    }, this.onTrackMuted = (p, _) => {
      if (_ === void 0 && (_ = !0), !p.sid) {
        this.log.error("could not update mute status for unpublished track", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(p)));
        return;
      }
      this.engine.updateMuteStatus(p.sid, _);
    }, this.onTrackUpstreamPaused = (p) => {
      this.log.debug("upstream paused", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(p))), this.onTrackMuted(p, !0);
    }, this.onTrackUpstreamResumed = (p) => {
      this.log.debug("upstream resumed", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(p))), this.onTrackMuted(p, p.isMuted);
    }, this.handleSubscribedQualityUpdate = (p) => __awaiter$3(this, void 0, void 0, function* () {
      var _, k, O, D, F, H;
      if (!(!((F = this.roomOptions) === null || F === void 0) && F.dynacast))
        return;
      const Z = this.videoTrackPublications.get(p.trackSid);
      if (!Z) {
        this.log.warn("received subscribed quality update for unknown track", Object.assign(Object.assign({}, this.logContext), {
          trackSid: p.trackSid
        }));
        return;
      }
      if (p.subscribedCodecs.length > 0) {
        if (!Z.videoTrack)
          return;
        const Q = yield Z.videoTrack.setPublishingCodecs(p.subscribedCodecs);
        try {
          for (var ee = !0, X = __asyncValues(Q), ne; ne = yield X.next(), _ = ne.done, !_; ee = !0) {
            D = ne.value, ee = !1;
            const ae = D;
            isBackupCodec(ae) && (this.log.debug("publish ".concat(ae, " for ").concat(Z.videoTrack.sid), Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(Z))), yield this.publishAdditionalCodecForTrack(Z.videoTrack, ae, Z.options));
          }
        } catch (ae) {
          k = {
            error: ae
          };
        } finally {
          try {
            !ee && !_ && (O = X.return) && (yield O.call(X));
          } finally {
            if (k)
              throw k.error;
          }
        }
      } else
        p.subscribedQualities.length > 0 && (yield (H = Z.videoTrack) === null || H === void 0 ? void 0 : H.setPublishingLayers(p.subscribedQualities));
    }), this.handleLocalTrackUnpublished = (p) => {
      const _ = this.trackPublications.get(p.trackSid);
      if (!_) {
        this.log.warn("received unpublished event for unknown track", Object.assign(Object.assign({}, this.logContext), {
          trackSid: p.trackSid
        }));
        return;
      }
      this.unpublishTrack(_.track);
    }, this.handleTrackEnded = (p) => __awaiter$3(this, void 0, void 0, function* () {
      if (p.source === Track.Source.ScreenShare || p.source === Track.Source.ScreenShareAudio)
        this.log.debug("unpublishing local track due to TrackEnded", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(p))), this.unpublishTrack(p);
      else if (p.isUserProvided)
        yield p.mute();
      else if (p instanceof LocalAudioTrack || p instanceof LocalVideoTrack)
        try {
          if (isWeb())
            try {
              const _ = yield navigator == null ? void 0 : navigator.permissions.query({
                // the permission query for camera and microphone currently not supported in Safari and Firefox
                // @ts-ignore
                name: p.source === Track.Source.Camera ? "camera" : "microphone"
              });
              if (_ && _.state === "denied")
                throw this.log.warn("user has revoked access to ".concat(p.source), Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(p))), _.onchange = () => {
                  _.state !== "denied" && (p.isMuted || p.restartTrack(), _.onchange = null);
                }, new Error("GetUserMedia Permission denied");
            } catch {
            }
          p.isMuted || (this.log.debug("track ended, attempting to use a different device", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(p))), yield p.restartTrack());
        } catch {
          this.log.warn("could not restart track, muting instead", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(p))), yield p.mute();
        }
    }), this.audioTrackPublications = /* @__PURE__ */ new Map(), this.videoTrackPublications = /* @__PURE__ */ new Map(), this.trackPublications = /* @__PURE__ */ new Map(), this.engine = l, this.roomOptions = v, this.setupEngine(l), this.activeDeviceMap = /* @__PURE__ */ new Map();
  }
  get lastCameraError() {
    return this.cameraError;
  }
  get lastMicrophoneError() {
    return this.microphoneError;
  }
  get isE2EEEnabled() {
    return this.encryptionType !== Encryption_Type.NONE;
  }
  getTrackPublication(u) {
    const c = super.getTrackPublication(u);
    if (c)
      return c;
  }
  getTrackPublicationByName(u) {
    const c = super.getTrackPublicationByName(u);
    if (c)
      return c;
  }
  /**
   * @internal
   */
  setupEngine(u) {
    this.engine = u, this.engine.on(EngineEvent.RemoteMute, (c, l) => {
      const v = this.trackPublications.get(c);
      !v || !v.track || (l ? v.mute() : v.unmute());
    }), this.engine.on(EngineEvent.Connected, this.handleReconnected).on(EngineEvent.SignalRestarted, this.handleReconnected).on(EngineEvent.SignalResumed, this.handleReconnected).on(EngineEvent.Restarting, this.handleReconnecting).on(EngineEvent.Resuming, this.handleReconnecting).on(EngineEvent.LocalTrackUnpublished, this.handleLocalTrackUnpublished).on(EngineEvent.SubscribedQualityUpdate, this.handleSubscribedQualityUpdate).on(EngineEvent.Disconnected, this.handleDisconnected);
  }
  /**
   * Sets and updates the metadata of the local participant.
   * The change does not take immediate effect.
   * If successful, a `ParticipantEvent.MetadataChanged` event will be emitted on the local participant.
   * Note: this requires `canUpdateOwnMetadata` permission.
   * @param metadata
   */
  setMetadata(u) {
    var c;
    this.engine.client.sendUpdateLocalMetadata(u, (c = this.name) !== null && c !== void 0 ? c : "");
  }
  /**
   * Sets and updates the name of the local participant.
   * The change does not take immediate effect.
   * If successful, a `ParticipantEvent.ParticipantNameChanged` event will be emitted on the local participant.
   * Note: this requires `canUpdateOwnMetadata` permission.
   * @param metadata
   */
  setName(u) {
    var c;
    this.engine.client.sendUpdateLocalMetadata((c = this.metadata) !== null && c !== void 0 ? c : "", u);
  }
  /**
   * Enable or disable a participant's camera track.
   *
   * If a track has already published, it'll mute or unmute the track.
   * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise
   */
  setCameraEnabled(u, c, l) {
    return this.setTrackEnabled(Track.Source.Camera, u, c, l);
  }
  /**
   * Enable or disable a participant's microphone track.
   *
   * If a track has already published, it'll mute or unmute the track.
   * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise
   */
  setMicrophoneEnabled(u, c, l) {
    return this.setTrackEnabled(Track.Source.Microphone, u, c, l);
  }
  /**
   * Start or stop sharing a participant's screen
   * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise
   */
  setScreenShareEnabled(u, c, l) {
    return this.setTrackEnabled(Track.Source.ScreenShare, u, c, l);
  }
  /** @internal */
  setPermissions(u) {
    const c = this.permissions, l = super.setPermissions(u);
    return l && c && this.emit(ParticipantEvent.ParticipantPermissionsChanged, c), l;
  }
  /** @internal */
  setE2EEEnabled(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      this.encryptionType = u ? Encryption_Type.GCM : Encryption_Type.NONE, yield this.republishAllTracks(void 0, !1);
    });
  }
  setTrackEnabled(u, c, l, v) {
    var p, _;
    return __awaiter$3(this, void 0, void 0, function* () {
      this.log.debug("setTrackEnabled", Object.assign(Object.assign({}, this.logContext), {
        source: u,
        enabled: c
      }));
      let k = this.getTrackPublication(u);
      if (c)
        if (k)
          yield k.unmute();
        else {
          let O;
          if (this.pendingPublishing.has(u)) {
            this.log.info("skipping duplicate published source", Object.assign(Object.assign({}, this.logContext), {
              source: u
            }));
            return;
          }
          this.pendingPublishing.add(u);
          try {
            switch (u) {
              case Track.Source.Camera:
                O = yield this.createTracks({
                  video: (p = l) !== null && p !== void 0 ? p : !0
                });
                break;
              case Track.Source.Microphone:
                O = yield this.createTracks({
                  audio: (_ = l) !== null && _ !== void 0 ? _ : !0
                });
                break;
              case Track.Source.ScreenShare:
                O = yield this.createScreenTracks(Object.assign({}, l));
                break;
              default:
                throw new TrackInvalidError(u);
            }
            const D = [];
            for (const H of O)
              this.log.info("publishing track", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(H))), D.push(this.publishTrack(H, v));
            [k] = yield Promise.all(D);
          } catch (D) {
            throw O == null || O.forEach((F) => {
              F.stop();
            }), D instanceof Error && !(D instanceof TrackInvalidError) && this.emit(ParticipantEvent.MediaDevicesError, D), D;
          } finally {
            this.pendingPublishing.delete(u);
          }
        }
      else if (k && k.track)
        if (u === Track.Source.ScreenShare) {
          k = yield this.unpublishTrack(k.track);
          const O = this.getTrackPublication(Track.Source.ScreenShareAudio);
          O && O.track && this.unpublishTrack(O.track);
        } else
          yield k.mute();
      return k;
    });
  }
  /**
   * Publish both camera and microphone at the same time. This is useful for
   * displaying a single Permission Dialog box to the end user.
   */
  enableCameraAndMicrophone() {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!(this.pendingPublishing.has(Track.Source.Camera) || this.pendingPublishing.has(Track.Source.Microphone))) {
        this.pendingPublishing.add(Track.Source.Camera), this.pendingPublishing.add(Track.Source.Microphone);
        try {
          const u = yield this.createTracks({
            audio: !0,
            video: !0
          });
          yield Promise.all(u.map((c) => this.publishTrack(c)));
        } finally {
          this.pendingPublishing.delete(Track.Source.Camera), this.pendingPublishing.delete(Track.Source.Microphone);
        }
      }
    });
  }
  /**
   * Create local camera and/or microphone tracks
   * @param options
   * @returns
   */
  createTracks(u) {
    var c, l;
    return __awaiter$3(this, void 0, void 0, function* () {
      const v = mergeDefaultOptions(u, (c = this.roomOptions) === null || c === void 0 ? void 0 : c.audioCaptureDefaults, (l = this.roomOptions) === null || l === void 0 ? void 0 : l.videoCaptureDefaults), p = constraintsForOptions(v);
      let _;
      try {
        _ = yield navigator.mediaDevices.getUserMedia(p);
      } catch (k) {
        throw k instanceof Error && (p.audio && (this.microphoneError = k), p.video && (this.cameraError = k)), k;
      }
      return p.audio && (this.microphoneError = void 0, this.emit(ParticipantEvent.AudioStreamAcquired)), p.video && (this.cameraError = void 0), _.getTracks().map((k) => {
        const O = k.kind === "audio";
        O ? u.audio : u.video;
        let D;
        const F = O ? p.audio : p.video;
        typeof F != "boolean" && (D = F);
        const H = mediaTrackToLocalTrack(k, D, {
          loggerName: this.roomOptions.loggerName,
          loggerContextCb: () => this.logContext
        });
        return H.kind === Track.Kind.Video ? H.source = Track.Source.Camera : H.kind === Track.Kind.Audio && (H.source = Track.Source.Microphone), H.mediaStream = _, H;
      });
    });
  }
  /**
   * Creates a screen capture tracks with getDisplayMedia().
   * A LocalVideoTrack is always created and returned.
   * If { audio: true }, and the browser supports audio capture, a LocalAudioTrack is also created.
   */
  createScreenTracks(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (u === void 0 && (u = {}), navigator.mediaDevices.getDisplayMedia === void 0)
        throw new DeviceUnsupportedError("getDisplayMedia not supported");
      u.resolution === void 0 && !isSafari17() && (u.resolution = ScreenSharePresets.h1080fps30.resolution);
      const c = screenCaptureToDisplayMediaStreamOptions(u), l = yield navigator.mediaDevices.getDisplayMedia(c), v = l.getVideoTracks();
      if (v.length === 0)
        throw new TrackInvalidError("no video track found");
      const p = new LocalVideoTrack(v[0], void 0, !1, {
        loggerName: this.roomOptions.loggerName,
        loggerContextCb: () => this.logContext
      });
      p.source = Track.Source.ScreenShare, u.contentHint && (p.mediaStreamTrack.contentHint = u.contentHint);
      const _ = [p];
      if (l.getAudioTracks().length > 0) {
        this.emit(ParticipantEvent.AudioStreamAcquired);
        const k = new LocalAudioTrack(l.getAudioTracks()[0], void 0, !1, this.audioContext, {
          loggerName: this.roomOptions.loggerName,
          loggerContextCb: () => this.logContext
        });
        k.source = Track.Source.ScreenShareAudio, _.push(k);
      }
      return _;
    });
  }
  /**
   * Publish a new track to the room
   * @param track
   * @param options
   */
  publishTrack(u, c) {
    var l, v, p, _;
    return __awaiter$3(this, void 0, void 0, function* () {
      u instanceof LocalAudioTrack && u.setAudioContext(this.audioContext), yield (l = this.reconnectFuture) === null || l === void 0 ? void 0 : l.promise, u instanceof LocalTrack && this.pendingPublishPromises.has(u) && (yield this.pendingPublishPromises.get(u));
      let k;
      if (u instanceof MediaStreamTrack)
        k = u.getConstraints();
      else {
        k = u.constraints;
        let ee;
        switch (u.source) {
          case Track.Source.Microphone:
            ee = "audioinput";
            break;
          case Track.Source.Camera:
            ee = "videoinput";
        }
        ee && this.activeDeviceMap.has(ee) && (k = Object.assign(Object.assign({}, k), {
          deviceId: this.activeDeviceMap.get(ee)
        }));
      }
      if (u instanceof MediaStreamTrack)
        switch (u.kind) {
          case "audio":
            u = new LocalAudioTrack(u, k, !0, this.audioContext, {
              loggerName: this.roomOptions.loggerName,
              loggerContextCb: () => this.logContext
            });
            break;
          case "video":
            u = new LocalVideoTrack(u, k, !0, {
              loggerName: this.roomOptions.loggerName,
              loggerContextCb: () => this.logContext
            });
            break;
          default:
            throw new TrackInvalidError("unsupported MediaStreamTrack kind ".concat(u.kind));
        }
      else
        u.updateLoggerOptions({
          loggerName: this.roomOptions.loggerName,
          loggerContextCb: () => this.logContext
        });
      let O;
      if (this.trackPublications.forEach((ee) => {
        ee.track && ee.track === u && (O = ee);
      }), O)
        return this.log.warn("track has already been published, skipping", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(O))), O;
      const D = "channelCount" in u.mediaStreamTrack.getSettings() && // @ts-ignore `channelCount` on getSettings() is currently only available for Safari, but is generally the best way to determine a stereo track https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackSettings/channelCount
      u.mediaStreamTrack.getSettings().channelCount === 2 || u.mediaStreamTrack.getConstraints().channelCount === 2, F = (v = c == null ? void 0 : c.forceStereo) !== null && v !== void 0 ? v : D;
      F && (c || (c = {}), c.dtx === void 0 && this.log.info("Opus DTX will be disabled for stereo tracks by default. Enable them explicitly to make it work.", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(u))), c.red === void 0 && this.log.info("Opus RED will be disabled for stereo tracks by default. Enable them explicitly to make it work."), (p = c.dtx) !== null && p !== void 0 || (c.dtx = !1), (_ = c.red) !== null && _ !== void 0 || (c.red = !1));
      const H = Object.assign(Object.assign({}, this.roomOptions.publishDefaults), c);
      isSafari() && this.roomOptions.e2ee && (this.log.info("End-to-end encryption is set up, simulcast publishing will be disabled on Safari", Object.assign({}, this.logContext)), H.simulcast = !1), H.source && (u.source = H.source);
      const Z = this.publish(u, H, F);
      this.pendingPublishPromises.set(u, Z);
      try {
        return yield Z;
      } catch (ee) {
        throw ee;
      } finally {
        this.pendingPublishPromises.delete(u);
      }
    });
  }
  publish(u, c, l) {
    var v, p, _, k, O, D, F, H, Z, ee, X, ne;
    return __awaiter$3(this, void 0, void 0, function* () {
      Array.from(this.trackPublications.values()).find((ke) => u instanceof LocalTrack && ke.source === u.source) && u.source !== Track.Source.Unknown && this.log.info("publishing a second track with the same source: ".concat(u.source), Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(u))), c.stopMicTrackOnMute && u instanceof LocalAudioTrack && (u.stopOnMute = !0), u.source === Track.Source.ScreenShare && isFireFox() && (c.simulcast = !1), c.videoCodec === "av1" && !supportsAV1() && (c.videoCodec = void 0), c.videoCodec === "vp9" && !supportsVP9() && (c.videoCodec = void 0), c.videoCodec === void 0 && (c.videoCodec = defaultVideoCodec);
      const ae = c.videoCodec;
      u.on(TrackEvent.Muted, this.onTrackMuted), u.on(TrackEvent.Unmuted, this.onTrackUnmuted), u.on(TrackEvent.Ended, this.handleTrackEnded), u.on(TrackEvent.UpstreamPaused, this.onTrackUpstreamPaused), u.on(TrackEvent.UpstreamResumed, this.onTrackUpstreamResumed);
      const j = new AddTrackRequest({
        // get local track id for use during publishing
        cid: u.mediaStreamTrack.id,
        name: c.name,
        type: Track.kindToProto(u.kind),
        muted: u.isMuted,
        source: Track.sourceToProto(u.source),
        disableDtx: !(!((v = c.dtx) !== null && v !== void 0) || v),
        encryption: this.encryptionType,
        stereo: l,
        disableRed: this.isE2EEEnabled || !(!((p = c.red) !== null && p !== void 0) || p),
        stream: c == null ? void 0 : c.stream
      });
      let ue;
      if (u.kind === Track.Kind.Video) {
        let ke = {
          width: 0,
          height: 0
        };
        try {
          ke = yield u.waitForDimensions();
        } catch {
          const q = (k = (_ = this.roomOptions.videoCaptureDefaults) === null || _ === void 0 ? void 0 : _.resolution) !== null && k !== void 0 ? k : VideoPresets.h720.resolution;
          ke = {
            width: q.width,
            height: q.height
          }, this.log.error("could not determine track dimensions, using defaults", Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(u)), {
            dims: ke
          }));
        }
        j.width = ke.width, j.height = ke.height, u instanceof LocalVideoTrack && (isSVCCodec(ae) && (u.source === Track.Source.ScreenShare && (c.scalabilityMode = "L1T3", "contentHint" in u.mediaStreamTrack && (u.mediaStreamTrack.contentHint = "motion", this.log.info("forcing contentHint to motion for screenshare with SVC codecs", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(u))))), c.scalabilityMode = (O = c.scalabilityMode) !== null && O !== void 0 ? O : "L3T3_KEY"), j.simulcastCodecs = [new SimulcastCodec({
          codec: ae,
          cid: u.mediaStreamTrack.id
        })], c.backupCodec === !0 && (c.backupCodec = {
          codec: defaultVideoCodec
        }), c.backupCodec && ae !== c.backupCodec.codec && // TODO remove this once e2ee is supported for backup codecs
        j.encryption === Encryption_Type.NONE && (this.roomOptions.dynacast || (this.roomOptions.dynacast = !0), j.simulcastCodecs.push(new SimulcastCodec({
          codec: c.backupCodec.codec,
          cid: ""
        })))), ue = computeVideoEncodings(u.source === Track.Source.ScreenShare, j.width, j.height, c), j.layers = videoLayersFromEncodings(j.width, j.height, ue, isSVCCodec(c.videoCodec));
      } else
        u.kind === Track.Kind.Audio && (ue = [{
          maxBitrate: (D = c.audioPreset) === null || D === void 0 ? void 0 : D.maxBitrate,
          priority: (H = (F = c.audioPreset) === null || F === void 0 ? void 0 : F.priority) !== null && H !== void 0 ? H : "high",
          networkPriority: (ee = (Z = c.audioPreset) === null || Z === void 0 ? void 0 : Z.priority) !== null && ee !== void 0 ? ee : "high"
        }]);
      if (!this.engine || this.engine.isClosed)
        throw new UnexpectedConnectionState("cannot publish track when not connected");
      const he = yield this.engine.addTrack(j);
      let fe;
      if (he.codecs.forEach((ke) => {
        fe === void 0 && (fe = ke.mimeType);
      }), fe && u.kind === Track.Kind.Video) {
        const ke = mimeTypeToVideoCodecString(fe);
        ke !== ae && (this.log.debug("falling back to server selected codec", Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(u)), {
          codec: ke
        })), c.videoCodec = ke, ue = computeVideoEncodings(u.source === Track.Source.ScreenShare, j.width, j.height, c));
      }
      const be = new LocalTrackPublication(u.kind, he, u, {
        loggerName: this.roomOptions.loggerName,
        loggerContextCb: () => this.logContext
      });
      if (be.options = c, u.sid = he.sid, !this.engine.pcManager)
        throw new UnexpectedConnectionState("pcManager is not ready");
      if (this.log.debug("publishing ".concat(u.kind, " with encodings"), Object.assign(Object.assign({}, this.logContext), {
        encodings: ue,
        trackInfo: he
      })), u.sender = yield this.engine.createSender(u, c, ue), ue)
        if (isFireFox() && u.kind === Track.Kind.Audio) {
          let ke;
          for (const Te of this.engine.pcManager.publisher.getTransceivers())
            if (Te.sender === u.sender) {
              ke = Te;
              break;
            }
          ke && this.engine.pcManager.publisher.setTrackCodecBitrate({
            transceiver: ke,
            codec: "opus",
            maxbr: !((X = ue[0]) === null || X === void 0) && X.maxBitrate ? ue[0].maxBitrate / 1e3 : 0
          });
        } else
          u.codec && u.codec == "av1" && (!((ne = ue[0]) === null || ne === void 0) && ne.maxBitrate) && this.engine.pcManager.publisher.setTrackCodecBitrate({
            cid: j.cid,
            codec: u.codec,
            maxbr: ue[0].maxBitrate / 1e3
          });
      if (u.kind === Track.Kind.Video && u.source === Track.Source.ScreenShare)
        try {
          this.log.debug("setting degradationPreference to maintain-resolution");
          const ke = u.sender.getParameters();
          ke.degradationPreference = "maintain-resolution", yield u.sender.setParameters(ke);
        } catch (ke) {
          this.log.warn("failed to set degradationPreference: ".concat(ke));
        }
      return yield this.engine.negotiate(), u instanceof LocalVideoTrack ? u.startMonitor(this.engine.client) : u instanceof LocalAudioTrack && u.startMonitor(), this.addTrackPublication(be), this.emit(ParticipantEvent.LocalTrackPublished, be), be;
    });
  }
  get isLocal() {
    return !0;
  }
  /** @internal
   * publish additional codec to existing track
   */
  publishAdditionalCodecForTrack(u, c, l) {
    var v;
    return __awaiter$3(this, void 0, void 0, function* () {
      if (this.encryptionType !== Encryption_Type.NONE)
        return;
      let p;
      if (this.trackPublications.forEach((H) => {
        H.track && H.track === u && (p = H);
      }), !p)
        throw new TrackInvalidError("track is not published");
      if (!(u instanceof LocalVideoTrack))
        throw new TrackInvalidError("track is not a video track");
      const _ = Object.assign(Object.assign({}, (v = this.roomOptions) === null || v === void 0 ? void 0 : v.publishDefaults), l), k = computeTrackBackupEncodings(u, c, _);
      if (!k) {
        this.log.info("backup codec has been disabled, ignoring request to add additional codec for track", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(u)));
        return;
      }
      const O = u.addSimulcastTrack(c, k);
      if (!O)
        return;
      const D = new AddTrackRequest({
        cid: O.mediaStreamTrack.id,
        type: Track.kindToProto(u.kind),
        muted: u.isMuted,
        source: Track.sourceToProto(u.source),
        sid: u.sid,
        simulcastCodecs: [{
          codec: _.videoCodec,
          cid: O.mediaStreamTrack.id
        }]
      });
      if (D.layers = videoLayersFromEncodings(D.width, D.height, k), !this.engine || this.engine.isClosed)
        throw new UnexpectedConnectionState("cannot publish track when not connected");
      const F = yield this.engine.addTrack(D);
      yield this.engine.createSimulcastSender(u, O, _, k), yield this.engine.negotiate(), this.log.debug("published ".concat(c, " for track ").concat(u.sid), Object.assign(Object.assign({}, this.logContext), {
        encodings: k,
        trackInfo: F
      }));
    });
  }
  unpublishTrack(u, c) {
    var l, v;
    return __awaiter$3(this, void 0, void 0, function* () {
      const p = this.getPublicationForTrack(u), _ = p ? getLogContextFromTrack(p) : void 0;
      if (this.log.debug("unpublishing track", Object.assign(Object.assign({}, this.logContext), _)), !p || !p.track) {
        this.log.warn("track was not unpublished because no publication was found", Object.assign(Object.assign({}, this.logContext), _));
        return;
      }
      u = p.track, u.off(TrackEvent.Muted, this.onTrackMuted), u.off(TrackEvent.Unmuted, this.onTrackUnmuted), u.off(TrackEvent.Ended, this.handleTrackEnded), u.off(TrackEvent.UpstreamPaused, this.onTrackUpstreamPaused), u.off(TrackEvent.UpstreamResumed, this.onTrackUpstreamResumed), c === void 0 && (c = (v = (l = this.roomOptions) === null || l === void 0 ? void 0 : l.stopLocalTrackOnUnpublish) !== null && v !== void 0 ? v : !0), c && u.stop();
      let k = !1;
      const O = u.sender;
      if (u.sender = void 0, this.engine.pcManager && this.engine.pcManager.currentState < PCTransportState.FAILED && O)
        try {
          for (const D of this.engine.pcManager.publisher.getTransceivers())
            D.sender === O && (D.direction = "inactive", k = !0);
          if (this.engine.removeTrack(O) && (k = !0), u instanceof LocalVideoTrack) {
            for (const [, D] of u.simulcastCodecs)
              D.sender && (this.engine.removeTrack(D.sender) && (k = !0), D.sender = void 0);
            u.simulcastCodecs.clear();
          }
        } catch (D) {
          this.log.warn("failed to unpublish track", Object.assign(Object.assign(Object.assign({}, this.logContext), _), {
            error: D
          }));
        }
      switch (this.trackPublications.delete(p.trackSid), p.kind) {
        case Track.Kind.Audio:
          this.audioTrackPublications.delete(p.trackSid);
          break;
        case Track.Kind.Video:
          this.videoTrackPublications.delete(p.trackSid);
          break;
      }
      return this.emit(ParticipantEvent.LocalTrackUnpublished, p), p.setTrack(void 0), k && (yield this.engine.negotiate()), p;
    });
  }
  unpublishTracks(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      return (yield Promise.all(u.map((l) => this.unpublishTrack(l)))).filter((l) => l instanceof LocalTrackPublication);
    });
  }
  republishAllTracks(u) {
    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
    return __awaiter$3(this, void 0, void 0, function* () {
      const l = [];
      this.trackPublications.forEach((v) => {
        v.track && (u && (v.options = Object.assign(Object.assign({}, v.options), u)), l.push(v));
      }), yield Promise.all(l.map((v) => __awaiter$3(this, void 0, void 0, function* () {
        const p = v.track;
        yield this.unpublishTrack(p, !1), c && !p.isMuted && p.source !== Track.Source.ScreenShare && p.source !== Track.Source.ScreenShareAudio && (p instanceof LocalAudioTrack || p instanceof LocalVideoTrack) && !p.isUserProvided && (this.log.debug("restarting existing track", Object.assign(Object.assign({}, this.logContext), {
          track: v.trackSid
        })), yield p.restartTrack()), yield this.publishTrack(p, v.options);
      })));
    });
  }
  /**
   * Publish a new data payload to the room. Data will be forwarded to each
   * participant in the room if the destination field in publishOptions is empty
   *
   * @param data Uint8Array of the payload. To send string data, use TextEncoder.encode
   * @param options optionally specify a `reliable`, `topic` and `destination`
   */
  publishData(u) {
    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return __awaiter$3(this, void 0, void 0, function* () {
      const l = c.reliable ? DataPacket_Kind.RELIABLE : DataPacket_Kind.LOSSY, v = c.destinationIdentities, p = c.topic, _ = new DataPacket({
        kind: l,
        value: {
          case: "user",
          value: new UserPacket({
            participantIdentity: this.identity,
            payload: u,
            destinationIdentities: v,
            topic: p
          })
        }
      });
      yield this.engine.sendDataPacket(_, l);
    });
  }
  /**
   * Control who can subscribe to LocalParticipant's published tracks.
   *
   * By default, all participants can subscribe. This allows fine-grained control over
   * who is able to subscribe at a participant and track level.
   *
   * Note: if access is given at a track-level (i.e. both [allParticipantsAllowed] and
   * [ParticipantTrackPermission.allTracksAllowed] are false), any newer published tracks
   * will not grant permissions to any participants and will require a subsequent
   * permissions update to allow subscription.
   *
   * @param allParticipantsAllowed Allows all participants to subscribe all tracks.
   *  Takes precedence over [[participantTrackPermissions]] if set to true.
   *  By default this is set to true.
   * @param participantTrackPermissions Full list of individual permissions per
   *  participant/track. Any omitted participants will not receive any permissions.
   */
  setTrackSubscriptionPermissions(u) {
    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    this.participantTrackPermissions = c, this.allParticipantsAllowedToSubscribe = u, this.engine.client.isDisconnected || this.updateTrackSubscriptionPermissions();
  }
  /** @internal */
  updateInfo(u) {
    return u.sid !== this.sid || !super.updateInfo(u) ? !1 : (u.tracks.forEach((c) => {
      var l, v;
      const p = this.trackPublications.get(c.sid);
      if (p) {
        const _ = p.isMuted || ((v = (l = p.track) === null || l === void 0 ? void 0 : l.isUpstreamPaused) !== null && v !== void 0 ? v : !1);
        _ !== c.muted && (this.log.debug("updating server mute state after reconcile", Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(p)), {
          mutedOnServer: _
        })), this.engine.client.sendMuteTrack(c.sid, _));
      }
    }), !0);
  }
  getPublicationForTrack(u) {
    let c;
    return this.trackPublications.forEach((l) => {
      const v = l.track;
      v && (u instanceof MediaStreamTrack ? (v instanceof LocalAudioTrack || v instanceof LocalVideoTrack) && v.mediaStreamTrack === u && (c = l) : u === v && (c = l));
    }), c;
  }
}
class RemoteTrackPublication extends TrackPublication {
  constructor(u, c, l, v) {
    super(u, c.sid, c.name, v), this.track = void 0, this.allowed = !0, this.disabled = !1, this.currentVideoQuality = VideoQuality.HIGH, this.handleEnded = (p) => {
      this.setTrack(void 0), this.emit(TrackEvent.Ended, p);
    }, this.handleVisibilityChange = (p) => {
      this.log.debug("adaptivestream video visibility ".concat(this.trackSid, ", visible=").concat(p), this.logContext), this.disabled = !p, this.emitTrackUpdate();
    }, this.handleVideoDimensionsChange = (p) => {
      this.log.debug("adaptivestream video dimensions ".concat(p.width, "x").concat(p.height), this.logContext), this.videoDimensions = p, this.emitTrackUpdate();
    }, this.subscribed = l, this.updateInfo(c);
  }
  /**
   * Subscribe or unsubscribe to this remote track
   * @param subscribed true to subscribe to a track, false to unsubscribe
   */
  setSubscribed(u) {
    const c = this.subscriptionStatus, l = this.permissionStatus;
    this.subscribed = u, u && (this.allowed = !0);
    const v = new UpdateSubscription({
      trackSids: [this.trackSid],
      subscribe: this.subscribed,
      participantTracks: [new ParticipantTracks({
        // sending an empty participant id since TrackPublication doesn't keep it
        // this is filled in by the participant that receives this message
        participantSid: "",
        trackSids: [this.trackSid]
      })]
    });
    this.emit(TrackEvent.UpdateSubscription, v), this.emitSubscriptionUpdateIfChanged(c), this.emitPermissionUpdateIfChanged(l);
  }
  get subscriptionStatus() {
    return this.subscribed === !1 ? TrackPublication.SubscriptionStatus.Unsubscribed : super.isSubscribed ? TrackPublication.SubscriptionStatus.Subscribed : TrackPublication.SubscriptionStatus.Desired;
  }
  get permissionStatus() {
    return this.allowed ? TrackPublication.PermissionStatus.Allowed : TrackPublication.PermissionStatus.NotAllowed;
  }
  /**
   * Returns true if track is subscribed, and ready for playback
   */
  get isSubscribed() {
    return this.subscribed === !1 ? !1 : super.isSubscribed;
  }
  // returns client's desire to subscribe to a track, also true if autoSubscribe is enabled
  get isDesired() {
    return this.subscribed !== !1;
  }
  get isEnabled() {
    return !this.disabled;
  }
  /**
   * disable server from sending down data for this track. this is useful when
   * the participant is off screen, you may disable streaming down their video
   * to reduce bandwidth requirements
   * @param enabled
   */
  setEnabled(u) {
    !this.isManualOperationAllowed() || this.disabled === !u || (this.disabled = !u, this.emitTrackUpdate());
  }
  /**
   * for tracks that support simulcasting, adjust subscribed quality
   *
   * This indicates the highest quality the client can accept. if network
   * bandwidth does not allow, server will automatically reduce quality to
   * optimize for uninterrupted video
   */
  setVideoQuality(u) {
    !this.isManualOperationAllowed() || this.currentVideoQuality === u || (this.currentVideoQuality = u, this.videoDimensions = void 0, this.emitTrackUpdate());
  }
  setVideoDimensions(u) {
    var c, l;
    this.isManualOperationAllowed() && (((c = this.videoDimensions) === null || c === void 0 ? void 0 : c.width) === u.width && ((l = this.videoDimensions) === null || l === void 0 ? void 0 : l.height) === u.height || (this.track instanceof RemoteVideoTrack && (this.videoDimensions = u), this.currentVideoQuality = void 0, this.emitTrackUpdate()));
  }
  setVideoFPS(u) {
    this.isManualOperationAllowed() && this.track instanceof RemoteVideoTrack && this.fps !== u && (this.fps = u, this.emitTrackUpdate());
  }
  get videoQuality() {
    return this.currentVideoQuality;
  }
  /** @internal */
  setTrack(u) {
    const c = this.subscriptionStatus, l = this.permissionStatus, v = this.track;
    v !== u && (v && (v.off(TrackEvent.VideoDimensionsChanged, this.handleVideoDimensionsChange), v.off(TrackEvent.VisibilityChanged, this.handleVisibilityChange), v.off(TrackEvent.Ended, this.handleEnded), v.detach(), v.stopMonitor(), this.emit(TrackEvent.Unsubscribed, v)), super.setTrack(u), u && (u.sid = this.trackSid, u.on(TrackEvent.VideoDimensionsChanged, this.handleVideoDimensionsChange), u.on(TrackEvent.VisibilityChanged, this.handleVisibilityChange), u.on(TrackEvent.Ended, this.handleEnded), this.emit(TrackEvent.Subscribed, u)), this.emitPermissionUpdateIfChanged(l), this.emitSubscriptionUpdateIfChanged(c));
  }
  /** @internal */
  setAllowed(u) {
    const c = this.subscriptionStatus, l = this.permissionStatus;
    this.allowed = u, this.emitPermissionUpdateIfChanged(l), this.emitSubscriptionUpdateIfChanged(c);
  }
  /** @internal */
  setSubscriptionError(u) {
    this.emit(TrackEvent.SubscriptionFailed, u);
  }
  /** @internal */
  updateInfo(u) {
    super.updateInfo(u);
    const c = this.metadataMuted;
    this.metadataMuted = u.muted, this.track ? this.track.setMuted(u.muted) : c !== u.muted && this.emit(u.muted ? TrackEvent.Muted : TrackEvent.Unmuted);
  }
  emitSubscriptionUpdateIfChanged(u) {
    const c = this.subscriptionStatus;
    u !== c && this.emit(TrackEvent.SubscriptionStatusChanged, c, u);
  }
  emitPermissionUpdateIfChanged(u) {
    this.permissionStatus !== u && this.emit(TrackEvent.SubscriptionPermissionChanged, this.permissionStatus, u);
  }
  isManualOperationAllowed() {
    return this.kind === Track.Kind.Video && this.isAdaptiveStream ? (this.log.warn("adaptive stream is enabled, cannot change video track settings", this.logContext), !1) : this.isDesired ? !0 : (this.log.warn("cannot update track settings when not subscribed", this.logContext), !1);
  }
  get isAdaptiveStream() {
    return this.track instanceof RemoteVideoTrack && this.track.isAdaptiveStream;
  }
  /* @internal */
  emitTrackUpdate() {
    const u = new UpdateTrackSettings({
      trackSids: [this.trackSid],
      disabled: this.disabled,
      fps: this.fps
    });
    this.videoDimensions ? (u.width = Math.ceil(this.videoDimensions.width), u.height = Math.ceil(this.videoDimensions.height)) : this.currentVideoQuality !== void 0 ? u.quality = this.currentVideoQuality : u.quality = VideoQuality.HIGH, this.emit(TrackEvent.UpdateSettings, u);
  }
}
class RemoteParticipant extends Participant {
  /** @internal */
  static fromParticipantInfo(u, c) {
    return new RemoteParticipant(u, c.sid, c.identity, c.name, c.metadata);
  }
  get logContext() {
    return Object.assign(Object.assign({}, super.logContext), {
      rpID: this.sid,
      remoteParticipant: this.identity
    });
  }
  /** @internal */
  constructor(u, c, l, v, p, _) {
    super(c, l || "", v, p, _), this.signalClient = u, this.trackPublications = /* @__PURE__ */ new Map(), this.audioTrackPublications = /* @__PURE__ */ new Map(), this.videoTrackPublications = /* @__PURE__ */ new Map(), this.volumeMap = /* @__PURE__ */ new Map();
  }
  addTrackPublication(u) {
    super.addTrackPublication(u), u.on(TrackEvent.UpdateSettings, (c) => {
      this.log.debug("send update settings", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(u))), this.signalClient.sendUpdateTrackSettings(c);
    }), u.on(TrackEvent.UpdateSubscription, (c) => {
      c.participantTracks.forEach((l) => {
        l.participantSid = this.sid;
      }), this.signalClient.sendUpdateSubscription(c);
    }), u.on(TrackEvent.SubscriptionPermissionChanged, (c) => {
      this.emit(ParticipantEvent.TrackSubscriptionPermissionChanged, u, c);
    }), u.on(TrackEvent.SubscriptionStatusChanged, (c) => {
      this.emit(ParticipantEvent.TrackSubscriptionStatusChanged, u, c);
    }), u.on(TrackEvent.Subscribed, (c) => {
      this.emit(ParticipantEvent.TrackSubscribed, c, u);
    }), u.on(TrackEvent.Unsubscribed, (c) => {
      this.emit(ParticipantEvent.TrackUnsubscribed, c, u);
    }), u.on(TrackEvent.SubscriptionFailed, (c) => {
      this.emit(ParticipantEvent.TrackSubscriptionFailed, u.trackSid, c);
    });
  }
  getTrackPublication(u) {
    const c = super.getTrackPublication(u);
    if (c)
      return c;
  }
  getTrackPublicationByName(u) {
    const c = super.getTrackPublicationByName(u);
    if (c)
      return c;
  }
  /**
   * sets the volume on the participant's audio track
   * by default, this affects the microphone publication
   * a different source can be passed in as a second argument
   * if no track exists the volume will be applied when the microphone track is added
   */
  setVolume(u) {
    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Track.Source.Microphone;
    this.volumeMap.set(c, u);
    const l = this.getTrackPublication(c);
    l && l.track && l.track.setVolume(u);
  }
  /**
   * gets the volume on the participant's microphone track
   */
  getVolume() {
    let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Track.Source.Microphone;
    const c = this.getTrackPublication(u);
    return c && c.track ? c.track.getVolume() : this.volumeMap.get(u);
  }
  /** @internal */
  addSubscribedMediaTrack(u, c, l, v, p, _) {
    let k = this.getTrackPublicationBySid(c);
    if (k || c.startsWith("TR") || this.trackPublications.forEach((F) => {
      !k && u.kind === F.kind.toString() && (k = F);
    }), !k) {
      if (_ === 0) {
        this.log.error("could not find published track", Object.assign(Object.assign({}, this.logContext), {
          trackSid: c
        })), this.emit(ParticipantEvent.TrackSubscriptionFailed, c);
        return;
      }
      _ === void 0 && (_ = 20), setTimeout(() => {
        this.addSubscribedMediaTrack(u, c, l, v, p, _ - 1);
      }, 150);
      return;
    }
    if (u.readyState === "ended") {
      this.log.error("unable to subscribe because MediaStreamTrack is ended. Do not call MediaStreamTrack.stop()", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(k))), this.emit(ParticipantEvent.TrackSubscriptionFailed, c);
      return;
    }
    const O = u.kind === "video";
    let D;
    return O ? D = new RemoteVideoTrack(u, c, v, p) : D = new RemoteAudioTrack(u, c, v, this.audioContext, this.audioOutput), D.source = k.source, D.isMuted = k.isMuted, D.setMediaStream(l), D.start(), k.setTrack(D), this.volumeMap.has(k.source) && D instanceof RemoteAudioTrack && D.setVolume(this.volumeMap.get(k.source)), k;
  }
  /** @internal */
  get hasMetadata() {
    return !!this.participantInfo;
  }
  /**
   * @internal
   */
  getTrackPublicationBySid(u) {
    return this.trackPublications.get(u);
  }
  /** @internal */
  updateInfo(u) {
    if (!super.updateInfo(u))
      return !1;
    const c = /* @__PURE__ */ new Map(), l = /* @__PURE__ */ new Map();
    return u.tracks.forEach((v) => {
      var p, _;
      let k = this.getTrackPublicationBySid(v.sid);
      if (k)
        k.updateInfo(v);
      else {
        const O = Track.kindFromProto(v.type);
        if (!O)
          return;
        k = new RemoteTrackPublication(O, v, (p = this.signalClient.connectOptions) === null || p === void 0 ? void 0 : p.autoSubscribe, {
          loggerContextCb: () => this.logContext,
          loggerName: (_ = this.loggerOptions) === null || _ === void 0 ? void 0 : _.loggerName
        }), k.updateInfo(v), l.set(v.sid, k);
        const D = Array.from(this.trackPublications.values()).find((F) => F.source === (k == null ? void 0 : k.source));
        D && k.source !== Track.Source.Unknown && this.log.debug("received a second track publication for ".concat(this.identity, " with the same source: ").concat(k.source), Object.assign(Object.assign({}, this.logContext), {
          oldTrack: getLogContextFromTrack(D),
          newTrack: getLogContextFromTrack(k)
        })), this.addTrackPublication(k);
      }
      c.set(v.sid, k);
    }), this.trackPublications.forEach((v) => {
      c.has(v.trackSid) || (this.log.trace("detected removed track on remote participant, unpublishing", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(v))), this.unpublishTrack(v.trackSid, !0));
    }), l.forEach((v) => {
      this.emit(ParticipantEvent.TrackPublished, v);
    }), !0;
  }
  /** @internal */
  unpublishTrack(u, c) {
    const l = this.trackPublications.get(u);
    if (!l)
      return;
    const {
      track: v
    } = l;
    switch (v && (v.stop(), l.setTrack(void 0)), this.trackPublications.delete(u), l.kind) {
      case Track.Kind.Audio:
        this.audioTrackPublications.delete(u);
        break;
      case Track.Kind.Video:
        this.videoTrackPublications.delete(u);
        break;
    }
    c && this.emit(ParticipantEvent.TrackUnpublished, l);
  }
  /**
   * @internal
   */
  setAudioOutput(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      this.audioOutput = u;
      const c = [];
      this.audioTrackPublications.forEach((l) => {
        var v;
        l.track instanceof RemoteAudioTrack && c.push(l.track.setSinkId((v = u.deviceId) !== null && v !== void 0 ? v : "default"));
      }), yield Promise.all(c);
    });
  }
  /** @internal */
  emit(u) {
    for (var c = arguments.length, l = new Array(c > 1 ? c - 1 : 0), v = 1; v < c; v++)
      l[v - 1] = arguments[v];
    return this.log.trace("participant event", Object.assign(Object.assign({}, this.logContext), {
      event: u,
      args: l
    })), super.emit(u, ...l);
  }
}
var ConnectionState;
(function(a) {
  a.Disconnected = "disconnected", a.Connecting = "connecting", a.Connected = "connected", a.Reconnecting = "reconnecting";
})(ConnectionState || (ConnectionState = {}));
const connectionReconcileFrequency = 2 * 1e3;
class Room extends eventsExports$1.EventEmitter {
  /**
   * Creates a new Room, the primary construct for a LiveKit session.
   * @param options
   */
  constructor(u) {
    var c, l, v;
    super(), c = this, this.state = ConnectionState.Disconnected, this.activeSpeakers = [], this.isE2EEEnabled = !1, this.audioEnabled = !0, this.isVideoPlaybackBlocked = !1, this.log = livekitLogger, this.bufferedEvents = [], this.isResuming = !1, this.connect = (p, _, k) => __awaiter$3(this, void 0, void 0, function* () {
      var O;
      if (!isBrowserSupported())
        throw isReactNative() ? Error("WebRTC isn't detected, have you called registerGlobals?") : Error("LiveKit doesn't seem to be supported on this browser. Try to update your browser and make sure no browser extensions are disabling webRTC.");
      const D = yield this.disconnectLock.lock();
      if (this.state === ConnectionState.Connected)
        return this.log.info("already connected to room ".concat(this.name), this.logContext), D(), Promise.resolve();
      if (this.connectFuture)
        return D(), this.connectFuture.promise;
      this.setAndEmitConnectionState(ConnectionState.Connecting), ((O = this.regionUrlProvider) === null || O === void 0 ? void 0 : O.getServerUrl().toString()) !== p && (this.regionUrl = void 0, this.regionUrlProvider = void 0), isCloud(new URL(p)) && (this.regionUrlProvider === void 0 ? this.regionUrlProvider = new RegionUrlProvider(p, _) : this.regionUrlProvider.updateToken(_), this.regionUrlProvider.fetchRegionSettings().catch((Z) => {
        this.log.warn("could not fetch region settings", Object.assign(Object.assign({}, this.logContext), {
          error: Z
        }));
      }));
      const F = (Z, ee, X) => __awaiter$3(this, void 0, void 0, function* () {
        var ne;
        this.abortController && this.abortController.abort();
        const Q = new AbortController();
        this.abortController = Q, D == null || D();
        try {
          yield this.attemptConnection(X ?? p, _, k, Q), this.abortController = void 0, Z();
        } catch (ae) {
          if (this.regionUrlProvider && ae instanceof ConnectionError && ae.reason !== 3 && ae.reason !== 0) {
            let j = null;
            try {
              j = yield this.regionUrlProvider.getNextBestRegionUrl((ne = this.abortController) === null || ne === void 0 ? void 0 : ne.signal);
            } catch (ue) {
              if (ue instanceof ConnectionError && (ue.status === 401 || ue.reason === 3)) {
                this.handleDisconnect(this.options.stopLocalTrackOnUnpublish), ee(ue);
                return;
              }
            }
            j ? (this.log.info("Initial connection failed with ConnectionError: ".concat(ae.message, ". Retrying with another region: ").concat(j), this.logContext), this.recreateEngine(), yield F(Z, ee, j)) : (this.handleDisconnect(this.options.stopLocalTrackOnUnpublish), ee(ae));
          } else
            this.handleDisconnect(this.options.stopLocalTrackOnUnpublish), ee(ae);
        }
      }), H = this.regionUrl;
      return this.regionUrl = void 0, this.connectFuture = new Future((Z, ee) => {
        F(Z, ee, H);
      }, () => {
        this.clearConnectionFutures();
      }), this.connectFuture.promise;
    }), this.connectSignal = (p, _, k, O, D, F) => __awaiter$3(this, void 0, void 0, function* () {
      var H, Z, ee;
      const X = yield k.join(p, _, {
        autoSubscribe: O.autoSubscribe,
        adaptiveStream: typeof D.adaptiveStream == "object" ? !0 : D.adaptiveStream,
        maxRetries: O.maxRetries,
        e2eeEnabled: !!this.e2eeManager,
        websocketTimeout: O.websocketTimeout
      }, F.signal);
      let ne = X.serverInfo;
      if (ne || (ne = {
        version: X.serverVersion,
        region: X.serverRegion
      }), this.log.debug("connected to Livekit Server ".concat(Object.entries(ne).map((Q) => {
        let [ae, j] = Q;
        return "".concat(ae, ": ").concat(j);
      }).join(", ")), {
        room: (H = X.room) === null || H === void 0 ? void 0 : H.name,
        roomSid: (Z = X.room) === null || Z === void 0 ? void 0 : Z.sid,
        identity: (ee = X.participant) === null || ee === void 0 ? void 0 : ee.identity
      }), !X.serverVersion)
        throw new UnsupportedServer("unknown server version");
      return X.serverVersion === "0.15.1" && this.options.dynacast && (this.log.debug("disabling dynacast due to server version", this.logContext), D.dynacast = !1), X;
    }), this.applyJoinResponse = (p) => {
      const _ = p.participant;
      if (this.localParticipant.sid = _.sid, this.localParticipant.identity = _.identity, this.options.e2ee && this.e2eeManager)
        try {
          this.e2eeManager.setSifTrailer(p.sifTrailer);
        } catch (k) {
          this.log.error(k instanceof Error ? k.message : "Could not set SifTrailer", Object.assign(Object.assign({}, this.logContext), {
            error: k
          }));
        }
      this.handleParticipantUpdates([_, ...p.otherParticipants]), p.room && this.handleRoomUpdate(p.room);
    }, this.attemptConnection = (p, _, k, O) => __awaiter$3(this, void 0, void 0, function* () {
      var D, F, H;
      this.state === ConnectionState.Reconnecting || this.isResuming || !((D = this.engine) === null || D === void 0) && D.pendingReconnect ? (this.log.info("Reconnection attempt replaced by new connection attempt", this.logContext), this.recreateEngine()) : this.maybeCreateEngine(), !((F = this.regionUrlProvider) === null || F === void 0) && F.isCloud() && this.engine.setRegionUrlProvider(this.regionUrlProvider), this.acquireAudioContext(), this.connOptions = Object.assign(Object.assign({}, roomConnectOptionDefaults), k), this.connOptions.rtcConfig && (this.engine.rtcConfig = this.connOptions.rtcConfig), this.connOptions.peerConnectionTimeout && (this.engine.peerConnectionTimeout = this.connOptions.peerConnectionTimeout);
      try {
        const Z = yield this.connectSignal(p, _, this.engine, this.connOptions, this.options, O);
        this.applyJoinResponse(Z), this.setupLocalParticipantEvents(), this.emit(RoomEvent.SignalConnected);
      } catch (Z) {
        yield this.engine.close(), this.recreateEngine();
        const ee = new ConnectionError("could not establish signal connection");
        throw Z instanceof Error && (ee.message = "".concat(ee.message, ": ").concat(Z.message)), Z instanceof ConnectionError && (ee.reason = Z.reason, ee.status = Z.status), this.log.debug("error trying to establish signal connection", Object.assign(Object.assign({}, this.logContext), {
          error: Z
        })), ee;
      }
      if (O.signal.aborted)
        throw yield this.engine.close(), this.recreateEngine(), new ConnectionError("Connection attempt aborted");
      try {
        yield this.engine.waitForPCInitialConnection(this.connOptions.peerConnectionTimeout, O);
      } catch (Z) {
        throw yield this.engine.close(), this.recreateEngine(), Z;
      }
      isWeb() && this.options.disconnectOnPageLeave && (window.addEventListener("pagehide", this.onPageLeave), window.addEventListener("beforeunload", this.onPageLeave)), isWeb() && (document.addEventListener("freeze", this.onPageLeave), (H = navigator.mediaDevices) === null || H === void 0 || H.addEventListener("devicechange", this.handleDeviceChange)), this.setAndEmitConnectionState(ConnectionState.Connected), this.emit(RoomEvent.Connected), this.registerConnectionReconcile();
    }), this.disconnect = function() {
      let p = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
      return __awaiter$3(c, void 0, void 0, function* () {
        var _, k, O, D;
        const F = yield this.disconnectLock.lock();
        try {
          if (this.state === ConnectionState.Disconnected) {
            this.log.debug("already disconnected", this.logContext);
            return;
          }
          this.log.info("disconnect from room", Object.assign({}, this.logContext)), (this.state === ConnectionState.Connecting || this.state === ConnectionState.Reconnecting || this.isResuming) && (this.log.warn("abort connection attempt", this.logContext), (_ = this.abortController) === null || _ === void 0 || _.abort(), (O = (k = this.connectFuture) === null || k === void 0 ? void 0 : k.reject) === null || O === void 0 || O.call(k, new ConnectionError("Client initiated disconnect")), this.connectFuture = void 0), !((D = this.engine) === null || D === void 0) && D.client.isDisconnected || (yield this.engine.client.sendLeave()), this.engine && (yield this.engine.close()), this.handleDisconnect(p, DisconnectReason.CLIENT_INITIATED), this.engine = void 0;
        } finally {
          F();
        }
      });
    }, this.onPageLeave = () => __awaiter$3(this, void 0, void 0, function* () {
      this.log.info("Page leave detected, disconnecting", this.logContext), yield this.disconnect();
    }), this.startAudio = () => __awaiter$3(this, void 0, void 0, function* () {
      const p = [], _ = getBrowser();
      if (_ && _.os === "iOS") {
        const k = "livekit-dummy-audio-el";
        let O = document.getElementById(k);
        if (!O) {
          O = document.createElement("audio"), O.id = k, O.autoplay = !0, O.hidden = !0;
          const D = getEmptyAudioStreamTrack();
          D.enabled = !0;
          const F = new MediaStream([D]);
          O.srcObject = F, document.addEventListener("visibilitychange", () => {
            O && (O.srcObject = document.hidden ? null : F, document.hidden || (this.log.debug("page visible again, triggering startAudio to resume playback and update playback status", this.logContext), this.startAudio()));
          }), document.body.append(O), this.once(RoomEvent.Disconnected, () => {
            O == null || O.remove(), O = null;
          });
        }
        p.push(O);
      }
      this.remoteParticipants.forEach((k) => {
        k.audioTrackPublications.forEach((O) => {
          O.track && O.track.attachedElements.forEach((D) => {
            p.push(D);
          });
        });
      });
      try {
        yield Promise.all([this.acquireAudioContext(), ...p.map((k) => (k.muted = !1, k.play()))]), this.handleAudioPlaybackStarted();
      } catch (k) {
        throw this.handleAudioPlaybackFailed(k), k;
      }
    }), this.startVideo = () => __awaiter$3(this, void 0, void 0, function* () {
      const p = [];
      for (const _ of this.remoteParticipants.values())
        _.videoTrackPublications.forEach((k) => {
          var O;
          (O = k.track) === null || O === void 0 || O.attachedElements.forEach((D) => {
            p.includes(D) || p.push(D);
          });
        });
      yield Promise.all(p.map((_) => _.play())).then(() => {
        this.handleVideoPlaybackStarted();
      }).catch((_) => {
        _.name === "NotAllowedError" ? this.handleVideoPlaybackFailed() : this.log.warn("Resuming video playback failed, make sure you call `startVideo` directly in a user gesture handler", this.logContext);
      });
    }), this.handleRestarting = () => {
      this.clearConnectionReconcile(), this.isResuming = !1;
      for (const p of this.remoteParticipants.values())
        this.handleParticipantDisconnected(p.identity, p);
      this.setAndEmitConnectionState(ConnectionState.Reconnecting) && this.emit(RoomEvent.Reconnecting);
    }, this.handleSignalRestarted = (p) => __awaiter$3(this, void 0, void 0, function* () {
      this.log.debug("signal reconnected to server, region ".concat(p.serverRegion), Object.assign(Object.assign({}, this.logContext), {
        region: p.serverRegion
      })), this.bufferedEvents = [], this.applyJoinResponse(p);
      try {
        yield this.localParticipant.republishAllTracks(void 0, !0);
      } catch (_) {
        this.log.error("error trying to re-publish tracks after reconnection", Object.assign(Object.assign({}, this.logContext), {
          error: _
        }));
      }
      try {
        yield this.engine.waitForRestarted(), this.log.debug("fully reconnected to server", Object.assign(Object.assign({}, this.logContext), {
          region: p.serverRegion
        }));
      } catch {
        return;
      }
      this.setAndEmitConnectionState(ConnectionState.Connected), this.emit(RoomEvent.Reconnected), this.registerConnectionReconcile(), this.emitBufferedEvents();
    }), this.handleParticipantUpdates = (p) => {
      p.forEach((_) => {
        var k;
        if (_.identity === this.localParticipant.identity) {
          this.localParticipant.updateInfo(_);
          return;
        }
        _.identity === "" && (_.identity = (k = this.sidToIdentity.get(_.sid)) !== null && k !== void 0 ? k : "");
        let O = this.remoteParticipants.get(_.identity);
        _.state === ParticipantInfo_State.DISCONNECTED ? this.handleParticipantDisconnected(_.identity, O) : O = this.getOrCreateParticipant(_.identity, _);
      });
    }, this.handleActiveSpeakersUpdate = (p) => {
      const _ = [], k = {};
      p.forEach((O) => {
        if (k[O.sid] = !0, O.sid === this.localParticipant.sid)
          this.localParticipant.audioLevel = O.level, this.localParticipant.setIsSpeaking(!0), _.push(this.localParticipant);
        else {
          const D = this.getRemoteParticipantBySid(O.sid);
          D && (D.audioLevel = O.level, D.setIsSpeaking(!0), _.push(D));
        }
      }), k[this.localParticipant.sid] || (this.localParticipant.audioLevel = 0, this.localParticipant.setIsSpeaking(!1)), this.remoteParticipants.forEach((O) => {
        k[O.sid] || (O.audioLevel = 0, O.setIsSpeaking(!1));
      }), this.activeSpeakers = _, this.emitWhenConnected(RoomEvent.ActiveSpeakersChanged, _);
    }, this.handleSpeakersChanged = (p) => {
      const _ = /* @__PURE__ */ new Map();
      this.activeSpeakers.forEach((O) => {
        _.set(O.sid, O);
      }), p.forEach((O) => {
        let D = this.getRemoteParticipantBySid(O.sid);
        O.sid === this.localParticipant.sid && (D = this.localParticipant), D && (D.audioLevel = O.level, D.setIsSpeaking(O.active), O.active ? _.set(O.sid, D) : _.delete(O.sid));
      });
      const k = Array.from(_.values());
      k.sort((O, D) => D.audioLevel - O.audioLevel), this.activeSpeakers = k, this.emitWhenConnected(RoomEvent.ActiveSpeakersChanged, k);
    }, this.handleStreamStateUpdate = (p) => {
      p.streamStates.forEach((_) => {
        const k = this.getRemoteParticipantBySid(_.participantSid);
        if (!k)
          return;
        const O = k.getTrackPublicationBySid(_.trackSid);
        !O || !O.track || (O.track.streamState = Track.streamStateFromProto(_.state), k.emit(ParticipantEvent.TrackStreamStateChanged, O, O.track.streamState), this.emitWhenConnected(RoomEvent.TrackStreamStateChanged, O, O.track.streamState, k));
      });
    }, this.handleSubscriptionPermissionUpdate = (p) => {
      const _ = this.getRemoteParticipantBySid(p.participantSid);
      if (!_)
        return;
      const k = _.getTrackPublicationBySid(p.trackSid);
      k && k.setAllowed(p.allowed);
    }, this.handleSubscriptionError = (p) => {
      const _ = Array.from(this.remoteParticipants.values()).find((O) => O.trackPublications.has(p.trackSid));
      if (!_)
        return;
      const k = _.getTrackPublicationBySid(p.trackSid);
      k && k.setSubscriptionError(p.err);
    }, this.handleDataPacket = (p, _) => {
      const k = this.remoteParticipants.get(p.participantIdentity);
      this.emit(RoomEvent.DataReceived, p.payload, k, _, p.topic), k == null || k.emit(ParticipantEvent.DataReceived, p.payload, _);
    }, this.handleAudioPlaybackStarted = () => {
      this.canPlaybackAudio || (this.audioEnabled = !0, this.emit(RoomEvent.AudioPlaybackStatusChanged, !0));
    }, this.handleAudioPlaybackFailed = (p) => {
      this.log.warn("could not playback audio", Object.assign(Object.assign({}, this.logContext), {
        error: p
      })), this.canPlaybackAudio && (this.audioEnabled = !1, this.emit(RoomEvent.AudioPlaybackStatusChanged, !1));
    }, this.handleVideoPlaybackStarted = () => {
      this.isVideoPlaybackBlocked && (this.isVideoPlaybackBlocked = !1, this.emit(RoomEvent.VideoPlaybackStatusChanged, !0));
    }, this.handleVideoPlaybackFailed = () => {
      this.isVideoPlaybackBlocked || (this.isVideoPlaybackBlocked = !0, this.emit(RoomEvent.VideoPlaybackStatusChanged, !1));
    }, this.handleDeviceChange = () => __awaiter$3(this, void 0, void 0, function* () {
      this.emit(RoomEvent.MediaDevicesChanged);
    }), this.handleRoomUpdate = (p) => {
      const _ = this.roomInfo;
      this.roomInfo = p, _ && _.metadata !== p.metadata && this.emitWhenConnected(RoomEvent.RoomMetadataChanged, p.metadata), (_ == null ? void 0 : _.activeRecording) !== p.activeRecording && this.emitWhenConnected(RoomEvent.RecordingStatusChanged, p.activeRecording);
    }, this.handleConnectionQualityUpdate = (p) => {
      p.updates.forEach((_) => {
        if (_.participantSid === this.localParticipant.sid) {
          this.localParticipant.setConnectionQuality(_.quality);
          return;
        }
        const k = this.getRemoteParticipantBySid(_.participantSid);
        k && k.setConnectionQuality(_.quality);
      });
    }, this.onLocalParticipantMetadataChanged = (p) => {
      this.emit(RoomEvent.ParticipantMetadataChanged, p, this.localParticipant);
    }, this.onLocalParticipantNameChanged = (p) => {
      this.emit(RoomEvent.ParticipantNameChanged, p, this.localParticipant);
    }, this.onLocalTrackMuted = (p) => {
      this.emit(RoomEvent.TrackMuted, p, this.localParticipant);
    }, this.onLocalTrackUnmuted = (p) => {
      this.emit(RoomEvent.TrackUnmuted, p, this.localParticipant);
    }, this.onTrackProcessorUpdate = (p) => {
      var _;
      (_ = p == null ? void 0 : p.onPublish) === null || _ === void 0 || _.call(p, this);
    }, this.onLocalTrackPublished = (p) => __awaiter$3(this, void 0, void 0, function* () {
      var _, k, O, D, F;
      (_ = p.track) === null || _ === void 0 || _.on(TrackEvent.TrackProcessorUpdate, this.onTrackProcessorUpdate), (D = (O = (k = p.track) === null || k === void 0 ? void 0 : k.getProcessor()) === null || O === void 0 ? void 0 : O.onPublish) === null || D === void 0 || D.call(O, this), this.emit(RoomEvent.LocalTrackPublished, p, this.localParticipant), p.track instanceof LocalAudioTrack && (yield p.track.checkForSilence()) && this.emit(RoomEvent.LocalAudioSilenceDetected, p);
      const H = yield (F = p.track) === null || F === void 0 ? void 0 : F.getDeviceId(), Z = sourceToKind(p.source);
      Z && H && H !== this.localParticipant.activeDeviceMap.get(Z) && (this.localParticipant.activeDeviceMap.set(Z, H), this.emit(RoomEvent.ActiveDeviceChanged, Z, H));
    }), this.onLocalTrackUnpublished = (p) => {
      var _;
      (_ = p.track) === null || _ === void 0 || _.off(TrackEvent.TrackProcessorUpdate, this.onTrackProcessorUpdate), this.emit(RoomEvent.LocalTrackUnpublished, p, this.localParticipant);
    }, this.onLocalConnectionQualityChanged = (p) => {
      this.emit(RoomEvent.ConnectionQualityChanged, p, this.localParticipant);
    }, this.onMediaDevicesError = (p) => {
      this.emit(RoomEvent.MediaDevicesError, p);
    }, this.onLocalParticipantPermissionsChanged = (p) => {
      this.emit(RoomEvent.ParticipantPermissionsChanged, p, this.localParticipant);
    }, this.setMaxListeners(100), this.remoteParticipants = /* @__PURE__ */ new Map(), this.sidToIdentity = /* @__PURE__ */ new Map(), this.options = Object.assign(Object.assign({}, roomOptionDefaults), u), this.log = getLogger((l = this.options.loggerName) !== null && l !== void 0 ? l : LoggerNames.Room), this.options.audioCaptureDefaults = Object.assign(Object.assign({}, audioDefaults), u == null ? void 0 : u.audioCaptureDefaults), this.options.videoCaptureDefaults = Object.assign(Object.assign({}, videoDefaults), u == null ? void 0 : u.videoCaptureDefaults), this.options.publishDefaults = Object.assign(Object.assign({}, publishDefaults), u == null ? void 0 : u.publishDefaults), this.maybeCreateEngine(), this.disconnectLock = new Mutex(), this.localParticipant = new LocalParticipant("", "", this.engine, this.options), this.options.videoCaptureDefaults.deviceId && this.localParticipant.activeDeviceMap.set("videoinput", unwrapConstraint(this.options.videoCaptureDefaults.deviceId)), this.options.audioCaptureDefaults.deviceId && this.localParticipant.activeDeviceMap.set("audioinput", unwrapConstraint(this.options.audioCaptureDefaults.deviceId)), !((v = this.options.audioOutput) === null || v === void 0) && v.deviceId && this.switchActiveDevice("audiooutput", unwrapConstraint(this.options.audioOutput.deviceId)).catch((p) => this.log.warn("Could not set audio output: ".concat(p.message), this.logContext)), this.options.e2ee && this.setupE2EE();
  }
  /**
   * @experimental
   */
  setE2EEEnabled(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (this.e2eeManager)
        yield Promise.all([this.localParticipant.setE2EEEnabled(u)]), this.localParticipant.identity !== "" && this.e2eeManager.setParticipantCryptorEnabled(u, this.localParticipant.identity);
      else
        throw Error("e2ee not configured, please set e2ee settings within the room options");
    });
  }
  setupE2EE() {
    var u;
    this.options.e2ee && (this.e2eeManager = new E2EEManager(this.options.e2ee), this.e2eeManager.on(EncryptionEvent.ParticipantEncryptionStatusChanged, (c, l) => {
      l instanceof LocalParticipant && (this.isE2EEEnabled = c), this.emit(RoomEvent.ParticipantEncryptionStatusChanged, c, l);
    }), this.e2eeManager.on(EncryptionEvent.EncryptionError, (c) => this.emit(RoomEvent.EncryptionError, c)), (u = this.e2eeManager) === null || u === void 0 || u.setup(this));
  }
  get logContext() {
    var u;
    return {
      room: this.name,
      roomID: (u = this.roomInfo) === null || u === void 0 ? void 0 : u.sid,
      participant: this.localParticipant.identity,
      pID: this.localParticipant.sid
    };
  }
  /**
   * if the current room has a participant with `recorder: true` in its JWT grant
   **/
  get isRecording() {
    var u, c;
    return (c = (u = this.roomInfo) === null || u === void 0 ? void 0 : u.activeRecording) !== null && c !== void 0 ? c : !1;
  }
  /**
   * server assigned unique room id.
   * returns once a sid has been issued by the server.
   */
  getSid() {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this.state === ConnectionState.Disconnected ? "" : this.roomInfo && this.roomInfo.sid !== "" ? this.roomInfo.sid : new Promise((u, c) => {
        const l = (v) => {
          v.sid !== "" && (this.engine.off(EngineEvent.RoomUpdate, l), u(v.sid));
        };
        this.engine.on(EngineEvent.RoomUpdate, l), this.once(RoomEvent.Disconnected, () => {
          this.engine.off(EngineEvent.RoomUpdate, l), c("Room disconnected before room server id was available");
        });
      });
    });
  }
  /** user assigned name, derived from JWT token */
  get name() {
    var u, c;
    return (c = (u = this.roomInfo) === null || u === void 0 ? void 0 : u.name) !== null && c !== void 0 ? c : "";
  }
  /** room metadata */
  get metadata() {
    var u;
    return (u = this.roomInfo) === null || u === void 0 ? void 0 : u.metadata;
  }
  get numParticipants() {
    var u, c;
    return (c = (u = this.roomInfo) === null || u === void 0 ? void 0 : u.numParticipants) !== null && c !== void 0 ? c : 0;
  }
  get numPublishers() {
    var u, c;
    return (c = (u = this.roomInfo) === null || u === void 0 ? void 0 : u.numPublishers) !== null && c !== void 0 ? c : 0;
  }
  maybeCreateEngine() {
    this.engine && !this.engine.isClosed || (this.engine = new RTCEngine(this.options), this.engine.on(EngineEvent.ParticipantUpdate, this.handleParticipantUpdates).on(EngineEvent.RoomUpdate, this.handleRoomUpdate).on(EngineEvent.SpeakersChanged, this.handleSpeakersChanged).on(EngineEvent.StreamStateChanged, this.handleStreamStateUpdate).on(EngineEvent.ConnectionQualityUpdate, this.handleConnectionQualityUpdate).on(EngineEvent.SubscriptionError, this.handleSubscriptionError).on(EngineEvent.SubscriptionPermissionUpdate, this.handleSubscriptionPermissionUpdate).on(EngineEvent.MediaTrackAdded, (u, c, l) => {
      this.onTrackAdded(u, c, l);
    }).on(EngineEvent.Disconnected, (u) => {
      this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, u);
    }).on(EngineEvent.ActiveSpeakersUpdate, this.handleActiveSpeakersUpdate).on(EngineEvent.DataPacketReceived, this.handleDataPacket).on(EngineEvent.Resuming, () => {
      this.clearConnectionReconcile(), this.isResuming = !0, this.log.info("Resuming signal connection", this.logContext);
    }).on(EngineEvent.Resumed, () => {
      this.registerConnectionReconcile(), this.isResuming = !1, this.log.info("Resumed signal connection", this.logContext), this.updateSubscriptions(), this.emitBufferedEvents();
    }).on(EngineEvent.SignalResumed, () => {
      this.bufferedEvents = [], (this.state === ConnectionState.Reconnecting || this.isResuming) && this.sendSyncState();
    }).on(EngineEvent.Restarting, this.handleRestarting).on(EngineEvent.SignalRestarted, this.handleSignalRestarted).on(EngineEvent.Offline, () => {
      this.setAndEmitConnectionState(ConnectionState.Reconnecting) && this.emit(RoomEvent.Reconnecting);
    }).on(EngineEvent.DCBufferStatusChanged, (u, c) => {
      this.emit(RoomEvent.DCBufferStatusChanged, u, c);
    }), this.localParticipant && this.localParticipant.setupEngine(this.engine), this.e2eeManager && this.e2eeManager.setupEngine(this.engine));
  }
  /**
   * getLocalDevices abstracts navigator.mediaDevices.enumerateDevices.
   * In particular, it handles Chrome's unique behavior of creating `default`
   * devices. When encountered, it'll be removed from the list of devices.
   * The actual default device will be placed at top.
   * @param kind
   * @returns a list of available local devices
   */
  static getLocalDevices(u) {
    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
    return DeviceManager.getInstance().getDevices(u, c);
  }
  /**
   * prepareConnection should be called as soon as the page is loaded, in order
   * to speed up the connection attempt. This function will
   * - perform DNS resolution and pre-warm the DNS cache
   * - establish TLS connection and cache TLS keys
   *
   * With LiveKit Cloud, it will also determine the best edge data center for
   * the current client to connect to if a token is provided.
   */
  prepareConnection(u, c) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (this.state === ConnectionState.Disconnected) {
        this.log.debug("prepareConnection to ".concat(u), this.logContext);
        try {
          if (isCloud(new URL(u)) && c) {
            this.regionUrlProvider = new RegionUrlProvider(u, c);
            const l = yield this.regionUrlProvider.getNextBestRegionUrl();
            l && this.state === ConnectionState.Disconnected && (this.regionUrl = l, yield fetch(toHttpUrl(l), {
              method: "HEAD"
            }), this.log.debug("prepared connection to ".concat(l), this.logContext));
          } else
            yield fetch(toHttpUrl(u), {
              method: "HEAD"
            });
        } catch (l) {
          this.log.warn("could not prepare connection", Object.assign(Object.assign({}, this.logContext), {
            error: l
          }));
        }
      }
    });
  }
  /**
   * retrieves a participant by identity
   * @param identity
   * @returns
   */
  getParticipantByIdentity(u) {
    return this.localParticipant.identity === u ? this.localParticipant : this.remoteParticipants.get(u);
  }
  clearConnectionFutures() {
    this.connectFuture = void 0;
  }
  /**
   * @internal for testing
   */
  simulateScenario(u, c) {
    return __awaiter$3(this, void 0, void 0, function* () {
      let l = () => {
      }, v;
      switch (u) {
        case "signal-reconnect":
          yield this.engine.client.handleOnClose("simulate disconnect");
          break;
        case "speaker":
          v = new SimulateScenario({
            scenario: {
              case: "speakerUpdate",
              value: 3
            }
          });
          break;
        case "node-failure":
          v = new SimulateScenario({
            scenario: {
              case: "nodeFailure",
              value: !0
            }
          });
          break;
        case "server-leave":
          v = new SimulateScenario({
            scenario: {
              case: "serverLeave",
              value: !0
            }
          });
          break;
        case "migration":
          v = new SimulateScenario({
            scenario: {
              case: "migration",
              value: !0
            }
          });
          break;
        case "resume-reconnect":
          this.engine.failNext(), yield this.engine.client.handleOnClose("simulate resume-disconnect");
          break;
        case "disconnect-signal-on-resume":
          l = () => __awaiter$3(this, void 0, void 0, function* () {
            yield this.engine.client.handleOnClose("simulate resume-disconnect");
          }), v = new SimulateScenario({
            scenario: {
              case: "disconnectSignalOnResume",
              value: !0
            }
          });
          break;
        case "disconnect-signal-on-resume-no-messages":
          l = () => __awaiter$3(this, void 0, void 0, function* () {
            yield this.engine.client.handleOnClose("simulate resume-disconnect");
          }), v = new SimulateScenario({
            scenario: {
              case: "disconnectSignalOnResumeNoMessages",
              value: !0
            }
          });
          break;
        case "full-reconnect":
          this.engine.fullReconnectOnNext = !0, yield this.engine.client.handleOnClose("simulate full-reconnect");
          break;
        case "force-tcp":
        case "force-tls":
          v = new SimulateScenario({
            scenario: {
              case: "switchCandidateProtocol",
              value: u === "force-tls" ? 2 : 1
            }
          }), l = () => __awaiter$3(this, void 0, void 0, function* () {
            const p = this.engine.client.onLeave;
            p && p(new LeaveRequest({
              reason: DisconnectReason.CLIENT_INITIATED,
              canReconnect: !0
            }));
          });
          break;
        case "subscriber-bandwidth":
          if (c === void 0 || typeof c != "number")
            throw new Error("subscriber-bandwidth requires a number as argument");
          v = new SimulateScenario({
            scenario: {
              case: "subscriberBandwidth",
              value: BigInt(c)
            }
          });
          break;
      }
      v && (yield this.engine.client.sendSimulateScenario(v), yield l());
    });
  }
  /**
   * Returns true if audio playback is enabled
   */
  get canPlaybackAudio() {
    return this.audioEnabled;
  }
  /**
   * Returns true if video playback is enabled
   */
  get canPlaybackVideo() {
    return !this.isVideoPlaybackBlocked;
  }
  getActiveDevice(u) {
    return this.localParticipant.activeDeviceMap.get(u);
  }
  /**
   * Switches all active devices used in this room to the given device.
   *
   * Note: setting AudioOutput is not supported on some browsers. See [setSinkId](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/setSinkId#browser_compatibility)
   *
   * @param kind use `videoinput` for camera track,
   *  `audioinput` for microphone track,
   *  `audiooutput` to set speaker for all incoming audio tracks
   * @param deviceId
   */
  switchActiveDevice(u, c) {
    let l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
    var v, p, _, k;
    return __awaiter$3(this, void 0, void 0, function* () {
      let O = !1, D = !0;
      const F = l ? {
        exact: c
      } : c;
      if (u === "audioinput") {
        const H = this.options.audioCaptureDefaults.deviceId;
        this.options.audioCaptureDefaults.deviceId = F, O = H !== F;
        const Z = Array.from(this.localParticipant.audioTrackPublications.values()).filter((ee) => ee.source === Track.Source.Microphone);
        try {
          D = (yield Promise.all(Z.map((ee) => {
            var X;
            return (X = ee.audioTrack) === null || X === void 0 ? void 0 : X.setDeviceId(F);
          }))).every((ee) => ee === !0);
        } catch (ee) {
          throw this.options.audioCaptureDefaults.deviceId = H, ee;
        }
      } else if (u === "videoinput") {
        const H = this.options.videoCaptureDefaults.deviceId;
        this.options.videoCaptureDefaults.deviceId = F, O = H !== F;
        const Z = Array.from(this.localParticipant.videoTrackPublications.values()).filter((ee) => ee.source === Track.Source.Camera);
        try {
          D = (yield Promise.all(Z.map((ee) => {
            var X;
            return (X = ee.videoTrack) === null || X === void 0 ? void 0 : X.setDeviceId(F);
          }))).every((ee) => ee === !0);
        } catch (ee) {
          throw this.options.videoCaptureDefaults.deviceId = H, ee;
        }
      } else if (u === "audiooutput") {
        if (!supportsSetSinkId() && !this.options.webAudioMix || this.options.webAudioMix && this.audioContext && !("setSinkId" in this.audioContext))
          throw new Error("cannot switch audio output, setSinkId not supported");
        this.options.webAudioMix && (c = (v = yield DeviceManager.getInstance().normalizeDeviceId("audiooutput", c)) !== null && v !== void 0 ? v : ""), (p = (k = this.options).audioOutput) !== null && p !== void 0 || (k.audioOutput = {});
        const H = this.options.audioOutput.deviceId;
        this.options.audioOutput.deviceId = c, O = H !== F;
        try {
          this.options.webAudioMix ? (_ = this.audioContext) === null || _ === void 0 || _.setSinkId(c) : yield Promise.all(Array.from(this.remoteParticipants.values()).map((Z) => Z.setAudioOutput({
            deviceId: c
          })));
        } catch (Z) {
          throw this.options.audioOutput.deviceId = H, Z;
        }
      }
      return O && D && (this.localParticipant.activeDeviceMap.set(u, c), this.emit(RoomEvent.ActiveDeviceChanged, u, c)), D;
    });
  }
  setupLocalParticipantEvents() {
    this.localParticipant.on(ParticipantEvent.ParticipantMetadataChanged, this.onLocalParticipantMetadataChanged).on(ParticipantEvent.ParticipantNameChanged, this.onLocalParticipantNameChanged).on(ParticipantEvent.TrackMuted, this.onLocalTrackMuted).on(ParticipantEvent.TrackUnmuted, this.onLocalTrackUnmuted).on(ParticipantEvent.LocalTrackPublished, this.onLocalTrackPublished).on(ParticipantEvent.LocalTrackUnpublished, this.onLocalTrackUnpublished).on(ParticipantEvent.ConnectionQualityChanged, this.onLocalConnectionQualityChanged).on(ParticipantEvent.MediaDevicesError, this.onMediaDevicesError).on(ParticipantEvent.AudioStreamAcquired, this.startAudio).on(ParticipantEvent.ParticipantPermissionsChanged, this.onLocalParticipantPermissionsChanged);
  }
  recreateEngine() {
    var u;
    (u = this.engine) === null || u === void 0 || u.close(), this.engine = void 0, this.isResuming = !1, this.remoteParticipants.clear(), this.sidToIdentity.clear(), this.bufferedEvents = [], this.maybeCreateEngine();
  }
  onTrackAdded(u, c, l) {
    if (this.state === ConnectionState.Connecting || this.state === ConnectionState.Reconnecting) {
      const F = () => {
        this.onTrackAdded(u, c, l), H();
      }, H = () => {
        this.off(RoomEvent.Reconnected, F), this.off(RoomEvent.Connected, F), this.off(RoomEvent.Disconnected, H);
      };
      this.once(RoomEvent.Reconnected, F), this.once(RoomEvent.Connected, F), this.once(RoomEvent.Disconnected, H);
      return;
    }
    if (this.state === ConnectionState.Disconnected) {
      this.log.warn("skipping incoming track after Room disconnected", this.logContext);
      return;
    }
    const v = unpackStreamId(c.id), p = v[0];
    let _ = v[1], k = u.id;
    if (_ && _.startsWith("TR") && (k = _), p === this.localParticipant.sid) {
      this.log.warn("tried to create RemoteParticipant for local participant", this.logContext);
      return;
    }
    const O = Array.from(this.remoteParticipants.values()).find((F) => F.sid === p);
    if (!O) {
      this.log.error("Tried to add a track for a participant, that's not present. Sid: ".concat(p), this.logContext);
      return;
    }
    let D;
    this.options.adaptiveStream && (typeof this.options.adaptiveStream == "object" ? D = this.options.adaptiveStream : D = {}), O.addSubscribedMediaTrack(u, k, c, l, D);
  }
  handleDisconnect() {
    let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0, c = arguments.length > 1 ? arguments[1] : void 0;
    var l;
    if (this.clearConnectionReconcile(), this.isResuming = !1, this.bufferedEvents = [], this.state !== ConnectionState.Disconnected) {
      this.regionUrl = void 0;
      try {
        this.remoteParticipants.forEach((v) => {
          v.trackPublications.forEach((p) => {
            v.unpublishTrack(p.trackSid);
          });
        }), this.localParticipant.trackPublications.forEach((v) => {
          var p, _;
          v.track && this.localParticipant.unpublishTrack(v.track, u), u && ((p = v.track) === null || p === void 0 || p.detach(), (_ = v.track) === null || _ === void 0 || _.stop());
        }), this.localParticipant.off(ParticipantEvent.ParticipantMetadataChanged, this.onLocalParticipantMetadataChanged).off(ParticipantEvent.ParticipantNameChanged, this.onLocalParticipantNameChanged).off(ParticipantEvent.TrackMuted, this.onLocalTrackMuted).off(ParticipantEvent.TrackUnmuted, this.onLocalTrackUnmuted).off(ParticipantEvent.LocalTrackPublished, this.onLocalTrackPublished).off(ParticipantEvent.LocalTrackUnpublished, this.onLocalTrackUnpublished).off(ParticipantEvent.ConnectionQualityChanged, this.onLocalConnectionQualityChanged).off(ParticipantEvent.MediaDevicesError, this.onMediaDevicesError).off(ParticipantEvent.AudioStreamAcquired, this.startAudio).off(ParticipantEvent.ParticipantPermissionsChanged, this.onLocalParticipantPermissionsChanged), this.localParticipant.trackPublications.clear(), this.localParticipant.videoTrackPublications.clear(), this.localParticipant.audioTrackPublications.clear(), this.remoteParticipants.clear(), this.sidToIdentity.clear(), this.activeSpeakers = [], this.audioContext && typeof this.options.webAudioMix == "boolean" && (this.audioContext.close(), this.audioContext = void 0), isWeb() && (window.removeEventListener("beforeunload", this.onPageLeave), window.removeEventListener("pagehide", this.onPageLeave), window.removeEventListener("freeze", this.onPageLeave), (l = navigator.mediaDevices) === null || l === void 0 || l.removeEventListener("devicechange", this.handleDeviceChange));
      } finally {
        this.setAndEmitConnectionState(ConnectionState.Disconnected), this.emit(RoomEvent.Disconnected, c);
      }
    }
  }
  handleParticipantDisconnected(u, c) {
    this.remoteParticipants.delete(u), c && (c.trackPublications.forEach((l) => {
      c.unpublishTrack(l.trackSid, !0);
    }), this.emit(RoomEvent.ParticipantDisconnected, c));
  }
  acquireAudioContext() {
    var u, c;
    return __awaiter$3(this, void 0, void 0, function* () {
      if (typeof this.options.webAudioMix != "boolean" && this.options.webAudioMix.audioContext ? this.audioContext = this.options.webAudioMix.audioContext : (!this.audioContext || this.audioContext.state === "closed") && (this.audioContext = (u = getNewAudioContext()) !== null && u !== void 0 ? u : void 0), this.audioContext && this.audioContext.state === "suspended")
        try {
          yield this.audioContext.resume();
        } catch (v) {
          this.log.warn("Could not resume audio context", Object.assign(Object.assign({}, this.logContext), {
            error: v
          }));
        }
      this.options.webAudioMix && this.remoteParticipants.forEach((v) => v.setAudioContext(this.audioContext)), this.localParticipant.setAudioContext(this.audioContext);
      const l = ((c = this.audioContext) === null || c === void 0 ? void 0 : c.state) === "running";
      l !== this.canPlaybackAudio && (this.audioEnabled = l, this.emit(RoomEvent.AudioPlaybackStatusChanged, l));
    });
  }
  createParticipant(u, c) {
    var l;
    let v;
    return c ? v = RemoteParticipant.fromParticipantInfo(this.engine.client, c) : v = new RemoteParticipant(this.engine.client, "", u, void 0, void 0, {
      loggerContextCb: () => this.logContext,
      loggerName: this.options.loggerName
    }), this.options.webAudioMix && v.setAudioContext(this.audioContext), !((l = this.options.audioOutput) === null || l === void 0) && l.deviceId && v.setAudioOutput(this.options.audioOutput).catch((p) => this.log.warn("Could not set audio output: ".concat(p.message), this.logContext)), v;
  }
  getOrCreateParticipant(u, c) {
    if (this.remoteParticipants.has(u)) {
      const v = this.remoteParticipants.get(u);
      return c && v.updateInfo(c) && this.sidToIdentity.set(c.sid, c.identity), v;
    }
    const l = this.createParticipant(u, c);
    return this.remoteParticipants.set(u, l), this.sidToIdentity.set(c.sid, c.identity), this.emitWhenConnected(RoomEvent.ParticipantConnected, l), l.on(ParticipantEvent.TrackPublished, (v) => {
      this.emitWhenConnected(RoomEvent.TrackPublished, v, l);
    }).on(ParticipantEvent.TrackSubscribed, (v, p) => {
      v.kind === Track.Kind.Audio ? (v.on(TrackEvent.AudioPlaybackStarted, this.handleAudioPlaybackStarted), v.on(TrackEvent.AudioPlaybackFailed, this.handleAudioPlaybackFailed)) : v.kind === Track.Kind.Video && (v.on(TrackEvent.VideoPlaybackFailed, this.handleVideoPlaybackFailed), v.on(TrackEvent.VideoPlaybackStarted, this.handleVideoPlaybackStarted)), this.emit(RoomEvent.TrackSubscribed, v, p, l);
    }).on(ParticipantEvent.TrackUnpublished, (v) => {
      this.emit(RoomEvent.TrackUnpublished, v, l);
    }).on(ParticipantEvent.TrackUnsubscribed, (v, p) => {
      this.emit(RoomEvent.TrackUnsubscribed, v, p, l);
    }).on(ParticipantEvent.TrackSubscriptionFailed, (v) => {
      this.emit(RoomEvent.TrackSubscriptionFailed, v, l);
    }).on(ParticipantEvent.TrackMuted, (v) => {
      this.emitWhenConnected(RoomEvent.TrackMuted, v, l);
    }).on(ParticipantEvent.TrackUnmuted, (v) => {
      this.emitWhenConnected(RoomEvent.TrackUnmuted, v, l);
    }).on(ParticipantEvent.ParticipantMetadataChanged, (v) => {
      this.emitWhenConnected(RoomEvent.ParticipantMetadataChanged, v, l);
    }).on(ParticipantEvent.ParticipantNameChanged, (v) => {
      this.emitWhenConnected(RoomEvent.ParticipantNameChanged, v, l);
    }).on(ParticipantEvent.ConnectionQualityChanged, (v) => {
      this.emitWhenConnected(RoomEvent.ConnectionQualityChanged, v, l);
    }).on(ParticipantEvent.ParticipantPermissionsChanged, (v) => {
      this.emitWhenConnected(RoomEvent.ParticipantPermissionsChanged, v, l);
    }).on(ParticipantEvent.TrackSubscriptionStatusChanged, (v, p) => {
      this.emitWhenConnected(RoomEvent.TrackSubscriptionStatusChanged, v, p, l);
    }).on(ParticipantEvent.TrackSubscriptionFailed, (v, p) => {
      this.emit(RoomEvent.TrackSubscriptionFailed, v, l, p);
    }).on(ParticipantEvent.TrackSubscriptionPermissionChanged, (v, p) => {
      this.emitWhenConnected(RoomEvent.TrackSubscriptionPermissionChanged, v, p, l);
    }), c && l.updateInfo(c), l;
  }
  sendSyncState() {
    const u = Array.from(this.remoteParticipants.values()).reduce((l, v) => (l.push(...v.getTrackPublications()), l), []), c = this.localParticipant.getTrackPublications();
    this.engine.sendSyncState(u, c);
  }
  /**
   * After resuming, we'll need to notify the server of the current
   * subscription settings.
   */
  updateSubscriptions() {
    for (const u of this.remoteParticipants.values())
      for (const c of u.videoTrackPublications.values())
        c.isSubscribed && c instanceof RemoteTrackPublication && c.emitTrackUpdate();
  }
  getRemoteParticipantBySid(u) {
    const c = this.sidToIdentity.get(u);
    if (c)
      return this.remoteParticipants.get(c);
  }
  registerConnectionReconcile() {
    this.clearConnectionReconcile();
    let u = 0;
    this.connectionReconcileInterval = CriticalTimers.setInterval(() => {
      // ensure we didn't tear it down
      !this.engine || // engine detected close, but Room missed it
      this.engine.isClosed || // transports failed without notifying engine
      !this.engine.verifyTransport() ? (u++, this.log.warn("detected connection state mismatch", Object.assign(Object.assign({}, this.logContext), {
        numFailures: u,
        engine: {
          closed: this.engine.isClosed,
          transportsConnected: this.engine.verifyTransport()
        }
      })), u >= 3 && (this.recreateEngine(), this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, DisconnectReason.STATE_MISMATCH))) : u = 0;
    }, connectionReconcileFrequency);
  }
  clearConnectionReconcile() {
    this.connectionReconcileInterval && CriticalTimers.clearInterval(this.connectionReconcileInterval);
  }
  setAndEmitConnectionState(u) {
    return u === this.state ? !1 : (this.state = u, this.emit(RoomEvent.ConnectionStateChanged, this.state), !0);
  }
  emitBufferedEvents() {
    this.bufferedEvents.forEach((u) => {
      let [c, l] = u;
      this.emit(c, ...l);
    }), this.bufferedEvents = [];
  }
  emitWhenConnected(u) {
    for (var c = arguments.length, l = new Array(c > 1 ? c - 1 : 0), v = 1; v < c; v++)
      l[v - 1] = arguments[v];
    if (this.state === ConnectionState.Reconnecting || this.isResuming || !this.engine || this.engine.pendingReconnect)
      this.bufferedEvents.push([u, l]);
    else if (this.state === ConnectionState.Connected)
      return this.emit(u, ...l);
    return !1;
  }
  /**
   * Allows to populate a room with simulated participants.
   * No actual connection to a server will be established, all state is
   * @experimental
   */
  simulateParticipants(u) {
    var c, l;
    return __awaiter$3(this, void 0, void 0, function* () {
      const v = Object.assign({
        audio: !0,
        video: !0,
        useRealTracks: !1
      }, u.publish), p = Object.assign({
        count: 9,
        audio: !1,
        video: !0,
        aspectRatios: [1.66, 1.7, 1.3]
      }, u.participants);
      if (this.handleDisconnect(), this.roomInfo = new Room$1({
        sid: "RM_SIMULATED",
        name: "simulated-room",
        emptyTimeout: 0,
        maxParticipants: 0,
        creationTime: protoInt64.parse((/* @__PURE__ */ new Date()).getTime()),
        metadata: "",
        numParticipants: 1,
        numPublishers: 1,
        turnPassword: "",
        enabledCodecs: [],
        activeRecording: !1
      }), this.localParticipant.updateInfo(new ParticipantInfo({
        identity: "simulated-local",
        name: "local-name"
      })), this.setupLocalParticipantEvents(), this.emit(RoomEvent.SignalConnected), this.emit(RoomEvent.Connected), this.setAndEmitConnectionState(ConnectionState.Connected), v.video) {
        const _ = new LocalTrackPublication(Track.Kind.Video, new TrackInfo({
          source: TrackSource.CAMERA,
          sid: Math.floor(Math.random() * 1e4).toString(),
          type: TrackType.AUDIO,
          name: "video-dummy"
        }), new LocalVideoTrack(v.useRealTracks ? (yield window.navigator.mediaDevices.getUserMedia({
          video: !0
        })).getVideoTracks()[0] : createDummyVideoStreamTrack(160 * ((c = p.aspectRatios[0]) !== null && c !== void 0 ? c : 1), 160, !0, !0), void 0, !1, {
          loggerName: this.options.loggerName,
          loggerContextCb: () => this.logContext
        }), {
          loggerName: this.options.loggerName,
          loggerContextCb: () => this.logContext
        });
        this.localParticipant.addTrackPublication(_), this.localParticipant.emit(ParticipantEvent.LocalTrackPublished, _);
      }
      if (v.audio) {
        const _ = new LocalTrackPublication(Track.Kind.Audio, new TrackInfo({
          source: TrackSource.MICROPHONE,
          sid: Math.floor(Math.random() * 1e4).toString(),
          type: TrackType.AUDIO
        }), new LocalAudioTrack(v.useRealTracks ? (yield navigator.mediaDevices.getUserMedia({
          audio: !0
        })).getAudioTracks()[0] : getEmptyAudioStreamTrack(), void 0, !1, this.audioContext, {
          loggerName: this.options.loggerName,
          loggerContextCb: () => this.logContext
        }), {
          loggerName: this.options.loggerName,
          loggerContextCb: () => this.logContext
        });
        this.localParticipant.addTrackPublication(_), this.localParticipant.emit(ParticipantEvent.LocalTrackPublished, _);
      }
      for (let _ = 0; _ < p.count - 1; _ += 1) {
        let k = new ParticipantInfo({
          sid: Math.floor(Math.random() * 1e4).toString(),
          identity: "simulated-".concat(_),
          state: ParticipantInfo_State.ACTIVE,
          tracks: [],
          joinedAt: protoInt64.parse(Date.now())
        });
        const O = this.getOrCreateParticipant(k.identity, k);
        if (p.video) {
          const D = createDummyVideoStreamTrack(160 * ((l = p.aspectRatios[_ % p.aspectRatios.length]) !== null && l !== void 0 ? l : 1), 160, !1, !0), F = new TrackInfo({
            source: TrackSource.CAMERA,
            sid: Math.floor(Math.random() * 1e4).toString(),
            type: TrackType.AUDIO
          });
          O.addSubscribedMediaTrack(D, F.sid, new MediaStream([D])), k.tracks = [...k.tracks, F];
        }
        if (p.audio) {
          const D = getEmptyAudioStreamTrack(), F = new TrackInfo({
            source: TrackSource.MICROPHONE,
            sid: Math.floor(Math.random() * 1e4).toString(),
            type: TrackType.AUDIO
          });
          O.addSubscribedMediaTrack(D, F.sid, new MediaStream([D])), k.tracks = [...k.tracks, F];
        }
        O.updateInfo(k);
      }
    });
  }
  // /** @internal */
  emit(u) {
    for (var c = arguments.length, l = new Array(c > 1 ? c - 1 : 0), v = 1; v < c; v++)
      l[v - 1] = arguments[v];
    if (u !== RoomEvent.ActiveSpeakersChanged) {
      const p = mapArgs(l).filter((_) => _ !== void 0);
      this.log.debug("room event ".concat(u), Object.assign(Object.assign({}, this.logContext), {
        event: u,
        args: p
      }));
    }
    return super.emit(u, ...l);
  }
}
function mapArgs(a) {
  return a.map((u) => {
    if (u)
      return Array.isArray(u) ? mapArgs(u) : typeof u == "object" ? "logContext" in u && u.logContext : u;
  });
}
var CheckStatus;
(function(a) {
  a[a.IDLE = 0] = "IDLE", a[a.RUNNING = 1] = "RUNNING", a[a.SKIPPED = 2] = "SKIPPED", a[a.SUCCESS = 3] = "SUCCESS", a[a.FAILED = 4] = "FAILED";
})(CheckStatus || (CheckStatus = {}));
class Checker extends eventsExports$1.EventEmitter {
  constructor(u, c) {
    let l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    super(), this.status = CheckStatus.IDLE, this.logs = [], this.errorsAsWarnings = !1, this.url = u, this.token = c, this.name = this.constructor.name, this.room = new Room(l.roomOptions), this.connectOptions = l.connectOptions, l.errorsAsWarnings && (this.errorsAsWarnings = l.errorsAsWarnings);
  }
  run(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (this.status !== CheckStatus.IDLE)
        throw Error("check is running already");
      this.setStatus(CheckStatus.RUNNING);
      try {
        yield this.perform();
      } catch (c) {
        c instanceof Error && (this.errorsAsWarnings ? this.appendWarning(c.message) : this.appendError(c.message));
      }
      return yield this.disconnect(), yield new Promise((c) => setTimeout(c, 500)), this.status !== CheckStatus.SKIPPED && this.setStatus(this.isSuccess() ? CheckStatus.SUCCESS : CheckStatus.FAILED), u && u(), this.getInfo();
    });
  }
  isSuccess() {
    return !this.logs.some((u) => u.level === "error");
  }
  connect() {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this.room.state === ConnectionState.Connected ? this.room : (yield this.room.connect(this.url, this.token), this.room);
    });
  }
  disconnect() {
    return __awaiter$3(this, void 0, void 0, function* () {
      this.room && this.room.state !== ConnectionState.Disconnected && (yield this.room.disconnect(), yield new Promise((u) => setTimeout(u, 500)));
    });
  }
  skip() {
    this.setStatus(CheckStatus.SKIPPED);
  }
  appendMessage(u) {
    this.logs.push({
      level: "info",
      message: u
    }), this.emit("update", this.getInfo());
  }
  appendWarning(u) {
    this.logs.push({
      level: "warning",
      message: u
    }), this.emit("update", this.getInfo());
  }
  appendError(u) {
    this.logs.push({
      level: "error",
      message: u
    }), this.emit("update", this.getInfo());
  }
  setStatus(u) {
    this.status = u, this.emit("update", this.getInfo());
  }
  get engine() {
    var u;
    return (u = this.room) === null || u === void 0 ? void 0 : u.engine;
  }
  getInfo() {
    return {
      logs: this.logs,
      name: this.name,
      status: this.status,
      description: this.description
    };
  }
}
function createLocalTracks(a) {
  var u, c;
  return __awaiter$3(this, void 0, void 0, function* () {
    a ?? (a = {}), (u = a.audio) !== null && u !== void 0 || (a.audio = !0), (c = a.video) !== null && c !== void 0 || (a.video = !0);
    const l = mergeDefaultOptions(a, audioDefaults, videoDefaults), v = constraintsForOptions(l), p = navigator.mediaDevices.getUserMedia(v);
    a.audio && (DeviceManager.userMediaPromiseMap.set("audioinput", p), p.catch(() => DeviceManager.userMediaPromiseMap.delete("audioinput"))), a.video && (DeviceManager.userMediaPromiseMap.set("videoinput", p), p.catch(() => DeviceManager.userMediaPromiseMap.delete("videoinput")));
    const _ = yield p;
    return _.getTracks().map((k) => {
      const O = k.kind === "audio";
      O ? a.audio : a.video;
      let D;
      const F = O ? v.audio : v.video;
      typeof F != "boolean" && (D = F), D ? D.deviceId = k.getSettings().deviceId : D = {
        deviceId: k.getSettings().deviceId
      };
      const H = mediaTrackToLocalTrack(k, D);
      return H.kind === Track.Kind.Video ? H.source = Track.Source.Camera : H.kind === Track.Kind.Audio && (H.source = Track.Source.Microphone), H.mediaStream = _, H;
    });
  });
}
function createLocalVideoTrack(a) {
  return __awaiter$3(this, void 0, void 0, function* () {
    return (yield createLocalTracks({
      audio: !1,
      video: a
    }))[0];
  });
}
function createLocalAudioTrack(a) {
  return __awaiter$3(this, void 0, void 0, function* () {
    return (yield createLocalTracks({
      audio: a,
      video: !1
    }))[0];
  });
}
class PublishAudioCheck extends Checker {
  get description() {
    return "Can publish audio";
  }
  perform() {
    var u;
    return __awaiter$3(this, void 0, void 0, function* () {
      const c = yield this.connect(), l = yield createLocalAudioTrack();
      c.localParticipant.publishTrack(l), yield new Promise((_) => setTimeout(_, 3e3));
      const v = yield (u = l.sender) === null || u === void 0 ? void 0 : u.getStats();
      if (!v)
        throw new Error("Could not get RTCStats");
      let p = 0;
      if (v.forEach((_) => {
        _.type === "outbound-rtp" && _.mediaType === "audio" && (p = _.packetsSent);
      }), p === 0)
        throw new Error("Could not determine packets are sent");
      this.appendMessage("published ".concat(p, " audio packets"));
    });
  }
}
class PublishVideoCheck extends Checker {
  get description() {
    return "Can publish video";
  }
  perform() {
    var u;
    return __awaiter$3(this, void 0, void 0, function* () {
      const c = yield this.connect(), l = yield createLocalVideoTrack();
      c.localParticipant.publishTrack(l), yield new Promise((_) => setTimeout(_, 3e3));
      const v = yield (u = l.sender) === null || u === void 0 ? void 0 : u.getStats();
      if (!v)
        throw new Error("Could not get RTCStats");
      let p = 0;
      if (v.forEach((_) => {
        _.type === "outbound-rtp" && _.mediaType === "video" && (p = _.packetsSent);
      }), p === 0)
        throw new Error("Could not determine packets are sent");
      this.appendMessage("published ".concat(p, " video packets"));
    });
  }
}
class ReconnectCheck extends Checker {
  get description() {
    return "Resuming connection after interruption";
  }
  perform() {
    var u;
    return __awaiter$3(this, void 0, void 0, function* () {
      const c = yield this.connect();
      let l = !1, v = !1, p;
      const _ = new Promise((O) => {
        setTimeout(O, 5e3), p = O;
      });
      c.on(RoomEvent.Reconnecting, () => {
        l = !0;
      }).on(RoomEvent.Reconnected, () => {
        v = !0, p(!0);
      }), (u = c.engine.client.ws) === null || u === void 0 || u.close();
      const k = c.engine.client.onClose;
      if (k && k(""), yield _, l) {
        if (!v || c.state !== ConnectionState.Connected)
          throw this.appendWarning("reconnection is only possible in Redis-based configurations"), new Error("Not able to reconnect");
      } else
        throw new Error("Did not attempt to reconnect");
    });
  }
}
class TURNCheck extends Checker {
  get description() {
    return "Can connect via TURN";
  }
  perform() {
    var u, c;
    return __awaiter$3(this, void 0, void 0, function* () {
      const l = new SignalClient(), v = yield l.join(this.url, this.token, {
        autoSubscribe: !0,
        maxRetries: 0,
        e2eeEnabled: !1,
        websocketTimeout: 15e3
      });
      let p = !1, _ = !1, k = !1;
      for (let O of v.iceServers)
        for (let D of O.urls)
          D.startsWith("turn:") ? (_ = !0, k = !0) : D.startsWith("turns:") && (_ = !0, k = !0, p = !0), D.startsWith("stun:") && (k = !0);
      k ? _ && !p && this.appendWarning("TURN is configured server side, but TURN/TLS is unavailable.") : this.appendWarning("No STUN servers configured on server side."), yield l.close(), !((c = (u = this.connectOptions) === null || u === void 0 ? void 0 : u.rtcConfig) === null || c === void 0) && c.iceServers || _ ? yield this.room.connect(this.url, this.token, {
        rtcConfig: {
          iceTransportPolicy: "relay"
        }
      }) : (this.appendWarning("No TURN servers configured."), this.skip(), yield new Promise((O) => setTimeout(O, 0)));
    });
  }
}
class WebRTCCheck extends Checker {
  get description() {
    return "Establishing WebRTC connection";
  }
  perform() {
    return __awaiter$3(this, void 0, void 0, function* () {
      let u = !1, c = !1;
      this.room.on(RoomEvent.SignalConnected, () => {
        const l = this.room.engine.client.onTrickle;
        this.room.engine.client.onTrickle = (v, p) => {
          if (v.candidate) {
            const _ = new RTCIceCandidate(v);
            let k = "".concat(_.protocol, " ").concat(_.address, ":").concat(_.port, " ").concat(_.type);
            _.address && (isIPPrivate(_.address) ? k += " (private)" : _.protocol === "tcp" && _.tcpType === "passive" ? (u = !0, k += " (passive)") : _.protocol === "udp" && (c = !0)), this.appendMessage(k);
          }
          l && l(v, p);
        }, this.room.engine.pcManager && (this.room.engine.pcManager.subscriber.onIceCandidateError = (v) => {
          v instanceof RTCPeerConnectionIceErrorEvent && this.appendWarning("error with ICE candidate: ".concat(v.errorCode, " ").concat(v.errorText, " ").concat(v.url));
        });
      });
      try {
        yield this.connect(), livekitLogger.info("now the room is connected");
      } catch (l) {
        throw this.appendWarning("ports need to be open on firewall in order to connect."), l;
      }
      u || this.appendWarning("Server is not configured for ICE/TCP"), c || this.appendWarning("No public IPv4 UDP candidates were found. Your server is likely not configured correctly");
    });
  }
}
function isIPPrivate(a) {
  const u = a.split(".");
  if (u.length === 4) {
    if (u[0] === "10")
      return !0;
    if (u[0] === "192" && u[1] === "168")
      return !0;
    if (u[0] === "172") {
      const c = parseInt(u[1], 10);
      if (c >= 16 && c <= 31)
        return !0;
    }
  }
  return !1;
}
class WebSocketCheck extends Checker {
  get description() {
    return "Connecting to signal connection via WebSocket";
  }
  perform() {
    var u, c, l;
    return __awaiter$3(this, void 0, void 0, function* () {
      (this.url.startsWith("ws:") || this.url.startsWith("http:")) && this.appendWarning("Server is insecure, clients may block connections to it");
      let v = new SignalClient();
      const p = yield v.join(this.url, this.token, {
        autoSubscribe: !0,
        maxRetries: 0,
        e2eeEnabled: !1,
        websocketTimeout: 15e3
      });
      this.appendMessage("Connected to server, version ".concat(p.serverVersion, ".")), ((u = p.serverInfo) === null || u === void 0 ? void 0 : u.edition) === ServerInfo_Edition.Cloud && (!((c = p.serverInfo) === null || c === void 0) && c.region) && this.appendMessage("LiveKit Cloud: ".concat((l = p.serverInfo) === null || l === void 0 ? void 0 : l.region)), yield v.close();
    });
  }
}
class ConnectionCheck extends eventsExports$1.EventEmitter {
  constructor(u, c) {
    super(), this.checkResults = /* @__PURE__ */ new Map(), this.url = u, this.token = c;
  }
  getNextCheckId() {
    const u = this.checkResults.size;
    return this.checkResults.set(u, {
      logs: [],
      status: CheckStatus.IDLE,
      name: "",
      description: ""
    }), u;
  }
  updateCheck(u, c) {
    this.checkResults.set(u, c), this.emit("checkUpdate", u, c);
  }
  isSuccess() {
    return Array.from(this.checkResults.values()).every((u) => u.status !== CheckStatus.FAILED);
  }
  getResults() {
    return Array.from(this.checkResults.values());
  }
  createAndRunCheck(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      const c = this.getNextCheckId(), l = new u(this.url, this.token), v = (_) => {
        this.updateCheck(c, _);
      };
      l.on("update", v);
      const p = yield l.run();
      return l.off("update", v), p;
    });
  }
  checkWebsocket() {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this.createAndRunCheck(WebSocketCheck);
    });
  }
  checkWebRTC() {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this.createAndRunCheck(WebRTCCheck);
    });
  }
  checkTURN() {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this.createAndRunCheck(TURNCheck);
    });
  }
  checkReconnect() {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this.createAndRunCheck(ReconnectCheck);
    });
  }
  checkPublishAudio() {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this.createAndRunCheck(PublishAudioCheck);
    });
  }
  checkPublishVideo() {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this.createAndRunCheck(PublishVideoCheck);
    });
  }
}
const Rendering = lib$2.LiveApiModel.Rendering, VideoRendering = lib$2.LiveApiModel.VideoRendering, AudioRendering = lib$2.LiveApiModel.AudioRendering, RenderingQuality = lib$2.LiveApiModel.RenderingQuality, Encoding = lib$2.LiveApiModel.Encoding, VideoEncoding = lib$2.LiveApiModel.VideoEncoding, AudioEncoding = lib$2.LiveApiModel.AudioEncoding, ProjectBroadcastPhase = lib$2.LiveApiModel.ProjectBroadcastPhase, Role = lib$2.LiveApiModel.Role, DestinationAddress = lib$2.LiveApiModel.DestinationAddress, VideoCodec = lib$2.LiveApiModel.VideoCodec, AudioCodec = lib$2.LiveApiModel.AudioCodec, VideoCodecRateControl = lib$2.LiveApiModel.VideoCodecRateControl, VideoCodecProfile = lib$2.LiveApiModel.VideoCodecProfile, types$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AudioCodec,
  AudioEncoding,
  AudioRendering,
  DestinationAddress,
  Encoding,
  ProjectBroadcastPhase,
  Rendering,
  RenderingQuality,
  Role,
  VideoCodec,
  VideoCodecProfile,
  VideoCodecRateControl,
  VideoEncoding,
  VideoRendering
}, Symbol.toStringTag, { value: "Module" }));
var Permission = /* @__PURE__ */ ((a) => (a[a.ReadProject = 0] = "ReadProject", a[a.UpdateProject = 1] = "UpdateProject", a[a.JoinRoom = 2] = "JoinRoom", a[a.InviteGuests = 3] = "InviteGuests", a[a.ManageGuests = 4] = "ManageGuests", a[a.ManageBroadcast = 5] = "ManageBroadcast", a[a.ManageSelf = 6] = "ManageSelf", a))(Permission || {});
const permissions = {
  [Role.ROLE_HOST]: [
    0,
    1,
    2,
    3,
    4,
    5
    /* ManageBroadcast */
  ],
  [Role.ROLE_COHOST]: [
    0,
    1,
    2,
    3,
    4,
    5
    /* ManageBroadcast */
  ],
  [Role.ROLE_CONTRIBUTOR]: [
    0,
    1,
    2,
    3
    /* InviteGuests */
  ],
  [Role.ROLE_GUEST]: [
    0,
    2,
    6
    /* ManageSelf */
  ],
  [Role.ROLE_VIEWER]: [
    0,
    2
    /* JoinRoom */
  ],
  [Role.ROLE_IMPERSONATE]: [
    0,
    1,
    3,
    4,
    5
    /* ManageBroadcast */
  ]
}, hasPermission = (a, u) => {
  var c;
  return a ? !!((c = permissions[a]) != null && c.find((l) => l === u)) : !1;
};
let currentSubId = 0;
const subscribers = /* @__PURE__ */ new Map(), subscribersInternal = /* @__PURE__ */ new Map();
function createSubscribe(a = {}) {
  return function(u) {
    if (typeof u != "function")
      return;
    const c = a.internal ? subscribersInternal : subscribers, l = ++currentSubId;
    return c.set(l, u), () => {
      c.delete(l);
    };
  };
}
function createOn(a = {}) {
  return function(u, c) {
    return (a.internal ? subscribeInternal : subscribe)((v, p) => {
      if (u === v)
        return c(p);
    });
  };
}
function createTrigger(a = {}) {
  const u = a.internal ? subscribersInternal : subscribers;
  return async function(c, ...l) {
    let v = {
      type: c,
      payload: l[0]
    };
    const p = a.internal ? "Internal" : "External";
    log.info(`${p} Event:`, v), await Promise.all(Array.from(u.values()).map((_) => _(v.type, v.payload)));
  };
}
const trigger$1 = createTrigger(), subscribe = createSubscribe(), on = createOn(), triggerInternal$1 = createTrigger({
  internal: !0
}), subscribeInternal = createSubscribe({
  internal: !0
}), onInternal = createOn({
  internal: !0
}), events$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  on,
  onInternal,
  subscribe,
  subscribeInternal,
  trigger: trigger$1,
  triggerInternal: triggerInternal$1
}, Symbol.toStringTag, { value: "Module" }));
var loglevel = { exports: {} };
(function(a) {
  (function(u, c) {
    a.exports ? a.exports = c() : u.log = c();
  })(commonjsGlobal$1, function() {
    var u = function() {
    }, c = "undefined", l = typeof window !== c && typeof window.navigator !== c && /Trident\/|MSIE /.test(window.navigator.userAgent), v = [
      "trace",
      "debug",
      "info",
      "warn",
      "error"
    ], p = {}, _ = null;
    function k(ne, Q) {
      var ae = ne[Q];
      if (typeof ae.bind == "function")
        return ae.bind(ne);
      try {
        return Function.prototype.bind.call(ae, ne);
      } catch {
        return function() {
          return Function.prototype.apply.apply(ae, [ne, arguments]);
        };
      }
    }
    function O() {
      console.log && (console.log.apply ? console.log.apply(console, arguments) : Function.prototype.apply.apply(console.log, [console, arguments])), console.trace && console.trace();
    }
    function D(ne) {
      return ne === "debug" && (ne = "log"), typeof console === c ? !1 : ne === "trace" && l ? O : console[ne] !== void 0 ? k(console, ne) : console.log !== void 0 ? k(console, "log") : u;
    }
    function F() {
      for (var ne = this.getLevel(), Q = 0; Q < v.length; Q++) {
        var ae = v[Q];
        this[ae] = Q < ne ? u : this.methodFactory(ae, ne, this.name);
      }
      if (this.log = this.debug, typeof console === c && ne < this.levels.SILENT)
        return "No console available for logging";
    }
    function H(ne) {
      return function() {
        typeof console !== c && (F.call(this), this[ne].apply(this, arguments));
      };
    }
    function Z(ne, Q, ae) {
      return D(ne) || H.apply(this, arguments);
    }
    function ee(ne, Q) {
      var ae = this, j, ue, he, fe = "loglevel";
      typeof ne == "string" ? fe += ":" + ne : typeof ne == "symbol" && (fe = void 0);
      function be(P) {
        var S = (v[P] || "silent").toUpperCase();
        if (!(typeof window === c || !fe)) {
          try {
            window.localStorage[fe] = S;
            return;
          } catch {
          }
          try {
            window.document.cookie = encodeURIComponent(fe) + "=" + S + ";";
          } catch {
          }
        }
      }
      function ke() {
        var P;
        if (!(typeof window === c || !fe)) {
          try {
            P = window.localStorage[fe];
          } catch {
          }
          if (typeof P === c)
            try {
              var S = window.document.cookie, E = encodeURIComponent(fe), I = S.indexOf(E + "=");
              I !== -1 && (P = /^([^;]+)/.exec(
                S.slice(I + E.length + 1)
              )[1]);
            } catch {
            }
          return ae.levels[P] === void 0 && (P = void 0), P;
        }
      }
      function Te() {
        if (!(typeof window === c || !fe)) {
          try {
            window.localStorage.removeItem(fe);
          } catch {
          }
          try {
            window.document.cookie = encodeURIComponent(fe) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
          } catch {
          }
        }
      }
      function q(P) {
        var S = P;
        if (typeof S == "string" && ae.levels[S.toUpperCase()] !== void 0 && (S = ae.levels[S.toUpperCase()]), typeof S == "number" && S >= 0 && S <= ae.levels.SILENT)
          return S;
        throw new TypeError("log.setLevel() called with invalid level: " + P);
      }
      ae.name = ne, ae.levels = {
        TRACE: 0,
        DEBUG: 1,
        INFO: 2,
        WARN: 3,
        ERROR: 4,
        SILENT: 5
      }, ae.methodFactory = Q || Z, ae.getLevel = function() {
        return he ?? ue ?? j;
      }, ae.setLevel = function(P, S) {
        return he = q(P), S !== !1 && be(he), F.call(ae);
      }, ae.setDefaultLevel = function(P) {
        ue = q(P), ke() || ae.setLevel(P, !1);
      }, ae.resetLevel = function() {
        he = null, Te(), F.call(ae);
      }, ae.enableAll = function(P) {
        ae.setLevel(ae.levels.TRACE, P);
      }, ae.disableAll = function(P) {
        ae.setLevel(ae.levels.SILENT, P);
      }, ae.rebuild = function() {
        if (_ !== ae && (j = q(_.getLevel())), F.call(ae), _ === ae)
          for (var P in p)
            p[P].rebuild();
      }, j = q(
        _ ? _.getLevel() : "WARN"
      );
      var z = ke();
      z != null && (he = q(z)), F.call(ae);
    }
    _ = new ee(), _.getLogger = function(Q) {
      if (typeof Q != "symbol" && typeof Q != "string" || Q === "")
        throw new TypeError("You must supply a name when creating a logger.");
      var ae = p[Q];
      return ae || (ae = p[Q] = new ee(
        Q,
        _.methodFactory
      )), ae;
    };
    var X = typeof window !== c ? window.log : void 0;
    return _.noConflict = function() {
      return typeof window !== c && window.log === _ && (window.log = X), _;
    }, _.getLoggers = function() {
      return p;
    }, _.default = _, _;
  });
})(loglevel);
var loglevelExports = loglevel.exports;
const log = /* @__PURE__ */ getDefaultExportFromCjs$2(loglevelExports), connectionId$1 = (Math.random() * 1e20).toString(36), version$2 = "3.0.13", CoreContext = {
  config: null,
  // TODO: Rename to client
  clients: null,
  Request: {},
  Command: {},
  on,
  subscribe,
  /** @private @internal */
  onInternal,
  /** @private @internal */
  subscribeInternal,
  /** @private @internal */
  trigger: trigger$1,
  /** @private @internal */
  triggerInternal: triggerInternal$1,
  /** @private @internal */
  state: {},
  compositor: {},
  connectionId: connectionId$1,
  version: version$2,
  /** @private @internal */
  rendererVersion: version$2,
  log,
  logLevel: null
}, setAppState = (a) => {
  Object.keys(a).forEach((u) => {
    CoreContext.state[u] = a[u];
  });
}, context = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CoreContext,
  default: CoreContext,
  log,
  setAppState
}, Symbol.toStringTag, { value: "Module" }));
var dist = {}, AccessToken$1 = {}, jws$3 = {}, safeBuffer$4 = { exports: {} };
const require$$0$2 = /* @__PURE__ */ getAugmentedNamespace(dist$3);
(function(a, u) {
  var c = require$$0$2, l = c.Buffer;
  function v(_, k) {
    for (var O in _)
      k[O] = _[O];
  }
  l.from && l.alloc && l.allocUnsafe && l.allocUnsafeSlow ? a.exports = c : (v(c, u), u.Buffer = p);
  function p(_, k, O) {
    return l(_, k, O);
  }
  v(l, p), p.from = function(_, k, O) {
    if (typeof _ == "number")
      throw new TypeError("Argument must not be a number");
    return l(_, k, O);
  }, p.alloc = function(_, k, O) {
    if (typeof _ != "number")
      throw new TypeError("Argument must be a number");
    var D = l(_);
    return k !== void 0 ? typeof O == "string" ? D.fill(k, O) : D.fill(k) : D.fill(0), D;
  }, p.allocUnsafe = function(_) {
    if (typeof _ != "number")
      throw new TypeError("Argument must be a number");
    return l(_);
  }, p.allocUnsafeSlow = function(_) {
    if (typeof _ != "number")
      throw new TypeError("Argument must be a number");
    return c.SlowBuffer(_);
  };
})(safeBuffer$4, safeBuffer$4.exports);
var safeBufferExports$3 = safeBuffer$4.exports, events = { exports: {} }, R = typeof Reflect == "object" ? Reflect : null, ReflectApply = R && typeof R.apply == "function" ? R.apply : function a(u, c, l) {
  return Function.prototype.apply.call(u, c, l);
}, ReflectOwnKeys;
R && typeof R.ownKeys == "function" ? ReflectOwnKeys = R.ownKeys : Object.getOwnPropertySymbols ? ReflectOwnKeys = function(u) {
  return Object.getOwnPropertyNames(u).concat(Object.getOwnPropertySymbols(u));
} : ReflectOwnKeys = function(u) {
  return Object.getOwnPropertyNames(u);
};
function ProcessEmitWarning(a) {
  console && console.warn && console.warn(a);
}
var NumberIsNaN = Number.isNaN || function a(u) {
  return u !== u;
};
function EventEmitter() {
  EventEmitter.init.call(this);
}
events.exports = EventEmitter;
events.exports.once = once$6;
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = void 0;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = void 0;
var defaultMaxListeners = 10;
function checkListener(a) {
  if (typeof a != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof a);
}
Object.defineProperty(EventEmitter, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(a) {
    if (typeof a != "number" || a < 0 || NumberIsNaN(a))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + a + ".");
    defaultMaxListeners = a;
  }
});
EventEmitter.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
EventEmitter.prototype.setMaxListeners = function a(u) {
  if (typeof u != "number" || u < 0 || NumberIsNaN(u))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + u + ".");
  return this._maxListeners = u, this;
};
function _getMaxListeners(a) {
  return a._maxListeners === void 0 ? EventEmitter.defaultMaxListeners : a._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function a() {
  return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function a(u) {
  for (var c = [], l = 1; l < arguments.length; l++)
    c.push(arguments[l]);
  var v = u === "error", p = this._events;
  if (p !== void 0)
    v = v && p.error === void 0;
  else if (!v)
    return !1;
  if (v) {
    var _;
    if (c.length > 0 && (_ = c[0]), _ instanceof Error)
      throw _;
    var k = new Error("Unhandled error." + (_ ? " (" + _.message + ")" : ""));
    throw k.context = _, k;
  }
  var O = p[u];
  if (O === void 0)
    return !1;
  if (typeof O == "function")
    ReflectApply(O, this, c);
  else
    for (var D = O.length, F = arrayClone(O, D), l = 0; l < D; ++l)
      ReflectApply(F[l], this, c);
  return !0;
};
function _addListener(a, u, c, l) {
  var v, p, _;
  if (checkListener(c), p = a._events, p === void 0 ? (p = a._events = /* @__PURE__ */ Object.create(null), a._eventsCount = 0) : (p.newListener !== void 0 && (a.emit(
    "newListener",
    u,
    c.listener ? c.listener : c
  ), p = a._events), _ = p[u]), _ === void 0)
    _ = p[u] = c, ++a._eventsCount;
  else if (typeof _ == "function" ? _ = p[u] = l ? [c, _] : [_, c] : l ? _.unshift(c) : _.push(c), v = _getMaxListeners(a), v > 0 && _.length > v && !_.warned) {
    _.warned = !0;
    var k = new Error("Possible EventEmitter memory leak detected. " + _.length + " " + String(u) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    k.name = "MaxListenersExceededWarning", k.emitter = a, k.type = u, k.count = _.length, ProcessEmitWarning(k);
  }
  return a;
}
EventEmitter.prototype.addListener = function a(u, c) {
  return _addListener(this, u, c, !1);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function a(u, c) {
  return _addListener(this, u, c, !0);
};
function onceWrapper() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function _onceWrap(a, u, c) {
  var l = { fired: !1, wrapFn: void 0, target: a, type: u, listener: c }, v = onceWrapper.bind(l);
  return v.listener = c, l.wrapFn = v, v;
}
EventEmitter.prototype.once = function a(u, c) {
  return checkListener(c), this.on(u, _onceWrap(this, u, c)), this;
};
EventEmitter.prototype.prependOnceListener = function a(u, c) {
  return checkListener(c), this.prependListener(u, _onceWrap(this, u, c)), this;
};
EventEmitter.prototype.removeListener = function a(u, c) {
  var l, v, p, _, k;
  if (checkListener(c), v = this._events, v === void 0)
    return this;
  if (l = v[u], l === void 0)
    return this;
  if (l === c || l.listener === c)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete v[u], v.removeListener && this.emit("removeListener", u, l.listener || c));
  else if (typeof l != "function") {
    for (p = -1, _ = l.length - 1; _ >= 0; _--)
      if (l[_] === c || l[_].listener === c) {
        k = l[_].listener, p = _;
        break;
      }
    if (p < 0)
      return this;
    p === 0 ? l.shift() : spliceOne(l, p), l.length === 1 && (v[u] = l[0]), v.removeListener !== void 0 && this.emit("removeListener", u, k || c);
  }
  return this;
};
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function a(u) {
  var c, l, v;
  if (l = this._events, l === void 0)
    return this;
  if (l.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : l[u] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete l[u]), this;
  if (arguments.length === 0) {
    var p = Object.keys(l), _;
    for (v = 0; v < p.length; ++v)
      _ = p[v], _ !== "removeListener" && this.removeAllListeners(_);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (c = l[u], typeof c == "function")
    this.removeListener(u, c);
  else if (c !== void 0)
    for (v = c.length - 1; v >= 0; v--)
      this.removeListener(u, c[v]);
  return this;
};
function _listeners(a, u, c) {
  var l = a._events;
  if (l === void 0)
    return [];
  var v = l[u];
  return v === void 0 ? [] : typeof v == "function" ? c ? [v.listener || v] : [v] : c ? unwrapListeners(v) : arrayClone(v, v.length);
}
EventEmitter.prototype.listeners = function a(u) {
  return _listeners(this, u, !0);
};
EventEmitter.prototype.rawListeners = function a(u) {
  return _listeners(this, u, !1);
};
EventEmitter.listenerCount = function(a, u) {
  return typeof a.listenerCount == "function" ? a.listenerCount(u) : listenerCount.call(a, u);
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(a) {
  var u = this._events;
  if (u !== void 0) {
    var c = u[a];
    if (typeof c == "function")
      return 1;
    if (c !== void 0)
      return c.length;
  }
  return 0;
}
EventEmitter.prototype.eventNames = function a() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone(a, u) {
  for (var c = new Array(u), l = 0; l < u; ++l)
    c[l] = a[l];
  return c;
}
function spliceOne(a, u) {
  for (; u + 1 < a.length; u++)
    a[u] = a[u + 1];
  a.pop();
}
function unwrapListeners(a) {
  for (var u = new Array(a.length), c = 0; c < u.length; ++c)
    u[c] = a[c].listener || a[c];
  return u;
}
function once$6(a, u) {
  return new Promise(function(c, l) {
    function v(_) {
      a.removeListener(u, p), l(_);
    }
    function p() {
      typeof a.removeListener == "function" && a.removeListener("error", v), c([].slice.call(arguments));
    }
    eventTargetAgnosticAddListener(a, u, p, { once: !0 }), u !== "error" && addErrorHandlerIfEventEmitter(a, v, { once: !0 });
  });
}
function addErrorHandlerIfEventEmitter(a, u, c) {
  typeof a.on == "function" && eventTargetAgnosticAddListener(a, "error", u, c);
}
function eventTargetAgnosticAddListener(a, u, c, l) {
  if (typeof a.on == "function")
    l.once ? a.once(u, c) : a.on(u, c);
  else if (typeof a.addEventListener == "function")
    a.addEventListener(u, function v(p) {
      l.once && a.removeEventListener(u, v), c(p);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof a);
}
var eventsExports = events.exports, inherits_browser = { exports: {} };
typeof Object.create == "function" ? inherits_browser.exports = function(u, c) {
  c && (u.super_ = c, u.prototype = Object.create(c.prototype, {
    constructor: {
      value: u,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }));
} : inherits_browser.exports = function(u, c) {
  if (c) {
    u.super_ = c;
    var l = function() {
    };
    l.prototype = c.prototype, u.prototype = new l(), u.prototype.constructor = u;
  }
};
var inherits_browserExports = inherits_browser.exports, streamBrowser$2, hasRequiredStreamBrowser;
function requireStreamBrowser() {
  return hasRequiredStreamBrowser || (hasRequiredStreamBrowser = 1, streamBrowser$2 = eventsExports.EventEmitter), streamBrowser$2;
}
var util$4 = {}, types$1 = {}, shams$1 = function a() {
  if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
    return !1;
  if (typeof Symbol.iterator == "symbol")
    return !0;
  var u = {}, c = Symbol("test"), l = Object(c);
  if (typeof c == "string" || Object.prototype.toString.call(c) !== "[object Symbol]" || Object.prototype.toString.call(l) !== "[object Symbol]")
    return !1;
  var v = 42;
  u[c] = v;
  for (c in u)
    return !1;
  if (typeof Object.keys == "function" && Object.keys(u).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(u).length !== 0)
    return !1;
  var p = Object.getOwnPropertySymbols(u);
  if (p.length !== 1 || p[0] !== c || !Object.prototype.propertyIsEnumerable.call(u, c))
    return !1;
  if (typeof Object.getOwnPropertyDescriptor == "function") {
    var _ = Object.getOwnPropertyDescriptor(u, c);
    if (_.value !== v || _.enumerable !== !0)
      return !1;
  }
  return !0;
}, hasSymbols$2 = shams$1, shams = function a() {
  return hasSymbols$2() && !!Symbol.toStringTag;
}, esErrors = Error, _eval = EvalError, range = RangeError, ref$1 = ReferenceError, syntax = SyntaxError, type = TypeError, uri = URIError, origSymbol = typeof Symbol < "u" && Symbol, hasSymbolSham = shams$1, hasSymbols$1 = function a() {
  return typeof origSymbol != "function" || typeof Symbol != "function" || typeof origSymbol("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : hasSymbolSham();
}, test = {
  foo: {}
}, $Object = Object, hasProto$1 = function a() {
  return { __proto__: test }.foo === test.foo && !({ __proto__: null } instanceof $Object);
}, ERROR_MESSAGE = "Function.prototype.bind called on incompatible ", toStr$3 = Object.prototype.toString, max = Math.max, funcType = "[object Function]", concatty = function a(u, c) {
  for (var l = [], v = 0; v < u.length; v += 1)
    l[v] = u[v];
  for (var p = 0; p < c.length; p += 1)
    l[p + u.length] = c[p];
  return l;
}, slicy = function a(u, c) {
  for (var l = [], v = c || 0, p = 0; v < u.length; v += 1, p += 1)
    l[p] = u[v];
  return l;
}, joiny = function(a, u) {
  for (var c = "", l = 0; l < a.length; l += 1)
    c += a[l], l + 1 < a.length && (c += u);
  return c;
}, implementation$1 = function a(u) {
  var c = this;
  if (typeof c != "function" || toStr$3.apply(c) !== funcType)
    throw new TypeError(ERROR_MESSAGE + c);
  for (var l = slicy(arguments, 1), v, p = function() {
    if (this instanceof v) {
      var F = c.apply(
        this,
        concatty(l, arguments)
      );
      return Object(F) === F ? F : this;
    }
    return c.apply(
      u,
      concatty(l, arguments)
    );
  }, _ = max(0, c.length - l.length), k = [], O = 0; O < _; O++)
    k[O] = "$" + O;
  if (v = Function("binder", "return function (" + joiny(k, ",") + "){ return binder.apply(this,arguments); }")(p), c.prototype) {
    var D = function() {
    };
    D.prototype = c.prototype, v.prototype = new D(), D.prototype = null;
  }
  return v;
}, implementation = implementation$1, functionBind = Function.prototype.bind || implementation, call$2 = Function.prototype.call, $hasOwn = Object.prototype.hasOwnProperty, bind$4 = functionBind, hasown = bind$4.call(call$2, $hasOwn), undefined$1, $Error = esErrors, $EvalError = _eval, $RangeError = range, $ReferenceError = ref$1, $SyntaxError$1 = syntax, $TypeError$2 = type, $URIError = uri, $Function = Function, getEvalledConstructor = function(a) {
  try {
    return $Function('"use strict"; return (' + a + ").constructor;")();
  } catch {
  }
}, $gOPD$1 = Object.getOwnPropertyDescriptor;
if ($gOPD$1)
  try {
    $gOPD$1({}, "");
  } catch {
    $gOPD$1 = null;
  }
var throwTypeError = function() {
  throw new $TypeError$2();
}, ThrowTypeError = $gOPD$1 ? function() {
  try {
    return arguments.callee, throwTypeError;
  } catch {
    try {
      return $gOPD$1(arguments, "callee").get;
    } catch {
      return throwTypeError;
    }
  }
}() : throwTypeError, hasSymbols = hasSymbols$1(), hasProto = hasProto$1(), getProto$1 = Object.getPrototypeOf || (hasProto ? function(a) {
  return a.__proto__;
} : null), needsEval = {}, TypedArray = typeof Uint8Array > "u" || !getProto$1 ? undefined$1 : getProto$1(Uint8Array), INTRINSICS = {
  __proto__: null,
  "%AggregateError%": typeof AggregateError > "u" ? undefined$1 : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer > "u" ? undefined$1 : ArrayBuffer,
  "%ArrayIteratorPrototype%": hasSymbols && getProto$1 ? getProto$1([][Symbol.iterator]()) : undefined$1,
  "%AsyncFromSyncIteratorPrototype%": undefined$1,
  "%AsyncFunction%": needsEval,
  "%AsyncGenerator%": needsEval,
  "%AsyncGeneratorFunction%": needsEval,
  "%AsyncIteratorPrototype%": needsEval,
  "%Atomics%": typeof Atomics > "u" ? undefined$1 : Atomics,
  "%BigInt%": typeof BigInt > "u" ? undefined$1 : BigInt,
  "%BigInt64Array%": typeof BigInt64Array > "u" ? undefined$1 : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array > "u" ? undefined$1 : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView > "u" ? undefined$1 : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": $Error,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": $EvalError,
  "%Float32Array%": typeof Float32Array > "u" ? undefined$1 : Float32Array,
  "%Float64Array%": typeof Float64Array > "u" ? undefined$1 : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? undefined$1 : FinalizationRegistry,
  "%Function%": $Function,
  "%GeneratorFunction%": needsEval,
  "%Int8Array%": typeof Int8Array > "u" ? undefined$1 : Int8Array,
  "%Int16Array%": typeof Int16Array > "u" ? undefined$1 : Int16Array,
  "%Int32Array%": typeof Int32Array > "u" ? undefined$1 : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": hasSymbols && getProto$1 ? getProto$1(getProto$1([][Symbol.iterator]())) : undefined$1,
  "%JSON%": typeof JSON == "object" ? JSON : undefined$1,
  "%Map%": typeof Map > "u" ? undefined$1 : Map,
  "%MapIteratorPrototype%": typeof Map > "u" || !hasSymbols || !getProto$1 ? undefined$1 : getProto$1((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Object,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise > "u" ? undefined$1 : Promise,
  "%Proxy%": typeof Proxy > "u" ? undefined$1 : Proxy,
  "%RangeError%": $RangeError,
  "%ReferenceError%": $ReferenceError,
  "%Reflect%": typeof Reflect > "u" ? undefined$1 : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set > "u" ? undefined$1 : Set,
  "%SetIteratorPrototype%": typeof Set > "u" || !hasSymbols || !getProto$1 ? undefined$1 : getProto$1((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? undefined$1 : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": hasSymbols && getProto$1 ? getProto$1(""[Symbol.iterator]()) : undefined$1,
  "%Symbol%": hasSymbols ? Symbol : undefined$1,
  "%SyntaxError%": $SyntaxError$1,
  "%ThrowTypeError%": ThrowTypeError,
  "%TypedArray%": TypedArray,
  "%TypeError%": $TypeError$2,
  "%Uint8Array%": typeof Uint8Array > "u" ? undefined$1 : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? undefined$1 : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array > "u" ? undefined$1 : Uint16Array,
  "%Uint32Array%": typeof Uint32Array > "u" ? undefined$1 : Uint32Array,
  "%URIError%": $URIError,
  "%WeakMap%": typeof WeakMap > "u" ? undefined$1 : WeakMap,
  "%WeakRef%": typeof WeakRef > "u" ? undefined$1 : WeakRef,
  "%WeakSet%": typeof WeakSet > "u" ? undefined$1 : WeakSet
};
if (getProto$1)
  try {
    null.error;
  } catch (a) {
    var errorProto = getProto$1(getProto$1(a));
    INTRINSICS["%Error.prototype%"] = errorProto;
  }
var doEval = function a(u) {
  var c;
  if (u === "%AsyncFunction%")
    c = getEvalledConstructor("async function () {}");
  else if (u === "%GeneratorFunction%")
    c = getEvalledConstructor("function* () {}");
  else if (u === "%AsyncGeneratorFunction%")
    c = getEvalledConstructor("async function* () {}");
  else if (u === "%AsyncGenerator%") {
    var l = a("%AsyncGeneratorFunction%");
    l && (c = l.prototype);
  } else if (u === "%AsyncIteratorPrototype%") {
    var v = a("%AsyncGenerator%");
    v && getProto$1 && (c = getProto$1(v.prototype));
  }
  return INTRINSICS[u] = c, c;
}, LEGACY_ALIASES = {
  __proto__: null,
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
}, bind$3 = functionBind, hasOwn = hasown, $concat = bind$3.call(Function.call, Array.prototype.concat), $spliceApply = bind$3.call(Function.apply, Array.prototype.splice), $replace = bind$3.call(Function.call, String.prototype.replace), $strSlice = bind$3.call(Function.call, String.prototype.slice), $exec = bind$3.call(Function.call, RegExp.prototype.exec), rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, reEscapeChar = /\\(\\)?/g, stringToPath = function a(u) {
  var c = $strSlice(u, 0, 1), l = $strSlice(u, -1);
  if (c === "%" && l !== "%")
    throw new $SyntaxError$1("invalid intrinsic syntax, expected closing `%`");
  if (l === "%" && c !== "%")
    throw new $SyntaxError$1("invalid intrinsic syntax, expected opening `%`");
  var v = [];
  return $replace(u, rePropName, function(p, _, k, O) {
    v[v.length] = k ? $replace(O, reEscapeChar, "$1") : _ || p;
  }), v;
}, getBaseIntrinsic = function a(u, c) {
  var l = u, v;
  if (hasOwn(LEGACY_ALIASES, l) && (v = LEGACY_ALIASES[l], l = "%" + v[0] + "%"), hasOwn(INTRINSICS, l)) {
    var p = INTRINSICS[l];
    if (p === needsEval && (p = doEval(l)), typeof p > "u" && !c)
      throw new $TypeError$2("intrinsic " + u + " exists, but is not available. Please file an issue!");
    return {
      alias: v,
      name: l,
      value: p
    };
  }
  throw new $SyntaxError$1("intrinsic " + u + " does not exist!");
}, getIntrinsic = function a(u, c) {
  if (typeof u != "string" || u.length === 0)
    throw new $TypeError$2("intrinsic name must be a non-empty string");
  if (arguments.length > 1 && typeof c != "boolean")
    throw new $TypeError$2('"allowMissing" argument must be a boolean');
  if ($exec(/^%?[^%]*%?$/, u) === null)
    throw new $SyntaxError$1("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  var l = stringToPath(u), v = l.length > 0 ? l[0] : "", p = getBaseIntrinsic("%" + v + "%", c), _ = p.name, k = p.value, O = !1, D = p.alias;
  D && (v = D[0], $spliceApply(l, $concat([0, 1], D)));
  for (var F = 1, H = !0; F < l.length; F += 1) {
    var Z = l[F], ee = $strSlice(Z, 0, 1), X = $strSlice(Z, -1);
    if ((ee === '"' || ee === "'" || ee === "`" || X === '"' || X === "'" || X === "`") && ee !== X)
      throw new $SyntaxError$1("property names with quotes must have matching quotes");
    if ((Z === "constructor" || !H) && (O = !0), v += "." + Z, _ = "%" + v + "%", hasOwn(INTRINSICS, _))
      k = INTRINSICS[_];
    else if (k != null) {
      if (!(Z in k)) {
        if (!c)
          throw new $TypeError$2("base intrinsic for " + u + " exists, but the property is not available.");
        return;
      }
      if ($gOPD$1 && F + 1 >= l.length) {
        var ne = $gOPD$1(k, Z);
        H = !!ne, H && "get" in ne && !("originalValue" in ne.get) ? k = ne.get : k = k[Z];
      } else
        H = hasOwn(k, Z), k = k[Z];
      H && !O && (INTRINSICS[_] = k);
    }
  }
  return k;
}, callBind$2 = { exports: {} }, esDefineProperty, hasRequiredEsDefineProperty;
function requireEsDefineProperty() {
  if (hasRequiredEsDefineProperty)
    return esDefineProperty;
  hasRequiredEsDefineProperty = 1;
  var a = getIntrinsic, u = a("%Object.defineProperty%", !0) || !1;
  if (u)
    try {
      u({}, "a", { value: 1 });
    } catch {
      u = !1;
    }
  return esDefineProperty = u, esDefineProperty;
}
var GetIntrinsic$2 = getIntrinsic, $gOPD = GetIntrinsic$2("%Object.getOwnPropertyDescriptor%", !0);
if ($gOPD)
  try {
    $gOPD([], "length");
  } catch {
    $gOPD = null;
  }
var gopd$1 = $gOPD, $defineProperty$1 = requireEsDefineProperty(), $SyntaxError = syntax, $TypeError$1 = type, gopd = gopd$1, defineDataProperty = function a(u, c, l) {
  if (!u || typeof u != "object" && typeof u != "function")
    throw new $TypeError$1("`obj` must be an object or a function`");
  if (typeof c != "string" && typeof c != "symbol")
    throw new $TypeError$1("`property` must be a string or a symbol`");
  if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
    throw new $TypeError$1("`nonEnumerable`, if provided, must be a boolean or null");
  if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
    throw new $TypeError$1("`nonWritable`, if provided, must be a boolean or null");
  if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
    throw new $TypeError$1("`nonConfigurable`, if provided, must be a boolean or null");
  if (arguments.length > 6 && typeof arguments[6] != "boolean")
    throw new $TypeError$1("`loose`, if provided, must be a boolean");
  var v = arguments.length > 3 ? arguments[3] : null, p = arguments.length > 4 ? arguments[4] : null, _ = arguments.length > 5 ? arguments[5] : null, k = arguments.length > 6 ? arguments[6] : !1, O = !!gopd && gopd(u, c);
  if ($defineProperty$1)
    $defineProperty$1(u, c, {
      configurable: _ === null && O ? O.configurable : !_,
      enumerable: v === null && O ? O.enumerable : !v,
      value: l,
      writable: p === null && O ? O.writable : !p
    });
  else if (k || !v && !p && !_)
    u[c] = l;
  else
    throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
}, $defineProperty = requireEsDefineProperty(), hasPropertyDescriptors = function a() {
  return !!$defineProperty;
};
hasPropertyDescriptors.hasArrayLengthDefineBug = function a() {
  if (!$defineProperty)
    return null;
  try {
    return $defineProperty([], "length", { value: 1 }).length !== 1;
  } catch {
    return !0;
  }
};
var hasPropertyDescriptors_1 = hasPropertyDescriptors, GetIntrinsic$1 = getIntrinsic, define = defineDataProperty, hasDescriptors = hasPropertyDescriptors_1(), gOPD$1 = gopd$1, $TypeError = type, $floor = GetIntrinsic$1("%Math.floor%"), setFunctionLength = function a(u, c) {
  if (typeof u != "function")
    throw new $TypeError("`fn` is not a function");
  if (typeof c != "number" || c < 0 || c > 4294967295 || $floor(c) !== c)
    throw new $TypeError("`length` must be a positive 32-bit integer");
  var l = arguments.length > 2 && !!arguments[2], v = !0, p = !0;
  if ("length" in u && gOPD$1) {
    var _ = gOPD$1(u, "length");
    _ && !_.configurable && (v = !1), _ && !_.writable && (p = !1);
  }
  return (v || p || !l) && (hasDescriptors ? define(
    /** @type {Parameters<define>[0]} */
    u,
    "length",
    c,
    !0,
    !0
  ) : define(
    /** @type {Parameters<define>[0]} */
    u,
    "length",
    c
  )), u;
};
(function(a) {
  var u = functionBind, c = getIntrinsic, l = setFunctionLength, v = type, p = c("%Function.prototype.apply%"), _ = c("%Function.prototype.call%"), k = c("%Reflect.apply%", !0) || u.call(_, p), O = requireEsDefineProperty(), D = c("%Math.max%");
  a.exports = function(Z) {
    if (typeof Z != "function")
      throw new v("a function is required");
    var ee = k(u, _, arguments);
    return l(
      ee,
      1 + D(0, Z.length - (arguments.length - 1)),
      !0
    );
  };
  var F = function() {
    return k(u, p, arguments);
  };
  O ? O(a.exports, "apply", { value: F }) : a.exports.apply = F;
})(callBind$2);
var callBindExports = callBind$2.exports, GetIntrinsic = getIntrinsic, callBind$1 = callBindExports, $indexOf$1 = callBind$1(GetIntrinsic("String.prototype.indexOf")), callBound$2 = function a(u, c) {
  var l = GetIntrinsic(u, !!c);
  return typeof l == "function" && $indexOf$1(u, ".prototype.") > -1 ? callBind$1(l) : l;
}, hasToStringTag$3 = shams(), callBound$1 = callBound$2, $toString$1 = callBound$1("Object.prototype.toString"), isStandardArguments = function a(u) {
  return hasToStringTag$3 && u && typeof u == "object" && Symbol.toStringTag in u ? !1 : $toString$1(u) === "[object Arguments]";
}, isLegacyArguments = function a(u) {
  return isStandardArguments(u) ? !0 : u !== null && typeof u == "object" && typeof u.length == "number" && u.length >= 0 && $toString$1(u) !== "[object Array]" && $toString$1(u.callee) === "[object Function]";
}, supportsStandardArguments = function() {
  return isStandardArguments(arguments);
}();
isStandardArguments.isLegacyArguments = isLegacyArguments;
var isArguments$1 = supportsStandardArguments ? isStandardArguments : isLegacyArguments, toStr$2 = Object.prototype.toString, fnToStr$1 = Function.prototype.toString, isFnRegex = /^\s*(?:function)?\*/, hasToStringTag$2 = shams(), getProto = Object.getPrototypeOf, getGeneratorFunc = function() {
  if (!hasToStringTag$2)
    return !1;
  try {
    return Function("return function*() {}")();
  } catch {
  }
}, GeneratorFunction, isGeneratorFunction = function a(u) {
  if (typeof u != "function")
    return !1;
  if (isFnRegex.test(fnToStr$1.call(u)))
    return !0;
  if (!hasToStringTag$2) {
    var c = toStr$2.call(u);
    return c === "[object GeneratorFunction]";
  }
  if (!getProto)
    return !1;
  if (typeof GeneratorFunction > "u") {
    var l = getGeneratorFunc();
    GeneratorFunction = l ? getProto(l) : !1;
  }
  return getProto(u) === GeneratorFunction;
}, fnToStr = Function.prototype.toString, reflectApply = typeof Reflect == "object" && Reflect !== null && Reflect.apply, badArrayLike, isCallableMarker;
if (typeof reflectApply == "function" && typeof Object.defineProperty == "function")
  try {
    badArrayLike = Object.defineProperty({}, "length", {
      get: function() {
        throw isCallableMarker;
      }
    }), isCallableMarker = {}, reflectApply(function() {
      throw 42;
    }, null, badArrayLike);
  } catch (a) {
    a !== isCallableMarker && (reflectApply = null);
  }
else
  reflectApply = null;
var constructorRegex = /^\s*class\b/, isES6ClassFn = function a(u) {
  try {
    var c = fnToStr.call(u);
    return constructorRegex.test(c);
  } catch {
    return !1;
  }
}, tryFunctionObject = function a(u) {
  try {
    return isES6ClassFn(u) ? !1 : (fnToStr.call(u), !0);
  } catch {
    return !1;
  }
}, toStr$1 = Object.prototype.toString, fnClass = "[object Function]", genClass = "[object GeneratorFunction]", hasToStringTag$1 = typeof Symbol == "function" && !!Symbol.toStringTag, documentDotAll = typeof document == "object" && typeof document.all > "u" && document.all !== void 0 ? document.all : {}, isCallable$1 = reflectApply ? function a(u) {
  if (u === documentDotAll)
    return !0;
  if (!u || typeof u != "function" && typeof u != "object")
    return !1;
  if (typeof u == "function" && !u.prototype)
    return !0;
  try {
    reflectApply(u, null, badArrayLike);
  } catch (c) {
    if (c !== isCallableMarker)
      return !1;
  }
  return !isES6ClassFn(u);
} : function a(u) {
  if (u === documentDotAll)
    return !0;
  if (!u || typeof u != "function" && typeof u != "object")
    return !1;
  if (typeof u == "function" && !u.prototype)
    return !0;
  if (hasToStringTag$1)
    return tryFunctionObject(u);
  if (isES6ClassFn(u))
    return !1;
  var c = toStr$1.call(u);
  return c === fnClass || c === genClass;
}, isCallable = isCallable$1, toStr = Object.prototype.toString, hasOwnProperty$2 = Object.prototype.hasOwnProperty, forEachArray = function a(u, c, l) {
  for (var v = 0, p = u.length; v < p; v++)
    hasOwnProperty$2.call(u, v) && (l == null ? c(u[v], v, u) : c.call(l, u[v], v, u));
}, forEachString = function a(u, c, l) {
  for (var v = 0, p = u.length; v < p; v++)
    l == null ? c(u.charAt(v), v, u) : c.call(l, u.charAt(v), v, u);
}, forEachObject = function a(u, c, l) {
  for (var v in u)
    hasOwnProperty$2.call(u, v) && (l == null ? c(u[v], v, u) : c.call(l, u[v], v, u));
}, forEach$2 = function a(u, c, l) {
  if (!isCallable(c))
    throw new TypeError("iterator must be a function");
  var v;
  arguments.length >= 3 && (v = l), toStr.call(u) === "[object Array]" ? forEachArray(u, c, v) : typeof u == "string" ? forEachString(u, c, v) : forEachObject(u, c, v);
}, forEach_1 = forEach$2, possibleNames = [
  "BigInt64Array",
  "BigUint64Array",
  "Float32Array",
  "Float64Array",
  "Int16Array",
  "Int32Array",
  "Int8Array",
  "Uint16Array",
  "Uint32Array",
  "Uint8Array",
  "Uint8ClampedArray"
], g$1 = typeof globalThis > "u" ? commonjsGlobal$1 : globalThis, availableTypedArrays$1 = function a() {
  for (var u = [], c = 0; c < possibleNames.length; c++)
    typeof g$1[possibleNames[c]] == "function" && (u[u.length] = possibleNames[c]);
  return u;
}, forEach$1 = forEach_1, availableTypedArrays = availableTypedArrays$1, callBind = callBindExports, callBound = callBound$2, gOPD = gopd$1, $toString = callBound("Object.prototype.toString"), hasToStringTag = shams(), g = typeof globalThis > "u" ? commonjsGlobal$1 : globalThis, typedArrays = availableTypedArrays(), $slice = callBound("String.prototype.slice"), getPrototypeOf = Object.getPrototypeOf, $indexOf = callBound("Array.prototype.indexOf", !0) || /** @type {(array: readonly unknown[], value: unknown) => keyof array} */
function a(u, c) {
  for (var l = 0; l < u.length; l += 1)
    if (u[l] === c)
      return l;
  return -1;
}, cache$2 = { __proto__: null };
hasToStringTag && gOPD && getPrototypeOf ? forEach$1(typedArrays, function(a) {
  var u = new g[a]();
  if (Symbol.toStringTag in u) {
    var c = getPrototypeOf(u), l = gOPD(c, Symbol.toStringTag);
    if (!l) {
      var v = getPrototypeOf(c);
      l = gOPD(v, Symbol.toStringTag);
    }
    cache$2["$" + a] = callBind(l.get);
  }
}) : forEach$1(typedArrays, function(a) {
  var u = new g[a](), c = u.slice || u.set;
  c && (cache$2["$" + a] = callBind(c));
});
var tryTypedArrays = function a(u) {
  var c = !1;
  return forEach$1(
    // eslint-disable-next-line no-extra-parens
    /** @type {Record<`\$${TypedArrayName}`, typeof cache>} */
    /** @type {any} */
    cache$2,
    /** @type {(getter: typeof cache, name: `\$${TypedArrayName}`) => void} */
    function(l, v) {
      if (!c)
        try {
          "$" + l(u) === v && (c = $slice(v, 1));
        } catch {
        }
    }
  ), c;
}, trySlices = function a(u) {
  var c = !1;
  return forEach$1(
    // eslint-disable-next-line no-extra-parens
    /** @type {any} */
    cache$2,
    /** @type {(getter: typeof cache, name: `\$${TypedArrayName}`) => void} */
    function(l, v) {
      if (!c)
        try {
          l(u), c = $slice(v, 1);
        } catch {
        }
    }
  ), c;
}, whichTypedArray$1 = function a(u) {
  if (!u || typeof u != "object")
    return !1;
  if (!hasToStringTag) {
    var c = $slice($toString(u), 8, -1);
    return $indexOf(typedArrays, c) > -1 ? c : c !== "Object" ? !1 : trySlices(u);
  }
  return gOPD ? tryTypedArrays(u) : null;
}, whichTypedArray = whichTypedArray$1, isTypedArray = function a(u) {
  return !!whichTypedArray(u);
};
(function(a) {
  var u = isArguments$1, c = isGeneratorFunction, l = whichTypedArray$1, v = isTypedArray;
  function p(qe) {
    return qe.call.bind(qe);
  }
  var _ = typeof BigInt < "u", k = typeof Symbol < "u", O = p(Object.prototype.toString), D = p(Number.prototype.valueOf), F = p(String.prototype.valueOf), H = p(Boolean.prototype.valueOf);
  if (_)
    var Z = p(BigInt.prototype.valueOf);
  if (k)
    var ee = p(Symbol.prototype.valueOf);
  function X(qe, yt) {
    if (typeof qe != "object")
      return !1;
    try {
      return yt(qe), !0;
    } catch {
      return !1;
    }
  }
  a.isArgumentsObject = u, a.isGeneratorFunction = c, a.isTypedArray = v;
  function ne(qe) {
    return typeof Promise < "u" && qe instanceof Promise || qe !== null && typeof qe == "object" && typeof qe.then == "function" && typeof qe.catch == "function";
  }
  a.isPromise = ne;
  function Q(qe) {
    return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(qe) : v(qe) || me(qe);
  }
  a.isArrayBufferView = Q;
  function ae(qe) {
    return l(qe) === "Uint8Array";
  }
  a.isUint8Array = ae;
  function j(qe) {
    return l(qe) === "Uint8ClampedArray";
  }
  a.isUint8ClampedArray = j;
  function ue(qe) {
    return l(qe) === "Uint16Array";
  }
  a.isUint16Array = ue;
  function he(qe) {
    return l(qe) === "Uint32Array";
  }
  a.isUint32Array = he;
  function fe(qe) {
    return l(qe) === "Int8Array";
  }
  a.isInt8Array = fe;
  function be(qe) {
    return l(qe) === "Int16Array";
  }
  a.isInt16Array = be;
  function ke(qe) {
    return l(qe) === "Int32Array";
  }
  a.isInt32Array = ke;
  function Te(qe) {
    return l(qe) === "Float32Array";
  }
  a.isFloat32Array = Te;
  function q(qe) {
    return l(qe) === "Float64Array";
  }
  a.isFloat64Array = q;
  function z(qe) {
    return l(qe) === "BigInt64Array";
  }
  a.isBigInt64Array = z;
  function P(qe) {
    return l(qe) === "BigUint64Array";
  }
  a.isBigUint64Array = P;
  function S(qe) {
    return O(qe) === "[object Map]";
  }
  S.working = typeof Map < "u" && S(/* @__PURE__ */ new Map());
  function E(qe) {
    return typeof Map > "u" ? !1 : S.working ? S(qe) : qe instanceof Map;
  }
  a.isMap = E;
  function I(qe) {
    return O(qe) === "[object Set]";
  }
  I.working = typeof Set < "u" && I(/* @__PURE__ */ new Set());
  function M(qe) {
    return typeof Set > "u" ? !1 : I.working ? I(qe) : qe instanceof Set;
  }
  a.isSet = M;
  function $(qe) {
    return O(qe) === "[object WeakMap]";
  }
  $.working = typeof WeakMap < "u" && $(/* @__PURE__ */ new WeakMap());
  function U(qe) {
    return typeof WeakMap > "u" ? !1 : $.working ? $(qe) : qe instanceof WeakMap;
  }
  a.isWeakMap = U;
  function Y(qe) {
    return O(qe) === "[object WeakSet]";
  }
  Y.working = typeof WeakSet < "u" && Y(/* @__PURE__ */ new WeakSet());
  function B(qe) {
    return Y(qe);
  }
  a.isWeakSet = B;
  function T(qe) {
    return O(qe) === "[object ArrayBuffer]";
  }
  T.working = typeof ArrayBuffer < "u" && T(new ArrayBuffer());
  function L(qe) {
    return typeof ArrayBuffer > "u" ? !1 : T.working ? T(qe) : qe instanceof ArrayBuffer;
  }
  a.isArrayBuffer = L;
  function te(qe) {
    return O(qe) === "[object DataView]";
  }
  te.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && te(new DataView(new ArrayBuffer(1), 0, 1));
  function me(qe) {
    return typeof DataView > "u" ? !1 : te.working ? te(qe) : qe instanceof DataView;
  }
  a.isDataView = me;
  var Ce = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
  function De(qe) {
    return O(qe) === "[object SharedArrayBuffer]";
  }
  function ye(qe) {
    return typeof Ce > "u" ? !1 : (typeof De.working > "u" && (De.working = De(new Ce())), De.working ? De(qe) : qe instanceof Ce);
  }
  a.isSharedArrayBuffer = ye;
  function pe(qe) {
    return O(qe) === "[object AsyncFunction]";
  }
  a.isAsyncFunction = pe;
  function Me(qe) {
    return O(qe) === "[object Map Iterator]";
  }
  a.isMapIterator = Me;
  function Ne(qe) {
    return O(qe) === "[object Set Iterator]";
  }
  a.isSetIterator = Ne;
  function Ue(qe) {
    return O(qe) === "[object Generator]";
  }
  a.isGeneratorObject = Ue;
  function oe(qe) {
    return O(qe) === "[object WebAssembly.Module]";
  }
  a.isWebAssemblyCompiledModule = oe;
  function A(qe) {
    return X(qe, D);
  }
  a.isNumberObject = A;
  function re(qe) {
    return X(qe, F);
  }
  a.isStringObject = re;
  function le(qe) {
    return X(qe, H);
  }
  a.isBooleanObject = le;
  function $e(qe) {
    return _ && X(qe, Z);
  }
  a.isBigIntObject = $e;
  function Oe(qe) {
    return k && X(qe, ee);
  }
  a.isSymbolObject = Oe;
  function Fe(qe) {
    return A(qe) || re(qe) || le(qe) || $e(qe) || Oe(qe);
  }
  a.isBoxedPrimitive = Fe;
  function Ze(qe) {
    return typeof Uint8Array < "u" && (L(qe) || ye(qe));
  }
  a.isAnyArrayBuffer = Ze, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(qe) {
    Object.defineProperty(a, qe, {
      enumerable: !1,
      value: function() {
        throw new Error(qe + " is not supported in userland");
      }
    });
  });
})(types$1);
var isBufferBrowser = function a(u) {
  return u && typeof u == "object" && typeof u.copy == "function" && typeof u.fill == "function" && typeof u.readUInt8 == "function";
};
(function(a) {
  var u = Object.getOwnPropertyDescriptors || function(me) {
    for (var Ce = Object.keys(me), De = {}, ye = 0; ye < Ce.length; ye++)
      De[Ce[ye]] = Object.getOwnPropertyDescriptor(me, Ce[ye]);
    return De;
  }, c = /%[sdj%]/g;
  a.format = function(te) {
    if (!fe(te)) {
      for (var me = [], Ce = 0; Ce < arguments.length; Ce++)
        me.push(_(arguments[Ce]));
      return me.join(" ");
    }
    for (var Ce = 1, De = arguments, ye = De.length, pe = String(te).replace(c, function(Ne) {
      if (Ne === "%%")
        return "%";
      if (Ce >= ye)
        return Ne;
      switch (Ne) {
        case "%s":
          return String(De[Ce++]);
        case "%d":
          return Number(De[Ce++]);
        case "%j":
          try {
            return JSON.stringify(De[Ce++]);
          } catch {
            return "[Circular]";
          }
        default:
          return Ne;
      }
    }), Me = De[Ce]; Ce < ye; Me = De[++Ce])
      j(Me) || !q(Me) ? pe += " " + Me : pe += " " + _(Me);
    return pe;
  }, a.deprecate = function(te, me) {
    if (typeof process$1 < "u" && process$1.noDeprecation === !0)
      return te;
    if (typeof process$1 > "u")
      return function() {
        return a.deprecate(te, me).apply(this, arguments);
      };
    var Ce = !1;
    function De() {
      if (!Ce) {
        if (process$1.throwDeprecation)
          throw new Error(me);
        process$1.traceDeprecation ? console.trace(me) : console.error(me), Ce = !0;
      }
      return te.apply(this, arguments);
    }
    return De;
  };
  var l = {}, v = /^$/;
  if (process$1.env.NODE_DEBUG) {
    var p = process$1.env.NODE_DEBUG;
    p = p.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), v = new RegExp("^" + p + "$", "i");
  }
  a.debuglog = function(te) {
    if (te = te.toUpperCase(), !l[te])
      if (v.test(te)) {
        var me = process$1.pid;
        l[te] = function() {
          var Ce = a.format.apply(a, arguments);
          console.error("%s %d: %s", te, me, Ce);
        };
      } else
        l[te] = function() {
        };
    return l[te];
  };
  function _(te, me) {
    var Ce = {
      seen: [],
      stylize: O
    };
    return arguments.length >= 3 && (Ce.depth = arguments[2]), arguments.length >= 4 && (Ce.colors = arguments[3]), ae(me) ? Ce.showHidden = me : me && a._extend(Ce, me), ke(Ce.showHidden) && (Ce.showHidden = !1), ke(Ce.depth) && (Ce.depth = 2), ke(Ce.colors) && (Ce.colors = !1), ke(Ce.customInspect) && (Ce.customInspect = !0), Ce.colors && (Ce.stylize = k), F(Ce, te, Ce.depth);
  }
  a.inspect = _, _.colors = {
    bold: [1, 22],
    italic: [3, 23],
    underline: [4, 24],
    inverse: [7, 27],
    white: [37, 39],
    grey: [90, 39],
    black: [30, 39],
    blue: [34, 39],
    cyan: [36, 39],
    green: [32, 39],
    magenta: [35, 39],
    red: [31, 39],
    yellow: [33, 39]
  }, _.styles = {
    special: "cyan",
    number: "yellow",
    boolean: "yellow",
    undefined: "grey",
    null: "bold",
    string: "green",
    date: "magenta",
    // "name": intentionally not styling
    regexp: "red"
  };
  function k(te, me) {
    var Ce = _.styles[me];
    return Ce ? "\x1B[" + _.colors[Ce][0] + "m" + te + "\x1B[" + _.colors[Ce][1] + "m" : te;
  }
  function O(te, me) {
    return te;
  }
  function D(te) {
    var me = {};
    return te.forEach(function(Ce, De) {
      me[Ce] = !0;
    }), me;
  }
  function F(te, me, Ce) {
    if (te.customInspect && me && S(me.inspect) && // Filter out the util module, it's inspect function is special
    me.inspect !== a.inspect && // Also filter out any prototype objects using the circular check.
    !(me.constructor && me.constructor.prototype === me)) {
      var De = me.inspect(Ce, te);
      return fe(De) || (De = F(te, De, Ce)), De;
    }
    var ye = H(te, me);
    if (ye)
      return ye;
    var pe = Object.keys(me), Me = D(pe);
    if (te.showHidden && (pe = Object.getOwnPropertyNames(me)), P(me) && (pe.indexOf("message") >= 0 || pe.indexOf("description") >= 0))
      return Z(me);
    if (pe.length === 0) {
      if (S(me)) {
        var Ne = me.name ? ": " + me.name : "";
        return te.stylize("[Function" + Ne + "]", "special");
      }
      if (Te(me))
        return te.stylize(RegExp.prototype.toString.call(me), "regexp");
      if (z(me))
        return te.stylize(Date.prototype.toString.call(me), "date");
      if (P(me))
        return Z(me);
    }
    var Ue = "", oe = !1, A = ["{", "}"];
    if (Q(me) && (oe = !0, A = ["[", "]"]), S(me)) {
      var re = me.name ? ": " + me.name : "";
      Ue = " [Function" + re + "]";
    }
    if (Te(me) && (Ue = " " + RegExp.prototype.toString.call(me)), z(me) && (Ue = " " + Date.prototype.toUTCString.call(me)), P(me) && (Ue = " " + Z(me)), pe.length === 0 && (!oe || me.length == 0))
      return A[0] + Ue + A[1];
    if (Ce < 0)
      return Te(me) ? te.stylize(RegExp.prototype.toString.call(me), "regexp") : te.stylize("[Object]", "special");
    te.seen.push(me);
    var le;
    return oe ? le = ee(te, me, Ce, Me, pe) : le = pe.map(function($e) {
      return X(te, me, Ce, Me, $e, oe);
    }), te.seen.pop(), ne(le, Ue, A);
  }
  function H(te, me) {
    if (ke(me))
      return te.stylize("undefined", "undefined");
    if (fe(me)) {
      var Ce = "'" + JSON.stringify(me).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return te.stylize(Ce, "string");
    }
    if (he(me))
      return te.stylize("" + me, "number");
    if (ae(me))
      return te.stylize("" + me, "boolean");
    if (j(me))
      return te.stylize("null", "null");
  }
  function Z(te) {
    return "[" + Error.prototype.toString.call(te) + "]";
  }
  function ee(te, me, Ce, De, ye) {
    for (var pe = [], Me = 0, Ne = me.length; Me < Ne; ++Me)
      Y(me, String(Me)) ? pe.push(X(
        te,
        me,
        Ce,
        De,
        String(Me),
        !0
      )) : pe.push("");
    return ye.forEach(function(Ue) {
      Ue.match(/^\d+$/) || pe.push(X(
        te,
        me,
        Ce,
        De,
        Ue,
        !0
      ));
    }), pe;
  }
  function X(te, me, Ce, De, ye, pe) {
    var Me, Ne, Ue;
    if (Ue = Object.getOwnPropertyDescriptor(me, ye) || { value: me[ye] }, Ue.get ? Ue.set ? Ne = te.stylize("[Getter/Setter]", "special") : Ne = te.stylize("[Getter]", "special") : Ue.set && (Ne = te.stylize("[Setter]", "special")), Y(De, ye) || (Me = "[" + ye + "]"), Ne || (te.seen.indexOf(Ue.value) < 0 ? (j(Ce) ? Ne = F(te, Ue.value, null) : Ne = F(te, Ue.value, Ce - 1), Ne.indexOf(`
`) > -1 && (pe ? Ne = Ne.split(`
`).map(function(oe) {
      return "  " + oe;
    }).join(`
`).slice(2) : Ne = `
` + Ne.split(`
`).map(function(oe) {
      return "   " + oe;
    }).join(`
`))) : Ne = te.stylize("[Circular]", "special")), ke(Me)) {
      if (pe && ye.match(/^\d+$/))
        return Ne;
      Me = JSON.stringify("" + ye), Me.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (Me = Me.slice(1, -1), Me = te.stylize(Me, "name")) : (Me = Me.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), Me = te.stylize(Me, "string"));
    }
    return Me + ": " + Ne;
  }
  function ne(te, me, Ce) {
    var De = te.reduce(function(ye, pe) {
      return pe.indexOf(`
`) >= 0, ye + pe.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0);
    return De > 60 ? Ce[0] + (me === "" ? "" : me + `
 `) + " " + te.join(`,
  `) + " " + Ce[1] : Ce[0] + me + " " + te.join(", ") + " " + Ce[1];
  }
  a.types = types$1;
  function Q(te) {
    return Array.isArray(te);
  }
  a.isArray = Q;
  function ae(te) {
    return typeof te == "boolean";
  }
  a.isBoolean = ae;
  function j(te) {
    return te === null;
  }
  a.isNull = j;
  function ue(te) {
    return te == null;
  }
  a.isNullOrUndefined = ue;
  function he(te) {
    return typeof te == "number";
  }
  a.isNumber = he;
  function fe(te) {
    return typeof te == "string";
  }
  a.isString = fe;
  function be(te) {
    return typeof te == "symbol";
  }
  a.isSymbol = be;
  function ke(te) {
    return te === void 0;
  }
  a.isUndefined = ke;
  function Te(te) {
    return q(te) && I(te) === "[object RegExp]";
  }
  a.isRegExp = Te, a.types.isRegExp = Te;
  function q(te) {
    return typeof te == "object" && te !== null;
  }
  a.isObject = q;
  function z(te) {
    return q(te) && I(te) === "[object Date]";
  }
  a.isDate = z, a.types.isDate = z;
  function P(te) {
    return q(te) && (I(te) === "[object Error]" || te instanceof Error);
  }
  a.isError = P, a.types.isNativeError = P;
  function S(te) {
    return typeof te == "function";
  }
  a.isFunction = S;
  function E(te) {
    return te === null || typeof te == "boolean" || typeof te == "number" || typeof te == "string" || typeof te == "symbol" || // ES6 symbol
    typeof te > "u";
  }
  a.isPrimitive = E, a.isBuffer = isBufferBrowser;
  function I(te) {
    return Object.prototype.toString.call(te);
  }
  function M(te) {
    return te < 10 ? "0" + te.toString(10) : te.toString(10);
  }
  var $ = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ];
  function U() {
    var te = /* @__PURE__ */ new Date(), me = [
      M(te.getHours()),
      M(te.getMinutes()),
      M(te.getSeconds())
    ].join(":");
    return [te.getDate(), $[te.getMonth()], me].join(" ");
  }
  a.log = function() {
    console.log("%s - %s", U(), a.format.apply(a, arguments));
  }, a.inherits = inherits_browserExports, a._extend = function(te, me) {
    if (!me || !q(me))
      return te;
    for (var Ce = Object.keys(me), De = Ce.length; De--; )
      te[Ce[De]] = me[Ce[De]];
    return te;
  };
  function Y(te, me) {
    return Object.prototype.hasOwnProperty.call(te, me);
  }
  var B = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
  a.promisify = function(me) {
    if (typeof me != "function")
      throw new TypeError('The "original" argument must be of type Function');
    if (B && me[B]) {
      var Ce = me[B];
      if (typeof Ce != "function")
        throw new TypeError('The "util.promisify.custom" argument must be of type Function');
      return Object.defineProperty(Ce, B, {
        value: Ce,
        enumerable: !1,
        writable: !1,
        configurable: !0
      }), Ce;
    }
    function Ce() {
      for (var De, ye, pe = new Promise(function(Ue, oe) {
        De = Ue, ye = oe;
      }), Me = [], Ne = 0; Ne < arguments.length; Ne++)
        Me.push(arguments[Ne]);
      Me.push(function(Ue, oe) {
        Ue ? ye(Ue) : De(oe);
      });
      try {
        me.apply(this, Me);
      } catch (Ue) {
        ye(Ue);
      }
      return pe;
    }
    return Object.setPrototypeOf(Ce, Object.getPrototypeOf(me)), B && Object.defineProperty(Ce, B, {
      value: Ce,
      enumerable: !1,
      writable: !1,
      configurable: !0
    }), Object.defineProperties(
      Ce,
      u(me)
    );
  }, a.promisify.custom = B;
  function T(te, me) {
    if (!te) {
      var Ce = new Error("Promise was rejected with a falsy value");
      Ce.reason = te, te = Ce;
    }
    return me(te);
  }
  function L(te) {
    if (typeof te != "function")
      throw new TypeError('The "original" argument must be of type Function');
    function me() {
      for (var Ce = [], De = 0; De < arguments.length; De++)
        Ce.push(arguments[De]);
      var ye = Ce.pop();
      if (typeof ye != "function")
        throw new TypeError("The last argument must be of type Function");
      var pe = this, Me = function() {
        return ye.apply(pe, arguments);
      };
      te.apply(this, Ce).then(
        function(Ne) {
          process$1.nextTick(Me.bind(null, null, Ne));
        },
        function(Ne) {
          process$1.nextTick(T.bind(null, Ne, Me));
        }
      );
    }
    return Object.setPrototypeOf(me, Object.getPrototypeOf(te)), Object.defineProperties(
      me,
      u(te)
    ), me;
  }
  a.callbackify = L;
})(util$4);
var buffer_list$2, hasRequiredBuffer_list$2;
function requireBuffer_list$2() {
  if (hasRequiredBuffer_list$2)
    return buffer_list$2;
  hasRequiredBuffer_list$2 = 1;
  function a(X, ne) {
    var Q = Object.keys(X);
    if (Object.getOwnPropertySymbols) {
      var ae = Object.getOwnPropertySymbols(X);
      ne && (ae = ae.filter(function(j) {
        return Object.getOwnPropertyDescriptor(X, j).enumerable;
      })), Q.push.apply(Q, ae);
    }
    return Q;
  }
  function u(X) {
    for (var ne = 1; ne < arguments.length; ne++) {
      var Q = arguments[ne] != null ? arguments[ne] : {};
      ne % 2 ? a(Object(Q), !0).forEach(function(ae) {
        c(X, ae, Q[ae]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(X, Object.getOwnPropertyDescriptors(Q)) : a(Object(Q)).forEach(function(ae) {
        Object.defineProperty(X, ae, Object.getOwnPropertyDescriptor(Q, ae));
      });
    }
    return X;
  }
  function c(X, ne, Q) {
    return ne = _(ne), ne in X ? Object.defineProperty(X, ne, { value: Q, enumerable: !0, configurable: !0, writable: !0 }) : X[ne] = Q, X;
  }
  function l(X, ne) {
    if (!(X instanceof ne))
      throw new TypeError("Cannot call a class as a function");
  }
  function v(X, ne) {
    for (var Q = 0; Q < ne.length; Q++) {
      var ae = ne[Q];
      ae.enumerable = ae.enumerable || !1, ae.configurable = !0, "value" in ae && (ae.writable = !0), Object.defineProperty(X, _(ae.key), ae);
    }
  }
  function p(X, ne, Q) {
    return ne && v(X.prototype, ne), Q && v(X, Q), Object.defineProperty(X, "prototype", { writable: !1 }), X;
  }
  function _(X) {
    var ne = k(X, "string");
    return typeof ne == "symbol" ? ne : String(ne);
  }
  function k(X, ne) {
    if (typeof X != "object" || X === null)
      return X;
    var Q = X[Symbol.toPrimitive];
    if (Q !== void 0) {
      var ae = Q.call(X, ne || "default");
      if (typeof ae != "object")
        return ae;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (ne === "string" ? String : Number)(X);
  }
  var O = require$$0$2, D = O.Buffer, F = util$4, H = F.inspect, Z = H && H.custom || "inspect";
  function ee(X, ne, Q) {
    D.prototype.copy.call(X, ne, Q);
  }
  return buffer_list$2 = /* @__PURE__ */ function() {
    function X() {
      l(this, X), this.head = null, this.tail = null, this.length = 0;
    }
    return p(X, [{
      key: "push",
      value: function(Q) {
        var ae = {
          data: Q,
          next: null
        };
        this.length > 0 ? this.tail.next = ae : this.head = ae, this.tail = ae, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(Q) {
        var ae = {
          data: Q,
          next: this.head
        };
        this.length === 0 && (this.tail = ae), this.head = ae, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var Q = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, Q;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(Q) {
        if (this.length === 0)
          return "";
        for (var ae = this.head, j = "" + ae.data; ae = ae.next; )
          j += Q + ae.data;
        return j;
      }
    }, {
      key: "concat",
      value: function(Q) {
        if (this.length === 0)
          return D.alloc(0);
        for (var ae = D.allocUnsafe(Q >>> 0), j = this.head, ue = 0; j; )
          ee(j.data, ae, ue), ue += j.data.length, j = j.next;
        return ae;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(Q, ae) {
        var j;
        return Q < this.head.data.length ? (j = this.head.data.slice(0, Q), this.head.data = this.head.data.slice(Q)) : Q === this.head.data.length ? j = this.shift() : j = ae ? this._getString(Q) : this._getBuffer(Q), j;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(Q) {
        var ae = this.head, j = 1, ue = ae.data;
        for (Q -= ue.length; ae = ae.next; ) {
          var he = ae.data, fe = Q > he.length ? he.length : Q;
          if (fe === he.length ? ue += he : ue += he.slice(0, Q), Q -= fe, Q === 0) {
            fe === he.length ? (++j, ae.next ? this.head = ae.next : this.head = this.tail = null) : (this.head = ae, ae.data = he.slice(fe));
            break;
          }
          ++j;
        }
        return this.length -= j, ue;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(Q) {
        var ae = D.allocUnsafe(Q), j = this.head, ue = 1;
        for (j.data.copy(ae), Q -= j.data.length; j = j.next; ) {
          var he = j.data, fe = Q > he.length ? he.length : Q;
          if (he.copy(ae, ae.length - Q, 0, fe), Q -= fe, Q === 0) {
            fe === he.length ? (++ue, j.next ? this.head = j.next : this.head = this.tail = null) : (this.head = j, j.data = he.slice(fe));
            break;
          }
          ++ue;
        }
        return this.length -= ue, ae;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: Z,
      value: function(Q, ae) {
        return H(this, u(u({}, ae), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), X;
  }(), buffer_list$2;
}
var destroy_1$2, hasRequiredDestroy;
function requireDestroy() {
  if (hasRequiredDestroy)
    return destroy_1$2;
  hasRequiredDestroy = 1;
  function a(_, k) {
    var O = this, D = this._readableState && this._readableState.destroyed, F = this._writableState && this._writableState.destroyed;
    return D || F ? (k ? k(_) : _ && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process$1.nextTick(v, this, _)) : process$1.nextTick(v, this, _)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(_ || null, function(H) {
      !k && H ? O._writableState ? O._writableState.errorEmitted ? process$1.nextTick(c, O) : (O._writableState.errorEmitted = !0, process$1.nextTick(u, O, H)) : process$1.nextTick(u, O, H) : k ? (process$1.nextTick(c, O), k(H)) : process$1.nextTick(c, O);
    }), this);
  }
  function u(_, k) {
    v(_, k), c(_);
  }
  function c(_) {
    _._writableState && !_._writableState.emitClose || _._readableState && !_._readableState.emitClose || _.emit("close");
  }
  function l() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function v(_, k) {
    _.emit("error", k);
  }
  function p(_, k) {
    var O = _._readableState, D = _._writableState;
    O && O.autoDestroy || D && D.autoDestroy ? _.destroy(k) : _.emit("error", k);
  }
  return destroy_1$2 = {
    destroy: a,
    undestroy: l,
    errorOrDestroy: p
  }, destroy_1$2;
}
var errorsBrowser$2 = {}, hasRequiredErrorsBrowser;
function requireErrorsBrowser() {
  if (hasRequiredErrorsBrowser)
    return errorsBrowser$2;
  hasRequiredErrorsBrowser = 1;
  function a(k, O) {
    k.prototype = Object.create(O.prototype), k.prototype.constructor = k, k.__proto__ = O;
  }
  var u = {};
  function c(k, O, D) {
    D || (D = Error);
    function F(Z, ee, X) {
      return typeof O == "string" ? O : O(Z, ee, X);
    }
    var H = /* @__PURE__ */ function(Z) {
      a(ee, Z);
      function ee(X, ne, Q) {
        return Z.call(this, F(X, ne, Q)) || this;
      }
      return ee;
    }(D);
    H.prototype.name = D.name, H.prototype.code = k, u[k] = H;
  }
  function l(k, O) {
    if (Array.isArray(k)) {
      var D = k.length;
      return k = k.map(function(F) {
        return String(F);
      }), D > 2 ? "one of ".concat(O, " ").concat(k.slice(0, D - 1).join(", "), ", or ") + k[D - 1] : D === 2 ? "one of ".concat(O, " ").concat(k[0], " or ").concat(k[1]) : "of ".concat(O, " ").concat(k[0]);
    } else
      return "of ".concat(O, " ").concat(String(k));
  }
  function v(k, O, D) {
    return k.substr(!D || D < 0 ? 0 : +D, O.length) === O;
  }
  function p(k, O, D) {
    return (D === void 0 || D > k.length) && (D = k.length), k.substring(D - O.length, D) === O;
  }
  function _(k, O, D) {
    return typeof D != "number" && (D = 0), D + O.length > k.length ? !1 : k.indexOf(O, D) !== -1;
  }
  return c("ERR_INVALID_OPT_VALUE", function(k, O) {
    return 'The value "' + O + '" is invalid for option "' + k + '"';
  }, TypeError), c("ERR_INVALID_ARG_TYPE", function(k, O, D) {
    var F;
    typeof O == "string" && v(O, "not ") ? (F = "must not be", O = O.replace(/^not /, "")) : F = "must be";
    var H;
    if (p(k, " argument"))
      H = "The ".concat(k, " ").concat(F, " ").concat(l(O, "type"));
    else {
      var Z = _(k, ".") ? "property" : "argument";
      H = 'The "'.concat(k, '" ').concat(Z, " ").concat(F, " ").concat(l(O, "type"));
    }
    return H += ". Received type ".concat(typeof D), H;
  }, TypeError), c("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), c("ERR_METHOD_NOT_IMPLEMENTED", function(k) {
    return "The " + k + " method is not implemented";
  }), c("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), c("ERR_STREAM_DESTROYED", function(k) {
    return "Cannot call " + k + " after a stream was destroyed";
  }), c("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), c("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), c("ERR_STREAM_WRITE_AFTER_END", "write after end"), c("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), c("ERR_UNKNOWN_ENCODING", function(k) {
    return "Unknown encoding: " + k;
  }, TypeError), c("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), errorsBrowser$2.codes = u, errorsBrowser$2;
}
var state$5, hasRequiredState;
function requireState() {
  if (hasRequiredState)
    return state$5;
  hasRequiredState = 1;
  var a = requireErrorsBrowser().codes.ERR_INVALID_OPT_VALUE;
  function u(l, v, p) {
    return l.highWaterMark != null ? l.highWaterMark : v ? l[p] : null;
  }
  function c(l, v, p, _) {
    var k = u(v, _, p);
    if (k != null) {
      if (!(isFinite(k) && Math.floor(k) === k) || k < 0) {
        var O = _ ? p : "highWaterMark";
        throw new a(O, k);
      }
      return Math.floor(k);
    }
    return l.objectMode ? 16 : 16 * 1024;
  }
  return state$5 = {
    getHighWaterMark: c
  }, state$5;
}
var browser$c = deprecate;
function deprecate(a, u) {
  if (config$1("noDeprecation"))
    return a;
  var c = !1;
  function l() {
    if (!c) {
      if (config$1("throwDeprecation"))
        throw new Error(u);
      config$1("traceDeprecation") ? console.trace(u) : console.warn(u), c = !0;
    }
    return a.apply(this, arguments);
  }
  return l;
}
function config$1(a) {
  try {
    if (!commonjsGlobal$1.localStorage)
      return !1;
  } catch {
    return !1;
  }
  var u = commonjsGlobal$1.localStorage[a];
  return u == null ? !1 : String(u).toLowerCase() === "true";
}
var _stream_writable$2, hasRequired_stream_writable$2;
function require_stream_writable$2() {
  if (hasRequired_stream_writable$2)
    return _stream_writable$2;
  hasRequired_stream_writable$2 = 1, _stream_writable$2 = Te;
  function a(ye) {
    var pe = this;
    this.next = null, this.entry = null, this.finish = function() {
      De(pe, ye);
    };
  }
  var u;
  Te.WritableState = be;
  var c = {
    deprecate: browser$c
  }, l = requireStreamBrowser(), v = require$$0$2.Buffer, p = (typeof commonjsGlobal$1 < "u" ? commonjsGlobal$1 : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function _(ye) {
    return v.from(ye);
  }
  function k(ye) {
    return v.isBuffer(ye) || ye instanceof p;
  }
  var O = requireDestroy(), D = requireState(), F = D.getHighWaterMark, H = requireErrorsBrowser().codes, Z = H.ERR_INVALID_ARG_TYPE, ee = H.ERR_METHOD_NOT_IMPLEMENTED, X = H.ERR_MULTIPLE_CALLBACK, ne = H.ERR_STREAM_CANNOT_PIPE, Q = H.ERR_STREAM_DESTROYED, ae = H.ERR_STREAM_NULL_VALUES, j = H.ERR_STREAM_WRITE_AFTER_END, ue = H.ERR_UNKNOWN_ENCODING, he = O.errorOrDestroy;
  inherits_browserExports(Te, l);
  function fe() {
  }
  function be(ye, pe, Me) {
    u = u || require_stream_duplex$2(), ye = ye || {}, typeof Me != "boolean" && (Me = pe instanceof u), this.objectMode = !!ye.objectMode, Me && (this.objectMode = this.objectMode || !!ye.writableObjectMode), this.highWaterMark = F(this, ye, "writableHighWaterMark", Me), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var Ne = ye.decodeStrings === !1;
    this.decodeStrings = !Ne, this.defaultEncoding = ye.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(Ue) {
      $(pe, Ue);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = ye.emitClose !== !1, this.autoDestroy = !!ye.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new a(this);
  }
  be.prototype.getBuffer = function() {
    for (var pe = this.bufferedRequest, Me = []; pe; )
      Me.push(pe), pe = pe.next;
    return Me;
  }, function() {
    try {
      Object.defineProperty(be.prototype, "buffer", {
        get: c.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var ke;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (ke = Function.prototype[Symbol.hasInstance], Object.defineProperty(Te, Symbol.hasInstance, {
    value: function(pe) {
      return ke.call(this, pe) ? !0 : this !== Te ? !1 : pe && pe._writableState instanceof be;
    }
  })) : ke = function(pe) {
    return pe instanceof this;
  };
  function Te(ye) {
    u = u || require_stream_duplex$2();
    var pe = this instanceof u;
    if (!pe && !ke.call(Te, this))
      return new Te(ye);
    this._writableState = new be(ye, this, pe), this.writable = !0, ye && (typeof ye.write == "function" && (this._write = ye.write), typeof ye.writev == "function" && (this._writev = ye.writev), typeof ye.destroy == "function" && (this._destroy = ye.destroy), typeof ye.final == "function" && (this._final = ye.final)), l.call(this);
  }
  Te.prototype.pipe = function() {
    he(this, new ne());
  };
  function q(ye, pe) {
    var Me = new j();
    he(ye, Me), process$1.nextTick(pe, Me);
  }
  function z(ye, pe, Me, Ne) {
    var Ue;
    return Me === null ? Ue = new ae() : typeof Me != "string" && !pe.objectMode && (Ue = new Z("chunk", ["string", "Buffer"], Me)), Ue ? (he(ye, Ue), process$1.nextTick(Ne, Ue), !1) : !0;
  }
  Te.prototype.write = function(ye, pe, Me) {
    var Ne = this._writableState, Ue = !1, oe = !Ne.objectMode && k(ye);
    return oe && !v.isBuffer(ye) && (ye = _(ye)), typeof pe == "function" && (Me = pe, pe = null), oe ? pe = "buffer" : pe || (pe = Ne.defaultEncoding), typeof Me != "function" && (Me = fe), Ne.ending ? q(this, Me) : (oe || z(this, Ne, ye, Me)) && (Ne.pendingcb++, Ue = S(this, Ne, oe, ye, pe, Me)), Ue;
  }, Te.prototype.cork = function() {
    this._writableState.corked++;
  }, Te.prototype.uncork = function() {
    var ye = this._writableState;
    ye.corked && (ye.corked--, !ye.writing && !ye.corked && !ye.bufferProcessing && ye.bufferedRequest && B(this, ye));
  }, Te.prototype.setDefaultEncoding = function(pe) {
    if (typeof pe == "string" && (pe = pe.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((pe + "").toLowerCase()) > -1))
      throw new ue(pe);
    return this._writableState.defaultEncoding = pe, this;
  }, Object.defineProperty(Te.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function P(ye, pe, Me) {
    return !ye.objectMode && ye.decodeStrings !== !1 && typeof pe == "string" && (pe = v.from(pe, Me)), pe;
  }
  Object.defineProperty(Te.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function S(ye, pe, Me, Ne, Ue, oe) {
    if (!Me) {
      var A = P(pe, Ne, Ue);
      Ne !== A && (Me = !0, Ue = "buffer", Ne = A);
    }
    var re = pe.objectMode ? 1 : Ne.length;
    pe.length += re;
    var le = pe.length < pe.highWaterMark;
    if (le || (pe.needDrain = !0), pe.writing || pe.corked) {
      var $e = pe.lastBufferedRequest;
      pe.lastBufferedRequest = {
        chunk: Ne,
        encoding: Ue,
        isBuf: Me,
        callback: oe,
        next: null
      }, $e ? $e.next = pe.lastBufferedRequest : pe.bufferedRequest = pe.lastBufferedRequest, pe.bufferedRequestCount += 1;
    } else
      E(ye, pe, !1, re, Ne, Ue, oe);
    return le;
  }
  function E(ye, pe, Me, Ne, Ue, oe, A) {
    pe.writelen = Ne, pe.writecb = A, pe.writing = !0, pe.sync = !0, pe.destroyed ? pe.onwrite(new Q("write")) : Me ? ye._writev(Ue, pe.onwrite) : ye._write(Ue, oe, pe.onwrite), pe.sync = !1;
  }
  function I(ye, pe, Me, Ne, Ue) {
    --pe.pendingcb, Me ? (process$1.nextTick(Ue, Ne), process$1.nextTick(me, ye, pe), ye._writableState.errorEmitted = !0, he(ye, Ne)) : (Ue(Ne), ye._writableState.errorEmitted = !0, he(ye, Ne), me(ye, pe));
  }
  function M(ye) {
    ye.writing = !1, ye.writecb = null, ye.length -= ye.writelen, ye.writelen = 0;
  }
  function $(ye, pe) {
    var Me = ye._writableState, Ne = Me.sync, Ue = Me.writecb;
    if (typeof Ue != "function")
      throw new X();
    if (M(Me), pe)
      I(ye, Me, Ne, pe, Ue);
    else {
      var oe = T(Me) || ye.destroyed;
      !oe && !Me.corked && !Me.bufferProcessing && Me.bufferedRequest && B(ye, Me), Ne ? process$1.nextTick(U, ye, Me, oe, Ue) : U(ye, Me, oe, Ue);
    }
  }
  function U(ye, pe, Me, Ne) {
    Me || Y(ye, pe), pe.pendingcb--, Ne(), me(ye, pe);
  }
  function Y(ye, pe) {
    pe.length === 0 && pe.needDrain && (pe.needDrain = !1, ye.emit("drain"));
  }
  function B(ye, pe) {
    pe.bufferProcessing = !0;
    var Me = pe.bufferedRequest;
    if (ye._writev && Me && Me.next) {
      var Ne = pe.bufferedRequestCount, Ue = new Array(Ne), oe = pe.corkedRequestsFree;
      oe.entry = Me;
      for (var A = 0, re = !0; Me; )
        Ue[A] = Me, Me.isBuf || (re = !1), Me = Me.next, A += 1;
      Ue.allBuffers = re, E(ye, pe, !0, pe.length, Ue, "", oe.finish), pe.pendingcb++, pe.lastBufferedRequest = null, oe.next ? (pe.corkedRequestsFree = oe.next, oe.next = null) : pe.corkedRequestsFree = new a(pe), pe.bufferedRequestCount = 0;
    } else {
      for (; Me; ) {
        var le = Me.chunk, $e = Me.encoding, Oe = Me.callback, Fe = pe.objectMode ? 1 : le.length;
        if (E(ye, pe, !1, Fe, le, $e, Oe), Me = Me.next, pe.bufferedRequestCount--, pe.writing)
          break;
      }
      Me === null && (pe.lastBufferedRequest = null);
    }
    pe.bufferedRequest = Me, pe.bufferProcessing = !1;
  }
  Te.prototype._write = function(ye, pe, Me) {
    Me(new ee("_write()"));
  }, Te.prototype._writev = null, Te.prototype.end = function(ye, pe, Me) {
    var Ne = this._writableState;
    return typeof ye == "function" ? (Me = ye, ye = null, pe = null) : typeof pe == "function" && (Me = pe, pe = null), ye != null && this.write(ye, pe), Ne.corked && (Ne.corked = 1, this.uncork()), Ne.ending || Ce(this, Ne, Me), this;
  }, Object.defineProperty(Te.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function T(ye) {
    return ye.ending && ye.length === 0 && ye.bufferedRequest === null && !ye.finished && !ye.writing;
  }
  function L(ye, pe) {
    ye._final(function(Me) {
      pe.pendingcb--, Me && he(ye, Me), pe.prefinished = !0, ye.emit("prefinish"), me(ye, pe);
    });
  }
  function te(ye, pe) {
    !pe.prefinished && !pe.finalCalled && (typeof ye._final == "function" && !pe.destroyed ? (pe.pendingcb++, pe.finalCalled = !0, process$1.nextTick(L, ye, pe)) : (pe.prefinished = !0, ye.emit("prefinish")));
  }
  function me(ye, pe) {
    var Me = T(pe);
    if (Me && (te(ye, pe), pe.pendingcb === 0 && (pe.finished = !0, ye.emit("finish"), pe.autoDestroy))) {
      var Ne = ye._readableState;
      (!Ne || Ne.autoDestroy && Ne.endEmitted) && ye.destroy();
    }
    return Me;
  }
  function Ce(ye, pe, Me) {
    pe.ending = !0, me(ye, pe), Me && (pe.finished ? process$1.nextTick(Me) : ye.once("finish", Me)), pe.ended = !0, ye.writable = !1;
  }
  function De(ye, pe, Me) {
    var Ne = ye.entry;
    for (ye.entry = null; Ne; ) {
      var Ue = Ne.callback;
      pe.pendingcb--, Ue(Me), Ne = Ne.next;
    }
    pe.corkedRequestsFree.next = ye;
  }
  return Object.defineProperty(Te.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(pe) {
      this._writableState && (this._writableState.destroyed = pe);
    }
  }), Te.prototype.destroy = O.destroy, Te.prototype._undestroy = O.undestroy, Te.prototype._destroy = function(ye, pe) {
    pe(ye);
  }, _stream_writable$2;
}
var _stream_duplex$2, hasRequired_stream_duplex$2;
function require_stream_duplex$2() {
  if (hasRequired_stream_duplex$2)
    return _stream_duplex$2;
  hasRequired_stream_duplex$2 = 1;
  var a = Object.keys || function(D) {
    var F = [];
    for (var H in D)
      F.push(H);
    return F;
  };
  _stream_duplex$2 = _;
  var u = require_stream_readable$2(), c = require_stream_writable$2();
  inherits_browserExports(_, u);
  for (var l = a(c.prototype), v = 0; v < l.length; v++) {
    var p = l[v];
    _.prototype[p] || (_.prototype[p] = c.prototype[p]);
  }
  function _(D) {
    if (!(this instanceof _))
      return new _(D);
    u.call(this, D), c.call(this, D), this.allowHalfOpen = !0, D && (D.readable === !1 && (this.readable = !1), D.writable === !1 && (this.writable = !1), D.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", k)));
  }
  Object.defineProperty(_.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(_.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(_.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function k() {
    this._writableState.ended || process$1.nextTick(O, this);
  }
  function O(D) {
    D.end();
  }
  return Object.defineProperty(_.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(F) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = F, this._writableState.destroyed = F);
    }
  }), _stream_duplex$2;
}
var string_decoder = {}, safeBuffer$3 = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(a, u) {
  var c = require$$0$2, l = c.Buffer;
  function v(_, k) {
    for (var O in _)
      k[O] = _[O];
  }
  l.from && l.alloc && l.allocUnsafe && l.allocUnsafeSlow ? a.exports = c : (v(c, u), u.Buffer = p);
  function p(_, k, O) {
    return l(_, k, O);
  }
  p.prototype = Object.create(l.prototype), v(l, p), p.from = function(_, k, O) {
    if (typeof _ == "number")
      throw new TypeError("Argument must not be a number");
    return l(_, k, O);
  }, p.alloc = function(_, k, O) {
    if (typeof _ != "number")
      throw new TypeError("Argument must be a number");
    var D = l(_);
    return k !== void 0 ? typeof O == "string" ? D.fill(k, O) : D.fill(k) : D.fill(0), D;
  }, p.allocUnsafe = function(_) {
    if (typeof _ != "number")
      throw new TypeError("Argument must be a number");
    return l(_);
  }, p.allocUnsafeSlow = function(_) {
    if (typeof _ != "number")
      throw new TypeError("Argument must be a number");
    return c.SlowBuffer(_);
  };
})(safeBuffer$3, safeBuffer$3.exports);
var safeBufferExports$2 = safeBuffer$3.exports, Buffer$L = safeBufferExports$2.Buffer, isEncoding = Buffer$L.isEncoding || function(a) {
  switch (a = "" + a, a && a.toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
    case "raw":
      return !0;
    default:
      return !1;
  }
};
function _normalizeEncoding(a) {
  if (!a)
    return "utf8";
  for (var u; ; )
    switch (a) {
      case "utf8":
      case "utf-8":
        return "utf8";
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return "utf16le";
      case "latin1":
      case "binary":
        return "latin1";
      case "base64":
      case "ascii":
      case "hex":
        return a;
      default:
        if (u)
          return;
        a = ("" + a).toLowerCase(), u = !0;
    }
}
function normalizeEncoding(a) {
  var u = _normalizeEncoding(a);
  if (typeof u != "string" && (Buffer$L.isEncoding === isEncoding || !isEncoding(a)))
    throw new Error("Unknown encoding: " + a);
  return u || a;
}
string_decoder.StringDecoder = StringDecoder$1;
function StringDecoder$1(a) {
  this.encoding = normalizeEncoding(a);
  var u;
  switch (this.encoding) {
    case "utf16le":
      this.text = utf16Text, this.end = utf16End, u = 4;
      break;
    case "utf8":
      this.fillLast = utf8FillLast, u = 4;
      break;
    case "base64":
      this.text = base64Text, this.end = base64End, u = 3;
      break;
    default:
      this.write = simpleWrite, this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0, this.lastTotal = 0, this.lastChar = Buffer$L.allocUnsafe(u);
}
StringDecoder$1.prototype.write = function(a) {
  if (a.length === 0)
    return "";
  var u, c;
  if (this.lastNeed) {
    if (u = this.fillLast(a), u === void 0)
      return "";
    c = this.lastNeed, this.lastNeed = 0;
  } else
    c = 0;
  return c < a.length ? u ? u + this.text(a, c) : this.text(a, c) : u || "";
};
StringDecoder$1.prototype.end = utf8End;
StringDecoder$1.prototype.text = utf8Text;
StringDecoder$1.prototype.fillLast = function(a) {
  if (this.lastNeed <= a.length)
    return a.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
  a.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, a.length), this.lastNeed -= a.length;
};
function utf8CheckByte(a) {
  return a <= 127 ? 0 : a >> 5 === 6 ? 2 : a >> 4 === 14 ? 3 : a >> 3 === 30 ? 4 : a >> 6 === 2 ? -1 : -2;
}
function utf8CheckIncomplete(a, u, c) {
  var l = u.length - 1;
  if (l < c)
    return 0;
  var v = utf8CheckByte(u[l]);
  return v >= 0 ? (v > 0 && (a.lastNeed = v - 1), v) : --l < c || v === -2 ? 0 : (v = utf8CheckByte(u[l]), v >= 0 ? (v > 0 && (a.lastNeed = v - 2), v) : --l < c || v === -2 ? 0 : (v = utf8CheckByte(u[l]), v >= 0 ? (v > 0 && (v === 2 ? v = 0 : a.lastNeed = v - 3), v) : 0));
}
function utf8CheckExtraBytes(a, u, c) {
  if ((u[0] & 192) !== 128)
    return a.lastNeed = 0, "�";
  if (a.lastNeed > 1 && u.length > 1) {
    if ((u[1] & 192) !== 128)
      return a.lastNeed = 1, "�";
    if (a.lastNeed > 2 && u.length > 2 && (u[2] & 192) !== 128)
      return a.lastNeed = 2, "�";
  }
}
function utf8FillLast(a) {
  var u = this.lastTotal - this.lastNeed, c = utf8CheckExtraBytes(this, a);
  if (c !== void 0)
    return c;
  if (this.lastNeed <= a.length)
    return a.copy(this.lastChar, u, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
  a.copy(this.lastChar, u, 0, a.length), this.lastNeed -= a.length;
}
function utf8Text(a, u) {
  var c = utf8CheckIncomplete(this, a, u);
  if (!this.lastNeed)
    return a.toString("utf8", u);
  this.lastTotal = c;
  var l = a.length - (c - this.lastNeed);
  return a.copy(this.lastChar, 0, l), a.toString("utf8", u, l);
}
function utf8End(a) {
  var u = a && a.length ? this.write(a) : "";
  return this.lastNeed ? u + "�" : u;
}
function utf16Text(a, u) {
  if ((a.length - u) % 2 === 0) {
    var c = a.toString("utf16le", u);
    if (c) {
      var l = c.charCodeAt(c.length - 1);
      if (l >= 55296 && l <= 56319)
        return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = a[a.length - 2], this.lastChar[1] = a[a.length - 1], c.slice(0, -1);
    }
    return c;
  }
  return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = a[a.length - 1], a.toString("utf16le", u, a.length - 1);
}
function utf16End(a) {
  var u = a && a.length ? this.write(a) : "";
  if (this.lastNeed) {
    var c = this.lastTotal - this.lastNeed;
    return u + this.lastChar.toString("utf16le", 0, c);
  }
  return u;
}
function base64Text(a, u) {
  var c = (a.length - u) % 3;
  return c === 0 ? a.toString("base64", u) : (this.lastNeed = 3 - c, this.lastTotal = 3, c === 1 ? this.lastChar[0] = a[a.length - 1] : (this.lastChar[0] = a[a.length - 2], this.lastChar[1] = a[a.length - 1]), a.toString("base64", u, a.length - c));
}
function base64End(a) {
  var u = a && a.length ? this.write(a) : "";
  return this.lastNeed ? u + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : u;
}
function simpleWrite(a) {
  return a.toString(this.encoding);
}
function simpleEnd(a) {
  return a && a.length ? this.write(a) : "";
}
var endOfStream$2, hasRequiredEndOfStream;
function requireEndOfStream() {
  if (hasRequiredEndOfStream)
    return endOfStream$2;
  hasRequiredEndOfStream = 1;
  var a = requireErrorsBrowser().codes.ERR_STREAM_PREMATURE_CLOSE;
  function u(p) {
    var _ = !1;
    return function() {
      if (!_) {
        _ = !0;
        for (var k = arguments.length, O = new Array(k), D = 0; D < k; D++)
          O[D] = arguments[D];
        p.apply(this, O);
      }
    };
  }
  function c() {
  }
  function l(p) {
    return p.setHeader && typeof p.abort == "function";
  }
  function v(p, _, k) {
    if (typeof _ == "function")
      return v(p, null, _);
    _ || (_ = {}), k = u(k || c);
    var O = _.readable || _.readable !== !1 && p.readable, D = _.writable || _.writable !== !1 && p.writable, F = function() {
      p.writable || Z();
    }, H = p._writableState && p._writableState.finished, Z = function() {
      D = !1, H = !0, O || k.call(p);
    }, ee = p._readableState && p._readableState.endEmitted, X = function() {
      O = !1, ee = !0, D || k.call(p);
    }, ne = function(ue) {
      k.call(p, ue);
    }, Q = function() {
      var ue;
      if (O && !ee)
        return (!p._readableState || !p._readableState.ended) && (ue = new a()), k.call(p, ue);
      if (D && !H)
        return (!p._writableState || !p._writableState.ended) && (ue = new a()), k.call(p, ue);
    }, ae = function() {
      p.req.on("finish", Z);
    };
    return l(p) ? (p.on("complete", Z), p.on("abort", Q), p.req ? ae() : p.on("request", ae)) : D && !p._writableState && (p.on("end", F), p.on("close", F)), p.on("end", X), p.on("finish", Z), _.error !== !1 && p.on("error", ne), p.on("close", Q), function() {
      p.removeListener("complete", Z), p.removeListener("abort", Q), p.removeListener("request", ae), p.req && p.req.removeListener("finish", Z), p.removeListener("end", F), p.removeListener("close", F), p.removeListener("finish", Z), p.removeListener("end", X), p.removeListener("error", ne), p.removeListener("close", Q);
    };
  }
  return endOfStream$2 = v, endOfStream$2;
}
var async_iterator$2, hasRequiredAsync_iterator$2;
function requireAsync_iterator$2() {
  if (hasRequiredAsync_iterator$2)
    return async_iterator$2;
  hasRequiredAsync_iterator$2 = 1;
  var a;
  function u(ue, he, fe) {
    return he = c(he), he in ue ? Object.defineProperty(ue, he, { value: fe, enumerable: !0, configurable: !0, writable: !0 }) : ue[he] = fe, ue;
  }
  function c(ue) {
    var he = l(ue, "string");
    return typeof he == "symbol" ? he : String(he);
  }
  function l(ue, he) {
    if (typeof ue != "object" || ue === null)
      return ue;
    var fe = ue[Symbol.toPrimitive];
    if (fe !== void 0) {
      var be = fe.call(ue, he || "default");
      if (typeof be != "object")
        return be;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (he === "string" ? String : Number)(ue);
  }
  var v = requireEndOfStream(), p = Symbol("lastResolve"), _ = Symbol("lastReject"), k = Symbol("error"), O = Symbol("ended"), D = Symbol("lastPromise"), F = Symbol("handlePromise"), H = Symbol("stream");
  function Z(ue, he) {
    return {
      value: ue,
      done: he
    };
  }
  function ee(ue) {
    var he = ue[p];
    if (he !== null) {
      var fe = ue[H].read();
      fe !== null && (ue[D] = null, ue[p] = null, ue[_] = null, he(Z(fe, !1)));
    }
  }
  function X(ue) {
    process$1.nextTick(ee, ue);
  }
  function ne(ue, he) {
    return function(fe, be) {
      ue.then(function() {
        if (he[O]) {
          fe(Z(void 0, !0));
          return;
        }
        he[F](fe, be);
      }, be);
    };
  }
  var Q = Object.getPrototypeOf(function() {
  }), ae = Object.setPrototypeOf((a = {
    get stream() {
      return this[H];
    },
    next: function() {
      var he = this, fe = this[k];
      if (fe !== null)
        return Promise.reject(fe);
      if (this[O])
        return Promise.resolve(Z(void 0, !0));
      if (this[H].destroyed)
        return new Promise(function(q, z) {
          process$1.nextTick(function() {
            he[k] ? z(he[k]) : q(Z(void 0, !0));
          });
        });
      var be = this[D], ke;
      if (be)
        ke = new Promise(ne(be, this));
      else {
        var Te = this[H].read();
        if (Te !== null)
          return Promise.resolve(Z(Te, !1));
        ke = new Promise(this[F]);
      }
      return this[D] = ke, ke;
    }
  }, u(a, Symbol.asyncIterator, function() {
    return this;
  }), u(a, "return", function() {
    var he = this;
    return new Promise(function(fe, be) {
      he[H].destroy(null, function(ke) {
        if (ke) {
          be(ke);
          return;
        }
        fe(Z(void 0, !0));
      });
    });
  }), a), Q), j = function(he) {
    var fe, be = Object.create(ae, (fe = {}, u(fe, H, {
      value: he,
      writable: !0
    }), u(fe, p, {
      value: null,
      writable: !0
    }), u(fe, _, {
      value: null,
      writable: !0
    }), u(fe, k, {
      value: null,
      writable: !0
    }), u(fe, O, {
      value: he._readableState.endEmitted,
      writable: !0
    }), u(fe, F, {
      value: function(Te, q) {
        var z = be[H].read();
        z ? (be[D] = null, be[p] = null, be[_] = null, Te(Z(z, !1))) : (be[p] = Te, be[_] = q);
      },
      writable: !0
    }), fe));
    return be[D] = null, v(he, function(ke) {
      if (ke && ke.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var Te = be[_];
        Te !== null && (be[D] = null, be[p] = null, be[_] = null, Te(ke)), be[k] = ke;
        return;
      }
      var q = be[p];
      q !== null && (be[D] = null, be[p] = null, be[_] = null, q(Z(void 0, !0))), be[O] = !0;
    }), he.on("readable", X.bind(null, be)), be;
  };
  return async_iterator$2 = j, async_iterator$2;
}
var fromBrowser$2, hasRequiredFromBrowser$2;
function requireFromBrowser$2() {
  return hasRequiredFromBrowser$2 || (hasRequiredFromBrowser$2 = 1, fromBrowser$2 = function() {
    throw new Error("Readable.from is not available in the browser");
  }), fromBrowser$2;
}
var _stream_readable$2, hasRequired_stream_readable$2;
function require_stream_readable$2() {
  if (hasRequired_stream_readable$2)
    return _stream_readable$2;
  hasRequired_stream_readable$2 = 1, _stream_readable$2 = q;
  var a;
  q.ReadableState = Te, eventsExports.EventEmitter;
  var u = function(A, re) {
    return A.listeners(re).length;
  }, c = requireStreamBrowser(), l = require$$0$2.Buffer, v = (typeof commonjsGlobal$1 < "u" ? commonjsGlobal$1 : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function p(oe) {
    return l.from(oe);
  }
  function _(oe) {
    return l.isBuffer(oe) || oe instanceof v;
  }
  var k = util$4, O;
  k && k.debuglog ? O = k.debuglog("stream") : O = function() {
  };
  var D = requireBuffer_list$2(), F = requireDestroy(), H = requireState(), Z = H.getHighWaterMark, ee = requireErrorsBrowser().codes, X = ee.ERR_INVALID_ARG_TYPE, ne = ee.ERR_STREAM_PUSH_AFTER_EOF, Q = ee.ERR_METHOD_NOT_IMPLEMENTED, ae = ee.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, j, ue, he;
  inherits_browserExports(q, c);
  var fe = F.errorOrDestroy, be = ["error", "close", "destroy", "pause", "resume"];
  function ke(oe, A, re) {
    if (typeof oe.prependListener == "function")
      return oe.prependListener(A, re);
    !oe._events || !oe._events[A] ? oe.on(A, re) : Array.isArray(oe._events[A]) ? oe._events[A].unshift(re) : oe._events[A] = [re, oe._events[A]];
  }
  function Te(oe, A, re) {
    a = a || require_stream_duplex$2(), oe = oe || {}, typeof re != "boolean" && (re = A instanceof a), this.objectMode = !!oe.objectMode, re && (this.objectMode = this.objectMode || !!oe.readableObjectMode), this.highWaterMark = Z(this, oe, "readableHighWaterMark", re), this.buffer = new D(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = oe.emitClose !== !1, this.autoDestroy = !!oe.autoDestroy, this.destroyed = !1, this.defaultEncoding = oe.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, oe.encoding && (j || (j = string_decoder.StringDecoder), this.decoder = new j(oe.encoding), this.encoding = oe.encoding);
  }
  function q(oe) {
    if (a = a || require_stream_duplex$2(), !(this instanceof q))
      return new q(oe);
    var A = this instanceof a;
    this._readableState = new Te(oe, this, A), this.readable = !0, oe && (typeof oe.read == "function" && (this._read = oe.read), typeof oe.destroy == "function" && (this._destroy = oe.destroy)), c.call(this);
  }
  Object.defineProperty(q.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(A) {
      this._readableState && (this._readableState.destroyed = A);
    }
  }), q.prototype.destroy = F.destroy, q.prototype._undestroy = F.undestroy, q.prototype._destroy = function(oe, A) {
    A(oe);
  }, q.prototype.push = function(oe, A) {
    var re = this._readableState, le;
    return re.objectMode ? le = !0 : typeof oe == "string" && (A = A || re.defaultEncoding, A !== re.encoding && (oe = l.from(oe, A), A = ""), le = !0), z(this, oe, A, !1, le);
  }, q.prototype.unshift = function(oe) {
    return z(this, oe, null, !0, !1);
  };
  function z(oe, A, re, le, $e) {
    O("readableAddChunk", A);
    var Oe = oe._readableState;
    if (A === null)
      Oe.reading = !1, $(oe, Oe);
    else {
      var Fe;
      if ($e || (Fe = S(Oe, A)), Fe)
        fe(oe, Fe);
      else if (Oe.objectMode || A && A.length > 0)
        if (typeof A != "string" && !Oe.objectMode && Object.getPrototypeOf(A) !== l.prototype && (A = p(A)), le)
          Oe.endEmitted ? fe(oe, new ae()) : P(oe, Oe, A, !0);
        else if (Oe.ended)
          fe(oe, new ne());
        else {
          if (Oe.destroyed)
            return !1;
          Oe.reading = !1, Oe.decoder && !re ? (A = Oe.decoder.write(A), Oe.objectMode || A.length !== 0 ? P(oe, Oe, A, !1) : B(oe, Oe)) : P(oe, Oe, A, !1);
        }
      else
        le || (Oe.reading = !1, B(oe, Oe));
    }
    return !Oe.ended && (Oe.length < Oe.highWaterMark || Oe.length === 0);
  }
  function P(oe, A, re, le) {
    A.flowing && A.length === 0 && !A.sync ? (A.awaitDrain = 0, oe.emit("data", re)) : (A.length += A.objectMode ? 1 : re.length, le ? A.buffer.unshift(re) : A.buffer.push(re), A.needReadable && U(oe)), B(oe, A);
  }
  function S(oe, A) {
    var re;
    return !_(A) && typeof A != "string" && A !== void 0 && !oe.objectMode && (re = new X("chunk", ["string", "Buffer", "Uint8Array"], A)), re;
  }
  q.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, q.prototype.setEncoding = function(oe) {
    j || (j = string_decoder.StringDecoder);
    var A = new j(oe);
    this._readableState.decoder = A, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var re = this._readableState.buffer.head, le = ""; re !== null; )
      le += A.write(re.data), re = re.next;
    return this._readableState.buffer.clear(), le !== "" && this._readableState.buffer.push(le), this._readableState.length = le.length, this;
  };
  var E = 1073741824;
  function I(oe) {
    return oe >= E ? oe = E : (oe--, oe |= oe >>> 1, oe |= oe >>> 2, oe |= oe >>> 4, oe |= oe >>> 8, oe |= oe >>> 16, oe++), oe;
  }
  function M(oe, A) {
    return oe <= 0 || A.length === 0 && A.ended ? 0 : A.objectMode ? 1 : oe !== oe ? A.flowing && A.length ? A.buffer.head.data.length : A.length : (oe > A.highWaterMark && (A.highWaterMark = I(oe)), oe <= A.length ? oe : A.ended ? A.length : (A.needReadable = !0, 0));
  }
  q.prototype.read = function(oe) {
    O("read", oe), oe = parseInt(oe, 10);
    var A = this._readableState, re = oe;
    if (oe !== 0 && (A.emittedReadable = !1), oe === 0 && A.needReadable && ((A.highWaterMark !== 0 ? A.length >= A.highWaterMark : A.length > 0) || A.ended))
      return O("read: emitReadable", A.length, A.ended), A.length === 0 && A.ended ? Me(this) : U(this), null;
    if (oe = M(oe, A), oe === 0 && A.ended)
      return A.length === 0 && Me(this), null;
    var le = A.needReadable;
    O("need readable", le), (A.length === 0 || A.length - oe < A.highWaterMark) && (le = !0, O("length less than watermark", le)), A.ended || A.reading ? (le = !1, O("reading or ended", le)) : le && (O("do read"), A.reading = !0, A.sync = !0, A.length === 0 && (A.needReadable = !0), this._read(A.highWaterMark), A.sync = !1, A.reading || (oe = M(re, A)));
    var $e;
    return oe > 0 ? $e = pe(oe, A) : $e = null, $e === null ? (A.needReadable = A.length <= A.highWaterMark, oe = 0) : (A.length -= oe, A.awaitDrain = 0), A.length === 0 && (A.ended || (A.needReadable = !0), re !== oe && A.ended && Me(this)), $e !== null && this.emit("data", $e), $e;
  };
  function $(oe, A) {
    if (O("onEofChunk"), !A.ended) {
      if (A.decoder) {
        var re = A.decoder.end();
        re && re.length && (A.buffer.push(re), A.length += A.objectMode ? 1 : re.length);
      }
      A.ended = !0, A.sync ? U(oe) : (A.needReadable = !1, A.emittedReadable || (A.emittedReadable = !0, Y(oe)));
    }
  }
  function U(oe) {
    var A = oe._readableState;
    O("emitReadable", A.needReadable, A.emittedReadable), A.needReadable = !1, A.emittedReadable || (O("emitReadable", A.flowing), A.emittedReadable = !0, process$1.nextTick(Y, oe));
  }
  function Y(oe) {
    var A = oe._readableState;
    O("emitReadable_", A.destroyed, A.length, A.ended), !A.destroyed && (A.length || A.ended) && (oe.emit("readable"), A.emittedReadable = !1), A.needReadable = !A.flowing && !A.ended && A.length <= A.highWaterMark, ye(oe);
  }
  function B(oe, A) {
    A.readingMore || (A.readingMore = !0, process$1.nextTick(T, oe, A));
  }
  function T(oe, A) {
    for (; !A.reading && !A.ended && (A.length < A.highWaterMark || A.flowing && A.length === 0); ) {
      var re = A.length;
      if (O("maybeReadMore read 0"), oe.read(0), re === A.length)
        break;
    }
    A.readingMore = !1;
  }
  q.prototype._read = function(oe) {
    fe(this, new Q("_read()"));
  }, q.prototype.pipe = function(oe, A) {
    var re = this, le = this._readableState;
    switch (le.pipesCount) {
      case 0:
        le.pipes = oe;
        break;
      case 1:
        le.pipes = [le.pipes, oe];
        break;
      default:
        le.pipes.push(oe);
        break;
    }
    le.pipesCount += 1, O("pipe count=%d opts=%j", le.pipesCount, A);
    var $e = (!A || A.end !== !1) && oe !== process$1.stdout && oe !== process$1.stderr, Oe = $e ? Ze : We;
    le.endEmitted ? process$1.nextTick(Oe) : re.once("end", Oe), oe.on("unpipe", Fe);
    function Fe(Ie, V) {
      O("onunpipe"), Ie === re && V && V.hasUnpiped === !1 && (V.hasUnpiped = !0, Xe());
    }
    function Ze() {
      O("onend"), oe.end();
    }
    var qe = L(re);
    oe.on("drain", qe);
    var yt = !1;
    function Xe() {
      O("cleanup"), oe.removeListener("close", ge), oe.removeListener("finish", we), oe.removeListener("drain", qe), oe.removeListener("error", J), oe.removeListener("unpipe", Fe), re.removeListener("end", Ze), re.removeListener("end", We), re.removeListener("data", Ge), yt = !0, le.awaitDrain && (!oe._writableState || oe._writableState.needDrain) && qe();
    }
    re.on("data", Ge);
    function Ge(Ie) {
      O("ondata");
      var V = oe.write(Ie);
      O("dest.write", V), V === !1 && ((le.pipesCount === 1 && le.pipes === oe || le.pipesCount > 1 && Ue(le.pipes, oe) !== -1) && !yt && (O("false write response, pause", le.awaitDrain), le.awaitDrain++), re.pause());
    }
    function J(Ie) {
      O("onerror", Ie), We(), oe.removeListener("error", J), u(oe, "error") === 0 && fe(oe, Ie);
    }
    ke(oe, "error", J);
    function ge() {
      oe.removeListener("finish", we), We();
    }
    oe.once("close", ge);
    function we() {
      O("onfinish"), oe.removeListener("close", ge), We();
    }
    oe.once("finish", we);
    function We() {
      O("unpipe"), re.unpipe(oe);
    }
    return oe.emit("pipe", re), le.flowing || (O("pipe resume"), re.resume()), oe;
  };
  function L(oe) {
    return function() {
      var re = oe._readableState;
      O("pipeOnDrain", re.awaitDrain), re.awaitDrain && re.awaitDrain--, re.awaitDrain === 0 && u(oe, "data") && (re.flowing = !0, ye(oe));
    };
  }
  q.prototype.unpipe = function(oe) {
    var A = this._readableState, re = {
      hasUnpiped: !1
    };
    if (A.pipesCount === 0)
      return this;
    if (A.pipesCount === 1)
      return oe && oe !== A.pipes ? this : (oe || (oe = A.pipes), A.pipes = null, A.pipesCount = 0, A.flowing = !1, oe && oe.emit("unpipe", this, re), this);
    if (!oe) {
      var le = A.pipes, $e = A.pipesCount;
      A.pipes = null, A.pipesCount = 0, A.flowing = !1;
      for (var Oe = 0; Oe < $e; Oe++)
        le[Oe].emit("unpipe", this, {
          hasUnpiped: !1
        });
      return this;
    }
    var Fe = Ue(A.pipes, oe);
    return Fe === -1 ? this : (A.pipes.splice(Fe, 1), A.pipesCount -= 1, A.pipesCount === 1 && (A.pipes = A.pipes[0]), oe.emit("unpipe", this, re), this);
  }, q.prototype.on = function(oe, A) {
    var re = c.prototype.on.call(this, oe, A), le = this._readableState;
    return oe === "data" ? (le.readableListening = this.listenerCount("readable") > 0, le.flowing !== !1 && this.resume()) : oe === "readable" && !le.endEmitted && !le.readableListening && (le.readableListening = le.needReadable = !0, le.flowing = !1, le.emittedReadable = !1, O("on readable", le.length, le.reading), le.length ? U(this) : le.reading || process$1.nextTick(me, this)), re;
  }, q.prototype.addListener = q.prototype.on, q.prototype.removeListener = function(oe, A) {
    var re = c.prototype.removeListener.call(this, oe, A);
    return oe === "readable" && process$1.nextTick(te, this), re;
  }, q.prototype.removeAllListeners = function(oe) {
    var A = c.prototype.removeAllListeners.apply(this, arguments);
    return (oe === "readable" || oe === void 0) && process$1.nextTick(te, this), A;
  };
  function te(oe) {
    var A = oe._readableState;
    A.readableListening = oe.listenerCount("readable") > 0, A.resumeScheduled && !A.paused ? A.flowing = !0 : oe.listenerCount("data") > 0 && oe.resume();
  }
  function me(oe) {
    O("readable nexttick read 0"), oe.read(0);
  }
  q.prototype.resume = function() {
    var oe = this._readableState;
    return oe.flowing || (O("resume"), oe.flowing = !oe.readableListening, Ce(this, oe)), oe.paused = !1, this;
  };
  function Ce(oe, A) {
    A.resumeScheduled || (A.resumeScheduled = !0, process$1.nextTick(De, oe, A));
  }
  function De(oe, A) {
    O("resume", A.reading), A.reading || oe.read(0), A.resumeScheduled = !1, oe.emit("resume"), ye(oe), A.flowing && !A.reading && oe.read(0);
  }
  q.prototype.pause = function() {
    return O("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (O("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function ye(oe) {
    var A = oe._readableState;
    for (O("flow", A.flowing); A.flowing && oe.read() !== null; )
      ;
  }
  q.prototype.wrap = function(oe) {
    var A = this, re = this._readableState, le = !1;
    oe.on("end", function() {
      if (O("wrapped end"), re.decoder && !re.ended) {
        var Fe = re.decoder.end();
        Fe && Fe.length && A.push(Fe);
      }
      A.push(null);
    }), oe.on("data", function(Fe) {
      if (O("wrapped data"), re.decoder && (Fe = re.decoder.write(Fe)), !(re.objectMode && Fe == null) && !(!re.objectMode && (!Fe || !Fe.length))) {
        var Ze = A.push(Fe);
        Ze || (le = !0, oe.pause());
      }
    });
    for (var $e in oe)
      this[$e] === void 0 && typeof oe[$e] == "function" && (this[$e] = /* @__PURE__ */ function(Ze) {
        return function() {
          return oe[Ze].apply(oe, arguments);
        };
      }($e));
    for (var Oe = 0; Oe < be.length; Oe++)
      oe.on(be[Oe], this.emit.bind(this, be[Oe]));
    return this._read = function(Fe) {
      O("wrapped _read", Fe), le && (le = !1, oe.resume());
    }, this;
  }, typeof Symbol == "function" && (q.prototype[Symbol.asyncIterator] = function() {
    return ue === void 0 && (ue = requireAsync_iterator$2()), ue(this);
  }), Object.defineProperty(q.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(q.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(q.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(A) {
      this._readableState && (this._readableState.flowing = A);
    }
  }), q._fromList = pe, Object.defineProperty(q.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function pe(oe, A) {
    if (A.length === 0)
      return null;
    var re;
    return A.objectMode ? re = A.buffer.shift() : !oe || oe >= A.length ? (A.decoder ? re = A.buffer.join("") : A.buffer.length === 1 ? re = A.buffer.first() : re = A.buffer.concat(A.length), A.buffer.clear()) : re = A.buffer.consume(oe, A.decoder), re;
  }
  function Me(oe) {
    var A = oe._readableState;
    O("endReadable", A.endEmitted), A.endEmitted || (A.ended = !0, process$1.nextTick(Ne, A, oe));
  }
  function Ne(oe, A) {
    if (O("endReadableNT", oe.endEmitted, oe.length), !oe.endEmitted && oe.length === 0 && (oe.endEmitted = !0, A.readable = !1, A.emit("end"), oe.autoDestroy)) {
      var re = A._writableState;
      (!re || re.autoDestroy && re.finished) && A.destroy();
    }
  }
  typeof Symbol == "function" && (q.from = function(oe, A) {
    return he === void 0 && (he = requireFromBrowser$2()), he(q, oe, A);
  });
  function Ue(oe, A) {
    for (var re = 0, le = oe.length; re < le; re++)
      if (oe[re] === A)
        return re;
    return -1;
  }
  return _stream_readable$2;
}
var _stream_transform$2, hasRequired_stream_transform;
function require_stream_transform() {
  if (hasRequired_stream_transform)
    return _stream_transform$2;
  hasRequired_stream_transform = 1, _stream_transform$2 = k;
  var a = requireErrorsBrowser().codes, u = a.ERR_METHOD_NOT_IMPLEMENTED, c = a.ERR_MULTIPLE_CALLBACK, l = a.ERR_TRANSFORM_ALREADY_TRANSFORMING, v = a.ERR_TRANSFORM_WITH_LENGTH_0, p = require_stream_duplex$2();
  inherits_browserExports(k, p);
  function _(F, H) {
    var Z = this._transformState;
    Z.transforming = !1;
    var ee = Z.writecb;
    if (ee === null)
      return this.emit("error", new c());
    Z.writechunk = null, Z.writecb = null, H != null && this.push(H), ee(F);
    var X = this._readableState;
    X.reading = !1, (X.needReadable || X.length < X.highWaterMark) && this._read(X.highWaterMark);
  }
  function k(F) {
    if (!(this instanceof k))
      return new k(F);
    p.call(this, F), this._transformState = {
      afterTransform: _.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, F && (typeof F.transform == "function" && (this._transform = F.transform), typeof F.flush == "function" && (this._flush = F.flush)), this.on("prefinish", O);
  }
  function O() {
    var F = this;
    typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(H, Z) {
      D(F, H, Z);
    }) : D(this, null, null);
  }
  k.prototype.push = function(F, H) {
    return this._transformState.needTransform = !1, p.prototype.push.call(this, F, H);
  }, k.prototype._transform = function(F, H, Z) {
    Z(new u("_transform()"));
  }, k.prototype._write = function(F, H, Z) {
    var ee = this._transformState;
    if (ee.writecb = Z, ee.writechunk = F, ee.writeencoding = H, !ee.transforming) {
      var X = this._readableState;
      (ee.needTransform || X.needReadable || X.length < X.highWaterMark) && this._read(X.highWaterMark);
    }
  }, k.prototype._read = function(F) {
    var H = this._transformState;
    H.writechunk !== null && !H.transforming ? (H.transforming = !0, this._transform(H.writechunk, H.writeencoding, H.afterTransform)) : H.needTransform = !0;
  }, k.prototype._destroy = function(F, H) {
    p.prototype._destroy.call(this, F, function(Z) {
      H(Z);
    });
  };
  function D(F, H, Z) {
    if (H)
      return F.emit("error", H);
    if (Z != null && F.push(Z), F._writableState.length)
      throw new v();
    if (F._transformState.transforming)
      throw new l();
    return F.push(null);
  }
  return _stream_transform$2;
}
var _stream_passthrough$2, hasRequired_stream_passthrough;
function require_stream_passthrough() {
  if (hasRequired_stream_passthrough)
    return _stream_passthrough$2;
  hasRequired_stream_passthrough = 1, _stream_passthrough$2 = u;
  var a = require_stream_transform();
  inherits_browserExports(u, a);
  function u(c) {
    if (!(this instanceof u))
      return new u(c);
    a.call(this, c);
  }
  return u.prototype._transform = function(c, l, v) {
    v(null, c);
  }, _stream_passthrough$2;
}
var pipeline_1$2, hasRequiredPipeline;
function requirePipeline() {
  if (hasRequiredPipeline)
    return pipeline_1$2;
  hasRequiredPipeline = 1;
  var a;
  function u(Z) {
    var ee = !1;
    return function() {
      ee || (ee = !0, Z.apply(void 0, arguments));
    };
  }
  var c = requireErrorsBrowser().codes, l = c.ERR_MISSING_ARGS, v = c.ERR_STREAM_DESTROYED;
  function p(Z) {
    if (Z)
      throw Z;
  }
  function _(Z) {
    return Z.setHeader && typeof Z.abort == "function";
  }
  function k(Z, ee, X, ne) {
    ne = u(ne);
    var Q = !1;
    Z.on("close", function() {
      Q = !0;
    }), a === void 0 && (a = requireEndOfStream()), a(Z, {
      readable: ee,
      writable: X
    }, function(j) {
      if (j)
        return ne(j);
      Q = !0, ne();
    });
    var ae = !1;
    return function(j) {
      if (!Q && !ae) {
        if (ae = !0, _(Z))
          return Z.abort();
        if (typeof Z.destroy == "function")
          return Z.destroy();
        ne(j || new v("pipe"));
      }
    };
  }
  function O(Z) {
    Z();
  }
  function D(Z, ee) {
    return Z.pipe(ee);
  }
  function F(Z) {
    return !Z.length || typeof Z[Z.length - 1] != "function" ? p : Z.pop();
  }
  function H() {
    for (var Z = arguments.length, ee = new Array(Z), X = 0; X < Z; X++)
      ee[X] = arguments[X];
    var ne = F(ee);
    if (Array.isArray(ee[0]) && (ee = ee[0]), ee.length < 2)
      throw new l("streams");
    var Q, ae = ee.map(function(j, ue) {
      var he = ue < ee.length - 1, fe = ue > 0;
      return k(j, he, fe, function(be) {
        Q || (Q = be), be && ae.forEach(O), !he && (ae.forEach(O), ne(Q));
      });
    });
    return ee.reduce(D);
  }
  return pipeline_1$2 = H, pipeline_1$2;
}
var streamBrowserify = Stream$3, EE = eventsExports.EventEmitter, inherits$v = inherits_browserExports;
inherits$v(Stream$3, EE);
Stream$3.Readable = require_stream_readable$2();
Stream$3.Writable = require_stream_writable$2();
Stream$3.Duplex = require_stream_duplex$2();
Stream$3.Transform = require_stream_transform();
Stream$3.PassThrough = require_stream_passthrough();
Stream$3.finished = requireEndOfStream();
Stream$3.pipeline = requirePipeline();
Stream$3.Stream = Stream$3;
function Stream$3() {
  EE.call(this);
}
Stream$3.prototype.pipe = function(a, u) {
  var c = this;
  function l(F) {
    a.writable && a.write(F) === !1 && c.pause && c.pause();
  }
  c.on("data", l);
  function v() {
    c.readable && c.resume && c.resume();
  }
  a.on("drain", v), !a._isStdio && (!u || u.end !== !1) && (c.on("end", _), c.on("close", k));
  var p = !1;
  function _() {
    p || (p = !0, a.end());
  }
  function k() {
    p || (p = !0, typeof a.destroy == "function" && a.destroy());
  }
  function O(F) {
    if (D(), EE.listenerCount(this, "error") === 0)
      throw F;
  }
  c.on("error", O), a.on("error", O);
  function D() {
    c.removeListener("data", l), a.removeListener("drain", v), c.removeListener("end", _), c.removeListener("close", k), c.removeListener("error", O), a.removeListener("error", O), c.removeListener("end", D), c.removeListener("close", D), a.removeListener("close", D);
  }
  return c.on("end", D), c.on("close", D), a.on("close", D), a.emit("pipe", c), a;
};
var Buffer$K = safeBufferExports$3.Buffer, Stream$2 = streamBrowserify, util$3 = util$4;
function DataStream$2(a) {
  if (this.buffer = null, this.writable = !0, this.readable = !0, !a)
    return this.buffer = Buffer$K.alloc(0), this;
  if (typeof a.pipe == "function")
    return this.buffer = Buffer$K.alloc(0), a.pipe(this), this;
  if (a.length || typeof a == "object")
    return this.buffer = a, this.writable = !1, process$1.nextTick((function() {
      this.emit("end", a), this.readable = !1, this.emit("close");
    }).bind(this)), this;
  throw new TypeError("Unexpected data type (" + typeof a + ")");
}
util$3.inherits(DataStream$2, Stream$2);
DataStream$2.prototype.write = function a(u) {
  this.buffer = Buffer$K.concat([this.buffer, Buffer$K.from(u)]), this.emit("data", u);
};
DataStream$2.prototype.end = function a(u) {
  u && this.write(u), this.emit("end", u), this.emit("close"), this.writable = !1, this.readable = !1;
};
var dataStream = DataStream$2, Buffer$J = require$$0$2.Buffer, SlowBuffer = require$$0$2.SlowBuffer, bufferEqualConstantTime = bufferEq;
function bufferEq(a, u) {
  if (!Buffer$J.isBuffer(a) || !Buffer$J.isBuffer(u) || a.length !== u.length)
    return !1;
  for (var c = 0, l = 0; l < a.length; l++)
    c |= a[l] ^ u[l];
  return c === 0;
}
bufferEq.install = function() {
  Buffer$J.prototype.equal = SlowBuffer.prototype.equal = function(u) {
    return bufferEq(this, u);
  };
};
var origBufEqual = Buffer$J.prototype.equal, origSlowBufEqual = SlowBuffer.prototype.equal;
bufferEq.restore = function() {
  Buffer$J.prototype.equal = origBufEqual, SlowBuffer.prototype.equal = origSlowBufEqual;
};
var cryptoBrowserify = {}, browser$b = { exports: {} }, MAX_BYTES = 65536, MAX_UINT32 = 4294967295;
function oldBrowser$1() {
  throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
}
var Buffer$I = safeBufferExports$3.Buffer, crypto$3 = commonjsGlobal$1.crypto || commonjsGlobal$1.msCrypto;
crypto$3 && crypto$3.getRandomValues ? browser$b.exports = randomBytes$2 : browser$b.exports = oldBrowser$1;
function randomBytes$2(a, u) {
  if (a > MAX_UINT32)
    throw new RangeError("requested too many random bytes");
  var c = Buffer$I.allocUnsafe(a);
  if (a > 0)
    if (a > MAX_BYTES)
      for (var l = 0; l < a; l += MAX_BYTES)
        crypto$3.getRandomValues(c.slice(l, l + MAX_BYTES));
    else
      crypto$3.getRandomValues(c);
  return typeof u == "function" ? process$1.nextTick(function() {
    u(null, c);
  }) : c;
}
var browserExports = browser$b.exports, safeBuffer$2 = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(a, u) {
  var c = require$$0$2, l = c.Buffer;
  function v(_, k) {
    for (var O in _)
      k[O] = _[O];
  }
  l.from && l.alloc && l.allocUnsafe && l.allocUnsafeSlow ? a.exports = c : (v(c, u), u.Buffer = p);
  function p(_, k, O) {
    return l(_, k, O);
  }
  p.prototype = Object.create(l.prototype), v(l, p), p.from = function(_, k, O) {
    if (typeof _ == "number")
      throw new TypeError("Argument must not be a number");
    return l(_, k, O);
  }, p.alloc = function(_, k, O) {
    if (typeof _ != "number")
      throw new TypeError("Argument must be a number");
    var D = l(_);
    return k !== void 0 ? typeof O == "string" ? D.fill(k, O) : D.fill(k) : D.fill(0), D;
  }, p.allocUnsafe = function(_) {
    if (typeof _ != "number")
      throw new TypeError("Argument must be a number");
    return l(_);
  }, p.allocUnsafeSlow = function(_) {
    if (typeof _ != "number")
      throw new TypeError("Argument must be a number");
    return c.SlowBuffer(_);
  };
})(safeBuffer$2, safeBuffer$2.exports);
var safeBufferExports$1 = safeBuffer$2.exports, readableBrowser$1 = { exports: {} }, streamBrowser$1 = eventsExports.EventEmitter, buffer_list$1, hasRequiredBuffer_list$1;
function requireBuffer_list$1() {
  if (hasRequiredBuffer_list$1)
    return buffer_list$1;
  hasRequiredBuffer_list$1 = 1;
  function a(X, ne) {
    var Q = Object.keys(X);
    if (Object.getOwnPropertySymbols) {
      var ae = Object.getOwnPropertySymbols(X);
      ne && (ae = ae.filter(function(j) {
        return Object.getOwnPropertyDescriptor(X, j).enumerable;
      })), Q.push.apply(Q, ae);
    }
    return Q;
  }
  function u(X) {
    for (var ne = 1; ne < arguments.length; ne++) {
      var Q = arguments[ne] != null ? arguments[ne] : {};
      ne % 2 ? a(Object(Q), !0).forEach(function(ae) {
        c(X, ae, Q[ae]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(X, Object.getOwnPropertyDescriptors(Q)) : a(Object(Q)).forEach(function(ae) {
        Object.defineProperty(X, ae, Object.getOwnPropertyDescriptor(Q, ae));
      });
    }
    return X;
  }
  function c(X, ne, Q) {
    return ne = _(ne), ne in X ? Object.defineProperty(X, ne, { value: Q, enumerable: !0, configurable: !0, writable: !0 }) : X[ne] = Q, X;
  }
  function l(X, ne) {
    if (!(X instanceof ne))
      throw new TypeError("Cannot call a class as a function");
  }
  function v(X, ne) {
    for (var Q = 0; Q < ne.length; Q++) {
      var ae = ne[Q];
      ae.enumerable = ae.enumerable || !1, ae.configurable = !0, "value" in ae && (ae.writable = !0), Object.defineProperty(X, _(ae.key), ae);
    }
  }
  function p(X, ne, Q) {
    return ne && v(X.prototype, ne), Q && v(X, Q), Object.defineProperty(X, "prototype", { writable: !1 }), X;
  }
  function _(X) {
    var ne = k(X, "string");
    return typeof ne == "symbol" ? ne : String(ne);
  }
  function k(X, ne) {
    if (typeof X != "object" || X === null)
      return X;
    var Q = X[Symbol.toPrimitive];
    if (Q !== void 0) {
      var ae = Q.call(X, ne || "default");
      if (typeof ae != "object")
        return ae;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (ne === "string" ? String : Number)(X);
  }
  var O = require$$0$2, D = O.Buffer, F = util$4, H = F.inspect, Z = H && H.custom || "inspect";
  function ee(X, ne, Q) {
    D.prototype.copy.call(X, ne, Q);
  }
  return buffer_list$1 = /* @__PURE__ */ function() {
    function X() {
      l(this, X), this.head = null, this.tail = null, this.length = 0;
    }
    return p(X, [{
      key: "push",
      value: function(Q) {
        var ae = {
          data: Q,
          next: null
        };
        this.length > 0 ? this.tail.next = ae : this.head = ae, this.tail = ae, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(Q) {
        var ae = {
          data: Q,
          next: this.head
        };
        this.length === 0 && (this.tail = ae), this.head = ae, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var Q = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, Q;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(Q) {
        if (this.length === 0)
          return "";
        for (var ae = this.head, j = "" + ae.data; ae = ae.next; )
          j += Q + ae.data;
        return j;
      }
    }, {
      key: "concat",
      value: function(Q) {
        if (this.length === 0)
          return D.alloc(0);
        for (var ae = D.allocUnsafe(Q >>> 0), j = this.head, ue = 0; j; )
          ee(j.data, ae, ue), ue += j.data.length, j = j.next;
        return ae;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(Q, ae) {
        var j;
        return Q < this.head.data.length ? (j = this.head.data.slice(0, Q), this.head.data = this.head.data.slice(Q)) : Q === this.head.data.length ? j = this.shift() : j = ae ? this._getString(Q) : this._getBuffer(Q), j;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(Q) {
        var ae = this.head, j = 1, ue = ae.data;
        for (Q -= ue.length; ae = ae.next; ) {
          var he = ae.data, fe = Q > he.length ? he.length : Q;
          if (fe === he.length ? ue += he : ue += he.slice(0, Q), Q -= fe, Q === 0) {
            fe === he.length ? (++j, ae.next ? this.head = ae.next : this.head = this.tail = null) : (this.head = ae, ae.data = he.slice(fe));
            break;
          }
          ++j;
        }
        return this.length -= j, ue;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(Q) {
        var ae = D.allocUnsafe(Q), j = this.head, ue = 1;
        for (j.data.copy(ae), Q -= j.data.length; j = j.next; ) {
          var he = j.data, fe = Q > he.length ? he.length : Q;
          if (he.copy(ae, ae.length - Q, 0, fe), Q -= fe, Q === 0) {
            fe === he.length ? (++ue, j.next ? this.head = j.next : this.head = this.tail = null) : (this.head = j, j.data = he.slice(fe));
            break;
          }
          ++ue;
        }
        return this.length -= ue, ae;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: Z,
      value: function(Q, ae) {
        return H(this, u(u({}, ae), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), X;
  }(), buffer_list$1;
}
function destroy$1(a, u) {
  var c = this, l = this._readableState && this._readableState.destroyed, v = this._writableState && this._writableState.destroyed;
  return l || v ? (u ? u(a) : a && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process$1.nextTick(emitErrorNT$1, this, a)) : process$1.nextTick(emitErrorNT$1, this, a)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(a || null, function(p) {
    !u && p ? c._writableState ? c._writableState.errorEmitted ? process$1.nextTick(emitCloseNT$1, c) : (c._writableState.errorEmitted = !0, process$1.nextTick(emitErrorAndCloseNT$1, c, p)) : process$1.nextTick(emitErrorAndCloseNT$1, c, p) : u ? (process$1.nextTick(emitCloseNT$1, c), u(p)) : process$1.nextTick(emitCloseNT$1, c);
  }), this);
}
function emitErrorAndCloseNT$1(a, u) {
  emitErrorNT$1(a, u), emitCloseNT$1(a);
}
function emitCloseNT$1(a) {
  a._writableState && !a._writableState.emitClose || a._readableState && !a._readableState.emitClose || a.emit("close");
}
function undestroy$1() {
  this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
}
function emitErrorNT$1(a, u) {
  a.emit("error", u);
}
function errorOrDestroy$1(a, u) {
  var c = a._readableState, l = a._writableState;
  c && c.autoDestroy || l && l.autoDestroy ? a.destroy(u) : a.emit("error", u);
}
var destroy_1$1 = {
  destroy: destroy$1,
  undestroy: undestroy$1,
  errorOrDestroy: errorOrDestroy$1
}, errorsBrowser$1 = {};
function _inheritsLoose$2(a, u) {
  a.prototype = Object.create(u.prototype), a.prototype.constructor = a, a.__proto__ = u;
}
var codes$1 = {};
function createErrorType$1(a, u, c) {
  c || (c = Error);
  function l(p, _, k) {
    return typeof u == "string" ? u : u(p, _, k);
  }
  var v = /* @__PURE__ */ function(p) {
    _inheritsLoose$2(_, p);
    function _(k, O, D) {
      return p.call(this, l(k, O, D)) || this;
    }
    return _;
  }(c);
  v.prototype.name = c.name, v.prototype.code = a, codes$1[a] = v;
}
function oneOf$1(a, u) {
  if (Array.isArray(a)) {
    var c = a.length;
    return a = a.map(function(l) {
      return String(l);
    }), c > 2 ? "one of ".concat(u, " ").concat(a.slice(0, c - 1).join(", "), ", or ") + a[c - 1] : c === 2 ? "one of ".concat(u, " ").concat(a[0], " or ").concat(a[1]) : "of ".concat(u, " ").concat(a[0]);
  } else
    return "of ".concat(u, " ").concat(String(a));
}
function startsWith$1(a, u, c) {
  return a.substr(!c || c < 0 ? 0 : +c, u.length) === u;
}
function endsWith$1(a, u, c) {
  return (c === void 0 || c > a.length) && (c = a.length), a.substring(c - u.length, c) === u;
}
function includes$3(a, u, c) {
  return typeof c != "number" && (c = 0), c + u.length > a.length ? !1 : a.indexOf(u, c) !== -1;
}
createErrorType$1("ERR_INVALID_OPT_VALUE", function(a, u) {
  return 'The value "' + u + '" is invalid for option "' + a + '"';
}, TypeError);
createErrorType$1("ERR_INVALID_ARG_TYPE", function(a, u, c) {
  var l;
  typeof u == "string" && startsWith$1(u, "not ") ? (l = "must not be", u = u.replace(/^not /, "")) : l = "must be";
  var v;
  if (endsWith$1(a, " argument"))
    v = "The ".concat(a, " ").concat(l, " ").concat(oneOf$1(u, "type"));
  else {
    var p = includes$3(a, ".") ? "property" : "argument";
    v = 'The "'.concat(a, '" ').concat(p, " ").concat(l, " ").concat(oneOf$1(u, "type"));
  }
  return v += ". Received type ".concat(typeof c), v;
}, TypeError);
createErrorType$1("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
createErrorType$1("ERR_METHOD_NOT_IMPLEMENTED", function(a) {
  return "The " + a + " method is not implemented";
});
createErrorType$1("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
createErrorType$1("ERR_STREAM_DESTROYED", function(a) {
  return "Cannot call " + a + " after a stream was destroyed";
});
createErrorType$1("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
createErrorType$1("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
createErrorType$1("ERR_STREAM_WRITE_AFTER_END", "write after end");
createErrorType$1("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
createErrorType$1("ERR_UNKNOWN_ENCODING", function(a) {
  return "Unknown encoding: " + a;
}, TypeError);
createErrorType$1("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
errorsBrowser$1.codes = codes$1;
var ERR_INVALID_OPT_VALUE$1 = errorsBrowser$1.codes.ERR_INVALID_OPT_VALUE;
function highWaterMarkFrom$1(a, u, c) {
  return a.highWaterMark != null ? a.highWaterMark : u ? a[c] : null;
}
function getHighWaterMark$1(a, u, c, l) {
  var v = highWaterMarkFrom$1(u, l, c);
  if (v != null) {
    if (!(isFinite(v) && Math.floor(v) === v) || v < 0) {
      var p = l ? c : "highWaterMark";
      throw new ERR_INVALID_OPT_VALUE$1(p, v);
    }
    return Math.floor(v);
  }
  return a.objectMode ? 16 : 16 * 1024;
}
var state$4 = {
  getHighWaterMark: getHighWaterMark$1
}, _stream_writable$1, hasRequired_stream_writable$1;
function require_stream_writable$1() {
  if (hasRequired_stream_writable$1)
    return _stream_writable$1;
  hasRequired_stream_writable$1 = 1, _stream_writable$1 = Te;
  function a(ye) {
    var pe = this;
    this.next = null, this.entry = null, this.finish = function() {
      De(pe, ye);
    };
  }
  var u;
  Te.WritableState = be;
  var c = {
    deprecate: browser$c
  }, l = streamBrowser$1, v = require$$0$2.Buffer, p = (typeof commonjsGlobal$1 < "u" ? commonjsGlobal$1 : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function _(ye) {
    return v.from(ye);
  }
  function k(ye) {
    return v.isBuffer(ye) || ye instanceof p;
  }
  var O = destroy_1$1, D = state$4, F = D.getHighWaterMark, H = errorsBrowser$1.codes, Z = H.ERR_INVALID_ARG_TYPE, ee = H.ERR_METHOD_NOT_IMPLEMENTED, X = H.ERR_MULTIPLE_CALLBACK, ne = H.ERR_STREAM_CANNOT_PIPE, Q = H.ERR_STREAM_DESTROYED, ae = H.ERR_STREAM_NULL_VALUES, j = H.ERR_STREAM_WRITE_AFTER_END, ue = H.ERR_UNKNOWN_ENCODING, he = O.errorOrDestroy;
  inherits_browserExports(Te, l);
  function fe() {
  }
  function be(ye, pe, Me) {
    u = u || require_stream_duplex$1(), ye = ye || {}, typeof Me != "boolean" && (Me = pe instanceof u), this.objectMode = !!ye.objectMode, Me && (this.objectMode = this.objectMode || !!ye.writableObjectMode), this.highWaterMark = F(this, ye, "writableHighWaterMark", Me), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var Ne = ye.decodeStrings === !1;
    this.decodeStrings = !Ne, this.defaultEncoding = ye.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(Ue) {
      $(pe, Ue);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = ye.emitClose !== !1, this.autoDestroy = !!ye.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new a(this);
  }
  be.prototype.getBuffer = function() {
    for (var pe = this.bufferedRequest, Me = []; pe; )
      Me.push(pe), pe = pe.next;
    return Me;
  }, function() {
    try {
      Object.defineProperty(be.prototype, "buffer", {
        get: c.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var ke;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (ke = Function.prototype[Symbol.hasInstance], Object.defineProperty(Te, Symbol.hasInstance, {
    value: function(pe) {
      return ke.call(this, pe) ? !0 : this !== Te ? !1 : pe && pe._writableState instanceof be;
    }
  })) : ke = function(pe) {
    return pe instanceof this;
  };
  function Te(ye) {
    u = u || require_stream_duplex$1();
    var pe = this instanceof u;
    if (!pe && !ke.call(Te, this))
      return new Te(ye);
    this._writableState = new be(ye, this, pe), this.writable = !0, ye && (typeof ye.write == "function" && (this._write = ye.write), typeof ye.writev == "function" && (this._writev = ye.writev), typeof ye.destroy == "function" && (this._destroy = ye.destroy), typeof ye.final == "function" && (this._final = ye.final)), l.call(this);
  }
  Te.prototype.pipe = function() {
    he(this, new ne());
  };
  function q(ye, pe) {
    var Me = new j();
    he(ye, Me), process$1.nextTick(pe, Me);
  }
  function z(ye, pe, Me, Ne) {
    var Ue;
    return Me === null ? Ue = new ae() : typeof Me != "string" && !pe.objectMode && (Ue = new Z("chunk", ["string", "Buffer"], Me)), Ue ? (he(ye, Ue), process$1.nextTick(Ne, Ue), !1) : !0;
  }
  Te.prototype.write = function(ye, pe, Me) {
    var Ne = this._writableState, Ue = !1, oe = !Ne.objectMode && k(ye);
    return oe && !v.isBuffer(ye) && (ye = _(ye)), typeof pe == "function" && (Me = pe, pe = null), oe ? pe = "buffer" : pe || (pe = Ne.defaultEncoding), typeof Me != "function" && (Me = fe), Ne.ending ? q(this, Me) : (oe || z(this, Ne, ye, Me)) && (Ne.pendingcb++, Ue = S(this, Ne, oe, ye, pe, Me)), Ue;
  }, Te.prototype.cork = function() {
    this._writableState.corked++;
  }, Te.prototype.uncork = function() {
    var ye = this._writableState;
    ye.corked && (ye.corked--, !ye.writing && !ye.corked && !ye.bufferProcessing && ye.bufferedRequest && B(this, ye));
  }, Te.prototype.setDefaultEncoding = function(pe) {
    if (typeof pe == "string" && (pe = pe.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((pe + "").toLowerCase()) > -1))
      throw new ue(pe);
    return this._writableState.defaultEncoding = pe, this;
  }, Object.defineProperty(Te.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function P(ye, pe, Me) {
    return !ye.objectMode && ye.decodeStrings !== !1 && typeof pe == "string" && (pe = v.from(pe, Me)), pe;
  }
  Object.defineProperty(Te.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function S(ye, pe, Me, Ne, Ue, oe) {
    if (!Me) {
      var A = P(pe, Ne, Ue);
      Ne !== A && (Me = !0, Ue = "buffer", Ne = A);
    }
    var re = pe.objectMode ? 1 : Ne.length;
    pe.length += re;
    var le = pe.length < pe.highWaterMark;
    if (le || (pe.needDrain = !0), pe.writing || pe.corked) {
      var $e = pe.lastBufferedRequest;
      pe.lastBufferedRequest = {
        chunk: Ne,
        encoding: Ue,
        isBuf: Me,
        callback: oe,
        next: null
      }, $e ? $e.next = pe.lastBufferedRequest : pe.bufferedRequest = pe.lastBufferedRequest, pe.bufferedRequestCount += 1;
    } else
      E(ye, pe, !1, re, Ne, Ue, oe);
    return le;
  }
  function E(ye, pe, Me, Ne, Ue, oe, A) {
    pe.writelen = Ne, pe.writecb = A, pe.writing = !0, pe.sync = !0, pe.destroyed ? pe.onwrite(new Q("write")) : Me ? ye._writev(Ue, pe.onwrite) : ye._write(Ue, oe, pe.onwrite), pe.sync = !1;
  }
  function I(ye, pe, Me, Ne, Ue) {
    --pe.pendingcb, Me ? (process$1.nextTick(Ue, Ne), process$1.nextTick(me, ye, pe), ye._writableState.errorEmitted = !0, he(ye, Ne)) : (Ue(Ne), ye._writableState.errorEmitted = !0, he(ye, Ne), me(ye, pe));
  }
  function M(ye) {
    ye.writing = !1, ye.writecb = null, ye.length -= ye.writelen, ye.writelen = 0;
  }
  function $(ye, pe) {
    var Me = ye._writableState, Ne = Me.sync, Ue = Me.writecb;
    if (typeof Ue != "function")
      throw new X();
    if (M(Me), pe)
      I(ye, Me, Ne, pe, Ue);
    else {
      var oe = T(Me) || ye.destroyed;
      !oe && !Me.corked && !Me.bufferProcessing && Me.bufferedRequest && B(ye, Me), Ne ? process$1.nextTick(U, ye, Me, oe, Ue) : U(ye, Me, oe, Ue);
    }
  }
  function U(ye, pe, Me, Ne) {
    Me || Y(ye, pe), pe.pendingcb--, Ne(), me(ye, pe);
  }
  function Y(ye, pe) {
    pe.length === 0 && pe.needDrain && (pe.needDrain = !1, ye.emit("drain"));
  }
  function B(ye, pe) {
    pe.bufferProcessing = !0;
    var Me = pe.bufferedRequest;
    if (ye._writev && Me && Me.next) {
      var Ne = pe.bufferedRequestCount, Ue = new Array(Ne), oe = pe.corkedRequestsFree;
      oe.entry = Me;
      for (var A = 0, re = !0; Me; )
        Ue[A] = Me, Me.isBuf || (re = !1), Me = Me.next, A += 1;
      Ue.allBuffers = re, E(ye, pe, !0, pe.length, Ue, "", oe.finish), pe.pendingcb++, pe.lastBufferedRequest = null, oe.next ? (pe.corkedRequestsFree = oe.next, oe.next = null) : pe.corkedRequestsFree = new a(pe), pe.bufferedRequestCount = 0;
    } else {
      for (; Me; ) {
        var le = Me.chunk, $e = Me.encoding, Oe = Me.callback, Fe = pe.objectMode ? 1 : le.length;
        if (E(ye, pe, !1, Fe, le, $e, Oe), Me = Me.next, pe.bufferedRequestCount--, pe.writing)
          break;
      }
      Me === null && (pe.lastBufferedRequest = null);
    }
    pe.bufferedRequest = Me, pe.bufferProcessing = !1;
  }
  Te.prototype._write = function(ye, pe, Me) {
    Me(new ee("_write()"));
  }, Te.prototype._writev = null, Te.prototype.end = function(ye, pe, Me) {
    var Ne = this._writableState;
    return typeof ye == "function" ? (Me = ye, ye = null, pe = null) : typeof pe == "function" && (Me = pe, pe = null), ye != null && this.write(ye, pe), Ne.corked && (Ne.corked = 1, this.uncork()), Ne.ending || Ce(this, Ne, Me), this;
  }, Object.defineProperty(Te.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function T(ye) {
    return ye.ending && ye.length === 0 && ye.bufferedRequest === null && !ye.finished && !ye.writing;
  }
  function L(ye, pe) {
    ye._final(function(Me) {
      pe.pendingcb--, Me && he(ye, Me), pe.prefinished = !0, ye.emit("prefinish"), me(ye, pe);
    });
  }
  function te(ye, pe) {
    !pe.prefinished && !pe.finalCalled && (typeof ye._final == "function" && !pe.destroyed ? (pe.pendingcb++, pe.finalCalled = !0, process$1.nextTick(L, ye, pe)) : (pe.prefinished = !0, ye.emit("prefinish")));
  }
  function me(ye, pe) {
    var Me = T(pe);
    if (Me && (te(ye, pe), pe.pendingcb === 0 && (pe.finished = !0, ye.emit("finish"), pe.autoDestroy))) {
      var Ne = ye._readableState;
      (!Ne || Ne.autoDestroy && Ne.endEmitted) && ye.destroy();
    }
    return Me;
  }
  function Ce(ye, pe, Me) {
    pe.ending = !0, me(ye, pe), Me && (pe.finished ? process$1.nextTick(Me) : ye.once("finish", Me)), pe.ended = !0, ye.writable = !1;
  }
  function De(ye, pe, Me) {
    var Ne = ye.entry;
    for (ye.entry = null; Ne; ) {
      var Ue = Ne.callback;
      pe.pendingcb--, Ue(Me), Ne = Ne.next;
    }
    pe.corkedRequestsFree.next = ye;
  }
  return Object.defineProperty(Te.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(pe) {
      this._writableState && (this._writableState.destroyed = pe);
    }
  }), Te.prototype.destroy = O.destroy, Te.prototype._undestroy = O.undestroy, Te.prototype._destroy = function(ye, pe) {
    pe(ye);
  }, _stream_writable$1;
}
var _stream_duplex$1, hasRequired_stream_duplex$1;
function require_stream_duplex$1() {
  if (hasRequired_stream_duplex$1)
    return _stream_duplex$1;
  hasRequired_stream_duplex$1 = 1;
  var a = Object.keys || function(D) {
    var F = [];
    for (var H in D)
      F.push(H);
    return F;
  };
  _stream_duplex$1 = _;
  var u = require_stream_readable$1(), c = require_stream_writable$1();
  inherits_browserExports(_, u);
  for (var l = a(c.prototype), v = 0; v < l.length; v++) {
    var p = l[v];
    _.prototype[p] || (_.prototype[p] = c.prototype[p]);
  }
  function _(D) {
    if (!(this instanceof _))
      return new _(D);
    u.call(this, D), c.call(this, D), this.allowHalfOpen = !0, D && (D.readable === !1 && (this.readable = !1), D.writable === !1 && (this.writable = !1), D.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", k)));
  }
  Object.defineProperty(_.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(_.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(_.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function k() {
    this._writableState.ended || process$1.nextTick(O, this);
  }
  function O(D) {
    D.end();
  }
  return Object.defineProperty(_.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(F) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = F, this._writableState.destroyed = F);
    }
  }), _stream_duplex$1;
}
var ERR_STREAM_PREMATURE_CLOSE$1 = errorsBrowser$1.codes.ERR_STREAM_PREMATURE_CLOSE;
function once$5(a) {
  var u = !1;
  return function() {
    if (!u) {
      u = !0;
      for (var c = arguments.length, l = new Array(c), v = 0; v < c; v++)
        l[v] = arguments[v];
      a.apply(this, l);
    }
  };
}
function noop$4() {
}
function isRequest$3(a) {
  return a.setHeader && typeof a.abort == "function";
}
function eos$3(a, u, c) {
  if (typeof u == "function")
    return eos$3(a, null, u);
  u || (u = {}), c = once$5(c || noop$4);
  var l = u.readable || u.readable !== !1 && a.readable, v = u.writable || u.writable !== !1 && a.writable, p = function() {
    a.writable || k();
  }, _ = a._writableState && a._writableState.finished, k = function() {
    v = !1, _ = !0, l || c.call(a);
  }, O = a._readableState && a._readableState.endEmitted, D = function() {
    l = !1, O = !0, v || c.call(a);
  }, F = function(X) {
    c.call(a, X);
  }, H = function() {
    var X;
    if (l && !O)
      return (!a._readableState || !a._readableState.ended) && (X = new ERR_STREAM_PREMATURE_CLOSE$1()), c.call(a, X);
    if (v && !_)
      return (!a._writableState || !a._writableState.ended) && (X = new ERR_STREAM_PREMATURE_CLOSE$1()), c.call(a, X);
  }, Z = function() {
    a.req.on("finish", k);
  };
  return isRequest$3(a) ? (a.on("complete", k), a.on("abort", H), a.req ? Z() : a.on("request", Z)) : v && !a._writableState && (a.on("end", p), a.on("close", p)), a.on("end", D), a.on("finish", k), u.error !== !1 && a.on("error", F), a.on("close", H), function() {
    a.removeListener("complete", k), a.removeListener("abort", H), a.removeListener("request", Z), a.req && a.req.removeListener("finish", k), a.removeListener("end", p), a.removeListener("close", p), a.removeListener("finish", k), a.removeListener("end", D), a.removeListener("error", F), a.removeListener("close", H);
  };
}
var endOfStream$1 = eos$3, async_iterator$1, hasRequiredAsync_iterator$1;
function requireAsync_iterator$1() {
  if (hasRequiredAsync_iterator$1)
    return async_iterator$1;
  hasRequiredAsync_iterator$1 = 1;
  var a;
  function u(ue, he, fe) {
    return he = c(he), he in ue ? Object.defineProperty(ue, he, { value: fe, enumerable: !0, configurable: !0, writable: !0 }) : ue[he] = fe, ue;
  }
  function c(ue) {
    var he = l(ue, "string");
    return typeof he == "symbol" ? he : String(he);
  }
  function l(ue, he) {
    if (typeof ue != "object" || ue === null)
      return ue;
    var fe = ue[Symbol.toPrimitive];
    if (fe !== void 0) {
      var be = fe.call(ue, he || "default");
      if (typeof be != "object")
        return be;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (he === "string" ? String : Number)(ue);
  }
  var v = endOfStream$1, p = Symbol("lastResolve"), _ = Symbol("lastReject"), k = Symbol("error"), O = Symbol("ended"), D = Symbol("lastPromise"), F = Symbol("handlePromise"), H = Symbol("stream");
  function Z(ue, he) {
    return {
      value: ue,
      done: he
    };
  }
  function ee(ue) {
    var he = ue[p];
    if (he !== null) {
      var fe = ue[H].read();
      fe !== null && (ue[D] = null, ue[p] = null, ue[_] = null, he(Z(fe, !1)));
    }
  }
  function X(ue) {
    process$1.nextTick(ee, ue);
  }
  function ne(ue, he) {
    return function(fe, be) {
      ue.then(function() {
        if (he[O]) {
          fe(Z(void 0, !0));
          return;
        }
        he[F](fe, be);
      }, be);
    };
  }
  var Q = Object.getPrototypeOf(function() {
  }), ae = Object.setPrototypeOf((a = {
    get stream() {
      return this[H];
    },
    next: function() {
      var he = this, fe = this[k];
      if (fe !== null)
        return Promise.reject(fe);
      if (this[O])
        return Promise.resolve(Z(void 0, !0));
      if (this[H].destroyed)
        return new Promise(function(q, z) {
          process$1.nextTick(function() {
            he[k] ? z(he[k]) : q(Z(void 0, !0));
          });
        });
      var be = this[D], ke;
      if (be)
        ke = new Promise(ne(be, this));
      else {
        var Te = this[H].read();
        if (Te !== null)
          return Promise.resolve(Z(Te, !1));
        ke = new Promise(this[F]);
      }
      return this[D] = ke, ke;
    }
  }, u(a, Symbol.asyncIterator, function() {
    return this;
  }), u(a, "return", function() {
    var he = this;
    return new Promise(function(fe, be) {
      he[H].destroy(null, function(ke) {
        if (ke) {
          be(ke);
          return;
        }
        fe(Z(void 0, !0));
      });
    });
  }), a), Q), j = function(he) {
    var fe, be = Object.create(ae, (fe = {}, u(fe, H, {
      value: he,
      writable: !0
    }), u(fe, p, {
      value: null,
      writable: !0
    }), u(fe, _, {
      value: null,
      writable: !0
    }), u(fe, k, {
      value: null,
      writable: !0
    }), u(fe, O, {
      value: he._readableState.endEmitted,
      writable: !0
    }), u(fe, F, {
      value: function(Te, q) {
        var z = be[H].read();
        z ? (be[D] = null, be[p] = null, be[_] = null, Te(Z(z, !1))) : (be[p] = Te, be[_] = q);
      },
      writable: !0
    }), fe));
    return be[D] = null, v(he, function(ke) {
      if (ke && ke.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var Te = be[_];
        Te !== null && (be[D] = null, be[p] = null, be[_] = null, Te(ke)), be[k] = ke;
        return;
      }
      var q = be[p];
      q !== null && (be[D] = null, be[p] = null, be[_] = null, q(Z(void 0, !0))), be[O] = !0;
    }), he.on("readable", X.bind(null, be)), be;
  };
  return async_iterator$1 = j, async_iterator$1;
}
var fromBrowser$1, hasRequiredFromBrowser$1;
function requireFromBrowser$1() {
  return hasRequiredFromBrowser$1 || (hasRequiredFromBrowser$1 = 1, fromBrowser$1 = function() {
    throw new Error("Readable.from is not available in the browser");
  }), fromBrowser$1;
}
var _stream_readable$1, hasRequired_stream_readable$1;
function require_stream_readable$1() {
  if (hasRequired_stream_readable$1)
    return _stream_readable$1;
  hasRequired_stream_readable$1 = 1, _stream_readable$1 = q;
  var a;
  q.ReadableState = Te, eventsExports.EventEmitter;
  var u = function(A, re) {
    return A.listeners(re).length;
  }, c = streamBrowser$1, l = require$$0$2.Buffer, v = (typeof commonjsGlobal$1 < "u" ? commonjsGlobal$1 : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function p(oe) {
    return l.from(oe);
  }
  function _(oe) {
    return l.isBuffer(oe) || oe instanceof v;
  }
  var k = util$4, O;
  k && k.debuglog ? O = k.debuglog("stream") : O = function() {
  };
  var D = requireBuffer_list$1(), F = destroy_1$1, H = state$4, Z = H.getHighWaterMark, ee = errorsBrowser$1.codes, X = ee.ERR_INVALID_ARG_TYPE, ne = ee.ERR_STREAM_PUSH_AFTER_EOF, Q = ee.ERR_METHOD_NOT_IMPLEMENTED, ae = ee.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, j, ue, he;
  inherits_browserExports(q, c);
  var fe = F.errorOrDestroy, be = ["error", "close", "destroy", "pause", "resume"];
  function ke(oe, A, re) {
    if (typeof oe.prependListener == "function")
      return oe.prependListener(A, re);
    !oe._events || !oe._events[A] ? oe.on(A, re) : Array.isArray(oe._events[A]) ? oe._events[A].unshift(re) : oe._events[A] = [re, oe._events[A]];
  }
  function Te(oe, A, re) {
    a = a || require_stream_duplex$1(), oe = oe || {}, typeof re != "boolean" && (re = A instanceof a), this.objectMode = !!oe.objectMode, re && (this.objectMode = this.objectMode || !!oe.readableObjectMode), this.highWaterMark = Z(this, oe, "readableHighWaterMark", re), this.buffer = new D(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = oe.emitClose !== !1, this.autoDestroy = !!oe.autoDestroy, this.destroyed = !1, this.defaultEncoding = oe.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, oe.encoding && (j || (j = string_decoder.StringDecoder), this.decoder = new j(oe.encoding), this.encoding = oe.encoding);
  }
  function q(oe) {
    if (a = a || require_stream_duplex$1(), !(this instanceof q))
      return new q(oe);
    var A = this instanceof a;
    this._readableState = new Te(oe, this, A), this.readable = !0, oe && (typeof oe.read == "function" && (this._read = oe.read), typeof oe.destroy == "function" && (this._destroy = oe.destroy)), c.call(this);
  }
  Object.defineProperty(q.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(A) {
      this._readableState && (this._readableState.destroyed = A);
    }
  }), q.prototype.destroy = F.destroy, q.prototype._undestroy = F.undestroy, q.prototype._destroy = function(oe, A) {
    A(oe);
  }, q.prototype.push = function(oe, A) {
    var re = this._readableState, le;
    return re.objectMode ? le = !0 : typeof oe == "string" && (A = A || re.defaultEncoding, A !== re.encoding && (oe = l.from(oe, A), A = ""), le = !0), z(this, oe, A, !1, le);
  }, q.prototype.unshift = function(oe) {
    return z(this, oe, null, !0, !1);
  };
  function z(oe, A, re, le, $e) {
    O("readableAddChunk", A);
    var Oe = oe._readableState;
    if (A === null)
      Oe.reading = !1, $(oe, Oe);
    else {
      var Fe;
      if ($e || (Fe = S(Oe, A)), Fe)
        fe(oe, Fe);
      else if (Oe.objectMode || A && A.length > 0)
        if (typeof A != "string" && !Oe.objectMode && Object.getPrototypeOf(A) !== l.prototype && (A = p(A)), le)
          Oe.endEmitted ? fe(oe, new ae()) : P(oe, Oe, A, !0);
        else if (Oe.ended)
          fe(oe, new ne());
        else {
          if (Oe.destroyed)
            return !1;
          Oe.reading = !1, Oe.decoder && !re ? (A = Oe.decoder.write(A), Oe.objectMode || A.length !== 0 ? P(oe, Oe, A, !1) : B(oe, Oe)) : P(oe, Oe, A, !1);
        }
      else
        le || (Oe.reading = !1, B(oe, Oe));
    }
    return !Oe.ended && (Oe.length < Oe.highWaterMark || Oe.length === 0);
  }
  function P(oe, A, re, le) {
    A.flowing && A.length === 0 && !A.sync ? (A.awaitDrain = 0, oe.emit("data", re)) : (A.length += A.objectMode ? 1 : re.length, le ? A.buffer.unshift(re) : A.buffer.push(re), A.needReadable && U(oe)), B(oe, A);
  }
  function S(oe, A) {
    var re;
    return !_(A) && typeof A != "string" && A !== void 0 && !oe.objectMode && (re = new X("chunk", ["string", "Buffer", "Uint8Array"], A)), re;
  }
  q.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, q.prototype.setEncoding = function(oe) {
    j || (j = string_decoder.StringDecoder);
    var A = new j(oe);
    this._readableState.decoder = A, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var re = this._readableState.buffer.head, le = ""; re !== null; )
      le += A.write(re.data), re = re.next;
    return this._readableState.buffer.clear(), le !== "" && this._readableState.buffer.push(le), this._readableState.length = le.length, this;
  };
  var E = 1073741824;
  function I(oe) {
    return oe >= E ? oe = E : (oe--, oe |= oe >>> 1, oe |= oe >>> 2, oe |= oe >>> 4, oe |= oe >>> 8, oe |= oe >>> 16, oe++), oe;
  }
  function M(oe, A) {
    return oe <= 0 || A.length === 0 && A.ended ? 0 : A.objectMode ? 1 : oe !== oe ? A.flowing && A.length ? A.buffer.head.data.length : A.length : (oe > A.highWaterMark && (A.highWaterMark = I(oe)), oe <= A.length ? oe : A.ended ? A.length : (A.needReadable = !0, 0));
  }
  q.prototype.read = function(oe) {
    O("read", oe), oe = parseInt(oe, 10);
    var A = this._readableState, re = oe;
    if (oe !== 0 && (A.emittedReadable = !1), oe === 0 && A.needReadable && ((A.highWaterMark !== 0 ? A.length >= A.highWaterMark : A.length > 0) || A.ended))
      return O("read: emitReadable", A.length, A.ended), A.length === 0 && A.ended ? Me(this) : U(this), null;
    if (oe = M(oe, A), oe === 0 && A.ended)
      return A.length === 0 && Me(this), null;
    var le = A.needReadable;
    O("need readable", le), (A.length === 0 || A.length - oe < A.highWaterMark) && (le = !0, O("length less than watermark", le)), A.ended || A.reading ? (le = !1, O("reading or ended", le)) : le && (O("do read"), A.reading = !0, A.sync = !0, A.length === 0 && (A.needReadable = !0), this._read(A.highWaterMark), A.sync = !1, A.reading || (oe = M(re, A)));
    var $e;
    return oe > 0 ? $e = pe(oe, A) : $e = null, $e === null ? (A.needReadable = A.length <= A.highWaterMark, oe = 0) : (A.length -= oe, A.awaitDrain = 0), A.length === 0 && (A.ended || (A.needReadable = !0), re !== oe && A.ended && Me(this)), $e !== null && this.emit("data", $e), $e;
  };
  function $(oe, A) {
    if (O("onEofChunk"), !A.ended) {
      if (A.decoder) {
        var re = A.decoder.end();
        re && re.length && (A.buffer.push(re), A.length += A.objectMode ? 1 : re.length);
      }
      A.ended = !0, A.sync ? U(oe) : (A.needReadable = !1, A.emittedReadable || (A.emittedReadable = !0, Y(oe)));
    }
  }
  function U(oe) {
    var A = oe._readableState;
    O("emitReadable", A.needReadable, A.emittedReadable), A.needReadable = !1, A.emittedReadable || (O("emitReadable", A.flowing), A.emittedReadable = !0, process$1.nextTick(Y, oe));
  }
  function Y(oe) {
    var A = oe._readableState;
    O("emitReadable_", A.destroyed, A.length, A.ended), !A.destroyed && (A.length || A.ended) && (oe.emit("readable"), A.emittedReadable = !1), A.needReadable = !A.flowing && !A.ended && A.length <= A.highWaterMark, ye(oe);
  }
  function B(oe, A) {
    A.readingMore || (A.readingMore = !0, process$1.nextTick(T, oe, A));
  }
  function T(oe, A) {
    for (; !A.reading && !A.ended && (A.length < A.highWaterMark || A.flowing && A.length === 0); ) {
      var re = A.length;
      if (O("maybeReadMore read 0"), oe.read(0), re === A.length)
        break;
    }
    A.readingMore = !1;
  }
  q.prototype._read = function(oe) {
    fe(this, new Q("_read()"));
  }, q.prototype.pipe = function(oe, A) {
    var re = this, le = this._readableState;
    switch (le.pipesCount) {
      case 0:
        le.pipes = oe;
        break;
      case 1:
        le.pipes = [le.pipes, oe];
        break;
      default:
        le.pipes.push(oe);
        break;
    }
    le.pipesCount += 1, O("pipe count=%d opts=%j", le.pipesCount, A);
    var $e = (!A || A.end !== !1) && oe !== process$1.stdout && oe !== process$1.stderr, Oe = $e ? Ze : We;
    le.endEmitted ? process$1.nextTick(Oe) : re.once("end", Oe), oe.on("unpipe", Fe);
    function Fe(Ie, V) {
      O("onunpipe"), Ie === re && V && V.hasUnpiped === !1 && (V.hasUnpiped = !0, Xe());
    }
    function Ze() {
      O("onend"), oe.end();
    }
    var qe = L(re);
    oe.on("drain", qe);
    var yt = !1;
    function Xe() {
      O("cleanup"), oe.removeListener("close", ge), oe.removeListener("finish", we), oe.removeListener("drain", qe), oe.removeListener("error", J), oe.removeListener("unpipe", Fe), re.removeListener("end", Ze), re.removeListener("end", We), re.removeListener("data", Ge), yt = !0, le.awaitDrain && (!oe._writableState || oe._writableState.needDrain) && qe();
    }
    re.on("data", Ge);
    function Ge(Ie) {
      O("ondata");
      var V = oe.write(Ie);
      O("dest.write", V), V === !1 && ((le.pipesCount === 1 && le.pipes === oe || le.pipesCount > 1 && Ue(le.pipes, oe) !== -1) && !yt && (O("false write response, pause", le.awaitDrain), le.awaitDrain++), re.pause());
    }
    function J(Ie) {
      O("onerror", Ie), We(), oe.removeListener("error", J), u(oe, "error") === 0 && fe(oe, Ie);
    }
    ke(oe, "error", J);
    function ge() {
      oe.removeListener("finish", we), We();
    }
    oe.once("close", ge);
    function we() {
      O("onfinish"), oe.removeListener("close", ge), We();
    }
    oe.once("finish", we);
    function We() {
      O("unpipe"), re.unpipe(oe);
    }
    return oe.emit("pipe", re), le.flowing || (O("pipe resume"), re.resume()), oe;
  };
  function L(oe) {
    return function() {
      var re = oe._readableState;
      O("pipeOnDrain", re.awaitDrain), re.awaitDrain && re.awaitDrain--, re.awaitDrain === 0 && u(oe, "data") && (re.flowing = !0, ye(oe));
    };
  }
  q.prototype.unpipe = function(oe) {
    var A = this._readableState, re = {
      hasUnpiped: !1
    };
    if (A.pipesCount === 0)
      return this;
    if (A.pipesCount === 1)
      return oe && oe !== A.pipes ? this : (oe || (oe = A.pipes), A.pipes = null, A.pipesCount = 0, A.flowing = !1, oe && oe.emit("unpipe", this, re), this);
    if (!oe) {
      var le = A.pipes, $e = A.pipesCount;
      A.pipes = null, A.pipesCount = 0, A.flowing = !1;
      for (var Oe = 0; Oe < $e; Oe++)
        le[Oe].emit("unpipe", this, {
          hasUnpiped: !1
        });
      return this;
    }
    var Fe = Ue(A.pipes, oe);
    return Fe === -1 ? this : (A.pipes.splice(Fe, 1), A.pipesCount -= 1, A.pipesCount === 1 && (A.pipes = A.pipes[0]), oe.emit("unpipe", this, re), this);
  }, q.prototype.on = function(oe, A) {
    var re = c.prototype.on.call(this, oe, A), le = this._readableState;
    return oe === "data" ? (le.readableListening = this.listenerCount("readable") > 0, le.flowing !== !1 && this.resume()) : oe === "readable" && !le.endEmitted && !le.readableListening && (le.readableListening = le.needReadable = !0, le.flowing = !1, le.emittedReadable = !1, O("on readable", le.length, le.reading), le.length ? U(this) : le.reading || process$1.nextTick(me, this)), re;
  }, q.prototype.addListener = q.prototype.on, q.prototype.removeListener = function(oe, A) {
    var re = c.prototype.removeListener.call(this, oe, A);
    return oe === "readable" && process$1.nextTick(te, this), re;
  }, q.prototype.removeAllListeners = function(oe) {
    var A = c.prototype.removeAllListeners.apply(this, arguments);
    return (oe === "readable" || oe === void 0) && process$1.nextTick(te, this), A;
  };
  function te(oe) {
    var A = oe._readableState;
    A.readableListening = oe.listenerCount("readable") > 0, A.resumeScheduled && !A.paused ? A.flowing = !0 : oe.listenerCount("data") > 0 && oe.resume();
  }
  function me(oe) {
    O("readable nexttick read 0"), oe.read(0);
  }
  q.prototype.resume = function() {
    var oe = this._readableState;
    return oe.flowing || (O("resume"), oe.flowing = !oe.readableListening, Ce(this, oe)), oe.paused = !1, this;
  };
  function Ce(oe, A) {
    A.resumeScheduled || (A.resumeScheduled = !0, process$1.nextTick(De, oe, A));
  }
  function De(oe, A) {
    O("resume", A.reading), A.reading || oe.read(0), A.resumeScheduled = !1, oe.emit("resume"), ye(oe), A.flowing && !A.reading && oe.read(0);
  }
  q.prototype.pause = function() {
    return O("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (O("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function ye(oe) {
    var A = oe._readableState;
    for (O("flow", A.flowing); A.flowing && oe.read() !== null; )
      ;
  }
  q.prototype.wrap = function(oe) {
    var A = this, re = this._readableState, le = !1;
    oe.on("end", function() {
      if (O("wrapped end"), re.decoder && !re.ended) {
        var Fe = re.decoder.end();
        Fe && Fe.length && A.push(Fe);
      }
      A.push(null);
    }), oe.on("data", function(Fe) {
      if (O("wrapped data"), re.decoder && (Fe = re.decoder.write(Fe)), !(re.objectMode && Fe == null) && !(!re.objectMode && (!Fe || !Fe.length))) {
        var Ze = A.push(Fe);
        Ze || (le = !0, oe.pause());
      }
    });
    for (var $e in oe)
      this[$e] === void 0 && typeof oe[$e] == "function" && (this[$e] = /* @__PURE__ */ function(Ze) {
        return function() {
          return oe[Ze].apply(oe, arguments);
        };
      }($e));
    for (var Oe = 0; Oe < be.length; Oe++)
      oe.on(be[Oe], this.emit.bind(this, be[Oe]));
    return this._read = function(Fe) {
      O("wrapped _read", Fe), le && (le = !1, oe.resume());
    }, this;
  }, typeof Symbol == "function" && (q.prototype[Symbol.asyncIterator] = function() {
    return ue === void 0 && (ue = requireAsync_iterator$1()), ue(this);
  }), Object.defineProperty(q.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(q.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(q.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(A) {
      this._readableState && (this._readableState.flowing = A);
    }
  }), q._fromList = pe, Object.defineProperty(q.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function pe(oe, A) {
    if (A.length === 0)
      return null;
    var re;
    return A.objectMode ? re = A.buffer.shift() : !oe || oe >= A.length ? (A.decoder ? re = A.buffer.join("") : A.buffer.length === 1 ? re = A.buffer.first() : re = A.buffer.concat(A.length), A.buffer.clear()) : re = A.buffer.consume(oe, A.decoder), re;
  }
  function Me(oe) {
    var A = oe._readableState;
    O("endReadable", A.endEmitted), A.endEmitted || (A.ended = !0, process$1.nextTick(Ne, A, oe));
  }
  function Ne(oe, A) {
    if (O("endReadableNT", oe.endEmitted, oe.length), !oe.endEmitted && oe.length === 0 && (oe.endEmitted = !0, A.readable = !1, A.emit("end"), oe.autoDestroy)) {
      var re = A._writableState;
      (!re || re.autoDestroy && re.finished) && A.destroy();
    }
  }
  typeof Symbol == "function" && (q.from = function(oe, A) {
    return he === void 0 && (he = requireFromBrowser$1()), he(q, oe, A);
  });
  function Ue(oe, A) {
    for (var re = 0, le = oe.length; re < le; re++)
      if (oe[re] === A)
        return re;
    return -1;
  }
  return _stream_readable$1;
}
var _stream_transform$1 = Transform$9, _require$codes$3 = errorsBrowser$1.codes, ERR_METHOD_NOT_IMPLEMENTED$1 = _require$codes$3.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK$1 = _require$codes$3.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING$1 = _require$codes$3.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0$1 = _require$codes$3.ERR_TRANSFORM_WITH_LENGTH_0, Duplex$1 = require_stream_duplex$1();
inherits_browserExports(Transform$9, Duplex$1);
function afterTransform$1(a, u) {
  var c = this._transformState;
  c.transforming = !1;
  var l = c.writecb;
  if (l === null)
    return this.emit("error", new ERR_MULTIPLE_CALLBACK$1());
  c.writechunk = null, c.writecb = null, u != null && this.push(u), l(a);
  var v = this._readableState;
  v.reading = !1, (v.needReadable || v.length < v.highWaterMark) && this._read(v.highWaterMark);
}
function Transform$9(a) {
  if (!(this instanceof Transform$9))
    return new Transform$9(a);
  Duplex$1.call(this, a), this._transformState = {
    afterTransform: afterTransform$1.bind(this),
    needTransform: !1,
    transforming: !1,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }, this._readableState.needReadable = !0, this._readableState.sync = !1, a && (typeof a.transform == "function" && (this._transform = a.transform), typeof a.flush == "function" && (this._flush = a.flush)), this.on("prefinish", prefinish$1);
}
function prefinish$1() {
  var a = this;
  typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(u, c) {
    done$1(a, u, c);
  }) : done$1(this, null, null);
}
Transform$9.prototype.push = function(a, u) {
  return this._transformState.needTransform = !1, Duplex$1.prototype.push.call(this, a, u);
};
Transform$9.prototype._transform = function(a, u, c) {
  c(new ERR_METHOD_NOT_IMPLEMENTED$1("_transform()"));
};
Transform$9.prototype._write = function(a, u, c) {
  var l = this._transformState;
  if (l.writecb = c, l.writechunk = a, l.writeencoding = u, !l.transforming) {
    var v = this._readableState;
    (l.needTransform || v.needReadable || v.length < v.highWaterMark) && this._read(v.highWaterMark);
  }
};
Transform$9.prototype._read = function(a) {
  var u = this._transformState;
  u.writechunk !== null && !u.transforming ? (u.transforming = !0, this._transform(u.writechunk, u.writeencoding, u.afterTransform)) : u.needTransform = !0;
};
Transform$9.prototype._destroy = function(a, u) {
  Duplex$1.prototype._destroy.call(this, a, function(c) {
    u(c);
  });
};
function done$1(a, u, c) {
  if (u)
    return a.emit("error", u);
  if (c != null && a.push(c), a._writableState.length)
    throw new ERR_TRANSFORM_WITH_LENGTH_0$1();
  if (a._transformState.transforming)
    throw new ERR_TRANSFORM_ALREADY_TRANSFORMING$1();
  return a.push(null);
}
var _stream_passthrough$1 = PassThrough$1, Transform$8 = _stream_transform$1;
inherits_browserExports(PassThrough$1, Transform$8);
function PassThrough$1(a) {
  if (!(this instanceof PassThrough$1))
    return new PassThrough$1(a);
  Transform$8.call(this, a);
}
PassThrough$1.prototype._transform = function(a, u, c) {
  c(null, a);
};
var eos$2;
function once$4(a) {
  var u = !1;
  return function() {
    u || (u = !0, a.apply(void 0, arguments));
  };
}
var _require$codes$2 = errorsBrowser$1.codes, ERR_MISSING_ARGS$1 = _require$codes$2.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED$1 = _require$codes$2.ERR_STREAM_DESTROYED;
function noop$3(a) {
  if (a)
    throw a;
}
function isRequest$2(a) {
  return a.setHeader && typeof a.abort == "function";
}
function destroyer$1(a, u, c, l) {
  l = once$4(l);
  var v = !1;
  a.on("close", function() {
    v = !0;
  }), eos$2 === void 0 && (eos$2 = endOfStream$1), eos$2(a, {
    readable: u,
    writable: c
  }, function(_) {
    if (_)
      return l(_);
    v = !0, l();
  });
  var p = !1;
  return function(_) {
    if (!v && !p) {
      if (p = !0, isRequest$2(a))
        return a.abort();
      if (typeof a.destroy == "function")
        return a.destroy();
      l(_ || new ERR_STREAM_DESTROYED$1("pipe"));
    }
  };
}
function call$1(a) {
  a();
}
function pipe$1(a, u) {
  return a.pipe(u);
}
function popCallback$1(a) {
  return !a.length || typeof a[a.length - 1] != "function" ? noop$3 : a.pop();
}
function pipeline$1() {
  for (var a = arguments.length, u = new Array(a), c = 0; c < a; c++)
    u[c] = arguments[c];
  var l = popCallback$1(u);
  if (Array.isArray(u[0]) && (u = u[0]), u.length < 2)
    throw new ERR_MISSING_ARGS$1("streams");
  var v, p = u.map(function(_, k) {
    var O = k < u.length - 1, D = k > 0;
    return destroyer$1(_, O, D, function(F) {
      v || (v = F), F && p.forEach(call$1), !O && (p.forEach(call$1), l(v));
    });
  });
  return u.reduce(pipe$1);
}
var pipeline_1$1 = pipeline$1;
(function(a, u) {
  u = a.exports = require_stream_readable$1(), u.Stream = u, u.Readable = u, u.Writable = require_stream_writable$1(), u.Duplex = require_stream_duplex$1(), u.Transform = _stream_transform$1, u.PassThrough = _stream_passthrough$1, u.finished = endOfStream$1, u.pipeline = pipeline_1$1;
})(readableBrowser$1, readableBrowser$1.exports);
var readableBrowserExports$1 = readableBrowser$1.exports, Buffer$H = safeBufferExports$1.Buffer, Transform$7 = readableBrowserExports$1.Transform, inherits$u = inherits_browserExports;
function throwIfNotStringOrBuffer(a, u) {
  if (!Buffer$H.isBuffer(a) && typeof a != "string")
    throw new TypeError(u + " must be a string or a buffer");
}
function HashBase$2(a) {
  Transform$7.call(this), this._block = Buffer$H.allocUnsafe(a), this._blockSize = a, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = !1;
}
inherits$u(HashBase$2, Transform$7);
HashBase$2.prototype._transform = function(a, u, c) {
  var l = null;
  try {
    this.update(a, u);
  } catch (v) {
    l = v;
  }
  c(l);
};
HashBase$2.prototype._flush = function(a) {
  var u = null;
  try {
    this.push(this.digest());
  } catch (c) {
    u = c;
  }
  a(u);
};
HashBase$2.prototype.update = function(a, u) {
  if (throwIfNotStringOrBuffer(a, "Data"), this._finalized)
    throw new Error("Digest already called");
  Buffer$H.isBuffer(a) || (a = Buffer$H.from(a, u));
  for (var c = this._block, l = 0; this._blockOffset + a.length - l >= this._blockSize; ) {
    for (var v = this._blockOffset; v < this._blockSize; )
      c[v++] = a[l++];
    this._update(), this._blockOffset = 0;
  }
  for (; l < a.length; )
    c[this._blockOffset++] = a[l++];
  for (var p = 0, _ = a.length * 8; _ > 0; ++p)
    this._length[p] += _, _ = this._length[p] / 4294967296 | 0, _ > 0 && (this._length[p] -= 4294967296 * _);
  return this;
};
HashBase$2.prototype._update = function() {
  throw new Error("_update is not implemented");
};
HashBase$2.prototype.digest = function(a) {
  if (this._finalized)
    throw new Error("Digest already called");
  this._finalized = !0;
  var u = this._digest();
  a !== void 0 && (u = u.toString(a)), this._block.fill(0), this._blockOffset = 0;
  for (var c = 0; c < 4; ++c)
    this._length[c] = 0;
  return u;
};
HashBase$2.prototype._digest = function() {
  throw new Error("_digest is not implemented");
};
var hashBase = HashBase$2, inherits$t = inherits_browserExports, HashBase$1 = hashBase, Buffer$G = safeBufferExports$3.Buffer, ARRAY16$1 = new Array(16);
function MD5$3() {
  HashBase$1.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
}
inherits$t(MD5$3, HashBase$1);
MD5$3.prototype._update = function() {
  for (var a = ARRAY16$1, u = 0; u < 16; ++u)
    a[u] = this._block.readInt32LE(u * 4);
  var c = this._a, l = this._b, v = this._c, p = this._d;
  c = fnF(c, l, v, p, a[0], 3614090360, 7), p = fnF(p, c, l, v, a[1], 3905402710, 12), v = fnF(v, p, c, l, a[2], 606105819, 17), l = fnF(l, v, p, c, a[3], 3250441966, 22), c = fnF(c, l, v, p, a[4], 4118548399, 7), p = fnF(p, c, l, v, a[5], 1200080426, 12), v = fnF(v, p, c, l, a[6], 2821735955, 17), l = fnF(l, v, p, c, a[7], 4249261313, 22), c = fnF(c, l, v, p, a[8], 1770035416, 7), p = fnF(p, c, l, v, a[9], 2336552879, 12), v = fnF(v, p, c, l, a[10], 4294925233, 17), l = fnF(l, v, p, c, a[11], 2304563134, 22), c = fnF(c, l, v, p, a[12], 1804603682, 7), p = fnF(p, c, l, v, a[13], 4254626195, 12), v = fnF(v, p, c, l, a[14], 2792965006, 17), l = fnF(l, v, p, c, a[15], 1236535329, 22), c = fnG(c, l, v, p, a[1], 4129170786, 5), p = fnG(p, c, l, v, a[6], 3225465664, 9), v = fnG(v, p, c, l, a[11], 643717713, 14), l = fnG(l, v, p, c, a[0], 3921069994, 20), c = fnG(c, l, v, p, a[5], 3593408605, 5), p = fnG(p, c, l, v, a[10], 38016083, 9), v = fnG(v, p, c, l, a[15], 3634488961, 14), l = fnG(l, v, p, c, a[4], 3889429448, 20), c = fnG(c, l, v, p, a[9], 568446438, 5), p = fnG(p, c, l, v, a[14], 3275163606, 9), v = fnG(v, p, c, l, a[3], 4107603335, 14), l = fnG(l, v, p, c, a[8], 1163531501, 20), c = fnG(c, l, v, p, a[13], 2850285829, 5), p = fnG(p, c, l, v, a[2], 4243563512, 9), v = fnG(v, p, c, l, a[7], 1735328473, 14), l = fnG(l, v, p, c, a[12], 2368359562, 20), c = fnH(c, l, v, p, a[5], 4294588738, 4), p = fnH(p, c, l, v, a[8], 2272392833, 11), v = fnH(v, p, c, l, a[11], 1839030562, 16), l = fnH(l, v, p, c, a[14], 4259657740, 23), c = fnH(c, l, v, p, a[1], 2763975236, 4), p = fnH(p, c, l, v, a[4], 1272893353, 11), v = fnH(v, p, c, l, a[7], 4139469664, 16), l = fnH(l, v, p, c, a[10], 3200236656, 23), c = fnH(c, l, v, p, a[13], 681279174, 4), p = fnH(p, c, l, v, a[0], 3936430074, 11), v = fnH(v, p, c, l, a[3], 3572445317, 16), l = fnH(l, v, p, c, a[6], 76029189, 23), c = fnH(c, l, v, p, a[9], 3654602809, 4), p = fnH(p, c, l, v, a[12], 3873151461, 11), v = fnH(v, p, c, l, a[15], 530742520, 16), l = fnH(l, v, p, c, a[2], 3299628645, 23), c = fnI(c, l, v, p, a[0], 4096336452, 6), p = fnI(p, c, l, v, a[7], 1126891415, 10), v = fnI(v, p, c, l, a[14], 2878612391, 15), l = fnI(l, v, p, c, a[5], 4237533241, 21), c = fnI(c, l, v, p, a[12], 1700485571, 6), p = fnI(p, c, l, v, a[3], 2399980690, 10), v = fnI(v, p, c, l, a[10], 4293915773, 15), l = fnI(l, v, p, c, a[1], 2240044497, 21), c = fnI(c, l, v, p, a[8], 1873313359, 6), p = fnI(p, c, l, v, a[15], 4264355552, 10), v = fnI(v, p, c, l, a[6], 2734768916, 15), l = fnI(l, v, p, c, a[13], 1309151649, 21), c = fnI(c, l, v, p, a[4], 4149444226, 6), p = fnI(p, c, l, v, a[11], 3174756917, 10), v = fnI(v, p, c, l, a[2], 718787259, 15), l = fnI(l, v, p, c, a[9], 3951481745, 21), this._a = this._a + c | 0, this._b = this._b + l | 0, this._c = this._c + v | 0, this._d = this._d + p | 0;
};
MD5$3.prototype._digest = function() {
  this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
  var a = Buffer$G.allocUnsafe(16);
  return a.writeInt32LE(this._a, 0), a.writeInt32LE(this._b, 4), a.writeInt32LE(this._c, 8), a.writeInt32LE(this._d, 12), a;
};
function rotl$1(a, u) {
  return a << u | a >>> 32 - u;
}
function fnF(a, u, c, l, v, p, _) {
  return rotl$1(a + (u & c | ~u & l) + v + p | 0, _) + u | 0;
}
function fnG(a, u, c, l, v, p, _) {
  return rotl$1(a + (u & l | c & ~l) + v + p | 0, _) + u | 0;
}
function fnH(a, u, c, l, v, p, _) {
  return rotl$1(a + (u ^ c ^ l) + v + p | 0, _) + u | 0;
}
function fnI(a, u, c, l, v, p, _) {
  return rotl$1(a + (c ^ (u | ~l)) + v + p | 0, _) + u | 0;
}
var md5_js = MD5$3, Buffer$F = require$$0$2.Buffer, inherits$s = inherits_browserExports, HashBase = hashBase, ARRAY16 = new Array(16), zl = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
], zr = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
], sl = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
], sr = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
], hl = [0, 1518500249, 1859775393, 2400959708, 2840853838], hr = [1352829926, 1548603684, 1836072691, 2053994217, 0];
function RIPEMD160$4() {
  HashBase.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
}
inherits$s(RIPEMD160$4, HashBase);
RIPEMD160$4.prototype._update = function() {
  for (var a = ARRAY16, u = 0; u < 16; ++u)
    a[u] = this._block.readInt32LE(u * 4);
  for (var c = this._a | 0, l = this._b | 0, v = this._c | 0, p = this._d | 0, _ = this._e | 0, k = this._a | 0, O = this._b | 0, D = this._c | 0, F = this._d | 0, H = this._e | 0, Z = 0; Z < 80; Z += 1) {
    var ee, X;
    Z < 16 ? (ee = fn1(c, l, v, p, _, a[zl[Z]], hl[0], sl[Z]), X = fn5(k, O, D, F, H, a[zr[Z]], hr[0], sr[Z])) : Z < 32 ? (ee = fn2(c, l, v, p, _, a[zl[Z]], hl[1], sl[Z]), X = fn4(k, O, D, F, H, a[zr[Z]], hr[1], sr[Z])) : Z < 48 ? (ee = fn3(c, l, v, p, _, a[zl[Z]], hl[2], sl[Z]), X = fn3(k, O, D, F, H, a[zr[Z]], hr[2], sr[Z])) : Z < 64 ? (ee = fn4(c, l, v, p, _, a[zl[Z]], hl[3], sl[Z]), X = fn2(k, O, D, F, H, a[zr[Z]], hr[3], sr[Z])) : (ee = fn5(c, l, v, p, _, a[zl[Z]], hl[4], sl[Z]), X = fn1(k, O, D, F, H, a[zr[Z]], hr[4], sr[Z])), c = _, _ = p, p = rotl(v, 10), v = l, l = ee, k = H, H = F, F = rotl(D, 10), D = O, O = X;
  }
  var ne = this._b + v + F | 0;
  this._b = this._c + p + H | 0, this._c = this._d + _ + k | 0, this._d = this._e + c + O | 0, this._e = this._a + l + D | 0, this._a = ne;
};
RIPEMD160$4.prototype._digest = function() {
  this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
  var a = Buffer$F.alloc ? Buffer$F.alloc(20) : new Buffer$F(20);
  return a.writeInt32LE(this._a, 0), a.writeInt32LE(this._b, 4), a.writeInt32LE(this._c, 8), a.writeInt32LE(this._d, 12), a.writeInt32LE(this._e, 16), a;
};
function rotl(a, u) {
  return a << u | a >>> 32 - u;
}
function fn1(a, u, c, l, v, p, _, k) {
  return rotl(a + (u ^ c ^ l) + p + _ | 0, k) + v | 0;
}
function fn2(a, u, c, l, v, p, _, k) {
  return rotl(a + (u & c | ~u & l) + p + _ | 0, k) + v | 0;
}
function fn3(a, u, c, l, v, p, _, k) {
  return rotl(a + ((u | ~c) ^ l) + p + _ | 0, k) + v | 0;
}
function fn4(a, u, c, l, v, p, _, k) {
  return rotl(a + (u & l | c & ~l) + p + _ | 0, k) + v | 0;
}
function fn5(a, u, c, l, v, p, _, k) {
  return rotl(a + (u ^ (c | ~l)) + p + _ | 0, k) + v | 0;
}
var ripemd160 = RIPEMD160$4, sha_js = { exports: {} }, Buffer$E = safeBufferExports$3.Buffer;
function Hash$7(a, u) {
  this._block = Buffer$E.alloc(a), this._finalSize = u, this._blockSize = a, this._len = 0;
}
Hash$7.prototype.update = function(a, u) {
  typeof a == "string" && (u = u || "utf8", a = Buffer$E.from(a, u));
  for (var c = this._block, l = this._blockSize, v = a.length, p = this._len, _ = 0; _ < v; ) {
    for (var k = p % l, O = Math.min(v - _, l - k), D = 0; D < O; D++)
      c[k + D] = a[_ + D];
    p += O, _ += O, p % l === 0 && this._update(c);
  }
  return this._len += v, this;
};
Hash$7.prototype.digest = function(a) {
  var u = this._len % this._blockSize;
  this._block[u] = 128, this._block.fill(0, u + 1), u >= this._finalSize && (this._update(this._block), this._block.fill(0));
  var c = this._len * 8;
  if (c <= 4294967295)
    this._block.writeUInt32BE(c, this._blockSize - 4);
  else {
    var l = (c & 4294967295) >>> 0, v = (c - l) / 4294967296;
    this._block.writeUInt32BE(v, this._blockSize - 8), this._block.writeUInt32BE(l, this._blockSize - 4);
  }
  this._update(this._block);
  var p = this._hash();
  return a ? p.toString(a) : p;
};
Hash$7.prototype._update = function() {
  throw new Error("_update must be implemented by subclass");
};
var hash$3 = Hash$7, inherits$r = inherits_browserExports, Hash$6 = hash$3, Buffer$D = safeBufferExports$3.Buffer, K$4 = [
  1518500249,
  1859775393,
  -1894007588,
  -899497514
], W$5 = new Array(80);
function Sha() {
  this.init(), this._w = W$5, Hash$6.call(this, 64, 56);
}
inherits$r(Sha, Hash$6);
Sha.prototype.init = function() {
  return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
};
function rotl5$1(a) {
  return a << 5 | a >>> 27;
}
function rotl30$1(a) {
  return a << 30 | a >>> 2;
}
function ft$1(a, u, c, l) {
  return a === 0 ? u & c | ~u & l : a === 2 ? u & c | u & l | c & l : u ^ c ^ l;
}
Sha.prototype._update = function(a) {
  for (var u = this._w, c = this._a | 0, l = this._b | 0, v = this._c | 0, p = this._d | 0, _ = this._e | 0, k = 0; k < 16; ++k)
    u[k] = a.readInt32BE(k * 4);
  for (; k < 80; ++k)
    u[k] = u[k - 3] ^ u[k - 8] ^ u[k - 14] ^ u[k - 16];
  for (var O = 0; O < 80; ++O) {
    var D = ~~(O / 20), F = rotl5$1(c) + ft$1(D, l, v, p) + _ + u[O] + K$4[D] | 0;
    _ = p, p = v, v = rotl30$1(l), l = c, c = F;
  }
  this._a = c + this._a | 0, this._b = l + this._b | 0, this._c = v + this._c | 0, this._d = p + this._d | 0, this._e = _ + this._e | 0;
};
Sha.prototype._hash = function() {
  var a = Buffer$D.allocUnsafe(20);
  return a.writeInt32BE(this._a | 0, 0), a.writeInt32BE(this._b | 0, 4), a.writeInt32BE(this._c | 0, 8), a.writeInt32BE(this._d | 0, 12), a.writeInt32BE(this._e | 0, 16), a;
};
var sha$4 = Sha, inherits$q = inherits_browserExports, Hash$5 = hash$3, Buffer$C = safeBufferExports$3.Buffer, K$3 = [
  1518500249,
  1859775393,
  -1894007588,
  -899497514
], W$4 = new Array(80);
function Sha1() {
  this.init(), this._w = W$4, Hash$5.call(this, 64, 56);
}
inherits$q(Sha1, Hash$5);
Sha1.prototype.init = function() {
  return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
};
function rotl1(a) {
  return a << 1 | a >>> 31;
}
function rotl5(a) {
  return a << 5 | a >>> 27;
}
function rotl30(a) {
  return a << 30 | a >>> 2;
}
function ft(a, u, c, l) {
  return a === 0 ? u & c | ~u & l : a === 2 ? u & c | u & l | c & l : u ^ c ^ l;
}
Sha1.prototype._update = function(a) {
  for (var u = this._w, c = this._a | 0, l = this._b | 0, v = this._c | 0, p = this._d | 0, _ = this._e | 0, k = 0; k < 16; ++k)
    u[k] = a.readInt32BE(k * 4);
  for (; k < 80; ++k)
    u[k] = rotl1(u[k - 3] ^ u[k - 8] ^ u[k - 14] ^ u[k - 16]);
  for (var O = 0; O < 80; ++O) {
    var D = ~~(O / 20), F = rotl5(c) + ft(D, l, v, p) + _ + u[O] + K$3[D] | 0;
    _ = p, p = v, v = rotl30(l), l = c, c = F;
  }
  this._a = c + this._a | 0, this._b = l + this._b | 0, this._c = v + this._c | 0, this._d = p + this._d | 0, this._e = _ + this._e | 0;
};
Sha1.prototype._hash = function() {
  var a = Buffer$C.allocUnsafe(20);
  return a.writeInt32BE(this._a | 0, 0), a.writeInt32BE(this._b | 0, 4), a.writeInt32BE(this._c | 0, 8), a.writeInt32BE(this._d | 0, 12), a.writeInt32BE(this._e | 0, 16), a;
};
var sha1 = Sha1, inherits$p = inherits_browserExports, Hash$4 = hash$3, Buffer$B = safeBufferExports$3.Buffer, K$2 = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
], W$3 = new Array(64);
function Sha256$1() {
  this.init(), this._w = W$3, Hash$4.call(this, 64, 56);
}
inherits$p(Sha256$1, Hash$4);
Sha256$1.prototype.init = function() {
  return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
};
function ch(a, u, c) {
  return c ^ a & (u ^ c);
}
function maj$1(a, u, c) {
  return a & u | c & (a | u);
}
function sigma0$1(a) {
  return (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10);
}
function sigma1$1(a) {
  return (a >>> 6 | a << 26) ^ (a >>> 11 | a << 21) ^ (a >>> 25 | a << 7);
}
function gamma0(a) {
  return (a >>> 7 | a << 25) ^ (a >>> 18 | a << 14) ^ a >>> 3;
}
function gamma1(a) {
  return (a >>> 17 | a << 15) ^ (a >>> 19 | a << 13) ^ a >>> 10;
}
Sha256$1.prototype._update = function(a) {
  for (var u = this._w, c = this._a | 0, l = this._b | 0, v = this._c | 0, p = this._d | 0, _ = this._e | 0, k = this._f | 0, O = this._g | 0, D = this._h | 0, F = 0; F < 16; ++F)
    u[F] = a.readInt32BE(F * 4);
  for (; F < 64; ++F)
    u[F] = gamma1(u[F - 2]) + u[F - 7] + gamma0(u[F - 15]) + u[F - 16] | 0;
  for (var H = 0; H < 64; ++H) {
    var Z = D + sigma1$1(_) + ch(_, k, O) + K$2[H] + u[H] | 0, ee = sigma0$1(c) + maj$1(c, l, v) | 0;
    D = O, O = k, k = _, _ = p + Z | 0, p = v, v = l, l = c, c = Z + ee | 0;
  }
  this._a = c + this._a | 0, this._b = l + this._b | 0, this._c = v + this._c | 0, this._d = p + this._d | 0, this._e = _ + this._e | 0, this._f = k + this._f | 0, this._g = O + this._g | 0, this._h = D + this._h | 0;
};
Sha256$1.prototype._hash = function() {
  var a = Buffer$B.allocUnsafe(32);
  return a.writeInt32BE(this._a, 0), a.writeInt32BE(this._b, 4), a.writeInt32BE(this._c, 8), a.writeInt32BE(this._d, 12), a.writeInt32BE(this._e, 16), a.writeInt32BE(this._f, 20), a.writeInt32BE(this._g, 24), a.writeInt32BE(this._h, 28), a;
};
var sha256$1 = Sha256$1, inherits$o = inherits_browserExports, Sha256 = sha256$1, Hash$3 = hash$3, Buffer$A = safeBufferExports$3.Buffer, W$2 = new Array(64);
function Sha224() {
  this.init(), this._w = W$2, Hash$3.call(this, 64, 56);
}
inherits$o(Sha224, Sha256);
Sha224.prototype.init = function() {
  return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
};
Sha224.prototype._hash = function() {
  var a = Buffer$A.allocUnsafe(28);
  return a.writeInt32BE(this._a, 0), a.writeInt32BE(this._b, 4), a.writeInt32BE(this._c, 8), a.writeInt32BE(this._d, 12), a.writeInt32BE(this._e, 16), a.writeInt32BE(this._f, 20), a.writeInt32BE(this._g, 24), a;
};
var sha224$1 = Sha224, inherits$n = inherits_browserExports, Hash$2 = hash$3, Buffer$z = safeBufferExports$3.Buffer, K$1 = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
], W$1 = new Array(160);
function Sha512() {
  this.init(), this._w = W$1, Hash$2.call(this, 128, 112);
}
inherits$n(Sha512, Hash$2);
Sha512.prototype.init = function() {
  return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
};
function Ch(a, u, c) {
  return c ^ a & (u ^ c);
}
function maj(a, u, c) {
  return a & u | c & (a | u);
}
function sigma0(a, u) {
  return (a >>> 28 | u << 4) ^ (u >>> 2 | a << 30) ^ (u >>> 7 | a << 25);
}
function sigma1(a, u) {
  return (a >>> 14 | u << 18) ^ (a >>> 18 | u << 14) ^ (u >>> 9 | a << 23);
}
function Gamma0(a, u) {
  return (a >>> 1 | u << 31) ^ (a >>> 8 | u << 24) ^ a >>> 7;
}
function Gamma0l(a, u) {
  return (a >>> 1 | u << 31) ^ (a >>> 8 | u << 24) ^ (a >>> 7 | u << 25);
}
function Gamma1(a, u) {
  return (a >>> 19 | u << 13) ^ (u >>> 29 | a << 3) ^ a >>> 6;
}
function Gamma1l(a, u) {
  return (a >>> 19 | u << 13) ^ (u >>> 29 | a << 3) ^ (a >>> 6 | u << 26);
}
function getCarry(a, u) {
  return a >>> 0 < u >>> 0 ? 1 : 0;
}
Sha512.prototype._update = function(a) {
  for (var u = this._w, c = this._ah | 0, l = this._bh | 0, v = this._ch | 0, p = this._dh | 0, _ = this._eh | 0, k = this._fh | 0, O = this._gh | 0, D = this._hh | 0, F = this._al | 0, H = this._bl | 0, Z = this._cl | 0, ee = this._dl | 0, X = this._el | 0, ne = this._fl | 0, Q = this._gl | 0, ae = this._hl | 0, j = 0; j < 32; j += 2)
    u[j] = a.readInt32BE(j * 4), u[j + 1] = a.readInt32BE(j * 4 + 4);
  for (; j < 160; j += 2) {
    var ue = u[j - 30], he = u[j - 15 * 2 + 1], fe = Gamma0(ue, he), be = Gamma0l(he, ue);
    ue = u[j - 2 * 2], he = u[j - 2 * 2 + 1];
    var ke = Gamma1(ue, he), Te = Gamma1l(he, ue), q = u[j - 7 * 2], z = u[j - 7 * 2 + 1], P = u[j - 16 * 2], S = u[j - 16 * 2 + 1], E = be + z | 0, I = fe + q + getCarry(E, be) | 0;
    E = E + Te | 0, I = I + ke + getCarry(E, Te) | 0, E = E + S | 0, I = I + P + getCarry(E, S) | 0, u[j] = I, u[j + 1] = E;
  }
  for (var M = 0; M < 160; M += 2) {
    I = u[M], E = u[M + 1];
    var $ = maj(c, l, v), U = maj(F, H, Z), Y = sigma0(c, F), B = sigma0(F, c), T = sigma1(_, X), L = sigma1(X, _), te = K$1[M], me = K$1[M + 1], Ce = Ch(_, k, O), De = Ch(X, ne, Q), ye = ae + L | 0, pe = D + T + getCarry(ye, ae) | 0;
    ye = ye + De | 0, pe = pe + Ce + getCarry(ye, De) | 0, ye = ye + me | 0, pe = pe + te + getCarry(ye, me) | 0, ye = ye + E | 0, pe = pe + I + getCarry(ye, E) | 0;
    var Me = B + U | 0, Ne = Y + $ + getCarry(Me, B) | 0;
    D = O, ae = Q, O = k, Q = ne, k = _, ne = X, X = ee + ye | 0, _ = p + pe + getCarry(X, ee) | 0, p = v, ee = Z, v = l, Z = H, l = c, H = F, F = ye + Me | 0, c = pe + Ne + getCarry(F, ye) | 0;
  }
  this._al = this._al + F | 0, this._bl = this._bl + H | 0, this._cl = this._cl + Z | 0, this._dl = this._dl + ee | 0, this._el = this._el + X | 0, this._fl = this._fl + ne | 0, this._gl = this._gl + Q | 0, this._hl = this._hl + ae | 0, this._ah = this._ah + c + getCarry(this._al, F) | 0, this._bh = this._bh + l + getCarry(this._bl, H) | 0, this._ch = this._ch + v + getCarry(this._cl, Z) | 0, this._dh = this._dh + p + getCarry(this._dl, ee) | 0, this._eh = this._eh + _ + getCarry(this._el, X) | 0, this._fh = this._fh + k + getCarry(this._fl, ne) | 0, this._gh = this._gh + O + getCarry(this._gl, Q) | 0, this._hh = this._hh + D + getCarry(this._hl, ae) | 0;
};
Sha512.prototype._hash = function() {
  var a = Buffer$z.allocUnsafe(64);
  function u(c, l, v) {
    a.writeInt32BE(c, v), a.writeInt32BE(l, v + 4);
  }
  return u(this._ah, this._al, 0), u(this._bh, this._bl, 8), u(this._ch, this._cl, 16), u(this._dh, this._dl, 24), u(this._eh, this._el, 32), u(this._fh, this._fl, 40), u(this._gh, this._gl, 48), u(this._hh, this._hl, 56), a;
};
var sha512$1 = Sha512, inherits$m = inherits_browserExports, SHA512$2 = sha512$1, Hash$1 = hash$3, Buffer$y = safeBufferExports$3.Buffer, W = new Array(160);
function Sha384() {
  this.init(), this._w = W, Hash$1.call(this, 128, 112);
}
inherits$m(Sha384, SHA512$2);
Sha384.prototype.init = function() {
  return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
};
Sha384.prototype._hash = function() {
  var a = Buffer$y.allocUnsafe(48);
  function u(c, l, v) {
    a.writeInt32BE(c, v), a.writeInt32BE(l, v + 4);
  }
  return u(this._ah, this._al, 0), u(this._bh, this._bl, 8), u(this._ch, this._cl, 16), u(this._dh, this._dl, 24), u(this._eh, this._el, 32), u(this._fh, this._fl, 40), a;
};
var sha384$1 = Sha384, exports$1 = sha_js.exports = function a(u) {
  u = u.toLowerCase();
  var c = exports$1[u];
  if (!c)
    throw new Error(u + " is not supported (we accept pull requests)");
  return new c();
};
exports$1.sha = sha$4;
exports$1.sha1 = sha1;
exports$1.sha224 = sha224$1;
exports$1.sha256 = sha256$1;
exports$1.sha384 = sha384$1;
exports$1.sha512 = sha512$1;
var sha_jsExports = sha_js.exports, Buffer$x = safeBufferExports$3.Buffer, Transform$6 = streamBrowserify.Transform, StringDecoder = string_decoder.StringDecoder, inherits$l = inherits_browserExports;
function CipherBase$1(a) {
  Transform$6.call(this), this.hashMode = typeof a == "string", this.hashMode ? this[a] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;
}
inherits$l(CipherBase$1, Transform$6);
CipherBase$1.prototype.update = function(a, u, c) {
  typeof a == "string" && (a = Buffer$x.from(a, u));
  var l = this._update(a);
  return this.hashMode ? this : (c && (l = this._toString(l, c)), l);
};
CipherBase$1.prototype.setAutoPadding = function() {
};
CipherBase$1.prototype.getAuthTag = function() {
  throw new Error("trying to get auth tag in unsupported state");
};
CipherBase$1.prototype.setAuthTag = function() {
  throw new Error("trying to set auth tag in unsupported state");
};
CipherBase$1.prototype.setAAD = function() {
  throw new Error("trying to set aad in unsupported state");
};
CipherBase$1.prototype._transform = function(a, u, c) {
  var l;
  try {
    this.hashMode ? this._update(a) : this.push(this._update(a));
  } catch (v) {
    l = v;
  } finally {
    c(l);
  }
};
CipherBase$1.prototype._flush = function(a) {
  var u;
  try {
    this.push(this.__final());
  } catch (c) {
    u = c;
  }
  a(u);
};
CipherBase$1.prototype._finalOrDigest = function(a) {
  var u = this.__final() || Buffer$x.alloc(0);
  return a && (u = this._toString(u, a, !0)), u;
};
CipherBase$1.prototype._toString = function(a, u, c) {
  if (this._decoder || (this._decoder = new StringDecoder(u), this._encoding = u), this._encoding !== u)
    throw new Error("can't switch encodings");
  var l = this._decoder.write(a);
  return c && (l += this._decoder.end()), l;
};
var cipherBase = CipherBase$1, inherits$k = inherits_browserExports, MD5$2 = md5_js, RIPEMD160$3 = ripemd160, sha$3 = sha_jsExports, Base$5 = cipherBase;
function Hash(a) {
  Base$5.call(this, "digest"), this._hash = a;
}
inherits$k(Hash, Base$5);
Hash.prototype._update = function(a) {
  this._hash.update(a);
};
Hash.prototype._final = function() {
  return this._hash.digest();
};
var browser$a = function a(u) {
  return u = u.toLowerCase(), u === "md5" ? new MD5$2() : u === "rmd160" || u === "ripemd160" ? new RIPEMD160$3() : new Hash(sha$3(u));
}, inherits$j = inherits_browserExports, Buffer$w = safeBufferExports$3.Buffer, Base$4 = cipherBase, ZEROS$2 = Buffer$w.alloc(128), blocksize = 64;
function Hmac$3(a, u) {
  Base$4.call(this, "digest"), typeof u == "string" && (u = Buffer$w.from(u)), this._alg = a, this._key = u, u.length > blocksize ? u = a(u) : u.length < blocksize && (u = Buffer$w.concat([u, ZEROS$2], blocksize));
  for (var c = this._ipad = Buffer$w.allocUnsafe(blocksize), l = this._opad = Buffer$w.allocUnsafe(blocksize), v = 0; v < blocksize; v++)
    c[v] = u[v] ^ 54, l[v] = u[v] ^ 92;
  this._hash = [c];
}
inherits$j(Hmac$3, Base$4);
Hmac$3.prototype._update = function(a) {
  this._hash.push(a);
};
Hmac$3.prototype._final = function() {
  var a = this._alg(Buffer$w.concat(this._hash));
  return this._alg(Buffer$w.concat([this._opad, a]));
};
var legacy = Hmac$3, MD5$1 = md5_js, md5$2 = function(a) {
  return new MD5$1().update(a).digest();
}, inherits$i = inherits_browserExports, Legacy = legacy, Base$3 = cipherBase, Buffer$v = safeBufferExports$3.Buffer, md5$1 = md5$2, RIPEMD160$2 = ripemd160, sha$2 = sha_jsExports, ZEROS$1 = Buffer$v.alloc(128);
function Hmac$2(a, u) {
  Base$3.call(this, "digest"), typeof u == "string" && (u = Buffer$v.from(u));
  var c = a === "sha512" || a === "sha384" ? 128 : 64;
  if (this._alg = a, this._key = u, u.length > c) {
    var l = a === "rmd160" ? new RIPEMD160$2() : sha$2(a);
    u = l.update(u).digest();
  } else
    u.length < c && (u = Buffer$v.concat([u, ZEROS$1], c));
  for (var v = this._ipad = Buffer$v.allocUnsafe(c), p = this._opad = Buffer$v.allocUnsafe(c), _ = 0; _ < c; _++)
    v[_] = u[_] ^ 54, p[_] = u[_] ^ 92;
  this._hash = a === "rmd160" ? new RIPEMD160$2() : sha$2(a), this._hash.update(v);
}
inherits$i(Hmac$2, Base$3);
Hmac$2.prototype._update = function(a) {
  this._hash.update(a);
};
Hmac$2.prototype._final = function() {
  var a = this._hash.digest(), u = this._alg === "rmd160" ? new RIPEMD160$2() : sha$2(this._alg);
  return u.update(this._opad).update(a).digest();
};
var browser$9 = function a(u, c) {
  return u = u.toLowerCase(), u === "rmd160" || u === "ripemd160" ? new Hmac$2("rmd160", c) : u === "md5" ? new Legacy(md5$1, c) : new Hmac$2(u, c);
};
const sha224WithRSAEncryption = {
  sign: "rsa",
  hash: "sha224",
  id: "302d300d06096086480165030402040500041c"
}, sha256WithRSAEncryption = {
  sign: "rsa",
  hash: "sha256",
  id: "3031300d060960864801650304020105000420"
}, sha384WithRSAEncryption = {
  sign: "rsa",
  hash: "sha384",
  id: "3041300d060960864801650304020205000430"
}, sha512WithRSAEncryption = {
  sign: "rsa",
  hash: "sha512",
  id: "3051300d060960864801650304020305000440"
}, sha256 = {
  sign: "ecdsa",
  hash: "sha256",
  id: ""
}, sha224 = {
  sign: "ecdsa",
  hash: "sha224",
  id: ""
}, sha384 = {
  sign: "ecdsa",
  hash: "sha384",
  id: ""
}, sha512 = {
  sign: "ecdsa",
  hash: "sha512",
  id: ""
}, DSA = {
  sign: "dsa",
  hash: "sha1",
  id: ""
}, ripemd160WithRSA = {
  sign: "rsa",
  hash: "rmd160",
  id: "3021300906052b2403020105000414"
}, md5WithRSAEncryption = {
  sign: "rsa",
  hash: "md5",
  id: "3020300c06082a864886f70d020505000410"
}, require$$6 = {
  sha224WithRSAEncryption,
  "RSA-SHA224": {
    sign: "ecdsa/rsa",
    hash: "sha224",
    id: "302d300d06096086480165030402040500041c"
  },
  sha256WithRSAEncryption,
  "RSA-SHA256": {
    sign: "ecdsa/rsa",
    hash: "sha256",
    id: "3031300d060960864801650304020105000420"
  },
  sha384WithRSAEncryption,
  "RSA-SHA384": {
    sign: "ecdsa/rsa",
    hash: "sha384",
    id: "3041300d060960864801650304020205000430"
  },
  sha512WithRSAEncryption,
  "RSA-SHA512": {
    sign: "ecdsa/rsa",
    hash: "sha512",
    id: "3051300d060960864801650304020305000440"
  },
  "RSA-SHA1": {
    sign: "rsa",
    hash: "sha1",
    id: "3021300906052b0e03021a05000414"
  },
  "ecdsa-with-SHA1": {
    sign: "ecdsa",
    hash: "sha1",
    id: ""
  },
  sha256,
  sha224,
  sha384,
  sha512,
  "DSA-SHA": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  "DSA-SHA1": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  DSA,
  "DSA-WITH-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-WITH-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-WITH-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-WITH-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-RIPEMD160": {
    sign: "dsa",
    hash: "rmd160",
    id: ""
  },
  ripemd160WithRSA,
  "RSA-RIPEMD160": {
    sign: "rsa",
    hash: "rmd160",
    id: "3021300906052b2403020105000414"
  },
  md5WithRSAEncryption,
  "RSA-MD5": {
    sign: "rsa",
    hash: "md5",
    id: "3020300c06082a864886f70d020505000410"
  }
};
var algos = require$$6, browser$8 = {}, MAX_ALLOC = Math.pow(2, 30) - 1, precondition = function(a, u) {
  if (typeof a != "number")
    throw new TypeError("Iterations not a number");
  if (a < 0)
    throw new TypeError("Bad iterations");
  if (typeof u != "number")
    throw new TypeError("Key length not a number");
  if (u < 0 || u > MAX_ALLOC || u !== u)
    throw new TypeError("Bad key length");
}, defaultEncoding$2;
if (commonjsGlobal$1.process && commonjsGlobal$1.process.browser)
  defaultEncoding$2 = "utf-8";
else if (commonjsGlobal$1.process && commonjsGlobal$1.process.version) {
  var pVersionMajor = parseInt(process$1.version.split(".")[0].slice(1), 10);
  defaultEncoding$2 = pVersionMajor >= 6 ? "utf-8" : "binary";
} else
  defaultEncoding$2 = "utf-8";
var defaultEncoding_1 = defaultEncoding$2, Buffer$u = safeBufferExports$3.Buffer, toBuffer$2 = function(a, u, c) {
  if (Buffer$u.isBuffer(a))
    return a;
  if (typeof a == "string")
    return Buffer$u.from(a, u);
  if (ArrayBuffer.isView(a))
    return Buffer$u.from(a.buffer);
  throw new TypeError(c + " must be a string, a Buffer, a typed array or a DataView");
}, md5 = md5$2, RIPEMD160$1 = ripemd160, sha$1 = sha_jsExports, Buffer$t = safeBufferExports$3.Buffer, checkParameters$1 = precondition, defaultEncoding$1 = defaultEncoding_1, toBuffer$1 = toBuffer$2, ZEROS = Buffer$t.alloc(128), sizes = {
  md5: 16,
  sha1: 20,
  sha224: 28,
  sha256: 32,
  sha384: 48,
  sha512: 64,
  rmd160: 20,
  ripemd160: 20
};
function Hmac$1(a, u, c) {
  var l = getDigest(a), v = a === "sha512" || a === "sha384" ? 128 : 64;
  u.length > v ? u = l(u) : u.length < v && (u = Buffer$t.concat([u, ZEROS], v));
  for (var p = Buffer$t.allocUnsafe(v + sizes[a]), _ = Buffer$t.allocUnsafe(v + sizes[a]), k = 0; k < v; k++)
    p[k] = u[k] ^ 54, _[k] = u[k] ^ 92;
  var O = Buffer$t.allocUnsafe(v + c + 4);
  p.copy(O, 0, 0, v), this.ipad1 = O, this.ipad2 = p, this.opad = _, this.alg = a, this.blocksize = v, this.hash = l, this.size = sizes[a];
}
Hmac$1.prototype.run = function(a, u) {
  a.copy(u, this.blocksize);
  var c = this.hash(u);
  return c.copy(this.opad, this.blocksize), this.hash(this.opad);
};
function getDigest(a) {
  function u(l) {
    return sha$1(a).update(l).digest();
  }
  function c(l) {
    return new RIPEMD160$1().update(l).digest();
  }
  return a === "rmd160" || a === "ripemd160" ? c : a === "md5" ? md5 : u;
}
function pbkdf2(a, u, c, l, v) {
  checkParameters$1(c, l), a = toBuffer$1(a, defaultEncoding$1, "Password"), u = toBuffer$1(u, defaultEncoding$1, "Salt"), v = v || "sha1";
  var p = new Hmac$1(v, a, u.length), _ = Buffer$t.allocUnsafe(l), k = Buffer$t.allocUnsafe(u.length + 4);
  u.copy(k, 0, 0, u.length);
  for (var O = 0, D = sizes[v], F = Math.ceil(l / D), H = 1; H <= F; H++) {
    k.writeUInt32BE(H, u.length);
    for (var Z = p.run(k, p.ipad1), ee = Z, X = 1; X < c; X++) {
      ee = p.run(ee, p.ipad2);
      for (var ne = 0; ne < D; ne++)
        Z[ne] ^= ee[ne];
    }
    Z.copy(_, O), O += D;
  }
  return _;
}
var syncBrowser = pbkdf2, Buffer$s = safeBufferExports$3.Buffer, checkParameters = precondition, defaultEncoding = defaultEncoding_1, sync = syncBrowser, toBuffer = toBuffer$2, ZERO_BUF, subtle = commonjsGlobal$1.crypto && commonjsGlobal$1.crypto.subtle, toBrowser = {
  sha: "SHA-1",
  "sha-1": "SHA-1",
  sha1: "SHA-1",
  sha256: "SHA-256",
  "sha-256": "SHA-256",
  sha384: "SHA-384",
  "sha-384": "SHA-384",
  "sha-512": "SHA-512",
  sha512: "SHA-512"
}, checks = [];
function checkNative(a) {
  if (commonjsGlobal$1.process && !commonjsGlobal$1.process.browser || !subtle || !subtle.importKey || !subtle.deriveBits)
    return Promise.resolve(!1);
  if (checks[a] !== void 0)
    return checks[a];
  ZERO_BUF = ZERO_BUF || Buffer$s.alloc(8);
  var u = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, a).then(function() {
    return !0;
  }).catch(function() {
    return !1;
  });
  return checks[a] = u, u;
}
var nextTick$1;
function getNextTick() {
  return nextTick$1 || (commonjsGlobal$1.process && commonjsGlobal$1.process.nextTick ? nextTick$1 = commonjsGlobal$1.process.nextTick : commonjsGlobal$1.queueMicrotask ? nextTick$1 = commonjsGlobal$1.queueMicrotask : commonjsGlobal$1.setImmediate ? nextTick$1 = commonjsGlobal$1.setImmediate : nextTick$1 = commonjsGlobal$1.setTimeout, nextTick$1);
}
function browserPbkdf2(a, u, c, l, v) {
  return subtle.importKey(
    "raw",
    a,
    { name: "PBKDF2" },
    !1,
    ["deriveBits"]
  ).then(function(p) {
    return subtle.deriveBits({
      name: "PBKDF2",
      salt: u,
      iterations: c,
      hash: {
        name: v
      }
    }, p, l << 3);
  }).then(function(p) {
    return Buffer$s.from(p);
  });
}
function resolvePromise(a, u) {
  a.then(function(c) {
    getNextTick()(function() {
      u(null, c);
    });
  }, function(c) {
    getNextTick()(function() {
      u(c);
    });
  });
}
var async = function(a, u, c, l, v, p) {
  typeof v == "function" && (p = v, v = void 0), v = v || "sha1";
  var _ = toBrowser[v.toLowerCase()];
  if (!_ || typeof commonjsGlobal$1.Promise != "function") {
    getNextTick()(function() {
      var k;
      try {
        k = sync(a, u, c, l, v);
      } catch (O) {
        return p(O);
      }
      p(null, k);
    });
    return;
  }
  if (checkParameters(c, l), a = toBuffer(a, defaultEncoding, "Password"), u = toBuffer(u, defaultEncoding, "Salt"), typeof p != "function")
    throw new Error("No callback provided to pbkdf2");
  resolvePromise(checkNative(_).then(function(k) {
    return k ? browserPbkdf2(a, u, c, l, _) : sync(a, u, c, l, v);
  }), p);
};
browser$8.pbkdf2 = async;
browser$8.pbkdf2Sync = syncBrowser;
var browser$7 = {}, des$2 = {}, utils$x = {};
utils$x.readUInt32BE = function a(u, c) {
  var l = u[0 + c] << 24 | u[1 + c] << 16 | u[2 + c] << 8 | u[3 + c];
  return l >>> 0;
};
utils$x.writeUInt32BE = function a(u, c, l) {
  u[0 + l] = c >>> 24, u[1 + l] = c >>> 16 & 255, u[2 + l] = c >>> 8 & 255, u[3 + l] = c & 255;
};
utils$x.ip = function a(u, c, l, v) {
  for (var p = 0, _ = 0, k = 6; k >= 0; k -= 2) {
    for (var O = 0; O <= 24; O += 8)
      p <<= 1, p |= c >>> O + k & 1;
    for (var O = 0; O <= 24; O += 8)
      p <<= 1, p |= u >>> O + k & 1;
  }
  for (var k = 6; k >= 0; k -= 2) {
    for (var O = 1; O <= 25; O += 8)
      _ <<= 1, _ |= c >>> O + k & 1;
    for (var O = 1; O <= 25; O += 8)
      _ <<= 1, _ |= u >>> O + k & 1;
  }
  l[v + 0] = p >>> 0, l[v + 1] = _ >>> 0;
};
utils$x.rip = function a(u, c, l, v) {
  for (var p = 0, _ = 0, k = 0; k < 4; k++)
    for (var O = 24; O >= 0; O -= 8)
      p <<= 1, p |= c >>> O + k & 1, p <<= 1, p |= u >>> O + k & 1;
  for (var k = 4; k < 8; k++)
    for (var O = 24; O >= 0; O -= 8)
      _ <<= 1, _ |= c >>> O + k & 1, _ <<= 1, _ |= u >>> O + k & 1;
  l[v + 0] = p >>> 0, l[v + 1] = _ >>> 0;
};
utils$x.pc1 = function a(u, c, l, v) {
  for (var p = 0, _ = 0, k = 7; k >= 5; k--) {
    for (var O = 0; O <= 24; O += 8)
      p <<= 1, p |= c >> O + k & 1;
    for (var O = 0; O <= 24; O += 8)
      p <<= 1, p |= u >> O + k & 1;
  }
  for (var O = 0; O <= 24; O += 8)
    p <<= 1, p |= c >> O + k & 1;
  for (var k = 1; k <= 3; k++) {
    for (var O = 0; O <= 24; O += 8)
      _ <<= 1, _ |= c >> O + k & 1;
    for (var O = 0; O <= 24; O += 8)
      _ <<= 1, _ |= u >> O + k & 1;
  }
  for (var O = 0; O <= 24; O += 8)
    _ <<= 1, _ |= u >> O + k & 1;
  l[v + 0] = p >>> 0, l[v + 1] = _ >>> 0;
};
utils$x.r28shl = function a(u, c) {
  return u << c & 268435455 | u >>> 28 - c;
};
var pc2table = [
  // inL => outL
  14,
  11,
  17,
  4,
  27,
  23,
  25,
  0,
  13,
  22,
  7,
  18,
  5,
  9,
  16,
  24,
  2,
  20,
  12,
  21,
  1,
  8,
  15,
  26,
  // inR => outR
  15,
  4,
  25,
  19,
  9,
  1,
  26,
  16,
  5,
  11,
  23,
  8,
  12,
  7,
  17,
  0,
  22,
  3,
  10,
  14,
  6,
  20,
  27,
  24
];
utils$x.pc2 = function a(u, c, l, v) {
  for (var p = 0, _ = 0, k = pc2table.length >>> 1, O = 0; O < k; O++)
    p <<= 1, p |= u >>> pc2table[O] & 1;
  for (var O = k; O < pc2table.length; O++)
    _ <<= 1, _ |= c >>> pc2table[O] & 1;
  l[v + 0] = p >>> 0, l[v + 1] = _ >>> 0;
};
utils$x.expand = function a(u, c, l) {
  var v = 0, p = 0;
  v = (u & 1) << 5 | u >>> 27;
  for (var _ = 23; _ >= 15; _ -= 4)
    v <<= 6, v |= u >>> _ & 63;
  for (var _ = 11; _ >= 3; _ -= 4)
    p |= u >>> _ & 63, p <<= 6;
  p |= (u & 31) << 1 | u >>> 31, c[l + 0] = v >>> 0, c[l + 1] = p >>> 0;
};
var sTable = [
  14,
  0,
  4,
  15,
  13,
  7,
  1,
  4,
  2,
  14,
  15,
  2,
  11,
  13,
  8,
  1,
  3,
  10,
  10,
  6,
  6,
  12,
  12,
  11,
  5,
  9,
  9,
  5,
  0,
  3,
  7,
  8,
  4,
  15,
  1,
  12,
  14,
  8,
  8,
  2,
  13,
  4,
  6,
  9,
  2,
  1,
  11,
  7,
  15,
  5,
  12,
  11,
  9,
  3,
  7,
  14,
  3,
  10,
  10,
  0,
  5,
  6,
  0,
  13,
  15,
  3,
  1,
  13,
  8,
  4,
  14,
  7,
  6,
  15,
  11,
  2,
  3,
  8,
  4,
  14,
  9,
  12,
  7,
  0,
  2,
  1,
  13,
  10,
  12,
  6,
  0,
  9,
  5,
  11,
  10,
  5,
  0,
  13,
  14,
  8,
  7,
  10,
  11,
  1,
  10,
  3,
  4,
  15,
  13,
  4,
  1,
  2,
  5,
  11,
  8,
  6,
  12,
  7,
  6,
  12,
  9,
  0,
  3,
  5,
  2,
  14,
  15,
  9,
  10,
  13,
  0,
  7,
  9,
  0,
  14,
  9,
  6,
  3,
  3,
  4,
  15,
  6,
  5,
  10,
  1,
  2,
  13,
  8,
  12,
  5,
  7,
  14,
  11,
  12,
  4,
  11,
  2,
  15,
  8,
  1,
  13,
  1,
  6,
  10,
  4,
  13,
  9,
  0,
  8,
  6,
  15,
  9,
  3,
  8,
  0,
  7,
  11,
  4,
  1,
  15,
  2,
  14,
  12,
  3,
  5,
  11,
  10,
  5,
  14,
  2,
  7,
  12,
  7,
  13,
  13,
  8,
  14,
  11,
  3,
  5,
  0,
  6,
  6,
  15,
  9,
  0,
  10,
  3,
  1,
  4,
  2,
  7,
  8,
  2,
  5,
  12,
  11,
  1,
  12,
  10,
  4,
  14,
  15,
  9,
  10,
  3,
  6,
  15,
  9,
  0,
  0,
  6,
  12,
  10,
  11,
  1,
  7,
  13,
  13,
  8,
  15,
  9,
  1,
  4,
  3,
  5,
  14,
  11,
  5,
  12,
  2,
  7,
  8,
  2,
  4,
  14,
  2,
  14,
  12,
  11,
  4,
  2,
  1,
  12,
  7,
  4,
  10,
  7,
  11,
  13,
  6,
  1,
  8,
  5,
  5,
  0,
  3,
  15,
  15,
  10,
  13,
  3,
  0,
  9,
  14,
  8,
  9,
  6,
  4,
  11,
  2,
  8,
  1,
  12,
  11,
  7,
  10,
  1,
  13,
  14,
  7,
  2,
  8,
  13,
  15,
  6,
  9,
  15,
  12,
  0,
  5,
  9,
  6,
  10,
  3,
  4,
  0,
  5,
  14,
  3,
  12,
  10,
  1,
  15,
  10,
  4,
  15,
  2,
  9,
  7,
  2,
  12,
  6,
  9,
  8,
  5,
  0,
  6,
  13,
  1,
  3,
  13,
  4,
  14,
  14,
  0,
  7,
  11,
  5,
  3,
  11,
  8,
  9,
  4,
  14,
  3,
  15,
  2,
  5,
  12,
  2,
  9,
  8,
  5,
  12,
  15,
  3,
  10,
  7,
  11,
  0,
  14,
  4,
  1,
  10,
  7,
  1,
  6,
  13,
  0,
  11,
  8,
  6,
  13,
  4,
  13,
  11,
  0,
  2,
  11,
  14,
  7,
  15,
  4,
  0,
  9,
  8,
  1,
  13,
  10,
  3,
  14,
  12,
  3,
  9,
  5,
  7,
  12,
  5,
  2,
  10,
  15,
  6,
  8,
  1,
  6,
  1,
  6,
  4,
  11,
  11,
  13,
  13,
  8,
  12,
  1,
  3,
  4,
  7,
  10,
  14,
  7,
  10,
  9,
  15,
  5,
  6,
  0,
  8,
  15,
  0,
  14,
  5,
  2,
  9,
  3,
  2,
  12,
  13,
  1,
  2,
  15,
  8,
  13,
  4,
  8,
  6,
  10,
  15,
  3,
  11,
  7,
  1,
  4,
  10,
  12,
  9,
  5,
  3,
  6,
  14,
  11,
  5,
  0,
  0,
  14,
  12,
  9,
  7,
  2,
  7,
  2,
  11,
  1,
  4,
  14,
  1,
  7,
  9,
  4,
  12,
  10,
  14,
  8,
  2,
  13,
  0,
  15,
  6,
  12,
  10,
  9,
  13,
  0,
  15,
  3,
  3,
  5,
  5,
  6,
  8,
  11
];
utils$x.substitute = function a(u, c) {
  for (var l = 0, v = 0; v < 4; v++) {
    var p = u >>> 18 - v * 6 & 63, _ = sTable[v * 64 + p];
    l <<= 4, l |= _;
  }
  for (var v = 0; v < 4; v++) {
    var p = c >>> 18 - v * 6 & 63, _ = sTable[4 * 64 + v * 64 + p];
    l <<= 4, l |= _;
  }
  return l >>> 0;
};
var permuteTable = [
  16,
  25,
  12,
  11,
  3,
  20,
  4,
  15,
  31,
  17,
  9,
  6,
  27,
  14,
  1,
  22,
  30,
  24,
  8,
  18,
  0,
  5,
  29,
  23,
  13,
  19,
  2,
  26,
  10,
  21,
  28,
  7
];
utils$x.permute = function a(u) {
  for (var c = 0, l = 0; l < permuteTable.length; l++)
    c <<= 1, c |= u >>> permuteTable[l] & 1;
  return c >>> 0;
};
utils$x.padSplit = function a(u, c, l) {
  for (var v = u.toString(2); v.length < c; )
    v = "0" + v;
  for (var p = [], _ = 0; _ < c; _ += l)
    p.push(v.slice(_, _ + l));
  return p.join(" ");
};
var minimalisticAssert = assert$j;
function assert$j(a, u) {
  if (!a)
    throw new Error(u || "Assertion failed");
}
assert$j.equal = function a(u, c, l) {
  if (u != c)
    throw new Error(l || "Assertion failed: " + u + " != " + c);
};
var assert$i = minimalisticAssert;
function Cipher$3(a) {
  this.options = a, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0, this.padding = a.padding !== !1;
}
var cipher = Cipher$3;
Cipher$3.prototype._init = function a() {
};
Cipher$3.prototype.update = function a(u) {
  return u.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(u) : this._updateEncrypt(u);
};
Cipher$3.prototype._buffer = function a(u, c) {
  for (var l = Math.min(this.buffer.length - this.bufferOff, u.length - c), v = 0; v < l; v++)
    this.buffer[this.bufferOff + v] = u[c + v];
  return this.bufferOff += l, l;
};
Cipher$3.prototype._flushBuffer = function a(u, c) {
  return this._update(this.buffer, 0, u, c), this.bufferOff = 0, this.blockSize;
};
Cipher$3.prototype._updateEncrypt = function a(u) {
  var c = 0, l = 0, v = (this.bufferOff + u.length) / this.blockSize | 0, p = new Array(v * this.blockSize);
  this.bufferOff !== 0 && (c += this._buffer(u, c), this.bufferOff === this.buffer.length && (l += this._flushBuffer(p, l)));
  for (var _ = u.length - (u.length - c) % this.blockSize; c < _; c += this.blockSize)
    this._update(u, c, p, l), l += this.blockSize;
  for (; c < u.length; c++, this.bufferOff++)
    this.buffer[this.bufferOff] = u[c];
  return p;
};
Cipher$3.prototype._updateDecrypt = function a(u) {
  for (var c = 0, l = 0, v = Math.ceil((this.bufferOff + u.length) / this.blockSize) - 1, p = new Array(v * this.blockSize); v > 0; v--)
    c += this._buffer(u, c), l += this._flushBuffer(p, l);
  return c += this._buffer(u, c), p;
};
Cipher$3.prototype.final = function a(u) {
  var c;
  u && (c = this.update(u));
  var l;
  return this.type === "encrypt" ? l = this._finalEncrypt() : l = this._finalDecrypt(), c ? c.concat(l) : l;
};
Cipher$3.prototype._pad = function a(u, c) {
  if (c === 0)
    return !1;
  for (; c < u.length; )
    u[c++] = 0;
  return !0;
};
Cipher$3.prototype._finalEncrypt = function a() {
  if (!this._pad(this.buffer, this.bufferOff))
    return [];
  var u = new Array(this.blockSize);
  return this._update(this.buffer, 0, u, 0), u;
};
Cipher$3.prototype._unpad = function a(u) {
  return u;
};
Cipher$3.prototype._finalDecrypt = function a() {
  assert$i.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
  var u = new Array(this.blockSize);
  return this._flushBuffer(u, 0), this._unpad(u);
};
var assert$h = minimalisticAssert, inherits$h = inherits_browserExports, utils$w = utils$x, Cipher$2 = cipher;
function DESState() {
  this.tmp = new Array(2), this.keys = null;
}
function DES$3(a) {
  Cipher$2.call(this, a);
  var u = new DESState();
  this._desState = u, this.deriveKeys(u, a.key);
}
inherits$h(DES$3, Cipher$2);
var des$1 = DES$3;
DES$3.create = function a(u) {
  return new DES$3(u);
};
var shiftTable = [
  1,
  1,
  2,
  2,
  2,
  2,
  2,
  2,
  1,
  2,
  2,
  2,
  2,
  2,
  2,
  1
];
DES$3.prototype.deriveKeys = function a(u, c) {
  u.keys = new Array(16 * 2), assert$h.equal(c.length, this.blockSize, "Invalid key length");
  var l = utils$w.readUInt32BE(c, 0), v = utils$w.readUInt32BE(c, 4);
  utils$w.pc1(l, v, u.tmp, 0), l = u.tmp[0], v = u.tmp[1];
  for (var p = 0; p < u.keys.length; p += 2) {
    var _ = shiftTable[p >>> 1];
    l = utils$w.r28shl(l, _), v = utils$w.r28shl(v, _), utils$w.pc2(l, v, u.keys, p);
  }
};
DES$3.prototype._update = function a(u, c, l, v) {
  var p = this._desState, _ = utils$w.readUInt32BE(u, c), k = utils$w.readUInt32BE(u, c + 4);
  utils$w.ip(_, k, p.tmp, 0), _ = p.tmp[0], k = p.tmp[1], this.type === "encrypt" ? this._encrypt(p, _, k, p.tmp, 0) : this._decrypt(p, _, k, p.tmp, 0), _ = p.tmp[0], k = p.tmp[1], utils$w.writeUInt32BE(l, _, v), utils$w.writeUInt32BE(l, k, v + 4);
};
DES$3.prototype._pad = function a(u, c) {
  if (this.padding === !1)
    return !1;
  for (var l = u.length - c, v = c; v < u.length; v++)
    u[v] = l;
  return !0;
};
DES$3.prototype._unpad = function a(u) {
  if (this.padding === !1)
    return u;
  for (var c = u[u.length - 1], l = u.length - c; l < u.length; l++)
    assert$h.equal(u[l], c);
  return u.slice(0, u.length - c);
};
DES$3.prototype._encrypt = function a(u, c, l, v, p) {
  for (var _ = c, k = l, O = 0; O < u.keys.length; O += 2) {
    var D = u.keys[O], F = u.keys[O + 1];
    utils$w.expand(k, u.tmp, 0), D ^= u.tmp[0], F ^= u.tmp[1];
    var H = utils$w.substitute(D, F), Z = utils$w.permute(H), ee = k;
    k = (_ ^ Z) >>> 0, _ = ee;
  }
  utils$w.rip(k, _, v, p);
};
DES$3.prototype._decrypt = function a(u, c, l, v, p) {
  for (var _ = l, k = c, O = u.keys.length - 2; O >= 0; O -= 2) {
    var D = u.keys[O], F = u.keys[O + 1];
    utils$w.expand(_, u.tmp, 0), D ^= u.tmp[0], F ^= u.tmp[1];
    var H = utils$w.substitute(D, F), Z = utils$w.permute(H), ee = _;
    _ = (k ^ Z) >>> 0, k = ee;
  }
  utils$w.rip(_, k, v, p);
};
var cbc$1 = {}, assert$g = minimalisticAssert, inherits$g = inherits_browserExports, proto = {};
function CBCState(a) {
  assert$g.equal(a.length, 8, "Invalid IV length"), this.iv = new Array(8);
  for (var u = 0; u < this.iv.length; u++)
    this.iv[u] = a[u];
}
function instantiate(a) {
  function u(p) {
    a.call(this, p), this._cbcInit();
  }
  inherits$g(u, a);
  for (var c = Object.keys(proto), l = 0; l < c.length; l++) {
    var v = c[l];
    u.prototype[v] = proto[v];
  }
  return u.create = function(_) {
    return new u(_);
  }, u;
}
cbc$1.instantiate = instantiate;
proto._cbcInit = function a() {
  var u = new CBCState(this.options.iv);
  this._cbcState = u;
};
proto._update = function a(u, c, l, v) {
  var p = this._cbcState, _ = this.constructor.super_.prototype, k = p.iv;
  if (this.type === "encrypt") {
    for (var O = 0; O < this.blockSize; O++)
      k[O] ^= u[c + O];
    _._update.call(this, k, 0, l, v);
    for (var O = 0; O < this.blockSize; O++)
      k[O] = l[v + O];
  } else {
    _._update.call(this, u, c, l, v);
    for (var O = 0; O < this.blockSize; O++)
      l[v + O] ^= k[O];
    for (var O = 0; O < this.blockSize; O++)
      k[O] = u[c + O];
  }
};
var assert$f = minimalisticAssert, inherits$f = inherits_browserExports, Cipher$1 = cipher, DES$2 = des$1;
function EDEState(a, u) {
  assert$f.equal(u.length, 24, "Invalid key length");
  var c = u.slice(0, 8), l = u.slice(8, 16), v = u.slice(16, 24);
  a === "encrypt" ? this.ciphers = [
    DES$2.create({ type: "encrypt", key: c }),
    DES$2.create({ type: "decrypt", key: l }),
    DES$2.create({ type: "encrypt", key: v })
  ] : this.ciphers = [
    DES$2.create({ type: "decrypt", key: v }),
    DES$2.create({ type: "encrypt", key: l }),
    DES$2.create({ type: "decrypt", key: c })
  ];
}
function EDE(a) {
  Cipher$1.call(this, a);
  var u = new EDEState(this.type, this.options.key);
  this._edeState = u;
}
inherits$f(EDE, Cipher$1);
var ede = EDE;
EDE.create = function a(u) {
  return new EDE(u);
};
EDE.prototype._update = function a(u, c, l, v) {
  var p = this._edeState;
  p.ciphers[0]._update(u, c, l, v), p.ciphers[1]._update(l, v, l, v), p.ciphers[2]._update(l, v, l, v);
};
EDE.prototype._pad = DES$2.prototype._pad;
EDE.prototype._unpad = DES$2.prototype._unpad;
des$2.utils = utils$x;
des$2.Cipher = cipher;
des$2.DES = des$1;
des$2.CBC = cbc$1;
des$2.EDE = ede;
var CipherBase = cipherBase, des = des$2, inherits$e = inherits_browserExports, Buffer$r = safeBufferExports$3.Buffer, modes$4 = {
  "des-ede3-cbc": des.CBC.instantiate(des.EDE),
  "des-ede3": des.EDE,
  "des-ede-cbc": des.CBC.instantiate(des.EDE),
  "des-ede": des.EDE,
  "des-cbc": des.CBC.instantiate(des.DES),
  "des-ecb": des.DES
};
modes$4.des = modes$4["des-cbc"];
modes$4.des3 = modes$4["des-ede3-cbc"];
var browserifyDes = DES$1;
inherits$e(DES$1, CipherBase);
function DES$1(a) {
  CipherBase.call(this);
  var u = a.mode.toLowerCase(), c = modes$4[u], l;
  a.decrypt ? l = "decrypt" : l = "encrypt";
  var v = a.key;
  Buffer$r.isBuffer(v) || (v = Buffer$r.from(v)), (u === "des-ede" || u === "des-ede-cbc") && (v = Buffer$r.concat([v, v.slice(0, 8)]));
  var p = a.iv;
  Buffer$r.isBuffer(p) || (p = Buffer$r.from(p)), this._des = c.create({
    key: v,
    iv: p,
    type: l
  });
}
DES$1.prototype._update = function(a) {
  return Buffer$r.from(this._des.update(a));
};
DES$1.prototype._final = function() {
  return Buffer$r.from(this._des.final());
};
var browser$6 = {}, encrypter = {}, ecb = {};
ecb.encrypt = function(a, u) {
  return a._cipher.encryptBlock(u);
};
ecb.decrypt = function(a, u) {
  return a._cipher.decryptBlock(u);
};
var cbc = {}, bufferXor = function a(u, c) {
  for (var l = Math.min(u.length, c.length), v = new Buffer$O(l), p = 0; p < l; ++p)
    v[p] = u[p] ^ c[p];
  return v;
}, xor$7 = bufferXor;
cbc.encrypt = function(a, u) {
  var c = xor$7(u, a._prev);
  return a._prev = a._cipher.encryptBlock(c), a._prev;
};
cbc.decrypt = function(a, u) {
  var c = a._prev;
  a._prev = u;
  var l = a._cipher.decryptBlock(u);
  return xor$7(l, c);
};
var cfb = {}, Buffer$q = safeBufferExports$3.Buffer, xor$6 = bufferXor;
function encryptStart(a, u, c) {
  var l = u.length, v = xor$6(u, a._cache);
  return a._cache = a._cache.slice(l), a._prev = Buffer$q.concat([a._prev, c ? u : v]), v;
}
cfb.encrypt = function(a, u, c) {
  for (var l = Buffer$q.allocUnsafe(0), v; u.length; )
    if (a._cache.length === 0 && (a._cache = a._cipher.encryptBlock(a._prev), a._prev = Buffer$q.allocUnsafe(0)), a._cache.length <= u.length)
      v = a._cache.length, l = Buffer$q.concat([l, encryptStart(a, u.slice(0, v), c)]), u = u.slice(v);
    else {
      l = Buffer$q.concat([l, encryptStart(a, u, c)]);
      break;
    }
  return l;
};
var cfb8 = {}, Buffer$p = safeBufferExports$3.Buffer;
function encryptByte$1(a, u, c) {
  var l = a._cipher.encryptBlock(a._prev), v = l[0] ^ u;
  return a._prev = Buffer$p.concat([
    a._prev.slice(1),
    Buffer$p.from([c ? u : v])
  ]), v;
}
cfb8.encrypt = function(a, u, c) {
  for (var l = u.length, v = Buffer$p.allocUnsafe(l), p = -1; ++p < l; )
    v[p] = encryptByte$1(a, u[p], c);
  return v;
};
var cfb1 = {}, Buffer$o = safeBufferExports$3.Buffer;
function encryptByte(a, u, c) {
  for (var l, v = -1, p = 8, _ = 0, k, O; ++v < p; )
    l = a._cipher.encryptBlock(a._prev), k = u & 1 << 7 - v ? 128 : 0, O = l[0] ^ k, _ += (O & 128) >> v % 8, a._prev = shiftIn(a._prev, c ? k : O);
  return _;
}
function shiftIn(a, u) {
  var c = a.length, l = -1, v = Buffer$o.allocUnsafe(a.length);
  for (a = Buffer$o.concat([a, Buffer$o.from([u])]); ++l < c; )
    v[l] = a[l] << 1 | a[l + 1] >> 7;
  return v;
}
cfb1.encrypt = function(a, u, c) {
  for (var l = u.length, v = Buffer$o.allocUnsafe(l), p = -1; ++p < l; )
    v[p] = encryptByte(a, u[p], c);
  return v;
};
var ofb = {}, xor$5 = bufferXor;
function getBlock$1(a) {
  return a._prev = a._cipher.encryptBlock(a._prev), a._prev;
}
ofb.encrypt = function(a, u) {
  for (; a._cache.length < u.length; )
    a._cache = Buffer$O.concat([a._cache, getBlock$1(a)]);
  var c = a._cache.slice(0, u.length);
  return a._cache = a._cache.slice(u.length), xor$5(u, c);
};
var ctr = {};
function incr32$2(a) {
  for (var u = a.length, c; u--; )
    if (c = a.readUInt8(u), c === 255)
      a.writeUInt8(0, u);
    else {
      c++, a.writeUInt8(c, u);
      break;
    }
}
var incr32_1 = incr32$2, xor$4 = bufferXor, Buffer$n = safeBufferExports$3.Buffer, incr32$1 = incr32_1;
function getBlock(a) {
  var u = a._cipher.encryptBlockRaw(a._prev);
  return incr32$1(a._prev), u;
}
var blockSize = 16;
ctr.encrypt = function(a, u) {
  var c = Math.ceil(u.length / blockSize), l = a._cache.length;
  a._cache = Buffer$n.concat([
    a._cache,
    Buffer$n.allocUnsafe(c * blockSize)
  ]);
  for (var v = 0; v < c; v++) {
    var p = getBlock(a), _ = l + v * blockSize;
    a._cache.writeUInt32BE(p[0], _ + 0), a._cache.writeUInt32BE(p[1], _ + 4), a._cache.writeUInt32BE(p[2], _ + 8), a._cache.writeUInt32BE(p[3], _ + 12);
  }
  var k = a._cache.slice(0, u.length);
  return a._cache = a._cache.slice(u.length), xor$4(u, k);
};
const aes128 = {
  cipher: "AES",
  key: 128,
  iv: 16,
  mode: "CBC",
  type: "block"
}, aes192 = {
  cipher: "AES",
  key: 192,
  iv: 16,
  mode: "CBC",
  type: "block"
}, aes256 = {
  cipher: "AES",
  key: 256,
  iv: 16,
  mode: "CBC",
  type: "block"
}, require$$2 = {
  "aes-128-ecb": {
    cipher: "AES",
    key: 128,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-192-ecb": {
    cipher: "AES",
    key: 192,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-256-ecb": {
    cipher: "AES",
    key: 256,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-128-cbc": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-192-cbc": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-256-cbc": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  aes128,
  aes192,
  aes256,
  "aes-128-cfb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-192-cfb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-256-cfb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-128-cfb8": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-192-cfb8": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-256-cfb8": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-128-cfb1": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-192-cfb1": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-256-cfb1": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-128-ofb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-192-ofb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-256-ofb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-128-ctr": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-192-ctr": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-256-ctr": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-128-gcm": {
    cipher: "AES",
    key: 128,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-192-gcm": {
    cipher: "AES",
    key: 192,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-256-gcm": {
    cipher: "AES",
    key: 256,
    iv: 12,
    mode: "GCM",
    type: "auth"
  }
};
var modeModules = {
  ECB: ecb,
  CBC: cbc,
  CFB: cfb,
  CFB8: cfb8,
  CFB1: cfb1,
  OFB: ofb,
  CTR: ctr,
  GCM: ctr
}, modes$3 = require$$2;
for (var key$3 in modes$3)
  modes$3[key$3].module = modeModules[modes$3[key$3].mode];
var modes_1 = modes$3, aes$5 = {}, Buffer$m = safeBufferExports$3.Buffer;
function asUInt32Array(a) {
  Buffer$m.isBuffer(a) || (a = Buffer$m.from(a));
  for (var u = a.length / 4 | 0, c = new Array(u), l = 0; l < u; l++)
    c[l] = a.readUInt32BE(l * 4);
  return c;
}
function scrubVec(a) {
  for (var u = 0; u < a.length; a++)
    a[u] = 0;
}
function cryptBlock(a, u, c, l, v) {
  for (var p = c[0], _ = c[1], k = c[2], O = c[3], D = a[0] ^ u[0], F = a[1] ^ u[1], H = a[2] ^ u[2], Z = a[3] ^ u[3], ee, X, ne, Q, ae = 4, j = 1; j < v; j++)
    ee = p[D >>> 24] ^ _[F >>> 16 & 255] ^ k[H >>> 8 & 255] ^ O[Z & 255] ^ u[ae++], X = p[F >>> 24] ^ _[H >>> 16 & 255] ^ k[Z >>> 8 & 255] ^ O[D & 255] ^ u[ae++], ne = p[H >>> 24] ^ _[Z >>> 16 & 255] ^ k[D >>> 8 & 255] ^ O[F & 255] ^ u[ae++], Q = p[Z >>> 24] ^ _[D >>> 16 & 255] ^ k[F >>> 8 & 255] ^ O[H & 255] ^ u[ae++], D = ee, F = X, H = ne, Z = Q;
  return ee = (l[D >>> 24] << 24 | l[F >>> 16 & 255] << 16 | l[H >>> 8 & 255] << 8 | l[Z & 255]) ^ u[ae++], X = (l[F >>> 24] << 24 | l[H >>> 16 & 255] << 16 | l[Z >>> 8 & 255] << 8 | l[D & 255]) ^ u[ae++], ne = (l[H >>> 24] << 24 | l[Z >>> 16 & 255] << 16 | l[D >>> 8 & 255] << 8 | l[F & 255]) ^ u[ae++], Q = (l[Z >>> 24] << 24 | l[D >>> 16 & 255] << 16 | l[F >>> 8 & 255] << 8 | l[H & 255]) ^ u[ae++], ee = ee >>> 0, X = X >>> 0, ne = ne >>> 0, Q = Q >>> 0, [ee, X, ne, Q];
}
var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], G = function() {
  for (var a = new Array(256), u = 0; u < 256; u++)
    u < 128 ? a[u] = u << 1 : a[u] = u << 1 ^ 283;
  for (var c = [], l = [], v = [[], [], [], []], p = [[], [], [], []], _ = 0, k = 0, O = 0; O < 256; ++O) {
    var D = k ^ k << 1 ^ k << 2 ^ k << 3 ^ k << 4;
    D = D >>> 8 ^ D & 255 ^ 99, c[_] = D, l[D] = _;
    var F = a[_], H = a[F], Z = a[H], ee = a[D] * 257 ^ D * 16843008;
    v[0][_] = ee << 24 | ee >>> 8, v[1][_] = ee << 16 | ee >>> 16, v[2][_] = ee << 8 | ee >>> 24, v[3][_] = ee, ee = Z * 16843009 ^ H * 65537 ^ F * 257 ^ _ * 16843008, p[0][D] = ee << 24 | ee >>> 8, p[1][D] = ee << 16 | ee >>> 16, p[2][D] = ee << 8 | ee >>> 24, p[3][D] = ee, _ === 0 ? _ = k = 1 : (_ = F ^ a[a[a[Z ^ F]]], k ^= a[a[k]]);
  }
  return {
    SBOX: c,
    INV_SBOX: l,
    SUB_MIX: v,
    INV_SUB_MIX: p
  };
}();
function AES(a) {
  this._key = asUInt32Array(a), this._reset();
}
AES.blockSize = 4 * 4;
AES.keySize = 256 / 8;
AES.prototype.blockSize = AES.blockSize;
AES.prototype.keySize = AES.keySize;
AES.prototype._reset = function() {
  for (var a = this._key, u = a.length, c = u + 6, l = (c + 1) * 4, v = [], p = 0; p < u; p++)
    v[p] = a[p];
  for (p = u; p < l; p++) {
    var _ = v[p - 1];
    p % u === 0 ? (_ = _ << 8 | _ >>> 24, _ = G.SBOX[_ >>> 24] << 24 | G.SBOX[_ >>> 16 & 255] << 16 | G.SBOX[_ >>> 8 & 255] << 8 | G.SBOX[_ & 255], _ ^= RCON[p / u | 0] << 24) : u > 6 && p % u === 4 && (_ = G.SBOX[_ >>> 24] << 24 | G.SBOX[_ >>> 16 & 255] << 16 | G.SBOX[_ >>> 8 & 255] << 8 | G.SBOX[_ & 255]), v[p] = v[p - u] ^ _;
  }
  for (var k = [], O = 0; O < l; O++) {
    var D = l - O, F = v[D - (O % 4 ? 0 : 4)];
    O < 4 || D <= 4 ? k[O] = F : k[O] = G.INV_SUB_MIX[0][G.SBOX[F >>> 24]] ^ G.INV_SUB_MIX[1][G.SBOX[F >>> 16 & 255]] ^ G.INV_SUB_MIX[2][G.SBOX[F >>> 8 & 255]] ^ G.INV_SUB_MIX[3][G.SBOX[F & 255]];
  }
  this._nRounds = c, this._keySchedule = v, this._invKeySchedule = k;
};
AES.prototype.encryptBlockRaw = function(a) {
  return a = asUInt32Array(a), cryptBlock(a, this._keySchedule, G.SUB_MIX, G.SBOX, this._nRounds);
};
AES.prototype.encryptBlock = function(a) {
  var u = this.encryptBlockRaw(a), c = Buffer$m.allocUnsafe(16);
  return c.writeUInt32BE(u[0], 0), c.writeUInt32BE(u[1], 4), c.writeUInt32BE(u[2], 8), c.writeUInt32BE(u[3], 12), c;
};
AES.prototype.decryptBlock = function(a) {
  a = asUInt32Array(a);
  var u = a[1];
  a[1] = a[3], a[3] = u;
  var c = cryptBlock(a, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX, this._nRounds), l = Buffer$m.allocUnsafe(16);
  return l.writeUInt32BE(c[0], 0), l.writeUInt32BE(c[3], 4), l.writeUInt32BE(c[2], 8), l.writeUInt32BE(c[1], 12), l;
};
AES.prototype.scrub = function() {
  scrubVec(this._keySchedule), scrubVec(this._invKeySchedule), scrubVec(this._key);
};
aes$5.AES = AES;
var Buffer$l = safeBufferExports$3.Buffer, ZEROES = Buffer$l.alloc(16, 0);
function toArray$1(a) {
  return [
    a.readUInt32BE(0),
    a.readUInt32BE(4),
    a.readUInt32BE(8),
    a.readUInt32BE(12)
  ];
}
function fromArray(a) {
  var u = Buffer$l.allocUnsafe(16);
  return u.writeUInt32BE(a[0] >>> 0, 0), u.writeUInt32BE(a[1] >>> 0, 4), u.writeUInt32BE(a[2] >>> 0, 8), u.writeUInt32BE(a[3] >>> 0, 12), u;
}
function GHASH$1(a) {
  this.h = a, this.state = Buffer$l.alloc(16, 0), this.cache = Buffer$l.allocUnsafe(0);
}
GHASH$1.prototype.ghash = function(a) {
  for (var u = -1; ++u < a.length; )
    this.state[u] ^= a[u];
  this._multiply();
};
GHASH$1.prototype._multiply = function() {
  for (var a = toArray$1(this.h), u = [0, 0, 0, 0], c, l, v, p = -1; ++p < 128; ) {
    for (l = (this.state[~~(p / 8)] & 1 << 7 - p % 8) !== 0, l && (u[0] ^= a[0], u[1] ^= a[1], u[2] ^= a[2], u[3] ^= a[3]), v = (a[3] & 1) !== 0, c = 3; c > 0; c--)
      a[c] = a[c] >>> 1 | (a[c - 1] & 1) << 31;
    a[0] = a[0] >>> 1, v && (a[0] = a[0] ^ 225 << 24);
  }
  this.state = fromArray(u);
};
GHASH$1.prototype.update = function(a) {
  this.cache = Buffer$l.concat([this.cache, a]);
  for (var u; this.cache.length >= 16; )
    u = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(u);
};
GHASH$1.prototype.final = function(a, u) {
  return this.cache.length && this.ghash(Buffer$l.concat([this.cache, ZEROES], 16)), this.ghash(fromArray([0, a, 0, u])), this.state;
};
var ghash = GHASH$1, aes$4 = aes$5, Buffer$k = safeBufferExports$3.Buffer, Transform$5 = cipherBase, inherits$d = inherits_browserExports, GHASH = ghash, xor$3 = bufferXor, incr32 = incr32_1;
function xorTest(a, u) {
  var c = 0;
  a.length !== u.length && c++;
  for (var l = Math.min(a.length, u.length), v = 0; v < l; ++v)
    c += a[v] ^ u[v];
  return c;
}
function calcIv(a, u, c) {
  if (u.length === 12)
    return a._finID = Buffer$k.concat([u, Buffer$k.from([0, 0, 0, 1])]), Buffer$k.concat([u, Buffer$k.from([0, 0, 0, 2])]);
  var l = new GHASH(c), v = u.length, p = v % 16;
  l.update(u), p && (p = 16 - p, l.update(Buffer$k.alloc(p, 0))), l.update(Buffer$k.alloc(8, 0));
  var _ = v * 8, k = Buffer$k.alloc(8);
  k.writeUIntBE(_, 0, 8), l.update(k), a._finID = l.state;
  var O = Buffer$k.from(a._finID);
  return incr32(O), O;
}
function StreamCipher$3(a, u, c, l) {
  Transform$5.call(this);
  var v = Buffer$k.alloc(4, 0);
  this._cipher = new aes$4.AES(u);
  var p = this._cipher.encryptBlock(v);
  this._ghash = new GHASH(p), c = calcIv(this, c, p), this._prev = Buffer$k.from(c), this._cache = Buffer$k.allocUnsafe(0), this._secCache = Buffer$k.allocUnsafe(0), this._decrypt = l, this._alen = 0, this._len = 0, this._mode = a, this._authTag = null, this._called = !1;
}
inherits$d(StreamCipher$3, Transform$5);
StreamCipher$3.prototype._update = function(a) {
  if (!this._called && this._alen) {
    var u = 16 - this._alen % 16;
    u < 16 && (u = Buffer$k.alloc(u, 0), this._ghash.update(u));
  }
  this._called = !0;
  var c = this._mode.encrypt(this, a);
  return this._decrypt ? this._ghash.update(a) : this._ghash.update(c), this._len += a.length, c;
};
StreamCipher$3.prototype._final = function() {
  if (this._decrypt && !this._authTag)
    throw new Error("Unsupported state or unable to authenticate data");
  var a = xor$3(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
  if (this._decrypt && xorTest(a, this._authTag))
    throw new Error("Unsupported state or unable to authenticate data");
  this._authTag = a, this._cipher.scrub();
};
StreamCipher$3.prototype.getAuthTag = function a() {
  if (this._decrypt || !Buffer$k.isBuffer(this._authTag))
    throw new Error("Attempting to get auth tag in unsupported state");
  return this._authTag;
};
StreamCipher$3.prototype.setAuthTag = function a(u) {
  if (!this._decrypt)
    throw new Error("Attempting to set auth tag in unsupported state");
  this._authTag = u;
};
StreamCipher$3.prototype.setAAD = function a(u) {
  if (this._called)
    throw new Error("Attempting to set AAD in unsupported state");
  this._ghash.update(u), this._alen += u.length;
};
var authCipher = StreamCipher$3, aes$3 = aes$5, Buffer$j = safeBufferExports$3.Buffer, Transform$4 = cipherBase, inherits$c = inherits_browserExports;
function StreamCipher$2(a, u, c, l) {
  Transform$4.call(this), this._cipher = new aes$3.AES(u), this._prev = Buffer$j.from(c), this._cache = Buffer$j.allocUnsafe(0), this._secCache = Buffer$j.allocUnsafe(0), this._decrypt = l, this._mode = a;
}
inherits$c(StreamCipher$2, Transform$4);
StreamCipher$2.prototype._update = function(a) {
  return this._mode.encrypt(this, a, this._decrypt);
};
StreamCipher$2.prototype._final = function() {
  this._cipher.scrub();
};
var streamCipher = StreamCipher$2, Buffer$i = safeBufferExports$3.Buffer, MD5 = md5_js;
function EVP_BytesToKey(a, u, c, l) {
  if (Buffer$i.isBuffer(a) || (a = Buffer$i.from(a, "binary")), u && (Buffer$i.isBuffer(u) || (u = Buffer$i.from(u, "binary")), u.length !== 8))
    throw new RangeError("salt should be Buffer with 8 byte length");
  for (var v = c / 8, p = Buffer$i.alloc(v), _ = Buffer$i.alloc(l || 0), k = Buffer$i.alloc(0); v > 0 || l > 0; ) {
    var O = new MD5();
    O.update(k), O.update(a), u && O.update(u), k = O.digest();
    var D = 0;
    if (v > 0) {
      var F = p.length - v;
      D = Math.min(v, k.length), k.copy(p, F, 0, D), v -= D;
    }
    if (D < k.length && l > 0) {
      var H = _.length - l, Z = Math.min(l, k.length - D);
      k.copy(_, H, D, D + Z), l -= Z;
    }
  }
  return k.fill(0), { key: p, iv: _ };
}
var evp_bytestokey = EVP_BytesToKey, MODES$1 = modes_1, AuthCipher$1 = authCipher, Buffer$h = safeBufferExports$3.Buffer, StreamCipher$1 = streamCipher, Transform$3 = cipherBase, aes$2 = aes$5, ebtk$2 = evp_bytestokey, inherits$b = inherits_browserExports;
function Cipher(a, u, c) {
  Transform$3.call(this), this._cache = new Splitter$1(), this._cipher = new aes$2.AES(u), this._prev = Buffer$h.from(c), this._mode = a, this._autopadding = !0;
}
inherits$b(Cipher, Transform$3);
Cipher.prototype._update = function(a) {
  this._cache.add(a);
  for (var u, c, l = []; u = this._cache.get(); )
    c = this._mode.encrypt(this, u), l.push(c);
  return Buffer$h.concat(l);
};
var PADDING$1 = Buffer$h.alloc(16, 16);
Cipher.prototype._final = function() {
  var a = this._cache.flush();
  if (this._autopadding)
    return a = this._mode.encrypt(this, a), this._cipher.scrub(), a;
  if (!a.equals(PADDING$1))
    throw this._cipher.scrub(), new Error("data not multiple of block length");
};
Cipher.prototype.setAutoPadding = function(a) {
  return this._autopadding = !!a, this;
};
function Splitter$1() {
  this.cache = Buffer$h.allocUnsafe(0);
}
Splitter$1.prototype.add = function(a) {
  this.cache = Buffer$h.concat([this.cache, a]);
};
Splitter$1.prototype.get = function() {
  if (this.cache.length > 15) {
    var a = this.cache.slice(0, 16);
    return this.cache = this.cache.slice(16), a;
  }
  return null;
};
Splitter$1.prototype.flush = function() {
  for (var a = 16 - this.cache.length, u = Buffer$h.allocUnsafe(a), c = -1; ++c < a; )
    u.writeUInt8(a, c);
  return Buffer$h.concat([this.cache, u]);
};
function createCipheriv$1(a, u, c) {
  var l = MODES$1[a.toLowerCase()];
  if (!l)
    throw new TypeError("invalid suite type");
  if (typeof u == "string" && (u = Buffer$h.from(u)), u.length !== l.key / 8)
    throw new TypeError("invalid key length " + u.length);
  if (typeof c == "string" && (c = Buffer$h.from(c)), l.mode !== "GCM" && c.length !== l.iv)
    throw new TypeError("invalid iv length " + c.length);
  return l.type === "stream" ? new StreamCipher$1(l.module, u, c) : l.type === "auth" ? new AuthCipher$1(l.module, u, c) : new Cipher(l.module, u, c);
}
function createCipher$1(a, u) {
  var c = MODES$1[a.toLowerCase()];
  if (!c)
    throw new TypeError("invalid suite type");
  var l = ebtk$2(u, !1, c.key, c.iv);
  return createCipheriv$1(a, l.key, l.iv);
}
encrypter.createCipheriv = createCipheriv$1;
encrypter.createCipher = createCipher$1;
var decrypter = {}, AuthCipher = authCipher, Buffer$g = safeBufferExports$3.Buffer, MODES = modes_1, StreamCipher = streamCipher, Transform$2 = cipherBase, aes$1 = aes$5, ebtk$1 = evp_bytestokey, inherits$a = inherits_browserExports;
function Decipher(a, u, c) {
  Transform$2.call(this), this._cache = new Splitter(), this._last = void 0, this._cipher = new aes$1.AES(u), this._prev = Buffer$g.from(c), this._mode = a, this._autopadding = !0;
}
inherits$a(Decipher, Transform$2);
Decipher.prototype._update = function(a) {
  this._cache.add(a);
  for (var u, c, l = []; u = this._cache.get(this._autopadding); )
    c = this._mode.decrypt(this, u), l.push(c);
  return Buffer$g.concat(l);
};
Decipher.prototype._final = function() {
  var a = this._cache.flush();
  if (this._autopadding)
    return unpad(this._mode.decrypt(this, a));
  if (a)
    throw new Error("data not multiple of block length");
};
Decipher.prototype.setAutoPadding = function(a) {
  return this._autopadding = !!a, this;
};
function Splitter() {
  this.cache = Buffer$g.allocUnsafe(0);
}
Splitter.prototype.add = function(a) {
  this.cache = Buffer$g.concat([this.cache, a]);
};
Splitter.prototype.get = function(a) {
  var u;
  if (a) {
    if (this.cache.length > 16)
      return u = this.cache.slice(0, 16), this.cache = this.cache.slice(16), u;
  } else if (this.cache.length >= 16)
    return u = this.cache.slice(0, 16), this.cache = this.cache.slice(16), u;
  return null;
};
Splitter.prototype.flush = function() {
  if (this.cache.length)
    return this.cache;
};
function unpad(a) {
  var u = a[15];
  if (u < 1 || u > 16)
    throw new Error("unable to decrypt data");
  for (var c = -1; ++c < u; )
    if (a[c + (16 - u)] !== u)
      throw new Error("unable to decrypt data");
  if (u !== 16)
    return a.slice(0, 16 - u);
}
function createDecipheriv$1(a, u, c) {
  var l = MODES[a.toLowerCase()];
  if (!l)
    throw new TypeError("invalid suite type");
  if (typeof c == "string" && (c = Buffer$g.from(c)), l.mode !== "GCM" && c.length !== l.iv)
    throw new TypeError("invalid iv length " + c.length);
  if (typeof u == "string" && (u = Buffer$g.from(u)), u.length !== l.key / 8)
    throw new TypeError("invalid key length " + u.length);
  return l.type === "stream" ? new StreamCipher(l.module, u, c, !0) : l.type === "auth" ? new AuthCipher(l.module, u, c, !0) : new Decipher(l.module, u, c);
}
function createDecipher$1(a, u) {
  var c = MODES[a.toLowerCase()];
  if (!c)
    throw new TypeError("invalid suite type");
  var l = ebtk$1(u, !1, c.key, c.iv);
  return createDecipheriv$1(a, l.key, l.iv);
}
decrypter.createDecipher = createDecipher$1;
decrypter.createDecipheriv = createDecipheriv$1;
var ciphers$2 = encrypter, deciphers = decrypter, modes$2 = require$$2;
function getCiphers$1() {
  return Object.keys(modes$2);
}
browser$6.createCipher = browser$6.Cipher = ciphers$2.createCipher;
browser$6.createCipheriv = browser$6.Cipheriv = ciphers$2.createCipheriv;
browser$6.createDecipher = browser$6.Decipher = deciphers.createDecipher;
browser$6.createDecipheriv = browser$6.Decipheriv = deciphers.createDecipheriv;
browser$6.listCiphers = browser$6.getCiphers = getCiphers$1;
var modes$1 = {};
(function(a) {
  a["des-ecb"] = {
    key: 8,
    iv: 0
  }, a["des-cbc"] = a.des = {
    key: 8,
    iv: 8
  }, a["des-ede3-cbc"] = a.des3 = {
    key: 24,
    iv: 8
  }, a["des-ede3"] = {
    key: 24,
    iv: 0
  }, a["des-ede-cbc"] = {
    key: 16,
    iv: 8
  }, a["des-ede"] = {
    key: 16,
    iv: 0
  };
})(modes$1);
var DES = browserifyDes, aes = browser$6, aesModes = modes_1, desModes = modes$1, ebtk = evp_bytestokey;
function createCipher(a, u) {
  a = a.toLowerCase();
  var c, l;
  if (aesModes[a])
    c = aesModes[a].key, l = aesModes[a].iv;
  else if (desModes[a])
    c = desModes[a].key * 8, l = desModes[a].iv;
  else
    throw new TypeError("invalid suite type");
  var v = ebtk(u, !1, c, l);
  return createCipheriv(a, v.key, v.iv);
}
function createDecipher(a, u) {
  a = a.toLowerCase();
  var c, l;
  if (aesModes[a])
    c = aesModes[a].key, l = aesModes[a].iv;
  else if (desModes[a])
    c = desModes[a].key * 8, l = desModes[a].iv;
  else
    throw new TypeError("invalid suite type");
  var v = ebtk(u, !1, c, l);
  return createDecipheriv(a, v.key, v.iv);
}
function createCipheriv(a, u, c) {
  if (a = a.toLowerCase(), aesModes[a])
    return aes.createCipheriv(a, u, c);
  if (desModes[a])
    return new DES({ key: u, iv: c, mode: a });
  throw new TypeError("invalid suite type");
}
function createDecipheriv(a, u, c) {
  if (a = a.toLowerCase(), aesModes[a])
    return aes.createDecipheriv(a, u, c);
  if (desModes[a])
    return new DES({ key: u, iv: c, mode: a, decrypt: !0 });
  throw new TypeError("invalid suite type");
}
function getCiphers() {
  return Object.keys(desModes).concat(aes.getCiphers());
}
browser$7.createCipher = browser$7.Cipher = createCipher;
browser$7.createCipheriv = browser$7.Cipheriv = createCipheriv;
browser$7.createDecipher = browser$7.Decipher = createDecipher;
browser$7.createDecipheriv = browser$7.Decipheriv = createDecipheriv;
browser$7.listCiphers = browser$7.getCiphers = getCiphers;
var browser$5 = {}, bn$6 = { exports: {} };
bn$6.exports;
(function(a) {
  (function(u, c) {
    function l(P, S) {
      if (!P)
        throw new Error(S || "Assertion failed");
    }
    function v(P, S) {
      P.super_ = S;
      var E = function() {
      };
      E.prototype = S.prototype, P.prototype = new E(), P.prototype.constructor = P;
    }
    function p(P, S, E) {
      if (p.isBN(P))
        return P;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, P !== null && ((S === "le" || S === "be") && (E = S, S = 10), this._init(P || 0, S || 10, E || "be"));
    }
    typeof u == "object" ? u.exports = p : c.BN = p, p.BN = p, p.wordSize = 26;
    var _;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? _ = window.Buffer : _ = require$$0$2.Buffer;
    } catch {
    }
    p.isBN = function(S) {
      return S instanceof p ? !0 : S !== null && typeof S == "object" && S.constructor.wordSize === p.wordSize && Array.isArray(S.words);
    }, p.max = function(S, E) {
      return S.cmp(E) > 0 ? S : E;
    }, p.min = function(S, E) {
      return S.cmp(E) < 0 ? S : E;
    }, p.prototype._init = function(S, E, I) {
      if (typeof S == "number")
        return this._initNumber(S, E, I);
      if (typeof S == "object")
        return this._initArray(S, E, I);
      E === "hex" && (E = 16), l(E === (E | 0) && E >= 2 && E <= 36), S = S.toString().replace(/\s+/g, "");
      var M = 0;
      S[0] === "-" && (M++, this.negative = 1), M < S.length && (E === 16 ? this._parseHex(S, M, I) : (this._parseBase(S, E, M), I === "le" && this._initArray(this.toArray(), E, I)));
    }, p.prototype._initNumber = function(S, E, I) {
      S < 0 && (this.negative = 1, S = -S), S < 67108864 ? (this.words = [S & 67108863], this.length = 1) : S < 4503599627370496 ? (this.words = [
        S & 67108863,
        S / 67108864 & 67108863
      ], this.length = 2) : (l(S < 9007199254740992), this.words = [
        S & 67108863,
        S / 67108864 & 67108863,
        1
      ], this.length = 3), I === "le" && this._initArray(this.toArray(), E, I);
    }, p.prototype._initArray = function(S, E, I) {
      if (l(typeof S.length == "number"), S.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(S.length / 3), this.words = new Array(this.length);
      for (var M = 0; M < this.length; M++)
        this.words[M] = 0;
      var $, U, Y = 0;
      if (I === "be")
        for (M = S.length - 1, $ = 0; M >= 0; M -= 3)
          U = S[M] | S[M - 1] << 8 | S[M - 2] << 16, this.words[$] |= U << Y & 67108863, this.words[$ + 1] = U >>> 26 - Y & 67108863, Y += 24, Y >= 26 && (Y -= 26, $++);
      else if (I === "le")
        for (M = 0, $ = 0; M < S.length; M += 3)
          U = S[M] | S[M + 1] << 8 | S[M + 2] << 16, this.words[$] |= U << Y & 67108863, this.words[$ + 1] = U >>> 26 - Y & 67108863, Y += 24, Y >= 26 && (Y -= 26, $++);
      return this.strip();
    };
    function k(P, S) {
      var E = P.charCodeAt(S);
      return E >= 65 && E <= 70 ? E - 55 : E >= 97 && E <= 102 ? E - 87 : E - 48 & 15;
    }
    function O(P, S, E) {
      var I = k(P, E);
      return E - 1 >= S && (I |= k(P, E - 1) << 4), I;
    }
    p.prototype._parseHex = function(S, E, I) {
      this.length = Math.ceil((S.length - E) / 6), this.words = new Array(this.length);
      for (var M = 0; M < this.length; M++)
        this.words[M] = 0;
      var $ = 0, U = 0, Y;
      if (I === "be")
        for (M = S.length - 1; M >= E; M -= 2)
          Y = O(S, E, M) << $, this.words[U] |= Y & 67108863, $ >= 18 ? ($ -= 18, U += 1, this.words[U] |= Y >>> 26) : $ += 8;
      else {
        var B = S.length - E;
        for (M = B % 2 === 0 ? E + 1 : E; M < S.length; M += 2)
          Y = O(S, E, M) << $, this.words[U] |= Y & 67108863, $ >= 18 ? ($ -= 18, U += 1, this.words[U] |= Y >>> 26) : $ += 8;
      }
      this.strip();
    };
    function D(P, S, E, I) {
      for (var M = 0, $ = Math.min(P.length, E), U = S; U < $; U++) {
        var Y = P.charCodeAt(U) - 48;
        M *= I, Y >= 49 ? M += Y - 49 + 10 : Y >= 17 ? M += Y - 17 + 10 : M += Y;
      }
      return M;
    }
    p.prototype._parseBase = function(S, E, I) {
      this.words = [0], this.length = 1;
      for (var M = 0, $ = 1; $ <= 67108863; $ *= E)
        M++;
      M--, $ = $ / E | 0;
      for (var U = S.length - I, Y = U % M, B = Math.min(U, U - Y) + I, T = 0, L = I; L < B; L += M)
        T = D(S, L, L + M, E), this.imuln($), this.words[0] + T < 67108864 ? this.words[0] += T : this._iaddn(T);
      if (Y !== 0) {
        var te = 1;
        for (T = D(S, L, S.length, E), L = 0; L < Y; L++)
          te *= E;
        this.imuln(te), this.words[0] + T < 67108864 ? this.words[0] += T : this._iaddn(T);
      }
      this.strip();
    }, p.prototype.copy = function(S) {
      S.words = new Array(this.length);
      for (var E = 0; E < this.length; E++)
        S.words[E] = this.words[E];
      S.length = this.length, S.negative = this.negative, S.red = this.red;
    }, p.prototype.clone = function() {
      var S = new p(null);
      return this.copy(S), S;
    }, p.prototype._expand = function(S) {
      for (; this.length < S; )
        this.words[this.length++] = 0;
      return this;
    }, p.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, p.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, p.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var F = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], H = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], Z = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    p.prototype.toString = function(S, E) {
      S = S || 10, E = E | 0 || 1;
      var I;
      if (S === 16 || S === "hex") {
        I = "";
        for (var M = 0, $ = 0, U = 0; U < this.length; U++) {
          var Y = this.words[U], B = ((Y << M | $) & 16777215).toString(16);
          $ = Y >>> 24 - M & 16777215, $ !== 0 || U !== this.length - 1 ? I = F[6 - B.length] + B + I : I = B + I, M += 2, M >= 26 && (M -= 26, U--);
        }
        for ($ !== 0 && (I = $.toString(16) + I); I.length % E !== 0; )
          I = "0" + I;
        return this.negative !== 0 && (I = "-" + I), I;
      }
      if (S === (S | 0) && S >= 2 && S <= 36) {
        var T = H[S], L = Z[S];
        I = "";
        var te = this.clone();
        for (te.negative = 0; !te.isZero(); ) {
          var me = te.modn(L).toString(S);
          te = te.idivn(L), te.isZero() ? I = me + I : I = F[T - me.length] + me + I;
        }
        for (this.isZero() && (I = "0" + I); I.length % E !== 0; )
          I = "0" + I;
        return this.negative !== 0 && (I = "-" + I), I;
      }
      l(!1, "Base should be between 2 and 36");
    }, p.prototype.toNumber = function() {
      var S = this.words[0];
      return this.length === 2 ? S += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? S += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && l(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -S : S;
    }, p.prototype.toJSON = function() {
      return this.toString(16);
    }, p.prototype.toBuffer = function(S, E) {
      return l(typeof _ < "u"), this.toArrayLike(_, S, E);
    }, p.prototype.toArray = function(S, E) {
      return this.toArrayLike(Array, S, E);
    }, p.prototype.toArrayLike = function(S, E, I) {
      var M = this.byteLength(), $ = I || Math.max(1, M);
      l(M <= $, "byte array longer than desired length"), l($ > 0, "Requested array length <= 0"), this.strip();
      var U = E === "le", Y = new S($), B, T, L = this.clone();
      if (U) {
        for (T = 0; !L.isZero(); T++)
          B = L.andln(255), L.iushrn(8), Y[T] = B;
        for (; T < $; T++)
          Y[T] = 0;
      } else {
        for (T = 0; T < $ - M; T++)
          Y[T] = 0;
        for (T = 0; !L.isZero(); T++)
          B = L.andln(255), L.iushrn(8), Y[$ - T - 1] = B;
      }
      return Y;
    }, Math.clz32 ? p.prototype._countBits = function(S) {
      return 32 - Math.clz32(S);
    } : p.prototype._countBits = function(S) {
      var E = S, I = 0;
      return E >= 4096 && (I += 13, E >>>= 13), E >= 64 && (I += 7, E >>>= 7), E >= 8 && (I += 4, E >>>= 4), E >= 2 && (I += 2, E >>>= 2), I + E;
    }, p.prototype._zeroBits = function(S) {
      if (S === 0)
        return 26;
      var E = S, I = 0;
      return E & 8191 || (I += 13, E >>>= 13), E & 127 || (I += 7, E >>>= 7), E & 15 || (I += 4, E >>>= 4), E & 3 || (I += 2, E >>>= 2), E & 1 || I++, I;
    }, p.prototype.bitLength = function() {
      var S = this.words[this.length - 1], E = this._countBits(S);
      return (this.length - 1) * 26 + E;
    };
    function ee(P) {
      for (var S = new Array(P.bitLength()), E = 0; E < S.length; E++) {
        var I = E / 26 | 0, M = E % 26;
        S[E] = (P.words[I] & 1 << M) >>> M;
      }
      return S;
    }
    p.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var S = 0, E = 0; E < this.length; E++) {
        var I = this._zeroBits(this.words[E]);
        if (S += I, I !== 26)
          break;
      }
      return S;
    }, p.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, p.prototype.toTwos = function(S) {
      return this.negative !== 0 ? this.abs().inotn(S).iaddn(1) : this.clone();
    }, p.prototype.fromTwos = function(S) {
      return this.testn(S - 1) ? this.notn(S).iaddn(1).ineg() : this.clone();
    }, p.prototype.isNeg = function() {
      return this.negative !== 0;
    }, p.prototype.neg = function() {
      return this.clone().ineg();
    }, p.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, p.prototype.iuor = function(S) {
      for (; this.length < S.length; )
        this.words[this.length++] = 0;
      for (var E = 0; E < S.length; E++)
        this.words[E] = this.words[E] | S.words[E];
      return this.strip();
    }, p.prototype.ior = function(S) {
      return l((this.negative | S.negative) === 0), this.iuor(S);
    }, p.prototype.or = function(S) {
      return this.length > S.length ? this.clone().ior(S) : S.clone().ior(this);
    }, p.prototype.uor = function(S) {
      return this.length > S.length ? this.clone().iuor(S) : S.clone().iuor(this);
    }, p.prototype.iuand = function(S) {
      var E;
      this.length > S.length ? E = S : E = this;
      for (var I = 0; I < E.length; I++)
        this.words[I] = this.words[I] & S.words[I];
      return this.length = E.length, this.strip();
    }, p.prototype.iand = function(S) {
      return l((this.negative | S.negative) === 0), this.iuand(S);
    }, p.prototype.and = function(S) {
      return this.length > S.length ? this.clone().iand(S) : S.clone().iand(this);
    }, p.prototype.uand = function(S) {
      return this.length > S.length ? this.clone().iuand(S) : S.clone().iuand(this);
    }, p.prototype.iuxor = function(S) {
      var E, I;
      this.length > S.length ? (E = this, I = S) : (E = S, I = this);
      for (var M = 0; M < I.length; M++)
        this.words[M] = E.words[M] ^ I.words[M];
      if (this !== E)
        for (; M < E.length; M++)
          this.words[M] = E.words[M];
      return this.length = E.length, this.strip();
    }, p.prototype.ixor = function(S) {
      return l((this.negative | S.negative) === 0), this.iuxor(S);
    }, p.prototype.xor = function(S) {
      return this.length > S.length ? this.clone().ixor(S) : S.clone().ixor(this);
    }, p.prototype.uxor = function(S) {
      return this.length > S.length ? this.clone().iuxor(S) : S.clone().iuxor(this);
    }, p.prototype.inotn = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = Math.ceil(S / 26) | 0, I = S % 26;
      this._expand(E), I > 0 && E--;
      for (var M = 0; M < E; M++)
        this.words[M] = ~this.words[M] & 67108863;
      return I > 0 && (this.words[M] = ~this.words[M] & 67108863 >> 26 - I), this.strip();
    }, p.prototype.notn = function(S) {
      return this.clone().inotn(S);
    }, p.prototype.setn = function(S, E) {
      l(typeof S == "number" && S >= 0);
      var I = S / 26 | 0, M = S % 26;
      return this._expand(I + 1), E ? this.words[I] = this.words[I] | 1 << M : this.words[I] = this.words[I] & ~(1 << M), this.strip();
    }, p.prototype.iadd = function(S) {
      var E;
      if (this.negative !== 0 && S.negative === 0)
        return this.negative = 0, E = this.isub(S), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && S.negative !== 0)
        return S.negative = 0, E = this.isub(S), S.negative = 1, E._normSign();
      var I, M;
      this.length > S.length ? (I = this, M = S) : (I = S, M = this);
      for (var $ = 0, U = 0; U < M.length; U++)
        E = (I.words[U] | 0) + (M.words[U] | 0) + $, this.words[U] = E & 67108863, $ = E >>> 26;
      for (; $ !== 0 && U < I.length; U++)
        E = (I.words[U] | 0) + $, this.words[U] = E & 67108863, $ = E >>> 26;
      if (this.length = I.length, $ !== 0)
        this.words[this.length] = $, this.length++;
      else if (I !== this)
        for (; U < I.length; U++)
          this.words[U] = I.words[U];
      return this;
    }, p.prototype.add = function(S) {
      var E;
      return S.negative !== 0 && this.negative === 0 ? (S.negative = 0, E = this.sub(S), S.negative ^= 1, E) : S.negative === 0 && this.negative !== 0 ? (this.negative = 0, E = S.sub(this), this.negative = 1, E) : this.length > S.length ? this.clone().iadd(S) : S.clone().iadd(this);
    }, p.prototype.isub = function(S) {
      if (S.negative !== 0) {
        S.negative = 0;
        var E = this.iadd(S);
        return S.negative = 1, E._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(S), this.negative = 1, this._normSign();
      var I = this.cmp(S);
      if (I === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var M, $;
      I > 0 ? (M = this, $ = S) : (M = S, $ = this);
      for (var U = 0, Y = 0; Y < $.length; Y++)
        E = (M.words[Y] | 0) - ($.words[Y] | 0) + U, U = E >> 26, this.words[Y] = E & 67108863;
      for (; U !== 0 && Y < M.length; Y++)
        E = (M.words[Y] | 0) + U, U = E >> 26, this.words[Y] = E & 67108863;
      if (U === 0 && Y < M.length && M !== this)
        for (; Y < M.length; Y++)
          this.words[Y] = M.words[Y];
      return this.length = Math.max(this.length, Y), M !== this && (this.negative = 1), this.strip();
    }, p.prototype.sub = function(S) {
      return this.clone().isub(S);
    };
    function X(P, S, E) {
      E.negative = S.negative ^ P.negative;
      var I = P.length + S.length | 0;
      E.length = I, I = I - 1 | 0;
      var M = P.words[0] | 0, $ = S.words[0] | 0, U = M * $, Y = U & 67108863, B = U / 67108864 | 0;
      E.words[0] = Y;
      for (var T = 1; T < I; T++) {
        for (var L = B >>> 26, te = B & 67108863, me = Math.min(T, S.length - 1), Ce = Math.max(0, T - P.length + 1); Ce <= me; Ce++) {
          var De = T - Ce | 0;
          M = P.words[De] | 0, $ = S.words[Ce] | 0, U = M * $ + te, L += U / 67108864 | 0, te = U & 67108863;
        }
        E.words[T] = te | 0, B = L | 0;
      }
      return B !== 0 ? E.words[T] = B | 0 : E.length--, E.strip();
    }
    var ne = function(S, E, I) {
      var M = S.words, $ = E.words, U = I.words, Y = 0, B, T, L, te = M[0] | 0, me = te & 8191, Ce = te >>> 13, De = M[1] | 0, ye = De & 8191, pe = De >>> 13, Me = M[2] | 0, Ne = Me & 8191, Ue = Me >>> 13, oe = M[3] | 0, A = oe & 8191, re = oe >>> 13, le = M[4] | 0, $e = le & 8191, Oe = le >>> 13, Fe = M[5] | 0, Ze = Fe & 8191, qe = Fe >>> 13, yt = M[6] | 0, Xe = yt & 8191, Ge = yt >>> 13, J = M[7] | 0, ge = J & 8191, we = J >>> 13, We = M[8] | 0, Ie = We & 8191, V = We >>> 13, Ee = M[9] | 0, de = Ee & 8191, ce = Ee >>> 13, ve = $[0] | 0, Pe = ve & 8191, Be = ve >>> 13, ze = $[1] | 0, Je = ze & 8191, je = ze >>> 13, Ke = $[2] | 0, x = Ke & 8191, se = Ke >>> 13, Se = $[3] | 0, xe = Se & 8191, Ae = Se >>> 13, Ye = $[4] | 0, et = Ye & 8191, dt = Ye >>> 13, St = $[5] | 0, tt = St & 8191, at = St >>> 13, kt = $[6] | 0, rt = kt & 8191, ut = kt >>> 13, wt = $[7] | 0, nt = wt & 8191, it = wt >>> 13, bt = $[8] | 0, ot = bt & 8191, ct = bt >>> 13, Pt = $[9] | 0, st = Pt & 8191, lt = Pt >>> 13;
      I.negative = S.negative ^ E.negative, I.length = 19, B = Math.imul(me, Pe), T = Math.imul(me, Be), T = T + Math.imul(Ce, Pe) | 0, L = Math.imul(Ce, Be);
      var It = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (It >>> 26) | 0, It &= 67108863, B = Math.imul(ye, Pe), T = Math.imul(ye, Be), T = T + Math.imul(pe, Pe) | 0, L = Math.imul(pe, Be), B = B + Math.imul(me, Je) | 0, T = T + Math.imul(me, je) | 0, T = T + Math.imul(Ce, Je) | 0, L = L + Math.imul(Ce, je) | 0;
      var Rt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (Rt >>> 26) | 0, Rt &= 67108863, B = Math.imul(Ne, Pe), T = Math.imul(Ne, Be), T = T + Math.imul(Ue, Pe) | 0, L = Math.imul(Ue, Be), B = B + Math.imul(ye, Je) | 0, T = T + Math.imul(ye, je) | 0, T = T + Math.imul(pe, Je) | 0, L = L + Math.imul(pe, je) | 0, B = B + Math.imul(me, x) | 0, T = T + Math.imul(me, se) | 0, T = T + Math.imul(Ce, x) | 0, L = L + Math.imul(Ce, se) | 0;
      var Ve = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, B = Math.imul(A, Pe), T = Math.imul(A, Be), T = T + Math.imul(re, Pe) | 0, L = Math.imul(re, Be), B = B + Math.imul(Ne, Je) | 0, T = T + Math.imul(Ne, je) | 0, T = T + Math.imul(Ue, Je) | 0, L = L + Math.imul(Ue, je) | 0, B = B + Math.imul(ye, x) | 0, T = T + Math.imul(ye, se) | 0, T = T + Math.imul(pe, x) | 0, L = L + Math.imul(pe, se) | 0, B = B + Math.imul(me, xe) | 0, T = T + Math.imul(me, Ae) | 0, T = T + Math.imul(Ce, xe) | 0, L = L + Math.imul(Ce, Ae) | 0;
      var He = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, B = Math.imul($e, Pe), T = Math.imul($e, Be), T = T + Math.imul(Oe, Pe) | 0, L = Math.imul(Oe, Be), B = B + Math.imul(A, Je) | 0, T = T + Math.imul(A, je) | 0, T = T + Math.imul(re, Je) | 0, L = L + Math.imul(re, je) | 0, B = B + Math.imul(Ne, x) | 0, T = T + Math.imul(Ne, se) | 0, T = T + Math.imul(Ue, x) | 0, L = L + Math.imul(Ue, se) | 0, B = B + Math.imul(ye, xe) | 0, T = T + Math.imul(ye, Ae) | 0, T = T + Math.imul(pe, xe) | 0, L = L + Math.imul(pe, Ae) | 0, B = B + Math.imul(me, et) | 0, T = T + Math.imul(me, dt) | 0, T = T + Math.imul(Ce, et) | 0, L = L + Math.imul(Ce, dt) | 0;
      var Qe = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, B = Math.imul(Ze, Pe), T = Math.imul(Ze, Be), T = T + Math.imul(qe, Pe) | 0, L = Math.imul(qe, Be), B = B + Math.imul($e, Je) | 0, T = T + Math.imul($e, je) | 0, T = T + Math.imul(Oe, Je) | 0, L = L + Math.imul(Oe, je) | 0, B = B + Math.imul(A, x) | 0, T = T + Math.imul(A, se) | 0, T = T + Math.imul(re, x) | 0, L = L + Math.imul(re, se) | 0, B = B + Math.imul(Ne, xe) | 0, T = T + Math.imul(Ne, Ae) | 0, T = T + Math.imul(Ue, xe) | 0, L = L + Math.imul(Ue, Ae) | 0, B = B + Math.imul(ye, et) | 0, T = T + Math.imul(ye, dt) | 0, T = T + Math.imul(pe, et) | 0, L = L + Math.imul(pe, dt) | 0, B = B + Math.imul(me, tt) | 0, T = T + Math.imul(me, at) | 0, T = T + Math.imul(Ce, tt) | 0, L = L + Math.imul(Ce, at) | 0;
      var pt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (pt >>> 26) | 0, pt &= 67108863, B = Math.imul(Xe, Pe), T = Math.imul(Xe, Be), T = T + Math.imul(Ge, Pe) | 0, L = Math.imul(Ge, Be), B = B + Math.imul(Ze, Je) | 0, T = T + Math.imul(Ze, je) | 0, T = T + Math.imul(qe, Je) | 0, L = L + Math.imul(qe, je) | 0, B = B + Math.imul($e, x) | 0, T = T + Math.imul($e, se) | 0, T = T + Math.imul(Oe, x) | 0, L = L + Math.imul(Oe, se) | 0, B = B + Math.imul(A, xe) | 0, T = T + Math.imul(A, Ae) | 0, T = T + Math.imul(re, xe) | 0, L = L + Math.imul(re, Ae) | 0, B = B + Math.imul(Ne, et) | 0, T = T + Math.imul(Ne, dt) | 0, T = T + Math.imul(Ue, et) | 0, L = L + Math.imul(Ue, dt) | 0, B = B + Math.imul(ye, tt) | 0, T = T + Math.imul(ye, at) | 0, T = T + Math.imul(pe, tt) | 0, L = L + Math.imul(pe, at) | 0, B = B + Math.imul(me, rt) | 0, T = T + Math.imul(me, ut) | 0, T = T + Math.imul(Ce, rt) | 0, L = L + Math.imul(Ce, ut) | 0;
      var mt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (mt >>> 26) | 0, mt &= 67108863, B = Math.imul(ge, Pe), T = Math.imul(ge, Be), T = T + Math.imul(we, Pe) | 0, L = Math.imul(we, Be), B = B + Math.imul(Xe, Je) | 0, T = T + Math.imul(Xe, je) | 0, T = T + Math.imul(Ge, Je) | 0, L = L + Math.imul(Ge, je) | 0, B = B + Math.imul(Ze, x) | 0, T = T + Math.imul(Ze, se) | 0, T = T + Math.imul(qe, x) | 0, L = L + Math.imul(qe, se) | 0, B = B + Math.imul($e, xe) | 0, T = T + Math.imul($e, Ae) | 0, T = T + Math.imul(Oe, xe) | 0, L = L + Math.imul(Oe, Ae) | 0, B = B + Math.imul(A, et) | 0, T = T + Math.imul(A, dt) | 0, T = T + Math.imul(re, et) | 0, L = L + Math.imul(re, dt) | 0, B = B + Math.imul(Ne, tt) | 0, T = T + Math.imul(Ne, at) | 0, T = T + Math.imul(Ue, tt) | 0, L = L + Math.imul(Ue, at) | 0, B = B + Math.imul(ye, rt) | 0, T = T + Math.imul(ye, ut) | 0, T = T + Math.imul(pe, rt) | 0, L = L + Math.imul(pe, ut) | 0, B = B + Math.imul(me, nt) | 0, T = T + Math.imul(me, it) | 0, T = T + Math.imul(Ce, nt) | 0, L = L + Math.imul(Ce, it) | 0;
      var vt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, B = Math.imul(Ie, Pe), T = Math.imul(Ie, Be), T = T + Math.imul(V, Pe) | 0, L = Math.imul(V, Be), B = B + Math.imul(ge, Je) | 0, T = T + Math.imul(ge, je) | 0, T = T + Math.imul(we, Je) | 0, L = L + Math.imul(we, je) | 0, B = B + Math.imul(Xe, x) | 0, T = T + Math.imul(Xe, se) | 0, T = T + Math.imul(Ge, x) | 0, L = L + Math.imul(Ge, se) | 0, B = B + Math.imul(Ze, xe) | 0, T = T + Math.imul(Ze, Ae) | 0, T = T + Math.imul(qe, xe) | 0, L = L + Math.imul(qe, Ae) | 0, B = B + Math.imul($e, et) | 0, T = T + Math.imul($e, dt) | 0, T = T + Math.imul(Oe, et) | 0, L = L + Math.imul(Oe, dt) | 0, B = B + Math.imul(A, tt) | 0, T = T + Math.imul(A, at) | 0, T = T + Math.imul(re, tt) | 0, L = L + Math.imul(re, at) | 0, B = B + Math.imul(Ne, rt) | 0, T = T + Math.imul(Ne, ut) | 0, T = T + Math.imul(Ue, rt) | 0, L = L + Math.imul(Ue, ut) | 0, B = B + Math.imul(ye, nt) | 0, T = T + Math.imul(ye, it) | 0, T = T + Math.imul(pe, nt) | 0, L = L + Math.imul(pe, it) | 0, B = B + Math.imul(me, ot) | 0, T = T + Math.imul(me, ct) | 0, T = T + Math.imul(Ce, ot) | 0, L = L + Math.imul(Ce, ct) | 0;
      var ht = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (ht >>> 26) | 0, ht &= 67108863, B = Math.imul(de, Pe), T = Math.imul(de, Be), T = T + Math.imul(ce, Pe) | 0, L = Math.imul(ce, Be), B = B + Math.imul(Ie, Je) | 0, T = T + Math.imul(Ie, je) | 0, T = T + Math.imul(V, Je) | 0, L = L + Math.imul(V, je) | 0, B = B + Math.imul(ge, x) | 0, T = T + Math.imul(ge, se) | 0, T = T + Math.imul(we, x) | 0, L = L + Math.imul(we, se) | 0, B = B + Math.imul(Xe, xe) | 0, T = T + Math.imul(Xe, Ae) | 0, T = T + Math.imul(Ge, xe) | 0, L = L + Math.imul(Ge, Ae) | 0, B = B + Math.imul(Ze, et) | 0, T = T + Math.imul(Ze, dt) | 0, T = T + Math.imul(qe, et) | 0, L = L + Math.imul(qe, dt) | 0, B = B + Math.imul($e, tt) | 0, T = T + Math.imul($e, at) | 0, T = T + Math.imul(Oe, tt) | 0, L = L + Math.imul(Oe, at) | 0, B = B + Math.imul(A, rt) | 0, T = T + Math.imul(A, ut) | 0, T = T + Math.imul(re, rt) | 0, L = L + Math.imul(re, ut) | 0, B = B + Math.imul(Ne, nt) | 0, T = T + Math.imul(Ne, it) | 0, T = T + Math.imul(Ue, nt) | 0, L = L + Math.imul(Ue, it) | 0, B = B + Math.imul(ye, ot) | 0, T = T + Math.imul(ye, ct) | 0, T = T + Math.imul(pe, ot) | 0, L = L + Math.imul(pe, ct) | 0, B = B + Math.imul(me, st) | 0, T = T + Math.imul(me, lt) | 0, T = T + Math.imul(Ce, st) | 0, L = L + Math.imul(Ce, lt) | 0;
      var Et = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, B = Math.imul(de, Je), T = Math.imul(de, je), T = T + Math.imul(ce, Je) | 0, L = Math.imul(ce, je), B = B + Math.imul(Ie, x) | 0, T = T + Math.imul(Ie, se) | 0, T = T + Math.imul(V, x) | 0, L = L + Math.imul(V, se) | 0, B = B + Math.imul(ge, xe) | 0, T = T + Math.imul(ge, Ae) | 0, T = T + Math.imul(we, xe) | 0, L = L + Math.imul(we, Ae) | 0, B = B + Math.imul(Xe, et) | 0, T = T + Math.imul(Xe, dt) | 0, T = T + Math.imul(Ge, et) | 0, L = L + Math.imul(Ge, dt) | 0, B = B + Math.imul(Ze, tt) | 0, T = T + Math.imul(Ze, at) | 0, T = T + Math.imul(qe, tt) | 0, L = L + Math.imul(qe, at) | 0, B = B + Math.imul($e, rt) | 0, T = T + Math.imul($e, ut) | 0, T = T + Math.imul(Oe, rt) | 0, L = L + Math.imul(Oe, ut) | 0, B = B + Math.imul(A, nt) | 0, T = T + Math.imul(A, it) | 0, T = T + Math.imul(re, nt) | 0, L = L + Math.imul(re, it) | 0, B = B + Math.imul(Ne, ot) | 0, T = T + Math.imul(Ne, ct) | 0, T = T + Math.imul(Ue, ot) | 0, L = L + Math.imul(Ue, ct) | 0, B = B + Math.imul(ye, st) | 0, T = T + Math.imul(ye, lt) | 0, T = T + Math.imul(pe, st) | 0, L = L + Math.imul(pe, lt) | 0;
      var Tt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (Tt >>> 26) | 0, Tt &= 67108863, B = Math.imul(de, x), T = Math.imul(de, se), T = T + Math.imul(ce, x) | 0, L = Math.imul(ce, se), B = B + Math.imul(Ie, xe) | 0, T = T + Math.imul(Ie, Ae) | 0, T = T + Math.imul(V, xe) | 0, L = L + Math.imul(V, Ae) | 0, B = B + Math.imul(ge, et) | 0, T = T + Math.imul(ge, dt) | 0, T = T + Math.imul(we, et) | 0, L = L + Math.imul(we, dt) | 0, B = B + Math.imul(Xe, tt) | 0, T = T + Math.imul(Xe, at) | 0, T = T + Math.imul(Ge, tt) | 0, L = L + Math.imul(Ge, at) | 0, B = B + Math.imul(Ze, rt) | 0, T = T + Math.imul(Ze, ut) | 0, T = T + Math.imul(qe, rt) | 0, L = L + Math.imul(qe, ut) | 0, B = B + Math.imul($e, nt) | 0, T = T + Math.imul($e, it) | 0, T = T + Math.imul(Oe, nt) | 0, L = L + Math.imul(Oe, it) | 0, B = B + Math.imul(A, ot) | 0, T = T + Math.imul(A, ct) | 0, T = T + Math.imul(re, ot) | 0, L = L + Math.imul(re, ct) | 0, B = B + Math.imul(Ne, st) | 0, T = T + Math.imul(Ne, lt) | 0, T = T + Math.imul(Ue, st) | 0, L = L + Math.imul(Ue, lt) | 0;
      var Ot = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (Ot >>> 26) | 0, Ot &= 67108863, B = Math.imul(de, xe), T = Math.imul(de, Ae), T = T + Math.imul(ce, xe) | 0, L = Math.imul(ce, Ae), B = B + Math.imul(Ie, et) | 0, T = T + Math.imul(Ie, dt) | 0, T = T + Math.imul(V, et) | 0, L = L + Math.imul(V, dt) | 0, B = B + Math.imul(ge, tt) | 0, T = T + Math.imul(ge, at) | 0, T = T + Math.imul(we, tt) | 0, L = L + Math.imul(we, at) | 0, B = B + Math.imul(Xe, rt) | 0, T = T + Math.imul(Xe, ut) | 0, T = T + Math.imul(Ge, rt) | 0, L = L + Math.imul(Ge, ut) | 0, B = B + Math.imul(Ze, nt) | 0, T = T + Math.imul(Ze, it) | 0, T = T + Math.imul(qe, nt) | 0, L = L + Math.imul(qe, it) | 0, B = B + Math.imul($e, ot) | 0, T = T + Math.imul($e, ct) | 0, T = T + Math.imul(Oe, ot) | 0, L = L + Math.imul(Oe, ct) | 0, B = B + Math.imul(A, st) | 0, T = T + Math.imul(A, lt) | 0, T = T + Math.imul(re, st) | 0, L = L + Math.imul(re, lt) | 0;
      var Nt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, B = Math.imul(de, et), T = Math.imul(de, dt), T = T + Math.imul(ce, et) | 0, L = Math.imul(ce, dt), B = B + Math.imul(Ie, tt) | 0, T = T + Math.imul(Ie, at) | 0, T = T + Math.imul(V, tt) | 0, L = L + Math.imul(V, at) | 0, B = B + Math.imul(ge, rt) | 0, T = T + Math.imul(ge, ut) | 0, T = T + Math.imul(we, rt) | 0, L = L + Math.imul(we, ut) | 0, B = B + Math.imul(Xe, nt) | 0, T = T + Math.imul(Xe, it) | 0, T = T + Math.imul(Ge, nt) | 0, L = L + Math.imul(Ge, it) | 0, B = B + Math.imul(Ze, ot) | 0, T = T + Math.imul(Ze, ct) | 0, T = T + Math.imul(qe, ot) | 0, L = L + Math.imul(qe, ct) | 0, B = B + Math.imul($e, st) | 0, T = T + Math.imul($e, lt) | 0, T = T + Math.imul(Oe, st) | 0, L = L + Math.imul(Oe, lt) | 0;
      var At = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, B = Math.imul(de, tt), T = Math.imul(de, at), T = T + Math.imul(ce, tt) | 0, L = Math.imul(ce, at), B = B + Math.imul(Ie, rt) | 0, T = T + Math.imul(Ie, ut) | 0, T = T + Math.imul(V, rt) | 0, L = L + Math.imul(V, ut) | 0, B = B + Math.imul(ge, nt) | 0, T = T + Math.imul(ge, it) | 0, T = T + Math.imul(we, nt) | 0, L = L + Math.imul(we, it) | 0, B = B + Math.imul(Xe, ot) | 0, T = T + Math.imul(Xe, ct) | 0, T = T + Math.imul(Ge, ot) | 0, L = L + Math.imul(Ge, ct) | 0, B = B + Math.imul(Ze, st) | 0, T = T + Math.imul(Ze, lt) | 0, T = T + Math.imul(qe, st) | 0, L = L + Math.imul(qe, lt) | 0;
      var Mt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (Mt >>> 26) | 0, Mt &= 67108863, B = Math.imul(de, rt), T = Math.imul(de, ut), T = T + Math.imul(ce, rt) | 0, L = Math.imul(ce, ut), B = B + Math.imul(Ie, nt) | 0, T = T + Math.imul(Ie, it) | 0, T = T + Math.imul(V, nt) | 0, L = L + Math.imul(V, it) | 0, B = B + Math.imul(ge, ot) | 0, T = T + Math.imul(ge, ct) | 0, T = T + Math.imul(we, ot) | 0, L = L + Math.imul(we, ct) | 0, B = B + Math.imul(Xe, st) | 0, T = T + Math.imul(Xe, lt) | 0, T = T + Math.imul(Ge, st) | 0, L = L + Math.imul(Ge, lt) | 0;
      var $t = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + ($t >>> 26) | 0, $t &= 67108863, B = Math.imul(de, nt), T = Math.imul(de, it), T = T + Math.imul(ce, nt) | 0, L = Math.imul(ce, it), B = B + Math.imul(Ie, ot) | 0, T = T + Math.imul(Ie, ct) | 0, T = T + Math.imul(V, ot) | 0, L = L + Math.imul(V, ct) | 0, B = B + Math.imul(ge, st) | 0, T = T + Math.imul(ge, lt) | 0, T = T + Math.imul(we, st) | 0, L = L + Math.imul(we, lt) | 0;
      var Bt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, B = Math.imul(de, ot), T = Math.imul(de, ct), T = T + Math.imul(ce, ot) | 0, L = Math.imul(ce, ct), B = B + Math.imul(Ie, st) | 0, T = T + Math.imul(Ie, lt) | 0, T = T + Math.imul(V, st) | 0, L = L + Math.imul(V, lt) | 0;
      var Ut = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (Ut >>> 26) | 0, Ut &= 67108863, B = Math.imul(de, st), T = Math.imul(de, lt), T = T + Math.imul(ce, st) | 0, L = Math.imul(ce, lt);
      var xt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      return Y = (L + (T >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, U[0] = It, U[1] = Rt, U[2] = Ve, U[3] = He, U[4] = Qe, U[5] = pt, U[6] = mt, U[7] = vt, U[8] = ht, U[9] = Et, U[10] = Tt, U[11] = Ot, U[12] = Nt, U[13] = At, U[14] = Mt, U[15] = $t, U[16] = Bt, U[17] = Ut, U[18] = xt, Y !== 0 && (U[19] = Y, I.length++), I;
    };
    Math.imul || (ne = X);
    function Q(P, S, E) {
      E.negative = S.negative ^ P.negative, E.length = P.length + S.length;
      for (var I = 0, M = 0, $ = 0; $ < E.length - 1; $++) {
        var U = M;
        M = 0;
        for (var Y = I & 67108863, B = Math.min($, S.length - 1), T = Math.max(0, $ - P.length + 1); T <= B; T++) {
          var L = $ - T, te = P.words[L] | 0, me = S.words[T] | 0, Ce = te * me, De = Ce & 67108863;
          U = U + (Ce / 67108864 | 0) | 0, De = De + Y | 0, Y = De & 67108863, U = U + (De >>> 26) | 0, M += U >>> 26, U &= 67108863;
        }
        E.words[$] = Y, I = U, U = M;
      }
      return I !== 0 ? E.words[$] = I : E.length--, E.strip();
    }
    function ae(P, S, E) {
      var I = new j();
      return I.mulp(P, S, E);
    }
    p.prototype.mulTo = function(S, E) {
      var I, M = this.length + S.length;
      return this.length === 10 && S.length === 10 ? I = ne(this, S, E) : M < 63 ? I = X(this, S, E) : M < 1024 ? I = Q(this, S, E) : I = ae(this, S, E), I;
    };
    function j(P, S) {
      this.x = P, this.y = S;
    }
    j.prototype.makeRBT = function(S) {
      for (var E = new Array(S), I = p.prototype._countBits(S) - 1, M = 0; M < S; M++)
        E[M] = this.revBin(M, I, S);
      return E;
    }, j.prototype.revBin = function(S, E, I) {
      if (S === 0 || S === I - 1)
        return S;
      for (var M = 0, $ = 0; $ < E; $++)
        M |= (S & 1) << E - $ - 1, S >>= 1;
      return M;
    }, j.prototype.permute = function(S, E, I, M, $, U) {
      for (var Y = 0; Y < U; Y++)
        M[Y] = E[S[Y]], $[Y] = I[S[Y]];
    }, j.prototype.transform = function(S, E, I, M, $, U) {
      this.permute(U, S, E, I, M, $);
      for (var Y = 1; Y < $; Y <<= 1)
        for (var B = Y << 1, T = Math.cos(2 * Math.PI / B), L = Math.sin(2 * Math.PI / B), te = 0; te < $; te += B)
          for (var me = T, Ce = L, De = 0; De < Y; De++) {
            var ye = I[te + De], pe = M[te + De], Me = I[te + De + Y], Ne = M[te + De + Y], Ue = me * Me - Ce * Ne;
            Ne = me * Ne + Ce * Me, Me = Ue, I[te + De] = ye + Me, M[te + De] = pe + Ne, I[te + De + Y] = ye - Me, M[te + De + Y] = pe - Ne, De !== B && (Ue = T * me - L * Ce, Ce = T * Ce + L * me, me = Ue);
          }
    }, j.prototype.guessLen13b = function(S, E) {
      var I = Math.max(E, S) | 1, M = I & 1, $ = 0;
      for (I = I / 2 | 0; I; I = I >>> 1)
        $++;
      return 1 << $ + 1 + M;
    }, j.prototype.conjugate = function(S, E, I) {
      if (!(I <= 1))
        for (var M = 0; M < I / 2; M++) {
          var $ = S[M];
          S[M] = S[I - M - 1], S[I - M - 1] = $, $ = E[M], E[M] = -E[I - M - 1], E[I - M - 1] = -$;
        }
    }, j.prototype.normalize13b = function(S, E) {
      for (var I = 0, M = 0; M < E / 2; M++) {
        var $ = Math.round(S[2 * M + 1] / E) * 8192 + Math.round(S[2 * M] / E) + I;
        S[M] = $ & 67108863, $ < 67108864 ? I = 0 : I = $ / 67108864 | 0;
      }
      return S;
    }, j.prototype.convert13b = function(S, E, I, M) {
      for (var $ = 0, U = 0; U < E; U++)
        $ = $ + (S[U] | 0), I[2 * U] = $ & 8191, $ = $ >>> 13, I[2 * U + 1] = $ & 8191, $ = $ >>> 13;
      for (U = 2 * E; U < M; ++U)
        I[U] = 0;
      l($ === 0), l(($ & -8192) === 0);
    }, j.prototype.stub = function(S) {
      for (var E = new Array(S), I = 0; I < S; I++)
        E[I] = 0;
      return E;
    }, j.prototype.mulp = function(S, E, I) {
      var M = 2 * this.guessLen13b(S.length, E.length), $ = this.makeRBT(M), U = this.stub(M), Y = new Array(M), B = new Array(M), T = new Array(M), L = new Array(M), te = new Array(M), me = new Array(M), Ce = I.words;
      Ce.length = M, this.convert13b(S.words, S.length, Y, M), this.convert13b(E.words, E.length, L, M), this.transform(Y, U, B, T, M, $), this.transform(L, U, te, me, M, $);
      for (var De = 0; De < M; De++) {
        var ye = B[De] * te[De] - T[De] * me[De];
        T[De] = B[De] * me[De] + T[De] * te[De], B[De] = ye;
      }
      return this.conjugate(B, T, M), this.transform(B, T, Ce, U, M, $), this.conjugate(Ce, U, M), this.normalize13b(Ce, M), I.negative = S.negative ^ E.negative, I.length = S.length + E.length, I.strip();
    }, p.prototype.mul = function(S) {
      var E = new p(null);
      return E.words = new Array(this.length + S.length), this.mulTo(S, E);
    }, p.prototype.mulf = function(S) {
      var E = new p(null);
      return E.words = new Array(this.length + S.length), ae(this, S, E);
    }, p.prototype.imul = function(S) {
      return this.clone().mulTo(S, this);
    }, p.prototype.imuln = function(S) {
      l(typeof S == "number"), l(S < 67108864);
      for (var E = 0, I = 0; I < this.length; I++) {
        var M = (this.words[I] | 0) * S, $ = (M & 67108863) + (E & 67108863);
        E >>= 26, E += M / 67108864 | 0, E += $ >>> 26, this.words[I] = $ & 67108863;
      }
      return E !== 0 && (this.words[I] = E, this.length++), this;
    }, p.prototype.muln = function(S) {
      return this.clone().imuln(S);
    }, p.prototype.sqr = function() {
      return this.mul(this);
    }, p.prototype.isqr = function() {
      return this.imul(this.clone());
    }, p.prototype.pow = function(S) {
      var E = ee(S);
      if (E.length === 0)
        return new p(1);
      for (var I = this, M = 0; M < E.length && E[M] === 0; M++, I = I.sqr())
        ;
      if (++M < E.length)
        for (var $ = I.sqr(); M < E.length; M++, $ = $.sqr())
          E[M] !== 0 && (I = I.mul($));
      return I;
    }, p.prototype.iushln = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = S % 26, I = (S - E) / 26, M = 67108863 >>> 26 - E << 26 - E, $;
      if (E !== 0) {
        var U = 0;
        for ($ = 0; $ < this.length; $++) {
          var Y = this.words[$] & M, B = (this.words[$] | 0) - Y << E;
          this.words[$] = B | U, U = Y >>> 26 - E;
        }
        U && (this.words[$] = U, this.length++);
      }
      if (I !== 0) {
        for ($ = this.length - 1; $ >= 0; $--)
          this.words[$ + I] = this.words[$];
        for ($ = 0; $ < I; $++)
          this.words[$] = 0;
        this.length += I;
      }
      return this.strip();
    }, p.prototype.ishln = function(S) {
      return l(this.negative === 0), this.iushln(S);
    }, p.prototype.iushrn = function(S, E, I) {
      l(typeof S == "number" && S >= 0);
      var M;
      E ? M = (E - E % 26) / 26 : M = 0;
      var $ = S % 26, U = Math.min((S - $) / 26, this.length), Y = 67108863 ^ 67108863 >>> $ << $, B = I;
      if (M -= U, M = Math.max(0, M), B) {
        for (var T = 0; T < U; T++)
          B.words[T] = this.words[T];
        B.length = U;
      }
      if (U !== 0)
        if (this.length > U)
          for (this.length -= U, T = 0; T < this.length; T++)
            this.words[T] = this.words[T + U];
        else
          this.words[0] = 0, this.length = 1;
      var L = 0;
      for (T = this.length - 1; T >= 0 && (L !== 0 || T >= M); T--) {
        var te = this.words[T] | 0;
        this.words[T] = L << 26 - $ | te >>> $, L = te & Y;
      }
      return B && L !== 0 && (B.words[B.length++] = L), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, p.prototype.ishrn = function(S, E, I) {
      return l(this.negative === 0), this.iushrn(S, E, I);
    }, p.prototype.shln = function(S) {
      return this.clone().ishln(S);
    }, p.prototype.ushln = function(S) {
      return this.clone().iushln(S);
    }, p.prototype.shrn = function(S) {
      return this.clone().ishrn(S);
    }, p.prototype.ushrn = function(S) {
      return this.clone().iushrn(S);
    }, p.prototype.testn = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = S % 26, I = (S - E) / 26, M = 1 << E;
      if (this.length <= I)
        return !1;
      var $ = this.words[I];
      return !!($ & M);
    }, p.prototype.imaskn = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = S % 26, I = (S - E) / 26;
      if (l(this.negative === 0, "imaskn works only with positive numbers"), this.length <= I)
        return this;
      if (E !== 0 && I++, this.length = Math.min(I, this.length), E !== 0) {
        var M = 67108863 ^ 67108863 >>> E << E;
        this.words[this.length - 1] &= M;
      }
      return this.strip();
    }, p.prototype.maskn = function(S) {
      return this.clone().imaskn(S);
    }, p.prototype.iaddn = function(S) {
      return l(typeof S == "number"), l(S < 67108864), S < 0 ? this.isubn(-S) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < S ? (this.words[0] = S - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(S), this.negative = 1, this) : this._iaddn(S);
    }, p.prototype._iaddn = function(S) {
      this.words[0] += S;
      for (var E = 0; E < this.length && this.words[E] >= 67108864; E++)
        this.words[E] -= 67108864, E === this.length - 1 ? this.words[E + 1] = 1 : this.words[E + 1]++;
      return this.length = Math.max(this.length, E + 1), this;
    }, p.prototype.isubn = function(S) {
      if (l(typeof S == "number"), l(S < 67108864), S < 0)
        return this.iaddn(-S);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(S), this.negative = 1, this;
      if (this.words[0] -= S, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var E = 0; E < this.length && this.words[E] < 0; E++)
          this.words[E] += 67108864, this.words[E + 1] -= 1;
      return this.strip();
    }, p.prototype.addn = function(S) {
      return this.clone().iaddn(S);
    }, p.prototype.subn = function(S) {
      return this.clone().isubn(S);
    }, p.prototype.iabs = function() {
      return this.negative = 0, this;
    }, p.prototype.abs = function() {
      return this.clone().iabs();
    }, p.prototype._ishlnsubmul = function(S, E, I) {
      var M = S.length + I, $;
      this._expand(M);
      var U, Y = 0;
      for ($ = 0; $ < S.length; $++) {
        U = (this.words[$ + I] | 0) + Y;
        var B = (S.words[$] | 0) * E;
        U -= B & 67108863, Y = (U >> 26) - (B / 67108864 | 0), this.words[$ + I] = U & 67108863;
      }
      for (; $ < this.length - I; $++)
        U = (this.words[$ + I] | 0) + Y, Y = U >> 26, this.words[$ + I] = U & 67108863;
      if (Y === 0)
        return this.strip();
      for (l(Y === -1), Y = 0, $ = 0; $ < this.length; $++)
        U = -(this.words[$] | 0) + Y, Y = U >> 26, this.words[$] = U & 67108863;
      return this.negative = 1, this.strip();
    }, p.prototype._wordDiv = function(S, E) {
      var I = this.length - S.length, M = this.clone(), $ = S, U = $.words[$.length - 1] | 0, Y = this._countBits(U);
      I = 26 - Y, I !== 0 && ($ = $.ushln(I), M.iushln(I), U = $.words[$.length - 1] | 0);
      var B = M.length - $.length, T;
      if (E !== "mod") {
        T = new p(null), T.length = B + 1, T.words = new Array(T.length);
        for (var L = 0; L < T.length; L++)
          T.words[L] = 0;
      }
      var te = M.clone()._ishlnsubmul($, 1, B);
      te.negative === 0 && (M = te, T && (T.words[B] = 1));
      for (var me = B - 1; me >= 0; me--) {
        var Ce = (M.words[$.length + me] | 0) * 67108864 + (M.words[$.length + me - 1] | 0);
        for (Ce = Math.min(Ce / U | 0, 67108863), M._ishlnsubmul($, Ce, me); M.negative !== 0; )
          Ce--, M.negative = 0, M._ishlnsubmul($, 1, me), M.isZero() || (M.negative ^= 1);
        T && (T.words[me] = Ce);
      }
      return T && T.strip(), M.strip(), E !== "div" && I !== 0 && M.iushrn(I), {
        div: T || null,
        mod: M
      };
    }, p.prototype.divmod = function(S, E, I) {
      if (l(!S.isZero()), this.isZero())
        return {
          div: new p(0),
          mod: new p(0)
        };
      var M, $, U;
      return this.negative !== 0 && S.negative === 0 ? (U = this.neg().divmod(S, E), E !== "mod" && (M = U.div.neg()), E !== "div" && ($ = U.mod.neg(), I && $.negative !== 0 && $.iadd(S)), {
        div: M,
        mod: $
      }) : this.negative === 0 && S.negative !== 0 ? (U = this.divmod(S.neg(), E), E !== "mod" && (M = U.div.neg()), {
        div: M,
        mod: U.mod
      }) : this.negative & S.negative ? (U = this.neg().divmod(S.neg(), E), E !== "div" && ($ = U.mod.neg(), I && $.negative !== 0 && $.isub(S)), {
        div: U.div,
        mod: $
      }) : S.length > this.length || this.cmp(S) < 0 ? {
        div: new p(0),
        mod: this
      } : S.length === 1 ? E === "div" ? {
        div: this.divn(S.words[0]),
        mod: null
      } : E === "mod" ? {
        div: null,
        mod: new p(this.modn(S.words[0]))
      } : {
        div: this.divn(S.words[0]),
        mod: new p(this.modn(S.words[0]))
      } : this._wordDiv(S, E);
    }, p.prototype.div = function(S) {
      return this.divmod(S, "div", !1).div;
    }, p.prototype.mod = function(S) {
      return this.divmod(S, "mod", !1).mod;
    }, p.prototype.umod = function(S) {
      return this.divmod(S, "mod", !0).mod;
    }, p.prototype.divRound = function(S) {
      var E = this.divmod(S);
      if (E.mod.isZero())
        return E.div;
      var I = E.div.negative !== 0 ? E.mod.isub(S) : E.mod, M = S.ushrn(1), $ = S.andln(1), U = I.cmp(M);
      return U < 0 || $ === 1 && U === 0 ? E.div : E.div.negative !== 0 ? E.div.isubn(1) : E.div.iaddn(1);
    }, p.prototype.modn = function(S) {
      l(S <= 67108863);
      for (var E = (1 << 26) % S, I = 0, M = this.length - 1; M >= 0; M--)
        I = (E * I + (this.words[M] | 0)) % S;
      return I;
    }, p.prototype.idivn = function(S) {
      l(S <= 67108863);
      for (var E = 0, I = this.length - 1; I >= 0; I--) {
        var M = (this.words[I] | 0) + E * 67108864;
        this.words[I] = M / S | 0, E = M % S;
      }
      return this.strip();
    }, p.prototype.divn = function(S) {
      return this.clone().idivn(S);
    }, p.prototype.egcd = function(S) {
      l(S.negative === 0), l(!S.isZero());
      var E = this, I = S.clone();
      E.negative !== 0 ? E = E.umod(S) : E = E.clone();
      for (var M = new p(1), $ = new p(0), U = new p(0), Y = new p(1), B = 0; E.isEven() && I.isEven(); )
        E.iushrn(1), I.iushrn(1), ++B;
      for (var T = I.clone(), L = E.clone(); !E.isZero(); ) {
        for (var te = 0, me = 1; !(E.words[0] & me) && te < 26; ++te, me <<= 1)
          ;
        if (te > 0)
          for (E.iushrn(te); te-- > 0; )
            (M.isOdd() || $.isOdd()) && (M.iadd(T), $.isub(L)), M.iushrn(1), $.iushrn(1);
        for (var Ce = 0, De = 1; !(I.words[0] & De) && Ce < 26; ++Ce, De <<= 1)
          ;
        if (Ce > 0)
          for (I.iushrn(Ce); Ce-- > 0; )
            (U.isOdd() || Y.isOdd()) && (U.iadd(T), Y.isub(L)), U.iushrn(1), Y.iushrn(1);
        E.cmp(I) >= 0 ? (E.isub(I), M.isub(U), $.isub(Y)) : (I.isub(E), U.isub(M), Y.isub($));
      }
      return {
        a: U,
        b: Y,
        gcd: I.iushln(B)
      };
    }, p.prototype._invmp = function(S) {
      l(S.negative === 0), l(!S.isZero());
      var E = this, I = S.clone();
      E.negative !== 0 ? E = E.umod(S) : E = E.clone();
      for (var M = new p(1), $ = new p(0), U = I.clone(); E.cmpn(1) > 0 && I.cmpn(1) > 0; ) {
        for (var Y = 0, B = 1; !(E.words[0] & B) && Y < 26; ++Y, B <<= 1)
          ;
        if (Y > 0)
          for (E.iushrn(Y); Y-- > 0; )
            M.isOdd() && M.iadd(U), M.iushrn(1);
        for (var T = 0, L = 1; !(I.words[0] & L) && T < 26; ++T, L <<= 1)
          ;
        if (T > 0)
          for (I.iushrn(T); T-- > 0; )
            $.isOdd() && $.iadd(U), $.iushrn(1);
        E.cmp(I) >= 0 ? (E.isub(I), M.isub($)) : (I.isub(E), $.isub(M));
      }
      var te;
      return E.cmpn(1) === 0 ? te = M : te = $, te.cmpn(0) < 0 && te.iadd(S), te;
    }, p.prototype.gcd = function(S) {
      if (this.isZero())
        return S.abs();
      if (S.isZero())
        return this.abs();
      var E = this.clone(), I = S.clone();
      E.negative = 0, I.negative = 0;
      for (var M = 0; E.isEven() && I.isEven(); M++)
        E.iushrn(1), I.iushrn(1);
      do {
        for (; E.isEven(); )
          E.iushrn(1);
        for (; I.isEven(); )
          I.iushrn(1);
        var $ = E.cmp(I);
        if ($ < 0) {
          var U = E;
          E = I, I = U;
        } else if ($ === 0 || I.cmpn(1) === 0)
          break;
        E.isub(I);
      } while (!0);
      return I.iushln(M);
    }, p.prototype.invm = function(S) {
      return this.egcd(S).a.umod(S);
    }, p.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, p.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, p.prototype.andln = function(S) {
      return this.words[0] & S;
    }, p.prototype.bincn = function(S) {
      l(typeof S == "number");
      var E = S % 26, I = (S - E) / 26, M = 1 << E;
      if (this.length <= I)
        return this._expand(I + 1), this.words[I] |= M, this;
      for (var $ = M, U = I; $ !== 0 && U < this.length; U++) {
        var Y = this.words[U] | 0;
        Y += $, $ = Y >>> 26, Y &= 67108863, this.words[U] = Y;
      }
      return $ !== 0 && (this.words[U] = $, this.length++), this;
    }, p.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, p.prototype.cmpn = function(S) {
      var E = S < 0;
      if (this.negative !== 0 && !E)
        return -1;
      if (this.negative === 0 && E)
        return 1;
      this.strip();
      var I;
      if (this.length > 1)
        I = 1;
      else {
        E && (S = -S), l(S <= 67108863, "Number is too big");
        var M = this.words[0] | 0;
        I = M === S ? 0 : M < S ? -1 : 1;
      }
      return this.negative !== 0 ? -I | 0 : I;
    }, p.prototype.cmp = function(S) {
      if (this.negative !== 0 && S.negative === 0)
        return -1;
      if (this.negative === 0 && S.negative !== 0)
        return 1;
      var E = this.ucmp(S);
      return this.negative !== 0 ? -E | 0 : E;
    }, p.prototype.ucmp = function(S) {
      if (this.length > S.length)
        return 1;
      if (this.length < S.length)
        return -1;
      for (var E = 0, I = this.length - 1; I >= 0; I--) {
        var M = this.words[I] | 0, $ = S.words[I] | 0;
        if (M !== $) {
          M < $ ? E = -1 : M > $ && (E = 1);
          break;
        }
      }
      return E;
    }, p.prototype.gtn = function(S) {
      return this.cmpn(S) === 1;
    }, p.prototype.gt = function(S) {
      return this.cmp(S) === 1;
    }, p.prototype.gten = function(S) {
      return this.cmpn(S) >= 0;
    }, p.prototype.gte = function(S) {
      return this.cmp(S) >= 0;
    }, p.prototype.ltn = function(S) {
      return this.cmpn(S) === -1;
    }, p.prototype.lt = function(S) {
      return this.cmp(S) === -1;
    }, p.prototype.lten = function(S) {
      return this.cmpn(S) <= 0;
    }, p.prototype.lte = function(S) {
      return this.cmp(S) <= 0;
    }, p.prototype.eqn = function(S) {
      return this.cmpn(S) === 0;
    }, p.prototype.eq = function(S) {
      return this.cmp(S) === 0;
    }, p.red = function(S) {
      return new q(S);
    }, p.prototype.toRed = function(S) {
      return l(!this.red, "Already a number in reduction context"), l(this.negative === 0, "red works only with positives"), S.convertTo(this)._forceRed(S);
    }, p.prototype.fromRed = function() {
      return l(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, p.prototype._forceRed = function(S) {
      return this.red = S, this;
    }, p.prototype.forceRed = function(S) {
      return l(!this.red, "Already a number in reduction context"), this._forceRed(S);
    }, p.prototype.redAdd = function(S) {
      return l(this.red, "redAdd works only with red numbers"), this.red.add(this, S);
    }, p.prototype.redIAdd = function(S) {
      return l(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, S);
    }, p.prototype.redSub = function(S) {
      return l(this.red, "redSub works only with red numbers"), this.red.sub(this, S);
    }, p.prototype.redISub = function(S) {
      return l(this.red, "redISub works only with red numbers"), this.red.isub(this, S);
    }, p.prototype.redShl = function(S) {
      return l(this.red, "redShl works only with red numbers"), this.red.shl(this, S);
    }, p.prototype.redMul = function(S) {
      return l(this.red, "redMul works only with red numbers"), this.red._verify2(this, S), this.red.mul(this, S);
    }, p.prototype.redIMul = function(S) {
      return l(this.red, "redMul works only with red numbers"), this.red._verify2(this, S), this.red.imul(this, S);
    }, p.prototype.redSqr = function() {
      return l(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, p.prototype.redISqr = function() {
      return l(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, p.prototype.redSqrt = function() {
      return l(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, p.prototype.redInvm = function() {
      return l(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, p.prototype.redNeg = function() {
      return l(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, p.prototype.redPow = function(S) {
      return l(this.red && !S.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, S);
    };
    var ue = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function he(P, S) {
      this.name = P, this.p = new p(S, 16), this.n = this.p.bitLength(), this.k = new p(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    he.prototype._tmp = function() {
      var S = new p(null);
      return S.words = new Array(Math.ceil(this.n / 13)), S;
    }, he.prototype.ireduce = function(S) {
      var E = S, I;
      do
        this.split(E, this.tmp), E = this.imulK(E), E = E.iadd(this.tmp), I = E.bitLength();
      while (I > this.n);
      var M = I < this.n ? -1 : E.ucmp(this.p);
      return M === 0 ? (E.words[0] = 0, E.length = 1) : M > 0 ? E.isub(this.p) : E.strip !== void 0 ? E.strip() : E._strip(), E;
    }, he.prototype.split = function(S, E) {
      S.iushrn(this.n, 0, E);
    }, he.prototype.imulK = function(S) {
      return S.imul(this.k);
    };
    function fe() {
      he.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    v(fe, he), fe.prototype.split = function(S, E) {
      for (var I = 4194303, M = Math.min(S.length, 9), $ = 0; $ < M; $++)
        E.words[$] = S.words[$];
      if (E.length = M, S.length <= 9) {
        S.words[0] = 0, S.length = 1;
        return;
      }
      var U = S.words[9];
      for (E.words[E.length++] = U & I, $ = 10; $ < S.length; $++) {
        var Y = S.words[$] | 0;
        S.words[$ - 10] = (Y & I) << 4 | U >>> 22, U = Y;
      }
      U >>>= 22, S.words[$ - 10] = U, U === 0 && S.length > 10 ? S.length -= 10 : S.length -= 9;
    }, fe.prototype.imulK = function(S) {
      S.words[S.length] = 0, S.words[S.length + 1] = 0, S.length += 2;
      for (var E = 0, I = 0; I < S.length; I++) {
        var M = S.words[I] | 0;
        E += M * 977, S.words[I] = E & 67108863, E = M * 64 + (E / 67108864 | 0);
      }
      return S.words[S.length - 1] === 0 && (S.length--, S.words[S.length - 1] === 0 && S.length--), S;
    };
    function be() {
      he.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    v(be, he);
    function ke() {
      he.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    v(ke, he);
    function Te() {
      he.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    v(Te, he), Te.prototype.imulK = function(S) {
      for (var E = 0, I = 0; I < S.length; I++) {
        var M = (S.words[I] | 0) * 19 + E, $ = M & 67108863;
        M >>>= 26, S.words[I] = $, E = M;
      }
      return E !== 0 && (S.words[S.length++] = E), S;
    }, p._prime = function(S) {
      if (ue[S])
        return ue[S];
      var E;
      if (S === "k256")
        E = new fe();
      else if (S === "p224")
        E = new be();
      else if (S === "p192")
        E = new ke();
      else if (S === "p25519")
        E = new Te();
      else
        throw new Error("Unknown prime " + S);
      return ue[S] = E, E;
    };
    function q(P) {
      if (typeof P == "string") {
        var S = p._prime(P);
        this.m = S.p, this.prime = S;
      } else
        l(P.gtn(1), "modulus must be greater than 1"), this.m = P, this.prime = null;
    }
    q.prototype._verify1 = function(S) {
      l(S.negative === 0, "red works only with positives"), l(S.red, "red works only with red numbers");
    }, q.prototype._verify2 = function(S, E) {
      l((S.negative | E.negative) === 0, "red works only with positives"), l(
        S.red && S.red === E.red,
        "red works only with red numbers"
      );
    }, q.prototype.imod = function(S) {
      return this.prime ? this.prime.ireduce(S)._forceRed(this) : S.umod(this.m)._forceRed(this);
    }, q.prototype.neg = function(S) {
      return S.isZero() ? S.clone() : this.m.sub(S)._forceRed(this);
    }, q.prototype.add = function(S, E) {
      this._verify2(S, E);
      var I = S.add(E);
      return I.cmp(this.m) >= 0 && I.isub(this.m), I._forceRed(this);
    }, q.prototype.iadd = function(S, E) {
      this._verify2(S, E);
      var I = S.iadd(E);
      return I.cmp(this.m) >= 0 && I.isub(this.m), I;
    }, q.prototype.sub = function(S, E) {
      this._verify2(S, E);
      var I = S.sub(E);
      return I.cmpn(0) < 0 && I.iadd(this.m), I._forceRed(this);
    }, q.prototype.isub = function(S, E) {
      this._verify2(S, E);
      var I = S.isub(E);
      return I.cmpn(0) < 0 && I.iadd(this.m), I;
    }, q.prototype.shl = function(S, E) {
      return this._verify1(S), this.imod(S.ushln(E));
    }, q.prototype.imul = function(S, E) {
      return this._verify2(S, E), this.imod(S.imul(E));
    }, q.prototype.mul = function(S, E) {
      return this._verify2(S, E), this.imod(S.mul(E));
    }, q.prototype.isqr = function(S) {
      return this.imul(S, S.clone());
    }, q.prototype.sqr = function(S) {
      return this.mul(S, S);
    }, q.prototype.sqrt = function(S) {
      if (S.isZero())
        return S.clone();
      var E = this.m.andln(3);
      if (l(E % 2 === 1), E === 3) {
        var I = this.m.add(new p(1)).iushrn(2);
        return this.pow(S, I);
      }
      for (var M = this.m.subn(1), $ = 0; !M.isZero() && M.andln(1) === 0; )
        $++, M.iushrn(1);
      l(!M.isZero());
      var U = new p(1).toRed(this), Y = U.redNeg(), B = this.m.subn(1).iushrn(1), T = this.m.bitLength();
      for (T = new p(2 * T * T).toRed(this); this.pow(T, B).cmp(Y) !== 0; )
        T.redIAdd(Y);
      for (var L = this.pow(T, M), te = this.pow(S, M.addn(1).iushrn(1)), me = this.pow(S, M), Ce = $; me.cmp(U) !== 0; ) {
        for (var De = me, ye = 0; De.cmp(U) !== 0; ye++)
          De = De.redSqr();
        l(ye < Ce);
        var pe = this.pow(L, new p(1).iushln(Ce - ye - 1));
        te = te.redMul(pe), L = pe.redSqr(), me = me.redMul(L), Ce = ye;
      }
      return te;
    }, q.prototype.invm = function(S) {
      var E = S._invmp(this.m);
      return E.negative !== 0 ? (E.negative = 0, this.imod(E).redNeg()) : this.imod(E);
    }, q.prototype.pow = function(S, E) {
      if (E.isZero())
        return new p(1).toRed(this);
      if (E.cmpn(1) === 0)
        return S.clone();
      var I = 4, M = new Array(1 << I);
      M[0] = new p(1).toRed(this), M[1] = S;
      for (var $ = 2; $ < M.length; $++)
        M[$] = this.mul(M[$ - 1], S);
      var U = M[0], Y = 0, B = 0, T = E.bitLength() % 26;
      for (T === 0 && (T = 26), $ = E.length - 1; $ >= 0; $--) {
        for (var L = E.words[$], te = T - 1; te >= 0; te--) {
          var me = L >> te & 1;
          if (U !== M[0] && (U = this.sqr(U)), me === 0 && Y === 0) {
            B = 0;
            continue;
          }
          Y <<= 1, Y |= me, B++, !(B !== I && ($ !== 0 || te !== 0)) && (U = this.mul(U, M[Y]), B = 0, Y = 0);
        }
        T = 26;
      }
      return U;
    }, q.prototype.convertTo = function(S) {
      var E = S.umod(this.m);
      return E === S ? E.clone() : E;
    }, q.prototype.convertFrom = function(S) {
      var E = S.clone();
      return E.red = null, E;
    }, p.mont = function(S) {
      return new z(S);
    };
    function z(P) {
      q.call(this, P), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new p(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    v(z, q), z.prototype.convertTo = function(S) {
      return this.imod(S.ushln(this.shift));
    }, z.prototype.convertFrom = function(S) {
      var E = this.imod(S.mul(this.rinv));
      return E.red = null, E;
    }, z.prototype.imul = function(S, E) {
      if (S.isZero() || E.isZero())
        return S.words[0] = 0, S.length = 1, S;
      var I = S.imul(E), M = I.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), $ = I.isub(M).iushrn(this.shift), U = $;
      return $.cmp(this.m) >= 0 ? U = $.isub(this.m) : $.cmpn(0) < 0 && (U = $.iadd(this.m)), U._forceRed(this);
    }, z.prototype.mul = function(S, E) {
      if (S.isZero() || E.isZero())
        return new p(0)._forceRed(this);
      var I = S.mul(E), M = I.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), $ = I.isub(M).iushrn(this.shift), U = $;
      return $.cmp(this.m) >= 0 ? U = $.isub(this.m) : $.cmpn(0) < 0 && (U = $.iadd(this.m)), U._forceRed(this);
    }, z.prototype.invm = function(S) {
      var E = this.imod(S._invmp(this.m).mul(this.r2));
      return E._forceRed(this);
    };
  })(a, commonjsGlobal$1);
})(bn$6);
var bnExports$6 = bn$6.exports, bn$5 = { exports: {} };
bn$5.exports;
(function(a) {
  (function(u, c) {
    function l(P, S) {
      if (!P)
        throw new Error(S || "Assertion failed");
    }
    function v(P, S) {
      P.super_ = S;
      var E = function() {
      };
      E.prototype = S.prototype, P.prototype = new E(), P.prototype.constructor = P;
    }
    function p(P, S, E) {
      if (p.isBN(P))
        return P;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, P !== null && ((S === "le" || S === "be") && (E = S, S = 10), this._init(P || 0, S || 10, E || "be"));
    }
    typeof u == "object" ? u.exports = p : c.BN = p, p.BN = p, p.wordSize = 26;
    var _;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? _ = window.Buffer : _ = require$$0$2.Buffer;
    } catch {
    }
    p.isBN = function(S) {
      return S instanceof p ? !0 : S !== null && typeof S == "object" && S.constructor.wordSize === p.wordSize && Array.isArray(S.words);
    }, p.max = function(S, E) {
      return S.cmp(E) > 0 ? S : E;
    }, p.min = function(S, E) {
      return S.cmp(E) < 0 ? S : E;
    }, p.prototype._init = function(S, E, I) {
      if (typeof S == "number")
        return this._initNumber(S, E, I);
      if (typeof S == "object")
        return this._initArray(S, E, I);
      E === "hex" && (E = 16), l(E === (E | 0) && E >= 2 && E <= 36), S = S.toString().replace(/\s+/g, "");
      var M = 0;
      S[0] === "-" && (M++, this.negative = 1), M < S.length && (E === 16 ? this._parseHex(S, M, I) : (this._parseBase(S, E, M), I === "le" && this._initArray(this.toArray(), E, I)));
    }, p.prototype._initNumber = function(S, E, I) {
      S < 0 && (this.negative = 1, S = -S), S < 67108864 ? (this.words = [S & 67108863], this.length = 1) : S < 4503599627370496 ? (this.words = [
        S & 67108863,
        S / 67108864 & 67108863
      ], this.length = 2) : (l(S < 9007199254740992), this.words = [
        S & 67108863,
        S / 67108864 & 67108863,
        1
      ], this.length = 3), I === "le" && this._initArray(this.toArray(), E, I);
    }, p.prototype._initArray = function(S, E, I) {
      if (l(typeof S.length == "number"), S.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(S.length / 3), this.words = new Array(this.length);
      for (var M = 0; M < this.length; M++)
        this.words[M] = 0;
      var $, U, Y = 0;
      if (I === "be")
        for (M = S.length - 1, $ = 0; M >= 0; M -= 3)
          U = S[M] | S[M - 1] << 8 | S[M - 2] << 16, this.words[$] |= U << Y & 67108863, this.words[$ + 1] = U >>> 26 - Y & 67108863, Y += 24, Y >= 26 && (Y -= 26, $++);
      else if (I === "le")
        for (M = 0, $ = 0; M < S.length; M += 3)
          U = S[M] | S[M + 1] << 8 | S[M + 2] << 16, this.words[$] |= U << Y & 67108863, this.words[$ + 1] = U >>> 26 - Y & 67108863, Y += 24, Y >= 26 && (Y -= 26, $++);
      return this.strip();
    };
    function k(P, S) {
      var E = P.charCodeAt(S);
      return E >= 65 && E <= 70 ? E - 55 : E >= 97 && E <= 102 ? E - 87 : E - 48 & 15;
    }
    function O(P, S, E) {
      var I = k(P, E);
      return E - 1 >= S && (I |= k(P, E - 1) << 4), I;
    }
    p.prototype._parseHex = function(S, E, I) {
      this.length = Math.ceil((S.length - E) / 6), this.words = new Array(this.length);
      for (var M = 0; M < this.length; M++)
        this.words[M] = 0;
      var $ = 0, U = 0, Y;
      if (I === "be")
        for (M = S.length - 1; M >= E; M -= 2)
          Y = O(S, E, M) << $, this.words[U] |= Y & 67108863, $ >= 18 ? ($ -= 18, U += 1, this.words[U] |= Y >>> 26) : $ += 8;
      else {
        var B = S.length - E;
        for (M = B % 2 === 0 ? E + 1 : E; M < S.length; M += 2)
          Y = O(S, E, M) << $, this.words[U] |= Y & 67108863, $ >= 18 ? ($ -= 18, U += 1, this.words[U] |= Y >>> 26) : $ += 8;
      }
      this.strip();
    };
    function D(P, S, E, I) {
      for (var M = 0, $ = Math.min(P.length, E), U = S; U < $; U++) {
        var Y = P.charCodeAt(U) - 48;
        M *= I, Y >= 49 ? M += Y - 49 + 10 : Y >= 17 ? M += Y - 17 + 10 : M += Y;
      }
      return M;
    }
    p.prototype._parseBase = function(S, E, I) {
      this.words = [0], this.length = 1;
      for (var M = 0, $ = 1; $ <= 67108863; $ *= E)
        M++;
      M--, $ = $ / E | 0;
      for (var U = S.length - I, Y = U % M, B = Math.min(U, U - Y) + I, T = 0, L = I; L < B; L += M)
        T = D(S, L, L + M, E), this.imuln($), this.words[0] + T < 67108864 ? this.words[0] += T : this._iaddn(T);
      if (Y !== 0) {
        var te = 1;
        for (T = D(S, L, S.length, E), L = 0; L < Y; L++)
          te *= E;
        this.imuln(te), this.words[0] + T < 67108864 ? this.words[0] += T : this._iaddn(T);
      }
      this.strip();
    }, p.prototype.copy = function(S) {
      S.words = new Array(this.length);
      for (var E = 0; E < this.length; E++)
        S.words[E] = this.words[E];
      S.length = this.length, S.negative = this.negative, S.red = this.red;
    }, p.prototype.clone = function() {
      var S = new p(null);
      return this.copy(S), S;
    }, p.prototype._expand = function(S) {
      for (; this.length < S; )
        this.words[this.length++] = 0;
      return this;
    }, p.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, p.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, p.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var F = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], H = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], Z = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    p.prototype.toString = function(S, E) {
      S = S || 10, E = E | 0 || 1;
      var I;
      if (S === 16 || S === "hex") {
        I = "";
        for (var M = 0, $ = 0, U = 0; U < this.length; U++) {
          var Y = this.words[U], B = ((Y << M | $) & 16777215).toString(16);
          $ = Y >>> 24 - M & 16777215, $ !== 0 || U !== this.length - 1 ? I = F[6 - B.length] + B + I : I = B + I, M += 2, M >= 26 && (M -= 26, U--);
        }
        for ($ !== 0 && (I = $.toString(16) + I); I.length % E !== 0; )
          I = "0" + I;
        return this.negative !== 0 && (I = "-" + I), I;
      }
      if (S === (S | 0) && S >= 2 && S <= 36) {
        var T = H[S], L = Z[S];
        I = "";
        var te = this.clone();
        for (te.negative = 0; !te.isZero(); ) {
          var me = te.modn(L).toString(S);
          te = te.idivn(L), te.isZero() ? I = me + I : I = F[T - me.length] + me + I;
        }
        for (this.isZero() && (I = "0" + I); I.length % E !== 0; )
          I = "0" + I;
        return this.negative !== 0 && (I = "-" + I), I;
      }
      l(!1, "Base should be between 2 and 36");
    }, p.prototype.toNumber = function() {
      var S = this.words[0];
      return this.length === 2 ? S += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? S += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && l(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -S : S;
    }, p.prototype.toJSON = function() {
      return this.toString(16);
    }, p.prototype.toBuffer = function(S, E) {
      return l(typeof _ < "u"), this.toArrayLike(_, S, E);
    }, p.prototype.toArray = function(S, E) {
      return this.toArrayLike(Array, S, E);
    }, p.prototype.toArrayLike = function(S, E, I) {
      var M = this.byteLength(), $ = I || Math.max(1, M);
      l(M <= $, "byte array longer than desired length"), l($ > 0, "Requested array length <= 0"), this.strip();
      var U = E === "le", Y = new S($), B, T, L = this.clone();
      if (U) {
        for (T = 0; !L.isZero(); T++)
          B = L.andln(255), L.iushrn(8), Y[T] = B;
        for (; T < $; T++)
          Y[T] = 0;
      } else {
        for (T = 0; T < $ - M; T++)
          Y[T] = 0;
        for (T = 0; !L.isZero(); T++)
          B = L.andln(255), L.iushrn(8), Y[$ - T - 1] = B;
      }
      return Y;
    }, Math.clz32 ? p.prototype._countBits = function(S) {
      return 32 - Math.clz32(S);
    } : p.prototype._countBits = function(S) {
      var E = S, I = 0;
      return E >= 4096 && (I += 13, E >>>= 13), E >= 64 && (I += 7, E >>>= 7), E >= 8 && (I += 4, E >>>= 4), E >= 2 && (I += 2, E >>>= 2), I + E;
    }, p.prototype._zeroBits = function(S) {
      if (S === 0)
        return 26;
      var E = S, I = 0;
      return E & 8191 || (I += 13, E >>>= 13), E & 127 || (I += 7, E >>>= 7), E & 15 || (I += 4, E >>>= 4), E & 3 || (I += 2, E >>>= 2), E & 1 || I++, I;
    }, p.prototype.bitLength = function() {
      var S = this.words[this.length - 1], E = this._countBits(S);
      return (this.length - 1) * 26 + E;
    };
    function ee(P) {
      for (var S = new Array(P.bitLength()), E = 0; E < S.length; E++) {
        var I = E / 26 | 0, M = E % 26;
        S[E] = (P.words[I] & 1 << M) >>> M;
      }
      return S;
    }
    p.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var S = 0, E = 0; E < this.length; E++) {
        var I = this._zeroBits(this.words[E]);
        if (S += I, I !== 26)
          break;
      }
      return S;
    }, p.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, p.prototype.toTwos = function(S) {
      return this.negative !== 0 ? this.abs().inotn(S).iaddn(1) : this.clone();
    }, p.prototype.fromTwos = function(S) {
      return this.testn(S - 1) ? this.notn(S).iaddn(1).ineg() : this.clone();
    }, p.prototype.isNeg = function() {
      return this.negative !== 0;
    }, p.prototype.neg = function() {
      return this.clone().ineg();
    }, p.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, p.prototype.iuor = function(S) {
      for (; this.length < S.length; )
        this.words[this.length++] = 0;
      for (var E = 0; E < S.length; E++)
        this.words[E] = this.words[E] | S.words[E];
      return this.strip();
    }, p.prototype.ior = function(S) {
      return l((this.negative | S.negative) === 0), this.iuor(S);
    }, p.prototype.or = function(S) {
      return this.length > S.length ? this.clone().ior(S) : S.clone().ior(this);
    }, p.prototype.uor = function(S) {
      return this.length > S.length ? this.clone().iuor(S) : S.clone().iuor(this);
    }, p.prototype.iuand = function(S) {
      var E;
      this.length > S.length ? E = S : E = this;
      for (var I = 0; I < E.length; I++)
        this.words[I] = this.words[I] & S.words[I];
      return this.length = E.length, this.strip();
    }, p.prototype.iand = function(S) {
      return l((this.negative | S.negative) === 0), this.iuand(S);
    }, p.prototype.and = function(S) {
      return this.length > S.length ? this.clone().iand(S) : S.clone().iand(this);
    }, p.prototype.uand = function(S) {
      return this.length > S.length ? this.clone().iuand(S) : S.clone().iuand(this);
    }, p.prototype.iuxor = function(S) {
      var E, I;
      this.length > S.length ? (E = this, I = S) : (E = S, I = this);
      for (var M = 0; M < I.length; M++)
        this.words[M] = E.words[M] ^ I.words[M];
      if (this !== E)
        for (; M < E.length; M++)
          this.words[M] = E.words[M];
      return this.length = E.length, this.strip();
    }, p.prototype.ixor = function(S) {
      return l((this.negative | S.negative) === 0), this.iuxor(S);
    }, p.prototype.xor = function(S) {
      return this.length > S.length ? this.clone().ixor(S) : S.clone().ixor(this);
    }, p.prototype.uxor = function(S) {
      return this.length > S.length ? this.clone().iuxor(S) : S.clone().iuxor(this);
    }, p.prototype.inotn = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = Math.ceil(S / 26) | 0, I = S % 26;
      this._expand(E), I > 0 && E--;
      for (var M = 0; M < E; M++)
        this.words[M] = ~this.words[M] & 67108863;
      return I > 0 && (this.words[M] = ~this.words[M] & 67108863 >> 26 - I), this.strip();
    }, p.prototype.notn = function(S) {
      return this.clone().inotn(S);
    }, p.prototype.setn = function(S, E) {
      l(typeof S == "number" && S >= 0);
      var I = S / 26 | 0, M = S % 26;
      return this._expand(I + 1), E ? this.words[I] = this.words[I] | 1 << M : this.words[I] = this.words[I] & ~(1 << M), this.strip();
    }, p.prototype.iadd = function(S) {
      var E;
      if (this.negative !== 0 && S.negative === 0)
        return this.negative = 0, E = this.isub(S), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && S.negative !== 0)
        return S.negative = 0, E = this.isub(S), S.negative = 1, E._normSign();
      var I, M;
      this.length > S.length ? (I = this, M = S) : (I = S, M = this);
      for (var $ = 0, U = 0; U < M.length; U++)
        E = (I.words[U] | 0) + (M.words[U] | 0) + $, this.words[U] = E & 67108863, $ = E >>> 26;
      for (; $ !== 0 && U < I.length; U++)
        E = (I.words[U] | 0) + $, this.words[U] = E & 67108863, $ = E >>> 26;
      if (this.length = I.length, $ !== 0)
        this.words[this.length] = $, this.length++;
      else if (I !== this)
        for (; U < I.length; U++)
          this.words[U] = I.words[U];
      return this;
    }, p.prototype.add = function(S) {
      var E;
      return S.negative !== 0 && this.negative === 0 ? (S.negative = 0, E = this.sub(S), S.negative ^= 1, E) : S.negative === 0 && this.negative !== 0 ? (this.negative = 0, E = S.sub(this), this.negative = 1, E) : this.length > S.length ? this.clone().iadd(S) : S.clone().iadd(this);
    }, p.prototype.isub = function(S) {
      if (S.negative !== 0) {
        S.negative = 0;
        var E = this.iadd(S);
        return S.negative = 1, E._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(S), this.negative = 1, this._normSign();
      var I = this.cmp(S);
      if (I === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var M, $;
      I > 0 ? (M = this, $ = S) : (M = S, $ = this);
      for (var U = 0, Y = 0; Y < $.length; Y++)
        E = (M.words[Y] | 0) - ($.words[Y] | 0) + U, U = E >> 26, this.words[Y] = E & 67108863;
      for (; U !== 0 && Y < M.length; Y++)
        E = (M.words[Y] | 0) + U, U = E >> 26, this.words[Y] = E & 67108863;
      if (U === 0 && Y < M.length && M !== this)
        for (; Y < M.length; Y++)
          this.words[Y] = M.words[Y];
      return this.length = Math.max(this.length, Y), M !== this && (this.negative = 1), this.strip();
    }, p.prototype.sub = function(S) {
      return this.clone().isub(S);
    };
    function X(P, S, E) {
      E.negative = S.negative ^ P.negative;
      var I = P.length + S.length | 0;
      E.length = I, I = I - 1 | 0;
      var M = P.words[0] | 0, $ = S.words[0] | 0, U = M * $, Y = U & 67108863, B = U / 67108864 | 0;
      E.words[0] = Y;
      for (var T = 1; T < I; T++) {
        for (var L = B >>> 26, te = B & 67108863, me = Math.min(T, S.length - 1), Ce = Math.max(0, T - P.length + 1); Ce <= me; Ce++) {
          var De = T - Ce | 0;
          M = P.words[De] | 0, $ = S.words[Ce] | 0, U = M * $ + te, L += U / 67108864 | 0, te = U & 67108863;
        }
        E.words[T] = te | 0, B = L | 0;
      }
      return B !== 0 ? E.words[T] = B | 0 : E.length--, E.strip();
    }
    var ne = function(S, E, I) {
      var M = S.words, $ = E.words, U = I.words, Y = 0, B, T, L, te = M[0] | 0, me = te & 8191, Ce = te >>> 13, De = M[1] | 0, ye = De & 8191, pe = De >>> 13, Me = M[2] | 0, Ne = Me & 8191, Ue = Me >>> 13, oe = M[3] | 0, A = oe & 8191, re = oe >>> 13, le = M[4] | 0, $e = le & 8191, Oe = le >>> 13, Fe = M[5] | 0, Ze = Fe & 8191, qe = Fe >>> 13, yt = M[6] | 0, Xe = yt & 8191, Ge = yt >>> 13, J = M[7] | 0, ge = J & 8191, we = J >>> 13, We = M[8] | 0, Ie = We & 8191, V = We >>> 13, Ee = M[9] | 0, de = Ee & 8191, ce = Ee >>> 13, ve = $[0] | 0, Pe = ve & 8191, Be = ve >>> 13, ze = $[1] | 0, Je = ze & 8191, je = ze >>> 13, Ke = $[2] | 0, x = Ke & 8191, se = Ke >>> 13, Se = $[3] | 0, xe = Se & 8191, Ae = Se >>> 13, Ye = $[4] | 0, et = Ye & 8191, dt = Ye >>> 13, St = $[5] | 0, tt = St & 8191, at = St >>> 13, kt = $[6] | 0, rt = kt & 8191, ut = kt >>> 13, wt = $[7] | 0, nt = wt & 8191, it = wt >>> 13, bt = $[8] | 0, ot = bt & 8191, ct = bt >>> 13, Pt = $[9] | 0, st = Pt & 8191, lt = Pt >>> 13;
      I.negative = S.negative ^ E.negative, I.length = 19, B = Math.imul(me, Pe), T = Math.imul(me, Be), T = T + Math.imul(Ce, Pe) | 0, L = Math.imul(Ce, Be);
      var It = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (It >>> 26) | 0, It &= 67108863, B = Math.imul(ye, Pe), T = Math.imul(ye, Be), T = T + Math.imul(pe, Pe) | 0, L = Math.imul(pe, Be), B = B + Math.imul(me, Je) | 0, T = T + Math.imul(me, je) | 0, T = T + Math.imul(Ce, Je) | 0, L = L + Math.imul(Ce, je) | 0;
      var Rt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (Rt >>> 26) | 0, Rt &= 67108863, B = Math.imul(Ne, Pe), T = Math.imul(Ne, Be), T = T + Math.imul(Ue, Pe) | 0, L = Math.imul(Ue, Be), B = B + Math.imul(ye, Je) | 0, T = T + Math.imul(ye, je) | 0, T = T + Math.imul(pe, Je) | 0, L = L + Math.imul(pe, je) | 0, B = B + Math.imul(me, x) | 0, T = T + Math.imul(me, se) | 0, T = T + Math.imul(Ce, x) | 0, L = L + Math.imul(Ce, se) | 0;
      var Ve = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, B = Math.imul(A, Pe), T = Math.imul(A, Be), T = T + Math.imul(re, Pe) | 0, L = Math.imul(re, Be), B = B + Math.imul(Ne, Je) | 0, T = T + Math.imul(Ne, je) | 0, T = T + Math.imul(Ue, Je) | 0, L = L + Math.imul(Ue, je) | 0, B = B + Math.imul(ye, x) | 0, T = T + Math.imul(ye, se) | 0, T = T + Math.imul(pe, x) | 0, L = L + Math.imul(pe, se) | 0, B = B + Math.imul(me, xe) | 0, T = T + Math.imul(me, Ae) | 0, T = T + Math.imul(Ce, xe) | 0, L = L + Math.imul(Ce, Ae) | 0;
      var He = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, B = Math.imul($e, Pe), T = Math.imul($e, Be), T = T + Math.imul(Oe, Pe) | 0, L = Math.imul(Oe, Be), B = B + Math.imul(A, Je) | 0, T = T + Math.imul(A, je) | 0, T = T + Math.imul(re, Je) | 0, L = L + Math.imul(re, je) | 0, B = B + Math.imul(Ne, x) | 0, T = T + Math.imul(Ne, se) | 0, T = T + Math.imul(Ue, x) | 0, L = L + Math.imul(Ue, se) | 0, B = B + Math.imul(ye, xe) | 0, T = T + Math.imul(ye, Ae) | 0, T = T + Math.imul(pe, xe) | 0, L = L + Math.imul(pe, Ae) | 0, B = B + Math.imul(me, et) | 0, T = T + Math.imul(me, dt) | 0, T = T + Math.imul(Ce, et) | 0, L = L + Math.imul(Ce, dt) | 0;
      var Qe = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, B = Math.imul(Ze, Pe), T = Math.imul(Ze, Be), T = T + Math.imul(qe, Pe) | 0, L = Math.imul(qe, Be), B = B + Math.imul($e, Je) | 0, T = T + Math.imul($e, je) | 0, T = T + Math.imul(Oe, Je) | 0, L = L + Math.imul(Oe, je) | 0, B = B + Math.imul(A, x) | 0, T = T + Math.imul(A, se) | 0, T = T + Math.imul(re, x) | 0, L = L + Math.imul(re, se) | 0, B = B + Math.imul(Ne, xe) | 0, T = T + Math.imul(Ne, Ae) | 0, T = T + Math.imul(Ue, xe) | 0, L = L + Math.imul(Ue, Ae) | 0, B = B + Math.imul(ye, et) | 0, T = T + Math.imul(ye, dt) | 0, T = T + Math.imul(pe, et) | 0, L = L + Math.imul(pe, dt) | 0, B = B + Math.imul(me, tt) | 0, T = T + Math.imul(me, at) | 0, T = T + Math.imul(Ce, tt) | 0, L = L + Math.imul(Ce, at) | 0;
      var pt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (pt >>> 26) | 0, pt &= 67108863, B = Math.imul(Xe, Pe), T = Math.imul(Xe, Be), T = T + Math.imul(Ge, Pe) | 0, L = Math.imul(Ge, Be), B = B + Math.imul(Ze, Je) | 0, T = T + Math.imul(Ze, je) | 0, T = T + Math.imul(qe, Je) | 0, L = L + Math.imul(qe, je) | 0, B = B + Math.imul($e, x) | 0, T = T + Math.imul($e, se) | 0, T = T + Math.imul(Oe, x) | 0, L = L + Math.imul(Oe, se) | 0, B = B + Math.imul(A, xe) | 0, T = T + Math.imul(A, Ae) | 0, T = T + Math.imul(re, xe) | 0, L = L + Math.imul(re, Ae) | 0, B = B + Math.imul(Ne, et) | 0, T = T + Math.imul(Ne, dt) | 0, T = T + Math.imul(Ue, et) | 0, L = L + Math.imul(Ue, dt) | 0, B = B + Math.imul(ye, tt) | 0, T = T + Math.imul(ye, at) | 0, T = T + Math.imul(pe, tt) | 0, L = L + Math.imul(pe, at) | 0, B = B + Math.imul(me, rt) | 0, T = T + Math.imul(me, ut) | 0, T = T + Math.imul(Ce, rt) | 0, L = L + Math.imul(Ce, ut) | 0;
      var mt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (mt >>> 26) | 0, mt &= 67108863, B = Math.imul(ge, Pe), T = Math.imul(ge, Be), T = T + Math.imul(we, Pe) | 0, L = Math.imul(we, Be), B = B + Math.imul(Xe, Je) | 0, T = T + Math.imul(Xe, je) | 0, T = T + Math.imul(Ge, Je) | 0, L = L + Math.imul(Ge, je) | 0, B = B + Math.imul(Ze, x) | 0, T = T + Math.imul(Ze, se) | 0, T = T + Math.imul(qe, x) | 0, L = L + Math.imul(qe, se) | 0, B = B + Math.imul($e, xe) | 0, T = T + Math.imul($e, Ae) | 0, T = T + Math.imul(Oe, xe) | 0, L = L + Math.imul(Oe, Ae) | 0, B = B + Math.imul(A, et) | 0, T = T + Math.imul(A, dt) | 0, T = T + Math.imul(re, et) | 0, L = L + Math.imul(re, dt) | 0, B = B + Math.imul(Ne, tt) | 0, T = T + Math.imul(Ne, at) | 0, T = T + Math.imul(Ue, tt) | 0, L = L + Math.imul(Ue, at) | 0, B = B + Math.imul(ye, rt) | 0, T = T + Math.imul(ye, ut) | 0, T = T + Math.imul(pe, rt) | 0, L = L + Math.imul(pe, ut) | 0, B = B + Math.imul(me, nt) | 0, T = T + Math.imul(me, it) | 0, T = T + Math.imul(Ce, nt) | 0, L = L + Math.imul(Ce, it) | 0;
      var vt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, B = Math.imul(Ie, Pe), T = Math.imul(Ie, Be), T = T + Math.imul(V, Pe) | 0, L = Math.imul(V, Be), B = B + Math.imul(ge, Je) | 0, T = T + Math.imul(ge, je) | 0, T = T + Math.imul(we, Je) | 0, L = L + Math.imul(we, je) | 0, B = B + Math.imul(Xe, x) | 0, T = T + Math.imul(Xe, se) | 0, T = T + Math.imul(Ge, x) | 0, L = L + Math.imul(Ge, se) | 0, B = B + Math.imul(Ze, xe) | 0, T = T + Math.imul(Ze, Ae) | 0, T = T + Math.imul(qe, xe) | 0, L = L + Math.imul(qe, Ae) | 0, B = B + Math.imul($e, et) | 0, T = T + Math.imul($e, dt) | 0, T = T + Math.imul(Oe, et) | 0, L = L + Math.imul(Oe, dt) | 0, B = B + Math.imul(A, tt) | 0, T = T + Math.imul(A, at) | 0, T = T + Math.imul(re, tt) | 0, L = L + Math.imul(re, at) | 0, B = B + Math.imul(Ne, rt) | 0, T = T + Math.imul(Ne, ut) | 0, T = T + Math.imul(Ue, rt) | 0, L = L + Math.imul(Ue, ut) | 0, B = B + Math.imul(ye, nt) | 0, T = T + Math.imul(ye, it) | 0, T = T + Math.imul(pe, nt) | 0, L = L + Math.imul(pe, it) | 0, B = B + Math.imul(me, ot) | 0, T = T + Math.imul(me, ct) | 0, T = T + Math.imul(Ce, ot) | 0, L = L + Math.imul(Ce, ct) | 0;
      var ht = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (ht >>> 26) | 0, ht &= 67108863, B = Math.imul(de, Pe), T = Math.imul(de, Be), T = T + Math.imul(ce, Pe) | 0, L = Math.imul(ce, Be), B = B + Math.imul(Ie, Je) | 0, T = T + Math.imul(Ie, je) | 0, T = T + Math.imul(V, Je) | 0, L = L + Math.imul(V, je) | 0, B = B + Math.imul(ge, x) | 0, T = T + Math.imul(ge, se) | 0, T = T + Math.imul(we, x) | 0, L = L + Math.imul(we, se) | 0, B = B + Math.imul(Xe, xe) | 0, T = T + Math.imul(Xe, Ae) | 0, T = T + Math.imul(Ge, xe) | 0, L = L + Math.imul(Ge, Ae) | 0, B = B + Math.imul(Ze, et) | 0, T = T + Math.imul(Ze, dt) | 0, T = T + Math.imul(qe, et) | 0, L = L + Math.imul(qe, dt) | 0, B = B + Math.imul($e, tt) | 0, T = T + Math.imul($e, at) | 0, T = T + Math.imul(Oe, tt) | 0, L = L + Math.imul(Oe, at) | 0, B = B + Math.imul(A, rt) | 0, T = T + Math.imul(A, ut) | 0, T = T + Math.imul(re, rt) | 0, L = L + Math.imul(re, ut) | 0, B = B + Math.imul(Ne, nt) | 0, T = T + Math.imul(Ne, it) | 0, T = T + Math.imul(Ue, nt) | 0, L = L + Math.imul(Ue, it) | 0, B = B + Math.imul(ye, ot) | 0, T = T + Math.imul(ye, ct) | 0, T = T + Math.imul(pe, ot) | 0, L = L + Math.imul(pe, ct) | 0, B = B + Math.imul(me, st) | 0, T = T + Math.imul(me, lt) | 0, T = T + Math.imul(Ce, st) | 0, L = L + Math.imul(Ce, lt) | 0;
      var Et = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, B = Math.imul(de, Je), T = Math.imul(de, je), T = T + Math.imul(ce, Je) | 0, L = Math.imul(ce, je), B = B + Math.imul(Ie, x) | 0, T = T + Math.imul(Ie, se) | 0, T = T + Math.imul(V, x) | 0, L = L + Math.imul(V, se) | 0, B = B + Math.imul(ge, xe) | 0, T = T + Math.imul(ge, Ae) | 0, T = T + Math.imul(we, xe) | 0, L = L + Math.imul(we, Ae) | 0, B = B + Math.imul(Xe, et) | 0, T = T + Math.imul(Xe, dt) | 0, T = T + Math.imul(Ge, et) | 0, L = L + Math.imul(Ge, dt) | 0, B = B + Math.imul(Ze, tt) | 0, T = T + Math.imul(Ze, at) | 0, T = T + Math.imul(qe, tt) | 0, L = L + Math.imul(qe, at) | 0, B = B + Math.imul($e, rt) | 0, T = T + Math.imul($e, ut) | 0, T = T + Math.imul(Oe, rt) | 0, L = L + Math.imul(Oe, ut) | 0, B = B + Math.imul(A, nt) | 0, T = T + Math.imul(A, it) | 0, T = T + Math.imul(re, nt) | 0, L = L + Math.imul(re, it) | 0, B = B + Math.imul(Ne, ot) | 0, T = T + Math.imul(Ne, ct) | 0, T = T + Math.imul(Ue, ot) | 0, L = L + Math.imul(Ue, ct) | 0, B = B + Math.imul(ye, st) | 0, T = T + Math.imul(ye, lt) | 0, T = T + Math.imul(pe, st) | 0, L = L + Math.imul(pe, lt) | 0;
      var Tt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (Tt >>> 26) | 0, Tt &= 67108863, B = Math.imul(de, x), T = Math.imul(de, se), T = T + Math.imul(ce, x) | 0, L = Math.imul(ce, se), B = B + Math.imul(Ie, xe) | 0, T = T + Math.imul(Ie, Ae) | 0, T = T + Math.imul(V, xe) | 0, L = L + Math.imul(V, Ae) | 0, B = B + Math.imul(ge, et) | 0, T = T + Math.imul(ge, dt) | 0, T = T + Math.imul(we, et) | 0, L = L + Math.imul(we, dt) | 0, B = B + Math.imul(Xe, tt) | 0, T = T + Math.imul(Xe, at) | 0, T = T + Math.imul(Ge, tt) | 0, L = L + Math.imul(Ge, at) | 0, B = B + Math.imul(Ze, rt) | 0, T = T + Math.imul(Ze, ut) | 0, T = T + Math.imul(qe, rt) | 0, L = L + Math.imul(qe, ut) | 0, B = B + Math.imul($e, nt) | 0, T = T + Math.imul($e, it) | 0, T = T + Math.imul(Oe, nt) | 0, L = L + Math.imul(Oe, it) | 0, B = B + Math.imul(A, ot) | 0, T = T + Math.imul(A, ct) | 0, T = T + Math.imul(re, ot) | 0, L = L + Math.imul(re, ct) | 0, B = B + Math.imul(Ne, st) | 0, T = T + Math.imul(Ne, lt) | 0, T = T + Math.imul(Ue, st) | 0, L = L + Math.imul(Ue, lt) | 0;
      var Ot = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (Ot >>> 26) | 0, Ot &= 67108863, B = Math.imul(de, xe), T = Math.imul(de, Ae), T = T + Math.imul(ce, xe) | 0, L = Math.imul(ce, Ae), B = B + Math.imul(Ie, et) | 0, T = T + Math.imul(Ie, dt) | 0, T = T + Math.imul(V, et) | 0, L = L + Math.imul(V, dt) | 0, B = B + Math.imul(ge, tt) | 0, T = T + Math.imul(ge, at) | 0, T = T + Math.imul(we, tt) | 0, L = L + Math.imul(we, at) | 0, B = B + Math.imul(Xe, rt) | 0, T = T + Math.imul(Xe, ut) | 0, T = T + Math.imul(Ge, rt) | 0, L = L + Math.imul(Ge, ut) | 0, B = B + Math.imul(Ze, nt) | 0, T = T + Math.imul(Ze, it) | 0, T = T + Math.imul(qe, nt) | 0, L = L + Math.imul(qe, it) | 0, B = B + Math.imul($e, ot) | 0, T = T + Math.imul($e, ct) | 0, T = T + Math.imul(Oe, ot) | 0, L = L + Math.imul(Oe, ct) | 0, B = B + Math.imul(A, st) | 0, T = T + Math.imul(A, lt) | 0, T = T + Math.imul(re, st) | 0, L = L + Math.imul(re, lt) | 0;
      var Nt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, B = Math.imul(de, et), T = Math.imul(de, dt), T = T + Math.imul(ce, et) | 0, L = Math.imul(ce, dt), B = B + Math.imul(Ie, tt) | 0, T = T + Math.imul(Ie, at) | 0, T = T + Math.imul(V, tt) | 0, L = L + Math.imul(V, at) | 0, B = B + Math.imul(ge, rt) | 0, T = T + Math.imul(ge, ut) | 0, T = T + Math.imul(we, rt) | 0, L = L + Math.imul(we, ut) | 0, B = B + Math.imul(Xe, nt) | 0, T = T + Math.imul(Xe, it) | 0, T = T + Math.imul(Ge, nt) | 0, L = L + Math.imul(Ge, it) | 0, B = B + Math.imul(Ze, ot) | 0, T = T + Math.imul(Ze, ct) | 0, T = T + Math.imul(qe, ot) | 0, L = L + Math.imul(qe, ct) | 0, B = B + Math.imul($e, st) | 0, T = T + Math.imul($e, lt) | 0, T = T + Math.imul(Oe, st) | 0, L = L + Math.imul(Oe, lt) | 0;
      var At = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, B = Math.imul(de, tt), T = Math.imul(de, at), T = T + Math.imul(ce, tt) | 0, L = Math.imul(ce, at), B = B + Math.imul(Ie, rt) | 0, T = T + Math.imul(Ie, ut) | 0, T = T + Math.imul(V, rt) | 0, L = L + Math.imul(V, ut) | 0, B = B + Math.imul(ge, nt) | 0, T = T + Math.imul(ge, it) | 0, T = T + Math.imul(we, nt) | 0, L = L + Math.imul(we, it) | 0, B = B + Math.imul(Xe, ot) | 0, T = T + Math.imul(Xe, ct) | 0, T = T + Math.imul(Ge, ot) | 0, L = L + Math.imul(Ge, ct) | 0, B = B + Math.imul(Ze, st) | 0, T = T + Math.imul(Ze, lt) | 0, T = T + Math.imul(qe, st) | 0, L = L + Math.imul(qe, lt) | 0;
      var Mt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (Mt >>> 26) | 0, Mt &= 67108863, B = Math.imul(de, rt), T = Math.imul(de, ut), T = T + Math.imul(ce, rt) | 0, L = Math.imul(ce, ut), B = B + Math.imul(Ie, nt) | 0, T = T + Math.imul(Ie, it) | 0, T = T + Math.imul(V, nt) | 0, L = L + Math.imul(V, it) | 0, B = B + Math.imul(ge, ot) | 0, T = T + Math.imul(ge, ct) | 0, T = T + Math.imul(we, ot) | 0, L = L + Math.imul(we, ct) | 0, B = B + Math.imul(Xe, st) | 0, T = T + Math.imul(Xe, lt) | 0, T = T + Math.imul(Ge, st) | 0, L = L + Math.imul(Ge, lt) | 0;
      var $t = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + ($t >>> 26) | 0, $t &= 67108863, B = Math.imul(de, nt), T = Math.imul(de, it), T = T + Math.imul(ce, nt) | 0, L = Math.imul(ce, it), B = B + Math.imul(Ie, ot) | 0, T = T + Math.imul(Ie, ct) | 0, T = T + Math.imul(V, ot) | 0, L = L + Math.imul(V, ct) | 0, B = B + Math.imul(ge, st) | 0, T = T + Math.imul(ge, lt) | 0, T = T + Math.imul(we, st) | 0, L = L + Math.imul(we, lt) | 0;
      var Bt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, B = Math.imul(de, ot), T = Math.imul(de, ct), T = T + Math.imul(ce, ot) | 0, L = Math.imul(ce, ct), B = B + Math.imul(Ie, st) | 0, T = T + Math.imul(Ie, lt) | 0, T = T + Math.imul(V, st) | 0, L = L + Math.imul(V, lt) | 0;
      var Ut = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (Ut >>> 26) | 0, Ut &= 67108863, B = Math.imul(de, st), T = Math.imul(de, lt), T = T + Math.imul(ce, st) | 0, L = Math.imul(ce, lt);
      var xt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      return Y = (L + (T >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, U[0] = It, U[1] = Rt, U[2] = Ve, U[3] = He, U[4] = Qe, U[5] = pt, U[6] = mt, U[7] = vt, U[8] = ht, U[9] = Et, U[10] = Tt, U[11] = Ot, U[12] = Nt, U[13] = At, U[14] = Mt, U[15] = $t, U[16] = Bt, U[17] = Ut, U[18] = xt, Y !== 0 && (U[19] = Y, I.length++), I;
    };
    Math.imul || (ne = X);
    function Q(P, S, E) {
      E.negative = S.negative ^ P.negative, E.length = P.length + S.length;
      for (var I = 0, M = 0, $ = 0; $ < E.length - 1; $++) {
        var U = M;
        M = 0;
        for (var Y = I & 67108863, B = Math.min($, S.length - 1), T = Math.max(0, $ - P.length + 1); T <= B; T++) {
          var L = $ - T, te = P.words[L] | 0, me = S.words[T] | 0, Ce = te * me, De = Ce & 67108863;
          U = U + (Ce / 67108864 | 0) | 0, De = De + Y | 0, Y = De & 67108863, U = U + (De >>> 26) | 0, M += U >>> 26, U &= 67108863;
        }
        E.words[$] = Y, I = U, U = M;
      }
      return I !== 0 ? E.words[$] = I : E.length--, E.strip();
    }
    function ae(P, S, E) {
      var I = new j();
      return I.mulp(P, S, E);
    }
    p.prototype.mulTo = function(S, E) {
      var I, M = this.length + S.length;
      return this.length === 10 && S.length === 10 ? I = ne(this, S, E) : M < 63 ? I = X(this, S, E) : M < 1024 ? I = Q(this, S, E) : I = ae(this, S, E), I;
    };
    function j(P, S) {
      this.x = P, this.y = S;
    }
    j.prototype.makeRBT = function(S) {
      for (var E = new Array(S), I = p.prototype._countBits(S) - 1, M = 0; M < S; M++)
        E[M] = this.revBin(M, I, S);
      return E;
    }, j.prototype.revBin = function(S, E, I) {
      if (S === 0 || S === I - 1)
        return S;
      for (var M = 0, $ = 0; $ < E; $++)
        M |= (S & 1) << E - $ - 1, S >>= 1;
      return M;
    }, j.prototype.permute = function(S, E, I, M, $, U) {
      for (var Y = 0; Y < U; Y++)
        M[Y] = E[S[Y]], $[Y] = I[S[Y]];
    }, j.prototype.transform = function(S, E, I, M, $, U) {
      this.permute(U, S, E, I, M, $);
      for (var Y = 1; Y < $; Y <<= 1)
        for (var B = Y << 1, T = Math.cos(2 * Math.PI / B), L = Math.sin(2 * Math.PI / B), te = 0; te < $; te += B)
          for (var me = T, Ce = L, De = 0; De < Y; De++) {
            var ye = I[te + De], pe = M[te + De], Me = I[te + De + Y], Ne = M[te + De + Y], Ue = me * Me - Ce * Ne;
            Ne = me * Ne + Ce * Me, Me = Ue, I[te + De] = ye + Me, M[te + De] = pe + Ne, I[te + De + Y] = ye - Me, M[te + De + Y] = pe - Ne, De !== B && (Ue = T * me - L * Ce, Ce = T * Ce + L * me, me = Ue);
          }
    }, j.prototype.guessLen13b = function(S, E) {
      var I = Math.max(E, S) | 1, M = I & 1, $ = 0;
      for (I = I / 2 | 0; I; I = I >>> 1)
        $++;
      return 1 << $ + 1 + M;
    }, j.prototype.conjugate = function(S, E, I) {
      if (!(I <= 1))
        for (var M = 0; M < I / 2; M++) {
          var $ = S[M];
          S[M] = S[I - M - 1], S[I - M - 1] = $, $ = E[M], E[M] = -E[I - M - 1], E[I - M - 1] = -$;
        }
    }, j.prototype.normalize13b = function(S, E) {
      for (var I = 0, M = 0; M < E / 2; M++) {
        var $ = Math.round(S[2 * M + 1] / E) * 8192 + Math.round(S[2 * M] / E) + I;
        S[M] = $ & 67108863, $ < 67108864 ? I = 0 : I = $ / 67108864 | 0;
      }
      return S;
    }, j.prototype.convert13b = function(S, E, I, M) {
      for (var $ = 0, U = 0; U < E; U++)
        $ = $ + (S[U] | 0), I[2 * U] = $ & 8191, $ = $ >>> 13, I[2 * U + 1] = $ & 8191, $ = $ >>> 13;
      for (U = 2 * E; U < M; ++U)
        I[U] = 0;
      l($ === 0), l(($ & -8192) === 0);
    }, j.prototype.stub = function(S) {
      for (var E = new Array(S), I = 0; I < S; I++)
        E[I] = 0;
      return E;
    }, j.prototype.mulp = function(S, E, I) {
      var M = 2 * this.guessLen13b(S.length, E.length), $ = this.makeRBT(M), U = this.stub(M), Y = new Array(M), B = new Array(M), T = new Array(M), L = new Array(M), te = new Array(M), me = new Array(M), Ce = I.words;
      Ce.length = M, this.convert13b(S.words, S.length, Y, M), this.convert13b(E.words, E.length, L, M), this.transform(Y, U, B, T, M, $), this.transform(L, U, te, me, M, $);
      for (var De = 0; De < M; De++) {
        var ye = B[De] * te[De] - T[De] * me[De];
        T[De] = B[De] * me[De] + T[De] * te[De], B[De] = ye;
      }
      return this.conjugate(B, T, M), this.transform(B, T, Ce, U, M, $), this.conjugate(Ce, U, M), this.normalize13b(Ce, M), I.negative = S.negative ^ E.negative, I.length = S.length + E.length, I.strip();
    }, p.prototype.mul = function(S) {
      var E = new p(null);
      return E.words = new Array(this.length + S.length), this.mulTo(S, E);
    }, p.prototype.mulf = function(S) {
      var E = new p(null);
      return E.words = new Array(this.length + S.length), ae(this, S, E);
    }, p.prototype.imul = function(S) {
      return this.clone().mulTo(S, this);
    }, p.prototype.imuln = function(S) {
      l(typeof S == "number"), l(S < 67108864);
      for (var E = 0, I = 0; I < this.length; I++) {
        var M = (this.words[I] | 0) * S, $ = (M & 67108863) + (E & 67108863);
        E >>= 26, E += M / 67108864 | 0, E += $ >>> 26, this.words[I] = $ & 67108863;
      }
      return E !== 0 && (this.words[I] = E, this.length++), this;
    }, p.prototype.muln = function(S) {
      return this.clone().imuln(S);
    }, p.prototype.sqr = function() {
      return this.mul(this);
    }, p.prototype.isqr = function() {
      return this.imul(this.clone());
    }, p.prototype.pow = function(S) {
      var E = ee(S);
      if (E.length === 0)
        return new p(1);
      for (var I = this, M = 0; M < E.length && E[M] === 0; M++, I = I.sqr())
        ;
      if (++M < E.length)
        for (var $ = I.sqr(); M < E.length; M++, $ = $.sqr())
          E[M] !== 0 && (I = I.mul($));
      return I;
    }, p.prototype.iushln = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = S % 26, I = (S - E) / 26, M = 67108863 >>> 26 - E << 26 - E, $;
      if (E !== 0) {
        var U = 0;
        for ($ = 0; $ < this.length; $++) {
          var Y = this.words[$] & M, B = (this.words[$] | 0) - Y << E;
          this.words[$] = B | U, U = Y >>> 26 - E;
        }
        U && (this.words[$] = U, this.length++);
      }
      if (I !== 0) {
        for ($ = this.length - 1; $ >= 0; $--)
          this.words[$ + I] = this.words[$];
        for ($ = 0; $ < I; $++)
          this.words[$] = 0;
        this.length += I;
      }
      return this.strip();
    }, p.prototype.ishln = function(S) {
      return l(this.negative === 0), this.iushln(S);
    }, p.prototype.iushrn = function(S, E, I) {
      l(typeof S == "number" && S >= 0);
      var M;
      E ? M = (E - E % 26) / 26 : M = 0;
      var $ = S % 26, U = Math.min((S - $) / 26, this.length), Y = 67108863 ^ 67108863 >>> $ << $, B = I;
      if (M -= U, M = Math.max(0, M), B) {
        for (var T = 0; T < U; T++)
          B.words[T] = this.words[T];
        B.length = U;
      }
      if (U !== 0)
        if (this.length > U)
          for (this.length -= U, T = 0; T < this.length; T++)
            this.words[T] = this.words[T + U];
        else
          this.words[0] = 0, this.length = 1;
      var L = 0;
      for (T = this.length - 1; T >= 0 && (L !== 0 || T >= M); T--) {
        var te = this.words[T] | 0;
        this.words[T] = L << 26 - $ | te >>> $, L = te & Y;
      }
      return B && L !== 0 && (B.words[B.length++] = L), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, p.prototype.ishrn = function(S, E, I) {
      return l(this.negative === 0), this.iushrn(S, E, I);
    }, p.prototype.shln = function(S) {
      return this.clone().ishln(S);
    }, p.prototype.ushln = function(S) {
      return this.clone().iushln(S);
    }, p.prototype.shrn = function(S) {
      return this.clone().ishrn(S);
    }, p.prototype.ushrn = function(S) {
      return this.clone().iushrn(S);
    }, p.prototype.testn = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = S % 26, I = (S - E) / 26, M = 1 << E;
      if (this.length <= I)
        return !1;
      var $ = this.words[I];
      return !!($ & M);
    }, p.prototype.imaskn = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = S % 26, I = (S - E) / 26;
      if (l(this.negative === 0, "imaskn works only with positive numbers"), this.length <= I)
        return this;
      if (E !== 0 && I++, this.length = Math.min(I, this.length), E !== 0) {
        var M = 67108863 ^ 67108863 >>> E << E;
        this.words[this.length - 1] &= M;
      }
      return this.strip();
    }, p.prototype.maskn = function(S) {
      return this.clone().imaskn(S);
    }, p.prototype.iaddn = function(S) {
      return l(typeof S == "number"), l(S < 67108864), S < 0 ? this.isubn(-S) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < S ? (this.words[0] = S - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(S), this.negative = 1, this) : this._iaddn(S);
    }, p.prototype._iaddn = function(S) {
      this.words[0] += S;
      for (var E = 0; E < this.length && this.words[E] >= 67108864; E++)
        this.words[E] -= 67108864, E === this.length - 1 ? this.words[E + 1] = 1 : this.words[E + 1]++;
      return this.length = Math.max(this.length, E + 1), this;
    }, p.prototype.isubn = function(S) {
      if (l(typeof S == "number"), l(S < 67108864), S < 0)
        return this.iaddn(-S);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(S), this.negative = 1, this;
      if (this.words[0] -= S, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var E = 0; E < this.length && this.words[E] < 0; E++)
          this.words[E] += 67108864, this.words[E + 1] -= 1;
      return this.strip();
    }, p.prototype.addn = function(S) {
      return this.clone().iaddn(S);
    }, p.prototype.subn = function(S) {
      return this.clone().isubn(S);
    }, p.prototype.iabs = function() {
      return this.negative = 0, this;
    }, p.prototype.abs = function() {
      return this.clone().iabs();
    }, p.prototype._ishlnsubmul = function(S, E, I) {
      var M = S.length + I, $;
      this._expand(M);
      var U, Y = 0;
      for ($ = 0; $ < S.length; $++) {
        U = (this.words[$ + I] | 0) + Y;
        var B = (S.words[$] | 0) * E;
        U -= B & 67108863, Y = (U >> 26) - (B / 67108864 | 0), this.words[$ + I] = U & 67108863;
      }
      for (; $ < this.length - I; $++)
        U = (this.words[$ + I] | 0) + Y, Y = U >> 26, this.words[$ + I] = U & 67108863;
      if (Y === 0)
        return this.strip();
      for (l(Y === -1), Y = 0, $ = 0; $ < this.length; $++)
        U = -(this.words[$] | 0) + Y, Y = U >> 26, this.words[$] = U & 67108863;
      return this.negative = 1, this.strip();
    }, p.prototype._wordDiv = function(S, E) {
      var I = this.length - S.length, M = this.clone(), $ = S, U = $.words[$.length - 1] | 0, Y = this._countBits(U);
      I = 26 - Y, I !== 0 && ($ = $.ushln(I), M.iushln(I), U = $.words[$.length - 1] | 0);
      var B = M.length - $.length, T;
      if (E !== "mod") {
        T = new p(null), T.length = B + 1, T.words = new Array(T.length);
        for (var L = 0; L < T.length; L++)
          T.words[L] = 0;
      }
      var te = M.clone()._ishlnsubmul($, 1, B);
      te.negative === 0 && (M = te, T && (T.words[B] = 1));
      for (var me = B - 1; me >= 0; me--) {
        var Ce = (M.words[$.length + me] | 0) * 67108864 + (M.words[$.length + me - 1] | 0);
        for (Ce = Math.min(Ce / U | 0, 67108863), M._ishlnsubmul($, Ce, me); M.negative !== 0; )
          Ce--, M.negative = 0, M._ishlnsubmul($, 1, me), M.isZero() || (M.negative ^= 1);
        T && (T.words[me] = Ce);
      }
      return T && T.strip(), M.strip(), E !== "div" && I !== 0 && M.iushrn(I), {
        div: T || null,
        mod: M
      };
    }, p.prototype.divmod = function(S, E, I) {
      if (l(!S.isZero()), this.isZero())
        return {
          div: new p(0),
          mod: new p(0)
        };
      var M, $, U;
      return this.negative !== 0 && S.negative === 0 ? (U = this.neg().divmod(S, E), E !== "mod" && (M = U.div.neg()), E !== "div" && ($ = U.mod.neg(), I && $.negative !== 0 && $.iadd(S)), {
        div: M,
        mod: $
      }) : this.negative === 0 && S.negative !== 0 ? (U = this.divmod(S.neg(), E), E !== "mod" && (M = U.div.neg()), {
        div: M,
        mod: U.mod
      }) : this.negative & S.negative ? (U = this.neg().divmod(S.neg(), E), E !== "div" && ($ = U.mod.neg(), I && $.negative !== 0 && $.isub(S)), {
        div: U.div,
        mod: $
      }) : S.length > this.length || this.cmp(S) < 0 ? {
        div: new p(0),
        mod: this
      } : S.length === 1 ? E === "div" ? {
        div: this.divn(S.words[0]),
        mod: null
      } : E === "mod" ? {
        div: null,
        mod: new p(this.modn(S.words[0]))
      } : {
        div: this.divn(S.words[0]),
        mod: new p(this.modn(S.words[0]))
      } : this._wordDiv(S, E);
    }, p.prototype.div = function(S) {
      return this.divmod(S, "div", !1).div;
    }, p.prototype.mod = function(S) {
      return this.divmod(S, "mod", !1).mod;
    }, p.prototype.umod = function(S) {
      return this.divmod(S, "mod", !0).mod;
    }, p.prototype.divRound = function(S) {
      var E = this.divmod(S);
      if (E.mod.isZero())
        return E.div;
      var I = E.div.negative !== 0 ? E.mod.isub(S) : E.mod, M = S.ushrn(1), $ = S.andln(1), U = I.cmp(M);
      return U < 0 || $ === 1 && U === 0 ? E.div : E.div.negative !== 0 ? E.div.isubn(1) : E.div.iaddn(1);
    }, p.prototype.modn = function(S) {
      l(S <= 67108863);
      for (var E = (1 << 26) % S, I = 0, M = this.length - 1; M >= 0; M--)
        I = (E * I + (this.words[M] | 0)) % S;
      return I;
    }, p.prototype.idivn = function(S) {
      l(S <= 67108863);
      for (var E = 0, I = this.length - 1; I >= 0; I--) {
        var M = (this.words[I] | 0) + E * 67108864;
        this.words[I] = M / S | 0, E = M % S;
      }
      return this.strip();
    }, p.prototype.divn = function(S) {
      return this.clone().idivn(S);
    }, p.prototype.egcd = function(S) {
      l(S.negative === 0), l(!S.isZero());
      var E = this, I = S.clone();
      E.negative !== 0 ? E = E.umod(S) : E = E.clone();
      for (var M = new p(1), $ = new p(0), U = new p(0), Y = new p(1), B = 0; E.isEven() && I.isEven(); )
        E.iushrn(1), I.iushrn(1), ++B;
      for (var T = I.clone(), L = E.clone(); !E.isZero(); ) {
        for (var te = 0, me = 1; !(E.words[0] & me) && te < 26; ++te, me <<= 1)
          ;
        if (te > 0)
          for (E.iushrn(te); te-- > 0; )
            (M.isOdd() || $.isOdd()) && (M.iadd(T), $.isub(L)), M.iushrn(1), $.iushrn(1);
        for (var Ce = 0, De = 1; !(I.words[0] & De) && Ce < 26; ++Ce, De <<= 1)
          ;
        if (Ce > 0)
          for (I.iushrn(Ce); Ce-- > 0; )
            (U.isOdd() || Y.isOdd()) && (U.iadd(T), Y.isub(L)), U.iushrn(1), Y.iushrn(1);
        E.cmp(I) >= 0 ? (E.isub(I), M.isub(U), $.isub(Y)) : (I.isub(E), U.isub(M), Y.isub($));
      }
      return {
        a: U,
        b: Y,
        gcd: I.iushln(B)
      };
    }, p.prototype._invmp = function(S) {
      l(S.negative === 0), l(!S.isZero());
      var E = this, I = S.clone();
      E.negative !== 0 ? E = E.umod(S) : E = E.clone();
      for (var M = new p(1), $ = new p(0), U = I.clone(); E.cmpn(1) > 0 && I.cmpn(1) > 0; ) {
        for (var Y = 0, B = 1; !(E.words[0] & B) && Y < 26; ++Y, B <<= 1)
          ;
        if (Y > 0)
          for (E.iushrn(Y); Y-- > 0; )
            M.isOdd() && M.iadd(U), M.iushrn(1);
        for (var T = 0, L = 1; !(I.words[0] & L) && T < 26; ++T, L <<= 1)
          ;
        if (T > 0)
          for (I.iushrn(T); T-- > 0; )
            $.isOdd() && $.iadd(U), $.iushrn(1);
        E.cmp(I) >= 0 ? (E.isub(I), M.isub($)) : (I.isub(E), $.isub(M));
      }
      var te;
      return E.cmpn(1) === 0 ? te = M : te = $, te.cmpn(0) < 0 && te.iadd(S), te;
    }, p.prototype.gcd = function(S) {
      if (this.isZero())
        return S.abs();
      if (S.isZero())
        return this.abs();
      var E = this.clone(), I = S.clone();
      E.negative = 0, I.negative = 0;
      for (var M = 0; E.isEven() && I.isEven(); M++)
        E.iushrn(1), I.iushrn(1);
      do {
        for (; E.isEven(); )
          E.iushrn(1);
        for (; I.isEven(); )
          I.iushrn(1);
        var $ = E.cmp(I);
        if ($ < 0) {
          var U = E;
          E = I, I = U;
        } else if ($ === 0 || I.cmpn(1) === 0)
          break;
        E.isub(I);
      } while (!0);
      return I.iushln(M);
    }, p.prototype.invm = function(S) {
      return this.egcd(S).a.umod(S);
    }, p.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, p.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, p.prototype.andln = function(S) {
      return this.words[0] & S;
    }, p.prototype.bincn = function(S) {
      l(typeof S == "number");
      var E = S % 26, I = (S - E) / 26, M = 1 << E;
      if (this.length <= I)
        return this._expand(I + 1), this.words[I] |= M, this;
      for (var $ = M, U = I; $ !== 0 && U < this.length; U++) {
        var Y = this.words[U] | 0;
        Y += $, $ = Y >>> 26, Y &= 67108863, this.words[U] = Y;
      }
      return $ !== 0 && (this.words[U] = $, this.length++), this;
    }, p.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, p.prototype.cmpn = function(S) {
      var E = S < 0;
      if (this.negative !== 0 && !E)
        return -1;
      if (this.negative === 0 && E)
        return 1;
      this.strip();
      var I;
      if (this.length > 1)
        I = 1;
      else {
        E && (S = -S), l(S <= 67108863, "Number is too big");
        var M = this.words[0] | 0;
        I = M === S ? 0 : M < S ? -1 : 1;
      }
      return this.negative !== 0 ? -I | 0 : I;
    }, p.prototype.cmp = function(S) {
      if (this.negative !== 0 && S.negative === 0)
        return -1;
      if (this.negative === 0 && S.negative !== 0)
        return 1;
      var E = this.ucmp(S);
      return this.negative !== 0 ? -E | 0 : E;
    }, p.prototype.ucmp = function(S) {
      if (this.length > S.length)
        return 1;
      if (this.length < S.length)
        return -1;
      for (var E = 0, I = this.length - 1; I >= 0; I--) {
        var M = this.words[I] | 0, $ = S.words[I] | 0;
        if (M !== $) {
          M < $ ? E = -1 : M > $ && (E = 1);
          break;
        }
      }
      return E;
    }, p.prototype.gtn = function(S) {
      return this.cmpn(S) === 1;
    }, p.prototype.gt = function(S) {
      return this.cmp(S) === 1;
    }, p.prototype.gten = function(S) {
      return this.cmpn(S) >= 0;
    }, p.prototype.gte = function(S) {
      return this.cmp(S) >= 0;
    }, p.prototype.ltn = function(S) {
      return this.cmpn(S) === -1;
    }, p.prototype.lt = function(S) {
      return this.cmp(S) === -1;
    }, p.prototype.lten = function(S) {
      return this.cmpn(S) <= 0;
    }, p.prototype.lte = function(S) {
      return this.cmp(S) <= 0;
    }, p.prototype.eqn = function(S) {
      return this.cmpn(S) === 0;
    }, p.prototype.eq = function(S) {
      return this.cmp(S) === 0;
    }, p.red = function(S) {
      return new q(S);
    }, p.prototype.toRed = function(S) {
      return l(!this.red, "Already a number in reduction context"), l(this.negative === 0, "red works only with positives"), S.convertTo(this)._forceRed(S);
    }, p.prototype.fromRed = function() {
      return l(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, p.prototype._forceRed = function(S) {
      return this.red = S, this;
    }, p.prototype.forceRed = function(S) {
      return l(!this.red, "Already a number in reduction context"), this._forceRed(S);
    }, p.prototype.redAdd = function(S) {
      return l(this.red, "redAdd works only with red numbers"), this.red.add(this, S);
    }, p.prototype.redIAdd = function(S) {
      return l(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, S);
    }, p.prototype.redSub = function(S) {
      return l(this.red, "redSub works only with red numbers"), this.red.sub(this, S);
    }, p.prototype.redISub = function(S) {
      return l(this.red, "redISub works only with red numbers"), this.red.isub(this, S);
    }, p.prototype.redShl = function(S) {
      return l(this.red, "redShl works only with red numbers"), this.red.shl(this, S);
    }, p.prototype.redMul = function(S) {
      return l(this.red, "redMul works only with red numbers"), this.red._verify2(this, S), this.red.mul(this, S);
    }, p.prototype.redIMul = function(S) {
      return l(this.red, "redMul works only with red numbers"), this.red._verify2(this, S), this.red.imul(this, S);
    }, p.prototype.redSqr = function() {
      return l(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, p.prototype.redISqr = function() {
      return l(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, p.prototype.redSqrt = function() {
      return l(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, p.prototype.redInvm = function() {
      return l(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, p.prototype.redNeg = function() {
      return l(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, p.prototype.redPow = function(S) {
      return l(this.red && !S.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, S);
    };
    var ue = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function he(P, S) {
      this.name = P, this.p = new p(S, 16), this.n = this.p.bitLength(), this.k = new p(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    he.prototype._tmp = function() {
      var S = new p(null);
      return S.words = new Array(Math.ceil(this.n / 13)), S;
    }, he.prototype.ireduce = function(S) {
      var E = S, I;
      do
        this.split(E, this.tmp), E = this.imulK(E), E = E.iadd(this.tmp), I = E.bitLength();
      while (I > this.n);
      var M = I < this.n ? -1 : E.ucmp(this.p);
      return M === 0 ? (E.words[0] = 0, E.length = 1) : M > 0 ? E.isub(this.p) : E.strip !== void 0 ? E.strip() : E._strip(), E;
    }, he.prototype.split = function(S, E) {
      S.iushrn(this.n, 0, E);
    }, he.prototype.imulK = function(S) {
      return S.imul(this.k);
    };
    function fe() {
      he.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    v(fe, he), fe.prototype.split = function(S, E) {
      for (var I = 4194303, M = Math.min(S.length, 9), $ = 0; $ < M; $++)
        E.words[$] = S.words[$];
      if (E.length = M, S.length <= 9) {
        S.words[0] = 0, S.length = 1;
        return;
      }
      var U = S.words[9];
      for (E.words[E.length++] = U & I, $ = 10; $ < S.length; $++) {
        var Y = S.words[$] | 0;
        S.words[$ - 10] = (Y & I) << 4 | U >>> 22, U = Y;
      }
      U >>>= 22, S.words[$ - 10] = U, U === 0 && S.length > 10 ? S.length -= 10 : S.length -= 9;
    }, fe.prototype.imulK = function(S) {
      S.words[S.length] = 0, S.words[S.length + 1] = 0, S.length += 2;
      for (var E = 0, I = 0; I < S.length; I++) {
        var M = S.words[I] | 0;
        E += M * 977, S.words[I] = E & 67108863, E = M * 64 + (E / 67108864 | 0);
      }
      return S.words[S.length - 1] === 0 && (S.length--, S.words[S.length - 1] === 0 && S.length--), S;
    };
    function be() {
      he.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    v(be, he);
    function ke() {
      he.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    v(ke, he);
    function Te() {
      he.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    v(Te, he), Te.prototype.imulK = function(S) {
      for (var E = 0, I = 0; I < S.length; I++) {
        var M = (S.words[I] | 0) * 19 + E, $ = M & 67108863;
        M >>>= 26, S.words[I] = $, E = M;
      }
      return E !== 0 && (S.words[S.length++] = E), S;
    }, p._prime = function(S) {
      if (ue[S])
        return ue[S];
      var E;
      if (S === "k256")
        E = new fe();
      else if (S === "p224")
        E = new be();
      else if (S === "p192")
        E = new ke();
      else if (S === "p25519")
        E = new Te();
      else
        throw new Error("Unknown prime " + S);
      return ue[S] = E, E;
    };
    function q(P) {
      if (typeof P == "string") {
        var S = p._prime(P);
        this.m = S.p, this.prime = S;
      } else
        l(P.gtn(1), "modulus must be greater than 1"), this.m = P, this.prime = null;
    }
    q.prototype._verify1 = function(S) {
      l(S.negative === 0, "red works only with positives"), l(S.red, "red works only with red numbers");
    }, q.prototype._verify2 = function(S, E) {
      l((S.negative | E.negative) === 0, "red works only with positives"), l(
        S.red && S.red === E.red,
        "red works only with red numbers"
      );
    }, q.prototype.imod = function(S) {
      return this.prime ? this.prime.ireduce(S)._forceRed(this) : S.umod(this.m)._forceRed(this);
    }, q.prototype.neg = function(S) {
      return S.isZero() ? S.clone() : this.m.sub(S)._forceRed(this);
    }, q.prototype.add = function(S, E) {
      this._verify2(S, E);
      var I = S.add(E);
      return I.cmp(this.m) >= 0 && I.isub(this.m), I._forceRed(this);
    }, q.prototype.iadd = function(S, E) {
      this._verify2(S, E);
      var I = S.iadd(E);
      return I.cmp(this.m) >= 0 && I.isub(this.m), I;
    }, q.prototype.sub = function(S, E) {
      this._verify2(S, E);
      var I = S.sub(E);
      return I.cmpn(0) < 0 && I.iadd(this.m), I._forceRed(this);
    }, q.prototype.isub = function(S, E) {
      this._verify2(S, E);
      var I = S.isub(E);
      return I.cmpn(0) < 0 && I.iadd(this.m), I;
    }, q.prototype.shl = function(S, E) {
      return this._verify1(S), this.imod(S.ushln(E));
    }, q.prototype.imul = function(S, E) {
      return this._verify2(S, E), this.imod(S.imul(E));
    }, q.prototype.mul = function(S, E) {
      return this._verify2(S, E), this.imod(S.mul(E));
    }, q.prototype.isqr = function(S) {
      return this.imul(S, S.clone());
    }, q.prototype.sqr = function(S) {
      return this.mul(S, S);
    }, q.prototype.sqrt = function(S) {
      if (S.isZero())
        return S.clone();
      var E = this.m.andln(3);
      if (l(E % 2 === 1), E === 3) {
        var I = this.m.add(new p(1)).iushrn(2);
        return this.pow(S, I);
      }
      for (var M = this.m.subn(1), $ = 0; !M.isZero() && M.andln(1) === 0; )
        $++, M.iushrn(1);
      l(!M.isZero());
      var U = new p(1).toRed(this), Y = U.redNeg(), B = this.m.subn(1).iushrn(1), T = this.m.bitLength();
      for (T = new p(2 * T * T).toRed(this); this.pow(T, B).cmp(Y) !== 0; )
        T.redIAdd(Y);
      for (var L = this.pow(T, M), te = this.pow(S, M.addn(1).iushrn(1)), me = this.pow(S, M), Ce = $; me.cmp(U) !== 0; ) {
        for (var De = me, ye = 0; De.cmp(U) !== 0; ye++)
          De = De.redSqr();
        l(ye < Ce);
        var pe = this.pow(L, new p(1).iushln(Ce - ye - 1));
        te = te.redMul(pe), L = pe.redSqr(), me = me.redMul(L), Ce = ye;
      }
      return te;
    }, q.prototype.invm = function(S) {
      var E = S._invmp(this.m);
      return E.negative !== 0 ? (E.negative = 0, this.imod(E).redNeg()) : this.imod(E);
    }, q.prototype.pow = function(S, E) {
      if (E.isZero())
        return new p(1).toRed(this);
      if (E.cmpn(1) === 0)
        return S.clone();
      var I = 4, M = new Array(1 << I);
      M[0] = new p(1).toRed(this), M[1] = S;
      for (var $ = 2; $ < M.length; $++)
        M[$] = this.mul(M[$ - 1], S);
      var U = M[0], Y = 0, B = 0, T = E.bitLength() % 26;
      for (T === 0 && (T = 26), $ = E.length - 1; $ >= 0; $--) {
        for (var L = E.words[$], te = T - 1; te >= 0; te--) {
          var me = L >> te & 1;
          if (U !== M[0] && (U = this.sqr(U)), me === 0 && Y === 0) {
            B = 0;
            continue;
          }
          Y <<= 1, Y |= me, B++, !(B !== I && ($ !== 0 || te !== 0)) && (U = this.mul(U, M[Y]), B = 0, Y = 0);
        }
        T = 26;
      }
      return U;
    }, q.prototype.convertTo = function(S) {
      var E = S.umod(this.m);
      return E === S ? E.clone() : E;
    }, q.prototype.convertFrom = function(S) {
      var E = S.clone();
      return E.red = null, E;
    }, p.mont = function(S) {
      return new z(S);
    };
    function z(P) {
      q.call(this, P), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new p(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    v(z, q), z.prototype.convertTo = function(S) {
      return this.imod(S.ushln(this.shift));
    }, z.prototype.convertFrom = function(S) {
      var E = this.imod(S.mul(this.rinv));
      return E.red = null, E;
    }, z.prototype.imul = function(S, E) {
      if (S.isZero() || E.isZero())
        return S.words[0] = 0, S.length = 1, S;
      var I = S.imul(E), M = I.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), $ = I.isub(M).iushrn(this.shift), U = $;
      return $.cmp(this.m) >= 0 ? U = $.isub(this.m) : $.cmpn(0) < 0 && (U = $.iadd(this.m)), U._forceRed(this);
    }, z.prototype.mul = function(S, E) {
      if (S.isZero() || E.isZero())
        return new p(0)._forceRed(this);
      var I = S.mul(E), M = I.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), $ = I.isub(M).iushrn(this.shift), U = $;
      return $.cmp(this.m) >= 0 ? U = $.isub(this.m) : $.cmpn(0) < 0 && (U = $.iadd(this.m)), U._forceRed(this);
    }, z.prototype.invm = function(S) {
      var E = this.imod(S._invmp(this.m).mul(this.r2));
      return E._forceRed(this);
    };
  })(a, commonjsGlobal$1);
})(bn$5);
var bnExports$5 = bn$5.exports, brorand = { exports: {} }, hasRequiredBrorand;
function requireBrorand() {
  if (hasRequiredBrorand)
    return brorand.exports;
  hasRequiredBrorand = 1;
  var a;
  brorand.exports = function(v) {
    return a || (a = new u(null)), a.generate(v);
  };
  function u(l) {
    this.rand = l;
  }
  if (brorand.exports.Rand = u, u.prototype.generate = function(v) {
    return this._rand(v);
  }, u.prototype._rand = function(v) {
    if (this.rand.getBytes)
      return this.rand.getBytes(v);
    for (var p = new Uint8Array(v), _ = 0; _ < p.length; _++)
      p[_] = this.rand.getByte();
    return p;
  }, typeof self == "object")
    self.crypto && self.crypto.getRandomValues ? u.prototype._rand = function(v) {
      var p = new Uint8Array(v);
      return self.crypto.getRandomValues(p), p;
    } : self.msCrypto && self.msCrypto.getRandomValues ? u.prototype._rand = function(v) {
      var p = new Uint8Array(v);
      return self.msCrypto.getRandomValues(p), p;
    } : typeof window == "object" && (u.prototype._rand = function() {
      throw new Error("Not implemented yet");
    });
  else
    try {
      var c = requireCryptoBrowserify();
      if (typeof c.randomBytes != "function")
        throw new Error("Not supported");
      u.prototype._rand = function(v) {
        return c.randomBytes(v);
      };
    } catch {
    }
  return brorand.exports;
}
var mr, hasRequiredMr;
function requireMr() {
  if (hasRequiredMr)
    return mr;
  hasRequiredMr = 1;
  var a = bnExports$5, u = requireBrorand();
  function c(l) {
    this.rand = l || new u.Rand();
  }
  return mr = c, c.create = function(v) {
    return new c(v);
  }, c.prototype._randbelow = function(v) {
    var p = v.bitLength(), _ = Math.ceil(p / 8);
    do
      var k = new a(this.rand.generate(_));
    while (k.cmp(v) >= 0);
    return k;
  }, c.prototype._randrange = function(v, p) {
    var _ = p.sub(v);
    return v.add(this._randbelow(_));
  }, c.prototype.test = function(v, p, _) {
    var k = v.bitLength(), O = a.mont(v), D = new a(1).toRed(O);
    p || (p = Math.max(1, k / 48 | 0));
    for (var F = v.subn(1), H = 0; !F.testn(H); H++)
      ;
    for (var Z = v.shrn(H), ee = F.toRed(O), X = !0; p > 0; p--) {
      var ne = this._randrange(new a(2), F);
      _ && _(ne);
      var Q = ne.toRed(O).redPow(Z);
      if (!(Q.cmp(D) === 0 || Q.cmp(ee) === 0)) {
        for (var ae = 1; ae < H; ae++) {
          if (Q = Q.redSqr(), Q.cmp(D) === 0)
            return !1;
          if (Q.cmp(ee) === 0)
            break;
        }
        if (ae === H)
          return !1;
      }
    }
    return X;
  }, c.prototype.getDivisor = function(v, p) {
    var _ = v.bitLength(), k = a.mont(v), O = new a(1).toRed(k);
    p || (p = Math.max(1, _ / 48 | 0));
    for (var D = v.subn(1), F = 0; !D.testn(F); F++)
      ;
    for (var H = v.shrn(F), Z = D.toRed(k); p > 0; p--) {
      var ee = this._randrange(new a(2), D), X = v.gcd(ee);
      if (X.cmpn(1) !== 0)
        return X;
      var ne = ee.toRed(k).redPow(H);
      if (!(ne.cmp(O) === 0 || ne.cmp(Z) === 0)) {
        for (var Q = 1; Q < F; Q++) {
          if (ne = ne.redSqr(), ne.cmp(O) === 0)
            return ne.fromRed().subn(1).gcd(v);
          if (ne.cmp(Z) === 0)
            break;
        }
        if (Q === F)
          return ne = ne.redSqr(), ne.fromRed().subn(1).gcd(v);
      }
    }
    return !1;
  }, mr;
}
var generatePrime, hasRequiredGeneratePrime;
function requireGeneratePrime() {
  if (hasRequiredGeneratePrime)
    return generatePrime;
  hasRequiredGeneratePrime = 1;
  var a = browserExports;
  generatePrime = Q, Q.simpleSieve = X, Q.fermatTest = ne;
  var u = bnExports$6, c = new u(24), l = requireMr(), v = new l(), p = new u(1), _ = new u(2), k = new u(5);
  new u(16), new u(8);
  var O = new u(10), D = new u(3);
  new u(7);
  var F = new u(11), H = new u(4);
  new u(12);
  var Z = null;
  function ee() {
    if (Z !== null)
      return Z;
    var ae = 1048576, j = [];
    j[0] = 2;
    for (var ue = 1, he = 3; he < ae; he += 2) {
      for (var fe = Math.ceil(Math.sqrt(he)), be = 0; be < ue && j[be] <= fe && he % j[be] !== 0; be++)
        ;
      ue !== be && j[be] <= fe || (j[ue++] = he);
    }
    return Z = j, j;
  }
  function X(ae) {
    for (var j = ee(), ue = 0; ue < j.length; ue++)
      if (ae.modn(j[ue]) === 0)
        return ae.cmpn(j[ue]) === 0;
    return !0;
  }
  function ne(ae) {
    var j = u.mont(ae);
    return _.toRed(j).redPow(ae.subn(1)).fromRed().cmpn(1) === 0;
  }
  function Q(ae, j) {
    if (ae < 16)
      return j === 2 || j === 5 ? new u([140, 123]) : new u([140, 39]);
    j = new u(j);
    for (var ue, he; ; ) {
      for (ue = new u(a(Math.ceil(ae / 8))); ue.bitLength() > ae; )
        ue.ishrn(1);
      if (ue.isEven() && ue.iadd(p), ue.testn(1) || ue.iadd(_), j.cmp(_)) {
        if (!j.cmp(k))
          for (; ue.mod(O).cmp(D); )
            ue.iadd(H);
      } else
        for (; ue.mod(c).cmp(F); )
          ue.iadd(H);
      if (he = ue.shrn(1), X(he) && X(ue) && ne(he) && ne(ue) && v.test(he) && v.test(ue))
        return ue;
    }
  }
  return generatePrime;
}
const modp1 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
}, modp2 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
}, modp5 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
}, modp14 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
}, modp15 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
}, modp16 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
}, modp17 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
}, modp18 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
}, require$$1$1 = {
  modp1,
  modp2,
  modp5,
  modp14,
  modp15,
  modp16,
  modp17,
  modp18
};
var dh, hasRequiredDh;
function requireDh() {
  if (hasRequiredDh)
    return dh;
  hasRequiredDh = 1;
  var a = bnExports$6, u = requireMr(), c = new u(), l = new a(24), v = new a(11), p = new a(10), _ = new a(3), k = new a(7), O = requireGeneratePrime(), D = browserExports;
  dh = X;
  function F(Q, ae) {
    return ae = ae || "utf8", Buffer$O.isBuffer(Q) || (Q = new Buffer$O(Q, ae)), this._pub = new a(Q), this;
  }
  function H(Q, ae) {
    return ae = ae || "utf8", Buffer$O.isBuffer(Q) || (Q = new Buffer$O(Q, ae)), this._priv = new a(Q), this;
  }
  var Z = {};
  function ee(Q, ae) {
    var j = ae.toString("hex"), ue = [j, Q.toString(16)].join("_");
    if (ue in Z)
      return Z[ue];
    var he = 0;
    if (Q.isEven() || !O.simpleSieve || !O.fermatTest(Q) || !c.test(Q))
      return he += 1, j === "02" || j === "05" ? he += 8 : he += 4, Z[ue] = he, he;
    c.test(Q.shrn(1)) || (he += 2);
    var fe;
    switch (j) {
      case "02":
        Q.mod(l).cmp(v) && (he += 8);
        break;
      case "05":
        fe = Q.mod(p), fe.cmp(_) && fe.cmp(k) && (he += 8);
        break;
      default:
        he += 4;
    }
    return Z[ue] = he, he;
  }
  function X(Q, ae, j) {
    this.setGenerator(ae), this.__prime = new a(Q), this._prime = a.mont(this.__prime), this._primeLen = Q.length, this._pub = void 0, this._priv = void 0, this._primeCode = void 0, j ? (this.setPublicKey = F, this.setPrivateKey = H) : this._primeCode = 8;
  }
  Object.defineProperty(X.prototype, "verifyError", {
    enumerable: !0,
    get: function() {
      return typeof this._primeCode != "number" && (this._primeCode = ee(this.__prime, this.__gen)), this._primeCode;
    }
  }), X.prototype.generateKeys = function() {
    return this._priv || (this._priv = new a(D(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey();
  }, X.prototype.computeSecret = function(Q) {
    Q = new a(Q), Q = Q.toRed(this._prime);
    var ae = Q.redPow(this._priv).fromRed(), j = new Buffer$O(ae.toArray()), ue = this.getPrime();
    if (j.length < ue.length) {
      var he = new Buffer$O(ue.length - j.length);
      he.fill(0), j = Buffer$O.concat([he, j]);
    }
    return j;
  }, X.prototype.getPublicKey = function(ae) {
    return ne(this._pub, ae);
  }, X.prototype.getPrivateKey = function(ae) {
    return ne(this._priv, ae);
  }, X.prototype.getPrime = function(Q) {
    return ne(this.__prime, Q);
  }, X.prototype.getGenerator = function(Q) {
    return ne(this._gen, Q);
  }, X.prototype.setGenerator = function(Q, ae) {
    return ae = ae || "utf8", Buffer$O.isBuffer(Q) || (Q = new Buffer$O(Q, ae)), this.__gen = Q, this._gen = new a(Q), this;
  };
  function ne(Q, ae) {
    var j = new Buffer$O(Q.toArray());
    return ae ? j.toString(ae) : j;
  }
  return dh;
}
var hasRequiredBrowser$2;
function requireBrowser$2() {
  if (hasRequiredBrowser$2)
    return browser$5;
  hasRequiredBrowser$2 = 1;
  var a = requireGeneratePrime(), u = require$$1$1, c = requireDh();
  function l(_) {
    var k = new Buffer$O(u[_].prime, "hex"), O = new Buffer$O(u[_].gen, "hex");
    return new c(k, O);
  }
  var v = {
    binary: !0,
    hex: !0,
    base64: !0
  };
  function p(_, k, O, D) {
    return Buffer$O.isBuffer(k) || v[k] === void 0 ? p(_, "binary", k, O) : (k = k || "binary", D = D || "binary", O = O || new Buffer$O([2]), Buffer$O.isBuffer(O) || (O = new Buffer$O(O, D)), typeof _ == "number" ? new c(a(_, O), O, !0) : (Buffer$O.isBuffer(_) || (_ = new Buffer$O(_, k)), new c(_, O, !0)));
  }
  return browser$5.DiffieHellmanGroup = browser$5.createDiffieHellmanGroup = browser$5.getDiffieHellman = l, browser$5.createDiffieHellman = browser$5.DiffieHellman = p, browser$5;
}
var safeBuffer$1 = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(a, u) {
  var c = require$$0$2, l = c.Buffer;
  function v(_, k) {
    for (var O in _)
      k[O] = _[O];
  }
  l.from && l.alloc && l.allocUnsafe && l.allocUnsafeSlow ? a.exports = c : (v(c, u), u.Buffer = p);
  function p(_, k, O) {
    return l(_, k, O);
  }
  p.prototype = Object.create(l.prototype), v(l, p), p.from = function(_, k, O) {
    if (typeof _ == "number")
      throw new TypeError("Argument must not be a number");
    return l(_, k, O);
  }, p.alloc = function(_, k, O) {
    if (typeof _ != "number")
      throw new TypeError("Argument must be a number");
    var D = l(_);
    return k !== void 0 ? typeof O == "string" ? D.fill(k, O) : D.fill(k) : D.fill(0), D;
  }, p.allocUnsafe = function(_) {
    if (typeof _ != "number")
      throw new TypeError("Argument must be a number");
    return l(_);
  }, p.allocUnsafeSlow = function(_) {
    if (typeof _ != "number")
      throw new TypeError("Argument must be a number");
    return c.SlowBuffer(_);
  };
})(safeBuffer$1, safeBuffer$1.exports);
var safeBufferExports = safeBuffer$1.exports, readableBrowser = { exports: {} }, streamBrowser = eventsExports.EventEmitter, buffer_list, hasRequiredBuffer_list;
function requireBuffer_list() {
  if (hasRequiredBuffer_list)
    return buffer_list;
  hasRequiredBuffer_list = 1;
  function a(X, ne) {
    var Q = Object.keys(X);
    if (Object.getOwnPropertySymbols) {
      var ae = Object.getOwnPropertySymbols(X);
      ne && (ae = ae.filter(function(j) {
        return Object.getOwnPropertyDescriptor(X, j).enumerable;
      })), Q.push.apply(Q, ae);
    }
    return Q;
  }
  function u(X) {
    for (var ne = 1; ne < arguments.length; ne++) {
      var Q = arguments[ne] != null ? arguments[ne] : {};
      ne % 2 ? a(Object(Q), !0).forEach(function(ae) {
        c(X, ae, Q[ae]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(X, Object.getOwnPropertyDescriptors(Q)) : a(Object(Q)).forEach(function(ae) {
        Object.defineProperty(X, ae, Object.getOwnPropertyDescriptor(Q, ae));
      });
    }
    return X;
  }
  function c(X, ne, Q) {
    return ne = _(ne), ne in X ? Object.defineProperty(X, ne, { value: Q, enumerable: !0, configurable: !0, writable: !0 }) : X[ne] = Q, X;
  }
  function l(X, ne) {
    if (!(X instanceof ne))
      throw new TypeError("Cannot call a class as a function");
  }
  function v(X, ne) {
    for (var Q = 0; Q < ne.length; Q++) {
      var ae = ne[Q];
      ae.enumerable = ae.enumerable || !1, ae.configurable = !0, "value" in ae && (ae.writable = !0), Object.defineProperty(X, _(ae.key), ae);
    }
  }
  function p(X, ne, Q) {
    return ne && v(X.prototype, ne), Q && v(X, Q), Object.defineProperty(X, "prototype", { writable: !1 }), X;
  }
  function _(X) {
    var ne = k(X, "string");
    return typeof ne == "symbol" ? ne : String(ne);
  }
  function k(X, ne) {
    if (typeof X != "object" || X === null)
      return X;
    var Q = X[Symbol.toPrimitive];
    if (Q !== void 0) {
      var ae = Q.call(X, ne || "default");
      if (typeof ae != "object")
        return ae;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (ne === "string" ? String : Number)(X);
  }
  var O = require$$0$2, D = O.Buffer, F = util$4, H = F.inspect, Z = H && H.custom || "inspect";
  function ee(X, ne, Q) {
    D.prototype.copy.call(X, ne, Q);
  }
  return buffer_list = /* @__PURE__ */ function() {
    function X() {
      l(this, X), this.head = null, this.tail = null, this.length = 0;
    }
    return p(X, [{
      key: "push",
      value: function(Q) {
        var ae = {
          data: Q,
          next: null
        };
        this.length > 0 ? this.tail.next = ae : this.head = ae, this.tail = ae, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(Q) {
        var ae = {
          data: Q,
          next: this.head
        };
        this.length === 0 && (this.tail = ae), this.head = ae, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var Q = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, Q;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(Q) {
        if (this.length === 0)
          return "";
        for (var ae = this.head, j = "" + ae.data; ae = ae.next; )
          j += Q + ae.data;
        return j;
      }
    }, {
      key: "concat",
      value: function(Q) {
        if (this.length === 0)
          return D.alloc(0);
        for (var ae = D.allocUnsafe(Q >>> 0), j = this.head, ue = 0; j; )
          ee(j.data, ae, ue), ue += j.data.length, j = j.next;
        return ae;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(Q, ae) {
        var j;
        return Q < this.head.data.length ? (j = this.head.data.slice(0, Q), this.head.data = this.head.data.slice(Q)) : Q === this.head.data.length ? j = this.shift() : j = ae ? this._getString(Q) : this._getBuffer(Q), j;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(Q) {
        var ae = this.head, j = 1, ue = ae.data;
        for (Q -= ue.length; ae = ae.next; ) {
          var he = ae.data, fe = Q > he.length ? he.length : Q;
          if (fe === he.length ? ue += he : ue += he.slice(0, Q), Q -= fe, Q === 0) {
            fe === he.length ? (++j, ae.next ? this.head = ae.next : this.head = this.tail = null) : (this.head = ae, ae.data = he.slice(fe));
            break;
          }
          ++j;
        }
        return this.length -= j, ue;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(Q) {
        var ae = D.allocUnsafe(Q), j = this.head, ue = 1;
        for (j.data.copy(ae), Q -= j.data.length; j = j.next; ) {
          var he = j.data, fe = Q > he.length ? he.length : Q;
          if (he.copy(ae, ae.length - Q, 0, fe), Q -= fe, Q === 0) {
            fe === he.length ? (++ue, j.next ? this.head = j.next : this.head = this.tail = null) : (this.head = j, j.data = he.slice(fe));
            break;
          }
          ++ue;
        }
        return this.length -= ue, ae;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: Z,
      value: function(Q, ae) {
        return H(this, u(u({}, ae), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), X;
  }(), buffer_list;
}
function destroy(a, u) {
  var c = this, l = this._readableState && this._readableState.destroyed, v = this._writableState && this._writableState.destroyed;
  return l || v ? (u ? u(a) : a && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process$1.nextTick(emitErrorNT, this, a)) : process$1.nextTick(emitErrorNT, this, a)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(a || null, function(p) {
    !u && p ? c._writableState ? c._writableState.errorEmitted ? process$1.nextTick(emitCloseNT, c) : (c._writableState.errorEmitted = !0, process$1.nextTick(emitErrorAndCloseNT, c, p)) : process$1.nextTick(emitErrorAndCloseNT, c, p) : u ? (process$1.nextTick(emitCloseNT, c), u(p)) : process$1.nextTick(emitCloseNT, c);
  }), this);
}
function emitErrorAndCloseNT(a, u) {
  emitErrorNT(a, u), emitCloseNT(a);
}
function emitCloseNT(a) {
  a._writableState && !a._writableState.emitClose || a._readableState && !a._readableState.emitClose || a.emit("close");
}
function undestroy() {
  this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
}
function emitErrorNT(a, u) {
  a.emit("error", u);
}
function errorOrDestroy(a, u) {
  var c = a._readableState, l = a._writableState;
  c && c.autoDestroy || l && l.autoDestroy ? a.destroy(u) : a.emit("error", u);
}
var destroy_1 = {
  destroy,
  undestroy,
  errorOrDestroy
}, errorsBrowser = {};
function _inheritsLoose$1(a, u) {
  a.prototype = Object.create(u.prototype), a.prototype.constructor = a, a.__proto__ = u;
}
var codes = {};
function createErrorType(a, u, c) {
  c || (c = Error);
  function l(p, _, k) {
    return typeof u == "string" ? u : u(p, _, k);
  }
  var v = /* @__PURE__ */ function(p) {
    _inheritsLoose$1(_, p);
    function _(k, O, D) {
      return p.call(this, l(k, O, D)) || this;
    }
    return _;
  }(c);
  v.prototype.name = c.name, v.prototype.code = a, codes[a] = v;
}
function oneOf(a, u) {
  if (Array.isArray(a)) {
    var c = a.length;
    return a = a.map(function(l) {
      return String(l);
    }), c > 2 ? "one of ".concat(u, " ").concat(a.slice(0, c - 1).join(", "), ", or ") + a[c - 1] : c === 2 ? "one of ".concat(u, " ").concat(a[0], " or ").concat(a[1]) : "of ".concat(u, " ").concat(a[0]);
  } else
    return "of ".concat(u, " ").concat(String(a));
}
function startsWith(a, u, c) {
  return a.substr(!c || c < 0 ? 0 : +c, u.length) === u;
}
function endsWith(a, u, c) {
  return (c === void 0 || c > a.length) && (c = a.length), a.substring(c - u.length, c) === u;
}
function includes$2(a, u, c) {
  return typeof c != "number" && (c = 0), c + u.length > a.length ? !1 : a.indexOf(u, c) !== -1;
}
createErrorType("ERR_INVALID_OPT_VALUE", function(a, u) {
  return 'The value "' + u + '" is invalid for option "' + a + '"';
}, TypeError);
createErrorType("ERR_INVALID_ARG_TYPE", function(a, u, c) {
  var l;
  typeof u == "string" && startsWith(u, "not ") ? (l = "must not be", u = u.replace(/^not /, "")) : l = "must be";
  var v;
  if (endsWith(a, " argument"))
    v = "The ".concat(a, " ").concat(l, " ").concat(oneOf(u, "type"));
  else {
    var p = includes$2(a, ".") ? "property" : "argument";
    v = 'The "'.concat(a, '" ').concat(p, " ").concat(l, " ").concat(oneOf(u, "type"));
  }
  return v += ". Received type ".concat(typeof c), v;
}, TypeError);
createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(a) {
  return "The " + a + " method is not implemented";
});
createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
createErrorType("ERR_STREAM_DESTROYED", function(a) {
  return "Cannot call " + a + " after a stream was destroyed";
});
createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
createErrorType("ERR_UNKNOWN_ENCODING", function(a) {
  return "Unknown encoding: " + a;
}, TypeError);
createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
errorsBrowser.codes = codes;
var ERR_INVALID_OPT_VALUE = errorsBrowser.codes.ERR_INVALID_OPT_VALUE;
function highWaterMarkFrom(a, u, c) {
  return a.highWaterMark != null ? a.highWaterMark : u ? a[c] : null;
}
function getHighWaterMark(a, u, c, l) {
  var v = highWaterMarkFrom(u, l, c);
  if (v != null) {
    if (!(isFinite(v) && Math.floor(v) === v) || v < 0) {
      var p = l ? c : "highWaterMark";
      throw new ERR_INVALID_OPT_VALUE(p, v);
    }
    return Math.floor(v);
  }
  return a.objectMode ? 16 : 16 * 1024;
}
var state$3 = {
  getHighWaterMark
}, _stream_writable, hasRequired_stream_writable;
function require_stream_writable() {
  if (hasRequired_stream_writable)
    return _stream_writable;
  hasRequired_stream_writable = 1, _stream_writable = Te;
  function a(ye) {
    var pe = this;
    this.next = null, this.entry = null, this.finish = function() {
      De(pe, ye);
    };
  }
  var u;
  Te.WritableState = be;
  var c = {
    deprecate: browser$c
  }, l = streamBrowser, v = require$$0$2.Buffer, p = (typeof commonjsGlobal$1 < "u" ? commonjsGlobal$1 : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function _(ye) {
    return v.from(ye);
  }
  function k(ye) {
    return v.isBuffer(ye) || ye instanceof p;
  }
  var O = destroy_1, D = state$3, F = D.getHighWaterMark, H = errorsBrowser.codes, Z = H.ERR_INVALID_ARG_TYPE, ee = H.ERR_METHOD_NOT_IMPLEMENTED, X = H.ERR_MULTIPLE_CALLBACK, ne = H.ERR_STREAM_CANNOT_PIPE, Q = H.ERR_STREAM_DESTROYED, ae = H.ERR_STREAM_NULL_VALUES, j = H.ERR_STREAM_WRITE_AFTER_END, ue = H.ERR_UNKNOWN_ENCODING, he = O.errorOrDestroy;
  inherits_browserExports(Te, l);
  function fe() {
  }
  function be(ye, pe, Me) {
    u = u || require_stream_duplex(), ye = ye || {}, typeof Me != "boolean" && (Me = pe instanceof u), this.objectMode = !!ye.objectMode, Me && (this.objectMode = this.objectMode || !!ye.writableObjectMode), this.highWaterMark = F(this, ye, "writableHighWaterMark", Me), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var Ne = ye.decodeStrings === !1;
    this.decodeStrings = !Ne, this.defaultEncoding = ye.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(Ue) {
      $(pe, Ue);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = ye.emitClose !== !1, this.autoDestroy = !!ye.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new a(this);
  }
  be.prototype.getBuffer = function() {
    for (var pe = this.bufferedRequest, Me = []; pe; )
      Me.push(pe), pe = pe.next;
    return Me;
  }, function() {
    try {
      Object.defineProperty(be.prototype, "buffer", {
        get: c.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var ke;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (ke = Function.prototype[Symbol.hasInstance], Object.defineProperty(Te, Symbol.hasInstance, {
    value: function(pe) {
      return ke.call(this, pe) ? !0 : this !== Te ? !1 : pe && pe._writableState instanceof be;
    }
  })) : ke = function(pe) {
    return pe instanceof this;
  };
  function Te(ye) {
    u = u || require_stream_duplex();
    var pe = this instanceof u;
    if (!pe && !ke.call(Te, this))
      return new Te(ye);
    this._writableState = new be(ye, this, pe), this.writable = !0, ye && (typeof ye.write == "function" && (this._write = ye.write), typeof ye.writev == "function" && (this._writev = ye.writev), typeof ye.destroy == "function" && (this._destroy = ye.destroy), typeof ye.final == "function" && (this._final = ye.final)), l.call(this);
  }
  Te.prototype.pipe = function() {
    he(this, new ne());
  };
  function q(ye, pe) {
    var Me = new j();
    he(ye, Me), process$1.nextTick(pe, Me);
  }
  function z(ye, pe, Me, Ne) {
    var Ue;
    return Me === null ? Ue = new ae() : typeof Me != "string" && !pe.objectMode && (Ue = new Z("chunk", ["string", "Buffer"], Me)), Ue ? (he(ye, Ue), process$1.nextTick(Ne, Ue), !1) : !0;
  }
  Te.prototype.write = function(ye, pe, Me) {
    var Ne = this._writableState, Ue = !1, oe = !Ne.objectMode && k(ye);
    return oe && !v.isBuffer(ye) && (ye = _(ye)), typeof pe == "function" && (Me = pe, pe = null), oe ? pe = "buffer" : pe || (pe = Ne.defaultEncoding), typeof Me != "function" && (Me = fe), Ne.ending ? q(this, Me) : (oe || z(this, Ne, ye, Me)) && (Ne.pendingcb++, Ue = S(this, Ne, oe, ye, pe, Me)), Ue;
  }, Te.prototype.cork = function() {
    this._writableState.corked++;
  }, Te.prototype.uncork = function() {
    var ye = this._writableState;
    ye.corked && (ye.corked--, !ye.writing && !ye.corked && !ye.bufferProcessing && ye.bufferedRequest && B(this, ye));
  }, Te.prototype.setDefaultEncoding = function(pe) {
    if (typeof pe == "string" && (pe = pe.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((pe + "").toLowerCase()) > -1))
      throw new ue(pe);
    return this._writableState.defaultEncoding = pe, this;
  }, Object.defineProperty(Te.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function P(ye, pe, Me) {
    return !ye.objectMode && ye.decodeStrings !== !1 && typeof pe == "string" && (pe = v.from(pe, Me)), pe;
  }
  Object.defineProperty(Te.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function S(ye, pe, Me, Ne, Ue, oe) {
    if (!Me) {
      var A = P(pe, Ne, Ue);
      Ne !== A && (Me = !0, Ue = "buffer", Ne = A);
    }
    var re = pe.objectMode ? 1 : Ne.length;
    pe.length += re;
    var le = pe.length < pe.highWaterMark;
    if (le || (pe.needDrain = !0), pe.writing || pe.corked) {
      var $e = pe.lastBufferedRequest;
      pe.lastBufferedRequest = {
        chunk: Ne,
        encoding: Ue,
        isBuf: Me,
        callback: oe,
        next: null
      }, $e ? $e.next = pe.lastBufferedRequest : pe.bufferedRequest = pe.lastBufferedRequest, pe.bufferedRequestCount += 1;
    } else
      E(ye, pe, !1, re, Ne, Ue, oe);
    return le;
  }
  function E(ye, pe, Me, Ne, Ue, oe, A) {
    pe.writelen = Ne, pe.writecb = A, pe.writing = !0, pe.sync = !0, pe.destroyed ? pe.onwrite(new Q("write")) : Me ? ye._writev(Ue, pe.onwrite) : ye._write(Ue, oe, pe.onwrite), pe.sync = !1;
  }
  function I(ye, pe, Me, Ne, Ue) {
    --pe.pendingcb, Me ? (process$1.nextTick(Ue, Ne), process$1.nextTick(me, ye, pe), ye._writableState.errorEmitted = !0, he(ye, Ne)) : (Ue(Ne), ye._writableState.errorEmitted = !0, he(ye, Ne), me(ye, pe));
  }
  function M(ye) {
    ye.writing = !1, ye.writecb = null, ye.length -= ye.writelen, ye.writelen = 0;
  }
  function $(ye, pe) {
    var Me = ye._writableState, Ne = Me.sync, Ue = Me.writecb;
    if (typeof Ue != "function")
      throw new X();
    if (M(Me), pe)
      I(ye, Me, Ne, pe, Ue);
    else {
      var oe = T(Me) || ye.destroyed;
      !oe && !Me.corked && !Me.bufferProcessing && Me.bufferedRequest && B(ye, Me), Ne ? process$1.nextTick(U, ye, Me, oe, Ue) : U(ye, Me, oe, Ue);
    }
  }
  function U(ye, pe, Me, Ne) {
    Me || Y(ye, pe), pe.pendingcb--, Ne(), me(ye, pe);
  }
  function Y(ye, pe) {
    pe.length === 0 && pe.needDrain && (pe.needDrain = !1, ye.emit("drain"));
  }
  function B(ye, pe) {
    pe.bufferProcessing = !0;
    var Me = pe.bufferedRequest;
    if (ye._writev && Me && Me.next) {
      var Ne = pe.bufferedRequestCount, Ue = new Array(Ne), oe = pe.corkedRequestsFree;
      oe.entry = Me;
      for (var A = 0, re = !0; Me; )
        Ue[A] = Me, Me.isBuf || (re = !1), Me = Me.next, A += 1;
      Ue.allBuffers = re, E(ye, pe, !0, pe.length, Ue, "", oe.finish), pe.pendingcb++, pe.lastBufferedRequest = null, oe.next ? (pe.corkedRequestsFree = oe.next, oe.next = null) : pe.corkedRequestsFree = new a(pe), pe.bufferedRequestCount = 0;
    } else {
      for (; Me; ) {
        var le = Me.chunk, $e = Me.encoding, Oe = Me.callback, Fe = pe.objectMode ? 1 : le.length;
        if (E(ye, pe, !1, Fe, le, $e, Oe), Me = Me.next, pe.bufferedRequestCount--, pe.writing)
          break;
      }
      Me === null && (pe.lastBufferedRequest = null);
    }
    pe.bufferedRequest = Me, pe.bufferProcessing = !1;
  }
  Te.prototype._write = function(ye, pe, Me) {
    Me(new ee("_write()"));
  }, Te.prototype._writev = null, Te.prototype.end = function(ye, pe, Me) {
    var Ne = this._writableState;
    return typeof ye == "function" ? (Me = ye, ye = null, pe = null) : typeof pe == "function" && (Me = pe, pe = null), ye != null && this.write(ye, pe), Ne.corked && (Ne.corked = 1, this.uncork()), Ne.ending || Ce(this, Ne, Me), this;
  }, Object.defineProperty(Te.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function T(ye) {
    return ye.ending && ye.length === 0 && ye.bufferedRequest === null && !ye.finished && !ye.writing;
  }
  function L(ye, pe) {
    ye._final(function(Me) {
      pe.pendingcb--, Me && he(ye, Me), pe.prefinished = !0, ye.emit("prefinish"), me(ye, pe);
    });
  }
  function te(ye, pe) {
    !pe.prefinished && !pe.finalCalled && (typeof ye._final == "function" && !pe.destroyed ? (pe.pendingcb++, pe.finalCalled = !0, process$1.nextTick(L, ye, pe)) : (pe.prefinished = !0, ye.emit("prefinish")));
  }
  function me(ye, pe) {
    var Me = T(pe);
    if (Me && (te(ye, pe), pe.pendingcb === 0 && (pe.finished = !0, ye.emit("finish"), pe.autoDestroy))) {
      var Ne = ye._readableState;
      (!Ne || Ne.autoDestroy && Ne.endEmitted) && ye.destroy();
    }
    return Me;
  }
  function Ce(ye, pe, Me) {
    pe.ending = !0, me(ye, pe), Me && (pe.finished ? process$1.nextTick(Me) : ye.once("finish", Me)), pe.ended = !0, ye.writable = !1;
  }
  function De(ye, pe, Me) {
    var Ne = ye.entry;
    for (ye.entry = null; Ne; ) {
      var Ue = Ne.callback;
      pe.pendingcb--, Ue(Me), Ne = Ne.next;
    }
    pe.corkedRequestsFree.next = ye;
  }
  return Object.defineProperty(Te.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(pe) {
      this._writableState && (this._writableState.destroyed = pe);
    }
  }), Te.prototype.destroy = O.destroy, Te.prototype._undestroy = O.undestroy, Te.prototype._destroy = function(ye, pe) {
    pe(ye);
  }, _stream_writable;
}
var _stream_duplex, hasRequired_stream_duplex;
function require_stream_duplex() {
  if (hasRequired_stream_duplex)
    return _stream_duplex;
  hasRequired_stream_duplex = 1;
  var a = Object.keys || function(D) {
    var F = [];
    for (var H in D)
      F.push(H);
    return F;
  };
  _stream_duplex = _;
  var u = require_stream_readable(), c = require_stream_writable();
  inherits_browserExports(_, u);
  for (var l = a(c.prototype), v = 0; v < l.length; v++) {
    var p = l[v];
    _.prototype[p] || (_.prototype[p] = c.prototype[p]);
  }
  function _(D) {
    if (!(this instanceof _))
      return new _(D);
    u.call(this, D), c.call(this, D), this.allowHalfOpen = !0, D && (D.readable === !1 && (this.readable = !1), D.writable === !1 && (this.writable = !1), D.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", k)));
  }
  Object.defineProperty(_.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(_.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(_.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function k() {
    this._writableState.ended || process$1.nextTick(O, this);
  }
  function O(D) {
    D.end();
  }
  return Object.defineProperty(_.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(F) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = F, this._writableState.destroyed = F);
    }
  }), _stream_duplex;
}
var ERR_STREAM_PREMATURE_CLOSE = errorsBrowser.codes.ERR_STREAM_PREMATURE_CLOSE;
function once$3(a) {
  var u = !1;
  return function() {
    if (!u) {
      u = !0;
      for (var c = arguments.length, l = new Array(c), v = 0; v < c; v++)
        l[v] = arguments[v];
      a.apply(this, l);
    }
  };
}
function noop$2() {
}
function isRequest$1(a) {
  return a.setHeader && typeof a.abort == "function";
}
function eos$1(a, u, c) {
  if (typeof u == "function")
    return eos$1(a, null, u);
  u || (u = {}), c = once$3(c || noop$2);
  var l = u.readable || u.readable !== !1 && a.readable, v = u.writable || u.writable !== !1 && a.writable, p = function() {
    a.writable || k();
  }, _ = a._writableState && a._writableState.finished, k = function() {
    v = !1, _ = !0, l || c.call(a);
  }, O = a._readableState && a._readableState.endEmitted, D = function() {
    l = !1, O = !0, v || c.call(a);
  }, F = function(X) {
    c.call(a, X);
  }, H = function() {
    var X;
    if (l && !O)
      return (!a._readableState || !a._readableState.ended) && (X = new ERR_STREAM_PREMATURE_CLOSE()), c.call(a, X);
    if (v && !_)
      return (!a._writableState || !a._writableState.ended) && (X = new ERR_STREAM_PREMATURE_CLOSE()), c.call(a, X);
  }, Z = function() {
    a.req.on("finish", k);
  };
  return isRequest$1(a) ? (a.on("complete", k), a.on("abort", H), a.req ? Z() : a.on("request", Z)) : v && !a._writableState && (a.on("end", p), a.on("close", p)), a.on("end", D), a.on("finish", k), u.error !== !1 && a.on("error", F), a.on("close", H), function() {
    a.removeListener("complete", k), a.removeListener("abort", H), a.removeListener("request", Z), a.req && a.req.removeListener("finish", k), a.removeListener("end", p), a.removeListener("close", p), a.removeListener("finish", k), a.removeListener("end", D), a.removeListener("error", F), a.removeListener("close", H);
  };
}
var endOfStream = eos$1, async_iterator, hasRequiredAsync_iterator;
function requireAsync_iterator() {
  if (hasRequiredAsync_iterator)
    return async_iterator;
  hasRequiredAsync_iterator = 1;
  var a;
  function u(ue, he, fe) {
    return he = c(he), he in ue ? Object.defineProperty(ue, he, { value: fe, enumerable: !0, configurable: !0, writable: !0 }) : ue[he] = fe, ue;
  }
  function c(ue) {
    var he = l(ue, "string");
    return typeof he == "symbol" ? he : String(he);
  }
  function l(ue, he) {
    if (typeof ue != "object" || ue === null)
      return ue;
    var fe = ue[Symbol.toPrimitive];
    if (fe !== void 0) {
      var be = fe.call(ue, he || "default");
      if (typeof be != "object")
        return be;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (he === "string" ? String : Number)(ue);
  }
  var v = endOfStream, p = Symbol("lastResolve"), _ = Symbol("lastReject"), k = Symbol("error"), O = Symbol("ended"), D = Symbol("lastPromise"), F = Symbol("handlePromise"), H = Symbol("stream");
  function Z(ue, he) {
    return {
      value: ue,
      done: he
    };
  }
  function ee(ue) {
    var he = ue[p];
    if (he !== null) {
      var fe = ue[H].read();
      fe !== null && (ue[D] = null, ue[p] = null, ue[_] = null, he(Z(fe, !1)));
    }
  }
  function X(ue) {
    process$1.nextTick(ee, ue);
  }
  function ne(ue, he) {
    return function(fe, be) {
      ue.then(function() {
        if (he[O]) {
          fe(Z(void 0, !0));
          return;
        }
        he[F](fe, be);
      }, be);
    };
  }
  var Q = Object.getPrototypeOf(function() {
  }), ae = Object.setPrototypeOf((a = {
    get stream() {
      return this[H];
    },
    next: function() {
      var he = this, fe = this[k];
      if (fe !== null)
        return Promise.reject(fe);
      if (this[O])
        return Promise.resolve(Z(void 0, !0));
      if (this[H].destroyed)
        return new Promise(function(q, z) {
          process$1.nextTick(function() {
            he[k] ? z(he[k]) : q(Z(void 0, !0));
          });
        });
      var be = this[D], ke;
      if (be)
        ke = new Promise(ne(be, this));
      else {
        var Te = this[H].read();
        if (Te !== null)
          return Promise.resolve(Z(Te, !1));
        ke = new Promise(this[F]);
      }
      return this[D] = ke, ke;
    }
  }, u(a, Symbol.asyncIterator, function() {
    return this;
  }), u(a, "return", function() {
    var he = this;
    return new Promise(function(fe, be) {
      he[H].destroy(null, function(ke) {
        if (ke) {
          be(ke);
          return;
        }
        fe(Z(void 0, !0));
      });
    });
  }), a), Q), j = function(he) {
    var fe, be = Object.create(ae, (fe = {}, u(fe, H, {
      value: he,
      writable: !0
    }), u(fe, p, {
      value: null,
      writable: !0
    }), u(fe, _, {
      value: null,
      writable: !0
    }), u(fe, k, {
      value: null,
      writable: !0
    }), u(fe, O, {
      value: he._readableState.endEmitted,
      writable: !0
    }), u(fe, F, {
      value: function(Te, q) {
        var z = be[H].read();
        z ? (be[D] = null, be[p] = null, be[_] = null, Te(Z(z, !1))) : (be[p] = Te, be[_] = q);
      },
      writable: !0
    }), fe));
    return be[D] = null, v(he, function(ke) {
      if (ke && ke.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var Te = be[_];
        Te !== null && (be[D] = null, be[p] = null, be[_] = null, Te(ke)), be[k] = ke;
        return;
      }
      var q = be[p];
      q !== null && (be[D] = null, be[p] = null, be[_] = null, q(Z(void 0, !0))), be[O] = !0;
    }), he.on("readable", X.bind(null, be)), be;
  };
  return async_iterator = j, async_iterator;
}
var fromBrowser, hasRequiredFromBrowser;
function requireFromBrowser() {
  return hasRequiredFromBrowser || (hasRequiredFromBrowser = 1, fromBrowser = function() {
    throw new Error("Readable.from is not available in the browser");
  }), fromBrowser;
}
var _stream_readable, hasRequired_stream_readable;
function require_stream_readable() {
  if (hasRequired_stream_readable)
    return _stream_readable;
  hasRequired_stream_readable = 1, _stream_readable = q;
  var a;
  q.ReadableState = Te, eventsExports.EventEmitter;
  var u = function(A, re) {
    return A.listeners(re).length;
  }, c = streamBrowser, l = require$$0$2.Buffer, v = (typeof commonjsGlobal$1 < "u" ? commonjsGlobal$1 : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function p(oe) {
    return l.from(oe);
  }
  function _(oe) {
    return l.isBuffer(oe) || oe instanceof v;
  }
  var k = util$4, O;
  k && k.debuglog ? O = k.debuglog("stream") : O = function() {
  };
  var D = requireBuffer_list(), F = destroy_1, H = state$3, Z = H.getHighWaterMark, ee = errorsBrowser.codes, X = ee.ERR_INVALID_ARG_TYPE, ne = ee.ERR_STREAM_PUSH_AFTER_EOF, Q = ee.ERR_METHOD_NOT_IMPLEMENTED, ae = ee.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, j, ue, he;
  inherits_browserExports(q, c);
  var fe = F.errorOrDestroy, be = ["error", "close", "destroy", "pause", "resume"];
  function ke(oe, A, re) {
    if (typeof oe.prependListener == "function")
      return oe.prependListener(A, re);
    !oe._events || !oe._events[A] ? oe.on(A, re) : Array.isArray(oe._events[A]) ? oe._events[A].unshift(re) : oe._events[A] = [re, oe._events[A]];
  }
  function Te(oe, A, re) {
    a = a || require_stream_duplex(), oe = oe || {}, typeof re != "boolean" && (re = A instanceof a), this.objectMode = !!oe.objectMode, re && (this.objectMode = this.objectMode || !!oe.readableObjectMode), this.highWaterMark = Z(this, oe, "readableHighWaterMark", re), this.buffer = new D(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = oe.emitClose !== !1, this.autoDestroy = !!oe.autoDestroy, this.destroyed = !1, this.defaultEncoding = oe.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, oe.encoding && (j || (j = string_decoder.StringDecoder), this.decoder = new j(oe.encoding), this.encoding = oe.encoding);
  }
  function q(oe) {
    if (a = a || require_stream_duplex(), !(this instanceof q))
      return new q(oe);
    var A = this instanceof a;
    this._readableState = new Te(oe, this, A), this.readable = !0, oe && (typeof oe.read == "function" && (this._read = oe.read), typeof oe.destroy == "function" && (this._destroy = oe.destroy)), c.call(this);
  }
  Object.defineProperty(q.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(A) {
      this._readableState && (this._readableState.destroyed = A);
    }
  }), q.prototype.destroy = F.destroy, q.prototype._undestroy = F.undestroy, q.prototype._destroy = function(oe, A) {
    A(oe);
  }, q.prototype.push = function(oe, A) {
    var re = this._readableState, le;
    return re.objectMode ? le = !0 : typeof oe == "string" && (A = A || re.defaultEncoding, A !== re.encoding && (oe = l.from(oe, A), A = ""), le = !0), z(this, oe, A, !1, le);
  }, q.prototype.unshift = function(oe) {
    return z(this, oe, null, !0, !1);
  };
  function z(oe, A, re, le, $e) {
    O("readableAddChunk", A);
    var Oe = oe._readableState;
    if (A === null)
      Oe.reading = !1, $(oe, Oe);
    else {
      var Fe;
      if ($e || (Fe = S(Oe, A)), Fe)
        fe(oe, Fe);
      else if (Oe.objectMode || A && A.length > 0)
        if (typeof A != "string" && !Oe.objectMode && Object.getPrototypeOf(A) !== l.prototype && (A = p(A)), le)
          Oe.endEmitted ? fe(oe, new ae()) : P(oe, Oe, A, !0);
        else if (Oe.ended)
          fe(oe, new ne());
        else {
          if (Oe.destroyed)
            return !1;
          Oe.reading = !1, Oe.decoder && !re ? (A = Oe.decoder.write(A), Oe.objectMode || A.length !== 0 ? P(oe, Oe, A, !1) : B(oe, Oe)) : P(oe, Oe, A, !1);
        }
      else
        le || (Oe.reading = !1, B(oe, Oe));
    }
    return !Oe.ended && (Oe.length < Oe.highWaterMark || Oe.length === 0);
  }
  function P(oe, A, re, le) {
    A.flowing && A.length === 0 && !A.sync ? (A.awaitDrain = 0, oe.emit("data", re)) : (A.length += A.objectMode ? 1 : re.length, le ? A.buffer.unshift(re) : A.buffer.push(re), A.needReadable && U(oe)), B(oe, A);
  }
  function S(oe, A) {
    var re;
    return !_(A) && typeof A != "string" && A !== void 0 && !oe.objectMode && (re = new X("chunk", ["string", "Buffer", "Uint8Array"], A)), re;
  }
  q.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, q.prototype.setEncoding = function(oe) {
    j || (j = string_decoder.StringDecoder);
    var A = new j(oe);
    this._readableState.decoder = A, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var re = this._readableState.buffer.head, le = ""; re !== null; )
      le += A.write(re.data), re = re.next;
    return this._readableState.buffer.clear(), le !== "" && this._readableState.buffer.push(le), this._readableState.length = le.length, this;
  };
  var E = 1073741824;
  function I(oe) {
    return oe >= E ? oe = E : (oe--, oe |= oe >>> 1, oe |= oe >>> 2, oe |= oe >>> 4, oe |= oe >>> 8, oe |= oe >>> 16, oe++), oe;
  }
  function M(oe, A) {
    return oe <= 0 || A.length === 0 && A.ended ? 0 : A.objectMode ? 1 : oe !== oe ? A.flowing && A.length ? A.buffer.head.data.length : A.length : (oe > A.highWaterMark && (A.highWaterMark = I(oe)), oe <= A.length ? oe : A.ended ? A.length : (A.needReadable = !0, 0));
  }
  q.prototype.read = function(oe) {
    O("read", oe), oe = parseInt(oe, 10);
    var A = this._readableState, re = oe;
    if (oe !== 0 && (A.emittedReadable = !1), oe === 0 && A.needReadable && ((A.highWaterMark !== 0 ? A.length >= A.highWaterMark : A.length > 0) || A.ended))
      return O("read: emitReadable", A.length, A.ended), A.length === 0 && A.ended ? Me(this) : U(this), null;
    if (oe = M(oe, A), oe === 0 && A.ended)
      return A.length === 0 && Me(this), null;
    var le = A.needReadable;
    O("need readable", le), (A.length === 0 || A.length - oe < A.highWaterMark) && (le = !0, O("length less than watermark", le)), A.ended || A.reading ? (le = !1, O("reading or ended", le)) : le && (O("do read"), A.reading = !0, A.sync = !0, A.length === 0 && (A.needReadable = !0), this._read(A.highWaterMark), A.sync = !1, A.reading || (oe = M(re, A)));
    var $e;
    return oe > 0 ? $e = pe(oe, A) : $e = null, $e === null ? (A.needReadable = A.length <= A.highWaterMark, oe = 0) : (A.length -= oe, A.awaitDrain = 0), A.length === 0 && (A.ended || (A.needReadable = !0), re !== oe && A.ended && Me(this)), $e !== null && this.emit("data", $e), $e;
  };
  function $(oe, A) {
    if (O("onEofChunk"), !A.ended) {
      if (A.decoder) {
        var re = A.decoder.end();
        re && re.length && (A.buffer.push(re), A.length += A.objectMode ? 1 : re.length);
      }
      A.ended = !0, A.sync ? U(oe) : (A.needReadable = !1, A.emittedReadable || (A.emittedReadable = !0, Y(oe)));
    }
  }
  function U(oe) {
    var A = oe._readableState;
    O("emitReadable", A.needReadable, A.emittedReadable), A.needReadable = !1, A.emittedReadable || (O("emitReadable", A.flowing), A.emittedReadable = !0, process$1.nextTick(Y, oe));
  }
  function Y(oe) {
    var A = oe._readableState;
    O("emitReadable_", A.destroyed, A.length, A.ended), !A.destroyed && (A.length || A.ended) && (oe.emit("readable"), A.emittedReadable = !1), A.needReadable = !A.flowing && !A.ended && A.length <= A.highWaterMark, ye(oe);
  }
  function B(oe, A) {
    A.readingMore || (A.readingMore = !0, process$1.nextTick(T, oe, A));
  }
  function T(oe, A) {
    for (; !A.reading && !A.ended && (A.length < A.highWaterMark || A.flowing && A.length === 0); ) {
      var re = A.length;
      if (O("maybeReadMore read 0"), oe.read(0), re === A.length)
        break;
    }
    A.readingMore = !1;
  }
  q.prototype._read = function(oe) {
    fe(this, new Q("_read()"));
  }, q.prototype.pipe = function(oe, A) {
    var re = this, le = this._readableState;
    switch (le.pipesCount) {
      case 0:
        le.pipes = oe;
        break;
      case 1:
        le.pipes = [le.pipes, oe];
        break;
      default:
        le.pipes.push(oe);
        break;
    }
    le.pipesCount += 1, O("pipe count=%d opts=%j", le.pipesCount, A);
    var $e = (!A || A.end !== !1) && oe !== process$1.stdout && oe !== process$1.stderr, Oe = $e ? Ze : We;
    le.endEmitted ? process$1.nextTick(Oe) : re.once("end", Oe), oe.on("unpipe", Fe);
    function Fe(Ie, V) {
      O("onunpipe"), Ie === re && V && V.hasUnpiped === !1 && (V.hasUnpiped = !0, Xe());
    }
    function Ze() {
      O("onend"), oe.end();
    }
    var qe = L(re);
    oe.on("drain", qe);
    var yt = !1;
    function Xe() {
      O("cleanup"), oe.removeListener("close", ge), oe.removeListener("finish", we), oe.removeListener("drain", qe), oe.removeListener("error", J), oe.removeListener("unpipe", Fe), re.removeListener("end", Ze), re.removeListener("end", We), re.removeListener("data", Ge), yt = !0, le.awaitDrain && (!oe._writableState || oe._writableState.needDrain) && qe();
    }
    re.on("data", Ge);
    function Ge(Ie) {
      O("ondata");
      var V = oe.write(Ie);
      O("dest.write", V), V === !1 && ((le.pipesCount === 1 && le.pipes === oe || le.pipesCount > 1 && Ue(le.pipes, oe) !== -1) && !yt && (O("false write response, pause", le.awaitDrain), le.awaitDrain++), re.pause());
    }
    function J(Ie) {
      O("onerror", Ie), We(), oe.removeListener("error", J), u(oe, "error") === 0 && fe(oe, Ie);
    }
    ke(oe, "error", J);
    function ge() {
      oe.removeListener("finish", we), We();
    }
    oe.once("close", ge);
    function we() {
      O("onfinish"), oe.removeListener("close", ge), We();
    }
    oe.once("finish", we);
    function We() {
      O("unpipe"), re.unpipe(oe);
    }
    return oe.emit("pipe", re), le.flowing || (O("pipe resume"), re.resume()), oe;
  };
  function L(oe) {
    return function() {
      var re = oe._readableState;
      O("pipeOnDrain", re.awaitDrain), re.awaitDrain && re.awaitDrain--, re.awaitDrain === 0 && u(oe, "data") && (re.flowing = !0, ye(oe));
    };
  }
  q.prototype.unpipe = function(oe) {
    var A = this._readableState, re = {
      hasUnpiped: !1
    };
    if (A.pipesCount === 0)
      return this;
    if (A.pipesCount === 1)
      return oe && oe !== A.pipes ? this : (oe || (oe = A.pipes), A.pipes = null, A.pipesCount = 0, A.flowing = !1, oe && oe.emit("unpipe", this, re), this);
    if (!oe) {
      var le = A.pipes, $e = A.pipesCount;
      A.pipes = null, A.pipesCount = 0, A.flowing = !1;
      for (var Oe = 0; Oe < $e; Oe++)
        le[Oe].emit("unpipe", this, {
          hasUnpiped: !1
        });
      return this;
    }
    var Fe = Ue(A.pipes, oe);
    return Fe === -1 ? this : (A.pipes.splice(Fe, 1), A.pipesCount -= 1, A.pipesCount === 1 && (A.pipes = A.pipes[0]), oe.emit("unpipe", this, re), this);
  }, q.prototype.on = function(oe, A) {
    var re = c.prototype.on.call(this, oe, A), le = this._readableState;
    return oe === "data" ? (le.readableListening = this.listenerCount("readable") > 0, le.flowing !== !1 && this.resume()) : oe === "readable" && !le.endEmitted && !le.readableListening && (le.readableListening = le.needReadable = !0, le.flowing = !1, le.emittedReadable = !1, O("on readable", le.length, le.reading), le.length ? U(this) : le.reading || process$1.nextTick(me, this)), re;
  }, q.prototype.addListener = q.prototype.on, q.prototype.removeListener = function(oe, A) {
    var re = c.prototype.removeListener.call(this, oe, A);
    return oe === "readable" && process$1.nextTick(te, this), re;
  }, q.prototype.removeAllListeners = function(oe) {
    var A = c.prototype.removeAllListeners.apply(this, arguments);
    return (oe === "readable" || oe === void 0) && process$1.nextTick(te, this), A;
  };
  function te(oe) {
    var A = oe._readableState;
    A.readableListening = oe.listenerCount("readable") > 0, A.resumeScheduled && !A.paused ? A.flowing = !0 : oe.listenerCount("data") > 0 && oe.resume();
  }
  function me(oe) {
    O("readable nexttick read 0"), oe.read(0);
  }
  q.prototype.resume = function() {
    var oe = this._readableState;
    return oe.flowing || (O("resume"), oe.flowing = !oe.readableListening, Ce(this, oe)), oe.paused = !1, this;
  };
  function Ce(oe, A) {
    A.resumeScheduled || (A.resumeScheduled = !0, process$1.nextTick(De, oe, A));
  }
  function De(oe, A) {
    O("resume", A.reading), A.reading || oe.read(0), A.resumeScheduled = !1, oe.emit("resume"), ye(oe), A.flowing && !A.reading && oe.read(0);
  }
  q.prototype.pause = function() {
    return O("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (O("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function ye(oe) {
    var A = oe._readableState;
    for (O("flow", A.flowing); A.flowing && oe.read() !== null; )
      ;
  }
  q.prototype.wrap = function(oe) {
    var A = this, re = this._readableState, le = !1;
    oe.on("end", function() {
      if (O("wrapped end"), re.decoder && !re.ended) {
        var Fe = re.decoder.end();
        Fe && Fe.length && A.push(Fe);
      }
      A.push(null);
    }), oe.on("data", function(Fe) {
      if (O("wrapped data"), re.decoder && (Fe = re.decoder.write(Fe)), !(re.objectMode && Fe == null) && !(!re.objectMode && (!Fe || !Fe.length))) {
        var Ze = A.push(Fe);
        Ze || (le = !0, oe.pause());
      }
    });
    for (var $e in oe)
      this[$e] === void 0 && typeof oe[$e] == "function" && (this[$e] = /* @__PURE__ */ function(Ze) {
        return function() {
          return oe[Ze].apply(oe, arguments);
        };
      }($e));
    for (var Oe = 0; Oe < be.length; Oe++)
      oe.on(be[Oe], this.emit.bind(this, be[Oe]));
    return this._read = function(Fe) {
      O("wrapped _read", Fe), le && (le = !1, oe.resume());
    }, this;
  }, typeof Symbol == "function" && (q.prototype[Symbol.asyncIterator] = function() {
    return ue === void 0 && (ue = requireAsync_iterator()), ue(this);
  }), Object.defineProperty(q.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(q.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(q.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(A) {
      this._readableState && (this._readableState.flowing = A);
    }
  }), q._fromList = pe, Object.defineProperty(q.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function pe(oe, A) {
    if (A.length === 0)
      return null;
    var re;
    return A.objectMode ? re = A.buffer.shift() : !oe || oe >= A.length ? (A.decoder ? re = A.buffer.join("") : A.buffer.length === 1 ? re = A.buffer.first() : re = A.buffer.concat(A.length), A.buffer.clear()) : re = A.buffer.consume(oe, A.decoder), re;
  }
  function Me(oe) {
    var A = oe._readableState;
    O("endReadable", A.endEmitted), A.endEmitted || (A.ended = !0, process$1.nextTick(Ne, A, oe));
  }
  function Ne(oe, A) {
    if (O("endReadableNT", oe.endEmitted, oe.length), !oe.endEmitted && oe.length === 0 && (oe.endEmitted = !0, A.readable = !1, A.emit("end"), oe.autoDestroy)) {
      var re = A._writableState;
      (!re || re.autoDestroy && re.finished) && A.destroy();
    }
  }
  typeof Symbol == "function" && (q.from = function(oe, A) {
    return he === void 0 && (he = requireFromBrowser()), he(q, oe, A);
  });
  function Ue(oe, A) {
    for (var re = 0, le = oe.length; re < le; re++)
      if (oe[re] === A)
        return re;
    return -1;
  }
  return _stream_readable;
}
var _stream_transform = Transform$1, _require$codes$1 = errorsBrowser.codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes$1.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes$1.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes$1.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes$1.ERR_TRANSFORM_WITH_LENGTH_0, Duplex = require_stream_duplex();
inherits_browserExports(Transform$1, Duplex);
function afterTransform(a, u) {
  var c = this._transformState;
  c.transforming = !1;
  var l = c.writecb;
  if (l === null)
    return this.emit("error", new ERR_MULTIPLE_CALLBACK());
  c.writechunk = null, c.writecb = null, u != null && this.push(u), l(a);
  var v = this._readableState;
  v.reading = !1, (v.needReadable || v.length < v.highWaterMark) && this._read(v.highWaterMark);
}
function Transform$1(a) {
  if (!(this instanceof Transform$1))
    return new Transform$1(a);
  Duplex.call(this, a), this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: !1,
    transforming: !1,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }, this._readableState.needReadable = !0, this._readableState.sync = !1, a && (typeof a.transform == "function" && (this._transform = a.transform), typeof a.flush == "function" && (this._flush = a.flush)), this.on("prefinish", prefinish);
}
function prefinish() {
  var a = this;
  typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(u, c) {
    done(a, u, c);
  }) : done(this, null, null);
}
Transform$1.prototype.push = function(a, u) {
  return this._transformState.needTransform = !1, Duplex.prototype.push.call(this, a, u);
};
Transform$1.prototype._transform = function(a, u, c) {
  c(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
};
Transform$1.prototype._write = function(a, u, c) {
  var l = this._transformState;
  if (l.writecb = c, l.writechunk = a, l.writeencoding = u, !l.transforming) {
    var v = this._readableState;
    (l.needTransform || v.needReadable || v.length < v.highWaterMark) && this._read(v.highWaterMark);
  }
};
Transform$1.prototype._read = function(a) {
  var u = this._transformState;
  u.writechunk !== null && !u.transforming ? (u.transforming = !0, this._transform(u.writechunk, u.writeencoding, u.afterTransform)) : u.needTransform = !0;
};
Transform$1.prototype._destroy = function(a, u) {
  Duplex.prototype._destroy.call(this, a, function(c) {
    u(c);
  });
};
function done(a, u, c) {
  if (u)
    return a.emit("error", u);
  if (c != null && a.push(c), a._writableState.length)
    throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (a._transformState.transforming)
    throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return a.push(null);
}
var _stream_passthrough = PassThrough, Transform = _stream_transform;
inherits_browserExports(PassThrough, Transform);
function PassThrough(a) {
  if (!(this instanceof PassThrough))
    return new PassThrough(a);
  Transform.call(this, a);
}
PassThrough.prototype._transform = function(a, u, c) {
  c(null, a);
};
var eos;
function once$2(a) {
  var u = !1;
  return function() {
    u || (u = !0, a.apply(void 0, arguments));
  };
}
var _require$codes = errorsBrowser.codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
function noop$1(a) {
  if (a)
    throw a;
}
function isRequest(a) {
  return a.setHeader && typeof a.abort == "function";
}
function destroyer(a, u, c, l) {
  l = once$2(l);
  var v = !1;
  a.on("close", function() {
    v = !0;
  }), eos === void 0 && (eos = endOfStream), eos(a, {
    readable: u,
    writable: c
  }, function(_) {
    if (_)
      return l(_);
    v = !0, l();
  });
  var p = !1;
  return function(_) {
    if (!v && !p) {
      if (p = !0, isRequest(a))
        return a.abort();
      if (typeof a.destroy == "function")
        return a.destroy();
      l(_ || new ERR_STREAM_DESTROYED("pipe"));
    }
  };
}
function call(a) {
  a();
}
function pipe(a, u) {
  return a.pipe(u);
}
function popCallback(a) {
  return !a.length || typeof a[a.length - 1] != "function" ? noop$1 : a.pop();
}
function pipeline() {
  for (var a = arguments.length, u = new Array(a), c = 0; c < a; c++)
    u[c] = arguments[c];
  var l = popCallback(u);
  if (Array.isArray(u[0]) && (u = u[0]), u.length < 2)
    throw new ERR_MISSING_ARGS("streams");
  var v, p = u.map(function(_, k) {
    var O = k < u.length - 1, D = k > 0;
    return destroyer(_, O, D, function(F) {
      v || (v = F), F && p.forEach(call), !O && (p.forEach(call), l(v));
    });
  });
  return u.reduce(pipe);
}
var pipeline_1 = pipeline;
(function(a, u) {
  u = a.exports = require_stream_readable(), u.Stream = u, u.Readable = u, u.Writable = require_stream_writable(), u.Duplex = require_stream_duplex(), u.Transform = _stream_transform, u.PassThrough = _stream_passthrough, u.finished = endOfStream, u.pipeline = pipeline_1;
})(readableBrowser, readableBrowser.exports);
var readableBrowserExports = readableBrowser.exports, sign$1 = { exports: {} }, bn$4 = { exports: {} };
bn$4.exports;
(function(a) {
  (function(u, c) {
    function l(E, I) {
      if (!E)
        throw new Error(I || "Assertion failed");
    }
    function v(E, I) {
      E.super_ = I;
      var M = function() {
      };
      M.prototype = I.prototype, E.prototype = new M(), E.prototype.constructor = E;
    }
    function p(E, I, M) {
      if (p.isBN(E))
        return E;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, E !== null && ((I === "le" || I === "be") && (M = I, I = 10), this._init(E || 0, I || 10, M || "be"));
    }
    typeof u == "object" ? u.exports = p : c.BN = p, p.BN = p, p.wordSize = 26;
    var _;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? _ = window.Buffer : _ = require$$0$2.Buffer;
    } catch {
    }
    p.isBN = function(I) {
      return I instanceof p ? !0 : I !== null && typeof I == "object" && I.constructor.wordSize === p.wordSize && Array.isArray(I.words);
    }, p.max = function(I, M) {
      return I.cmp(M) > 0 ? I : M;
    }, p.min = function(I, M) {
      return I.cmp(M) < 0 ? I : M;
    }, p.prototype._init = function(I, M, $) {
      if (typeof I == "number")
        return this._initNumber(I, M, $);
      if (typeof I == "object")
        return this._initArray(I, M, $);
      M === "hex" && (M = 16), l(M === (M | 0) && M >= 2 && M <= 36), I = I.toString().replace(/\s+/g, "");
      var U = 0;
      I[0] === "-" && (U++, this.negative = 1), U < I.length && (M === 16 ? this._parseHex(I, U, $) : (this._parseBase(I, M, U), $ === "le" && this._initArray(this.toArray(), M, $)));
    }, p.prototype._initNumber = function(I, M, $) {
      I < 0 && (this.negative = 1, I = -I), I < 67108864 ? (this.words = [I & 67108863], this.length = 1) : I < 4503599627370496 ? (this.words = [
        I & 67108863,
        I / 67108864 & 67108863
      ], this.length = 2) : (l(I < 9007199254740992), this.words = [
        I & 67108863,
        I / 67108864 & 67108863,
        1
      ], this.length = 3), $ === "le" && this._initArray(this.toArray(), M, $);
    }, p.prototype._initArray = function(I, M, $) {
      if (l(typeof I.length == "number"), I.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(I.length / 3), this.words = new Array(this.length);
      for (var U = 0; U < this.length; U++)
        this.words[U] = 0;
      var Y, B, T = 0;
      if ($ === "be")
        for (U = I.length - 1, Y = 0; U >= 0; U -= 3)
          B = I[U] | I[U - 1] << 8 | I[U - 2] << 16, this.words[Y] |= B << T & 67108863, this.words[Y + 1] = B >>> 26 - T & 67108863, T += 24, T >= 26 && (T -= 26, Y++);
      else if ($ === "le")
        for (U = 0, Y = 0; U < I.length; U += 3)
          B = I[U] | I[U + 1] << 8 | I[U + 2] << 16, this.words[Y] |= B << T & 67108863, this.words[Y + 1] = B >>> 26 - T & 67108863, T += 24, T >= 26 && (T -= 26, Y++);
      return this._strip();
    };
    function k(E, I) {
      var M = E.charCodeAt(I);
      if (M >= 48 && M <= 57)
        return M - 48;
      if (M >= 65 && M <= 70)
        return M - 55;
      if (M >= 97 && M <= 102)
        return M - 87;
      l(!1, "Invalid character in " + E);
    }
    function O(E, I, M) {
      var $ = k(E, M);
      return M - 1 >= I && ($ |= k(E, M - 1) << 4), $;
    }
    p.prototype._parseHex = function(I, M, $) {
      this.length = Math.ceil((I.length - M) / 6), this.words = new Array(this.length);
      for (var U = 0; U < this.length; U++)
        this.words[U] = 0;
      var Y = 0, B = 0, T;
      if ($ === "be")
        for (U = I.length - 1; U >= M; U -= 2)
          T = O(I, M, U) << Y, this.words[B] |= T & 67108863, Y >= 18 ? (Y -= 18, B += 1, this.words[B] |= T >>> 26) : Y += 8;
      else {
        var L = I.length - M;
        for (U = L % 2 === 0 ? M + 1 : M; U < I.length; U += 2)
          T = O(I, M, U) << Y, this.words[B] |= T & 67108863, Y >= 18 ? (Y -= 18, B += 1, this.words[B] |= T >>> 26) : Y += 8;
      }
      this._strip();
    };
    function D(E, I, M, $) {
      for (var U = 0, Y = 0, B = Math.min(E.length, M), T = I; T < B; T++) {
        var L = E.charCodeAt(T) - 48;
        U *= $, L >= 49 ? Y = L - 49 + 10 : L >= 17 ? Y = L - 17 + 10 : Y = L, l(L >= 0 && Y < $, "Invalid character"), U += Y;
      }
      return U;
    }
    p.prototype._parseBase = function(I, M, $) {
      this.words = [0], this.length = 1;
      for (var U = 0, Y = 1; Y <= 67108863; Y *= M)
        U++;
      U--, Y = Y / M | 0;
      for (var B = I.length - $, T = B % U, L = Math.min(B, B - T) + $, te = 0, me = $; me < L; me += U)
        te = D(I, me, me + U, M), this.imuln(Y), this.words[0] + te < 67108864 ? this.words[0] += te : this._iaddn(te);
      if (T !== 0) {
        var Ce = 1;
        for (te = D(I, me, I.length, M), me = 0; me < T; me++)
          Ce *= M;
        this.imuln(Ce), this.words[0] + te < 67108864 ? this.words[0] += te : this._iaddn(te);
      }
      this._strip();
    }, p.prototype.copy = function(I) {
      I.words = new Array(this.length);
      for (var M = 0; M < this.length; M++)
        I.words[M] = this.words[M];
      I.length = this.length, I.negative = this.negative, I.red = this.red;
    };
    function F(E, I) {
      E.words = I.words, E.length = I.length, E.negative = I.negative, E.red = I.red;
    }
    if (p.prototype._move = function(I) {
      F(I, this);
    }, p.prototype.clone = function() {
      var I = new p(null);
      return this.copy(I), I;
    }, p.prototype._expand = function(I) {
      for (; this.length < I; )
        this.words[this.length++] = 0;
      return this;
    }, p.prototype._strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, p.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol < "u" && typeof Symbol.for == "function")
      try {
        p.prototype[Symbol.for("nodejs.util.inspect.custom")] = H;
      } catch {
        p.prototype.inspect = H;
      }
    else
      p.prototype.inspect = H;
    function H() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var Z = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], ee = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], X = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    p.prototype.toString = function(I, M) {
      I = I || 10, M = M | 0 || 1;
      var $;
      if (I === 16 || I === "hex") {
        $ = "";
        for (var U = 0, Y = 0, B = 0; B < this.length; B++) {
          var T = this.words[B], L = ((T << U | Y) & 16777215).toString(16);
          Y = T >>> 24 - U & 16777215, U += 2, U >= 26 && (U -= 26, B--), Y !== 0 || B !== this.length - 1 ? $ = Z[6 - L.length] + L + $ : $ = L + $;
        }
        for (Y !== 0 && ($ = Y.toString(16) + $); $.length % M !== 0; )
          $ = "0" + $;
        return this.negative !== 0 && ($ = "-" + $), $;
      }
      if (I === (I | 0) && I >= 2 && I <= 36) {
        var te = ee[I], me = X[I];
        $ = "";
        var Ce = this.clone();
        for (Ce.negative = 0; !Ce.isZero(); ) {
          var De = Ce.modrn(me).toString(I);
          Ce = Ce.idivn(me), Ce.isZero() ? $ = De + $ : $ = Z[te - De.length] + De + $;
        }
        for (this.isZero() && ($ = "0" + $); $.length % M !== 0; )
          $ = "0" + $;
        return this.negative !== 0 && ($ = "-" + $), $;
      }
      l(!1, "Base should be between 2 and 36");
    }, p.prototype.toNumber = function() {
      var I = this.words[0];
      return this.length === 2 ? I += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? I += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && l(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -I : I;
    }, p.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, _ && (p.prototype.toBuffer = function(I, M) {
      return this.toArrayLike(_, I, M);
    }), p.prototype.toArray = function(I, M) {
      return this.toArrayLike(Array, I, M);
    };
    var ne = function(I, M) {
      return I.allocUnsafe ? I.allocUnsafe(M) : new I(M);
    };
    p.prototype.toArrayLike = function(I, M, $) {
      this._strip();
      var U = this.byteLength(), Y = $ || Math.max(1, U);
      l(U <= Y, "byte array longer than desired length"), l(Y > 0, "Requested array length <= 0");
      var B = ne(I, Y), T = M === "le" ? "LE" : "BE";
      return this["_toArrayLike" + T](B, U), B;
    }, p.prototype._toArrayLikeLE = function(I, M) {
      for (var $ = 0, U = 0, Y = 0, B = 0; Y < this.length; Y++) {
        var T = this.words[Y] << B | U;
        I[$++] = T & 255, $ < I.length && (I[$++] = T >> 8 & 255), $ < I.length && (I[$++] = T >> 16 & 255), B === 6 ? ($ < I.length && (I[$++] = T >> 24 & 255), U = 0, B = 0) : (U = T >>> 24, B += 2);
      }
      if ($ < I.length)
        for (I[$++] = U; $ < I.length; )
          I[$++] = 0;
    }, p.prototype._toArrayLikeBE = function(I, M) {
      for (var $ = I.length - 1, U = 0, Y = 0, B = 0; Y < this.length; Y++) {
        var T = this.words[Y] << B | U;
        I[$--] = T & 255, $ >= 0 && (I[$--] = T >> 8 & 255), $ >= 0 && (I[$--] = T >> 16 & 255), B === 6 ? ($ >= 0 && (I[$--] = T >> 24 & 255), U = 0, B = 0) : (U = T >>> 24, B += 2);
      }
      if ($ >= 0)
        for (I[$--] = U; $ >= 0; )
          I[$--] = 0;
    }, Math.clz32 ? p.prototype._countBits = function(I) {
      return 32 - Math.clz32(I);
    } : p.prototype._countBits = function(I) {
      var M = I, $ = 0;
      return M >= 4096 && ($ += 13, M >>>= 13), M >= 64 && ($ += 7, M >>>= 7), M >= 8 && ($ += 4, M >>>= 4), M >= 2 && ($ += 2, M >>>= 2), $ + M;
    }, p.prototype._zeroBits = function(I) {
      if (I === 0)
        return 26;
      var M = I, $ = 0;
      return M & 8191 || ($ += 13, M >>>= 13), M & 127 || ($ += 7, M >>>= 7), M & 15 || ($ += 4, M >>>= 4), M & 3 || ($ += 2, M >>>= 2), M & 1 || $++, $;
    }, p.prototype.bitLength = function() {
      var I = this.words[this.length - 1], M = this._countBits(I);
      return (this.length - 1) * 26 + M;
    };
    function Q(E) {
      for (var I = new Array(E.bitLength()), M = 0; M < I.length; M++) {
        var $ = M / 26 | 0, U = M % 26;
        I[M] = E.words[$] >>> U & 1;
      }
      return I;
    }
    p.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var I = 0, M = 0; M < this.length; M++) {
        var $ = this._zeroBits(this.words[M]);
        if (I += $, $ !== 26)
          break;
      }
      return I;
    }, p.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, p.prototype.toTwos = function(I) {
      return this.negative !== 0 ? this.abs().inotn(I).iaddn(1) : this.clone();
    }, p.prototype.fromTwos = function(I) {
      return this.testn(I - 1) ? this.notn(I).iaddn(1).ineg() : this.clone();
    }, p.prototype.isNeg = function() {
      return this.negative !== 0;
    }, p.prototype.neg = function() {
      return this.clone().ineg();
    }, p.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, p.prototype.iuor = function(I) {
      for (; this.length < I.length; )
        this.words[this.length++] = 0;
      for (var M = 0; M < I.length; M++)
        this.words[M] = this.words[M] | I.words[M];
      return this._strip();
    }, p.prototype.ior = function(I) {
      return l((this.negative | I.negative) === 0), this.iuor(I);
    }, p.prototype.or = function(I) {
      return this.length > I.length ? this.clone().ior(I) : I.clone().ior(this);
    }, p.prototype.uor = function(I) {
      return this.length > I.length ? this.clone().iuor(I) : I.clone().iuor(this);
    }, p.prototype.iuand = function(I) {
      var M;
      this.length > I.length ? M = I : M = this;
      for (var $ = 0; $ < M.length; $++)
        this.words[$] = this.words[$] & I.words[$];
      return this.length = M.length, this._strip();
    }, p.prototype.iand = function(I) {
      return l((this.negative | I.negative) === 0), this.iuand(I);
    }, p.prototype.and = function(I) {
      return this.length > I.length ? this.clone().iand(I) : I.clone().iand(this);
    }, p.prototype.uand = function(I) {
      return this.length > I.length ? this.clone().iuand(I) : I.clone().iuand(this);
    }, p.prototype.iuxor = function(I) {
      var M, $;
      this.length > I.length ? (M = this, $ = I) : (M = I, $ = this);
      for (var U = 0; U < $.length; U++)
        this.words[U] = M.words[U] ^ $.words[U];
      if (this !== M)
        for (; U < M.length; U++)
          this.words[U] = M.words[U];
      return this.length = M.length, this._strip();
    }, p.prototype.ixor = function(I) {
      return l((this.negative | I.negative) === 0), this.iuxor(I);
    }, p.prototype.xor = function(I) {
      return this.length > I.length ? this.clone().ixor(I) : I.clone().ixor(this);
    }, p.prototype.uxor = function(I) {
      return this.length > I.length ? this.clone().iuxor(I) : I.clone().iuxor(this);
    }, p.prototype.inotn = function(I) {
      l(typeof I == "number" && I >= 0);
      var M = Math.ceil(I / 26) | 0, $ = I % 26;
      this._expand(M), $ > 0 && M--;
      for (var U = 0; U < M; U++)
        this.words[U] = ~this.words[U] & 67108863;
      return $ > 0 && (this.words[U] = ~this.words[U] & 67108863 >> 26 - $), this._strip();
    }, p.prototype.notn = function(I) {
      return this.clone().inotn(I);
    }, p.prototype.setn = function(I, M) {
      l(typeof I == "number" && I >= 0);
      var $ = I / 26 | 0, U = I % 26;
      return this._expand($ + 1), M ? this.words[$] = this.words[$] | 1 << U : this.words[$] = this.words[$] & ~(1 << U), this._strip();
    }, p.prototype.iadd = function(I) {
      var M;
      if (this.negative !== 0 && I.negative === 0)
        return this.negative = 0, M = this.isub(I), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && I.negative !== 0)
        return I.negative = 0, M = this.isub(I), I.negative = 1, M._normSign();
      var $, U;
      this.length > I.length ? ($ = this, U = I) : ($ = I, U = this);
      for (var Y = 0, B = 0; B < U.length; B++)
        M = ($.words[B] | 0) + (U.words[B] | 0) + Y, this.words[B] = M & 67108863, Y = M >>> 26;
      for (; Y !== 0 && B < $.length; B++)
        M = ($.words[B] | 0) + Y, this.words[B] = M & 67108863, Y = M >>> 26;
      if (this.length = $.length, Y !== 0)
        this.words[this.length] = Y, this.length++;
      else if ($ !== this)
        for (; B < $.length; B++)
          this.words[B] = $.words[B];
      return this;
    }, p.prototype.add = function(I) {
      var M;
      return I.negative !== 0 && this.negative === 0 ? (I.negative = 0, M = this.sub(I), I.negative ^= 1, M) : I.negative === 0 && this.negative !== 0 ? (this.negative = 0, M = I.sub(this), this.negative = 1, M) : this.length > I.length ? this.clone().iadd(I) : I.clone().iadd(this);
    }, p.prototype.isub = function(I) {
      if (I.negative !== 0) {
        I.negative = 0;
        var M = this.iadd(I);
        return I.negative = 1, M._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(I), this.negative = 1, this._normSign();
      var $ = this.cmp(I);
      if ($ === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var U, Y;
      $ > 0 ? (U = this, Y = I) : (U = I, Y = this);
      for (var B = 0, T = 0; T < Y.length; T++)
        M = (U.words[T] | 0) - (Y.words[T] | 0) + B, B = M >> 26, this.words[T] = M & 67108863;
      for (; B !== 0 && T < U.length; T++)
        M = (U.words[T] | 0) + B, B = M >> 26, this.words[T] = M & 67108863;
      if (B === 0 && T < U.length && U !== this)
        for (; T < U.length; T++)
          this.words[T] = U.words[T];
      return this.length = Math.max(this.length, T), U !== this && (this.negative = 1), this._strip();
    }, p.prototype.sub = function(I) {
      return this.clone().isub(I);
    };
    function ae(E, I, M) {
      M.negative = I.negative ^ E.negative;
      var $ = E.length + I.length | 0;
      M.length = $, $ = $ - 1 | 0;
      var U = E.words[0] | 0, Y = I.words[0] | 0, B = U * Y, T = B & 67108863, L = B / 67108864 | 0;
      M.words[0] = T;
      for (var te = 1; te < $; te++) {
        for (var me = L >>> 26, Ce = L & 67108863, De = Math.min(te, I.length - 1), ye = Math.max(0, te - E.length + 1); ye <= De; ye++) {
          var pe = te - ye | 0;
          U = E.words[pe] | 0, Y = I.words[ye] | 0, B = U * Y + Ce, me += B / 67108864 | 0, Ce = B & 67108863;
        }
        M.words[te] = Ce | 0, L = me | 0;
      }
      return L !== 0 ? M.words[te] = L | 0 : M.length--, M._strip();
    }
    var j = function(I, M, $) {
      var U = I.words, Y = M.words, B = $.words, T = 0, L, te, me, Ce = U[0] | 0, De = Ce & 8191, ye = Ce >>> 13, pe = U[1] | 0, Me = pe & 8191, Ne = pe >>> 13, Ue = U[2] | 0, oe = Ue & 8191, A = Ue >>> 13, re = U[3] | 0, le = re & 8191, $e = re >>> 13, Oe = U[4] | 0, Fe = Oe & 8191, Ze = Oe >>> 13, qe = U[5] | 0, yt = qe & 8191, Xe = qe >>> 13, Ge = U[6] | 0, J = Ge & 8191, ge = Ge >>> 13, we = U[7] | 0, We = we & 8191, Ie = we >>> 13, V = U[8] | 0, Ee = V & 8191, de = V >>> 13, ce = U[9] | 0, ve = ce & 8191, Pe = ce >>> 13, Be = Y[0] | 0, ze = Be & 8191, Je = Be >>> 13, je = Y[1] | 0, Ke = je & 8191, x = je >>> 13, se = Y[2] | 0, Se = se & 8191, xe = se >>> 13, Ae = Y[3] | 0, Ye = Ae & 8191, et = Ae >>> 13, dt = Y[4] | 0, St = dt & 8191, tt = dt >>> 13, at = Y[5] | 0, kt = at & 8191, rt = at >>> 13, ut = Y[6] | 0, wt = ut & 8191, nt = ut >>> 13, it = Y[7] | 0, bt = it & 8191, ot = it >>> 13, ct = Y[8] | 0, Pt = ct & 8191, st = ct >>> 13, lt = Y[9] | 0, It = lt & 8191, Rt = lt >>> 13;
      $.negative = I.negative ^ M.negative, $.length = 19, L = Math.imul(De, ze), te = Math.imul(De, Je), te = te + Math.imul(ye, ze) | 0, me = Math.imul(ye, Je);
      var Ve = (T + L | 0) + ((te & 8191) << 13) | 0;
      T = (me + (te >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, L = Math.imul(Me, ze), te = Math.imul(Me, Je), te = te + Math.imul(Ne, ze) | 0, me = Math.imul(Ne, Je), L = L + Math.imul(De, Ke) | 0, te = te + Math.imul(De, x) | 0, te = te + Math.imul(ye, Ke) | 0, me = me + Math.imul(ye, x) | 0;
      var He = (T + L | 0) + ((te & 8191) << 13) | 0;
      T = (me + (te >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, L = Math.imul(oe, ze), te = Math.imul(oe, Je), te = te + Math.imul(A, ze) | 0, me = Math.imul(A, Je), L = L + Math.imul(Me, Ke) | 0, te = te + Math.imul(Me, x) | 0, te = te + Math.imul(Ne, Ke) | 0, me = me + Math.imul(Ne, x) | 0, L = L + Math.imul(De, Se) | 0, te = te + Math.imul(De, xe) | 0, te = te + Math.imul(ye, Se) | 0, me = me + Math.imul(ye, xe) | 0;
      var Qe = (T + L | 0) + ((te & 8191) << 13) | 0;
      T = (me + (te >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, L = Math.imul(le, ze), te = Math.imul(le, Je), te = te + Math.imul($e, ze) | 0, me = Math.imul($e, Je), L = L + Math.imul(oe, Ke) | 0, te = te + Math.imul(oe, x) | 0, te = te + Math.imul(A, Ke) | 0, me = me + Math.imul(A, x) | 0, L = L + Math.imul(Me, Se) | 0, te = te + Math.imul(Me, xe) | 0, te = te + Math.imul(Ne, Se) | 0, me = me + Math.imul(Ne, xe) | 0, L = L + Math.imul(De, Ye) | 0, te = te + Math.imul(De, et) | 0, te = te + Math.imul(ye, Ye) | 0, me = me + Math.imul(ye, et) | 0;
      var pt = (T + L | 0) + ((te & 8191) << 13) | 0;
      T = (me + (te >>> 13) | 0) + (pt >>> 26) | 0, pt &= 67108863, L = Math.imul(Fe, ze), te = Math.imul(Fe, Je), te = te + Math.imul(Ze, ze) | 0, me = Math.imul(Ze, Je), L = L + Math.imul(le, Ke) | 0, te = te + Math.imul(le, x) | 0, te = te + Math.imul($e, Ke) | 0, me = me + Math.imul($e, x) | 0, L = L + Math.imul(oe, Se) | 0, te = te + Math.imul(oe, xe) | 0, te = te + Math.imul(A, Se) | 0, me = me + Math.imul(A, xe) | 0, L = L + Math.imul(Me, Ye) | 0, te = te + Math.imul(Me, et) | 0, te = te + Math.imul(Ne, Ye) | 0, me = me + Math.imul(Ne, et) | 0, L = L + Math.imul(De, St) | 0, te = te + Math.imul(De, tt) | 0, te = te + Math.imul(ye, St) | 0, me = me + Math.imul(ye, tt) | 0;
      var mt = (T + L | 0) + ((te & 8191) << 13) | 0;
      T = (me + (te >>> 13) | 0) + (mt >>> 26) | 0, mt &= 67108863, L = Math.imul(yt, ze), te = Math.imul(yt, Je), te = te + Math.imul(Xe, ze) | 0, me = Math.imul(Xe, Je), L = L + Math.imul(Fe, Ke) | 0, te = te + Math.imul(Fe, x) | 0, te = te + Math.imul(Ze, Ke) | 0, me = me + Math.imul(Ze, x) | 0, L = L + Math.imul(le, Se) | 0, te = te + Math.imul(le, xe) | 0, te = te + Math.imul($e, Se) | 0, me = me + Math.imul($e, xe) | 0, L = L + Math.imul(oe, Ye) | 0, te = te + Math.imul(oe, et) | 0, te = te + Math.imul(A, Ye) | 0, me = me + Math.imul(A, et) | 0, L = L + Math.imul(Me, St) | 0, te = te + Math.imul(Me, tt) | 0, te = te + Math.imul(Ne, St) | 0, me = me + Math.imul(Ne, tt) | 0, L = L + Math.imul(De, kt) | 0, te = te + Math.imul(De, rt) | 0, te = te + Math.imul(ye, kt) | 0, me = me + Math.imul(ye, rt) | 0;
      var vt = (T + L | 0) + ((te & 8191) << 13) | 0;
      T = (me + (te >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, L = Math.imul(J, ze), te = Math.imul(J, Je), te = te + Math.imul(ge, ze) | 0, me = Math.imul(ge, Je), L = L + Math.imul(yt, Ke) | 0, te = te + Math.imul(yt, x) | 0, te = te + Math.imul(Xe, Ke) | 0, me = me + Math.imul(Xe, x) | 0, L = L + Math.imul(Fe, Se) | 0, te = te + Math.imul(Fe, xe) | 0, te = te + Math.imul(Ze, Se) | 0, me = me + Math.imul(Ze, xe) | 0, L = L + Math.imul(le, Ye) | 0, te = te + Math.imul(le, et) | 0, te = te + Math.imul($e, Ye) | 0, me = me + Math.imul($e, et) | 0, L = L + Math.imul(oe, St) | 0, te = te + Math.imul(oe, tt) | 0, te = te + Math.imul(A, St) | 0, me = me + Math.imul(A, tt) | 0, L = L + Math.imul(Me, kt) | 0, te = te + Math.imul(Me, rt) | 0, te = te + Math.imul(Ne, kt) | 0, me = me + Math.imul(Ne, rt) | 0, L = L + Math.imul(De, wt) | 0, te = te + Math.imul(De, nt) | 0, te = te + Math.imul(ye, wt) | 0, me = me + Math.imul(ye, nt) | 0;
      var ht = (T + L | 0) + ((te & 8191) << 13) | 0;
      T = (me + (te >>> 13) | 0) + (ht >>> 26) | 0, ht &= 67108863, L = Math.imul(We, ze), te = Math.imul(We, Je), te = te + Math.imul(Ie, ze) | 0, me = Math.imul(Ie, Je), L = L + Math.imul(J, Ke) | 0, te = te + Math.imul(J, x) | 0, te = te + Math.imul(ge, Ke) | 0, me = me + Math.imul(ge, x) | 0, L = L + Math.imul(yt, Se) | 0, te = te + Math.imul(yt, xe) | 0, te = te + Math.imul(Xe, Se) | 0, me = me + Math.imul(Xe, xe) | 0, L = L + Math.imul(Fe, Ye) | 0, te = te + Math.imul(Fe, et) | 0, te = te + Math.imul(Ze, Ye) | 0, me = me + Math.imul(Ze, et) | 0, L = L + Math.imul(le, St) | 0, te = te + Math.imul(le, tt) | 0, te = te + Math.imul($e, St) | 0, me = me + Math.imul($e, tt) | 0, L = L + Math.imul(oe, kt) | 0, te = te + Math.imul(oe, rt) | 0, te = te + Math.imul(A, kt) | 0, me = me + Math.imul(A, rt) | 0, L = L + Math.imul(Me, wt) | 0, te = te + Math.imul(Me, nt) | 0, te = te + Math.imul(Ne, wt) | 0, me = me + Math.imul(Ne, nt) | 0, L = L + Math.imul(De, bt) | 0, te = te + Math.imul(De, ot) | 0, te = te + Math.imul(ye, bt) | 0, me = me + Math.imul(ye, ot) | 0;
      var Et = (T + L | 0) + ((te & 8191) << 13) | 0;
      T = (me + (te >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, L = Math.imul(Ee, ze), te = Math.imul(Ee, Je), te = te + Math.imul(de, ze) | 0, me = Math.imul(de, Je), L = L + Math.imul(We, Ke) | 0, te = te + Math.imul(We, x) | 0, te = te + Math.imul(Ie, Ke) | 0, me = me + Math.imul(Ie, x) | 0, L = L + Math.imul(J, Se) | 0, te = te + Math.imul(J, xe) | 0, te = te + Math.imul(ge, Se) | 0, me = me + Math.imul(ge, xe) | 0, L = L + Math.imul(yt, Ye) | 0, te = te + Math.imul(yt, et) | 0, te = te + Math.imul(Xe, Ye) | 0, me = me + Math.imul(Xe, et) | 0, L = L + Math.imul(Fe, St) | 0, te = te + Math.imul(Fe, tt) | 0, te = te + Math.imul(Ze, St) | 0, me = me + Math.imul(Ze, tt) | 0, L = L + Math.imul(le, kt) | 0, te = te + Math.imul(le, rt) | 0, te = te + Math.imul($e, kt) | 0, me = me + Math.imul($e, rt) | 0, L = L + Math.imul(oe, wt) | 0, te = te + Math.imul(oe, nt) | 0, te = te + Math.imul(A, wt) | 0, me = me + Math.imul(A, nt) | 0, L = L + Math.imul(Me, bt) | 0, te = te + Math.imul(Me, ot) | 0, te = te + Math.imul(Ne, bt) | 0, me = me + Math.imul(Ne, ot) | 0, L = L + Math.imul(De, Pt) | 0, te = te + Math.imul(De, st) | 0, te = te + Math.imul(ye, Pt) | 0, me = me + Math.imul(ye, st) | 0;
      var Tt = (T + L | 0) + ((te & 8191) << 13) | 0;
      T = (me + (te >>> 13) | 0) + (Tt >>> 26) | 0, Tt &= 67108863, L = Math.imul(ve, ze), te = Math.imul(ve, Je), te = te + Math.imul(Pe, ze) | 0, me = Math.imul(Pe, Je), L = L + Math.imul(Ee, Ke) | 0, te = te + Math.imul(Ee, x) | 0, te = te + Math.imul(de, Ke) | 0, me = me + Math.imul(de, x) | 0, L = L + Math.imul(We, Se) | 0, te = te + Math.imul(We, xe) | 0, te = te + Math.imul(Ie, Se) | 0, me = me + Math.imul(Ie, xe) | 0, L = L + Math.imul(J, Ye) | 0, te = te + Math.imul(J, et) | 0, te = te + Math.imul(ge, Ye) | 0, me = me + Math.imul(ge, et) | 0, L = L + Math.imul(yt, St) | 0, te = te + Math.imul(yt, tt) | 0, te = te + Math.imul(Xe, St) | 0, me = me + Math.imul(Xe, tt) | 0, L = L + Math.imul(Fe, kt) | 0, te = te + Math.imul(Fe, rt) | 0, te = te + Math.imul(Ze, kt) | 0, me = me + Math.imul(Ze, rt) | 0, L = L + Math.imul(le, wt) | 0, te = te + Math.imul(le, nt) | 0, te = te + Math.imul($e, wt) | 0, me = me + Math.imul($e, nt) | 0, L = L + Math.imul(oe, bt) | 0, te = te + Math.imul(oe, ot) | 0, te = te + Math.imul(A, bt) | 0, me = me + Math.imul(A, ot) | 0, L = L + Math.imul(Me, Pt) | 0, te = te + Math.imul(Me, st) | 0, te = te + Math.imul(Ne, Pt) | 0, me = me + Math.imul(Ne, st) | 0, L = L + Math.imul(De, It) | 0, te = te + Math.imul(De, Rt) | 0, te = te + Math.imul(ye, It) | 0, me = me + Math.imul(ye, Rt) | 0;
      var Ot = (T + L | 0) + ((te & 8191) << 13) | 0;
      T = (me + (te >>> 13) | 0) + (Ot >>> 26) | 0, Ot &= 67108863, L = Math.imul(ve, Ke), te = Math.imul(ve, x), te = te + Math.imul(Pe, Ke) | 0, me = Math.imul(Pe, x), L = L + Math.imul(Ee, Se) | 0, te = te + Math.imul(Ee, xe) | 0, te = te + Math.imul(de, Se) | 0, me = me + Math.imul(de, xe) | 0, L = L + Math.imul(We, Ye) | 0, te = te + Math.imul(We, et) | 0, te = te + Math.imul(Ie, Ye) | 0, me = me + Math.imul(Ie, et) | 0, L = L + Math.imul(J, St) | 0, te = te + Math.imul(J, tt) | 0, te = te + Math.imul(ge, St) | 0, me = me + Math.imul(ge, tt) | 0, L = L + Math.imul(yt, kt) | 0, te = te + Math.imul(yt, rt) | 0, te = te + Math.imul(Xe, kt) | 0, me = me + Math.imul(Xe, rt) | 0, L = L + Math.imul(Fe, wt) | 0, te = te + Math.imul(Fe, nt) | 0, te = te + Math.imul(Ze, wt) | 0, me = me + Math.imul(Ze, nt) | 0, L = L + Math.imul(le, bt) | 0, te = te + Math.imul(le, ot) | 0, te = te + Math.imul($e, bt) | 0, me = me + Math.imul($e, ot) | 0, L = L + Math.imul(oe, Pt) | 0, te = te + Math.imul(oe, st) | 0, te = te + Math.imul(A, Pt) | 0, me = me + Math.imul(A, st) | 0, L = L + Math.imul(Me, It) | 0, te = te + Math.imul(Me, Rt) | 0, te = te + Math.imul(Ne, It) | 0, me = me + Math.imul(Ne, Rt) | 0;
      var Nt = (T + L | 0) + ((te & 8191) << 13) | 0;
      T = (me + (te >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, L = Math.imul(ve, Se), te = Math.imul(ve, xe), te = te + Math.imul(Pe, Se) | 0, me = Math.imul(Pe, xe), L = L + Math.imul(Ee, Ye) | 0, te = te + Math.imul(Ee, et) | 0, te = te + Math.imul(de, Ye) | 0, me = me + Math.imul(de, et) | 0, L = L + Math.imul(We, St) | 0, te = te + Math.imul(We, tt) | 0, te = te + Math.imul(Ie, St) | 0, me = me + Math.imul(Ie, tt) | 0, L = L + Math.imul(J, kt) | 0, te = te + Math.imul(J, rt) | 0, te = te + Math.imul(ge, kt) | 0, me = me + Math.imul(ge, rt) | 0, L = L + Math.imul(yt, wt) | 0, te = te + Math.imul(yt, nt) | 0, te = te + Math.imul(Xe, wt) | 0, me = me + Math.imul(Xe, nt) | 0, L = L + Math.imul(Fe, bt) | 0, te = te + Math.imul(Fe, ot) | 0, te = te + Math.imul(Ze, bt) | 0, me = me + Math.imul(Ze, ot) | 0, L = L + Math.imul(le, Pt) | 0, te = te + Math.imul(le, st) | 0, te = te + Math.imul($e, Pt) | 0, me = me + Math.imul($e, st) | 0, L = L + Math.imul(oe, It) | 0, te = te + Math.imul(oe, Rt) | 0, te = te + Math.imul(A, It) | 0, me = me + Math.imul(A, Rt) | 0;
      var At = (T + L | 0) + ((te & 8191) << 13) | 0;
      T = (me + (te >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, L = Math.imul(ve, Ye), te = Math.imul(ve, et), te = te + Math.imul(Pe, Ye) | 0, me = Math.imul(Pe, et), L = L + Math.imul(Ee, St) | 0, te = te + Math.imul(Ee, tt) | 0, te = te + Math.imul(de, St) | 0, me = me + Math.imul(de, tt) | 0, L = L + Math.imul(We, kt) | 0, te = te + Math.imul(We, rt) | 0, te = te + Math.imul(Ie, kt) | 0, me = me + Math.imul(Ie, rt) | 0, L = L + Math.imul(J, wt) | 0, te = te + Math.imul(J, nt) | 0, te = te + Math.imul(ge, wt) | 0, me = me + Math.imul(ge, nt) | 0, L = L + Math.imul(yt, bt) | 0, te = te + Math.imul(yt, ot) | 0, te = te + Math.imul(Xe, bt) | 0, me = me + Math.imul(Xe, ot) | 0, L = L + Math.imul(Fe, Pt) | 0, te = te + Math.imul(Fe, st) | 0, te = te + Math.imul(Ze, Pt) | 0, me = me + Math.imul(Ze, st) | 0, L = L + Math.imul(le, It) | 0, te = te + Math.imul(le, Rt) | 0, te = te + Math.imul($e, It) | 0, me = me + Math.imul($e, Rt) | 0;
      var Mt = (T + L | 0) + ((te & 8191) << 13) | 0;
      T = (me + (te >>> 13) | 0) + (Mt >>> 26) | 0, Mt &= 67108863, L = Math.imul(ve, St), te = Math.imul(ve, tt), te = te + Math.imul(Pe, St) | 0, me = Math.imul(Pe, tt), L = L + Math.imul(Ee, kt) | 0, te = te + Math.imul(Ee, rt) | 0, te = te + Math.imul(de, kt) | 0, me = me + Math.imul(de, rt) | 0, L = L + Math.imul(We, wt) | 0, te = te + Math.imul(We, nt) | 0, te = te + Math.imul(Ie, wt) | 0, me = me + Math.imul(Ie, nt) | 0, L = L + Math.imul(J, bt) | 0, te = te + Math.imul(J, ot) | 0, te = te + Math.imul(ge, bt) | 0, me = me + Math.imul(ge, ot) | 0, L = L + Math.imul(yt, Pt) | 0, te = te + Math.imul(yt, st) | 0, te = te + Math.imul(Xe, Pt) | 0, me = me + Math.imul(Xe, st) | 0, L = L + Math.imul(Fe, It) | 0, te = te + Math.imul(Fe, Rt) | 0, te = te + Math.imul(Ze, It) | 0, me = me + Math.imul(Ze, Rt) | 0;
      var $t = (T + L | 0) + ((te & 8191) << 13) | 0;
      T = (me + (te >>> 13) | 0) + ($t >>> 26) | 0, $t &= 67108863, L = Math.imul(ve, kt), te = Math.imul(ve, rt), te = te + Math.imul(Pe, kt) | 0, me = Math.imul(Pe, rt), L = L + Math.imul(Ee, wt) | 0, te = te + Math.imul(Ee, nt) | 0, te = te + Math.imul(de, wt) | 0, me = me + Math.imul(de, nt) | 0, L = L + Math.imul(We, bt) | 0, te = te + Math.imul(We, ot) | 0, te = te + Math.imul(Ie, bt) | 0, me = me + Math.imul(Ie, ot) | 0, L = L + Math.imul(J, Pt) | 0, te = te + Math.imul(J, st) | 0, te = te + Math.imul(ge, Pt) | 0, me = me + Math.imul(ge, st) | 0, L = L + Math.imul(yt, It) | 0, te = te + Math.imul(yt, Rt) | 0, te = te + Math.imul(Xe, It) | 0, me = me + Math.imul(Xe, Rt) | 0;
      var Bt = (T + L | 0) + ((te & 8191) << 13) | 0;
      T = (me + (te >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, L = Math.imul(ve, wt), te = Math.imul(ve, nt), te = te + Math.imul(Pe, wt) | 0, me = Math.imul(Pe, nt), L = L + Math.imul(Ee, bt) | 0, te = te + Math.imul(Ee, ot) | 0, te = te + Math.imul(de, bt) | 0, me = me + Math.imul(de, ot) | 0, L = L + Math.imul(We, Pt) | 0, te = te + Math.imul(We, st) | 0, te = te + Math.imul(Ie, Pt) | 0, me = me + Math.imul(Ie, st) | 0, L = L + Math.imul(J, It) | 0, te = te + Math.imul(J, Rt) | 0, te = te + Math.imul(ge, It) | 0, me = me + Math.imul(ge, Rt) | 0;
      var Ut = (T + L | 0) + ((te & 8191) << 13) | 0;
      T = (me + (te >>> 13) | 0) + (Ut >>> 26) | 0, Ut &= 67108863, L = Math.imul(ve, bt), te = Math.imul(ve, ot), te = te + Math.imul(Pe, bt) | 0, me = Math.imul(Pe, ot), L = L + Math.imul(Ee, Pt) | 0, te = te + Math.imul(Ee, st) | 0, te = te + Math.imul(de, Pt) | 0, me = me + Math.imul(de, st) | 0, L = L + Math.imul(We, It) | 0, te = te + Math.imul(We, Rt) | 0, te = te + Math.imul(Ie, It) | 0, me = me + Math.imul(Ie, Rt) | 0;
      var xt = (T + L | 0) + ((te & 8191) << 13) | 0;
      T = (me + (te >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, L = Math.imul(ve, Pt), te = Math.imul(ve, st), te = te + Math.imul(Pe, Pt) | 0, me = Math.imul(Pe, st), L = L + Math.imul(Ee, It) | 0, te = te + Math.imul(Ee, Rt) | 0, te = te + Math.imul(de, It) | 0, me = me + Math.imul(de, Rt) | 0;
      var Jt = (T + L | 0) + ((te & 8191) << 13) | 0;
      T = (me + (te >>> 13) | 0) + (Jt >>> 26) | 0, Jt &= 67108863, L = Math.imul(ve, It), te = Math.imul(ve, Rt), te = te + Math.imul(Pe, It) | 0, me = Math.imul(Pe, Rt);
      var Gt = (T + L | 0) + ((te & 8191) << 13) | 0;
      return T = (me + (te >>> 13) | 0) + (Gt >>> 26) | 0, Gt &= 67108863, B[0] = Ve, B[1] = He, B[2] = Qe, B[3] = pt, B[4] = mt, B[5] = vt, B[6] = ht, B[7] = Et, B[8] = Tt, B[9] = Ot, B[10] = Nt, B[11] = At, B[12] = Mt, B[13] = $t, B[14] = Bt, B[15] = Ut, B[16] = xt, B[17] = Jt, B[18] = Gt, T !== 0 && (B[19] = T, $.length++), $;
    };
    Math.imul || (j = ae);
    function ue(E, I, M) {
      M.negative = I.negative ^ E.negative, M.length = E.length + I.length;
      for (var $ = 0, U = 0, Y = 0; Y < M.length - 1; Y++) {
        var B = U;
        U = 0;
        for (var T = $ & 67108863, L = Math.min(Y, I.length - 1), te = Math.max(0, Y - E.length + 1); te <= L; te++) {
          var me = Y - te, Ce = E.words[me] | 0, De = I.words[te] | 0, ye = Ce * De, pe = ye & 67108863;
          B = B + (ye / 67108864 | 0) | 0, pe = pe + T | 0, T = pe & 67108863, B = B + (pe >>> 26) | 0, U += B >>> 26, B &= 67108863;
        }
        M.words[Y] = T, $ = B, B = U;
      }
      return $ !== 0 ? M.words[Y] = $ : M.length--, M._strip();
    }
    function he(E, I, M) {
      return ue(E, I, M);
    }
    p.prototype.mulTo = function(I, M) {
      var $, U = this.length + I.length;
      return this.length === 10 && I.length === 10 ? $ = j(this, I, M) : U < 63 ? $ = ae(this, I, M) : U < 1024 ? $ = ue(this, I, M) : $ = he(this, I, M), $;
    }, p.prototype.mul = function(I) {
      var M = new p(null);
      return M.words = new Array(this.length + I.length), this.mulTo(I, M);
    }, p.prototype.mulf = function(I) {
      var M = new p(null);
      return M.words = new Array(this.length + I.length), he(this, I, M);
    }, p.prototype.imul = function(I) {
      return this.clone().mulTo(I, this);
    }, p.prototype.imuln = function(I) {
      var M = I < 0;
      M && (I = -I), l(typeof I == "number"), l(I < 67108864);
      for (var $ = 0, U = 0; U < this.length; U++) {
        var Y = (this.words[U] | 0) * I, B = (Y & 67108863) + ($ & 67108863);
        $ >>= 26, $ += Y / 67108864 | 0, $ += B >>> 26, this.words[U] = B & 67108863;
      }
      return $ !== 0 && (this.words[U] = $, this.length++), M ? this.ineg() : this;
    }, p.prototype.muln = function(I) {
      return this.clone().imuln(I);
    }, p.prototype.sqr = function() {
      return this.mul(this);
    }, p.prototype.isqr = function() {
      return this.imul(this.clone());
    }, p.prototype.pow = function(I) {
      var M = Q(I);
      if (M.length === 0)
        return new p(1);
      for (var $ = this, U = 0; U < M.length && M[U] === 0; U++, $ = $.sqr())
        ;
      if (++U < M.length)
        for (var Y = $.sqr(); U < M.length; U++, Y = Y.sqr())
          M[U] !== 0 && ($ = $.mul(Y));
      return $;
    }, p.prototype.iushln = function(I) {
      l(typeof I == "number" && I >= 0);
      var M = I % 26, $ = (I - M) / 26, U = 67108863 >>> 26 - M << 26 - M, Y;
      if (M !== 0) {
        var B = 0;
        for (Y = 0; Y < this.length; Y++) {
          var T = this.words[Y] & U, L = (this.words[Y] | 0) - T << M;
          this.words[Y] = L | B, B = T >>> 26 - M;
        }
        B && (this.words[Y] = B, this.length++);
      }
      if ($ !== 0) {
        for (Y = this.length - 1; Y >= 0; Y--)
          this.words[Y + $] = this.words[Y];
        for (Y = 0; Y < $; Y++)
          this.words[Y] = 0;
        this.length += $;
      }
      return this._strip();
    }, p.prototype.ishln = function(I) {
      return l(this.negative === 0), this.iushln(I);
    }, p.prototype.iushrn = function(I, M, $) {
      l(typeof I == "number" && I >= 0);
      var U;
      M ? U = (M - M % 26) / 26 : U = 0;
      var Y = I % 26, B = Math.min((I - Y) / 26, this.length), T = 67108863 ^ 67108863 >>> Y << Y, L = $;
      if (U -= B, U = Math.max(0, U), L) {
        for (var te = 0; te < B; te++)
          L.words[te] = this.words[te];
        L.length = B;
      }
      if (B !== 0)
        if (this.length > B)
          for (this.length -= B, te = 0; te < this.length; te++)
            this.words[te] = this.words[te + B];
        else
          this.words[0] = 0, this.length = 1;
      var me = 0;
      for (te = this.length - 1; te >= 0 && (me !== 0 || te >= U); te--) {
        var Ce = this.words[te] | 0;
        this.words[te] = me << 26 - Y | Ce >>> Y, me = Ce & T;
      }
      return L && me !== 0 && (L.words[L.length++] = me), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, p.prototype.ishrn = function(I, M, $) {
      return l(this.negative === 0), this.iushrn(I, M, $);
    }, p.prototype.shln = function(I) {
      return this.clone().ishln(I);
    }, p.prototype.ushln = function(I) {
      return this.clone().iushln(I);
    }, p.prototype.shrn = function(I) {
      return this.clone().ishrn(I);
    }, p.prototype.ushrn = function(I) {
      return this.clone().iushrn(I);
    }, p.prototype.testn = function(I) {
      l(typeof I == "number" && I >= 0);
      var M = I % 26, $ = (I - M) / 26, U = 1 << M;
      if (this.length <= $)
        return !1;
      var Y = this.words[$];
      return !!(Y & U);
    }, p.prototype.imaskn = function(I) {
      l(typeof I == "number" && I >= 0);
      var M = I % 26, $ = (I - M) / 26;
      if (l(this.negative === 0, "imaskn works only with positive numbers"), this.length <= $)
        return this;
      if (M !== 0 && $++, this.length = Math.min($, this.length), M !== 0) {
        var U = 67108863 ^ 67108863 >>> M << M;
        this.words[this.length - 1] &= U;
      }
      return this._strip();
    }, p.prototype.maskn = function(I) {
      return this.clone().imaskn(I);
    }, p.prototype.iaddn = function(I) {
      return l(typeof I == "number"), l(I < 67108864), I < 0 ? this.isubn(-I) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= I ? (this.words[0] = I - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(I), this.negative = 1, this) : this._iaddn(I);
    }, p.prototype._iaddn = function(I) {
      this.words[0] += I;
      for (var M = 0; M < this.length && this.words[M] >= 67108864; M++)
        this.words[M] -= 67108864, M === this.length - 1 ? this.words[M + 1] = 1 : this.words[M + 1]++;
      return this.length = Math.max(this.length, M + 1), this;
    }, p.prototype.isubn = function(I) {
      if (l(typeof I == "number"), l(I < 67108864), I < 0)
        return this.iaddn(-I);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(I), this.negative = 1, this;
      if (this.words[0] -= I, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var M = 0; M < this.length && this.words[M] < 0; M++)
          this.words[M] += 67108864, this.words[M + 1] -= 1;
      return this._strip();
    }, p.prototype.addn = function(I) {
      return this.clone().iaddn(I);
    }, p.prototype.subn = function(I) {
      return this.clone().isubn(I);
    }, p.prototype.iabs = function() {
      return this.negative = 0, this;
    }, p.prototype.abs = function() {
      return this.clone().iabs();
    }, p.prototype._ishlnsubmul = function(I, M, $) {
      var U = I.length + $, Y;
      this._expand(U);
      var B, T = 0;
      for (Y = 0; Y < I.length; Y++) {
        B = (this.words[Y + $] | 0) + T;
        var L = (I.words[Y] | 0) * M;
        B -= L & 67108863, T = (B >> 26) - (L / 67108864 | 0), this.words[Y + $] = B & 67108863;
      }
      for (; Y < this.length - $; Y++)
        B = (this.words[Y + $] | 0) + T, T = B >> 26, this.words[Y + $] = B & 67108863;
      if (T === 0)
        return this._strip();
      for (l(T === -1), T = 0, Y = 0; Y < this.length; Y++)
        B = -(this.words[Y] | 0) + T, T = B >> 26, this.words[Y] = B & 67108863;
      return this.negative = 1, this._strip();
    }, p.prototype._wordDiv = function(I, M) {
      var $ = this.length - I.length, U = this.clone(), Y = I, B = Y.words[Y.length - 1] | 0, T = this._countBits(B);
      $ = 26 - T, $ !== 0 && (Y = Y.ushln($), U.iushln($), B = Y.words[Y.length - 1] | 0);
      var L = U.length - Y.length, te;
      if (M !== "mod") {
        te = new p(null), te.length = L + 1, te.words = new Array(te.length);
        for (var me = 0; me < te.length; me++)
          te.words[me] = 0;
      }
      var Ce = U.clone()._ishlnsubmul(Y, 1, L);
      Ce.negative === 0 && (U = Ce, te && (te.words[L] = 1));
      for (var De = L - 1; De >= 0; De--) {
        var ye = (U.words[Y.length + De] | 0) * 67108864 + (U.words[Y.length + De - 1] | 0);
        for (ye = Math.min(ye / B | 0, 67108863), U._ishlnsubmul(Y, ye, De); U.negative !== 0; )
          ye--, U.negative = 0, U._ishlnsubmul(Y, 1, De), U.isZero() || (U.negative ^= 1);
        te && (te.words[De] = ye);
      }
      return te && te._strip(), U._strip(), M !== "div" && $ !== 0 && U.iushrn($), {
        div: te || null,
        mod: U
      };
    }, p.prototype.divmod = function(I, M, $) {
      if (l(!I.isZero()), this.isZero())
        return {
          div: new p(0),
          mod: new p(0)
        };
      var U, Y, B;
      return this.negative !== 0 && I.negative === 0 ? (B = this.neg().divmod(I, M), M !== "mod" && (U = B.div.neg()), M !== "div" && (Y = B.mod.neg(), $ && Y.negative !== 0 && Y.iadd(I)), {
        div: U,
        mod: Y
      }) : this.negative === 0 && I.negative !== 0 ? (B = this.divmod(I.neg(), M), M !== "mod" && (U = B.div.neg()), {
        div: U,
        mod: B.mod
      }) : this.negative & I.negative ? (B = this.neg().divmod(I.neg(), M), M !== "div" && (Y = B.mod.neg(), $ && Y.negative !== 0 && Y.isub(I)), {
        div: B.div,
        mod: Y
      }) : I.length > this.length || this.cmp(I) < 0 ? {
        div: new p(0),
        mod: this
      } : I.length === 1 ? M === "div" ? {
        div: this.divn(I.words[0]),
        mod: null
      } : M === "mod" ? {
        div: null,
        mod: new p(this.modrn(I.words[0]))
      } : {
        div: this.divn(I.words[0]),
        mod: new p(this.modrn(I.words[0]))
      } : this._wordDiv(I, M);
    }, p.prototype.div = function(I) {
      return this.divmod(I, "div", !1).div;
    }, p.prototype.mod = function(I) {
      return this.divmod(I, "mod", !1).mod;
    }, p.prototype.umod = function(I) {
      return this.divmod(I, "mod", !0).mod;
    }, p.prototype.divRound = function(I) {
      var M = this.divmod(I);
      if (M.mod.isZero())
        return M.div;
      var $ = M.div.negative !== 0 ? M.mod.isub(I) : M.mod, U = I.ushrn(1), Y = I.andln(1), B = $.cmp(U);
      return B < 0 || Y === 1 && B === 0 ? M.div : M.div.negative !== 0 ? M.div.isubn(1) : M.div.iaddn(1);
    }, p.prototype.modrn = function(I) {
      var M = I < 0;
      M && (I = -I), l(I <= 67108863);
      for (var $ = (1 << 26) % I, U = 0, Y = this.length - 1; Y >= 0; Y--)
        U = ($ * U + (this.words[Y] | 0)) % I;
      return M ? -U : U;
    }, p.prototype.modn = function(I) {
      return this.modrn(I);
    }, p.prototype.idivn = function(I) {
      var M = I < 0;
      M && (I = -I), l(I <= 67108863);
      for (var $ = 0, U = this.length - 1; U >= 0; U--) {
        var Y = (this.words[U] | 0) + $ * 67108864;
        this.words[U] = Y / I | 0, $ = Y % I;
      }
      return this._strip(), M ? this.ineg() : this;
    }, p.prototype.divn = function(I) {
      return this.clone().idivn(I);
    }, p.prototype.egcd = function(I) {
      l(I.negative === 0), l(!I.isZero());
      var M = this, $ = I.clone();
      M.negative !== 0 ? M = M.umod(I) : M = M.clone();
      for (var U = new p(1), Y = new p(0), B = new p(0), T = new p(1), L = 0; M.isEven() && $.isEven(); )
        M.iushrn(1), $.iushrn(1), ++L;
      for (var te = $.clone(), me = M.clone(); !M.isZero(); ) {
        for (var Ce = 0, De = 1; !(M.words[0] & De) && Ce < 26; ++Ce, De <<= 1)
          ;
        if (Ce > 0)
          for (M.iushrn(Ce); Ce-- > 0; )
            (U.isOdd() || Y.isOdd()) && (U.iadd(te), Y.isub(me)), U.iushrn(1), Y.iushrn(1);
        for (var ye = 0, pe = 1; !($.words[0] & pe) && ye < 26; ++ye, pe <<= 1)
          ;
        if (ye > 0)
          for ($.iushrn(ye); ye-- > 0; )
            (B.isOdd() || T.isOdd()) && (B.iadd(te), T.isub(me)), B.iushrn(1), T.iushrn(1);
        M.cmp($) >= 0 ? (M.isub($), U.isub(B), Y.isub(T)) : ($.isub(M), B.isub(U), T.isub(Y));
      }
      return {
        a: B,
        b: T,
        gcd: $.iushln(L)
      };
    }, p.prototype._invmp = function(I) {
      l(I.negative === 0), l(!I.isZero());
      var M = this, $ = I.clone();
      M.negative !== 0 ? M = M.umod(I) : M = M.clone();
      for (var U = new p(1), Y = new p(0), B = $.clone(); M.cmpn(1) > 0 && $.cmpn(1) > 0; ) {
        for (var T = 0, L = 1; !(M.words[0] & L) && T < 26; ++T, L <<= 1)
          ;
        if (T > 0)
          for (M.iushrn(T); T-- > 0; )
            U.isOdd() && U.iadd(B), U.iushrn(1);
        for (var te = 0, me = 1; !($.words[0] & me) && te < 26; ++te, me <<= 1)
          ;
        if (te > 0)
          for ($.iushrn(te); te-- > 0; )
            Y.isOdd() && Y.iadd(B), Y.iushrn(1);
        M.cmp($) >= 0 ? (M.isub($), U.isub(Y)) : ($.isub(M), Y.isub(U));
      }
      var Ce;
      return M.cmpn(1) === 0 ? Ce = U : Ce = Y, Ce.cmpn(0) < 0 && Ce.iadd(I), Ce;
    }, p.prototype.gcd = function(I) {
      if (this.isZero())
        return I.abs();
      if (I.isZero())
        return this.abs();
      var M = this.clone(), $ = I.clone();
      M.negative = 0, $.negative = 0;
      for (var U = 0; M.isEven() && $.isEven(); U++)
        M.iushrn(1), $.iushrn(1);
      do {
        for (; M.isEven(); )
          M.iushrn(1);
        for (; $.isEven(); )
          $.iushrn(1);
        var Y = M.cmp($);
        if (Y < 0) {
          var B = M;
          M = $, $ = B;
        } else if (Y === 0 || $.cmpn(1) === 0)
          break;
        M.isub($);
      } while (!0);
      return $.iushln(U);
    }, p.prototype.invm = function(I) {
      return this.egcd(I).a.umod(I);
    }, p.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, p.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, p.prototype.andln = function(I) {
      return this.words[0] & I;
    }, p.prototype.bincn = function(I) {
      l(typeof I == "number");
      var M = I % 26, $ = (I - M) / 26, U = 1 << M;
      if (this.length <= $)
        return this._expand($ + 1), this.words[$] |= U, this;
      for (var Y = U, B = $; Y !== 0 && B < this.length; B++) {
        var T = this.words[B] | 0;
        T += Y, Y = T >>> 26, T &= 67108863, this.words[B] = T;
      }
      return Y !== 0 && (this.words[B] = Y, this.length++), this;
    }, p.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, p.prototype.cmpn = function(I) {
      var M = I < 0;
      if (this.negative !== 0 && !M)
        return -1;
      if (this.negative === 0 && M)
        return 1;
      this._strip();
      var $;
      if (this.length > 1)
        $ = 1;
      else {
        M && (I = -I), l(I <= 67108863, "Number is too big");
        var U = this.words[0] | 0;
        $ = U === I ? 0 : U < I ? -1 : 1;
      }
      return this.negative !== 0 ? -$ | 0 : $;
    }, p.prototype.cmp = function(I) {
      if (this.negative !== 0 && I.negative === 0)
        return -1;
      if (this.negative === 0 && I.negative !== 0)
        return 1;
      var M = this.ucmp(I);
      return this.negative !== 0 ? -M | 0 : M;
    }, p.prototype.ucmp = function(I) {
      if (this.length > I.length)
        return 1;
      if (this.length < I.length)
        return -1;
      for (var M = 0, $ = this.length - 1; $ >= 0; $--) {
        var U = this.words[$] | 0, Y = I.words[$] | 0;
        if (U !== Y) {
          U < Y ? M = -1 : U > Y && (M = 1);
          break;
        }
      }
      return M;
    }, p.prototype.gtn = function(I) {
      return this.cmpn(I) === 1;
    }, p.prototype.gt = function(I) {
      return this.cmp(I) === 1;
    }, p.prototype.gten = function(I) {
      return this.cmpn(I) >= 0;
    }, p.prototype.gte = function(I) {
      return this.cmp(I) >= 0;
    }, p.prototype.ltn = function(I) {
      return this.cmpn(I) === -1;
    }, p.prototype.lt = function(I) {
      return this.cmp(I) === -1;
    }, p.prototype.lten = function(I) {
      return this.cmpn(I) <= 0;
    }, p.prototype.lte = function(I) {
      return this.cmp(I) <= 0;
    }, p.prototype.eqn = function(I) {
      return this.cmpn(I) === 0;
    }, p.prototype.eq = function(I) {
      return this.cmp(I) === 0;
    }, p.red = function(I) {
      return new P(I);
    }, p.prototype.toRed = function(I) {
      return l(!this.red, "Already a number in reduction context"), l(this.negative === 0, "red works only with positives"), I.convertTo(this)._forceRed(I);
    }, p.prototype.fromRed = function() {
      return l(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, p.prototype._forceRed = function(I) {
      return this.red = I, this;
    }, p.prototype.forceRed = function(I) {
      return l(!this.red, "Already a number in reduction context"), this._forceRed(I);
    }, p.prototype.redAdd = function(I) {
      return l(this.red, "redAdd works only with red numbers"), this.red.add(this, I);
    }, p.prototype.redIAdd = function(I) {
      return l(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, I);
    }, p.prototype.redSub = function(I) {
      return l(this.red, "redSub works only with red numbers"), this.red.sub(this, I);
    }, p.prototype.redISub = function(I) {
      return l(this.red, "redISub works only with red numbers"), this.red.isub(this, I);
    }, p.prototype.redShl = function(I) {
      return l(this.red, "redShl works only with red numbers"), this.red.shl(this, I);
    }, p.prototype.redMul = function(I) {
      return l(this.red, "redMul works only with red numbers"), this.red._verify2(this, I), this.red.mul(this, I);
    }, p.prototype.redIMul = function(I) {
      return l(this.red, "redMul works only with red numbers"), this.red._verify2(this, I), this.red.imul(this, I);
    }, p.prototype.redSqr = function() {
      return l(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, p.prototype.redISqr = function() {
      return l(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, p.prototype.redSqrt = function() {
      return l(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, p.prototype.redInvm = function() {
      return l(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, p.prototype.redNeg = function() {
      return l(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, p.prototype.redPow = function(I) {
      return l(this.red && !I.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, I);
    };
    var fe = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function be(E, I) {
      this.name = E, this.p = new p(I, 16), this.n = this.p.bitLength(), this.k = new p(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    be.prototype._tmp = function() {
      var I = new p(null);
      return I.words = new Array(Math.ceil(this.n / 13)), I;
    }, be.prototype.ireduce = function(I) {
      var M = I, $;
      do
        this.split(M, this.tmp), M = this.imulK(M), M = M.iadd(this.tmp), $ = M.bitLength();
      while ($ > this.n);
      var U = $ < this.n ? -1 : M.ucmp(this.p);
      return U === 0 ? (M.words[0] = 0, M.length = 1) : U > 0 ? M.isub(this.p) : M.strip !== void 0 ? M.strip() : M._strip(), M;
    }, be.prototype.split = function(I, M) {
      I.iushrn(this.n, 0, M);
    }, be.prototype.imulK = function(I) {
      return I.imul(this.k);
    };
    function ke() {
      be.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    v(ke, be), ke.prototype.split = function(I, M) {
      for (var $ = 4194303, U = Math.min(I.length, 9), Y = 0; Y < U; Y++)
        M.words[Y] = I.words[Y];
      if (M.length = U, I.length <= 9) {
        I.words[0] = 0, I.length = 1;
        return;
      }
      var B = I.words[9];
      for (M.words[M.length++] = B & $, Y = 10; Y < I.length; Y++) {
        var T = I.words[Y] | 0;
        I.words[Y - 10] = (T & $) << 4 | B >>> 22, B = T;
      }
      B >>>= 22, I.words[Y - 10] = B, B === 0 && I.length > 10 ? I.length -= 10 : I.length -= 9;
    }, ke.prototype.imulK = function(I) {
      I.words[I.length] = 0, I.words[I.length + 1] = 0, I.length += 2;
      for (var M = 0, $ = 0; $ < I.length; $++) {
        var U = I.words[$] | 0;
        M += U * 977, I.words[$] = M & 67108863, M = U * 64 + (M / 67108864 | 0);
      }
      return I.words[I.length - 1] === 0 && (I.length--, I.words[I.length - 1] === 0 && I.length--), I;
    };
    function Te() {
      be.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    v(Te, be);
    function q() {
      be.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    v(q, be);
    function z() {
      be.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    v(z, be), z.prototype.imulK = function(I) {
      for (var M = 0, $ = 0; $ < I.length; $++) {
        var U = (I.words[$] | 0) * 19 + M, Y = U & 67108863;
        U >>>= 26, I.words[$] = Y, M = U;
      }
      return M !== 0 && (I.words[I.length++] = M), I;
    }, p._prime = function(I) {
      if (fe[I])
        return fe[I];
      var M;
      if (I === "k256")
        M = new ke();
      else if (I === "p224")
        M = new Te();
      else if (I === "p192")
        M = new q();
      else if (I === "p25519")
        M = new z();
      else
        throw new Error("Unknown prime " + I);
      return fe[I] = M, M;
    };
    function P(E) {
      if (typeof E == "string") {
        var I = p._prime(E);
        this.m = I.p, this.prime = I;
      } else
        l(E.gtn(1), "modulus must be greater than 1"), this.m = E, this.prime = null;
    }
    P.prototype._verify1 = function(I) {
      l(I.negative === 0, "red works only with positives"), l(I.red, "red works only with red numbers");
    }, P.prototype._verify2 = function(I, M) {
      l((I.negative | M.negative) === 0, "red works only with positives"), l(
        I.red && I.red === M.red,
        "red works only with red numbers"
      );
    }, P.prototype.imod = function(I) {
      return this.prime ? this.prime.ireduce(I)._forceRed(this) : (F(I, I.umod(this.m)._forceRed(this)), I);
    }, P.prototype.neg = function(I) {
      return I.isZero() ? I.clone() : this.m.sub(I)._forceRed(this);
    }, P.prototype.add = function(I, M) {
      this._verify2(I, M);
      var $ = I.add(M);
      return $.cmp(this.m) >= 0 && $.isub(this.m), $._forceRed(this);
    }, P.prototype.iadd = function(I, M) {
      this._verify2(I, M);
      var $ = I.iadd(M);
      return $.cmp(this.m) >= 0 && $.isub(this.m), $;
    }, P.prototype.sub = function(I, M) {
      this._verify2(I, M);
      var $ = I.sub(M);
      return $.cmpn(0) < 0 && $.iadd(this.m), $._forceRed(this);
    }, P.prototype.isub = function(I, M) {
      this._verify2(I, M);
      var $ = I.isub(M);
      return $.cmpn(0) < 0 && $.iadd(this.m), $;
    }, P.prototype.shl = function(I, M) {
      return this._verify1(I), this.imod(I.ushln(M));
    }, P.prototype.imul = function(I, M) {
      return this._verify2(I, M), this.imod(I.imul(M));
    }, P.prototype.mul = function(I, M) {
      return this._verify2(I, M), this.imod(I.mul(M));
    }, P.prototype.isqr = function(I) {
      return this.imul(I, I.clone());
    }, P.prototype.sqr = function(I) {
      return this.mul(I, I);
    }, P.prototype.sqrt = function(I) {
      if (I.isZero())
        return I.clone();
      var M = this.m.andln(3);
      if (l(M % 2 === 1), M === 3) {
        var $ = this.m.add(new p(1)).iushrn(2);
        return this.pow(I, $);
      }
      for (var U = this.m.subn(1), Y = 0; !U.isZero() && U.andln(1) === 0; )
        Y++, U.iushrn(1);
      l(!U.isZero());
      var B = new p(1).toRed(this), T = B.redNeg(), L = this.m.subn(1).iushrn(1), te = this.m.bitLength();
      for (te = new p(2 * te * te).toRed(this); this.pow(te, L).cmp(T) !== 0; )
        te.redIAdd(T);
      for (var me = this.pow(te, U), Ce = this.pow(I, U.addn(1).iushrn(1)), De = this.pow(I, U), ye = Y; De.cmp(B) !== 0; ) {
        for (var pe = De, Me = 0; pe.cmp(B) !== 0; Me++)
          pe = pe.redSqr();
        l(Me < ye);
        var Ne = this.pow(me, new p(1).iushln(ye - Me - 1));
        Ce = Ce.redMul(Ne), me = Ne.redSqr(), De = De.redMul(me), ye = Me;
      }
      return Ce;
    }, P.prototype.invm = function(I) {
      var M = I._invmp(this.m);
      return M.negative !== 0 ? (M.negative = 0, this.imod(M).redNeg()) : this.imod(M);
    }, P.prototype.pow = function(I, M) {
      if (M.isZero())
        return new p(1).toRed(this);
      if (M.cmpn(1) === 0)
        return I.clone();
      var $ = 4, U = new Array(1 << $);
      U[0] = new p(1).toRed(this), U[1] = I;
      for (var Y = 2; Y < U.length; Y++)
        U[Y] = this.mul(U[Y - 1], I);
      var B = U[0], T = 0, L = 0, te = M.bitLength() % 26;
      for (te === 0 && (te = 26), Y = M.length - 1; Y >= 0; Y--) {
        for (var me = M.words[Y], Ce = te - 1; Ce >= 0; Ce--) {
          var De = me >> Ce & 1;
          if (B !== U[0] && (B = this.sqr(B)), De === 0 && T === 0) {
            L = 0;
            continue;
          }
          T <<= 1, T |= De, L++, !(L !== $ && (Y !== 0 || Ce !== 0)) && (B = this.mul(B, U[T]), L = 0, T = 0);
        }
        te = 26;
      }
      return B;
    }, P.prototype.convertTo = function(I) {
      var M = I.umod(this.m);
      return M === I ? M.clone() : M;
    }, P.prototype.convertFrom = function(I) {
      var M = I.clone();
      return M.red = null, M;
    }, p.mont = function(I) {
      return new S(I);
    };
    function S(E) {
      P.call(this, E), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new p(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    v(S, P), S.prototype.convertTo = function(I) {
      return this.imod(I.ushln(this.shift));
    }, S.prototype.convertFrom = function(I) {
      var M = this.imod(I.mul(this.rinv));
      return M.red = null, M;
    }, S.prototype.imul = function(I, M) {
      if (I.isZero() || M.isZero())
        return I.words[0] = 0, I.length = 1, I;
      var $ = I.imul(M), U = $.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), Y = $.isub(U).iushrn(this.shift), B = Y;
      return Y.cmp(this.m) >= 0 ? B = Y.isub(this.m) : Y.cmpn(0) < 0 && (B = Y.iadd(this.m)), B._forceRed(this);
    }, S.prototype.mul = function(I, M) {
      if (I.isZero() || M.isZero())
        return new p(0)._forceRed(this);
      var $ = I.mul(M), U = $.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), Y = $.isub(U).iushrn(this.shift), B = Y;
      return Y.cmp(this.m) >= 0 ? B = Y.isub(this.m) : Y.cmpn(0) < 0 && (B = Y.iadd(this.m)), B._forceRed(this);
    }, S.prototype.invm = function(I) {
      var M = this.imod(I._invmp(this.m).mul(this.r2));
      return M._forceRed(this);
    };
  })(a, commonjsGlobal$1);
})(bn$4);
var bnExports$4 = bn$4.exports, BN$a = bnExports$4, randomBytes$1 = browserExports;
function blind(a) {
  var u = getr(a), c = u.toRed(BN$a.mont(a.modulus)).redPow(new BN$a(a.publicExponent)).fromRed();
  return { blinder: c, unblinder: u.invm(a.modulus) };
}
function getr(a) {
  var u = a.modulus.byteLength(), c;
  do
    c = new BN$a(randomBytes$1(u));
  while (c.cmp(a.modulus) >= 0 || !c.umod(a.prime1) || !c.umod(a.prime2));
  return c;
}
function crt$2(a, u) {
  var c = blind(u), l = u.modulus.byteLength(), v = new BN$a(a).mul(c.blinder).umod(u.modulus), p = v.toRed(BN$a.mont(u.prime1)), _ = v.toRed(BN$a.mont(u.prime2)), k = u.coefficient, O = u.prime1, D = u.prime2, F = p.redPow(u.exponent1).fromRed(), H = _.redPow(u.exponent2).fromRed(), Z = F.isub(H).imul(k).umod(O).imul(D);
  return H.iadd(Z).imul(c.unblinder).umod(u.modulus).toArrayLike(Buffer$O, "be", l);
}
crt$2.getr = getr;
var browserifyRsa = crt$2, elliptic = {};
const name$1 = "elliptic", version$1 = "6.5.4", description$1 = "EC cryptography", main$1 = "lib/elliptic.js", files = [
  "lib"
], scripts$1 = {
  lint: "eslint lib test",
  "lint:fix": "npm run lint -- --fix",
  unit: "istanbul test _mocha --reporter=spec test/index.js",
  test: "npm run lint && npm run unit",
  version: "grunt dist && git add dist/"
}, repository$1 = {
  type: "git",
  url: "git@github.com:indutny/elliptic"
}, keywords$1 = [
  "EC",
  "Elliptic",
  "curve",
  "Cryptography"
], author$1 = "Fedor Indutny <fedor@indutny.com>", license$1 = "MIT", bugs$1 = {
  url: "https://github.com/indutny/elliptic/issues"
}, homepage$1 = "https://github.com/indutny/elliptic", devDependencies$1 = {
  brfs: "^2.0.2",
  coveralls: "^3.1.0",
  eslint: "^7.6.0",
  grunt: "^1.2.1",
  "grunt-browserify": "^5.3.0",
  "grunt-cli": "^1.3.2",
  "grunt-contrib-connect": "^3.0.0",
  "grunt-contrib-copy": "^1.0.0",
  "grunt-contrib-uglify": "^5.0.0",
  "grunt-mocha-istanbul": "^5.0.2",
  "grunt-saucelabs": "^9.0.1",
  istanbul: "^0.4.5",
  mocha: "^8.0.1"
}, dependencies$1 = {
  "bn.js": "^4.11.9",
  brorand: "^1.1.0",
  "hash.js": "^1.0.0",
  "hmac-drbg": "^1.0.1",
  inherits: "^2.0.4",
  "minimalistic-assert": "^1.0.1",
  "minimalistic-crypto-utils": "^1.0.1"
}, require$$0$1 = {
  name: name$1,
  version: version$1,
  description: description$1,
  main: main$1,
  files,
  scripts: scripts$1,
  repository: repository$1,
  keywords: keywords$1,
  author: author$1,
  license: license$1,
  bugs: bugs$1,
  homepage: homepage$1,
  devDependencies: devDependencies$1,
  dependencies: dependencies$1
};
var utils$v = {}, bn$3 = { exports: {} };
bn$3.exports;
(function(a) {
  (function(u, c) {
    function l(P, S) {
      if (!P)
        throw new Error(S || "Assertion failed");
    }
    function v(P, S) {
      P.super_ = S;
      var E = function() {
      };
      E.prototype = S.prototype, P.prototype = new E(), P.prototype.constructor = P;
    }
    function p(P, S, E) {
      if (p.isBN(P))
        return P;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, P !== null && ((S === "le" || S === "be") && (E = S, S = 10), this._init(P || 0, S || 10, E || "be"));
    }
    typeof u == "object" ? u.exports = p : c.BN = p, p.BN = p, p.wordSize = 26;
    var _;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? _ = window.Buffer : _ = require$$0$2.Buffer;
    } catch {
    }
    p.isBN = function(S) {
      return S instanceof p ? !0 : S !== null && typeof S == "object" && S.constructor.wordSize === p.wordSize && Array.isArray(S.words);
    }, p.max = function(S, E) {
      return S.cmp(E) > 0 ? S : E;
    }, p.min = function(S, E) {
      return S.cmp(E) < 0 ? S : E;
    }, p.prototype._init = function(S, E, I) {
      if (typeof S == "number")
        return this._initNumber(S, E, I);
      if (typeof S == "object")
        return this._initArray(S, E, I);
      E === "hex" && (E = 16), l(E === (E | 0) && E >= 2 && E <= 36), S = S.toString().replace(/\s+/g, "");
      var M = 0;
      S[0] === "-" && (M++, this.negative = 1), M < S.length && (E === 16 ? this._parseHex(S, M, I) : (this._parseBase(S, E, M), I === "le" && this._initArray(this.toArray(), E, I)));
    }, p.prototype._initNumber = function(S, E, I) {
      S < 0 && (this.negative = 1, S = -S), S < 67108864 ? (this.words = [S & 67108863], this.length = 1) : S < 4503599627370496 ? (this.words = [
        S & 67108863,
        S / 67108864 & 67108863
      ], this.length = 2) : (l(S < 9007199254740992), this.words = [
        S & 67108863,
        S / 67108864 & 67108863,
        1
      ], this.length = 3), I === "le" && this._initArray(this.toArray(), E, I);
    }, p.prototype._initArray = function(S, E, I) {
      if (l(typeof S.length == "number"), S.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(S.length / 3), this.words = new Array(this.length);
      for (var M = 0; M < this.length; M++)
        this.words[M] = 0;
      var $, U, Y = 0;
      if (I === "be")
        for (M = S.length - 1, $ = 0; M >= 0; M -= 3)
          U = S[M] | S[M - 1] << 8 | S[M - 2] << 16, this.words[$] |= U << Y & 67108863, this.words[$ + 1] = U >>> 26 - Y & 67108863, Y += 24, Y >= 26 && (Y -= 26, $++);
      else if (I === "le")
        for (M = 0, $ = 0; M < S.length; M += 3)
          U = S[M] | S[M + 1] << 8 | S[M + 2] << 16, this.words[$] |= U << Y & 67108863, this.words[$ + 1] = U >>> 26 - Y & 67108863, Y += 24, Y >= 26 && (Y -= 26, $++);
      return this.strip();
    };
    function k(P, S) {
      var E = P.charCodeAt(S);
      return E >= 65 && E <= 70 ? E - 55 : E >= 97 && E <= 102 ? E - 87 : E - 48 & 15;
    }
    function O(P, S, E) {
      var I = k(P, E);
      return E - 1 >= S && (I |= k(P, E - 1) << 4), I;
    }
    p.prototype._parseHex = function(S, E, I) {
      this.length = Math.ceil((S.length - E) / 6), this.words = new Array(this.length);
      for (var M = 0; M < this.length; M++)
        this.words[M] = 0;
      var $ = 0, U = 0, Y;
      if (I === "be")
        for (M = S.length - 1; M >= E; M -= 2)
          Y = O(S, E, M) << $, this.words[U] |= Y & 67108863, $ >= 18 ? ($ -= 18, U += 1, this.words[U] |= Y >>> 26) : $ += 8;
      else {
        var B = S.length - E;
        for (M = B % 2 === 0 ? E + 1 : E; M < S.length; M += 2)
          Y = O(S, E, M) << $, this.words[U] |= Y & 67108863, $ >= 18 ? ($ -= 18, U += 1, this.words[U] |= Y >>> 26) : $ += 8;
      }
      this.strip();
    };
    function D(P, S, E, I) {
      for (var M = 0, $ = Math.min(P.length, E), U = S; U < $; U++) {
        var Y = P.charCodeAt(U) - 48;
        M *= I, Y >= 49 ? M += Y - 49 + 10 : Y >= 17 ? M += Y - 17 + 10 : M += Y;
      }
      return M;
    }
    p.prototype._parseBase = function(S, E, I) {
      this.words = [0], this.length = 1;
      for (var M = 0, $ = 1; $ <= 67108863; $ *= E)
        M++;
      M--, $ = $ / E | 0;
      for (var U = S.length - I, Y = U % M, B = Math.min(U, U - Y) + I, T = 0, L = I; L < B; L += M)
        T = D(S, L, L + M, E), this.imuln($), this.words[0] + T < 67108864 ? this.words[0] += T : this._iaddn(T);
      if (Y !== 0) {
        var te = 1;
        for (T = D(S, L, S.length, E), L = 0; L < Y; L++)
          te *= E;
        this.imuln(te), this.words[0] + T < 67108864 ? this.words[0] += T : this._iaddn(T);
      }
      this.strip();
    }, p.prototype.copy = function(S) {
      S.words = new Array(this.length);
      for (var E = 0; E < this.length; E++)
        S.words[E] = this.words[E];
      S.length = this.length, S.negative = this.negative, S.red = this.red;
    }, p.prototype.clone = function() {
      var S = new p(null);
      return this.copy(S), S;
    }, p.prototype._expand = function(S) {
      for (; this.length < S; )
        this.words[this.length++] = 0;
      return this;
    }, p.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, p.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, p.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var F = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], H = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], Z = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    p.prototype.toString = function(S, E) {
      S = S || 10, E = E | 0 || 1;
      var I;
      if (S === 16 || S === "hex") {
        I = "";
        for (var M = 0, $ = 0, U = 0; U < this.length; U++) {
          var Y = this.words[U], B = ((Y << M | $) & 16777215).toString(16);
          $ = Y >>> 24 - M & 16777215, $ !== 0 || U !== this.length - 1 ? I = F[6 - B.length] + B + I : I = B + I, M += 2, M >= 26 && (M -= 26, U--);
        }
        for ($ !== 0 && (I = $.toString(16) + I); I.length % E !== 0; )
          I = "0" + I;
        return this.negative !== 0 && (I = "-" + I), I;
      }
      if (S === (S | 0) && S >= 2 && S <= 36) {
        var T = H[S], L = Z[S];
        I = "";
        var te = this.clone();
        for (te.negative = 0; !te.isZero(); ) {
          var me = te.modn(L).toString(S);
          te = te.idivn(L), te.isZero() ? I = me + I : I = F[T - me.length] + me + I;
        }
        for (this.isZero() && (I = "0" + I); I.length % E !== 0; )
          I = "0" + I;
        return this.negative !== 0 && (I = "-" + I), I;
      }
      l(!1, "Base should be between 2 and 36");
    }, p.prototype.toNumber = function() {
      var S = this.words[0];
      return this.length === 2 ? S += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? S += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && l(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -S : S;
    }, p.prototype.toJSON = function() {
      return this.toString(16);
    }, p.prototype.toBuffer = function(S, E) {
      return l(typeof _ < "u"), this.toArrayLike(_, S, E);
    }, p.prototype.toArray = function(S, E) {
      return this.toArrayLike(Array, S, E);
    }, p.prototype.toArrayLike = function(S, E, I) {
      var M = this.byteLength(), $ = I || Math.max(1, M);
      l(M <= $, "byte array longer than desired length"), l($ > 0, "Requested array length <= 0"), this.strip();
      var U = E === "le", Y = new S($), B, T, L = this.clone();
      if (U) {
        for (T = 0; !L.isZero(); T++)
          B = L.andln(255), L.iushrn(8), Y[T] = B;
        for (; T < $; T++)
          Y[T] = 0;
      } else {
        for (T = 0; T < $ - M; T++)
          Y[T] = 0;
        for (T = 0; !L.isZero(); T++)
          B = L.andln(255), L.iushrn(8), Y[$ - T - 1] = B;
      }
      return Y;
    }, Math.clz32 ? p.prototype._countBits = function(S) {
      return 32 - Math.clz32(S);
    } : p.prototype._countBits = function(S) {
      var E = S, I = 0;
      return E >= 4096 && (I += 13, E >>>= 13), E >= 64 && (I += 7, E >>>= 7), E >= 8 && (I += 4, E >>>= 4), E >= 2 && (I += 2, E >>>= 2), I + E;
    }, p.prototype._zeroBits = function(S) {
      if (S === 0)
        return 26;
      var E = S, I = 0;
      return E & 8191 || (I += 13, E >>>= 13), E & 127 || (I += 7, E >>>= 7), E & 15 || (I += 4, E >>>= 4), E & 3 || (I += 2, E >>>= 2), E & 1 || I++, I;
    }, p.prototype.bitLength = function() {
      var S = this.words[this.length - 1], E = this._countBits(S);
      return (this.length - 1) * 26 + E;
    };
    function ee(P) {
      for (var S = new Array(P.bitLength()), E = 0; E < S.length; E++) {
        var I = E / 26 | 0, M = E % 26;
        S[E] = (P.words[I] & 1 << M) >>> M;
      }
      return S;
    }
    p.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var S = 0, E = 0; E < this.length; E++) {
        var I = this._zeroBits(this.words[E]);
        if (S += I, I !== 26)
          break;
      }
      return S;
    }, p.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, p.prototype.toTwos = function(S) {
      return this.negative !== 0 ? this.abs().inotn(S).iaddn(1) : this.clone();
    }, p.prototype.fromTwos = function(S) {
      return this.testn(S - 1) ? this.notn(S).iaddn(1).ineg() : this.clone();
    }, p.prototype.isNeg = function() {
      return this.negative !== 0;
    }, p.prototype.neg = function() {
      return this.clone().ineg();
    }, p.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, p.prototype.iuor = function(S) {
      for (; this.length < S.length; )
        this.words[this.length++] = 0;
      for (var E = 0; E < S.length; E++)
        this.words[E] = this.words[E] | S.words[E];
      return this.strip();
    }, p.prototype.ior = function(S) {
      return l((this.negative | S.negative) === 0), this.iuor(S);
    }, p.prototype.or = function(S) {
      return this.length > S.length ? this.clone().ior(S) : S.clone().ior(this);
    }, p.prototype.uor = function(S) {
      return this.length > S.length ? this.clone().iuor(S) : S.clone().iuor(this);
    }, p.prototype.iuand = function(S) {
      var E;
      this.length > S.length ? E = S : E = this;
      for (var I = 0; I < E.length; I++)
        this.words[I] = this.words[I] & S.words[I];
      return this.length = E.length, this.strip();
    }, p.prototype.iand = function(S) {
      return l((this.negative | S.negative) === 0), this.iuand(S);
    }, p.prototype.and = function(S) {
      return this.length > S.length ? this.clone().iand(S) : S.clone().iand(this);
    }, p.prototype.uand = function(S) {
      return this.length > S.length ? this.clone().iuand(S) : S.clone().iuand(this);
    }, p.prototype.iuxor = function(S) {
      var E, I;
      this.length > S.length ? (E = this, I = S) : (E = S, I = this);
      for (var M = 0; M < I.length; M++)
        this.words[M] = E.words[M] ^ I.words[M];
      if (this !== E)
        for (; M < E.length; M++)
          this.words[M] = E.words[M];
      return this.length = E.length, this.strip();
    }, p.prototype.ixor = function(S) {
      return l((this.negative | S.negative) === 0), this.iuxor(S);
    }, p.prototype.xor = function(S) {
      return this.length > S.length ? this.clone().ixor(S) : S.clone().ixor(this);
    }, p.prototype.uxor = function(S) {
      return this.length > S.length ? this.clone().iuxor(S) : S.clone().iuxor(this);
    }, p.prototype.inotn = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = Math.ceil(S / 26) | 0, I = S % 26;
      this._expand(E), I > 0 && E--;
      for (var M = 0; M < E; M++)
        this.words[M] = ~this.words[M] & 67108863;
      return I > 0 && (this.words[M] = ~this.words[M] & 67108863 >> 26 - I), this.strip();
    }, p.prototype.notn = function(S) {
      return this.clone().inotn(S);
    }, p.prototype.setn = function(S, E) {
      l(typeof S == "number" && S >= 0);
      var I = S / 26 | 0, M = S % 26;
      return this._expand(I + 1), E ? this.words[I] = this.words[I] | 1 << M : this.words[I] = this.words[I] & ~(1 << M), this.strip();
    }, p.prototype.iadd = function(S) {
      var E;
      if (this.negative !== 0 && S.negative === 0)
        return this.negative = 0, E = this.isub(S), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && S.negative !== 0)
        return S.negative = 0, E = this.isub(S), S.negative = 1, E._normSign();
      var I, M;
      this.length > S.length ? (I = this, M = S) : (I = S, M = this);
      for (var $ = 0, U = 0; U < M.length; U++)
        E = (I.words[U] | 0) + (M.words[U] | 0) + $, this.words[U] = E & 67108863, $ = E >>> 26;
      for (; $ !== 0 && U < I.length; U++)
        E = (I.words[U] | 0) + $, this.words[U] = E & 67108863, $ = E >>> 26;
      if (this.length = I.length, $ !== 0)
        this.words[this.length] = $, this.length++;
      else if (I !== this)
        for (; U < I.length; U++)
          this.words[U] = I.words[U];
      return this;
    }, p.prototype.add = function(S) {
      var E;
      return S.negative !== 0 && this.negative === 0 ? (S.negative = 0, E = this.sub(S), S.negative ^= 1, E) : S.negative === 0 && this.negative !== 0 ? (this.negative = 0, E = S.sub(this), this.negative = 1, E) : this.length > S.length ? this.clone().iadd(S) : S.clone().iadd(this);
    }, p.prototype.isub = function(S) {
      if (S.negative !== 0) {
        S.negative = 0;
        var E = this.iadd(S);
        return S.negative = 1, E._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(S), this.negative = 1, this._normSign();
      var I = this.cmp(S);
      if (I === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var M, $;
      I > 0 ? (M = this, $ = S) : (M = S, $ = this);
      for (var U = 0, Y = 0; Y < $.length; Y++)
        E = (M.words[Y] | 0) - ($.words[Y] | 0) + U, U = E >> 26, this.words[Y] = E & 67108863;
      for (; U !== 0 && Y < M.length; Y++)
        E = (M.words[Y] | 0) + U, U = E >> 26, this.words[Y] = E & 67108863;
      if (U === 0 && Y < M.length && M !== this)
        for (; Y < M.length; Y++)
          this.words[Y] = M.words[Y];
      return this.length = Math.max(this.length, Y), M !== this && (this.negative = 1), this.strip();
    }, p.prototype.sub = function(S) {
      return this.clone().isub(S);
    };
    function X(P, S, E) {
      E.negative = S.negative ^ P.negative;
      var I = P.length + S.length | 0;
      E.length = I, I = I - 1 | 0;
      var M = P.words[0] | 0, $ = S.words[0] | 0, U = M * $, Y = U & 67108863, B = U / 67108864 | 0;
      E.words[0] = Y;
      for (var T = 1; T < I; T++) {
        for (var L = B >>> 26, te = B & 67108863, me = Math.min(T, S.length - 1), Ce = Math.max(0, T - P.length + 1); Ce <= me; Ce++) {
          var De = T - Ce | 0;
          M = P.words[De] | 0, $ = S.words[Ce] | 0, U = M * $ + te, L += U / 67108864 | 0, te = U & 67108863;
        }
        E.words[T] = te | 0, B = L | 0;
      }
      return B !== 0 ? E.words[T] = B | 0 : E.length--, E.strip();
    }
    var ne = function(S, E, I) {
      var M = S.words, $ = E.words, U = I.words, Y = 0, B, T, L, te = M[0] | 0, me = te & 8191, Ce = te >>> 13, De = M[1] | 0, ye = De & 8191, pe = De >>> 13, Me = M[2] | 0, Ne = Me & 8191, Ue = Me >>> 13, oe = M[3] | 0, A = oe & 8191, re = oe >>> 13, le = M[4] | 0, $e = le & 8191, Oe = le >>> 13, Fe = M[5] | 0, Ze = Fe & 8191, qe = Fe >>> 13, yt = M[6] | 0, Xe = yt & 8191, Ge = yt >>> 13, J = M[7] | 0, ge = J & 8191, we = J >>> 13, We = M[8] | 0, Ie = We & 8191, V = We >>> 13, Ee = M[9] | 0, de = Ee & 8191, ce = Ee >>> 13, ve = $[0] | 0, Pe = ve & 8191, Be = ve >>> 13, ze = $[1] | 0, Je = ze & 8191, je = ze >>> 13, Ke = $[2] | 0, x = Ke & 8191, se = Ke >>> 13, Se = $[3] | 0, xe = Se & 8191, Ae = Se >>> 13, Ye = $[4] | 0, et = Ye & 8191, dt = Ye >>> 13, St = $[5] | 0, tt = St & 8191, at = St >>> 13, kt = $[6] | 0, rt = kt & 8191, ut = kt >>> 13, wt = $[7] | 0, nt = wt & 8191, it = wt >>> 13, bt = $[8] | 0, ot = bt & 8191, ct = bt >>> 13, Pt = $[9] | 0, st = Pt & 8191, lt = Pt >>> 13;
      I.negative = S.negative ^ E.negative, I.length = 19, B = Math.imul(me, Pe), T = Math.imul(me, Be), T = T + Math.imul(Ce, Pe) | 0, L = Math.imul(Ce, Be);
      var It = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (It >>> 26) | 0, It &= 67108863, B = Math.imul(ye, Pe), T = Math.imul(ye, Be), T = T + Math.imul(pe, Pe) | 0, L = Math.imul(pe, Be), B = B + Math.imul(me, Je) | 0, T = T + Math.imul(me, je) | 0, T = T + Math.imul(Ce, Je) | 0, L = L + Math.imul(Ce, je) | 0;
      var Rt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (Rt >>> 26) | 0, Rt &= 67108863, B = Math.imul(Ne, Pe), T = Math.imul(Ne, Be), T = T + Math.imul(Ue, Pe) | 0, L = Math.imul(Ue, Be), B = B + Math.imul(ye, Je) | 0, T = T + Math.imul(ye, je) | 0, T = T + Math.imul(pe, Je) | 0, L = L + Math.imul(pe, je) | 0, B = B + Math.imul(me, x) | 0, T = T + Math.imul(me, se) | 0, T = T + Math.imul(Ce, x) | 0, L = L + Math.imul(Ce, se) | 0;
      var Ve = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, B = Math.imul(A, Pe), T = Math.imul(A, Be), T = T + Math.imul(re, Pe) | 0, L = Math.imul(re, Be), B = B + Math.imul(Ne, Je) | 0, T = T + Math.imul(Ne, je) | 0, T = T + Math.imul(Ue, Je) | 0, L = L + Math.imul(Ue, je) | 0, B = B + Math.imul(ye, x) | 0, T = T + Math.imul(ye, se) | 0, T = T + Math.imul(pe, x) | 0, L = L + Math.imul(pe, se) | 0, B = B + Math.imul(me, xe) | 0, T = T + Math.imul(me, Ae) | 0, T = T + Math.imul(Ce, xe) | 0, L = L + Math.imul(Ce, Ae) | 0;
      var He = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, B = Math.imul($e, Pe), T = Math.imul($e, Be), T = T + Math.imul(Oe, Pe) | 0, L = Math.imul(Oe, Be), B = B + Math.imul(A, Je) | 0, T = T + Math.imul(A, je) | 0, T = T + Math.imul(re, Je) | 0, L = L + Math.imul(re, je) | 0, B = B + Math.imul(Ne, x) | 0, T = T + Math.imul(Ne, se) | 0, T = T + Math.imul(Ue, x) | 0, L = L + Math.imul(Ue, se) | 0, B = B + Math.imul(ye, xe) | 0, T = T + Math.imul(ye, Ae) | 0, T = T + Math.imul(pe, xe) | 0, L = L + Math.imul(pe, Ae) | 0, B = B + Math.imul(me, et) | 0, T = T + Math.imul(me, dt) | 0, T = T + Math.imul(Ce, et) | 0, L = L + Math.imul(Ce, dt) | 0;
      var Qe = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, B = Math.imul(Ze, Pe), T = Math.imul(Ze, Be), T = T + Math.imul(qe, Pe) | 0, L = Math.imul(qe, Be), B = B + Math.imul($e, Je) | 0, T = T + Math.imul($e, je) | 0, T = T + Math.imul(Oe, Je) | 0, L = L + Math.imul(Oe, je) | 0, B = B + Math.imul(A, x) | 0, T = T + Math.imul(A, se) | 0, T = T + Math.imul(re, x) | 0, L = L + Math.imul(re, se) | 0, B = B + Math.imul(Ne, xe) | 0, T = T + Math.imul(Ne, Ae) | 0, T = T + Math.imul(Ue, xe) | 0, L = L + Math.imul(Ue, Ae) | 0, B = B + Math.imul(ye, et) | 0, T = T + Math.imul(ye, dt) | 0, T = T + Math.imul(pe, et) | 0, L = L + Math.imul(pe, dt) | 0, B = B + Math.imul(me, tt) | 0, T = T + Math.imul(me, at) | 0, T = T + Math.imul(Ce, tt) | 0, L = L + Math.imul(Ce, at) | 0;
      var pt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (pt >>> 26) | 0, pt &= 67108863, B = Math.imul(Xe, Pe), T = Math.imul(Xe, Be), T = T + Math.imul(Ge, Pe) | 0, L = Math.imul(Ge, Be), B = B + Math.imul(Ze, Je) | 0, T = T + Math.imul(Ze, je) | 0, T = T + Math.imul(qe, Je) | 0, L = L + Math.imul(qe, je) | 0, B = B + Math.imul($e, x) | 0, T = T + Math.imul($e, se) | 0, T = T + Math.imul(Oe, x) | 0, L = L + Math.imul(Oe, se) | 0, B = B + Math.imul(A, xe) | 0, T = T + Math.imul(A, Ae) | 0, T = T + Math.imul(re, xe) | 0, L = L + Math.imul(re, Ae) | 0, B = B + Math.imul(Ne, et) | 0, T = T + Math.imul(Ne, dt) | 0, T = T + Math.imul(Ue, et) | 0, L = L + Math.imul(Ue, dt) | 0, B = B + Math.imul(ye, tt) | 0, T = T + Math.imul(ye, at) | 0, T = T + Math.imul(pe, tt) | 0, L = L + Math.imul(pe, at) | 0, B = B + Math.imul(me, rt) | 0, T = T + Math.imul(me, ut) | 0, T = T + Math.imul(Ce, rt) | 0, L = L + Math.imul(Ce, ut) | 0;
      var mt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (mt >>> 26) | 0, mt &= 67108863, B = Math.imul(ge, Pe), T = Math.imul(ge, Be), T = T + Math.imul(we, Pe) | 0, L = Math.imul(we, Be), B = B + Math.imul(Xe, Je) | 0, T = T + Math.imul(Xe, je) | 0, T = T + Math.imul(Ge, Je) | 0, L = L + Math.imul(Ge, je) | 0, B = B + Math.imul(Ze, x) | 0, T = T + Math.imul(Ze, se) | 0, T = T + Math.imul(qe, x) | 0, L = L + Math.imul(qe, se) | 0, B = B + Math.imul($e, xe) | 0, T = T + Math.imul($e, Ae) | 0, T = T + Math.imul(Oe, xe) | 0, L = L + Math.imul(Oe, Ae) | 0, B = B + Math.imul(A, et) | 0, T = T + Math.imul(A, dt) | 0, T = T + Math.imul(re, et) | 0, L = L + Math.imul(re, dt) | 0, B = B + Math.imul(Ne, tt) | 0, T = T + Math.imul(Ne, at) | 0, T = T + Math.imul(Ue, tt) | 0, L = L + Math.imul(Ue, at) | 0, B = B + Math.imul(ye, rt) | 0, T = T + Math.imul(ye, ut) | 0, T = T + Math.imul(pe, rt) | 0, L = L + Math.imul(pe, ut) | 0, B = B + Math.imul(me, nt) | 0, T = T + Math.imul(me, it) | 0, T = T + Math.imul(Ce, nt) | 0, L = L + Math.imul(Ce, it) | 0;
      var vt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, B = Math.imul(Ie, Pe), T = Math.imul(Ie, Be), T = T + Math.imul(V, Pe) | 0, L = Math.imul(V, Be), B = B + Math.imul(ge, Je) | 0, T = T + Math.imul(ge, je) | 0, T = T + Math.imul(we, Je) | 0, L = L + Math.imul(we, je) | 0, B = B + Math.imul(Xe, x) | 0, T = T + Math.imul(Xe, se) | 0, T = T + Math.imul(Ge, x) | 0, L = L + Math.imul(Ge, se) | 0, B = B + Math.imul(Ze, xe) | 0, T = T + Math.imul(Ze, Ae) | 0, T = T + Math.imul(qe, xe) | 0, L = L + Math.imul(qe, Ae) | 0, B = B + Math.imul($e, et) | 0, T = T + Math.imul($e, dt) | 0, T = T + Math.imul(Oe, et) | 0, L = L + Math.imul(Oe, dt) | 0, B = B + Math.imul(A, tt) | 0, T = T + Math.imul(A, at) | 0, T = T + Math.imul(re, tt) | 0, L = L + Math.imul(re, at) | 0, B = B + Math.imul(Ne, rt) | 0, T = T + Math.imul(Ne, ut) | 0, T = T + Math.imul(Ue, rt) | 0, L = L + Math.imul(Ue, ut) | 0, B = B + Math.imul(ye, nt) | 0, T = T + Math.imul(ye, it) | 0, T = T + Math.imul(pe, nt) | 0, L = L + Math.imul(pe, it) | 0, B = B + Math.imul(me, ot) | 0, T = T + Math.imul(me, ct) | 0, T = T + Math.imul(Ce, ot) | 0, L = L + Math.imul(Ce, ct) | 0;
      var ht = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (ht >>> 26) | 0, ht &= 67108863, B = Math.imul(de, Pe), T = Math.imul(de, Be), T = T + Math.imul(ce, Pe) | 0, L = Math.imul(ce, Be), B = B + Math.imul(Ie, Je) | 0, T = T + Math.imul(Ie, je) | 0, T = T + Math.imul(V, Je) | 0, L = L + Math.imul(V, je) | 0, B = B + Math.imul(ge, x) | 0, T = T + Math.imul(ge, se) | 0, T = T + Math.imul(we, x) | 0, L = L + Math.imul(we, se) | 0, B = B + Math.imul(Xe, xe) | 0, T = T + Math.imul(Xe, Ae) | 0, T = T + Math.imul(Ge, xe) | 0, L = L + Math.imul(Ge, Ae) | 0, B = B + Math.imul(Ze, et) | 0, T = T + Math.imul(Ze, dt) | 0, T = T + Math.imul(qe, et) | 0, L = L + Math.imul(qe, dt) | 0, B = B + Math.imul($e, tt) | 0, T = T + Math.imul($e, at) | 0, T = T + Math.imul(Oe, tt) | 0, L = L + Math.imul(Oe, at) | 0, B = B + Math.imul(A, rt) | 0, T = T + Math.imul(A, ut) | 0, T = T + Math.imul(re, rt) | 0, L = L + Math.imul(re, ut) | 0, B = B + Math.imul(Ne, nt) | 0, T = T + Math.imul(Ne, it) | 0, T = T + Math.imul(Ue, nt) | 0, L = L + Math.imul(Ue, it) | 0, B = B + Math.imul(ye, ot) | 0, T = T + Math.imul(ye, ct) | 0, T = T + Math.imul(pe, ot) | 0, L = L + Math.imul(pe, ct) | 0, B = B + Math.imul(me, st) | 0, T = T + Math.imul(me, lt) | 0, T = T + Math.imul(Ce, st) | 0, L = L + Math.imul(Ce, lt) | 0;
      var Et = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, B = Math.imul(de, Je), T = Math.imul(de, je), T = T + Math.imul(ce, Je) | 0, L = Math.imul(ce, je), B = B + Math.imul(Ie, x) | 0, T = T + Math.imul(Ie, se) | 0, T = T + Math.imul(V, x) | 0, L = L + Math.imul(V, se) | 0, B = B + Math.imul(ge, xe) | 0, T = T + Math.imul(ge, Ae) | 0, T = T + Math.imul(we, xe) | 0, L = L + Math.imul(we, Ae) | 0, B = B + Math.imul(Xe, et) | 0, T = T + Math.imul(Xe, dt) | 0, T = T + Math.imul(Ge, et) | 0, L = L + Math.imul(Ge, dt) | 0, B = B + Math.imul(Ze, tt) | 0, T = T + Math.imul(Ze, at) | 0, T = T + Math.imul(qe, tt) | 0, L = L + Math.imul(qe, at) | 0, B = B + Math.imul($e, rt) | 0, T = T + Math.imul($e, ut) | 0, T = T + Math.imul(Oe, rt) | 0, L = L + Math.imul(Oe, ut) | 0, B = B + Math.imul(A, nt) | 0, T = T + Math.imul(A, it) | 0, T = T + Math.imul(re, nt) | 0, L = L + Math.imul(re, it) | 0, B = B + Math.imul(Ne, ot) | 0, T = T + Math.imul(Ne, ct) | 0, T = T + Math.imul(Ue, ot) | 0, L = L + Math.imul(Ue, ct) | 0, B = B + Math.imul(ye, st) | 0, T = T + Math.imul(ye, lt) | 0, T = T + Math.imul(pe, st) | 0, L = L + Math.imul(pe, lt) | 0;
      var Tt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (Tt >>> 26) | 0, Tt &= 67108863, B = Math.imul(de, x), T = Math.imul(de, se), T = T + Math.imul(ce, x) | 0, L = Math.imul(ce, se), B = B + Math.imul(Ie, xe) | 0, T = T + Math.imul(Ie, Ae) | 0, T = T + Math.imul(V, xe) | 0, L = L + Math.imul(V, Ae) | 0, B = B + Math.imul(ge, et) | 0, T = T + Math.imul(ge, dt) | 0, T = T + Math.imul(we, et) | 0, L = L + Math.imul(we, dt) | 0, B = B + Math.imul(Xe, tt) | 0, T = T + Math.imul(Xe, at) | 0, T = T + Math.imul(Ge, tt) | 0, L = L + Math.imul(Ge, at) | 0, B = B + Math.imul(Ze, rt) | 0, T = T + Math.imul(Ze, ut) | 0, T = T + Math.imul(qe, rt) | 0, L = L + Math.imul(qe, ut) | 0, B = B + Math.imul($e, nt) | 0, T = T + Math.imul($e, it) | 0, T = T + Math.imul(Oe, nt) | 0, L = L + Math.imul(Oe, it) | 0, B = B + Math.imul(A, ot) | 0, T = T + Math.imul(A, ct) | 0, T = T + Math.imul(re, ot) | 0, L = L + Math.imul(re, ct) | 0, B = B + Math.imul(Ne, st) | 0, T = T + Math.imul(Ne, lt) | 0, T = T + Math.imul(Ue, st) | 0, L = L + Math.imul(Ue, lt) | 0;
      var Ot = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (Ot >>> 26) | 0, Ot &= 67108863, B = Math.imul(de, xe), T = Math.imul(de, Ae), T = T + Math.imul(ce, xe) | 0, L = Math.imul(ce, Ae), B = B + Math.imul(Ie, et) | 0, T = T + Math.imul(Ie, dt) | 0, T = T + Math.imul(V, et) | 0, L = L + Math.imul(V, dt) | 0, B = B + Math.imul(ge, tt) | 0, T = T + Math.imul(ge, at) | 0, T = T + Math.imul(we, tt) | 0, L = L + Math.imul(we, at) | 0, B = B + Math.imul(Xe, rt) | 0, T = T + Math.imul(Xe, ut) | 0, T = T + Math.imul(Ge, rt) | 0, L = L + Math.imul(Ge, ut) | 0, B = B + Math.imul(Ze, nt) | 0, T = T + Math.imul(Ze, it) | 0, T = T + Math.imul(qe, nt) | 0, L = L + Math.imul(qe, it) | 0, B = B + Math.imul($e, ot) | 0, T = T + Math.imul($e, ct) | 0, T = T + Math.imul(Oe, ot) | 0, L = L + Math.imul(Oe, ct) | 0, B = B + Math.imul(A, st) | 0, T = T + Math.imul(A, lt) | 0, T = T + Math.imul(re, st) | 0, L = L + Math.imul(re, lt) | 0;
      var Nt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, B = Math.imul(de, et), T = Math.imul(de, dt), T = T + Math.imul(ce, et) | 0, L = Math.imul(ce, dt), B = B + Math.imul(Ie, tt) | 0, T = T + Math.imul(Ie, at) | 0, T = T + Math.imul(V, tt) | 0, L = L + Math.imul(V, at) | 0, B = B + Math.imul(ge, rt) | 0, T = T + Math.imul(ge, ut) | 0, T = T + Math.imul(we, rt) | 0, L = L + Math.imul(we, ut) | 0, B = B + Math.imul(Xe, nt) | 0, T = T + Math.imul(Xe, it) | 0, T = T + Math.imul(Ge, nt) | 0, L = L + Math.imul(Ge, it) | 0, B = B + Math.imul(Ze, ot) | 0, T = T + Math.imul(Ze, ct) | 0, T = T + Math.imul(qe, ot) | 0, L = L + Math.imul(qe, ct) | 0, B = B + Math.imul($e, st) | 0, T = T + Math.imul($e, lt) | 0, T = T + Math.imul(Oe, st) | 0, L = L + Math.imul(Oe, lt) | 0;
      var At = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, B = Math.imul(de, tt), T = Math.imul(de, at), T = T + Math.imul(ce, tt) | 0, L = Math.imul(ce, at), B = B + Math.imul(Ie, rt) | 0, T = T + Math.imul(Ie, ut) | 0, T = T + Math.imul(V, rt) | 0, L = L + Math.imul(V, ut) | 0, B = B + Math.imul(ge, nt) | 0, T = T + Math.imul(ge, it) | 0, T = T + Math.imul(we, nt) | 0, L = L + Math.imul(we, it) | 0, B = B + Math.imul(Xe, ot) | 0, T = T + Math.imul(Xe, ct) | 0, T = T + Math.imul(Ge, ot) | 0, L = L + Math.imul(Ge, ct) | 0, B = B + Math.imul(Ze, st) | 0, T = T + Math.imul(Ze, lt) | 0, T = T + Math.imul(qe, st) | 0, L = L + Math.imul(qe, lt) | 0;
      var Mt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (Mt >>> 26) | 0, Mt &= 67108863, B = Math.imul(de, rt), T = Math.imul(de, ut), T = T + Math.imul(ce, rt) | 0, L = Math.imul(ce, ut), B = B + Math.imul(Ie, nt) | 0, T = T + Math.imul(Ie, it) | 0, T = T + Math.imul(V, nt) | 0, L = L + Math.imul(V, it) | 0, B = B + Math.imul(ge, ot) | 0, T = T + Math.imul(ge, ct) | 0, T = T + Math.imul(we, ot) | 0, L = L + Math.imul(we, ct) | 0, B = B + Math.imul(Xe, st) | 0, T = T + Math.imul(Xe, lt) | 0, T = T + Math.imul(Ge, st) | 0, L = L + Math.imul(Ge, lt) | 0;
      var $t = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + ($t >>> 26) | 0, $t &= 67108863, B = Math.imul(de, nt), T = Math.imul(de, it), T = T + Math.imul(ce, nt) | 0, L = Math.imul(ce, it), B = B + Math.imul(Ie, ot) | 0, T = T + Math.imul(Ie, ct) | 0, T = T + Math.imul(V, ot) | 0, L = L + Math.imul(V, ct) | 0, B = B + Math.imul(ge, st) | 0, T = T + Math.imul(ge, lt) | 0, T = T + Math.imul(we, st) | 0, L = L + Math.imul(we, lt) | 0;
      var Bt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, B = Math.imul(de, ot), T = Math.imul(de, ct), T = T + Math.imul(ce, ot) | 0, L = Math.imul(ce, ct), B = B + Math.imul(Ie, st) | 0, T = T + Math.imul(Ie, lt) | 0, T = T + Math.imul(V, st) | 0, L = L + Math.imul(V, lt) | 0;
      var Ut = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (Ut >>> 26) | 0, Ut &= 67108863, B = Math.imul(de, st), T = Math.imul(de, lt), T = T + Math.imul(ce, st) | 0, L = Math.imul(ce, lt);
      var xt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      return Y = (L + (T >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, U[0] = It, U[1] = Rt, U[2] = Ve, U[3] = He, U[4] = Qe, U[5] = pt, U[6] = mt, U[7] = vt, U[8] = ht, U[9] = Et, U[10] = Tt, U[11] = Ot, U[12] = Nt, U[13] = At, U[14] = Mt, U[15] = $t, U[16] = Bt, U[17] = Ut, U[18] = xt, Y !== 0 && (U[19] = Y, I.length++), I;
    };
    Math.imul || (ne = X);
    function Q(P, S, E) {
      E.negative = S.negative ^ P.negative, E.length = P.length + S.length;
      for (var I = 0, M = 0, $ = 0; $ < E.length - 1; $++) {
        var U = M;
        M = 0;
        for (var Y = I & 67108863, B = Math.min($, S.length - 1), T = Math.max(0, $ - P.length + 1); T <= B; T++) {
          var L = $ - T, te = P.words[L] | 0, me = S.words[T] | 0, Ce = te * me, De = Ce & 67108863;
          U = U + (Ce / 67108864 | 0) | 0, De = De + Y | 0, Y = De & 67108863, U = U + (De >>> 26) | 0, M += U >>> 26, U &= 67108863;
        }
        E.words[$] = Y, I = U, U = M;
      }
      return I !== 0 ? E.words[$] = I : E.length--, E.strip();
    }
    function ae(P, S, E) {
      var I = new j();
      return I.mulp(P, S, E);
    }
    p.prototype.mulTo = function(S, E) {
      var I, M = this.length + S.length;
      return this.length === 10 && S.length === 10 ? I = ne(this, S, E) : M < 63 ? I = X(this, S, E) : M < 1024 ? I = Q(this, S, E) : I = ae(this, S, E), I;
    };
    function j(P, S) {
      this.x = P, this.y = S;
    }
    j.prototype.makeRBT = function(S) {
      for (var E = new Array(S), I = p.prototype._countBits(S) - 1, M = 0; M < S; M++)
        E[M] = this.revBin(M, I, S);
      return E;
    }, j.prototype.revBin = function(S, E, I) {
      if (S === 0 || S === I - 1)
        return S;
      for (var M = 0, $ = 0; $ < E; $++)
        M |= (S & 1) << E - $ - 1, S >>= 1;
      return M;
    }, j.prototype.permute = function(S, E, I, M, $, U) {
      for (var Y = 0; Y < U; Y++)
        M[Y] = E[S[Y]], $[Y] = I[S[Y]];
    }, j.prototype.transform = function(S, E, I, M, $, U) {
      this.permute(U, S, E, I, M, $);
      for (var Y = 1; Y < $; Y <<= 1)
        for (var B = Y << 1, T = Math.cos(2 * Math.PI / B), L = Math.sin(2 * Math.PI / B), te = 0; te < $; te += B)
          for (var me = T, Ce = L, De = 0; De < Y; De++) {
            var ye = I[te + De], pe = M[te + De], Me = I[te + De + Y], Ne = M[te + De + Y], Ue = me * Me - Ce * Ne;
            Ne = me * Ne + Ce * Me, Me = Ue, I[te + De] = ye + Me, M[te + De] = pe + Ne, I[te + De + Y] = ye - Me, M[te + De + Y] = pe - Ne, De !== B && (Ue = T * me - L * Ce, Ce = T * Ce + L * me, me = Ue);
          }
    }, j.prototype.guessLen13b = function(S, E) {
      var I = Math.max(E, S) | 1, M = I & 1, $ = 0;
      for (I = I / 2 | 0; I; I = I >>> 1)
        $++;
      return 1 << $ + 1 + M;
    }, j.prototype.conjugate = function(S, E, I) {
      if (!(I <= 1))
        for (var M = 0; M < I / 2; M++) {
          var $ = S[M];
          S[M] = S[I - M - 1], S[I - M - 1] = $, $ = E[M], E[M] = -E[I - M - 1], E[I - M - 1] = -$;
        }
    }, j.prototype.normalize13b = function(S, E) {
      for (var I = 0, M = 0; M < E / 2; M++) {
        var $ = Math.round(S[2 * M + 1] / E) * 8192 + Math.round(S[2 * M] / E) + I;
        S[M] = $ & 67108863, $ < 67108864 ? I = 0 : I = $ / 67108864 | 0;
      }
      return S;
    }, j.prototype.convert13b = function(S, E, I, M) {
      for (var $ = 0, U = 0; U < E; U++)
        $ = $ + (S[U] | 0), I[2 * U] = $ & 8191, $ = $ >>> 13, I[2 * U + 1] = $ & 8191, $ = $ >>> 13;
      for (U = 2 * E; U < M; ++U)
        I[U] = 0;
      l($ === 0), l(($ & -8192) === 0);
    }, j.prototype.stub = function(S) {
      for (var E = new Array(S), I = 0; I < S; I++)
        E[I] = 0;
      return E;
    }, j.prototype.mulp = function(S, E, I) {
      var M = 2 * this.guessLen13b(S.length, E.length), $ = this.makeRBT(M), U = this.stub(M), Y = new Array(M), B = new Array(M), T = new Array(M), L = new Array(M), te = new Array(M), me = new Array(M), Ce = I.words;
      Ce.length = M, this.convert13b(S.words, S.length, Y, M), this.convert13b(E.words, E.length, L, M), this.transform(Y, U, B, T, M, $), this.transform(L, U, te, me, M, $);
      for (var De = 0; De < M; De++) {
        var ye = B[De] * te[De] - T[De] * me[De];
        T[De] = B[De] * me[De] + T[De] * te[De], B[De] = ye;
      }
      return this.conjugate(B, T, M), this.transform(B, T, Ce, U, M, $), this.conjugate(Ce, U, M), this.normalize13b(Ce, M), I.negative = S.negative ^ E.negative, I.length = S.length + E.length, I.strip();
    }, p.prototype.mul = function(S) {
      var E = new p(null);
      return E.words = new Array(this.length + S.length), this.mulTo(S, E);
    }, p.prototype.mulf = function(S) {
      var E = new p(null);
      return E.words = new Array(this.length + S.length), ae(this, S, E);
    }, p.prototype.imul = function(S) {
      return this.clone().mulTo(S, this);
    }, p.prototype.imuln = function(S) {
      l(typeof S == "number"), l(S < 67108864);
      for (var E = 0, I = 0; I < this.length; I++) {
        var M = (this.words[I] | 0) * S, $ = (M & 67108863) + (E & 67108863);
        E >>= 26, E += M / 67108864 | 0, E += $ >>> 26, this.words[I] = $ & 67108863;
      }
      return E !== 0 && (this.words[I] = E, this.length++), this;
    }, p.prototype.muln = function(S) {
      return this.clone().imuln(S);
    }, p.prototype.sqr = function() {
      return this.mul(this);
    }, p.prototype.isqr = function() {
      return this.imul(this.clone());
    }, p.prototype.pow = function(S) {
      var E = ee(S);
      if (E.length === 0)
        return new p(1);
      for (var I = this, M = 0; M < E.length && E[M] === 0; M++, I = I.sqr())
        ;
      if (++M < E.length)
        for (var $ = I.sqr(); M < E.length; M++, $ = $.sqr())
          E[M] !== 0 && (I = I.mul($));
      return I;
    }, p.prototype.iushln = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = S % 26, I = (S - E) / 26, M = 67108863 >>> 26 - E << 26 - E, $;
      if (E !== 0) {
        var U = 0;
        for ($ = 0; $ < this.length; $++) {
          var Y = this.words[$] & M, B = (this.words[$] | 0) - Y << E;
          this.words[$] = B | U, U = Y >>> 26 - E;
        }
        U && (this.words[$] = U, this.length++);
      }
      if (I !== 0) {
        for ($ = this.length - 1; $ >= 0; $--)
          this.words[$ + I] = this.words[$];
        for ($ = 0; $ < I; $++)
          this.words[$] = 0;
        this.length += I;
      }
      return this.strip();
    }, p.prototype.ishln = function(S) {
      return l(this.negative === 0), this.iushln(S);
    }, p.prototype.iushrn = function(S, E, I) {
      l(typeof S == "number" && S >= 0);
      var M;
      E ? M = (E - E % 26) / 26 : M = 0;
      var $ = S % 26, U = Math.min((S - $) / 26, this.length), Y = 67108863 ^ 67108863 >>> $ << $, B = I;
      if (M -= U, M = Math.max(0, M), B) {
        for (var T = 0; T < U; T++)
          B.words[T] = this.words[T];
        B.length = U;
      }
      if (U !== 0)
        if (this.length > U)
          for (this.length -= U, T = 0; T < this.length; T++)
            this.words[T] = this.words[T + U];
        else
          this.words[0] = 0, this.length = 1;
      var L = 0;
      for (T = this.length - 1; T >= 0 && (L !== 0 || T >= M); T--) {
        var te = this.words[T] | 0;
        this.words[T] = L << 26 - $ | te >>> $, L = te & Y;
      }
      return B && L !== 0 && (B.words[B.length++] = L), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, p.prototype.ishrn = function(S, E, I) {
      return l(this.negative === 0), this.iushrn(S, E, I);
    }, p.prototype.shln = function(S) {
      return this.clone().ishln(S);
    }, p.prototype.ushln = function(S) {
      return this.clone().iushln(S);
    }, p.prototype.shrn = function(S) {
      return this.clone().ishrn(S);
    }, p.prototype.ushrn = function(S) {
      return this.clone().iushrn(S);
    }, p.prototype.testn = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = S % 26, I = (S - E) / 26, M = 1 << E;
      if (this.length <= I)
        return !1;
      var $ = this.words[I];
      return !!($ & M);
    }, p.prototype.imaskn = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = S % 26, I = (S - E) / 26;
      if (l(this.negative === 0, "imaskn works only with positive numbers"), this.length <= I)
        return this;
      if (E !== 0 && I++, this.length = Math.min(I, this.length), E !== 0) {
        var M = 67108863 ^ 67108863 >>> E << E;
        this.words[this.length - 1] &= M;
      }
      return this.strip();
    }, p.prototype.maskn = function(S) {
      return this.clone().imaskn(S);
    }, p.prototype.iaddn = function(S) {
      return l(typeof S == "number"), l(S < 67108864), S < 0 ? this.isubn(-S) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < S ? (this.words[0] = S - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(S), this.negative = 1, this) : this._iaddn(S);
    }, p.prototype._iaddn = function(S) {
      this.words[0] += S;
      for (var E = 0; E < this.length && this.words[E] >= 67108864; E++)
        this.words[E] -= 67108864, E === this.length - 1 ? this.words[E + 1] = 1 : this.words[E + 1]++;
      return this.length = Math.max(this.length, E + 1), this;
    }, p.prototype.isubn = function(S) {
      if (l(typeof S == "number"), l(S < 67108864), S < 0)
        return this.iaddn(-S);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(S), this.negative = 1, this;
      if (this.words[0] -= S, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var E = 0; E < this.length && this.words[E] < 0; E++)
          this.words[E] += 67108864, this.words[E + 1] -= 1;
      return this.strip();
    }, p.prototype.addn = function(S) {
      return this.clone().iaddn(S);
    }, p.prototype.subn = function(S) {
      return this.clone().isubn(S);
    }, p.prototype.iabs = function() {
      return this.negative = 0, this;
    }, p.prototype.abs = function() {
      return this.clone().iabs();
    }, p.prototype._ishlnsubmul = function(S, E, I) {
      var M = S.length + I, $;
      this._expand(M);
      var U, Y = 0;
      for ($ = 0; $ < S.length; $++) {
        U = (this.words[$ + I] | 0) + Y;
        var B = (S.words[$] | 0) * E;
        U -= B & 67108863, Y = (U >> 26) - (B / 67108864 | 0), this.words[$ + I] = U & 67108863;
      }
      for (; $ < this.length - I; $++)
        U = (this.words[$ + I] | 0) + Y, Y = U >> 26, this.words[$ + I] = U & 67108863;
      if (Y === 0)
        return this.strip();
      for (l(Y === -1), Y = 0, $ = 0; $ < this.length; $++)
        U = -(this.words[$] | 0) + Y, Y = U >> 26, this.words[$] = U & 67108863;
      return this.negative = 1, this.strip();
    }, p.prototype._wordDiv = function(S, E) {
      var I = this.length - S.length, M = this.clone(), $ = S, U = $.words[$.length - 1] | 0, Y = this._countBits(U);
      I = 26 - Y, I !== 0 && ($ = $.ushln(I), M.iushln(I), U = $.words[$.length - 1] | 0);
      var B = M.length - $.length, T;
      if (E !== "mod") {
        T = new p(null), T.length = B + 1, T.words = new Array(T.length);
        for (var L = 0; L < T.length; L++)
          T.words[L] = 0;
      }
      var te = M.clone()._ishlnsubmul($, 1, B);
      te.negative === 0 && (M = te, T && (T.words[B] = 1));
      for (var me = B - 1; me >= 0; me--) {
        var Ce = (M.words[$.length + me] | 0) * 67108864 + (M.words[$.length + me - 1] | 0);
        for (Ce = Math.min(Ce / U | 0, 67108863), M._ishlnsubmul($, Ce, me); M.negative !== 0; )
          Ce--, M.negative = 0, M._ishlnsubmul($, 1, me), M.isZero() || (M.negative ^= 1);
        T && (T.words[me] = Ce);
      }
      return T && T.strip(), M.strip(), E !== "div" && I !== 0 && M.iushrn(I), {
        div: T || null,
        mod: M
      };
    }, p.prototype.divmod = function(S, E, I) {
      if (l(!S.isZero()), this.isZero())
        return {
          div: new p(0),
          mod: new p(0)
        };
      var M, $, U;
      return this.negative !== 0 && S.negative === 0 ? (U = this.neg().divmod(S, E), E !== "mod" && (M = U.div.neg()), E !== "div" && ($ = U.mod.neg(), I && $.negative !== 0 && $.iadd(S)), {
        div: M,
        mod: $
      }) : this.negative === 0 && S.negative !== 0 ? (U = this.divmod(S.neg(), E), E !== "mod" && (M = U.div.neg()), {
        div: M,
        mod: U.mod
      }) : this.negative & S.negative ? (U = this.neg().divmod(S.neg(), E), E !== "div" && ($ = U.mod.neg(), I && $.negative !== 0 && $.isub(S)), {
        div: U.div,
        mod: $
      }) : S.length > this.length || this.cmp(S) < 0 ? {
        div: new p(0),
        mod: this
      } : S.length === 1 ? E === "div" ? {
        div: this.divn(S.words[0]),
        mod: null
      } : E === "mod" ? {
        div: null,
        mod: new p(this.modn(S.words[0]))
      } : {
        div: this.divn(S.words[0]),
        mod: new p(this.modn(S.words[0]))
      } : this._wordDiv(S, E);
    }, p.prototype.div = function(S) {
      return this.divmod(S, "div", !1).div;
    }, p.prototype.mod = function(S) {
      return this.divmod(S, "mod", !1).mod;
    }, p.prototype.umod = function(S) {
      return this.divmod(S, "mod", !0).mod;
    }, p.prototype.divRound = function(S) {
      var E = this.divmod(S);
      if (E.mod.isZero())
        return E.div;
      var I = E.div.negative !== 0 ? E.mod.isub(S) : E.mod, M = S.ushrn(1), $ = S.andln(1), U = I.cmp(M);
      return U < 0 || $ === 1 && U === 0 ? E.div : E.div.negative !== 0 ? E.div.isubn(1) : E.div.iaddn(1);
    }, p.prototype.modn = function(S) {
      l(S <= 67108863);
      for (var E = (1 << 26) % S, I = 0, M = this.length - 1; M >= 0; M--)
        I = (E * I + (this.words[M] | 0)) % S;
      return I;
    }, p.prototype.idivn = function(S) {
      l(S <= 67108863);
      for (var E = 0, I = this.length - 1; I >= 0; I--) {
        var M = (this.words[I] | 0) + E * 67108864;
        this.words[I] = M / S | 0, E = M % S;
      }
      return this.strip();
    }, p.prototype.divn = function(S) {
      return this.clone().idivn(S);
    }, p.prototype.egcd = function(S) {
      l(S.negative === 0), l(!S.isZero());
      var E = this, I = S.clone();
      E.negative !== 0 ? E = E.umod(S) : E = E.clone();
      for (var M = new p(1), $ = new p(0), U = new p(0), Y = new p(1), B = 0; E.isEven() && I.isEven(); )
        E.iushrn(1), I.iushrn(1), ++B;
      for (var T = I.clone(), L = E.clone(); !E.isZero(); ) {
        for (var te = 0, me = 1; !(E.words[0] & me) && te < 26; ++te, me <<= 1)
          ;
        if (te > 0)
          for (E.iushrn(te); te-- > 0; )
            (M.isOdd() || $.isOdd()) && (M.iadd(T), $.isub(L)), M.iushrn(1), $.iushrn(1);
        for (var Ce = 0, De = 1; !(I.words[0] & De) && Ce < 26; ++Ce, De <<= 1)
          ;
        if (Ce > 0)
          for (I.iushrn(Ce); Ce-- > 0; )
            (U.isOdd() || Y.isOdd()) && (U.iadd(T), Y.isub(L)), U.iushrn(1), Y.iushrn(1);
        E.cmp(I) >= 0 ? (E.isub(I), M.isub(U), $.isub(Y)) : (I.isub(E), U.isub(M), Y.isub($));
      }
      return {
        a: U,
        b: Y,
        gcd: I.iushln(B)
      };
    }, p.prototype._invmp = function(S) {
      l(S.negative === 0), l(!S.isZero());
      var E = this, I = S.clone();
      E.negative !== 0 ? E = E.umod(S) : E = E.clone();
      for (var M = new p(1), $ = new p(0), U = I.clone(); E.cmpn(1) > 0 && I.cmpn(1) > 0; ) {
        for (var Y = 0, B = 1; !(E.words[0] & B) && Y < 26; ++Y, B <<= 1)
          ;
        if (Y > 0)
          for (E.iushrn(Y); Y-- > 0; )
            M.isOdd() && M.iadd(U), M.iushrn(1);
        for (var T = 0, L = 1; !(I.words[0] & L) && T < 26; ++T, L <<= 1)
          ;
        if (T > 0)
          for (I.iushrn(T); T-- > 0; )
            $.isOdd() && $.iadd(U), $.iushrn(1);
        E.cmp(I) >= 0 ? (E.isub(I), M.isub($)) : (I.isub(E), $.isub(M));
      }
      var te;
      return E.cmpn(1) === 0 ? te = M : te = $, te.cmpn(0) < 0 && te.iadd(S), te;
    }, p.prototype.gcd = function(S) {
      if (this.isZero())
        return S.abs();
      if (S.isZero())
        return this.abs();
      var E = this.clone(), I = S.clone();
      E.negative = 0, I.negative = 0;
      for (var M = 0; E.isEven() && I.isEven(); M++)
        E.iushrn(1), I.iushrn(1);
      do {
        for (; E.isEven(); )
          E.iushrn(1);
        for (; I.isEven(); )
          I.iushrn(1);
        var $ = E.cmp(I);
        if ($ < 0) {
          var U = E;
          E = I, I = U;
        } else if ($ === 0 || I.cmpn(1) === 0)
          break;
        E.isub(I);
      } while (!0);
      return I.iushln(M);
    }, p.prototype.invm = function(S) {
      return this.egcd(S).a.umod(S);
    }, p.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, p.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, p.prototype.andln = function(S) {
      return this.words[0] & S;
    }, p.prototype.bincn = function(S) {
      l(typeof S == "number");
      var E = S % 26, I = (S - E) / 26, M = 1 << E;
      if (this.length <= I)
        return this._expand(I + 1), this.words[I] |= M, this;
      for (var $ = M, U = I; $ !== 0 && U < this.length; U++) {
        var Y = this.words[U] | 0;
        Y += $, $ = Y >>> 26, Y &= 67108863, this.words[U] = Y;
      }
      return $ !== 0 && (this.words[U] = $, this.length++), this;
    }, p.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, p.prototype.cmpn = function(S) {
      var E = S < 0;
      if (this.negative !== 0 && !E)
        return -1;
      if (this.negative === 0 && E)
        return 1;
      this.strip();
      var I;
      if (this.length > 1)
        I = 1;
      else {
        E && (S = -S), l(S <= 67108863, "Number is too big");
        var M = this.words[0] | 0;
        I = M === S ? 0 : M < S ? -1 : 1;
      }
      return this.negative !== 0 ? -I | 0 : I;
    }, p.prototype.cmp = function(S) {
      if (this.negative !== 0 && S.negative === 0)
        return -1;
      if (this.negative === 0 && S.negative !== 0)
        return 1;
      var E = this.ucmp(S);
      return this.negative !== 0 ? -E | 0 : E;
    }, p.prototype.ucmp = function(S) {
      if (this.length > S.length)
        return 1;
      if (this.length < S.length)
        return -1;
      for (var E = 0, I = this.length - 1; I >= 0; I--) {
        var M = this.words[I] | 0, $ = S.words[I] | 0;
        if (M !== $) {
          M < $ ? E = -1 : M > $ && (E = 1);
          break;
        }
      }
      return E;
    }, p.prototype.gtn = function(S) {
      return this.cmpn(S) === 1;
    }, p.prototype.gt = function(S) {
      return this.cmp(S) === 1;
    }, p.prototype.gten = function(S) {
      return this.cmpn(S) >= 0;
    }, p.prototype.gte = function(S) {
      return this.cmp(S) >= 0;
    }, p.prototype.ltn = function(S) {
      return this.cmpn(S) === -1;
    }, p.prototype.lt = function(S) {
      return this.cmp(S) === -1;
    }, p.prototype.lten = function(S) {
      return this.cmpn(S) <= 0;
    }, p.prototype.lte = function(S) {
      return this.cmp(S) <= 0;
    }, p.prototype.eqn = function(S) {
      return this.cmpn(S) === 0;
    }, p.prototype.eq = function(S) {
      return this.cmp(S) === 0;
    }, p.red = function(S) {
      return new q(S);
    }, p.prototype.toRed = function(S) {
      return l(!this.red, "Already a number in reduction context"), l(this.negative === 0, "red works only with positives"), S.convertTo(this)._forceRed(S);
    }, p.prototype.fromRed = function() {
      return l(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, p.prototype._forceRed = function(S) {
      return this.red = S, this;
    }, p.prototype.forceRed = function(S) {
      return l(!this.red, "Already a number in reduction context"), this._forceRed(S);
    }, p.prototype.redAdd = function(S) {
      return l(this.red, "redAdd works only with red numbers"), this.red.add(this, S);
    }, p.prototype.redIAdd = function(S) {
      return l(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, S);
    }, p.prototype.redSub = function(S) {
      return l(this.red, "redSub works only with red numbers"), this.red.sub(this, S);
    }, p.prototype.redISub = function(S) {
      return l(this.red, "redISub works only with red numbers"), this.red.isub(this, S);
    }, p.prototype.redShl = function(S) {
      return l(this.red, "redShl works only with red numbers"), this.red.shl(this, S);
    }, p.prototype.redMul = function(S) {
      return l(this.red, "redMul works only with red numbers"), this.red._verify2(this, S), this.red.mul(this, S);
    }, p.prototype.redIMul = function(S) {
      return l(this.red, "redMul works only with red numbers"), this.red._verify2(this, S), this.red.imul(this, S);
    }, p.prototype.redSqr = function() {
      return l(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, p.prototype.redISqr = function() {
      return l(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, p.prototype.redSqrt = function() {
      return l(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, p.prototype.redInvm = function() {
      return l(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, p.prototype.redNeg = function() {
      return l(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, p.prototype.redPow = function(S) {
      return l(this.red && !S.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, S);
    };
    var ue = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function he(P, S) {
      this.name = P, this.p = new p(S, 16), this.n = this.p.bitLength(), this.k = new p(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    he.prototype._tmp = function() {
      var S = new p(null);
      return S.words = new Array(Math.ceil(this.n / 13)), S;
    }, he.prototype.ireduce = function(S) {
      var E = S, I;
      do
        this.split(E, this.tmp), E = this.imulK(E), E = E.iadd(this.tmp), I = E.bitLength();
      while (I > this.n);
      var M = I < this.n ? -1 : E.ucmp(this.p);
      return M === 0 ? (E.words[0] = 0, E.length = 1) : M > 0 ? E.isub(this.p) : E.strip !== void 0 ? E.strip() : E._strip(), E;
    }, he.prototype.split = function(S, E) {
      S.iushrn(this.n, 0, E);
    }, he.prototype.imulK = function(S) {
      return S.imul(this.k);
    };
    function fe() {
      he.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    v(fe, he), fe.prototype.split = function(S, E) {
      for (var I = 4194303, M = Math.min(S.length, 9), $ = 0; $ < M; $++)
        E.words[$] = S.words[$];
      if (E.length = M, S.length <= 9) {
        S.words[0] = 0, S.length = 1;
        return;
      }
      var U = S.words[9];
      for (E.words[E.length++] = U & I, $ = 10; $ < S.length; $++) {
        var Y = S.words[$] | 0;
        S.words[$ - 10] = (Y & I) << 4 | U >>> 22, U = Y;
      }
      U >>>= 22, S.words[$ - 10] = U, U === 0 && S.length > 10 ? S.length -= 10 : S.length -= 9;
    }, fe.prototype.imulK = function(S) {
      S.words[S.length] = 0, S.words[S.length + 1] = 0, S.length += 2;
      for (var E = 0, I = 0; I < S.length; I++) {
        var M = S.words[I] | 0;
        E += M * 977, S.words[I] = E & 67108863, E = M * 64 + (E / 67108864 | 0);
      }
      return S.words[S.length - 1] === 0 && (S.length--, S.words[S.length - 1] === 0 && S.length--), S;
    };
    function be() {
      he.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    v(be, he);
    function ke() {
      he.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    v(ke, he);
    function Te() {
      he.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    v(Te, he), Te.prototype.imulK = function(S) {
      for (var E = 0, I = 0; I < S.length; I++) {
        var M = (S.words[I] | 0) * 19 + E, $ = M & 67108863;
        M >>>= 26, S.words[I] = $, E = M;
      }
      return E !== 0 && (S.words[S.length++] = E), S;
    }, p._prime = function(S) {
      if (ue[S])
        return ue[S];
      var E;
      if (S === "k256")
        E = new fe();
      else if (S === "p224")
        E = new be();
      else if (S === "p192")
        E = new ke();
      else if (S === "p25519")
        E = new Te();
      else
        throw new Error("Unknown prime " + S);
      return ue[S] = E, E;
    };
    function q(P) {
      if (typeof P == "string") {
        var S = p._prime(P);
        this.m = S.p, this.prime = S;
      } else
        l(P.gtn(1), "modulus must be greater than 1"), this.m = P, this.prime = null;
    }
    q.prototype._verify1 = function(S) {
      l(S.negative === 0, "red works only with positives"), l(S.red, "red works only with red numbers");
    }, q.prototype._verify2 = function(S, E) {
      l((S.negative | E.negative) === 0, "red works only with positives"), l(
        S.red && S.red === E.red,
        "red works only with red numbers"
      );
    }, q.prototype.imod = function(S) {
      return this.prime ? this.prime.ireduce(S)._forceRed(this) : S.umod(this.m)._forceRed(this);
    }, q.prototype.neg = function(S) {
      return S.isZero() ? S.clone() : this.m.sub(S)._forceRed(this);
    }, q.prototype.add = function(S, E) {
      this._verify2(S, E);
      var I = S.add(E);
      return I.cmp(this.m) >= 0 && I.isub(this.m), I._forceRed(this);
    }, q.prototype.iadd = function(S, E) {
      this._verify2(S, E);
      var I = S.iadd(E);
      return I.cmp(this.m) >= 0 && I.isub(this.m), I;
    }, q.prototype.sub = function(S, E) {
      this._verify2(S, E);
      var I = S.sub(E);
      return I.cmpn(0) < 0 && I.iadd(this.m), I._forceRed(this);
    }, q.prototype.isub = function(S, E) {
      this._verify2(S, E);
      var I = S.isub(E);
      return I.cmpn(0) < 0 && I.iadd(this.m), I;
    }, q.prototype.shl = function(S, E) {
      return this._verify1(S), this.imod(S.ushln(E));
    }, q.prototype.imul = function(S, E) {
      return this._verify2(S, E), this.imod(S.imul(E));
    }, q.prototype.mul = function(S, E) {
      return this._verify2(S, E), this.imod(S.mul(E));
    }, q.prototype.isqr = function(S) {
      return this.imul(S, S.clone());
    }, q.prototype.sqr = function(S) {
      return this.mul(S, S);
    }, q.prototype.sqrt = function(S) {
      if (S.isZero())
        return S.clone();
      var E = this.m.andln(3);
      if (l(E % 2 === 1), E === 3) {
        var I = this.m.add(new p(1)).iushrn(2);
        return this.pow(S, I);
      }
      for (var M = this.m.subn(1), $ = 0; !M.isZero() && M.andln(1) === 0; )
        $++, M.iushrn(1);
      l(!M.isZero());
      var U = new p(1).toRed(this), Y = U.redNeg(), B = this.m.subn(1).iushrn(1), T = this.m.bitLength();
      for (T = new p(2 * T * T).toRed(this); this.pow(T, B).cmp(Y) !== 0; )
        T.redIAdd(Y);
      for (var L = this.pow(T, M), te = this.pow(S, M.addn(1).iushrn(1)), me = this.pow(S, M), Ce = $; me.cmp(U) !== 0; ) {
        for (var De = me, ye = 0; De.cmp(U) !== 0; ye++)
          De = De.redSqr();
        l(ye < Ce);
        var pe = this.pow(L, new p(1).iushln(Ce - ye - 1));
        te = te.redMul(pe), L = pe.redSqr(), me = me.redMul(L), Ce = ye;
      }
      return te;
    }, q.prototype.invm = function(S) {
      var E = S._invmp(this.m);
      return E.negative !== 0 ? (E.negative = 0, this.imod(E).redNeg()) : this.imod(E);
    }, q.prototype.pow = function(S, E) {
      if (E.isZero())
        return new p(1).toRed(this);
      if (E.cmpn(1) === 0)
        return S.clone();
      var I = 4, M = new Array(1 << I);
      M[0] = new p(1).toRed(this), M[1] = S;
      for (var $ = 2; $ < M.length; $++)
        M[$] = this.mul(M[$ - 1], S);
      var U = M[0], Y = 0, B = 0, T = E.bitLength() % 26;
      for (T === 0 && (T = 26), $ = E.length - 1; $ >= 0; $--) {
        for (var L = E.words[$], te = T - 1; te >= 0; te--) {
          var me = L >> te & 1;
          if (U !== M[0] && (U = this.sqr(U)), me === 0 && Y === 0) {
            B = 0;
            continue;
          }
          Y <<= 1, Y |= me, B++, !(B !== I && ($ !== 0 || te !== 0)) && (U = this.mul(U, M[Y]), B = 0, Y = 0);
        }
        T = 26;
      }
      return U;
    }, q.prototype.convertTo = function(S) {
      var E = S.umod(this.m);
      return E === S ? E.clone() : E;
    }, q.prototype.convertFrom = function(S) {
      var E = S.clone();
      return E.red = null, E;
    }, p.mont = function(S) {
      return new z(S);
    };
    function z(P) {
      q.call(this, P), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new p(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    v(z, q), z.prototype.convertTo = function(S) {
      return this.imod(S.ushln(this.shift));
    }, z.prototype.convertFrom = function(S) {
      var E = this.imod(S.mul(this.rinv));
      return E.red = null, E;
    }, z.prototype.imul = function(S, E) {
      if (S.isZero() || E.isZero())
        return S.words[0] = 0, S.length = 1, S;
      var I = S.imul(E), M = I.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), $ = I.isub(M).iushrn(this.shift), U = $;
      return $.cmp(this.m) >= 0 ? U = $.isub(this.m) : $.cmpn(0) < 0 && (U = $.iadd(this.m)), U._forceRed(this);
    }, z.prototype.mul = function(S, E) {
      if (S.isZero() || E.isZero())
        return new p(0)._forceRed(this);
      var I = S.mul(E), M = I.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), $ = I.isub(M).iushrn(this.shift), U = $;
      return $.cmp(this.m) >= 0 ? U = $.isub(this.m) : $.cmpn(0) < 0 && (U = $.iadd(this.m)), U._forceRed(this);
    }, z.prototype.invm = function(S) {
      var E = this.imod(S._invmp(this.m).mul(this.r2));
      return E._forceRed(this);
    };
  })(a, commonjsGlobal$1);
})(bn$3);
var bnExports$3 = bn$3.exports, utils$u = {};
(function(a) {
  var u = a;
  function c(p, _) {
    if (Array.isArray(p))
      return p.slice();
    if (!p)
      return [];
    var k = [];
    if (typeof p != "string") {
      for (var O = 0; O < p.length; O++)
        k[O] = p[O] | 0;
      return k;
    }
    if (_ === "hex") {
      p = p.replace(/[^a-z0-9]+/ig, ""), p.length % 2 !== 0 && (p = "0" + p);
      for (var O = 0; O < p.length; O += 2)
        k.push(parseInt(p[O] + p[O + 1], 16));
    } else
      for (var O = 0; O < p.length; O++) {
        var D = p.charCodeAt(O), F = D >> 8, H = D & 255;
        F ? k.push(F, H) : k.push(H);
      }
    return k;
  }
  u.toArray = c;
  function l(p) {
    return p.length === 1 ? "0" + p : p;
  }
  u.zero2 = l;
  function v(p) {
    for (var _ = "", k = 0; k < p.length; k++)
      _ += l(p[k].toString(16));
    return _;
  }
  u.toHex = v, u.encode = function(_, k) {
    return k === "hex" ? v(_) : _;
  };
})(utils$u);
(function(a) {
  var u = a, c = bnExports$3, l = minimalisticAssert, v = utils$u;
  u.assert = l, u.toArray = v.toArray, u.zero2 = v.zero2, u.toHex = v.toHex, u.encode = v.encode;
  function p(F, H, Z) {
    var ee = new Array(Math.max(F.bitLength(), Z) + 1);
    ee.fill(0);
    for (var X = 1 << H + 1, ne = F.clone(), Q = 0; Q < ee.length; Q++) {
      var ae, j = ne.andln(X - 1);
      ne.isOdd() ? (j > (X >> 1) - 1 ? ae = (X >> 1) - j : ae = j, ne.isubn(ae)) : ae = 0, ee[Q] = ae, ne.iushrn(1);
    }
    return ee;
  }
  u.getNAF = p;
  function _(F, H) {
    var Z = [
      [],
      []
    ];
    F = F.clone(), H = H.clone();
    for (var ee = 0, X = 0, ne; F.cmpn(-ee) > 0 || H.cmpn(-X) > 0; ) {
      var Q = F.andln(3) + ee & 3, ae = H.andln(3) + X & 3;
      Q === 3 && (Q = -1), ae === 3 && (ae = -1);
      var j;
      Q & 1 ? (ne = F.andln(7) + ee & 7, (ne === 3 || ne === 5) && ae === 2 ? j = -Q : j = Q) : j = 0, Z[0].push(j);
      var ue;
      ae & 1 ? (ne = H.andln(7) + X & 7, (ne === 3 || ne === 5) && Q === 2 ? ue = -ae : ue = ae) : ue = 0, Z[1].push(ue), 2 * ee === j + 1 && (ee = 1 - ee), 2 * X === ue + 1 && (X = 1 - X), F.iushrn(1), H.iushrn(1);
    }
    return Z;
  }
  u.getJSF = _;
  function k(F, H, Z) {
    var ee = "_" + H;
    F.prototype[H] = function() {
      return this[ee] !== void 0 ? this[ee] : this[ee] = Z.call(this);
    };
  }
  u.cachedProperty = k;
  function O(F) {
    return typeof F == "string" ? u.toArray(F, "hex") : F;
  }
  u.parseBytes = O;
  function D(F) {
    return new c(F, "hex", "le");
  }
  u.intFromLE = D;
})(utils$v);
var curve = {}, BN$9 = bnExports$3, utils$t = utils$v, getNAF = utils$t.getNAF, getJSF = utils$t.getJSF, assert$e = utils$t.assert;
function BaseCurve(a, u) {
  this.type = a, this.p = new BN$9(u.p, 16), this.red = u.prime ? BN$9.red(u.prime) : BN$9.mont(this.p), this.zero = new BN$9(0).toRed(this.red), this.one = new BN$9(1).toRed(this.red), this.two = new BN$9(2).toRed(this.red), this.n = u.n && new BN$9(u.n, 16), this.g = u.g && this.pointFromJSON(u.g, u.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
  var c = this.n && this.p.div(this.n);
  !c || c.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
}
var base$1 = BaseCurve;
BaseCurve.prototype.point = function a() {
  throw new Error("Not implemented");
};
BaseCurve.prototype.validate = function a() {
  throw new Error("Not implemented");
};
BaseCurve.prototype._fixedNafMul = function a(u, c) {
  assert$e(u.precomputed);
  var l = u._getDoubles(), v = getNAF(c, 1, this._bitLength), p = (1 << l.step + 1) - (l.step % 2 === 0 ? 2 : 1);
  p /= 3;
  var _ = [], k, O;
  for (k = 0; k < v.length; k += l.step) {
    O = 0;
    for (var D = k + l.step - 1; D >= k; D--)
      O = (O << 1) + v[D];
    _.push(O);
  }
  for (var F = this.jpoint(null, null, null), H = this.jpoint(null, null, null), Z = p; Z > 0; Z--) {
    for (k = 0; k < _.length; k++)
      O = _[k], O === Z ? H = H.mixedAdd(l.points[k]) : O === -Z && (H = H.mixedAdd(l.points[k].neg()));
    F = F.add(H);
  }
  return F.toP();
};
BaseCurve.prototype._wnafMul = function a(u, c) {
  var l = 4, v = u._getNAFPoints(l);
  l = v.wnd;
  for (var p = v.points, _ = getNAF(c, l, this._bitLength), k = this.jpoint(null, null, null), O = _.length - 1; O >= 0; O--) {
    for (var D = 0; O >= 0 && _[O] === 0; O--)
      D++;
    if (O >= 0 && D++, k = k.dblp(D), O < 0)
      break;
    var F = _[O];
    assert$e(F !== 0), u.type === "affine" ? F > 0 ? k = k.mixedAdd(p[F - 1 >> 1]) : k = k.mixedAdd(p[-F - 1 >> 1].neg()) : F > 0 ? k = k.add(p[F - 1 >> 1]) : k = k.add(p[-F - 1 >> 1].neg());
  }
  return u.type === "affine" ? k.toP() : k;
};
BaseCurve.prototype._wnafMulAdd = function a(u, c, l, v, p) {
  var _ = this._wnafT1, k = this._wnafT2, O = this._wnafT3, D = 0, F, H, Z;
  for (F = 0; F < v; F++) {
    Z = c[F];
    var ee = Z._getNAFPoints(u);
    _[F] = ee.wnd, k[F] = ee.points;
  }
  for (F = v - 1; F >= 1; F -= 2) {
    var X = F - 1, ne = F;
    if (_[X] !== 1 || _[ne] !== 1) {
      O[X] = getNAF(l[X], _[X], this._bitLength), O[ne] = getNAF(l[ne], _[ne], this._bitLength), D = Math.max(O[X].length, D), D = Math.max(O[ne].length, D);
      continue;
    }
    var Q = [
      c[X],
      /* 1 */
      null,
      /* 3 */
      null,
      /* 5 */
      c[ne]
      /* 7 */
    ];
    c[X].y.cmp(c[ne].y) === 0 ? (Q[1] = c[X].add(c[ne]), Q[2] = c[X].toJ().mixedAdd(c[ne].neg())) : c[X].y.cmp(c[ne].y.redNeg()) === 0 ? (Q[1] = c[X].toJ().mixedAdd(c[ne]), Q[2] = c[X].add(c[ne].neg())) : (Q[1] = c[X].toJ().mixedAdd(c[ne]), Q[2] = c[X].toJ().mixedAdd(c[ne].neg()));
    var ae = [
      -3,
      /* -1 -1 */
      -1,
      /* -1 0 */
      -5,
      /* -1 1 */
      -7,
      /* 0 -1 */
      0,
      /* 0 0 */
      7,
      /* 0 1 */
      5,
      /* 1 -1 */
      1,
      /* 1 0 */
      3
      /* 1 1 */
    ], j = getJSF(l[X], l[ne]);
    for (D = Math.max(j[0].length, D), O[X] = new Array(D), O[ne] = new Array(D), H = 0; H < D; H++) {
      var ue = j[0][H] | 0, he = j[1][H] | 0;
      O[X][H] = ae[(ue + 1) * 3 + (he + 1)], O[ne][H] = 0, k[X] = Q;
    }
  }
  var fe = this.jpoint(null, null, null), be = this._wnafT4;
  for (F = D; F >= 0; F--) {
    for (var ke = 0; F >= 0; ) {
      var Te = !0;
      for (H = 0; H < v; H++)
        be[H] = O[H][F] | 0, be[H] !== 0 && (Te = !1);
      if (!Te)
        break;
      ke++, F--;
    }
    if (F >= 0 && ke++, fe = fe.dblp(ke), F < 0)
      break;
    for (H = 0; H < v; H++) {
      var q = be[H];
      q !== 0 && (q > 0 ? Z = k[H][q - 1 >> 1] : q < 0 && (Z = k[H][-q - 1 >> 1].neg()), Z.type === "affine" ? fe = fe.mixedAdd(Z) : fe = fe.add(Z));
    }
  }
  for (F = 0; F < v; F++)
    k[F] = null;
  return p ? fe : fe.toP();
};
function BasePoint(a, u) {
  this.curve = a, this.type = u, this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;
BasePoint.prototype.eq = function a() {
  throw new Error("Not implemented");
};
BasePoint.prototype.validate = function a() {
  return this.curve.validate(this);
};
BaseCurve.prototype.decodePoint = function a(u, c) {
  u = utils$t.toArray(u, c);
  var l = this.p.byteLength();
  if ((u[0] === 4 || u[0] === 6 || u[0] === 7) && u.length - 1 === 2 * l) {
    u[0] === 6 ? assert$e(u[u.length - 1] % 2 === 0) : u[0] === 7 && assert$e(u[u.length - 1] % 2 === 1);
    var v = this.point(
      u.slice(1, 1 + l),
      u.slice(1 + l, 1 + 2 * l)
    );
    return v;
  } else if ((u[0] === 2 || u[0] === 3) && u.length - 1 === l)
    return this.pointFromX(u.slice(1, 1 + l), u[0] === 3);
  throw new Error("Unknown point format");
};
BasePoint.prototype.encodeCompressed = function a(u) {
  return this.encode(u, !0);
};
BasePoint.prototype._encode = function a(u) {
  var c = this.curve.p.byteLength(), l = this.getX().toArray("be", c);
  return u ? [this.getY().isEven() ? 2 : 3].concat(l) : [4].concat(l, this.getY().toArray("be", c));
};
BasePoint.prototype.encode = function a(u, c) {
  return utils$t.encode(this._encode(c), u);
};
BasePoint.prototype.precompute = function a(u) {
  if (this.precomputed)
    return this;
  var c = {
    doubles: null,
    naf: null,
    beta: null
  };
  return c.naf = this._getNAFPoints(8), c.doubles = this._getDoubles(4, u), c.beta = this._getBeta(), this.precomputed = c, this;
};
BasePoint.prototype._hasDoubles = function a(u) {
  if (!this.precomputed)
    return !1;
  var c = this.precomputed.doubles;
  return c ? c.points.length >= Math.ceil((u.bitLength() + 1) / c.step) : !1;
};
BasePoint.prototype._getDoubles = function a(u, c) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  for (var l = [this], v = this, p = 0; p < c; p += u) {
    for (var _ = 0; _ < u; _++)
      v = v.dbl();
    l.push(v);
  }
  return {
    step: u,
    points: l
  };
};
BasePoint.prototype._getNAFPoints = function a(u) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  for (var c = [this], l = (1 << u) - 1, v = l === 1 ? null : this.dbl(), p = 1; p < l; p++)
    c[p] = c[p - 1].add(v);
  return {
    wnd: u,
    points: c
  };
};
BasePoint.prototype._getBeta = function a() {
  return null;
};
BasePoint.prototype.dblp = function a(u) {
  for (var c = this, l = 0; l < u; l++)
    c = c.dbl();
  return c;
};
var utils$s = utils$v, BN$8 = bnExports$3, inherits$9 = inherits_browserExports, Base$2 = base$1, assert$d = utils$s.assert;
function ShortCurve(a) {
  Base$2.call(this, "short", a), this.a = new BN$8(a.a, 16).toRed(this.red), this.b = new BN$8(a.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(a), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
}
inherits$9(ShortCurve, Base$2);
var short = ShortCurve;
ShortCurve.prototype._getEndomorphism = function a(u) {
  if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
    var c, l;
    if (u.beta)
      c = new BN$8(u.beta, 16).toRed(this.red);
    else {
      var v = this._getEndoRoots(this.p);
      c = v[0].cmp(v[1]) < 0 ? v[0] : v[1], c = c.toRed(this.red);
    }
    if (u.lambda)
      l = new BN$8(u.lambda, 16);
    else {
      var p = this._getEndoRoots(this.n);
      this.g.mul(p[0]).x.cmp(this.g.x.redMul(c)) === 0 ? l = p[0] : (l = p[1], assert$d(this.g.mul(l).x.cmp(this.g.x.redMul(c)) === 0));
    }
    var _;
    return u.basis ? _ = u.basis.map(function(k) {
      return {
        a: new BN$8(k.a, 16),
        b: new BN$8(k.b, 16)
      };
    }) : _ = this._getEndoBasis(l), {
      beta: c,
      lambda: l,
      basis: _
    };
  }
};
ShortCurve.prototype._getEndoRoots = function a(u) {
  var c = u === this.p ? this.red : BN$8.mont(u), l = new BN$8(2).toRed(c).redInvm(), v = l.redNeg(), p = new BN$8(3).toRed(c).redNeg().redSqrt().redMul(l), _ = v.redAdd(p).fromRed(), k = v.redSub(p).fromRed();
  return [_, k];
};
ShortCurve.prototype._getEndoBasis = function a(u) {
  for (var c = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), l = u, v = this.n.clone(), p = new BN$8(1), _ = new BN$8(0), k = new BN$8(0), O = new BN$8(1), D, F, H, Z, ee, X, ne, Q = 0, ae, j; l.cmpn(0) !== 0; ) {
    var ue = v.div(l);
    ae = v.sub(ue.mul(l)), j = k.sub(ue.mul(p));
    var he = O.sub(ue.mul(_));
    if (!H && ae.cmp(c) < 0)
      D = ne.neg(), F = p, H = ae.neg(), Z = j;
    else if (H && ++Q === 2)
      break;
    ne = ae, v = l, l = ae, k = p, p = j, O = _, _ = he;
  }
  ee = ae.neg(), X = j;
  var fe = H.sqr().add(Z.sqr()), be = ee.sqr().add(X.sqr());
  return be.cmp(fe) >= 0 && (ee = D, X = F), H.negative && (H = H.neg(), Z = Z.neg()), ee.negative && (ee = ee.neg(), X = X.neg()), [
    { a: H, b: Z },
    { a: ee, b: X }
  ];
};
ShortCurve.prototype._endoSplit = function a(u) {
  var c = this.endo.basis, l = c[0], v = c[1], p = v.b.mul(u).divRound(this.n), _ = l.b.neg().mul(u).divRound(this.n), k = p.mul(l.a), O = _.mul(v.a), D = p.mul(l.b), F = _.mul(v.b), H = u.sub(k).sub(O), Z = D.add(F).neg();
  return { k1: H, k2: Z };
};
ShortCurve.prototype.pointFromX = function a(u, c) {
  u = new BN$8(u, 16), u.red || (u = u.toRed(this.red));
  var l = u.redSqr().redMul(u).redIAdd(u.redMul(this.a)).redIAdd(this.b), v = l.redSqrt();
  if (v.redSqr().redSub(l).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var p = v.fromRed().isOdd();
  return (c && !p || !c && p) && (v = v.redNeg()), this.point(u, v);
};
ShortCurve.prototype.validate = function a(u) {
  if (u.inf)
    return !0;
  var c = u.x, l = u.y, v = this.a.redMul(c), p = c.redSqr().redMul(c).redIAdd(v).redIAdd(this.b);
  return l.redSqr().redISub(p).cmpn(0) === 0;
};
ShortCurve.prototype._endoWnafMulAdd = function a(u, c, l) {
  for (var v = this._endoWnafT1, p = this._endoWnafT2, _ = 0; _ < u.length; _++) {
    var k = this._endoSplit(c[_]), O = u[_], D = O._getBeta();
    k.k1.negative && (k.k1.ineg(), O = O.neg(!0)), k.k2.negative && (k.k2.ineg(), D = D.neg(!0)), v[_ * 2] = O, v[_ * 2 + 1] = D, p[_ * 2] = k.k1, p[_ * 2 + 1] = k.k2;
  }
  for (var F = this._wnafMulAdd(1, v, p, _ * 2, l), H = 0; H < _ * 2; H++)
    v[H] = null, p[H] = null;
  return F;
};
function Point$2(a, u, c, l) {
  Base$2.BasePoint.call(this, a, "affine"), u === null && c === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new BN$8(u, 16), this.y = new BN$8(c, 16), l && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
}
inherits$9(Point$2, Base$2.BasePoint);
ShortCurve.prototype.point = function a(u, c, l) {
  return new Point$2(this, u, c, l);
};
ShortCurve.prototype.pointFromJSON = function a(u, c) {
  return Point$2.fromJSON(this, u, c);
};
Point$2.prototype._getBeta = function a() {
  if (this.curve.endo) {
    var u = this.precomputed;
    if (u && u.beta)
      return u.beta;
    var c = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (u) {
      var l = this.curve, v = function(p) {
        return l.point(p.x.redMul(l.endo.beta), p.y);
      };
      u.beta = c, c.precomputed = {
        beta: null,
        naf: u.naf && {
          wnd: u.naf.wnd,
          points: u.naf.points.map(v)
        },
        doubles: u.doubles && {
          step: u.doubles.step,
          points: u.doubles.points.map(v)
        }
      };
    }
    return c;
  }
};
Point$2.prototype.toJSON = function a() {
  return this.precomputed ? [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }] : [this.x, this.y];
};
Point$2.fromJSON = function a(u, c, l) {
  typeof c == "string" && (c = JSON.parse(c));
  var v = u.point(c[0], c[1], l);
  if (!c[2])
    return v;
  function p(k) {
    return u.point(k[0], k[1], l);
  }
  var _ = c[2];
  return v.precomputed = {
    beta: null,
    doubles: _.doubles && {
      step: _.doubles.step,
      points: [v].concat(_.doubles.points.map(p))
    },
    naf: _.naf && {
      wnd: _.naf.wnd,
      points: [v].concat(_.naf.points.map(p))
    }
  }, v;
};
Point$2.prototype.inspect = function a() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
Point$2.prototype.isInfinity = function a() {
  return this.inf;
};
Point$2.prototype.add = function a(u) {
  if (this.inf)
    return u;
  if (u.inf)
    return this;
  if (this.eq(u))
    return this.dbl();
  if (this.neg().eq(u))
    return this.curve.point(null, null);
  if (this.x.cmp(u.x) === 0)
    return this.curve.point(null, null);
  var c = this.y.redSub(u.y);
  c.cmpn(0) !== 0 && (c = c.redMul(this.x.redSub(u.x).redInvm()));
  var l = c.redSqr().redISub(this.x).redISub(u.x), v = c.redMul(this.x.redSub(l)).redISub(this.y);
  return this.curve.point(l, v);
};
Point$2.prototype.dbl = function a() {
  if (this.inf)
    return this;
  var u = this.y.redAdd(this.y);
  if (u.cmpn(0) === 0)
    return this.curve.point(null, null);
  var c = this.curve.a, l = this.x.redSqr(), v = u.redInvm(), p = l.redAdd(l).redIAdd(l).redIAdd(c).redMul(v), _ = p.redSqr().redISub(this.x.redAdd(this.x)), k = p.redMul(this.x.redSub(_)).redISub(this.y);
  return this.curve.point(_, k);
};
Point$2.prototype.getX = function a() {
  return this.x.fromRed();
};
Point$2.prototype.getY = function a() {
  return this.y.fromRed();
};
Point$2.prototype.mul = function a(u) {
  return u = new BN$8(u, 16), this.isInfinity() ? this : this._hasDoubles(u) ? this.curve._fixedNafMul(this, u) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [u]) : this.curve._wnafMul(this, u);
};
Point$2.prototype.mulAdd = function a(u, c, l) {
  var v = [this, c], p = [u, l];
  return this.curve.endo ? this.curve._endoWnafMulAdd(v, p) : this.curve._wnafMulAdd(1, v, p, 2);
};
Point$2.prototype.jmulAdd = function a(u, c, l) {
  var v = [this, c], p = [u, l];
  return this.curve.endo ? this.curve._endoWnafMulAdd(v, p, !0) : this.curve._wnafMulAdd(1, v, p, 2, !0);
};
Point$2.prototype.eq = function a(u) {
  return this === u || this.inf === u.inf && (this.inf || this.x.cmp(u.x) === 0 && this.y.cmp(u.y) === 0);
};
Point$2.prototype.neg = function a(u) {
  if (this.inf)
    return this;
  var c = this.curve.point(this.x, this.y.redNeg());
  if (u && this.precomputed) {
    var l = this.precomputed, v = function(p) {
      return p.neg();
    };
    c.precomputed = {
      naf: l.naf && {
        wnd: l.naf.wnd,
        points: l.naf.points.map(v)
      },
      doubles: l.doubles && {
        step: l.doubles.step,
        points: l.doubles.points.map(v)
      }
    };
  }
  return c;
};
Point$2.prototype.toJ = function a() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var u = this.curve.jpoint(this.x, this.y, this.curve.one);
  return u;
};
function JPoint(a, u, c, l) {
  Base$2.BasePoint.call(this, a, "jacobian"), u === null && c === null && l === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new BN$8(0)) : (this.x = new BN$8(u, 16), this.y = new BN$8(c, 16), this.z = new BN$8(l, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
}
inherits$9(JPoint, Base$2.BasePoint);
ShortCurve.prototype.jpoint = function a(u, c, l) {
  return new JPoint(this, u, c, l);
};
JPoint.prototype.toP = function a() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var u = this.z.redInvm(), c = u.redSqr(), l = this.x.redMul(c), v = this.y.redMul(c).redMul(u);
  return this.curve.point(l, v);
};
JPoint.prototype.neg = function a() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
JPoint.prototype.add = function a(u) {
  if (this.isInfinity())
    return u;
  if (u.isInfinity())
    return this;
  var c = u.z.redSqr(), l = this.z.redSqr(), v = this.x.redMul(c), p = u.x.redMul(l), _ = this.y.redMul(c.redMul(u.z)), k = u.y.redMul(l.redMul(this.z)), O = v.redSub(p), D = _.redSub(k);
  if (O.cmpn(0) === 0)
    return D.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var F = O.redSqr(), H = F.redMul(O), Z = v.redMul(F), ee = D.redSqr().redIAdd(H).redISub(Z).redISub(Z), X = D.redMul(Z.redISub(ee)).redISub(_.redMul(H)), ne = this.z.redMul(u.z).redMul(O);
  return this.curve.jpoint(ee, X, ne);
};
JPoint.prototype.mixedAdd = function a(u) {
  if (this.isInfinity())
    return u.toJ();
  if (u.isInfinity())
    return this;
  var c = this.z.redSqr(), l = this.x, v = u.x.redMul(c), p = this.y, _ = u.y.redMul(c).redMul(this.z), k = l.redSub(v), O = p.redSub(_);
  if (k.cmpn(0) === 0)
    return O.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var D = k.redSqr(), F = D.redMul(k), H = l.redMul(D), Z = O.redSqr().redIAdd(F).redISub(H).redISub(H), ee = O.redMul(H.redISub(Z)).redISub(p.redMul(F)), X = this.z.redMul(k);
  return this.curve.jpoint(Z, ee, X);
};
JPoint.prototype.dblp = function a(u) {
  if (u === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!u)
    return this.dbl();
  var c;
  if (this.curve.zeroA || this.curve.threeA) {
    var l = this;
    for (c = 0; c < u; c++)
      l = l.dbl();
    return l;
  }
  var v = this.curve.a, p = this.curve.tinv, _ = this.x, k = this.y, O = this.z, D = O.redSqr().redSqr(), F = k.redAdd(k);
  for (c = 0; c < u; c++) {
    var H = _.redSqr(), Z = F.redSqr(), ee = Z.redSqr(), X = H.redAdd(H).redIAdd(H).redIAdd(v.redMul(D)), ne = _.redMul(Z), Q = X.redSqr().redISub(ne.redAdd(ne)), ae = ne.redISub(Q), j = X.redMul(ae);
    j = j.redIAdd(j).redISub(ee);
    var ue = F.redMul(O);
    c + 1 < u && (D = D.redMul(ee)), _ = Q, O = ue, F = j;
  }
  return this.curve.jpoint(_, F.redMul(p), O);
};
JPoint.prototype.dbl = function a() {
  return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
};
JPoint.prototype._zeroDbl = function a() {
  var u, c, l;
  if (this.zOne) {
    var v = this.x.redSqr(), p = this.y.redSqr(), _ = p.redSqr(), k = this.x.redAdd(p).redSqr().redISub(v).redISub(_);
    k = k.redIAdd(k);
    var O = v.redAdd(v).redIAdd(v), D = O.redSqr().redISub(k).redISub(k), F = _.redIAdd(_);
    F = F.redIAdd(F), F = F.redIAdd(F), u = D, c = O.redMul(k.redISub(D)).redISub(F), l = this.y.redAdd(this.y);
  } else {
    var H = this.x.redSqr(), Z = this.y.redSqr(), ee = Z.redSqr(), X = this.x.redAdd(Z).redSqr().redISub(H).redISub(ee);
    X = X.redIAdd(X);
    var ne = H.redAdd(H).redIAdd(H), Q = ne.redSqr(), ae = ee.redIAdd(ee);
    ae = ae.redIAdd(ae), ae = ae.redIAdd(ae), u = Q.redISub(X).redISub(X), c = ne.redMul(X.redISub(u)).redISub(ae), l = this.y.redMul(this.z), l = l.redIAdd(l);
  }
  return this.curve.jpoint(u, c, l);
};
JPoint.prototype._threeDbl = function a() {
  var u, c, l;
  if (this.zOne) {
    var v = this.x.redSqr(), p = this.y.redSqr(), _ = p.redSqr(), k = this.x.redAdd(p).redSqr().redISub(v).redISub(_);
    k = k.redIAdd(k);
    var O = v.redAdd(v).redIAdd(v).redIAdd(this.curve.a), D = O.redSqr().redISub(k).redISub(k);
    u = D;
    var F = _.redIAdd(_);
    F = F.redIAdd(F), F = F.redIAdd(F), c = O.redMul(k.redISub(D)).redISub(F), l = this.y.redAdd(this.y);
  } else {
    var H = this.z.redSqr(), Z = this.y.redSqr(), ee = this.x.redMul(Z), X = this.x.redSub(H).redMul(this.x.redAdd(H));
    X = X.redAdd(X).redIAdd(X);
    var ne = ee.redIAdd(ee);
    ne = ne.redIAdd(ne);
    var Q = ne.redAdd(ne);
    u = X.redSqr().redISub(Q), l = this.y.redAdd(this.z).redSqr().redISub(Z).redISub(H);
    var ae = Z.redSqr();
    ae = ae.redIAdd(ae), ae = ae.redIAdd(ae), ae = ae.redIAdd(ae), c = X.redMul(ne.redISub(u)).redISub(ae);
  }
  return this.curve.jpoint(u, c, l);
};
JPoint.prototype._dbl = function a() {
  var u = this.curve.a, c = this.x, l = this.y, v = this.z, p = v.redSqr().redSqr(), _ = c.redSqr(), k = l.redSqr(), O = _.redAdd(_).redIAdd(_).redIAdd(u.redMul(p)), D = c.redAdd(c);
  D = D.redIAdd(D);
  var F = D.redMul(k), H = O.redSqr().redISub(F.redAdd(F)), Z = F.redISub(H), ee = k.redSqr();
  ee = ee.redIAdd(ee), ee = ee.redIAdd(ee), ee = ee.redIAdd(ee);
  var X = O.redMul(Z).redISub(ee), ne = l.redAdd(l).redMul(v);
  return this.curve.jpoint(H, X, ne);
};
JPoint.prototype.trpl = function a() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var u = this.x.redSqr(), c = this.y.redSqr(), l = this.z.redSqr(), v = c.redSqr(), p = u.redAdd(u).redIAdd(u), _ = p.redSqr(), k = this.x.redAdd(c).redSqr().redISub(u).redISub(v);
  k = k.redIAdd(k), k = k.redAdd(k).redIAdd(k), k = k.redISub(_);
  var O = k.redSqr(), D = v.redIAdd(v);
  D = D.redIAdd(D), D = D.redIAdd(D), D = D.redIAdd(D);
  var F = p.redIAdd(k).redSqr().redISub(_).redISub(O).redISub(D), H = c.redMul(F);
  H = H.redIAdd(H), H = H.redIAdd(H);
  var Z = this.x.redMul(O).redISub(H);
  Z = Z.redIAdd(Z), Z = Z.redIAdd(Z);
  var ee = this.y.redMul(F.redMul(D.redISub(F)).redISub(k.redMul(O)));
  ee = ee.redIAdd(ee), ee = ee.redIAdd(ee), ee = ee.redIAdd(ee);
  var X = this.z.redAdd(k).redSqr().redISub(l).redISub(O);
  return this.curve.jpoint(Z, ee, X);
};
JPoint.prototype.mul = function a(u, c) {
  return u = new BN$8(u, c), this.curve._wnafMul(this, u);
};
JPoint.prototype.eq = function a(u) {
  if (u.type === "affine")
    return this.eq(u.toJ());
  if (this === u)
    return !0;
  var c = this.z.redSqr(), l = u.z.redSqr();
  if (this.x.redMul(l).redISub(u.x.redMul(c)).cmpn(0) !== 0)
    return !1;
  var v = c.redMul(this.z), p = l.redMul(u.z);
  return this.y.redMul(p).redISub(u.y.redMul(v)).cmpn(0) === 0;
};
JPoint.prototype.eqXToP = function a(u) {
  var c = this.z.redSqr(), l = u.toRed(this.curve.red).redMul(c);
  if (this.x.cmp(l) === 0)
    return !0;
  for (var v = u.clone(), p = this.curve.redN.redMul(c); ; ) {
    if (v.iadd(this.curve.n), v.cmp(this.curve.p) >= 0)
      return !1;
    if (l.redIAdd(p), this.x.cmp(l) === 0)
      return !0;
  }
};
JPoint.prototype.inspect = function a() {
  return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
JPoint.prototype.isInfinity = function a() {
  return this.z.cmpn(0) === 0;
};
var BN$7 = bnExports$3, inherits$8 = inherits_browserExports, Base$1 = base$1, utils$r = utils$v;
function MontCurve(a) {
  Base$1.call(this, "mont", a), this.a = new BN$7(a.a, 16).toRed(this.red), this.b = new BN$7(a.b, 16).toRed(this.red), this.i4 = new BN$7(4).toRed(this.red).redInvm(), this.two = new BN$7(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
inherits$8(MontCurve, Base$1);
var mont = MontCurve;
MontCurve.prototype.validate = function a(u) {
  var c = u.normalize().x, l = c.redSqr(), v = l.redMul(c).redAdd(l.redMul(this.a)).redAdd(c), p = v.redSqrt();
  return p.redSqr().cmp(v) === 0;
};
function Point$1(a, u, c) {
  Base$1.BasePoint.call(this, a, "projective"), u === null && c === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new BN$7(u, 16), this.z = new BN$7(c, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
}
inherits$8(Point$1, Base$1.BasePoint);
MontCurve.prototype.decodePoint = function a(u, c) {
  return this.point(utils$r.toArray(u, c), 1);
};
MontCurve.prototype.point = function a(u, c) {
  return new Point$1(this, u, c);
};
MontCurve.prototype.pointFromJSON = function a(u) {
  return Point$1.fromJSON(this, u);
};
Point$1.prototype.precompute = function a() {
};
Point$1.prototype._encode = function a() {
  return this.getX().toArray("be", this.curve.p.byteLength());
};
Point$1.fromJSON = function a(u, c) {
  return new Point$1(u, c[0], c[1] || u.one);
};
Point$1.prototype.inspect = function a() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
Point$1.prototype.isInfinity = function a() {
  return this.z.cmpn(0) === 0;
};
Point$1.prototype.dbl = function a() {
  var u = this.x.redAdd(this.z), c = u.redSqr(), l = this.x.redSub(this.z), v = l.redSqr(), p = c.redSub(v), _ = c.redMul(v), k = p.redMul(v.redAdd(this.curve.a24.redMul(p)));
  return this.curve.point(_, k);
};
Point$1.prototype.add = function a() {
  throw new Error("Not supported on Montgomery curve");
};
Point$1.prototype.diffAdd = function a(u, c) {
  var l = this.x.redAdd(this.z), v = this.x.redSub(this.z), p = u.x.redAdd(u.z), _ = u.x.redSub(u.z), k = _.redMul(l), O = p.redMul(v), D = c.z.redMul(k.redAdd(O).redSqr()), F = c.x.redMul(k.redISub(O).redSqr());
  return this.curve.point(D, F);
};
Point$1.prototype.mul = function a(u) {
  for (var c = u.clone(), l = this, v = this.curve.point(null, null), p = this, _ = []; c.cmpn(0) !== 0; c.iushrn(1))
    _.push(c.andln(1));
  for (var k = _.length - 1; k >= 0; k--)
    _[k] === 0 ? (l = l.diffAdd(v, p), v = v.dbl()) : (v = l.diffAdd(v, p), l = l.dbl());
  return v;
};
Point$1.prototype.mulAdd = function a() {
  throw new Error("Not supported on Montgomery curve");
};
Point$1.prototype.jumlAdd = function a() {
  throw new Error("Not supported on Montgomery curve");
};
Point$1.prototype.eq = function a(u) {
  return this.getX().cmp(u.getX()) === 0;
};
Point$1.prototype.normalize = function a() {
  return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
};
Point$1.prototype.getX = function a() {
  return this.normalize(), this.x.fromRed();
};
var utils$q = utils$v, BN$6 = bnExports$3, inherits$7 = inherits_browserExports, Base = base$1, assert$c = utils$q.assert;
function EdwardsCurve(a) {
  this.twisted = (a.a | 0) !== 1, this.mOneA = this.twisted && (a.a | 0) === -1, this.extended = this.mOneA, Base.call(this, "edwards", a), this.a = new BN$6(a.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new BN$6(a.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new BN$6(a.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), assert$c(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (a.c | 0) === 1;
}
inherits$7(EdwardsCurve, Base);
var edwards = EdwardsCurve;
EdwardsCurve.prototype._mulA = function a(u) {
  return this.mOneA ? u.redNeg() : this.a.redMul(u);
};
EdwardsCurve.prototype._mulC = function a(u) {
  return this.oneC ? u : this.c.redMul(u);
};
EdwardsCurve.prototype.jpoint = function a(u, c, l, v) {
  return this.point(u, c, l, v);
};
EdwardsCurve.prototype.pointFromX = function a(u, c) {
  u = new BN$6(u, 16), u.red || (u = u.toRed(this.red));
  var l = u.redSqr(), v = this.c2.redSub(this.a.redMul(l)), p = this.one.redSub(this.c2.redMul(this.d).redMul(l)), _ = v.redMul(p.redInvm()), k = _.redSqrt();
  if (k.redSqr().redSub(_).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var O = k.fromRed().isOdd();
  return (c && !O || !c && O) && (k = k.redNeg()), this.point(u, k);
};
EdwardsCurve.prototype.pointFromY = function a(u, c) {
  u = new BN$6(u, 16), u.red || (u = u.toRed(this.red));
  var l = u.redSqr(), v = l.redSub(this.c2), p = l.redMul(this.d).redMul(this.c2).redSub(this.a), _ = v.redMul(p.redInvm());
  if (_.cmp(this.zero) === 0) {
    if (c)
      throw new Error("invalid point");
    return this.point(this.zero, u);
  }
  var k = _.redSqrt();
  if (k.redSqr().redSub(_).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  return k.fromRed().isOdd() !== c && (k = k.redNeg()), this.point(k, u);
};
EdwardsCurve.prototype.validate = function a(u) {
  if (u.isInfinity())
    return !0;
  u.normalize();
  var c = u.x.redSqr(), l = u.y.redSqr(), v = c.redMul(this.a).redAdd(l), p = this.c2.redMul(this.one.redAdd(this.d.redMul(c).redMul(l)));
  return v.cmp(p) === 0;
};
function Point(a, u, c, l, v) {
  Base.BasePoint.call(this, a, "projective"), u === null && c === null && l === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new BN$6(u, 16), this.y = new BN$6(c, 16), this.z = l ? new BN$6(l, 16) : this.curve.one, this.t = v && new BN$6(v, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
}
inherits$7(Point, Base.BasePoint);
EdwardsCurve.prototype.pointFromJSON = function a(u) {
  return Point.fromJSON(this, u);
};
EdwardsCurve.prototype.point = function a(u, c, l, v) {
  return new Point(this, u, c, l, v);
};
Point.fromJSON = function a(u, c) {
  return new Point(u, c[0], c[1], c[2]);
};
Point.prototype.inspect = function a() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
Point.prototype.isInfinity = function a() {
  return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
};
Point.prototype._extDbl = function a() {
  var u = this.x.redSqr(), c = this.y.redSqr(), l = this.z.redSqr();
  l = l.redIAdd(l);
  var v = this.curve._mulA(u), p = this.x.redAdd(this.y).redSqr().redISub(u).redISub(c), _ = v.redAdd(c), k = _.redSub(l), O = v.redSub(c), D = p.redMul(k), F = _.redMul(O), H = p.redMul(O), Z = k.redMul(_);
  return this.curve.point(D, F, Z, H);
};
Point.prototype._projDbl = function a() {
  var u = this.x.redAdd(this.y).redSqr(), c = this.x.redSqr(), l = this.y.redSqr(), v, p, _, k, O, D;
  if (this.curve.twisted) {
    k = this.curve._mulA(c);
    var F = k.redAdd(l);
    this.zOne ? (v = u.redSub(c).redSub(l).redMul(F.redSub(this.curve.two)), p = F.redMul(k.redSub(l)), _ = F.redSqr().redSub(F).redSub(F)) : (O = this.z.redSqr(), D = F.redSub(O).redISub(O), v = u.redSub(c).redISub(l).redMul(D), p = F.redMul(k.redSub(l)), _ = F.redMul(D));
  } else
    k = c.redAdd(l), O = this.curve._mulC(this.z).redSqr(), D = k.redSub(O).redSub(O), v = this.curve._mulC(u.redISub(k)).redMul(D), p = this.curve._mulC(k).redMul(c.redISub(l)), _ = k.redMul(D);
  return this.curve.point(v, p, _);
};
Point.prototype.dbl = function a() {
  return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
};
Point.prototype._extAdd = function a(u) {
  var c = this.y.redSub(this.x).redMul(u.y.redSub(u.x)), l = this.y.redAdd(this.x).redMul(u.y.redAdd(u.x)), v = this.t.redMul(this.curve.dd).redMul(u.t), p = this.z.redMul(u.z.redAdd(u.z)), _ = l.redSub(c), k = p.redSub(v), O = p.redAdd(v), D = l.redAdd(c), F = _.redMul(k), H = O.redMul(D), Z = _.redMul(D), ee = k.redMul(O);
  return this.curve.point(F, H, ee, Z);
};
Point.prototype._projAdd = function a(u) {
  var c = this.z.redMul(u.z), l = c.redSqr(), v = this.x.redMul(u.x), p = this.y.redMul(u.y), _ = this.curve.d.redMul(v).redMul(p), k = l.redSub(_), O = l.redAdd(_), D = this.x.redAdd(this.y).redMul(u.x.redAdd(u.y)).redISub(v).redISub(p), F = c.redMul(k).redMul(D), H, Z;
  return this.curve.twisted ? (H = c.redMul(O).redMul(p.redSub(this.curve._mulA(v))), Z = k.redMul(O)) : (H = c.redMul(O).redMul(p.redSub(v)), Z = this.curve._mulC(k).redMul(O)), this.curve.point(F, H, Z);
};
Point.prototype.add = function a(u) {
  return this.isInfinity() ? u : u.isInfinity() ? this : this.curve.extended ? this._extAdd(u) : this._projAdd(u);
};
Point.prototype.mul = function a(u) {
  return this._hasDoubles(u) ? this.curve._fixedNafMul(this, u) : this.curve._wnafMul(this, u);
};
Point.prototype.mulAdd = function a(u, c, l) {
  return this.curve._wnafMulAdd(1, [this, c], [u, l], 2, !1);
};
Point.prototype.jmulAdd = function a(u, c, l) {
  return this.curve._wnafMulAdd(1, [this, c], [u, l], 2, !0);
};
Point.prototype.normalize = function a() {
  if (this.zOne)
    return this;
  var u = this.z.redInvm();
  return this.x = this.x.redMul(u), this.y = this.y.redMul(u), this.t && (this.t = this.t.redMul(u)), this.z = this.curve.one, this.zOne = !0, this;
};
Point.prototype.neg = function a() {
  return this.curve.point(
    this.x.redNeg(),
    this.y,
    this.z,
    this.t && this.t.redNeg()
  );
};
Point.prototype.getX = function a() {
  return this.normalize(), this.x.fromRed();
};
Point.prototype.getY = function a() {
  return this.normalize(), this.y.fromRed();
};
Point.prototype.eq = function a(u) {
  return this === u || this.getX().cmp(u.getX()) === 0 && this.getY().cmp(u.getY()) === 0;
};
Point.prototype.eqXToP = function a(u) {
  var c = u.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(c) === 0)
    return !0;
  for (var l = u.clone(), v = this.curve.redN.redMul(this.z); ; ) {
    if (l.iadd(this.curve.n), l.cmp(this.curve.p) >= 0)
      return !1;
    if (c.redIAdd(v), this.x.cmp(c) === 0)
      return !0;
  }
};
Point.prototype.toP = Point.prototype.normalize;
Point.prototype.mixedAdd = Point.prototype.add;
(function(a) {
  var u = a;
  u.base = base$1, u.short = short, u.mont = mont, u.edwards = edwards;
})(curve);
var curves$1 = {}, hash$2 = {}, utils$p = {}, assert$b = minimalisticAssert, inherits$6 = inherits_browserExports;
utils$p.inherits = inherits$6;
function isSurrogatePair(a, u) {
  return (a.charCodeAt(u) & 64512) !== 55296 || u < 0 || u + 1 >= a.length ? !1 : (a.charCodeAt(u + 1) & 64512) === 56320;
}
function toArray(a, u) {
  if (Array.isArray(a))
    return a.slice();
  if (!a)
    return [];
  var c = [];
  if (typeof a == "string")
    if (u) {
      if (u === "hex")
        for (a = a.replace(/[^a-z0-9]+/ig, ""), a.length % 2 !== 0 && (a = "0" + a), v = 0; v < a.length; v += 2)
          c.push(parseInt(a[v] + a[v + 1], 16));
    } else
      for (var l = 0, v = 0; v < a.length; v++) {
        var p = a.charCodeAt(v);
        p < 128 ? c[l++] = p : p < 2048 ? (c[l++] = p >> 6 | 192, c[l++] = p & 63 | 128) : isSurrogatePair(a, v) ? (p = 65536 + ((p & 1023) << 10) + (a.charCodeAt(++v) & 1023), c[l++] = p >> 18 | 240, c[l++] = p >> 12 & 63 | 128, c[l++] = p >> 6 & 63 | 128, c[l++] = p & 63 | 128) : (c[l++] = p >> 12 | 224, c[l++] = p >> 6 & 63 | 128, c[l++] = p & 63 | 128);
      }
  else
    for (v = 0; v < a.length; v++)
      c[v] = a[v] | 0;
  return c;
}
utils$p.toArray = toArray;
function toHex$1(a) {
  for (var u = "", c = 0; c < a.length; c++)
    u += zero2(a[c].toString(16));
  return u;
}
utils$p.toHex = toHex$1;
function htonl(a) {
  var u = a >>> 24 | a >>> 8 & 65280 | a << 8 & 16711680 | (a & 255) << 24;
  return u >>> 0;
}
utils$p.htonl = htonl;
function toHex32(a, u) {
  for (var c = "", l = 0; l < a.length; l++) {
    var v = a[l];
    u === "little" && (v = htonl(v)), c += zero8(v.toString(16));
  }
  return c;
}
utils$p.toHex32 = toHex32;
function zero2(a) {
  return a.length === 1 ? "0" + a : a;
}
utils$p.zero2 = zero2;
function zero8(a) {
  return a.length === 7 ? "0" + a : a.length === 6 ? "00" + a : a.length === 5 ? "000" + a : a.length === 4 ? "0000" + a : a.length === 3 ? "00000" + a : a.length === 2 ? "000000" + a : a.length === 1 ? "0000000" + a : a;
}
utils$p.zero8 = zero8;
function join32(a, u, c, l) {
  var v = c - u;
  assert$b(v % 4 === 0);
  for (var p = new Array(v / 4), _ = 0, k = u; _ < p.length; _++, k += 4) {
    var O;
    l === "big" ? O = a[k] << 24 | a[k + 1] << 16 | a[k + 2] << 8 | a[k + 3] : O = a[k + 3] << 24 | a[k + 2] << 16 | a[k + 1] << 8 | a[k], p[_] = O >>> 0;
  }
  return p;
}
utils$p.join32 = join32;
function split32(a, u) {
  for (var c = new Array(a.length * 4), l = 0, v = 0; l < a.length; l++, v += 4) {
    var p = a[l];
    u === "big" ? (c[v] = p >>> 24, c[v + 1] = p >>> 16 & 255, c[v + 2] = p >>> 8 & 255, c[v + 3] = p & 255) : (c[v + 3] = p >>> 24, c[v + 2] = p >>> 16 & 255, c[v + 1] = p >>> 8 & 255, c[v] = p & 255);
  }
  return c;
}
utils$p.split32 = split32;
function rotr32$1(a, u) {
  return a >>> u | a << 32 - u;
}
utils$p.rotr32 = rotr32$1;
function rotl32$2(a, u) {
  return a << u | a >>> 32 - u;
}
utils$p.rotl32 = rotl32$2;
function sum32$3(a, u) {
  return a + u >>> 0;
}
utils$p.sum32 = sum32$3;
function sum32_3$1(a, u, c) {
  return a + u + c >>> 0;
}
utils$p.sum32_3 = sum32_3$1;
function sum32_4$2(a, u, c, l) {
  return a + u + c + l >>> 0;
}
utils$p.sum32_4 = sum32_4$2;
function sum32_5$2(a, u, c, l, v) {
  return a + u + c + l + v >>> 0;
}
utils$p.sum32_5 = sum32_5$2;
function sum64$1(a, u, c, l) {
  var v = a[u], p = a[u + 1], _ = l + p >>> 0, k = (_ < l ? 1 : 0) + c + v;
  a[u] = k >>> 0, a[u + 1] = _;
}
utils$p.sum64 = sum64$1;
function sum64_hi$1(a, u, c, l) {
  var v = u + l >>> 0, p = (v < u ? 1 : 0) + a + c;
  return p >>> 0;
}
utils$p.sum64_hi = sum64_hi$1;
function sum64_lo$1(a, u, c, l) {
  var v = u + l;
  return v >>> 0;
}
utils$p.sum64_lo = sum64_lo$1;
function sum64_4_hi$1(a, u, c, l, v, p, _, k) {
  var O = 0, D = u;
  D = D + l >>> 0, O += D < u ? 1 : 0, D = D + p >>> 0, O += D < p ? 1 : 0, D = D + k >>> 0, O += D < k ? 1 : 0;
  var F = a + c + v + _ + O;
  return F >>> 0;
}
utils$p.sum64_4_hi = sum64_4_hi$1;
function sum64_4_lo$1(a, u, c, l, v, p, _, k) {
  var O = u + l + p + k;
  return O >>> 0;
}
utils$p.sum64_4_lo = sum64_4_lo$1;
function sum64_5_hi$1(a, u, c, l, v, p, _, k, O, D) {
  var F = 0, H = u;
  H = H + l >>> 0, F += H < u ? 1 : 0, H = H + p >>> 0, F += H < p ? 1 : 0, H = H + k >>> 0, F += H < k ? 1 : 0, H = H + D >>> 0, F += H < D ? 1 : 0;
  var Z = a + c + v + _ + O + F;
  return Z >>> 0;
}
utils$p.sum64_5_hi = sum64_5_hi$1;
function sum64_5_lo$1(a, u, c, l, v, p, _, k, O, D) {
  var F = u + l + p + k + D;
  return F >>> 0;
}
utils$p.sum64_5_lo = sum64_5_lo$1;
function rotr64_hi$1(a, u, c) {
  var l = u << 32 - c | a >>> c;
  return l >>> 0;
}
utils$p.rotr64_hi = rotr64_hi$1;
function rotr64_lo$1(a, u, c) {
  var l = a << 32 - c | u >>> c;
  return l >>> 0;
}
utils$p.rotr64_lo = rotr64_lo$1;
function shr64_hi$1(a, u, c) {
  return a >>> c;
}
utils$p.shr64_hi = shr64_hi$1;
function shr64_lo$1(a, u, c) {
  var l = a << 32 - c | u >>> c;
  return l >>> 0;
}
utils$p.shr64_lo = shr64_lo$1;
var common$5 = {}, utils$o = utils$p, assert$a = minimalisticAssert;
function BlockHash$4() {
  this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
}
common$5.BlockHash = BlockHash$4;
BlockHash$4.prototype.update = function a(u, c) {
  if (u = utils$o.toArray(u, c), this.pending ? this.pending = this.pending.concat(u) : this.pending = u, this.pendingTotal += u.length, this.pending.length >= this._delta8) {
    u = this.pending;
    var l = u.length % this._delta8;
    this.pending = u.slice(u.length - l, u.length), this.pending.length === 0 && (this.pending = null), u = utils$o.join32(u, 0, u.length - l, this.endian);
    for (var v = 0; v < u.length; v += this._delta32)
      this._update(u, v, v + this._delta32);
  }
  return this;
};
BlockHash$4.prototype.digest = function a(u) {
  return this.update(this._pad()), assert$a(this.pending === null), this._digest(u);
};
BlockHash$4.prototype._pad = function a() {
  var u = this.pendingTotal, c = this._delta8, l = c - (u + this.padLength) % c, v = new Array(l + this.padLength);
  v[0] = 128;
  for (var p = 1; p < l; p++)
    v[p] = 0;
  if (u <<= 3, this.endian === "big") {
    for (var _ = 8; _ < this.padLength; _++)
      v[p++] = 0;
    v[p++] = 0, v[p++] = 0, v[p++] = 0, v[p++] = 0, v[p++] = u >>> 24 & 255, v[p++] = u >>> 16 & 255, v[p++] = u >>> 8 & 255, v[p++] = u & 255;
  } else
    for (v[p++] = u & 255, v[p++] = u >>> 8 & 255, v[p++] = u >>> 16 & 255, v[p++] = u >>> 24 & 255, v[p++] = 0, v[p++] = 0, v[p++] = 0, v[p++] = 0, _ = 8; _ < this.padLength; _++)
      v[p++] = 0;
  return v;
};
var sha = {}, common$4 = {}, utils$n = utils$p, rotr32 = utils$n.rotr32;
function ft_1$1(a, u, c, l) {
  if (a === 0)
    return ch32$1(u, c, l);
  if (a === 1 || a === 3)
    return p32(u, c, l);
  if (a === 2)
    return maj32$1(u, c, l);
}
common$4.ft_1 = ft_1$1;
function ch32$1(a, u, c) {
  return a & u ^ ~a & c;
}
common$4.ch32 = ch32$1;
function maj32$1(a, u, c) {
  return a & u ^ a & c ^ u & c;
}
common$4.maj32 = maj32$1;
function p32(a, u, c) {
  return a ^ u ^ c;
}
common$4.p32 = p32;
function s0_256$1(a) {
  return rotr32(a, 2) ^ rotr32(a, 13) ^ rotr32(a, 22);
}
common$4.s0_256 = s0_256$1;
function s1_256$1(a) {
  return rotr32(a, 6) ^ rotr32(a, 11) ^ rotr32(a, 25);
}
common$4.s1_256 = s1_256$1;
function g0_256$1(a) {
  return rotr32(a, 7) ^ rotr32(a, 18) ^ a >>> 3;
}
common$4.g0_256 = g0_256$1;
function g1_256$1(a) {
  return rotr32(a, 17) ^ rotr32(a, 19) ^ a >>> 10;
}
common$4.g1_256 = g1_256$1;
var utils$m = utils$p, common$3 = common$5, shaCommon$1 = common$4, rotl32$1 = utils$m.rotl32, sum32$2 = utils$m.sum32, sum32_5$1 = utils$m.sum32_5, ft_1 = shaCommon$1.ft_1, BlockHash$3 = common$3.BlockHash, sha1_K = [
  1518500249,
  1859775393,
  2400959708,
  3395469782
];
function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();
  BlockHash$3.call(this), this.h = [
    1732584193,
    4023233417,
    2562383102,
    271733878,
    3285377520
  ], this.W = new Array(80);
}
utils$m.inherits(SHA1, BlockHash$3);
var _1 = SHA1;
SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;
SHA1.prototype._update = function a(u, c) {
  for (var l = this.W, v = 0; v < 16; v++)
    l[v] = u[c + v];
  for (; v < l.length; v++)
    l[v] = rotl32$1(l[v - 3] ^ l[v - 8] ^ l[v - 14] ^ l[v - 16], 1);
  var p = this.h[0], _ = this.h[1], k = this.h[2], O = this.h[3], D = this.h[4];
  for (v = 0; v < l.length; v++) {
    var F = ~~(v / 20), H = sum32_5$1(rotl32$1(p, 5), ft_1(F, _, k, O), D, l[v], sha1_K[F]);
    D = O, O = k, k = rotl32$1(_, 30), _ = p, p = H;
  }
  this.h[0] = sum32$2(this.h[0], p), this.h[1] = sum32$2(this.h[1], _), this.h[2] = sum32$2(this.h[2], k), this.h[3] = sum32$2(this.h[3], O), this.h[4] = sum32$2(this.h[4], D);
};
SHA1.prototype._digest = function a(u) {
  return u === "hex" ? utils$m.toHex32(this.h, "big") : utils$m.split32(this.h, "big");
};
var utils$l = utils$p, common$2 = common$5, shaCommon = common$4, assert$9 = minimalisticAssert, sum32$1 = utils$l.sum32, sum32_4$1 = utils$l.sum32_4, sum32_5 = utils$l.sum32_5, ch32 = shaCommon.ch32, maj32 = shaCommon.maj32, s0_256 = shaCommon.s0_256, s1_256 = shaCommon.s1_256, g0_256 = shaCommon.g0_256, g1_256 = shaCommon.g1_256, BlockHash$2 = common$2.BlockHash, sha256_K = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
];
function SHA256$1() {
  if (!(this instanceof SHA256$1))
    return new SHA256$1();
  BlockHash$2.call(this), this.h = [
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ], this.k = sha256_K, this.W = new Array(64);
}
utils$l.inherits(SHA256$1, BlockHash$2);
var _256 = SHA256$1;
SHA256$1.blockSize = 512;
SHA256$1.outSize = 256;
SHA256$1.hmacStrength = 192;
SHA256$1.padLength = 64;
SHA256$1.prototype._update = function a(u, c) {
  for (var l = this.W, v = 0; v < 16; v++)
    l[v] = u[c + v];
  for (; v < l.length; v++)
    l[v] = sum32_4$1(g1_256(l[v - 2]), l[v - 7], g0_256(l[v - 15]), l[v - 16]);
  var p = this.h[0], _ = this.h[1], k = this.h[2], O = this.h[3], D = this.h[4], F = this.h[5], H = this.h[6], Z = this.h[7];
  for (assert$9(this.k.length === l.length), v = 0; v < l.length; v++) {
    var ee = sum32_5(Z, s1_256(D), ch32(D, F, H), this.k[v], l[v]), X = sum32$1(s0_256(p), maj32(p, _, k));
    Z = H, H = F, F = D, D = sum32$1(O, ee), O = k, k = _, _ = p, p = sum32$1(ee, X);
  }
  this.h[0] = sum32$1(this.h[0], p), this.h[1] = sum32$1(this.h[1], _), this.h[2] = sum32$1(this.h[2], k), this.h[3] = sum32$1(this.h[3], O), this.h[4] = sum32$1(this.h[4], D), this.h[5] = sum32$1(this.h[5], F), this.h[6] = sum32$1(this.h[6], H), this.h[7] = sum32$1(this.h[7], Z);
};
SHA256$1.prototype._digest = function a(u) {
  return u === "hex" ? utils$l.toHex32(this.h, "big") : utils$l.split32(this.h, "big");
};
var utils$k = utils$p, SHA256 = _256;
function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();
  SHA256.call(this), this.h = [
    3238371032,
    914150663,
    812702999,
    4144912697,
    4290775857,
    1750603025,
    1694076839,
    3204075428
  ];
}
utils$k.inherits(SHA224, SHA256);
var _224 = SHA224;
SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;
SHA224.prototype._digest = function a(u) {
  return u === "hex" ? utils$k.toHex32(this.h.slice(0, 7), "big") : utils$k.split32(this.h.slice(0, 7), "big");
};
var utils$j = utils$p, common$1 = common$5, assert$8 = minimalisticAssert, rotr64_hi = utils$j.rotr64_hi, rotr64_lo = utils$j.rotr64_lo, shr64_hi = utils$j.shr64_hi, shr64_lo = utils$j.shr64_lo, sum64 = utils$j.sum64, sum64_hi = utils$j.sum64_hi, sum64_lo = utils$j.sum64_lo, sum64_4_hi = utils$j.sum64_4_hi, sum64_4_lo = utils$j.sum64_4_lo, sum64_5_hi = utils$j.sum64_5_hi, sum64_5_lo = utils$j.sum64_5_lo, BlockHash$1 = common$1.BlockHash, sha512_K = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
];
function SHA512$1() {
  if (!(this instanceof SHA512$1))
    return new SHA512$1();
  BlockHash$1.call(this), this.h = [
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
  ], this.k = sha512_K, this.W = new Array(160);
}
utils$j.inherits(SHA512$1, BlockHash$1);
var _512 = SHA512$1;
SHA512$1.blockSize = 1024;
SHA512$1.outSize = 512;
SHA512$1.hmacStrength = 192;
SHA512$1.padLength = 128;
SHA512$1.prototype._prepareBlock = function a(u, c) {
  for (var l = this.W, v = 0; v < 32; v++)
    l[v] = u[c + v];
  for (; v < l.length; v += 2) {
    var p = g1_512_hi(l[v - 4], l[v - 3]), _ = g1_512_lo(l[v - 4], l[v - 3]), k = l[v - 14], O = l[v - 13], D = g0_512_hi(l[v - 30], l[v - 29]), F = g0_512_lo(l[v - 30], l[v - 29]), H = l[v - 32], Z = l[v - 31];
    l[v] = sum64_4_hi(
      p,
      _,
      k,
      O,
      D,
      F,
      H,
      Z
    ), l[v + 1] = sum64_4_lo(
      p,
      _,
      k,
      O,
      D,
      F,
      H,
      Z
    );
  }
};
SHA512$1.prototype._update = function a(u, c) {
  this._prepareBlock(u, c);
  var l = this.W, v = this.h[0], p = this.h[1], _ = this.h[2], k = this.h[3], O = this.h[4], D = this.h[5], F = this.h[6], H = this.h[7], Z = this.h[8], ee = this.h[9], X = this.h[10], ne = this.h[11], Q = this.h[12], ae = this.h[13], j = this.h[14], ue = this.h[15];
  assert$8(this.k.length === l.length);
  for (var he = 0; he < l.length; he += 2) {
    var fe = j, be = ue, ke = s1_512_hi(Z, ee), Te = s1_512_lo(Z, ee), q = ch64_hi(Z, ee, X, ne, Q), z = ch64_lo(Z, ee, X, ne, Q, ae), P = this.k[he], S = this.k[he + 1], E = l[he], I = l[he + 1], M = sum64_5_hi(
      fe,
      be,
      ke,
      Te,
      q,
      z,
      P,
      S,
      E,
      I
    ), $ = sum64_5_lo(
      fe,
      be,
      ke,
      Te,
      q,
      z,
      P,
      S,
      E,
      I
    );
    fe = s0_512_hi(v, p), be = s0_512_lo(v, p), ke = maj64_hi(v, p, _, k, O), Te = maj64_lo(v, p, _, k, O, D);
    var U = sum64_hi(fe, be, ke, Te), Y = sum64_lo(fe, be, ke, Te);
    j = Q, ue = ae, Q = X, ae = ne, X = Z, ne = ee, Z = sum64_hi(F, H, M, $), ee = sum64_lo(H, H, M, $), F = O, H = D, O = _, D = k, _ = v, k = p, v = sum64_hi(M, $, U, Y), p = sum64_lo(M, $, U, Y);
  }
  sum64(this.h, 0, v, p), sum64(this.h, 2, _, k), sum64(this.h, 4, O, D), sum64(this.h, 6, F, H), sum64(this.h, 8, Z, ee), sum64(this.h, 10, X, ne), sum64(this.h, 12, Q, ae), sum64(this.h, 14, j, ue);
};
SHA512$1.prototype._digest = function a(u) {
  return u === "hex" ? utils$j.toHex32(this.h, "big") : utils$j.split32(this.h, "big");
};
function ch64_hi(a, u, c, l, v) {
  var p = a & c ^ ~a & v;
  return p < 0 && (p += 4294967296), p;
}
function ch64_lo(a, u, c, l, v, p) {
  var _ = u & l ^ ~u & p;
  return _ < 0 && (_ += 4294967296), _;
}
function maj64_hi(a, u, c, l, v) {
  var p = a & c ^ a & v ^ c & v;
  return p < 0 && (p += 4294967296), p;
}
function maj64_lo(a, u, c, l, v, p) {
  var _ = u & l ^ u & p ^ l & p;
  return _ < 0 && (_ += 4294967296), _;
}
function s0_512_hi(a, u) {
  var c = rotr64_hi(a, u, 28), l = rotr64_hi(u, a, 2), v = rotr64_hi(u, a, 7), p = c ^ l ^ v;
  return p < 0 && (p += 4294967296), p;
}
function s0_512_lo(a, u) {
  var c = rotr64_lo(a, u, 28), l = rotr64_lo(u, a, 2), v = rotr64_lo(u, a, 7), p = c ^ l ^ v;
  return p < 0 && (p += 4294967296), p;
}
function s1_512_hi(a, u) {
  var c = rotr64_hi(a, u, 14), l = rotr64_hi(a, u, 18), v = rotr64_hi(u, a, 9), p = c ^ l ^ v;
  return p < 0 && (p += 4294967296), p;
}
function s1_512_lo(a, u) {
  var c = rotr64_lo(a, u, 14), l = rotr64_lo(a, u, 18), v = rotr64_lo(u, a, 9), p = c ^ l ^ v;
  return p < 0 && (p += 4294967296), p;
}
function g0_512_hi(a, u) {
  var c = rotr64_hi(a, u, 1), l = rotr64_hi(a, u, 8), v = shr64_hi(a, u, 7), p = c ^ l ^ v;
  return p < 0 && (p += 4294967296), p;
}
function g0_512_lo(a, u) {
  var c = rotr64_lo(a, u, 1), l = rotr64_lo(a, u, 8), v = shr64_lo(a, u, 7), p = c ^ l ^ v;
  return p < 0 && (p += 4294967296), p;
}
function g1_512_hi(a, u) {
  var c = rotr64_hi(a, u, 19), l = rotr64_hi(u, a, 29), v = shr64_hi(a, u, 6), p = c ^ l ^ v;
  return p < 0 && (p += 4294967296), p;
}
function g1_512_lo(a, u) {
  var c = rotr64_lo(a, u, 19), l = rotr64_lo(u, a, 29), v = shr64_lo(a, u, 6), p = c ^ l ^ v;
  return p < 0 && (p += 4294967296), p;
}
var utils$i = utils$p, SHA512 = _512;
function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();
  SHA512.call(this), this.h = [
    3418070365,
    3238371032,
    1654270250,
    914150663,
    2438529370,
    812702999,
    355462360,
    4144912697,
    1731405415,
    4290775857,
    2394180231,
    1750603025,
    3675008525,
    1694076839,
    1203062813,
    3204075428
  ];
}
utils$i.inherits(SHA384, SHA512);
var _384 = SHA384;
SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;
SHA384.prototype._digest = function a(u) {
  return u === "hex" ? utils$i.toHex32(this.h.slice(0, 12), "big") : utils$i.split32(this.h.slice(0, 12), "big");
};
sha.sha1 = _1;
sha.sha224 = _224;
sha.sha256 = _256;
sha.sha384 = _384;
sha.sha512 = _512;
var ripemd = {}, utils$h = utils$p, common = common$5, rotl32 = utils$h.rotl32, sum32 = utils$h.sum32, sum32_3 = utils$h.sum32_3, sum32_4 = utils$h.sum32_4, BlockHash = common.BlockHash;
function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();
  BlockHash.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
}
utils$h.inherits(RIPEMD160, BlockHash);
ripemd.ripemd160 = RIPEMD160;
RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;
RIPEMD160.prototype._update = function a(u, c) {
  for (var l = this.h[0], v = this.h[1], p = this.h[2], _ = this.h[3], k = this.h[4], O = l, D = v, F = p, H = _, Z = k, ee = 0; ee < 80; ee++) {
    var X = sum32(
      rotl32(
        sum32_4(l, f(ee, v, p, _), u[r[ee] + c], K(ee)),
        s$1[ee]
      ),
      k
    );
    l = k, k = _, _ = rotl32(p, 10), p = v, v = X, X = sum32(
      rotl32(
        sum32_4(O, f(79 - ee, D, F, H), u[rh[ee] + c], Kh(ee)),
        sh[ee]
      ),
      Z
    ), O = Z, Z = H, H = rotl32(F, 10), F = D, D = X;
  }
  X = sum32_3(this.h[1], p, H), this.h[1] = sum32_3(this.h[2], _, Z), this.h[2] = sum32_3(this.h[3], k, O), this.h[3] = sum32_3(this.h[4], l, D), this.h[4] = sum32_3(this.h[0], v, F), this.h[0] = X;
};
RIPEMD160.prototype._digest = function a(u) {
  return u === "hex" ? utils$h.toHex32(this.h, "little") : utils$h.split32(this.h, "little");
};
function f(a, u, c, l) {
  return a <= 15 ? u ^ c ^ l : a <= 31 ? u & c | ~u & l : a <= 47 ? (u | ~c) ^ l : a <= 63 ? u & l | c & ~l : u ^ (c | ~l);
}
function K(a) {
  return a <= 15 ? 0 : a <= 31 ? 1518500249 : a <= 47 ? 1859775393 : a <= 63 ? 2400959708 : 2840853838;
}
function Kh(a) {
  return a <= 15 ? 1352829926 : a <= 31 ? 1548603684 : a <= 47 ? 1836072691 : a <= 63 ? 2053994217 : 0;
}
var r = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
], rh = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
], s$1 = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
], sh = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
], utils$g = utils$p, assert$7 = minimalisticAssert;
function Hmac(a, u, c) {
  if (!(this instanceof Hmac))
    return new Hmac(a, u, c);
  this.Hash = a, this.blockSize = a.blockSize / 8, this.outSize = a.outSize / 8, this.inner = null, this.outer = null, this._init(utils$g.toArray(u, c));
}
var hmac = Hmac;
Hmac.prototype._init = function a(u) {
  u.length > this.blockSize && (u = new this.Hash().update(u).digest()), assert$7(u.length <= this.blockSize);
  for (var c = u.length; c < this.blockSize; c++)
    u.push(0);
  for (c = 0; c < u.length; c++)
    u[c] ^= 54;
  for (this.inner = new this.Hash().update(u), c = 0; c < u.length; c++)
    u[c] ^= 106;
  this.outer = new this.Hash().update(u);
};
Hmac.prototype.update = function a(u, c) {
  return this.inner.update(u, c), this;
};
Hmac.prototype.digest = function a(u) {
  return this.outer.update(this.inner.digest()), this.outer.digest(u);
};
(function(a) {
  var u = a;
  u.utils = utils$p, u.common = common$5, u.sha = sha, u.ripemd = ripemd, u.hmac = hmac, u.sha1 = u.sha.sha1, u.sha256 = u.sha.sha256, u.sha224 = u.sha.sha224, u.sha384 = u.sha.sha384, u.sha512 = u.sha.sha512, u.ripemd160 = u.ripemd.ripemd160;
})(hash$2);
var secp256k1, hasRequiredSecp256k1;
function requireSecp256k1() {
  return hasRequiredSecp256k1 || (hasRequiredSecp256k1 = 1, secp256k1 = {
    doubles: {
      step: 4,
      points: [
        [
          "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
          "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
        ],
        [
          "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
          "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
        ],
        [
          "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
          "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
        ],
        [
          "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
          "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
        ],
        [
          "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
          "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
        ],
        [
          "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
          "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
        ],
        [
          "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
          "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
        ],
        [
          "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
          "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
        ],
        [
          "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
          "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
        ],
        [
          "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
          "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
        ],
        [
          "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
          "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
        ],
        [
          "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
          "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
        ],
        [
          "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
          "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
        ],
        [
          "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
          "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
        ],
        [
          "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
          "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
        ],
        [
          "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
          "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
        ],
        [
          "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
          "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
        ],
        [
          "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
          "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
        ],
        [
          "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
          "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
        ],
        [
          "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
          "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
        ],
        [
          "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
          "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
        ],
        [
          "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
          "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
        ],
        [
          "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
          "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
        ],
        [
          "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
          "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
        ],
        [
          "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
          "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
        ],
        [
          "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
          "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
        ],
        [
          "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
          "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
        ],
        [
          "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
          "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
        ],
        [
          "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
          "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
        ],
        [
          "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
          "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
        ],
        [
          "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
          "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
        ],
        [
          "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
          "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
        ],
        [
          "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
          "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
        ],
        [
          "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
          "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
        ],
        [
          "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
          "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
        ],
        [
          "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
          "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
        ],
        [
          "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
          "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
        ],
        [
          "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
          "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
        ],
        [
          "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
          "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
        ],
        [
          "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
          "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
        ],
        [
          "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
          "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
        ],
        [
          "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
          "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
        ],
        [
          "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
          "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
        ],
        [
          "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
          "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
        ],
        [
          "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
          "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
        ],
        [
          "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
          "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
        ],
        [
          "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
          "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
        ],
        [
          "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
          "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
        ],
        [
          "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
          "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
        ],
        [
          "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
          "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
        ],
        [
          "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
          "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
        ],
        [
          "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
          "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
        ],
        [
          "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
          "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
        ],
        [
          "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
          "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
        ],
        [
          "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
          "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
        ],
        [
          "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
          "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
        ],
        [
          "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
          "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
        ],
        [
          "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
          "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
        ],
        [
          "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
          "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
        ],
        [
          "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
          "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
        ],
        [
          "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
          "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
        ],
        [
          "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
          "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
        ],
        [
          "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
          "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
        ],
        [
          "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
          "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
        ],
        [
          "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
          "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
        ]
      ]
    },
    naf: {
      wnd: 7,
      points: [
        [
          "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
          "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
        ],
        [
          "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
          "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
        ],
        [
          "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
          "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
        ],
        [
          "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
          "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
        ],
        [
          "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
          "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
        ],
        [
          "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
          "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
        ],
        [
          "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
          "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
        ],
        [
          "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
          "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
        ],
        [
          "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
          "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
        ],
        [
          "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
          "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
        ],
        [
          "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
          "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
        ],
        [
          "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
          "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
        ],
        [
          "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
          "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
        ],
        [
          "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
          "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
        ],
        [
          "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
          "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
        ],
        [
          "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
          "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
        ],
        [
          "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
          "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
        ],
        [
          "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
          "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
        ],
        [
          "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
          "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
        ],
        [
          "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
          "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
        ],
        [
          "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
          "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
        ],
        [
          "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
          "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
        ],
        [
          "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
          "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
        ],
        [
          "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
          "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
        ],
        [
          "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
          "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
        ],
        [
          "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
          "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
        ],
        [
          "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
          "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
        ],
        [
          "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
          "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
        ],
        [
          "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
          "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
        ],
        [
          "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
          "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
        ],
        [
          "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
          "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
        ],
        [
          "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
          "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
        ],
        [
          "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
          "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
        ],
        [
          "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
          "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
        ],
        [
          "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
          "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
        ],
        [
          "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
          "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
        ],
        [
          "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
          "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
        ],
        [
          "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
          "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
        ],
        [
          "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
          "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
        ],
        [
          "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
          "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
        ],
        [
          "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
          "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
        ],
        [
          "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
          "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
        ],
        [
          "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
          "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
        ],
        [
          "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
          "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
        ],
        [
          "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
          "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
        ],
        [
          "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
          "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
        ],
        [
          "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
          "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
        ],
        [
          "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
          "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
        ],
        [
          "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
          "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
        ],
        [
          "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
          "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
        ],
        [
          "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
          "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
        ],
        [
          "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
          "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
        ],
        [
          "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
          "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
        ],
        [
          "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
          "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
        ],
        [
          "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
          "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
        ],
        [
          "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
          "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
        ],
        [
          "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
          "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
        ],
        [
          "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
          "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
        ],
        [
          "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
          "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
        ],
        [
          "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
          "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
        ],
        [
          "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
          "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
        ],
        [
          "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
          "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
        ],
        [
          "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
          "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
        ],
        [
          "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
          "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
        ],
        [
          "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
          "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
        ],
        [
          "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
          "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
        ],
        [
          "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
          "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
        ],
        [
          "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
          "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
        ],
        [
          "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
          "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
        ],
        [
          "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
          "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
        ],
        [
          "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
          "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
        ],
        [
          "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
          "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
        ],
        [
          "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
          "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
        ],
        [
          "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
          "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
        ],
        [
          "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
          "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
        ],
        [
          "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
          "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
        ],
        [
          "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
          "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
        ],
        [
          "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
          "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
        ],
        [
          "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
          "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
        ],
        [
          "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
          "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
        ],
        [
          "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
          "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
        ],
        [
          "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
          "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
        ],
        [
          "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
          "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
        ],
        [
          "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
          "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
        ],
        [
          "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
          "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
        ],
        [
          "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
          "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
        ],
        [
          "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
          "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
        ],
        [
          "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
          "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
        ],
        [
          "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
          "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
        ],
        [
          "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
          "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
        ],
        [
          "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
          "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
        ],
        [
          "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
          "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
        ],
        [
          "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
          "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
        ],
        [
          "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
          "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
        ],
        [
          "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
          "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
        ],
        [
          "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
          "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
        ],
        [
          "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
          "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
        ],
        [
          "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
          "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
        ],
        [
          "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
          "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
        ],
        [
          "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
          "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
        ],
        [
          "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
          "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
        ],
        [
          "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
          "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
        ],
        [
          "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
          "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
        ],
        [
          "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
          "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
        ],
        [
          "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
          "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
        ],
        [
          "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
          "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
        ],
        [
          "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
          "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
        ],
        [
          "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
          "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
        ],
        [
          "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
          "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
        ],
        [
          "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
          "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
        ],
        [
          "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
          "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
        ],
        [
          "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
          "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
        ],
        [
          "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
          "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
        ],
        [
          "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
          "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
        ],
        [
          "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
          "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
        ],
        [
          "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
          "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
        ],
        [
          "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
          "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
        ],
        [
          "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
          "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
        ],
        [
          "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
          "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
        ],
        [
          "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
          "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
        ],
        [
          "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
          "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
        ],
        [
          "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
          "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
        ],
        [
          "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
          "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
        ],
        [
          "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
          "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
        ],
        [
          "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
          "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
        ],
        [
          "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
          "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
        ],
        [
          "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
          "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
        ]
      ]
    }
  }), secp256k1;
}
(function(a) {
  var u = a, c = hash$2, l = curve, v = utils$v, p = v.assert;
  function _(D) {
    D.type === "short" ? this.curve = new l.short(D) : D.type === "edwards" ? this.curve = new l.edwards(D) : this.curve = new l.mont(D), this.g = this.curve.g, this.n = this.curve.n, this.hash = D.hash, p(this.g.validate(), "Invalid curve"), p(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  u.PresetCurve = _;
  function k(D, F) {
    Object.defineProperty(u, D, {
      configurable: !0,
      enumerable: !0,
      get: function() {
        var H = new _(F);
        return Object.defineProperty(u, D, {
          configurable: !0,
          enumerable: !0,
          value: H
        }), H;
      }
    });
  }
  k("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: c.sha256,
    gRed: !1,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  }), k("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: c.sha256,
    gRed: !1,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  }), k("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: c.sha256,
    gRed: !1,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  }), k("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: c.sha384,
    gRed: !1,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  }), k("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: c.sha512,
    gRed: !1,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  }), k("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: c.sha256,
    gRed: !1,
    g: [
      "9"
    ]
  }), k("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    // -121665 * (121666^(-1)) (mod P)
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: c.sha256,
    gRed: !1,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      // 4/5
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var O;
  try {
    O = requireSecp256k1();
  } catch {
    O = void 0;
  }
  k("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: c.sha256,
    // Precomputed endomorphism
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: !1,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      O
    ]
  });
})(curves$1);
var hash$1 = hash$2, utils$f = utils$u, assert$6 = minimalisticAssert;
function HmacDRBG(a) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(a);
  this.hash = a.hash, this.predResist = !!a.predResist, this.outLen = this.hash.outSize, this.minEntropy = a.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
  var u = utils$f.toArray(a.entropy, a.entropyEnc || "hex"), c = utils$f.toArray(a.nonce, a.nonceEnc || "hex"), l = utils$f.toArray(a.pers, a.persEnc || "hex");
  assert$6(
    u.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._init(u, c, l);
}
var hmacDrbg = HmacDRBG;
HmacDRBG.prototype._init = function a(u, c, l) {
  var v = u.concat(c).concat(l);
  this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
  for (var p = 0; p < this.V.length; p++)
    this.K[p] = 0, this.V[p] = 1;
  this._update(v), this._reseed = 1, this.reseedInterval = 281474976710656;
};
HmacDRBG.prototype._hmac = function a() {
  return new hash$1.hmac(this.hash, this.K);
};
HmacDRBG.prototype._update = function a(u) {
  var c = this._hmac().update(this.V).update([0]);
  u && (c = c.update(u)), this.K = c.digest(), this.V = this._hmac().update(this.V).digest(), u && (this.K = this._hmac().update(this.V).update([1]).update(u).digest(), this.V = this._hmac().update(this.V).digest());
};
HmacDRBG.prototype.reseed = function a(u, c, l, v) {
  typeof c != "string" && (v = l, l = c, c = null), u = utils$f.toArray(u, c), l = utils$f.toArray(l, v), assert$6(
    u.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._update(u.concat(l || [])), this._reseed = 1;
};
HmacDRBG.prototype.generate = function a(u, c, l, v) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  typeof c != "string" && (v = l, l = c, c = null), l && (l = utils$f.toArray(l, v || "hex"), this._update(l));
  for (var p = []; p.length < u; )
    this.V = this._hmac().update(this.V).digest(), p = p.concat(this.V);
  var _ = p.slice(0, u);
  return this._update(l), this._reseed++, utils$f.encode(_, c);
};
var BN$5 = bnExports$3, utils$e = utils$v, assert$5 = utils$e.assert;
function KeyPair$2(a, u) {
  this.ec = a, this.priv = null, this.pub = null, u.priv && this._importPrivate(u.priv, u.privEnc), u.pub && this._importPublic(u.pub, u.pubEnc);
}
var key$2 = KeyPair$2;
KeyPair$2.fromPublic = function a(u, c, l) {
  return c instanceof KeyPair$2 ? c : new KeyPair$2(u, {
    pub: c,
    pubEnc: l
  });
};
KeyPair$2.fromPrivate = function a(u, c, l) {
  return c instanceof KeyPair$2 ? c : new KeyPair$2(u, {
    priv: c,
    privEnc: l
  });
};
KeyPair$2.prototype.validate = function a() {
  var u = this.getPublic();
  return u.isInfinity() ? { result: !1, reason: "Invalid public key" } : u.validate() ? u.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" };
};
KeyPair$2.prototype.getPublic = function a(u, c) {
  return typeof u == "string" && (c = u, u = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), c ? this.pub.encode(c, u) : this.pub;
};
KeyPair$2.prototype.getPrivate = function a(u) {
  return u === "hex" ? this.priv.toString(16, 2) : this.priv;
};
KeyPair$2.prototype._importPrivate = function a(u, c) {
  this.priv = new BN$5(u, c || 16), this.priv = this.priv.umod(this.ec.curve.n);
};
KeyPair$2.prototype._importPublic = function a(u, c) {
  if (u.x || u.y) {
    this.ec.curve.type === "mont" ? assert$5(u.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && assert$5(u.x && u.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(u.x, u.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(u, c);
};
KeyPair$2.prototype.derive = function a(u) {
  return u.validate() || assert$5(u.validate(), "public point not validated"), u.mul(this.priv).getX();
};
KeyPair$2.prototype.sign = function a(u, c, l) {
  return this.ec.sign(u, this, c, l);
};
KeyPair$2.prototype.verify = function a(u, c) {
  return this.ec.verify(u, c, this);
};
KeyPair$2.prototype.inspect = function a() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var BN$4 = bnExports$3, utils$d = utils$v, assert$4 = utils$d.assert;
function Signature$2(a, u) {
  if (a instanceof Signature$2)
    return a;
  this._importDER(a, u) || (assert$4(a.r && a.s, "Signature without r or s"), this.r = new BN$4(a.r, 16), this.s = new BN$4(a.s, 16), a.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = a.recoveryParam);
}
var signature$1 = Signature$2;
function Position() {
  this.place = 0;
}
function getLength(a, u) {
  var c = a[u.place++];
  if (!(c & 128))
    return c;
  var l = c & 15;
  if (l === 0 || l > 4)
    return !1;
  for (var v = 0, p = 0, _ = u.place; p < l; p++, _++)
    v <<= 8, v |= a[_], v >>>= 0;
  return v <= 127 ? !1 : (u.place = _, v);
}
function rmPadding(a) {
  for (var u = 0, c = a.length - 1; !a[u] && !(a[u + 1] & 128) && u < c; )
    u++;
  return u === 0 ? a : a.slice(u);
}
Signature$2.prototype._importDER = function a(u, c) {
  u = utils$d.toArray(u, c);
  var l = new Position();
  if (u[l.place++] !== 48)
    return !1;
  var v = getLength(u, l);
  if (v === !1 || v + l.place !== u.length || u[l.place++] !== 2)
    return !1;
  var p = getLength(u, l);
  if (p === !1)
    return !1;
  var _ = u.slice(l.place, p + l.place);
  if (l.place += p, u[l.place++] !== 2)
    return !1;
  var k = getLength(u, l);
  if (k === !1 || u.length !== k + l.place)
    return !1;
  var O = u.slice(l.place, k + l.place);
  if (_[0] === 0)
    if (_[1] & 128)
      _ = _.slice(1);
    else
      return !1;
  if (O[0] === 0)
    if (O[1] & 128)
      O = O.slice(1);
    else
      return !1;
  return this.r = new BN$4(_), this.s = new BN$4(O), this.recoveryParam = null, !0;
};
function constructLength(a, u) {
  if (u < 128) {
    a.push(u);
    return;
  }
  var c = 1 + (Math.log(u) / Math.LN2 >>> 3);
  for (a.push(c | 128); --c; )
    a.push(u >>> (c << 3) & 255);
  a.push(u);
}
Signature$2.prototype.toDER = function a(u) {
  var c = this.r.toArray(), l = this.s.toArray();
  for (c[0] & 128 && (c = [0].concat(c)), l[0] & 128 && (l = [0].concat(l)), c = rmPadding(c), l = rmPadding(l); !l[0] && !(l[1] & 128); )
    l = l.slice(1);
  var v = [2];
  constructLength(v, c.length), v = v.concat(c), v.push(2), constructLength(v, l.length);
  var p = v.concat(l), _ = [48];
  return constructLength(_, p.length), _ = _.concat(p), utils$d.encode(_, u);
};
var ec, hasRequiredEc;
function requireEc() {
  if (hasRequiredEc)
    return ec;
  hasRequiredEc = 1;
  var a = bnExports$3, u = hmacDrbg, c = utils$v, l = curves$1, v = requireBrorand(), p = c.assert, _ = key$2, k = signature$1;
  function O(D) {
    if (!(this instanceof O))
      return new O(D);
    typeof D == "string" && (p(
      Object.prototype.hasOwnProperty.call(l, D),
      "Unknown curve " + D
    ), D = l[D]), D instanceof l.PresetCurve && (D = { curve: D }), this.curve = D.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = D.curve.g, this.g.precompute(D.curve.n.bitLength() + 1), this.hash = D.hash || D.curve.hash;
  }
  return ec = O, O.prototype.keyPair = function(F) {
    return new _(this, F);
  }, O.prototype.keyFromPrivate = function(F, H) {
    return _.fromPrivate(this, F, H);
  }, O.prototype.keyFromPublic = function(F, H) {
    return _.fromPublic(this, F, H);
  }, O.prototype.genKeyPair = function(F) {
    F || (F = {});
    for (var H = new u({
      hash: this.hash,
      pers: F.pers,
      persEnc: F.persEnc || "utf8",
      entropy: F.entropy || v(this.hash.hmacStrength),
      entropyEnc: F.entropy && F.entropyEnc || "utf8",
      nonce: this.n.toArray()
    }), Z = this.n.byteLength(), ee = this.n.sub(new a(2)); ; ) {
      var X = new a(H.generate(Z));
      if (!(X.cmp(ee) > 0))
        return X.iaddn(1), this.keyFromPrivate(X);
    }
  }, O.prototype._truncateToN = function(F, H) {
    var Z = F.byteLength() * 8 - this.n.bitLength();
    return Z > 0 && (F = F.ushrn(Z)), !H && F.cmp(this.n) >= 0 ? F.sub(this.n) : F;
  }, O.prototype.sign = function(F, H, Z, ee) {
    typeof Z == "object" && (ee = Z, Z = null), ee || (ee = {}), H = this.keyFromPrivate(H, Z), F = this._truncateToN(new a(F, 16));
    for (var X = this.n.byteLength(), ne = H.getPrivate().toArray("be", X), Q = F.toArray("be", X), ae = new u({
      hash: this.hash,
      entropy: ne,
      nonce: Q,
      pers: ee.pers,
      persEnc: ee.persEnc || "utf8"
    }), j = this.n.sub(new a(1)), ue = 0; ; ue++) {
      var he = ee.k ? ee.k(ue) : new a(ae.generate(this.n.byteLength()));
      if (he = this._truncateToN(he, !0), !(he.cmpn(1) <= 0 || he.cmp(j) >= 0)) {
        var fe = this.g.mul(he);
        if (!fe.isInfinity()) {
          var be = fe.getX(), ke = be.umod(this.n);
          if (ke.cmpn(0) !== 0) {
            var Te = he.invm(this.n).mul(ke.mul(H.getPrivate()).iadd(F));
            if (Te = Te.umod(this.n), Te.cmpn(0) !== 0) {
              var q = (fe.getY().isOdd() ? 1 : 0) | (be.cmp(ke) !== 0 ? 2 : 0);
              return ee.canonical && Te.cmp(this.nh) > 0 && (Te = this.n.sub(Te), q ^= 1), new k({ r: ke, s: Te, recoveryParam: q });
            }
          }
        }
      }
    }
  }, O.prototype.verify = function(F, H, Z, ee) {
    F = this._truncateToN(new a(F, 16)), Z = this.keyFromPublic(Z, ee), H = new k(H, "hex");
    var X = H.r, ne = H.s;
    if (X.cmpn(1) < 0 || X.cmp(this.n) >= 0 || ne.cmpn(1) < 0 || ne.cmp(this.n) >= 0)
      return !1;
    var Q = ne.invm(this.n), ae = Q.mul(F).umod(this.n), j = Q.mul(X).umod(this.n), ue;
    return this.curve._maxwellTrick ? (ue = this.g.jmulAdd(ae, Z.getPublic(), j), ue.isInfinity() ? !1 : ue.eqXToP(X)) : (ue = this.g.mulAdd(ae, Z.getPublic(), j), ue.isInfinity() ? !1 : ue.getX().umod(this.n).cmp(X) === 0);
  }, O.prototype.recoverPubKey = function(D, F, H, Z) {
    p((3 & H) === H, "The recovery param is more than two bits"), F = new k(F, Z);
    var ee = this.n, X = new a(D), ne = F.r, Q = F.s, ae = H & 1, j = H >> 1;
    if (ne.cmp(this.curve.p.umod(this.curve.n)) >= 0 && j)
      throw new Error("Unable to find sencond key candinate");
    j ? ne = this.curve.pointFromX(ne.add(this.curve.n), ae) : ne = this.curve.pointFromX(ne, ae);
    var ue = F.r.invm(ee), he = ee.sub(X).mul(ue).umod(ee), fe = Q.mul(ue).umod(ee);
    return this.g.mulAdd(he, ne, fe);
  }, O.prototype.getKeyRecoveryParam = function(D, F, H, Z) {
    if (F = new k(F, Z), F.recoveryParam !== null)
      return F.recoveryParam;
    for (var ee = 0; ee < 4; ee++) {
      var X;
      try {
        X = this.recoverPubKey(D, F, ee);
      } catch {
        continue;
      }
      if (X.eq(H))
        return ee;
    }
    throw new Error("Unable to find valid recovery factor");
  }, ec;
}
var utils$c = utils$v, assert$3 = utils$c.assert, parseBytes$2 = utils$c.parseBytes, cachedProperty$1 = utils$c.cachedProperty;
function KeyPair$1(a, u) {
  this.eddsa = a, this._secret = parseBytes$2(u.secret), a.isPoint(u.pub) ? this._pub = u.pub : this._pubBytes = parseBytes$2(u.pub);
}
KeyPair$1.fromPublic = function a(u, c) {
  return c instanceof KeyPair$1 ? c : new KeyPair$1(u, { pub: c });
};
KeyPair$1.fromSecret = function a(u, c) {
  return c instanceof KeyPair$1 ? c : new KeyPair$1(u, { secret: c });
};
KeyPair$1.prototype.secret = function a() {
  return this._secret;
};
cachedProperty$1(KeyPair$1, "pubBytes", function a() {
  return this.eddsa.encodePoint(this.pub());
});
cachedProperty$1(KeyPair$1, "pub", function a() {
  return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
});
cachedProperty$1(KeyPair$1, "privBytes", function a() {
  var u = this.eddsa, c = this.hash(), l = u.encodingLength - 1, v = c.slice(0, u.encodingLength);
  return v[0] &= 248, v[l] &= 127, v[l] |= 64, v;
});
cachedProperty$1(KeyPair$1, "priv", function a() {
  return this.eddsa.decodeInt(this.privBytes());
});
cachedProperty$1(KeyPair$1, "hash", function a() {
  return this.eddsa.hash().update(this.secret()).digest();
});
cachedProperty$1(KeyPair$1, "messagePrefix", function a() {
  return this.hash().slice(this.eddsa.encodingLength);
});
KeyPair$1.prototype.sign = function a(u) {
  return assert$3(this._secret, "KeyPair can only verify"), this.eddsa.sign(u, this);
};
KeyPair$1.prototype.verify = function a(u, c) {
  return this.eddsa.verify(u, c, this);
};
KeyPair$1.prototype.getSecret = function a(u) {
  return assert$3(this._secret, "KeyPair is public only"), utils$c.encode(this.secret(), u);
};
KeyPair$1.prototype.getPublic = function a(u) {
  return utils$c.encode(this.pubBytes(), u);
};
var key$1 = KeyPair$1, BN$3 = bnExports$3, utils$b = utils$v, assert$2 = utils$b.assert, cachedProperty = utils$b.cachedProperty, parseBytes$1 = utils$b.parseBytes;
function Signature$1(a, u) {
  this.eddsa = a, typeof u != "object" && (u = parseBytes$1(u)), Array.isArray(u) && (u = {
    R: u.slice(0, a.encodingLength),
    S: u.slice(a.encodingLength)
  }), assert$2(u.R && u.S, "Signature without R or S"), a.isPoint(u.R) && (this._R = u.R), u.S instanceof BN$3 && (this._S = u.S), this._Rencoded = Array.isArray(u.R) ? u.R : u.Rencoded, this._Sencoded = Array.isArray(u.S) ? u.S : u.Sencoded;
}
cachedProperty(Signature$1, "S", function a() {
  return this.eddsa.decodeInt(this.Sencoded());
});
cachedProperty(Signature$1, "R", function a() {
  return this.eddsa.decodePoint(this.Rencoded());
});
cachedProperty(Signature$1, "Rencoded", function a() {
  return this.eddsa.encodePoint(this.R());
});
cachedProperty(Signature$1, "Sencoded", function a() {
  return this.eddsa.encodeInt(this.S());
});
Signature$1.prototype.toBytes = function a() {
  return this.Rencoded().concat(this.Sencoded());
};
Signature$1.prototype.toHex = function a() {
  return utils$b.encode(this.toBytes(), "hex").toUpperCase();
};
var signature = Signature$1, hash = hash$2, curves = curves$1, utils$a = utils$v, assert$1 = utils$a.assert, parseBytes = utils$a.parseBytes, KeyPair = key$1, Signature = signature;
function EDDSA(a) {
  if (assert$1(a === "ed25519", "only tested with ed25519 so far"), !(this instanceof EDDSA))
    return new EDDSA(a);
  a = curves[a].curve, this.curve = a, this.g = a.g, this.g.precompute(a.n.bitLength() + 1), this.pointClass = a.point().constructor, this.encodingLength = Math.ceil(a.n.bitLength() / 8), this.hash = hash.sha512;
}
var eddsa = EDDSA;
EDDSA.prototype.sign = function a(u, c) {
  u = parseBytes(u);
  var l = this.keyFromSecret(c), v = this.hashInt(l.messagePrefix(), u), p = this.g.mul(v), _ = this.encodePoint(p), k = this.hashInt(_, l.pubBytes(), u).mul(l.priv()), O = v.add(k).umod(this.curve.n);
  return this.makeSignature({ R: p, S: O, Rencoded: _ });
};
EDDSA.prototype.verify = function a(u, c, l) {
  u = parseBytes(u), c = this.makeSignature(c);
  var v = this.keyFromPublic(l), p = this.hashInt(c.Rencoded(), v.pubBytes(), u), _ = this.g.mul(c.S()), k = c.R().add(v.pub().mul(p));
  return k.eq(_);
};
EDDSA.prototype.hashInt = function a() {
  for (var u = this.hash(), c = 0; c < arguments.length; c++)
    u.update(arguments[c]);
  return utils$a.intFromLE(u.digest()).umod(this.curve.n);
};
EDDSA.prototype.keyFromPublic = function a(u) {
  return KeyPair.fromPublic(this, u);
};
EDDSA.prototype.keyFromSecret = function a(u) {
  return KeyPair.fromSecret(this, u);
};
EDDSA.prototype.makeSignature = function a(u) {
  return u instanceof Signature ? u : new Signature(this, u);
};
EDDSA.prototype.encodePoint = function a(u) {
  var c = u.getY().toArray("le", this.encodingLength);
  return c[this.encodingLength - 1] |= u.getX().isOdd() ? 128 : 0, c;
};
EDDSA.prototype.decodePoint = function a(u) {
  u = utils$a.parseBytes(u);
  var c = u.length - 1, l = u.slice(0, c).concat(u[c] & -129), v = (u[c] & 128) !== 0, p = utils$a.intFromLE(l);
  return this.curve.pointFromY(p, v);
};
EDDSA.prototype.encodeInt = function a(u) {
  return u.toArray("le", this.encodingLength);
};
EDDSA.prototype.decodeInt = function a(u) {
  return utils$a.intFromLE(u);
};
EDDSA.prototype.isPoint = function a(u) {
  return u instanceof this.pointClass;
};
var hasRequiredElliptic;
function requireElliptic() {
  return hasRequiredElliptic || (hasRequiredElliptic = 1, function(a) {
    var u = a;
    u.version = require$$0$1.version, u.utils = utils$v, u.rand = requireBrorand(), u.curve = curve, u.curves = curves$1, u.ec = requireEc(), u.eddsa = eddsa;
  }(elliptic)), elliptic;
}
var asn1$3 = {}, asn1$2 = {}, bn$2 = { exports: {} };
bn$2.exports;
(function(a) {
  (function(u, c) {
    function l(P, S) {
      if (!P)
        throw new Error(S || "Assertion failed");
    }
    function v(P, S) {
      P.super_ = S;
      var E = function() {
      };
      E.prototype = S.prototype, P.prototype = new E(), P.prototype.constructor = P;
    }
    function p(P, S, E) {
      if (p.isBN(P))
        return P;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, P !== null && ((S === "le" || S === "be") && (E = S, S = 10), this._init(P || 0, S || 10, E || "be"));
    }
    typeof u == "object" ? u.exports = p : c.BN = p, p.BN = p, p.wordSize = 26;
    var _;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? _ = window.Buffer : _ = require$$0$2.Buffer;
    } catch {
    }
    p.isBN = function(S) {
      return S instanceof p ? !0 : S !== null && typeof S == "object" && S.constructor.wordSize === p.wordSize && Array.isArray(S.words);
    }, p.max = function(S, E) {
      return S.cmp(E) > 0 ? S : E;
    }, p.min = function(S, E) {
      return S.cmp(E) < 0 ? S : E;
    }, p.prototype._init = function(S, E, I) {
      if (typeof S == "number")
        return this._initNumber(S, E, I);
      if (typeof S == "object")
        return this._initArray(S, E, I);
      E === "hex" && (E = 16), l(E === (E | 0) && E >= 2 && E <= 36), S = S.toString().replace(/\s+/g, "");
      var M = 0;
      S[0] === "-" && (M++, this.negative = 1), M < S.length && (E === 16 ? this._parseHex(S, M, I) : (this._parseBase(S, E, M), I === "le" && this._initArray(this.toArray(), E, I)));
    }, p.prototype._initNumber = function(S, E, I) {
      S < 0 && (this.negative = 1, S = -S), S < 67108864 ? (this.words = [S & 67108863], this.length = 1) : S < 4503599627370496 ? (this.words = [
        S & 67108863,
        S / 67108864 & 67108863
      ], this.length = 2) : (l(S < 9007199254740992), this.words = [
        S & 67108863,
        S / 67108864 & 67108863,
        1
      ], this.length = 3), I === "le" && this._initArray(this.toArray(), E, I);
    }, p.prototype._initArray = function(S, E, I) {
      if (l(typeof S.length == "number"), S.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(S.length / 3), this.words = new Array(this.length);
      for (var M = 0; M < this.length; M++)
        this.words[M] = 0;
      var $, U, Y = 0;
      if (I === "be")
        for (M = S.length - 1, $ = 0; M >= 0; M -= 3)
          U = S[M] | S[M - 1] << 8 | S[M - 2] << 16, this.words[$] |= U << Y & 67108863, this.words[$ + 1] = U >>> 26 - Y & 67108863, Y += 24, Y >= 26 && (Y -= 26, $++);
      else if (I === "le")
        for (M = 0, $ = 0; M < S.length; M += 3)
          U = S[M] | S[M + 1] << 8 | S[M + 2] << 16, this.words[$] |= U << Y & 67108863, this.words[$ + 1] = U >>> 26 - Y & 67108863, Y += 24, Y >= 26 && (Y -= 26, $++);
      return this.strip();
    };
    function k(P, S) {
      var E = P.charCodeAt(S);
      return E >= 65 && E <= 70 ? E - 55 : E >= 97 && E <= 102 ? E - 87 : E - 48 & 15;
    }
    function O(P, S, E) {
      var I = k(P, E);
      return E - 1 >= S && (I |= k(P, E - 1) << 4), I;
    }
    p.prototype._parseHex = function(S, E, I) {
      this.length = Math.ceil((S.length - E) / 6), this.words = new Array(this.length);
      for (var M = 0; M < this.length; M++)
        this.words[M] = 0;
      var $ = 0, U = 0, Y;
      if (I === "be")
        for (M = S.length - 1; M >= E; M -= 2)
          Y = O(S, E, M) << $, this.words[U] |= Y & 67108863, $ >= 18 ? ($ -= 18, U += 1, this.words[U] |= Y >>> 26) : $ += 8;
      else {
        var B = S.length - E;
        for (M = B % 2 === 0 ? E + 1 : E; M < S.length; M += 2)
          Y = O(S, E, M) << $, this.words[U] |= Y & 67108863, $ >= 18 ? ($ -= 18, U += 1, this.words[U] |= Y >>> 26) : $ += 8;
      }
      this.strip();
    };
    function D(P, S, E, I) {
      for (var M = 0, $ = Math.min(P.length, E), U = S; U < $; U++) {
        var Y = P.charCodeAt(U) - 48;
        M *= I, Y >= 49 ? M += Y - 49 + 10 : Y >= 17 ? M += Y - 17 + 10 : M += Y;
      }
      return M;
    }
    p.prototype._parseBase = function(S, E, I) {
      this.words = [0], this.length = 1;
      for (var M = 0, $ = 1; $ <= 67108863; $ *= E)
        M++;
      M--, $ = $ / E | 0;
      for (var U = S.length - I, Y = U % M, B = Math.min(U, U - Y) + I, T = 0, L = I; L < B; L += M)
        T = D(S, L, L + M, E), this.imuln($), this.words[0] + T < 67108864 ? this.words[0] += T : this._iaddn(T);
      if (Y !== 0) {
        var te = 1;
        for (T = D(S, L, S.length, E), L = 0; L < Y; L++)
          te *= E;
        this.imuln(te), this.words[0] + T < 67108864 ? this.words[0] += T : this._iaddn(T);
      }
      this.strip();
    }, p.prototype.copy = function(S) {
      S.words = new Array(this.length);
      for (var E = 0; E < this.length; E++)
        S.words[E] = this.words[E];
      S.length = this.length, S.negative = this.negative, S.red = this.red;
    }, p.prototype.clone = function() {
      var S = new p(null);
      return this.copy(S), S;
    }, p.prototype._expand = function(S) {
      for (; this.length < S; )
        this.words[this.length++] = 0;
      return this;
    }, p.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, p.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, p.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var F = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], H = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], Z = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    p.prototype.toString = function(S, E) {
      S = S || 10, E = E | 0 || 1;
      var I;
      if (S === 16 || S === "hex") {
        I = "";
        for (var M = 0, $ = 0, U = 0; U < this.length; U++) {
          var Y = this.words[U], B = ((Y << M | $) & 16777215).toString(16);
          $ = Y >>> 24 - M & 16777215, $ !== 0 || U !== this.length - 1 ? I = F[6 - B.length] + B + I : I = B + I, M += 2, M >= 26 && (M -= 26, U--);
        }
        for ($ !== 0 && (I = $.toString(16) + I); I.length % E !== 0; )
          I = "0" + I;
        return this.negative !== 0 && (I = "-" + I), I;
      }
      if (S === (S | 0) && S >= 2 && S <= 36) {
        var T = H[S], L = Z[S];
        I = "";
        var te = this.clone();
        for (te.negative = 0; !te.isZero(); ) {
          var me = te.modn(L).toString(S);
          te = te.idivn(L), te.isZero() ? I = me + I : I = F[T - me.length] + me + I;
        }
        for (this.isZero() && (I = "0" + I); I.length % E !== 0; )
          I = "0" + I;
        return this.negative !== 0 && (I = "-" + I), I;
      }
      l(!1, "Base should be between 2 and 36");
    }, p.prototype.toNumber = function() {
      var S = this.words[0];
      return this.length === 2 ? S += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? S += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && l(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -S : S;
    }, p.prototype.toJSON = function() {
      return this.toString(16);
    }, p.prototype.toBuffer = function(S, E) {
      return l(typeof _ < "u"), this.toArrayLike(_, S, E);
    }, p.prototype.toArray = function(S, E) {
      return this.toArrayLike(Array, S, E);
    }, p.prototype.toArrayLike = function(S, E, I) {
      var M = this.byteLength(), $ = I || Math.max(1, M);
      l(M <= $, "byte array longer than desired length"), l($ > 0, "Requested array length <= 0"), this.strip();
      var U = E === "le", Y = new S($), B, T, L = this.clone();
      if (U) {
        for (T = 0; !L.isZero(); T++)
          B = L.andln(255), L.iushrn(8), Y[T] = B;
        for (; T < $; T++)
          Y[T] = 0;
      } else {
        for (T = 0; T < $ - M; T++)
          Y[T] = 0;
        for (T = 0; !L.isZero(); T++)
          B = L.andln(255), L.iushrn(8), Y[$ - T - 1] = B;
      }
      return Y;
    }, Math.clz32 ? p.prototype._countBits = function(S) {
      return 32 - Math.clz32(S);
    } : p.prototype._countBits = function(S) {
      var E = S, I = 0;
      return E >= 4096 && (I += 13, E >>>= 13), E >= 64 && (I += 7, E >>>= 7), E >= 8 && (I += 4, E >>>= 4), E >= 2 && (I += 2, E >>>= 2), I + E;
    }, p.prototype._zeroBits = function(S) {
      if (S === 0)
        return 26;
      var E = S, I = 0;
      return E & 8191 || (I += 13, E >>>= 13), E & 127 || (I += 7, E >>>= 7), E & 15 || (I += 4, E >>>= 4), E & 3 || (I += 2, E >>>= 2), E & 1 || I++, I;
    }, p.prototype.bitLength = function() {
      var S = this.words[this.length - 1], E = this._countBits(S);
      return (this.length - 1) * 26 + E;
    };
    function ee(P) {
      for (var S = new Array(P.bitLength()), E = 0; E < S.length; E++) {
        var I = E / 26 | 0, M = E % 26;
        S[E] = (P.words[I] & 1 << M) >>> M;
      }
      return S;
    }
    p.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var S = 0, E = 0; E < this.length; E++) {
        var I = this._zeroBits(this.words[E]);
        if (S += I, I !== 26)
          break;
      }
      return S;
    }, p.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, p.prototype.toTwos = function(S) {
      return this.negative !== 0 ? this.abs().inotn(S).iaddn(1) : this.clone();
    }, p.prototype.fromTwos = function(S) {
      return this.testn(S - 1) ? this.notn(S).iaddn(1).ineg() : this.clone();
    }, p.prototype.isNeg = function() {
      return this.negative !== 0;
    }, p.prototype.neg = function() {
      return this.clone().ineg();
    }, p.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, p.prototype.iuor = function(S) {
      for (; this.length < S.length; )
        this.words[this.length++] = 0;
      for (var E = 0; E < S.length; E++)
        this.words[E] = this.words[E] | S.words[E];
      return this.strip();
    }, p.prototype.ior = function(S) {
      return l((this.negative | S.negative) === 0), this.iuor(S);
    }, p.prototype.or = function(S) {
      return this.length > S.length ? this.clone().ior(S) : S.clone().ior(this);
    }, p.prototype.uor = function(S) {
      return this.length > S.length ? this.clone().iuor(S) : S.clone().iuor(this);
    }, p.prototype.iuand = function(S) {
      var E;
      this.length > S.length ? E = S : E = this;
      for (var I = 0; I < E.length; I++)
        this.words[I] = this.words[I] & S.words[I];
      return this.length = E.length, this.strip();
    }, p.prototype.iand = function(S) {
      return l((this.negative | S.negative) === 0), this.iuand(S);
    }, p.prototype.and = function(S) {
      return this.length > S.length ? this.clone().iand(S) : S.clone().iand(this);
    }, p.prototype.uand = function(S) {
      return this.length > S.length ? this.clone().iuand(S) : S.clone().iuand(this);
    }, p.prototype.iuxor = function(S) {
      var E, I;
      this.length > S.length ? (E = this, I = S) : (E = S, I = this);
      for (var M = 0; M < I.length; M++)
        this.words[M] = E.words[M] ^ I.words[M];
      if (this !== E)
        for (; M < E.length; M++)
          this.words[M] = E.words[M];
      return this.length = E.length, this.strip();
    }, p.prototype.ixor = function(S) {
      return l((this.negative | S.negative) === 0), this.iuxor(S);
    }, p.prototype.xor = function(S) {
      return this.length > S.length ? this.clone().ixor(S) : S.clone().ixor(this);
    }, p.prototype.uxor = function(S) {
      return this.length > S.length ? this.clone().iuxor(S) : S.clone().iuxor(this);
    }, p.prototype.inotn = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = Math.ceil(S / 26) | 0, I = S % 26;
      this._expand(E), I > 0 && E--;
      for (var M = 0; M < E; M++)
        this.words[M] = ~this.words[M] & 67108863;
      return I > 0 && (this.words[M] = ~this.words[M] & 67108863 >> 26 - I), this.strip();
    }, p.prototype.notn = function(S) {
      return this.clone().inotn(S);
    }, p.prototype.setn = function(S, E) {
      l(typeof S == "number" && S >= 0);
      var I = S / 26 | 0, M = S % 26;
      return this._expand(I + 1), E ? this.words[I] = this.words[I] | 1 << M : this.words[I] = this.words[I] & ~(1 << M), this.strip();
    }, p.prototype.iadd = function(S) {
      var E;
      if (this.negative !== 0 && S.negative === 0)
        return this.negative = 0, E = this.isub(S), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && S.negative !== 0)
        return S.negative = 0, E = this.isub(S), S.negative = 1, E._normSign();
      var I, M;
      this.length > S.length ? (I = this, M = S) : (I = S, M = this);
      for (var $ = 0, U = 0; U < M.length; U++)
        E = (I.words[U] | 0) + (M.words[U] | 0) + $, this.words[U] = E & 67108863, $ = E >>> 26;
      for (; $ !== 0 && U < I.length; U++)
        E = (I.words[U] | 0) + $, this.words[U] = E & 67108863, $ = E >>> 26;
      if (this.length = I.length, $ !== 0)
        this.words[this.length] = $, this.length++;
      else if (I !== this)
        for (; U < I.length; U++)
          this.words[U] = I.words[U];
      return this;
    }, p.prototype.add = function(S) {
      var E;
      return S.negative !== 0 && this.negative === 0 ? (S.negative = 0, E = this.sub(S), S.negative ^= 1, E) : S.negative === 0 && this.negative !== 0 ? (this.negative = 0, E = S.sub(this), this.negative = 1, E) : this.length > S.length ? this.clone().iadd(S) : S.clone().iadd(this);
    }, p.prototype.isub = function(S) {
      if (S.negative !== 0) {
        S.negative = 0;
        var E = this.iadd(S);
        return S.negative = 1, E._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(S), this.negative = 1, this._normSign();
      var I = this.cmp(S);
      if (I === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var M, $;
      I > 0 ? (M = this, $ = S) : (M = S, $ = this);
      for (var U = 0, Y = 0; Y < $.length; Y++)
        E = (M.words[Y] | 0) - ($.words[Y] | 0) + U, U = E >> 26, this.words[Y] = E & 67108863;
      for (; U !== 0 && Y < M.length; Y++)
        E = (M.words[Y] | 0) + U, U = E >> 26, this.words[Y] = E & 67108863;
      if (U === 0 && Y < M.length && M !== this)
        for (; Y < M.length; Y++)
          this.words[Y] = M.words[Y];
      return this.length = Math.max(this.length, Y), M !== this && (this.negative = 1), this.strip();
    }, p.prototype.sub = function(S) {
      return this.clone().isub(S);
    };
    function X(P, S, E) {
      E.negative = S.negative ^ P.negative;
      var I = P.length + S.length | 0;
      E.length = I, I = I - 1 | 0;
      var M = P.words[0] | 0, $ = S.words[0] | 0, U = M * $, Y = U & 67108863, B = U / 67108864 | 0;
      E.words[0] = Y;
      for (var T = 1; T < I; T++) {
        for (var L = B >>> 26, te = B & 67108863, me = Math.min(T, S.length - 1), Ce = Math.max(0, T - P.length + 1); Ce <= me; Ce++) {
          var De = T - Ce | 0;
          M = P.words[De] | 0, $ = S.words[Ce] | 0, U = M * $ + te, L += U / 67108864 | 0, te = U & 67108863;
        }
        E.words[T] = te | 0, B = L | 0;
      }
      return B !== 0 ? E.words[T] = B | 0 : E.length--, E.strip();
    }
    var ne = function(S, E, I) {
      var M = S.words, $ = E.words, U = I.words, Y = 0, B, T, L, te = M[0] | 0, me = te & 8191, Ce = te >>> 13, De = M[1] | 0, ye = De & 8191, pe = De >>> 13, Me = M[2] | 0, Ne = Me & 8191, Ue = Me >>> 13, oe = M[3] | 0, A = oe & 8191, re = oe >>> 13, le = M[4] | 0, $e = le & 8191, Oe = le >>> 13, Fe = M[5] | 0, Ze = Fe & 8191, qe = Fe >>> 13, yt = M[6] | 0, Xe = yt & 8191, Ge = yt >>> 13, J = M[7] | 0, ge = J & 8191, we = J >>> 13, We = M[8] | 0, Ie = We & 8191, V = We >>> 13, Ee = M[9] | 0, de = Ee & 8191, ce = Ee >>> 13, ve = $[0] | 0, Pe = ve & 8191, Be = ve >>> 13, ze = $[1] | 0, Je = ze & 8191, je = ze >>> 13, Ke = $[2] | 0, x = Ke & 8191, se = Ke >>> 13, Se = $[3] | 0, xe = Se & 8191, Ae = Se >>> 13, Ye = $[4] | 0, et = Ye & 8191, dt = Ye >>> 13, St = $[5] | 0, tt = St & 8191, at = St >>> 13, kt = $[6] | 0, rt = kt & 8191, ut = kt >>> 13, wt = $[7] | 0, nt = wt & 8191, it = wt >>> 13, bt = $[8] | 0, ot = bt & 8191, ct = bt >>> 13, Pt = $[9] | 0, st = Pt & 8191, lt = Pt >>> 13;
      I.negative = S.negative ^ E.negative, I.length = 19, B = Math.imul(me, Pe), T = Math.imul(me, Be), T = T + Math.imul(Ce, Pe) | 0, L = Math.imul(Ce, Be);
      var It = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (It >>> 26) | 0, It &= 67108863, B = Math.imul(ye, Pe), T = Math.imul(ye, Be), T = T + Math.imul(pe, Pe) | 0, L = Math.imul(pe, Be), B = B + Math.imul(me, Je) | 0, T = T + Math.imul(me, je) | 0, T = T + Math.imul(Ce, Je) | 0, L = L + Math.imul(Ce, je) | 0;
      var Rt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (Rt >>> 26) | 0, Rt &= 67108863, B = Math.imul(Ne, Pe), T = Math.imul(Ne, Be), T = T + Math.imul(Ue, Pe) | 0, L = Math.imul(Ue, Be), B = B + Math.imul(ye, Je) | 0, T = T + Math.imul(ye, je) | 0, T = T + Math.imul(pe, Je) | 0, L = L + Math.imul(pe, je) | 0, B = B + Math.imul(me, x) | 0, T = T + Math.imul(me, se) | 0, T = T + Math.imul(Ce, x) | 0, L = L + Math.imul(Ce, se) | 0;
      var Ve = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, B = Math.imul(A, Pe), T = Math.imul(A, Be), T = T + Math.imul(re, Pe) | 0, L = Math.imul(re, Be), B = B + Math.imul(Ne, Je) | 0, T = T + Math.imul(Ne, je) | 0, T = T + Math.imul(Ue, Je) | 0, L = L + Math.imul(Ue, je) | 0, B = B + Math.imul(ye, x) | 0, T = T + Math.imul(ye, se) | 0, T = T + Math.imul(pe, x) | 0, L = L + Math.imul(pe, se) | 0, B = B + Math.imul(me, xe) | 0, T = T + Math.imul(me, Ae) | 0, T = T + Math.imul(Ce, xe) | 0, L = L + Math.imul(Ce, Ae) | 0;
      var He = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, B = Math.imul($e, Pe), T = Math.imul($e, Be), T = T + Math.imul(Oe, Pe) | 0, L = Math.imul(Oe, Be), B = B + Math.imul(A, Je) | 0, T = T + Math.imul(A, je) | 0, T = T + Math.imul(re, Je) | 0, L = L + Math.imul(re, je) | 0, B = B + Math.imul(Ne, x) | 0, T = T + Math.imul(Ne, se) | 0, T = T + Math.imul(Ue, x) | 0, L = L + Math.imul(Ue, se) | 0, B = B + Math.imul(ye, xe) | 0, T = T + Math.imul(ye, Ae) | 0, T = T + Math.imul(pe, xe) | 0, L = L + Math.imul(pe, Ae) | 0, B = B + Math.imul(me, et) | 0, T = T + Math.imul(me, dt) | 0, T = T + Math.imul(Ce, et) | 0, L = L + Math.imul(Ce, dt) | 0;
      var Qe = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, B = Math.imul(Ze, Pe), T = Math.imul(Ze, Be), T = T + Math.imul(qe, Pe) | 0, L = Math.imul(qe, Be), B = B + Math.imul($e, Je) | 0, T = T + Math.imul($e, je) | 0, T = T + Math.imul(Oe, Je) | 0, L = L + Math.imul(Oe, je) | 0, B = B + Math.imul(A, x) | 0, T = T + Math.imul(A, se) | 0, T = T + Math.imul(re, x) | 0, L = L + Math.imul(re, se) | 0, B = B + Math.imul(Ne, xe) | 0, T = T + Math.imul(Ne, Ae) | 0, T = T + Math.imul(Ue, xe) | 0, L = L + Math.imul(Ue, Ae) | 0, B = B + Math.imul(ye, et) | 0, T = T + Math.imul(ye, dt) | 0, T = T + Math.imul(pe, et) | 0, L = L + Math.imul(pe, dt) | 0, B = B + Math.imul(me, tt) | 0, T = T + Math.imul(me, at) | 0, T = T + Math.imul(Ce, tt) | 0, L = L + Math.imul(Ce, at) | 0;
      var pt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (pt >>> 26) | 0, pt &= 67108863, B = Math.imul(Xe, Pe), T = Math.imul(Xe, Be), T = T + Math.imul(Ge, Pe) | 0, L = Math.imul(Ge, Be), B = B + Math.imul(Ze, Je) | 0, T = T + Math.imul(Ze, je) | 0, T = T + Math.imul(qe, Je) | 0, L = L + Math.imul(qe, je) | 0, B = B + Math.imul($e, x) | 0, T = T + Math.imul($e, se) | 0, T = T + Math.imul(Oe, x) | 0, L = L + Math.imul(Oe, se) | 0, B = B + Math.imul(A, xe) | 0, T = T + Math.imul(A, Ae) | 0, T = T + Math.imul(re, xe) | 0, L = L + Math.imul(re, Ae) | 0, B = B + Math.imul(Ne, et) | 0, T = T + Math.imul(Ne, dt) | 0, T = T + Math.imul(Ue, et) | 0, L = L + Math.imul(Ue, dt) | 0, B = B + Math.imul(ye, tt) | 0, T = T + Math.imul(ye, at) | 0, T = T + Math.imul(pe, tt) | 0, L = L + Math.imul(pe, at) | 0, B = B + Math.imul(me, rt) | 0, T = T + Math.imul(me, ut) | 0, T = T + Math.imul(Ce, rt) | 0, L = L + Math.imul(Ce, ut) | 0;
      var mt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (mt >>> 26) | 0, mt &= 67108863, B = Math.imul(ge, Pe), T = Math.imul(ge, Be), T = T + Math.imul(we, Pe) | 0, L = Math.imul(we, Be), B = B + Math.imul(Xe, Je) | 0, T = T + Math.imul(Xe, je) | 0, T = T + Math.imul(Ge, Je) | 0, L = L + Math.imul(Ge, je) | 0, B = B + Math.imul(Ze, x) | 0, T = T + Math.imul(Ze, se) | 0, T = T + Math.imul(qe, x) | 0, L = L + Math.imul(qe, se) | 0, B = B + Math.imul($e, xe) | 0, T = T + Math.imul($e, Ae) | 0, T = T + Math.imul(Oe, xe) | 0, L = L + Math.imul(Oe, Ae) | 0, B = B + Math.imul(A, et) | 0, T = T + Math.imul(A, dt) | 0, T = T + Math.imul(re, et) | 0, L = L + Math.imul(re, dt) | 0, B = B + Math.imul(Ne, tt) | 0, T = T + Math.imul(Ne, at) | 0, T = T + Math.imul(Ue, tt) | 0, L = L + Math.imul(Ue, at) | 0, B = B + Math.imul(ye, rt) | 0, T = T + Math.imul(ye, ut) | 0, T = T + Math.imul(pe, rt) | 0, L = L + Math.imul(pe, ut) | 0, B = B + Math.imul(me, nt) | 0, T = T + Math.imul(me, it) | 0, T = T + Math.imul(Ce, nt) | 0, L = L + Math.imul(Ce, it) | 0;
      var vt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, B = Math.imul(Ie, Pe), T = Math.imul(Ie, Be), T = T + Math.imul(V, Pe) | 0, L = Math.imul(V, Be), B = B + Math.imul(ge, Je) | 0, T = T + Math.imul(ge, je) | 0, T = T + Math.imul(we, Je) | 0, L = L + Math.imul(we, je) | 0, B = B + Math.imul(Xe, x) | 0, T = T + Math.imul(Xe, se) | 0, T = T + Math.imul(Ge, x) | 0, L = L + Math.imul(Ge, se) | 0, B = B + Math.imul(Ze, xe) | 0, T = T + Math.imul(Ze, Ae) | 0, T = T + Math.imul(qe, xe) | 0, L = L + Math.imul(qe, Ae) | 0, B = B + Math.imul($e, et) | 0, T = T + Math.imul($e, dt) | 0, T = T + Math.imul(Oe, et) | 0, L = L + Math.imul(Oe, dt) | 0, B = B + Math.imul(A, tt) | 0, T = T + Math.imul(A, at) | 0, T = T + Math.imul(re, tt) | 0, L = L + Math.imul(re, at) | 0, B = B + Math.imul(Ne, rt) | 0, T = T + Math.imul(Ne, ut) | 0, T = T + Math.imul(Ue, rt) | 0, L = L + Math.imul(Ue, ut) | 0, B = B + Math.imul(ye, nt) | 0, T = T + Math.imul(ye, it) | 0, T = T + Math.imul(pe, nt) | 0, L = L + Math.imul(pe, it) | 0, B = B + Math.imul(me, ot) | 0, T = T + Math.imul(me, ct) | 0, T = T + Math.imul(Ce, ot) | 0, L = L + Math.imul(Ce, ct) | 0;
      var ht = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (ht >>> 26) | 0, ht &= 67108863, B = Math.imul(de, Pe), T = Math.imul(de, Be), T = T + Math.imul(ce, Pe) | 0, L = Math.imul(ce, Be), B = B + Math.imul(Ie, Je) | 0, T = T + Math.imul(Ie, je) | 0, T = T + Math.imul(V, Je) | 0, L = L + Math.imul(V, je) | 0, B = B + Math.imul(ge, x) | 0, T = T + Math.imul(ge, se) | 0, T = T + Math.imul(we, x) | 0, L = L + Math.imul(we, se) | 0, B = B + Math.imul(Xe, xe) | 0, T = T + Math.imul(Xe, Ae) | 0, T = T + Math.imul(Ge, xe) | 0, L = L + Math.imul(Ge, Ae) | 0, B = B + Math.imul(Ze, et) | 0, T = T + Math.imul(Ze, dt) | 0, T = T + Math.imul(qe, et) | 0, L = L + Math.imul(qe, dt) | 0, B = B + Math.imul($e, tt) | 0, T = T + Math.imul($e, at) | 0, T = T + Math.imul(Oe, tt) | 0, L = L + Math.imul(Oe, at) | 0, B = B + Math.imul(A, rt) | 0, T = T + Math.imul(A, ut) | 0, T = T + Math.imul(re, rt) | 0, L = L + Math.imul(re, ut) | 0, B = B + Math.imul(Ne, nt) | 0, T = T + Math.imul(Ne, it) | 0, T = T + Math.imul(Ue, nt) | 0, L = L + Math.imul(Ue, it) | 0, B = B + Math.imul(ye, ot) | 0, T = T + Math.imul(ye, ct) | 0, T = T + Math.imul(pe, ot) | 0, L = L + Math.imul(pe, ct) | 0, B = B + Math.imul(me, st) | 0, T = T + Math.imul(me, lt) | 0, T = T + Math.imul(Ce, st) | 0, L = L + Math.imul(Ce, lt) | 0;
      var Et = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, B = Math.imul(de, Je), T = Math.imul(de, je), T = T + Math.imul(ce, Je) | 0, L = Math.imul(ce, je), B = B + Math.imul(Ie, x) | 0, T = T + Math.imul(Ie, se) | 0, T = T + Math.imul(V, x) | 0, L = L + Math.imul(V, se) | 0, B = B + Math.imul(ge, xe) | 0, T = T + Math.imul(ge, Ae) | 0, T = T + Math.imul(we, xe) | 0, L = L + Math.imul(we, Ae) | 0, B = B + Math.imul(Xe, et) | 0, T = T + Math.imul(Xe, dt) | 0, T = T + Math.imul(Ge, et) | 0, L = L + Math.imul(Ge, dt) | 0, B = B + Math.imul(Ze, tt) | 0, T = T + Math.imul(Ze, at) | 0, T = T + Math.imul(qe, tt) | 0, L = L + Math.imul(qe, at) | 0, B = B + Math.imul($e, rt) | 0, T = T + Math.imul($e, ut) | 0, T = T + Math.imul(Oe, rt) | 0, L = L + Math.imul(Oe, ut) | 0, B = B + Math.imul(A, nt) | 0, T = T + Math.imul(A, it) | 0, T = T + Math.imul(re, nt) | 0, L = L + Math.imul(re, it) | 0, B = B + Math.imul(Ne, ot) | 0, T = T + Math.imul(Ne, ct) | 0, T = T + Math.imul(Ue, ot) | 0, L = L + Math.imul(Ue, ct) | 0, B = B + Math.imul(ye, st) | 0, T = T + Math.imul(ye, lt) | 0, T = T + Math.imul(pe, st) | 0, L = L + Math.imul(pe, lt) | 0;
      var Tt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (Tt >>> 26) | 0, Tt &= 67108863, B = Math.imul(de, x), T = Math.imul(de, se), T = T + Math.imul(ce, x) | 0, L = Math.imul(ce, se), B = B + Math.imul(Ie, xe) | 0, T = T + Math.imul(Ie, Ae) | 0, T = T + Math.imul(V, xe) | 0, L = L + Math.imul(V, Ae) | 0, B = B + Math.imul(ge, et) | 0, T = T + Math.imul(ge, dt) | 0, T = T + Math.imul(we, et) | 0, L = L + Math.imul(we, dt) | 0, B = B + Math.imul(Xe, tt) | 0, T = T + Math.imul(Xe, at) | 0, T = T + Math.imul(Ge, tt) | 0, L = L + Math.imul(Ge, at) | 0, B = B + Math.imul(Ze, rt) | 0, T = T + Math.imul(Ze, ut) | 0, T = T + Math.imul(qe, rt) | 0, L = L + Math.imul(qe, ut) | 0, B = B + Math.imul($e, nt) | 0, T = T + Math.imul($e, it) | 0, T = T + Math.imul(Oe, nt) | 0, L = L + Math.imul(Oe, it) | 0, B = B + Math.imul(A, ot) | 0, T = T + Math.imul(A, ct) | 0, T = T + Math.imul(re, ot) | 0, L = L + Math.imul(re, ct) | 0, B = B + Math.imul(Ne, st) | 0, T = T + Math.imul(Ne, lt) | 0, T = T + Math.imul(Ue, st) | 0, L = L + Math.imul(Ue, lt) | 0;
      var Ot = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (Ot >>> 26) | 0, Ot &= 67108863, B = Math.imul(de, xe), T = Math.imul(de, Ae), T = T + Math.imul(ce, xe) | 0, L = Math.imul(ce, Ae), B = B + Math.imul(Ie, et) | 0, T = T + Math.imul(Ie, dt) | 0, T = T + Math.imul(V, et) | 0, L = L + Math.imul(V, dt) | 0, B = B + Math.imul(ge, tt) | 0, T = T + Math.imul(ge, at) | 0, T = T + Math.imul(we, tt) | 0, L = L + Math.imul(we, at) | 0, B = B + Math.imul(Xe, rt) | 0, T = T + Math.imul(Xe, ut) | 0, T = T + Math.imul(Ge, rt) | 0, L = L + Math.imul(Ge, ut) | 0, B = B + Math.imul(Ze, nt) | 0, T = T + Math.imul(Ze, it) | 0, T = T + Math.imul(qe, nt) | 0, L = L + Math.imul(qe, it) | 0, B = B + Math.imul($e, ot) | 0, T = T + Math.imul($e, ct) | 0, T = T + Math.imul(Oe, ot) | 0, L = L + Math.imul(Oe, ct) | 0, B = B + Math.imul(A, st) | 0, T = T + Math.imul(A, lt) | 0, T = T + Math.imul(re, st) | 0, L = L + Math.imul(re, lt) | 0;
      var Nt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, B = Math.imul(de, et), T = Math.imul(de, dt), T = T + Math.imul(ce, et) | 0, L = Math.imul(ce, dt), B = B + Math.imul(Ie, tt) | 0, T = T + Math.imul(Ie, at) | 0, T = T + Math.imul(V, tt) | 0, L = L + Math.imul(V, at) | 0, B = B + Math.imul(ge, rt) | 0, T = T + Math.imul(ge, ut) | 0, T = T + Math.imul(we, rt) | 0, L = L + Math.imul(we, ut) | 0, B = B + Math.imul(Xe, nt) | 0, T = T + Math.imul(Xe, it) | 0, T = T + Math.imul(Ge, nt) | 0, L = L + Math.imul(Ge, it) | 0, B = B + Math.imul(Ze, ot) | 0, T = T + Math.imul(Ze, ct) | 0, T = T + Math.imul(qe, ot) | 0, L = L + Math.imul(qe, ct) | 0, B = B + Math.imul($e, st) | 0, T = T + Math.imul($e, lt) | 0, T = T + Math.imul(Oe, st) | 0, L = L + Math.imul(Oe, lt) | 0;
      var At = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, B = Math.imul(de, tt), T = Math.imul(de, at), T = T + Math.imul(ce, tt) | 0, L = Math.imul(ce, at), B = B + Math.imul(Ie, rt) | 0, T = T + Math.imul(Ie, ut) | 0, T = T + Math.imul(V, rt) | 0, L = L + Math.imul(V, ut) | 0, B = B + Math.imul(ge, nt) | 0, T = T + Math.imul(ge, it) | 0, T = T + Math.imul(we, nt) | 0, L = L + Math.imul(we, it) | 0, B = B + Math.imul(Xe, ot) | 0, T = T + Math.imul(Xe, ct) | 0, T = T + Math.imul(Ge, ot) | 0, L = L + Math.imul(Ge, ct) | 0, B = B + Math.imul(Ze, st) | 0, T = T + Math.imul(Ze, lt) | 0, T = T + Math.imul(qe, st) | 0, L = L + Math.imul(qe, lt) | 0;
      var Mt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (Mt >>> 26) | 0, Mt &= 67108863, B = Math.imul(de, rt), T = Math.imul(de, ut), T = T + Math.imul(ce, rt) | 0, L = Math.imul(ce, ut), B = B + Math.imul(Ie, nt) | 0, T = T + Math.imul(Ie, it) | 0, T = T + Math.imul(V, nt) | 0, L = L + Math.imul(V, it) | 0, B = B + Math.imul(ge, ot) | 0, T = T + Math.imul(ge, ct) | 0, T = T + Math.imul(we, ot) | 0, L = L + Math.imul(we, ct) | 0, B = B + Math.imul(Xe, st) | 0, T = T + Math.imul(Xe, lt) | 0, T = T + Math.imul(Ge, st) | 0, L = L + Math.imul(Ge, lt) | 0;
      var $t = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + ($t >>> 26) | 0, $t &= 67108863, B = Math.imul(de, nt), T = Math.imul(de, it), T = T + Math.imul(ce, nt) | 0, L = Math.imul(ce, it), B = B + Math.imul(Ie, ot) | 0, T = T + Math.imul(Ie, ct) | 0, T = T + Math.imul(V, ot) | 0, L = L + Math.imul(V, ct) | 0, B = B + Math.imul(ge, st) | 0, T = T + Math.imul(ge, lt) | 0, T = T + Math.imul(we, st) | 0, L = L + Math.imul(we, lt) | 0;
      var Bt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, B = Math.imul(de, ot), T = Math.imul(de, ct), T = T + Math.imul(ce, ot) | 0, L = Math.imul(ce, ct), B = B + Math.imul(Ie, st) | 0, T = T + Math.imul(Ie, lt) | 0, T = T + Math.imul(V, st) | 0, L = L + Math.imul(V, lt) | 0;
      var Ut = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (Ut >>> 26) | 0, Ut &= 67108863, B = Math.imul(de, st), T = Math.imul(de, lt), T = T + Math.imul(ce, st) | 0, L = Math.imul(ce, lt);
      var xt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      return Y = (L + (T >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, U[0] = It, U[1] = Rt, U[2] = Ve, U[3] = He, U[4] = Qe, U[5] = pt, U[6] = mt, U[7] = vt, U[8] = ht, U[9] = Et, U[10] = Tt, U[11] = Ot, U[12] = Nt, U[13] = At, U[14] = Mt, U[15] = $t, U[16] = Bt, U[17] = Ut, U[18] = xt, Y !== 0 && (U[19] = Y, I.length++), I;
    };
    Math.imul || (ne = X);
    function Q(P, S, E) {
      E.negative = S.negative ^ P.negative, E.length = P.length + S.length;
      for (var I = 0, M = 0, $ = 0; $ < E.length - 1; $++) {
        var U = M;
        M = 0;
        for (var Y = I & 67108863, B = Math.min($, S.length - 1), T = Math.max(0, $ - P.length + 1); T <= B; T++) {
          var L = $ - T, te = P.words[L] | 0, me = S.words[T] | 0, Ce = te * me, De = Ce & 67108863;
          U = U + (Ce / 67108864 | 0) | 0, De = De + Y | 0, Y = De & 67108863, U = U + (De >>> 26) | 0, M += U >>> 26, U &= 67108863;
        }
        E.words[$] = Y, I = U, U = M;
      }
      return I !== 0 ? E.words[$] = I : E.length--, E.strip();
    }
    function ae(P, S, E) {
      var I = new j();
      return I.mulp(P, S, E);
    }
    p.prototype.mulTo = function(S, E) {
      var I, M = this.length + S.length;
      return this.length === 10 && S.length === 10 ? I = ne(this, S, E) : M < 63 ? I = X(this, S, E) : M < 1024 ? I = Q(this, S, E) : I = ae(this, S, E), I;
    };
    function j(P, S) {
      this.x = P, this.y = S;
    }
    j.prototype.makeRBT = function(S) {
      for (var E = new Array(S), I = p.prototype._countBits(S) - 1, M = 0; M < S; M++)
        E[M] = this.revBin(M, I, S);
      return E;
    }, j.prototype.revBin = function(S, E, I) {
      if (S === 0 || S === I - 1)
        return S;
      for (var M = 0, $ = 0; $ < E; $++)
        M |= (S & 1) << E - $ - 1, S >>= 1;
      return M;
    }, j.prototype.permute = function(S, E, I, M, $, U) {
      for (var Y = 0; Y < U; Y++)
        M[Y] = E[S[Y]], $[Y] = I[S[Y]];
    }, j.prototype.transform = function(S, E, I, M, $, U) {
      this.permute(U, S, E, I, M, $);
      for (var Y = 1; Y < $; Y <<= 1)
        for (var B = Y << 1, T = Math.cos(2 * Math.PI / B), L = Math.sin(2 * Math.PI / B), te = 0; te < $; te += B)
          for (var me = T, Ce = L, De = 0; De < Y; De++) {
            var ye = I[te + De], pe = M[te + De], Me = I[te + De + Y], Ne = M[te + De + Y], Ue = me * Me - Ce * Ne;
            Ne = me * Ne + Ce * Me, Me = Ue, I[te + De] = ye + Me, M[te + De] = pe + Ne, I[te + De + Y] = ye - Me, M[te + De + Y] = pe - Ne, De !== B && (Ue = T * me - L * Ce, Ce = T * Ce + L * me, me = Ue);
          }
    }, j.prototype.guessLen13b = function(S, E) {
      var I = Math.max(E, S) | 1, M = I & 1, $ = 0;
      for (I = I / 2 | 0; I; I = I >>> 1)
        $++;
      return 1 << $ + 1 + M;
    }, j.prototype.conjugate = function(S, E, I) {
      if (!(I <= 1))
        for (var M = 0; M < I / 2; M++) {
          var $ = S[M];
          S[M] = S[I - M - 1], S[I - M - 1] = $, $ = E[M], E[M] = -E[I - M - 1], E[I - M - 1] = -$;
        }
    }, j.prototype.normalize13b = function(S, E) {
      for (var I = 0, M = 0; M < E / 2; M++) {
        var $ = Math.round(S[2 * M + 1] / E) * 8192 + Math.round(S[2 * M] / E) + I;
        S[M] = $ & 67108863, $ < 67108864 ? I = 0 : I = $ / 67108864 | 0;
      }
      return S;
    }, j.prototype.convert13b = function(S, E, I, M) {
      for (var $ = 0, U = 0; U < E; U++)
        $ = $ + (S[U] | 0), I[2 * U] = $ & 8191, $ = $ >>> 13, I[2 * U + 1] = $ & 8191, $ = $ >>> 13;
      for (U = 2 * E; U < M; ++U)
        I[U] = 0;
      l($ === 0), l(($ & -8192) === 0);
    }, j.prototype.stub = function(S) {
      for (var E = new Array(S), I = 0; I < S; I++)
        E[I] = 0;
      return E;
    }, j.prototype.mulp = function(S, E, I) {
      var M = 2 * this.guessLen13b(S.length, E.length), $ = this.makeRBT(M), U = this.stub(M), Y = new Array(M), B = new Array(M), T = new Array(M), L = new Array(M), te = new Array(M), me = new Array(M), Ce = I.words;
      Ce.length = M, this.convert13b(S.words, S.length, Y, M), this.convert13b(E.words, E.length, L, M), this.transform(Y, U, B, T, M, $), this.transform(L, U, te, me, M, $);
      for (var De = 0; De < M; De++) {
        var ye = B[De] * te[De] - T[De] * me[De];
        T[De] = B[De] * me[De] + T[De] * te[De], B[De] = ye;
      }
      return this.conjugate(B, T, M), this.transform(B, T, Ce, U, M, $), this.conjugate(Ce, U, M), this.normalize13b(Ce, M), I.negative = S.negative ^ E.negative, I.length = S.length + E.length, I.strip();
    }, p.prototype.mul = function(S) {
      var E = new p(null);
      return E.words = new Array(this.length + S.length), this.mulTo(S, E);
    }, p.prototype.mulf = function(S) {
      var E = new p(null);
      return E.words = new Array(this.length + S.length), ae(this, S, E);
    }, p.prototype.imul = function(S) {
      return this.clone().mulTo(S, this);
    }, p.prototype.imuln = function(S) {
      l(typeof S == "number"), l(S < 67108864);
      for (var E = 0, I = 0; I < this.length; I++) {
        var M = (this.words[I] | 0) * S, $ = (M & 67108863) + (E & 67108863);
        E >>= 26, E += M / 67108864 | 0, E += $ >>> 26, this.words[I] = $ & 67108863;
      }
      return E !== 0 && (this.words[I] = E, this.length++), this;
    }, p.prototype.muln = function(S) {
      return this.clone().imuln(S);
    }, p.prototype.sqr = function() {
      return this.mul(this);
    }, p.prototype.isqr = function() {
      return this.imul(this.clone());
    }, p.prototype.pow = function(S) {
      var E = ee(S);
      if (E.length === 0)
        return new p(1);
      for (var I = this, M = 0; M < E.length && E[M] === 0; M++, I = I.sqr())
        ;
      if (++M < E.length)
        for (var $ = I.sqr(); M < E.length; M++, $ = $.sqr())
          E[M] !== 0 && (I = I.mul($));
      return I;
    }, p.prototype.iushln = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = S % 26, I = (S - E) / 26, M = 67108863 >>> 26 - E << 26 - E, $;
      if (E !== 0) {
        var U = 0;
        for ($ = 0; $ < this.length; $++) {
          var Y = this.words[$] & M, B = (this.words[$] | 0) - Y << E;
          this.words[$] = B | U, U = Y >>> 26 - E;
        }
        U && (this.words[$] = U, this.length++);
      }
      if (I !== 0) {
        for ($ = this.length - 1; $ >= 0; $--)
          this.words[$ + I] = this.words[$];
        for ($ = 0; $ < I; $++)
          this.words[$] = 0;
        this.length += I;
      }
      return this.strip();
    }, p.prototype.ishln = function(S) {
      return l(this.negative === 0), this.iushln(S);
    }, p.prototype.iushrn = function(S, E, I) {
      l(typeof S == "number" && S >= 0);
      var M;
      E ? M = (E - E % 26) / 26 : M = 0;
      var $ = S % 26, U = Math.min((S - $) / 26, this.length), Y = 67108863 ^ 67108863 >>> $ << $, B = I;
      if (M -= U, M = Math.max(0, M), B) {
        for (var T = 0; T < U; T++)
          B.words[T] = this.words[T];
        B.length = U;
      }
      if (U !== 0)
        if (this.length > U)
          for (this.length -= U, T = 0; T < this.length; T++)
            this.words[T] = this.words[T + U];
        else
          this.words[0] = 0, this.length = 1;
      var L = 0;
      for (T = this.length - 1; T >= 0 && (L !== 0 || T >= M); T--) {
        var te = this.words[T] | 0;
        this.words[T] = L << 26 - $ | te >>> $, L = te & Y;
      }
      return B && L !== 0 && (B.words[B.length++] = L), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, p.prototype.ishrn = function(S, E, I) {
      return l(this.negative === 0), this.iushrn(S, E, I);
    }, p.prototype.shln = function(S) {
      return this.clone().ishln(S);
    }, p.prototype.ushln = function(S) {
      return this.clone().iushln(S);
    }, p.prototype.shrn = function(S) {
      return this.clone().ishrn(S);
    }, p.prototype.ushrn = function(S) {
      return this.clone().iushrn(S);
    }, p.prototype.testn = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = S % 26, I = (S - E) / 26, M = 1 << E;
      if (this.length <= I)
        return !1;
      var $ = this.words[I];
      return !!($ & M);
    }, p.prototype.imaskn = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = S % 26, I = (S - E) / 26;
      if (l(this.negative === 0, "imaskn works only with positive numbers"), this.length <= I)
        return this;
      if (E !== 0 && I++, this.length = Math.min(I, this.length), E !== 0) {
        var M = 67108863 ^ 67108863 >>> E << E;
        this.words[this.length - 1] &= M;
      }
      return this.strip();
    }, p.prototype.maskn = function(S) {
      return this.clone().imaskn(S);
    }, p.prototype.iaddn = function(S) {
      return l(typeof S == "number"), l(S < 67108864), S < 0 ? this.isubn(-S) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < S ? (this.words[0] = S - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(S), this.negative = 1, this) : this._iaddn(S);
    }, p.prototype._iaddn = function(S) {
      this.words[0] += S;
      for (var E = 0; E < this.length && this.words[E] >= 67108864; E++)
        this.words[E] -= 67108864, E === this.length - 1 ? this.words[E + 1] = 1 : this.words[E + 1]++;
      return this.length = Math.max(this.length, E + 1), this;
    }, p.prototype.isubn = function(S) {
      if (l(typeof S == "number"), l(S < 67108864), S < 0)
        return this.iaddn(-S);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(S), this.negative = 1, this;
      if (this.words[0] -= S, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var E = 0; E < this.length && this.words[E] < 0; E++)
          this.words[E] += 67108864, this.words[E + 1] -= 1;
      return this.strip();
    }, p.prototype.addn = function(S) {
      return this.clone().iaddn(S);
    }, p.prototype.subn = function(S) {
      return this.clone().isubn(S);
    }, p.prototype.iabs = function() {
      return this.negative = 0, this;
    }, p.prototype.abs = function() {
      return this.clone().iabs();
    }, p.prototype._ishlnsubmul = function(S, E, I) {
      var M = S.length + I, $;
      this._expand(M);
      var U, Y = 0;
      for ($ = 0; $ < S.length; $++) {
        U = (this.words[$ + I] | 0) + Y;
        var B = (S.words[$] | 0) * E;
        U -= B & 67108863, Y = (U >> 26) - (B / 67108864 | 0), this.words[$ + I] = U & 67108863;
      }
      for (; $ < this.length - I; $++)
        U = (this.words[$ + I] | 0) + Y, Y = U >> 26, this.words[$ + I] = U & 67108863;
      if (Y === 0)
        return this.strip();
      for (l(Y === -1), Y = 0, $ = 0; $ < this.length; $++)
        U = -(this.words[$] | 0) + Y, Y = U >> 26, this.words[$] = U & 67108863;
      return this.negative = 1, this.strip();
    }, p.prototype._wordDiv = function(S, E) {
      var I = this.length - S.length, M = this.clone(), $ = S, U = $.words[$.length - 1] | 0, Y = this._countBits(U);
      I = 26 - Y, I !== 0 && ($ = $.ushln(I), M.iushln(I), U = $.words[$.length - 1] | 0);
      var B = M.length - $.length, T;
      if (E !== "mod") {
        T = new p(null), T.length = B + 1, T.words = new Array(T.length);
        for (var L = 0; L < T.length; L++)
          T.words[L] = 0;
      }
      var te = M.clone()._ishlnsubmul($, 1, B);
      te.negative === 0 && (M = te, T && (T.words[B] = 1));
      for (var me = B - 1; me >= 0; me--) {
        var Ce = (M.words[$.length + me] | 0) * 67108864 + (M.words[$.length + me - 1] | 0);
        for (Ce = Math.min(Ce / U | 0, 67108863), M._ishlnsubmul($, Ce, me); M.negative !== 0; )
          Ce--, M.negative = 0, M._ishlnsubmul($, 1, me), M.isZero() || (M.negative ^= 1);
        T && (T.words[me] = Ce);
      }
      return T && T.strip(), M.strip(), E !== "div" && I !== 0 && M.iushrn(I), {
        div: T || null,
        mod: M
      };
    }, p.prototype.divmod = function(S, E, I) {
      if (l(!S.isZero()), this.isZero())
        return {
          div: new p(0),
          mod: new p(0)
        };
      var M, $, U;
      return this.negative !== 0 && S.negative === 0 ? (U = this.neg().divmod(S, E), E !== "mod" && (M = U.div.neg()), E !== "div" && ($ = U.mod.neg(), I && $.negative !== 0 && $.iadd(S)), {
        div: M,
        mod: $
      }) : this.negative === 0 && S.negative !== 0 ? (U = this.divmod(S.neg(), E), E !== "mod" && (M = U.div.neg()), {
        div: M,
        mod: U.mod
      }) : this.negative & S.negative ? (U = this.neg().divmod(S.neg(), E), E !== "div" && ($ = U.mod.neg(), I && $.negative !== 0 && $.isub(S)), {
        div: U.div,
        mod: $
      }) : S.length > this.length || this.cmp(S) < 0 ? {
        div: new p(0),
        mod: this
      } : S.length === 1 ? E === "div" ? {
        div: this.divn(S.words[0]),
        mod: null
      } : E === "mod" ? {
        div: null,
        mod: new p(this.modn(S.words[0]))
      } : {
        div: this.divn(S.words[0]),
        mod: new p(this.modn(S.words[0]))
      } : this._wordDiv(S, E);
    }, p.prototype.div = function(S) {
      return this.divmod(S, "div", !1).div;
    }, p.prototype.mod = function(S) {
      return this.divmod(S, "mod", !1).mod;
    }, p.prototype.umod = function(S) {
      return this.divmod(S, "mod", !0).mod;
    }, p.prototype.divRound = function(S) {
      var E = this.divmod(S);
      if (E.mod.isZero())
        return E.div;
      var I = E.div.negative !== 0 ? E.mod.isub(S) : E.mod, M = S.ushrn(1), $ = S.andln(1), U = I.cmp(M);
      return U < 0 || $ === 1 && U === 0 ? E.div : E.div.negative !== 0 ? E.div.isubn(1) : E.div.iaddn(1);
    }, p.prototype.modn = function(S) {
      l(S <= 67108863);
      for (var E = (1 << 26) % S, I = 0, M = this.length - 1; M >= 0; M--)
        I = (E * I + (this.words[M] | 0)) % S;
      return I;
    }, p.prototype.idivn = function(S) {
      l(S <= 67108863);
      for (var E = 0, I = this.length - 1; I >= 0; I--) {
        var M = (this.words[I] | 0) + E * 67108864;
        this.words[I] = M / S | 0, E = M % S;
      }
      return this.strip();
    }, p.prototype.divn = function(S) {
      return this.clone().idivn(S);
    }, p.prototype.egcd = function(S) {
      l(S.negative === 0), l(!S.isZero());
      var E = this, I = S.clone();
      E.negative !== 0 ? E = E.umod(S) : E = E.clone();
      for (var M = new p(1), $ = new p(0), U = new p(0), Y = new p(1), B = 0; E.isEven() && I.isEven(); )
        E.iushrn(1), I.iushrn(1), ++B;
      for (var T = I.clone(), L = E.clone(); !E.isZero(); ) {
        for (var te = 0, me = 1; !(E.words[0] & me) && te < 26; ++te, me <<= 1)
          ;
        if (te > 0)
          for (E.iushrn(te); te-- > 0; )
            (M.isOdd() || $.isOdd()) && (M.iadd(T), $.isub(L)), M.iushrn(1), $.iushrn(1);
        for (var Ce = 0, De = 1; !(I.words[0] & De) && Ce < 26; ++Ce, De <<= 1)
          ;
        if (Ce > 0)
          for (I.iushrn(Ce); Ce-- > 0; )
            (U.isOdd() || Y.isOdd()) && (U.iadd(T), Y.isub(L)), U.iushrn(1), Y.iushrn(1);
        E.cmp(I) >= 0 ? (E.isub(I), M.isub(U), $.isub(Y)) : (I.isub(E), U.isub(M), Y.isub($));
      }
      return {
        a: U,
        b: Y,
        gcd: I.iushln(B)
      };
    }, p.prototype._invmp = function(S) {
      l(S.negative === 0), l(!S.isZero());
      var E = this, I = S.clone();
      E.negative !== 0 ? E = E.umod(S) : E = E.clone();
      for (var M = new p(1), $ = new p(0), U = I.clone(); E.cmpn(1) > 0 && I.cmpn(1) > 0; ) {
        for (var Y = 0, B = 1; !(E.words[0] & B) && Y < 26; ++Y, B <<= 1)
          ;
        if (Y > 0)
          for (E.iushrn(Y); Y-- > 0; )
            M.isOdd() && M.iadd(U), M.iushrn(1);
        for (var T = 0, L = 1; !(I.words[0] & L) && T < 26; ++T, L <<= 1)
          ;
        if (T > 0)
          for (I.iushrn(T); T-- > 0; )
            $.isOdd() && $.iadd(U), $.iushrn(1);
        E.cmp(I) >= 0 ? (E.isub(I), M.isub($)) : (I.isub(E), $.isub(M));
      }
      var te;
      return E.cmpn(1) === 0 ? te = M : te = $, te.cmpn(0) < 0 && te.iadd(S), te;
    }, p.prototype.gcd = function(S) {
      if (this.isZero())
        return S.abs();
      if (S.isZero())
        return this.abs();
      var E = this.clone(), I = S.clone();
      E.negative = 0, I.negative = 0;
      for (var M = 0; E.isEven() && I.isEven(); M++)
        E.iushrn(1), I.iushrn(1);
      do {
        for (; E.isEven(); )
          E.iushrn(1);
        for (; I.isEven(); )
          I.iushrn(1);
        var $ = E.cmp(I);
        if ($ < 0) {
          var U = E;
          E = I, I = U;
        } else if ($ === 0 || I.cmpn(1) === 0)
          break;
        E.isub(I);
      } while (!0);
      return I.iushln(M);
    }, p.prototype.invm = function(S) {
      return this.egcd(S).a.umod(S);
    }, p.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, p.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, p.prototype.andln = function(S) {
      return this.words[0] & S;
    }, p.prototype.bincn = function(S) {
      l(typeof S == "number");
      var E = S % 26, I = (S - E) / 26, M = 1 << E;
      if (this.length <= I)
        return this._expand(I + 1), this.words[I] |= M, this;
      for (var $ = M, U = I; $ !== 0 && U < this.length; U++) {
        var Y = this.words[U] | 0;
        Y += $, $ = Y >>> 26, Y &= 67108863, this.words[U] = Y;
      }
      return $ !== 0 && (this.words[U] = $, this.length++), this;
    }, p.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, p.prototype.cmpn = function(S) {
      var E = S < 0;
      if (this.negative !== 0 && !E)
        return -1;
      if (this.negative === 0 && E)
        return 1;
      this.strip();
      var I;
      if (this.length > 1)
        I = 1;
      else {
        E && (S = -S), l(S <= 67108863, "Number is too big");
        var M = this.words[0] | 0;
        I = M === S ? 0 : M < S ? -1 : 1;
      }
      return this.negative !== 0 ? -I | 0 : I;
    }, p.prototype.cmp = function(S) {
      if (this.negative !== 0 && S.negative === 0)
        return -1;
      if (this.negative === 0 && S.negative !== 0)
        return 1;
      var E = this.ucmp(S);
      return this.negative !== 0 ? -E | 0 : E;
    }, p.prototype.ucmp = function(S) {
      if (this.length > S.length)
        return 1;
      if (this.length < S.length)
        return -1;
      for (var E = 0, I = this.length - 1; I >= 0; I--) {
        var M = this.words[I] | 0, $ = S.words[I] | 0;
        if (M !== $) {
          M < $ ? E = -1 : M > $ && (E = 1);
          break;
        }
      }
      return E;
    }, p.prototype.gtn = function(S) {
      return this.cmpn(S) === 1;
    }, p.prototype.gt = function(S) {
      return this.cmp(S) === 1;
    }, p.prototype.gten = function(S) {
      return this.cmpn(S) >= 0;
    }, p.prototype.gte = function(S) {
      return this.cmp(S) >= 0;
    }, p.prototype.ltn = function(S) {
      return this.cmpn(S) === -1;
    }, p.prototype.lt = function(S) {
      return this.cmp(S) === -1;
    }, p.prototype.lten = function(S) {
      return this.cmpn(S) <= 0;
    }, p.prototype.lte = function(S) {
      return this.cmp(S) <= 0;
    }, p.prototype.eqn = function(S) {
      return this.cmpn(S) === 0;
    }, p.prototype.eq = function(S) {
      return this.cmp(S) === 0;
    }, p.red = function(S) {
      return new q(S);
    }, p.prototype.toRed = function(S) {
      return l(!this.red, "Already a number in reduction context"), l(this.negative === 0, "red works only with positives"), S.convertTo(this)._forceRed(S);
    }, p.prototype.fromRed = function() {
      return l(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, p.prototype._forceRed = function(S) {
      return this.red = S, this;
    }, p.prototype.forceRed = function(S) {
      return l(!this.red, "Already a number in reduction context"), this._forceRed(S);
    }, p.prototype.redAdd = function(S) {
      return l(this.red, "redAdd works only with red numbers"), this.red.add(this, S);
    }, p.prototype.redIAdd = function(S) {
      return l(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, S);
    }, p.prototype.redSub = function(S) {
      return l(this.red, "redSub works only with red numbers"), this.red.sub(this, S);
    }, p.prototype.redISub = function(S) {
      return l(this.red, "redISub works only with red numbers"), this.red.isub(this, S);
    }, p.prototype.redShl = function(S) {
      return l(this.red, "redShl works only with red numbers"), this.red.shl(this, S);
    }, p.prototype.redMul = function(S) {
      return l(this.red, "redMul works only with red numbers"), this.red._verify2(this, S), this.red.mul(this, S);
    }, p.prototype.redIMul = function(S) {
      return l(this.red, "redMul works only with red numbers"), this.red._verify2(this, S), this.red.imul(this, S);
    }, p.prototype.redSqr = function() {
      return l(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, p.prototype.redISqr = function() {
      return l(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, p.prototype.redSqrt = function() {
      return l(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, p.prototype.redInvm = function() {
      return l(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, p.prototype.redNeg = function() {
      return l(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, p.prototype.redPow = function(S) {
      return l(this.red && !S.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, S);
    };
    var ue = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function he(P, S) {
      this.name = P, this.p = new p(S, 16), this.n = this.p.bitLength(), this.k = new p(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    he.prototype._tmp = function() {
      var S = new p(null);
      return S.words = new Array(Math.ceil(this.n / 13)), S;
    }, he.prototype.ireduce = function(S) {
      var E = S, I;
      do
        this.split(E, this.tmp), E = this.imulK(E), E = E.iadd(this.tmp), I = E.bitLength();
      while (I > this.n);
      var M = I < this.n ? -1 : E.ucmp(this.p);
      return M === 0 ? (E.words[0] = 0, E.length = 1) : M > 0 ? E.isub(this.p) : E.strip !== void 0 ? E.strip() : E._strip(), E;
    }, he.prototype.split = function(S, E) {
      S.iushrn(this.n, 0, E);
    }, he.prototype.imulK = function(S) {
      return S.imul(this.k);
    };
    function fe() {
      he.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    v(fe, he), fe.prototype.split = function(S, E) {
      for (var I = 4194303, M = Math.min(S.length, 9), $ = 0; $ < M; $++)
        E.words[$] = S.words[$];
      if (E.length = M, S.length <= 9) {
        S.words[0] = 0, S.length = 1;
        return;
      }
      var U = S.words[9];
      for (E.words[E.length++] = U & I, $ = 10; $ < S.length; $++) {
        var Y = S.words[$] | 0;
        S.words[$ - 10] = (Y & I) << 4 | U >>> 22, U = Y;
      }
      U >>>= 22, S.words[$ - 10] = U, U === 0 && S.length > 10 ? S.length -= 10 : S.length -= 9;
    }, fe.prototype.imulK = function(S) {
      S.words[S.length] = 0, S.words[S.length + 1] = 0, S.length += 2;
      for (var E = 0, I = 0; I < S.length; I++) {
        var M = S.words[I] | 0;
        E += M * 977, S.words[I] = E & 67108863, E = M * 64 + (E / 67108864 | 0);
      }
      return S.words[S.length - 1] === 0 && (S.length--, S.words[S.length - 1] === 0 && S.length--), S;
    };
    function be() {
      he.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    v(be, he);
    function ke() {
      he.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    v(ke, he);
    function Te() {
      he.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    v(Te, he), Te.prototype.imulK = function(S) {
      for (var E = 0, I = 0; I < S.length; I++) {
        var M = (S.words[I] | 0) * 19 + E, $ = M & 67108863;
        M >>>= 26, S.words[I] = $, E = M;
      }
      return E !== 0 && (S.words[S.length++] = E), S;
    }, p._prime = function(S) {
      if (ue[S])
        return ue[S];
      var E;
      if (S === "k256")
        E = new fe();
      else if (S === "p224")
        E = new be();
      else if (S === "p192")
        E = new ke();
      else if (S === "p25519")
        E = new Te();
      else
        throw new Error("Unknown prime " + S);
      return ue[S] = E, E;
    };
    function q(P) {
      if (typeof P == "string") {
        var S = p._prime(P);
        this.m = S.p, this.prime = S;
      } else
        l(P.gtn(1), "modulus must be greater than 1"), this.m = P, this.prime = null;
    }
    q.prototype._verify1 = function(S) {
      l(S.negative === 0, "red works only with positives"), l(S.red, "red works only with red numbers");
    }, q.prototype._verify2 = function(S, E) {
      l((S.negative | E.negative) === 0, "red works only with positives"), l(
        S.red && S.red === E.red,
        "red works only with red numbers"
      );
    }, q.prototype.imod = function(S) {
      return this.prime ? this.prime.ireduce(S)._forceRed(this) : S.umod(this.m)._forceRed(this);
    }, q.prototype.neg = function(S) {
      return S.isZero() ? S.clone() : this.m.sub(S)._forceRed(this);
    }, q.prototype.add = function(S, E) {
      this._verify2(S, E);
      var I = S.add(E);
      return I.cmp(this.m) >= 0 && I.isub(this.m), I._forceRed(this);
    }, q.prototype.iadd = function(S, E) {
      this._verify2(S, E);
      var I = S.iadd(E);
      return I.cmp(this.m) >= 0 && I.isub(this.m), I;
    }, q.prototype.sub = function(S, E) {
      this._verify2(S, E);
      var I = S.sub(E);
      return I.cmpn(0) < 0 && I.iadd(this.m), I._forceRed(this);
    }, q.prototype.isub = function(S, E) {
      this._verify2(S, E);
      var I = S.isub(E);
      return I.cmpn(0) < 0 && I.iadd(this.m), I;
    }, q.prototype.shl = function(S, E) {
      return this._verify1(S), this.imod(S.ushln(E));
    }, q.prototype.imul = function(S, E) {
      return this._verify2(S, E), this.imod(S.imul(E));
    }, q.prototype.mul = function(S, E) {
      return this._verify2(S, E), this.imod(S.mul(E));
    }, q.prototype.isqr = function(S) {
      return this.imul(S, S.clone());
    }, q.prototype.sqr = function(S) {
      return this.mul(S, S);
    }, q.prototype.sqrt = function(S) {
      if (S.isZero())
        return S.clone();
      var E = this.m.andln(3);
      if (l(E % 2 === 1), E === 3) {
        var I = this.m.add(new p(1)).iushrn(2);
        return this.pow(S, I);
      }
      for (var M = this.m.subn(1), $ = 0; !M.isZero() && M.andln(1) === 0; )
        $++, M.iushrn(1);
      l(!M.isZero());
      var U = new p(1).toRed(this), Y = U.redNeg(), B = this.m.subn(1).iushrn(1), T = this.m.bitLength();
      for (T = new p(2 * T * T).toRed(this); this.pow(T, B).cmp(Y) !== 0; )
        T.redIAdd(Y);
      for (var L = this.pow(T, M), te = this.pow(S, M.addn(1).iushrn(1)), me = this.pow(S, M), Ce = $; me.cmp(U) !== 0; ) {
        for (var De = me, ye = 0; De.cmp(U) !== 0; ye++)
          De = De.redSqr();
        l(ye < Ce);
        var pe = this.pow(L, new p(1).iushln(Ce - ye - 1));
        te = te.redMul(pe), L = pe.redSqr(), me = me.redMul(L), Ce = ye;
      }
      return te;
    }, q.prototype.invm = function(S) {
      var E = S._invmp(this.m);
      return E.negative !== 0 ? (E.negative = 0, this.imod(E).redNeg()) : this.imod(E);
    }, q.prototype.pow = function(S, E) {
      if (E.isZero())
        return new p(1).toRed(this);
      if (E.cmpn(1) === 0)
        return S.clone();
      var I = 4, M = new Array(1 << I);
      M[0] = new p(1).toRed(this), M[1] = S;
      for (var $ = 2; $ < M.length; $++)
        M[$] = this.mul(M[$ - 1], S);
      var U = M[0], Y = 0, B = 0, T = E.bitLength() % 26;
      for (T === 0 && (T = 26), $ = E.length - 1; $ >= 0; $--) {
        for (var L = E.words[$], te = T - 1; te >= 0; te--) {
          var me = L >> te & 1;
          if (U !== M[0] && (U = this.sqr(U)), me === 0 && Y === 0) {
            B = 0;
            continue;
          }
          Y <<= 1, Y |= me, B++, !(B !== I && ($ !== 0 || te !== 0)) && (U = this.mul(U, M[Y]), B = 0, Y = 0);
        }
        T = 26;
      }
      return U;
    }, q.prototype.convertTo = function(S) {
      var E = S.umod(this.m);
      return E === S ? E.clone() : E;
    }, q.prototype.convertFrom = function(S) {
      var E = S.clone();
      return E.red = null, E;
    }, p.mont = function(S) {
      return new z(S);
    };
    function z(P) {
      q.call(this, P), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new p(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    v(z, q), z.prototype.convertTo = function(S) {
      return this.imod(S.ushln(this.shift));
    }, z.prototype.convertFrom = function(S) {
      var E = this.imod(S.mul(this.rinv));
      return E.red = null, E;
    }, z.prototype.imul = function(S, E) {
      if (S.isZero() || E.isZero())
        return S.words[0] = 0, S.length = 1, S;
      var I = S.imul(E), M = I.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), $ = I.isub(M).iushrn(this.shift), U = $;
      return $.cmp(this.m) >= 0 ? U = $.isub(this.m) : $.cmpn(0) < 0 && (U = $.iadd(this.m)), U._forceRed(this);
    }, z.prototype.mul = function(S, E) {
      if (S.isZero() || E.isZero())
        return new p(0)._forceRed(this);
      var I = S.mul(E), M = I.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), $ = I.isub(M).iushrn(this.shift), U = $;
      return $.cmp(this.m) >= 0 ? U = $.isub(this.m) : $.cmpn(0) < 0 && (U = $.iadd(this.m)), U._forceRed(this);
    }, z.prototype.invm = function(S) {
      var E = this.imod(S._invmp(this.m).mul(this.r2));
      return E._forceRed(this);
    };
  })(a, commonjsGlobal$1);
})(bn$2);
var bnExports$2 = bn$2.exports, api = {}, encoders = {}, buffer$1 = require$$0$2, Buffer$f = buffer$1.Buffer, safer = {}, key;
for (key in buffer$1)
  buffer$1.hasOwnProperty(key) && (key === "SlowBuffer" || key === "Buffer" || (safer[key] = buffer$1[key]));
var Safer = safer.Buffer = {};
for (key in Buffer$f)
  Buffer$f.hasOwnProperty(key) && (key === "allocUnsafe" || key === "allocUnsafeSlow" || (Safer[key] = Buffer$f[key]));
safer.Buffer.prototype = Buffer$f.prototype;
(!Safer.from || Safer.from === Uint8Array.from) && (Safer.from = function(a, u, c) {
  if (typeof a == "number")
    throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof a);
  if (a && typeof a.length > "u")
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof a);
  return Buffer$f(a, u, c);
});
Safer.alloc || (Safer.alloc = function(a, u, c) {
  if (typeof a != "number")
    throw new TypeError('The "size" argument must be of type number. Received type ' + typeof a);
  if (a < 0 || a >= 2 * (1 << 30))
    throw new RangeError('The value "' + a + '" is invalid for option "size"');
  var l = Buffer$f(a);
  return !u || u.length === 0 ? l.fill(0) : typeof c == "string" ? l.fill(u, c) : l.fill(u), l;
});
if (!safer.kStringMaxLength)
  try {
    safer.kStringMaxLength = process$1.binding("buffer").kStringMaxLength;
  } catch {
  }
safer.constants || (safer.constants = {
  MAX_LENGTH: safer.kMaxLength
}, safer.kStringMaxLength && (safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength));
var safer_1 = safer, reporter = {};
const inherits$5 = inherits_browserExports;
function Reporter$2(a) {
  this._reporterState = {
    obj: null,
    path: [],
    options: a || {},
    errors: []
  };
}
reporter.Reporter = Reporter$2;
Reporter$2.prototype.isError = function a(u) {
  return u instanceof ReporterError;
};
Reporter$2.prototype.save = function a() {
  const u = this._reporterState;
  return { obj: u.obj, pathLen: u.path.length };
};
Reporter$2.prototype.restore = function a(u) {
  const c = this._reporterState;
  c.obj = u.obj, c.path = c.path.slice(0, u.pathLen);
};
Reporter$2.prototype.enterKey = function a(u) {
  return this._reporterState.path.push(u);
};
Reporter$2.prototype.exitKey = function a(u) {
  const c = this._reporterState;
  c.path = c.path.slice(0, u - 1);
};
Reporter$2.prototype.leaveKey = function a(u, c, l) {
  const v = this._reporterState;
  this.exitKey(u), v.obj !== null && (v.obj[c] = l);
};
Reporter$2.prototype.path = function a() {
  return this._reporterState.path.join("/");
};
Reporter$2.prototype.enterObject = function a() {
  const u = this._reporterState, c = u.obj;
  return u.obj = {}, c;
};
Reporter$2.prototype.leaveObject = function a(u) {
  const c = this._reporterState, l = c.obj;
  return c.obj = u, l;
};
Reporter$2.prototype.error = function a(u) {
  let c;
  const l = this._reporterState, v = u instanceof ReporterError;
  if (v ? c = u : c = new ReporterError(l.path.map(function(p) {
    return "[" + JSON.stringify(p) + "]";
  }).join(""), u.message || u, u.stack), !l.options.partial)
    throw c;
  return v || l.errors.push(c), c;
};
Reporter$2.prototype.wrapResult = function a(u) {
  const c = this._reporterState;
  return c.options.partial ? {
    result: this.isError(u) ? null : u,
    errors: c.errors
  } : u;
};
function ReporterError(a, u) {
  this.path = a, this.rethrow(u);
}
inherits$5(ReporterError, Error);
ReporterError.prototype.rethrow = function a(u) {
  if (this.message = u + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, ReporterError), !this.stack)
    try {
      throw new Error(this.message);
    } catch (c) {
      this.stack = c.stack;
    }
  return this;
};
var buffer = {};
const inherits$4 = inherits_browserExports, Reporter$1 = reporter.Reporter, Buffer$e = safer_1.Buffer;
function DecoderBuffer$2(a, u) {
  if (Reporter$1.call(this, u), !Buffer$e.isBuffer(a)) {
    this.error("Input not Buffer");
    return;
  }
  this.base = a, this.offset = 0, this.length = a.length;
}
inherits$4(DecoderBuffer$2, Reporter$1);
buffer.DecoderBuffer = DecoderBuffer$2;
DecoderBuffer$2.isDecoderBuffer = function a(u) {
  return u instanceof DecoderBuffer$2 ? !0 : typeof u == "object" && Buffer$e.isBuffer(u.base) && u.constructor.name === "DecoderBuffer" && typeof u.offset == "number" && typeof u.length == "number" && typeof u.save == "function" && typeof u.restore == "function" && typeof u.isEmpty == "function" && typeof u.readUInt8 == "function" && typeof u.skip == "function" && typeof u.raw == "function";
};
DecoderBuffer$2.prototype.save = function a() {
  return { offset: this.offset, reporter: Reporter$1.prototype.save.call(this) };
};
DecoderBuffer$2.prototype.restore = function a(u) {
  const c = new DecoderBuffer$2(this.base);
  return c.offset = u.offset, c.length = this.offset, this.offset = u.offset, Reporter$1.prototype.restore.call(this, u.reporter), c;
};
DecoderBuffer$2.prototype.isEmpty = function a() {
  return this.offset === this.length;
};
DecoderBuffer$2.prototype.readUInt8 = function a(u) {
  return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, !0) : this.error(u || "DecoderBuffer overrun");
};
DecoderBuffer$2.prototype.skip = function a(u, c) {
  if (!(this.offset + u <= this.length))
    return this.error(c || "DecoderBuffer overrun");
  const l = new DecoderBuffer$2(this.base);
  return l._reporterState = this._reporterState, l.offset = this.offset, l.length = this.offset + u, this.offset += u, l;
};
DecoderBuffer$2.prototype.raw = function a(u) {
  return this.base.slice(u ? u.offset : this.offset, this.length);
};
function EncoderBuffer$1(a, u) {
  if (Array.isArray(a))
    this.length = 0, this.value = a.map(function(c) {
      return EncoderBuffer$1.isEncoderBuffer(c) || (c = new EncoderBuffer$1(c, u)), this.length += c.length, c;
    }, this);
  else if (typeof a == "number") {
    if (!(0 <= a && a <= 255))
      return u.error("non-byte EncoderBuffer value");
    this.value = a, this.length = 1;
  } else if (typeof a == "string")
    this.value = a, this.length = Buffer$e.byteLength(a);
  else if (Buffer$e.isBuffer(a))
    this.value = a, this.length = a.length;
  else
    return u.error("Unsupported type: " + typeof a);
}
buffer.EncoderBuffer = EncoderBuffer$1;
EncoderBuffer$1.isEncoderBuffer = function a(u) {
  return u instanceof EncoderBuffer$1 ? !0 : typeof u == "object" && u.constructor.name === "EncoderBuffer" && typeof u.length == "number" && typeof u.join == "function";
};
EncoderBuffer$1.prototype.join = function a(u, c) {
  return u || (u = Buffer$e.alloc(this.length)), c || (c = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(l) {
    l.join(u, c), c += l.length;
  }) : (typeof this.value == "number" ? u[c] = this.value : typeof this.value == "string" ? u.write(this.value, c) : Buffer$e.isBuffer(this.value) && this.value.copy(u, c), c += this.length)), u;
};
const Reporter = reporter.Reporter, EncoderBuffer = buffer.EncoderBuffer, DecoderBuffer$1 = buffer.DecoderBuffer, assert = minimalisticAssert, tags = [
  "seq",
  "seqof",
  "set",
  "setof",
  "objid",
  "bool",
  "gentime",
  "utctime",
  "null_",
  "enum",
  "int",
  "objDesc",
  "bitstr",
  "bmpstr",
  "charstr",
  "genstr",
  "graphstr",
  "ia5str",
  "iso646str",
  "numstr",
  "octstr",
  "printstr",
  "t61str",
  "unistr",
  "utf8str",
  "videostr"
], methods = [
  "key",
  "obj",
  "use",
  "optional",
  "explicit",
  "implicit",
  "def",
  "choice",
  "any",
  "contains"
].concat(tags), overrided = [
  "_peekTag",
  "_decodeTag",
  "_use",
  "_decodeStr",
  "_decodeObjid",
  "_decodeTime",
  "_decodeNull",
  "_decodeInt",
  "_decodeBool",
  "_decodeList",
  "_encodeComposite",
  "_encodeStr",
  "_encodeObjid",
  "_encodeTime",
  "_encodeNull",
  "_encodeInt",
  "_encodeBool"
];
function Node$2(a, u, c) {
  const l = {};
  this._baseState = l, l.name = c, l.enc = a, l.parent = u || null, l.children = null, l.tag = null, l.args = null, l.reverseArgs = null, l.choice = null, l.optional = !1, l.any = !1, l.obj = !1, l.use = null, l.useDecoder = null, l.key = null, l.default = null, l.explicit = null, l.implicit = null, l.contains = null, l.parent || (l.children = [], this._wrap());
}
var node = Node$2;
const stateProps = [
  "enc",
  "parent",
  "children",
  "tag",
  "args",
  "reverseArgs",
  "choice",
  "optional",
  "any",
  "obj",
  "use",
  "alteredUse",
  "key",
  "default",
  "explicit",
  "implicit",
  "contains"
];
Node$2.prototype.clone = function a() {
  const u = this._baseState, c = {};
  stateProps.forEach(function(v) {
    c[v] = u[v];
  });
  const l = new this.constructor(c.parent);
  return l._baseState = c, l;
};
Node$2.prototype._wrap = function a() {
  const u = this._baseState;
  methods.forEach(function(c) {
    this[c] = function() {
      const v = new this.constructor(this);
      return u.children.push(v), v[c].apply(v, arguments);
    };
  }, this);
};
Node$2.prototype._init = function a(u) {
  const c = this._baseState;
  assert(c.parent === null), u.call(this), c.children = c.children.filter(function(l) {
    return l._baseState.parent === this;
  }, this), assert.equal(c.children.length, 1, "Root node can have only one child");
};
Node$2.prototype._useArgs = function a(u) {
  const c = this._baseState, l = u.filter(function(v) {
    return v instanceof this.constructor;
  }, this);
  u = u.filter(function(v) {
    return !(v instanceof this.constructor);
  }, this), l.length !== 0 && (assert(c.children === null), c.children = l, l.forEach(function(v) {
    v._baseState.parent = this;
  }, this)), u.length !== 0 && (assert(c.args === null), c.args = u, c.reverseArgs = u.map(function(v) {
    if (typeof v != "object" || v.constructor !== Object)
      return v;
    const p = {};
    return Object.keys(v).forEach(function(_) {
      _ == (_ | 0) && (_ |= 0);
      const k = v[_];
      p[k] = _;
    }), p;
  }));
};
overrided.forEach(function(a) {
  Node$2.prototype[a] = function() {
    const c = this._baseState;
    throw new Error(a + " not implemented for encoding: " + c.enc);
  };
});
tags.forEach(function(a) {
  Node$2.prototype[a] = function() {
    const c = this._baseState, l = Array.prototype.slice.call(arguments);
    return assert(c.tag === null), c.tag = a, this._useArgs(l), this;
  };
});
Node$2.prototype.use = function a(u) {
  assert(u);
  const c = this._baseState;
  return assert(c.use === null), c.use = u, this;
};
Node$2.prototype.optional = function a() {
  const u = this._baseState;
  return u.optional = !0, this;
};
Node$2.prototype.def = function a(u) {
  const c = this._baseState;
  return assert(c.default === null), c.default = u, c.optional = !0, this;
};
Node$2.prototype.explicit = function a(u) {
  const c = this._baseState;
  return assert(c.explicit === null && c.implicit === null), c.explicit = u, this;
};
Node$2.prototype.implicit = function a(u) {
  const c = this._baseState;
  return assert(c.explicit === null && c.implicit === null), c.implicit = u, this;
};
Node$2.prototype.obj = function a() {
  const u = this._baseState, c = Array.prototype.slice.call(arguments);
  return u.obj = !0, c.length !== 0 && this._useArgs(c), this;
};
Node$2.prototype.key = function a(u) {
  const c = this._baseState;
  return assert(c.key === null), c.key = u, this;
};
Node$2.prototype.any = function a() {
  const u = this._baseState;
  return u.any = !0, this;
};
Node$2.prototype.choice = function a(u) {
  const c = this._baseState;
  return assert(c.choice === null), c.choice = u, this._useArgs(Object.keys(u).map(function(l) {
    return u[l];
  })), this;
};
Node$2.prototype.contains = function a(u) {
  const c = this._baseState;
  return assert(c.use === null), c.contains = u, this;
};
Node$2.prototype._decode = function a(u, c) {
  const l = this._baseState;
  if (l.parent === null)
    return u.wrapResult(l.children[0]._decode(u, c));
  let v = l.default, p = !0, _ = null;
  if (l.key !== null && (_ = u.enterKey(l.key)), l.optional) {
    let O = null;
    if (l.explicit !== null ? O = l.explicit : l.implicit !== null ? O = l.implicit : l.tag !== null && (O = l.tag), O === null && !l.any) {
      const D = u.save();
      try {
        l.choice === null ? this._decodeGeneric(l.tag, u, c) : this._decodeChoice(u, c), p = !0;
      } catch {
        p = !1;
      }
      u.restore(D);
    } else if (p = this._peekTag(u, O, l.any), u.isError(p))
      return p;
  }
  let k;
  if (l.obj && p && (k = u.enterObject()), p) {
    if (l.explicit !== null) {
      const D = this._decodeTag(u, l.explicit);
      if (u.isError(D))
        return D;
      u = D;
    }
    const O = u.offset;
    if (l.use === null && l.choice === null) {
      let D;
      l.any && (D = u.save());
      const F = this._decodeTag(
        u,
        l.implicit !== null ? l.implicit : l.tag,
        l.any
      );
      if (u.isError(F))
        return F;
      l.any ? v = u.raw(D) : u = F;
    }
    if (c && c.track && l.tag !== null && c.track(u.path(), O, u.length, "tagged"), c && c.track && l.tag !== null && c.track(u.path(), u.offset, u.length, "content"), l.any || (l.choice === null ? v = this._decodeGeneric(l.tag, u, c) : v = this._decodeChoice(u, c)), u.isError(v))
      return v;
    if (!l.any && l.choice === null && l.children !== null && l.children.forEach(function(F) {
      F._decode(u, c);
    }), l.contains && (l.tag === "octstr" || l.tag === "bitstr")) {
      const D = new DecoderBuffer$1(v);
      v = this._getUse(l.contains, u._reporterState.obj)._decode(D, c);
    }
  }
  return l.obj && p && (v = u.leaveObject(k)), l.key !== null && (v !== null || p === !0) ? u.leaveKey(_, l.key, v) : _ !== null && u.exitKey(_), v;
};
Node$2.prototype._decodeGeneric = function a(u, c, l) {
  const v = this._baseState;
  return u === "seq" || u === "set" ? null : u === "seqof" || u === "setof" ? this._decodeList(c, u, v.args[0], l) : /str$/.test(u) ? this._decodeStr(c, u, l) : u === "objid" && v.args ? this._decodeObjid(c, v.args[0], v.args[1], l) : u === "objid" ? this._decodeObjid(c, null, null, l) : u === "gentime" || u === "utctime" ? this._decodeTime(c, u, l) : u === "null_" ? this._decodeNull(c, l) : u === "bool" ? this._decodeBool(c, l) : u === "objDesc" ? this._decodeStr(c, u, l) : u === "int" || u === "enum" ? this._decodeInt(c, v.args && v.args[0], l) : v.use !== null ? this._getUse(v.use, c._reporterState.obj)._decode(c, l) : c.error("unknown tag: " + u);
};
Node$2.prototype._getUse = function a(u, c) {
  const l = this._baseState;
  return l.useDecoder = this._use(u, c), assert(l.useDecoder._baseState.parent === null), l.useDecoder = l.useDecoder._baseState.children[0], l.implicit !== l.useDecoder._baseState.implicit && (l.useDecoder = l.useDecoder.clone(), l.useDecoder._baseState.implicit = l.implicit), l.useDecoder;
};
Node$2.prototype._decodeChoice = function a(u, c) {
  const l = this._baseState;
  let v = null, p = !1;
  return Object.keys(l.choice).some(function(_) {
    const k = u.save(), O = l.choice[_];
    try {
      const D = O._decode(u, c);
      if (u.isError(D))
        return !1;
      v = { type: _, value: D }, p = !0;
    } catch {
      return u.restore(k), !1;
    }
    return !0;
  }, this), p ? v : u.error("Choice not matched");
};
Node$2.prototype._createEncoderBuffer = function a(u) {
  return new EncoderBuffer(u, this.reporter);
};
Node$2.prototype._encode = function a(u, c, l) {
  const v = this._baseState;
  if (v.default !== null && v.default === u)
    return;
  const p = this._encodeValue(u, c, l);
  if (p !== void 0 && !this._skipDefault(p, c, l))
    return p;
};
Node$2.prototype._encodeValue = function a(u, c, l) {
  const v = this._baseState;
  if (v.parent === null)
    return v.children[0]._encode(u, c || new Reporter());
  let p = null;
  if (this.reporter = c, v.optional && u === void 0)
    if (v.default !== null)
      u = v.default;
    else
      return;
  let _ = null, k = !1;
  if (v.any)
    p = this._createEncoderBuffer(u);
  else if (v.choice)
    p = this._encodeChoice(u, c);
  else if (v.contains)
    _ = this._getUse(v.contains, l)._encode(u, c), k = !0;
  else if (v.children)
    _ = v.children.map(function(O) {
      if (O._baseState.tag === "null_")
        return O._encode(null, c, u);
      if (O._baseState.key === null)
        return c.error("Child should have a key");
      const D = c.enterKey(O._baseState.key);
      if (typeof u != "object")
        return c.error("Child expected, but input is not object");
      const F = O._encode(u[O._baseState.key], c, u);
      return c.leaveKey(D), F;
    }, this).filter(function(O) {
      return O;
    }), _ = this._createEncoderBuffer(_);
  else if (v.tag === "seqof" || v.tag === "setof") {
    if (!(v.args && v.args.length === 1))
      return c.error("Too many args for : " + v.tag);
    if (!Array.isArray(u))
      return c.error("seqof/setof, but data is not Array");
    const O = this.clone();
    O._baseState.implicit = null, _ = this._createEncoderBuffer(u.map(function(D) {
      const F = this._baseState;
      return this._getUse(F.args[0], u)._encode(D, c);
    }, O));
  } else
    v.use !== null ? p = this._getUse(v.use, l)._encode(u, c) : (_ = this._encodePrimitive(v.tag, u), k = !0);
  if (!v.any && v.choice === null) {
    const O = v.implicit !== null ? v.implicit : v.tag, D = v.implicit === null ? "universal" : "context";
    O === null ? v.use === null && c.error("Tag could be omitted only for .use()") : v.use === null && (p = this._encodeComposite(O, k, D, _));
  }
  return v.explicit !== null && (p = this._encodeComposite(v.explicit, !1, "context", p)), p;
};
Node$2.prototype._encodeChoice = function a(u, c) {
  const l = this._baseState, v = l.choice[u.type];
  return v || assert(
    !1,
    u.type + " not found in " + JSON.stringify(Object.keys(l.choice))
  ), v._encode(u.value, c);
};
Node$2.prototype._encodePrimitive = function a(u, c) {
  const l = this._baseState;
  if (/str$/.test(u))
    return this._encodeStr(c, u);
  if (u === "objid" && l.args)
    return this._encodeObjid(c, l.reverseArgs[0], l.args[1]);
  if (u === "objid")
    return this._encodeObjid(c, null, null);
  if (u === "gentime" || u === "utctime")
    return this._encodeTime(c, u);
  if (u === "null_")
    return this._encodeNull();
  if (u === "int" || u === "enum")
    return this._encodeInt(c, l.args && l.reverseArgs[0]);
  if (u === "bool")
    return this._encodeBool(c);
  if (u === "objDesc")
    return this._encodeStr(c, u);
  throw new Error("Unsupported tag: " + u);
};
Node$2.prototype._isNumstr = function a(u) {
  return /^[0-9 ]*$/.test(u);
};
Node$2.prototype._isPrintstr = function a(u) {
  return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(u);
};
var der$2 = {};
(function(a) {
  function u(c) {
    const l = {};
    return Object.keys(c).forEach(function(v) {
      (v | 0) == v && (v = v | 0);
      const p = c[v];
      l[p] = v;
    }), l;
  }
  a.tagClass = {
    0: "universal",
    1: "application",
    2: "context",
    3: "private"
  }, a.tagClassByName = u(a.tagClass), a.tag = {
    0: "end",
    1: "bool",
    2: "int",
    3: "bitstr",
    4: "octstr",
    5: "null_",
    6: "objid",
    7: "objDesc",
    8: "external",
    9: "real",
    10: "enum",
    11: "embed",
    12: "utf8str",
    13: "relativeOid",
    16: "seq",
    17: "set",
    18: "numstr",
    19: "printstr",
    20: "t61str",
    21: "videostr",
    22: "ia5str",
    23: "utctime",
    24: "gentime",
    25: "graphstr",
    26: "iso646str",
    27: "genstr",
    28: "unistr",
    29: "charstr",
    30: "bmpstr"
  }, a.tagByName = u(a.tag);
})(der$2);
const inherits$3 = inherits_browserExports, Buffer$d = safer_1.Buffer, Node$1 = node, der$1 = der$2;
function DEREncoder$1(a) {
  this.enc = "der", this.name = a.name, this.entity = a, this.tree = new DERNode$1(), this.tree._init(a.body);
}
var der_1$1 = DEREncoder$1;
DEREncoder$1.prototype.encode = function a(u, c) {
  return this.tree._encode(u, c).join();
};
function DERNode$1(a) {
  Node$1.call(this, "der", a);
}
inherits$3(DERNode$1, Node$1);
DERNode$1.prototype._encodeComposite = function a(u, c, l, v) {
  const p = encodeTag(u, c, l, this.reporter);
  if (v.length < 128) {
    const O = Buffer$d.alloc(2);
    return O[0] = p, O[1] = v.length, this._createEncoderBuffer([O, v]);
  }
  let _ = 1;
  for (let O = v.length; O >= 256; O >>= 8)
    _++;
  const k = Buffer$d.alloc(2 + _);
  k[0] = p, k[1] = 128 | _;
  for (let O = 1 + _, D = v.length; D > 0; O--, D >>= 8)
    k[O] = D & 255;
  return this._createEncoderBuffer([k, v]);
};
DERNode$1.prototype._encodeStr = function a(u, c) {
  if (c === "bitstr")
    return this._createEncoderBuffer([u.unused | 0, u.data]);
  if (c === "bmpstr") {
    const l = Buffer$d.alloc(u.length * 2);
    for (let v = 0; v < u.length; v++)
      l.writeUInt16BE(u.charCodeAt(v), v * 2);
    return this._createEncoderBuffer(l);
  } else
    return c === "numstr" ? this._isNumstr(u) ? this._createEncoderBuffer(u) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : c === "printstr" ? this._isPrintstr(u) ? this._createEncoderBuffer(u) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(c) ? this._createEncoderBuffer(u) : c === "objDesc" ? this._createEncoderBuffer(u) : this.reporter.error("Encoding of string type: " + c + " unsupported");
};
DERNode$1.prototype._encodeObjid = function a(u, c, l) {
  if (typeof u == "string") {
    if (!c)
      return this.reporter.error("string objid given, but no values map found");
    if (!c.hasOwnProperty(u))
      return this.reporter.error("objid not found in values map");
    u = c[u].split(/[\s.]+/g);
    for (let k = 0; k < u.length; k++)
      u[k] |= 0;
  } else if (Array.isArray(u)) {
    u = u.slice();
    for (let k = 0; k < u.length; k++)
      u[k] |= 0;
  }
  if (!Array.isArray(u))
    return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(u));
  if (!l) {
    if (u[1] >= 40)
      return this.reporter.error("Second objid identifier OOB");
    u.splice(0, 2, u[0] * 40 + u[1]);
  }
  let v = 0;
  for (let k = 0; k < u.length; k++) {
    let O = u[k];
    for (v++; O >= 128; O >>= 7)
      v++;
  }
  const p = Buffer$d.alloc(v);
  let _ = p.length - 1;
  for (let k = u.length - 1; k >= 0; k--) {
    let O = u[k];
    for (p[_--] = O & 127; (O >>= 7) > 0; )
      p[_--] = 128 | O & 127;
  }
  return this._createEncoderBuffer(p);
};
function two(a) {
  return a < 10 ? "0" + a : a;
}
DERNode$1.prototype._encodeTime = function a(u, c) {
  let l;
  const v = new Date(u);
  return c === "gentime" ? l = [
    two(v.getUTCFullYear()),
    two(v.getUTCMonth() + 1),
    two(v.getUTCDate()),
    two(v.getUTCHours()),
    two(v.getUTCMinutes()),
    two(v.getUTCSeconds()),
    "Z"
  ].join("") : c === "utctime" ? l = [
    two(v.getUTCFullYear() % 100),
    two(v.getUTCMonth() + 1),
    two(v.getUTCDate()),
    two(v.getUTCHours()),
    two(v.getUTCMinutes()),
    two(v.getUTCSeconds()),
    "Z"
  ].join("") : this.reporter.error("Encoding " + c + " time is not supported yet"), this._encodeStr(l, "octstr");
};
DERNode$1.prototype._encodeNull = function a() {
  return this._createEncoderBuffer("");
};
DERNode$1.prototype._encodeInt = function a(u, c) {
  if (typeof u == "string") {
    if (!c)
      return this.reporter.error("String int or enum given, but no values map");
    if (!c.hasOwnProperty(u))
      return this.reporter.error("Values map doesn't contain: " + JSON.stringify(u));
    u = c[u];
  }
  if (typeof u != "number" && !Buffer$d.isBuffer(u)) {
    const p = u.toArray();
    !u.sign && p[0] & 128 && p.unshift(0), u = Buffer$d.from(p);
  }
  if (Buffer$d.isBuffer(u)) {
    let p = u.length;
    u.length === 0 && p++;
    const _ = Buffer$d.alloc(p);
    return u.copy(_), u.length === 0 && (_[0] = 0), this._createEncoderBuffer(_);
  }
  if (u < 128)
    return this._createEncoderBuffer(u);
  if (u < 256)
    return this._createEncoderBuffer([0, u]);
  let l = 1;
  for (let p = u; p >= 256; p >>= 8)
    l++;
  const v = new Array(l);
  for (let p = v.length - 1; p >= 0; p--)
    v[p] = u & 255, u >>= 8;
  return v[0] & 128 && v.unshift(0), this._createEncoderBuffer(Buffer$d.from(v));
};
DERNode$1.prototype._encodeBool = function a(u) {
  return this._createEncoderBuffer(u ? 255 : 0);
};
DERNode$1.prototype._use = function a(u, c) {
  return typeof u == "function" && (u = u(c)), u._getEncoder("der").tree;
};
DERNode$1.prototype._skipDefault = function a(u, c, l) {
  const v = this._baseState;
  let p;
  if (v.default === null)
    return !1;
  const _ = u.join();
  if (v.defaultBuffer === void 0 && (v.defaultBuffer = this._encodeValue(v.default, c, l).join()), _.length !== v.defaultBuffer.length)
    return !1;
  for (p = 0; p < _.length; p++)
    if (_[p] !== v.defaultBuffer[p])
      return !1;
  return !0;
};
function encodeTag(a, u, c, l) {
  let v;
  if (a === "seqof" ? a = "seq" : a === "setof" && (a = "set"), der$1.tagByName.hasOwnProperty(a))
    v = der$1.tagByName[a];
  else if (typeof a == "number" && (a | 0) === a)
    v = a;
  else
    return l.error("Unknown tag: " + a);
  return v >= 31 ? l.error("Multi-octet tag encoding unsupported") : (u || (v |= 32), v |= der$1.tagClassByName[c || "universal"] << 6, v);
}
const inherits$2 = inherits_browserExports, DEREncoder = der_1$1;
function PEMEncoder(a) {
  DEREncoder.call(this, a), this.enc = "pem";
}
inherits$2(PEMEncoder, DEREncoder);
var pem$1 = PEMEncoder;
PEMEncoder.prototype.encode = function a(u, c) {
  const v = DEREncoder.prototype.encode.call(this, u).toString("base64"), p = ["-----BEGIN " + c.label + "-----"];
  for (let _ = 0; _ < v.length; _ += 64)
    p.push(v.slice(_, _ + 64));
  return p.push("-----END " + c.label + "-----"), p.join(`
`);
};
(function(a) {
  const u = a;
  u.der = der_1$1, u.pem = pem$1;
})(encoders);
var decoders = {};
const inherits$1 = inherits_browserExports, bignum = bnExports$2, DecoderBuffer = buffer.DecoderBuffer, Node = node, der = der$2;
function DERDecoder$1(a) {
  this.enc = "der", this.name = a.name, this.entity = a, this.tree = new DERNode(), this.tree._init(a.body);
}
var der_1 = DERDecoder$1;
DERDecoder$1.prototype.decode = function a(u, c) {
  return DecoderBuffer.isDecoderBuffer(u) || (u = new DecoderBuffer(u, c)), this.tree._decode(u, c);
};
function DERNode(a) {
  Node.call(this, "der", a);
}
inherits$1(DERNode, Node);
DERNode.prototype._peekTag = function a(u, c, l) {
  if (u.isEmpty())
    return !1;
  const v = u.save(), p = derDecodeTag(u, 'Failed to peek tag: "' + c + '"');
  return u.isError(p) ? p : (u.restore(v), p.tag === c || p.tagStr === c || p.tagStr + "of" === c || l);
};
DERNode.prototype._decodeTag = function a(u, c, l) {
  const v = derDecodeTag(
    u,
    'Failed to decode tag of "' + c + '"'
  );
  if (u.isError(v))
    return v;
  let p = derDecodeLen(
    u,
    v.primitive,
    'Failed to get length of "' + c + '"'
  );
  if (u.isError(p))
    return p;
  if (!l && v.tag !== c && v.tagStr !== c && v.tagStr + "of" !== c)
    return u.error('Failed to match tag: "' + c + '"');
  if (v.primitive || p !== null)
    return u.skip(p, 'Failed to match body of: "' + c + '"');
  const _ = u.save(), k = this._skipUntilEnd(
    u,
    'Failed to skip indefinite length body: "' + this.tag + '"'
  );
  return u.isError(k) ? k : (p = u.offset - _.offset, u.restore(_), u.skip(p, 'Failed to match body of: "' + c + '"'));
};
DERNode.prototype._skipUntilEnd = function a(u, c) {
  for (; ; ) {
    const l = derDecodeTag(u, c);
    if (u.isError(l))
      return l;
    const v = derDecodeLen(u, l.primitive, c);
    if (u.isError(v))
      return v;
    let p;
    if (l.primitive || v !== null ? p = u.skip(v) : p = this._skipUntilEnd(u, c), u.isError(p))
      return p;
    if (l.tagStr === "end")
      break;
  }
};
DERNode.prototype._decodeList = function a(u, c, l, v) {
  const p = [];
  for (; !u.isEmpty(); ) {
    const _ = this._peekTag(u, "end");
    if (u.isError(_))
      return _;
    const k = l.decode(u, "der", v);
    if (u.isError(k) && _)
      break;
    p.push(k);
  }
  return p;
};
DERNode.prototype._decodeStr = function a(u, c) {
  if (c === "bitstr") {
    const l = u.readUInt8();
    return u.isError(l) ? l : { unused: l, data: u.raw() };
  } else if (c === "bmpstr") {
    const l = u.raw();
    if (l.length % 2 === 1)
      return u.error("Decoding of string type: bmpstr length mismatch");
    let v = "";
    for (let p = 0; p < l.length / 2; p++)
      v += String.fromCharCode(l.readUInt16BE(p * 2));
    return v;
  } else if (c === "numstr") {
    const l = u.raw().toString("ascii");
    return this._isNumstr(l) ? l : u.error("Decoding of string type: numstr unsupported characters");
  } else {
    if (c === "octstr")
      return u.raw();
    if (c === "objDesc")
      return u.raw();
    if (c === "printstr") {
      const l = u.raw().toString("ascii");
      return this._isPrintstr(l) ? l : u.error("Decoding of string type: printstr unsupported characters");
    } else
      return /str$/.test(c) ? u.raw().toString() : u.error("Decoding of string type: " + c + " unsupported");
  }
};
DERNode.prototype._decodeObjid = function a(u, c, l) {
  let v;
  const p = [];
  let _ = 0, k = 0;
  for (; !u.isEmpty(); )
    k = u.readUInt8(), _ <<= 7, _ |= k & 127, k & 128 || (p.push(_), _ = 0);
  k & 128 && p.push(_);
  const O = p[0] / 40 | 0, D = p[0] % 40;
  if (l ? v = p : v = [O, D].concat(p.slice(1)), c) {
    let F = c[v.join(" ")];
    F === void 0 && (F = c[v.join(".")]), F !== void 0 && (v = F);
  }
  return v;
};
DERNode.prototype._decodeTime = function a(u, c) {
  const l = u.raw().toString();
  let v, p, _, k, O, D;
  if (c === "gentime")
    v = l.slice(0, 4) | 0, p = l.slice(4, 6) | 0, _ = l.slice(6, 8) | 0, k = l.slice(8, 10) | 0, O = l.slice(10, 12) | 0, D = l.slice(12, 14) | 0;
  else if (c === "utctime")
    v = l.slice(0, 2) | 0, p = l.slice(2, 4) | 0, _ = l.slice(4, 6) | 0, k = l.slice(6, 8) | 0, O = l.slice(8, 10) | 0, D = l.slice(10, 12) | 0, v < 70 ? v = 2e3 + v : v = 1900 + v;
  else
    return u.error("Decoding " + c + " time is not supported yet");
  return Date.UTC(v, p - 1, _, k, O, D, 0);
};
DERNode.prototype._decodeNull = function a() {
  return null;
};
DERNode.prototype._decodeBool = function a(u) {
  const c = u.readUInt8();
  return u.isError(c) ? c : c !== 0;
};
DERNode.prototype._decodeInt = function a(u, c) {
  const l = u.raw();
  let v = new bignum(l);
  return c && (v = c[v.toString(10)] || v), v;
};
DERNode.prototype._use = function a(u, c) {
  return typeof u == "function" && (u = u(c)), u._getDecoder("der").tree;
};
function derDecodeTag(a, u) {
  let c = a.readUInt8(u);
  if (a.isError(c))
    return c;
  const l = der.tagClass[c >> 6], v = (c & 32) === 0;
  if ((c & 31) === 31) {
    let _ = c;
    for (c = 0; (_ & 128) === 128; ) {
      if (_ = a.readUInt8(u), a.isError(_))
        return _;
      c <<= 7, c |= _ & 127;
    }
  } else
    c &= 31;
  const p = der.tag[c];
  return {
    cls: l,
    primitive: v,
    tag: c,
    tagStr: p
  };
}
function derDecodeLen(a, u, c) {
  let l = a.readUInt8(c);
  if (a.isError(l))
    return l;
  if (!u && l === 128)
    return null;
  if (!(l & 128))
    return l;
  const v = l & 127;
  if (v > 4)
    return a.error("length octect is too long");
  l = 0;
  for (let p = 0; p < v; p++) {
    l <<= 8;
    const _ = a.readUInt8(c);
    if (a.isError(_))
      return _;
    l |= _;
  }
  return l;
}
const inherits = inherits_browserExports, Buffer$c = safer_1.Buffer, DERDecoder = der_1;
function PEMDecoder(a) {
  DERDecoder.call(this, a), this.enc = "pem";
}
inherits(PEMDecoder, DERDecoder);
var pem = PEMDecoder;
PEMDecoder.prototype.decode = function a(u, c) {
  const l = u.toString().split(/[\r\n]+/g), v = c.label.toUpperCase(), p = /^-----(BEGIN|END) ([^-]+)-----$/;
  let _ = -1, k = -1;
  for (let F = 0; F < l.length; F++) {
    const H = l[F].match(p);
    if (H !== null && H[2] === v)
      if (_ === -1) {
        if (H[1] !== "BEGIN")
          break;
        _ = F;
      } else {
        if (H[1] !== "END")
          break;
        k = F;
        break;
      }
  }
  if (_ === -1 || k === -1)
    throw new Error("PEM section not found for: " + v);
  const O = l.slice(_ + 1, k).join("");
  O.replace(/[^a-z0-9+/=]+/gi, "");
  const D = Buffer$c.from(O, "base64");
  return DERDecoder.prototype.decode.call(this, D, c);
};
(function(a) {
  const u = a;
  u.der = der_1, u.pem = pem;
})(decoders);
(function(a) {
  const u = encoders, c = decoders, l = inherits_browserExports, v = a;
  v.define = function(k, O) {
    return new p(k, O);
  };
  function p(_, k) {
    this.name = _, this.body = k, this.decoders = {}, this.encoders = {};
  }
  p.prototype._createNamed = function(k) {
    const O = this.name;
    function D(F) {
      this._initNamed(F, O);
    }
    return l(D, k), D.prototype._initNamed = function(H, Z) {
      k.call(this, H, Z);
    }, new D(this);
  }, p.prototype._getDecoder = function(k) {
    return k = k || "der", this.decoders.hasOwnProperty(k) || (this.decoders[k] = this._createNamed(c[k])), this.decoders[k];
  }, p.prototype.decode = function(k, O, D) {
    return this._getDecoder(O).decode(k, D);
  }, p.prototype._getEncoder = function(k) {
    return k = k || "der", this.encoders.hasOwnProperty(k) || (this.encoders[k] = this._createNamed(u[k])), this.encoders[k];
  }, p.prototype.encode = function(k, O, D) {
    return this._getEncoder(O).encode(k, D);
  };
})(api);
var base = {};
(function(a) {
  const u = a;
  u.Reporter = reporter.Reporter, u.DecoderBuffer = buffer.DecoderBuffer, u.EncoderBuffer = buffer.EncoderBuffer, u.Node = node;
})(base);
var constants = {};
(function(a) {
  const u = a;
  u._reverse = function(l) {
    const v = {};
    return Object.keys(l).forEach(function(p) {
      (p | 0) == p && (p = p | 0);
      const _ = l[p];
      v[_] = p;
    }), v;
  }, u.der = der$2;
})(constants);
(function(a) {
  const u = a;
  u.bignum = bnExports$2, u.define = api.define, u.base = base, u.constants = constants, u.decoders = decoders, u.encoders = encoders;
})(asn1$2);
var asn = asn1$2, Time = asn.define("Time", function() {
  this.choice({
    utcTime: this.utctime(),
    generalTime: this.gentime()
  });
}), AttributeTypeValue = asn.define("AttributeTypeValue", function() {
  this.seq().obj(
    this.key("type").objid(),
    this.key("value").any()
  );
}), AlgorithmIdentifier$1 = asn.define("AlgorithmIdentifier", function() {
  this.seq().obj(
    this.key("algorithm").objid(),
    this.key("parameters").optional(),
    this.key("curve").objid().optional()
  );
}), SubjectPublicKeyInfo = asn.define("SubjectPublicKeyInfo", function() {
  this.seq().obj(
    this.key("algorithm").use(AlgorithmIdentifier$1),
    this.key("subjectPublicKey").bitstr()
  );
}), RelativeDistinguishedName = asn.define("RelativeDistinguishedName", function() {
  this.setof(AttributeTypeValue);
}), RDNSequence = asn.define("RDNSequence", function() {
  this.seqof(RelativeDistinguishedName);
}), Name = asn.define("Name", function() {
  this.choice({
    rdnSequence: this.use(RDNSequence)
  });
}), Validity = asn.define("Validity", function() {
  this.seq().obj(
    this.key("notBefore").use(Time),
    this.key("notAfter").use(Time)
  );
}), Extension = asn.define("Extension", function() {
  this.seq().obj(
    this.key("extnID").objid(),
    this.key("critical").bool().def(!1),
    this.key("extnValue").octstr()
  );
}), TBSCertificate = asn.define("TBSCertificate", function() {
  this.seq().obj(
    this.key("version").explicit(0).int().optional(),
    this.key("serialNumber").int(),
    this.key("signature").use(AlgorithmIdentifier$1),
    this.key("issuer").use(Name),
    this.key("validity").use(Validity),
    this.key("subject").use(Name),
    this.key("subjectPublicKeyInfo").use(SubjectPublicKeyInfo),
    this.key("issuerUniqueID").implicit(1).bitstr().optional(),
    this.key("subjectUniqueID").implicit(2).bitstr().optional(),
    this.key("extensions").explicit(3).seqof(Extension).optional()
  );
}), X509Certificate = asn.define("X509Certificate", function() {
  this.seq().obj(
    this.key("tbsCertificate").use(TBSCertificate),
    this.key("signatureAlgorithm").use(AlgorithmIdentifier$1),
    this.key("signatureValue").bitstr()
  );
}), certificate = X509Certificate, asn1$1 = asn1$2;
asn1$3.certificate = certificate;
var RSAPrivateKey = asn1$1.define("RSAPrivateKey", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("modulus").int(),
    this.key("publicExponent").int(),
    this.key("privateExponent").int(),
    this.key("prime1").int(),
    this.key("prime2").int(),
    this.key("exponent1").int(),
    this.key("exponent2").int(),
    this.key("coefficient").int()
  );
});
asn1$3.RSAPrivateKey = RSAPrivateKey;
var RSAPublicKey = asn1$1.define("RSAPublicKey", function() {
  this.seq().obj(
    this.key("modulus").int(),
    this.key("publicExponent").int()
  );
});
asn1$3.RSAPublicKey = RSAPublicKey;
var PublicKey = asn1$1.define("SubjectPublicKeyInfo", function() {
  this.seq().obj(
    this.key("algorithm").use(AlgorithmIdentifier),
    this.key("subjectPublicKey").bitstr()
  );
});
asn1$3.PublicKey = PublicKey;
var AlgorithmIdentifier = asn1$1.define("AlgorithmIdentifier", function() {
  this.seq().obj(
    this.key("algorithm").objid(),
    this.key("none").null_().optional(),
    this.key("curve").objid().optional(),
    this.key("params").seq().obj(
      this.key("p").int(),
      this.key("q").int(),
      this.key("g").int()
    ).optional()
  );
}), PrivateKeyInfo = asn1$1.define("PrivateKeyInfo", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("algorithm").use(AlgorithmIdentifier),
    this.key("subjectPrivateKey").octstr()
  );
});
asn1$3.PrivateKey = PrivateKeyInfo;
var EncryptedPrivateKeyInfo = asn1$1.define("EncryptedPrivateKeyInfo", function() {
  this.seq().obj(
    this.key("algorithm").seq().obj(
      this.key("id").objid(),
      this.key("decrypt").seq().obj(
        this.key("kde").seq().obj(
          this.key("id").objid(),
          this.key("kdeparams").seq().obj(
            this.key("salt").octstr(),
            this.key("iters").int()
          )
        ),
        this.key("cipher").seq().obj(
          this.key("algo").objid(),
          this.key("iv").octstr()
        )
      )
    ),
    this.key("subjectPrivateKey").octstr()
  );
});
asn1$3.EncryptedPrivateKey = EncryptedPrivateKeyInfo;
var DSAPrivateKey = asn1$1.define("DSAPrivateKey", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("p").int(),
    this.key("q").int(),
    this.key("g").int(),
    this.key("pub_key").int(),
    this.key("priv_key").int()
  );
});
asn1$3.DSAPrivateKey = DSAPrivateKey;
asn1$3.DSAparam = asn1$1.define("DSAparam", function() {
  this.int();
});
var ECPrivateKey = asn1$1.define("ECPrivateKey", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("privateKey").octstr(),
    this.key("parameters").optional().explicit(0).use(ECParameters),
    this.key("publicKey").optional().explicit(1).bitstr()
  );
});
asn1$3.ECPrivateKey = ECPrivateKey;
var ECParameters = asn1$1.define("ECParameters", function() {
  this.choice({
    namedCurve: this.objid()
  });
});
asn1$3.signature = asn1$1.define("signature", function() {
  this.seq().obj(
    this.key("r").int(),
    this.key("s").int()
  );
});
const require$$1 = {
  "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
  "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
  "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
  "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
  "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
  "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
  "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
  "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
  "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
  "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
  "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
  "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
};
var findProc = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, startRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, fullRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, evp = evp_bytestokey, ciphers$1 = browser$6, Buffer$b = safeBufferExports$3.Buffer, fixProc$1 = function(a, u) {
  var c = a.toString(), l = c.match(findProc), v;
  if (l) {
    var _ = "aes" + l[1], k = Buffer$b.from(l[2], "hex"), O = Buffer$b.from(l[3].replace(/[\r\n]/g, ""), "base64"), D = evp(u, k.slice(0, 8), parseInt(l[1], 10)).key, F = [], H = ciphers$1.createDecipheriv(_, D, k);
    F.push(H.update(O)), F.push(H.final()), v = Buffer$b.concat(F);
  } else {
    var p = c.match(fullRegex);
    v = Buffer$b.from(p[2].replace(/[\r\n]/g, ""), "base64");
  }
  var Z = c.match(startRegex)[1];
  return {
    tag: Z,
    data: v
  };
}, asn1 = asn1$3, aesid = require$$1, fixProc = fixProc$1, ciphers = browser$6, compat = browser$8, Buffer$a = safeBufferExports$3.Buffer, parseAsn1 = parseKeys$2;
function parseKeys$2(a) {
  var u;
  typeof a == "object" && !Buffer$a.isBuffer(a) && (u = a.passphrase, a = a.key), typeof a == "string" && (a = Buffer$a.from(a));
  var c = fixProc(a, u), l = c.tag, v = c.data, p, _;
  switch (l) {
    case "CERTIFICATE":
      _ = asn1.certificate.decode(v, "der").tbsCertificate.subjectPublicKeyInfo;
    case "PUBLIC KEY":
      switch (_ || (_ = asn1.PublicKey.decode(v, "der")), p = _.algorithm.algorithm.join("."), p) {
        case "1.2.840.113549.1.1.1":
          return asn1.RSAPublicKey.decode(_.subjectPublicKey.data, "der");
        case "1.2.840.10045.2.1":
          return _.subjectPrivateKey = _.subjectPublicKey, {
            type: "ec",
            data: _
          };
        case "1.2.840.10040.4.1":
          return _.algorithm.params.pub_key = asn1.DSAparam.decode(_.subjectPublicKey.data, "der"), {
            type: "dsa",
            data: _.algorithm.params
          };
        default:
          throw new Error("unknown key id " + p);
      }
    case "ENCRYPTED PRIVATE KEY":
      v = asn1.EncryptedPrivateKey.decode(v, "der"), v = decrypt(v, u);
    case "PRIVATE KEY":
      switch (_ = asn1.PrivateKey.decode(v, "der"), p = _.algorithm.algorithm.join("."), p) {
        case "1.2.840.113549.1.1.1":
          return asn1.RSAPrivateKey.decode(_.subjectPrivateKey, "der");
        case "1.2.840.10045.2.1":
          return {
            curve: _.algorithm.curve,
            privateKey: asn1.ECPrivateKey.decode(_.subjectPrivateKey, "der").privateKey
          };
        case "1.2.840.10040.4.1":
          return _.algorithm.params.priv_key = asn1.DSAparam.decode(_.subjectPrivateKey, "der"), {
            type: "dsa",
            params: _.algorithm.params
          };
        default:
          throw new Error("unknown key id " + p);
      }
    case "RSA PUBLIC KEY":
      return asn1.RSAPublicKey.decode(v, "der");
    case "RSA PRIVATE KEY":
      return asn1.RSAPrivateKey.decode(v, "der");
    case "DSA PRIVATE KEY":
      return {
        type: "dsa",
        params: asn1.DSAPrivateKey.decode(v, "der")
      };
    case "EC PRIVATE KEY":
      return v = asn1.ECPrivateKey.decode(v, "der"), {
        curve: v.parameters.value,
        privateKey: v.privateKey
      };
    default:
      throw new Error("unknown key type " + l);
  }
}
parseKeys$2.signature = asn1.signature;
function decrypt(a, u) {
  var c = a.algorithm.decrypt.kde.kdeparams.salt, l = parseInt(a.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), v = aesid[a.algorithm.decrypt.cipher.algo.join(".")], p = a.algorithm.decrypt.cipher.iv, _ = a.subjectPrivateKey, k = parseInt(v.split("-")[1], 10) / 8, O = compat.pbkdf2Sync(u, c, l, k, "sha1"), D = ciphers.createDecipheriv(v, O, p), F = [];
  return F.push(D.update(_)), F.push(D.final()), Buffer$a.concat(F);
}
const require$$4 = {
  "1.3.132.0.10": "secp256k1",
  "1.3.132.0.33": "p224",
  "1.2.840.10045.3.1.1": "p192",
  "1.2.840.10045.3.1.7": "p256",
  "1.3.132.0.34": "p384",
  "1.3.132.0.35": "p521"
};
var hasRequiredSign;
function requireSign() {
  if (hasRequiredSign)
    return sign$1.exports;
  hasRequiredSign = 1;
  var a = safeBufferExports.Buffer, u = browser$9, c = browserifyRsa, l = requireElliptic().ec, v = bnExports$4, p = parseAsn1, _ = require$$4, k = 1;
  function O(ae, j, ue, he, fe) {
    var be = p(j);
    if (be.curve) {
      if (he !== "ecdsa" && he !== "ecdsa/rsa")
        throw new Error("wrong private key type");
      return D(ae, be);
    } else if (be.type === "dsa") {
      if (he !== "dsa")
        throw new Error("wrong private key type");
      return F(ae, be, ue);
    }
    if (he !== "rsa" && he !== "ecdsa/rsa")
      throw new Error("wrong private key type");
    if (j.padding !== void 0 && j.padding !== k)
      throw new Error("illegal or unsupported padding mode");
    ae = a.concat([fe, ae]);
    for (var ke = be.modulus.byteLength(), Te = [0, 1]; ae.length + Te.length + 1 < ke; )
      Te.push(255);
    Te.push(0);
    for (var q = -1; ++q < ae.length; )
      Te.push(ae[q]);
    var z = c(Te, be);
    return z;
  }
  function D(ae, j) {
    var ue = _[j.curve.join(".")];
    if (!ue)
      throw new Error("unknown curve " + j.curve.join("."));
    var he = new l(ue), fe = he.keyFromPrivate(j.privateKey), be = fe.sign(ae);
    return a.from(be.toDER());
  }
  function F(ae, j, ue) {
    for (var he = j.params.priv_key, fe = j.params.p, be = j.params.q, ke = j.params.g, Te = new v(0), q, z = ee(ae, be).mod(be), P = !1, S = Z(he, be, ae, ue); P === !1; )
      q = ne(be, S, ue), Te = Q(ke, q, fe, be), P = q.invm(be).imul(z.add(he.mul(Te))).mod(be), P.cmpn(0) === 0 && (P = !1, Te = new v(0));
    return H(Te, P);
  }
  function H(ae, j) {
    ae = ae.toArray(), j = j.toArray(), ae[0] & 128 && (ae = [0].concat(ae)), j[0] & 128 && (j = [0].concat(j));
    var ue = ae.length + j.length + 4, he = [
      48,
      ue,
      2,
      ae.length
    ];
    return he = he.concat(ae, [2, j.length], j), a.from(he);
  }
  function Z(ae, j, ue, he) {
    if (ae = a.from(ae.toArray()), ae.length < j.byteLength()) {
      var fe = a.alloc(j.byteLength() - ae.length);
      ae = a.concat([fe, ae]);
    }
    var be = ue.length, ke = X(ue, j), Te = a.alloc(be);
    Te.fill(1);
    var q = a.alloc(be);
    return q = u(he, q).update(Te).update(a.from([0])).update(ae).update(ke).digest(), Te = u(he, q).update(Te).digest(), q = u(he, q).update(Te).update(a.from([1])).update(ae).update(ke).digest(), Te = u(he, q).update(Te).digest(), { k: q, v: Te };
  }
  function ee(ae, j) {
    var ue = new v(ae), he = (ae.length << 3) - j.bitLength();
    return he > 0 && ue.ishrn(he), ue;
  }
  function X(ae, j) {
    ae = ee(ae, j), ae = ae.mod(j);
    var ue = a.from(ae.toArray());
    if (ue.length < j.byteLength()) {
      var he = a.alloc(j.byteLength() - ue.length);
      ue = a.concat([he, ue]);
    }
    return ue;
  }
  function ne(ae, j, ue) {
    var he, fe;
    do {
      for (he = a.alloc(0); he.length * 8 < ae.bitLength(); )
        j.v = u(ue, j.k).update(j.v).digest(), he = a.concat([he, j.v]);
      fe = ee(he, ae), j.k = u(ue, j.k).update(j.v).update(a.from([0])).digest(), j.v = u(ue, j.k).update(j.v).digest();
    } while (fe.cmp(ae) !== -1);
    return fe;
  }
  function Q(ae, j, ue, he) {
    return ae.toRed(v.mont(ue)).redPow(j).fromRed().mod(he);
  }
  return sign$1.exports = O, sign$1.exports.getKey = Z, sign$1.exports.makeKey = ne, sign$1.exports;
}
var verify_1, hasRequiredVerify;
function requireVerify() {
  if (hasRequiredVerify)
    return verify_1;
  hasRequiredVerify = 1;
  var a = safeBufferExports.Buffer, u = bnExports$4, c = requireElliptic().ec, l = parseAsn1, v = require$$4;
  function p(D, F, H, Z, ee) {
    var X = l(H);
    if (X.type === "ec") {
      if (Z !== "ecdsa" && Z !== "ecdsa/rsa")
        throw new Error("wrong public key type");
      return _(D, F, X);
    } else if (X.type === "dsa") {
      if (Z !== "dsa")
        throw new Error("wrong public key type");
      return k(D, F, X);
    }
    if (Z !== "rsa" && Z !== "ecdsa/rsa")
      throw new Error("wrong public key type");
    F = a.concat([ee, F]);
    for (var ne = X.modulus.byteLength(), Q = [1], ae = 0; F.length + Q.length + 2 < ne; )
      Q.push(255), ae += 1;
    Q.push(0);
    for (var j = -1; ++j < F.length; )
      Q.push(F[j]);
    Q = a.from(Q);
    var ue = u.mont(X.modulus);
    D = new u(D).toRed(ue), D = D.redPow(new u(X.publicExponent)), D = a.from(D.fromRed().toArray());
    var he = ae < 8 ? 1 : 0;
    for (ne = Math.min(D.length, Q.length), D.length !== Q.length && (he = 1), j = -1; ++j < ne; )
      he |= D[j] ^ Q[j];
    return he === 0;
  }
  function _(D, F, H) {
    var Z = v[H.data.algorithm.curve.join(".")];
    if (!Z)
      throw new Error("unknown curve " + H.data.algorithm.curve.join("."));
    var ee = new c(Z), X = H.data.subjectPrivateKey.data;
    return ee.verify(F, D, X);
  }
  function k(D, F, H) {
    var Z = H.data.p, ee = H.data.q, X = H.data.g, ne = H.data.pub_key, Q = l.signature.decode(D, "der"), ae = Q.s, j = Q.r;
    O(ae, ee), O(j, ee);
    var ue = u.mont(Z), he = ae.invm(ee), fe = X.toRed(ue).redPow(new u(F).mul(he).mod(ee)).fromRed().mul(ne.toRed(ue).redPow(j.mul(he).mod(ee)).fromRed()).mod(Z).mod(ee);
    return fe.cmp(j) === 0;
  }
  function O(D, F) {
    if (D.cmpn(0) <= 0)
      throw new Error("invalid sig");
    if (D.cmp(F) >= 0)
      throw new Error("invalid sig");
  }
  return verify_1 = p, verify_1;
}
var browser$4, hasRequiredBrowser$1;
function requireBrowser$1() {
  if (hasRequiredBrowser$1)
    return browser$4;
  hasRequiredBrowser$1 = 1;
  var a = safeBufferExports.Buffer, u = browser$a, c = readableBrowserExports, l = inherits_browserExports, v = requireSign(), p = requireVerify(), _ = require$$6;
  Object.keys(_).forEach(function(H) {
    _[H].id = a.from(_[H].id, "hex"), _[H.toLowerCase()] = _[H];
  });
  function k(H) {
    c.Writable.call(this);
    var Z = _[H];
    if (!Z)
      throw new Error("Unknown message digest");
    this._hashType = Z.hash, this._hash = u(Z.hash), this._tag = Z.id, this._signType = Z.sign;
  }
  l(k, c.Writable), k.prototype._write = function(Z, ee, X) {
    this._hash.update(Z), X();
  }, k.prototype.update = function(Z, ee) {
    return this._hash.update(typeof Z == "string" ? a.from(Z, ee) : Z), this;
  }, k.prototype.sign = function(Z, ee) {
    this.end();
    var X = this._hash.digest(), ne = v(X, Z, this._hashType, this._signType, this._tag);
    return ee ? ne.toString(ee) : ne;
  };
  function O(H) {
    c.Writable.call(this);
    var Z = _[H];
    if (!Z)
      throw new Error("Unknown message digest");
    this._hash = u(Z.hash), this._tag = Z.id, this._signType = Z.sign;
  }
  l(O, c.Writable), O.prototype._write = function(Z, ee, X) {
    this._hash.update(Z), X();
  }, O.prototype.update = function(Z, ee) {
    return this._hash.update(typeof Z == "string" ? a.from(Z, ee) : Z), this;
  }, O.prototype.verify = function(Z, ee, X) {
    var ne = typeof ee == "string" ? a.from(ee, X) : ee;
    this.end();
    var Q = this._hash.digest();
    return p(ne, Q, Z, this._signType, this._tag);
  };
  function D(H) {
    return new k(H);
  }
  function F(H) {
    return new O(H);
  }
  return browser$4 = {
    Sign: D,
    Verify: F,
    createSign: D,
    createVerify: F
  }, browser$4;
}
var bn$1 = { exports: {} };
bn$1.exports;
(function(a) {
  (function(u, c) {
    function l(P, S) {
      if (!P)
        throw new Error(S || "Assertion failed");
    }
    function v(P, S) {
      P.super_ = S;
      var E = function() {
      };
      E.prototype = S.prototype, P.prototype = new E(), P.prototype.constructor = P;
    }
    function p(P, S, E) {
      if (p.isBN(P))
        return P;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, P !== null && ((S === "le" || S === "be") && (E = S, S = 10), this._init(P || 0, S || 10, E || "be"));
    }
    typeof u == "object" ? u.exports = p : c.BN = p, p.BN = p, p.wordSize = 26;
    var _;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? _ = window.Buffer : _ = require$$0$2.Buffer;
    } catch {
    }
    p.isBN = function(S) {
      return S instanceof p ? !0 : S !== null && typeof S == "object" && S.constructor.wordSize === p.wordSize && Array.isArray(S.words);
    }, p.max = function(S, E) {
      return S.cmp(E) > 0 ? S : E;
    }, p.min = function(S, E) {
      return S.cmp(E) < 0 ? S : E;
    }, p.prototype._init = function(S, E, I) {
      if (typeof S == "number")
        return this._initNumber(S, E, I);
      if (typeof S == "object")
        return this._initArray(S, E, I);
      E === "hex" && (E = 16), l(E === (E | 0) && E >= 2 && E <= 36), S = S.toString().replace(/\s+/g, "");
      var M = 0;
      S[0] === "-" && (M++, this.negative = 1), M < S.length && (E === 16 ? this._parseHex(S, M, I) : (this._parseBase(S, E, M), I === "le" && this._initArray(this.toArray(), E, I)));
    }, p.prototype._initNumber = function(S, E, I) {
      S < 0 && (this.negative = 1, S = -S), S < 67108864 ? (this.words = [S & 67108863], this.length = 1) : S < 4503599627370496 ? (this.words = [
        S & 67108863,
        S / 67108864 & 67108863
      ], this.length = 2) : (l(S < 9007199254740992), this.words = [
        S & 67108863,
        S / 67108864 & 67108863,
        1
      ], this.length = 3), I === "le" && this._initArray(this.toArray(), E, I);
    }, p.prototype._initArray = function(S, E, I) {
      if (l(typeof S.length == "number"), S.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(S.length / 3), this.words = new Array(this.length);
      for (var M = 0; M < this.length; M++)
        this.words[M] = 0;
      var $, U, Y = 0;
      if (I === "be")
        for (M = S.length - 1, $ = 0; M >= 0; M -= 3)
          U = S[M] | S[M - 1] << 8 | S[M - 2] << 16, this.words[$] |= U << Y & 67108863, this.words[$ + 1] = U >>> 26 - Y & 67108863, Y += 24, Y >= 26 && (Y -= 26, $++);
      else if (I === "le")
        for (M = 0, $ = 0; M < S.length; M += 3)
          U = S[M] | S[M + 1] << 8 | S[M + 2] << 16, this.words[$] |= U << Y & 67108863, this.words[$ + 1] = U >>> 26 - Y & 67108863, Y += 24, Y >= 26 && (Y -= 26, $++);
      return this.strip();
    };
    function k(P, S) {
      var E = P.charCodeAt(S);
      return E >= 65 && E <= 70 ? E - 55 : E >= 97 && E <= 102 ? E - 87 : E - 48 & 15;
    }
    function O(P, S, E) {
      var I = k(P, E);
      return E - 1 >= S && (I |= k(P, E - 1) << 4), I;
    }
    p.prototype._parseHex = function(S, E, I) {
      this.length = Math.ceil((S.length - E) / 6), this.words = new Array(this.length);
      for (var M = 0; M < this.length; M++)
        this.words[M] = 0;
      var $ = 0, U = 0, Y;
      if (I === "be")
        for (M = S.length - 1; M >= E; M -= 2)
          Y = O(S, E, M) << $, this.words[U] |= Y & 67108863, $ >= 18 ? ($ -= 18, U += 1, this.words[U] |= Y >>> 26) : $ += 8;
      else {
        var B = S.length - E;
        for (M = B % 2 === 0 ? E + 1 : E; M < S.length; M += 2)
          Y = O(S, E, M) << $, this.words[U] |= Y & 67108863, $ >= 18 ? ($ -= 18, U += 1, this.words[U] |= Y >>> 26) : $ += 8;
      }
      this.strip();
    };
    function D(P, S, E, I) {
      for (var M = 0, $ = Math.min(P.length, E), U = S; U < $; U++) {
        var Y = P.charCodeAt(U) - 48;
        M *= I, Y >= 49 ? M += Y - 49 + 10 : Y >= 17 ? M += Y - 17 + 10 : M += Y;
      }
      return M;
    }
    p.prototype._parseBase = function(S, E, I) {
      this.words = [0], this.length = 1;
      for (var M = 0, $ = 1; $ <= 67108863; $ *= E)
        M++;
      M--, $ = $ / E | 0;
      for (var U = S.length - I, Y = U % M, B = Math.min(U, U - Y) + I, T = 0, L = I; L < B; L += M)
        T = D(S, L, L + M, E), this.imuln($), this.words[0] + T < 67108864 ? this.words[0] += T : this._iaddn(T);
      if (Y !== 0) {
        var te = 1;
        for (T = D(S, L, S.length, E), L = 0; L < Y; L++)
          te *= E;
        this.imuln(te), this.words[0] + T < 67108864 ? this.words[0] += T : this._iaddn(T);
      }
      this.strip();
    }, p.prototype.copy = function(S) {
      S.words = new Array(this.length);
      for (var E = 0; E < this.length; E++)
        S.words[E] = this.words[E];
      S.length = this.length, S.negative = this.negative, S.red = this.red;
    }, p.prototype.clone = function() {
      var S = new p(null);
      return this.copy(S), S;
    }, p.prototype._expand = function(S) {
      for (; this.length < S; )
        this.words[this.length++] = 0;
      return this;
    }, p.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, p.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, p.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var F = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], H = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], Z = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    p.prototype.toString = function(S, E) {
      S = S || 10, E = E | 0 || 1;
      var I;
      if (S === 16 || S === "hex") {
        I = "";
        for (var M = 0, $ = 0, U = 0; U < this.length; U++) {
          var Y = this.words[U], B = ((Y << M | $) & 16777215).toString(16);
          $ = Y >>> 24 - M & 16777215, $ !== 0 || U !== this.length - 1 ? I = F[6 - B.length] + B + I : I = B + I, M += 2, M >= 26 && (M -= 26, U--);
        }
        for ($ !== 0 && (I = $.toString(16) + I); I.length % E !== 0; )
          I = "0" + I;
        return this.negative !== 0 && (I = "-" + I), I;
      }
      if (S === (S | 0) && S >= 2 && S <= 36) {
        var T = H[S], L = Z[S];
        I = "";
        var te = this.clone();
        for (te.negative = 0; !te.isZero(); ) {
          var me = te.modn(L).toString(S);
          te = te.idivn(L), te.isZero() ? I = me + I : I = F[T - me.length] + me + I;
        }
        for (this.isZero() && (I = "0" + I); I.length % E !== 0; )
          I = "0" + I;
        return this.negative !== 0 && (I = "-" + I), I;
      }
      l(!1, "Base should be between 2 and 36");
    }, p.prototype.toNumber = function() {
      var S = this.words[0];
      return this.length === 2 ? S += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? S += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && l(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -S : S;
    }, p.prototype.toJSON = function() {
      return this.toString(16);
    }, p.prototype.toBuffer = function(S, E) {
      return l(typeof _ < "u"), this.toArrayLike(_, S, E);
    }, p.prototype.toArray = function(S, E) {
      return this.toArrayLike(Array, S, E);
    }, p.prototype.toArrayLike = function(S, E, I) {
      var M = this.byteLength(), $ = I || Math.max(1, M);
      l(M <= $, "byte array longer than desired length"), l($ > 0, "Requested array length <= 0"), this.strip();
      var U = E === "le", Y = new S($), B, T, L = this.clone();
      if (U) {
        for (T = 0; !L.isZero(); T++)
          B = L.andln(255), L.iushrn(8), Y[T] = B;
        for (; T < $; T++)
          Y[T] = 0;
      } else {
        for (T = 0; T < $ - M; T++)
          Y[T] = 0;
        for (T = 0; !L.isZero(); T++)
          B = L.andln(255), L.iushrn(8), Y[$ - T - 1] = B;
      }
      return Y;
    }, Math.clz32 ? p.prototype._countBits = function(S) {
      return 32 - Math.clz32(S);
    } : p.prototype._countBits = function(S) {
      var E = S, I = 0;
      return E >= 4096 && (I += 13, E >>>= 13), E >= 64 && (I += 7, E >>>= 7), E >= 8 && (I += 4, E >>>= 4), E >= 2 && (I += 2, E >>>= 2), I + E;
    }, p.prototype._zeroBits = function(S) {
      if (S === 0)
        return 26;
      var E = S, I = 0;
      return E & 8191 || (I += 13, E >>>= 13), E & 127 || (I += 7, E >>>= 7), E & 15 || (I += 4, E >>>= 4), E & 3 || (I += 2, E >>>= 2), E & 1 || I++, I;
    }, p.prototype.bitLength = function() {
      var S = this.words[this.length - 1], E = this._countBits(S);
      return (this.length - 1) * 26 + E;
    };
    function ee(P) {
      for (var S = new Array(P.bitLength()), E = 0; E < S.length; E++) {
        var I = E / 26 | 0, M = E % 26;
        S[E] = (P.words[I] & 1 << M) >>> M;
      }
      return S;
    }
    p.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var S = 0, E = 0; E < this.length; E++) {
        var I = this._zeroBits(this.words[E]);
        if (S += I, I !== 26)
          break;
      }
      return S;
    }, p.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, p.prototype.toTwos = function(S) {
      return this.negative !== 0 ? this.abs().inotn(S).iaddn(1) : this.clone();
    }, p.prototype.fromTwos = function(S) {
      return this.testn(S - 1) ? this.notn(S).iaddn(1).ineg() : this.clone();
    }, p.prototype.isNeg = function() {
      return this.negative !== 0;
    }, p.prototype.neg = function() {
      return this.clone().ineg();
    }, p.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, p.prototype.iuor = function(S) {
      for (; this.length < S.length; )
        this.words[this.length++] = 0;
      for (var E = 0; E < S.length; E++)
        this.words[E] = this.words[E] | S.words[E];
      return this.strip();
    }, p.prototype.ior = function(S) {
      return l((this.negative | S.negative) === 0), this.iuor(S);
    }, p.prototype.or = function(S) {
      return this.length > S.length ? this.clone().ior(S) : S.clone().ior(this);
    }, p.prototype.uor = function(S) {
      return this.length > S.length ? this.clone().iuor(S) : S.clone().iuor(this);
    }, p.prototype.iuand = function(S) {
      var E;
      this.length > S.length ? E = S : E = this;
      for (var I = 0; I < E.length; I++)
        this.words[I] = this.words[I] & S.words[I];
      return this.length = E.length, this.strip();
    }, p.prototype.iand = function(S) {
      return l((this.negative | S.negative) === 0), this.iuand(S);
    }, p.prototype.and = function(S) {
      return this.length > S.length ? this.clone().iand(S) : S.clone().iand(this);
    }, p.prototype.uand = function(S) {
      return this.length > S.length ? this.clone().iuand(S) : S.clone().iuand(this);
    }, p.prototype.iuxor = function(S) {
      var E, I;
      this.length > S.length ? (E = this, I = S) : (E = S, I = this);
      for (var M = 0; M < I.length; M++)
        this.words[M] = E.words[M] ^ I.words[M];
      if (this !== E)
        for (; M < E.length; M++)
          this.words[M] = E.words[M];
      return this.length = E.length, this.strip();
    }, p.prototype.ixor = function(S) {
      return l((this.negative | S.negative) === 0), this.iuxor(S);
    }, p.prototype.xor = function(S) {
      return this.length > S.length ? this.clone().ixor(S) : S.clone().ixor(this);
    }, p.prototype.uxor = function(S) {
      return this.length > S.length ? this.clone().iuxor(S) : S.clone().iuxor(this);
    }, p.prototype.inotn = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = Math.ceil(S / 26) | 0, I = S % 26;
      this._expand(E), I > 0 && E--;
      for (var M = 0; M < E; M++)
        this.words[M] = ~this.words[M] & 67108863;
      return I > 0 && (this.words[M] = ~this.words[M] & 67108863 >> 26 - I), this.strip();
    }, p.prototype.notn = function(S) {
      return this.clone().inotn(S);
    }, p.prototype.setn = function(S, E) {
      l(typeof S == "number" && S >= 0);
      var I = S / 26 | 0, M = S % 26;
      return this._expand(I + 1), E ? this.words[I] = this.words[I] | 1 << M : this.words[I] = this.words[I] & ~(1 << M), this.strip();
    }, p.prototype.iadd = function(S) {
      var E;
      if (this.negative !== 0 && S.negative === 0)
        return this.negative = 0, E = this.isub(S), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && S.negative !== 0)
        return S.negative = 0, E = this.isub(S), S.negative = 1, E._normSign();
      var I, M;
      this.length > S.length ? (I = this, M = S) : (I = S, M = this);
      for (var $ = 0, U = 0; U < M.length; U++)
        E = (I.words[U] | 0) + (M.words[U] | 0) + $, this.words[U] = E & 67108863, $ = E >>> 26;
      for (; $ !== 0 && U < I.length; U++)
        E = (I.words[U] | 0) + $, this.words[U] = E & 67108863, $ = E >>> 26;
      if (this.length = I.length, $ !== 0)
        this.words[this.length] = $, this.length++;
      else if (I !== this)
        for (; U < I.length; U++)
          this.words[U] = I.words[U];
      return this;
    }, p.prototype.add = function(S) {
      var E;
      return S.negative !== 0 && this.negative === 0 ? (S.negative = 0, E = this.sub(S), S.negative ^= 1, E) : S.negative === 0 && this.negative !== 0 ? (this.negative = 0, E = S.sub(this), this.negative = 1, E) : this.length > S.length ? this.clone().iadd(S) : S.clone().iadd(this);
    }, p.prototype.isub = function(S) {
      if (S.negative !== 0) {
        S.negative = 0;
        var E = this.iadd(S);
        return S.negative = 1, E._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(S), this.negative = 1, this._normSign();
      var I = this.cmp(S);
      if (I === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var M, $;
      I > 0 ? (M = this, $ = S) : (M = S, $ = this);
      for (var U = 0, Y = 0; Y < $.length; Y++)
        E = (M.words[Y] | 0) - ($.words[Y] | 0) + U, U = E >> 26, this.words[Y] = E & 67108863;
      for (; U !== 0 && Y < M.length; Y++)
        E = (M.words[Y] | 0) + U, U = E >> 26, this.words[Y] = E & 67108863;
      if (U === 0 && Y < M.length && M !== this)
        for (; Y < M.length; Y++)
          this.words[Y] = M.words[Y];
      return this.length = Math.max(this.length, Y), M !== this && (this.negative = 1), this.strip();
    }, p.prototype.sub = function(S) {
      return this.clone().isub(S);
    };
    function X(P, S, E) {
      E.negative = S.negative ^ P.negative;
      var I = P.length + S.length | 0;
      E.length = I, I = I - 1 | 0;
      var M = P.words[0] | 0, $ = S.words[0] | 0, U = M * $, Y = U & 67108863, B = U / 67108864 | 0;
      E.words[0] = Y;
      for (var T = 1; T < I; T++) {
        for (var L = B >>> 26, te = B & 67108863, me = Math.min(T, S.length - 1), Ce = Math.max(0, T - P.length + 1); Ce <= me; Ce++) {
          var De = T - Ce | 0;
          M = P.words[De] | 0, $ = S.words[Ce] | 0, U = M * $ + te, L += U / 67108864 | 0, te = U & 67108863;
        }
        E.words[T] = te | 0, B = L | 0;
      }
      return B !== 0 ? E.words[T] = B | 0 : E.length--, E.strip();
    }
    var ne = function(S, E, I) {
      var M = S.words, $ = E.words, U = I.words, Y = 0, B, T, L, te = M[0] | 0, me = te & 8191, Ce = te >>> 13, De = M[1] | 0, ye = De & 8191, pe = De >>> 13, Me = M[2] | 0, Ne = Me & 8191, Ue = Me >>> 13, oe = M[3] | 0, A = oe & 8191, re = oe >>> 13, le = M[4] | 0, $e = le & 8191, Oe = le >>> 13, Fe = M[5] | 0, Ze = Fe & 8191, qe = Fe >>> 13, yt = M[6] | 0, Xe = yt & 8191, Ge = yt >>> 13, J = M[7] | 0, ge = J & 8191, we = J >>> 13, We = M[8] | 0, Ie = We & 8191, V = We >>> 13, Ee = M[9] | 0, de = Ee & 8191, ce = Ee >>> 13, ve = $[0] | 0, Pe = ve & 8191, Be = ve >>> 13, ze = $[1] | 0, Je = ze & 8191, je = ze >>> 13, Ke = $[2] | 0, x = Ke & 8191, se = Ke >>> 13, Se = $[3] | 0, xe = Se & 8191, Ae = Se >>> 13, Ye = $[4] | 0, et = Ye & 8191, dt = Ye >>> 13, St = $[5] | 0, tt = St & 8191, at = St >>> 13, kt = $[6] | 0, rt = kt & 8191, ut = kt >>> 13, wt = $[7] | 0, nt = wt & 8191, it = wt >>> 13, bt = $[8] | 0, ot = bt & 8191, ct = bt >>> 13, Pt = $[9] | 0, st = Pt & 8191, lt = Pt >>> 13;
      I.negative = S.negative ^ E.negative, I.length = 19, B = Math.imul(me, Pe), T = Math.imul(me, Be), T = T + Math.imul(Ce, Pe) | 0, L = Math.imul(Ce, Be);
      var It = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (It >>> 26) | 0, It &= 67108863, B = Math.imul(ye, Pe), T = Math.imul(ye, Be), T = T + Math.imul(pe, Pe) | 0, L = Math.imul(pe, Be), B = B + Math.imul(me, Je) | 0, T = T + Math.imul(me, je) | 0, T = T + Math.imul(Ce, Je) | 0, L = L + Math.imul(Ce, je) | 0;
      var Rt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (Rt >>> 26) | 0, Rt &= 67108863, B = Math.imul(Ne, Pe), T = Math.imul(Ne, Be), T = T + Math.imul(Ue, Pe) | 0, L = Math.imul(Ue, Be), B = B + Math.imul(ye, Je) | 0, T = T + Math.imul(ye, je) | 0, T = T + Math.imul(pe, Je) | 0, L = L + Math.imul(pe, je) | 0, B = B + Math.imul(me, x) | 0, T = T + Math.imul(me, se) | 0, T = T + Math.imul(Ce, x) | 0, L = L + Math.imul(Ce, se) | 0;
      var Ve = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, B = Math.imul(A, Pe), T = Math.imul(A, Be), T = T + Math.imul(re, Pe) | 0, L = Math.imul(re, Be), B = B + Math.imul(Ne, Je) | 0, T = T + Math.imul(Ne, je) | 0, T = T + Math.imul(Ue, Je) | 0, L = L + Math.imul(Ue, je) | 0, B = B + Math.imul(ye, x) | 0, T = T + Math.imul(ye, se) | 0, T = T + Math.imul(pe, x) | 0, L = L + Math.imul(pe, se) | 0, B = B + Math.imul(me, xe) | 0, T = T + Math.imul(me, Ae) | 0, T = T + Math.imul(Ce, xe) | 0, L = L + Math.imul(Ce, Ae) | 0;
      var He = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, B = Math.imul($e, Pe), T = Math.imul($e, Be), T = T + Math.imul(Oe, Pe) | 0, L = Math.imul(Oe, Be), B = B + Math.imul(A, Je) | 0, T = T + Math.imul(A, je) | 0, T = T + Math.imul(re, Je) | 0, L = L + Math.imul(re, je) | 0, B = B + Math.imul(Ne, x) | 0, T = T + Math.imul(Ne, se) | 0, T = T + Math.imul(Ue, x) | 0, L = L + Math.imul(Ue, se) | 0, B = B + Math.imul(ye, xe) | 0, T = T + Math.imul(ye, Ae) | 0, T = T + Math.imul(pe, xe) | 0, L = L + Math.imul(pe, Ae) | 0, B = B + Math.imul(me, et) | 0, T = T + Math.imul(me, dt) | 0, T = T + Math.imul(Ce, et) | 0, L = L + Math.imul(Ce, dt) | 0;
      var Qe = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, B = Math.imul(Ze, Pe), T = Math.imul(Ze, Be), T = T + Math.imul(qe, Pe) | 0, L = Math.imul(qe, Be), B = B + Math.imul($e, Je) | 0, T = T + Math.imul($e, je) | 0, T = T + Math.imul(Oe, Je) | 0, L = L + Math.imul(Oe, je) | 0, B = B + Math.imul(A, x) | 0, T = T + Math.imul(A, se) | 0, T = T + Math.imul(re, x) | 0, L = L + Math.imul(re, se) | 0, B = B + Math.imul(Ne, xe) | 0, T = T + Math.imul(Ne, Ae) | 0, T = T + Math.imul(Ue, xe) | 0, L = L + Math.imul(Ue, Ae) | 0, B = B + Math.imul(ye, et) | 0, T = T + Math.imul(ye, dt) | 0, T = T + Math.imul(pe, et) | 0, L = L + Math.imul(pe, dt) | 0, B = B + Math.imul(me, tt) | 0, T = T + Math.imul(me, at) | 0, T = T + Math.imul(Ce, tt) | 0, L = L + Math.imul(Ce, at) | 0;
      var pt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (pt >>> 26) | 0, pt &= 67108863, B = Math.imul(Xe, Pe), T = Math.imul(Xe, Be), T = T + Math.imul(Ge, Pe) | 0, L = Math.imul(Ge, Be), B = B + Math.imul(Ze, Je) | 0, T = T + Math.imul(Ze, je) | 0, T = T + Math.imul(qe, Je) | 0, L = L + Math.imul(qe, je) | 0, B = B + Math.imul($e, x) | 0, T = T + Math.imul($e, se) | 0, T = T + Math.imul(Oe, x) | 0, L = L + Math.imul(Oe, se) | 0, B = B + Math.imul(A, xe) | 0, T = T + Math.imul(A, Ae) | 0, T = T + Math.imul(re, xe) | 0, L = L + Math.imul(re, Ae) | 0, B = B + Math.imul(Ne, et) | 0, T = T + Math.imul(Ne, dt) | 0, T = T + Math.imul(Ue, et) | 0, L = L + Math.imul(Ue, dt) | 0, B = B + Math.imul(ye, tt) | 0, T = T + Math.imul(ye, at) | 0, T = T + Math.imul(pe, tt) | 0, L = L + Math.imul(pe, at) | 0, B = B + Math.imul(me, rt) | 0, T = T + Math.imul(me, ut) | 0, T = T + Math.imul(Ce, rt) | 0, L = L + Math.imul(Ce, ut) | 0;
      var mt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (mt >>> 26) | 0, mt &= 67108863, B = Math.imul(ge, Pe), T = Math.imul(ge, Be), T = T + Math.imul(we, Pe) | 0, L = Math.imul(we, Be), B = B + Math.imul(Xe, Je) | 0, T = T + Math.imul(Xe, je) | 0, T = T + Math.imul(Ge, Je) | 0, L = L + Math.imul(Ge, je) | 0, B = B + Math.imul(Ze, x) | 0, T = T + Math.imul(Ze, se) | 0, T = T + Math.imul(qe, x) | 0, L = L + Math.imul(qe, se) | 0, B = B + Math.imul($e, xe) | 0, T = T + Math.imul($e, Ae) | 0, T = T + Math.imul(Oe, xe) | 0, L = L + Math.imul(Oe, Ae) | 0, B = B + Math.imul(A, et) | 0, T = T + Math.imul(A, dt) | 0, T = T + Math.imul(re, et) | 0, L = L + Math.imul(re, dt) | 0, B = B + Math.imul(Ne, tt) | 0, T = T + Math.imul(Ne, at) | 0, T = T + Math.imul(Ue, tt) | 0, L = L + Math.imul(Ue, at) | 0, B = B + Math.imul(ye, rt) | 0, T = T + Math.imul(ye, ut) | 0, T = T + Math.imul(pe, rt) | 0, L = L + Math.imul(pe, ut) | 0, B = B + Math.imul(me, nt) | 0, T = T + Math.imul(me, it) | 0, T = T + Math.imul(Ce, nt) | 0, L = L + Math.imul(Ce, it) | 0;
      var vt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, B = Math.imul(Ie, Pe), T = Math.imul(Ie, Be), T = T + Math.imul(V, Pe) | 0, L = Math.imul(V, Be), B = B + Math.imul(ge, Je) | 0, T = T + Math.imul(ge, je) | 0, T = T + Math.imul(we, Je) | 0, L = L + Math.imul(we, je) | 0, B = B + Math.imul(Xe, x) | 0, T = T + Math.imul(Xe, se) | 0, T = T + Math.imul(Ge, x) | 0, L = L + Math.imul(Ge, se) | 0, B = B + Math.imul(Ze, xe) | 0, T = T + Math.imul(Ze, Ae) | 0, T = T + Math.imul(qe, xe) | 0, L = L + Math.imul(qe, Ae) | 0, B = B + Math.imul($e, et) | 0, T = T + Math.imul($e, dt) | 0, T = T + Math.imul(Oe, et) | 0, L = L + Math.imul(Oe, dt) | 0, B = B + Math.imul(A, tt) | 0, T = T + Math.imul(A, at) | 0, T = T + Math.imul(re, tt) | 0, L = L + Math.imul(re, at) | 0, B = B + Math.imul(Ne, rt) | 0, T = T + Math.imul(Ne, ut) | 0, T = T + Math.imul(Ue, rt) | 0, L = L + Math.imul(Ue, ut) | 0, B = B + Math.imul(ye, nt) | 0, T = T + Math.imul(ye, it) | 0, T = T + Math.imul(pe, nt) | 0, L = L + Math.imul(pe, it) | 0, B = B + Math.imul(me, ot) | 0, T = T + Math.imul(me, ct) | 0, T = T + Math.imul(Ce, ot) | 0, L = L + Math.imul(Ce, ct) | 0;
      var ht = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (ht >>> 26) | 0, ht &= 67108863, B = Math.imul(de, Pe), T = Math.imul(de, Be), T = T + Math.imul(ce, Pe) | 0, L = Math.imul(ce, Be), B = B + Math.imul(Ie, Je) | 0, T = T + Math.imul(Ie, je) | 0, T = T + Math.imul(V, Je) | 0, L = L + Math.imul(V, je) | 0, B = B + Math.imul(ge, x) | 0, T = T + Math.imul(ge, se) | 0, T = T + Math.imul(we, x) | 0, L = L + Math.imul(we, se) | 0, B = B + Math.imul(Xe, xe) | 0, T = T + Math.imul(Xe, Ae) | 0, T = T + Math.imul(Ge, xe) | 0, L = L + Math.imul(Ge, Ae) | 0, B = B + Math.imul(Ze, et) | 0, T = T + Math.imul(Ze, dt) | 0, T = T + Math.imul(qe, et) | 0, L = L + Math.imul(qe, dt) | 0, B = B + Math.imul($e, tt) | 0, T = T + Math.imul($e, at) | 0, T = T + Math.imul(Oe, tt) | 0, L = L + Math.imul(Oe, at) | 0, B = B + Math.imul(A, rt) | 0, T = T + Math.imul(A, ut) | 0, T = T + Math.imul(re, rt) | 0, L = L + Math.imul(re, ut) | 0, B = B + Math.imul(Ne, nt) | 0, T = T + Math.imul(Ne, it) | 0, T = T + Math.imul(Ue, nt) | 0, L = L + Math.imul(Ue, it) | 0, B = B + Math.imul(ye, ot) | 0, T = T + Math.imul(ye, ct) | 0, T = T + Math.imul(pe, ot) | 0, L = L + Math.imul(pe, ct) | 0, B = B + Math.imul(me, st) | 0, T = T + Math.imul(me, lt) | 0, T = T + Math.imul(Ce, st) | 0, L = L + Math.imul(Ce, lt) | 0;
      var Et = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, B = Math.imul(de, Je), T = Math.imul(de, je), T = T + Math.imul(ce, Je) | 0, L = Math.imul(ce, je), B = B + Math.imul(Ie, x) | 0, T = T + Math.imul(Ie, se) | 0, T = T + Math.imul(V, x) | 0, L = L + Math.imul(V, se) | 0, B = B + Math.imul(ge, xe) | 0, T = T + Math.imul(ge, Ae) | 0, T = T + Math.imul(we, xe) | 0, L = L + Math.imul(we, Ae) | 0, B = B + Math.imul(Xe, et) | 0, T = T + Math.imul(Xe, dt) | 0, T = T + Math.imul(Ge, et) | 0, L = L + Math.imul(Ge, dt) | 0, B = B + Math.imul(Ze, tt) | 0, T = T + Math.imul(Ze, at) | 0, T = T + Math.imul(qe, tt) | 0, L = L + Math.imul(qe, at) | 0, B = B + Math.imul($e, rt) | 0, T = T + Math.imul($e, ut) | 0, T = T + Math.imul(Oe, rt) | 0, L = L + Math.imul(Oe, ut) | 0, B = B + Math.imul(A, nt) | 0, T = T + Math.imul(A, it) | 0, T = T + Math.imul(re, nt) | 0, L = L + Math.imul(re, it) | 0, B = B + Math.imul(Ne, ot) | 0, T = T + Math.imul(Ne, ct) | 0, T = T + Math.imul(Ue, ot) | 0, L = L + Math.imul(Ue, ct) | 0, B = B + Math.imul(ye, st) | 0, T = T + Math.imul(ye, lt) | 0, T = T + Math.imul(pe, st) | 0, L = L + Math.imul(pe, lt) | 0;
      var Tt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (Tt >>> 26) | 0, Tt &= 67108863, B = Math.imul(de, x), T = Math.imul(de, se), T = T + Math.imul(ce, x) | 0, L = Math.imul(ce, se), B = B + Math.imul(Ie, xe) | 0, T = T + Math.imul(Ie, Ae) | 0, T = T + Math.imul(V, xe) | 0, L = L + Math.imul(V, Ae) | 0, B = B + Math.imul(ge, et) | 0, T = T + Math.imul(ge, dt) | 0, T = T + Math.imul(we, et) | 0, L = L + Math.imul(we, dt) | 0, B = B + Math.imul(Xe, tt) | 0, T = T + Math.imul(Xe, at) | 0, T = T + Math.imul(Ge, tt) | 0, L = L + Math.imul(Ge, at) | 0, B = B + Math.imul(Ze, rt) | 0, T = T + Math.imul(Ze, ut) | 0, T = T + Math.imul(qe, rt) | 0, L = L + Math.imul(qe, ut) | 0, B = B + Math.imul($e, nt) | 0, T = T + Math.imul($e, it) | 0, T = T + Math.imul(Oe, nt) | 0, L = L + Math.imul(Oe, it) | 0, B = B + Math.imul(A, ot) | 0, T = T + Math.imul(A, ct) | 0, T = T + Math.imul(re, ot) | 0, L = L + Math.imul(re, ct) | 0, B = B + Math.imul(Ne, st) | 0, T = T + Math.imul(Ne, lt) | 0, T = T + Math.imul(Ue, st) | 0, L = L + Math.imul(Ue, lt) | 0;
      var Ot = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (Ot >>> 26) | 0, Ot &= 67108863, B = Math.imul(de, xe), T = Math.imul(de, Ae), T = T + Math.imul(ce, xe) | 0, L = Math.imul(ce, Ae), B = B + Math.imul(Ie, et) | 0, T = T + Math.imul(Ie, dt) | 0, T = T + Math.imul(V, et) | 0, L = L + Math.imul(V, dt) | 0, B = B + Math.imul(ge, tt) | 0, T = T + Math.imul(ge, at) | 0, T = T + Math.imul(we, tt) | 0, L = L + Math.imul(we, at) | 0, B = B + Math.imul(Xe, rt) | 0, T = T + Math.imul(Xe, ut) | 0, T = T + Math.imul(Ge, rt) | 0, L = L + Math.imul(Ge, ut) | 0, B = B + Math.imul(Ze, nt) | 0, T = T + Math.imul(Ze, it) | 0, T = T + Math.imul(qe, nt) | 0, L = L + Math.imul(qe, it) | 0, B = B + Math.imul($e, ot) | 0, T = T + Math.imul($e, ct) | 0, T = T + Math.imul(Oe, ot) | 0, L = L + Math.imul(Oe, ct) | 0, B = B + Math.imul(A, st) | 0, T = T + Math.imul(A, lt) | 0, T = T + Math.imul(re, st) | 0, L = L + Math.imul(re, lt) | 0;
      var Nt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, B = Math.imul(de, et), T = Math.imul(de, dt), T = T + Math.imul(ce, et) | 0, L = Math.imul(ce, dt), B = B + Math.imul(Ie, tt) | 0, T = T + Math.imul(Ie, at) | 0, T = T + Math.imul(V, tt) | 0, L = L + Math.imul(V, at) | 0, B = B + Math.imul(ge, rt) | 0, T = T + Math.imul(ge, ut) | 0, T = T + Math.imul(we, rt) | 0, L = L + Math.imul(we, ut) | 0, B = B + Math.imul(Xe, nt) | 0, T = T + Math.imul(Xe, it) | 0, T = T + Math.imul(Ge, nt) | 0, L = L + Math.imul(Ge, it) | 0, B = B + Math.imul(Ze, ot) | 0, T = T + Math.imul(Ze, ct) | 0, T = T + Math.imul(qe, ot) | 0, L = L + Math.imul(qe, ct) | 0, B = B + Math.imul($e, st) | 0, T = T + Math.imul($e, lt) | 0, T = T + Math.imul(Oe, st) | 0, L = L + Math.imul(Oe, lt) | 0;
      var At = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, B = Math.imul(de, tt), T = Math.imul(de, at), T = T + Math.imul(ce, tt) | 0, L = Math.imul(ce, at), B = B + Math.imul(Ie, rt) | 0, T = T + Math.imul(Ie, ut) | 0, T = T + Math.imul(V, rt) | 0, L = L + Math.imul(V, ut) | 0, B = B + Math.imul(ge, nt) | 0, T = T + Math.imul(ge, it) | 0, T = T + Math.imul(we, nt) | 0, L = L + Math.imul(we, it) | 0, B = B + Math.imul(Xe, ot) | 0, T = T + Math.imul(Xe, ct) | 0, T = T + Math.imul(Ge, ot) | 0, L = L + Math.imul(Ge, ct) | 0, B = B + Math.imul(Ze, st) | 0, T = T + Math.imul(Ze, lt) | 0, T = T + Math.imul(qe, st) | 0, L = L + Math.imul(qe, lt) | 0;
      var Mt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (Mt >>> 26) | 0, Mt &= 67108863, B = Math.imul(de, rt), T = Math.imul(de, ut), T = T + Math.imul(ce, rt) | 0, L = Math.imul(ce, ut), B = B + Math.imul(Ie, nt) | 0, T = T + Math.imul(Ie, it) | 0, T = T + Math.imul(V, nt) | 0, L = L + Math.imul(V, it) | 0, B = B + Math.imul(ge, ot) | 0, T = T + Math.imul(ge, ct) | 0, T = T + Math.imul(we, ot) | 0, L = L + Math.imul(we, ct) | 0, B = B + Math.imul(Xe, st) | 0, T = T + Math.imul(Xe, lt) | 0, T = T + Math.imul(Ge, st) | 0, L = L + Math.imul(Ge, lt) | 0;
      var $t = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + ($t >>> 26) | 0, $t &= 67108863, B = Math.imul(de, nt), T = Math.imul(de, it), T = T + Math.imul(ce, nt) | 0, L = Math.imul(ce, it), B = B + Math.imul(Ie, ot) | 0, T = T + Math.imul(Ie, ct) | 0, T = T + Math.imul(V, ot) | 0, L = L + Math.imul(V, ct) | 0, B = B + Math.imul(ge, st) | 0, T = T + Math.imul(ge, lt) | 0, T = T + Math.imul(we, st) | 0, L = L + Math.imul(we, lt) | 0;
      var Bt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, B = Math.imul(de, ot), T = Math.imul(de, ct), T = T + Math.imul(ce, ot) | 0, L = Math.imul(ce, ct), B = B + Math.imul(Ie, st) | 0, T = T + Math.imul(Ie, lt) | 0, T = T + Math.imul(V, st) | 0, L = L + Math.imul(V, lt) | 0;
      var Ut = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (Ut >>> 26) | 0, Ut &= 67108863, B = Math.imul(de, st), T = Math.imul(de, lt), T = T + Math.imul(ce, st) | 0, L = Math.imul(ce, lt);
      var xt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      return Y = (L + (T >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, U[0] = It, U[1] = Rt, U[2] = Ve, U[3] = He, U[4] = Qe, U[5] = pt, U[6] = mt, U[7] = vt, U[8] = ht, U[9] = Et, U[10] = Tt, U[11] = Ot, U[12] = Nt, U[13] = At, U[14] = Mt, U[15] = $t, U[16] = Bt, U[17] = Ut, U[18] = xt, Y !== 0 && (U[19] = Y, I.length++), I;
    };
    Math.imul || (ne = X);
    function Q(P, S, E) {
      E.negative = S.negative ^ P.negative, E.length = P.length + S.length;
      for (var I = 0, M = 0, $ = 0; $ < E.length - 1; $++) {
        var U = M;
        M = 0;
        for (var Y = I & 67108863, B = Math.min($, S.length - 1), T = Math.max(0, $ - P.length + 1); T <= B; T++) {
          var L = $ - T, te = P.words[L] | 0, me = S.words[T] | 0, Ce = te * me, De = Ce & 67108863;
          U = U + (Ce / 67108864 | 0) | 0, De = De + Y | 0, Y = De & 67108863, U = U + (De >>> 26) | 0, M += U >>> 26, U &= 67108863;
        }
        E.words[$] = Y, I = U, U = M;
      }
      return I !== 0 ? E.words[$] = I : E.length--, E.strip();
    }
    function ae(P, S, E) {
      var I = new j();
      return I.mulp(P, S, E);
    }
    p.prototype.mulTo = function(S, E) {
      var I, M = this.length + S.length;
      return this.length === 10 && S.length === 10 ? I = ne(this, S, E) : M < 63 ? I = X(this, S, E) : M < 1024 ? I = Q(this, S, E) : I = ae(this, S, E), I;
    };
    function j(P, S) {
      this.x = P, this.y = S;
    }
    j.prototype.makeRBT = function(S) {
      for (var E = new Array(S), I = p.prototype._countBits(S) - 1, M = 0; M < S; M++)
        E[M] = this.revBin(M, I, S);
      return E;
    }, j.prototype.revBin = function(S, E, I) {
      if (S === 0 || S === I - 1)
        return S;
      for (var M = 0, $ = 0; $ < E; $++)
        M |= (S & 1) << E - $ - 1, S >>= 1;
      return M;
    }, j.prototype.permute = function(S, E, I, M, $, U) {
      for (var Y = 0; Y < U; Y++)
        M[Y] = E[S[Y]], $[Y] = I[S[Y]];
    }, j.prototype.transform = function(S, E, I, M, $, U) {
      this.permute(U, S, E, I, M, $);
      for (var Y = 1; Y < $; Y <<= 1)
        for (var B = Y << 1, T = Math.cos(2 * Math.PI / B), L = Math.sin(2 * Math.PI / B), te = 0; te < $; te += B)
          for (var me = T, Ce = L, De = 0; De < Y; De++) {
            var ye = I[te + De], pe = M[te + De], Me = I[te + De + Y], Ne = M[te + De + Y], Ue = me * Me - Ce * Ne;
            Ne = me * Ne + Ce * Me, Me = Ue, I[te + De] = ye + Me, M[te + De] = pe + Ne, I[te + De + Y] = ye - Me, M[te + De + Y] = pe - Ne, De !== B && (Ue = T * me - L * Ce, Ce = T * Ce + L * me, me = Ue);
          }
    }, j.prototype.guessLen13b = function(S, E) {
      var I = Math.max(E, S) | 1, M = I & 1, $ = 0;
      for (I = I / 2 | 0; I; I = I >>> 1)
        $++;
      return 1 << $ + 1 + M;
    }, j.prototype.conjugate = function(S, E, I) {
      if (!(I <= 1))
        for (var M = 0; M < I / 2; M++) {
          var $ = S[M];
          S[M] = S[I - M - 1], S[I - M - 1] = $, $ = E[M], E[M] = -E[I - M - 1], E[I - M - 1] = -$;
        }
    }, j.prototype.normalize13b = function(S, E) {
      for (var I = 0, M = 0; M < E / 2; M++) {
        var $ = Math.round(S[2 * M + 1] / E) * 8192 + Math.round(S[2 * M] / E) + I;
        S[M] = $ & 67108863, $ < 67108864 ? I = 0 : I = $ / 67108864 | 0;
      }
      return S;
    }, j.prototype.convert13b = function(S, E, I, M) {
      for (var $ = 0, U = 0; U < E; U++)
        $ = $ + (S[U] | 0), I[2 * U] = $ & 8191, $ = $ >>> 13, I[2 * U + 1] = $ & 8191, $ = $ >>> 13;
      for (U = 2 * E; U < M; ++U)
        I[U] = 0;
      l($ === 0), l(($ & -8192) === 0);
    }, j.prototype.stub = function(S) {
      for (var E = new Array(S), I = 0; I < S; I++)
        E[I] = 0;
      return E;
    }, j.prototype.mulp = function(S, E, I) {
      var M = 2 * this.guessLen13b(S.length, E.length), $ = this.makeRBT(M), U = this.stub(M), Y = new Array(M), B = new Array(M), T = new Array(M), L = new Array(M), te = new Array(M), me = new Array(M), Ce = I.words;
      Ce.length = M, this.convert13b(S.words, S.length, Y, M), this.convert13b(E.words, E.length, L, M), this.transform(Y, U, B, T, M, $), this.transform(L, U, te, me, M, $);
      for (var De = 0; De < M; De++) {
        var ye = B[De] * te[De] - T[De] * me[De];
        T[De] = B[De] * me[De] + T[De] * te[De], B[De] = ye;
      }
      return this.conjugate(B, T, M), this.transform(B, T, Ce, U, M, $), this.conjugate(Ce, U, M), this.normalize13b(Ce, M), I.negative = S.negative ^ E.negative, I.length = S.length + E.length, I.strip();
    }, p.prototype.mul = function(S) {
      var E = new p(null);
      return E.words = new Array(this.length + S.length), this.mulTo(S, E);
    }, p.prototype.mulf = function(S) {
      var E = new p(null);
      return E.words = new Array(this.length + S.length), ae(this, S, E);
    }, p.prototype.imul = function(S) {
      return this.clone().mulTo(S, this);
    }, p.prototype.imuln = function(S) {
      l(typeof S == "number"), l(S < 67108864);
      for (var E = 0, I = 0; I < this.length; I++) {
        var M = (this.words[I] | 0) * S, $ = (M & 67108863) + (E & 67108863);
        E >>= 26, E += M / 67108864 | 0, E += $ >>> 26, this.words[I] = $ & 67108863;
      }
      return E !== 0 && (this.words[I] = E, this.length++), this;
    }, p.prototype.muln = function(S) {
      return this.clone().imuln(S);
    }, p.prototype.sqr = function() {
      return this.mul(this);
    }, p.prototype.isqr = function() {
      return this.imul(this.clone());
    }, p.prototype.pow = function(S) {
      var E = ee(S);
      if (E.length === 0)
        return new p(1);
      for (var I = this, M = 0; M < E.length && E[M] === 0; M++, I = I.sqr())
        ;
      if (++M < E.length)
        for (var $ = I.sqr(); M < E.length; M++, $ = $.sqr())
          E[M] !== 0 && (I = I.mul($));
      return I;
    }, p.prototype.iushln = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = S % 26, I = (S - E) / 26, M = 67108863 >>> 26 - E << 26 - E, $;
      if (E !== 0) {
        var U = 0;
        for ($ = 0; $ < this.length; $++) {
          var Y = this.words[$] & M, B = (this.words[$] | 0) - Y << E;
          this.words[$] = B | U, U = Y >>> 26 - E;
        }
        U && (this.words[$] = U, this.length++);
      }
      if (I !== 0) {
        for ($ = this.length - 1; $ >= 0; $--)
          this.words[$ + I] = this.words[$];
        for ($ = 0; $ < I; $++)
          this.words[$] = 0;
        this.length += I;
      }
      return this.strip();
    }, p.prototype.ishln = function(S) {
      return l(this.negative === 0), this.iushln(S);
    }, p.prototype.iushrn = function(S, E, I) {
      l(typeof S == "number" && S >= 0);
      var M;
      E ? M = (E - E % 26) / 26 : M = 0;
      var $ = S % 26, U = Math.min((S - $) / 26, this.length), Y = 67108863 ^ 67108863 >>> $ << $, B = I;
      if (M -= U, M = Math.max(0, M), B) {
        for (var T = 0; T < U; T++)
          B.words[T] = this.words[T];
        B.length = U;
      }
      if (U !== 0)
        if (this.length > U)
          for (this.length -= U, T = 0; T < this.length; T++)
            this.words[T] = this.words[T + U];
        else
          this.words[0] = 0, this.length = 1;
      var L = 0;
      for (T = this.length - 1; T >= 0 && (L !== 0 || T >= M); T--) {
        var te = this.words[T] | 0;
        this.words[T] = L << 26 - $ | te >>> $, L = te & Y;
      }
      return B && L !== 0 && (B.words[B.length++] = L), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, p.prototype.ishrn = function(S, E, I) {
      return l(this.negative === 0), this.iushrn(S, E, I);
    }, p.prototype.shln = function(S) {
      return this.clone().ishln(S);
    }, p.prototype.ushln = function(S) {
      return this.clone().iushln(S);
    }, p.prototype.shrn = function(S) {
      return this.clone().ishrn(S);
    }, p.prototype.ushrn = function(S) {
      return this.clone().iushrn(S);
    }, p.prototype.testn = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = S % 26, I = (S - E) / 26, M = 1 << E;
      if (this.length <= I)
        return !1;
      var $ = this.words[I];
      return !!($ & M);
    }, p.prototype.imaskn = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = S % 26, I = (S - E) / 26;
      if (l(this.negative === 0, "imaskn works only with positive numbers"), this.length <= I)
        return this;
      if (E !== 0 && I++, this.length = Math.min(I, this.length), E !== 0) {
        var M = 67108863 ^ 67108863 >>> E << E;
        this.words[this.length - 1] &= M;
      }
      return this.strip();
    }, p.prototype.maskn = function(S) {
      return this.clone().imaskn(S);
    }, p.prototype.iaddn = function(S) {
      return l(typeof S == "number"), l(S < 67108864), S < 0 ? this.isubn(-S) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < S ? (this.words[0] = S - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(S), this.negative = 1, this) : this._iaddn(S);
    }, p.prototype._iaddn = function(S) {
      this.words[0] += S;
      for (var E = 0; E < this.length && this.words[E] >= 67108864; E++)
        this.words[E] -= 67108864, E === this.length - 1 ? this.words[E + 1] = 1 : this.words[E + 1]++;
      return this.length = Math.max(this.length, E + 1), this;
    }, p.prototype.isubn = function(S) {
      if (l(typeof S == "number"), l(S < 67108864), S < 0)
        return this.iaddn(-S);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(S), this.negative = 1, this;
      if (this.words[0] -= S, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var E = 0; E < this.length && this.words[E] < 0; E++)
          this.words[E] += 67108864, this.words[E + 1] -= 1;
      return this.strip();
    }, p.prototype.addn = function(S) {
      return this.clone().iaddn(S);
    }, p.prototype.subn = function(S) {
      return this.clone().isubn(S);
    }, p.prototype.iabs = function() {
      return this.negative = 0, this;
    }, p.prototype.abs = function() {
      return this.clone().iabs();
    }, p.prototype._ishlnsubmul = function(S, E, I) {
      var M = S.length + I, $;
      this._expand(M);
      var U, Y = 0;
      for ($ = 0; $ < S.length; $++) {
        U = (this.words[$ + I] | 0) + Y;
        var B = (S.words[$] | 0) * E;
        U -= B & 67108863, Y = (U >> 26) - (B / 67108864 | 0), this.words[$ + I] = U & 67108863;
      }
      for (; $ < this.length - I; $++)
        U = (this.words[$ + I] | 0) + Y, Y = U >> 26, this.words[$ + I] = U & 67108863;
      if (Y === 0)
        return this.strip();
      for (l(Y === -1), Y = 0, $ = 0; $ < this.length; $++)
        U = -(this.words[$] | 0) + Y, Y = U >> 26, this.words[$] = U & 67108863;
      return this.negative = 1, this.strip();
    }, p.prototype._wordDiv = function(S, E) {
      var I = this.length - S.length, M = this.clone(), $ = S, U = $.words[$.length - 1] | 0, Y = this._countBits(U);
      I = 26 - Y, I !== 0 && ($ = $.ushln(I), M.iushln(I), U = $.words[$.length - 1] | 0);
      var B = M.length - $.length, T;
      if (E !== "mod") {
        T = new p(null), T.length = B + 1, T.words = new Array(T.length);
        for (var L = 0; L < T.length; L++)
          T.words[L] = 0;
      }
      var te = M.clone()._ishlnsubmul($, 1, B);
      te.negative === 0 && (M = te, T && (T.words[B] = 1));
      for (var me = B - 1; me >= 0; me--) {
        var Ce = (M.words[$.length + me] | 0) * 67108864 + (M.words[$.length + me - 1] | 0);
        for (Ce = Math.min(Ce / U | 0, 67108863), M._ishlnsubmul($, Ce, me); M.negative !== 0; )
          Ce--, M.negative = 0, M._ishlnsubmul($, 1, me), M.isZero() || (M.negative ^= 1);
        T && (T.words[me] = Ce);
      }
      return T && T.strip(), M.strip(), E !== "div" && I !== 0 && M.iushrn(I), {
        div: T || null,
        mod: M
      };
    }, p.prototype.divmod = function(S, E, I) {
      if (l(!S.isZero()), this.isZero())
        return {
          div: new p(0),
          mod: new p(0)
        };
      var M, $, U;
      return this.negative !== 0 && S.negative === 0 ? (U = this.neg().divmod(S, E), E !== "mod" && (M = U.div.neg()), E !== "div" && ($ = U.mod.neg(), I && $.negative !== 0 && $.iadd(S)), {
        div: M,
        mod: $
      }) : this.negative === 0 && S.negative !== 0 ? (U = this.divmod(S.neg(), E), E !== "mod" && (M = U.div.neg()), {
        div: M,
        mod: U.mod
      }) : this.negative & S.negative ? (U = this.neg().divmod(S.neg(), E), E !== "div" && ($ = U.mod.neg(), I && $.negative !== 0 && $.isub(S)), {
        div: U.div,
        mod: $
      }) : S.length > this.length || this.cmp(S) < 0 ? {
        div: new p(0),
        mod: this
      } : S.length === 1 ? E === "div" ? {
        div: this.divn(S.words[0]),
        mod: null
      } : E === "mod" ? {
        div: null,
        mod: new p(this.modn(S.words[0]))
      } : {
        div: this.divn(S.words[0]),
        mod: new p(this.modn(S.words[0]))
      } : this._wordDiv(S, E);
    }, p.prototype.div = function(S) {
      return this.divmod(S, "div", !1).div;
    }, p.prototype.mod = function(S) {
      return this.divmod(S, "mod", !1).mod;
    }, p.prototype.umod = function(S) {
      return this.divmod(S, "mod", !0).mod;
    }, p.prototype.divRound = function(S) {
      var E = this.divmod(S);
      if (E.mod.isZero())
        return E.div;
      var I = E.div.negative !== 0 ? E.mod.isub(S) : E.mod, M = S.ushrn(1), $ = S.andln(1), U = I.cmp(M);
      return U < 0 || $ === 1 && U === 0 ? E.div : E.div.negative !== 0 ? E.div.isubn(1) : E.div.iaddn(1);
    }, p.prototype.modn = function(S) {
      l(S <= 67108863);
      for (var E = (1 << 26) % S, I = 0, M = this.length - 1; M >= 0; M--)
        I = (E * I + (this.words[M] | 0)) % S;
      return I;
    }, p.prototype.idivn = function(S) {
      l(S <= 67108863);
      for (var E = 0, I = this.length - 1; I >= 0; I--) {
        var M = (this.words[I] | 0) + E * 67108864;
        this.words[I] = M / S | 0, E = M % S;
      }
      return this.strip();
    }, p.prototype.divn = function(S) {
      return this.clone().idivn(S);
    }, p.prototype.egcd = function(S) {
      l(S.negative === 0), l(!S.isZero());
      var E = this, I = S.clone();
      E.negative !== 0 ? E = E.umod(S) : E = E.clone();
      for (var M = new p(1), $ = new p(0), U = new p(0), Y = new p(1), B = 0; E.isEven() && I.isEven(); )
        E.iushrn(1), I.iushrn(1), ++B;
      for (var T = I.clone(), L = E.clone(); !E.isZero(); ) {
        for (var te = 0, me = 1; !(E.words[0] & me) && te < 26; ++te, me <<= 1)
          ;
        if (te > 0)
          for (E.iushrn(te); te-- > 0; )
            (M.isOdd() || $.isOdd()) && (M.iadd(T), $.isub(L)), M.iushrn(1), $.iushrn(1);
        for (var Ce = 0, De = 1; !(I.words[0] & De) && Ce < 26; ++Ce, De <<= 1)
          ;
        if (Ce > 0)
          for (I.iushrn(Ce); Ce-- > 0; )
            (U.isOdd() || Y.isOdd()) && (U.iadd(T), Y.isub(L)), U.iushrn(1), Y.iushrn(1);
        E.cmp(I) >= 0 ? (E.isub(I), M.isub(U), $.isub(Y)) : (I.isub(E), U.isub(M), Y.isub($));
      }
      return {
        a: U,
        b: Y,
        gcd: I.iushln(B)
      };
    }, p.prototype._invmp = function(S) {
      l(S.negative === 0), l(!S.isZero());
      var E = this, I = S.clone();
      E.negative !== 0 ? E = E.umod(S) : E = E.clone();
      for (var M = new p(1), $ = new p(0), U = I.clone(); E.cmpn(1) > 0 && I.cmpn(1) > 0; ) {
        for (var Y = 0, B = 1; !(E.words[0] & B) && Y < 26; ++Y, B <<= 1)
          ;
        if (Y > 0)
          for (E.iushrn(Y); Y-- > 0; )
            M.isOdd() && M.iadd(U), M.iushrn(1);
        for (var T = 0, L = 1; !(I.words[0] & L) && T < 26; ++T, L <<= 1)
          ;
        if (T > 0)
          for (I.iushrn(T); T-- > 0; )
            $.isOdd() && $.iadd(U), $.iushrn(1);
        E.cmp(I) >= 0 ? (E.isub(I), M.isub($)) : (I.isub(E), $.isub(M));
      }
      var te;
      return E.cmpn(1) === 0 ? te = M : te = $, te.cmpn(0) < 0 && te.iadd(S), te;
    }, p.prototype.gcd = function(S) {
      if (this.isZero())
        return S.abs();
      if (S.isZero())
        return this.abs();
      var E = this.clone(), I = S.clone();
      E.negative = 0, I.negative = 0;
      for (var M = 0; E.isEven() && I.isEven(); M++)
        E.iushrn(1), I.iushrn(1);
      do {
        for (; E.isEven(); )
          E.iushrn(1);
        for (; I.isEven(); )
          I.iushrn(1);
        var $ = E.cmp(I);
        if ($ < 0) {
          var U = E;
          E = I, I = U;
        } else if ($ === 0 || I.cmpn(1) === 0)
          break;
        E.isub(I);
      } while (!0);
      return I.iushln(M);
    }, p.prototype.invm = function(S) {
      return this.egcd(S).a.umod(S);
    }, p.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, p.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, p.prototype.andln = function(S) {
      return this.words[0] & S;
    }, p.prototype.bincn = function(S) {
      l(typeof S == "number");
      var E = S % 26, I = (S - E) / 26, M = 1 << E;
      if (this.length <= I)
        return this._expand(I + 1), this.words[I] |= M, this;
      for (var $ = M, U = I; $ !== 0 && U < this.length; U++) {
        var Y = this.words[U] | 0;
        Y += $, $ = Y >>> 26, Y &= 67108863, this.words[U] = Y;
      }
      return $ !== 0 && (this.words[U] = $, this.length++), this;
    }, p.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, p.prototype.cmpn = function(S) {
      var E = S < 0;
      if (this.negative !== 0 && !E)
        return -1;
      if (this.negative === 0 && E)
        return 1;
      this.strip();
      var I;
      if (this.length > 1)
        I = 1;
      else {
        E && (S = -S), l(S <= 67108863, "Number is too big");
        var M = this.words[0] | 0;
        I = M === S ? 0 : M < S ? -1 : 1;
      }
      return this.negative !== 0 ? -I | 0 : I;
    }, p.prototype.cmp = function(S) {
      if (this.negative !== 0 && S.negative === 0)
        return -1;
      if (this.negative === 0 && S.negative !== 0)
        return 1;
      var E = this.ucmp(S);
      return this.negative !== 0 ? -E | 0 : E;
    }, p.prototype.ucmp = function(S) {
      if (this.length > S.length)
        return 1;
      if (this.length < S.length)
        return -1;
      for (var E = 0, I = this.length - 1; I >= 0; I--) {
        var M = this.words[I] | 0, $ = S.words[I] | 0;
        if (M !== $) {
          M < $ ? E = -1 : M > $ && (E = 1);
          break;
        }
      }
      return E;
    }, p.prototype.gtn = function(S) {
      return this.cmpn(S) === 1;
    }, p.prototype.gt = function(S) {
      return this.cmp(S) === 1;
    }, p.prototype.gten = function(S) {
      return this.cmpn(S) >= 0;
    }, p.prototype.gte = function(S) {
      return this.cmp(S) >= 0;
    }, p.prototype.ltn = function(S) {
      return this.cmpn(S) === -1;
    }, p.prototype.lt = function(S) {
      return this.cmp(S) === -1;
    }, p.prototype.lten = function(S) {
      return this.cmpn(S) <= 0;
    }, p.prototype.lte = function(S) {
      return this.cmp(S) <= 0;
    }, p.prototype.eqn = function(S) {
      return this.cmpn(S) === 0;
    }, p.prototype.eq = function(S) {
      return this.cmp(S) === 0;
    }, p.red = function(S) {
      return new q(S);
    }, p.prototype.toRed = function(S) {
      return l(!this.red, "Already a number in reduction context"), l(this.negative === 0, "red works only with positives"), S.convertTo(this)._forceRed(S);
    }, p.prototype.fromRed = function() {
      return l(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, p.prototype._forceRed = function(S) {
      return this.red = S, this;
    }, p.prototype.forceRed = function(S) {
      return l(!this.red, "Already a number in reduction context"), this._forceRed(S);
    }, p.prototype.redAdd = function(S) {
      return l(this.red, "redAdd works only with red numbers"), this.red.add(this, S);
    }, p.prototype.redIAdd = function(S) {
      return l(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, S);
    }, p.prototype.redSub = function(S) {
      return l(this.red, "redSub works only with red numbers"), this.red.sub(this, S);
    }, p.prototype.redISub = function(S) {
      return l(this.red, "redISub works only with red numbers"), this.red.isub(this, S);
    }, p.prototype.redShl = function(S) {
      return l(this.red, "redShl works only with red numbers"), this.red.shl(this, S);
    }, p.prototype.redMul = function(S) {
      return l(this.red, "redMul works only with red numbers"), this.red._verify2(this, S), this.red.mul(this, S);
    }, p.prototype.redIMul = function(S) {
      return l(this.red, "redMul works only with red numbers"), this.red._verify2(this, S), this.red.imul(this, S);
    }, p.prototype.redSqr = function() {
      return l(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, p.prototype.redISqr = function() {
      return l(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, p.prototype.redSqrt = function() {
      return l(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, p.prototype.redInvm = function() {
      return l(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, p.prototype.redNeg = function() {
      return l(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, p.prototype.redPow = function(S) {
      return l(this.red && !S.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, S);
    };
    var ue = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function he(P, S) {
      this.name = P, this.p = new p(S, 16), this.n = this.p.bitLength(), this.k = new p(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    he.prototype._tmp = function() {
      var S = new p(null);
      return S.words = new Array(Math.ceil(this.n / 13)), S;
    }, he.prototype.ireduce = function(S) {
      var E = S, I;
      do
        this.split(E, this.tmp), E = this.imulK(E), E = E.iadd(this.tmp), I = E.bitLength();
      while (I > this.n);
      var M = I < this.n ? -1 : E.ucmp(this.p);
      return M === 0 ? (E.words[0] = 0, E.length = 1) : M > 0 ? E.isub(this.p) : E.strip !== void 0 ? E.strip() : E._strip(), E;
    }, he.prototype.split = function(S, E) {
      S.iushrn(this.n, 0, E);
    }, he.prototype.imulK = function(S) {
      return S.imul(this.k);
    };
    function fe() {
      he.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    v(fe, he), fe.prototype.split = function(S, E) {
      for (var I = 4194303, M = Math.min(S.length, 9), $ = 0; $ < M; $++)
        E.words[$] = S.words[$];
      if (E.length = M, S.length <= 9) {
        S.words[0] = 0, S.length = 1;
        return;
      }
      var U = S.words[9];
      for (E.words[E.length++] = U & I, $ = 10; $ < S.length; $++) {
        var Y = S.words[$] | 0;
        S.words[$ - 10] = (Y & I) << 4 | U >>> 22, U = Y;
      }
      U >>>= 22, S.words[$ - 10] = U, U === 0 && S.length > 10 ? S.length -= 10 : S.length -= 9;
    }, fe.prototype.imulK = function(S) {
      S.words[S.length] = 0, S.words[S.length + 1] = 0, S.length += 2;
      for (var E = 0, I = 0; I < S.length; I++) {
        var M = S.words[I] | 0;
        E += M * 977, S.words[I] = E & 67108863, E = M * 64 + (E / 67108864 | 0);
      }
      return S.words[S.length - 1] === 0 && (S.length--, S.words[S.length - 1] === 0 && S.length--), S;
    };
    function be() {
      he.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    v(be, he);
    function ke() {
      he.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    v(ke, he);
    function Te() {
      he.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    v(Te, he), Te.prototype.imulK = function(S) {
      for (var E = 0, I = 0; I < S.length; I++) {
        var M = (S.words[I] | 0) * 19 + E, $ = M & 67108863;
        M >>>= 26, S.words[I] = $, E = M;
      }
      return E !== 0 && (S.words[S.length++] = E), S;
    }, p._prime = function(S) {
      if (ue[S])
        return ue[S];
      var E;
      if (S === "k256")
        E = new fe();
      else if (S === "p224")
        E = new be();
      else if (S === "p192")
        E = new ke();
      else if (S === "p25519")
        E = new Te();
      else
        throw new Error("Unknown prime " + S);
      return ue[S] = E, E;
    };
    function q(P) {
      if (typeof P == "string") {
        var S = p._prime(P);
        this.m = S.p, this.prime = S;
      } else
        l(P.gtn(1), "modulus must be greater than 1"), this.m = P, this.prime = null;
    }
    q.prototype._verify1 = function(S) {
      l(S.negative === 0, "red works only with positives"), l(S.red, "red works only with red numbers");
    }, q.prototype._verify2 = function(S, E) {
      l((S.negative | E.negative) === 0, "red works only with positives"), l(
        S.red && S.red === E.red,
        "red works only with red numbers"
      );
    }, q.prototype.imod = function(S) {
      return this.prime ? this.prime.ireduce(S)._forceRed(this) : S.umod(this.m)._forceRed(this);
    }, q.prototype.neg = function(S) {
      return S.isZero() ? S.clone() : this.m.sub(S)._forceRed(this);
    }, q.prototype.add = function(S, E) {
      this._verify2(S, E);
      var I = S.add(E);
      return I.cmp(this.m) >= 0 && I.isub(this.m), I._forceRed(this);
    }, q.prototype.iadd = function(S, E) {
      this._verify2(S, E);
      var I = S.iadd(E);
      return I.cmp(this.m) >= 0 && I.isub(this.m), I;
    }, q.prototype.sub = function(S, E) {
      this._verify2(S, E);
      var I = S.sub(E);
      return I.cmpn(0) < 0 && I.iadd(this.m), I._forceRed(this);
    }, q.prototype.isub = function(S, E) {
      this._verify2(S, E);
      var I = S.isub(E);
      return I.cmpn(0) < 0 && I.iadd(this.m), I;
    }, q.prototype.shl = function(S, E) {
      return this._verify1(S), this.imod(S.ushln(E));
    }, q.prototype.imul = function(S, E) {
      return this._verify2(S, E), this.imod(S.imul(E));
    }, q.prototype.mul = function(S, E) {
      return this._verify2(S, E), this.imod(S.mul(E));
    }, q.prototype.isqr = function(S) {
      return this.imul(S, S.clone());
    }, q.prototype.sqr = function(S) {
      return this.mul(S, S);
    }, q.prototype.sqrt = function(S) {
      if (S.isZero())
        return S.clone();
      var E = this.m.andln(3);
      if (l(E % 2 === 1), E === 3) {
        var I = this.m.add(new p(1)).iushrn(2);
        return this.pow(S, I);
      }
      for (var M = this.m.subn(1), $ = 0; !M.isZero() && M.andln(1) === 0; )
        $++, M.iushrn(1);
      l(!M.isZero());
      var U = new p(1).toRed(this), Y = U.redNeg(), B = this.m.subn(1).iushrn(1), T = this.m.bitLength();
      for (T = new p(2 * T * T).toRed(this); this.pow(T, B).cmp(Y) !== 0; )
        T.redIAdd(Y);
      for (var L = this.pow(T, M), te = this.pow(S, M.addn(1).iushrn(1)), me = this.pow(S, M), Ce = $; me.cmp(U) !== 0; ) {
        for (var De = me, ye = 0; De.cmp(U) !== 0; ye++)
          De = De.redSqr();
        l(ye < Ce);
        var pe = this.pow(L, new p(1).iushln(Ce - ye - 1));
        te = te.redMul(pe), L = pe.redSqr(), me = me.redMul(L), Ce = ye;
      }
      return te;
    }, q.prototype.invm = function(S) {
      var E = S._invmp(this.m);
      return E.negative !== 0 ? (E.negative = 0, this.imod(E).redNeg()) : this.imod(E);
    }, q.prototype.pow = function(S, E) {
      if (E.isZero())
        return new p(1).toRed(this);
      if (E.cmpn(1) === 0)
        return S.clone();
      var I = 4, M = new Array(1 << I);
      M[0] = new p(1).toRed(this), M[1] = S;
      for (var $ = 2; $ < M.length; $++)
        M[$] = this.mul(M[$ - 1], S);
      var U = M[0], Y = 0, B = 0, T = E.bitLength() % 26;
      for (T === 0 && (T = 26), $ = E.length - 1; $ >= 0; $--) {
        for (var L = E.words[$], te = T - 1; te >= 0; te--) {
          var me = L >> te & 1;
          if (U !== M[0] && (U = this.sqr(U)), me === 0 && Y === 0) {
            B = 0;
            continue;
          }
          Y <<= 1, Y |= me, B++, !(B !== I && ($ !== 0 || te !== 0)) && (U = this.mul(U, M[Y]), B = 0, Y = 0);
        }
        T = 26;
      }
      return U;
    }, q.prototype.convertTo = function(S) {
      var E = S.umod(this.m);
      return E === S ? E.clone() : E;
    }, q.prototype.convertFrom = function(S) {
      var E = S.clone();
      return E.red = null, E;
    }, p.mont = function(S) {
      return new z(S);
    };
    function z(P) {
      q.call(this, P), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new p(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    v(z, q), z.prototype.convertTo = function(S) {
      return this.imod(S.ushln(this.shift));
    }, z.prototype.convertFrom = function(S) {
      var E = this.imod(S.mul(this.rinv));
      return E.red = null, E;
    }, z.prototype.imul = function(S, E) {
      if (S.isZero() || E.isZero())
        return S.words[0] = 0, S.length = 1, S;
      var I = S.imul(E), M = I.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), $ = I.isub(M).iushrn(this.shift), U = $;
      return $.cmp(this.m) >= 0 ? U = $.isub(this.m) : $.cmpn(0) < 0 && (U = $.iadd(this.m)), U._forceRed(this);
    }, z.prototype.mul = function(S, E) {
      if (S.isZero() || E.isZero())
        return new p(0)._forceRed(this);
      var I = S.mul(E), M = I.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), $ = I.isub(M).iushrn(this.shift), U = $;
      return $.cmp(this.m) >= 0 ? U = $.isub(this.m) : $.cmpn(0) < 0 && (U = $.iadd(this.m)), U._forceRed(this);
    }, z.prototype.invm = function(S) {
      var E = this.imod(S._invmp(this.m).mul(this.r2));
      return E._forceRed(this);
    };
  })(a, commonjsGlobal$1);
})(bn$1);
var bnExports$1 = bn$1.exports, browser$3, hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser)
    return browser$3;
  hasRequiredBrowser = 1;
  var a = requireElliptic(), u = bnExports$1;
  browser$3 = function(_) {
    return new l(_);
  };
  var c = {
    secp256k1: {
      name: "secp256k1",
      byteLength: 32
    },
    secp224r1: {
      name: "p224",
      byteLength: 28
    },
    prime256v1: {
      name: "p256",
      byteLength: 32
    },
    prime192v1: {
      name: "p192",
      byteLength: 24
    },
    ed25519: {
      name: "ed25519",
      byteLength: 32
    },
    secp384r1: {
      name: "p384",
      byteLength: 48
    },
    secp521r1: {
      name: "p521",
      byteLength: 66
    }
  };
  c.p224 = c.secp224r1, c.p256 = c.secp256r1 = c.prime256v1, c.p192 = c.secp192r1 = c.prime192v1, c.p384 = c.secp384r1, c.p521 = c.secp521r1;
  function l(p) {
    this.curveType = c[p], this.curveType || (this.curveType = {
      name: p
    }), this.curve = new a.ec(this.curveType.name), this.keys = void 0;
  }
  l.prototype.generateKeys = function(p, _) {
    return this.keys = this.curve.genKeyPair(), this.getPublicKey(p, _);
  }, l.prototype.computeSecret = function(p, _, k) {
    _ = _ || "utf8", Buffer$O.isBuffer(p) || (p = new Buffer$O(p, _));
    var O = this.curve.keyFromPublic(p).getPublic(), D = O.mul(this.keys.getPrivate()).getX();
    return v(D, k, this.curveType.byteLength);
  }, l.prototype.getPublicKey = function(p, _) {
    var k = this.keys.getPublic(_ === "compressed", !0);
    return _ === "hybrid" && (k[k.length - 1] % 2 ? k[0] = 7 : k[0] = 6), v(k, p);
  }, l.prototype.getPrivateKey = function(p) {
    return v(this.keys.getPrivate(), p);
  }, l.prototype.setPublicKey = function(p, _) {
    return _ = _ || "utf8", Buffer$O.isBuffer(p) || (p = new Buffer$O(p, _)), this.keys._importPublic(p), this;
  }, l.prototype.setPrivateKey = function(p, _) {
    _ = _ || "utf8", Buffer$O.isBuffer(p) || (p = new Buffer$O(p, _));
    var k = new u(p);
    return k = k.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(k), this;
  };
  function v(p, _, k) {
    Array.isArray(p) || (p = p.toArray());
    var O = new Buffer$O(p);
    if (k && O.length < k) {
      var D = new Buffer$O(k - O.length);
      D.fill(0), O = Buffer$O.concat([D, O]);
    }
    return _ ? O.toString(_) : O;
  }
  return browser$3;
}
var browser$2 = {}, createHash$2 = browser$a, Buffer$9 = safeBufferExports$3.Buffer, mgf$2 = function(a, u) {
  for (var c = Buffer$9.alloc(0), l = 0, v; c.length < u; )
    v = i2ops(l++), c = Buffer$9.concat([c, createHash$2("sha1").update(a).update(v).digest()]);
  return c.slice(0, u);
};
function i2ops(a) {
  var u = Buffer$9.allocUnsafe(4);
  return u.writeUInt32BE(a, 0), u;
}
var xor$2 = function a(u, c) {
  for (var l = u.length, v = -1; ++v < l; )
    u[v] ^= c[v];
  return u;
}, bn = { exports: {} };
bn.exports;
(function(a) {
  (function(u, c) {
    function l(P, S) {
      if (!P)
        throw new Error(S || "Assertion failed");
    }
    function v(P, S) {
      P.super_ = S;
      var E = function() {
      };
      E.prototype = S.prototype, P.prototype = new E(), P.prototype.constructor = P;
    }
    function p(P, S, E) {
      if (p.isBN(P))
        return P;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, P !== null && ((S === "le" || S === "be") && (E = S, S = 10), this._init(P || 0, S || 10, E || "be"));
    }
    typeof u == "object" ? u.exports = p : c.BN = p, p.BN = p, p.wordSize = 26;
    var _;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? _ = window.Buffer : _ = require$$0$2.Buffer;
    } catch {
    }
    p.isBN = function(S) {
      return S instanceof p ? !0 : S !== null && typeof S == "object" && S.constructor.wordSize === p.wordSize && Array.isArray(S.words);
    }, p.max = function(S, E) {
      return S.cmp(E) > 0 ? S : E;
    }, p.min = function(S, E) {
      return S.cmp(E) < 0 ? S : E;
    }, p.prototype._init = function(S, E, I) {
      if (typeof S == "number")
        return this._initNumber(S, E, I);
      if (typeof S == "object")
        return this._initArray(S, E, I);
      E === "hex" && (E = 16), l(E === (E | 0) && E >= 2 && E <= 36), S = S.toString().replace(/\s+/g, "");
      var M = 0;
      S[0] === "-" && (M++, this.negative = 1), M < S.length && (E === 16 ? this._parseHex(S, M, I) : (this._parseBase(S, E, M), I === "le" && this._initArray(this.toArray(), E, I)));
    }, p.prototype._initNumber = function(S, E, I) {
      S < 0 && (this.negative = 1, S = -S), S < 67108864 ? (this.words = [S & 67108863], this.length = 1) : S < 4503599627370496 ? (this.words = [
        S & 67108863,
        S / 67108864 & 67108863
      ], this.length = 2) : (l(S < 9007199254740992), this.words = [
        S & 67108863,
        S / 67108864 & 67108863,
        1
      ], this.length = 3), I === "le" && this._initArray(this.toArray(), E, I);
    }, p.prototype._initArray = function(S, E, I) {
      if (l(typeof S.length == "number"), S.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(S.length / 3), this.words = new Array(this.length);
      for (var M = 0; M < this.length; M++)
        this.words[M] = 0;
      var $, U, Y = 0;
      if (I === "be")
        for (M = S.length - 1, $ = 0; M >= 0; M -= 3)
          U = S[M] | S[M - 1] << 8 | S[M - 2] << 16, this.words[$] |= U << Y & 67108863, this.words[$ + 1] = U >>> 26 - Y & 67108863, Y += 24, Y >= 26 && (Y -= 26, $++);
      else if (I === "le")
        for (M = 0, $ = 0; M < S.length; M += 3)
          U = S[M] | S[M + 1] << 8 | S[M + 2] << 16, this.words[$] |= U << Y & 67108863, this.words[$ + 1] = U >>> 26 - Y & 67108863, Y += 24, Y >= 26 && (Y -= 26, $++);
      return this.strip();
    };
    function k(P, S) {
      var E = P.charCodeAt(S);
      return E >= 65 && E <= 70 ? E - 55 : E >= 97 && E <= 102 ? E - 87 : E - 48 & 15;
    }
    function O(P, S, E) {
      var I = k(P, E);
      return E - 1 >= S && (I |= k(P, E - 1) << 4), I;
    }
    p.prototype._parseHex = function(S, E, I) {
      this.length = Math.ceil((S.length - E) / 6), this.words = new Array(this.length);
      for (var M = 0; M < this.length; M++)
        this.words[M] = 0;
      var $ = 0, U = 0, Y;
      if (I === "be")
        for (M = S.length - 1; M >= E; M -= 2)
          Y = O(S, E, M) << $, this.words[U] |= Y & 67108863, $ >= 18 ? ($ -= 18, U += 1, this.words[U] |= Y >>> 26) : $ += 8;
      else {
        var B = S.length - E;
        for (M = B % 2 === 0 ? E + 1 : E; M < S.length; M += 2)
          Y = O(S, E, M) << $, this.words[U] |= Y & 67108863, $ >= 18 ? ($ -= 18, U += 1, this.words[U] |= Y >>> 26) : $ += 8;
      }
      this.strip();
    };
    function D(P, S, E, I) {
      for (var M = 0, $ = Math.min(P.length, E), U = S; U < $; U++) {
        var Y = P.charCodeAt(U) - 48;
        M *= I, Y >= 49 ? M += Y - 49 + 10 : Y >= 17 ? M += Y - 17 + 10 : M += Y;
      }
      return M;
    }
    p.prototype._parseBase = function(S, E, I) {
      this.words = [0], this.length = 1;
      for (var M = 0, $ = 1; $ <= 67108863; $ *= E)
        M++;
      M--, $ = $ / E | 0;
      for (var U = S.length - I, Y = U % M, B = Math.min(U, U - Y) + I, T = 0, L = I; L < B; L += M)
        T = D(S, L, L + M, E), this.imuln($), this.words[0] + T < 67108864 ? this.words[0] += T : this._iaddn(T);
      if (Y !== 0) {
        var te = 1;
        for (T = D(S, L, S.length, E), L = 0; L < Y; L++)
          te *= E;
        this.imuln(te), this.words[0] + T < 67108864 ? this.words[0] += T : this._iaddn(T);
      }
      this.strip();
    }, p.prototype.copy = function(S) {
      S.words = new Array(this.length);
      for (var E = 0; E < this.length; E++)
        S.words[E] = this.words[E];
      S.length = this.length, S.negative = this.negative, S.red = this.red;
    }, p.prototype.clone = function() {
      var S = new p(null);
      return this.copy(S), S;
    }, p.prototype._expand = function(S) {
      for (; this.length < S; )
        this.words[this.length++] = 0;
      return this;
    }, p.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, p.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, p.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var F = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], H = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], Z = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    p.prototype.toString = function(S, E) {
      S = S || 10, E = E | 0 || 1;
      var I;
      if (S === 16 || S === "hex") {
        I = "";
        for (var M = 0, $ = 0, U = 0; U < this.length; U++) {
          var Y = this.words[U], B = ((Y << M | $) & 16777215).toString(16);
          $ = Y >>> 24 - M & 16777215, $ !== 0 || U !== this.length - 1 ? I = F[6 - B.length] + B + I : I = B + I, M += 2, M >= 26 && (M -= 26, U--);
        }
        for ($ !== 0 && (I = $.toString(16) + I); I.length % E !== 0; )
          I = "0" + I;
        return this.negative !== 0 && (I = "-" + I), I;
      }
      if (S === (S | 0) && S >= 2 && S <= 36) {
        var T = H[S], L = Z[S];
        I = "";
        var te = this.clone();
        for (te.negative = 0; !te.isZero(); ) {
          var me = te.modn(L).toString(S);
          te = te.idivn(L), te.isZero() ? I = me + I : I = F[T - me.length] + me + I;
        }
        for (this.isZero() && (I = "0" + I); I.length % E !== 0; )
          I = "0" + I;
        return this.negative !== 0 && (I = "-" + I), I;
      }
      l(!1, "Base should be between 2 and 36");
    }, p.prototype.toNumber = function() {
      var S = this.words[0];
      return this.length === 2 ? S += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? S += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && l(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -S : S;
    }, p.prototype.toJSON = function() {
      return this.toString(16);
    }, p.prototype.toBuffer = function(S, E) {
      return l(typeof _ < "u"), this.toArrayLike(_, S, E);
    }, p.prototype.toArray = function(S, E) {
      return this.toArrayLike(Array, S, E);
    }, p.prototype.toArrayLike = function(S, E, I) {
      var M = this.byteLength(), $ = I || Math.max(1, M);
      l(M <= $, "byte array longer than desired length"), l($ > 0, "Requested array length <= 0"), this.strip();
      var U = E === "le", Y = new S($), B, T, L = this.clone();
      if (U) {
        for (T = 0; !L.isZero(); T++)
          B = L.andln(255), L.iushrn(8), Y[T] = B;
        for (; T < $; T++)
          Y[T] = 0;
      } else {
        for (T = 0; T < $ - M; T++)
          Y[T] = 0;
        for (T = 0; !L.isZero(); T++)
          B = L.andln(255), L.iushrn(8), Y[$ - T - 1] = B;
      }
      return Y;
    }, Math.clz32 ? p.prototype._countBits = function(S) {
      return 32 - Math.clz32(S);
    } : p.prototype._countBits = function(S) {
      var E = S, I = 0;
      return E >= 4096 && (I += 13, E >>>= 13), E >= 64 && (I += 7, E >>>= 7), E >= 8 && (I += 4, E >>>= 4), E >= 2 && (I += 2, E >>>= 2), I + E;
    }, p.prototype._zeroBits = function(S) {
      if (S === 0)
        return 26;
      var E = S, I = 0;
      return E & 8191 || (I += 13, E >>>= 13), E & 127 || (I += 7, E >>>= 7), E & 15 || (I += 4, E >>>= 4), E & 3 || (I += 2, E >>>= 2), E & 1 || I++, I;
    }, p.prototype.bitLength = function() {
      var S = this.words[this.length - 1], E = this._countBits(S);
      return (this.length - 1) * 26 + E;
    };
    function ee(P) {
      for (var S = new Array(P.bitLength()), E = 0; E < S.length; E++) {
        var I = E / 26 | 0, M = E % 26;
        S[E] = (P.words[I] & 1 << M) >>> M;
      }
      return S;
    }
    p.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var S = 0, E = 0; E < this.length; E++) {
        var I = this._zeroBits(this.words[E]);
        if (S += I, I !== 26)
          break;
      }
      return S;
    }, p.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, p.prototype.toTwos = function(S) {
      return this.negative !== 0 ? this.abs().inotn(S).iaddn(1) : this.clone();
    }, p.prototype.fromTwos = function(S) {
      return this.testn(S - 1) ? this.notn(S).iaddn(1).ineg() : this.clone();
    }, p.prototype.isNeg = function() {
      return this.negative !== 0;
    }, p.prototype.neg = function() {
      return this.clone().ineg();
    }, p.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, p.prototype.iuor = function(S) {
      for (; this.length < S.length; )
        this.words[this.length++] = 0;
      for (var E = 0; E < S.length; E++)
        this.words[E] = this.words[E] | S.words[E];
      return this.strip();
    }, p.prototype.ior = function(S) {
      return l((this.negative | S.negative) === 0), this.iuor(S);
    }, p.prototype.or = function(S) {
      return this.length > S.length ? this.clone().ior(S) : S.clone().ior(this);
    }, p.prototype.uor = function(S) {
      return this.length > S.length ? this.clone().iuor(S) : S.clone().iuor(this);
    }, p.prototype.iuand = function(S) {
      var E;
      this.length > S.length ? E = S : E = this;
      for (var I = 0; I < E.length; I++)
        this.words[I] = this.words[I] & S.words[I];
      return this.length = E.length, this.strip();
    }, p.prototype.iand = function(S) {
      return l((this.negative | S.negative) === 0), this.iuand(S);
    }, p.prototype.and = function(S) {
      return this.length > S.length ? this.clone().iand(S) : S.clone().iand(this);
    }, p.prototype.uand = function(S) {
      return this.length > S.length ? this.clone().iuand(S) : S.clone().iuand(this);
    }, p.prototype.iuxor = function(S) {
      var E, I;
      this.length > S.length ? (E = this, I = S) : (E = S, I = this);
      for (var M = 0; M < I.length; M++)
        this.words[M] = E.words[M] ^ I.words[M];
      if (this !== E)
        for (; M < E.length; M++)
          this.words[M] = E.words[M];
      return this.length = E.length, this.strip();
    }, p.prototype.ixor = function(S) {
      return l((this.negative | S.negative) === 0), this.iuxor(S);
    }, p.prototype.xor = function(S) {
      return this.length > S.length ? this.clone().ixor(S) : S.clone().ixor(this);
    }, p.prototype.uxor = function(S) {
      return this.length > S.length ? this.clone().iuxor(S) : S.clone().iuxor(this);
    }, p.prototype.inotn = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = Math.ceil(S / 26) | 0, I = S % 26;
      this._expand(E), I > 0 && E--;
      for (var M = 0; M < E; M++)
        this.words[M] = ~this.words[M] & 67108863;
      return I > 0 && (this.words[M] = ~this.words[M] & 67108863 >> 26 - I), this.strip();
    }, p.prototype.notn = function(S) {
      return this.clone().inotn(S);
    }, p.prototype.setn = function(S, E) {
      l(typeof S == "number" && S >= 0);
      var I = S / 26 | 0, M = S % 26;
      return this._expand(I + 1), E ? this.words[I] = this.words[I] | 1 << M : this.words[I] = this.words[I] & ~(1 << M), this.strip();
    }, p.prototype.iadd = function(S) {
      var E;
      if (this.negative !== 0 && S.negative === 0)
        return this.negative = 0, E = this.isub(S), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && S.negative !== 0)
        return S.negative = 0, E = this.isub(S), S.negative = 1, E._normSign();
      var I, M;
      this.length > S.length ? (I = this, M = S) : (I = S, M = this);
      for (var $ = 0, U = 0; U < M.length; U++)
        E = (I.words[U] | 0) + (M.words[U] | 0) + $, this.words[U] = E & 67108863, $ = E >>> 26;
      for (; $ !== 0 && U < I.length; U++)
        E = (I.words[U] | 0) + $, this.words[U] = E & 67108863, $ = E >>> 26;
      if (this.length = I.length, $ !== 0)
        this.words[this.length] = $, this.length++;
      else if (I !== this)
        for (; U < I.length; U++)
          this.words[U] = I.words[U];
      return this;
    }, p.prototype.add = function(S) {
      var E;
      return S.negative !== 0 && this.negative === 0 ? (S.negative = 0, E = this.sub(S), S.negative ^= 1, E) : S.negative === 0 && this.negative !== 0 ? (this.negative = 0, E = S.sub(this), this.negative = 1, E) : this.length > S.length ? this.clone().iadd(S) : S.clone().iadd(this);
    }, p.prototype.isub = function(S) {
      if (S.negative !== 0) {
        S.negative = 0;
        var E = this.iadd(S);
        return S.negative = 1, E._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(S), this.negative = 1, this._normSign();
      var I = this.cmp(S);
      if (I === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var M, $;
      I > 0 ? (M = this, $ = S) : (M = S, $ = this);
      for (var U = 0, Y = 0; Y < $.length; Y++)
        E = (M.words[Y] | 0) - ($.words[Y] | 0) + U, U = E >> 26, this.words[Y] = E & 67108863;
      for (; U !== 0 && Y < M.length; Y++)
        E = (M.words[Y] | 0) + U, U = E >> 26, this.words[Y] = E & 67108863;
      if (U === 0 && Y < M.length && M !== this)
        for (; Y < M.length; Y++)
          this.words[Y] = M.words[Y];
      return this.length = Math.max(this.length, Y), M !== this && (this.negative = 1), this.strip();
    }, p.prototype.sub = function(S) {
      return this.clone().isub(S);
    };
    function X(P, S, E) {
      E.negative = S.negative ^ P.negative;
      var I = P.length + S.length | 0;
      E.length = I, I = I - 1 | 0;
      var M = P.words[0] | 0, $ = S.words[0] | 0, U = M * $, Y = U & 67108863, B = U / 67108864 | 0;
      E.words[0] = Y;
      for (var T = 1; T < I; T++) {
        for (var L = B >>> 26, te = B & 67108863, me = Math.min(T, S.length - 1), Ce = Math.max(0, T - P.length + 1); Ce <= me; Ce++) {
          var De = T - Ce | 0;
          M = P.words[De] | 0, $ = S.words[Ce] | 0, U = M * $ + te, L += U / 67108864 | 0, te = U & 67108863;
        }
        E.words[T] = te | 0, B = L | 0;
      }
      return B !== 0 ? E.words[T] = B | 0 : E.length--, E.strip();
    }
    var ne = function(S, E, I) {
      var M = S.words, $ = E.words, U = I.words, Y = 0, B, T, L, te = M[0] | 0, me = te & 8191, Ce = te >>> 13, De = M[1] | 0, ye = De & 8191, pe = De >>> 13, Me = M[2] | 0, Ne = Me & 8191, Ue = Me >>> 13, oe = M[3] | 0, A = oe & 8191, re = oe >>> 13, le = M[4] | 0, $e = le & 8191, Oe = le >>> 13, Fe = M[5] | 0, Ze = Fe & 8191, qe = Fe >>> 13, yt = M[6] | 0, Xe = yt & 8191, Ge = yt >>> 13, J = M[7] | 0, ge = J & 8191, we = J >>> 13, We = M[8] | 0, Ie = We & 8191, V = We >>> 13, Ee = M[9] | 0, de = Ee & 8191, ce = Ee >>> 13, ve = $[0] | 0, Pe = ve & 8191, Be = ve >>> 13, ze = $[1] | 0, Je = ze & 8191, je = ze >>> 13, Ke = $[2] | 0, x = Ke & 8191, se = Ke >>> 13, Se = $[3] | 0, xe = Se & 8191, Ae = Se >>> 13, Ye = $[4] | 0, et = Ye & 8191, dt = Ye >>> 13, St = $[5] | 0, tt = St & 8191, at = St >>> 13, kt = $[6] | 0, rt = kt & 8191, ut = kt >>> 13, wt = $[7] | 0, nt = wt & 8191, it = wt >>> 13, bt = $[8] | 0, ot = bt & 8191, ct = bt >>> 13, Pt = $[9] | 0, st = Pt & 8191, lt = Pt >>> 13;
      I.negative = S.negative ^ E.negative, I.length = 19, B = Math.imul(me, Pe), T = Math.imul(me, Be), T = T + Math.imul(Ce, Pe) | 0, L = Math.imul(Ce, Be);
      var It = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (It >>> 26) | 0, It &= 67108863, B = Math.imul(ye, Pe), T = Math.imul(ye, Be), T = T + Math.imul(pe, Pe) | 0, L = Math.imul(pe, Be), B = B + Math.imul(me, Je) | 0, T = T + Math.imul(me, je) | 0, T = T + Math.imul(Ce, Je) | 0, L = L + Math.imul(Ce, je) | 0;
      var Rt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (Rt >>> 26) | 0, Rt &= 67108863, B = Math.imul(Ne, Pe), T = Math.imul(Ne, Be), T = T + Math.imul(Ue, Pe) | 0, L = Math.imul(Ue, Be), B = B + Math.imul(ye, Je) | 0, T = T + Math.imul(ye, je) | 0, T = T + Math.imul(pe, Je) | 0, L = L + Math.imul(pe, je) | 0, B = B + Math.imul(me, x) | 0, T = T + Math.imul(me, se) | 0, T = T + Math.imul(Ce, x) | 0, L = L + Math.imul(Ce, se) | 0;
      var Ve = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, B = Math.imul(A, Pe), T = Math.imul(A, Be), T = T + Math.imul(re, Pe) | 0, L = Math.imul(re, Be), B = B + Math.imul(Ne, Je) | 0, T = T + Math.imul(Ne, je) | 0, T = T + Math.imul(Ue, Je) | 0, L = L + Math.imul(Ue, je) | 0, B = B + Math.imul(ye, x) | 0, T = T + Math.imul(ye, se) | 0, T = T + Math.imul(pe, x) | 0, L = L + Math.imul(pe, se) | 0, B = B + Math.imul(me, xe) | 0, T = T + Math.imul(me, Ae) | 0, T = T + Math.imul(Ce, xe) | 0, L = L + Math.imul(Ce, Ae) | 0;
      var He = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, B = Math.imul($e, Pe), T = Math.imul($e, Be), T = T + Math.imul(Oe, Pe) | 0, L = Math.imul(Oe, Be), B = B + Math.imul(A, Je) | 0, T = T + Math.imul(A, je) | 0, T = T + Math.imul(re, Je) | 0, L = L + Math.imul(re, je) | 0, B = B + Math.imul(Ne, x) | 0, T = T + Math.imul(Ne, se) | 0, T = T + Math.imul(Ue, x) | 0, L = L + Math.imul(Ue, se) | 0, B = B + Math.imul(ye, xe) | 0, T = T + Math.imul(ye, Ae) | 0, T = T + Math.imul(pe, xe) | 0, L = L + Math.imul(pe, Ae) | 0, B = B + Math.imul(me, et) | 0, T = T + Math.imul(me, dt) | 0, T = T + Math.imul(Ce, et) | 0, L = L + Math.imul(Ce, dt) | 0;
      var Qe = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, B = Math.imul(Ze, Pe), T = Math.imul(Ze, Be), T = T + Math.imul(qe, Pe) | 0, L = Math.imul(qe, Be), B = B + Math.imul($e, Je) | 0, T = T + Math.imul($e, je) | 0, T = T + Math.imul(Oe, Je) | 0, L = L + Math.imul(Oe, je) | 0, B = B + Math.imul(A, x) | 0, T = T + Math.imul(A, se) | 0, T = T + Math.imul(re, x) | 0, L = L + Math.imul(re, se) | 0, B = B + Math.imul(Ne, xe) | 0, T = T + Math.imul(Ne, Ae) | 0, T = T + Math.imul(Ue, xe) | 0, L = L + Math.imul(Ue, Ae) | 0, B = B + Math.imul(ye, et) | 0, T = T + Math.imul(ye, dt) | 0, T = T + Math.imul(pe, et) | 0, L = L + Math.imul(pe, dt) | 0, B = B + Math.imul(me, tt) | 0, T = T + Math.imul(me, at) | 0, T = T + Math.imul(Ce, tt) | 0, L = L + Math.imul(Ce, at) | 0;
      var pt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (pt >>> 26) | 0, pt &= 67108863, B = Math.imul(Xe, Pe), T = Math.imul(Xe, Be), T = T + Math.imul(Ge, Pe) | 0, L = Math.imul(Ge, Be), B = B + Math.imul(Ze, Je) | 0, T = T + Math.imul(Ze, je) | 0, T = T + Math.imul(qe, Je) | 0, L = L + Math.imul(qe, je) | 0, B = B + Math.imul($e, x) | 0, T = T + Math.imul($e, se) | 0, T = T + Math.imul(Oe, x) | 0, L = L + Math.imul(Oe, se) | 0, B = B + Math.imul(A, xe) | 0, T = T + Math.imul(A, Ae) | 0, T = T + Math.imul(re, xe) | 0, L = L + Math.imul(re, Ae) | 0, B = B + Math.imul(Ne, et) | 0, T = T + Math.imul(Ne, dt) | 0, T = T + Math.imul(Ue, et) | 0, L = L + Math.imul(Ue, dt) | 0, B = B + Math.imul(ye, tt) | 0, T = T + Math.imul(ye, at) | 0, T = T + Math.imul(pe, tt) | 0, L = L + Math.imul(pe, at) | 0, B = B + Math.imul(me, rt) | 0, T = T + Math.imul(me, ut) | 0, T = T + Math.imul(Ce, rt) | 0, L = L + Math.imul(Ce, ut) | 0;
      var mt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (mt >>> 26) | 0, mt &= 67108863, B = Math.imul(ge, Pe), T = Math.imul(ge, Be), T = T + Math.imul(we, Pe) | 0, L = Math.imul(we, Be), B = B + Math.imul(Xe, Je) | 0, T = T + Math.imul(Xe, je) | 0, T = T + Math.imul(Ge, Je) | 0, L = L + Math.imul(Ge, je) | 0, B = B + Math.imul(Ze, x) | 0, T = T + Math.imul(Ze, se) | 0, T = T + Math.imul(qe, x) | 0, L = L + Math.imul(qe, se) | 0, B = B + Math.imul($e, xe) | 0, T = T + Math.imul($e, Ae) | 0, T = T + Math.imul(Oe, xe) | 0, L = L + Math.imul(Oe, Ae) | 0, B = B + Math.imul(A, et) | 0, T = T + Math.imul(A, dt) | 0, T = T + Math.imul(re, et) | 0, L = L + Math.imul(re, dt) | 0, B = B + Math.imul(Ne, tt) | 0, T = T + Math.imul(Ne, at) | 0, T = T + Math.imul(Ue, tt) | 0, L = L + Math.imul(Ue, at) | 0, B = B + Math.imul(ye, rt) | 0, T = T + Math.imul(ye, ut) | 0, T = T + Math.imul(pe, rt) | 0, L = L + Math.imul(pe, ut) | 0, B = B + Math.imul(me, nt) | 0, T = T + Math.imul(me, it) | 0, T = T + Math.imul(Ce, nt) | 0, L = L + Math.imul(Ce, it) | 0;
      var vt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, B = Math.imul(Ie, Pe), T = Math.imul(Ie, Be), T = T + Math.imul(V, Pe) | 0, L = Math.imul(V, Be), B = B + Math.imul(ge, Je) | 0, T = T + Math.imul(ge, je) | 0, T = T + Math.imul(we, Je) | 0, L = L + Math.imul(we, je) | 0, B = B + Math.imul(Xe, x) | 0, T = T + Math.imul(Xe, se) | 0, T = T + Math.imul(Ge, x) | 0, L = L + Math.imul(Ge, se) | 0, B = B + Math.imul(Ze, xe) | 0, T = T + Math.imul(Ze, Ae) | 0, T = T + Math.imul(qe, xe) | 0, L = L + Math.imul(qe, Ae) | 0, B = B + Math.imul($e, et) | 0, T = T + Math.imul($e, dt) | 0, T = T + Math.imul(Oe, et) | 0, L = L + Math.imul(Oe, dt) | 0, B = B + Math.imul(A, tt) | 0, T = T + Math.imul(A, at) | 0, T = T + Math.imul(re, tt) | 0, L = L + Math.imul(re, at) | 0, B = B + Math.imul(Ne, rt) | 0, T = T + Math.imul(Ne, ut) | 0, T = T + Math.imul(Ue, rt) | 0, L = L + Math.imul(Ue, ut) | 0, B = B + Math.imul(ye, nt) | 0, T = T + Math.imul(ye, it) | 0, T = T + Math.imul(pe, nt) | 0, L = L + Math.imul(pe, it) | 0, B = B + Math.imul(me, ot) | 0, T = T + Math.imul(me, ct) | 0, T = T + Math.imul(Ce, ot) | 0, L = L + Math.imul(Ce, ct) | 0;
      var ht = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (ht >>> 26) | 0, ht &= 67108863, B = Math.imul(de, Pe), T = Math.imul(de, Be), T = T + Math.imul(ce, Pe) | 0, L = Math.imul(ce, Be), B = B + Math.imul(Ie, Je) | 0, T = T + Math.imul(Ie, je) | 0, T = T + Math.imul(V, Je) | 0, L = L + Math.imul(V, je) | 0, B = B + Math.imul(ge, x) | 0, T = T + Math.imul(ge, se) | 0, T = T + Math.imul(we, x) | 0, L = L + Math.imul(we, se) | 0, B = B + Math.imul(Xe, xe) | 0, T = T + Math.imul(Xe, Ae) | 0, T = T + Math.imul(Ge, xe) | 0, L = L + Math.imul(Ge, Ae) | 0, B = B + Math.imul(Ze, et) | 0, T = T + Math.imul(Ze, dt) | 0, T = T + Math.imul(qe, et) | 0, L = L + Math.imul(qe, dt) | 0, B = B + Math.imul($e, tt) | 0, T = T + Math.imul($e, at) | 0, T = T + Math.imul(Oe, tt) | 0, L = L + Math.imul(Oe, at) | 0, B = B + Math.imul(A, rt) | 0, T = T + Math.imul(A, ut) | 0, T = T + Math.imul(re, rt) | 0, L = L + Math.imul(re, ut) | 0, B = B + Math.imul(Ne, nt) | 0, T = T + Math.imul(Ne, it) | 0, T = T + Math.imul(Ue, nt) | 0, L = L + Math.imul(Ue, it) | 0, B = B + Math.imul(ye, ot) | 0, T = T + Math.imul(ye, ct) | 0, T = T + Math.imul(pe, ot) | 0, L = L + Math.imul(pe, ct) | 0, B = B + Math.imul(me, st) | 0, T = T + Math.imul(me, lt) | 0, T = T + Math.imul(Ce, st) | 0, L = L + Math.imul(Ce, lt) | 0;
      var Et = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, B = Math.imul(de, Je), T = Math.imul(de, je), T = T + Math.imul(ce, Je) | 0, L = Math.imul(ce, je), B = B + Math.imul(Ie, x) | 0, T = T + Math.imul(Ie, se) | 0, T = T + Math.imul(V, x) | 0, L = L + Math.imul(V, se) | 0, B = B + Math.imul(ge, xe) | 0, T = T + Math.imul(ge, Ae) | 0, T = T + Math.imul(we, xe) | 0, L = L + Math.imul(we, Ae) | 0, B = B + Math.imul(Xe, et) | 0, T = T + Math.imul(Xe, dt) | 0, T = T + Math.imul(Ge, et) | 0, L = L + Math.imul(Ge, dt) | 0, B = B + Math.imul(Ze, tt) | 0, T = T + Math.imul(Ze, at) | 0, T = T + Math.imul(qe, tt) | 0, L = L + Math.imul(qe, at) | 0, B = B + Math.imul($e, rt) | 0, T = T + Math.imul($e, ut) | 0, T = T + Math.imul(Oe, rt) | 0, L = L + Math.imul(Oe, ut) | 0, B = B + Math.imul(A, nt) | 0, T = T + Math.imul(A, it) | 0, T = T + Math.imul(re, nt) | 0, L = L + Math.imul(re, it) | 0, B = B + Math.imul(Ne, ot) | 0, T = T + Math.imul(Ne, ct) | 0, T = T + Math.imul(Ue, ot) | 0, L = L + Math.imul(Ue, ct) | 0, B = B + Math.imul(ye, st) | 0, T = T + Math.imul(ye, lt) | 0, T = T + Math.imul(pe, st) | 0, L = L + Math.imul(pe, lt) | 0;
      var Tt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (Tt >>> 26) | 0, Tt &= 67108863, B = Math.imul(de, x), T = Math.imul(de, se), T = T + Math.imul(ce, x) | 0, L = Math.imul(ce, se), B = B + Math.imul(Ie, xe) | 0, T = T + Math.imul(Ie, Ae) | 0, T = T + Math.imul(V, xe) | 0, L = L + Math.imul(V, Ae) | 0, B = B + Math.imul(ge, et) | 0, T = T + Math.imul(ge, dt) | 0, T = T + Math.imul(we, et) | 0, L = L + Math.imul(we, dt) | 0, B = B + Math.imul(Xe, tt) | 0, T = T + Math.imul(Xe, at) | 0, T = T + Math.imul(Ge, tt) | 0, L = L + Math.imul(Ge, at) | 0, B = B + Math.imul(Ze, rt) | 0, T = T + Math.imul(Ze, ut) | 0, T = T + Math.imul(qe, rt) | 0, L = L + Math.imul(qe, ut) | 0, B = B + Math.imul($e, nt) | 0, T = T + Math.imul($e, it) | 0, T = T + Math.imul(Oe, nt) | 0, L = L + Math.imul(Oe, it) | 0, B = B + Math.imul(A, ot) | 0, T = T + Math.imul(A, ct) | 0, T = T + Math.imul(re, ot) | 0, L = L + Math.imul(re, ct) | 0, B = B + Math.imul(Ne, st) | 0, T = T + Math.imul(Ne, lt) | 0, T = T + Math.imul(Ue, st) | 0, L = L + Math.imul(Ue, lt) | 0;
      var Ot = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (Ot >>> 26) | 0, Ot &= 67108863, B = Math.imul(de, xe), T = Math.imul(de, Ae), T = T + Math.imul(ce, xe) | 0, L = Math.imul(ce, Ae), B = B + Math.imul(Ie, et) | 0, T = T + Math.imul(Ie, dt) | 0, T = T + Math.imul(V, et) | 0, L = L + Math.imul(V, dt) | 0, B = B + Math.imul(ge, tt) | 0, T = T + Math.imul(ge, at) | 0, T = T + Math.imul(we, tt) | 0, L = L + Math.imul(we, at) | 0, B = B + Math.imul(Xe, rt) | 0, T = T + Math.imul(Xe, ut) | 0, T = T + Math.imul(Ge, rt) | 0, L = L + Math.imul(Ge, ut) | 0, B = B + Math.imul(Ze, nt) | 0, T = T + Math.imul(Ze, it) | 0, T = T + Math.imul(qe, nt) | 0, L = L + Math.imul(qe, it) | 0, B = B + Math.imul($e, ot) | 0, T = T + Math.imul($e, ct) | 0, T = T + Math.imul(Oe, ot) | 0, L = L + Math.imul(Oe, ct) | 0, B = B + Math.imul(A, st) | 0, T = T + Math.imul(A, lt) | 0, T = T + Math.imul(re, st) | 0, L = L + Math.imul(re, lt) | 0;
      var Nt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, B = Math.imul(de, et), T = Math.imul(de, dt), T = T + Math.imul(ce, et) | 0, L = Math.imul(ce, dt), B = B + Math.imul(Ie, tt) | 0, T = T + Math.imul(Ie, at) | 0, T = T + Math.imul(V, tt) | 0, L = L + Math.imul(V, at) | 0, B = B + Math.imul(ge, rt) | 0, T = T + Math.imul(ge, ut) | 0, T = T + Math.imul(we, rt) | 0, L = L + Math.imul(we, ut) | 0, B = B + Math.imul(Xe, nt) | 0, T = T + Math.imul(Xe, it) | 0, T = T + Math.imul(Ge, nt) | 0, L = L + Math.imul(Ge, it) | 0, B = B + Math.imul(Ze, ot) | 0, T = T + Math.imul(Ze, ct) | 0, T = T + Math.imul(qe, ot) | 0, L = L + Math.imul(qe, ct) | 0, B = B + Math.imul($e, st) | 0, T = T + Math.imul($e, lt) | 0, T = T + Math.imul(Oe, st) | 0, L = L + Math.imul(Oe, lt) | 0;
      var At = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, B = Math.imul(de, tt), T = Math.imul(de, at), T = T + Math.imul(ce, tt) | 0, L = Math.imul(ce, at), B = B + Math.imul(Ie, rt) | 0, T = T + Math.imul(Ie, ut) | 0, T = T + Math.imul(V, rt) | 0, L = L + Math.imul(V, ut) | 0, B = B + Math.imul(ge, nt) | 0, T = T + Math.imul(ge, it) | 0, T = T + Math.imul(we, nt) | 0, L = L + Math.imul(we, it) | 0, B = B + Math.imul(Xe, ot) | 0, T = T + Math.imul(Xe, ct) | 0, T = T + Math.imul(Ge, ot) | 0, L = L + Math.imul(Ge, ct) | 0, B = B + Math.imul(Ze, st) | 0, T = T + Math.imul(Ze, lt) | 0, T = T + Math.imul(qe, st) | 0, L = L + Math.imul(qe, lt) | 0;
      var Mt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (Mt >>> 26) | 0, Mt &= 67108863, B = Math.imul(de, rt), T = Math.imul(de, ut), T = T + Math.imul(ce, rt) | 0, L = Math.imul(ce, ut), B = B + Math.imul(Ie, nt) | 0, T = T + Math.imul(Ie, it) | 0, T = T + Math.imul(V, nt) | 0, L = L + Math.imul(V, it) | 0, B = B + Math.imul(ge, ot) | 0, T = T + Math.imul(ge, ct) | 0, T = T + Math.imul(we, ot) | 0, L = L + Math.imul(we, ct) | 0, B = B + Math.imul(Xe, st) | 0, T = T + Math.imul(Xe, lt) | 0, T = T + Math.imul(Ge, st) | 0, L = L + Math.imul(Ge, lt) | 0;
      var $t = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + ($t >>> 26) | 0, $t &= 67108863, B = Math.imul(de, nt), T = Math.imul(de, it), T = T + Math.imul(ce, nt) | 0, L = Math.imul(ce, it), B = B + Math.imul(Ie, ot) | 0, T = T + Math.imul(Ie, ct) | 0, T = T + Math.imul(V, ot) | 0, L = L + Math.imul(V, ct) | 0, B = B + Math.imul(ge, st) | 0, T = T + Math.imul(ge, lt) | 0, T = T + Math.imul(we, st) | 0, L = L + Math.imul(we, lt) | 0;
      var Bt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, B = Math.imul(de, ot), T = Math.imul(de, ct), T = T + Math.imul(ce, ot) | 0, L = Math.imul(ce, ct), B = B + Math.imul(Ie, st) | 0, T = T + Math.imul(Ie, lt) | 0, T = T + Math.imul(V, st) | 0, L = L + Math.imul(V, lt) | 0;
      var Ut = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (L + (T >>> 13) | 0) + (Ut >>> 26) | 0, Ut &= 67108863, B = Math.imul(de, st), T = Math.imul(de, lt), T = T + Math.imul(ce, st) | 0, L = Math.imul(ce, lt);
      var xt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      return Y = (L + (T >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, U[0] = It, U[1] = Rt, U[2] = Ve, U[3] = He, U[4] = Qe, U[5] = pt, U[6] = mt, U[7] = vt, U[8] = ht, U[9] = Et, U[10] = Tt, U[11] = Ot, U[12] = Nt, U[13] = At, U[14] = Mt, U[15] = $t, U[16] = Bt, U[17] = Ut, U[18] = xt, Y !== 0 && (U[19] = Y, I.length++), I;
    };
    Math.imul || (ne = X);
    function Q(P, S, E) {
      E.negative = S.negative ^ P.negative, E.length = P.length + S.length;
      for (var I = 0, M = 0, $ = 0; $ < E.length - 1; $++) {
        var U = M;
        M = 0;
        for (var Y = I & 67108863, B = Math.min($, S.length - 1), T = Math.max(0, $ - P.length + 1); T <= B; T++) {
          var L = $ - T, te = P.words[L] | 0, me = S.words[T] | 0, Ce = te * me, De = Ce & 67108863;
          U = U + (Ce / 67108864 | 0) | 0, De = De + Y | 0, Y = De & 67108863, U = U + (De >>> 26) | 0, M += U >>> 26, U &= 67108863;
        }
        E.words[$] = Y, I = U, U = M;
      }
      return I !== 0 ? E.words[$] = I : E.length--, E.strip();
    }
    function ae(P, S, E) {
      var I = new j();
      return I.mulp(P, S, E);
    }
    p.prototype.mulTo = function(S, E) {
      var I, M = this.length + S.length;
      return this.length === 10 && S.length === 10 ? I = ne(this, S, E) : M < 63 ? I = X(this, S, E) : M < 1024 ? I = Q(this, S, E) : I = ae(this, S, E), I;
    };
    function j(P, S) {
      this.x = P, this.y = S;
    }
    j.prototype.makeRBT = function(S) {
      for (var E = new Array(S), I = p.prototype._countBits(S) - 1, M = 0; M < S; M++)
        E[M] = this.revBin(M, I, S);
      return E;
    }, j.prototype.revBin = function(S, E, I) {
      if (S === 0 || S === I - 1)
        return S;
      for (var M = 0, $ = 0; $ < E; $++)
        M |= (S & 1) << E - $ - 1, S >>= 1;
      return M;
    }, j.prototype.permute = function(S, E, I, M, $, U) {
      for (var Y = 0; Y < U; Y++)
        M[Y] = E[S[Y]], $[Y] = I[S[Y]];
    }, j.prototype.transform = function(S, E, I, M, $, U) {
      this.permute(U, S, E, I, M, $);
      for (var Y = 1; Y < $; Y <<= 1)
        for (var B = Y << 1, T = Math.cos(2 * Math.PI / B), L = Math.sin(2 * Math.PI / B), te = 0; te < $; te += B)
          for (var me = T, Ce = L, De = 0; De < Y; De++) {
            var ye = I[te + De], pe = M[te + De], Me = I[te + De + Y], Ne = M[te + De + Y], Ue = me * Me - Ce * Ne;
            Ne = me * Ne + Ce * Me, Me = Ue, I[te + De] = ye + Me, M[te + De] = pe + Ne, I[te + De + Y] = ye - Me, M[te + De + Y] = pe - Ne, De !== B && (Ue = T * me - L * Ce, Ce = T * Ce + L * me, me = Ue);
          }
    }, j.prototype.guessLen13b = function(S, E) {
      var I = Math.max(E, S) | 1, M = I & 1, $ = 0;
      for (I = I / 2 | 0; I; I = I >>> 1)
        $++;
      return 1 << $ + 1 + M;
    }, j.prototype.conjugate = function(S, E, I) {
      if (!(I <= 1))
        for (var M = 0; M < I / 2; M++) {
          var $ = S[M];
          S[M] = S[I - M - 1], S[I - M - 1] = $, $ = E[M], E[M] = -E[I - M - 1], E[I - M - 1] = -$;
        }
    }, j.prototype.normalize13b = function(S, E) {
      for (var I = 0, M = 0; M < E / 2; M++) {
        var $ = Math.round(S[2 * M + 1] / E) * 8192 + Math.round(S[2 * M] / E) + I;
        S[M] = $ & 67108863, $ < 67108864 ? I = 0 : I = $ / 67108864 | 0;
      }
      return S;
    }, j.prototype.convert13b = function(S, E, I, M) {
      for (var $ = 0, U = 0; U < E; U++)
        $ = $ + (S[U] | 0), I[2 * U] = $ & 8191, $ = $ >>> 13, I[2 * U + 1] = $ & 8191, $ = $ >>> 13;
      for (U = 2 * E; U < M; ++U)
        I[U] = 0;
      l($ === 0), l(($ & -8192) === 0);
    }, j.prototype.stub = function(S) {
      for (var E = new Array(S), I = 0; I < S; I++)
        E[I] = 0;
      return E;
    }, j.prototype.mulp = function(S, E, I) {
      var M = 2 * this.guessLen13b(S.length, E.length), $ = this.makeRBT(M), U = this.stub(M), Y = new Array(M), B = new Array(M), T = new Array(M), L = new Array(M), te = new Array(M), me = new Array(M), Ce = I.words;
      Ce.length = M, this.convert13b(S.words, S.length, Y, M), this.convert13b(E.words, E.length, L, M), this.transform(Y, U, B, T, M, $), this.transform(L, U, te, me, M, $);
      for (var De = 0; De < M; De++) {
        var ye = B[De] * te[De] - T[De] * me[De];
        T[De] = B[De] * me[De] + T[De] * te[De], B[De] = ye;
      }
      return this.conjugate(B, T, M), this.transform(B, T, Ce, U, M, $), this.conjugate(Ce, U, M), this.normalize13b(Ce, M), I.negative = S.negative ^ E.negative, I.length = S.length + E.length, I.strip();
    }, p.prototype.mul = function(S) {
      var E = new p(null);
      return E.words = new Array(this.length + S.length), this.mulTo(S, E);
    }, p.prototype.mulf = function(S) {
      var E = new p(null);
      return E.words = new Array(this.length + S.length), ae(this, S, E);
    }, p.prototype.imul = function(S) {
      return this.clone().mulTo(S, this);
    }, p.prototype.imuln = function(S) {
      l(typeof S == "number"), l(S < 67108864);
      for (var E = 0, I = 0; I < this.length; I++) {
        var M = (this.words[I] | 0) * S, $ = (M & 67108863) + (E & 67108863);
        E >>= 26, E += M / 67108864 | 0, E += $ >>> 26, this.words[I] = $ & 67108863;
      }
      return E !== 0 && (this.words[I] = E, this.length++), this;
    }, p.prototype.muln = function(S) {
      return this.clone().imuln(S);
    }, p.prototype.sqr = function() {
      return this.mul(this);
    }, p.prototype.isqr = function() {
      return this.imul(this.clone());
    }, p.prototype.pow = function(S) {
      var E = ee(S);
      if (E.length === 0)
        return new p(1);
      for (var I = this, M = 0; M < E.length && E[M] === 0; M++, I = I.sqr())
        ;
      if (++M < E.length)
        for (var $ = I.sqr(); M < E.length; M++, $ = $.sqr())
          E[M] !== 0 && (I = I.mul($));
      return I;
    }, p.prototype.iushln = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = S % 26, I = (S - E) / 26, M = 67108863 >>> 26 - E << 26 - E, $;
      if (E !== 0) {
        var U = 0;
        for ($ = 0; $ < this.length; $++) {
          var Y = this.words[$] & M, B = (this.words[$] | 0) - Y << E;
          this.words[$] = B | U, U = Y >>> 26 - E;
        }
        U && (this.words[$] = U, this.length++);
      }
      if (I !== 0) {
        for ($ = this.length - 1; $ >= 0; $--)
          this.words[$ + I] = this.words[$];
        for ($ = 0; $ < I; $++)
          this.words[$] = 0;
        this.length += I;
      }
      return this.strip();
    }, p.prototype.ishln = function(S) {
      return l(this.negative === 0), this.iushln(S);
    }, p.prototype.iushrn = function(S, E, I) {
      l(typeof S == "number" && S >= 0);
      var M;
      E ? M = (E - E % 26) / 26 : M = 0;
      var $ = S % 26, U = Math.min((S - $) / 26, this.length), Y = 67108863 ^ 67108863 >>> $ << $, B = I;
      if (M -= U, M = Math.max(0, M), B) {
        for (var T = 0; T < U; T++)
          B.words[T] = this.words[T];
        B.length = U;
      }
      if (U !== 0)
        if (this.length > U)
          for (this.length -= U, T = 0; T < this.length; T++)
            this.words[T] = this.words[T + U];
        else
          this.words[0] = 0, this.length = 1;
      var L = 0;
      for (T = this.length - 1; T >= 0 && (L !== 0 || T >= M); T--) {
        var te = this.words[T] | 0;
        this.words[T] = L << 26 - $ | te >>> $, L = te & Y;
      }
      return B && L !== 0 && (B.words[B.length++] = L), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, p.prototype.ishrn = function(S, E, I) {
      return l(this.negative === 0), this.iushrn(S, E, I);
    }, p.prototype.shln = function(S) {
      return this.clone().ishln(S);
    }, p.prototype.ushln = function(S) {
      return this.clone().iushln(S);
    }, p.prototype.shrn = function(S) {
      return this.clone().ishrn(S);
    }, p.prototype.ushrn = function(S) {
      return this.clone().iushrn(S);
    }, p.prototype.testn = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = S % 26, I = (S - E) / 26, M = 1 << E;
      if (this.length <= I)
        return !1;
      var $ = this.words[I];
      return !!($ & M);
    }, p.prototype.imaskn = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = S % 26, I = (S - E) / 26;
      if (l(this.negative === 0, "imaskn works only with positive numbers"), this.length <= I)
        return this;
      if (E !== 0 && I++, this.length = Math.min(I, this.length), E !== 0) {
        var M = 67108863 ^ 67108863 >>> E << E;
        this.words[this.length - 1] &= M;
      }
      return this.strip();
    }, p.prototype.maskn = function(S) {
      return this.clone().imaskn(S);
    }, p.prototype.iaddn = function(S) {
      return l(typeof S == "number"), l(S < 67108864), S < 0 ? this.isubn(-S) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < S ? (this.words[0] = S - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(S), this.negative = 1, this) : this._iaddn(S);
    }, p.prototype._iaddn = function(S) {
      this.words[0] += S;
      for (var E = 0; E < this.length && this.words[E] >= 67108864; E++)
        this.words[E] -= 67108864, E === this.length - 1 ? this.words[E + 1] = 1 : this.words[E + 1]++;
      return this.length = Math.max(this.length, E + 1), this;
    }, p.prototype.isubn = function(S) {
      if (l(typeof S == "number"), l(S < 67108864), S < 0)
        return this.iaddn(-S);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(S), this.negative = 1, this;
      if (this.words[0] -= S, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var E = 0; E < this.length && this.words[E] < 0; E++)
          this.words[E] += 67108864, this.words[E + 1] -= 1;
      return this.strip();
    }, p.prototype.addn = function(S) {
      return this.clone().iaddn(S);
    }, p.prototype.subn = function(S) {
      return this.clone().isubn(S);
    }, p.prototype.iabs = function() {
      return this.negative = 0, this;
    }, p.prototype.abs = function() {
      return this.clone().iabs();
    }, p.prototype._ishlnsubmul = function(S, E, I) {
      var M = S.length + I, $;
      this._expand(M);
      var U, Y = 0;
      for ($ = 0; $ < S.length; $++) {
        U = (this.words[$ + I] | 0) + Y;
        var B = (S.words[$] | 0) * E;
        U -= B & 67108863, Y = (U >> 26) - (B / 67108864 | 0), this.words[$ + I] = U & 67108863;
      }
      for (; $ < this.length - I; $++)
        U = (this.words[$ + I] | 0) + Y, Y = U >> 26, this.words[$ + I] = U & 67108863;
      if (Y === 0)
        return this.strip();
      for (l(Y === -1), Y = 0, $ = 0; $ < this.length; $++)
        U = -(this.words[$] | 0) + Y, Y = U >> 26, this.words[$] = U & 67108863;
      return this.negative = 1, this.strip();
    }, p.prototype._wordDiv = function(S, E) {
      var I = this.length - S.length, M = this.clone(), $ = S, U = $.words[$.length - 1] | 0, Y = this._countBits(U);
      I = 26 - Y, I !== 0 && ($ = $.ushln(I), M.iushln(I), U = $.words[$.length - 1] | 0);
      var B = M.length - $.length, T;
      if (E !== "mod") {
        T = new p(null), T.length = B + 1, T.words = new Array(T.length);
        for (var L = 0; L < T.length; L++)
          T.words[L] = 0;
      }
      var te = M.clone()._ishlnsubmul($, 1, B);
      te.negative === 0 && (M = te, T && (T.words[B] = 1));
      for (var me = B - 1; me >= 0; me--) {
        var Ce = (M.words[$.length + me] | 0) * 67108864 + (M.words[$.length + me - 1] | 0);
        for (Ce = Math.min(Ce / U | 0, 67108863), M._ishlnsubmul($, Ce, me); M.negative !== 0; )
          Ce--, M.negative = 0, M._ishlnsubmul($, 1, me), M.isZero() || (M.negative ^= 1);
        T && (T.words[me] = Ce);
      }
      return T && T.strip(), M.strip(), E !== "div" && I !== 0 && M.iushrn(I), {
        div: T || null,
        mod: M
      };
    }, p.prototype.divmod = function(S, E, I) {
      if (l(!S.isZero()), this.isZero())
        return {
          div: new p(0),
          mod: new p(0)
        };
      var M, $, U;
      return this.negative !== 0 && S.negative === 0 ? (U = this.neg().divmod(S, E), E !== "mod" && (M = U.div.neg()), E !== "div" && ($ = U.mod.neg(), I && $.negative !== 0 && $.iadd(S)), {
        div: M,
        mod: $
      }) : this.negative === 0 && S.negative !== 0 ? (U = this.divmod(S.neg(), E), E !== "mod" && (M = U.div.neg()), {
        div: M,
        mod: U.mod
      }) : this.negative & S.negative ? (U = this.neg().divmod(S.neg(), E), E !== "div" && ($ = U.mod.neg(), I && $.negative !== 0 && $.isub(S)), {
        div: U.div,
        mod: $
      }) : S.length > this.length || this.cmp(S) < 0 ? {
        div: new p(0),
        mod: this
      } : S.length === 1 ? E === "div" ? {
        div: this.divn(S.words[0]),
        mod: null
      } : E === "mod" ? {
        div: null,
        mod: new p(this.modn(S.words[0]))
      } : {
        div: this.divn(S.words[0]),
        mod: new p(this.modn(S.words[0]))
      } : this._wordDiv(S, E);
    }, p.prototype.div = function(S) {
      return this.divmod(S, "div", !1).div;
    }, p.prototype.mod = function(S) {
      return this.divmod(S, "mod", !1).mod;
    }, p.prototype.umod = function(S) {
      return this.divmod(S, "mod", !0).mod;
    }, p.prototype.divRound = function(S) {
      var E = this.divmod(S);
      if (E.mod.isZero())
        return E.div;
      var I = E.div.negative !== 0 ? E.mod.isub(S) : E.mod, M = S.ushrn(1), $ = S.andln(1), U = I.cmp(M);
      return U < 0 || $ === 1 && U === 0 ? E.div : E.div.negative !== 0 ? E.div.isubn(1) : E.div.iaddn(1);
    }, p.prototype.modn = function(S) {
      l(S <= 67108863);
      for (var E = (1 << 26) % S, I = 0, M = this.length - 1; M >= 0; M--)
        I = (E * I + (this.words[M] | 0)) % S;
      return I;
    }, p.prototype.idivn = function(S) {
      l(S <= 67108863);
      for (var E = 0, I = this.length - 1; I >= 0; I--) {
        var M = (this.words[I] | 0) + E * 67108864;
        this.words[I] = M / S | 0, E = M % S;
      }
      return this.strip();
    }, p.prototype.divn = function(S) {
      return this.clone().idivn(S);
    }, p.prototype.egcd = function(S) {
      l(S.negative === 0), l(!S.isZero());
      var E = this, I = S.clone();
      E.negative !== 0 ? E = E.umod(S) : E = E.clone();
      for (var M = new p(1), $ = new p(0), U = new p(0), Y = new p(1), B = 0; E.isEven() && I.isEven(); )
        E.iushrn(1), I.iushrn(1), ++B;
      for (var T = I.clone(), L = E.clone(); !E.isZero(); ) {
        for (var te = 0, me = 1; !(E.words[0] & me) && te < 26; ++te, me <<= 1)
          ;
        if (te > 0)
          for (E.iushrn(te); te-- > 0; )
            (M.isOdd() || $.isOdd()) && (M.iadd(T), $.isub(L)), M.iushrn(1), $.iushrn(1);
        for (var Ce = 0, De = 1; !(I.words[0] & De) && Ce < 26; ++Ce, De <<= 1)
          ;
        if (Ce > 0)
          for (I.iushrn(Ce); Ce-- > 0; )
            (U.isOdd() || Y.isOdd()) && (U.iadd(T), Y.isub(L)), U.iushrn(1), Y.iushrn(1);
        E.cmp(I) >= 0 ? (E.isub(I), M.isub(U), $.isub(Y)) : (I.isub(E), U.isub(M), Y.isub($));
      }
      return {
        a: U,
        b: Y,
        gcd: I.iushln(B)
      };
    }, p.prototype._invmp = function(S) {
      l(S.negative === 0), l(!S.isZero());
      var E = this, I = S.clone();
      E.negative !== 0 ? E = E.umod(S) : E = E.clone();
      for (var M = new p(1), $ = new p(0), U = I.clone(); E.cmpn(1) > 0 && I.cmpn(1) > 0; ) {
        for (var Y = 0, B = 1; !(E.words[0] & B) && Y < 26; ++Y, B <<= 1)
          ;
        if (Y > 0)
          for (E.iushrn(Y); Y-- > 0; )
            M.isOdd() && M.iadd(U), M.iushrn(1);
        for (var T = 0, L = 1; !(I.words[0] & L) && T < 26; ++T, L <<= 1)
          ;
        if (T > 0)
          for (I.iushrn(T); T-- > 0; )
            $.isOdd() && $.iadd(U), $.iushrn(1);
        E.cmp(I) >= 0 ? (E.isub(I), M.isub($)) : (I.isub(E), $.isub(M));
      }
      var te;
      return E.cmpn(1) === 0 ? te = M : te = $, te.cmpn(0) < 0 && te.iadd(S), te;
    }, p.prototype.gcd = function(S) {
      if (this.isZero())
        return S.abs();
      if (S.isZero())
        return this.abs();
      var E = this.clone(), I = S.clone();
      E.negative = 0, I.negative = 0;
      for (var M = 0; E.isEven() && I.isEven(); M++)
        E.iushrn(1), I.iushrn(1);
      do {
        for (; E.isEven(); )
          E.iushrn(1);
        for (; I.isEven(); )
          I.iushrn(1);
        var $ = E.cmp(I);
        if ($ < 0) {
          var U = E;
          E = I, I = U;
        } else if ($ === 0 || I.cmpn(1) === 0)
          break;
        E.isub(I);
      } while (!0);
      return I.iushln(M);
    }, p.prototype.invm = function(S) {
      return this.egcd(S).a.umod(S);
    }, p.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, p.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, p.prototype.andln = function(S) {
      return this.words[0] & S;
    }, p.prototype.bincn = function(S) {
      l(typeof S == "number");
      var E = S % 26, I = (S - E) / 26, M = 1 << E;
      if (this.length <= I)
        return this._expand(I + 1), this.words[I] |= M, this;
      for (var $ = M, U = I; $ !== 0 && U < this.length; U++) {
        var Y = this.words[U] | 0;
        Y += $, $ = Y >>> 26, Y &= 67108863, this.words[U] = Y;
      }
      return $ !== 0 && (this.words[U] = $, this.length++), this;
    }, p.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, p.prototype.cmpn = function(S) {
      var E = S < 0;
      if (this.negative !== 0 && !E)
        return -1;
      if (this.negative === 0 && E)
        return 1;
      this.strip();
      var I;
      if (this.length > 1)
        I = 1;
      else {
        E && (S = -S), l(S <= 67108863, "Number is too big");
        var M = this.words[0] | 0;
        I = M === S ? 0 : M < S ? -1 : 1;
      }
      return this.negative !== 0 ? -I | 0 : I;
    }, p.prototype.cmp = function(S) {
      if (this.negative !== 0 && S.negative === 0)
        return -1;
      if (this.negative === 0 && S.negative !== 0)
        return 1;
      var E = this.ucmp(S);
      return this.negative !== 0 ? -E | 0 : E;
    }, p.prototype.ucmp = function(S) {
      if (this.length > S.length)
        return 1;
      if (this.length < S.length)
        return -1;
      for (var E = 0, I = this.length - 1; I >= 0; I--) {
        var M = this.words[I] | 0, $ = S.words[I] | 0;
        if (M !== $) {
          M < $ ? E = -1 : M > $ && (E = 1);
          break;
        }
      }
      return E;
    }, p.prototype.gtn = function(S) {
      return this.cmpn(S) === 1;
    }, p.prototype.gt = function(S) {
      return this.cmp(S) === 1;
    }, p.prototype.gten = function(S) {
      return this.cmpn(S) >= 0;
    }, p.prototype.gte = function(S) {
      return this.cmp(S) >= 0;
    }, p.prototype.ltn = function(S) {
      return this.cmpn(S) === -1;
    }, p.prototype.lt = function(S) {
      return this.cmp(S) === -1;
    }, p.prototype.lten = function(S) {
      return this.cmpn(S) <= 0;
    }, p.prototype.lte = function(S) {
      return this.cmp(S) <= 0;
    }, p.prototype.eqn = function(S) {
      return this.cmpn(S) === 0;
    }, p.prototype.eq = function(S) {
      return this.cmp(S) === 0;
    }, p.red = function(S) {
      return new q(S);
    }, p.prototype.toRed = function(S) {
      return l(!this.red, "Already a number in reduction context"), l(this.negative === 0, "red works only with positives"), S.convertTo(this)._forceRed(S);
    }, p.prototype.fromRed = function() {
      return l(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, p.prototype._forceRed = function(S) {
      return this.red = S, this;
    }, p.prototype.forceRed = function(S) {
      return l(!this.red, "Already a number in reduction context"), this._forceRed(S);
    }, p.prototype.redAdd = function(S) {
      return l(this.red, "redAdd works only with red numbers"), this.red.add(this, S);
    }, p.prototype.redIAdd = function(S) {
      return l(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, S);
    }, p.prototype.redSub = function(S) {
      return l(this.red, "redSub works only with red numbers"), this.red.sub(this, S);
    }, p.prototype.redISub = function(S) {
      return l(this.red, "redISub works only with red numbers"), this.red.isub(this, S);
    }, p.prototype.redShl = function(S) {
      return l(this.red, "redShl works only with red numbers"), this.red.shl(this, S);
    }, p.prototype.redMul = function(S) {
      return l(this.red, "redMul works only with red numbers"), this.red._verify2(this, S), this.red.mul(this, S);
    }, p.prototype.redIMul = function(S) {
      return l(this.red, "redMul works only with red numbers"), this.red._verify2(this, S), this.red.imul(this, S);
    }, p.prototype.redSqr = function() {
      return l(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, p.prototype.redISqr = function() {
      return l(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, p.prototype.redSqrt = function() {
      return l(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, p.prototype.redInvm = function() {
      return l(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, p.prototype.redNeg = function() {
      return l(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, p.prototype.redPow = function(S) {
      return l(this.red && !S.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, S);
    };
    var ue = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function he(P, S) {
      this.name = P, this.p = new p(S, 16), this.n = this.p.bitLength(), this.k = new p(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    he.prototype._tmp = function() {
      var S = new p(null);
      return S.words = new Array(Math.ceil(this.n / 13)), S;
    }, he.prototype.ireduce = function(S) {
      var E = S, I;
      do
        this.split(E, this.tmp), E = this.imulK(E), E = E.iadd(this.tmp), I = E.bitLength();
      while (I > this.n);
      var M = I < this.n ? -1 : E.ucmp(this.p);
      return M === 0 ? (E.words[0] = 0, E.length = 1) : M > 0 ? E.isub(this.p) : E.strip !== void 0 ? E.strip() : E._strip(), E;
    }, he.prototype.split = function(S, E) {
      S.iushrn(this.n, 0, E);
    }, he.prototype.imulK = function(S) {
      return S.imul(this.k);
    };
    function fe() {
      he.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    v(fe, he), fe.prototype.split = function(S, E) {
      for (var I = 4194303, M = Math.min(S.length, 9), $ = 0; $ < M; $++)
        E.words[$] = S.words[$];
      if (E.length = M, S.length <= 9) {
        S.words[0] = 0, S.length = 1;
        return;
      }
      var U = S.words[9];
      for (E.words[E.length++] = U & I, $ = 10; $ < S.length; $++) {
        var Y = S.words[$] | 0;
        S.words[$ - 10] = (Y & I) << 4 | U >>> 22, U = Y;
      }
      U >>>= 22, S.words[$ - 10] = U, U === 0 && S.length > 10 ? S.length -= 10 : S.length -= 9;
    }, fe.prototype.imulK = function(S) {
      S.words[S.length] = 0, S.words[S.length + 1] = 0, S.length += 2;
      for (var E = 0, I = 0; I < S.length; I++) {
        var M = S.words[I] | 0;
        E += M * 977, S.words[I] = E & 67108863, E = M * 64 + (E / 67108864 | 0);
      }
      return S.words[S.length - 1] === 0 && (S.length--, S.words[S.length - 1] === 0 && S.length--), S;
    };
    function be() {
      he.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    v(be, he);
    function ke() {
      he.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    v(ke, he);
    function Te() {
      he.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    v(Te, he), Te.prototype.imulK = function(S) {
      for (var E = 0, I = 0; I < S.length; I++) {
        var M = (S.words[I] | 0) * 19 + E, $ = M & 67108863;
        M >>>= 26, S.words[I] = $, E = M;
      }
      return E !== 0 && (S.words[S.length++] = E), S;
    }, p._prime = function(S) {
      if (ue[S])
        return ue[S];
      var E;
      if (S === "k256")
        E = new fe();
      else if (S === "p224")
        E = new be();
      else if (S === "p192")
        E = new ke();
      else if (S === "p25519")
        E = new Te();
      else
        throw new Error("Unknown prime " + S);
      return ue[S] = E, E;
    };
    function q(P) {
      if (typeof P == "string") {
        var S = p._prime(P);
        this.m = S.p, this.prime = S;
      } else
        l(P.gtn(1), "modulus must be greater than 1"), this.m = P, this.prime = null;
    }
    q.prototype._verify1 = function(S) {
      l(S.negative === 0, "red works only with positives"), l(S.red, "red works only with red numbers");
    }, q.prototype._verify2 = function(S, E) {
      l((S.negative | E.negative) === 0, "red works only with positives"), l(
        S.red && S.red === E.red,
        "red works only with red numbers"
      );
    }, q.prototype.imod = function(S) {
      return this.prime ? this.prime.ireduce(S)._forceRed(this) : S.umod(this.m)._forceRed(this);
    }, q.prototype.neg = function(S) {
      return S.isZero() ? S.clone() : this.m.sub(S)._forceRed(this);
    }, q.prototype.add = function(S, E) {
      this._verify2(S, E);
      var I = S.add(E);
      return I.cmp(this.m) >= 0 && I.isub(this.m), I._forceRed(this);
    }, q.prototype.iadd = function(S, E) {
      this._verify2(S, E);
      var I = S.iadd(E);
      return I.cmp(this.m) >= 0 && I.isub(this.m), I;
    }, q.prototype.sub = function(S, E) {
      this._verify2(S, E);
      var I = S.sub(E);
      return I.cmpn(0) < 0 && I.iadd(this.m), I._forceRed(this);
    }, q.prototype.isub = function(S, E) {
      this._verify2(S, E);
      var I = S.isub(E);
      return I.cmpn(0) < 0 && I.iadd(this.m), I;
    }, q.prototype.shl = function(S, E) {
      return this._verify1(S), this.imod(S.ushln(E));
    }, q.prototype.imul = function(S, E) {
      return this._verify2(S, E), this.imod(S.imul(E));
    }, q.prototype.mul = function(S, E) {
      return this._verify2(S, E), this.imod(S.mul(E));
    }, q.prototype.isqr = function(S) {
      return this.imul(S, S.clone());
    }, q.prototype.sqr = function(S) {
      return this.mul(S, S);
    }, q.prototype.sqrt = function(S) {
      if (S.isZero())
        return S.clone();
      var E = this.m.andln(3);
      if (l(E % 2 === 1), E === 3) {
        var I = this.m.add(new p(1)).iushrn(2);
        return this.pow(S, I);
      }
      for (var M = this.m.subn(1), $ = 0; !M.isZero() && M.andln(1) === 0; )
        $++, M.iushrn(1);
      l(!M.isZero());
      var U = new p(1).toRed(this), Y = U.redNeg(), B = this.m.subn(1).iushrn(1), T = this.m.bitLength();
      for (T = new p(2 * T * T).toRed(this); this.pow(T, B).cmp(Y) !== 0; )
        T.redIAdd(Y);
      for (var L = this.pow(T, M), te = this.pow(S, M.addn(1).iushrn(1)), me = this.pow(S, M), Ce = $; me.cmp(U) !== 0; ) {
        for (var De = me, ye = 0; De.cmp(U) !== 0; ye++)
          De = De.redSqr();
        l(ye < Ce);
        var pe = this.pow(L, new p(1).iushln(Ce - ye - 1));
        te = te.redMul(pe), L = pe.redSqr(), me = me.redMul(L), Ce = ye;
      }
      return te;
    }, q.prototype.invm = function(S) {
      var E = S._invmp(this.m);
      return E.negative !== 0 ? (E.negative = 0, this.imod(E).redNeg()) : this.imod(E);
    }, q.prototype.pow = function(S, E) {
      if (E.isZero())
        return new p(1).toRed(this);
      if (E.cmpn(1) === 0)
        return S.clone();
      var I = 4, M = new Array(1 << I);
      M[0] = new p(1).toRed(this), M[1] = S;
      for (var $ = 2; $ < M.length; $++)
        M[$] = this.mul(M[$ - 1], S);
      var U = M[0], Y = 0, B = 0, T = E.bitLength() % 26;
      for (T === 0 && (T = 26), $ = E.length - 1; $ >= 0; $--) {
        for (var L = E.words[$], te = T - 1; te >= 0; te--) {
          var me = L >> te & 1;
          if (U !== M[0] && (U = this.sqr(U)), me === 0 && Y === 0) {
            B = 0;
            continue;
          }
          Y <<= 1, Y |= me, B++, !(B !== I && ($ !== 0 || te !== 0)) && (U = this.mul(U, M[Y]), B = 0, Y = 0);
        }
        T = 26;
      }
      return U;
    }, q.prototype.convertTo = function(S) {
      var E = S.umod(this.m);
      return E === S ? E.clone() : E;
    }, q.prototype.convertFrom = function(S) {
      var E = S.clone();
      return E.red = null, E;
    }, p.mont = function(S) {
      return new z(S);
    };
    function z(P) {
      q.call(this, P), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new p(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    v(z, q), z.prototype.convertTo = function(S) {
      return this.imod(S.ushln(this.shift));
    }, z.prototype.convertFrom = function(S) {
      var E = this.imod(S.mul(this.rinv));
      return E.red = null, E;
    }, z.prototype.imul = function(S, E) {
      if (S.isZero() || E.isZero())
        return S.words[0] = 0, S.length = 1, S;
      var I = S.imul(E), M = I.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), $ = I.isub(M).iushrn(this.shift), U = $;
      return $.cmp(this.m) >= 0 ? U = $.isub(this.m) : $.cmpn(0) < 0 && (U = $.iadd(this.m)), U._forceRed(this);
    }, z.prototype.mul = function(S, E) {
      if (S.isZero() || E.isZero())
        return new p(0)._forceRed(this);
      var I = S.mul(E), M = I.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), $ = I.isub(M).iushrn(this.shift), U = $;
      return $.cmp(this.m) >= 0 ? U = $.isub(this.m) : $.cmpn(0) < 0 && (U = $.iadd(this.m)), U._forceRed(this);
    }, z.prototype.invm = function(S) {
      var E = this.imod(S._invmp(this.m).mul(this.r2));
      return E._forceRed(this);
    };
  })(a, commonjsGlobal$1);
})(bn);
var bnExports = bn.exports, BN$2 = bnExports, Buffer$8 = safeBufferExports$3.Buffer;
function withPublic$2(a, u) {
  return Buffer$8.from(a.toRed(BN$2.mont(u.modulus)).redPow(new BN$2(u.publicExponent)).fromRed().toArray());
}
var withPublic_1 = withPublic$2, parseKeys$1 = parseAsn1, randomBytes = browserExports, createHash$1 = browser$a, mgf$1 = mgf$2, xor$1 = xor$2, BN$1 = bnExports, withPublic$1 = withPublic_1, crt$1 = browserifyRsa, Buffer$7 = safeBufferExports$3.Buffer, publicEncrypt = function a(u, c, l) {
  var v;
  u.padding ? v = u.padding : l ? v = 1 : v = 4;
  var p = parseKeys$1(u), _;
  if (v === 4)
    _ = oaep$1(p, c);
  else if (v === 1)
    _ = pkcs1$1(p, c, l);
  else if (v === 3) {
    if (_ = new BN$1(c), _.cmp(p.modulus) >= 0)
      throw new Error("data too long for modulus");
  } else
    throw new Error("unknown padding");
  return l ? crt$1(_, p) : withPublic$1(_, p);
};
function oaep$1(a, u) {
  var c = a.modulus.byteLength(), l = u.length, v = createHash$1("sha1").update(Buffer$7.alloc(0)).digest(), p = v.length, _ = 2 * p;
  if (l > c - _ - 2)
    throw new Error("message too long");
  var k = Buffer$7.alloc(c - l - _ - 2), O = c - p - 1, D = randomBytes(p), F = xor$1(Buffer$7.concat([v, k, Buffer$7.alloc(1, 1), u], O), mgf$1(D, O)), H = xor$1(D, mgf$1(F, p));
  return new BN$1(Buffer$7.concat([Buffer$7.alloc(1), H, F], c));
}
function pkcs1$1(a, u, c) {
  var l = u.length, v = a.modulus.byteLength();
  if (l > v - 11)
    throw new Error("message too long");
  var p;
  return c ? p = Buffer$7.alloc(v - l - 3, 255) : p = nonZero(v - l - 3), new BN$1(Buffer$7.concat([Buffer$7.from([0, c ? 1 : 2]), p, Buffer$7.alloc(1), u], v));
}
function nonZero(a) {
  for (var u = Buffer$7.allocUnsafe(a), c = 0, l = randomBytes(a * 2), v = 0, p; c < a; )
    v === l.length && (l = randomBytes(a * 2), v = 0), p = l[v++], p && (u[c++] = p);
  return u;
}
var parseKeys = parseAsn1, mgf = mgf$2, xor = xor$2, BN = bnExports, crt = browserifyRsa, createHash = browser$a, withPublic = withPublic_1, Buffer$6 = safeBufferExports$3.Buffer, privateDecrypt = function a(u, c, l) {
  var v;
  u.padding ? v = u.padding : l ? v = 1 : v = 4;
  var p = parseKeys(u), _ = p.modulus.byteLength();
  if (c.length > _ || new BN(c).cmp(p.modulus) >= 0)
    throw new Error("decryption error");
  var k;
  l ? k = withPublic(new BN(c), p) : k = crt(c, p);
  var O = Buffer$6.alloc(_ - k.length);
  if (k = Buffer$6.concat([O, k], _), v === 4)
    return oaep(p, k);
  if (v === 1)
    return pkcs1(p, k, l);
  if (v === 3)
    return k;
  throw new Error("unknown padding");
};
function oaep(a, u) {
  var c = a.modulus.byteLength(), l = createHash("sha1").update(Buffer$6.alloc(0)).digest(), v = l.length;
  if (u[0] !== 0)
    throw new Error("decryption error");
  var p = u.slice(1, v + 1), _ = u.slice(v + 1), k = xor(p, mgf(_, v)), O = xor(_, mgf(k, c - v - 1));
  if (compare(l, O.slice(0, v)))
    throw new Error("decryption error");
  for (var D = v; O[D] === 0; )
    D++;
  if (O[D++] !== 1)
    throw new Error("decryption error");
  return O.slice(D);
}
function pkcs1(a, u, c) {
  for (var l = u.slice(0, 2), v = 2, p = 0; u[v++] !== 0; )
    if (v >= u.length) {
      p++;
      break;
    }
  var _ = u.slice(2, v - 1);
  if ((l.toString("hex") !== "0002" && !c || l.toString("hex") !== "0001" && c) && p++, _.length < 8 && p++, p)
    throw new Error("decryption error");
  return u.slice(v);
}
function compare(a, u) {
  a = Buffer$6.from(a), u = Buffer$6.from(u);
  var c = 0, l = a.length;
  a.length !== u.length && (c++, l = Math.min(a.length, u.length));
  for (var v = -1; ++v < l; )
    c += a[v] ^ u[v];
  return c;
}
(function(a) {
  a.publicEncrypt = publicEncrypt, a.privateDecrypt = privateDecrypt, a.privateEncrypt = function(c, l) {
    return a.publicEncrypt(c, l, !0);
  }, a.publicDecrypt = function(c, l) {
    return a.privateDecrypt(c, l, !0);
  };
})(browser$2);
var browser$1 = {};
function oldBrowser() {
  throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`);
}
var safeBuffer = safeBufferExports$3, randombytes = browserExports, Buffer$5 = safeBuffer.Buffer, kBufferMaxLength = safeBuffer.kMaxLength, crypto$2 = commonjsGlobal$1.crypto || commonjsGlobal$1.msCrypto, kMaxUint32 = Math.pow(2, 32) - 1;
function assertOffset(a, u) {
  if (typeof a != "number" || a !== a)
    throw new TypeError("offset must be a number");
  if (a > kMaxUint32 || a < 0)
    throw new TypeError("offset must be a uint32");
  if (a > kBufferMaxLength || a > u)
    throw new RangeError("offset out of range");
}
function assertSize(a, u, c) {
  if (typeof a != "number" || a !== a)
    throw new TypeError("size must be a number");
  if (a > kMaxUint32 || a < 0)
    throw new TypeError("size must be a uint32");
  if (a + u > c || a > kBufferMaxLength)
    throw new RangeError("buffer too small");
}
crypto$2 && crypto$2.getRandomValues || !process$1.browser ? (browser$1.randomFill = randomFill, browser$1.randomFillSync = randomFillSync) : (browser$1.randomFill = oldBrowser, browser$1.randomFillSync = oldBrowser);
function randomFill(a, u, c, l) {
  if (!Buffer$5.isBuffer(a) && !(a instanceof commonjsGlobal$1.Uint8Array))
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
  if (typeof u == "function")
    l = u, u = 0, c = a.length;
  else if (typeof c == "function")
    l = c, c = a.length - u;
  else if (typeof l != "function")
    throw new TypeError('"cb" argument must be a function');
  return assertOffset(u, a.length), assertSize(c, u, a.length), actualFill(a, u, c, l);
}
function actualFill(a, u, c, l) {
  if (process$1.browser) {
    var v = a.buffer, p = new Uint8Array(v, u, c);
    if (crypto$2.getRandomValues(p), l) {
      process$1.nextTick(function() {
        l(null, a);
      });
      return;
    }
    return a;
  }
  if (l) {
    randombytes(c, function(k, O) {
      if (k)
        return l(k);
      O.copy(a, u), l(null, a);
    });
    return;
  }
  var _ = randombytes(c);
  return _.copy(a, u), a;
}
function randomFillSync(a, u, c) {
  if (typeof u > "u" && (u = 0), !Buffer$5.isBuffer(a) && !(a instanceof commonjsGlobal$1.Uint8Array))
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
  return assertOffset(u, a.length), c === void 0 && (c = a.length - u), assertSize(c, u, a.length), actualFill(a, u, c);
}
var hasRequiredCryptoBrowserify;
function requireCryptoBrowserify() {
  if (hasRequiredCryptoBrowserify)
    return cryptoBrowserify;
  hasRequiredCryptoBrowserify = 1, cryptoBrowserify.randomBytes = cryptoBrowserify.rng = cryptoBrowserify.pseudoRandomBytes = cryptoBrowserify.prng = browserExports, cryptoBrowserify.createHash = cryptoBrowserify.Hash = browser$a, cryptoBrowserify.createHmac = cryptoBrowserify.Hmac = browser$9;
  var a = algos, u = Object.keys(a), c = ["sha1", "sha224", "sha256", "sha384", "sha512", "md5", "rmd160"].concat(u);
  cryptoBrowserify.getHashes = function() {
    return c;
  };
  var l = browser$8;
  cryptoBrowserify.pbkdf2 = l.pbkdf2, cryptoBrowserify.pbkdf2Sync = l.pbkdf2Sync;
  var v = browser$7;
  cryptoBrowserify.Cipher = v.Cipher, cryptoBrowserify.createCipher = v.createCipher, cryptoBrowserify.Cipheriv = v.Cipheriv, cryptoBrowserify.createCipheriv = v.createCipheriv, cryptoBrowserify.Decipher = v.Decipher, cryptoBrowserify.createDecipher = v.createDecipher, cryptoBrowserify.Decipheriv = v.Decipheriv, cryptoBrowserify.createDecipheriv = v.createDecipheriv, cryptoBrowserify.getCiphers = v.getCiphers, cryptoBrowserify.listCiphers = v.listCiphers;
  var p = requireBrowser$2();
  cryptoBrowserify.DiffieHellmanGroup = p.DiffieHellmanGroup, cryptoBrowserify.createDiffieHellmanGroup = p.createDiffieHellmanGroup, cryptoBrowserify.getDiffieHellman = p.getDiffieHellman, cryptoBrowserify.createDiffieHellman = p.createDiffieHellman, cryptoBrowserify.DiffieHellman = p.DiffieHellman;
  var _ = requireBrowser$1();
  cryptoBrowserify.createSign = _.createSign, cryptoBrowserify.Sign = _.Sign, cryptoBrowserify.createVerify = _.createVerify, cryptoBrowserify.Verify = _.Verify, cryptoBrowserify.createECDH = requireBrowser();
  var k = browser$2;
  cryptoBrowserify.publicEncrypt = k.publicEncrypt, cryptoBrowserify.privateEncrypt = k.privateEncrypt, cryptoBrowserify.publicDecrypt = k.publicDecrypt, cryptoBrowserify.privateDecrypt = k.privateDecrypt;
  var O = browser$1;
  return cryptoBrowserify.randomFill = O.randomFill, cryptoBrowserify.randomFillSync = O.randomFillSync, cryptoBrowserify.createCredentials = function() {
    throw new Error([
      "sorry, createCredentials is not implemented yet",
      "we accept pull requests",
      "https://github.com/crypto-browserify/crypto-browserify"
    ].join(`
`));
  }, cryptoBrowserify.constants = {
    DH_CHECK_P_NOT_SAFE_PRIME: 2,
    DH_CHECK_P_NOT_PRIME: 1,
    DH_UNABLE_TO_CHECK_GENERATOR: 4,
    DH_NOT_SUITABLE_GENERATOR: 8,
    NPN_ENABLED: 1,
    ALPN_ENABLED: 1,
    RSA_PKCS1_PADDING: 1,
    RSA_SSLV23_PADDING: 2,
    RSA_NO_PADDING: 3,
    RSA_PKCS1_OAEP_PADDING: 4,
    RSA_X931_PADDING: 5,
    RSA_PKCS1_PSS_PADDING: 6,
    POINT_CONVERSION_COMPRESSED: 2,
    POINT_CONVERSION_UNCOMPRESSED: 4,
    POINT_CONVERSION_HYBRID: 6
  }, cryptoBrowserify;
}
function getParamSize(a) {
  var u = (a / 8 | 0) + (a % 8 === 0 ? 0 : 1);
  return u;
}
var paramBytesForAlg = {
  ES256: getParamSize(256),
  ES384: getParamSize(384),
  ES512: getParamSize(521)
};
function getParamBytesForAlg$1(a) {
  var u = paramBytesForAlg[a];
  if (u)
    return u;
  throw new Error('Unknown algorithm "' + a + '"');
}
var paramBytesForAlg_1 = getParamBytesForAlg$1, Buffer$4 = safeBufferExports$3.Buffer, getParamBytesForAlg = paramBytesForAlg_1, MAX_OCTET = 128, CLASS_UNIVERSAL = 0, PRIMITIVE_BIT = 32, TAG_SEQ = 16, TAG_INT = 2, ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | CLASS_UNIVERSAL << 6, ENCODED_TAG_INT = TAG_INT | CLASS_UNIVERSAL << 6;
function base64Url(a) {
  return a.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function signatureAsBuffer(a) {
  if (Buffer$4.isBuffer(a))
    return a;
  if (typeof a == "string")
    return Buffer$4.from(a, "base64");
  throw new TypeError("ECDSA signature must be a Base64 string or a Buffer");
}
function derToJose(a, u) {
  a = signatureAsBuffer(a);
  var c = getParamBytesForAlg(u), l = c + 1, v = a.length, p = 0;
  if (a[p++] !== ENCODED_TAG_SEQ)
    throw new Error('Could not find expected "seq"');
  var _ = a[p++];
  if (_ === (MAX_OCTET | 1) && (_ = a[p++]), v - p < _)
    throw new Error('"seq" specified length of "' + _ + '", only "' + (v - p) + '" remaining');
  if (a[p++] !== ENCODED_TAG_INT)
    throw new Error('Could not find expected "int" for "r"');
  var k = a[p++];
  if (v - p - 2 < k)
    throw new Error('"r" specified length of "' + k + '", only "' + (v - p - 2) + '" available');
  if (l < k)
    throw new Error('"r" specified length of "' + k + '", max of "' + l + '" is acceptable');
  var O = p;
  if (p += k, a[p++] !== ENCODED_TAG_INT)
    throw new Error('Could not find expected "int" for "s"');
  var D = a[p++];
  if (v - p !== D)
    throw new Error('"s" specified length of "' + D + '", expected "' + (v - p) + '"');
  if (l < D)
    throw new Error('"s" specified length of "' + D + '", max of "' + l + '" is acceptable');
  var F = p;
  if (p += D, p !== v)
    throw new Error('Expected to consume entire buffer, but "' + (v - p) + '" bytes remain');
  var H = c - k, Z = c - D, ee = Buffer$4.allocUnsafe(H + k + Z + D);
  for (p = 0; p < H; ++p)
    ee[p] = 0;
  a.copy(ee, p, O + Math.max(-H, 0), O + k), p = c;
  for (var X = p; p < X + Z; ++p)
    ee[p] = 0;
  return a.copy(ee, p, F + Math.max(-Z, 0), F + D), ee = ee.toString("base64"), ee = base64Url(ee), ee;
}
function countPadding(a, u, c) {
  for (var l = 0; u + l < c && a[u + l] === 0; )
    ++l;
  var v = a[u + l] >= MAX_OCTET;
  return v && --l, l;
}
function joseToDer(a, u) {
  a = signatureAsBuffer(a);
  var c = getParamBytesForAlg(u), l = a.length;
  if (l !== c * 2)
    throw new TypeError('"' + u + '" signatures must be "' + c * 2 + '" bytes, saw "' + l + '"');
  var v = countPadding(a, 0, c), p = countPadding(a, c, a.length), _ = c - v, k = c - p, O = 2 + _ + 1 + 1 + k, D = O < MAX_OCTET, F = Buffer$4.allocUnsafe((D ? 2 : 3) + O), H = 0;
  return F[H++] = ENCODED_TAG_SEQ, D ? F[H++] = O : (F[H++] = MAX_OCTET | 1, F[H++] = O & 255), F[H++] = ENCODED_TAG_INT, F[H++] = _, v < 0 ? (F[H++] = 0, H += a.copy(F, H, 0, c)) : H += a.copy(F, H, v, c), F[H++] = ENCODED_TAG_INT, F[H++] = k, p < 0 ? (F[H++] = 0, a.copy(F, H, c)) : a.copy(F, H, c + p), F;
}
var ecdsaSigFormatter = {
  derToJose,
  joseToDer
}, bufferEqual = bufferEqualConstantTime, Buffer$3 = safeBufferExports$3.Buffer, crypto$1 = requireCryptoBrowserify(), formatEcdsa = ecdsaSigFormatter, util$2 = util$4, MSG_INVALID_ALGORITHM = `"%s" is not a valid algorithm.
  Supported algorithms are:
  "HS256", "HS384", "HS512", "RS256", "RS384", "RS512", "PS256", "PS384", "PS512", "ES256", "ES384", "ES512" and "none".`, MSG_INVALID_SECRET = "secret must be a string or buffer", MSG_INVALID_VERIFIER_KEY = "key must be a string or a buffer", MSG_INVALID_SIGNER_KEY = "key must be a string, a buffer or an object", supportsKeyObjects = typeof crypto$1.createPublicKey == "function";
supportsKeyObjects && (MSG_INVALID_VERIFIER_KEY += " or a KeyObject", MSG_INVALID_SECRET += "or a KeyObject");
function checkIsPublicKey(a) {
  if (!Buffer$3.isBuffer(a) && typeof a != "string" && (!supportsKeyObjects || typeof a != "object" || typeof a.type != "string" || typeof a.asymmetricKeyType != "string" || typeof a.export != "function"))
    throw typeError(MSG_INVALID_VERIFIER_KEY);
}
function checkIsPrivateKey(a) {
  if (!Buffer$3.isBuffer(a) && typeof a != "string" && typeof a != "object")
    throw typeError(MSG_INVALID_SIGNER_KEY);
}
function checkIsSecretKey(a) {
  if (!Buffer$3.isBuffer(a)) {
    if (typeof a == "string")
      return a;
    if (!supportsKeyObjects || typeof a != "object" || a.type !== "secret" || typeof a.export != "function")
      throw typeError(MSG_INVALID_SECRET);
  }
}
function fromBase64(a) {
  return a.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function toBase64(a) {
  a = a.toString();
  var u = 4 - a.length % 4;
  if (u !== 4)
    for (var c = 0; c < u; ++c)
      a += "=";
  return a.replace(/\-/g, "+").replace(/_/g, "/");
}
function typeError(a) {
  var u = [].slice.call(arguments, 1), c = util$2.format.bind(util$2, a).apply(null, u);
  return new TypeError(c);
}
function bufferOrString(a) {
  return Buffer$3.isBuffer(a) || typeof a == "string";
}
function normalizeInput(a) {
  return bufferOrString(a) || (a = JSON.stringify(a)), a;
}
function createHmacSigner(a) {
  return function(c, l) {
    checkIsSecretKey(l), c = normalizeInput(c);
    var v = crypto$1.createHmac("sha" + a, l), p = (v.update(c), v.digest("base64"));
    return fromBase64(p);
  };
}
function createHmacVerifier(a) {
  return function(c, l, v) {
    var p = createHmacSigner(a)(c, v);
    return bufferEqual(Buffer$3.from(l), Buffer$3.from(p));
  };
}
function createKeySigner(a) {
  return function(c, l) {
    checkIsPrivateKey(l), c = normalizeInput(c);
    var v = crypto$1.createSign("RSA-SHA" + a), p = (v.update(c), v.sign(l, "base64"));
    return fromBase64(p);
  };
}
function createKeyVerifier(a) {
  return function(c, l, v) {
    checkIsPublicKey(v), c = normalizeInput(c), l = toBase64(l);
    var p = crypto$1.createVerify("RSA-SHA" + a);
    return p.update(c), p.verify(v, l, "base64");
  };
}
function createPSSKeySigner(a) {
  return function(c, l) {
    checkIsPrivateKey(l), c = normalizeInput(c);
    var v = crypto$1.createSign("RSA-SHA" + a), p = (v.update(c), v.sign({
      key: l,
      padding: crypto$1.constants.RSA_PKCS1_PSS_PADDING,
      saltLength: crypto$1.constants.RSA_PSS_SALTLEN_DIGEST
    }, "base64"));
    return fromBase64(p);
  };
}
function createPSSKeyVerifier(a) {
  return function(c, l, v) {
    checkIsPublicKey(v), c = normalizeInput(c), l = toBase64(l);
    var p = crypto$1.createVerify("RSA-SHA" + a);
    return p.update(c), p.verify({
      key: v,
      padding: crypto$1.constants.RSA_PKCS1_PSS_PADDING,
      saltLength: crypto$1.constants.RSA_PSS_SALTLEN_DIGEST
    }, l, "base64");
  };
}
function createECDSASigner(a) {
  var u = createKeySigner(a);
  return function() {
    var l = u.apply(null, arguments);
    return l = formatEcdsa.derToJose(l, "ES" + a), l;
  };
}
function createECDSAVerifer(a) {
  var u = createKeyVerifier(a);
  return function(l, v, p) {
    v = formatEcdsa.joseToDer(v, "ES" + a).toString("base64");
    var _ = u(l, v, p);
    return _;
  };
}
function createNoneSigner() {
  return function() {
    return "";
  };
}
function createNoneVerifier() {
  return function(u, c) {
    return c === "";
  };
}
var jwa$2 = function a(u) {
  var c = {
    hs: createHmacSigner,
    rs: createKeySigner,
    ps: createPSSKeySigner,
    es: createECDSASigner,
    none: createNoneSigner
  }, l = {
    hs: createHmacVerifier,
    rs: createKeyVerifier,
    ps: createPSSKeyVerifier,
    es: createECDSAVerifer,
    none: createNoneVerifier
  }, v = u.match(/^(RS|PS|ES|HS)(256|384|512)$|^(none)$/i);
  if (!v)
    throw typeError(MSG_INVALID_ALGORITHM, u);
  var p = (v[1] || v[3]).toLowerCase(), _ = v[2];
  return {
    sign: c[p](_),
    verify: l[p](_)
  };
}, Buffer$2 = require$$0$2.Buffer, tostring = function a(u) {
  return typeof u == "string" ? u : typeof u == "number" || Buffer$2.isBuffer(u) ? u.toString() : JSON.stringify(u);
}, Buffer$1 = safeBufferExports$3.Buffer, DataStream$1 = dataStream, jwa$1 = jwa$2, Stream$1 = streamBrowserify, toString$2 = tostring, util$1 = util$4;
function base64url(a, u) {
  return Buffer$1.from(a, u).toString("base64").replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function jwsSecuredInput(a, u, c) {
  c = c || "utf8";
  var l = base64url(toString$2(a), "binary"), v = base64url(toString$2(u), c);
  return util$1.format("%s.%s", l, v);
}
function jwsSign(a) {
  var u = a.header, c = a.payload, l = a.secret || a.privateKey, v = a.encoding, p = jwa$1(u.alg), _ = jwsSecuredInput(u, c, v), k = p.sign(_, l);
  return util$1.format("%s.%s", _, k);
}
function SignStream$1(a) {
  var u = a.secret || a.privateKey || a.key, c = new DataStream$1(u);
  this.readable = !0, this.header = a.header, this.encoding = a.encoding, this.secret = this.privateKey = this.key = c, this.payload = new DataStream$1(a.payload), this.secret.once("close", (function() {
    !this.payload.writable && this.readable && this.sign();
  }).bind(this)), this.payload.once("close", (function() {
    !this.secret.writable && this.readable && this.sign();
  }).bind(this));
}
util$1.inherits(SignStream$1, Stream$1);
SignStream$1.prototype.sign = function a() {
  try {
    var u = jwsSign({
      header: this.header,
      payload: this.payload.buffer,
      secret: this.secret.buffer,
      encoding: this.encoding
    });
    return this.emit("done", u), this.emit("data", u), this.emit("end"), this.readable = !1, u;
  } catch (c) {
    this.readable = !1, this.emit("error", c), this.emit("close");
  }
};
SignStream$1.sign = jwsSign;
var signStream = SignStream$1, Buffer = safeBufferExports$3.Buffer, DataStream = dataStream, jwa = jwa$2, Stream = streamBrowserify, toString$1 = tostring, util = util$4, JWS_REGEX = /^[a-zA-Z0-9\-_]+?\.[a-zA-Z0-9\-_]+?\.([a-zA-Z0-9\-_]+)?$/;
function isObject$6(a) {
  return Object.prototype.toString.call(a) === "[object Object]";
}
function safeJsonParse(a) {
  if (isObject$6(a))
    return a;
  try {
    return JSON.parse(a);
  } catch {
    return;
  }
}
function headerFromJWS(a) {
  var u = a.split(".", 1)[0];
  return safeJsonParse(Buffer.from(u, "base64").toString("binary"));
}
function securedInputFromJWS(a) {
  return a.split(".", 2).join(".");
}
function signatureFromJWS(a) {
  return a.split(".")[2];
}
function payloadFromJWS(a, u) {
  u = u || "utf8";
  var c = a.split(".")[1];
  return Buffer.from(c, "base64").toString(u);
}
function isValidJws(a) {
  return JWS_REGEX.test(a) && !!headerFromJWS(a);
}
function jwsVerify(a, u, c) {
  if (!u) {
    var l = new Error("Missing algorithm parameter for jws.verify");
    throw l.code = "MISSING_ALGORITHM", l;
  }
  a = toString$1(a);
  var v = signatureFromJWS(a), p = securedInputFromJWS(a), _ = jwa(u);
  return _.verify(p, v, c);
}
function jwsDecode(a, u) {
  if (u = u || {}, a = toString$1(a), !isValidJws(a))
    return null;
  var c = headerFromJWS(a);
  if (!c)
    return null;
  var l = payloadFromJWS(a);
  return (c.typ === "JWT" || u.json) && (l = JSON.parse(l, u.encoding)), {
    header: c,
    payload: l,
    signature: signatureFromJWS(a)
  };
}
function VerifyStream$1(a) {
  a = a || {};
  var u = a.secret || a.publicKey || a.key, c = new DataStream(u);
  this.readable = !0, this.algorithm = a.algorithm, this.encoding = a.encoding, this.secret = this.publicKey = this.key = c, this.signature = new DataStream(a.signature), this.secret.once("close", (function() {
    !this.signature.writable && this.readable && this.verify();
  }).bind(this)), this.signature.once("close", (function() {
    !this.secret.writable && this.readable && this.verify();
  }).bind(this));
}
util.inherits(VerifyStream$1, Stream);
VerifyStream$1.prototype.verify = function a() {
  try {
    var u = jwsVerify(this.signature.buffer, this.algorithm, this.key.buffer), c = jwsDecode(this.signature.buffer, this.encoding);
    return this.emit("done", u, c), this.emit("data", u), this.emit("end"), this.readable = !1, u;
  } catch (l) {
    this.readable = !1, this.emit("error", l), this.emit("close");
  }
};
VerifyStream$1.decode = jwsDecode;
VerifyStream$1.isValid = isValidJws;
VerifyStream$1.verify = jwsVerify;
var verifyStream = VerifyStream$1, SignStream = signStream, VerifyStream = verifyStream, ALGORITHMS = [
  "HS256",
  "HS384",
  "HS512",
  "RS256",
  "RS384",
  "RS512",
  "PS256",
  "PS384",
  "PS512",
  "ES256",
  "ES384",
  "ES512"
];
jws$3.ALGORITHMS = ALGORITHMS;
jws$3.sign = SignStream.sign;
jws$3.verify = VerifyStream.verify;
jws$3.decode = VerifyStream.decode;
jws$3.isValid = VerifyStream.isValid;
jws$3.createSign = function a(u) {
  return new SignStream(u);
};
jws$3.createVerify = function a(u) {
  return new VerifyStream(u);
};
var jws$2 = jws$3, decode$1 = function(a, u) {
  u = u || {};
  var c = jws$2.decode(a, u);
  if (!c)
    return null;
  var l = c.payload;
  if (typeof l == "string")
    try {
      var v = JSON.parse(l);
      v !== null && typeof v == "object" && (l = v);
    } catch {
    }
  return u.complete === !0 ? {
    header: c.header,
    payload: l,
    signature: c.signature
  } : l;
}, JsonWebTokenError$3 = function(a, u) {
  Error.call(this, a), Error.captureStackTrace && Error.captureStackTrace(this, this.constructor), this.name = "JsonWebTokenError", this.message = a, u && (this.inner = u);
};
JsonWebTokenError$3.prototype = Object.create(Error.prototype);
JsonWebTokenError$3.prototype.constructor = JsonWebTokenError$3;
var JsonWebTokenError_1 = JsonWebTokenError$3, JsonWebTokenError$2 = JsonWebTokenError_1, NotBeforeError$1 = function(a, u) {
  JsonWebTokenError$2.call(this, a), this.name = "NotBeforeError", this.date = u;
};
NotBeforeError$1.prototype = Object.create(JsonWebTokenError$2.prototype);
NotBeforeError$1.prototype.constructor = NotBeforeError$1;
var NotBeforeError_1 = NotBeforeError$1, JsonWebTokenError$1 = JsonWebTokenError_1, TokenExpiredError$1 = function(a, u) {
  JsonWebTokenError$1.call(this, a), this.name = "TokenExpiredError", this.expiredAt = u;
};
TokenExpiredError$1.prototype = Object.create(JsonWebTokenError$1.prototype);
TokenExpiredError$1.prototype.constructor = TokenExpiredError$1;
var TokenExpiredError_1 = TokenExpiredError$1, s = 1e3, m$1 = s * 60, h = m$1 * 60, d = h * 24, w = d * 7, y = d * 365.25, ms$1 = function(a, u) {
  u = u || {};
  var c = typeof a;
  if (c === "string" && a.length > 0)
    return parse$1(a);
  if (c === "number" && isFinite(a))
    return u.long ? fmtLong(a) : fmtShort(a);
  throw new Error(
    "val is not a non-empty string or a valid number. val=" + JSON.stringify(a)
  );
};
function parse$1(a) {
  if (a = String(a), !(a.length > 100)) {
    var u = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      a
    );
    if (u) {
      var c = parseFloat(u[1]), l = (u[2] || "ms").toLowerCase();
      switch (l) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return c * y;
        case "weeks":
        case "week":
        case "w":
          return c * w;
        case "days":
        case "day":
        case "d":
          return c * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return c * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return c * m$1;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return c * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return c;
        default:
          return;
      }
    }
  }
}
function fmtShort(a) {
  var u = Math.abs(a);
  return u >= d ? Math.round(a / d) + "d" : u >= h ? Math.round(a / h) + "h" : u >= m$1 ? Math.round(a / m$1) + "m" : u >= s ? Math.round(a / s) + "s" : a + "ms";
}
function fmtLong(a) {
  var u = Math.abs(a);
  return u >= d ? plural(a, u, d, "day") : u >= h ? plural(a, u, h, "hour") : u >= m$1 ? plural(a, u, m$1, "minute") : u >= s ? plural(a, u, s, "second") : a + " ms";
}
function plural(a, u, c, l) {
  var v = u >= c * 1.5;
  return Math.round(a / c) + " " + l + (v ? "s" : "");
}
var ms = ms$1, timespan$2 = function(a, u) {
  var c = u || Math.floor(Date.now() / 1e3);
  if (typeof a == "string") {
    var l = ms(a);
    return typeof l > "u" ? void 0 : Math.floor(c + l / 1e3);
  } else
    return typeof a == "number" ? c + a : void 0;
}, semver$1 = { exports: {} };
(function(a, u) {
  u = a.exports = Fe;
  var c;
  typeof process$1 == "object" && process$1.env && process$1.env.NODE_DEBUG && /\bsemver\b/i.test(process$1.env.NODE_DEBUG) ? c = function() {
    var Ve = Array.prototype.slice.call(arguments, 0);
    Ve.unshift("SEMVER"), console.log.apply(console, Ve);
  } : c = function() {
  }, u.SEMVER_SPEC_VERSION = "2.0.0";
  var l = 256, v = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
  9007199254740991, p = 16, _ = u.re = [], k = u.src = [], O = 0, D = O++;
  k[D] = "0|[1-9]\\d*";
  var F = O++;
  k[F] = "[0-9]+";
  var H = O++;
  k[H] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
  var Z = O++;
  k[Z] = "(" + k[D] + ")\\.(" + k[D] + ")\\.(" + k[D] + ")";
  var ee = O++;
  k[ee] = "(" + k[F] + ")\\.(" + k[F] + ")\\.(" + k[F] + ")";
  var X = O++;
  k[X] = "(?:" + k[D] + "|" + k[H] + ")";
  var ne = O++;
  k[ne] = "(?:" + k[F] + "|" + k[H] + ")";
  var Q = O++;
  k[Q] = "(?:-(" + k[X] + "(?:\\." + k[X] + ")*))";
  var ae = O++;
  k[ae] = "(?:-?(" + k[ne] + "(?:\\." + k[ne] + ")*))";
  var j = O++;
  k[j] = "[0-9A-Za-z-]+";
  var ue = O++;
  k[ue] = "(?:\\+(" + k[j] + "(?:\\." + k[j] + ")*))";
  var he = O++, fe = "v?" + k[Z] + k[Q] + "?" + k[ue] + "?";
  k[he] = "^" + fe + "$";
  var be = "[v=\\s]*" + k[ee] + k[ae] + "?" + k[ue] + "?", ke = O++;
  k[ke] = "^" + be + "$";
  var Te = O++;
  k[Te] = "((?:<|>)?=?)";
  var q = O++;
  k[q] = k[F] + "|x|X|\\*";
  var z = O++;
  k[z] = k[D] + "|x|X|\\*";
  var P = O++;
  k[P] = "[v=\\s]*(" + k[z] + ")(?:\\.(" + k[z] + ")(?:\\.(" + k[z] + ")(?:" + k[Q] + ")?" + k[ue] + "?)?)?";
  var S = O++;
  k[S] = "[v=\\s]*(" + k[q] + ")(?:\\.(" + k[q] + ")(?:\\.(" + k[q] + ")(?:" + k[ae] + ")?" + k[ue] + "?)?)?";
  var E = O++;
  k[E] = "^" + k[Te] + "\\s*" + k[P] + "$";
  var I = O++;
  k[I] = "^" + k[Te] + "\\s*" + k[S] + "$";
  var M = O++;
  k[M] = "(?:^|[^\\d])(\\d{1," + p + "})(?:\\.(\\d{1," + p + "}))?(?:\\.(\\d{1," + p + "}))?(?:$|[^\\d])";
  var $ = O++;
  k[$] = "(?:~>?)";
  var U = O++;
  k[U] = "(\\s*)" + k[$] + "\\s+", _[U] = new RegExp(k[U], "g");
  var Y = "$1~", B = O++;
  k[B] = "^" + k[$] + k[P] + "$";
  var T = O++;
  k[T] = "^" + k[$] + k[S] + "$";
  var L = O++;
  k[L] = "(?:\\^)";
  var te = O++;
  k[te] = "(\\s*)" + k[L] + "\\s+", _[te] = new RegExp(k[te], "g");
  var me = "$1^", Ce = O++;
  k[Ce] = "^" + k[L] + k[P] + "$";
  var De = O++;
  k[De] = "^" + k[L] + k[S] + "$";
  var ye = O++;
  k[ye] = "^" + k[Te] + "\\s*(" + be + ")$|^$";
  var pe = O++;
  k[pe] = "^" + k[Te] + "\\s*(" + fe + ")$|^$";
  var Me = O++;
  k[Me] = "(\\s*)" + k[Te] + "\\s*(" + be + "|" + k[P] + ")", _[Me] = new RegExp(k[Me], "g");
  var Ne = "$1$2$3", Ue = O++;
  k[Ue] = "^\\s*(" + k[P] + ")\\s+-\\s+(" + k[P] + ")\\s*$";
  var oe = O++;
  k[oe] = "^\\s*(" + k[S] + ")\\s+-\\s+(" + k[S] + ")\\s*$";
  var A = O++;
  k[A] = "(<|>)?=?\\s*\\*";
  for (var re = 0; re < O; re++)
    c(re, k[re]), _[re] || (_[re] = new RegExp(k[re]));
  u.parse = le;
  function le(Ve, He) {
    if ((!He || typeof He != "object") && (He = {
      loose: !!He,
      includePrerelease: !1
    }), Ve instanceof Fe)
      return Ve;
    if (typeof Ve != "string" || Ve.length > l)
      return null;
    var Qe = He.loose ? _[ke] : _[he];
    if (!Qe.test(Ve))
      return null;
    try {
      return new Fe(Ve, He);
    } catch {
      return null;
    }
  }
  u.valid = $e;
  function $e(Ve, He) {
    var Qe = le(Ve, He);
    return Qe ? Qe.version : null;
  }
  u.clean = Oe;
  function Oe(Ve, He) {
    var Qe = le(Ve.trim().replace(/^[=v]+/, ""), He);
    return Qe ? Qe.version : null;
  }
  u.SemVer = Fe;
  function Fe(Ve, He) {
    if ((!He || typeof He != "object") && (He = {
      loose: !!He,
      includePrerelease: !1
    }), Ve instanceof Fe) {
      if (Ve.loose === He.loose)
        return Ve;
      Ve = Ve.version;
    } else if (typeof Ve != "string")
      throw new TypeError("Invalid Version: " + Ve);
    if (Ve.length > l)
      throw new TypeError("version is longer than " + l + " characters");
    if (!(this instanceof Fe))
      return new Fe(Ve, He);
    c("SemVer", Ve, He), this.options = He, this.loose = !!He.loose;
    var Qe = Ve.trim().match(He.loose ? _[ke] : _[he]);
    if (!Qe)
      throw new TypeError("Invalid Version: " + Ve);
    if (this.raw = Ve, this.major = +Qe[1], this.minor = +Qe[2], this.patch = +Qe[3], this.major > v || this.major < 0)
      throw new TypeError("Invalid major version");
    if (this.minor > v || this.minor < 0)
      throw new TypeError("Invalid minor version");
    if (this.patch > v || this.patch < 0)
      throw new TypeError("Invalid patch version");
    Qe[4] ? this.prerelease = Qe[4].split(".").map(function(pt) {
      if (/^[0-9]+$/.test(pt)) {
        var mt = +pt;
        if (mt >= 0 && mt < v)
          return mt;
      }
      return pt;
    }) : this.prerelease = [], this.build = Qe[5] ? Qe[5].split(".") : [], this.format();
  }
  Fe.prototype.format = function() {
    return this.version = this.major + "." + this.minor + "." + this.patch, this.prerelease.length && (this.version += "-" + this.prerelease.join(".")), this.version;
  }, Fe.prototype.toString = function() {
    return this.version;
  }, Fe.prototype.compare = function(Ve) {
    return c("SemVer.compare", this.version, this.options, Ve), Ve instanceof Fe || (Ve = new Fe(Ve, this.options)), this.compareMain(Ve) || this.comparePre(Ve);
  }, Fe.prototype.compareMain = function(Ve) {
    return Ve instanceof Fe || (Ve = new Fe(Ve, this.options)), Xe(this.major, Ve.major) || Xe(this.minor, Ve.minor) || Xe(this.patch, Ve.patch);
  }, Fe.prototype.comparePre = function(Ve) {
    if (Ve instanceof Fe || (Ve = new Fe(Ve, this.options)), this.prerelease.length && !Ve.prerelease.length)
      return -1;
    if (!this.prerelease.length && Ve.prerelease.length)
      return 1;
    if (!this.prerelease.length && !Ve.prerelease.length)
      return 0;
    var He = 0;
    do {
      var Qe = this.prerelease[He], pt = Ve.prerelease[He];
      if (c("prerelease compare", He, Qe, pt), Qe === void 0 && pt === void 0)
        return 0;
      if (pt === void 0)
        return 1;
      if (Qe === void 0)
        return -1;
      if (Qe === pt)
        continue;
      return Xe(Qe, pt);
    } while (++He);
  }, Fe.prototype.inc = function(Ve, He) {
    switch (Ve) {
      case "premajor":
        this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", He);
        break;
      case "preminor":
        this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", He);
        break;
      case "prepatch":
        this.prerelease.length = 0, this.inc("patch", He), this.inc("pre", He);
        break;
      case "prerelease":
        this.prerelease.length === 0 && this.inc("patch", He), this.inc("pre", He);
        break;
      case "major":
        (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
        break;
      case "minor":
        (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
        break;
      case "patch":
        this.prerelease.length === 0 && this.patch++, this.prerelease = [];
        break;
      case "pre":
        if (this.prerelease.length === 0)
          this.prerelease = [0];
        else {
          for (var Qe = this.prerelease.length; --Qe >= 0; )
            typeof this.prerelease[Qe] == "number" && (this.prerelease[Qe]++, Qe = -2);
          Qe === -1 && this.prerelease.push(0);
        }
        He && (this.prerelease[0] === He ? isNaN(this.prerelease[1]) && (this.prerelease = [He, 0]) : this.prerelease = [He, 0]);
        break;
      default:
        throw new Error("invalid increment argument: " + Ve);
    }
    return this.format(), this.raw = this.version, this;
  }, u.inc = Ze;
  function Ze(Ve, He, Qe, pt) {
    typeof Qe == "string" && (pt = Qe, Qe = void 0);
    try {
      return new Fe(Ve, Qe).inc(He, pt).version;
    } catch {
      return null;
    }
  }
  u.diff = qe;
  function qe(Ve, He) {
    if (Pe(Ve, He))
      return null;
    var Qe = le(Ve), pt = le(He), mt = "";
    if (Qe.prerelease.length || pt.prerelease.length) {
      mt = "pre";
      var vt = "prerelease";
    }
    for (var ht in Qe)
      if ((ht === "major" || ht === "minor" || ht === "patch") && Qe[ht] !== pt[ht])
        return mt + ht;
    return vt;
  }
  u.compareIdentifiers = Xe;
  var yt = /^[0-9]+$/;
  function Xe(Ve, He) {
    var Qe = yt.test(Ve), pt = yt.test(He);
    return Qe && pt && (Ve = +Ve, He = +He), Ve === He ? 0 : Qe && !pt ? -1 : pt && !Qe ? 1 : Ve < He ? -1 : 1;
  }
  u.rcompareIdentifiers = Ge;
  function Ge(Ve, He) {
    return Xe(He, Ve);
  }
  u.major = J;
  function J(Ve, He) {
    return new Fe(Ve, He).major;
  }
  u.minor = ge;
  function ge(Ve, He) {
    return new Fe(Ve, He).minor;
  }
  u.patch = we;
  function we(Ve, He) {
    return new Fe(Ve, He).patch;
  }
  u.compare = We;
  function We(Ve, He, Qe) {
    return new Fe(Ve, Qe).compare(new Fe(He, Qe));
  }
  u.compareLoose = Ie;
  function Ie(Ve, He) {
    return We(Ve, He, !0);
  }
  u.rcompare = V;
  function V(Ve, He, Qe) {
    return We(He, Ve, Qe);
  }
  u.sort = Ee;
  function Ee(Ve, He) {
    return Ve.sort(function(Qe, pt) {
      return u.compare(Qe, pt, He);
    });
  }
  u.rsort = de;
  function de(Ve, He) {
    return Ve.sort(function(Qe, pt) {
      return u.rcompare(Qe, pt, He);
    });
  }
  u.gt = ce;
  function ce(Ve, He, Qe) {
    return We(Ve, He, Qe) > 0;
  }
  u.lt = ve;
  function ve(Ve, He, Qe) {
    return We(Ve, He, Qe) < 0;
  }
  u.eq = Pe;
  function Pe(Ve, He, Qe) {
    return We(Ve, He, Qe) === 0;
  }
  u.neq = Be;
  function Be(Ve, He, Qe) {
    return We(Ve, He, Qe) !== 0;
  }
  u.gte = ze;
  function ze(Ve, He, Qe) {
    return We(Ve, He, Qe) >= 0;
  }
  u.lte = Je;
  function Je(Ve, He, Qe) {
    return We(Ve, He, Qe) <= 0;
  }
  u.cmp = je;
  function je(Ve, He, Qe, pt) {
    switch (He) {
      case "===":
        return typeof Ve == "object" && (Ve = Ve.version), typeof Qe == "object" && (Qe = Qe.version), Ve === Qe;
      case "!==":
        return typeof Ve == "object" && (Ve = Ve.version), typeof Qe == "object" && (Qe = Qe.version), Ve !== Qe;
      case "":
      case "=":
      case "==":
        return Pe(Ve, Qe, pt);
      case "!=":
        return Be(Ve, Qe, pt);
      case ">":
        return ce(Ve, Qe, pt);
      case ">=":
        return ze(Ve, Qe, pt);
      case "<":
        return ve(Ve, Qe, pt);
      case "<=":
        return Je(Ve, Qe, pt);
      default:
        throw new TypeError("Invalid operator: " + He);
    }
  }
  u.Comparator = Ke;
  function Ke(Ve, He) {
    if ((!He || typeof He != "object") && (He = {
      loose: !!He,
      includePrerelease: !1
    }), Ve instanceof Ke) {
      if (Ve.loose === !!He.loose)
        return Ve;
      Ve = Ve.value;
    }
    if (!(this instanceof Ke))
      return new Ke(Ve, He);
    c("comparator", Ve, He), this.options = He, this.loose = !!He.loose, this.parse(Ve), this.semver === x ? this.value = "" : this.value = this.operator + this.semver.version, c("comp", this);
  }
  var x = {};
  Ke.prototype.parse = function(Ve) {
    var He = this.options.loose ? _[ye] : _[pe], Qe = Ve.match(He);
    if (!Qe)
      throw new TypeError("Invalid comparator: " + Ve);
    this.operator = Qe[1], this.operator === "=" && (this.operator = ""), Qe[2] ? this.semver = new Fe(Qe[2], this.options.loose) : this.semver = x;
  }, Ke.prototype.toString = function() {
    return this.value;
  }, Ke.prototype.test = function(Ve) {
    return c("Comparator.test", Ve, this.options.loose), this.semver === x ? !0 : (typeof Ve == "string" && (Ve = new Fe(Ve, this.options)), je(Ve, this.operator, this.semver, this.options));
  }, Ke.prototype.intersects = function(Ve, He) {
    if (!(Ve instanceof Ke))
      throw new TypeError("a Comparator is required");
    (!He || typeof He != "object") && (He = {
      loose: !!He,
      includePrerelease: !1
    });
    var Qe;
    if (this.operator === "")
      return Qe = new se(Ve.value, He), wt(this.value, Qe, He);
    if (Ve.operator === "")
      return Qe = new se(this.value, He), wt(Ve.semver, Qe, He);
    var pt = (this.operator === ">=" || this.operator === ">") && (Ve.operator === ">=" || Ve.operator === ">"), mt = (this.operator === "<=" || this.operator === "<") && (Ve.operator === "<=" || Ve.operator === "<"), vt = this.semver.version === Ve.semver.version, ht = (this.operator === ">=" || this.operator === "<=") && (Ve.operator === ">=" || Ve.operator === "<="), Et = je(this.semver, "<", Ve.semver, He) && (this.operator === ">=" || this.operator === ">") && (Ve.operator === "<=" || Ve.operator === "<"), Tt = je(this.semver, ">", Ve.semver, He) && (this.operator === "<=" || this.operator === "<") && (Ve.operator === ">=" || Ve.operator === ">");
    return pt || mt || vt && ht || Et || Tt;
  }, u.Range = se;
  function se(Ve, He) {
    if ((!He || typeof He != "object") && (He = {
      loose: !!He,
      includePrerelease: !1
    }), Ve instanceof se)
      return Ve.loose === !!He.loose && Ve.includePrerelease === !!He.includePrerelease ? Ve : new se(Ve.raw, He);
    if (Ve instanceof Ke)
      return new se(Ve.value, He);
    if (!(this instanceof se))
      return new se(Ve, He);
    if (this.options = He, this.loose = !!He.loose, this.includePrerelease = !!He.includePrerelease, this.raw = Ve, this.set = Ve.split(/\s*\|\|\s*/).map(function(Qe) {
      return this.parseRange(Qe.trim());
    }, this).filter(function(Qe) {
      return Qe.length;
    }), !this.set.length)
      throw new TypeError("Invalid SemVer Range: " + Ve);
    this.format();
  }
  se.prototype.format = function() {
    return this.range = this.set.map(function(Ve) {
      return Ve.join(" ").trim();
    }).join("||").trim(), this.range;
  }, se.prototype.toString = function() {
    return this.range;
  }, se.prototype.parseRange = function(Ve) {
    var He = this.options.loose;
    Ve = Ve.trim();
    var Qe = He ? _[oe] : _[Ue];
    Ve = Ve.replace(Qe, rt), c("hyphen replace", Ve), Ve = Ve.replace(_[Me], Ne), c("comparator trim", Ve, _[Me]), Ve = Ve.replace(_[U], Y), Ve = Ve.replace(_[te], me), Ve = Ve.split(/\s+/).join(" ");
    var pt = He ? _[ye] : _[pe], mt = Ve.split(" ").map(function(vt) {
      return xe(vt, this.options);
    }, this).join(" ").split(/\s+/);
    return this.options.loose && (mt = mt.filter(function(vt) {
      return !!vt.match(pt);
    })), mt = mt.map(function(vt) {
      return new Ke(vt, this.options);
    }, this), mt;
  }, se.prototype.intersects = function(Ve, He) {
    if (!(Ve instanceof se))
      throw new TypeError("a Range is required");
    return this.set.some(function(Qe) {
      return Qe.every(function(pt) {
        return Ve.set.some(function(mt) {
          return mt.every(function(vt) {
            return pt.intersects(vt, He);
          });
        });
      });
    });
  }, u.toComparators = Se;
  function Se(Ve, He) {
    return new se(Ve, He).set.map(function(Qe) {
      return Qe.map(function(pt) {
        return pt.value;
      }).join(" ").trim().split(" ");
    });
  }
  function xe(Ve, He) {
    return c("comp", Ve, He), Ve = dt(Ve, He), c("caret", Ve), Ve = Ye(Ve, He), c("tildes", Ve), Ve = tt(Ve, He), c("xrange", Ve), Ve = kt(Ve, He), c("stars", Ve), Ve;
  }
  function Ae(Ve) {
    return !Ve || Ve.toLowerCase() === "x" || Ve === "*";
  }
  function Ye(Ve, He) {
    return Ve.trim().split(/\s+/).map(function(Qe) {
      return et(Qe, He);
    }).join(" ");
  }
  function et(Ve, He) {
    var Qe = He.loose ? _[T] : _[B];
    return Ve.replace(Qe, function(pt, mt, vt, ht, Et) {
      c("tilde", Ve, pt, mt, vt, ht, Et);
      var Tt;
      return Ae(mt) ? Tt = "" : Ae(vt) ? Tt = ">=" + mt + ".0.0 <" + (+mt + 1) + ".0.0" : Ae(ht) ? Tt = ">=" + mt + "." + vt + ".0 <" + mt + "." + (+vt + 1) + ".0" : Et ? (c("replaceTilde pr", Et), Tt = ">=" + mt + "." + vt + "." + ht + "-" + Et + " <" + mt + "." + (+vt + 1) + ".0") : Tt = ">=" + mt + "." + vt + "." + ht + " <" + mt + "." + (+vt + 1) + ".0", c("tilde return", Tt), Tt;
    });
  }
  function dt(Ve, He) {
    return Ve.trim().split(/\s+/).map(function(Qe) {
      return St(Qe, He);
    }).join(" ");
  }
  function St(Ve, He) {
    c("caret", Ve, He);
    var Qe = He.loose ? _[De] : _[Ce];
    return Ve.replace(Qe, function(pt, mt, vt, ht, Et) {
      c("caret", Ve, pt, mt, vt, ht, Et);
      var Tt;
      return Ae(mt) ? Tt = "" : Ae(vt) ? Tt = ">=" + mt + ".0.0 <" + (+mt + 1) + ".0.0" : Ae(ht) ? mt === "0" ? Tt = ">=" + mt + "." + vt + ".0 <" + mt + "." + (+vt + 1) + ".0" : Tt = ">=" + mt + "." + vt + ".0 <" + (+mt + 1) + ".0.0" : Et ? (c("replaceCaret pr", Et), mt === "0" ? vt === "0" ? Tt = ">=" + mt + "." + vt + "." + ht + "-" + Et + " <" + mt + "." + vt + "." + (+ht + 1) : Tt = ">=" + mt + "." + vt + "." + ht + "-" + Et + " <" + mt + "." + (+vt + 1) + ".0" : Tt = ">=" + mt + "." + vt + "." + ht + "-" + Et + " <" + (+mt + 1) + ".0.0") : (c("no pr"), mt === "0" ? vt === "0" ? Tt = ">=" + mt + "." + vt + "." + ht + " <" + mt + "." + vt + "." + (+ht + 1) : Tt = ">=" + mt + "." + vt + "." + ht + " <" + mt + "." + (+vt + 1) + ".0" : Tt = ">=" + mt + "." + vt + "." + ht + " <" + (+mt + 1) + ".0.0"), c("caret return", Tt), Tt;
    });
  }
  function tt(Ve, He) {
    return c("replaceXRanges", Ve, He), Ve.split(/\s+/).map(function(Qe) {
      return at(Qe, He);
    }).join(" ");
  }
  function at(Ve, He) {
    Ve = Ve.trim();
    var Qe = He.loose ? _[I] : _[E];
    return Ve.replace(Qe, function(pt, mt, vt, ht, Et, Tt) {
      c("xRange", Ve, pt, mt, vt, ht, Et, Tt);
      var Ot = Ae(vt), Nt = Ot || Ae(ht), At = Nt || Ae(Et), Mt = At;
      return mt === "=" && Mt && (mt = ""), Ot ? mt === ">" || mt === "<" ? pt = "<0.0.0" : pt = "*" : mt && Mt ? (Nt && (ht = 0), Et = 0, mt === ">" ? (mt = ">=", Nt ? (vt = +vt + 1, ht = 0, Et = 0) : (ht = +ht + 1, Et = 0)) : mt === "<=" && (mt = "<", Nt ? vt = +vt + 1 : ht = +ht + 1), pt = mt + vt + "." + ht + "." + Et) : Nt ? pt = ">=" + vt + ".0.0 <" + (+vt + 1) + ".0.0" : At && (pt = ">=" + vt + "." + ht + ".0 <" + vt + "." + (+ht + 1) + ".0"), c("xRange return", pt), pt;
    });
  }
  function kt(Ve, He) {
    return c("replaceStars", Ve, He), Ve.trim().replace(_[A], "");
  }
  function rt(Ve, He, Qe, pt, mt, vt, ht, Et, Tt, Ot, Nt, At, Mt) {
    return Ae(Qe) ? He = "" : Ae(pt) ? He = ">=" + Qe + ".0.0" : Ae(mt) ? He = ">=" + Qe + "." + pt + ".0" : He = ">=" + He, Ae(Tt) ? Et = "" : Ae(Ot) ? Et = "<" + (+Tt + 1) + ".0.0" : Ae(Nt) ? Et = "<" + Tt + "." + (+Ot + 1) + ".0" : At ? Et = "<=" + Tt + "." + Ot + "." + Nt + "-" + At : Et = "<=" + Et, (He + " " + Et).trim();
  }
  se.prototype.test = function(Ve) {
    if (!Ve)
      return !1;
    typeof Ve == "string" && (Ve = new Fe(Ve, this.options));
    for (var He = 0; He < this.set.length; He++)
      if (ut(this.set[He], Ve, this.options))
        return !0;
    return !1;
  };
  function ut(Ve, He, Qe) {
    for (var pt = 0; pt < Ve.length; pt++)
      if (!Ve[pt].test(He))
        return !1;
    if (He.prerelease.length && !Qe.includePrerelease) {
      for (pt = 0; pt < Ve.length; pt++)
        if (c(Ve[pt].semver), Ve[pt].semver !== x && Ve[pt].semver.prerelease.length > 0) {
          var mt = Ve[pt].semver;
          if (mt.major === He.major && mt.minor === He.minor && mt.patch === He.patch)
            return !0;
        }
      return !1;
    }
    return !0;
  }
  u.satisfies = wt;
  function wt(Ve, He, Qe) {
    try {
      He = new se(He, Qe);
    } catch {
      return !1;
    }
    return He.test(Ve);
  }
  u.maxSatisfying = nt;
  function nt(Ve, He, Qe) {
    var pt = null, mt = null;
    try {
      var vt = new se(He, Qe);
    } catch {
      return null;
    }
    return Ve.forEach(function(ht) {
      vt.test(ht) && (!pt || mt.compare(ht) === -1) && (pt = ht, mt = new Fe(pt, Qe));
    }), pt;
  }
  u.minSatisfying = it;
  function it(Ve, He, Qe) {
    var pt = null, mt = null;
    try {
      var vt = new se(He, Qe);
    } catch {
      return null;
    }
    return Ve.forEach(function(ht) {
      vt.test(ht) && (!pt || mt.compare(ht) === 1) && (pt = ht, mt = new Fe(pt, Qe));
    }), pt;
  }
  u.minVersion = bt;
  function bt(Ve, He) {
    Ve = new se(Ve, He);
    var Qe = new Fe("0.0.0");
    if (Ve.test(Qe) || (Qe = new Fe("0.0.0-0"), Ve.test(Qe)))
      return Qe;
    Qe = null;
    for (var pt = 0; pt < Ve.set.length; ++pt) {
      var mt = Ve.set[pt];
      mt.forEach(function(vt) {
        var ht = new Fe(vt.semver.version);
        switch (vt.operator) {
          case ">":
            ht.prerelease.length === 0 ? ht.patch++ : ht.prerelease.push(0), ht.raw = ht.format();
          case "":
          case ">=":
            (!Qe || ce(Qe, ht)) && (Qe = ht);
            break;
          case "<":
          case "<=":
            break;
          default:
            throw new Error("Unexpected operation: " + vt.operator);
        }
      });
    }
    return Qe && Ve.test(Qe) ? Qe : null;
  }
  u.validRange = ot;
  function ot(Ve, He) {
    try {
      return new se(Ve, He).range || "*";
    } catch {
      return null;
    }
  }
  u.ltr = ct;
  function ct(Ve, He, Qe) {
    return st(Ve, He, "<", Qe);
  }
  u.gtr = Pt;
  function Pt(Ve, He, Qe) {
    return st(Ve, He, ">", Qe);
  }
  u.outside = st;
  function st(Ve, He, Qe, pt) {
    Ve = new Fe(Ve, pt), He = new se(He, pt);
    var mt, vt, ht, Et, Tt;
    switch (Qe) {
      case ">":
        mt = ce, vt = Je, ht = ve, Et = ">", Tt = ">=";
        break;
      case "<":
        mt = ve, vt = ze, ht = ce, Et = "<", Tt = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (wt(Ve, He, pt))
      return !1;
    for (var Ot = 0; Ot < He.set.length; ++Ot) {
      var Nt = He.set[Ot], At = null, Mt = null;
      if (Nt.forEach(function($t) {
        $t.semver === x && ($t = new Ke(">=0.0.0")), At = At || $t, Mt = Mt || $t, mt($t.semver, At.semver, pt) ? At = $t : ht($t.semver, Mt.semver, pt) && (Mt = $t);
      }), At.operator === Et || At.operator === Tt || (!Mt.operator || Mt.operator === Et) && vt(Ve, Mt.semver))
        return !1;
      if (Mt.operator === Tt && ht(Ve, Mt.semver))
        return !1;
    }
    return !0;
  }
  u.prerelease = lt;
  function lt(Ve, He) {
    var Qe = le(Ve, He);
    return Qe && Qe.prerelease.length ? Qe.prerelease : null;
  }
  u.intersects = It;
  function It(Ve, He, Qe) {
    return Ve = new se(Ve, Qe), He = new se(He, Qe), Ve.intersects(He);
  }
  u.coerce = Rt;
  function Rt(Ve) {
    if (Ve instanceof Fe)
      return Ve;
    if (typeof Ve != "string")
      return null;
    var He = Ve.match(_[M]);
    return He == null ? null : le(He[1] + "." + (He[2] || "0") + "." + (He[3] || "0"));
  }
})(semver$1, semver$1.exports);
var semverExports = semver$1.exports, semver = semverExports, psSupported = semver.satisfies(process$1.version, "^6.12.0 || >=8.0.0"), JsonWebTokenError = JsonWebTokenError_1, NotBeforeError = NotBeforeError_1, TokenExpiredError = TokenExpiredError_1, decode = decode$1, timespan$1 = timespan$2, PS_SUPPORTED$1 = psSupported, jws$1 = jws$3, PUB_KEY_ALGS = ["RS256", "RS384", "RS512", "ES256", "ES384", "ES512"], RSA_KEY_ALGS = ["RS256", "RS384", "RS512"], HS_ALGS = ["HS256", "HS384", "HS512"];
PS_SUPPORTED$1 && (PUB_KEY_ALGS.splice(3, 0, "PS256", "PS384", "PS512"), RSA_KEY_ALGS.splice(3, 0, "PS256", "PS384", "PS512"));
var verify = function(a, u, c, l) {
  typeof c == "function" && !l && (l = c, c = {}), c || (c = {}), c = Object.assign({}, c);
  var v;
  if (l ? v = l : v = function(F, H) {
    if (F)
      throw F;
    return H;
  }, c.clockTimestamp && typeof c.clockTimestamp != "number")
    return v(new JsonWebTokenError("clockTimestamp must be a number"));
  if (c.nonce !== void 0 && (typeof c.nonce != "string" || c.nonce.trim() === ""))
    return v(new JsonWebTokenError("nonce must be a non-empty string"));
  var p = c.clockTimestamp || Math.floor(Date.now() / 1e3);
  if (!a)
    return v(new JsonWebTokenError("jwt must be provided"));
  if (typeof a != "string")
    return v(new JsonWebTokenError("jwt must be a string"));
  var _ = a.split(".");
  if (_.length !== 3)
    return v(new JsonWebTokenError("jwt malformed"));
  var k;
  try {
    k = decode(a, { complete: !0 });
  } catch (F) {
    return v(F);
  }
  if (!k)
    return v(new JsonWebTokenError("invalid token"));
  var O = k.header, D;
  if (typeof u == "function") {
    if (!l)
      return v(new JsonWebTokenError("verify must be called asynchronous if secret or public key is provided as a callback"));
    D = u;
  } else
    D = function(F, H) {
      return H(null, u);
    };
  return D(O, function(F, H) {
    if (F)
      return v(new JsonWebTokenError("error in secret or public key callback: " + F.message));
    var Z = _[2].trim() !== "";
    if (!Z && H)
      return v(new JsonWebTokenError("jwt signature is required"));
    if (Z && !H)
      return v(new JsonWebTokenError("secret or public key must be provided"));
    if (!Z && !c.algorithms && (c.algorithms = ["none"]), c.algorithms || (c.algorithms = ~H.toString().indexOf("BEGIN CERTIFICATE") || ~H.toString().indexOf("BEGIN PUBLIC KEY") ? PUB_KEY_ALGS : ~H.toString().indexOf("BEGIN RSA PUBLIC KEY") ? RSA_KEY_ALGS : HS_ALGS), !~c.algorithms.indexOf(k.header.alg))
      return v(new JsonWebTokenError("invalid algorithm"));
    var ee;
    try {
      ee = jws$1.verify(a, k.header.alg, H);
    } catch (fe) {
      return v(fe);
    }
    if (!ee)
      return v(new JsonWebTokenError("invalid signature"));
    var X = k.payload;
    if (typeof X.nbf < "u" && !c.ignoreNotBefore) {
      if (typeof X.nbf != "number")
        return v(new JsonWebTokenError("invalid nbf value"));
      if (X.nbf > p + (c.clockTolerance || 0))
        return v(new NotBeforeError("jwt not active", new Date(X.nbf * 1e3)));
    }
    if (typeof X.exp < "u" && !c.ignoreExpiration) {
      if (typeof X.exp != "number")
        return v(new JsonWebTokenError("invalid exp value"));
      if (p >= X.exp + (c.clockTolerance || 0))
        return v(new TokenExpiredError("jwt expired", new Date(X.exp * 1e3)));
    }
    if (c.audience) {
      var ne = Array.isArray(c.audience) ? c.audience : [c.audience], Q = Array.isArray(X.aud) ? X.aud : [X.aud], ae = Q.some(function(fe) {
        return ne.some(function(be) {
          return be instanceof RegExp ? be.test(fe) : be === fe;
        });
      });
      if (!ae)
        return v(new JsonWebTokenError("jwt audience invalid. expected: " + ne.join(" or ")));
    }
    if (c.issuer) {
      var j = typeof c.issuer == "string" && X.iss !== c.issuer || Array.isArray(c.issuer) && c.issuer.indexOf(X.iss) === -1;
      if (j)
        return v(new JsonWebTokenError("jwt issuer invalid. expected: " + c.issuer));
    }
    if (c.subject && X.sub !== c.subject)
      return v(new JsonWebTokenError("jwt subject invalid. expected: " + c.subject));
    if (c.jwtid && X.jti !== c.jwtid)
      return v(new JsonWebTokenError("jwt jwtid invalid. expected: " + c.jwtid));
    if (c.nonce && X.nonce !== c.nonce)
      return v(new JsonWebTokenError("jwt nonce invalid. expected: " + c.nonce));
    if (c.maxAge) {
      if (typeof X.iat != "number")
        return v(new JsonWebTokenError("iat required when maxAge is specified"));
      var ue = timespan$1(c.maxAge, X.iat);
      if (typeof ue > "u")
        return v(new JsonWebTokenError('"maxAge" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
      if (p >= ue + (c.clockTolerance || 0))
        return v(new TokenExpiredError("maxAge exceeded", new Date(ue * 1e3)));
    }
    if (c.complete === !0) {
      var he = k.signature;
      return v(null, {
        header: O,
        payload: X,
        signature: he
      });
    }
    return v(null, X);
  });
}, INFINITY$2 = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER$2 = 17976931348623157e292, NAN$2 = NaN, argsTag = "[object Arguments]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", stringTag$1 = "[object String]", symbolTag$2 = "[object Symbol]", reTrim$2 = /^\s+|\s+$/g, reIsBadHex$2 = /^[-+]0x[0-9a-f]+$/i, reIsBinary$2 = /^0b[01]+$/i, reIsOctal$2 = /^0o[0-7]+$/i, reIsUint = /^(?:0|[1-9]\d*)$/, freeParseInt$2 = parseInt;
function arrayMap(a, u) {
  for (var c = -1, l = a ? a.length : 0, v = Array(l); ++c < l; )
    v[c] = u(a[c], c, a);
  return v;
}
function baseFindIndex(a, u, c, l) {
  for (var v = a.length, p = c + (l ? 1 : -1); l ? p-- : ++p < v; )
    if (u(a[p], p, a))
      return p;
  return -1;
}
function baseIndexOf(a, u, c) {
  if (u !== u)
    return baseFindIndex(a, baseIsNaN, c);
  for (var l = c - 1, v = a.length; ++l < v; )
    if (a[l] === u)
      return l;
  return -1;
}
function baseIsNaN(a) {
  return a !== a;
}
function baseTimes(a, u) {
  for (var c = -1, l = Array(a); ++c < a; )
    l[c] = u(c);
  return l;
}
function baseValues(a, u) {
  return arrayMap(u, function(c) {
    return a[c];
  });
}
function overArg$1(a, u) {
  return function(c) {
    return a(u(c));
  };
}
var objectProto$6 = Object.prototype, hasOwnProperty$1 = objectProto$6.hasOwnProperty, objectToString$6 = objectProto$6.toString, propertyIsEnumerable = objectProto$6.propertyIsEnumerable, nativeKeys = overArg$1(Object.keys, Object), nativeMax = Math.max;
function arrayLikeKeys(a, u) {
  var c = isArray$3(a) || isArguments(a) ? baseTimes(a.length, String) : [], l = c.length, v = !!l;
  for (var p in a)
    (u || hasOwnProperty$1.call(a, p)) && !(v && (p == "length" || isIndex(p, l))) && c.push(p);
  return c;
}
function baseKeys(a) {
  if (!isPrototype(a))
    return nativeKeys(a);
  var u = [];
  for (var c in Object(a))
    hasOwnProperty$1.call(a, c) && c != "constructor" && u.push(c);
  return u;
}
function isIndex(a, u) {
  return u = u ?? MAX_SAFE_INTEGER, !!u && (typeof a == "number" || reIsUint.test(a)) && a > -1 && a % 1 == 0 && a < u;
}
function isPrototype(a) {
  var u = a && a.constructor, c = typeof u == "function" && u.prototype || objectProto$6;
  return a === c;
}
function includes$1(a, u, c, l) {
  a = isArrayLike(a) ? a : values(a), c = c && !l ? toInteger$2(c) : 0;
  var v = a.length;
  return c < 0 && (c = nativeMax(v + c, 0)), isString$3(a) ? c <= v && a.indexOf(u, c) > -1 : !!v && baseIndexOf(a, u, c) > -1;
}
function isArguments(a) {
  return isArrayLikeObject(a) && hasOwnProperty$1.call(a, "callee") && (!propertyIsEnumerable.call(a, "callee") || objectToString$6.call(a) == argsTag);
}
var isArray$3 = Array.isArray;
function isArrayLike(a) {
  return a != null && isLength(a.length) && !isFunction$1(a);
}
function isArrayLikeObject(a) {
  return isObjectLike$6(a) && isArrayLike(a);
}
function isFunction$1(a) {
  var u = isObject$5(a) ? objectToString$6.call(a) : "";
  return u == funcTag || u == genTag;
}
function isLength(a) {
  return typeof a == "number" && a > -1 && a % 1 == 0 && a <= MAX_SAFE_INTEGER;
}
function isObject$5(a) {
  var u = typeof a;
  return !!a && (u == "object" || u == "function");
}
function isObjectLike$6(a) {
  return !!a && typeof a == "object";
}
function isString$3(a) {
  return typeof a == "string" || !isArray$3(a) && isObjectLike$6(a) && objectToString$6.call(a) == stringTag$1;
}
function isSymbol$2(a) {
  return typeof a == "symbol" || isObjectLike$6(a) && objectToString$6.call(a) == symbolTag$2;
}
function toFinite$2(a) {
  if (!a)
    return a === 0 ? a : 0;
  if (a = toNumber$2(a), a === INFINITY$2 || a === -INFINITY$2) {
    var u = a < 0 ? -1 : 1;
    return u * MAX_INTEGER$2;
  }
  return a === a ? a : 0;
}
function toInteger$2(a) {
  var u = toFinite$2(a), c = u % 1;
  return u === u ? c ? u - c : u : 0;
}
function toNumber$2(a) {
  if (typeof a == "number")
    return a;
  if (isSymbol$2(a))
    return NAN$2;
  if (isObject$5(a)) {
    var u = typeof a.valueOf == "function" ? a.valueOf() : a;
    a = isObject$5(u) ? u + "" : u;
  }
  if (typeof a != "string")
    return a === 0 ? a : +a;
  a = a.replace(reTrim$2, "");
  var c = reIsBinary$2.test(a);
  return c || reIsOctal$2.test(a) ? freeParseInt$2(a.slice(2), c ? 2 : 8) : reIsBadHex$2.test(a) ? NAN$2 : +a;
}
function keys$1(a) {
  return isArrayLike(a) ? arrayLikeKeys(a) : baseKeys(a);
}
function values(a) {
  return a ? baseValues(a, keys$1(a)) : [];
}
var lodash_includes = includes$1, boolTag = "[object Boolean]", objectProto$5 = Object.prototype, objectToString$5 = objectProto$5.toString;
function isBoolean$1(a) {
  return a === !0 || a === !1 || isObjectLike$5(a) && objectToString$5.call(a) == boolTag;
}
function isObjectLike$5(a) {
  return !!a && typeof a == "object";
}
var lodash_isboolean = isBoolean$1, INFINITY$1 = 1 / 0, MAX_INTEGER$1 = 17976931348623157e292, NAN$1 = NaN, symbolTag$1 = "[object Symbol]", reTrim$1 = /^\s+|\s+$/g, reIsBadHex$1 = /^[-+]0x[0-9a-f]+$/i, reIsBinary$1 = /^0b[01]+$/i, reIsOctal$1 = /^0o[0-7]+$/i, freeParseInt$1 = parseInt, objectProto$4 = Object.prototype, objectToString$4 = objectProto$4.toString;
function isInteger$1(a) {
  return typeof a == "number" && a == toInteger$1(a);
}
function isObject$4(a) {
  var u = typeof a;
  return !!a && (u == "object" || u == "function");
}
function isObjectLike$4(a) {
  return !!a && typeof a == "object";
}
function isSymbol$1(a) {
  return typeof a == "symbol" || isObjectLike$4(a) && objectToString$4.call(a) == symbolTag$1;
}
function toFinite$1(a) {
  if (!a)
    return a === 0 ? a : 0;
  if (a = toNumber$1(a), a === INFINITY$1 || a === -INFINITY$1) {
    var u = a < 0 ? -1 : 1;
    return u * MAX_INTEGER$1;
  }
  return a === a ? a : 0;
}
function toInteger$1(a) {
  var u = toFinite$1(a), c = u % 1;
  return u === u ? c ? u - c : u : 0;
}
function toNumber$1(a) {
  if (typeof a == "number")
    return a;
  if (isSymbol$1(a))
    return NAN$1;
  if (isObject$4(a)) {
    var u = typeof a.valueOf == "function" ? a.valueOf() : a;
    a = isObject$4(u) ? u + "" : u;
  }
  if (typeof a != "string")
    return a === 0 ? a : +a;
  a = a.replace(reTrim$1, "");
  var c = reIsBinary$1.test(a);
  return c || reIsOctal$1.test(a) ? freeParseInt$1(a.slice(2), c ? 2 : 8) : reIsBadHex$1.test(a) ? NAN$1 : +a;
}
var lodash_isinteger = isInteger$1, numberTag = "[object Number]", objectProto$3 = Object.prototype, objectToString$3 = objectProto$3.toString;
function isObjectLike$3(a) {
  return !!a && typeof a == "object";
}
function isNumber$2(a) {
  return typeof a == "number" || isObjectLike$3(a) && objectToString$3.call(a) == numberTag;
}
var lodash_isnumber = isNumber$2, objectTag = "[object Object]";
function isHostObject(a) {
  var u = !1;
  if (a != null && typeof a.toString != "function")
    try {
      u = !!(a + "");
    } catch {
    }
  return u;
}
function overArg(a, u) {
  return function(c) {
    return a(u(c));
  };
}
var funcProto = Function.prototype, objectProto$2 = Object.prototype, funcToString = funcProto.toString, hasOwnProperty = objectProto$2.hasOwnProperty, objectCtorString = funcToString.call(Object), objectToString$2 = objectProto$2.toString, getPrototype = overArg(Object.getPrototypeOf, Object);
function isObjectLike$2(a) {
  return !!a && typeof a == "object";
}
function isPlainObject$2(a) {
  if (!isObjectLike$2(a) || objectToString$2.call(a) != objectTag || isHostObject(a))
    return !1;
  var u = getPrototype(a);
  if (u === null)
    return !0;
  var c = hasOwnProperty.call(u, "constructor") && u.constructor;
  return typeof c == "function" && c instanceof c && funcToString.call(c) == objectCtorString;
}
var lodash_isplainobject = isPlainObject$2, stringTag = "[object String]", objectProto$1 = Object.prototype, objectToString$1 = objectProto$1.toString, isArray$2 = Array.isArray;
function isObjectLike$1(a) {
  return !!a && typeof a == "object";
}
function isString$2(a) {
  return typeof a == "string" || !isArray$2(a) && isObjectLike$1(a) && objectToString$1.call(a) == stringTag;
}
var lodash_isstring = isString$2, FUNC_ERROR_TEXT = "Expected a function", INFINITY = 1 / 0, MAX_INTEGER = 17976931348623157e292, NAN = NaN, symbolTag = "[object Symbol]", reTrim = /^\s+|\s+$/g, reIsBadHex = /^[-+]0x[0-9a-f]+$/i, reIsBinary = /^0b[01]+$/i, reIsOctal = /^0o[0-7]+$/i, freeParseInt = parseInt, objectProto = Object.prototype, objectToString = objectProto.toString;
function before(a, u) {
  var c;
  if (typeof u != "function")
    throw new TypeError(FUNC_ERROR_TEXT);
  return a = toInteger(a), function() {
    return --a > 0 && (c = u.apply(this, arguments)), a <= 1 && (u = void 0), c;
  };
}
function once$1(a) {
  return before(2, a);
}
function isObject$3(a) {
  var u = typeof a;
  return !!a && (u == "object" || u == "function");
}
function isObjectLike(a) {
  return !!a && typeof a == "object";
}
function isSymbol(a) {
  return typeof a == "symbol" || isObjectLike(a) && objectToString.call(a) == symbolTag;
}
function toFinite(a) {
  if (!a)
    return a === 0 ? a : 0;
  if (a = toNumber(a), a === INFINITY || a === -INFINITY) {
    var u = a < 0 ? -1 : 1;
    return u * MAX_INTEGER;
  }
  return a === a ? a : 0;
}
function toInteger(a) {
  var u = toFinite(a), c = u % 1;
  return u === u ? c ? u - c : u : 0;
}
function toNumber(a) {
  if (typeof a == "number")
    return a;
  if (isSymbol(a))
    return NAN;
  if (isObject$3(a)) {
    var u = typeof a.valueOf == "function" ? a.valueOf() : a;
    a = isObject$3(u) ? u + "" : u;
  }
  if (typeof a != "string")
    return a === 0 ? a : +a;
  a = a.replace(reTrim, "");
  var c = reIsBinary.test(a);
  return c || reIsOctal.test(a) ? freeParseInt(a.slice(2), c ? 2 : 8) : reIsBadHex.test(a) ? NAN : +a;
}
var lodash_once = once$1, timespan = timespan$2, PS_SUPPORTED = psSupported, jws = jws$3, includes = lodash_includes, isBoolean = lodash_isboolean, isInteger = lodash_isinteger, isNumber$1 = lodash_isnumber, isPlainObject$1 = lodash_isplainobject, isString$1 = lodash_isstring, once = lodash_once, SUPPORTED_ALGS = ["RS256", "RS384", "RS512", "ES256", "ES384", "ES512", "HS256", "HS384", "HS512", "none"];
PS_SUPPORTED && SUPPORTED_ALGS.splice(3, 0, "PS256", "PS384", "PS512");
var sign_options_schema = {
  expiresIn: { isValid: function(a) {
    return isInteger(a) || isString$1(a) && a;
  }, message: '"expiresIn" should be a number of seconds or string representing a timespan' },
  notBefore: { isValid: function(a) {
    return isInteger(a) || isString$1(a) && a;
  }, message: '"notBefore" should be a number of seconds or string representing a timespan' },
  audience: { isValid: function(a) {
    return isString$1(a) || Array.isArray(a);
  }, message: '"audience" must be a string or array' },
  algorithm: { isValid: includes.bind(null, SUPPORTED_ALGS), message: '"algorithm" must be a valid string enum value' },
  header: { isValid: isPlainObject$1, message: '"header" must be an object' },
  encoding: { isValid: isString$1, message: '"encoding" must be a string' },
  issuer: { isValid: isString$1, message: '"issuer" must be a string' },
  subject: { isValid: isString$1, message: '"subject" must be a string' },
  jwtid: { isValid: isString$1, message: '"jwtid" must be a string' },
  noTimestamp: { isValid: isBoolean, message: '"noTimestamp" must be a boolean' },
  keyid: { isValid: isString$1, message: '"keyid" must be a string' },
  mutatePayload: { isValid: isBoolean, message: '"mutatePayload" must be a boolean' }
}, registered_claims_schema = {
  iat: { isValid: isNumber$1, message: '"iat" should be a number of seconds' },
  exp: { isValid: isNumber$1, message: '"exp" should be a number of seconds' },
  nbf: { isValid: isNumber$1, message: '"nbf" should be a number of seconds' }
};
function validate(a, u, c, l) {
  if (!isPlainObject$1(c))
    throw new Error('Expected "' + l + '" to be a plain object.');
  Object.keys(c).forEach(function(v) {
    var p = a[v];
    if (!p) {
      if (!u)
        throw new Error('"' + v + '" is not allowed in "' + l + '"');
      return;
    }
    if (!p.isValid(c[v]))
      throw new Error(p.message);
  });
}
function validateOptions(a) {
  return validate(sign_options_schema, !1, a, "options");
}
function validatePayload(a) {
  return validate(registered_claims_schema, !0, a, "payload");
}
var options_to_payload = {
  audience: "aud",
  issuer: "iss",
  subject: "sub",
  jwtid: "jti"
}, options_for_objects = [
  "expiresIn",
  "notBefore",
  "noTimestamp",
  "audience",
  "issuer",
  "subject",
  "jwtid"
], sign = function(a, u, c, l) {
  typeof c == "function" ? (l = c, c = {}) : c = c || {};
  var v = typeof a == "object" && !Buffer$O.isBuffer(a), p = Object.assign({
    alg: c.algorithm || "HS256",
    typ: v ? "JWT" : void 0,
    kid: c.keyid
  }, c.header);
  function _(F) {
    if (l)
      return l(F);
    throw F;
  }
  if (!u && c.algorithm !== "none")
    return _(new Error("secretOrPrivateKey must have a value"));
  if (typeof a > "u")
    return _(new Error("payload is required"));
  if (v) {
    try {
      validatePayload(a);
    } catch (F) {
      return _(F);
    }
    c.mutatePayload || (a = Object.assign({}, a));
  } else {
    var k = options_for_objects.filter(function(F) {
      return typeof c[F] < "u";
    });
    if (k.length > 0)
      return _(new Error("invalid " + k.join(",") + " option for " + typeof a + " payload"));
  }
  if (typeof a.exp < "u" && typeof c.expiresIn < "u")
    return _(new Error('Bad "options.expiresIn" option the payload already has an "exp" property.'));
  if (typeof a.nbf < "u" && typeof c.notBefore < "u")
    return _(new Error('Bad "options.notBefore" option the payload already has an "nbf" property.'));
  try {
    validateOptions(c);
  } catch (F) {
    return _(F);
  }
  var O = a.iat || Math.floor(Date.now() / 1e3);
  if (c.noTimestamp ? delete a.iat : v && (a.iat = O), typeof c.notBefore < "u") {
    try {
      a.nbf = timespan(c.notBefore, O);
    } catch (F) {
      return _(F);
    }
    if (typeof a.nbf > "u")
      return _(new Error('"notBefore" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
  }
  if (typeof c.expiresIn < "u" && typeof a == "object") {
    try {
      a.exp = timespan(c.expiresIn, O);
    } catch (F) {
      return _(F);
    }
    if (typeof a.exp > "u")
      return _(new Error('"expiresIn" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
  }
  Object.keys(options_to_payload).forEach(function(F) {
    var H = options_to_payload[F];
    if (typeof c[F] < "u") {
      if (typeof a[H] < "u")
        return _(new Error('Bad "options.' + F + '" option. The payload already has an "' + H + '" property.'));
      a[H] = c[F];
    }
  });
  var D = c.encoding || "utf8";
  if (typeof l == "function")
    l = l && once(l), jws.createSign({
      header: p,
      privateKey: u,
      payload: a,
      encoding: D
    }).once("error", l).once("done", function(F) {
      l(null, F);
    });
  else
    return jws.sign({ header: p, payload: a, secret: u, encoding: D });
}, jsonwebtoken = {
  decode: decode$1,
  verify,
  sign,
  JsonWebTokenError: JsonWebTokenError_1,
  NotBeforeError: NotBeforeError_1,
  TokenExpiredError: TokenExpiredError_1
}, __createBinding = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(a, u, c, l) {
  l === void 0 && (l = c), Object.defineProperty(a, l, { enumerable: !0, get: function() {
    return u[c];
  } });
} : function(a, u, c, l) {
  l === void 0 && (l = c), a[l] = u[c];
}), __setModuleDefault = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(a, u) {
  Object.defineProperty(a, "default", { enumerable: !0, value: u });
} : function(a, u) {
  a.default = u;
}), __importStar = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(a) {
  if (a && a.__esModule)
    return a;
  var u = {};
  if (a != null)
    for (var c in a)
      c !== "default" && Object.prototype.hasOwnProperty.call(a, c) && __createBinding(u, a, c);
  return __setModuleDefault(u, a), u;
};
Object.defineProperty(AccessToken$1, "__esModule", { value: !0 });
AccessToken$1.TokenVerifier = AccessToken$1.AccessToken = void 0;
const jwt = __importStar(jsonwebtoken), defaultTTL = 6 * 60 * 60;
class AccessToken {
  /**
   * Creates a new AccessToken
   * @param apiKey API Key, can be set in env LIVEKIT_API_KEY
   * @param apiSecret Secret, can be set in env LIVEKIT_API_SECRET
   */
  constructor(u, c, l) {
    if (u || (u = process$1.env.LIVEKIT_API_KEY), c || (c = process$1.env.LIVEKIT_API_SECRET), !u || !c)
      throw Error("api-key and api-secret must be set");
    this.apiKey = u, this.apiSecret = c, this.grants = {}, this.identity = l == null ? void 0 : l.identity, this.ttl = (l == null ? void 0 : l.ttl) || defaultTTL, l != null && l.metadata && (this.metadata = l.metadata), l != null && l.name && (this.name = l.name);
  }
  /**
   * Adds a video grant to this token.
   * @param grant
   */
  addGrant(u) {
    this.grants.video = u;
  }
  /**
   * Set metadata to be passed to the Participant, used only when joining the room
   */
  set metadata(u) {
    this.grants.metadata = u;
  }
  set name(u) {
    this.grants.name = u;
  }
  get sha256() {
    return this.grants.sha256;
  }
  set sha256(u) {
    this.grants.sha256 = u;
  }
  /**
   * @returns JWT encoded token
   */
  toJwt() {
    var u;
    const c = {
      issuer: this.apiKey,
      expiresIn: this.ttl,
      notBefore: 0
    };
    if (this.identity)
      c.subject = this.identity, c.jwtid = this.identity;
    else if (!((u = this.grants.video) === null || u === void 0) && u.roomJoin)
      throw Error("identity is required for join but not set");
    return jwt.sign(this.grants, this.apiSecret, c);
  }
}
AccessToken$1.AccessToken = AccessToken;
class TokenVerifier {
  constructor(u, c) {
    this.apiKey = u, this.apiSecret = c;
  }
  verify(u) {
    const c = jwt.verify(u, this.apiSecret, { issuer: this.apiKey });
    if (!c)
      throw Error("invalid token");
    return c;
  }
}
AccessToken$1.TokenVerifier = TokenVerifier;
var EgressClient$1 = {}, livekit_egress = {};
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(J) {
    return J && J.__esModule ? J : { default: J };
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.AutoTrackEgress = a.SegmentsInfo = a.FileInfo = a.StreamInfo = a.StreamInfoList = a.EgressInfo = a.StopEgressRequest = a.ListEgressResponse = a.ListEgressRequest = a.UpdateStreamRequest = a.UpdateLayoutRequest = a.EncodingOptions = a.StreamOutput = a.AliOSSUpload = a.AzureBlobUpload = a.GCPUpload = a.S3Upload_MetadataEntry = a.S3Upload = a.DirectFileOutput = a.SegmentedFileOutput = a.EncodedFileOutput = a.WebEgressRequest = a.TrackEgressRequest = a.TrackCompositeEgressRequest = a.RoomCompositeEgressRequest = a.streamInfo_StatusToJSON = a.streamInfo_StatusFromJSON = a.StreamInfo_Status = a.egressStatusToJSON = a.egressStatusFromJSON = a.EgressStatus = a.encodingOptionsPresetToJSON = a.encodingOptionsPresetFromJSON = a.EncodingOptionsPreset = a.videoCodecToJSON = a.videoCodecFromJSON = a.VideoCodec = a.audioCodecToJSON = a.audioCodecFromJSON = a.AudioCodec = a.segmentedFileProtocolToJSON = a.segmentedFileProtocolFromJSON = a.SegmentedFileProtocol = a.streamProtocolToJSON = a.streamProtocolFromJSON = a.StreamProtocol = a.encodedFileTypeToJSON = a.encodedFileTypeFromJSON = a.EncodedFileType = a.protobufPackage = void 0;
  const c = u(umdExports), l = u(minimal);
  a.protobufPackage = "livekit";
  var v;
  (function(J) {
    J[J.DEFAULT_FILETYPE = 0] = "DEFAULT_FILETYPE", J[J.MP4 = 1] = "MP4", J[J.OGG = 2] = "OGG", J[J.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(v = a.EncodedFileType || (a.EncodedFileType = {}));
  function p(J) {
    switch (J) {
      case 0:
      case "DEFAULT_FILETYPE":
        return v.DEFAULT_FILETYPE;
      case 1:
      case "MP4":
        return v.MP4;
      case 2:
      case "OGG":
        return v.OGG;
      case -1:
      case "UNRECOGNIZED":
      default:
        return v.UNRECOGNIZED;
    }
  }
  a.encodedFileTypeFromJSON = p;
  function _(J) {
    switch (J) {
      case v.DEFAULT_FILETYPE:
        return "DEFAULT_FILETYPE";
      case v.MP4:
        return "MP4";
      case v.OGG:
        return "OGG";
      case v.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.encodedFileTypeToJSON = _;
  var k;
  (function(J) {
    J[J.DEFAULT_PROTOCOL = 0] = "DEFAULT_PROTOCOL", J[J.RTMP = 1] = "RTMP", J[J.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(k = a.StreamProtocol || (a.StreamProtocol = {}));
  function O(J) {
    switch (J) {
      case 0:
      case "DEFAULT_PROTOCOL":
        return k.DEFAULT_PROTOCOL;
      case 1:
      case "RTMP":
        return k.RTMP;
      case -1:
      case "UNRECOGNIZED":
      default:
        return k.UNRECOGNIZED;
    }
  }
  a.streamProtocolFromJSON = O;
  function D(J) {
    switch (J) {
      case k.DEFAULT_PROTOCOL:
        return "DEFAULT_PROTOCOL";
      case k.RTMP:
        return "RTMP";
      case k.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.streamProtocolToJSON = D;
  var F;
  (function(J) {
    J[J.DEFAULT_SEGMENTED_FILE_PROTOCOL = 0] = "DEFAULT_SEGMENTED_FILE_PROTOCOL", J[J.HLS_PROTOCOL = 1] = "HLS_PROTOCOL", J[J.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(F = a.SegmentedFileProtocol || (a.SegmentedFileProtocol = {}));
  function H(J) {
    switch (J) {
      case 0:
      case "DEFAULT_SEGMENTED_FILE_PROTOCOL":
        return F.DEFAULT_SEGMENTED_FILE_PROTOCOL;
      case 1:
      case "HLS_PROTOCOL":
        return F.HLS_PROTOCOL;
      case -1:
      case "UNRECOGNIZED":
      default:
        return F.UNRECOGNIZED;
    }
  }
  a.segmentedFileProtocolFromJSON = H;
  function Z(J) {
    switch (J) {
      case F.DEFAULT_SEGMENTED_FILE_PROTOCOL:
        return "DEFAULT_SEGMENTED_FILE_PROTOCOL";
      case F.HLS_PROTOCOL:
        return "HLS_PROTOCOL";
      case F.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.segmentedFileProtocolToJSON = Z;
  var ee;
  (function(J) {
    J[J.DEFAULT_AC = 0] = "DEFAULT_AC", J[J.OPUS = 1] = "OPUS", J[J.AAC = 2] = "AAC", J[J.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(ee = a.AudioCodec || (a.AudioCodec = {}));
  function X(J) {
    switch (J) {
      case 0:
      case "DEFAULT_AC":
        return ee.DEFAULT_AC;
      case 1:
      case "OPUS":
        return ee.OPUS;
      case 2:
      case "AAC":
        return ee.AAC;
      case -1:
      case "UNRECOGNIZED":
      default:
        return ee.UNRECOGNIZED;
    }
  }
  a.audioCodecFromJSON = X;
  function ne(J) {
    switch (J) {
      case ee.DEFAULT_AC:
        return "DEFAULT_AC";
      case ee.OPUS:
        return "OPUS";
      case ee.AAC:
        return "AAC";
      case ee.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.audioCodecToJSON = ne;
  var Q;
  (function(J) {
    J[J.DEFAULT_VC = 0] = "DEFAULT_VC", J[J.H264_BASELINE = 1] = "H264_BASELINE", J[J.H264_MAIN = 2] = "H264_MAIN", J[J.H264_HIGH = 3] = "H264_HIGH", J[J.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(Q = a.VideoCodec || (a.VideoCodec = {}));
  function ae(J) {
    switch (J) {
      case 0:
      case "DEFAULT_VC":
        return Q.DEFAULT_VC;
      case 1:
      case "H264_BASELINE":
        return Q.H264_BASELINE;
      case 2:
      case "H264_MAIN":
        return Q.H264_MAIN;
      case 3:
      case "H264_HIGH":
        return Q.H264_HIGH;
      case -1:
      case "UNRECOGNIZED":
      default:
        return Q.UNRECOGNIZED;
    }
  }
  a.videoCodecFromJSON = ae;
  function j(J) {
    switch (J) {
      case Q.DEFAULT_VC:
        return "DEFAULT_VC";
      case Q.H264_BASELINE:
        return "H264_BASELINE";
      case Q.H264_MAIN:
        return "H264_MAIN";
      case Q.H264_HIGH:
        return "H264_HIGH";
      case Q.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.videoCodecToJSON = j;
  var ue;
  (function(J) {
    J[J.H264_720P_30 = 0] = "H264_720P_30", J[J.H264_720P_60 = 1] = "H264_720P_60", J[J.H264_1080P_30 = 2] = "H264_1080P_30", J[J.H264_1080P_60 = 3] = "H264_1080P_60", J[J.PORTRAIT_H264_720P_30 = 4] = "PORTRAIT_H264_720P_30", J[J.PORTRAIT_H264_720P_60 = 5] = "PORTRAIT_H264_720P_60", J[J.PORTRAIT_H264_1080P_30 = 6] = "PORTRAIT_H264_1080P_30", J[J.PORTRAIT_H264_1080P_60 = 7] = "PORTRAIT_H264_1080P_60", J[J.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(ue = a.EncodingOptionsPreset || (a.EncodingOptionsPreset = {}));
  function he(J) {
    switch (J) {
      case 0:
      case "H264_720P_30":
        return ue.H264_720P_30;
      case 1:
      case "H264_720P_60":
        return ue.H264_720P_60;
      case 2:
      case "H264_1080P_30":
        return ue.H264_1080P_30;
      case 3:
      case "H264_1080P_60":
        return ue.H264_1080P_60;
      case 4:
      case "PORTRAIT_H264_720P_30":
        return ue.PORTRAIT_H264_720P_30;
      case 5:
      case "PORTRAIT_H264_720P_60":
        return ue.PORTRAIT_H264_720P_60;
      case 6:
      case "PORTRAIT_H264_1080P_30":
        return ue.PORTRAIT_H264_1080P_30;
      case 7:
      case "PORTRAIT_H264_1080P_60":
        return ue.PORTRAIT_H264_1080P_60;
      case -1:
      case "UNRECOGNIZED":
      default:
        return ue.UNRECOGNIZED;
    }
  }
  a.encodingOptionsPresetFromJSON = he;
  function fe(J) {
    switch (J) {
      case ue.H264_720P_30:
        return "H264_720P_30";
      case ue.H264_720P_60:
        return "H264_720P_60";
      case ue.H264_1080P_30:
        return "H264_1080P_30";
      case ue.H264_1080P_60:
        return "H264_1080P_60";
      case ue.PORTRAIT_H264_720P_30:
        return "PORTRAIT_H264_720P_30";
      case ue.PORTRAIT_H264_720P_60:
        return "PORTRAIT_H264_720P_60";
      case ue.PORTRAIT_H264_1080P_30:
        return "PORTRAIT_H264_1080P_30";
      case ue.PORTRAIT_H264_1080P_60:
        return "PORTRAIT_H264_1080P_60";
      case ue.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.encodingOptionsPresetToJSON = fe;
  var be;
  (function(J) {
    J[J.EGRESS_STARTING = 0] = "EGRESS_STARTING", J[J.EGRESS_ACTIVE = 1] = "EGRESS_ACTIVE", J[J.EGRESS_ENDING = 2] = "EGRESS_ENDING", J[J.EGRESS_COMPLETE = 3] = "EGRESS_COMPLETE", J[J.EGRESS_FAILED = 4] = "EGRESS_FAILED", J[J.EGRESS_ABORTED = 5] = "EGRESS_ABORTED", J[J.EGRESS_LIMIT_REACHED = 6] = "EGRESS_LIMIT_REACHED", J[J.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(be = a.EgressStatus || (a.EgressStatus = {}));
  function ke(J) {
    switch (J) {
      case 0:
      case "EGRESS_STARTING":
        return be.EGRESS_STARTING;
      case 1:
      case "EGRESS_ACTIVE":
        return be.EGRESS_ACTIVE;
      case 2:
      case "EGRESS_ENDING":
        return be.EGRESS_ENDING;
      case 3:
      case "EGRESS_COMPLETE":
        return be.EGRESS_COMPLETE;
      case 4:
      case "EGRESS_FAILED":
        return be.EGRESS_FAILED;
      case 5:
      case "EGRESS_ABORTED":
        return be.EGRESS_ABORTED;
      case 6:
      case "EGRESS_LIMIT_REACHED":
        return be.EGRESS_LIMIT_REACHED;
      case -1:
      case "UNRECOGNIZED":
      default:
        return be.UNRECOGNIZED;
    }
  }
  a.egressStatusFromJSON = ke;
  function Te(J) {
    switch (J) {
      case be.EGRESS_STARTING:
        return "EGRESS_STARTING";
      case be.EGRESS_ACTIVE:
        return "EGRESS_ACTIVE";
      case be.EGRESS_ENDING:
        return "EGRESS_ENDING";
      case be.EGRESS_COMPLETE:
        return "EGRESS_COMPLETE";
      case be.EGRESS_FAILED:
        return "EGRESS_FAILED";
      case be.EGRESS_ABORTED:
        return "EGRESS_ABORTED";
      case be.EGRESS_LIMIT_REACHED:
        return "EGRESS_LIMIT_REACHED";
      case be.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.egressStatusToJSON = Te;
  var q;
  (function(J) {
    J[J.ACTIVE = 0] = "ACTIVE", J[J.FINISHED = 1] = "FINISHED", J[J.FAILED = 2] = "FAILED", J[J.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(q = a.StreamInfo_Status || (a.StreamInfo_Status = {}));
  function z(J) {
    switch (J) {
      case 0:
      case "ACTIVE":
        return q.ACTIVE;
      case 1:
      case "FINISHED":
        return q.FINISHED;
      case 2:
      case "FAILED":
        return q.FAILED;
      case -1:
      case "UNRECOGNIZED":
      default:
        return q.UNRECOGNIZED;
    }
  }
  a.streamInfo_StatusFromJSON = z;
  function P(J) {
    switch (J) {
      case q.ACTIVE:
        return "ACTIVE";
      case q.FINISHED:
        return "FINISHED";
      case q.FAILED:
        return "FAILED";
      case q.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.streamInfo_StatusToJSON = P;
  function S() {
    return {
      roomName: "",
      layout: "",
      audioOnly: !1,
      videoOnly: !1,
      customBaseUrl: "",
      file: void 0,
      stream: void 0,
      segments: void 0,
      preset: void 0,
      advanced: void 0
    };
  }
  a.RoomCompositeEgressRequest = {
    encode(J, ge = l.default.Writer.create()) {
      return J.roomName !== void 0 && J.roomName !== "" && ge.uint32(10).string(J.roomName), J.layout !== void 0 && J.layout !== "" && ge.uint32(18).string(J.layout), J.audioOnly === !0 && ge.uint32(24).bool(J.audioOnly), J.videoOnly === !0 && ge.uint32(32).bool(J.videoOnly), J.customBaseUrl !== void 0 && J.customBaseUrl !== "" && ge.uint32(42).string(J.customBaseUrl), J.file !== void 0 && a.EncodedFileOutput.encode(J.file, ge.uint32(50).fork()).ldelim(), J.stream !== void 0 && a.StreamOutput.encode(J.stream, ge.uint32(58).fork()).ldelim(), J.segments !== void 0 && a.SegmentedFileOutput.encode(J.segments, ge.uint32(82).fork()).ldelim(), J.preset !== void 0 && ge.uint32(64).int32(J.preset), J.advanced !== void 0 && a.EncodingOptions.encode(J.advanced, ge.uint32(74).fork()).ldelim(), ge;
    },
    decode(J, ge) {
      const we = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let We = ge === void 0 ? we.len : we.pos + ge;
      const Ie = S();
      for (; we.pos < We; ) {
        const V = we.uint32();
        switch (V >>> 3) {
          case 1:
            Ie.roomName = we.string();
            break;
          case 2:
            Ie.layout = we.string();
            break;
          case 3:
            Ie.audioOnly = we.bool();
            break;
          case 4:
            Ie.videoOnly = we.bool();
            break;
          case 5:
            Ie.customBaseUrl = we.string();
            break;
          case 6:
            Ie.file = a.EncodedFileOutput.decode(we, we.uint32());
            break;
          case 7:
            Ie.stream = a.StreamOutput.decode(we, we.uint32());
            break;
          case 10:
            Ie.segments = a.SegmentedFileOutput.decode(we, we.uint32());
            break;
          case 8:
            Ie.preset = we.int32();
            break;
          case 9:
            Ie.advanced = a.EncodingOptions.decode(we, we.uint32());
            break;
          default:
            we.skipType(V & 7);
            break;
        }
      }
      return Ie;
    },
    fromJSON(J) {
      return {
        roomName: Ge(J.roomName) ? String(J.roomName) : "",
        layout: Ge(J.layout) ? String(J.layout) : "",
        audioOnly: Ge(J.audioOnly) ? !!J.audioOnly : !1,
        videoOnly: Ge(J.videoOnly) ? !!J.videoOnly : !1,
        customBaseUrl: Ge(J.customBaseUrl) ? String(J.customBaseUrl) : "",
        file: Ge(J.file) ? a.EncodedFileOutput.fromJSON(J.file) : void 0,
        stream: Ge(J.stream) ? a.StreamOutput.fromJSON(J.stream) : void 0,
        segments: Ge(J.segments) ? a.SegmentedFileOutput.fromJSON(J.segments) : void 0,
        preset: Ge(J.preset) ? he(J.preset) : void 0,
        advanced: Ge(J.advanced) ? a.EncodingOptions.fromJSON(J.advanced) : void 0
      };
    },
    toJSON(J) {
      const ge = {};
      return J.roomName !== void 0 && (ge.roomName = J.roomName), J.layout !== void 0 && (ge.layout = J.layout), J.audioOnly !== void 0 && (ge.audioOnly = J.audioOnly), J.videoOnly !== void 0 && (ge.videoOnly = J.videoOnly), J.customBaseUrl !== void 0 && (ge.customBaseUrl = J.customBaseUrl), J.file !== void 0 && (ge.file = J.file ? a.EncodedFileOutput.toJSON(J.file) : void 0), J.stream !== void 0 && (ge.stream = J.stream ? a.StreamOutput.toJSON(J.stream) : void 0), J.segments !== void 0 && (ge.segments = J.segments ? a.SegmentedFileOutput.toJSON(J.segments) : void 0), J.preset !== void 0 && (ge.preset = J.preset !== void 0 ? fe(J.preset) : void 0), J.advanced !== void 0 && (ge.advanced = J.advanced ? a.EncodingOptions.toJSON(J.advanced) : void 0), ge;
    },
    fromPartial(J) {
      var ge, we, We, Ie, V, Ee;
      const de = S();
      return de.roomName = (ge = J.roomName) !== null && ge !== void 0 ? ge : "", de.layout = (we = J.layout) !== null && we !== void 0 ? we : "", de.audioOnly = (We = J.audioOnly) !== null && We !== void 0 ? We : !1, de.videoOnly = (Ie = J.videoOnly) !== null && Ie !== void 0 ? Ie : !1, de.customBaseUrl = (V = J.customBaseUrl) !== null && V !== void 0 ? V : "", de.file = J.file !== void 0 && J.file !== null ? a.EncodedFileOutput.fromPartial(J.file) : void 0, de.stream = J.stream !== void 0 && J.stream !== null ? a.StreamOutput.fromPartial(J.stream) : void 0, de.segments = J.segments !== void 0 && J.segments !== null ? a.SegmentedFileOutput.fromPartial(J.segments) : void 0, de.preset = (Ee = J.preset) !== null && Ee !== void 0 ? Ee : void 0, de.advanced = J.advanced !== void 0 && J.advanced !== null ? a.EncodingOptions.fromPartial(J.advanced) : void 0, de;
    }
  };
  function E() {
    return {
      roomName: "",
      audioTrackId: "",
      videoTrackId: "",
      file: void 0,
      stream: void 0,
      segments: void 0,
      preset: void 0,
      advanced: void 0
    };
  }
  a.TrackCompositeEgressRequest = {
    encode(J, ge = l.default.Writer.create()) {
      return J.roomName !== void 0 && J.roomName !== "" && ge.uint32(10).string(J.roomName), J.audioTrackId !== void 0 && J.audioTrackId !== "" && ge.uint32(18).string(J.audioTrackId), J.videoTrackId !== void 0 && J.videoTrackId !== "" && ge.uint32(26).string(J.videoTrackId), J.file !== void 0 && a.EncodedFileOutput.encode(J.file, ge.uint32(34).fork()).ldelim(), J.stream !== void 0 && a.StreamOutput.encode(J.stream, ge.uint32(42).fork()).ldelim(), J.segments !== void 0 && a.SegmentedFileOutput.encode(J.segments, ge.uint32(66).fork()).ldelim(), J.preset !== void 0 && ge.uint32(48).int32(J.preset), J.advanced !== void 0 && a.EncodingOptions.encode(J.advanced, ge.uint32(58).fork()).ldelim(), ge;
    },
    decode(J, ge) {
      const we = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let We = ge === void 0 ? we.len : we.pos + ge;
      const Ie = E();
      for (; we.pos < We; ) {
        const V = we.uint32();
        switch (V >>> 3) {
          case 1:
            Ie.roomName = we.string();
            break;
          case 2:
            Ie.audioTrackId = we.string();
            break;
          case 3:
            Ie.videoTrackId = we.string();
            break;
          case 4:
            Ie.file = a.EncodedFileOutput.decode(we, we.uint32());
            break;
          case 5:
            Ie.stream = a.StreamOutput.decode(we, we.uint32());
            break;
          case 8:
            Ie.segments = a.SegmentedFileOutput.decode(we, we.uint32());
            break;
          case 6:
            Ie.preset = we.int32();
            break;
          case 7:
            Ie.advanced = a.EncodingOptions.decode(we, we.uint32());
            break;
          default:
            we.skipType(V & 7);
            break;
        }
      }
      return Ie;
    },
    fromJSON(J) {
      return {
        roomName: Ge(J.roomName) ? String(J.roomName) : "",
        audioTrackId: Ge(J.audioTrackId) ? String(J.audioTrackId) : "",
        videoTrackId: Ge(J.videoTrackId) ? String(J.videoTrackId) : "",
        file: Ge(J.file) ? a.EncodedFileOutput.fromJSON(J.file) : void 0,
        stream: Ge(J.stream) ? a.StreamOutput.fromJSON(J.stream) : void 0,
        segments: Ge(J.segments) ? a.SegmentedFileOutput.fromJSON(J.segments) : void 0,
        preset: Ge(J.preset) ? he(J.preset) : void 0,
        advanced: Ge(J.advanced) ? a.EncodingOptions.fromJSON(J.advanced) : void 0
      };
    },
    toJSON(J) {
      const ge = {};
      return J.roomName !== void 0 && (ge.roomName = J.roomName), J.audioTrackId !== void 0 && (ge.audioTrackId = J.audioTrackId), J.videoTrackId !== void 0 && (ge.videoTrackId = J.videoTrackId), J.file !== void 0 && (ge.file = J.file ? a.EncodedFileOutput.toJSON(J.file) : void 0), J.stream !== void 0 && (ge.stream = J.stream ? a.StreamOutput.toJSON(J.stream) : void 0), J.segments !== void 0 && (ge.segments = J.segments ? a.SegmentedFileOutput.toJSON(J.segments) : void 0), J.preset !== void 0 && (ge.preset = J.preset !== void 0 ? fe(J.preset) : void 0), J.advanced !== void 0 && (ge.advanced = J.advanced ? a.EncodingOptions.toJSON(J.advanced) : void 0), ge;
    },
    fromPartial(J) {
      var ge, we, We, Ie;
      const V = E();
      return V.roomName = (ge = J.roomName) !== null && ge !== void 0 ? ge : "", V.audioTrackId = (we = J.audioTrackId) !== null && we !== void 0 ? we : "", V.videoTrackId = (We = J.videoTrackId) !== null && We !== void 0 ? We : "", V.file = J.file !== void 0 && J.file !== null ? a.EncodedFileOutput.fromPartial(J.file) : void 0, V.stream = J.stream !== void 0 && J.stream !== null ? a.StreamOutput.fromPartial(J.stream) : void 0, V.segments = J.segments !== void 0 && J.segments !== null ? a.SegmentedFileOutput.fromPartial(J.segments) : void 0, V.preset = (Ie = J.preset) !== null && Ie !== void 0 ? Ie : void 0, V.advanced = J.advanced !== void 0 && J.advanced !== null ? a.EncodingOptions.fromPartial(J.advanced) : void 0, V;
    }
  };
  function I() {
    return { roomName: "", trackId: "", file: void 0, websocketUrl: void 0 };
  }
  a.TrackEgressRequest = {
    encode(J, ge = l.default.Writer.create()) {
      return J.roomName !== void 0 && J.roomName !== "" && ge.uint32(10).string(J.roomName), J.trackId !== void 0 && J.trackId !== "" && ge.uint32(18).string(J.trackId), J.file !== void 0 && a.DirectFileOutput.encode(J.file, ge.uint32(26).fork()).ldelim(), J.websocketUrl !== void 0 && ge.uint32(34).string(J.websocketUrl), ge;
    },
    decode(J, ge) {
      const we = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let We = ge === void 0 ? we.len : we.pos + ge;
      const Ie = I();
      for (; we.pos < We; ) {
        const V = we.uint32();
        switch (V >>> 3) {
          case 1:
            Ie.roomName = we.string();
            break;
          case 2:
            Ie.trackId = we.string();
            break;
          case 3:
            Ie.file = a.DirectFileOutput.decode(we, we.uint32());
            break;
          case 4:
            Ie.websocketUrl = we.string();
            break;
          default:
            we.skipType(V & 7);
            break;
        }
      }
      return Ie;
    },
    fromJSON(J) {
      return {
        roomName: Ge(J.roomName) ? String(J.roomName) : "",
        trackId: Ge(J.trackId) ? String(J.trackId) : "",
        file: Ge(J.file) ? a.DirectFileOutput.fromJSON(J.file) : void 0,
        websocketUrl: Ge(J.websocketUrl) ? String(J.websocketUrl) : void 0
      };
    },
    toJSON(J) {
      const ge = {};
      return J.roomName !== void 0 && (ge.roomName = J.roomName), J.trackId !== void 0 && (ge.trackId = J.trackId), J.file !== void 0 && (ge.file = J.file ? a.DirectFileOutput.toJSON(J.file) : void 0), J.websocketUrl !== void 0 && (ge.websocketUrl = J.websocketUrl), ge;
    },
    fromPartial(J) {
      var ge, we, We;
      const Ie = I();
      return Ie.roomName = (ge = J.roomName) !== null && ge !== void 0 ? ge : "", Ie.trackId = (we = J.trackId) !== null && we !== void 0 ? we : "", Ie.file = J.file !== void 0 && J.file !== null ? a.DirectFileOutput.fromPartial(J.file) : void 0, Ie.websocketUrl = (We = J.websocketUrl) !== null && We !== void 0 ? We : void 0, Ie;
    }
  };
  function M() {
    return {
      url: "",
      audioOnly: !1,
      videoOnly: !1,
      file: void 0,
      stream: void 0,
      segments: void 0,
      preset: void 0,
      advanced: void 0
    };
  }
  a.WebEgressRequest = {
    encode(J, ge = l.default.Writer.create()) {
      return J.url !== void 0 && J.url !== "" && ge.uint32(10).string(J.url), J.audioOnly === !0 && ge.uint32(16).bool(J.audioOnly), J.videoOnly === !0 && ge.uint32(24).bool(J.videoOnly), J.file !== void 0 && a.EncodedFileOutput.encode(J.file, ge.uint32(34).fork()).ldelim(), J.stream !== void 0 && a.StreamOutput.encode(J.stream, ge.uint32(42).fork()).ldelim(), J.segments !== void 0 && a.SegmentedFileOutput.encode(J.segments, ge.uint32(50).fork()).ldelim(), J.preset !== void 0 && ge.uint32(56).int32(J.preset), J.advanced !== void 0 && a.EncodingOptions.encode(J.advanced, ge.uint32(66).fork()).ldelim(), ge;
    },
    decode(J, ge) {
      const we = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let We = ge === void 0 ? we.len : we.pos + ge;
      const Ie = M();
      for (; we.pos < We; ) {
        const V = we.uint32();
        switch (V >>> 3) {
          case 1:
            Ie.url = we.string();
            break;
          case 2:
            Ie.audioOnly = we.bool();
            break;
          case 3:
            Ie.videoOnly = we.bool();
            break;
          case 4:
            Ie.file = a.EncodedFileOutput.decode(we, we.uint32());
            break;
          case 5:
            Ie.stream = a.StreamOutput.decode(we, we.uint32());
            break;
          case 6:
            Ie.segments = a.SegmentedFileOutput.decode(we, we.uint32());
            break;
          case 7:
            Ie.preset = we.int32();
            break;
          case 8:
            Ie.advanced = a.EncodingOptions.decode(we, we.uint32());
            break;
          default:
            we.skipType(V & 7);
            break;
        }
      }
      return Ie;
    },
    fromJSON(J) {
      return {
        url: Ge(J.url) ? String(J.url) : "",
        audioOnly: Ge(J.audioOnly) ? !!J.audioOnly : !1,
        videoOnly: Ge(J.videoOnly) ? !!J.videoOnly : !1,
        file: Ge(J.file) ? a.EncodedFileOutput.fromJSON(J.file) : void 0,
        stream: Ge(J.stream) ? a.StreamOutput.fromJSON(J.stream) : void 0,
        segments: Ge(J.segments) ? a.SegmentedFileOutput.fromJSON(J.segments) : void 0,
        preset: Ge(J.preset) ? he(J.preset) : void 0,
        advanced: Ge(J.advanced) ? a.EncodingOptions.fromJSON(J.advanced) : void 0
      };
    },
    toJSON(J) {
      const ge = {};
      return J.url !== void 0 && (ge.url = J.url), J.audioOnly !== void 0 && (ge.audioOnly = J.audioOnly), J.videoOnly !== void 0 && (ge.videoOnly = J.videoOnly), J.file !== void 0 && (ge.file = J.file ? a.EncodedFileOutput.toJSON(J.file) : void 0), J.stream !== void 0 && (ge.stream = J.stream ? a.StreamOutput.toJSON(J.stream) : void 0), J.segments !== void 0 && (ge.segments = J.segments ? a.SegmentedFileOutput.toJSON(J.segments) : void 0), J.preset !== void 0 && (ge.preset = J.preset !== void 0 ? fe(J.preset) : void 0), J.advanced !== void 0 && (ge.advanced = J.advanced ? a.EncodingOptions.toJSON(J.advanced) : void 0), ge;
    },
    fromPartial(J) {
      var ge, we, We, Ie;
      const V = M();
      return V.url = (ge = J.url) !== null && ge !== void 0 ? ge : "", V.audioOnly = (we = J.audioOnly) !== null && we !== void 0 ? we : !1, V.videoOnly = (We = J.videoOnly) !== null && We !== void 0 ? We : !1, V.file = J.file !== void 0 && J.file !== null ? a.EncodedFileOutput.fromPartial(J.file) : void 0, V.stream = J.stream !== void 0 && J.stream !== null ? a.StreamOutput.fromPartial(J.stream) : void 0, V.segments = J.segments !== void 0 && J.segments !== null ? a.SegmentedFileOutput.fromPartial(J.segments) : void 0, V.preset = (Ie = J.preset) !== null && Ie !== void 0 ? Ie : void 0, V.advanced = J.advanced !== void 0 && J.advanced !== null ? a.EncodingOptions.fromPartial(J.advanced) : void 0, V;
    }
  };
  function $() {
    return {
      fileType: 0,
      filepath: "",
      disableManifest: !1,
      s3: void 0,
      gcp: void 0,
      azure: void 0,
      aliOSS: void 0
    };
  }
  a.EncodedFileOutput = {
    encode(J, ge = l.default.Writer.create()) {
      return J.fileType !== void 0 && J.fileType !== 0 && ge.uint32(8).int32(J.fileType), J.filepath !== void 0 && J.filepath !== "" && ge.uint32(18).string(J.filepath), J.disableManifest === !0 && ge.uint32(48).bool(J.disableManifest), J.s3 !== void 0 && a.S3Upload.encode(J.s3, ge.uint32(26).fork()).ldelim(), J.gcp !== void 0 && a.GCPUpload.encode(J.gcp, ge.uint32(34).fork()).ldelim(), J.azure !== void 0 && a.AzureBlobUpload.encode(J.azure, ge.uint32(42).fork()).ldelim(), J.aliOSS !== void 0 && a.AliOSSUpload.encode(J.aliOSS, ge.uint32(58).fork()).ldelim(), ge;
    },
    decode(J, ge) {
      const we = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let We = ge === void 0 ? we.len : we.pos + ge;
      const Ie = $();
      for (; we.pos < We; ) {
        const V = we.uint32();
        switch (V >>> 3) {
          case 1:
            Ie.fileType = we.int32();
            break;
          case 2:
            Ie.filepath = we.string();
            break;
          case 6:
            Ie.disableManifest = we.bool();
            break;
          case 3:
            Ie.s3 = a.S3Upload.decode(we, we.uint32());
            break;
          case 4:
            Ie.gcp = a.GCPUpload.decode(we, we.uint32());
            break;
          case 5:
            Ie.azure = a.AzureBlobUpload.decode(we, we.uint32());
            break;
          case 7:
            Ie.aliOSS = a.AliOSSUpload.decode(we, we.uint32());
            break;
          default:
            we.skipType(V & 7);
            break;
        }
      }
      return Ie;
    },
    fromJSON(J) {
      return {
        fileType: Ge(J.fileType) ? p(J.fileType) : 0,
        filepath: Ge(J.filepath) ? String(J.filepath) : "",
        disableManifest: Ge(J.disableManifest) ? !!J.disableManifest : !1,
        s3: Ge(J.s3) ? a.S3Upload.fromJSON(J.s3) : void 0,
        gcp: Ge(J.gcp) ? a.GCPUpload.fromJSON(J.gcp) : void 0,
        azure: Ge(J.azure) ? a.AzureBlobUpload.fromJSON(J.azure) : void 0,
        aliOSS: Ge(J.aliOSS) ? a.AliOSSUpload.fromJSON(J.aliOSS) : void 0
      };
    },
    toJSON(J) {
      const ge = {};
      return J.fileType !== void 0 && (ge.fileType = _(J.fileType)), J.filepath !== void 0 && (ge.filepath = J.filepath), J.disableManifest !== void 0 && (ge.disableManifest = J.disableManifest), J.s3 !== void 0 && (ge.s3 = J.s3 ? a.S3Upload.toJSON(J.s3) : void 0), J.gcp !== void 0 && (ge.gcp = J.gcp ? a.GCPUpload.toJSON(J.gcp) : void 0), J.azure !== void 0 && (ge.azure = J.azure ? a.AzureBlobUpload.toJSON(J.azure) : void 0), J.aliOSS !== void 0 && (ge.aliOSS = J.aliOSS ? a.AliOSSUpload.toJSON(J.aliOSS) : void 0), ge;
    },
    fromPartial(J) {
      var ge, we, We;
      const Ie = $();
      return Ie.fileType = (ge = J.fileType) !== null && ge !== void 0 ? ge : 0, Ie.filepath = (we = J.filepath) !== null && we !== void 0 ? we : "", Ie.disableManifest = (We = J.disableManifest) !== null && We !== void 0 ? We : !1, Ie.s3 = J.s3 !== void 0 && J.s3 !== null ? a.S3Upload.fromPartial(J.s3) : void 0, Ie.gcp = J.gcp !== void 0 && J.gcp !== null ? a.GCPUpload.fromPartial(J.gcp) : void 0, Ie.azure = J.azure !== void 0 && J.azure !== null ? a.AzureBlobUpload.fromPartial(J.azure) : void 0, Ie.aliOSS = J.aliOSS !== void 0 && J.aliOSS !== null ? a.AliOSSUpload.fromPartial(J.aliOSS) : void 0, Ie;
    }
  };
  function U() {
    return {
      protocol: 0,
      filenamePrefix: "",
      playlistName: "",
      segmentDuration: 0,
      disableManifest: !1,
      s3: void 0,
      gcp: void 0,
      azure: void 0,
      aliOSS: void 0
    };
  }
  a.SegmentedFileOutput = {
    encode(J, ge = l.default.Writer.create()) {
      return J.protocol !== void 0 && J.protocol !== 0 && ge.uint32(8).int32(J.protocol), J.filenamePrefix !== void 0 && J.filenamePrefix !== "" && ge.uint32(18).string(J.filenamePrefix), J.playlistName !== void 0 && J.playlistName !== "" && ge.uint32(26).string(J.playlistName), J.segmentDuration !== void 0 && J.segmentDuration !== 0 && ge.uint32(32).uint32(J.segmentDuration), J.disableManifest === !0 && ge.uint32(64).bool(J.disableManifest), J.s3 !== void 0 && a.S3Upload.encode(J.s3, ge.uint32(42).fork()).ldelim(), J.gcp !== void 0 && a.GCPUpload.encode(J.gcp, ge.uint32(50).fork()).ldelim(), J.azure !== void 0 && a.AzureBlobUpload.encode(J.azure, ge.uint32(58).fork()).ldelim(), J.aliOSS !== void 0 && a.AliOSSUpload.encode(J.aliOSS, ge.uint32(74).fork()).ldelim(), ge;
    },
    decode(J, ge) {
      const we = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let We = ge === void 0 ? we.len : we.pos + ge;
      const Ie = U();
      for (; we.pos < We; ) {
        const V = we.uint32();
        switch (V >>> 3) {
          case 1:
            Ie.protocol = we.int32();
            break;
          case 2:
            Ie.filenamePrefix = we.string();
            break;
          case 3:
            Ie.playlistName = we.string();
            break;
          case 4:
            Ie.segmentDuration = we.uint32();
            break;
          case 8:
            Ie.disableManifest = we.bool();
            break;
          case 5:
            Ie.s3 = a.S3Upload.decode(we, we.uint32());
            break;
          case 6:
            Ie.gcp = a.GCPUpload.decode(we, we.uint32());
            break;
          case 7:
            Ie.azure = a.AzureBlobUpload.decode(we, we.uint32());
            break;
          case 9:
            Ie.aliOSS = a.AliOSSUpload.decode(we, we.uint32());
            break;
          default:
            we.skipType(V & 7);
            break;
        }
      }
      return Ie;
    },
    fromJSON(J) {
      return {
        protocol: Ge(J.protocol) ? H(J.protocol) : 0,
        filenamePrefix: Ge(J.filenamePrefix) ? String(J.filenamePrefix) : "",
        playlistName: Ge(J.playlistName) ? String(J.playlistName) : "",
        segmentDuration: Ge(J.segmentDuration) ? Number(J.segmentDuration) : 0,
        disableManifest: Ge(J.disableManifest) ? !!J.disableManifest : !1,
        s3: Ge(J.s3) ? a.S3Upload.fromJSON(J.s3) : void 0,
        gcp: Ge(J.gcp) ? a.GCPUpload.fromJSON(J.gcp) : void 0,
        azure: Ge(J.azure) ? a.AzureBlobUpload.fromJSON(J.azure) : void 0,
        aliOSS: Ge(J.aliOSS) ? a.AliOSSUpload.fromJSON(J.aliOSS) : void 0
      };
    },
    toJSON(J) {
      const ge = {};
      return J.protocol !== void 0 && (ge.protocol = Z(J.protocol)), J.filenamePrefix !== void 0 && (ge.filenamePrefix = J.filenamePrefix), J.playlistName !== void 0 && (ge.playlistName = J.playlistName), J.segmentDuration !== void 0 && (ge.segmentDuration = Math.round(J.segmentDuration)), J.disableManifest !== void 0 && (ge.disableManifest = J.disableManifest), J.s3 !== void 0 && (ge.s3 = J.s3 ? a.S3Upload.toJSON(J.s3) : void 0), J.gcp !== void 0 && (ge.gcp = J.gcp ? a.GCPUpload.toJSON(J.gcp) : void 0), J.azure !== void 0 && (ge.azure = J.azure ? a.AzureBlobUpload.toJSON(J.azure) : void 0), J.aliOSS !== void 0 && (ge.aliOSS = J.aliOSS ? a.AliOSSUpload.toJSON(J.aliOSS) : void 0), ge;
    },
    fromPartial(J) {
      var ge, we, We, Ie, V;
      const Ee = U();
      return Ee.protocol = (ge = J.protocol) !== null && ge !== void 0 ? ge : 0, Ee.filenamePrefix = (we = J.filenamePrefix) !== null && we !== void 0 ? we : "", Ee.playlistName = (We = J.playlistName) !== null && We !== void 0 ? We : "", Ee.segmentDuration = (Ie = J.segmentDuration) !== null && Ie !== void 0 ? Ie : 0, Ee.disableManifest = (V = J.disableManifest) !== null && V !== void 0 ? V : !1, Ee.s3 = J.s3 !== void 0 && J.s3 !== null ? a.S3Upload.fromPartial(J.s3) : void 0, Ee.gcp = J.gcp !== void 0 && J.gcp !== null ? a.GCPUpload.fromPartial(J.gcp) : void 0, Ee.azure = J.azure !== void 0 && J.azure !== null ? a.AzureBlobUpload.fromPartial(J.azure) : void 0, Ee.aliOSS = J.aliOSS !== void 0 && J.aliOSS !== null ? a.AliOSSUpload.fromPartial(J.aliOSS) : void 0, Ee;
    }
  };
  function Y() {
    return { filepath: "", disableManifest: !1, s3: void 0, gcp: void 0, azure: void 0, aliOSS: void 0 };
  }
  a.DirectFileOutput = {
    encode(J, ge = l.default.Writer.create()) {
      return J.filepath !== void 0 && J.filepath !== "" && ge.uint32(10).string(J.filepath), J.disableManifest === !0 && ge.uint32(40).bool(J.disableManifest), J.s3 !== void 0 && a.S3Upload.encode(J.s3, ge.uint32(18).fork()).ldelim(), J.gcp !== void 0 && a.GCPUpload.encode(J.gcp, ge.uint32(26).fork()).ldelim(), J.azure !== void 0 && a.AzureBlobUpload.encode(J.azure, ge.uint32(34).fork()).ldelim(), J.aliOSS !== void 0 && a.AliOSSUpload.encode(J.aliOSS, ge.uint32(50).fork()).ldelim(), ge;
    },
    decode(J, ge) {
      const we = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let We = ge === void 0 ? we.len : we.pos + ge;
      const Ie = Y();
      for (; we.pos < We; ) {
        const V = we.uint32();
        switch (V >>> 3) {
          case 1:
            Ie.filepath = we.string();
            break;
          case 5:
            Ie.disableManifest = we.bool();
            break;
          case 2:
            Ie.s3 = a.S3Upload.decode(we, we.uint32());
            break;
          case 3:
            Ie.gcp = a.GCPUpload.decode(we, we.uint32());
            break;
          case 4:
            Ie.azure = a.AzureBlobUpload.decode(we, we.uint32());
            break;
          case 6:
            Ie.aliOSS = a.AliOSSUpload.decode(we, we.uint32());
            break;
          default:
            we.skipType(V & 7);
            break;
        }
      }
      return Ie;
    },
    fromJSON(J) {
      return {
        filepath: Ge(J.filepath) ? String(J.filepath) : "",
        disableManifest: Ge(J.disableManifest) ? !!J.disableManifest : !1,
        s3: Ge(J.s3) ? a.S3Upload.fromJSON(J.s3) : void 0,
        gcp: Ge(J.gcp) ? a.GCPUpload.fromJSON(J.gcp) : void 0,
        azure: Ge(J.azure) ? a.AzureBlobUpload.fromJSON(J.azure) : void 0,
        aliOSS: Ge(J.aliOSS) ? a.AliOSSUpload.fromJSON(J.aliOSS) : void 0
      };
    },
    toJSON(J) {
      const ge = {};
      return J.filepath !== void 0 && (ge.filepath = J.filepath), J.disableManifest !== void 0 && (ge.disableManifest = J.disableManifest), J.s3 !== void 0 && (ge.s3 = J.s3 ? a.S3Upload.toJSON(J.s3) : void 0), J.gcp !== void 0 && (ge.gcp = J.gcp ? a.GCPUpload.toJSON(J.gcp) : void 0), J.azure !== void 0 && (ge.azure = J.azure ? a.AzureBlobUpload.toJSON(J.azure) : void 0), J.aliOSS !== void 0 && (ge.aliOSS = J.aliOSS ? a.AliOSSUpload.toJSON(J.aliOSS) : void 0), ge;
    },
    fromPartial(J) {
      var ge, we;
      const We = Y();
      return We.filepath = (ge = J.filepath) !== null && ge !== void 0 ? ge : "", We.disableManifest = (we = J.disableManifest) !== null && we !== void 0 ? we : !1, We.s3 = J.s3 !== void 0 && J.s3 !== null ? a.S3Upload.fromPartial(J.s3) : void 0, We.gcp = J.gcp !== void 0 && J.gcp !== null ? a.GCPUpload.fromPartial(J.gcp) : void 0, We.azure = J.azure !== void 0 && J.azure !== null ? a.AzureBlobUpload.fromPartial(J.azure) : void 0, We.aliOSS = J.aliOSS !== void 0 && J.aliOSS !== null ? a.AliOSSUpload.fromPartial(J.aliOSS) : void 0, We;
    }
  };
  function B() {
    return {
      accessKey: "",
      secret: "",
      region: "",
      endpoint: "",
      bucket: "",
      forcePathStyle: !1,
      metadata: {},
      tagging: ""
    };
  }
  a.S3Upload = {
    encode(J, ge = l.default.Writer.create()) {
      return J.accessKey !== void 0 && J.accessKey !== "" && ge.uint32(10).string(J.accessKey), J.secret !== void 0 && J.secret !== "" && ge.uint32(18).string(J.secret), J.region !== void 0 && J.region !== "" && ge.uint32(26).string(J.region), J.endpoint !== void 0 && J.endpoint !== "" && ge.uint32(34).string(J.endpoint), J.bucket !== void 0 && J.bucket !== "" && ge.uint32(42).string(J.bucket), J.forcePathStyle === !0 && ge.uint32(48).bool(J.forcePathStyle), Object.entries(J.metadata || {}).forEach(([we, We]) => {
        a.S3Upload_MetadataEntry.encode({ key: we, value: We }, ge.uint32(58).fork()).ldelim();
      }), J.tagging !== void 0 && J.tagging !== "" && ge.uint32(66).string(J.tagging), ge;
    },
    decode(J, ge) {
      const we = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let We = ge === void 0 ? we.len : we.pos + ge;
      const Ie = B();
      for (; we.pos < We; ) {
        const V = we.uint32();
        switch (V >>> 3) {
          case 1:
            Ie.accessKey = we.string();
            break;
          case 2:
            Ie.secret = we.string();
            break;
          case 3:
            Ie.region = we.string();
            break;
          case 4:
            Ie.endpoint = we.string();
            break;
          case 5:
            Ie.bucket = we.string();
            break;
          case 6:
            Ie.forcePathStyle = we.bool();
            break;
          case 7:
            const Ee = a.S3Upload_MetadataEntry.decode(we, we.uint32());
            Ee.value !== void 0 && (Ie.metadata[Ee.key] = Ee.value);
            break;
          case 8:
            Ie.tagging = we.string();
            break;
          default:
            we.skipType(V & 7);
            break;
        }
      }
      return Ie;
    },
    fromJSON(J) {
      return {
        accessKey: Ge(J.accessKey) ? String(J.accessKey) : "",
        secret: Ge(J.secret) ? String(J.secret) : "",
        region: Ge(J.region) ? String(J.region) : "",
        endpoint: Ge(J.endpoint) ? String(J.endpoint) : "",
        bucket: Ge(J.bucket) ? String(J.bucket) : "",
        forcePathStyle: Ge(J.forcePathStyle) ? !!J.forcePathStyle : !1,
        metadata: Xe(J.metadata) ? Object.entries(J.metadata).reduce((ge, [we, We]) => (ge[we] = String(We), ge), {}) : {},
        tagging: Ge(J.tagging) ? String(J.tagging) : ""
      };
    },
    toJSON(J) {
      const ge = {};
      return J.accessKey !== void 0 && (ge.accessKey = J.accessKey), J.secret !== void 0 && (ge.secret = J.secret), J.region !== void 0 && (ge.region = J.region), J.endpoint !== void 0 && (ge.endpoint = J.endpoint), J.bucket !== void 0 && (ge.bucket = J.bucket), J.forcePathStyle !== void 0 && (ge.forcePathStyle = J.forcePathStyle), ge.metadata = {}, J.metadata && Object.entries(J.metadata).forEach(([we, We]) => {
        ge.metadata[we] = We;
      }), J.tagging !== void 0 && (ge.tagging = J.tagging), ge;
    },
    fromPartial(J) {
      var ge, we, We, Ie, V, Ee, de, ce;
      const ve = B();
      return ve.accessKey = (ge = J.accessKey) !== null && ge !== void 0 ? ge : "", ve.secret = (we = J.secret) !== null && we !== void 0 ? we : "", ve.region = (We = J.region) !== null && We !== void 0 ? We : "", ve.endpoint = (Ie = J.endpoint) !== null && Ie !== void 0 ? Ie : "", ve.bucket = (V = J.bucket) !== null && V !== void 0 ? V : "", ve.forcePathStyle = (Ee = J.forcePathStyle) !== null && Ee !== void 0 ? Ee : !1, ve.metadata = Object.entries((de = J.metadata) !== null && de !== void 0 ? de : {}).reduce((Pe, [Be, ze]) => (ze !== void 0 && (Pe[Be] = String(ze)), Pe), {}), ve.tagging = (ce = J.tagging) !== null && ce !== void 0 ? ce : "", ve;
    }
  };
  function T() {
    return { key: "", value: "" };
  }
  a.S3Upload_MetadataEntry = {
    encode(J, ge = l.default.Writer.create()) {
      return J.key !== "" && ge.uint32(10).string(J.key), J.value !== "" && ge.uint32(18).string(J.value), ge;
    },
    decode(J, ge) {
      const we = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let We = ge === void 0 ? we.len : we.pos + ge;
      const Ie = T();
      for (; we.pos < We; ) {
        const V = we.uint32();
        switch (V >>> 3) {
          case 1:
            Ie.key = we.string();
            break;
          case 2:
            Ie.value = we.string();
            break;
          default:
            we.skipType(V & 7);
            break;
        }
      }
      return Ie;
    },
    fromJSON(J) {
      return { key: Ge(J.key) ? String(J.key) : "", value: Ge(J.value) ? String(J.value) : "" };
    },
    toJSON(J) {
      const ge = {};
      return J.key !== void 0 && (ge.key = J.key), J.value !== void 0 && (ge.value = J.value), ge;
    },
    fromPartial(J) {
      var ge, we;
      const We = T();
      return We.key = (ge = J.key) !== null && ge !== void 0 ? ge : "", We.value = (we = J.value) !== null && we !== void 0 ? we : "", We;
    }
  };
  function L() {
    return { credentials: new Uint8Array(), bucket: "" };
  }
  a.GCPUpload = {
    encode(J, ge = l.default.Writer.create()) {
      return J.credentials !== void 0 && J.credentials.length !== 0 && ge.uint32(10).bytes(J.credentials), J.bucket !== void 0 && J.bucket !== "" && ge.uint32(18).string(J.bucket), ge;
    },
    decode(J, ge) {
      const we = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let We = ge === void 0 ? we.len : we.pos + ge;
      const Ie = L();
      for (; we.pos < We; ) {
        const V = we.uint32();
        switch (V >>> 3) {
          case 1:
            Ie.credentials = we.bytes();
            break;
          case 2:
            Ie.bucket = we.string();
            break;
          default:
            we.skipType(V & 7);
            break;
        }
      }
      return Ie;
    },
    fromJSON(J) {
      return {
        credentials: Ge(J.credentials) ? Ze(J.credentials) : new Uint8Array(),
        bucket: Ge(J.bucket) ? String(J.bucket) : ""
      };
    },
    toJSON(J) {
      const ge = {};
      return J.credentials !== void 0 && (ge.credentials = qe(J.credentials !== void 0 ? J.credentials : new Uint8Array())), J.bucket !== void 0 && (ge.bucket = J.bucket), ge;
    },
    fromPartial(J) {
      var ge, we;
      const We = L();
      return We.credentials = (ge = J.credentials) !== null && ge !== void 0 ? ge : new Uint8Array(), We.bucket = (we = J.bucket) !== null && we !== void 0 ? we : "", We;
    }
  };
  function te() {
    return { accountName: "", accountKey: "", containerName: "" };
  }
  a.AzureBlobUpload = {
    encode(J, ge = l.default.Writer.create()) {
      return J.accountName !== void 0 && J.accountName !== "" && ge.uint32(10).string(J.accountName), J.accountKey !== void 0 && J.accountKey !== "" && ge.uint32(18).string(J.accountKey), J.containerName !== void 0 && J.containerName !== "" && ge.uint32(26).string(J.containerName), ge;
    },
    decode(J, ge) {
      const we = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let We = ge === void 0 ? we.len : we.pos + ge;
      const Ie = te();
      for (; we.pos < We; ) {
        const V = we.uint32();
        switch (V >>> 3) {
          case 1:
            Ie.accountName = we.string();
            break;
          case 2:
            Ie.accountKey = we.string();
            break;
          case 3:
            Ie.containerName = we.string();
            break;
          default:
            we.skipType(V & 7);
            break;
        }
      }
      return Ie;
    },
    fromJSON(J) {
      return {
        accountName: Ge(J.accountName) ? String(J.accountName) : "",
        accountKey: Ge(J.accountKey) ? String(J.accountKey) : "",
        containerName: Ge(J.containerName) ? String(J.containerName) : ""
      };
    },
    toJSON(J) {
      const ge = {};
      return J.accountName !== void 0 && (ge.accountName = J.accountName), J.accountKey !== void 0 && (ge.accountKey = J.accountKey), J.containerName !== void 0 && (ge.containerName = J.containerName), ge;
    },
    fromPartial(J) {
      var ge, we, We;
      const Ie = te();
      return Ie.accountName = (ge = J.accountName) !== null && ge !== void 0 ? ge : "", Ie.accountKey = (we = J.accountKey) !== null && we !== void 0 ? we : "", Ie.containerName = (We = J.containerName) !== null && We !== void 0 ? We : "", Ie;
    }
  };
  function me() {
    return { accessKey: "", secret: "", region: "", endpoint: "", bucket: "" };
  }
  a.AliOSSUpload = {
    encode(J, ge = l.default.Writer.create()) {
      return J.accessKey !== void 0 && J.accessKey !== "" && ge.uint32(10).string(J.accessKey), J.secret !== void 0 && J.secret !== "" && ge.uint32(18).string(J.secret), J.region !== void 0 && J.region !== "" && ge.uint32(26).string(J.region), J.endpoint !== void 0 && J.endpoint !== "" && ge.uint32(34).string(J.endpoint), J.bucket !== void 0 && J.bucket !== "" && ge.uint32(42).string(J.bucket), ge;
    },
    decode(J, ge) {
      const we = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let We = ge === void 0 ? we.len : we.pos + ge;
      const Ie = me();
      for (; we.pos < We; ) {
        const V = we.uint32();
        switch (V >>> 3) {
          case 1:
            Ie.accessKey = we.string();
            break;
          case 2:
            Ie.secret = we.string();
            break;
          case 3:
            Ie.region = we.string();
            break;
          case 4:
            Ie.endpoint = we.string();
            break;
          case 5:
            Ie.bucket = we.string();
            break;
          default:
            we.skipType(V & 7);
            break;
        }
      }
      return Ie;
    },
    fromJSON(J) {
      return {
        accessKey: Ge(J.accessKey) ? String(J.accessKey) : "",
        secret: Ge(J.secret) ? String(J.secret) : "",
        region: Ge(J.region) ? String(J.region) : "",
        endpoint: Ge(J.endpoint) ? String(J.endpoint) : "",
        bucket: Ge(J.bucket) ? String(J.bucket) : ""
      };
    },
    toJSON(J) {
      const ge = {};
      return J.accessKey !== void 0 && (ge.accessKey = J.accessKey), J.secret !== void 0 && (ge.secret = J.secret), J.region !== void 0 && (ge.region = J.region), J.endpoint !== void 0 && (ge.endpoint = J.endpoint), J.bucket !== void 0 && (ge.bucket = J.bucket), ge;
    },
    fromPartial(J) {
      var ge, we, We, Ie, V;
      const Ee = me();
      return Ee.accessKey = (ge = J.accessKey) !== null && ge !== void 0 ? ge : "", Ee.secret = (we = J.secret) !== null && we !== void 0 ? we : "", Ee.region = (We = J.region) !== null && We !== void 0 ? We : "", Ee.endpoint = (Ie = J.endpoint) !== null && Ie !== void 0 ? Ie : "", Ee.bucket = (V = J.bucket) !== null && V !== void 0 ? V : "", Ee;
    }
  };
  function Ce() {
    return { protocol: 0, urls: [] };
  }
  a.StreamOutput = {
    encode(J, ge = l.default.Writer.create()) {
      if (J.protocol !== void 0 && J.protocol !== 0 && ge.uint32(8).int32(J.protocol), J.urls !== void 0 && J.urls.length !== 0)
        for (const we of J.urls)
          ge.uint32(18).string(we);
      return ge;
    },
    decode(J, ge) {
      const we = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let We = ge === void 0 ? we.len : we.pos + ge;
      const Ie = Ce();
      for (; we.pos < We; ) {
        const V = we.uint32();
        switch (V >>> 3) {
          case 1:
            Ie.protocol = we.int32();
            break;
          case 2:
            Ie.urls.push(we.string());
            break;
          default:
            we.skipType(V & 7);
            break;
        }
      }
      return Ie;
    },
    fromJSON(J) {
      return {
        protocol: Ge(J.protocol) ? O(J.protocol) : 0,
        urls: Array.isArray(J == null ? void 0 : J.urls) ? J.urls.map((ge) => String(ge)) : []
      };
    },
    toJSON(J) {
      const ge = {};
      return J.protocol !== void 0 && (ge.protocol = D(J.protocol)), J.urls ? ge.urls = J.urls.map((we) => we) : ge.urls = [], ge;
    },
    fromPartial(J) {
      var ge, we;
      const We = Ce();
      return We.protocol = (ge = J.protocol) !== null && ge !== void 0 ? ge : 0, We.urls = ((we = J.urls) === null || we === void 0 ? void 0 : we.map((Ie) => Ie)) || [], We;
    }
  };
  function De() {
    return {
      width: 0,
      height: 0,
      depth: 0,
      framerate: 0,
      audioCodec: 0,
      audioBitrate: 0,
      audioFrequency: 0,
      videoCodec: 0,
      videoBitrate: 0
    };
  }
  a.EncodingOptions = {
    encode(J, ge = l.default.Writer.create()) {
      return J.width !== void 0 && J.width !== 0 && ge.uint32(8).int32(J.width), J.height !== void 0 && J.height !== 0 && ge.uint32(16).int32(J.height), J.depth !== void 0 && J.depth !== 0 && ge.uint32(24).int32(J.depth), J.framerate !== void 0 && J.framerate !== 0 && ge.uint32(32).int32(J.framerate), J.audioCodec !== void 0 && J.audioCodec !== 0 && ge.uint32(40).int32(J.audioCodec), J.audioBitrate !== void 0 && J.audioBitrate !== 0 && ge.uint32(48).int32(J.audioBitrate), J.audioFrequency !== void 0 && J.audioFrequency !== 0 && ge.uint32(56).int32(J.audioFrequency), J.videoCodec !== void 0 && J.videoCodec !== 0 && ge.uint32(64).int32(J.videoCodec), J.videoBitrate !== void 0 && J.videoBitrate !== 0 && ge.uint32(72).int32(J.videoBitrate), ge;
    },
    decode(J, ge) {
      const we = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let We = ge === void 0 ? we.len : we.pos + ge;
      const Ie = De();
      for (; we.pos < We; ) {
        const V = we.uint32();
        switch (V >>> 3) {
          case 1:
            Ie.width = we.int32();
            break;
          case 2:
            Ie.height = we.int32();
            break;
          case 3:
            Ie.depth = we.int32();
            break;
          case 4:
            Ie.framerate = we.int32();
            break;
          case 5:
            Ie.audioCodec = we.int32();
            break;
          case 6:
            Ie.audioBitrate = we.int32();
            break;
          case 7:
            Ie.audioFrequency = we.int32();
            break;
          case 8:
            Ie.videoCodec = we.int32();
            break;
          case 9:
            Ie.videoBitrate = we.int32();
            break;
          default:
            we.skipType(V & 7);
            break;
        }
      }
      return Ie;
    },
    fromJSON(J) {
      return {
        width: Ge(J.width) ? Number(J.width) : 0,
        height: Ge(J.height) ? Number(J.height) : 0,
        depth: Ge(J.depth) ? Number(J.depth) : 0,
        framerate: Ge(J.framerate) ? Number(J.framerate) : 0,
        audioCodec: Ge(J.audioCodec) ? X(J.audioCodec) : 0,
        audioBitrate: Ge(J.audioBitrate) ? Number(J.audioBitrate) : 0,
        audioFrequency: Ge(J.audioFrequency) ? Number(J.audioFrequency) : 0,
        videoCodec: Ge(J.videoCodec) ? ae(J.videoCodec) : 0,
        videoBitrate: Ge(J.videoBitrate) ? Number(J.videoBitrate) : 0
      };
    },
    toJSON(J) {
      const ge = {};
      return J.width !== void 0 && (ge.width = Math.round(J.width)), J.height !== void 0 && (ge.height = Math.round(J.height)), J.depth !== void 0 && (ge.depth = Math.round(J.depth)), J.framerate !== void 0 && (ge.framerate = Math.round(J.framerate)), J.audioCodec !== void 0 && (ge.audioCodec = ne(J.audioCodec)), J.audioBitrate !== void 0 && (ge.audioBitrate = Math.round(J.audioBitrate)), J.audioFrequency !== void 0 && (ge.audioFrequency = Math.round(J.audioFrequency)), J.videoCodec !== void 0 && (ge.videoCodec = j(J.videoCodec)), J.videoBitrate !== void 0 && (ge.videoBitrate = Math.round(J.videoBitrate)), ge;
    },
    fromPartial(J) {
      var ge, we, We, Ie, V, Ee, de, ce, ve;
      const Pe = De();
      return Pe.width = (ge = J.width) !== null && ge !== void 0 ? ge : 0, Pe.height = (we = J.height) !== null && we !== void 0 ? we : 0, Pe.depth = (We = J.depth) !== null && We !== void 0 ? We : 0, Pe.framerate = (Ie = J.framerate) !== null && Ie !== void 0 ? Ie : 0, Pe.audioCodec = (V = J.audioCodec) !== null && V !== void 0 ? V : 0, Pe.audioBitrate = (Ee = J.audioBitrate) !== null && Ee !== void 0 ? Ee : 0, Pe.audioFrequency = (de = J.audioFrequency) !== null && de !== void 0 ? de : 0, Pe.videoCodec = (ce = J.videoCodec) !== null && ce !== void 0 ? ce : 0, Pe.videoBitrate = (ve = J.videoBitrate) !== null && ve !== void 0 ? ve : 0, Pe;
    }
  };
  function ye() {
    return { egressId: "", layout: "" };
  }
  a.UpdateLayoutRequest = {
    encode(J, ge = l.default.Writer.create()) {
      return J.egressId !== void 0 && J.egressId !== "" && ge.uint32(10).string(J.egressId), J.layout !== void 0 && J.layout !== "" && ge.uint32(18).string(J.layout), ge;
    },
    decode(J, ge) {
      const we = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let We = ge === void 0 ? we.len : we.pos + ge;
      const Ie = ye();
      for (; we.pos < We; ) {
        const V = we.uint32();
        switch (V >>> 3) {
          case 1:
            Ie.egressId = we.string();
            break;
          case 2:
            Ie.layout = we.string();
            break;
          default:
            we.skipType(V & 7);
            break;
        }
      }
      return Ie;
    },
    fromJSON(J) {
      return {
        egressId: Ge(J.egressId) ? String(J.egressId) : "",
        layout: Ge(J.layout) ? String(J.layout) : ""
      };
    },
    toJSON(J) {
      const ge = {};
      return J.egressId !== void 0 && (ge.egressId = J.egressId), J.layout !== void 0 && (ge.layout = J.layout), ge;
    },
    fromPartial(J) {
      var ge, we;
      const We = ye();
      return We.egressId = (ge = J.egressId) !== null && ge !== void 0 ? ge : "", We.layout = (we = J.layout) !== null && we !== void 0 ? we : "", We;
    }
  };
  function pe() {
    return { egressId: "", addOutputUrls: [], removeOutputUrls: [] };
  }
  a.UpdateStreamRequest = {
    encode(J, ge = l.default.Writer.create()) {
      if (J.egressId !== void 0 && J.egressId !== "" && ge.uint32(10).string(J.egressId), J.addOutputUrls !== void 0 && J.addOutputUrls.length !== 0)
        for (const we of J.addOutputUrls)
          ge.uint32(18).string(we);
      if (J.removeOutputUrls !== void 0 && J.removeOutputUrls.length !== 0)
        for (const we of J.removeOutputUrls)
          ge.uint32(26).string(we);
      return ge;
    },
    decode(J, ge) {
      const we = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let We = ge === void 0 ? we.len : we.pos + ge;
      const Ie = pe();
      for (; we.pos < We; ) {
        const V = we.uint32();
        switch (V >>> 3) {
          case 1:
            Ie.egressId = we.string();
            break;
          case 2:
            Ie.addOutputUrls.push(we.string());
            break;
          case 3:
            Ie.removeOutputUrls.push(we.string());
            break;
          default:
            we.skipType(V & 7);
            break;
        }
      }
      return Ie;
    },
    fromJSON(J) {
      return {
        egressId: Ge(J.egressId) ? String(J.egressId) : "",
        addOutputUrls: Array.isArray(J == null ? void 0 : J.addOutputUrls) ? J.addOutputUrls.map((ge) => String(ge)) : [],
        removeOutputUrls: Array.isArray(J == null ? void 0 : J.removeOutputUrls) ? J.removeOutputUrls.map((ge) => String(ge)) : []
      };
    },
    toJSON(J) {
      const ge = {};
      return J.egressId !== void 0 && (ge.egressId = J.egressId), J.addOutputUrls ? ge.addOutputUrls = J.addOutputUrls.map((we) => we) : ge.addOutputUrls = [], J.removeOutputUrls ? ge.removeOutputUrls = J.removeOutputUrls.map((we) => we) : ge.removeOutputUrls = [], ge;
    },
    fromPartial(J) {
      var ge, we, We;
      const Ie = pe();
      return Ie.egressId = (ge = J.egressId) !== null && ge !== void 0 ? ge : "", Ie.addOutputUrls = ((we = J.addOutputUrls) === null || we === void 0 ? void 0 : we.map((V) => V)) || [], Ie.removeOutputUrls = ((We = J.removeOutputUrls) === null || We === void 0 ? void 0 : We.map((V) => V)) || [], Ie;
    }
  };
  function Me() {
    return { roomName: "" };
  }
  a.ListEgressRequest = {
    encode(J, ge = l.default.Writer.create()) {
      return J.roomName !== void 0 && J.roomName !== "" && ge.uint32(10).string(J.roomName), ge;
    },
    decode(J, ge) {
      const we = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let We = ge === void 0 ? we.len : we.pos + ge;
      const Ie = Me();
      for (; we.pos < We; ) {
        const V = we.uint32();
        switch (V >>> 3) {
          case 1:
            Ie.roomName = we.string();
            break;
          default:
            we.skipType(V & 7);
            break;
        }
      }
      return Ie;
    },
    fromJSON(J) {
      return { roomName: Ge(J.roomName) ? String(J.roomName) : "" };
    },
    toJSON(J) {
      const ge = {};
      return J.roomName !== void 0 && (ge.roomName = J.roomName), ge;
    },
    fromPartial(J) {
      var ge;
      const we = Me();
      return we.roomName = (ge = J.roomName) !== null && ge !== void 0 ? ge : "", we;
    }
  };
  function Ne() {
    return { items: [] };
  }
  a.ListEgressResponse = {
    encode(J, ge = l.default.Writer.create()) {
      if (J.items !== void 0 && J.items.length !== 0)
        for (const we of J.items)
          a.EgressInfo.encode(we, ge.uint32(10).fork()).ldelim();
      return ge;
    },
    decode(J, ge) {
      const we = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let We = ge === void 0 ? we.len : we.pos + ge;
      const Ie = Ne();
      for (; we.pos < We; ) {
        const V = we.uint32();
        switch (V >>> 3) {
          case 1:
            Ie.items.push(a.EgressInfo.decode(we, we.uint32()));
            break;
          default:
            we.skipType(V & 7);
            break;
        }
      }
      return Ie;
    },
    fromJSON(J) {
      return { items: Array.isArray(J == null ? void 0 : J.items) ? J.items.map((ge) => a.EgressInfo.fromJSON(ge)) : [] };
    },
    toJSON(J) {
      const ge = {};
      return J.items ? ge.items = J.items.map((we) => we ? a.EgressInfo.toJSON(we) : void 0) : ge.items = [], ge;
    },
    fromPartial(J) {
      var ge;
      const we = Ne();
      return we.items = ((ge = J.items) === null || ge === void 0 ? void 0 : ge.map((We) => a.EgressInfo.fromPartial(We))) || [], we;
    }
  };
  function Ue() {
    return { egressId: "" };
  }
  a.StopEgressRequest = {
    encode(J, ge = l.default.Writer.create()) {
      return J.egressId !== void 0 && J.egressId !== "" && ge.uint32(10).string(J.egressId), ge;
    },
    decode(J, ge) {
      const we = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let We = ge === void 0 ? we.len : we.pos + ge;
      const Ie = Ue();
      for (; we.pos < We; ) {
        const V = we.uint32();
        switch (V >>> 3) {
          case 1:
            Ie.egressId = we.string();
            break;
          default:
            we.skipType(V & 7);
            break;
        }
      }
      return Ie;
    },
    fromJSON(J) {
      return { egressId: Ge(J.egressId) ? String(J.egressId) : "" };
    },
    toJSON(J) {
      const ge = {};
      return J.egressId !== void 0 && (ge.egressId = J.egressId), ge;
    },
    fromPartial(J) {
      var ge;
      const we = Ue();
      return we.egressId = (ge = J.egressId) !== null && ge !== void 0 ? ge : "", we;
    }
  };
  function oe() {
    return {
      egressId: "",
      roomId: "",
      roomName: "",
      status: 0,
      startedAt: 0,
      endedAt: 0,
      error: "",
      roomComposite: void 0,
      trackComposite: void 0,
      track: void 0,
      web: void 0,
      stream: void 0,
      file: void 0,
      segments: void 0
    };
  }
  a.EgressInfo = {
    encode(J, ge = l.default.Writer.create()) {
      return J.egressId !== void 0 && J.egressId !== "" && ge.uint32(10).string(J.egressId), J.roomId !== void 0 && J.roomId !== "" && ge.uint32(18).string(J.roomId), J.roomName !== void 0 && J.roomName !== "" && ge.uint32(106).string(J.roomName), J.status !== void 0 && J.status !== 0 && ge.uint32(24).int32(J.status), J.startedAt !== void 0 && J.startedAt !== 0 && ge.uint32(80).int64(J.startedAt), J.endedAt !== void 0 && J.endedAt !== 0 && ge.uint32(88).int64(J.endedAt), J.error !== void 0 && J.error !== "" && ge.uint32(74).string(J.error), J.roomComposite !== void 0 && a.RoomCompositeEgressRequest.encode(J.roomComposite, ge.uint32(34).fork()).ldelim(), J.trackComposite !== void 0 && a.TrackCompositeEgressRequest.encode(J.trackComposite, ge.uint32(42).fork()).ldelim(), J.track !== void 0 && a.TrackEgressRequest.encode(J.track, ge.uint32(50).fork()).ldelim(), J.web !== void 0 && a.WebEgressRequest.encode(J.web, ge.uint32(114).fork()).ldelim(), J.stream !== void 0 && a.StreamInfoList.encode(J.stream, ge.uint32(58).fork()).ldelim(), J.file !== void 0 && a.FileInfo.encode(J.file, ge.uint32(66).fork()).ldelim(), J.segments !== void 0 && a.SegmentsInfo.encode(J.segments, ge.uint32(98).fork()).ldelim(), ge;
    },
    decode(J, ge) {
      const we = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let We = ge === void 0 ? we.len : we.pos + ge;
      const Ie = oe();
      for (; we.pos < We; ) {
        const V = we.uint32();
        switch (V >>> 3) {
          case 1:
            Ie.egressId = we.string();
            break;
          case 2:
            Ie.roomId = we.string();
            break;
          case 13:
            Ie.roomName = we.string();
            break;
          case 3:
            Ie.status = we.int32();
            break;
          case 10:
            Ie.startedAt = yt(we.int64());
            break;
          case 11:
            Ie.endedAt = yt(we.int64());
            break;
          case 9:
            Ie.error = we.string();
            break;
          case 4:
            Ie.roomComposite = a.RoomCompositeEgressRequest.decode(we, we.uint32());
            break;
          case 5:
            Ie.trackComposite = a.TrackCompositeEgressRequest.decode(we, we.uint32());
            break;
          case 6:
            Ie.track = a.TrackEgressRequest.decode(we, we.uint32());
            break;
          case 14:
            Ie.web = a.WebEgressRequest.decode(we, we.uint32());
            break;
          case 7:
            Ie.stream = a.StreamInfoList.decode(we, we.uint32());
            break;
          case 8:
            Ie.file = a.FileInfo.decode(we, we.uint32());
            break;
          case 12:
            Ie.segments = a.SegmentsInfo.decode(we, we.uint32());
            break;
          default:
            we.skipType(V & 7);
            break;
        }
      }
      return Ie;
    },
    fromJSON(J) {
      return {
        egressId: Ge(J.egressId) ? String(J.egressId) : "",
        roomId: Ge(J.roomId) ? String(J.roomId) : "",
        roomName: Ge(J.roomName) ? String(J.roomName) : "",
        status: Ge(J.status) ? ke(J.status) : 0,
        startedAt: Ge(J.startedAt) ? Number(J.startedAt) : 0,
        endedAt: Ge(J.endedAt) ? Number(J.endedAt) : 0,
        error: Ge(J.error) ? String(J.error) : "",
        roomComposite: Ge(J.roomComposite) ? a.RoomCompositeEgressRequest.fromJSON(J.roomComposite) : void 0,
        trackComposite: Ge(J.trackComposite) ? a.TrackCompositeEgressRequest.fromJSON(J.trackComposite) : void 0,
        track: Ge(J.track) ? a.TrackEgressRequest.fromJSON(J.track) : void 0,
        web: Ge(J.web) ? a.WebEgressRequest.fromJSON(J.web) : void 0,
        stream: Ge(J.stream) ? a.StreamInfoList.fromJSON(J.stream) : void 0,
        file: Ge(J.file) ? a.FileInfo.fromJSON(J.file) : void 0,
        segments: Ge(J.segments) ? a.SegmentsInfo.fromJSON(J.segments) : void 0
      };
    },
    toJSON(J) {
      const ge = {};
      return J.egressId !== void 0 && (ge.egressId = J.egressId), J.roomId !== void 0 && (ge.roomId = J.roomId), J.roomName !== void 0 && (ge.roomName = J.roomName), J.status !== void 0 && (ge.status = Te(J.status)), J.startedAt !== void 0 && (ge.startedAt = Math.round(J.startedAt)), J.endedAt !== void 0 && (ge.endedAt = Math.round(J.endedAt)), J.error !== void 0 && (ge.error = J.error), J.roomComposite !== void 0 && (ge.roomComposite = J.roomComposite ? a.RoomCompositeEgressRequest.toJSON(J.roomComposite) : void 0), J.trackComposite !== void 0 && (ge.trackComposite = J.trackComposite ? a.TrackCompositeEgressRequest.toJSON(J.trackComposite) : void 0), J.track !== void 0 && (ge.track = J.track ? a.TrackEgressRequest.toJSON(J.track) : void 0), J.web !== void 0 && (ge.web = J.web ? a.WebEgressRequest.toJSON(J.web) : void 0), J.stream !== void 0 && (ge.stream = J.stream ? a.StreamInfoList.toJSON(J.stream) : void 0), J.file !== void 0 && (ge.file = J.file ? a.FileInfo.toJSON(J.file) : void 0), J.segments !== void 0 && (ge.segments = J.segments ? a.SegmentsInfo.toJSON(J.segments) : void 0), ge;
    },
    fromPartial(J) {
      var ge, we, We, Ie, V, Ee, de;
      const ce = oe();
      return ce.egressId = (ge = J.egressId) !== null && ge !== void 0 ? ge : "", ce.roomId = (we = J.roomId) !== null && we !== void 0 ? we : "", ce.roomName = (We = J.roomName) !== null && We !== void 0 ? We : "", ce.status = (Ie = J.status) !== null && Ie !== void 0 ? Ie : 0, ce.startedAt = (V = J.startedAt) !== null && V !== void 0 ? V : 0, ce.endedAt = (Ee = J.endedAt) !== null && Ee !== void 0 ? Ee : 0, ce.error = (de = J.error) !== null && de !== void 0 ? de : "", ce.roomComposite = J.roomComposite !== void 0 && J.roomComposite !== null ? a.RoomCompositeEgressRequest.fromPartial(J.roomComposite) : void 0, ce.trackComposite = J.trackComposite !== void 0 && J.trackComposite !== null ? a.TrackCompositeEgressRequest.fromPartial(J.trackComposite) : void 0, ce.track = J.track !== void 0 && J.track !== null ? a.TrackEgressRequest.fromPartial(J.track) : void 0, ce.web = J.web !== void 0 && J.web !== null ? a.WebEgressRequest.fromPartial(J.web) : void 0, ce.stream = J.stream !== void 0 && J.stream !== null ? a.StreamInfoList.fromPartial(J.stream) : void 0, ce.file = J.file !== void 0 && J.file !== null ? a.FileInfo.fromPartial(J.file) : void 0, ce.segments = J.segments !== void 0 && J.segments !== null ? a.SegmentsInfo.fromPartial(J.segments) : void 0, ce;
    }
  };
  function A() {
    return { info: [] };
  }
  a.StreamInfoList = {
    encode(J, ge = l.default.Writer.create()) {
      if (J.info !== void 0 && J.info.length !== 0)
        for (const we of J.info)
          a.StreamInfo.encode(we, ge.uint32(10).fork()).ldelim();
      return ge;
    },
    decode(J, ge) {
      const we = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let We = ge === void 0 ? we.len : we.pos + ge;
      const Ie = A();
      for (; we.pos < We; ) {
        const V = we.uint32();
        switch (V >>> 3) {
          case 1:
            Ie.info.push(a.StreamInfo.decode(we, we.uint32()));
            break;
          default:
            we.skipType(V & 7);
            break;
        }
      }
      return Ie;
    },
    fromJSON(J) {
      return { info: Array.isArray(J == null ? void 0 : J.info) ? J.info.map((ge) => a.StreamInfo.fromJSON(ge)) : [] };
    },
    toJSON(J) {
      const ge = {};
      return J.info ? ge.info = J.info.map((we) => we ? a.StreamInfo.toJSON(we) : void 0) : ge.info = [], ge;
    },
    fromPartial(J) {
      var ge;
      const we = A();
      return we.info = ((ge = J.info) === null || ge === void 0 ? void 0 : ge.map((We) => a.StreamInfo.fromPartial(We))) || [], we;
    }
  };
  function re() {
    return { url: "", startedAt: 0, endedAt: 0, duration: 0, status: 0 };
  }
  a.StreamInfo = {
    encode(J, ge = l.default.Writer.create()) {
      return J.url !== void 0 && J.url !== "" && ge.uint32(10).string(J.url), J.startedAt !== void 0 && J.startedAt !== 0 && ge.uint32(16).int64(J.startedAt), J.endedAt !== void 0 && J.endedAt !== 0 && ge.uint32(24).int64(J.endedAt), J.duration !== void 0 && J.duration !== 0 && ge.uint32(32).int64(J.duration), J.status !== void 0 && J.status !== 0 && ge.uint32(40).int32(J.status), ge;
    },
    decode(J, ge) {
      const we = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let We = ge === void 0 ? we.len : we.pos + ge;
      const Ie = re();
      for (; we.pos < We; ) {
        const V = we.uint32();
        switch (V >>> 3) {
          case 1:
            Ie.url = we.string();
            break;
          case 2:
            Ie.startedAt = yt(we.int64());
            break;
          case 3:
            Ie.endedAt = yt(we.int64());
            break;
          case 4:
            Ie.duration = yt(we.int64());
            break;
          case 5:
            Ie.status = we.int32();
            break;
          default:
            we.skipType(V & 7);
            break;
        }
      }
      return Ie;
    },
    fromJSON(J) {
      return {
        url: Ge(J.url) ? String(J.url) : "",
        startedAt: Ge(J.startedAt) ? Number(J.startedAt) : 0,
        endedAt: Ge(J.endedAt) ? Number(J.endedAt) : 0,
        duration: Ge(J.duration) ? Number(J.duration) : 0,
        status: Ge(J.status) ? z(J.status) : 0
      };
    },
    toJSON(J) {
      const ge = {};
      return J.url !== void 0 && (ge.url = J.url), J.startedAt !== void 0 && (ge.startedAt = Math.round(J.startedAt)), J.endedAt !== void 0 && (ge.endedAt = Math.round(J.endedAt)), J.duration !== void 0 && (ge.duration = Math.round(J.duration)), J.status !== void 0 && (ge.status = P(J.status)), ge;
    },
    fromPartial(J) {
      var ge, we, We, Ie, V;
      const Ee = re();
      return Ee.url = (ge = J.url) !== null && ge !== void 0 ? ge : "", Ee.startedAt = (we = J.startedAt) !== null && we !== void 0 ? we : 0, Ee.endedAt = (We = J.endedAt) !== null && We !== void 0 ? We : 0, Ee.duration = (Ie = J.duration) !== null && Ie !== void 0 ? Ie : 0, Ee.status = (V = J.status) !== null && V !== void 0 ? V : 0, Ee;
    }
  };
  function le() {
    return { filename: "", startedAt: 0, endedAt: 0, duration: 0, size: 0, location: "" };
  }
  a.FileInfo = {
    encode(J, ge = l.default.Writer.create()) {
      return J.filename !== void 0 && J.filename !== "" && ge.uint32(10).string(J.filename), J.startedAt !== void 0 && J.startedAt !== 0 && ge.uint32(16).int64(J.startedAt), J.endedAt !== void 0 && J.endedAt !== 0 && ge.uint32(24).int64(J.endedAt), J.duration !== void 0 && J.duration !== 0 && ge.uint32(48).int64(J.duration), J.size !== void 0 && J.size !== 0 && ge.uint32(32).int64(J.size), J.location !== void 0 && J.location !== "" && ge.uint32(42).string(J.location), ge;
    },
    decode(J, ge) {
      const we = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let We = ge === void 0 ? we.len : we.pos + ge;
      const Ie = le();
      for (; we.pos < We; ) {
        const V = we.uint32();
        switch (V >>> 3) {
          case 1:
            Ie.filename = we.string();
            break;
          case 2:
            Ie.startedAt = yt(we.int64());
            break;
          case 3:
            Ie.endedAt = yt(we.int64());
            break;
          case 6:
            Ie.duration = yt(we.int64());
            break;
          case 4:
            Ie.size = yt(we.int64());
            break;
          case 5:
            Ie.location = we.string();
            break;
          default:
            we.skipType(V & 7);
            break;
        }
      }
      return Ie;
    },
    fromJSON(J) {
      return {
        filename: Ge(J.filename) ? String(J.filename) : "",
        startedAt: Ge(J.startedAt) ? Number(J.startedAt) : 0,
        endedAt: Ge(J.endedAt) ? Number(J.endedAt) : 0,
        duration: Ge(J.duration) ? Number(J.duration) : 0,
        size: Ge(J.size) ? Number(J.size) : 0,
        location: Ge(J.location) ? String(J.location) : ""
      };
    },
    toJSON(J) {
      const ge = {};
      return J.filename !== void 0 && (ge.filename = J.filename), J.startedAt !== void 0 && (ge.startedAt = Math.round(J.startedAt)), J.endedAt !== void 0 && (ge.endedAt = Math.round(J.endedAt)), J.duration !== void 0 && (ge.duration = Math.round(J.duration)), J.size !== void 0 && (ge.size = Math.round(J.size)), J.location !== void 0 && (ge.location = J.location), ge;
    },
    fromPartial(J) {
      var ge, we, We, Ie, V, Ee;
      const de = le();
      return de.filename = (ge = J.filename) !== null && ge !== void 0 ? ge : "", de.startedAt = (we = J.startedAt) !== null && we !== void 0 ? we : 0, de.endedAt = (We = J.endedAt) !== null && We !== void 0 ? We : 0, de.duration = (Ie = J.duration) !== null && Ie !== void 0 ? Ie : 0, de.size = (V = J.size) !== null && V !== void 0 ? V : 0, de.location = (Ee = J.location) !== null && Ee !== void 0 ? Ee : "", de;
    }
  };
  function $e() {
    return { playlistName: "", duration: 0, size: 0, playlistLocation: "", segmentCount: 0, startedAt: 0, endedAt: 0 };
  }
  a.SegmentsInfo = {
    encode(J, ge = l.default.Writer.create()) {
      return J.playlistName !== void 0 && J.playlistName !== "" && ge.uint32(10).string(J.playlistName), J.duration !== void 0 && J.duration !== 0 && ge.uint32(16).int64(J.duration), J.size !== void 0 && J.size !== 0 && ge.uint32(24).int64(J.size), J.playlistLocation !== void 0 && J.playlistLocation !== "" && ge.uint32(34).string(J.playlistLocation), J.segmentCount !== void 0 && J.segmentCount !== 0 && ge.uint32(40).int64(J.segmentCount), J.startedAt !== void 0 && J.startedAt !== 0 && ge.uint32(48).int64(J.startedAt), J.endedAt !== void 0 && J.endedAt !== 0 && ge.uint32(56).int64(J.endedAt), ge;
    },
    decode(J, ge) {
      const we = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let We = ge === void 0 ? we.len : we.pos + ge;
      const Ie = $e();
      for (; we.pos < We; ) {
        const V = we.uint32();
        switch (V >>> 3) {
          case 1:
            Ie.playlistName = we.string();
            break;
          case 2:
            Ie.duration = yt(we.int64());
            break;
          case 3:
            Ie.size = yt(we.int64());
            break;
          case 4:
            Ie.playlistLocation = we.string();
            break;
          case 5:
            Ie.segmentCount = yt(we.int64());
            break;
          case 6:
            Ie.startedAt = yt(we.int64());
            break;
          case 7:
            Ie.endedAt = yt(we.int64());
            break;
          default:
            we.skipType(V & 7);
            break;
        }
      }
      return Ie;
    },
    fromJSON(J) {
      return {
        playlistName: Ge(J.playlistName) ? String(J.playlistName) : "",
        duration: Ge(J.duration) ? Number(J.duration) : 0,
        size: Ge(J.size) ? Number(J.size) : 0,
        playlistLocation: Ge(J.playlistLocation) ? String(J.playlistLocation) : "",
        segmentCount: Ge(J.segmentCount) ? Number(J.segmentCount) : 0,
        startedAt: Ge(J.startedAt) ? Number(J.startedAt) : 0,
        endedAt: Ge(J.endedAt) ? Number(J.endedAt) : 0
      };
    },
    toJSON(J) {
      const ge = {};
      return J.playlistName !== void 0 && (ge.playlistName = J.playlistName), J.duration !== void 0 && (ge.duration = Math.round(J.duration)), J.size !== void 0 && (ge.size = Math.round(J.size)), J.playlistLocation !== void 0 && (ge.playlistLocation = J.playlistLocation), J.segmentCount !== void 0 && (ge.segmentCount = Math.round(J.segmentCount)), J.startedAt !== void 0 && (ge.startedAt = Math.round(J.startedAt)), J.endedAt !== void 0 && (ge.endedAt = Math.round(J.endedAt)), ge;
    },
    fromPartial(J) {
      var ge, we, We, Ie, V, Ee, de;
      const ce = $e();
      return ce.playlistName = (ge = J.playlistName) !== null && ge !== void 0 ? ge : "", ce.duration = (we = J.duration) !== null && we !== void 0 ? we : 0, ce.size = (We = J.size) !== null && We !== void 0 ? We : 0, ce.playlistLocation = (Ie = J.playlistLocation) !== null && Ie !== void 0 ? Ie : "", ce.segmentCount = (V = J.segmentCount) !== null && V !== void 0 ? V : 0, ce.startedAt = (Ee = J.startedAt) !== null && Ee !== void 0 ? Ee : 0, ce.endedAt = (de = J.endedAt) !== null && de !== void 0 ? de : 0, ce;
    }
  };
  function Oe() {
    return { filepath: "", disableManifest: !1, s3: void 0, gcp: void 0, azure: void 0 };
  }
  a.AutoTrackEgress = {
    encode(J, ge = l.default.Writer.create()) {
      return J.filepath !== void 0 && J.filepath !== "" && ge.uint32(10).string(J.filepath), J.disableManifest === !0 && ge.uint32(40).bool(J.disableManifest), J.s3 !== void 0 && a.S3Upload.encode(J.s3, ge.uint32(18).fork()).ldelim(), J.gcp !== void 0 && a.GCPUpload.encode(J.gcp, ge.uint32(26).fork()).ldelim(), J.azure !== void 0 && a.AzureBlobUpload.encode(J.azure, ge.uint32(34).fork()).ldelim(), ge;
    },
    decode(J, ge) {
      const we = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let We = ge === void 0 ? we.len : we.pos + ge;
      const Ie = Oe();
      for (; we.pos < We; ) {
        const V = we.uint32();
        switch (V >>> 3) {
          case 1:
            Ie.filepath = we.string();
            break;
          case 5:
            Ie.disableManifest = we.bool();
            break;
          case 2:
            Ie.s3 = a.S3Upload.decode(we, we.uint32());
            break;
          case 3:
            Ie.gcp = a.GCPUpload.decode(we, we.uint32());
            break;
          case 4:
            Ie.azure = a.AzureBlobUpload.decode(we, we.uint32());
            break;
          default:
            we.skipType(V & 7);
            break;
        }
      }
      return Ie;
    },
    fromJSON(J) {
      return {
        filepath: Ge(J.filepath) ? String(J.filepath) : "",
        disableManifest: Ge(J.disableManifest) ? !!J.disableManifest : !1,
        s3: Ge(J.s3) ? a.S3Upload.fromJSON(J.s3) : void 0,
        gcp: Ge(J.gcp) ? a.GCPUpload.fromJSON(J.gcp) : void 0,
        azure: Ge(J.azure) ? a.AzureBlobUpload.fromJSON(J.azure) : void 0
      };
    },
    toJSON(J) {
      const ge = {};
      return J.filepath !== void 0 && (ge.filepath = J.filepath), J.disableManifest !== void 0 && (ge.disableManifest = J.disableManifest), J.s3 !== void 0 && (ge.s3 = J.s3 ? a.S3Upload.toJSON(J.s3) : void 0), J.gcp !== void 0 && (ge.gcp = J.gcp ? a.GCPUpload.toJSON(J.gcp) : void 0), J.azure !== void 0 && (ge.azure = J.azure ? a.AzureBlobUpload.toJSON(J.azure) : void 0), ge;
    },
    fromPartial(J) {
      var ge, we;
      const We = Oe();
      return We.filepath = (ge = J.filepath) !== null && ge !== void 0 ? ge : "", We.disableManifest = (we = J.disableManifest) !== null && we !== void 0 ? we : !1, We.s3 = J.s3 !== void 0 && J.s3 !== null ? a.S3Upload.fromPartial(J.s3) : void 0, We.gcp = J.gcp !== void 0 && J.gcp !== null ? a.GCPUpload.fromPartial(J.gcp) : void 0, We.azure = J.azure !== void 0 && J.azure !== null ? a.AzureBlobUpload.fromPartial(J.azure) : void 0, We;
    }
  };
  var Fe = (() => {
    if (typeof Fe < "u")
      return Fe;
    if (typeof self < "u")
      return self;
    if (typeof window < "u")
      return window;
    if (typeof commonjsGlobal$1 < "u")
      return commonjsGlobal$1;
    throw "Unable to locate global object";
  })();
  function Ze(J) {
    if (Fe.Buffer)
      return Uint8Array.from(Fe.Buffer.from(J, "base64"));
    {
      const ge = Fe.atob(J), we = new Uint8Array(ge.length);
      for (let We = 0; We < ge.length; ++We)
        we[We] = ge.charCodeAt(We);
      return we;
    }
  }
  function qe(J) {
    if (Fe.Buffer)
      return Fe.Buffer.from(J).toString("base64");
    {
      const ge = [];
      return J.forEach((we) => {
        ge.push(String.fromCharCode(we));
      }), Fe.btoa(ge.join(""));
    }
  }
  function yt(J) {
    if (J.gt(Number.MAX_SAFE_INTEGER))
      throw new Fe.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    return J.toNumber();
  }
  l.default.util.Long !== c.default && (l.default.util.Long = c.default, l.default.configure());
  function Xe(J) {
    return typeof J == "object" && J !== null;
  }
  function Ge(J) {
    return J != null;
  }
})(livekit_egress);
var ServiceBase$1 = {};
Object.defineProperty(ServiceBase$1, "__esModule", { value: !0 });
const AccessToken_1$1 = AccessToken$1;
class ServiceBase {
  /**
   * @param apiKey API Key.
   * @param secret API Secret.
   * @param ttl token TTL
   */
  constructor(u, c, l) {
    this.apiKey = u, this.secret = c, this.ttl = l || "10m";
  }
  authHeader(u) {
    const c = new AccessToken_1$1.AccessToken(this.apiKey, this.secret, { ttl: this.ttl });
    return c.addGrant(u), {
      Authorization: `Bearer ${c.toJwt()}`
    };
  }
}
ServiceBase$1.default = ServiceBase;
var TwirpRPC = {}, axios$2 = { exports: {} }, bind$2 = function a(u, c) {
  return function() {
    for (var v = new Array(arguments.length), p = 0; p < v.length; p++)
      v[p] = arguments[p];
    return u.apply(c, v);
  };
}, bind$1 = bind$2, toString = Object.prototype.toString;
function isArray$1(a) {
  return toString.call(a) === "[object Array]";
}
function isUndefined(a) {
  return typeof a > "u";
}
function isBuffer(a) {
  return a !== null && !isUndefined(a) && a.constructor !== null && !isUndefined(a.constructor) && typeof a.constructor.isBuffer == "function" && a.constructor.isBuffer(a);
}
function isArrayBuffer(a) {
  return toString.call(a) === "[object ArrayBuffer]";
}
function isFormData(a) {
  return typeof FormData < "u" && a instanceof FormData;
}
function isArrayBufferView(a) {
  var u;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? u = ArrayBuffer.isView(a) : u = a && a.buffer && a.buffer instanceof ArrayBuffer, u;
}
function isString(a) {
  return typeof a == "string";
}
function isNumber(a) {
  return typeof a == "number";
}
function isObject$2(a) {
  return a !== null && typeof a == "object";
}
function isPlainObject(a) {
  if (toString.call(a) !== "[object Object]")
    return !1;
  var u = Object.getPrototypeOf(a);
  return u === null || u === Object.prototype;
}
function isDate(a) {
  return toString.call(a) === "[object Date]";
}
function isFile(a) {
  return toString.call(a) === "[object File]";
}
function isBlob(a) {
  return toString.call(a) === "[object Blob]";
}
function isFunction(a) {
  return toString.call(a) === "[object Function]";
}
function isStream(a) {
  return isObject$2(a) && isFunction(a.pipe);
}
function isURLSearchParams(a) {
  return typeof URLSearchParams < "u" && a instanceof URLSearchParams;
}
function trim$1(a) {
  return a.trim ? a.trim() : a.replace(/^\s+|\s+$/g, "");
}
function isStandardBrowserEnv() {
  return typeof navigator < "u" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS") ? !1 : typeof window < "u" && typeof document < "u";
}
function forEach(a, u) {
  if (!(a === null || typeof a > "u"))
    if (typeof a != "object" && (a = [a]), isArray$1(a))
      for (var c = 0, l = a.length; c < l; c++)
        u.call(null, a[c], c, a);
    else
      for (var v in a)
        Object.prototype.hasOwnProperty.call(a, v) && u.call(null, a[v], v, a);
}
function merge() {
  var a = {};
  function u(v, p) {
    isPlainObject(a[p]) && isPlainObject(v) ? a[p] = merge(a[p], v) : isPlainObject(v) ? a[p] = merge({}, v) : isArray$1(v) ? a[p] = v.slice() : a[p] = v;
  }
  for (var c = 0, l = arguments.length; c < l; c++)
    forEach(arguments[c], u);
  return a;
}
function extend(a, u, c) {
  return forEach(u, function(v, p) {
    c && typeof v == "function" ? a[p] = bind$1(v, c) : a[p] = v;
  }), a;
}
function stripBOM(a) {
  return a.charCodeAt(0) === 65279 && (a = a.slice(1)), a;
}
var utils$9 = {
  isArray: isArray$1,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isObject: isObject$2,
  isPlainObject,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isFunction,
  isStream,
  isURLSearchParams,
  isStandardBrowserEnv,
  forEach,
  merge,
  extend,
  trim: trim$1,
  stripBOM
}, utils$8 = utils$9;
function encode(a) {
  return encodeURIComponent(a).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
var buildURL$1 = function a(u, c, l) {
  if (!c)
    return u;
  var v;
  if (l)
    v = l(c);
  else if (utils$8.isURLSearchParams(c))
    v = c.toString();
  else {
    var p = [];
    utils$8.forEach(c, function(O, D) {
      O === null || typeof O > "u" || (utils$8.isArray(O) ? D = D + "[]" : O = [O], utils$8.forEach(O, function(H) {
        utils$8.isDate(H) ? H = H.toISOString() : utils$8.isObject(H) && (H = JSON.stringify(H)), p.push(encode(D) + "=" + encode(H));
      }));
    }), v = p.join("&");
  }
  if (v) {
    var _ = u.indexOf("#");
    _ !== -1 && (u = u.slice(0, _)), u += (u.indexOf("?") === -1 ? "?" : "&") + v;
  }
  return u;
}, utils$7 = utils$9;
function InterceptorManager$1() {
  this.handlers = [];
}
InterceptorManager$1.prototype.use = function a(u, c, l) {
  return this.handlers.push({
    fulfilled: u,
    rejected: c,
    synchronous: l ? l.synchronous : !1,
    runWhen: l ? l.runWhen : null
  }), this.handlers.length - 1;
};
InterceptorManager$1.prototype.eject = function a(u) {
  this.handlers[u] && (this.handlers[u] = null);
};
InterceptorManager$1.prototype.forEach = function a(u) {
  utils$7.forEach(this.handlers, function(l) {
    l !== null && u(l);
  });
};
var InterceptorManager_1 = InterceptorManager$1, utils$6 = utils$9, normalizeHeaderName$1 = function a(u, c) {
  utils$6.forEach(u, function(v, p) {
    p !== c && p.toUpperCase() === c.toUpperCase() && (u[c] = v, delete u[p]);
  });
}, enhanceError$1 = function a(u, c, l, v, p) {
  return u.config = c, l && (u.code = l), u.request = v, u.response = p, u.isAxiosError = !0, u.toJSON = function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code
    };
  }, u;
}, createError, hasRequiredCreateError;
function requireCreateError() {
  if (hasRequiredCreateError)
    return createError;
  hasRequiredCreateError = 1;
  var a = enhanceError$1;
  return createError = function(c, l, v, p, _) {
    var k = new Error(c);
    return a(k, l, v, p, _);
  }, createError;
}
var settle, hasRequiredSettle;
function requireSettle() {
  if (hasRequiredSettle)
    return settle;
  hasRequiredSettle = 1;
  var a = requireCreateError();
  return settle = function(c, l, v) {
    var p = v.config.validateStatus;
    !v.status || !p || p(v.status) ? c(v) : l(a(
      "Request failed with status code " + v.status,
      v.config,
      null,
      v.request,
      v
    ));
  }, settle;
}
var cookies, hasRequiredCookies;
function requireCookies() {
  if (hasRequiredCookies)
    return cookies;
  hasRequiredCookies = 1;
  var a = utils$9;
  return cookies = a.isStandardBrowserEnv() ? (
    // Standard browser envs support document.cookie
    /* @__PURE__ */ function() {
      return {
        write: function(l, v, p, _, k, O) {
          var D = [];
          D.push(l + "=" + encodeURIComponent(v)), a.isNumber(p) && D.push("expires=" + new Date(p).toGMTString()), a.isString(_) && D.push("path=" + _), a.isString(k) && D.push("domain=" + k), O === !0 && D.push("secure"), document.cookie = D.join("; ");
        },
        read: function(l) {
          var v = document.cookie.match(new RegExp("(^|;\\s*)(" + l + ")=([^;]*)"));
          return v ? decodeURIComponent(v[3]) : null;
        },
        remove: function(l) {
          this.write(l, "", Date.now() - 864e5);
        }
      };
    }()
  ) : (
    // Non standard browser env (web workers, react-native) lack needed support.
    /* @__PURE__ */ function() {
      return {
        write: function() {
        },
        read: function() {
          return null;
        },
        remove: function() {
        }
      };
    }()
  ), cookies;
}
var isAbsoluteURL, hasRequiredIsAbsoluteURL;
function requireIsAbsoluteURL() {
  return hasRequiredIsAbsoluteURL || (hasRequiredIsAbsoluteURL = 1, isAbsoluteURL = function(u) {
    return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(u);
  }), isAbsoluteURL;
}
var combineURLs, hasRequiredCombineURLs;
function requireCombineURLs() {
  return hasRequiredCombineURLs || (hasRequiredCombineURLs = 1, combineURLs = function(u, c) {
    return c ? u.replace(/\/+$/, "") + "/" + c.replace(/^\/+/, "") : u;
  }), combineURLs;
}
var buildFullPath, hasRequiredBuildFullPath;
function requireBuildFullPath() {
  if (hasRequiredBuildFullPath)
    return buildFullPath;
  hasRequiredBuildFullPath = 1;
  var a = requireIsAbsoluteURL(), u = requireCombineURLs();
  return buildFullPath = function(l, v) {
    return l && !a(v) ? u(l, v) : v;
  }, buildFullPath;
}
var parseHeaders, hasRequiredParseHeaders;
function requireParseHeaders() {
  if (hasRequiredParseHeaders)
    return parseHeaders;
  hasRequiredParseHeaders = 1;
  var a = utils$9, u = [
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ];
  return parseHeaders = function(l) {
    var v = {}, p, _, k;
    return l && a.forEach(l.split(`
`), function(D) {
      if (k = D.indexOf(":"), p = a.trim(D.substr(0, k)).toLowerCase(), _ = a.trim(D.substr(k + 1)), p) {
        if (v[p] && u.indexOf(p) >= 0)
          return;
        p === "set-cookie" ? v[p] = (v[p] ? v[p] : []).concat([_]) : v[p] = v[p] ? v[p] + ", " + _ : _;
      }
    }), v;
  }, parseHeaders;
}
var isURLSameOrigin, hasRequiredIsURLSameOrigin;
function requireIsURLSameOrigin() {
  if (hasRequiredIsURLSameOrigin)
    return isURLSameOrigin;
  hasRequiredIsURLSameOrigin = 1;
  var a = utils$9;
  return isURLSameOrigin = a.isStandardBrowserEnv() ? (
    // Standard browser envs have full support of the APIs needed to test
    // whether the request URL is of the same origin as current location.
    function() {
      var c = /(msie|trident)/i.test(navigator.userAgent), l = document.createElement("a"), v;
      function p(_) {
        var k = _;
        return c && (l.setAttribute("href", k), k = l.href), l.setAttribute("href", k), {
          href: l.href,
          protocol: l.protocol ? l.protocol.replace(/:$/, "") : "",
          host: l.host,
          search: l.search ? l.search.replace(/^\?/, "") : "",
          hash: l.hash ? l.hash.replace(/^#/, "") : "",
          hostname: l.hostname,
          port: l.port,
          pathname: l.pathname.charAt(0) === "/" ? l.pathname : "/" + l.pathname
        };
      }
      return v = p(window.location.href), function(k) {
        var O = a.isString(k) ? p(k) : k;
        return O.protocol === v.protocol && O.host === v.host;
      };
    }()
  ) : (
    // Non standard browser envs (web workers, react-native) lack needed support.
    /* @__PURE__ */ function() {
      return function() {
        return !0;
      };
    }()
  ), isURLSameOrigin;
}
var xhr, hasRequiredXhr;
function requireXhr() {
  if (hasRequiredXhr)
    return xhr;
  hasRequiredXhr = 1;
  var a = utils$9, u = requireSettle(), c = requireCookies(), l = buildURL$1, v = requireBuildFullPath(), p = requireParseHeaders(), _ = requireIsURLSameOrigin(), k = requireCreateError();
  return xhr = function(D) {
    return new Promise(function(H, Z) {
      var ee = D.data, X = D.headers, ne = D.responseType;
      a.isFormData(ee) && delete X["Content-Type"];
      var Q = new XMLHttpRequest();
      if (D.auth) {
        var ae = D.auth.username || "", j = D.auth.password ? unescape(encodeURIComponent(D.auth.password)) : "";
        X.Authorization = "Basic " + btoa(ae + ":" + j);
      }
      var ue = v(D.baseURL, D.url);
      Q.open(D.method.toUpperCase(), l(ue, D.params, D.paramsSerializer), !0), Q.timeout = D.timeout;
      function he() {
        if (Q) {
          var be = "getAllResponseHeaders" in Q ? p(Q.getAllResponseHeaders()) : null, ke = !ne || ne === "text" || ne === "json" ? Q.responseText : Q.response, Te = {
            data: ke,
            status: Q.status,
            statusText: Q.statusText,
            headers: be,
            config: D,
            request: Q
          };
          u(H, Z, Te), Q = null;
        }
      }
      if ("onloadend" in Q ? Q.onloadend = he : Q.onreadystatechange = function() {
        !Q || Q.readyState !== 4 || Q.status === 0 && !(Q.responseURL && Q.responseURL.indexOf("file:") === 0) || setTimeout(he);
      }, Q.onabort = function() {
        Q && (Z(k("Request aborted", D, "ECONNABORTED", Q)), Q = null);
      }, Q.onerror = function() {
        Z(k("Network Error", D, null, Q)), Q = null;
      }, Q.ontimeout = function() {
        var ke = "timeout of " + D.timeout + "ms exceeded";
        D.timeoutErrorMessage && (ke = D.timeoutErrorMessage), Z(k(
          ke,
          D,
          D.transitional && D.transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED",
          Q
        )), Q = null;
      }, a.isStandardBrowserEnv()) {
        var fe = (D.withCredentials || _(ue)) && D.xsrfCookieName ? c.read(D.xsrfCookieName) : void 0;
        fe && (X[D.xsrfHeaderName] = fe);
      }
      "setRequestHeader" in Q && a.forEach(X, function(ke, Te) {
        typeof ee > "u" && Te.toLowerCase() === "content-type" ? delete X[Te] : Q.setRequestHeader(Te, ke);
      }), a.isUndefined(D.withCredentials) || (Q.withCredentials = !!D.withCredentials), ne && ne !== "json" && (Q.responseType = D.responseType), typeof D.onDownloadProgress == "function" && Q.addEventListener("progress", D.onDownloadProgress), typeof D.onUploadProgress == "function" && Q.upload && Q.upload.addEventListener("progress", D.onUploadProgress), D.cancelToken && D.cancelToken.promise.then(function(ke) {
        Q && (Q.abort(), Z(ke), Q = null);
      }), ee || (ee = null), Q.send(ee);
    });
  }, xhr;
}
var utils$5 = utils$9, normalizeHeaderName = normalizeHeaderName$1, enhanceError = enhanceError$1, DEFAULT_CONTENT_TYPE = {
  "Content-Type": "application/x-www-form-urlencoded"
};
function setContentTypeIfUnset(a, u) {
  !utils$5.isUndefined(a) && utils$5.isUndefined(a["Content-Type"]) && (a["Content-Type"] = u);
}
function getDefaultAdapter() {
  var a;
  return (typeof XMLHttpRequest < "u" || typeof process$1 < "u" && Object.prototype.toString.call(process$1) === "[object process]") && (a = requireXhr()), a;
}
function stringifySafely(a, u, c) {
  if (utils$5.isString(a))
    try {
      return (u || JSON.parse)(a), utils$5.trim(a);
    } catch (l) {
      if (l.name !== "SyntaxError")
        throw l;
    }
  return (c || JSON.stringify)(a);
}
var defaults$3 = {
  transitional: {
    silentJSONParsing: !0,
    forcedJSONParsing: !0,
    clarifyTimeoutError: !1
  },
  adapter: getDefaultAdapter(),
  transformRequest: [function a(u, c) {
    return normalizeHeaderName(c, "Accept"), normalizeHeaderName(c, "Content-Type"), utils$5.isFormData(u) || utils$5.isArrayBuffer(u) || utils$5.isBuffer(u) || utils$5.isStream(u) || utils$5.isFile(u) || utils$5.isBlob(u) ? u : utils$5.isArrayBufferView(u) ? u.buffer : utils$5.isURLSearchParams(u) ? (setContentTypeIfUnset(c, "application/x-www-form-urlencoded;charset=utf-8"), u.toString()) : utils$5.isObject(u) || c && c["Content-Type"] === "application/json" ? (setContentTypeIfUnset(c, "application/json"), stringifySafely(u)) : u;
  }],
  transformResponse: [function a(u) {
    var c = this.transitional, l = c && c.silentJSONParsing, v = c && c.forcedJSONParsing, p = !l && this.responseType === "json";
    if (p || v && utils$5.isString(u) && u.length)
      try {
        return JSON.parse(u);
      } catch (_) {
        if (p)
          throw _.name === "SyntaxError" ? enhanceError(_, this, "E_JSON_PARSE") : _;
      }
    return u;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  validateStatus: function a(u) {
    return u >= 200 && u < 300;
  }
};
defaults$3.headers = {
  common: {
    Accept: "application/json, text/plain, */*"
  }
};
utils$5.forEach(["delete", "get", "head"], function a(u) {
  defaults$3.headers[u] = {};
});
utils$5.forEach(["post", "put", "patch"], function a(u) {
  defaults$3.headers[u] = utils$5.merge(DEFAULT_CONTENT_TYPE);
});
var defaults_1 = defaults$3, utils$4 = utils$9, defaults$2 = defaults_1, transformData$1 = function a(u, c, l) {
  var v = this || defaults$2;
  return utils$4.forEach(l, function(_) {
    u = _.call(v, u, c);
  }), u;
}, isCancel$1, hasRequiredIsCancel;
function requireIsCancel() {
  return hasRequiredIsCancel || (hasRequiredIsCancel = 1, isCancel$1 = function(u) {
    return !!(u && u.__CANCEL__);
  }), isCancel$1;
}
var utils$3 = utils$9, transformData = transformData$1, isCancel = requireIsCancel(), defaults$1 = defaults_1;
function throwIfCancellationRequested(a) {
  a.cancelToken && a.cancelToken.throwIfRequested();
}
var dispatchRequest$1 = function a(u) {
  throwIfCancellationRequested(u), u.headers = u.headers || {}, u.data = transformData.call(
    u,
    u.data,
    u.headers,
    u.transformRequest
  ), u.headers = utils$3.merge(
    u.headers.common || {},
    u.headers[u.method] || {},
    u.headers
  ), utils$3.forEach(
    ["delete", "get", "head", "post", "put", "patch", "common"],
    function(v) {
      delete u.headers[v];
    }
  );
  var c = u.adapter || defaults$1.adapter;
  return c(u).then(function(v) {
    return throwIfCancellationRequested(u), v.data = transformData.call(
      u,
      v.data,
      v.headers,
      u.transformResponse
    ), v;
  }, function(v) {
    return isCancel(v) || (throwIfCancellationRequested(u), v && v.response && (v.response.data = transformData.call(
      u,
      v.response.data,
      v.response.headers,
      u.transformResponse
    ))), Promise.reject(v);
  });
}, utils$2 = utils$9, mergeConfig$2 = function a(u, c) {
  c = c || {};
  var l = {}, v = ["url", "method", "data"], p = ["headers", "auth", "proxy", "params"], _ = [
    "baseURL",
    "transformRequest",
    "transformResponse",
    "paramsSerializer",
    "timeout",
    "timeoutMessage",
    "withCredentials",
    "adapter",
    "responseType",
    "xsrfCookieName",
    "xsrfHeaderName",
    "onUploadProgress",
    "onDownloadProgress",
    "decompress",
    "maxContentLength",
    "maxBodyLength",
    "maxRedirects",
    "transport",
    "httpAgent",
    "httpsAgent",
    "cancelToken",
    "socketPath",
    "responseEncoding"
  ], k = ["validateStatus"];
  function O(Z, ee) {
    return utils$2.isPlainObject(Z) && utils$2.isPlainObject(ee) ? utils$2.merge(Z, ee) : utils$2.isPlainObject(ee) ? utils$2.merge({}, ee) : utils$2.isArray(ee) ? ee.slice() : ee;
  }
  function D(Z) {
    utils$2.isUndefined(c[Z]) ? utils$2.isUndefined(u[Z]) || (l[Z] = O(void 0, u[Z])) : l[Z] = O(u[Z], c[Z]);
  }
  utils$2.forEach(v, function(ee) {
    utils$2.isUndefined(c[ee]) || (l[ee] = O(void 0, c[ee]));
  }), utils$2.forEach(p, D), utils$2.forEach(_, function(ee) {
    utils$2.isUndefined(c[ee]) ? utils$2.isUndefined(u[ee]) || (l[ee] = O(void 0, u[ee])) : l[ee] = O(void 0, c[ee]);
  }), utils$2.forEach(k, function(ee) {
    ee in c ? l[ee] = O(u[ee], c[ee]) : ee in u && (l[ee] = O(void 0, u[ee]));
  });
  var F = v.concat(p).concat(_).concat(k), H = Object.keys(u).concat(Object.keys(c)).filter(function(ee) {
    return F.indexOf(ee) === -1;
  });
  return utils$2.forEach(H, D), l;
};
const name = "axios", version = "0.21.4", description = "Promise based HTTP client for the browser and node.js", main = "index.js", scripts = {
  test: "grunt test",
  start: "node ./sandbox/server.js",
  build: "NODE_ENV=production grunt build",
  preversion: "npm test",
  version: "npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json",
  postversion: "git push && git push --tags",
  examples: "node ./examples/server.js",
  coveralls: "cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js",
  fix: "eslint --fix lib/**/*.js"
}, repository = {
  type: "git",
  url: "https://github.com/axios/axios.git"
}, keywords = [
  "xhr",
  "http",
  "ajax",
  "promise",
  "node"
], author = "Matt Zabriskie", license = "MIT", bugs = {
  url: "https://github.com/axios/axios/issues"
}, homepage = "https://axios-http.com", devDependencies = {
  coveralls: "^3.0.0",
  "es6-promise": "^4.2.4",
  grunt: "^1.3.0",
  "grunt-banner": "^0.6.0",
  "grunt-cli": "^1.2.0",
  "grunt-contrib-clean": "^1.1.0",
  "grunt-contrib-watch": "^1.0.0",
  "grunt-eslint": "^23.0.0",
  "grunt-karma": "^4.0.0",
  "grunt-mocha-test": "^0.13.3",
  "grunt-ts": "^6.0.0-beta.19",
  "grunt-webpack": "^4.0.2",
  "istanbul-instrumenter-loader": "^1.0.0",
  "jasmine-core": "^2.4.1",
  karma: "^6.3.2",
  "karma-chrome-launcher": "^3.1.0",
  "karma-firefox-launcher": "^2.1.0",
  "karma-jasmine": "^1.1.1",
  "karma-jasmine-ajax": "^0.1.13",
  "karma-safari-launcher": "^1.0.0",
  "karma-sauce-launcher": "^4.3.6",
  "karma-sinon": "^1.0.5",
  "karma-sourcemap-loader": "^0.3.8",
  "karma-webpack": "^4.0.2",
  "load-grunt-tasks": "^3.5.2",
  minimist: "^1.2.0",
  mocha: "^8.2.1",
  sinon: "^4.5.0",
  "terser-webpack-plugin": "^4.2.3",
  typescript: "^4.0.5",
  "url-search-params": "^0.10.0",
  webpack: "^4.44.2",
  "webpack-dev-server": "^3.11.0"
}, browser = {
  "./lib/adapters/http.js": "./lib/adapters/xhr.js"
}, jsdelivr = "dist/axios.min.js", unpkg = "dist/axios.min.js", typings = "./index.d.ts", dependencies = {
  "follow-redirects": "^1.14.0"
}, bundlesize = [
  {
    path: "./dist/axios.min.js",
    threshold: "5kB"
  }
], require$$0 = {
  name,
  version,
  description,
  main,
  scripts,
  repository,
  keywords,
  author,
  license,
  bugs,
  homepage,
  devDependencies,
  browser,
  jsdelivr,
  unpkg,
  typings,
  dependencies,
  bundlesize
};
var pkg = require$$0, validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach(function(a, u) {
  validators$1[a] = function(l) {
    return typeof l === a || "a" + (u < 1 ? "n " : " ") + a;
  };
});
var deprecatedWarnings = {}, currentVerArr = pkg.version.split(".");
function isOlderVersion(a, u) {
  for (var c = u ? u.split(".") : currentVerArr, l = a.split("."), v = 0; v < 3; v++) {
    if (c[v] > l[v])
      return !0;
    if (c[v] < l[v])
      return !1;
  }
  return !1;
}
validators$1.transitional = function a(u, c, l) {
  var v = c && isOlderVersion(c);
  function p(_, k) {
    return "[Axios v" + pkg.version + "] Transitional option '" + _ + "'" + k + (l ? ". " + l : "");
  }
  return function(_, k, O) {
    if (u === !1)
      throw new Error(p(k, " has been removed in " + c));
    return v && !deprecatedWarnings[k] && (deprecatedWarnings[k] = !0, console.warn(
      p(
        k,
        " has been deprecated since v" + c + " and will be removed in the near future"
      )
    )), u ? u(_, k, O) : !0;
  };
};
function assertOptions(a, u, c) {
  if (typeof a != "object")
    throw new TypeError("options must be an object");
  for (var l = Object.keys(a), v = l.length; v-- > 0; ) {
    var p = l[v], _ = u[p];
    if (_) {
      var k = a[p], O = k === void 0 || _(k, p, a);
      if (O !== !0)
        throw new TypeError("option " + p + " must be " + O);
      continue;
    }
    if (c !== !0)
      throw Error("Unknown option " + p);
  }
}
var validator$1 = {
  isOlderVersion,
  assertOptions,
  validators: validators$1
}, utils$1 = utils$9, buildURL = buildURL$1, InterceptorManager = InterceptorManager_1, dispatchRequest = dispatchRequest$1, mergeConfig$1 = mergeConfig$2, validator = validator$1, validators = validator.validators;
function Axios$1(a) {
  this.defaults = a, this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}
Axios$1.prototype.request = function a(u) {
  typeof u == "string" ? (u = arguments[1] || {}, u.url = arguments[0]) : u = u || {}, u = mergeConfig$1(this.defaults, u), u.method ? u.method = u.method.toLowerCase() : this.defaults.method ? u.method = this.defaults.method.toLowerCase() : u.method = "get";
  var c = u.transitional;
  c !== void 0 && validator.assertOptions(c, {
    silentJSONParsing: validators.transitional(validators.boolean, "1.0.0"),
    forcedJSONParsing: validators.transitional(validators.boolean, "1.0.0"),
    clarifyTimeoutError: validators.transitional(validators.boolean, "1.0.0")
  }, !1);
  var l = [], v = !0;
  this.interceptors.request.forEach(function(Z) {
    typeof Z.runWhen == "function" && Z.runWhen(u) === !1 || (v = v && Z.synchronous, l.unshift(Z.fulfilled, Z.rejected));
  });
  var p = [];
  this.interceptors.response.forEach(function(Z) {
    p.push(Z.fulfilled, Z.rejected);
  });
  var _;
  if (!v) {
    var k = [dispatchRequest, void 0];
    for (Array.prototype.unshift.apply(k, l), k = k.concat(p), _ = Promise.resolve(u); k.length; )
      _ = _.then(k.shift(), k.shift());
    return _;
  }
  for (var O = u; l.length; ) {
    var D = l.shift(), F = l.shift();
    try {
      O = D(O);
    } catch (H) {
      F(H);
      break;
    }
  }
  try {
    _ = dispatchRequest(O);
  } catch (H) {
    return Promise.reject(H);
  }
  for (; p.length; )
    _ = _.then(p.shift(), p.shift());
  return _;
};
Axios$1.prototype.getUri = function a(u) {
  return u = mergeConfig$1(this.defaults, u), buildURL(u.url, u.params, u.paramsSerializer).replace(/^\?/, "");
};
utils$1.forEach(["delete", "get", "head", "options"], function a(u) {
  Axios$1.prototype[u] = function(c, l) {
    return this.request(mergeConfig$1(l || {}, {
      method: u,
      url: c,
      data: (l || {}).data
    }));
  };
});
utils$1.forEach(["post", "put", "patch"], function a(u) {
  Axios$1.prototype[u] = function(c, l, v) {
    return this.request(mergeConfig$1(v || {}, {
      method: u,
      url: c,
      data: l
    }));
  };
});
var Axios_1 = Axios$1, Cancel_1, hasRequiredCancel;
function requireCancel() {
  if (hasRequiredCancel)
    return Cancel_1;
  hasRequiredCancel = 1;
  function a(u) {
    this.message = u;
  }
  return a.prototype.toString = function() {
    return "Cancel" + (this.message ? ": " + this.message : "");
  }, a.prototype.__CANCEL__ = !0, Cancel_1 = a, Cancel_1;
}
var CancelToken_1, hasRequiredCancelToken;
function requireCancelToken() {
  if (hasRequiredCancelToken)
    return CancelToken_1;
  hasRequiredCancelToken = 1;
  var a = requireCancel();
  function u(c) {
    if (typeof c != "function")
      throw new TypeError("executor must be a function.");
    var l;
    this.promise = new Promise(function(_) {
      l = _;
    });
    var v = this;
    c(function(_) {
      v.reason || (v.reason = new a(_), l(v.reason));
    });
  }
  return u.prototype.throwIfRequested = function() {
    if (this.reason)
      throw this.reason;
  }, u.source = function() {
    var l, v = new u(function(_) {
      l = _;
    });
    return {
      token: v,
      cancel: l
    };
  }, CancelToken_1 = u, CancelToken_1;
}
var spread, hasRequiredSpread;
function requireSpread() {
  return hasRequiredSpread || (hasRequiredSpread = 1, spread = function(u) {
    return function(l) {
      return u.apply(null, l);
    };
  }), spread;
}
var isAxiosError, hasRequiredIsAxiosError;
function requireIsAxiosError() {
  return hasRequiredIsAxiosError || (hasRequiredIsAxiosError = 1, isAxiosError = function(u) {
    return typeof u == "object" && u.isAxiosError === !0;
  }), isAxiosError;
}
var utils = utils$9, bind = bind$2, Axios = Axios_1, mergeConfig = mergeConfig$2, defaults = defaults_1;
function createInstance(a) {
  var u = new Axios(a), c = bind(Axios.prototype.request, u);
  return utils.extend(c, Axios.prototype, u), utils.extend(c, u), c;
}
var axios$1 = createInstance(defaults);
axios$1.Axios = Axios;
axios$1.create = function a(u) {
  return createInstance(mergeConfig(axios$1.defaults, u));
};
axios$1.Cancel = requireCancel();
axios$1.CancelToken = requireCancelToken();
axios$1.isCancel = requireIsCancel();
axios$1.all = function a(u) {
  return Promise.all(u);
};
axios$1.spread = requireSpread();
axios$1.isAxiosError = requireIsAxiosError();
axios$2.exports = axios$1;
axios$2.exports.default = axios$1;
var axiosExports = axios$2.exports, axios = axiosExports, mapObj$1 = { exports: {} };
const isObject$1 = (a) => typeof a == "object" && a !== null, mapObjectSkip = Symbol("skip"), isObjectCustom = (a) => isObject$1(a) && !(a instanceof RegExp) && !(a instanceof Error) && !(a instanceof Date), mapObject = (a, u, c, l = /* @__PURE__ */ new WeakMap()) => {
  if (c = {
    deep: !1,
    target: {},
    ...c
  }, l.has(a))
    return l.get(a);
  l.set(a, c.target);
  const { target: v } = c;
  delete c.target;
  const p = (_) => _.map((k) => isObjectCustom(k) ? mapObject(k, u, c, l) : k);
  if (Array.isArray(a))
    return p(a);
  for (const [_, k] of Object.entries(a)) {
    const O = u(_, k, a);
    if (O === mapObjectSkip)
      continue;
    let [D, F, { shouldRecurse: H = !0 } = {}] = O;
    D !== "__proto__" && (c.deep && H && isObjectCustom(F) && (F = Array.isArray(F) ? p(F) : mapObject(F, u, c, l)), v[D] = F);
  }
  return v;
};
mapObj$1.exports = (a, u, c) => {
  if (!isObject$1(a))
    throw new TypeError(`Expected an object, got \`${a}\` (${typeof a})`);
  return mapObject(a, u, c);
};
mapObj$1.exports.mapObjectSkip = mapObjectSkip;
var mapObjExports = mapObj$1.exports, camelcase = { exports: {} };
const UPPERCASE = /[\p{Lu}]/u, LOWERCASE = /[\p{Ll}]/u, LEADING_CAPITAL = /^[\p{Lu}](?![\p{Lu}])/gu, IDENTIFIER = /([\p{Alpha}\p{N}_]|$)/u, SEPARATORS = /[_.\- ]+/, LEADING_SEPARATORS = new RegExp("^" + SEPARATORS.source), SEPARATORS_AND_IDENTIFIER = new RegExp(SEPARATORS.source + IDENTIFIER.source, "gu"), NUMBERS_AND_IDENTIFIER = new RegExp("\\d+" + IDENTIFIER.source, "gu"), preserveCamelCase = (a, u, c) => {
  let l = !1, v = !1, p = !1;
  for (let _ = 0; _ < a.length; _++) {
    const k = a[_];
    l && UPPERCASE.test(k) ? (a = a.slice(0, _) + "-" + a.slice(_), l = !1, p = v, v = !0, _++) : v && p && LOWERCASE.test(k) ? (a = a.slice(0, _ - 1) + "-" + a.slice(_ - 1), p = v, v = !1, l = !0) : (l = u(k) === k && c(k) !== k, p = v, v = c(k) === k && u(k) !== k);
  }
  return a;
}, preserveConsecutiveUppercase = (a, u) => (LEADING_CAPITAL.lastIndex = 0, a.replace(LEADING_CAPITAL, (c) => u(c))), postProcess = (a, u) => (SEPARATORS_AND_IDENTIFIER.lastIndex = 0, NUMBERS_AND_IDENTIFIER.lastIndex = 0, a.replace(SEPARATORS_AND_IDENTIFIER, (c, l) => u(l)).replace(NUMBERS_AND_IDENTIFIER, (c) => u(c))), camelCase$1 = (a, u) => {
  if (!(typeof a == "string" || Array.isArray(a)))
    throw new TypeError("Expected the input to be `string | string[]`");
  if (u = {
    pascalCase: !1,
    preserveConsecutiveUppercase: !1,
    ...u
  }, Array.isArray(a) ? a = a.map((p) => p.trim()).filter((p) => p.length).join("-") : a = a.trim(), a.length === 0)
    return "";
  const c = u.locale === !1 ? (p) => p.toLowerCase() : (p) => p.toLocaleLowerCase(u.locale), l = u.locale === !1 ? (p) => p.toUpperCase() : (p) => p.toLocaleUpperCase(u.locale);
  return a.length === 1 ? u.pascalCase ? l(a) : c(a) : (a !== c(a) && (a = preserveCamelCase(a, c, l)), a = a.replace(LEADING_SEPARATORS, ""), u.preserveConsecutiveUppercase ? a = preserveConsecutiveUppercase(a, c) : a = c(a), u.pascalCase && (a = l(a.charAt(0)) + a.slice(1)), postProcess(a, l));
};
camelcase.exports = camelCase$1;
camelcase.exports.default = camelCase$1;
var camelcaseExports = camelcase.exports;
class QuickLRU {
  constructor(u = {}) {
    if (!(u.maxSize && u.maxSize > 0))
      throw new TypeError("`maxSize` must be a number greater than 0");
    this.maxSize = u.maxSize, this.onEviction = u.onEviction, this.cache = /* @__PURE__ */ new Map(), this.oldCache = /* @__PURE__ */ new Map(), this._size = 0;
  }
  _set(u, c) {
    if (this.cache.set(u, c), this._size++, this._size >= this.maxSize) {
      if (this._size = 0, typeof this.onEviction == "function")
        for (const [l, v] of this.oldCache.entries())
          this.onEviction(l, v);
      this.oldCache = this.cache, this.cache = /* @__PURE__ */ new Map();
    }
  }
  get(u) {
    if (this.cache.has(u))
      return this.cache.get(u);
    if (this.oldCache.has(u)) {
      const c = this.oldCache.get(u);
      return this.oldCache.delete(u), this._set(u, c), c;
    }
  }
  set(u, c) {
    return this.cache.has(u) ? this.cache.set(u, c) : this._set(u, c), this;
  }
  has(u) {
    return this.cache.has(u) || this.oldCache.has(u);
  }
  peek(u) {
    if (this.cache.has(u))
      return this.cache.get(u);
    if (this.oldCache.has(u))
      return this.oldCache.get(u);
  }
  delete(u) {
    const c = this.cache.delete(u);
    return c && this._size--, this.oldCache.delete(u) || c;
  }
  clear() {
    this.cache.clear(), this.oldCache.clear(), this._size = 0;
  }
  *keys() {
    for (const [u] of this)
      yield u;
  }
  *values() {
    for (const [, u] of this)
      yield u;
  }
  *[Symbol.iterator]() {
    for (const u of this.cache)
      yield u;
    for (const u of this.oldCache) {
      const [c] = u;
      this.cache.has(c) || (yield u);
    }
  }
  get size() {
    let u = 0;
    for (const c of this.oldCache.keys())
      this.cache.has(c) || u++;
    return Math.min(this._size + u, this.maxSize);
  }
}
var quickLru = QuickLRU;
const mapObj = mapObjExports, camelCase = camelcaseExports, QuickLru = quickLru, has$1 = (a, u) => a.some((c) => typeof c == "string" ? c === u : (c.lastIndex = 0, c.test(u))), cache$1 = new QuickLru({ maxSize: 1e5 }), isObject = (a) => typeof a == "object" && a !== null && !(a instanceof RegExp) && !(a instanceof Error) && !(a instanceof Date), camelCaseConvert = (a, u) => {
  if (!isObject(a))
    return a;
  u = {
    deep: !1,
    pascalCase: !1,
    ...u
  };
  const { exclude: c, pascalCase: l, stopPaths: v, deep: p } = u, _ = new Set(v), k = (O) => (D, F) => {
    if (p && isObject(F)) {
      const H = O === void 0 ? D : `${O}.${D}`;
      _.has(H) || (F = mapObj(F, k(H)));
    }
    if (!(c && has$1(c, D))) {
      const H = l ? `${D}_` : D;
      if (cache$1.has(H))
        D = cache$1.get(H);
      else {
        const Z = camelCase(D, { pascalCase: l, locale: !1 });
        D.length < 100 && cache$1.set(H, Z), D = Z;
      }
    }
    return [D, F];
  };
  return mapObj(a, k(void 0));
};
var camelcaseKeys = (a, u) => Array.isArray(a) ? Object.keys(a).map((c) => camelCaseConvert(a[c], u)) : camelCaseConvert(a, u), __importDefault$6 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(TwirpRPC, "__esModule", { value: !0 });
TwirpRPC.TwirpRpc = TwirpRPC.livekitPackage = void 0;
const axios_1 = __importDefault$6(axios), camelcase_keys_1 = __importDefault$6(camelcaseKeys), defaultPrefix = "/twirp";
TwirpRPC.livekitPackage = "livekit";
class TwirpRpc {
  constructor(u, c, l, v) {
    this.host = u, this.pkg = c, this.prefix = l || defaultPrefix, this.instance = axios_1.default.create({
      baseURL: u,
      headers: Object.assign({}, v ? { Host: v } : {})
    });
  }
  request(u, c, l, v) {
    return new Promise((p, _) => {
      const k = `${this.prefix}/${this.pkg}.${u}/${c}`;
      this.instance.post(k, l, { headers: v }).then((O) => {
        p(camelcase_keys_1.default(O.data, { deep: !0 }));
      }).catch(_);
    });
  }
}
TwirpRPC.TwirpRpc = TwirpRpc;
var __awaiter$2 = commonjsGlobal$1 && commonjsGlobal$1.__awaiter || function(a, u, c, l) {
  function v(p) {
    return p instanceof c ? p : new c(function(_) {
      _(p);
    });
  }
  return new (c || (c = Promise))(function(p, _) {
    function k(F) {
      try {
        D(l.next(F));
      } catch (H) {
        _(H);
      }
    }
    function O(F) {
      try {
        D(l.throw(F));
      } catch (H) {
        _(H);
      }
    }
    function D(F) {
      F.done ? p(F.value) : v(F.value).then(k, O);
    }
    D((l = l.apply(a, u || [])).next());
  });
}, __importDefault$5 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(EgressClient$1, "__esModule", { value: !0 });
EgressClient$1.EgressClient = void 0;
const livekit_egress_1$1 = livekit_egress, ServiceBase_1$2 = __importDefault$5(ServiceBase$1), TwirpRPC_1$2 = TwirpRPC, svc$2 = "Egress";
class EgressClient extends ServiceBase_1$2.default {
  /**
   * @param host hostname including protocol. i.e. 'https://cluster.livekit.io'
   * @param apiKey API Key, can be set in env var LIVEKIT_API_KEY
   * @param secret API Secret, can be set in env var LIVEKIT_API_SECRET
   */
  constructor(u, c, l) {
    super(c, l), this.rpc = new TwirpRPC_1$2.TwirpRpc(u, TwirpRPC_1$2.livekitPackage);
  }
  startRoomCompositeEgress(u, c, l, v, p, _, k) {
    return __awaiter$2(this, void 0, void 0, function* () {
      let O;
      if (l !== void 0)
        if (typeof l == "string")
          O = l;
        else {
          const Q = l;
          O = Q.layout, v = Q.encodingOptions, p = Q.audioOnly, _ = Q.videoOnly, k = Q.customBaseUrl;
        }
      O ?? (O = ""), p ?? (p = !1), _ ?? (_ = !1), k ?? (k = "");
      const { file: D, segments: F, stream: H, preset: Z, advanced: ee } = this.getOutputParams(c, v), X = livekit_egress_1$1.RoomCompositeEgressRequest.toJSON({
        roomName: u,
        layout: O,
        audioOnly: p,
        videoOnly: _,
        customBaseUrl: k,
        file: D,
        stream: H,
        segments: F,
        preset: Z,
        advanced: ee
      }), ne = yield this.rpc.request(svc$2, "StartRoomCompositeEgress", X, this.authHeader({ roomRecord: !0 }));
      return livekit_egress_1$1.EgressInfo.fromJSON(ne);
    });
  }
  /**
   * @param url url
   * @param output file or stream output
   * @param opts WebOptions
   */
  startWebEgress(u, c, l) {
    return __awaiter$2(this, void 0, void 0, function* () {
      const v = (l == null ? void 0 : l.audioOnly) || !1, p = (l == null ? void 0 : l.videoOnly) || !1, { file: _, segments: k, stream: O, preset: D, advanced: F } = this.getOutputParams(c, l == null ? void 0 : l.encodingOptions), H = livekit_egress_1$1.WebEgressRequest.toJSON({
        url: u,
        audioOnly: v,
        videoOnly: p,
        file: _,
        stream: O,
        segments: k,
        preset: D,
        advanced: F
      }), Z = yield this.rpc.request(svc$2, "StartWebEgress", H, this.authHeader({ roomRecord: !0 }));
      return livekit_egress_1$1.EgressInfo.fromJSON(Z);
    });
  }
  startTrackCompositeEgress(u, c, l, v, p) {
    return __awaiter$2(this, void 0, void 0, function* () {
      let _;
      if (l !== void 0)
        if (typeof l == "string")
          _ = l;
        else {
          const X = l;
          _ = X.audioTrackId, v = X.videoTrackId, p = X.encodingOptions;
        }
      _ ?? (_ = ""), v ?? (v = "");
      const { file: k, segments: O, stream: D, preset: F, advanced: H } = this.getOutputParams(c, p), Z = livekit_egress_1$1.TrackCompositeEgressRequest.toJSON({
        roomName: u,
        audioTrackId: _,
        videoTrackId: v,
        file: k,
        stream: D,
        segments: O,
        preset: F,
        advanced: H
      }), ee = yield this.rpc.request(svc$2, "StartTrackCompositeEgress", Z, this.authHeader({ roomRecord: !0 }));
      return livekit_egress_1$1.EgressInfo.fromJSON(ee);
    });
  }
  getOutputParams(u, c) {
    let l, v, p, _, k;
    return u.filepath !== void 0 ? l = u : u.filenamePrefix !== void 0 ? p = u : v = u, c && (typeof c == "number" ? _ = c : k = c), { file: l, segments: p, stream: v, preset: _, advanced: k };
  }
  /**
   * @param roomName room name
   * @param output file or websocket output
   * @param trackId track Id
   */
  startTrackEgress(u, c, l) {
    return __awaiter$2(this, void 0, void 0, function* () {
      let v, p;
      c.filepath !== void 0 ? v = c : p = c;
      const _ = livekit_egress_1$1.TrackEgressRequest.toJSON({
        roomName: u,
        trackId: l,
        file: v,
        websocketUrl: p
      }), k = yield this.rpc.request(svc$2, "StartTrackEgress", _, this.authHeader({ roomRecord: !0 }));
      return livekit_egress_1$1.EgressInfo.fromJSON(k);
    });
  }
  /**
   * @param egressId
   * @param layout
   */
  updateLayout(u, c) {
    return __awaiter$2(this, void 0, void 0, function* () {
      const l = yield this.rpc.request(svc$2, "UpdateLayout", livekit_egress_1$1.UpdateLayoutRequest.toJSON({ egressId: u, layout: c }), this.authHeader({ roomRecord: !0 }));
      return livekit_egress_1$1.EgressInfo.fromJSON(l);
    });
  }
  /**
   * @param egressId
   * @param addOutputUrls
   * @param removeOutputUrls
   */
  updateStream(u, c, l) {
    return __awaiter$2(this, void 0, void 0, function* () {
      c ?? (c = []), l ?? (l = []);
      const v = yield this.rpc.request(svc$2, "UpdateStream", livekit_egress_1$1.UpdateStreamRequest.toJSON({ egressId: u, addOutputUrls: c, removeOutputUrls: l }), this.authHeader({ roomRecord: !0 }));
      return livekit_egress_1$1.EgressInfo.fromJSON(v);
    });
  }
  /**
   * @param roomName list egress for one room only
   */
  listEgress(u) {
    var c;
    return __awaiter$2(this, void 0, void 0, function* () {
      u ?? (u = "");
      const l = yield this.rpc.request(svc$2, "ListEgress", livekit_egress_1$1.ListEgressRequest.toJSON({ roomName: u }), this.authHeader({ roomRecord: !0 }));
      return (c = livekit_egress_1$1.ListEgressResponse.fromJSON(l).items) !== null && c !== void 0 ? c : [];
    });
  }
  /**
   * @param egressId
   */
  stopEgress(u) {
    return __awaiter$2(this, void 0, void 0, function* () {
      const c = yield this.rpc.request(svc$2, "StopEgress", livekit_egress_1$1.StopEgressRequest.toJSON({ egressId: u }), this.authHeader({ roomRecord: !0 }));
      return livekit_egress_1$1.EgressInfo.fromJSON(c);
    });
  }
}
EgressClient$1.EgressClient = EgressClient;
var grants = {};
Object.defineProperty(grants, "__esModule", { value: !0 });
var IngressClient$1 = {}, livekit_ingress = {}, livekit_models = {}, timestamp = {}, __importDefault$4 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(timestamp, "__esModule", { value: !0 });
timestamp.Timestamp = timestamp.protobufPackage = void 0;
const long_1$1 = __importDefault$4(umdExports), minimal_1$1 = __importDefault$4(minimal);
timestamp.protobufPackage = "google.protobuf";
function createBaseTimestamp() {
  return { seconds: 0, nanos: 0 };
}
timestamp.Timestamp = {
  encode(a, u = minimal_1$1.default.Writer.create()) {
    return a.seconds !== 0 && u.uint32(8).int64(a.seconds), a.nanos !== 0 && u.uint32(16).int32(a.nanos), u;
  },
  decode(a, u) {
    const c = a instanceof minimal_1$1.default.Reader ? a : new minimal_1$1.default.Reader(a);
    let l = u === void 0 ? c.len : c.pos + u;
    const v = createBaseTimestamp();
    for (; c.pos < l; ) {
      const p = c.uint32();
      switch (p >>> 3) {
        case 1:
          v.seconds = longToNumber$1(c.int64());
          break;
        case 2:
          v.nanos = c.int32();
          break;
        default:
          c.skipType(p & 7);
          break;
      }
    }
    return v;
  },
  fromJSON(a) {
    return {
      seconds: isSet$1(a.seconds) ? Number(a.seconds) : 0,
      nanos: isSet$1(a.nanos) ? Number(a.nanos) : 0
    };
  },
  toJSON(a) {
    const u = {};
    return a.seconds !== void 0 && (u.seconds = Math.round(a.seconds)), a.nanos !== void 0 && (u.nanos = Math.round(a.nanos)), u;
  },
  fromPartial(a) {
    var u, c;
    const l = createBaseTimestamp();
    return l.seconds = (u = a.seconds) !== null && u !== void 0 ? u : 0, l.nanos = (c = a.nanos) !== null && c !== void 0 ? c : 0, l;
  }
};
var globalThis$2 = (() => {
  if (typeof globalThis$2 < "u")
    return globalThis$2;
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof commonjsGlobal$1 < "u")
    return commonjsGlobal$1;
  throw "Unable to locate global object";
})();
function longToNumber$1(a) {
  if (a.gt(Number.MAX_SAFE_INTEGER))
    throw new globalThis$2.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  return a.toNumber();
}
minimal_1$1.default.util.Long !== long_1$1.default && (minimal_1$1.default.util.Long = long_1$1.default, minimal_1$1.default.configure());
function isSet$1(a) {
  return a != null;
}
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(V) {
    return V && V.__esModule ? V : { default: V };
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.RTPStats_GapHistogramEntry = a.RTPStats = a.DisabledCodecs = a.VideoConfiguration = a.ClientConfiguration = a.ClientInfo = a.ServerInfo = a.ParticipantTracks = a.UserPacket = a.SpeakerInfo = a.ActiveSpeakerUpdate = a.DataPacket = a.VideoLayer = a.TrackInfo = a.SimulcastCodecInfo = a.ParticipantInfo = a.ParticipantPermission = a.Codec = a.Room = a.clientInfo_SDKToJSON = a.clientInfo_SDKFromJSON = a.ClientInfo_SDK = a.serverInfo_EditionToJSON = a.serverInfo_EditionFromJSON = a.ServerInfo_Edition = a.dataPacket_KindToJSON = a.dataPacket_KindFromJSON = a.DataPacket_Kind = a.participantInfo_StateToJSON = a.participantInfo_StateFromJSON = a.ParticipantInfo_State = a.disconnectReasonToJSON = a.disconnectReasonFromJSON = a.DisconnectReason = a.clientConfigSettingToJSON = a.clientConfigSettingFromJSON = a.ClientConfigSetting = a.connectionQualityToJSON = a.connectionQualityFromJSON = a.ConnectionQuality = a.videoQualityToJSON = a.videoQualityFromJSON = a.VideoQuality = a.trackSourceToJSON = a.trackSourceFromJSON = a.TrackSource = a.trackTypeToJSON = a.trackTypeFromJSON = a.TrackType = a.protobufPackage = void 0, a.TimedVersion = void 0;
  const c = u(umdExports), l = u(minimal), v = timestamp;
  a.protobufPackage = "livekit";
  var p;
  (function(V) {
    V[V.AUDIO = 0] = "AUDIO", V[V.VIDEO = 1] = "VIDEO", V[V.DATA = 2] = "DATA", V[V.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(p = a.TrackType || (a.TrackType = {}));
  function _(V) {
    switch (V) {
      case 0:
      case "AUDIO":
        return p.AUDIO;
      case 1:
      case "VIDEO":
        return p.VIDEO;
      case 2:
      case "DATA":
        return p.DATA;
      case -1:
      case "UNRECOGNIZED":
      default:
        return p.UNRECOGNIZED;
    }
  }
  a.trackTypeFromJSON = _;
  function k(V) {
    switch (V) {
      case p.AUDIO:
        return "AUDIO";
      case p.VIDEO:
        return "VIDEO";
      case p.DATA:
        return "DATA";
      case p.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.trackTypeToJSON = k;
  var O;
  (function(V) {
    V[V.UNKNOWN = 0] = "UNKNOWN", V[V.CAMERA = 1] = "CAMERA", V[V.MICROPHONE = 2] = "MICROPHONE", V[V.SCREEN_SHARE = 3] = "SCREEN_SHARE", V[V.SCREEN_SHARE_AUDIO = 4] = "SCREEN_SHARE_AUDIO", V[V.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(O = a.TrackSource || (a.TrackSource = {}));
  function D(V) {
    switch (V) {
      case 0:
      case "UNKNOWN":
        return O.UNKNOWN;
      case 1:
      case "CAMERA":
        return O.CAMERA;
      case 2:
      case "MICROPHONE":
        return O.MICROPHONE;
      case 3:
      case "SCREEN_SHARE":
        return O.SCREEN_SHARE;
      case 4:
      case "SCREEN_SHARE_AUDIO":
        return O.SCREEN_SHARE_AUDIO;
      case -1:
      case "UNRECOGNIZED":
      default:
        return O.UNRECOGNIZED;
    }
  }
  a.trackSourceFromJSON = D;
  function F(V) {
    switch (V) {
      case O.UNKNOWN:
        return "UNKNOWN";
      case O.CAMERA:
        return "CAMERA";
      case O.MICROPHONE:
        return "MICROPHONE";
      case O.SCREEN_SHARE:
        return "SCREEN_SHARE";
      case O.SCREEN_SHARE_AUDIO:
        return "SCREEN_SHARE_AUDIO";
      case O.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.trackSourceToJSON = F;
  var H;
  (function(V) {
    V[V.LOW = 0] = "LOW", V[V.MEDIUM = 1] = "MEDIUM", V[V.HIGH = 2] = "HIGH", V[V.OFF = 3] = "OFF", V[V.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(H = a.VideoQuality || (a.VideoQuality = {}));
  function Z(V) {
    switch (V) {
      case 0:
      case "LOW":
        return H.LOW;
      case 1:
      case "MEDIUM":
        return H.MEDIUM;
      case 2:
      case "HIGH":
        return H.HIGH;
      case 3:
      case "OFF":
        return H.OFF;
      case -1:
      case "UNRECOGNIZED":
      default:
        return H.UNRECOGNIZED;
    }
  }
  a.videoQualityFromJSON = Z;
  function ee(V) {
    switch (V) {
      case H.LOW:
        return "LOW";
      case H.MEDIUM:
        return "MEDIUM";
      case H.HIGH:
        return "HIGH";
      case H.OFF:
        return "OFF";
      case H.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.videoQualityToJSON = ee;
  var X;
  (function(V) {
    V[V.POOR = 0] = "POOR", V[V.GOOD = 1] = "GOOD", V[V.EXCELLENT = 2] = "EXCELLENT", V[V.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(X = a.ConnectionQuality || (a.ConnectionQuality = {}));
  function ne(V) {
    switch (V) {
      case 0:
      case "POOR":
        return X.POOR;
      case 1:
      case "GOOD":
        return X.GOOD;
      case 2:
      case "EXCELLENT":
        return X.EXCELLENT;
      case -1:
      case "UNRECOGNIZED":
      default:
        return X.UNRECOGNIZED;
    }
  }
  a.connectionQualityFromJSON = ne;
  function Q(V) {
    switch (V) {
      case X.POOR:
        return "POOR";
      case X.GOOD:
        return "GOOD";
      case X.EXCELLENT:
        return "EXCELLENT";
      case X.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.connectionQualityToJSON = Q;
  var ae;
  (function(V) {
    V[V.UNSET = 0] = "UNSET", V[V.DISABLED = 1] = "DISABLED", V[V.ENABLED = 2] = "ENABLED", V[V.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(ae = a.ClientConfigSetting || (a.ClientConfigSetting = {}));
  function j(V) {
    switch (V) {
      case 0:
      case "UNSET":
        return ae.UNSET;
      case 1:
      case "DISABLED":
        return ae.DISABLED;
      case 2:
      case "ENABLED":
        return ae.ENABLED;
      case -1:
      case "UNRECOGNIZED":
      default:
        return ae.UNRECOGNIZED;
    }
  }
  a.clientConfigSettingFromJSON = j;
  function ue(V) {
    switch (V) {
      case ae.UNSET:
        return "UNSET";
      case ae.DISABLED:
        return "DISABLED";
      case ae.ENABLED:
        return "ENABLED";
      case ae.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.clientConfigSettingToJSON = ue;
  var he;
  (function(V) {
    V[V.UNKNOWN_REASON = 0] = "UNKNOWN_REASON", V[V.CLIENT_INITIATED = 1] = "CLIENT_INITIATED", V[V.DUPLICATE_IDENTITY = 2] = "DUPLICATE_IDENTITY", V[V.SERVER_SHUTDOWN = 3] = "SERVER_SHUTDOWN", V[V.PARTICIPANT_REMOVED = 4] = "PARTICIPANT_REMOVED", V[V.ROOM_DELETED = 5] = "ROOM_DELETED", V[V.STATE_MISMATCH = 6] = "STATE_MISMATCH", V[V.JOIN_FAILURE = 7] = "JOIN_FAILURE", V[V.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(he = a.DisconnectReason || (a.DisconnectReason = {}));
  function fe(V) {
    switch (V) {
      case 0:
      case "UNKNOWN_REASON":
        return he.UNKNOWN_REASON;
      case 1:
      case "CLIENT_INITIATED":
        return he.CLIENT_INITIATED;
      case 2:
      case "DUPLICATE_IDENTITY":
        return he.DUPLICATE_IDENTITY;
      case 3:
      case "SERVER_SHUTDOWN":
        return he.SERVER_SHUTDOWN;
      case 4:
      case "PARTICIPANT_REMOVED":
        return he.PARTICIPANT_REMOVED;
      case 5:
      case "ROOM_DELETED":
        return he.ROOM_DELETED;
      case 6:
      case "STATE_MISMATCH":
        return he.STATE_MISMATCH;
      case 7:
      case "JOIN_FAILURE":
        return he.JOIN_FAILURE;
      case -1:
      case "UNRECOGNIZED":
      default:
        return he.UNRECOGNIZED;
    }
  }
  a.disconnectReasonFromJSON = fe;
  function be(V) {
    switch (V) {
      case he.UNKNOWN_REASON:
        return "UNKNOWN_REASON";
      case he.CLIENT_INITIATED:
        return "CLIENT_INITIATED";
      case he.DUPLICATE_IDENTITY:
        return "DUPLICATE_IDENTITY";
      case he.SERVER_SHUTDOWN:
        return "SERVER_SHUTDOWN";
      case he.PARTICIPANT_REMOVED:
        return "PARTICIPANT_REMOVED";
      case he.ROOM_DELETED:
        return "ROOM_DELETED";
      case he.STATE_MISMATCH:
        return "STATE_MISMATCH";
      case he.JOIN_FAILURE:
        return "JOIN_FAILURE";
      case he.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.disconnectReasonToJSON = be;
  var ke;
  (function(V) {
    V[V.JOINING = 0] = "JOINING", V[V.JOINED = 1] = "JOINED", V[V.ACTIVE = 2] = "ACTIVE", V[V.DISCONNECTED = 3] = "DISCONNECTED", V[V.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(ke = a.ParticipantInfo_State || (a.ParticipantInfo_State = {}));
  function Te(V) {
    switch (V) {
      case 0:
      case "JOINING":
        return ke.JOINING;
      case 1:
      case "JOINED":
        return ke.JOINED;
      case 2:
      case "ACTIVE":
        return ke.ACTIVE;
      case 3:
      case "DISCONNECTED":
        return ke.DISCONNECTED;
      case -1:
      case "UNRECOGNIZED":
      default:
        return ke.UNRECOGNIZED;
    }
  }
  a.participantInfo_StateFromJSON = Te;
  function q(V) {
    switch (V) {
      case ke.JOINING:
        return "JOINING";
      case ke.JOINED:
        return "JOINED";
      case ke.ACTIVE:
        return "ACTIVE";
      case ke.DISCONNECTED:
        return "DISCONNECTED";
      case ke.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.participantInfo_StateToJSON = q;
  var z;
  (function(V) {
    V[V.RELIABLE = 0] = "RELIABLE", V[V.LOSSY = 1] = "LOSSY", V[V.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(z = a.DataPacket_Kind || (a.DataPacket_Kind = {}));
  function P(V) {
    switch (V) {
      case 0:
      case "RELIABLE":
        return z.RELIABLE;
      case 1:
      case "LOSSY":
        return z.LOSSY;
      case -1:
      case "UNRECOGNIZED":
      default:
        return z.UNRECOGNIZED;
    }
  }
  a.dataPacket_KindFromJSON = P;
  function S(V) {
    switch (V) {
      case z.RELIABLE:
        return "RELIABLE";
      case z.LOSSY:
        return "LOSSY";
      case z.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.dataPacket_KindToJSON = S;
  var E;
  (function(V) {
    V[V.Standard = 0] = "Standard", V[V.Cloud = 1] = "Cloud", V[V.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(E = a.ServerInfo_Edition || (a.ServerInfo_Edition = {}));
  function I(V) {
    switch (V) {
      case 0:
      case "Standard":
        return E.Standard;
      case 1:
      case "Cloud":
        return E.Cloud;
      case -1:
      case "UNRECOGNIZED":
      default:
        return E.UNRECOGNIZED;
    }
  }
  a.serverInfo_EditionFromJSON = I;
  function M(V) {
    switch (V) {
      case E.Standard:
        return "Standard";
      case E.Cloud:
        return "Cloud";
      case E.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.serverInfo_EditionToJSON = M;
  var $;
  (function(V) {
    V[V.UNKNOWN = 0] = "UNKNOWN", V[V.JS = 1] = "JS", V[V.SWIFT = 2] = "SWIFT", V[V.ANDROID = 3] = "ANDROID", V[V.FLUTTER = 4] = "FLUTTER", V[V.GO = 5] = "GO", V[V.UNITY = 6] = "UNITY", V[V.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })($ = a.ClientInfo_SDK || (a.ClientInfo_SDK = {}));
  function U(V) {
    switch (V) {
      case 0:
      case "UNKNOWN":
        return $.UNKNOWN;
      case 1:
      case "JS":
        return $.JS;
      case 2:
      case "SWIFT":
        return $.SWIFT;
      case 3:
      case "ANDROID":
        return $.ANDROID;
      case 4:
      case "FLUTTER":
        return $.FLUTTER;
      case 5:
      case "GO":
        return $.GO;
      case 6:
      case "UNITY":
        return $.UNITY;
      case -1:
      case "UNRECOGNIZED":
      default:
        return $.UNRECOGNIZED;
    }
  }
  a.clientInfo_SDKFromJSON = U;
  function Y(V) {
    switch (V) {
      case $.UNKNOWN:
        return "UNKNOWN";
      case $.JS:
        return "JS";
      case $.SWIFT:
        return "SWIFT";
      case $.ANDROID:
        return "ANDROID";
      case $.FLUTTER:
        return "FLUTTER";
      case $.GO:
        return "GO";
      case $.UNITY:
        return "UNITY";
      case $.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.clientInfo_SDKToJSON = Y;
  function B() {
    return {
      sid: "",
      name: "",
      emptyTimeout: 0,
      maxParticipants: 0,
      creationTime: 0,
      turnPassword: "",
      enabledCodecs: [],
      metadata: "",
      numParticipants: 0,
      activeRecording: !1
    };
  }
  a.Room = {
    encode(V, Ee = l.default.Writer.create()) {
      V.sid !== "" && Ee.uint32(10).string(V.sid), V.name !== "" && Ee.uint32(18).string(V.name), V.emptyTimeout !== 0 && Ee.uint32(24).uint32(V.emptyTimeout), V.maxParticipants !== 0 && Ee.uint32(32).uint32(V.maxParticipants), V.creationTime !== 0 && Ee.uint32(40).int64(V.creationTime), V.turnPassword !== "" && Ee.uint32(50).string(V.turnPassword);
      for (const de of V.enabledCodecs)
        a.Codec.encode(de, Ee.uint32(58).fork()).ldelim();
      return V.metadata !== "" && Ee.uint32(66).string(V.metadata), V.numParticipants !== 0 && Ee.uint32(72).uint32(V.numParticipants), V.activeRecording === !0 && Ee.uint32(80).bool(V.activeRecording), Ee;
    },
    decode(V, Ee) {
      const de = V instanceof l.default.Reader ? V : new l.default.Reader(V);
      let ce = Ee === void 0 ? de.len : de.pos + Ee;
      const ve = B();
      for (; de.pos < ce; ) {
        const Pe = de.uint32();
        switch (Pe >>> 3) {
          case 1:
            ve.sid = de.string();
            break;
          case 2:
            ve.name = de.string();
            break;
          case 3:
            ve.emptyTimeout = de.uint32();
            break;
          case 4:
            ve.maxParticipants = de.uint32();
            break;
          case 5:
            ve.creationTime = we(de.int64());
            break;
          case 6:
            ve.turnPassword = de.string();
            break;
          case 7:
            ve.enabledCodecs.push(a.Codec.decode(de, de.uint32()));
            break;
          case 8:
            ve.metadata = de.string();
            break;
          case 9:
            ve.numParticipants = de.uint32();
            break;
          case 10:
            ve.activeRecording = de.bool();
            break;
          default:
            de.skipType(Pe & 7);
            break;
        }
      }
      return ve;
    },
    fromJSON(V) {
      return {
        sid: Ie(V.sid) ? String(V.sid) : "",
        name: Ie(V.name) ? String(V.name) : "",
        emptyTimeout: Ie(V.emptyTimeout) ? Number(V.emptyTimeout) : 0,
        maxParticipants: Ie(V.maxParticipants) ? Number(V.maxParticipants) : 0,
        creationTime: Ie(V.creationTime) ? Number(V.creationTime) : 0,
        turnPassword: Ie(V.turnPassword) ? String(V.turnPassword) : "",
        enabledCodecs: Array.isArray(V == null ? void 0 : V.enabledCodecs) ? V.enabledCodecs.map((Ee) => a.Codec.fromJSON(Ee)) : [],
        metadata: Ie(V.metadata) ? String(V.metadata) : "",
        numParticipants: Ie(V.numParticipants) ? Number(V.numParticipants) : 0,
        activeRecording: Ie(V.activeRecording) ? !!V.activeRecording : !1
      };
    },
    toJSON(V) {
      const Ee = {};
      return V.sid !== void 0 && (Ee.sid = V.sid), V.name !== void 0 && (Ee.name = V.name), V.emptyTimeout !== void 0 && (Ee.emptyTimeout = Math.round(V.emptyTimeout)), V.maxParticipants !== void 0 && (Ee.maxParticipants = Math.round(V.maxParticipants)), V.creationTime !== void 0 && (Ee.creationTime = Math.round(V.creationTime)), V.turnPassword !== void 0 && (Ee.turnPassword = V.turnPassword), V.enabledCodecs ? Ee.enabledCodecs = V.enabledCodecs.map((de) => de ? a.Codec.toJSON(de) : void 0) : Ee.enabledCodecs = [], V.metadata !== void 0 && (Ee.metadata = V.metadata), V.numParticipants !== void 0 && (Ee.numParticipants = Math.round(V.numParticipants)), V.activeRecording !== void 0 && (Ee.activeRecording = V.activeRecording), Ee;
    },
    fromPartial(V) {
      var Ee, de, ce, ve, Pe, Be, ze, Je, je, Ke;
      const x = B();
      return x.sid = (Ee = V.sid) !== null && Ee !== void 0 ? Ee : "", x.name = (de = V.name) !== null && de !== void 0 ? de : "", x.emptyTimeout = (ce = V.emptyTimeout) !== null && ce !== void 0 ? ce : 0, x.maxParticipants = (ve = V.maxParticipants) !== null && ve !== void 0 ? ve : 0, x.creationTime = (Pe = V.creationTime) !== null && Pe !== void 0 ? Pe : 0, x.turnPassword = (Be = V.turnPassword) !== null && Be !== void 0 ? Be : "", x.enabledCodecs = ((ze = V.enabledCodecs) === null || ze === void 0 ? void 0 : ze.map((se) => a.Codec.fromPartial(se))) || [], x.metadata = (Je = V.metadata) !== null && Je !== void 0 ? Je : "", x.numParticipants = (je = V.numParticipants) !== null && je !== void 0 ? je : 0, x.activeRecording = (Ke = V.activeRecording) !== null && Ke !== void 0 ? Ke : !1, x;
    }
  };
  function T() {
    return { mime: "", fmtpLine: "" };
  }
  a.Codec = {
    encode(V, Ee = l.default.Writer.create()) {
      return V.mime !== "" && Ee.uint32(10).string(V.mime), V.fmtpLine !== "" && Ee.uint32(18).string(V.fmtpLine), Ee;
    },
    decode(V, Ee) {
      const de = V instanceof l.default.Reader ? V : new l.default.Reader(V);
      let ce = Ee === void 0 ? de.len : de.pos + Ee;
      const ve = T();
      for (; de.pos < ce; ) {
        const Pe = de.uint32();
        switch (Pe >>> 3) {
          case 1:
            ve.mime = de.string();
            break;
          case 2:
            ve.fmtpLine = de.string();
            break;
          default:
            de.skipType(Pe & 7);
            break;
        }
      }
      return ve;
    },
    fromJSON(V) {
      return {
        mime: Ie(V.mime) ? String(V.mime) : "",
        fmtpLine: Ie(V.fmtpLine) ? String(V.fmtpLine) : ""
      };
    },
    toJSON(V) {
      const Ee = {};
      return V.mime !== void 0 && (Ee.mime = V.mime), V.fmtpLine !== void 0 && (Ee.fmtpLine = V.fmtpLine), Ee;
    },
    fromPartial(V) {
      var Ee, de;
      const ce = T();
      return ce.mime = (Ee = V.mime) !== null && Ee !== void 0 ? Ee : "", ce.fmtpLine = (de = V.fmtpLine) !== null && de !== void 0 ? de : "", ce;
    }
  };
  function L() {
    return { canSubscribe: !1, canPublish: !1, canPublishData: !1, hidden: !1, recorder: !1 };
  }
  a.ParticipantPermission = {
    encode(V, Ee = l.default.Writer.create()) {
      return V.canSubscribe === !0 && Ee.uint32(8).bool(V.canSubscribe), V.canPublish === !0 && Ee.uint32(16).bool(V.canPublish), V.canPublishData === !0 && Ee.uint32(24).bool(V.canPublishData), V.hidden === !0 && Ee.uint32(56).bool(V.hidden), V.recorder === !0 && Ee.uint32(64).bool(V.recorder), Ee;
    },
    decode(V, Ee) {
      const de = V instanceof l.default.Reader ? V : new l.default.Reader(V);
      let ce = Ee === void 0 ? de.len : de.pos + Ee;
      const ve = L();
      for (; de.pos < ce; ) {
        const Pe = de.uint32();
        switch (Pe >>> 3) {
          case 1:
            ve.canSubscribe = de.bool();
            break;
          case 2:
            ve.canPublish = de.bool();
            break;
          case 3:
            ve.canPublishData = de.bool();
            break;
          case 7:
            ve.hidden = de.bool();
            break;
          case 8:
            ve.recorder = de.bool();
            break;
          default:
            de.skipType(Pe & 7);
            break;
        }
      }
      return ve;
    },
    fromJSON(V) {
      return {
        canSubscribe: Ie(V.canSubscribe) ? !!V.canSubscribe : !1,
        canPublish: Ie(V.canPublish) ? !!V.canPublish : !1,
        canPublishData: Ie(V.canPublishData) ? !!V.canPublishData : !1,
        hidden: Ie(V.hidden) ? !!V.hidden : !1,
        recorder: Ie(V.recorder) ? !!V.recorder : !1
      };
    },
    toJSON(V) {
      const Ee = {};
      return V.canSubscribe !== void 0 && (Ee.canSubscribe = V.canSubscribe), V.canPublish !== void 0 && (Ee.canPublish = V.canPublish), V.canPublishData !== void 0 && (Ee.canPublishData = V.canPublishData), V.hidden !== void 0 && (Ee.hidden = V.hidden), V.recorder !== void 0 && (Ee.recorder = V.recorder), Ee;
    },
    fromPartial(V) {
      var Ee, de, ce, ve, Pe;
      const Be = L();
      return Be.canSubscribe = (Ee = V.canSubscribe) !== null && Ee !== void 0 ? Ee : !1, Be.canPublish = (de = V.canPublish) !== null && de !== void 0 ? de : !1, Be.canPublishData = (ce = V.canPublishData) !== null && ce !== void 0 ? ce : !1, Be.hidden = (ve = V.hidden) !== null && ve !== void 0 ? ve : !1, Be.recorder = (Pe = V.recorder) !== null && Pe !== void 0 ? Pe : !1, Be;
    }
  };
  function te() {
    return {
      sid: "",
      identity: "",
      state: 0,
      tracks: [],
      metadata: "",
      joinedAt: 0,
      name: "",
      version: 0,
      permission: void 0,
      region: "",
      isPublisher: !1
    };
  }
  a.ParticipantInfo = {
    encode(V, Ee = l.default.Writer.create()) {
      V.sid !== "" && Ee.uint32(10).string(V.sid), V.identity !== "" && Ee.uint32(18).string(V.identity), V.state !== 0 && Ee.uint32(24).int32(V.state);
      for (const de of V.tracks)
        a.TrackInfo.encode(de, Ee.uint32(34).fork()).ldelim();
      return V.metadata !== "" && Ee.uint32(42).string(V.metadata), V.joinedAt !== 0 && Ee.uint32(48).int64(V.joinedAt), V.name !== "" && Ee.uint32(74).string(V.name), V.version !== 0 && Ee.uint32(80).uint32(V.version), V.permission !== void 0 && a.ParticipantPermission.encode(V.permission, Ee.uint32(90).fork()).ldelim(), V.region !== "" && Ee.uint32(98).string(V.region), V.isPublisher === !0 && Ee.uint32(104).bool(V.isPublisher), Ee;
    },
    decode(V, Ee) {
      const de = V instanceof l.default.Reader ? V : new l.default.Reader(V);
      let ce = Ee === void 0 ? de.len : de.pos + Ee;
      const ve = te();
      for (; de.pos < ce; ) {
        const Pe = de.uint32();
        switch (Pe >>> 3) {
          case 1:
            ve.sid = de.string();
            break;
          case 2:
            ve.identity = de.string();
            break;
          case 3:
            ve.state = de.int32();
            break;
          case 4:
            ve.tracks.push(a.TrackInfo.decode(de, de.uint32()));
            break;
          case 5:
            ve.metadata = de.string();
            break;
          case 6:
            ve.joinedAt = we(de.int64());
            break;
          case 9:
            ve.name = de.string();
            break;
          case 10:
            ve.version = de.uint32();
            break;
          case 11:
            ve.permission = a.ParticipantPermission.decode(de, de.uint32());
            break;
          case 12:
            ve.region = de.string();
            break;
          case 13:
            ve.isPublisher = de.bool();
            break;
          default:
            de.skipType(Pe & 7);
            break;
        }
      }
      return ve;
    },
    fromJSON(V) {
      return {
        sid: Ie(V.sid) ? String(V.sid) : "",
        identity: Ie(V.identity) ? String(V.identity) : "",
        state: Ie(V.state) ? Te(V.state) : 0,
        tracks: Array.isArray(V == null ? void 0 : V.tracks) ? V.tracks.map((Ee) => a.TrackInfo.fromJSON(Ee)) : [],
        metadata: Ie(V.metadata) ? String(V.metadata) : "",
        joinedAt: Ie(V.joinedAt) ? Number(V.joinedAt) : 0,
        name: Ie(V.name) ? String(V.name) : "",
        version: Ie(V.version) ? Number(V.version) : 0,
        permission: Ie(V.permission) ? a.ParticipantPermission.fromJSON(V.permission) : void 0,
        region: Ie(V.region) ? String(V.region) : "",
        isPublisher: Ie(V.isPublisher) ? !!V.isPublisher : !1
      };
    },
    toJSON(V) {
      const Ee = {};
      return V.sid !== void 0 && (Ee.sid = V.sid), V.identity !== void 0 && (Ee.identity = V.identity), V.state !== void 0 && (Ee.state = q(V.state)), V.tracks ? Ee.tracks = V.tracks.map((de) => de ? a.TrackInfo.toJSON(de) : void 0) : Ee.tracks = [], V.metadata !== void 0 && (Ee.metadata = V.metadata), V.joinedAt !== void 0 && (Ee.joinedAt = Math.round(V.joinedAt)), V.name !== void 0 && (Ee.name = V.name), V.version !== void 0 && (Ee.version = Math.round(V.version)), V.permission !== void 0 && (Ee.permission = V.permission ? a.ParticipantPermission.toJSON(V.permission) : void 0), V.region !== void 0 && (Ee.region = V.region), V.isPublisher !== void 0 && (Ee.isPublisher = V.isPublisher), Ee;
    },
    fromPartial(V) {
      var Ee, de, ce, ve, Pe, Be, ze, Je, je, Ke;
      const x = te();
      return x.sid = (Ee = V.sid) !== null && Ee !== void 0 ? Ee : "", x.identity = (de = V.identity) !== null && de !== void 0 ? de : "", x.state = (ce = V.state) !== null && ce !== void 0 ? ce : 0, x.tracks = ((ve = V.tracks) === null || ve === void 0 ? void 0 : ve.map((se) => a.TrackInfo.fromPartial(se))) || [], x.metadata = (Pe = V.metadata) !== null && Pe !== void 0 ? Pe : "", x.joinedAt = (Be = V.joinedAt) !== null && Be !== void 0 ? Be : 0, x.name = (ze = V.name) !== null && ze !== void 0 ? ze : "", x.version = (Je = V.version) !== null && Je !== void 0 ? Je : 0, x.permission = V.permission !== void 0 && V.permission !== null ? a.ParticipantPermission.fromPartial(V.permission) : void 0, x.region = (je = V.region) !== null && je !== void 0 ? je : "", x.isPublisher = (Ke = V.isPublisher) !== null && Ke !== void 0 ? Ke : !1, x;
    }
  };
  function me() {
    return { mimeType: "", mid: "", cid: "", layers: [] };
  }
  a.SimulcastCodecInfo = {
    encode(V, Ee = l.default.Writer.create()) {
      V.mimeType !== "" && Ee.uint32(10).string(V.mimeType), V.mid !== "" && Ee.uint32(18).string(V.mid), V.cid !== "" && Ee.uint32(26).string(V.cid);
      for (const de of V.layers)
        a.VideoLayer.encode(de, Ee.uint32(34).fork()).ldelim();
      return Ee;
    },
    decode(V, Ee) {
      const de = V instanceof l.default.Reader ? V : new l.default.Reader(V);
      let ce = Ee === void 0 ? de.len : de.pos + Ee;
      const ve = me();
      for (; de.pos < ce; ) {
        const Pe = de.uint32();
        switch (Pe >>> 3) {
          case 1:
            ve.mimeType = de.string();
            break;
          case 2:
            ve.mid = de.string();
            break;
          case 3:
            ve.cid = de.string();
            break;
          case 4:
            ve.layers.push(a.VideoLayer.decode(de, de.uint32()));
            break;
          default:
            de.skipType(Pe & 7);
            break;
        }
      }
      return ve;
    },
    fromJSON(V) {
      return {
        mimeType: Ie(V.mimeType) ? String(V.mimeType) : "",
        mid: Ie(V.mid) ? String(V.mid) : "",
        cid: Ie(V.cid) ? String(V.cid) : "",
        layers: Array.isArray(V == null ? void 0 : V.layers) ? V.layers.map((Ee) => a.VideoLayer.fromJSON(Ee)) : []
      };
    },
    toJSON(V) {
      const Ee = {};
      return V.mimeType !== void 0 && (Ee.mimeType = V.mimeType), V.mid !== void 0 && (Ee.mid = V.mid), V.cid !== void 0 && (Ee.cid = V.cid), V.layers ? Ee.layers = V.layers.map((de) => de ? a.VideoLayer.toJSON(de) : void 0) : Ee.layers = [], Ee;
    },
    fromPartial(V) {
      var Ee, de, ce, ve;
      const Pe = me();
      return Pe.mimeType = (Ee = V.mimeType) !== null && Ee !== void 0 ? Ee : "", Pe.mid = (de = V.mid) !== null && de !== void 0 ? de : "", Pe.cid = (ce = V.cid) !== null && ce !== void 0 ? ce : "", Pe.layers = ((ve = V.layers) === null || ve === void 0 ? void 0 : ve.map((Be) => a.VideoLayer.fromPartial(Be))) || [], Pe;
    }
  };
  function Ce() {
    return {
      sid: "",
      type: 0,
      name: "",
      muted: !1,
      width: 0,
      height: 0,
      simulcast: !1,
      disableDtx: !1,
      source: 0,
      layers: [],
      mimeType: "",
      mid: "",
      codecs: [],
      stereo: !1,
      disableRed: !1
    };
  }
  a.TrackInfo = {
    encode(V, Ee = l.default.Writer.create()) {
      V.sid !== "" && Ee.uint32(10).string(V.sid), V.type !== 0 && Ee.uint32(16).int32(V.type), V.name !== "" && Ee.uint32(26).string(V.name), V.muted === !0 && Ee.uint32(32).bool(V.muted), V.width !== 0 && Ee.uint32(40).uint32(V.width), V.height !== 0 && Ee.uint32(48).uint32(V.height), V.simulcast === !0 && Ee.uint32(56).bool(V.simulcast), V.disableDtx === !0 && Ee.uint32(64).bool(V.disableDtx), V.source !== 0 && Ee.uint32(72).int32(V.source);
      for (const de of V.layers)
        a.VideoLayer.encode(de, Ee.uint32(82).fork()).ldelim();
      V.mimeType !== "" && Ee.uint32(90).string(V.mimeType), V.mid !== "" && Ee.uint32(98).string(V.mid);
      for (const de of V.codecs)
        a.SimulcastCodecInfo.encode(de, Ee.uint32(106).fork()).ldelim();
      return V.stereo === !0 && Ee.uint32(112).bool(V.stereo), V.disableRed === !0 && Ee.uint32(120).bool(V.disableRed), Ee;
    },
    decode(V, Ee) {
      const de = V instanceof l.default.Reader ? V : new l.default.Reader(V);
      let ce = Ee === void 0 ? de.len : de.pos + Ee;
      const ve = Ce();
      for (; de.pos < ce; ) {
        const Pe = de.uint32();
        switch (Pe >>> 3) {
          case 1:
            ve.sid = de.string();
            break;
          case 2:
            ve.type = de.int32();
            break;
          case 3:
            ve.name = de.string();
            break;
          case 4:
            ve.muted = de.bool();
            break;
          case 5:
            ve.width = de.uint32();
            break;
          case 6:
            ve.height = de.uint32();
            break;
          case 7:
            ve.simulcast = de.bool();
            break;
          case 8:
            ve.disableDtx = de.bool();
            break;
          case 9:
            ve.source = de.int32();
            break;
          case 10:
            ve.layers.push(a.VideoLayer.decode(de, de.uint32()));
            break;
          case 11:
            ve.mimeType = de.string();
            break;
          case 12:
            ve.mid = de.string();
            break;
          case 13:
            ve.codecs.push(a.SimulcastCodecInfo.decode(de, de.uint32()));
            break;
          case 14:
            ve.stereo = de.bool();
            break;
          case 15:
            ve.disableRed = de.bool();
            break;
          default:
            de.skipType(Pe & 7);
            break;
        }
      }
      return ve;
    },
    fromJSON(V) {
      return {
        sid: Ie(V.sid) ? String(V.sid) : "",
        type: Ie(V.type) ? _(V.type) : 0,
        name: Ie(V.name) ? String(V.name) : "",
        muted: Ie(V.muted) ? !!V.muted : !1,
        width: Ie(V.width) ? Number(V.width) : 0,
        height: Ie(V.height) ? Number(V.height) : 0,
        simulcast: Ie(V.simulcast) ? !!V.simulcast : !1,
        disableDtx: Ie(V.disableDtx) ? !!V.disableDtx : !1,
        source: Ie(V.source) ? D(V.source) : 0,
        layers: Array.isArray(V == null ? void 0 : V.layers) ? V.layers.map((Ee) => a.VideoLayer.fromJSON(Ee)) : [],
        mimeType: Ie(V.mimeType) ? String(V.mimeType) : "",
        mid: Ie(V.mid) ? String(V.mid) : "",
        codecs: Array.isArray(V == null ? void 0 : V.codecs) ? V.codecs.map((Ee) => a.SimulcastCodecInfo.fromJSON(Ee)) : [],
        stereo: Ie(V.stereo) ? !!V.stereo : !1,
        disableRed: Ie(V.disableRed) ? !!V.disableRed : !1
      };
    },
    toJSON(V) {
      const Ee = {};
      return V.sid !== void 0 && (Ee.sid = V.sid), V.type !== void 0 && (Ee.type = k(V.type)), V.name !== void 0 && (Ee.name = V.name), V.muted !== void 0 && (Ee.muted = V.muted), V.width !== void 0 && (Ee.width = Math.round(V.width)), V.height !== void 0 && (Ee.height = Math.round(V.height)), V.simulcast !== void 0 && (Ee.simulcast = V.simulcast), V.disableDtx !== void 0 && (Ee.disableDtx = V.disableDtx), V.source !== void 0 && (Ee.source = F(V.source)), V.layers ? Ee.layers = V.layers.map((de) => de ? a.VideoLayer.toJSON(de) : void 0) : Ee.layers = [], V.mimeType !== void 0 && (Ee.mimeType = V.mimeType), V.mid !== void 0 && (Ee.mid = V.mid), V.codecs ? Ee.codecs = V.codecs.map((de) => de ? a.SimulcastCodecInfo.toJSON(de) : void 0) : Ee.codecs = [], V.stereo !== void 0 && (Ee.stereo = V.stereo), V.disableRed !== void 0 && (Ee.disableRed = V.disableRed), Ee;
    },
    fromPartial(V) {
      var Ee, de, ce, ve, Pe, Be, ze, Je, je, Ke, x, se, Se, xe, Ae;
      const Ye = Ce();
      return Ye.sid = (Ee = V.sid) !== null && Ee !== void 0 ? Ee : "", Ye.type = (de = V.type) !== null && de !== void 0 ? de : 0, Ye.name = (ce = V.name) !== null && ce !== void 0 ? ce : "", Ye.muted = (ve = V.muted) !== null && ve !== void 0 ? ve : !1, Ye.width = (Pe = V.width) !== null && Pe !== void 0 ? Pe : 0, Ye.height = (Be = V.height) !== null && Be !== void 0 ? Be : 0, Ye.simulcast = (ze = V.simulcast) !== null && ze !== void 0 ? ze : !1, Ye.disableDtx = (Je = V.disableDtx) !== null && Je !== void 0 ? Je : !1, Ye.source = (je = V.source) !== null && je !== void 0 ? je : 0, Ye.layers = ((Ke = V.layers) === null || Ke === void 0 ? void 0 : Ke.map((et) => a.VideoLayer.fromPartial(et))) || [], Ye.mimeType = (x = V.mimeType) !== null && x !== void 0 ? x : "", Ye.mid = (se = V.mid) !== null && se !== void 0 ? se : "", Ye.codecs = ((Se = V.codecs) === null || Se === void 0 ? void 0 : Se.map((et) => a.SimulcastCodecInfo.fromPartial(et))) || [], Ye.stereo = (xe = V.stereo) !== null && xe !== void 0 ? xe : !1, Ye.disableRed = (Ae = V.disableRed) !== null && Ae !== void 0 ? Ae : !1, Ye;
    }
  };
  function De() {
    return { quality: 0, width: 0, height: 0, bitrate: 0, ssrc: 0 };
  }
  a.VideoLayer = {
    encode(V, Ee = l.default.Writer.create()) {
      return V.quality !== 0 && Ee.uint32(8).int32(V.quality), V.width !== 0 && Ee.uint32(16).uint32(V.width), V.height !== 0 && Ee.uint32(24).uint32(V.height), V.bitrate !== 0 && Ee.uint32(32).uint32(V.bitrate), V.ssrc !== 0 && Ee.uint32(40).uint32(V.ssrc), Ee;
    },
    decode(V, Ee) {
      const de = V instanceof l.default.Reader ? V : new l.default.Reader(V);
      let ce = Ee === void 0 ? de.len : de.pos + Ee;
      const ve = De();
      for (; de.pos < ce; ) {
        const Pe = de.uint32();
        switch (Pe >>> 3) {
          case 1:
            ve.quality = de.int32();
            break;
          case 2:
            ve.width = de.uint32();
            break;
          case 3:
            ve.height = de.uint32();
            break;
          case 4:
            ve.bitrate = de.uint32();
            break;
          case 5:
            ve.ssrc = de.uint32();
            break;
          default:
            de.skipType(Pe & 7);
            break;
        }
      }
      return ve;
    },
    fromJSON(V) {
      return {
        quality: Ie(V.quality) ? Z(V.quality) : 0,
        width: Ie(V.width) ? Number(V.width) : 0,
        height: Ie(V.height) ? Number(V.height) : 0,
        bitrate: Ie(V.bitrate) ? Number(V.bitrate) : 0,
        ssrc: Ie(V.ssrc) ? Number(V.ssrc) : 0
      };
    },
    toJSON(V) {
      const Ee = {};
      return V.quality !== void 0 && (Ee.quality = ee(V.quality)), V.width !== void 0 && (Ee.width = Math.round(V.width)), V.height !== void 0 && (Ee.height = Math.round(V.height)), V.bitrate !== void 0 && (Ee.bitrate = Math.round(V.bitrate)), V.ssrc !== void 0 && (Ee.ssrc = Math.round(V.ssrc)), Ee;
    },
    fromPartial(V) {
      var Ee, de, ce, ve, Pe;
      const Be = De();
      return Be.quality = (Ee = V.quality) !== null && Ee !== void 0 ? Ee : 0, Be.width = (de = V.width) !== null && de !== void 0 ? de : 0, Be.height = (ce = V.height) !== null && ce !== void 0 ? ce : 0, Be.bitrate = (ve = V.bitrate) !== null && ve !== void 0 ? ve : 0, Be.ssrc = (Pe = V.ssrc) !== null && Pe !== void 0 ? Pe : 0, Be;
    }
  };
  function ye() {
    return { kind: 0, user: void 0, speaker: void 0 };
  }
  a.DataPacket = {
    encode(V, Ee = l.default.Writer.create()) {
      return V.kind !== 0 && Ee.uint32(8).int32(V.kind), V.user !== void 0 && a.UserPacket.encode(V.user, Ee.uint32(18).fork()).ldelim(), V.speaker !== void 0 && a.ActiveSpeakerUpdate.encode(V.speaker, Ee.uint32(26).fork()).ldelim(), Ee;
    },
    decode(V, Ee) {
      const de = V instanceof l.default.Reader ? V : new l.default.Reader(V);
      let ce = Ee === void 0 ? de.len : de.pos + Ee;
      const ve = ye();
      for (; de.pos < ce; ) {
        const Pe = de.uint32();
        switch (Pe >>> 3) {
          case 1:
            ve.kind = de.int32();
            break;
          case 2:
            ve.user = a.UserPacket.decode(de, de.uint32());
            break;
          case 3:
            ve.speaker = a.ActiveSpeakerUpdate.decode(de, de.uint32());
            break;
          default:
            de.skipType(Pe & 7);
            break;
        }
      }
      return ve;
    },
    fromJSON(V) {
      return {
        kind: Ie(V.kind) ? P(V.kind) : 0,
        user: Ie(V.user) ? a.UserPacket.fromJSON(V.user) : void 0,
        speaker: Ie(V.speaker) ? a.ActiveSpeakerUpdate.fromJSON(V.speaker) : void 0
      };
    },
    toJSON(V) {
      const Ee = {};
      return V.kind !== void 0 && (Ee.kind = S(V.kind)), V.user !== void 0 && (Ee.user = V.user ? a.UserPacket.toJSON(V.user) : void 0), V.speaker !== void 0 && (Ee.speaker = V.speaker ? a.ActiveSpeakerUpdate.toJSON(V.speaker) : void 0), Ee;
    },
    fromPartial(V) {
      var Ee;
      const de = ye();
      return de.kind = (Ee = V.kind) !== null && Ee !== void 0 ? Ee : 0, de.user = V.user !== void 0 && V.user !== null ? a.UserPacket.fromPartial(V.user) : void 0, de.speaker = V.speaker !== void 0 && V.speaker !== null ? a.ActiveSpeakerUpdate.fromPartial(V.speaker) : void 0, de;
    }
  };
  function pe() {
    return { speakers: [] };
  }
  a.ActiveSpeakerUpdate = {
    encode(V, Ee = l.default.Writer.create()) {
      for (const de of V.speakers)
        a.SpeakerInfo.encode(de, Ee.uint32(10).fork()).ldelim();
      return Ee;
    },
    decode(V, Ee) {
      const de = V instanceof l.default.Reader ? V : new l.default.Reader(V);
      let ce = Ee === void 0 ? de.len : de.pos + Ee;
      const ve = pe();
      for (; de.pos < ce; ) {
        const Pe = de.uint32();
        switch (Pe >>> 3) {
          case 1:
            ve.speakers.push(a.SpeakerInfo.decode(de, de.uint32()));
            break;
          default:
            de.skipType(Pe & 7);
            break;
        }
      }
      return ve;
    },
    fromJSON(V) {
      return {
        speakers: Array.isArray(V == null ? void 0 : V.speakers) ? V.speakers.map((Ee) => a.SpeakerInfo.fromJSON(Ee)) : []
      };
    },
    toJSON(V) {
      const Ee = {};
      return V.speakers ? Ee.speakers = V.speakers.map((de) => de ? a.SpeakerInfo.toJSON(de) : void 0) : Ee.speakers = [], Ee;
    },
    fromPartial(V) {
      var Ee;
      const de = pe();
      return de.speakers = ((Ee = V.speakers) === null || Ee === void 0 ? void 0 : Ee.map((ce) => a.SpeakerInfo.fromPartial(ce))) || [], de;
    }
  };
  function Me() {
    return { sid: "", level: 0, active: !1 };
  }
  a.SpeakerInfo = {
    encode(V, Ee = l.default.Writer.create()) {
      return V.sid !== "" && Ee.uint32(10).string(V.sid), V.level !== 0 && Ee.uint32(21).float(V.level), V.active === !0 && Ee.uint32(24).bool(V.active), Ee;
    },
    decode(V, Ee) {
      const de = V instanceof l.default.Reader ? V : new l.default.Reader(V);
      let ce = Ee === void 0 ? de.len : de.pos + Ee;
      const ve = Me();
      for (; de.pos < ce; ) {
        const Pe = de.uint32();
        switch (Pe >>> 3) {
          case 1:
            ve.sid = de.string();
            break;
          case 2:
            ve.level = de.float();
            break;
          case 3:
            ve.active = de.bool();
            break;
          default:
            de.skipType(Pe & 7);
            break;
        }
      }
      return ve;
    },
    fromJSON(V) {
      return {
        sid: Ie(V.sid) ? String(V.sid) : "",
        level: Ie(V.level) ? Number(V.level) : 0,
        active: Ie(V.active) ? !!V.active : !1
      };
    },
    toJSON(V) {
      const Ee = {};
      return V.sid !== void 0 && (Ee.sid = V.sid), V.level !== void 0 && (Ee.level = V.level), V.active !== void 0 && (Ee.active = V.active), Ee;
    },
    fromPartial(V) {
      var Ee, de, ce;
      const ve = Me();
      return ve.sid = (Ee = V.sid) !== null && Ee !== void 0 ? Ee : "", ve.level = (de = V.level) !== null && de !== void 0 ? de : 0, ve.active = (ce = V.active) !== null && ce !== void 0 ? ce : !1, ve;
    }
  };
  function Ne() {
    return { participantSid: "", payload: new Uint8Array(), destinationSids: [] };
  }
  a.UserPacket = {
    encode(V, Ee = l.default.Writer.create()) {
      V.participantSid !== "" && Ee.uint32(10).string(V.participantSid), V.payload.length !== 0 && Ee.uint32(18).bytes(V.payload);
      for (const de of V.destinationSids)
        Ee.uint32(26).string(de);
      return Ee;
    },
    decode(V, Ee) {
      const de = V instanceof l.default.Reader ? V : new l.default.Reader(V);
      let ce = Ee === void 0 ? de.len : de.pos + Ee;
      const ve = Ne();
      for (; de.pos < ce; ) {
        const Pe = de.uint32();
        switch (Pe >>> 3) {
          case 1:
            ve.participantSid = de.string();
            break;
          case 2:
            ve.payload = de.bytes();
            break;
          case 3:
            ve.destinationSids.push(de.string());
            break;
          default:
            de.skipType(Pe & 7);
            break;
        }
      }
      return ve;
    },
    fromJSON(V) {
      return {
        participantSid: Ie(V.participantSid) ? String(V.participantSid) : "",
        payload: Ie(V.payload) ? yt(V.payload) : new Uint8Array(),
        destinationSids: Array.isArray(V == null ? void 0 : V.destinationSids) ? V.destinationSids.map((Ee) => String(Ee)) : []
      };
    },
    toJSON(V) {
      const Ee = {};
      return V.participantSid !== void 0 && (Ee.participantSid = V.participantSid), V.payload !== void 0 && (Ee.payload = Xe(V.payload !== void 0 ? V.payload : new Uint8Array())), V.destinationSids ? Ee.destinationSids = V.destinationSids.map((de) => de) : Ee.destinationSids = [], Ee;
    },
    fromPartial(V) {
      var Ee, de, ce;
      const ve = Ne();
      return ve.participantSid = (Ee = V.participantSid) !== null && Ee !== void 0 ? Ee : "", ve.payload = (de = V.payload) !== null && de !== void 0 ? de : new Uint8Array(), ve.destinationSids = ((ce = V.destinationSids) === null || ce === void 0 ? void 0 : ce.map((Pe) => Pe)) || [], ve;
    }
  };
  function Ue() {
    return { participantSid: "", trackSids: [] };
  }
  a.ParticipantTracks = {
    encode(V, Ee = l.default.Writer.create()) {
      V.participantSid !== "" && Ee.uint32(10).string(V.participantSid);
      for (const de of V.trackSids)
        Ee.uint32(18).string(de);
      return Ee;
    },
    decode(V, Ee) {
      const de = V instanceof l.default.Reader ? V : new l.default.Reader(V);
      let ce = Ee === void 0 ? de.len : de.pos + Ee;
      const ve = Ue();
      for (; de.pos < ce; ) {
        const Pe = de.uint32();
        switch (Pe >>> 3) {
          case 1:
            ve.participantSid = de.string();
            break;
          case 2:
            ve.trackSids.push(de.string());
            break;
          default:
            de.skipType(Pe & 7);
            break;
        }
      }
      return ve;
    },
    fromJSON(V) {
      return {
        participantSid: Ie(V.participantSid) ? String(V.participantSid) : "",
        trackSids: Array.isArray(V == null ? void 0 : V.trackSids) ? V.trackSids.map((Ee) => String(Ee)) : []
      };
    },
    toJSON(V) {
      const Ee = {};
      return V.participantSid !== void 0 && (Ee.participantSid = V.participantSid), V.trackSids ? Ee.trackSids = V.trackSids.map((de) => de) : Ee.trackSids = [], Ee;
    },
    fromPartial(V) {
      var Ee, de;
      const ce = Ue();
      return ce.participantSid = (Ee = V.participantSid) !== null && Ee !== void 0 ? Ee : "", ce.trackSids = ((de = V.trackSids) === null || de === void 0 ? void 0 : de.map((ve) => ve)) || [], ce;
    }
  };
  function oe() {
    return { edition: 0, version: "", protocol: 0, region: "", nodeId: "", debugInfo: "" };
  }
  a.ServerInfo = {
    encode(V, Ee = l.default.Writer.create()) {
      return V.edition !== 0 && Ee.uint32(8).int32(V.edition), V.version !== "" && Ee.uint32(18).string(V.version), V.protocol !== 0 && Ee.uint32(24).int32(V.protocol), V.region !== "" && Ee.uint32(34).string(V.region), V.nodeId !== "" && Ee.uint32(42).string(V.nodeId), V.debugInfo !== "" && Ee.uint32(50).string(V.debugInfo), Ee;
    },
    decode(V, Ee) {
      const de = V instanceof l.default.Reader ? V : new l.default.Reader(V);
      let ce = Ee === void 0 ? de.len : de.pos + Ee;
      const ve = oe();
      for (; de.pos < ce; ) {
        const Pe = de.uint32();
        switch (Pe >>> 3) {
          case 1:
            ve.edition = de.int32();
            break;
          case 2:
            ve.version = de.string();
            break;
          case 3:
            ve.protocol = de.int32();
            break;
          case 4:
            ve.region = de.string();
            break;
          case 5:
            ve.nodeId = de.string();
            break;
          case 6:
            ve.debugInfo = de.string();
            break;
          default:
            de.skipType(Pe & 7);
            break;
        }
      }
      return ve;
    },
    fromJSON(V) {
      return {
        edition: Ie(V.edition) ? I(V.edition) : 0,
        version: Ie(V.version) ? String(V.version) : "",
        protocol: Ie(V.protocol) ? Number(V.protocol) : 0,
        region: Ie(V.region) ? String(V.region) : "",
        nodeId: Ie(V.nodeId) ? String(V.nodeId) : "",
        debugInfo: Ie(V.debugInfo) ? String(V.debugInfo) : ""
      };
    },
    toJSON(V) {
      const Ee = {};
      return V.edition !== void 0 && (Ee.edition = M(V.edition)), V.version !== void 0 && (Ee.version = V.version), V.protocol !== void 0 && (Ee.protocol = Math.round(V.protocol)), V.region !== void 0 && (Ee.region = V.region), V.nodeId !== void 0 && (Ee.nodeId = V.nodeId), V.debugInfo !== void 0 && (Ee.debugInfo = V.debugInfo), Ee;
    },
    fromPartial(V) {
      var Ee, de, ce, ve, Pe, Be;
      const ze = oe();
      return ze.edition = (Ee = V.edition) !== null && Ee !== void 0 ? Ee : 0, ze.version = (de = V.version) !== null && de !== void 0 ? de : "", ze.protocol = (ce = V.protocol) !== null && ce !== void 0 ? ce : 0, ze.region = (ve = V.region) !== null && ve !== void 0 ? ve : "", ze.nodeId = (Pe = V.nodeId) !== null && Pe !== void 0 ? Pe : "", ze.debugInfo = (Be = V.debugInfo) !== null && Be !== void 0 ? Be : "", ze;
    }
  };
  function A() {
    return {
      sdk: 0,
      version: "",
      protocol: 0,
      os: "",
      osVersion: "",
      deviceModel: "",
      browser: "",
      browserVersion: "",
      address: "",
      network: ""
    };
  }
  a.ClientInfo = {
    encode(V, Ee = l.default.Writer.create()) {
      return V.sdk !== 0 && Ee.uint32(8).int32(V.sdk), V.version !== "" && Ee.uint32(18).string(V.version), V.protocol !== 0 && Ee.uint32(24).int32(V.protocol), V.os !== "" && Ee.uint32(34).string(V.os), V.osVersion !== "" && Ee.uint32(42).string(V.osVersion), V.deviceModel !== "" && Ee.uint32(50).string(V.deviceModel), V.browser !== "" && Ee.uint32(58).string(V.browser), V.browserVersion !== "" && Ee.uint32(66).string(V.browserVersion), V.address !== "" && Ee.uint32(74).string(V.address), V.network !== "" && Ee.uint32(82).string(V.network), Ee;
    },
    decode(V, Ee) {
      const de = V instanceof l.default.Reader ? V : new l.default.Reader(V);
      let ce = Ee === void 0 ? de.len : de.pos + Ee;
      const ve = A();
      for (; de.pos < ce; ) {
        const Pe = de.uint32();
        switch (Pe >>> 3) {
          case 1:
            ve.sdk = de.int32();
            break;
          case 2:
            ve.version = de.string();
            break;
          case 3:
            ve.protocol = de.int32();
            break;
          case 4:
            ve.os = de.string();
            break;
          case 5:
            ve.osVersion = de.string();
            break;
          case 6:
            ve.deviceModel = de.string();
            break;
          case 7:
            ve.browser = de.string();
            break;
          case 8:
            ve.browserVersion = de.string();
            break;
          case 9:
            ve.address = de.string();
            break;
          case 10:
            ve.network = de.string();
            break;
          default:
            de.skipType(Pe & 7);
            break;
        }
      }
      return ve;
    },
    fromJSON(V) {
      return {
        sdk: Ie(V.sdk) ? U(V.sdk) : 0,
        version: Ie(V.version) ? String(V.version) : "",
        protocol: Ie(V.protocol) ? Number(V.protocol) : 0,
        os: Ie(V.os) ? String(V.os) : "",
        osVersion: Ie(V.osVersion) ? String(V.osVersion) : "",
        deviceModel: Ie(V.deviceModel) ? String(V.deviceModel) : "",
        browser: Ie(V.browser) ? String(V.browser) : "",
        browserVersion: Ie(V.browserVersion) ? String(V.browserVersion) : "",
        address: Ie(V.address) ? String(V.address) : "",
        network: Ie(V.network) ? String(V.network) : ""
      };
    },
    toJSON(V) {
      const Ee = {};
      return V.sdk !== void 0 && (Ee.sdk = Y(V.sdk)), V.version !== void 0 && (Ee.version = V.version), V.protocol !== void 0 && (Ee.protocol = Math.round(V.protocol)), V.os !== void 0 && (Ee.os = V.os), V.osVersion !== void 0 && (Ee.osVersion = V.osVersion), V.deviceModel !== void 0 && (Ee.deviceModel = V.deviceModel), V.browser !== void 0 && (Ee.browser = V.browser), V.browserVersion !== void 0 && (Ee.browserVersion = V.browserVersion), V.address !== void 0 && (Ee.address = V.address), V.network !== void 0 && (Ee.network = V.network), Ee;
    },
    fromPartial(V) {
      var Ee, de, ce, ve, Pe, Be, ze, Je, je, Ke;
      const x = A();
      return x.sdk = (Ee = V.sdk) !== null && Ee !== void 0 ? Ee : 0, x.version = (de = V.version) !== null && de !== void 0 ? de : "", x.protocol = (ce = V.protocol) !== null && ce !== void 0 ? ce : 0, x.os = (ve = V.os) !== null && ve !== void 0 ? ve : "", x.osVersion = (Pe = V.osVersion) !== null && Pe !== void 0 ? Pe : "", x.deviceModel = (Be = V.deviceModel) !== null && Be !== void 0 ? Be : "", x.browser = (ze = V.browser) !== null && ze !== void 0 ? ze : "", x.browserVersion = (Je = V.browserVersion) !== null && Je !== void 0 ? Je : "", x.address = (je = V.address) !== null && je !== void 0 ? je : "", x.network = (Ke = V.network) !== null && Ke !== void 0 ? Ke : "", x;
    }
  };
  function re() {
    return { video: void 0, screen: void 0, resumeConnection: 0, disabledCodecs: void 0, forceRelay: 0 };
  }
  a.ClientConfiguration = {
    encode(V, Ee = l.default.Writer.create()) {
      return V.video !== void 0 && a.VideoConfiguration.encode(V.video, Ee.uint32(10).fork()).ldelim(), V.screen !== void 0 && a.VideoConfiguration.encode(V.screen, Ee.uint32(18).fork()).ldelim(), V.resumeConnection !== 0 && Ee.uint32(24).int32(V.resumeConnection), V.disabledCodecs !== void 0 && a.DisabledCodecs.encode(V.disabledCodecs, Ee.uint32(34).fork()).ldelim(), V.forceRelay !== 0 && Ee.uint32(40).int32(V.forceRelay), Ee;
    },
    decode(V, Ee) {
      const de = V instanceof l.default.Reader ? V : new l.default.Reader(V);
      let ce = Ee === void 0 ? de.len : de.pos + Ee;
      const ve = re();
      for (; de.pos < ce; ) {
        const Pe = de.uint32();
        switch (Pe >>> 3) {
          case 1:
            ve.video = a.VideoConfiguration.decode(de, de.uint32());
            break;
          case 2:
            ve.screen = a.VideoConfiguration.decode(de, de.uint32());
            break;
          case 3:
            ve.resumeConnection = de.int32();
            break;
          case 4:
            ve.disabledCodecs = a.DisabledCodecs.decode(de, de.uint32());
            break;
          case 5:
            ve.forceRelay = de.int32();
            break;
          default:
            de.skipType(Pe & 7);
            break;
        }
      }
      return ve;
    },
    fromJSON(V) {
      return {
        video: Ie(V.video) ? a.VideoConfiguration.fromJSON(V.video) : void 0,
        screen: Ie(V.screen) ? a.VideoConfiguration.fromJSON(V.screen) : void 0,
        resumeConnection: Ie(V.resumeConnection) ? j(V.resumeConnection) : 0,
        disabledCodecs: Ie(V.disabledCodecs) ? a.DisabledCodecs.fromJSON(V.disabledCodecs) : void 0,
        forceRelay: Ie(V.forceRelay) ? j(V.forceRelay) : 0
      };
    },
    toJSON(V) {
      const Ee = {};
      return V.video !== void 0 && (Ee.video = V.video ? a.VideoConfiguration.toJSON(V.video) : void 0), V.screen !== void 0 && (Ee.screen = V.screen ? a.VideoConfiguration.toJSON(V.screen) : void 0), V.resumeConnection !== void 0 && (Ee.resumeConnection = ue(V.resumeConnection)), V.disabledCodecs !== void 0 && (Ee.disabledCodecs = V.disabledCodecs ? a.DisabledCodecs.toJSON(V.disabledCodecs) : void 0), V.forceRelay !== void 0 && (Ee.forceRelay = ue(V.forceRelay)), Ee;
    },
    fromPartial(V) {
      var Ee, de;
      const ce = re();
      return ce.video = V.video !== void 0 && V.video !== null ? a.VideoConfiguration.fromPartial(V.video) : void 0, ce.screen = V.screen !== void 0 && V.screen !== null ? a.VideoConfiguration.fromPartial(V.screen) : void 0, ce.resumeConnection = (Ee = V.resumeConnection) !== null && Ee !== void 0 ? Ee : 0, ce.disabledCodecs = V.disabledCodecs !== void 0 && V.disabledCodecs !== null ? a.DisabledCodecs.fromPartial(V.disabledCodecs) : void 0, ce.forceRelay = (de = V.forceRelay) !== null && de !== void 0 ? de : 0, ce;
    }
  };
  function le() {
    return { hardwareEncoder: 0 };
  }
  a.VideoConfiguration = {
    encode(V, Ee = l.default.Writer.create()) {
      return V.hardwareEncoder !== 0 && Ee.uint32(8).int32(V.hardwareEncoder), Ee;
    },
    decode(V, Ee) {
      const de = V instanceof l.default.Reader ? V : new l.default.Reader(V);
      let ce = Ee === void 0 ? de.len : de.pos + Ee;
      const ve = le();
      for (; de.pos < ce; ) {
        const Pe = de.uint32();
        switch (Pe >>> 3) {
          case 1:
            ve.hardwareEncoder = de.int32();
            break;
          default:
            de.skipType(Pe & 7);
            break;
        }
      }
      return ve;
    },
    fromJSON(V) {
      return { hardwareEncoder: Ie(V.hardwareEncoder) ? j(V.hardwareEncoder) : 0 };
    },
    toJSON(V) {
      const Ee = {};
      return V.hardwareEncoder !== void 0 && (Ee.hardwareEncoder = ue(V.hardwareEncoder)), Ee;
    },
    fromPartial(V) {
      var Ee;
      const de = le();
      return de.hardwareEncoder = (Ee = V.hardwareEncoder) !== null && Ee !== void 0 ? Ee : 0, de;
    }
  };
  function $e() {
    return { codecs: [] };
  }
  a.DisabledCodecs = {
    encode(V, Ee = l.default.Writer.create()) {
      for (const de of V.codecs)
        a.Codec.encode(de, Ee.uint32(10).fork()).ldelim();
      return Ee;
    },
    decode(V, Ee) {
      const de = V instanceof l.default.Reader ? V : new l.default.Reader(V);
      let ce = Ee === void 0 ? de.len : de.pos + Ee;
      const ve = $e();
      for (; de.pos < ce; ) {
        const Pe = de.uint32();
        switch (Pe >>> 3) {
          case 1:
            ve.codecs.push(a.Codec.decode(de, de.uint32()));
            break;
          default:
            de.skipType(Pe & 7);
            break;
        }
      }
      return ve;
    },
    fromJSON(V) {
      return { codecs: Array.isArray(V == null ? void 0 : V.codecs) ? V.codecs.map((Ee) => a.Codec.fromJSON(Ee)) : [] };
    },
    toJSON(V) {
      const Ee = {};
      return V.codecs ? Ee.codecs = V.codecs.map((de) => de ? a.Codec.toJSON(de) : void 0) : Ee.codecs = [], Ee;
    },
    fromPartial(V) {
      var Ee;
      const de = $e();
      return de.codecs = ((Ee = V.codecs) === null || Ee === void 0 ? void 0 : Ee.map((ce) => a.Codec.fromPartial(ce))) || [], de;
    }
  };
  function Oe() {
    return {
      startTime: void 0,
      endTime: void 0,
      duration: 0,
      packets: 0,
      packetRate: 0,
      bytes: 0,
      headerBytes: 0,
      bitrate: 0,
      packetsLost: 0,
      packetLossRate: 0,
      packetLossPercentage: 0,
      packetsDuplicate: 0,
      packetDuplicateRate: 0,
      bytesDuplicate: 0,
      headerBytesDuplicate: 0,
      bitrateDuplicate: 0,
      packetsPadding: 0,
      packetPaddingRate: 0,
      bytesPadding: 0,
      headerBytesPadding: 0,
      bitratePadding: 0,
      packetsOutOfOrder: 0,
      frames: 0,
      frameRate: 0,
      jitterCurrent: 0,
      jitterMax: 0,
      gapHistogram: {},
      nacks: 0,
      nackAcks: 0,
      nackMisses: 0,
      nackRepeated: 0,
      plis: 0,
      lastPli: void 0,
      firs: 0,
      lastFir: void 0,
      rttCurrent: 0,
      rttMax: 0,
      keyFrames: 0,
      lastKeyFrame: void 0,
      layerLockPlis: 0,
      lastLayerLockPli: void 0
    };
  }
  a.RTPStats = {
    encode(V, Ee = l.default.Writer.create()) {
      return V.startTime !== void 0 && v.Timestamp.encode(Ge(V.startTime), Ee.uint32(10).fork()).ldelim(), V.endTime !== void 0 && v.Timestamp.encode(Ge(V.endTime), Ee.uint32(18).fork()).ldelim(), V.duration !== 0 && Ee.uint32(25).double(V.duration), V.packets !== 0 && Ee.uint32(32).uint32(V.packets), V.packetRate !== 0 && Ee.uint32(41).double(V.packetRate), V.bytes !== 0 && Ee.uint32(48).uint64(V.bytes), V.headerBytes !== 0 && Ee.uint32(312).uint64(V.headerBytes), V.bitrate !== 0 && Ee.uint32(57).double(V.bitrate), V.packetsLost !== 0 && Ee.uint32(64).uint32(V.packetsLost), V.packetLossRate !== 0 && Ee.uint32(73).double(V.packetLossRate), V.packetLossPercentage !== 0 && Ee.uint32(85).float(V.packetLossPercentage), V.packetsDuplicate !== 0 && Ee.uint32(88).uint32(V.packetsDuplicate), V.packetDuplicateRate !== 0 && Ee.uint32(97).double(V.packetDuplicateRate), V.bytesDuplicate !== 0 && Ee.uint32(104).uint64(V.bytesDuplicate), V.headerBytesDuplicate !== 0 && Ee.uint32(320).uint64(V.headerBytesDuplicate), V.bitrateDuplicate !== 0 && Ee.uint32(113).double(V.bitrateDuplicate), V.packetsPadding !== 0 && Ee.uint32(120).uint32(V.packetsPadding), V.packetPaddingRate !== 0 && Ee.uint32(129).double(V.packetPaddingRate), V.bytesPadding !== 0 && Ee.uint32(136).uint64(V.bytesPadding), V.headerBytesPadding !== 0 && Ee.uint32(328).uint64(V.headerBytesPadding), V.bitratePadding !== 0 && Ee.uint32(145).double(V.bitratePadding), V.packetsOutOfOrder !== 0 && Ee.uint32(152).uint32(V.packetsOutOfOrder), V.frames !== 0 && Ee.uint32(160).uint32(V.frames), V.frameRate !== 0 && Ee.uint32(169).double(V.frameRate), V.jitterCurrent !== 0 && Ee.uint32(177).double(V.jitterCurrent), V.jitterMax !== 0 && Ee.uint32(185).double(V.jitterMax), Object.entries(V.gapHistogram).forEach(([de, ce]) => {
        a.RTPStats_GapHistogramEntry.encode({ key: de, value: ce }, Ee.uint32(194).fork()).ldelim();
      }), V.nacks !== 0 && Ee.uint32(200).uint32(V.nacks), V.nackAcks !== 0 && Ee.uint32(296).uint32(V.nackAcks), V.nackMisses !== 0 && Ee.uint32(208).uint32(V.nackMisses), V.nackRepeated !== 0 && Ee.uint32(304).uint32(V.nackRepeated), V.plis !== 0 && Ee.uint32(216).uint32(V.plis), V.lastPli !== void 0 && v.Timestamp.encode(Ge(V.lastPli), Ee.uint32(226).fork()).ldelim(), V.firs !== 0 && Ee.uint32(232).uint32(V.firs), V.lastFir !== void 0 && v.Timestamp.encode(Ge(V.lastFir), Ee.uint32(242).fork()).ldelim(), V.rttCurrent !== 0 && Ee.uint32(248).uint32(V.rttCurrent), V.rttMax !== 0 && Ee.uint32(256).uint32(V.rttMax), V.keyFrames !== 0 && Ee.uint32(264).uint32(V.keyFrames), V.lastKeyFrame !== void 0 && v.Timestamp.encode(Ge(V.lastKeyFrame), Ee.uint32(274).fork()).ldelim(), V.layerLockPlis !== 0 && Ee.uint32(280).uint32(V.layerLockPlis), V.lastLayerLockPli !== void 0 && v.Timestamp.encode(Ge(V.lastLayerLockPli), Ee.uint32(290).fork()).ldelim(), Ee;
    },
    decode(V, Ee) {
      const de = V instanceof l.default.Reader ? V : new l.default.Reader(V);
      let ce = Ee === void 0 ? de.len : de.pos + Ee;
      const ve = Oe();
      for (; de.pos < ce; ) {
        const Pe = de.uint32();
        switch (Pe >>> 3) {
          case 1:
            ve.startTime = J(v.Timestamp.decode(de, de.uint32()));
            break;
          case 2:
            ve.endTime = J(v.Timestamp.decode(de, de.uint32()));
            break;
          case 3:
            ve.duration = de.double();
            break;
          case 4:
            ve.packets = de.uint32();
            break;
          case 5:
            ve.packetRate = de.double();
            break;
          case 6:
            ve.bytes = we(de.uint64());
            break;
          case 39:
            ve.headerBytes = we(de.uint64());
            break;
          case 7:
            ve.bitrate = de.double();
            break;
          case 8:
            ve.packetsLost = de.uint32();
            break;
          case 9:
            ve.packetLossRate = de.double();
            break;
          case 10:
            ve.packetLossPercentage = de.float();
            break;
          case 11:
            ve.packetsDuplicate = de.uint32();
            break;
          case 12:
            ve.packetDuplicateRate = de.double();
            break;
          case 13:
            ve.bytesDuplicate = we(de.uint64());
            break;
          case 40:
            ve.headerBytesDuplicate = we(de.uint64());
            break;
          case 14:
            ve.bitrateDuplicate = de.double();
            break;
          case 15:
            ve.packetsPadding = de.uint32();
            break;
          case 16:
            ve.packetPaddingRate = de.double();
            break;
          case 17:
            ve.bytesPadding = we(de.uint64());
            break;
          case 41:
            ve.headerBytesPadding = we(de.uint64());
            break;
          case 18:
            ve.bitratePadding = de.double();
            break;
          case 19:
            ve.packetsOutOfOrder = de.uint32();
            break;
          case 20:
            ve.frames = de.uint32();
            break;
          case 21:
            ve.frameRate = de.double();
            break;
          case 22:
            ve.jitterCurrent = de.double();
            break;
          case 23:
            ve.jitterMax = de.double();
            break;
          case 24:
            const Be = a.RTPStats_GapHistogramEntry.decode(de, de.uint32());
            Be.value !== void 0 && (ve.gapHistogram[Be.key] = Be.value);
            break;
          case 25:
            ve.nacks = de.uint32();
            break;
          case 37:
            ve.nackAcks = de.uint32();
            break;
          case 26:
            ve.nackMisses = de.uint32();
            break;
          case 38:
            ve.nackRepeated = de.uint32();
            break;
          case 27:
            ve.plis = de.uint32();
            break;
          case 28:
            ve.lastPli = J(v.Timestamp.decode(de, de.uint32()));
            break;
          case 29:
            ve.firs = de.uint32();
            break;
          case 30:
            ve.lastFir = J(v.Timestamp.decode(de, de.uint32()));
            break;
          case 31:
            ve.rttCurrent = de.uint32();
            break;
          case 32:
            ve.rttMax = de.uint32();
            break;
          case 33:
            ve.keyFrames = de.uint32();
            break;
          case 34:
            ve.lastKeyFrame = J(v.Timestamp.decode(de, de.uint32()));
            break;
          case 35:
            ve.layerLockPlis = de.uint32();
            break;
          case 36:
            ve.lastLayerLockPli = J(v.Timestamp.decode(de, de.uint32()));
            break;
          default:
            de.skipType(Pe & 7);
            break;
        }
      }
      return ve;
    },
    fromJSON(V) {
      return {
        startTime: Ie(V.startTime) ? ge(V.startTime) : void 0,
        endTime: Ie(V.endTime) ? ge(V.endTime) : void 0,
        duration: Ie(V.duration) ? Number(V.duration) : 0,
        packets: Ie(V.packets) ? Number(V.packets) : 0,
        packetRate: Ie(V.packetRate) ? Number(V.packetRate) : 0,
        bytes: Ie(V.bytes) ? Number(V.bytes) : 0,
        headerBytes: Ie(V.headerBytes) ? Number(V.headerBytes) : 0,
        bitrate: Ie(V.bitrate) ? Number(V.bitrate) : 0,
        packetsLost: Ie(V.packetsLost) ? Number(V.packetsLost) : 0,
        packetLossRate: Ie(V.packetLossRate) ? Number(V.packetLossRate) : 0,
        packetLossPercentage: Ie(V.packetLossPercentage) ? Number(V.packetLossPercentage) : 0,
        packetsDuplicate: Ie(V.packetsDuplicate) ? Number(V.packetsDuplicate) : 0,
        packetDuplicateRate: Ie(V.packetDuplicateRate) ? Number(V.packetDuplicateRate) : 0,
        bytesDuplicate: Ie(V.bytesDuplicate) ? Number(V.bytesDuplicate) : 0,
        headerBytesDuplicate: Ie(V.headerBytesDuplicate) ? Number(V.headerBytesDuplicate) : 0,
        bitrateDuplicate: Ie(V.bitrateDuplicate) ? Number(V.bitrateDuplicate) : 0,
        packetsPadding: Ie(V.packetsPadding) ? Number(V.packetsPadding) : 0,
        packetPaddingRate: Ie(V.packetPaddingRate) ? Number(V.packetPaddingRate) : 0,
        bytesPadding: Ie(V.bytesPadding) ? Number(V.bytesPadding) : 0,
        headerBytesPadding: Ie(V.headerBytesPadding) ? Number(V.headerBytesPadding) : 0,
        bitratePadding: Ie(V.bitratePadding) ? Number(V.bitratePadding) : 0,
        packetsOutOfOrder: Ie(V.packetsOutOfOrder) ? Number(V.packetsOutOfOrder) : 0,
        frames: Ie(V.frames) ? Number(V.frames) : 0,
        frameRate: Ie(V.frameRate) ? Number(V.frameRate) : 0,
        jitterCurrent: Ie(V.jitterCurrent) ? Number(V.jitterCurrent) : 0,
        jitterMax: Ie(V.jitterMax) ? Number(V.jitterMax) : 0,
        gapHistogram: We(V.gapHistogram) ? Object.entries(V.gapHistogram).reduce((Ee, [de, ce]) => (Ee[Number(de)] = Number(ce), Ee), {}) : {},
        nacks: Ie(V.nacks) ? Number(V.nacks) : 0,
        nackAcks: Ie(V.nackAcks) ? Number(V.nackAcks) : 0,
        nackMisses: Ie(V.nackMisses) ? Number(V.nackMisses) : 0,
        nackRepeated: Ie(V.nackRepeated) ? Number(V.nackRepeated) : 0,
        plis: Ie(V.plis) ? Number(V.plis) : 0,
        lastPli: Ie(V.lastPli) ? ge(V.lastPli) : void 0,
        firs: Ie(V.firs) ? Number(V.firs) : 0,
        lastFir: Ie(V.lastFir) ? ge(V.lastFir) : void 0,
        rttCurrent: Ie(V.rttCurrent) ? Number(V.rttCurrent) : 0,
        rttMax: Ie(V.rttMax) ? Number(V.rttMax) : 0,
        keyFrames: Ie(V.keyFrames) ? Number(V.keyFrames) : 0,
        lastKeyFrame: Ie(V.lastKeyFrame) ? ge(V.lastKeyFrame) : void 0,
        layerLockPlis: Ie(V.layerLockPlis) ? Number(V.layerLockPlis) : 0,
        lastLayerLockPli: Ie(V.lastLayerLockPli) ? ge(V.lastLayerLockPli) : void 0
      };
    },
    toJSON(V) {
      const Ee = {};
      return V.startTime !== void 0 && (Ee.startTime = V.startTime.toISOString()), V.endTime !== void 0 && (Ee.endTime = V.endTime.toISOString()), V.duration !== void 0 && (Ee.duration = V.duration), V.packets !== void 0 && (Ee.packets = Math.round(V.packets)), V.packetRate !== void 0 && (Ee.packetRate = V.packetRate), V.bytes !== void 0 && (Ee.bytes = Math.round(V.bytes)), V.headerBytes !== void 0 && (Ee.headerBytes = Math.round(V.headerBytes)), V.bitrate !== void 0 && (Ee.bitrate = V.bitrate), V.packetsLost !== void 0 && (Ee.packetsLost = Math.round(V.packetsLost)), V.packetLossRate !== void 0 && (Ee.packetLossRate = V.packetLossRate), V.packetLossPercentage !== void 0 && (Ee.packetLossPercentage = V.packetLossPercentage), V.packetsDuplicate !== void 0 && (Ee.packetsDuplicate = Math.round(V.packetsDuplicate)), V.packetDuplicateRate !== void 0 && (Ee.packetDuplicateRate = V.packetDuplicateRate), V.bytesDuplicate !== void 0 && (Ee.bytesDuplicate = Math.round(V.bytesDuplicate)), V.headerBytesDuplicate !== void 0 && (Ee.headerBytesDuplicate = Math.round(V.headerBytesDuplicate)), V.bitrateDuplicate !== void 0 && (Ee.bitrateDuplicate = V.bitrateDuplicate), V.packetsPadding !== void 0 && (Ee.packetsPadding = Math.round(V.packetsPadding)), V.packetPaddingRate !== void 0 && (Ee.packetPaddingRate = V.packetPaddingRate), V.bytesPadding !== void 0 && (Ee.bytesPadding = Math.round(V.bytesPadding)), V.headerBytesPadding !== void 0 && (Ee.headerBytesPadding = Math.round(V.headerBytesPadding)), V.bitratePadding !== void 0 && (Ee.bitratePadding = V.bitratePadding), V.packetsOutOfOrder !== void 0 && (Ee.packetsOutOfOrder = Math.round(V.packetsOutOfOrder)), V.frames !== void 0 && (Ee.frames = Math.round(V.frames)), V.frameRate !== void 0 && (Ee.frameRate = V.frameRate), V.jitterCurrent !== void 0 && (Ee.jitterCurrent = V.jitterCurrent), V.jitterMax !== void 0 && (Ee.jitterMax = V.jitterMax), Ee.gapHistogram = {}, V.gapHistogram && Object.entries(V.gapHistogram).forEach(([de, ce]) => {
        Ee.gapHistogram[de] = Math.round(ce);
      }), V.nacks !== void 0 && (Ee.nacks = Math.round(V.nacks)), V.nackAcks !== void 0 && (Ee.nackAcks = Math.round(V.nackAcks)), V.nackMisses !== void 0 && (Ee.nackMisses = Math.round(V.nackMisses)), V.nackRepeated !== void 0 && (Ee.nackRepeated = Math.round(V.nackRepeated)), V.plis !== void 0 && (Ee.plis = Math.round(V.plis)), V.lastPli !== void 0 && (Ee.lastPli = V.lastPli.toISOString()), V.firs !== void 0 && (Ee.firs = Math.round(V.firs)), V.lastFir !== void 0 && (Ee.lastFir = V.lastFir.toISOString()), V.rttCurrent !== void 0 && (Ee.rttCurrent = Math.round(V.rttCurrent)), V.rttMax !== void 0 && (Ee.rttMax = Math.round(V.rttMax)), V.keyFrames !== void 0 && (Ee.keyFrames = Math.round(V.keyFrames)), V.lastKeyFrame !== void 0 && (Ee.lastKeyFrame = V.lastKeyFrame.toISOString()), V.layerLockPlis !== void 0 && (Ee.layerLockPlis = Math.round(V.layerLockPlis)), V.lastLayerLockPli !== void 0 && (Ee.lastLayerLockPli = V.lastLayerLockPli.toISOString()), Ee;
    },
    fromPartial(V) {
      var Ee, de, ce, ve, Pe, Be, ze, Je, je, Ke, x, se, Se, xe, Ae, Ye, et, dt, St, tt, at, kt, rt, ut, wt, nt, it, bt, ot, ct, Pt, st, lt, It, Rt, Ve, He, Qe, pt, mt, vt;
      const ht = Oe();
      return ht.startTime = (Ee = V.startTime) !== null && Ee !== void 0 ? Ee : void 0, ht.endTime = (de = V.endTime) !== null && de !== void 0 ? de : void 0, ht.duration = (ce = V.duration) !== null && ce !== void 0 ? ce : 0, ht.packets = (ve = V.packets) !== null && ve !== void 0 ? ve : 0, ht.packetRate = (Pe = V.packetRate) !== null && Pe !== void 0 ? Pe : 0, ht.bytes = (Be = V.bytes) !== null && Be !== void 0 ? Be : 0, ht.headerBytes = (ze = V.headerBytes) !== null && ze !== void 0 ? ze : 0, ht.bitrate = (Je = V.bitrate) !== null && Je !== void 0 ? Je : 0, ht.packetsLost = (je = V.packetsLost) !== null && je !== void 0 ? je : 0, ht.packetLossRate = (Ke = V.packetLossRate) !== null && Ke !== void 0 ? Ke : 0, ht.packetLossPercentage = (x = V.packetLossPercentage) !== null && x !== void 0 ? x : 0, ht.packetsDuplicate = (se = V.packetsDuplicate) !== null && se !== void 0 ? se : 0, ht.packetDuplicateRate = (Se = V.packetDuplicateRate) !== null && Se !== void 0 ? Se : 0, ht.bytesDuplicate = (xe = V.bytesDuplicate) !== null && xe !== void 0 ? xe : 0, ht.headerBytesDuplicate = (Ae = V.headerBytesDuplicate) !== null && Ae !== void 0 ? Ae : 0, ht.bitrateDuplicate = (Ye = V.bitrateDuplicate) !== null && Ye !== void 0 ? Ye : 0, ht.packetsPadding = (et = V.packetsPadding) !== null && et !== void 0 ? et : 0, ht.packetPaddingRate = (dt = V.packetPaddingRate) !== null && dt !== void 0 ? dt : 0, ht.bytesPadding = (St = V.bytesPadding) !== null && St !== void 0 ? St : 0, ht.headerBytesPadding = (tt = V.headerBytesPadding) !== null && tt !== void 0 ? tt : 0, ht.bitratePadding = (at = V.bitratePadding) !== null && at !== void 0 ? at : 0, ht.packetsOutOfOrder = (kt = V.packetsOutOfOrder) !== null && kt !== void 0 ? kt : 0, ht.frames = (rt = V.frames) !== null && rt !== void 0 ? rt : 0, ht.frameRate = (ut = V.frameRate) !== null && ut !== void 0 ? ut : 0, ht.jitterCurrent = (wt = V.jitterCurrent) !== null && wt !== void 0 ? wt : 0, ht.jitterMax = (nt = V.jitterMax) !== null && nt !== void 0 ? nt : 0, ht.gapHistogram = Object.entries((it = V.gapHistogram) !== null && it !== void 0 ? it : {}).reduce((Et, [Tt, Ot]) => (Ot !== void 0 && (Et[Number(Tt)] = Number(Ot)), Et), {}), ht.nacks = (bt = V.nacks) !== null && bt !== void 0 ? bt : 0, ht.nackAcks = (ot = V.nackAcks) !== null && ot !== void 0 ? ot : 0, ht.nackMisses = (ct = V.nackMisses) !== null && ct !== void 0 ? ct : 0, ht.nackRepeated = (Pt = V.nackRepeated) !== null && Pt !== void 0 ? Pt : 0, ht.plis = (st = V.plis) !== null && st !== void 0 ? st : 0, ht.lastPli = (lt = V.lastPli) !== null && lt !== void 0 ? lt : void 0, ht.firs = (It = V.firs) !== null && It !== void 0 ? It : 0, ht.lastFir = (Rt = V.lastFir) !== null && Rt !== void 0 ? Rt : void 0, ht.rttCurrent = (Ve = V.rttCurrent) !== null && Ve !== void 0 ? Ve : 0, ht.rttMax = (He = V.rttMax) !== null && He !== void 0 ? He : 0, ht.keyFrames = (Qe = V.keyFrames) !== null && Qe !== void 0 ? Qe : 0, ht.lastKeyFrame = (pt = V.lastKeyFrame) !== null && pt !== void 0 ? pt : void 0, ht.layerLockPlis = (mt = V.layerLockPlis) !== null && mt !== void 0 ? mt : 0, ht.lastLayerLockPli = (vt = V.lastLayerLockPli) !== null && vt !== void 0 ? vt : void 0, ht;
    }
  };
  function Fe() {
    return { key: 0, value: 0 };
  }
  a.RTPStats_GapHistogramEntry = {
    encode(V, Ee = l.default.Writer.create()) {
      return V.key !== 0 && Ee.uint32(8).int32(V.key), V.value !== 0 && Ee.uint32(16).uint32(V.value), Ee;
    },
    decode(V, Ee) {
      const de = V instanceof l.default.Reader ? V : new l.default.Reader(V);
      let ce = Ee === void 0 ? de.len : de.pos + Ee;
      const ve = Fe();
      for (; de.pos < ce; ) {
        const Pe = de.uint32();
        switch (Pe >>> 3) {
          case 1:
            ve.key = de.int32();
            break;
          case 2:
            ve.value = de.uint32();
            break;
          default:
            de.skipType(Pe & 7);
            break;
        }
      }
      return ve;
    },
    fromJSON(V) {
      return { key: Ie(V.key) ? Number(V.key) : 0, value: Ie(V.value) ? Number(V.value) : 0 };
    },
    toJSON(V) {
      const Ee = {};
      return V.key !== void 0 && (Ee.key = Math.round(V.key)), V.value !== void 0 && (Ee.value = Math.round(V.value)), Ee;
    },
    fromPartial(V) {
      var Ee, de;
      const ce = Fe();
      return ce.key = (Ee = V.key) !== null && Ee !== void 0 ? Ee : 0, ce.value = (de = V.value) !== null && de !== void 0 ? de : 0, ce;
    }
  };
  function Ze() {
    return { unixMicro: 0, ticks: 0 };
  }
  a.TimedVersion = {
    encode(V, Ee = l.default.Writer.create()) {
      return V.unixMicro !== 0 && Ee.uint32(8).int64(V.unixMicro), V.ticks !== 0 && Ee.uint32(16).int32(V.ticks), Ee;
    },
    decode(V, Ee) {
      const de = V instanceof l.default.Reader ? V : new l.default.Reader(V);
      let ce = Ee === void 0 ? de.len : de.pos + Ee;
      const ve = Ze();
      for (; de.pos < ce; ) {
        const Pe = de.uint32();
        switch (Pe >>> 3) {
          case 1:
            ve.unixMicro = we(de.int64());
            break;
          case 2:
            ve.ticks = de.int32();
            break;
          default:
            de.skipType(Pe & 7);
            break;
        }
      }
      return ve;
    },
    fromJSON(V) {
      return {
        unixMicro: Ie(V.unixMicro) ? Number(V.unixMicro) : 0,
        ticks: Ie(V.ticks) ? Number(V.ticks) : 0
      };
    },
    toJSON(V) {
      const Ee = {};
      return V.unixMicro !== void 0 && (Ee.unixMicro = Math.round(V.unixMicro)), V.ticks !== void 0 && (Ee.ticks = Math.round(V.ticks)), Ee;
    },
    fromPartial(V) {
      var Ee, de;
      const ce = Ze();
      return ce.unixMicro = (Ee = V.unixMicro) !== null && Ee !== void 0 ? Ee : 0, ce.ticks = (de = V.ticks) !== null && de !== void 0 ? de : 0, ce;
    }
  };
  var qe = (() => {
    if (typeof qe < "u")
      return qe;
    if (typeof self < "u")
      return self;
    if (typeof window < "u")
      return window;
    if (typeof commonjsGlobal$1 < "u")
      return commonjsGlobal$1;
    throw "Unable to locate global object";
  })();
  function yt(V) {
    if (qe.Buffer)
      return Uint8Array.from(qe.Buffer.from(V, "base64"));
    {
      const Ee = qe.atob(V), de = new Uint8Array(Ee.length);
      for (let ce = 0; ce < Ee.length; ++ce)
        de[ce] = Ee.charCodeAt(ce);
      return de;
    }
  }
  function Xe(V) {
    if (qe.Buffer)
      return qe.Buffer.from(V).toString("base64");
    {
      const Ee = [];
      return V.forEach((de) => {
        Ee.push(String.fromCharCode(de));
      }), qe.btoa(Ee.join(""));
    }
  }
  function Ge(V) {
    const Ee = V.getTime() / 1e3, de = V.getTime() % 1e3 * 1e6;
    return { seconds: Ee, nanos: de };
  }
  function J(V) {
    let Ee = V.seconds * 1e3;
    return Ee += V.nanos / 1e6, new Date(Ee);
  }
  function ge(V) {
    return V instanceof Date ? V : typeof V == "string" ? new Date(V) : J(v.Timestamp.fromJSON(V));
  }
  function we(V) {
    if (V.gt(Number.MAX_SAFE_INTEGER))
      throw new qe.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    return V.toNumber();
  }
  l.default.util.Long !== c.default && (l.default.util.Long = c.default, l.default.configure());
  function We(V) {
    return typeof V == "object" && V !== null;
  }
  function Ie(V) {
    return V != null;
  }
})(livekit_models);
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(q) {
    return q && q.__esModule ? q : { default: q };
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.DeleteIngressRequest = a.ListIngressResponse = a.ListIngressRequest = a.UpdateIngressRequest = a.InputAudioState = a.InputVideoState = a.IngressState = a.IngressInfo = a.IngressVideoOptions = a.IngressAudioOptions = a.CreateIngressRequest = a.ingressState_StatusToJSON = a.ingressState_StatusFromJSON = a.IngressState_Status = a.ingressInputToJSON = a.ingressInputFromJSON = a.IngressInput = a.protobufPackage = void 0;
  const c = u(umdExports), l = u(minimal), v = livekit_models;
  a.protobufPackage = "livekit";
  var p;
  (function(q) {
    q[q.RTMP_INPUT = 0] = "RTMP_INPUT", q[q.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(p = a.IngressInput || (a.IngressInput = {}));
  function _(q) {
    switch (q) {
      case 0:
      case "RTMP_INPUT":
        return p.RTMP_INPUT;
      case -1:
      case "UNRECOGNIZED":
      default:
        return p.UNRECOGNIZED;
    }
  }
  a.ingressInputFromJSON = _;
  function k(q) {
    switch (q) {
      case p.RTMP_INPUT:
        return "RTMP_INPUT";
      case p.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.ingressInputToJSON = k;
  var O;
  (function(q) {
    q[q.ENDPOINT_INACTIVE = 0] = "ENDPOINT_INACTIVE", q[q.ENDPOINT_BUFFERING = 1] = "ENDPOINT_BUFFERING", q[q.ENDPOINT_PUBLISHING = 2] = "ENDPOINT_PUBLISHING", q[q.ENDPOINT_ERROR = 3] = "ENDPOINT_ERROR", q[q.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(O = a.IngressState_Status || (a.IngressState_Status = {}));
  function D(q) {
    switch (q) {
      case 0:
      case "ENDPOINT_INACTIVE":
        return O.ENDPOINT_INACTIVE;
      case 1:
      case "ENDPOINT_BUFFERING":
        return O.ENDPOINT_BUFFERING;
      case 2:
      case "ENDPOINT_PUBLISHING":
        return O.ENDPOINT_PUBLISHING;
      case 3:
      case "ENDPOINT_ERROR":
        return O.ENDPOINT_ERROR;
      case -1:
      case "UNRECOGNIZED":
      default:
        return O.UNRECOGNIZED;
    }
  }
  a.ingressState_StatusFromJSON = D;
  function F(q) {
    switch (q) {
      case O.ENDPOINT_INACTIVE:
        return "ENDPOINT_INACTIVE";
      case O.ENDPOINT_BUFFERING:
        return "ENDPOINT_BUFFERING";
      case O.ENDPOINT_PUBLISHING:
        return "ENDPOINT_PUBLISHING";
      case O.ENDPOINT_ERROR:
        return "ENDPOINT_ERROR";
      case O.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.ingressState_StatusToJSON = F;
  function H() {
    return {
      inputType: 0,
      name: "",
      roomName: "",
      participantIdentity: "",
      participantName: "",
      audio: void 0,
      video: void 0
    };
  }
  a.CreateIngressRequest = {
    encode(q, z = l.default.Writer.create()) {
      return q.inputType !== void 0 && q.inputType !== 0 && z.uint32(8).int32(q.inputType), q.name !== void 0 && q.name !== "" && z.uint32(18).string(q.name), q.roomName !== void 0 && q.roomName !== "" && z.uint32(26).string(q.roomName), q.participantIdentity !== void 0 && q.participantIdentity !== "" && z.uint32(34).string(q.participantIdentity), q.participantName !== void 0 && q.participantName !== "" && z.uint32(42).string(q.participantName), q.audio !== void 0 && a.IngressAudioOptions.encode(q.audio, z.uint32(50).fork()).ldelim(), q.video !== void 0 && a.IngressVideoOptions.encode(q.video, z.uint32(58).fork()).ldelim(), z;
    },
    decode(q, z) {
      const P = q instanceof l.default.Reader ? q : new l.default.Reader(q);
      let S = z === void 0 ? P.len : P.pos + z;
      const E = H();
      for (; P.pos < S; ) {
        const I = P.uint32();
        switch (I >>> 3) {
          case 1:
            E.inputType = P.int32();
            break;
          case 2:
            E.name = P.string();
            break;
          case 3:
            E.roomName = P.string();
            break;
          case 4:
            E.participantIdentity = P.string();
            break;
          case 5:
            E.participantName = P.string();
            break;
          case 6:
            E.audio = a.IngressAudioOptions.decode(P, P.uint32());
            break;
          case 7:
            E.video = a.IngressVideoOptions.decode(P, P.uint32());
            break;
          default:
            P.skipType(I & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(q) {
      return {
        inputType: Te(q.inputType) ? _(q.inputType) : 0,
        name: Te(q.name) ? String(q.name) : "",
        roomName: Te(q.roomName) ? String(q.roomName) : "",
        participantIdentity: Te(q.participantIdentity) ? String(q.participantIdentity) : "",
        participantName: Te(q.participantName) ? String(q.participantName) : "",
        audio: Te(q.audio) ? a.IngressAudioOptions.fromJSON(q.audio) : void 0,
        video: Te(q.video) ? a.IngressVideoOptions.fromJSON(q.video) : void 0
      };
    },
    toJSON(q) {
      const z = {};
      return q.inputType !== void 0 && (z.inputType = k(q.inputType)), q.name !== void 0 && (z.name = q.name), q.roomName !== void 0 && (z.roomName = q.roomName), q.participantIdentity !== void 0 && (z.participantIdentity = q.participantIdentity), q.participantName !== void 0 && (z.participantName = q.participantName), q.audio !== void 0 && (z.audio = q.audio ? a.IngressAudioOptions.toJSON(q.audio) : void 0), q.video !== void 0 && (z.video = q.video ? a.IngressVideoOptions.toJSON(q.video) : void 0), z;
    },
    fromPartial(q) {
      var z, P, S, E, I;
      const M = H();
      return M.inputType = (z = q.inputType) !== null && z !== void 0 ? z : 0, M.name = (P = q.name) !== null && P !== void 0 ? P : "", M.roomName = (S = q.roomName) !== null && S !== void 0 ? S : "", M.participantIdentity = (E = q.participantIdentity) !== null && E !== void 0 ? E : "", M.participantName = (I = q.participantName) !== null && I !== void 0 ? I : "", M.audio = q.audio !== void 0 && q.audio !== null ? a.IngressAudioOptions.fromPartial(q.audio) : void 0, M.video = q.video !== void 0 && q.video !== null ? a.IngressVideoOptions.fromPartial(q.video) : void 0, M;
    }
  };
  function Z() {
    return { name: "", source: 0, mimeType: "", bitrate: 0, disableDtx: !1, channels: 0 };
  }
  a.IngressAudioOptions = {
    encode(q, z = l.default.Writer.create()) {
      return q.name !== void 0 && q.name !== "" && z.uint32(10).string(q.name), q.source !== void 0 && q.source !== 0 && z.uint32(16).int32(q.source), q.mimeType !== void 0 && q.mimeType !== "" && z.uint32(26).string(q.mimeType), q.bitrate !== void 0 && q.bitrate !== 0 && z.uint32(32).uint32(q.bitrate), q.disableDtx === !0 && z.uint32(40).bool(q.disableDtx), q.channels !== void 0 && q.channels !== 0 && z.uint32(48).uint32(q.channels), z;
    },
    decode(q, z) {
      const P = q instanceof l.default.Reader ? q : new l.default.Reader(q);
      let S = z === void 0 ? P.len : P.pos + z;
      const E = Z();
      for (; P.pos < S; ) {
        const I = P.uint32();
        switch (I >>> 3) {
          case 1:
            E.name = P.string();
            break;
          case 2:
            E.source = P.int32();
            break;
          case 3:
            E.mimeType = P.string();
            break;
          case 4:
            E.bitrate = P.uint32();
            break;
          case 5:
            E.disableDtx = P.bool();
            break;
          case 6:
            E.channels = P.uint32();
            break;
          default:
            P.skipType(I & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(q) {
      return {
        name: Te(q.name) ? String(q.name) : "",
        source: Te(q.source) ? v.trackSourceFromJSON(q.source) : 0,
        mimeType: Te(q.mimeType) ? String(q.mimeType) : "",
        bitrate: Te(q.bitrate) ? Number(q.bitrate) : 0,
        disableDtx: Te(q.disableDtx) ? !!q.disableDtx : !1,
        channels: Te(q.channels) ? Number(q.channels) : 0
      };
    },
    toJSON(q) {
      const z = {};
      return q.name !== void 0 && (z.name = q.name), q.source !== void 0 && (z.source = v.trackSourceToJSON(q.source)), q.mimeType !== void 0 && (z.mimeType = q.mimeType), q.bitrate !== void 0 && (z.bitrate = Math.round(q.bitrate)), q.disableDtx !== void 0 && (z.disableDtx = q.disableDtx), q.channels !== void 0 && (z.channels = Math.round(q.channels)), z;
    },
    fromPartial(q) {
      var z, P, S, E, I, M;
      const $ = Z();
      return $.name = (z = q.name) !== null && z !== void 0 ? z : "", $.source = (P = q.source) !== null && P !== void 0 ? P : 0, $.mimeType = (S = q.mimeType) !== null && S !== void 0 ? S : "", $.bitrate = (E = q.bitrate) !== null && E !== void 0 ? E : 0, $.disableDtx = (I = q.disableDtx) !== null && I !== void 0 ? I : !1, $.channels = (M = q.channels) !== null && M !== void 0 ? M : 0, $;
    }
  };
  function ee() {
    return { name: "", source: 0, mimeType: "", layers: [] };
  }
  a.IngressVideoOptions = {
    encode(q, z = l.default.Writer.create()) {
      if (q.name !== void 0 && q.name !== "" && z.uint32(10).string(q.name), q.source !== void 0 && q.source !== 0 && z.uint32(16).int32(q.source), q.mimeType !== void 0 && q.mimeType !== "" && z.uint32(26).string(q.mimeType), q.layers !== void 0 && q.layers.length !== 0)
        for (const P of q.layers)
          v.VideoLayer.encode(P, z.uint32(34).fork()).ldelim();
      return z;
    },
    decode(q, z) {
      const P = q instanceof l.default.Reader ? q : new l.default.Reader(q);
      let S = z === void 0 ? P.len : P.pos + z;
      const E = ee();
      for (; P.pos < S; ) {
        const I = P.uint32();
        switch (I >>> 3) {
          case 1:
            E.name = P.string();
            break;
          case 2:
            E.source = P.int32();
            break;
          case 3:
            E.mimeType = P.string();
            break;
          case 4:
            E.layers.push(v.VideoLayer.decode(P, P.uint32()));
            break;
          default:
            P.skipType(I & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(q) {
      return {
        name: Te(q.name) ? String(q.name) : "",
        source: Te(q.source) ? v.trackSourceFromJSON(q.source) : 0,
        mimeType: Te(q.mimeType) ? String(q.mimeType) : "",
        layers: Array.isArray(q == null ? void 0 : q.layers) ? q.layers.map((z) => v.VideoLayer.fromJSON(z)) : []
      };
    },
    toJSON(q) {
      const z = {};
      return q.name !== void 0 && (z.name = q.name), q.source !== void 0 && (z.source = v.trackSourceToJSON(q.source)), q.mimeType !== void 0 && (z.mimeType = q.mimeType), q.layers ? z.layers = q.layers.map((P) => P ? v.VideoLayer.toJSON(P) : void 0) : z.layers = [], z;
    },
    fromPartial(q) {
      var z, P, S, E;
      const I = ee();
      return I.name = (z = q.name) !== null && z !== void 0 ? z : "", I.source = (P = q.source) !== null && P !== void 0 ? P : 0, I.mimeType = (S = q.mimeType) !== null && S !== void 0 ? S : "", I.layers = ((E = q.layers) === null || E === void 0 ? void 0 : E.map((M) => v.VideoLayer.fromPartial(M))) || [], I;
    }
  };
  function X() {
    return {
      ingressId: "",
      name: "",
      streamKey: "",
      url: "",
      inputType: 0,
      audio: void 0,
      video: void 0,
      roomName: "",
      participantIdentity: "",
      participantName: "",
      reusable: !1,
      state: void 0
    };
  }
  a.IngressInfo = {
    encode(q, z = l.default.Writer.create()) {
      return q.ingressId !== void 0 && q.ingressId !== "" && z.uint32(10).string(q.ingressId), q.name !== void 0 && q.name !== "" && z.uint32(18).string(q.name), q.streamKey !== void 0 && q.streamKey !== "" && z.uint32(26).string(q.streamKey), q.url !== void 0 && q.url !== "" && z.uint32(34).string(q.url), q.inputType !== void 0 && q.inputType !== 0 && z.uint32(40).int32(q.inputType), q.audio !== void 0 && a.IngressAudioOptions.encode(q.audio, z.uint32(50).fork()).ldelim(), q.video !== void 0 && a.IngressVideoOptions.encode(q.video, z.uint32(58).fork()).ldelim(), q.roomName !== void 0 && q.roomName !== "" && z.uint32(66).string(q.roomName), q.participantIdentity !== void 0 && q.participantIdentity !== "" && z.uint32(74).string(q.participantIdentity), q.participantName !== void 0 && q.participantName !== "" && z.uint32(82).string(q.participantName), q.reusable === !0 && z.uint32(88).bool(q.reusable), q.state !== void 0 && a.IngressState.encode(q.state, z.uint32(98).fork()).ldelim(), z;
    },
    decode(q, z) {
      const P = q instanceof l.default.Reader ? q : new l.default.Reader(q);
      let S = z === void 0 ? P.len : P.pos + z;
      const E = X();
      for (; P.pos < S; ) {
        const I = P.uint32();
        switch (I >>> 3) {
          case 1:
            E.ingressId = P.string();
            break;
          case 2:
            E.name = P.string();
            break;
          case 3:
            E.streamKey = P.string();
            break;
          case 4:
            E.url = P.string();
            break;
          case 5:
            E.inputType = P.int32();
            break;
          case 6:
            E.audio = a.IngressAudioOptions.decode(P, P.uint32());
            break;
          case 7:
            E.video = a.IngressVideoOptions.decode(P, P.uint32());
            break;
          case 8:
            E.roomName = P.string();
            break;
          case 9:
            E.participantIdentity = P.string();
            break;
          case 10:
            E.participantName = P.string();
            break;
          case 11:
            E.reusable = P.bool();
            break;
          case 12:
            E.state = a.IngressState.decode(P, P.uint32());
            break;
          default:
            P.skipType(I & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(q) {
      return {
        ingressId: Te(q.ingressId) ? String(q.ingressId) : "",
        name: Te(q.name) ? String(q.name) : "",
        streamKey: Te(q.streamKey) ? String(q.streamKey) : "",
        url: Te(q.url) ? String(q.url) : "",
        inputType: Te(q.inputType) ? _(q.inputType) : 0,
        audio: Te(q.audio) ? a.IngressAudioOptions.fromJSON(q.audio) : void 0,
        video: Te(q.video) ? a.IngressVideoOptions.fromJSON(q.video) : void 0,
        roomName: Te(q.roomName) ? String(q.roomName) : "",
        participantIdentity: Te(q.participantIdentity) ? String(q.participantIdentity) : "",
        participantName: Te(q.participantName) ? String(q.participantName) : "",
        reusable: Te(q.reusable) ? !!q.reusable : !1,
        state: Te(q.state) ? a.IngressState.fromJSON(q.state) : void 0
      };
    },
    toJSON(q) {
      const z = {};
      return q.ingressId !== void 0 && (z.ingressId = q.ingressId), q.name !== void 0 && (z.name = q.name), q.streamKey !== void 0 && (z.streamKey = q.streamKey), q.url !== void 0 && (z.url = q.url), q.inputType !== void 0 && (z.inputType = k(q.inputType)), q.audio !== void 0 && (z.audio = q.audio ? a.IngressAudioOptions.toJSON(q.audio) : void 0), q.video !== void 0 && (z.video = q.video ? a.IngressVideoOptions.toJSON(q.video) : void 0), q.roomName !== void 0 && (z.roomName = q.roomName), q.participantIdentity !== void 0 && (z.participantIdentity = q.participantIdentity), q.participantName !== void 0 && (z.participantName = q.participantName), q.reusable !== void 0 && (z.reusable = q.reusable), q.state !== void 0 && (z.state = q.state ? a.IngressState.toJSON(q.state) : void 0), z;
    },
    fromPartial(q) {
      var z, P, S, E, I, M, $, U, Y;
      const B = X();
      return B.ingressId = (z = q.ingressId) !== null && z !== void 0 ? z : "", B.name = (P = q.name) !== null && P !== void 0 ? P : "", B.streamKey = (S = q.streamKey) !== null && S !== void 0 ? S : "", B.url = (E = q.url) !== null && E !== void 0 ? E : "", B.inputType = (I = q.inputType) !== null && I !== void 0 ? I : 0, B.audio = q.audio !== void 0 && q.audio !== null ? a.IngressAudioOptions.fromPartial(q.audio) : void 0, B.video = q.video !== void 0 && q.video !== null ? a.IngressVideoOptions.fromPartial(q.video) : void 0, B.roomName = (M = q.roomName) !== null && M !== void 0 ? M : "", B.participantIdentity = ($ = q.participantIdentity) !== null && $ !== void 0 ? $ : "", B.participantName = (U = q.participantName) !== null && U !== void 0 ? U : "", B.reusable = (Y = q.reusable) !== null && Y !== void 0 ? Y : !1, B.state = q.state !== void 0 && q.state !== null ? a.IngressState.fromPartial(q.state) : void 0, B;
    }
  };
  function ne() {
    return { status: 0, error: "", video: void 0, audio: void 0, roomId: "", startedAt: 0, tracks: [] };
  }
  a.IngressState = {
    encode(q, z = l.default.Writer.create()) {
      if (q.status !== void 0 && q.status !== 0 && z.uint32(8).int32(q.status), q.error !== void 0 && q.error !== "" && z.uint32(18).string(q.error), q.video !== void 0 && a.InputVideoState.encode(q.video, z.uint32(26).fork()).ldelim(), q.audio !== void 0 && a.InputAudioState.encode(q.audio, z.uint32(34).fork()).ldelim(), q.roomId !== void 0 && q.roomId !== "" && z.uint32(42).string(q.roomId), q.startedAt !== void 0 && q.startedAt !== 0 && z.uint32(56).int64(q.startedAt), q.tracks !== void 0 && q.tracks.length !== 0)
        for (const P of q.tracks)
          v.TrackInfo.encode(P, z.uint32(50).fork()).ldelim();
      return z;
    },
    decode(q, z) {
      const P = q instanceof l.default.Reader ? q : new l.default.Reader(q);
      let S = z === void 0 ? P.len : P.pos + z;
      const E = ne();
      for (; P.pos < S; ) {
        const I = P.uint32();
        switch (I >>> 3) {
          case 1:
            E.status = P.int32();
            break;
          case 2:
            E.error = P.string();
            break;
          case 3:
            E.video = a.InputVideoState.decode(P, P.uint32());
            break;
          case 4:
            E.audio = a.InputAudioState.decode(P, P.uint32());
            break;
          case 5:
            E.roomId = P.string();
            break;
          case 7:
            E.startedAt = ke(P.int64());
            break;
          case 6:
            E.tracks.push(v.TrackInfo.decode(P, P.uint32()));
            break;
          default:
            P.skipType(I & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(q) {
      return {
        status: Te(q.status) ? D(q.status) : 0,
        error: Te(q.error) ? String(q.error) : "",
        video: Te(q.video) ? a.InputVideoState.fromJSON(q.video) : void 0,
        audio: Te(q.audio) ? a.InputAudioState.fromJSON(q.audio) : void 0,
        roomId: Te(q.roomId) ? String(q.roomId) : "",
        startedAt: Te(q.startedAt) ? Number(q.startedAt) : 0,
        tracks: Array.isArray(q == null ? void 0 : q.tracks) ? q.tracks.map((z) => v.TrackInfo.fromJSON(z)) : []
      };
    },
    toJSON(q) {
      const z = {};
      return q.status !== void 0 && (z.status = F(q.status)), q.error !== void 0 && (z.error = q.error), q.video !== void 0 && (z.video = q.video ? a.InputVideoState.toJSON(q.video) : void 0), q.audio !== void 0 && (z.audio = q.audio ? a.InputAudioState.toJSON(q.audio) : void 0), q.roomId !== void 0 && (z.roomId = q.roomId), q.startedAt !== void 0 && (z.startedAt = Math.round(q.startedAt)), q.tracks ? z.tracks = q.tracks.map((P) => P ? v.TrackInfo.toJSON(P) : void 0) : z.tracks = [], z;
    },
    fromPartial(q) {
      var z, P, S, E, I;
      const M = ne();
      return M.status = (z = q.status) !== null && z !== void 0 ? z : 0, M.error = (P = q.error) !== null && P !== void 0 ? P : "", M.video = q.video !== void 0 && q.video !== null ? a.InputVideoState.fromPartial(q.video) : void 0, M.audio = q.audio !== void 0 && q.audio !== null ? a.InputAudioState.fromPartial(q.audio) : void 0, M.roomId = (S = q.roomId) !== null && S !== void 0 ? S : "", M.startedAt = (E = q.startedAt) !== null && E !== void 0 ? E : 0, M.tracks = ((I = q.tracks) === null || I === void 0 ? void 0 : I.map(($) => v.TrackInfo.fromPartial($))) || [], M;
    }
  };
  function Q() {
    return { mimeType: 0, width: 0, height: 0, framerate: 0 };
  }
  a.InputVideoState = {
    encode(q, z = l.default.Writer.create()) {
      return q.mimeType !== void 0 && q.mimeType !== 0 && z.uint32(8).uint32(q.mimeType), q.width !== void 0 && q.width !== 0 && z.uint32(24).uint32(q.width), q.height !== void 0 && q.height !== 0 && z.uint32(32).uint32(q.height), q.framerate !== void 0 && q.framerate !== 0 && z.uint32(40).uint32(q.framerate), z;
    },
    decode(q, z) {
      const P = q instanceof l.default.Reader ? q : new l.default.Reader(q);
      let S = z === void 0 ? P.len : P.pos + z;
      const E = Q();
      for (; P.pos < S; ) {
        const I = P.uint32();
        switch (I >>> 3) {
          case 1:
            E.mimeType = P.uint32();
            break;
          case 3:
            E.width = P.uint32();
            break;
          case 4:
            E.height = P.uint32();
            break;
          case 5:
            E.framerate = P.uint32();
            break;
          default:
            P.skipType(I & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(q) {
      return {
        mimeType: Te(q.mimeType) ? Number(q.mimeType) : 0,
        width: Te(q.width) ? Number(q.width) : 0,
        height: Te(q.height) ? Number(q.height) : 0,
        framerate: Te(q.framerate) ? Number(q.framerate) : 0
      };
    },
    toJSON(q) {
      const z = {};
      return q.mimeType !== void 0 && (z.mimeType = Math.round(q.mimeType)), q.width !== void 0 && (z.width = Math.round(q.width)), q.height !== void 0 && (z.height = Math.round(q.height)), q.framerate !== void 0 && (z.framerate = Math.round(q.framerate)), z;
    },
    fromPartial(q) {
      var z, P, S, E;
      const I = Q();
      return I.mimeType = (z = q.mimeType) !== null && z !== void 0 ? z : 0, I.width = (P = q.width) !== null && P !== void 0 ? P : 0, I.height = (S = q.height) !== null && S !== void 0 ? S : 0, I.framerate = (E = q.framerate) !== null && E !== void 0 ? E : 0, I;
    }
  };
  function ae() {
    return { mimeType: 0, channels: 0, sampleRate: 0 };
  }
  a.InputAudioState = {
    encode(q, z = l.default.Writer.create()) {
      return q.mimeType !== void 0 && q.mimeType !== 0 && z.uint32(8).uint32(q.mimeType), q.channels !== void 0 && q.channels !== 0 && z.uint32(24).uint32(q.channels), q.sampleRate !== void 0 && q.sampleRate !== 0 && z.uint32(32).uint32(q.sampleRate), z;
    },
    decode(q, z) {
      const P = q instanceof l.default.Reader ? q : new l.default.Reader(q);
      let S = z === void 0 ? P.len : P.pos + z;
      const E = ae();
      for (; P.pos < S; ) {
        const I = P.uint32();
        switch (I >>> 3) {
          case 1:
            E.mimeType = P.uint32();
            break;
          case 3:
            E.channels = P.uint32();
            break;
          case 4:
            E.sampleRate = P.uint32();
            break;
          default:
            P.skipType(I & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(q) {
      return {
        mimeType: Te(q.mimeType) ? Number(q.mimeType) : 0,
        channels: Te(q.channels) ? Number(q.channels) : 0,
        sampleRate: Te(q.sampleRate) ? Number(q.sampleRate) : 0
      };
    },
    toJSON(q) {
      const z = {};
      return q.mimeType !== void 0 && (z.mimeType = Math.round(q.mimeType)), q.channels !== void 0 && (z.channels = Math.round(q.channels)), q.sampleRate !== void 0 && (z.sampleRate = Math.round(q.sampleRate)), z;
    },
    fromPartial(q) {
      var z, P, S;
      const E = ae();
      return E.mimeType = (z = q.mimeType) !== null && z !== void 0 ? z : 0, E.channels = (P = q.channels) !== null && P !== void 0 ? P : 0, E.sampleRate = (S = q.sampleRate) !== null && S !== void 0 ? S : 0, E;
    }
  };
  function j() {
    return {
      ingressId: "",
      name: "",
      roomName: "",
      participantIdentity: "",
      participantName: "",
      audio: void 0,
      video: void 0
    };
  }
  a.UpdateIngressRequest = {
    encode(q, z = l.default.Writer.create()) {
      return q.ingressId !== void 0 && q.ingressId !== "" && z.uint32(10).string(q.ingressId), q.name !== void 0 && q.name !== "" && z.uint32(18).string(q.name), q.roomName !== void 0 && q.roomName !== "" && z.uint32(26).string(q.roomName), q.participantIdentity !== void 0 && q.participantIdentity !== "" && z.uint32(34).string(q.participantIdentity), q.participantName !== void 0 && q.participantName !== "" && z.uint32(42).string(q.participantName), q.audio !== void 0 && a.IngressAudioOptions.encode(q.audio, z.uint32(50).fork()).ldelim(), q.video !== void 0 && a.IngressVideoOptions.encode(q.video, z.uint32(58).fork()).ldelim(), z;
    },
    decode(q, z) {
      const P = q instanceof l.default.Reader ? q : new l.default.Reader(q);
      let S = z === void 0 ? P.len : P.pos + z;
      const E = j();
      for (; P.pos < S; ) {
        const I = P.uint32();
        switch (I >>> 3) {
          case 1:
            E.ingressId = P.string();
            break;
          case 2:
            E.name = P.string();
            break;
          case 3:
            E.roomName = P.string();
            break;
          case 4:
            E.participantIdentity = P.string();
            break;
          case 5:
            E.participantName = P.string();
            break;
          case 6:
            E.audio = a.IngressAudioOptions.decode(P, P.uint32());
            break;
          case 7:
            E.video = a.IngressVideoOptions.decode(P, P.uint32());
            break;
          default:
            P.skipType(I & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(q) {
      return {
        ingressId: Te(q.ingressId) ? String(q.ingressId) : "",
        name: Te(q.name) ? String(q.name) : "",
        roomName: Te(q.roomName) ? String(q.roomName) : "",
        participantIdentity: Te(q.participantIdentity) ? String(q.participantIdentity) : "",
        participantName: Te(q.participantName) ? String(q.participantName) : "",
        audio: Te(q.audio) ? a.IngressAudioOptions.fromJSON(q.audio) : void 0,
        video: Te(q.video) ? a.IngressVideoOptions.fromJSON(q.video) : void 0
      };
    },
    toJSON(q) {
      const z = {};
      return q.ingressId !== void 0 && (z.ingressId = q.ingressId), q.name !== void 0 && (z.name = q.name), q.roomName !== void 0 && (z.roomName = q.roomName), q.participantIdentity !== void 0 && (z.participantIdentity = q.participantIdentity), q.participantName !== void 0 && (z.participantName = q.participantName), q.audio !== void 0 && (z.audio = q.audio ? a.IngressAudioOptions.toJSON(q.audio) : void 0), q.video !== void 0 && (z.video = q.video ? a.IngressVideoOptions.toJSON(q.video) : void 0), z;
    },
    fromPartial(q) {
      var z, P, S, E, I;
      const M = j();
      return M.ingressId = (z = q.ingressId) !== null && z !== void 0 ? z : "", M.name = (P = q.name) !== null && P !== void 0 ? P : "", M.roomName = (S = q.roomName) !== null && S !== void 0 ? S : "", M.participantIdentity = (E = q.participantIdentity) !== null && E !== void 0 ? E : "", M.participantName = (I = q.participantName) !== null && I !== void 0 ? I : "", M.audio = q.audio !== void 0 && q.audio !== null ? a.IngressAudioOptions.fromPartial(q.audio) : void 0, M.video = q.video !== void 0 && q.video !== null ? a.IngressVideoOptions.fromPartial(q.video) : void 0, M;
    }
  };
  function ue() {
    return { roomName: "" };
  }
  a.ListIngressRequest = {
    encode(q, z = l.default.Writer.create()) {
      return q.roomName !== void 0 && q.roomName !== "" && z.uint32(10).string(q.roomName), z;
    },
    decode(q, z) {
      const P = q instanceof l.default.Reader ? q : new l.default.Reader(q);
      let S = z === void 0 ? P.len : P.pos + z;
      const E = ue();
      for (; P.pos < S; ) {
        const I = P.uint32();
        switch (I >>> 3) {
          case 1:
            E.roomName = P.string();
            break;
          default:
            P.skipType(I & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(q) {
      return { roomName: Te(q.roomName) ? String(q.roomName) : "" };
    },
    toJSON(q) {
      const z = {};
      return q.roomName !== void 0 && (z.roomName = q.roomName), z;
    },
    fromPartial(q) {
      var z;
      const P = ue();
      return P.roomName = (z = q.roomName) !== null && z !== void 0 ? z : "", P;
    }
  };
  function he() {
    return { items: [] };
  }
  a.ListIngressResponse = {
    encode(q, z = l.default.Writer.create()) {
      if (q.items !== void 0 && q.items.length !== 0)
        for (const P of q.items)
          a.IngressInfo.encode(P, z.uint32(10).fork()).ldelim();
      return z;
    },
    decode(q, z) {
      const P = q instanceof l.default.Reader ? q : new l.default.Reader(q);
      let S = z === void 0 ? P.len : P.pos + z;
      const E = he();
      for (; P.pos < S; ) {
        const I = P.uint32();
        switch (I >>> 3) {
          case 1:
            E.items.push(a.IngressInfo.decode(P, P.uint32()));
            break;
          default:
            P.skipType(I & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(q) {
      return { items: Array.isArray(q == null ? void 0 : q.items) ? q.items.map((z) => a.IngressInfo.fromJSON(z)) : [] };
    },
    toJSON(q) {
      const z = {};
      return q.items ? z.items = q.items.map((P) => P ? a.IngressInfo.toJSON(P) : void 0) : z.items = [], z;
    },
    fromPartial(q) {
      var z;
      const P = he();
      return P.items = ((z = q.items) === null || z === void 0 ? void 0 : z.map((S) => a.IngressInfo.fromPartial(S))) || [], P;
    }
  };
  function fe() {
    return { ingressId: "" };
  }
  a.DeleteIngressRequest = {
    encode(q, z = l.default.Writer.create()) {
      return q.ingressId !== void 0 && q.ingressId !== "" && z.uint32(10).string(q.ingressId), z;
    },
    decode(q, z) {
      const P = q instanceof l.default.Reader ? q : new l.default.Reader(q);
      let S = z === void 0 ? P.len : P.pos + z;
      const E = fe();
      for (; P.pos < S; ) {
        const I = P.uint32();
        switch (I >>> 3) {
          case 1:
            E.ingressId = P.string();
            break;
          default:
            P.skipType(I & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(q) {
      return { ingressId: Te(q.ingressId) ? String(q.ingressId) : "" };
    },
    toJSON(q) {
      const z = {};
      return q.ingressId !== void 0 && (z.ingressId = q.ingressId), z;
    },
    fromPartial(q) {
      var z;
      const P = fe();
      return P.ingressId = (z = q.ingressId) !== null && z !== void 0 ? z : "", P;
    }
  };
  var be = (() => {
    if (typeof be < "u")
      return be;
    if (typeof self < "u")
      return self;
    if (typeof window < "u")
      return window;
    if (typeof commonjsGlobal$1 < "u")
      return commonjsGlobal$1;
    throw "Unable to locate global object";
  })();
  function ke(q) {
    if (q.gt(Number.MAX_SAFE_INTEGER))
      throw new be.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    return q.toNumber();
  }
  l.default.util.Long !== c.default && (l.default.util.Long = c.default, l.default.configure());
  function Te(q) {
    return q != null;
  }
})(livekit_ingress);
var __awaiter$1 = commonjsGlobal$1 && commonjsGlobal$1.__awaiter || function(a, u, c, l) {
  function v(p) {
    return p instanceof c ? p : new c(function(_) {
      _(p);
    });
  }
  return new (c || (c = Promise))(function(p, _) {
    function k(F) {
      try {
        D(l.next(F));
      } catch (H) {
        _(H);
      }
    }
    function O(F) {
      try {
        D(l.throw(F));
      } catch (H) {
        _(H);
      }
    }
    function D(F) {
      F.done ? p(F.value) : v(F.value).then(k, O);
    }
    D((l = l.apply(a, u || [])).next());
  });
}, __importDefault$3 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(IngressClient$1, "__esModule", { value: !0 });
IngressClient$1.IngressClient = void 0;
const livekit_ingress_1$1 = livekit_ingress, ServiceBase_1$1 = __importDefault$3(ServiceBase$1), TwirpRPC_1$1 = TwirpRPC, svc$1 = "Ingress";
class IngressClient extends ServiceBase_1$1.default {
  /**
   * @param host hostname including protocol. i.e. 'https://cluster.livekit.io'
   * @param apiKey API Key, can be set in env var LIVEKIT_API_KEY
   * @param secret API Secret, can be set in env var LIVEKIT_API_SECRET
   */
  constructor(u, c, l) {
    super(c, l), this.rpc = new TwirpRPC_1$1.TwirpRpc(u, TwirpRPC_1$1.livekitPackage);
  }
  /**
   * @param inputType protocol for the ingress
   * @param opts CreateIngressOptions
   */
  createIngress(u, c) {
    return __awaiter$1(this, void 0, void 0, function* () {
      let l = "", v = "", p = "", _ = "", k, O;
      c !== void 0 && (l = c.name || "", v = c.roomName || "", p = c.participantName || "", _ = c.participantIdentity || "", k = c.audioParams, O = c.videoParams);
      const D = livekit_ingress_1$1.CreateIngressRequest.toJSON({
        inputType: u,
        name: l,
        roomName: v,
        participantIdentity: _,
        participantName: p,
        audio: k,
        video: O
      }), F = yield this.rpc.request(svc$1, "CreateIngress", D, this.authHeader({ ingressAdmin: !0 }));
      return livekit_ingress_1$1.IngressInfo.fromJSON(F);
    });
  }
  /**
   * @param ingressId ID of the ingress to update
   * @param opts UpdateIngressOptions
   */
  updateIngress(u, c) {
    return __awaiter$1(this, void 0, void 0, function* () {
      const l = c.name || "", v = c.roomName || "", p = c.participantName || "", _ = c.participantIdentity || "", k = c.audioParams, O = c.videoParams, D = livekit_ingress_1$1.UpdateIngressRequest.toJSON({
        ingressId: u,
        name: l,
        roomName: v,
        participantIdentity: _,
        participantName: p,
        audio: k,
        video: O
      }), F = yield this.rpc.request(svc$1, "UpdateIngress", D, this.authHeader({ ingressAdmin: !0 }));
      return livekit_ingress_1$1.IngressInfo.fromJSON(F);
    });
  }
  /**
   * @param roomName list ingress for one room only
   */
  listIngress(u) {
    var c;
    return __awaiter$1(this, void 0, void 0, function* () {
      u ?? (u = "");
      const l = yield this.rpc.request(svc$1, "ListIngress", livekit_ingress_1$1.ListIngressRequest.toJSON({ roomName: u }), this.authHeader({ ingressAdmin: !0 }));
      return (c = livekit_ingress_1$1.ListIngressResponse.fromJSON(l).items) !== null && c !== void 0 ? c : [];
    });
  }
  /**
   * @param ingressId ingress to delete
   */
  deleteIngress(u) {
    return __awaiter$1(this, void 0, void 0, function* () {
      const c = yield this.rpc.request(svc$1, "DeleteIngress", livekit_ingress_1$1.DeleteIngressRequest.toJSON({ ingressId: u }), this.authHeader({ ingressAdmin: !0 }));
      return livekit_ingress_1$1.IngressInfo.fromJSON(c);
    });
  }
}
IngressClient$1.IngressClient = IngressClient;
var RoomServiceClient$1 = {}, livekit_room = {};
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(P) {
    return P && P.__esModule ? P : { default: P };
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.UpdateRoomMetadataRequest = a.SendDataResponse = a.SendDataRequest = a.UpdateSubscriptionsResponse = a.UpdateSubscriptionsRequest = a.UpdateParticipantRequest = a.MuteRoomTrackResponse = a.MuteRoomTrackRequest = a.RemoveParticipantResponse = a.RoomParticipantIdentity = a.ListParticipantsResponse = a.ListParticipantsRequest = a.DeleteRoomResponse = a.DeleteRoomRequest = a.ListRoomsResponse = a.ListRoomsRequest = a.RoomEgress = a.CreateRoomRequest = a.protobufPackage = void 0;
  const c = u(minimal), l = livekit_egress, v = livekit_models;
  a.protobufPackage = "livekit";
  function p() {
    return { name: "", emptyTimeout: 0, maxParticipants: 0, nodeId: "", metadata: "", egress: void 0 };
  }
  a.CreateRoomRequest = {
    encode(P, S = c.default.Writer.create()) {
      return P.name !== void 0 && P.name !== "" && S.uint32(10).string(P.name), P.emptyTimeout !== void 0 && P.emptyTimeout !== 0 && S.uint32(16).uint32(P.emptyTimeout), P.maxParticipants !== void 0 && P.maxParticipants !== 0 && S.uint32(24).uint32(P.maxParticipants), P.nodeId !== void 0 && P.nodeId !== "" && S.uint32(34).string(P.nodeId), P.metadata !== void 0 && P.metadata !== "" && S.uint32(42).string(P.metadata), P.egress !== void 0 && a.RoomEgress.encode(P.egress, S.uint32(50).fork()).ldelim(), S;
    },
    decode(P, S) {
      const E = P instanceof c.default.Reader ? P : new c.default.Reader(P);
      let I = S === void 0 ? E.len : E.pos + S;
      const M = p();
      for (; E.pos < I; ) {
        const $ = E.uint32();
        switch ($ >>> 3) {
          case 1:
            M.name = E.string();
            break;
          case 2:
            M.emptyTimeout = E.uint32();
            break;
          case 3:
            M.maxParticipants = E.uint32();
            break;
          case 4:
            M.nodeId = E.string();
            break;
          case 5:
            M.metadata = E.string();
            break;
          case 6:
            M.egress = a.RoomEgress.decode(E, E.uint32());
            break;
          default:
            E.skipType($ & 7);
            break;
        }
      }
      return M;
    },
    fromJSON(P) {
      return {
        name: z(P.name) ? String(P.name) : "",
        emptyTimeout: z(P.emptyTimeout) ? Number(P.emptyTimeout) : 0,
        maxParticipants: z(P.maxParticipants) ? Number(P.maxParticipants) : 0,
        nodeId: z(P.nodeId) ? String(P.nodeId) : "",
        metadata: z(P.metadata) ? String(P.metadata) : "",
        egress: z(P.egress) ? a.RoomEgress.fromJSON(P.egress) : void 0
      };
    },
    toJSON(P) {
      const S = {};
      return P.name !== void 0 && (S.name = P.name), P.emptyTimeout !== void 0 && (S.emptyTimeout = Math.round(P.emptyTimeout)), P.maxParticipants !== void 0 && (S.maxParticipants = Math.round(P.maxParticipants)), P.nodeId !== void 0 && (S.nodeId = P.nodeId), P.metadata !== void 0 && (S.metadata = P.metadata), P.egress !== void 0 && (S.egress = P.egress ? a.RoomEgress.toJSON(P.egress) : void 0), S;
    },
    fromPartial(P) {
      var S, E, I, M, $;
      const U = p();
      return U.name = (S = P.name) !== null && S !== void 0 ? S : "", U.emptyTimeout = (E = P.emptyTimeout) !== null && E !== void 0 ? E : 0, U.maxParticipants = (I = P.maxParticipants) !== null && I !== void 0 ? I : 0, U.nodeId = (M = P.nodeId) !== null && M !== void 0 ? M : "", U.metadata = ($ = P.metadata) !== null && $ !== void 0 ? $ : "", U.egress = P.egress !== void 0 && P.egress !== null ? a.RoomEgress.fromPartial(P.egress) : void 0, U;
    }
  };
  function _() {
    return { room: void 0, tracks: void 0 };
  }
  a.RoomEgress = {
    encode(P, S = c.default.Writer.create()) {
      return P.room !== void 0 && l.RoomCompositeEgressRequest.encode(P.room, S.uint32(10).fork()).ldelim(), P.tracks !== void 0 && l.AutoTrackEgress.encode(P.tracks, S.uint32(18).fork()).ldelim(), S;
    },
    decode(P, S) {
      const E = P instanceof c.default.Reader ? P : new c.default.Reader(P);
      let I = S === void 0 ? E.len : E.pos + S;
      const M = _();
      for (; E.pos < I; ) {
        const $ = E.uint32();
        switch ($ >>> 3) {
          case 1:
            M.room = l.RoomCompositeEgressRequest.decode(E, E.uint32());
            break;
          case 2:
            M.tracks = l.AutoTrackEgress.decode(E, E.uint32());
            break;
          default:
            E.skipType($ & 7);
            break;
        }
      }
      return M;
    },
    fromJSON(P) {
      return {
        room: z(P.room) ? l.RoomCompositeEgressRequest.fromJSON(P.room) : void 0,
        tracks: z(P.tracks) ? l.AutoTrackEgress.fromJSON(P.tracks) : void 0
      };
    },
    toJSON(P) {
      const S = {};
      return P.room !== void 0 && (S.room = P.room ? l.RoomCompositeEgressRequest.toJSON(P.room) : void 0), P.tracks !== void 0 && (S.tracks = P.tracks ? l.AutoTrackEgress.toJSON(P.tracks) : void 0), S;
    },
    fromPartial(P) {
      const S = _();
      return S.room = P.room !== void 0 && P.room !== null ? l.RoomCompositeEgressRequest.fromPartial(P.room) : void 0, S.tracks = P.tracks !== void 0 && P.tracks !== null ? l.AutoTrackEgress.fromPartial(P.tracks) : void 0, S;
    }
  };
  function k() {
    return { names: [] };
  }
  a.ListRoomsRequest = {
    encode(P, S = c.default.Writer.create()) {
      if (P.names !== void 0 && P.names.length !== 0)
        for (const E of P.names)
          S.uint32(10).string(E);
      return S;
    },
    decode(P, S) {
      const E = P instanceof c.default.Reader ? P : new c.default.Reader(P);
      let I = S === void 0 ? E.len : E.pos + S;
      const M = k();
      for (; E.pos < I; ) {
        const $ = E.uint32();
        switch ($ >>> 3) {
          case 1:
            M.names.push(E.string());
            break;
          default:
            E.skipType($ & 7);
            break;
        }
      }
      return M;
    },
    fromJSON(P) {
      return { names: Array.isArray(P == null ? void 0 : P.names) ? P.names.map((S) => String(S)) : [] };
    },
    toJSON(P) {
      const S = {};
      return P.names ? S.names = P.names.map((E) => E) : S.names = [], S;
    },
    fromPartial(P) {
      var S;
      const E = k();
      return E.names = ((S = P.names) === null || S === void 0 ? void 0 : S.map((I) => I)) || [], E;
    }
  };
  function O() {
    return { rooms: [] };
  }
  a.ListRoomsResponse = {
    encode(P, S = c.default.Writer.create()) {
      if (P.rooms !== void 0 && P.rooms.length !== 0)
        for (const E of P.rooms)
          v.Room.encode(E, S.uint32(10).fork()).ldelim();
      return S;
    },
    decode(P, S) {
      const E = P instanceof c.default.Reader ? P : new c.default.Reader(P);
      let I = S === void 0 ? E.len : E.pos + S;
      const M = O();
      for (; E.pos < I; ) {
        const $ = E.uint32();
        switch ($ >>> 3) {
          case 1:
            M.rooms.push(v.Room.decode(E, E.uint32()));
            break;
          default:
            E.skipType($ & 7);
            break;
        }
      }
      return M;
    },
    fromJSON(P) {
      return { rooms: Array.isArray(P == null ? void 0 : P.rooms) ? P.rooms.map((S) => v.Room.fromJSON(S)) : [] };
    },
    toJSON(P) {
      const S = {};
      return P.rooms ? S.rooms = P.rooms.map((E) => E ? v.Room.toJSON(E) : void 0) : S.rooms = [], S;
    },
    fromPartial(P) {
      var S;
      const E = O();
      return E.rooms = ((S = P.rooms) === null || S === void 0 ? void 0 : S.map((I) => v.Room.fromPartial(I))) || [], E;
    }
  };
  function D() {
    return { room: "" };
  }
  a.DeleteRoomRequest = {
    encode(P, S = c.default.Writer.create()) {
      return P.room !== void 0 && P.room !== "" && S.uint32(10).string(P.room), S;
    },
    decode(P, S) {
      const E = P instanceof c.default.Reader ? P : new c.default.Reader(P);
      let I = S === void 0 ? E.len : E.pos + S;
      const M = D();
      for (; E.pos < I; ) {
        const $ = E.uint32();
        switch ($ >>> 3) {
          case 1:
            M.room = E.string();
            break;
          default:
            E.skipType($ & 7);
            break;
        }
      }
      return M;
    },
    fromJSON(P) {
      return { room: z(P.room) ? String(P.room) : "" };
    },
    toJSON(P) {
      const S = {};
      return P.room !== void 0 && (S.room = P.room), S;
    },
    fromPartial(P) {
      var S;
      const E = D();
      return E.room = (S = P.room) !== null && S !== void 0 ? S : "", E;
    }
  };
  function F() {
    return {};
  }
  a.DeleteRoomResponse = {
    encode(P, S = c.default.Writer.create()) {
      return S;
    },
    decode(P, S) {
      const E = P instanceof c.default.Reader ? P : new c.default.Reader(P);
      let I = S === void 0 ? E.len : E.pos + S;
      const M = F();
      for (; E.pos < I; ) {
        const $ = E.uint32();
        switch ($ >>> 3) {
          default:
            E.skipType($ & 7);
            break;
        }
      }
      return M;
    },
    fromJSON(P) {
      return {};
    },
    toJSON(P) {
      return {};
    },
    fromPartial(P) {
      return F();
    }
  };
  function H() {
    return { room: "" };
  }
  a.ListParticipantsRequest = {
    encode(P, S = c.default.Writer.create()) {
      return P.room !== void 0 && P.room !== "" && S.uint32(10).string(P.room), S;
    },
    decode(P, S) {
      const E = P instanceof c.default.Reader ? P : new c.default.Reader(P);
      let I = S === void 0 ? E.len : E.pos + S;
      const M = H();
      for (; E.pos < I; ) {
        const $ = E.uint32();
        switch ($ >>> 3) {
          case 1:
            M.room = E.string();
            break;
          default:
            E.skipType($ & 7);
            break;
        }
      }
      return M;
    },
    fromJSON(P) {
      return { room: z(P.room) ? String(P.room) : "" };
    },
    toJSON(P) {
      const S = {};
      return P.room !== void 0 && (S.room = P.room), S;
    },
    fromPartial(P) {
      var S;
      const E = H();
      return E.room = (S = P.room) !== null && S !== void 0 ? S : "", E;
    }
  };
  function Z() {
    return { participants: [] };
  }
  a.ListParticipantsResponse = {
    encode(P, S = c.default.Writer.create()) {
      if (P.participants !== void 0 && P.participants.length !== 0)
        for (const E of P.participants)
          v.ParticipantInfo.encode(E, S.uint32(10).fork()).ldelim();
      return S;
    },
    decode(P, S) {
      const E = P instanceof c.default.Reader ? P : new c.default.Reader(P);
      let I = S === void 0 ? E.len : E.pos + S;
      const M = Z();
      for (; E.pos < I; ) {
        const $ = E.uint32();
        switch ($ >>> 3) {
          case 1:
            M.participants.push(v.ParticipantInfo.decode(E, E.uint32()));
            break;
          default:
            E.skipType($ & 7);
            break;
        }
      }
      return M;
    },
    fromJSON(P) {
      return {
        participants: Array.isArray(P == null ? void 0 : P.participants) ? P.participants.map((S) => v.ParticipantInfo.fromJSON(S)) : []
      };
    },
    toJSON(P) {
      const S = {};
      return P.participants ? S.participants = P.participants.map((E) => E ? v.ParticipantInfo.toJSON(E) : void 0) : S.participants = [], S;
    },
    fromPartial(P) {
      var S;
      const E = Z();
      return E.participants = ((S = P.participants) === null || S === void 0 ? void 0 : S.map((I) => v.ParticipantInfo.fromPartial(I))) || [], E;
    }
  };
  function ee() {
    return { room: "", identity: "" };
  }
  a.RoomParticipantIdentity = {
    encode(P, S = c.default.Writer.create()) {
      return P.room !== void 0 && P.room !== "" && S.uint32(10).string(P.room), P.identity !== void 0 && P.identity !== "" && S.uint32(18).string(P.identity), S;
    },
    decode(P, S) {
      const E = P instanceof c.default.Reader ? P : new c.default.Reader(P);
      let I = S === void 0 ? E.len : E.pos + S;
      const M = ee();
      for (; E.pos < I; ) {
        const $ = E.uint32();
        switch ($ >>> 3) {
          case 1:
            M.room = E.string();
            break;
          case 2:
            M.identity = E.string();
            break;
          default:
            E.skipType($ & 7);
            break;
        }
      }
      return M;
    },
    fromJSON(P) {
      return {
        room: z(P.room) ? String(P.room) : "",
        identity: z(P.identity) ? String(P.identity) : ""
      };
    },
    toJSON(P) {
      const S = {};
      return P.room !== void 0 && (S.room = P.room), P.identity !== void 0 && (S.identity = P.identity), S;
    },
    fromPartial(P) {
      var S, E;
      const I = ee();
      return I.room = (S = P.room) !== null && S !== void 0 ? S : "", I.identity = (E = P.identity) !== null && E !== void 0 ? E : "", I;
    }
  };
  function X() {
    return {};
  }
  a.RemoveParticipantResponse = {
    encode(P, S = c.default.Writer.create()) {
      return S;
    },
    decode(P, S) {
      const E = P instanceof c.default.Reader ? P : new c.default.Reader(P);
      let I = S === void 0 ? E.len : E.pos + S;
      const M = X();
      for (; E.pos < I; ) {
        const $ = E.uint32();
        switch ($ >>> 3) {
          default:
            E.skipType($ & 7);
            break;
        }
      }
      return M;
    },
    fromJSON(P) {
      return {};
    },
    toJSON(P) {
      return {};
    },
    fromPartial(P) {
      return X();
    }
  };
  function ne() {
    return { room: "", identity: "", trackSid: "", muted: !1 };
  }
  a.MuteRoomTrackRequest = {
    encode(P, S = c.default.Writer.create()) {
      return P.room !== void 0 && P.room !== "" && S.uint32(10).string(P.room), P.identity !== void 0 && P.identity !== "" && S.uint32(18).string(P.identity), P.trackSid !== void 0 && P.trackSid !== "" && S.uint32(26).string(P.trackSid), P.muted === !0 && S.uint32(32).bool(P.muted), S;
    },
    decode(P, S) {
      const E = P instanceof c.default.Reader ? P : new c.default.Reader(P);
      let I = S === void 0 ? E.len : E.pos + S;
      const M = ne();
      for (; E.pos < I; ) {
        const $ = E.uint32();
        switch ($ >>> 3) {
          case 1:
            M.room = E.string();
            break;
          case 2:
            M.identity = E.string();
            break;
          case 3:
            M.trackSid = E.string();
            break;
          case 4:
            M.muted = E.bool();
            break;
          default:
            E.skipType($ & 7);
            break;
        }
      }
      return M;
    },
    fromJSON(P) {
      return {
        room: z(P.room) ? String(P.room) : "",
        identity: z(P.identity) ? String(P.identity) : "",
        trackSid: z(P.trackSid) ? String(P.trackSid) : "",
        muted: z(P.muted) ? !!P.muted : !1
      };
    },
    toJSON(P) {
      const S = {};
      return P.room !== void 0 && (S.room = P.room), P.identity !== void 0 && (S.identity = P.identity), P.trackSid !== void 0 && (S.trackSid = P.trackSid), P.muted !== void 0 && (S.muted = P.muted), S;
    },
    fromPartial(P) {
      var S, E, I, M;
      const $ = ne();
      return $.room = (S = P.room) !== null && S !== void 0 ? S : "", $.identity = (E = P.identity) !== null && E !== void 0 ? E : "", $.trackSid = (I = P.trackSid) !== null && I !== void 0 ? I : "", $.muted = (M = P.muted) !== null && M !== void 0 ? M : !1, $;
    }
  };
  function Q() {
    return { track: void 0 };
  }
  a.MuteRoomTrackResponse = {
    encode(P, S = c.default.Writer.create()) {
      return P.track !== void 0 && v.TrackInfo.encode(P.track, S.uint32(10).fork()).ldelim(), S;
    },
    decode(P, S) {
      const E = P instanceof c.default.Reader ? P : new c.default.Reader(P);
      let I = S === void 0 ? E.len : E.pos + S;
      const M = Q();
      for (; E.pos < I; ) {
        const $ = E.uint32();
        switch ($ >>> 3) {
          case 1:
            M.track = v.TrackInfo.decode(E, E.uint32());
            break;
          default:
            E.skipType($ & 7);
            break;
        }
      }
      return M;
    },
    fromJSON(P) {
      return { track: z(P.track) ? v.TrackInfo.fromJSON(P.track) : void 0 };
    },
    toJSON(P) {
      const S = {};
      return P.track !== void 0 && (S.track = P.track ? v.TrackInfo.toJSON(P.track) : void 0), S;
    },
    fromPartial(P) {
      const S = Q();
      return S.track = P.track !== void 0 && P.track !== null ? v.TrackInfo.fromPartial(P.track) : void 0, S;
    }
  };
  function ae() {
    return { room: "", identity: "", metadata: "", permission: void 0, name: "" };
  }
  a.UpdateParticipantRequest = {
    encode(P, S = c.default.Writer.create()) {
      return P.room !== void 0 && P.room !== "" && S.uint32(10).string(P.room), P.identity !== void 0 && P.identity !== "" && S.uint32(18).string(P.identity), P.metadata !== void 0 && P.metadata !== "" && S.uint32(26).string(P.metadata), P.permission !== void 0 && v.ParticipantPermission.encode(P.permission, S.uint32(34).fork()).ldelim(), P.name !== void 0 && P.name !== "" && S.uint32(42).string(P.name), S;
    },
    decode(P, S) {
      const E = P instanceof c.default.Reader ? P : new c.default.Reader(P);
      let I = S === void 0 ? E.len : E.pos + S;
      const M = ae();
      for (; E.pos < I; ) {
        const $ = E.uint32();
        switch ($ >>> 3) {
          case 1:
            M.room = E.string();
            break;
          case 2:
            M.identity = E.string();
            break;
          case 3:
            M.metadata = E.string();
            break;
          case 4:
            M.permission = v.ParticipantPermission.decode(E, E.uint32());
            break;
          case 5:
            M.name = E.string();
            break;
          default:
            E.skipType($ & 7);
            break;
        }
      }
      return M;
    },
    fromJSON(P) {
      return {
        room: z(P.room) ? String(P.room) : "",
        identity: z(P.identity) ? String(P.identity) : "",
        metadata: z(P.metadata) ? String(P.metadata) : "",
        permission: z(P.permission) ? v.ParticipantPermission.fromJSON(P.permission) : void 0,
        name: z(P.name) ? String(P.name) : ""
      };
    },
    toJSON(P) {
      const S = {};
      return P.room !== void 0 && (S.room = P.room), P.identity !== void 0 && (S.identity = P.identity), P.metadata !== void 0 && (S.metadata = P.metadata), P.permission !== void 0 && (S.permission = P.permission ? v.ParticipantPermission.toJSON(P.permission) : void 0), P.name !== void 0 && (S.name = P.name), S;
    },
    fromPartial(P) {
      var S, E, I, M;
      const $ = ae();
      return $.room = (S = P.room) !== null && S !== void 0 ? S : "", $.identity = (E = P.identity) !== null && E !== void 0 ? E : "", $.metadata = (I = P.metadata) !== null && I !== void 0 ? I : "", $.permission = P.permission !== void 0 && P.permission !== null ? v.ParticipantPermission.fromPartial(P.permission) : void 0, $.name = (M = P.name) !== null && M !== void 0 ? M : "", $;
    }
  };
  function j() {
    return { room: "", identity: "", trackSids: [], subscribe: !1, participantTracks: [] };
  }
  a.UpdateSubscriptionsRequest = {
    encode(P, S = c.default.Writer.create()) {
      if (P.room !== void 0 && P.room !== "" && S.uint32(10).string(P.room), P.identity !== void 0 && P.identity !== "" && S.uint32(18).string(P.identity), P.trackSids !== void 0 && P.trackSids.length !== 0)
        for (const E of P.trackSids)
          S.uint32(26).string(E);
      if (P.subscribe === !0 && S.uint32(32).bool(P.subscribe), P.participantTracks !== void 0 && P.participantTracks.length !== 0)
        for (const E of P.participantTracks)
          v.ParticipantTracks.encode(E, S.uint32(42).fork()).ldelim();
      return S;
    },
    decode(P, S) {
      const E = P instanceof c.default.Reader ? P : new c.default.Reader(P);
      let I = S === void 0 ? E.len : E.pos + S;
      const M = j();
      for (; E.pos < I; ) {
        const $ = E.uint32();
        switch ($ >>> 3) {
          case 1:
            M.room = E.string();
            break;
          case 2:
            M.identity = E.string();
            break;
          case 3:
            M.trackSids.push(E.string());
            break;
          case 4:
            M.subscribe = E.bool();
            break;
          case 5:
            M.participantTracks.push(v.ParticipantTracks.decode(E, E.uint32()));
            break;
          default:
            E.skipType($ & 7);
            break;
        }
      }
      return M;
    },
    fromJSON(P) {
      return {
        room: z(P.room) ? String(P.room) : "",
        identity: z(P.identity) ? String(P.identity) : "",
        trackSids: Array.isArray(P == null ? void 0 : P.trackSids) ? P.trackSids.map((S) => String(S)) : [],
        subscribe: z(P.subscribe) ? !!P.subscribe : !1,
        participantTracks: Array.isArray(P == null ? void 0 : P.participantTracks) ? P.participantTracks.map((S) => v.ParticipantTracks.fromJSON(S)) : []
      };
    },
    toJSON(P) {
      const S = {};
      return P.room !== void 0 && (S.room = P.room), P.identity !== void 0 && (S.identity = P.identity), P.trackSids ? S.trackSids = P.trackSids.map((E) => E) : S.trackSids = [], P.subscribe !== void 0 && (S.subscribe = P.subscribe), P.participantTracks ? S.participantTracks = P.participantTracks.map((E) => E ? v.ParticipantTracks.toJSON(E) : void 0) : S.participantTracks = [], S;
    },
    fromPartial(P) {
      var S, E, I, M, $;
      const U = j();
      return U.room = (S = P.room) !== null && S !== void 0 ? S : "", U.identity = (E = P.identity) !== null && E !== void 0 ? E : "", U.trackSids = ((I = P.trackSids) === null || I === void 0 ? void 0 : I.map((Y) => Y)) || [], U.subscribe = (M = P.subscribe) !== null && M !== void 0 ? M : !1, U.participantTracks = (($ = P.participantTracks) === null || $ === void 0 ? void 0 : $.map((Y) => v.ParticipantTracks.fromPartial(Y))) || [], U;
    }
  };
  function ue() {
    return {};
  }
  a.UpdateSubscriptionsResponse = {
    encode(P, S = c.default.Writer.create()) {
      return S;
    },
    decode(P, S) {
      const E = P instanceof c.default.Reader ? P : new c.default.Reader(P);
      let I = S === void 0 ? E.len : E.pos + S;
      const M = ue();
      for (; E.pos < I; ) {
        const $ = E.uint32();
        switch ($ >>> 3) {
          default:
            E.skipType($ & 7);
            break;
        }
      }
      return M;
    },
    fromJSON(P) {
      return {};
    },
    toJSON(P) {
      return {};
    },
    fromPartial(P) {
      return ue();
    }
  };
  function he() {
    return { room: "", data: new Uint8Array(), kind: 0, destinationSids: [] };
  }
  a.SendDataRequest = {
    encode(P, S = c.default.Writer.create()) {
      if (P.room !== void 0 && P.room !== "" && S.uint32(10).string(P.room), P.data !== void 0 && P.data.length !== 0 && S.uint32(18).bytes(P.data), P.kind !== void 0 && P.kind !== 0 && S.uint32(24).int32(P.kind), P.destinationSids !== void 0 && P.destinationSids.length !== 0)
        for (const E of P.destinationSids)
          S.uint32(34).string(E);
      return S;
    },
    decode(P, S) {
      const E = P instanceof c.default.Reader ? P : new c.default.Reader(P);
      let I = S === void 0 ? E.len : E.pos + S;
      const M = he();
      for (; E.pos < I; ) {
        const $ = E.uint32();
        switch ($ >>> 3) {
          case 1:
            M.room = E.string();
            break;
          case 2:
            M.data = E.bytes();
            break;
          case 3:
            M.kind = E.int32();
            break;
          case 4:
            M.destinationSids.push(E.string());
            break;
          default:
            E.skipType($ & 7);
            break;
        }
      }
      return M;
    },
    fromJSON(P) {
      return {
        room: z(P.room) ? String(P.room) : "",
        data: z(P.data) ? Te(P.data) : new Uint8Array(),
        kind: z(P.kind) ? v.dataPacket_KindFromJSON(P.kind) : 0,
        destinationSids: Array.isArray(P == null ? void 0 : P.destinationSids) ? P.destinationSids.map((S) => String(S)) : []
      };
    },
    toJSON(P) {
      const S = {};
      return P.room !== void 0 && (S.room = P.room), P.data !== void 0 && (S.data = q(P.data !== void 0 ? P.data : new Uint8Array())), P.kind !== void 0 && (S.kind = v.dataPacket_KindToJSON(P.kind)), P.destinationSids ? S.destinationSids = P.destinationSids.map((E) => E) : S.destinationSids = [], S;
    },
    fromPartial(P) {
      var S, E, I, M;
      const $ = he();
      return $.room = (S = P.room) !== null && S !== void 0 ? S : "", $.data = (E = P.data) !== null && E !== void 0 ? E : new Uint8Array(), $.kind = (I = P.kind) !== null && I !== void 0 ? I : 0, $.destinationSids = ((M = P.destinationSids) === null || M === void 0 ? void 0 : M.map((U) => U)) || [], $;
    }
  };
  function fe() {
    return {};
  }
  a.SendDataResponse = {
    encode(P, S = c.default.Writer.create()) {
      return S;
    },
    decode(P, S) {
      const E = P instanceof c.default.Reader ? P : new c.default.Reader(P);
      let I = S === void 0 ? E.len : E.pos + S;
      const M = fe();
      for (; E.pos < I; ) {
        const $ = E.uint32();
        switch ($ >>> 3) {
          default:
            E.skipType($ & 7);
            break;
        }
      }
      return M;
    },
    fromJSON(P) {
      return {};
    },
    toJSON(P) {
      return {};
    },
    fromPartial(P) {
      return fe();
    }
  };
  function be() {
    return { room: "", metadata: "" };
  }
  a.UpdateRoomMetadataRequest = {
    encode(P, S = c.default.Writer.create()) {
      return P.room !== void 0 && P.room !== "" && S.uint32(10).string(P.room), P.metadata !== void 0 && P.metadata !== "" && S.uint32(18).string(P.metadata), S;
    },
    decode(P, S) {
      const E = P instanceof c.default.Reader ? P : new c.default.Reader(P);
      let I = S === void 0 ? E.len : E.pos + S;
      const M = be();
      for (; E.pos < I; ) {
        const $ = E.uint32();
        switch ($ >>> 3) {
          case 1:
            M.room = E.string();
            break;
          case 2:
            M.metadata = E.string();
            break;
          default:
            E.skipType($ & 7);
            break;
        }
      }
      return M;
    },
    fromJSON(P) {
      return {
        room: z(P.room) ? String(P.room) : "",
        metadata: z(P.metadata) ? String(P.metadata) : ""
      };
    },
    toJSON(P) {
      const S = {};
      return P.room !== void 0 && (S.room = P.room), P.metadata !== void 0 && (S.metadata = P.metadata), S;
    },
    fromPartial(P) {
      var S, E;
      const I = be();
      return I.room = (S = P.room) !== null && S !== void 0 ? S : "", I.metadata = (E = P.metadata) !== null && E !== void 0 ? E : "", I;
    }
  };
  var ke = (() => {
    if (typeof ke < "u")
      return ke;
    if (typeof self < "u")
      return self;
    if (typeof window < "u")
      return window;
    if (typeof commonjsGlobal$1 < "u")
      return commonjsGlobal$1;
    throw "Unable to locate global object";
  })();
  function Te(P) {
    if (ke.Buffer)
      return Uint8Array.from(ke.Buffer.from(P, "base64"));
    {
      const S = ke.atob(P), E = new Uint8Array(S.length);
      for (let I = 0; I < S.length; ++I)
        E[I] = S.charCodeAt(I);
      return E;
    }
  }
  function q(P) {
    if (ke.Buffer)
      return ke.Buffer.from(P).toString("base64");
    {
      const S = [];
      return P.forEach((E) => {
        S.push(String.fromCharCode(E));
      }), ke.btoa(S.join(""));
    }
  }
  function z(P) {
    return P != null;
  }
})(livekit_room);
var __awaiter = commonjsGlobal$1 && commonjsGlobal$1.__awaiter || function(a, u, c, l) {
  function v(p) {
    return p instanceof c ? p : new c(function(_) {
      _(p);
    });
  }
  return new (c || (c = Promise))(function(p, _) {
    function k(F) {
      try {
        D(l.next(F));
      } catch (H) {
        _(H);
      }
    }
    function O(F) {
      try {
        D(l.throw(F));
      } catch (H) {
        _(H);
      }
    }
    function D(F) {
      F.done ? p(F.value) : v(F.value).then(k, O);
    }
    D((l = l.apply(a, u || [])).next());
  });
}, __importDefault$2 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(RoomServiceClient$1, "__esModule", { value: !0 });
RoomServiceClient$1.RoomServiceClient = void 0;
const livekit_models_1$1 = livekit_models, livekit_room_1 = livekit_room, ServiceBase_1 = __importDefault$2(ServiceBase$1), TwirpRPC_1 = TwirpRPC, svc = "RoomService";
class RoomServiceClient extends ServiceBase_1.default {
  /**
   *
   * @param host hostname including protocol. i.e. 'https://cluster.livekit.io'
   * @param apiKey API Key, can be set in env var LIVEKIT_API_KEY
   * @param secret API Secret, can be set in env var LIVEKIT_API_SECRET
   * @param jwt JWT Token, a pregenerated JWT token for authentication.
   * @param hostHeader A host header to send with the request.
   *
   */
  constructor(u, c, l, v, p) {
    super(c, l), this.jwt = v, this.rpc = new TwirpRPC_1.TwirpRpc(u, TwirpRPC_1.livekitPackage, void 0, p);
  }
  /**
   * Creates a new room. Explicit room creation is not required, since rooms will
   * be automatically created when the first participant joins. This method can be
   * used to customize room settings.
   * @param options
   */
  createRoom(u) {
    return __awaiter(this, void 0, void 0, function* () {
      const c = yield this.rpc.request(svc, "CreateRoom", livekit_room_1.CreateRoomRequest.toJSON(livekit_room_1.CreateRoomRequest.fromPartial(u)), this.authHeader({ roomCreate: !0 }));
      return livekit_models_1$1.Room.fromJSON(c);
    });
  }
  /**
   * List active rooms
   * @param names when undefined or empty, list all rooms.
   *              otherwise returns rooms with matching names
   * @returns
   */
  listRooms(u) {
    var c;
    return __awaiter(this, void 0, void 0, function* () {
      const l = yield this.rpc.request(svc, "ListRooms", livekit_room_1.ListRoomsRequest.toJSON({ names: u ?? [] }), this.authHeader({ roomList: !0 }));
      return (c = livekit_room_1.ListRoomsResponse.fromJSON(l).rooms) !== null && c !== void 0 ? c : [];
    });
  }
  deleteRoom(u) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.rpc.request(svc, "DeleteRoom", livekit_room_1.DeleteRoomRequest.toJSON({ room: u }), this.authHeader({ roomCreate: !0 }));
    });
  }
  /**
   * Update metadata of a room
   * @param room name of the room
   * @param metadata the new metadata for the room
   */
  updateRoomMetadata(u, c) {
    return __awaiter(this, void 0, void 0, function* () {
      const l = yield this.rpc.request(svc, "UpdateRoomMetadata", livekit_room_1.UpdateRoomMetadataRequest.toJSON({ room: u, metadata: c }), this.authHeader({ roomAdmin: !0, room: u }));
      return livekit_models_1$1.Room.fromJSON(l);
    });
  }
  /**
   * List participants in a room
   * @param room name of the room
   */
  listParticipants(u) {
    var c;
    return __awaiter(this, void 0, void 0, function* () {
      const l = yield this.rpc.request(svc, "ListParticipants", livekit_room_1.ListParticipantsRequest.toJSON({ room: u }), this.authHeader({ roomAdmin: !0, room: u }));
      return (c = livekit_room_1.ListParticipantsResponse.fromJSON(l).participants) !== null && c !== void 0 ? c : [];
    });
  }
  /**
   * Get information on a specific participant, including the tracks that participant
   * has published
   * @param room name of the room
   * @param identity identity of the participant to return
   */
  getParticipant(u, c) {
    return __awaiter(this, void 0, void 0, function* () {
      const l = yield this.rpc.request(svc, "GetParticipant", livekit_room_1.RoomParticipantIdentity.toJSON({ room: u, identity: c }), this.authHeader({ roomAdmin: !0, room: u }));
      return livekit_models_1$1.ParticipantInfo.fromJSON(l);
    });
  }
  /**
   * Removes a participant in the room. This will disconnect the participant
   * and will emit a Disconnected event for that participant.
   * Even after being removed, the participant can still re-join the room.
   * @param room
   * @param identity
   */
  removeParticipant(u, c) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.rpc.request(svc, "RemoveParticipant", livekit_room_1.RoomParticipantIdentity.toJSON({ room: u, identity: c }), this.authHeader({ roomAdmin: !0, room: u }));
    });
  }
  /**
   * Mutes a track that the participant has published.
   * @param room
   * @param identity
   * @param trackSid sid of the track to be muted
   * @param muted true to mute, false to unmute
   */
  mutePublishedTrack(u, c, l, v) {
    return __awaiter(this, void 0, void 0, function* () {
      const p = livekit_room_1.MuteRoomTrackRequest.toJSON({
        room: u,
        identity: c,
        trackSid: l,
        muted: v
      }), _ = yield this.rpc.request(svc, "MutePublishedTrack", p, this.authHeader({ roomAdmin: !0, room: u }));
      return livekit_room_1.MuteRoomTrackResponse.fromJSON(_).track;
    });
  }
  /**
   * Updates a participant's metadata or permissions
   * @param room
   * @param identity
   * @param metadata optional, metadata to update
   * @param permission optional, new permissions to assign to participant
   * @param name optional, new name for participant
   */
  updateParticipant(u, c, l, v, p) {
    return __awaiter(this, void 0, void 0, function* () {
      const _ = {
        room: u,
        identity: c,
        metadata: l || "",
        permission: v,
        name: p || ""
      }, k = yield this.rpc.request(svc, "UpdateParticipant", livekit_room_1.UpdateParticipantRequest.toJSON(_), this.authHeader({ roomAdmin: !0, room: u }));
      return livekit_models_1$1.ParticipantInfo.fromJSON(k);
    });
  }
  /**
   * Updates a participant's subscription to tracks
   * @param room
   * @param identity
   * @param trackSids
   * @param subscribe true to subscribe, false to unsubscribe
   */
  updateSubscriptions(u, c, l, v) {
    return __awaiter(this, void 0, void 0, function* () {
      const p = livekit_room_1.UpdateSubscriptionsRequest.toJSON({
        room: u,
        identity: c,
        trackSids: l,
        subscribe: v,
        participantTracks: []
      });
      yield this.rpc.request(svc, "UpdateSubscriptions", p, this.authHeader({ roomAdmin: !0, room: u }));
    });
  }
  /**
   * Sends data message to participants in the room
   * @param room
   * @param data opaque payload to send
   * @param kind delivery reliability
   * @param destinationSids optional. when empty, message is sent to everyone
   */
  sendData(u, c, l, v = []) {
    return __awaiter(this, void 0, void 0, function* () {
      const p = livekit_room_1.SendDataRequest.toJSON({
        room: u,
        data: c,
        kind: l,
        destinationSids: v
      });
      yield this.rpc.request(svc, "SendData", p, this.authHeader({ roomAdmin: !0, room: u }));
    });
  }
  authHeader(u) {
    return this.jwt ? { Authorization: `Bearer ${this.jwt}` } : super.authHeader(u);
  }
}
RoomServiceClient$1.RoomServiceClient = RoomServiceClient;
var WebhookReceiver$1 = {}, livekit_webhook = {}, __importDefault$1 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(livekit_webhook, "__esModule", { value: !0 });
livekit_webhook.WebhookEvent = livekit_webhook.protobufPackage = void 0;
const long_1 = __importDefault$1(umdExports), minimal_1 = __importDefault$1(minimal), livekit_egress_1 = livekit_egress, livekit_ingress_1 = livekit_ingress, livekit_models_1 = livekit_models;
livekit_webhook.protobufPackage = "livekit";
function createBaseWebhookEvent() {
  return {
    event: "",
    room: void 0,
    participant: void 0,
    egressInfo: void 0,
    ingressInfo: void 0,
    track: void 0,
    id: "",
    createdAt: 0
  };
}
livekit_webhook.WebhookEvent = {
  encode(a, u = minimal_1.default.Writer.create()) {
    return a.event !== void 0 && a.event !== "" && u.uint32(10).string(a.event), a.room !== void 0 && livekit_models_1.Room.encode(a.room, u.uint32(18).fork()).ldelim(), a.participant !== void 0 && livekit_models_1.ParticipantInfo.encode(a.participant, u.uint32(26).fork()).ldelim(), a.egressInfo !== void 0 && livekit_egress_1.EgressInfo.encode(a.egressInfo, u.uint32(74).fork()).ldelim(), a.ingressInfo !== void 0 && livekit_ingress_1.IngressInfo.encode(a.ingressInfo, u.uint32(82).fork()).ldelim(), a.track !== void 0 && livekit_models_1.TrackInfo.encode(a.track, u.uint32(66).fork()).ldelim(), a.id !== void 0 && a.id !== "" && u.uint32(50).string(a.id), a.createdAt !== void 0 && a.createdAt !== 0 && u.uint32(56).int64(a.createdAt), u;
  },
  decode(a, u) {
    const c = a instanceof minimal_1.default.Reader ? a : new minimal_1.default.Reader(a);
    let l = u === void 0 ? c.len : c.pos + u;
    const v = createBaseWebhookEvent();
    for (; c.pos < l; ) {
      const p = c.uint32();
      switch (p >>> 3) {
        case 1:
          v.event = c.string();
          break;
        case 2:
          v.room = livekit_models_1.Room.decode(c, c.uint32());
          break;
        case 3:
          v.participant = livekit_models_1.ParticipantInfo.decode(c, c.uint32());
          break;
        case 9:
          v.egressInfo = livekit_egress_1.EgressInfo.decode(c, c.uint32());
          break;
        case 10:
          v.ingressInfo = livekit_ingress_1.IngressInfo.decode(c, c.uint32());
          break;
        case 8:
          v.track = livekit_models_1.TrackInfo.decode(c, c.uint32());
          break;
        case 6:
          v.id = c.string();
          break;
        case 7:
          v.createdAt = longToNumber(c.int64());
          break;
        default:
          c.skipType(p & 7);
          break;
      }
    }
    return v;
  },
  fromJSON(a) {
    return {
      event: isSet(a.event) ? String(a.event) : "",
      room: isSet(a.room) ? livekit_models_1.Room.fromJSON(a.room) : void 0,
      participant: isSet(a.participant) ? livekit_models_1.ParticipantInfo.fromJSON(a.participant) : void 0,
      egressInfo: isSet(a.egressInfo) ? livekit_egress_1.EgressInfo.fromJSON(a.egressInfo) : void 0,
      ingressInfo: isSet(a.ingressInfo) ? livekit_ingress_1.IngressInfo.fromJSON(a.ingressInfo) : void 0,
      track: isSet(a.track) ? livekit_models_1.TrackInfo.fromJSON(a.track) : void 0,
      id: isSet(a.id) ? String(a.id) : "",
      createdAt: isSet(a.createdAt) ? Number(a.createdAt) : 0
    };
  },
  toJSON(a) {
    const u = {};
    return a.event !== void 0 && (u.event = a.event), a.room !== void 0 && (u.room = a.room ? livekit_models_1.Room.toJSON(a.room) : void 0), a.participant !== void 0 && (u.participant = a.participant ? livekit_models_1.ParticipantInfo.toJSON(a.participant) : void 0), a.egressInfo !== void 0 && (u.egressInfo = a.egressInfo ? livekit_egress_1.EgressInfo.toJSON(a.egressInfo) : void 0), a.ingressInfo !== void 0 && (u.ingressInfo = a.ingressInfo ? livekit_ingress_1.IngressInfo.toJSON(a.ingressInfo) : void 0), a.track !== void 0 && (u.track = a.track ? livekit_models_1.TrackInfo.toJSON(a.track) : void 0), a.id !== void 0 && (u.id = a.id), a.createdAt !== void 0 && (u.createdAt = Math.round(a.createdAt)), u;
  },
  fromPartial(a) {
    var u, c, l;
    const v = createBaseWebhookEvent();
    return v.event = (u = a.event) !== null && u !== void 0 ? u : "", v.room = a.room !== void 0 && a.room !== null ? livekit_models_1.Room.fromPartial(a.room) : void 0, v.participant = a.participant !== void 0 && a.participant !== null ? livekit_models_1.ParticipantInfo.fromPartial(a.participant) : void 0, v.egressInfo = a.egressInfo !== void 0 && a.egressInfo !== null ? livekit_egress_1.EgressInfo.fromPartial(a.egressInfo) : void 0, v.ingressInfo = a.ingressInfo !== void 0 && a.ingressInfo !== null ? livekit_ingress_1.IngressInfo.fromPartial(a.ingressInfo) : void 0, v.track = a.track !== void 0 && a.track !== null ? livekit_models_1.TrackInfo.fromPartial(a.track) : void 0, v.id = (c = a.id) !== null && c !== void 0 ? c : "", v.createdAt = (l = a.createdAt) !== null && l !== void 0 ? l : 0, v;
  }
};
var globalThis$1 = (() => {
  if (typeof globalThis$1 < "u")
    return globalThis$1;
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof commonjsGlobal$1 < "u")
    return commonjsGlobal$1;
  throw "Unable to locate global object";
})();
function longToNumber(a) {
  if (a.gt(Number.MAX_SAFE_INTEGER))
    throw new globalThis$1.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  return a.toNumber();
}
minimal_1.default.util.Long !== long_1.default && (minimal_1.default.util.Long = long_1.default, minimal_1.default.configure());
function isSet(a) {
  return a != null;
}
var __importDefault = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(WebhookReceiver$1, "__esModule", { value: !0 });
WebhookReceiver$1.WebhookReceiver = WebhookReceiver$1.authorizeHeader = void 0;
const crypto_1 = __importDefault(requireCryptoBrowserify()), AccessToken_1 = AccessToken$1, livekit_webhook_1 = livekit_webhook;
WebhookReceiver$1.authorizeHeader = "Authorize";
class WebhookReceiver {
  constructor(u, c) {
    this.verifier = new AccessToken_1.TokenVerifier(u, c);
  }
  /**
   *
   * @param body string of the posted body
   * @param authHeader `Authorization` header from the request
   * @param skipAuth true to skip auth validation
   * @returns
   */
  receive(u, c, l = !1) {
    if (!l) {
      if (!c)
        throw new Error("authorization header is empty");
      const v = this.verifier.verify(c), p = crypto_1.default.createHash("sha256");
      if (p.update(u), v.sha256 !== p.digest("base64"))
        throw new Error("sha256 checksum of body does not match");
    }
    return livekit_webhook_1.WebhookEvent.fromJSON(JSON.parse(u));
  }
}
WebhookReceiver$1.WebhookReceiver = WebhookReceiver;
var livekit_internal = {}, livekit_rtc = {};
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(A) {
    return A && A.__esModule ? A : { default: A };
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.SimulateScenario = a.DataChannelInfo = a.SyncState = a.SubscriptionPermissionUpdate = a.SubscriptionPermission = a.TrackPermission = a.SubscribedQualityUpdate = a.SubscribedCodec = a.SubscribedQuality = a.StreamStateUpdate = a.StreamStateInfo = a.ConnectionQualityUpdate = a.ConnectionQualityInfo = a.RoomUpdate = a.SpeakersChanged = a.ICEServer = a.UpdateVideoLayers = a.LeaveRequest = a.UpdateTrackSettings = a.UpdateSubscription = a.ParticipantUpdate = a.SessionDescription = a.TrackUnpublishedResponse = a.TrackPublishedResponse = a.JoinResponse = a.MuteTrackRequest = a.TrickleRequest = a.AddTrackRequest = a.SimulcastCodec = a.SignalResponse = a.SignalRequest = a.candidateProtocolToJSON = a.candidateProtocolFromJSON = a.CandidateProtocol = a.streamStateToJSON = a.streamStateFromJSON = a.StreamState = a.signalTargetToJSON = a.signalTargetFromJSON = a.SignalTarget = a.protobufPackage = void 0;
  const c = u(umdExports), l = u(minimal), v = livekit_models;
  a.protobufPackage = "livekit";
  var p;
  (function(A) {
    A[A.PUBLISHER = 0] = "PUBLISHER", A[A.SUBSCRIBER = 1] = "SUBSCRIBER", A[A.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(p = a.SignalTarget || (a.SignalTarget = {}));
  function _(A) {
    switch (A) {
      case 0:
      case "PUBLISHER":
        return p.PUBLISHER;
      case 1:
      case "SUBSCRIBER":
        return p.SUBSCRIBER;
      case -1:
      case "UNRECOGNIZED":
      default:
        return p.UNRECOGNIZED;
    }
  }
  a.signalTargetFromJSON = _;
  function k(A) {
    switch (A) {
      case p.PUBLISHER:
        return "PUBLISHER";
      case p.SUBSCRIBER:
        return "SUBSCRIBER";
      case p.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.signalTargetToJSON = k;
  var O;
  (function(A) {
    A[A.ACTIVE = 0] = "ACTIVE", A[A.PAUSED = 1] = "PAUSED", A[A.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(O = a.StreamState || (a.StreamState = {}));
  function D(A) {
    switch (A) {
      case 0:
      case "ACTIVE":
        return O.ACTIVE;
      case 1:
      case "PAUSED":
        return O.PAUSED;
      case -1:
      case "UNRECOGNIZED":
      default:
        return O.UNRECOGNIZED;
    }
  }
  a.streamStateFromJSON = D;
  function F(A) {
    switch (A) {
      case O.ACTIVE:
        return "ACTIVE";
      case O.PAUSED:
        return "PAUSED";
      case O.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.streamStateToJSON = F;
  var H;
  (function(A) {
    A[A.UDP = 0] = "UDP", A[A.TCP = 1] = "TCP", A[A.TLS = 2] = "TLS", A[A.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(H = a.CandidateProtocol || (a.CandidateProtocol = {}));
  function Z(A) {
    switch (A) {
      case 0:
      case "UDP":
        return H.UDP;
      case 1:
      case "TCP":
        return H.TCP;
      case 2:
      case "TLS":
        return H.TLS;
      case -1:
      case "UNRECOGNIZED":
      default:
        return H.UNRECOGNIZED;
    }
  }
  a.candidateProtocolFromJSON = Z;
  function ee(A) {
    switch (A) {
      case H.UDP:
        return "UDP";
      case H.TCP:
        return "TCP";
      case H.TLS:
        return "TLS";
      case H.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.candidateProtocolToJSON = ee;
  function X() {
    return {
      offer: void 0,
      answer: void 0,
      trickle: void 0,
      addTrack: void 0,
      mute: void 0,
      subscription: void 0,
      trackSetting: void 0,
      leave: void 0,
      updateLayers: void 0,
      subscriptionPermission: void 0,
      syncState: void 0,
      simulate: void 0,
      ping: void 0
    };
  }
  a.SignalRequest = {
    encode(A, re = l.default.Writer.create()) {
      return A.offer !== void 0 && a.SessionDescription.encode(A.offer, re.uint32(10).fork()).ldelim(), A.answer !== void 0 && a.SessionDescription.encode(A.answer, re.uint32(18).fork()).ldelim(), A.trickle !== void 0 && a.TrickleRequest.encode(A.trickle, re.uint32(26).fork()).ldelim(), A.addTrack !== void 0 && a.AddTrackRequest.encode(A.addTrack, re.uint32(34).fork()).ldelim(), A.mute !== void 0 && a.MuteTrackRequest.encode(A.mute, re.uint32(42).fork()).ldelim(), A.subscription !== void 0 && a.UpdateSubscription.encode(A.subscription, re.uint32(50).fork()).ldelim(), A.trackSetting !== void 0 && a.UpdateTrackSettings.encode(A.trackSetting, re.uint32(58).fork()).ldelim(), A.leave !== void 0 && a.LeaveRequest.encode(A.leave, re.uint32(66).fork()).ldelim(), A.updateLayers !== void 0 && a.UpdateVideoLayers.encode(A.updateLayers, re.uint32(82).fork()).ldelim(), A.subscriptionPermission !== void 0 && a.SubscriptionPermission.encode(A.subscriptionPermission, re.uint32(90).fork()).ldelim(), A.syncState !== void 0 && a.SyncState.encode(A.syncState, re.uint32(98).fork()).ldelim(), A.simulate !== void 0 && a.SimulateScenario.encode(A.simulate, re.uint32(106).fork()).ldelim(), A.ping !== void 0 && re.uint32(112).int64(A.ping), re;
    },
    decode(A, re) {
      const le = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let $e = re === void 0 ? le.len : le.pos + re;
      const Oe = X();
      for (; le.pos < $e; ) {
        const Fe = le.uint32();
        switch (Fe >>> 3) {
          case 1:
            Oe.offer = a.SessionDescription.decode(le, le.uint32());
            break;
          case 2:
            Oe.answer = a.SessionDescription.decode(le, le.uint32());
            break;
          case 3:
            Oe.trickle = a.TrickleRequest.decode(le, le.uint32());
            break;
          case 4:
            Oe.addTrack = a.AddTrackRequest.decode(le, le.uint32());
            break;
          case 5:
            Oe.mute = a.MuteTrackRequest.decode(le, le.uint32());
            break;
          case 6:
            Oe.subscription = a.UpdateSubscription.decode(le, le.uint32());
            break;
          case 7:
            Oe.trackSetting = a.UpdateTrackSettings.decode(le, le.uint32());
            break;
          case 8:
            Oe.leave = a.LeaveRequest.decode(le, le.uint32());
            break;
          case 10:
            Oe.updateLayers = a.UpdateVideoLayers.decode(le, le.uint32());
            break;
          case 11:
            Oe.subscriptionPermission = a.SubscriptionPermission.decode(le, le.uint32());
            break;
          case 12:
            Oe.syncState = a.SyncState.decode(le, le.uint32());
            break;
          case 13:
            Oe.simulate = a.SimulateScenario.decode(le, le.uint32());
            break;
          case 14:
            Oe.ping = Ue(le.int64());
            break;
          default:
            le.skipType(Fe & 7);
            break;
        }
      }
      return Oe;
    },
    fromJSON(A) {
      return {
        offer: oe(A.offer) ? a.SessionDescription.fromJSON(A.offer) : void 0,
        answer: oe(A.answer) ? a.SessionDescription.fromJSON(A.answer) : void 0,
        trickle: oe(A.trickle) ? a.TrickleRequest.fromJSON(A.trickle) : void 0,
        addTrack: oe(A.addTrack) ? a.AddTrackRequest.fromJSON(A.addTrack) : void 0,
        mute: oe(A.mute) ? a.MuteTrackRequest.fromJSON(A.mute) : void 0,
        subscription: oe(A.subscription) ? a.UpdateSubscription.fromJSON(A.subscription) : void 0,
        trackSetting: oe(A.trackSetting) ? a.UpdateTrackSettings.fromJSON(A.trackSetting) : void 0,
        leave: oe(A.leave) ? a.LeaveRequest.fromJSON(A.leave) : void 0,
        updateLayers: oe(A.updateLayers) ? a.UpdateVideoLayers.fromJSON(A.updateLayers) : void 0,
        subscriptionPermission: oe(A.subscriptionPermission) ? a.SubscriptionPermission.fromJSON(A.subscriptionPermission) : void 0,
        syncState: oe(A.syncState) ? a.SyncState.fromJSON(A.syncState) : void 0,
        simulate: oe(A.simulate) ? a.SimulateScenario.fromJSON(A.simulate) : void 0,
        ping: oe(A.ping) ? Number(A.ping) : void 0
      };
    },
    toJSON(A) {
      const re = {};
      return A.offer !== void 0 && (re.offer = A.offer ? a.SessionDescription.toJSON(A.offer) : void 0), A.answer !== void 0 && (re.answer = A.answer ? a.SessionDescription.toJSON(A.answer) : void 0), A.trickle !== void 0 && (re.trickle = A.trickle ? a.TrickleRequest.toJSON(A.trickle) : void 0), A.addTrack !== void 0 && (re.addTrack = A.addTrack ? a.AddTrackRequest.toJSON(A.addTrack) : void 0), A.mute !== void 0 && (re.mute = A.mute ? a.MuteTrackRequest.toJSON(A.mute) : void 0), A.subscription !== void 0 && (re.subscription = A.subscription ? a.UpdateSubscription.toJSON(A.subscription) : void 0), A.trackSetting !== void 0 && (re.trackSetting = A.trackSetting ? a.UpdateTrackSettings.toJSON(A.trackSetting) : void 0), A.leave !== void 0 && (re.leave = A.leave ? a.LeaveRequest.toJSON(A.leave) : void 0), A.updateLayers !== void 0 && (re.updateLayers = A.updateLayers ? a.UpdateVideoLayers.toJSON(A.updateLayers) : void 0), A.subscriptionPermission !== void 0 && (re.subscriptionPermission = A.subscriptionPermission ? a.SubscriptionPermission.toJSON(A.subscriptionPermission) : void 0), A.syncState !== void 0 && (re.syncState = A.syncState ? a.SyncState.toJSON(A.syncState) : void 0), A.simulate !== void 0 && (re.simulate = A.simulate ? a.SimulateScenario.toJSON(A.simulate) : void 0), A.ping !== void 0 && (re.ping = Math.round(A.ping)), re;
    },
    fromPartial(A) {
      var re;
      const le = X();
      return le.offer = A.offer !== void 0 && A.offer !== null ? a.SessionDescription.fromPartial(A.offer) : void 0, le.answer = A.answer !== void 0 && A.answer !== null ? a.SessionDescription.fromPartial(A.answer) : void 0, le.trickle = A.trickle !== void 0 && A.trickle !== null ? a.TrickleRequest.fromPartial(A.trickle) : void 0, le.addTrack = A.addTrack !== void 0 && A.addTrack !== null ? a.AddTrackRequest.fromPartial(A.addTrack) : void 0, le.mute = A.mute !== void 0 && A.mute !== null ? a.MuteTrackRequest.fromPartial(A.mute) : void 0, le.subscription = A.subscription !== void 0 && A.subscription !== null ? a.UpdateSubscription.fromPartial(A.subscription) : void 0, le.trackSetting = A.trackSetting !== void 0 && A.trackSetting !== null ? a.UpdateTrackSettings.fromPartial(A.trackSetting) : void 0, le.leave = A.leave !== void 0 && A.leave !== null ? a.LeaveRequest.fromPartial(A.leave) : void 0, le.updateLayers = A.updateLayers !== void 0 && A.updateLayers !== null ? a.UpdateVideoLayers.fromPartial(A.updateLayers) : void 0, le.subscriptionPermission = A.subscriptionPermission !== void 0 && A.subscriptionPermission !== null ? a.SubscriptionPermission.fromPartial(A.subscriptionPermission) : void 0, le.syncState = A.syncState !== void 0 && A.syncState !== null ? a.SyncState.fromPartial(A.syncState) : void 0, le.simulate = A.simulate !== void 0 && A.simulate !== null ? a.SimulateScenario.fromPartial(A.simulate) : void 0, le.ping = (re = A.ping) !== null && re !== void 0 ? re : void 0, le;
    }
  };
  function ne() {
    return {
      join: void 0,
      answer: void 0,
      offer: void 0,
      trickle: void 0,
      update: void 0,
      trackPublished: void 0,
      leave: void 0,
      mute: void 0,
      speakersChanged: void 0,
      roomUpdate: void 0,
      connectionQuality: void 0,
      streamStateUpdate: void 0,
      subscribedQualityUpdate: void 0,
      subscriptionPermissionUpdate: void 0,
      refreshToken: void 0,
      trackUnpublished: void 0,
      pong: void 0
    };
  }
  a.SignalResponse = {
    encode(A, re = l.default.Writer.create()) {
      return A.join !== void 0 && a.JoinResponse.encode(A.join, re.uint32(10).fork()).ldelim(), A.answer !== void 0 && a.SessionDescription.encode(A.answer, re.uint32(18).fork()).ldelim(), A.offer !== void 0 && a.SessionDescription.encode(A.offer, re.uint32(26).fork()).ldelim(), A.trickle !== void 0 && a.TrickleRequest.encode(A.trickle, re.uint32(34).fork()).ldelim(), A.update !== void 0 && a.ParticipantUpdate.encode(A.update, re.uint32(42).fork()).ldelim(), A.trackPublished !== void 0 && a.TrackPublishedResponse.encode(A.trackPublished, re.uint32(50).fork()).ldelim(), A.leave !== void 0 && a.LeaveRequest.encode(A.leave, re.uint32(66).fork()).ldelim(), A.mute !== void 0 && a.MuteTrackRequest.encode(A.mute, re.uint32(74).fork()).ldelim(), A.speakersChanged !== void 0 && a.SpeakersChanged.encode(A.speakersChanged, re.uint32(82).fork()).ldelim(), A.roomUpdate !== void 0 && a.RoomUpdate.encode(A.roomUpdate, re.uint32(90).fork()).ldelim(), A.connectionQuality !== void 0 && a.ConnectionQualityUpdate.encode(A.connectionQuality, re.uint32(98).fork()).ldelim(), A.streamStateUpdate !== void 0 && a.StreamStateUpdate.encode(A.streamStateUpdate, re.uint32(106).fork()).ldelim(), A.subscribedQualityUpdate !== void 0 && a.SubscribedQualityUpdate.encode(A.subscribedQualityUpdate, re.uint32(114).fork()).ldelim(), A.subscriptionPermissionUpdate !== void 0 && a.SubscriptionPermissionUpdate.encode(A.subscriptionPermissionUpdate, re.uint32(122).fork()).ldelim(), A.refreshToken !== void 0 && re.uint32(130).string(A.refreshToken), A.trackUnpublished !== void 0 && a.TrackUnpublishedResponse.encode(A.trackUnpublished, re.uint32(138).fork()).ldelim(), A.pong !== void 0 && re.uint32(144).int64(A.pong), re;
    },
    decode(A, re) {
      const le = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let $e = re === void 0 ? le.len : le.pos + re;
      const Oe = ne();
      for (; le.pos < $e; ) {
        const Fe = le.uint32();
        switch (Fe >>> 3) {
          case 1:
            Oe.join = a.JoinResponse.decode(le, le.uint32());
            break;
          case 2:
            Oe.answer = a.SessionDescription.decode(le, le.uint32());
            break;
          case 3:
            Oe.offer = a.SessionDescription.decode(le, le.uint32());
            break;
          case 4:
            Oe.trickle = a.TrickleRequest.decode(le, le.uint32());
            break;
          case 5:
            Oe.update = a.ParticipantUpdate.decode(le, le.uint32());
            break;
          case 6:
            Oe.trackPublished = a.TrackPublishedResponse.decode(le, le.uint32());
            break;
          case 8:
            Oe.leave = a.LeaveRequest.decode(le, le.uint32());
            break;
          case 9:
            Oe.mute = a.MuteTrackRequest.decode(le, le.uint32());
            break;
          case 10:
            Oe.speakersChanged = a.SpeakersChanged.decode(le, le.uint32());
            break;
          case 11:
            Oe.roomUpdate = a.RoomUpdate.decode(le, le.uint32());
            break;
          case 12:
            Oe.connectionQuality = a.ConnectionQualityUpdate.decode(le, le.uint32());
            break;
          case 13:
            Oe.streamStateUpdate = a.StreamStateUpdate.decode(le, le.uint32());
            break;
          case 14:
            Oe.subscribedQualityUpdate = a.SubscribedQualityUpdate.decode(le, le.uint32());
            break;
          case 15:
            Oe.subscriptionPermissionUpdate = a.SubscriptionPermissionUpdate.decode(le, le.uint32());
            break;
          case 16:
            Oe.refreshToken = le.string();
            break;
          case 17:
            Oe.trackUnpublished = a.TrackUnpublishedResponse.decode(le, le.uint32());
            break;
          case 18:
            Oe.pong = Ue(le.int64());
            break;
          default:
            le.skipType(Fe & 7);
            break;
        }
      }
      return Oe;
    },
    fromJSON(A) {
      return {
        join: oe(A.join) ? a.JoinResponse.fromJSON(A.join) : void 0,
        answer: oe(A.answer) ? a.SessionDescription.fromJSON(A.answer) : void 0,
        offer: oe(A.offer) ? a.SessionDescription.fromJSON(A.offer) : void 0,
        trickle: oe(A.trickle) ? a.TrickleRequest.fromJSON(A.trickle) : void 0,
        update: oe(A.update) ? a.ParticipantUpdate.fromJSON(A.update) : void 0,
        trackPublished: oe(A.trackPublished) ? a.TrackPublishedResponse.fromJSON(A.trackPublished) : void 0,
        leave: oe(A.leave) ? a.LeaveRequest.fromJSON(A.leave) : void 0,
        mute: oe(A.mute) ? a.MuteTrackRequest.fromJSON(A.mute) : void 0,
        speakersChanged: oe(A.speakersChanged) ? a.SpeakersChanged.fromJSON(A.speakersChanged) : void 0,
        roomUpdate: oe(A.roomUpdate) ? a.RoomUpdate.fromJSON(A.roomUpdate) : void 0,
        connectionQuality: oe(A.connectionQuality) ? a.ConnectionQualityUpdate.fromJSON(A.connectionQuality) : void 0,
        streamStateUpdate: oe(A.streamStateUpdate) ? a.StreamStateUpdate.fromJSON(A.streamStateUpdate) : void 0,
        subscribedQualityUpdate: oe(A.subscribedQualityUpdate) ? a.SubscribedQualityUpdate.fromJSON(A.subscribedQualityUpdate) : void 0,
        subscriptionPermissionUpdate: oe(A.subscriptionPermissionUpdate) ? a.SubscriptionPermissionUpdate.fromJSON(A.subscriptionPermissionUpdate) : void 0,
        refreshToken: oe(A.refreshToken) ? String(A.refreshToken) : void 0,
        trackUnpublished: oe(A.trackUnpublished) ? a.TrackUnpublishedResponse.fromJSON(A.trackUnpublished) : void 0,
        pong: oe(A.pong) ? Number(A.pong) : void 0
      };
    },
    toJSON(A) {
      const re = {};
      return A.join !== void 0 && (re.join = A.join ? a.JoinResponse.toJSON(A.join) : void 0), A.answer !== void 0 && (re.answer = A.answer ? a.SessionDescription.toJSON(A.answer) : void 0), A.offer !== void 0 && (re.offer = A.offer ? a.SessionDescription.toJSON(A.offer) : void 0), A.trickle !== void 0 && (re.trickle = A.trickle ? a.TrickleRequest.toJSON(A.trickle) : void 0), A.update !== void 0 && (re.update = A.update ? a.ParticipantUpdate.toJSON(A.update) : void 0), A.trackPublished !== void 0 && (re.trackPublished = A.trackPublished ? a.TrackPublishedResponse.toJSON(A.trackPublished) : void 0), A.leave !== void 0 && (re.leave = A.leave ? a.LeaveRequest.toJSON(A.leave) : void 0), A.mute !== void 0 && (re.mute = A.mute ? a.MuteTrackRequest.toJSON(A.mute) : void 0), A.speakersChanged !== void 0 && (re.speakersChanged = A.speakersChanged ? a.SpeakersChanged.toJSON(A.speakersChanged) : void 0), A.roomUpdate !== void 0 && (re.roomUpdate = A.roomUpdate ? a.RoomUpdate.toJSON(A.roomUpdate) : void 0), A.connectionQuality !== void 0 && (re.connectionQuality = A.connectionQuality ? a.ConnectionQualityUpdate.toJSON(A.connectionQuality) : void 0), A.streamStateUpdate !== void 0 && (re.streamStateUpdate = A.streamStateUpdate ? a.StreamStateUpdate.toJSON(A.streamStateUpdate) : void 0), A.subscribedQualityUpdate !== void 0 && (re.subscribedQualityUpdate = A.subscribedQualityUpdate ? a.SubscribedQualityUpdate.toJSON(A.subscribedQualityUpdate) : void 0), A.subscriptionPermissionUpdate !== void 0 && (re.subscriptionPermissionUpdate = A.subscriptionPermissionUpdate ? a.SubscriptionPermissionUpdate.toJSON(A.subscriptionPermissionUpdate) : void 0), A.refreshToken !== void 0 && (re.refreshToken = A.refreshToken), A.trackUnpublished !== void 0 && (re.trackUnpublished = A.trackUnpublished ? a.TrackUnpublishedResponse.toJSON(A.trackUnpublished) : void 0), A.pong !== void 0 && (re.pong = Math.round(A.pong)), re;
    },
    fromPartial(A) {
      var re, le;
      const $e = ne();
      return $e.join = A.join !== void 0 && A.join !== null ? a.JoinResponse.fromPartial(A.join) : void 0, $e.answer = A.answer !== void 0 && A.answer !== null ? a.SessionDescription.fromPartial(A.answer) : void 0, $e.offer = A.offer !== void 0 && A.offer !== null ? a.SessionDescription.fromPartial(A.offer) : void 0, $e.trickle = A.trickle !== void 0 && A.trickle !== null ? a.TrickleRequest.fromPartial(A.trickle) : void 0, $e.update = A.update !== void 0 && A.update !== null ? a.ParticipantUpdate.fromPartial(A.update) : void 0, $e.trackPublished = A.trackPublished !== void 0 && A.trackPublished !== null ? a.TrackPublishedResponse.fromPartial(A.trackPublished) : void 0, $e.leave = A.leave !== void 0 && A.leave !== null ? a.LeaveRequest.fromPartial(A.leave) : void 0, $e.mute = A.mute !== void 0 && A.mute !== null ? a.MuteTrackRequest.fromPartial(A.mute) : void 0, $e.speakersChanged = A.speakersChanged !== void 0 && A.speakersChanged !== null ? a.SpeakersChanged.fromPartial(A.speakersChanged) : void 0, $e.roomUpdate = A.roomUpdate !== void 0 && A.roomUpdate !== null ? a.RoomUpdate.fromPartial(A.roomUpdate) : void 0, $e.connectionQuality = A.connectionQuality !== void 0 && A.connectionQuality !== null ? a.ConnectionQualityUpdate.fromPartial(A.connectionQuality) : void 0, $e.streamStateUpdate = A.streamStateUpdate !== void 0 && A.streamStateUpdate !== null ? a.StreamStateUpdate.fromPartial(A.streamStateUpdate) : void 0, $e.subscribedQualityUpdate = A.subscribedQualityUpdate !== void 0 && A.subscribedQualityUpdate !== null ? a.SubscribedQualityUpdate.fromPartial(A.subscribedQualityUpdate) : void 0, $e.subscriptionPermissionUpdate = A.subscriptionPermissionUpdate !== void 0 && A.subscriptionPermissionUpdate !== null ? a.SubscriptionPermissionUpdate.fromPartial(A.subscriptionPermissionUpdate) : void 0, $e.refreshToken = (re = A.refreshToken) !== null && re !== void 0 ? re : void 0, $e.trackUnpublished = A.trackUnpublished !== void 0 && A.trackUnpublished !== null ? a.TrackUnpublishedResponse.fromPartial(A.trackUnpublished) : void 0, $e.pong = (le = A.pong) !== null && le !== void 0 ? le : void 0, $e;
    }
  };
  function Q() {
    return { codec: "", cid: "", enableSimulcastLayers: !1 };
  }
  a.SimulcastCodec = {
    encode(A, re = l.default.Writer.create()) {
      return A.codec !== void 0 && A.codec !== "" && re.uint32(10).string(A.codec), A.cid !== void 0 && A.cid !== "" && re.uint32(18).string(A.cid), A.enableSimulcastLayers === !0 && re.uint32(24).bool(A.enableSimulcastLayers), re;
    },
    decode(A, re) {
      const le = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let $e = re === void 0 ? le.len : le.pos + re;
      const Oe = Q();
      for (; le.pos < $e; ) {
        const Fe = le.uint32();
        switch (Fe >>> 3) {
          case 1:
            Oe.codec = le.string();
            break;
          case 2:
            Oe.cid = le.string();
            break;
          case 3:
            Oe.enableSimulcastLayers = le.bool();
            break;
          default:
            le.skipType(Fe & 7);
            break;
        }
      }
      return Oe;
    },
    fromJSON(A) {
      return {
        codec: oe(A.codec) ? String(A.codec) : "",
        cid: oe(A.cid) ? String(A.cid) : "",
        enableSimulcastLayers: oe(A.enableSimulcastLayers) ? !!A.enableSimulcastLayers : !1
      };
    },
    toJSON(A) {
      const re = {};
      return A.codec !== void 0 && (re.codec = A.codec), A.cid !== void 0 && (re.cid = A.cid), A.enableSimulcastLayers !== void 0 && (re.enableSimulcastLayers = A.enableSimulcastLayers), re;
    },
    fromPartial(A) {
      var re, le, $e;
      const Oe = Q();
      return Oe.codec = (re = A.codec) !== null && re !== void 0 ? re : "", Oe.cid = (le = A.cid) !== null && le !== void 0 ? le : "", Oe.enableSimulcastLayers = ($e = A.enableSimulcastLayers) !== null && $e !== void 0 ? $e : !1, Oe;
    }
  };
  function ae() {
    return {
      cid: "",
      name: "",
      type: 0,
      width: 0,
      height: 0,
      muted: !1,
      disableDtx: !1,
      source: 0,
      layers: [],
      simulcastCodecs: [],
      sid: "",
      stereo: !1,
      disableRed: !1
    };
  }
  a.AddTrackRequest = {
    encode(A, re = l.default.Writer.create()) {
      if (A.cid !== void 0 && A.cid !== "" && re.uint32(10).string(A.cid), A.name !== void 0 && A.name !== "" && re.uint32(18).string(A.name), A.type !== void 0 && A.type !== 0 && re.uint32(24).int32(A.type), A.width !== void 0 && A.width !== 0 && re.uint32(32).uint32(A.width), A.height !== void 0 && A.height !== 0 && re.uint32(40).uint32(A.height), A.muted === !0 && re.uint32(48).bool(A.muted), A.disableDtx === !0 && re.uint32(56).bool(A.disableDtx), A.source !== void 0 && A.source !== 0 && re.uint32(64).int32(A.source), A.layers !== void 0 && A.layers.length !== 0)
        for (const le of A.layers)
          v.VideoLayer.encode(le, re.uint32(74).fork()).ldelim();
      if (A.simulcastCodecs !== void 0 && A.simulcastCodecs.length !== 0)
        for (const le of A.simulcastCodecs)
          a.SimulcastCodec.encode(le, re.uint32(82).fork()).ldelim();
      return A.sid !== void 0 && A.sid !== "" && re.uint32(90).string(A.sid), A.stereo === !0 && re.uint32(96).bool(A.stereo), A.disableRed === !0 && re.uint32(104).bool(A.disableRed), re;
    },
    decode(A, re) {
      const le = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let $e = re === void 0 ? le.len : le.pos + re;
      const Oe = ae();
      for (; le.pos < $e; ) {
        const Fe = le.uint32();
        switch (Fe >>> 3) {
          case 1:
            Oe.cid = le.string();
            break;
          case 2:
            Oe.name = le.string();
            break;
          case 3:
            Oe.type = le.int32();
            break;
          case 4:
            Oe.width = le.uint32();
            break;
          case 5:
            Oe.height = le.uint32();
            break;
          case 6:
            Oe.muted = le.bool();
            break;
          case 7:
            Oe.disableDtx = le.bool();
            break;
          case 8:
            Oe.source = le.int32();
            break;
          case 9:
            Oe.layers.push(v.VideoLayer.decode(le, le.uint32()));
            break;
          case 10:
            Oe.simulcastCodecs.push(a.SimulcastCodec.decode(le, le.uint32()));
            break;
          case 11:
            Oe.sid = le.string();
            break;
          case 12:
            Oe.stereo = le.bool();
            break;
          case 13:
            Oe.disableRed = le.bool();
            break;
          default:
            le.skipType(Fe & 7);
            break;
        }
      }
      return Oe;
    },
    fromJSON(A) {
      return {
        cid: oe(A.cid) ? String(A.cid) : "",
        name: oe(A.name) ? String(A.name) : "",
        type: oe(A.type) ? v.trackTypeFromJSON(A.type) : 0,
        width: oe(A.width) ? Number(A.width) : 0,
        height: oe(A.height) ? Number(A.height) : 0,
        muted: oe(A.muted) ? !!A.muted : !1,
        disableDtx: oe(A.disableDtx) ? !!A.disableDtx : !1,
        source: oe(A.source) ? v.trackSourceFromJSON(A.source) : 0,
        layers: Array.isArray(A == null ? void 0 : A.layers) ? A.layers.map((re) => v.VideoLayer.fromJSON(re)) : [],
        simulcastCodecs: Array.isArray(A == null ? void 0 : A.simulcastCodecs) ? A.simulcastCodecs.map((re) => a.SimulcastCodec.fromJSON(re)) : [],
        sid: oe(A.sid) ? String(A.sid) : "",
        stereo: oe(A.stereo) ? !!A.stereo : !1,
        disableRed: oe(A.disableRed) ? !!A.disableRed : !1
      };
    },
    toJSON(A) {
      const re = {};
      return A.cid !== void 0 && (re.cid = A.cid), A.name !== void 0 && (re.name = A.name), A.type !== void 0 && (re.type = v.trackTypeToJSON(A.type)), A.width !== void 0 && (re.width = Math.round(A.width)), A.height !== void 0 && (re.height = Math.round(A.height)), A.muted !== void 0 && (re.muted = A.muted), A.disableDtx !== void 0 && (re.disableDtx = A.disableDtx), A.source !== void 0 && (re.source = v.trackSourceToJSON(A.source)), A.layers ? re.layers = A.layers.map((le) => le ? v.VideoLayer.toJSON(le) : void 0) : re.layers = [], A.simulcastCodecs ? re.simulcastCodecs = A.simulcastCodecs.map((le) => le ? a.SimulcastCodec.toJSON(le) : void 0) : re.simulcastCodecs = [], A.sid !== void 0 && (re.sid = A.sid), A.stereo !== void 0 && (re.stereo = A.stereo), A.disableRed !== void 0 && (re.disableRed = A.disableRed), re;
    },
    fromPartial(A) {
      var re, le, $e, Oe, Fe, Ze, qe, yt, Xe, Ge, J, ge, we;
      const We = ae();
      return We.cid = (re = A.cid) !== null && re !== void 0 ? re : "", We.name = (le = A.name) !== null && le !== void 0 ? le : "", We.type = ($e = A.type) !== null && $e !== void 0 ? $e : 0, We.width = (Oe = A.width) !== null && Oe !== void 0 ? Oe : 0, We.height = (Fe = A.height) !== null && Fe !== void 0 ? Fe : 0, We.muted = (Ze = A.muted) !== null && Ze !== void 0 ? Ze : !1, We.disableDtx = (qe = A.disableDtx) !== null && qe !== void 0 ? qe : !1, We.source = (yt = A.source) !== null && yt !== void 0 ? yt : 0, We.layers = ((Xe = A.layers) === null || Xe === void 0 ? void 0 : Xe.map((Ie) => v.VideoLayer.fromPartial(Ie))) || [], We.simulcastCodecs = ((Ge = A.simulcastCodecs) === null || Ge === void 0 ? void 0 : Ge.map((Ie) => a.SimulcastCodec.fromPartial(Ie))) || [], We.sid = (J = A.sid) !== null && J !== void 0 ? J : "", We.stereo = (ge = A.stereo) !== null && ge !== void 0 ? ge : !1, We.disableRed = (we = A.disableRed) !== null && we !== void 0 ? we : !1, We;
    }
  };
  function j() {
    return { candidateInit: "", target: 0 };
  }
  a.TrickleRequest = {
    encode(A, re = l.default.Writer.create()) {
      return A.candidateInit !== void 0 && A.candidateInit !== "" && re.uint32(10).string(A.candidateInit), A.target !== void 0 && A.target !== 0 && re.uint32(16).int32(A.target), re;
    },
    decode(A, re) {
      const le = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let $e = re === void 0 ? le.len : le.pos + re;
      const Oe = j();
      for (; le.pos < $e; ) {
        const Fe = le.uint32();
        switch (Fe >>> 3) {
          case 1:
            Oe.candidateInit = le.string();
            break;
          case 2:
            Oe.target = le.int32();
            break;
          default:
            le.skipType(Fe & 7);
            break;
        }
      }
      return Oe;
    },
    fromJSON(A) {
      return {
        candidateInit: oe(A.candidateInit) ? String(A.candidateInit) : "",
        target: oe(A.target) ? _(A.target) : 0
      };
    },
    toJSON(A) {
      const re = {};
      return A.candidateInit !== void 0 && (re.candidateInit = A.candidateInit), A.target !== void 0 && (re.target = k(A.target)), re;
    },
    fromPartial(A) {
      var re, le;
      const $e = j();
      return $e.candidateInit = (re = A.candidateInit) !== null && re !== void 0 ? re : "", $e.target = (le = A.target) !== null && le !== void 0 ? le : 0, $e;
    }
  };
  function ue() {
    return { sid: "", muted: !1 };
  }
  a.MuteTrackRequest = {
    encode(A, re = l.default.Writer.create()) {
      return A.sid !== void 0 && A.sid !== "" && re.uint32(10).string(A.sid), A.muted === !0 && re.uint32(16).bool(A.muted), re;
    },
    decode(A, re) {
      const le = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let $e = re === void 0 ? le.len : le.pos + re;
      const Oe = ue();
      for (; le.pos < $e; ) {
        const Fe = le.uint32();
        switch (Fe >>> 3) {
          case 1:
            Oe.sid = le.string();
            break;
          case 2:
            Oe.muted = le.bool();
            break;
          default:
            le.skipType(Fe & 7);
            break;
        }
      }
      return Oe;
    },
    fromJSON(A) {
      return {
        sid: oe(A.sid) ? String(A.sid) : "",
        muted: oe(A.muted) ? !!A.muted : !1
      };
    },
    toJSON(A) {
      const re = {};
      return A.sid !== void 0 && (re.sid = A.sid), A.muted !== void 0 && (re.muted = A.muted), re;
    },
    fromPartial(A) {
      var re, le;
      const $e = ue();
      return $e.sid = (re = A.sid) !== null && re !== void 0 ? re : "", $e.muted = (le = A.muted) !== null && le !== void 0 ? le : !1, $e;
    }
  };
  function he() {
    return {
      room: void 0,
      participant: void 0,
      otherParticipants: [],
      serverVersion: "",
      iceServers: [],
      subscriberPrimary: !1,
      alternativeUrl: "",
      clientConfiguration: void 0,
      serverRegion: "",
      pingTimeout: 0,
      pingInterval: 0,
      serverInfo: void 0
    };
  }
  a.JoinResponse = {
    encode(A, re = l.default.Writer.create()) {
      if (A.room !== void 0 && v.Room.encode(A.room, re.uint32(10).fork()).ldelim(), A.participant !== void 0 && v.ParticipantInfo.encode(A.participant, re.uint32(18).fork()).ldelim(), A.otherParticipants !== void 0 && A.otherParticipants.length !== 0)
        for (const le of A.otherParticipants)
          v.ParticipantInfo.encode(le, re.uint32(26).fork()).ldelim();
      if (A.serverVersion !== void 0 && A.serverVersion !== "" && re.uint32(34).string(A.serverVersion), A.iceServers !== void 0 && A.iceServers.length !== 0)
        for (const le of A.iceServers)
          a.ICEServer.encode(le, re.uint32(42).fork()).ldelim();
      return A.subscriberPrimary === !0 && re.uint32(48).bool(A.subscriberPrimary), A.alternativeUrl !== void 0 && A.alternativeUrl !== "" && re.uint32(58).string(A.alternativeUrl), A.clientConfiguration !== void 0 && v.ClientConfiguration.encode(A.clientConfiguration, re.uint32(66).fork()).ldelim(), A.serverRegion !== void 0 && A.serverRegion !== "" && re.uint32(74).string(A.serverRegion), A.pingTimeout !== void 0 && A.pingTimeout !== 0 && re.uint32(80).int32(A.pingTimeout), A.pingInterval !== void 0 && A.pingInterval !== 0 && re.uint32(88).int32(A.pingInterval), A.serverInfo !== void 0 && v.ServerInfo.encode(A.serverInfo, re.uint32(98).fork()).ldelim(), re;
    },
    decode(A, re) {
      const le = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let $e = re === void 0 ? le.len : le.pos + re;
      const Oe = he();
      for (; le.pos < $e; ) {
        const Fe = le.uint32();
        switch (Fe >>> 3) {
          case 1:
            Oe.room = v.Room.decode(le, le.uint32());
            break;
          case 2:
            Oe.participant = v.ParticipantInfo.decode(le, le.uint32());
            break;
          case 3:
            Oe.otherParticipants.push(v.ParticipantInfo.decode(le, le.uint32()));
            break;
          case 4:
            Oe.serverVersion = le.string();
            break;
          case 5:
            Oe.iceServers.push(a.ICEServer.decode(le, le.uint32()));
            break;
          case 6:
            Oe.subscriberPrimary = le.bool();
            break;
          case 7:
            Oe.alternativeUrl = le.string();
            break;
          case 8:
            Oe.clientConfiguration = v.ClientConfiguration.decode(le, le.uint32());
            break;
          case 9:
            Oe.serverRegion = le.string();
            break;
          case 10:
            Oe.pingTimeout = le.int32();
            break;
          case 11:
            Oe.pingInterval = le.int32();
            break;
          case 12:
            Oe.serverInfo = v.ServerInfo.decode(le, le.uint32());
            break;
          default:
            le.skipType(Fe & 7);
            break;
        }
      }
      return Oe;
    },
    fromJSON(A) {
      return {
        room: oe(A.room) ? v.Room.fromJSON(A.room) : void 0,
        participant: oe(A.participant) ? v.ParticipantInfo.fromJSON(A.participant) : void 0,
        otherParticipants: Array.isArray(A == null ? void 0 : A.otherParticipants) ? A.otherParticipants.map((re) => v.ParticipantInfo.fromJSON(re)) : [],
        serverVersion: oe(A.serverVersion) ? String(A.serverVersion) : "",
        iceServers: Array.isArray(A == null ? void 0 : A.iceServers) ? A.iceServers.map((re) => a.ICEServer.fromJSON(re)) : [],
        subscriberPrimary: oe(A.subscriberPrimary) ? !!A.subscriberPrimary : !1,
        alternativeUrl: oe(A.alternativeUrl) ? String(A.alternativeUrl) : "",
        clientConfiguration: oe(A.clientConfiguration) ? v.ClientConfiguration.fromJSON(A.clientConfiguration) : void 0,
        serverRegion: oe(A.serverRegion) ? String(A.serverRegion) : "",
        pingTimeout: oe(A.pingTimeout) ? Number(A.pingTimeout) : 0,
        pingInterval: oe(A.pingInterval) ? Number(A.pingInterval) : 0,
        serverInfo: oe(A.serverInfo) ? v.ServerInfo.fromJSON(A.serverInfo) : void 0
      };
    },
    toJSON(A) {
      const re = {};
      return A.room !== void 0 && (re.room = A.room ? v.Room.toJSON(A.room) : void 0), A.participant !== void 0 && (re.participant = A.participant ? v.ParticipantInfo.toJSON(A.participant) : void 0), A.otherParticipants ? re.otherParticipants = A.otherParticipants.map((le) => le ? v.ParticipantInfo.toJSON(le) : void 0) : re.otherParticipants = [], A.serverVersion !== void 0 && (re.serverVersion = A.serverVersion), A.iceServers ? re.iceServers = A.iceServers.map((le) => le ? a.ICEServer.toJSON(le) : void 0) : re.iceServers = [], A.subscriberPrimary !== void 0 && (re.subscriberPrimary = A.subscriberPrimary), A.alternativeUrl !== void 0 && (re.alternativeUrl = A.alternativeUrl), A.clientConfiguration !== void 0 && (re.clientConfiguration = A.clientConfiguration ? v.ClientConfiguration.toJSON(A.clientConfiguration) : void 0), A.serverRegion !== void 0 && (re.serverRegion = A.serverRegion), A.pingTimeout !== void 0 && (re.pingTimeout = Math.round(A.pingTimeout)), A.pingInterval !== void 0 && (re.pingInterval = Math.round(A.pingInterval)), A.serverInfo !== void 0 && (re.serverInfo = A.serverInfo ? v.ServerInfo.toJSON(A.serverInfo) : void 0), re;
    },
    fromPartial(A) {
      var re, le, $e, Oe, Fe, Ze, qe, yt;
      const Xe = he();
      return Xe.room = A.room !== void 0 && A.room !== null ? v.Room.fromPartial(A.room) : void 0, Xe.participant = A.participant !== void 0 && A.participant !== null ? v.ParticipantInfo.fromPartial(A.participant) : void 0, Xe.otherParticipants = ((re = A.otherParticipants) === null || re === void 0 ? void 0 : re.map((Ge) => v.ParticipantInfo.fromPartial(Ge))) || [], Xe.serverVersion = (le = A.serverVersion) !== null && le !== void 0 ? le : "", Xe.iceServers = (($e = A.iceServers) === null || $e === void 0 ? void 0 : $e.map((Ge) => a.ICEServer.fromPartial(Ge))) || [], Xe.subscriberPrimary = (Oe = A.subscriberPrimary) !== null && Oe !== void 0 ? Oe : !1, Xe.alternativeUrl = (Fe = A.alternativeUrl) !== null && Fe !== void 0 ? Fe : "", Xe.clientConfiguration = A.clientConfiguration !== void 0 && A.clientConfiguration !== null ? v.ClientConfiguration.fromPartial(A.clientConfiguration) : void 0, Xe.serverRegion = (Ze = A.serverRegion) !== null && Ze !== void 0 ? Ze : "", Xe.pingTimeout = (qe = A.pingTimeout) !== null && qe !== void 0 ? qe : 0, Xe.pingInterval = (yt = A.pingInterval) !== null && yt !== void 0 ? yt : 0, Xe.serverInfo = A.serverInfo !== void 0 && A.serverInfo !== null ? v.ServerInfo.fromPartial(A.serverInfo) : void 0, Xe;
    }
  };
  function fe() {
    return { cid: "", track: void 0 };
  }
  a.TrackPublishedResponse = {
    encode(A, re = l.default.Writer.create()) {
      return A.cid !== void 0 && A.cid !== "" && re.uint32(10).string(A.cid), A.track !== void 0 && v.TrackInfo.encode(A.track, re.uint32(18).fork()).ldelim(), re;
    },
    decode(A, re) {
      const le = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let $e = re === void 0 ? le.len : le.pos + re;
      const Oe = fe();
      for (; le.pos < $e; ) {
        const Fe = le.uint32();
        switch (Fe >>> 3) {
          case 1:
            Oe.cid = le.string();
            break;
          case 2:
            Oe.track = v.TrackInfo.decode(le, le.uint32());
            break;
          default:
            le.skipType(Fe & 7);
            break;
        }
      }
      return Oe;
    },
    fromJSON(A) {
      return {
        cid: oe(A.cid) ? String(A.cid) : "",
        track: oe(A.track) ? v.TrackInfo.fromJSON(A.track) : void 0
      };
    },
    toJSON(A) {
      const re = {};
      return A.cid !== void 0 && (re.cid = A.cid), A.track !== void 0 && (re.track = A.track ? v.TrackInfo.toJSON(A.track) : void 0), re;
    },
    fromPartial(A) {
      var re;
      const le = fe();
      return le.cid = (re = A.cid) !== null && re !== void 0 ? re : "", le.track = A.track !== void 0 && A.track !== null ? v.TrackInfo.fromPartial(A.track) : void 0, le;
    }
  };
  function be() {
    return { trackSid: "" };
  }
  a.TrackUnpublishedResponse = {
    encode(A, re = l.default.Writer.create()) {
      return A.trackSid !== void 0 && A.trackSid !== "" && re.uint32(10).string(A.trackSid), re;
    },
    decode(A, re) {
      const le = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let $e = re === void 0 ? le.len : le.pos + re;
      const Oe = be();
      for (; le.pos < $e; ) {
        const Fe = le.uint32();
        switch (Fe >>> 3) {
          case 1:
            Oe.trackSid = le.string();
            break;
          default:
            le.skipType(Fe & 7);
            break;
        }
      }
      return Oe;
    },
    fromJSON(A) {
      return { trackSid: oe(A.trackSid) ? String(A.trackSid) : "" };
    },
    toJSON(A) {
      const re = {};
      return A.trackSid !== void 0 && (re.trackSid = A.trackSid), re;
    },
    fromPartial(A) {
      var re;
      const le = be();
      return le.trackSid = (re = A.trackSid) !== null && re !== void 0 ? re : "", le;
    }
  };
  function ke() {
    return { type: "", sdp: "" };
  }
  a.SessionDescription = {
    encode(A, re = l.default.Writer.create()) {
      return A.type !== void 0 && A.type !== "" && re.uint32(10).string(A.type), A.sdp !== void 0 && A.sdp !== "" && re.uint32(18).string(A.sdp), re;
    },
    decode(A, re) {
      const le = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let $e = re === void 0 ? le.len : le.pos + re;
      const Oe = ke();
      for (; le.pos < $e; ) {
        const Fe = le.uint32();
        switch (Fe >>> 3) {
          case 1:
            Oe.type = le.string();
            break;
          case 2:
            Oe.sdp = le.string();
            break;
          default:
            le.skipType(Fe & 7);
            break;
        }
      }
      return Oe;
    },
    fromJSON(A) {
      return { type: oe(A.type) ? String(A.type) : "", sdp: oe(A.sdp) ? String(A.sdp) : "" };
    },
    toJSON(A) {
      const re = {};
      return A.type !== void 0 && (re.type = A.type), A.sdp !== void 0 && (re.sdp = A.sdp), re;
    },
    fromPartial(A) {
      var re, le;
      const $e = ke();
      return $e.type = (re = A.type) !== null && re !== void 0 ? re : "", $e.sdp = (le = A.sdp) !== null && le !== void 0 ? le : "", $e;
    }
  };
  function Te() {
    return { participants: [] };
  }
  a.ParticipantUpdate = {
    encode(A, re = l.default.Writer.create()) {
      if (A.participants !== void 0 && A.participants.length !== 0)
        for (const le of A.participants)
          v.ParticipantInfo.encode(le, re.uint32(10).fork()).ldelim();
      return re;
    },
    decode(A, re) {
      const le = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let $e = re === void 0 ? le.len : le.pos + re;
      const Oe = Te();
      for (; le.pos < $e; ) {
        const Fe = le.uint32();
        switch (Fe >>> 3) {
          case 1:
            Oe.participants.push(v.ParticipantInfo.decode(le, le.uint32()));
            break;
          default:
            le.skipType(Fe & 7);
            break;
        }
      }
      return Oe;
    },
    fromJSON(A) {
      return {
        participants: Array.isArray(A == null ? void 0 : A.participants) ? A.participants.map((re) => v.ParticipantInfo.fromJSON(re)) : []
      };
    },
    toJSON(A) {
      const re = {};
      return A.participants ? re.participants = A.participants.map((le) => le ? v.ParticipantInfo.toJSON(le) : void 0) : re.participants = [], re;
    },
    fromPartial(A) {
      var re;
      const le = Te();
      return le.participants = ((re = A.participants) === null || re === void 0 ? void 0 : re.map(($e) => v.ParticipantInfo.fromPartial($e))) || [], le;
    }
  };
  function q() {
    return { trackSids: [], subscribe: !1, participantTracks: [] };
  }
  a.UpdateSubscription = {
    encode(A, re = l.default.Writer.create()) {
      if (A.trackSids !== void 0 && A.trackSids.length !== 0)
        for (const le of A.trackSids)
          re.uint32(10).string(le);
      if (A.subscribe === !0 && re.uint32(16).bool(A.subscribe), A.participantTracks !== void 0 && A.participantTracks.length !== 0)
        for (const le of A.participantTracks)
          v.ParticipantTracks.encode(le, re.uint32(26).fork()).ldelim();
      return re;
    },
    decode(A, re) {
      const le = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let $e = re === void 0 ? le.len : le.pos + re;
      const Oe = q();
      for (; le.pos < $e; ) {
        const Fe = le.uint32();
        switch (Fe >>> 3) {
          case 1:
            Oe.trackSids.push(le.string());
            break;
          case 2:
            Oe.subscribe = le.bool();
            break;
          case 3:
            Oe.participantTracks.push(v.ParticipantTracks.decode(le, le.uint32()));
            break;
          default:
            le.skipType(Fe & 7);
            break;
        }
      }
      return Oe;
    },
    fromJSON(A) {
      return {
        trackSids: Array.isArray(A == null ? void 0 : A.trackSids) ? A.trackSids.map((re) => String(re)) : [],
        subscribe: oe(A.subscribe) ? !!A.subscribe : !1,
        participantTracks: Array.isArray(A == null ? void 0 : A.participantTracks) ? A.participantTracks.map((re) => v.ParticipantTracks.fromJSON(re)) : []
      };
    },
    toJSON(A) {
      const re = {};
      return A.trackSids ? re.trackSids = A.trackSids.map((le) => le) : re.trackSids = [], A.subscribe !== void 0 && (re.subscribe = A.subscribe), A.participantTracks ? re.participantTracks = A.participantTracks.map((le) => le ? v.ParticipantTracks.toJSON(le) : void 0) : re.participantTracks = [], re;
    },
    fromPartial(A) {
      var re, le, $e;
      const Oe = q();
      return Oe.trackSids = ((re = A.trackSids) === null || re === void 0 ? void 0 : re.map((Fe) => Fe)) || [], Oe.subscribe = (le = A.subscribe) !== null && le !== void 0 ? le : !1, Oe.participantTracks = (($e = A.participantTracks) === null || $e === void 0 ? void 0 : $e.map((Fe) => v.ParticipantTracks.fromPartial(Fe))) || [], Oe;
    }
  };
  function z() {
    return { trackSids: [], disabled: !1, quality: 0, width: 0, height: 0, fps: 0 };
  }
  a.UpdateTrackSettings = {
    encode(A, re = l.default.Writer.create()) {
      if (A.trackSids !== void 0 && A.trackSids.length !== 0)
        for (const le of A.trackSids)
          re.uint32(10).string(le);
      return A.disabled === !0 && re.uint32(24).bool(A.disabled), A.quality !== void 0 && A.quality !== 0 && re.uint32(32).int32(A.quality), A.width !== void 0 && A.width !== 0 && re.uint32(40).uint32(A.width), A.height !== void 0 && A.height !== 0 && re.uint32(48).uint32(A.height), A.fps !== void 0 && A.fps !== 0 && re.uint32(56).uint32(A.fps), re;
    },
    decode(A, re) {
      const le = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let $e = re === void 0 ? le.len : le.pos + re;
      const Oe = z();
      for (; le.pos < $e; ) {
        const Fe = le.uint32();
        switch (Fe >>> 3) {
          case 1:
            Oe.trackSids.push(le.string());
            break;
          case 3:
            Oe.disabled = le.bool();
            break;
          case 4:
            Oe.quality = le.int32();
            break;
          case 5:
            Oe.width = le.uint32();
            break;
          case 6:
            Oe.height = le.uint32();
            break;
          case 7:
            Oe.fps = le.uint32();
            break;
          default:
            le.skipType(Fe & 7);
            break;
        }
      }
      return Oe;
    },
    fromJSON(A) {
      return {
        trackSids: Array.isArray(A == null ? void 0 : A.trackSids) ? A.trackSids.map((re) => String(re)) : [],
        disabled: oe(A.disabled) ? !!A.disabled : !1,
        quality: oe(A.quality) ? v.videoQualityFromJSON(A.quality) : 0,
        width: oe(A.width) ? Number(A.width) : 0,
        height: oe(A.height) ? Number(A.height) : 0,
        fps: oe(A.fps) ? Number(A.fps) : 0
      };
    },
    toJSON(A) {
      const re = {};
      return A.trackSids ? re.trackSids = A.trackSids.map((le) => le) : re.trackSids = [], A.disabled !== void 0 && (re.disabled = A.disabled), A.quality !== void 0 && (re.quality = v.videoQualityToJSON(A.quality)), A.width !== void 0 && (re.width = Math.round(A.width)), A.height !== void 0 && (re.height = Math.round(A.height)), A.fps !== void 0 && (re.fps = Math.round(A.fps)), re;
    },
    fromPartial(A) {
      var re, le, $e, Oe, Fe, Ze;
      const qe = z();
      return qe.trackSids = ((re = A.trackSids) === null || re === void 0 ? void 0 : re.map((yt) => yt)) || [], qe.disabled = (le = A.disabled) !== null && le !== void 0 ? le : !1, qe.quality = ($e = A.quality) !== null && $e !== void 0 ? $e : 0, qe.width = (Oe = A.width) !== null && Oe !== void 0 ? Oe : 0, qe.height = (Fe = A.height) !== null && Fe !== void 0 ? Fe : 0, qe.fps = (Ze = A.fps) !== null && Ze !== void 0 ? Ze : 0, qe;
    }
  };
  function P() {
    return { canReconnect: !1, reason: 0 };
  }
  a.LeaveRequest = {
    encode(A, re = l.default.Writer.create()) {
      return A.canReconnect === !0 && re.uint32(8).bool(A.canReconnect), A.reason !== void 0 && A.reason !== 0 && re.uint32(16).int32(A.reason), re;
    },
    decode(A, re) {
      const le = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let $e = re === void 0 ? le.len : le.pos + re;
      const Oe = P();
      for (; le.pos < $e; ) {
        const Fe = le.uint32();
        switch (Fe >>> 3) {
          case 1:
            Oe.canReconnect = le.bool();
            break;
          case 2:
            Oe.reason = le.int32();
            break;
          default:
            le.skipType(Fe & 7);
            break;
        }
      }
      return Oe;
    },
    fromJSON(A) {
      return {
        canReconnect: oe(A.canReconnect) ? !!A.canReconnect : !1,
        reason: oe(A.reason) ? v.disconnectReasonFromJSON(A.reason) : 0
      };
    },
    toJSON(A) {
      const re = {};
      return A.canReconnect !== void 0 && (re.canReconnect = A.canReconnect), A.reason !== void 0 && (re.reason = v.disconnectReasonToJSON(A.reason)), re;
    },
    fromPartial(A) {
      var re, le;
      const $e = P();
      return $e.canReconnect = (re = A.canReconnect) !== null && re !== void 0 ? re : !1, $e.reason = (le = A.reason) !== null && le !== void 0 ? le : 0, $e;
    }
  };
  function S() {
    return { trackSid: "", layers: [] };
  }
  a.UpdateVideoLayers = {
    encode(A, re = l.default.Writer.create()) {
      if (A.trackSid !== void 0 && A.trackSid !== "" && re.uint32(10).string(A.trackSid), A.layers !== void 0 && A.layers.length !== 0)
        for (const le of A.layers)
          v.VideoLayer.encode(le, re.uint32(18).fork()).ldelim();
      return re;
    },
    decode(A, re) {
      const le = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let $e = re === void 0 ? le.len : le.pos + re;
      const Oe = S();
      for (; le.pos < $e; ) {
        const Fe = le.uint32();
        switch (Fe >>> 3) {
          case 1:
            Oe.trackSid = le.string();
            break;
          case 2:
            Oe.layers.push(v.VideoLayer.decode(le, le.uint32()));
            break;
          default:
            le.skipType(Fe & 7);
            break;
        }
      }
      return Oe;
    },
    fromJSON(A) {
      return {
        trackSid: oe(A.trackSid) ? String(A.trackSid) : "",
        layers: Array.isArray(A == null ? void 0 : A.layers) ? A.layers.map((re) => v.VideoLayer.fromJSON(re)) : []
      };
    },
    toJSON(A) {
      const re = {};
      return A.trackSid !== void 0 && (re.trackSid = A.trackSid), A.layers ? re.layers = A.layers.map((le) => le ? v.VideoLayer.toJSON(le) : void 0) : re.layers = [], re;
    },
    fromPartial(A) {
      var re, le;
      const $e = S();
      return $e.trackSid = (re = A.trackSid) !== null && re !== void 0 ? re : "", $e.layers = ((le = A.layers) === null || le === void 0 ? void 0 : le.map((Oe) => v.VideoLayer.fromPartial(Oe))) || [], $e;
    }
  };
  function E() {
    return { urls: [], username: "", credential: "" };
  }
  a.ICEServer = {
    encode(A, re = l.default.Writer.create()) {
      if (A.urls !== void 0 && A.urls.length !== 0)
        for (const le of A.urls)
          re.uint32(10).string(le);
      return A.username !== void 0 && A.username !== "" && re.uint32(18).string(A.username), A.credential !== void 0 && A.credential !== "" && re.uint32(26).string(A.credential), re;
    },
    decode(A, re) {
      const le = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let $e = re === void 0 ? le.len : le.pos + re;
      const Oe = E();
      for (; le.pos < $e; ) {
        const Fe = le.uint32();
        switch (Fe >>> 3) {
          case 1:
            Oe.urls.push(le.string());
            break;
          case 2:
            Oe.username = le.string();
            break;
          case 3:
            Oe.credential = le.string();
            break;
          default:
            le.skipType(Fe & 7);
            break;
        }
      }
      return Oe;
    },
    fromJSON(A) {
      return {
        urls: Array.isArray(A == null ? void 0 : A.urls) ? A.urls.map((re) => String(re)) : [],
        username: oe(A.username) ? String(A.username) : "",
        credential: oe(A.credential) ? String(A.credential) : ""
      };
    },
    toJSON(A) {
      const re = {};
      return A.urls ? re.urls = A.urls.map((le) => le) : re.urls = [], A.username !== void 0 && (re.username = A.username), A.credential !== void 0 && (re.credential = A.credential), re;
    },
    fromPartial(A) {
      var re, le, $e;
      const Oe = E();
      return Oe.urls = ((re = A.urls) === null || re === void 0 ? void 0 : re.map((Fe) => Fe)) || [], Oe.username = (le = A.username) !== null && le !== void 0 ? le : "", Oe.credential = ($e = A.credential) !== null && $e !== void 0 ? $e : "", Oe;
    }
  };
  function I() {
    return { speakers: [] };
  }
  a.SpeakersChanged = {
    encode(A, re = l.default.Writer.create()) {
      if (A.speakers !== void 0 && A.speakers.length !== 0)
        for (const le of A.speakers)
          v.SpeakerInfo.encode(le, re.uint32(10).fork()).ldelim();
      return re;
    },
    decode(A, re) {
      const le = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let $e = re === void 0 ? le.len : le.pos + re;
      const Oe = I();
      for (; le.pos < $e; ) {
        const Fe = le.uint32();
        switch (Fe >>> 3) {
          case 1:
            Oe.speakers.push(v.SpeakerInfo.decode(le, le.uint32()));
            break;
          default:
            le.skipType(Fe & 7);
            break;
        }
      }
      return Oe;
    },
    fromJSON(A) {
      return {
        speakers: Array.isArray(A == null ? void 0 : A.speakers) ? A.speakers.map((re) => v.SpeakerInfo.fromJSON(re)) : []
      };
    },
    toJSON(A) {
      const re = {};
      return A.speakers ? re.speakers = A.speakers.map((le) => le ? v.SpeakerInfo.toJSON(le) : void 0) : re.speakers = [], re;
    },
    fromPartial(A) {
      var re;
      const le = I();
      return le.speakers = ((re = A.speakers) === null || re === void 0 ? void 0 : re.map(($e) => v.SpeakerInfo.fromPartial($e))) || [], le;
    }
  };
  function M() {
    return { room: void 0 };
  }
  a.RoomUpdate = {
    encode(A, re = l.default.Writer.create()) {
      return A.room !== void 0 && v.Room.encode(A.room, re.uint32(10).fork()).ldelim(), re;
    },
    decode(A, re) {
      const le = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let $e = re === void 0 ? le.len : le.pos + re;
      const Oe = M();
      for (; le.pos < $e; ) {
        const Fe = le.uint32();
        switch (Fe >>> 3) {
          case 1:
            Oe.room = v.Room.decode(le, le.uint32());
            break;
          default:
            le.skipType(Fe & 7);
            break;
        }
      }
      return Oe;
    },
    fromJSON(A) {
      return { room: oe(A.room) ? v.Room.fromJSON(A.room) : void 0 };
    },
    toJSON(A) {
      const re = {};
      return A.room !== void 0 && (re.room = A.room ? v.Room.toJSON(A.room) : void 0), re;
    },
    fromPartial(A) {
      const re = M();
      return re.room = A.room !== void 0 && A.room !== null ? v.Room.fromPartial(A.room) : void 0, re;
    }
  };
  function $() {
    return { participantSid: "", quality: 0, score: 0 };
  }
  a.ConnectionQualityInfo = {
    encode(A, re = l.default.Writer.create()) {
      return A.participantSid !== void 0 && A.participantSid !== "" && re.uint32(10).string(A.participantSid), A.quality !== void 0 && A.quality !== 0 && re.uint32(16).int32(A.quality), A.score !== void 0 && A.score !== 0 && re.uint32(29).float(A.score), re;
    },
    decode(A, re) {
      const le = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let $e = re === void 0 ? le.len : le.pos + re;
      const Oe = $();
      for (; le.pos < $e; ) {
        const Fe = le.uint32();
        switch (Fe >>> 3) {
          case 1:
            Oe.participantSid = le.string();
            break;
          case 2:
            Oe.quality = le.int32();
            break;
          case 3:
            Oe.score = le.float();
            break;
          default:
            le.skipType(Fe & 7);
            break;
        }
      }
      return Oe;
    },
    fromJSON(A) {
      return {
        participantSid: oe(A.participantSid) ? String(A.participantSid) : "",
        quality: oe(A.quality) ? v.connectionQualityFromJSON(A.quality) : 0,
        score: oe(A.score) ? Number(A.score) : 0
      };
    },
    toJSON(A) {
      const re = {};
      return A.participantSid !== void 0 && (re.participantSid = A.participantSid), A.quality !== void 0 && (re.quality = v.connectionQualityToJSON(A.quality)), A.score !== void 0 && (re.score = A.score), re;
    },
    fromPartial(A) {
      var re, le, $e;
      const Oe = $();
      return Oe.participantSid = (re = A.participantSid) !== null && re !== void 0 ? re : "", Oe.quality = (le = A.quality) !== null && le !== void 0 ? le : 0, Oe.score = ($e = A.score) !== null && $e !== void 0 ? $e : 0, Oe;
    }
  };
  function U() {
    return { updates: [] };
  }
  a.ConnectionQualityUpdate = {
    encode(A, re = l.default.Writer.create()) {
      if (A.updates !== void 0 && A.updates.length !== 0)
        for (const le of A.updates)
          a.ConnectionQualityInfo.encode(le, re.uint32(10).fork()).ldelim();
      return re;
    },
    decode(A, re) {
      const le = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let $e = re === void 0 ? le.len : le.pos + re;
      const Oe = U();
      for (; le.pos < $e; ) {
        const Fe = le.uint32();
        switch (Fe >>> 3) {
          case 1:
            Oe.updates.push(a.ConnectionQualityInfo.decode(le, le.uint32()));
            break;
          default:
            le.skipType(Fe & 7);
            break;
        }
      }
      return Oe;
    },
    fromJSON(A) {
      return {
        updates: Array.isArray(A == null ? void 0 : A.updates) ? A.updates.map((re) => a.ConnectionQualityInfo.fromJSON(re)) : []
      };
    },
    toJSON(A) {
      const re = {};
      return A.updates ? re.updates = A.updates.map((le) => le ? a.ConnectionQualityInfo.toJSON(le) : void 0) : re.updates = [], re;
    },
    fromPartial(A) {
      var re;
      const le = U();
      return le.updates = ((re = A.updates) === null || re === void 0 ? void 0 : re.map(($e) => a.ConnectionQualityInfo.fromPartial($e))) || [], le;
    }
  };
  function Y() {
    return { participantSid: "", trackSid: "", state: 0 };
  }
  a.StreamStateInfo = {
    encode(A, re = l.default.Writer.create()) {
      return A.participantSid !== void 0 && A.participantSid !== "" && re.uint32(10).string(A.participantSid), A.trackSid !== void 0 && A.trackSid !== "" && re.uint32(18).string(A.trackSid), A.state !== void 0 && A.state !== 0 && re.uint32(24).int32(A.state), re;
    },
    decode(A, re) {
      const le = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let $e = re === void 0 ? le.len : le.pos + re;
      const Oe = Y();
      for (; le.pos < $e; ) {
        const Fe = le.uint32();
        switch (Fe >>> 3) {
          case 1:
            Oe.participantSid = le.string();
            break;
          case 2:
            Oe.trackSid = le.string();
            break;
          case 3:
            Oe.state = le.int32();
            break;
          default:
            le.skipType(Fe & 7);
            break;
        }
      }
      return Oe;
    },
    fromJSON(A) {
      return {
        participantSid: oe(A.participantSid) ? String(A.participantSid) : "",
        trackSid: oe(A.trackSid) ? String(A.trackSid) : "",
        state: oe(A.state) ? D(A.state) : 0
      };
    },
    toJSON(A) {
      const re = {};
      return A.participantSid !== void 0 && (re.participantSid = A.participantSid), A.trackSid !== void 0 && (re.trackSid = A.trackSid), A.state !== void 0 && (re.state = F(A.state)), re;
    },
    fromPartial(A) {
      var re, le, $e;
      const Oe = Y();
      return Oe.participantSid = (re = A.participantSid) !== null && re !== void 0 ? re : "", Oe.trackSid = (le = A.trackSid) !== null && le !== void 0 ? le : "", Oe.state = ($e = A.state) !== null && $e !== void 0 ? $e : 0, Oe;
    }
  };
  function B() {
    return { streamStates: [] };
  }
  a.StreamStateUpdate = {
    encode(A, re = l.default.Writer.create()) {
      if (A.streamStates !== void 0 && A.streamStates.length !== 0)
        for (const le of A.streamStates)
          a.StreamStateInfo.encode(le, re.uint32(10).fork()).ldelim();
      return re;
    },
    decode(A, re) {
      const le = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let $e = re === void 0 ? le.len : le.pos + re;
      const Oe = B();
      for (; le.pos < $e; ) {
        const Fe = le.uint32();
        switch (Fe >>> 3) {
          case 1:
            Oe.streamStates.push(a.StreamStateInfo.decode(le, le.uint32()));
            break;
          default:
            le.skipType(Fe & 7);
            break;
        }
      }
      return Oe;
    },
    fromJSON(A) {
      return {
        streamStates: Array.isArray(A == null ? void 0 : A.streamStates) ? A.streamStates.map((re) => a.StreamStateInfo.fromJSON(re)) : []
      };
    },
    toJSON(A) {
      const re = {};
      return A.streamStates ? re.streamStates = A.streamStates.map((le) => le ? a.StreamStateInfo.toJSON(le) : void 0) : re.streamStates = [], re;
    },
    fromPartial(A) {
      var re;
      const le = B();
      return le.streamStates = ((re = A.streamStates) === null || re === void 0 ? void 0 : re.map(($e) => a.StreamStateInfo.fromPartial($e))) || [], le;
    }
  };
  function T() {
    return { quality: 0, enabled: !1 };
  }
  a.SubscribedQuality = {
    encode(A, re = l.default.Writer.create()) {
      return A.quality !== void 0 && A.quality !== 0 && re.uint32(8).int32(A.quality), A.enabled === !0 && re.uint32(16).bool(A.enabled), re;
    },
    decode(A, re) {
      const le = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let $e = re === void 0 ? le.len : le.pos + re;
      const Oe = T();
      for (; le.pos < $e; ) {
        const Fe = le.uint32();
        switch (Fe >>> 3) {
          case 1:
            Oe.quality = le.int32();
            break;
          case 2:
            Oe.enabled = le.bool();
            break;
          default:
            le.skipType(Fe & 7);
            break;
        }
      }
      return Oe;
    },
    fromJSON(A) {
      return {
        quality: oe(A.quality) ? v.videoQualityFromJSON(A.quality) : 0,
        enabled: oe(A.enabled) ? !!A.enabled : !1
      };
    },
    toJSON(A) {
      const re = {};
      return A.quality !== void 0 && (re.quality = v.videoQualityToJSON(A.quality)), A.enabled !== void 0 && (re.enabled = A.enabled), re;
    },
    fromPartial(A) {
      var re, le;
      const $e = T();
      return $e.quality = (re = A.quality) !== null && re !== void 0 ? re : 0, $e.enabled = (le = A.enabled) !== null && le !== void 0 ? le : !1, $e;
    }
  };
  function L() {
    return { codec: "", qualities: [] };
  }
  a.SubscribedCodec = {
    encode(A, re = l.default.Writer.create()) {
      if (A.codec !== void 0 && A.codec !== "" && re.uint32(10).string(A.codec), A.qualities !== void 0 && A.qualities.length !== 0)
        for (const le of A.qualities)
          a.SubscribedQuality.encode(le, re.uint32(18).fork()).ldelim();
      return re;
    },
    decode(A, re) {
      const le = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let $e = re === void 0 ? le.len : le.pos + re;
      const Oe = L();
      for (; le.pos < $e; ) {
        const Fe = le.uint32();
        switch (Fe >>> 3) {
          case 1:
            Oe.codec = le.string();
            break;
          case 2:
            Oe.qualities.push(a.SubscribedQuality.decode(le, le.uint32()));
            break;
          default:
            le.skipType(Fe & 7);
            break;
        }
      }
      return Oe;
    },
    fromJSON(A) {
      return {
        codec: oe(A.codec) ? String(A.codec) : "",
        qualities: Array.isArray(A == null ? void 0 : A.qualities) ? A.qualities.map((re) => a.SubscribedQuality.fromJSON(re)) : []
      };
    },
    toJSON(A) {
      const re = {};
      return A.codec !== void 0 && (re.codec = A.codec), A.qualities ? re.qualities = A.qualities.map((le) => le ? a.SubscribedQuality.toJSON(le) : void 0) : re.qualities = [], re;
    },
    fromPartial(A) {
      var re, le;
      const $e = L();
      return $e.codec = (re = A.codec) !== null && re !== void 0 ? re : "", $e.qualities = ((le = A.qualities) === null || le === void 0 ? void 0 : le.map((Oe) => a.SubscribedQuality.fromPartial(Oe))) || [], $e;
    }
  };
  function te() {
    return { trackSid: "", subscribedQualities: [], subscribedCodecs: [] };
  }
  a.SubscribedQualityUpdate = {
    encode(A, re = l.default.Writer.create()) {
      if (A.trackSid !== void 0 && A.trackSid !== "" && re.uint32(10).string(A.trackSid), A.subscribedQualities !== void 0 && A.subscribedQualities.length !== 0)
        for (const le of A.subscribedQualities)
          a.SubscribedQuality.encode(le, re.uint32(18).fork()).ldelim();
      if (A.subscribedCodecs !== void 0 && A.subscribedCodecs.length !== 0)
        for (const le of A.subscribedCodecs)
          a.SubscribedCodec.encode(le, re.uint32(26).fork()).ldelim();
      return re;
    },
    decode(A, re) {
      const le = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let $e = re === void 0 ? le.len : le.pos + re;
      const Oe = te();
      for (; le.pos < $e; ) {
        const Fe = le.uint32();
        switch (Fe >>> 3) {
          case 1:
            Oe.trackSid = le.string();
            break;
          case 2:
            Oe.subscribedQualities.push(a.SubscribedQuality.decode(le, le.uint32()));
            break;
          case 3:
            Oe.subscribedCodecs.push(a.SubscribedCodec.decode(le, le.uint32()));
            break;
          default:
            le.skipType(Fe & 7);
            break;
        }
      }
      return Oe;
    },
    fromJSON(A) {
      return {
        trackSid: oe(A.trackSid) ? String(A.trackSid) : "",
        subscribedQualities: Array.isArray(A == null ? void 0 : A.subscribedQualities) ? A.subscribedQualities.map((re) => a.SubscribedQuality.fromJSON(re)) : [],
        subscribedCodecs: Array.isArray(A == null ? void 0 : A.subscribedCodecs) ? A.subscribedCodecs.map((re) => a.SubscribedCodec.fromJSON(re)) : []
      };
    },
    toJSON(A) {
      const re = {};
      return A.trackSid !== void 0 && (re.trackSid = A.trackSid), A.subscribedQualities ? re.subscribedQualities = A.subscribedQualities.map((le) => le ? a.SubscribedQuality.toJSON(le) : void 0) : re.subscribedQualities = [], A.subscribedCodecs ? re.subscribedCodecs = A.subscribedCodecs.map((le) => le ? a.SubscribedCodec.toJSON(le) : void 0) : re.subscribedCodecs = [], re;
    },
    fromPartial(A) {
      var re, le, $e;
      const Oe = te();
      return Oe.trackSid = (re = A.trackSid) !== null && re !== void 0 ? re : "", Oe.subscribedQualities = ((le = A.subscribedQualities) === null || le === void 0 ? void 0 : le.map((Fe) => a.SubscribedQuality.fromPartial(Fe))) || [], Oe.subscribedCodecs = (($e = A.subscribedCodecs) === null || $e === void 0 ? void 0 : $e.map((Fe) => a.SubscribedCodec.fromPartial(Fe))) || [], Oe;
    }
  };
  function me() {
    return { participantSid: "", allTracks: !1, trackSids: [], participantIdentity: "" };
  }
  a.TrackPermission = {
    encode(A, re = l.default.Writer.create()) {
      if (A.participantSid !== void 0 && A.participantSid !== "" && re.uint32(10).string(A.participantSid), A.allTracks === !0 && re.uint32(16).bool(A.allTracks), A.trackSids !== void 0 && A.trackSids.length !== 0)
        for (const le of A.trackSids)
          re.uint32(26).string(le);
      return A.participantIdentity !== void 0 && A.participantIdentity !== "" && re.uint32(34).string(A.participantIdentity), re;
    },
    decode(A, re) {
      const le = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let $e = re === void 0 ? le.len : le.pos + re;
      const Oe = me();
      for (; le.pos < $e; ) {
        const Fe = le.uint32();
        switch (Fe >>> 3) {
          case 1:
            Oe.participantSid = le.string();
            break;
          case 2:
            Oe.allTracks = le.bool();
            break;
          case 3:
            Oe.trackSids.push(le.string());
            break;
          case 4:
            Oe.participantIdentity = le.string();
            break;
          default:
            le.skipType(Fe & 7);
            break;
        }
      }
      return Oe;
    },
    fromJSON(A) {
      return {
        participantSid: oe(A.participantSid) ? String(A.participantSid) : "",
        allTracks: oe(A.allTracks) ? !!A.allTracks : !1,
        trackSids: Array.isArray(A == null ? void 0 : A.trackSids) ? A.trackSids.map((re) => String(re)) : [],
        participantIdentity: oe(A.participantIdentity) ? String(A.participantIdentity) : ""
      };
    },
    toJSON(A) {
      const re = {};
      return A.participantSid !== void 0 && (re.participantSid = A.participantSid), A.allTracks !== void 0 && (re.allTracks = A.allTracks), A.trackSids ? re.trackSids = A.trackSids.map((le) => le) : re.trackSids = [], A.participantIdentity !== void 0 && (re.participantIdentity = A.participantIdentity), re;
    },
    fromPartial(A) {
      var re, le, $e, Oe;
      const Fe = me();
      return Fe.participantSid = (re = A.participantSid) !== null && re !== void 0 ? re : "", Fe.allTracks = (le = A.allTracks) !== null && le !== void 0 ? le : !1, Fe.trackSids = (($e = A.trackSids) === null || $e === void 0 ? void 0 : $e.map((Ze) => Ze)) || [], Fe.participantIdentity = (Oe = A.participantIdentity) !== null && Oe !== void 0 ? Oe : "", Fe;
    }
  };
  function Ce() {
    return { allParticipants: !1, trackPermissions: [] };
  }
  a.SubscriptionPermission = {
    encode(A, re = l.default.Writer.create()) {
      if (A.allParticipants === !0 && re.uint32(8).bool(A.allParticipants), A.trackPermissions !== void 0 && A.trackPermissions.length !== 0)
        for (const le of A.trackPermissions)
          a.TrackPermission.encode(le, re.uint32(18).fork()).ldelim();
      return re;
    },
    decode(A, re) {
      const le = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let $e = re === void 0 ? le.len : le.pos + re;
      const Oe = Ce();
      for (; le.pos < $e; ) {
        const Fe = le.uint32();
        switch (Fe >>> 3) {
          case 1:
            Oe.allParticipants = le.bool();
            break;
          case 2:
            Oe.trackPermissions.push(a.TrackPermission.decode(le, le.uint32()));
            break;
          default:
            le.skipType(Fe & 7);
            break;
        }
      }
      return Oe;
    },
    fromJSON(A) {
      return {
        allParticipants: oe(A.allParticipants) ? !!A.allParticipants : !1,
        trackPermissions: Array.isArray(A == null ? void 0 : A.trackPermissions) ? A.trackPermissions.map((re) => a.TrackPermission.fromJSON(re)) : []
      };
    },
    toJSON(A) {
      const re = {};
      return A.allParticipants !== void 0 && (re.allParticipants = A.allParticipants), A.trackPermissions ? re.trackPermissions = A.trackPermissions.map((le) => le ? a.TrackPermission.toJSON(le) : void 0) : re.trackPermissions = [], re;
    },
    fromPartial(A) {
      var re, le;
      const $e = Ce();
      return $e.allParticipants = (re = A.allParticipants) !== null && re !== void 0 ? re : !1, $e.trackPermissions = ((le = A.trackPermissions) === null || le === void 0 ? void 0 : le.map((Oe) => a.TrackPermission.fromPartial(Oe))) || [], $e;
    }
  };
  function De() {
    return { participantSid: "", trackSid: "", allowed: !1 };
  }
  a.SubscriptionPermissionUpdate = {
    encode(A, re = l.default.Writer.create()) {
      return A.participantSid !== void 0 && A.participantSid !== "" && re.uint32(10).string(A.participantSid), A.trackSid !== void 0 && A.trackSid !== "" && re.uint32(18).string(A.trackSid), A.allowed === !0 && re.uint32(24).bool(A.allowed), re;
    },
    decode(A, re) {
      const le = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let $e = re === void 0 ? le.len : le.pos + re;
      const Oe = De();
      for (; le.pos < $e; ) {
        const Fe = le.uint32();
        switch (Fe >>> 3) {
          case 1:
            Oe.participantSid = le.string();
            break;
          case 2:
            Oe.trackSid = le.string();
            break;
          case 3:
            Oe.allowed = le.bool();
            break;
          default:
            le.skipType(Fe & 7);
            break;
        }
      }
      return Oe;
    },
    fromJSON(A) {
      return {
        participantSid: oe(A.participantSid) ? String(A.participantSid) : "",
        trackSid: oe(A.trackSid) ? String(A.trackSid) : "",
        allowed: oe(A.allowed) ? !!A.allowed : !1
      };
    },
    toJSON(A) {
      const re = {};
      return A.participantSid !== void 0 && (re.participantSid = A.participantSid), A.trackSid !== void 0 && (re.trackSid = A.trackSid), A.allowed !== void 0 && (re.allowed = A.allowed), re;
    },
    fromPartial(A) {
      var re, le, $e;
      const Oe = De();
      return Oe.participantSid = (re = A.participantSid) !== null && re !== void 0 ? re : "", Oe.trackSid = (le = A.trackSid) !== null && le !== void 0 ? le : "", Oe.allowed = ($e = A.allowed) !== null && $e !== void 0 ? $e : !1, Oe;
    }
  };
  function ye() {
    return { answer: void 0, subscription: void 0, publishTracks: [], dataChannels: [], offer: void 0 };
  }
  a.SyncState = {
    encode(A, re = l.default.Writer.create()) {
      if (A.answer !== void 0 && a.SessionDescription.encode(A.answer, re.uint32(10).fork()).ldelim(), A.subscription !== void 0 && a.UpdateSubscription.encode(A.subscription, re.uint32(18).fork()).ldelim(), A.publishTracks !== void 0 && A.publishTracks.length !== 0)
        for (const le of A.publishTracks)
          a.TrackPublishedResponse.encode(le, re.uint32(26).fork()).ldelim();
      if (A.dataChannels !== void 0 && A.dataChannels.length !== 0)
        for (const le of A.dataChannels)
          a.DataChannelInfo.encode(le, re.uint32(34).fork()).ldelim();
      return A.offer !== void 0 && a.SessionDescription.encode(A.offer, re.uint32(42).fork()).ldelim(), re;
    },
    decode(A, re) {
      const le = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let $e = re === void 0 ? le.len : le.pos + re;
      const Oe = ye();
      for (; le.pos < $e; ) {
        const Fe = le.uint32();
        switch (Fe >>> 3) {
          case 1:
            Oe.answer = a.SessionDescription.decode(le, le.uint32());
            break;
          case 2:
            Oe.subscription = a.UpdateSubscription.decode(le, le.uint32());
            break;
          case 3:
            Oe.publishTracks.push(a.TrackPublishedResponse.decode(le, le.uint32()));
            break;
          case 4:
            Oe.dataChannels.push(a.DataChannelInfo.decode(le, le.uint32()));
            break;
          case 5:
            Oe.offer = a.SessionDescription.decode(le, le.uint32());
            break;
          default:
            le.skipType(Fe & 7);
            break;
        }
      }
      return Oe;
    },
    fromJSON(A) {
      return {
        answer: oe(A.answer) ? a.SessionDescription.fromJSON(A.answer) : void 0,
        subscription: oe(A.subscription) ? a.UpdateSubscription.fromJSON(A.subscription) : void 0,
        publishTracks: Array.isArray(A == null ? void 0 : A.publishTracks) ? A.publishTracks.map((re) => a.TrackPublishedResponse.fromJSON(re)) : [],
        dataChannels: Array.isArray(A == null ? void 0 : A.dataChannels) ? A.dataChannels.map((re) => a.DataChannelInfo.fromJSON(re)) : [],
        offer: oe(A.offer) ? a.SessionDescription.fromJSON(A.offer) : void 0
      };
    },
    toJSON(A) {
      const re = {};
      return A.answer !== void 0 && (re.answer = A.answer ? a.SessionDescription.toJSON(A.answer) : void 0), A.subscription !== void 0 && (re.subscription = A.subscription ? a.UpdateSubscription.toJSON(A.subscription) : void 0), A.publishTracks ? re.publishTracks = A.publishTracks.map((le) => le ? a.TrackPublishedResponse.toJSON(le) : void 0) : re.publishTracks = [], A.dataChannels ? re.dataChannels = A.dataChannels.map((le) => le ? a.DataChannelInfo.toJSON(le) : void 0) : re.dataChannels = [], A.offer !== void 0 && (re.offer = A.offer ? a.SessionDescription.toJSON(A.offer) : void 0), re;
    },
    fromPartial(A) {
      var re, le;
      const $e = ye();
      return $e.answer = A.answer !== void 0 && A.answer !== null ? a.SessionDescription.fromPartial(A.answer) : void 0, $e.subscription = A.subscription !== void 0 && A.subscription !== null ? a.UpdateSubscription.fromPartial(A.subscription) : void 0, $e.publishTracks = ((re = A.publishTracks) === null || re === void 0 ? void 0 : re.map((Oe) => a.TrackPublishedResponse.fromPartial(Oe))) || [], $e.dataChannels = ((le = A.dataChannels) === null || le === void 0 ? void 0 : le.map((Oe) => a.DataChannelInfo.fromPartial(Oe))) || [], $e.offer = A.offer !== void 0 && A.offer !== null ? a.SessionDescription.fromPartial(A.offer) : void 0, $e;
    }
  };
  function pe() {
    return { label: "", id: 0, target: 0 };
  }
  a.DataChannelInfo = {
    encode(A, re = l.default.Writer.create()) {
      return A.label !== void 0 && A.label !== "" && re.uint32(10).string(A.label), A.id !== void 0 && A.id !== 0 && re.uint32(16).uint32(A.id), A.target !== void 0 && A.target !== 0 && re.uint32(24).int32(A.target), re;
    },
    decode(A, re) {
      const le = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let $e = re === void 0 ? le.len : le.pos + re;
      const Oe = pe();
      for (; le.pos < $e; ) {
        const Fe = le.uint32();
        switch (Fe >>> 3) {
          case 1:
            Oe.label = le.string();
            break;
          case 2:
            Oe.id = le.uint32();
            break;
          case 3:
            Oe.target = le.int32();
            break;
          default:
            le.skipType(Fe & 7);
            break;
        }
      }
      return Oe;
    },
    fromJSON(A) {
      return {
        label: oe(A.label) ? String(A.label) : "",
        id: oe(A.id) ? Number(A.id) : 0,
        target: oe(A.target) ? _(A.target) : 0
      };
    },
    toJSON(A) {
      const re = {};
      return A.label !== void 0 && (re.label = A.label), A.id !== void 0 && (re.id = Math.round(A.id)), A.target !== void 0 && (re.target = k(A.target)), re;
    },
    fromPartial(A) {
      var re, le, $e;
      const Oe = pe();
      return Oe.label = (re = A.label) !== null && re !== void 0 ? re : "", Oe.id = (le = A.id) !== null && le !== void 0 ? le : 0, Oe.target = ($e = A.target) !== null && $e !== void 0 ? $e : 0, Oe;
    }
  };
  function Me() {
    return {
      speakerUpdate: void 0,
      nodeFailure: void 0,
      migration: void 0,
      serverLeave: void 0,
      switchCandidateProtocol: void 0
    };
  }
  a.SimulateScenario = {
    encode(A, re = l.default.Writer.create()) {
      return A.speakerUpdate !== void 0 && re.uint32(8).int32(A.speakerUpdate), A.nodeFailure !== void 0 && re.uint32(16).bool(A.nodeFailure), A.migration !== void 0 && re.uint32(24).bool(A.migration), A.serverLeave !== void 0 && re.uint32(32).bool(A.serverLeave), A.switchCandidateProtocol !== void 0 && re.uint32(40).int32(A.switchCandidateProtocol), re;
    },
    decode(A, re) {
      const le = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let $e = re === void 0 ? le.len : le.pos + re;
      const Oe = Me();
      for (; le.pos < $e; ) {
        const Fe = le.uint32();
        switch (Fe >>> 3) {
          case 1:
            Oe.speakerUpdate = le.int32();
            break;
          case 2:
            Oe.nodeFailure = le.bool();
            break;
          case 3:
            Oe.migration = le.bool();
            break;
          case 4:
            Oe.serverLeave = le.bool();
            break;
          case 5:
            Oe.switchCandidateProtocol = le.int32();
            break;
          default:
            le.skipType(Fe & 7);
            break;
        }
      }
      return Oe;
    },
    fromJSON(A) {
      return {
        speakerUpdate: oe(A.speakerUpdate) ? Number(A.speakerUpdate) : void 0,
        nodeFailure: oe(A.nodeFailure) ? !!A.nodeFailure : void 0,
        migration: oe(A.migration) ? !!A.migration : void 0,
        serverLeave: oe(A.serverLeave) ? !!A.serverLeave : void 0,
        switchCandidateProtocol: oe(A.switchCandidateProtocol) ? Z(A.switchCandidateProtocol) : void 0
      };
    },
    toJSON(A) {
      const re = {};
      return A.speakerUpdate !== void 0 && (re.speakerUpdate = Math.round(A.speakerUpdate)), A.nodeFailure !== void 0 && (re.nodeFailure = A.nodeFailure), A.migration !== void 0 && (re.migration = A.migration), A.serverLeave !== void 0 && (re.serverLeave = A.serverLeave), A.switchCandidateProtocol !== void 0 && (re.switchCandidateProtocol = A.switchCandidateProtocol !== void 0 ? ee(A.switchCandidateProtocol) : void 0), re;
    },
    fromPartial(A) {
      var re, le, $e, Oe, Fe;
      const Ze = Me();
      return Ze.speakerUpdate = (re = A.speakerUpdate) !== null && re !== void 0 ? re : void 0, Ze.nodeFailure = (le = A.nodeFailure) !== null && le !== void 0 ? le : void 0, Ze.migration = ($e = A.migration) !== null && $e !== void 0 ? $e : void 0, Ze.serverLeave = (Oe = A.serverLeave) !== null && Oe !== void 0 ? Oe : void 0, Ze.switchCandidateProtocol = (Fe = A.switchCandidateProtocol) !== null && Fe !== void 0 ? Fe : void 0, Ze;
    }
  };
  var Ne = (() => {
    if (typeof Ne < "u")
      return Ne;
    if (typeof self < "u")
      return self;
    if (typeof window < "u")
      return window;
    if (typeof commonjsGlobal$1 < "u")
      return commonjsGlobal$1;
    throw "Unable to locate global object";
  })();
  function Ue(A) {
    if (A.gt(Number.MAX_SAFE_INTEGER))
      throw new Ne.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    return A.toNumber();
  }
  l.default.util.Long !== c.default && (l.default.util.Long = c.default, l.default.configure());
  function oe(A) {
    return A != null;
  }
})(livekit_rtc);
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(z) {
    return z && z.__esModule ? z : { default: z };
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.RoomInternal = a.KeepAlive = a.RemoveParticipant = a.EndSession = a.StartSession = a.SignalNodeMessage = a.RTCNodeMessage = a.NodeStats = a.Node = a.nodeStateToJSON = a.nodeStateFromJSON = a.NodeState = a.nodeTypeToJSON = a.nodeTypeFromJSON = a.NodeType = a.protobufPackage = void 0;
  const c = u(umdExports), l = u(minimal), v = livekit_egress, p = livekit_models, _ = livekit_room, k = livekit_rtc;
  a.protobufPackage = "livekit";
  var O;
  (function(z) {
    z[z.SERVER = 0] = "SERVER", z[z.CONTROLLER = 1] = "CONTROLLER", z[z.MEDIA = 2] = "MEDIA", z[z.TURN = 4] = "TURN", z[z.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(O = a.NodeType || (a.NodeType = {}));
  function D(z) {
    switch (z) {
      case 0:
      case "SERVER":
        return O.SERVER;
      case 1:
      case "CONTROLLER":
        return O.CONTROLLER;
      case 2:
      case "MEDIA":
        return O.MEDIA;
      case 4:
      case "TURN":
        return O.TURN;
      case -1:
      case "UNRECOGNIZED":
      default:
        return O.UNRECOGNIZED;
    }
  }
  a.nodeTypeFromJSON = D;
  function F(z) {
    switch (z) {
      case O.SERVER:
        return "SERVER";
      case O.CONTROLLER:
        return "CONTROLLER";
      case O.MEDIA:
        return "MEDIA";
      case O.TURN:
        return "TURN";
      case O.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.nodeTypeToJSON = F;
  var H;
  (function(z) {
    z[z.STARTING_UP = 0] = "STARTING_UP", z[z.SERVING = 1] = "SERVING", z[z.SHUTTING_DOWN = 2] = "SHUTTING_DOWN", z[z.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(H = a.NodeState || (a.NodeState = {}));
  function Z(z) {
    switch (z) {
      case 0:
      case "STARTING_UP":
        return H.STARTING_UP;
      case 1:
      case "SERVING":
        return H.SERVING;
      case 2:
      case "SHUTTING_DOWN":
        return H.SHUTTING_DOWN;
      case -1:
      case "UNRECOGNIZED":
      default:
        return H.UNRECOGNIZED;
    }
  }
  a.nodeStateFromJSON = Z;
  function ee(z) {
    switch (z) {
      case H.STARTING_UP:
        return "STARTING_UP";
      case H.SERVING:
        return "SERVING";
      case H.SHUTTING_DOWN:
        return "SHUTTING_DOWN";
      case H.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.nodeStateToJSON = ee;
  function X() {
    return { id: "", ip: "", numCpus: 0, stats: void 0, type: 0, state: 0, region: "" };
  }
  a.Node = {
    encode(z, P = l.default.Writer.create()) {
      return z.id !== void 0 && z.id !== "" && P.uint32(10).string(z.id), z.ip !== void 0 && z.ip !== "" && P.uint32(18).string(z.ip), z.numCpus !== void 0 && z.numCpus !== 0 && P.uint32(24).uint32(z.numCpus), z.stats !== void 0 && a.NodeStats.encode(z.stats, P.uint32(34).fork()).ldelim(), z.type !== void 0 && z.type !== 0 && P.uint32(40).int32(z.type), z.state !== void 0 && z.state !== 0 && P.uint32(48).int32(z.state), z.region !== void 0 && z.region !== "" && P.uint32(58).string(z.region), P;
    },
    decode(z, P) {
      const S = z instanceof l.default.Reader ? z : new l.default.Reader(z);
      let E = P === void 0 ? S.len : S.pos + P;
      const I = X();
      for (; S.pos < E; ) {
        const M = S.uint32();
        switch (M >>> 3) {
          case 1:
            I.id = S.string();
            break;
          case 2:
            I.ip = S.string();
            break;
          case 3:
            I.numCpus = S.uint32();
            break;
          case 4:
            I.stats = a.NodeStats.decode(S, S.uint32());
            break;
          case 5:
            I.type = S.int32();
            break;
          case 6:
            I.state = S.int32();
            break;
          case 7:
            I.region = S.string();
            break;
          default:
            S.skipType(M & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(z) {
      return {
        id: q(z.id) ? String(z.id) : "",
        ip: q(z.ip) ? String(z.ip) : "",
        numCpus: q(z.numCpus) ? Number(z.numCpus) : 0,
        stats: q(z.stats) ? a.NodeStats.fromJSON(z.stats) : void 0,
        type: q(z.type) ? D(z.type) : 0,
        state: q(z.state) ? Z(z.state) : 0,
        region: q(z.region) ? String(z.region) : ""
      };
    },
    toJSON(z) {
      const P = {};
      return z.id !== void 0 && (P.id = z.id), z.ip !== void 0 && (P.ip = z.ip), z.numCpus !== void 0 && (P.numCpus = Math.round(z.numCpus)), z.stats !== void 0 && (P.stats = z.stats ? a.NodeStats.toJSON(z.stats) : void 0), z.type !== void 0 && (P.type = F(z.type)), z.state !== void 0 && (P.state = ee(z.state)), z.region !== void 0 && (P.region = z.region), P;
    },
    fromPartial(z) {
      var P, S, E, I, M, $;
      const U = X();
      return U.id = (P = z.id) !== null && P !== void 0 ? P : "", U.ip = (S = z.ip) !== null && S !== void 0 ? S : "", U.numCpus = (E = z.numCpus) !== null && E !== void 0 ? E : 0, U.stats = z.stats !== void 0 && z.stats !== null ? a.NodeStats.fromPartial(z.stats) : void 0, U.type = (I = z.type) !== null && I !== void 0 ? I : 0, U.state = (M = z.state) !== null && M !== void 0 ? M : 0, U.region = ($ = z.region) !== null && $ !== void 0 ? $ : "", U;
    }
  };
  function ne() {
    return {
      startedAt: 0,
      updatedAt: 0,
      numRooms: 0,
      numClients: 0,
      numTracksIn: 0,
      numTracksOut: 0,
      bytesIn: 0,
      bytesOut: 0,
      packetsIn: 0,
      packetsOut: 0,
      nackTotal: 0,
      bytesInPerSec: 0,
      bytesOutPerSec: 0,
      packetsInPerSec: 0,
      packetsOutPerSec: 0,
      nackPerSec: 0,
      numCpus: 0,
      loadAvgLast1min: 0,
      loadAvgLast5min: 0,
      loadAvgLast15min: 0,
      cpuLoad: 0,
      memoryLoad: 0,
      sysPacketsOut: 0,
      sysPacketsDropped: 0,
      sysPacketsOutPerSec: 0,
      sysPacketsDroppedPerSec: 0,
      sysPacketsDroppedPctPerSec: 0,
      retransmitBytesOut: 0,
      retransmitPacketsOut: 0,
      retransmitBytesOutPerSec: 0,
      retransmitPacketsOutPerSec: 0,
      participantJoin: 0,
      participantJoinPerSec: 0
    };
  }
  a.NodeStats = {
    encode(z, P = l.default.Writer.create()) {
      return z.startedAt !== void 0 && z.startedAt !== 0 && P.uint32(8).int64(z.startedAt), z.updatedAt !== void 0 && z.updatedAt !== 0 && P.uint32(16).int64(z.updatedAt), z.numRooms !== void 0 && z.numRooms !== 0 && P.uint32(24).int32(z.numRooms), z.numClients !== void 0 && z.numClients !== 0 && P.uint32(32).int32(z.numClients), z.numTracksIn !== void 0 && z.numTracksIn !== 0 && P.uint32(40).int32(z.numTracksIn), z.numTracksOut !== void 0 && z.numTracksOut !== 0 && P.uint32(48).int32(z.numTracksOut), z.bytesIn !== void 0 && z.bytesIn !== 0 && P.uint32(56).uint64(z.bytesIn), z.bytesOut !== void 0 && z.bytesOut !== 0 && P.uint32(64).uint64(z.bytesOut), z.packetsIn !== void 0 && z.packetsIn !== 0 && P.uint32(72).uint64(z.packetsIn), z.packetsOut !== void 0 && z.packetsOut !== 0 && P.uint32(80).uint64(z.packetsOut), z.nackTotal !== void 0 && z.nackTotal !== 0 && P.uint32(88).uint64(z.nackTotal), z.bytesInPerSec !== void 0 && z.bytesInPerSec !== 0 && P.uint32(101).float(z.bytesInPerSec), z.bytesOutPerSec !== void 0 && z.bytesOutPerSec !== 0 && P.uint32(109).float(z.bytesOutPerSec), z.packetsInPerSec !== void 0 && z.packetsInPerSec !== 0 && P.uint32(117).float(z.packetsInPerSec), z.packetsOutPerSec !== void 0 && z.packetsOutPerSec !== 0 && P.uint32(125).float(z.packetsOutPerSec), z.nackPerSec !== void 0 && z.nackPerSec !== 0 && P.uint32(133).float(z.nackPerSec), z.numCpus !== void 0 && z.numCpus !== 0 && P.uint32(136).uint32(z.numCpus), z.loadAvgLast1min !== void 0 && z.loadAvgLast1min !== 0 && P.uint32(149).float(z.loadAvgLast1min), z.loadAvgLast5min !== void 0 && z.loadAvgLast5min !== 0 && P.uint32(157).float(z.loadAvgLast5min), z.loadAvgLast15min !== void 0 && z.loadAvgLast15min !== 0 && P.uint32(165).float(z.loadAvgLast15min), z.cpuLoad !== void 0 && z.cpuLoad !== 0 && P.uint32(173).float(z.cpuLoad), z.memoryLoad !== void 0 && z.memoryLoad !== 0 && P.uint32(269).float(z.memoryLoad), z.sysPacketsOut !== void 0 && z.sysPacketsOut !== 0 && P.uint32(224).uint32(z.sysPacketsOut), z.sysPacketsDropped !== void 0 && z.sysPacketsDropped !== 0 && P.uint32(232).uint32(z.sysPacketsDropped), z.sysPacketsOutPerSec !== void 0 && z.sysPacketsOutPerSec !== 0 && P.uint32(245).float(z.sysPacketsOutPerSec), z.sysPacketsDroppedPerSec !== void 0 && z.sysPacketsDroppedPerSec !== 0 && P.uint32(253).float(z.sysPacketsDroppedPerSec), z.sysPacketsDroppedPctPerSec !== void 0 && z.sysPacketsDroppedPctPerSec !== 0 && P.uint32(261).float(z.sysPacketsDroppedPctPerSec), z.retransmitBytesOut !== void 0 && z.retransmitBytesOut !== 0 && P.uint32(176).uint64(z.retransmitBytesOut), z.retransmitPacketsOut !== void 0 && z.retransmitPacketsOut !== 0 && P.uint32(184).uint64(z.retransmitPacketsOut), z.retransmitBytesOutPerSec !== void 0 && z.retransmitBytesOutPerSec !== 0 && P.uint32(197).float(z.retransmitBytesOutPerSec), z.retransmitPacketsOutPerSec !== void 0 && z.retransmitPacketsOutPerSec !== 0 && P.uint32(205).float(z.retransmitPacketsOutPerSec), z.participantJoin !== void 0 && z.participantJoin !== 0 && P.uint32(208).uint64(z.participantJoin), z.participantJoinPerSec !== void 0 && z.participantJoinPerSec !== 0 && P.uint32(221).float(z.participantJoinPerSec), P;
    },
    decode(z, P) {
      const S = z instanceof l.default.Reader ? z : new l.default.Reader(z);
      let E = P === void 0 ? S.len : S.pos + P;
      const I = ne();
      for (; S.pos < E; ) {
        const M = S.uint32();
        switch (M >>> 3) {
          case 1:
            I.startedAt = Te(S.int64());
            break;
          case 2:
            I.updatedAt = Te(S.int64());
            break;
          case 3:
            I.numRooms = S.int32();
            break;
          case 4:
            I.numClients = S.int32();
            break;
          case 5:
            I.numTracksIn = S.int32();
            break;
          case 6:
            I.numTracksOut = S.int32();
            break;
          case 7:
            I.bytesIn = Te(S.uint64());
            break;
          case 8:
            I.bytesOut = Te(S.uint64());
            break;
          case 9:
            I.packetsIn = Te(S.uint64());
            break;
          case 10:
            I.packetsOut = Te(S.uint64());
            break;
          case 11:
            I.nackTotal = Te(S.uint64());
            break;
          case 12:
            I.bytesInPerSec = S.float();
            break;
          case 13:
            I.bytesOutPerSec = S.float();
            break;
          case 14:
            I.packetsInPerSec = S.float();
            break;
          case 15:
            I.packetsOutPerSec = S.float();
            break;
          case 16:
            I.nackPerSec = S.float();
            break;
          case 17:
            I.numCpus = S.uint32();
            break;
          case 18:
            I.loadAvgLast1min = S.float();
            break;
          case 19:
            I.loadAvgLast5min = S.float();
            break;
          case 20:
            I.loadAvgLast15min = S.float();
            break;
          case 21:
            I.cpuLoad = S.float();
            break;
          case 33:
            I.memoryLoad = S.float();
            break;
          case 28:
            I.sysPacketsOut = S.uint32();
            break;
          case 29:
            I.sysPacketsDropped = S.uint32();
            break;
          case 30:
            I.sysPacketsOutPerSec = S.float();
            break;
          case 31:
            I.sysPacketsDroppedPerSec = S.float();
            break;
          case 32:
            I.sysPacketsDroppedPctPerSec = S.float();
            break;
          case 22:
            I.retransmitBytesOut = Te(S.uint64());
            break;
          case 23:
            I.retransmitPacketsOut = Te(S.uint64());
            break;
          case 24:
            I.retransmitBytesOutPerSec = S.float();
            break;
          case 25:
            I.retransmitPacketsOutPerSec = S.float();
            break;
          case 26:
            I.participantJoin = Te(S.uint64());
            break;
          case 27:
            I.participantJoinPerSec = S.float();
            break;
          default:
            S.skipType(M & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(z) {
      return {
        startedAt: q(z.startedAt) ? Number(z.startedAt) : 0,
        updatedAt: q(z.updatedAt) ? Number(z.updatedAt) : 0,
        numRooms: q(z.numRooms) ? Number(z.numRooms) : 0,
        numClients: q(z.numClients) ? Number(z.numClients) : 0,
        numTracksIn: q(z.numTracksIn) ? Number(z.numTracksIn) : 0,
        numTracksOut: q(z.numTracksOut) ? Number(z.numTracksOut) : 0,
        bytesIn: q(z.bytesIn) ? Number(z.bytesIn) : 0,
        bytesOut: q(z.bytesOut) ? Number(z.bytesOut) : 0,
        packetsIn: q(z.packetsIn) ? Number(z.packetsIn) : 0,
        packetsOut: q(z.packetsOut) ? Number(z.packetsOut) : 0,
        nackTotal: q(z.nackTotal) ? Number(z.nackTotal) : 0,
        bytesInPerSec: q(z.bytesInPerSec) ? Number(z.bytesInPerSec) : 0,
        bytesOutPerSec: q(z.bytesOutPerSec) ? Number(z.bytesOutPerSec) : 0,
        packetsInPerSec: q(z.packetsInPerSec) ? Number(z.packetsInPerSec) : 0,
        packetsOutPerSec: q(z.packetsOutPerSec) ? Number(z.packetsOutPerSec) : 0,
        nackPerSec: q(z.nackPerSec) ? Number(z.nackPerSec) : 0,
        numCpus: q(z.numCpus) ? Number(z.numCpus) : 0,
        loadAvgLast1min: q(z.loadAvgLast1min) ? Number(z.loadAvgLast1min) : 0,
        loadAvgLast5min: q(z.loadAvgLast5min) ? Number(z.loadAvgLast5min) : 0,
        loadAvgLast15min: q(z.loadAvgLast15min) ? Number(z.loadAvgLast15min) : 0,
        cpuLoad: q(z.cpuLoad) ? Number(z.cpuLoad) : 0,
        memoryLoad: q(z.memoryLoad) ? Number(z.memoryLoad) : 0,
        sysPacketsOut: q(z.sysPacketsOut) ? Number(z.sysPacketsOut) : 0,
        sysPacketsDropped: q(z.sysPacketsDropped) ? Number(z.sysPacketsDropped) : 0,
        sysPacketsOutPerSec: q(z.sysPacketsOutPerSec) ? Number(z.sysPacketsOutPerSec) : 0,
        sysPacketsDroppedPerSec: q(z.sysPacketsDroppedPerSec) ? Number(z.sysPacketsDroppedPerSec) : 0,
        sysPacketsDroppedPctPerSec: q(z.sysPacketsDroppedPctPerSec) ? Number(z.sysPacketsDroppedPctPerSec) : 0,
        retransmitBytesOut: q(z.retransmitBytesOut) ? Number(z.retransmitBytesOut) : 0,
        retransmitPacketsOut: q(z.retransmitPacketsOut) ? Number(z.retransmitPacketsOut) : 0,
        retransmitBytesOutPerSec: q(z.retransmitBytesOutPerSec) ? Number(z.retransmitBytesOutPerSec) : 0,
        retransmitPacketsOutPerSec: q(z.retransmitPacketsOutPerSec) ? Number(z.retransmitPacketsOutPerSec) : 0,
        participantJoin: q(z.participantJoin) ? Number(z.participantJoin) : 0,
        participantJoinPerSec: q(z.participantJoinPerSec) ? Number(z.participantJoinPerSec) : 0
      };
    },
    toJSON(z) {
      const P = {};
      return z.startedAt !== void 0 && (P.startedAt = Math.round(z.startedAt)), z.updatedAt !== void 0 && (P.updatedAt = Math.round(z.updatedAt)), z.numRooms !== void 0 && (P.numRooms = Math.round(z.numRooms)), z.numClients !== void 0 && (P.numClients = Math.round(z.numClients)), z.numTracksIn !== void 0 && (P.numTracksIn = Math.round(z.numTracksIn)), z.numTracksOut !== void 0 && (P.numTracksOut = Math.round(z.numTracksOut)), z.bytesIn !== void 0 && (P.bytesIn = Math.round(z.bytesIn)), z.bytesOut !== void 0 && (P.bytesOut = Math.round(z.bytesOut)), z.packetsIn !== void 0 && (P.packetsIn = Math.round(z.packetsIn)), z.packetsOut !== void 0 && (P.packetsOut = Math.round(z.packetsOut)), z.nackTotal !== void 0 && (P.nackTotal = Math.round(z.nackTotal)), z.bytesInPerSec !== void 0 && (P.bytesInPerSec = z.bytesInPerSec), z.bytesOutPerSec !== void 0 && (P.bytesOutPerSec = z.bytesOutPerSec), z.packetsInPerSec !== void 0 && (P.packetsInPerSec = z.packetsInPerSec), z.packetsOutPerSec !== void 0 && (P.packetsOutPerSec = z.packetsOutPerSec), z.nackPerSec !== void 0 && (P.nackPerSec = z.nackPerSec), z.numCpus !== void 0 && (P.numCpus = Math.round(z.numCpus)), z.loadAvgLast1min !== void 0 && (P.loadAvgLast1min = z.loadAvgLast1min), z.loadAvgLast5min !== void 0 && (P.loadAvgLast5min = z.loadAvgLast5min), z.loadAvgLast15min !== void 0 && (P.loadAvgLast15min = z.loadAvgLast15min), z.cpuLoad !== void 0 && (P.cpuLoad = z.cpuLoad), z.memoryLoad !== void 0 && (P.memoryLoad = z.memoryLoad), z.sysPacketsOut !== void 0 && (P.sysPacketsOut = Math.round(z.sysPacketsOut)), z.sysPacketsDropped !== void 0 && (P.sysPacketsDropped = Math.round(z.sysPacketsDropped)), z.sysPacketsOutPerSec !== void 0 && (P.sysPacketsOutPerSec = z.sysPacketsOutPerSec), z.sysPacketsDroppedPerSec !== void 0 && (P.sysPacketsDroppedPerSec = z.sysPacketsDroppedPerSec), z.sysPacketsDroppedPctPerSec !== void 0 && (P.sysPacketsDroppedPctPerSec = z.sysPacketsDroppedPctPerSec), z.retransmitBytesOut !== void 0 && (P.retransmitBytesOut = Math.round(z.retransmitBytesOut)), z.retransmitPacketsOut !== void 0 && (P.retransmitPacketsOut = Math.round(z.retransmitPacketsOut)), z.retransmitBytesOutPerSec !== void 0 && (P.retransmitBytesOutPerSec = z.retransmitBytesOutPerSec), z.retransmitPacketsOutPerSec !== void 0 && (P.retransmitPacketsOutPerSec = z.retransmitPacketsOutPerSec), z.participantJoin !== void 0 && (P.participantJoin = Math.round(z.participantJoin)), z.participantJoinPerSec !== void 0 && (P.participantJoinPerSec = z.participantJoinPerSec), P;
    },
    fromPartial(z) {
      var P, S, E, I, M, $, U, Y, B, T, L, te, me, Ce, De, ye, pe, Me, Ne, Ue, oe, A, re, le, $e, Oe, Fe, Ze, qe, yt, Xe, Ge, J;
      const ge = ne();
      return ge.startedAt = (P = z.startedAt) !== null && P !== void 0 ? P : 0, ge.updatedAt = (S = z.updatedAt) !== null && S !== void 0 ? S : 0, ge.numRooms = (E = z.numRooms) !== null && E !== void 0 ? E : 0, ge.numClients = (I = z.numClients) !== null && I !== void 0 ? I : 0, ge.numTracksIn = (M = z.numTracksIn) !== null && M !== void 0 ? M : 0, ge.numTracksOut = ($ = z.numTracksOut) !== null && $ !== void 0 ? $ : 0, ge.bytesIn = (U = z.bytesIn) !== null && U !== void 0 ? U : 0, ge.bytesOut = (Y = z.bytesOut) !== null && Y !== void 0 ? Y : 0, ge.packetsIn = (B = z.packetsIn) !== null && B !== void 0 ? B : 0, ge.packetsOut = (T = z.packetsOut) !== null && T !== void 0 ? T : 0, ge.nackTotal = (L = z.nackTotal) !== null && L !== void 0 ? L : 0, ge.bytesInPerSec = (te = z.bytesInPerSec) !== null && te !== void 0 ? te : 0, ge.bytesOutPerSec = (me = z.bytesOutPerSec) !== null && me !== void 0 ? me : 0, ge.packetsInPerSec = (Ce = z.packetsInPerSec) !== null && Ce !== void 0 ? Ce : 0, ge.packetsOutPerSec = (De = z.packetsOutPerSec) !== null && De !== void 0 ? De : 0, ge.nackPerSec = (ye = z.nackPerSec) !== null && ye !== void 0 ? ye : 0, ge.numCpus = (pe = z.numCpus) !== null && pe !== void 0 ? pe : 0, ge.loadAvgLast1min = (Me = z.loadAvgLast1min) !== null && Me !== void 0 ? Me : 0, ge.loadAvgLast5min = (Ne = z.loadAvgLast5min) !== null && Ne !== void 0 ? Ne : 0, ge.loadAvgLast15min = (Ue = z.loadAvgLast15min) !== null && Ue !== void 0 ? Ue : 0, ge.cpuLoad = (oe = z.cpuLoad) !== null && oe !== void 0 ? oe : 0, ge.memoryLoad = (A = z.memoryLoad) !== null && A !== void 0 ? A : 0, ge.sysPacketsOut = (re = z.sysPacketsOut) !== null && re !== void 0 ? re : 0, ge.sysPacketsDropped = (le = z.sysPacketsDropped) !== null && le !== void 0 ? le : 0, ge.sysPacketsOutPerSec = ($e = z.sysPacketsOutPerSec) !== null && $e !== void 0 ? $e : 0, ge.sysPacketsDroppedPerSec = (Oe = z.sysPacketsDroppedPerSec) !== null && Oe !== void 0 ? Oe : 0, ge.sysPacketsDroppedPctPerSec = (Fe = z.sysPacketsDroppedPctPerSec) !== null && Fe !== void 0 ? Fe : 0, ge.retransmitBytesOut = (Ze = z.retransmitBytesOut) !== null && Ze !== void 0 ? Ze : 0, ge.retransmitPacketsOut = (qe = z.retransmitPacketsOut) !== null && qe !== void 0 ? qe : 0, ge.retransmitBytesOutPerSec = (yt = z.retransmitBytesOutPerSec) !== null && yt !== void 0 ? yt : 0, ge.retransmitPacketsOutPerSec = (Xe = z.retransmitPacketsOutPerSec) !== null && Xe !== void 0 ? Xe : 0, ge.participantJoin = (Ge = z.participantJoin) !== null && Ge !== void 0 ? Ge : 0, ge.participantJoinPerSec = (J = z.participantJoinPerSec) !== null && J !== void 0 ? J : 0, ge;
    }
  };
  function Q() {
    return {
      participantKey: "",
      senderTime: 0,
      connectionId: "",
      startSession: void 0,
      request: void 0,
      removeParticipant: void 0,
      muteTrack: void 0,
      updateParticipant: void 0,
      deleteRoom: void 0,
      updateSubscriptions: void 0,
      sendData: void 0,
      updateRoomMetadata: void 0,
      keepAlive: void 0
    };
  }
  a.RTCNodeMessage = {
    encode(z, P = l.default.Writer.create()) {
      return z.participantKey !== void 0 && z.participantKey !== "" && P.uint32(10).string(z.participantKey), z.senderTime !== void 0 && z.senderTime !== 0 && P.uint32(88).int64(z.senderTime), z.connectionId !== void 0 && z.connectionId !== "" && P.uint32(106).string(z.connectionId), z.startSession !== void 0 && a.StartSession.encode(z.startSession, P.uint32(18).fork()).ldelim(), z.request !== void 0 && k.SignalRequest.encode(z.request, P.uint32(26).fork()).ldelim(), z.removeParticipant !== void 0 && _.RoomParticipantIdentity.encode(z.removeParticipant, P.uint32(34).fork()).ldelim(), z.muteTrack !== void 0 && _.MuteRoomTrackRequest.encode(z.muteTrack, P.uint32(42).fork()).ldelim(), z.updateParticipant !== void 0 && _.UpdateParticipantRequest.encode(z.updateParticipant, P.uint32(50).fork()).ldelim(), z.deleteRoom !== void 0 && _.DeleteRoomRequest.encode(z.deleteRoom, P.uint32(58).fork()).ldelim(), z.updateSubscriptions !== void 0 && _.UpdateSubscriptionsRequest.encode(z.updateSubscriptions, P.uint32(66).fork()).ldelim(), z.sendData !== void 0 && _.SendDataRequest.encode(z.sendData, P.uint32(74).fork()).ldelim(), z.updateRoomMetadata !== void 0 && _.UpdateRoomMetadataRequest.encode(z.updateRoomMetadata, P.uint32(82).fork()).ldelim(), z.keepAlive !== void 0 && a.KeepAlive.encode(z.keepAlive, P.uint32(98).fork()).ldelim(), P;
    },
    decode(z, P) {
      const S = z instanceof l.default.Reader ? z : new l.default.Reader(z);
      let E = P === void 0 ? S.len : S.pos + P;
      const I = Q();
      for (; S.pos < E; ) {
        const M = S.uint32();
        switch (M >>> 3) {
          case 1:
            I.participantKey = S.string();
            break;
          case 11:
            I.senderTime = Te(S.int64());
            break;
          case 13:
            I.connectionId = S.string();
            break;
          case 2:
            I.startSession = a.StartSession.decode(S, S.uint32());
            break;
          case 3:
            I.request = k.SignalRequest.decode(S, S.uint32());
            break;
          case 4:
            I.removeParticipant = _.RoomParticipantIdentity.decode(S, S.uint32());
            break;
          case 5:
            I.muteTrack = _.MuteRoomTrackRequest.decode(S, S.uint32());
            break;
          case 6:
            I.updateParticipant = _.UpdateParticipantRequest.decode(S, S.uint32());
            break;
          case 7:
            I.deleteRoom = _.DeleteRoomRequest.decode(S, S.uint32());
            break;
          case 8:
            I.updateSubscriptions = _.UpdateSubscriptionsRequest.decode(S, S.uint32());
            break;
          case 9:
            I.sendData = _.SendDataRequest.decode(S, S.uint32());
            break;
          case 10:
            I.updateRoomMetadata = _.UpdateRoomMetadataRequest.decode(S, S.uint32());
            break;
          case 12:
            I.keepAlive = a.KeepAlive.decode(S, S.uint32());
            break;
          default:
            S.skipType(M & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(z) {
      return {
        participantKey: q(z.participantKey) ? String(z.participantKey) : "",
        senderTime: q(z.senderTime) ? Number(z.senderTime) : 0,
        connectionId: q(z.connectionId) ? String(z.connectionId) : "",
        startSession: q(z.startSession) ? a.StartSession.fromJSON(z.startSession) : void 0,
        request: q(z.request) ? k.SignalRequest.fromJSON(z.request) : void 0,
        removeParticipant: q(z.removeParticipant) ? _.RoomParticipantIdentity.fromJSON(z.removeParticipant) : void 0,
        muteTrack: q(z.muteTrack) ? _.MuteRoomTrackRequest.fromJSON(z.muteTrack) : void 0,
        updateParticipant: q(z.updateParticipant) ? _.UpdateParticipantRequest.fromJSON(z.updateParticipant) : void 0,
        deleteRoom: q(z.deleteRoom) ? _.DeleteRoomRequest.fromJSON(z.deleteRoom) : void 0,
        updateSubscriptions: q(z.updateSubscriptions) ? _.UpdateSubscriptionsRequest.fromJSON(z.updateSubscriptions) : void 0,
        sendData: q(z.sendData) ? _.SendDataRequest.fromJSON(z.sendData) : void 0,
        updateRoomMetadata: q(z.updateRoomMetadata) ? _.UpdateRoomMetadataRequest.fromJSON(z.updateRoomMetadata) : void 0,
        keepAlive: q(z.keepAlive) ? a.KeepAlive.fromJSON(z.keepAlive) : void 0
      };
    },
    toJSON(z) {
      const P = {};
      return z.participantKey !== void 0 && (P.participantKey = z.participantKey), z.senderTime !== void 0 && (P.senderTime = Math.round(z.senderTime)), z.connectionId !== void 0 && (P.connectionId = z.connectionId), z.startSession !== void 0 && (P.startSession = z.startSession ? a.StartSession.toJSON(z.startSession) : void 0), z.request !== void 0 && (P.request = z.request ? k.SignalRequest.toJSON(z.request) : void 0), z.removeParticipant !== void 0 && (P.removeParticipant = z.removeParticipant ? _.RoomParticipantIdentity.toJSON(z.removeParticipant) : void 0), z.muteTrack !== void 0 && (P.muteTrack = z.muteTrack ? _.MuteRoomTrackRequest.toJSON(z.muteTrack) : void 0), z.updateParticipant !== void 0 && (P.updateParticipant = z.updateParticipant ? _.UpdateParticipantRequest.toJSON(z.updateParticipant) : void 0), z.deleteRoom !== void 0 && (P.deleteRoom = z.deleteRoom ? _.DeleteRoomRequest.toJSON(z.deleteRoom) : void 0), z.updateSubscriptions !== void 0 && (P.updateSubscriptions = z.updateSubscriptions ? _.UpdateSubscriptionsRequest.toJSON(z.updateSubscriptions) : void 0), z.sendData !== void 0 && (P.sendData = z.sendData ? _.SendDataRequest.toJSON(z.sendData) : void 0), z.updateRoomMetadata !== void 0 && (P.updateRoomMetadata = z.updateRoomMetadata ? _.UpdateRoomMetadataRequest.toJSON(z.updateRoomMetadata) : void 0), z.keepAlive !== void 0 && (P.keepAlive = z.keepAlive ? a.KeepAlive.toJSON(z.keepAlive) : void 0), P;
    },
    fromPartial(z) {
      var P, S, E;
      const I = Q();
      return I.participantKey = (P = z.participantKey) !== null && P !== void 0 ? P : "", I.senderTime = (S = z.senderTime) !== null && S !== void 0 ? S : 0, I.connectionId = (E = z.connectionId) !== null && E !== void 0 ? E : "", I.startSession = z.startSession !== void 0 && z.startSession !== null ? a.StartSession.fromPartial(z.startSession) : void 0, I.request = z.request !== void 0 && z.request !== null ? k.SignalRequest.fromPartial(z.request) : void 0, I.removeParticipant = z.removeParticipant !== void 0 && z.removeParticipant !== null ? _.RoomParticipantIdentity.fromPartial(z.removeParticipant) : void 0, I.muteTrack = z.muteTrack !== void 0 && z.muteTrack !== null ? _.MuteRoomTrackRequest.fromPartial(z.muteTrack) : void 0, I.updateParticipant = z.updateParticipant !== void 0 && z.updateParticipant !== null ? _.UpdateParticipantRequest.fromPartial(z.updateParticipant) : void 0, I.deleteRoom = z.deleteRoom !== void 0 && z.deleteRoom !== null ? _.DeleteRoomRequest.fromPartial(z.deleteRoom) : void 0, I.updateSubscriptions = z.updateSubscriptions !== void 0 && z.updateSubscriptions !== null ? _.UpdateSubscriptionsRequest.fromPartial(z.updateSubscriptions) : void 0, I.sendData = z.sendData !== void 0 && z.sendData !== null ? _.SendDataRequest.fromPartial(z.sendData) : void 0, I.updateRoomMetadata = z.updateRoomMetadata !== void 0 && z.updateRoomMetadata !== null ? _.UpdateRoomMetadataRequest.fromPartial(z.updateRoomMetadata) : void 0, I.keepAlive = z.keepAlive !== void 0 && z.keepAlive !== null ? a.KeepAlive.fromPartial(z.keepAlive) : void 0, I;
    }
  };
  function ae() {
    return { connectionId: "", response: void 0, endSession: void 0 };
  }
  a.SignalNodeMessage = {
    encode(z, P = l.default.Writer.create()) {
      return z.connectionId !== void 0 && z.connectionId !== "" && P.uint32(10).string(z.connectionId), z.response !== void 0 && k.SignalResponse.encode(z.response, P.uint32(18).fork()).ldelim(), z.endSession !== void 0 && a.EndSession.encode(z.endSession, P.uint32(26).fork()).ldelim(), P;
    },
    decode(z, P) {
      const S = z instanceof l.default.Reader ? z : new l.default.Reader(z);
      let E = P === void 0 ? S.len : S.pos + P;
      const I = ae();
      for (; S.pos < E; ) {
        const M = S.uint32();
        switch (M >>> 3) {
          case 1:
            I.connectionId = S.string();
            break;
          case 2:
            I.response = k.SignalResponse.decode(S, S.uint32());
            break;
          case 3:
            I.endSession = a.EndSession.decode(S, S.uint32());
            break;
          default:
            S.skipType(M & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(z) {
      return {
        connectionId: q(z.connectionId) ? String(z.connectionId) : "",
        response: q(z.response) ? k.SignalResponse.fromJSON(z.response) : void 0,
        endSession: q(z.endSession) ? a.EndSession.fromJSON(z.endSession) : void 0
      };
    },
    toJSON(z) {
      const P = {};
      return z.connectionId !== void 0 && (P.connectionId = z.connectionId), z.response !== void 0 && (P.response = z.response ? k.SignalResponse.toJSON(z.response) : void 0), z.endSession !== void 0 && (P.endSession = z.endSession ? a.EndSession.toJSON(z.endSession) : void 0), P;
    },
    fromPartial(z) {
      var P;
      const S = ae();
      return S.connectionId = (P = z.connectionId) !== null && P !== void 0 ? P : "", S.response = z.response !== void 0 && z.response !== null ? k.SignalResponse.fromPartial(z.response) : void 0, S.endSession = z.endSession !== void 0 && z.endSession !== null ? a.EndSession.fromPartial(z.endSession) : void 0, S;
    }
  };
  function j() {
    return {
      roomName: "",
      identity: "",
      connectionId: "",
      reconnect: !1,
      autoSubscribe: !1,
      hidden: !1,
      client: void 0,
      recorder: !1,
      name: "",
      grantsJson: "",
      adaptiveStream: !1,
      participantId: ""
    };
  }
  a.StartSession = {
    encode(z, P = l.default.Writer.create()) {
      return z.roomName !== void 0 && z.roomName !== "" && P.uint32(10).string(z.roomName), z.identity !== void 0 && z.identity !== "" && P.uint32(18).string(z.identity), z.connectionId !== void 0 && z.connectionId !== "" && P.uint32(26).string(z.connectionId), z.reconnect === !0 && P.uint32(32).bool(z.reconnect), z.autoSubscribe === !0 && P.uint32(72).bool(z.autoSubscribe), z.hidden === !0 && P.uint32(80).bool(z.hidden), z.client !== void 0 && p.ClientInfo.encode(z.client, P.uint32(90).fork()).ldelim(), z.recorder === !0 && P.uint32(96).bool(z.recorder), z.name !== void 0 && z.name !== "" && P.uint32(106).string(z.name), z.grantsJson !== void 0 && z.grantsJson !== "" && P.uint32(114).string(z.grantsJson), z.adaptiveStream === !0 && P.uint32(120).bool(z.adaptiveStream), z.participantId !== void 0 && z.participantId !== "" && P.uint32(130).string(z.participantId), P;
    },
    decode(z, P) {
      const S = z instanceof l.default.Reader ? z : new l.default.Reader(z);
      let E = P === void 0 ? S.len : S.pos + P;
      const I = j();
      for (; S.pos < E; ) {
        const M = S.uint32();
        switch (M >>> 3) {
          case 1:
            I.roomName = S.string();
            break;
          case 2:
            I.identity = S.string();
            break;
          case 3:
            I.connectionId = S.string();
            break;
          case 4:
            I.reconnect = S.bool();
            break;
          case 9:
            I.autoSubscribe = S.bool();
            break;
          case 10:
            I.hidden = S.bool();
            break;
          case 11:
            I.client = p.ClientInfo.decode(S, S.uint32());
            break;
          case 12:
            I.recorder = S.bool();
            break;
          case 13:
            I.name = S.string();
            break;
          case 14:
            I.grantsJson = S.string();
            break;
          case 15:
            I.adaptiveStream = S.bool();
            break;
          case 16:
            I.participantId = S.string();
            break;
          default:
            S.skipType(M & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(z) {
      return {
        roomName: q(z.roomName) ? String(z.roomName) : "",
        identity: q(z.identity) ? String(z.identity) : "",
        connectionId: q(z.connectionId) ? String(z.connectionId) : "",
        reconnect: q(z.reconnect) ? !!z.reconnect : !1,
        autoSubscribe: q(z.autoSubscribe) ? !!z.autoSubscribe : !1,
        hidden: q(z.hidden) ? !!z.hidden : !1,
        client: q(z.client) ? p.ClientInfo.fromJSON(z.client) : void 0,
        recorder: q(z.recorder) ? !!z.recorder : !1,
        name: q(z.name) ? String(z.name) : "",
        grantsJson: q(z.grantsJson) ? String(z.grantsJson) : "",
        adaptiveStream: q(z.adaptiveStream) ? !!z.adaptiveStream : !1,
        participantId: q(z.participantId) ? String(z.participantId) : ""
      };
    },
    toJSON(z) {
      const P = {};
      return z.roomName !== void 0 && (P.roomName = z.roomName), z.identity !== void 0 && (P.identity = z.identity), z.connectionId !== void 0 && (P.connectionId = z.connectionId), z.reconnect !== void 0 && (P.reconnect = z.reconnect), z.autoSubscribe !== void 0 && (P.autoSubscribe = z.autoSubscribe), z.hidden !== void 0 && (P.hidden = z.hidden), z.client !== void 0 && (P.client = z.client ? p.ClientInfo.toJSON(z.client) : void 0), z.recorder !== void 0 && (P.recorder = z.recorder), z.name !== void 0 && (P.name = z.name), z.grantsJson !== void 0 && (P.grantsJson = z.grantsJson), z.adaptiveStream !== void 0 && (P.adaptiveStream = z.adaptiveStream), z.participantId !== void 0 && (P.participantId = z.participantId), P;
    },
    fromPartial(z) {
      var P, S, E, I, M, $, U, Y, B, T, L;
      const te = j();
      return te.roomName = (P = z.roomName) !== null && P !== void 0 ? P : "", te.identity = (S = z.identity) !== null && S !== void 0 ? S : "", te.connectionId = (E = z.connectionId) !== null && E !== void 0 ? E : "", te.reconnect = (I = z.reconnect) !== null && I !== void 0 ? I : !1, te.autoSubscribe = (M = z.autoSubscribe) !== null && M !== void 0 ? M : !1, te.hidden = ($ = z.hidden) !== null && $ !== void 0 ? $ : !1, te.client = z.client !== void 0 && z.client !== null ? p.ClientInfo.fromPartial(z.client) : void 0, te.recorder = (U = z.recorder) !== null && U !== void 0 ? U : !1, te.name = (Y = z.name) !== null && Y !== void 0 ? Y : "", te.grantsJson = (B = z.grantsJson) !== null && B !== void 0 ? B : "", te.adaptiveStream = (T = z.adaptiveStream) !== null && T !== void 0 ? T : !1, te.participantId = (L = z.participantId) !== null && L !== void 0 ? L : "", te;
    }
  };
  function ue() {
    return {};
  }
  a.EndSession = {
    encode(z, P = l.default.Writer.create()) {
      return P;
    },
    decode(z, P) {
      const S = z instanceof l.default.Reader ? z : new l.default.Reader(z);
      let E = P === void 0 ? S.len : S.pos + P;
      const I = ue();
      for (; S.pos < E; ) {
        const M = S.uint32();
        switch (M >>> 3) {
          default:
            S.skipType(M & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(z) {
      return {};
    },
    toJSON(z) {
      return {};
    },
    fromPartial(z) {
      return ue();
    }
  };
  function he() {
    return { participantId: "" };
  }
  a.RemoveParticipant = {
    encode(z, P = l.default.Writer.create()) {
      return z.participantId !== void 0 && z.participantId !== "" && P.uint32(10).string(z.participantId), P;
    },
    decode(z, P) {
      const S = z instanceof l.default.Reader ? z : new l.default.Reader(z);
      let E = P === void 0 ? S.len : S.pos + P;
      const I = he();
      for (; S.pos < E; ) {
        const M = S.uint32();
        switch (M >>> 3) {
          case 1:
            I.participantId = S.string();
            break;
          default:
            S.skipType(M & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(z) {
      return { participantId: q(z.participantId) ? String(z.participantId) : "" };
    },
    toJSON(z) {
      const P = {};
      return z.participantId !== void 0 && (P.participantId = z.participantId), P;
    },
    fromPartial(z) {
      var P;
      const S = he();
      return S.participantId = (P = z.participantId) !== null && P !== void 0 ? P : "", S;
    }
  };
  function fe() {
    return {};
  }
  a.KeepAlive = {
    encode(z, P = l.default.Writer.create()) {
      return P;
    },
    decode(z, P) {
      const S = z instanceof l.default.Reader ? z : new l.default.Reader(z);
      let E = P === void 0 ? S.len : S.pos + P;
      const I = fe();
      for (; S.pos < E; ) {
        const M = S.uint32();
        switch (M >>> 3) {
          default:
            S.skipType(M & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(z) {
      return {};
    },
    toJSON(z) {
      return {};
    },
    fromPartial(z) {
      return fe();
    }
  };
  function be() {
    return { trackEgress: void 0 };
  }
  a.RoomInternal = {
    encode(z, P = l.default.Writer.create()) {
      return z.trackEgress !== void 0 && v.AutoTrackEgress.encode(z.trackEgress, P.uint32(10).fork()).ldelim(), P;
    },
    decode(z, P) {
      const S = z instanceof l.default.Reader ? z : new l.default.Reader(z);
      let E = P === void 0 ? S.len : S.pos + P;
      const I = be();
      for (; S.pos < E; ) {
        const M = S.uint32();
        switch (M >>> 3) {
          case 1:
            I.trackEgress = v.AutoTrackEgress.decode(S, S.uint32());
            break;
          default:
            S.skipType(M & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(z) {
      return { trackEgress: q(z.trackEgress) ? v.AutoTrackEgress.fromJSON(z.trackEgress) : void 0 };
    },
    toJSON(z) {
      const P = {};
      return z.trackEgress !== void 0 && (P.trackEgress = z.trackEgress ? v.AutoTrackEgress.toJSON(z.trackEgress) : void 0), P;
    },
    fromPartial(z) {
      const P = be();
      return P.trackEgress = z.trackEgress !== void 0 && z.trackEgress !== null ? v.AutoTrackEgress.fromPartial(z.trackEgress) : void 0, P;
    }
  };
  var ke = (() => {
    if (typeof ke < "u")
      return ke;
    if (typeof self < "u")
      return self;
    if (typeof window < "u")
      return window;
    if (typeof commonjsGlobal$1 < "u")
      return commonjsGlobal$1;
    throw "Unable to locate global object";
  })();
  function Te(z) {
    if (z.gt(Number.MAX_SAFE_INTEGER))
      throw new ke.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    return z.toNumber();
  }
  l.default.util.Long !== c.default && (l.default.util.Long = c.default, l.default.configure());
  function q(z) {
    return z != null;
  }
})(livekit_internal);
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(O, D, F, H) {
    H === void 0 && (H = F), Object.defineProperty(O, H, { enumerable: !0, get: function() {
      return D[F];
    } });
  } : function(O, D, F, H) {
    H === void 0 && (H = F), O[H] = D[F];
  }), c = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(O, D) {
    Object.defineProperty(O, "default", { enumerable: !0, value: D });
  } : function(O, D) {
    O.default = D;
  }), l = commonjsGlobal$1 && commonjsGlobal$1.__exportStar || function(O, D) {
    for (var F in O)
      F !== "default" && !Object.prototype.hasOwnProperty.call(D, F) && u(D, O, F);
  }, v = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(O) {
    if (O && O.__esModule)
      return O;
    var D = {};
    if (O != null)
      for (var F in O)
        F !== "default" && Object.prototype.hasOwnProperty.call(O, F) && u(D, O, F);
    return c(D, O), D;
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.LivekitInternal = a.TrackType = a.TrackInfo = a.Room = a.ParticipantPermission = a.ParticipantInfo_State = a.ParticipantInfo = a.DataPacket_Kind = a.IngressVideoOptions = a.IngressState = a.IngressInput = a.IngressInfo = a.IngressAudioOptions = a.StreamProtocol = a.StreamOutput = a.SegmentedFileProtocol = a.SegmentedFileOutput = a.EncodingOptionsPreset = a.EncodingOptions = a.EncodedFileType = a.EncodedFileOutput = a.EgressInfo = a.DirectFileOutput = void 0, l(AccessToken$1, a), l(EgressClient$1, a), l(grants, a), l(IngressClient$1, a);
  var p = livekit_egress;
  Object.defineProperty(a, "DirectFileOutput", { enumerable: !0, get: function() {
    return p.DirectFileOutput;
  } }), Object.defineProperty(a, "EgressInfo", { enumerable: !0, get: function() {
    return p.EgressInfo;
  } }), Object.defineProperty(a, "EncodedFileOutput", { enumerable: !0, get: function() {
    return p.EncodedFileOutput;
  } }), Object.defineProperty(a, "EncodedFileType", { enumerable: !0, get: function() {
    return p.EncodedFileType;
  } }), Object.defineProperty(a, "EncodingOptions", { enumerable: !0, get: function() {
    return p.EncodingOptions;
  } }), Object.defineProperty(a, "EncodingOptionsPreset", { enumerable: !0, get: function() {
    return p.EncodingOptionsPreset;
  } }), Object.defineProperty(a, "SegmentedFileOutput", { enumerable: !0, get: function() {
    return p.SegmentedFileOutput;
  } }), Object.defineProperty(a, "SegmentedFileProtocol", { enumerable: !0, get: function() {
    return p.SegmentedFileProtocol;
  } }), Object.defineProperty(a, "StreamOutput", { enumerable: !0, get: function() {
    return p.StreamOutput;
  } }), Object.defineProperty(a, "StreamProtocol", { enumerable: !0, get: function() {
    return p.StreamProtocol;
  } });
  var _ = livekit_ingress;
  Object.defineProperty(a, "IngressAudioOptions", { enumerable: !0, get: function() {
    return _.IngressAudioOptions;
  } }), Object.defineProperty(a, "IngressInfo", { enumerable: !0, get: function() {
    return _.IngressInfo;
  } }), Object.defineProperty(a, "IngressInput", { enumerable: !0, get: function() {
    return _.IngressInput;
  } }), Object.defineProperty(a, "IngressState", { enumerable: !0, get: function() {
    return _.IngressState;
  } }), Object.defineProperty(a, "IngressVideoOptions", { enumerable: !0, get: function() {
    return _.IngressVideoOptions;
  } });
  var k = livekit_models;
  Object.defineProperty(a, "DataPacket_Kind", { enumerable: !0, get: function() {
    return k.DataPacket_Kind;
  } }), Object.defineProperty(a, "ParticipantInfo", { enumerable: !0, get: function() {
    return k.ParticipantInfo;
  } }), Object.defineProperty(a, "ParticipantInfo_State", { enumerable: !0, get: function() {
    return k.ParticipantInfo_State;
  } }), Object.defineProperty(a, "ParticipantPermission", { enumerable: !0, get: function() {
    return k.ParticipantPermission;
  } }), Object.defineProperty(a, "Room", { enumerable: !0, get: function() {
    return k.Room;
  } }), Object.defineProperty(a, "TrackInfo", { enumerable: !0, get: function() {
    return k.TrackInfo;
  } }), Object.defineProperty(a, "TrackType", { enumerable: !0, get: function() {
    return k.TrackType;
  } }), l(RoomServiceClient$1, a), l(WebhookReceiver$1, a), a.LivekitInternal = v(livekit_internal);
})(dist);
class InvalidTokenError extends Error {
}
InvalidTokenError.prototype.name = "InvalidTokenError";
function b64DecodeUnicode(a) {
  return decodeURIComponent(atob(a).replace(/(.)/g, (u, c) => {
    let l = c.charCodeAt(0).toString(16).toUpperCase();
    return l.length < 2 && (l = "0" + l), "%" + l;
  }));
}
function base64UrlDecode(a) {
  let u = a.replace(/-/g, "+").replace(/_/g, "/");
  switch (u.length % 4) {
    case 0:
      break;
    case 2:
      u += "==";
      break;
    case 3:
      u += "=";
      break;
    default:
      throw new Error("base64 string is not of the correct length");
  }
  try {
    return b64DecodeUnicode(u);
  } catch {
    return atob(u);
  }
}
function jwtDecode(a, u) {
  if (typeof a != "string")
    throw new InvalidTokenError("Invalid token specified: must be a string");
  u || (u = {});
  const c = u.header === !0 ? 0 : 1, l = a.split(".")[c];
  if (typeof l != "string")
    throw new InvalidTokenError(`Invalid token specified: missing part #${c + 1}`);
  let v;
  try {
    v = base64UrlDecode(l);
  } catch (p) {
    throw new InvalidTokenError(`Invalid token specified: invalid base64 for part #${c + 1} (${p.message})`);
  }
  try {
    return JSON.parse(v);
  } catch (p) {
    throw new InvalidTokenError(`Invalid token specified: invalid json for part #${c + 1} (${p.message})`);
  }
}
var DataType = /* @__PURE__ */ ((a) => (a.ChatMessage = "ChatMessage", a.ParticipantMetadataUpdate = "ParticipantMetadataUpdate", a))(DataType || {}), SpecialEvent = /* @__PURE__ */ ((a) => (a.Chat = "Chat", a))(SpecialEvent || {});
const decoder$1 = new TextDecoder(), encoder$1 = new TextEncoder();
class RoomsManager {
  constructor() {
    Ft(this, "rooms");
    this.rooms = /* @__PURE__ */ new Map(), this.addRoom = this.addRoom.bind(this), this.ensureRoom = this.ensureRoom.bind(this), this.removeRoom = this.removeRoom.bind(this);
  }
  addRoom(u, c, l) {
    const v = new RoomContext(u, c, l, this);
    return this.rooms.set(c, v), v;
  }
  ensureRoom(u, c, l) {
    return this.rooms.get(c) ? (this.rooms.get(c).token = l, this.rooms.get(c)) : this.addRoom(u, c, l);
  }
  async removeRoom(u) {
    const c = this.rooms.get(u);
    if (!Room)
      throw new Error("room not found!");
    if (c.isConnecting)
      throw new Error("Cannot remove room: Room is in connecting state");
    c.livekitRoom && await c.livekitRoom.disconnect(!0), this.rooms.delete(u);
  }
}
class RoomContext {
  /**
   * @param baseUrl base url for the webrtc server
   * @param token get
   */
  constructor(u, c, l, v) {
    /**
     * base URL for the webrtc server
     */
    Ft(this, "_baseUrl");
    Ft(this, "_chatHistory");
    /**
     * event listeners just for livekit room connect
     */
    Ft(this, "_connectListeners");
    /**
     * Event listeners that are registered OR to be registered upon connection
     * Keys are of type RoomEvent
     */
    Ft(this, "_roomEventListenerRegistry");
    /**
     * Event listeners that are registered OR to be registered on the localParticipant upon connection
     * Keys are of type ParticipantEvent
     */
    Ft(this, "_localParticipantEventListenerRegistry");
    /**
     * Registry for special/custom events such as chat events
     */
    Ft(this, "_specialEventListenerRegistry");
    /**
     * access token for our connection
     * Should be acquired from vapi
     */
    Ft(this, "_jwt");
    /**
     * reference to the rooms manager that contains it
     */
    Ft(this, "_manager");
    Ft(this, "_apiClient");
    Ft(this, "audioTracks");
    Ft(this, "isConnecting");
    Ft(this, "livekitRoom");
    Ft(this, "participants");
    Ft(this, "guestParticipantMetadata");
    Ft(this, "roomName");
    /**
     * Livekit Room Service client, for performing admin functions
     * Should only be defined if user is room admin
     */
    Ft(this, "_admin");
    let p = CoreContext.logLevel.toLowerCase();
    setLogLevel(p), this.livekitRoom = new Room({
      // automatically manage subscribed video quality
      // adaptiveStream: true,
      // optimize publishing bandwidth and CPU for published tracks
      dynacast: !0,
      // default capture settings
      videoCaptureDefaults: {
        resolution: VideoPresets.h720.resolution
      }
    }), this._baseUrl = u, this._connectListeners = [], this._roomEventListenerRegistry = {}, this._jwt = l, Object.values(RoomEvent).forEach((_) => {
      this._roomEventListenerRegistry[_] = /* @__PURE__ */ new Set();
    }), this._localParticipantEventListenerRegistry = {}, Object.values(ParticipantEvent).forEach((_) => {
      this._localParticipantEventListenerRegistry[_] = /* @__PURE__ */ new Set();
    }), this._specialEventListenerRegistry = {}, this._manager = v, this._chatHistory = [], this.roomName = c, this.audioTracks = [], this.participants = [], this.guestParticipantMetadata = [], this.isConnecting = !1, this.subscribeToRoomEvent(RoomEvent.DataReceived, (_, k) => {
      var F;
      const O = decoder$1.decode(_);
      switch (JSON.parse(O).type) {
        case "ChatMessage":
          return this._appendChat(_, k);
        case "ParticipantMetadataUpdate": {
          const H = decoder$1.decode(_), Z = JSON.parse(H);
          hasPermission((F = Z == null ? void 0 : Z.metadata) == null ? void 0 : F.participantRole, Permission.ManageSelf) && this._updateGuestParticipantsStore(Z);
          return;
        }
        default:
          return;
      }
    }), this.connect = this.connect.bind(this), this.subscribeToRoomEvent = this.subscribeToRoomEvent.bind(this), this.subscribeToConnect = this.subscribeToConnect.bind(this), this.subscribeToLocalParticipantEvent = this.subscribeToLocalParticipantEvent.bind(this), this.subscribeToSpecialEvent = this.subscribeToSpecialEvent.bind(this), this.unsubscribeFromRoomEvent = this.unsubscribeFromRoomEvent.bind(this), this.unsubscribeFromSpecialEvent = this.unsubscribeFromSpecialEvent.bind(this), this.unsubscribeFromConnect = this.unsubscribeFromConnect.bind(this), this.unsubscribeFromLocalParticipantEvent = this.unsubscribeFromLocalParticipantEvent.bind(this), this.sendChatMessage = this.sendChatMessage.bind(this), this.kickParticipant = this.kickParticipant.bind(this), this.updateParticipant = this.updateParticipant.bind(this), this.muteTrackAsAdmin = this.muteTrackAsAdmin.bind(this), this._updateParticipants = this._updateParticipants.bind(this), this.subscribeToRoomEvent(RoomEvent.ParticipantConnected, this._updateParticipants), this.subscribeToRoomEvent(RoomEvent.ParticipantDisconnected, this._updateParticipants), this.subscribeToRoomEvent(RoomEvent.TrackSubscribed, this._updateParticipants), this.subscribeToRoomEvent(RoomEvent.TrackUnsubscribed, this._updateParticipants), this.subscribeToRoomEvent(RoomEvent.LocalTrackPublished, this._updateParticipants), this.subscribeToRoomEvent(RoomEvent.LocalTrackUnpublished, this._updateParticipants), this.subscribeToRoomEvent(RoomEvent.Disconnected, () => {
      this._updateParticipants();
    }), this.subscribeToRoomEvent(RoomEvent.ParticipantMetadataChanged, (_, k) => {
      if (_ !== (k == null ? void 0 : k.metadata)) {
        const O = JSON.parse(k == null ? void 0 : k.metadata);
        if (hasPermission(O == null ? void 0 : O.participantRole, Permission.ManageSelf)) {
          if (O.hasOwnProperty("isMirrored")) {
            const D = {
              participantId: k == null ? void 0 : k.identity,
              metadata: O,
              type: "ParticipantMetadataUpdate"
              /* ParticipantMetadataUpdate */
            };
            this._updateGuestParticipantsStore(D);
          }
          return;
        }
      }
    });
  }
  bindApiClient(u) {
    this._apiClient = u;
  }
  get isAdmin() {
    return jwtDecode(this._jwt).video.roomAdmin;
  }
  set isAdmin(u) {
    log.warn("isAdmin cannot be set");
  }
  get token() {
    return this._jwt;
  }
  set token(u) {
    this._jwt = u;
  }
  get url() {
    return this._baseUrl;
  }
  set url(u) {
  }
  get chatHistory() {
    return this._chatHistory;
  }
  set chatHistory(u) {
    this._chatHistory = u;
  }
  _updateGuestParticipantsStore(u) {
    if (!this.guestParticipantMetadata.length)
      this.guestParticipantMetadata.push(u);
    else {
      const c = this.guestParticipantMetadata.findIndex((l) => l.participantId === (u == null ? void 0 : u.participantId));
      c > -1 ? this.guestParticipantMetadata[c] = u : this.guestParticipantMetadata.push(u);
    }
  }
  _updateParticipants() {
    if (!this.livekitRoom || this.livekitRoom.state === ConnectionState.Disconnected) {
      this.participants = [];
      return;
    } else {
      const u = Array.from(this.livekitRoom.remoteParticipants.values()), c = [this.livekitRoom.localParticipant];
      c.push(...u), this.guestParticipantMetadata = this.guestParticipantMetadata.filter((l) => c.find((v) => (v == null ? void 0 : v.identity) === (l == null ? void 0 : l.participantId))), this.participants = c;
    }
  }
  /**
   * @param identity Identity of the user that you wish to kick
   */
  async kickParticipant(u) {
    if (this._admin)
      this._admin.removeParticipant(this.roomName, u);
    else
      throw new Error("no admin permissions");
  }
  updateParticipant(u, c) {
    if (this._admin) {
      const l = JSON.stringify(c);
      this._admin.updateParticipant(this.roomName, u, l);
    } else
      throw new Error("no admin permissions");
  }
  muteTrackAsAdmin(u, c = !0) {
    if (this._admin) {
      const l = this.participants.find((v) => [...v.audioTrackPublications.values(), ...v.videoTrackPublications.values()].find((p) => p.trackSid === u));
      if (!l) {
        log.warn("Could not find participant for track:", {
          trackSid: u
        });
        return;
      }
      this._admin.mutePublishedTrack(this.roomName, l == null ? void 0 : l.identity, u, c);
    } else
      throw new Error("no admin permissions");
  }
  _appendChat(u, c) {
    const l = decoder$1.decode(u), v = JSON.parse(l), p = c.identity, _ = c.name, k = {
      ...v,
      displayName: _,
      sender: p
    };
    this.chatHistory = [...this.chatHistory, k], this._triggerSpecialEvents("Chat", k);
  }
  subscribeToConnect(u) {
    return this._connectListeners.push(u), () => this.unsubscribeFromConnect(u);
  }
  unsubscribeFromConnect(u) {
    this._connectListeners = this._connectListeners.filter((c) => c !== u);
  }
  subscribeToSpecialEvent(u, c) {
    return this._specialEventListenerRegistry[u] || (this._specialEventListenerRegistry[u] = /* @__PURE__ */ new Set()), this._specialEventListenerRegistry[u].add(c), () => {
      this.unsubscribeFromSpecialEvent(u, c);
    };
  }
  unsubscribeFromSpecialEvent(u, c) {
    this._specialEventListenerRegistry[u] || (this._specialEventListenerRegistry[u] = /* @__PURE__ */ new Set()), this._specialEventListenerRegistry[u].delete(c);
  }
  _triggerSpecialEvents(u, ...c) {
    this._specialEventListenerRegistry[u] || (this._specialEventListenerRegistry[u] = /* @__PURE__ */ new Set()), this._specialEventListenerRegistry[u].forEach((l) => {
      l(...c);
    });
  }
  /**
   * connect to livekit webrtc room
   * @param {string} identity unique user name to be displayed to other users
   */
  async connect(u = {}) {
    var c, l;
    try {
      if (this.livekitRoom.state === "connected" || this.isConnecting)
        return;
      this.isConnecting = !0, await this.livekitRoom.connect(`wss://${this._baseUrl}`, this._jwt, {
        ...u
      }), this.isConnecting = !1, Object.values(RoomEvent).forEach((v) => {
        this.livekitRoom.on(v, (...p) => {
          this._roomEventListenerRegistry[v].forEach((_) => {
            _(...p);
          });
        });
      }), Object.values(ParticipantEvent).forEach((v) => {
        this.livekitRoom.localParticipant.on(v, (...p) => {
          this._localParticipantEventListenerRegistry[v].forEach((_) => {
            _(...p);
          });
        });
      }), this._updateParticipants(), this._connectListeners.forEach((v) => v(this.livekitRoom)), lib$2.LiveKitUtils.isRoomAdmin(this._jwt) ? (log.info("Room: Granting admin permissions"), log.debug("Livekit server: ", (c = this._apiClient) == null ? void 0 : c.getLiveKitServer(!0)), this._admin = new dist.RoomServiceClient((l = this._apiClient) == null ? void 0 : l.getLiveKitServer(!0), void 0, void 0, this._jwt)) : log.debug("Room: Not an admin");
    } catch (v) {
      this.isConnecting = !1, log.error(v);
    }
  }
  subscribeToLocalParticipantEvent(u, c) {
    return this._localParticipantEventListenerRegistry[u] || (this._localParticipantEventListenerRegistry[u] = /* @__PURE__ */ new Set()), this._localParticipantEventListenerRegistry[u].add(c), () => {
      this.unsubscribeFromLocalParticipantEvent(u, c);
    };
  }
  unsubscribeFromLocalParticipantEvent(u, c) {
    this._localParticipantEventListenerRegistry[u] || (this._localParticipantEventListenerRegistry[u] = /* @__PURE__ */ new Set()), this._localParticipantEventListenerRegistry[u].delete(c);
  }
  subscribeToRoomEvent(u, c) {
    return this._roomEventListenerRegistry[u] || (this._roomEventListenerRegistry[u] = /* @__PURE__ */ new Set()), this._roomEventListenerRegistry[u].add(c), () => {
      this.unsubscribeFromRoomEvent(u, c);
    };
  }
  unsubscribeFromRoomEvent(u, c) {
    this._roomEventListenerRegistry[u] || (this._roomEventListenerRegistry[u] = /* @__PURE__ */ new Set()), this._roomEventListenerRegistry[u].delete(c);
  }
  /**
   * Sends chat message to entire livekit room, or a private message (if specified) from local participant
   * @param {string[]} [recipients] The identities of the recipient participants. If undefined, will send message to all participants in the chat.
   * Only specify for private messages.
   * Do not include the local participant's identity in this.
   */
  sendChatMessage(u) {
    const {
      message: c,
      recipients: l,
      metadata: v
    } = u;
    if (!this.livekitRoom || this.livekitRoom.state !== "connected")
      return;
    const p = {
      type: "ChatMessage",
      recipients: l,
      metadata: v,
      content: c,
      timestamp: Date.now()
    }, _ = JSON.stringify(p), k = encoder$1.encode(_);
    if ({
      ...p,
      sender: this.livekitRoom.localParticipant.identity,
      displayName: this.livekitRoom.localParticipant.identity
    }, l) {
      const O = l.map(this.livekitRoom.getParticipantByIdentity);
      return this.livekitRoom.localParticipant.publishData(k, {
        reliable: !0,
        destinationIdentities: O.map((D) => D.identity)
      }).then(() => {
        this._appendChat(k, this.livekitRoom.localParticipant);
      });
    } else
      return this.livekitRoom.localParticipant.publishData(k, {
        reliable: !0
      }).then(() => {
        this._appendChat(k, this.livekitRoom.localParticipant);
      });
  }
}
const webrtcManager = new RoomsManager(), index$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  webrtcManager
}, Symbol.toStringTag, { value: "Module" })), encoder = new TextEncoder(), decoder = new TextDecoder(), simpleRooms = /* @__PURE__ */ new Map(), getRoom = (a) => {
  if (!a)
    return null;
  if (simpleRooms.get(a))
    return simpleRooms.get(a);
  const u = webrtcManager.rooms.get(a);
  if (!u)
    return null;
  const c = u.livekitRoom, l = c == null ? void 0 : c.localParticipant;
  window.__StudioRoom = c, l || log.warn("No local participant!");
  const v = {
    useTracks: /* @__PURE__ */ new Set(),
    useTrack: /* @__PURE__ */ new Map(),
    useParticipants: /* @__PURE__ */ new Set(),
    useParticipant: /* @__PURE__ */ new Map(),
    useChatHistory: /* @__PURE__ */ new Set()
  };
  let p = {
    tracks: [],
    participants: [],
    result: {
      participants: [],
      tracks: []
    },
    chat: u.chatHistory
  };
  const _ = () => {
    const ne = u.participants, Q = u.guestParticipantMetadata, ae = ne.flatMap((ue) => ue.getTrackPublications().map((he) => ({
      ...he,
      participant: ue
    }))), j = {
      participants: ne.map((ue) => {
        const he = Q.find((be) => be.participantId === ue.identity);
        if (he) {
          let be = JSON.parse(ue.metadata);
          be = {
            ...be,
            ...he.metadata
          }, ue.metadata = JSON.stringify(be);
        }
        const fe = JSON.parse(ue.metadata);
        return {
          id: ue.identity,
          isSelf: ue === l,
          connectionQuality: ue.connectionQuality,
          displayName: fe.displayName || ue.name,
          joinedAt: ue.joinedAt,
          role: fe.participantRole,
          meta: fe,
          trackIds: ae.filter((be) => be.participant.sid === ue.sid).map((be) => be.trackSid)
        };
      }),
      tracks: ae.map((ue) => {
        var fe, be, ke, Te;
        const he = JSON.parse((fe = ue == null ? void 0 : ue.participant) == null ? void 0 : fe.metadata);
        return {
          mediaStreamTrack: (be = ue.track) == null ? void 0 : be.mediaStreamTrack,
          id: ue.trackSid,
          participantId: (ke = ue.participant) == null ? void 0 : ke.identity,
          isMuted: (Te = ue.track) == null ? void 0 : Te.isMuted,
          type: ue.source,
          isExternal: !!(he != null && he[ue.trackSid])
        };
      })
    };
    p = {
      tracks: ae,
      participants: ne,
      result: j,
      chat: u.chatHistory
    }, v.useTracks.forEach((ue) => ue(j.tracks)), v.useTrack.forEach((ue, he) => {
      he(D(ue));
    }), v.useParticipants.forEach((ue) => ue(j.participants)), v.useParticipant.forEach((ue, he) => {
      he(F(ue));
    }), v.useChatHistory.forEach((ue) => {
      ue(p.chat);
    });
  }, k = [RoomEvent.ParticipantConnected, RoomEvent.ParticipantDisconnected, RoomEvent.ParticipantMetadataChanged, RoomEvent.Disconnected, RoomEvent.TrackSubscribed, RoomEvent.TrackUnsubscribed, RoomEvent.LocalTrackPublished, RoomEvent.LocalTrackUnpublished, RoomEvent.ConnectionQualityChanged, RoomEvent.TrackMuted, RoomEvent.TrackUnmuted, RoomEvent.TrackStreamStateChanged];
  u.subscribeToRoomEvent(RoomEvent.DataReceived, (ne, Q, ae) => {
    const j = decoder.decode(ne);
    JSON.parse(j).type === DataType.ParticipantMetadataUpdate && _();
  }), k.map((ne) => u.subscribeToRoomEvent(ne, () => _())).push(u.subscribeToSpecialEvent(SpecialEvent.Chat, _));
  const D = (ne) => p.result.tracks.find((Q) => Q.id === ne), F = (ne) => p.result.participants.find((Q) => Q.id === ne), H = (ne, Q) => {
    const ae = l.getTrackPublications().find((j) => j.trackSid === ne);
    ae && (Q ? ae.mute() : ae.unmute());
  };
  let Z, ee;
  const X = {
    id: u.roomName,
    participantId: l.identity,
    setTrackEnabled: H,
    setCameraEnabled: (ne = !0) => l.setCameraEnabled(ne),
    setMicrophoneEnabled: (ne = !0) => l.setMicrophoneEnabled(ne),
    setCamera: async (ne = {}) => {
      var ae;
      if (Z) {
        log.warn("Cannot set camera until previous has resolved");
        return;
      }
      Z = !0;
      let Q;
      try {
        const ue = l.getTrackPublications().filter((fe) => (fe == null ? void 0 : fe.source) === Track.Source.Camera).find((fe) => !D(fe == null ? void 0 : fe.trackSid).isExternal), he = await l.createTracks({
          video: {
            deviceId: ne.deviceId,
            resolution: ne.resolution || {
              width: 1280,
              height: 720,
              frameRate: 30,
              aspectRatio: 16 / 9
            }
          }
        });
        ue != null && ue.isMuted && he.forEach((fe) => {
          fe.mute();
        }), Q = await Promise.all(he.map((fe) => l.publishTrack(fe))), ue && l.unpublishTrack(ue.track);
      } catch (j) {
        throw j;
      } finally {
        return Z = !1, D((ae = Q[0]) == null ? void 0 : ae.trackSid);
      }
    },
    setMicrophone: async (ne) => {
      var ae;
      if (ee) {
        log.warn("Cannot set microphone until previous has resolved");
        return;
      }
      ee = !0;
      let Q;
      try {
        const ue = l.getTrackPublications().filter((fe) => fe.source === Track.Source.Microphone).find((fe) => !D(fe == null ? void 0 : fe.trackSid).isExternal), he = await l.createTracks({
          audio: ne || !0
        });
        ue != null && ue.isMuted && he.forEach((fe) => {
          fe.mute();
        }), Q = await Promise.all(he.map((fe) => l.publishTrack(fe))), ue && l.unpublishTrack(ue.track);
      } catch (j) {
        throw j;
      } finally {
        return ee = !1, D((ae = Q[0]) == null ? void 0 : ae.trackSid);
      }
    },
    addMicrophone: async (ne) => {
      var he;
      if (ee) {
        log.warn("Cannot set microphone until previous has resolved");
        return;
      }
      ee = !0;
      const Q = await l.createTracks({
        audio: ne || !0
      }), j = l.getTrackPublications().filter((fe) => fe.source === Track.Source.Microphone).find((fe) => {
        var ke, Te;
        const be = D(fe == null ? void 0 : fe.trackSid);
        ((Te = (ke = be == null ? void 0 : be.mediaStreamTrack) == null ? void 0 : ke.getSettings()) == null ? void 0 : Te.deviceId) === ne.deviceId && (be == null || be.isExternal);
      });
      j != null && j.isMuted && Q.forEach((fe) => {
        fe.mute();
      });
      const ue = await Promise.all(Q.map((fe) => l.publishTrack(fe)));
      return j && l.unpublishTrack(j.track), ee = !1, D((he = ue[0]) == null ? void 0 : he.trackSid);
    },
    addCamera: async (ne = {}) => {
      var ue;
      const Q = await l.createTracks({
        video: {
          deviceId: ne.deviceId,
          resolution: ne.resolution || {
            width: 1280,
            height: 720,
            frameRate: 30,
            aspectRatio: 1.7777777777777777
          }
        }
      }), ae = l.getTrackPublications().find((he) => {
        var fe, be, ke;
        return (he == null ? void 0 : he.source) === Track.Source.Camera && ((ke = (be = (fe = he == null ? void 0 : he.track) == null ? void 0 : fe.mediaStreamTrack) == null ? void 0 : be.getSettings()) == null ? void 0 : ke.deviceId) === ne.deviceId;
      });
      ae != null && ae.isMuted && Q.forEach((he) => {
        he.mute();
      });
      const j = await Promise.all(Q.map((he) => l.publishTrack(he)));
      return ae && l.unpublishTrack(ae.track), ee = !1, D((ue = j[0]) == null ? void 0 : ue.trackSid);
    },
    addScreen: async (ne = {
      audio: !1
    }) => {
      const Q = await l.createScreenTracks(ne), ae = await Promise.all(Q.map((he) => l.publishTrack(he))), j = ae.find((he) => he.kind === "video"), ue = ae.find((he) => he.kind === "audio");
      return {
        screen: D(j == null ? void 0 : j.trackSid),
        audio: D(ue == null ? void 0 : ue.trackSid)
      };
    },
    removeTrack: async (ne) => {
      const Q = p.tracks.find((ae) => ae.trackSid === ne);
      l.unpublishTrack(Q.track);
    },
    /* Setting the local participant metadata. */
    setLocalParticipantMetadata: async (ne, Q) => {
      const ae = JSON.stringify(Q), j = encoder.encode(JSON.stringify({
        metadata: Q,
        type: DataType.ParticipantMetadataUpdate,
        participantId: ne
      }));
      return l.setMetadata(ae), await l.publishData(j, {
        reliable: !0
      });
    },
    setParticipantMetadata: (ne, Q) => u.updateParticipant(ne, Q),
    kickParticipant: u.kickParticipant,
    muteTrackAsAdmin: u.muteTrackAsAdmin,
    sendChatMessage: u.sendChatMessage,
    // Callbacks
    getTracks: () => p.result.tracks,
    useTracks: (ne) => (v.useTracks.add(ne), ne(p.result.tracks), () => {
      v.useTracks.delete(ne);
    }),
    getTrack: D,
    useTrack: (ne, Q) => (v.useTrack.set(Q, ne), Q(D(ne)), () => {
      v.useTrack.delete(Q);
    }),
    getParticipant: F,
    getParticipants: () => p.result.participants,
    useParticipants: (ne) => (v.useParticipants.add(ne), ne(p.result.participants), () => {
      v.useParticipants.delete(ne);
    }),
    useParticipant: (ne, Q) => (v.useParticipant.set(Q, ne), Q(F(ne)), () => {
      v.useTrack.delete(Q);
    }),
    useChatHistory: (ne) => (v.useChatHistory.add(ne), ne(p.chat), () => {
      v.useChatHistory.delete(ne);
    }),
    useActiveSpeakers: (ne) => {
      var ae, j;
      const Q = (ue) => {
        ne(ue.map((he) => he.identity));
      };
      return (ae = u.livekitRoom) == null || ae.on(RoomEvent.ActiveSpeakersChanged, Q), Q((j = u.livekitRoom) == null ? void 0 : j.activeSpeakers), () => {
        var ue;
        (ue = u.livekitRoom) == null || ue.off(RoomEvent.ActiveSpeakersChanged, Q);
      };
    },
    sendData: (ne, Q = []) => {
      const ae = encoder.encode(JSON.stringify(ne)), j = Q == null ? void 0 : Q.map((ue) => {
        var he;
        return (he = u.livekitRoom) == null ? void 0 : he.getParticipantByIdentity(ue);
      }).filter(Boolean);
      return l.publishData(ae, {
        reliable: !0,
        destinationIdentities: j.map((ue) => ue.identity)
      });
    },
    onData: (ne) => {
      var ae;
      const Q = (j, ue) => {
        const he = JSON.parse(decoder.decode(j));
        ne(he, ue == null ? void 0 : ue.identity);
      };
      return (ae = u.livekitRoom) == null || ae.on(RoomEvent.DataReceived, Q), () => {
        var j;
        (j = u.livekitRoom) == null || j.off(RoomEvent.DataReceived, Q);
      };
    },
    connect: () => u.connect(),
    disconnect: () => {
      var ne;
      return (ne = u.livekitRoom) == null ? void 0 : ne.disconnect();
    },
    onDisconnected: (ne) => {
      var Q;
      return (Q = u.livekitRoom) == null || Q.on(RoomEvent.Disconnected, ne), () => {
        var ae;
        (ae = u.livekitRoom) == null || ae.off(RoomEvent.DataReceived, ne);
      };
    },
    setAudioOutput: (ne) => {
      var Q;
      return (Q = u.livekitRoom) == null ? void 0 : Q.switchActiveDevice("audiooutput", ne);
    }
  };
  return _(), simpleRooms.set(a, X), X;
}, {
  state: state$2
} = CoreContext, getAccessTokenData = () => {
  var a;
  return ((a = CoreContext.clients.accessTokenClaims) == null ? void 0 : a.user) || {};
}, getBaseUser = () => state$2.user ? {
  id: state$2.user.id,
  props: state$2.user.props,
  name: state$2.user.name,
  projects: state$2.projects.map(toBaseProject),
  sources: state$2.sources.map(toBaseSource)
} : null, toBaseProject = (a) => {
  const {
    compositor: u,
    videoApi: c,
    props: l = {},
    role: v
  } = a, {
    destinations: p,
    encoding: _,
    rendering: k,
    sources: O
  } = c.project, D = {
    get: u.get,
    getRoot: u.getRoot,
    getParent: u.getParent
  };
  Object.defineProperty(D, "nodes", {
    get() {
      return u.nodes.filter((Z) => !Z._deleted);
    }
  });
  const F = a.videoApi.phase, H = a.videoApi.broadcastId || null;
  return {
    broadcastPhase: F,
    role: v,
    broadcastId: H,
    layoutId: a.layoutApi.layoutId,
    isLive: [ProjectBroadcastPhase.PROJECT_BROADCAST_PHASE_RUNNING, ProjectBroadcastPhase.PROJECT_BROADCAST_PHASE_STOPPING].includes(F),
    scene: D,
    joinRoom: async (Z = {}) => CoreContext.Command.joinRoom({
      projectId: a.id,
      ...Z
    }),
    subscribe: (Z) => CoreContext.subscribe((ee, X) => {
      X.projectId && (X == null ? void 0 : X.projectId) === a.id && Z(ee, X);
    }),
    destinations: p.map(toBaseDestination),
    sources: O.map(toBaseSource),
    encoding: _,
    rendering: k,
    id: a.id,
    hostDisplayName: a.props.hostDisplayName,
    props: l
  };
}, toBaseDestination = (a) => {
  var u;
  return {
    id: a.destinationId,
    enabled: a.enabled,
    address: a.address,
    // For backward compatibility, fall back to "metadata" as props.
    //  All new projects have a dedicated "props" field
    props: ((u = a.metadata) == null ? void 0 : u.props) || (a == null ? void 0 : a.metadata) || {}
  };
}, toBaseSource = (a) => {
  var u;
  return {
    id: a.sourceId,
    address: a.address,
    preview: a.preview,
    props: ((u = a.metadata) == null ? void 0 : u.props) || {}
  };
}, hydrateProject = async (a, u, c) => {
  const l = a.metadata || {}, v = {
    collectionId: a.collectionId,
    projectId: a.projectId,
    updateMask: []
  };
  hasPermission(u, Permission.ManageBroadcast) && a.composition.studioSdk.version !== CoreContext.rendererVersion && (v.composition = {
    studioSdk: {
      version: CoreContext.rendererVersion
    }
  }, v.updateMask.push("composition.studioSdk.version")), c && (v.rendering = {
    video: {
      width: c.x,
      height: c.y,
      framerate: 30
    }
  }, v.updateMask.push("rendering")), v.updateMask.length && await CoreContext.clients.LiveApi().project.updateProject(v);
  const _ = await layoutToProject(l.layoutId, c);
  return {
    id: a.projectId,
    compositor: _,
    role: u,
    videoApi: {
      project: a,
      phase: ProjectBroadcastPhase.PROJECT_BROADCAST_PHASE_UNSPECIFIED
    },
    layoutApi: {
      layoutId: l.layoutId
    },
    // For backward compatibility, fall back to "metadata" as props.
    //  All new projects have a dedicated "props" field
    props: (l == null ? void 0 : l.props) || l
  };
}, sceneNodeToLayer = (a) => {
  const {
    id: u,
    props: c = {},
    children: l = []
  } = a;
  return {
    ...u ? {
      id: u
    } : {},
    type: c.type,
    data: {
      ...c
    },
    children: l.map((v) => v.id)
  };
}, nodeToLayer = (a) => ({
  id: a.id,
  type: a.props.type,
  data: {
    ...a.props
  },
  children: a.childIds.map((u) => u)
}), layerToNode = (a) => ({
  id: String(a.id),
  props: {
    type: a.type,
    ...a.data
  },
  childIds: a.children.map((u) => String(u))
}), layoutToProject = async (a, u) => {
  const {
    layers: c
  } = await CoreContext.clients.LayoutApi().layer.listLayers({
    layoutId: a
  });
  if (u && c) {
    const {
      x: _,
      y: k
    } = u, O = c == null ? void 0 : c.reduce((D, F) => D ? D.data.isRoot ? D : F.data.isRoot || !c.some((H) => H.children.includes(F.id)) ? F : D : F, null);
    if (O) {
      const D = await CoreContext.clients.LayoutApi().layer.updateLayer({
        layoutId: O.layoutId,
        layerId: O.id,
        layer: {
          x: _,
          y: k,
          data: {
            ...O.data,
            size: {
              x: _,
              y: k
            }
          }
        }
      }), F = c.findIndex((H) => H.id === D.id);
      c[F] = D;
    }
  }
  const l = c.map(layerToNode), v = l.reduce((_, k) => _ ? _.props.isRoot ? _ : k.props.isRoot || !l.some((O) => O.childIds.includes(k.id)) ? k : _ : k, null), p = v ? toSceneTree(l, v.id) : null;
  return CoreContext.compositor.loadProject(p, a);
}, getUser = () => {
  const a = state$2.user;
  if (!a)
    throw new Error("User not loaded");
  return a;
}, getProject = (a) => state$2.projects.find((u) => u.id === a), getProjectByLayoutId = (a) => state$2.projects.find((u) => u.compositor.id === a), getProjectRoom = (a) => {
  var u;
  return getRoom((u = getProject(a)) == null ? void 0 : u.roomId);
}, {
  connectionId
} = CoreContext, latestUpdateVersion = {}, getNextNodeVersion = (a) => (latestUpdateVersion[a] || (latestUpdateVersion[a] = 0), ++latestUpdateVersion[a]), request = (a, u) => {
  const c = u.map((l) => {
    const [v, p] = l;
    return {
      [v]: p
    };
  });
  return log.debug("Batch request", c), CoreContext.clients.LayoutApi().layer.batch({
    layoutId: a,
    layers: c,
    requestMetadata: {
      connectionId,
      layoutId: a,
      updateVersions: u.filter(([l]) => l === "update").map(([l, v]) => ({
        [v.id]: getNextNodeVersion(v.id)
      })).reduce((l, v) => ({
        ...v,
        ...l
      }), {})
    }
  });
}, compositorAdapter = (a, u) => ({
  async insert(c = {}, l, v) {
    const p = nodeToLayer({
      id: null,
      props: c,
      childIds: []
    });
    l ? p.type = "child" : p.type = "root", log.debug("Insert layer", p);
    const _ = await CoreContext.clients.LayoutApi().layer.createLayer({
      layoutId: a,
      layer: {
        ...p,
        requestMetadata: {
          connectionId,
          layoutId: a
        }
      }
    });
    if (_.code)
      throw new Error(_.message);
    const k = await u.get(l);
    if (l && !k)
      throw Error("Parent not found with ID");
    if (k) {
      const O = nodeToLayer(k), D = insertAt$1(v, _.id, O.children), F = {
        layoutId: a,
        layerId: O.id,
        layer: {
          children: D,
          requestMetadata: {
            connectionId,
            layoutId: a,
            updateVersion: {
              [p.id]: getNextNodeVersion(p.id)
            }
          }
        }
      };
      await CoreContext.clients.LayoutApi().layer.updateLayer(F);
    }
    return String(_.id);
  },
  async update(c, l = {}) {
    const v = u.get(c), p = nodeToLayer({
      ...v,
      props: {
        ...v.props,
        ...l
      }
    }), _ = {
      layoutId: a,
      layerId: p.id,
      layer: {
        ...p,
        requestMetadata: {
          connectionId,
          layoutId: a,
          updateVersions: {
            [p.id]: getNextNodeVersion(p.id)
          }
        }
      }
    };
    log.debug("Update layer", _), await CoreContext.clients.LayoutApi().layer.updateLayer(_);
  },
  async remove(c) {
    const l = await u.getParent(c);
    if (l) {
      const v = nodeToLayer(l), p = v.children.filter((k) => k !== c), _ = {
        layoutId: a,
        layerId: v.id,
        layer: {
          children: p,
          requestMetadata: {
            connectionId,
            layoutId: a,
            updateVersions: {
              [v.id]: getNextNodeVersion(v.id)
            }
          }
        }
      };
      await CoreContext.clients.LayoutApi().layer.updateLayer(_);
    }
    await CoreContext.clients.LayoutApi().layer.deleteLayer({
      layoutId: a,
      layerId: c,
      payload: {
        requestMetadata: {
          connectionId,
          layoutId: a
        }
      }
    });
  },
  // @ts-ignore
  async reorder(c, l) {
    const v = u.get(c), p = nodeToLayer({
      ...v,
      childIds: l
    });
    log.debug("Reorder layer children", p), await CoreContext.clients.LayoutApi().layer.updateLayer({
      layoutId: a,
      layerId: p.id,
      layer: {
        children: p.children,
        requestMetadata: {
          connectionId,
          layoutId: a,
          updateVersions: {
            [p.id]: getNextNodeVersion(p.id)
          }
        }
      }
    });
  },
  // @ts-ignore
  async move(c, l, v) {
    const p = u.get(c), _ = u.get(u.getParent(c).id), k = nodeToLayer({
      ..._,
      childIds: pull$1(_.childIds, p.id)
    }), O = u.get(l), D = nodeToLayer({
      ...O,
      childIds: insertAt$1(v, p.id, O.childIds)
    });
    log.debug("Move layers"), await Promise.all([CoreContext.clients.LayoutApi().layer.updateLayer({
      layoutId: a,
      layerId: k.id,
      layer: {
        children: k.children,
        requestMetadata: {
          connectionId,
          layoutId: a,
          updateVersions: {
            [k.id]: getNextNodeVersion(k.id)
          }
        }
      }
    }), CoreContext.clients.LayoutApi().layer.updateLayer({
      layoutId: a,
      layerId: D.id,
      layer: {
        children: D.children,
        requestMetadata: {
          connectionId,
          layoutId: a,
          updateVersions: {
            [D.id]: getNextNodeVersion(D.id)
          }
        }
      }
    })]);
  },
  async batch(c) {
    const l = c.map(([p, _]) => [p, sceneNodeToLayer(_)]), v = await request(a, l);
    return log.debug("Batch response", v), v;
  }
}), {
  state: state$1
} = CoreContext, prepareInternalEvents = () => {
  subscribeInternal(async (a, u) => {
    var c, l, v;
    switch (a) {
      case "UserChanged": {
        const {
          metadata: p
        } = u;
        state$1.user.metadata = p || {}, state$1.user.props = (p == null ? void 0 : p.props) || {}, trigger$1("UserChanged", {
          user: getBaseUser()
        });
        return;
      }
      case "ActiveProjectChanged": {
        const {
          projectId: p
        } = u;
        state$1.activeProjectId = p, trigger$1("ActiveProjectChanged", {
          projectId: p
        });
        return;
      }
      case "ProjectAdded": {
        const _ = await hydrateProject(u, "ROLE_HOST"), k = toBaseProject(_);
        state$1.projects = [...state$1.projects, _], trigger$1("ProjectAdded", {
          project: k
        });
        return;
      }
      case "ProjectRemoved": {
        const {
          projectId: p
        } = u;
        state$1.projects = state$1.projects.filter((_) => _.id !== p), trigger$1("ProjectRemoved", {
          projectId: p
        });
        return;
      }
      case "ProjectChanged": {
        const {
          project: p,
          phase: _,
          broadcastId: k
        } = u, O = getProject(p.projectId);
        if (!O)
          return;
        _ && (O.videoApi.phase = _), typeof k < "u" && (O.videoApi.broadcastId = k);
        const D = (c = p.metadata) == null ? void 0 : c.layoutId;
        D !== O.layoutApi.layoutId && (O.layoutApi.layoutId = (l = p.metadata) == null ? void 0 : l.layoutId, O.compositor = await layoutToProject(D)), O.videoApi.project = p, O.props = ((v = p.metadata) == null ? void 0 : v.props) ?? {}, trigger$1("ProjectChanged", {
          project: toBaseProject(O)
        });
        return;
      }
      case "DestinationAdded": {
        const {
          projectId: p
        } = u, _ = getProject(p);
        if (!_)
          return;
        _.videoApi.project.destinations.push(u), trigger$1("DestinationAdded", {
          projectId: p,
          destination: toBaseDestination(u)
        });
        return;
      }
      case "DestinationRemoved": {
        const {
          projectId: p,
          destinationId: _
        } = u, k = getProject(p);
        if (!k)
          return;
        k.videoApi.project.destinations = k.videoApi.project.destinations.filter((O) => O.destinationId !== _), trigger$1("DestinationRemoved", {
          projectId: p,
          destinationId: _
        });
        return;
      }
      case "DestinationChanged": {
        const p = u, {
          projectId: _,
          destinationId: k
        } = p, O = getProject(_);
        if (!O)
          return;
        const D = O.videoApi.project.destinations.find((F) => F.destinationId === k);
        if (!D)
          return;
        Object.assign(D, p), trigger$1("DestinationChanged", {
          projectId: _,
          destination: toBaseDestination(D)
        });
        return;
      }
      case "SourceAdded": {
        trigger$1("SourceAdded", {
          source: toBaseSource(u)
        });
        return;
      }
      case "SourceRemoved":
        return;
      case "SourceChanged":
        return;
      case "ProjectSourceAdded": {
        const {
          projectId: p,
          source: _
        } = u, k = getProject(p);
        if (!k)
          return;
        k.videoApi.project.sources.push(_), trigger$1("ProjectSourceAdded", {
          source: toBaseSource(_),
          projectId: p
        });
        return;
      }
      case "ProjectSourceRemoved": {
        const {
          projectId: p,
          sourceId: _
        } = u, k = getProject(p);
        if (!k)
          return;
        k.videoApi.project.sources = k.videoApi.project.sources.filter((O) => O.sourceId !== _), trigger$1("ProjectSourceRemoved", {
          sourceId: _,
          projectId: p
        });
      }
      case "NodeAdded":
        return;
      case "NodeRemoved":
        return;
      case "NodeChanged":
        return;
    }
  }), subscribeInternal(() => log.debug({
    nextState: {
      ...state$1
    }
  }));
};
/*! (c) Andrea Giammarchi - ISC */
var self$1 = {};
try {
  self$1.WeakMap = WeakMap;
} catch (a) {
  self$1.WeakMap = function(u, c) {
    var l = c.defineProperty, v = c.hasOwnProperty, p = _.prototype;
    return p.delete = function(O) {
      return this.has(O) && delete O[this._];
    }, p.get = function(O) {
      return this.has(O) ? O[this._] : void 0;
    }, p.has = function(O) {
      return v.call(O, this._);
    }, p.set = function(O, D) {
      return l(O, this._, { configurable: !0, value: D }), this;
    }, _;
    function _(O) {
      l(this, "_", { value: "_@ungap/weakmap" + u++ }), O && O.forEach(k, this);
    }
    function k(O) {
      this.set(O[0], O[1]);
    }
  }(Math.random(), Object);
}
const WeakMap$1 = self$1.WeakMap;
/*! (c) Andrea Giammarchi - ISC */
var UID = "-" + Math.random().toFixed(6) + "%", UID_IE = !1;
try {
  (function(a, u, c) {
    return u in a && (a.innerHTML = "<p " + c + '="' + UID + '"></p>', a[u].childNodes[0].getAttribute(c) == UID);
  })(document.createElement("template"), "content", "tabindex") || (UID = "_dt: " + UID.slice(1, -1) + ";", UID_IE = !0);
} catch (a) {
}
var UIDC = "<!--" + UID + "-->", COMMENT_NODE = 8, ELEMENT_NODE$1 = 1, TEXT_NODE = 3, SHOULD_USE_TEXT_CONTENT = /^(?:plaintext|script|style|textarea|title|xmp)$/i, VOID_ELEMENTS = /^(?:area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)$/i;
/*! (c) Andrea Giammarchi - ISC */
function domsanitizer(a) {
  return a.join(UIDC).replace(selfClosing, fullClosing).replace(attrSeeker, attrReplacer);
}
var spaces = " \\f\\n\\r\\t", almostEverything = "[^" + spaces + `\\/>"'=]+`, attrName = "[" + spaces + "]+" + almostEverything, tagName = "<([A-Za-z]+[A-Za-z0-9:._-]*)((?:", attrPartials = `(?:\\s*=\\s*(?:'[^']*?'|"[^"]*?"|<[^>]*?>|` + almostEverything.replace("\\/", "") + "))?)", attrSeeker = new RegExp(tagName + attrName + attrPartials + "+)([" + spaces + "]*/?>)", "g"), selfClosing = new RegExp(tagName + attrName + attrPartials + "*)([" + spaces + "]*/>)", "g"), findAttributes = new RegExp("(" + attrName + `\\s*=\\s*)(['"]?)` + UIDC + "\\2", "gi");
function attrReplacer(a, u, c, l) {
  return "<" + u + c.replace(findAttributes, replaceAttributes) + l;
}
function replaceAttributes(a, u, c) {
  return u + (c || '"') + UID + (c || '"');
}
function fullClosing(a, u, c) {
  return VOID_ELEMENTS.test(u) ? a : "<" + u + c + "></" + u + ">";
}
const { isArray } = Array, { indexOf, slice } = [], umap = (a) => ({
  // About: get: _.get.bind(_)
  // It looks like WebKit/Safari didn't optimize bind at all,
  // so that using bind slows it down by 60%.
  // Firefox and Chrome are just fine in both cases,
  // so let's use the approach that works fast everywhere 👍
  get: (u) => a.get(u),
  set: (u, c) => (a.set(u, c), c)
}), ELEMENT_NODE = 1, nodeType = 111, remove = ({ firstChild: a, lastChild: u }) => {
  const c = document.createRange();
  return c.setStartAfter(a), c.setEndAfter(u), c.deleteContents(), a;
}, diffable = (a, u) => a.nodeType === nodeType ? 1 / u < 0 ? u ? remove(a) : a.lastChild : u ? a.valueOf() : a.firstChild : a, persistent = (a) => {
  const { childNodes: u } = a, { length: c } = u;
  if (c < 2)
    return c ? u[0] : a;
  const l = slice.call(u, 0), v = l[0], p = l[c - 1];
  return {
    ELEMENT_NODE,
    nodeType,
    firstChild: v,
    lastChild: p,
    valueOf() {
      if (u.length !== c) {
        let _ = 0;
        for (; _ < c; )
          a.appendChild(l[_++]);
      }
      return a;
    }
  };
};
/*! (c) Andrea Giammarchi - ISC */
var createContent = function(a) {
  var u = "fragment", c = "template", l = "content" in _(c), v = l ? function(O) {
    var D = _(c);
    return D.innerHTML = O, D.content;
  } : function(O) {
    var D = _(u), F = _(c), H = null;
    if (/^[^\S]*?<(col(?:group)?|t(?:head|body|foot|r|d|h))/i.test(O)) {
      var Z = RegExp.$1;
      F.innerHTML = "<table>" + O + "</table>", H = F.querySelectorAll(Z);
    } else
      F.innerHTML = O, H = F.childNodes;
    return p(D, H), D;
  };
  return function(D, F) {
    return (F === "svg" ? k : v)(D);
  };
  function p(O, D) {
    for (var F = D.length; F--; )
      O.appendChild(D[0]);
  }
  function _(O) {
    return O === u ? a.createDocumentFragment() : a.createElementNS("http://www.w3.org/1999/xhtml", O);
  }
  function k(O) {
    var D = _(u), F = _("div");
    return F.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg">' + O + "</svg>", p(D, F.firstChild.childNodes), D;
  }
}(document);
const udomdiff = (a, u, c, l, v) => {
  const p = c.length;
  let _ = u.length, k = p, O = 0, D = 0, F = null;
  for (; O < _ || D < k; )
    if (_ === O) {
      const H = k < p ? D ? l(c[D - 1], -0).nextSibling : l(c[k - D], 0) : v;
      for (; D < k; )
        a.insertBefore(l(c[D++], 1), H);
    } else if (k === D)
      for (; O < _; )
        (!F || !F.has(u[O])) && a.removeChild(l(u[O], -1)), O++;
    else if (u[O] === c[D])
      O++, D++;
    else if (u[_ - 1] === c[k - 1])
      _--, k--;
    else if (u[O] === c[k - 1] && c[D] === u[_ - 1]) {
      const H = l(u[--_], -1).nextSibling;
      a.insertBefore(
        l(c[D++], 1),
        l(u[O++], -1).nextSibling
      ), a.insertBefore(l(c[--k], 1), H), u[_] = c[k];
    } else {
      if (!F) {
        F = /* @__PURE__ */ new Map();
        let H = D;
        for (; H < k; )
          F.set(c[H], H++);
      }
      if (F.has(u[O])) {
        const H = F.get(u[O]);
        if (D < H && H < k) {
          let Z = O, ee = 1;
          for (; ++Z < _ && Z < k && F.get(u[Z]) === H + ee; )
            ee++;
          if (ee > H - D) {
            const X = l(u[O], 0);
            for (; D < H; )
              a.insertBefore(l(c[D++], 1), X);
          } else
            a.replaceChild(
              l(c[D++], 1),
              l(u[O++], -1)
            );
        } else
          O++;
      } else
        a.removeChild(l(u[O++], -1));
    }
  return c;
};
/*! (c) Andrea Giammarchi - ISC */
var importNode = function(a, u, c, l, v) {
  var p = v in a, _ = a.createDocumentFragment();
  _[u](a[l]("g")), _[u](a[l](""));
  var k = p ? a[v](_, !0) : _[c](!0);
  return k.childNodes.length < 2 ? function O(D, F) {
    for (var H = D[c](), Z = D.childNodes || [], ee = Z.length, X = 0; F && X < ee; X++)
      H[u](O(Z[X], F));
    return H;
  } : (
    /* istanbul ignore next */
    p ? a[v] : function(O, D) {
      return O[c](!!D);
    }
  );
}(
  document,
  "appendChild",
  "cloneNode",
  "createTextNode",
  "importNode"
), trim = "".trim || /* istanbul ignore next */
function() {
  return String(this).replace(/^\s+|\s+/g, "");
}, normalizeAttributes = UID_IE ? function(a, u) {
  var c = u.join(" ");
  return u.slice.call(a, 0).sort(function(l, v) {
    return c.indexOf(l.name) <= c.indexOf(v.name) ? -1 : 1;
  });
} : function(a, u) {
  return u.slice.call(a, 0);
};
function find(a, u) {
  for (var c = u.length, l = 0; l < c; )
    a = a.childNodes[u[l++]];
  return a;
}
function parse(a, u, c, l) {
  for (var v = a.childNodes, p = v.length, _ = 0; _ < p; ) {
    var k = v[_];
    switch (k.nodeType) {
      case ELEMENT_NODE$1:
        var O = l.concat(_);
        parseAttributes(k, u, c, O), parse(k, u, c, O);
        break;
      case COMMENT_NODE:
        var D = k.textContent;
        if (D === UID)
          c.shift(), u.push(
            // basicHTML or other non standard engines
            // might end up having comments in nodes
            // where they shouldn't, hence this check.
            SHOULD_USE_TEXT_CONTENT.test(a.nodeName) ? Text(a, l) : Any(k, l.concat(_))
          );
        else
          switch (D.slice(0, 2)) {
            case "/*":
              if (D.slice(-2) !== "*/")
                break;
            case "👻":
              a.removeChild(k), _--, p--;
          }
        break;
      case TEXT_NODE:
        SHOULD_USE_TEXT_CONTENT.test(a.nodeName) && trim.call(k.textContent) === UIDC && (c.shift(), u.push(Text(a, l)));
        break;
    }
    _++;
  }
}
function parseAttributes(a, u, c, l) {
  for (var v = a.attributes, p = [], _ = [], k = normalizeAttributes(v, c), O = k.length, D = 0; D < O; ) {
    var F = k[D++], H = F.value === UID, Z;
    if (H || 1 < (Z = F.value.split(UIDC)).length) {
      var ee = F.name;
      if (p.indexOf(ee) < 0) {
        p.push(ee);
        var X = c.shift().replace(
          H ? /^(?:|[\S\s]*?\s)(\S+?)\s*=\s*('|")?$/ : new RegExp(
            "^(?:|[\\S\\s]*?\\s)(" + ee + `)\\s*=\\s*('|")[\\S\\s]*`,
            "i"
          ),
          "$1"
        ), ne = v[X] || // the following ignore is covered by browsers
        // while basicHTML is already case-sensitive
        /* istanbul ignore next */
        v[X.toLowerCase()];
        if (H)
          u.push(Attr(ne, l, X, null));
        else {
          for (var Q = Z.length - 2; Q--; )
            c.shift();
          u.push(Attr(ne, l, X, Z));
        }
      }
      _.push(F);
    }
  }
  O = _.length, D = 0;
  for (var ae = 0 < O && UID_IE && !("ownerSVGElement" in a); D < O; ) {
    var j = _[D++];
    ae && (j.value = ""), a.removeAttribute(j.name);
  }
  var ue = a.nodeName;
  if (/^script$/i.test(ue)) {
    var he = document.createElement(ue);
    for (O = v.length, D = 0; D < O; )
      he.setAttributeNode(v[D++].cloneNode(!0));
    he.textContent = a.textContent, a.parentNode.replaceChild(he, a);
  }
}
function Any(a, u) {
  return {
    type: "any",
    node: a,
    path: u
  };
}
function Attr(a, u, c, l) {
  return {
    type: "attr",
    node: a,
    path: u,
    name: c,
    sparse: l
  };
}
function Text(a, u) {
  return {
    type: "text",
    node: a,
    path: u
  };
}
var parsed = umap(new WeakMap$1());
function createInfo(a, u) {
  var c = (a.convert || domsanitizer)(u), l = a.transform;
  l && (c = l(c));
  var v = createContent(c, a.type);
  cleanContent(v);
  var p = [];
  return parse(v, p, u.slice(0), []), {
    content: v,
    updates: function(_) {
      for (var k = [], O = p.length, D = 0, F = 0; D < O; ) {
        var H = p[D++], Z = find(_, H.path);
        switch (H.type) {
          case "any":
            k.push({ fn: a.any(Z, []), sparse: !1 });
            break;
          case "attr":
            var ee = H.sparse, X = a.attribute(Z, H.name, H.node);
            ee === null ? k.push({ fn: X, sparse: !1 }) : (F += ee.length - 2, k.push({ fn: X, sparse: !0, values: ee }));
            break;
          case "text":
            k.push({ fn: a.text(Z), sparse: !1 }), Z.textContent = "";
            break;
        }
      }
      return O += F, function() {
        var ne = arguments.length;
        if (O !== ne - 1)
          throw new Error(
            ne - 1 + " values instead of " + O + `
` + u.join("${value}")
          );
        for (var Q = 1, ae = 1; Q < ne; ) {
          var j = k[Q - ae];
          if (j.sparse) {
            var ue = j.values, he = ue[0], fe = 1, be = ue.length;
            for (ae += be - 2; fe < be; )
              he += arguments[Q++] + ue[fe++];
            j.fn(he);
          } else
            j.fn(arguments[Q++]);
        }
        return _;
      };
    }
  };
}
function createDetails(a, u) {
  var c = parsed.get(u) || parsed.set(u, createInfo(a, u));
  return c.updates(importNode.call(document, c.content, !0));
}
var empty = [];
function domtagger(a) {
  var u = empty, c = cleanContent;
  return function(l) {
    return u !== l && (c = createDetails(a, u = l)), c.apply(null, arguments);
  };
}
function cleanContent(a) {
  for (var u = a.childNodes, c = u.length; c--; ) {
    var l = u[c];
    l.nodeType !== 1 && trim.call(l.textContent).length === 0 && a.removeChild(l);
  }
}
/*! (c) Andrea Giammarchi - ISC */
var hyperStyle = /* @__PURE__ */ function() {
  var a = /acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i, u = /([^A-Z])([A-Z]+)/g;
  return function(k, O) {
    return "ownerSVGElement" in k ? l(k, O) : p(k.style, !1);
  };
  function c(_, k, O) {
    return k + "-" + O.toLowerCase();
  }
  function l(_, k) {
    var O;
    return k ? O = k.cloneNode(!0) : (_.setAttribute("style", "--hyper:style;"), O = _.getAttributeNode("style")), O.value = "", _.setAttributeNode(O), p(O, !0);
  }
  function v(_) {
    var k, O = [];
    for (k in _)
      O.push(k.replace(u, c), ":", _[k], ";");
    return O.join("");
  }
  function p(_, k) {
    var O, D;
    return function(F) {
      var H, Z, ee, X;
      switch (typeof F) {
        case "object":
          if (F) {
            if (O === "object") {
              if (!k && D !== F)
                for (Z in D)
                  Z in F || (_[Z] = "");
            } else
              k ? _.value = "" : _.cssText = "";
            H = k ? {} : _;
            for (Z in F)
              X = F[Z], ee = typeof X == "number" && !a.test(Z) ? X + "px" : X, !k && /^--/.test(Z) ? H.setProperty(Z, ee) : H[Z] = ee;
            O = "object", k ? _.value = v(D = H) : D = F;
            break;
          }
        default:
          D != F && (O = "string", D = F, k ? _.value = F || "" : _.cssText = F || "");
          break;
      }
    };
  }
}();
const aria = (a) => (u) => {
  for (const c in u) {
    const l = c === "role" ? c : `aria-${c}`, v = u[c];
    v == null ? a.removeAttribute(l) : a.setAttribute(l, v);
  }
}, attribute = (a, u) => {
  let c, l = !0;
  const v = document.createAttributeNS(null, u);
  return (p) => {
    c !== p && (c = p, c == null ? l || (a.removeAttributeNode(v), l = !0) : (v.value = p, l && (a.setAttributeNodeNS(v), l = !1)));
  };
}, boolean = (a, u, c) => (l) => {
  c !== !!l && ((c = !!l) ? a.setAttribute(u, "") : a.removeAttribute(u));
}, data = ({ dataset: a }) => (u) => {
  for (const c in u) {
    const l = u[c];
    l == null ? delete a[c] : a[c] = l;
  }
}, event = (a, u) => {
  let c, l = u.slice(2);
  return !(u in a) && u.toLowerCase() in a && (l = l.toLowerCase()), (v) => {
    const p = isArray(v) ? v : [v, !1];
    c !== p[0] && (c && a.removeEventListener(l, c, p[1]), (c = p[0]) && a.addEventListener(l, c, p[1]));
  };
}, ref = (a) => (u) => {
  typeof u == "function" ? u(a) : u.current = a;
}, setter = (a, u) => u === "dataset" ? data(a) : (c) => {
  a[u] = c;
}, hyperProperty = (a, u) => {
  let c;
  return (l) => {
    c !== l && (c = l, a[u] !== l && (l == null ? (a[u] = "", a.removeAttribute(u)) : a[u] = l));
  };
}, readOnly = /^(?:form|list)$/i, text = (a, u) => a.ownerDocument.createTextNode(u);
function Tagger(a) {
  return this.type = a, domtagger(this);
}
Tagger.prototype = {
  // there are four kind of attributes, and related behavior:
  //  * events, with a name starting with `on`, to add/remove event listeners
  //  * special, with a name present in their inherited prototype, accessed directly
  //  * regular, accessed through get/setAttribute standard DOM methods
  //  * style, the only regular attribute that also accepts an object as value
  //    so that you can style=${{width: 120}}. In this case, the behavior has been
  //    fully inspired by Preact library and its simplicity.
  attribute(a, u, c) {
    const l = this.type === "svg";
    switch (u) {
      case "class":
        if (l)
          return attribute(a, u);
        u = "className";
      case "props":
        return setter(a, u);
      case "aria":
        return aria(a);
      case "style":
        return hyperStyle(a, c, l);
      case "ref":
        return ref(a);
      case ".dataset":
        return data(a);
      default:
        return u.slice(0, 1) === "." ? setter(a, u.slice(1)) : u.slice(0, 1) === "?" ? boolean(a, u.slice(1)) : u.slice(0, 2) === "on" ? event(a, u) : u in a && !(l || readOnly.test(u)) ? hyperProperty(a, u) : attribute(a, u);
    }
  },
  // in a hyper(node)`<div>${content}</div>` case
  // everything could happen:
  //  * it's a JS primitive, stored as text
  //  * it's null or undefined, the node should be cleaned
  //  * it's a promise, update the content once resolved
  //  * it's an explicit intent, perform the desired operation
  //  * it's an Array, resolve all values if Promises and/or
  //    update the node with the resulting list of content
  any(a, u) {
    const { type: c } = this;
    let l = !1, v;
    const p = (_) => {
      switch (typeof _) {
        case "string":
        case "number":
        case "boolean":
          l ? v !== _ && (v = _, u[0].textContent = _) : (l = !0, v = _, u = udomdiff(
            a.parentNode,
            u,
            [text(a, _)],
            diffable,
            a
          ));
          break;
        case "function":
          p(_(a));
          break;
        case "object":
        case "undefined":
          if (_ == null) {
            l = !1, u = udomdiff(
              a.parentNode,
              u,
              [],
              diffable,
              a
            );
            break;
          }
        default:
          if (l = !1, v = _, isArray(_))
            if (_.length === 0)
              u.length && (u = udomdiff(
                a.parentNode,
                u,
                [],
                diffable,
                a
              ));
            else
              switch (typeof _[0]) {
                case "string":
                case "number":
                case "boolean":
                  p(String(_));
                  break;
                case "function":
                  p(_.map(invoke, a));
                  break;
                case "object":
                  isArray(_[0]) && (_ = _.concat.apply([], _));
                default:
                  u = udomdiff(
                    a.parentNode,
                    u,
                    _,
                    diffable,
                    a
                  );
                  break;
              }
          else
            "ELEMENT_NODE" in _ ? u = udomdiff(
              a.parentNode,
              u,
              _.nodeType === 11 ? slice.call(_.childNodes) : [_],
              diffable,
              a
            ) : "text" in _ ? p(String(_.text)) : "any" in _ ? p(_.any) : "html" in _ ? u = udomdiff(
              a.parentNode,
              u,
              slice.call(
                createContent(
                  [].concat(_.html).join(""),
                  c
                ).childNodes
              ),
              diffable,
              a
            ) : "length" in _ && p(slice.call(_));
          break;
      }
    };
    return p;
  },
  // style or textareas don't accept HTML as content
  // it's pointless to transform or analyze anything
  // different from text there but it's worth checking
  // for possible defined intents.
  text(a) {
    let u;
    const c = (l) => {
      if (u !== l) {
        u = l;
        const v = typeof l;
        v === "object" && l ? "text" in l ? c(String(l.text)) : "any" in l ? c(l.any) : "html" in l ? c([].concat(l.html).join("")) : "length" in l && c(slice.call(l).join("")) : v === "function" ? c(l(a)) : a.textContent = l ?? "";
      }
    };
    return c;
  }
};
function invoke(a) {
  return a(this);
}
const { create: create$1, freeze, keys } = Object, cache = umap(new WeakMap$1()), createRender = (a) => ({
  html: outer("html", a),
  svg: outer("svg", a),
  render(u, c) {
    const l = typeof c == "function" ? c() : c, v = cache.get(u) || cache.set(u, createCache()), p = l instanceof LighterHole ? unroll(a, v, l) : l;
    return p !== v.wire && (v.wire = p, u.textContent = "", u.appendChild(p.valueOf())), u;
  }
}), createCache = () => ({ stack: [], entry: null, wire: null }), outer = (a, u) => {
  const c = umap(new WeakMap$1()), l = (p) => function() {
    return unroll(u, p, v.apply(null, arguments));
  };
  return v.for = (p, _) => {
    const k = c.get(p) || c.set(p, create$1(null));
    return k[_] || (k[_] = l(createCache()));
  }, v.node = function() {
    return unroll(
      u,
      createCache(),
      v.apply(null, arguments)
    ).valueOf();
  }, v;
  function v() {
    return new LighterHole(a, tta.apply(null, arguments));
  }
}, unroll = (a, u, { type: c, template: l, values: v }) => {
  const { length: p } = v;
  unrollValues(a, u, v, p);
  let { entry: _ } = u;
  if (!_ || _.template !== l || _.type !== c) {
    const k = new a(c);
    u.entry = _ = {
      type: c,
      template: l,
      tag: k,
      wire: persistent(k(l, ...v))
    };
  } else
    _.tag(l, ...v);
  return _.wire;
}, unrollValues = (a, { stack: u }, c, l) => {
  for (let v = 0; v < l; v++) {
    const p = c[v];
    p instanceof Hole ? c[v] = unroll(
      a,
      u[v] || (u[v] = createCache()),
      p
    ) : isArray(p) ? unrollValues(
      a,
      u[v] || (u[v] = createCache()),
      p,
      p.length
    ) : u[v] = null;
  }
  l < u.length && u.splice(l);
};
freeze(LighterHole);
function LighterHole(a, u) {
  this.type = a, this.template = u.shift(), this.values = u;
}
const Hole = LighterHole, { render: render$1, html, svg } = createRender(Tagger);
function tta() {
  let a = [], u = 0, { length: c } = arguments;
  for (; u < c; )
    a.push(arguments[u++]);
  return a;
}
const Free = {
  name: "Free",
  layout: ({
    props: a,
    children: u,
    size: c
  }) => u.reduce((l, v) => {
    const {
      size: p = {
        x: "100%",
        y: "100%"
      },
      position: _ = {
        x: 0,
        y: 0
      },
      opacity: k = 1
    } = v.props;
    return {
      ...l,
      [v.id]: {
        position: {
          x: _.x,
          y: _.y
        },
        size: {
          x: p.x,
          y: p.y
        },
        opacity: k
      }
    };
  }, {})
}, Column = {
  name: "Column",
  layout: ({
    props: a = {},
    children: u,
    size: c
  }) => {
    let {
      justify: l = "center",
      align: v = "center",
      cover: p = !1,
      margin: _ = {},
      dimensions: k = 16 / 9,
      reverse: O = !1
    } = a;
    const D = p ? 0 : Math.min(c.y / 6, 12);
    _ = {
      left: D,
      right: D,
      top: D,
      bottom: D,
      between: D,
      ..._
    };
    const F = c.y - _.top - _.bottom, H = c.x - _.left - _.right, Z = _.between * ((u.length || 1) - 1), ee = Math.min(H, (F - Z) / (u.length || 1) * k), X = ee / k;
    return html.node`
      <div style=${{
      height: "100%",
      width: p ? c.x + "px" : "auto",
      display: "flex",
      flexDirection: O ? "column-reverse" : "column",
      justifyContent: l,
      alignItems: v,
      paddingLeft: _.left + "px",
      paddingTop: _.top + "px",
      paddingBottom: _.bottom + "px",
      paddingRight: _.right + "px"
    }}>
      ${u.map((ne, Q) => html.node`<div data-node-id=${ne.id} .data=${{
      entryTransition: {
        delay: 400 + Q * 100,
        offset: {
          x: 0,
          y: "100%"
        },
        scale: {
          x: 0.8,
          y: 0.8
        },
        opacity: 0
      },
      exitTransition: {
        offset: {
          x: 0,
          y: 1e3
        },
        scale: {
          x: 0.8,
          y: 0.8
        },
        opacity: 0
      },
      borderRadius: p ? 0 : 5
    }} style=${{
      display: "flex",
      width: p ? "100%" : ee + "px",
      height: p ? X + "px" : "auto",
      aspectRatio: k,
      marginBottom: Q === u.length - 1 ? 0 : _.between + "px",
      flexGrow: 0,
      flexShrink: 1,
      flexBasis: X + "px"
    }}></div>`)}
      </div>
    `;
  }
}, Row = {
  name: "Row",
  layout: ({
    props: a = {},
    children: u,
    size: c
  }) => {
    let {
      justify: l = "center",
      align: v = "center",
      cover: p = !1,
      margin: _ = {},
      dimensions: k,
      maxWidth: O = 1,
      reverse: D = !1
    } = a;
    const F = p ? 0 : Math.min(c.y / 6, 12);
    _ = {
      left: F,
      right: F,
      top: F,
      bottom: F,
      between: F,
      ..._
    };
    const H = c.y - _.top - _.bottom, Z = c.x - _.left - _.right, ee = _.between * ((u.length || 1) - 1);
    let X = H, ne = Math.min((Z - ee) / (u.length || 1), k ? H * k : Z, O * c.x);
    return k && (X = ne / k), html.node`
      <div style=${{
      height: p ? c.y + "px" : "auto",
      width: "100%",
      display: "flex",
      flexDirection: D ? "row-reverse" : "row",
      justifyContent: l,
      alignItems: v,
      paddingLeft: _.left + "px",
      paddingTop: _.top + "px",
      paddingBottom: _.bottom + "px",
      paddingRight: _.right + "px"
    }}>
          ${u.map((Q, ae) => html.node`<div data-node-id=${Q.id} .data=${{
      entryTransition: {
        delay: 400 + ae * 100,
        offset: {
          x: 0,
          y: "100%"
        },
        scale: {
          x: 0.8,
          y: 0.8
        },
        opacity: 0
      },
      exitTransition: {
        offset: {
          x: 0,
          y: 1e3
        },
        scale: {
          x: 0.8,
          y: 0.8
        },
        opacity: 0
      },
      borderRadius: p ? 0 : 5
    }} style=${{
      display: "flex",
      height: p ? "100%" : X + "px",
      width: ne + "px",
      marginRight: ae === u.length - 1 ? 0 : _.between + "px",
      flexGrow: 0,
      flexShrink: 1,
      flexBasis: ne + "px"
    }}></div>`)}
      </div>
    `;
  }
}, toMatrix = (a, u) => a.reduce((c, l, v) => (v % u == 0 ? c.push([v]) : c[c.length - 1].push(v)) && c, []), Grid = {
  name: "Grid",
  layout: ({
    props: a = {},
    children: u,
    size: c
  }) => {
    let {
      dimensions: l,
      numPerRow: v,
      margin: p,
      cover: _ = !1,
      maxWidth: k,
      between: O
    } = a;
    const D = u.length === 0 || _ ? 0 : O || Math.min(c.y / u.length / 10, 30);
    p = p ?? D;
    const F = c.x < c.y;
    O = typeof O == "number" ? O : p;
    let H = [];
    v ? H = toMatrix(u, v) : H = F ? getTallGrid(u.length) : getWideGrid(u.length);
    const Z = (c.y - (p * 2 + O * (H.length - 1))) / H.length, ee = c.x - p * 2;
    return html.node`
    <div style=${{
      display: "flex",
      width: "100%",
      height: "100%",
      flexDirection: "column",
      justifyContent: "center",
      padding: p + "px",
      gap: O + "px",
      flexGrow: 0
    }}>${H.map((X, ne) => Row.layout({
      props: {
        justify: "center",
        dimensions: l,
        cover: _,
        maxWidth: k || 1 / (H[0].length || 1),
        margin: {
          top: 0,
          right: 0,
          left: 0,
          bottom: 0,
          between: O
        }
      },
      children: X.map((Q) => u[Q]),
      size: {
        y: Z,
        x: ee
      }
    }))}</div>`;
  }
}, Presentation = {
  name: "Presentation",
  layout: ({
    props: a = {},
    children: u,
    size: c
  }) => {
    let {
      margin: l,
      cover: v = !1,
      barWidth: p = 0.2,
      barPosition: _ = "side",
      presentationDimensions: k = 16 / 9,
      viewerDimensions: O = 16 / 9,
      justifyViewers: D = "center",
      useGrid: F = !1,
      reverse: H = !1
    } = a;
    const Z = _ === "side" ? c.x * p : c.y * p, ee = u[0], X = u.filter((fe) => fe !== ee), ne = u.length <= 1 ? 0 : Math.min(c.x / 80, 30);
    if (l = l ?? ne, !ee)
      return Grid.layout({
        props: a,
        children: u,
        size: c
      });
    const Q = u[1], ae = {
      ...c
    };
    Q && (_ === "side" ? (ae.x = c.x - Z, ae.y = ae.x / k) : (ae.y = c.y - Z, ae.x = ae.y * k));
    let j, ue = {};
    F ? (j = Grid.layout, ue = {
      cover: v,
      ...v ? {
        maxWidth: 1
      } : {
        margin: l
      }
    }) : (j = _ === "side" ? Column.layout : Row.layout, ue = {
      margin: {
        top: l,
        left: l,
        bottom: l,
        right: l,
        between: l
      },
      dimensions: O,
      justify: D,
      align: "flex-end"
    });
    const he = _ === "side" ? H ? "left" : "right" : H ? "top" : "bottom";
    return html.node`
      <div style=${{
      display: "flex",
      flexDirection: (_ === "side" ? "row" : "column") + (H ? "-reverse" : ""),
      justifyContent: "space-around",
      alignItems: "center",
      position: "relative",
      padding: v ? 0 : l,
      [`padding-${he}`]: 0
    }}>
        ${u[0] && html.node`<div style=${{
      // aspectRatio: String(presentationDimensions),
      width: ae.x,
      height: ae.y,
      display: "flex",
      flexGrow: 1
    }}>
            <div data-node-id=${ee.id} .data=${{
      dimensions: k,
      borderRadius: v ? 0 : 5,
      entryTransition: {
        delay: 0,
        offset: {
          x: 0,
          y: 1e3
        },
        scale: {
          x: 0.5,
          y: 0.5
        },
        opacity: 0
      },
      exitTransition: {
        offset: {
          x: 0,
          y: 1e3
        },
        scale: {
          x: 2,
          y: 2
        },
        opacity: 0
      }
    }} style=${{
      width: "100%",
      height: "100%",
      ...v ? {
        position: "absolute",
        top: 0,
        left: 0,
        width: F && Q ? 100 - p * 100 + "%" : "100%",
        height: "100%"
      } : {}
    }} />
          </div>`}
        ${html.node`<div style=${{
      ..._ === "side" ? {
        maxWidth: p * 100 + "%",
        height: "100%"
      } : {
        maxHeight: p * 100 + "%",
        width: "100%"
      }
    }}>${Q && j({
      props: ue,
      children: X,
      size: _ === "side" ? {
        x: Z,
        y: c.y
      } : {
        x: c.x,
        y: Z
      }
    })}</div>`}
      </div>
    `;
  }
}, Layered = {
  name: "Layered",
  layout: ({
    props: a = {},
    children: u,
    size: c
  }) => html.node`<div style=${{
    width: "100%",
    height: "100%",
    position: "relative"
  }}>
      ${u.map((l, v) => html.node`<div data-node-id=${l.id} .data=${{
    zIndex: v + 1
  }} style=${{
    position: "absolute",
    inset: "0px"
  }}></div>`)}
    </div>`
}, getWideGrid = (a = 0) => {
  switch (a) {
    case 0:
      return [[]];
    case 1:
      return [[0]];
    case 2:
      return [[0, 1]];
    case 3:
      return [[0, 1], [2]];
    case 4:
      return [[0, 1], [2, 3]];
    case 5:
      return [[0, 1, 2], [3, 4]];
    case 6:
      return [[0, 1, 2], [3, 4, 5]];
    case 7:
      return [[0, 1, 2], [3, 4, 5], [6]];
    case 8:
      return [[0, 1, 2], [3, 4, 5], [6, 7]];
  }
  const u = Array(a).fill(null).map((c, l) => l);
  return toMatrix(u, Math.round(Math.sqrt(a)));
}, getTallGrid = (a = 0) => {
  switch (a) {
    case 0:
      return [[]];
    case 1:
      return [[0]];
    case 2:
      return [[0], [1]];
    case 3:
      return [[0, 1], [2]];
    case 4:
      return [[0, 1], [2, 3]];
    case 5:
      return [[0, 1], [2, 3], [4]];
    case 6:
      return [[0, 1], [2, 3], [4, 5]];
    case 7:
      return [[0, 1], [2, 3], [4, 5], [6]];
    case 8:
      return [[0, 1], [2, 3], [4, 5], [6, 7]];
  }
  const u = Array(a).fill(null).map((c, l) => l);
  return toMatrix(u, Math.ceil(Math.sqrt(u.length)) - 1);
}, Layouts = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Column,
  Free,
  Grid,
  Layered,
  Presentation,
  Row
}, Symbol.toStringTag, { value: "Module" })), deviceWatchers = /* @__PURE__ */ new Set(), updateMediaStreamTracks = (a, u) => {
  const c = {
    audio: a.getAudioTracks()[0],
    video: a.getVideoTracks()[0]
  };
  c.audio !== u.audio && (c.audio && a.removeTrack(c.audio), u.audio && a.addTrack(u.audio)), c.video !== u.video && (c.video && a.removeTrack(c.video), u.video && a.addTrack(u.video));
}, getDevicePermissions = async () => {
  const a = {
    audio: !0,
    video: !0
  };
  return Promise.all([navigator.mediaDevices.getUserMedia({
    video: !0
  }).then((u) => {
    u.getTracks().forEach((c) => c.stop());
  }).catch((u) => {
    u.name === "NotAllowedError" && (a.video = !1);
  }), navigator.mediaDevices.getUserMedia({
    audio: !0
  }).then((u) => {
    u.getTracks().forEach((c) => c.stop());
  }).catch((u) => {
    u.name === "NotAllowedError" && (a.audio = !1);
  })]).then(() => a);
}, ensureDevicePermissions = async () => getDevicePermissions(), watchDevices = (a) => (deviceWatchers.size === 0 && navigator.mediaDevices.addEventListener("devicechange", reportDevices), deviceWatchers.add(a), reportDevices().catch(() => {
}), () => {
  deviceWatchers.delete(a), deviceWatchers.size === 0 && navigator.mediaDevices.removeEventListener("devicechange", reportDevices);
}), getUserMedia = async (...a) => {
  const u = await navigator.mediaDevices.getUserMedia(...a);
  return reportDevices(), u;
}, deviceWithDefaultLabel = (a, u) => ({
  deviceId: a.deviceId,
  groupId: a.groupId,
  kind: a.kind,
  label: a.label || u
}), reportDevices = async () => {
  const a = await navigator.mediaDevices.enumerateDevices(), u = a.filter((v) => v.kind === "videoinput").map((v, p) => deviceWithDefaultLabel(v, "Camera " + (p + 1))), c = a.filter((v) => v.kind === "audioinput").map((v, p) => deviceWithDefaultLabel(v, "Microphone " + (p + 1))), l = a.filter((v) => v.kind === "audiooutput").map((v, p) => deviceWithDefaultLabel(v, "Speaker " + (p + 1)));
  deviceWatchers.forEach((v) => v({
    webcams: u,
    microphones: c,
    speakers: l
  }));
}, webrtc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ensureDevicePermissions,
  getDevicePermissions,
  getUserMedia,
  updateMediaStreamTracks,
  watchDevices
}, Symbol.toStringTag, { value: "Module" })), RoomParticipant$1 = {
  type: "RoomParticipant",
  valueType: MediaStream,
  props: {
    id: {},
    type: {},
    // 'screen' | 'camera'
    videoEnabled: {},
    audioEnabled: {}
  },
  init({
    addSource: a,
    removeSource: u,
    updateSource: c,
    getSource: l
  }) {
    CoreContext.on("RoomJoined", ({
      room: v
    }) => {
      let p = {}, _ = [], k = [], O = {};
      const D = () => {
        _.filter((F) => (F == null ? void 0 : F.type) === "camera" && (F == null ? void 0 : F.isExternal) === !0).forEach((F) => {
          var H, Z, ee;
          if (F.type === "camera") {
            const X = O[F.id], ne = v.getParticipant(F.participantId), Q = v.getTrack(F.id);
            if (l(F == null ? void 0 : F.id)) {
              const j = v.getTrack((H = ne == null ? void 0 : ne.meta[F.id]) == null ? void 0 : H.microphone);
              updateMediaStreamTracks(X, {
                video: Q == null ? void 0 : Q.mediaStreamTrack,
                audio: j == null ? void 0 : j.mediaStreamTrack
              }), c(F.id, {
                videoEnabled: !!(Q && !Q.isMuted),
                audioEnabled: !!(j && !j.isMuted),
                displayName: ((Z = ne == null ? void 0 : ne.meta[F.id]) == null ? void 0 : Z.displayName) || "External Track",
                mirrored: (ee = ne == null ? void 0 : ne.meta[F.id]) == null ? void 0 : ee.isMirrored,
                microphone: j,
                external: F == null ? void 0 : F.isExternal
              });
            }
          }
        }), k.forEach((F) => {
          var ue;
          const H = O[F.id], Z = O[F.id + "-screen"], ee = F.trackIds.find((he) => {
            const fe = v.getTrack(he);
            return (fe == null ? void 0 : fe.type) === "camera" && !(fe != null && fe.isExternal);
          }), X = F.trackIds.find((he) => {
            const fe = v.getTrack(he);
            return (fe == null ? void 0 : fe.type) === "microphone" && !(fe != null && fe.isExternal);
          }), ne = F.trackIds.find((he) => {
            const fe = v.getTrack(he);
            return (fe == null ? void 0 : fe.type) === "screen_share";
          }), Q = v.getTrack(ee), ae = v.getTrack(X), j = v.getTrack(ne);
          updateMediaStreamTracks(H, {
            video: Q == null ? void 0 : Q.mediaStreamTrack,
            audio: ae == null ? void 0 : ae.mediaStreamTrack
          }), updateMediaStreamTracks(Z, {
            video: j == null ? void 0 : j.mediaStreamTrack
          }), c(F.id, {
            videoEnabled: !!(Q && !Q.isMuted),
            audioEnabled: !!(ae && !ae.isMuted),
            displayName: F.displayName,
            mirrored: (ue = F == null ? void 0 : F.meta) == null ? void 0 : ue.isMirrored,
            external: Q == null ? void 0 : Q.isExternal
          }), c(F.id + "-screen", {
            videoEnabled: !!(j && !j.isMuted),
            displayName: F.meta.screenDisplayName || `${F.displayName}'s Screen`
          });
        });
      };
      v.useTracks((F) => {
        const H = F.filter((ee) => !_.some((X) => X.id === ee.id) && !!(ee != null && ee.mediaStreamTrack)), Z = _.filter((ee) => !F.some((X) => X.id === ee.id));
        _ = F.filter((ee) => !!(ee != null && ee.mediaStreamTrack)), H.forEach((ee) => {
          const X = new MediaStream([]);
          O[ee.id] = X;
          const {
            id: ne,
            participantId: Q,
            type: ae,
            mediaStreamTrack: j
          } = v.getTrack(ee.id);
          j && a({
            id: ne,
            isActive: !0,
            value: X,
            props: {
              id: ne,
              trackId: ne,
              participantId: Q,
              isMuted: ee.isMuted,
              type: ae
            }
          });
        }), Z.forEach((ee) => {
          var X;
          u(ee.id), (X = p[ee.id]) == null || X.call(p);
        }), D();
      }), v.useParticipants((F) => {
        const H = F.filter((X) => !X.id.startsWith("source")), Z = H.filter((X) => !k.some((ne) => ne.id === X.id)), ee = k.filter((X) => !H.some((ne) => ne.id === X.id));
        k = H, Z.forEach((X) => {
          var j;
          const {
            id: ne
          } = X, Q = new MediaStream([]), ae = new MediaStream([]);
          O[ne] = Q, O[ne + "-screen"] = ae, a({
            id: ne,
            isActive: !0,
            value: Q,
            props: {
              id: ne,
              type: "camera",
              displayName: X.displayName || X.id,
              audioEnabled: !1,
              videoEnabled: !1,
              mirrored: (j = X == null ? void 0 : X.meta) == null ? void 0 : j.isMirrored
            }
          }), a({
            id: ne + "-screen",
            isActive: !0,
            value: ae,
            props: {
              id: ne,
              type: "screen",
              displayName: X.displayName || X.id,
              audioEnabled: !1,
              videoEnabled: !1
            }
          });
        }), D(), ee.forEach((X) => {
          var ne;
          u(X.id), (ne = p[X.id]) == null || ne.call(p);
        });
      });
    });
  }
}, Banner$1 = {
  type: "Banner",
  valueType: Object,
  props: {},
  init({
    addSource: a,
    removeSource: u,
    updateSource: c,
    getSource: l,
    modifySourceValue: v
  }) {
    let p = [];
    const _ = (k = []) => {
      const O = k.filter((H) => !p.some((Z) => Z.id === H.id)), D = p.filter((H) => !k.some((Z) => Z.id === H.id)), F = k.filter((H) => {
        const Z = p.find((ee) => ee.id === H.id);
        return !deepEqual(H, Z);
      });
      O.forEach((H) => a({
        id: H.id,
        value: {
          headerText: H.props.headerText,
          bodyText: H.props.bodyText
        },
        // TODO: It feels odd to have "props" match "value" exactly.
        //  They probably shouldn't be necessary here.
        props: H.props
      })), D.forEach((H) => u(H.id)), F.forEach((H) => {
        c(H.id, H.props), v(H.id, (Z) => {
          Z.headerText = H.props.headerText, Z.bodyText = H.props.bodyText;
        });
      }), p = k;
    };
    CoreContext.on("ActiveProjectChanged", ({
      projectId: k
    }) => {
      var D;
      if (p = [], !k)
        return;
      const O = getProject(k);
      _(((D = O.props) == null ? void 0 : D.banners) ?? []);
    }), CoreContext.on("ProjectChanged", ({
      project: k
    }) => {
      var O;
      _(((O = k.props) == null ? void 0 : O.banners) ?? []);
    });
  }
}, {
  state
} = CoreContext, updateUserProps = async (a) => {
  const u = getUser();
  if (!u)
    return;
  const c = {
    ...u.props,
    ...a.props
  }, l = await CoreContext.clients.LiveApi().collection.updateCollection({
    collectionId: u.id,
    updateMask: ["metadata"],
    metadata: {
      ...u.metadata,
      props: c
    }
  });
  await triggerInternal$1("UserChanged", l.collection);
}, createSource = async (a) => {
  const u = getUser().id, {
    source: c
  } = await CoreContext.clients.LiveApi().source.createSource({
    metadata: {
      props: a.props || {}
    },
    collectionId: u,
    address: a.address,
    preview: {
      webrtc: {
        enabled: !0,
        displayName: a.displayName || "RTMP Source"
      }
    }
  });
  await triggerInternal$1("SourceAdded", c);
  const l = await CoreContext.clients.LiveApi().source.addSourceToProject({
    collectionId: u,
    projectId: a.projectId,
    sourceId: c.sourceId
  });
  return await triggerInternal$1("ProjectSourceAdded", {
    projectId: l.project.projectId,
    source: c
  }), c;
}, updateSource = async (a) => {
  const u = getUser().id;
  let c = [], l = {};
  a.metadata && (c.push("metadata"), l.metadata = a.metadata), a.displayName && (c.push("preview.webrtc.displayName"), l = {
    ...l,
    preview: {
      webrtc: {
        displayName: a.displayName
      }
    }
  });
  const {
    source: v
  } = await CoreContext.clients.LiveApi().source.updateSource({
    collectionId: u,
    updateMask: c,
    sourceId: a.sourceId,
    ...l
  });
  return await triggerInternal$1("SourceChanged", v), v;
}, deleteSource = async (a) => {
  const u = getUser().id;
  await CoreContext.clients.LiveApi().source.removeSourceFromProject({
    collectionId: u,
    projectId: a.projectId,
    sourceId: a.sourceId
  }), await triggerInternal$1("ProjectSourceRemoved", {
    projectId: a.projectId,
    sourceId: a.sourceId
  });
  const c = await CoreContext.clients.LiveApi().source.deleteSource({
    sourceId: a.sourceId,
    collectionId: u
  });
  return await triggerInternal$1("SourceRemoved", a.sourceId), c;
}, createProject$1 = async (a = {}) => {
  const {
    props: u = {},
    size: c,
    settings: l = {},
    type: v
  } = a, p = await CoreContext.Request.createProject({
    settings: l,
    props: u,
    size: c,
    type: v
  });
  await triggerInternal$1("ProjectAdded", p.project);
  const _ = await hydrateProject(p.project, "ROLE_HOST");
  return toBaseProject(_);
}, recreateLayout = async (a) => {
  const {
    projectId: u,
    props: c = {}
  } = a, l = getUser().id, v = await CoreContext.clients.LiveApi().project.getProject({
    collectionId: l,
    projectId: u,
    status: !0
  });
  if ([ProjectBroadcastPhase.PROJECT_BROADCAST_PHASE_RUNNING, ProjectBroadcastPhase.PROJECT_BROADCAST_PHASE_STARTING].includes(v.status.phase))
    return;
  const p = v.project.metadata || {}, {
    layoutId: _
  } = p, {
    video: k
  } = v.project.rendering, {
    type: O
  } = v.project.metadata.props || {}, D = await CoreContext.Request.createLayout({
    collectionId: l,
    projectId: u,
    type: O || "sceneless",
    settings: {},
    size: {
      x: k.width,
      y: k.height
    }
  }), F = await CoreContext.clients.LiveApi().project.updateProject({
    collectionId: l,
    projectId: u,
    updateMask: ["metadata"],
    metadata: {
      ...p,
      layoutId: D.id
    }
  });
  CoreContext.log.debug("New layout assigned to project:", {
    layout: D
  }), await triggerInternal$1("ProjectChanged", {
    project: F.project
  }), await CoreContext.clients.LayoutApi().layout.deleteLayout({
    layoutId: _
  }), CoreContext.log.debug("Previous layout deleted:", {
    layoutId: _
  });
  const H = await hydrateProject(F.project, "ROLE_HOST");
  return await H.compositor.update(H.compositor.getRoot().id, c), {
    project: toBaseProject(H),
    internalProject: H
  };
}, deleteProject$1 = async (a) => {
  const {
    projectId: u
  } = a;
  await CoreContext.Request.deleteProject({
    projectId: u
  }), await triggerInternal$1("ProjectRemoved", {
    projectId: u
  });
}, updateProjectProps = async (a) => {
  const {
    projectId: u
  } = a, c = getUser().id, l = getProject(u), v = {
    ...l.props,
    ...a.props
  }, p = await CoreContext.clients.LiveApi().project.updateProject({
    collectionId: c,
    projectId: u,
    updateMask: ["metadata"],
    metadata: {
      ...l.videoApi.project.metadata,
      props: v
    }
  });
  await triggerInternal$1("ProjectChanged", {
    project: p.project
  });
}, updateProjectPropsWithoutTrigger = async (a) => {
  const {
    projectId: u
  } = a, c = getUser().id, l = getProject(u), v = {
    ...l.props,
    ...a.props
  };
  await CoreContext.clients.LiveApi().project.updateProject({
    collectionId: c,
    projectId: u,
    updateMask: ["metadata"],
    metadata: {
      ...l.videoApi.project.metadata,
      props: v
    }
  });
}, setActiveProject = async (a) => {
  const u = state.projects.find((l) => l.id === a.projectId);
  if (!u) {
    state.activeProjectId = null, triggerInternal$1("ActiveProjectChanged", {
      projectId: null
    });
    return;
  }
  const c = state.projects.find((l) => l.id === state.activeProjectId);
  if (u !== c)
    return c && (Array.from(webrtcManager.rooms.keys()).map(webrtcManager.removeRoom), await CoreContext.clients.LayoutApi().unsubscribeFromLayout(c.layoutApi.layoutId), await CoreContext.clients.LiveApi().unsubscribeFromProject(c.videoApi.project.collectionId, c.videoApi.project.projectId), await CoreContext.clients.LiveApi().unsubscribeFromCollection(c.videoApi.project.collectionId)), await CoreContext.clients.LayoutApi().subscribeToLayout(u.layoutApi.layoutId), await CoreContext.clients.LiveApi().subscribeToProject(u.videoApi.project.collectionId, u.videoApi.project.projectId), await CoreContext.clients.LiveApi().subscribeToCollection(u.videoApi.project.collectionId), CoreContext.clients.LiveApi().project.getProject({
      collectionId: u.videoApi.project.collectionId,
      projectId: u.videoApi.project.projectId,
      status: !0
    }).then((l) => {
      var v, p;
      triggerInternal$1("ProjectChanged", {
        project: l.project,
        phase: (v = l.status) == null ? void 0 : v.phase,
        broadcastId: (p = l.status) == null ? void 0 : p.broadcastId
      });
    }), triggerInternal$1("ActiveProjectChanged", {
      projectId: u.id
    }), toBaseProject(u);
}, joinRoom = async (a) => {
  const {
    projectId: u,
    displayName: c = "Guest"
  } = a, l = state.projects.find((H) => H.id === u);
  let v = l.sfuToken;
  if (!v) {
    let {
      webrtcAccess: H
    } = await CoreContext.clients.LiveApi().authentication.createWebRtcAccessToken({
      collectionId: l.videoApi.project.collectionId,
      projectId: l.videoApi.project.projectId,
      displayName: c
    });
    v = H.accessToken;
  }
  const _ = jwtDecode(v).video.room, k = new URL(CoreContext.clients.getLiveKitServer()), O = k.host + k.pathname, D = webrtcManager.ensureRoom(O, _, v);
  D.bindApiClient(CoreContext.clients), await D.connect(), l.sfuToken = v, l.roomId = _;
  const F = getRoom(_);
  return trigger$1("RoomJoined", {
    projectId: l.id,
    room: F
  }), F;
}, createNode = async (a) => {
  let {
    props: u = {},
    parentId: c,
    index: l,
    projectId: v = state.activeProjectId
  } = a;
  const p = getProject(v), _ = await p.compositor.insert(u, c, l);
  return triggerInternal$1("NodeAdded", {
    projectId: v,
    nodeId: _
  }), triggerInternal$1("NodeChanged", {
    projectId: v,
    nodeId: c
  }), p.compositor.get(_);
}, deleteNode = async (a) => {
  var p;
  let {
    nodeId: u,
    projectId: c = state.activeProjectId
  } = a;
  const l = getProject(c), v = (p = l.compositor.getParent(u)) == null ? void 0 : p.id;
  l.compositor.remove(u), triggerInternal$1("NodeRemoved", {
    projectId: c,
    nodeId: u
  }), triggerInternal$1("NodeChanged", {
    projectId: c,
    nodeId: v
  });
}, updateNode = async (a) => {
  let {
    nodeId: u,
    props: c = {},
    projectId: l = state.activeProjectId
  } = a;
  const v = getProject(l);
  return delete c.type, delete c.sourceType, v.compositor.update(u, c), triggerInternal$1("NodeChanged", {
    projectId: l,
    nodeId: u
  }), v.compositor.get(u);
}, setNodeLayout = async (a) => {
  let {
    nodeId: u,
    layout: c,
    projectId: l = state.activeProjectId,
    layoutProps: v = {}
  } = a;
  getProject(l).compositor.update(u, {
    layout: c,
    layoutProps: v
  }), triggerInternal$1("NodeChanged", {
    projectId: l,
    nodeId: u
  });
}, moveNode = async (a) => {
  const {
    nodeId: u,
    parentId: c,
    projectId: l = state.activeProjectId,
    index: v
  } = a;
  getProject(l).compositor.move(u, c, v), triggerInternal$1("NodeChanged", {
    projectId: l,
    nodeId: u
  });
}, swapNodes = async (a) => {
  var k, O;
  const {
    nodeAId: u,
    nodeBId: c,
    projectId: l = state.activeProjectId
  } = a, v = getProject(l), p = (k = v.compositor.getParent(u)) == null ? void 0 : k.id, _ = (O = v.compositor.getParent(c)) == null ? void 0 : O.id;
  v.compositor.swap(u, c), triggerInternal$1("NodeChanged", {
    projectId: l,
    nodeId: p
  }), triggerInternal$1("NodeChanged", {
    projectId: l,
    nodeId: _
  });
}, reorderNodes = async (a) => {
  const {
    parentId: u,
    childIds: c,
    projectId: l = state.activeProjectId
  } = a;
  getProject(l).compositor.reorder(u, c), triggerInternal$1("NodeChanged", {
    projectId: l,
    nodeId: u
  });
}, startBroadcast = async (a) => {
  const {
    projectId: u = state.activeProjectId,
    dynamicSources: c,
    props: l
  } = a, v = getProject(u);
  await CoreContext.clients.LiveApi().project.startProjectBroadcast({
    collectionId: v.videoApi.project.collectionId,
    projectId: v.videoApi.project.projectId,
    ...c && {
      dynamicSources: c
    },
    ...l && {
      triggerMetadata: {
        ...l
      }
    }
  });
}, stopBroadcast = async (a) => {
  const {
    projectId: u = state.activeProjectId
  } = a, c = getProject(u);
  await CoreContext.clients.LiveApi().project.stopProjectBroadcast({
    collectionId: c.videoApi.project.collectionId,
    projectId: c.videoApi.project.projectId
  });
}, addDestination = async (a) => {
  var D;
  const {
    rtmpUrl: u,
    rtmpKey: c,
    enabled: l,
    projectId: v = state.activeProjectId,
    props: p = {}
  } = a, _ = getProject(v), k = {
    rtmpPush: {
      key: c,
      url: u
    }
  }, O = await ((D = CoreContext.clients.LiveApi().destination) == null ? void 0 : D.createDestination({
    collectionId: _.videoApi.project.collectionId,
    projectId: _.videoApi.project.projectId,
    address: k,
    enabled: l,
    metadata: {
      props: p
    }
  }));
  return await triggerInternal$1("DestinationAdded", O.destination), toBaseDestination(O.destination);
}, removeDestination = async (a) => {
  var v;
  const {
    destinationId: u,
    projectId: c = state.activeProjectId
  } = a, l = getProject(c);
  await ((v = CoreContext.clients.LiveApi().destination) == null ? void 0 : v.deleteDestination({
    collectionId: l.videoApi.project.collectionId,
    projectId: l.videoApi.project.projectId,
    destinationId: u
  })), await triggerInternal$1("DestinationRemoved", {
    projectId: c,
    destinationId: u
  });
}, updateDestination = async (a) => {
  var O;
  const {
    rtmpUrl: u,
    rtmpKey: c,
    destinationId: l,
    projectId: v = state.activeProjectId
  } = a, p = getProject(v), _ = {
    key: c,
    url: u
  }, k = await ((O = CoreContext.clients.LiveApi().destination) == null ? void 0 : O.updateDestination({
    collectionId: p.videoApi.project.collectionId,
    projectId: p.videoApi.project.projectId,
    destinationId: l,
    updateMask: ["address.rtmpPush"],
    address: {
      rtmpPush: _
    }
  }));
  await triggerInternal$1("DestinationChanged", k.destination);
}, updateDestinationProps = async (a) => {
  var k, O;
  const {
    projectId: u = state.activeProjectId,
    destinationId: c,
    props: l = {}
  } = a, v = getProject(u), p = v.videoApi.project.destinations.find((D) => D.destinationId === c);
  if (!p)
    return;
  const _ = await ((O = CoreContext.clients.LiveApi().destination) == null ? void 0 : O.updateDestination({
    collectionId: v.videoApi.project.collectionId,
    projectId: v.videoApi.project.projectId,
    destinationId: c,
    updateMask: ["metadata"],
    metadata: {
      ...p.metadata || {},
      props: {
        ...((k = p.metadata) == null ? void 0 : k.props) || {},
        ...l
      }
    }
  }));
  await triggerInternal$1("DestinationChanged", _.destination);
}, setDestinationEnabled = async (a) => {
  var k;
  const {
    enabled: u,
    destinationId: c,
    projectId: l = state.activeProjectId
  } = a, v = getProject(l);
  if (v.videoApi.project.destinations.find((O) => c === O.destinationId).enabled === u)
    return;
  const _ = await ((k = CoreContext.clients.LiveApi().destination) == null ? void 0 : k.updateDestination({
    collectionId: v.videoApi.project.collectionId,
    projectId: v.videoApi.project.projectId,
    destinationId: c,
    updateMask: ["enabled"],
    enabled: u
  }));
  await triggerInternal$1("DestinationChanged", _.destination);
}, setDestination = async (a) => {
  var k, O;
  const {
    rtmpUrl: u,
    rtmpKey: c,
    projectId: l = state.activeProjectId
  } = a, v = getProject(l), p = {
    key: c,
    url: u
  }, _ = !0;
  if (v.videoApi.project.destinations.length > 0) {
    const D = await ((k = CoreContext.clients.LiveApi().destination) == null ? void 0 : k.updateDestination({
      collectionId: v.videoApi.project.collectionId,
      projectId: v.videoApi.project.projectId,
      destinationId: v.videoApi.project.destinations[0].destinationId,
      updateMask: ["address.rtmpPush"],
      address: {
        rtmpPush: p
      }
    }));
    await triggerInternal$1("DestinationChanged", D.destination);
  } else {
    const D = await ((O = CoreContext.clients.LiveApi().destination) == null ? void 0 : O.createDestination({
      collectionId: v.videoApi.project.collectionId,
      projectId: v.videoApi.project.projectId,
      address: {
        rtmpPush: p
      },
      enabled: _
    }));
    await triggerInternal$1("DestinationAdded", D.destination);
  }
}, commands$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  addDestination,
  createNode,
  createProject: createProject$1,
  createSource,
  deleteNode,
  deleteProject: deleteProject$1,
  deleteSource,
  joinRoom,
  moveNode,
  recreateLayout,
  removeDestination,
  reorderNodes,
  setActiveProject,
  setDestination,
  setDestinationEnabled,
  setNodeLayout,
  startBroadcast,
  stopBroadcast,
  swapNodes,
  updateDestination,
  updateDestinationProps,
  updateNode,
  updateProjectProps,
  updateProjectPropsWithoutTrigger,
  updateSource,
  updateUserProps
}, Symbol.toStringTag, { value: "Module" })), useActiveProjectRoom$1 = () => {
  const [a, u] = useState(null);
  return useEffect(() => useActiveProjectRoom(u), []), a;
}, useDevices = () => {
  const [a, u] = useState({
    webcams: [],
    microphones: [],
    speakers: []
  });
  return useEffect(() => watchDevices(u), []), a;
}, StudioContext = React.createContext({
  studio: null,
  project: null,
  room: null,
  webcamId: null,
  microphoneId: null,
  setStudio: () => {
  },
  setProject: () => {
  },
  setRoom: () => {
  },
  setWebcamId: () => {
  },
  setMicrophoneId: () => {
  },
  projectCommands: {}
}), useStudio = () => useContext(StudioContext);
let stored = {
  webcamId: null,
  microphoneId: null
};
try {
  stored.webcamId = localStorage == null ? void 0 : localStorage.getItem("__LS_webcam"), stored.microphoneId = localStorage == null ? void 0 : localStorage.getItem("__LS_microphone");
} catch {
}
const StudioProvider = ({
  children: a
}) => {
  const [u, c] = useState(), [l, v] = useState(), [p, _] = useState(), [k, O] = useState(stored.webcamId), [D, F] = useState(stored.microphoneId), H = useMemo(() => l ? commands(l) : null, [l]);
  return useEffect(() => {
  }, [l]), useEffect(() => {
    u && (k && u.setCamera({
      deviceId: k
    }).catch((Z) => {
      console.warn(Z);
    }), D && u.setMicrophone({
      deviceId: D
    }).catch((Z) => {
      console.warn(Z);
    }));
  }, [u, k, D]), /* @__PURE__ */ React.createElement(StudioContext.Provider, {
    value: {
      studio: p,
      project: l,
      room: u,
      webcamId: k,
      microphoneId: D,
      setStudio: _,
      setProject: v,
      setRoom: c,
      setWebcamId: (Z) => {
        try {
          localStorage == null || localStorage.setItem("__LS_webcam", Z);
        } catch {
        }
        O(Z);
      },
      setMicrophoneId: (Z) => {
        try {
          localStorage == null || localStorage.setItem("__LS_microphone", Z);
        } catch {
        }
        F(Z);
      },
      projectCommands: H
    }
  }, a);
}, react = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  StudioContext,
  StudioProvider,
  useActiveProjectRoom: useActiveProjectRoom$1,
  useDevices,
  useStudio
}, Symbol.toStringTag, { value: "Module" })), ForegroundLayers = [{
  name: "ImageIframeOverlayContainer",
  id: "fg-image-iframe",
  layout: "Free"
}, {
  name: "BannerContainer",
  id: "fg-banners",
  layout: "Column",
  layoutProps: {
    cover: !0
  }
}, {
  name: "VideoOverlayContainer",
  id: "fg-video",
  layout: "Free"
}, {
  name: "LogoContainer",
  layout: "Free",
  id: "logo"
}], defaultStyles = {
  custom: {
    display: "block"
  },
  video: {
    height: "100%",
    width: "100%"
  },
  image: {
    height: "100%",
    width: "100%"
  },
  logo: {
    objectFit: "contain",
    position: "unset"
  }
}, validateEachChildren = (a, u) => {
  let c = !0;
  return a.forEach((l) => {
    var v, p;
    (v = l.props) != null && v.sourceType && !u.includes((p = l.props) == null ? void 0 : p.sourceType) ? c = !1 : l.children.length > 0 && (c = c && validateEachChildren(l.children, u));
  }), c;
}, addingCache = {
  camera: /* @__PURE__ */ new Set(),
  screen: /* @__PURE__ */ new Set(),
  rtmp: /* @__PURE__ */ new Set(),
  game: /* @__PURE__ */ new Set()
}, commands = (a) => {
  var ae, j, ue, he;
  const u = a.id, c = a.scene.getRoot(), {
    Command: l
  } = CoreContext, v = c.children.find((fe) => fe.props.id === "bg"), p = c.children.find((fe) => fe.props.id === "content"), _ = c.children.find((fe) => fe.props.id === "foreground");
  let k = (ae = _ == null ? void 0 : _.children) == null ? void 0 : ae.find((fe) => fe.props.id === "fg-image-iframe"), O = (j = _ == null ? void 0 : _.children) == null ? void 0 : j.find((fe) => fe.props.id === "logo"), D = (ue = _ == null ? void 0 : _.children) == null ? void 0 : ue.find((fe) => fe.props.id === "fg-video");
  const F = getProject(a.id);
  let H = (he = _ == null ? void 0 : _.children) == null ? void 0 : he.find((fe) => fe.props.id === "fg-banners");
  const Z = async () => {
    var fe, be;
    ((fe = v == null ? void 0 : v.props) == null ? void 0 : fe.layout) !== "Layered" && await F.compositor.update(v.id, {
      name: "Background",
      id: "bg",
      layout: "Layered"
    }), ((be = _ == null ? void 0 : _.props) == null ? void 0 : be.layout) !== "Layered" && await F.compositor.update(_.id, {
      id: "foreground",
      name: "Overlays",
      layout: "Layered"
    });
  }, ee = async () => {
    validateEachChildren(v.children, ["Background"]) || v.children.forEach(async (fe) => {
      await CoreContext.Command.deleteNode({
        nodeId: fe.id
      });
    });
  }, X = async () => {
    const fe = async () => {
      var q;
      if (H)
        return H.id;
      {
        const z = await F.compositor.insert({
          name: "BannerContainer",
          id: "fg-banners",
          layout: "Column",
          layoutProps: {
            cover: !0
          }
        }, _.id);
        return H = (q = _ == null ? void 0 : _.children) == null ? void 0 : q.find((P) => P.id === z), z;
      }
    }, be = async () => {
      var q;
      if (k)
        return k.id;
      {
        const z = await F.compositor.insert({
          name: "ImageIframeOverlay",
          id: "fg-image-iframe",
          layout: "Free"
        }, _.id);
        return k = (q = _ == null ? void 0 : _.children) == null ? void 0 : q.find((P) => P.id === z), z;
      }
    }, ke = async () => {
      var q;
      if (D)
        return D.id;
      {
        const z = await F.compositor.insert({
          name: "VideoOverlay",
          id: "fg-video",
          layout: "Free"
        }, _.id);
        return D = (q = _ == null ? void 0 : _.children) == null ? void 0 : q.find((P) => P.id === z), z;
      }
    }, Te = async () => {
      var q;
      if (O)
        return O.id;
      {
        const z = await F.compositor.insert({
          name: "Logo",
          layout: "Free",
          sourceType: "Logo",
          id: "logo",
          style: {
            width: "100%",
            height: "100%",
            objectFit: "contain",
            position: "unset"
          }
        }, _.id);
        return O = (q = _ == null ? void 0 : _.children) == null ? void 0 : q.find((P) => P.id === z), z;
      }
    };
    try {
      const q = await Promise.all([fe(), be(), ke(), Te()]);
      await F.compositor.reorder(_.id, q);
    } catch {
    }
  }, ne = {
    getBackground() {
      return v;
    },
    getContent() {
      return p;
    },
    getForeground() {
      return _;
    },
    getLayout() {
      return p.props.layout;
    },
    getBanners() {
      var fe;
      return ((fe = getProject(a.id).props) == null ? void 0 : fe.banners) || [];
    },
    getParticipants() {
      return p.children.filter((fe) => fe.props.sourceType === "RoomParticipant");
    },
    getLogo() {
      var fe, be;
      return (be = (fe = O == null ? void 0 : O.children[0]) == null ? void 0 : fe.props) == null ? void 0 : be.id;
    },
    async removeLogo() {
      const [fe, ...be] = (O == null ? void 0 : O.children) || [];
      be.forEach((ke) => {
        CoreContext.Command.deleteNode({
          nodeId: ke.id
        });
      }), fe && await CoreContext.Command.deleteNode({
        nodeId: fe.id
      });
    },
    getImageOverlay() {
      var be, ke;
      const fe = (be = k == null ? void 0 : k.children) == null ? void 0 : be.find((Te) => {
        var q, z;
        return ((z = (q = Te == null ? void 0 : Te.props) == null ? void 0 : q.sourceProps) == null ? void 0 : z.type) === "image";
      });
      return (ke = fe == null ? void 0 : fe.props) == null ? void 0 : ke.id;
    },
    getVideoOverlay() {
      var be, ke;
      const fe = (be = D == null ? void 0 : D.children) == null ? void 0 : be.find((Te) => {
        var q, z;
        return ((z = (q = Te == null ? void 0 : Te.props) == null ? void 0 : q.sourceProps) == null ? void 0 : z.type) === "video";
      });
      return (ke = fe == null ? void 0 : fe.props) == null ? void 0 : ke.id;
    },
    autoPlayBackgroundVideo(fe = {
      muted: !0,
      autoplay: !0
    }) {
      const be = v.children.find((ke) => ke.props.id === "bg-video");
      be && CoreContext.Command.updateNode({
        nodeId: be.id,
        props: {
          ...be.props,
          attributes: {
            ...be.props.attributes,
            ...fe
          }
        }
      });
    },
    autoPlayVideoOverlay(fe, be = {
      muted: !0,
      autoplay: !0
    }) {
      var Te;
      const ke = (Te = D == null ? void 0 : D.children) == null ? void 0 : Te.find((q) => {
        var z, P;
        return ((P = (z = q.props) == null ? void 0 : z.sourceProps) == null ? void 0 : P.id) === fe;
      });
      ke && ke.props.sourceProps.type === "video" && CoreContext.Command.updateNode({
        nodeId: ke.id,
        props: {
          ...ke.props,
          attributes: {
            ...ke.props.attributes,
            ...be
          }
        }
      });
    },
    getBackgroundMedia() {
      var be, ke;
      return (ke = (be = v.children.filter((Te) => Te)[0]) == null ? void 0 : be.props) == null ? void 0 : ke.id;
    },
    getBackgroundImage() {
      var be;
      const fe = v.children.find((ke) => {
        var Te, q;
        return ((q = (Te = ke.props) == null ? void 0 : Te.sourceProps) == null ? void 0 : q.type) === "image";
      });
      return (be = fe == null ? void 0 : fe.props) == null ? void 0 : be.id;
    },
    getBackgroundVideo() {
      var be;
      const fe = v.children.find((ke) => {
        var Te, q;
        return ((q = (Te = ke.props) == null ? void 0 : Te.sourceProps) == null ? void 0 : q.type) === "video";
      });
      return (be = fe == null ? void 0 : fe.props) == null ? void 0 : be.id;
    },
    async addLogo(fe, be) {
      const [ke, ...Te] = (O == null ? void 0 : O.children) || [];
      Te.forEach((q) => {
        CoreContext.Command.deleteNode({
          nodeId: q.id
        });
      }), ke ? await CoreContext.Command.updateNode({
        nodeId: ke.id,
        props: {
          sourceType: "Logo",
          id: fe,
          sourceProps: {
            ...be,
            meta: {
              style: {
                ...defaultStyles.logo
              },
              ...be.meta
            }
          }
        }
      }) : await CoreContext.Command.createNode({
        parentId: O == null ? void 0 : O.id,
        props: {
          sourceType: "Logo",
          id: fe,
          sourceProps: {
            ...be,
            meta: {
              style: {
                ...defaultStyles.logo
              },
              ...be.meta
            }
          }
        }
      });
    },
    addBanner(fe = {}) {
      var q;
      const be = fe.meta || {}, ke = {
        id: generateId(),
        props: {
          ...fe,
          meta: be
        }
      }, Te = ((q = getProject(u).props) == null ? void 0 : q.banners) || [];
      return l.updateProjectProps({
        projectId: u,
        props: {
          banners: [...Te, ke]
        }
      });
    },
    editBanner(fe, be = {}) {
      const Te = ne.getBanners().map((q) => q.id !== fe ? q : {
        ...q,
        props: be
      });
      return l.updateProjectProps({
        projectId: u,
        props: {
          banners: Te
        }
      });
    },
    removeBanner(fe) {
      var ke;
      const be = ne.getBanners();
      return (ke = H == null ? void 0 : H.children) == null || ke.forEach((Te) => {
        Te.props.bannerId === fe && CoreContext.Command.deleteNode({
          nodeId: Te.id
        });
      }), l.updateProjectProps({
        projectId: u,
        props: {
          banners: be.filter((Te) => Te.id !== fe)
        }
      });
    },
    async setActiveBanner(fe) {
      var q, z;
      const [be, ...{}] = (H == null ? void 0 : H.children) || [];
      ((z = (q = be == null ? void 0 : be.props) == null ? void 0 : q.sourceType) == null ? void 0 : z.toLowerCase()) === "chatoverlay" && await CoreContext.Command.deleteNode({
        nodeId: be.id
      });
      const [ke, ...Te] = (H == null ? void 0 : H.children) || [];
      if (Te.forEach((P) => {
        CoreContext.Command.deleteNode({
          nodeId: P.id
        });
      }), ke)
        CoreContext.Command.updateNode({
          nodeId: ke.id,
          props: {
            sourceType: "Banner",
            bannerId: fe
          }
        });
      else
        return CoreContext.Command.createNode({
          parentId: H == null ? void 0 : H.id,
          props: {
            sourceType: "Banner",
            bannerId: fe
          }
        });
    },
    getActiveBanner() {
      var fe, be, ke;
      return ((ke = (be = (fe = H.children) == null ? void 0 : fe[0]) == null ? void 0 : be.props) == null ? void 0 : ke.bannerId) ?? null;
    },
    async addChatOverlay(fe, be) {
      var z, P;
      const [ke, ...{}] = (H == null ? void 0 : H.children) || [];
      ((P = (z = ke == null ? void 0 : ke.props) == null ? void 0 : z.sourceType) == null ? void 0 : P.toLowerCase()) === "banner" && await CoreContext.Command.deleteNode({
        nodeId: ke.id
      });
      const [Te, ...q] = (H == null ? void 0 : H.children) || [];
      q.forEach((S) => {
        CoreContext.Command.deleteNode({
          nodeId: S.id
        });
      }), Te ? await CoreContext.Command.updateNode({
        nodeId: Te.id,
        props: {
          sourceType: "ChatOverlay",
          chatOverlayId: fe,
          id: fe,
          ...be
        }
      }) : await CoreContext.Command.createNode({
        parentId: H == null ? void 0 : H.id,
        props: {
          sourceType: "ChatOverlay",
          chatOverlayId: fe,
          id: fe,
          ...be
        }
      });
    },
    async removeChatOverlay(fe) {
      var be;
      (be = H == null ? void 0 : H.children) == null || be.forEach(async (ke) => {
        ke.props.chatOverlayId === fe && await CoreContext.Command.deleteNode({
          nodeId: ke.id
        });
      });
    },
    getChatOverlay() {
      var fe, be, ke, Te, q;
      return (ke = (be = (fe = H.children) == null ? void 0 : fe[0]) == null ? void 0 : be.props) != null && ke.chatOverlayId && ((q = (Te = H.children) == null ? void 0 : Te[0]) == null ? void 0 : q.props) || null;
    },
    getCustomOverlay() {
      var be, ke;
      const fe = (be = k == null ? void 0 : k.children) == null ? void 0 : be.find((Te) => {
        var q, z;
        return ((z = (q = Te == null ? void 0 : Te.props) == null ? void 0 : q.sourceProps) == null ? void 0 : z.type) === "custom";
      });
      return (ke = fe == null ? void 0 : fe.props) == null ? void 0 : ke.id;
    },
    async addImageOverlay(fe, be) {
      const [ke, ...Te] = (k == null ? void 0 : k.children) || [];
      Te.forEach((z) => {
        CoreContext.Command.deleteNode({
          nodeId: z.id
        });
      });
      const q = {
        ...defaultStyles.image,
        ...(D == null ? void 0 : D.children.length) && {
          opacity: 0
        }
      };
      ke ? await CoreContext.Command.updateNode({
        nodeId: ke == null ? void 0 : ke.id,
        props: {
          sourceType: "Overlay",
          id: fe,
          sourceProps: {
            ...be,
            type: "image",
            meta: {
              style: {
                ...q
              }
            }
          }
        }
      }) : await CoreContext.Command.createNode({
        parentId: k == null ? void 0 : k.id,
        props: {
          sourceType: "Overlay",
          id: fe,
          sourceProps: {
            ...be,
            type: "image",
            meta: {
              style: {
                ...q
              }
            }
          }
        }
      });
    },
    async addVideoOverlay(fe, be) {
      const [ke, ...Te] = (D == null ? void 0 : D.children) || [];
      Te.forEach((q) => {
        CoreContext.Command.deleteNode({
          nodeId: q.id
        });
      }), k.children.forEach(({
        id: q,
        props: z
      }) => {
        var P, S;
        if (((S = (P = z.sourceProps.meta) == null ? void 0 : P.style) == null ? void 0 : S.opacity) !== 0) {
          const E = z.sourceProps.type, I = {
            ...defaultStyles[E],
            opacity: 0
          };
          CoreContext.Command.updateNode({
            nodeId: q,
            props: {
              ...z,
              sourceProps: {
                ...z.sourceProps,
                meta: {
                  style: {
                    ...I
                  }
                }
              }
            }
          });
        }
      }), ke ? await CoreContext.Command.updateNode({
        nodeId: ke == null ? void 0 : ke.id,
        props: {
          sourceType: "Overlay",
          id: fe,
          sourceProps: {
            ...be,
            type: "video",
            meta: {
              style: {
                ...defaultStyles.video
              },
              ...be.meta
            }
          }
        }
      }) : await CoreContext.Command.createNode({
        parentId: D == null ? void 0 : D.id,
        props: {
          sourceType: "Overlay",
          id: fe,
          sourceProps: {
            ...be,
            type: "video",
            meta: {
              style: {
                ...defaultStyles.video
              },
              ...be.meta
            }
          }
        }
      });
    },
    async updateVideoOverlayProps(fe, be) {
      var Te, q;
      const ke = ((Te = D == null ? void 0 : D.children) == null ? void 0 : Te.find((z) => {
        var P;
        return ((P = z == null ? void 0 : z.props) == null ? void 0 : P.id) === fe;
      })) || null;
      ke && await CoreContext.Command.updateNode({
        nodeId: ke == null ? void 0 : ke.id,
        props: {
          sourceType: "Overlay",
          id: fe,
          sourceProps: {
            ...(q = ke == null ? void 0 : ke.props) == null ? void 0 : q.sourceProps,
            ...be,
            meta: {
              style: {
                ...defaultStyles.video
              },
              ...be.meta
            }
          }
        }
      });
    },
    async addCustomOverlay(fe, be) {
      const [ke, ...Te] = (k == null ? void 0 : k.children) || [];
      Te.forEach((z) => {
        CoreContext.Command.deleteNode({
          nodeId: z.id
        });
      });
      const q = {
        ...defaultStyles.custom,
        ...(D == null ? void 0 : D.children.length) && {
          opacity: 0
        }
      };
      ke ? await CoreContext.Command.updateNode({
        nodeId: ke == null ? void 0 : ke.id,
        props: {
          sourceType: "Overlay",
          id: fe,
          sourceProps: {
            ...be,
            type: "custom",
            meta: {
              style: {
                ...q
              }
            }
          }
        }
      }) : await CoreContext.Command.createNode({
        parentId: k == null ? void 0 : k.id,
        props: {
          sourceType: "Overlay",
          id: fe,
          sourceProps: {
            ...be,
            type: "custom",
            meta: {
              style: {
                ...q
              }
            }
          }
        }
      });
    },
    async removeCustomOverlay() {
      var ke, Te;
      const [fe, ...be] = (k == null ? void 0 : k.children) || [];
      be.forEach((q) => {
        CoreContext.Command.deleteNode({
          nodeId: q.id
        });
      }), fe && ((Te = (ke = fe == null ? void 0 : fe.props) == null ? void 0 : ke.sourceProps) == null ? void 0 : Te.type) === "custom" && await CoreContext.Command.deleteNode({
        nodeId: fe.id
      });
    },
    async removeImageOverlay() {
      var ke, Te;
      const [fe, ...be] = (k == null ? void 0 : k.children) || [];
      be.forEach((q) => {
        CoreContext.Command.deleteNode({
          nodeId: q.id
        });
      }), fe && ((Te = (ke = fe == null ? void 0 : fe.props) == null ? void 0 : ke.sourceProps) == null ? void 0 : Te.type) === "image" && await CoreContext.Command.deleteNode({
        nodeId: fe.id
      });
    },
    async removeVideoOverlay() {
      const [fe, ...be] = (D == null ? void 0 : D.children) || [];
      be.forEach((ke) => {
        CoreContext.Command.deleteNode({
          nodeId: ke.id
        });
      }), fe && await CoreContext.Command.deleteNode({
        nodeId: fe.id
      }), k == null || k.children.forEach(({
        id: ke,
        props: Te
      }) => {
        var q, z;
        if (((z = (q = Te.sourceProps.meta) == null ? void 0 : q.style) == null ? void 0 : z.opacity) === 0) {
          const P = Te.sourceProps.type, S = {
            ...defaultStyles[P],
            opacity: 1
          };
          CoreContext.Command.updateNode({
            nodeId: ke,
            props: {
              ...Te,
              sourceProps: {
                ...Te.sourceProps,
                meta: {
                  style: {
                    ...S
                  }
                }
              }
            }
          });
        }
      });
    },
    setLayout(fe, be = {}) {
      const ke = p.props.layoutProps.showcase;
      l.setNodeLayout({
        nodeId: p.id,
        layout: fe,
        layoutProps: {
          showcase: ke,
          ...be
        }
      });
    },
    async setBackgroundImage(fe, be) {
      const [ke, ...Te] = (v == null ? void 0 : v.children) || [];
      Te.forEach((q) => {
        CoreContext.Command.deleteNode({
          nodeId: q.id
        });
      }), ke ? await CoreContext.Command.updateNode({
        nodeId: ke.id,
        props: {
          id: fe,
          sourceType: "Background",
          sourceProps: {
            ...be,
            type: "image",
            meta: {
              style: {
                ...defaultStyles.image
              },
              ...be == null ? void 0 : be.meta
            }
          }
        }
      }) : await CoreContext.Command.createNode({
        parentId: v == null ? void 0 : v.id,
        props: {
          id: fe,
          sourceType: "Background",
          sourceProps: {
            ...be,
            type: "image",
            meta: {
              style: {
                ...defaultStyles.image
              },
              ...be == null ? void 0 : be.meta
            }
          }
        }
      });
    },
    async setBackgroundVideo(fe, be) {
      const [ke, ...Te] = (v == null ? void 0 : v.children) || [];
      Te.forEach((q) => {
        CoreContext.Command.deleteNode({
          nodeId: q.id
        });
      }), ke ? await CoreContext.Command.updateNode({
        nodeId: ke.id,
        props: {
          id: fe,
          sourceType: "Background",
          sourceProps: {
            ...be,
            type: "video",
            meta: {
              style: {
                ...defaultStyles.video
              },
              ...be == null ? void 0 : be.meta
            }
          }
        }
      }) : await CoreContext.Command.createNode({
        parentId: v == null ? void 0 : v.id,
        props: {
          id: fe,
          sourceType: "Background",
          sourceProps: {
            ...be,
            type: "video",
            meta: {
              style: {
                ...defaultStyles.video
              },
              ...be == null ? void 0 : be.meta
            }
          }
        }
      });
    },
    async updateBackgroundVideoProps(fe, be) {
      var Te, q;
      const ke = ((Te = v == null ? void 0 : v.children) == null ? void 0 : Te.find((z) => {
        var P;
        return ((P = z == null ? void 0 : z.props) == null ? void 0 : P.id) === fe;
      })) || null;
      ke && await CoreContext.Command.updateNode({
        nodeId: ke == null ? void 0 : ke.id,
        props: {
          sourceType: "Background",
          id: fe,
          sourceProps: {
            ...(q = ke == null ? void 0 : ke.props) == null ? void 0 : q.sourceProps,
            ...be,
            meta: {
              style: {
                ...defaultStyles.video
              },
              ...be.meta
            }
          }
        }
      });
    },
    async removeBackgroundImage() {
      const [fe, ...be] = (v == null ? void 0 : v.children) || [];
      be.forEach((ke) => {
        CoreContext.Command.deleteNode({
          nodeId: ke.id
        });
      }), fe && fe.props.sourceProps.type === "image" && await CoreContext.Command.deleteNode({
        nodeId: fe.id
      });
    },
    async removeBackgroundVideo() {
      const [fe, ...be] = (v == null ? void 0 : v.children) || [];
      be.forEach((ke) => {
        CoreContext.Command.deleteNode({
          nodeId: ke.id
        });
      }), fe && fe.props.sourceProps.type === "video" && await CoreContext.Command.deleteNode({
        nodeId: fe.id
      });
    },
    /* A function that takes in a sourceType and a callback function. It then creates a shallow copy of
      the root node and finds all the nodes that have the same sourceType as the one passed in. It then
      creates a listener for when the node changes, is added, or is removed. When any of these events
      happen, it will call the callback function with the new state. */
    useLayerState(fe, be) {
      const ke = cloneDeep$1(c);
      let Te = findAll(ke, (E) => E.props.sourceType === fe);
      const q = () => {
        be((Te == null ? void 0 : Te.map((E) => E.props)) || {});
      }, z = CoreContext.onInternal("NodeChanged", (E) => {
        const I = Te == null ? void 0 : Te.find((U) => U.id === E.nodeId);
        if (Te != null && Te.length && !I)
          return;
        const M = Te, $ = cloneDeep$1(c);
        Te = findAll($, (U) => {
          var Y;
          return ((Y = U == null ? void 0 : U.props) == null ? void 0 : Y.sourceType) === fe;
        }), deepEqual(M, Te) || q();
      }), P = CoreContext.onInternal("NodeAdded", (E) => {
        var U;
        if (Te == null ? void 0 : Te.find((Y) => Y.id === E.nodeId))
          return;
        const M = cloneDeep$1(c);
        Te = findAll(M, (Y) => {
          var B;
          return ((B = Y == null ? void 0 : Y.props) == null ? void 0 : B.sourceType) === fe;
        });
        const $ = Te == null ? void 0 : Te.find((Y) => Y.id === E.nodeId);
        ((U = $ == null ? void 0 : $.props) == null ? void 0 : U.sourceType) === fe && q();
      }), S = CoreContext.onInternal("NodeRemoved", (E) => {
        var M;
        const I = Te == null ? void 0 : Te.find(($) => $.id === E.nodeId);
        I && (Te = Te == null ? void 0 : Te.filter(($) => $.id !== E.nodeId), ((M = I == null ? void 0 : I.props) == null ? void 0 : M.sourceType) === fe && q());
      });
      return q(), () => {
        z(), P(), S();
      };
    },
    setShowcase(fe, be = "camera") {
      const ke = ne.getParticipantNode(fe, be);
      return CoreContext.Command.updateNode({
        nodeId: p.id,
        props: {
          layoutProps: {
            ...p.props.layoutProps,
            showcase: (ke == null ? void 0 : ke.id) ?? null
          }
        }
      });
    },
    useShowcase(fe) {
      const be = () => {
        const ke = p.props.layoutProps.showcase, Te = p.children.find((z) => z.id === ke);
        if (!Te)
          return fe({
            participantId: null,
            type: null
          });
        const {
          sourceProps: q
        } = Te.props;
        return fe({
          participantId: q.id,
          type: q.type
        });
      };
      return be(), CoreContext.onInternal("NodeChanged", (ke) => {
        ke.nodeId === p.id && be();
      });
    },
    getRTMPNode(fe) {
      return p.children.find((be) => {
        var ke, Te;
        return ((ke = be.props.sourceProps) == null ? void 0 : ke.id) === fe && ((Te = be.props.sourceProps) == null ? void 0 : Te.type) === "rtmp";
      });
    },
    useRTMPNodes(fe) {
      let be = [];
      const ke = () => {
        const z = p.children.filter((P) => {
          var S, E;
          return ((E = (S = P.props) == null ? void 0 : S.sourceProps) == null ? void 0 : E.type) === "rtmp";
        });
        return be = z.map((P) => P.id), fe(z);
      };
      ke();
      const Te = CoreContext.onInternal("NodeAdded", (z) => {
        var S, E;
        const P = a.scene.get(z.nodeId);
        ((E = (S = P == null ? void 0 : P.props) == null ? void 0 : S.sourceProps) == null ? void 0 : E.type) === "rtmp" && ke();
      }), q = CoreContext.onInternal("NodeRemoved", (z) => {
        be.indexOf(z.nodeId) !== -1 && ke();
      });
      return () => {
        Te(), q();
      };
    },
    async addRTMPSource(fe, be = {
      isMuted: !0,
      isHidden: !1,
      volume: 0
    }) {
      const ke = "rtmp";
      if (addingCache[ke].has(fe))
        return;
      const {
        isMuted: Te = !1,
        isHidden: q = !1,
        volume: z = 1
      } = be;
      if (p.children.find((E) => {
        var I, M;
        return ((I = E.props.sourceProps) == null ? void 0 : I.id) === fe && ((M = E.props.sourceProps) == null ? void 0 : M.type) === ke;
      }))
        return;
      addingCache[ke].add(fe), p.children[0];
      let S = p.children.length;
      await CoreContext.Command.createNode({
        props: {
          name: "RTMP",
          sourceType: "RTMP",
          sourceProps: {
            type: ke,
            id: fe
          },
          volume: z,
          isMuted: Te,
          isHidden: q
        },
        parentId: p.id,
        index: S
      }).finally(() => {
        addingCache[ke].delete(fe);
      });
    },
    removeRTMPSource(fe) {
      const be = "rtmp";
      p.children.filter((ke) => {
        var Te, q;
        return ((Te = ke.props.sourceProps) == null ? void 0 : Te.id) === fe && ((q = ke.props.sourceProps) == null ? void 0 : q.type) === be && ke.props.sourceType === "RTMP";
      }).forEach((ke) => {
        CoreContext.Command.deleteNode({
          nodeId: ke.id
        });
      });
    },
    getGameSourceNode(fe) {
      return p.children.find((be) => {
        var ke, Te;
        return ((ke = be.props.sourceProps) == null ? void 0 : ke.id) === fe && ((Te = be.props.sourceProps) == null ? void 0 : Te.type) === "game";
      });
    },
    useGameSourceNodes(fe) {
      let be = [];
      const ke = () => {
        const z = p.children.filter((P) => {
          var S, E;
          return ((E = (S = P.props) == null ? void 0 : S.sourceProps) == null ? void 0 : E.type) === "game";
        });
        return be = z.map((P) => P.id), fe(z);
      };
      ke();
      const Te = CoreContext.onInternal("NodeAdded", (z) => {
        var S, E;
        const P = a.scene.get(z.nodeId);
        ((E = (S = P == null ? void 0 : P.props) == null ? void 0 : S.sourceProps) == null ? void 0 : E.type) === "game" && ke();
      }), q = CoreContext.onInternal("NodeRemoved", (z) => {
        be.indexOf(z.nodeId) !== -1 && ke();
      });
      return () => {
        Te(), q();
      };
    },
    async addGameSource(fe, be = {
      isMuted: !0,
      isHidden: !1,
      volume: 0
    }) {
      const ke = "game";
      if (addingCache[ke].has(fe))
        return;
      const {
        isMuted: Te = !1,
        isHidden: q = !1,
        volume: z = 1
      } = be;
      if (p.children.find((E) => {
        var I, M;
        return ((I = E.props.sourceProps) == null ? void 0 : I.id) === fe && ((M = E.props.sourceProps) == null ? void 0 : M.type) === ke;
      }))
        return;
      addingCache[ke].add(fe), p.children[0];
      let S = p.children.length;
      await CoreContext.Command.createNode({
        props: {
          name: "Game",
          sourceType: "Game",
          sourceProps: {
            type: ke,
            id: fe
          },
          volume: z,
          isMuted: Te,
          isHidden: q
        },
        parentId: p.id,
        index: S
      }).finally(() => {
        addingCache[ke].delete(fe);
      });
    },
    removeGameSource(fe) {
      const be = "game";
      p.children.filter((ke) => {
        var Te, q;
        return ((Te = ke.props.sourceProps) == null ? void 0 : Te.id) === fe && ((q = ke.props.sourceProps) == null ? void 0 : q.type) === be && ke.props.sourceType === "Game";
      }).forEach((ke) => {
        CoreContext.Command.deleteNode({
          nodeId: ke.id
        });
      });
    },
    async addParticipantTrack(fe, be = {
      isMuted: !0,
      isHidden: !1,
      volume: 0
    }, ke = "camera") {
      if (addingCache[ke].has(fe))
        return;
      const {
        isMuted: Te = !1,
        isHidden: q = !1,
        volume: z = 1
      } = be;
      if (p.children.find((I) => {
        var M, $;
        return ((M = I.props.sourceProps) == null ? void 0 : M.id) === fe && (($ = I.props.sourceProps) == null ? void 0 : $.type) === ke;
      }))
        return;
      addingCache[ke].add(fe);
      const S = p.children[0];
      let E = p.children.length;
      ke === "screen" && (S == null ? void 0 : S.props.sourceProps.type) !== "screen" && (E = 0), await CoreContext.Command.createNode({
        props: {
          name: "Participant",
          sourceType: "RoomParticipant",
          sourceProps: {
            type: ke,
            id: fe
          },
          volume: z,
          isMuted: Te,
          isHidden: q
        },
        parentId: p.id,
        index: E
      }).finally(() => {
        addingCache[ke].delete(fe);
      });
    },
    removeParticipantTrack(fe, be = "camera") {
      p.children.filter((ke) => {
        var Te, q;
        return ((Te = ke.props.sourceProps) == null ? void 0 : Te.id) === fe && ((q = ke.props.sourceProps) == null ? void 0 : q.type) === be && ke.props.sourceType === "RoomParticipant";
      }).forEach((ke) => {
        CoreContext.Command.deleteNode({
          nodeId: ke.id
        });
      });
    },
    async addParticipant(fe, be = {}, ke = "camera") {
      if (addingCache[ke].has(fe))
        return;
      const {
        isMuted: Te = !1,
        isHidden: q = !1,
        volume: z = 1
      } = be;
      if (p.children.find((I) => {
        var M, $;
        return ((M = I.props.sourceProps) == null ? void 0 : M.id) === fe && (($ = I.props.sourceProps) == null ? void 0 : $.type) === ke;
      }))
        return;
      addingCache[ke].add(fe);
      const S = p.children[0];
      let E = p.children.length;
      ke === "screen" && (S == null ? void 0 : S.props.sourceProps.type) !== "screen" && (E = 0), await CoreContext.Command.createNode({
        props: {
          name: "Participant",
          sourceType: "RoomParticipant",
          sourceProps: {
            type: ke,
            id: fe
          },
          volume: z,
          isMuted: Te,
          isHidden: q
        },
        parentId: p.id,
        index: E
      }).finally(() => {
        addingCache[ke].delete(fe);
      });
    },
    removeParticipant(fe, be = "camera") {
      p.children.filter((ke) => {
        var Te, q;
        return ((Te = ke.props.sourceProps) == null ? void 0 : Te.id) === fe && ((q = ke.props.sourceProps) == null ? void 0 : q.type) === be && ke.props.sourceType === "RoomParticipant";
      }).forEach((ke) => {
        CoreContext.Command.deleteNode({
          nodeId: ke.id
        });
      });
    },
    getParticipantNode(fe, be = "camera") {
      return p.children.find((ke) => {
        var Te, q;
        return ((Te = ke.props.sourceProps) == null ? void 0 : Te.id) === fe && ((q = ke.props.sourceProps) == null ? void 0 : q.type) === be;
      });
    },
    getParticipantState(fe, be = "camera") {
      var ke;
      return (ke = ne.getParticipantNode(fe, be)) == null ? void 0 : ke.props;
    },
    useParticipantState(fe, be, ke = "camera") {
      let Te = ne.getParticipantNode(fe, ke);
      const q = () => {
        be(Te == null ? void 0 : Te.props);
      }, z = CoreContext.onInternal("NodeChanged", (S) => {
        if (S.nodeId !== p.id)
          return;
        const E = Te;
        Te = ne.getParticipantNode(fe, ke), E !== Te && q();
      }), P = CoreContext.onInternal("NodeChanged", (S) => {
        !Te || S.nodeId !== Te.id || q();
      });
      return q(), () => {
        z(), P();
      };
    },
    setParticipantVolume(fe, be) {
      const ke = ne.getParticipantNode(fe);
      ke && CoreContext.Command.updateNode({
        nodeId: ke.id,
        props: {
          volume: be
        }
      });
    },
    setParticipantMuted(fe, be) {
      const ke = ne.getParticipantNode(fe);
      ke && CoreContext.Command.updateNode({
        nodeId: ke.id,
        props: {
          isMuted: be
        }
      });
    },
    setParticipantHidden(fe, be) {
      const ke = ne.getParticipantNode(fe);
      ke && CoreContext.Command.updateNode({
        nodeId: ke.id,
        props: {
          isHidden: be
        }
      });
    },
    pruneParticipants() {
      const fe = getProjectRoom(u);
      fe && p.children.filter((be) => {
        var S, E, I;
        if (be.props.sourceType !== "RoomParticipant")
          return !1;
        const ke = (S = be.props.sourceProps) == null ? void 0 : S.type, Te = fe.getParticipant((E = be.props.sourceProps) == null ? void 0 : E.id), q = fe.getTrack((I = be.props.sourceProps) == null ? void 0 : I.id);
        return !Te && !q ? !0 : ke === "camera" ? !1 : !Te.trackIds.map((M) => fe.getTrack(M)).filter(Boolean).some((M) => (M.type === Track.Source.Camera || M.type === Track.Source.Microphone ? "camera" : "screen") === ke);
      }).forEach((be) => {
        CoreContext.Command.deleteNode({
          nodeId: be.id
        });
      });
    },
    getProp(fe) {
      return getProject(a.id).props[fe];
    },
    setProp(fe, be) {
      return l.updateProjectProps({
        projectId: u,
        props: {
          [fe]: be
        }
      });
    },
    useProp(fe, be) {
      return CoreContext.on("ProjectChanged", (ke) => {
        u === ke.project.id && be(ke.project.props[fe]);
      });
    },
    createSource(fe) {
      return CoreContext.Command.createSource({
        projectId: u,
        ...fe
      });
    },
    deleteSource(fe) {
      return CoreContext.Command.deleteSource({
        projectId: u,
        sourceId: fe
      });
    },
    createGameSource(fe) {
      if (!getProject(a.id).videoApi.project.sources.find((ke) => {
        var Te, q;
        return ((q = (Te = ke.address) == null ? void 0 : Te.dynamic) == null ? void 0 : q.id) === "integration";
      }))
        return CoreContext.Command.createSource({
          projectId: u,
          ...fe
        });
    }
  };
  return (async () => {
    await Z(), await ee(), await X();
  })(), ne;
}, create = async (a = {}, u = {}, c) => CoreContext.Command.createProject({
  settings: a,
  props: u,
  size: c
}), createCompositor = async (a, u, c) => {
  const {
    layout: l,
    layoutProps: v = {}
  } = c, p = await CoreContext.compositor.createProject({
    props: {
      name: "Root",
      type: "sceneless-project",
      sourceType: "Element",
      layout: "Layered",
      size: u,
      isRoot: !0,
      tagName: "div",
      version: "beta",
      fields: {
        style: {
          background: "black"
        }
      }
    }
  }, a), _ = p.getRoot(), k = await Promise.all([p.insert({
    name: "Background",
    id: "bg",
    layout: "Layered"
  }, _.id), p.insert({
    id: "content",
    name: "Content",
    layout: l,
    layoutProps: v
  }, _.id), p.insert({
    id: "foreground",
    name: "Overlays",
    layout: "Layered"
  }, _.id)]);
  await p.reorder(_.id, k);
  const O = _.children.find((H) => H.props.id === "foreground"), D = ForegroundLayers.map((H) => p.insert(H, O.id)), F = await Promise.all(D);
  return await p.reorder(O.id, F), p;
}, scenelessProject = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  commands,
  create,
  createCompositor
}, Symbol.toStringTag, { value: "Module" })), useActiveProjectRoom = (a) => {
  const u = getProject(CoreContext.state.activeProjectId);
  return a(u ? getRoom(u.roomId) : null), CoreContext.on("RoomJoined", () => {
    const c = getProject(CoreContext.state.activeProjectId);
    a(c ? getRoom(c.roomId) : null);
  });
}, callbacks = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  useActiveProjectRoom
}, Symbol.toStringTag, { value: "Module" })), index$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Callback: callbacks,
  React: react,
  Room: webrtc,
  ScenelessProject: scenelessProject
}, Symbol.toStringTag, { value: "Module" })), runFilters = (a, u = []) => u.reduce((c, l) => l(c), a), transforms = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  runFilters
}, Symbol.toStringTag, { value: "Module" })), createDefault = () => ({
  root: document.createElement("div")
}), init$2 = (a = {}, u, c) => {
  const l = {}, v = a.defaultTransforms || {}, p = (Q) => {
    asArray(Q).forEach((ae) => {
      l[ae.name] = ae;
    });
  }, _ = {}, k = {}, O = {}, D = (Q) => O[Q] || [], F = (Q) => k[Q] || [], H = (Q) => _[Q], Z = (Q) => l[Q];
  u.on("SourceChanged", (Q) => {
    F(Q.id).forEach((j) => {
      const ue = u.getNode(j.nodeId);
      j._onUpdateHandlers.forEach((he) => he(ue.props || {}));
    });
  }), u.on("AvailableSourcesChanged", ({
    type: Q,
    sources: ae
  }) => {
    D(Q).forEach((ue) => {
      ee(ue.nodeId);
    });
  });
  const ee = (Q) => {
    var q, z, P;
    const ae = H(Q);
    if (!ae)
      return;
    const j = Z(ae.transformName);
    if (!j.useSource)
      return;
    const ue = u.getNode(Q), he = ae.sourceType, fe = c.getSources(he), be = j.useSource(fe, ue.props), ke = ae.sourceValue, Te = be == null ? void 0 : be.value;
    ae.source !== be && (k[(q = ae.source) == null ? void 0 : q.id] && (k[(z = ae.source) == null ? void 0 : z.id] = k[(P = ae.source) == null ? void 0 : P.id].filter((S) => S.nodeId !== Q)), k[be == null ? void 0 : be.id] = [...k[be == null ? void 0 : be.id] || [], ae]), ae.source = be, ae.sourceValue = Te, Object.is(ke, Te) || ae._onNewSourceHandlers.forEach((S) => S(be));
  }, X = (Q) => {
    const ae = ne(Q), ue = runFilters(Q, []);
    return ee(Q.id), ae == null || ae._onUpdateHandlers.forEach((he) => he(Q.props || {})), {
      ...ue,
      children: ue.children.map(X)
    };
  }, ne = (Q) => {
    if (_[Q.id])
      return _[Q.id];
    const {
      props: ae = {}
    } = Q, {
      sourceType: j
    } = ae;
    if (!j)
      return null;
    let ue = v[j], he;
    if (ue ? he = l[ue] : he = Object.values(l).find((E) => E.sourceType === j), !he)
      throw new Error("Could not find matching transform for sourceType: " + j);
    const fe = [], be = [], ke = [], Te = [], z = {
      ...(he.create || createDefault)({
        onEvent: (E, I, ...M) => {
          const $ = u.on(E, I, ...M);
          return Te.push($), $;
        },
        onNewSource: (E) => fe.push(E),
        onUpdate: (E) => be.push(E),
        onRemove: (E) => ke.push(E)
      }, Q.props),
      sourceType: j,
      nodeId: Q.id,
      transformName: he.name,
      _onNewSourceHandlers: fe,
      _onUpdateHandlers: be,
      _disposables: Te
    };
    _[Q.id] = z;
    const P = j;
    O[P] = [...O[P] || [], z], he.useSource && ee(Q.id);
    const S = [
      // Dispose when node is removed
      u.on("NodeRemoved", ({
        nodeId: E
      }) => {
        if (E === Q.id) {
          const I = u.getNode(E), {
            sourceType: M = "Element"
          } = I.props;
          S.forEach((U) => U == null ? void 0 : U()), Te.forEach((U) => U == null ? void 0 : U()), ke.forEach((U) => U == null ? void 0 : U()), delete _[I.id];
          const $ = M;
          O[$] = O[$].filter((U) => U !== _[I.id]);
        }
      })
    ];
    return z;
  };
  return {
    transforms: l,
    nodeElementIndex: _,
    elementSourceTypeIndex: O,
    registerTransform: p,
    getElementsBySourceType: D,
    getElementByNodeId: H,
    getTransformByName: Z,
    updateSourceForNode: ee,
    renderTree: X,
    getElement: ne
  };
}, TRANSITION_DURATION = 300, findLayoutUp = (a, u, c = 0) => {
  const v = a.parentElement;
  return v instanceof Layout && (c = 0, !u || u(v)) ? v : v ? c > 4 ? null : findLayoutUp(v, u, c + 1) : null;
}, TRANSITION_FIELDS = "opacity, transform, width, height, left, right, top, bottom, inset", layoutIndex = {}, parentIdIndex = {}, childIndex = {};
let rootLayout, _cid = 1;
const ignoredAttributes = ["style", "id", "className"];
let tickOps = {};
const tick = () => {
  if (nextTick = null, window.__dragging) {
    nextTick = nextTick || requestAnimationFrame(tick);
    return;
  }
  const a = /* @__PURE__ */ new Set(), u = /* @__PURE__ */ new Set(), c = /* @__PURE__ */ new Set();
  Object.entries(tickOps).forEach(([l, v]) => {
    v.forEach(([p, _, k]) => {
      switch (p) {
        case "childInserted": {
          u.has(k) ? u.delete(k) : a.add(k);
          break;
        }
        case "childRemoved": {
          a.has(k) ? a.delete(k) : u.add(k);
          break;
        }
        case "childRemoveFinished": {
          c.add(k);
          break;
        }
      }
    });
  });
  try {
    u.forEach((v) => {
      var k, O, D;
      const p = childIndex[v], _ = Array.from(((k = p.parentEl) == null ? void 0 : k.children) || []);
      p.nextSiblingEl && _.includes(p.nextSiblingEl) ? (O = p.parentEl) == null || O.insertBefore(p, p.nextSiblingEl) : (p.nextSiblingEl = null, (D = p.parentEl) == null || D.append(p)), p.runRemove();
    }), c.forEach((v) => {
      const p = childIndex[v];
      if (p.removed) {
        p.previousSiblingEl && (p.previousSiblingEl.nextSiblingEl = p.nextSiblingEl), p.nextSiblingEl && (p.nextSiblingEl.previousSiblingEl = p.previousSiblingEl);
        return;
      }
    });
    const l = window.__scale;
    Object.entries(tickOps).forEach(([v, p]) => {
      const _ = layoutIndex[v], k = _.getBoundingClientRect(), O = {
        x: k.width / l,
        y: k.height / l
      };
      _.updatePositions({
        size: O,
        inserted: a,
        removed: u
      });
    });
  } catch (l) {
    log.warn("Failed to run Layout ops", l);
  }
  tickOps = {};
};
let nextTick;
const queueOp = (a) => {
  const [u, c] = a, l = tickOps[c] || [];
  tickOps[c] = [...l, a], nextTick = nextTick || requestAnimationFrame(tick);
};
class Layout extends HTMLElement {
  constructor() {
    super();
    Ft(this, "parentEl");
    Ft(this, "slotEl");
    Ft(this, "parentLayout");
    Ft(this, "nodes");
    Ft(this, "mutationObserver");
    Ft(this, "latestSize");
    Ft(this, "isFirst", !0);
    Ft(this, "isUpdating", !1);
    Ft(this, "cid");
    this.cid = ++_cid;
  }
  log(...c) {
    var l;
    log.debug(...c, {
      id: this.dataset.id,
      parent: (l = this.parentLayout) == null ? void 0 : l.dataset.id
    }, this);
  }
  connectedCallback() {
    var c;
    this.parentEl = this.parentElement, this.parentLayout = findLayoutUp(this), this.slotEl = this.closest("[data-layout-child]"), Array.from(this.children).forEach((l) => this.initializeChild(l)), rootLayout || (rootLayout = this), layoutIndex[this.dataset.id] = this, parentIdIndex[this.dataset.id] = (c = this.parentLayout) == null ? void 0 : c.id, Object.assign(this.style, {
      width: "100%",
      height: "100%",
      position: "absolute",
      top: "0px",
      left: "0px",
      pointerEvents: "none",
      boxSizing: "border-box"
    }), this.mutationObserver && this.mutationObserver.disconnect(), this.mutationObserver = new MutationObserver((l) => {
      this.isConnected && l.forEach((v) => {
        v.type === "attributes" && !ignoredAttributes.includes(v.attributeName) ? queueOp(["attributesChanged", this.dataset.id]) : v.type === "childList" && (v.addedNodes.forEach((p) => {
          const _ = childIndex[p.dataset.id];
          p.removed || (_ ? _ !== p && (this.initializeChild(p), p.setAttribute("style", _.getAttribute("style")), p.data = _.data) : this.initializeChild(p), queueOp(["childInserted", this.dataset.id, p.dataset.id]));
        }), v.removedNodes.forEach((p) => {
          p.removed || queueOp(["childRemoved", this.dataset.id, p.dataset.id]);
        }));
      });
    }), this.mutationObserver.observe(this, {
      childList: !0,
      attributes: !0
    }), this.latestSize || queueOp(["attributesChanged", this.dataset.id]);
  }
  disconnectedCallback() {
  }
  adoptedCallback() {
  }
  updatePositions(c) {
    if (this.isUpdating)
      return;
    this.isUpdating = !0;
    const {
      size: l,
      inserted: v = /* @__PURE__ */ new Set(),
      removed: p = /* @__PURE__ */ new Set()
    } = c;
    this.nodes = Array.from(this.children || []).filter((D) => !D.removed).map((D, F) => {
      const H = getElementAttributes(D);
      return {
        // TODO: Does this work well enough? Think through keying
        id: D.dataset.id,
        props: H,
        children: []
      };
    });
    const _ = JSON.parse(this.getAttribute("props") || "{}");
    this.latestSize = l;
    const k = {
      id: this.dataset.id,
      props: _,
      children: this.nodes,
      size: l
    };
    let O = layoutChildren(k);
    Promise.all(Object.entries(O).map(async ([D, F]) => {
      var he, fe, be, ke;
      let H = childIndex[D] || this.querySelector(`[data-layout-child][data-id="${D}"]`);
      const Z = {
        ...H.data,
        ...F
      };
      H.data = Z;
      const {
        size: ee,
        position: X,
        zIndex: ne = 1,
        opacity: Q = 1,
        borderRadius: ae = 0,
        entryTransition: j = {},
        exitTransition: ue = {}
      } = Z;
      if (H) {
        if (H.removed)
          return;
        ue && (H.data.exitTransition = ue), j && (H.data.entryTransition = j), H.data.size = ee, H.data.position = X;
        const Te = window.__scale, q = this.getBoundingClientRect(), z = q.width / Te, P = z - sizeToNum(X.x, z) - sizeToNum(ee.x, z), S = q.height / Te, E = S - sizeToNum(X.y, S) - sizeToNum(ee.y, S);
        Object.assign(H.style, {
          position: "absolute",
          transformOrigin: "50% 50%",
          transitionDuration: "0ms",
          transitionDelay: "0ms",
          transform: "translate3d(0, 0, 0) scaleX(1) scaleY(1)",
          visibility: "visible",
          boxSizing: "border-box",
          overflow: "hidden",
          borderRadius: ae + "px",
          width: "auto",
          height: "auto"
        });
        let I = "0ms", M = this.isFirst ? asDuration(0) : asDuration(TRANSITION_DURATION);
        if (v.has(D))
          Object.assign(H.style, {
            transitionProperty: TRANSITION_FIELDS,
            transitionDuration: "0ms",
            transitionTimingFunction: j.timingFn ?? "ease",
            transform: `translate3d(calc(${asSize(((he = j.offset) == null ? void 0 : he.x) ?? 0)}), calc(${asSize(((fe = j.offset) == null ? void 0 : fe.y) ?? 0)}), 0) scaleX(${((be = j.scale) == null ? void 0 : be.x) ?? 1}) scaleY(${((ke = j.scale) == null ? void 0 : ke.y) ?? 1})`,
            opacity: j.opacity ?? Q,
            left: asSize(X.x) || 0,
            right: asSize(P) || 0,
            top: asSize(X.y) || 0,
            bottom: asSize(E) || 0
          }), I = asDuration(j.delay ?? 0);
        else if (H.data.rootOffset) {
          const Y = rootLayout.getBoundingClientRect(), B = this.getBoundingClientRect(), T = {
            x: B.x / Te - Y.x / Te,
            y: B.y / Te - Y.y / Te
          }, L = T.x + B.width / Te, te = H.data.rootOffset.x + Number(H.data.size.x), me = T.y + B.height / Te, Ce = H.data.rootOffset.y + Number(H.data.size.y);
          H.data.rootOffset.x - T.x, H.data.rootOffset.y - T.y, L - te, me - Ce;
        }
        H.addEventListener("transitionstart", () => {
          H.style.zIndex = String(ne + 1);
        }), await new Promise((Y) => window.setTimeout(Y)), Object.assign(H.style, {
          transitionProperty: TRANSITION_FIELDS,
          transitionDuration: M,
          transitionDelay: I,
          transform: "translate3d(0, 0, 0) scaleX(1) scaleY(1)",
          opacity: Q,
          left: asSize(X.x) || 0,
          top: asSize(X.y) || 0,
          width: z ? "auto" : ee.x,
          right: z ? asSize(P) || 0 : "auto",
          height: S ? "auto" : ee.y,
          bottom: S ? asSize(E) || 0 : "auto",
          zIndex: ne
        });
        const U = () => {
          const Y = rootLayout.getBoundingClientRect(), B = H.getBoundingClientRect();
          H.data.rootOffset = {
            x: B.x / Te - Y.x / Te,
            y: B.y / Te - Y.y / Te
          };
        };
        U(), H.addEventListener("transitionend", () => {
          H.style.zIndex = String(ne), U();
        });
      }
    })).then(() => {
      this.isUpdating = !1;
    }), this.isFirst = !1, Array.from(this.querySelectorAll("ls-layout")).forEach((D) => {
      if (!O[D.dataset.id])
        return;
      const F = O[D.dataset.id].size;
      D.updatePositions({
        size: {
          x: sizeToNum(F.x, l.x),
          y: sizeToNum(F.y, l.y)
        }
      });
    });
  }
  initializeChild(c) {
    var v;
    if (!((v = c.dataset) != null && v.id))
      return log.warn("Layout: Child requires `data-id` at the time it is added to a Layout");
    c._remove = c.remove, c.remove = () => {
      this.removeChild(c);
    }, c.mutationObserver || (c.mutationObserver = new MutationObserver((p) => {
      p.forEach((_) => {
        if (_.type === "attributes") {
          if (_.attributeName === "style")
            return;
          queueOp(["childAttributesChanged", this.dataset.id, c.dataset.id]);
        }
      });
    }), c.mutationObserver.observe(c, {
      childList: !0,
      attributes: !0
    }));
    const l = {
      entryTransition: {
        delay: 0,
        opacity: 0,
        scale: {
          x: 1,
          y: 1
        },
        offset: {
          x: 0,
          y: 0
        }
      },
      exitTransition: {
        delay: 0,
        opacity: 0,
        scale: {
          x: 1,
          y: 1
        },
        offset: {
          x: 0,
          y: 0
        }
      },
      position: {
        x: 0,
        y: 0
      },
      size: {
        x: 0,
        y: 0
      },
      opacity: 0,
      fit: "cover",
      borderRadius: 0,
      zIndex: 1
    };
    c.data = l, c.parentEl = c.parentElement, c.nextSiblingEl = c.nextSibling, c.previousSiblingEl = c.previousSibling, c.previousSiblingEl && (c.previousSiblingEl.nextSiblingEl = c), c.toggleAttribute("data-layout-child", !0), childIndex[c.dataset.id] = c, c.runRemove = async () => {
      var _, k, O, D;
      c.removed = !0;
      const p = TRANSITION_DURATION;
      return await new Promise((F) => window.setTimeout(F)), Object.assign(c.style, {
        zIndex: 0,
        transitionDelay: asDuration(0),
        transitionDuration: asDuration(p),
        transitionProperty: TRANSITION_FIELDS,
        transitionTimingFunction: l.exitTransition.timingFn ?? "ease",
        transform: `translate3d(calc(${asSize(((_ = l.exitTransition.offset) == null ? void 0 : _.x) ?? 0)}), calc( ${asSize(((k = l.exitTransition.offset) == null ? void 0 : k.y) ?? 0)}), 0) scaleX(${((O = l.exitTransition.scale) == null ? void 0 : O.x) ?? 1}) scaleY(${((D = l.exitTransition.scale) == null ? void 0 : D.y) ?? 1})`,
        opacity: l.exitTransition.opacity ?? 0
      }), c.removed = !0, c.transition = new Promise((F) => {
        const H = () => {
          c.transition = null, c._remove(), queueOp(["childRemoveFinished", this.dataset.id, c.dataset.id]), clearTimeout(Z), F();
        }, Z = window.setTimeout(H, parseInt(String(p)) + 600);
        c.addEventListener("transitionend", H, {
          once: !0
        });
      }), c.transition;
    };
  }
}
const ensureLayoutContainer = (a) => {
  const u = document.getElementById("__ls-layout-container");
  if (u)
    return Object.assign(u.style, {
      width: a.x + "px",
      height: a.y + "px"
    }), u;
  const c = document.createElement("div");
  return c.id = "__ls-layout-container", Object.assign(c.style, {
    position: "fixed",
    // pointerEvents: 'none',
    visibility: "hidden",
    top: "0px",
    left: "0px",
    zIndex: -1,
    width: a.x + "px",
    height: a.y + "px"
  }), document.body.append(c), c;
}, layoutChildren = ({
  id: a,
  props: u = {},
  children: c,
  size: l
}) => {
  const v = {
    props: u,
    children: c,
    size: l
  }, p = htmlLayouts[u.layout] ? htmlLayouts[u.layout].layout(v) : htmlLayouts.Free.layout(v);
  if (!(p instanceof HTMLElement))
    return p;
  const _ = Array.from(p.querySelectorAll("[data-node-id]")), k = document.createElement("div");
  k.style.height = p.style.height = l.y + "px", k.style.width = p.style.width = l.x + "px", k.style.position = "absolute", k.style.top = "0px", k.style.left = "0px", k.style.boxSizing = "border-box", k.setAttribute("data-wrapper-id", a), k.append(p);
  const O = ensureLayoutContainer(l), D = O.querySelector(`[data-wrapper-id="${a}"]`);
  D ? D.replaceWith(k) : O.append(k);
  const F = p.getBoundingClientRect(), H = {};
  return _.forEach((Z) => {
    var ae, j, ue, he;
    const ee = Z.dataset.nodeId;
    if (!ee)
      return;
    const X = Number(Z.dataset.opacity ?? (Z.style.opacity || 1)), ne = Z.getBoundingClientRect();
    let Q = {
      position: {
        x: ne.x - F.x + "px",
        y: ne.y - F.y + "px"
      },
      size: {
        x: ne.width + "px",
        y: ne.height + "px"
      },
      opacity: X,
      zIndex: (ae = Z.data) == null ? void 0 : ae.zIndex,
      entryTransition: ((j = Z.data) == null ? void 0 : j.entryTransition) ?? {},
      exitTransition: ((ue = Z.data) == null ? void 0 : ue.exitTransition) ?? {},
      borderRadius: ((he = Z.data) == null ? void 0 : he.borderRadius) ?? 0
    };
    `${u.showcase}-x` === ee && (Q.position = {
      x: F.x + "px",
      y: F.y + "px"
    }, Q.size = {
      x: F.width + "px",
      y: F.height + "px"
    }, Q.zIndex = 10), H[ee] = Q, positionIndex[Z.dataset.nodeId] = Q;
  }), H;
}, positionIndex = {}, htmlLayouts = {}, registerLayout = (a) => {
  asArray(a).forEach((u) => {
    htmlLayouts[u.name] = u;
  });
}, sourceTypes = {}, init$1 = (a = {}, u) => {
  const c = {}, l = {}, v = (O) => {
    u.triggerEvent("SourceChanged", O);
  }, p = (O) => {
    u.triggerEvent("AvailableSourcesChanged", {
      type: O,
      sources: l[O]
    });
  }, k = {
    sourceIndex: c,
    sourceTypeIndex: l,
    registerSource: (O) => {
      asArray(O).forEach((D) => {
        var H;
        const F = (Z) => {
          const ee = c[Z];
          if (ee && ee.type !== D.type)
            throw new Error(`Attempted to modify source of type ${ee.type} from ${D.type}`);
        };
        (H = D.init) == null || H.call(D, {
          getSource: (Z) => k.getSource(Z),
          removeSource: (Z) => (F(Z), k.removeSource(Z)),
          setSourceActive: (Z, ee) => (F(Z), k.setSourceActive(Z, ee)),
          updateSource: (Z, ee) => (F(Z), k.updateSource(Z, ee)),
          modifySourceValue(Z, ee) {
            return F(Z), k.modifySourceValue(Z, ee);
          },
          addSource: (Z) => k.addSource(D.type, Z)
        }), sourceTypes[D.type] = D;
      });
    },
    getSource: (O) => c[O],
    getSources: (O) => l[O] || [],
    useSource: (O, D) => (D(c[O]), u.on("SourceChanged", (F) => {
      F.id === O && D(F);
    })),
    useSources: (O, D) => (D(l[O] || []), u.on("AvailableSourcesChanged", (F) => {
      F.type === O && D(F.sources);
    })),
    addSource: (O, D) => {
      if (!D.id)
        throw new Error('Cannot add source without field "id"');
      if (c[D.id])
        return;
      if (!D.value)
        throw new Error('Cannot add source with an empty field "value"');
      if (!sourceTypes[O])
        throw new Error("Could not find definition for source type: " + O);
      const {
        id: H,
        value: Z = null,
        props: ee = {},
        isActive: X = !0
      } = D;
      c[H] = {
        id: H,
        type: O,
        props: ee,
        value: Z,
        isActive: X
      }, l[O] = [...l[O] || [], c[H]], v(c[H]), p(O);
    },
    removeSource: (O) => {
      const D = c[O];
      D && (delete c[O], l[D.type] = l[D.type].filter((F) => F.id !== O), p(D.type));
    },
    updateSource: (O, D) => {
      const F = c[O];
      F.props = {
        ...F.props,
        ...D
      }, v(F), p(F.type);
    },
    /**
     * Imperatively update a Source's value.
     * Triggers an event to inform elements to re-render.
     */
    modifySourceValue: async (O, D) => {
      const F = c[O];
      await D(F.value), v(F);
    },
    setSourceActive: (O, D = !0) => {
      const F = c[O];
      F.isActive = D, p(F.type);
    }
  };
  return k;
}, sources = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  init: init$1,
  sourceTypes
}, Symbol.toStringTag, { value: "Module" })), layouts = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), {
  forEachDown,
  insertAt,
  toDataNode,
  pull,
  replaceItem
} = Logic;
let compositor;
const start = (a) => {
  if (compositor)
    return compositor;
  const {
    dbAdapter: u,
    transformSettings: c = {},
    sourceSettings: l = {}
  } = a, v = {}, p = {};
  try {
    customElements.define("ls-layout", Layout);
  } catch (ae) {
    log.warn(ae);
  }
  const _ = {}, k = {}, O = {};
  let D = 0;
  const F = /* @__PURE__ */ new Map(), H = (ae, j) => {
    if (typeof ae != "function")
      return;
    const ue = ++D;
    return F.set(ue, ae), ae.nodeId = j, () => {
      F.delete(ue);
    };
  }, Z = (ae, j, ue) => H((he, fe) => {
    he === ae && j(fe);
  }, ue), ee = (ae, j) => {
    F.forEach((ue) => {
      ue.nodeId ? j != null && j.nodeId && (j == null ? void 0 : j.nodeId) === ue.nodeId && ue(ae, j) : ue(ae, j);
    });
  }, X = {
    projects: p,
    subscribe: H,
    on: Z,
    triggerEvent: ee,
    getProject: (ae) => p[ae],
    getNodeProject: (ae) => p[_[ae]],
    getNodeParent: (ae) => O[k[ae]],
    getNode: (ae) => O[ae],
    createProject: async (ae = {}, j) => {
      const {
        id: ue,
        props: he = {},
        children: fe = []
      } = ae, be = await u(j, {
        get: () => null,
        getParent: () => null
      }).insert(he), ke = {
        id: be,
        props: he,
        children: fe
      };
      return forEachDown(ae, (Te) => {
      }), O[be] = ke, compositor.loadProject(ke, j);
    },
    loadProject: (ae, j) => {
      if (!ae)
        return;
      if (j = j || ae.id, p[j])
        return p[j];
      forEachDown(ae, (be, ke) => {
        O[be.id] = be, k[be.id] = ke == null ? void 0 : ke.id, _[be.id] = j;
      });
      const ue = {
        insert: async (be, ke, Te = 0) => {
          if (be.id && O[be.id])
            return O[be.id];
          if (be.children || (be.children = []), be.props || (be.props = {}), ke) {
            const q = O[ke];
            if (!q)
              throw "Parent node not found with ID";
            q.children = insertAt(Te, be, q.children || []), k[be.id] = ke;
          }
          return O[be.id] = be, _[be.id] = j, be.id;
        },
        update: async (be, ke = {}, Te) => {
          const q = O[be];
          if (Te) {
            const z = Te.map((P) => {
              const S = O[P];
              return k[S.id] = be, S;
            });
            q.children = z;
          }
          q.props = {
            ...q.props,
            ...ke
          };
        },
        remove: async (be) => {
          const ke = O[k[be]];
          ke && (ke.children = ke.children.filter((q) => q.id !== be));
          const Te = O[be];
          forEachDown(Te, (q) => {
            O[q.id] && (O[q.id]._deleted = !0), ee("NodeRemoved", {
              projectId: he.id,
              nodeId: q.id
            });
          });
        }
      }, he = {
        id: j,
        getRoot: () => ae,
        get(be) {
          return O[be];
        },
        getParent(be) {
          return O[k[be]];
        },
        renderTree() {
          return Q.renderTree(ae);
        },
        local: ue,
        insert: async (be = {}, ke, Te = 0) => {
          const z = {
            id: await fe.insert(be, ke, Te),
            props: be,
            children: []
          };
          return ue.insert(z, ke, Te);
        },
        update: async (be, ke) => (await ue.update(be, ke), fe.update(be, ke)),
        remove: async (be) => {
          await ue.remove(be);
          const ke = O[k[be]], Te = ke.children.filter((q) => q.id !== be);
          return fe.batch([["delete", {
            id: be
          }], ["update", {
            ...ke,
            children: Te
          }]]);
        },
        reorder: async (be, ke) => {
          const Te = O[be];
          return Te.children = ke.map((q) => Te.children.find((z) => z.id === q)), fe.batch([["update", Te]]);
        },
        move: async (be, ke, Te = 0) => {
          const q = O[be], z = O[k[be]], P = O[ke];
          z.children = pull(z.children, q), P.children = insertAt(Te, q, P.children), fe.batch([["update", P], ["update", z]]), k[be] = ke;
        },
        swap: async (be, ke) => {
          const Te = O[be], q = O[ke], z = O[k[be]], P = O[k[ke]];
          z.children = replaceItem((S) => S.id === be, q, z.children), P.children = replaceItem((S) => S.id === ke, Te, P.children), k[be] = P.id, k[ke] = z.id, fe.batch([["update", z], ["update", P]]);
        }
      };
      Object.defineProperty(he, "nodes", {
        get() {
          return Object.values(O).filter((be) => _[be.id] === he.id);
        }
      });
      const fe = v[j] || u(j, {
        get: (be) => toDataNode(he.get(be)),
        getParent: (be) => toDataNode(he.getParent(be))
      });
      return v[j] = fe, p[j] = he, he;
    }
  }, ne = init$1(l, X), Q = init$2(c, X, ne);
  return compositor = {
    registerLayout,
    registerTransform: Q.registerTransform,
    registerSource: ne.registerSource,
    getElement: Q.getElement,
    getSource: ne.getSource,
    getSources: ne.getSources,
    useSource: ne.useSource,
    useSources: ne.useSources,
    ...X
  }, compositor;
}, index = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Layout: layouts,
  Source: sources,
  Transform: transforms,
  start
}, Symbol.toStringTag, { value: "Module" })), createProject = async (a) => {
  const u = getUser().id, c = a.type || "sceneless", l = a.size || {
    x: 1280,
    y: 720
  }, v = a.settings || {};
  let p = await CoreContext.clients.LiveApi().project.createProject({
    collectionId: u,
    rendering: {
      video: {
        width: l.x,
        height: l.y,
        framerate: 30
      }
    },
    composition: {
      studioSdk: {
        version: CoreContext.rendererVersion
      }
    },
    metadata: {},
    webrtc: {
      hosted: {}
    }
  });
  const _ = await createLayout({
    projectId: p.project.projectId,
    collectionId: p.project.collectionId,
    settings: v,
    size: l,
    type: c
  }), {
    displayName: k
  } = getAccessTokenData(), O = {
    type: c,
    layoutId: _.id,
    hostDisplayName: k,
    props: a.props || {}
  };
  let D = await CoreContext.clients.LiveApi().project.updateProject({
    collectionId: u,
    projectId: p.project.projectId,
    updateMask: ["metadata"],
    metadata: O
  });
  return p.project = D.project, p.project.metadata = O, {
    project: p.project,
    layout: _
  };
}, deleteProject = async (a) => {
  const {
    projectId: u
  } = a, c = getProject(u), l = getUser().id;
  await Promise.all([CoreContext.clients.LiveApi().project.deleteProject({
    collectionId: l,
    projectId: u
  }), CoreContext.clients.LayoutApi().layout.deleteLayout({
    layoutId: c.layoutApi.layoutId
  })]);
}, loadUser = async (a) => {
  var _;
  const u = await loadCollections();
  let c;
  const {
    displayName: l,
    serviceUserId: v
  } = getAccessTokenData();
  u.length === 0 ? c = (await CoreContext.clients.LiveApi().collection.createCollection({
    metadata: {
      serviceUserId: v,
      displayName: l,
      props: {}
    }
  })).collection : c = u[0], await CoreContext.clients.LiveApi().subscribeToCollection(c.collectionId);
  const p = await Promise.all(c.projects.filter((k) => {
    var O;
    return !!((O = k.metadata) != null && O.layoutId);
  }).map((k) => hydrateProject(k, "ROLE_HOST", a)));
  return {
    user: {
      id: c.collectionId,
      metadata: c.metadata,
      props: ((_ = c.metadata) == null ? void 0 : _.props) || {},
      name: l
    },
    projects: p,
    sources: c.sources
  };
}, loadCollections = async () => (await CoreContext.clients.LiveApi().collection.getCollections({})).collections, createLayout = async (a) => {
  const {
    settings: u,
    size: c,
    type: l,
    projectId: v,
    collectionId: p
  } = a, _ = await CoreContext.clients.LayoutApi().layout.createLayout({
    layout: {
      projectId: v,
      collectionId: p
    }
  });
  return l === "sceneless" ? await createCompositor(_.id, c, u) : await CoreContext.compositor.createProject({
    props: {
      name: "Root",
      layout: "Free",
      ...u,
      isRoot: !0,
      size: c
    }
  }, _.id), _;
}, requests = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createLayout,
  createProject,
  deleteProject,
  loadCollections,
  loadUser
}, Symbol.toStringTag, { value: "Module" })), RTMP = {
  type: "RTMP",
  valueType: MediaStream,
  props: {
    id: {},
    type: {},
    videoEnabled: {},
    audioEnabled: {}
  },
  init({
    addSource: a,
    removeSource: u,
    updateSource: c,
    getSource: l
  }) {
    let v = {}, p = [], _ = [];
    const k = (O) => {
      const D = O.filter((H) => !_.some((Z) => Z.id === H.id)), F = _.filter((H) => !O.some((Z) => Z.id === H.id));
      _ = O, D.forEach(async (H) => {
        const Z = new MediaStream([]);
        v[H.id] = Z;
        const ee = Z.getVideoTracks();
        a({
          id: `rtmp-${H.id}`,
          isActive: !0,
          value: Z,
          props: {
            id: H.id,
            isMuted: !1,
            participantId: H.id,
            type: "rtmp",
            videoEnabled: !!ee.length,
            audioEnabled: !0
          }
        });
      }), F.forEach((H) => {
        u(`rtmp-${H.id}`);
      });
    };
    CoreContext.on("ActiveProjectChanged", ({
      projectId: O
    }) => {
      const F = toBaseProject(getProject(O)).sources.filter((H) => {
        var Z, ee;
        return !((ee = (Z = H.address) == null ? void 0 : Z.dynamic) != null && ee.id);
      });
      k(F);
    }), CoreContext.on("RoomJoined", ({
      projectId: O,
      room: D
    }) => {
      if (toBaseProject(getProject(O)).role !== Role.ROLE_RENDERER) {
        const H = () => {
          p.filter((Z) => (Z == null ? void 0 : Z.type) === "screen_share" && (Z == null ? void 0 : Z.isExternal) === !0).forEach((Z) => {
            if (Z.type === "screen_share") {
              const ee = v[Z.participantId], X = D.getParticipant(Z.participantId);
              if (_.some((ne) => ne.id === X.id)) {
                const ne = D.getTrack(Z.id);
                if (l(`rtmp-${X == null ? void 0 : X.id}`)) {
                  const ae = D.getTracks().find((j) => j.participantId === X.id && j.mediaStreamTrack.kind === "audio");
                  updateMediaStreamTracks(ee, {
                    video: ne == null ? void 0 : ne.mediaStreamTrack,
                    audio: ae == null ? void 0 : ae.mediaStreamTrack
                  }), c(`rtmp-${X == null ? void 0 : X.id}`, {
                    videoEnabled: !!(ne != null && ne.mediaStreamTrack && !ne.isMuted),
                    audioEnabled: !!(ae && !ae.isMuted)
                  });
                }
              }
            }
          });
        };
        D.useTracks((Z) => {
          const ee = Z.filter((Q) => _.some((ae) => ae.id === Q.participantId)).filter((Q) => ["screen_share"].includes(Q.type)), X = ee.filter((Q) => !p.some((ae) => ae.id === Q.id) && !!(Q != null && Q.mediaStreamTrack)), ne = p.filter((Q) => !ee.some((ae) => ae.id === Q.id));
          p = ee.filter((Q) => !!(Q != null && Q.mediaStreamTrack)), ne.forEach((Q) => {
            const ae = v[Q.participantId];
            Q.mediaStreamTrack.kind === "video" && (updateMediaStreamTracks(ae, {
              video: null
            }), c(`rtmp-${Q.participantId}`, {
              videoEnabled: !1
            })), Q.mediaStreamTrack.kind === "audio" && (updateMediaStreamTracks(ae, {
              audio: null
            }), c(`rtmp-${Q.participantId}`, {
              audioEnabled: !1
            }));
          }), X.forEach((Q) => {
            if (Q.type === "screen_share" && Q.mediaStreamTrack.kind === "video") {
              const ae = v[Q.participantId], j = p.find((ue) => {
                var he;
                return ue.participantId === Q.participantId && ((he = ue.mediaStreamTrack) == null ? void 0 : he.kind) === "audio";
              });
              updateMediaStreamTracks(ae, {
                video: Q == null ? void 0 : Q.mediaStreamTrack,
                audio: j == null ? void 0 : j.mediaStreamTrack
              }), c(`rtmp-${Q.participantId}`, {
                videoEnabled: !!(Q && !(Q != null && Q.isMuted)),
                audioEnabled: !!(j && !(j != null && j.isMuted))
              });
            }
          }), H();
        });
      }
    }), CoreContext.onInternal("SourceConnected", async (O) => {
      const D = v[O];
      if (D) {
        const F = await connectDevice(O);
        if (l(`rtmp-${O}`) && F) {
          const Z = F.getAudioTracks()[0], ee = F.getVideoTracks()[0];
          updateMediaStreamTracks(D, {
            video: ee,
            audio: Z
          }), c(`rtmp-${O}`, {
            videoEnabled: !!ee,
            audioEnabled: !!Z
          });
        }
      }
    }), CoreContext.onInternal("SourceDisconnected", async (O) => {
      const D = v[O];
      D && ((D == null ? void 0 : D.getTracks()).forEach((H) => {
        var Z;
        (Z = v[O]) == null || Z.removeTrack(H);
      }), c(`rtmp-${O}`, {
        videoEnabled: !1,
        audioEnabled: !1
      }));
    }), CoreContext.on("ProjectSourceAdded", ({
      source: O,
      projectId: D
    }) => {
      const H = toBaseProject(getProject(D)).sources.filter((Z) => {
        var ee, X;
        return !((X = (ee = Z.address) == null ? void 0 : ee.dynamic) != null && X.id);
      });
      k(H);
    }), CoreContext.on("ProjectSourceRemoved", ({
      sourceId: O,
      projectId: D
    }) => {
      const H = toBaseProject(getProject(D)).sources.filter((Z) => {
        var ee, X;
        return !((X = (ee = Z.address) == null ? void 0 : ee.dynamic) != null && X.id);
      });
      k(H);
    });
  }
}, Game = {
  type: "Game",
  valueType: MediaStream,
  props: {
    id: {},
    type: {},
    videoEnabled: {},
    audioEnabled: {}
  },
  init({
    addSource: a,
    removeSource: u,
    updateSource: c,
    getSource: l,
    modifySourceValue: v
  }) {
    let p = [], _ = [];
    const k = (O) => {
      const D = O.filter((H) => !_.some((Z) => Z.id === H.id)), F = _.filter((H) => !O.some((Z) => Z.id === H.id));
      _ = O, D.forEach(async (H) => {
        var X, ne, Q, ae, j, ue, he, fe;
        const Z = new MediaStream([]), ee = Z.getVideoTracks();
        a({
          id: `game-${(ne = (X = H.preview) == null ? void 0 : X.webrtc) == null ? void 0 : ne.participantId}`,
          isActive: !0,
          value: Z,
          props: {
            displayName: ((ae = (Q = H.preview) == null ? void 0 : Q.webrtc) == null ? void 0 : ae.displayName) || H.id,
            id: (ue = (j = H.preview) == null ? void 0 : j.webrtc) == null ? void 0 : ue.participantId,
            isMuted: !1,
            participantId: (fe = (he = H.preview) == null ? void 0 : he.webrtc) == null ? void 0 : fe.participantId,
            type: "game",
            videoEnabled: !!ee.length,
            audioEnabled: !0
          }
        });
      }), F.forEach((H) => {
        var Z, ee;
        u(`game-${(ee = (Z = H.preview) == null ? void 0 : Z.webrtc) == null ? void 0 : ee.participantId}`);
      });
    };
    CoreContext.on("RoomJoined", ({
      projectId: O,
      room: D
    }) => {
      if (toBaseProject(getProject(O)).role !== Role.ROLE_RENDERER) {
        const H = () => {
          p.filter((Z) => (Z == null ? void 0 : Z.type) === "camera" && (Z == null ? void 0 : Z.isExternal) === !0).forEach((Z) => {
            var ee;
            if (Z.type === "camera") {
              const X = D.getParticipant(Z.participantId);
              if (_.some((Q) => {
                var ae, j;
                return ((j = (ae = Q.preview) == null ? void 0 : ae.webrtc) == null ? void 0 : j.participantId) === X.id;
              })) {
                const Q = D.getTrack(Z.id);
                if (l(`game-${X == null ? void 0 : X.id}`)) {
                  const j = D.getTracks().find((ue) => ue.participantId === X.id && ue.mediaStreamTrack.kind === "audio");
                  v(`game-${X == null ? void 0 : X.id}`, (ue) => {
                    updateMediaStreamTracks(ue, {
                      video: Q == null ? void 0 : Q.mediaStreamTrack,
                      audio: j == null ? void 0 : j.mediaStreamTrack
                    });
                  }), c(`game-${X == null ? void 0 : X.id}`, {
                    videoEnabled: !!(Q != null && Q.mediaStreamTrack && !Q.isMuted),
                    audioEnabled: !!(j && !j.isMuted),
                    displayName: ((ee = X.meta) == null ? void 0 : ee.screenDisplayName) || (X == null ? void 0 : X.displayName) || "Game Source"
                  });
                }
              }
            }
          });
        };
        D.useTracks((Z) => {
          const ee = Z.filter((Q) => _.some((ae) => {
            var j, ue;
            return ((ue = (j = ae.preview) == null ? void 0 : j.webrtc) == null ? void 0 : ue.participantId) === Q.participantId;
          })).filter((Q) => ["camera"].includes(Q.type)), X = ee.filter((Q) => !p.some((ae) => ae.id === Q.id) && !!(Q != null && Q.mediaStreamTrack)), ne = p.filter((Q) => !ee.some((ae) => ae.id === Q.id));
          p = ee.filter((Q) => !!(Q != null && Q.mediaStreamTrack)), ne.forEach((Q) => {
            const {
              participantId: ae
            } = Q;
            Q.mediaStreamTrack.kind === "video" && (v(`game-${ae}`, (j) => {
              updateMediaStreamTracks(j, {
                video: null
              });
            }), c(`game-${ae}`, {
              videoEnabled: !1
            })), Q.mediaStreamTrack.kind === "audio" && (v(`game-${ae}`, (j) => {
              updateMediaStreamTracks(j, {
                audio: null
              });
            }), c(`game-${ae}`, {
              audioEnabled: !1
            }));
          }), X.forEach((Q) => {
            if (Q.type === "camera" && Q.mediaStreamTrack.kind === "video") {
              const ae = p.find((j) => {
                var ue;
                return j.participantId === Q.participantId && ((ue = j.mediaStreamTrack) == null ? void 0 : ue.kind) === "audio";
              });
              v(`game-${Q.participantId}`, (j) => {
                updateMediaStreamTracks(j, {
                  video: Q == null ? void 0 : Q.mediaStreamTrack,
                  audio: ae == null ? void 0 : ae.mediaStreamTrack
                });
              }), c(`game-${Q.participantId}`, {
                videoEnabled: !!(Q && !(Q != null && Q.isMuted)),
                audioEnabled: !!(ae && !(ae != null && ae.isMuted))
              });
            }
          }), H();
        });
      }
      D.useParticipants((H) => {
        H.filter((ee) => ee.id.startsWith("source")).forEach((ee) => {
          var ne;
          l(`game-${ee.id}`) && c(`game-${ee.id}`, {
            displayName: ((ne = ee.meta) == null ? void 0 : ne.screenDisplayName) || (ee == null ? void 0 : ee.displayName) || "Game Source"
          });
        });
      });
    }), CoreContext.on("ActiveProjectChanged", ({
      projectId: O
    }) => {
      const F = toBaseProject(getProject(O)).sources.filter((H) => {
        var Z, ee;
        return (ee = (Z = H.address) == null ? void 0 : Z.dynamic) == null ? void 0 : ee.id;
      });
      k(F);
    }), CoreContext.onInternal("SourceConnected", async (O) => {
      const D = await connectDevice(O);
      if (l(`game-source-${O}`) && D) {
        const H = D.getAudioTracks()[0], Z = D.getVideoTracks()[0];
        v(`game-source-${O}`, (ee) => {
          updateMediaStreamTracks(ee, {
            video: Z,
            audio: H
          });
        }), c(`game-source-${O}`, {
          videoEnabled: !!Z,
          audioEnabled: !!H
        });
      }
    }), CoreContext.onInternal("SourceDisconnected", (O) => {
      var F;
      const D = (F = l(`game-source-${O}`)) == null ? void 0 : F.value;
      D && ((D == null ? void 0 : D.getTracks()).forEach((Z) => {
        D == null || D.removeTrack(Z);
      }), c(`game-source-${O}`, {
        videoEnabled: !1,
        audioEnabled: !1
      }));
    }), CoreContext.on("ProjectSourceAdded", ({
      source: O,
      projectId: D
    }) => {
      const F = toBaseProject(getProject(D));
      k(F.sources.filter((H) => {
        var Z, ee;
        return (ee = (Z = H.address) == null ? void 0 : Z.dynamic) == null ? void 0 : ee.id;
      }));
    }), CoreContext.on("ProjectSourceRemoved", ({
      sourceId: O,
      projectId: D
    }) => {
      const F = toBaseProject(getProject(D));
      k(F.sources.filter((H) => {
        var Z, ee;
        return (ee = (Z = H.address) == null ? void 0 : Z.dynamic) == null ? void 0 : ee.id;
      }));
    });
  }
}, Sources = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Banner: Banner$1,
  Game,
  RTMP,
  RoomParticipant: RoomParticipant$1
}, Symbol.toStringTag, { value: "Module" }));
var createRoot, m = ReactDOM;
if (process$1.env.NODE_ENV === "production")
  createRoot = m.createRoot, m.hydrateRoot;
else {
  var i = m.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  createRoot = function(a, u) {
    i.usingClientEntryPoint = !0;
    try {
      return m.createRoot(a, u);
    } finally {
      i.usingClientEntryPoint = !1;
    }
  };
}
var APIKitAnimationTypes = /* @__PURE__ */ ((a) => (a.FADE_IN = "fade-in", a.FADE_OUT = "fade-out", a.SLIDE_IN_BLURRED_TOP = "slide-in-blurred-top", a.SLIDE_IN_LEFT = "slide-in-left", a.SLIDE_OUT_LEFT = "slide-out-left", a))(APIKitAnimationTypes || {});
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(a) {
    for (var u = 1; u < arguments.length; u++) {
      var c = arguments[u];
      for (var l in c)
        Object.prototype.hasOwnProperty.call(c, l) && (a[l] = c[l]);
    }
    return a;
  }, _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(a, u) {
  if (a == null)
    return {};
  var c = {}, l = Object.keys(a), v, p;
  for (p = 0; p < l.length; p++)
    v = l[p], !(u.indexOf(v) >= 0) && (c[v] = a[v]);
  return c;
}
function _setPrototypeOf(a, u) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(l, v) {
    return l.__proto__ = v, l;
  }, _setPrototypeOf(a, u);
}
function _inheritsLoose(a, u) {
  a.prototype = Object.create(u.prototype), a.prototype.constructor = a, _setPrototypeOf(a, u);
}
var propTypes = { exports: {} }, reactIs = { exports: {} }, reactIs_production_min = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactIs_production_min;
function requireReactIs_production_min() {
  if (hasRequiredReactIs_production_min)
    return reactIs_production_min;
  hasRequiredReactIs_production_min = 1;
  var a = typeof Symbol == "function" && Symbol.for, u = a ? Symbol.for("react.element") : 60103, c = a ? Symbol.for("react.portal") : 60106, l = a ? Symbol.for("react.fragment") : 60107, v = a ? Symbol.for("react.strict_mode") : 60108, p = a ? Symbol.for("react.profiler") : 60114, _ = a ? Symbol.for("react.provider") : 60109, k = a ? Symbol.for("react.context") : 60110, O = a ? Symbol.for("react.async_mode") : 60111, D = a ? Symbol.for("react.concurrent_mode") : 60111, F = a ? Symbol.for("react.forward_ref") : 60112, H = a ? Symbol.for("react.suspense") : 60113, Z = a ? Symbol.for("react.suspense_list") : 60120, ee = a ? Symbol.for("react.memo") : 60115, X = a ? Symbol.for("react.lazy") : 60116, ne = a ? Symbol.for("react.block") : 60121, Q = a ? Symbol.for("react.fundamental") : 60117, ae = a ? Symbol.for("react.responder") : 60118, j = a ? Symbol.for("react.scope") : 60119;
  function ue(fe) {
    if (typeof fe == "object" && fe !== null) {
      var be = fe.$$typeof;
      switch (be) {
        case u:
          switch (fe = fe.type, fe) {
            case O:
            case D:
            case l:
            case p:
            case v:
            case H:
              return fe;
            default:
              switch (fe = fe && fe.$$typeof, fe) {
                case k:
                case F:
                case X:
                case ee:
                case _:
                  return fe;
                default:
                  return be;
              }
          }
        case c:
          return be;
      }
    }
  }
  function he(fe) {
    return ue(fe) === D;
  }
  return reactIs_production_min.AsyncMode = O, reactIs_production_min.ConcurrentMode = D, reactIs_production_min.ContextConsumer = k, reactIs_production_min.ContextProvider = _, reactIs_production_min.Element = u, reactIs_production_min.ForwardRef = F, reactIs_production_min.Fragment = l, reactIs_production_min.Lazy = X, reactIs_production_min.Memo = ee, reactIs_production_min.Portal = c, reactIs_production_min.Profiler = p, reactIs_production_min.StrictMode = v, reactIs_production_min.Suspense = H, reactIs_production_min.isAsyncMode = function(fe) {
    return he(fe) || ue(fe) === O;
  }, reactIs_production_min.isConcurrentMode = he, reactIs_production_min.isContextConsumer = function(fe) {
    return ue(fe) === k;
  }, reactIs_production_min.isContextProvider = function(fe) {
    return ue(fe) === _;
  }, reactIs_production_min.isElement = function(fe) {
    return typeof fe == "object" && fe !== null && fe.$$typeof === u;
  }, reactIs_production_min.isForwardRef = function(fe) {
    return ue(fe) === F;
  }, reactIs_production_min.isFragment = function(fe) {
    return ue(fe) === l;
  }, reactIs_production_min.isLazy = function(fe) {
    return ue(fe) === X;
  }, reactIs_production_min.isMemo = function(fe) {
    return ue(fe) === ee;
  }, reactIs_production_min.isPortal = function(fe) {
    return ue(fe) === c;
  }, reactIs_production_min.isProfiler = function(fe) {
    return ue(fe) === p;
  }, reactIs_production_min.isStrictMode = function(fe) {
    return ue(fe) === v;
  }, reactIs_production_min.isSuspense = function(fe) {
    return ue(fe) === H;
  }, reactIs_production_min.isValidElementType = function(fe) {
    return typeof fe == "string" || typeof fe == "function" || fe === l || fe === D || fe === p || fe === v || fe === H || fe === Z || typeof fe == "object" && fe !== null && (fe.$$typeof === X || fe.$$typeof === ee || fe.$$typeof === _ || fe.$$typeof === k || fe.$$typeof === F || fe.$$typeof === Q || fe.$$typeof === ae || fe.$$typeof === j || fe.$$typeof === ne);
  }, reactIs_production_min.typeOf = ue, reactIs_production_min;
}
var reactIs_development = {}, hasRequiredReactIs_development;
function requireReactIs_development() {
  return hasRequiredReactIs_development || (hasRequiredReactIs_development = 1, process$1.env.NODE_ENV !== "production" && function() {
    var a = typeof Symbol == "function" && Symbol.for, u = a ? Symbol.for("react.element") : 60103, c = a ? Symbol.for("react.portal") : 60106, l = a ? Symbol.for("react.fragment") : 60107, v = a ? Symbol.for("react.strict_mode") : 60108, p = a ? Symbol.for("react.profiler") : 60114, _ = a ? Symbol.for("react.provider") : 60109, k = a ? Symbol.for("react.context") : 60110, O = a ? Symbol.for("react.async_mode") : 60111, D = a ? Symbol.for("react.concurrent_mode") : 60111, F = a ? Symbol.for("react.forward_ref") : 60112, H = a ? Symbol.for("react.suspense") : 60113, Z = a ? Symbol.for("react.suspense_list") : 60120, ee = a ? Symbol.for("react.memo") : 60115, X = a ? Symbol.for("react.lazy") : 60116, ne = a ? Symbol.for("react.block") : 60121, Q = a ? Symbol.for("react.fundamental") : 60117, ae = a ? Symbol.for("react.responder") : 60118, j = a ? Symbol.for("react.scope") : 60119;
    function ue(A) {
      return typeof A == "string" || typeof A == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      A === l || A === D || A === p || A === v || A === H || A === Z || typeof A == "object" && A !== null && (A.$$typeof === X || A.$$typeof === ee || A.$$typeof === _ || A.$$typeof === k || A.$$typeof === F || A.$$typeof === Q || A.$$typeof === ae || A.$$typeof === j || A.$$typeof === ne);
    }
    function he(A) {
      if (typeof A == "object" && A !== null) {
        var re = A.$$typeof;
        switch (re) {
          case u:
            var le = A.type;
            switch (le) {
              case O:
              case D:
              case l:
              case p:
              case v:
              case H:
                return le;
              default:
                var $e = le && le.$$typeof;
                switch ($e) {
                  case k:
                  case F:
                  case X:
                  case ee:
                  case _:
                    return $e;
                  default:
                    return re;
                }
            }
          case c:
            return re;
        }
      }
    }
    var fe = O, be = D, ke = k, Te = _, q = u, z = F, P = l, S = X, E = ee, I = c, M = p, $ = v, U = H, Y = !1;
    function B(A) {
      return Y || (Y = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), T(A) || he(A) === O;
    }
    function T(A) {
      return he(A) === D;
    }
    function L(A) {
      return he(A) === k;
    }
    function te(A) {
      return he(A) === _;
    }
    function me(A) {
      return typeof A == "object" && A !== null && A.$$typeof === u;
    }
    function Ce(A) {
      return he(A) === F;
    }
    function De(A) {
      return he(A) === l;
    }
    function ye(A) {
      return he(A) === X;
    }
    function pe(A) {
      return he(A) === ee;
    }
    function Me(A) {
      return he(A) === c;
    }
    function Ne(A) {
      return he(A) === p;
    }
    function Ue(A) {
      return he(A) === v;
    }
    function oe(A) {
      return he(A) === H;
    }
    reactIs_development.AsyncMode = fe, reactIs_development.ConcurrentMode = be, reactIs_development.ContextConsumer = ke, reactIs_development.ContextProvider = Te, reactIs_development.Element = q, reactIs_development.ForwardRef = z, reactIs_development.Fragment = P, reactIs_development.Lazy = S, reactIs_development.Memo = E, reactIs_development.Portal = I, reactIs_development.Profiler = M, reactIs_development.StrictMode = $, reactIs_development.Suspense = U, reactIs_development.isAsyncMode = B, reactIs_development.isConcurrentMode = T, reactIs_development.isContextConsumer = L, reactIs_development.isContextProvider = te, reactIs_development.isElement = me, reactIs_development.isForwardRef = Ce, reactIs_development.isFragment = De, reactIs_development.isLazy = ye, reactIs_development.isMemo = pe, reactIs_development.isPortal = Me, reactIs_development.isProfiler = Ne, reactIs_development.isStrictMode = Ue, reactIs_development.isSuspense = oe, reactIs_development.isValidElementType = ue, reactIs_development.typeOf = he;
  }()), reactIs_development;
}
var hasRequiredReactIs;
function requireReactIs() {
  return hasRequiredReactIs || (hasRequiredReactIs = 1, process$1.env.NODE_ENV === "production" ? reactIs.exports = requireReactIs_production_min() : reactIs.exports = requireReactIs_development()), reactIs.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var objectAssign, hasRequiredObjectAssign;
function requireObjectAssign() {
  if (hasRequiredObjectAssign)
    return objectAssign;
  hasRequiredObjectAssign = 1;
  var a = Object.getOwnPropertySymbols, u = Object.prototype.hasOwnProperty, c = Object.prototype.propertyIsEnumerable;
  function l(p) {
    if (p == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(p);
  }
  function v() {
    try {
      if (!Object.assign)
        return !1;
      var p = new String("abc");
      if (p[5] = "de", Object.getOwnPropertyNames(p)[0] === "5")
        return !1;
      for (var _ = {}, k = 0; k < 10; k++)
        _["_" + String.fromCharCode(k)] = k;
      var O = Object.getOwnPropertyNames(_).map(function(F) {
        return _[F];
      });
      if (O.join("") !== "0123456789")
        return !1;
      var D = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(F) {
        D[F] = F;
      }), Object.keys(Object.assign({}, D)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return objectAssign = v() ? Object.assign : function(p, _) {
    for (var k, O = l(p), D, F = 1; F < arguments.length; F++) {
      k = Object(arguments[F]);
      for (var H in k)
        u.call(k, H) && (O[H] = k[H]);
      if (a) {
        D = a(k);
        for (var Z = 0; Z < D.length; Z++)
          c.call(k, D[Z]) && (O[D[Z]] = k[D[Z]]);
      }
    }
    return O;
  }, objectAssign;
}
var ReactPropTypesSecret_1, hasRequiredReactPropTypesSecret;
function requireReactPropTypesSecret() {
  if (hasRequiredReactPropTypesSecret)
    return ReactPropTypesSecret_1;
  hasRequiredReactPropTypesSecret = 1;
  var a = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return ReactPropTypesSecret_1 = a, ReactPropTypesSecret_1;
}
var has, hasRequiredHas;
function requireHas() {
  return hasRequiredHas || (hasRequiredHas = 1, has = Function.call.bind(Object.prototype.hasOwnProperty)), has;
}
var checkPropTypes_1, hasRequiredCheckPropTypes;
function requireCheckPropTypes() {
  if (hasRequiredCheckPropTypes)
    return checkPropTypes_1;
  hasRequiredCheckPropTypes = 1;
  var a = function() {
  };
  if (process$1.env.NODE_ENV !== "production") {
    var u = requireReactPropTypesSecret(), c = {}, l = requireHas();
    a = function(p) {
      var _ = "Warning: " + p;
      typeof console < "u" && console.error(_);
      try {
        throw new Error(_);
      } catch {
      }
    };
  }
  function v(p, _, k, O, D) {
    if (process$1.env.NODE_ENV !== "production") {
      for (var F in p)
        if (l(p, F)) {
          var H;
          try {
            if (typeof p[F] != "function") {
              var Z = Error(
                (O || "React class") + ": " + k + " type `" + F + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof p[F] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw Z.name = "Invariant Violation", Z;
            }
            H = p[F](_, F, O, k, null, u);
          } catch (X) {
            H = X;
          }
          if (H && !(H instanceof Error) && a(
            (O || "React class") + ": type specification of " + k + " `" + F + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof H + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), H instanceof Error && !(H.message in c)) {
            c[H.message] = !0;
            var ee = D ? D() : "";
            a(
              "Failed " + k + " type: " + H.message + (ee ?? "")
            );
          }
        }
    }
  }
  return v.resetWarningCache = function() {
    process$1.env.NODE_ENV !== "production" && (c = {});
  }, checkPropTypes_1 = v, checkPropTypes_1;
}
var factoryWithTypeCheckers, hasRequiredFactoryWithTypeCheckers;
function requireFactoryWithTypeCheckers() {
  if (hasRequiredFactoryWithTypeCheckers)
    return factoryWithTypeCheckers;
  hasRequiredFactoryWithTypeCheckers = 1;
  var a = requireReactIs(), u = requireObjectAssign(), c = requireReactPropTypesSecret(), l = requireHas(), v = requireCheckPropTypes(), p = function() {
  };
  process$1.env.NODE_ENV !== "production" && (p = function(k) {
    var O = "Warning: " + k;
    typeof console < "u" && console.error(O);
    try {
      throw new Error(O);
    } catch {
    }
  });
  function _() {
    return null;
  }
  return factoryWithTypeCheckers = function(k, O) {
    var D = typeof Symbol == "function" && Symbol.iterator, F = "@@iterator";
    function H(T) {
      var L = T && (D && T[D] || T[F]);
      if (typeof L == "function")
        return L;
    }
    var Z = "<<anonymous>>", ee = {
      array: ae("array"),
      bigint: ae("bigint"),
      bool: ae("boolean"),
      func: ae("function"),
      number: ae("number"),
      object: ae("object"),
      string: ae("string"),
      symbol: ae("symbol"),
      any: j(),
      arrayOf: ue,
      element: he(),
      elementType: fe(),
      instanceOf: be,
      node: z(),
      objectOf: Te,
      oneOf: ke,
      oneOfType: q,
      shape: S,
      exact: E
    };
    function X(T, L) {
      return T === L ? T !== 0 || 1 / T === 1 / L : T !== T && L !== L;
    }
    function ne(T, L) {
      this.message = T, this.data = L && typeof L == "object" ? L : {}, this.stack = "";
    }
    ne.prototype = Error.prototype;
    function Q(T) {
      if (process$1.env.NODE_ENV !== "production")
        var L = {}, te = 0;
      function me(De, ye, pe, Me, Ne, Ue, oe) {
        if (Me = Me || Z, Ue = Ue || pe, oe !== c) {
          if (O) {
            var A = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw A.name = "Invariant Violation", A;
          } else if (process$1.env.NODE_ENV !== "production" && typeof console < "u") {
            var re = Me + ":" + pe;
            !L[re] && // Avoid spamming the console because they are often not actionable except for lib authors
            te < 3 && (p(
              "You are manually calling a React.PropTypes validation function for the `" + Ue + "` prop on `" + Me + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), L[re] = !0, te++);
          }
        }
        return ye[pe] == null ? De ? ye[pe] === null ? new ne("The " + Ne + " `" + Ue + "` is marked as required " + ("in `" + Me + "`, but its value is `null`.")) : new ne("The " + Ne + " `" + Ue + "` is marked as required in " + ("`" + Me + "`, but its value is `undefined`.")) : null : T(ye, pe, Me, Ne, Ue);
      }
      var Ce = me.bind(null, !1);
      return Ce.isRequired = me.bind(null, !0), Ce;
    }
    function ae(T) {
      function L(te, me, Ce, De, ye, pe) {
        var Me = te[me], Ne = $(Me);
        if (Ne !== T) {
          var Ue = U(Me);
          return new ne(
            "Invalid " + De + " `" + ye + "` of type " + ("`" + Ue + "` supplied to `" + Ce + "`, expected ") + ("`" + T + "`."),
            { expectedType: T }
          );
        }
        return null;
      }
      return Q(L);
    }
    function j() {
      return Q(_);
    }
    function ue(T) {
      function L(te, me, Ce, De, ye) {
        if (typeof T != "function")
          return new ne("Property `" + ye + "` of component `" + Ce + "` has invalid PropType notation inside arrayOf.");
        var pe = te[me];
        if (!Array.isArray(pe)) {
          var Me = $(pe);
          return new ne("Invalid " + De + " `" + ye + "` of type " + ("`" + Me + "` supplied to `" + Ce + "`, expected an array."));
        }
        for (var Ne = 0; Ne < pe.length; Ne++) {
          var Ue = T(pe, Ne, Ce, De, ye + "[" + Ne + "]", c);
          if (Ue instanceof Error)
            return Ue;
        }
        return null;
      }
      return Q(L);
    }
    function he() {
      function T(L, te, me, Ce, De) {
        var ye = L[te];
        if (!k(ye)) {
          var pe = $(ye);
          return new ne("Invalid " + Ce + " `" + De + "` of type " + ("`" + pe + "` supplied to `" + me + "`, expected a single ReactElement."));
        }
        return null;
      }
      return Q(T);
    }
    function fe() {
      function T(L, te, me, Ce, De) {
        var ye = L[te];
        if (!a.isValidElementType(ye)) {
          var pe = $(ye);
          return new ne("Invalid " + Ce + " `" + De + "` of type " + ("`" + pe + "` supplied to `" + me + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return Q(T);
    }
    function be(T) {
      function L(te, me, Ce, De, ye) {
        if (!(te[me] instanceof T)) {
          var pe = T.name || Z, Me = B(te[me]);
          return new ne("Invalid " + De + " `" + ye + "` of type " + ("`" + Me + "` supplied to `" + Ce + "`, expected ") + ("instance of `" + pe + "`."));
        }
        return null;
      }
      return Q(L);
    }
    function ke(T) {
      if (!Array.isArray(T))
        return process$1.env.NODE_ENV !== "production" && (arguments.length > 1 ? p(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : p("Invalid argument supplied to oneOf, expected an array.")), _;
      function L(te, me, Ce, De, ye) {
        for (var pe = te[me], Me = 0; Me < T.length; Me++)
          if (X(pe, T[Me]))
            return null;
        var Ne = JSON.stringify(T, function(oe, A) {
          var re = U(A);
          return re === "symbol" ? String(A) : A;
        });
        return new ne("Invalid " + De + " `" + ye + "` of value `" + String(pe) + "` " + ("supplied to `" + Ce + "`, expected one of " + Ne + "."));
      }
      return Q(L);
    }
    function Te(T) {
      function L(te, me, Ce, De, ye) {
        if (typeof T != "function")
          return new ne("Property `" + ye + "` of component `" + Ce + "` has invalid PropType notation inside objectOf.");
        var pe = te[me], Me = $(pe);
        if (Me !== "object")
          return new ne("Invalid " + De + " `" + ye + "` of type " + ("`" + Me + "` supplied to `" + Ce + "`, expected an object."));
        for (var Ne in pe)
          if (l(pe, Ne)) {
            var Ue = T(pe, Ne, Ce, De, ye + "." + Ne, c);
            if (Ue instanceof Error)
              return Ue;
          }
        return null;
      }
      return Q(L);
    }
    function q(T) {
      if (!Array.isArray(T))
        return process$1.env.NODE_ENV !== "production" && p("Invalid argument supplied to oneOfType, expected an instance of array."), _;
      for (var L = 0; L < T.length; L++) {
        var te = T[L];
        if (typeof te != "function")
          return p(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + Y(te) + " at index " + L + "."
          ), _;
      }
      function me(Ce, De, ye, pe, Me) {
        for (var Ne = [], Ue = 0; Ue < T.length; Ue++) {
          var oe = T[Ue], A = oe(Ce, De, ye, pe, Me, c);
          if (A == null)
            return null;
          A.data && l(A.data, "expectedType") && Ne.push(A.data.expectedType);
        }
        var re = Ne.length > 0 ? ", expected one of type [" + Ne.join(", ") + "]" : "";
        return new ne("Invalid " + pe + " `" + Me + "` supplied to " + ("`" + ye + "`" + re + "."));
      }
      return Q(me);
    }
    function z() {
      function T(L, te, me, Ce, De) {
        return I(L[te]) ? null : new ne("Invalid " + Ce + " `" + De + "` supplied to " + ("`" + me + "`, expected a ReactNode."));
      }
      return Q(T);
    }
    function P(T, L, te, me, Ce) {
      return new ne(
        (T || "React class") + ": " + L + " type `" + te + "." + me + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + Ce + "`."
      );
    }
    function S(T) {
      function L(te, me, Ce, De, ye) {
        var pe = te[me], Me = $(pe);
        if (Me !== "object")
          return new ne("Invalid " + De + " `" + ye + "` of type `" + Me + "` " + ("supplied to `" + Ce + "`, expected `object`."));
        for (var Ne in T) {
          var Ue = T[Ne];
          if (typeof Ue != "function")
            return P(Ce, De, ye, Ne, U(Ue));
          var oe = Ue(pe, Ne, Ce, De, ye + "." + Ne, c);
          if (oe)
            return oe;
        }
        return null;
      }
      return Q(L);
    }
    function E(T) {
      function L(te, me, Ce, De, ye) {
        var pe = te[me], Me = $(pe);
        if (Me !== "object")
          return new ne("Invalid " + De + " `" + ye + "` of type `" + Me + "` " + ("supplied to `" + Ce + "`, expected `object`."));
        var Ne = u({}, te[me], T);
        for (var Ue in Ne) {
          var oe = T[Ue];
          if (l(T, Ue) && typeof oe != "function")
            return P(Ce, De, ye, Ue, U(oe));
          if (!oe)
            return new ne(
              "Invalid " + De + " `" + ye + "` key `" + Ue + "` supplied to `" + Ce + "`.\nBad object: " + JSON.stringify(te[me], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(T), null, "  ")
            );
          var A = oe(pe, Ue, Ce, De, ye + "." + Ue, c);
          if (A)
            return A;
        }
        return null;
      }
      return Q(L);
    }
    function I(T) {
      switch (typeof T) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !T;
        case "object":
          if (Array.isArray(T))
            return T.every(I);
          if (T === null || k(T))
            return !0;
          var L = H(T);
          if (L) {
            var te = L.call(T), me;
            if (L !== T.entries) {
              for (; !(me = te.next()).done; )
                if (!I(me.value))
                  return !1;
            } else
              for (; !(me = te.next()).done; ) {
                var Ce = me.value;
                if (Ce && !I(Ce[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function M(T, L) {
      return T === "symbol" ? !0 : L ? L["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && L instanceof Symbol : !1;
    }
    function $(T) {
      var L = typeof T;
      return Array.isArray(T) ? "array" : T instanceof RegExp ? "object" : M(L, T) ? "symbol" : L;
    }
    function U(T) {
      if (typeof T > "u" || T === null)
        return "" + T;
      var L = $(T);
      if (L === "object") {
        if (T instanceof Date)
          return "date";
        if (T instanceof RegExp)
          return "regexp";
      }
      return L;
    }
    function Y(T) {
      var L = U(T);
      switch (L) {
        case "array":
        case "object":
          return "an " + L;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + L;
        default:
          return L;
      }
    }
    function B(T) {
      return !T.constructor || !T.constructor.name ? Z : T.constructor.name;
    }
    return ee.checkPropTypes = v, ee.resetWarningCache = v.resetWarningCache, ee.PropTypes = ee, ee;
  }, factoryWithTypeCheckers;
}
var factoryWithThrowingShims, hasRequiredFactoryWithThrowingShims;
function requireFactoryWithThrowingShims() {
  if (hasRequiredFactoryWithThrowingShims)
    return factoryWithThrowingShims;
  hasRequiredFactoryWithThrowingShims = 1;
  var a = requireReactPropTypesSecret();
  function u() {
  }
  function c() {
  }
  return c.resetWarningCache = u, factoryWithThrowingShims = function() {
    function l(_, k, O, D, F, H) {
      if (H !== a) {
        var Z = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw Z.name = "Invariant Violation", Z;
      }
    }
    l.isRequired = l;
    function v() {
      return l;
    }
    var p = {
      array: l,
      bigint: l,
      bool: l,
      func: l,
      number: l,
      object: l,
      string: l,
      symbol: l,
      any: l,
      arrayOf: v,
      element: l,
      elementType: l,
      instanceOf: v,
      node: l,
      objectOf: v,
      oneOf: v,
      oneOfType: v,
      shape: v,
      exact: v,
      checkPropTypes: c,
      resetWarningCache: u
    };
    return p.PropTypes = p, p;
  }, factoryWithThrowingShims;
}
if (process$1.env.NODE_ENV !== "production") {
  var ReactIs = requireReactIs(), throwOnDirectAccess = !0;
  propTypes.exports = requireFactoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
} else
  propTypes.exports = requireFactoryWithThrowingShims()();
var propTypesExports = propTypes.exports;
const PropTypes = /* @__PURE__ */ getDefaultExportFromCjs$2(propTypesExports);
function hasClass(a, u) {
  return a.classList ? !!u && a.classList.contains(u) : (" " + (a.className.baseVal || a.className) + " ").indexOf(" " + u + " ") !== -1;
}
function addClass(a, u) {
  a.classList ? a.classList.add(u) : hasClass(a, u) || (typeof a.className == "string" ? a.className = a.className + " " + u : a.setAttribute("class", (a.className && a.className.baseVal || "") + " " + u));
}
function replaceClassName(a, u) {
  return a.replace(new RegExp("(^|\\s)" + u + "(?:\\s|$)", "g"), "$1").replace(/\s+/g, " ").replace(/^\s*|\s*$/g, "");
}
function removeClass$1(a, u) {
  a.classList ? a.classList.remove(u) : typeof a.className == "string" ? a.className = replaceClassName(a.className, u) : a.setAttribute("class", replaceClassName(a.className && a.className.baseVal || "", u));
}
const config = {
  disabled: !1
};
var timeoutsShape = process$1.env.NODE_ENV !== "production" ? PropTypes.oneOfType([PropTypes.number, PropTypes.shape({
  enter: PropTypes.number,
  exit: PropTypes.number,
  appear: PropTypes.number
}).isRequired]) : null, classNamesShape = process$1.env.NODE_ENV !== "production" ? PropTypes.oneOfType([PropTypes.string, PropTypes.shape({
  enter: PropTypes.string,
  exit: PropTypes.string,
  active: PropTypes.string
}), PropTypes.shape({
  enter: PropTypes.string,
  enterDone: PropTypes.string,
  enterActive: PropTypes.string,
  exit: PropTypes.string,
  exitDone: PropTypes.string,
  exitActive: PropTypes.string
})]) : null;
const TransitionGroupContext = React.createContext(null);
var forceReflow = function a(u) {
  return u.scrollTop;
}, UNMOUNTED = "unmounted", EXITED = "exited", ENTERING = "entering", ENTERED = "entered", EXITING = "exiting", Transition = /* @__PURE__ */ function(a) {
  _inheritsLoose(u, a);
  function u(l, v) {
    var p;
    p = a.call(this, l, v) || this;
    var _ = v, k = _ && !_.isMounting ? l.enter : l.appear, O;
    return p.appearStatus = null, l.in ? k ? (O = EXITED, p.appearStatus = ENTERING) : O = ENTERED : l.unmountOnExit || l.mountOnEnter ? O = UNMOUNTED : O = EXITED, p.state = {
      status: O
    }, p.nextCallback = null, p;
  }
  u.getDerivedStateFromProps = function(v, p) {
    var _ = v.in;
    return _ && p.status === UNMOUNTED ? {
      status: EXITED
    } : null;
  };
  var c = u.prototype;
  return c.componentDidMount = function() {
    this.updateStatus(!0, this.appearStatus);
  }, c.componentDidUpdate = function(v) {
    var p = null;
    if (v !== this.props) {
      var _ = this.state.status;
      this.props.in ? _ !== ENTERING && _ !== ENTERED && (p = ENTERING) : (_ === ENTERING || _ === ENTERED) && (p = EXITING);
    }
    this.updateStatus(!1, p);
  }, c.componentWillUnmount = function() {
    this.cancelNextCallback();
  }, c.getTimeouts = function() {
    var v = this.props.timeout, p, _, k;
    return p = _ = k = v, v != null && typeof v != "number" && (p = v.exit, _ = v.enter, k = v.appear !== void 0 ? v.appear : _), {
      exit: p,
      enter: _,
      appear: k
    };
  }, c.updateStatus = function(v, p) {
    if (v === void 0 && (v = !1), p !== null)
      if (this.cancelNextCallback(), p === ENTERING) {
        if (this.props.unmountOnExit || this.props.mountOnEnter) {
          var _ = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
          _ && forceReflow(_);
        }
        this.performEnter(v);
      } else
        this.performExit();
    else
      this.props.unmountOnExit && this.state.status === EXITED && this.setState({
        status: UNMOUNTED
      });
  }, c.performEnter = function(v) {
    var p = this, _ = this.props.enter, k = this.context ? this.context.isMounting : v, O = this.props.nodeRef ? [k] : [ReactDOM.findDOMNode(this), k], D = O[0], F = O[1], H = this.getTimeouts(), Z = k ? H.appear : H.enter;
    if (!v && !_ || config.disabled) {
      this.safeSetState({
        status: ENTERED
      }, function() {
        p.props.onEntered(D);
      });
      return;
    }
    this.props.onEnter(D, F), this.safeSetState({
      status: ENTERING
    }, function() {
      p.props.onEntering(D, F), p.onTransitionEnd(Z, function() {
        p.safeSetState({
          status: ENTERED
        }, function() {
          p.props.onEntered(D, F);
        });
      });
    });
  }, c.performExit = function() {
    var v = this, p = this.props.exit, _ = this.getTimeouts(), k = this.props.nodeRef ? void 0 : ReactDOM.findDOMNode(this);
    if (!p || config.disabled) {
      this.safeSetState({
        status: EXITED
      }, function() {
        v.props.onExited(k);
      });
      return;
    }
    this.props.onExit(k), this.safeSetState({
      status: EXITING
    }, function() {
      v.props.onExiting(k), v.onTransitionEnd(_.exit, function() {
        v.safeSetState({
          status: EXITED
        }, function() {
          v.props.onExited(k);
        });
      });
    });
  }, c.cancelNextCallback = function() {
    this.nextCallback !== null && (this.nextCallback.cancel(), this.nextCallback = null);
  }, c.safeSetState = function(v, p) {
    p = this.setNextCallback(p), this.setState(v, p);
  }, c.setNextCallback = function(v) {
    var p = this, _ = !0;
    return this.nextCallback = function(k) {
      _ && (_ = !1, p.nextCallback = null, v(k));
    }, this.nextCallback.cancel = function() {
      _ = !1;
    }, this.nextCallback;
  }, c.onTransitionEnd = function(v, p) {
    this.setNextCallback(p);
    var _ = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this), k = v == null && !this.props.addEndListener;
    if (!_ || k) {
      setTimeout(this.nextCallback, 0);
      return;
    }
    if (this.props.addEndListener) {
      var O = this.props.nodeRef ? [this.nextCallback] : [_, this.nextCallback], D = O[0], F = O[1];
      this.props.addEndListener(D, F);
    }
    v != null && setTimeout(this.nextCallback, v);
  }, c.render = function() {
    var v = this.state.status;
    if (v === UNMOUNTED)
      return null;
    var p = this.props, _ = p.children;
    p.in, p.mountOnEnter, p.unmountOnExit, p.appear, p.enter, p.exit, p.timeout, p.addEndListener, p.onEnter, p.onEntering, p.onEntered, p.onExit, p.onExiting, p.onExited, p.nodeRef;
    var k = _objectWithoutPropertiesLoose(p, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
    return (
      // allows for nested Transitions
      /* @__PURE__ */ React.createElement(TransitionGroupContext.Provider, {
        value: null
      }, typeof _ == "function" ? _(v, k) : React.cloneElement(React.Children.only(_), k))
    );
  }, u;
}(React.Component);
Transition.contextType = TransitionGroupContext;
Transition.propTypes = process$1.env.NODE_ENV !== "production" ? {
  /**
   * A React reference to DOM element that need to transition:
   * https://stackoverflow.com/a/51127130/4671932
   *
   *   - When `nodeRef` prop is used, `node` is not passed to callback functions
   *      (e.g. `onEnter`) because user already has direct access to the node.
   *   - When changing `key` prop of `Transition` in a `TransitionGroup` a new
   *     `nodeRef` need to be provided to `Transition` with changed `key` prop
   *     (see
   *     [test/CSSTransition-test.js](https://github.com/reactjs/react-transition-group/blob/13435f897b3ab71f6e19d724f145596f5910581c/test/CSSTransition-test.js#L362-L437)).
   */
  nodeRef: PropTypes.shape({
    current: typeof Element > "u" ? PropTypes.any : function(a, u, c, l, v, p) {
      var _ = a[u];
      return PropTypes.instanceOf(_ && "ownerDocument" in _ ? _.ownerDocument.defaultView.Element : Element)(a, u, c, l, v, p);
    }
  }),
  /**
   * A `function` child can be used instead of a React element. This function is
   * called with the current transition status (`'entering'`, `'entered'`,
   * `'exiting'`, `'exited'`), which can be used to apply context
   * specific props to a component.
   *
   * ```jsx
   * <Transition in={this.state.in} timeout={150}>
   *   {state => (
   *     <MyComponent className={`fade fade-${state}`} />
   *   )}
   * </Transition>
   * ```
   */
  children: PropTypes.oneOfType([PropTypes.func.isRequired, PropTypes.element.isRequired]).isRequired,
  /**
   * Show the component; triggers the enter or exit states
   */
  in: PropTypes.bool,
  /**
   * By default the child component is mounted immediately along with
   * the parent `Transition` component. If you want to "lazy mount" the component on the
   * first `in={true}` you can set `mountOnEnter`. After the first enter transition the component will stay
   * mounted, even on "exited", unless you also specify `unmountOnExit`.
   */
  mountOnEnter: PropTypes.bool,
  /**
   * By default the child component stays mounted after it reaches the `'exited'` state.
   * Set `unmountOnExit` if you'd prefer to unmount the component after it finishes exiting.
   */
  unmountOnExit: PropTypes.bool,
  /**
   * By default the child component does not perform the enter transition when
   * it first mounts, regardless of the value of `in`. If you want this
   * behavior, set both `appear` and `in` to `true`.
   *
   * > **Note**: there are no special appear states like `appearing`/`appeared`, this prop
   * > only adds an additional enter transition. However, in the
   * > `<CSSTransition>` component that first enter transition does result in
   * > additional `.appear-*` classes, that way you can choose to style it
   * > differently.
   */
  appear: PropTypes.bool,
  /**
   * Enable or disable enter transitions.
   */
  enter: PropTypes.bool,
  /**
   * Enable or disable exit transitions.
   */
  exit: PropTypes.bool,
  /**
   * The duration of the transition, in milliseconds.
   * Required unless `addEndListener` is provided.
   *
   * You may specify a single timeout for all transitions:
   *
   * ```jsx
   * timeout={500}
   * ```
   *
   * or individually:
   *
   * ```jsx
   * timeout={{
   *  appear: 500,
   *  enter: 300,
   *  exit: 500,
   * }}
   * ```
   *
   * - `appear` defaults to the value of `enter`
   * - `enter` defaults to `0`
   * - `exit` defaults to `0`
   *
   * @type {number | { enter?: number, exit?: number, appear?: number }}
   */
  timeout: function a(u) {
    var c = timeoutsShape;
    u.addEndListener || (c = c.isRequired);
    for (var l = arguments.length, v = new Array(l > 1 ? l - 1 : 0), p = 1; p < l; p++)
      v[p - 1] = arguments[p];
    return c.apply(void 0, [u].concat(v));
  },
  /**
   * Add a custom transition end trigger. Called with the transitioning
   * DOM node and a `done` callback. Allows for more fine grained transition end
   * logic. Timeouts are still used as a fallback if provided.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * ```jsx
   * addEndListener={(node, done) => {
   *   // use the css transitionend event to mark the finish of a transition
   *   node.addEventListener('transitionend', done, false);
   * }}
   * ```
   */
  addEndListener: PropTypes.func,
  /**
   * Callback fired before the "entering" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool) -> void
   */
  onEnter: PropTypes.func,
  /**
   * Callback fired after the "entering" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEntering: PropTypes.func,
  /**
   * Callback fired after the "entered" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool) -> void
   */
  onEntered: PropTypes.func,
  /**
   * Callback fired before the "exiting" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExit: PropTypes.func,
  /**
   * Callback fired after the "exiting" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExiting: PropTypes.func,
  /**
   * Callback fired after the "exited" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExited: PropTypes.func
} : {};
function noop() {
}
Transition.defaultProps = {
  in: !1,
  mountOnEnter: !1,
  unmountOnExit: !1,
  appear: !1,
  enter: !0,
  exit: !0,
  onEnter: noop,
  onEntering: noop,
  onEntered: noop,
  onExit: noop,
  onExiting: noop,
  onExited: noop
};
Transition.UNMOUNTED = UNMOUNTED;
Transition.EXITED = EXITED;
Transition.ENTERING = ENTERING;
Transition.ENTERED = ENTERED;
Transition.EXITING = EXITING;
const Transition$1 = Transition;
var _addClass = function a(u, c) {
  return u && c && c.split(" ").forEach(function(l) {
    return addClass(u, l);
  });
}, removeClass = function a(u, c) {
  return u && c && c.split(" ").forEach(function(l) {
    return removeClass$1(u, l);
  });
}, CSSTransition = /* @__PURE__ */ function(a) {
  _inheritsLoose(u, a);
  function u() {
    for (var l, v = arguments.length, p = new Array(v), _ = 0; _ < v; _++)
      p[_] = arguments[_];
    return l = a.call.apply(a, [this].concat(p)) || this, l.appliedClasses = {
      appear: {},
      enter: {},
      exit: {}
    }, l.onEnter = function(k, O) {
      var D = l.resolveArguments(k, O), F = D[0], H = D[1];
      l.removeClasses(F, "exit"), l.addClass(F, H ? "appear" : "enter", "base"), l.props.onEnter && l.props.onEnter(k, O);
    }, l.onEntering = function(k, O) {
      var D = l.resolveArguments(k, O), F = D[0], H = D[1], Z = H ? "appear" : "enter";
      l.addClass(F, Z, "active"), l.props.onEntering && l.props.onEntering(k, O);
    }, l.onEntered = function(k, O) {
      var D = l.resolveArguments(k, O), F = D[0], H = D[1], Z = H ? "appear" : "enter";
      l.removeClasses(F, Z), l.addClass(F, Z, "done"), l.props.onEntered && l.props.onEntered(k, O);
    }, l.onExit = function(k) {
      var O = l.resolveArguments(k), D = O[0];
      l.removeClasses(D, "appear"), l.removeClasses(D, "enter"), l.addClass(D, "exit", "base"), l.props.onExit && l.props.onExit(k);
    }, l.onExiting = function(k) {
      var O = l.resolveArguments(k), D = O[0];
      l.addClass(D, "exit", "active"), l.props.onExiting && l.props.onExiting(k);
    }, l.onExited = function(k) {
      var O = l.resolveArguments(k), D = O[0];
      l.removeClasses(D, "exit"), l.addClass(D, "exit", "done"), l.props.onExited && l.props.onExited(k);
    }, l.resolveArguments = function(k, O) {
      return l.props.nodeRef ? [l.props.nodeRef.current, k] : [k, O];
    }, l.getClassNames = function(k) {
      var O = l.props.classNames, D = typeof O == "string", F = D && O ? O + "-" : "", H = D ? "" + F + k : O[k], Z = D ? H + "-active" : O[k + "Active"], ee = D ? H + "-done" : O[k + "Done"];
      return {
        baseClassName: H,
        activeClassName: Z,
        doneClassName: ee
      };
    }, l;
  }
  var c = u.prototype;
  return c.addClass = function(v, p, _) {
    var k = this.getClassNames(p)[_ + "ClassName"], O = this.getClassNames("enter"), D = O.doneClassName;
    p === "appear" && _ === "done" && D && (k += " " + D), _ === "active" && v && forceReflow(v), k && (this.appliedClasses[p][_] = k, _addClass(v, k));
  }, c.removeClasses = function(v, p) {
    var _ = this.appliedClasses[p], k = _.base, O = _.active, D = _.done;
    this.appliedClasses[p] = {}, k && removeClass(v, k), O && removeClass(v, O), D && removeClass(v, D);
  }, c.render = function() {
    var v = this.props;
    v.classNames;
    var p = _objectWithoutPropertiesLoose(v, ["classNames"]);
    return /* @__PURE__ */ React.createElement(Transition$1, _extends({}, p, {
      onEnter: this.onEnter,
      onEntered: this.onEntered,
      onEntering: this.onEntering,
      onExit: this.onExit,
      onExiting: this.onExiting,
      onExited: this.onExited
    }));
  }, u;
}(React.Component);
CSSTransition.defaultProps = {
  classNames: ""
};
CSSTransition.propTypes = process$1.env.NODE_ENV !== "production" ? _extends({}, Transition$1.propTypes, {
  /**
   * The animation classNames applied to the component as it appears, enters,
   * exits or has finished the transition. A single name can be provided, which
   * will be suffixed for each stage, e.g. `classNames="fade"` applies:
   *
   * - `fade-appear`, `fade-appear-active`, `fade-appear-done`
   * - `fade-enter`, `fade-enter-active`, `fade-enter-done`
   * - `fade-exit`, `fade-exit-active`, `fade-exit-done`
   *
   * A few details to note about how these classes are applied:
   *
   * 1. They are _joined_ with the ones that are already defined on the child
   *    component, so if you want to add some base styles, you can use
   *    `className` without worrying that it will be overridden.
   *
   * 2. If the transition component mounts with `in={false}`, no classes are
   *    applied yet. You might be expecting `*-exit-done`, but if you think
   *    about it, a component cannot finish exiting if it hasn't entered yet.
   *
   * 2. `fade-appear-done` and `fade-enter-done` will _both_ be applied. This
   *    allows you to define different behavior for when appearing is done and
   *    when regular entering is done, using selectors like
   *    `.fade-enter-done:not(.fade-appear-done)`. For example, you could apply
   *    an epic entrance animation when element first appears in the DOM using
   *    [Animate.css](https://daneden.github.io/animate.css/). Otherwise you can
   *    simply use `fade-enter-done` for defining both cases.
   *
   * Each individual classNames can also be specified independently like:
   *
   * ```js
   * classNames={{
   *  appear: 'my-appear',
   *  appearActive: 'my-active-appear',
   *  appearDone: 'my-done-appear',
   *  enter: 'my-enter',
   *  enterActive: 'my-active-enter',
   *  enterDone: 'my-done-enter',
   *  exit: 'my-exit',
   *  exitActive: 'my-active-exit',
   *  exitDone: 'my-done-exit',
   * }}
   * ```
   *
   * If you want to set these classes using CSS Modules:
   *
   * ```js
   * import styles from './styles.css';
   * ```
   *
   * you might want to use camelCase in your CSS file, that way could simply
   * spread them instead of listing them one by one:
   *
   * ```js
   * classNames={{ ...styles }}
   * ```
   *
   * @type {string | {
   *  appear?: string,
   *  appearActive?: string,
   *  appearDone?: string,
   *  enter?: string,
   *  enterActive?: string,
   *  enterDone?: string,
   *  exit?: string,
   *  exitActive?: string,
   *  exitDone?: string,
   * }}
   */
  classNames: classNamesShape,
  /**
   * A `<Transition>` callback fired immediately after the 'enter' or 'appear' class is
   * applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEnter: PropTypes.func,
  /**
   * A `<Transition>` callback fired immediately after the 'enter-active' or
   * 'appear-active' class is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEntering: PropTypes.func,
  /**
   * A `<Transition>` callback fired immediately after the 'enter' or
   * 'appear' classes are **removed** and the `done` class is added to the DOM node.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEntered: PropTypes.func,
  /**
   * A `<Transition>` callback fired immediately after the 'exit' class is
   * applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement)
   */
  onExit: PropTypes.func,
  /**
   * A `<Transition>` callback fired immediately after the 'exit-active' is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement)
   */
  onExiting: PropTypes.func,
  /**
   * A `<Transition>` callback fired immediately after the 'exit' classes
   * are **removed** and the `exit-done` class is added to the DOM node.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement)
   */
  onExited: PropTypes.func
}) : {};
const CSSTransition$1 = CSSTransition;
var _leaveRenders, _enterRenders;
function areChildrenDifferent(a, u) {
  return !(a === u || React.isValidElement(a) && React.isValidElement(u) && a.key != null && a.key === u.key);
}
var modes = {
  out: "out-in",
  in: "in-out"
}, callHook = function a(u, c, l) {
  return function() {
    var v;
    u.props[c] && (v = u.props)[c].apply(v, arguments), l();
  };
}, leaveRenders = (_leaveRenders = {}, _leaveRenders[modes.out] = function(a) {
  var u = a.current, c = a.changeState;
  return React.cloneElement(u, {
    in: !1,
    onExited: callHook(u, "onExited", function() {
      c(ENTERING, null);
    })
  });
}, _leaveRenders[modes.in] = function(a) {
  var u = a.current, c = a.changeState, l = a.children;
  return [u, React.cloneElement(l, {
    in: !0,
    onEntered: callHook(l, "onEntered", function() {
      c(ENTERING);
    })
  })];
}, _leaveRenders), enterRenders = (_enterRenders = {}, _enterRenders[modes.out] = function(a) {
  var u = a.children, c = a.changeState;
  return React.cloneElement(u, {
    in: !0,
    onEntered: callHook(u, "onEntered", function() {
      c(ENTERED, React.cloneElement(u, {
        in: !0
      }));
    })
  });
}, _enterRenders[modes.in] = function(a) {
  var u = a.current, c = a.children, l = a.changeState;
  return [React.cloneElement(u, {
    in: !1,
    onExited: callHook(u, "onExited", function() {
      l(ENTERED, React.cloneElement(c, {
        in: !0
      }));
    })
  }), React.cloneElement(c, {
    in: !0
  })];
}, _enterRenders), SwitchTransition = /* @__PURE__ */ function(a) {
  _inheritsLoose(u, a);
  function u() {
    for (var l, v = arguments.length, p = new Array(v), _ = 0; _ < v; _++)
      p[_] = arguments[_];
    return l = a.call.apply(a, [this].concat(p)) || this, l.state = {
      status: ENTERED,
      current: null
    }, l.appeared = !1, l.changeState = function(k, O) {
      O === void 0 && (O = l.state.current), l.setState({
        status: k,
        current: O
      });
    }, l;
  }
  var c = u.prototype;
  return c.componentDidMount = function() {
    this.appeared = !0;
  }, u.getDerivedStateFromProps = function(v, p) {
    return v.children == null ? {
      current: null
    } : p.status === ENTERING && v.mode === modes.in ? {
      status: ENTERING
    } : p.current && areChildrenDifferent(p.current, v.children) ? {
      status: EXITING
    } : {
      current: React.cloneElement(v.children, {
        in: !0
      })
    };
  }, c.render = function() {
    var v = this.props, p = v.children, _ = v.mode, k = this.state, O = k.status, D = k.current, F = {
      children: p,
      current: D,
      changeState: this.changeState,
      status: O
    }, H;
    switch (O) {
      case ENTERING:
        H = enterRenders[_](F);
        break;
      case EXITING:
        H = leaveRenders[_](F);
        break;
      case ENTERED:
        H = D;
    }
    return /* @__PURE__ */ React.createElement(TransitionGroupContext.Provider, {
      value: {
        isMounting: !this.appeared
      }
    }, H);
  }, u;
}(React.Component);
SwitchTransition.propTypes = process$1.env.NODE_ENV !== "production" ? {
  /**
   * Transition modes.
   * `out-in`: Current element transitions out first, then when complete, the new element transitions in.
   * `in-out`: New element transitions in first, then when complete, the current element transitions out.
   *
   * @type {'out-in'|'in-out'}
   */
  mode: PropTypes.oneOf([modes.in, modes.out]),
  /**
   * Any `Transition` or `CSSTransition` component.
   */
  children: PropTypes.oneOfType([PropTypes.element.isRequired])
} : {};
SwitchTransition.defaultProps = {
  mode: modes.out
};
const SwitchTransition$1 = SwitchTransition, Animations = {
  "fade-in": ".fade-in{-webkit-animation:fade-in;animation:fade-in}@-webkit-keyframes fade-in{0%{opacity:0}100%{opacity:1}}@keyframes fade-in{0%{opacity:0}100%{opacity:1}}",
  "fade-out": ".fade-out{-webkit-animation:fade-out;animation:fade-out}@-webkit-keyframes fade-out{0%{opacity:1}100%{opacity:0}}@keyframes fade-out{0%{opacity:1}100%{opacity:0}}",
  "slide-in-blurred-top": ".slide-in-blurred-top{-webkit-animation:slide-in-blurred-top .6s cubic-bezier(.23,1.000,.32,1.000) both;animation:slide-in-blurred-top .6s cubic-bezier(.23,1.000,.32,1.000) both}@-webkit-keyframes slide-in-blurred-top{0%{-webkit-transform:translateY(-1000px) scaleY(2.5) scaleX(.2);transform:translateY(-1000px) scaleY(2.5) scaleX(.2);-webkit-transform-origin:50% 0;transform-origin:50% 0;-webkit-filter:blur(40px);filter:blur(40px);opacity:0}100%{-webkit-transform:translateY(0) scaleY(1) scaleX(1);transform:translateY(0) scaleY(1) scaleX(1);-webkit-transform-origin:50% 50%;transform-origin:50% 50%;-webkit-filter:blur(0);filter:blur(0);opacity:1}}@keyframes slide-in-blurred-top{0%{-webkit-transform:translateY(-1000px) scaleY(2.5) scaleX(.2);transform:translateY(-1000px) scaleY(2.5) scaleX(.2);-webkit-transform-origin:50% 0;transform-origin:50% 0;-webkit-filter:blur(40px);filter:blur(40px);opacity:0}100%{-webkit-transform:translateY(0) scaleY(1) scaleX(1);transform:translateY(0) scaleY(1) scaleX(1);-webkit-transform-origin:50% 50%;transform-origin:50% 50%;-webkit-filter:blur(0);filter:blur(0);opacity:1}}",
  "slide-in-left": ".slide-in-left{-webkit-animation:slide-in-left .5s cubic-bezier(.25,.46,.45,.94) both;animation:slide-in-left .5s cubic-bezier(.25,.46,.45,.94) both}@-webkit-keyframes slide-in-left{0%{-webkit-transform:translateX(-1000px);transform:translateX(-1000px);opacity:0}100%{-webkit-transform:translateX(0);transform:translateX(0);opacity:1}}@keyframes slide-in-left{0%{-webkit-transform:translateX(-1000px);transform:translateX(-1000px);opacity:0}100%{-webkit-transform:translateX(0);transform:translateX(0);opacity:1}}",
  "slide-out-left": ".slide-out-left{-webkit-animation:slide-out-left .5s cubic-bezier(.55,.085,.68,.53) both;animation:slide-out-left .5s cubic-bezier(.55,.085,.68,.53) both}@-webkit-keyframes slide-out-left{0%{-webkit-transform:translateX(0);transform:translateX(0);opacity:1}100%{-webkit-transform:translateX(-1000px);transform:translateX(-1000px);opacity:0}}@keyframes slide-out-left{0%{-webkit-transform:translateX(0);transform:translateX(0);opacity:1}100%{-webkit-transform:translateX(-1000px);transform:translateX(-1000px);opacity:0}}"
}, APIKitAnimation = (a) => {
  const {
    enter: u,
    exit: c,
    children: l,
    tag: v = "div",
    direction: p = "normal",
    duration: _ = 500,
    id: k,
    type: O
  } = a, D = k ? `${O}-${k}` : `${O}-api-kit-animation`;
  return /* @__PURE__ */ React.createElement("div", {
    style: {
      height: "100%",
      width: "100%"
    }
  }, /* @__PURE__ */ React.createElement("style", {
    dangerouslySetInnerHTML: {
      __html: renderStyle(O, u, c, _, p)
    }
  }), /* @__PURE__ */ React.createElement(SwitchTransition$1, {
    mode: "out-in"
  }, /* @__PURE__ */ React.createElement(CSSTransition$1, {
    key: D,
    addEndListener: (F, H) => {
      F.addEventListener("transitionend", H, !1);
    },
    classNames: {
      enter: `${O}-default-enter`,
      enterActive: u,
      exit: `${O}-default-leave`,
      exitActive: c
    },
    timeout: _
  }, /* @__PURE__ */ React.createElement("div", {
    style: {
      height: "100%",
      width: "100%"
    }
  }, l))));
}, renderStyle = (a, u, c, l, v) => `
        body {
          margin: 0;
          padding: 0;
        }
        
        ${Animations[u]}
        
        ${Animations[c]}

        .${a}-transition {
          transition: opacity ${l}ms ease-out};
        }

        .${a}-default-enter {
          opacity: 0;
        }

        .${a}-default-enter.${u} {
          animation-direction: ${v};
          animation-duration: ${l / 1e3}s;
          animation-fill-mode: both;
          animation-timing-function: ease-out;
        }

        .${a}-default-leave {
          opacity: 1;
        }

        .${a}-default-leave.${c} {
          animation-direction: ${v};
          animation-duration: ${l / 1e3}s;
          animation-timing-function: ease-out;
          animation-fill-mode: both;
        }
        `, APIKitAnimation$1 = APIKitAnimation, Background = {
  name: "LS-Background",
  sourceType: "Background",
  create({
    onUpdate: a,
    onRemove: u
  }, {
    sourceProps: c
  }) {
    u(() => {
      clearInterval(p);
    });
    const l = document.createElement("div"), v = getProject(CoreContext.state.activeProjectId).role;
    let p;
    const _ = ({
      source: H,
      setStartAnimation: Z
    }) => {
      var q, z;
      const {
        src: ee,
        type: X,
        meta: ne,
        loop: Q
      } = (H == null ? void 0 : H.sourceProps) || {}, {
        id: ae,
        sourceType: j
      } = H || {}, [ue, he] = React.useState(null), fe = React.useRef(null);
      console.log("Updated current time", (q = fe == null ? void 0 : fe.current) == null ? void 0 : q.currentTime);
      const be = React.useCallback((P) => {
        fe.current = P, he(P ? P.id : null);
      }, []), ke = React.useCallback(() => {
        fe != null && fe.current && fe.current.play().catch(() => {
          var P;
          fe.current.muted = !0, (P = fe.current) == null || P.play();
        });
      }, [ee]), Te = React.useCallback(() => {
        p && clearInterval(p), hasPermission(v, Permission.UpdateProject) && trigger$1("VideoEnded", {
          id: ae,
          category: X
        });
      }, [ee]);
      return React.useEffect(() => {
        ne && (fe != null && fe.current) && ue && hasPermission(v, Permission.ManageSelf) && ne != null && ne.time && (fe.current.currentTime = Number(ne == null ? void 0 : ne.time));
      }, [ne == null ? void 0 : ne.time, ue]), React.useEffect(() => () => {
        p && clearInterval(p);
      }, [ae]), React.useEffect(() => {
        ue ? fe.current && (fe.current.src = ee, fe.current.play().catch(() => {
          fe.current.muted = !0, fe.current.play();
        }), hasPermission(v, Permission.UpdateProject) && (p = setInterval(() => {
          if (fe.current.duration) {
            const P = fe.current.duration - fe.current.currentTime;
            trigger$1("VideoTimeUpdate", {
              category: j,
              id: ae,
              time: Math.floor(P)
            });
          }
        }, 1e3))) : p && clearInterval(p);
      }, [ue]), /* @__PURE__ */ React.createElement(React.Fragment, {
        key: ae
      }, ee && /* @__PURE__ */ React.createElement("video", {
        loop: Q,
        id: ae,
        ref: be,
        style: {
          ...(z = c == null ? void 0 : c.meta) == null ? void 0 : z.style,
          ...ne.style
        },
        onLoadedData: ke,
        onEnded: Te,
        onCanPlay: () => Z(!0)
      }));
    }, k = ({
      source: H,
      setStartAnimation: Z
    }) => {
      var ae;
      const {
        src: ee,
        meta: X,
        type: ne
      } = (H == null ? void 0 : H.sourceProps) || {}, {
        id: Q
      } = H || {};
      return /* @__PURE__ */ React.createElement(React.Fragment, {
        key: Q
      }, ee && /* @__PURE__ */ React.createElement("img", {
        style: {
          ...(ae = c == null ? void 0 : c.meta) == null ? void 0 : ae.style,
          ...X == null ? void 0 : X.style
        },
        src: ee,
        onLoad: () => Z(!0)
      }));
    }, O = ({
      source: H
    }) => {
      const {
        type: Z
      } = H.sourceProps, {
        id: ee
      } = H || {}, [X, ne] = React.useState(!1);
      return useEffect(() => {
        ne(!1);
      }, [ee]), /* @__PURE__ */ React.createElement(APIKitAnimation$1, {
        id: ee,
        type: "background",
        enter: APIKitAnimationTypes.FADE_IN,
        exit: APIKitAnimationTypes.FADE_OUT,
        duration: 400
      }, /* @__PURE__ */ React.createElement("div", {
        style: {
          opacity: X ? 1 : 0
        },
        className: "backgroundContainer background-transition"
      }, ee && Z === "image" && /* @__PURE__ */ React.createElement(k, {
        source: H,
        setStartAnimation: ne
      }), ee && Z === "video" && /* @__PURE__ */ React.createElement(_, {
        source: H,
        setStartAnimation: ne
      })));
    }, D = createRoot(l), F = (H) => D.render(/* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(O, {
      source: H
    })));
    return a((H) => {
      F({
        ...H
      });
    }), {
      root: l
    };
  }
}, Banner = {
  name: "LS-Banner",
  sourceType: "Banner",
  props: {
    bannerId: {
      type: String,
      required: !0
    }
  },
  useSource(a, u) {
    return a.find((c) => c.id === u.bannerId);
  },
  create({
    onUpdate: a,
    onNewSource: u
  }, c) {
    const l = document.createElement("div");
    let v, p, _;
    const k = ({
      currentSource: F,
      latestSource: H
    }) => {
      const [Z, ee] = useState(!1), {
        headerText: X,
        bodyText: ne
      } = (H == null ? void 0 : H.value) || {};
      return useEffect(() => {
        window.setTimeout(() => {
          ee(!!F);
        }), F || ee(!1);
      }, [F]), /* @__PURE__ */ React.createElement("div", {
        className: "BannerContainer",
        style: {
          position: "absolute",
          top: 0,
          left: 0,
          width: "100%",
          height: "100%",
          display: "flex",
          flexDirection: "row",
          justifyContent: "flex-start",
          alignItems: "flex-end",
          transition: "200ms ease all",
          ...Z ? {
            zIndex: 2,
            opacity: 1,
            transform: "translateX(0)"
          } : {
            zIndex: 1,
            opacity: 0,
            transform: "translateX(-200px)"
          }
        }
      }, /* @__PURE__ */ React.createElement("div", {
        className: "Banner",
        style: {
          padding: 10,
          background: "orange",
          width: "fit-content",
          height: "fit-content",
          maxWidth: "84%",
          position: "relative"
        }
      }, X && /* @__PURE__ */ React.createElement("div", {
        className: "Banner-header",
        style: {
          marginBottom: 6
        }
      }, X), ne && /* @__PURE__ */ React.createElement("div", {
        className: "Banner-body"
      }, ne)));
    }, O = createRoot(l), D = () => O.render(/* @__PURE__ */ React.createElement(React.Fragment, null, _ && _.id !== p.id && /* @__PURE__ */ React.createElement(k, {
      key: _ == null ? void 0 : _.id,
      currentSource: null,
      latestSource: _
    }), /* @__PURE__ */ React.createElement(k, {
      key: p == null ? void 0 : p.id,
      currentSource: v,
      latestSource: p
    })));
    return a(() => {
      D();
    }), u((F) => {
      _ = v, v = F, v && (p = v), D();
    }), {
      root: l
    };
  }
};
var functionExpression = /[\s]*([a-z-]+)[\s]*\([\s]*([^\)]+)[\s]*\)[\s]*/i, floatExpression = /^(\-?\d+\.?\d{0,5})/, toFloat = parseFloat;
function ensurePercent(a) {
  return typeof a == "number" ? a : toFloat(a) * 0.01;
}
function formatPercent(a) {
  return formatFloat(a * 100) + "%";
}
function formatFloat(a) {
  return floatExpression.exec(a.toString())[1];
}
function parseCSSFunction(a) {
  var u = functionExpression.exec(a);
  if (!(!u || !u.length))
    return [u[1]].concat(u[2].split(","));
}
function cssFunction(a, u) {
  var c = Array.prototype.join.call(u, ", ");
  return a + "(" + c + ")";
}
var math = Math, round = math.round;
function roundFloat(a, u) {
  return round(a * u) / u;
}
var _a, RGB = "rgb", HSL = "hsl", converters = (_a = {}, _a[RGB + HSL] = RGBtoHSL, _a[HSL + RGB] = HSLtoRGB, _a), maxChannelValues = {
  r: 255,
  g: 255,
  b: 255,
  h: 360,
  s: 1,
  l: 1,
  a: 1
};
function color(a) {
  return parseHexCode(a) || parseColorFunction(a) || rgb(255, 0, 0);
}
function rgb(a, u, c, l) {
  return new ColorHelper(
    RGB,
    a,
    u,
    c,
    l === void 0 ? 1 : ensurePercent(l),
    l !== void 0
    /* hasAlpha*/
  );
}
function convertHelper(a, u, c) {
  var l = u.f, v = u.r, p = u.g, _ = u.b, k = u.a, O = c === void 0 ? u.o : c;
  return l !== a ? converters[l + a](v, p, _, k, O) : c === void 0 ? u : new ColorHelper(l, v, p, _, k, O);
}
var ColorHelper = (
  /** @class */
  function() {
    function a(u, c, l, v, p, _) {
      var k = this;
      k.f = u, k.o = _;
      var O = u === HSL;
      k.r = clampColor(O ? "h" : "r", c), k.g = clampColor(O ? "s" : "g", l), k.b = clampColor(O ? "l" : "b", v), k.a = clampColor("a", p);
    }
    return a.prototype.toString = function() {
      var u = this, c = u.o, l = u.f, v = u.r, p = u.g, _ = u.b, k = u.a, O, D;
      if (l === RGB)
        O = c ? "rgba" : RGB, D = [round(v), round(p), round(_)];
      else if (l === HSL)
        O = c ? "hsla" : HSL, D = [round(v), formatPercent(roundFloat(p, 100)), formatPercent(roundFloat(_, 100))];
      else
        throw new Error("Invalid color format");
      return c && D.push(formatFloat(roundFloat(k, 1e5))), cssFunction(O, D);
    }, a.prototype.toHexString = function() {
      var u = convertHelper(RGB, this);
      return "#" + (toHex(u.r) + toHex(u.g) + toHex(u.b)).toUpperCase();
    }, a.prototype.toHSL = function() {
      return convertHelper(HSL, this, !1);
    }, a.prototype.toHSLA = function() {
      return convertHelper(HSL, this, !0);
    }, a.prototype.toRGB = function() {
      return convertHelper(RGB, this, !1);
    }, a.prototype.toRGBA = function() {
      return convertHelper(RGB, this, !0);
    }, a.prototype.red = function() {
      var u = this;
      return (u.f === RGB ? u : u.toRGB()).r;
    }, a.prototype.green = function() {
      var u = this;
      return (u.f === RGB ? u : u.toRGB()).g;
    }, a.prototype.blue = function() {
      var u = this;
      return (u.f === RGB ? u : u.toRGB()).b;
    }, a.prototype.hue = function() {
      var u = this;
      return (u.f === HSL ? u : u.toHSL()).r;
    }, a.prototype.saturation = function() {
      var u = this;
      return (u.f === HSL ? u : u.toHSL()).g;
    }, a.prototype.lightness = function() {
      var u = this;
      return (u.f === HSL ? u : u.toHSL()).b;
    }, a.prototype.alpha = function() {
      return this.a;
    }, a.prototype.opacity = function() {
      return this.a;
    }, a.prototype.invert = function() {
      var u = this, c = convertHelper(RGB, u);
      return convertHelper(u.f, new a(RGB, 255 - c.r, 255 - c.g, 255 - c.b, u.a, u.o));
    }, a.prototype.lighten = function(u, c) {
      var l = this, v = convertHelper(HSL, l), p = maxChannelValues.l, _ = v.b + (c ? p - v.b : p) * ensurePercent(u);
      return convertHelper(l.f, new a(HSL, v.r, v.g, _, l.a, l.o));
    }, a.prototype.darken = function(u, c) {
      var l = this, v = convertHelper(HSL, l), p = v.b - (c ? v.b : maxChannelValues.l) * ensurePercent(u);
      return convertHelper(l.f, new a(HSL, v.r, v.g, p, l.a, l.o));
    }, a.prototype.saturate = function(u, c) {
      var l = this, v = convertHelper(HSL, l), p = maxChannelValues.s, _ = v.g + (c ? p - v.g : p) * ensurePercent(u);
      return convertHelper(l.f, new a(HSL, v.r, _, v.b, l.a, l.o));
    }, a.prototype.desaturate = function(u, c) {
      var l = this, v = convertHelper(HSL, l), p = maxChannelValues.s, _ = v.g - (c ? v.g : p) * ensurePercent(u);
      return convertHelper(l.f, new a(HSL, v.r, _, v.b, l.a, l.o));
    }, a.prototype.grayscale = function() {
      return this.desaturate(1);
    }, a.prototype.fade = function(u) {
      var c = this, l = clampColor("a", ensurePercent(u));
      return convertHelper(c.f, new a(c.f, c.r, c.g, c.b, l, !0));
    }, a.prototype.fadeOut = function(u, c) {
      var l = this, v = 1, p = clampColor("a", l.a - (c ? l.a : v) * ensurePercent(u));
      return convertHelper(l.f, new a(l.f, l.r, l.g, l.b, p, !0));
    }, a.prototype.fadeIn = function(u, c) {
      var l = this, v = 1, p = clampColor("a", l.a + (c ? l.a : v) * ensurePercent(u));
      return convertHelper(l.f, new a(l.f, l.r, l.g, l.b, p, !0));
    }, a.prototype.mix = function(u, c) {
      var l = this, v = ensureColor(u), p = convertHelper(RGB, l), _ = convertHelper(RGB, v), k = c === void 0 ? 0.5 : c, O = 2 * k - 1, D = Math.abs(p.a - _.a), F = ((O * D === -1 ? O : (O + D) / (1 + O * D)) + 1) / 2, H = 1 - F, Z = new a(RGB, round(p.r * F + _.r * H), round(p.g * F + _.g * H), round(p.b * F + _.b * H), p.a * k + _.a * (1 - k), l.o || v.o);
      return convertHelper(this.f, Z);
    }, a.prototype.tint = function(u) {
      return rgb(255, 255, 255).mix(this, u);
    }, a.prototype.shade = function(u) {
      return rgb(0, 0, 0).mix(this, u);
    }, a.prototype.spin = function(u) {
      var c = this, l = convertHelper(HSL, c);
      return convertHelper(c.f, new a(HSL, modDegrees(l.r + u), l.g, l.b, c.a, c.o));
    }, a;
  }()
);
function toHex(a) {
  var u = round(a);
  return (u < 16 ? "0" : "") + u.toString(16);
}
function modDegrees(a) {
  return ((a < 0 ? 360 : 0) + a % 360) % 360;
}
function RGBtoHSL(a, u, c, l, v) {
  var p = a / 255, _ = u / 255, k = c / 255, O = Math.min(p, _, k), D = Math.max(p, _, k), F = (O + D) / 2, H = D - O, Z;
  D === O ? Z = 0 : p === D ? Z = (_ - k) / H : _ === D ? Z = 2 + (k - p) / H : k === D ? Z = 4 + (p - _) / H : Z = 0, Z = Math.min(Z * 60, 360), Z < 0 && (Z += 360);
  var ee;
  return D === O ? ee = 0 : F <= 0.5 ? ee = H / (D + O) : ee = H / (2 - D - O), new ColorHelper(HSL, Z, ee, F, l, v);
}
function HSLtoRGB(a, u, c, l, v) {
  var p = a / 360, _ = u, k = c;
  if (_ === 0) {
    var O = k * 255;
    return new ColorHelper(RGB, O, O, O, l, v);
  }
  for (var D = k < 0.5 ? k * (1 + _) : k + _ - k * _, F = 2 * k - D, H = 0, Z = 0, ee = 0, X = 0; X < 3; X++) {
    var ne = p + 0.3333333333333333 * -(X - 1);
    ne < 0 && ne++, ne > 1 && ne--;
    var O = void 0;
    6 * ne < 1 ? O = F + (D - F) * 6 * ne : 2 * ne < 1 ? O = D : 3 * ne < 2 ? O = F + (D - F) * (2 / 3 - ne) * 6 : O = F, O *= 255, X === 0 ? H = O : X === 1 ? Z = O : ee = O;
  }
  return new ColorHelper(RGB, H, Z, ee, l, v);
}
function clampColor(a, u) {
  var c = 0, l = maxChannelValues[a];
  return u < c ? c : u > l ? l : u;
}
function ensureColor(a) {
  return a instanceof ColorHelper ? a : color(a);
}
function parseHexCode(a) {
  var u = a.match(/#(([a-f0-9]{6})|([a-f0-9]{3}))$/i);
  if (u) {
    var c = u[1], l = parseInt(c.length === 3 ? c[0] + c[0] + c[1] + c[1] + c[2] + c[2] : c, 16), v = l >> 16 & 255, p = l >> 8 & 255, _ = l & 255;
    return new ColorHelper(RGB, v, p, _, 1, !1);
  }
}
function parseColorFunction(a) {
  var u = parseCSSFunction(a);
  if (!(!u || !(u.length === 4 || u.length === 5))) {
    var c = u[0], l = c === "rgba", v = c === "hsla", p = c === RGB, _ = c === HSL, k = v || l, O;
    if (p || l)
      O = RGB;
    else if (_ || v)
      O = HSL;
    else
      throw new Error("unsupported color string");
    var D = toFloat(u[1]), F = p || l ? toFloat(u[2]) : ensurePercent(u[2]), H = p || l ? toFloat(u[3]) : ensurePercent(u[3]), Z = k ? toFloat(u[4]) : 1;
    return new ColorHelper(O, D, F, H, Z, k);
  }
}
const of = color, transparent = color("rgba(0,0,0,0)"), white = color("#ffffff"), black = color("#000000"), weights = {
  primary: {
    50: "#EAFAF5",
    100: "#D5F6EB",
    200: "#ABEDD7",
    300: "#82E3C3",
    400: "#58DAAF",
    500: "#26AD80",
    600: "#25A77C",
    700: "#1C7D5D",
    800: "#12543E"
  },
  secondary: {
    50: "#FBEAEA",
    100: "#F7D4D4",
    200: "#EFA9A9",
    300: "#E77E7E",
    400: "#FF6F64",
    500: "#E9554A",
    600: "#CB362B",
    700: "#811818",
    800: "#561010"
  },
  neutral: {
    0: "#ffffff",
    10: "#f5f5f5",
    200: "#d9d9d9",
    300: "#bababa",
    350: "#999999",
    400: "#9e9e9e",
    500: "#808080",
    600: "#666666",
    700: "#4d4d4d",
    800: "#303030",
    900: "#141414",
    1e3: "#000000"
  },
  warning: {
    400: "#FFC28A",
    500: "#FFAE64",
    600: "#F29540"
  }
}, types = Object.keys(weights), weight = (a) => (u) => {
  const c = weights[a];
  if (c[u])
    return c[u];
  const l = Object.keys(weights.primary).map(Number), v = l.find((p) => u <= p);
  return v ? c[v] : c[l.slice(l.length - 1)[0]];
}, primary = weight("primary"), neutral = weight("neutral"), secondary = weight("secondary"), warning = weight("warning"), lightstream = color("#26ad80"), twitch = color("#9156ff"), linkedin = color("#2867b2"), youtube = color("#ff0000"), facebook = color("#1877f2"), twitter = color("#1da1f2"), Color = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  black,
  color,
  facebook,
  lightstream,
  linkedin,
  neutral,
  of,
  primary,
  secondary,
  transparent,
  twitch,
  twitter,
  types,
  warning,
  white,
  youtube
}, Symbol.toStringTag, { value: "Module" })), YouTube = /* @__PURE__ */ React.createElement("svg", {
  style: {
    flex: "0 0 100%"
  },
  viewBox: "0 0 24 24"
}, /* @__PURE__ */ React.createElement("path", {
  d: "M19.6465 8.53711C19.4707 7.83398 18.9141 7.27734 18.2402 7.10156C16.9805 6.75 12 6.75 12 6.75C12 6.75 6.99023 6.75 5.73047 7.10156C5.05664 7.27734 4.5 7.83398 4.32422 8.53711C3.97266 9.76758 3.97266 12.4043 3.97266 12.4043C3.97266 12.4043 3.97266 15.0117 4.32422 16.2715C4.5 16.9746 5.05664 17.502 5.73047 17.6777C6.99023 18 12 18 12 18C12 18 16.9805 18 18.2402 17.6777C18.9141 17.502 19.4707 16.9746 19.6465 16.2715C19.998 15.0117 19.998 12.4043 19.998 12.4043C19.998 12.4043 19.998 9.76758 19.6465 8.53711ZM10.3594 14.7773V10.0312L14.5195 12.4043L10.3594 14.7773Z"
})), YouTubeDuo = /* @__PURE__ */ React.createElement("svg", {
  style: {
    flex: "0 0 100%"
  },
  viewBox: "0 0 24 24"
}, /* @__PURE__ */ React.createElement("rect", {
  x: "8",
  y: "9",
  width: "9",
  height: "7",
  fill: neutral(0)
}), /* @__PURE__ */ React.createElement("path", {
  d: "M19.6465 8.53711C19.4707 7.83398 18.9141 7.27734 18.2402 7.10156C16.9805 6.75 12 6.75 12 6.75C12 6.75 6.99023 6.75 5.73047 7.10156C5.05664 7.27734 4.5 7.83398 4.32422 8.53711C3.97266 9.76758 3.97266 12.4043 3.97266 12.4043C3.97266 12.4043 3.97266 15.0117 4.32422 16.2715C4.5 16.9746 5.05664 17.502 5.73047 17.6777C6.99023 18 12 18 12 18C12 18 16.9805 18 18.2402 17.6777C18.9141 17.502 19.4707 16.9746 19.6465 16.2715C19.998 15.0117 19.998 12.4043 19.998 12.4043C19.998 12.4043 19.998 9.76758 19.6465 8.53711ZM10.3594 14.7773V10.0312L14.5195 12.4043L10.3594 14.7773Z"
})), Facebook = /* @__PURE__ */ React.createElement("svg", {
  style: {
    flex: "0 0 100%"
  },
  viewBox: "0 0 24 24"
}, /* @__PURE__ */ React.createElement("path", {
  d: "M15.4863 13.3125L15.8965 10.6172H13.2891V8.85938C13.2891 8.09766 13.6406 7.39453 14.8125 7.39453H16.0137V5.08008C16.0137 5.08008 14.9297 4.875 13.9043 4.875C11.7656 4.875 10.3594 6.19336 10.3594 8.53711V10.6172H7.95703V13.3125H10.3594V19.875H13.2891V13.3125H15.4863Z"
})), FacebookCircle = /* @__PURE__ */ React.createElement("svg", {
  style: {
    flex: "0 0 100%"
  },
  viewBox: "0 0 24 24"
}, /* @__PURE__ */ React.createElement("path", {
  d: "M19.2656 12.375C19.2656 8.36133 16.0137 5.10938 12 5.10938C7.98633 5.10938 4.73438 8.36133 4.73438 12.375C4.73438 16.0078 7.37109 19.0254 10.8574 19.5527V14.4844H9.01172V12.375H10.8574V10.793C10.8574 8.97656 11.9414 7.95117 13.582 7.95117C14.4023 7.95117 15.2227 8.09766 15.2227 8.09766V9.88477H14.3145C13.4062 9.88477 13.1133 10.4414 13.1133 11.0273V12.375H15.1348L14.8125 14.4844H13.1133V19.5527C16.5996 19.0254 19.2656 16.0078 19.2656 12.375Z"
})), Twitch = /* @__PURE__ */ React.createElement("svg", {
  style: {
    flex: "0 0 100%"
  },
  viewBox: "0 0 24 24"
}, /* @__PURE__ */ React.createElement("path", {
  d: "M16.9551 8.92188H15.8125V12.1445H16.9551V8.92188ZM13.8496 8.89258H12.707V12.1152H13.8496V8.89258ZM9.01562 5.875L6.20312 8.57031V18.209H9.60156V20.875L12.4141 18.209H14.6699L19.7676 13.375V5.875H9.01562ZM18.6543 12.8477L16.3691 14.9863H14.1133L12.1504 16.8613V14.9863H9.60156V6.95898H18.6543V12.8477Z"
})), TwitchDuo = /* @__PURE__ */ React.createElement("svg", {
  style: {
    flex: "0 0 100%"
  },
  viewBox: "0 0 24 24"
}, /* @__PURE__ */ React.createElement("path", {
  d: "M19 6.5H9L8.8125 17.5H13.5L19 13V6.5Z",
  fill: neutral(0)
}), /* @__PURE__ */ React.createElement("path", {
  d: "M16.9551 8.92188H15.8125V12.1445H16.9551V8.92188ZM13.8496 8.89258H12.707V12.1152H13.8496V8.89258ZM9.01562 5.875L6.20312 8.57031V18.209H9.60156V20.875L12.4141 18.209H14.6699L19.7676 13.375V5.875H9.01562ZM18.6543 12.8477L16.3691 14.9863H14.1133L12.1504 16.8613V14.9863H9.60156V6.95898H18.6543V12.8477Z"
})), Twitter = /* @__PURE__ */ React.createElement("svg", {
  style: {
    flex: "0 0 100%"
  },
  viewBox: "0 0 24 24"
}, /* @__PURE__ */ React.createElement("path", {
  d: "M20.6681 7.98749C20.6806 8.16248 20.6806 8.33751 20.6806 8.5125C20.6806 13.85 16.6197 20 9.1976 20C6.91098 20 4.78681 19.3375 3 18.1875C3.32489 18.225 3.63723 18.2375 3.97462 18.2375C5.86136 18.2375 7.59821 17.6 8.98518 16.5125C7.21086 16.475 5.72393 15.3125 5.21162 13.7125C5.46155 13.75 5.71143 13.775 5.97386 13.775C6.33621 13.775 6.69859 13.725 7.03594 13.6375C5.18666 13.2625 3.79966 11.6375 3.79966 9.67499V9.62501C4.33693 9.92501 4.96174 10.1125 5.62393 10.1375C4.53685 9.41247 3.82466 8.17498 3.82466 6.77497C3.82466 6.02499 4.02454 5.33749 4.37443 4.73748C6.36117 7.18748 9.34753 8.78745 12.6962 8.96248C12.6337 8.66248 12.5962 8.35001 12.5962 8.03751C12.5962 5.81248 14.3955 4 16.6322 4C17.7942 4 18.8438 4.4875 19.581 5.275C20.4931 5.10001 21.3678 4.76249 22.1425 4.3C21.8426 5.23752 21.2054 6.02502 20.3682 6.52499C21.1804 6.43753 21.9676 6.21248 22.6923 5.90001C22.1426 6.69998 21.4553 7.41245 20.6681 7.98749Z"
})), LinkedIn = /* @__PURE__ */ React.createElement("svg", {
  style: {
    flex: "0 0 100%"
  },
  viewBox: "0 0 24 24"
}, /* @__PURE__ */ React.createElement("path", {
  d: "M19.2 3H4.8C3.81 3 3.009 3.81 3.009 4.8L3 19.2C3 20.19 3.81 21 4.8 21H19.2C20.19 21 21 20.19 21 19.2V4.8C21 3.81 20.19 3 19.2 3ZM8.4 18.3H5.7V10.2H8.4V18.3ZM7.05 8.679C6.15 8.679 5.421 7.95 5.421 7.05C5.421 6.15 6.15 5.421 7.05 5.421C7.95 5.421 8.679 6.15 8.679 7.05C8.679 7.95 7.95 8.679 7.05 8.679ZM18.3 18.3H15.6V13.53C15.6 12.783 14.997 12.18 14.25 12.18C13.503 12.18 12.9 12.783 12.9 13.53V18.3H10.2V10.2H12.9V11.28C13.368 10.524 14.331 10.02 15.15 10.02C16.887 10.02 18.3 11.433 18.3 13.17V18.3Z"
})), Lightstream = /* @__PURE__ */ React.createElement("svg", {
  style: {
    flex: "0 0 100%"
  },
  viewBox: "0.144 0 27.712 24"
}, /* @__PURE__ */ React.createElement("path", {
  d: "M16.0369 12.1232L14 15.6518L11.5642 11.4335L6.27356 10.6176L14 24L20.4627 12.805L16.0369 12.1232Z"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M9.74033 8.27418L7.37317 4.17409H20.6268L19.0921 6.83194L24.3827 6.01602L27.8558 0H0.144165L5.31453 8.95665L9.74033 8.27418Z"
})), LightstreamWithText = /* @__PURE__ */ React.createElement("svg", {
  style: {
    flex: "0 0 100%"
  },
  viewBox: "0 0 3000 524"
}, /* @__PURE__ */ React.createElement("polygon", {
  points: "330.56 263.5 299.73 316.91 262.86 253.06 182.78 240.71 299.73 443.27 397.55 273.82 330.56 263.5"
}), /* @__PURE__ */ React.createElement("polygon", {
  points: "235.25 205.24 199.42 143.18 400.03 143.18 376.8 183.41 456.88 171.06 509.45 80 90 80 168.26 215.57 235.25 205.24"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M646.32,345.72h94.91v13.73H630V167.26h16.36Z"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M846.24,359.45H830V167.26h16.23Z"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M1091.16,336.61q-8.45,12-26.46,18.74t-40.33,6.73q-22.57,0-40.13-10.82t-27.19-30.62q-9.64-19.8-9.77-45.41V250.95q0-40,20.2-63.16t54.25-23.17q29.69,0,47.78,15.11T1091,221.38h-16.24q-3.56-21.18-17.23-32.11t-35.7-10.92q-26.92,0-42.64,19.15t-15.71,54v22.72q0,21.93,7.46,38.77t21.38,26.09q13.92,9.25,32,9.25,21,0,36-6.6,9.76-4.36,14.52-10.16V282h-51.61V268.24h67.85Z"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M1333.71,359.45h-16.37V278.11H1207.53v81.33h-16.23V167.26h16.23v97.12h109.81V167.26h16.37Z"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M1563.2,181h-65.87V359.45H1481.1V181h-65.73V167.26H1563.2Z"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M1990.75,181h-65.87V359.45h-16.23V181h-65.73V167.26h147.83Z"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M2147.65,279.33h-55.84v80.12h-16.36V167.26h62.43q30.75,0,48,14.9t17.29,41.66a52,52,0,0,1-10.83,32.56q-10.82,14.11-29,19.51l48,81.83v1.72h-17.29Zm-55.84-13.73h49.76q20.45,0,32.86-11.63t12.41-30.14q0-20.36-12.93-31.59T2137.61,181h-45.8Z"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M2407.62,278.11h-89.88v67.61h103.35v13.73H2301.5V167.26h118.92V181H2317.73v83.39h89.88Z"
}), /* @__PURE__ */ React.createElement("polygon", {
  points: "2892.79 183.67 2892.79 183.67 2816.23 326.97 2724.06 154.45 2724.06 189.54 2724.06 359.75 2739.67 359.75 2739.67 218.3 2816.26 359.42 2892.79 218.32 2892.79 359.75 2908.4 359.75 2908.4 189.54 2908.4 154.45 2892.79 183.67"
}), /* @__PURE__ */ React.createElement("polygon", {
  points: "2649.77 359.45 2569.47 154.54 2569.47 154.53 2569.46 154.53 2569.46 154.53 2569.46 154.54 2489.16 359.45 2506.19 359.45 2569.46 194.32 2632.74 359.45 2649.77 359.45"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M1764.57,287q-6.73-10.56-20.06-18.15a131.55,131.55,0,0,0-21.47-9.18l-7.64,13.49q19.65,6.61,28.32,13.77,11.22,9.3,11.22,25.28,0,16.37-13.6,26.26t-36,9.9c-11.35,0-21.05-1.94-29.35-5.51l-7,12.33a94,94,0,0,0,36.33,6.91q29.7,0,47.85-13.73t18.15-36.43Q1771.3,297.55,1764.57,287Z"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M1659.11,250.93c7.28,5.25,18,10.18,32.13,14.79l7.72-13.38q-21-6.41-31.29-14.49Q1655.95,228.61,1656,214q0-15.83,13-25.66t35-9.83c13.12,0,23.78,3.19,32.26,9.21l7.23-12.51c-1.71-1-3.43-2.1-5.3-3q-15.09-7.38-34.18-7.38-28.19,0-46.31,13.76t-18.11,35.77Q1639.62,237,1659.11,250.93Z"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M1744.34,268.78a129.23,129.23,0,0,0-21.68-9.32l-7.79,13.49c13.28,4.44,22.87,9.06,28.68,13.88q11.2,9.29,11.2,25.23,0,16.33-13.57,26.21t-36,9.88c-11.8,0-21.85-2-30.34-5.91l-7.08,12.26.2.1a93.63,93.63,0,0,0,37.22,7.25q29.64,0,47.75-13.7t18.11-36.36q0-14.36-6.72-24.9T1744.34,268.78Z"
})), IconMap = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Facebook,
  FacebookCircle,
  Lightstream,
  LightstreamWithText,
  LinkedIn,
  Twitch,
  TwitchDuo,
  Twitter,
  YouTube,
  YouTubeDuo
}, Symbol.toStringTag, { value: "Module" })), nudge = (a) => {
  if (a.nudgeUp || a.nudgeDown || a.nudgeRight || a.nudgeLeft)
    return {
      position: "relative",
      top: a.nudgeDown,
      left: a.nudgeRight,
      right: a.nudgeLeft,
      bottom: a.nudgeUp
    };
}, SVGWrapper = ({
  children: a,
  width: u,
  height: c,
  color: l,
  colorWeight: v = 0,
  marginLeft: p,
  marginTop: _,
  marginRight: k,
  marginBottom: O,
  className: D,
  ...F
}) => (l && Color[l](v), /* @__PURE__ */ React.createElement("div", {
  className: D,
  style: {
    ...nudge(F),
    display: "flex",
    justifyContent: "center",
    flexBasis: u || "auto",
    flexShrink: 0,
    width: u,
    height: c || u && "fit-content",
    marginLeft: p,
    marginTop: _,
    marginBottom: O,
    marginRight: k
  }
}, a)), Icon = ({
  name: a,
  ...u
}) => /* @__PURE__ */ React.createElement(SVGWrapper, {
  ...u
}, IconMap[a]), Icon$1 = Icon, dragImageSvg = `
  <svg height="75" width="120" viewBox="0 0 120 75" xmlns="http://www.w3.org/2000/svg" style="">
    <rect width="120" height="75" rx="3" style="
      opacity: 0.4;
      stroke: white;
      stroke-width: 3px;
      stroke-opacity: 0.7;
    "/>
  </svg>`;
let dragImage;
const loadDragImage = () => dragImage || (dragImage = new Image(), dragImage.src = URL.createObjectURL(new Blob([dragImageSvg], {
  type: "image/svg+xml"
})), dragImage);
class ErrorBoundary extends React.Component {
  constructor(u) {
    super(u), this.state = {
      error: null
    };
  }
  componentDidCatch(u, c) {
    log.warn(u, c);
  }
  static getDerivedStateFromError() {
    return {
      error: !0
    };
  }
  render() {
    return this.state.error ? null : this.props.children;
  }
}
const onDrop = async (a, u) => {
  u.preventDefault(), u.stopPropagation();
  const {
    dropNodeId: c,
    dropType: l,
    project: v
  } = a, p = u.dataTransfer.getData("text/plain");
  if (log.debug("Compositor: Dropping", {
    dropType: l,
    dragNodeId: p,
    dropNodeId: c
  }), c === p)
    return;
  const [_, k, O, D] = await Promise.all([v.compositor.get(p), v.compositor.get(c), v.compositor.getParent(p), v.compositor.getParent(c)]);
  if (l === "layout")
    return O.id === c ? void 0 : CoreContext.Command.moveNode({
      projectId: v.id,
      nodeId: _.id,
      parentId: k.id
    });
  if (O.id !== (D == null ? void 0 : D.id))
    return CoreContext.Command.swapNodes({
      projectId: v.id,
      nodeAId: _.id,
      nodeBId: k.id
    });
  const F = O.children.map((H) => H.id);
  return CoreContext.Command.reorderNodes({
    projectId: v.id,
    parentId: O.id,
    childIds: swapItems(_.id, k.id, F)
  });
};
let foundDropTarget = !1;
const ElementTree = (a) => {
  var ue, he;
  const u = useRef(!1), c = useRef(), l = useRef(), v = useRef(), {
    project: p,
    interactive: _ = !0,
    onElementDoubleClick: k,
    checkIsDragTarget: O,
    checkIsDropTarget: D
  } = useContext(CompositorContext), {
    nodeId: F
  } = a, H = p.compositor.get(F);
  if (!H)
    return null;
  const Z = CoreContext.compositor.getElement(H), ee = H.props.layout || "Row", X = _ && O(H), ne = _ && D(H);
  let Q = ne ? {
    onDrop: (fe) => (foundDropTarget = !0, onDrop({
      dropType: "layout",
      dropNodeId: H.id,
      project: p
    }, fe)),
    onDragOver: (fe) => {
      var be;
      fe.preventDefault(), fe.stopPropagation(), (be = v.current) == null || be.toggleAttribute("data-layout-drop-target-active", !0);
    },
    onDragLeave: (fe) => {
      var be;
      fe.preventDefault(), fe.stopPropagation(), (be = v.current) == null || be.toggleAttribute("data-layout-drop-target-active", !1);
    }
  } : {}, ae = X ? {
    draggable: !0,
    // If a target is draggable, it will also be treated as
    //  a drop target (swap element positions)
    ondrop: (fe) => (foundDropTarget = !0, onDrop(
      {
        dropType: "transform",
        dropNodeId: H.id,
        project: p
      },
      // @ts-ignore TODO: Convert all to native drag events
      fe
    )),
    ondragstart: (fe) => {
      var be;
      u.current = !0, wrapperEl.toggleAttribute("data-dragging", !0), log.debug("Compositor: Dragging", H.id), foundDropTarget = !1, fe.dataTransfer.setData("text/plain", H.id), fe.dataTransfer.dropEffect = "move", fe.dataTransfer.setDragImage(dragImage, 10, 10), (be = v.current) == null || be.toggleAttribute("data-drag-target-active", !0), window.__dragging = !0;
    },
    ondragend: (fe) => {
      var be;
      u.current = !1, foundDropTarget || (log.info("Compositor: No drop target - deleting node", H), CoreContext.Command.deleteNode({
        nodeId: H.id
      })), wrapperEl.toggleAttribute("data-dragging", !0), log.debug("Compositor: DragEnd", fe), (be = v.current) == null || be.toggleAttribute("data-drag-target-active", !1), wrapperEl.querySelectorAll("[data-item]").forEach((ke) => {
        ke.toggleAttribute("data-drag-target-active", !1), ke.toggleAttribute("data-layout-drop-target-active", !1), ke.toggleAttribute("data-transform-drop-target-active", !1);
      }), window.__dragging = !1;
    },
    ondragover: (fe) => {
      var be;
      fe.preventDefault(), fe.stopPropagation(), !u.current && ((be = v.current) == null || be.toggleAttribute("data-transform-drop-target-active", !0));
    },
    ondragleave: (fe) => {
      var be;
      fe.preventDefault(), fe.stopPropagation(), (be = v.current) == null || be.toggleAttribute("data-transform-drop-target-active", !1);
    }
  } : {};
  useEffect(() => {
    l.current && Z && (l.current.appendChild(Z.root), Object.assign(l.current.style, {
      width: "100%",
      height: "100%",
      position: "relative",
      overflow: "hidden"
    }), Object.assign(Z.root.style, {
      pointerEvents: X ? "all" : "none",
      width: "100%",
      height: "100%",
      position: "relative",
      ...H.props.style || {}
    }));
  }, [l.current, Z]), useEffect(() => {
    const fe = X ? () => k(H) : () => {
    };
    return c.current && (Object.assign(c.current, ae), Object.assign(c.current.style, {
      pointerEvents: X ? "all" : "none"
    }), c.current.addEventListener("dblclick", fe)), () => {
      var be;
      (be = c.current) == null || be.removeEventListener("dblclick", fe);
    };
  }, [c.current]);
  const j = {
    layout: ee,
    ...H.props.layoutProps ?? {}
  };
  return /* @__PURE__ */ React.createElement("div", {
    ref: v,
    "data-id": H.id + "-x",
    "data-item": !0,
    ...X && {
      "data-drag-target": !0
    },
    ...ne && {
      "data-drop-target": !0
    },
    ...Q,
    style: {
      position: "relative",
      width: ((ue = H.props.size) == null ? void 0 : ue.x) || "100%",
      height: ((he = H.props.size) == null ? void 0 : he.y) || "100%",
      pointerEvents: "none"
    }
  }, /* @__PURE__ */ React.createElement("div", {
    className: "interactive-overlay",
    ref: c,
    style: {
      height: "100%",
      width: "100%",
      position: "absolute",
      zIndex: 2
    }
  }), /* @__PURE__ */ React.createElement("div", {
    className: "item-element",
    style: {
      display: "flex",
      flex: "0 0 auto",
      justifyContent: "center",
      width: "100%",
      height: "100%"
    }
  }, /* @__PURE__ */ React.createElement("div", {
    ref: l
  }), /* @__PURE__ */ React.createElement(ErrorBoundary, null, /* @__PURE__ */ React.createElement("ls-layout", {
    "data-id": H.id + "-x",
    props: JSON.stringify(j),
    layout: ee
  }, H.children.map((fe) => /* @__PURE__ */ React.createElement(ElementTree, {
    key: fe.id,
    nodeId: fe.id
  }))))));
}, Root = (a) => {
  const {
    project: u
  } = useContext(CompositorContext), [c, l] = useState(null);
  return useEffect(() => (l(u.compositor.renderTree()), CoreContext.onInternal("NodeChanged", () => {
    l(u.compositor.renderTree());
  })), []), useEffect(() => {
    const v = u.compositor.getRoot(), {
      x: p
    } = v.props.size, _ = () => {
      var ee, X, ne;
      const {
        bannerStyle: k = "default",
        primaryColor: O = "#ABABAB",
        showNameBanners: D
      } = u.props ?? {}, F = ((ee = u.props) == null ? void 0 : ee.logoPosition) ?? ((ne = (X = u.props) == null ? void 0 : X.logo) == null ? void 0 : ne.logoPosition) ?? "top-right";
      if (!k || !O || !F)
        return;
      const H = themes[k](O, D, p / 1920), Z = themes[F](p / 1920);
      a.setStyle(`${H} ${Z}` || "");
    };
    return _(), CoreContext.onInternal("ProjectChanged", _);
  }, [u]), c ? /* @__PURE__ */ React.createElement("div", {
    onDrop: (v) => {
      foundDropTarget = !0, v.preventDefault();
    },
    onDragOver: (v) => {
      v.preventDefault();
    },
    onDragLeave: (v) => {
      v.preventDefault();
    },
    style: {
      userSelect: "none",
      width: `${c.props.size.x + PADDING * 2}px`,
      height: `${c.props.size.y + PADDING * 2}px`,
      margin: PADDING + "px"
    }
  }, /* @__PURE__ */ React.createElement("div", {
    style: {
      width: "100%",
      height: "100%",
      overflow: "hidden"
    }
  }, /* @__PURE__ */ React.createElement(ElementTree, {
    nodeId: c.id
  }))) : null;
};
let wrapperEl, customStyleEl;
const PADDING = 0, render = (a) => {
  const {
    containerEl: u,
    projectId: c,
    dragAndDrop: l = !1,
    checkDragTarget: v = scenelessProjectDragCheck,
    checkDropTarget: p = scenelessProjectDropCheck
  } = a, _ = getProject(c);
  CoreContext.clients.LayoutApi().subscribeToLayout(_.layoutApi.layoutId), loadDragImage();
  const k = a.onElementDoubleClick ?? (() => {
  });
  if (!u || !_)
    return;
  if (!u.shadowRoot) {
    u.attachShadow({
      mode: "open"
    }), customStyleEl = document.createElement("style");
    const X = document.createElement("style");
    X.textContent = getStyle(), wrapperEl = document.createElement("div"), wrapperEl.id = "compositor-root", Object.assign(wrapperEl.style, {
      width: "100%",
      height: "100%",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      transformOrigin: "center"
    }), u.shadowRoot.appendChild(X), u.shadowRoot.appendChild(customStyleEl), u.shadowRoot.appendChild(wrapperEl), new ResizeObserver((Q) => {
      H();
    }).observe(u);
  }
  const O = _.compositor.getRoot(), {
    x: D,
    y: F
  } = O.props.size, H = () => {
    let {
      width: X,
      height: ne
    } = u.getBoundingClientRect();
    const Q = X / ne, ae = D / F;
    let j;
    X && ne ? ae > Q ? j = X / (D + PADDING * 2) : j = ne / (F + PADDING * 2) : j = 1, wrapperEl.style.willChange = "transform", wrapperEl.style.transform = `scale(${j}) translateZ(0)`, window.__scale = j, ee();
  }, Z = createRoot(wrapperEl), ee = () => {
    Z.render(/* @__PURE__ */ React.createElement(CompositorProvider, {
      project: _,
      interactive: l,
      onElementDoubleClick: k,
      checkIsDropTarget: p,
      checkIsDragTarget: v
    }, /* @__PURE__ */ React.createElement(Root, {
      setStyle: (X) => {
        customStyleEl.textContent = X;
      }
    })));
  };
  H();
}, scenelessProjectDragCheck = (a) => a.props.name === "Participant" || a.props.sourceType === "RoomParticipant" || a.props.sourceType === "RTMP", scenelessProjectDropCheck = (a) => a.props.name === "Content", CompositorContext = React.createContext({
  interactive: !1,
  project: null,
  checkIsDragTarget: () => !1,
  checkIsDropTarget: () => !1,
  onElementDoubleClick: () => {
  }
}), CompositorProvider = ({
  children: a,
  ...u
}) => /* @__PURE__ */ React.createElement(CompositorContext.Provider, {
  value: {
    ...u
  }
}, a), getStyle = () => `
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  font-family: 'Arial';
}

video {
  width: 100%;
  height: 100%;
  object-fit: contain;
}

.NameBanner {
  top: 100%;
  transform: translateY(-100%);
  left: 0;
  height: 30px;
  background: linear-gradient(90deg, rgba(0, 0, 0, 0.5) 50%, rgba(0, 0, 0, 0) 100%);
  padding: 0px 0px 0px 10px;
  color: rgba(255, 255, 255, 0.9);
  font-weight: bold;
  line-height: 30px;
  width: 100%;
  font-size: 28px;
  position: absolute;
}

ls-layout[layout="Presentation"][props*="\\"cover\\"\\:true"] > :first-child .NameBanner {
  top: 0% !important;
  transform: translateY(0%) !important;
}

[layout="Layered"] > [data-item] {
  transform: scale(1.003) !important;
}
[layout="Layered"] > [data-item]:nth-child(2) {
  transform: scale(1.0015) !important;
}
[layout="Layered"] > [data-item]:nth-child(1) {
  transform: scale(1) !important;
}

.logo {
  position: absolute !important;
}

#compositor-root[data-dragging] {}

[data-drag-target] {}
[data-drag-target]:hover > .interactive-overlay {
  box-shadow: 0 0 0 3px inset rgba(255, 255, 255, 0.5);
  cursor: grab;
}
[data-drop-target] {}
[data-drop-target]:hover {}
[data-drag-target][data-drag-target-active] > .interactive-overlay {
  box-shadow: 0 0 0 3px inset rgba(255, 255, 255, 0.2);
}
[data-drag-target][data-drag-target-active] > .item-element {
  opacity: 0.8;
}
[data-layout-drop-target-active] > .interactive-overlay {
  box-shadow: 0 0 0 3px inset yellow;
}
[data-transform-drop-target-active] > .interactive-overlay {
  box-shadow: 0 0 0 3px inset white;
}
`;
var BannerStyle = /* @__PURE__ */ ((a) => (a.DEFAULT = "default", a.MINIMAL = "minimal", a.BUBBLE = "bubble", a))(BannerStyle || {});
const themes = {
  "top-left": (a = 1280 / 1920) => `
      .wrapper {
       top:0;
       left:0;
    }`,
  "top-right": (a = 1280 / 1920) => `
      .wrapper {
       top:0;
       right:0;
    }`,
  "bottom-left": (a = 1280 / 1920) => `
      .wrapper {
       bottom:0;
       left:0;
    }`,
  "bottom-right": (a = 1280 / 1920) => `
      .wrapper {
       bottom:0;
       right:0;
    }`,
  default: (a = "#ABABAB", u = !0, c = 1280 / 1920) => {
    const l = color(a).lightness() < 0.6 ? "#FFF" : "#000", v = color(a).lightness() < 0.6 ? "#FFF" : "#000", p = color(a).lightness() < 0.6 ? "#000" : "#FFF", _ = (k) => k * c + "px";
    return `
      .ChatOverlay {
        background: ${a} !important;
        margin-bottom: ${_(40)} !important;
        transition: 300ms ease all;
        left: 0;

        /* Default Size 4 */
        font-size: ${_(44)} !important;
        padding: ${_(40)} ${_(100)} !important;
        border-radius: ${_(20)} !important;
      }
      
      .ChatOverlay-badge-icon {
          width:${_(32)};
          height: ${_(32)};
          fill: currentcolor;
          color: ${p};
      }

       .ChatOverlay-badge-container {
          background-color:${v};
          display:flex;
          flex-direction:row;
          padding: ${_(6)} ${_(12)} ${_(6)} ${_(6)};
          border-radius: ${_(10)};
          align-items: center;
          border-bottom-left-radius: 0px !important;
          position: relative;
          border: none;
          cursor: pointer;
       }
      
       .ChatOverlay-badge-username {
          color:${p};
          padding:${_(6)};
          font-size:${_(18)};
          font-weight:700;
          text-transform: capitalize; 
       }
       
       .ChatOverlay-badge-container::before {
          content:"";
          width:15px;
          height:15px;
          background-color:${v};
          position: absolute;
          bottom:-14px;
          left:0;
          clip-path:polygon(0 100%, 12% 87%, 26% 73%, 45% 53%, 59% 40%, 71% 28%, 85% 14%, 100% 0, 0 0);
        }
       

       .ChatOverlay-avatar {
          height: ${_(120)};
          width: ${_(120)};
          left:0;
          right:0;
          top:0;
          bottom:0;
          border-radius:50%;
       }

      .Banner, .NameBanner, .ChatOverlay {
        background: ${a} !important;
        margin-bottom: ${_(40)} !important;
        transition: 300ms ease all;
        left: 0;

        /* Default Size 4 */
        font-size: ${_(44)} !important;
        padding: ${_(40)} ${_(100)} !important;
        border-top-right-radius: ${_(20)} !important;
        border-bottom-right-radius: ${_(20)} !important;
      }

      .Banner-body, .NameBanner-body, .ChatOverlay-body {
        color: ${l} !important;
        font-family: 'Roboto' !important;
        font-style: normal !important;
        font-weight: 700 !important;
        line-height: 120% !important;
      }

      .NameBanner {
        transform-origin: 0 100%;
        margin: 0 !important;
        transform: translateX(-100%);
        opacity: 0 !important;
        white-space: nowrap;
        ${u && `
          opacity: 1 !important;
          transform: translateX(0);
        `}
      }

      .NameBanner[data-size="4"] {
        padding: ${_(40)} ${_(100)} !important;
        font-size: ${_(44)} !important;
        border-top-right-radius: ${_(20)} !important;
        border-bottom-right-radius: ${_(20)} !important;
      }
      .NameBanner[data-size="3"] {
        padding: ${_(12)} ${_(30)} !important;
        font-size: ${_(44)} !important;
        border-top-right-radius: ${_(20)} !important;
        border-bottom-right-radius: ${_(20)} !important;
      }
      .NameBanner[data-size="2"] {
        padding: ${_(12)} ${_(20)} !important;
        font-size: ${_(28)} !important;
        border-top-right-radius: ${_(16)} !important;
        border-bottom-right-radius: ${_(16)} !important;
      }
      .NameBanner[data-size="1"], .NameBanner[data-size="0"] {
        padding: ${_(8)} ${_(8)} !important;
        font-size: ${_(20)} !important;
        border-top-right-radius: ${_(8)} !important;
        border-bottom-right-radius: ${_(8)} !important;
      }
      .NameBanner[data-size="0"] {
        opacity: 0;
        transform: translateX(-100%);
      }
    `;
  },
  minimal: (a = "#ABABAB", u = !0, c = 1280 / 1920) => {
    const l = "white", v = "#fff", p = "#000", _ = (k) => k * c + "px";
    return `

      .ChatOverlay-badge-icon {
          width:${_(32)};
          height: ${_(32)};
          fill: currentcolor;
          color: ${p};
      }

       .ChatOverlay-badge-container {
          background-color:${v};
          display:flex;
          flex-direction:row;
          padding: ${_(6)} ${_(12)} ${_(6)} ${_(6)};
          align-items: center;
          position: relative;
          border: none;
          cursor: pointer;
       }

       .ChatOverlay-badge-username {
          color:${p};
          padding:${_(6)};
          font-size:${_(18)};
          font-weight:700;
          text-transform: capitalize; 
       }

       .ChatOverlay-avatar {
          height: ${_(120)};
          width: ${_(120)};
          left:0;
          right:0;
          top:0;
          bottom:0;
          border-radius:50%;
       }


    .Banner, .NameBanner, .ChatOverlay {
        background: ${color(a).fade(color(a).alpha() * 0.7).toString()} !important;
        padding: ${_(40)} ${_(40)} ${_(40)} ${_(60)} !important;
        position: relative !important;
        margin-bottom: ${_(40)} !important;
        transition: 300ms ease all;
        font-size: ${_(34)} !important;
        left: 0;
      }

      .Banner:before, .NameBanner:before, .ChatOverlay:before {
        z-index: 1;
        content: "";
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.6);
        transition: 300ms ease all;
        opacity: ${color(a).alpha()};
      }
      .Banner:after, .NameBanner:after, .ChatOverlay:after {
        z-index: 1;
        content: "";
        position: absolute;
        left: 0;
        top: 0;
        height: 100%;
        transition: 300ms ease all;
        width: ${_(20)};
        background: ${color(a)};
        opacity: ${color(a).alpha()};
      }
      .Banner-body, .NameBanner-body, .ChatOverlay-body {
        color: ${l} !important;
        font-family: 'Roboto' !important;
        font-style: normal !important;
        font-weight: 700 !important;
        line-height: 120% !important;
        position: relative;
        z-index: 2;
      }
      .Banner-header {
        font-size: ${_(90)};
        position: relative;
        z-index: 2;
      }
      .NameBanner {
        transform-origin: 0 100%;
        margin: 0 !important;
        transform: translateX(-100%);
        opacity: 0 !important;
        white-space: nowrap;
        ${u && `
          opacity: 1 !important;
          transform: translateX(0);
        `}
      }

      .NameBanner[data-size="4"] {
        padding: ${_(40)} ${_(40)} ${_(40)} ${_(60)} !important;
        font-size: ${_(34)} !important;
      }
      .NameBanner[data-size="3"] {
        padding: ${_(16)} ${_(40)} ${_(16)} ${_(60)} !important;
        font-size: ${_(34)} !important;
      }
      .NameBanner[data-size="2"] {
        padding: ${_(12)} ${_(24)} ${_(12)} ${_(44)} !important;
        font-size: ${_(24)} !important;
      }
      .NameBanner[data-size="1"], .NameBanner[data-size="0"] {
        padding: ${_(12)} ${_(16)} ${_(12)} ${_(36)} !important;
        font-size: ${_(18)} !important;
      }
      .NameBanner[data-size="0"] {
        opacity: 0 !important;
        transform: translateX(-100%);
      }
    `;
  },
  bubble: (a = "#ABABAB", u = !0, c = 1280 / 1920) => {
    const l = color(a).lightness() < 0.6 ? "#FFF" : "#000", v = color(a).lightness() < 0.6 ? "#FFF" : "#000", p = color(a).lightness() < 0.6 ? "#000" : "#FFF", _ = (k) => k * c + "px";
    return `
      .ChatOverlay-badge-icon {
          width:${_(32)};
          height: ${_(32)};
          fill: currentcolor;
          color: ${p};
      }


       .ChatOverlay-badge-container {
          background-color:${v};
          display:flex;
          flex-direction:row;
          padding: ${_(6)} ${_(12)} ${_(6)} ${_(6)};
          align-items: center;
          z-index: 1;
          border: none;
          cursor: pointer;
          top: 0;
          margin-bottom: 2px;
          margin-left: -${_(30)};
          border-radius: 30px;
       }

       .ChatOverlay-badge-username {
          color:${p};
          padding:${_(6)};
          font-size:${_(18)};
          font-weight:700;
          text-transform: capitalize; 
       }

       .ChatOverlayAvatar-container {
          height: ${_(120)};
          width: ${_(120)};
          top: 0;
       }
       .ChatOverlay-avatar {
          height: ${_(120)};
          width: ${_(120)};
          left:0;
          right:0;
          top:0;
          bottom:0;
          border-radius:50%;
       }


      .Banner, .ChatOverlay {
        transform: translateX(-50%);
        left: 50%;
        margin-bottom: ${_(40)} !important;
      }

      .Banner, .NameBanner, .ChatOverlay {
        background: ${color(a)} !important;
        color: ${l} !important;
        border-radius: 500px !important;
        transition: 300ms ease all;

        /* Default Style */
        border: 4px solid ${l} !important;
        padding: ${_(40)} ${_(80)} !important;
        font-size: ${_(40)} !important;
      }
      .Banner-body, .NameBanner-body, .ChatOverlay-body {
        color: ${l} !important;
        text-align: center !important;
        font-family: 'Roboto' !important;
        font-style: normal !important;
        font-weight: 700 !important;
        line-height: 120% !important;
      }
      .NameBanner {
        transform-origin: 0% 100%;
        transform: translateX(-100%);
        opacity: 0 !important;
        white-space: nowrap;
        ${u && `
          opacity: 1 !important;
          transform: translateX(0);
        `}
      }

      ls-layout[layout="Presentation"][props*="\\"cover\\"\\:true"] > :first-child .NameBanner {
        top: 0% !important;
        transform: translateY(0%) !important;
        margin: ${_(20)} ${_(20)};
      }


      .NameBanner[data-size="4"] {
        padding: ${_(40)} ${_(80)} ${_(40)} ${_(80)} !important;
        font-size: ${_(40)} !important;
      }
      .NameBanner[data-size="3"] {
        padding: ${_(12)} ${_(30)} ${_(12)} ${_(30)} !important;
        font-size: ${_(40)} !important;
        margin: -${_(20)} ${_(20)};
      }
      .NameBanner[data-size="2"] {
        padding: ${_(12)} ${_(30)} ${_(12)} ${_(30)} !important;
        font-size: ${_(26)} !important;
        margin: -${_(8)} ${_(8)};
      }
      .NameBanner[data-size="1"], .NameBanner[data-size="0"] {
        padding: ${_(8)} ${_(16)} ${_(8)} ${_(16)} !important;
        font-size: ${_(18)} !important;
        border-width: ${_(2)} !important;
        margin: -${_(16)} ${_(8)};
      }
      .NameBanner[data-size="0"] {
        opacity: 0 !important;
        transform: translateX(-100%);
      }
    `;
  }
}, iconStyles = {
  twitch: {
    icon: "Twitch"
  },
  youtube: {
    icon: "YouTube"
  },
  facebook: {
    icon: "Facebook"
  }
}, fixLink = (a) => !a.startsWith("http:") && !a.startsWith("https:") ? `https://${a}` : a, ChatOverlay = {
  name: "LS-ChatOverlay",
  sourceType: "ChatOverlay",
  create({
    onUpdate: a,
    onEvent: u
  }, c) {
    const l = document.createElement("div"), v = getProject(CoreContext.state.activeProjectId), p = v.compositor.getRoot(), {
      x: _
    } = p.props.size, k = (_ ?? 1280) / 1920, O = (Q) => Q * k + "px";
    let D;
    const F = (Q, ae) => {
      const j = Q.width / ae.width;
      return Q.height / ae.height >= 0.25 && j >= 0.75 ? 4 : j >= 0.75 ? 1 : j >= 0.5 ? -2 : j > 0.25 ? -3 : -4;
    };
    CoreContext.onInternal("ProjectChanged", () => {
      const {
        bannerStyle: Q
      } = v.props ?? {};
      Q && ne({
        ...D,
        metadata: {
          ...D.metadata,
          bannerStyle: Q
        }
      });
    });
    const H = React.memo((Q) => {
      var ae, j, ue;
      return (Q == null ? void 0 : Q.type) === "emoticon" && ((ae = Q == null ? void 0 : Q.data) == null ? void 0 : ae.type) === "direct" ? /* @__PURE__ */ React.createElement("img", {
        src: (j = Q == null ? void 0 : Q.data) == null ? void 0 : j.url,
        style: {
          height: O(36)
        },
        alt: Q == null ? void 0 : Q.text
      }) : (Q == null ? void 0 : Q.type) === "link" ? /* @__PURE__ */ React.createElement("a", {
        style: {
          color: "#FFF",
          wordBreak: "break-all"
        },
        target: "_blank",
        rel: "noreferrer",
        href: fixLink((ue = Q == null ? void 0 : Q.data) == null ? void 0 : ue.url)
      }, Q == null ? void 0 : Q.text) : /* @__PURE__ */ React.createElement("span", null, Q == null ? void 0 : Q.text);
    }), Z = (Q) => {
      const ae = {
        height: `${Q.height}`,
        width: `${Q.width}`,
        background: Q.background || "transparent",
        display: "inline-block",
        verticalAlign: "middle",
        borderRadius: "50%",
        fontSize: `${Q.fontSize}`
      };
      return /* @__PURE__ */ React.createElement("div", {
        style: {
          ...ae,
          position: "relative",
          marginRight: Q == null ? void 0 : Q.marginRight
        }
      }, /* @__PURE__ */ React.createElement("div", {
        style: {
          left: "50%",
          position: "absolute",
          top: "50%",
          transform: "translate(-50%, -50%)"
        }
      }, Q.username.substring(0, 2).toUpperCase()));
    }, ee = (Q) => {
      const {
        message: ae,
        id: j,
        username: ue,
        metadata: he
      } = Q || {}, [fe, be] = useState(0), {
        index: ke,
        platform: Te,
        avatar: q,
        bannerStyle: z
      } = he || {}, P = useMemo(() => iconStyles[Te], [Te]), S = useRef();
      return useLayoutEffect(() => {
        if (!S.current)
          return;
        const E = () => {
          const M = S.current;
          M && be(F({
            width: M.clientWidth,
            height: M.clientHeight
          }, {
            width: v.compositor.getRoot().props.size.x,
            height: v.compositor.getRoot().props.size.y
          }));
        }, I = new ResizeObserver((M) => {
          E();
        });
        return E(), I.observe(S.current), () => {
          S != null && S.current && I.unobserve(S == null ? void 0 : S.current);
        };
      }, [S.current, v]), /* @__PURE__ */ React.createElement(APIKitAnimation$1, {
        id: `${j}_${ke}`,
        type: "chatoverlay",
        enter: APIKitAnimationTypes.SLIDE_IN_LEFT,
        exit: APIKitAnimationTypes.SLIDE_OUT_LEFT,
        duration: 200
      }, /* @__PURE__ */ React.createElement("div", {
        className: "ChatOverlayContainer",
        style: {
          position: "absolute",
          top: 0,
          left: 0,
          width: "100%",
          height: "100%",
          display: "flex",
          flexDirection: "row",
          justifyContent: "flex-start",
          alignItems: "flex-end",
          marginLeft: z !== BannerStyle.BUBBLE ? "5%" : "0px"
        }
      }, z !== BannerStyle.BUBBLE ? (
        /* It's a ternary operator. If the style is not equal to BannerStyle.BUBBLE.toString(), then it will
        render the first div. Otherwise, it will render the second div. */
        /* @__PURE__ */ React.createElement("div", {
          style: {
            width: "100%",
            display: "flex"
          }
        }, q ? /* @__PURE__ */ React.createElement("span", {
          style: {
            marginRight: "20px"
          }
        }, /* @__PURE__ */ React.createElement("img", {
          src: q,
          className: "ChatOverlay-avatar"
        })) : /* @__PURE__ */ React.createElement(Z, {
          height: O(110),
          width: O(120),
          background: primary(500),
          username: ue,
          marginRight: 20,
          fontSize: O(30)
        }), /* @__PURE__ */ React.createElement("div", {
          style: {
            width: "100%"
          }
        }, ue && /* @__PURE__ */ React.createElement("button", {
          className: "ChatOverlay-badge-container"
        }, (P == null ? void 0 : P.icon) && /* @__PURE__ */ React.createElement(Icon$1, {
          className: "ChatOverlay-badge-icon",
          name: P == null ? void 0 : P.icon
        }), /* @__PURE__ */ React.createElement("div", {
          className: "ChatOverlay-badge-username"
        }, ue)), /* @__PURE__ */ React.createElement("div", {
          className: "ChatOverlay",
          style: {
            padding: 10,
            background: "orange",
            width: "fit-content",
            height: "fit-content",
            maxWidth: "84%",
            position: "relative"
          }
        }, ae && /* @__PURE__ */ React.createElement("div", {
          className: "ChatOverlay-body",
          style: {
            gap: 10,
            display: "flex",
            alignItems: "center",
            flexWrap: "wrap",
            verticalAlign: "middle"
          }
        }, ae.map((E, I) => /* @__PURE__ */ React.createElement(H, {
          key: I,
          ...E
        }))))))
      ) : (
        /* It's a ternary operator. If the style is not equal to BannerStyle.BUBBLE.toString(), then it will
        render the first div. Otherwise, it will render the second div. */
        /* @__PURE__ */ React.createElement("div", {
          style: {
            width: "100%",
            display: "flex"
          }
        }, /* @__PURE__ */ React.createElement("div", {
          className: "ChatOverlay",
          style: {
            padding: 10,
            background: "orange",
            width: "fit-content",
            height: "fit-content",
            maxWidth: "84%",
            position: "relative"
          }
        }, /* @__PURE__ */ React.createElement("div", {
          style: {
            display: "flex",
            marginTop: `-${O(160)}`,
            alignItems: "flex-end",
            padding: `${O(14)} ${O(0)} ${O(14)} ${O(0)}`,
            marginLeft: `${fe * 10}px`
          }
        }, q ? /* @__PURE__ */ React.createElement("div", {
          className: "ChatOverlayAvatar-container"
        }, /* @__PURE__ */ React.createElement("img", {
          src: q,
          className: "ChatOverlay-avatar"
        })) : /* @__PURE__ */ React.createElement("div", {
          className: "ChatOverlayAvatar-container"
        }, /* @__PURE__ */ React.createElement(Z, {
          height: O(120),
          width: O(120),
          background: primary(500),
          username: ue,
          fontSize: O(30)
        })), ue && /* @__PURE__ */ React.createElement("button", {
          className: "ChatOverlay-badge-container"
        }, (P == null ? void 0 : P.icon) && /* @__PURE__ */ React.createElement(Icon$1, {
          className: "ChatOverlay-badge-icon",
          name: P == null ? void 0 : P.icon
        }), /* @__PURE__ */ React.createElement("div", {
          className: "ChatOverlay-badge-username"
        }, ue))), ae && /* @__PURE__ */ React.createElement("div", {
          ref: S,
          className: "ChatOverlay-body",
          style: {
            gap: 10,
            alignItems: "center",
            flexWrap: "wrap",
            verticalAlign: "middle"
          }
        }, ae.map((E, I) => /* @__PURE__ */ React.createElement(H, {
          key: I,
          ...E
        })))))
      )));
    }, X = createRoot(l), ne = (Q) => X.render(/* @__PURE__ */ React.createElement(ee, {
      ...Q
    }));
    return a((Q) => {
      const {
        bannerStyle: ae = BannerStyle.DEFAULT
      } = v.props ?? {};
      D = {
        ...Q,
        metadata: {
          ...Q.metadata,
          bannerStyle: ae
        }
      }, ne(D);
    }), {
      root: l
    };
  }
}, Element$1 = {
  name: "Element",
  sourceType: "Element",
  create({
    onUpdate: a
  }, {
    tagName: u = "div"
  }) {
    const c = document.createElement(u);
    return a(({
      tagName: l,
      attributes: v = {},
      fields: p = {}
    }) => {
      l === "img" ? (c == null ? void 0 : c.src) !== v.src && Object.keys(v).forEach((_) => {
        c.setAttribute(_, v[_]);
      }) : Object.keys(v).forEach((_) => {
        c.setAttribute(_, v[_]);
      }), Object.keys(p).forEach((_) => {
        try {
          typeof c[_] == "object" ? Object.assign(c[_], p[_]) : c[_] = p[_];
        } catch {
          log.warn("Cannot assign field to element", {
            field: _
          });
        }
      });
    }), {
      root: c
    };
  }
}, GameSource = {
  name: "LS-Game-Source",
  sourceType: "Game",
  props: {},
  useSource(a, u) {
    return a.find((c) => isMatch(c.props, u.sourceProps));
  },
  create({
    onUpdate: a,
    onNewSource: u,
    onRemove: c
  }, l) {
    const v = document.createElement("div"), p = getProject(CoreContext.state.activeProjectId);
    Object.assign(v.style, {
      position: "relative"
    });
    let _, k = l;
    const O = (Z, ee) => {
      const X = Z / ee.width;
      return X >= 0.5 ? 3 : X > 0.25 ? 2 : X > 0.15 ? 1 : 0;
    }, D = ({
      props: Z,
      source: ee
    }) => {
      var fe;
      const X = useRef(), {
        volume: ne = 1,
        isHidden: Q = !1
      } = Z || {}, [ae, j] = useState(0), ue = Z == null ? void 0 : Z.isMuted, he = !(Z != null && Z.isHidden) && ((fe = ee == null ? void 0 : ee.props) == null ? void 0 : fe.videoEnabled);
      return useEffect(() => {
        X.current && (X.current.play().catch((be) => {
          document.addEventListener("click", () => {
            var ke;
            return (ke = X.current) == null ? void 0 : ke.play();
          }, {
            once: !0
          });
        }), ee != null && ee.value && (ee == null ? void 0 : ee.value) !== X.current.srcObject ? X.current.srcObject = ee == null ? void 0 : ee.value : ee != null && ee.value || (X.current.srcObject = null));
      }, [X.current, ee == null ? void 0 : ee.value]), useEffect(() => {
        !Z && X.current && (X.current.srcObject = null, X.current = null);
      }, [Z]), useLayoutEffect(() => {
        if (!X.current)
          return;
        const be = () => {
          const Te = X.current;
          Te && j(O(Te.clientWidth, {
            width: p.compositor.getRoot().props.size.x,
            height: p.compositor.getRoot().props.size.y
          }));
        }, ke = new ResizeObserver((Te) => {
          be();
        });
        return be(), ke == null || ke.observe(X.current), () => {
          X.current && (ke == null || ke.unobserve(X.current), X.current.srcObject = null);
        };
      }, [X.current, p]), useEffect(() => {
        X.current && (X.current.volume = ne);
      }, [X.current, ne]), /* @__PURE__ */ React.createElement("div", {
        style: {
          position: "relative",
          display: "flex",
          height: "100%",
          width: "100%"
        }
      }, /* @__PURE__ */ React.createElement("div", {
        style: {
          background: "#222",
          position: "absolute",
          height: "100%",
          width: "100%",
          fontSize: "43px",
          color: "rgba(255,255,255,0.6)",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          opacity: he ? "0" : "1"
        }
      }, !!ee && /* @__PURE__ */ React.createElement("div", {
        style: {
          borderRadius: "50%",
          background: "#555",
          width: "70px",
          height: "70px",
          textTransform: "uppercase",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          lineHeight: "1em"
        }
      }, "Game Source")), /* @__PURE__ */ React.createElement("div", {
        style: {
          position: "relative",
          display: "flex",
          height: "100%",
          width: "100%"
        }
      }, /* @__PURE__ */ React.createElement("video", {
        ref: X,
        autoPlay: !0,
        muted: ue,
        disablePictureInPicture: !0,
        playsInline: !0,
        style: {
          left: "50%",
          top: "50%",
          position: "relative",
          transform: "translate3d(-50%, -50%, 0)",
          height: "100%",
          opacity: he ? "1" : "0",
          objectFit: "cover",
          background: "rgba(0,0,0,0.6)"
        }
      })), !!(ee != null && ee.props.displayName) && /* @__PURE__ */ React.createElement("div", {
        className: "NameBannerContainer",
        style: {
          width: "100%",
          height: "100%",
          position: "absolute"
        }
      }, /* @__PURE__ */ React.createElement("div", {
        className: "NameBanner",
        "data-size": ae,
        style: {
          padding: "12px 30px",
          width: "fit-content",
          height: "fit-content",
          top: "100%",
          transform: "translateY(-100%)",
          left: 0
        }
      }, /* @__PURE__ */ React.createElement("div", {
        className: "NameBanner-body"
      }, ee == null ? void 0 : ee.props.displayName))));
    }, F = createRoot(v), H = () => F.render(/* @__PURE__ */ React.createElement(D, {
      source: _,
      props: k
    }));
    return a((Z) => {
      k = Z, H();
    }), u((Z) => {
      _ = Z, H();
    }), c((Z) => {
      k = Z, H();
    }), {
      root: v
    };
  }
}, Logo = {
  name: "LS-Logo",
  sourceType: "Logo",
  create({
    onUpdate: a
  }, {
    sourceProps: u
  }) {
    const c = document.createElement("div"), v = getProject(CoreContext.state.activeProjectId).compositor.getRoot(), {
      x: p
    } = v.props.size, _ = (p ?? 1280) / 1920, k = (H) => H * _ + "px", O = ({
      source: H
    }) => {
      var fe;
      const {
        src: Z,
        meta: ee
      } = (H == null ? void 0 : H.sourceProps) || {}, {
        id: X
      } = H || {}, [ne, Q] = React.useState(!1);
      useEffect(() => {
        Q(!1);
      }, [X]);
      const {
        offsetX: ae = 40,
        offsetY: j = 40,
        height: ue = 135,
        width: he = 240
      } = (ee == null ? void 0 : ee.style) || {};
      return /* @__PURE__ */ React.createElement(APIKitAnimation$1, {
        type: "logo",
        id: X,
        enter: APIKitAnimationTypes.FADE_IN,
        exit: APIKitAnimationTypes.FADE_OUT,
        duration: 400
      }, /* @__PURE__ */ React.createElement("div", {
        style: {
          opacity: ne ? 1 : 0,
          width: "100%",
          height: "100%"
        },
        className: "logo-transition"
      }, Z && /* @__PURE__ */ React.createElement("div", {
        className: "logo wrapper",
        style: {
          padding: `${k(j)} ${k(ae)}`
        }
      }, /* @__PURE__ */ React.createElement("img", {
        style: {
          height: "100%",
          width: "100%",
          maxHeight: ue ? k(ue) : "none",
          maxWidth: he ? k(he) : "none",
          ...(fe = u == null ? void 0 : u.meta) == null ? void 0 : fe.style,
          ...ee == null ? void 0 : ee.style
        },
        src: Z,
        onLoad: () => Q(!0)
      }))));
    }, D = createRoot(c), F = (H) => D.render(/* @__PURE__ */ React.createElement(O, {
      source: H
    }));
    return a((H) => {
      F({
        ...H
      });
    }), {
      root: c
    };
  }
}, Iframe = ({
  url: a,
  allowFullScreen: u,
  position: c,
  display: l,
  height: v,
  width: p,
  overflow: _,
  styles: k,
  onLoad: O,
  id: D,
  frameBorder: F,
  className: H,
  name: Z,
  target: ee,
  iframeRef: X,
  children: ne,
  src: Q
}) => {
  const ae = Object.assign({
    src: Q || a,
    target: ee || null,
    style: {
      position: c || null,
      display: l || "block",
      overflow: _ || null,
      ...k
    },
    name: Z || null,
    className: H || null,
    id: D || null,
    onLoad: O || null,
    height: v || "100%",
    width: p || "100%",
    allow: "autoplay"
  });
  let j = /* @__PURE__ */ Object.create(null);
  for (let ue of Object.keys(ae))
    ae[ue] != null && (j[ue] = ae[ue]);
  for (let ue of Object.keys(j.style))
    j.style[ue] == null && delete j.style[ue];
  if (u)
    if ("allow" in j) {
      const ue = j.allow.replace("fullscreen", "");
      j.allow = `fullscreen ${ue.trim()}`.trim();
    } else
      j.allow = "fullscreen";
  return F >= 0 && (j.style.hasOwnProperty("border") || (j.style.border = F)), /* @__PURE__ */ React.createElement(React.Fragment, null, ne ? /* @__PURE__ */ React.createElement("iframe", {
    ref: X,
    ...j
  }, ne) : /* @__PURE__ */ React.createElement("iframe", {
    ref: X,
    ...j
  }));
}, Iframe$1 = Iframe, Overlay = {
  name: "LS-Overlay",
  sourceType: "Overlay",
  create({
    onUpdate: a,
    onRemove: u
  }, {
    sourceProps: c
  }) {
    u(() => {
      clearInterval(p);
    });
    const l = document.createElement("div"), v = getProject(CoreContext.state.activeProjectId).role;
    let p;
    const _ = ({
      source: Z,
      setStartAnimation: ee
    }) => {
      const {
        src: X,
        meta: ne,
        height: Q,
        width: ae
      } = (Z == null ? void 0 : Z.sourceProps) || {}, j = React.useRef(null);
      useEffect(() => {
        j.current && (j.current.style.removeProperty("transformOrigin"), j.current.style.removeProperty("transform"));
      }, [X]);
      const ue = () => {
        if (j.current) {
          const fe = getProject(CoreContext.state.activeProjectId).compositor.getRoot(), {
            x: be,
            y: ke
          } = fe.props.size;
          let Te = j.current.clientWidth, q = j.current.clientHeight, z;
          Te && q ? z = Math.min(be / Te, ke / q) : z = 1, j.current.style.willChange = "transform", j.current.style.transformOrigin = "0 0", j.current.style.transform = `scale(${z}) translateZ(0)`, ee(!0);
        }
      };
      return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Iframe$1, {
        key: Z.id,
        url: X,
        frameBorder: 0,
        iframeRef: j,
        height: Q,
        width: ae,
        onLoad: ue,
        styles: {
          ...ne == null ? void 0 : ne.style
        }
      }));
    }, k = ({
      source: Z,
      setStartAnimation: ee
    }) => {
      var z;
      const {
        src: X,
        type: ne,
        meta: Q,
        loop: ae
      } = (Z == null ? void 0 : Z.sourceProps) || {}, {
        id: j,
        sourceType: ue
      } = Z || {}, [he, fe] = React.useState(null), be = React.useRef(null);
      console.log("Updated current time", (z = be == null ? void 0 : be.current) == null ? void 0 : z.currentTime);
      const ke = React.useCallback((P) => {
        be.current = P, fe(P ? P.id : null);
      }, []), Te = React.useCallback(() => {
        be != null && be.current && be.current.play().catch(() => {
          var P;
          be.current.muted = !0, (P = be.current) == null || P.play();
        });
      }, [X]), q = React.useCallback(() => {
        p && clearInterval(p), hasPermission(v, Permission.UpdateProject) && trigger$1("VideoEnded", {
          id: j,
          category: ne
        });
      }, [X]);
      return React.useEffect(() => {
        Q && (be != null && be.current) && he && hasPermission(v, Permission.ManageSelf) && Q != null && Q.time && (be.current.currentTime = Number(Q == null ? void 0 : Q.time));
      }, [Q == null ? void 0 : Q.time, he]), React.useEffect(() => () => {
        p && clearInterval(p);
      }, [j]), React.useEffect(() => {
        he ? be.current && (be.current.src = X, be.current.play().catch(() => {
          be.current.muted = !0, be.current.play();
        }), hasPermission(v, Permission.UpdateProject) && (p = setInterval(() => {
          if (be.current.duration) {
            const P = be.current.duration - be.current.currentTime;
            trigger$1("VideoTimeUpdate", {
              category: ue,
              id: j,
              time: Math.floor(P)
            });
          }
        }, 1e3))) : p && clearInterval(p);
      }, [he]), /* @__PURE__ */ React.createElement(React.Fragment, {
        key: j
      }, X && /* @__PURE__ */ React.createElement("video", {
        loop: ae,
        id: j,
        ref: ke,
        style: {
          ...c.meta.style,
          ...Q.style
        },
        onLoadedData: Te,
        onEnded: q,
        onCanPlay: () => ee(!0)
      }));
    }, O = ({
      source: Z,
      setStartAnimation: ee
    }) => {
      const {
        src: X,
        meta: ne
      } = (Z == null ? void 0 : Z.sourceProps) || {}, {
        id: Q
      } = Z || {};
      return /* @__PURE__ */ React.createElement(React.Fragment, {
        key: Q
      }, X && /* @__PURE__ */ React.createElement("img", {
        style: {
          ...c.meta.style,
          ...ne.style
        },
        src: X,
        onLoad: () => ee(!0)
      }));
    }, D = ({
      source: Z
    }) => {
      const {
        type: ee
      } = (Z == null ? void 0 : Z.sourceProps) || {}, {
        id: X
      } = Z || {}, [ne, Q] = React.useState(!1);
      return useEffect(() => {
        Q(!1);
      }, [X]), /* @__PURE__ */ React.createElement(APIKitAnimation$1, {
        id: X,
        type: "overlay",
        enter: APIKitAnimationTypes.FADE_IN,
        exit: APIKitAnimationTypes.FADE_OUT,
        duration: 400
      }, /* @__PURE__ */ React.createElement("div", {
        style: {
          opacity: ne ? 1 : 0
        },
        className: "overlayContainer overlay-transition"
      }, X && ee === "image" && /* @__PURE__ */ React.createElement(O, {
        source: Z,
        setStartAnimation: Q
      }), X && ee === "video" && /* @__PURE__ */ React.createElement(k, {
        source: Z,
        setStartAnimation: Q
      }), X && ee === "custom" && /* @__PURE__ */ React.createElement(_, {
        source: Z,
        setStartAnimation: Q
      })));
    }, F = createRoot(l), H = (Z) => F.render(/* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(D, {
      source: Z
    })));
    return a((Z) => {
      H({
        ...Z
      });
    }), {
      root: l
    };
  }
}, RTMPSource = {
  name: "LS-RTMP-Source",
  sourceType: "RTMP",
  props: {},
  useSource(a, u) {
    return a.find((c) => isMatch(c.props, u.sourceProps));
  },
  create({
    onUpdate: a,
    onNewSource: u,
    onRemove: c
  }, l) {
    const v = document.createElement("div"), p = getProject(CoreContext.state.activeProjectId);
    getProjectRoom(CoreContext.state.activeProjectId), Object.assign(v.style, {
      position: "relative"
    });
    let _, k = l;
    const O = (Z, ee) => {
      const X = Z / ee.width;
      return X >= 0.5 ? 3 : X > 0.25 ? 2 : X > 0.15 ? 1 : 0;
    }, D = ({
      props: Z,
      source: ee
    }) => {
      var fe;
      const X = useRef(), {
        volume: ne = 1,
        isHidden: Q = !1
      } = Z || {}, [ae, j] = useState(0), ue = Z == null ? void 0 : Z.isMuted, he = !(Z != null && Z.isHidden) && ((fe = ee == null ? void 0 : ee.props) == null ? void 0 : fe.videoEnabled);
      return useEffect(() => {
        X.current && (X.current.play().catch((be) => {
          document.addEventListener("click", () => {
            var ke;
            return (ke = X.current) == null ? void 0 : ke.play();
          }, {
            once: !0
          });
        }), ee != null && ee.value && (ee == null ? void 0 : ee.value) !== X.current.srcObject ? X.current.srcObject = ee == null ? void 0 : ee.value : ee != null && ee.value || (X.current.srcObject = null));
      }, [X.current, ee == null ? void 0 : ee.value]), useEffect(() => {
        !Z && X.current && (X.current.srcObject = null, X.current = null);
      }, [Z]), useLayoutEffect(() => {
        if (!X.current)
          return;
        const be = () => {
          const Te = X.current;
          Te && j(O(Te.clientWidth, {
            width: p.compositor.getRoot().props.size.x,
            height: p.compositor.getRoot().props.size.y
          }));
        }, ke = new ResizeObserver((Te) => {
          be();
        });
        return be(), ke == null || ke.observe(X.current), () => {
          X.current && (ke == null || ke.unobserve(X.current), X.current.srcObject = null);
        };
      }, [X.current, p]), useEffect(() => {
        X.current && (X.current.volume = ne);
      }, [X.current, ne]), /* @__PURE__ */ React.createElement("div", {
        style: {
          position: "relative",
          display: "flex",
          height: "100%",
          width: "100%"
        }
      }, /* @__PURE__ */ React.createElement("div", {
        style: {
          background: "#222",
          position: "absolute",
          height: "100%",
          width: "100%",
          fontSize: "43px",
          color: "rgba(255,255,255,0.6)",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          opacity: he ? "0" : "1"
        }
      }, !!ee && /* @__PURE__ */ React.createElement("div", {
        style: {
          borderRadius: "50%",
          background: "#555",
          width: "70px",
          height: "70px",
          textTransform: "uppercase",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          lineHeight: "1em"
        }
      }, "RTMP")), /* @__PURE__ */ React.createElement("div", {
        style: {
          position: "relative",
          display: "flex",
          height: "100%",
          width: "100%"
        }
      }, /* @__PURE__ */ React.createElement("video", {
        ref: X,
        autoPlay: !0,
        muted: ue,
        disablePictureInPicture: !0,
        playsInline: !0,
        style: {
          left: "50%",
          top: "50%",
          position: "relative",
          transform: "translate3d(-50%, -50%, 0)",
          height: "100%",
          opacity: he ? "1" : "0",
          objectFit: "cover",
          background: "rgba(0,0,0,0.6)"
        }
      })), !!(ee != null && ee.props.displayName) && /* @__PURE__ */ React.createElement("div", {
        className: "NameBannerContainer",
        style: {
          width: "100%",
          height: "100%",
          position: "absolute"
        }
      }, /* @__PURE__ */ React.createElement("div", {
        className: "NameBanner",
        "data-size": ae,
        style: {
          padding: "12px 30px",
          width: "fit-content",
          height: "fit-content",
          top: "100%",
          transform: "translateY(-100%)",
          left: 0
        }
      }, /* @__PURE__ */ React.createElement("div", {
        className: "NameBanner-body"
      }, ee == null ? void 0 : ee.props.displayName))));
    }, F = createRoot(v), H = () => F.render(/* @__PURE__ */ React.createElement(D, {
      source: _,
      props: k
    }));
    return a((Z) => {
      k = Z, H();
    }), u((Z) => {
      _ = Z, H();
    }), c((Z) => {
      k = Z, H();
    }), {
      root: v
    };
  }
}, RoomParticipant = {
  name: "LS-Room-Participant",
  sourceType: "RoomParticipant",
  props: {
    isMuted: {
      type: Boolean,
      required: !1,
      default: !1
    },
    volume: {
      type: Number,
      required: !1,
      default: 1
    }
  },
  useSource(a, u) {
    return a.find((c) => isMatch(c.props, u.sourceProps));
  },
  create({
    onUpdate: a,
    onNewSource: u,
    onRemove: c
  }, l) {
    const v = document.createElement("div"), p = getProject(CoreContext.state.activeProjectId), _ = getProjectRoom(CoreContext.state.activeProjectId);
    Object.assign(v.style, {
      position: "relative"
    });
    let k, O = l;
    const D = (ee, X) => {
      const ne = ee / X.width;
      return ne >= 0.5 ? 3 : ne > 0.25 ? 2 : ne > 0.15 ? 1 : 0;
    }, F = ({
      props: ee,
      source: X
    }) => {
      var ke, Te, q;
      const ne = useRef(), {
        volume: Q = 1,
        isHidden: ae = !1
      } = ee || {}, [j, ue] = useState(0), fe = (X == null ? void 0 : X.id) === (_ == null ? void 0 : _.participantId) || ((ke = X == null ? void 0 : X.props) == null ? void 0 : ke.participantId) === (_ == null ? void 0 : _.participantId) || (ee == null ? void 0 : ee.isMuted), be = !(ee != null && ee.isHidden) && ((Te = X == null ? void 0 : X.props) == null ? void 0 : Te.videoEnabled);
      return useEffect(() => {
        ne.current && (ne.current.play().catch((z) => {
          document.addEventListener("click", () => {
            var P;
            return (P = ne.current) == null ? void 0 : P.play();
          }, {
            once: !0
          });
        }), X != null && X.value && (X == null ? void 0 : X.value) !== ne.current.srcObject ? ne.current.srcObject = X == null ? void 0 : X.value : X != null && X.value || (ne.current.srcObject = null));
      }, [ne.current, X == null ? void 0 : X.value]), useEffect(() => {
        !ee && ne.current && (ne.current.srcObject = null, ne.current = null);
      }, [ee]), useLayoutEffect(() => {
        if (!ne.current)
          return;
        const z = () => {
          const S = ne.current;
          S && ue(D(S.clientWidth, {
            width: p.compositor.getRoot().props.size.x,
            height: p.compositor.getRoot().props.size.y
          }));
        }, P = new ResizeObserver((S) => {
          z();
        });
        return z(), P == null || P.observe(ne.current), () => {
          ne.current && (P == null || P.unobserve(ne.current), ne.current.srcObject = null);
        };
      }, [ne.current, p]), useEffect(() => {
        ne.current && (ne.current.volume = Q);
      }, [ne.current, Q]), /* @__PURE__ */ React.createElement("div", {
        style: {
          position: "relative",
          display: "flex",
          height: "100%",
          width: "100%"
        }
      }, /* @__PURE__ */ React.createElement("div", {
        style: {
          background: "#222",
          position: "absolute",
          height: "100%",
          width: "100%",
          fontSize: "43px",
          color: "rgba(255,255,255,0.6)",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          opacity: be ? "0" : "1"
        }
      }, (X == null ? void 0 : X.props.displayName) && /* @__PURE__ */ React.createElement("div", {
        style: {
          borderRadius: "50%",
          background: "#555",
          width: "70px",
          height: "70px",
          textTransform: "uppercase",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          lineHeight: "1em"
        }
      }, (X == null ? void 0 : X.props.displayName.slice(0, 1)) || "")), /* @__PURE__ */ React.createElement("div", {
        style: {
          position: "relative",
          display: "flex",
          height: "100%",
          width: "100%",
          ...!!((q = X == null ? void 0 : X.props) != null && q.mirrored) && {
            transform: "scaleX(-1)"
          }
        }
      }, /* @__PURE__ */ React.createElement("video", {
        ref: ne,
        autoPlay: !0,
        muted: fe,
        disablePictureInPicture: !0,
        playsInline: !0,
        style: {
          left: "50%",
          top: "50%",
          position: "relative",
          transform: "translate3d(-50%, -50%, 0)",
          height: "100%",
          opacity: be ? "1" : "0",
          objectFit: (X == null ? void 0 : X.props.type) === "screen" ? "contain" : "cover",
          background: "rgba(0,0,0,0.6)"
        }
      })), (X == null ? void 0 : X.props.displayName) && /* @__PURE__ */ React.createElement("div", {
        className: "NameBannerContainer",
        style: {
          width: "100%",
          height: "100%",
          position: "absolute"
        }
      }, /* @__PURE__ */ React.createElement("div", {
        className: "NameBanner",
        "data-size": j,
        style: {
          padding: "12px 30px",
          width: "fit-content",
          height: "fit-content",
          top: "100%",
          transform: "translateY(-100%)",
          left: 0
        }
      }, /* @__PURE__ */ React.createElement("div", {
        className: "NameBanner-body"
      }, X.props.displayName))));
    }, H = createRoot(v), Z = () => H.render(/* @__PURE__ */ React.createElement(F, {
      source: k,
      props: O
    }));
    return a((ee) => {
      O = ee, Z();
    }), u((ee) => {
      k = ee, Z();
    }), c((ee) => {
      O = ee, Z();
    }), {
      root: v
    };
  }
}, Transforms = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Background,
  Banner,
  ChatOverlay,
  Element: Element$1,
  GameSource,
  Logo,
  Overlay,
  RTMPSource,
  RoomParticipant
}, Symbol.toStringTag, { value: "Module" }));
class EngineWebsocket {
  constructor(u, c) {
    Ft(this, "ws", null);
    Ft(this, "sources", /* @__PURE__ */ new Set());
    this.connectSource = u, this.disconnectSource = c, this.connect = this.connect.bind(this), this.handleMessage = this.handleMessage.bind(this);
  }
  getConnectionString() {
    if (!("apistreamCompositor" in window))
      return "ws://127.0.0.1:8000";
    const {
      eventsConfig: u
    } = window.apistreamCompositor;
    return `ws${u.secure ? "s" : ""}://${u.hostname}:${u.port}${u.token ? `?token=${u.token}` : ""}`;
  }
  connect() {
    const u = this.handleMessage.bind(this);
    this.ws = new WebSocket(this.getConnectionString()), this.ws.addEventListener("message", u), this.ws.addEventListener("error", (c) => {
      console.error("Unable to connect to websocket", c);
    }), this.ws.addEventListener("close", () => {
      var c, l;
      (c = this.ws) == null || c.removeEventListener("message", u);
      try {
        (l = this.ws) == null || l.close(), this.ws = null;
      } catch {
      }
      setTimeout(() => {
        this.connect();
      }, 1e3);
    });
  }
  disconnect() {
    var u, c;
    (u = this.ws) != null && u.OPEN && ((c = this.ws) == null || c.close());
  }
  handleMessage(u) {
    try {
      const c = JSON.parse(u.data);
      if (c.name === "state") {
        this.sources.clear(), console.info("[Engine]: state", c.payload);
        for (const l of c.payload.sources)
          l.connected && (this.sources.has(l.id) || (this.sources.add(l.id), this.connectSource(l.id)));
      } else
        c.name === "source.disconnect" ? (console.info("[Engine]: source disconnect", c.payload.id), this.sources.delete(c.payload.id), this.disconnectSource(c.payload.id)) : c.name === "source.connect" && (console.info("[Engine]: source connect", c.payload.id), this.sources.add(c.payload.id), this.connectSource(c.payload.id));
    } catch (c) {
      console.error("unable to handle message: ", c);
    }
  }
}
const BroadcastPhase = lib$2.LiveApiModel.ProjectBroadcastPhase, {
  trigger,
  triggerInternal
} = CoreContext, EventType = lib$2.LiveApiModel.EventType, EventSubType = lib$2.LiveApiModel.EventSubType;
let engineSocket;
const init = async (a = {}) => {
  prepareInternalEvents();
  const u = a.env || "prod", c = a.logLevel || "Warn";
  log.getLogger("livekit").setLevel(c), log.setLevel(c), log.info("Initializing Studio SDK...");
  const {
    layouts: v = [],
    transforms: p = [],
    sources: _ = [],
    defaultTransforms: k = {},
    useLatestRenderer: O = !1,
    guestToken: D,
    rendererVersion: F
  } = a, H = new lib$2.ApiStream({
    sdkVersion: CoreContext.version,
    env: u,
    logLevel: c
  }), Z = config$2(), ee = start({
    dbAdapter: compositorAdapter,
    transformSettings: {
      defaultTransforms: {
        ...k,
        ...Z.defaults.transforms
      }
    }
  });
  CoreContext.config = Z, CoreContext.clients = H, CoreContext.compositor = ee, CoreContext.logLevel = c, CoreContext.Request = await Promise.resolve().then(() => requests), CoreContext.Command = await Promise.resolve().then(() => commands$1), CoreContext.rendererVersion = O ? "latest-v2" : F || CoreContext.version, window.__StudioKit = {
    ...CoreContext
  }, ee && (ee.registerSource([...Object.values(Sources), ..._]), ee.registerTransform([...Object.values(Transforms), ...p]), ee.registerLayout([...Object.values(Layouts), ...v]));
  const X = await H.load(D);
  let ne;
  X && await H.LiveApi().project.getProject({
    ...X
  }).then((ae) => hydrateProject(ae.project, X.role)).then(async (ae) => {
    setAppState({
      // As a contributor, `user` refers to the collection
      //  that the project belongs to. This will be referenced
      //  when making requests requiring `collectionId`.
      user: {
        id: X.collectionId,
        props: {},
        name: null,
        metadata: {}
      },
      // TODO: Populate
      sources: [],
      projects: [ae],
      activeProjectId: null
    }), ae.isInitial = !0, ne = await CoreContext.Command.setActiveProject({
      projectId: ae.id
    });
  }), H.LiveApi().on(EventType.EVENT_TYPE_COLLECTION, (ae, j) => {
    switch (log.info("Received: Collection event", j, ae), j) {
      case EventSubType.EVENT_SUB_TYPE_UPDATE: {
        triggerInternal("UserChanged", ae.update.collection);
        return;
      }
    }
  }), H.LiveApi().on(EventType.EVENT_TYPE_DESTINATION, (ae, j) => {
    switch (log.info("Received: Destination event", j, ae), j) {
      case EventSubType.EVENT_SUB_TYPE_CREATE: {
        const {
          destination: ue
        } = ae.create;
        triggerInternal("DestinationAdded", ue);
        return;
      }
      case EventSubType.EVENT_SUB_TYPE_UPDATE: {
        const {
          destination: ue
        } = ae.update;
        triggerInternal("DestinationChanged", ue);
        return;
      }
      case EventSubType.EVENT_SUB_TYPE_DELETE: {
        triggerInternal("DestinationRemoved", ae.delete);
        return;
      }
    }
  }), H.LiveApi().on(EventType.EVENT_TYPE_SOURCE, (ae, j) => {
    switch (log.info("Received: Source event", j, ae), j) {
      case EventSubType.EVENT_SUB_TYPE_CREATE: {
        triggerInternal("SourceAdded", ae.create.source);
        return;
      }
      case EventSubType.EVENT_SUB_TYPE_UPDATE: {
        triggerInternal("SourceChanged", ae.update.source);
        return;
      }
      case EventSubType.EVENT_SUB_TYPE_DELETE: {
        triggerInternal("SourceRemoved", ae.delete.sourceId);
        return;
      }
      case EventSubType.EVENT_SUB_TYPE_ADD: {
        triggerInternal("ProjectSourceAdded", {
          projectId: ae.add.projectId,
          source: ae.add.source
        });
        return;
      }
      case EventSubType.EVENT_SUB_TYPE_REMOVE: {
        triggerInternal("ProjectSourceRemoved", {
          projectId: ae.remove.projectId,
          sourceId: ae.remove.sourceId
        });
        return;
      }
    }
  }), H.LiveApi().on(EventType.EVENT_TYPE_PROJECT, (ae, j) => {
    var ue;
    switch (log.info("Received: Project event", j, ae), j) {
      case EventSubType.EVENT_SUB_TYPE_CREATE: {
        const he = ae.create.project;
        if (getProject(he.projectId))
          return;
        triggerInternal("ProjectAdded", he);
        return;
      }
      case EventSubType.EVENT_SUB_TYPE_UPDATE: {
        const {
          project: he
        } = ae.update, fe = getProject(he.projectId);
        if (!fe)
          return;
        triggerInternal("ProjectChanged", {
          project: he,
          phase: fe.videoApi.phase
        });
        return;
      }
      case EventSubType.EVENT_SUB_TYPE_DELETE: {
        triggerInternal("ProjectRemoved", {
          projectId: ae.delete.projectId
        });
        return;
      }
      case EventSubType.EVENT_SUB_TYPE_STATE: {
        const he = getProject((ue = ae.state) == null ? void 0 : ue.projectId);
        if (!he)
          return;
        let fe = ae.state.broadcastId;
        if (ae.state.error && trigger("BroadcastError", {
          projectId: he.id,
          broadcastId: ae.state.broadcastId,
          error: ae.state.error
        }), ae.state.phase) {
          const be = ae.state.phase;
          be === BroadcastPhase.PROJECT_BROADCAST_PHASE_RUNNING ? trigger("BroadcastStarted", {
            projectId: he.id,
            broadcastId: ae.state.broadcastId
          }) : be === BroadcastPhase.PROJECT_BROADCAST_PHASE_STOPPED && (fe = null, trigger("BroadcastStopped", {
            projectId: he.id,
            broadcastId: ae.state.broadcastId
          }));
        }
        triggerInternal("ProjectChanged", {
          project: he.videoApi.project,
          phase: ae.state.phase,
          broadcastId: fe
        });
        return;
      }
    }
  }), H.LayoutApi().on(lib$2.LayoutApiModel.EventType.EVENT_TYPE_LAYER, (ae, j) => {
    var ue;
    if (j === lib$2.LayoutApiModel.EventSubType.EVENT_SUB_TYPE_CREATE) {
      log.debug("Received: Node Insert", ae.create);
      const {
        connectionId: he,
        layoutId: fe
      } = ae.create.requestMetadata;
      if (CoreContext.connectionId === he)
        return;
      const be = layerToNode(ae.create), ke = getProjectByLayoutId(fe), Te = [be, ...ke.compositor.nodes.map(toDataNode$1)], q = toSceneTree(Te, be.id);
      ke.compositor.local.insert(q), triggerInternal("NodeAdded", {
        projectId: ke.id,
        nodeId: be.id
      });
    } else if (j === lib$2.LayoutApiModel.EventSubType.EVENT_SUB_TYPE_UPDATE) {
      log.debug("Received: Node Update", ae.update);
      const {
        connectionId: he,
        layoutId: fe,
        updateVersions: be = {}
      } = ((ue = ae.update) == null ? void 0 : ue.requestMetadata) || {};
      if (CoreContext.connectionId === he)
        return;
      const ke = layerToNode(ae.update);
      if ((latestUpdateVersion[ke.id] || 0) > be[ke.id])
        return log.info("Ignoring node update - updateID is less than latest.");
      latestUpdateVersion[ke.id] = be[ke.id];
      const q = getProjectByLayoutId(fe);
      q.compositor.local.update(ae.update.id, ke.props, ke.childIds), triggerInternal("NodeChanged", {
        projectId: q.id,
        nodeId: ke.id
      });
    } else if (j === lib$2.LayoutApiModel.EventSubType.EVENT_SUB_TYPE_DELETE) {
      log.debug("Received: Node Delete", ae.delete);
      const {
        connectionId: he,
        layoutId: fe
      } = ae.delete.requestMetadata;
      if (CoreContext.connectionId === he)
        return;
      const be = getProjectByLayoutId(fe);
      be.compositor.local.remove(ae.delete.id), triggerInternal("NodeRemoved", {
        projectId: be.id,
        nodeId: ae.delete.id
      });
    } else if (j === lib$2.LayoutApiModel.EventSubType.EVENT_SUB_TYPE_BATCH) {
      log.debug("Received: Node Batch Update", ae.batch);
      const {
        connectionId: he,
        layoutId: fe,
        updateVersions: be = {}
      } = ae.batch.requestMetadata;
      if (CoreContext.connectionId === he)
        return;
      const ke = getProjectByLayoutId(fe);
      ae.batch.layers.forEach((Te) => {
        try {
          const [q, z] = Object.entries(Te)[0];
          if (q === "create") {
            const P = layerToNode(z);
            ke.compositor.local.insert(P), triggerInternal("NodeAdded", {
              projectId: ke.id,
              nodeId: P.id
            });
          } else if (q === "update") {
            const P = layerToNode(z);
            if ((latestUpdateVersion[P.id] || 0) > be[P.id])
              return log.info("Ignoring node update - updateID is less than latest.");
            latestUpdateVersion[P.id] = be[P.id], ke.compositor.local.update(P.id, P.props, P.childIds), triggerInternal("NodeChanged", {
              projectId: ke.id,
              nodeId: P.id
            });
          } else
            q === "delete" && (ke.compositor.local.remove(z.id), triggerInternal("NodeRemoved", {
              projectId: ke.id,
              nodeId: z.id
            }));
        } catch (q) {
          log.warn("Error handling batch item", q, {
            item: Te
          });
        }
      }), ke && triggerInternal("NodeChanged", {
        projectId: ke.id,
        nodeId: ke.compositor.getRoot().id
      });
    }
  });
  const Q = (ae = {}, j) => {
    const {
      displayName: ue,
      role: he,
      maxDuration: fe = CoreContext.config.defaults.guestTokenDuration,
      projectId: be = CoreContext.state.activeProjectId
    } = ae, ke = getProject(be), Te = ue ? {
      direct: {
        displayName: ue
      }
    } : {
      exchange: {
        maxDuration: fe
      }
    };
    return H.LiveApi().authentication.createGuestAccessToken({
      projectId: be,
      token: Te,
      url: j,
      collectionId: ke.videoApi.project.collectionId,
      maxDuration: fe,
      role: he || lib$2.LiveApiModel.Role.ROLE_GUEST
    });
  };
  return {
    ...omit(CoreContext, ["clients", "config", "connectionId", "Request", "state", "trigger"]),
    createDemoToken: async () => (console.warn("createDemoToken() is currently unavailable."), ""),
    createPreviewLink: async (ae = {}) => {
      const {
        maxDuration: j,
        projectId: ue = CoreContext.state.activeProjectId
      } = ae, he = getProject(ue), fe = he.videoApi.project.composition.studioSdk.rendererUrl;
      return (await H.LiveApi().authentication.createGuestAccessToken({
        projectId: ue,
        token: {
          direct: {
            displayName: "Preview"
          }
        },
        url: fe,
        collectionId: he.videoApi.project.collectionId,
        maxDuration: j || CoreContext.config.defaults.previewTokenDuration,
        role: lib$2.LiveApiModel.Role.ROLE_VIEWER
      })).url;
    },
    createGuestLink: async (ae, j = {}) => (await Q(j, ae)).url,
    createGuestToken: async (ae = {}) => (await Q(ae)).accessToken,
    initialProject: ne,
    load,
    render
  };
};
CoreContext.on("ActiveProjectChanged", ({
  projectId: a
}) => {
  toBaseProject(getProject(a)).role === Role.ROLE_RENDERER && (log.info("Connecting to engine websocket..."), engineSocket && (log.info("Disconnecting existing engine websocket..."), engineSocket.disconnect(), engineSocket = null), engineSocket || (log.info("Creating new engine websocket..."), engineSocket = setupEngineWebsocket(async function(l) {
    triggerInternal("SourceConnected", l);
  }, async function(l) {
    triggerInternal("SourceDisconnected", l);
  }), engineSocket.connect()));
});
function setupEngineWebsocket(a, u) {
  return new EngineWebsocket(a, u);
}
const load = async (a, u) => {
  let c = getBaseUser();
  if (c)
    return log.info("Attempted to load user again - returning existing user"), c;
  if (!a) {
    log.warn("Access token required for load()");
    return;
  }
  log.info("Loading user..."), await CoreContext.clients.load(a);
  const v = await CoreContext.Request.loadUser(u);
  return setAppState({
    user: v.user,
    sources: v.sources,
    projects: v.projects,
    activeProjectId: null
  }), c = getBaseUser(), trigger("UserLoaded", c), c;
};
export {
  commands$1 as Command,
  index as Compositor,
  context as Context,
  events$1 as Events,
  index$1 as Helpers,
  requests as Request,
  index$2 as Room,
  types$2 as SDK,
  init
};
//# sourceMappingURL=index.js.map
