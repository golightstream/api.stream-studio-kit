var Ci = Object.defineProperty;
var Pi = (a, u, c) => u in a ? Ci(a, u, { enumerable: !0, configurable: !0, writable: !0, value: c }) : a[u] = c;
var Ft = (a, u, c) => (Pi(a, typeof u != "symbol" ? u + "" : u, c), c);
import React, { useState, useEffect, useContext, useMemo, useRef, useLayoutEffect } from "react";
import ReactDOM from "react-dom";
var commonjsGlobal$1 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs$2(a) {
  return a && a.__esModule && Object.prototype.hasOwnProperty.call(a, "default") ? a.default : a;
}
function getAugmentedNamespace(a) {
  if (a.__esModule)
    return a;
  var u = a.default;
  if (typeof u == "function") {
    var c = function l() {
      return this instanceof l ? Reflect.construct(u, arguments, this.constructor) : u.apply(this, arguments);
    };
    c.prototype = u.prototype;
  } else
    c = {};
  return Object.defineProperty(c, "__esModule", { value: !0 }), Object.keys(a).forEach(function(l) {
    var v = Object.getOwnPropertyDescriptor(a, l);
    Object.defineProperty(c, l, v.get ? v : {
      enumerable: !0,
      get: function() {
        return a[l];
      }
    });
  }), c;
}
var lib$2 = {};
function e(a) {
  this.message = a;
}
e.prototype = new Error(), e.prototype.name = "InvalidCharacterError";
var r$2 = typeof window < "u" && window.atob && window.atob.bind(window) || function(a) {
  var u = String(a).replace(/=+$/, "");
  if (u.length % 4 == 1)
    throw new e("'atob' failed: The string to be decoded is not correctly encoded.");
  for (var c, l, v = 0, p = 0, _ = ""; l = u.charAt(p++); ~l && (c = v % 4 ? 64 * c + l : l, v++ % 4) ? _ += String.fromCharCode(255 & c >> (-2 * v & 6)) : 0)
    l = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(l);
  return _;
};
function t(a) {
  var u = a.replace(/-/g, "+").replace(/_/g, "/");
  switch (u.length % 4) {
    case 0:
      break;
    case 2:
      u += "==";
      break;
    case 3:
      u += "=";
      break;
    default:
      throw "Illegal base64url string!";
  }
  try {
    return function(c) {
      return decodeURIComponent(r$2(c).replace(/(.)/g, function(l, v) {
        var p = v.charCodeAt(0).toString(16).toUpperCase();
        return p.length < 2 && (p = "0" + p), "%" + p;
      }));
    }(u);
  } catch {
    return r$2(u);
  }
}
function n(a) {
  this.message = a;
}
function o(a, u) {
  if (typeof a != "string")
    throw new n("Invalid token specified");
  var c = (u = u || {}).header === !0 ? 0 : 1;
  try {
    return JSON.parse(t(a.split(".")[c]));
  } catch (l) {
    throw new n("Invalid token specified: " + l.message);
  }
}
n.prototype = new Error(), n.prototype.name = "InvalidTokenError";
const jwtDecode_esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  InvalidTokenError: n,
  default: o
}, Symbol.toStringTag, { value: "Module" })), require$$0$3 = /* @__PURE__ */ getAugmentedNamespace(jwtDecode_esm);
var getRandomValues, rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues && (getRandomValues = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto < "u" && typeof msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto), !getRandomValues))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return getRandomValues(rnds8);
}
const REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function validate$2(a) {
  return typeof a == "string" && REGEX.test(a);
}
var byteToHex = [];
for (var i$2 = 0; i$2 < 256; ++i$2)
  byteToHex.push((i$2 + 256).toString(16).substr(1));
function stringify(a) {
  var u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, c = (byteToHex[a[u + 0]] + byteToHex[a[u + 1]] + byteToHex[a[u + 2]] + byteToHex[a[u + 3]] + "-" + byteToHex[a[u + 4]] + byteToHex[a[u + 5]] + "-" + byteToHex[a[u + 6]] + byteToHex[a[u + 7]] + "-" + byteToHex[a[u + 8]] + byteToHex[a[u + 9]] + "-" + byteToHex[a[u + 10]] + byteToHex[a[u + 11]] + byteToHex[a[u + 12]] + byteToHex[a[u + 13]] + byteToHex[a[u + 14]] + byteToHex[a[u + 15]]).toLowerCase();
  if (!validate$2(c))
    throw TypeError("Stringified UUID is invalid");
  return c;
}
var _nodeId, _clockseq, _lastMSecs = 0, _lastNSecs = 0;
function v1(a, u, c) {
  var l = u && c || 0, v = u || new Array(16);
  a = a || {};
  var p = a.node || _nodeId, _ = a.clockseq !== void 0 ? a.clockseq : _clockseq;
  if (p == null || _ == null) {
    var k = a.random || (a.rng || rng)();
    p == null && (p = _nodeId = [k[0] | 1, k[1], k[2], k[3], k[4], k[5]]), _ == null && (_ = _clockseq = (k[6] << 8 | k[7]) & 16383);
  }
  var O = a.msecs !== void 0 ? a.msecs : Date.now(), D = a.nsecs !== void 0 ? a.nsecs : _lastNSecs + 1, F = O - _lastMSecs + (D - _lastNSecs) / 1e4;
  if (F < 0 && a.clockseq === void 0 && (_ = _ + 1 & 16383), (F < 0 || O > _lastMSecs) && a.nsecs === void 0 && (D = 0), D >= 1e4)
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  _lastMSecs = O, _lastNSecs = D, _clockseq = _, O += 122192928e5;
  var z = ((O & 268435455) * 1e4 + D) % 4294967296;
  v[l++] = z >>> 24 & 255, v[l++] = z >>> 16 & 255, v[l++] = z >>> 8 & 255, v[l++] = z & 255;
  var j = O / 4294967296 * 1e4 & 268435455;
  v[l++] = j >>> 8 & 255, v[l++] = j & 255, v[l++] = j >>> 24 & 15 | 16, v[l++] = j >>> 16 & 255, v[l++] = _ >>> 8 | 128, v[l++] = _ & 255;
  for (var ee = 0; ee < 6; ++ee)
    v[l + ee] = p[ee];
  return u || stringify(v);
}
function parse$3(a) {
  if (!validate$2(a))
    throw TypeError("Invalid UUID");
  var u, c = new Uint8Array(16);
  return c[0] = (u = parseInt(a.slice(0, 8), 16)) >>> 24, c[1] = u >>> 16 & 255, c[2] = u >>> 8 & 255, c[3] = u & 255, c[4] = (u = parseInt(a.slice(9, 13), 16)) >>> 8, c[5] = u & 255, c[6] = (u = parseInt(a.slice(14, 18), 16)) >>> 8, c[7] = u & 255, c[8] = (u = parseInt(a.slice(19, 23), 16)) >>> 8, c[9] = u & 255, c[10] = (u = parseInt(a.slice(24, 36), 16)) / 1099511627776 & 255, c[11] = u / 4294967296 & 255, c[12] = u >>> 24 & 255, c[13] = u >>> 16 & 255, c[14] = u >>> 8 & 255, c[15] = u & 255, c;
}
function stringToBytes(a) {
  a = unescape(encodeURIComponent(a));
  for (var u = [], c = 0; c < a.length; ++c)
    u.push(a.charCodeAt(c));
  return u;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8", URL$1 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35(a, u, c) {
  function l(v, p, _, k) {
    if (typeof v == "string" && (v = stringToBytes(v)), typeof p == "string" && (p = parse$3(p)), p.length !== 16)
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    var O = new Uint8Array(16 + v.length);
    if (O.set(p), O.set(v, p.length), O = c(O), O[6] = O[6] & 15 | u, O[8] = O[8] & 63 | 128, _) {
      k = k || 0;
      for (var D = 0; D < 16; ++D)
        _[k + D] = O[D];
      return _;
    }
    return stringify(O);
  }
  try {
    l.name = a;
  } catch {
  }
  return l.DNS = DNS, l.URL = URL$1, l;
}
function md5$3(a) {
  if (typeof a == "string") {
    var u = unescape(encodeURIComponent(a));
    a = new Uint8Array(u.length);
    for (var c = 0; c < u.length; ++c)
      a[c] = u.charCodeAt(c);
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(a), a.length * 8));
}
function md5ToHexEncodedArray(a) {
  for (var u = [], c = a.length * 32, l = "0123456789abcdef", v = 0; v < c; v += 8) {
    var p = a[v >> 5] >>> v % 32 & 255, _ = parseInt(l.charAt(p >>> 4 & 15) + l.charAt(p & 15), 16);
    u.push(_);
  }
  return u;
}
function getOutputLength(a) {
  return (a + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(a, u) {
  a[u >> 5] |= 128 << u % 32, a[getOutputLength(u) - 1] = u;
  for (var c = 1732584193, l = -271733879, v = -1732584194, p = 271733878, _ = 0; _ < a.length; _ += 16) {
    var k = c, O = l, D = v, F = p;
    c = md5ff(c, l, v, p, a[_], 7, -680876936), p = md5ff(p, c, l, v, a[_ + 1], 12, -389564586), v = md5ff(v, p, c, l, a[_ + 2], 17, 606105819), l = md5ff(l, v, p, c, a[_ + 3], 22, -1044525330), c = md5ff(c, l, v, p, a[_ + 4], 7, -176418897), p = md5ff(p, c, l, v, a[_ + 5], 12, 1200080426), v = md5ff(v, p, c, l, a[_ + 6], 17, -1473231341), l = md5ff(l, v, p, c, a[_ + 7], 22, -45705983), c = md5ff(c, l, v, p, a[_ + 8], 7, 1770035416), p = md5ff(p, c, l, v, a[_ + 9], 12, -1958414417), v = md5ff(v, p, c, l, a[_ + 10], 17, -42063), l = md5ff(l, v, p, c, a[_ + 11], 22, -1990404162), c = md5ff(c, l, v, p, a[_ + 12], 7, 1804603682), p = md5ff(p, c, l, v, a[_ + 13], 12, -40341101), v = md5ff(v, p, c, l, a[_ + 14], 17, -1502002290), l = md5ff(l, v, p, c, a[_ + 15], 22, 1236535329), c = md5gg(c, l, v, p, a[_ + 1], 5, -165796510), p = md5gg(p, c, l, v, a[_ + 6], 9, -1069501632), v = md5gg(v, p, c, l, a[_ + 11], 14, 643717713), l = md5gg(l, v, p, c, a[_], 20, -373897302), c = md5gg(c, l, v, p, a[_ + 5], 5, -701558691), p = md5gg(p, c, l, v, a[_ + 10], 9, 38016083), v = md5gg(v, p, c, l, a[_ + 15], 14, -660478335), l = md5gg(l, v, p, c, a[_ + 4], 20, -405537848), c = md5gg(c, l, v, p, a[_ + 9], 5, 568446438), p = md5gg(p, c, l, v, a[_ + 14], 9, -1019803690), v = md5gg(v, p, c, l, a[_ + 3], 14, -187363961), l = md5gg(l, v, p, c, a[_ + 8], 20, 1163531501), c = md5gg(c, l, v, p, a[_ + 13], 5, -1444681467), p = md5gg(p, c, l, v, a[_ + 2], 9, -51403784), v = md5gg(v, p, c, l, a[_ + 7], 14, 1735328473), l = md5gg(l, v, p, c, a[_ + 12], 20, -1926607734), c = md5hh(c, l, v, p, a[_ + 5], 4, -378558), p = md5hh(p, c, l, v, a[_ + 8], 11, -2022574463), v = md5hh(v, p, c, l, a[_ + 11], 16, 1839030562), l = md5hh(l, v, p, c, a[_ + 14], 23, -35309556), c = md5hh(c, l, v, p, a[_ + 1], 4, -1530992060), p = md5hh(p, c, l, v, a[_ + 4], 11, 1272893353), v = md5hh(v, p, c, l, a[_ + 7], 16, -155497632), l = md5hh(l, v, p, c, a[_ + 10], 23, -1094730640), c = md5hh(c, l, v, p, a[_ + 13], 4, 681279174), p = md5hh(p, c, l, v, a[_], 11, -358537222), v = md5hh(v, p, c, l, a[_ + 3], 16, -722521979), l = md5hh(l, v, p, c, a[_ + 6], 23, 76029189), c = md5hh(c, l, v, p, a[_ + 9], 4, -640364487), p = md5hh(p, c, l, v, a[_ + 12], 11, -421815835), v = md5hh(v, p, c, l, a[_ + 15], 16, 530742520), l = md5hh(l, v, p, c, a[_ + 2], 23, -995338651), c = md5ii(c, l, v, p, a[_], 6, -198630844), p = md5ii(p, c, l, v, a[_ + 7], 10, 1126891415), v = md5ii(v, p, c, l, a[_ + 14], 15, -1416354905), l = md5ii(l, v, p, c, a[_ + 5], 21, -57434055), c = md5ii(c, l, v, p, a[_ + 12], 6, 1700485571), p = md5ii(p, c, l, v, a[_ + 3], 10, -1894986606), v = md5ii(v, p, c, l, a[_ + 10], 15, -1051523), l = md5ii(l, v, p, c, a[_ + 1], 21, -2054922799), c = md5ii(c, l, v, p, a[_ + 8], 6, 1873313359), p = md5ii(p, c, l, v, a[_ + 15], 10, -30611744), v = md5ii(v, p, c, l, a[_ + 6], 15, -1560198380), l = md5ii(l, v, p, c, a[_ + 13], 21, 1309151649), c = md5ii(c, l, v, p, a[_ + 4], 6, -145523070), p = md5ii(p, c, l, v, a[_ + 11], 10, -1120210379), v = md5ii(v, p, c, l, a[_ + 2], 15, 718787259), l = md5ii(l, v, p, c, a[_ + 9], 21, -343485551), c = safeAdd(c, k), l = safeAdd(l, O), v = safeAdd(v, D), p = safeAdd(p, F);
  }
  return [c, l, v, p];
}
function bytesToWords(a) {
  if (a.length === 0)
    return [];
  for (var u = a.length * 8, c = new Uint32Array(getOutputLength(u)), l = 0; l < u; l += 8)
    c[l >> 5] |= (a[l / 8] & 255) << l % 32;
  return c;
}
function safeAdd(a, u) {
  var c = (a & 65535) + (u & 65535), l = (a >> 16) + (u >> 16) + (c >> 16);
  return l << 16 | c & 65535;
}
function bitRotateLeft(a, u) {
  return a << u | a >>> 32 - u;
}
function md5cmn(a, u, c, l, v, p) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(u, a), safeAdd(l, p)), v), c);
}
function md5ff(a, u, c, l, v, p, _) {
  return md5cmn(u & c | ~u & l, a, u, v, p, _);
}
function md5gg(a, u, c, l, v, p, _) {
  return md5cmn(u & l | c & ~l, a, u, v, p, _);
}
function md5hh(a, u, c, l, v, p, _) {
  return md5cmn(u ^ c ^ l, a, u, v, p, _);
}
function md5ii(a, u, c, l, v, p, _) {
  return md5cmn(c ^ (u | ~l), a, u, v, p, _);
}
var v3 = v35("v3", 48, md5$3);
const v3$1 = v3;
function v4(a, u, c) {
  a = a || {};
  var l = a.random || (a.rng || rng)();
  if (l[6] = l[6] & 15 | 64, l[8] = l[8] & 63 | 128, u) {
    c = c || 0;
    for (var v = 0; v < 16; ++v)
      u[c + v] = l[v];
    return u;
  }
  return stringify(l);
}
function f$1(a, u, c, l) {
  switch (a) {
    case 0:
      return u & c ^ ~u & l;
    case 1:
      return u ^ c ^ l;
    case 2:
      return u & c ^ u & l ^ c & l;
    case 3:
      return u ^ c ^ l;
  }
}
function ROTL(a, u) {
  return a << u | a >>> 32 - u;
}
function sha1$1(a) {
  var u = [1518500249, 1859775393, 2400959708, 3395469782], c = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof a == "string") {
    var l = unescape(encodeURIComponent(a));
    a = [];
    for (var v = 0; v < l.length; ++v)
      a.push(l.charCodeAt(v));
  } else
    Array.isArray(a) || (a = Array.prototype.slice.call(a));
  a.push(128);
  for (var p = a.length / 4 + 2, _ = Math.ceil(p / 16), k = new Array(_), O = 0; O < _; ++O) {
    for (var D = new Uint32Array(16), F = 0; F < 16; ++F)
      D[F] = a[O * 64 + F * 4] << 24 | a[O * 64 + F * 4 + 1] << 16 | a[O * 64 + F * 4 + 2] << 8 | a[O * 64 + F * 4 + 3];
    k[O] = D;
  }
  k[_ - 1][14] = (a.length - 1) * 8 / Math.pow(2, 32), k[_ - 1][14] = Math.floor(k[_ - 1][14]), k[_ - 1][15] = (a.length - 1) * 8 & 4294967295;
  for (var z = 0; z < _; ++z) {
    for (var j = new Uint32Array(80), ee = 0; ee < 16; ++ee)
      j[ee] = k[z][ee];
    for (var X = 16; X < 80; ++X)
      j[X] = ROTL(j[X - 3] ^ j[X - 8] ^ j[X - 14] ^ j[X - 16], 1);
    for (var ae = c[0], Q = c[1], ne = c[2], Z = c[3], de = c[4], fe = 0; fe < 80; ++fe) {
      var Te = Math.floor(fe / 20), Re = ROTL(ae, 5) + f$1(Te, Q, ne, Z) + de + u[Te] + j[fe] >>> 0;
      de = Z, Z = ne, ne = ROTL(Q, 30) >>> 0, Q = ae, ae = Re;
    }
    c[0] = c[0] + ae >>> 0, c[1] = c[1] + Q >>> 0, c[2] = c[2] + ne >>> 0, c[3] = c[3] + Z >>> 0, c[4] = c[4] + de >>> 0;
  }
  return [c[0] >> 24 & 255, c[0] >> 16 & 255, c[0] >> 8 & 255, c[0] & 255, c[1] >> 24 & 255, c[1] >> 16 & 255, c[1] >> 8 & 255, c[1] & 255, c[2] >> 24 & 255, c[2] >> 16 & 255, c[2] >> 8 & 255, c[2] & 255, c[3] >> 24 & 255, c[3] >> 16 & 255, c[3] >> 8 & 255, c[3] & 255, c[4] >> 24 & 255, c[4] >> 16 & 255, c[4] >> 8 & 255, c[4] & 255];
}
var v5 = v35("v5", 80, sha1$1);
const v5$1 = v5, nil = "00000000-0000-0000-0000-000000000000";
function version$5(a) {
  if (!validate$2(a))
    throw TypeError("Invalid UUID");
  return parseInt(a.substr(14, 1), 16);
}
const esmBrowser = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  NIL: nil,
  parse: parse$3,
  stringify,
  v1,
  v3: v3$1,
  v4,
  v5: v5$1,
  validate: validate$2,
  version: version$5
}, Symbol.toStringTag, { value: "Module" })), require$$1$4 = /* @__PURE__ */ getAugmentedNamespace(esmBrowser);
let EnhancedMap$1 = class extends Map {
  /**
   * If key has a mapping already returns the currently associated value. If
   * there is no mapping, calls the computer which must return a value V.
   * The value is then stored for given key and returned.
   * @param key Key
   * @param computer Computer which is called only if key has no mapping yet.
   * @return Existing value if the key already existed, or the newly computed value.
   */
  computeIfAbsent(u, c) {
    if (this.has(u))
      return this.get(u);
    const l = c(u);
    return this.set(u, l), l;
  }
  /**
   * If the key exists already calls given computer, if the key does not exist
   * this method does nothing.
   *
   * The computer is called with current key and current value associated. The
   * computer can return a (new) value V or undefined. When undefined is returned
   * the key is removed from this map, when a V is returned the key is updated
   * with the new value V.
   * @param key Key
   * @param computer Computer which is called only if the key has a mapping already
   * @return Undefined if the key has no mapping, otherwise the value returned from computer
   */
  computeIfPresent(u, c) {
    const l = this.get(u);
    if (l === void 0)
      return;
    const v = c(u, l);
    return v !== void 0 ? this.set(u, v) : this.delete(u), v;
  }
  /**
   * Computes a value for given key, the computer can return a value V (in which case the map
   * will set the value for given key), if it returns undefined the mapping for key K will be
   * removed.
   * @param key Key to compute
   * @param computer Computer which is called, note that the currentValue argument contains the existing
   *                 value or is undefined when no mapping exists for the key.
   * @return The newly computed value
   */
  compute(u, c) {
    const l = this.get(u), v = c(u, l);
    return v ? this.set(u, v) : this.delete(u), v;
  }
};
var InternalLogLevel$1;
(function(a) {
  a[a.Trace = 0] = "Trace", a[a.Debug = 1] = "Debug", a[a.Info = 2] = "Info", a[a.Warn = 3] = "Warn", a[a.Error = 4] = "Error";
})(InternalLogLevel$1 || (InternalLogLevel$1 = {}));
function getInternalLogger$1(a) {
  return provider$1.getLogger(a);
}
const INTERNAL_LOGGING_SETTINGS$1 = {
  /**
   * Changes the log level for the internal logging (for all new and existing loggers)
   * @param level New log level
   */
  setInternalLogLevel: (a) => provider$1.changeLogLevel(a),
  /**
   * Changes where messages are written to for all new and existing loggers),
   * by default they are written to the console.
   * @param fnOutput Function to write messages to
   */
  setOutput: (a) => provider$1.changeOutput(a),
  /**
   * Resets the log level and output back to defaults (level to error and writing to console)
   * for all new and existing loggers.
   */
  reset: () => provider$1.reset()
};
let InternalLoggerImpl$1 = class {
  constructor(u, c, l) {
    this._name = u, this._level = c, this._fnOutput = l;
  }
  trace(u) {
    this.log(InternalLogLevel$1.Trace, u);
  }
  debug(u) {
    this.log(InternalLogLevel$1.Debug, u);
  }
  error(u, c) {
    this.log(InternalLogLevel$1.Error, u, c);
  }
  info(u) {
    this.log(InternalLogLevel$1.Info, u);
  }
  warn(u, c) {
    this.log(InternalLogLevel$1.Warn, u, c);
  }
  setLevel(u) {
    this._level = u;
  }
  setOutput(u) {
    this._fnOutput = u;
  }
  log(u, c, l) {
    this._level > u || this._fnOutput(`${InternalLogLevel$1[this._level].toString()} <INTERNAL LOGGER> ${this._name} ${c()}${l ? `
` + l.stack : ""}`);
  }
}, InternalProviderImpl$1 = class Kt {
  constructor() {
    this._loggers = new EnhancedMap$1(), this._logLevel = InternalLogLevel$1.Error, this._fnOutput = Kt.logConsole;
  }
  getLogger(u) {
    return this._loggers.computeIfAbsent(u, (c) => new InternalLoggerImpl$1(c, this._logLevel, this._fnOutput));
  }
  changeLogLevel(u) {
    this._logLevel = u, this._loggers.forEach((c) => c.setLevel(u));
  }
  changeOutput(u) {
    this._fnOutput = u, this._loggers.forEach((c) => c.setOutput(this._fnOutput));
  }
  reset() {
    this.changeLogLevel(InternalLogLevel$1.Error), this._fnOutput = Kt.logConsole, this._loggers.forEach((u) => u.setOutput(this._fnOutput));
  }
  static logConsole(u) {
    console && console.log && console.log(u);
  }
};
const provider$1 = new InternalProviderImpl$1();
var InternalLogger$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  get InternalLogLevel() {
    return InternalLogLevel$1;
  },
  getInternalLogger: getInternalLogger$1,
  INTERNAL_LOGGING_SETTINGS: INTERNAL_LOGGING_SETTINGS$1
}), LogLevel$2;
(function(a) {
  a[a.Trace = 0] = "Trace", a[a.Debug = 1] = "Debug", a[a.Info = 2] = "Info", a[a.Warn = 3] = "Warn", a[a.Error = 4] = "Error", a[a.Fatal = 5] = "Fatal";
})(LogLevel$2 || (LogLevel$2 = {}));
(function(a) {
  function u(c) {
    switch (c.toLowerCase()) {
      case "trace":
        return a.Trace;
      case "debug":
        return a.Debug;
      case "info":
        return a.Info;
      case "warn":
        return a.Warn;
      case "error":
        return a.Error;
      case "fatal":
        return a.Fatal;
      default:
        return;
    }
  }
  a.toLogLevel = u;
})(LogLevel$2 || (LogLevel$2 = {}));
let CoreLoggerImpl$1 = class mi {
  constructor(u) {
    this._runtime = u;
  }
  get id() {
    return this._runtime.id;
  }
  get logLevel() {
    return this._runtime.level;
  }
  get runtimeSettings() {
    return Object.assign({}, this._runtime);
  }
  set runtimeSettings(u) {
    this._runtime = u;
  }
  trace(u, ...c) {
    this.logMessage(LogLevel$2.Trace, u, c);
  }
  debug(u, ...c) {
    this.logMessage(LogLevel$2.Debug, u, c);
  }
  info(u, ...c) {
    this.logMessage(LogLevel$2.Info, u, c);
  }
  warn(u, ...c) {
    this.logMessage(LogLevel$2.Warn, u, c);
  }
  error(u, ...c) {
    this.logMessage(LogLevel$2.Error, u, c);
  }
  fatal(u, ...c) {
    this.logMessage(LogLevel$2.Fatal, u, c);
  }
  logMessage(u, c, l) {
    if (this._runtime.level > u)
      return;
    const v = Date.now(), p = typeof c == "string" ? c : c(), _ = mi.getErrorAndArgs(l);
    switch (this._runtime.channel.type) {
      case "RawLogChannel":
        this._runtime.channel.write({
          message: p,
          exception: _.error,
          args: _.args,
          timeInMillis: v,
          level: u,
          logNames: this._runtime.name
        }, this._runtime.argumentFormatter);
        return;
      case "LogChannel":
        this._runtime.channel.write(this.createLogMessage(p, u, _, v));
        break;
    }
  }
  formatArgValue(u) {
    try {
      return this._runtime.argumentFormatter(u);
    } catch {
      return `>>ARG CONVERT FAILED: '${u !== void 0 ? u.toString() : "undefined"}'<<`;
    }
  }
  createLogMessage(u, c, l, v) {
    let p;
    const _ = l.error, k = l.args;
    _ && (p = `${_.name}: ${_.message}`, _.stack && (p += `@
${_.stack}`));
    const O = this._runtime.dateFormatter(v);
    let D = LogLevel$2[c].toUpperCase();
    D.length < 5 && (D += " ");
    const F = typeof this._runtime.name == "string" ? this._runtime.name : this._runtime.name.join(", "), z = typeof k < "u" && k.length > 0 ? " [" + k.map((ee) => this.formatArgValue(ee)).join(", ") + "]" : "";
    return {
      message: O + " " + D + " [" + F + "] " + u + z,
      error: p
    };
  }
  static getErrorAndArgs(u) {
    if (u.length === 0)
      return {};
    let c, l;
    const v = u[0];
    if (v instanceof Error)
      return c = v, l = u.length > 1 ? u.slice(1) : void 0, { error: c, args: l };
    if (typeof v == "function") {
      const p = v();
      return p instanceof Error ? (c = p, l = u.length > 1 ? u.slice(1) : void 0, { error: c, args: l }) : u.length === 1 ? Array.isArray(p) ? { args: p.length > 0 ? p : void 0 } : { args: p } : Array.isArray(p) ? { args: [...p, ...u.slice(1)] } : { args: [p, ...u.slice(1)] };
    }
    return { args: u };
  }
};
function padStart$1(a, u, c = " ") {
  return padInternal$1(a, u, "start", c);
}
function padEnd$1(a, u, c = " ") {
  return padInternal$1(a, u, "end", c);
}
function maxLengthStringValueInArray$1(a) {
  return a.map((u) => u.length).reduce((u, c) => c > u ? c : u, 0);
}
function padInternal$1(a, u, c, l = " ") {
  if (u <= a.length)
    return a;
  if (l.length > 1)
    throw new Error(`Fill char must be one char exactly, it is: ${l.length}`);
  const v = u - a.length;
  let p = "";
  for (let _ = 0; _ < v; _++)
    p += l;
  return c === "start" ? p + a : a + p;
}
function formatArgument$1(a) {
  return a === void 0 ? "undefined" : JSON.stringify(a);
}
function formatDate$1(a) {
  const u = new Date(a), c = u.getFullYear(), l = padStart$1((u.getMonth() + 1).toString(), 2, "0"), v = padStart$1(u.getDate().toString(), 2, "0"), p = padStart$1(u.getHours().toString(), 2, "0"), _ = padStart$1(u.getMinutes().toString(), 2, "0"), k = padStart$1(u.getSeconds().toString(), 2, "0"), O = padStart$1(u.getMilliseconds().toString(), 2, "0");
  return `${c}-${l}-${v} ${p}:${_}:${k},${O}`;
}
let ConsoleLogChannel$1 = class {
  constructor() {
    this.type = "LogChannel";
  }
  write(u) {
    console && console.log && console.log(u.message + (u.error ? `
${u.error}` : ""));
  }
};
var DefaultChannels$1;
(function(a) {
  function u() {
    return new ConsoleLogChannel$1();
  }
  a.createConsoleChannel = u;
})(DefaultChannels$1 || (DefaultChannels$1 = {}));
let LogProviderImpl$1 = class Wt {
  constructor(u, c) {
    this._log = getInternalLogger$1("core.impl.LogProviderImpl"), this._name = u, this._settings = c, this._loggers = new EnhancedMap$1(), this._idToKeyMap = new EnhancedMap$1(), this._globalRuntimeSettings = { level: c.level, channel: c.channel }, this._nextLoggerId = 1, this._log.trace(() => `Created LogProviderImpl with settings: ${JSON.stringify(this._settings)}`);
  }
  get runtimeSettings() {
    return Object.assign(Object.assign({}, this._settings), { level: this._globalRuntimeSettings.level, channel: this._globalRuntimeSettings.channel });
  }
  getLogger(u) {
    return this.getOrCreateLogger(u);
  }
  updateLoggerRuntime(u, c) {
    this._log.debug(() => `Updating logger ${u.id} runtime settings using: '${JSON.stringify(c)}'`);
    const l = this._idToKeyMap.get(u.id);
    return l === void 0 ? (this._log.warn(() => `Cannot update logger with id: ${u.id}, it was not found.`), !1) : (this._loggers.computeIfPresent(l, (v, p) => (p.runtimeSettings = Wt.mergeRuntimeSettingsIntoLogRuntime(p.runtimeSettings, c), p)), !0);
  }
  updateRuntimeSettings(u) {
    this._log.debug(() => `Updating global runtime settings and updating existing loggers runtime settings using: '${JSON.stringify(u)}'`), this._globalRuntimeSettings = {
      /* It's unclear, but not checking explicitly on undefined here makes the test fail, it makes no sense as level is a number | undefined essentially. */
      level: u.level !== void 0 ? u.level : this._globalRuntimeSettings.level,
      channel: u.channel !== void 0 ? u.channel : this._globalRuntimeSettings.channel
    }, this._loggers.forEach((c) => c.runtimeSettings = Wt.mergeRuntimeSettingsIntoLogRuntime(c.runtimeSettings, u));
  }
  /**
   * Removes all state and loggers, it reverts back to as it was after initial construction.
   */
  clear() {
    this._loggers.clear(), this._idToKeyMap.clear(), this._globalRuntimeSettings = Object.assign({}, this._settings), this._nextLoggerId = 1;
  }
  getOrCreateLogger(u) {
    const c = Wt.createKey(u), l = this._loggers.computeIfAbsent(c, () => {
      const v = {
        level: this._globalRuntimeSettings.level,
        channel: this._globalRuntimeSettings.channel,
        id: this.nextLoggerId(),
        name: u,
        argumentFormatter: this._settings.argumentFormatter,
        dateFormatter: this._settings.dateFormatter
      };
      return new CoreLoggerImpl$1(v);
    });
    return this._idToKeyMap.computeIfAbsent(l.id, () => c), l;
  }
  nextLoggerId() {
    const u = this._name + "_" + this._nextLoggerId;
    return this._nextLoggerId++, u;
  }
  static mergeRuntimeSettingsIntoLogRuntime(u, c) {
    return Object.assign(Object.assign({}, u), {
      /* It's unclear, but not checking explicitly on undefined here makes the test fail, it makes no sense as level is a number | undefined essentially. */
      level: c.level !== void 0 ? c.level : u.level,
      channel: c.channel !== void 0 ? c.channel : u.channel
    });
  }
  static createKey(u) {
    return typeof u == "string" ? u : u.join(",");
  }
};
function createLogProvider$1(a, u) {
  return new LogProviderImpl$1(a, u);
}
var index$4 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  EnhancedMap: EnhancedMap$1,
  padStart: padStart$1,
  padEnd: padEnd$1,
  maxLengthStringValueInArray: maxLengthStringValueInArray$1
});
class ArrayLogChannel {
  constructor() {
    this._buffer = [], this.type = "LogChannel";
  }
  write(u) {
    this._buffer.push(u);
  }
  get logMessages() {
    return this._buffer;
  }
  get messages() {
    return this._buffer.map((u) => u.message);
  }
}
class ArrayRawLogChannel {
  constructor() {
    this._buffer = [], this.type = "RawLogChannel";
  }
  write(u, c) {
    this._buffer.push(u);
  }
  get messages() {
    return this._buffer.map((u) => u.message);
  }
  get errors() {
    return this._buffer.map((u) => u.exception);
  }
  get size() {
    return this._buffer.length;
  }
  get rawMessages() {
    return this._buffer;
  }
  clear() {
    this._buffer = [];
  }
}
class TestControlMessage {
  constructor() {
    this._messages = [], this.write = this.write.bind(this);
  }
  get messages() {
    return this._messages;
  }
  write(u) {
    this._messages.push(u);
  }
  clear() {
    this._messages = [];
  }
}
var TestClasses = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArrayLogChannel,
  ArrayRawLogChannel,
  TestControlMessage
});
const typescriptLogging_esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  $internal: InternalLogger$1,
  $test: TestClasses,
  get DefaultChannels() {
    return DefaultChannels$1;
  },
  get LogLevel() {
    return LogLevel$2;
  },
  createLogProvider: createLogProvider$1,
  formatArgument: formatArgument$1,
  formatDate: formatDate$1,
  util: index$4
}, Symbol.toStringTag, { value: "Module" })), require$$2$2 = /* @__PURE__ */ getAugmentedNamespace(typescriptLogging_esm);
var layoutapi = {}, lib$1 = {}, lib = {}, Metadata = {};
Object.defineProperty(Metadata, "__esModule", { value: !0 });
Metadata.Metadata = void 0;
Metadata.Metadata = function(u) {
  const c = /* @__PURE__ */ new Map(), l = {
    set(v, p) {
      if (v = normalizeKey(v), Array.isArray(p))
        if (p.length === 0)
          c.delete(v);
        else {
          for (const _ of p)
            validate$1(v, _);
          c.set(v, v.endsWith("-bin") ? p : [p.join(", ")]);
        }
      else
        validate$1(v, p), c.set(v, [p]);
      return l;
    },
    append(v, p) {
      v = normalizeKey(v), validate$1(v, p);
      let _ = c.get(v);
      return _ == null && (_ = [], c.set(v, _)), _.push(p), v.endsWith("-bin") || c.set(v, [_.join(", ")]), l;
    },
    delete(v) {
      v = normalizeKey(v), c.delete(v);
    },
    get(v) {
      var p;
      return v = normalizeKey(v), (p = c.get(v)) === null || p === void 0 ? void 0 : p[0];
    },
    getAll(v) {
      var p;
      return v = normalizeKey(v), (p = c.get(v)) !== null && p !== void 0 ? p : [];
    },
    has(v) {
      return v = normalizeKey(v), c.has(v);
    },
    [Symbol.iterator]() {
      return c[Symbol.iterator]();
    }
  };
  if (u != null) {
    const v = isIterable$1(u) ? u : Object.entries(u);
    for (const [p, _] of v)
      l.set(p, _);
  }
  return l;
};
function normalizeKey(a) {
  return a.toLowerCase();
}
function validate$1(a, u) {
  if (!/^[0-9a-z_.-]+$/.test(a))
    throw new Error(`Metadata key '${a}' contains illegal characters`);
  if (a.endsWith("-bin")) {
    if (!(u instanceof Uint8Array))
      throw new Error(`Metadata key '${a}' ends with '-bin', thus it must have binary value`);
  } else {
    if (typeof u != "string")
      throw new Error(`Metadata key '${a}' doesn't end with '-bin', thus it must have string value`);
    if (!/^[ -~]*$/.test(u))
      throw new Error(`Metadata value '${u}' of key '${a}' contains illegal characters`);
  }
}
function isIterable$1(a) {
  return Symbol.iterator in a;
}
var Status = {};
(function(a) {
  Object.defineProperty(a, "__esModule", { value: !0 }), a.Status = void 0, function(u) {
    u[u.OK = 0] = "OK", u[u.CANCELLED = 1] = "CANCELLED", u[u.UNKNOWN = 2] = "UNKNOWN", u[u.INVALID_ARGUMENT = 3] = "INVALID_ARGUMENT", u[u.DEADLINE_EXCEEDED = 4] = "DEADLINE_EXCEEDED", u[u.NOT_FOUND = 5] = "NOT_FOUND", u[u.ALREADY_EXISTS = 6] = "ALREADY_EXISTS", u[u.PERMISSION_DENIED = 7] = "PERMISSION_DENIED", u[u.RESOURCE_EXHAUSTED = 8] = "RESOURCE_EXHAUSTED", u[u.FAILED_PRECONDITION = 9] = "FAILED_PRECONDITION", u[u.ABORTED = 10] = "ABORTED", u[u.OUT_OF_RANGE = 11] = "OUT_OF_RANGE", u[u.UNIMPLEMENTED = 12] = "UNIMPLEMENTED", u[u.INTERNAL = 13] = "INTERNAL", u[u.UNAVAILABLE = 14] = "UNAVAILABLE", u[u.DATA_LOSS = 15] = "DATA_LOSS", u[u.UNAUTHENTICATED = 16] = "UNAUTHENTICATED";
  }(a.Status || (a.Status = {}));
})(Status);
var MethodDescriptor = {};
Object.defineProperty(MethodDescriptor, "__esModule", { value: !0 });
var CallOptions = {};
Object.defineProperty(CallOptions, "__esModule", { value: !0 });
var ClientMiddleware = {};
Object.defineProperty(ClientMiddleware, "__esModule", { value: !0 });
var composeClientMiddleware$1 = {};
Object.defineProperty(composeClientMiddleware$1, "__esModule", { value: !0 });
composeClientMiddleware$1.composeClientMiddleware = void 0;
function composeClientMiddleware(a, u) {
  return (c, l) => u({
    ...c,
    next: (v, p) => a({ ...c, request: v }, p)
  }, l);
}
composeClientMiddleware$1.composeClientMiddleware = composeClientMiddleware;
var ClientError$1 = {}, cjs = {}, helpers = {};
helpers.__esModule = void 0;
helpers.__esModule = !0;
var objectSetPrototypeOfIsDefined = typeof Object.setPrototypeOf == "function", objectGetPrototypeOfIsDefined = typeof Object.getPrototypeOf == "function", objectDefinePropertyIsDefined = typeof Object.defineProperty == "function", objectCreateIsDefined = typeof Object.create == "function", objectHasOwnPropertyIsDefined = typeof Object.prototype.hasOwnProperty == "function", setPrototypeOf = function(u, c) {
  objectSetPrototypeOfIsDefined ? Object.setPrototypeOf(u, c) : u.__proto__ = c;
};
helpers.setPrototypeOf = setPrototypeOf;
var getPrototypeOf$1 = function(u) {
  return objectGetPrototypeOfIsDefined ? Object.getPrototypeOf(u) : u.__proto__ || u.prototype;
};
helpers.getPrototypeOf = getPrototypeOf$1;
var ie8ObjectDefinePropertyBug = !1, defineProperty$1 = function a(u, c, l) {
  if (objectDefinePropertyIsDefined && !ie8ObjectDefinePropertyBug)
    try {
      Object.defineProperty(u, c, l);
    } catch {
      ie8ObjectDefinePropertyBug = !0, a(u, c, l);
    }
  else
    u[c] = l.value;
};
helpers.defineProperty = defineProperty$1;
var hasOwnProperty$g = function(u, c) {
  return objectHasOwnPropertyIsDefined ? u.hasOwnProperty(u, c) : u[c] === void 0;
};
helpers.hasOwnProperty = hasOwnProperty$g;
var objectCreate$1 = function(u, c) {
  if (objectCreateIsDefined)
    return Object.create(u, c);
  var l = function() {
  };
  l.prototype = u;
  var v = new l();
  if (typeof c > "u")
    return v;
  if (typeof c == "null")
    throw new Error("PropertyDescriptors must not be null.");
  if (typeof c == "object")
    for (var p in c)
      hasOwnProperty$g(c, p) && (v[p] = c[p].value);
  return v;
};
helpers.objectCreate = objectCreate$1;
(function(a) {
  a.__esModule = void 0, a.__esModule = !0;
  var u = helpers, c = u.setPrototypeOf, l = u.getPrototypeOf, v = u.defineProperty, p = u.objectCreate, _ = new Error().toString() === "[object Error]", k = "";
  function O(D) {
    var F = this.constructor, z = F.name || function() {
      var Q = F.toString().match(/^function\s*([^\s(]+)/);
      return Q === null ? k || "Error" : Q[1];
    }(), j = z === "Error", ee = j ? k : z, X = Error.apply(this, arguments);
    if (c(X, l(this)), !(X instanceof F) || !(X instanceof O)) {
      var X = this;
      Error.apply(this, arguments), v(X, "message", {
        configurable: !0,
        enumerable: !1,
        value: D,
        writable: !0
      });
    }
    if (v(X, "name", {
      configurable: !0,
      enumerable: !1,
      value: ee,
      writable: !0
    }), Error.captureStackTrace && Error.captureStackTrace(
      X,
      j ? O : F
    ), X.stack === void 0) {
      var ae = new Error(D);
      ae.name = X.name, X.stack = ae.stack;
    }
    return _ && v(X, "toString", {
      configurable: !0,
      enumerable: !1,
      value: function() {
        return (this.name || "Error") + (typeof this.message > "u" ? "" : ": " + this.message);
      },
      writable: !0
    }), X;
  }
  k = O.name || "ExtendableError", O.prototype = p(Error.prototype, {
    constructor: {
      value: Error,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }), a.ExtendableError = O, a.default = a.ExtendableError;
})(cjs);
Object.defineProperty(ClientError$1, "__esModule", { value: !0 });
ClientError$1.ClientError = void 0;
const ts_error_1$1 = cjs, Status_1$1 = Status;
class ClientError extends ts_error_1$1.ExtendableError {
  constructor(u, c, l) {
    super(`${u} ${Status_1$1.Status[c]}: ${l}`), this.path = u, this.code = c, this.details = l, this.name = "ClientError", Object.defineProperty(this, "@@nice-grpc", {
      value: !0
    }), Object.defineProperty(this, "@@nice-grpc:ClientError", {
      value: !0
    });
  }
  static [Symbol.hasInstance](u) {
    return this !== ClientError ? this.prototype.isPrototypeOf(u) : typeof u == "object" && u !== null && (u.constructor === ClientError || u["@@nice-grpc:ClientError"] === !0 || u.name === "ClientError" && u["@@nice-grpc"] === !0);
  }
}
ClientError$1.ClientError = ClientError;
var CallContext = {};
Object.defineProperty(CallContext, "__esModule", { value: !0 });
var ServerMiddleware = {};
Object.defineProperty(ServerMiddleware, "__esModule", { value: !0 });
var composeServerMiddleware$1 = {};
Object.defineProperty(composeServerMiddleware$1, "__esModule", { value: !0 });
composeServerMiddleware$1.composeServerMiddleware = void 0;
function composeServerMiddleware(a, u) {
  return (c, l) => a({
    ...c,
    next: (v, p) => u({ ...c, request: v }, p)
  }, l);
}
composeServerMiddleware$1.composeServerMiddleware = composeServerMiddleware;
var ServerError$1 = {};
Object.defineProperty(ServerError$1, "__esModule", { value: !0 });
ServerError$1.ServerError = void 0;
const ts_error_1 = cjs, Status_1 = Status;
class ServerError extends ts_error_1.ExtendableError {
  constructor(u, c) {
    super(`${Status_1.Status[u]}: ${c}`), this.code = u, this.details = c, this.name = "ServerError", Object.defineProperty(this, "@@nice-grpc", {
      value: !0
    }), Object.defineProperty(this, "@@nice-grpc:ServerError", {
      value: !0
    });
  }
  static [Symbol.hasInstance](u) {
    return this !== ServerError ? this.prototype.isPrototypeOf(u) : typeof u == "object" && u !== null && (u.constructor === ServerError || u["@@nice-grpc:ServerError"] === !0 || u.name === "ServerError" && u["@@nice-grpc"] === !0);
  }
}
ServerError$1.ServerError = ServerError;
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(l, v, p, _) {
    _ === void 0 && (_ = p);
    var k = Object.getOwnPropertyDescriptor(v, p);
    (!k || ("get" in k ? !v.__esModule : k.writable || k.configurable)) && (k = { enumerable: !0, get: function() {
      return v[p];
    } }), Object.defineProperty(l, _, k);
  } : function(l, v, p, _) {
    _ === void 0 && (_ = p), l[_] = v[p];
  }), c = commonjsGlobal$1 && commonjsGlobal$1.__exportStar || function(l, v) {
    for (var p in l)
      p !== "default" && !Object.prototype.hasOwnProperty.call(v, p) && u(v, l, p);
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), c(Metadata, a), c(Status, a), c(MethodDescriptor, a), c(CallOptions, a), c(ClientMiddleware, a), c(composeClientMiddleware$1, a), c(ClientError$1, a), c(CallContext, a), c(ServerMiddleware, a), c(composeServerMiddleware$1, a), c(ServerError$1, a);
})(lib);
var serviceDefinitions = {}, grpcWeb = {};
Object.defineProperty(grpcWeb, "__esModule", { value: !0 });
grpcWeb.isGrpcWebServiceDefinition = grpcWeb.fromGrpcWebServiceDefinition = void 0;
function fromGrpcWebServiceDefinition(a) {
  const u = {};
  for (const [c, l] of Object.entries(a)) {
    if (c === "serviceName")
      continue;
    const v = l;
    u[uncapitalize(c)] = {
      path: `/${a.serviceName}/${c}`,
      requestStream: v.requestStream,
      responseStream: v.responseStream,
      requestDeserialize: v.requestType.deserializeBinary,
      requestSerialize: (p) => p.serializeBinary(),
      responseDeserialize: v.responseType.deserializeBinary,
      responseSerialize: (p) => p.serializeBinary(),
      options: {}
    };
  }
  return u;
}
grpcWeb.fromGrpcWebServiceDefinition = fromGrpcWebServiceDefinition;
function isGrpcWebServiceDefinition(a) {
  return "prototype" in a;
}
grpcWeb.isGrpcWebServiceDefinition = isGrpcWebServiceDefinition;
function uncapitalize(a) {
  return a.length === 0 ? a : a[0].toLowerCase() + a.slice(1);
}
var tsProto = {};
Object.defineProperty(tsProto, "__esModule", { value: !0 });
tsProto.isTsProtoServiceDefinition = tsProto.fromTsProtoServiceDefinition = void 0;
function fromTsProtoServiceDefinition(a) {
  const u = {};
  for (const [c, l] of Object.entries(a.methods)) {
    const v = l.requestType.encode, p = l.requestType.fromPartial, _ = l.responseType.encode, k = l.responseType.fromPartial;
    u[c] = {
      path: `/${a.fullName}/${l.name}`,
      requestStream: l.requestStream,
      responseStream: l.responseStream,
      requestDeserialize: l.requestType.decode,
      requestSerialize: p != null ? (O) => v(p(O)).finish() : (O) => v(O).finish(),
      responseDeserialize: l.responseType.decode,
      responseSerialize: k != null ? (O) => _(k(O)).finish() : (O) => _(O).finish(),
      options: l.options
    };
  }
  return u;
}
tsProto.fromTsProtoServiceDefinition = fromTsProtoServiceDefinition;
function isTsProtoServiceDefinition(a) {
  return "name" in a && "fullName" in a && "methods" in a;
}
tsProto.isTsProtoServiceDefinition = isTsProtoServiceDefinition;
Object.defineProperty(serviceDefinitions, "__esModule", { value: !0 });
serviceDefinitions.toGrpcWebMethodDefinition = serviceDefinitions.normalizeServiceDefinition = void 0;
const grpc_web_1$5 = grpcWeb, ts_proto_1 = tsProto;
function normalizeServiceDefinition(a) {
  return (0, grpc_web_1$5.isGrpcWebServiceDefinition)(a) ? (0, grpc_web_1$5.fromGrpcWebServiceDefinition)(a) : (0, ts_proto_1.isTsProtoServiceDefinition)(a) ? (0, ts_proto_1.fromTsProtoServiceDefinition)(a) : a;
}
serviceDefinitions.normalizeServiceDefinition = normalizeServiceDefinition;
function toGrpcWebMethodDefinition(a) {
  const [, u, c] = a.path.split("/");
  return {
    service: {
      serviceName: u
    },
    methodName: c,
    requestStream: a.requestStream,
    responseStream: a.responseStream,
    requestType: class {
      constructor() {
        throw new Error("Unexpected instantiation");
      }
      static deserializeBinary(l) {
        return a.requestDeserialize(l);
      }
    },
    responseType: class {
      constructor() {
        throw new Error("Unexpected instantiation");
      }
      static deserializeBinary(l) {
        return a.responseDeserialize(l);
      }
    }
  };
}
serviceDefinitions.toGrpcWebMethodDefinition = toGrpcWebMethodDefinition;
var channel = {};
Object.defineProperty(channel, "__esModule", { value: !0 });
channel.createChannel = void 0;
function createChannel(a, u) {
  return { address: a, transport: u };
}
channel.createChannel = createChannel;
var ClientFactory = {}, createBidiStreamingMethod$1 = {}, grpcWebClient_umd = { exports: {} };
(function(a, u) {
  (function(c, l) {
    a.exports = l();
  })(commonjsGlobal$1, function() {
    return c = { 418: function(v, p) {
      (function(_, k) {
        for (var O in k)
          _[O] = k[O];
      })(p, function(_) {
        var k = {};
        function O(D) {
          if (k[D])
            return k[D].exports;
          var F = k[D] = { i: D, l: !1, exports: {} };
          return _[D].call(F.exports, F, F.exports, O), F.l = !0, F.exports;
        }
        return O.m = _, O.c = k, O.i = function(D) {
          return D;
        }, O.d = function(D, F, z) {
          O.o(D, F) || Object.defineProperty(D, F, { configurable: !1, enumerable: !0, get: z });
        }, O.n = function(D) {
          var F = D && D.__esModule ? function() {
            return D.default;
          } : function() {
            return D;
          };
          return O.d(F, "a", F), F;
        }, O.o = function(D, F) {
          return Object.prototype.hasOwnProperty.call(D, F);
        }, O.p = "", O(O.s = 1);
      }([function(_, k, O) {
        Object.defineProperty(k, "__esModule", { value: !0 });
        var D = O(3), F = function() {
          function z(j, ee) {
            j === void 0 && (j = {}), ee === void 0 && (ee = { splitValues: !1 });
            var X, ae = this;
            this.headersMap = {}, j && (typeof Headers < "u" && j instanceof Headers ? D.getHeaderKeys(j).forEach(function(Q) {
              D.getHeaderValues(j, Q).forEach(function(ne) {
                ee.splitValues ? ae.append(Q, D.splitHeaderValue(ne)) : ae.append(Q, ne);
              });
            }) : typeof (X = j) == "object" && typeof X.headersMap == "object" && typeof X.forEach == "function" ? j.forEach(function(Q, ne) {
              ae.append(Q, ne);
            }) : typeof Map < "u" && j instanceof Map ? j.forEach(function(Q, ne) {
              ae.append(ne, Q);
            }) : typeof j == "string" ? this.appendFromString(j) : typeof j == "object" && Object.getOwnPropertyNames(j).forEach(function(Q) {
              var ne = j[Q];
              Array.isArray(ne) ? ne.forEach(function(Z) {
                ae.append(Q, Z);
              }) : ae.append(Q, ne);
            }));
          }
          return z.prototype.appendFromString = function(j) {
            for (var ee = j.split(`\r
`), X = 0; X < ee.length; X++) {
              var ae = ee[X], Q = ae.indexOf(":");
              if (Q > 0) {
                var ne = ae.substring(0, Q).trim(), Z = ae.substring(Q + 1).trim();
                this.append(ne, Z);
              }
            }
          }, z.prototype.delete = function(j, ee) {
            var X = D.normalizeName(j);
            if (ee === void 0)
              delete this.headersMap[X];
            else {
              var ae = this.headersMap[X];
              if (ae) {
                var Q = ae.indexOf(ee);
                Q >= 0 && ae.splice(Q, 1), ae.length === 0 && delete this.headersMap[X];
              }
            }
          }, z.prototype.append = function(j, ee) {
            var X = this, ae = D.normalizeName(j);
            Array.isArray(this.headersMap[ae]) || (this.headersMap[ae] = []), Array.isArray(ee) ? ee.forEach(function(Q) {
              X.headersMap[ae].push(D.normalizeValue(Q));
            }) : this.headersMap[ae].push(D.normalizeValue(ee));
          }, z.prototype.set = function(j, ee) {
            var X = D.normalizeName(j);
            if (Array.isArray(ee)) {
              var ae = [];
              ee.forEach(function(Q) {
                ae.push(D.normalizeValue(Q));
              }), this.headersMap[X] = ae;
            } else
              this.headersMap[X] = [D.normalizeValue(ee)];
          }, z.prototype.has = function(j, ee) {
            var X = this.headersMap[D.normalizeName(j)];
            if (!Array.isArray(X))
              return !1;
            if (ee !== void 0) {
              var ae = D.normalizeValue(ee);
              return X.indexOf(ae) >= 0;
            }
            return !0;
          }, z.prototype.get = function(j) {
            var ee = this.headersMap[D.normalizeName(j)];
            return ee !== void 0 ? ee.concat() : [];
          }, z.prototype.forEach = function(j) {
            var ee = this;
            Object.getOwnPropertyNames(this.headersMap).forEach(function(X) {
              j(X, ee.headersMap[X]);
            }, this);
          }, z.prototype.toHeaders = function() {
            if (typeof Headers < "u") {
              var j = new Headers();
              return this.forEach(function(ee, X) {
                X.forEach(function(ae) {
                  j.append(ee, ae);
                });
              }), j;
            }
            throw new Error("Headers class is not defined");
          }, z;
        }();
        k.BrowserHeaders = F;
      }, function(_, k, O) {
        Object.defineProperty(k, "__esModule", { value: !0 });
        var D = O(0);
        k.BrowserHeaders = D.BrowserHeaders;
      }, function(_, k, O) {
        Object.defineProperty(k, "__esModule", { value: !0 }), k.iterateHeaders = function(D, F) {
          for (var z = D[Symbol.iterator](), j = z.next(); !j.done; )
            F(j.value[0]), j = z.next();
        }, k.iterateHeadersKeys = function(D, F) {
          for (var z = D.keys(), j = z.next(); !j.done; )
            F(j.value), j = z.next();
        };
      }, function(_, k, O) {
        Object.defineProperty(k, "__esModule", { value: !0 });
        var D = O(2);
        k.normalizeName = function(F) {
          if (typeof F != "string" && (F = String(F)), /[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(F))
            throw new TypeError("Invalid character in header field name");
          return F.toLowerCase();
        }, k.normalizeValue = function(F) {
          return typeof F != "string" && (F = String(F)), F;
        }, k.getHeaderValues = function(F, z) {
          var j = F;
          if (j instanceof Headers && j.getAll)
            return j.getAll(z);
          var ee = j.get(z);
          return ee && typeof ee == "string" ? [ee] : ee;
        }, k.getHeaderKeys = function(F) {
          var z = F, j = {}, ee = [];
          return z.keys ? D.iterateHeadersKeys(z, function(X) {
            j[X] || (j[X] = !0, ee.push(X));
          }) : z.forEach ? z.forEach(function(X, ae) {
            j[ae] || (j[ae] = !0, ee.push(ae));
          }) : D.iterateHeaders(z, function(X) {
            var ae = X[0];
            j[ae] || (j[ae] = !0, ee.push(ae));
          }), ee;
        }, k.splitHeaderValue = function(F) {
          var z = [];
          return F.split(", ").forEach(function(j) {
            j.split(",").forEach(function(ee) {
              z.push(ee);
            });
          }), z;
        };
      }]));
    }, 617: function(v, p, _) {
      Object.defineProperty(p, "__esModule", { value: !0 }), p.ChunkParser = p.ChunkType = p.encodeASCII = p.decodeASCII = void 0;
      var k, O = _(65);
      function D(Q) {
        return (ne = Q) === 9 || ne === 10 || ne === 13 || Q >= 32 && Q <= 126;
        var ne;
      }
      function F(Q) {
        for (var ne = 0; ne !== Q.length; ++ne)
          if (!D(Q[ne]))
            throw new Error("Metadata is not valid (printable) ASCII");
        return String.fromCharCode.apply(String, Array.prototype.slice.call(Q));
      }
      function z(Q) {
        return (128 & Q.getUint8(0)) == 128;
      }
      function j(Q) {
        return Q.getUint32(1, !1);
      }
      function ee(Q, ne, Z) {
        return Q.byteLength - ne >= Z;
      }
      function X(Q, ne, Z) {
        if (Q.slice)
          return Q.slice(ne, Z);
        var de = Q.length;
        Z !== void 0 && (de = Z);
        for (var fe = new Uint8Array(de - ne), Te = 0, Re = ne; Re < de; Re++)
          fe[Te++] = Q[Re];
        return fe;
      }
      p.decodeASCII = F, p.encodeASCII = function(Q) {
        for (var ne = new Uint8Array(Q.length), Z = 0; Z !== Q.length; ++Z) {
          var de = Q.charCodeAt(Z);
          if (!D(de))
            throw new Error("Metadata contains invalid ASCII");
          ne[Z] = de;
        }
        return ne;
      }, function(Q) {
        Q[Q.MESSAGE = 1] = "MESSAGE", Q[Q.TRAILERS = 2] = "TRAILERS";
      }(k = p.ChunkType || (p.ChunkType = {}));
      var ae = function() {
        function Q() {
          this.buffer = null, this.position = 0;
        }
        return Q.prototype.parse = function(ne, Z) {
          if (ne.length === 0 && Z)
            return [];
          var de, fe = [];
          if (this.buffer == null)
            this.buffer = ne, this.position = 0;
          else if (this.position === this.buffer.byteLength)
            this.buffer = ne, this.position = 0;
          else {
            var Te = this.buffer.byteLength - this.position, Re = new Uint8Array(Te + ne.byteLength), Le = X(this.buffer, this.position);
            Re.set(Le, 0);
            var be = new Uint8Array(ne);
            Re.set(be, Te), this.buffer = Re, this.position = 0;
          }
          for (; ; ) {
            if (!ee(this.buffer, this.position, 5))
              return fe;
            var q = X(this.buffer, this.position, this.position + 5), J = new DataView(q.buffer, q.byteOffset, q.byteLength), C = j(J);
            if (!ee(this.buffer, this.position, 5 + C))
              return fe;
            var S = X(this.buffer, this.position + 5, this.position + 5 + C);
            if (this.position += 5 + C, z(J))
              return fe.push({ chunkType: k.TRAILERS, trailers: (de = S, new O.Metadata(F(de))) }), fe;
            fe.push({ chunkType: k.MESSAGE, data: S });
          }
        }, Q;
      }();
      p.ChunkParser = ae;
    }, 8: function(v, p) {
      var _;
      Object.defineProperty(p, "__esModule", { value: !0 }), p.httpStatusToCode = p.Code = void 0, function(k) {
        k[k.OK = 0] = "OK", k[k.Canceled = 1] = "Canceled", k[k.Unknown = 2] = "Unknown", k[k.InvalidArgument = 3] = "InvalidArgument", k[k.DeadlineExceeded = 4] = "DeadlineExceeded", k[k.NotFound = 5] = "NotFound", k[k.AlreadyExists = 6] = "AlreadyExists", k[k.PermissionDenied = 7] = "PermissionDenied", k[k.ResourceExhausted = 8] = "ResourceExhausted", k[k.FailedPrecondition = 9] = "FailedPrecondition", k[k.Aborted = 10] = "Aborted", k[k.OutOfRange = 11] = "OutOfRange", k[k.Unimplemented = 12] = "Unimplemented", k[k.Internal = 13] = "Internal", k[k.Unavailable = 14] = "Unavailable", k[k.DataLoss = 15] = "DataLoss", k[k.Unauthenticated = 16] = "Unauthenticated";
      }(_ = p.Code || (p.Code = {})), p.httpStatusToCode = function(k) {
        switch (k) {
          case 0:
            return _.Internal;
          case 200:
            return _.OK;
          case 400:
            return _.InvalidArgument;
          case 401:
            return _.Unauthenticated;
          case 403:
            return _.PermissionDenied;
          case 404:
            return _.NotFound;
          case 409:
            return _.Aborted;
          case 412:
            return _.FailedPrecondition;
          case 429:
            return _.ResourceExhausted;
          case 499:
            return _.Canceled;
          case 500:
            return _.Unknown;
          case 501:
            return _.Unimplemented;
          case 503:
            return _.Unavailable;
          case 504:
            return _.DeadlineExceeded;
          default:
            return _.Unknown;
        }
      };
    }, 934: function(v, p, _) {
      Object.defineProperty(p, "__esModule", { value: !0 }), p.client = void 0;
      var k = _(65), O = _(617), D = _(8), F = _(346), z = _(57), j = _(882);
      p.client = function(ae, Q) {
        return new ee(ae, Q);
      };
      var ee = function() {
        function ae(Q, ne) {
          this.started = !1, this.sentFirstMessage = !1, this.completed = !1, this.closed = !1, this.finishedSending = !1, this.onHeadersCallbacks = [], this.onMessageCallbacks = [], this.onEndCallbacks = [], this.parser = new O.ChunkParser(), this.methodDefinition = Q, this.props = ne, this.createTransport();
        }
        return ae.prototype.createTransport = function() {
          var Q = this.props.host + "/" + this.methodDefinition.service.serviceName + "/" + this.methodDefinition.methodName, ne = { methodDefinition: this.methodDefinition, debug: this.props.debug || !1, url: Q, onHeaders: this.onTransportHeaders.bind(this), onChunk: this.onTransportChunk.bind(this), onEnd: this.onTransportEnd.bind(this) };
          this.props.transport ? this.transport = this.props.transport(ne) : this.transport = z.makeDefaultTransport(ne);
        }, ae.prototype.onTransportHeaders = function(Q, ne) {
          if (this.props.debug && F.debug("onHeaders", Q, ne), this.closed)
            this.props.debug && F.debug("grpc.onHeaders received after request was closed - ignoring");
          else if (ne !== 0) {
            this.responseHeaders = Q, this.props.debug && F.debug("onHeaders.responseHeaders", JSON.stringify(this.responseHeaders, null, 2));
            var Z = X(Q);
            this.props.debug && F.debug("onHeaders.gRPCStatus", Z);
            var de = Z && Z >= 0 ? Z : D.httpStatusToCode(ne);
            this.props.debug && F.debug("onHeaders.code", de);
            var fe = Q.get("grpc-message") || [];
            if (this.props.debug && F.debug("onHeaders.gRPCMessage", fe), this.rawOnHeaders(Q), de !== D.Code.OK) {
              var Te = this.decodeGRPCStatus(fe[0]);
              this.rawOnError(de, Te, Q);
            }
          }
        }, ae.prototype.onTransportChunk = function(Q) {
          var ne = this;
          if (this.closed)
            this.props.debug && F.debug("grpc.onChunk received after request was closed - ignoring");
          else {
            var Z = [];
            try {
              Z = this.parser.parse(Q);
            } catch (de) {
              return this.props.debug && F.debug("onChunk.parsing error", de, de.message), void this.rawOnError(D.Code.Internal, "parsing error: " + de.message);
            }
            Z.forEach(function(de) {
              if (de.chunkType === O.ChunkType.MESSAGE) {
                var fe = ne.methodDefinition.responseType.deserializeBinary(de.data);
                ne.rawOnMessage(fe);
              } else
                de.chunkType === O.ChunkType.TRAILERS && (ne.responseHeaders ? (ne.responseTrailers = new k.Metadata(de.trailers), ne.props.debug && F.debug("onChunk.trailers", ne.responseTrailers)) : (ne.responseHeaders = new k.Metadata(de.trailers), ne.rawOnHeaders(ne.responseHeaders)));
            });
          }
        }, ae.prototype.onTransportEnd = function() {
          if (this.props.debug && F.debug("grpc.onEnd"), this.closed)
            this.props.debug && F.debug("grpc.onEnd received after request was closed - ignoring");
          else if (this.responseTrailers !== void 0) {
            var Q = X(this.responseTrailers);
            if (Q !== null) {
              var ne = this.responseTrailers.get("grpc-message"), Z = this.decodeGRPCStatus(ne[0]);
              this.rawOnEnd(Q, Z, this.responseTrailers);
            } else
              this.rawOnError(D.Code.Internal, "Response closed without grpc-status (Trailers provided)");
          } else {
            if (this.responseHeaders === void 0)
              return void this.rawOnError(D.Code.Unknown, "Response closed without headers");
            var de = X(this.responseHeaders), fe = this.responseHeaders.get("grpc-message");
            if (this.props.debug && F.debug("grpc.headers only response ", de, fe), de === null)
              return void this.rawOnEnd(D.Code.Unknown, "Response closed without grpc-status (Headers only)", this.responseHeaders);
            var Te = this.decodeGRPCStatus(fe[0]);
            this.rawOnEnd(de, Te, this.responseHeaders);
          }
        }, ae.prototype.decodeGRPCStatus = function(Q) {
          if (!Q)
            return "";
          try {
            return decodeURIComponent(Q);
          } catch {
            return Q;
          }
        }, ae.prototype.rawOnEnd = function(Q, ne, Z) {
          var de = this;
          this.props.debug && F.debug("rawOnEnd", Q, ne, Z), this.completed || (this.completed = !0, this.onEndCallbacks.forEach(function(fe) {
            if (!de.closed)
              try {
                fe(Q, ne, Z);
              } catch (Te) {
                setTimeout(function() {
                  throw Te;
                }, 0);
              }
          }));
        }, ae.prototype.rawOnHeaders = function(Q) {
          this.props.debug && F.debug("rawOnHeaders", Q), this.completed || this.onHeadersCallbacks.forEach(function(ne) {
            try {
              ne(Q);
            } catch (Z) {
              setTimeout(function() {
                throw Z;
              }, 0);
            }
          });
        }, ae.prototype.rawOnError = function(Q, ne, Z) {
          var de = this;
          Z === void 0 && (Z = new k.Metadata()), this.props.debug && F.debug("rawOnError", Q, ne), this.completed || (this.completed = !0, this.onEndCallbacks.forEach(function(fe) {
            if (!de.closed)
              try {
                fe(Q, ne, Z);
              } catch (Te) {
                setTimeout(function() {
                  throw Te;
                }, 0);
              }
          }));
        }, ae.prototype.rawOnMessage = function(Q) {
          var ne = this;
          this.props.debug && F.debug("rawOnMessage", Q.toObject()), this.completed || this.closed || this.onMessageCallbacks.forEach(function(Z) {
            if (!ne.closed)
              try {
                Z(Q);
              } catch (de) {
                setTimeout(function() {
                  throw de;
                }, 0);
              }
          });
        }, ae.prototype.onHeaders = function(Q) {
          this.onHeadersCallbacks.push(Q);
        }, ae.prototype.onMessage = function(Q) {
          this.onMessageCallbacks.push(Q);
        }, ae.prototype.onEnd = function(Q) {
          this.onEndCallbacks.push(Q);
        }, ae.prototype.start = function(Q) {
          if (this.started)
            throw new Error("Client already started - cannot .start()");
          this.started = !0;
          var ne = new k.Metadata(Q || {});
          ne.set("content-type", "application/grpc-web+proto"), ne.set("x-grpc-web", "1"), this.transport.start(ne);
        }, ae.prototype.send = function(Q) {
          if (!this.started)
            throw new Error("Client not started - .start() must be called before .send()");
          if (this.closed)
            throw new Error("Client already closed - cannot .send()");
          if (this.finishedSending)
            throw new Error("Client already finished sending - cannot .send()");
          if (!this.methodDefinition.requestStream && this.sentFirstMessage)
            throw new Error("Message already sent for non-client-streaming method - cannot .send()");
          this.sentFirstMessage = !0;
          var ne = j.frameRequest(Q);
          this.transport.sendMessage(ne);
        }, ae.prototype.finishSend = function() {
          if (!this.started)
            throw new Error("Client not started - .finishSend() must be called before .close()");
          if (this.closed)
            throw new Error("Client already closed - cannot .send()");
          if (this.finishedSending)
            throw new Error("Client already finished sending - cannot .finishSend()");
          this.finishedSending = !0, this.transport.finishSend();
        }, ae.prototype.close = function() {
          if (!this.started)
            throw new Error("Client not started - .start() must be called before .close()");
          if (this.closed)
            throw new Error("Client already closed - cannot .close()");
          this.closed = !0, this.props.debug && F.debug("request.abort aborting request"), this.transport.cancel();
        }, ae;
      }();
      function X(ae) {
        var Q = ae.get("grpc-status") || [];
        if (Q.length > 0)
          try {
            var ne = Q[0];
            return parseInt(ne, 10);
          } catch {
            return null;
          }
        return null;
      }
    }, 346: function(v, p) {
      Object.defineProperty(p, "__esModule", { value: !0 }), p.debug = void 0, p.debug = function() {
        for (var _ = [], k = 0; k < arguments.length; k++)
          _[k] = arguments[k];
        console.debug ? console.debug.apply(null, _) : console.log.apply(null, _);
      };
    }, 607: function(v, p, _) {
      Object.defineProperty(p, "__esModule", { value: !0 }), p.grpc = void 0;
      var k, O = _(418), D = _(57), F = _(229), z = _(540), j = _(210), ee = _(859), X = _(8), ae = _(938), Q = _(35), ne = _(934);
      (k = p.grpc || (p.grpc = {})).setDefaultTransport = D.setDefaultTransportFactory, k.CrossBrowserHttpTransport = ee.CrossBrowserHttpTransport, k.FetchReadableStreamTransport = F.FetchReadableStreamTransport, k.XhrTransport = j.XhrTransport, k.WebsocketTransport = z.WebsocketTransport, k.Code = X.Code, k.Metadata = O.BrowserHeaders, k.client = function(Z, de) {
        return ne.client(Z, de);
      }, k.invoke = ae.invoke, k.unary = Q.unary;
    }, 938: function(v, p, _) {
      Object.defineProperty(p, "__esModule", { value: !0 }), p.invoke = void 0;
      var k = _(934);
      p.invoke = function(O, D) {
        if (O.requestStream)
          throw new Error(".invoke cannot be used with client-streaming methods. Use .client instead.");
        var F = k.client(O, { host: D.host, transport: D.transport, debug: D.debug });
        return D.onHeaders && F.onHeaders(D.onHeaders), D.onMessage && F.onMessage(D.onMessage), D.onEnd && F.onEnd(D.onEnd), F.start(D.metadata), F.send(D.request), F.finishSend(), { close: function() {
          F.close();
        } };
      };
    }, 65: function(v, p, _) {
      Object.defineProperty(p, "__esModule", { value: !0 }), p.Metadata = void 0;
      var k = _(418);
      Object.defineProperty(p, "Metadata", { enumerable: !0, get: function() {
        return k.BrowserHeaders;
      } });
    }, 57: function(v, p, _) {
      Object.defineProperty(p, "__esModule", { value: !0 }), p.makeDefaultTransport = p.setDefaultTransportFactory = void 0;
      var k = _(859), O = function(D) {
        return k.CrossBrowserHttpTransport({ withCredentials: !1 })(D);
      };
      p.setDefaultTransportFactory = function(D) {
        O = D;
      }, p.makeDefaultTransport = function(D) {
        return O(D);
      };
    }, 229: function(v, p, _) {
      var k = this && this.__assign || function() {
        return (k = Object.assign || function(z) {
          for (var j, ee = 1, X = arguments.length; ee < X; ee++)
            for (var ae in j = arguments[ee])
              Object.prototype.hasOwnProperty.call(j, ae) && (z[ae] = j[ae]);
          return z;
        }).apply(this, arguments);
      };
      Object.defineProperty(p, "__esModule", { value: !0 }), p.detectFetchSupport = p.FetchReadableStreamTransport = void 0;
      var O = _(65), D = _(346);
      p.FetchReadableStreamTransport = function(z) {
        return function(j) {
          return function(ee, X) {
            return ee.debug && D.debug("fetchRequest", ee), new F(ee, X);
          }(j, z);
        };
      };
      var F = function() {
        function z(j, ee) {
          this.cancelled = !1, this.controller = self.AbortController && new AbortController(), this.options = j, this.init = ee;
        }
        return z.prototype.pump = function(j, ee) {
          var X = this;
          if (this.reader = j, this.cancelled)
            return this.options.debug && D.debug("Fetch.pump.cancel at first pump"), void this.reader.cancel().catch(function(ae) {
              X.options.debug && D.debug("Fetch.pump.reader.cancel exception", ae);
            });
          this.reader.read().then(function(ae) {
            if (ae.done)
              return X.options.onEnd(), ee;
            X.options.onChunk(ae.value), X.pump(X.reader, ee);
          }).catch(function(ae) {
            X.cancelled ? X.options.debug && D.debug("Fetch.catch - request cancelled") : (X.cancelled = !0, X.options.debug && D.debug("Fetch.catch", ae.message), X.options.onEnd(ae));
          });
        }, z.prototype.send = function(j) {
          var ee = this;
          fetch(this.options.url, k(k({}, this.init), { headers: this.metadata.toHeaders(), method: "POST", body: j, signal: this.controller && this.controller.signal })).then(function(X) {
            if (ee.options.debug && D.debug("Fetch.response", X), ee.options.onHeaders(new O.Metadata(X.headers), X.status), !X.body)
              return X;
            ee.pump(X.body.getReader(), X);
          }).catch(function(X) {
            ee.cancelled ? ee.options.debug && D.debug("Fetch.catch - request cancelled") : (ee.cancelled = !0, ee.options.debug && D.debug("Fetch.catch", X.message), ee.options.onEnd(X));
          });
        }, z.prototype.sendMessage = function(j) {
          this.send(j);
        }, z.prototype.finishSend = function() {
        }, z.prototype.start = function(j) {
          this.metadata = j;
        }, z.prototype.cancel = function() {
          var j = this;
          this.cancelled ? this.options.debug && D.debug("Fetch.cancel already cancelled") : (this.cancelled = !0, this.controller ? (this.options.debug && D.debug("Fetch.cancel.controller.abort"), this.controller.abort()) : this.options.debug && D.debug("Fetch.cancel.missing abort controller"), this.reader ? (this.options.debug && D.debug("Fetch.cancel.reader.cancel"), this.reader.cancel().catch(function(ee) {
            j.options.debug && D.debug("Fetch.cancel.reader.cancel exception", ee);
          })) : this.options.debug && D.debug("Fetch.cancel before reader"));
        }, z;
      }();
      p.detectFetchSupport = function() {
        return typeof Response < "u" && Response.prototype.hasOwnProperty("body") && typeof Headers == "function";
      };
    }, 859: function(v, p, _) {
      Object.defineProperty(p, "__esModule", { value: !0 }), p.CrossBrowserHttpTransport = void 0;
      var k = _(229), O = _(210);
      p.CrossBrowserHttpTransport = function(D) {
        if (k.detectFetchSupport()) {
          var F = { credentials: D.withCredentials ? "include" : "same-origin" };
          return k.FetchReadableStreamTransport(F);
        }
        return O.XhrTransport({ withCredentials: D.withCredentials });
      };
    }, 210: function(v, p, _) {
      var k, O = this && this.__extends || (k = function(Q, ne) {
        return (k = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(Z, de) {
          Z.__proto__ = de;
        } || function(Z, de) {
          for (var fe in de)
            Object.prototype.hasOwnProperty.call(de, fe) && (Z[fe] = de[fe]);
        })(Q, ne);
      }, function(Q, ne) {
        function Z() {
          this.constructor = Q;
        }
        k(Q, ne), Q.prototype = ne === null ? Object.create(ne) : (Z.prototype = ne.prototype, new Z());
      });
      Object.defineProperty(p, "__esModule", { value: !0 }), p.stringToArrayBuffer = p.MozChunkedArrayBufferXHR = p.XHR = p.XhrTransport = void 0;
      var D = _(65), F = _(346), z = _(849);
      p.XhrTransport = function(Q) {
        return function(ne) {
          if (z.detectMozXHRSupport())
            return new ee(ne, Q);
          if (z.detectXHROverrideMimeTypeSupport())
            return new j(ne, Q);
          throw new Error("This environment's XHR implementation cannot support binary transfer.");
        };
      };
      var j = function() {
        function Q(ne, Z) {
          this.options = ne, this.init = Z;
        }
        return Q.prototype.onProgressEvent = function() {
          this.options.debug && F.debug("XHR.onProgressEvent.length: ", this.xhr.response.length);
          var ne = this.xhr.response.substr(this.index);
          this.index = this.xhr.response.length;
          var Z = ae(ne);
          this.options.onChunk(Z);
        }, Q.prototype.onLoadEvent = function() {
          this.options.debug && F.debug("XHR.onLoadEvent"), this.options.onEnd();
        }, Q.prototype.onStateChange = function() {
          this.options.debug && F.debug("XHR.onStateChange", this.xhr.readyState), this.xhr.readyState === XMLHttpRequest.HEADERS_RECEIVED && this.options.onHeaders(new D.Metadata(this.xhr.getAllResponseHeaders()), this.xhr.status);
        }, Q.prototype.sendMessage = function(ne) {
          this.xhr.send(ne);
        }, Q.prototype.finishSend = function() {
        }, Q.prototype.start = function(ne) {
          var Z = this;
          this.metadata = ne;
          var de = new XMLHttpRequest();
          this.xhr = de, de.open("POST", this.options.url), this.configureXhr(), this.metadata.forEach(function(fe, Te) {
            de.setRequestHeader(fe, Te.join(", "));
          }), de.withCredentials = !!this.init.withCredentials, de.addEventListener("readystatechange", this.onStateChange.bind(this)), de.addEventListener("progress", this.onProgressEvent.bind(this)), de.addEventListener("loadend", this.onLoadEvent.bind(this)), de.addEventListener("error", function(fe) {
            Z.options.debug && F.debug("XHR.error", fe), Z.options.onEnd(fe.error);
          });
        }, Q.prototype.configureXhr = function() {
          this.xhr.responseType = "text", this.xhr.overrideMimeType("text/plain; charset=x-user-defined");
        }, Q.prototype.cancel = function() {
          this.options.debug && F.debug("XHR.abort"), this.xhr.abort();
        }, Q;
      }();
      p.XHR = j;
      var ee = function(Q) {
        function ne() {
          return Q !== null && Q.apply(this, arguments) || this;
        }
        return O(ne, Q), ne.prototype.configureXhr = function() {
          this.options.debug && F.debug("MozXHR.configureXhr: setting responseType to 'moz-chunked-arraybuffer'"), this.xhr.responseType = "moz-chunked-arraybuffer";
        }, ne.prototype.onProgressEvent = function() {
          var Z = this.xhr.response;
          this.options.debug && F.debug("MozXHR.onProgressEvent: ", new Uint8Array(Z)), this.options.onChunk(new Uint8Array(Z));
        }, ne;
      }(j);
      function X(Q, ne) {
        var Z = Q.charCodeAt(ne);
        if (Z >= 55296 && Z <= 56319) {
          var de = Q.charCodeAt(ne + 1);
          de >= 56320 && de <= 57343 && (Z = 65536 + (Z - 55296 << 10) + (de - 56320));
        }
        return Z;
      }
      function ae(Q) {
        for (var ne = new Uint8Array(Q.length), Z = 0, de = 0; de < Q.length; de++) {
          var fe = String.prototype.codePointAt ? Q.codePointAt(de) : X(Q, de);
          ne[Z++] = 255 & fe;
        }
        return ne;
      }
      p.MozChunkedArrayBufferXHR = ee, p.stringToArrayBuffer = ae;
    }, 849: function(v, p) {
      var _;
      function k() {
        if (_ !== void 0)
          return _;
        if (XMLHttpRequest) {
          _ = new XMLHttpRequest();
          try {
            _.open("GET", "https://localhost");
          } catch {
          }
        }
        return _;
      }
      function O(D) {
        var F = k();
        if (!F)
          return !1;
        try {
          return F.responseType = D, F.responseType === D;
        } catch {
        }
        return !1;
      }
      Object.defineProperty(p, "__esModule", { value: !0 }), p.detectXHROverrideMimeTypeSupport = p.detectMozXHRSupport = p.xhrSupportsResponseType = void 0, p.xhrSupportsResponseType = O, p.detectMozXHRSupport = function() {
        return typeof XMLHttpRequest < "u" && O("moz-chunked-arraybuffer");
      }, p.detectXHROverrideMimeTypeSupport = function() {
        return typeof XMLHttpRequest < "u" && XMLHttpRequest.prototype.hasOwnProperty("overrideMimeType");
      };
    }, 540: function(v, p, _) {
      Object.defineProperty(p, "__esModule", { value: !0 }), p.WebsocketTransport = void 0;
      var k, O = _(346), D = _(617);
      (function(z) {
        z[z.FINISH_SEND = 1] = "FINISH_SEND";
      })(k || (k = {}));
      var F = new Uint8Array([1]);
      p.WebsocketTransport = function() {
        return function(z) {
          return function(j) {
            j.debug && O.debug("websocketRequest", j);
            var ee, X = function(ne) {
              if (ne.substr(0, 8) === "https://")
                return "wss://" + ne.substr(8);
              if (ne.substr(0, 7) === "http://")
                return "ws://" + ne.substr(7);
              throw new Error("Websocket transport constructed with non-https:// or http:// host.");
            }(j.url), ae = [];
            function Q(ne) {
              if (ne === k.FINISH_SEND)
                ee.send(F);
              else {
                var Z = ne, de = new Int8Array(Z.byteLength + 1);
                de.set(new Uint8Array([0])), de.set(Z, 1), ee.send(de);
              }
            }
            return { sendMessage: function(ne) {
              ee && ee.readyState !== ee.CONNECTING ? Q(ne) : ae.push(ne);
            }, finishSend: function() {
              ee && ee.readyState !== ee.CONNECTING ? Q(k.FINISH_SEND) : ae.push(k.FINISH_SEND);
            }, start: function(ne) {
              (ee = new WebSocket(X, ["grpc-websockets"])).binaryType = "arraybuffer", ee.onopen = function() {
                var Z;
                j.debug && O.debug("websocketRequest.onopen"), ee.send((Z = "", ne.forEach(function(de, fe) {
                  Z += de + ": " + fe.join(", ") + `\r
`;
                }), D.encodeASCII(Z))), ae.forEach(function(de) {
                  Q(de);
                });
              }, ee.onclose = function(Z) {
                j.debug && O.debug("websocketRequest.onclose", Z), j.onEnd();
              }, ee.onerror = function(Z) {
                j.debug && O.debug("websocketRequest.onerror", Z);
              }, ee.onmessage = function(Z) {
                j.onChunk(new Uint8Array(Z.data));
              };
            }, cancel: function() {
              j.debug && O.debug("websocket.abort"), ee.close();
            } };
          }(z);
        };
      };
    }, 35: function(v, p, _) {
      Object.defineProperty(p, "__esModule", { value: !0 }), p.unary = void 0;
      var k = _(65), O = _(934);
      p.unary = function(D, F) {
        if (D.responseStream)
          throw new Error(".unary cannot be used with server-streaming methods. Use .invoke or .client instead.");
        if (D.requestStream)
          throw new Error(".unary cannot be used with client-streaming methods. Use .client instead.");
        var z = null, j = null, ee = O.client(D, { host: F.host, transport: F.transport, debug: F.debug });
        return ee.onHeaders(function(X) {
          z = X;
        }), ee.onMessage(function(X) {
          j = X;
        }), ee.onEnd(function(X, ae, Q) {
          F.onEnd({ status: X, statusMessage: ae, headers: z || new k.Metadata(), message: j, trailers: Q });
        }), ee.start(F.metadata), ee.send(F.request), ee.finishSend(), { close: function() {
          ee.close();
        } };
      };
    }, 882: function(v, p) {
      Object.defineProperty(p, "__esModule", { value: !0 }), p.frameRequest = void 0, p.frameRequest = function(_) {
        var k = _.serializeBinary(), O = new ArrayBuffer(k.byteLength + 5);
        return new DataView(O, 1, 4).setUint32(0, k.length, !1), new Uint8Array(O, 5).set(k), new Uint8Array(O);
      };
    } }, l = {}, function v(p) {
      if (l[p])
        return l[p].exports;
      var _ = l[p] = { exports: {} };
      return c[p].call(_.exports, _, _.exports, v), _.exports;
    }(607);
    var c, l;
  });
})(grpcWebClient_umd);
var grpcWebClient_umdExports = grpcWebClient_umd.exports;
class AbortError extends Error {
  constructor() {
    super("The operation has been aborted"), this.message = "The operation has been aborted", this.name = "AbortError", typeof Error.captureStackTrace == "function" && Error.captureStackTrace(this, this.constructor);
  }
}
function isAbortError(a) {
  return typeof a == "object" && a !== null && a.name === "AbortError";
}
function throwIfAborted(a) {
  if (a.aborted)
    throw new AbortError();
}
function rethrowAbortError(a) {
  if (isAbortError(a))
    throw a;
}
function catchAbortError(a) {
  if (!isAbortError(a))
    throw a;
}
function execute(a, u) {
  return new Promise((c, l) => {
    if (a.aborted) {
      l(new AbortError());
      return;
    }
    let v, p = !1;
    function _() {
      p || (p = !0, v != null && v());
    }
    const k = u((O) => {
      c(O), _();
    }, (O) => {
      l(O), _();
    });
    if (!p) {
      const O = () => {
        const D = k();
        D == null ? l(new AbortError()) : D.then(() => {
          l(new AbortError());
        }, (F) => {
          l(F);
        }), _();
      };
      a.addEventListener("abort", O), v = () => {
        a.removeEventListener("abort", O);
      };
    }
  });
}
function abortable(a, u) {
  if (a.aborted) {
    const c = () => {
    };
    u.then(c, c);
  }
  return execute(a, (c, l) => (u.then(c, l), () => {
  }));
}
function delay$1(a, u) {
  return execute(a, (c) => {
    const l = typeof u == "number" ? u : u.getTime() - Date.now(), v = setTimeout(c, l);
    return () => {
      clearTimeout(v);
    };
  });
}
function forever(a) {
  return execute(a, () => () => {
  });
}
function waitForEvent(a, u, c, l) {
  return execute(a, (v) => {
    let p, _ = !1;
    return p = listen(u, c, (...O) => {
      v(O.length > 1 ? O : O[0]), _ = !0, p != null && p();
    }, l), _ && p(), () => {
      _ = !0, p != null && p();
    };
  });
}
function listen(a, u, c, l) {
  if (isEventTarget(a))
    return a.addEventListener(u, c, l), () => a.removeEventListener(u, c, l);
  if (isJQueryStyleEventEmitter(a))
    return a.on(u, c), () => a.off(u, c);
  if (isNodeStyleEventEmitter(a))
    return a.addListener(u, c), () => a.removeListener(u, c);
  throw new Error("Invalid event target");
}
function isNodeStyleEventEmitter(a) {
  return isFunction$4(a.addListener) && isFunction$4(a.removeListener);
}
function isJQueryStyleEventEmitter(a) {
  return isFunction$4(a.on) && isFunction$4(a.off);
}
function isEventTarget(a) {
  return isFunction$4(a.addEventListener) && isFunction$4(a.removeEventListener);
}
const isFunction$4 = (a) => typeof a == "function";
var browser$g = { exports: {} };
const _global = typeof self < "u" ? self : typeof window < "u" ? window : (
  /* otherwise */
  void 0
);
if (!_global)
  throw new Error(
    "Unable to find global scope. Are you sure this is running in the browser?"
  );
if (!_global.AbortController)
  throw new Error(
    'Could not find "AbortController" in the global scope. You need to polyfill it first'
  );
browser$g.exports = _global.AbortController;
browser$g.exports.default = _global.AbortController;
var browserExports$2 = browser$g.exports;
const AbortController$1 = /* @__PURE__ */ getDefaultExportFromCjs$2(browserExports$2);
function all(a, u) {
  return new Promise((c, l) => {
    if (a.aborted) {
      l(new AbortError());
      return;
    }
    const v = new AbortController$1(), p = u(v.signal);
    if (p.length === 0) {
      c([]);
      return;
    }
    const _ = () => {
      v.abort();
    };
    a.addEventListener("abort", _);
    let k;
    const O = new Array(p.length);
    let D = 0;
    function F() {
      D += 1, D === p.length && (a.removeEventListener("abort", _), k != null ? l(k.reason) : c(O));
    }
    for (const [z, j] of p.entries())
      j.then((ee) => {
        O[z] = ee, F();
      }, (ee) => {
        v.abort(), (k == null || !isAbortError(ee) && isAbortError(k.reason)) && (k = { reason: ee }), F();
      });
  });
}
function race$2(a, u) {
  return new Promise((c, l) => {
    if (a.aborted) {
      l(new AbortError());
      return;
    }
    const v = new AbortController$1(), p = u(v.signal), _ = () => {
      v.abort();
    };
    a.addEventListener("abort", _);
    let k = 0;
    function O(F) {
      v.abort(), k += 1, k === p.length && (a.removeEventListener("abort", _), F.status === "fulfilled" ? c(F.value) : l(F.reason));
    }
    let D;
    for (const F of p)
      F.then((z) => {
        D == null && (D = { status: "fulfilled", value: z }), O(D);
      }, (z) => {
        (D == null || !isAbortError(z) && (D.status === "fulfilled" || isAbortError(D.reason))) && (D = { status: "rejected", reason: z }), O(D);
      });
  });
}
async function retry$1(a, u, c = {}) {
  const { baseMs: l = 1e3, maxDelayMs: v = 15e3, onError: p, maxAttempts: _ = 1 / 0 } = c;
  let k = 0;
  const O = () => {
    k = -1;
  };
  for (; ; )
    try {
      return await u(a, k, O);
    } catch (D) {
      if (rethrowAbortError(D), k >= _)
        throw D;
      let F;
      if (k === -1)
        F = 0;
      else {
        const z = Math.min(v, Math.pow(2, k) * l);
        F = Math.round(z * (1 + Math.random()) / 2);
      }
      p && p(D, k, F), F !== 0 && await delay$1(a, F), k += 1;
    }
}
function spawn(a, u) {
  if (a.aborted)
    return Promise.reject(new AbortError());
  const c = [], l = new AbortController$1(), v = l.signal, p = () => {
    l.abort();
  };
  a.addEventListener("abort", p);
  const _ = () => {
    a.removeEventListener("abort", p);
  }, k = /* @__PURE__ */ new Set(), O = () => {
    for (const z of k)
      z.abort();
  };
  v.addEventListener("abort", O);
  const D = () => {
    v.removeEventListener("abort", O);
  };
  let F = new Promise((z, j) => {
    let ee, X;
    ae((Q) => u(Q, {
      defer(ne) {
        c.push(ne);
      },
      fork: ae
    })).join().then((Q) => {
      l.abort(), ee = { value: Q };
    }, (Q) => {
      l.abort(), (!isAbortError(Q) || X == null) && (X = { error: Q });
    });
    function ae(Q) {
      if (v.aborted)
        return {
          abort() {
          },
          async join() {
            throw new AbortError();
          }
        };
      const ne = new AbortController$1(), Z = ne.signal, de = Q(Z), fe = {
        abort() {
          ne.abort();
        },
        join: () => de
      };
      return k.add(fe), de.catch(catchAbortError).catch((Te) => {
        X = { error: Te }, l.abort();
      }).finally(() => {
        k.delete(fe), k.size === 0 && (X != null ? j(X.error) : z(ee.value));
      }), fe;
    }
  });
  return F = F.finally(() => {
    _(), D();
    let z = Promise.resolve();
    for (let j = c.length - 1; j >= 0; j--)
      z = z.finally(c[j]);
    return z;
  }), F;
}
function run(a) {
  const u = new AbortController$1(), c = a(u.signal).catch(catchAbortError);
  return () => (u.abort(), c);
}
const es = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AbortError,
  abortable,
  all,
  catchAbortError,
  delay: delay$1,
  execute,
  forever,
  isAbortError,
  race: race$2,
  rethrowAbortError,
  retry: retry$1,
  run,
  spawn,
  throwIfAborted,
  waitForEvent
}, Symbol.toStringTag, { value: "Module" })), require$$1$3 = /* @__PURE__ */ getAugmentedNamespace(es);
var AsyncSink$1 = {};
Object.defineProperty(AsyncSink$1, "__esModule", { value: !0 });
AsyncSink$1.AsyncSink = void 0;
const ARRAY_VALUE = "value", ARRAY_ERROR = "error";
class AsyncSink {
  constructor() {
    this._ended = !1, this._values = [], this._resolvers = [];
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  write(u) {
    this._push({ type: ARRAY_VALUE, value: u });
  }
  error(u) {
    this._push({ type: ARRAY_ERROR, error: u });
  }
  _push(u) {
    if (this._ended)
      throw new Error("AsyncSink already ended");
    if (this._resolvers.length > 0) {
      const { resolve: c, reject: l } = this._resolvers.shift();
      u.type === ARRAY_ERROR ? l(u.error) : c({ done: !1, value: u.value });
    } else
      this._values.push(u);
  }
  next() {
    if (this._values.length > 0) {
      const { type: u, value: c, error: l } = this._values.shift();
      return u === ARRAY_ERROR ? Promise.reject(l) : Promise.resolve({ done: !1, value: c });
    }
    return this._ended ? Promise.resolve({ done: !0 }) : new Promise((u, c) => {
      this._resolvers.push({ resolve: u, reject: c });
    });
  }
  end() {
    for (; this._resolvers.length > 0; )
      this._resolvers.shift().resolve({ done: !0 });
    this._ended = !0;
  }
}
AsyncSink$1.AsyncSink = AsyncSink;
var isAsyncIterable$1 = {};
Object.defineProperty(isAsyncIterable$1, "__esModule", { value: !0 });
isAsyncIterable$1.isAsyncIterable = void 0;
function isAsyncIterable(a) {
  return a != null && Symbol.asyncIterator in a;
}
isAsyncIterable$1.isAsyncIterable = isAsyncIterable;
var convertMetadata = {}, buffer$3 = {}, base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [], revLookup = [], Arr = typeof Uint8Array < "u" ? Uint8Array : Array, code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$1 = 0, len = code.length; i$1 < len; ++i$1)
  lookup[i$1] = code[i$1], revLookup[code.charCodeAt(i$1)] = i$1;
revLookup[45] = 62;
revLookup[95] = 63;
function getLens(a) {
  var u = a.length;
  if (u % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var c = a.indexOf("=");
  c === -1 && (c = u);
  var l = c === u ? 0 : 4 - c % 4;
  return [c, l];
}
function byteLength(a) {
  var u = getLens(a), c = u[0], l = u[1];
  return (c + l) * 3 / 4 - l;
}
function _byteLength(a, u, c) {
  return (u + c) * 3 / 4 - c;
}
function toByteArray(a) {
  var u, c = getLens(a), l = c[0], v = c[1], p = new Arr(_byteLength(a, l, v)), _ = 0, k = v > 0 ? l - 4 : l, O;
  for (O = 0; O < k; O += 4)
    u = revLookup[a.charCodeAt(O)] << 18 | revLookup[a.charCodeAt(O + 1)] << 12 | revLookup[a.charCodeAt(O + 2)] << 6 | revLookup[a.charCodeAt(O + 3)], p[_++] = u >> 16 & 255, p[_++] = u >> 8 & 255, p[_++] = u & 255;
  return v === 2 && (u = revLookup[a.charCodeAt(O)] << 2 | revLookup[a.charCodeAt(O + 1)] >> 4, p[_++] = u & 255), v === 1 && (u = revLookup[a.charCodeAt(O)] << 10 | revLookup[a.charCodeAt(O + 1)] << 4 | revLookup[a.charCodeAt(O + 2)] >> 2, p[_++] = u >> 8 & 255, p[_++] = u & 255), p;
}
function tripletToBase64(a) {
  return lookup[a >> 18 & 63] + lookup[a >> 12 & 63] + lookup[a >> 6 & 63] + lookup[a & 63];
}
function encodeChunk(a, u, c) {
  for (var l, v = [], p = u; p < c; p += 3)
    l = (a[p] << 16 & 16711680) + (a[p + 1] << 8 & 65280) + (a[p + 2] & 255), v.push(tripletToBase64(l));
  return v.join("");
}
function fromByteArray(a) {
  for (var u, c = a.length, l = c % 3, v = [], p = 16383, _ = 0, k = c - l; _ < k; _ += p)
    v.push(encodeChunk(a, _, _ + p > k ? k : _ + p));
  return l === 1 ? (u = a[c - 1], v.push(
    lookup[u >> 2] + lookup[u << 4 & 63] + "=="
  )) : l === 2 && (u = (a[c - 2] << 8) + a[c - 1], v.push(
    lookup[u >> 10] + lookup[u >> 4 & 63] + lookup[u << 2 & 63] + "="
  )), v.join("");
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(a, u, c, l, v) {
  var p, _, k = v * 8 - l - 1, O = (1 << k) - 1, D = O >> 1, F = -7, z = c ? v - 1 : 0, j = c ? -1 : 1, ee = a[u + z];
  for (z += j, p = ee & (1 << -F) - 1, ee >>= -F, F += k; F > 0; p = p * 256 + a[u + z], z += j, F -= 8)
    ;
  for (_ = p & (1 << -F) - 1, p >>= -F, F += l; F > 0; _ = _ * 256 + a[u + z], z += j, F -= 8)
    ;
  if (p === 0)
    p = 1 - D;
  else {
    if (p === O)
      return _ ? NaN : (ee ? -1 : 1) * (1 / 0);
    _ = _ + Math.pow(2, l), p = p - D;
  }
  return (ee ? -1 : 1) * _ * Math.pow(2, p - l);
};
ieee754.write = function(a, u, c, l, v, p) {
  var _, k, O, D = p * 8 - v - 1, F = (1 << D) - 1, z = F >> 1, j = v === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, ee = l ? 0 : p - 1, X = l ? 1 : -1, ae = u < 0 || u === 0 && 1 / u < 0 ? 1 : 0;
  for (u = Math.abs(u), isNaN(u) || u === 1 / 0 ? (k = isNaN(u) ? 1 : 0, _ = F) : (_ = Math.floor(Math.log(u) / Math.LN2), u * (O = Math.pow(2, -_)) < 1 && (_--, O *= 2), _ + z >= 1 ? u += j / O : u += j * Math.pow(2, 1 - z), u * O >= 2 && (_++, O /= 2), _ + z >= F ? (k = 0, _ = F) : _ + z >= 1 ? (k = (u * O - 1) * Math.pow(2, v), _ = _ + z) : (k = u * Math.pow(2, z - 1) * Math.pow(2, v), _ = 0)); v >= 8; a[c + ee] = k & 255, ee += X, k /= 256, v -= 8)
    ;
  for (_ = _ << v | k, D += v; D > 0; a[c + ee] = _ & 255, ee += X, _ /= 256, D -= 8)
    ;
  a[c + ee - X] |= ae * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(a) {
  const u = base64Js, c = ieee754, l = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  a.Buffer = F, a.SlowBuffer = Te, a.INSPECT_MAX_BYTES = 50;
  const v = 2147483647;
  a.kMaxLength = v;
  const { Uint8Array: p, ArrayBuffer: _, SharedArrayBuffer: k } = globalThis;
  F.TYPED_ARRAY_SUPPORT = O(), !F.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function O() {
    try {
      const ue = new p(1), ce = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(ce, p.prototype), Object.setPrototypeOf(ue, ce), ue.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(F.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (F.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(F.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (F.isBuffer(this))
        return this.byteOffset;
    }
  });
  function D(ue) {
    if (ue > v)
      throw new RangeError('The value "' + ue + '" is invalid for option "size"');
    const ce = new p(ue);
    return Object.setPrototypeOf(ce, F.prototype), ce;
  }
  function F(ue, ce, me) {
    if (typeof ue == "number") {
      if (typeof ce == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return X(ue);
    }
    return z(ue, ce, me);
  }
  F.poolSize = 8192;
  function z(ue, ce, me) {
    if (typeof ue == "string")
      return ae(ue, ce);
    if (_.isView(ue))
      return ne(ue);
    if (ue == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof ue
      );
    if (Ee(ue, _) || ue && Ee(ue.buffer, _) || typeof k < "u" && (Ee(ue, k) || ue && Ee(ue.buffer, k)))
      return Z(ue, ce, me);
    if (typeof ue == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const Ce = ue.valueOf && ue.valueOf();
    if (Ce != null && Ce !== ue)
      return F.from(Ce, ce, me);
    const Be = de(ue);
    if (Be)
      return Be;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof ue[Symbol.toPrimitive] == "function")
      return F.from(ue[Symbol.toPrimitive]("string"), ce, me);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof ue
    );
  }
  F.from = function(ue, ce, me) {
    return z(ue, ce, me);
  }, Object.setPrototypeOf(F.prototype, p.prototype), Object.setPrototypeOf(F, p);
  function j(ue) {
    if (typeof ue != "number")
      throw new TypeError('"size" argument must be of type number');
    if (ue < 0)
      throw new RangeError('The value "' + ue + '" is invalid for option "size"');
  }
  function ee(ue, ce, me) {
    return j(ue), ue <= 0 ? D(ue) : ce !== void 0 ? typeof me == "string" ? D(ue).fill(ce, me) : D(ue).fill(ce) : D(ue);
  }
  F.alloc = function(ue, ce, me) {
    return ee(ue, ce, me);
  };
  function X(ue) {
    return j(ue), D(ue < 0 ? 0 : fe(ue) | 0);
  }
  F.allocUnsafe = function(ue) {
    return X(ue);
  }, F.allocUnsafeSlow = function(ue) {
    return X(ue);
  };
  function ae(ue, ce) {
    if ((typeof ce != "string" || ce === "") && (ce = "utf8"), !F.isEncoding(ce))
      throw new TypeError("Unknown encoding: " + ce);
    const me = Re(ue, ce) | 0;
    let Ce = D(me);
    const Be = Ce.write(ue, ce);
    return Be !== me && (Ce = Ce.slice(0, Be)), Ce;
  }
  function Q(ue) {
    const ce = ue.length < 0 ? 0 : fe(ue.length) | 0, me = D(ce);
    for (let Ce = 0; Ce < ce; Ce += 1)
      me[Ce] = ue[Ce] & 255;
    return me;
  }
  function ne(ue) {
    if (Ee(ue, p)) {
      const ce = new p(ue);
      return Z(ce.buffer, ce.byteOffset, ce.byteLength);
    }
    return Q(ue);
  }
  function Z(ue, ce, me) {
    if (ce < 0 || ue.byteLength < ce)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (ue.byteLength < ce + (me || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let Ce;
    return ce === void 0 && me === void 0 ? Ce = new p(ue) : me === void 0 ? Ce = new p(ue, ce) : Ce = new p(ue, ce, me), Object.setPrototypeOf(Ce, F.prototype), Ce;
  }
  function de(ue) {
    if (F.isBuffer(ue)) {
      const ce = fe(ue.length) | 0, me = D(ce);
      return me.length === 0 || ue.copy(me, 0, 0, ce), me;
    }
    if (ue.length !== void 0)
      return typeof ue.length != "number" || We(ue.length) ? D(0) : Q(ue);
    if (ue.type === "Buffer" && Array.isArray(ue.data))
      return Q(ue.data);
  }
  function fe(ue) {
    if (ue >= v)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + v.toString(16) + " bytes");
    return ue | 0;
  }
  function Te(ue) {
    return +ue != ue && (ue = 0), F.alloc(+ue);
  }
  F.isBuffer = function(ce) {
    return ce != null && ce._isBuffer === !0 && ce !== F.prototype;
  }, F.compare = function(ce, me) {
    if (Ee(ce, p) && (ce = F.from(ce, ce.offset, ce.byteLength)), Ee(me, p) && (me = F.from(me, me.offset, me.byteLength)), !F.isBuffer(ce) || !F.isBuffer(me))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (ce === me)
      return 0;
    let Ce = ce.length, Be = me.length;
    for (let ze = 0, Je = Math.min(Ce, Be); ze < Je; ++ze)
      if (ce[ze] !== me[ze]) {
        Ce = ce[ze], Be = me[ze];
        break;
      }
    return Ce < Be ? -1 : Be < Ce ? 1 : 0;
  }, F.isEncoding = function(ce) {
    switch (String(ce).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, F.concat = function(ce, me) {
    if (!Array.isArray(ce))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (ce.length === 0)
      return F.alloc(0);
    let Ce;
    if (me === void 0)
      for (me = 0, Ce = 0; Ce < ce.length; ++Ce)
        me += ce[Ce].length;
    const Be = F.allocUnsafe(me);
    let ze = 0;
    for (Ce = 0; Ce < ce.length; ++Ce) {
      let Je = ce[Ce];
      if (Ee(Je, p))
        ze + Je.length > Be.length ? (F.isBuffer(Je) || (Je = F.from(Je)), Je.copy(Be, ze)) : p.prototype.set.call(
          Be,
          Je,
          ze
        );
      else if (F.isBuffer(Je))
        Je.copy(Be, ze);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      ze += Je.length;
    }
    return Be;
  };
  function Re(ue, ce) {
    if (F.isBuffer(ue))
      return ue.length;
    if (_.isView(ue) || Ee(ue, _))
      return ue.byteLength;
    if (typeof ue != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof ue
      );
    const me = ue.length, Ce = arguments.length > 2 && arguments[2] === !0;
    if (!Ce && me === 0)
      return 0;
    let Be = !1;
    for (; ; )
      switch (ce) {
        case "ascii":
        case "latin1":
        case "binary":
          return me;
        case "utf8":
        case "utf-8":
          return yt(ue).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return me * 2;
        case "hex":
          return me >>> 1;
        case "base64":
          return H(ue).length;
        default:
          if (Be)
            return Ce ? -1 : yt(ue).length;
          ce = ("" + ce).toLowerCase(), Be = !0;
      }
  }
  F.byteLength = Re;
  function Le(ue, ce, me) {
    let Ce = !1;
    if ((ce === void 0 || ce < 0) && (ce = 0), ce > this.length || ((me === void 0 || me > this.length) && (me = this.length), me <= 0) || (me >>>= 0, ce >>>= 0, me <= ce))
      return "";
    for (ue || (ue = "utf8"); ; )
      switch (ue) {
        case "hex":
          return te(this, ce, me);
        case "utf8":
        case "utf-8":
          return U(this, ce, me);
        case "ascii":
          return T(this, ce, me);
        case "latin1":
        case "binary":
          return B(this, ce, me);
        case "base64":
          return $(this, ce, me);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return pe(this, ce, me);
        default:
          if (Ce)
            throw new TypeError("Unknown encoding: " + ue);
          ue = (ue + "").toLowerCase(), Ce = !0;
      }
  }
  F.prototype._isBuffer = !0;
  function be(ue, ce, me) {
    const Ce = ue[ce];
    ue[ce] = ue[me], ue[me] = Ce;
  }
  F.prototype.swap16 = function() {
    const ce = this.length;
    if (ce % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let me = 0; me < ce; me += 2)
      be(this, me, me + 1);
    return this;
  }, F.prototype.swap32 = function() {
    const ce = this.length;
    if (ce % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let me = 0; me < ce; me += 4)
      be(this, me, me + 3), be(this, me + 1, me + 2);
    return this;
  }, F.prototype.swap64 = function() {
    const ce = this.length;
    if (ce % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let me = 0; me < ce; me += 8)
      be(this, me, me + 7), be(this, me + 1, me + 6), be(this, me + 2, me + 5), be(this, me + 3, me + 4);
    return this;
  }, F.prototype.toString = function() {
    const ce = this.length;
    return ce === 0 ? "" : arguments.length === 0 ? U(this, 0, ce) : Le.apply(this, arguments);
  }, F.prototype.toLocaleString = F.prototype.toString, F.prototype.equals = function(ce) {
    if (!F.isBuffer(ce))
      throw new TypeError("Argument must be a Buffer");
    return this === ce ? !0 : F.compare(this, ce) === 0;
  }, F.prototype.inspect = function() {
    let ce = "";
    const me = a.INSPECT_MAX_BYTES;
    return ce = this.toString("hex", 0, me).replace(/(.{2})/g, "$1 ").trim(), this.length > me && (ce += " ... "), "<Buffer " + ce + ">";
  }, l && (F.prototype[l] = F.prototype.inspect), F.prototype.compare = function(ce, me, Ce, Be, ze) {
    if (Ee(ce, p) && (ce = F.from(ce, ce.offset, ce.byteLength)), !F.isBuffer(ce))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof ce
      );
    if (me === void 0 && (me = 0), Ce === void 0 && (Ce = ce ? ce.length : 0), Be === void 0 && (Be = 0), ze === void 0 && (ze = this.length), me < 0 || Ce > ce.length || Be < 0 || ze > this.length)
      throw new RangeError("out of range index");
    if (Be >= ze && me >= Ce)
      return 0;
    if (Be >= ze)
      return -1;
    if (me >= Ce)
      return 1;
    if (me >>>= 0, Ce >>>= 0, Be >>>= 0, ze >>>= 0, this === ce)
      return 0;
    let Je = ze - Be, Ze = Ce - me;
    const Ke = Math.min(Je, Ze), x = this.slice(Be, ze), se = ce.slice(me, Ce);
    for (let ge = 0; ge < Ke; ++ge)
      if (x[ge] !== se[ge]) {
        Je = x[ge], Ze = se[ge];
        break;
      }
    return Je < Ze ? -1 : Ze < Je ? 1 : 0;
  };
  function q(ue, ce, me, Ce, Be) {
    if (ue.length === 0)
      return -1;
    if (typeof me == "string" ? (Ce = me, me = 0) : me > 2147483647 ? me = 2147483647 : me < -2147483648 && (me = -2147483648), me = +me, We(me) && (me = Be ? 0 : ue.length - 1), me < 0 && (me = ue.length + me), me >= ue.length) {
      if (Be)
        return -1;
      me = ue.length - 1;
    } else if (me < 0)
      if (Be)
        me = 0;
      else
        return -1;
    if (typeof ce == "string" && (ce = F.from(ce, Ce)), F.isBuffer(ce))
      return ce.length === 0 ? -1 : J(ue, ce, me, Ce, Be);
    if (typeof ce == "number")
      return ce = ce & 255, typeof p.prototype.indexOf == "function" ? Be ? p.prototype.indexOf.call(ue, ce, me) : p.prototype.lastIndexOf.call(ue, ce, me) : J(ue, [ce], me, Ce, Be);
    throw new TypeError("val must be string, number or Buffer");
  }
  function J(ue, ce, me, Ce, Be) {
    let ze = 1, Je = ue.length, Ze = ce.length;
    if (Ce !== void 0 && (Ce = String(Ce).toLowerCase(), Ce === "ucs2" || Ce === "ucs-2" || Ce === "utf16le" || Ce === "utf-16le")) {
      if (ue.length < 2 || ce.length < 2)
        return -1;
      ze = 2, Je /= 2, Ze /= 2, me /= 2;
    }
    function Ke(se, ge) {
      return ze === 1 ? se[ge] : se.readUInt16BE(ge * ze);
    }
    let x;
    if (Be) {
      let se = -1;
      for (x = me; x < Je; x++)
        if (Ke(ue, x) === Ke(ce, se === -1 ? 0 : x - se)) {
          if (se === -1 && (se = x), x - se + 1 === Ze)
            return se * ze;
        } else
          se !== -1 && (x -= x - se), se = -1;
    } else
      for (me + Ze > Je && (me = Je - Ze), x = me; x >= 0; x--) {
        let se = !0;
        for (let ge = 0; ge < Ze; ge++)
          if (Ke(ue, x + ge) !== Ke(ce, ge)) {
            se = !1;
            break;
          }
        if (se)
          return x;
      }
    return -1;
  }
  F.prototype.includes = function(ce, me, Ce) {
    return this.indexOf(ce, me, Ce) !== -1;
  }, F.prototype.indexOf = function(ce, me, Ce) {
    return q(this, ce, me, Ce, !0);
  }, F.prototype.lastIndexOf = function(ce, me, Ce) {
    return q(this, ce, me, Ce, !1);
  };
  function C(ue, ce, me, Ce) {
    me = Number(me) || 0;
    const Be = ue.length - me;
    Ce ? (Ce = Number(Ce), Ce > Be && (Ce = Be)) : Ce = Be;
    const ze = ce.length;
    Ce > ze / 2 && (Ce = ze / 2);
    let Je;
    for (Je = 0; Je < Ce; ++Je) {
      const Ze = parseInt(ce.substr(Je * 2, 2), 16);
      if (We(Ze))
        return Je;
      ue[me + Je] = Ze;
    }
    return Je;
  }
  function S(ue, ce, me, Ce) {
    return ye(yt(ce, ue.length - me), ue, me, Ce);
  }
  function E(ue, ce, me, Ce) {
    return ye(Xe(ce), ue, me, Ce);
  }
  function I(ue, ce, me, Ce) {
    return ye(H(ce), ue, me, Ce);
  }
  function M(ue, ce, me, Ce) {
    return ye(Ge(ce, ue.length - me), ue, me, Ce);
  }
  F.prototype.write = function(ce, me, Ce, Be) {
    if (me === void 0)
      Be = "utf8", Ce = this.length, me = 0;
    else if (Ce === void 0 && typeof me == "string")
      Be = me, Ce = this.length, me = 0;
    else if (isFinite(me))
      me = me >>> 0, isFinite(Ce) ? (Ce = Ce >>> 0, Be === void 0 && (Be = "utf8")) : (Be = Ce, Ce = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const ze = this.length - me;
    if ((Ce === void 0 || Ce > ze) && (Ce = ze), ce.length > 0 && (Ce < 0 || me < 0) || me > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    Be || (Be = "utf8");
    let Je = !1;
    for (; ; )
      switch (Be) {
        case "hex":
          return C(this, ce, me, Ce);
        case "utf8":
        case "utf-8":
          return S(this, ce, me, Ce);
        case "ascii":
        case "latin1":
        case "binary":
          return E(this, ce, me, Ce);
        case "base64":
          return I(this, ce, me, Ce);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return M(this, ce, me, Ce);
        default:
          if (Je)
            throw new TypeError("Unknown encoding: " + Be);
          Be = ("" + Be).toLowerCase(), Je = !0;
      }
  }, F.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function $(ue, ce, me) {
    return ce === 0 && me === ue.length ? u.fromByteArray(ue) : u.fromByteArray(ue.slice(ce, me));
  }
  function U(ue, ce, me) {
    me = Math.min(ue.length, me);
    const Ce = [];
    let Be = ce;
    for (; Be < me; ) {
      const ze = ue[Be];
      let Je = null, Ze = ze > 239 ? 4 : ze > 223 ? 3 : ze > 191 ? 2 : 1;
      if (Be + Ze <= me) {
        let Ke, x, se, ge;
        switch (Ze) {
          case 1:
            ze < 128 && (Je = ze);
            break;
          case 2:
            Ke = ue[Be + 1], (Ke & 192) === 128 && (ge = (ze & 31) << 6 | Ke & 63, ge > 127 && (Je = ge));
            break;
          case 3:
            Ke = ue[Be + 1], x = ue[Be + 2], (Ke & 192) === 128 && (x & 192) === 128 && (ge = (ze & 15) << 12 | (Ke & 63) << 6 | x & 63, ge > 2047 && (ge < 55296 || ge > 57343) && (Je = ge));
            break;
          case 4:
            Ke = ue[Be + 1], x = ue[Be + 2], se = ue[Be + 3], (Ke & 192) === 128 && (x & 192) === 128 && (se & 192) === 128 && (ge = (ze & 15) << 18 | (Ke & 63) << 12 | (x & 63) << 6 | se & 63, ge > 65535 && ge < 1114112 && (Je = ge));
        }
      }
      Je === null ? (Je = 65533, Ze = 1) : Je > 65535 && (Je -= 65536, Ce.push(Je >>> 10 & 1023 | 55296), Je = 56320 | Je & 1023), Ce.push(Je), Be += Ze;
    }
    return L(Ce);
  }
  const Y = 4096;
  function L(ue) {
    const ce = ue.length;
    if (ce <= Y)
      return String.fromCharCode.apply(String, ue);
    let me = "", Ce = 0;
    for (; Ce < ce; )
      me += String.fromCharCode.apply(
        String,
        ue.slice(Ce, Ce += Y)
      );
    return me;
  }
  function T(ue, ce, me) {
    let Ce = "";
    me = Math.min(ue.length, me);
    for (let Be = ce; Be < me; ++Be)
      Ce += String.fromCharCode(ue[Be] & 127);
    return Ce;
  }
  function B(ue, ce, me) {
    let Ce = "";
    me = Math.min(ue.length, me);
    for (let Be = ce; Be < me; ++Be)
      Ce += String.fromCharCode(ue[Be]);
    return Ce;
  }
  function te(ue, ce, me) {
    const Ce = ue.length;
    (!ce || ce < 0) && (ce = 0), (!me || me < 0 || me > Ce) && (me = Ce);
    let Be = "";
    for (let ze = ce; ze < me; ++ze)
      Be += we[ue[ze]];
    return Be;
  }
  function pe(ue, ce, me) {
    const Ce = ue.slice(ce, me);
    let Be = "";
    for (let ze = 0; ze < Ce.length - 1; ze += 2)
      Be += String.fromCharCode(Ce[ze] + Ce[ze + 1] * 256);
    return Be;
  }
  F.prototype.slice = function(ce, me) {
    const Ce = this.length;
    ce = ~~ce, me = me === void 0 ? Ce : ~~me, ce < 0 ? (ce += Ce, ce < 0 && (ce = 0)) : ce > Ce && (ce = Ce), me < 0 ? (me += Ce, me < 0 && (me = 0)) : me > Ce && (me = Ce), me < ce && (me = ce);
    const Be = this.subarray(ce, me);
    return Object.setPrototypeOf(Be, F.prototype), Be;
  };
  function Ie(ue, ce, me) {
    if (ue % 1 !== 0 || ue < 0)
      throw new RangeError("offset is not uint");
    if (ue + ce > me)
      throw new RangeError("Trying to access beyond buffer length");
  }
  F.prototype.readUintLE = F.prototype.readUIntLE = function(ce, me, Ce) {
    ce = ce >>> 0, me = me >>> 0, Ce || Ie(ce, me, this.length);
    let Be = this[ce], ze = 1, Je = 0;
    for (; ++Je < me && (ze *= 256); )
      Be += this[ce + Je] * ze;
    return Be;
  }, F.prototype.readUintBE = F.prototype.readUIntBE = function(ce, me, Ce) {
    ce = ce >>> 0, me = me >>> 0, Ce || Ie(ce, me, this.length);
    let Be = this[ce + --me], ze = 1;
    for (; me > 0 && (ze *= 256); )
      Be += this[ce + --me] * ze;
    return Be;
  }, F.prototype.readUint8 = F.prototype.readUInt8 = function(ce, me) {
    return ce = ce >>> 0, me || Ie(ce, 1, this.length), this[ce];
  }, F.prototype.readUint16LE = F.prototype.readUInt16LE = function(ce, me) {
    return ce = ce >>> 0, me || Ie(ce, 2, this.length), this[ce] | this[ce + 1] << 8;
  }, F.prototype.readUint16BE = F.prototype.readUInt16BE = function(ce, me) {
    return ce = ce >>> 0, me || Ie(ce, 2, this.length), this[ce] << 8 | this[ce + 1];
  }, F.prototype.readUint32LE = F.prototype.readUInt32LE = function(ce, me) {
    return ce = ce >>> 0, me || Ie(ce, 4, this.length), (this[ce] | this[ce + 1] << 8 | this[ce + 2] << 16) + this[ce + 3] * 16777216;
  }, F.prototype.readUint32BE = F.prototype.readUInt32BE = function(ce, me) {
    return ce = ce >>> 0, me || Ie(ce, 4, this.length), this[ce] * 16777216 + (this[ce + 1] << 16 | this[ce + 2] << 8 | this[ce + 3]);
  }, F.prototype.readBigUInt64LE = V(function(ce) {
    ce = ce >>> 0, Pe(ce, "offset");
    const me = this[ce], Ce = this[ce + 7];
    (me === void 0 || Ce === void 0) && Fe(ce, this.length - 8);
    const Be = me + this[++ce] * 2 ** 8 + this[++ce] * 2 ** 16 + this[++ce] * 2 ** 24, ze = this[++ce] + this[++ce] * 2 ** 8 + this[++ce] * 2 ** 16 + Ce * 2 ** 24;
    return BigInt(Be) + (BigInt(ze) << BigInt(32));
  }), F.prototype.readBigUInt64BE = V(function(ce) {
    ce = ce >>> 0, Pe(ce, "offset");
    const me = this[ce], Ce = this[ce + 7];
    (me === void 0 || Ce === void 0) && Fe(ce, this.length - 8);
    const Be = me * 2 ** 24 + this[++ce] * 2 ** 16 + this[++ce] * 2 ** 8 + this[++ce], ze = this[++ce] * 2 ** 24 + this[++ce] * 2 ** 16 + this[++ce] * 2 ** 8 + Ce;
    return (BigInt(Be) << BigInt(32)) + BigInt(ze);
  }), F.prototype.readIntLE = function(ce, me, Ce) {
    ce = ce >>> 0, me = me >>> 0, Ce || Ie(ce, me, this.length);
    let Be = this[ce], ze = 1, Je = 0;
    for (; ++Je < me && (ze *= 256); )
      Be += this[ce + Je] * ze;
    return ze *= 128, Be >= ze && (Be -= Math.pow(2, 8 * me)), Be;
  }, F.prototype.readIntBE = function(ce, me, Ce) {
    ce = ce >>> 0, me = me >>> 0, Ce || Ie(ce, me, this.length);
    let Be = me, ze = 1, Je = this[ce + --Be];
    for (; Be > 0 && (ze *= 256); )
      Je += this[ce + --Be] * ze;
    return ze *= 128, Je >= ze && (Je -= Math.pow(2, 8 * me)), Je;
  }, F.prototype.readInt8 = function(ce, me) {
    return ce = ce >>> 0, me || Ie(ce, 1, this.length), this[ce] & 128 ? (255 - this[ce] + 1) * -1 : this[ce];
  }, F.prototype.readInt16LE = function(ce, me) {
    ce = ce >>> 0, me || Ie(ce, 2, this.length);
    const Ce = this[ce] | this[ce + 1] << 8;
    return Ce & 32768 ? Ce | 4294901760 : Ce;
  }, F.prototype.readInt16BE = function(ce, me) {
    ce = ce >>> 0, me || Ie(ce, 2, this.length);
    const Ce = this[ce + 1] | this[ce] << 8;
    return Ce & 32768 ? Ce | 4294901760 : Ce;
  }, F.prototype.readInt32LE = function(ce, me) {
    return ce = ce >>> 0, me || Ie(ce, 4, this.length), this[ce] | this[ce + 1] << 8 | this[ce + 2] << 16 | this[ce + 3] << 24;
  }, F.prototype.readInt32BE = function(ce, me) {
    return ce = ce >>> 0, me || Ie(ce, 4, this.length), this[ce] << 24 | this[ce + 1] << 16 | this[ce + 2] << 8 | this[ce + 3];
  }, F.prototype.readBigInt64LE = V(function(ce) {
    ce = ce >>> 0, Pe(ce, "offset");
    const me = this[ce], Ce = this[ce + 7];
    (me === void 0 || Ce === void 0) && Fe(ce, this.length - 8);
    const Be = this[ce + 4] + this[ce + 5] * 2 ** 8 + this[ce + 6] * 2 ** 16 + (Ce << 24);
    return (BigInt(Be) << BigInt(32)) + BigInt(me + this[++ce] * 2 ** 8 + this[++ce] * 2 ** 16 + this[++ce] * 2 ** 24);
  }), F.prototype.readBigInt64BE = V(function(ce) {
    ce = ce >>> 0, Pe(ce, "offset");
    const me = this[ce], Ce = this[ce + 7];
    (me === void 0 || Ce === void 0) && Fe(ce, this.length - 8);
    const Be = (me << 24) + // Overflow
    this[++ce] * 2 ** 16 + this[++ce] * 2 ** 8 + this[++ce];
    return (BigInt(Be) << BigInt(32)) + BigInt(this[++ce] * 2 ** 24 + this[++ce] * 2 ** 16 + this[++ce] * 2 ** 8 + Ce);
  }), F.prototype.readFloatLE = function(ce, me) {
    return ce = ce >>> 0, me || Ie(ce, 4, this.length), c.read(this, ce, !0, 23, 4);
  }, F.prototype.readFloatBE = function(ce, me) {
    return ce = ce >>> 0, me || Ie(ce, 4, this.length), c.read(this, ce, !1, 23, 4);
  }, F.prototype.readDoubleLE = function(ce, me) {
    return ce = ce >>> 0, me || Ie(ce, 8, this.length), c.read(this, ce, !0, 52, 8);
  }, F.prototype.readDoubleBE = function(ce, me) {
    return ce = ce >>> 0, me || Ie(ce, 8, this.length), c.read(this, ce, !1, 52, 8);
  };
  function $e(ue, ce, me, Ce, Be, ze) {
    if (!F.isBuffer(ue))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (ce > Be || ce < ze)
      throw new RangeError('"value" argument is out of bounds');
    if (me + Ce > ue.length)
      throw new RangeError("Index out of range");
  }
  F.prototype.writeUintLE = F.prototype.writeUIntLE = function(ce, me, Ce, Be) {
    if (ce = +ce, me = me >>> 0, Ce = Ce >>> 0, !Be) {
      const Ze = Math.pow(2, 8 * Ce) - 1;
      $e(this, ce, me, Ce, Ze, 0);
    }
    let ze = 1, Je = 0;
    for (this[me] = ce & 255; ++Je < Ce && (ze *= 256); )
      this[me + Je] = ce / ze & 255;
    return me + Ce;
  }, F.prototype.writeUintBE = F.prototype.writeUIntBE = function(ce, me, Ce, Be) {
    if (ce = +ce, me = me >>> 0, Ce = Ce >>> 0, !Be) {
      const Ze = Math.pow(2, 8 * Ce) - 1;
      $e(this, ce, me, Ce, Ze, 0);
    }
    let ze = Ce - 1, Je = 1;
    for (this[me + ze] = ce & 255; --ze >= 0 && (Je *= 256); )
      this[me + ze] = ce / Je & 255;
    return me + Ce;
  }, F.prototype.writeUint8 = F.prototype.writeUInt8 = function(ce, me, Ce) {
    return ce = +ce, me = me >>> 0, Ce || $e(this, ce, me, 1, 255, 0), this[me] = ce & 255, me + 1;
  }, F.prototype.writeUint16LE = F.prototype.writeUInt16LE = function(ce, me, Ce) {
    return ce = +ce, me = me >>> 0, Ce || $e(this, ce, me, 2, 65535, 0), this[me] = ce & 255, this[me + 1] = ce >>> 8, me + 2;
  }, F.prototype.writeUint16BE = F.prototype.writeUInt16BE = function(ce, me, Ce) {
    return ce = +ce, me = me >>> 0, Ce || $e(this, ce, me, 2, 65535, 0), this[me] = ce >>> 8, this[me + 1] = ce & 255, me + 2;
  }, F.prototype.writeUint32LE = F.prototype.writeUInt32LE = function(ce, me, Ce) {
    return ce = +ce, me = me >>> 0, Ce || $e(this, ce, me, 4, 4294967295, 0), this[me + 3] = ce >>> 24, this[me + 2] = ce >>> 16, this[me + 1] = ce >>> 8, this[me] = ce & 255, me + 4;
  }, F.prototype.writeUint32BE = F.prototype.writeUInt32BE = function(ce, me, Ce) {
    return ce = +ce, me = me >>> 0, Ce || $e(this, ce, me, 4, 4294967295, 0), this[me] = ce >>> 24, this[me + 1] = ce >>> 16, this[me + 2] = ce >>> 8, this[me + 3] = ce & 255, me + 4;
  };
  function ve(ue, ce, me, Ce, Be) {
    Ne(ce, Ce, Be, ue, me, 7);
    let ze = Number(ce & BigInt(4294967295));
    ue[me++] = ze, ze = ze >> 8, ue[me++] = ze, ze = ze >> 8, ue[me++] = ze, ze = ze >> 8, ue[me++] = ze;
    let Je = Number(ce >> BigInt(32) & BigInt(4294967295));
    return ue[me++] = Je, Je = Je >> 8, ue[me++] = Je, Je = Je >> 8, ue[me++] = Je, Je = Je >> 8, ue[me++] = Je, me;
  }
  function he(ue, ce, me, Ce, Be) {
    Ne(ce, Ce, Be, ue, me, 7);
    let ze = Number(ce & BigInt(4294967295));
    ue[me + 7] = ze, ze = ze >> 8, ue[me + 6] = ze, ze = ze >> 8, ue[me + 5] = ze, ze = ze >> 8, ue[me + 4] = ze;
    let Je = Number(ce >> BigInt(32) & BigInt(4294967295));
    return ue[me + 3] = Je, Je = Je >> 8, ue[me + 2] = Je, Je = Je >> 8, ue[me + 1] = Je, Je = Je >> 8, ue[me] = Je, me + 8;
  }
  F.prototype.writeBigUInt64LE = V(function(ce, me = 0) {
    return ve(this, ce, me, BigInt(0), BigInt("0xffffffffffffffff"));
  }), F.prototype.writeBigUInt64BE = V(function(ce, me = 0) {
    return he(this, ce, me, BigInt(0), BigInt("0xffffffffffffffff"));
  }), F.prototype.writeIntLE = function(ce, me, Ce, Be) {
    if (ce = +ce, me = me >>> 0, !Be) {
      const Ke = Math.pow(2, 8 * Ce - 1);
      $e(this, ce, me, Ce, Ke - 1, -Ke);
    }
    let ze = 0, Je = 1, Ze = 0;
    for (this[me] = ce & 255; ++ze < Ce && (Je *= 256); )
      ce < 0 && Ze === 0 && this[me + ze - 1] !== 0 && (Ze = 1), this[me + ze] = (ce / Je >> 0) - Ze & 255;
    return me + Ce;
  }, F.prototype.writeIntBE = function(ce, me, Ce, Be) {
    if (ce = +ce, me = me >>> 0, !Be) {
      const Ke = Math.pow(2, 8 * Ce - 1);
      $e(this, ce, me, Ce, Ke - 1, -Ke);
    }
    let ze = Ce - 1, Je = 1, Ze = 0;
    for (this[me + ze] = ce & 255; --ze >= 0 && (Je *= 256); )
      ce < 0 && Ze === 0 && this[me + ze + 1] !== 0 && (Ze = 1), this[me + ze] = (ce / Je >> 0) - Ze & 255;
    return me + Ce;
  }, F.prototype.writeInt8 = function(ce, me, Ce) {
    return ce = +ce, me = me >>> 0, Ce || $e(this, ce, me, 1, 127, -128), ce < 0 && (ce = 255 + ce + 1), this[me] = ce & 255, me + 1;
  }, F.prototype.writeInt16LE = function(ce, me, Ce) {
    return ce = +ce, me = me >>> 0, Ce || $e(this, ce, me, 2, 32767, -32768), this[me] = ce & 255, this[me + 1] = ce >>> 8, me + 2;
  }, F.prototype.writeInt16BE = function(ce, me, Ce) {
    return ce = +ce, me = me >>> 0, Ce || $e(this, ce, me, 2, 32767, -32768), this[me] = ce >>> 8, this[me + 1] = ce & 255, me + 2;
  }, F.prototype.writeInt32LE = function(ce, me, Ce) {
    return ce = +ce, me = me >>> 0, Ce || $e(this, ce, me, 4, 2147483647, -2147483648), this[me] = ce & 255, this[me + 1] = ce >>> 8, this[me + 2] = ce >>> 16, this[me + 3] = ce >>> 24, me + 4;
  }, F.prototype.writeInt32BE = function(ce, me, Ce) {
    return ce = +ce, me = me >>> 0, Ce || $e(this, ce, me, 4, 2147483647, -2147483648), ce < 0 && (ce = 4294967295 + ce + 1), this[me] = ce >>> 24, this[me + 1] = ce >>> 16, this[me + 2] = ce >>> 8, this[me + 3] = ce & 255, me + 4;
  }, F.prototype.writeBigInt64LE = V(function(ce, me = 0) {
    return ve(this, ce, me, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), F.prototype.writeBigInt64BE = V(function(ce, me = 0) {
    return he(this, ce, me, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function Oe(ue, ce, me, Ce, Be, ze) {
    if (me + Ce > ue.length)
      throw new RangeError("Index out of range");
    if (me < 0)
      throw new RangeError("Index out of range");
  }
  function Ae(ue, ce, me, Ce, Be) {
    return ce = +ce, me = me >>> 0, Be || Oe(ue, ce, me, 4), c.write(ue, ce, me, Ce, 23, 4), me + 4;
  }
  F.prototype.writeFloatLE = function(ce, me, Ce) {
    return Ae(this, ce, me, !0, Ce);
  }, F.prototype.writeFloatBE = function(ce, me, Ce) {
    return Ae(this, ce, me, !1, Ce);
  };
  function Ue(ue, ce, me, Ce, Be) {
    return ce = +ce, me = me >>> 0, Be || Oe(ue, ce, me, 8), c.write(ue, ce, me, Ce, 52, 8), me + 8;
  }
  F.prototype.writeDoubleLE = function(ce, me, Ce) {
    return Ue(this, ce, me, !0, Ce);
  }, F.prototype.writeDoubleBE = function(ce, me, Ce) {
    return Ue(this, ce, me, !1, Ce);
  }, F.prototype.copy = function(ce, me, Ce, Be) {
    if (!F.isBuffer(ce))
      throw new TypeError("argument should be a Buffer");
    if (Ce || (Ce = 0), !Be && Be !== 0 && (Be = this.length), me >= ce.length && (me = ce.length), me || (me = 0), Be > 0 && Be < Ce && (Be = Ce), Be === Ce || ce.length === 0 || this.length === 0)
      return 0;
    if (me < 0)
      throw new RangeError("targetStart out of bounds");
    if (Ce < 0 || Ce >= this.length)
      throw new RangeError("Index out of range");
    if (Be < 0)
      throw new RangeError("sourceEnd out of bounds");
    Be > this.length && (Be = this.length), ce.length - me < Be - Ce && (Be = ce.length - me + Ce);
    const ze = Be - Ce;
    return this === ce && typeof p.prototype.copyWithin == "function" ? this.copyWithin(me, Ce, Be) : p.prototype.set.call(
      ce,
      this.subarray(Ce, Be),
      me
    ), ze;
  }, F.prototype.fill = function(ce, me, Ce, Be) {
    if (typeof ce == "string") {
      if (typeof me == "string" ? (Be = me, me = 0, Ce = this.length) : typeof Ce == "string" && (Be = Ce, Ce = this.length), Be !== void 0 && typeof Be != "string")
        throw new TypeError("encoding must be a string");
      if (typeof Be == "string" && !F.isEncoding(Be))
        throw new TypeError("Unknown encoding: " + Be);
      if (ce.length === 1) {
        const Je = ce.charCodeAt(0);
        (Be === "utf8" && Je < 128 || Be === "latin1") && (ce = Je);
      }
    } else
      typeof ce == "number" ? ce = ce & 255 : typeof ce == "boolean" && (ce = Number(ce));
    if (me < 0 || this.length < me || this.length < Ce)
      throw new RangeError("Out of range index");
    if (Ce <= me)
      return this;
    me = me >>> 0, Ce = Ce === void 0 ? this.length : Ce >>> 0, ce || (ce = 0);
    let ze;
    if (typeof ce == "number")
      for (ze = me; ze < Ce; ++ze)
        this[ze] = ce;
    else {
      const Je = F.isBuffer(ce) ? ce : F.from(ce, Be), Ze = Je.length;
      if (Ze === 0)
        throw new TypeError('The value "' + ce + '" is invalid for argument "value"');
      for (ze = 0; ze < Ce - me; ++ze)
        this[ze + me] = Je[ze % Ze];
    }
    return this;
  };
  const oe = {};
  function A(ue, ce, me) {
    oe[ue] = class extends me {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: ce.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${ue}]`, this.stack, delete this.name;
      }
      get code() {
        return ue;
      }
      set code(Be) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: Be,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${ue}]: ${this.message}`;
      }
    };
  }
  A(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(ue) {
      return ue ? `${ue} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), A(
    "ERR_INVALID_ARG_TYPE",
    function(ue, ce) {
      return `The "${ue}" argument must be of type number. Received type ${typeof ce}`;
    },
    TypeError
  ), A(
    "ERR_OUT_OF_RANGE",
    function(ue, ce, me) {
      let Ce = `The value of "${ue}" is out of range.`, Be = me;
      return Number.isInteger(me) && Math.abs(me) > 2 ** 32 ? Be = re(String(me)) : typeof me == "bigint" && (Be = String(me), (me > BigInt(2) ** BigInt(32) || me < -(BigInt(2) ** BigInt(32))) && (Be = re(Be)), Be += "n"), Ce += ` It must be ${ce}. Received ${Be}`, Ce;
    },
    RangeError
  );
  function re(ue) {
    let ce = "", me = ue.length;
    const Ce = ue[0] === "-" ? 1 : 0;
    for (; me >= Ce + 4; me -= 3)
      ce = `_${ue.slice(me - 3, me)}${ce}`;
    return `${ue.slice(0, me)}${ce}`;
  }
  function le(ue, ce, me) {
    Pe(ce, "offset"), (ue[ce] === void 0 || ue[ce + me] === void 0) && Fe(ce, ue.length - (me + 1));
  }
  function Ne(ue, ce, me, Ce, Be, ze) {
    if (ue > me || ue < ce) {
      const Je = typeof ce == "bigint" ? "n" : "";
      let Ze;
      throw ze > 3 ? ce === 0 || ce === BigInt(0) ? Ze = `>= 0${Je} and < 2${Je} ** ${(ze + 1) * 8}${Je}` : Ze = `>= -(2${Je} ** ${(ze + 1) * 8 - 1}${Je}) and < 2 ** ${(ze + 1) * 8 - 1}${Je}` : Ze = `>= ${ce}${Je} and <= ${me}${Je}`, new oe.ERR_OUT_OF_RANGE("value", Ze, ue);
    }
    le(Ce, Be, ze);
  }
  function Pe(ue, ce) {
    if (typeof ue != "number")
      throw new oe.ERR_INVALID_ARG_TYPE(ce, "number", ue);
  }
  function Fe(ue, ce, me) {
    throw Math.floor(ue) !== ue ? (Pe(ue, me), new oe.ERR_OUT_OF_RANGE(me || "offset", "an integer", ue)) : ce < 0 ? new oe.ERR_BUFFER_OUT_OF_BOUNDS() : new oe.ERR_OUT_OF_RANGE(
      me || "offset",
      `>= ${me ? 1 : 0} and <= ${ce}`,
      ue
    );
  }
  const je = /[^+/0-9A-Za-z-_]/g;
  function qe(ue) {
    if (ue = ue.split("=")[0], ue = ue.trim().replace(je, ""), ue.length < 2)
      return "";
    for (; ue.length % 4 !== 0; )
      ue = ue + "=";
    return ue;
  }
  function yt(ue, ce) {
    ce = ce || 1 / 0;
    let me;
    const Ce = ue.length;
    let Be = null;
    const ze = [];
    for (let Je = 0; Je < Ce; ++Je) {
      if (me = ue.charCodeAt(Je), me > 55295 && me < 57344) {
        if (!Be) {
          if (me > 56319) {
            (ce -= 3) > -1 && ze.push(239, 191, 189);
            continue;
          } else if (Je + 1 === Ce) {
            (ce -= 3) > -1 && ze.push(239, 191, 189);
            continue;
          }
          Be = me;
          continue;
        }
        if (me < 56320) {
          (ce -= 3) > -1 && ze.push(239, 191, 189), Be = me;
          continue;
        }
        me = (Be - 55296 << 10 | me - 56320) + 65536;
      } else
        Be && (ce -= 3) > -1 && ze.push(239, 191, 189);
      if (Be = null, me < 128) {
        if ((ce -= 1) < 0)
          break;
        ze.push(me);
      } else if (me < 2048) {
        if ((ce -= 2) < 0)
          break;
        ze.push(
          me >> 6 | 192,
          me & 63 | 128
        );
      } else if (me < 65536) {
        if ((ce -= 3) < 0)
          break;
        ze.push(
          me >> 12 | 224,
          me >> 6 & 63 | 128,
          me & 63 | 128
        );
      } else if (me < 1114112) {
        if ((ce -= 4) < 0)
          break;
        ze.push(
          me >> 18 | 240,
          me >> 12 & 63 | 128,
          me >> 6 & 63 | 128,
          me & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return ze;
  }
  function Xe(ue) {
    const ce = [];
    for (let me = 0; me < ue.length; ++me)
      ce.push(ue.charCodeAt(me) & 255);
    return ce;
  }
  function Ge(ue, ce) {
    let me, Ce, Be;
    const ze = [];
    for (let Je = 0; Je < ue.length && !((ce -= 2) < 0); ++Je)
      me = ue.charCodeAt(Je), Ce = me >> 8, Be = me % 256, ze.push(Be), ze.push(Ce);
    return ze;
  }
  function H(ue) {
    return u.toByteArray(qe(ue));
  }
  function ye(ue, ce, me, Ce) {
    let Be;
    for (Be = 0; Be < Ce && !(Be + me >= ce.length || Be >= ue.length); ++Be)
      ce[Be + me] = ue[Be];
    return Be;
  }
  function Ee(ue, ce) {
    return ue instanceof ce || ue != null && ue.constructor != null && ue.constructor.name != null && ue.constructor.name === ce.name;
  }
  function We(ue) {
    return ue !== ue;
  }
  const we = function() {
    const ue = "0123456789abcdef", ce = new Array(256);
    for (let me = 0; me < 16; ++me) {
      const Ce = me * 16;
      for (let Be = 0; Be < 16; ++Be)
        ce[Ce + Be] = ue[me] + ue[Be];
    }
    return ce;
  }();
  function V(ue) {
    return typeof BigInt > "u" ? _e : ue;
  }
  function _e() {
    throw new Error("BigInt not supported");
  }
})(buffer$3);
const Buffer$O = buffer$3.Buffer, Blob$1 = buffer$3.Blob, BlobOptions = buffer$3.BlobOptions, Buffer$1$1 = buffer$3.Buffer, File = buffer$3.File, FileOptions = buffer$3.FileOptions, INSPECT_MAX_BYTES = buffer$3.INSPECT_MAX_BYTES, SlowBuffer$1 = buffer$3.SlowBuffer, TranscodeEncoding = buffer$3.TranscodeEncoding, atob$1 = buffer$3.atob, btoa$1 = buffer$3.btoa, constants$1 = buffer$3.constants, isAscii = buffer$3.isAscii, isUtf8 = buffer$3.isUtf8, kMaxLength = buffer$3.kMaxLength, kStringMaxLength = buffer$3.kStringMaxLength, resolveObjectURL = buffer$3.resolveObjectURL, transcode = buffer$3.transcode, dist$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Blob: Blob$1,
  BlobOptions,
  Buffer: Buffer$1$1,
  File,
  FileOptions,
  INSPECT_MAX_BYTES,
  SlowBuffer: SlowBuffer$1,
  TranscodeEncoding,
  atob: atob$1,
  btoa: btoa$1,
  constants: constants$1,
  default: Buffer$O,
  isAscii,
  isUtf8,
  kMaxLength,
  kStringMaxLength,
  resolveObjectURL,
  transcode
}, Symbol.toStringTag, { value: "Module" }));
var base64$2 = { exports: {} };
(function(a, u) {
  (function(c, l) {
    a.exports = l();
  })(typeof self < "u" ? self : typeof window < "u" ? window : commonjsGlobal$1, function() {
    var c = "3.7.2", l = c, v = typeof atob == "function", p = typeof btoa == "function", _ = typeof Buffer$O == "function", k = typeof TextDecoder == "function" ? new TextDecoder() : void 0, O = typeof TextEncoder == "function" ? new TextEncoder() : void 0, D = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", F = Array.prototype.slice.call(D), z = function(he) {
      var Oe = {};
      return he.forEach(function(Ae, Ue) {
        return Oe[Ae] = Ue;
      }), Oe;
    }(F), j = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/, ee = String.fromCharCode.bind(String), X = typeof Uint8Array.from == "function" ? Uint8Array.from.bind(Uint8Array) : function(he, Oe) {
      return Oe === void 0 && (Oe = function(Ae) {
        return Ae;
      }), new Uint8Array(Array.prototype.slice.call(he, 0).map(Oe));
    }, ae = function(he) {
      return he.replace(/=/g, "").replace(/[+\/]/g, function(Oe) {
        return Oe == "+" ? "-" : "_";
      });
    }, Q = function(he) {
      return he.replace(/[^A-Za-z0-9\+\/]/g, "");
    }, ne = function(he) {
      for (var Oe, Ae, Ue, oe, A = "", re = he.length % 3, le = 0; le < he.length; ) {
        if ((Ae = he.charCodeAt(le++)) > 255 || (Ue = he.charCodeAt(le++)) > 255 || (oe = he.charCodeAt(le++)) > 255)
          throw new TypeError("invalid character found");
        Oe = Ae << 16 | Ue << 8 | oe, A += F[Oe >> 18 & 63] + F[Oe >> 12 & 63] + F[Oe >> 6 & 63] + F[Oe & 63];
      }
      return re ? A.slice(0, re - 3) + "===".substring(re) : A;
    }, Z = p ? function(he) {
      return btoa(he);
    } : _ ? function(he) {
      return Buffer$O.from(he, "binary").toString("base64");
    } : ne, de = _ ? function(he) {
      return Buffer$O.from(he).toString("base64");
    } : function(he) {
      for (var Oe = 4096, Ae = [], Ue = 0, oe = he.length; Ue < oe; Ue += Oe)
        Ae.push(ee.apply(null, he.subarray(Ue, Ue + Oe)));
      return Z(Ae.join(""));
    }, fe = function(he, Oe) {
      return Oe === void 0 && (Oe = !1), Oe ? ae(de(he)) : de(he);
    }, Te = function(he) {
      if (he.length < 2) {
        var Oe = he.charCodeAt(0);
        return Oe < 128 ? he : Oe < 2048 ? ee(192 | Oe >>> 6) + ee(128 | Oe & 63) : ee(224 | Oe >>> 12 & 15) + ee(128 | Oe >>> 6 & 63) + ee(128 | Oe & 63);
      } else {
        var Oe = 65536 + (he.charCodeAt(0) - 55296) * 1024 + (he.charCodeAt(1) - 56320);
        return ee(240 | Oe >>> 18 & 7) + ee(128 | Oe >>> 12 & 63) + ee(128 | Oe >>> 6 & 63) + ee(128 | Oe & 63);
      }
    }, Re = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g, Le = function(he) {
      return he.replace(Re, Te);
    }, be = _ ? function(he) {
      return Buffer$O.from(he, "utf8").toString("base64");
    } : O ? function(he) {
      return de(O.encode(he));
    } : function(he) {
      return Z(Le(he));
    }, q = function(he, Oe) {
      return Oe === void 0 && (Oe = !1), Oe ? ae(be(he)) : be(he);
    }, J = function(he) {
      return q(he, !0);
    }, C = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g, S = function(he) {
      switch (he.length) {
        case 4:
          var Oe = (7 & he.charCodeAt(0)) << 18 | (63 & he.charCodeAt(1)) << 12 | (63 & he.charCodeAt(2)) << 6 | 63 & he.charCodeAt(3), Ae = Oe - 65536;
          return ee((Ae >>> 10) + 55296) + ee((Ae & 1023) + 56320);
        case 3:
          return ee((15 & he.charCodeAt(0)) << 12 | (63 & he.charCodeAt(1)) << 6 | 63 & he.charCodeAt(2));
        default:
          return ee((31 & he.charCodeAt(0)) << 6 | 63 & he.charCodeAt(1));
      }
    }, E = function(he) {
      return he.replace(C, S);
    }, I = function(he) {
      if (he = he.replace(/\s+/g, ""), !j.test(he))
        throw new TypeError("malformed base64.");
      he += "==".slice(2 - (he.length & 3));
      for (var Oe, Ae = "", Ue, oe, A = 0; A < he.length; )
        Oe = z[he.charAt(A++)] << 18 | z[he.charAt(A++)] << 12 | (Ue = z[he.charAt(A++)]) << 6 | (oe = z[he.charAt(A++)]), Ae += Ue === 64 ? ee(Oe >> 16 & 255) : oe === 64 ? ee(Oe >> 16 & 255, Oe >> 8 & 255) : ee(Oe >> 16 & 255, Oe >> 8 & 255, Oe & 255);
      return Ae;
    }, M = v ? function(he) {
      return atob(Q(he));
    } : _ ? function(he) {
      return Buffer$O.from(he, "base64").toString("binary");
    } : I, $ = _ ? function(he) {
      return X(Buffer$O.from(he, "base64"));
    } : function(he) {
      return X(M(he), function(Oe) {
        return Oe.charCodeAt(0);
      });
    }, U = function(he) {
      return $(L(he));
    }, Y = _ ? function(he) {
      return Buffer$O.from(he, "base64").toString("utf8");
    } : k ? function(he) {
      return k.decode($(he));
    } : function(he) {
      return E(M(he));
    }, L = function(he) {
      return Q(he.replace(/[-_]/g, function(Oe) {
        return Oe == "-" ? "+" : "/";
      }));
    }, T = function(he) {
      return Y(L(he));
    }, B = function(he) {
      if (typeof he != "string")
        return !1;
      var Oe = he.replace(/\s+/g, "").replace(/={0,2}$/, "");
      return !/[^\s0-9a-zA-Z\+/]/.test(Oe) || !/[^\s0-9a-zA-Z\-_]/.test(Oe);
    }, te = function(he) {
      return {
        value: he,
        enumerable: !1,
        writable: !0,
        configurable: !0
      };
    }, pe = function() {
      var he = function(Oe, Ae) {
        return Object.defineProperty(String.prototype, Oe, te(Ae));
      };
      he("fromBase64", function() {
        return T(this);
      }), he("toBase64", function(Oe) {
        return q(this, Oe);
      }), he("toBase64URI", function() {
        return q(this, !0);
      }), he("toBase64URL", function() {
        return q(this, !0);
      }), he("toUint8Array", function() {
        return U(this);
      });
    }, Ie = function() {
      var he = function(Oe, Ae) {
        return Object.defineProperty(Uint8Array.prototype, Oe, te(Ae));
      };
      he("toBase64", function(Oe) {
        return fe(this, Oe);
      }), he("toBase64URI", function() {
        return fe(this, !0);
      }), he("toBase64URL", function() {
        return fe(this, !0);
      });
    }, $e = function() {
      pe(), Ie();
    }, ve = {
      version: c,
      VERSION: l,
      atob: M,
      atobPolyfill: I,
      btoa: Z,
      btoaPolyfill: ne,
      fromBase64: T,
      toBase64: q,
      encode: q,
      encodeURI: J,
      encodeURL: J,
      utob: Le,
      btou: E,
      decode: T,
      isValid: B,
      fromUint8Array: fe,
      toUint8Array: U,
      extendString: pe,
      extendUint8Array: Ie,
      extendBuiltins: $e
    };
    return ve.Base64 = {}, Object.keys(ve).forEach(function(he) {
      return ve.Base64[he] = ve[he];
    }), ve;
  });
})(base64$2);
var base64Exports = base64$2.exports;
Object.defineProperty(convertMetadata, "__esModule", { value: !0 });
convertMetadata.convertMetadataFromGrpcWeb = convertMetadata.convertMetadataToGrpcWeb = void 0;
const grpc_web_1$4 = grpcWebClient_umdExports, nice_grpc_common_1$5 = lib, js_base64_1 = base64Exports;
function convertMetadataToGrpcWeb(a) {
  const u = new grpc_web_1$4.grpc.Metadata();
  for (const [c, l] of a)
    for (const v of l)
      u.append(c, typeof v == "string" ? v : js_base64_1.Base64.fromUint8Array(v));
  return u;
}
convertMetadata.convertMetadataToGrpcWeb = convertMetadataToGrpcWeb;
function convertMetadataFromGrpcWeb(a) {
  const u = (0, nice_grpc_common_1$5.Metadata)();
  for (const [c, l] of Object.entries(a.headersMap))
    u.set(c, c.endsWith("-bin") ? l.map((v) => js_base64_1.Base64.toUint8Array(v)) : l);
  return u;
}
convertMetadata.convertMetadataFromGrpcWeb = convertMetadataFromGrpcWeb;
var __importDefault$h = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(createBidiStreamingMethod$1, "__esModule", { value: !0 });
createBidiStreamingMethod$1.createBidiStreamingMethod = void 0;
const nice_grpc_common_1$4 = lib, grpc_web_1$3 = grpcWebClient_umdExports, abort_controller_x_1$4 = require$$1$3, node_abort_controller_1$3 = __importDefault$h(browserExports$2), AsyncSink_1$1 = AsyncSink$1, service_definitions_1$4 = serviceDefinitions, isAsyncIterable_1$3 = isAsyncIterable$1, convertMetadata_1$3 = convertMetadata;
function createBidiStreamingMethod(a, u, c, l) {
  const v = (0, service_definitions_1$4.toGrpcWebMethodDefinition)(a), p = {
    path: a.path,
    requestStream: a.requestStream,
    responseStream: a.responseStream,
    options: a.options
  };
  async function* _(O, D) {
    if (!(0, isAsyncIterable_1$3.isAsyncIterable)(O))
      throw new Error("A middleware passed invalid request to next(): expected a single message for bidirectional streaming method");
    const { metadata: F = (0, nice_grpc_common_1$4.Metadata)(), signal: z = new node_abort_controller_1$3.default().signal, onHeader: j, onTrailer: ee } = D, X = new node_abort_controller_1$3.default(), ae = new AsyncSink_1$1.AsyncSink(), Q = grpc_web_1$3.grpc.client(v, {
      host: u.address,
      transport: u.transport
    });
    Q.onHeaders((de) => {
      j == null || j((0, convertMetadata_1$3.convertMetadataFromGrpcWeb)(de));
    }), Q.onMessage((de) => {
      ae.write(de);
    }), Q.onEnd((de, fe, Te) => {
      ee == null || ee((0, convertMetadata_1$3.convertMetadataFromGrpcWeb)(Te)), de === grpc_web_1$3.grpc.Code.OK ? ae.end() : ae.error(new nice_grpc_common_1$4.ClientError(a.path, +de, fe));
    }), Q.start((0, convertMetadata_1$3.convertMetadataToGrpcWeb)(F));
    let ne;
    pipeRequest$1(X.signal, O, Q, a).then(() => {
      Q.finishSend();
    }, (de) => {
      (0, abort_controller_x_1$4.isAbortError)(de) || (ne = de, Q.close(), ae.end());
    });
    const Z = () => {
      ae.error(new abort_controller_x_1$4.AbortError()), X.abort(), Q.close();
    };
    z.addEventListener("abort", Z);
    try {
      yield* ae;
    } finally {
      if (X.abort(), z.removeEventListener("abort", Z), (0, abort_controller_x_1$4.throwIfAborted)(z), ne)
        throw ne;
    }
  }
  const k = c == null ? _ : (O, D) => c({
    method: p,
    requestStream: !0,
    request: O,
    responseStream: !0,
    next: _
  }, D);
  return (O, D) => {
    const z = k(O, {
      ...l,
      ...D
    })[Symbol.asyncIterator]();
    return {
      [Symbol.asyncIterator]() {
        return {
          async next() {
            const j = await z.next();
            return j.done && j.value != null ? await z.throw(new Error("A middleware returned a message, but expected to return void for bidirectional streaming method")) : j;
          },
          return() {
            return z.return();
          },
          throw(j) {
            return z.throw(j);
          }
        };
      }
    };
  };
}
createBidiStreamingMethod$1.createBidiStreamingMethod = createBidiStreamingMethod;
async function pipeRequest$1(a, u, c, l) {
  for await (const v of u)
    (0, abort_controller_x_1$4.throwIfAborted)(a), c.send({
      serializeBinary: () => l.requestSerialize(v)
    });
}
var createClientStreamingMethod$1 = {}, __importDefault$g = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(createClientStreamingMethod$1, "__esModule", { value: !0 });
createClientStreamingMethod$1.createClientStreamingMethod = void 0;
const nice_grpc_common_1$3 = lib, grpc_web_1$2 = grpcWebClient_umdExports, abort_controller_x_1$3 = require$$1$3, node_abort_controller_1$2 = __importDefault$g(browserExports$2), service_definitions_1$3 = serviceDefinitions, isAsyncIterable_1$2 = isAsyncIterable$1, convertMetadata_1$2 = convertMetadata;
function createClientStreamingMethod(a, u, c, l) {
  const v = (0, service_definitions_1$3.toGrpcWebMethodDefinition)(a), p = {
    path: a.path,
    requestStream: a.requestStream,
    responseStream: a.responseStream,
    options: a.options
  };
  async function* _(O, D) {
    if (!(0, isAsyncIterable_1$2.isAsyncIterable)(O))
      throw new Error("A middleware passed invalid request to next(): expected a single message for client streaming method");
    const { metadata: F = (0, nice_grpc_common_1$3.Metadata)(), signal: z = new node_abort_controller_1$2.default().signal, onHeader: j, onTrailer: ee } = D;
    return await (0, abort_controller_x_1$3.execute)(z, (X, ae) => {
      const Q = new node_abort_controller_1$2.default();
      let ne;
      const Z = grpc_web_1$2.grpc.client(v, {
        host: u.address,
        transport: u.transport
      });
      return Z.onHeaders((de) => {
        j == null || j((0, convertMetadata_1$2.convertMetadataFromGrpcWeb)(de));
      }), Z.onMessage((de) => {
        ne = de;
      }), Z.onEnd((de, fe, Te) => {
        ee == null || ee((0, convertMetadata_1$2.convertMetadataFromGrpcWeb)(Te)), Q.abort(), de === grpc_web_1$2.grpc.Code.OK ? X(ne) : ae(new nice_grpc_common_1$3.ClientError(a.path, +de, fe));
      }), Z.start((0, convertMetadata_1$2.convertMetadataToGrpcWeb)(F)), pipeRequest(Q.signal, O, Z, a).then(() => {
        Z.finishSend();
      }, (de) => {
        (0, abort_controller_x_1$3.isAbortError)(de) || (ae(de), Z.close());
      }), () => {
        Q.abort(), Z.close();
      };
    });
  }
  const k = c == null ? _ : (O, D) => c({
    method: p,
    requestStream: !0,
    request: O,
    responseStream: !1,
    next: _
  }, D);
  return async (O, D) => {
    const z = k(O, {
      ...l,
      ...D
    })[Symbol.asyncIterator]();
    let j = await z.next();
    for (; ; ) {
      if (!j.done) {
        j = await z.throw(new Error("A middleware yielded a message, but expected to only return a message for client streaming method"));
        continue;
      }
      if (j.value == null) {
        j = await z.throw(new Error("A middleware returned void, but expected to return a message for client streaming method"));
        continue;
      }
      return j.value;
    }
  };
}
createClientStreamingMethod$1.createClientStreamingMethod = createClientStreamingMethod;
async function pipeRequest(a, u, c, l) {
  for await (const v of u)
    (0, abort_controller_x_1$3.throwIfAborted)(a), c.send({
      serializeBinary: () => l.requestSerialize(v)
    });
}
var createServerStreamingMethod$1 = {}, __importDefault$f = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(createServerStreamingMethod$1, "__esModule", { value: !0 });
createServerStreamingMethod$1.createServerStreamingMethod = void 0;
const grpc_web_1$1 = grpcWebClient_umdExports, abort_controller_x_1$2 = require$$1$3, AsyncSink_1 = AsyncSink$1, nice_grpc_common_1$2 = lib, node_abort_controller_1$1 = __importDefault$f(browserExports$2), service_definitions_1$2 = serviceDefinitions, convertMetadata_1$1 = convertMetadata, isAsyncIterable_1$1 = isAsyncIterable$1;
function createServerStreamingMethod(a, u, c, l) {
  const v = (0, service_definitions_1$2.toGrpcWebMethodDefinition)(a), p = {
    path: a.path,
    requestStream: a.requestStream,
    responseStream: a.responseStream,
    options: a.options
  };
  async function* _(O, D) {
    if ((0, isAsyncIterable_1$1.isAsyncIterable)(O))
      throw new Error("A middleware passed invalid request to next(): expected a single message for server streaming method");
    const { metadata: F = (0, nice_grpc_common_1$2.Metadata)(), signal: z = new node_abort_controller_1$1.default().signal, onHeader: j, onTrailer: ee } = D, X = new AsyncSink_1.AsyncSink(), ae = grpc_web_1$1.grpc.client(v, {
      host: u.address,
      transport: u.transport
    });
    ae.onHeaders((ne) => {
      j == null || j((0, convertMetadata_1$1.convertMetadataFromGrpcWeb)(ne));
    }), ae.onMessage((ne) => {
      X.write(ne);
    }), ae.onEnd((ne, Z, de) => {
      ee == null || ee((0, convertMetadata_1$1.convertMetadataFromGrpcWeb)(de)), ne === grpc_web_1$1.grpc.Code.OK ? X.end() : X.error(new nice_grpc_common_1$2.ClientError(a.path, +ne, Z));
    }), ae.start((0, convertMetadata_1$1.convertMetadataToGrpcWeb)(F)), ae.send({
      serializeBinary: () => a.requestSerialize(O)
    }), ae.finishSend();
    const Q = () => {
      X.error(new abort_controller_x_1$2.AbortError()), ae.close();
    };
    z.addEventListener("abort", Q);
    try {
      yield* X;
    } finally {
      z.removeEventListener("abort", Q), (0, abort_controller_x_1$2.throwIfAborted)(z);
    }
  }
  const k = c == null ? _ : (O, D) => c({
    method: p,
    requestStream: !1,
    request: O,
    responseStream: !0,
    next: _
  }, D);
  return (O, D) => {
    const z = k(O, {
      ...l,
      ...D
    })[Symbol.asyncIterator]();
    return {
      [Symbol.asyncIterator]() {
        return {
          async next() {
            const j = await z.next();
            return j.done && j.value != null ? await z.throw(new Error("A middleware returned a message, but expected to return void for server streaming method")) : j;
          },
          return() {
            return z.return();
          },
          throw(j) {
            return z.throw(j);
          }
        };
      }
    };
  };
}
createServerStreamingMethod$1.createServerStreamingMethod = createServerStreamingMethod;
var createUnaryMethod$1 = {}, __importDefault$e = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(createUnaryMethod$1, "__esModule", { value: !0 });
createUnaryMethod$1.createUnaryMethod = void 0;
const nice_grpc_common_1$1 = lib, grpc_web_1 = grpcWebClient_umdExports, abort_controller_x_1$1 = require$$1$3, node_abort_controller_1 = __importDefault$e(browserExports$2), service_definitions_1$1 = serviceDefinitions, isAsyncIterable_1 = isAsyncIterable$1, convertMetadata_1 = convertMetadata;
function createUnaryMethod(a, u, c, l) {
  const v = (0, service_definitions_1$1.toGrpcWebMethodDefinition)(a), p = {
    path: a.path,
    requestStream: a.requestStream,
    responseStream: a.responseStream,
    options: a.options
  };
  async function* _(O, D) {
    if ((0, isAsyncIterable_1.isAsyncIterable)(O))
      throw new Error("A middleware passed invalid request to next(): expected a single message for unary method");
    const { metadata: F = (0, nice_grpc_common_1$1.Metadata)(), signal: z = new node_abort_controller_1.default().signal, onHeader: j, onTrailer: ee } = D;
    return await (0, abort_controller_x_1$1.execute)(z, (X, ae) => {
      let Q;
      const ne = grpc_web_1.grpc.client(v, {
        host: u.address,
        transport: u.transport
      });
      return ne.onHeaders((Z) => {
        j == null || j((0, convertMetadata_1.convertMetadataFromGrpcWeb)(Z));
      }), ne.onMessage((Z) => {
        Q = Z;
      }), ne.onEnd((Z, de, fe) => {
        ee == null || ee((0, convertMetadata_1.convertMetadataFromGrpcWeb)(fe)), Z === grpc_web_1.grpc.Code.OK ? X(Q) : ae(new nice_grpc_common_1$1.ClientError(a.path, +Z, de));
      }), ne.start((0, convertMetadata_1.convertMetadataToGrpcWeb)(F)), ne.send({
        serializeBinary: () => a.requestSerialize(O)
      }), ne.finishSend(), () => {
        ne.close();
      };
    });
  }
  const k = c == null ? _ : (O, D) => c({
    method: p,
    requestStream: !1,
    request: O,
    responseStream: !1,
    next: _
  }, D);
  return async (O, D) => {
    const z = k(O, {
      ...l,
      ...D
    })[Symbol.asyncIterator]();
    let j = await z.next();
    for (; ; ) {
      if (!j.done) {
        j = await z.throw(new Error("A middleware yielded a message, but expected to only return a message for unary method"));
        continue;
      }
      if (j.value == null) {
        j = await z.throw(new Error("A middleware returned void, but expected to return a message for unary method"));
        continue;
      }
      return j.value;
    }
  };
}
createUnaryMethod$1.createUnaryMethod = createUnaryMethod;
Object.defineProperty(ClientFactory, "__esModule", { value: !0 });
ClientFactory.createClient = ClientFactory.createClientFactory = void 0;
const nice_grpc_common_1 = lib, service_definitions_1 = serviceDefinitions, createBidiStreamingMethod_1 = createBidiStreamingMethod$1, createClientStreamingMethod_1 = createClientStreamingMethod$1, createServerStreamingMethod_1 = createServerStreamingMethod$1, createUnaryMethod_1 = createUnaryMethod$1;
function createClientFactory() {
  return createClientFactoryWithMiddleware();
}
ClientFactory.createClientFactory = createClientFactory;
function createClient(a, u, c) {
  return createClientFactory().create(a, u, c);
}
ClientFactory.createClient = createClient;
function createClientFactoryWithMiddleware(a) {
  return {
    use(u) {
      return createClientFactoryWithMiddleware(a == null ? u : (0, nice_grpc_common_1.composeClientMiddleware)(a, u));
    },
    create(u, c, l = {}) {
      const v = {}, p = Object.entries((0, service_definitions_1.normalizeServiceDefinition)(u));
      for (const [_, k] of p) {
        const O = {
          ...l["*"],
          ...l[_]
        };
        k.requestStream ? k.responseStream ? v[_] = (0, createBidiStreamingMethod_1.createBidiStreamingMethod)(k, c, a, O) : v[_] = (0, createClientStreamingMethod_1.createClientStreamingMethod)(k, c, a, O) : k.responseStream ? v[_] = (0, createServerStreamingMethod_1.createServerStreamingMethod)(k, c, a, O) : v[_] = (0, createUnaryMethod_1.createUnaryMethod)(k, c, a, O);
      }
      return v;
    }
  };
}
var Client = {};
Object.defineProperty(Client, "__esModule", { value: !0 });
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(v, p, _, k) {
    k === void 0 && (k = _);
    var O = Object.getOwnPropertyDescriptor(p, _);
    (!O || ("get" in O ? !p.__esModule : O.writable || O.configurable)) && (O = { enumerable: !0, get: function() {
      return p[_];
    } }), Object.defineProperty(v, k, O);
  } : function(v, p, _, k) {
    k === void 0 && (k = _), v[k] = p[_];
  }), c = commonjsGlobal$1 && commonjsGlobal$1.__exportStar || function(v, p) {
    for (var _ in v)
      _ !== "default" && !Object.prototype.hasOwnProperty.call(p, _) && u(p, v, _);
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.Status = a.Metadata = a.composeClientMiddleware = a.ClientError = void 0;
  var l = lib;
  Object.defineProperty(a, "ClientError", { enumerable: !0, get: function() {
    return l.ClientError;
  } }), Object.defineProperty(a, "composeClientMiddleware", { enumerable: !0, get: function() {
    return l.composeClientMiddleware;
  } }), Object.defineProperty(a, "Metadata", { enumerable: !0, get: function() {
    return l.Metadata;
  } }), Object.defineProperty(a, "Status", { enumerable: !0, get: function() {
    return l.Status;
  } }), c(serviceDefinitions, a), c(channel, a), c(ClientFactory, a), c(Client, a);
})(lib$1);
var dist$2 = {}, api$4 = {}, umd = { exports: {} };
(function(a, u) {
  var c = function(l) {
    Object.defineProperty(l, "__esModule", {
      value: !0
    }), l.default = void 0;
    /**
     * @license
     * Copyright 2009 The Closure Library Authors
     * Copyright 2020 Daniel Wirtz / The long.js Authors.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
     * SPDX-License-Identifier: Apache-2.0
     */
    var v = null;
    try {
      v = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
    } catch {
    }
    function p($, U, Y) {
      this.low = $ | 0, this.high = U | 0, this.unsigned = !!Y;
    }
    p.prototype.__isLong__, Object.defineProperty(p.prototype, "__isLong__", {
      value: !0
    });
    function _($) {
      return ($ && $.__isLong__) === !0;
    }
    function k($) {
      var U = Math.clz32($ & -$);
      return $ ? 31 - U : U;
    }
    p.isLong = _;
    var O = {}, D = {};
    function F($, U) {
      var Y, L, T;
      return U ? ($ >>>= 0, (T = 0 <= $ && $ < 256) && (L = D[$], L) ? L : (Y = j($, 0, !0), T && (D[$] = Y), Y)) : ($ |= 0, (T = -128 <= $ && $ < 128) && (L = O[$], L) ? L : (Y = j($, $ < 0 ? -1 : 0, !1), T && (O[$] = Y), Y));
    }
    p.fromInt = F;
    function z($, U) {
      if (isNaN($))
        return U ? Le : Re;
      if (U) {
        if ($ < 0)
          return Le;
        if ($ >= de)
          return S;
      } else {
        if ($ <= -fe)
          return E;
        if ($ + 1 >= fe)
          return C;
      }
      return $ < 0 ? z(-$, U).neg() : j($ % Z | 0, $ / Z | 0, U);
    }
    p.fromNumber = z;
    function j($, U, Y) {
      return new p($, U, Y);
    }
    p.fromBits = j;
    var ee = Math.pow;
    function X($, U, Y) {
      if ($.length === 0)
        throw Error("empty string");
      if (typeof U == "number" ? (Y = U, U = !1) : U = !!U, $ === "NaN" || $ === "Infinity" || $ === "+Infinity" || $ === "-Infinity")
        return U ? Le : Re;
      if (Y = Y || 10, Y < 2 || 36 < Y)
        throw RangeError("radix");
      var L;
      if ((L = $.indexOf("-")) > 0)
        throw Error("interior hyphen");
      if (L === 0)
        return X($.substring(1), U, Y).neg();
      for (var T = z(ee(Y, 8)), B = Re, te = 0; te < $.length; te += 8) {
        var pe = Math.min(8, $.length - te), Ie = parseInt($.substring(te, te + pe), Y);
        if (pe < 8) {
          var $e = z(ee(Y, pe));
          B = B.mul($e).add(z(Ie));
        } else
          B = B.mul(T), B = B.add(z(Ie));
      }
      return B.unsigned = U, B;
    }
    p.fromString = X;
    function ae($, U) {
      return typeof $ == "number" ? z($, U) : typeof $ == "string" ? X($, U) : j($.low, $.high, typeof U == "boolean" ? U : $.unsigned);
    }
    p.fromValue = ae;
    var Q = 65536, ne = 1 << 24, Z = Q * Q, de = Z * Z, fe = de / 2, Te = F(ne), Re = F(0);
    p.ZERO = Re;
    var Le = F(0, !0);
    p.UZERO = Le;
    var be = F(1);
    p.ONE = be;
    var q = F(1, !0);
    p.UONE = q;
    var J = F(-1);
    p.NEG_ONE = J;
    var C = j(-1, 2147483647, !1);
    p.MAX_VALUE = C;
    var S = j(-1, -1, !0);
    p.MAX_UNSIGNED_VALUE = S;
    var E = j(0, -2147483648, !1);
    p.MIN_VALUE = E;
    var I = p.prototype;
    I.toInt = function() {
      return this.unsigned ? this.low >>> 0 : this.low;
    }, I.toNumber = function() {
      return this.unsigned ? (this.high >>> 0) * Z + (this.low >>> 0) : this.high * Z + (this.low >>> 0);
    }, I.toString = function(U) {
      if (U = U || 10, U < 2 || 36 < U)
        throw RangeError("radix");
      if (this.isZero())
        return "0";
      if (this.isNegative())
        if (this.eq(E)) {
          var Y = z(U), L = this.div(Y), T = L.mul(Y).sub(this);
          return L.toString(U) + T.toInt().toString(U);
        } else
          return "-" + this.neg().toString(U);
      for (var B = z(ee(U, 6), this.unsigned), te = this, pe = ""; ; ) {
        var Ie = te.div(B), $e = te.sub(Ie.mul(B)).toInt() >>> 0, ve = $e.toString(U);
        if (te = Ie, te.isZero())
          return ve + pe;
        for (; ve.length < 6; )
          ve = "0" + ve;
        pe = "" + ve + pe;
      }
    }, I.getHighBits = function() {
      return this.high;
    }, I.getHighBitsUnsigned = function() {
      return this.high >>> 0;
    }, I.getLowBits = function() {
      return this.low;
    }, I.getLowBitsUnsigned = function() {
      return this.low >>> 0;
    }, I.getNumBitsAbs = function() {
      if (this.isNegative())
        return this.eq(E) ? 64 : this.neg().getNumBitsAbs();
      for (var U = this.high != 0 ? this.high : this.low, Y = 31; Y > 0 && !(U & 1 << Y); Y--)
        ;
      return this.high != 0 ? Y + 33 : Y + 1;
    }, I.isZero = function() {
      return this.high === 0 && this.low === 0;
    }, I.eqz = I.isZero, I.isNegative = function() {
      return !this.unsigned && this.high < 0;
    }, I.isPositive = function() {
      return this.unsigned || this.high >= 0;
    }, I.isOdd = function() {
      return (this.low & 1) === 1;
    }, I.isEven = function() {
      return (this.low & 1) === 0;
    }, I.equals = function(U) {
      return _(U) || (U = ae(U)), this.unsigned !== U.unsigned && this.high >>> 31 === 1 && U.high >>> 31 === 1 ? !1 : this.high === U.high && this.low === U.low;
    }, I.eq = I.equals, I.notEquals = function(U) {
      return !this.eq(
        /* validates */
        U
      );
    }, I.neq = I.notEquals, I.ne = I.notEquals, I.lessThan = function(U) {
      return this.comp(
        /* validates */
        U
      ) < 0;
    }, I.lt = I.lessThan, I.lessThanOrEqual = function(U) {
      return this.comp(
        /* validates */
        U
      ) <= 0;
    }, I.lte = I.lessThanOrEqual, I.le = I.lessThanOrEqual, I.greaterThan = function(U) {
      return this.comp(
        /* validates */
        U
      ) > 0;
    }, I.gt = I.greaterThan, I.greaterThanOrEqual = function(U) {
      return this.comp(
        /* validates */
        U
      ) >= 0;
    }, I.gte = I.greaterThanOrEqual, I.ge = I.greaterThanOrEqual, I.compare = function(U) {
      if (_(U) || (U = ae(U)), this.eq(U))
        return 0;
      var Y = this.isNegative(), L = U.isNegative();
      return Y && !L ? -1 : !Y && L ? 1 : this.unsigned ? U.high >>> 0 > this.high >>> 0 || U.high === this.high && U.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(U).isNegative() ? -1 : 1;
    }, I.comp = I.compare, I.negate = function() {
      return !this.unsigned && this.eq(E) ? E : this.not().add(be);
    }, I.neg = I.negate, I.add = function(U) {
      _(U) || (U = ae(U));
      var Y = this.high >>> 16, L = this.high & 65535, T = this.low >>> 16, B = this.low & 65535, te = U.high >>> 16, pe = U.high & 65535, Ie = U.low >>> 16, $e = U.low & 65535, ve = 0, he = 0, Oe = 0, Ae = 0;
      return Ae += B + $e, Oe += Ae >>> 16, Ae &= 65535, Oe += T + Ie, he += Oe >>> 16, Oe &= 65535, he += L + pe, ve += he >>> 16, he &= 65535, ve += Y + te, ve &= 65535, j(Oe << 16 | Ae, ve << 16 | he, this.unsigned);
    }, I.subtract = function(U) {
      return _(U) || (U = ae(U)), this.add(U.neg());
    }, I.sub = I.subtract, I.multiply = function(U) {
      if (this.isZero())
        return this;
      if (_(U) || (U = ae(U)), v) {
        var Y = v.mul(this.low, this.high, U.low, U.high);
        return j(Y, v.get_high(), this.unsigned);
      }
      if (U.isZero())
        return this.unsigned ? Le : Re;
      if (this.eq(E))
        return U.isOdd() ? E : Re;
      if (U.eq(E))
        return this.isOdd() ? E : Re;
      if (this.isNegative())
        return U.isNegative() ? this.neg().mul(U.neg()) : this.neg().mul(U).neg();
      if (U.isNegative())
        return this.mul(U.neg()).neg();
      if (this.lt(Te) && U.lt(Te))
        return z(this.toNumber() * U.toNumber(), this.unsigned);
      var L = this.high >>> 16, T = this.high & 65535, B = this.low >>> 16, te = this.low & 65535, pe = U.high >>> 16, Ie = U.high & 65535, $e = U.low >>> 16, ve = U.low & 65535, he = 0, Oe = 0, Ae = 0, Ue = 0;
      return Ue += te * ve, Ae += Ue >>> 16, Ue &= 65535, Ae += B * ve, Oe += Ae >>> 16, Ae &= 65535, Ae += te * $e, Oe += Ae >>> 16, Ae &= 65535, Oe += T * ve, he += Oe >>> 16, Oe &= 65535, Oe += B * $e, he += Oe >>> 16, Oe &= 65535, Oe += te * Ie, he += Oe >>> 16, Oe &= 65535, he += L * ve + T * $e + B * Ie + te * pe, he &= 65535, j(Ae << 16 | Ue, he << 16 | Oe, this.unsigned);
    }, I.mul = I.multiply, I.divide = function(U) {
      if (_(U) || (U = ae(U)), U.isZero())
        throw Error("division by zero");
      if (v) {
        if (!this.unsigned && this.high === -2147483648 && U.low === -1 && U.high === -1)
          return this;
        var Y = (this.unsigned ? v.div_u : v.div_s)(this.low, this.high, U.low, U.high);
        return j(Y, v.get_high(), this.unsigned);
      }
      if (this.isZero())
        return this.unsigned ? Le : Re;
      var L, T, B;
      if (this.unsigned) {
        if (U.unsigned || (U = U.toUnsigned()), U.gt(this))
          return Le;
        if (U.gt(this.shru(1)))
          return q;
        B = Le;
      } else {
        if (this.eq(E)) {
          if (U.eq(be) || U.eq(J))
            return E;
          if (U.eq(E))
            return be;
          var te = this.shr(1);
          return L = te.div(U).shl(1), L.eq(Re) ? U.isNegative() ? be : J : (T = this.sub(U.mul(L)), B = L.add(T.div(U)), B);
        } else if (U.eq(E))
          return this.unsigned ? Le : Re;
        if (this.isNegative())
          return U.isNegative() ? this.neg().div(U.neg()) : this.neg().div(U).neg();
        if (U.isNegative())
          return this.div(U.neg()).neg();
        B = Re;
      }
      for (T = this; T.gte(U); ) {
        L = Math.max(1, Math.floor(T.toNumber() / U.toNumber()));
        for (var pe = Math.ceil(Math.log(L) / Math.LN2), Ie = pe <= 48 ? 1 : ee(2, pe - 48), $e = z(L), ve = $e.mul(U); ve.isNegative() || ve.gt(T); )
          L -= Ie, $e = z(L, this.unsigned), ve = $e.mul(U);
        $e.isZero() && ($e = be), B = B.add($e), T = T.sub(ve);
      }
      return B;
    }, I.div = I.divide, I.modulo = function(U) {
      if (_(U) || (U = ae(U)), v) {
        var Y = (this.unsigned ? v.rem_u : v.rem_s)(this.low, this.high, U.low, U.high);
        return j(Y, v.get_high(), this.unsigned);
      }
      return this.sub(this.div(U).mul(U));
    }, I.mod = I.modulo, I.rem = I.modulo, I.not = function() {
      return j(~this.low, ~this.high, this.unsigned);
    }, I.countLeadingZeros = function() {
      return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
    }, I.clz = I.countLeadingZeros, I.countTrailingZeros = function() {
      return this.low ? k(this.low) : k(this.high) + 32;
    }, I.ctz = I.countTrailingZeros, I.and = function(U) {
      return _(U) || (U = ae(U)), j(this.low & U.low, this.high & U.high, this.unsigned);
    }, I.or = function(U) {
      return _(U) || (U = ae(U)), j(this.low | U.low, this.high | U.high, this.unsigned);
    }, I.xor = function(U) {
      return _(U) || (U = ae(U)), j(this.low ^ U.low, this.high ^ U.high, this.unsigned);
    }, I.shiftLeft = function(U) {
      return _(U) && (U = U.toInt()), (U &= 63) === 0 ? this : U < 32 ? j(this.low << U, this.high << U | this.low >>> 32 - U, this.unsigned) : j(0, this.low << U - 32, this.unsigned);
    }, I.shl = I.shiftLeft, I.shiftRight = function(U) {
      return _(U) && (U = U.toInt()), (U &= 63) === 0 ? this : U < 32 ? j(this.low >>> U | this.high << 32 - U, this.high >> U, this.unsigned) : j(this.high >> U - 32, this.high >= 0 ? 0 : -1, this.unsigned);
    }, I.shr = I.shiftRight, I.shiftRightUnsigned = function(U) {
      return _(U) && (U = U.toInt()), (U &= 63) === 0 ? this : U < 32 ? j(this.low >>> U | this.high << 32 - U, this.high >>> U, this.unsigned) : U === 32 ? j(this.high, 0, this.unsigned) : j(this.high >>> U - 32, 0, this.unsigned);
    }, I.shru = I.shiftRightUnsigned, I.shr_u = I.shiftRightUnsigned, I.rotateLeft = function(U) {
      var Y;
      return _(U) && (U = U.toInt()), (U &= 63) === 0 ? this : U === 32 ? j(this.high, this.low, this.unsigned) : U < 32 ? (Y = 32 - U, j(this.low << U | this.high >>> Y, this.high << U | this.low >>> Y, this.unsigned)) : (U -= 32, Y = 32 - U, j(this.high << U | this.low >>> Y, this.low << U | this.high >>> Y, this.unsigned));
    }, I.rotl = I.rotateLeft, I.rotateRight = function(U) {
      var Y;
      return _(U) && (U = U.toInt()), (U &= 63) === 0 ? this : U === 32 ? j(this.high, this.low, this.unsigned) : U < 32 ? (Y = 32 - U, j(this.high << Y | this.low >>> U, this.low << Y | this.high >>> U, this.unsigned)) : (U -= 32, Y = 32 - U, j(this.low << Y | this.high >>> U, this.high << Y | this.low >>> U, this.unsigned));
    }, I.rotr = I.rotateRight, I.toSigned = function() {
      return this.unsigned ? j(this.low, this.high, !1) : this;
    }, I.toUnsigned = function() {
      return this.unsigned ? this : j(this.low, this.high, !0);
    }, I.toBytes = function(U) {
      return U ? this.toBytesLE() : this.toBytesBE();
    }, I.toBytesLE = function() {
      var U = this.high, Y = this.low;
      return [Y & 255, Y >>> 8 & 255, Y >>> 16 & 255, Y >>> 24, U & 255, U >>> 8 & 255, U >>> 16 & 255, U >>> 24];
    }, I.toBytesBE = function() {
      var U = this.high, Y = this.low;
      return [U >>> 24, U >>> 16 & 255, U >>> 8 & 255, U & 255, Y >>> 24, Y >>> 16 & 255, Y >>> 8 & 255, Y & 255];
    }, p.fromBytes = function(U, Y, L) {
      return L ? p.fromBytesLE(U, Y) : p.fromBytesBE(U, Y);
    }, p.fromBytesLE = function(U, Y) {
      return new p(U[0] | U[1] << 8 | U[2] << 16 | U[3] << 24, U[4] | U[5] << 8 | U[6] << 16 | U[7] << 24, Y);
    }, p.fromBytesBE = function(U, Y) {
      return new p(U[4] << 24 | U[5] << 16 | U[6] << 8 | U[7], U[0] << 24 | U[1] << 16 | U[2] << 8 | U[3], Y);
    };
    var M = p;
    return l.default = M, "default" in l ? l.default : l;
  }({});
  a.exports = c;
})(umd);
var umdExports = umd.exports, indexMinimal = {}, minimal$1 = {}, aspromise = asPromise;
function asPromise(a, u) {
  for (var c = new Array(arguments.length - 1), l = 0, v = 2, p = !0; v < arguments.length; )
    c[l++] = arguments[v++];
  return new Promise(function(k, O) {
    c[l] = function(F) {
      if (p)
        if (p = !1, F)
          O(F);
        else {
          for (var z = new Array(arguments.length - 1), j = 0; j < z.length; )
            z[j++] = arguments[j];
          k.apply(null, z);
        }
    };
    try {
      a.apply(u || null, c);
    } catch (D) {
      p && (p = !1, O(D));
    }
  });
}
var base64$1 = {};
(function(a) {
  var u = a;
  u.length = function(k) {
    var O = k.length;
    if (!O)
      return 0;
    for (var D = 0; --O % 4 > 1 && k.charAt(O) === "="; )
      ++D;
    return Math.ceil(k.length * 3) / 4 - D;
  };
  for (var c = new Array(64), l = new Array(123), v = 0; v < 64; )
    l[c[v] = v < 26 ? v + 65 : v < 52 ? v + 71 : v < 62 ? v - 4 : v - 59 | 43] = v++;
  u.encode = function(k, O, D) {
    for (var F = null, z = [], j = 0, ee = 0, X; O < D; ) {
      var ae = k[O++];
      switch (ee) {
        case 0:
          z[j++] = c[ae >> 2], X = (ae & 3) << 4, ee = 1;
          break;
        case 1:
          z[j++] = c[X | ae >> 4], X = (ae & 15) << 2, ee = 2;
          break;
        case 2:
          z[j++] = c[X | ae >> 6], z[j++] = c[ae & 63], ee = 0;
          break;
      }
      j > 8191 && ((F || (F = [])).push(String.fromCharCode.apply(String, z)), j = 0);
    }
    return ee && (z[j++] = c[X], z[j++] = 61, ee === 1 && (z[j++] = 61)), F ? (j && F.push(String.fromCharCode.apply(String, z.slice(0, j))), F.join("")) : String.fromCharCode.apply(String, z.slice(0, j));
  };
  var p = "invalid encoding";
  u.decode = function(k, O, D) {
    for (var F = D, z = 0, j, ee = 0; ee < k.length; ) {
      var X = k.charCodeAt(ee++);
      if (X === 61 && z > 1)
        break;
      if ((X = l[X]) === void 0)
        throw Error(p);
      switch (z) {
        case 0:
          j = X, z = 1;
          break;
        case 1:
          O[D++] = j << 2 | (X & 48) >> 4, j = X, z = 2;
          break;
        case 2:
          O[D++] = (j & 15) << 4 | (X & 60) >> 2, j = X, z = 3;
          break;
        case 3:
          O[D++] = (j & 3) << 6 | X, z = 0;
          break;
      }
    }
    if (z === 1)
      throw Error(p);
    return D - F;
  }, u.test = function(k) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(k);
  };
})(base64$1);
var eventemitter = EventEmitter$2;
function EventEmitter$2() {
  this._listeners = {};
}
EventEmitter$2.prototype.on = function(u, c, l) {
  return (this._listeners[u] || (this._listeners[u] = [])).push({
    fn: c,
    ctx: l || this
  }), this;
};
EventEmitter$2.prototype.off = function(u, c) {
  if (u === void 0)
    this._listeners = {};
  else if (c === void 0)
    this._listeners[u] = [];
  else
    for (var l = this._listeners[u], v = 0; v < l.length; )
      l[v].fn === c ? l.splice(v, 1) : ++v;
  return this;
};
EventEmitter$2.prototype.emit = function(u) {
  var c = this._listeners[u];
  if (c) {
    for (var l = [], v = 1; v < arguments.length; )
      l.push(arguments[v++]);
    for (v = 0; v < c.length; )
      c[v].fn.apply(c[v++].ctx, l);
  }
  return this;
};
var float = factory(factory);
function factory(a) {
  return typeof Float32Array < "u" ? function() {
    var u = new Float32Array([-0]), c = new Uint8Array(u.buffer), l = c[3] === 128;
    function v(O, D, F) {
      u[0] = O, D[F] = c[0], D[F + 1] = c[1], D[F + 2] = c[2], D[F + 3] = c[3];
    }
    function p(O, D, F) {
      u[0] = O, D[F] = c[3], D[F + 1] = c[2], D[F + 2] = c[1], D[F + 3] = c[0];
    }
    a.writeFloatLE = l ? v : p, a.writeFloatBE = l ? p : v;
    function _(O, D) {
      return c[0] = O[D], c[1] = O[D + 1], c[2] = O[D + 2], c[3] = O[D + 3], u[0];
    }
    function k(O, D) {
      return c[3] = O[D], c[2] = O[D + 1], c[1] = O[D + 2], c[0] = O[D + 3], u[0];
    }
    a.readFloatLE = l ? _ : k, a.readFloatBE = l ? k : _;
  }() : function() {
    function u(l, v, p, _) {
      var k = v < 0 ? 1 : 0;
      if (k && (v = -v), v === 0)
        l(1 / v > 0 ? (
          /* positive */
          0
        ) : (
          /* negative 0 */
          2147483648
        ), p, _);
      else if (isNaN(v))
        l(2143289344, p, _);
      else if (v > 34028234663852886e22)
        l((k << 31 | 2139095040) >>> 0, p, _);
      else if (v < 11754943508222875e-54)
        l((k << 31 | Math.round(v / 1401298464324817e-60)) >>> 0, p, _);
      else {
        var O = Math.floor(Math.log(v) / Math.LN2), D = Math.round(v * Math.pow(2, -O) * 8388608) & 8388607;
        l((k << 31 | O + 127 << 23 | D) >>> 0, p, _);
      }
    }
    a.writeFloatLE = u.bind(null, writeUintLE), a.writeFloatBE = u.bind(null, writeUintBE);
    function c(l, v, p) {
      var _ = l(v, p), k = (_ >> 31) * 2 + 1, O = _ >>> 23 & 255, D = _ & 8388607;
      return O === 255 ? D ? NaN : k * (1 / 0) : O === 0 ? k * 1401298464324817e-60 * D : k * Math.pow(2, O - 150) * (D + 8388608);
    }
    a.readFloatLE = c.bind(null, readUintLE), a.readFloatBE = c.bind(null, readUintBE);
  }(), typeof Float64Array < "u" ? function() {
    var u = new Float64Array([-0]), c = new Uint8Array(u.buffer), l = c[7] === 128;
    function v(O, D, F) {
      u[0] = O, D[F] = c[0], D[F + 1] = c[1], D[F + 2] = c[2], D[F + 3] = c[3], D[F + 4] = c[4], D[F + 5] = c[5], D[F + 6] = c[6], D[F + 7] = c[7];
    }
    function p(O, D, F) {
      u[0] = O, D[F] = c[7], D[F + 1] = c[6], D[F + 2] = c[5], D[F + 3] = c[4], D[F + 4] = c[3], D[F + 5] = c[2], D[F + 6] = c[1], D[F + 7] = c[0];
    }
    a.writeDoubleLE = l ? v : p, a.writeDoubleBE = l ? p : v;
    function _(O, D) {
      return c[0] = O[D], c[1] = O[D + 1], c[2] = O[D + 2], c[3] = O[D + 3], c[4] = O[D + 4], c[5] = O[D + 5], c[6] = O[D + 6], c[7] = O[D + 7], u[0];
    }
    function k(O, D) {
      return c[7] = O[D], c[6] = O[D + 1], c[5] = O[D + 2], c[4] = O[D + 3], c[3] = O[D + 4], c[2] = O[D + 5], c[1] = O[D + 6], c[0] = O[D + 7], u[0];
    }
    a.readDoubleLE = l ? _ : k, a.readDoubleBE = l ? k : _;
  }() : function() {
    function u(l, v, p, _, k, O) {
      var D = _ < 0 ? 1 : 0;
      if (D && (_ = -_), _ === 0)
        l(0, k, O + v), l(1 / _ > 0 ? (
          /* positive */
          0
        ) : (
          /* negative 0 */
          2147483648
        ), k, O + p);
      else if (isNaN(_))
        l(0, k, O + v), l(2146959360, k, O + p);
      else if (_ > 17976931348623157e292)
        l(0, k, O + v), l((D << 31 | 2146435072) >>> 0, k, O + p);
      else {
        var F;
        if (_ < 22250738585072014e-324)
          F = _ / 5e-324, l(F >>> 0, k, O + v), l((D << 31 | F / 4294967296) >>> 0, k, O + p);
        else {
          var z = Math.floor(Math.log(_) / Math.LN2);
          z === 1024 && (z = 1023), F = _ * Math.pow(2, -z), l(F * 4503599627370496 >>> 0, k, O + v), l((D << 31 | z + 1023 << 20 | F * 1048576 & 1048575) >>> 0, k, O + p);
        }
      }
    }
    a.writeDoubleLE = u.bind(null, writeUintLE, 0, 4), a.writeDoubleBE = u.bind(null, writeUintBE, 4, 0);
    function c(l, v, p, _, k) {
      var O = l(_, k + v), D = l(_, k + p), F = (D >> 31) * 2 + 1, z = D >>> 20 & 2047, j = 4294967296 * (D & 1048575) + O;
      return z === 2047 ? j ? NaN : F * (1 / 0) : z === 0 ? F * 5e-324 * j : F * Math.pow(2, z - 1075) * (j + 4503599627370496);
    }
    a.readDoubleLE = c.bind(null, readUintLE, 0, 4), a.readDoubleBE = c.bind(null, readUintBE, 4, 0);
  }(), a;
}
function writeUintLE(a, u, c) {
  u[c] = a & 255, u[c + 1] = a >>> 8 & 255, u[c + 2] = a >>> 16 & 255, u[c + 3] = a >>> 24;
}
function writeUintBE(a, u, c) {
  u[c] = a >>> 24, u[c + 1] = a >>> 16 & 255, u[c + 2] = a >>> 8 & 255, u[c + 3] = a & 255;
}
function readUintLE(a, u) {
  return (a[u] | a[u + 1] << 8 | a[u + 2] << 16 | a[u + 3] << 24) >>> 0;
}
function readUintBE(a, u) {
  return (a[u] << 24 | a[u + 1] << 16 | a[u + 2] << 8 | a[u + 3]) >>> 0;
}
var inquire_1 = inquire;
function inquire(moduleName) {
  try {
    var mod = eval("quire".replace(/^/, "re"))(moduleName);
    if (mod && (mod.length || Object.keys(mod).length))
      return mod;
  } catch (a) {
  }
  return null;
}
var utf8$2 = {};
(function(a) {
  var u = a;
  u.length = function(l) {
    for (var v = 0, p = 0, _ = 0; _ < l.length; ++_)
      p = l.charCodeAt(_), p < 128 ? v += 1 : p < 2048 ? v += 2 : (p & 64512) === 55296 && (l.charCodeAt(_ + 1) & 64512) === 56320 ? (++_, v += 4) : v += 3;
    return v;
  }, u.read = function(l, v, p) {
    var _ = p - v;
    if (_ < 1)
      return "";
    for (var k = null, O = [], D = 0, F; v < p; )
      F = l[v++], F < 128 ? O[D++] = F : F > 191 && F < 224 ? O[D++] = (F & 31) << 6 | l[v++] & 63 : F > 239 && F < 365 ? (F = ((F & 7) << 18 | (l[v++] & 63) << 12 | (l[v++] & 63) << 6 | l[v++] & 63) - 65536, O[D++] = 55296 + (F >> 10), O[D++] = 56320 + (F & 1023)) : O[D++] = (F & 15) << 12 | (l[v++] & 63) << 6 | l[v++] & 63, D > 8191 && ((k || (k = [])).push(String.fromCharCode.apply(String, O)), D = 0);
    return k ? (D && k.push(String.fromCharCode.apply(String, O.slice(0, D))), k.join("")) : String.fromCharCode.apply(String, O.slice(0, D));
  }, u.write = function(l, v, p) {
    for (var _ = p, k, O, D = 0; D < l.length; ++D)
      k = l.charCodeAt(D), k < 128 ? v[p++] = k : k < 2048 ? (v[p++] = k >> 6 | 192, v[p++] = k & 63 | 128) : (k & 64512) === 55296 && ((O = l.charCodeAt(D + 1)) & 64512) === 56320 ? (k = 65536 + ((k & 1023) << 10) + (O & 1023), ++D, v[p++] = k >> 18 | 240, v[p++] = k >> 12 & 63 | 128, v[p++] = k >> 6 & 63 | 128, v[p++] = k & 63 | 128) : (v[p++] = k >> 12 | 224, v[p++] = k >> 6 & 63 | 128, v[p++] = k & 63 | 128);
    return p - _;
  };
})(utf8$2);
var pool_1 = pool;
function pool(a, u, c) {
  var l = c || 8192, v = l >>> 1, p = null, _ = l;
  return function(O) {
    if (O < 1 || O > v)
      return a(O);
    _ + O > l && (p = a(l), _ = 0);
    var D = u.call(p, _, _ += O);
    return _ & 7 && (_ = (_ | 7) + 1), D;
  };
}
var longbits, hasRequiredLongbits;
function requireLongbits() {
  if (hasRequiredLongbits)
    return longbits;
  hasRequiredLongbits = 1, longbits = u;
  var a = requireMinimal();
  function u(p, _) {
    this.lo = p >>> 0, this.hi = _ >>> 0;
  }
  var c = u.zero = new u(0, 0);
  c.toNumber = function() {
    return 0;
  }, c.zzEncode = c.zzDecode = function() {
    return this;
  }, c.length = function() {
    return 1;
  };
  var l = u.zeroHash = "\0\0\0\0\0\0\0\0";
  u.fromNumber = function(_) {
    if (_ === 0)
      return c;
    var k = _ < 0;
    k && (_ = -_);
    var O = _ >>> 0, D = (_ - O) / 4294967296 >>> 0;
    return k && (D = ~D >>> 0, O = ~O >>> 0, ++O > 4294967295 && (O = 0, ++D > 4294967295 && (D = 0))), new u(O, D);
  }, u.from = function(_) {
    if (typeof _ == "number")
      return u.fromNumber(_);
    if (a.isString(_))
      if (a.Long)
        _ = a.Long.fromString(_);
      else
        return u.fromNumber(parseInt(_, 10));
    return _.low || _.high ? new u(_.low >>> 0, _.high >>> 0) : c;
  }, u.prototype.toNumber = function(_) {
    if (!_ && this.hi >>> 31) {
      var k = ~this.lo + 1 >>> 0, O = ~this.hi >>> 0;
      return k || (O = O + 1 >>> 0), -(k + O * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
  }, u.prototype.toLong = function(_) {
    return a.Long ? new a.Long(this.lo | 0, this.hi | 0, !!_) : { low: this.lo | 0, high: this.hi | 0, unsigned: !!_ };
  };
  var v = String.prototype.charCodeAt;
  return u.fromHash = function(_) {
    return _ === l ? c : new u(
      (v.call(_, 0) | v.call(_, 1) << 8 | v.call(_, 2) << 16 | v.call(_, 3) << 24) >>> 0,
      (v.call(_, 4) | v.call(_, 5) << 8 | v.call(_, 6) << 16 | v.call(_, 7) << 24) >>> 0
    );
  }, u.prototype.toHash = function() {
    return String.fromCharCode(
      this.lo & 255,
      this.lo >>> 8 & 255,
      this.lo >>> 16 & 255,
      this.lo >>> 24,
      this.hi & 255,
      this.hi >>> 8 & 255,
      this.hi >>> 16 & 255,
      this.hi >>> 24
    );
  }, u.prototype.zzEncode = function() {
    var _ = this.hi >> 31;
    return this.hi = ((this.hi << 1 | this.lo >>> 31) ^ _) >>> 0, this.lo = (this.lo << 1 ^ _) >>> 0, this;
  }, u.prototype.zzDecode = function() {
    var _ = -(this.lo & 1);
    return this.lo = ((this.lo >>> 1 | this.hi << 31) ^ _) >>> 0, this.hi = (this.hi >>> 1 ^ _) >>> 0, this;
  }, u.prototype.length = function() {
    var _ = this.lo, k = (this.lo >>> 28 | this.hi << 4) >>> 0, O = this.hi >>> 24;
    return O === 0 ? k === 0 ? _ < 16384 ? _ < 128 ? 1 : 2 : _ < 2097152 ? 3 : 4 : k < 16384 ? k < 128 ? 5 : 6 : k < 2097152 ? 7 : 8 : O < 128 ? 9 : 10;
  }, longbits;
}
var hasRequiredMinimal;
function requireMinimal() {
  return hasRequiredMinimal || (hasRequiredMinimal = 1, function(a) {
    var u = a;
    u.asPromise = aspromise, u.base64 = base64$1, u.EventEmitter = eventemitter, u.float = float, u.inquire = inquire_1, u.utf8 = utf8$2, u.pool = pool_1, u.LongBits = requireLongbits(), u.isNode = !!(typeof commonjsGlobal$1 < "u" && commonjsGlobal$1 && commonjsGlobal$1.process && commonjsGlobal$1.process.versions && commonjsGlobal$1.process.versions.node), u.global = u.isNode && commonjsGlobal$1 || typeof window < "u" && window || typeof self < "u" && self || commonjsGlobal$1, u.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    ), u.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    ), u.isInteger = Number.isInteger || /* istanbul ignore next */
    function(p) {
      return typeof p == "number" && isFinite(p) && Math.floor(p) === p;
    }, u.isString = function(p) {
      return typeof p == "string" || p instanceof String;
    }, u.isObject = function(p) {
      return p && typeof p == "object";
    }, u.isset = /**
     * Checks if a property on a message is considered to be present.
     * @param {Object} obj Plain object or message instance
     * @param {string} prop Property name
     * @returns {boolean} `true` if considered to be present, otherwise `false`
     */
    u.isSet = function(p, _) {
      var k = p[_];
      return k != null && p.hasOwnProperty(_) ? typeof k != "object" || (Array.isArray(k) ? k.length : Object.keys(k).length) > 0 : !1;
    }, u.Buffer = function() {
      try {
        var v = u.inquire("buffer").Buffer;
        return v.prototype.utf8Write ? v : (
          /* istanbul ignore next */
          null
        );
      } catch {
        return null;
      }
    }(), u._Buffer_from = null, u._Buffer_allocUnsafe = null, u.newBuffer = function(p) {
      return typeof p == "number" ? u.Buffer ? u._Buffer_allocUnsafe(p) : new u.Array(p) : u.Buffer ? u._Buffer_from(p) : typeof Uint8Array > "u" ? p : new Uint8Array(p);
    }, u.Array = typeof Uint8Array < "u" ? Uint8Array : Array, u.Long = /* istanbul ignore next */
    u.global.dcodeIO && /* istanbul ignore next */
    u.global.dcodeIO.Long || /* istanbul ignore next */
    u.global.Long || u.inquire("long"), u.key2Re = /^true|false|0|1$/, u.key32Re = /^-?(?:0|[1-9][0-9]*)$/, u.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/, u.longToHash = function(p) {
      return p ? u.LongBits.from(p).toHash() : u.LongBits.zeroHash;
    }, u.longFromHash = function(p, _) {
      var k = u.LongBits.fromHash(p);
      return u.Long ? u.Long.fromBits(k.lo, k.hi, _) : k.toNumber(!!_);
    };
    function c(v, p, _) {
      for (var k = Object.keys(p), O = 0; O < k.length; ++O)
        (v[k[O]] === void 0 || !_) && (v[k[O]] = p[k[O]]);
      return v;
    }
    u.merge = c, u.lcFirst = function(p) {
      return p.charAt(0).toLowerCase() + p.substring(1);
    };
    function l(v) {
      function p(_, k) {
        if (!(this instanceof p))
          return new p(_, k);
        Object.defineProperty(this, "message", { get: function() {
          return _;
        } }), Error.captureStackTrace ? Error.captureStackTrace(this, p) : Object.defineProperty(this, "stack", { value: new Error().stack || "" }), k && c(this, k);
      }
      return (p.prototype = Object.create(Error.prototype)).constructor = p, Object.defineProperty(p.prototype, "name", { get: function() {
        return v;
      } }), p.prototype.toString = function() {
        return this.name + ": " + this.message;
      }, p;
    }
    u.newError = l, u.ProtocolError = l("ProtocolError"), u.oneOfGetter = function(p) {
      for (var _ = {}, k = 0; k < p.length; ++k)
        _[p[k]] = 1;
      return function() {
        for (var O = Object.keys(this), D = O.length - 1; D > -1; --D)
          if (_[O[D]] === 1 && this[O[D]] !== void 0 && this[O[D]] !== null)
            return O[D];
      };
    }, u.oneOfSetter = function(p) {
      return function(_) {
        for (var k = 0; k < p.length; ++k)
          p[k] !== _ && delete this[p[k]];
      };
    }, u.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: !0
    }, u._configure = function() {
      var v = u.Buffer;
      if (!v) {
        u._Buffer_from = u._Buffer_allocUnsafe = null;
        return;
      }
      u._Buffer_from = v.from !== Uint8Array.from && v.from || /* istanbul ignore next */
      function(_, k) {
        return new v(_, k);
      }, u._Buffer_allocUnsafe = v.allocUnsafe || /* istanbul ignore next */
      function(_) {
        return new v(_);
      };
    };
  }(minimal$1)), minimal$1;
}
var writer$2 = Writer$1, util$9 = requireMinimal(), BufferWriter$1, LongBits$1 = util$9.LongBits, base64 = util$9.base64, utf8$1 = util$9.utf8;
function Op(a, u, c) {
  this.fn = a, this.len = u, this.next = void 0, this.val = c;
}
function noop$7() {
}
function State(a) {
  this.head = a.head, this.tail = a.tail, this.len = a.len, this.next = a.states;
}
function Writer$1() {
  this.len = 0, this.head = new Op(noop$7, 0, 0), this.tail = this.head, this.states = null;
}
var create$3 = function a() {
  return util$9.Buffer ? function() {
    return (Writer$1.create = function() {
      return new BufferWriter$1();
    })();
  } : function() {
    return new Writer$1();
  };
};
Writer$1.create = create$3();
Writer$1.alloc = function a(u) {
  return new util$9.Array(u);
};
util$9.Array !== Array && (Writer$1.alloc = util$9.pool(Writer$1.alloc, util$9.Array.prototype.subarray));
Writer$1.prototype._push = function a(u, c, l) {
  return this.tail = this.tail.next = new Op(u, c, l), this.len += c, this;
};
function writeByte(a, u, c) {
  u[c] = a & 255;
}
function writeVarint32(a, u, c) {
  for (; a > 127; )
    u[c++] = a & 127 | 128, a >>>= 7;
  u[c] = a;
}
function VarintOp(a, u) {
  this.len = a, this.next = void 0, this.val = u;
}
VarintOp.prototype = Object.create(Op.prototype);
VarintOp.prototype.fn = writeVarint32;
Writer$1.prototype.uint32 = function a(u) {
  return this.len += (this.tail = this.tail.next = new VarintOp(
    (u = u >>> 0) < 128 ? 1 : u < 16384 ? 2 : u < 2097152 ? 3 : u < 268435456 ? 4 : 5,
    u
  )).len, this;
};
Writer$1.prototype.int32 = function a(u) {
  return u < 0 ? this._push(writeVarint64, 10, LongBits$1.fromNumber(u)) : this.uint32(u);
};
Writer$1.prototype.sint32 = function a(u) {
  return this.uint32((u << 1 ^ u >> 31) >>> 0);
};
function writeVarint64(a, u, c) {
  for (; a.hi; )
    u[c++] = a.lo & 127 | 128, a.lo = (a.lo >>> 7 | a.hi << 25) >>> 0, a.hi >>>= 7;
  for (; a.lo > 127; )
    u[c++] = a.lo & 127 | 128, a.lo = a.lo >>> 7;
  u[c++] = a.lo;
}
Writer$1.prototype.uint64 = function a(u) {
  var c = LongBits$1.from(u);
  return this._push(writeVarint64, c.length(), c);
};
Writer$1.prototype.int64 = Writer$1.prototype.uint64;
Writer$1.prototype.sint64 = function a(u) {
  var c = LongBits$1.from(u).zzEncode();
  return this._push(writeVarint64, c.length(), c);
};
Writer$1.prototype.bool = function a(u) {
  return this._push(writeByte, 1, u ? 1 : 0);
};
function writeFixed32(a, u, c) {
  u[c] = a & 255, u[c + 1] = a >>> 8 & 255, u[c + 2] = a >>> 16 & 255, u[c + 3] = a >>> 24;
}
Writer$1.prototype.fixed32 = function a(u) {
  return this._push(writeFixed32, 4, u >>> 0);
};
Writer$1.prototype.sfixed32 = Writer$1.prototype.fixed32;
Writer$1.prototype.fixed64 = function a(u) {
  var c = LongBits$1.from(u);
  return this._push(writeFixed32, 4, c.lo)._push(writeFixed32, 4, c.hi);
};
Writer$1.prototype.sfixed64 = Writer$1.prototype.fixed64;
Writer$1.prototype.float = function a(u) {
  return this._push(util$9.float.writeFloatLE, 4, u);
};
Writer$1.prototype.double = function a(u) {
  return this._push(util$9.float.writeDoubleLE, 8, u);
};
var writeBytes = util$9.Array.prototype.set ? function a(u, c, l) {
  c.set(u, l);
} : function a(u, c, l) {
  for (var v = 0; v < u.length; ++v)
    c[l + v] = u[v];
};
Writer$1.prototype.bytes = function a(u) {
  var c = u.length >>> 0;
  if (!c)
    return this._push(writeByte, 1, 0);
  if (util$9.isString(u)) {
    var l = Writer$1.alloc(c = base64.length(u));
    base64.decode(u, l, 0), u = l;
  }
  return this.uint32(c)._push(writeBytes, c, u);
};
Writer$1.prototype.string = function a(u) {
  var c = utf8$1.length(u);
  return c ? this.uint32(c)._push(utf8$1.write, c, u) : this._push(writeByte, 1, 0);
};
Writer$1.prototype.fork = function a() {
  return this.states = new State(this), this.head = this.tail = new Op(noop$7, 0, 0), this.len = 0, this;
};
Writer$1.prototype.reset = function a() {
  return this.states ? (this.head = this.states.head, this.tail = this.states.tail, this.len = this.states.len, this.states = this.states.next) : (this.head = this.tail = new Op(noop$7, 0, 0), this.len = 0), this;
};
Writer$1.prototype.ldelim = function a() {
  var u = this.head, c = this.tail, l = this.len;
  return this.reset().uint32(l), l && (this.tail.next = u.next, this.tail = c, this.len += l), this;
};
Writer$1.prototype.finish = function a() {
  for (var u = this.head.next, c = this.constructor.alloc(this.len), l = 0; u; )
    u.fn(u.val, c, l), l += u.len, u = u.next;
  return c;
};
Writer$1._configure = function(a) {
  BufferWriter$1 = a, Writer$1.create = create$3(), BufferWriter$1._configure();
};
var writer_buffer = BufferWriter, Writer = writer$2;
(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
var util$8 = requireMinimal();
function BufferWriter() {
  Writer.call(this);
}
BufferWriter._configure = function() {
  BufferWriter.alloc = util$8._Buffer_allocUnsafe, BufferWriter.writeBytesBuffer = util$8.Buffer && util$8.Buffer.prototype instanceof Uint8Array && util$8.Buffer.prototype.set.name === "set" ? function(u, c, l) {
    c.set(u, l);
  } : function(u, c, l) {
    if (u.copy)
      u.copy(c, l, 0, u.length);
    else
      for (var v = 0; v < u.length; )
        c[l++] = u[v++];
  };
};
BufferWriter.prototype.bytes = function a(u) {
  util$8.isString(u) && (u = util$8._Buffer_from(u, "base64"));
  var c = u.length >>> 0;
  return this.uint32(c), c && this._push(BufferWriter.writeBytesBuffer, c, u), this;
};
function writeStringBuffer(a, u, c) {
  a.length < 40 ? util$8.utf8.write(a, u, c) : u.utf8Write ? u.utf8Write(a, c) : u.write(a, c);
}
BufferWriter.prototype.string = function a(u) {
  var c = util$8.Buffer.byteLength(u);
  return this.uint32(c), c && this._push(writeStringBuffer, c, u), this;
};
BufferWriter._configure();
var reader = Reader$1, util$7 = requireMinimal(), BufferReader$1, LongBits = util$7.LongBits, utf8 = util$7.utf8;
function indexOutOfRange(a, u) {
  return RangeError("index out of range: " + a.pos + " + " + (u || 1) + " > " + a.len);
}
function Reader$1(a) {
  this.buf = a, this.pos = 0, this.len = a.length;
}
var create_array = typeof Uint8Array < "u" ? function a(u) {
  if (u instanceof Uint8Array || Array.isArray(u))
    return new Reader$1(u);
  throw Error("illegal buffer");
} : function a(u) {
  if (Array.isArray(u))
    return new Reader$1(u);
  throw Error("illegal buffer");
}, create$2 = function a() {
  return util$7.Buffer ? function(c) {
    return (Reader$1.create = function(v) {
      return util$7.Buffer.isBuffer(v) ? new BufferReader$1(v) : create_array(v);
    })(c);
  } : create_array;
};
Reader$1.create = create$2();
Reader$1.prototype._slice = util$7.Array.prototype.subarray || /* istanbul ignore next */
util$7.Array.prototype.slice;
Reader$1.prototype.uint32 = /* @__PURE__ */ function a() {
  var u = 4294967295;
  return function() {
    if (u = (this.buf[this.pos] & 127) >>> 0, this.buf[this.pos++] < 128 || (u = (u | (this.buf[this.pos] & 127) << 7) >>> 0, this.buf[this.pos++] < 128) || (u = (u | (this.buf[this.pos] & 127) << 14) >>> 0, this.buf[this.pos++] < 128) || (u = (u | (this.buf[this.pos] & 127) << 21) >>> 0, this.buf[this.pos++] < 128) || (u = (u | (this.buf[this.pos] & 15) << 28) >>> 0, this.buf[this.pos++] < 128))
      return u;
    if ((this.pos += 5) > this.len)
      throw this.pos = this.len, indexOutOfRange(this, 10);
    return u;
  };
}();
Reader$1.prototype.int32 = function a() {
  return this.uint32() | 0;
};
Reader$1.prototype.sint32 = function a() {
  var u = this.uint32();
  return u >>> 1 ^ -(u & 1) | 0;
};
function readLongVarint() {
  var a = new LongBits(0, 0), u = 0;
  if (this.len - this.pos > 4) {
    for (; u < 4; ++u)
      if (a.lo = (a.lo | (this.buf[this.pos] & 127) << u * 7) >>> 0, this.buf[this.pos++] < 128)
        return a;
    if (a.lo = (a.lo | (this.buf[this.pos] & 127) << 28) >>> 0, a.hi = (a.hi | (this.buf[this.pos] & 127) >> 4) >>> 0, this.buf[this.pos++] < 128)
      return a;
    u = 0;
  } else {
    for (; u < 3; ++u) {
      if (this.pos >= this.len)
        throw indexOutOfRange(this);
      if (a.lo = (a.lo | (this.buf[this.pos] & 127) << u * 7) >>> 0, this.buf[this.pos++] < 128)
        return a;
    }
    return a.lo = (a.lo | (this.buf[this.pos++] & 127) << u * 7) >>> 0, a;
  }
  if (this.len - this.pos > 4) {
    for (; u < 5; ++u)
      if (a.hi = (a.hi | (this.buf[this.pos] & 127) << u * 7 + 3) >>> 0, this.buf[this.pos++] < 128)
        return a;
  } else
    for (; u < 5; ++u) {
      if (this.pos >= this.len)
        throw indexOutOfRange(this);
      if (a.hi = (a.hi | (this.buf[this.pos] & 127) << u * 7 + 3) >>> 0, this.buf[this.pos++] < 128)
        return a;
    }
  throw Error("invalid varint encoding");
}
Reader$1.prototype.bool = function a() {
  return this.uint32() !== 0;
};
function readFixed32_end(a, u) {
  return (a[u - 4] | a[u - 3] << 8 | a[u - 2] << 16 | a[u - 1] << 24) >>> 0;
}
Reader$1.prototype.fixed32 = function a() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange(this, 4);
  return readFixed32_end(this.buf, this.pos += 4);
};
Reader$1.prototype.sfixed32 = function a() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange(this, 4);
  return readFixed32_end(this.buf, this.pos += 4) | 0;
};
function readFixed64() {
  if (this.pos + 8 > this.len)
    throw indexOutOfRange(this, 8);
  return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}
Reader$1.prototype.float = function a() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange(this, 4);
  var u = util$7.float.readFloatLE(this.buf, this.pos);
  return this.pos += 4, u;
};
Reader$1.prototype.double = function a() {
  if (this.pos + 8 > this.len)
    throw indexOutOfRange(this, 4);
  var u = util$7.float.readDoubleLE(this.buf, this.pos);
  return this.pos += 8, u;
};
Reader$1.prototype.bytes = function a() {
  var u = this.uint32(), c = this.pos, l = this.pos + u;
  if (l > this.len)
    throw indexOutOfRange(this, u);
  return this.pos += u, Array.isArray(this.buf) ? this.buf.slice(c, l) : c === l ? new this.buf.constructor(0) : this._slice.call(this.buf, c, l);
};
Reader$1.prototype.string = function a() {
  var u = this.bytes();
  return utf8.read(u, 0, u.length);
};
Reader$1.prototype.skip = function a(u) {
  if (typeof u == "number") {
    if (this.pos + u > this.len)
      throw indexOutOfRange(this, u);
    this.pos += u;
  } else
    do
      if (this.pos >= this.len)
        throw indexOutOfRange(this);
    while (this.buf[this.pos++] & 128);
  return this;
};
Reader$1.prototype.skipType = function(a) {
  switch (a) {
    case 0:
      this.skip();
      break;
    case 1:
      this.skip(8);
      break;
    case 2:
      this.skip(this.uint32());
      break;
    case 3:
      for (; (a = this.uint32() & 7) !== 4; )
        this.skipType(a);
      break;
    case 5:
      this.skip(4);
      break;
    default:
      throw Error("invalid wire type " + a + " at offset " + this.pos);
  }
  return this;
};
Reader$1._configure = function(a) {
  BufferReader$1 = a, Reader$1.create = create$2(), BufferReader$1._configure();
  var u = util$7.Long ? "toLong" : (
    /* istanbul ignore next */
    "toNumber"
  );
  util$7.merge(Reader$1.prototype, {
    int64: function() {
      return readLongVarint.call(this)[u](!1);
    },
    uint64: function() {
      return readLongVarint.call(this)[u](!0);
    },
    sint64: function() {
      return readLongVarint.call(this).zzDecode()[u](!1);
    },
    fixed64: function() {
      return readFixed64.call(this)[u](!0);
    },
    sfixed64: function() {
      return readFixed64.call(this)[u](!1);
    }
  });
};
var reader_buffer = BufferReader, Reader = reader;
(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
var util$6 = requireMinimal();
function BufferReader(a) {
  Reader.call(this, a);
}
BufferReader._configure = function() {
  util$6.Buffer && (BufferReader.prototype._slice = util$6.Buffer.prototype.slice);
};
BufferReader.prototype.string = function a() {
  var u = this.uint32();
  return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + u, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + u, this.len));
};
BufferReader._configure();
var rpc = {}, service = Service, util$5 = requireMinimal();
(Service.prototype = Object.create(util$5.EventEmitter.prototype)).constructor = Service;
function Service(a, u, c) {
  if (typeof a != "function")
    throw TypeError("rpcImpl must be a function");
  util$5.EventEmitter.call(this), this.rpcImpl = a, this.requestDelimited = !!u, this.responseDelimited = !!c;
}
Service.prototype.rpcCall = function a(u, c, l, v, p) {
  if (!v)
    throw TypeError("request must be specified");
  var _ = this;
  if (!p)
    return util$5.asPromise(a, _, u, c, l, v);
  if (!_.rpcImpl) {
    setTimeout(function() {
      p(Error("already ended"));
    }, 0);
    return;
  }
  try {
    return _.rpcImpl(
      u,
      c[_.requestDelimited ? "encodeDelimited" : "encode"](v).finish(),
      function(O, D) {
        if (O)
          return _.emit("error", O, u), p(O);
        if (D === null) {
          _.end(
            /* endedByRPC */
            !0
          );
          return;
        }
        if (!(D instanceof l))
          try {
            D = l[_.responseDelimited ? "decodeDelimited" : "decode"](D);
          } catch (F) {
            return _.emit("error", F, u), p(F);
          }
        return _.emit("data", D, u), p(null, D);
      }
    );
  } catch (k) {
    _.emit("error", k, u), setTimeout(function() {
      p(k);
    }, 0);
    return;
  }
};
Service.prototype.end = function a(u) {
  return this.rpcImpl && (u || this.rpcImpl(null, null, null), this.rpcImpl = null, this.emit("end").off()), this;
};
(function(a) {
  var u = a;
  u.Service = service;
})(rpc);
var roots = {};
(function(a) {
  var u = a;
  u.build = "minimal", u.Writer = writer$2, u.BufferWriter = writer_buffer, u.Reader = reader, u.BufferReader = reader_buffer, u.util = requireMinimal(), u.rpc = rpc, u.roots = roots, u.configure = c;
  function c() {
    u.util._configure(), u.Writer._configure(u.BufferWriter), u.Reader._configure(u.BufferReader);
  }
  c();
})(indexMinimal);
var minimal = indexMinimal, struct$2 = {};
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(Z, de, fe, Te) {
    Te === void 0 && (Te = fe), Object.defineProperty(Z, Te, { enumerable: !0, get: function() {
      return de[fe];
    } });
  } : function(Z, de, fe, Te) {
    Te === void 0 && (Te = fe), Z[Te] = de[fe];
  }), c = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(Z, de) {
    Object.defineProperty(Z, "default", { enumerable: !0, value: de });
  } : function(Z, de) {
    Z.default = de;
  }), l = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(Z) {
    if (Z && Z.__esModule)
      return Z;
    var de = {};
    if (Z != null)
      for (var fe in Z)
        fe !== "default" && Object.hasOwnProperty.call(Z, fe) && u(de, Z, fe);
    return c(de, Z), de;
  }, v = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(Z) {
    return Z && Z.__esModule ? Z : { default: Z };
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.ListValue = a.Value = a.Struct_FieldsEntry = a.Struct = a.nullValueToNumber = a.nullValueToJSON = a.nullValueFromJSON = a.NullValue = a.protobufPackage = void 0;
  const p = v(umdExports), _ = l(minimal);
  a.protobufPackage = "google.protobuf";
  var k;
  (function(Z) {
    Z.NULL_VALUE = "NULL_VALUE";
  })(k = a.NullValue || (a.NullValue = {}));
  function O(Z) {
    switch (Z) {
      case 0:
      case "NULL_VALUE":
        return k.NULL_VALUE;
      default:
        throw new ae.Error("Unrecognized enum value " + Z + " for enum NullValue");
    }
  }
  a.nullValueFromJSON = O;
  function D(Z) {
    switch (Z) {
      case k.NULL_VALUE:
        return "NULL_VALUE";
      default:
        return "UNKNOWN";
    }
  }
  a.nullValueToJSON = D;
  function F(Z) {
    switch (Z) {
      case k.NULL_VALUE:
        return 0;
      default:
        return 0;
    }
  }
  a.nullValueToNumber = F;
  function z() {
    return { fields: {} };
  }
  a.Struct = {
    encode(Z, de = _.Writer.create()) {
      return Object.entries(Z.fields).forEach(([fe, Te]) => {
        Te !== void 0 && a.Struct_FieldsEntry.encode({ key: fe, value: Te }, de.uint32(10).fork()).ldelim();
      }), de;
    },
    decode(Z, de) {
      const fe = Z instanceof _.Reader ? Z : new _.Reader(Z);
      let Te = de === void 0 ? fe.len : fe.pos + de;
      const Re = z();
      for (; fe.pos < Te; ) {
        const Le = fe.uint32();
        switch (Le >>> 3) {
          case 1:
            const be = a.Struct_FieldsEntry.decode(fe, fe.uint32());
            be.value !== void 0 && (Re.fields[be.key] = be.value);
            break;
          default:
            fe.skipType(Le & 7);
            break;
        }
      }
      return Re;
    },
    fromJSON(Z) {
      return {
        fields: Q(Z.fields) ? Object.entries(Z.fields).reduce((de, [fe, Te]) => (de[fe] = Te, de), {}) : {}
      };
    },
    toJSON(Z) {
      const de = {};
      return de.fields = {}, Z.fields && Object.entries(Z.fields).forEach(([fe, Te]) => {
        de.fields[fe] = Te;
      }), de;
    },
    fromPartial(Z) {
      var de;
      const fe = z();
      return fe.fields = Object.entries((de = Z.fields) !== null && de !== void 0 ? de : {}).reduce((Te, [Re, Le]) => (Le !== void 0 && (Te[Re] = Le), Te), {}), fe;
    },
    wrap(Z) {
      const de = z();
      return Z !== void 0 && Object.keys(Z).forEach((fe) => {
        de.fields[fe] = Z[fe];
      }), de;
    },
    unwrap(Z) {
      const de = {};
      return Object.keys(Z.fields).forEach((fe) => {
        de[fe] = Z.fields[fe];
      }), de;
    }
  };
  function j() {
    return { key: "", value: void 0 };
  }
  a.Struct_FieldsEntry = {
    encode(Z, de = _.Writer.create()) {
      return Z.key !== "" && de.uint32(10).string(Z.key), Z.value !== void 0 && a.Value.encode(a.Value.wrap(Z.value), de.uint32(18).fork()).ldelim(), de;
    },
    decode(Z, de) {
      const fe = Z instanceof _.Reader ? Z : new _.Reader(Z);
      let Te = de === void 0 ? fe.len : fe.pos + de;
      const Re = j();
      for (; fe.pos < Te; ) {
        const Le = fe.uint32();
        switch (Le >>> 3) {
          case 1:
            Re.key = fe.string();
            break;
          case 2:
            Re.value = a.Value.unwrap(a.Value.decode(fe, fe.uint32()));
            break;
          default:
            fe.skipType(Le & 7);
            break;
        }
      }
      return Re;
    },
    fromJSON(Z) {
      return {
        key: ne(Z.key) ? String(Z.key) : "",
        value: ne(Z == null ? void 0 : Z.value) ? Z.value : void 0
      };
    },
    toJSON(Z) {
      const de = {};
      return Z.key !== void 0 && (de.key = Z.key), Z.value !== void 0 && (de.value = Z.value), de;
    },
    fromPartial(Z) {
      var de, fe;
      const Te = j();
      return Te.key = (de = Z.key) !== null && de !== void 0 ? de : "", Te.value = (fe = Z.value) !== null && fe !== void 0 ? fe : void 0, Te;
    }
  };
  function ee() {
    return {
      nullValue: void 0,
      numberValue: void 0,
      stringValue: void 0,
      boolValue: void 0,
      structValue: void 0,
      listValue: void 0
    };
  }
  a.Value = {
    encode(Z, de = _.Writer.create()) {
      return Z.nullValue !== void 0 && de.uint32(8).int32(F(Z.nullValue)), Z.numberValue !== void 0 && de.uint32(17).double(Z.numberValue), Z.stringValue !== void 0 && de.uint32(26).string(Z.stringValue), Z.boolValue !== void 0 && de.uint32(32).bool(Z.boolValue), Z.structValue !== void 0 && a.Struct.encode(a.Struct.wrap(Z.structValue), de.uint32(42).fork()).ldelim(), Z.listValue !== void 0 && a.ListValue.encode(a.ListValue.wrap(Z.listValue), de.uint32(50).fork()).ldelim(), de;
    },
    decode(Z, de) {
      const fe = Z instanceof _.Reader ? Z : new _.Reader(Z);
      let Te = de === void 0 ? fe.len : fe.pos + de;
      const Re = ee();
      for (; fe.pos < Te; ) {
        const Le = fe.uint32();
        switch (Le >>> 3) {
          case 1:
            Re.nullValue = O(fe.int32());
            break;
          case 2:
            Re.numberValue = fe.double();
            break;
          case 3:
            Re.stringValue = fe.string();
            break;
          case 4:
            Re.boolValue = fe.bool();
            break;
          case 5:
            Re.structValue = a.Struct.unwrap(a.Struct.decode(fe, fe.uint32()));
            break;
          case 6:
            Re.listValue = a.ListValue.unwrap(a.ListValue.decode(fe, fe.uint32()));
            break;
          default:
            fe.skipType(Le & 7);
            break;
        }
      }
      return Re;
    },
    fromJSON(Z) {
      return {
        nullValue: ne(Z.nullValue) ? O(Z.nullValue) : void 0,
        numberValue: ne(Z.numberValue) ? Number(Z.numberValue) : void 0,
        stringValue: ne(Z.stringValue) ? String(Z.stringValue) : void 0,
        boolValue: ne(Z.boolValue) ? !!Z.boolValue : void 0,
        structValue: Q(Z.structValue) ? Z.structValue : void 0,
        listValue: Array.isArray(Z.listValue) ? [...Z.listValue] : void 0
      };
    },
    toJSON(Z) {
      const de = {};
      return Z.nullValue !== void 0 && (de.nullValue = Z.nullValue !== void 0 ? D(Z.nullValue) : void 0), Z.numberValue !== void 0 && (de.numberValue = Z.numberValue), Z.stringValue !== void 0 && (de.stringValue = Z.stringValue), Z.boolValue !== void 0 && (de.boolValue = Z.boolValue), Z.structValue !== void 0 && (de.structValue = Z.structValue), Z.listValue !== void 0 && (de.listValue = Z.listValue), de;
    },
    fromPartial(Z) {
      var de, fe, Te, Re, Le, be;
      const q = ee();
      return q.nullValue = (de = Z.nullValue) !== null && de !== void 0 ? de : void 0, q.numberValue = (fe = Z.numberValue) !== null && fe !== void 0 ? fe : void 0, q.stringValue = (Te = Z.stringValue) !== null && Te !== void 0 ? Te : void 0, q.boolValue = (Re = Z.boolValue) !== null && Re !== void 0 ? Re : void 0, q.structValue = (Le = Z.structValue) !== null && Le !== void 0 ? Le : void 0, q.listValue = (be = Z.listValue) !== null && be !== void 0 ? be : void 0, q;
    },
    wrap(Z) {
      const de = ee();
      if (Z === null)
        de.nullValue = k.NULL_VALUE;
      else if (typeof Z == "boolean")
        de.boolValue = Z;
      else if (typeof Z == "number")
        de.numberValue = Z;
      else if (typeof Z == "string")
        de.stringValue = Z;
      else if (Array.isArray(Z))
        de.listValue = Z;
      else if (typeof Z == "object")
        de.structValue = Z;
      else if (typeof Z < "u")
        throw new Error("Unsupported any value type: " + typeof Z);
      return de;
    },
    unwrap(Z) {
      if ((Z == null ? void 0 : Z.stringValue) !== void 0)
        return Z.stringValue;
      if ((Z == null ? void 0 : Z.numberValue) !== void 0)
        return Z.numberValue;
      if ((Z == null ? void 0 : Z.boolValue) !== void 0)
        return Z.boolValue;
      if ((Z == null ? void 0 : Z.structValue) !== void 0)
        return Z.structValue;
      if ((Z == null ? void 0 : Z.listValue) !== void 0)
        return Z.listValue;
      if ((Z == null ? void 0 : Z.nullValue) !== void 0)
        return null;
    }
  };
  function X() {
    return { values: [] };
  }
  a.ListValue = {
    encode(Z, de = _.Writer.create()) {
      for (const fe of Z.values)
        a.Value.encode(a.Value.wrap(fe), de.uint32(10).fork()).ldelim();
      return de;
    },
    decode(Z, de) {
      const fe = Z instanceof _.Reader ? Z : new _.Reader(Z);
      let Te = de === void 0 ? fe.len : fe.pos + de;
      const Re = X();
      for (; fe.pos < Te; ) {
        const Le = fe.uint32();
        switch (Le >>> 3) {
          case 1:
            Re.values.push(a.Value.unwrap(a.Value.decode(fe, fe.uint32())));
            break;
          default:
            fe.skipType(Le & 7);
            break;
        }
      }
      return Re;
    },
    fromJSON(Z) {
      return {
        values: Array.isArray(Z == null ? void 0 : Z.values) ? [...Z.values] : []
      };
    },
    toJSON(Z) {
      const de = {};
      return Z.values ? de.values = Z.values.map((fe) => fe) : de.values = [], de;
    },
    fromPartial(Z) {
      var de;
      const fe = X();
      return fe.values = ((de = Z.values) === null || de === void 0 ? void 0 : de.map((Te) => Te)) || [], fe;
    },
    wrap(Z) {
      const de = X();
      return de.values = Z ?? [], de;
    },
    unwrap(Z) {
      return Z.values;
    }
  };
  var ae = (() => {
    if (typeof ae < "u")
      return ae;
    if (typeof self < "u")
      return self;
    if (typeof window < "u")
      return window;
    if (typeof commonjsGlobal$1 < "u")
      return commonjsGlobal$1;
    throw "Unable to locate global object";
  })();
  _.util.Long !== p.default && (_.util.Long = p.default, _.configure());
  function Q(Z) {
    return typeof Z == "object" && Z !== null;
  }
  function ne(Z) {
    return Z != null;
  }
})(struct$2);
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(x, se, ge, xe) {
    xe === void 0 && (xe = ge), Object.defineProperty(x, xe, { enumerable: !0, get: function() {
      return se[ge];
    } });
  } : function(x, se, ge, xe) {
    xe === void 0 && (xe = ge), x[xe] = se[ge];
  }), c = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(x, se) {
    Object.defineProperty(x, "default", { enumerable: !0, value: se });
  } : function(x, se) {
    x.default = se;
  }), l = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(x) {
    if (x && x.__esModule)
      return x;
    var se = {};
    if (x != null)
      for (var ge in x)
        ge !== "default" && Object.hasOwnProperty.call(x, ge) && u(se, x, ge);
    return c(se, x), se;
  }, v = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(x) {
    return x && x.__esModule ? x : { default: x };
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.LayoutServiceDefinition = a.LayoutServiceClientImpl = a.LayerServiceDefinition = a.LayerServiceClientImpl = a.Event = a.LayerEvent = a.LayoutEvent = a.BatchLayerRequest_BatchItem = a.BatchLayerRequest = a.BatchDeleteLayerRequest = a.DeleteLayerPayload = a.UpdateLayerRequest = a.GetLayerRequest = a.CreateLayerRequest = a.ListLayersResponse = a.ListLayersRequest = a.PartialLayerWithID = a.PartialLayer = a.LayerAnimation = a.DeleteLayoutResponse = a.DeleteLayoutRequest = a.DeleteLayoutPayload = a.UpdateLayoutRequest = a.GetLayoutRequest = a.CreateLayoutRequest = a.ListLayoutsResponse = a.ListLayoutsRequest = a.PartialLayout = a.BatchLayerResponse_BatchLayerItem = a.BatchLayerResponse = a.DeleteLayerResponse = a.DeleteLayerRequest = a.Layer = a.Layout = a.Transition_TransitionStinger = a.Transition_TransitionStingerCut = a.Transition_TransitionSwipe = a.Transition_TransitionCrossfade = a.Transition_TransitionFadeToColor = a.Transition_TransitionCut = a.Transition_TransitionMediaType = a.Transition = a.transition_TransitionSwipeTypeToNumber = a.transition_TransitionSwipeTypeToJSON = a.transition_TransitionSwipeTypeFromJSON = a.Transition_TransitionSwipeType = a.transition_TransitionDirectionToNumber = a.transition_TransitionDirectionToJSON = a.transition_TransitionDirectionFromJSON = a.Transition_TransitionDirection = a.eventTypeToNumber = a.eventTypeToJSON = a.eventTypeFromJSON = a.EventType = a.eventSubTypeToNumber = a.eventSubTypeToJSON = a.eventSubTypeFromJSON = a.EventSubType = a.requestAnimationModeToNumber = a.requestAnimationModeToJSON = a.requestAnimationModeFromJSON = a.RequestAnimationMode = a.layoutTypeToNumber = a.layoutTypeToJSON = a.layoutTypeFromJSON = a.LayoutType = a.protobufPackage = void 0;
  const p = v(umdExports), _ = l(minimal), k = struct$2;
  a.protobufPackage = "apis.layout.v2";
  var O;
  (function(x) {
    x.LAYOUT_TYPE_UNSPECIFIED = "LAYOUT_TYPE_UNSPECIFIED", x.LAYOUT_TYPE_SCENELESS = "LAYOUT_TYPE_SCENELESS", x.LAYOUT_TYPE_SCENE = "LAYOUT_TYPE_SCENE";
  })(O = a.LayoutType || (a.LayoutType = {}));
  function D(x) {
    switch (x) {
      case 0:
      case "LAYOUT_TYPE_UNSPECIFIED":
        return O.LAYOUT_TYPE_UNSPECIFIED;
      case 1:
      case "LAYOUT_TYPE_SCENELESS":
        return O.LAYOUT_TYPE_SCENELESS;
      case 2:
      case "LAYOUT_TYPE_SCENE":
        return O.LAYOUT_TYPE_SCENE;
      default:
        throw new Je.Error("Unrecognized enum value " + x + " for enum LayoutType");
    }
  }
  a.layoutTypeFromJSON = D;
  function F(x) {
    switch (x) {
      case O.LAYOUT_TYPE_UNSPECIFIED:
        return "LAYOUT_TYPE_UNSPECIFIED";
      case O.LAYOUT_TYPE_SCENELESS:
        return "LAYOUT_TYPE_SCENELESS";
      case O.LAYOUT_TYPE_SCENE:
        return "LAYOUT_TYPE_SCENE";
      default:
        return "UNKNOWN";
    }
  }
  a.layoutTypeToJSON = F;
  function z(x) {
    switch (x) {
      case O.LAYOUT_TYPE_UNSPECIFIED:
        return 0;
      case O.LAYOUT_TYPE_SCENELESS:
        return 1;
      case O.LAYOUT_TYPE_SCENE:
        return 2;
      default:
        return 0;
    }
  }
  a.layoutTypeToNumber = z;
  var j;
  (function(x) {
    x.REQUEST_ANIMATION_MODE_UNSPECIFIED = "REQUEST_ANIMATION_MODE_UNSPECIFIED", x.REQUEST_ANIMATION_MODE_PARALLEL = "REQUEST_ANIMATION_MODE_PARALLEL", x.REQUEST_ANIMATION_MODE_SERIES = "REQUEST_ANIMATION_MODE_SERIES";
  })(j = a.RequestAnimationMode || (a.RequestAnimationMode = {}));
  function ee(x) {
    switch (x) {
      case 0:
      case "REQUEST_ANIMATION_MODE_UNSPECIFIED":
        return j.REQUEST_ANIMATION_MODE_UNSPECIFIED;
      case 1:
      case "REQUEST_ANIMATION_MODE_PARALLEL":
        return j.REQUEST_ANIMATION_MODE_PARALLEL;
      case 2:
      case "REQUEST_ANIMATION_MODE_SERIES":
        return j.REQUEST_ANIMATION_MODE_SERIES;
      default:
        throw new Je.Error("Unrecognized enum value " + x + " for enum RequestAnimationMode");
    }
  }
  a.requestAnimationModeFromJSON = ee;
  function X(x) {
    switch (x) {
      case j.REQUEST_ANIMATION_MODE_UNSPECIFIED:
        return "REQUEST_ANIMATION_MODE_UNSPECIFIED";
      case j.REQUEST_ANIMATION_MODE_PARALLEL:
        return "REQUEST_ANIMATION_MODE_PARALLEL";
      case j.REQUEST_ANIMATION_MODE_SERIES:
        return "REQUEST_ANIMATION_MODE_SERIES";
      default:
        return "UNKNOWN";
    }
  }
  a.requestAnimationModeToJSON = X;
  function ae(x) {
    switch (x) {
      case j.REQUEST_ANIMATION_MODE_UNSPECIFIED:
        return 0;
      case j.REQUEST_ANIMATION_MODE_PARALLEL:
        return 1;
      case j.REQUEST_ANIMATION_MODE_SERIES:
        return 2;
      default:
        return 0;
    }
  }
  a.requestAnimationModeToNumber = ae;
  var Q;
  (function(x) {
    x.EVENT_SUB_TYPE_UNSPECIFIED = "EVENT_SUB_TYPE_UNSPECIFIED", x.EVENT_SUB_TYPE_CREATE = "EVENT_SUB_TYPE_CREATE", x.EVENT_SUB_TYPE_UPDATE = "EVENT_SUB_TYPE_UPDATE", x.EVENT_SUB_TYPE_DELETE = "EVENT_SUB_TYPE_DELETE", x.EVENT_SUB_TYPE_BATCH = "EVENT_SUB_TYPE_BATCH";
  })(Q = a.EventSubType || (a.EventSubType = {}));
  function ne(x) {
    switch (x) {
      case 0:
      case "EVENT_SUB_TYPE_UNSPECIFIED":
        return Q.EVENT_SUB_TYPE_UNSPECIFIED;
      case 1:
      case "EVENT_SUB_TYPE_CREATE":
        return Q.EVENT_SUB_TYPE_CREATE;
      case 2:
      case "EVENT_SUB_TYPE_UPDATE":
        return Q.EVENT_SUB_TYPE_UPDATE;
      case 3:
      case "EVENT_SUB_TYPE_DELETE":
        return Q.EVENT_SUB_TYPE_DELETE;
      case 4:
      case "EVENT_SUB_TYPE_BATCH":
        return Q.EVENT_SUB_TYPE_BATCH;
      default:
        throw new Je.Error("Unrecognized enum value " + x + " for enum EventSubType");
    }
  }
  a.eventSubTypeFromJSON = ne;
  function Z(x) {
    switch (x) {
      case Q.EVENT_SUB_TYPE_UNSPECIFIED:
        return "EVENT_SUB_TYPE_UNSPECIFIED";
      case Q.EVENT_SUB_TYPE_CREATE:
        return "EVENT_SUB_TYPE_CREATE";
      case Q.EVENT_SUB_TYPE_UPDATE:
        return "EVENT_SUB_TYPE_UPDATE";
      case Q.EVENT_SUB_TYPE_DELETE:
        return "EVENT_SUB_TYPE_DELETE";
      case Q.EVENT_SUB_TYPE_BATCH:
        return "EVENT_SUB_TYPE_BATCH";
      default:
        return "UNKNOWN";
    }
  }
  a.eventSubTypeToJSON = Z;
  function de(x) {
    switch (x) {
      case Q.EVENT_SUB_TYPE_UNSPECIFIED:
        return 0;
      case Q.EVENT_SUB_TYPE_CREATE:
        return 1;
      case Q.EVENT_SUB_TYPE_UPDATE:
        return 2;
      case Q.EVENT_SUB_TYPE_DELETE:
        return 3;
      case Q.EVENT_SUB_TYPE_BATCH:
        return 4;
      default:
        return 0;
    }
  }
  a.eventSubTypeToNumber = de;
  var fe;
  (function(x) {
    x.EVENT_TYPE_UNSPECIFIED = "EVENT_TYPE_UNSPECIFIED", x.EVENT_TYPE_LAYOUT = "EVENT_TYPE_LAYOUT", x.EVENT_TYPE_LAYER = "EVENT_TYPE_LAYER";
  })(fe = a.EventType || (a.EventType = {}));
  function Te(x) {
    switch (x) {
      case 0:
      case "EVENT_TYPE_UNSPECIFIED":
        return fe.EVENT_TYPE_UNSPECIFIED;
      case 1:
      case "EVENT_TYPE_LAYOUT":
        return fe.EVENT_TYPE_LAYOUT;
      case 2:
      case "EVENT_TYPE_LAYER":
        return fe.EVENT_TYPE_LAYER;
      default:
        throw new Je.Error("Unrecognized enum value " + x + " for enum EventType");
    }
  }
  a.eventTypeFromJSON = Te;
  function Re(x) {
    switch (x) {
      case fe.EVENT_TYPE_UNSPECIFIED:
        return "EVENT_TYPE_UNSPECIFIED";
      case fe.EVENT_TYPE_LAYOUT:
        return "EVENT_TYPE_LAYOUT";
      case fe.EVENT_TYPE_LAYER:
        return "EVENT_TYPE_LAYER";
      default:
        return "UNKNOWN";
    }
  }
  a.eventTypeToJSON = Re;
  function Le(x) {
    switch (x) {
      case fe.EVENT_TYPE_UNSPECIFIED:
        return 0;
      case fe.EVENT_TYPE_LAYOUT:
        return 1;
      case fe.EVENT_TYPE_LAYER:
        return 2;
      default:
        return 0;
    }
  }
  a.eventTypeToNumber = Le;
  var be;
  (function(x) {
    x.TRANSITION_DIRECTION_UNSPECIFIED = "TRANSITION_DIRECTION_UNSPECIFIED", x.TRANSITION_DIRECTION_LEFT = "TRANSITION_DIRECTION_LEFT", x.TRANSITION_DIRECTION_RIGHT = "TRANSITION_DIRECTION_RIGHT", x.TRANSITION_DIRECTION_UP = "TRANSITION_DIRECTION_UP", x.TRANSITION_DIRECTION_DOWN = "TRANSITION_DIRECTION_DOWN";
  })(be = a.Transition_TransitionDirection || (a.Transition_TransitionDirection = {}));
  function q(x) {
    switch (x) {
      case 0:
      case "TRANSITION_DIRECTION_UNSPECIFIED":
        return be.TRANSITION_DIRECTION_UNSPECIFIED;
      case 1:
      case "TRANSITION_DIRECTION_LEFT":
        return be.TRANSITION_DIRECTION_LEFT;
      case 2:
      case "TRANSITION_DIRECTION_RIGHT":
        return be.TRANSITION_DIRECTION_RIGHT;
      case 3:
      case "TRANSITION_DIRECTION_UP":
        return be.TRANSITION_DIRECTION_UP;
      case 4:
      case "TRANSITION_DIRECTION_DOWN":
        return be.TRANSITION_DIRECTION_DOWN;
      default:
        throw new Je.Error("Unrecognized enum value " + x + " for enum Transition_TransitionDirection");
    }
  }
  a.transition_TransitionDirectionFromJSON = q;
  function J(x) {
    switch (x) {
      case be.TRANSITION_DIRECTION_UNSPECIFIED:
        return "TRANSITION_DIRECTION_UNSPECIFIED";
      case be.TRANSITION_DIRECTION_LEFT:
        return "TRANSITION_DIRECTION_LEFT";
      case be.TRANSITION_DIRECTION_RIGHT:
        return "TRANSITION_DIRECTION_RIGHT";
      case be.TRANSITION_DIRECTION_UP:
        return "TRANSITION_DIRECTION_UP";
      case be.TRANSITION_DIRECTION_DOWN:
        return "TRANSITION_DIRECTION_DOWN";
      default:
        return "UNKNOWN";
    }
  }
  a.transition_TransitionDirectionToJSON = J;
  function C(x) {
    switch (x) {
      case be.TRANSITION_DIRECTION_UNSPECIFIED:
        return 0;
      case be.TRANSITION_DIRECTION_LEFT:
        return 1;
      case be.TRANSITION_DIRECTION_RIGHT:
        return 2;
      case be.TRANSITION_DIRECTION_UP:
        return 3;
      case be.TRANSITION_DIRECTION_DOWN:
        return 4;
      default:
        return 0;
    }
  }
  a.transition_TransitionDirectionToNumber = C;
  var S;
  (function(x) {
    x.TRANSITION_SWIPE_TYPE_UNSPECIFIED = "TRANSITION_SWIPE_TYPE_UNSPECIFIED", x.TRANSITION_SWIPE_TYPE_COMBINED = "TRANSITION_SWIPE_TYPE_COMBINED", x.TRANSITION_SWIPE_TYPE_SOURCE = "TRANSITION_SWIPE_TYPE_SOURCE", x.TRANSITION_SWIPE_TYPE_DESTINATION = "TRANSITION_SWIPE_TYPE_DESTINATION";
  })(S = a.Transition_TransitionSwipeType || (a.Transition_TransitionSwipeType = {}));
  function E(x) {
    switch (x) {
      case 0:
      case "TRANSITION_SWIPE_TYPE_UNSPECIFIED":
        return S.TRANSITION_SWIPE_TYPE_UNSPECIFIED;
      case 1:
      case "TRANSITION_SWIPE_TYPE_COMBINED":
        return S.TRANSITION_SWIPE_TYPE_COMBINED;
      case 2:
      case "TRANSITION_SWIPE_TYPE_SOURCE":
        return S.TRANSITION_SWIPE_TYPE_SOURCE;
      case 3:
      case "TRANSITION_SWIPE_TYPE_DESTINATION":
        return S.TRANSITION_SWIPE_TYPE_DESTINATION;
      default:
        throw new Je.Error("Unrecognized enum value " + x + " for enum Transition_TransitionSwipeType");
    }
  }
  a.transition_TransitionSwipeTypeFromJSON = E;
  function I(x) {
    switch (x) {
      case S.TRANSITION_SWIPE_TYPE_UNSPECIFIED:
        return "TRANSITION_SWIPE_TYPE_UNSPECIFIED";
      case S.TRANSITION_SWIPE_TYPE_COMBINED:
        return "TRANSITION_SWIPE_TYPE_COMBINED";
      case S.TRANSITION_SWIPE_TYPE_SOURCE:
        return "TRANSITION_SWIPE_TYPE_SOURCE";
      case S.TRANSITION_SWIPE_TYPE_DESTINATION:
        return "TRANSITION_SWIPE_TYPE_DESTINATION";
      default:
        return "UNKNOWN";
    }
  }
  a.transition_TransitionSwipeTypeToJSON = I;
  function M(x) {
    switch (x) {
      case S.TRANSITION_SWIPE_TYPE_UNSPECIFIED:
        return 0;
      case S.TRANSITION_SWIPE_TYPE_COMBINED:
        return 1;
      case S.TRANSITION_SWIPE_TYPE_SOURCE:
        return 2;
      case S.TRANSITION_SWIPE_TYPE_DESTINATION:
        return 3;
      default:
        return 0;
    }
  }
  a.transition_TransitionSwipeTypeToNumber = M;
  function $() {
    return {
      fromLayoutIds: [],
      cut: void 0,
      crossfade: void 0,
      fadeToColor: void 0,
      swipe: void 0,
      stinger: void 0
    };
  }
  a.Transition = {
    encode(x, se = _.Writer.create()) {
      for (const ge of x.fromLayoutIds)
        se.uint32(10).string(ge);
      return x.cut !== void 0 && a.Transition_TransitionCut.encode(x.cut, se.uint32(82).fork()).ldelim(), x.crossfade !== void 0 && a.Transition_TransitionCrossfade.encode(x.crossfade, se.uint32(90).fork()).ldelim(), x.fadeToColor !== void 0 && a.Transition_TransitionFadeToColor.encode(x.fadeToColor, se.uint32(98).fork()).ldelim(), x.swipe !== void 0 && a.Transition_TransitionSwipe.encode(x.swipe, se.uint32(106).fork()).ldelim(), x.stinger !== void 0 && a.Transition_TransitionStinger.encode(x.stinger, se.uint32(114).fork()).ldelim(), se;
    },
    decode(x, se) {
      const ge = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? ge.len : ge.pos + se;
      const Me = $();
      for (; ge.pos < xe; ) {
        const Ye = ge.uint32();
        switch (Ye >>> 3) {
          case 1:
            Me.fromLayoutIds.push(ge.string());
            break;
          case 10:
            Me.cut = a.Transition_TransitionCut.decode(ge, ge.uint32());
            break;
          case 11:
            Me.crossfade = a.Transition_TransitionCrossfade.decode(ge, ge.uint32());
            break;
          case 12:
            Me.fadeToColor = a.Transition_TransitionFadeToColor.decode(ge, ge.uint32());
            break;
          case 13:
            Me.swipe = a.Transition_TransitionSwipe.decode(ge, ge.uint32());
            break;
          case 14:
            Me.stinger = a.Transition_TransitionStinger.decode(ge, ge.uint32());
            break;
          default:
            ge.skipType(Ye & 7);
            break;
        }
      }
      return Me;
    },
    fromJSON(x) {
      return {
        fromLayoutIds: Array.isArray(x == null ? void 0 : x.fromLayoutIds) ? x.fromLayoutIds.map((se) => String(se)) : [],
        cut: Ke(x.cut) ? a.Transition_TransitionCut.fromJSON(x.cut) : void 0,
        crossfade: Ke(x.crossfade) ? a.Transition_TransitionCrossfade.fromJSON(x.crossfade) : void 0,
        fadeToColor: Ke(x.fadeToColor) ? a.Transition_TransitionFadeToColor.fromJSON(x.fadeToColor) : void 0,
        swipe: Ke(x.swipe) ? a.Transition_TransitionSwipe.fromJSON(x.swipe) : void 0,
        stinger: Ke(x.stinger) ? a.Transition_TransitionStinger.fromJSON(x.stinger) : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.fromLayoutIds ? se.fromLayoutIds = x.fromLayoutIds.map((ge) => ge) : se.fromLayoutIds = [], x.cut !== void 0 && (se.cut = x.cut ? a.Transition_TransitionCut.toJSON(x.cut) : void 0), x.crossfade !== void 0 && (se.crossfade = x.crossfade ? a.Transition_TransitionCrossfade.toJSON(x.crossfade) : void 0), x.fadeToColor !== void 0 && (se.fadeToColor = x.fadeToColor ? a.Transition_TransitionFadeToColor.toJSON(x.fadeToColor) : void 0), x.swipe !== void 0 && (se.swipe = x.swipe ? a.Transition_TransitionSwipe.toJSON(x.swipe) : void 0), x.stinger !== void 0 && (se.stinger = x.stinger ? a.Transition_TransitionStinger.toJSON(x.stinger) : void 0), se;
    },
    fromPartial(x) {
      var se;
      const ge = $();
      return ge.fromLayoutIds = ((se = x.fromLayoutIds) === null || se === void 0 ? void 0 : se.map((xe) => xe)) || [], ge.cut = x.cut !== void 0 && x.cut !== null ? a.Transition_TransitionCut.fromPartial(x.cut) : void 0, ge.crossfade = x.crossfade !== void 0 && x.crossfade !== null ? a.Transition_TransitionCrossfade.fromPartial(x.crossfade) : void 0, ge.fadeToColor = x.fadeToColor !== void 0 && x.fadeToColor !== null ? a.Transition_TransitionFadeToColor.fromPartial(x.fadeToColor) : void 0, ge.swipe = x.swipe !== void 0 && x.swipe !== null ? a.Transition_TransitionSwipe.fromPartial(x.swipe) : void 0, ge.stinger = x.stinger !== void 0 && x.stinger !== null ? a.Transition_TransitionStinger.fromPartial(x.stinger) : void 0, ge;
    }
  };
  function U() {
    return { url: "", volume: 0 };
  }
  a.Transition_TransitionMediaType = {
    encode(x, se = _.Writer.create()) {
      return x.url !== "" && se.uint32(10).string(x.url), x.volume !== 0 && se.uint32(17).double(x.volume), se;
    },
    decode(x, se) {
      const ge = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? ge.len : ge.pos + se;
      const Me = U();
      for (; ge.pos < xe; ) {
        const Ye = ge.uint32();
        switch (Ye >>> 3) {
          case 1:
            Me.url = ge.string();
            break;
          case 2:
            Me.volume = ge.double();
            break;
          default:
            ge.skipType(Ye & 7);
            break;
        }
      }
      return Me;
    },
    fromJSON(x) {
      return {
        url: Ke(x.url) ? String(x.url) : "",
        volume: Ke(x.volume) ? Number(x.volume) : 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.url !== void 0 && (se.url = x.url), x.volume !== void 0 && (se.volume = x.volume), se;
    },
    fromPartial(x) {
      var se, ge;
      const xe = U();
      return xe.url = (se = x.url) !== null && se !== void 0 ? se : "", xe.volume = (ge = x.volume) !== null && ge !== void 0 ? ge : 0, xe;
    }
  };
  function Y() {
    return {};
  }
  a.Transition_TransitionCut = {
    encode(x, se = _.Writer.create()) {
      return se;
    },
    decode(x, se) {
      const ge = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? ge.len : ge.pos + se;
      const Me = Y();
      for (; ge.pos < xe; ) {
        const Ye = ge.uint32();
        switch (Ye >>> 3) {
          default:
            ge.skipType(Ye & 7);
            break;
        }
      }
      return Me;
    },
    fromJSON(x) {
      return {};
    },
    toJSON(x) {
      return {};
    },
    fromPartial(x) {
      return Y();
    }
  };
  function L() {
    return { durationMs: 0, backgroundColor: "" };
  }
  a.Transition_TransitionFadeToColor = {
    encode(x, se = _.Writer.create()) {
      return x.durationMs !== 0 && se.uint32(8).int32(x.durationMs), x.backgroundColor !== "" && se.uint32(18).string(x.backgroundColor), se;
    },
    decode(x, se) {
      const ge = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? ge.len : ge.pos + se;
      const Me = L();
      for (; ge.pos < xe; ) {
        const Ye = ge.uint32();
        switch (Ye >>> 3) {
          case 1:
            Me.durationMs = ge.int32();
            break;
          case 2:
            Me.backgroundColor = ge.string();
            break;
          default:
            ge.skipType(Ye & 7);
            break;
        }
      }
      return Me;
    },
    fromJSON(x) {
      return {
        durationMs: Ke(x.durationMs) ? Number(x.durationMs) : 0,
        backgroundColor: Ke(x.backgroundColor) ? String(x.backgroundColor) : ""
      };
    },
    toJSON(x) {
      const se = {};
      return x.durationMs !== void 0 && (se.durationMs = Math.round(x.durationMs)), x.backgroundColor !== void 0 && (se.backgroundColor = x.backgroundColor), se;
    },
    fromPartial(x) {
      var se, ge;
      const xe = L();
      return xe.durationMs = (se = x.durationMs) !== null && se !== void 0 ? se : 0, xe.backgroundColor = (ge = x.backgroundColor) !== null && ge !== void 0 ? ge : "", xe;
    }
  };
  function T() {
    return { durationMs: 0 };
  }
  a.Transition_TransitionCrossfade = {
    encode(x, se = _.Writer.create()) {
      return x.durationMs !== 0 && se.uint32(8).int32(x.durationMs), se;
    },
    decode(x, se) {
      const ge = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? ge.len : ge.pos + se;
      const Me = T();
      for (; ge.pos < xe; ) {
        const Ye = ge.uint32();
        switch (Ye >>> 3) {
          case 1:
            Me.durationMs = ge.int32();
            break;
          default:
            ge.skipType(Ye & 7);
            break;
        }
      }
      return Me;
    },
    fromJSON(x) {
      return {
        durationMs: Ke(x.durationMs) ? Number(x.durationMs) : 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.durationMs !== void 0 && (se.durationMs = Math.round(x.durationMs)), se;
    },
    fromPartial(x) {
      var se;
      const ge = T();
      return ge.durationMs = (se = x.durationMs) !== null && se !== void 0 ? se : 0, ge;
    }
  };
  function B() {
    return {
      durationMs: 0,
      direction: be.TRANSITION_DIRECTION_UNSPECIFIED,
      combinedAnimation: S.TRANSITION_SWIPE_TYPE_UNSPECIFIED
    };
  }
  a.Transition_TransitionSwipe = {
    encode(x, se = _.Writer.create()) {
      return x.durationMs !== 0 && se.uint32(8).int32(x.durationMs), x.direction !== be.TRANSITION_DIRECTION_UNSPECIFIED && se.uint32(16).int32(C(x.direction)), x.combinedAnimation !== S.TRANSITION_SWIPE_TYPE_UNSPECIFIED && se.uint32(24).int32(M(x.combinedAnimation)), se;
    },
    decode(x, se) {
      const ge = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? ge.len : ge.pos + se;
      const Me = B();
      for (; ge.pos < xe; ) {
        const Ye = ge.uint32();
        switch (Ye >>> 3) {
          case 1:
            Me.durationMs = ge.int32();
            break;
          case 2:
            Me.direction = q(ge.int32());
            break;
          case 3:
            Me.combinedAnimation = E(ge.int32());
            break;
          default:
            ge.skipType(Ye & 7);
            break;
        }
      }
      return Me;
    },
    fromJSON(x) {
      return {
        durationMs: Ke(x.durationMs) ? Number(x.durationMs) : 0,
        direction: Ke(x.direction) ? q(x.direction) : be.TRANSITION_DIRECTION_UNSPECIFIED,
        combinedAnimation: Ke(x.combinedAnimation) ? E(x.combinedAnimation) : S.TRANSITION_SWIPE_TYPE_UNSPECIFIED
      };
    },
    toJSON(x) {
      const se = {};
      return x.durationMs !== void 0 && (se.durationMs = Math.round(x.durationMs)), x.direction !== void 0 && (se.direction = J(x.direction)), x.combinedAnimation !== void 0 && (se.combinedAnimation = I(x.combinedAnimation)), se;
    },
    fromPartial(x) {
      var se, ge, xe;
      const Me = B();
      return Me.durationMs = (se = x.durationMs) !== null && se !== void 0 ? se : 0, Me.direction = (ge = x.direction) !== null && ge !== void 0 ? ge : be.TRANSITION_DIRECTION_UNSPECIFIED, Me.combinedAnimation = (xe = x.combinedAnimation) !== null && xe !== void 0 ? xe : S.TRANSITION_SWIPE_TYPE_UNSPECIFIED, Me;
    }
  };
  function te() {
    return { cutPointMs: 0, media: void 0 };
  }
  a.Transition_TransitionStingerCut = {
    encode(x, se = _.Writer.create()) {
      return x.cutPointMs !== 0 && se.uint32(8).int32(x.cutPointMs), x.media !== void 0 && a.Transition_TransitionMediaType.encode(x.media, se.uint32(18).fork()).ldelim(), se;
    },
    decode(x, se) {
      const ge = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? ge.len : ge.pos + se;
      const Me = te();
      for (; ge.pos < xe; ) {
        const Ye = ge.uint32();
        switch (Ye >>> 3) {
          case 1:
            Me.cutPointMs = ge.int32();
            break;
          case 2:
            Me.media = a.Transition_TransitionMediaType.decode(ge, ge.uint32());
            break;
          default:
            ge.skipType(Ye & 7);
            break;
        }
      }
      return Me;
    },
    fromJSON(x) {
      return {
        cutPointMs: Ke(x.cutPointMs) ? Number(x.cutPointMs) : 0,
        media: Ke(x.media) ? a.Transition_TransitionMediaType.fromJSON(x.media) : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.cutPointMs !== void 0 && (se.cutPointMs = Math.round(x.cutPointMs)), x.media !== void 0 && (se.media = x.media ? a.Transition_TransitionMediaType.toJSON(x.media) : void 0), se;
    },
    fromPartial(x) {
      var se;
      const ge = te();
      return ge.cutPointMs = (se = x.cutPointMs) !== null && se !== void 0 ? se : 0, ge.media = x.media !== void 0 && x.media !== null ? a.Transition_TransitionMediaType.fromPartial(x.media) : void 0, ge;
    }
  };
  function pe() {
    return { cut: void 0 };
  }
  a.Transition_TransitionStinger = {
    encode(x, se = _.Writer.create()) {
      return x.cut !== void 0 && a.Transition_TransitionStingerCut.encode(x.cut, se.uint32(10).fork()).ldelim(), se;
    },
    decode(x, se) {
      const ge = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? ge.len : ge.pos + se;
      const Me = pe();
      for (; ge.pos < xe; ) {
        const Ye = ge.uint32();
        switch (Ye >>> 3) {
          case 1:
            Me.cut = a.Transition_TransitionStingerCut.decode(ge, ge.uint32());
            break;
          default:
            ge.skipType(Ye & 7);
            break;
        }
      }
      return Me;
    },
    fromJSON(x) {
      return {
        cut: Ke(x.cut) ? a.Transition_TransitionStingerCut.fromJSON(x.cut) : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.cut !== void 0 && (se.cut = x.cut ? a.Transition_TransitionStingerCut.toJSON(x.cut) : void 0), se;
    },
    fromPartial(x) {
      const se = pe();
      return se.cut = x.cut !== void 0 && x.cut !== null ? a.Transition_TransitionStingerCut.fromPartial(x.cut) : void 0, se;
    }
  };
  function Ie() {
    return {
      id: "",
      width: 0,
      height: 0,
      metadata: void 0,
      projectId: void 0,
      collectionId: void 0,
      type: void 0,
      transitions: [],
      requestMetadata: void 0
    };
  }
  a.Layout = {
    encode(x, se = _.Writer.create()) {
      x.id !== "" && se.uint32(10).string(x.id), x.width !== 0 && se.uint32(16).int32(x.width), x.height !== 0 && se.uint32(24).int32(x.height), x.metadata !== void 0 && k.Value.encode(k.Value.wrap(x.metadata), se.uint32(50).fork()).ldelim(), x.projectId !== void 0 && se.uint32(58).string(x.projectId), x.collectionId !== void 0 && se.uint32(66).string(x.collectionId), x.type !== void 0 && se.uint32(72).int32(z(x.type));
      for (const ge of x.transitions)
        a.Transition.encode(ge, se.uint32(82).fork()).ldelim();
      return x.requestMetadata !== void 0 && k.Value.encode(k.Value.wrap(x.requestMetadata), se.uint32(810).fork()).ldelim(), se;
    },
    decode(x, se) {
      const ge = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? ge.len : ge.pos + se;
      const Me = Ie();
      for (; ge.pos < xe; ) {
        const Ye = ge.uint32();
        switch (Ye >>> 3) {
          case 1:
            Me.id = ge.string();
            break;
          case 2:
            Me.width = ge.int32();
            break;
          case 3:
            Me.height = ge.int32();
            break;
          case 6:
            Me.metadata = k.Value.unwrap(k.Value.decode(ge, ge.uint32()));
            break;
          case 7:
            Me.projectId = ge.string();
            break;
          case 8:
            Me.collectionId = ge.string();
            break;
          case 9:
            Me.type = D(ge.int32());
            break;
          case 10:
            Me.transitions.push(a.Transition.decode(ge, ge.uint32()));
            break;
          case 101:
            Me.requestMetadata = k.Value.unwrap(k.Value.decode(ge, ge.uint32()));
            break;
          default:
            ge.skipType(Ye & 7);
            break;
        }
      }
      return Me;
    },
    fromJSON(x) {
      return {
        id: Ke(x.id) ? String(x.id) : "",
        width: Ke(x.width) ? Number(x.width) : 0,
        height: Ke(x.height) ? Number(x.height) : 0,
        metadata: Ke(x == null ? void 0 : x.metadata) ? x.metadata : void 0,
        projectId: Ke(x.projectId) ? String(x.projectId) : void 0,
        collectionId: Ke(x.collectionId) ? String(x.collectionId) : void 0,
        type: Ke(x.type) ? D(x.type) : void 0,
        transitions: Array.isArray(x == null ? void 0 : x.transitions) ? x.transitions.map((se) => a.Transition.fromJSON(se)) : [],
        requestMetadata: Ke(x == null ? void 0 : x.requestMetadata) ? x.requestMetadata : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.id !== void 0 && (se.id = x.id), x.width !== void 0 && (se.width = Math.round(x.width)), x.height !== void 0 && (se.height = Math.round(x.height)), x.metadata !== void 0 && (se.metadata = x.metadata), x.projectId !== void 0 && (se.projectId = x.projectId), x.collectionId !== void 0 && (se.collectionId = x.collectionId), x.type !== void 0 && (se.type = x.type !== void 0 ? F(x.type) : void 0), x.transitions ? se.transitions = x.transitions.map((ge) => ge ? a.Transition.toJSON(ge) : void 0) : se.transitions = [], x.requestMetadata !== void 0 && (se.requestMetadata = x.requestMetadata), se;
    },
    fromPartial(x) {
      var se, ge, xe, Me, Ye, et, dt, St, tt;
      const at = Ie();
      return at.id = (se = x.id) !== null && se !== void 0 ? se : "", at.width = (ge = x.width) !== null && ge !== void 0 ? ge : 0, at.height = (xe = x.height) !== null && xe !== void 0 ? xe : 0, at.metadata = (Me = x.metadata) !== null && Me !== void 0 ? Me : void 0, at.projectId = (Ye = x.projectId) !== null && Ye !== void 0 ? Ye : void 0, at.collectionId = (et = x.collectionId) !== null && et !== void 0 ? et : void 0, at.type = (dt = x.type) !== null && dt !== void 0 ? dt : void 0, at.transitions = ((St = x.transitions) === null || St === void 0 ? void 0 : St.map((kt) => a.Transition.fromPartial(kt))) || [], at.requestMetadata = (tt = x.requestMetadata) !== null && tt !== void 0 ? tt : void 0, at;
    }
  };
  function $e() {
    return {
      type: "",
      data: void 0,
      x: void 0,
      y: void 0,
      width: void 0,
      height: void 0,
      rotation: 0,
      opacity: 0,
      scale: 0,
      hidden: !1,
      children: void 0,
      metadata: void 0,
      id: "",
      layoutId: "",
      requestMetadata: void 0,
      requestAnimation: []
    };
  }
  a.Layer = {
    encode(x, se = _.Writer.create()) {
      x.type !== "" && se.uint32(10).string(x.type), x.data !== void 0 && k.Struct.encode(k.Struct.wrap(x.data), se.uint32(18).fork()).ldelim(), x.x !== void 0 && k.Value.encode(k.Value.wrap(x.x), se.uint32(26).fork()).ldelim(), x.y !== void 0 && k.Value.encode(k.Value.wrap(x.y), se.uint32(34).fork()).ldelim(), x.width !== void 0 && k.Value.encode(k.Value.wrap(x.width), se.uint32(42).fork()).ldelim(), x.height !== void 0 && k.Value.encode(k.Value.wrap(x.height), se.uint32(50).fork()).ldelim(), x.rotation !== 0 && se.uint32(57).double(x.rotation), x.opacity !== 0 && se.uint32(65).double(x.opacity), x.scale !== 0 && se.uint32(73).double(x.scale), x.hidden === !0 && se.uint32(80).bool(x.hidden), x.children !== void 0 && k.ListValue.encode(k.ListValue.wrap(x.children), se.uint32(98).fork()).ldelim(), x.metadata !== void 0 && k.Value.encode(k.Value.wrap(x.metadata), se.uint32(114).fork()).ldelim(), x.id !== "" && se.uint32(802).string(x.id), x.layoutId !== "" && se.uint32(818).string(x.layoutId), x.requestMetadata !== void 0 && k.Value.encode(k.Value.wrap(x.requestMetadata), se.uint32(810).fork()).ldelim();
      for (const ge of x.requestAnimation)
        a.LayerAnimation.encode(ge, se.uint32(826).fork()).ldelim();
      return se;
    },
    decode(x, se) {
      const ge = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? ge.len : ge.pos + se;
      const Me = $e();
      for (; ge.pos < xe; ) {
        const Ye = ge.uint32();
        switch (Ye >>> 3) {
          case 1:
            Me.type = ge.string();
            break;
          case 2:
            Me.data = k.Struct.unwrap(k.Struct.decode(ge, ge.uint32()));
            break;
          case 3:
            Me.x = k.Value.unwrap(k.Value.decode(ge, ge.uint32()));
            break;
          case 4:
            Me.y = k.Value.unwrap(k.Value.decode(ge, ge.uint32()));
            break;
          case 5:
            Me.width = k.Value.unwrap(k.Value.decode(ge, ge.uint32()));
            break;
          case 6:
            Me.height = k.Value.unwrap(k.Value.decode(ge, ge.uint32()));
            break;
          case 7:
            Me.rotation = ge.double();
            break;
          case 8:
            Me.opacity = ge.double();
            break;
          case 9:
            Me.scale = ge.double();
            break;
          case 10:
            Me.hidden = ge.bool();
            break;
          case 12:
            Me.children = k.ListValue.unwrap(k.ListValue.decode(ge, ge.uint32()));
            break;
          case 14:
            Me.metadata = k.Value.unwrap(k.Value.decode(ge, ge.uint32()));
            break;
          case 100:
            Me.id = ge.string();
            break;
          case 102:
            Me.layoutId = ge.string();
            break;
          case 101:
            Me.requestMetadata = k.Value.unwrap(k.Value.decode(ge, ge.uint32()));
            break;
          case 103:
            Me.requestAnimation.push(a.LayerAnimation.decode(ge, ge.uint32()));
            break;
          default:
            ge.skipType(Ye & 7);
            break;
        }
      }
      return Me;
    },
    fromJSON(x) {
      return {
        type: Ke(x.type) ? String(x.type) : "",
        data: Ze(x.data) ? x.data : void 0,
        x: Ke(x == null ? void 0 : x.x) ? x.x : void 0,
        y: Ke(x == null ? void 0 : x.y) ? x.y : void 0,
        width: Ke(x == null ? void 0 : x.width) ? x.width : void 0,
        height: Ke(x == null ? void 0 : x.height) ? x.height : void 0,
        rotation: Ke(x.rotation) ? Number(x.rotation) : 0,
        opacity: Ke(x.opacity) ? Number(x.opacity) : 0,
        scale: Ke(x.scale) ? Number(x.scale) : 0,
        hidden: Ke(x.hidden) ? !!x.hidden : !1,
        children: Array.isArray(x.children) ? [...x.children] : void 0,
        metadata: Ke(x == null ? void 0 : x.metadata) ? x.metadata : void 0,
        id: Ke(x.id) ? String(x.id) : "",
        layoutId: Ke(x.layoutId) ? String(x.layoutId) : "",
        requestMetadata: Ke(x == null ? void 0 : x.requestMetadata) ? x.requestMetadata : void 0,
        requestAnimation: Array.isArray(x == null ? void 0 : x.requestAnimation) ? x.requestAnimation.map((se) => a.LayerAnimation.fromJSON(se)) : []
      };
    },
    toJSON(x) {
      const se = {};
      return x.type !== void 0 && (se.type = x.type), x.data !== void 0 && (se.data = x.data), x.x !== void 0 && (se.x = x.x), x.y !== void 0 && (se.y = x.y), x.width !== void 0 && (se.width = x.width), x.height !== void 0 && (se.height = x.height), x.rotation !== void 0 && (se.rotation = x.rotation), x.opacity !== void 0 && (se.opacity = x.opacity), x.scale !== void 0 && (se.scale = x.scale), x.hidden !== void 0 && (se.hidden = x.hidden), x.children !== void 0 && (se.children = x.children), x.metadata !== void 0 && (se.metadata = x.metadata), x.id !== void 0 && (se.id = x.id), x.layoutId !== void 0 && (se.layoutId = x.layoutId), x.requestMetadata !== void 0 && (se.requestMetadata = x.requestMetadata), x.requestAnimation ? se.requestAnimation = x.requestAnimation.map((ge) => ge ? a.LayerAnimation.toJSON(ge) : void 0) : se.requestAnimation = [], se;
    },
    fromPartial(x) {
      var se, ge, xe, Me, Ye, et, dt, St, tt, at, kt, rt, ut, wt, nt, it;
      const bt = $e();
      return bt.type = (se = x.type) !== null && se !== void 0 ? se : "", bt.data = (ge = x.data) !== null && ge !== void 0 ? ge : void 0, bt.x = (xe = x.x) !== null && xe !== void 0 ? xe : void 0, bt.y = (Me = x.y) !== null && Me !== void 0 ? Me : void 0, bt.width = (Ye = x.width) !== null && Ye !== void 0 ? Ye : void 0, bt.height = (et = x.height) !== null && et !== void 0 ? et : void 0, bt.rotation = (dt = x.rotation) !== null && dt !== void 0 ? dt : 0, bt.opacity = (St = x.opacity) !== null && St !== void 0 ? St : 0, bt.scale = (tt = x.scale) !== null && tt !== void 0 ? tt : 0, bt.hidden = (at = x.hidden) !== null && at !== void 0 ? at : !1, bt.children = (kt = x.children) !== null && kt !== void 0 ? kt : void 0, bt.metadata = (rt = x.metadata) !== null && rt !== void 0 ? rt : void 0, bt.id = (ut = x.id) !== null && ut !== void 0 ? ut : "", bt.layoutId = (wt = x.layoutId) !== null && wt !== void 0 ? wt : "", bt.requestMetadata = (nt = x.requestMetadata) !== null && nt !== void 0 ? nt : void 0, bt.requestAnimation = ((it = x.requestAnimation) === null || it === void 0 ? void 0 : it.map((ot) => a.LayerAnimation.fromPartial(ot))) || [], bt;
    }
  };
  function ve() {
    return { layoutId: "", layerId: "", payload: void 0 };
  }
  a.DeleteLayerRequest = {
    encode(x, se = _.Writer.create()) {
      return x.layoutId !== "" && se.uint32(10).string(x.layoutId), x.layerId !== "" && se.uint32(18).string(x.layerId), x.payload !== void 0 && a.DeleteLayerPayload.encode(x.payload, se.uint32(26).fork()).ldelim(), se;
    },
    decode(x, se) {
      const ge = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? ge.len : ge.pos + se;
      const Me = ve();
      for (; ge.pos < xe; ) {
        const Ye = ge.uint32();
        switch (Ye >>> 3) {
          case 1:
            Me.layoutId = ge.string();
            break;
          case 2:
            Me.layerId = ge.string();
            break;
          case 3:
            Me.payload = a.DeleteLayerPayload.decode(ge, ge.uint32());
            break;
          default:
            ge.skipType(Ye & 7);
            break;
        }
      }
      return Me;
    },
    fromJSON(x) {
      return {
        layoutId: Ke(x.layoutId) ? String(x.layoutId) : "",
        layerId: Ke(x.layerId) ? String(x.layerId) : "",
        payload: Ke(x.payload) ? a.DeleteLayerPayload.fromJSON(x.payload) : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.layoutId !== void 0 && (se.layoutId = x.layoutId), x.layerId !== void 0 && (se.layerId = x.layerId), x.payload !== void 0 && (se.payload = x.payload ? a.DeleteLayerPayload.toJSON(x.payload) : void 0), se;
    },
    fromPartial(x) {
      var se, ge;
      const xe = ve();
      return xe.layoutId = (se = x.layoutId) !== null && se !== void 0 ? se : "", xe.layerId = (ge = x.layerId) !== null && ge !== void 0 ? ge : "", xe.payload = x.payload !== void 0 && x.payload !== null ? a.DeleteLayerPayload.fromPartial(x.payload) : void 0, xe;
    }
  };
  function he() {
    return { id: "", layoutId: "", requestMetadata: void 0 };
  }
  a.DeleteLayerResponse = {
    encode(x, se = _.Writer.create()) {
      return x.id !== "" && se.uint32(10).string(x.id), x.layoutId !== "" && se.uint32(18).string(x.layoutId), x.requestMetadata !== void 0 && k.Value.encode(k.Value.wrap(x.requestMetadata), se.uint32(802).fork()).ldelim(), se;
    },
    decode(x, se) {
      const ge = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? ge.len : ge.pos + se;
      const Me = he();
      for (; ge.pos < xe; ) {
        const Ye = ge.uint32();
        switch (Ye >>> 3) {
          case 1:
            Me.id = ge.string();
            break;
          case 2:
            Me.layoutId = ge.string();
            break;
          case 100:
            Me.requestMetadata = k.Value.unwrap(k.Value.decode(ge, ge.uint32()));
            break;
          default:
            ge.skipType(Ye & 7);
            break;
        }
      }
      return Me;
    },
    fromJSON(x) {
      return {
        id: Ke(x.id) ? String(x.id) : "",
        layoutId: Ke(x.layoutId) ? String(x.layoutId) : "",
        requestMetadata: Ke(x == null ? void 0 : x.requestMetadata) ? x.requestMetadata : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.id !== void 0 && (se.id = x.id), x.layoutId !== void 0 && (se.layoutId = x.layoutId), x.requestMetadata !== void 0 && (se.requestMetadata = x.requestMetadata), se;
    },
    fromPartial(x) {
      var se, ge, xe;
      const Me = he();
      return Me.id = (se = x.id) !== null && se !== void 0 ? se : "", Me.layoutId = (ge = x.layoutId) !== null && ge !== void 0 ? ge : "", Me.requestMetadata = (xe = x.requestMetadata) !== null && xe !== void 0 ? xe : void 0, Me;
    }
  };
  function Oe() {
    return {
      layers: [],
      layoutId: "",
      requestMetadata: void 0,
      requestAnimationMode: j.REQUEST_ANIMATION_MODE_UNSPECIFIED
    };
  }
  a.BatchLayerResponse = {
    encode(x, se = _.Writer.create()) {
      for (const ge of x.layers)
        a.BatchLayerResponse_BatchLayerItem.encode(ge, se.uint32(18).fork()).ldelim();
      return x.layoutId !== "" && se.uint32(26).string(x.layoutId), x.requestMetadata !== void 0 && k.Value.encode(k.Value.wrap(x.requestMetadata), se.uint32(802).fork()).ldelim(), x.requestAnimationMode !== j.REQUEST_ANIMATION_MODE_UNSPECIFIED && se.uint32(808).int32(ae(x.requestAnimationMode)), se;
    },
    decode(x, se) {
      const ge = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? ge.len : ge.pos + se;
      const Me = Oe();
      for (; ge.pos < xe; ) {
        const Ye = ge.uint32();
        switch (Ye >>> 3) {
          case 2:
            Me.layers.push(a.BatchLayerResponse_BatchLayerItem.decode(ge, ge.uint32()));
            break;
          case 3:
            Me.layoutId = ge.string();
            break;
          case 100:
            Me.requestMetadata = k.Value.unwrap(k.Value.decode(ge, ge.uint32()));
            break;
          case 101:
            Me.requestAnimationMode = ee(ge.int32());
            break;
          default:
            ge.skipType(Ye & 7);
            break;
        }
      }
      return Me;
    },
    fromJSON(x) {
      return {
        layers: Array.isArray(x == null ? void 0 : x.layers) ? x.layers.map((se) => a.BatchLayerResponse_BatchLayerItem.fromJSON(se)) : [],
        layoutId: Ke(x.layoutId) ? String(x.layoutId) : "",
        requestMetadata: Ke(x == null ? void 0 : x.requestMetadata) ? x.requestMetadata : void 0,
        requestAnimationMode: Ke(x.requestAnimationMode) ? ee(x.requestAnimationMode) : j.REQUEST_ANIMATION_MODE_UNSPECIFIED
      };
    },
    toJSON(x) {
      const se = {};
      return x.layers ? se.layers = x.layers.map((ge) => ge ? a.BatchLayerResponse_BatchLayerItem.toJSON(ge) : void 0) : se.layers = [], x.layoutId !== void 0 && (se.layoutId = x.layoutId), x.requestMetadata !== void 0 && (se.requestMetadata = x.requestMetadata), x.requestAnimationMode !== void 0 && (se.requestAnimationMode = X(x.requestAnimationMode)), se;
    },
    fromPartial(x) {
      var se, ge, xe, Me;
      const Ye = Oe();
      return Ye.layers = ((se = x.layers) === null || se === void 0 ? void 0 : se.map((et) => a.BatchLayerResponse_BatchLayerItem.fromPartial(et))) || [], Ye.layoutId = (ge = x.layoutId) !== null && ge !== void 0 ? ge : "", Ye.requestMetadata = (xe = x.requestMetadata) !== null && xe !== void 0 ? xe : void 0, Ye.requestAnimationMode = (Me = x.requestAnimationMode) !== null && Me !== void 0 ? Me : j.REQUEST_ANIMATION_MODE_UNSPECIFIED, Ye;
    }
  };
  function Ae() {
    return { create: void 0, update: void 0, delete: void 0 };
  }
  a.BatchLayerResponse_BatchLayerItem = {
    encode(x, se = _.Writer.create()) {
      return x.create !== void 0 && a.Layer.encode(x.create, se.uint32(10).fork()).ldelim(), x.update !== void 0 && a.Layer.encode(x.update, se.uint32(18).fork()).ldelim(), x.delete !== void 0 && a.DeleteLayerResponse.encode(x.delete, se.uint32(26).fork()).ldelim(), se;
    },
    decode(x, se) {
      const ge = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? ge.len : ge.pos + se;
      const Me = Ae();
      for (; ge.pos < xe; ) {
        const Ye = ge.uint32();
        switch (Ye >>> 3) {
          case 1:
            Me.create = a.Layer.decode(ge, ge.uint32());
            break;
          case 2:
            Me.update = a.Layer.decode(ge, ge.uint32());
            break;
          case 3:
            Me.delete = a.DeleteLayerResponse.decode(ge, ge.uint32());
            break;
          default:
            ge.skipType(Ye & 7);
            break;
        }
      }
      return Me;
    },
    fromJSON(x) {
      return {
        create: Ke(x.create) ? a.Layer.fromJSON(x.create) : void 0,
        update: Ke(x.update) ? a.Layer.fromJSON(x.update) : void 0,
        delete: Ke(x.delete) ? a.DeleteLayerResponse.fromJSON(x.delete) : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.create !== void 0 && (se.create = x.create ? a.Layer.toJSON(x.create) : void 0), x.update !== void 0 && (se.update = x.update ? a.Layer.toJSON(x.update) : void 0), x.delete !== void 0 && (se.delete = x.delete ? a.DeleteLayerResponse.toJSON(x.delete) : void 0), se;
    },
    fromPartial(x) {
      const se = Ae();
      return se.create = x.create !== void 0 && x.create !== null ? a.Layer.fromPartial(x.create) : void 0, se.update = x.update !== void 0 && x.update !== null ? a.Layer.fromPartial(x.update) : void 0, se.delete = x.delete !== void 0 && x.delete !== null ? a.DeleteLayerResponse.fromPartial(x.delete) : void 0, se;
    }
  };
  function Ue() {
    return {
      width: void 0,
      height: void 0,
      metadata: void 0,
      projectId: void 0,
      collectionId: void 0,
      type: void 0,
      transitions: [],
      requestMetadata: void 0
    };
  }
  a.PartialLayout = {
    encode(x, se = _.Writer.create()) {
      x.width !== void 0 && se.uint32(16).int32(x.width), x.height !== void 0 && se.uint32(24).int32(x.height), x.metadata !== void 0 && k.Value.encode(k.Value.wrap(x.metadata), se.uint32(50).fork()).ldelim(), x.projectId !== void 0 && se.uint32(58).string(x.projectId), x.collectionId !== void 0 && se.uint32(66).string(x.collectionId), x.type !== void 0 && se.uint32(72).int32(z(x.type));
      for (const ge of x.transitions)
        a.Transition.encode(ge, se.uint32(82).fork()).ldelim();
      return x.requestMetadata !== void 0 && k.Value.encode(k.Value.wrap(x.requestMetadata), se.uint32(810).fork()).ldelim(), se;
    },
    decode(x, se) {
      const ge = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? ge.len : ge.pos + se;
      const Me = Ue();
      for (; ge.pos < xe; ) {
        const Ye = ge.uint32();
        switch (Ye >>> 3) {
          case 2:
            Me.width = ge.int32();
            break;
          case 3:
            Me.height = ge.int32();
            break;
          case 6:
            Me.metadata = k.Value.unwrap(k.Value.decode(ge, ge.uint32()));
            break;
          case 7:
            Me.projectId = ge.string();
            break;
          case 8:
            Me.collectionId = ge.string();
            break;
          case 9:
            Me.type = D(ge.int32());
            break;
          case 10:
            Me.transitions.push(a.Transition.decode(ge, ge.uint32()));
            break;
          case 101:
            Me.requestMetadata = k.Value.unwrap(k.Value.decode(ge, ge.uint32()));
            break;
          default:
            ge.skipType(Ye & 7);
            break;
        }
      }
      return Me;
    },
    fromJSON(x) {
      return {
        width: Ke(x.width) ? Number(x.width) : void 0,
        height: Ke(x.height) ? Number(x.height) : void 0,
        metadata: Ke(x == null ? void 0 : x.metadata) ? x.metadata : void 0,
        projectId: Ke(x.projectId) ? String(x.projectId) : void 0,
        collectionId: Ke(x.collectionId) ? String(x.collectionId) : void 0,
        type: Ke(x.type) ? D(x.type) : void 0,
        transitions: Array.isArray(x == null ? void 0 : x.transitions) ? x.transitions.map((se) => a.Transition.fromJSON(se)) : [],
        requestMetadata: Ke(x == null ? void 0 : x.requestMetadata) ? x.requestMetadata : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.width !== void 0 && (se.width = Math.round(x.width)), x.height !== void 0 && (se.height = Math.round(x.height)), x.metadata !== void 0 && (se.metadata = x.metadata), x.projectId !== void 0 && (se.projectId = x.projectId), x.collectionId !== void 0 && (se.collectionId = x.collectionId), x.type !== void 0 && (se.type = x.type !== void 0 ? F(x.type) : void 0), x.transitions ? se.transitions = x.transitions.map((ge) => ge ? a.Transition.toJSON(ge) : void 0) : se.transitions = [], x.requestMetadata !== void 0 && (se.requestMetadata = x.requestMetadata), se;
    },
    fromPartial(x) {
      var se, ge, xe, Me, Ye, et, dt, St;
      const tt = Ue();
      return tt.width = (se = x.width) !== null && se !== void 0 ? se : void 0, tt.height = (ge = x.height) !== null && ge !== void 0 ? ge : void 0, tt.metadata = (xe = x.metadata) !== null && xe !== void 0 ? xe : void 0, tt.projectId = (Me = x.projectId) !== null && Me !== void 0 ? Me : void 0, tt.collectionId = (Ye = x.collectionId) !== null && Ye !== void 0 ? Ye : void 0, tt.type = (et = x.type) !== null && et !== void 0 ? et : void 0, tt.transitions = ((dt = x.transitions) === null || dt === void 0 ? void 0 : dt.map((at) => a.Transition.fromPartial(at))) || [], tt.requestMetadata = (St = x.requestMetadata) !== null && St !== void 0 ? St : void 0, tt;
    }
  };
  function oe() {
    return { projectId: void 0, collectionId: void 0, type: void 0 };
  }
  a.ListLayoutsRequest = {
    encode(x, se = _.Writer.create()) {
      return x.projectId !== void 0 && se.uint32(10).string(x.projectId), x.collectionId !== void 0 && se.uint32(18).string(x.collectionId), x.type !== void 0 && se.uint32(24).int32(z(x.type)), se;
    },
    decode(x, se) {
      const ge = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? ge.len : ge.pos + se;
      const Me = oe();
      for (; ge.pos < xe; ) {
        const Ye = ge.uint32();
        switch (Ye >>> 3) {
          case 1:
            Me.projectId = ge.string();
            break;
          case 2:
            Me.collectionId = ge.string();
            break;
          case 3:
            Me.type = D(ge.int32());
            break;
          default:
            ge.skipType(Ye & 7);
            break;
        }
      }
      return Me;
    },
    fromJSON(x) {
      return {
        projectId: Ke(x.projectId) ? String(x.projectId) : void 0,
        collectionId: Ke(x.collectionId) ? String(x.collectionId) : void 0,
        type: Ke(x.type) ? D(x.type) : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.projectId !== void 0 && (se.projectId = x.projectId), x.collectionId !== void 0 && (se.collectionId = x.collectionId), x.type !== void 0 && (se.type = x.type !== void 0 ? F(x.type) : void 0), se;
    },
    fromPartial(x) {
      var se, ge, xe;
      const Me = oe();
      return Me.projectId = (se = x.projectId) !== null && se !== void 0 ? se : void 0, Me.collectionId = (ge = x.collectionId) !== null && ge !== void 0 ? ge : void 0, Me.type = (xe = x.type) !== null && xe !== void 0 ? xe : void 0, Me;
    }
  };
  function A() {
    return { layouts: [] };
  }
  a.ListLayoutsResponse = {
    encode(x, se = _.Writer.create()) {
      for (const ge of x.layouts)
        a.Layout.encode(ge, se.uint32(10).fork()).ldelim();
      return se;
    },
    decode(x, se) {
      const ge = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? ge.len : ge.pos + se;
      const Me = A();
      for (; ge.pos < xe; ) {
        const Ye = ge.uint32();
        switch (Ye >>> 3) {
          case 1:
            Me.layouts.push(a.Layout.decode(ge, ge.uint32()));
            break;
          default:
            ge.skipType(Ye & 7);
            break;
        }
      }
      return Me;
    },
    fromJSON(x) {
      return {
        layouts: Array.isArray(x == null ? void 0 : x.layouts) ? x.layouts.map((se) => a.Layout.fromJSON(se)) : []
      };
    },
    toJSON(x) {
      const se = {};
      return x.layouts ? se.layouts = x.layouts.map((ge) => ge ? a.Layout.toJSON(ge) : void 0) : se.layouts = [], se;
    },
    fromPartial(x) {
      var se;
      const ge = A();
      return ge.layouts = ((se = x.layouts) === null || se === void 0 ? void 0 : se.map((xe) => a.Layout.fromPartial(xe))) || [], ge;
    }
  };
  function re() {
    return { layout: void 0 };
  }
  a.CreateLayoutRequest = {
    encode(x, se = _.Writer.create()) {
      return x.layout !== void 0 && a.PartialLayout.encode(x.layout, se.uint32(18).fork()).ldelim(), se;
    },
    decode(x, se) {
      const ge = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? ge.len : ge.pos + se;
      const Me = re();
      for (; ge.pos < xe; ) {
        const Ye = ge.uint32();
        switch (Ye >>> 3) {
          case 2:
            Me.layout = a.PartialLayout.decode(ge, ge.uint32());
            break;
          default:
            ge.skipType(Ye & 7);
            break;
        }
      }
      return Me;
    },
    fromJSON(x) {
      return {
        layout: Ke(x.layout) ? a.PartialLayout.fromJSON(x.layout) : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.layout !== void 0 && (se.layout = x.layout ? a.PartialLayout.toJSON(x.layout) : void 0), se;
    },
    fromPartial(x) {
      const se = re();
      return se.layout = x.layout !== void 0 && x.layout !== null ? a.PartialLayout.fromPartial(x.layout) : void 0, se;
    }
  };
  function le() {
    return { layoutId: "" };
  }
  a.GetLayoutRequest = {
    encode(x, se = _.Writer.create()) {
      return x.layoutId !== "" && se.uint32(10).string(x.layoutId), se;
    },
    decode(x, se) {
      const ge = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? ge.len : ge.pos + se;
      const Me = le();
      for (; ge.pos < xe; ) {
        const Ye = ge.uint32();
        switch (Ye >>> 3) {
          case 1:
            Me.layoutId = ge.string();
            break;
          default:
            ge.skipType(Ye & 7);
            break;
        }
      }
      return Me;
    },
    fromJSON(x) {
      return {
        layoutId: Ke(x.layoutId) ? String(x.layoutId) : ""
      };
    },
    toJSON(x) {
      const se = {};
      return x.layoutId !== void 0 && (se.layoutId = x.layoutId), se;
    },
    fromPartial(x) {
      var se;
      const ge = le();
      return ge.layoutId = (se = x.layoutId) !== null && se !== void 0 ? se : "", ge;
    }
  };
  function Ne() {
    return { layoutId: "", layout: void 0 };
  }
  a.UpdateLayoutRequest = {
    encode(x, se = _.Writer.create()) {
      return x.layoutId !== "" && se.uint32(10).string(x.layoutId), x.layout !== void 0 && a.PartialLayout.encode(x.layout, se.uint32(26).fork()).ldelim(), se;
    },
    decode(x, se) {
      const ge = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? ge.len : ge.pos + se;
      const Me = Ne();
      for (; ge.pos < xe; ) {
        const Ye = ge.uint32();
        switch (Ye >>> 3) {
          case 1:
            Me.layoutId = ge.string();
            break;
          case 3:
            Me.layout = a.PartialLayout.decode(ge, ge.uint32());
            break;
          default:
            ge.skipType(Ye & 7);
            break;
        }
      }
      return Me;
    },
    fromJSON(x) {
      return {
        layoutId: Ke(x.layoutId) ? String(x.layoutId) : "",
        layout: Ke(x.layout) ? a.PartialLayout.fromJSON(x.layout) : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.layoutId !== void 0 && (se.layoutId = x.layoutId), x.layout !== void 0 && (se.layout = x.layout ? a.PartialLayout.toJSON(x.layout) : void 0), se;
    },
    fromPartial(x) {
      var se;
      const ge = Ne();
      return ge.layoutId = (se = x.layoutId) !== null && se !== void 0 ? se : "", ge.layout = x.layout !== void 0 && x.layout !== null ? a.PartialLayout.fromPartial(x.layout) : void 0, ge;
    }
  };
  function Pe() {
    return { requestMetadata: void 0 };
  }
  a.DeleteLayoutPayload = {
    encode(x, se = _.Writer.create()) {
      return x.requestMetadata !== void 0 && k.Value.encode(k.Value.wrap(x.requestMetadata), se.uint32(802).fork()).ldelim(), se;
    },
    decode(x, se) {
      const ge = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? ge.len : ge.pos + se;
      const Me = Pe();
      for (; ge.pos < xe; ) {
        const Ye = ge.uint32();
        switch (Ye >>> 3) {
          case 100:
            Me.requestMetadata = k.Value.unwrap(k.Value.decode(ge, ge.uint32()));
            break;
          default:
            ge.skipType(Ye & 7);
            break;
        }
      }
      return Me;
    },
    fromJSON(x) {
      return {
        requestMetadata: Ke(x == null ? void 0 : x.requestMetadata) ? x.requestMetadata : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.requestMetadata !== void 0 && (se.requestMetadata = x.requestMetadata), se;
    },
    fromPartial(x) {
      var se;
      const ge = Pe();
      return ge.requestMetadata = (se = x.requestMetadata) !== null && se !== void 0 ? se : void 0, ge;
    }
  };
  function Fe() {
    return { layoutId: "", payload: void 0 };
  }
  a.DeleteLayoutRequest = {
    encode(x, se = _.Writer.create()) {
      return x.layoutId !== "" && se.uint32(10).string(x.layoutId), x.payload !== void 0 && a.DeleteLayoutPayload.encode(x.payload, se.uint32(18).fork()).ldelim(), se;
    },
    decode(x, se) {
      const ge = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? ge.len : ge.pos + se;
      const Me = Fe();
      for (; ge.pos < xe; ) {
        const Ye = ge.uint32();
        switch (Ye >>> 3) {
          case 1:
            Me.layoutId = ge.string();
            break;
          case 2:
            Me.payload = a.DeleteLayoutPayload.decode(ge, ge.uint32());
            break;
          default:
            ge.skipType(Ye & 7);
            break;
        }
      }
      return Me;
    },
    fromJSON(x) {
      return {
        layoutId: Ke(x.layoutId) ? String(x.layoutId) : "",
        payload: Ke(x.payload) ? a.DeleteLayoutPayload.fromJSON(x.payload) : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.layoutId !== void 0 && (se.layoutId = x.layoutId), x.payload !== void 0 && (se.payload = x.payload ? a.DeleteLayoutPayload.toJSON(x.payload) : void 0), se;
    },
    fromPartial(x) {
      var se;
      const ge = Fe();
      return ge.layoutId = (se = x.layoutId) !== null && se !== void 0 ? se : "", ge.payload = x.payload !== void 0 && x.payload !== null ? a.DeleteLayoutPayload.fromPartial(x.payload) : void 0, ge;
    }
  };
  function je() {
    return { id: "", requestMetadata: void 0 };
  }
  a.DeleteLayoutResponse = {
    encode(x, se = _.Writer.create()) {
      return x.id !== "" && se.uint32(18).string(x.id), x.requestMetadata !== void 0 && k.Value.encode(k.Value.wrap(x.requestMetadata), se.uint32(802).fork()).ldelim(), se;
    },
    decode(x, se) {
      const ge = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? ge.len : ge.pos + se;
      const Me = je();
      for (; ge.pos < xe; ) {
        const Ye = ge.uint32();
        switch (Ye >>> 3) {
          case 2:
            Me.id = ge.string();
            break;
          case 100:
            Me.requestMetadata = k.Value.unwrap(k.Value.decode(ge, ge.uint32()));
            break;
          default:
            ge.skipType(Ye & 7);
            break;
        }
      }
      return Me;
    },
    fromJSON(x) {
      return {
        id: Ke(x.id) ? String(x.id) : "",
        requestMetadata: Ke(x == null ? void 0 : x.requestMetadata) ? x.requestMetadata : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.id !== void 0 && (se.id = x.id), x.requestMetadata !== void 0 && (se.requestMetadata = x.requestMetadata), se;
    },
    fromPartial(x) {
      var se, ge;
      const xe = je();
      return xe.id = (se = x.id) !== null && se !== void 0 ? se : "", xe.requestMetadata = (ge = x.requestMetadata) !== null && ge !== void 0 ? ge : void 0, xe;
    }
  };
  function qe() {
    return {
      properties: [],
      durationMs: 0,
      delayMs: void 0,
      easingMode: void 0
    };
  }
  a.LayerAnimation = {
    encode(x, se = _.Writer.create()) {
      for (const ge of x.properties)
        se.uint32(10).string(ge);
      return x.durationMs !== 0 && se.uint32(16).int32(x.durationMs), x.delayMs !== void 0 && se.uint32(32).int32(x.delayMs), x.easingMode !== void 0 && se.uint32(42).string(x.easingMode), se;
    },
    decode(x, se) {
      const ge = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? ge.len : ge.pos + se;
      const Me = qe();
      for (; ge.pos < xe; ) {
        const Ye = ge.uint32();
        switch (Ye >>> 3) {
          case 1:
            Me.properties.push(ge.string());
            break;
          case 2:
            Me.durationMs = ge.int32();
            break;
          case 4:
            Me.delayMs = ge.int32();
            break;
          case 5:
            Me.easingMode = ge.string();
            break;
          default:
            ge.skipType(Ye & 7);
            break;
        }
      }
      return Me;
    },
    fromJSON(x) {
      return {
        properties: Array.isArray(x == null ? void 0 : x.properties) ? x.properties.map((se) => String(se)) : [],
        durationMs: Ke(x.durationMs) ? Number(x.durationMs) : 0,
        delayMs: Ke(x.delayMs) ? Number(x.delayMs) : void 0,
        easingMode: Ke(x.easingMode) ? String(x.easingMode) : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.properties ? se.properties = x.properties.map((ge) => ge) : se.properties = [], x.durationMs !== void 0 && (se.durationMs = Math.round(x.durationMs)), x.delayMs !== void 0 && (se.delayMs = Math.round(x.delayMs)), x.easingMode !== void 0 && (se.easingMode = x.easingMode), se;
    },
    fromPartial(x) {
      var se, ge, xe, Me;
      const Ye = qe();
      return Ye.properties = ((se = x.properties) === null || se === void 0 ? void 0 : se.map((et) => et)) || [], Ye.durationMs = (ge = x.durationMs) !== null && ge !== void 0 ? ge : 0, Ye.delayMs = (xe = x.delayMs) !== null && xe !== void 0 ? xe : void 0, Ye.easingMode = (Me = x.easingMode) !== null && Me !== void 0 ? Me : void 0, Ye;
    }
  };
  function yt() {
    return {
      type: void 0,
      data: void 0,
      x: void 0,
      y: void 0,
      width: void 0,
      height: void 0,
      rotation: void 0,
      opacity: void 0,
      scale: void 0,
      hidden: void 0,
      children: void 0,
      parentId: void 0,
      metadata: void 0,
      requestMetadata: void 0,
      requestAnimation: []
    };
  }
  a.PartialLayer = {
    encode(x, se = _.Writer.create()) {
      x.type !== void 0 && se.uint32(10).string(x.type), x.data !== void 0 && k.Struct.encode(k.Struct.wrap(x.data), se.uint32(18).fork()).ldelim(), x.x !== void 0 && k.Value.encode(k.Value.wrap(x.x), se.uint32(26).fork()).ldelim(), x.y !== void 0 && k.Value.encode(k.Value.wrap(x.y), se.uint32(34).fork()).ldelim(), x.width !== void 0 && k.Value.encode(k.Value.wrap(x.width), se.uint32(42).fork()).ldelim(), x.height !== void 0 && k.Value.encode(k.Value.wrap(x.height), se.uint32(50).fork()).ldelim(), x.rotation !== void 0 && se.uint32(57).double(x.rotation), x.opacity !== void 0 && se.uint32(65).double(x.opacity), x.scale !== void 0 && se.uint32(73).double(x.scale), x.hidden !== void 0 && se.uint32(80).bool(x.hidden), x.children !== void 0 && k.ListValue.encode(k.ListValue.wrap(x.children), se.uint32(98).fork()).ldelim(), x.parentId !== void 0 && se.uint32(106).string(x.parentId), x.metadata !== void 0 && k.Value.encode(k.Value.wrap(x.metadata), se.uint32(114).fork()).ldelim(), x.requestMetadata !== void 0 && k.Value.encode(k.Value.wrap(x.requestMetadata), se.uint32(802).fork()).ldelim();
      for (const ge of x.requestAnimation)
        a.LayerAnimation.encode(ge, se.uint32(826).fork()).ldelim();
      return se;
    },
    decode(x, se) {
      const ge = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? ge.len : ge.pos + se;
      const Me = yt();
      for (; ge.pos < xe; ) {
        const Ye = ge.uint32();
        switch (Ye >>> 3) {
          case 1:
            Me.type = ge.string();
            break;
          case 2:
            Me.data = k.Struct.unwrap(k.Struct.decode(ge, ge.uint32()));
            break;
          case 3:
            Me.x = k.Value.unwrap(k.Value.decode(ge, ge.uint32()));
            break;
          case 4:
            Me.y = k.Value.unwrap(k.Value.decode(ge, ge.uint32()));
            break;
          case 5:
            Me.width = k.Value.unwrap(k.Value.decode(ge, ge.uint32()));
            break;
          case 6:
            Me.height = k.Value.unwrap(k.Value.decode(ge, ge.uint32()));
            break;
          case 7:
            Me.rotation = ge.double();
            break;
          case 8:
            Me.opacity = ge.double();
            break;
          case 9:
            Me.scale = ge.double();
            break;
          case 10:
            Me.hidden = ge.bool();
            break;
          case 12:
            Me.children = k.ListValue.unwrap(k.ListValue.decode(ge, ge.uint32()));
            break;
          case 13:
            Me.parentId = ge.string();
            break;
          case 14:
            Me.metadata = k.Value.unwrap(k.Value.decode(ge, ge.uint32()));
            break;
          case 100:
            Me.requestMetadata = k.Value.unwrap(k.Value.decode(ge, ge.uint32()));
            break;
          case 103:
            Me.requestAnimation.push(a.LayerAnimation.decode(ge, ge.uint32()));
            break;
          default:
            ge.skipType(Ye & 7);
            break;
        }
      }
      return Me;
    },
    fromJSON(x) {
      return {
        type: Ke(x.type) ? String(x.type) : void 0,
        data: Ze(x.data) ? x.data : void 0,
        x: Ke(x == null ? void 0 : x.x) ? x.x : void 0,
        y: Ke(x == null ? void 0 : x.y) ? x.y : void 0,
        width: Ke(x == null ? void 0 : x.width) ? x.width : void 0,
        height: Ke(x == null ? void 0 : x.height) ? x.height : void 0,
        rotation: Ke(x.rotation) ? Number(x.rotation) : void 0,
        opacity: Ke(x.opacity) ? Number(x.opacity) : void 0,
        scale: Ke(x.scale) ? Number(x.scale) : void 0,
        hidden: Ke(x.hidden) ? !!x.hidden : void 0,
        children: Array.isArray(x.children) ? [...x.children] : void 0,
        parentId: Ke(x.parentId) ? String(x.parentId) : void 0,
        metadata: Ke(x == null ? void 0 : x.metadata) ? x.metadata : void 0,
        requestMetadata: Ke(x == null ? void 0 : x.requestMetadata) ? x.requestMetadata : void 0,
        requestAnimation: Array.isArray(x == null ? void 0 : x.requestAnimation) ? x.requestAnimation.map((se) => a.LayerAnimation.fromJSON(se)) : []
      };
    },
    toJSON(x) {
      const se = {};
      return x.type !== void 0 && (se.type = x.type), x.data !== void 0 && (se.data = x.data), x.x !== void 0 && (se.x = x.x), x.y !== void 0 && (se.y = x.y), x.width !== void 0 && (se.width = x.width), x.height !== void 0 && (se.height = x.height), x.rotation !== void 0 && (se.rotation = x.rotation), x.opacity !== void 0 && (se.opacity = x.opacity), x.scale !== void 0 && (se.scale = x.scale), x.hidden !== void 0 && (se.hidden = x.hidden), x.children !== void 0 && (se.children = x.children), x.parentId !== void 0 && (se.parentId = x.parentId), x.metadata !== void 0 && (se.metadata = x.metadata), x.requestMetadata !== void 0 && (se.requestMetadata = x.requestMetadata), x.requestAnimation ? se.requestAnimation = x.requestAnimation.map((ge) => ge ? a.LayerAnimation.toJSON(ge) : void 0) : se.requestAnimation = [], se;
    },
    fromPartial(x) {
      var se, ge, xe, Me, Ye, et, dt, St, tt, at, kt, rt, ut, wt, nt;
      const it = yt();
      return it.type = (se = x.type) !== null && se !== void 0 ? se : void 0, it.data = (ge = x.data) !== null && ge !== void 0 ? ge : void 0, it.x = (xe = x.x) !== null && xe !== void 0 ? xe : void 0, it.y = (Me = x.y) !== null && Me !== void 0 ? Me : void 0, it.width = (Ye = x.width) !== null && Ye !== void 0 ? Ye : void 0, it.height = (et = x.height) !== null && et !== void 0 ? et : void 0, it.rotation = (dt = x.rotation) !== null && dt !== void 0 ? dt : void 0, it.opacity = (St = x.opacity) !== null && St !== void 0 ? St : void 0, it.scale = (tt = x.scale) !== null && tt !== void 0 ? tt : void 0, it.hidden = (at = x.hidden) !== null && at !== void 0 ? at : void 0, it.children = (kt = x.children) !== null && kt !== void 0 ? kt : void 0, it.parentId = (rt = x.parentId) !== null && rt !== void 0 ? rt : void 0, it.metadata = (ut = x.metadata) !== null && ut !== void 0 ? ut : void 0, it.requestMetadata = (wt = x.requestMetadata) !== null && wt !== void 0 ? wt : void 0, it.requestAnimation = ((nt = x.requestAnimation) === null || nt === void 0 ? void 0 : nt.map((bt) => a.LayerAnimation.fromPartial(bt))) || [], it;
    }
  };
  function Xe() {
    return {
      id: "",
      type: void 0,
      data: void 0,
      x: void 0,
      y: void 0,
      width: void 0,
      height: void 0,
      rotation: void 0,
      opacity: void 0,
      scale: void 0,
      hidden: void 0,
      children: void 0,
      parentId: void 0,
      metadata: void 0,
      requestMetadata: void 0,
      requestAnimation: []
    };
  }
  a.PartialLayerWithID = {
    encode(x, se = _.Writer.create()) {
      x.id !== "" && se.uint32(8002).string(x.id), x.type !== void 0 && se.uint32(10).string(x.type), x.data !== void 0 && k.Struct.encode(k.Struct.wrap(x.data), se.uint32(18).fork()).ldelim(), x.x !== void 0 && k.Value.encode(k.Value.wrap(x.x), se.uint32(26).fork()).ldelim(), x.y !== void 0 && k.Value.encode(k.Value.wrap(x.y), se.uint32(34).fork()).ldelim(), x.width !== void 0 && k.Value.encode(k.Value.wrap(x.width), se.uint32(42).fork()).ldelim(), x.height !== void 0 && k.Value.encode(k.Value.wrap(x.height), se.uint32(50).fork()).ldelim(), x.rotation !== void 0 && se.uint32(57).double(x.rotation), x.opacity !== void 0 && se.uint32(65).double(x.opacity), x.scale !== void 0 && se.uint32(73).double(x.scale), x.hidden !== void 0 && se.uint32(80).bool(x.hidden), x.children !== void 0 && k.ListValue.encode(k.ListValue.wrap(x.children), se.uint32(98).fork()).ldelim(), x.parentId !== void 0 && se.uint32(106).string(x.parentId), x.metadata !== void 0 && k.Value.encode(k.Value.wrap(x.metadata), se.uint32(114).fork()).ldelim(), x.requestMetadata !== void 0 && k.Value.encode(k.Value.wrap(x.requestMetadata), se.uint32(802).fork()).ldelim();
      for (const ge of x.requestAnimation)
        a.LayerAnimation.encode(ge, se.uint32(826).fork()).ldelim();
      return se;
    },
    decode(x, se) {
      const ge = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? ge.len : ge.pos + se;
      const Me = Xe();
      for (; ge.pos < xe; ) {
        const Ye = ge.uint32();
        switch (Ye >>> 3) {
          case 1e3:
            Me.id = ge.string();
            break;
          case 1:
            Me.type = ge.string();
            break;
          case 2:
            Me.data = k.Struct.unwrap(k.Struct.decode(ge, ge.uint32()));
            break;
          case 3:
            Me.x = k.Value.unwrap(k.Value.decode(ge, ge.uint32()));
            break;
          case 4:
            Me.y = k.Value.unwrap(k.Value.decode(ge, ge.uint32()));
            break;
          case 5:
            Me.width = k.Value.unwrap(k.Value.decode(ge, ge.uint32()));
            break;
          case 6:
            Me.height = k.Value.unwrap(k.Value.decode(ge, ge.uint32()));
            break;
          case 7:
            Me.rotation = ge.double();
            break;
          case 8:
            Me.opacity = ge.double();
            break;
          case 9:
            Me.scale = ge.double();
            break;
          case 10:
            Me.hidden = ge.bool();
            break;
          case 12:
            Me.children = k.ListValue.unwrap(k.ListValue.decode(ge, ge.uint32()));
            break;
          case 13:
            Me.parentId = ge.string();
            break;
          case 14:
            Me.metadata = k.Value.unwrap(k.Value.decode(ge, ge.uint32()));
            break;
          case 100:
            Me.requestMetadata = k.Value.unwrap(k.Value.decode(ge, ge.uint32()));
            break;
          case 103:
            Me.requestAnimation.push(a.LayerAnimation.decode(ge, ge.uint32()));
            break;
          default:
            ge.skipType(Ye & 7);
            break;
        }
      }
      return Me;
    },
    fromJSON(x) {
      return {
        id: Ke(x.id) ? String(x.id) : "",
        type: Ke(x.type) ? String(x.type) : void 0,
        data: Ze(x.data) ? x.data : void 0,
        x: Ke(x == null ? void 0 : x.x) ? x.x : void 0,
        y: Ke(x == null ? void 0 : x.y) ? x.y : void 0,
        width: Ke(x == null ? void 0 : x.width) ? x.width : void 0,
        height: Ke(x == null ? void 0 : x.height) ? x.height : void 0,
        rotation: Ke(x.rotation) ? Number(x.rotation) : void 0,
        opacity: Ke(x.opacity) ? Number(x.opacity) : void 0,
        scale: Ke(x.scale) ? Number(x.scale) : void 0,
        hidden: Ke(x.hidden) ? !!x.hidden : void 0,
        children: Array.isArray(x.children) ? [...x.children] : void 0,
        parentId: Ke(x.parentId) ? String(x.parentId) : void 0,
        metadata: Ke(x == null ? void 0 : x.metadata) ? x.metadata : void 0,
        requestMetadata: Ke(x == null ? void 0 : x.requestMetadata) ? x.requestMetadata : void 0,
        requestAnimation: Array.isArray(x == null ? void 0 : x.requestAnimation) ? x.requestAnimation.map((se) => a.LayerAnimation.fromJSON(se)) : []
      };
    },
    toJSON(x) {
      const se = {};
      return x.id !== void 0 && (se.id = x.id), x.type !== void 0 && (se.type = x.type), x.data !== void 0 && (se.data = x.data), x.x !== void 0 && (se.x = x.x), x.y !== void 0 && (se.y = x.y), x.width !== void 0 && (se.width = x.width), x.height !== void 0 && (se.height = x.height), x.rotation !== void 0 && (se.rotation = x.rotation), x.opacity !== void 0 && (se.opacity = x.opacity), x.scale !== void 0 && (se.scale = x.scale), x.hidden !== void 0 && (se.hidden = x.hidden), x.children !== void 0 && (se.children = x.children), x.parentId !== void 0 && (se.parentId = x.parentId), x.metadata !== void 0 && (se.metadata = x.metadata), x.requestMetadata !== void 0 && (se.requestMetadata = x.requestMetadata), x.requestAnimation ? se.requestAnimation = x.requestAnimation.map((ge) => ge ? a.LayerAnimation.toJSON(ge) : void 0) : se.requestAnimation = [], se;
    },
    fromPartial(x) {
      var se, ge, xe, Me, Ye, et, dt, St, tt, at, kt, rt, ut, wt, nt, it;
      const bt = Xe();
      return bt.id = (se = x.id) !== null && se !== void 0 ? se : "", bt.type = (ge = x.type) !== null && ge !== void 0 ? ge : void 0, bt.data = (xe = x.data) !== null && xe !== void 0 ? xe : void 0, bt.x = (Me = x.x) !== null && Me !== void 0 ? Me : void 0, bt.y = (Ye = x.y) !== null && Ye !== void 0 ? Ye : void 0, bt.width = (et = x.width) !== null && et !== void 0 ? et : void 0, bt.height = (dt = x.height) !== null && dt !== void 0 ? dt : void 0, bt.rotation = (St = x.rotation) !== null && St !== void 0 ? St : void 0, bt.opacity = (tt = x.opacity) !== null && tt !== void 0 ? tt : void 0, bt.scale = (at = x.scale) !== null && at !== void 0 ? at : void 0, bt.hidden = (kt = x.hidden) !== null && kt !== void 0 ? kt : void 0, bt.children = (rt = x.children) !== null && rt !== void 0 ? rt : void 0, bt.parentId = (ut = x.parentId) !== null && ut !== void 0 ? ut : void 0, bt.metadata = (wt = x.metadata) !== null && wt !== void 0 ? wt : void 0, bt.requestMetadata = (nt = x.requestMetadata) !== null && nt !== void 0 ? nt : void 0, bt.requestAnimation = ((it = x.requestAnimation) === null || it === void 0 ? void 0 : it.map((ot) => a.LayerAnimation.fromPartial(ot))) || [], bt;
    }
  };
  function Ge() {
    return { layoutId: "" };
  }
  a.ListLayersRequest = {
    encode(x, se = _.Writer.create()) {
      return x.layoutId !== "" && se.uint32(10).string(x.layoutId), se;
    },
    decode(x, se) {
      const ge = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? ge.len : ge.pos + se;
      const Me = Ge();
      for (; ge.pos < xe; ) {
        const Ye = ge.uint32();
        switch (Ye >>> 3) {
          case 1:
            Me.layoutId = ge.string();
            break;
          default:
            ge.skipType(Ye & 7);
            break;
        }
      }
      return Me;
    },
    fromJSON(x) {
      return {
        layoutId: Ke(x.layoutId) ? String(x.layoutId) : ""
      };
    },
    toJSON(x) {
      const se = {};
      return x.layoutId !== void 0 && (se.layoutId = x.layoutId), se;
    },
    fromPartial(x) {
      var se;
      const ge = Ge();
      return ge.layoutId = (se = x.layoutId) !== null && se !== void 0 ? se : "", ge;
    }
  };
  function H() {
    return { layers: [] };
  }
  a.ListLayersResponse = {
    encode(x, se = _.Writer.create()) {
      for (const ge of x.layers)
        a.Layer.encode(ge, se.uint32(10).fork()).ldelim();
      return se;
    },
    decode(x, se) {
      const ge = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? ge.len : ge.pos + se;
      const Me = H();
      for (; ge.pos < xe; ) {
        const Ye = ge.uint32();
        switch (Ye >>> 3) {
          case 1:
            Me.layers.push(a.Layer.decode(ge, ge.uint32()));
            break;
          default:
            ge.skipType(Ye & 7);
            break;
        }
      }
      return Me;
    },
    fromJSON(x) {
      return {
        layers: Array.isArray(x == null ? void 0 : x.layers) ? x.layers.map((se) => a.Layer.fromJSON(se)) : []
      };
    },
    toJSON(x) {
      const se = {};
      return x.layers ? se.layers = x.layers.map((ge) => ge ? a.Layer.toJSON(ge) : void 0) : se.layers = [], se;
    },
    fromPartial(x) {
      var se;
      const ge = H();
      return ge.layers = ((se = x.layers) === null || se === void 0 ? void 0 : se.map((xe) => a.Layer.fromPartial(xe))) || [], ge;
    }
  };
  function ye() {
    return { layoutId: "", layer: void 0 };
  }
  a.CreateLayerRequest = {
    encode(x, se = _.Writer.create()) {
      return x.layoutId !== "" && se.uint32(10).string(x.layoutId), x.layer !== void 0 && a.PartialLayer.encode(x.layer, se.uint32(18).fork()).ldelim(), se;
    },
    decode(x, se) {
      const ge = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? ge.len : ge.pos + se;
      const Me = ye();
      for (; ge.pos < xe; ) {
        const Ye = ge.uint32();
        switch (Ye >>> 3) {
          case 1:
            Me.layoutId = ge.string();
            break;
          case 2:
            Me.layer = a.PartialLayer.decode(ge, ge.uint32());
            break;
          default:
            ge.skipType(Ye & 7);
            break;
        }
      }
      return Me;
    },
    fromJSON(x) {
      return {
        layoutId: Ke(x.layoutId) ? String(x.layoutId) : "",
        layer: Ke(x.layer) ? a.PartialLayer.fromJSON(x.layer) : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.layoutId !== void 0 && (se.layoutId = x.layoutId), x.layer !== void 0 && (se.layer = x.layer ? a.PartialLayer.toJSON(x.layer) : void 0), se;
    },
    fromPartial(x) {
      var se;
      const ge = ye();
      return ge.layoutId = (se = x.layoutId) !== null && se !== void 0 ? se : "", ge.layer = x.layer !== void 0 && x.layer !== null ? a.PartialLayer.fromPartial(x.layer) : void 0, ge;
    }
  };
  function Ee() {
    return { layoutId: "", layerId: "" };
  }
  a.GetLayerRequest = {
    encode(x, se = _.Writer.create()) {
      return x.layoutId !== "" && se.uint32(10).string(x.layoutId), x.layerId !== "" && se.uint32(18).string(x.layerId), se;
    },
    decode(x, se) {
      const ge = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? ge.len : ge.pos + se;
      const Me = Ee();
      for (; ge.pos < xe; ) {
        const Ye = ge.uint32();
        switch (Ye >>> 3) {
          case 1:
            Me.layoutId = ge.string();
            break;
          case 2:
            Me.layerId = ge.string();
            break;
          default:
            ge.skipType(Ye & 7);
            break;
        }
      }
      return Me;
    },
    fromJSON(x) {
      return {
        layoutId: Ke(x.layoutId) ? String(x.layoutId) : "",
        layerId: Ke(x.layerId) ? String(x.layerId) : ""
      };
    },
    toJSON(x) {
      const se = {};
      return x.layoutId !== void 0 && (se.layoutId = x.layoutId), x.layerId !== void 0 && (se.layerId = x.layerId), se;
    },
    fromPartial(x) {
      var se, ge;
      const xe = Ee();
      return xe.layoutId = (se = x.layoutId) !== null && se !== void 0 ? se : "", xe.layerId = (ge = x.layerId) !== null && ge !== void 0 ? ge : "", xe;
    }
  };
  function We() {
    return { layoutId: "", layerId: "", layer: void 0 };
  }
  a.UpdateLayerRequest = {
    encode(x, se = _.Writer.create()) {
      return x.layoutId !== "" && se.uint32(10).string(x.layoutId), x.layerId !== "" && se.uint32(18).string(x.layerId), x.layer !== void 0 && a.PartialLayer.encode(x.layer, se.uint32(26).fork()).ldelim(), se;
    },
    decode(x, se) {
      const ge = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? ge.len : ge.pos + se;
      const Me = We();
      for (; ge.pos < xe; ) {
        const Ye = ge.uint32();
        switch (Ye >>> 3) {
          case 1:
            Me.layoutId = ge.string();
            break;
          case 2:
            Me.layerId = ge.string();
            break;
          case 3:
            Me.layer = a.PartialLayer.decode(ge, ge.uint32());
            break;
          default:
            ge.skipType(Ye & 7);
            break;
        }
      }
      return Me;
    },
    fromJSON(x) {
      return {
        layoutId: Ke(x.layoutId) ? String(x.layoutId) : "",
        layerId: Ke(x.layerId) ? String(x.layerId) : "",
        layer: Ke(x.layer) ? a.PartialLayer.fromJSON(x.layer) : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.layoutId !== void 0 && (se.layoutId = x.layoutId), x.layerId !== void 0 && (se.layerId = x.layerId), x.layer !== void 0 && (se.layer = x.layer ? a.PartialLayer.toJSON(x.layer) : void 0), se;
    },
    fromPartial(x) {
      var se, ge;
      const xe = We();
      return xe.layoutId = (se = x.layoutId) !== null && se !== void 0 ? se : "", xe.layerId = (ge = x.layerId) !== null && ge !== void 0 ? ge : "", xe.layer = x.layer !== void 0 && x.layer !== null ? a.PartialLayer.fromPartial(x.layer) : void 0, xe;
    }
  };
  function we() {
    return { requestMetadata: void 0 };
  }
  a.DeleteLayerPayload = {
    encode(x, se = _.Writer.create()) {
      return x.requestMetadata !== void 0 && k.Value.encode(k.Value.wrap(x.requestMetadata), se.uint32(802).fork()).ldelim(), se;
    },
    decode(x, se) {
      const ge = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? ge.len : ge.pos + se;
      const Me = we();
      for (; ge.pos < xe; ) {
        const Ye = ge.uint32();
        switch (Ye >>> 3) {
          case 100:
            Me.requestMetadata = k.Value.unwrap(k.Value.decode(ge, ge.uint32()));
            break;
          default:
            ge.skipType(Ye & 7);
            break;
        }
      }
      return Me;
    },
    fromJSON(x) {
      return {
        requestMetadata: Ke(x == null ? void 0 : x.requestMetadata) ? x.requestMetadata : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.requestMetadata !== void 0 && (se.requestMetadata = x.requestMetadata), se;
    },
    fromPartial(x) {
      var se;
      const ge = we();
      return ge.requestMetadata = (se = x.requestMetadata) !== null && se !== void 0 ? se : void 0, ge;
    }
  };
  function V() {
    return { id: "", requestMetadata: void 0 };
  }
  a.BatchDeleteLayerRequest = {
    encode(x, se = _.Writer.create()) {
      return x.id !== "" && se.uint32(10).string(x.id), x.requestMetadata !== void 0 && k.Value.encode(k.Value.wrap(x.requestMetadata), se.uint32(802).fork()).ldelim(), se;
    },
    decode(x, se) {
      const ge = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? ge.len : ge.pos + se;
      const Me = V();
      for (; ge.pos < xe; ) {
        const Ye = ge.uint32();
        switch (Ye >>> 3) {
          case 1:
            Me.id = ge.string();
            break;
          case 100:
            Me.requestMetadata = k.Value.unwrap(k.Value.decode(ge, ge.uint32()));
            break;
          default:
            ge.skipType(Ye & 7);
            break;
        }
      }
      return Me;
    },
    fromJSON(x) {
      return {
        id: Ke(x.id) ? String(x.id) : "",
        requestMetadata: Ke(x == null ? void 0 : x.requestMetadata) ? x.requestMetadata : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.id !== void 0 && (se.id = x.id), x.requestMetadata !== void 0 && (se.requestMetadata = x.requestMetadata), se;
    },
    fromPartial(x) {
      var se, ge;
      const xe = V();
      return xe.id = (se = x.id) !== null && se !== void 0 ? se : "", xe.requestMetadata = (ge = x.requestMetadata) !== null && ge !== void 0 ? ge : void 0, xe;
    }
  };
  function _e() {
    return {
      layoutId: "",
      layers: [],
      requestMetadata: void 0,
      requestAnimationMode: void 0
    };
  }
  a.BatchLayerRequest = {
    encode(x, se = _.Writer.create()) {
      x.layoutId !== "" && se.uint32(10).string(x.layoutId);
      for (const ge of x.layers)
        a.BatchLayerRequest_BatchItem.encode(ge, se.uint32(18).fork()).ldelim();
      return x.requestMetadata !== void 0 && k.Value.encode(k.Value.wrap(x.requestMetadata), se.uint32(802).fork()).ldelim(), x.requestAnimationMode !== void 0 && se.uint32(808).int32(ae(x.requestAnimationMode)), se;
    },
    decode(x, se) {
      const ge = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? ge.len : ge.pos + se;
      const Me = _e();
      for (; ge.pos < xe; ) {
        const Ye = ge.uint32();
        switch (Ye >>> 3) {
          case 1:
            Me.layoutId = ge.string();
            break;
          case 2:
            Me.layers.push(a.BatchLayerRequest_BatchItem.decode(ge, ge.uint32()));
            break;
          case 100:
            Me.requestMetadata = k.Value.unwrap(k.Value.decode(ge, ge.uint32()));
            break;
          case 101:
            Me.requestAnimationMode = ee(ge.int32());
            break;
          default:
            ge.skipType(Ye & 7);
            break;
        }
      }
      return Me;
    },
    fromJSON(x) {
      return {
        layoutId: Ke(x.layoutId) ? String(x.layoutId) : "",
        layers: Array.isArray(x == null ? void 0 : x.layers) ? x.layers.map((se) => a.BatchLayerRequest_BatchItem.fromJSON(se)) : [],
        requestMetadata: Ke(x == null ? void 0 : x.requestMetadata) ? x.requestMetadata : void 0,
        requestAnimationMode: Ke(x.requestAnimationMode) ? ee(x.requestAnimationMode) : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.layoutId !== void 0 && (se.layoutId = x.layoutId), x.layers ? se.layers = x.layers.map((ge) => ge ? a.BatchLayerRequest_BatchItem.toJSON(ge) : void 0) : se.layers = [], x.requestMetadata !== void 0 && (se.requestMetadata = x.requestMetadata), x.requestAnimationMode !== void 0 && (se.requestAnimationMode = x.requestAnimationMode !== void 0 ? X(x.requestAnimationMode) : void 0), se;
    },
    fromPartial(x) {
      var se, ge, xe, Me;
      const Ye = _e();
      return Ye.layoutId = (se = x.layoutId) !== null && se !== void 0 ? se : "", Ye.layers = ((ge = x.layers) === null || ge === void 0 ? void 0 : ge.map((et) => a.BatchLayerRequest_BatchItem.fromPartial(et))) || [], Ye.requestMetadata = (xe = x.requestMetadata) !== null && xe !== void 0 ? xe : void 0, Ye.requestAnimationMode = (Me = x.requestAnimationMode) !== null && Me !== void 0 ? Me : void 0, Ye;
    }
  };
  function ue() {
    return { create: void 0, update: void 0, delete: void 0 };
  }
  a.BatchLayerRequest_BatchItem = {
    encode(x, se = _.Writer.create()) {
      return x.create !== void 0 && a.PartialLayer.encode(x.create, se.uint32(10).fork()).ldelim(), x.update !== void 0 && a.PartialLayerWithID.encode(x.update, se.uint32(18).fork()).ldelim(), x.delete !== void 0 && a.BatchDeleteLayerRequest.encode(x.delete, se.uint32(26).fork()).ldelim(), se;
    },
    decode(x, se) {
      const ge = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? ge.len : ge.pos + se;
      const Me = ue();
      for (; ge.pos < xe; ) {
        const Ye = ge.uint32();
        switch (Ye >>> 3) {
          case 1:
            Me.create = a.PartialLayer.decode(ge, ge.uint32());
            break;
          case 2:
            Me.update = a.PartialLayerWithID.decode(ge, ge.uint32());
            break;
          case 3:
            Me.delete = a.BatchDeleteLayerRequest.decode(ge, ge.uint32());
            break;
          default:
            ge.skipType(Ye & 7);
            break;
        }
      }
      return Me;
    },
    fromJSON(x) {
      return {
        create: Ke(x.create) ? a.PartialLayer.fromJSON(x.create) : void 0,
        update: Ke(x.update) ? a.PartialLayerWithID.fromJSON(x.update) : void 0,
        delete: Ke(x.delete) ? a.BatchDeleteLayerRequest.fromJSON(x.delete) : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.create !== void 0 && (se.create = x.create ? a.PartialLayer.toJSON(x.create) : void 0), x.update !== void 0 && (se.update = x.update ? a.PartialLayerWithID.toJSON(x.update) : void 0), x.delete !== void 0 && (se.delete = x.delete ? a.BatchDeleteLayerRequest.toJSON(x.delete) : void 0), se;
    },
    fromPartial(x) {
      const se = ue();
      return se.create = x.create !== void 0 && x.create !== null ? a.PartialLayer.fromPartial(x.create) : void 0, se.update = x.update !== void 0 && x.update !== null ? a.PartialLayerWithID.fromPartial(x.update) : void 0, se.delete = x.delete !== void 0 && x.delete !== null ? a.BatchDeleteLayerRequest.fromPartial(x.delete) : void 0, se;
    }
  };
  function ce() {
    return { create: void 0, update: void 0, delete: void 0 };
  }
  a.LayoutEvent = {
    encode(x, se = _.Writer.create()) {
      return x.create !== void 0 && a.Layout.encode(x.create, se.uint32(10).fork()).ldelim(), x.update !== void 0 && a.Layout.encode(x.update, se.uint32(18).fork()).ldelim(), x.delete !== void 0 && a.DeleteLayoutResponse.encode(x.delete, se.uint32(26).fork()).ldelim(), se;
    },
    decode(x, se) {
      const ge = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? ge.len : ge.pos + se;
      const Me = ce();
      for (; ge.pos < xe; ) {
        const Ye = ge.uint32();
        switch (Ye >>> 3) {
          case 1:
            Me.create = a.Layout.decode(ge, ge.uint32());
            break;
          case 2:
            Me.update = a.Layout.decode(ge, ge.uint32());
            break;
          case 3:
            Me.delete = a.DeleteLayoutResponse.decode(ge, ge.uint32());
            break;
          default:
            ge.skipType(Ye & 7);
            break;
        }
      }
      return Me;
    },
    fromJSON(x) {
      return {
        create: Ke(x.create) ? a.Layout.fromJSON(x.create) : void 0,
        update: Ke(x.update) ? a.Layout.fromJSON(x.update) : void 0,
        delete: Ke(x.delete) ? a.DeleteLayoutResponse.fromJSON(x.delete) : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.create !== void 0 && (se.create = x.create ? a.Layout.toJSON(x.create) : void 0), x.update !== void 0 && (se.update = x.update ? a.Layout.toJSON(x.update) : void 0), x.delete !== void 0 && (se.delete = x.delete ? a.DeleteLayoutResponse.toJSON(x.delete) : void 0), se;
    },
    fromPartial(x) {
      const se = ce();
      return se.create = x.create !== void 0 && x.create !== null ? a.Layout.fromPartial(x.create) : void 0, se.update = x.update !== void 0 && x.update !== null ? a.Layout.fromPartial(x.update) : void 0, se.delete = x.delete !== void 0 && x.delete !== null ? a.DeleteLayoutResponse.fromPartial(x.delete) : void 0, se;
    }
  };
  function me() {
    return {
      create: void 0,
      update: void 0,
      delete: void 0,
      batch: void 0
    };
  }
  a.LayerEvent = {
    encode(x, se = _.Writer.create()) {
      return x.create !== void 0 && a.Layer.encode(x.create, se.uint32(10).fork()).ldelim(), x.update !== void 0 && a.Layer.encode(x.update, se.uint32(18).fork()).ldelim(), x.delete !== void 0 && a.DeleteLayerResponse.encode(x.delete, se.uint32(26).fork()).ldelim(), x.batch !== void 0 && a.BatchLayerResponse.encode(x.batch, se.uint32(34).fork()).ldelim(), se;
    },
    decode(x, se) {
      const ge = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? ge.len : ge.pos + se;
      const Me = me();
      for (; ge.pos < xe; ) {
        const Ye = ge.uint32();
        switch (Ye >>> 3) {
          case 1:
            Me.create = a.Layer.decode(ge, ge.uint32());
            break;
          case 2:
            Me.update = a.Layer.decode(ge, ge.uint32());
            break;
          case 3:
            Me.delete = a.DeleteLayerResponse.decode(ge, ge.uint32());
            break;
          case 4:
            Me.batch = a.BatchLayerResponse.decode(ge, ge.uint32());
            break;
          default:
            ge.skipType(Ye & 7);
            break;
        }
      }
      return Me;
    },
    fromJSON(x) {
      return {
        create: Ke(x.create) ? a.Layer.fromJSON(x.create) : void 0,
        update: Ke(x.update) ? a.Layer.fromJSON(x.update) : void 0,
        delete: Ke(x.delete) ? a.DeleteLayerResponse.fromJSON(x.delete) : void 0,
        batch: Ke(x.batch) ? a.BatchLayerResponse.fromJSON(x.batch) : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.create !== void 0 && (se.create = x.create ? a.Layer.toJSON(x.create) : void 0), x.update !== void 0 && (se.update = x.update ? a.Layer.toJSON(x.update) : void 0), x.delete !== void 0 && (se.delete = x.delete ? a.DeleteLayerResponse.toJSON(x.delete) : void 0), x.batch !== void 0 && (se.batch = x.batch ? a.BatchLayerResponse.toJSON(x.batch) : void 0), se;
    },
    fromPartial(x) {
      const se = me();
      return se.create = x.create !== void 0 && x.create !== null ? a.Layer.fromPartial(x.create) : void 0, se.update = x.update !== void 0 && x.update !== null ? a.Layer.fromPartial(x.update) : void 0, se.delete = x.delete !== void 0 && x.delete !== null ? a.DeleteLayerResponse.fromPartial(x.delete) : void 0, se.batch = x.batch !== void 0 && x.batch !== null ? a.BatchLayerResponse.fromPartial(x.batch) : void 0, se;
    }
  };
  function Ce() {
    return { layout: void 0, layer: void 0 };
  }
  a.Event = {
    encode(x, se = _.Writer.create()) {
      return x.layout !== void 0 && a.LayoutEvent.encode(x.layout, se.uint32(10).fork()).ldelim(), x.layer !== void 0 && a.LayerEvent.encode(x.layer, se.uint32(18).fork()).ldelim(), se;
    },
    decode(x, se) {
      const ge = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? ge.len : ge.pos + se;
      const Me = Ce();
      for (; ge.pos < xe; ) {
        const Ye = ge.uint32();
        switch (Ye >>> 3) {
          case 1:
            Me.layout = a.LayoutEvent.decode(ge, ge.uint32());
            break;
          case 2:
            Me.layer = a.LayerEvent.decode(ge, ge.uint32());
            break;
          default:
            ge.skipType(Ye & 7);
            break;
        }
      }
      return Me;
    },
    fromJSON(x) {
      return {
        layout: Ke(x.layout) ? a.LayoutEvent.fromJSON(x.layout) : void 0,
        layer: Ke(x.layer) ? a.LayerEvent.fromJSON(x.layer) : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.layout !== void 0 && (se.layout = x.layout ? a.LayoutEvent.toJSON(x.layout) : void 0), x.layer !== void 0 && (se.layer = x.layer ? a.LayerEvent.toJSON(x.layer) : void 0), se;
    },
    fromPartial(x) {
      const se = Ce();
      return se.layout = x.layout !== void 0 && x.layout !== null ? a.LayoutEvent.fromPartial(x.layout) : void 0, se.layer = x.layer !== void 0 && x.layer !== null ? a.LayerEvent.fromPartial(x.layer) : void 0, se;
    }
  };
  class Be {
    constructor(se) {
      this.rpc = se, this.ListLayers = this.ListLayers.bind(this), this.CreateLayer = this.CreateLayer.bind(this), this.GetLayer = this.GetLayer.bind(this), this.UpdateLayer = this.UpdateLayer.bind(this), this.DeleteLayer = this.DeleteLayer.bind(this), this.Batch = this.Batch.bind(this);
    }
    ListLayers(se) {
      const ge = a.ListLayersRequest.encode(se).finish();
      return this.rpc.request("apis.layout.v2.LayerService", "ListLayers", ge).then((Me) => a.ListLayersResponse.decode(new _.Reader(Me)));
    }
    CreateLayer(se) {
      const ge = a.CreateLayerRequest.encode(se).finish();
      return this.rpc.request("apis.layout.v2.LayerService", "CreateLayer", ge).then((Me) => a.Layer.decode(new _.Reader(Me)));
    }
    GetLayer(se) {
      const ge = a.GetLayerRequest.encode(se).finish();
      return this.rpc.request("apis.layout.v2.LayerService", "GetLayer", ge).then((Me) => a.Layer.decode(new _.Reader(Me)));
    }
    UpdateLayer(se) {
      const ge = a.UpdateLayerRequest.encode(se).finish();
      return this.rpc.request("apis.layout.v2.LayerService", "UpdateLayer", ge).then((Me) => a.Layer.decode(new _.Reader(Me)));
    }
    DeleteLayer(se) {
      const ge = a.DeleteLayerRequest.encode(se).finish();
      return this.rpc.request("apis.layout.v2.LayerService", "DeleteLayer", ge).then((Me) => a.DeleteLayerResponse.decode(new _.Reader(Me)));
    }
    Batch(se) {
      const ge = a.BatchLayerRequest.encode(se).finish();
      return this.rpc.request("apis.layout.v2.LayerService", "Batch", ge).then((Me) => a.BatchLayerResponse.decode(new _.Reader(Me)));
    }
  }
  a.LayerServiceClientImpl = Be, a.LayerServiceDefinition = {
    name: "LayerService",
    fullName: "apis.layout.v2.LayerService",
    methods: {
      /** List all layers */
      listLayers: {
        name: "ListLayers",
        requestType: a.ListLayersRequest,
        requestStream: !1,
        responseType: a.ListLayersResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Create a layer
       * buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
       * buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE
       */
      createLayer: {
        name: "CreateLayer",
        requestType: a.CreateLayerRequest,
        requestStream: !1,
        responseType: a.Layer,
        responseStream: !1,
        options: {}
      },
      /**
       * Get a single layer
       * buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
       * buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE
       */
      getLayer: {
        name: "GetLayer",
        requestType: a.GetLayerRequest,
        requestStream: !1,
        responseType: a.Layer,
        responseStream: !1,
        options: {}
      },
      /**
       * Update a layer
       * buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
       * buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE
       */
      updateLayer: {
        name: "UpdateLayer",
        requestType: a.UpdateLayerRequest,
        requestStream: !1,
        responseType: a.Layer,
        responseStream: !1,
        options: {}
      },
      /** Delete a layer */
      deleteLayer: {
        name: "DeleteLayer",
        requestType: a.DeleteLayerRequest,
        requestStream: !1,
        responseType: a.DeleteLayerResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Batch update
       * buf:lint:ignore RPC_REQUEST_STANDARD_NAME
       * buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
       */
      batch: {
        name: "Batch",
        requestType: a.BatchLayerRequest,
        requestStream: !1,
        responseType: a.BatchLayerResponse,
        responseStream: !1,
        options: {}
      }
    }
  };
  class ze {
    constructor(se) {
      this.rpc = se, this.ListLayouts = this.ListLayouts.bind(this), this.CreateLayout = this.CreateLayout.bind(this), this.GetLayout = this.GetLayout.bind(this), this.UpdateLayout = this.UpdateLayout.bind(this), this.DeleteLayout = this.DeleteLayout.bind(this);
    }
    ListLayouts(se) {
      const ge = a.ListLayoutsRequest.encode(se).finish();
      return this.rpc.request("apis.layout.v2.LayoutService", "ListLayouts", ge).then((Me) => a.ListLayoutsResponse.decode(new _.Reader(Me)));
    }
    CreateLayout(se) {
      const ge = a.CreateLayoutRequest.encode(se).finish();
      return this.rpc.request("apis.layout.v2.LayoutService", "CreateLayout", ge).then((Me) => a.Layout.decode(new _.Reader(Me)));
    }
    GetLayout(se) {
      const ge = a.GetLayoutRequest.encode(se).finish();
      return this.rpc.request("apis.layout.v2.LayoutService", "GetLayout", ge).then((Me) => a.Layout.decode(new _.Reader(Me)));
    }
    UpdateLayout(se) {
      const ge = a.UpdateLayoutRequest.encode(se).finish();
      return this.rpc.request("apis.layout.v2.LayoutService", "UpdateLayout", ge).then((Me) => a.Layout.decode(new _.Reader(Me)));
    }
    DeleteLayout(se) {
      const ge = a.DeleteLayoutRequest.encode(se).finish();
      return this.rpc.request("apis.layout.v2.LayoutService", "DeleteLayout", ge).then((Me) => a.DeleteLayoutResponse.decode(new _.Reader(Me)));
    }
  }
  a.LayoutServiceClientImpl = ze, a.LayoutServiceDefinition = {
    name: "LayoutService",
    fullName: "apis.layout.v2.LayoutService",
    methods: {
      /** Get all layouts owned by the user. */
      listLayouts: {
        name: "ListLayouts",
        requestType: a.ListLayoutsRequest,
        requestStream: !1,
        responseType: a.ListLayoutsResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Create a new layout
       * buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
       * buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE
       */
      createLayout: {
        name: "CreateLayout",
        requestType: a.CreateLayoutRequest,
        requestStream: !1,
        responseType: a.Layout,
        responseStream: !1,
        options: {}
      },
      /**
       * Get a layout
       * buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
       * buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE
       */
      getLayout: {
        name: "GetLayout",
        requestType: a.GetLayoutRequest,
        requestStream: !1,
        responseType: a.Layout,
        responseStream: !1,
        options: {}
      },
      /**
       * Update a layout
       * buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
       * buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE
       */
      updateLayout: {
        name: "UpdateLayout",
        requestType: a.UpdateLayoutRequest,
        requestStream: !1,
        responseType: a.Layout,
        responseStream: !1,
        options: {}
      },
      /** Delete a layout */
      deleteLayout: {
        name: "DeleteLayout",
        requestType: a.DeleteLayoutRequest,
        requestStream: !1,
        responseType: a.DeleteLayoutResponse,
        responseStream: !1,
        options: {}
      }
    }
  };
  var Je = (() => {
    if (typeof Je < "u")
      return Je;
    if (typeof self < "u")
      return self;
    if (typeof window < "u")
      return window;
    if (typeof commonjsGlobal$1 < "u")
      return commonjsGlobal$1;
    throw "Unable to locate global object";
  })();
  _.util.Long !== p.default && (_.util.Long = p.default, _.configure());
  function Ze(x) {
    return typeof x == "object" && x !== null;
  }
  function Ke(x) {
    return x != null;
  }
})(api$4);
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(v, p, _, k) {
    k === void 0 && (k = _), Object.defineProperty(v, k, { enumerable: !0, get: function() {
      return p[_];
    } });
  } : function(v, p, _, k) {
    k === void 0 && (k = _), v[k] = p[_];
  }), c = commonjsGlobal$1 && commonjsGlobal$1.__exportStar || function(v, p) {
    for (var _ in v)
      _ !== "default" && !p.hasOwnProperty(_) && u(p, v, _);
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.layoutApiEventMap = void 0;
  const l = api$4;
  c(api$4, a), a.layoutApiEventMap = {
    [l.EventType.EVENT_TYPE_LAYOUT]: "layout",
    [l.EventType.EVENT_TYPE_LAYER]: "layer",
    [l.EventType.EVENT_TYPE_UNSPECIFIED]: "unspecified"
  };
})(dist$2);
var api$3 = {}, browser$f = !1;
const __viteBrowserExternal = {}, __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" })), require$$3 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
var logger = {};
class EnhancedMap extends Map {
  /**
   * If key has a mapping already returns the currently associated value. If
   * there is no mapping, calls the computer which must return a value V.
   * The value is then stored for given key and returned.
   * @param key Key
   * @param computer Computer which is called only if key has no mapping yet.
   * @return Existing value if the key already existed, or the newly computed value.
   */
  computeIfAbsent(u, c) {
    if (this.has(u))
      return this.get(u);
    const l = c(u);
    return this.set(u, l), l;
  }
  /**
   * If the key exists already calls given computer, if the key does not exist
   * this method does nothing.
   *
   * The computer is called with current key and current value associated. The
   * computer can return a (new) value V or undefined. When undefined is returned
   * the key is removed from this map, when a V is returned the key is updated
   * with the new value V.
   * @param key Key
   * @param computer Computer which is called only if the key has a mapping already
   * @return Undefined if the key has no mapping, otherwise the value returned from computer
   */
  computeIfPresent(u, c) {
    const l = this.get(u);
    if (l === void 0)
      return;
    const v = c(u, l);
    return v !== void 0 ? this.set(u, v) : this.delete(u), v;
  }
  /**
   * Computes a value for given key, the computer can return a value V (in which case the map
   * will set the value for given key), if it returns undefined the mapping for key K will be
   * removed.
   * @param key Key to compute
   * @param computer Computer which is called, note that the currentValue argument contains the existing
   *                 value or is undefined when no mapping exists for the key.
   * @return The newly computed value
   */
  compute(u, c) {
    const l = this.get(u), v = c(u, l);
    return v ? this.set(u, v) : this.delete(u), v;
  }
}
var InternalLogLevel;
(function(a) {
  a[a.Trace = 0] = "Trace", a[a.Debug = 1] = "Debug", a[a.Info = 2] = "Info", a[a.Warn = 3] = "Warn", a[a.Error = 4] = "Error";
})(InternalLogLevel || (InternalLogLevel = {}));
function getInternalLogger(a) {
  return provider.getLogger(a);
}
const INTERNAL_LOGGING_SETTINGS = {
  /**
   * Changes the log level for the internal logging (for all new and existing loggers)
   * @param level New log level
   */
  setInternalLogLevel: (a) => provider.changeLogLevel(a),
  /**
   * Changes where messages are written to for all new and existing loggers),
   * by default they are written to the console.
   * @param fnOutput Function to write messages to
   */
  setOutput: (a) => provider.changeOutput(a),
  /**
   * Resets the log level and output back to defaults (level to error and writing to console)
   * for all new and existing loggers.
   */
  reset: () => provider.reset()
};
class InternalLoggerImpl {
  constructor(u, c, l) {
    this._name = u, this._level = c, this._fnOutput = l;
  }
  trace(u) {
    this.log(InternalLogLevel.Trace, u);
  }
  debug(u) {
    this.log(InternalLogLevel.Debug, u);
  }
  error(u, c) {
    this.log(InternalLogLevel.Error, u, c);
  }
  info(u) {
    this.log(InternalLogLevel.Info, u);
  }
  warn(u, c) {
    this.log(InternalLogLevel.Warn, u, c);
  }
  setLevel(u) {
    this._level = u;
  }
  setOutput(u) {
    this._fnOutput = u;
  }
  log(u, c, l) {
    this._level > u || this._fnOutput(`${InternalLogLevel[this._level].toString()} <INTERNAL LOGGER> ${this._name} ${c()}${l ? `
` + l.stack : ""}`);
  }
}
class InternalProviderImpl {
  constructor() {
    this._loggers = new EnhancedMap(), this._logLevel = InternalLogLevel.Error, this._fnOutput = InternalProviderImpl.logConsole;
  }
  getLogger(u) {
    return this._loggers.computeIfAbsent(u, (c) => new InternalLoggerImpl(c, this._logLevel, this._fnOutput));
  }
  changeLogLevel(u) {
    this._logLevel = u, this._loggers.forEach((c) => c.setLevel(u));
  }
  changeOutput(u) {
    this._fnOutput = u, this._loggers.forEach((c) => c.setOutput(this._fnOutput));
  }
  reset() {
    this.changeLogLevel(InternalLogLevel.Error), this._fnOutput = InternalProviderImpl.logConsole, this._loggers.forEach((u) => u.setOutput(this._fnOutput));
  }
  static logConsole(u) {
    console && console.log && console.log(u);
  }
}
const provider = new InternalProviderImpl();
var InternalLogger = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  get InternalLogLevel() {
    return InternalLogLevel;
  },
  getInternalLogger,
  INTERNAL_LOGGING_SETTINGS
}), LogLevel$1;
(function(a) {
  a[a.Trace = 0] = "Trace", a[a.Debug = 1] = "Debug", a[a.Info = 2] = "Info", a[a.Warn = 3] = "Warn", a[a.Error = 4] = "Error", a[a.Fatal = 5] = "Fatal";
})(LogLevel$1 || (LogLevel$1 = {}));
(function(a) {
  function u(c) {
    switch (c.toLowerCase()) {
      case "trace":
        return a.Trace;
      case "debug":
        return a.Debug;
      case "info":
        return a.Info;
      case "warn":
        return a.Warn;
      case "error":
        return a.Error;
      case "fatal":
        return a.Fatal;
      default:
        return;
    }
  }
  a.toLogLevel = u;
})(LogLevel$1 || (LogLevel$1 = {}));
class CoreLoggerImpl {
  constructor(u) {
    this._runtime = u;
  }
  get id() {
    return this._runtime.id;
  }
  get logLevel() {
    return this._runtime.level;
  }
  get runtimeSettings() {
    return Object.assign({}, this._runtime);
  }
  set runtimeSettings(u) {
    this._runtime = u;
  }
  trace(u, ...c) {
    this.logMessage(LogLevel$1.Trace, u, c);
  }
  debug(u, ...c) {
    this.logMessage(LogLevel$1.Debug, u, c);
  }
  info(u, ...c) {
    this.logMessage(LogLevel$1.Info, u, c);
  }
  warn(u, ...c) {
    this.logMessage(LogLevel$1.Warn, u, c);
  }
  error(u, ...c) {
    this.logMessage(LogLevel$1.Error, u, c);
  }
  fatal(u, ...c) {
    this.logMessage(LogLevel$1.Fatal, u, c);
  }
  logMessage(u, c, l) {
    if (this._runtime.level > u)
      return;
    const v = Date.now(), p = typeof c == "string" ? c : c(), _ = CoreLoggerImpl.getErrorAndArgs(l);
    switch (this._runtime.channel.type) {
      case "RawLogChannel":
        this._runtime.channel.write({
          message: p,
          exception: _.error,
          args: _.args,
          timeInMillis: v,
          level: u,
          logNames: this._runtime.name
        }, this._runtime.argumentFormatter);
        return;
      case "LogChannel":
        this._runtime.channel.write(this.createLogMessage(p, u, _, v));
        break;
    }
  }
  formatArgValue(u) {
    try {
      return this._runtime.argumentFormatter(u);
    } catch {
      return `>>ARG CONVERT FAILED: '${u !== void 0 ? u.toString() : "undefined"}'<<`;
    }
  }
  createLogMessage(u, c, l, v) {
    let p;
    const _ = l.error, k = l.args;
    _ && (p = `${_.name}: ${_.message}`, _.stack && (p += `@
${_.stack}`));
    const O = this._runtime.dateFormatter(v);
    let D = LogLevel$1[c].toUpperCase();
    D.length < 5 && (D += " ");
    const F = typeof this._runtime.name == "string" ? this._runtime.name : this._runtime.name.join(", "), z = typeof k < "u" && k.length > 0 ? " [" + k.map((ee) => this.formatArgValue(ee)).join(", ") + "]" : "";
    return {
      message: O + " " + D + " [" + F + "] " + u + z,
      error: p
    };
  }
  static getErrorAndArgs(u) {
    if (u.length === 0)
      return {};
    let c, l;
    const v = u[0];
    if (v instanceof Error)
      return c = v, l = u.length > 1 ? u.slice(1) : void 0, { error: c, args: l };
    if (typeof v == "function") {
      const p = v();
      return p instanceof Error ? (c = p, l = u.length > 1 ? u.slice(1) : void 0, { error: c, args: l }) : u.length === 1 ? Array.isArray(p) ? { args: p.length > 0 ? p : void 0 } : { args: p } : Array.isArray(p) ? { args: [...p, ...u.slice(1)] } : { args: [p, ...u.slice(1)] };
    }
    return { args: u };
  }
}
function padStart(a, u, c = " ") {
  return padInternal(a, u, "start", c);
}
function padEnd(a, u, c = " ") {
  return padInternal(a, u, "end", c);
}
function maxLengthStringValueInArray(a) {
  return a.map((u) => u.length).reduce((u, c) => c > u ? c : u, 0);
}
function padInternal(a, u, c, l = " ") {
  if (u <= a.length)
    return a;
  if (l.length > 1)
    throw new Error(`Fill char must be one char exactly, it is: ${l.length}`);
  const v = u - a.length;
  let p = "";
  for (let _ = 0; _ < v; _++)
    p += l;
  return c === "start" ? p + a : a + p;
}
function formatArgument(a) {
  return a === void 0 ? "undefined" : JSON.stringify(a);
}
function formatDate(a) {
  const u = new Date(a), c = u.getFullYear(), l = padStart((u.getMonth() + 1).toString(), 2, "0"), v = padStart(u.getDate().toString(), 2, "0"), p = padStart(u.getHours().toString(), 2, "0"), _ = padStart(u.getMinutes().toString(), 2, "0"), k = padStart(u.getSeconds().toString(), 2, "0"), O = padStart(u.getMilliseconds().toString(), 2, "0");
  return `${c}-${l}-${v} ${p}:${_}:${k},${O}`;
}
class ConsoleLogChannel {
  constructor() {
    this.type = "LogChannel";
  }
  write(u) {
    console && console.log && console.log(u.message + (u.error ? `
${u.error}` : ""));
  }
}
var DefaultChannels;
(function(a) {
  function u() {
    return new ConsoleLogChannel();
  }
  a.createConsoleChannel = u;
})(DefaultChannels || (DefaultChannels = {}));
class LogProviderImpl {
  constructor(u, c) {
    this._log = getInternalLogger("core.impl.LogProviderImpl"), this._name = u, this._settings = c, this._loggers = new EnhancedMap(), this._idToKeyMap = new EnhancedMap(), this._globalRuntimeSettings = { level: c.level, channel: c.channel }, this._nextLoggerId = 1, this._log.trace(() => `Created LogProviderImpl with settings: ${JSON.stringify(this._settings)}`);
  }
  get runtimeSettings() {
    return Object.assign(Object.assign({}, this._settings), { level: this._globalRuntimeSettings.level, channel: this._globalRuntimeSettings.channel });
  }
  getLogger(u) {
    return this.getOrCreateLogger(u);
  }
  updateLoggerRuntime(u, c) {
    this._log.debug(() => `Updating logger ${u.id} runtime settings using: '${JSON.stringify(c)}'`);
    const l = this._idToKeyMap.get(u.id);
    return l === void 0 ? (this._log.warn(() => `Cannot update logger with id: ${u.id}, it was not found.`), !1) : (this._loggers.computeIfPresent(l, (v, p) => (p.runtimeSettings = LogProviderImpl.mergeRuntimeSettingsIntoLogRuntime(p.runtimeSettings, c), p)), !0);
  }
  updateRuntimeSettings(u) {
    this._log.debug(() => `Updating global runtime settings and updating existing loggers runtime settings using: '${JSON.stringify(u)}'`), this._globalRuntimeSettings = {
      /* It's unclear, but not checking explicitly on undefined here makes the test fail, it makes no sense as level is a number | undefined essentially. */
      level: u.level !== void 0 ? u.level : this._globalRuntimeSettings.level,
      channel: u.channel !== void 0 ? u.channel : this._globalRuntimeSettings.channel
    }, this._loggers.forEach((c) => c.runtimeSettings = LogProviderImpl.mergeRuntimeSettingsIntoLogRuntime(c.runtimeSettings, u));
  }
  /**
   * Removes all state and loggers, it reverts back to as it was after initial construction.
   */
  clear() {
    this._loggers.clear(), this._idToKeyMap.clear(), this._globalRuntimeSettings = Object.assign({}, this._settings), this._nextLoggerId = 1;
  }
  getOrCreateLogger(u) {
    const c = LogProviderImpl.createKey(u), l = this._loggers.computeIfAbsent(c, () => {
      const v = {
        level: this._globalRuntimeSettings.level,
        channel: this._globalRuntimeSettings.channel,
        id: this.nextLoggerId(),
        name: u,
        argumentFormatter: this._settings.argumentFormatter,
        dateFormatter: this._settings.dateFormatter
      };
      return new CoreLoggerImpl(v);
    });
    return this._idToKeyMap.computeIfAbsent(l.id, () => c), l;
  }
  nextLoggerId() {
    const u = this._name + "_" + this._nextLoggerId;
    return this._nextLoggerId++, u;
  }
  static mergeRuntimeSettingsIntoLogRuntime(u, c) {
    return Object.assign(Object.assign({}, u), {
      /* It's unclear, but not checking explicitly on undefined here makes the test fail, it makes no sense as level is a number | undefined essentially. */
      level: c.level !== void 0 ? c.level : u.level,
      channel: c.channel !== void 0 ? c.channel : u.channel
    });
  }
  static createKey(u) {
    return typeof u == "string" ? u : u.join(",");
  }
}
function createLogProvider(a, u) {
  return new LogProviderImpl(a, u);
}
var index$3 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  EnhancedMap,
  padStart,
  padEnd,
  maxLengthStringValueInArray
});
class CategoryImpl {
  constructor(u, c, l, v) {
    this._children = [], this._logger = u, this._name = c, this._parent = l, this._fnGetOrCreateChildCategory = v;
  }
  get name() {
    return this._name;
  }
  get parent() {
    return this._parent;
  }
  get path() {
    const u = [];
    let c = this;
    for (; c !== void 0; )
      u.push(c.name), c = c.parent;
    return u.reverse();
  }
  get children() {
    return [...this._children];
  }
  addChild(u) {
    if (u.parent !== this)
      throw new Error(`Cannot add child '${u.name}', expected parent '${this._name} but got ${u.parent ? u.parent.name : "undefined"}'`);
    this._children.push(u);
  }
  getChildCategory(u) {
    const c = this._children.find((l) => l.name === u);
    return c !== void 0 ? c : this._fnGetOrCreateChildCategory(u, this);
  }
  get id() {
    return this._logger.id;
  }
  get logLevel() {
    return this._logger.logLevel;
  }
  get runtimeSettings() {
    return this._logger.runtimeSettings;
  }
  get logger() {
    return this._logger;
  }
  trace(u, ...c) {
    this._logger.trace(u, ...c);
  }
  debug(u, ...c) {
    this._logger.debug(u, ...c);
  }
  info(u, ...c) {
    this._logger.info(u, ...c);
  }
  warn(u, ...c) {
    this._logger.warn(u, ...c);
  }
  error(u, ...c) {
    this._logger.error(u, ...c);
  }
  fatal(u, ...c) {
    this._logger.fatal(u, ...c);
  }
}
const CATEGORY_PATH_SEPARATOR = "#";
class CategoryProviderImpl {
  constructor(u, c) {
    this._name = u, this._initialConfig = c, this._categoryStorage = new CategoryStorage(u, c);
  }
  get name() {
    return this._name;
  }
  get config() {
    return this._initialConfig;
  }
  get runtimeConfig() {
    return this._categoryStorage.getCurrentRuntimeConfig();
  }
  getCategory(u, c) {
    return this._categoryStorage.getOrCreateCategory(u, c);
  }
  updateRuntimeSettingsCategory(u, c) {
    this._categoryStorage.updateRuntimeSettingsCategory(u, c);
  }
  updateRuntimeSettings(u) {
    this._categoryStorage.updateRuntimeSettings(u);
  }
  /** Returns all currently registered categories */
  getRegisteredCategories() {
    return this._categoryStorage.getRegisteredCategories();
  }
  /** Get a category by path, note that paths must be separated by #, e.g. root#child1#child1_1 */
  getCategoryByPath(u) {
    return this._categoryStorage.getCategoryByPath(u);
  }
}
class CategoryStorage {
  constructor(u, c) {
    this._categoriesById = /* @__PURE__ */ new Map(), this._categoriesByPath = /* @__PURE__ */ new Map(), this._categoryProviderName = u, this._allowSameCategoryName = c.allowSameCategoryName, this._logProvider = createLogProvider(u, Object.assign({}, c)), this.getOrCreateCategory = this.getOrCreateCategory.bind(this);
  }
  getOrCreateCategory(u, c) {
    if (u.indexOf(CATEGORY_PATH_SEPARATOR) !== -1)
      throw new Error(`Cannot create category '${u}', name cannot contain a '${CATEGORY_PATH_SEPARATOR}'.`);
    const l = c !== void 0 ? this.getParentCategory(c) : void 0;
    return l === void 0 ? this.getOrCreateRootCategory(u) : this.getOrCreateChildCategory(u, l);
  }
  updateRuntimeSettingsCategory(u, c) {
    if (!u.id.startsWith(this._categoryProviderName))
      throw new Error(`Category '${u.name}' with LogId '${u.id}' is from a different CategoryProvider, cannot mix categories between providers.`);
    const l = this._categoriesById.get(u.id);
    l !== void 0 && (this._logProvider.updateLoggerRuntime(l.logger, { level: c.level }), !(c.disableRecursion !== void 0 && c.disableRecursion) && l.children.forEach((v) => this.updateRuntimeSettingsCategory(v, c)));
  }
  updateRuntimeSettings(u) {
    this._logProvider.updateRuntimeSettings(u);
  }
  getCurrentRuntimeConfig() {
    return Object.assign(Object.assign({}, this._logProvider.runtimeSettings), { allowSameCategoryName: this._allowSameCategoryName });
  }
  /** Returns all currently registered categories */
  getRegisteredCategories() {
    return [...this._categoriesById.values()];
  }
  /** Get a category by path, note that paths must be separated by #, e.g. root#child1#child1_1 */
  getCategoryByPath(u) {
    return this._categoriesByPath.get(u);
  }
  getParentCategory(u) {
    let c;
    if (CategoryStorage.isLogId(u)) {
      if (c = this._categoriesById.get(u), c === void 0)
        throw new Error(`Parent category was not found by LogId '${u}'. Are you sure you passed in the correct argument?`);
    } else if (c = this._categoriesById.get(u.id), c === void 0)
      throw new Error(`Parent category '${u.name}' was not found by it's LogId '${u.id}'. Are you sure you passed in the correct parent category?`);
    return c;
  }
  getOrCreateRootCategory(u) {
    const c = this._categoriesByPath.get(u);
    if (c) {
      if (!this._allowSameCategoryName)
        throw new Error(`Category '${u} already exists, config flag allowSameCategoryName=false - therefore matching version 1 behavior (hence this Error)`);
      return c;
    }
    const l = this._logProvider.getLogger(u), v = new CategoryImpl(l, u, void 0, this.getOrCreateCategory);
    return this._categoriesById.set(v.id, v), this._categoriesByPath.set(u, v), v;
  }
  getOrCreateChildCategory(u, c) {
    if (!c.id.startsWith(this._categoryProviderName))
      throw new Error(`Parent category '${c.name}' with LogId '${c.id}' is from a different CategoryProvider, cannot mix categories between providers.`);
    const l = [...c.path, u].join(CATEGORY_PATH_SEPARATOR), v = this._categoriesByPath.get(l);
    if (v) {
      if (!this._allowSameCategoryName)
        throw new Error(`Child category '${u} already exists for parent category ${c.name}, config flag allowSameCategoryName=false - therefore matching version 1 behavior (hence this Error)`);
      return v;
    }
    const p = this._logProvider.getLogger(l);
    this._logProvider.updateLoggerRuntime(p, {
      level: c.logger.runtimeSettings.level,
      channel: c.logger.runtimeSettings.channel
    });
    const _ = new CategoryImpl(p, u, c, this.getOrCreateCategory);
    return this._categoriesById.set(_.id, _), this._categoriesByPath.set(_.path.join(CATEGORY_PATH_SEPARATOR), _), c.addChild(_), _;
  }
  static isLogId(u) {
    return typeof u == "string";
  }
}
class CategoryControlProviderImpl {
  constructor(u, c) {
    this._provider = u, this._messageChannel = c, this._originalLogLevels = CategoryControlProviderImpl.loadCurrentGroupLogLevels(u);
  }
  get name() {
    return this._provider.name;
  }
  /**
   * Shows current settings.
   */
  showSettings() {
    let u = `Available categories (CategoryProvider '${this._provider.name}'):
`;
    const c = this.createCategoryInfoHierarchy(), l = c.size.toString().length, v = index$3.maxLengthStringValueInArray([...c.values()].map((_) => _.category.name + " ".repeat(_.depth))), p = [...c.values()].map((_, k) => CategoryControlProviderImpl.createSettingLineCategory(_, k, l, v));
    u += p.join(`
`) + (p.length > 0 ? `
` : ""), this._messageChannel(u);
  }
  help() {
    const u = `You can use the following commands (CategoryProvider ${this._provider.name}):
  showSettings()
    Shows the current configuration settings.
  update(level: CategoryControlProviderLogLevel, categoryId?: number | string, noRecurse?: boolean)
    Change the log level for a category (by default recursively).
      @param level      The log level to set - must be one of 'trace', 'debug', 'info', 'warn', 'error' or 'fatal'
      @param categoryId The category id or path of a category (e.g. root#child1) to update. Use showSettings() for id and/or name.
                        When omitted, it applies the level to all categories recursively.
  reset()
    Resets the log levels of the config groups back to when this control provider was created.
  save()
    Saves the current log levels for all categories of this provider. Use restore() to load last saved state.
  restore()
    Restore stored saved state, if any. Log levels will be set according to the saved state.
  help()
    Shows this help.
`;
    this._messageChannel(u);
  }
  reset() {
    const u = new Map(this._provider.getRegisteredCategories().map((c) => [c.id, c]));
    this._originalLogLevels.forEach((c, l) => {
      const v = u.get(l);
      v !== void 0 && this._provider.updateRuntimeSettingsCategory(v, { level: c, disableRecursion: !0 }), u.delete(l);
    }), u.forEach((c) => {
      c.parent !== void 0 && this._provider.updateRuntimeSettingsCategory(c, { level: c.parent.logLevel, disableRecursion: !0 });
    }), this._originalLogLevels = CategoryControlProviderImpl.loadCurrentGroupLogLevels(this._provider), this._messageChannel("Successfully reset log levels back to original state (from when this CategoryControlProvider was created).");
  }
  save() {
    if (!localStorage) {
      this._messageChannel("Cannot save state, localStorage is not available.");
      return;
    }
    const u = this._provider.getRegisteredCategories().filter((l) => l.parent === void 0).map((l) => CategoryControlProviderImpl.createCategorySaveData(l)), c = {
      name: this._provider.name,
      rootCategories: u
    };
    localStorage.setItem(this.createKey(), JSON.stringify(c)), this._messageChannel(`Successfully saved state for CategoryControlProvider '${this._provider.name}'.`);
  }
  restore(u) {
    const c = u !== void 0 ? u : !0;
    if (!localStorage) {
      c && this._messageChannel(`Will not attempt to restore state for CategoryControlProvider '${this._provider.name}', localStorage is not available.`);
      return;
    }
    const l = this.createKey(), v = localStorage.getItem(l);
    if (v === null) {
      c && this._messageChannel(`Cannot restore state for CategoryControlProvider '${this._provider.name}', no data available.`);
      return;
    }
    try {
      const p = JSON.parse(v);
      if (this._provider.name !== p.name) {
        c && this._messageChannel(`Cannot restore state for CategoryControlProvider '${this._provider.name}', data is not for provider - found name '${p.name}'.`);
        return;
      }
      this.restoreBySaveData(p, c), this._messageChannel(`Successfully restored state for CategoryControlProvider '${this._provider.name}'`), this._originalLogLevels = CategoryControlProviderImpl.loadCurrentGroupLogLevels(this._provider);
    } catch {
      localStorage.removeItem(l), this._messageChannel(`Cannot restore state for CategoryControlProvider '${this._provider.name}', data is not valid. Invalid data removed from localStorage.`);
    }
  }
  update(u, c, l) {
    typeof c > "u" ? this.updateAll(u) : typeof c == "number" ? this.updateByIndex(u, c, l !== void 0 ? l : !1) : this.updateByPath(u, c, l !== void 0 ? l : !1);
  }
  updateAll(u) {
    const c = LogLevel$1.toLogLevel(u);
    this._provider.getRegisteredCategories().filter((l) => l.parent === void 0).forEach((l) => this._provider.updateRuntimeSettingsCategory(l, { level: c })), this._messageChannel(`Updated all categories to use log level '${u.toLowerCase()}'`);
  }
  updateByPath(u, c, l) {
    const v = this._provider.getCategoryByPath(c);
    if (v === void 0) {
      this._messageChannel(`Failed to find a provider by path '${c}', please make sure to separate the parts by a ${CATEGORY_PATH_SEPARATOR}.`);
      return;
    }
    this._provider.updateRuntimeSettingsCategory(v, { level: LogLevel$1.toLogLevel(u), disableRecursion: l }), this._messageChannel(`Successfully updated category '${v.name}' with path '${c}' to log level '${u.toLowerCase()}'${l ? "" : " and recursively applied to children (if any)"}.`);
  }
  updateByIndex(u, c, l) {
    if (c < 0) {
      this._messageChannel(`Cannot update category by index '${c}', it is negative.`);
      return;
    }
    const v = this.createCategoryInfoHierarchy();
    if (c >= v.size) {
      this._messageChannel(`Cannot update category by index '${c}', it is outside of the range of available categories, use showSettings() to see the indices.`);
      return;
    }
    const p = [...v.values()][c].category;
    this._provider.updateRuntimeSettingsCategory(p, { level: LogLevel$1.toLogLevel(u), disableRecursion: l }), this._messageChannel(`Successfully updated category '${p.name}' by index '${c}' to log level '${u.toLowerCase()}'${l ? "" : " and recursively applied to children (if any)"}.`);
  }
  restoreBySaveData(u, c) {
    const l = (v, p) => {
      const _ = p.length > 0 ? p + CATEGORY_PATH_SEPARATOR + v.name : v.name, k = this._provider.getCategoryByPath(_);
      if (k !== void 0) {
        const O = LogLevel$1.toLogLevel(v.level);
        O !== void 0 ? this._provider.updateRuntimeSettingsCategory(k, { level: O, disableRecursion: !0 }) : c && this._messageChannel(`CategoryControlProvider '${this._provider.name}' - cannot restore log level for category path '${_}', log level is invalid.`);
        for (const D of v.children)
          l(D, _);
      } else
        c && this._messageChannel(`CategoryControlProvider '${this._provider.name}' - failed to find a Category by path '${_}', will not restore category (and children)`);
    };
    for (const v of u.rootCategories)
      l(v, "");
  }
  createKey() {
    return `CategoryProvider-${this._provider.name}`;
  }
  createCategoryInfoHierarchy() {
    const u = /* @__PURE__ */ new Map();
    return this._provider.getRegisteredCategories().filter((l) => l.parent === void 0).forEach((l) => CategoryControlProviderImpl.addCategoryInfoHierarchy(l, 0, u)), u;
  }
  static createCategorySaveData(u) {
    return {
      name: u.name,
      level: LogLevel$1[u.logLevel],
      children: u.children.map((c) => this.createCategorySaveData(c))
    };
  }
  static loadCurrentGroupLogLevels(u) {
    return new Map(u.getRegisteredCategories().map((c) => [c.id, c.logLevel]));
  }
  static createSettingLineCategory(u, c, l, v) {
    const _ = " ".repeat(u.depth) + u.category.name;
    return `  [${index$3.padStart(c.toString(), l)}, ${index$3.padEnd(_, v)} (level=${index$3.padEnd(u.logLevel, 5)})]`;
  }
  static addCategoryInfoHierarchy(u, c, l) {
    l.set(u.id, {
      category: u,
      logLevel: LogLevel$1[u.logLevel],
      depth: c
    }), u.children.forEach((v) => this.addCategoryInfoHierarchy(v, c + 1, l));
  }
}
function categoryConfigDebug(a) {
  return `CategoryConfig=level: ${LogLevel$1[a.level].toString()}, allowSameCategoryName=${a.allowSameCategoryName}`;
}
class CategoryProviderService {
  constructor() {
    this._log = InternalLogger.getInternalLogger("category.impl.CategoryProviderService"), this._providers = new index$3.EnhancedMap();
  }
  createLogProvider(u, c) {
    const l = this._providers.compute(u, (v, p) => {
      if (p)
        throw new Error(`CategoryProvider with name '${u}' already exists, cannot create another.`);
      const _ = mergeWithDefaults(c);
      return this._log.debug(() => `Creating new CategoryProvider with name '${u}', using config settings '${categoryConfigDebug(_)}'.`), new CategoryProviderImpl(u, _);
    });
    if (l)
      return l;
    throw new Error("No CategoryProvider? This is a bug.");
  }
  getCategoryControl(u) {
    const c = u || ((l) => {
      if (console && console.log)
        console.log(l);
      else
        throw new Error("Cannot use console (it is not present), please specify a custom function to write to.");
    });
    return {
      help: () => c(CategoryProviderService.help()),
      showSettings: () => c(this.showSettings()),
      getProvider: (l) => this.getCategoryControlProviderByIdOrName(l, c)
    };
  }
  clear() {
    this._providers.clear();
  }
  /* Functions for CategoryControl follow */
  showSettings() {
    let u = `Available CategoryProviders:
`;
    const c = this._providers.size.toString().length, l = index$3.maxLengthStringValueInArray([...this._providers.keys()]), v = [...this._providers.entries()].map((p, _) => {
      const k = p[0];
      return `  [${index$3.padStart(_.toString(), c)}, ${index$3.padEnd(k, l)}]`;
    });
    return u += v.join(`
`) + (v.length > 0 ? `
` : ""), u;
  }
  getCategoryControlProviderByIdOrName(u, c) {
    if (typeof u == "string") {
      const v = this._providers.get(u);
      if (v === void 0)
        throw new Error(`Provider with name '${u}' does not exist.`);
      return new CategoryControlProviderImpl(v, c);
    }
    const l = [...this._providers.values()];
    if (u < 0 || u >= l.length)
      throw new Error(`Provider with index '${u}' does not exist (outside of range).`);
    return new CategoryControlProviderImpl(l[u], c);
  }
  static help() {
    return `You can use the following commands:
  showSettings()
    Shows the current configuration settings.
  getProvider: (id: number | string): CategoryControlProvider
    Get access to a CategoryControlProvider to change log levels.
      @param id The id (use showSettings to see) or name of the provider
  help()
    Shows this help.
`;
  }
}
const CATEGORY_PROVIDER_SERVICE = new CategoryProviderService(), CATEGORY_LOG_CONTROL = (a) => CATEGORY_PROVIDER_SERVICE.getCategoryControl(a);
function mergeWithDefaults(a) {
  const u = {
    channel: DefaultChannels.createConsoleChannel(),
    allowSameCategoryName: !0,
    level: LogLevel$1.Error,
    dateFormatter: formatDate,
    argumentFormatter: formatArgument
  };
  return a ? {
    channel: a.channel ? a.channel : u.channel,
    allowSameCategoryName: a.allowSameCategoryName !== void 0 ? a.allowSameCategoryName : u.allowSameCategoryName,
    level: a.level ? a.level : u.level,
    dateFormatter: a.dateFormatter ? a.dateFormatter : u.dateFormatter,
    argumentFormatter: a.argumentFormatter ? a.argumentFormatter : u.argumentFormatter
  } : u;
}
var CategoryProvider;
(function(a) {
  function u(l, v) {
    return CATEGORY_PROVIDER_SERVICE.createLogProvider(l, v);
  }
  a.createProvider = u;
  function c() {
    CATEGORY_PROVIDER_SERVICE.clear();
  }
  a.clear = c;
})(CategoryProvider || (CategoryProvider = {}));
const typescriptLoggingCategory_esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CATEGORY_LOG_CONTROL,
  get CategoryProvider() {
    return CategoryProvider;
  }
}, Symbol.toStringTag, { value: "Module" })), require$$1$2 = /* @__PURE__ */ getAugmentedNamespace(typescriptLoggingCategory_esm);
Object.defineProperty(logger, "__esModule", { value: !0 });
logger.logger = void 0;
const typescript_logging_1 = require$$2$2, typescript_logging_category_style_1 = require$$1$2;
logger.logger = typescript_logging_category_style_1.CategoryProvider.createProvider("ApiStream", { allowSameCategoryName: !0, level: typescript_logging_1.LogLevel.Warn });
var version$4 = "1.0.27", __createBinding$3 = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(a, u, c, l) {
  l === void 0 && (l = c);
  var v = Object.getOwnPropertyDescriptor(u, c);
  (!v || ("get" in v ? !u.__esModule : v.writable || v.configurable)) && (v = { enumerable: !0, get: function() {
    return u[c];
  } }), Object.defineProperty(a, l, v);
} : function(a, u, c, l) {
  l === void 0 && (l = c), a[l] = u[c];
}), __setModuleDefault$3 = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(a, u) {
  Object.defineProperty(a, "default", { enumerable: !0, value: u });
} : function(a, u) {
  a.default = u;
}), __importStar$3 = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(a) {
  if (a && a.__esModule)
    return a;
  var u = {};
  if (a != null)
    for (var c in a)
      c !== "default" && Object.prototype.hasOwnProperty.call(a, c) && __createBinding$3(u, a, c);
  return __setModuleDefault$3(u, a), u;
}, __importDefault$d = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(api$3, "__esModule", { value: !0 });
api$3.ApiClient = void 0;
const NiceGrpc$1 = __importStar$3(lib$1), abort_controller_x_1 = require$$1$3, detect_node_1 = __importDefault$d(browser$f), NodeTransport = __importStar$3(require$$3), logger_1 = logger, clientVersion$1 = version$4;
class ApiClient {
  constructor(u, c, l, v, p, _) {
    this.sessionId = u, this.sdkVersion = l, this.version = clientVersion$1, this.apiLogCallback = p, this.eventLogCallback = _, this.log = logger_1.logger.getCategory(v), this.channel = NiceGrpc$1.createChannel(c, detect_node_1.default ? NodeTransport.NodeHttpTransport() : void 0), this.clientFactory = NiceGrpc$1.createClientFactory().use(this.logMiddleware.bind(this));
  }
  async *logMiddleware(u, c) {
    const { path: l } = u.method;
    try {
      const v = yield* u.next(u.request, c);
      if (this.log.debug(`-> ${l}: ok`), this.log.trace(`${JSON.stringify(u.request)} -> ${l}: ${JSON.stringify(v)}`), this.apiLogCallback) {
        let p = l.split("/"), _ = p[1].split("."), k = _[_.length - 1], O = _[_.length - 2], D = _[_.length - 3], F = p[2];
        this.apiLogCallback(D, k, F, u.request, v);
      }
      return v;
    } catch (v) {
      throw this.log.trace(`${JSON.stringify(u.request)} -> ${l}`), v instanceof NiceGrpc$1.ClientError ? this.log.warn(`-> ${l}: error: ${NiceGrpc$1.Status[v.code]}: ${v.details}`) : (0, abort_controller_x_1.isAbortError)(v) ? this.log.warn(`-> ${l}: cancel`) : this.log.warn(`-> ${l}: error: ${v == null ? void 0 : v.stack}`), v;
    }
  }
  setAccessToken(u) {
    (this.accessToken == null || this.accessToken != u) && (this.log.debug("access token refreshed"), this.accessToken = u, this.setup());
  }
  makeGrpcMetadata() {
    let u = NiceGrpc$1.Metadata({
      Authorization: `Bearer ${this.accessToken}`,
      Version: this.version,
      SessionId: this.sessionId
    });
    return this.sdkVersion != null && u.set("SdkVersion", this.sdkVersion), u;
  }
  setup() {
    let u = {
      metadata: this.makeGrpcMetadata()
    };
    this._setup(u);
  }
  _setup(u) {
  }
}
api$3.ApiClient = ApiClient;
var decorator = {};
Object.defineProperty(decorator, "__esModule", { value: !0 });
decorator.RequiresSdkAuthentication = void 0;
function RequiresSdkAuthentication() {
  return function(a, u) {
    const c = Symbol(u);
    Object.defineProperty(a, u, {
      get: function() {
        if (!this[c])
          throw new Error("Please authenticate ApiStream by calling apiStream.load( accessToken )");
        return this[c];
      },
      set: function(l) {
        this[c] = l;
      }
    });
  };
}
decorator.RequiresSdkAuthentication = RequiresSdkAuthentication;
var __createBinding$2 = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(a, u, c, l) {
  l === void 0 && (l = c);
  var v = Object.getOwnPropertyDescriptor(u, c);
  (!v || ("get" in v ? !u.__esModule : v.writable || v.configurable)) && (v = { enumerable: !0, get: function() {
    return u[c];
  } }), Object.defineProperty(a, l, v);
} : function(a, u, c, l) {
  l === void 0 && (l = c), a[l] = u[c];
}), __setModuleDefault$2 = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(a, u) {
  Object.defineProperty(a, "default", { enumerable: !0, value: u });
} : function(a, u) {
  a.default = u;
}), __decorate = commonjsGlobal$1 && commonjsGlobal$1.__decorate || function(a, u, c, l) {
  var v = arguments.length, p = v < 3 ? u : l === null ? l = Object.getOwnPropertyDescriptor(u, c) : l, _;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    p = Reflect.decorate(a, u, c, l);
  else
    for (var k = a.length - 1; k >= 0; k--)
      (_ = a[k]) && (p = (v < 3 ? _(p) : v > 3 ? _(u, c, p) : _(u, c)) || p);
  return v > 3 && p && Object.defineProperty(u, c, p), p;
}, __importStar$2 = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(a) {
  if (a && a.__esModule)
    return a;
  var u = {};
  if (a != null)
    for (var c in a)
      c !== "default" && Object.prototype.hasOwnProperty.call(a, c) && __createBinding$2(u, a, c);
  return __setModuleDefault$2(u, a), u;
}, __metadata = commonjsGlobal$1 && commonjsGlobal$1.__metadata || function(a, u) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
    return Reflect.metadata(a, u);
};
Object.defineProperty(layoutapi, "__esModule", { value: !0 });
layoutapi.LayoutApi = void 0;
__importStar$2(lib$1);
const LayoutApiModel = __importStar$2(dist$2), api_1$1 = api$3, decorator_1 = decorator, LOG_CATEGORY$1 = "LayoutApi";
class LayoutApi extends api_1$1.ApiClient {
  constructor(u, c, l, v, p) {
    super(u, l, v, LOG_CATEGORY$1, p), this.handlers = {}, this.eventApi = c, this.eventApi.on("event", { name: `${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:*`, ignoreSessionEvents: !0 }, (_) => {
      var k;
      const [, O] = _.name.split(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:`), [D, F] = O.split(":"), z = _.payload;
      for (const j of (k = this.handlers[D]) !== null && k !== void 0 ? k : [])
        j(Object.values(z).find((ee) => !!ee), F);
    });
  }
  _setup(u) {
    this.layer = this.clientFactory.create(LayoutApiModel.LayerServiceDefinition, this.channel, {
      "*": u
    }), this.layout = this.clientFactory.create(LayoutApiModel.LayoutServiceDefinition, this.channel, {
      "*": u
    });
  }
  /**
   * Subscribe to all events for a given layout.
   *
   * @param layoutId - the id of the layout to which you want to subscribe to layout events
   */
  async subscribeToLayout(u) {
    await Promise.all([
      this.eventApi.subscribe(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:${LayoutApiModel.EventType.EVENT_TYPE_LAYER}:*`, { target: { layoutId: u } }),
      this.eventApi.subscribe(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:${LayoutApiModel.EventType.EVENT_TYPE_LAYOUT}:*`, { target: { layoutId: u } })
    ]);
  }
  /**
   * Unsubscribe from all events for a given layout.
   *
   * @param layoutId - the id of the layout to which you want to unsubscribe to layout events
   */
  async unsubscribeFromLayout(u) {
    await Promise.all([
      this.eventApi.unsubscribe(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:${LayoutApiModel.EventType.EVENT_TYPE_LAYER}:*`, { target: { layoutId: u } }),
      this.eventApi.unsubscribe(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:${LayoutApiModel.EventType.EVENT_TYPE_LAYOUT}:*`, { target: { layoutId: u } })
    ]);
  }
  /**
   * Subscribe to all events for layouts in a project.
   *
   * @param collectionId - the id of the collection the layouts are in.
   * @param projectId - the id of the project the layouts are in.
   */
  async subscribeToLayoutsInProject(u, c) {
    await Promise.all([
      this.eventApi.subscribe(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:${LayoutApiModel.EventType.EVENT_TYPE_LAYER}:*`, { target: { collectionId: u, projectId: c } }),
      this.eventApi.subscribe(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:${LayoutApiModel.EventType.EVENT_TYPE_LAYOUT}:*`, { target: { collectionId: u, projectId: c } })
    ]);
  }
  /**
   * Unsubscribe from all events for layouts in a project.
   *
   * @param collectionId - the id of the collection the layouts are in.
   * @param projectId - the id of the project the layouts are in.
   */
  async unsubscribeFromLayoutsInProject(u, c) {
    await Promise.all([
      this.eventApi.unsubscribe(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:${LayoutApiModel.EventType.EVENT_TYPE_LAYER}:*`, { target: { collectionId: u, projectId: c } }),
      this.eventApi.unsubscribe(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:${LayoutApiModel.EventType.EVENT_TYPE_LAYOUT}:*`, { target: { collectionId: u, projectId: c } })
    ]);
  }
  /**
   * Register an event handler
   *
   * @param type Type of event
   * @param handler
   */
  on(u, c) {
    var l;
    this.handlers[u] = (l = this.handlers[u]) !== null && l !== void 0 ? l : [], this.handlers[u].push(c);
  }
  /**
   * Unregister an event handler
   *
   * @param type Type of event
   * @param handler
   */
  off(u, c) {
    this.handlers[u] = this.handlers[u].filter((l) => l !== c);
  }
}
LayoutApi.LAYOUTAPI_EVENT_PREFIX = "apistream:layout";
__decorate([
  (0, decorator_1.RequiresSdkAuthentication)(),
  __metadata("design:type", Object)
], LayoutApi.prototype, "layout", void 0);
__decorate([
  (0, decorator_1.RequiresSdkAuthentication)(),
  __metadata("design:type", Object)
], LayoutApi.prototype, "layer", void 0);
layoutapi.LayoutApi = LayoutApi;
var liveapi = {}, api$2 = {}, httpbody = {}, any = {}, __importDefault$c = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(any, "__esModule", { value: !0 });
any.Any = any.protobufPackage = void 0;
const minimal_1$5 = __importDefault$c(minimal);
any.protobufPackage = "google.protobuf";
function createBaseAny() {
  return { typeUrl: "", value: new Uint8Array() };
}
any.Any = {
  encode(a, u = minimal_1$5.default.Writer.create()) {
    return a.typeUrl !== "" && u.uint32(10).string(a.typeUrl), a.value.length !== 0 && u.uint32(18).bytes(a.value), u;
  },
  decode(a, u) {
    const c = a instanceof minimal_1$5.default.Reader ? a : new minimal_1$5.default.Reader(a);
    let l = u === void 0 ? c.len : c.pos + u;
    const v = createBaseAny();
    for (; c.pos < l; ) {
      const p = c.uint32();
      switch (p >>> 3) {
        case 1:
          v.typeUrl = c.string();
          break;
        case 2:
          v.value = c.bytes();
          break;
        default:
          c.skipType(p & 7);
          break;
      }
    }
    return v;
  },
  fromJSON(a) {
    return {
      typeUrl: isSet$5(a.typeUrl) ? String(a.typeUrl) : "",
      value: isSet$5(a.value) ? bytesFromBase64$1(a.value) : new Uint8Array()
    };
  },
  toJSON(a) {
    const u = {};
    return a.typeUrl !== void 0 && (u.typeUrl = a.typeUrl), a.value !== void 0 && (u.value = base64FromBytes$1(a.value !== void 0 ? a.value : new Uint8Array())), u;
  },
  fromPartial(a) {
    var u, c;
    const l = createBaseAny();
    return l.typeUrl = (u = a.typeUrl) !== null && u !== void 0 ? u : "", l.value = (c = a.value) !== null && c !== void 0 ? c : new Uint8Array(), l;
  }
};
var globalThis$5 = (() => {
  if (typeof globalThis$5 < "u")
    return globalThis$5;
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof commonjsGlobal$1 < "u")
    return commonjsGlobal$1;
  throw "Unable to locate global object";
})();
function bytesFromBase64$1(a) {
  if (globalThis$5.Buffer)
    return Uint8Array.from(globalThis$5.Buffer.from(a, "base64"));
  {
    const u = globalThis$5.atob(a), c = new Uint8Array(u.length);
    for (let l = 0; l < u.length; ++l)
      c[l] = u.charCodeAt(l);
    return c;
  }
}
function base64FromBytes$1(a) {
  if (globalThis$5.Buffer)
    return globalThis$5.Buffer.from(a).toString("base64");
  {
    const u = [];
    return a.forEach((c) => {
      u.push(String.fromCharCode(c));
    }), globalThis$5.btoa(u.join(""));
  }
}
function isSet$5(a) {
  return a != null;
}
var __importDefault$b = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(httpbody, "__esModule", { value: !0 });
httpbody.HttpBody = httpbody.protobufPackage = void 0;
const minimal_1$4 = __importDefault$b(minimal), any_1 = any;
httpbody.protobufPackage = "google.api";
function createBaseHttpBody() {
  return { contentType: "", data: new Uint8Array(), extensions: [] };
}
httpbody.HttpBody = {
  encode(a, u = minimal_1$4.default.Writer.create()) {
    a.contentType !== "" && u.uint32(10).string(a.contentType), a.data.length !== 0 && u.uint32(18).bytes(a.data);
    for (const c of a.extensions)
      any_1.Any.encode(c, u.uint32(26).fork()).ldelim();
    return u;
  },
  decode(a, u) {
    const c = a instanceof minimal_1$4.default.Reader ? a : new minimal_1$4.default.Reader(a);
    let l = u === void 0 ? c.len : c.pos + u;
    const v = createBaseHttpBody();
    for (; c.pos < l; ) {
      const p = c.uint32();
      switch (p >>> 3) {
        case 1:
          v.contentType = c.string();
          break;
        case 2:
          v.data = c.bytes();
          break;
        case 3:
          v.extensions.push(any_1.Any.decode(c, c.uint32()));
          break;
        default:
          c.skipType(p & 7);
          break;
      }
    }
    return v;
  },
  fromJSON(a) {
    return {
      contentType: isSet$4(a.contentType) ? String(a.contentType) : "",
      data: isSet$4(a.data) ? bytesFromBase64(a.data) : new Uint8Array(),
      extensions: Array.isArray(a == null ? void 0 : a.extensions) ? a.extensions.map((u) => any_1.Any.fromJSON(u)) : []
    };
  },
  toJSON(a) {
    const u = {};
    return a.contentType !== void 0 && (u.contentType = a.contentType), a.data !== void 0 && (u.data = base64FromBytes(a.data !== void 0 ? a.data : new Uint8Array())), a.extensions ? u.extensions = a.extensions.map((c) => c ? any_1.Any.toJSON(c) : void 0) : u.extensions = [], u;
  },
  fromPartial(a) {
    var u, c, l;
    const v = createBaseHttpBody();
    return v.contentType = (u = a.contentType) !== null && u !== void 0 ? u : "", v.data = (c = a.data) !== null && c !== void 0 ? c : new Uint8Array(), v.extensions = ((l = a.extensions) === null || l === void 0 ? void 0 : l.map((p) => any_1.Any.fromPartial(p))) || [], v;
  }
};
var globalThis$4 = (() => {
  if (typeof globalThis$4 < "u")
    return globalThis$4;
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof commonjsGlobal$1 < "u")
    return commonjsGlobal$1;
  throw "Unable to locate global object";
})();
function bytesFromBase64(a) {
  if (globalThis$4.Buffer)
    return Uint8Array.from(globalThis$4.Buffer.from(a, "base64"));
  {
    const u = globalThis$4.atob(a), c = new Uint8Array(u.length);
    for (let l = 0; l < u.length; ++l)
      c[l] = u.charCodeAt(l);
    return c;
  }
}
function base64FromBytes(a) {
  if (globalThis$4.Buffer)
    return globalThis$4.Buffer.from(a).toString("base64");
  {
    const u = [];
    return a.forEach((c) => {
      u.push(String.fromCharCode(c));
    }), globalThis$4.btoa(u.join(""));
  }
}
function isSet$4(a) {
  return a != null;
}
var field_mask = {}, __importDefault$a = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(field_mask, "__esModule", { value: !0 });
field_mask.FieldMask = field_mask.protobufPackage = void 0;
const minimal_1$3 = __importDefault$a(minimal);
field_mask.protobufPackage = "google.protobuf";
function createBaseFieldMask() {
  return { paths: [] };
}
field_mask.FieldMask = {
  encode(a, u = minimal_1$3.default.Writer.create()) {
    for (const c of a.paths)
      u.uint32(10).string(c);
    return u;
  },
  decode(a, u) {
    const c = a instanceof minimal_1$3.default.Reader ? a : new minimal_1$3.default.Reader(a);
    let l = u === void 0 ? c.len : c.pos + u;
    const v = createBaseFieldMask();
    for (; c.pos < l; ) {
      const p = c.uint32();
      switch (p >>> 3) {
        case 1:
          v.paths.push(c.string());
          break;
        default:
          c.skipType(p & 7);
          break;
      }
    }
    return v;
  },
  fromJSON(a) {
    return {
      paths: typeof a == "string" ? a.split(",").filter(Boolean) : Array.isArray(a == null ? void 0 : a.paths) ? a.paths.map(String) : []
    };
  },
  toJSON(a) {
    return a.paths.join(",");
  },
  fromPartial(a) {
    var u;
    const c = createBaseFieldMask();
    return c.paths = ((u = a.paths) === null || u === void 0 ? void 0 : u.map((l) => l)) || [], c;
  },
  wrap(a) {
    const u = createBaseFieldMask();
    return u.paths = a, u;
  },
  unwrap(a) {
    return a.paths;
  }
};
var struct$1 = {};
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(X) {
    return X && X.__esModule ? X : { default: X };
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.ListValue = a.Value = a.Struct_FieldsEntry = a.Struct = a.nullValueToNumber = a.nullValueToJSON = a.nullValueFromJSON = a.NullValue = a.protobufPackage = void 0;
  const c = u(minimal);
  a.protobufPackage = "google.protobuf";
  var l;
  (function(X) {
    X.NULL_VALUE = "NULL_VALUE";
  })(l = a.NullValue || (a.NullValue = {}));
  function v(X) {
    switch (X) {
      case 0:
      case "NULL_VALUE":
        return l.NULL_VALUE;
      default:
        throw new z.Error("Unrecognized enum value " + X + " for enum NullValue");
    }
  }
  a.nullValueFromJSON = v;
  function p(X) {
    switch (X) {
      case l.NULL_VALUE:
        return "NULL_VALUE";
      default:
        throw new z.Error("Unrecognized enum value " + X + " for enum NullValue");
    }
  }
  a.nullValueToJSON = p;
  function _(X) {
    switch (X) {
      case l.NULL_VALUE:
        return 0;
      default:
        throw new z.Error("Unrecognized enum value " + X + " for enum NullValue");
    }
  }
  a.nullValueToNumber = _;
  function k() {
    return { fields: {} };
  }
  a.Struct = {
    encode(X, ae = c.default.Writer.create()) {
      return Object.entries(X.fields).forEach(([Q, ne]) => {
        ne !== void 0 && a.Struct_FieldsEntry.encode({ key: Q, value: ne }, ae.uint32(10).fork()).ldelim();
      }), ae;
    },
    decode(X, ae) {
      const Q = X instanceof c.default.Reader ? X : new c.default.Reader(X);
      let ne = ae === void 0 ? Q.len : Q.pos + ae;
      const Z = k();
      for (; Q.pos < ne; ) {
        const de = Q.uint32();
        switch (de >>> 3) {
          case 1:
            const fe = a.Struct_FieldsEntry.decode(Q, Q.uint32());
            fe.value !== void 0 && (Z.fields[fe.key] = fe.value);
            break;
          default:
            Q.skipType(de & 7);
            break;
        }
      }
      return Z;
    },
    fromJSON(X) {
      return {
        fields: j(X.fields) ? Object.entries(X.fields).reduce((ae, [Q, ne]) => (ae[Q] = ne, ae), {}) : {}
      };
    },
    toJSON(X) {
      const ae = {};
      return ae.fields = {}, X.fields && Object.entries(X.fields).forEach(([Q, ne]) => {
        ae.fields[Q] = ne;
      }), ae;
    },
    fromPartial(X) {
      var ae;
      const Q = k();
      return Q.fields = Object.entries((ae = X.fields) !== null && ae !== void 0 ? ae : {}).reduce((ne, [Z, de]) => (de !== void 0 && (ne[Z] = de), ne), {}), Q;
    },
    wrap(X) {
      const ae = k();
      return X !== void 0 && Object.keys(X).forEach((Q) => {
        ae.fields[Q] = X[Q];
      }), ae;
    },
    unwrap(X) {
      const ae = {};
      return Object.keys(X.fields).forEach((Q) => {
        ae[Q] = X.fields[Q];
      }), ae;
    }
  };
  function O() {
    return { key: "", value: void 0 };
  }
  a.Struct_FieldsEntry = {
    encode(X, ae = c.default.Writer.create()) {
      return X.key !== "" && ae.uint32(10).string(X.key), X.value !== void 0 && a.Value.encode(a.Value.wrap(X.value), ae.uint32(18).fork()).ldelim(), ae;
    },
    decode(X, ae) {
      const Q = X instanceof c.default.Reader ? X : new c.default.Reader(X);
      let ne = ae === void 0 ? Q.len : Q.pos + ae;
      const Z = O();
      for (; Q.pos < ne; ) {
        const de = Q.uint32();
        switch (de >>> 3) {
          case 1:
            Z.key = Q.string();
            break;
          case 2:
            Z.value = a.Value.unwrap(a.Value.decode(Q, Q.uint32()));
            break;
          default:
            Q.skipType(de & 7);
            break;
        }
      }
      return Z;
    },
    fromJSON(X) {
      return { key: ee(X.key) ? String(X.key) : "", value: ee(X == null ? void 0 : X.value) ? X.value : void 0 };
    },
    toJSON(X) {
      const ae = {};
      return X.key !== void 0 && (ae.key = X.key), X.value !== void 0 && (ae.value = X.value), ae;
    },
    fromPartial(X) {
      var ae, Q;
      const ne = O();
      return ne.key = (ae = X.key) !== null && ae !== void 0 ? ae : "", ne.value = (Q = X.value) !== null && Q !== void 0 ? Q : void 0, ne;
    }
  };
  function D() {
    return {
      nullValue: void 0,
      numberValue: void 0,
      stringValue: void 0,
      boolValue: void 0,
      structValue: void 0,
      listValue: void 0
    };
  }
  a.Value = {
    encode(X, ae = c.default.Writer.create()) {
      return X.nullValue !== void 0 && ae.uint32(8).int32(_(X.nullValue)), X.numberValue !== void 0 && ae.uint32(17).double(X.numberValue), X.stringValue !== void 0 && ae.uint32(26).string(X.stringValue), X.boolValue !== void 0 && ae.uint32(32).bool(X.boolValue), X.structValue !== void 0 && a.Struct.encode(a.Struct.wrap(X.structValue), ae.uint32(42).fork()).ldelim(), X.listValue !== void 0 && a.ListValue.encode(a.ListValue.wrap(X.listValue), ae.uint32(50).fork()).ldelim(), ae;
    },
    decode(X, ae) {
      const Q = X instanceof c.default.Reader ? X : new c.default.Reader(X);
      let ne = ae === void 0 ? Q.len : Q.pos + ae;
      const Z = D();
      for (; Q.pos < ne; ) {
        const de = Q.uint32();
        switch (de >>> 3) {
          case 1:
            Z.nullValue = v(Q.int32());
            break;
          case 2:
            Z.numberValue = Q.double();
            break;
          case 3:
            Z.stringValue = Q.string();
            break;
          case 4:
            Z.boolValue = Q.bool();
            break;
          case 5:
            Z.structValue = a.Struct.unwrap(a.Struct.decode(Q, Q.uint32()));
            break;
          case 6:
            Z.listValue = a.ListValue.unwrap(a.ListValue.decode(Q, Q.uint32()));
            break;
          default:
            Q.skipType(de & 7);
            break;
        }
      }
      return Z;
    },
    fromJSON(X) {
      return {
        nullValue: ee(X.nullValue) ? v(X.nullValue) : void 0,
        numberValue: ee(X.numberValue) ? Number(X.numberValue) : void 0,
        stringValue: ee(X.stringValue) ? String(X.stringValue) : void 0,
        boolValue: ee(X.boolValue) ? !!X.boolValue : void 0,
        structValue: j(X.structValue) ? X.structValue : void 0,
        listValue: Array.isArray(X.listValue) ? [...X.listValue] : void 0
      };
    },
    toJSON(X) {
      const ae = {};
      return X.nullValue !== void 0 && (ae.nullValue = X.nullValue !== void 0 ? p(X.nullValue) : void 0), X.numberValue !== void 0 && (ae.numberValue = X.numberValue), X.stringValue !== void 0 && (ae.stringValue = X.stringValue), X.boolValue !== void 0 && (ae.boolValue = X.boolValue), X.structValue !== void 0 && (ae.structValue = X.structValue), X.listValue !== void 0 && (ae.listValue = X.listValue), ae;
    },
    fromPartial(X) {
      var ae, Q, ne, Z, de, fe;
      const Te = D();
      return Te.nullValue = (ae = X.nullValue) !== null && ae !== void 0 ? ae : void 0, Te.numberValue = (Q = X.numberValue) !== null && Q !== void 0 ? Q : void 0, Te.stringValue = (ne = X.stringValue) !== null && ne !== void 0 ? ne : void 0, Te.boolValue = (Z = X.boolValue) !== null && Z !== void 0 ? Z : void 0, Te.structValue = (de = X.structValue) !== null && de !== void 0 ? de : void 0, Te.listValue = (fe = X.listValue) !== null && fe !== void 0 ? fe : void 0, Te;
    },
    wrap(X) {
      const ae = D();
      if (X === null)
        ae.nullValue = l.NULL_VALUE;
      else if (typeof X == "boolean")
        ae.boolValue = X;
      else if (typeof X == "number")
        ae.numberValue = X;
      else if (typeof X == "string")
        ae.stringValue = X;
      else if (Array.isArray(X))
        ae.listValue = X;
      else if (typeof X == "object")
        ae.structValue = X;
      else if (typeof X < "u")
        throw new Error("Unsupported any value type: " + typeof X);
      return ae;
    },
    unwrap(X) {
      if ((X == null ? void 0 : X.stringValue) !== void 0)
        return X.stringValue;
      if ((X == null ? void 0 : X.numberValue) !== void 0)
        return X.numberValue;
      if ((X == null ? void 0 : X.boolValue) !== void 0)
        return X.boolValue;
      if ((X == null ? void 0 : X.structValue) !== void 0)
        return X.structValue;
      if ((X == null ? void 0 : X.listValue) !== void 0)
        return X.listValue;
      if ((X == null ? void 0 : X.nullValue) !== void 0)
        return null;
    }
  };
  function F() {
    return { values: [] };
  }
  a.ListValue = {
    encode(X, ae = c.default.Writer.create()) {
      for (const Q of X.values)
        a.Value.encode(a.Value.wrap(Q), ae.uint32(10).fork()).ldelim();
      return ae;
    },
    decode(X, ae) {
      const Q = X instanceof c.default.Reader ? X : new c.default.Reader(X);
      let ne = ae === void 0 ? Q.len : Q.pos + ae;
      const Z = F();
      for (; Q.pos < ne; ) {
        const de = Q.uint32();
        switch (de >>> 3) {
          case 1:
            Z.values.push(a.Value.unwrap(a.Value.decode(Q, Q.uint32())));
            break;
          default:
            Q.skipType(de & 7);
            break;
        }
      }
      return Z;
    },
    fromJSON(X) {
      return { values: Array.isArray(X == null ? void 0 : X.values) ? [...X.values] : [] };
    },
    toJSON(X) {
      const ae = {};
      return X.values ? ae.values = X.values.map((Q) => Q) : ae.values = [], ae;
    },
    fromPartial(X) {
      var ae;
      const Q = F();
      return Q.values = ((ae = X.values) === null || ae === void 0 ? void 0 : ae.map((ne) => ne)) || [], Q;
    },
    wrap(X) {
      const ae = F();
      return ae.values = X ?? [], ae;
    },
    unwrap(X) {
      return X.values;
    }
  };
  var z = (() => {
    if (typeof z < "u")
      return z;
    if (typeof self < "u")
      return self;
    if (typeof window < "u")
      return window;
    if (typeof commonjsGlobal$1 < "u")
      return commonjsGlobal$1;
    throw "Unable to locate global object";
  })();
  function j(X) {
    return typeof X == "object" && X !== null;
  }
  function ee(X) {
    return X != null;
  }
})(struct$1);
var timestamp$2 = {}, __importDefault$9 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(timestamp$2, "__esModule", { value: !0 });
timestamp$2.Timestamp = timestamp$2.protobufPackage = void 0;
const long_1$2 = __importDefault$9(umdExports), minimal_1$2 = __importDefault$9(minimal);
timestamp$2.protobufPackage = "google.protobuf";
function createBaseTimestamp$1() {
  return { seconds: 0, nanos: 0 };
}
timestamp$2.Timestamp = {
  encode(a, u = minimal_1$2.default.Writer.create()) {
    return a.seconds !== 0 && u.uint32(8).int64(a.seconds), a.nanos !== 0 && u.uint32(16).int32(a.nanos), u;
  },
  decode(a, u) {
    const c = a instanceof minimal_1$2.default.Reader ? a : new minimal_1$2.default.Reader(a);
    let l = u === void 0 ? c.len : c.pos + u;
    const v = createBaseTimestamp$1();
    for (; c.pos < l; ) {
      const p = c.uint32();
      switch (p >>> 3) {
        case 1:
          v.seconds = longToNumber$2(c.int64());
          break;
        case 2:
          v.nanos = c.int32();
          break;
        default:
          c.skipType(p & 7);
          break;
      }
    }
    return v;
  },
  fromJSON(a) {
    return {
      seconds: isSet$3(a.seconds) ? Number(a.seconds) : 0,
      nanos: isSet$3(a.nanos) ? Number(a.nanos) : 0
    };
  },
  toJSON(a) {
    const u = {};
    return a.seconds !== void 0 && (u.seconds = Math.round(a.seconds)), a.nanos !== void 0 && (u.nanos = Math.round(a.nanos)), u;
  },
  fromPartial(a) {
    var u, c;
    const l = createBaseTimestamp$1();
    return l.seconds = (u = a.seconds) !== null && u !== void 0 ? u : 0, l.nanos = (c = a.nanos) !== null && c !== void 0 ? c : 0, l;
  }
};
var globalThis$3 = (() => {
  if (typeof globalThis$3 < "u")
    return globalThis$3;
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof commonjsGlobal$1 < "u")
    return commonjsGlobal$1;
  throw "Unable to locate global object";
})();
function longToNumber$2(a) {
  if (a.gt(Number.MAX_SAFE_INTEGER))
    throw new globalThis$3.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  return a.toNumber();
}
minimal_1$2.default.util.Long !== long_1$2.default && (minimal_1$2.default.util.Long = long_1$2.default, minimal_1$2.default.configure());
function isSet$3(a) {
  return a != null;
}
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(b) {
    return b && b.__esModule ? b : { default: b };
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.S3ACL = a.projectBroadcastPhaseToNumber = a.projectBroadcastPhaseToJSON = a.projectBroadcastPhaseFromJSON = a.ProjectBroadcastPhase = a.videoCodecRateControlModeToNumber = a.videoCodecRateControlModeToJSON = a.videoCodecRateControlModeFromJSON = a.VideoCodecRateControlMode = a.audioCodecToNumber = a.audioCodecToJSON = a.audioCodecFromJSON = a.AudioCodec = a.videoCodecProfileToNumber = a.videoCodecProfileToJSON = a.videoCodecProfileFromJSON = a.VideoCodecProfile = a.videoCodecToNumber = a.videoCodecToJSON = a.videoCodecFromJSON = a.VideoCodec = a.renderingQualityToNumber = a.renderingQualityToJSON = a.renderingQualityFromJSON = a.RenderingQuality = a.audioChannelLayoutToNumber = a.audioChannelLayoutToJSON = a.audioChannelLayoutFromJSON = a.AudioChannelLayout = a.videoColorSpaceToNumber = a.videoColorSpaceToJSON = a.videoColorSpaceFromJSON = a.VideoColorSpace = a.imageFormatToNumber = a.imageFormatToJSON = a.imageFormatFromJSON = a.ImageFormat = a.webhookSubtypeToNumber = a.webhookSubtypeToJSON = a.webhookSubtypeFromJSON = a.WebhookSubtype = a.webhookTypeToNumber = a.webhookTypeToJSON = a.webhookTypeFromJSON = a.WebhookType = a.broadcastTriggerToNumber = a.broadcastTriggerToJSON = a.broadcastTriggerFromJSON = a.BroadcastTrigger = a.protobufPackage = void 0, a.RtmpPullAddress = a.SrtPushAddress = a.SourceRtmpPushAddress = a.Encoding = a.AudioEncoding = a.VideoEncoding = a.VideoCodecRateControl = a.Rendering = a.AudioRendering = a.VideoRendering = a.UpdateAccountConfigurationResponse = a.UpdateAccountConfigurationRequest = a.GetAccountConfigurationResponse = a.GetAccountConfigurationRequest = a.AccountConfiguration = a.AccountConfigurationHook = a.WebhookConfiguration = a.WebhookResponse = a.WebhookRequest = a.eventTypeToNumber = a.eventTypeToJSON = a.eventTypeFromJSON = a.EventType = a.eventSubTypeToNumber = a.eventSubTypeToJSON = a.eventSubTypeFromJSON = a.EventSubType = a.connectStateToNumber = a.connectStateToJSON = a.connectStateFromJSON = a.ConnectState = a.projectBroadcastErrorToNumber = a.projectBroadcastErrorToJSON = a.projectBroadcastErrorFromJSON = a.ProjectBroadcastError = a.roleToNumber = a.roleToJSON = a.roleFromJSON = a.Role = a.regionToNumber = a.regionToJSON = a.regionFromJSON = a.Region = a.sourceTriggerActionToNumber = a.sourceTriggerActionToJSON = a.sourceTriggerActionFromJSON = a.SourceTriggerAction = a.s3ACLToNumber = a.s3ACLToJSON = a.s3ACLFromJSON = void 0, a.UpdateProjectResponse = a.UpdateProjectRequest = a.CreateProjectResponse = a.CreateProjectRequest = a.GetCollectionsResponse = a.GetCollectionsRequest = a.DeleteCollectionResponse = a.DeleteCollectionRequest = a.UpdateCollectionResponse = a.UpdateCollectionRequest = a.GetCollectionResponse = a.GetCollectionRequest = a.CreateCollectionResponse = a.CreateCollectionRequest = a.Collection = a.Project = a.Destination = a.Source = a.ProjectBroadcastStatus = a.DirectIngestUrl = a.LatLong = a.WebRtcAccess = a.WebRtc = a.HostedWebRtc = a.Composition = a.ExternalComposition = a.SceneComposition = a.StudioSdkComposition = a.PreviewAddress = a.PreviewWebRtcAddress = a.PreviewHlsPullAddress = a.ProjectTrigger = a.WebRtcTrigger = a.SourceTrigger = a.DestinationAddress = a.S3StorageAddress = a.ObjectStoragePackaging = a.HlsPackaging = a.HlsLifecycle = a.HlsLifecycleVod = a.HlsLifecycleLive = a.DestinationAgoraPushAddress = a.DestinationSrtPushAddress = a.DestinationRtmpPushAddress = a.SourceAddress = a.RuntimeSourceAddress = a.DirectSrtAddress = a.DirectRTMPAddress = a.DynamicAddress = a.SrtPullAddress = void 0, a.CreateGuestAccessTokenResponse = a.CreateGuestAccessTokenRequest = a.GuestAccessToken = a.GuestAccessTokenExchange = a.GuestAccessTokenDirect = a.CreateAccessTokenResponse = a.CreateAccessTokenRequest = a.GetSourcePlaylistResponse = a.GetSourcePlaylistRequest = a.RemoveSourceFromProjectResponse = a.RemoveSourceFromProjectRequest = a.UpdateSourceResponse = a.UpdateSourceRequest = a.GetSourcesResponse = a.GetSourcesRequest = a.GetSourceResponse = a.GetSourceRequest = a.UpdateSourceInProjectResponse = a.UpdateSourceInProjectRequest = a.AddSourceToProjectResponse = a.AddSourceToProjectRequest = a.DeleteSourceResponse = a.DeleteSourceRequest = a.CreateSourceResponse = a.CreateSourceRequest = a.UpdateDestinationResponse = a.UpdateDestinationRequest = a.DeleteDestinationResponse = a.DeleteDestinationRequest = a.GetDestinationResponse = a.GetDestinationRequest = a.CreateDestinationResponse = a.CreateDestinationRequest = a.StopProjectWebRtcResponse = a.StopProjectWebRtcRequest = a.StartProjectWebRtcResponse = a.StartProjectWebRtcRequest = a.GetProjectBroadcastStatusResponse = a.GetProjectBroadcastStatusRequest = a.GetProjectBroadcastSnapshotResponse = a.GetProjectBroadcastSnapshotRequest = a.GetProjectResponse = a.GetProjectRequest = a.StopProjectBroadcastResponse = a.StopProjectBroadcastRequest = a.StartProjectBroadcastResponse = a.StartProjectBroadcastRequest_DynamicSourcesEntry = a.StartProjectBroadcastRequest = a.DeleteProjectResponse = a.DeleteProjectRequest = void 0, a.PublicAuthenticationServiceDefinition = a.PublicAuthenticationServiceClientImpl = a.AuthenticationServiceDefinition = a.AuthenticationServiceClientImpl = a.BackendAuthenticationServiceDefinition = a.BackendAuthenticationServiceClientImpl = a.SourceServiceDefinition = a.SourceServiceClientImpl = a.DestinationServiceDefinition = a.DestinationServiceClientImpl = a.ProjectServiceDefinition = a.ProjectServiceClientImpl = a.CollectionServiceDefinition = a.CollectionServiceClientImpl = a.AccountConfigurationServiceDefinition = a.AccountConfigurationServiceClientImpl = a.LiveEvent = a.SourceEvent = a.ProjectEvent = a.DestinationEvent = a.CollectionEvent = a.SourceStateEvent = a.SourceRemoveEvent = a.SourceAddEvent = a.SourceUpdateEvent = a.SourceDeleteEvent = a.SourceCreateEvent = a.CollectionUpdateEvent = a.CollectionDeleteEvent = a.CollectionCreateEvent = a.ProjectBroadcastStateEvent = a.ProjectUpdateEvent = a.ProjectDeleteEvent = a.ProjectCreateEvent = a.DestinationStateEvent = a.DestinationUpdateEvent = a.DestinationDeleteEvent = a.DestinationCreateEvent = a.GetTestTokenResponse = a.GetTestTokenRequest = a.GetJsonWebKeySetResponse = a.GetJsonWebKeySetRequest = a.JsonWebKey = a.GuestCodeRedirectResponse = a.GuestCodeRedirectRequest = a.GuestCode = a.RefreshAccessTokenResponse = a.RefreshAccessTokenRequest = a.CreateWebRtcAccessTokenResponse = a.CreateWebRtcAccessTokenRequest = void 0;
  const c = u(minimal), l = httpbody, v = field_mask, p = struct$1, _ = timestamp$2;
  a.protobufPackage = "live.v21";
  var k;
  (function(b) {
    b.BROADCAST_TRIGGER_UNSPECIFIED = "BROADCAST_TRIGGER_UNSPECIFIED", b.BROADCAST_TRIGGER_API = "BROADCAST_TRIGGER_API", b.BROADCAST_TRIGGER_SOURCE = "BROADCAST_TRIGGER_SOURCE", b.BROADCAST_TRIGGER_INTEGRATION = "BROADCAST_TRIGGER_INTEGRATION";
  })(k = a.BroadcastTrigger || (a.BroadcastTrigger = {}));
  function O(b) {
    switch (b) {
      case 0:
      case "BROADCAST_TRIGGER_UNSPECIFIED":
        return k.BROADCAST_TRIGGER_UNSPECIFIED;
      case 1:
      case "BROADCAST_TRIGGER_API":
        return k.BROADCAST_TRIGGER_API;
      case 2:
      case "BROADCAST_TRIGGER_SOURCE":
        return k.BROADCAST_TRIGGER_SOURCE;
      case 3:
      case "BROADCAST_TRIGGER_INTEGRATION":
        return k.BROADCAST_TRIGGER_INTEGRATION;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum BroadcastTrigger");
    }
  }
  a.broadcastTriggerFromJSON = O;
  function D(b) {
    switch (b) {
      case k.BROADCAST_TRIGGER_UNSPECIFIED:
        return "BROADCAST_TRIGGER_UNSPECIFIED";
      case k.BROADCAST_TRIGGER_API:
        return "BROADCAST_TRIGGER_API";
      case k.BROADCAST_TRIGGER_SOURCE:
        return "BROADCAST_TRIGGER_SOURCE";
      case k.BROADCAST_TRIGGER_INTEGRATION:
        return "BROADCAST_TRIGGER_INTEGRATION";
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum BroadcastTrigger");
    }
  }
  a.broadcastTriggerToJSON = D;
  function F(b) {
    switch (b) {
      case k.BROADCAST_TRIGGER_UNSPECIFIED:
        return 0;
      case k.BROADCAST_TRIGGER_API:
        return 1;
      case k.BROADCAST_TRIGGER_SOURCE:
        return 2;
      case k.BROADCAST_TRIGGER_INTEGRATION:
        return 3;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum BroadcastTrigger");
    }
  }
  a.broadcastTriggerToNumber = F;
  var z;
  (function(b) {
    b.WEBHOOK_TYPE_UNSPECIFIED = "WEBHOOK_TYPE_UNSPECIFIED", b.WEBHOOK_TYPE_HOOK = "WEBHOOK_TYPE_HOOK", b.WEBHOOK_TYPE_EVENT = "WEBHOOK_TYPE_EVENT";
  })(z = a.WebhookType || (a.WebhookType = {}));
  function j(b) {
    switch (b) {
      case 0:
      case "WEBHOOK_TYPE_UNSPECIFIED":
        return z.WEBHOOK_TYPE_UNSPECIFIED;
      case 1:
      case "WEBHOOK_TYPE_HOOK":
        return z.WEBHOOK_TYPE_HOOK;
      case 2:
      case "WEBHOOK_TYPE_EVENT":
        return z.WEBHOOK_TYPE_EVENT;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum WebhookType");
    }
  }
  a.webhookTypeFromJSON = j;
  function ee(b) {
    switch (b) {
      case z.WEBHOOK_TYPE_UNSPECIFIED:
        return "WEBHOOK_TYPE_UNSPECIFIED";
      case z.WEBHOOK_TYPE_HOOK:
        return "WEBHOOK_TYPE_HOOK";
      case z.WEBHOOK_TYPE_EVENT:
        return "WEBHOOK_TYPE_EVENT";
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum WebhookType");
    }
  }
  a.webhookTypeToJSON = ee;
  function X(b) {
    switch (b) {
      case z.WEBHOOK_TYPE_UNSPECIFIED:
        return 0;
      case z.WEBHOOK_TYPE_HOOK:
        return 1;
      case z.WEBHOOK_TYPE_EVENT:
        return 2;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum WebhookType");
    }
  }
  a.webhookTypeToNumber = X;
  var ae;
  (function(b) {
    b.WEBHOOK_SUBTYPE_UNSPECIFIED = "WEBHOOK_SUBTYPE_UNSPECIFIED", b.WEBHOOK_SUBTYPE_START_BROADCAST = "WEBHOOK_SUBTYPE_START_BROADCAST", b.WEBHOOK_SUBTYPE_START_WEBRTC = "WEBHOOK_SUBTYPE_START_WEBRTC", b.WEBHOOK_SUBTYPE_JOIN_WEBRTC = "WEBHOOK_SUBTYPE_JOIN_WEBRTC";
  })(ae = a.WebhookSubtype || (a.WebhookSubtype = {}));
  function Q(b) {
    switch (b) {
      case 0:
      case "WEBHOOK_SUBTYPE_UNSPECIFIED":
        return ae.WEBHOOK_SUBTYPE_UNSPECIFIED;
      case 1:
      case "WEBHOOK_SUBTYPE_START_BROADCAST":
        return ae.WEBHOOK_SUBTYPE_START_BROADCAST;
      case 2:
      case "WEBHOOK_SUBTYPE_START_WEBRTC":
        return ae.WEBHOOK_SUBTYPE_START_WEBRTC;
      case 3:
      case "WEBHOOK_SUBTYPE_JOIN_WEBRTC":
        return ae.WEBHOOK_SUBTYPE_JOIN_WEBRTC;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum WebhookSubtype");
    }
  }
  a.webhookSubtypeFromJSON = Q;
  function ne(b) {
    switch (b) {
      case ae.WEBHOOK_SUBTYPE_UNSPECIFIED:
        return "WEBHOOK_SUBTYPE_UNSPECIFIED";
      case ae.WEBHOOK_SUBTYPE_START_BROADCAST:
        return "WEBHOOK_SUBTYPE_START_BROADCAST";
      case ae.WEBHOOK_SUBTYPE_START_WEBRTC:
        return "WEBHOOK_SUBTYPE_START_WEBRTC";
      case ae.WEBHOOK_SUBTYPE_JOIN_WEBRTC:
        return "WEBHOOK_SUBTYPE_JOIN_WEBRTC";
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum WebhookSubtype");
    }
  }
  a.webhookSubtypeToJSON = ne;
  function Z(b) {
    switch (b) {
      case ae.WEBHOOK_SUBTYPE_UNSPECIFIED:
        return 0;
      case ae.WEBHOOK_SUBTYPE_START_BROADCAST:
        return 1;
      case ae.WEBHOOK_SUBTYPE_START_WEBRTC:
        return 2;
      case ae.WEBHOOK_SUBTYPE_JOIN_WEBRTC:
        return 3;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum WebhookSubtype");
    }
  }
  a.webhookSubtypeToNumber = Z;
  var de;
  (function(b) {
    b.IMAGE_FORMAT_UNSPECIFIED = "IMAGE_FORMAT_UNSPECIFIED", b.IMAGE_FORMAT_JPEG = "IMAGE_FORMAT_JPEG";
  })(de = a.ImageFormat || (a.ImageFormat = {}));
  function fe(b) {
    switch (b) {
      case 0:
      case "IMAGE_FORMAT_UNSPECIFIED":
        return de.IMAGE_FORMAT_UNSPECIFIED;
      case 1:
      case "IMAGE_FORMAT_JPEG":
        return de.IMAGE_FORMAT_JPEG;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum ImageFormat");
    }
  }
  a.imageFormatFromJSON = fe;
  function Te(b) {
    switch (b) {
      case de.IMAGE_FORMAT_UNSPECIFIED:
        return "IMAGE_FORMAT_UNSPECIFIED";
      case de.IMAGE_FORMAT_JPEG:
        return "IMAGE_FORMAT_JPEG";
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum ImageFormat");
    }
  }
  a.imageFormatToJSON = Te;
  function Re(b) {
    switch (b) {
      case de.IMAGE_FORMAT_UNSPECIFIED:
        return 0;
      case de.IMAGE_FORMAT_JPEG:
        return 1;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum ImageFormat");
    }
  }
  a.imageFormatToNumber = Re;
  var Le;
  (function(b) {
    b.VIDEO_COLOR_SPACE_UNSPECIFIED = "VIDEO_COLOR_SPACE_UNSPECIFIED", b.VIDEO_COLOR_SPACE_YUV420 = "VIDEO_COLOR_SPACE_YUV420";
  })(Le = a.VideoColorSpace || (a.VideoColorSpace = {}));
  function be(b) {
    switch (b) {
      case 0:
      case "VIDEO_COLOR_SPACE_UNSPECIFIED":
        return Le.VIDEO_COLOR_SPACE_UNSPECIFIED;
      case 1:
      case "VIDEO_COLOR_SPACE_YUV420":
        return Le.VIDEO_COLOR_SPACE_YUV420;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum VideoColorSpace");
    }
  }
  a.videoColorSpaceFromJSON = be;
  function q(b) {
    switch (b) {
      case Le.VIDEO_COLOR_SPACE_UNSPECIFIED:
        return "VIDEO_COLOR_SPACE_UNSPECIFIED";
      case Le.VIDEO_COLOR_SPACE_YUV420:
        return "VIDEO_COLOR_SPACE_YUV420";
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum VideoColorSpace");
    }
  }
  a.videoColorSpaceToJSON = q;
  function J(b) {
    switch (b) {
      case Le.VIDEO_COLOR_SPACE_UNSPECIFIED:
        return 0;
      case Le.VIDEO_COLOR_SPACE_YUV420:
        return 1;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum VideoColorSpace");
    }
  }
  a.videoColorSpaceToNumber = J;
  var C;
  (function(b) {
    b.AUDIO_CHANNEL_LAYOUT_UNSPECIFIED = "AUDIO_CHANNEL_LAYOUT_UNSPECIFIED", b.AUDIO_CHANNEL_LAYOUT_STEREO = "AUDIO_CHANNEL_LAYOUT_STEREO";
  })(C = a.AudioChannelLayout || (a.AudioChannelLayout = {}));
  function S(b) {
    switch (b) {
      case 0:
      case "AUDIO_CHANNEL_LAYOUT_UNSPECIFIED":
        return C.AUDIO_CHANNEL_LAYOUT_UNSPECIFIED;
      case 1:
      case "AUDIO_CHANNEL_LAYOUT_STEREO":
        return C.AUDIO_CHANNEL_LAYOUT_STEREO;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum AudioChannelLayout");
    }
  }
  a.audioChannelLayoutFromJSON = S;
  function E(b) {
    switch (b) {
      case C.AUDIO_CHANNEL_LAYOUT_UNSPECIFIED:
        return "AUDIO_CHANNEL_LAYOUT_UNSPECIFIED";
      case C.AUDIO_CHANNEL_LAYOUT_STEREO:
        return "AUDIO_CHANNEL_LAYOUT_STEREO";
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum AudioChannelLayout");
    }
  }
  a.audioChannelLayoutToJSON = E;
  function I(b) {
    switch (b) {
      case C.AUDIO_CHANNEL_LAYOUT_UNSPECIFIED:
        return 0;
      case C.AUDIO_CHANNEL_LAYOUT_STEREO:
        return 1;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum AudioChannelLayout");
    }
  }
  a.audioChannelLayoutToNumber = I;
  var M;
  (function(b) {
    b.RENDERING_QUALITY_UNSPECIFIED = "RENDERING_QUALITY_UNSPECIFIED", b.RENDERING_QUALITY_STANDARD = "RENDERING_QUALITY_STANDARD", b.RENDERING_QUALITY_HIGH = "RENDERING_QUALITY_HIGH";
  })(M = a.RenderingQuality || (a.RenderingQuality = {}));
  function $(b) {
    switch (b) {
      case 0:
      case "RENDERING_QUALITY_UNSPECIFIED":
        return M.RENDERING_QUALITY_UNSPECIFIED;
      case 1:
      case "RENDERING_QUALITY_STANDARD":
        return M.RENDERING_QUALITY_STANDARD;
      case 2:
      case "RENDERING_QUALITY_HIGH":
        return M.RENDERING_QUALITY_HIGH;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum RenderingQuality");
    }
  }
  a.renderingQualityFromJSON = $;
  function U(b) {
    switch (b) {
      case M.RENDERING_QUALITY_UNSPECIFIED:
        return "RENDERING_QUALITY_UNSPECIFIED";
      case M.RENDERING_QUALITY_STANDARD:
        return "RENDERING_QUALITY_STANDARD";
      case M.RENDERING_QUALITY_HIGH:
        return "RENDERING_QUALITY_HIGH";
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum RenderingQuality");
    }
  }
  a.renderingQualityToJSON = U;
  function Y(b) {
    switch (b) {
      case M.RENDERING_QUALITY_UNSPECIFIED:
        return 0;
      case M.RENDERING_QUALITY_STANDARD:
        return 1;
      case M.RENDERING_QUALITY_HIGH:
        return 2;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum RenderingQuality");
    }
  }
  a.renderingQualityToNumber = Y;
  var L;
  (function(b) {
    b.VIDEO_CODEC_UNSPECIFIED = "VIDEO_CODEC_UNSPECIFIED", b.VIDEO_CODEC_H264 = "VIDEO_CODEC_H264";
  })(L = a.VideoCodec || (a.VideoCodec = {}));
  function T(b) {
    switch (b) {
      case 0:
      case "VIDEO_CODEC_UNSPECIFIED":
        return L.VIDEO_CODEC_UNSPECIFIED;
      case 1:
      case "VIDEO_CODEC_H264":
        return L.VIDEO_CODEC_H264;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum VideoCodec");
    }
  }
  a.videoCodecFromJSON = T;
  function B(b) {
    switch (b) {
      case L.VIDEO_CODEC_UNSPECIFIED:
        return "VIDEO_CODEC_UNSPECIFIED";
      case L.VIDEO_CODEC_H264:
        return "VIDEO_CODEC_H264";
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum VideoCodec");
    }
  }
  a.videoCodecToJSON = B;
  function te(b) {
    switch (b) {
      case L.VIDEO_CODEC_UNSPECIFIED:
        return 0;
      case L.VIDEO_CODEC_H264:
        return 1;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum VideoCodec");
    }
  }
  a.videoCodecToNumber = te;
  var pe;
  (function(b) {
    b.VIDEO_CODEC_PROFILE_UNSPECIFIED = "VIDEO_CODEC_PROFILE_UNSPECIFIED", b.VIDEO_CODEC_PROFILE_BASELINE = "VIDEO_CODEC_PROFILE_BASELINE", b.VIDEO_CODEC_PROFILE_MAIN = "VIDEO_CODEC_PROFILE_MAIN", b.VIDEO_CODEC_PROFILE_HIGH = "VIDEO_CODEC_PROFILE_HIGH";
  })(pe = a.VideoCodecProfile || (a.VideoCodecProfile = {}));
  function Ie(b) {
    switch (b) {
      case 0:
      case "VIDEO_CODEC_PROFILE_UNSPECIFIED":
        return pe.VIDEO_CODEC_PROFILE_UNSPECIFIED;
      case 2:
      case "VIDEO_CODEC_PROFILE_BASELINE":
        return pe.VIDEO_CODEC_PROFILE_BASELINE;
      case 3:
      case "VIDEO_CODEC_PROFILE_MAIN":
        return pe.VIDEO_CODEC_PROFILE_MAIN;
      case 4:
      case "VIDEO_CODEC_PROFILE_HIGH":
        return pe.VIDEO_CODEC_PROFILE_HIGH;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum VideoCodecProfile");
    }
  }
  a.videoCodecProfileFromJSON = Ie;
  function $e(b) {
    switch (b) {
      case pe.VIDEO_CODEC_PROFILE_UNSPECIFIED:
        return "VIDEO_CODEC_PROFILE_UNSPECIFIED";
      case pe.VIDEO_CODEC_PROFILE_BASELINE:
        return "VIDEO_CODEC_PROFILE_BASELINE";
      case pe.VIDEO_CODEC_PROFILE_MAIN:
        return "VIDEO_CODEC_PROFILE_MAIN";
      case pe.VIDEO_CODEC_PROFILE_HIGH:
        return "VIDEO_CODEC_PROFILE_HIGH";
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum VideoCodecProfile");
    }
  }
  a.videoCodecProfileToJSON = $e;
  function ve(b) {
    switch (b) {
      case pe.VIDEO_CODEC_PROFILE_UNSPECIFIED:
        return 0;
      case pe.VIDEO_CODEC_PROFILE_BASELINE:
        return 2;
      case pe.VIDEO_CODEC_PROFILE_MAIN:
        return 3;
      case pe.VIDEO_CODEC_PROFILE_HIGH:
        return 4;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum VideoCodecProfile");
    }
  }
  a.videoCodecProfileToNumber = ve;
  var he;
  (function(b) {
    b.AUDIO_CODEC_UNSPECIFIED = "AUDIO_CODEC_UNSPECIFIED", b.AUDIO_CODEC_AAC = "AUDIO_CODEC_AAC";
  })(he = a.AudioCodec || (a.AudioCodec = {}));
  function Oe(b) {
    switch (b) {
      case 0:
      case "AUDIO_CODEC_UNSPECIFIED":
        return he.AUDIO_CODEC_UNSPECIFIED;
      case 1:
      case "AUDIO_CODEC_AAC":
        return he.AUDIO_CODEC_AAC;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum AudioCodec");
    }
  }
  a.audioCodecFromJSON = Oe;
  function Ae(b) {
    switch (b) {
      case he.AUDIO_CODEC_UNSPECIFIED:
        return "AUDIO_CODEC_UNSPECIFIED";
      case he.AUDIO_CODEC_AAC:
        return "AUDIO_CODEC_AAC";
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum AudioCodec");
    }
  }
  a.audioCodecToJSON = Ae;
  function Ue(b) {
    switch (b) {
      case he.AUDIO_CODEC_UNSPECIFIED:
        return 0;
      case he.AUDIO_CODEC_AAC:
        return 1;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum AudioCodec");
    }
  }
  a.audioCodecToNumber = Ue;
  var oe;
  (function(b) {
    b.VIDEO_CODEC_RATE_CONTROL_MODE_UNSPECIFIED = "VIDEO_CODEC_RATE_CONTROL_MODE_UNSPECIFIED", b.VIDEO_CODEC_RATE_CONTROL_MODE_CBR = "VIDEO_CODEC_RATE_CONTROL_MODE_CBR";
  })(oe = a.VideoCodecRateControlMode || (a.VideoCodecRateControlMode = {}));
  function A(b) {
    switch (b) {
      case 0:
      case "VIDEO_CODEC_RATE_CONTROL_MODE_UNSPECIFIED":
        return oe.VIDEO_CODEC_RATE_CONTROL_MODE_UNSPECIFIED;
      case 1:
      case "VIDEO_CODEC_RATE_CONTROL_MODE_CBR":
        return oe.VIDEO_CODEC_RATE_CONTROL_MODE_CBR;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum VideoCodecRateControlMode");
    }
  }
  a.videoCodecRateControlModeFromJSON = A;
  function re(b) {
    switch (b) {
      case oe.VIDEO_CODEC_RATE_CONTROL_MODE_UNSPECIFIED:
        return "VIDEO_CODEC_RATE_CONTROL_MODE_UNSPECIFIED";
      case oe.VIDEO_CODEC_RATE_CONTROL_MODE_CBR:
        return "VIDEO_CODEC_RATE_CONTROL_MODE_CBR";
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum VideoCodecRateControlMode");
    }
  }
  a.videoCodecRateControlModeToJSON = re;
  function le(b) {
    switch (b) {
      case oe.VIDEO_CODEC_RATE_CONTROL_MODE_UNSPECIFIED:
        return 0;
      case oe.VIDEO_CODEC_RATE_CONTROL_MODE_CBR:
        return 1;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum VideoCodecRateControlMode");
    }
  }
  a.videoCodecRateControlModeToNumber = le;
  var Ne;
  (function(b) {
    b.PROJECT_BROADCAST_PHASE_UNSPECIFIED = "PROJECT_BROADCAST_PHASE_UNSPECIFIED", b.PROJECT_BROADCAST_PHASE_NOT_RUNNING = "PROJECT_BROADCAST_PHASE_NOT_RUNNING", b.PROJECT_BROADCAST_PHASE_WAITING = "PROJECT_BROADCAST_PHASE_WAITING", b.PROJECT_BROADCAST_PHASE_STARTING = "PROJECT_BROADCAST_PHASE_STARTING", b.PROJECT_BROADCAST_PHASE_RUNNING = "PROJECT_BROADCAST_PHASE_RUNNING", b.PROJECT_BROADCAST_PHASE_STOPPING = "PROJECT_BROADCAST_PHASE_STOPPING", b.PROJECT_BROADCAST_PHASE_STOPPED = "PROJECT_BROADCAST_PHASE_STOPPED", b.PROJECT_BROADCAST_PHASE_ARCHIVED = "PROJECT_BROADCAST_PHASE_ARCHIVED";
  })(Ne = a.ProjectBroadcastPhase || (a.ProjectBroadcastPhase = {}));
  function Pe(b) {
    switch (b) {
      case 0:
      case "PROJECT_BROADCAST_PHASE_UNSPECIFIED":
        return Ne.PROJECT_BROADCAST_PHASE_UNSPECIFIED;
      case 1:
      case "PROJECT_BROADCAST_PHASE_NOT_RUNNING":
        return Ne.PROJECT_BROADCAST_PHASE_NOT_RUNNING;
      case 2:
      case "PROJECT_BROADCAST_PHASE_WAITING":
        return Ne.PROJECT_BROADCAST_PHASE_WAITING;
      case 3:
      case "PROJECT_BROADCAST_PHASE_STARTING":
        return Ne.PROJECT_BROADCAST_PHASE_STARTING;
      case 4:
      case "PROJECT_BROADCAST_PHASE_RUNNING":
        return Ne.PROJECT_BROADCAST_PHASE_RUNNING;
      case 5:
      case "PROJECT_BROADCAST_PHASE_STOPPING":
        return Ne.PROJECT_BROADCAST_PHASE_STOPPING;
      case 6:
      case "PROJECT_BROADCAST_PHASE_STOPPED":
        return Ne.PROJECT_BROADCAST_PHASE_STOPPED;
      case 7:
      case "PROJECT_BROADCAST_PHASE_ARCHIVED":
        return Ne.PROJECT_BROADCAST_PHASE_ARCHIVED;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum ProjectBroadcastPhase");
    }
  }
  a.projectBroadcastPhaseFromJSON = Pe;
  function Fe(b) {
    switch (b) {
      case Ne.PROJECT_BROADCAST_PHASE_UNSPECIFIED:
        return "PROJECT_BROADCAST_PHASE_UNSPECIFIED";
      case Ne.PROJECT_BROADCAST_PHASE_NOT_RUNNING:
        return "PROJECT_BROADCAST_PHASE_NOT_RUNNING";
      case Ne.PROJECT_BROADCAST_PHASE_WAITING:
        return "PROJECT_BROADCAST_PHASE_WAITING";
      case Ne.PROJECT_BROADCAST_PHASE_STARTING:
        return "PROJECT_BROADCAST_PHASE_STARTING";
      case Ne.PROJECT_BROADCAST_PHASE_RUNNING:
        return "PROJECT_BROADCAST_PHASE_RUNNING";
      case Ne.PROJECT_BROADCAST_PHASE_STOPPING:
        return "PROJECT_BROADCAST_PHASE_STOPPING";
      case Ne.PROJECT_BROADCAST_PHASE_STOPPED:
        return "PROJECT_BROADCAST_PHASE_STOPPED";
      case Ne.PROJECT_BROADCAST_PHASE_ARCHIVED:
        return "PROJECT_BROADCAST_PHASE_ARCHIVED";
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum ProjectBroadcastPhase");
    }
  }
  a.projectBroadcastPhaseToJSON = Fe;
  function je(b) {
    switch (b) {
      case Ne.PROJECT_BROADCAST_PHASE_UNSPECIFIED:
        return 0;
      case Ne.PROJECT_BROADCAST_PHASE_NOT_RUNNING:
        return 1;
      case Ne.PROJECT_BROADCAST_PHASE_WAITING:
        return 2;
      case Ne.PROJECT_BROADCAST_PHASE_STARTING:
        return 3;
      case Ne.PROJECT_BROADCAST_PHASE_RUNNING:
        return 4;
      case Ne.PROJECT_BROADCAST_PHASE_STOPPING:
        return 5;
      case Ne.PROJECT_BROADCAST_PHASE_STOPPED:
        return 6;
      case Ne.PROJECT_BROADCAST_PHASE_ARCHIVED:
        return 7;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum ProjectBroadcastPhase");
    }
  }
  a.projectBroadcastPhaseToNumber = je;
  var qe;
  (function(b) {
    b.S3ACL_UNSPECIFIED = "S3ACL_UNSPECIFIED", b.S3ACL_PRIVATE = "S3ACL_PRIVATE", b.S3ACL_PUBLIC_READ = "S3ACL_PUBLIC_READ", b.S3ACL_PUBLIC_READ_WRITE = "S3ACL_PUBLIC_READ_WRITE", b.S3ACL_AUTHENTICATED_READ = "S3ACL_AUTHENTICATED_READ", b.S3ACL_BUCKET_OWNER_READ = "S3ACL_BUCKET_OWNER_READ", b.S3ACL_BUCKET_OWNER_FULL_CONTROL = "S3ACL_BUCKET_OWNER_FULL_CONTROL";
  })(qe = a.S3ACL || (a.S3ACL = {}));
  function yt(b) {
    switch (b) {
      case 0:
      case "S3ACL_UNSPECIFIED":
        return qe.S3ACL_UNSPECIFIED;
      case 1:
      case "S3ACL_PRIVATE":
        return qe.S3ACL_PRIVATE;
      case 2:
      case "S3ACL_PUBLIC_READ":
        return qe.S3ACL_PUBLIC_READ;
      case 3:
      case "S3ACL_PUBLIC_READ_WRITE":
        return qe.S3ACL_PUBLIC_READ_WRITE;
      case 4:
      case "S3ACL_AUTHENTICATED_READ":
        return qe.S3ACL_AUTHENTICATED_READ;
      case 5:
      case "S3ACL_BUCKET_OWNER_READ":
        return qe.S3ACL_BUCKET_OWNER_READ;
      case 6:
      case "S3ACL_BUCKET_OWNER_FULL_CONTROL":
        return qe.S3ACL_BUCKET_OWNER_FULL_CONTROL;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum S3ACL");
    }
  }
  a.s3ACLFromJSON = yt;
  function Xe(b) {
    switch (b) {
      case qe.S3ACL_UNSPECIFIED:
        return "S3ACL_UNSPECIFIED";
      case qe.S3ACL_PRIVATE:
        return "S3ACL_PRIVATE";
      case qe.S3ACL_PUBLIC_READ:
        return "S3ACL_PUBLIC_READ";
      case qe.S3ACL_PUBLIC_READ_WRITE:
        return "S3ACL_PUBLIC_READ_WRITE";
      case qe.S3ACL_AUTHENTICATED_READ:
        return "S3ACL_AUTHENTICATED_READ";
      case qe.S3ACL_BUCKET_OWNER_READ:
        return "S3ACL_BUCKET_OWNER_READ";
      case qe.S3ACL_BUCKET_OWNER_FULL_CONTROL:
        return "S3ACL_BUCKET_OWNER_FULL_CONTROL";
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum S3ACL");
    }
  }
  a.s3ACLToJSON = Xe;
  function Ge(b) {
    switch (b) {
      case qe.S3ACL_UNSPECIFIED:
        return 0;
      case qe.S3ACL_PRIVATE:
        return 1;
      case qe.S3ACL_PUBLIC_READ:
        return 2;
      case qe.S3ACL_PUBLIC_READ_WRITE:
        return 3;
      case qe.S3ACL_AUTHENTICATED_READ:
        return 4;
      case qe.S3ACL_BUCKET_OWNER_READ:
        return 5;
      case qe.S3ACL_BUCKET_OWNER_FULL_CONTROL:
        return 6;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum S3ACL");
    }
  }
  a.s3ACLToNumber = Ge;
  var H;
  (function(b) {
    b.SOURCE_TRIGGER_ACTION_UNSPECIFIED = "SOURCE_TRIGGER_ACTION_UNSPECIFIED", b.SOURCE_TRIGGER_ACTION_IGNORE = "SOURCE_TRIGGER_ACTION_IGNORE", b.SOURCE_TRIGGER_ACTION_OR = "SOURCE_TRIGGER_ACTION_OR";
  })(H = a.SourceTriggerAction || (a.SourceTriggerAction = {}));
  function ye(b) {
    switch (b) {
      case 0:
      case "SOURCE_TRIGGER_ACTION_UNSPECIFIED":
        return H.SOURCE_TRIGGER_ACTION_UNSPECIFIED;
      case 1:
      case "SOURCE_TRIGGER_ACTION_IGNORE":
        return H.SOURCE_TRIGGER_ACTION_IGNORE;
      case 3:
      case "SOURCE_TRIGGER_ACTION_OR":
        return H.SOURCE_TRIGGER_ACTION_OR;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum SourceTriggerAction");
    }
  }
  a.sourceTriggerActionFromJSON = ye;
  function Ee(b) {
    switch (b) {
      case H.SOURCE_TRIGGER_ACTION_UNSPECIFIED:
        return "SOURCE_TRIGGER_ACTION_UNSPECIFIED";
      case H.SOURCE_TRIGGER_ACTION_IGNORE:
        return "SOURCE_TRIGGER_ACTION_IGNORE";
      case H.SOURCE_TRIGGER_ACTION_OR:
        return "SOURCE_TRIGGER_ACTION_OR";
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum SourceTriggerAction");
    }
  }
  a.sourceTriggerActionToJSON = Ee;
  function We(b) {
    switch (b) {
      case H.SOURCE_TRIGGER_ACTION_UNSPECIFIED:
        return 0;
      case H.SOURCE_TRIGGER_ACTION_IGNORE:
        return 1;
      case H.SOURCE_TRIGGER_ACTION_OR:
        return 3;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum SourceTriggerAction");
    }
  }
  a.sourceTriggerActionToNumber = We;
  var we;
  (function(b) {
    b.REGION_UNSPECIFIED = "REGION_UNSPECIFIED", b.REGION_US_EAST_1 = "REGION_US_EAST_1", b.REGION_US_EAST_2 = "REGION_US_EAST_2", b.REGION_US_WEST_1 = "REGION_US_WEST_1", b.REGION_US_WEST_2 = "REGION_US_WEST_2", b.REGION_US_CENTRAL_1 = "REGION_US_CENTRAL_1", b.REGION_AP_SOUTHEAST_1 = "REGION_AP_SOUTHEAST_1", b.REGION_AP_SOUTHEAST_2 = "REGION_AP_SOUTHEAST_2", b.REGION_AP_SOUTH_1 = "REGION_AP_SOUTH_1", b.REGION_CA_EAST_1 = "REGION_CA_EAST_1", b.REGION_EU_CENTRAL_1 = "REGION_EU_CENTRAL_1", b.REGION_EU_WEST_1 = "REGION_EU_WEST_1";
  })(we = a.Region || (a.Region = {}));
  function V(b) {
    switch (b) {
      case 0:
      case "REGION_UNSPECIFIED":
        return we.REGION_UNSPECIFIED;
      case 1:
      case "REGION_US_EAST_1":
        return we.REGION_US_EAST_1;
      case 2:
      case "REGION_US_EAST_2":
        return we.REGION_US_EAST_2;
      case 3:
      case "REGION_US_WEST_1":
        return we.REGION_US_WEST_1;
      case 4:
      case "REGION_US_WEST_2":
        return we.REGION_US_WEST_2;
      case 5:
      case "REGION_US_CENTRAL_1":
        return we.REGION_US_CENTRAL_1;
      case 10:
      case "REGION_AP_SOUTHEAST_1":
        return we.REGION_AP_SOUTHEAST_1;
      case 11:
      case "REGION_AP_SOUTHEAST_2":
        return we.REGION_AP_SOUTHEAST_2;
      case 15:
      case "REGION_AP_SOUTH_1":
        return we.REGION_AP_SOUTH_1;
      case 20:
      case "REGION_CA_EAST_1":
        return we.REGION_CA_EAST_1;
      case 30:
      case "REGION_EU_CENTRAL_1":
        return we.REGION_EU_CENTRAL_1;
      case 31:
      case "REGION_EU_WEST_1":
        return we.REGION_EU_WEST_1;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum Region");
    }
  }
  a.regionFromJSON = V;
  function _e(b) {
    switch (b) {
      case we.REGION_UNSPECIFIED:
        return "REGION_UNSPECIFIED";
      case we.REGION_US_EAST_1:
        return "REGION_US_EAST_1";
      case we.REGION_US_EAST_2:
        return "REGION_US_EAST_2";
      case we.REGION_US_WEST_1:
        return "REGION_US_WEST_1";
      case we.REGION_US_WEST_2:
        return "REGION_US_WEST_2";
      case we.REGION_US_CENTRAL_1:
        return "REGION_US_CENTRAL_1";
      case we.REGION_AP_SOUTHEAST_1:
        return "REGION_AP_SOUTHEAST_1";
      case we.REGION_AP_SOUTHEAST_2:
        return "REGION_AP_SOUTHEAST_2";
      case we.REGION_AP_SOUTH_1:
        return "REGION_AP_SOUTH_1";
      case we.REGION_CA_EAST_1:
        return "REGION_CA_EAST_1";
      case we.REGION_EU_CENTRAL_1:
        return "REGION_EU_CENTRAL_1";
      case we.REGION_EU_WEST_1:
        return "REGION_EU_WEST_1";
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum Region");
    }
  }
  a.regionToJSON = _e;
  function ue(b) {
    switch (b) {
      case we.REGION_UNSPECIFIED:
        return 0;
      case we.REGION_US_EAST_1:
        return 1;
      case we.REGION_US_EAST_2:
        return 2;
      case we.REGION_US_WEST_1:
        return 3;
      case we.REGION_US_WEST_2:
        return 4;
      case we.REGION_US_CENTRAL_1:
        return 5;
      case we.REGION_AP_SOUTHEAST_1:
        return 10;
      case we.REGION_AP_SOUTHEAST_2:
        return 11;
      case we.REGION_AP_SOUTH_1:
        return 15;
      case we.REGION_CA_EAST_1:
        return 20;
      case we.REGION_EU_CENTRAL_1:
        return 30;
      case we.REGION_EU_WEST_1:
        return 31;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum Region");
    }
  }
  a.regionToNumber = ue;
  var ce;
  (function(b) {
    b.ROLE_UNSPECIFIED = "ROLE_UNSPECIFIED", b.ROLE_HOST = "ROLE_HOST", b.ROLE_COHOST = "ROLE_COHOST", b.ROLE_CONTRIBUTOR = "ROLE_CONTRIBUTOR", b.ROLE_GUEST = "ROLE_GUEST", b.ROLE_VIEWER = "ROLE_VIEWER", b.ROLE_RENDERER = "ROLE_RENDERER", b.ROLE_PLATFORM = "ROLE_PLATFORM", b.ROLE_IMPERSONATE = "ROLE_IMPERSONATE";
  })(ce = a.Role || (a.Role = {}));
  function me(b) {
    switch (b) {
      case 0:
      case "ROLE_UNSPECIFIED":
        return ce.ROLE_UNSPECIFIED;
      case 1:
      case "ROLE_HOST":
        return ce.ROLE_HOST;
      case 2:
      case "ROLE_COHOST":
        return ce.ROLE_COHOST;
      case 3:
      case "ROLE_CONTRIBUTOR":
        return ce.ROLE_CONTRIBUTOR;
      case 4:
      case "ROLE_GUEST":
        return ce.ROLE_GUEST;
      case 5:
      case "ROLE_VIEWER":
        return ce.ROLE_VIEWER;
      case 6:
      case "ROLE_RENDERER":
        return ce.ROLE_RENDERER;
      case 7:
      case "ROLE_PLATFORM":
        return ce.ROLE_PLATFORM;
      case 8:
      case "ROLE_IMPERSONATE":
        return ce.ROLE_IMPERSONATE;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum Role");
    }
  }
  a.roleFromJSON = me;
  function Ce(b) {
    switch (b) {
      case ce.ROLE_UNSPECIFIED:
        return "ROLE_UNSPECIFIED";
      case ce.ROLE_HOST:
        return "ROLE_HOST";
      case ce.ROLE_COHOST:
        return "ROLE_COHOST";
      case ce.ROLE_CONTRIBUTOR:
        return "ROLE_CONTRIBUTOR";
      case ce.ROLE_GUEST:
        return "ROLE_GUEST";
      case ce.ROLE_VIEWER:
        return "ROLE_VIEWER";
      case ce.ROLE_RENDERER:
        return "ROLE_RENDERER";
      case ce.ROLE_PLATFORM:
        return "ROLE_PLATFORM";
      case ce.ROLE_IMPERSONATE:
        return "ROLE_IMPERSONATE";
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum Role");
    }
  }
  a.roleToJSON = Ce;
  function Be(b) {
    switch (b) {
      case ce.ROLE_UNSPECIFIED:
        return 0;
      case ce.ROLE_HOST:
        return 1;
      case ce.ROLE_COHOST:
        return 2;
      case ce.ROLE_CONTRIBUTOR:
        return 3;
      case ce.ROLE_GUEST:
        return 4;
      case ce.ROLE_VIEWER:
        return 5;
      case ce.ROLE_RENDERER:
        return 6;
      case ce.ROLE_PLATFORM:
        return 7;
      case ce.ROLE_IMPERSONATE:
        return 8;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum Role");
    }
  }
  a.roleToNumber = Be;
  var ze;
  (function(b) {
    b.PROJECT_BROADCAST_ERROR_UNSPECIFIED = "PROJECT_BROADCAST_ERROR_UNSPECIFIED", b.PROJECT_BROADCAST_ERROR_INTERNAL = "PROJECT_BROADCAST_ERROR_INTERNAL", b.PROJECT_BROADCAST_ERROR_DURATION_EXCEEDED = "PROJECT_BROADCAST_ERROR_DURATION_EXCEEDED";
  })(ze = a.ProjectBroadcastError || (a.ProjectBroadcastError = {}));
  function Je(b) {
    switch (b) {
      case 0:
      case "PROJECT_BROADCAST_ERROR_UNSPECIFIED":
        return ze.PROJECT_BROADCAST_ERROR_UNSPECIFIED;
      case 1:
      case "PROJECT_BROADCAST_ERROR_INTERNAL":
        return ze.PROJECT_BROADCAST_ERROR_INTERNAL;
      case 2:
      case "PROJECT_BROADCAST_ERROR_DURATION_EXCEEDED":
        return ze.PROJECT_BROADCAST_ERROR_DURATION_EXCEEDED;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum ProjectBroadcastError");
    }
  }
  a.projectBroadcastErrorFromJSON = Je;
  function Ze(b) {
    switch (b) {
      case ze.PROJECT_BROADCAST_ERROR_UNSPECIFIED:
        return "PROJECT_BROADCAST_ERROR_UNSPECIFIED";
      case ze.PROJECT_BROADCAST_ERROR_INTERNAL:
        return "PROJECT_BROADCAST_ERROR_INTERNAL";
      case ze.PROJECT_BROADCAST_ERROR_DURATION_EXCEEDED:
        return "PROJECT_BROADCAST_ERROR_DURATION_EXCEEDED";
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum ProjectBroadcastError");
    }
  }
  a.projectBroadcastErrorToJSON = Ze;
  function Ke(b) {
    switch (b) {
      case ze.PROJECT_BROADCAST_ERROR_UNSPECIFIED:
        return 0;
      case ze.PROJECT_BROADCAST_ERROR_INTERNAL:
        return 1;
      case ze.PROJECT_BROADCAST_ERROR_DURATION_EXCEEDED:
        return 2;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum ProjectBroadcastError");
    }
  }
  a.projectBroadcastErrorToNumber = Ke;
  var x;
  (function(b) {
    b.CONNECT_STATE_UNSPECIFIED = "CONNECT_STATE_UNSPECIFIED", b.CONNECT_STATE_CONNECTED = "CONNECT_STATE_CONNECTED", b.CONNECT_STATE_DISCONNECTED = "CONNECT_STATE_DISCONNECTED";
  })(x = a.ConnectState || (a.ConnectState = {}));
  function se(b) {
    switch (b) {
      case 0:
      case "CONNECT_STATE_UNSPECIFIED":
        return x.CONNECT_STATE_UNSPECIFIED;
      case 1:
      case "CONNECT_STATE_CONNECTED":
        return x.CONNECT_STATE_CONNECTED;
      case 2:
      case "CONNECT_STATE_DISCONNECTED":
        return x.CONNECT_STATE_DISCONNECTED;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum ConnectState");
    }
  }
  a.connectStateFromJSON = se;
  function ge(b) {
    switch (b) {
      case x.CONNECT_STATE_UNSPECIFIED:
        return "CONNECT_STATE_UNSPECIFIED";
      case x.CONNECT_STATE_CONNECTED:
        return "CONNECT_STATE_CONNECTED";
      case x.CONNECT_STATE_DISCONNECTED:
        return "CONNECT_STATE_DISCONNECTED";
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum ConnectState");
    }
  }
  a.connectStateToJSON = ge;
  function xe(b) {
    switch (b) {
      case x.CONNECT_STATE_UNSPECIFIED:
        return 0;
      case x.CONNECT_STATE_CONNECTED:
        return 1;
      case x.CONNECT_STATE_DISCONNECTED:
        return 2;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum ConnectState");
    }
  }
  a.connectStateToNumber = xe;
  var Me;
  (function(b) {
    b.EVENT_SUB_TYPE_UNSPECIFIED = "EVENT_SUB_TYPE_UNSPECIFIED", b.EVENT_SUB_TYPE_CREATE = "EVENT_SUB_TYPE_CREATE", b.EVENT_SUB_TYPE_UPDATE = "EVENT_SUB_TYPE_UPDATE", b.EVENT_SUB_TYPE_DELETE = "EVENT_SUB_TYPE_DELETE", b.EVENT_SUB_TYPE_ADD = "EVENT_SUB_TYPE_ADD", b.EVENT_SUB_TYPE_REMOVE = "EVENT_SUB_TYPE_REMOVE", b.EVENT_SUB_TYPE_STATE = "EVENT_SUB_TYPE_STATE";
  })(Me = a.EventSubType || (a.EventSubType = {}));
  function Ye(b) {
    switch (b) {
      case 0:
      case "EVENT_SUB_TYPE_UNSPECIFIED":
        return Me.EVENT_SUB_TYPE_UNSPECIFIED;
      case 1:
      case "EVENT_SUB_TYPE_CREATE":
        return Me.EVENT_SUB_TYPE_CREATE;
      case 2:
      case "EVENT_SUB_TYPE_UPDATE":
        return Me.EVENT_SUB_TYPE_UPDATE;
      case 3:
      case "EVENT_SUB_TYPE_DELETE":
        return Me.EVENT_SUB_TYPE_DELETE;
      case 4:
      case "EVENT_SUB_TYPE_ADD":
        return Me.EVENT_SUB_TYPE_ADD;
      case 5:
      case "EVENT_SUB_TYPE_REMOVE":
        return Me.EVENT_SUB_TYPE_REMOVE;
      case 6:
      case "EVENT_SUB_TYPE_STATE":
        return Me.EVENT_SUB_TYPE_STATE;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum EventSubType");
    }
  }
  a.eventSubTypeFromJSON = Ye;
  function et(b) {
    switch (b) {
      case Me.EVENT_SUB_TYPE_UNSPECIFIED:
        return "EVENT_SUB_TYPE_UNSPECIFIED";
      case Me.EVENT_SUB_TYPE_CREATE:
        return "EVENT_SUB_TYPE_CREATE";
      case Me.EVENT_SUB_TYPE_UPDATE:
        return "EVENT_SUB_TYPE_UPDATE";
      case Me.EVENT_SUB_TYPE_DELETE:
        return "EVENT_SUB_TYPE_DELETE";
      case Me.EVENT_SUB_TYPE_ADD:
        return "EVENT_SUB_TYPE_ADD";
      case Me.EVENT_SUB_TYPE_REMOVE:
        return "EVENT_SUB_TYPE_REMOVE";
      case Me.EVENT_SUB_TYPE_STATE:
        return "EVENT_SUB_TYPE_STATE";
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum EventSubType");
    }
  }
  a.eventSubTypeToJSON = et;
  function dt(b) {
    switch (b) {
      case Me.EVENT_SUB_TYPE_UNSPECIFIED:
        return 0;
      case Me.EVENT_SUB_TYPE_CREATE:
        return 1;
      case Me.EVENT_SUB_TYPE_UPDATE:
        return 2;
      case Me.EVENT_SUB_TYPE_DELETE:
        return 3;
      case Me.EVENT_SUB_TYPE_ADD:
        return 4;
      case Me.EVENT_SUB_TYPE_REMOVE:
        return 5;
      case Me.EVENT_SUB_TYPE_STATE:
        return 6;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum EventSubType");
    }
  }
  a.eventSubTypeToNumber = dt;
  var St;
  (function(b) {
    b.EVENT_TYPE_UNSPECIFIED = "EVENT_TYPE_UNSPECIFIED", b.EVENT_TYPE_COLLECTION = "EVENT_TYPE_COLLECTION", b.EVENT_TYPE_PROJECT = "EVENT_TYPE_PROJECT", b.EVENT_TYPE_SOURCE = "EVENT_TYPE_SOURCE", b.EVENT_TYPE_DESTINATION = "EVENT_TYPE_DESTINATION";
  })(St = a.EventType || (a.EventType = {}));
  function tt(b) {
    switch (b) {
      case 0:
      case "EVENT_TYPE_UNSPECIFIED":
        return St.EVENT_TYPE_UNSPECIFIED;
      case 1:
      case "EVENT_TYPE_COLLECTION":
        return St.EVENT_TYPE_COLLECTION;
      case 2:
      case "EVENT_TYPE_PROJECT":
        return St.EVENT_TYPE_PROJECT;
      case 4:
      case "EVENT_TYPE_SOURCE":
        return St.EVENT_TYPE_SOURCE;
      case 5:
      case "EVENT_TYPE_DESTINATION":
        return St.EVENT_TYPE_DESTINATION;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum EventType");
    }
  }
  a.eventTypeFromJSON = tt;
  function at(b) {
    switch (b) {
      case St.EVENT_TYPE_UNSPECIFIED:
        return "EVENT_TYPE_UNSPECIFIED";
      case St.EVENT_TYPE_COLLECTION:
        return "EVENT_TYPE_COLLECTION";
      case St.EVENT_TYPE_PROJECT:
        return "EVENT_TYPE_PROJECT";
      case St.EVENT_TYPE_SOURCE:
        return "EVENT_TYPE_SOURCE";
      case St.EVENT_TYPE_DESTINATION:
        return "EVENT_TYPE_DESTINATION";
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum EventType");
    }
  }
  a.eventTypeToJSON = at;
  function kt(b) {
    switch (b) {
      case St.EVENT_TYPE_UNSPECIFIED:
        return 0;
      case St.EVENT_TYPE_COLLECTION:
        return 1;
      case St.EVENT_TYPE_PROJECT:
        return 2;
      case St.EVENT_TYPE_SOURCE:
        return 4;
      case St.EVENT_TYPE_DESTINATION:
        return 5;
      default:
        throw new _t.Error("Unrecognized enum value " + b + " for enum EventType");
    }
  }
  a.eventTypeToNumber = kt;
  function rt() {
    return { userId: "", collectionId: "", projectId: "", triggerMetadata: void 0, trigger: void 0 };
  }
  a.WebhookRequest = {
    encode(b, P = c.default.Writer.create()) {
      return b.userId !== "" && P.uint32(10).string(b.userId), b.collectionId !== "" && P.uint32(18).string(b.collectionId), b.projectId !== "" && P.uint32(26).string(b.projectId), b.triggerMetadata !== void 0 && p.Value.encode(p.Value.wrap(b.triggerMetadata), P.uint32(34).fork()).ldelim(), b.trigger !== void 0 && P.uint32(40).int32(F(b.trigger)), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = rt();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.userId = N.string();
            break;
          case 2:
            ie.collectionId = N.string();
            break;
          case 3:
            ie.projectId = N.string();
            break;
          case 4:
            ie.triggerMetadata = p.Value.unwrap(p.Value.decode(N, N.uint32()));
            break;
          case 5:
            ie.trigger = O(N.int32());
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        userId: De(b.userId) ? String(b.userId) : "",
        collectionId: De(b.collectionId) ? String(b.collectionId) : "",
        projectId: De(b.projectId) ? String(b.projectId) : "",
        triggerMetadata: De(b == null ? void 0 : b.triggerMetadata) ? b.triggerMetadata : void 0,
        trigger: De(b.trigger) ? O(b.trigger) : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.userId !== void 0 && (P.userId = b.userId), b.collectionId !== void 0 && (P.collectionId = b.collectionId), b.projectId !== void 0 && (P.projectId = b.projectId), b.triggerMetadata !== void 0 && (P.triggerMetadata = b.triggerMetadata), b.trigger !== void 0 && (P.trigger = b.trigger !== void 0 ? D(b.trigger) : void 0), P;
    },
    fromPartial(b) {
      var P, N, Se, ie, ke;
      const gt = rt();
      return gt.userId = (P = b.userId) !== null && P !== void 0 ? P : "", gt.collectionId = (N = b.collectionId) !== null && N !== void 0 ? N : "", gt.projectId = (Se = b.projectId) !== null && Se !== void 0 ? Se : "", gt.triggerMetadata = (ie = b.triggerMetadata) !== null && ie !== void 0 ? ie : void 0, gt.trigger = (ke = b.trigger) !== null && ke !== void 0 ? ke : void 0, gt;
    }
  };
  function ut() {
    return {};
  }
  a.WebhookResponse = {
    encode(b, P = c.default.Writer.create()) {
      return P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = ut();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {};
    },
    toJSON(b) {
      return {};
    },
    fromPartial(b) {
      return ut();
    }
  };
  function wt() {
    return { enabled: !1, url: "", timeoutMs: void 0 };
  }
  a.WebhookConfiguration = {
    encode(b, P = c.default.Writer.create()) {
      return b.enabled === !0 && P.uint32(8).bool(b.enabled), b.url !== "" && P.uint32(18).string(b.url), b.timeoutMs !== void 0 && P.uint32(24).uint32(b.timeoutMs), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = wt();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.enabled = N.bool();
            break;
          case 2:
            ie.url = N.string();
            break;
          case 3:
            ie.timeoutMs = N.uint32();
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        enabled: De(b.enabled) ? !!b.enabled : !1,
        url: De(b.url) ? String(b.url) : "",
        timeoutMs: De(b.timeoutMs) ? Number(b.timeoutMs) : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.enabled !== void 0 && (P.enabled = b.enabled), b.url !== void 0 && (P.url = b.url), b.timeoutMs !== void 0 && (P.timeoutMs = Math.round(b.timeoutMs)), P;
    },
    fromPartial(b) {
      var P, N, Se;
      const ie = wt();
      return ie.enabled = (P = b.enabled) !== null && P !== void 0 ? P : !1, ie.url = (N = b.url) !== null && N !== void 0 ? N : "", ie.timeoutMs = (Se = b.timeoutMs) !== null && Se !== void 0 ? Se : void 0, ie;
    }
  };
  function nt() {
    return { startBroadcast: void 0, startWebrtc: void 0, joinWebrtc: void 0 };
  }
  a.AccountConfigurationHook = {
    encode(b, P = c.default.Writer.create()) {
      return b.startBroadcast !== void 0 && a.WebhookConfiguration.encode(b.startBroadcast, P.uint32(10).fork()).ldelim(), b.startWebrtc !== void 0 && a.WebhookConfiguration.encode(b.startWebrtc, P.uint32(18).fork()).ldelim(), b.joinWebrtc !== void 0 && a.WebhookConfiguration.encode(b.joinWebrtc, P.uint32(26).fork()).ldelim(), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = nt();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.startBroadcast = a.WebhookConfiguration.decode(N, N.uint32());
            break;
          case 2:
            ie.startWebrtc = a.WebhookConfiguration.decode(N, N.uint32());
            break;
          case 3:
            ie.joinWebrtc = a.WebhookConfiguration.decode(N, N.uint32());
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        startBroadcast: De(b.startBroadcast) ? a.WebhookConfiguration.fromJSON(b.startBroadcast) : void 0,
        startWebrtc: De(b.startWebrtc) ? a.WebhookConfiguration.fromJSON(b.startWebrtc) : void 0,
        joinWebrtc: De(b.joinWebrtc) ? a.WebhookConfiguration.fromJSON(b.joinWebrtc) : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.startBroadcast !== void 0 && (P.startBroadcast = b.startBroadcast ? a.WebhookConfiguration.toJSON(b.startBroadcast) : void 0), b.startWebrtc !== void 0 && (P.startWebrtc = b.startWebrtc ? a.WebhookConfiguration.toJSON(b.startWebrtc) : void 0), b.joinWebrtc !== void 0 && (P.joinWebrtc = b.joinWebrtc ? a.WebhookConfiguration.toJSON(b.joinWebrtc) : void 0), P;
    },
    fromPartial(b) {
      const P = nt();
      return P.startBroadcast = b.startBroadcast !== void 0 && b.startBroadcast !== null ? a.WebhookConfiguration.fromPartial(b.startBroadcast) : void 0, P.startWebrtc = b.startWebrtc !== void 0 && b.startWebrtc !== null ? a.WebhookConfiguration.fromPartial(b.startWebrtc) : void 0, P.joinWebrtc = b.joinWebrtc !== void 0 && b.joinWebrtc !== null ? a.WebhookConfiguration.fromPartial(b.joinWebrtc) : void 0, P;
    }
  };
  function it() {
    return { broadcastConcurrency: void 0, hooks: void 0 };
  }
  a.AccountConfiguration = {
    encode(b, P = c.default.Writer.create()) {
      return b.broadcastConcurrency !== void 0 && P.uint32(16).int32(b.broadcastConcurrency), b.hooks !== void 0 && a.AccountConfigurationHook.encode(b.hooks, P.uint32(26).fork()).ldelim(), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = it();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 2:
            ie.broadcastConcurrency = N.int32();
            break;
          case 3:
            ie.hooks = a.AccountConfigurationHook.decode(N, N.uint32());
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        broadcastConcurrency: De(b.broadcastConcurrency) ? Number(b.broadcastConcurrency) : void 0,
        hooks: De(b.hooks) ? a.AccountConfigurationHook.fromJSON(b.hooks) : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.broadcastConcurrency !== void 0 && (P.broadcastConcurrency = Math.round(b.broadcastConcurrency)), b.hooks !== void 0 && (P.hooks = b.hooks ? a.AccountConfigurationHook.toJSON(b.hooks) : void 0), P;
    },
    fromPartial(b) {
      var P;
      const N = it();
      return N.broadcastConcurrency = (P = b.broadcastConcurrency) !== null && P !== void 0 ? P : void 0, N.hooks = b.hooks !== void 0 && b.hooks !== null ? a.AccountConfigurationHook.fromPartial(b.hooks) : void 0, N;
    }
  };
  function bt() {
    return {};
  }
  a.GetAccountConfigurationRequest = {
    encode(b, P = c.default.Writer.create()) {
      return P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = bt();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {};
    },
    toJSON(b) {
      return {};
    },
    fromPartial(b) {
      return bt();
    }
  };
  function ot() {
    return { accountConfiguration: void 0 };
  }
  a.GetAccountConfigurationResponse = {
    encode(b, P = c.default.Writer.create()) {
      return b.accountConfiguration !== void 0 && a.AccountConfiguration.encode(b.accountConfiguration, P.uint32(10).fork()).ldelim(), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = ot();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.accountConfiguration = a.AccountConfiguration.decode(N, N.uint32());
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        accountConfiguration: De(b.accountConfiguration) ? a.AccountConfiguration.fromJSON(b.accountConfiguration) : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.accountConfiguration !== void 0 && (P.accountConfiguration = b.accountConfiguration ? a.AccountConfiguration.toJSON(b.accountConfiguration) : void 0), P;
    },
    fromPartial(b) {
      const P = ot();
      return P.accountConfiguration = b.accountConfiguration !== void 0 && b.accountConfiguration !== null ? a.AccountConfiguration.fromPartial(b.accountConfiguration) : void 0, P;
    }
  };
  function ct() {
    return { broadcastConcurrency: void 0, hooks: void 0, updateMask: void 0 };
  }
  a.UpdateAccountConfigurationRequest = {
    encode(b, P = c.default.Writer.create()) {
      return b.broadcastConcurrency !== void 0 && P.uint32(16).int32(b.broadcastConcurrency), b.hooks !== void 0 && a.AccountConfigurationHook.encode(b.hooks, P.uint32(26).fork()).ldelim(), b.updateMask !== void 0 && v.FieldMask.encode(v.FieldMask.wrap(b.updateMask), P.uint32(34).fork()).ldelim(), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = ct();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 2:
            ie.broadcastConcurrency = N.int32();
            break;
          case 3:
            ie.hooks = a.AccountConfigurationHook.decode(N, N.uint32());
            break;
          case 4:
            ie.updateMask = v.FieldMask.unwrap(v.FieldMask.decode(N, N.uint32()));
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        broadcastConcurrency: De(b.broadcastConcurrency) ? Number(b.broadcastConcurrency) : void 0,
        hooks: De(b.hooks) ? a.AccountConfigurationHook.fromJSON(b.hooks) : void 0,
        updateMask: De(b.updateMask) ? v.FieldMask.unwrap(v.FieldMask.fromJSON(b.updateMask)) : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.broadcastConcurrency !== void 0 && (P.broadcastConcurrency = Math.round(b.broadcastConcurrency)), b.hooks !== void 0 && (P.hooks = b.hooks ? a.AccountConfigurationHook.toJSON(b.hooks) : void 0), b.updateMask !== void 0 && (P.updateMask = v.FieldMask.toJSON(v.FieldMask.wrap(b.updateMask))), P;
    },
    fromPartial(b) {
      var P, N;
      const Se = ct();
      return Se.broadcastConcurrency = (P = b.broadcastConcurrency) !== null && P !== void 0 ? P : void 0, Se.hooks = b.hooks !== void 0 && b.hooks !== null ? a.AccountConfigurationHook.fromPartial(b.hooks) : void 0, Se.updateMask = (N = b.updateMask) !== null && N !== void 0 ? N : void 0, Se;
    }
  };
  function Pt() {
    return { accountConfiguration: void 0 };
  }
  a.UpdateAccountConfigurationResponse = {
    encode(b, P = c.default.Writer.create()) {
      return b.accountConfiguration !== void 0 && a.AccountConfiguration.encode(b.accountConfiguration, P.uint32(10).fork()).ldelim(), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = Pt();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.accountConfiguration = a.AccountConfiguration.decode(N, N.uint32());
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        accountConfiguration: De(b.accountConfiguration) ? a.AccountConfiguration.fromJSON(b.accountConfiguration) : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.accountConfiguration !== void 0 && (P.accountConfiguration = b.accountConfiguration ? a.AccountConfiguration.toJSON(b.accountConfiguration) : void 0), P;
    },
    fromPartial(b) {
      const P = Pt();
      return P.accountConfiguration = b.accountConfiguration !== void 0 && b.accountConfiguration !== null ? a.AccountConfiguration.fromPartial(b.accountConfiguration) : void 0, P;
    }
  };
  function st() {
    return { height: void 0, width: void 0, framerate: void 0, colorSpace: void 0 };
  }
  a.VideoRendering = {
    encode(b, P = c.default.Writer.create()) {
      return b.height !== void 0 && P.uint32(8).uint32(b.height), b.width !== void 0 && P.uint32(16).uint32(b.width), b.framerate !== void 0 && P.uint32(29).float(b.framerate), b.colorSpace !== void 0 && P.uint32(32).int32(J(b.colorSpace)), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = st();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.height = N.uint32();
            break;
          case 2:
            ie.width = N.uint32();
            break;
          case 3:
            ie.framerate = N.float();
            break;
          case 4:
            ie.colorSpace = be(N.int32());
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        height: De(b.height) ? Number(b.height) : void 0,
        width: De(b.width) ? Number(b.width) : void 0,
        framerate: De(b.framerate) ? Number(b.framerate) : void 0,
        colorSpace: De(b.colorSpace) ? be(b.colorSpace) : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.height !== void 0 && (P.height = Math.round(b.height)), b.width !== void 0 && (P.width = Math.round(b.width)), b.framerate !== void 0 && (P.framerate = b.framerate), b.colorSpace !== void 0 && (P.colorSpace = b.colorSpace !== void 0 ? q(b.colorSpace) : void 0), P;
    },
    fromPartial(b) {
      var P, N, Se, ie;
      const ke = st();
      return ke.height = (P = b.height) !== null && P !== void 0 ? P : void 0, ke.width = (N = b.width) !== null && N !== void 0 ? N : void 0, ke.framerate = (Se = b.framerate) !== null && Se !== void 0 ? Se : void 0, ke.colorSpace = (ie = b.colorSpace) !== null && ie !== void 0 ? ie : void 0, ke;
    }
  };
  function lt() {
    return { channelLayout: void 0 };
  }
  a.AudioRendering = {
    encode(b, P = c.default.Writer.create()) {
      return b.channelLayout !== void 0 && P.uint32(8).int32(I(b.channelLayout)), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = lt();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.channelLayout = S(N.int32());
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        channelLayout: De(b.channelLayout) ? S(b.channelLayout) : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.channelLayout !== void 0 && (P.channelLayout = b.channelLayout !== void 0 ? E(b.channelLayout) : void 0), P;
    },
    fromPartial(b) {
      var P;
      const N = lt();
      return N.channelLayout = (P = b.channelLayout) !== null && P !== void 0 ? P : void 0, N;
    }
  };
  function It() {
    return { video: void 0, audio: void 0, quality: void 0, targetLatency: void 0, complexity: void 0 };
  }
  a.Rendering = {
    encode(b, P = c.default.Writer.create()) {
      return b.video !== void 0 && a.VideoRendering.encode(b.video, P.uint32(10).fork()).ldelim(), b.audio !== void 0 && a.AudioRendering.encode(b.audio, P.uint32(18).fork()).ldelim(), b.quality !== void 0 && P.uint32(24).int32(Y(b.quality)), b.targetLatency !== void 0 && P.uint32(32).uint32(b.targetLatency), b.complexity !== void 0 && P.uint32(40).int32(b.complexity), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = It();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.video = a.VideoRendering.decode(N, N.uint32());
            break;
          case 2:
            ie.audio = a.AudioRendering.decode(N, N.uint32());
            break;
          case 3:
            ie.quality = $(N.int32());
            break;
          case 4:
            ie.targetLatency = N.uint32();
            break;
          case 5:
            ie.complexity = N.int32();
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        video: De(b.video) ? a.VideoRendering.fromJSON(b.video) : void 0,
        audio: De(b.audio) ? a.AudioRendering.fromJSON(b.audio) : void 0,
        quality: De(b.quality) ? $(b.quality) : void 0,
        targetLatency: De(b.targetLatency) ? Number(b.targetLatency) : void 0,
        complexity: De(b.complexity) ? Number(b.complexity) : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.video !== void 0 && (P.video = b.video ? a.VideoRendering.toJSON(b.video) : void 0), b.audio !== void 0 && (P.audio = b.audio ? a.AudioRendering.toJSON(b.audio) : void 0), b.quality !== void 0 && (P.quality = b.quality !== void 0 ? U(b.quality) : void 0), b.targetLatency !== void 0 && (P.targetLatency = Math.round(b.targetLatency)), b.complexity !== void 0 && (P.complexity = Math.round(b.complexity)), P;
    },
    fromPartial(b) {
      var P, N, Se;
      const ie = It();
      return ie.video = b.video !== void 0 && b.video !== null ? a.VideoRendering.fromPartial(b.video) : void 0, ie.audio = b.audio !== void 0 && b.audio !== null ? a.AudioRendering.fromPartial(b.audio) : void 0, ie.quality = (P = b.quality) !== null && P !== void 0 ? P : void 0, ie.targetLatency = (N = b.targetLatency) !== null && N !== void 0 ? N : void 0, ie.complexity = (Se = b.complexity) !== null && Se !== void 0 ? Se : void 0, ie;
    }
  };
  function Rt() {
    return { mode: void 0, targetBitrate: void 0, maxKeyFrameInterval: void 0 };
  }
  a.VideoCodecRateControl = {
    encode(b, P = c.default.Writer.create()) {
      return b.mode !== void 0 && P.uint32(8).int32(le(b.mode)), b.targetBitrate !== void 0 && P.uint32(16).uint32(b.targetBitrate), b.maxKeyFrameInterval !== void 0 && P.uint32(24).uint32(b.maxKeyFrameInterval), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = Rt();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.mode = A(N.int32());
            break;
          case 2:
            ie.targetBitrate = N.uint32();
            break;
          case 3:
            ie.maxKeyFrameInterval = N.uint32();
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        mode: De(b.mode) ? A(b.mode) : void 0,
        targetBitrate: De(b.targetBitrate) ? Number(b.targetBitrate) : void 0,
        maxKeyFrameInterval: De(b.maxKeyFrameInterval) ? Number(b.maxKeyFrameInterval) : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.mode !== void 0 && (P.mode = b.mode !== void 0 ? re(b.mode) : void 0), b.targetBitrate !== void 0 && (P.targetBitrate = Math.round(b.targetBitrate)), b.maxKeyFrameInterval !== void 0 && (P.maxKeyFrameInterval = Math.round(b.maxKeyFrameInterval)), P;
    },
    fromPartial(b) {
      var P, N, Se;
      const ie = Rt();
      return ie.mode = (P = b.mode) !== null && P !== void 0 ? P : void 0, ie.targetBitrate = (N = b.targetBitrate) !== null && N !== void 0 ? N : void 0, ie.maxKeyFrameInterval = (Se = b.maxKeyFrameInterval) !== null && Se !== void 0 ? Se : void 0, ie;
    }
  };
  function Ve() {
    return { codec: void 0, rateControl: void 0, profile: void 0 };
  }
  a.VideoEncoding = {
    encode(b, P = c.default.Writer.create()) {
      return b.codec !== void 0 && P.uint32(8).int32(te(b.codec)), b.rateControl !== void 0 && a.VideoCodecRateControl.encode(b.rateControl, P.uint32(18).fork()).ldelim(), b.profile !== void 0 && P.uint32(32).int32(ve(b.profile)), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = Ve();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.codec = T(N.int32());
            break;
          case 2:
            ie.rateControl = a.VideoCodecRateControl.decode(N, N.uint32());
            break;
          case 4:
            ie.profile = Ie(N.int32());
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        codec: De(b.codec) ? T(b.codec) : void 0,
        rateControl: De(b.rateControl) ? a.VideoCodecRateControl.fromJSON(b.rateControl) : void 0,
        profile: De(b.profile) ? Ie(b.profile) : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.codec !== void 0 && (P.codec = b.codec !== void 0 ? B(b.codec) : void 0), b.rateControl !== void 0 && (P.rateControl = b.rateControl ? a.VideoCodecRateControl.toJSON(b.rateControl) : void 0), b.profile !== void 0 && (P.profile = b.profile !== void 0 ? $e(b.profile) : void 0), P;
    },
    fromPartial(b) {
      var P, N;
      const Se = Ve();
      return Se.codec = (P = b.codec) !== null && P !== void 0 ? P : void 0, Se.rateControl = b.rateControl !== void 0 && b.rateControl !== null ? a.VideoCodecRateControl.fromPartial(b.rateControl) : void 0, Se.profile = (N = b.profile) !== null && N !== void 0 ? N : void 0, Se;
    }
  };
  function He() {
    return { codec: void 0 };
  }
  a.AudioEncoding = {
    encode(b, P = c.default.Writer.create()) {
      return b.codec !== void 0 && P.uint32(8).int32(Ue(b.codec)), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = He();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.codec = Oe(N.int32());
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { codec: De(b.codec) ? Oe(b.codec) : void 0 };
    },
    toJSON(b) {
      const P = {};
      return b.codec !== void 0 && (P.codec = b.codec !== void 0 ? Ae(b.codec) : void 0), P;
    },
    fromPartial(b) {
      var P;
      const N = He();
      return N.codec = (P = b.codec) !== null && P !== void 0 ? P : void 0, N;
    }
  };
  function Qe() {
    return { video: void 0, audio: void 0 };
  }
  a.Encoding = {
    encode(b, P = c.default.Writer.create()) {
      return b.video !== void 0 && a.VideoEncoding.encode(b.video, P.uint32(10).fork()).ldelim(), b.audio !== void 0 && a.AudioEncoding.encode(b.audio, P.uint32(18).fork()).ldelim(), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = Qe();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.video = a.VideoEncoding.decode(N, N.uint32());
            break;
          case 2:
            ie.audio = a.AudioEncoding.decode(N, N.uint32());
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        video: De(b.video) ? a.VideoEncoding.fromJSON(b.video) : void 0,
        audio: De(b.audio) ? a.AudioEncoding.fromJSON(b.audio) : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.video !== void 0 && (P.video = b.video ? a.VideoEncoding.toJSON(b.video) : void 0), b.audio !== void 0 && (P.audio = b.audio ? a.AudioEncoding.toJSON(b.audio) : void 0), P;
    },
    fromPartial(b) {
      const P = Qe();
      return P.video = b.video !== void 0 && b.video !== null ? a.VideoEncoding.fromPartial(b.video) : void 0, P.audio = b.audio !== void 0 && b.audio !== null ? a.AudioEncoding.fromPartial(b.audio) : void 0, P;
    }
  };
  function pt() {
    return {
      enabled: void 0,
      key: void 0,
      url: void 0,
      baseUrl: void 0,
      previewUrl: void 0,
      ingestId: void 0,
      secure: void 0,
      ingestType: void 0
    };
  }
  a.SourceRtmpPushAddress = {
    encode(b, P = c.default.Writer.create()) {
      return b.enabled !== void 0 && P.uint32(8).bool(b.enabled), b.key !== void 0 && P.uint32(18).string(b.key), b.url !== void 0 && P.uint32(26).string(b.url), b.baseUrl !== void 0 && P.uint32(34).string(b.baseUrl), b.previewUrl !== void 0 && P.uint32(42).string(b.previewUrl), b.ingestId !== void 0 && P.uint32(50).string(b.ingestId), b.secure !== void 0 && P.uint32(56).bool(b.secure), b.ingestType !== void 0 && P.uint32(66).string(b.ingestType), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = pt();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.enabled = N.bool();
            break;
          case 2:
            ie.key = N.string();
            break;
          case 3:
            ie.url = N.string();
            break;
          case 4:
            ie.baseUrl = N.string();
            break;
          case 5:
            ie.previewUrl = N.string();
            break;
          case 6:
            ie.ingestId = N.string();
            break;
          case 7:
            ie.secure = N.bool();
            break;
          case 8:
            ie.ingestType = N.string();
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        enabled: De(b.enabled) ? !!b.enabled : void 0,
        key: De(b.key) ? String(b.key) : void 0,
        url: De(b.url) ? String(b.url) : void 0,
        baseUrl: De(b.baseUrl) ? String(b.baseUrl) : void 0,
        previewUrl: De(b.previewUrl) ? String(b.previewUrl) : void 0,
        ingestId: De(b.ingestId) ? String(b.ingestId) : void 0,
        secure: De(b.secure) ? !!b.secure : void 0,
        ingestType: De(b.ingestType) ? String(b.ingestType) : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.enabled !== void 0 && (P.enabled = b.enabled), b.key !== void 0 && (P.key = b.key), b.url !== void 0 && (P.url = b.url), b.baseUrl !== void 0 && (P.baseUrl = b.baseUrl), b.previewUrl !== void 0 && (P.previewUrl = b.previewUrl), b.ingestId !== void 0 && (P.ingestId = b.ingestId), b.secure !== void 0 && (P.secure = b.secure), b.ingestType !== void 0 && (P.ingestType = b.ingestType), P;
    },
    fromPartial(b) {
      var P, N, Se, ie, ke, gt, Ct, Dt;
      const Lt = pt();
      return Lt.enabled = (P = b.enabled) !== null && P !== void 0 ? P : void 0, Lt.key = (N = b.key) !== null && N !== void 0 ? N : void 0, Lt.url = (Se = b.url) !== null && Se !== void 0 ? Se : void 0, Lt.baseUrl = (ie = b.baseUrl) !== null && ie !== void 0 ? ie : void 0, Lt.previewUrl = (ke = b.previewUrl) !== null && ke !== void 0 ? ke : void 0, Lt.ingestId = (gt = b.ingestId) !== null && gt !== void 0 ? gt : void 0, Lt.secure = (Ct = b.secure) !== null && Ct !== void 0 ? Ct : void 0, Lt.ingestType = (Dt = b.ingestType) !== null && Dt !== void 0 ? Dt : void 0, Lt;
    }
  };
  function mt() {
    return {
      enabled: void 0,
      streamId: void 0,
      url: void 0,
      baseUrl: void 0,
      previewUrl: void 0,
      ingestId: void 0,
      ingestType: void 0
    };
  }
  a.SrtPushAddress = {
    encode(b, P = c.default.Writer.create()) {
      return b.enabled !== void 0 && P.uint32(8).bool(b.enabled), b.streamId !== void 0 && P.uint32(18).string(b.streamId), b.url !== void 0 && P.uint32(26).string(b.url), b.baseUrl !== void 0 && P.uint32(34).string(b.baseUrl), b.previewUrl !== void 0 && P.uint32(42).string(b.previewUrl), b.ingestId !== void 0 && P.uint32(50).string(b.ingestId), b.ingestType !== void 0 && P.uint32(58).string(b.ingestType), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = mt();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.enabled = N.bool();
            break;
          case 2:
            ie.streamId = N.string();
            break;
          case 3:
            ie.url = N.string();
            break;
          case 4:
            ie.baseUrl = N.string();
            break;
          case 5:
            ie.previewUrl = N.string();
            break;
          case 6:
            ie.ingestId = N.string();
            break;
          case 7:
            ie.ingestType = N.string();
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        enabled: De(b.enabled) ? !!b.enabled : void 0,
        streamId: De(b.streamId) ? String(b.streamId) : void 0,
        url: De(b.url) ? String(b.url) : void 0,
        baseUrl: De(b.baseUrl) ? String(b.baseUrl) : void 0,
        previewUrl: De(b.previewUrl) ? String(b.previewUrl) : void 0,
        ingestId: De(b.ingestId) ? String(b.ingestId) : void 0,
        ingestType: De(b.ingestType) ? String(b.ingestType) : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.enabled !== void 0 && (P.enabled = b.enabled), b.streamId !== void 0 && (P.streamId = b.streamId), b.url !== void 0 && (P.url = b.url), b.baseUrl !== void 0 && (P.baseUrl = b.baseUrl), b.previewUrl !== void 0 && (P.previewUrl = b.previewUrl), b.ingestId !== void 0 && (P.ingestId = b.ingestId), b.ingestType !== void 0 && (P.ingestType = b.ingestType), P;
    },
    fromPartial(b) {
      var P, N, Se, ie, ke, gt, Ct;
      const Dt = mt();
      return Dt.enabled = (P = b.enabled) !== null && P !== void 0 ? P : void 0, Dt.streamId = (N = b.streamId) !== null && N !== void 0 ? N : void 0, Dt.url = (Se = b.url) !== null && Se !== void 0 ? Se : void 0, Dt.baseUrl = (ie = b.baseUrl) !== null && ie !== void 0 ? ie : void 0, Dt.previewUrl = (ke = b.previewUrl) !== null && ke !== void 0 ? ke : void 0, Dt.ingestId = (gt = b.ingestId) !== null && gt !== void 0 ? gt : void 0, Dt.ingestType = (Ct = b.ingestType) !== null && Ct !== void 0 ? Ct : void 0, Dt;
    }
  };
  function vt() {
    return { url: "" };
  }
  a.RtmpPullAddress = {
    encode(b, P = c.default.Writer.create()) {
      return b.url !== "" && P.uint32(10).string(b.url), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = vt();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.url = N.string();
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { url: De(b.url) ? String(b.url) : "" };
    },
    toJSON(b) {
      const P = {};
      return b.url !== void 0 && (P.url = b.url), P;
    },
    fromPartial(b) {
      var P;
      const N = vt();
      return N.url = (P = b.url) !== null && P !== void 0 ? P : "", N;
    }
  };
  function ht() {
    return { url: "" };
  }
  a.SrtPullAddress = {
    encode(b, P = c.default.Writer.create()) {
      return b.url !== "" && P.uint32(10).string(b.url), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = ht();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.url = N.string();
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { url: De(b.url) ? String(b.url) : "" };
    },
    toJSON(b) {
      const P = {};
      return b.url !== void 0 && (P.url = b.url), P;
    },
    fromPartial(b) {
      var P;
      const N = ht();
      return N.url = (P = b.url) !== null && P !== void 0 ? P : "", N;
    }
  };
  function Et() {
    return { id: void 0 };
  }
  a.DynamicAddress = {
    encode(b, P = c.default.Writer.create()) {
      return b.id !== void 0 && P.uint32(10).string(b.id), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = Et();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.id = N.string();
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { id: De(b.id) ? String(b.id) : void 0 };
    },
    toJSON(b) {
      const P = {};
      return b.id !== void 0 && (P.id = b.id), P;
    },
    fromPartial(b) {
      var P;
      const N = Et();
      return N.id = (P = b.id) !== null && P !== void 0 ? P : void 0, N;
    }
  };
  function Tt() {
    return { enabled: void 0, secure: !1 };
  }
  a.DirectRTMPAddress = {
    encode(b, P = c.default.Writer.create()) {
      return b.enabled !== void 0 && P.uint32(8).bool(b.enabled), b.secure === !0 && P.uint32(16).bool(b.secure), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = Tt();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.enabled = N.bool();
            break;
          case 2:
            ie.secure = N.bool();
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        enabled: De(b.enabled) ? !!b.enabled : void 0,
        secure: De(b.secure) ? !!b.secure : !1
      };
    },
    toJSON(b) {
      const P = {};
      return b.enabled !== void 0 && (P.enabled = b.enabled), b.secure !== void 0 && (P.secure = b.secure), P;
    },
    fromPartial(b) {
      var P, N;
      const Se = Tt();
      return Se.enabled = (P = b.enabled) !== null && P !== void 0 ? P : void 0, Se.secure = (N = b.secure) !== null && N !== void 0 ? N : !1, Se;
    }
  };
  function Ot() {
    return { enabled: void 0, secure: !1 };
  }
  a.DirectSrtAddress = {
    encode(b, P = c.default.Writer.create()) {
      return b.enabled !== void 0 && P.uint32(8).bool(b.enabled), b.secure === !0 && P.uint32(16).bool(b.secure), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = Ot();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.enabled = N.bool();
            break;
          case 2:
            ie.secure = N.bool();
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        enabled: De(b.enabled) ? !!b.enabled : void 0,
        secure: De(b.secure) ? !!b.secure : !1
      };
    },
    toJSON(b) {
      const P = {};
      return b.enabled !== void 0 && (P.enabled = b.enabled), b.secure !== void 0 && (P.secure = b.secure), P;
    },
    fromPartial(b) {
      var P, N;
      const Se = Ot();
      return Se.enabled = (P = b.enabled) !== null && P !== void 0 ? P : void 0, Se.secure = (N = b.secure) !== null && N !== void 0 ? N : !1, Se;
    }
  };
  function Nt() {
    return { rtmpPull: void 0, srtPull: void 0, directRtmpPush: void 0, directSrtPush: void 0 };
  }
  a.RuntimeSourceAddress = {
    encode(b, P = c.default.Writer.create()) {
      return b.rtmpPull !== void 0 && a.RtmpPullAddress.encode(b.rtmpPull, P.uint32(10).fork()).ldelim(), b.srtPull !== void 0 && a.SrtPullAddress.encode(b.srtPull, P.uint32(18).fork()).ldelim(), b.directRtmpPush !== void 0 && a.DirectRTMPAddress.encode(b.directRtmpPush, P.uint32(26).fork()).ldelim(), b.directSrtPush !== void 0 && a.DirectSrtAddress.encode(b.directSrtPush, P.uint32(34).fork()).ldelim(), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = Nt();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.rtmpPull = a.RtmpPullAddress.decode(N, N.uint32());
            break;
          case 2:
            ie.srtPull = a.SrtPullAddress.decode(N, N.uint32());
            break;
          case 3:
            ie.directRtmpPush = a.DirectRTMPAddress.decode(N, N.uint32());
            break;
          case 4:
            ie.directSrtPush = a.DirectSrtAddress.decode(N, N.uint32());
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        rtmpPull: De(b.rtmpPull) ? a.RtmpPullAddress.fromJSON(b.rtmpPull) : void 0,
        srtPull: De(b.srtPull) ? a.SrtPullAddress.fromJSON(b.srtPull) : void 0,
        directRtmpPush: De(b.directRtmpPush) ? a.DirectRTMPAddress.fromJSON(b.directRtmpPush) : void 0,
        directSrtPush: De(b.directSrtPush) ? a.DirectSrtAddress.fromJSON(b.directSrtPush) : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.rtmpPull !== void 0 && (P.rtmpPull = b.rtmpPull ? a.RtmpPullAddress.toJSON(b.rtmpPull) : void 0), b.srtPull !== void 0 && (P.srtPull = b.srtPull ? a.SrtPullAddress.toJSON(b.srtPull) : void 0), b.directRtmpPush !== void 0 && (P.directRtmpPush = b.directRtmpPush ? a.DirectRTMPAddress.toJSON(b.directRtmpPush) : void 0), b.directSrtPush !== void 0 && (P.directSrtPush = b.directSrtPush ? a.DirectSrtAddress.toJSON(b.directSrtPush) : void 0), P;
    },
    fromPartial(b) {
      const P = Nt();
      return P.rtmpPull = b.rtmpPull !== void 0 && b.rtmpPull !== null ? a.RtmpPullAddress.fromPartial(b.rtmpPull) : void 0, P.srtPull = b.srtPull !== void 0 && b.srtPull !== null ? a.SrtPullAddress.fromPartial(b.srtPull) : void 0, P.directRtmpPush = b.directRtmpPush !== void 0 && b.directRtmpPush !== null ? a.DirectRTMPAddress.fromPartial(b.directRtmpPush) : void 0, P.directSrtPush = b.directSrtPush !== void 0 && b.directSrtPush !== null ? a.DirectSrtAddress.fromPartial(b.directSrtPush) : void 0, P;
    }
  };
  function At() {
    return { rtmpPush: void 0, srtPush: void 0, rtmpPull: void 0, srtPull: void 0, dynamic: void 0 };
  }
  a.SourceAddress = {
    encode(b, P = c.default.Writer.create()) {
      return b.rtmpPush !== void 0 && a.SourceRtmpPushAddress.encode(b.rtmpPush, P.uint32(10).fork()).ldelim(), b.srtPush !== void 0 && a.SrtPushAddress.encode(b.srtPush, P.uint32(18).fork()).ldelim(), b.rtmpPull !== void 0 && a.RtmpPullAddress.encode(b.rtmpPull, P.uint32(26).fork()).ldelim(), b.srtPull !== void 0 && a.SrtPullAddress.encode(b.srtPull, P.uint32(34).fork()).ldelim(), b.dynamic !== void 0 && a.DynamicAddress.encode(b.dynamic, P.uint32(42).fork()).ldelim(), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = At();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.rtmpPush = a.SourceRtmpPushAddress.decode(N, N.uint32());
            break;
          case 2:
            ie.srtPush = a.SrtPushAddress.decode(N, N.uint32());
            break;
          case 3:
            ie.rtmpPull = a.RtmpPullAddress.decode(N, N.uint32());
            break;
          case 4:
            ie.srtPull = a.SrtPullAddress.decode(N, N.uint32());
            break;
          case 5:
            ie.dynamic = a.DynamicAddress.decode(N, N.uint32());
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        rtmpPush: De(b.rtmpPush) ? a.SourceRtmpPushAddress.fromJSON(b.rtmpPush) : void 0,
        srtPush: De(b.srtPush) ? a.SrtPushAddress.fromJSON(b.srtPush) : void 0,
        rtmpPull: De(b.rtmpPull) ? a.RtmpPullAddress.fromJSON(b.rtmpPull) : void 0,
        srtPull: De(b.srtPull) ? a.SrtPullAddress.fromJSON(b.srtPull) : void 0,
        dynamic: De(b.dynamic) ? a.DynamicAddress.fromJSON(b.dynamic) : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.rtmpPush !== void 0 && (P.rtmpPush = b.rtmpPush ? a.SourceRtmpPushAddress.toJSON(b.rtmpPush) : void 0), b.srtPush !== void 0 && (P.srtPush = b.srtPush ? a.SrtPushAddress.toJSON(b.srtPush) : void 0), b.rtmpPull !== void 0 && (P.rtmpPull = b.rtmpPull ? a.RtmpPullAddress.toJSON(b.rtmpPull) : void 0), b.srtPull !== void 0 && (P.srtPull = b.srtPull ? a.SrtPullAddress.toJSON(b.srtPull) : void 0), b.dynamic !== void 0 && (P.dynamic = b.dynamic ? a.DynamicAddress.toJSON(b.dynamic) : void 0), P;
    },
    fromPartial(b) {
      const P = At();
      return P.rtmpPush = b.rtmpPush !== void 0 && b.rtmpPush !== null ? a.SourceRtmpPushAddress.fromPartial(b.rtmpPush) : void 0, P.srtPush = b.srtPush !== void 0 && b.srtPush !== null ? a.SrtPushAddress.fromPartial(b.srtPush) : void 0, P.rtmpPull = b.rtmpPull !== void 0 && b.rtmpPull !== null ? a.RtmpPullAddress.fromPartial(b.rtmpPull) : void 0, P.srtPull = b.srtPull !== void 0 && b.srtPull !== null ? a.SrtPullAddress.fromPartial(b.srtPull) : void 0, P.dynamic = b.dynamic !== void 0 && b.dynamic !== null ? a.DynamicAddress.fromPartial(b.dynamic) : void 0, P;
    }
  };
  function Mt() {
    return { key: void 0, url: "" };
  }
  a.DestinationRtmpPushAddress = {
    encode(b, P = c.default.Writer.create()) {
      return b.key !== void 0 && P.uint32(10).string(b.key), b.url !== "" && P.uint32(18).string(b.url), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = Mt();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.key = N.string();
            break;
          case 2:
            ie.url = N.string();
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        key: De(b.key) ? String(b.key) : void 0,
        url: De(b.url) ? String(b.url) : ""
      };
    },
    toJSON(b) {
      const P = {};
      return b.key !== void 0 && (P.key = b.key), b.url !== void 0 && (P.url = b.url), P;
    },
    fromPartial(b) {
      var P, N;
      const Se = Mt();
      return Se.key = (P = b.key) !== null && P !== void 0 ? P : void 0, Se.url = (N = b.url) !== null && N !== void 0 ? N : "", Se;
    }
  };
  function $t() {
    return { url: "" };
  }
  a.DestinationSrtPushAddress = {
    encode(b, P = c.default.Writer.create()) {
      return b.url !== "" && P.uint32(18).string(b.url), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = $t();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 2:
            ie.url = N.string();
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { url: De(b.url) ? String(b.url) : "" };
    },
    toJSON(b) {
      const P = {};
      return b.url !== void 0 && (P.url = b.url), P;
    },
    fromPartial(b) {
      var P;
      const N = $t();
      return N.url = (P = b.url) !== null && P !== void 0 ? P : "", N;
    }
  };
  function Bt() {
    return { appId: "", channelId: "", userId: "" };
  }
  a.DestinationAgoraPushAddress = {
    encode(b, P = c.default.Writer.create()) {
      return b.appId !== "" && P.uint32(10).string(b.appId), b.channelId !== "" && P.uint32(18).string(b.channelId), b.userId !== "" && P.uint32(26).string(b.userId), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = Bt();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.appId = N.string();
            break;
          case 2:
            ie.channelId = N.string();
            break;
          case 3:
            ie.userId = N.string();
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        appId: De(b.appId) ? String(b.appId) : "",
        channelId: De(b.channelId) ? String(b.channelId) : "",
        userId: De(b.userId) ? String(b.userId) : ""
      };
    },
    toJSON(b) {
      const P = {};
      return b.appId !== void 0 && (P.appId = b.appId), b.channelId !== void 0 && (P.channelId = b.channelId), b.userId !== void 0 && (P.userId = b.userId), P;
    },
    fromPartial(b) {
      var P, N, Se;
      const ie = Bt();
      return ie.appId = (P = b.appId) !== null && P !== void 0 ? P : "", ie.channelId = (N = b.channelId) !== null && N !== void 0 ? N : "", ie.userId = (Se = b.userId) !== null && Se !== void 0 ? Se : "", ie;
    }
  };
  function Ut() {
    return { playlistCount: void 0, fileCount: void 0 };
  }
  a.HlsLifecycleLive = {
    encode(b, P = c.default.Writer.create()) {
      return b.playlistCount !== void 0 && P.uint32(8).int32(b.playlistCount), b.fileCount !== void 0 && P.uint32(16).int32(b.fileCount), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = Ut();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.playlistCount = N.int32();
            break;
          case 2:
            ie.fileCount = N.int32();
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        playlistCount: De(b.playlistCount) ? Number(b.playlistCount) : void 0,
        fileCount: De(b.fileCount) ? Number(b.fileCount) : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.playlistCount !== void 0 && (P.playlistCount = Math.round(b.playlistCount)), b.fileCount !== void 0 && (P.fileCount = Math.round(b.fileCount)), P;
    },
    fromPartial(b) {
      var P, N;
      const Se = Ut();
      return Se.playlistCount = (P = b.playlistCount) !== null && P !== void 0 ? P : void 0, Se.fileCount = (N = b.fileCount) !== null && N !== void 0 ? N : void 0, Se;
    }
  };
  function xt() {
    return { maxDuration: void 0 };
  }
  a.HlsLifecycleVod = {
    encode(b, P = c.default.Writer.create()) {
      return b.maxDuration !== void 0 && P.uint32(8).int32(b.maxDuration), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = xt();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.maxDuration = N.int32();
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { maxDuration: De(b.maxDuration) ? Number(b.maxDuration) : void 0 };
    },
    toJSON(b) {
      const P = {};
      return b.maxDuration !== void 0 && (P.maxDuration = Math.round(b.maxDuration)), P;
    },
    fromPartial(b) {
      var P;
      const N = xt();
      return N.maxDuration = (P = b.maxDuration) !== null && P !== void 0 ? P : void 0, N;
    }
  };
  function Jt() {
    return { vod: void 0, live: void 0 };
  }
  a.HlsLifecycle = {
    encode(b, P = c.default.Writer.create()) {
      return b.vod !== void 0 && a.HlsLifecycleVod.encode(b.vod, P.uint32(10).fork()).ldelim(), b.live !== void 0 && a.HlsLifecycleLive.encode(b.live, P.uint32(18).fork()).ldelim(), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = Jt();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.vod = a.HlsLifecycleVod.decode(N, N.uint32());
            break;
          case 2:
            ie.live = a.HlsLifecycleLive.decode(N, N.uint32());
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        vod: De(b.vod) ? a.HlsLifecycleVod.fromJSON(b.vod) : void 0,
        live: De(b.live) ? a.HlsLifecycleLive.fromJSON(b.live) : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.vod !== void 0 && (P.vod = b.vod ? a.HlsLifecycleVod.toJSON(b.vod) : void 0), b.live !== void 0 && (P.live = b.live ? a.HlsLifecycleLive.toJSON(b.live) : void 0), P;
    },
    fromPartial(b) {
      const P = Jt();
      return P.vod = b.vod !== void 0 && b.vod !== null ? a.HlsLifecycleVod.fromPartial(b.vod) : void 0, P.live = b.live !== void 0 && b.live !== null ? a.HlsLifecycleLive.fromPartial(b.live) : void 0, P;
    }
  };
  function Gt() {
    return { lifecycle: void 0, segmentDuration: void 0 };
  }
  a.HlsPackaging = {
    encode(b, P = c.default.Writer.create()) {
      return b.lifecycle !== void 0 && a.HlsLifecycle.encode(b.lifecycle, P.uint32(10).fork()).ldelim(), b.segmentDuration !== void 0 && P.uint32(16).int32(b.segmentDuration), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = Gt();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.lifecycle = a.HlsLifecycle.decode(N, N.uint32());
            break;
          case 2:
            ie.segmentDuration = N.int32();
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        lifecycle: De(b.lifecycle) ? a.HlsLifecycle.fromJSON(b.lifecycle) : void 0,
        segmentDuration: De(b.segmentDuration) ? Number(b.segmentDuration) : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.lifecycle !== void 0 && (P.lifecycle = b.lifecycle ? a.HlsLifecycle.toJSON(b.lifecycle) : void 0), b.segmentDuration !== void 0 && (P.segmentDuration = Math.round(b.segmentDuration)), P;
    },
    fromPartial(b) {
      var P;
      const N = Gt();
      return N.lifecycle = b.lifecycle !== void 0 && b.lifecycle !== null ? a.HlsLifecycle.fromPartial(b.lifecycle) : void 0, N.segmentDuration = (P = b.segmentDuration) !== null && P !== void 0 ? P : void 0, N;
    }
  };
  function Yt() {
    return { hls: void 0 };
  }
  a.ObjectStoragePackaging = {
    encode(b, P = c.default.Writer.create()) {
      return b.hls !== void 0 && a.HlsPackaging.encode(b.hls, P.uint32(10).fork()).ldelim(), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = Yt();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.hls = a.HlsPackaging.decode(N, N.uint32());
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { hls: De(b.hls) ? a.HlsPackaging.fromJSON(b.hls) : void 0 };
    },
    toJSON(b) {
      const P = {};
      return b.hls !== void 0 && (P.hls = b.hls ? a.HlsPackaging.toJSON(b.hls) : void 0), P;
    },
    fromPartial(b) {
      const P = Yt();
      return P.hls = b.hls !== void 0 && b.hls !== null ? a.HlsPackaging.fromPartial(b.hls) : void 0, P;
    }
  };
  function jt() {
    return {
      region: "",
      bucket: "",
      prefix: void 0,
      accessKey: "",
      secretKey: "",
      token: void 0,
      tokenDuration: void 0,
      acl: void 0,
      endpoint: void 0,
      packaging: void 0
    };
  }
  a.S3StorageAddress = {
    encode(b, P = c.default.Writer.create()) {
      return b.region !== "" && P.uint32(10).string(b.region), b.bucket !== "" && P.uint32(18).string(b.bucket), b.prefix !== void 0 && P.uint32(26).string(b.prefix), b.accessKey !== "" && P.uint32(34).string(b.accessKey), b.secretKey !== "" && P.uint32(42).string(b.secretKey), b.token !== void 0 && P.uint32(50).string(b.token), b.tokenDuration !== void 0 && P.uint32(56).int32(b.tokenDuration), b.acl !== void 0 && P.uint32(64).int32(Ge(b.acl)), b.endpoint !== void 0 && P.uint32(74).string(b.endpoint), b.packaging !== void 0 && a.ObjectStoragePackaging.encode(b.packaging, P.uint32(82).fork()).ldelim(), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = jt();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.region = N.string();
            break;
          case 2:
            ie.bucket = N.string();
            break;
          case 3:
            ie.prefix = N.string();
            break;
          case 4:
            ie.accessKey = N.string();
            break;
          case 5:
            ie.secretKey = N.string();
            break;
          case 6:
            ie.token = N.string();
            break;
          case 7:
            ie.tokenDuration = N.int32();
            break;
          case 8:
            ie.acl = yt(N.int32());
            break;
          case 9:
            ie.endpoint = N.string();
            break;
          case 10:
            ie.packaging = a.ObjectStoragePackaging.decode(N, N.uint32());
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        region: De(b.region) ? String(b.region) : "",
        bucket: De(b.bucket) ? String(b.bucket) : "",
        prefix: De(b.prefix) ? String(b.prefix) : void 0,
        accessKey: De(b.accessKey) ? String(b.accessKey) : "",
        secretKey: De(b.secretKey) ? String(b.secretKey) : "",
        token: De(b.token) ? String(b.token) : void 0,
        tokenDuration: De(b.tokenDuration) ? Number(b.tokenDuration) : void 0,
        acl: De(b.acl) ? yt(b.acl) : void 0,
        endpoint: De(b.endpoint) ? String(b.endpoint) : void 0,
        packaging: De(b.packaging) ? a.ObjectStoragePackaging.fromJSON(b.packaging) : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.region !== void 0 && (P.region = b.region), b.bucket !== void 0 && (P.bucket = b.bucket), b.prefix !== void 0 && (P.prefix = b.prefix), b.accessKey !== void 0 && (P.accessKey = b.accessKey), b.secretKey !== void 0 && (P.secretKey = b.secretKey), b.token !== void 0 && (P.token = b.token), b.tokenDuration !== void 0 && (P.tokenDuration = Math.round(b.tokenDuration)), b.acl !== void 0 && (P.acl = b.acl !== void 0 ? Xe(b.acl) : void 0), b.endpoint !== void 0 && (P.endpoint = b.endpoint), b.packaging !== void 0 && (P.packaging = b.packaging ? a.ObjectStoragePackaging.toJSON(b.packaging) : void 0), P;
    },
    fromPartial(b) {
      var P, N, Se, ie, ke, gt, Ct, Dt, Lt;
      const qt = jt();
      return qt.region = (P = b.region) !== null && P !== void 0 ? P : "", qt.bucket = (N = b.bucket) !== null && N !== void 0 ? N : "", qt.prefix = (Se = b.prefix) !== null && Se !== void 0 ? Se : void 0, qt.accessKey = (ie = b.accessKey) !== null && ie !== void 0 ? ie : "", qt.secretKey = (ke = b.secretKey) !== null && ke !== void 0 ? ke : "", qt.token = (gt = b.token) !== null && gt !== void 0 ? gt : void 0, qt.tokenDuration = (Ct = b.tokenDuration) !== null && Ct !== void 0 ? Ct : void 0, qt.acl = (Dt = b.acl) !== null && Dt !== void 0 ? Dt : void 0, qt.endpoint = (Lt = b.endpoint) !== null && Lt !== void 0 ? Lt : void 0, qt.packaging = b.packaging !== void 0 && b.packaging !== null ? a.ObjectStoragePackaging.fromPartial(b.packaging) : void 0, qt;
    }
  };
  function Zt() {
    return { rtmpPush: void 0, agora: void 0, s3Storage: void 0, srtPush: void 0 };
  }
  a.DestinationAddress = {
    encode(b, P = c.default.Writer.create()) {
      return b.rtmpPush !== void 0 && a.DestinationRtmpPushAddress.encode(b.rtmpPush, P.uint32(10).fork()).ldelim(), b.agora !== void 0 && a.DestinationAgoraPushAddress.encode(b.agora, P.uint32(18).fork()).ldelim(), b.s3Storage !== void 0 && a.S3StorageAddress.encode(b.s3Storage, P.uint32(26).fork()).ldelim(), b.srtPush !== void 0 && a.DestinationSrtPushAddress.encode(b.srtPush, P.uint32(34).fork()).ldelim(), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = Zt();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.rtmpPush = a.DestinationRtmpPushAddress.decode(N, N.uint32());
            break;
          case 2:
            ie.agora = a.DestinationAgoraPushAddress.decode(N, N.uint32());
            break;
          case 3:
            ie.s3Storage = a.S3StorageAddress.decode(N, N.uint32());
            break;
          case 4:
            ie.srtPush = a.DestinationSrtPushAddress.decode(N, N.uint32());
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        rtmpPush: De(b.rtmpPush) ? a.DestinationRtmpPushAddress.fromJSON(b.rtmpPush) : void 0,
        agora: De(b.agora) ? a.DestinationAgoraPushAddress.fromJSON(b.agora) : void 0,
        s3Storage: De(b.s3Storage) ? a.S3StorageAddress.fromJSON(b.s3Storage) : void 0,
        srtPush: De(b.srtPush) ? a.DestinationSrtPushAddress.fromJSON(b.srtPush) : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.rtmpPush !== void 0 && (P.rtmpPush = b.rtmpPush ? a.DestinationRtmpPushAddress.toJSON(b.rtmpPush) : void 0), b.agora !== void 0 && (P.agora = b.agora ? a.DestinationAgoraPushAddress.toJSON(b.agora) : void 0), b.s3Storage !== void 0 && (P.s3Storage = b.s3Storage ? a.S3StorageAddress.toJSON(b.s3Storage) : void 0), b.srtPush !== void 0 && (P.srtPush = b.srtPush ? a.DestinationSrtPushAddress.toJSON(b.srtPush) : void 0), P;
    },
    fromPartial(b) {
      const P = Zt();
      return P.rtmpPush = b.rtmpPush !== void 0 && b.rtmpPush !== null ? a.DestinationRtmpPushAddress.fromPartial(b.rtmpPush) : void 0, P.agora = b.agora !== void 0 && b.agora !== null ? a.DestinationAgoraPushAddress.fromPartial(b.agora) : void 0, P.s3Storage = b.s3Storage !== void 0 && b.s3Storage !== null ? a.S3StorageAddress.fromPartial(b.s3Storage) : void 0, P.srtPush = b.srtPush !== void 0 && b.srtPush !== null ? a.DestinationSrtPushAddress.fromPartial(b.srtPush) : void 0, P;
    }
  };
  function Xt() {
    return { sourceId: "", start: void 0, stop: void 0 };
  }
  a.SourceTrigger = {
    encode(b, P = c.default.Writer.create()) {
      return b.sourceId !== "" && P.uint32(10).string(b.sourceId), b.start !== void 0 && P.uint32(16).int32(We(b.start)), b.stop !== void 0 && P.uint32(24).int32(We(b.stop)), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = Xt();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.sourceId = N.string();
            break;
          case 2:
            ie.start = ye(N.int32());
            break;
          case 3:
            ie.stop = ye(N.int32());
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        sourceId: De(b.sourceId) ? String(b.sourceId) : "",
        start: De(b.start) ? ye(b.start) : void 0,
        stop: De(b.stop) ? ye(b.stop) : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.sourceId !== void 0 && (P.sourceId = b.sourceId), b.start !== void 0 && (P.start = b.start !== void 0 ? Ee(b.start) : void 0), b.stop !== void 0 && (P.stop = b.stop !== void 0 ? Ee(b.stop) : void 0), P;
    },
    fromPartial(b) {
      var P, N, Se;
      const ie = Xt();
      return ie.sourceId = (P = b.sourceId) !== null && P !== void 0 ? P : "", ie.start = (N = b.start) !== null && N !== void 0 ? N : void 0, ie.stop = (Se = b.stop) !== null && Se !== void 0 ? Se : void 0, ie;
    }
  };
  function Qt() {
    return { stop: void 0 };
  }
  a.WebRtcTrigger = {
    encode(b, P = c.default.Writer.create()) {
      return b.stop !== void 0 && P.uint32(24).int32(We(b.stop)), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = Qt();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 3:
            ie.stop = ye(N.int32());
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { stop: De(b.stop) ? ye(b.stop) : void 0 };
    },
    toJSON(b) {
      const P = {};
      return b.stop !== void 0 && (P.stop = b.stop !== void 0 ? Ee(b.stop) : void 0), P;
    },
    fromPartial(b) {
      var P;
      const N = Qt();
      return N.stop = (P = b.stop) !== null && P !== void 0 ? P : void 0, N;
    }
  };
  function er() {
    return { source: void 0 };
  }
  a.ProjectTrigger = {
    encode(b, P = c.default.Writer.create()) {
      return b.source !== void 0 && a.SourceTrigger.encode(b.source, P.uint32(10).fork()).ldelim(), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = er();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.source = a.SourceTrigger.decode(N, N.uint32());
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { source: De(b.source) ? a.SourceTrigger.fromJSON(b.source) : void 0 };
    },
    toJSON(b) {
      const P = {};
      return b.source !== void 0 && (P.source = b.source ? a.SourceTrigger.toJSON(b.source) : void 0), P;
    },
    fromPartial(b) {
      const P = er();
      return P.source = b.source !== void 0 && b.source !== null ? a.SourceTrigger.fromPartial(b.source) : void 0, P;
    }
  };
  function tr() {
    return { enabled: void 0, url: void 0 };
  }
  a.PreviewHlsPullAddress = {
    encode(b, P = c.default.Writer.create()) {
      return b.enabled !== void 0 && P.uint32(8).bool(b.enabled), b.url !== void 0 && P.uint32(18).string(b.url), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = tr();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.enabled = N.bool();
            break;
          case 2:
            ie.url = N.string();
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        enabled: De(b.enabled) ? !!b.enabled : void 0,
        url: De(b.url) ? String(b.url) : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.enabled !== void 0 && (P.enabled = b.enabled), b.url !== void 0 && (P.url = b.url), P;
    },
    fromPartial(b) {
      var P, N;
      const Se = tr();
      return Se.enabled = (P = b.enabled) !== null && P !== void 0 ? P : void 0, Se.url = (N = b.url) !== null && N !== void 0 ? N : void 0, Se;
    }
  };
  function rr() {
    return { enabled: void 0, displayName: void 0, participantId: void 0 };
  }
  a.PreviewWebRtcAddress = {
    encode(b, P = c.default.Writer.create()) {
      return b.enabled !== void 0 && P.uint32(8).bool(b.enabled), b.displayName !== void 0 && P.uint32(18).string(b.displayName), b.participantId !== void 0 && P.uint32(26).string(b.participantId), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = rr();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.enabled = N.bool();
            break;
          case 2:
            ie.displayName = N.string();
            break;
          case 3:
            ie.participantId = N.string();
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        enabled: De(b.enabled) ? !!b.enabled : void 0,
        displayName: De(b.displayName) ? String(b.displayName) : void 0,
        participantId: De(b.participantId) ? String(b.participantId) : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.enabled !== void 0 && (P.enabled = b.enabled), b.displayName !== void 0 && (P.displayName = b.displayName), b.participantId !== void 0 && (P.participantId = b.participantId), P;
    },
    fromPartial(b) {
      var P, N, Se;
      const ie = rr();
      return ie.enabled = (P = b.enabled) !== null && P !== void 0 ? P : void 0, ie.displayName = (N = b.displayName) !== null && N !== void 0 ? N : void 0, ie.participantId = (Se = b.participantId) !== null && Se !== void 0 ? Se : void 0, ie;
    }
  };
  function nr() {
    return { webrtc: void 0 };
  }
  a.PreviewAddress = {
    encode(b, P = c.default.Writer.create()) {
      return b.webrtc !== void 0 && a.PreviewWebRtcAddress.encode(b.webrtc, P.uint32(18).fork()).ldelim(), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = nr();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 2:
            ie.webrtc = a.PreviewWebRtcAddress.decode(N, N.uint32());
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { webrtc: De(b.webrtc) ? a.PreviewWebRtcAddress.fromJSON(b.webrtc) : void 0 };
    },
    toJSON(b) {
      const P = {};
      return b.webrtc !== void 0 && (P.webrtc = b.webrtc ? a.PreviewWebRtcAddress.toJSON(b.webrtc) : void 0), P;
    },
    fromPartial(b) {
      const P = nr();
      return P.webrtc = b.webrtc !== void 0 && b.webrtc !== null ? a.PreviewWebRtcAddress.fromPartial(b.webrtc) : void 0, P;
    }
  };
  function ir() {
    return { rendererUrl: void 0, version: void 0 };
  }
  a.StudioSdkComposition = {
    encode(b, P = c.default.Writer.create()) {
      return b.rendererUrl !== void 0 && P.uint32(10).string(b.rendererUrl), b.version !== void 0 && P.uint32(18).string(b.version), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = ir();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.rendererUrl = N.string();
            break;
          case 2:
            ie.version = N.string();
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        rendererUrl: De(b.rendererUrl) ? String(b.rendererUrl) : void 0,
        version: De(b.version) ? String(b.version) : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.rendererUrl !== void 0 && (P.rendererUrl = b.rendererUrl), b.version !== void 0 && (P.version = b.version), P;
    },
    fromPartial(b) {
      var P, N;
      const Se = ir();
      return Se.rendererUrl = (P = b.rendererUrl) !== null && P !== void 0 ? P : void 0, Se.version = (N = b.version) !== null && N !== void 0 ? N : void 0, Se;
    }
  };
  function ar() {
    return { rendererUrl: void 0, selectedLayoutId: void 0, debug: void 0 };
  }
  a.SceneComposition = {
    encode(b, P = c.default.Writer.create()) {
      return b.rendererUrl !== void 0 && P.uint32(10).string(b.rendererUrl), b.selectedLayoutId !== void 0 && P.uint32(18).string(b.selectedLayoutId), b.debug !== void 0 && P.uint32(24).bool(b.debug), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = ar();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.rendererUrl = N.string();
            break;
          case 2:
            ie.selectedLayoutId = N.string();
            break;
          case 3:
            ie.debug = N.bool();
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        rendererUrl: De(b.rendererUrl) ? String(b.rendererUrl) : void 0,
        selectedLayoutId: De(b.selectedLayoutId) ? String(b.selectedLayoutId) : void 0,
        debug: De(b.debug) ? !!b.debug : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.rendererUrl !== void 0 && (P.rendererUrl = b.rendererUrl), b.selectedLayoutId !== void 0 && (P.selectedLayoutId = b.selectedLayoutId), b.debug !== void 0 && (P.debug = b.debug), P;
    },
    fromPartial(b) {
      var P, N, Se;
      const ie = ar();
      return ie.rendererUrl = (P = b.rendererUrl) !== null && P !== void 0 ? P : void 0, ie.selectedLayoutId = (N = b.selectedLayoutId) !== null && N !== void 0 ? N : void 0, ie.debug = (Se = b.debug) !== null && Se !== void 0 ? Se : void 0, ie;
    }
  };
  function or() {
    return { url: "" };
  }
  a.ExternalComposition = {
    encode(b, P = c.default.Writer.create()) {
      return b.url !== "" && P.uint32(10).string(b.url), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = or();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.url = N.string();
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { url: De(b.url) ? String(b.url) : "" };
    },
    toJSON(b) {
      const P = {};
      return b.url !== void 0 && (P.url = b.url), P;
    },
    fromPartial(b) {
      var P;
      const N = or();
      return N.url = (P = b.url) !== null && P !== void 0 ? P : "", N;
    }
  };
  function dr() {
    return { external: void 0, studioSdk: void 0, scene: void 0 };
  }
  a.Composition = {
    encode(b, P = c.default.Writer.create()) {
      return b.external !== void 0 && a.ExternalComposition.encode(b.external, P.uint32(10).fork()).ldelim(), b.studioSdk !== void 0 && a.StudioSdkComposition.encode(b.studioSdk, P.uint32(18).fork()).ldelim(), b.scene !== void 0 && a.SceneComposition.encode(b.scene, P.uint32(34).fork()).ldelim(), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = dr();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.external = a.ExternalComposition.decode(N, N.uint32());
            break;
          case 2:
            ie.studioSdk = a.StudioSdkComposition.decode(N, N.uint32());
            break;
          case 4:
            ie.scene = a.SceneComposition.decode(N, N.uint32());
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        external: De(b.external) ? a.ExternalComposition.fromJSON(b.external) : void 0,
        studioSdk: De(b.studioSdk) ? a.StudioSdkComposition.fromJSON(b.studioSdk) : void 0,
        scene: De(b.scene) ? a.SceneComposition.fromJSON(b.scene) : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.external !== void 0 && (P.external = b.external ? a.ExternalComposition.toJSON(b.external) : void 0), b.studioSdk !== void 0 && (P.studioSdk = b.studioSdk ? a.StudioSdkComposition.toJSON(b.studioSdk) : void 0), b.scene !== void 0 && (P.scene = b.scene ? a.SceneComposition.toJSON(b.scene) : void 0), P;
    },
    fromPartial(b) {
      const P = dr();
      return P.external = b.external !== void 0 && b.external !== null ? a.ExternalComposition.fromPartial(b.external) : void 0, P.studioSdk = b.studioSdk !== void 0 && b.studioSdk !== null ? a.StudioSdkComposition.fromPartial(b.studioSdk) : void 0, P.scene = b.scene !== void 0 && b.scene !== null ? a.SceneComposition.fromPartial(b.scene) : void 0, P;
    }
  };
  function ur() {
    return { enabled: void 0 };
  }
  a.HostedWebRtc = {
    encode(b, P = c.default.Writer.create()) {
      return b.enabled !== void 0 && P.uint32(8).bool(b.enabled), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = ur();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.enabled = N.bool();
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { enabled: De(b.enabled) ? !!b.enabled : void 0 };
    },
    toJSON(b) {
      const P = {};
      return b.enabled !== void 0 && (P.enabled = b.enabled), P;
    },
    fromPartial(b) {
      var P;
      const N = ur();
      return N.enabled = (P = b.enabled) !== null && P !== void 0 ? P : void 0, N;
    }
  };
  function cr() {
    return { hosted: void 0 };
  }
  a.WebRtc = {
    encode(b, P = c.default.Writer.create()) {
      return b.hosted !== void 0 && a.HostedWebRtc.encode(b.hosted, P.uint32(10).fork()).ldelim(), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = cr();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.hosted = a.HostedWebRtc.decode(N, N.uint32());
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { hosted: De(b.hosted) ? a.HostedWebRtc.fromJSON(b.hosted) : void 0 };
    },
    toJSON(b) {
      const P = {};
      return b.hosted !== void 0 && (P.hosted = b.hosted ? a.HostedWebRtc.toJSON(b.hosted) : void 0), P;
    },
    fromPartial(b) {
      const P = cr();
      return P.hosted = b.hosted !== void 0 && b.hosted !== null ? a.HostedWebRtc.fromPartial(b.hosted) : void 0, P;
    }
  };
  function lr() {
    return { accessToken: "", participantId: void 0 };
  }
  a.WebRtcAccess = {
    encode(b, P = c.default.Writer.create()) {
      return b.accessToken !== "" && P.uint32(10).string(b.accessToken), b.participantId !== void 0 && P.uint32(26).string(b.participantId), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = lr();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.accessToken = N.string();
            break;
          case 3:
            ie.participantId = N.string();
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        accessToken: De(b.accessToken) ? String(b.accessToken) : "",
        participantId: De(b.participantId) ? String(b.participantId) : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.accessToken !== void 0 && (P.accessToken = b.accessToken), b.participantId !== void 0 && (P.participantId = b.participantId), P;
    },
    fromPartial(b) {
      var P, N;
      const Se = lr();
      return Se.accessToken = (P = b.accessToken) !== null && P !== void 0 ? P : "", Se.participantId = (N = b.participantId) !== null && N !== void 0 ? N : void 0, Se;
    }
  };
  function fr() {
    return { latitude: 0, longitude: 0 };
  }
  a.LatLong = {
    encode(b, P = c.default.Writer.create()) {
      return b.latitude !== 0 && P.uint32(9).double(b.latitude), b.longitude !== 0 && P.uint32(17).double(b.longitude), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = fr();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.latitude = N.double();
            break;
          case 2:
            ie.longitude = N.double();
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        latitude: De(b.latitude) ? Number(b.latitude) : 0,
        longitude: De(b.longitude) ? Number(b.longitude) : 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.latitude !== void 0 && (P.latitude = b.latitude), b.longitude !== void 0 && (P.longitude = b.longitude), P;
    },
    fromPartial(b) {
      var P, N;
      const Se = fr();
      return Se.latitude = (P = b.latitude) !== null && P !== void 0 ? P : 0, Se.longitude = (N = b.longitude) !== null && N !== void 0 ? N : 0, Se;
    }
  };
  function pr() {
    return { dynamicId: void 0, sourceId: void 0, rtmpPush: void 0, srtPush: void 0 };
  }
  a.DirectIngestUrl = {
    encode(b, P = c.default.Writer.create()) {
      return b.dynamicId !== void 0 && P.uint32(10).string(b.dynamicId), b.sourceId !== void 0 && P.uint32(18).string(b.sourceId), b.rtmpPush !== void 0 && a.SourceRtmpPushAddress.encode(b.rtmpPush, P.uint32(82).fork()).ldelim(), b.srtPush !== void 0 && a.SrtPushAddress.encode(b.srtPush, P.uint32(90).fork()).ldelim(), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = pr();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.dynamicId = N.string();
            break;
          case 2:
            ie.sourceId = N.string();
            break;
          case 10:
            ie.rtmpPush = a.SourceRtmpPushAddress.decode(N, N.uint32());
            break;
          case 11:
            ie.srtPush = a.SrtPushAddress.decode(N, N.uint32());
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        dynamicId: De(b.dynamicId) ? String(b.dynamicId) : void 0,
        sourceId: De(b.sourceId) ? String(b.sourceId) : void 0,
        rtmpPush: De(b.rtmpPush) ? a.SourceRtmpPushAddress.fromJSON(b.rtmpPush) : void 0,
        srtPush: De(b.srtPush) ? a.SrtPushAddress.fromJSON(b.srtPush) : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.dynamicId !== void 0 && (P.dynamicId = b.dynamicId), b.sourceId !== void 0 && (P.sourceId = b.sourceId), b.rtmpPush !== void 0 && (P.rtmpPush = b.rtmpPush ? a.SourceRtmpPushAddress.toJSON(b.rtmpPush) : void 0), b.srtPush !== void 0 && (P.srtPush = b.srtPush ? a.SrtPushAddress.toJSON(b.srtPush) : void 0), P;
    },
    fromPartial(b) {
      var P, N;
      const Se = pr();
      return Se.dynamicId = (P = b.dynamicId) !== null && P !== void 0 ? P : void 0, Se.sourceId = (N = b.sourceId) !== null && N !== void 0 ? N : void 0, Se.rtmpPush = b.rtmpPush !== void 0 && b.rtmpPush !== null ? a.SourceRtmpPushAddress.fromPartial(b.rtmpPush) : void 0, Se.srtPush = b.srtPush !== void 0 && b.srtPush !== null ? a.SrtPushAddress.fromPartial(b.srtPush) : void 0, Se;
    }
  };
  function vr() {
    return {
      collectionId: "",
      projectId: "",
      broadcastId: void 0,
      duration: void 0,
      start: void 0,
      stop: void 0,
      phase: Ne.PROJECT_BROADCAST_PHASE_UNSPECIFIED,
      region: void 0,
      datacenter: void 0,
      directIngests: []
    };
  }
  a.ProjectBroadcastStatus = {
    encode(b, P = c.default.Writer.create()) {
      b.collectionId !== "" && P.uint32(10).string(b.collectionId), b.projectId !== "" && P.uint32(18).string(b.projectId), b.broadcastId !== void 0 && P.uint32(26).string(b.broadcastId), b.duration !== void 0 && P.uint32(32).uint32(b.duration), b.start !== void 0 && _.Timestamp.encode(Ht(b.start), P.uint32(42).fork()).ldelim(), b.stop !== void 0 && _.Timestamp.encode(Ht(b.stop), P.uint32(50).fork()).ldelim(), b.phase !== Ne.PROJECT_BROADCAST_PHASE_UNSPECIFIED && P.uint32(56).int32(je(b.phase)), b.region !== void 0 && P.uint32(64).int32(ue(b.region)), b.datacenter !== void 0 && P.uint32(74).string(b.datacenter);
      for (const N of b.directIngests)
        a.DirectIngestUrl.encode(N, P.uint32(82).fork()).ldelim();
      return P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = vr();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.projectId = N.string();
            break;
          case 3:
            ie.broadcastId = N.string();
            break;
          case 4:
            ie.duration = N.uint32();
            break;
          case 5:
            ie.start = zt(_.Timestamp.decode(N, N.uint32()));
            break;
          case 6:
            ie.stop = zt(_.Timestamp.decode(N, N.uint32()));
            break;
          case 7:
            ie.phase = Pe(N.int32());
            break;
          case 8:
            ie.region = V(N.int32());
            break;
          case 9:
            ie.datacenter = N.string();
            break;
          case 10:
            ie.directIngests.push(a.DirectIngestUrl.decode(N, N.uint32()));
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: De(b.collectionId) ? String(b.collectionId) : "",
        projectId: De(b.projectId) ? String(b.projectId) : "",
        broadcastId: De(b.broadcastId) ? String(b.broadcastId) : void 0,
        duration: De(b.duration) ? Number(b.duration) : void 0,
        start: De(b.start) ? String(b.start) : void 0,
        stop: De(b.stop) ? String(b.stop) : void 0,
        phase: De(b.phase) ? Pe(b.phase) : Ne.PROJECT_BROADCAST_PHASE_UNSPECIFIED,
        region: De(b.region) ? V(b.region) : void 0,
        datacenter: De(b.datacenter) ? String(b.datacenter) : void 0,
        directIngests: Array.isArray(b == null ? void 0 : b.directIngests) ? b.directIngests.map((P) => a.DirectIngestUrl.fromJSON(P)) : []
      };
    },
    toJSON(b) {
      const P = {};
      return b.collectionId !== void 0 && (P.collectionId = b.collectionId), b.projectId !== void 0 && (P.projectId = b.projectId), b.broadcastId !== void 0 && (P.broadcastId = b.broadcastId), b.duration !== void 0 && (P.duration = Math.round(b.duration)), b.start !== void 0 && (P.start = b.start), b.stop !== void 0 && (P.stop = b.stop), b.phase !== void 0 && (P.phase = Fe(b.phase)), b.region !== void 0 && (P.region = b.region !== void 0 ? _e(b.region) : void 0), b.datacenter !== void 0 && (P.datacenter = b.datacenter), b.directIngests ? P.directIngests = b.directIngests.map((N) => N ? a.DirectIngestUrl.toJSON(N) : void 0) : P.directIngests = [], P;
    },
    fromPartial(b) {
      var P, N, Se, ie, ke, gt, Ct, Dt, Lt, qt;
      const Vt = vr();
      return Vt.collectionId = (P = b.collectionId) !== null && P !== void 0 ? P : "", Vt.projectId = (N = b.projectId) !== null && N !== void 0 ? N : "", Vt.broadcastId = (Se = b.broadcastId) !== null && Se !== void 0 ? Se : void 0, Vt.duration = (ie = b.duration) !== null && ie !== void 0 ? ie : void 0, Vt.start = (ke = b.start) !== null && ke !== void 0 ? ke : void 0, Vt.stop = (gt = b.stop) !== null && gt !== void 0 ? gt : void 0, Vt.phase = (Ct = b.phase) !== null && Ct !== void 0 ? Ct : Ne.PROJECT_BROADCAST_PHASE_UNSPECIFIED, Vt.region = (Dt = b.region) !== null && Dt !== void 0 ? Dt : void 0, Vt.datacenter = (Lt = b.datacenter) !== null && Lt !== void 0 ? Lt : void 0, Vt.directIngests = ((qt = b.directIngests) === null || qt === void 0 ? void 0 : qt.map((Ri) => a.DirectIngestUrl.fromPartial(Ri))) || [], Vt;
    }
  };
  function yr() {
    return { collectionId: "", sourceId: "", metadata: void 0, preview: void 0, address: void 0 };
  }
  a.Source = {
    encode(b, P = c.default.Writer.create()) {
      return b.collectionId !== "" && P.uint32(10).string(b.collectionId), b.sourceId !== "" && P.uint32(18).string(b.sourceId), b.metadata !== void 0 && p.Value.encode(p.Value.wrap(b.metadata), P.uint32(26).fork()).ldelim(), b.preview !== void 0 && a.PreviewAddress.encode(b.preview, P.uint32(34).fork()).ldelim(), b.address !== void 0 && a.SourceAddress.encode(b.address, P.uint32(50).fork()).ldelim(), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = yr();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.sourceId = N.string();
            break;
          case 3:
            ie.metadata = p.Value.unwrap(p.Value.decode(N, N.uint32()));
            break;
          case 4:
            ie.preview = a.PreviewAddress.decode(N, N.uint32());
            break;
          case 6:
            ie.address = a.SourceAddress.decode(N, N.uint32());
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: De(b.collectionId) ? String(b.collectionId) : "",
        sourceId: De(b.sourceId) ? String(b.sourceId) : "",
        metadata: De(b == null ? void 0 : b.metadata) ? b.metadata : void 0,
        preview: De(b.preview) ? a.PreviewAddress.fromJSON(b.preview) : void 0,
        address: De(b.address) ? a.SourceAddress.fromJSON(b.address) : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.collectionId !== void 0 && (P.collectionId = b.collectionId), b.sourceId !== void 0 && (P.sourceId = b.sourceId), b.metadata !== void 0 && (P.metadata = b.metadata), b.preview !== void 0 && (P.preview = b.preview ? a.PreviewAddress.toJSON(b.preview) : void 0), b.address !== void 0 && (P.address = b.address ? a.SourceAddress.toJSON(b.address) : void 0), P;
    },
    fromPartial(b) {
      var P, N, Se;
      const ie = yr();
      return ie.collectionId = (P = b.collectionId) !== null && P !== void 0 ? P : "", ie.sourceId = (N = b.sourceId) !== null && N !== void 0 ? N : "", ie.metadata = (Se = b.metadata) !== null && Se !== void 0 ? Se : void 0, ie.preview = b.preview !== void 0 && b.preview !== null ? a.PreviewAddress.fromPartial(b.preview) : void 0, ie.address = b.address !== void 0 && b.address !== null ? a.SourceAddress.fromPartial(b.address) : void 0, ie;
    }
  };
  function gr() {
    return {
      collectionId: "",
      projectId: "",
      destinationId: "",
      metadata: void 0,
      enabled: void 0,
      address: void 0,
      timeout: void 0
    };
  }
  a.Destination = {
    encode(b, P = c.default.Writer.create()) {
      return b.collectionId !== "" && P.uint32(10).string(b.collectionId), b.projectId !== "" && P.uint32(18).string(b.projectId), b.destinationId !== "" && P.uint32(26).string(b.destinationId), b.metadata !== void 0 && p.Value.encode(p.Value.wrap(b.metadata), P.uint32(34).fork()).ldelim(), b.enabled !== void 0 && P.uint32(40).bool(b.enabled), b.address !== void 0 && a.DestinationAddress.encode(b.address, P.uint32(50).fork()).ldelim(), b.timeout !== void 0 && P.uint32(56).uint32(b.timeout), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = gr();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.projectId = N.string();
            break;
          case 3:
            ie.destinationId = N.string();
            break;
          case 4:
            ie.metadata = p.Value.unwrap(p.Value.decode(N, N.uint32()));
            break;
          case 5:
            ie.enabled = N.bool();
            break;
          case 6:
            ie.address = a.DestinationAddress.decode(N, N.uint32());
            break;
          case 7:
            ie.timeout = N.uint32();
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: De(b.collectionId) ? String(b.collectionId) : "",
        projectId: De(b.projectId) ? String(b.projectId) : "",
        destinationId: De(b.destinationId) ? String(b.destinationId) : "",
        metadata: De(b == null ? void 0 : b.metadata) ? b.metadata : void 0,
        enabled: De(b.enabled) ? !!b.enabled : void 0,
        address: De(b.address) ? a.DestinationAddress.fromJSON(b.address) : void 0,
        timeout: De(b.timeout) ? Number(b.timeout) : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.collectionId !== void 0 && (P.collectionId = b.collectionId), b.projectId !== void 0 && (P.projectId = b.projectId), b.destinationId !== void 0 && (P.destinationId = b.destinationId), b.metadata !== void 0 && (P.metadata = b.metadata), b.enabled !== void 0 && (P.enabled = b.enabled), b.address !== void 0 && (P.address = b.address ? a.DestinationAddress.toJSON(b.address) : void 0), b.timeout !== void 0 && (P.timeout = Math.round(b.timeout)), P;
    },
    fromPartial(b) {
      var P, N, Se, ie, ke, gt;
      const Ct = gr();
      return Ct.collectionId = (P = b.collectionId) !== null && P !== void 0 ? P : "", Ct.projectId = (N = b.projectId) !== null && N !== void 0 ? N : "", Ct.destinationId = (Se = b.destinationId) !== null && Se !== void 0 ? Se : "", Ct.metadata = (ie = b.metadata) !== null && ie !== void 0 ? ie : void 0, Ct.enabled = (ke = b.enabled) !== null && ke !== void 0 ? ke : void 0, Ct.address = b.address !== void 0 && b.address !== null ? a.DestinationAddress.fromPartial(b.address) : void 0, Ct.timeout = (gt = b.timeout) !== null && gt !== void 0 ? gt : void 0, Ct;
    }
  };
  function br() {
    return {
      collectionId: "",
      projectId: "",
      metadata: void 0,
      rendering: void 0,
      encoding: void 0,
      sources: [],
      destinations: [],
      composition: void 0,
      maxDuration: void 0,
      webrtc: void 0,
      triggers: [],
      location: void 0,
      guestCodes: []
    };
  }
  a.Project = {
    encode(b, P = c.default.Writer.create()) {
      b.collectionId !== "" && P.uint32(10).string(b.collectionId), b.projectId !== "" && P.uint32(18).string(b.projectId), b.metadata !== void 0 && p.Value.encode(p.Value.wrap(b.metadata), P.uint32(26).fork()).ldelim(), b.rendering !== void 0 && a.Rendering.encode(b.rendering, P.uint32(34).fork()).ldelim(), b.encoding !== void 0 && a.Encoding.encode(b.encoding, P.uint32(42).fork()).ldelim();
      for (const N of b.sources)
        a.Source.encode(N, P.uint32(50).fork()).ldelim();
      for (const N of b.destinations)
        a.Destination.encode(N, P.uint32(58).fork()).ldelim();
      b.composition !== void 0 && a.Composition.encode(b.composition, P.uint32(66).fork()).ldelim(), b.maxDuration !== void 0 && P.uint32(72).uint32(b.maxDuration), b.webrtc !== void 0 && a.WebRtc.encode(b.webrtc, P.uint32(82).fork()).ldelim();
      for (const N of b.triggers)
        a.ProjectTrigger.encode(N, P.uint32(90).fork()).ldelim();
      b.location !== void 0 && a.LatLong.encode(b.location, P.uint32(98).fork()).ldelim();
      for (const N of b.guestCodes)
        a.GuestCode.encode(N, P.uint32(106).fork()).ldelim();
      return P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = br();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.projectId = N.string();
            break;
          case 3:
            ie.metadata = p.Value.unwrap(p.Value.decode(N, N.uint32()));
            break;
          case 4:
            ie.rendering = a.Rendering.decode(N, N.uint32());
            break;
          case 5:
            ie.encoding = a.Encoding.decode(N, N.uint32());
            break;
          case 6:
            ie.sources.push(a.Source.decode(N, N.uint32()));
            break;
          case 7:
            ie.destinations.push(a.Destination.decode(N, N.uint32()));
            break;
          case 8:
            ie.composition = a.Composition.decode(N, N.uint32());
            break;
          case 9:
            ie.maxDuration = N.uint32();
            break;
          case 10:
            ie.webrtc = a.WebRtc.decode(N, N.uint32());
            break;
          case 11:
            ie.triggers.push(a.ProjectTrigger.decode(N, N.uint32()));
            break;
          case 12:
            ie.location = a.LatLong.decode(N, N.uint32());
            break;
          case 13:
            ie.guestCodes.push(a.GuestCode.decode(N, N.uint32()));
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: De(b.collectionId) ? String(b.collectionId) : "",
        projectId: De(b.projectId) ? String(b.projectId) : "",
        metadata: De(b == null ? void 0 : b.metadata) ? b.metadata : void 0,
        rendering: De(b.rendering) ? a.Rendering.fromJSON(b.rendering) : void 0,
        encoding: De(b.encoding) ? a.Encoding.fromJSON(b.encoding) : void 0,
        sources: Array.isArray(b == null ? void 0 : b.sources) ? b.sources.map((P) => a.Source.fromJSON(P)) : [],
        destinations: Array.isArray(b == null ? void 0 : b.destinations) ? b.destinations.map((P) => a.Destination.fromJSON(P)) : [],
        composition: De(b.composition) ? a.Composition.fromJSON(b.composition) : void 0,
        maxDuration: De(b.maxDuration) ? Number(b.maxDuration) : void 0,
        webrtc: De(b.webrtc) ? a.WebRtc.fromJSON(b.webrtc) : void 0,
        triggers: Array.isArray(b == null ? void 0 : b.triggers) ? b.triggers.map((P) => a.ProjectTrigger.fromJSON(P)) : [],
        location: De(b.location) ? a.LatLong.fromJSON(b.location) : void 0,
        guestCodes: Array.isArray(b == null ? void 0 : b.guestCodes) ? b.guestCodes.map((P) => a.GuestCode.fromJSON(P)) : []
      };
    },
    toJSON(b) {
      const P = {};
      return b.collectionId !== void 0 && (P.collectionId = b.collectionId), b.projectId !== void 0 && (P.projectId = b.projectId), b.metadata !== void 0 && (P.metadata = b.metadata), b.rendering !== void 0 && (P.rendering = b.rendering ? a.Rendering.toJSON(b.rendering) : void 0), b.encoding !== void 0 && (P.encoding = b.encoding ? a.Encoding.toJSON(b.encoding) : void 0), b.sources ? P.sources = b.sources.map((N) => N ? a.Source.toJSON(N) : void 0) : P.sources = [], b.destinations ? P.destinations = b.destinations.map((N) => N ? a.Destination.toJSON(N) : void 0) : P.destinations = [], b.composition !== void 0 && (P.composition = b.composition ? a.Composition.toJSON(b.composition) : void 0), b.maxDuration !== void 0 && (P.maxDuration = Math.round(b.maxDuration)), b.webrtc !== void 0 && (P.webrtc = b.webrtc ? a.WebRtc.toJSON(b.webrtc) : void 0), b.triggers ? P.triggers = b.triggers.map((N) => N ? a.ProjectTrigger.toJSON(N) : void 0) : P.triggers = [], b.location !== void 0 && (P.location = b.location ? a.LatLong.toJSON(b.location) : void 0), b.guestCodes ? P.guestCodes = b.guestCodes.map((N) => N ? a.GuestCode.toJSON(N) : void 0) : P.guestCodes = [], P;
    },
    fromPartial(b) {
      var P, N, Se, ie, ke, gt, Ct, Dt;
      const Lt = br();
      return Lt.collectionId = (P = b.collectionId) !== null && P !== void 0 ? P : "", Lt.projectId = (N = b.projectId) !== null && N !== void 0 ? N : "", Lt.metadata = (Se = b.metadata) !== null && Se !== void 0 ? Se : void 0, Lt.rendering = b.rendering !== void 0 && b.rendering !== null ? a.Rendering.fromPartial(b.rendering) : void 0, Lt.encoding = b.encoding !== void 0 && b.encoding !== null ? a.Encoding.fromPartial(b.encoding) : void 0, Lt.sources = ((ie = b.sources) === null || ie === void 0 ? void 0 : ie.map((qt) => a.Source.fromPartial(qt))) || [], Lt.destinations = ((ke = b.destinations) === null || ke === void 0 ? void 0 : ke.map((qt) => a.Destination.fromPartial(qt))) || [], Lt.composition = b.composition !== void 0 && b.composition !== null ? a.Composition.fromPartial(b.composition) : void 0, Lt.maxDuration = (gt = b.maxDuration) !== null && gt !== void 0 ? gt : void 0, Lt.webrtc = b.webrtc !== void 0 && b.webrtc !== null ? a.WebRtc.fromPartial(b.webrtc) : void 0, Lt.triggers = ((Ct = b.triggers) === null || Ct === void 0 ? void 0 : Ct.map((qt) => a.ProjectTrigger.fromPartial(qt))) || [], Lt.location = b.location !== void 0 && b.location !== null ? a.LatLong.fromPartial(b.location) : void 0, Lt.guestCodes = ((Dt = b.guestCodes) === null || Dt === void 0 ? void 0 : Dt.map((qt) => a.GuestCode.fromPartial(qt))) || [], Lt;
    }
  };
  function Sr() {
    return { collectionId: "", metadata: void 0, projects: [], sources: [] };
  }
  a.Collection = {
    encode(b, P = c.default.Writer.create()) {
      b.collectionId !== "" && P.uint32(10).string(b.collectionId), b.metadata !== void 0 && p.Value.encode(p.Value.wrap(b.metadata), P.uint32(18).fork()).ldelim();
      for (const N of b.projects)
        a.Project.encode(N, P.uint32(26).fork()).ldelim();
      for (const N of b.sources)
        a.Source.encode(N, P.uint32(34).fork()).ldelim();
      return P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = Sr();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.metadata = p.Value.unwrap(p.Value.decode(N, N.uint32()));
            break;
          case 3:
            ie.projects.push(a.Project.decode(N, N.uint32()));
            break;
          case 4:
            ie.sources.push(a.Source.decode(N, N.uint32()));
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: De(b.collectionId) ? String(b.collectionId) : "",
        metadata: De(b == null ? void 0 : b.metadata) ? b.metadata : void 0,
        projects: Array.isArray(b == null ? void 0 : b.projects) ? b.projects.map((P) => a.Project.fromJSON(P)) : [],
        sources: Array.isArray(b == null ? void 0 : b.sources) ? b.sources.map((P) => a.Source.fromJSON(P)) : []
      };
    },
    toJSON(b) {
      const P = {};
      return b.collectionId !== void 0 && (P.collectionId = b.collectionId), b.metadata !== void 0 && (P.metadata = b.metadata), b.projects ? P.projects = b.projects.map((N) => N ? a.Project.toJSON(N) : void 0) : P.projects = [], b.sources ? P.sources = b.sources.map((N) => N ? a.Source.toJSON(N) : void 0) : P.sources = [], P;
    },
    fromPartial(b) {
      var P, N, Se, ie;
      const ke = Sr();
      return ke.collectionId = (P = b.collectionId) !== null && P !== void 0 ? P : "", ke.metadata = (N = b.metadata) !== null && N !== void 0 ? N : void 0, ke.projects = ((Se = b.projects) === null || Se === void 0 ? void 0 : Se.map((gt) => a.Project.fromPartial(gt))) || [], ke.sources = ((ie = b.sources) === null || ie === void 0 ? void 0 : ie.map((gt) => a.Source.fromPartial(gt))) || [], ke;
    }
  };
  function _r() {
    return { metadata: void 0 };
  }
  a.CreateCollectionRequest = {
    encode(b, P = c.default.Writer.create()) {
      return b.metadata !== void 0 && p.Value.encode(p.Value.wrap(b.metadata), P.uint32(10).fork()).ldelim(), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = _r();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.metadata = p.Value.unwrap(p.Value.decode(N, N.uint32()));
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { metadata: De(b == null ? void 0 : b.metadata) ? b.metadata : void 0 };
    },
    toJSON(b) {
      const P = {};
      return b.metadata !== void 0 && (P.metadata = b.metadata), P;
    },
    fromPartial(b) {
      var P;
      const N = _r();
      return N.metadata = (P = b.metadata) !== null && P !== void 0 ? P : void 0, N;
    }
  };
  function Er() {
    return { collection: void 0 };
  }
  a.CreateCollectionResponse = {
    encode(b, P = c.default.Writer.create()) {
      return b.collection !== void 0 && a.Collection.encode(b.collection, P.uint32(10).fork()).ldelim(), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = Er();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.collection = a.Collection.decode(N, N.uint32());
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { collection: De(b.collection) ? a.Collection.fromJSON(b.collection) : void 0 };
    },
    toJSON(b) {
      const P = {};
      return b.collection !== void 0 && (P.collection = b.collection ? a.Collection.toJSON(b.collection) : void 0), P;
    },
    fromPartial(b) {
      const P = Er();
      return P.collection = b.collection !== void 0 && b.collection !== null ? a.Collection.fromPartial(b.collection) : void 0, P;
    }
  };
  function Tr() {
    return { collectionId: "", populateProjects: void 0, populateSources: void 0 };
  }
  a.GetCollectionRequest = {
    encode(b, P = c.default.Writer.create()) {
      return b.collectionId !== "" && P.uint32(10).string(b.collectionId), b.populateProjects !== void 0 && P.uint32(16).bool(b.populateProjects), b.populateSources !== void 0 && P.uint32(24).bool(b.populateSources), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = Tr();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.populateProjects = N.bool();
            break;
          case 3:
            ie.populateSources = N.bool();
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: De(b.collectionId) ? String(b.collectionId) : "",
        populateProjects: De(b.populateProjects) ? !!b.populateProjects : void 0,
        populateSources: De(b.populateSources) ? !!b.populateSources : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.collectionId !== void 0 && (P.collectionId = b.collectionId), b.populateProjects !== void 0 && (P.populateProjects = b.populateProjects), b.populateSources !== void 0 && (P.populateSources = b.populateSources), P;
    },
    fromPartial(b) {
      var P, N, Se;
      const ie = Tr();
      return ie.collectionId = (P = b.collectionId) !== null && P !== void 0 ? P : "", ie.populateProjects = (N = b.populateProjects) !== null && N !== void 0 ? N : void 0, ie.populateSources = (Se = b.populateSources) !== null && Se !== void 0 ? Se : void 0, ie;
    }
  };
  function wr() {
    return { collection: void 0 };
  }
  a.GetCollectionResponse = {
    encode(b, P = c.default.Writer.create()) {
      return b.collection !== void 0 && a.Collection.encode(b.collection, P.uint32(10).fork()).ldelim(), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = wr();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.collection = a.Collection.decode(N, N.uint32());
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { collection: De(b.collection) ? a.Collection.fromJSON(b.collection) : void 0 };
    },
    toJSON(b) {
      const P = {};
      return b.collection !== void 0 && (P.collection = b.collection ? a.Collection.toJSON(b.collection) : void 0), P;
    },
    fromPartial(b) {
      const P = wr();
      return P.collection = b.collection !== void 0 && b.collection !== null ? a.Collection.fromPartial(b.collection) : void 0, P;
    }
  };
  function kr() {
    return { collectionId: "", updateMask: void 0, metadata: void 0 };
  }
  a.UpdateCollectionRequest = {
    encode(b, P = c.default.Writer.create()) {
      return b.collectionId !== "" && P.uint32(10).string(b.collectionId), b.updateMask !== void 0 && v.FieldMask.encode(v.FieldMask.wrap(b.updateMask), P.uint32(18).fork()).ldelim(), b.metadata !== void 0 && p.Value.encode(p.Value.wrap(b.metadata), P.uint32(26).fork()).ldelim(), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = kr();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.updateMask = v.FieldMask.unwrap(v.FieldMask.decode(N, N.uint32()));
            break;
          case 3:
            ie.metadata = p.Value.unwrap(p.Value.decode(N, N.uint32()));
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: De(b.collectionId) ? String(b.collectionId) : "",
        updateMask: De(b.updateMask) ? v.FieldMask.unwrap(v.FieldMask.fromJSON(b.updateMask)) : void 0,
        metadata: De(b == null ? void 0 : b.metadata) ? b.metadata : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.collectionId !== void 0 && (P.collectionId = b.collectionId), b.updateMask !== void 0 && (P.updateMask = v.FieldMask.toJSON(v.FieldMask.wrap(b.updateMask))), b.metadata !== void 0 && (P.metadata = b.metadata), P;
    },
    fromPartial(b) {
      var P, N, Se;
      const ie = kr();
      return ie.collectionId = (P = b.collectionId) !== null && P !== void 0 ? P : "", ie.updateMask = (N = b.updateMask) !== null && N !== void 0 ? N : void 0, ie.metadata = (Se = b.metadata) !== null && Se !== void 0 ? Se : void 0, ie;
    }
  };
  function Ir() {
    return { collection: void 0 };
  }
  a.UpdateCollectionResponse = {
    encode(b, P = c.default.Writer.create()) {
      return b.collection !== void 0 && a.Collection.encode(b.collection, P.uint32(10).fork()).ldelim(), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = Ir();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.collection = a.Collection.decode(N, N.uint32());
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { collection: De(b.collection) ? a.Collection.fromJSON(b.collection) : void 0 };
    },
    toJSON(b) {
      const P = {};
      return b.collection !== void 0 && (P.collection = b.collection ? a.Collection.toJSON(b.collection) : void 0), P;
    },
    fromPartial(b) {
      const P = Ir();
      return P.collection = b.collection !== void 0 && b.collection !== null ? a.Collection.fromPartial(b.collection) : void 0, P;
    }
  };
  function Rr() {
    return { collectionId: "", force: void 0 };
  }
  a.DeleteCollectionRequest = {
    encode(b, P = c.default.Writer.create()) {
      return b.collectionId !== "" && P.uint32(10).string(b.collectionId), b.force !== void 0 && P.uint32(16).bool(b.force), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = Rr();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.force = N.bool();
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: De(b.collectionId) ? String(b.collectionId) : "",
        force: De(b.force) ? !!b.force : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.collectionId !== void 0 && (P.collectionId = b.collectionId), b.force !== void 0 && (P.force = b.force), P;
    },
    fromPartial(b) {
      var P, N;
      const Se = Rr();
      return Se.collectionId = (P = b.collectionId) !== null && P !== void 0 ? P : "", Se.force = (N = b.force) !== null && N !== void 0 ? N : void 0, Se;
    }
  };
  function Cr() {
    return { sourcesDeleted: 0, projectsDeleted: 0, projectIdsStopped: [] };
  }
  a.DeleteCollectionResponse = {
    encode(b, P = c.default.Writer.create()) {
      b.sourcesDeleted !== 0 && P.uint32(8).uint32(b.sourcesDeleted), b.projectsDeleted !== 0 && P.uint32(16).uint32(b.projectsDeleted);
      for (const N of b.projectIdsStopped)
        P.uint32(26).string(N);
      return P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = Cr();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.sourcesDeleted = N.uint32();
            break;
          case 2:
            ie.projectsDeleted = N.uint32();
            break;
          case 3:
            ie.projectIdsStopped.push(N.string());
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        sourcesDeleted: De(b.sourcesDeleted) ? Number(b.sourcesDeleted) : 0,
        projectsDeleted: De(b.projectsDeleted) ? Number(b.projectsDeleted) : 0,
        projectIdsStopped: Array.isArray(b == null ? void 0 : b.projectIdsStopped) ? b.projectIdsStopped.map((P) => String(P)) : []
      };
    },
    toJSON(b) {
      const P = {};
      return b.sourcesDeleted !== void 0 && (P.sourcesDeleted = Math.round(b.sourcesDeleted)), b.projectsDeleted !== void 0 && (P.projectsDeleted = Math.round(b.projectsDeleted)), b.projectIdsStopped ? P.projectIdsStopped = b.projectIdsStopped.map((N) => N) : P.projectIdsStopped = [], P;
    },
    fromPartial(b) {
      var P, N, Se;
      const ie = Cr();
      return ie.sourcesDeleted = (P = b.sourcesDeleted) !== null && P !== void 0 ? P : 0, ie.projectsDeleted = (N = b.projectsDeleted) !== null && N !== void 0 ? N : 0, ie.projectIdsStopped = ((Se = b.projectIdsStopped) === null || Se === void 0 ? void 0 : Se.map((ke) => ke)) || [], ie;
    }
  };
  function Pr() {
    return {};
  }
  a.GetCollectionsRequest = {
    encode(b, P = c.default.Writer.create()) {
      return P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = Pr();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {};
    },
    toJSON(b) {
      return {};
    },
    fromPartial(b) {
      return Pr();
    }
  };
  function Or() {
    return { collections: [] };
  }
  a.GetCollectionsResponse = {
    encode(b, P = c.default.Writer.create()) {
      for (const N of b.collections)
        a.Collection.encode(N, P.uint32(10).fork()).ldelim();
      return P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = Or();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.collections.push(a.Collection.decode(N, N.uint32()));
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collections: Array.isArray(b == null ? void 0 : b.collections) ? b.collections.map((P) => a.Collection.fromJSON(P)) : []
      };
    },
    toJSON(b) {
      const P = {};
      return b.collections ? P.collections = b.collections.map((N) => N ? a.Collection.toJSON(N) : void 0) : P.collections = [], P;
    },
    fromPartial(b) {
      var P;
      const N = Or();
      return N.collections = ((P = b.collections) === null || P === void 0 ? void 0 : P.map((Se) => a.Collection.fromPartial(Se))) || [], N;
    }
  };
  function Mr() {
    return {
      collectionId: "",
      metadata: void 0,
      rendering: void 0,
      encoding: void 0,
      composition: void 0,
      maxDuration: void 0,
      webrtc: void 0,
      location: void 0
    };
  }
  a.CreateProjectRequest = {
    encode(b, P = c.default.Writer.create()) {
      return b.collectionId !== "" && P.uint32(10).string(b.collectionId), b.metadata !== void 0 && p.Value.encode(p.Value.wrap(b.metadata), P.uint32(18).fork()).ldelim(), b.rendering !== void 0 && a.Rendering.encode(b.rendering, P.uint32(26).fork()).ldelim(), b.encoding !== void 0 && a.Encoding.encode(b.encoding, P.uint32(34).fork()).ldelim(), b.composition !== void 0 && a.Composition.encode(b.composition, P.uint32(42).fork()).ldelim(), b.maxDuration !== void 0 && P.uint32(48).uint32(b.maxDuration), b.webrtc !== void 0 && a.WebRtc.encode(b.webrtc, P.uint32(58).fork()).ldelim(), b.location !== void 0 && a.LatLong.encode(b.location, P.uint32(74).fork()).ldelim(), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = Mr();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.metadata = p.Value.unwrap(p.Value.decode(N, N.uint32()));
            break;
          case 3:
            ie.rendering = a.Rendering.decode(N, N.uint32());
            break;
          case 4:
            ie.encoding = a.Encoding.decode(N, N.uint32());
            break;
          case 5:
            ie.composition = a.Composition.decode(N, N.uint32());
            break;
          case 6:
            ie.maxDuration = N.uint32();
            break;
          case 7:
            ie.webrtc = a.WebRtc.decode(N, N.uint32());
            break;
          case 9:
            ie.location = a.LatLong.decode(N, N.uint32());
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: De(b.collectionId) ? String(b.collectionId) : "",
        metadata: De(b == null ? void 0 : b.metadata) ? b.metadata : void 0,
        rendering: De(b.rendering) ? a.Rendering.fromJSON(b.rendering) : void 0,
        encoding: De(b.encoding) ? a.Encoding.fromJSON(b.encoding) : void 0,
        composition: De(b.composition) ? a.Composition.fromJSON(b.composition) : void 0,
        maxDuration: De(b.maxDuration) ? Number(b.maxDuration) : void 0,
        webrtc: De(b.webrtc) ? a.WebRtc.fromJSON(b.webrtc) : void 0,
        location: De(b.location) ? a.LatLong.fromJSON(b.location) : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.collectionId !== void 0 && (P.collectionId = b.collectionId), b.metadata !== void 0 && (P.metadata = b.metadata), b.rendering !== void 0 && (P.rendering = b.rendering ? a.Rendering.toJSON(b.rendering) : void 0), b.encoding !== void 0 && (P.encoding = b.encoding ? a.Encoding.toJSON(b.encoding) : void 0), b.composition !== void 0 && (P.composition = b.composition ? a.Composition.toJSON(b.composition) : void 0), b.maxDuration !== void 0 && (P.maxDuration = Math.round(b.maxDuration)), b.webrtc !== void 0 && (P.webrtc = b.webrtc ? a.WebRtc.toJSON(b.webrtc) : void 0), b.location !== void 0 && (P.location = b.location ? a.LatLong.toJSON(b.location) : void 0), P;
    },
    fromPartial(b) {
      var P, N, Se;
      const ie = Mr();
      return ie.collectionId = (P = b.collectionId) !== null && P !== void 0 ? P : "", ie.metadata = (N = b.metadata) !== null && N !== void 0 ? N : void 0, ie.rendering = b.rendering !== void 0 && b.rendering !== null ? a.Rendering.fromPartial(b.rendering) : void 0, ie.encoding = b.encoding !== void 0 && b.encoding !== null ? a.Encoding.fromPartial(b.encoding) : void 0, ie.composition = b.composition !== void 0 && b.composition !== null ? a.Composition.fromPartial(b.composition) : void 0, ie.maxDuration = (Se = b.maxDuration) !== null && Se !== void 0 ? Se : void 0, ie.webrtc = b.webrtc !== void 0 && b.webrtc !== null ? a.WebRtc.fromPartial(b.webrtc) : void 0, ie.location = b.location !== void 0 && b.location !== null ? a.LatLong.fromPartial(b.location) : void 0, ie;
    }
  };
  function Ar() {
    return { project: void 0 };
  }
  a.CreateProjectResponse = {
    encode(b, P = c.default.Writer.create()) {
      return b.project !== void 0 && a.Project.encode(b.project, P.uint32(10).fork()).ldelim(), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = Ar();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.project = a.Project.decode(N, N.uint32());
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { project: De(b.project) ? a.Project.fromJSON(b.project) : void 0 };
    },
    toJSON(b) {
      const P = {};
      return b.project !== void 0 && (P.project = b.project ? a.Project.toJSON(b.project) : void 0), P;
    },
    fromPartial(b) {
      const P = Ar();
      return P.project = b.project !== void 0 && b.project !== null ? a.Project.fromPartial(b.project) : void 0, P;
    }
  };
  function Nr() {
    return {
      collectionId: "",
      projectId: "",
      updateMask: void 0,
      metadata: void 0,
      rendering: void 0,
      encoding: void 0,
      composition: void 0,
      maxDuration: void 0,
      webrtc: void 0,
      location: void 0
    };
  }
  a.UpdateProjectRequest = {
    encode(b, P = c.default.Writer.create()) {
      return b.collectionId !== "" && P.uint32(10).string(b.collectionId), b.projectId !== "" && P.uint32(18).string(b.projectId), b.updateMask !== void 0 && v.FieldMask.encode(v.FieldMask.wrap(b.updateMask), P.uint32(26).fork()).ldelim(), b.metadata !== void 0 && p.Value.encode(p.Value.wrap(b.metadata), P.uint32(34).fork()).ldelim(), b.rendering !== void 0 && a.Rendering.encode(b.rendering, P.uint32(42).fork()).ldelim(), b.encoding !== void 0 && a.Encoding.encode(b.encoding, P.uint32(50).fork()).ldelim(), b.composition !== void 0 && a.Composition.encode(b.composition, P.uint32(58).fork()).ldelim(), b.maxDuration !== void 0 && P.uint32(64).uint32(b.maxDuration), b.webrtc !== void 0 && a.WebRtc.encode(b.webrtc, P.uint32(74).fork()).ldelim(), b.location !== void 0 && a.LatLong.encode(b.location, P.uint32(82).fork()).ldelim(), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = Nr();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.projectId = N.string();
            break;
          case 3:
            ie.updateMask = v.FieldMask.unwrap(v.FieldMask.decode(N, N.uint32()));
            break;
          case 4:
            ie.metadata = p.Value.unwrap(p.Value.decode(N, N.uint32()));
            break;
          case 5:
            ie.rendering = a.Rendering.decode(N, N.uint32());
            break;
          case 6:
            ie.encoding = a.Encoding.decode(N, N.uint32());
            break;
          case 7:
            ie.composition = a.Composition.decode(N, N.uint32());
            break;
          case 8:
            ie.maxDuration = N.uint32();
            break;
          case 9:
            ie.webrtc = a.WebRtc.decode(N, N.uint32());
            break;
          case 10:
            ie.location = a.LatLong.decode(N, N.uint32());
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: De(b.collectionId) ? String(b.collectionId) : "",
        projectId: De(b.projectId) ? String(b.projectId) : "",
        updateMask: De(b.updateMask) ? v.FieldMask.unwrap(v.FieldMask.fromJSON(b.updateMask)) : void 0,
        metadata: De(b == null ? void 0 : b.metadata) ? b.metadata : void 0,
        rendering: De(b.rendering) ? a.Rendering.fromJSON(b.rendering) : void 0,
        encoding: De(b.encoding) ? a.Encoding.fromJSON(b.encoding) : void 0,
        composition: De(b.composition) ? a.Composition.fromJSON(b.composition) : void 0,
        maxDuration: De(b.maxDuration) ? Number(b.maxDuration) : void 0,
        webrtc: De(b.webrtc) ? a.WebRtc.fromJSON(b.webrtc) : void 0,
        location: De(b.location) ? a.LatLong.fromJSON(b.location) : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.collectionId !== void 0 && (P.collectionId = b.collectionId), b.projectId !== void 0 && (P.projectId = b.projectId), b.updateMask !== void 0 && (P.updateMask = v.FieldMask.toJSON(v.FieldMask.wrap(b.updateMask))), b.metadata !== void 0 && (P.metadata = b.metadata), b.rendering !== void 0 && (P.rendering = b.rendering ? a.Rendering.toJSON(b.rendering) : void 0), b.encoding !== void 0 && (P.encoding = b.encoding ? a.Encoding.toJSON(b.encoding) : void 0), b.composition !== void 0 && (P.composition = b.composition ? a.Composition.toJSON(b.composition) : void 0), b.maxDuration !== void 0 && (P.maxDuration = Math.round(b.maxDuration)), b.webrtc !== void 0 && (P.webrtc = b.webrtc ? a.WebRtc.toJSON(b.webrtc) : void 0), b.location !== void 0 && (P.location = b.location ? a.LatLong.toJSON(b.location) : void 0), P;
    },
    fromPartial(b) {
      var P, N, Se, ie, ke;
      const gt = Nr();
      return gt.collectionId = (P = b.collectionId) !== null && P !== void 0 ? P : "", gt.projectId = (N = b.projectId) !== null && N !== void 0 ? N : "", gt.updateMask = (Se = b.updateMask) !== null && Se !== void 0 ? Se : void 0, gt.metadata = (ie = b.metadata) !== null && ie !== void 0 ? ie : void 0, gt.rendering = b.rendering !== void 0 && b.rendering !== null ? a.Rendering.fromPartial(b.rendering) : void 0, gt.encoding = b.encoding !== void 0 && b.encoding !== null ? a.Encoding.fromPartial(b.encoding) : void 0, gt.composition = b.composition !== void 0 && b.composition !== null ? a.Composition.fromPartial(b.composition) : void 0, gt.maxDuration = (ke = b.maxDuration) !== null && ke !== void 0 ? ke : void 0, gt.webrtc = b.webrtc !== void 0 && b.webrtc !== null ? a.WebRtc.fromPartial(b.webrtc) : void 0, gt.location = b.location !== void 0 && b.location !== null ? a.LatLong.fromPartial(b.location) : void 0, gt;
    }
  };
  function $r() {
    return { project: void 0, broadcastUpdated: !1 };
  }
  a.UpdateProjectResponse = {
    encode(b, P = c.default.Writer.create()) {
      return b.project !== void 0 && a.Project.encode(b.project, P.uint32(10).fork()).ldelim(), b.broadcastUpdated === !0 && P.uint32(16).bool(b.broadcastUpdated), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = $r();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.project = a.Project.decode(N, N.uint32());
            break;
          case 2:
            ie.broadcastUpdated = N.bool();
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        project: De(b.project) ? a.Project.fromJSON(b.project) : void 0,
        broadcastUpdated: De(b.broadcastUpdated) ? !!b.broadcastUpdated : !1
      };
    },
    toJSON(b) {
      const P = {};
      return b.project !== void 0 && (P.project = b.project ? a.Project.toJSON(b.project) : void 0), b.broadcastUpdated !== void 0 && (P.broadcastUpdated = b.broadcastUpdated), P;
    },
    fromPartial(b) {
      var P;
      const N = $r();
      return N.project = b.project !== void 0 && b.project !== null ? a.Project.fromPartial(b.project) : void 0, N.broadcastUpdated = (P = b.broadcastUpdated) !== null && P !== void 0 ? P : !1, N;
    }
  };
  function Dr() {
    return { collectionId: "", projectId: "", force: void 0 };
  }
  a.DeleteProjectRequest = {
    encode(b, P = c.default.Writer.create()) {
      return b.collectionId !== "" && P.uint32(10).string(b.collectionId), b.projectId !== "" && P.uint32(18).string(b.projectId), b.force !== void 0 && P.uint32(24).bool(b.force), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = Dr();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.projectId = N.string();
            break;
          case 3:
            ie.force = N.bool();
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: De(b.collectionId) ? String(b.collectionId) : "",
        projectId: De(b.projectId) ? String(b.projectId) : "",
        force: De(b.force) ? !!b.force : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.collectionId !== void 0 && (P.collectionId = b.collectionId), b.projectId !== void 0 && (P.projectId = b.projectId), b.force !== void 0 && (P.force = b.force), P;
    },
    fromPartial(b) {
      var P, N, Se;
      const ie = Dr();
      return ie.collectionId = (P = b.collectionId) !== null && P !== void 0 ? P : "", ie.projectId = (N = b.projectId) !== null && N !== void 0 ? N : "", ie.force = (Se = b.force) !== null && Se !== void 0 ? Se : void 0, ie;
    }
  };
  function Lr() {
    return { broadcastStopped: !1, layoutsDeleted: 0 };
  }
  a.DeleteProjectResponse = {
    encode(b, P = c.default.Writer.create()) {
      return b.broadcastStopped === !0 && P.uint32(8).bool(b.broadcastStopped), b.layoutsDeleted !== 0 && P.uint32(16).uint32(b.layoutsDeleted), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = Lr();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.broadcastStopped = N.bool();
            break;
          case 2:
            ie.layoutsDeleted = N.uint32();
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        broadcastStopped: De(b.broadcastStopped) ? !!b.broadcastStopped : !1,
        layoutsDeleted: De(b.layoutsDeleted) ? Number(b.layoutsDeleted) : 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.broadcastStopped !== void 0 && (P.broadcastStopped = b.broadcastStopped), b.layoutsDeleted !== void 0 && (P.layoutsDeleted = Math.round(b.layoutsDeleted)), P;
    },
    fromPartial(b) {
      var P, N;
      const Se = Lr();
      return Se.broadcastStopped = (P = b.broadcastStopped) !== null && P !== void 0 ? P : !1, Se.layoutsDeleted = (N = b.layoutsDeleted) !== null && N !== void 0 ? N : 0, Se;
    }
  };
  function Br() {
    return {
      collectionId: "",
      projectId: "",
      webrtcStart: void 0,
      async: void 0,
      dynamicSources: {},
      triggerMetadata: void 0
    };
  }
  a.StartProjectBroadcastRequest = {
    encode(b, P = c.default.Writer.create()) {
      return b.collectionId !== "" && P.uint32(10).string(b.collectionId), b.projectId !== "" && P.uint32(18).string(b.projectId), b.webrtcStart !== void 0 && P.uint32(24).bool(b.webrtcStart), b.async !== void 0 && P.uint32(32).bool(b.async), Object.entries(b.dynamicSources).forEach(([N, Se]) => {
        a.StartProjectBroadcastRequest_DynamicSourcesEntry.encode({ key: N, value: Se }, P.uint32(42).fork()).ldelim();
      }), b.triggerMetadata !== void 0 && p.Value.encode(p.Value.wrap(b.triggerMetadata), P.uint32(58).fork()).ldelim(), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = Br();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.projectId = N.string();
            break;
          case 3:
            ie.webrtcStart = N.bool();
            break;
          case 4:
            ie.async = N.bool();
            break;
          case 5:
            const gt = a.StartProjectBroadcastRequest_DynamicSourcesEntry.decode(N, N.uint32());
            gt.value !== void 0 && (ie.dynamicSources[gt.key] = gt.value);
            break;
          case 7:
            ie.triggerMetadata = p.Value.unwrap(p.Value.decode(N, N.uint32()));
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: De(b.collectionId) ? String(b.collectionId) : "",
        projectId: De(b.projectId) ? String(b.projectId) : "",
        webrtcStart: De(b.webrtcStart) ? !!b.webrtcStart : void 0,
        async: De(b.async) ? !!b.async : void 0,
        dynamicSources: Ii(b.dynamicSources) ? Object.entries(b.dynamicSources).reduce((P, [N, Se]) => (P[N] = a.RuntimeSourceAddress.fromJSON(Se), P), {}) : {},
        triggerMetadata: De(b == null ? void 0 : b.triggerMetadata) ? b.triggerMetadata : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.collectionId !== void 0 && (P.collectionId = b.collectionId), b.projectId !== void 0 && (P.projectId = b.projectId), b.webrtcStart !== void 0 && (P.webrtcStart = b.webrtcStart), b.async !== void 0 && (P.async = b.async), P.dynamicSources = {}, b.dynamicSources && Object.entries(b.dynamicSources).forEach(([N, Se]) => {
        P.dynamicSources[N] = a.RuntimeSourceAddress.toJSON(Se);
      }), b.triggerMetadata !== void 0 && (P.triggerMetadata = b.triggerMetadata), P;
    },
    fromPartial(b) {
      var P, N, Se, ie, ke, gt;
      const Ct = Br();
      return Ct.collectionId = (P = b.collectionId) !== null && P !== void 0 ? P : "", Ct.projectId = (N = b.projectId) !== null && N !== void 0 ? N : "", Ct.webrtcStart = (Se = b.webrtcStart) !== null && Se !== void 0 ? Se : void 0, Ct.async = (ie = b.async) !== null && ie !== void 0 ? ie : void 0, Ct.dynamicSources = Object.entries((ke = b.dynamicSources) !== null && ke !== void 0 ? ke : {}).reduce((Dt, [Lt, qt]) => (qt !== void 0 && (Dt[Lt] = a.RuntimeSourceAddress.fromPartial(qt)), Dt), {}), Ct.triggerMetadata = (gt = b.triggerMetadata) !== null && gt !== void 0 ? gt : void 0, Ct;
    }
  };
  function Ur() {
    return { key: "", value: void 0 };
  }
  a.StartProjectBroadcastRequest_DynamicSourcesEntry = {
    encode(b, P = c.default.Writer.create()) {
      return b.key !== "" && P.uint32(10).string(b.key), b.value !== void 0 && a.RuntimeSourceAddress.encode(b.value, P.uint32(18).fork()).ldelim(), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = Ur();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.key = N.string();
            break;
          case 2:
            ie.value = a.RuntimeSourceAddress.decode(N, N.uint32());
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        key: De(b.key) ? String(b.key) : "",
        value: De(b.value) ? a.RuntimeSourceAddress.fromJSON(b.value) : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.key !== void 0 && (P.key = b.key), b.value !== void 0 && (P.value = b.value ? a.RuntimeSourceAddress.toJSON(b.value) : void 0), P;
    },
    fromPartial(b) {
      var P;
      const N = Ur();
      return N.key = (P = b.key) !== null && P !== void 0 ? P : "", N.value = b.value !== void 0 && b.value !== null ? a.RuntimeSourceAddress.fromPartial(b.value) : void 0, N;
    }
  };
  function xr() {
    return { broadcastId: "" };
  }
  a.StartProjectBroadcastResponse = {
    encode(b, P = c.default.Writer.create()) {
      return b.broadcastId !== "" && P.uint32(10).string(b.broadcastId), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = xr();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.broadcastId = N.string();
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { broadcastId: De(b.broadcastId) ? String(b.broadcastId) : "" };
    },
    toJSON(b) {
      const P = {};
      return b.broadcastId !== void 0 && (P.broadcastId = b.broadcastId), P;
    },
    fromPartial(b) {
      var P;
      const N = xr();
      return N.broadcastId = (P = b.broadcastId) !== null && P !== void 0 ? P : "", N;
    }
  };
  function Fr() {
    return { collectionId: "", projectId: "", webrtcStop: void 0 };
  }
  a.StopProjectBroadcastRequest = {
    encode(b, P = c.default.Writer.create()) {
      return b.collectionId !== "" && P.uint32(10).string(b.collectionId), b.projectId !== "" && P.uint32(18).string(b.projectId), b.webrtcStop !== void 0 && P.uint32(24).bool(b.webrtcStop), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = Fr();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.projectId = N.string();
            break;
          case 3:
            ie.webrtcStop = N.bool();
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: De(b.collectionId) ? String(b.collectionId) : "",
        projectId: De(b.projectId) ? String(b.projectId) : "",
        webrtcStop: De(b.webrtcStop) ? !!b.webrtcStop : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.collectionId !== void 0 && (P.collectionId = b.collectionId), b.projectId !== void 0 && (P.projectId = b.projectId), b.webrtcStop !== void 0 && (P.webrtcStop = b.webrtcStop), P;
    },
    fromPartial(b) {
      var P, N, Se;
      const ie = Fr();
      return ie.collectionId = (P = b.collectionId) !== null && P !== void 0 ? P : "", ie.projectId = (N = b.projectId) !== null && N !== void 0 ? N : "", ie.webrtcStop = (Se = b.webrtcStop) !== null && Se !== void 0 ? Se : void 0, ie;
    }
  };
  function qr() {
    return {};
  }
  a.StopProjectBroadcastResponse = {
    encode(b, P = c.default.Writer.create()) {
      return P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = qr();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {};
    },
    toJSON(b) {
      return {};
    },
    fromPartial(b) {
      return qr();
    }
  };
  function Vr() {
    return { collectionId: "", projectId: "", status: void 0 };
  }
  a.GetProjectRequest = {
    encode(b, P = c.default.Writer.create()) {
      return b.collectionId !== "" && P.uint32(10).string(b.collectionId), b.projectId !== "" && P.uint32(18).string(b.projectId), b.status !== void 0 && P.uint32(24).bool(b.status), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = Vr();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.projectId = N.string();
            break;
          case 3:
            ie.status = N.bool();
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: De(b.collectionId) ? String(b.collectionId) : "",
        projectId: De(b.projectId) ? String(b.projectId) : "",
        status: De(b.status) ? !!b.status : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.collectionId !== void 0 && (P.collectionId = b.collectionId), b.projectId !== void 0 && (P.projectId = b.projectId), b.status !== void 0 && (P.status = b.status), P;
    },
    fromPartial(b) {
      var P, N, Se;
      const ie = Vr();
      return ie.collectionId = (P = b.collectionId) !== null && P !== void 0 ? P : "", ie.projectId = (N = b.projectId) !== null && N !== void 0 ? N : "", ie.status = (Se = b.status) !== null && Se !== void 0 ? Se : void 0, ie;
    }
  };
  function Jr() {
    return { project: void 0, status: void 0 };
  }
  a.GetProjectResponse = {
    encode(b, P = c.default.Writer.create()) {
      return b.project !== void 0 && a.Project.encode(b.project, P.uint32(10).fork()).ldelim(), b.status !== void 0 && a.ProjectBroadcastStatus.encode(b.status, P.uint32(18).fork()).ldelim(), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = Jr();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.project = a.Project.decode(N, N.uint32());
            break;
          case 2:
            ie.status = a.ProjectBroadcastStatus.decode(N, N.uint32());
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        project: De(b.project) ? a.Project.fromJSON(b.project) : void 0,
        status: De(b.status) ? a.ProjectBroadcastStatus.fromJSON(b.status) : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.project !== void 0 && (P.project = b.project ? a.Project.toJSON(b.project) : void 0), b.status !== void 0 && (P.status = b.status ? a.ProjectBroadcastStatus.toJSON(b.status) : void 0), P;
    },
    fromPartial(b) {
      const P = Jr();
      return P.project = b.project !== void 0 && b.project !== null ? a.Project.fromPartial(b.project) : void 0, P.status = b.status !== void 0 && b.status !== null ? a.ProjectBroadcastStatus.fromPartial(b.status) : void 0, P;
    }
  };
  function Gr() {
    return { collectionId: "", projectId: "", format: void 0 };
  }
  a.GetProjectBroadcastSnapshotRequest = {
    encode(b, P = c.default.Writer.create()) {
      return b.collectionId !== "" && P.uint32(10).string(b.collectionId), b.projectId !== "" && P.uint32(18).string(b.projectId), b.format !== void 0 && P.uint32(24).int32(Re(b.format)), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = Gr();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.projectId = N.string();
            break;
          case 3:
            ie.format = fe(N.int32());
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: De(b.collectionId) ? String(b.collectionId) : "",
        projectId: De(b.projectId) ? String(b.projectId) : "",
        format: De(b.format) ? fe(b.format) : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.collectionId !== void 0 && (P.collectionId = b.collectionId), b.projectId !== void 0 && (P.projectId = b.projectId), b.format !== void 0 && (P.format = b.format !== void 0 ? Te(b.format) : void 0), P;
    },
    fromPartial(b) {
      var P, N, Se;
      const ie = Gr();
      return ie.collectionId = (P = b.collectionId) !== null && P !== void 0 ? P : "", ie.projectId = (N = b.projectId) !== null && N !== void 0 ? N : "", ie.format = (Se = b.format) !== null && Se !== void 0 ? Se : void 0, ie;
    }
  };
  function Wr() {
    return { format: de.IMAGE_FORMAT_UNSPECIFIED, image: new Uint8Array() };
  }
  a.GetProjectBroadcastSnapshotResponse = {
    encode(b, P = c.default.Writer.create()) {
      return b.format !== de.IMAGE_FORMAT_UNSPECIFIED && P.uint32(8).int32(Re(b.format)), b.image.length !== 0 && P.uint32(18).bytes(b.image), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = Wr();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.format = fe(N.int32());
            break;
          case 2:
            ie.image = N.bytes();
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        format: De(b.format) ? fe(b.format) : de.IMAGE_FORMAT_UNSPECIFIED,
        image: De(b.image) ? wi(b.image) : new Uint8Array()
      };
    },
    toJSON(b) {
      const P = {};
      return b.format !== void 0 && (P.format = Te(b.format)), b.image !== void 0 && (P.image = ki(b.image !== void 0 ? b.image : new Uint8Array())), P;
    },
    fromPartial(b) {
      var P, N;
      const Se = Wr();
      return Se.format = (P = b.format) !== null && P !== void 0 ? P : de.IMAGE_FORMAT_UNSPECIFIED, Se.image = (N = b.image) !== null && N !== void 0 ? N : new Uint8Array(), Se;
    }
  };
  function Hr() {
    return { collectionId: "", projectId: "" };
  }
  a.GetProjectBroadcastStatusRequest = {
    encode(b, P = c.default.Writer.create()) {
      return b.collectionId !== "" && P.uint32(10).string(b.collectionId), b.projectId !== "" && P.uint32(18).string(b.projectId), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = Hr();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.projectId = N.string();
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: De(b.collectionId) ? String(b.collectionId) : "",
        projectId: De(b.projectId) ? String(b.projectId) : ""
      };
    },
    toJSON(b) {
      const P = {};
      return b.collectionId !== void 0 && (P.collectionId = b.collectionId), b.projectId !== void 0 && (P.projectId = b.projectId), P;
    },
    fromPartial(b) {
      var P, N;
      const Se = Hr();
      return Se.collectionId = (P = b.collectionId) !== null && P !== void 0 ? P : "", Se.projectId = (N = b.projectId) !== null && N !== void 0 ? N : "", Se;
    }
  };
  function Kr() {
    return { status: void 0 };
  }
  a.GetProjectBroadcastStatusResponse = {
    encode(b, P = c.default.Writer.create()) {
      return b.status !== void 0 && a.ProjectBroadcastStatus.encode(b.status, P.uint32(10).fork()).ldelim(), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = Kr();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.status = a.ProjectBroadcastStatus.decode(N, N.uint32());
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { status: De(b.status) ? a.ProjectBroadcastStatus.fromJSON(b.status) : void 0 };
    },
    toJSON(b) {
      const P = {};
      return b.status !== void 0 && (P.status = b.status ? a.ProjectBroadcastStatus.toJSON(b.status) : void 0), P;
    },
    fromPartial(b) {
      const P = Kr();
      return P.status = b.status !== void 0 && b.status !== null ? a.ProjectBroadcastStatus.fromPartial(b.status) : void 0, P;
    }
  };
  function Yr() {
    return { collectionId: "", projectId: "" };
  }
  a.StartProjectWebRtcRequest = {
    encode(b, P = c.default.Writer.create()) {
      return b.collectionId !== "" && P.uint32(10).string(b.collectionId), b.projectId !== "" && P.uint32(18).string(b.projectId), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = Yr();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.projectId = N.string();
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: De(b.collectionId) ? String(b.collectionId) : "",
        projectId: De(b.projectId) ? String(b.projectId) : ""
      };
    },
    toJSON(b) {
      const P = {};
      return b.collectionId !== void 0 && (P.collectionId = b.collectionId), b.projectId !== void 0 && (P.projectId = b.projectId), P;
    },
    fromPartial(b) {
      var P, N;
      const Se = Yr();
      return Se.collectionId = (P = b.collectionId) !== null && P !== void 0 ? P : "", Se.projectId = (N = b.projectId) !== null && N !== void 0 ? N : "", Se;
    }
  };
  function jr() {
    return {};
  }
  a.StartProjectWebRtcResponse = {
    encode(b, P = c.default.Writer.create()) {
      return P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = jr();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {};
    },
    toJSON(b) {
      return {};
    },
    fromPartial(b) {
      return jr();
    }
  };
  function Zr() {
    return { collectionId: "", projectId: "" };
  }
  a.StopProjectWebRtcRequest = {
    encode(b, P = c.default.Writer.create()) {
      return b.collectionId !== "" && P.uint32(10).string(b.collectionId), b.projectId !== "" && P.uint32(18).string(b.projectId), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = Zr();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.projectId = N.string();
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: De(b.collectionId) ? String(b.collectionId) : "",
        projectId: De(b.projectId) ? String(b.projectId) : ""
      };
    },
    toJSON(b) {
      const P = {};
      return b.collectionId !== void 0 && (P.collectionId = b.collectionId), b.projectId !== void 0 && (P.projectId = b.projectId), P;
    },
    fromPartial(b) {
      var P, N;
      const Se = Zr();
      return Se.collectionId = (P = b.collectionId) !== null && P !== void 0 ? P : "", Se.projectId = (N = b.projectId) !== null && N !== void 0 ? N : "", Se;
    }
  };
  function Xr() {
    return {};
  }
  a.StopProjectWebRtcResponse = {
    encode(b, P = c.default.Writer.create()) {
      return P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = Xr();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {};
    },
    toJSON(b) {
      return {};
    },
    fromPartial(b) {
      return Xr();
    }
  };
  function Qr() {
    return {
      collectionId: "",
      projectId: "",
      metadata: void 0,
      address: void 0,
      enabled: void 0,
      timeout: void 0
    };
  }
  a.CreateDestinationRequest = {
    encode(b, P = c.default.Writer.create()) {
      return b.collectionId !== "" && P.uint32(10).string(b.collectionId), b.projectId !== "" && P.uint32(18).string(b.projectId), b.metadata !== void 0 && p.Value.encode(p.Value.wrap(b.metadata), P.uint32(26).fork()).ldelim(), b.address !== void 0 && a.DestinationAddress.encode(b.address, P.uint32(42).fork()).ldelim(), b.enabled !== void 0 && P.uint32(48).bool(b.enabled), b.timeout !== void 0 && P.uint32(56).uint32(b.timeout), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = Qr();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.projectId = N.string();
            break;
          case 3:
            ie.metadata = p.Value.unwrap(p.Value.decode(N, N.uint32()));
            break;
          case 5:
            ie.address = a.DestinationAddress.decode(N, N.uint32());
            break;
          case 6:
            ie.enabled = N.bool();
            break;
          case 7:
            ie.timeout = N.uint32();
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: De(b.collectionId) ? String(b.collectionId) : "",
        projectId: De(b.projectId) ? String(b.projectId) : "",
        metadata: De(b == null ? void 0 : b.metadata) ? b.metadata : void 0,
        address: De(b.address) ? a.DestinationAddress.fromJSON(b.address) : void 0,
        enabled: De(b.enabled) ? !!b.enabled : void 0,
        timeout: De(b.timeout) ? Number(b.timeout) : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.collectionId !== void 0 && (P.collectionId = b.collectionId), b.projectId !== void 0 && (P.projectId = b.projectId), b.metadata !== void 0 && (P.metadata = b.metadata), b.address !== void 0 && (P.address = b.address ? a.DestinationAddress.toJSON(b.address) : void 0), b.enabled !== void 0 && (P.enabled = b.enabled), b.timeout !== void 0 && (P.timeout = Math.round(b.timeout)), P;
    },
    fromPartial(b) {
      var P, N, Se, ie, ke;
      const gt = Qr();
      return gt.collectionId = (P = b.collectionId) !== null && P !== void 0 ? P : "", gt.projectId = (N = b.projectId) !== null && N !== void 0 ? N : "", gt.metadata = (Se = b.metadata) !== null && Se !== void 0 ? Se : void 0, gt.address = b.address !== void 0 && b.address !== null ? a.DestinationAddress.fromPartial(b.address) : void 0, gt.enabled = (ie = b.enabled) !== null && ie !== void 0 ? ie : void 0, gt.timeout = (ke = b.timeout) !== null && ke !== void 0 ? ke : void 0, gt;
    }
  };
  function en() {
    return { destination: void 0 };
  }
  a.CreateDestinationResponse = {
    encode(b, P = c.default.Writer.create()) {
      return b.destination !== void 0 && a.Destination.encode(b.destination, P.uint32(10).fork()).ldelim(), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = en();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.destination = a.Destination.decode(N, N.uint32());
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { destination: De(b.destination) ? a.Destination.fromJSON(b.destination) : void 0 };
    },
    toJSON(b) {
      const P = {};
      return b.destination !== void 0 && (P.destination = b.destination ? a.Destination.toJSON(b.destination) : void 0), P;
    },
    fromPartial(b) {
      const P = en();
      return P.destination = b.destination !== void 0 && b.destination !== null ? a.Destination.fromPartial(b.destination) : void 0, P;
    }
  };
  function tn() {
    return { collectionId: "", projectId: "", destinationId: "" };
  }
  a.GetDestinationRequest = {
    encode(b, P = c.default.Writer.create()) {
      return b.collectionId !== "" && P.uint32(10).string(b.collectionId), b.projectId !== "" && P.uint32(18).string(b.projectId), b.destinationId !== "" && P.uint32(26).string(b.destinationId), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = tn();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.projectId = N.string();
            break;
          case 3:
            ie.destinationId = N.string();
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: De(b.collectionId) ? String(b.collectionId) : "",
        projectId: De(b.projectId) ? String(b.projectId) : "",
        destinationId: De(b.destinationId) ? String(b.destinationId) : ""
      };
    },
    toJSON(b) {
      const P = {};
      return b.collectionId !== void 0 && (P.collectionId = b.collectionId), b.projectId !== void 0 && (P.projectId = b.projectId), b.destinationId !== void 0 && (P.destinationId = b.destinationId), P;
    },
    fromPartial(b) {
      var P, N, Se;
      const ie = tn();
      return ie.collectionId = (P = b.collectionId) !== null && P !== void 0 ? P : "", ie.projectId = (N = b.projectId) !== null && N !== void 0 ? N : "", ie.destinationId = (Se = b.destinationId) !== null && Se !== void 0 ? Se : "", ie;
    }
  };
  function rn() {
    return { destination: void 0 };
  }
  a.GetDestinationResponse = {
    encode(b, P = c.default.Writer.create()) {
      return b.destination !== void 0 && a.Destination.encode(b.destination, P.uint32(10).fork()).ldelim(), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = rn();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.destination = a.Destination.decode(N, N.uint32());
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { destination: De(b.destination) ? a.Destination.fromJSON(b.destination) : void 0 };
    },
    toJSON(b) {
      const P = {};
      return b.destination !== void 0 && (P.destination = b.destination ? a.Destination.toJSON(b.destination) : void 0), P;
    },
    fromPartial(b) {
      const P = rn();
      return P.destination = b.destination !== void 0 && b.destination !== null ? a.Destination.fromPartial(b.destination) : void 0, P;
    }
  };
  function nn() {
    return { collectionId: "", projectId: "", destinationId: "", force: void 0 };
  }
  a.DeleteDestinationRequest = {
    encode(b, P = c.default.Writer.create()) {
      return b.collectionId !== "" && P.uint32(10).string(b.collectionId), b.projectId !== "" && P.uint32(18).string(b.projectId), b.destinationId !== "" && P.uint32(26).string(b.destinationId), b.force !== void 0 && P.uint32(32).bool(b.force), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = nn();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.projectId = N.string();
            break;
          case 3:
            ie.destinationId = N.string();
            break;
          case 4:
            ie.force = N.bool();
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: De(b.collectionId) ? String(b.collectionId) : "",
        projectId: De(b.projectId) ? String(b.projectId) : "",
        destinationId: De(b.destinationId) ? String(b.destinationId) : "",
        force: De(b.force) ? !!b.force : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.collectionId !== void 0 && (P.collectionId = b.collectionId), b.projectId !== void 0 && (P.projectId = b.projectId), b.destinationId !== void 0 && (P.destinationId = b.destinationId), b.force !== void 0 && (P.force = b.force), P;
    },
    fromPartial(b) {
      var P, N, Se, ie;
      const ke = nn();
      return ke.collectionId = (P = b.collectionId) !== null && P !== void 0 ? P : "", ke.projectId = (N = b.projectId) !== null && N !== void 0 ? N : "", ke.destinationId = (Se = b.destinationId) !== null && Se !== void 0 ? Se : "", ke.force = (ie = b.force) !== null && ie !== void 0 ? ie : void 0, ke;
    }
  };
  function an() {
    return { broadcastUpdated: !1 };
  }
  a.DeleteDestinationResponse = {
    encode(b, P = c.default.Writer.create()) {
      return b.broadcastUpdated === !0 && P.uint32(8).bool(b.broadcastUpdated), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = an();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.broadcastUpdated = N.bool();
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { broadcastUpdated: De(b.broadcastUpdated) ? !!b.broadcastUpdated : !1 };
    },
    toJSON(b) {
      const P = {};
      return b.broadcastUpdated !== void 0 && (P.broadcastUpdated = b.broadcastUpdated), P;
    },
    fromPartial(b) {
      var P;
      const N = an();
      return N.broadcastUpdated = (P = b.broadcastUpdated) !== null && P !== void 0 ? P : !1, N;
    }
  };
  function sn() {
    return {
      collectionId: "",
      projectId: "",
      destinationId: "",
      updateMask: void 0,
      metadata: void 0,
      address: void 0,
      enabled: void 0,
      timeout: void 0
    };
  }
  a.UpdateDestinationRequest = {
    encode(b, P = c.default.Writer.create()) {
      return b.collectionId !== "" && P.uint32(10).string(b.collectionId), b.projectId !== "" && P.uint32(18).string(b.projectId), b.destinationId !== "" && P.uint32(26).string(b.destinationId), b.updateMask !== void 0 && v.FieldMask.encode(v.FieldMask.wrap(b.updateMask), P.uint32(34).fork()).ldelim(), b.metadata !== void 0 && p.Value.encode(p.Value.wrap(b.metadata), P.uint32(42).fork()).ldelim(), b.address !== void 0 && a.DestinationAddress.encode(b.address, P.uint32(50).fork()).ldelim(), b.enabled !== void 0 && P.uint32(56).bool(b.enabled), b.timeout !== void 0 && P.uint32(64).uint32(b.timeout), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = sn();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.projectId = N.string();
            break;
          case 3:
            ie.destinationId = N.string();
            break;
          case 4:
            ie.updateMask = v.FieldMask.unwrap(v.FieldMask.decode(N, N.uint32()));
            break;
          case 5:
            ie.metadata = p.Value.unwrap(p.Value.decode(N, N.uint32()));
            break;
          case 6:
            ie.address = a.DestinationAddress.decode(N, N.uint32());
            break;
          case 7:
            ie.enabled = N.bool();
            break;
          case 8:
            ie.timeout = N.uint32();
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: De(b.collectionId) ? String(b.collectionId) : "",
        projectId: De(b.projectId) ? String(b.projectId) : "",
        destinationId: De(b.destinationId) ? String(b.destinationId) : "",
        updateMask: De(b.updateMask) ? v.FieldMask.unwrap(v.FieldMask.fromJSON(b.updateMask)) : void 0,
        metadata: De(b == null ? void 0 : b.metadata) ? b.metadata : void 0,
        address: De(b.address) ? a.DestinationAddress.fromJSON(b.address) : void 0,
        enabled: De(b.enabled) ? !!b.enabled : void 0,
        timeout: De(b.timeout) ? Number(b.timeout) : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.collectionId !== void 0 && (P.collectionId = b.collectionId), b.projectId !== void 0 && (P.projectId = b.projectId), b.destinationId !== void 0 && (P.destinationId = b.destinationId), b.updateMask !== void 0 && (P.updateMask = v.FieldMask.toJSON(v.FieldMask.wrap(b.updateMask))), b.metadata !== void 0 && (P.metadata = b.metadata), b.address !== void 0 && (P.address = b.address ? a.DestinationAddress.toJSON(b.address) : void 0), b.enabled !== void 0 && (P.enabled = b.enabled), b.timeout !== void 0 && (P.timeout = Math.round(b.timeout)), P;
    },
    fromPartial(b) {
      var P, N, Se, ie, ke, gt, Ct;
      const Dt = sn();
      return Dt.collectionId = (P = b.collectionId) !== null && P !== void 0 ? P : "", Dt.projectId = (N = b.projectId) !== null && N !== void 0 ? N : "", Dt.destinationId = (Se = b.destinationId) !== null && Se !== void 0 ? Se : "", Dt.updateMask = (ie = b.updateMask) !== null && ie !== void 0 ? ie : void 0, Dt.metadata = (ke = b.metadata) !== null && ke !== void 0 ? ke : void 0, Dt.address = b.address !== void 0 && b.address !== null ? a.DestinationAddress.fromPartial(b.address) : void 0, Dt.enabled = (gt = b.enabled) !== null && gt !== void 0 ? gt : void 0, Dt.timeout = (Ct = b.timeout) !== null && Ct !== void 0 ? Ct : void 0, Dt;
    }
  };
  function dn() {
    return { destination: void 0, broadcastUpdated: !1 };
  }
  a.UpdateDestinationResponse = {
    encode(b, P = c.default.Writer.create()) {
      return b.destination !== void 0 && a.Destination.encode(b.destination, P.uint32(10).fork()).ldelim(), b.broadcastUpdated === !0 && P.uint32(16).bool(b.broadcastUpdated), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = dn();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.destination = a.Destination.decode(N, N.uint32());
            break;
          case 2:
            ie.broadcastUpdated = N.bool();
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        destination: De(b.destination) ? a.Destination.fromJSON(b.destination) : void 0,
        broadcastUpdated: De(b.broadcastUpdated) ? !!b.broadcastUpdated : !1
      };
    },
    toJSON(b) {
      const P = {};
      return b.destination !== void 0 && (P.destination = b.destination ? a.Destination.toJSON(b.destination) : void 0), b.broadcastUpdated !== void 0 && (P.broadcastUpdated = b.broadcastUpdated), P;
    },
    fromPartial(b) {
      var P;
      const N = dn();
      return N.destination = b.destination !== void 0 && b.destination !== null ? a.Destination.fromPartial(b.destination) : void 0, N.broadcastUpdated = (P = b.broadcastUpdated) !== null && P !== void 0 ? P : !1, N;
    }
  };
  function un() {
    return { collectionId: "", metadata: void 0, address: void 0, preview: void 0 };
  }
  a.CreateSourceRequest = {
    encode(b, P = c.default.Writer.create()) {
      return b.collectionId !== "" && P.uint32(10).string(b.collectionId), b.metadata !== void 0 && p.Value.encode(p.Value.wrap(b.metadata), P.uint32(18).fork()).ldelim(), b.address !== void 0 && a.SourceAddress.encode(b.address, P.uint32(26).fork()).ldelim(), b.preview !== void 0 && a.PreviewAddress.encode(b.preview, P.uint32(34).fork()).ldelim(), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = un();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.metadata = p.Value.unwrap(p.Value.decode(N, N.uint32()));
            break;
          case 3:
            ie.address = a.SourceAddress.decode(N, N.uint32());
            break;
          case 4:
            ie.preview = a.PreviewAddress.decode(N, N.uint32());
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: De(b.collectionId) ? String(b.collectionId) : "",
        metadata: De(b == null ? void 0 : b.metadata) ? b.metadata : void 0,
        address: De(b.address) ? a.SourceAddress.fromJSON(b.address) : void 0,
        preview: De(b.preview) ? a.PreviewAddress.fromJSON(b.preview) : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.collectionId !== void 0 && (P.collectionId = b.collectionId), b.metadata !== void 0 && (P.metadata = b.metadata), b.address !== void 0 && (P.address = b.address ? a.SourceAddress.toJSON(b.address) : void 0), b.preview !== void 0 && (P.preview = b.preview ? a.PreviewAddress.toJSON(b.preview) : void 0), P;
    },
    fromPartial(b) {
      var P, N;
      const Se = un();
      return Se.collectionId = (P = b.collectionId) !== null && P !== void 0 ? P : "", Se.metadata = (N = b.metadata) !== null && N !== void 0 ? N : void 0, Se.address = b.address !== void 0 && b.address !== null ? a.SourceAddress.fromPartial(b.address) : void 0, Se.preview = b.preview !== void 0 && b.preview !== null ? a.PreviewAddress.fromPartial(b.preview) : void 0, Se;
    }
  };
  function cn() {
    return { source: void 0 };
  }
  a.CreateSourceResponse = {
    encode(b, P = c.default.Writer.create()) {
      return b.source !== void 0 && a.Source.encode(b.source, P.uint32(10).fork()).ldelim(), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = cn();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.source = a.Source.decode(N, N.uint32());
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { source: De(b.source) ? a.Source.fromJSON(b.source) : void 0 };
    },
    toJSON(b) {
      const P = {};
      return b.source !== void 0 && (P.source = b.source ? a.Source.toJSON(b.source) : void 0), P;
    },
    fromPartial(b) {
      const P = cn();
      return P.source = b.source !== void 0 && b.source !== null ? a.Source.fromPartial(b.source) : void 0, P;
    }
  };
  function ln() {
    return { collectionId: "", sourceId: "", force: void 0 };
  }
  a.DeleteSourceRequest = {
    encode(b, P = c.default.Writer.create()) {
      return b.collectionId !== "" && P.uint32(10).string(b.collectionId), b.sourceId !== "" && P.uint32(18).string(b.sourceId), b.force !== void 0 && P.uint32(24).bool(b.force), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = ln();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.sourceId = N.string();
            break;
          case 3:
            ie.force = N.bool();
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: De(b.collectionId) ? String(b.collectionId) : "",
        sourceId: De(b.sourceId) ? String(b.sourceId) : "",
        force: De(b.force) ? !!b.force : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.collectionId !== void 0 && (P.collectionId = b.collectionId), b.sourceId !== void 0 && (P.sourceId = b.sourceId), b.force !== void 0 && (P.force = b.force), P;
    },
    fromPartial(b) {
      var P, N, Se;
      const ie = ln();
      return ie.collectionId = (P = b.collectionId) !== null && P !== void 0 ? P : "", ie.sourceId = (N = b.sourceId) !== null && N !== void 0 ? N : "", ie.force = (Se = b.force) !== null && Se !== void 0 ? Se : void 0, ie;
    }
  };
  function fn() {
    return { projectIdsUpdated: [] };
  }
  a.DeleteSourceResponse = {
    encode(b, P = c.default.Writer.create()) {
      for (const N of b.projectIdsUpdated)
        P.uint32(26).string(N);
      return P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = fn();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 3:
            ie.projectIdsUpdated.push(N.string());
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        projectIdsUpdated: Array.isArray(b == null ? void 0 : b.projectIdsUpdated) ? b.projectIdsUpdated.map((P) => String(P)) : []
      };
    },
    toJSON(b) {
      const P = {};
      return b.projectIdsUpdated ? P.projectIdsUpdated = b.projectIdsUpdated.map((N) => N) : P.projectIdsUpdated = [], P;
    },
    fromPartial(b) {
      var P;
      const N = fn();
      return N.projectIdsUpdated = ((P = b.projectIdsUpdated) === null || P === void 0 ? void 0 : P.map((Se) => Se)) || [], N;
    }
  };
  function hn() {
    return { collectionId: "", projectId: "", sourceId: "", trigger: void 0 };
  }
  a.AddSourceToProjectRequest = {
    encode(b, P = c.default.Writer.create()) {
      return b.collectionId !== "" && P.uint32(10).string(b.collectionId), b.projectId !== "" && P.uint32(18).string(b.projectId), b.sourceId !== "" && P.uint32(26).string(b.sourceId), b.trigger !== void 0 && a.SourceTrigger.encode(b.trigger, P.uint32(34).fork()).ldelim(), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = hn();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.projectId = N.string();
            break;
          case 3:
            ie.sourceId = N.string();
            break;
          case 4:
            ie.trigger = a.SourceTrigger.decode(N, N.uint32());
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: De(b.collectionId) ? String(b.collectionId) : "",
        projectId: De(b.projectId) ? String(b.projectId) : "",
        sourceId: De(b.sourceId) ? String(b.sourceId) : "",
        trigger: De(b.trigger) ? a.SourceTrigger.fromJSON(b.trigger) : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.collectionId !== void 0 && (P.collectionId = b.collectionId), b.projectId !== void 0 && (P.projectId = b.projectId), b.sourceId !== void 0 && (P.sourceId = b.sourceId), b.trigger !== void 0 && (P.trigger = b.trigger ? a.SourceTrigger.toJSON(b.trigger) : void 0), P;
    },
    fromPartial(b) {
      var P, N, Se;
      const ie = hn();
      return ie.collectionId = (P = b.collectionId) !== null && P !== void 0 ? P : "", ie.projectId = (N = b.projectId) !== null && N !== void 0 ? N : "", ie.sourceId = (Se = b.sourceId) !== null && Se !== void 0 ? Se : "", ie.trigger = b.trigger !== void 0 && b.trigger !== null ? a.SourceTrigger.fromPartial(b.trigger) : void 0, ie;
    }
  };
  function pn() {
    return { project: void 0, broadcastUpdated: !1 };
  }
  a.AddSourceToProjectResponse = {
    encode(b, P = c.default.Writer.create()) {
      return b.project !== void 0 && a.Project.encode(b.project, P.uint32(10).fork()).ldelim(), b.broadcastUpdated === !0 && P.uint32(16).bool(b.broadcastUpdated), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = pn();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.project = a.Project.decode(N, N.uint32());
            break;
          case 2:
            ie.broadcastUpdated = N.bool();
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        project: De(b.project) ? a.Project.fromJSON(b.project) : void 0,
        broadcastUpdated: De(b.broadcastUpdated) ? !!b.broadcastUpdated : !1
      };
    },
    toJSON(b) {
      const P = {};
      return b.project !== void 0 && (P.project = b.project ? a.Project.toJSON(b.project) : void 0), b.broadcastUpdated !== void 0 && (P.broadcastUpdated = b.broadcastUpdated), P;
    },
    fromPartial(b) {
      var P;
      const N = pn();
      return N.project = b.project !== void 0 && b.project !== null ? a.Project.fromPartial(b.project) : void 0, N.broadcastUpdated = (P = b.broadcastUpdated) !== null && P !== void 0 ? P : !1, N;
    }
  };
  function mn() {
    return { collectionId: "", projectId: "", sourceId: "", updateMask: void 0, trigger: void 0 };
  }
  a.UpdateSourceInProjectRequest = {
    encode(b, P = c.default.Writer.create()) {
      return b.collectionId !== "" && P.uint32(10).string(b.collectionId), b.projectId !== "" && P.uint32(18).string(b.projectId), b.sourceId !== "" && P.uint32(26).string(b.sourceId), b.updateMask !== void 0 && v.FieldMask.encode(v.FieldMask.wrap(b.updateMask), P.uint32(34).fork()).ldelim(), b.trigger !== void 0 && a.SourceTrigger.encode(b.trigger, P.uint32(42).fork()).ldelim(), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = mn();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.projectId = N.string();
            break;
          case 3:
            ie.sourceId = N.string();
            break;
          case 4:
            ie.updateMask = v.FieldMask.unwrap(v.FieldMask.decode(N, N.uint32()));
            break;
          case 5:
            ie.trigger = a.SourceTrigger.decode(N, N.uint32());
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: De(b.collectionId) ? String(b.collectionId) : "",
        projectId: De(b.projectId) ? String(b.projectId) : "",
        sourceId: De(b.sourceId) ? String(b.sourceId) : "",
        updateMask: De(b.updateMask) ? v.FieldMask.unwrap(v.FieldMask.fromJSON(b.updateMask)) : void 0,
        trigger: De(b.trigger) ? a.SourceTrigger.fromJSON(b.trigger) : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.collectionId !== void 0 && (P.collectionId = b.collectionId), b.projectId !== void 0 && (P.projectId = b.projectId), b.sourceId !== void 0 && (P.sourceId = b.sourceId), b.updateMask !== void 0 && (P.updateMask = v.FieldMask.toJSON(v.FieldMask.wrap(b.updateMask))), b.trigger !== void 0 && (P.trigger = b.trigger ? a.SourceTrigger.toJSON(b.trigger) : void 0), P;
    },
    fromPartial(b) {
      var P, N, Se, ie;
      const ke = mn();
      return ke.collectionId = (P = b.collectionId) !== null && P !== void 0 ? P : "", ke.projectId = (N = b.projectId) !== null && N !== void 0 ? N : "", ke.sourceId = (Se = b.sourceId) !== null && Se !== void 0 ? Se : "", ke.updateMask = (ie = b.updateMask) !== null && ie !== void 0 ? ie : void 0, ke.trigger = b.trigger !== void 0 && b.trigger !== null ? a.SourceTrigger.fromPartial(b.trigger) : void 0, ke;
    }
  };
  function vn() {
    return { project: void 0 };
  }
  a.UpdateSourceInProjectResponse = {
    encode(b, P = c.default.Writer.create()) {
      return b.project !== void 0 && a.Project.encode(b.project, P.uint32(10).fork()).ldelim(), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = vn();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.project = a.Project.decode(N, N.uint32());
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { project: De(b.project) ? a.Project.fromJSON(b.project) : void 0 };
    },
    toJSON(b) {
      const P = {};
      return b.project !== void 0 && (P.project = b.project ? a.Project.toJSON(b.project) : void 0), P;
    },
    fromPartial(b) {
      const P = vn();
      return P.project = b.project !== void 0 && b.project !== null ? a.Project.fromPartial(b.project) : void 0, P;
    }
  };
  function yn() {
    return { collectionId: "", sourceId: "" };
  }
  a.GetSourceRequest = {
    encode(b, P = c.default.Writer.create()) {
      return b.collectionId !== "" && P.uint32(10).string(b.collectionId), b.sourceId !== "" && P.uint32(26).string(b.sourceId), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = yn();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 3:
            ie.sourceId = N.string();
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: De(b.collectionId) ? String(b.collectionId) : "",
        sourceId: De(b.sourceId) ? String(b.sourceId) : ""
      };
    },
    toJSON(b) {
      const P = {};
      return b.collectionId !== void 0 && (P.collectionId = b.collectionId), b.sourceId !== void 0 && (P.sourceId = b.sourceId), P;
    },
    fromPartial(b) {
      var P, N;
      const Se = yn();
      return Se.collectionId = (P = b.collectionId) !== null && P !== void 0 ? P : "", Se.sourceId = (N = b.sourceId) !== null && N !== void 0 ? N : "", Se;
    }
  };
  function gn() {
    return { source: void 0 };
  }
  a.GetSourceResponse = {
    encode(b, P = c.default.Writer.create()) {
      return b.source !== void 0 && a.Source.encode(b.source, P.uint32(10).fork()).ldelim(), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = gn();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.source = a.Source.decode(N, N.uint32());
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { source: De(b.source) ? a.Source.fromJSON(b.source) : void 0 };
    },
    toJSON(b) {
      const P = {};
      return b.source !== void 0 && (P.source = b.source ? a.Source.toJSON(b.source) : void 0), P;
    },
    fromPartial(b) {
      const P = gn();
      return P.source = b.source !== void 0 && b.source !== null ? a.Source.fromPartial(b.source) : void 0, P;
    }
  };
  function Sn() {
    return { collectionId: "" };
  }
  a.GetSourcesRequest = {
    encode(b, P = c.default.Writer.create()) {
      return b.collectionId !== "" && P.uint32(10).string(b.collectionId), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = Sn();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { collectionId: De(b.collectionId) ? String(b.collectionId) : "" };
    },
    toJSON(b) {
      const P = {};
      return b.collectionId !== void 0 && (P.collectionId = b.collectionId), P;
    },
    fromPartial(b) {
      var P;
      const N = Sn();
      return N.collectionId = (P = b.collectionId) !== null && P !== void 0 ? P : "", N;
    }
  };
  function _n() {
    return { sources: [] };
  }
  a.GetSourcesResponse = {
    encode(b, P = c.default.Writer.create()) {
      for (const N of b.sources)
        a.Source.encode(N, P.uint32(10).fork()).ldelim();
      return P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = _n();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.sources.push(a.Source.decode(N, N.uint32()));
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { sources: Array.isArray(b == null ? void 0 : b.sources) ? b.sources.map((P) => a.Source.fromJSON(P)) : [] };
    },
    toJSON(b) {
      const P = {};
      return b.sources ? P.sources = b.sources.map((N) => N ? a.Source.toJSON(N) : void 0) : P.sources = [], P;
    },
    fromPartial(b) {
      var P;
      const N = _n();
      return N.sources = ((P = b.sources) === null || P === void 0 ? void 0 : P.map((Se) => a.Source.fromPartial(Se))) || [], N;
    }
  };
  function En() {
    return {
      collectionId: "",
      sourceId: "",
      updateMask: void 0,
      metadata: void 0,
      address: void 0,
      preview: void 0
    };
  }
  a.UpdateSourceRequest = {
    encode(b, P = c.default.Writer.create()) {
      return b.collectionId !== "" && P.uint32(10).string(b.collectionId), b.sourceId !== "" && P.uint32(26).string(b.sourceId), b.updateMask !== void 0 && v.FieldMask.encode(v.FieldMask.wrap(b.updateMask), P.uint32(34).fork()).ldelim(), b.metadata !== void 0 && p.Value.encode(p.Value.wrap(b.metadata), P.uint32(42).fork()).ldelim(), b.address !== void 0 && a.SourceAddress.encode(b.address, P.uint32(50).fork()).ldelim(), b.preview !== void 0 && a.PreviewAddress.encode(b.preview, P.uint32(58).fork()).ldelim(), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = En();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 3:
            ie.sourceId = N.string();
            break;
          case 4:
            ie.updateMask = v.FieldMask.unwrap(v.FieldMask.decode(N, N.uint32()));
            break;
          case 5:
            ie.metadata = p.Value.unwrap(p.Value.decode(N, N.uint32()));
            break;
          case 6:
            ie.address = a.SourceAddress.decode(N, N.uint32());
            break;
          case 7:
            ie.preview = a.PreviewAddress.decode(N, N.uint32());
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: De(b.collectionId) ? String(b.collectionId) : "",
        sourceId: De(b.sourceId) ? String(b.sourceId) : "",
        updateMask: De(b.updateMask) ? v.FieldMask.unwrap(v.FieldMask.fromJSON(b.updateMask)) : void 0,
        metadata: De(b == null ? void 0 : b.metadata) ? b.metadata : void 0,
        address: De(b.address) ? a.SourceAddress.fromJSON(b.address) : void 0,
        preview: De(b.preview) ? a.PreviewAddress.fromJSON(b.preview) : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.collectionId !== void 0 && (P.collectionId = b.collectionId), b.sourceId !== void 0 && (P.sourceId = b.sourceId), b.updateMask !== void 0 && (P.updateMask = v.FieldMask.toJSON(v.FieldMask.wrap(b.updateMask))), b.metadata !== void 0 && (P.metadata = b.metadata), b.address !== void 0 && (P.address = b.address ? a.SourceAddress.toJSON(b.address) : void 0), b.preview !== void 0 && (P.preview = b.preview ? a.PreviewAddress.toJSON(b.preview) : void 0), P;
    },
    fromPartial(b) {
      var P, N, Se, ie;
      const ke = En();
      return ke.collectionId = (P = b.collectionId) !== null && P !== void 0 ? P : "", ke.sourceId = (N = b.sourceId) !== null && N !== void 0 ? N : "", ke.updateMask = (Se = b.updateMask) !== null && Se !== void 0 ? Se : void 0, ke.metadata = (ie = b.metadata) !== null && ie !== void 0 ? ie : void 0, ke.address = b.address !== void 0 && b.address !== null ? a.SourceAddress.fromPartial(b.address) : void 0, ke.preview = b.preview !== void 0 && b.preview !== null ? a.PreviewAddress.fromPartial(b.preview) : void 0, ke;
    }
  };
  function Tn() {
    return { source: void 0, broadcastUpdated: !1 };
  }
  a.UpdateSourceResponse = {
    encode(b, P = c.default.Writer.create()) {
      return b.source !== void 0 && a.Source.encode(b.source, P.uint32(10).fork()).ldelim(), b.broadcastUpdated === !0 && P.uint32(16).bool(b.broadcastUpdated), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = Tn();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.source = a.Source.decode(N, N.uint32());
            break;
          case 2:
            ie.broadcastUpdated = N.bool();
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        source: De(b.source) ? a.Source.fromJSON(b.source) : void 0,
        broadcastUpdated: De(b.broadcastUpdated) ? !!b.broadcastUpdated : !1
      };
    },
    toJSON(b) {
      const P = {};
      return b.source !== void 0 && (P.source = b.source ? a.Source.toJSON(b.source) : void 0), b.broadcastUpdated !== void 0 && (P.broadcastUpdated = b.broadcastUpdated), P;
    },
    fromPartial(b) {
      var P;
      const N = Tn();
      return N.source = b.source !== void 0 && b.source !== null ? a.Source.fromPartial(b.source) : void 0, N.broadcastUpdated = (P = b.broadcastUpdated) !== null && P !== void 0 ? P : !1, N;
    }
  };
  function wn() {
    return { collectionId: "", projectId: "", sourceId: "", force: void 0 };
  }
  a.RemoveSourceFromProjectRequest = {
    encode(b, P = c.default.Writer.create()) {
      return b.collectionId !== "" && P.uint32(10).string(b.collectionId), b.projectId !== "" && P.uint32(18).string(b.projectId), b.sourceId !== "" && P.uint32(26).string(b.sourceId), b.force !== void 0 && P.uint32(32).bool(b.force), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = wn();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.projectId = N.string();
            break;
          case 3:
            ie.sourceId = N.string();
            break;
          case 4:
            ie.force = N.bool();
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: De(b.collectionId) ? String(b.collectionId) : "",
        projectId: De(b.projectId) ? String(b.projectId) : "",
        sourceId: De(b.sourceId) ? String(b.sourceId) : "",
        force: De(b.force) ? !!b.force : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.collectionId !== void 0 && (P.collectionId = b.collectionId), b.projectId !== void 0 && (P.projectId = b.projectId), b.sourceId !== void 0 && (P.sourceId = b.sourceId), b.force !== void 0 && (P.force = b.force), P;
    },
    fromPartial(b) {
      var P, N, Se, ie;
      const ke = wn();
      return ke.collectionId = (P = b.collectionId) !== null && P !== void 0 ? P : "", ke.projectId = (N = b.projectId) !== null && N !== void 0 ? N : "", ke.sourceId = (Se = b.sourceId) !== null && Se !== void 0 ? Se : "", ke.force = (ie = b.force) !== null && ie !== void 0 ? ie : void 0, ke;
    }
  };
  function kn() {
    return { project: void 0, broadcastUpdated: !1 };
  }
  a.RemoveSourceFromProjectResponse = {
    encode(b, P = c.default.Writer.create()) {
      return b.project !== void 0 && a.Project.encode(b.project, P.uint32(10).fork()).ldelim(), b.broadcastUpdated === !0 && P.uint32(16).bool(b.broadcastUpdated), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = kn();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.project = a.Project.decode(N, N.uint32());
            break;
          case 2:
            ie.broadcastUpdated = N.bool();
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        project: De(b.project) ? a.Project.fromJSON(b.project) : void 0,
        broadcastUpdated: De(b.broadcastUpdated) ? !!b.broadcastUpdated : !1
      };
    },
    toJSON(b) {
      const P = {};
      return b.project !== void 0 && (P.project = b.project ? a.Project.toJSON(b.project) : void 0), b.broadcastUpdated !== void 0 && (P.broadcastUpdated = b.broadcastUpdated), P;
    },
    fromPartial(b) {
      var P;
      const N = kn();
      return N.project = b.project !== void 0 && b.project !== null ? a.Project.fromPartial(b.project) : void 0, N.broadcastUpdated = (P = b.broadcastUpdated) !== null && P !== void 0 ? P : !1, N;
    }
  };
  function In() {
    return { collectionId: "", sourceId: "", accessToken: void 0 };
  }
  a.GetSourcePlaylistRequest = {
    encode(b, P = c.default.Writer.create()) {
      return b.collectionId !== "" && P.uint32(10).string(b.collectionId), b.sourceId !== "" && P.uint32(26).string(b.sourceId), b.accessToken !== void 0 && P.uint32(34).string(b.accessToken), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = In();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 3:
            ie.sourceId = N.string();
            break;
          case 4:
            ie.accessToken = N.string();
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: De(b.collectionId) ? String(b.collectionId) : "",
        sourceId: De(b.sourceId) ? String(b.sourceId) : "",
        accessToken: De(b.accessToken) ? String(b.accessToken) : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.collectionId !== void 0 && (P.collectionId = b.collectionId), b.sourceId !== void 0 && (P.sourceId = b.sourceId), b.accessToken !== void 0 && (P.accessToken = b.accessToken), P;
    },
    fromPartial(b) {
      var P, N, Se;
      const ie = In();
      return ie.collectionId = (P = b.collectionId) !== null && P !== void 0 ? P : "", ie.sourceId = (N = b.sourceId) !== null && N !== void 0 ? N : "", ie.accessToken = (Se = b.accessToken) !== null && Se !== void 0 ? Se : void 0, ie;
    }
  };
  function Rn() {
    return { manifest: "" };
  }
  a.GetSourcePlaylistResponse = {
    encode(b, P = c.default.Writer.create()) {
      return b.manifest !== "" && P.uint32(10).string(b.manifest), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = Rn();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.manifest = N.string();
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { manifest: De(b.manifest) ? String(b.manifest) : "" };
    },
    toJSON(b) {
      const P = {};
      return b.manifest !== void 0 && (P.manifest = b.manifest), P;
    },
    fromPartial(b) {
      var P;
      const N = Rn();
      return N.manifest = (P = b.manifest) !== null && P !== void 0 ? P : "", N;
    }
  };
  function Cn() {
    return { serviceUserId: "", displayName: void 0, role: void 0, maxDuration: void 0 };
  }
  a.CreateAccessTokenRequest = {
    encode(b, P = c.default.Writer.create()) {
      return b.serviceUserId !== "" && P.uint32(10).string(b.serviceUserId), b.displayName !== void 0 && P.uint32(34).string(b.displayName), b.role !== void 0 && P.uint32(16).int32(Be(b.role)), b.maxDuration !== void 0 && P.uint32(24).uint32(b.maxDuration), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = Cn();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.serviceUserId = N.string();
            break;
          case 4:
            ie.displayName = N.string();
            break;
          case 2:
            ie.role = me(N.int32());
            break;
          case 3:
            ie.maxDuration = N.uint32();
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        serviceUserId: De(b.serviceUserId) ? String(b.serviceUserId) : "",
        displayName: De(b.displayName) ? String(b.displayName) : void 0,
        role: De(b.role) ? me(b.role) : void 0,
        maxDuration: De(b.maxDuration) ? Number(b.maxDuration) : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.serviceUserId !== void 0 && (P.serviceUserId = b.serviceUserId), b.displayName !== void 0 && (P.displayName = b.displayName), b.role !== void 0 && (P.role = b.role !== void 0 ? Ce(b.role) : void 0), b.maxDuration !== void 0 && (P.maxDuration = Math.round(b.maxDuration)), P;
    },
    fromPartial(b) {
      var P, N, Se, ie;
      const ke = Cn();
      return ke.serviceUserId = (P = b.serviceUserId) !== null && P !== void 0 ? P : "", ke.displayName = (N = b.displayName) !== null && N !== void 0 ? N : void 0, ke.role = (Se = b.role) !== null && Se !== void 0 ? Se : void 0, ke.maxDuration = (ie = b.maxDuration) !== null && ie !== void 0 ? ie : void 0, ke;
    }
  };
  function Pn() {
    return { accessToken: "" };
  }
  a.CreateAccessTokenResponse = {
    encode(b, P = c.default.Writer.create()) {
      return b.accessToken !== "" && P.uint32(10).string(b.accessToken), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = Pn();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.accessToken = N.string();
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { accessToken: De(b.accessToken) ? String(b.accessToken) : "" };
    },
    toJSON(b) {
      const P = {};
      return b.accessToken !== void 0 && (P.accessToken = b.accessToken), P;
    },
    fromPartial(b) {
      var P;
      const N = Pn();
      return N.accessToken = (P = b.accessToken) !== null && P !== void 0 ? P : "", N;
    }
  };
  function On() {
    return { displayName: "", serviceUserId: void 0 };
  }
  a.GuestAccessTokenDirect = {
    encode(b, P = c.default.Writer.create()) {
      return b.displayName !== "" && P.uint32(10).string(b.displayName), b.serviceUserId !== void 0 && P.uint32(18).string(b.serviceUserId), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = On();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.displayName = N.string();
            break;
          case 2:
            ie.serviceUserId = N.string();
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        displayName: De(b.displayName) ? String(b.displayName) : "",
        serviceUserId: De(b.serviceUserId) ? String(b.serviceUserId) : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.displayName !== void 0 && (P.displayName = b.displayName), b.serviceUserId !== void 0 && (P.serviceUserId = b.serviceUserId), P;
    },
    fromPartial(b) {
      var P, N;
      const Se = On();
      return Se.displayName = (P = b.displayName) !== null && P !== void 0 ? P : "", Se.serviceUserId = (N = b.serviceUserId) !== null && N !== void 0 ? N : void 0, Se;
    }
  };
  function Mn() {
    return { maxDuration: void 0 };
  }
  a.GuestAccessTokenExchange = {
    encode(b, P = c.default.Writer.create()) {
      return b.maxDuration !== void 0 && P.uint32(8).uint32(b.maxDuration), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = Mn();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.maxDuration = N.uint32();
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { maxDuration: De(b.maxDuration) ? Number(b.maxDuration) : void 0 };
    },
    toJSON(b) {
      const P = {};
      return b.maxDuration !== void 0 && (P.maxDuration = Math.round(b.maxDuration)), P;
    },
    fromPartial(b) {
      var P;
      const N = Mn();
      return N.maxDuration = (P = b.maxDuration) !== null && P !== void 0 ? P : void 0, N;
    }
  };
  function An() {
    return { direct: void 0, exchange: void 0 };
  }
  a.GuestAccessToken = {
    encode(b, P = c.default.Writer.create()) {
      return b.direct !== void 0 && a.GuestAccessTokenDirect.encode(b.direct, P.uint32(10).fork()).ldelim(), b.exchange !== void 0 && a.GuestAccessTokenExchange.encode(b.exchange, P.uint32(18).fork()).ldelim(), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = An();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.direct = a.GuestAccessTokenDirect.decode(N, N.uint32());
            break;
          case 2:
            ie.exchange = a.GuestAccessTokenExchange.decode(N, N.uint32());
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        direct: De(b.direct) ? a.GuestAccessTokenDirect.fromJSON(b.direct) : void 0,
        exchange: De(b.exchange) ? a.GuestAccessTokenExchange.fromJSON(b.exchange) : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.direct !== void 0 && (P.direct = b.direct ? a.GuestAccessTokenDirect.toJSON(b.direct) : void 0), b.exchange !== void 0 && (P.exchange = b.exchange ? a.GuestAccessTokenExchange.toJSON(b.exchange) : void 0), P;
    },
    fromPartial(b) {
      const P = An();
      return P.direct = b.direct !== void 0 && b.direct !== null ? a.GuestAccessTokenDirect.fromPartial(b.direct) : void 0, P.exchange = b.exchange !== void 0 && b.exchange !== null ? a.GuestAccessTokenExchange.fromPartial(b.exchange) : void 0, P;
    }
  };
  function Nn() {
    return {
      collectionId: "",
      projectId: "",
      maxDuration: void 0,
      role: ce.ROLE_UNSPECIFIED,
      token: void 0,
      url: void 0
    };
  }
  a.CreateGuestAccessTokenRequest = {
    encode(b, P = c.default.Writer.create()) {
      return b.collectionId !== "" && P.uint32(10).string(b.collectionId), b.projectId !== "" && P.uint32(18).string(b.projectId), b.maxDuration !== void 0 && P.uint32(24).uint32(b.maxDuration), b.role !== ce.ROLE_UNSPECIFIED && P.uint32(32).int32(Be(b.role)), b.token !== void 0 && a.GuestAccessToken.encode(b.token, P.uint32(42).fork()).ldelim(), b.url !== void 0 && P.uint32(50).string(b.url), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = Nn();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.projectId = N.string();
            break;
          case 3:
            ie.maxDuration = N.uint32();
            break;
          case 4:
            ie.role = me(N.int32());
            break;
          case 5:
            ie.token = a.GuestAccessToken.decode(N, N.uint32());
            break;
          case 6:
            ie.url = N.string();
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: De(b.collectionId) ? String(b.collectionId) : "",
        projectId: De(b.projectId) ? String(b.projectId) : "",
        maxDuration: De(b.maxDuration) ? Number(b.maxDuration) : void 0,
        role: De(b.role) ? me(b.role) : ce.ROLE_UNSPECIFIED,
        token: De(b.token) ? a.GuestAccessToken.fromJSON(b.token) : void 0,
        url: De(b.url) ? String(b.url) : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.collectionId !== void 0 && (P.collectionId = b.collectionId), b.projectId !== void 0 && (P.projectId = b.projectId), b.maxDuration !== void 0 && (P.maxDuration = Math.round(b.maxDuration)), b.role !== void 0 && (P.role = Ce(b.role)), b.token !== void 0 && (P.token = b.token ? a.GuestAccessToken.toJSON(b.token) : void 0), b.url !== void 0 && (P.url = b.url), P;
    },
    fromPartial(b) {
      var P, N, Se, ie, ke;
      const gt = Nn();
      return gt.collectionId = (P = b.collectionId) !== null && P !== void 0 ? P : "", gt.projectId = (N = b.projectId) !== null && N !== void 0 ? N : "", gt.maxDuration = (Se = b.maxDuration) !== null && Se !== void 0 ? Se : void 0, gt.role = (ie = b.role) !== null && ie !== void 0 ? ie : ce.ROLE_UNSPECIFIED, gt.token = b.token !== void 0 && b.token !== null ? a.GuestAccessToken.fromPartial(b.token) : void 0, gt.url = (ke = b.url) !== null && ke !== void 0 ? ke : void 0, gt;
    }
  };
  function $n() {
    return { accessToken: "", url: void 0 };
  }
  a.CreateGuestAccessTokenResponse = {
    encode(b, P = c.default.Writer.create()) {
      return b.accessToken !== "" && P.uint32(10).string(b.accessToken), b.url !== void 0 && P.uint32(18).string(b.url), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = $n();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.accessToken = N.string();
            break;
          case 2:
            ie.url = N.string();
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        accessToken: De(b.accessToken) ? String(b.accessToken) : "",
        url: De(b.url) ? String(b.url) : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.accessToken !== void 0 && (P.accessToken = b.accessToken), b.url !== void 0 && (P.url = b.url), P;
    },
    fromPartial(b) {
      var P, N;
      const Se = $n();
      return Se.accessToken = (P = b.accessToken) !== null && P !== void 0 ? P : "", Se.url = (N = b.url) !== null && N !== void 0 ? N : void 0, Se;
    }
  };
  function Dn() {
    return { collectionId: "", projectId: "", displayName: "" };
  }
  a.CreateWebRtcAccessTokenRequest = {
    encode(b, P = c.default.Writer.create()) {
      return b.collectionId !== "" && P.uint32(10).string(b.collectionId), b.projectId !== "" && P.uint32(18).string(b.projectId), b.displayName !== "" && P.uint32(26).string(b.displayName), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = Dn();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.projectId = N.string();
            break;
          case 3:
            ie.displayName = N.string();
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: De(b.collectionId) ? String(b.collectionId) : "",
        projectId: De(b.projectId) ? String(b.projectId) : "",
        displayName: De(b.displayName) ? String(b.displayName) : ""
      };
    },
    toJSON(b) {
      const P = {};
      return b.collectionId !== void 0 && (P.collectionId = b.collectionId), b.projectId !== void 0 && (P.projectId = b.projectId), b.displayName !== void 0 && (P.displayName = b.displayName), P;
    },
    fromPartial(b) {
      var P, N, Se;
      const ie = Dn();
      return ie.collectionId = (P = b.collectionId) !== null && P !== void 0 ? P : "", ie.projectId = (N = b.projectId) !== null && N !== void 0 ? N : "", ie.displayName = (Se = b.displayName) !== null && Se !== void 0 ? Se : "", ie;
    }
  };
  function Ln() {
    return { webrtcAccess: void 0 };
  }
  a.CreateWebRtcAccessTokenResponse = {
    encode(b, P = c.default.Writer.create()) {
      return b.webrtcAccess !== void 0 && a.WebRtcAccess.encode(b.webrtcAccess, P.uint32(18).fork()).ldelim(), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = Ln();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 2:
            ie.webrtcAccess = a.WebRtcAccess.decode(N, N.uint32());
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { webrtcAccess: De(b.webrtcAccess) ? a.WebRtcAccess.fromJSON(b.webrtcAccess) : void 0 };
    },
    toJSON(b) {
      const P = {};
      return b.webrtcAccess !== void 0 && (P.webrtcAccess = b.webrtcAccess ? a.WebRtcAccess.toJSON(b.webrtcAccess) : void 0), P;
    },
    fromPartial(b) {
      const P = Ln();
      return P.webrtcAccess = b.webrtcAccess !== void 0 && b.webrtcAccess !== null ? a.WebRtcAccess.fromPartial(b.webrtcAccess) : void 0, P;
    }
  };
  function Bn() {
    return {};
  }
  a.RefreshAccessTokenRequest = {
    encode(b, P = c.default.Writer.create()) {
      return P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = Bn();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {};
    },
    toJSON(b) {
      return {};
    },
    fromPartial(b) {
      return Bn();
    }
  };
  function Un() {
    return {};
  }
  a.RefreshAccessTokenResponse = {
    encode(b, P = c.default.Writer.create()) {
      return P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = Un();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {};
    },
    toJSON(b) {
      return {};
    },
    fromPartial(b) {
      return Un();
    }
  };
  function xn() {
    return { collectionId: "", projectId: "", code: "", url: "", autoDelete: void 0 };
  }
  a.GuestCode = {
    encode(b, P = c.default.Writer.create()) {
      return b.collectionId !== "" && P.uint32(10).string(b.collectionId), b.projectId !== "" && P.uint32(18).string(b.projectId), b.code !== "" && P.uint32(26).string(b.code), b.url !== "" && P.uint32(34).string(b.url), b.autoDelete !== void 0 && _.Timestamp.encode(Ht(b.autoDelete), P.uint32(42).fork()).ldelim(), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = xn();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.projectId = N.string();
            break;
          case 3:
            ie.code = N.string();
            break;
          case 4:
            ie.url = N.string();
            break;
          case 5:
            ie.autoDelete = zt(_.Timestamp.decode(N, N.uint32()));
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: De(b.collectionId) ? String(b.collectionId) : "",
        projectId: De(b.projectId) ? String(b.projectId) : "",
        code: De(b.code) ? String(b.code) : "",
        url: De(b.url) ? String(b.url) : "",
        autoDelete: De(b.autoDelete) ? String(b.autoDelete) : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.collectionId !== void 0 && (P.collectionId = b.collectionId), b.projectId !== void 0 && (P.projectId = b.projectId), b.code !== void 0 && (P.code = b.code), b.url !== void 0 && (P.url = b.url), b.autoDelete !== void 0 && (P.autoDelete = b.autoDelete), P;
    },
    fromPartial(b) {
      var P, N, Se, ie, ke;
      const gt = xn();
      return gt.collectionId = (P = b.collectionId) !== null && P !== void 0 ? P : "", gt.projectId = (N = b.projectId) !== null && N !== void 0 ? N : "", gt.code = (Se = b.code) !== null && Se !== void 0 ? Se : "", gt.url = (ie = b.url) !== null && ie !== void 0 ? ie : "", gt.autoDelete = (ke = b.autoDelete) !== null && ke !== void 0 ? ke : void 0, gt;
    }
  };
  function Fn() {
    return { serviceId: "", code: "" };
  }
  a.GuestCodeRedirectRequest = {
    encode(b, P = c.default.Writer.create()) {
      return b.serviceId !== "" && P.uint32(10).string(b.serviceId), b.code !== "" && P.uint32(18).string(b.code), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = Fn();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.serviceId = N.string();
            break;
          case 2:
            ie.code = N.string();
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        serviceId: De(b.serviceId) ? String(b.serviceId) : "",
        code: De(b.code) ? String(b.code) : ""
      };
    },
    toJSON(b) {
      const P = {};
      return b.serviceId !== void 0 && (P.serviceId = b.serviceId), b.code !== void 0 && (P.code = b.code), P;
    },
    fromPartial(b) {
      var P, N;
      const Se = Fn();
      return Se.serviceId = (P = b.serviceId) !== null && P !== void 0 ? P : "", Se.code = (N = b.code) !== null && N !== void 0 ? N : "", Se;
    }
  };
  function qn() {
    return {};
  }
  a.GuestCodeRedirectResponse = {
    encode(b, P = c.default.Writer.create()) {
      return P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = qn();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {};
    },
    toJSON(b) {
      return {};
    },
    fromPartial(b) {
      return qn();
    }
  };
  function Vn() {
    return { alg: "", kty: "", use: "", kid: "", e: "", n: "" };
  }
  a.JsonWebKey = {
    encode(b, P = c.default.Writer.create()) {
      return b.alg !== "" && P.uint32(10).string(b.alg), b.kty !== "" && P.uint32(18).string(b.kty), b.use !== "" && P.uint32(26).string(b.use), b.kid !== "" && P.uint32(34).string(b.kid), b.e !== "" && P.uint32(42).string(b.e), b.n !== "" && P.uint32(50).string(b.n), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = Vn();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.alg = N.string();
            break;
          case 2:
            ie.kty = N.string();
            break;
          case 3:
            ie.use = N.string();
            break;
          case 4:
            ie.kid = N.string();
            break;
          case 5:
            ie.e = N.string();
            break;
          case 6:
            ie.n = N.string();
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        alg: De(b.alg) ? String(b.alg) : "",
        kty: De(b.kty) ? String(b.kty) : "",
        use: De(b.use) ? String(b.use) : "",
        kid: De(b.kid) ? String(b.kid) : "",
        e: De(b.e) ? String(b.e) : "",
        n: De(b.n) ? String(b.n) : ""
      };
    },
    toJSON(b) {
      const P = {};
      return b.alg !== void 0 && (P.alg = b.alg), b.kty !== void 0 && (P.kty = b.kty), b.use !== void 0 && (P.use = b.use), b.kid !== void 0 && (P.kid = b.kid), b.e !== void 0 && (P.e = b.e), b.n !== void 0 && (P.n = b.n), P;
    },
    fromPartial(b) {
      var P, N, Se, ie, ke, gt;
      const Ct = Vn();
      return Ct.alg = (P = b.alg) !== null && P !== void 0 ? P : "", Ct.kty = (N = b.kty) !== null && N !== void 0 ? N : "", Ct.use = (Se = b.use) !== null && Se !== void 0 ? Se : "", Ct.kid = (ie = b.kid) !== null && ie !== void 0 ? ie : "", Ct.e = (ke = b.e) !== null && ke !== void 0 ? ke : "", Ct.n = (gt = b.n) !== null && gt !== void 0 ? gt : "", Ct;
    }
  };
  function Jn() {
    return {};
  }
  a.GetJsonWebKeySetRequest = {
    encode(b, P = c.default.Writer.create()) {
      return P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = Jn();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {};
    },
    toJSON(b) {
      return {};
    },
    fromPartial(b) {
      return Jn();
    }
  };
  function Gn() {
    return { keys: [] };
  }
  a.GetJsonWebKeySetResponse = {
    encode(b, P = c.default.Writer.create()) {
      for (const N of b.keys)
        a.JsonWebKey.encode(N, P.uint32(10).fork()).ldelim();
      return P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = Gn();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.keys.push(a.JsonWebKey.decode(N, N.uint32()));
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { keys: Array.isArray(b == null ? void 0 : b.keys) ? b.keys.map((P) => a.JsonWebKey.fromJSON(P)) : [] };
    },
    toJSON(b) {
      const P = {};
      return b.keys ? P.keys = b.keys.map((N) => N ? a.JsonWebKey.toJSON(N) : void 0) : P.keys = [], P;
    },
    fromPartial(b) {
      var P;
      const N = Gn();
      return N.keys = ((P = b.keys) === null || P === void 0 ? void 0 : P.map((Se) => a.JsonWebKey.fromPartial(Se))) || [], N;
    }
  };
  function Wn() {
    return {};
  }
  a.GetTestTokenRequest = {
    encode(b, P = c.default.Writer.create()) {
      return P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = Wn();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {};
    },
    toJSON(b) {
      return {};
    },
    fromPartial(b) {
      return Wn();
    }
  };
  function Hn() {
    return { accessToken: "" };
  }
  a.GetTestTokenResponse = {
    encode(b, P = c.default.Writer.create()) {
      return b.accessToken !== "" && P.uint32(10).string(b.accessToken), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = Hn();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.accessToken = N.string();
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { accessToken: De(b.accessToken) ? String(b.accessToken) : "" };
    },
    toJSON(b) {
      const P = {};
      return b.accessToken !== void 0 && (P.accessToken = b.accessToken), P;
    },
    fromPartial(b) {
      var P;
      const N = Hn();
      return N.accessToken = (P = b.accessToken) !== null && P !== void 0 ? P : "", N;
    }
  };
  function zn() {
    return { collectionId: "", projectId: "", destinationId: "", destination: void 0 };
  }
  a.DestinationCreateEvent = {
    encode(b, P = c.default.Writer.create()) {
      return b.collectionId !== "" && P.uint32(10).string(b.collectionId), b.projectId !== "" && P.uint32(18).string(b.projectId), b.destinationId !== "" && P.uint32(26).string(b.destinationId), b.destination !== void 0 && a.Destination.encode(b.destination, P.uint32(34).fork()).ldelim(), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = zn();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.projectId = N.string();
            break;
          case 3:
            ie.destinationId = N.string();
            break;
          case 4:
            ie.destination = a.Destination.decode(N, N.uint32());
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: De(b.collectionId) ? String(b.collectionId) : "",
        projectId: De(b.projectId) ? String(b.projectId) : "",
        destinationId: De(b.destinationId) ? String(b.destinationId) : "",
        destination: De(b.destination) ? a.Destination.fromJSON(b.destination) : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.collectionId !== void 0 && (P.collectionId = b.collectionId), b.projectId !== void 0 && (P.projectId = b.projectId), b.destinationId !== void 0 && (P.destinationId = b.destinationId), b.destination !== void 0 && (P.destination = b.destination ? a.Destination.toJSON(b.destination) : void 0), P;
    },
    fromPartial(b) {
      var P, N, Se;
      const ie = zn();
      return ie.collectionId = (P = b.collectionId) !== null && P !== void 0 ? P : "", ie.projectId = (N = b.projectId) !== null && N !== void 0 ? N : "", ie.destinationId = (Se = b.destinationId) !== null && Se !== void 0 ? Se : "", ie.destination = b.destination !== void 0 && b.destination !== null ? a.Destination.fromPartial(b.destination) : void 0, ie;
    }
  };
  function Kn() {
    return { collectionId: "", projectId: "", destinationId: "" };
  }
  a.DestinationDeleteEvent = {
    encode(b, P = c.default.Writer.create()) {
      return b.collectionId !== "" && P.uint32(10).string(b.collectionId), b.projectId !== "" && P.uint32(18).string(b.projectId), b.destinationId !== "" && P.uint32(26).string(b.destinationId), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = Kn();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.projectId = N.string();
            break;
          case 3:
            ie.destinationId = N.string();
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: De(b.collectionId) ? String(b.collectionId) : "",
        projectId: De(b.projectId) ? String(b.projectId) : "",
        destinationId: De(b.destinationId) ? String(b.destinationId) : ""
      };
    },
    toJSON(b) {
      const P = {};
      return b.collectionId !== void 0 && (P.collectionId = b.collectionId), b.projectId !== void 0 && (P.projectId = b.projectId), b.destinationId !== void 0 && (P.destinationId = b.destinationId), P;
    },
    fromPartial(b) {
      var P, N, Se;
      const ie = Kn();
      return ie.collectionId = (P = b.collectionId) !== null && P !== void 0 ? P : "", ie.projectId = (N = b.projectId) !== null && N !== void 0 ? N : "", ie.destinationId = (Se = b.destinationId) !== null && Se !== void 0 ? Se : "", ie;
    }
  };
  function Yn() {
    return { collectionId: "", projectId: "", destinationId: "", updateMask: [], destination: void 0 };
  }
  a.DestinationUpdateEvent = {
    encode(b, P = c.default.Writer.create()) {
      b.collectionId !== "" && P.uint32(10).string(b.collectionId), b.projectId !== "" && P.uint32(18).string(b.projectId), b.destinationId !== "" && P.uint32(26).string(b.destinationId);
      for (const N of b.updateMask)
        P.uint32(34).string(N);
      return b.destination !== void 0 && a.Destination.encode(b.destination, P.uint32(42).fork()).ldelim(), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = Yn();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.projectId = N.string();
            break;
          case 3:
            ie.destinationId = N.string();
            break;
          case 4:
            ie.updateMask.push(N.string());
            break;
          case 5:
            ie.destination = a.Destination.decode(N, N.uint32());
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: De(b.collectionId) ? String(b.collectionId) : "",
        projectId: De(b.projectId) ? String(b.projectId) : "",
        destinationId: De(b.destinationId) ? String(b.destinationId) : "",
        updateMask: Array.isArray(b == null ? void 0 : b.updateMask) ? b.updateMask.map((P) => String(P)) : [],
        destination: De(b.destination) ? a.Destination.fromJSON(b.destination) : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.collectionId !== void 0 && (P.collectionId = b.collectionId), b.projectId !== void 0 && (P.projectId = b.projectId), b.destinationId !== void 0 && (P.destinationId = b.destinationId), b.updateMask ? P.updateMask = b.updateMask.map((N) => N) : P.updateMask = [], b.destination !== void 0 && (P.destination = b.destination ? a.Destination.toJSON(b.destination) : void 0), P;
    },
    fromPartial(b) {
      var P, N, Se, ie;
      const ke = Yn();
      return ke.collectionId = (P = b.collectionId) !== null && P !== void 0 ? P : "", ke.projectId = (N = b.projectId) !== null && N !== void 0 ? N : "", ke.destinationId = (Se = b.destinationId) !== null && Se !== void 0 ? Se : "", ke.updateMask = ((ie = b.updateMask) === null || ie === void 0 ? void 0 : ie.map((gt) => gt)) || [], ke.destination = b.destination !== void 0 && b.destination !== null ? a.Destination.fromPartial(b.destination) : void 0, ke;
    }
  };
  function jn() {
    return { collectionId: "", projectId: "", destinationId: "", connect: void 0 };
  }
  a.DestinationStateEvent = {
    encode(b, P = c.default.Writer.create()) {
      return b.collectionId !== "" && P.uint32(10).string(b.collectionId), b.projectId !== "" && P.uint32(18).string(b.projectId), b.destinationId !== "" && P.uint32(26).string(b.destinationId), b.connect !== void 0 && P.uint32(32).int32(xe(b.connect)), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = jn();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.projectId = N.string();
            break;
          case 3:
            ie.destinationId = N.string();
            break;
          case 4:
            ie.connect = se(N.int32());
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: De(b.collectionId) ? String(b.collectionId) : "",
        projectId: De(b.projectId) ? String(b.projectId) : "",
        destinationId: De(b.destinationId) ? String(b.destinationId) : "",
        connect: De(b.connect) ? se(b.connect) : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.collectionId !== void 0 && (P.collectionId = b.collectionId), b.projectId !== void 0 && (P.projectId = b.projectId), b.destinationId !== void 0 && (P.destinationId = b.destinationId), b.connect !== void 0 && (P.connect = b.connect !== void 0 ? ge(b.connect) : void 0), P;
    },
    fromPartial(b) {
      var P, N, Se, ie;
      const ke = jn();
      return ke.collectionId = (P = b.collectionId) !== null && P !== void 0 ? P : "", ke.projectId = (N = b.projectId) !== null && N !== void 0 ? N : "", ke.destinationId = (Se = b.destinationId) !== null && Se !== void 0 ? Se : "", ke.connect = (ie = b.connect) !== null && ie !== void 0 ? ie : void 0, ke;
    }
  };
  function Zn() {
    return { collectionId: "", projectId: "", project: void 0 };
  }
  a.ProjectCreateEvent = {
    encode(b, P = c.default.Writer.create()) {
      return b.collectionId !== "" && P.uint32(10).string(b.collectionId), b.projectId !== "" && P.uint32(18).string(b.projectId), b.project !== void 0 && a.Project.encode(b.project, P.uint32(26).fork()).ldelim(), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = Zn();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.projectId = N.string();
            break;
          case 3:
            ie.project = a.Project.decode(N, N.uint32());
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: De(b.collectionId) ? String(b.collectionId) : "",
        projectId: De(b.projectId) ? String(b.projectId) : "",
        project: De(b.project) ? a.Project.fromJSON(b.project) : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.collectionId !== void 0 && (P.collectionId = b.collectionId), b.projectId !== void 0 && (P.projectId = b.projectId), b.project !== void 0 && (P.project = b.project ? a.Project.toJSON(b.project) : void 0), P;
    },
    fromPartial(b) {
      var P, N;
      const Se = Zn();
      return Se.collectionId = (P = b.collectionId) !== null && P !== void 0 ? P : "", Se.projectId = (N = b.projectId) !== null && N !== void 0 ? N : "", Se.project = b.project !== void 0 && b.project !== null ? a.Project.fromPartial(b.project) : void 0, Se;
    }
  };
  function Xn() {
    return { collectionId: "", projectId: "" };
  }
  a.ProjectDeleteEvent = {
    encode(b, P = c.default.Writer.create()) {
      return b.collectionId !== "" && P.uint32(10).string(b.collectionId), b.projectId !== "" && P.uint32(18).string(b.projectId), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = Xn();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.projectId = N.string();
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: De(b.collectionId) ? String(b.collectionId) : "",
        projectId: De(b.projectId) ? String(b.projectId) : ""
      };
    },
    toJSON(b) {
      const P = {};
      return b.collectionId !== void 0 && (P.collectionId = b.collectionId), b.projectId !== void 0 && (P.projectId = b.projectId), P;
    },
    fromPartial(b) {
      var P, N;
      const Se = Xn();
      return Se.collectionId = (P = b.collectionId) !== null && P !== void 0 ? P : "", Se.projectId = (N = b.projectId) !== null && N !== void 0 ? N : "", Se;
    }
  };
  function Qn() {
    return { collectionId: "", projectId: "", updateMask: [], project: void 0 };
  }
  a.ProjectUpdateEvent = {
    encode(b, P = c.default.Writer.create()) {
      b.collectionId !== "" && P.uint32(10).string(b.collectionId), b.projectId !== "" && P.uint32(18).string(b.projectId);
      for (const N of b.updateMask)
        P.uint32(26).string(N);
      return b.project !== void 0 && a.Project.encode(b.project, P.uint32(34).fork()).ldelim(), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = Qn();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.projectId = N.string();
            break;
          case 3:
            ie.updateMask.push(N.string());
            break;
          case 4:
            ie.project = a.Project.decode(N, N.uint32());
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: De(b.collectionId) ? String(b.collectionId) : "",
        projectId: De(b.projectId) ? String(b.projectId) : "",
        updateMask: Array.isArray(b == null ? void 0 : b.updateMask) ? b.updateMask.map((P) => String(P)) : [],
        project: De(b.project) ? a.Project.fromJSON(b.project) : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.collectionId !== void 0 && (P.collectionId = b.collectionId), b.projectId !== void 0 && (P.projectId = b.projectId), b.updateMask ? P.updateMask = b.updateMask.map((N) => N) : P.updateMask = [], b.project !== void 0 && (P.project = b.project ? a.Project.toJSON(b.project) : void 0), P;
    },
    fromPartial(b) {
      var P, N, Se;
      const ie = Qn();
      return ie.collectionId = (P = b.collectionId) !== null && P !== void 0 ? P : "", ie.projectId = (N = b.projectId) !== null && N !== void 0 ? N : "", ie.updateMask = ((Se = b.updateMask) === null || Se === void 0 ? void 0 : Se.map((ke) => ke)) || [], ie.project = b.project !== void 0 && b.project !== null ? a.Project.fromPartial(b.project) : void 0, ie;
    }
  };
  function ei() {
    return { collectionId: "", projectId: "", broadcastId: "", phase: void 0, error: void 0 };
  }
  a.ProjectBroadcastStateEvent = {
    encode(b, P = c.default.Writer.create()) {
      return b.collectionId !== "" && P.uint32(10).string(b.collectionId), b.projectId !== "" && P.uint32(18).string(b.projectId), b.broadcastId !== "" && P.uint32(26).string(b.broadcastId), b.phase !== void 0 && P.uint32(32).int32(je(b.phase)), b.error !== void 0 && P.uint32(40).int32(Ke(b.error)), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = ei();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.projectId = N.string();
            break;
          case 3:
            ie.broadcastId = N.string();
            break;
          case 4:
            ie.phase = Pe(N.int32());
            break;
          case 5:
            ie.error = Je(N.int32());
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: De(b.collectionId) ? String(b.collectionId) : "",
        projectId: De(b.projectId) ? String(b.projectId) : "",
        broadcastId: De(b.broadcastId) ? String(b.broadcastId) : "",
        phase: De(b.phase) ? Pe(b.phase) : void 0,
        error: De(b.error) ? Je(b.error) : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.collectionId !== void 0 && (P.collectionId = b.collectionId), b.projectId !== void 0 && (P.projectId = b.projectId), b.broadcastId !== void 0 && (P.broadcastId = b.broadcastId), b.phase !== void 0 && (P.phase = b.phase !== void 0 ? Fe(b.phase) : void 0), b.error !== void 0 && (P.error = b.error !== void 0 ? Ze(b.error) : void 0), P;
    },
    fromPartial(b) {
      var P, N, Se, ie, ke;
      const gt = ei();
      return gt.collectionId = (P = b.collectionId) !== null && P !== void 0 ? P : "", gt.projectId = (N = b.projectId) !== null && N !== void 0 ? N : "", gt.broadcastId = (Se = b.broadcastId) !== null && Se !== void 0 ? Se : "", gt.phase = (ie = b.phase) !== null && ie !== void 0 ? ie : void 0, gt.error = (ke = b.error) !== null && ke !== void 0 ? ke : void 0, gt;
    }
  };
  function ti() {
    return { collectionId: "", collection: void 0 };
  }
  a.CollectionCreateEvent = {
    encode(b, P = c.default.Writer.create()) {
      return b.collectionId !== "" && P.uint32(10).string(b.collectionId), b.collection !== void 0 && a.Collection.encode(b.collection, P.uint32(18).fork()).ldelim(), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = ti();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.collection = a.Collection.decode(N, N.uint32());
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: De(b.collectionId) ? String(b.collectionId) : "",
        collection: De(b.collection) ? a.Collection.fromJSON(b.collection) : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.collectionId !== void 0 && (P.collectionId = b.collectionId), b.collection !== void 0 && (P.collection = b.collection ? a.Collection.toJSON(b.collection) : void 0), P;
    },
    fromPartial(b) {
      var P;
      const N = ti();
      return N.collectionId = (P = b.collectionId) !== null && P !== void 0 ? P : "", N.collection = b.collection !== void 0 && b.collection !== null ? a.Collection.fromPartial(b.collection) : void 0, N;
    }
  };
  function ri() {
    return { collectionId: "" };
  }
  a.CollectionDeleteEvent = {
    encode(b, P = c.default.Writer.create()) {
      return b.collectionId !== "" && P.uint32(10).string(b.collectionId), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = ri();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return { collectionId: De(b.collectionId) ? String(b.collectionId) : "" };
    },
    toJSON(b) {
      const P = {};
      return b.collectionId !== void 0 && (P.collectionId = b.collectionId), P;
    },
    fromPartial(b) {
      var P;
      const N = ri();
      return N.collectionId = (P = b.collectionId) !== null && P !== void 0 ? P : "", N;
    }
  };
  function ni() {
    return { collectionId: "", updateMask: [], collection: void 0 };
  }
  a.CollectionUpdateEvent = {
    encode(b, P = c.default.Writer.create()) {
      b.collectionId !== "" && P.uint32(10).string(b.collectionId);
      for (const N of b.updateMask)
        P.uint32(18).string(N);
      return b.collection !== void 0 && a.Collection.encode(b.collection, P.uint32(26).fork()).ldelim(), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = ni();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.updateMask.push(N.string());
            break;
          case 3:
            ie.collection = a.Collection.decode(N, N.uint32());
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: De(b.collectionId) ? String(b.collectionId) : "",
        updateMask: Array.isArray(b == null ? void 0 : b.updateMask) ? b.updateMask.map((P) => String(P)) : [],
        collection: De(b.collection) ? a.Collection.fromJSON(b.collection) : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.collectionId !== void 0 && (P.collectionId = b.collectionId), b.updateMask ? P.updateMask = b.updateMask.map((N) => N) : P.updateMask = [], b.collection !== void 0 && (P.collection = b.collection ? a.Collection.toJSON(b.collection) : void 0), P;
    },
    fromPartial(b) {
      var P, N;
      const Se = ni();
      return Se.collectionId = (P = b.collectionId) !== null && P !== void 0 ? P : "", Se.updateMask = ((N = b.updateMask) === null || N === void 0 ? void 0 : N.map((ie) => ie)) || [], Se.collection = b.collection !== void 0 && b.collection !== null ? a.Collection.fromPartial(b.collection) : void 0, Se;
    }
  };
  function ii() {
    return { collectionId: "", sourceId: "", source: void 0 };
  }
  a.SourceCreateEvent = {
    encode(b, P = c.default.Writer.create()) {
      return b.collectionId !== "" && P.uint32(10).string(b.collectionId), b.sourceId !== "" && P.uint32(18).string(b.sourceId), b.source !== void 0 && a.Source.encode(b.source, P.uint32(26).fork()).ldelim(), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = ii();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.sourceId = N.string();
            break;
          case 3:
            ie.source = a.Source.decode(N, N.uint32());
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: De(b.collectionId) ? String(b.collectionId) : "",
        sourceId: De(b.sourceId) ? String(b.sourceId) : "",
        source: De(b.source) ? a.Source.fromJSON(b.source) : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.collectionId !== void 0 && (P.collectionId = b.collectionId), b.sourceId !== void 0 && (P.sourceId = b.sourceId), b.source !== void 0 && (P.source = b.source ? a.Source.toJSON(b.source) : void 0), P;
    },
    fromPartial(b) {
      var P, N;
      const Se = ii();
      return Se.collectionId = (P = b.collectionId) !== null && P !== void 0 ? P : "", Se.sourceId = (N = b.sourceId) !== null && N !== void 0 ? N : "", Se.source = b.source !== void 0 && b.source !== null ? a.Source.fromPartial(b.source) : void 0, Se;
    }
  };
  function ai() {
    return { collectionId: "", sourceId: "" };
  }
  a.SourceDeleteEvent = {
    encode(b, P = c.default.Writer.create()) {
      return b.collectionId !== "" && P.uint32(10).string(b.collectionId), b.sourceId !== "" && P.uint32(18).string(b.sourceId), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = ai();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.sourceId = N.string();
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: De(b.collectionId) ? String(b.collectionId) : "",
        sourceId: De(b.sourceId) ? String(b.sourceId) : ""
      };
    },
    toJSON(b) {
      const P = {};
      return b.collectionId !== void 0 && (P.collectionId = b.collectionId), b.sourceId !== void 0 && (P.sourceId = b.sourceId), P;
    },
    fromPartial(b) {
      var P, N;
      const Se = ai();
      return Se.collectionId = (P = b.collectionId) !== null && P !== void 0 ? P : "", Se.sourceId = (N = b.sourceId) !== null && N !== void 0 ? N : "", Se;
    }
  };
  function oi() {
    return { collectionId: "", sourceId: "", updateMask: [], source: void 0 };
  }
  a.SourceUpdateEvent = {
    encode(b, P = c.default.Writer.create()) {
      b.collectionId !== "" && P.uint32(10).string(b.collectionId), b.sourceId !== "" && P.uint32(18).string(b.sourceId);
      for (const N of b.updateMask)
        P.uint32(26).string(N);
      return b.source !== void 0 && a.Source.encode(b.source, P.uint32(34).fork()).ldelim(), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = oi();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.sourceId = N.string();
            break;
          case 3:
            ie.updateMask.push(N.string());
            break;
          case 4:
            ie.source = a.Source.decode(N, N.uint32());
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: De(b.collectionId) ? String(b.collectionId) : "",
        sourceId: De(b.sourceId) ? String(b.sourceId) : "",
        updateMask: Array.isArray(b == null ? void 0 : b.updateMask) ? b.updateMask.map((P) => String(P)) : [],
        source: De(b.source) ? a.Source.fromJSON(b.source) : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.collectionId !== void 0 && (P.collectionId = b.collectionId), b.sourceId !== void 0 && (P.sourceId = b.sourceId), b.updateMask ? P.updateMask = b.updateMask.map((N) => N) : P.updateMask = [], b.source !== void 0 && (P.source = b.source ? a.Source.toJSON(b.source) : void 0), P;
    },
    fromPartial(b) {
      var P, N, Se;
      const ie = oi();
      return ie.collectionId = (P = b.collectionId) !== null && P !== void 0 ? P : "", ie.sourceId = (N = b.sourceId) !== null && N !== void 0 ? N : "", ie.updateMask = ((Se = b.updateMask) === null || Se === void 0 ? void 0 : Se.map((ke) => ke)) || [], ie.source = b.source !== void 0 && b.source !== null ? a.Source.fromPartial(b.source) : void 0, ie;
    }
  };
  function si() {
    return { collectionId: "", sourceId: "", projectId: "", source: void 0 };
  }
  a.SourceAddEvent = {
    encode(b, P = c.default.Writer.create()) {
      return b.collectionId !== "" && P.uint32(10).string(b.collectionId), b.sourceId !== "" && P.uint32(18).string(b.sourceId), b.projectId !== "" && P.uint32(26).string(b.projectId), b.source !== void 0 && a.Source.encode(b.source, P.uint32(34).fork()).ldelim(), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = si();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.sourceId = N.string();
            break;
          case 3:
            ie.projectId = N.string();
            break;
          case 4:
            ie.source = a.Source.decode(N, N.uint32());
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: De(b.collectionId) ? String(b.collectionId) : "",
        sourceId: De(b.sourceId) ? String(b.sourceId) : "",
        projectId: De(b.projectId) ? String(b.projectId) : "",
        source: De(b.source) ? a.Source.fromJSON(b.source) : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.collectionId !== void 0 && (P.collectionId = b.collectionId), b.sourceId !== void 0 && (P.sourceId = b.sourceId), b.projectId !== void 0 && (P.projectId = b.projectId), b.source !== void 0 && (P.source = b.source ? a.Source.toJSON(b.source) : void 0), P;
    },
    fromPartial(b) {
      var P, N, Se;
      const ie = si();
      return ie.collectionId = (P = b.collectionId) !== null && P !== void 0 ? P : "", ie.sourceId = (N = b.sourceId) !== null && N !== void 0 ? N : "", ie.projectId = (Se = b.projectId) !== null && Se !== void 0 ? Se : "", ie.source = b.source !== void 0 && b.source !== null ? a.Source.fromPartial(b.source) : void 0, ie;
    }
  };
  function di() {
    return { collectionId: "", sourceId: "", projectId: "" };
  }
  a.SourceRemoveEvent = {
    encode(b, P = c.default.Writer.create()) {
      return b.collectionId !== "" && P.uint32(10).string(b.collectionId), b.sourceId !== "" && P.uint32(18).string(b.sourceId), b.projectId !== "" && P.uint32(26).string(b.projectId), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = di();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.sourceId = N.string();
            break;
          case 3:
            ie.projectId = N.string();
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: De(b.collectionId) ? String(b.collectionId) : "",
        sourceId: De(b.sourceId) ? String(b.sourceId) : "",
        projectId: De(b.projectId) ? String(b.projectId) : ""
      };
    },
    toJSON(b) {
      const P = {};
      return b.collectionId !== void 0 && (P.collectionId = b.collectionId), b.sourceId !== void 0 && (P.sourceId = b.sourceId), b.projectId !== void 0 && (P.projectId = b.projectId), P;
    },
    fromPartial(b) {
      var P, N, Se;
      const ie = di();
      return ie.collectionId = (P = b.collectionId) !== null && P !== void 0 ? P : "", ie.sourceId = (N = b.sourceId) !== null && N !== void 0 ? N : "", ie.projectId = (Se = b.projectId) !== null && Se !== void 0 ? Se : "", ie;
    }
  };
  function ui() {
    return { collectionId: "", projectId: "", sourceId: "", connect: void 0 };
  }
  a.SourceStateEvent = {
    encode(b, P = c.default.Writer.create()) {
      return b.collectionId !== "" && P.uint32(10).string(b.collectionId), b.projectId !== "" && P.uint32(18).string(b.projectId), b.sourceId !== "" && P.uint32(26).string(b.sourceId), b.connect !== void 0 && P.uint32(32).int32(xe(b.connect)), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = ui();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.collectionId = N.string();
            break;
          case 2:
            ie.projectId = N.string();
            break;
          case 3:
            ie.sourceId = N.string();
            break;
          case 4:
            ie.connect = se(N.int32());
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collectionId: De(b.collectionId) ? String(b.collectionId) : "",
        projectId: De(b.projectId) ? String(b.projectId) : "",
        sourceId: De(b.sourceId) ? String(b.sourceId) : "",
        connect: De(b.connect) ? se(b.connect) : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.collectionId !== void 0 && (P.collectionId = b.collectionId), b.projectId !== void 0 && (P.projectId = b.projectId), b.sourceId !== void 0 && (P.sourceId = b.sourceId), b.connect !== void 0 && (P.connect = b.connect !== void 0 ? ge(b.connect) : void 0), P;
    },
    fromPartial(b) {
      var P, N, Se, ie;
      const ke = ui();
      return ke.collectionId = (P = b.collectionId) !== null && P !== void 0 ? P : "", ke.projectId = (N = b.projectId) !== null && N !== void 0 ? N : "", ke.sourceId = (Se = b.sourceId) !== null && Se !== void 0 ? Se : "", ke.connect = (ie = b.connect) !== null && ie !== void 0 ? ie : void 0, ke;
    }
  };
  function ci() {
    return { create: void 0, update: void 0, delete: void 0 };
  }
  a.CollectionEvent = {
    encode(b, P = c.default.Writer.create()) {
      return b.create !== void 0 && a.CollectionCreateEvent.encode(b.create, P.uint32(10).fork()).ldelim(), b.update !== void 0 && a.CollectionUpdateEvent.encode(b.update, P.uint32(18).fork()).ldelim(), b.delete !== void 0 && a.CollectionDeleteEvent.encode(b.delete, P.uint32(26).fork()).ldelim(), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = ci();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.create = a.CollectionCreateEvent.decode(N, N.uint32());
            break;
          case 2:
            ie.update = a.CollectionUpdateEvent.decode(N, N.uint32());
            break;
          case 3:
            ie.delete = a.CollectionDeleteEvent.decode(N, N.uint32());
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        create: De(b.create) ? a.CollectionCreateEvent.fromJSON(b.create) : void 0,
        update: De(b.update) ? a.CollectionUpdateEvent.fromJSON(b.update) : void 0,
        delete: De(b.delete) ? a.CollectionDeleteEvent.fromJSON(b.delete) : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.create !== void 0 && (P.create = b.create ? a.CollectionCreateEvent.toJSON(b.create) : void 0), b.update !== void 0 && (P.update = b.update ? a.CollectionUpdateEvent.toJSON(b.update) : void 0), b.delete !== void 0 && (P.delete = b.delete ? a.CollectionDeleteEvent.toJSON(b.delete) : void 0), P;
    },
    fromPartial(b) {
      const P = ci();
      return P.create = b.create !== void 0 && b.create !== null ? a.CollectionCreateEvent.fromPartial(b.create) : void 0, P.update = b.update !== void 0 && b.update !== null ? a.CollectionUpdateEvent.fromPartial(b.update) : void 0, P.delete = b.delete !== void 0 && b.delete !== null ? a.CollectionDeleteEvent.fromPartial(b.delete) : void 0, P;
    }
  };
  function li() {
    return { create: void 0, update: void 0, delete: void 0, state: void 0 };
  }
  a.DestinationEvent = {
    encode(b, P = c.default.Writer.create()) {
      return b.create !== void 0 && a.DestinationCreateEvent.encode(b.create, P.uint32(10).fork()).ldelim(), b.update !== void 0 && a.DestinationUpdateEvent.encode(b.update, P.uint32(18).fork()).ldelim(), b.delete !== void 0 && a.DestinationDeleteEvent.encode(b.delete, P.uint32(26).fork()).ldelim(), b.state !== void 0 && a.DestinationStateEvent.encode(b.state, P.uint32(34).fork()).ldelim(), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = li();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.create = a.DestinationCreateEvent.decode(N, N.uint32());
            break;
          case 2:
            ie.update = a.DestinationUpdateEvent.decode(N, N.uint32());
            break;
          case 3:
            ie.delete = a.DestinationDeleteEvent.decode(N, N.uint32());
            break;
          case 4:
            ie.state = a.DestinationStateEvent.decode(N, N.uint32());
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        create: De(b.create) ? a.DestinationCreateEvent.fromJSON(b.create) : void 0,
        update: De(b.update) ? a.DestinationUpdateEvent.fromJSON(b.update) : void 0,
        delete: De(b.delete) ? a.DestinationDeleteEvent.fromJSON(b.delete) : void 0,
        state: De(b.state) ? a.DestinationStateEvent.fromJSON(b.state) : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.create !== void 0 && (P.create = b.create ? a.DestinationCreateEvent.toJSON(b.create) : void 0), b.update !== void 0 && (P.update = b.update ? a.DestinationUpdateEvent.toJSON(b.update) : void 0), b.delete !== void 0 && (P.delete = b.delete ? a.DestinationDeleteEvent.toJSON(b.delete) : void 0), b.state !== void 0 && (P.state = b.state ? a.DestinationStateEvent.toJSON(b.state) : void 0), P;
    },
    fromPartial(b) {
      const P = li();
      return P.create = b.create !== void 0 && b.create !== null ? a.DestinationCreateEvent.fromPartial(b.create) : void 0, P.update = b.update !== void 0 && b.update !== null ? a.DestinationUpdateEvent.fromPartial(b.update) : void 0, P.delete = b.delete !== void 0 && b.delete !== null ? a.DestinationDeleteEvent.fromPartial(b.delete) : void 0, P.state = b.state !== void 0 && b.state !== null ? a.DestinationStateEvent.fromPartial(b.state) : void 0, P;
    }
  };
  function fi() {
    return { create: void 0, update: void 0, delete: void 0, state: void 0 };
  }
  a.ProjectEvent = {
    encode(b, P = c.default.Writer.create()) {
      return b.create !== void 0 && a.ProjectCreateEvent.encode(b.create, P.uint32(10).fork()).ldelim(), b.update !== void 0 && a.ProjectUpdateEvent.encode(b.update, P.uint32(18).fork()).ldelim(), b.delete !== void 0 && a.ProjectDeleteEvent.encode(b.delete, P.uint32(26).fork()).ldelim(), b.state !== void 0 && a.ProjectBroadcastStateEvent.encode(b.state, P.uint32(34).fork()).ldelim(), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = fi();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.create = a.ProjectCreateEvent.decode(N, N.uint32());
            break;
          case 2:
            ie.update = a.ProjectUpdateEvent.decode(N, N.uint32());
            break;
          case 3:
            ie.delete = a.ProjectDeleteEvent.decode(N, N.uint32());
            break;
          case 4:
            ie.state = a.ProjectBroadcastStateEvent.decode(N, N.uint32());
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        create: De(b.create) ? a.ProjectCreateEvent.fromJSON(b.create) : void 0,
        update: De(b.update) ? a.ProjectUpdateEvent.fromJSON(b.update) : void 0,
        delete: De(b.delete) ? a.ProjectDeleteEvent.fromJSON(b.delete) : void 0,
        state: De(b.state) ? a.ProjectBroadcastStateEvent.fromJSON(b.state) : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.create !== void 0 && (P.create = b.create ? a.ProjectCreateEvent.toJSON(b.create) : void 0), b.update !== void 0 && (P.update = b.update ? a.ProjectUpdateEvent.toJSON(b.update) : void 0), b.delete !== void 0 && (P.delete = b.delete ? a.ProjectDeleteEvent.toJSON(b.delete) : void 0), b.state !== void 0 && (P.state = b.state ? a.ProjectBroadcastStateEvent.toJSON(b.state) : void 0), P;
    },
    fromPartial(b) {
      const P = fi();
      return P.create = b.create !== void 0 && b.create !== null ? a.ProjectCreateEvent.fromPartial(b.create) : void 0, P.update = b.update !== void 0 && b.update !== null ? a.ProjectUpdateEvent.fromPartial(b.update) : void 0, P.delete = b.delete !== void 0 && b.delete !== null ? a.ProjectDeleteEvent.fromPartial(b.delete) : void 0, P.state = b.state !== void 0 && b.state !== null ? a.ProjectBroadcastStateEvent.fromPartial(b.state) : void 0, P;
    }
  };
  function hi() {
    return {
      create: void 0,
      update: void 0,
      delete: void 0,
      add: void 0,
      remove: void 0,
      state: void 0
    };
  }
  a.SourceEvent = {
    encode(b, P = c.default.Writer.create()) {
      return b.create !== void 0 && a.SourceCreateEvent.encode(b.create, P.uint32(10).fork()).ldelim(), b.update !== void 0 && a.SourceUpdateEvent.encode(b.update, P.uint32(18).fork()).ldelim(), b.delete !== void 0 && a.SourceDeleteEvent.encode(b.delete, P.uint32(26).fork()).ldelim(), b.add !== void 0 && a.SourceAddEvent.encode(b.add, P.uint32(34).fork()).ldelim(), b.remove !== void 0 && a.SourceRemoveEvent.encode(b.remove, P.uint32(42).fork()).ldelim(), b.state !== void 0 && a.SourceStateEvent.encode(b.state, P.uint32(50).fork()).ldelim(), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = hi();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.create = a.SourceCreateEvent.decode(N, N.uint32());
            break;
          case 2:
            ie.update = a.SourceUpdateEvent.decode(N, N.uint32());
            break;
          case 3:
            ie.delete = a.SourceDeleteEvent.decode(N, N.uint32());
            break;
          case 4:
            ie.add = a.SourceAddEvent.decode(N, N.uint32());
            break;
          case 5:
            ie.remove = a.SourceRemoveEvent.decode(N, N.uint32());
            break;
          case 6:
            ie.state = a.SourceStateEvent.decode(N, N.uint32());
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        create: De(b.create) ? a.SourceCreateEvent.fromJSON(b.create) : void 0,
        update: De(b.update) ? a.SourceUpdateEvent.fromJSON(b.update) : void 0,
        delete: De(b.delete) ? a.SourceDeleteEvent.fromJSON(b.delete) : void 0,
        add: De(b.add) ? a.SourceAddEvent.fromJSON(b.add) : void 0,
        remove: De(b.remove) ? a.SourceRemoveEvent.fromJSON(b.remove) : void 0,
        state: De(b.state) ? a.SourceStateEvent.fromJSON(b.state) : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.create !== void 0 && (P.create = b.create ? a.SourceCreateEvent.toJSON(b.create) : void 0), b.update !== void 0 && (P.update = b.update ? a.SourceUpdateEvent.toJSON(b.update) : void 0), b.delete !== void 0 && (P.delete = b.delete ? a.SourceDeleteEvent.toJSON(b.delete) : void 0), b.add !== void 0 && (P.add = b.add ? a.SourceAddEvent.toJSON(b.add) : void 0), b.remove !== void 0 && (P.remove = b.remove ? a.SourceRemoveEvent.toJSON(b.remove) : void 0), b.state !== void 0 && (P.state = b.state ? a.SourceStateEvent.toJSON(b.state) : void 0), P;
    },
    fromPartial(b) {
      const P = hi();
      return P.create = b.create !== void 0 && b.create !== null ? a.SourceCreateEvent.fromPartial(b.create) : void 0, P.update = b.update !== void 0 && b.update !== null ? a.SourceUpdateEvent.fromPartial(b.update) : void 0, P.delete = b.delete !== void 0 && b.delete !== null ? a.SourceDeleteEvent.fromPartial(b.delete) : void 0, P.add = b.add !== void 0 && b.add !== null ? a.SourceAddEvent.fromPartial(b.add) : void 0, P.remove = b.remove !== void 0 && b.remove !== null ? a.SourceRemoveEvent.fromPartial(b.remove) : void 0, P.state = b.state !== void 0 && b.state !== null ? a.SourceStateEvent.fromPartial(b.state) : void 0, P;
    }
  };
  function pi() {
    return {
      collection: void 0,
      destination: void 0,
      project: void 0,
      source: void 0,
      unspecified: void 0
    };
  }
  a.LiveEvent = {
    encode(b, P = c.default.Writer.create()) {
      return b.collection !== void 0 && a.CollectionEvent.encode(b.collection, P.uint32(10).fork()).ldelim(), b.destination !== void 0 && a.DestinationEvent.encode(b.destination, P.uint32(18).fork()).ldelim(), b.project !== void 0 && a.ProjectEvent.encode(b.project, P.uint32(26).fork()).ldelim(), b.source !== void 0 && a.SourceEvent.encode(b.source, P.uint32(34).fork()).ldelim(), b.unspecified !== void 0 && P.uint32(40).int32((0, p.nullValueToNumber)(b.unspecified)), P;
    },
    decode(b, P) {
      const N = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = P === void 0 ? N.len : N.pos + P;
      const ie = pi();
      for (; N.pos < Se; ) {
        const ke = N.uint32();
        switch (ke >>> 3) {
          case 1:
            ie.collection = a.CollectionEvent.decode(N, N.uint32());
            break;
          case 2:
            ie.destination = a.DestinationEvent.decode(N, N.uint32());
            break;
          case 3:
            ie.project = a.ProjectEvent.decode(N, N.uint32());
            break;
          case 4:
            ie.source = a.SourceEvent.decode(N, N.uint32());
            break;
          case 5:
            ie.unspecified = (0, p.nullValueFromJSON)(N.int32());
            break;
          default:
            N.skipType(ke & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(b) {
      return {
        collection: De(b.collection) ? a.CollectionEvent.fromJSON(b.collection) : void 0,
        destination: De(b.destination) ? a.DestinationEvent.fromJSON(b.destination) : void 0,
        project: De(b.project) ? a.ProjectEvent.fromJSON(b.project) : void 0,
        source: De(b.source) ? a.SourceEvent.fromJSON(b.source) : void 0,
        unspecified: De(b.unspecified) ? (0, p.nullValueFromJSON)(b.unspecified) : void 0
      };
    },
    toJSON(b) {
      const P = {};
      return b.collection !== void 0 && (P.collection = b.collection ? a.CollectionEvent.toJSON(b.collection) : void 0), b.destination !== void 0 && (P.destination = b.destination ? a.DestinationEvent.toJSON(b.destination) : void 0), b.project !== void 0 && (P.project = b.project ? a.ProjectEvent.toJSON(b.project) : void 0), b.source !== void 0 && (P.source = b.source ? a.SourceEvent.toJSON(b.source) : void 0), b.unspecified !== void 0 && (P.unspecified = b.unspecified !== void 0 ? (0, p.nullValueToJSON)(b.unspecified) : void 0), P;
    },
    fromPartial(b) {
      var P;
      const N = pi();
      return N.collection = b.collection !== void 0 && b.collection !== null ? a.CollectionEvent.fromPartial(b.collection) : void 0, N.destination = b.destination !== void 0 && b.destination !== null ? a.DestinationEvent.fromPartial(b.destination) : void 0, N.project = b.project !== void 0 && b.project !== null ? a.ProjectEvent.fromPartial(b.project) : void 0, N.source = b.source !== void 0 && b.source !== null ? a.SourceEvent.fromPartial(b.source) : void 0, N.unspecified = (P = b.unspecified) !== null && P !== void 0 ? P : void 0, N;
    }
  };
  class vi {
    constructor(P, N) {
      this.service = (N == null ? void 0 : N.service) || "live.v21.AccountConfigurationService", this.rpc = P, this.GetAccountConfiguration = this.GetAccountConfiguration.bind(this), this.UpdateAccountConfiguration = this.UpdateAccountConfiguration.bind(this);
    }
    GetAccountConfiguration(P) {
      const N = a.GetAccountConfigurationRequest.encode(P).finish();
      return this.rpc.request(this.service, "GetAccountConfiguration", N).then((ie) => a.GetAccountConfigurationResponse.decode(new c.default.Reader(ie)));
    }
    UpdateAccountConfiguration(P) {
      const N = a.UpdateAccountConfigurationRequest.encode(P).finish();
      return this.rpc.request(this.service, "UpdateAccountConfiguration", N).then((ie) => a.UpdateAccountConfigurationResponse.decode(new c.default.Reader(ie)));
    }
  }
  a.AccountConfigurationServiceClientImpl = vi, a.AccountConfigurationServiceDefinition = {
    name: "AccountConfigurationService",
    fullName: "live.v21.AccountConfigurationService",
    methods: {
      /** get account configuration */
      getAccountConfiguration: {
        name: "GetAccountConfiguration",
        requestType: a.GetAccountConfigurationRequest,
        requestStream: !1,
        responseType: a.GetAccountConfigurationResponse,
        responseStream: !1,
        options: {}
      },
      /** update account configuration */
      updateAccountConfiguration: {
        name: "UpdateAccountConfiguration",
        requestType: a.UpdateAccountConfigurationRequest,
        requestStream: !1,
        responseType: a.UpdateAccountConfigurationResponse,
        responseStream: !1,
        options: {}
      }
    }
  };
  class yi {
    constructor(P, N) {
      this.service = (N == null ? void 0 : N.service) || "live.v21.CollectionService", this.rpc = P, this.CreateCollection = this.CreateCollection.bind(this), this.GetCollection = this.GetCollection.bind(this), this.GetCollections = this.GetCollections.bind(this), this.UpdateCollection = this.UpdateCollection.bind(this), this.DeleteCollection = this.DeleteCollection.bind(this);
    }
    CreateCollection(P) {
      const N = a.CreateCollectionRequest.encode(P).finish();
      return this.rpc.request(this.service, "CreateCollection", N).then((ie) => a.CreateCollectionResponse.decode(new c.default.Reader(ie)));
    }
    GetCollection(P) {
      const N = a.GetCollectionRequest.encode(P).finish();
      return this.rpc.request(this.service, "GetCollection", N).then((ie) => a.GetCollectionResponse.decode(new c.default.Reader(ie)));
    }
    GetCollections(P) {
      const N = a.GetCollectionsRequest.encode(P).finish();
      return this.rpc.request(this.service, "GetCollections", N).then((ie) => a.GetCollectionsResponse.decode(new c.default.Reader(ie)));
    }
    UpdateCollection(P) {
      const N = a.UpdateCollectionRequest.encode(P).finish();
      return this.rpc.request(this.service, "UpdateCollection", N).then((ie) => a.UpdateCollectionResponse.decode(new c.default.Reader(ie)));
    }
    DeleteCollection(P) {
      const N = a.DeleteCollectionRequest.encode(P).finish();
      return this.rpc.request(this.service, "DeleteCollection", N).then((ie) => a.DeleteCollectionResponse.decode(new c.default.Reader(ie)));
    }
  }
  a.CollectionServiceClientImpl = yi, a.CollectionServiceDefinition = {
    name: "CollectionService",
    fullName: "live.v21.CollectionService",
    methods: {
      /**
       * Create Collection
       *
       * Create a new collection of related projects and collection live sources
       */
      createCollection: {
        name: "CreateCollection",
        requestType: a.CreateCollectionRequest,
        requestStream: !1,
        responseType: a.CreateCollectionResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Get Collection
       *
       * Get an existing collection of related projects and collection live
       * sources
       */
      getCollection: {
        name: "GetCollection",
        requestType: a.GetCollectionRequest,
        requestStream: !1,
        responseType: a.GetCollectionResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Get Collections
       *
       * Get all collections owned by the user
       */
      getCollections: {
        name: "GetCollections",
        requestType: a.GetCollectionsRequest,
        requestStream: !1,
        responseType: a.GetCollectionsResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Update Collection
       *
       * Update select collection document data
       */
      updateCollection: {
        name: "UpdateCollection",
        requestType: a.UpdateCollectionRequest,
        requestStream: !1,
        responseType: a.UpdateCollectionResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Delete Collection
       *
       * Delete a collection of related projects and collection live sources
       */
      deleteCollection: {
        name: "DeleteCollection",
        requestType: a.DeleteCollectionRequest,
        requestStream: !1,
        responseType: a.DeleteCollectionResponse,
        responseStream: !1,
        options: {}
      }
    }
  };
  class gi {
    constructor(P, N) {
      this.service = (N == null ? void 0 : N.service) || "live.v21.ProjectService", this.rpc = P, this.CreateProject = this.CreateProject.bind(this), this.GetProject = this.GetProject.bind(this), this.DeleteProject = this.DeleteProject.bind(this), this.UpdateProject = this.UpdateProject.bind(this), this.StartProjectBroadcast = this.StartProjectBroadcast.bind(this), this.StopProjectBroadcast = this.StopProjectBroadcast.bind(this), this.StartProjectWebRtc = this.StartProjectWebRtc.bind(this), this.StopProjectWebRtc = this.StopProjectWebRtc.bind(this), this.GetProjectBroadcastSnapshot = this.GetProjectBroadcastSnapshot.bind(this), this.GetProjectBroadcastStatus = this.GetProjectBroadcastStatus.bind(this);
    }
    CreateProject(P) {
      const N = a.CreateProjectRequest.encode(P).finish();
      return this.rpc.request(this.service, "CreateProject", N).then((ie) => a.CreateProjectResponse.decode(new c.default.Reader(ie)));
    }
    GetProject(P) {
      const N = a.GetProjectRequest.encode(P).finish();
      return this.rpc.request(this.service, "GetProject", N).then((ie) => a.GetProjectResponse.decode(new c.default.Reader(ie)));
    }
    DeleteProject(P) {
      const N = a.DeleteProjectRequest.encode(P).finish();
      return this.rpc.request(this.service, "DeleteProject", N).then((ie) => a.DeleteProjectResponse.decode(new c.default.Reader(ie)));
    }
    UpdateProject(P) {
      const N = a.UpdateProjectRequest.encode(P).finish();
      return this.rpc.request(this.service, "UpdateProject", N).then((ie) => a.UpdateProjectResponse.decode(new c.default.Reader(ie)));
    }
    StartProjectBroadcast(P) {
      const N = a.StartProjectBroadcastRequest.encode(P).finish();
      return this.rpc.request(this.service, "StartProjectBroadcast", N).then((ie) => a.StartProjectBroadcastResponse.decode(new c.default.Reader(ie)));
    }
    StopProjectBroadcast(P) {
      const N = a.StopProjectBroadcastRequest.encode(P).finish();
      return this.rpc.request(this.service, "StopProjectBroadcast", N).then((ie) => a.StopProjectBroadcastResponse.decode(new c.default.Reader(ie)));
    }
    StartProjectWebRtc(P) {
      const N = a.StartProjectWebRtcRequest.encode(P).finish();
      return this.rpc.request(this.service, "StartProjectWebRtc", N).then((ie) => a.StartProjectWebRtcResponse.decode(new c.default.Reader(ie)));
    }
    StopProjectWebRtc(P) {
      const N = a.StopProjectWebRtcRequest.encode(P).finish();
      return this.rpc.request(this.service, "StopProjectWebRtc", N).then((ie) => a.StopProjectWebRtcResponse.decode(new c.default.Reader(ie)));
    }
    GetProjectBroadcastSnapshot(P) {
      const N = a.GetProjectBroadcastSnapshotRequest.encode(P).finish();
      return this.rpc.request(this.service, "GetProjectBroadcastSnapshot", N).then((ie) => a.GetProjectBroadcastSnapshotResponse.decode(new c.default.Reader(ie)));
    }
    GetProjectBroadcastStatus(P) {
      const N = a.GetProjectBroadcastStatusRequest.encode(P).finish();
      return this.rpc.request(this.service, "GetProjectBroadcastStatus", N).then((ie) => a.GetProjectBroadcastStatusResponse.decode(new c.default.Reader(ie)));
    }
  }
  a.ProjectServiceClientImpl = gi, a.ProjectServiceDefinition = {
    name: "ProjectService",
    fullName: "live.v21.ProjectService",
    methods: {
      /**
       * Create Project
       *
       * Create a new project
       */
      createProject: {
        name: "CreateProject",
        requestType: a.CreateProjectRequest,
        requestStream: !1,
        responseType: a.CreateProjectResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Get Project
       *
       * Get an existing project
       */
      getProject: {
        name: "GetProject",
        requestType: a.GetProjectRequest,
        requestStream: !1,
        responseType: a.GetProjectResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Delete Project
       *
       * Delete a project
       */
      deleteProject: {
        name: "DeleteProject",
        requestType: a.DeleteProjectRequest,
        requestStream: !1,
        responseType: a.DeleteProjectResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Update Project
       *
       * Updates a project
       */
      updateProject: {
        name: "UpdateProject",
        requestType: a.UpdateProjectRequest,
        requestStream: !1,
        responseType: a.UpdateProjectResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Start Broadcast
       *
       * Start broadcasting a project
       */
      startProjectBroadcast: {
        name: "StartProjectBroadcast",
        requestType: a.StartProjectBroadcastRequest,
        requestStream: !1,
        responseType: a.StartProjectBroadcastResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Stop Broadcast
       *
       * Stop broadcasting a project
       */
      stopProjectBroadcast: {
        name: "StopProjectBroadcast",
        requestType: a.StopProjectBroadcastRequest,
        requestStream: !1,
        responseType: a.StopProjectBroadcastResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Start WebRTC
       *
       * Start WebRTC services
       */
      startProjectWebRtc: {
        name: "StartProjectWebRtc",
        requestType: a.StartProjectWebRtcRequest,
        requestStream: !1,
        responseType: a.StartProjectWebRtcResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Stop WebRTC
       *
       * Stop WebRTC services
       */
      stopProjectWebRtc: {
        name: "StopProjectWebRtc",
        requestType: a.StopProjectWebRtcRequest,
        requestStream: !1,
        responseType: a.StopProjectWebRtcResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Get Snapshot
       *
       * Get a snapshot of the current output frame of the broadcast
       */
      getProjectBroadcastSnapshot: {
        name: "GetProjectBroadcastSnapshot",
        requestType: a.GetProjectBroadcastSnapshotRequest,
        requestStream: !1,
        responseType: a.GetProjectBroadcastSnapshotResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Get Broadcast Status
       *
       * Get the broadcast status of the project
       */
      getProjectBroadcastStatus: {
        name: "GetProjectBroadcastStatus",
        requestType: a.GetProjectBroadcastStatusRequest,
        requestStream: !1,
        responseType: a.GetProjectBroadcastStatusResponse,
        responseStream: !1,
        options: {}
      }
    }
  };
  class bi {
    constructor(P, N) {
      this.service = (N == null ? void 0 : N.service) || "live.v21.DestinationService", this.rpc = P, this.CreateDestination = this.CreateDestination.bind(this), this.GetDestination = this.GetDestination.bind(this), this.UpdateDestination = this.UpdateDestination.bind(this), this.DeleteDestination = this.DeleteDestination.bind(this);
    }
    CreateDestination(P) {
      const N = a.CreateDestinationRequest.encode(P).finish();
      return this.rpc.request(this.service, "CreateDestination", N).then((ie) => a.CreateDestinationResponse.decode(new c.default.Reader(ie)));
    }
    GetDestination(P) {
      const N = a.GetDestinationRequest.encode(P).finish();
      return this.rpc.request(this.service, "GetDestination", N).then((ie) => a.GetDestinationResponse.decode(new c.default.Reader(ie)));
    }
    UpdateDestination(P) {
      const N = a.UpdateDestinationRequest.encode(P).finish();
      return this.rpc.request(this.service, "UpdateDestination", N).then((ie) => a.UpdateDestinationResponse.decode(new c.default.Reader(ie)));
    }
    DeleteDestination(P) {
      const N = a.DeleteDestinationRequest.encode(P).finish();
      return this.rpc.request(this.service, "DeleteDestination", N).then((ie) => a.DeleteDestinationResponse.decode(new c.default.Reader(ie)));
    }
  }
  a.DestinationServiceClientImpl = bi, a.DestinationServiceDefinition = {
    name: "DestinationService",
    fullName: "live.v21.DestinationService",
    methods: {
      /**
       * Create Destination
       *
       * Create a new Destination
       */
      createDestination: {
        name: "CreateDestination",
        requestType: a.CreateDestinationRequest,
        requestStream: !1,
        responseType: a.CreateDestinationResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Get Destination
       *
       * Get an existing Destination.
       */
      getDestination: {
        name: "GetDestination",
        requestType: a.GetDestinationRequest,
        requestStream: !1,
        responseType: a.GetDestinationResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Update Destination
       *
       * Update a destination
       */
      updateDestination: {
        name: "UpdateDestination",
        requestType: a.UpdateDestinationRequest,
        requestStream: !1,
        responseType: a.UpdateDestinationResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Delete Destination
       *
       * Delete a destination
       */
      deleteDestination: {
        name: "DeleteDestination",
        requestType: a.DeleteDestinationRequest,
        requestStream: !1,
        responseType: a.DeleteDestinationResponse,
        responseStream: !1,
        options: {}
      }
    }
  };
  class Si {
    constructor(P, N) {
      this.service = (N == null ? void 0 : N.service) || "live.v21.SourceService", this.rpc = P, this.CreateSource = this.CreateSource.bind(this), this.DeleteSource = this.DeleteSource.bind(this), this.UpdateSource = this.UpdateSource.bind(this), this.UpdateSourceInProject = this.UpdateSourceInProject.bind(this), this.GetSource = this.GetSource.bind(this), this.GetSources = this.GetSources.bind(this), this.AddSourceToProject = this.AddSourceToProject.bind(this), this.RemoveSourceFromProject = this.RemoveSourceFromProject.bind(this), this.GetSourcePlaylist = this.GetSourcePlaylist.bind(this);
    }
    CreateSource(P) {
      const N = a.CreateSourceRequest.encode(P).finish();
      return this.rpc.request(this.service, "CreateSource", N).then((ie) => a.CreateSourceResponse.decode(new c.default.Reader(ie)));
    }
    DeleteSource(P) {
      const N = a.DeleteSourceRequest.encode(P).finish();
      return this.rpc.request(this.service, "DeleteSource", N).then((ie) => a.DeleteSourceResponse.decode(new c.default.Reader(ie)));
    }
    UpdateSource(P) {
      const N = a.UpdateSourceRequest.encode(P).finish();
      return this.rpc.request(this.service, "UpdateSource", N).then((ie) => a.UpdateSourceResponse.decode(new c.default.Reader(ie)));
    }
    UpdateSourceInProject(P) {
      const N = a.UpdateSourceInProjectRequest.encode(P).finish();
      return this.rpc.request(this.service, "UpdateSourceInProject", N).then((ie) => a.UpdateSourceInProjectResponse.decode(new c.default.Reader(ie)));
    }
    GetSource(P) {
      const N = a.GetSourceRequest.encode(P).finish();
      return this.rpc.request(this.service, "GetSource", N).then((ie) => a.GetSourceResponse.decode(new c.default.Reader(ie)));
    }
    GetSources(P) {
      const N = a.GetSourcesRequest.encode(P).finish();
      return this.rpc.request(this.service, "GetSources", N).then((ie) => a.GetSourcesResponse.decode(new c.default.Reader(ie)));
    }
    AddSourceToProject(P) {
      const N = a.AddSourceToProjectRequest.encode(P).finish();
      return this.rpc.request(this.service, "AddSourceToProject", N).then((ie) => a.AddSourceToProjectResponse.decode(new c.default.Reader(ie)));
    }
    RemoveSourceFromProject(P) {
      const N = a.RemoveSourceFromProjectRequest.encode(P).finish();
      return this.rpc.request(this.service, "RemoveSourceFromProject", N).then((ie) => a.RemoveSourceFromProjectResponse.decode(new c.default.Reader(ie)));
    }
    GetSourcePlaylist(P) {
      const N = a.GetSourcePlaylistRequest.encode(P).finish();
      return this.rpc.request(this.service, "GetSourcePlaylist", N).then((ie) => l.HttpBody.decode(new c.default.Reader(ie)));
    }
  }
  a.SourceServiceClientImpl = Si, a.SourceServiceDefinition = {
    name: "SourceService",
    fullName: "live.v21.SourceService",
    methods: {
      /**
       * Create Collection Live Source
       *
       * Create a new live source in a collection
       * ### Permissions
       * * scope: `SCOPE_VAPI_CREATE`
       */
      createSource: {
        name: "CreateSource",
        requestType: a.CreateSourceRequest,
        requestStream: !1,
        responseType: a.CreateSourceResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Delete Live Source
       *
       * Deletes a live source from a collection
       */
      deleteSource: {
        name: "DeleteSource",
        requestType: a.DeleteSourceRequest,
        requestStream: !1,
        responseType: a.DeleteSourceResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Update Source
       *
       * Update attributes of the Source.
       */
      updateSource: {
        name: "UpdateSource",
        requestType: a.UpdateSourceRequest,
        requestStream: !1,
        responseType: a.UpdateSourceResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Update Source
       *
       * Update attributes of the Source.
       */
      updateSourceInProject: {
        name: "UpdateSourceInProject",
        requestType: a.UpdateSourceInProjectRequest,
        requestStream: !1,
        responseType: a.UpdateSourceInProjectResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Get Source
       *
       * Get an existing source in a project
       */
      getSource: {
        name: "GetSource",
        requestType: a.GetSourceRequest,
        requestStream: !1,
        responseType: a.GetSourceResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Get Source
       *
       * Get existing sources in a collection
       */
      getSources: {
        name: "GetSources",
        requestType: a.GetSourcesRequest,
        requestStream: !1,
        responseType: a.GetSourcesResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Add Source to Project
       *
       * Add a source to a project
       */
      addSourceToProject: {
        name: "AddSourceToProject",
        requestType: a.AddSourceToProjectRequest,
        requestStream: !1,
        responseType: a.AddSourceToProjectResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Delete Source From Project
       *
       * Removes a source from a project.
       */
      removeSourceFromProject: {
        name: "RemoveSourceFromProject",
        requestType: a.RemoveSourceFromProjectRequest,
        requestStream: !1,
        responseType: a.RemoveSourceFromProjectResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Get the HLS playlist for a source.
       * buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
       */
      getSourcePlaylist: {
        name: "GetSourcePlaylist",
        requestType: a.GetSourcePlaylistRequest,
        requestStream: !1,
        responseType: l.HttpBody,
        responseStream: !1,
        options: {}
      }
    }
  };
  class _i {
    constructor(P, N) {
      this.service = (N == null ? void 0 : N.service) || "live.v21.BackendAuthenticationService", this.rpc = P, this.CreateAccessToken = this.CreateAccessToken.bind(this);
    }
    CreateAccessToken(P) {
      const N = a.CreateAccessTokenRequest.encode(P).finish();
      return this.rpc.request(this.service, "CreateAccessToken", N).then((ie) => a.CreateAccessTokenResponse.decode(new c.default.Reader(ie)));
    }
  }
  a.BackendAuthenticationServiceClientImpl = _i, a.BackendAuthenticationServiceDefinition = {
    name: "BackendAuthenticationService",
    fullName: "live.v21.BackendAuthenticationService",
    methods: {
      /**
       * Create Access Token
       *
       * Create an access token for a session host
       */
      createAccessToken: {
        name: "CreateAccessToken",
        requestType: a.CreateAccessTokenRequest,
        requestStream: !1,
        responseType: a.CreateAccessTokenResponse,
        responseStream: !1,
        options: {}
      }
    }
  };
  class Ei {
    constructor(P, N) {
      this.service = (N == null ? void 0 : N.service) || "live.v21.AuthenticationService", this.rpc = P, this.CreateGuestAccessToken = this.CreateGuestAccessToken.bind(this), this.RefreshAccessToken = this.RefreshAccessToken.bind(this), this.CreateWebRtcAccessToken = this.CreateWebRtcAccessToken.bind(this);
    }
    CreateGuestAccessToken(P) {
      const N = a.CreateGuestAccessTokenRequest.encode(P).finish();
      return this.rpc.request(this.service, "CreateGuestAccessToken", N).then((ie) => a.CreateGuestAccessTokenResponse.decode(new c.default.Reader(ie)));
    }
    RefreshAccessToken(P) {
      const N = a.RefreshAccessTokenRequest.encode(P).finish();
      return this.rpc.request(this.service, "RefreshAccessToken", N).then((ie) => a.RefreshAccessTokenResponse.decode(new c.default.Reader(ie)));
    }
    CreateWebRtcAccessToken(P) {
      const N = a.CreateWebRtcAccessTokenRequest.encode(P).finish();
      return this.rpc.request(this.service, "CreateWebRtcAccessToken", N).then((ie) => a.CreateWebRtcAccessTokenResponse.decode(new c.default.Reader(ie)));
    }
  }
  a.AuthenticationServiceClientImpl = Ei, a.AuthenticationServiceDefinition = {
    name: "AuthenticationService",
    fullName: "live.v21.AuthenticationService",
    methods: {
      /**
       * Create Guest Access Token
       *
       * Create an access token for a guest
       */
      createGuestAccessToken: {
        name: "CreateGuestAccessToken",
        requestType: a.CreateGuestAccessTokenRequest,
        requestStream: !1,
        responseType: a.CreateGuestAccessTokenResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Refresh Access Token
       *
       * Forcibly refresh an access token prior to expiration
       */
      refreshAccessToken: {
        name: "RefreshAccessToken",
        requestType: a.RefreshAccessTokenRequest,
        requestStream: !1,
        responseType: a.RefreshAccessTokenResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Create WebRTC Access Token
       *
       * Create a WebRTC Access Token
       */
      createWebRtcAccessToken: {
        name: "CreateWebRtcAccessToken",
        requestType: a.CreateWebRtcAccessTokenRequest,
        requestStream: !1,
        responseType: a.CreateWebRtcAccessTokenResponse,
        responseStream: !1,
        options: {}
      }
    }
  };
  class Ti {
    constructor(P, N) {
      this.service = (N == null ? void 0 : N.service) || "live.v21.PublicAuthenticationService", this.rpc = P, this.GetJsonWebKeySet = this.GetJsonWebKeySet.bind(this), this.GuestCodeRedirect = this.GuestCodeRedirect.bind(this);
    }
    GetJsonWebKeySet(P) {
      const N = a.GetJsonWebKeySetRequest.encode(P).finish();
      return this.rpc.request(this.service, "GetJsonWebKeySet", N).then((ie) => a.GetJsonWebKeySetResponse.decode(new c.default.Reader(ie)));
    }
    GuestCodeRedirect(P) {
      const N = a.GuestCodeRedirectRequest.encode(P).finish();
      return this.rpc.request(this.service, "GuestCodeRedirect", N).then((ie) => a.GuestCodeRedirectResponse.decode(new c.default.Reader(ie)));
    }
  }
  a.PublicAuthenticationServiceClientImpl = Ti, a.PublicAuthenticationServiceDefinition = {
    name: "PublicAuthenticationService",
    fullName: "live.v21.PublicAuthenticationService",
    methods: {
      /**
       * Get Public Keys
       *
       * Get public keys used to sign access tokens
       */
      getJsonWebKeySet: {
        name: "GetJsonWebKeySet",
        requestType: a.GetJsonWebKeySetRequest,
        requestStream: !1,
        responseType: a.GetJsonWebKeySetResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Exchange Guest Access Token
       *
       * Exchange a guest access token with updated user identifiers
       */
      guestCodeRedirect: {
        name: "GuestCodeRedirect",
        requestType: a.GuestCodeRedirectRequest,
        requestStream: !1,
        responseType: a.GuestCodeRedirectResponse,
        responseStream: !1,
        options: {}
      }
    }
  };
  var _t = (() => {
    if (typeof _t < "u")
      return _t;
    if (typeof self < "u")
      return self;
    if (typeof window < "u")
      return window;
    if (typeof commonjsGlobal$1 < "u")
      return commonjsGlobal$1;
    throw "Unable to locate global object";
  })();
  function wi(b) {
    if (_t.Buffer)
      return Uint8Array.from(_t.Buffer.from(b, "base64"));
    {
      const P = _t.atob(b), N = new Uint8Array(P.length);
      for (let Se = 0; Se < P.length; ++Se)
        N[Se] = P.charCodeAt(Se);
      return N;
    }
  }
  function ki(b) {
    if (_t.Buffer)
      return _t.Buffer.from(b).toString("base64");
    {
      const P = [];
      return b.forEach((N) => {
        P.push(String.fromCharCode(N));
      }), _t.btoa(P.join(""));
    }
  }
  function Ht(b) {
    const P = new Date(b), N = P.getTime() / 1e3, Se = P.getTime() % 1e3 * 1e6;
    return { seconds: N, nanos: Se };
  }
  function zt(b) {
    let P = b.seconds * 1e3;
    return P += b.nanos / 1e6, new Date(P).toISOString();
  }
  function Ii(b) {
    return typeof b == "object" && b !== null;
  }
  function De(b) {
    return b != null;
  }
})(api$2);
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(j, ee, X, ae) {
    ae === void 0 && (ae = X);
    var Q = Object.getOwnPropertyDescriptor(ee, X);
    (!Q || ("get" in Q ? !ee.__esModule : Q.writable || Q.configurable)) && (Q = { enumerable: !0, get: function() {
      return ee[X];
    } }), Object.defineProperty(j, ae, Q);
  } : function(j, ee, X, ae) {
    ae === void 0 && (ae = X), j[ae] = ee[X];
  }), c = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(j, ee) {
    Object.defineProperty(j, "default", { enumerable: !0, value: ee });
  } : function(j, ee) {
    j.default = ee;
  }), l = commonjsGlobal$1 && commonjsGlobal$1.__decorate || function(j, ee, X, ae) {
    var Q = arguments.length, ne = Q < 3 ? ee : ae === null ? ae = Object.getOwnPropertyDescriptor(ee, X) : ae, Z;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      ne = Reflect.decorate(j, ee, X, ae);
    else
      for (var de = j.length - 1; de >= 0; de--)
        (Z = j[de]) && (ne = (Q < 3 ? Z(ne) : Q > 3 ? Z(ee, X, ne) : Z(ee, X)) || ne);
    return Q > 3 && ne && Object.defineProperty(ee, X, ne), ne;
  }, v = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(j) {
    if (j && j.__esModule)
      return j;
    var ee = {};
    if (j != null)
      for (var X in j)
        X !== "default" && Object.prototype.hasOwnProperty.call(j, X) && u(ee, j, X);
    return c(ee, j), ee;
  }, p = commonjsGlobal$1 && commonjsGlobal$1.__metadata || function(j, ee) {
    if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
      return Reflect.metadata(j, ee);
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.LiveApi = void 0;
  const _ = v(lib$1), k = api$3, O = v(api$2), D = decorator, F = "LiveApi";
  class z extends k.ApiClient {
    constructor(ee, X, ae, Q, ne, Z, de) {
      super(ee, ae, Z, F, de), this.handlers = {}, this.eventApi = X, this.accessTokenRefreshCallback = Q, this.publicAuthentication = this.clientFactory.create(O.PublicAuthenticationServiceDefinition, this.channel), ne != null && (this.backendAuthentication = this.clientFactory.create(O.BackendAuthenticationServiceDefinition, this.channel, {
        "*": { metadata: _.Metadata({ "X-Api-Key": ne }) }
      }), this.accountConfiguration = this.clientFactory.create(O.AccountConfigurationServiceDefinition, this.channel, {
        "*": { metadata: _.Metadata({ "X-Api-Key": ne }) }
      })), this.eventApi.on("event", { name: `${z.LIVEAPI_EVENT_PREFIX}:*`, ignoreSessionEvents: !0, allowedSessionEvents: [`${z.LIVEAPI_EVENT_PREFIX}:EVENT_TYPE_PROJECT:EVENT_SUB_TYPE_STATE`] }, this.eventCallback.bind(this));
    }
    /**
    * Register an event handler
    *
    * @param type Type of event
    * @param handler
    */
    on(ee, X) {
      var ae;
      this.handlers[ee] = (ae = this.handlers[ee]) !== null && ae !== void 0 ? ae : [], this.handlers[ee].push(X);
    }
    /**
     * Unregister an event handler
     *
     * @param type Type of event
     * @param handler
     */
    off(ee, X) {
      this.handlers[ee] = this.handlers[ee].filter((ae) => ae !== X);
    }
    emitToHandlers(ee, X, ae) {
      var Q;
      for (const ne of (Q = this.handlers[ee]) !== null && Q !== void 0 ? Q : [])
        ne(Object.values(ae).find((Z) => !!Z), X);
    }
    async subscribeToCollection(ee) {
      await this.eventApi.subscribe(`${z.LIVEAPI_EVENT_PREFIX}:*`, { target: { collectionId: ee } });
    }
    async unsubscribeFromCollection(ee) {
      await this.eventApi.unsubscribe(`${z.LIVEAPI_EVENT_PREFIX}:*`, { target: { collectionId: ee } });
    }
    async subscribeToProject(ee, X) {
      await this.eventApi.subscribe(`${z.LIVEAPI_EVENT_PREFIX}:*`, { target: { collectionId: ee, projectId: X } });
    }
    async unsubscribeFromProject(ee, X) {
      await this.eventApi.unsubscribe(`${z.LIVEAPI_EVENT_PREFIX}:*`, { target: { collectionId: ee, projectId: X } });
    }
    eventCallback(ee) {
      let ae = ee.name.split(`${z.LIVEAPI_EVENT_PREFIX}:`)[1].split(":"), Q = O.eventTypeFromJSON(ae[0]), ne = O.eventSubTypeFromJSON(ae[1]);
      this.log.info("processing event: " + Q + "/" + ne), z.liveApiEventMap[Q] && this.emitToHandlers(Q, ne, ee.payload);
    }
    _setup(ee) {
      let X = this;
      ee.onHeader = function(ae) {
        let Q = ae.get("Authorization");
        if (Q != null) {
          const ne = Q.split(" ");
          if (ne.length == 2 && ne[0] == "Bearer") {
            let Z = ne[1];
            X.log.info("received refresh token"), X.accessTokenRefreshCallback(Z);
          }
        }
      }, this.collection = this.clientFactory.create(O.CollectionServiceDefinition, this.channel, {
        "*": ee
      }), this.project = this.clientFactory.create(O.ProjectServiceDefinition, this.channel, {
        "*": ee
      }), this.source = this.clientFactory.create(O.SourceServiceDefinition, this.channel, {
        "*": ee
      }), this.destination = this.clientFactory.create(O.DestinationServiceDefinition, this.channel, {
        "*": ee
      }), this.authentication = this.clientFactory.create(O.AuthenticationServiceDefinition, this.channel, {
        "*": ee
      });
    }
  }
  z.LIVEAPI_EVENT_PREFIX = "apistream:live", l([
    (0, D.RequiresSdkAuthentication)(),
    p("design:type", Object)
  ], z.prototype, "collection", void 0), l([
    (0, D.RequiresSdkAuthentication)(),
    p("design:type", Object)
  ], z.prototype, "project", void 0), l([
    (0, D.RequiresSdkAuthentication)(),
    p("design:type", Object)
  ], z.prototype, "source", void 0), l([
    (0, D.RequiresSdkAuthentication)(),
    p("design:type", Object)
  ], z.prototype, "destination", void 0), l([
    (0, D.RequiresSdkAuthentication)(),
    p("design:type", Object)
  ], z.prototype, "authentication", void 0), a.LiveApi = z, function(j) {
    j.liveApiEventMap = {
      [O.EventType.EVENT_TYPE_COLLECTION]: "collection",
      [O.EventType.EVENT_TYPE_PROJECT]: "project",
      [O.EventType.EVENT_TYPE_SOURCE]: "source",
      [O.EventType.EVENT_TYPE_DESTINATION]: "destination",
      [O.EventType.EVENT_TYPE_UNSPECIFIED]: "unspecified"
    };
  }(z = a.LiveApi || (a.LiveApi = {}));
})(liveapi);
var eventapi = {}, dist$1 = {}, api$1 = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(a, u) {
  return extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(c, l) {
    c.__proto__ = l;
  } || function(c, l) {
    for (var v in l)
      l.hasOwnProperty(v) && (c[v] = l[v]);
  }, extendStatics(a, u);
};
function __extends(a, u) {
  extendStatics(a, u);
  function c() {
    this.constructor = a;
  }
  a.prototype = u === null ? Object.create(u) : (c.prototype = u.prototype, new c());
}
function isFunction$3(a) {
  return typeof a == "function";
}
var _enable_super_gross_mode_that_will_cause_bad_things = !1, config$3 = {
  Promise: void 0,
  set useDeprecatedSynchronousErrorHandling(a) {
    if (a) {
      var u = /* @__PURE__ */ new Error();
      "" + u.stack;
    }
    _enable_super_gross_mode_that_will_cause_bad_things = a;
  },
  get useDeprecatedSynchronousErrorHandling() {
    return _enable_super_gross_mode_that_will_cause_bad_things;
  }
};
function hostReportError(a) {
  setTimeout(function() {
    throw a;
  }, 0);
}
var empty$3 = {
  closed: !0,
  next: function(a) {
  },
  error: function(a) {
    if (config$3.useDeprecatedSynchronousErrorHandling)
      throw a;
    hostReportError(a);
  },
  complete: function() {
  }
}, isArray$5 = /* @__PURE__ */ function() {
  return Array.isArray || function(a) {
    return a && typeof a.length == "number";
  };
}();
function isObject$9(a) {
  return a !== null && typeof a == "object";
}
var UnsubscriptionErrorImpl = /* @__PURE__ */ function() {
  function a(u) {
    return Error.call(this), this.message = u ? u.length + ` errors occurred during unsubscription:
` + u.map(function(c, l) {
      return l + 1 + ") " + c.toString();
    }).join(`
  `) : "", this.name = "UnsubscriptionError", this.errors = u, this;
  }
  return a.prototype = /* @__PURE__ */ Object.create(Error.prototype), a;
}(), UnsubscriptionError = UnsubscriptionErrorImpl, Subscription = /* @__PURE__ */ function() {
  function a(u) {
    this.closed = !1, this._parentOrParents = null, this._subscriptions = null, u && (this._ctorUnsubscribe = !0, this._unsubscribe = u);
  }
  return a.prototype.unsubscribe = function() {
    var u;
    if (!this.closed) {
      var c = this, l = c._parentOrParents, v = c._ctorUnsubscribe, p = c._unsubscribe, _ = c._subscriptions;
      if (this.closed = !0, this._parentOrParents = null, this._subscriptions = null, l instanceof a)
        l.remove(this);
      else if (l !== null)
        for (var k = 0; k < l.length; ++k) {
          var O = l[k];
          O.remove(this);
        }
      if (isFunction$3(p)) {
        v && (this._unsubscribe = void 0);
        try {
          p.call(this);
        } catch (z) {
          u = z instanceof UnsubscriptionError ? flattenUnsubscriptionErrors(z.errors) : [z];
        }
      }
      if (isArray$5(_))
        for (var k = -1, D = _.length; ++k < D; ) {
          var F = _[k];
          if (isObject$9(F))
            try {
              F.unsubscribe();
            } catch (j) {
              u = u || [], j instanceof UnsubscriptionError ? u = u.concat(flattenUnsubscriptionErrors(j.errors)) : u.push(j);
            }
        }
      if (u)
        throw new UnsubscriptionError(u);
    }
  }, a.prototype.add = function(u) {
    var c = u;
    if (!u)
      return a.EMPTY;
    switch (typeof u) {
      case "function":
        c = new a(u);
      case "object":
        if (c === this || c.closed || typeof c.unsubscribe != "function")
          return c;
        if (this.closed)
          return c.unsubscribe(), c;
        if (!(c instanceof a)) {
          var l = c;
          c = new a(), c._subscriptions = [l];
        }
        break;
      default:
        throw new Error("unrecognized teardown " + u + " added to Subscription.");
    }
    var v = c._parentOrParents;
    if (v === null)
      c._parentOrParents = this;
    else if (v instanceof a) {
      if (v === this)
        return c;
      c._parentOrParents = [v, this];
    } else if (v.indexOf(this) === -1)
      v.push(this);
    else
      return c;
    var p = this._subscriptions;
    return p === null ? this._subscriptions = [c] : p.push(c), c;
  }, a.prototype.remove = function(u) {
    var c = this._subscriptions;
    if (c) {
      var l = c.indexOf(u);
      l !== -1 && c.splice(l, 1);
    }
  }, a.EMPTY = function(u) {
    return u.closed = !0, u;
  }(new a()), a;
}();
function flattenUnsubscriptionErrors(a) {
  return a.reduce(function(u, c) {
    return u.concat(c instanceof UnsubscriptionError ? c.errors : c);
  }, []);
}
var rxSubscriber = /* @__PURE__ */ function() {
  return typeof Symbol == "function" ? /* @__PURE__ */ Symbol("rxSubscriber") : "@@rxSubscriber_" + /* @__PURE__ */ Math.random();
}(), Subscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this) || this;
    switch (p.syncErrorValue = null, p.syncErrorThrown = !1, p.syncErrorThrowable = !1, p.isStopped = !1, arguments.length) {
      case 0:
        p.destination = empty$3;
        break;
      case 1:
        if (!c) {
          p.destination = empty$3;
          break;
        }
        if (typeof c == "object") {
          c instanceof u ? (p.syncErrorThrowable = c.syncErrorThrowable, p.destination = c, c.add(p)) : (p.syncErrorThrowable = !0, p.destination = new SafeSubscriber(p, c));
          break;
        }
      default:
        p.syncErrorThrowable = !0, p.destination = new SafeSubscriber(p, c, l, v);
        break;
    }
    return p;
  }
  return u.prototype[rxSubscriber] = function() {
    return this;
  }, u.create = function(c, l, v) {
    var p = new u(c, l, v);
    return p.syncErrorThrowable = !1, p;
  }, u.prototype.next = function(c) {
    this.isStopped || this._next(c);
  }, u.prototype.error = function(c) {
    this.isStopped || (this.isStopped = !0, this._error(c));
  }, u.prototype.complete = function() {
    this.isStopped || (this.isStopped = !0, this._complete());
  }, u.prototype.unsubscribe = function() {
    this.closed || (this.isStopped = !0, a.prototype.unsubscribe.call(this));
  }, u.prototype._next = function(c) {
    this.destination.next(c);
  }, u.prototype._error = function(c) {
    this.destination.error(c), this.unsubscribe();
  }, u.prototype._complete = function() {
    this.destination.complete(), this.unsubscribe();
  }, u.prototype._unsubscribeAndRecycle = function() {
    var c = this._parentOrParents;
    return this._parentOrParents = null, this.unsubscribe(), this.closed = !1, this.isStopped = !1, this._parentOrParents = c, this;
  }, u;
}(Subscription), SafeSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v, p) {
    var _ = a.call(this) || this;
    _._parentSubscriber = c;
    var k, O = _;
    return isFunction$3(l) ? k = l : l && (k = l.next, v = l.error, p = l.complete, l !== empty$3 && (O = Object.create(l), isFunction$3(O.unsubscribe) && _.add(O.unsubscribe.bind(O)), O.unsubscribe = _.unsubscribe.bind(_))), _._context = O, _._next = k, _._error = v, _._complete = p, _;
  }
  return u.prototype.next = function(c) {
    if (!this.isStopped && this._next) {
      var l = this._parentSubscriber;
      !config$3.useDeprecatedSynchronousErrorHandling || !l.syncErrorThrowable ? this.__tryOrUnsub(this._next, c) : this.__tryOrSetError(l, this._next, c) && this.unsubscribe();
    }
  }, u.prototype.error = function(c) {
    if (!this.isStopped) {
      var l = this._parentSubscriber, v = config$3.useDeprecatedSynchronousErrorHandling;
      if (this._error)
        !v || !l.syncErrorThrowable ? (this.__tryOrUnsub(this._error, c), this.unsubscribe()) : (this.__tryOrSetError(l, this._error, c), this.unsubscribe());
      else if (l.syncErrorThrowable)
        v ? (l.syncErrorValue = c, l.syncErrorThrown = !0) : hostReportError(c), this.unsubscribe();
      else {
        if (this.unsubscribe(), v)
          throw c;
        hostReportError(c);
      }
    }
  }, u.prototype.complete = function() {
    var c = this;
    if (!this.isStopped) {
      var l = this._parentSubscriber;
      if (this._complete) {
        var v = function() {
          return c._complete.call(c._context);
        };
        !config$3.useDeprecatedSynchronousErrorHandling || !l.syncErrorThrowable ? (this.__tryOrUnsub(v), this.unsubscribe()) : (this.__tryOrSetError(l, v), this.unsubscribe());
      } else
        this.unsubscribe();
    }
  }, u.prototype.__tryOrUnsub = function(c, l) {
    try {
      c.call(this._context, l);
    } catch (v) {
      if (this.unsubscribe(), config$3.useDeprecatedSynchronousErrorHandling)
        throw v;
      hostReportError(v);
    }
  }, u.prototype.__tryOrSetError = function(c, l, v) {
    if (!config$3.useDeprecatedSynchronousErrorHandling)
      throw new Error("bad call");
    try {
      l.call(this._context, v);
    } catch (p) {
      return config$3.useDeprecatedSynchronousErrorHandling ? (c.syncErrorValue = p, c.syncErrorThrown = !0, !0) : (hostReportError(p), !0);
    }
    return !1;
  }, u.prototype._unsubscribe = function() {
    var c = this._parentSubscriber;
    this._context = null, this._parentSubscriber = null, c.unsubscribe();
  }, u;
}(Subscriber);
function canReportError(a) {
  for (; a; ) {
    var u = a, c = u.closed, l = u.destination, v = u.isStopped;
    if (c || v)
      return !1;
    l && l instanceof Subscriber ? a = l : a = null;
  }
  return !0;
}
function toSubscriber(a, u, c) {
  if (a) {
    if (a instanceof Subscriber)
      return a;
    if (a[rxSubscriber])
      return a[rxSubscriber]();
  }
  return !a && !u && !c ? new Subscriber(empty$3) : new Subscriber(a, u, c);
}
var observable = /* @__PURE__ */ function() {
  return typeof Symbol == "function" && Symbol.observable || "@@observable";
}();
function identity$1(a) {
  return a;
}
function pipe$2() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  return pipeFromArray(a);
}
function pipeFromArray(a) {
  return a.length === 0 ? identity$1 : a.length === 1 ? a[0] : function(c) {
    return a.reduce(function(l, v) {
      return v(l);
    }, c);
  };
}
var Observable = /* @__PURE__ */ function() {
  function a(u) {
    this._isScalar = !1, u && (this._subscribe = u);
  }
  return a.prototype.lift = function(u) {
    var c = new a();
    return c.source = this, c.operator = u, c;
  }, a.prototype.subscribe = function(u, c, l) {
    var v = this.operator, p = toSubscriber(u, c, l);
    if (v ? p.add(v.call(p, this.source)) : p.add(this.source || config$3.useDeprecatedSynchronousErrorHandling && !p.syncErrorThrowable ? this._subscribe(p) : this._trySubscribe(p)), config$3.useDeprecatedSynchronousErrorHandling && p.syncErrorThrowable && (p.syncErrorThrowable = !1, p.syncErrorThrown))
      throw p.syncErrorValue;
    return p;
  }, a.prototype._trySubscribe = function(u) {
    try {
      return this._subscribe(u);
    } catch (c) {
      config$3.useDeprecatedSynchronousErrorHandling && (u.syncErrorThrown = !0, u.syncErrorValue = c), canReportError(u) ? u.error(c) : console.warn(c);
    }
  }, a.prototype.forEach = function(u, c) {
    var l = this;
    return c = getPromiseCtor(c), new c(function(v, p) {
      var _;
      _ = l.subscribe(function(k) {
        try {
          u(k);
        } catch (O) {
          p(O), _ && _.unsubscribe();
        }
      }, p, v);
    });
  }, a.prototype._subscribe = function(u) {
    var c = this.source;
    return c && c.subscribe(u);
  }, a.prototype[observable] = function() {
    return this;
  }, a.prototype.pipe = function() {
    for (var u = [], c = 0; c < arguments.length; c++)
      u[c] = arguments[c];
    return u.length === 0 ? this : pipeFromArray(u)(this);
  }, a.prototype.toPromise = function(u) {
    var c = this;
    return u = getPromiseCtor(u), new u(function(l, v) {
      var p;
      c.subscribe(function(_) {
        return p = _;
      }, function(_) {
        return v(_);
      }, function() {
        return l(p);
      });
    });
  }, a.create = function(u) {
    return new a(u);
  }, a;
}();
function getPromiseCtor(a) {
  if (a || (a = Promise), !a)
    throw new Error("no Promise impl found");
  return a;
}
var subscribeToArray = function(a) {
  return function(u) {
    for (var c = 0, l = a.length; c < l && !u.closed; c++)
      u.next(a[c]);
    u.complete();
  };
}, subscribeToPromise = function(a) {
  return function(u) {
    return a.then(function(c) {
      u.closed || (u.next(c), u.complete());
    }, function(c) {
      return u.error(c);
    }).then(null, hostReportError), u;
  };
};
function getSymbolIterator() {
  return typeof Symbol != "function" || !Symbol.iterator ? "@@iterator" : Symbol.iterator;
}
var iterator = /* @__PURE__ */ getSymbolIterator(), subscribeToIterable = function(a) {
  return function(u) {
    var c = a[iterator]();
    do {
      var l = void 0;
      try {
        l = c.next();
      } catch (v) {
        return u.error(v), u;
      }
      if (l.done) {
        u.complete();
        break;
      }
      if (u.next(l.value), u.closed)
        break;
    } while (!0);
    return typeof c.return == "function" && u.add(function() {
      c.return && c.return();
    }), u;
  };
}, subscribeToObservable = function(a) {
  return function(u) {
    var c = a[observable]();
    if (typeof c.subscribe != "function")
      throw new TypeError("Provided object does not correctly implement Symbol.observable");
    return c.subscribe(u);
  };
}, isArrayLike$2 = function(a) {
  return a && typeof a.length == "number" && typeof a != "function";
};
function isPromise(a) {
  return !!a && typeof a.subscribe != "function" && typeof a.then == "function";
}
var subscribeTo = function(a) {
  if (a && typeof a[observable] == "function")
    return subscribeToObservable(a);
  if (isArrayLike$2(a))
    return subscribeToArray(a);
  if (isPromise(a))
    return subscribeToPromise(a);
  if (a && typeof a[iterator] == "function")
    return subscribeToIterable(a);
  var u = isObject$9(a) ? "an invalid object" : "'" + a + "'", c = "You provided " + u + " where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.";
  throw new TypeError(c);
}, SimpleInnerSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c) {
    var l = a.call(this) || this;
    return l.parent = c, l;
  }
  return u.prototype._next = function(c) {
    this.parent.notifyNext(c);
  }, u.prototype._error = function(c) {
    this.parent.notifyError(c), this.unsubscribe();
  }, u.prototype._complete = function() {
    this.parent.notifyComplete(), this.unsubscribe();
  }, u;
}(Subscriber), SimpleOuterSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u() {
    return a !== null && a.apply(this, arguments) || this;
  }
  return u.prototype.notifyNext = function(c) {
    this.destination.next(c);
  }, u.prototype.notifyError = function(c) {
    this.destination.error(c);
  }, u.prototype.notifyComplete = function() {
    this.destination.complete();
  }, u;
}(Subscriber);
function innerSubscribe(a, u) {
  if (!u.closed) {
    if (a instanceof Observable)
      return a.subscribe(u);
    var c;
    try {
      c = subscribeTo(a)(u);
    } catch (l) {
      u.error(l);
    }
    return c;
  }
}
function audit(a) {
  return function(c) {
    return c.lift(new AuditOperator(a));
  };
}
var AuditOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.durationSelector = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new AuditSubscriber(u, this.durationSelector));
  }, a;
}(), AuditSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.durationSelector = l, v.hasValue = !1, v;
  }
  return u.prototype._next = function(c) {
    if (this.value = c, this.hasValue = !0, !this.throttled) {
      var l = void 0;
      try {
        var v = this.durationSelector;
        l = v(c);
      } catch (_) {
        return this.destination.error(_);
      }
      var p = innerSubscribe(l, new SimpleInnerSubscriber(this));
      !p || p.closed ? this.clearThrottle() : this.add(this.throttled = p);
    }
  }, u.prototype.clearThrottle = function() {
    var c = this, l = c.value, v = c.hasValue, p = c.throttled;
    p && (this.remove(p), this.throttled = void 0, p.unsubscribe()), v && (this.value = void 0, this.hasValue = !1, this.destination.next(l));
  }, u.prototype.notifyNext = function() {
    this.clearThrottle();
  }, u.prototype.notifyComplete = function() {
    this.clearThrottle();
  }, u;
}(SimpleOuterSubscriber), Action = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    return a.call(this) || this;
  }
  return u.prototype.schedule = function(c, l) {
    return this;
  }, u;
}(Subscription), AsyncAction = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c, l) || this;
    return v.scheduler = c, v.work = l, v.pending = !1, v;
  }
  return u.prototype.schedule = function(c, l) {
    if (l === void 0 && (l = 0), this.closed)
      return this;
    this.state = c;
    var v = this.id, p = this.scheduler;
    return v != null && (this.id = this.recycleAsyncId(p, v, l)), this.pending = !0, this.delay = l, this.id = this.id || this.requestAsyncId(p, this.id, l), this;
  }, u.prototype.requestAsyncId = function(c, l, v) {
    return v === void 0 && (v = 0), setInterval(c.flush.bind(c, this), v);
  }, u.prototype.recycleAsyncId = function(c, l, v) {
    if (v === void 0 && (v = 0), v !== null && this.delay === v && this.pending === !1)
      return l;
    clearInterval(l);
  }, u.prototype.execute = function(c, l) {
    if (this.closed)
      return new Error("executing a cancelled action");
    this.pending = !1;
    var v = this._execute(c, l);
    if (v)
      return v;
    this.pending === !1 && this.id != null && (this.id = this.recycleAsyncId(this.scheduler, this.id, null));
  }, u.prototype._execute = function(c, l) {
    var v = !1, p = void 0;
    try {
      this.work(c);
    } catch (_) {
      v = !0, p = !!_ && _ || new Error(_);
    }
    if (v)
      return this.unsubscribe(), p;
  }, u.prototype._unsubscribe = function() {
    var c = this.id, l = this.scheduler, v = l.actions, p = v.indexOf(this);
    this.work = null, this.state = null, this.pending = !1, this.scheduler = null, p !== -1 && v.splice(p, 1), c != null && (this.id = this.recycleAsyncId(l, c, null)), this.delay = null;
  }, u;
}(Action), Scheduler = /* @__PURE__ */ function() {
  function a(u, c) {
    c === void 0 && (c = a.now), this.SchedulerAction = u, this.now = c;
  }
  return a.prototype.schedule = function(u, c, l) {
    return c === void 0 && (c = 0), new this.SchedulerAction(this, u).schedule(l, c);
  }, a.now = function() {
    return Date.now();
  }, a;
}(), AsyncScheduler = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    l === void 0 && (l = Scheduler.now);
    var v = a.call(this, c, function() {
      return u.delegate && u.delegate !== v ? u.delegate.now() : l();
    }) || this;
    return v.actions = [], v.active = !1, v.scheduled = void 0, v;
  }
  return u.prototype.schedule = function(c, l, v) {
    return l === void 0 && (l = 0), u.delegate && u.delegate !== this ? u.delegate.schedule(c, l, v) : a.prototype.schedule.call(this, c, l, v);
  }, u.prototype.flush = function(c) {
    var l = this.actions;
    if (this.active) {
      l.push(c);
      return;
    }
    var v;
    this.active = !0;
    do
      if (v = c.execute(c.state, c.delay))
        break;
    while (c = l.shift());
    if (this.active = !1, v) {
      for (; c = l.shift(); )
        c.unsubscribe();
      throw v;
    }
  }, u;
}(Scheduler), asyncScheduler = /* @__PURE__ */ new AsyncScheduler(AsyncAction), async$1 = asyncScheduler;
function isNumeric(a) {
  return !isArray$5(a) && a - parseFloat(a) + 1 >= 0;
}
function isScheduler(a) {
  return a && typeof a.schedule == "function";
}
function timer(a, u, c) {
  a === void 0 && (a = 0);
  var l = -1;
  return isNumeric(u) ? l = Number(u) < 1 && 1 || Number(u) : isScheduler(u) && (c = u), isScheduler(c) || (c = async$1), new Observable(function(v) {
    var p = isNumeric(a) ? a : +a - c.now();
    return c.schedule(dispatch$1, p, {
      index: 0,
      period: l,
      subscriber: v
    });
  });
}
function dispatch$1(a) {
  var u = a.index, c = a.period, l = a.subscriber;
  if (l.next(u), !l.closed) {
    if (c === -1)
      return l.complete();
    a.index = u + 1, this.schedule(a, c);
  }
}
function auditTime(a, u) {
  return u === void 0 && (u = async$1), audit(function() {
    return timer(a, u);
  });
}
function buffer$2(a) {
  return function(c) {
    return c.lift(new BufferOperator(a));
  };
}
var BufferOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.closingNotifier = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new BufferSubscriber(u, this.closingNotifier));
  }, a;
}(), BufferSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.buffer = [], v.add(innerSubscribe(l, new SimpleInnerSubscriber(v))), v;
  }
  return u.prototype._next = function(c) {
    this.buffer.push(c);
  }, u.prototype.notifyNext = function() {
    var c = this.buffer;
    this.buffer = [], this.destination.next(c);
  }, u;
}(SimpleOuterSubscriber);
function bufferCount(a, u) {
  return u === void 0 && (u = null), function(l) {
    return l.lift(new BufferCountOperator(a, u));
  };
}
var BufferCountOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.bufferSize = u, this.startBufferEvery = c, !c || u === c ? this.subscriberClass = BufferCountSubscriber : this.subscriberClass = BufferSkipCountSubscriber;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new this.subscriberClass(u, this.bufferSize, this.startBufferEvery));
  }, a;
}(), BufferCountSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.bufferSize = l, v.buffer = [], v;
  }
  return u.prototype._next = function(c) {
    var l = this.buffer;
    l.push(c), l.length == this.bufferSize && (this.destination.next(l), this.buffer = []);
  }, u.prototype._complete = function() {
    var c = this.buffer;
    c.length > 0 && this.destination.next(c), a.prototype._complete.call(this);
  }, u;
}(Subscriber), BufferSkipCountSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.bufferSize = l, p.startBufferEvery = v, p.buffers = [], p.count = 0, p;
  }
  return u.prototype._next = function(c) {
    var l = this, v = l.bufferSize, p = l.startBufferEvery, _ = l.buffers, k = l.count;
    this.count++, k % p === 0 && _.push([]);
    for (var O = _.length; O--; ) {
      var D = _[O];
      D.push(c), D.length === v && (_.splice(O, 1), this.destination.next(D));
    }
  }, u.prototype._complete = function() {
    for (var c = this, l = c.buffers, v = c.destination; l.length > 0; ) {
      var p = l.shift();
      p.length > 0 && v.next(p);
    }
    a.prototype._complete.call(this);
  }, u;
}(Subscriber);
function bufferTime(a) {
  var u = arguments.length, c = async$1;
  isScheduler(arguments[arguments.length - 1]) && (c = arguments[arguments.length - 1], u--);
  var l = null;
  u >= 2 && (l = arguments[1]);
  var v = Number.POSITIVE_INFINITY;
  return u >= 3 && (v = arguments[2]), function(_) {
    return _.lift(new BufferTimeOperator(a, l, v, c));
  };
}
var BufferTimeOperator = /* @__PURE__ */ function() {
  function a(u, c, l, v) {
    this.bufferTimeSpan = u, this.bufferCreationInterval = c, this.maxBufferSize = l, this.scheduler = v;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new BufferTimeSubscriber(u, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));
  }, a;
}(), Context = /* @__PURE__ */ function() {
  function a() {
    this.buffer = [];
  }
  return a;
}(), BufferTimeSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v, p, _) {
    var k = a.call(this, c) || this;
    k.bufferTimeSpan = l, k.bufferCreationInterval = v, k.maxBufferSize = p, k.scheduler = _, k.contexts = [];
    var O = k.openContext();
    if (k.timespanOnly = v == null || v < 0, k.timespanOnly) {
      var D = { subscriber: k, context: O, bufferTimeSpan: l };
      k.add(O.closeAction = _.schedule(dispatchBufferTimeSpanOnly, l, D));
    } else {
      var F = { subscriber: k, context: O }, z = { bufferTimeSpan: l, bufferCreationInterval: v, subscriber: k, scheduler: _ };
      k.add(O.closeAction = _.schedule(dispatchBufferClose, l, F)), k.add(_.schedule(dispatchBufferCreation, v, z));
    }
    return k;
  }
  return u.prototype._next = function(c) {
    for (var l = this.contexts, v = l.length, p, _ = 0; _ < v; _++) {
      var k = l[_], O = k.buffer;
      O.push(c), O.length == this.maxBufferSize && (p = k);
    }
    p && this.onBufferFull(p);
  }, u.prototype._error = function(c) {
    this.contexts.length = 0, a.prototype._error.call(this, c);
  }, u.prototype._complete = function() {
    for (var c = this, l = c.contexts, v = c.destination; l.length > 0; ) {
      var p = l.shift();
      v.next(p.buffer);
    }
    a.prototype._complete.call(this);
  }, u.prototype._unsubscribe = function() {
    this.contexts = null;
  }, u.prototype.onBufferFull = function(c) {
    this.closeContext(c);
    var l = c.closeAction;
    if (l.unsubscribe(), this.remove(l), !this.closed && this.timespanOnly) {
      c = this.openContext();
      var v = this.bufferTimeSpan, p = { subscriber: this, context: c, bufferTimeSpan: v };
      this.add(c.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, v, p));
    }
  }, u.prototype.openContext = function() {
    var c = new Context();
    return this.contexts.push(c), c;
  }, u.prototype.closeContext = function(c) {
    this.destination.next(c.buffer);
    var l = this.contexts, v = l ? l.indexOf(c) : -1;
    v >= 0 && l.splice(l.indexOf(c), 1);
  }, u;
}(Subscriber);
function dispatchBufferTimeSpanOnly(a) {
  var u = a.subscriber, c = a.context;
  c && u.closeContext(c), u.closed || (a.context = u.openContext(), a.context.closeAction = this.schedule(a, a.bufferTimeSpan));
}
function dispatchBufferCreation(a) {
  var u = a.bufferCreationInterval, c = a.bufferTimeSpan, l = a.subscriber, v = a.scheduler, p = l.openContext(), _ = this;
  l.closed || (l.add(p.closeAction = v.schedule(dispatchBufferClose, c, { subscriber: l, context: p })), _.schedule(a, u));
}
function dispatchBufferClose(a) {
  var u = a.subscriber, c = a.context;
  u.closeContext(c);
}
var InnerSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this) || this;
    return p.parent = c, p.outerValue = l, p.outerIndex = v, p.index = 0, p;
  }
  return u.prototype._next = function(c) {
    this.parent.notifyNext(this.outerValue, c, this.outerIndex, this.index++, this);
  }, u.prototype._error = function(c) {
    this.parent.notifyError(c, this), this.unsubscribe();
  }, u.prototype._complete = function() {
    this.parent.notifyComplete(this), this.unsubscribe();
  }, u;
}(Subscriber);
function subscribeToResult(a, u, c, l, v) {
  if (v === void 0 && (v = new InnerSubscriber(a, c, l)), !v.closed)
    return u instanceof Observable ? u.subscribe(v) : subscribeTo(u)(v);
}
var OuterSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u() {
    return a !== null && a.apply(this, arguments) || this;
  }
  return u.prototype.notifyNext = function(c, l, v, p, _) {
    this.destination.next(l);
  }, u.prototype.notifyError = function(c, l) {
    this.destination.error(c);
  }, u.prototype.notifyComplete = function(c) {
    this.destination.complete();
  }, u;
}(Subscriber);
function bufferToggle(a, u) {
  return function(l) {
    return l.lift(new BufferToggleOperator(a, u));
  };
}
var BufferToggleOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.openings = u, this.closingSelector = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new BufferToggleSubscriber(u, this.openings, this.closingSelector));
  }, a;
}(), BufferToggleSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.closingSelector = v, p.contexts = [], p.add(subscribeToResult(p, l)), p;
  }
  return u.prototype._next = function(c) {
    for (var l = this.contexts, v = l.length, p = 0; p < v; p++)
      l[p].buffer.push(c);
  }, u.prototype._error = function(c) {
    for (var l = this.contexts; l.length > 0; ) {
      var v = l.shift();
      v.subscription.unsubscribe(), v.buffer = null, v.subscription = null;
    }
    this.contexts = null, a.prototype._error.call(this, c);
  }, u.prototype._complete = function() {
    for (var c = this.contexts; c.length > 0; ) {
      var l = c.shift();
      this.destination.next(l.buffer), l.subscription.unsubscribe(), l.buffer = null, l.subscription = null;
    }
    this.contexts = null, a.prototype._complete.call(this);
  }, u.prototype.notifyNext = function(c, l) {
    c ? this.closeBuffer(c) : this.openBuffer(l);
  }, u.prototype.notifyComplete = function(c) {
    this.closeBuffer(c.context);
  }, u.prototype.openBuffer = function(c) {
    try {
      var l = this.closingSelector, v = l.call(this, c);
      v && this.trySubscribe(v);
    } catch (p) {
      this._error(p);
    }
  }, u.prototype.closeBuffer = function(c) {
    var l = this.contexts;
    if (l && c) {
      var v = c.buffer, p = c.subscription;
      this.destination.next(v), l.splice(l.indexOf(c), 1), this.remove(p), p.unsubscribe();
    }
  }, u.prototype.trySubscribe = function(c) {
    var l = this.contexts, v = [], p = new Subscription(), _ = { buffer: v, subscription: p };
    l.push(_);
    var k = subscribeToResult(this, c, _);
    !k || k.closed ? this.closeBuffer(_) : (k.context = _, this.add(k), p.add(k));
  }, u;
}(OuterSubscriber);
function bufferWhen(a) {
  return function(u) {
    return u.lift(new BufferWhenOperator(a));
  };
}
var BufferWhenOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.closingSelector = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new BufferWhenSubscriber(u, this.closingSelector));
  }, a;
}(), BufferWhenSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.closingSelector = l, v.subscribing = !1, v.openBuffer(), v;
  }
  return u.prototype._next = function(c) {
    this.buffer.push(c);
  }, u.prototype._complete = function() {
    var c = this.buffer;
    c && this.destination.next(c), a.prototype._complete.call(this);
  }, u.prototype._unsubscribe = function() {
    this.buffer = void 0, this.subscribing = !1;
  }, u.prototype.notifyNext = function() {
    this.openBuffer();
  }, u.prototype.notifyComplete = function() {
    this.subscribing ? this.complete() : this.openBuffer();
  }, u.prototype.openBuffer = function() {
    var c = this.closingSubscription;
    c && (this.remove(c), c.unsubscribe());
    var l = this.buffer;
    this.buffer && this.destination.next(l), this.buffer = [];
    var v;
    try {
      var p = this.closingSelector;
      v = p();
    } catch (_) {
      return this.error(_);
    }
    c = new Subscription(), this.closingSubscription = c, this.add(c), this.subscribing = !0, c.add(innerSubscribe(v, new SimpleInnerSubscriber(this))), this.subscribing = !1;
  }, u;
}(SimpleOuterSubscriber);
function catchError(a) {
  return function(c) {
    var l = new CatchOperator(a), v = c.lift(l);
    return l.caught = v;
  };
}
var CatchOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.selector = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new CatchSubscriber(u, this.selector, this.caught));
  }, a;
}(), CatchSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.selector = l, p.caught = v, p;
  }
  return u.prototype.error = function(c) {
    if (!this.isStopped) {
      var l = void 0;
      try {
        l = this.selector(c, this.caught);
      } catch (_) {
        a.prototype.error.call(this, _);
        return;
      }
      this._unsubscribeAndRecycle();
      var v = new SimpleInnerSubscriber(this);
      this.add(v);
      var p = innerSubscribe(l, v);
      p !== v && this.add(p);
    }
  }, u;
}(SimpleOuterSubscriber);
function scheduleArray(a, u) {
  return new Observable(function(c) {
    var l = new Subscription(), v = 0;
    return l.add(u.schedule(function() {
      if (v === a.length) {
        c.complete();
        return;
      }
      c.next(a[v++]), c.closed || l.add(this.schedule());
    })), l;
  });
}
function fromArray$1(a, u) {
  return u ? scheduleArray(a, u) : new Observable(subscribeToArray(a));
}
var NONE = {}, CombineLatestOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.resultSelector = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new CombineLatestSubscriber(u, this.resultSelector));
  }, a;
}(), CombineLatestSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.resultSelector = l, v.active = 0, v.values = [], v.observables = [], v;
  }
  return u.prototype._next = function(c) {
    this.values.push(NONE), this.observables.push(c);
  }, u.prototype._complete = function() {
    var c = this.observables, l = c.length;
    if (l === 0)
      this.destination.complete();
    else {
      this.active = l, this.toRespond = l;
      for (var v = 0; v < l; v++) {
        var p = c[v];
        this.add(subscribeToResult(this, p, void 0, v));
      }
    }
  }, u.prototype.notifyComplete = function(c) {
    (this.active -= 1) === 0 && this.destination.complete();
  }, u.prototype.notifyNext = function(c, l, v) {
    var p = this.values, _ = p[v], k = this.toRespond ? _ === NONE ? --this.toRespond : this.toRespond : 0;
    p[v] = l, k === 0 && (this.resultSelector ? this._tryResultSelector(p) : this.destination.next(p.slice()));
  }, u.prototype._tryResultSelector = function(c) {
    var l;
    try {
      l = this.resultSelector.apply(this, c);
    } catch (v) {
      this.destination.error(v);
      return;
    }
    this.destination.next(l);
  }, u;
}(OuterSubscriber);
function combineAll(a) {
  return function(u) {
    return u.lift(new CombineLatestOperator(a));
  };
}
function scheduleObservable(a, u) {
  return new Observable(function(c) {
    var l = new Subscription();
    return l.add(u.schedule(function() {
      var v = a[observable]();
      l.add(v.subscribe({
        next: function(p) {
          l.add(u.schedule(function() {
            return c.next(p);
          }));
        },
        error: function(p) {
          l.add(u.schedule(function() {
            return c.error(p);
          }));
        },
        complete: function() {
          l.add(u.schedule(function() {
            return c.complete();
          }));
        }
      }));
    })), l;
  });
}
function schedulePromise(a, u) {
  return new Observable(function(c) {
    var l = new Subscription();
    return l.add(u.schedule(function() {
      return a.then(function(v) {
        l.add(u.schedule(function() {
          c.next(v), l.add(u.schedule(function() {
            return c.complete();
          }));
        }));
      }, function(v) {
        l.add(u.schedule(function() {
          return c.error(v);
        }));
      });
    })), l;
  });
}
function scheduleIterable(a, u) {
  if (!a)
    throw new Error("Iterable cannot be null");
  return new Observable(function(c) {
    var l = new Subscription(), v;
    return l.add(function() {
      v && typeof v.return == "function" && v.return();
    }), l.add(u.schedule(function() {
      v = a[iterator](), l.add(u.schedule(function() {
        if (!c.closed) {
          var p, _;
          try {
            var k = v.next();
            p = k.value, _ = k.done;
          } catch (O) {
            c.error(O);
            return;
          }
          _ ? c.complete() : (c.next(p), this.schedule());
        }
      }));
    })), l;
  });
}
function isInteropObservable(a) {
  return a && typeof a[observable] == "function";
}
function isIterable(a) {
  return a && typeof a[iterator] == "function";
}
function scheduled(a, u) {
  if (a != null) {
    if (isInteropObservable(a))
      return scheduleObservable(a, u);
    if (isPromise(a))
      return schedulePromise(a, u);
    if (isArrayLike$2(a))
      return scheduleArray(a, u);
    if (isIterable(a) || typeof a == "string")
      return scheduleIterable(a, u);
  }
  throw new TypeError((a !== null && typeof a || a) + " is not observable");
}
function from(a, u) {
  return u ? scheduled(a, u) : a instanceof Observable ? a : new Observable(subscribeTo(a));
}
function combineLatest() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  var c = null;
  return typeof a[a.length - 1] == "function" && (c = a.pop()), a.length === 1 && isArray$5(a[0]) && (a = a[0].slice()), function(l) {
    return l.lift.call(from([l].concat(a)), new CombineLatestOperator(c));
  };
}
function of$1() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  var c = a[a.length - 1];
  return isScheduler(c) ? (a.pop(), scheduleArray(a, c)) : fromArray$1(a);
}
function map(a, u) {
  return function(l) {
    if (typeof a != "function")
      throw new TypeError("argument is not a function. Are you looking for `mapTo()`?");
    return l.lift(new MapOperator(a, u));
  };
}
var MapOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.project = u, this.thisArg = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new MapSubscriber(u, this.project, this.thisArg));
  }, a;
}(), MapSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.project = l, p.count = 0, p.thisArg = v || p, p;
  }
  return u.prototype._next = function(c) {
    var l;
    try {
      l = this.project.call(this.thisArg, c, this.count++);
    } catch (v) {
      this.destination.error(v);
      return;
    }
    this.destination.next(l);
  }, u;
}(Subscriber);
function mergeMap(a, u, c) {
  return c === void 0 && (c = Number.POSITIVE_INFINITY), typeof u == "function" ? function(l) {
    return l.pipe(mergeMap(function(v, p) {
      return from(a(v, p)).pipe(map(function(_, k) {
        return u(v, _, p, k);
      }));
    }, c));
  } : (typeof u == "number" && (c = u), function(l) {
    return l.lift(new MergeMapOperator(a, c));
  });
}
var MergeMapOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    c === void 0 && (c = Number.POSITIVE_INFINITY), this.project = u, this.concurrent = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new MergeMapSubscriber(u, this.project, this.concurrent));
  }, a;
}(), MergeMapSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    v === void 0 && (v = Number.POSITIVE_INFINITY);
    var p = a.call(this, c) || this;
    return p.project = l, p.concurrent = v, p.hasCompleted = !1, p.buffer = [], p.active = 0, p.index = 0, p;
  }
  return u.prototype._next = function(c) {
    this.active < this.concurrent ? this._tryNext(c) : this.buffer.push(c);
  }, u.prototype._tryNext = function(c) {
    var l, v = this.index++;
    try {
      l = this.project(c, v);
    } catch (p) {
      this.destination.error(p);
      return;
    }
    this.active++, this._innerSub(l);
  }, u.prototype._innerSub = function(c) {
    var l = new SimpleInnerSubscriber(this), v = this.destination;
    v.add(l);
    var p = innerSubscribe(c, l);
    p !== l && v.add(p);
  }, u.prototype._complete = function() {
    this.hasCompleted = !0, this.active === 0 && this.buffer.length === 0 && this.destination.complete(), this.unsubscribe();
  }, u.prototype.notifyNext = function(c) {
    this.destination.next(c);
  }, u.prototype.notifyComplete = function() {
    var c = this.buffer;
    this.active--, c.length > 0 ? this._next(c.shift()) : this.active === 0 && this.hasCompleted && this.destination.complete();
  }, u;
}(SimpleOuterSubscriber), flatMap = mergeMap;
function mergeAll(a) {
  return a === void 0 && (a = Number.POSITIVE_INFINITY), mergeMap(identity$1, a);
}
function concatAll() {
  return mergeAll(1);
}
function concat$1() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  return concatAll()(of$1.apply(void 0, a));
}
function concat() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  return function(c) {
    return c.lift.call(concat$1.apply(void 0, [c].concat(a)));
  };
}
function concatMap(a, u) {
  return mergeMap(a, u, 1);
}
function concatMapTo(a, u) {
  return concatMap(function() {
    return a;
  }, u);
}
function count(a) {
  return function(u) {
    return u.lift(new CountOperator(a, u));
  };
}
var CountOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.predicate = u, this.source = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new CountSubscriber(u, this.predicate, this.source));
  }, a;
}(), CountSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.predicate = l, p.source = v, p.count = 0, p.index = 0, p;
  }
  return u.prototype._next = function(c) {
    this.predicate ? this._tryPredicate(c) : this.count++;
  }, u.prototype._tryPredicate = function(c) {
    var l;
    try {
      l = this.predicate(c, this.index++, this.source);
    } catch (v) {
      this.destination.error(v);
      return;
    }
    l && this.count++;
  }, u.prototype._complete = function() {
    this.destination.next(this.count), this.destination.complete();
  }, u;
}(Subscriber);
function debounce$1(a) {
  return function(u) {
    return u.lift(new DebounceOperator(a));
  };
}
var DebounceOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.durationSelector = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new DebounceSubscriber(u, this.durationSelector));
  }, a;
}(), DebounceSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.durationSelector = l, v.hasValue = !1, v;
  }
  return u.prototype._next = function(c) {
    try {
      var l = this.durationSelector.call(this, c);
      l && this._tryNext(c, l);
    } catch (v) {
      this.destination.error(v);
    }
  }, u.prototype._complete = function() {
    this.emitValue(), this.destination.complete();
  }, u.prototype._tryNext = function(c, l) {
    var v = this.durationSubscription;
    this.value = c, this.hasValue = !0, v && (v.unsubscribe(), this.remove(v)), v = innerSubscribe(l, new SimpleInnerSubscriber(this)), v && !v.closed && this.add(this.durationSubscription = v);
  }, u.prototype.notifyNext = function() {
    this.emitValue();
  }, u.prototype.notifyComplete = function() {
    this.emitValue();
  }, u.prototype.emitValue = function() {
    if (this.hasValue) {
      var c = this.value, l = this.durationSubscription;
      l && (this.durationSubscription = void 0, l.unsubscribe(), this.remove(l)), this.value = void 0, this.hasValue = !1, a.prototype._next.call(this, c);
    }
  }, u;
}(SimpleOuterSubscriber);
function debounceTime(a, u) {
  return u === void 0 && (u = async$1), function(c) {
    return c.lift(new DebounceTimeOperator(a, u));
  };
}
var DebounceTimeOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.dueTime = u, this.scheduler = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new DebounceTimeSubscriber(u, this.dueTime, this.scheduler));
  }, a;
}(), DebounceTimeSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.dueTime = l, p.scheduler = v, p.debouncedSubscription = null, p.lastValue = null, p.hasValue = !1, p;
  }
  return u.prototype._next = function(c) {
    this.clearDebounce(), this.lastValue = c, this.hasValue = !0, this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext$1, this.dueTime, this));
  }, u.prototype._complete = function() {
    this.debouncedNext(), this.destination.complete();
  }, u.prototype.debouncedNext = function() {
    if (this.clearDebounce(), this.hasValue) {
      var c = this.lastValue;
      this.lastValue = null, this.hasValue = !1, this.destination.next(c);
    }
  }, u.prototype.clearDebounce = function() {
    var c = this.debouncedSubscription;
    c !== null && (this.remove(c), c.unsubscribe(), this.debouncedSubscription = null);
  }, u;
}(Subscriber);
function dispatchNext$1(a) {
  a.debouncedNext();
}
function defaultIfEmpty(a) {
  return a === void 0 && (a = null), function(u) {
    return u.lift(new DefaultIfEmptyOperator(a));
  };
}
var DefaultIfEmptyOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.defaultValue = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new DefaultIfEmptySubscriber(u, this.defaultValue));
  }, a;
}(), DefaultIfEmptySubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.defaultValue = l, v.isEmpty = !0, v;
  }
  return u.prototype._next = function(c) {
    this.isEmpty = !1, this.destination.next(c);
  }, u.prototype._complete = function() {
    this.isEmpty && this.destination.next(this.defaultValue), this.destination.complete();
  }, u;
}(Subscriber);
function isDate$1(a) {
  return a instanceof Date && !isNaN(+a);
}
var EMPTY = /* @__PURE__ */ new Observable(function(a) {
  return a.complete();
});
function empty$2(a) {
  return a ? emptyScheduled(a) : EMPTY;
}
function emptyScheduled(a) {
  return new Observable(function(u) {
    return a.schedule(function() {
      return u.complete();
    });
  });
}
function throwError(a, u) {
  return u ? new Observable(function(c) {
    return u.schedule(dispatch, 0, { error: a, subscriber: c });
  }) : new Observable(function(c) {
    return c.error(a);
  });
}
function dispatch(a) {
  var u = a.error, c = a.subscriber;
  c.error(u);
}
var Notification = /* @__PURE__ */ function() {
  function a(u, c, l) {
    this.kind = u, this.value = c, this.error = l, this.hasValue = u === "N";
  }
  return a.prototype.observe = function(u) {
    switch (this.kind) {
      case "N":
        return u.next && u.next(this.value);
      case "E":
        return u.error && u.error(this.error);
      case "C":
        return u.complete && u.complete();
    }
  }, a.prototype.do = function(u, c, l) {
    var v = this.kind;
    switch (v) {
      case "N":
        return u && u(this.value);
      case "E":
        return c && c(this.error);
      case "C":
        return l && l();
    }
  }, a.prototype.accept = function(u, c, l) {
    return u && typeof u.next == "function" ? this.observe(u) : this.do(u, c, l);
  }, a.prototype.toObservable = function() {
    var u = this.kind;
    switch (u) {
      case "N":
        return of$1(this.value);
      case "E":
        return throwError(this.error);
      case "C":
        return empty$2();
    }
    throw new Error("unexpected notification kind value");
  }, a.createNext = function(u) {
    return typeof u < "u" ? new a("N", u) : a.undefinedValueNotification;
  }, a.createError = function(u) {
    return new a("E", void 0, u);
  }, a.createComplete = function() {
    return a.completeNotification;
  }, a.completeNotification = new a("C"), a.undefinedValueNotification = new a("N", void 0), a;
}();
function delay(a, u) {
  u === void 0 && (u = async$1);
  var c = isDate$1(a), l = c ? +a - u.now() : Math.abs(a);
  return function(v) {
    return v.lift(new DelayOperator(l, u));
  };
}
var DelayOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.delay = u, this.scheduler = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new DelaySubscriber(u, this.delay, this.scheduler));
  }, a;
}(), DelaySubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.delay = l, p.scheduler = v, p.queue = [], p.active = !1, p.errored = !1, p;
  }
  return u.dispatch = function(c) {
    for (var l = c.source, v = l.queue, p = c.scheduler, _ = c.destination; v.length > 0 && v[0].time - p.now() <= 0; )
      v.shift().notification.observe(_);
    if (v.length > 0) {
      var k = Math.max(0, v[0].time - p.now());
      this.schedule(c, k);
    } else
      this.unsubscribe(), l.active = !1;
  }, u.prototype._schedule = function(c) {
    this.active = !0;
    var l = this.destination;
    l.add(c.schedule(u.dispatch, this.delay, {
      source: this,
      destination: this.destination,
      scheduler: c
    }));
  }, u.prototype.scheduleNotification = function(c) {
    if (this.errored !== !0) {
      var l = this.scheduler, v = new DelayMessage(l.now() + this.delay, c);
      this.queue.push(v), this.active === !1 && this._schedule(l);
    }
  }, u.prototype._next = function(c) {
    this.scheduleNotification(Notification.createNext(c));
  }, u.prototype._error = function(c) {
    this.errored = !0, this.queue = [], this.destination.error(c), this.unsubscribe();
  }, u.prototype._complete = function() {
    this.scheduleNotification(Notification.createComplete()), this.unsubscribe();
  }, u;
}(Subscriber), DelayMessage = /* @__PURE__ */ function() {
  function a(u, c) {
    this.time = u, this.notification = c;
  }
  return a;
}();
function delayWhen(a, u) {
  return u ? function(c) {
    return new SubscriptionDelayObservable(c, u).lift(new DelayWhenOperator(a));
  } : function(c) {
    return c.lift(new DelayWhenOperator(a));
  };
}
var DelayWhenOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.delayDurationSelector = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new DelayWhenSubscriber(u, this.delayDurationSelector));
  }, a;
}(), DelayWhenSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.delayDurationSelector = l, v.completed = !1, v.delayNotifierSubscriptions = [], v.index = 0, v;
  }
  return u.prototype.notifyNext = function(c, l, v, p, _) {
    this.destination.next(c), this.removeSubscription(_), this.tryComplete();
  }, u.prototype.notifyError = function(c, l) {
    this._error(c);
  }, u.prototype.notifyComplete = function(c) {
    var l = this.removeSubscription(c);
    l && this.destination.next(l), this.tryComplete();
  }, u.prototype._next = function(c) {
    var l = this.index++;
    try {
      var v = this.delayDurationSelector(c, l);
      v && this.tryDelay(v, c);
    } catch (p) {
      this.destination.error(p);
    }
  }, u.prototype._complete = function() {
    this.completed = !0, this.tryComplete(), this.unsubscribe();
  }, u.prototype.removeSubscription = function(c) {
    c.unsubscribe();
    var l = this.delayNotifierSubscriptions.indexOf(c);
    return l !== -1 && this.delayNotifierSubscriptions.splice(l, 1), c.outerValue;
  }, u.prototype.tryDelay = function(c, l) {
    var v = subscribeToResult(this, c, l);
    if (v && !v.closed) {
      var p = this.destination;
      p.add(v), this.delayNotifierSubscriptions.push(v);
    }
  }, u.prototype.tryComplete = function() {
    this.completed && this.delayNotifierSubscriptions.length === 0 && this.destination.complete();
  }, u;
}(OuterSubscriber), SubscriptionDelayObservable = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this) || this;
    return v.source = c, v.subscriptionDelay = l, v;
  }
  return u.prototype._subscribe = function(c) {
    this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(c, this.source));
  }, u;
}(Observable), SubscriptionDelaySubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this) || this;
    return v.parent = c, v.source = l, v.sourceSubscribed = !1, v;
  }
  return u.prototype._next = function(c) {
    this.subscribeToSource();
  }, u.prototype._error = function(c) {
    this.unsubscribe(), this.parent.error(c);
  }, u.prototype._complete = function() {
    this.unsubscribe(), this.subscribeToSource();
  }, u.prototype.subscribeToSource = function() {
    this.sourceSubscribed || (this.sourceSubscribed = !0, this.unsubscribe(), this.source.subscribe(this.parent));
  }, u;
}(Subscriber);
function dematerialize() {
  return function(u) {
    return u.lift(new DeMaterializeOperator());
  };
}
var DeMaterializeOperator = /* @__PURE__ */ function() {
  function a() {
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new DeMaterializeSubscriber(u));
  }, a;
}(), DeMaterializeSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c) {
    return a.call(this, c) || this;
  }
  return u.prototype._next = function(c) {
    c.observe(this.destination);
  }, u;
}(Subscriber);
function distinct(a, u) {
  return function(c) {
    return c.lift(new DistinctOperator(a, u));
  };
}
var DistinctOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.keySelector = u, this.flushes = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new DistinctSubscriber(u, this.keySelector, this.flushes));
  }, a;
}(), DistinctSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.keySelector = l, p.values = /* @__PURE__ */ new Set(), v && p.add(innerSubscribe(v, new SimpleInnerSubscriber(p))), p;
  }
  return u.prototype.notifyNext = function() {
    this.values.clear();
  }, u.prototype.notifyError = function(c) {
    this._error(c);
  }, u.prototype._next = function(c) {
    this.keySelector ? this._useKeySelector(c) : this._finalizeNext(c, c);
  }, u.prototype._useKeySelector = function(c) {
    var l, v = this.destination;
    try {
      l = this.keySelector(c);
    } catch (p) {
      v.error(p);
      return;
    }
    this._finalizeNext(l, c);
  }, u.prototype._finalizeNext = function(c, l) {
    var v = this.values;
    v.has(c) || (v.add(c), this.destination.next(l));
  }, u;
}(SimpleOuterSubscriber);
function distinctUntilChanged(a, u) {
  return function(c) {
    return c.lift(new DistinctUntilChangedOperator(a, u));
  };
}
var DistinctUntilChangedOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.compare = u, this.keySelector = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new DistinctUntilChangedSubscriber(u, this.compare, this.keySelector));
  }, a;
}(), DistinctUntilChangedSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.keySelector = v, p.hasKey = !1, typeof l == "function" && (p.compare = l), p;
  }
  return u.prototype.compare = function(c, l) {
    return c === l;
  }, u.prototype._next = function(c) {
    var l;
    try {
      var v = this.keySelector;
      l = v ? v(c) : c;
    } catch (k) {
      return this.destination.error(k);
    }
    var p = !1;
    if (this.hasKey)
      try {
        var _ = this.compare;
        p = _(this.key, l);
      } catch (k) {
        return this.destination.error(k);
      }
    else
      this.hasKey = !0;
    p || (this.key = l, this.destination.next(c));
  }, u;
}(Subscriber);
function distinctUntilKeyChanged(a, u) {
  return distinctUntilChanged(function(c, l) {
    return u ? u(c[a], l[a]) : c[a] === l[a];
  });
}
var ArgumentOutOfRangeErrorImpl = /* @__PURE__ */ function() {
  function a() {
    return Error.call(this), this.message = "argument out of range", this.name = "ArgumentOutOfRangeError", this;
  }
  return a.prototype = /* @__PURE__ */ Object.create(Error.prototype), a;
}(), ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl;
function filter(a, u) {
  return function(l) {
    return l.lift(new FilterOperator(a, u));
  };
}
var FilterOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.predicate = u, this.thisArg = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new FilterSubscriber(u, this.predicate, this.thisArg));
  }, a;
}(), FilterSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.predicate = l, p.thisArg = v, p.count = 0, p;
  }
  return u.prototype._next = function(c) {
    var l;
    try {
      l = this.predicate.call(this.thisArg, c, this.count++);
    } catch (v) {
      this.destination.error(v);
      return;
    }
    l && this.destination.next(c);
  }, u;
}(Subscriber), EmptyErrorImpl = /* @__PURE__ */ function() {
  function a() {
    return Error.call(this), this.message = "no elements in sequence", this.name = "EmptyError", this;
  }
  return a.prototype = /* @__PURE__ */ Object.create(Error.prototype), a;
}(), EmptyError = EmptyErrorImpl;
function throwIfEmpty(a) {
  return a === void 0 && (a = defaultErrorFactory), function(u) {
    return u.lift(new ThrowIfEmptyOperator(a));
  };
}
var ThrowIfEmptyOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.errorFactory = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new ThrowIfEmptySubscriber(u, this.errorFactory));
  }, a;
}(), ThrowIfEmptySubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.errorFactory = l, v.hasValue = !1, v;
  }
  return u.prototype._next = function(c) {
    this.hasValue = !0, this.destination.next(c);
  }, u.prototype._complete = function() {
    if (this.hasValue)
      return this.destination.complete();
    var c = void 0;
    try {
      c = this.errorFactory();
    } catch (l) {
      c = l;
    }
    this.destination.error(c);
  }, u;
}(Subscriber);
function defaultErrorFactory() {
  return new EmptyError();
}
function take(a) {
  return function(u) {
    return a === 0 ? empty$2() : u.lift(new TakeOperator(a));
  };
}
var TakeOperator = /* @__PURE__ */ function() {
  function a(u) {
    if (this.total = u, this.total < 0)
      throw new ArgumentOutOfRangeError();
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new TakeSubscriber(u, this.total));
  }, a;
}(), TakeSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.total = l, v.count = 0, v;
  }
  return u.prototype._next = function(c) {
    var l = this.total, v = ++this.count;
    v <= l && (this.destination.next(c), v === l && (this.destination.complete(), this.unsubscribe()));
  }, u;
}(Subscriber);
function elementAt(a, u) {
  if (a < 0)
    throw new ArgumentOutOfRangeError();
  var c = arguments.length >= 2;
  return function(l) {
    return l.pipe(filter(function(v, p) {
      return p === a;
    }), take(1), c ? defaultIfEmpty(u) : throwIfEmpty(function() {
      return new ArgumentOutOfRangeError();
    }));
  };
}
function endWith() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  return function(c) {
    return concat$1(c, of$1.apply(void 0, a));
  };
}
function every$1(a, u) {
  return function(c) {
    return c.lift(new EveryOperator(a, u, c));
  };
}
var EveryOperator = /* @__PURE__ */ function() {
  function a(u, c, l) {
    this.predicate = u, this.thisArg = c, this.source = l;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new EverySubscriber(u, this.predicate, this.thisArg, this.source));
  }, a;
}(), EverySubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v, p) {
    var _ = a.call(this, c) || this;
    return _.predicate = l, _.thisArg = v, _.source = p, _.index = 0, _.thisArg = v || _, _;
  }
  return u.prototype.notifyComplete = function(c) {
    this.destination.next(c), this.destination.complete();
  }, u.prototype._next = function(c) {
    var l = !1;
    try {
      l = this.predicate.call(this.thisArg, c, this.index++, this.source);
    } catch (v) {
      this.destination.error(v);
      return;
    }
    l || this.notifyComplete(!1);
  }, u.prototype._complete = function() {
    this.notifyComplete(!0);
  }, u;
}(Subscriber);
function exhaust() {
  return function(a) {
    return a.lift(new SwitchFirstOperator());
  };
}
var SwitchFirstOperator = /* @__PURE__ */ function() {
  function a() {
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new SwitchFirstSubscriber(u));
  }, a;
}(), SwitchFirstSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c) {
    var l = a.call(this, c) || this;
    return l.hasCompleted = !1, l.hasSubscription = !1, l;
  }
  return u.prototype._next = function(c) {
    this.hasSubscription || (this.hasSubscription = !0, this.add(innerSubscribe(c, new SimpleInnerSubscriber(this))));
  }, u.prototype._complete = function() {
    this.hasCompleted = !0, this.hasSubscription || this.destination.complete();
  }, u.prototype.notifyComplete = function() {
    this.hasSubscription = !1, this.hasCompleted && this.destination.complete();
  }, u;
}(SimpleOuterSubscriber);
function exhaustMap(a, u) {
  return u ? function(c) {
    return c.pipe(exhaustMap(function(l, v) {
      return from(a(l, v)).pipe(map(function(p, _) {
        return u(l, p, v, _);
      }));
    }));
  } : function(c) {
    return c.lift(new ExhaustMapOperator(a));
  };
}
var ExhaustMapOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.project = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new ExhaustMapSubscriber(u, this.project));
  }, a;
}(), ExhaustMapSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.project = l, v.hasSubscription = !1, v.hasCompleted = !1, v.index = 0, v;
  }
  return u.prototype._next = function(c) {
    this.hasSubscription || this.tryNext(c);
  }, u.prototype.tryNext = function(c) {
    var l, v = this.index++;
    try {
      l = this.project(c, v);
    } catch (p) {
      this.destination.error(p);
      return;
    }
    this.hasSubscription = !0, this._innerSub(l);
  }, u.prototype._innerSub = function(c) {
    var l = new SimpleInnerSubscriber(this), v = this.destination;
    v.add(l);
    var p = innerSubscribe(c, l);
    p !== l && v.add(p);
  }, u.prototype._complete = function() {
    this.hasCompleted = !0, this.hasSubscription || this.destination.complete(), this.unsubscribe();
  }, u.prototype.notifyNext = function(c) {
    this.destination.next(c);
  }, u.prototype.notifyError = function(c) {
    this.destination.error(c);
  }, u.prototype.notifyComplete = function() {
    this.hasSubscription = !1, this.hasCompleted && this.destination.complete();
  }, u;
}(SimpleOuterSubscriber);
function expand(a, u, c) {
  return u === void 0 && (u = Number.POSITIVE_INFINITY), u = (u || 0) < 1 ? Number.POSITIVE_INFINITY : u, function(l) {
    return l.lift(new ExpandOperator(a, u, c));
  };
}
var ExpandOperator = /* @__PURE__ */ function() {
  function a(u, c, l) {
    this.project = u, this.concurrent = c, this.scheduler = l;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new ExpandSubscriber(u, this.project, this.concurrent, this.scheduler));
  }, a;
}(), ExpandSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v, p) {
    var _ = a.call(this, c) || this;
    return _.project = l, _.concurrent = v, _.scheduler = p, _.index = 0, _.active = 0, _.hasCompleted = !1, v < Number.POSITIVE_INFINITY && (_.buffer = []), _;
  }
  return u.dispatch = function(c) {
    var l = c.subscriber, v = c.result, p = c.value, _ = c.index;
    l.subscribeToProjection(v, p, _);
  }, u.prototype._next = function(c) {
    var l = this.destination;
    if (l.closed) {
      this._complete();
      return;
    }
    var v = this.index++;
    if (this.active < this.concurrent) {
      l.next(c);
      try {
        var p = this.project, _ = p(c, v);
        if (!this.scheduler)
          this.subscribeToProjection(_, c, v);
        else {
          var k = { subscriber: this, result: _, value: c, index: v }, O = this.destination;
          O.add(this.scheduler.schedule(u.dispatch, 0, k));
        }
      } catch (D) {
        l.error(D);
      }
    } else
      this.buffer.push(c);
  }, u.prototype.subscribeToProjection = function(c, l, v) {
    this.active++;
    var p = this.destination;
    p.add(innerSubscribe(c, new SimpleInnerSubscriber(this)));
  }, u.prototype._complete = function() {
    this.hasCompleted = !0, this.hasCompleted && this.active === 0 && this.destination.complete(), this.unsubscribe();
  }, u.prototype.notifyNext = function(c) {
    this._next(c);
  }, u.prototype.notifyComplete = function() {
    var c = this.buffer;
    this.active--, c && c.length > 0 && this._next(c.shift()), this.hasCompleted && this.active === 0 && this.destination.complete();
  }, u;
}(SimpleOuterSubscriber);
function finalize(a) {
  return function(u) {
    return u.lift(new FinallyOperator(a));
  };
}
var FinallyOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.callback = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new FinallySubscriber(u, this.callback));
  }, a;
}(), FinallySubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.add(new Subscription(l)), v;
  }
  return u;
}(Subscriber);
function find$2(a, u) {
  if (typeof a != "function")
    throw new TypeError("predicate is not a function");
  return function(c) {
    return c.lift(new FindValueOperator(a, c, !1, u));
  };
}
var FindValueOperator = /* @__PURE__ */ function() {
  function a(u, c, l, v) {
    this.predicate = u, this.source = c, this.yieldIndex = l, this.thisArg = v;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new FindValueSubscriber(u, this.predicate, this.source, this.yieldIndex, this.thisArg));
  }, a;
}(), FindValueSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v, p, _) {
    var k = a.call(this, c) || this;
    return k.predicate = l, k.source = v, k.yieldIndex = p, k.thisArg = _, k.index = 0, k;
  }
  return u.prototype.notifyComplete = function(c) {
    var l = this.destination;
    l.next(c), l.complete(), this.unsubscribe();
  }, u.prototype._next = function(c) {
    var l = this, v = l.predicate, p = l.thisArg, _ = this.index++;
    try {
      var k = v.call(p || this, c, _, this.source);
      k && this.notifyComplete(this.yieldIndex ? _ : c);
    } catch (O) {
      this.destination.error(O);
    }
  }, u.prototype._complete = function() {
    this.notifyComplete(this.yieldIndex ? -1 : void 0);
  }, u;
}(Subscriber);
function findIndex(a, u) {
  return function(c) {
    return c.lift(new FindValueOperator(a, c, !0, u));
  };
}
function first(a, u) {
  var c = arguments.length >= 2;
  return function(l) {
    return l.pipe(a ? filter(function(v, p) {
      return a(v, p, l);
    }) : identity$1, take(1), c ? defaultIfEmpty(u) : throwIfEmpty(function() {
      return new EmptyError();
    }));
  };
}
var ObjectUnsubscribedErrorImpl = /* @__PURE__ */ function() {
  function a() {
    return Error.call(this), this.message = "object unsubscribed", this.name = "ObjectUnsubscribedError", this;
  }
  return a.prototype = /* @__PURE__ */ Object.create(Error.prototype), a;
}(), ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl, SubjectSubscription = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this) || this;
    return v.subject = c, v.subscriber = l, v.closed = !1, v;
  }
  return u.prototype.unsubscribe = function() {
    if (!this.closed) {
      this.closed = !0;
      var c = this.subject, l = c.observers;
      if (this.subject = null, !(!l || l.length === 0 || c.isStopped || c.closed)) {
        var v = l.indexOf(this.subscriber);
        v !== -1 && l.splice(v, 1);
      }
    }
  }, u;
}(Subscription), SubjectSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c) {
    var l = a.call(this, c) || this;
    return l.destination = c, l;
  }
  return u;
}(Subscriber), Subject = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u() {
    var c = a.call(this) || this;
    return c.observers = [], c.closed = !1, c.isStopped = !1, c.hasError = !1, c.thrownError = null, c;
  }
  return u.prototype[rxSubscriber] = function() {
    return new SubjectSubscriber(this);
  }, u.prototype.lift = function(c) {
    var l = new AnonymousSubject(this, this);
    return l.operator = c, l;
  }, u.prototype.next = function(c) {
    if (this.closed)
      throw new ObjectUnsubscribedError();
    if (!this.isStopped)
      for (var l = this.observers, v = l.length, p = l.slice(), _ = 0; _ < v; _++)
        p[_].next(c);
  }, u.prototype.error = function(c) {
    if (this.closed)
      throw new ObjectUnsubscribedError();
    this.hasError = !0, this.thrownError = c, this.isStopped = !0;
    for (var l = this.observers, v = l.length, p = l.slice(), _ = 0; _ < v; _++)
      p[_].error(c);
    this.observers.length = 0;
  }, u.prototype.complete = function() {
    if (this.closed)
      throw new ObjectUnsubscribedError();
    this.isStopped = !0;
    for (var c = this.observers, l = c.length, v = c.slice(), p = 0; p < l; p++)
      v[p].complete();
    this.observers.length = 0;
  }, u.prototype.unsubscribe = function() {
    this.isStopped = !0, this.closed = !0, this.observers = null;
  }, u.prototype._trySubscribe = function(c) {
    if (this.closed)
      throw new ObjectUnsubscribedError();
    return a.prototype._trySubscribe.call(this, c);
  }, u.prototype._subscribe = function(c) {
    if (this.closed)
      throw new ObjectUnsubscribedError();
    return this.hasError ? (c.error(this.thrownError), Subscription.EMPTY) : this.isStopped ? (c.complete(), Subscription.EMPTY) : (this.observers.push(c), new SubjectSubscription(this, c));
  }, u.prototype.asObservable = function() {
    var c = new Observable();
    return c.source = this, c;
  }, u.create = function(c, l) {
    return new AnonymousSubject(c, l);
  }, u;
}(Observable), AnonymousSubject = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this) || this;
    return v.destination = c, v.source = l, v;
  }
  return u.prototype.next = function(c) {
    var l = this.destination;
    l && l.next && l.next(c);
  }, u.prototype.error = function(c) {
    var l = this.destination;
    l && l.error && this.destination.error(c);
  }, u.prototype.complete = function() {
    var c = this.destination;
    c && c.complete && this.destination.complete();
  }, u.prototype._subscribe = function(c) {
    var l = this.source;
    return l ? this.source.subscribe(c) : Subscription.EMPTY;
  }, u;
}(Subject);
function groupBy(a, u, c, l) {
  return function(v) {
    return v.lift(new GroupByOperator(a, u, c, l));
  };
}
var GroupByOperator = /* @__PURE__ */ function() {
  function a(u, c, l, v) {
    this.keySelector = u, this.elementSelector = c, this.durationSelector = l, this.subjectSelector = v;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new GroupBySubscriber(u, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));
  }, a;
}(), GroupBySubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v, p, _) {
    var k = a.call(this, c) || this;
    return k.keySelector = l, k.elementSelector = v, k.durationSelector = p, k.subjectSelector = _, k.groups = null, k.attemptedToUnsubscribe = !1, k.count = 0, k;
  }
  return u.prototype._next = function(c) {
    var l;
    try {
      l = this.keySelector(c);
    } catch (v) {
      this.error(v);
      return;
    }
    this._group(c, l);
  }, u.prototype._group = function(c, l) {
    var v = this.groups;
    v || (v = this.groups = /* @__PURE__ */ new Map());
    var p = v.get(l), _;
    if (this.elementSelector)
      try {
        _ = this.elementSelector(c);
      } catch (D) {
        this.error(D);
      }
    else
      _ = c;
    if (!p) {
      p = this.subjectSelector ? this.subjectSelector() : new Subject(), v.set(l, p);
      var k = new GroupedObservable(l, p, this);
      if (this.destination.next(k), this.durationSelector) {
        var O = void 0;
        try {
          O = this.durationSelector(new GroupedObservable(l, p));
        } catch (D) {
          this.error(D);
          return;
        }
        this.add(O.subscribe(new GroupDurationSubscriber(l, p, this)));
      }
    }
    p.closed || p.next(_);
  }, u.prototype._error = function(c) {
    var l = this.groups;
    l && (l.forEach(function(v, p) {
      v.error(c);
    }), l.clear()), this.destination.error(c);
  }, u.prototype._complete = function() {
    var c = this.groups;
    c && (c.forEach(function(l, v) {
      l.complete();
    }), c.clear()), this.destination.complete();
  }, u.prototype.removeGroup = function(c) {
    this.groups.delete(c);
  }, u.prototype.unsubscribe = function() {
    this.closed || (this.attemptedToUnsubscribe = !0, this.count === 0 && a.prototype.unsubscribe.call(this));
  }, u;
}(Subscriber), GroupDurationSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, l) || this;
    return p.key = c, p.group = l, p.parent = v, p;
  }
  return u.prototype._next = function(c) {
    this.complete();
  }, u.prototype._unsubscribe = function() {
    var c = this, l = c.parent, v = c.key;
    this.key = this.parent = null, l && l.removeGroup(v);
  }, u;
}(Subscriber), GroupedObservable = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this) || this;
    return p.key = c, p.groupSubject = l, p.refCountSubscription = v, p;
  }
  return u.prototype._subscribe = function(c) {
    var l = new Subscription(), v = this, p = v.refCountSubscription, _ = v.groupSubject;
    return p && !p.closed && l.add(new InnerRefCountSubscription(p)), l.add(_.subscribe(c)), l;
  }, u;
}(Observable), InnerRefCountSubscription = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c) {
    var l = a.call(this) || this;
    return l.parent = c, c.count++, l;
  }
  return u.prototype.unsubscribe = function() {
    var c = this.parent;
    !c.closed && !this.closed && (a.prototype.unsubscribe.call(this), c.count -= 1, c.count === 0 && c.attemptedToUnsubscribe && c.unsubscribe());
  }, u;
}(Subscription);
function ignoreElements() {
  return function(u) {
    return u.lift(new IgnoreElementsOperator());
  };
}
var IgnoreElementsOperator = /* @__PURE__ */ function() {
  function a() {
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new IgnoreElementsSubscriber(u));
  }, a;
}(), IgnoreElementsSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u() {
    return a !== null && a.apply(this, arguments) || this;
  }
  return u.prototype._next = function(c) {
  }, u;
}(Subscriber);
function isEmpty() {
  return function(a) {
    return a.lift(new IsEmptyOperator());
  };
}
var IsEmptyOperator = /* @__PURE__ */ function() {
  function a() {
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new IsEmptySubscriber(u));
  }, a;
}(), IsEmptySubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c) {
    return a.call(this, c) || this;
  }
  return u.prototype.notifyComplete = function(c) {
    var l = this.destination;
    l.next(c), l.complete();
  }, u.prototype._next = function(c) {
    this.notifyComplete(!1);
  }, u.prototype._complete = function() {
    this.notifyComplete(!0);
  }, u;
}(Subscriber);
function takeLast(a) {
  return function(c) {
    return a === 0 ? empty$2() : c.lift(new TakeLastOperator(a));
  };
}
var TakeLastOperator = /* @__PURE__ */ function() {
  function a(u) {
    if (this.total = u, this.total < 0)
      throw new ArgumentOutOfRangeError();
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new TakeLastSubscriber(u, this.total));
  }, a;
}(), TakeLastSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.total = l, v.ring = new Array(), v.count = 0, v;
  }
  return u.prototype._next = function(c) {
    var l = this.ring, v = this.total, p = this.count++;
    if (l.length < v)
      l.push(c);
    else {
      var _ = p % v;
      l[_] = c;
    }
  }, u.prototype._complete = function() {
    var c = this.destination, l = this.count;
    if (l > 0)
      for (var v = this.count >= this.total ? this.total : this.count, p = this.ring, _ = 0; _ < v; _++) {
        var k = l++ % v;
        c.next(p[k]);
      }
    c.complete();
  }, u;
}(Subscriber);
function last$1(a, u) {
  var c = arguments.length >= 2;
  return function(l) {
    return l.pipe(a ? filter(function(v, p) {
      return a(v, p, l);
    }) : identity$1, takeLast(1), c ? defaultIfEmpty(u) : throwIfEmpty(function() {
      return new EmptyError();
    }));
  };
}
function mapTo(a) {
  return function(u) {
    return u.lift(new MapToOperator(a));
  };
}
var MapToOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.value = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new MapToSubscriber(u, this.value));
  }, a;
}(), MapToSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.value = l, v;
  }
  return u.prototype._next = function(c) {
    this.destination.next(this.value);
  }, u;
}(Subscriber);
function materialize() {
  return function(u) {
    return u.lift(new MaterializeOperator());
  };
}
var MaterializeOperator = /* @__PURE__ */ function() {
  function a() {
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new MaterializeSubscriber(u));
  }, a;
}(), MaterializeSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c) {
    return a.call(this, c) || this;
  }
  return u.prototype._next = function(c) {
    this.destination.next(Notification.createNext(c));
  }, u.prototype._error = function(c) {
    var l = this.destination;
    l.next(Notification.createError(c)), l.complete();
  }, u.prototype._complete = function() {
    var c = this.destination;
    c.next(Notification.createComplete()), c.complete();
  }, u;
}(Subscriber);
function scan(a, u) {
  var c = !1;
  return arguments.length >= 2 && (c = !0), function(v) {
    return v.lift(new ScanOperator(a, u, c));
  };
}
var ScanOperator = /* @__PURE__ */ function() {
  function a(u, c, l) {
    l === void 0 && (l = !1), this.accumulator = u, this.seed = c, this.hasSeed = l;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new ScanSubscriber(u, this.accumulator, this.seed, this.hasSeed));
  }, a;
}(), ScanSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v, p) {
    var _ = a.call(this, c) || this;
    return _.accumulator = l, _._seed = v, _.hasSeed = p, _.index = 0, _;
  }
  return Object.defineProperty(u.prototype, "seed", {
    get: function() {
      return this._seed;
    },
    set: function(c) {
      this.hasSeed = !0, this._seed = c;
    },
    enumerable: !0,
    configurable: !0
  }), u.prototype._next = function(c) {
    if (!this.hasSeed)
      this.seed = c, this.destination.next(c);
    else
      return this._tryNext(c);
  }, u.prototype._tryNext = function(c) {
    var l = this.index++, v;
    try {
      v = this.accumulator(this.seed, c, l);
    } catch (p) {
      this.destination.error(p);
    }
    this.seed = v, this.destination.next(v);
  }, u;
}(Subscriber);
function reduce(a, u) {
  return arguments.length >= 2 ? function(l) {
    return pipe$2(scan(a, u), takeLast(1), defaultIfEmpty(u))(l);
  } : function(l) {
    return pipe$2(scan(function(v, p, _) {
      return a(v, p, _ + 1);
    }), takeLast(1))(l);
  };
}
function max$1(a) {
  var u = typeof a == "function" ? function(c, l) {
    return a(c, l) > 0 ? c : l;
  } : function(c, l) {
    return c > l ? c : l;
  };
  return reduce(u);
}
function merge$2() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  var c = Number.POSITIVE_INFINITY, l = null, v = a[a.length - 1];
  return isScheduler(v) ? (l = a.pop(), a.length > 1 && typeof a[a.length - 1] == "number" && (c = a.pop())) : typeof v == "number" && (c = a.pop()), l === null && a.length === 1 && a[0] instanceof Observable ? a[0] : mergeAll(c)(fromArray$1(a, l));
}
function merge$1() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  return function(c) {
    return c.lift.call(merge$2.apply(void 0, [c].concat(a)));
  };
}
function mergeMapTo(a, u, c) {
  return c === void 0 && (c = Number.POSITIVE_INFINITY), typeof u == "function" ? mergeMap(function() {
    return a;
  }, u, c) : (typeof u == "number" && (c = u), mergeMap(function() {
    return a;
  }, c));
}
function mergeScan(a, u, c) {
  return c === void 0 && (c = Number.POSITIVE_INFINITY), function(l) {
    return l.lift(new MergeScanOperator(a, u, c));
  };
}
var MergeScanOperator = /* @__PURE__ */ function() {
  function a(u, c, l) {
    this.accumulator = u, this.seed = c, this.concurrent = l;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new MergeScanSubscriber(u, this.accumulator, this.seed, this.concurrent));
  }, a;
}(), MergeScanSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v, p) {
    var _ = a.call(this, c) || this;
    return _.accumulator = l, _.acc = v, _.concurrent = p, _.hasValue = !1, _.hasCompleted = !1, _.buffer = [], _.active = 0, _.index = 0, _;
  }
  return u.prototype._next = function(c) {
    if (this.active < this.concurrent) {
      var l = this.index++, v = this.destination, p = void 0;
      try {
        var _ = this.accumulator;
        p = _(this.acc, c, l);
      } catch (k) {
        return v.error(k);
      }
      this.active++, this._innerSub(p);
    } else
      this.buffer.push(c);
  }, u.prototype._innerSub = function(c) {
    var l = new SimpleInnerSubscriber(this), v = this.destination;
    v.add(l);
    var p = innerSubscribe(c, l);
    p !== l && v.add(p);
  }, u.prototype._complete = function() {
    this.hasCompleted = !0, this.active === 0 && this.buffer.length === 0 && (this.hasValue === !1 && this.destination.next(this.acc), this.destination.complete()), this.unsubscribe();
  }, u.prototype.notifyNext = function(c) {
    var l = this.destination;
    this.acc = c, this.hasValue = !0, l.next(c);
  }, u.prototype.notifyComplete = function() {
    var c = this.buffer;
    this.active--, c.length > 0 ? this._next(c.shift()) : this.active === 0 && this.hasCompleted && (this.hasValue === !1 && this.destination.next(this.acc), this.destination.complete());
  }, u;
}(SimpleOuterSubscriber);
function min(a) {
  var u = typeof a == "function" ? function(c, l) {
    return a(c, l) < 0 ? c : l;
  } : function(c, l) {
    return c < l ? c : l;
  };
  return reduce(u);
}
function refCount() {
  return function(u) {
    return u.lift(new RefCountOperator(u));
  };
}
var RefCountOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.connectable = u;
  }
  return a.prototype.call = function(u, c) {
    var l = this.connectable;
    l._refCount++;
    var v = new RefCountSubscriber(u, l), p = c.subscribe(v);
    return v.closed || (v.connection = l.connect()), p;
  }, a;
}(), RefCountSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.connectable = l, v;
  }
  return u.prototype._unsubscribe = function() {
    var c = this.connectable;
    if (!c) {
      this.connection = null;
      return;
    }
    this.connectable = null;
    var l = c._refCount;
    if (l <= 0) {
      this.connection = null;
      return;
    }
    if (c._refCount = l - 1, l > 1) {
      this.connection = null;
      return;
    }
    var v = this.connection, p = c._connection;
    this.connection = null, p && (!v || p === v) && p.unsubscribe();
  }, u;
}(Subscriber), ConnectableObservable = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this) || this;
    return v.source = c, v.subjectFactory = l, v._refCount = 0, v._isComplete = !1, v;
  }
  return u.prototype._subscribe = function(c) {
    return this.getSubject().subscribe(c);
  }, u.prototype.getSubject = function() {
    var c = this._subject;
    return (!c || c.isStopped) && (this._subject = this.subjectFactory()), this._subject;
  }, u.prototype.connect = function() {
    var c = this._connection;
    return c || (this._isComplete = !1, c = this._connection = new Subscription(), c.add(this.source.subscribe(new ConnectableSubscriber(this.getSubject(), this))), c.closed && (this._connection = null, c = Subscription.EMPTY)), c;
  }, u.prototype.refCount = function() {
    return refCount()(this);
  }, u;
}(Observable), connectableObservableDescriptor = /* @__PURE__ */ function() {
  var a = ConnectableObservable.prototype;
  return {
    operator: { value: null },
    _refCount: { value: 0, writable: !0 },
    _subject: { value: null, writable: !0 },
    _connection: { value: null, writable: !0 },
    _subscribe: { value: a._subscribe },
    _isComplete: { value: a._isComplete, writable: !0 },
    getSubject: { value: a.getSubject },
    connect: { value: a.connect },
    refCount: { value: a.refCount }
  };
}(), ConnectableSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.connectable = l, v;
  }
  return u.prototype._error = function(c) {
    this._unsubscribe(), a.prototype._error.call(this, c);
  }, u.prototype._complete = function() {
    this.connectable._isComplete = !0, this._unsubscribe(), a.prototype._complete.call(this);
  }, u.prototype._unsubscribe = function() {
    var c = this.connectable;
    if (c) {
      this.connectable = null;
      var l = c._connection;
      c._refCount = 0, c._subject = null, c._connection = null, l && l.unsubscribe();
    }
  }, u;
}(SubjectSubscriber);
function multicast(a, u) {
  return function(l) {
    var v;
    if (typeof a == "function" ? v = a : v = function() {
      return a;
    }, typeof u == "function")
      return l.lift(new MulticastOperator(v, u));
    var p = Object.create(l, connectableObservableDescriptor);
    return p.source = l, p.subjectFactory = v, p;
  };
}
var MulticastOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.subjectFactory = u, this.selector = c;
  }
  return a.prototype.call = function(u, c) {
    var l = this.selector, v = this.subjectFactory(), p = l(v).subscribe(u);
    return p.add(c.subscribe(v)), p;
  }, a;
}();
function observeOn(a, u) {
  return u === void 0 && (u = 0), function(l) {
    return l.lift(new ObserveOnOperator(a, u));
  };
}
var ObserveOnOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    c === void 0 && (c = 0), this.scheduler = u, this.delay = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new ObserveOnSubscriber(u, this.scheduler, this.delay));
  }, a;
}(), ObserveOnSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    v === void 0 && (v = 0);
    var p = a.call(this, c) || this;
    return p.scheduler = l, p.delay = v, p;
  }
  return u.dispatch = function(c) {
    var l = c.notification, v = c.destination;
    l.observe(v), this.unsubscribe();
  }, u.prototype.scheduleMessage = function(c) {
    var l = this.destination;
    l.add(this.scheduler.schedule(u.dispatch, this.delay, new ObserveOnMessage(c, this.destination)));
  }, u.prototype._next = function(c) {
    this.scheduleMessage(Notification.createNext(c));
  }, u.prototype._error = function(c) {
    this.scheduleMessage(Notification.createError(c)), this.unsubscribe();
  }, u.prototype._complete = function() {
    this.scheduleMessage(Notification.createComplete()), this.unsubscribe();
  }, u;
}(Subscriber), ObserveOnMessage = /* @__PURE__ */ function() {
  function a(u, c) {
    this.notification = u, this.destination = c;
  }
  return a;
}();
function onErrorResumeNext() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  return a.length === 1 && isArray$5(a[0]) && (a = a[0]), function(c) {
    return c.lift(new OnErrorResumeNextOperator(a));
  };
}
var OnErrorResumeNextOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.nextSources = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new OnErrorResumeNextSubscriber(u, this.nextSources));
  }, a;
}(), OnErrorResumeNextSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.destination = c, v.nextSources = l, v;
  }
  return u.prototype.notifyError = function() {
    this.subscribeToNextSource();
  }, u.prototype.notifyComplete = function() {
    this.subscribeToNextSource();
  }, u.prototype._error = function(c) {
    this.subscribeToNextSource(), this.unsubscribe();
  }, u.prototype._complete = function() {
    this.subscribeToNextSource(), this.unsubscribe();
  }, u.prototype.subscribeToNextSource = function() {
    var c = this.nextSources.shift();
    if (c) {
      var l = new SimpleInnerSubscriber(this), v = this.destination;
      v.add(l);
      var p = innerSubscribe(c, l);
      p !== l && v.add(p);
    } else
      this.destination.complete();
  }, u;
}(SimpleOuterSubscriber);
function pairwise() {
  return function(a) {
    return a.lift(new PairwiseOperator());
  };
}
var PairwiseOperator = /* @__PURE__ */ function() {
  function a() {
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new PairwiseSubscriber(u));
  }, a;
}(), PairwiseSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c) {
    var l = a.call(this, c) || this;
    return l.hasPrev = !1, l;
  }
  return u.prototype._next = function(c) {
    var l;
    this.hasPrev ? l = [this.prev, c] : this.hasPrev = !0, this.prev = c, l && this.destination.next(l);
  }, u;
}(Subscriber);
function not(a, u) {
  function c() {
    return !c.pred.apply(c.thisArg, arguments);
  }
  return c.pred = a, c.thisArg = u, c;
}
function partition(a, u) {
  return function(c) {
    return [
      filter(a, u)(c),
      filter(not(a, u))(c)
    ];
  };
}
function pluck() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  var c = a.length;
  if (c === 0)
    throw new Error("list of properties cannot be empty.");
  return function(l) {
    return map(plucker(a, c))(l);
  };
}
function plucker(a, u) {
  var c = function(l) {
    for (var v = l, p = 0; p < u; p++) {
      var _ = v != null ? v[a[p]] : void 0;
      if (_ !== void 0)
        v = _;
      else
        return;
    }
    return v;
  };
  return c;
}
function publish(a) {
  return a ? multicast(function() {
    return new Subject();
  }, a) : multicast(new Subject());
}
var BehaviorSubject = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c) {
    var l = a.call(this) || this;
    return l._value = c, l;
  }
  return Object.defineProperty(u.prototype, "value", {
    get: function() {
      return this.getValue();
    },
    enumerable: !0,
    configurable: !0
  }), u.prototype._subscribe = function(c) {
    var l = a.prototype._subscribe.call(this, c);
    return l && !l.closed && c.next(this._value), l;
  }, u.prototype.getValue = function() {
    if (this.hasError)
      throw this.thrownError;
    if (this.closed)
      throw new ObjectUnsubscribedError();
    return this._value;
  }, u.prototype.next = function(c) {
    a.prototype.next.call(this, this._value = c);
  }, u;
}(Subject);
function publishBehavior(a) {
  return function(u) {
    return multicast(new BehaviorSubject(a))(u);
  };
}
var AsyncSubject = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u() {
    var c = a !== null && a.apply(this, arguments) || this;
    return c.value = null, c.hasNext = !1, c.hasCompleted = !1, c;
  }
  return u.prototype._subscribe = function(c) {
    return this.hasError ? (c.error(this.thrownError), Subscription.EMPTY) : this.hasCompleted && this.hasNext ? (c.next(this.value), c.complete(), Subscription.EMPTY) : a.prototype._subscribe.call(this, c);
  }, u.prototype.next = function(c) {
    this.hasCompleted || (this.value = c, this.hasNext = !0);
  }, u.prototype.error = function(c) {
    this.hasCompleted || a.prototype.error.call(this, c);
  }, u.prototype.complete = function() {
    this.hasCompleted = !0, this.hasNext && a.prototype.next.call(this, this.value), a.prototype.complete.call(this);
  }, u;
}(Subject);
function publishLast() {
  return function(a) {
    return multicast(new AsyncSubject())(a);
  };
}
var QueueAction = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c, l) || this;
    return v.scheduler = c, v.work = l, v;
  }
  return u.prototype.schedule = function(c, l) {
    return l === void 0 && (l = 0), l > 0 ? a.prototype.schedule.call(this, c, l) : (this.delay = l, this.state = c, this.scheduler.flush(this), this);
  }, u.prototype.execute = function(c, l) {
    return l > 0 || this.closed ? a.prototype.execute.call(this, c, l) : this._execute(c, l);
  }, u.prototype.requestAsyncId = function(c, l, v) {
    return v === void 0 && (v = 0), v !== null && v > 0 || v === null && this.delay > 0 ? a.prototype.requestAsyncId.call(this, c, l, v) : c.flush(this);
  }, u;
}(AsyncAction), QueueScheduler = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u() {
    return a !== null && a.apply(this, arguments) || this;
  }
  return u;
}(AsyncScheduler), queueScheduler = /* @__PURE__ */ new QueueScheduler(QueueAction), queue$1 = queueScheduler, ReplaySubject = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    c === void 0 && (c = Number.POSITIVE_INFINITY), l === void 0 && (l = Number.POSITIVE_INFINITY);
    var p = a.call(this) || this;
    return p.scheduler = v, p._events = [], p._infiniteTimeWindow = !1, p._bufferSize = c < 1 ? 1 : c, p._windowTime = l < 1 ? 1 : l, l === Number.POSITIVE_INFINITY ? (p._infiniteTimeWindow = !0, p.next = p.nextInfiniteTimeWindow) : p.next = p.nextTimeWindow, p;
  }
  return u.prototype.nextInfiniteTimeWindow = function(c) {
    if (!this.isStopped) {
      var l = this._events;
      l.push(c), l.length > this._bufferSize && l.shift();
    }
    a.prototype.next.call(this, c);
  }, u.prototype.nextTimeWindow = function(c) {
    this.isStopped || (this._events.push(new ReplayEvent(this._getNow(), c)), this._trimBufferThenGetEvents()), a.prototype.next.call(this, c);
  }, u.prototype._subscribe = function(c) {
    var l = this._infiniteTimeWindow, v = l ? this._events : this._trimBufferThenGetEvents(), p = this.scheduler, _ = v.length, k;
    if (this.closed)
      throw new ObjectUnsubscribedError();
    if (this.isStopped || this.hasError ? k = Subscription.EMPTY : (this.observers.push(c), k = new SubjectSubscription(this, c)), p && c.add(c = new ObserveOnSubscriber(c, p)), l)
      for (var O = 0; O < _ && !c.closed; O++)
        c.next(v[O]);
    else
      for (var O = 0; O < _ && !c.closed; O++)
        c.next(v[O].value);
    return this.hasError ? c.error(this.thrownError) : this.isStopped && c.complete(), k;
  }, u.prototype._getNow = function() {
    return (this.scheduler || queue$1).now();
  }, u.prototype._trimBufferThenGetEvents = function() {
    for (var c = this._getNow(), l = this._bufferSize, v = this._windowTime, p = this._events, _ = p.length, k = 0; k < _ && !(c - p[k].time < v); )
      k++;
    return _ > l && (k = Math.max(k, _ - l)), k > 0 && p.splice(0, k), p;
  }, u;
}(Subject), ReplayEvent = /* @__PURE__ */ function() {
  function a(u, c) {
    this.time = u, this.value = c;
  }
  return a;
}();
function publishReplay(a, u, c, l) {
  c && typeof c != "function" && (l = c);
  var v = typeof c == "function" ? c : void 0, p = new ReplaySubject(a, u, l);
  return function(_) {
    return multicast(function() {
      return p;
    }, v)(_);
  };
}
function race$1() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  if (a.length === 1)
    if (isArray$5(a[0]))
      a = a[0];
    else
      return a[0];
  return fromArray$1(a, void 0).lift(new RaceOperator());
}
var RaceOperator = /* @__PURE__ */ function() {
  function a() {
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new RaceSubscriber(u));
  }, a;
}(), RaceSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c) {
    var l = a.call(this, c) || this;
    return l.hasFirst = !1, l.observables = [], l.subscriptions = [], l;
  }
  return u.prototype._next = function(c) {
    this.observables.push(c);
  }, u.prototype._complete = function() {
    var c = this.observables, l = c.length;
    if (l === 0)
      this.destination.complete();
    else {
      for (var v = 0; v < l && !this.hasFirst; v++) {
        var p = c[v], _ = subscribeToResult(this, p, void 0, v);
        this.subscriptions && this.subscriptions.push(_), this.add(_);
      }
      this.observables = null;
    }
  }, u.prototype.notifyNext = function(c, l, v) {
    if (!this.hasFirst) {
      this.hasFirst = !0;
      for (var p = 0; p < this.subscriptions.length; p++)
        if (p !== v) {
          var _ = this.subscriptions[p];
          _.unsubscribe(), this.remove(_);
        }
      this.subscriptions = null;
    }
    this.destination.next(l);
  }, u;
}(OuterSubscriber);
function race() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  return function(l) {
    return a.length === 1 && isArray$5(a[0]) && (a = a[0]), l.lift.call(race$1.apply(void 0, [l].concat(a)));
  };
}
function repeat(a) {
  return a === void 0 && (a = -1), function(u) {
    return a === 0 ? empty$2() : a < 0 ? u.lift(new RepeatOperator(-1, u)) : u.lift(new RepeatOperator(a - 1, u));
  };
}
var RepeatOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.count = u, this.source = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new RepeatSubscriber(u, this.count, this.source));
  }, a;
}(), RepeatSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.count = l, p.source = v, p;
  }
  return u.prototype.complete = function() {
    if (!this.isStopped) {
      var c = this, l = c.source, v = c.count;
      if (v === 0)
        return a.prototype.complete.call(this);
      v > -1 && (this.count = v - 1), l.subscribe(this._unsubscribeAndRecycle());
    }
  }, u;
}(Subscriber);
function repeatWhen(a) {
  return function(u) {
    return u.lift(new RepeatWhenOperator(a));
  };
}
var RepeatWhenOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.notifier = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new RepeatWhenSubscriber(u, this.notifier, c));
  }, a;
}(), RepeatWhenSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.notifier = l, p.source = v, p.sourceIsBeingSubscribedTo = !0, p;
  }
  return u.prototype.notifyNext = function() {
    this.sourceIsBeingSubscribedTo = !0, this.source.subscribe(this);
  }, u.prototype.notifyComplete = function() {
    if (this.sourceIsBeingSubscribedTo === !1)
      return a.prototype.complete.call(this);
  }, u.prototype.complete = function() {
    if (this.sourceIsBeingSubscribedTo = !1, !this.isStopped) {
      if (this.retries || this.subscribeToRetries(), !this.retriesSubscription || this.retriesSubscription.closed)
        return a.prototype.complete.call(this);
      this._unsubscribeAndRecycle(), this.notifications.next(void 0);
    }
  }, u.prototype._unsubscribe = function() {
    var c = this, l = c.notifications, v = c.retriesSubscription;
    l && (l.unsubscribe(), this.notifications = void 0), v && (v.unsubscribe(), this.retriesSubscription = void 0), this.retries = void 0;
  }, u.prototype._unsubscribeAndRecycle = function() {
    var c = this._unsubscribe;
    return this._unsubscribe = null, a.prototype._unsubscribeAndRecycle.call(this), this._unsubscribe = c, this;
  }, u.prototype.subscribeToRetries = function() {
    this.notifications = new Subject();
    var c;
    try {
      var l = this.notifier;
      c = l(this.notifications);
    } catch {
      return a.prototype.complete.call(this);
    }
    this.retries = c, this.retriesSubscription = innerSubscribe(c, new SimpleInnerSubscriber(this));
  }, u;
}(SimpleOuterSubscriber);
function retry(a) {
  return a === void 0 && (a = -1), function(u) {
    return u.lift(new RetryOperator(a, u));
  };
}
var RetryOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.count = u, this.source = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new RetrySubscriber(u, this.count, this.source));
  }, a;
}(), RetrySubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.count = l, p.source = v, p;
  }
  return u.prototype.error = function(c) {
    if (!this.isStopped) {
      var l = this, v = l.source, p = l.count;
      if (p === 0)
        return a.prototype.error.call(this, c);
      p > -1 && (this.count = p - 1), v.subscribe(this._unsubscribeAndRecycle());
    }
  }, u;
}(Subscriber);
function retryWhen(a) {
  return function(u) {
    return u.lift(new RetryWhenOperator(a, u));
  };
}
var RetryWhenOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.notifier = u, this.source = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new RetryWhenSubscriber(u, this.notifier, this.source));
  }, a;
}(), RetryWhenSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.notifier = l, p.source = v, p;
  }
  return u.prototype.error = function(c) {
    if (!this.isStopped) {
      var l = this.errors, v = this.retries, p = this.retriesSubscription;
      if (v)
        this.errors = void 0, this.retriesSubscription = void 0;
      else {
        l = new Subject();
        try {
          var _ = this.notifier;
          v = _(l);
        } catch (k) {
          return a.prototype.error.call(this, k);
        }
        p = innerSubscribe(v, new SimpleInnerSubscriber(this));
      }
      this._unsubscribeAndRecycle(), this.errors = l, this.retries = v, this.retriesSubscription = p, l.next(c);
    }
  }, u.prototype._unsubscribe = function() {
    var c = this, l = c.errors, v = c.retriesSubscription;
    l && (l.unsubscribe(), this.errors = void 0), v && (v.unsubscribe(), this.retriesSubscription = void 0), this.retries = void 0;
  }, u.prototype.notifyNext = function() {
    var c = this._unsubscribe;
    this._unsubscribe = null, this._unsubscribeAndRecycle(), this._unsubscribe = c, this.source.subscribe(this);
  }, u;
}(SimpleOuterSubscriber);
function sample(a) {
  return function(u) {
    return u.lift(new SampleOperator(a));
  };
}
var SampleOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.notifier = u;
  }
  return a.prototype.call = function(u, c) {
    var l = new SampleSubscriber(u), v = c.subscribe(l);
    return v.add(innerSubscribe(this.notifier, new SimpleInnerSubscriber(l))), v;
  }, a;
}(), SampleSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u() {
    var c = a !== null && a.apply(this, arguments) || this;
    return c.hasValue = !1, c;
  }
  return u.prototype._next = function(c) {
    this.value = c, this.hasValue = !0;
  }, u.prototype.notifyNext = function() {
    this.emitValue();
  }, u.prototype.notifyComplete = function() {
    this.emitValue();
  }, u.prototype.emitValue = function() {
    this.hasValue && (this.hasValue = !1, this.destination.next(this.value));
  }, u;
}(SimpleOuterSubscriber);
function sampleTime(a, u) {
  return u === void 0 && (u = async$1), function(c) {
    return c.lift(new SampleTimeOperator(a, u));
  };
}
var SampleTimeOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.period = u, this.scheduler = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new SampleTimeSubscriber(u, this.period, this.scheduler));
  }, a;
}(), SampleTimeSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.period = l, p.scheduler = v, p.hasValue = !1, p.add(v.schedule(dispatchNotification, l, { subscriber: p, period: l })), p;
  }
  return u.prototype._next = function(c) {
    this.lastValue = c, this.hasValue = !0;
  }, u.prototype.notifyNext = function() {
    this.hasValue && (this.hasValue = !1, this.destination.next(this.lastValue));
  }, u;
}(Subscriber);
function dispatchNotification(a) {
  var u = a.subscriber, c = a.period;
  u.notifyNext(), this.schedule(a, c);
}
function sequenceEqual(a, u) {
  return function(c) {
    return c.lift(new SequenceEqualOperator(a, u));
  };
}
var SequenceEqualOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.compareTo = u, this.comparator = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new SequenceEqualSubscriber(u, this.compareTo, this.comparator));
  }, a;
}(), SequenceEqualSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.compareTo = l, p.comparator = v, p._a = [], p._b = [], p._oneComplete = !1, p.destination.add(l.subscribe(new SequenceEqualCompareToSubscriber(c, p))), p;
  }
  return u.prototype._next = function(c) {
    this._oneComplete && this._b.length === 0 ? this.emit(!1) : (this._a.push(c), this.checkValues());
  }, u.prototype._complete = function() {
    this._oneComplete ? this.emit(this._a.length === 0 && this._b.length === 0) : this._oneComplete = !0, this.unsubscribe();
  }, u.prototype.checkValues = function() {
    for (var c = this, l = c._a, v = c._b, p = c.comparator; l.length > 0 && v.length > 0; ) {
      var _ = l.shift(), k = v.shift(), O = !1;
      try {
        O = p ? p(_, k) : _ === k;
      } catch (D) {
        this.destination.error(D);
      }
      O || this.emit(!1);
    }
  }, u.prototype.emit = function(c) {
    var l = this.destination;
    l.next(c), l.complete();
  }, u.prototype.nextB = function(c) {
    this._oneComplete && this._a.length === 0 ? this.emit(!1) : (this._b.push(c), this.checkValues());
  }, u.prototype.completeB = function() {
    this._oneComplete ? this.emit(this._a.length === 0 && this._b.length === 0) : this._oneComplete = !0;
  }, u;
}(Subscriber), SequenceEqualCompareToSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.parent = l, v;
  }
  return u.prototype._next = function(c) {
    this.parent.nextB(c);
  }, u.prototype._error = function(c) {
    this.parent.error(c), this.unsubscribe();
  }, u.prototype._complete = function() {
    this.parent.completeB(), this.unsubscribe();
  }, u;
}(Subscriber);
function shareSubjectFactory() {
  return new Subject();
}
function share() {
  return function(a) {
    return refCount()(multicast(shareSubjectFactory)(a));
  };
}
function shareReplay(a, u, c) {
  var l;
  return a && typeof a == "object" ? l = a : l = {
    bufferSize: a,
    windowTime: u,
    refCount: !1,
    scheduler: c
  }, function(v) {
    return v.lift(shareReplayOperator(l));
  };
}
function shareReplayOperator(a) {
  var u = a.bufferSize, c = u === void 0 ? Number.POSITIVE_INFINITY : u, l = a.windowTime, v = l === void 0 ? Number.POSITIVE_INFINITY : l, p = a.refCount, _ = a.scheduler, k, O = 0, D, F = !1, z = !1;
  return function(ee) {
    O++;
    var X;
    !k || F ? (F = !1, k = new ReplaySubject(c, v, _), X = k.subscribe(this), D = ee.subscribe({
      next: function(ae) {
        k.next(ae);
      },
      error: function(ae) {
        F = !0, k.error(ae);
      },
      complete: function() {
        z = !0, D = void 0, k.complete();
      }
    }), z && (D = void 0)) : X = k.subscribe(this), this.add(function() {
      O--, X.unsubscribe(), X = void 0, D && !z && p && O === 0 && (D.unsubscribe(), D = void 0, k = void 0);
    });
  };
}
function single(a) {
  return function(u) {
    return u.lift(new SingleOperator(a, u));
  };
}
var SingleOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.predicate = u, this.source = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new SingleSubscriber(u, this.predicate, this.source));
  }, a;
}(), SingleSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.predicate = l, p.source = v, p.seenValue = !1, p.index = 0, p;
  }
  return u.prototype.applySingleValue = function(c) {
    this.seenValue ? this.destination.error("Sequence contains more than one element") : (this.seenValue = !0, this.singleValue = c);
  }, u.prototype._next = function(c) {
    var l = this.index++;
    this.predicate ? this.tryNext(c, l) : this.applySingleValue(c);
  }, u.prototype.tryNext = function(c, l) {
    try {
      this.predicate(c, l, this.source) && this.applySingleValue(c);
    } catch (v) {
      this.destination.error(v);
    }
  }, u.prototype._complete = function() {
    var c = this.destination;
    this.index > 0 ? (c.next(this.seenValue ? this.singleValue : void 0), c.complete()) : c.error(new EmptyError());
  }, u;
}(Subscriber);
function skip(a) {
  return function(u) {
    return u.lift(new SkipOperator(a));
  };
}
var SkipOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.total = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new SkipSubscriber(u, this.total));
  }, a;
}(), SkipSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.total = l, v.count = 0, v;
  }
  return u.prototype._next = function(c) {
    ++this.count > this.total && this.destination.next(c);
  }, u;
}(Subscriber);
function skipLast(a) {
  return function(u) {
    return u.lift(new SkipLastOperator(a));
  };
}
var SkipLastOperator = /* @__PURE__ */ function() {
  function a(u) {
    if (this._skipCount = u, this._skipCount < 0)
      throw new ArgumentOutOfRangeError();
  }
  return a.prototype.call = function(u, c) {
    return this._skipCount === 0 ? c.subscribe(new Subscriber(u)) : c.subscribe(new SkipLastSubscriber(u, this._skipCount));
  }, a;
}(), SkipLastSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v._skipCount = l, v._count = 0, v._ring = new Array(l), v;
  }
  return u.prototype._next = function(c) {
    var l = this._skipCount, v = this._count++;
    if (v < l)
      this._ring[v] = c;
    else {
      var p = v % l, _ = this._ring, k = _[p];
      _[p] = c, this.destination.next(k);
    }
  }, u;
}(Subscriber);
function skipUntil(a) {
  return function(u) {
    return u.lift(new SkipUntilOperator(a));
  };
}
var SkipUntilOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.notifier = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new SkipUntilSubscriber(u, this.notifier));
  }, a;
}(), SkipUntilSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    v.hasValue = !1;
    var p = new SimpleInnerSubscriber(v);
    v.add(p), v.innerSubscription = p;
    var _ = innerSubscribe(l, p);
    return _ !== p && (v.add(_), v.innerSubscription = _), v;
  }
  return u.prototype._next = function(c) {
    this.hasValue && a.prototype._next.call(this, c);
  }, u.prototype.notifyNext = function() {
    this.hasValue = !0, this.innerSubscription && this.innerSubscription.unsubscribe();
  }, u.prototype.notifyComplete = function() {
  }, u;
}(SimpleOuterSubscriber);
function skipWhile(a) {
  return function(u) {
    return u.lift(new SkipWhileOperator(a));
  };
}
var SkipWhileOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.predicate = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new SkipWhileSubscriber(u, this.predicate));
  }, a;
}(), SkipWhileSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.predicate = l, v.skipping = !0, v.index = 0, v;
  }
  return u.prototype._next = function(c) {
    var l = this.destination;
    this.skipping && this.tryCallPredicate(c), this.skipping || l.next(c);
  }, u.prototype.tryCallPredicate = function(c) {
    try {
      var l = this.predicate(c, this.index++);
      this.skipping = !!l;
    } catch (v) {
      this.destination.error(v);
    }
  }, u;
}(Subscriber);
function startWith() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  var c = a[a.length - 1];
  return isScheduler(c) ? (a.pop(), function(l) {
    return concat$1(a, l, c);
  }) : function(l) {
    return concat$1(a, l);
  };
}
var nextHandle = 1, RESOLVED = /* @__PURE__ */ function() {
  return /* @__PURE__ */ Promise.resolve();
}(), activeHandles = {};
function findAndClearHandle(a) {
  return a in activeHandles ? (delete activeHandles[a], !0) : !1;
}
var Immediate = {
  setImmediate: function(a) {
    var u = nextHandle++;
    return activeHandles[u] = !0, RESOLVED.then(function() {
      return findAndClearHandle(u) && a();
    }), u;
  },
  clearImmediate: function(a) {
    findAndClearHandle(a);
  }
}, AsapAction = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c, l) || this;
    return v.scheduler = c, v.work = l, v;
  }
  return u.prototype.requestAsyncId = function(c, l, v) {
    return v === void 0 && (v = 0), v !== null && v > 0 ? a.prototype.requestAsyncId.call(this, c, l, v) : (c.actions.push(this), c.scheduled || (c.scheduled = Immediate.setImmediate(c.flush.bind(c, null))));
  }, u.prototype.recycleAsyncId = function(c, l, v) {
    if (v === void 0 && (v = 0), v !== null && v > 0 || v === null && this.delay > 0)
      return a.prototype.recycleAsyncId.call(this, c, l, v);
    c.actions.length === 0 && (Immediate.clearImmediate(l), c.scheduled = void 0);
  }, u;
}(AsyncAction), AsapScheduler = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u() {
    return a !== null && a.apply(this, arguments) || this;
  }
  return u.prototype.flush = function(c) {
    this.active = !0, this.scheduled = void 0;
    var l = this.actions, v, p = -1, _ = l.length;
    c = c || l.shift();
    do
      if (v = c.execute(c.state, c.delay))
        break;
    while (++p < _ && (c = l.shift()));
    if (this.active = !1, v) {
      for (; ++p < _ && (c = l.shift()); )
        c.unsubscribe();
      throw v;
    }
  }, u;
}(AsyncScheduler), asapScheduler = /* @__PURE__ */ new AsapScheduler(AsapAction), asap = asapScheduler, SubscribeOnObservable = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    l === void 0 && (l = 0), v === void 0 && (v = asap);
    var p = a.call(this) || this;
    return p.source = c, p.delayTime = l, p.scheduler = v, (!isNumeric(l) || l < 0) && (p.delayTime = 0), (!v || typeof v.schedule != "function") && (p.scheduler = asap), p;
  }
  return u.create = function(c, l, v) {
    return l === void 0 && (l = 0), v === void 0 && (v = asap), new u(c, l, v);
  }, u.dispatch = function(c) {
    var l = c.source, v = c.subscriber;
    return this.add(l.subscribe(v));
  }, u.prototype._subscribe = function(c) {
    var l = this.delayTime, v = this.source, p = this.scheduler;
    return p.schedule(u.dispatch, l, {
      source: v,
      subscriber: c
    });
  }, u;
}(Observable);
function subscribeOn(a, u) {
  return u === void 0 && (u = 0), function(l) {
    return l.lift(new SubscribeOnOperator(a, u));
  };
}
var SubscribeOnOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.scheduler = u, this.delay = c;
  }
  return a.prototype.call = function(u, c) {
    return new SubscribeOnObservable(c, this.delay, this.scheduler).subscribe(u);
  }, a;
}();
function switchMap(a, u) {
  return typeof u == "function" ? function(c) {
    return c.pipe(switchMap(function(l, v) {
      return from(a(l, v)).pipe(map(function(p, _) {
        return u(l, p, v, _);
      }));
    }));
  } : function(c) {
    return c.lift(new SwitchMapOperator(a));
  };
}
var SwitchMapOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.project = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new SwitchMapSubscriber(u, this.project));
  }, a;
}(), SwitchMapSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.project = l, v.index = 0, v;
  }
  return u.prototype._next = function(c) {
    var l, v = this.index++;
    try {
      l = this.project(c, v);
    } catch (p) {
      this.destination.error(p);
      return;
    }
    this._innerSub(l);
  }, u.prototype._innerSub = function(c) {
    var l = this.innerSubscription;
    l && l.unsubscribe();
    var v = new SimpleInnerSubscriber(this), p = this.destination;
    p.add(v), this.innerSubscription = innerSubscribe(c, v), this.innerSubscription !== v && p.add(this.innerSubscription);
  }, u.prototype._complete = function() {
    var c = this.innerSubscription;
    (!c || c.closed) && a.prototype._complete.call(this), this.unsubscribe();
  }, u.prototype._unsubscribe = function() {
    this.innerSubscription = void 0;
  }, u.prototype.notifyComplete = function() {
    this.innerSubscription = void 0, this.isStopped && a.prototype._complete.call(this);
  }, u.prototype.notifyNext = function(c) {
    this.destination.next(c);
  }, u;
}(SimpleOuterSubscriber);
function switchAll() {
  return switchMap(identity$1);
}
function switchMapTo(a, u) {
  return u ? switchMap(function() {
    return a;
  }, u) : switchMap(function() {
    return a;
  });
}
function takeUntil(a) {
  return function(u) {
    return u.lift(new TakeUntilOperator(a));
  };
}
var TakeUntilOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.notifier = u;
  }
  return a.prototype.call = function(u, c) {
    var l = new TakeUntilSubscriber(u), v = innerSubscribe(this.notifier, new SimpleInnerSubscriber(l));
    return v && !l.seenValue ? (l.add(v), c.subscribe(l)) : l;
  }, a;
}(), TakeUntilSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c) {
    var l = a.call(this, c) || this;
    return l.seenValue = !1, l;
  }
  return u.prototype.notifyNext = function() {
    this.seenValue = !0, this.complete();
  }, u.prototype.notifyComplete = function() {
  }, u;
}(SimpleOuterSubscriber);
function takeWhile(a, u) {
  return u === void 0 && (u = !1), function(c) {
    return c.lift(new TakeWhileOperator(a, u));
  };
}
var TakeWhileOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.predicate = u, this.inclusive = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new TakeWhileSubscriber(u, this.predicate, this.inclusive));
  }, a;
}(), TakeWhileSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.predicate = l, p.inclusive = v, p.index = 0, p;
  }
  return u.prototype._next = function(c) {
    var l = this.destination, v;
    try {
      v = this.predicate(c, this.index++);
    } catch (p) {
      l.error(p);
      return;
    }
    this.nextOrComplete(c, v);
  }, u.prototype.nextOrComplete = function(c, l) {
    var v = this.destination;
    l ? v.next(c) : (this.inclusive && v.next(c), v.complete());
  }, u;
}(Subscriber);
function noop$6() {
}
function tap(a, u, c) {
  return function(v) {
    return v.lift(new DoOperator(a, u, c));
  };
}
var DoOperator = /* @__PURE__ */ function() {
  function a(u, c, l) {
    this.nextOrObserver = u, this.error = c, this.complete = l;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new TapSubscriber(u, this.nextOrObserver, this.error, this.complete));
  }, a;
}(), TapSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v, p) {
    var _ = a.call(this, c) || this;
    return _._tapNext = noop$6, _._tapError = noop$6, _._tapComplete = noop$6, _._tapError = v || noop$6, _._tapComplete = p || noop$6, isFunction$3(l) ? (_._context = _, _._tapNext = l) : l && (_._context = l, _._tapNext = l.next || noop$6, _._tapError = l.error || noop$6, _._tapComplete = l.complete || noop$6), _;
  }
  return u.prototype._next = function(c) {
    try {
      this._tapNext.call(this._context, c);
    } catch (l) {
      this.destination.error(l);
      return;
    }
    this.destination.next(c);
  }, u.prototype._error = function(c) {
    try {
      this._tapError.call(this._context, c);
    } catch (l) {
      this.destination.error(l);
      return;
    }
    this.destination.error(c);
  }, u.prototype._complete = function() {
    try {
      this._tapComplete.call(this._context);
    } catch (c) {
      this.destination.error(c);
      return;
    }
    return this.destination.complete();
  }, u;
}(Subscriber), defaultThrottleConfig = {
  leading: !0,
  trailing: !1
};
function throttle(a, u) {
  return u === void 0 && (u = defaultThrottleConfig), function(c) {
    return c.lift(new ThrottleOperator(a, !!u.leading, !!u.trailing));
  };
}
var ThrottleOperator = /* @__PURE__ */ function() {
  function a(u, c, l) {
    this.durationSelector = u, this.leading = c, this.trailing = l;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new ThrottleSubscriber(u, this.durationSelector, this.leading, this.trailing));
  }, a;
}(), ThrottleSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v, p) {
    var _ = a.call(this, c) || this;
    return _.destination = c, _.durationSelector = l, _._leading = v, _._trailing = p, _._hasValue = !1, _;
  }
  return u.prototype._next = function(c) {
    this._hasValue = !0, this._sendValue = c, this._throttled || (this._leading ? this.send() : this.throttle(c));
  }, u.prototype.send = function() {
    var c = this, l = c._hasValue, v = c._sendValue;
    l && (this.destination.next(v), this.throttle(v)), this._hasValue = !1, this._sendValue = void 0;
  }, u.prototype.throttle = function(c) {
    var l = this.tryDurationSelector(c);
    l && this.add(this._throttled = innerSubscribe(l, new SimpleInnerSubscriber(this)));
  }, u.prototype.tryDurationSelector = function(c) {
    try {
      return this.durationSelector(c);
    } catch (l) {
      return this.destination.error(l), null;
    }
  }, u.prototype.throttlingDone = function() {
    var c = this, l = c._throttled, v = c._trailing;
    l && l.unsubscribe(), this._throttled = void 0, v && this.send();
  }, u.prototype.notifyNext = function() {
    this.throttlingDone();
  }, u.prototype.notifyComplete = function() {
    this.throttlingDone();
  }, u;
}(SimpleOuterSubscriber);
function throttleTime(a, u, c) {
  return u === void 0 && (u = async$1), c === void 0 && (c = defaultThrottleConfig), function(l) {
    return l.lift(new ThrottleTimeOperator(a, u, c.leading, c.trailing));
  };
}
var ThrottleTimeOperator = /* @__PURE__ */ function() {
  function a(u, c, l, v) {
    this.duration = u, this.scheduler = c, this.leading = l, this.trailing = v;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new ThrottleTimeSubscriber(u, this.duration, this.scheduler, this.leading, this.trailing));
  }, a;
}(), ThrottleTimeSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v, p, _) {
    var k = a.call(this, c) || this;
    return k.duration = l, k.scheduler = v, k.leading = p, k.trailing = _, k._hasTrailingValue = !1, k._trailingValue = null, k;
  }
  return u.prototype._next = function(c) {
    this.throttled ? this.trailing && (this._trailingValue = c, this._hasTrailingValue = !0) : (this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, { subscriber: this })), this.leading ? this.destination.next(c) : this.trailing && (this._trailingValue = c, this._hasTrailingValue = !0));
  }, u.prototype._complete = function() {
    this._hasTrailingValue ? (this.destination.next(this._trailingValue), this.destination.complete()) : this.destination.complete();
  }, u.prototype.clearThrottle = function() {
    var c = this.throttled;
    c && (this.trailing && this._hasTrailingValue && (this.destination.next(this._trailingValue), this._trailingValue = null, this._hasTrailingValue = !1), c.unsubscribe(), this.remove(c), this.throttled = null);
  }, u;
}(Subscriber);
function dispatchNext(a) {
  var u = a.subscriber;
  u.clearThrottle();
}
function defer(a) {
  return new Observable(function(u) {
    var c;
    try {
      c = a();
    } catch (v) {
      u.error(v);
      return;
    }
    var l = c ? from(c) : empty$2();
    return l.subscribe(u);
  });
}
function timeInterval(a) {
  return a === void 0 && (a = async$1), function(u) {
    return defer(function() {
      return u.pipe(scan(function(c, l) {
        var v = c.current;
        return { value: l, current: a.now(), last: v };
      }, { current: a.now(), value: void 0, last: void 0 }), map(function(c) {
        var l = c.current, v = c.last, p = c.value;
        return new TimeInterval(p, l - v);
      }));
    });
  };
}
var TimeInterval = /* @__PURE__ */ function() {
  function a(u, c) {
    this.value = u, this.interval = c;
  }
  return a;
}(), TimeoutErrorImpl = /* @__PURE__ */ function() {
  function a() {
    return Error.call(this), this.message = "Timeout has occurred", this.name = "TimeoutError", this;
  }
  return a.prototype = /* @__PURE__ */ Object.create(Error.prototype), a;
}(), TimeoutError = TimeoutErrorImpl;
function timeoutWith(a, u, c) {
  return c === void 0 && (c = async$1), function(l) {
    var v = isDate$1(a), p = v ? +a - c.now() : Math.abs(a);
    return l.lift(new TimeoutWithOperator(p, v, u, c));
  };
}
var TimeoutWithOperator = /* @__PURE__ */ function() {
  function a(u, c, l, v) {
    this.waitFor = u, this.absoluteTimeout = c, this.withObservable = l, this.scheduler = v;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new TimeoutWithSubscriber(u, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));
  }, a;
}(), TimeoutWithSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v, p, _) {
    var k = a.call(this, c) || this;
    return k.absoluteTimeout = l, k.waitFor = v, k.withObservable = p, k.scheduler = _, k.scheduleTimeout(), k;
  }
  return u.dispatchTimeout = function(c) {
    var l = c.withObservable;
    c._unsubscribeAndRecycle(), c.add(innerSubscribe(l, new SimpleInnerSubscriber(c)));
  }, u.prototype.scheduleTimeout = function() {
    var c = this.action;
    c ? this.action = c.schedule(this, this.waitFor) : this.add(this.action = this.scheduler.schedule(u.dispatchTimeout, this.waitFor, this));
  }, u.prototype._next = function(c) {
    this.absoluteTimeout || this.scheduleTimeout(), a.prototype._next.call(this, c);
  }, u.prototype._unsubscribe = function() {
    this.action = void 0, this.scheduler = null, this.withObservable = null;
  }, u;
}(SimpleOuterSubscriber);
function timeout(a, u) {
  return u === void 0 && (u = async$1), timeoutWith(a, throwError(new TimeoutError()), u);
}
function timestamp$1(a) {
  return a === void 0 && (a = async$1), map(function(u) {
    return new Timestamp$1(u, a.now());
  });
}
var Timestamp$1 = /* @__PURE__ */ function() {
  function a(u, c) {
    this.value = u, this.timestamp = c;
  }
  return a;
}();
function toArrayReducer(a, u, c) {
  return c === 0 ? [u] : (a.push(u), a);
}
function toArray$2() {
  return reduce(toArrayReducer, []);
}
function window$1(a) {
  return function(c) {
    return c.lift(new WindowOperator$1(a));
  };
}
var WindowOperator$1 = /* @__PURE__ */ function() {
  function a(u) {
    this.windowBoundaries = u;
  }
  return a.prototype.call = function(u, c) {
    var l = new WindowSubscriber$1(u), v = c.subscribe(l);
    return v.closed || l.add(innerSubscribe(this.windowBoundaries, new SimpleInnerSubscriber(l))), v;
  }, a;
}(), WindowSubscriber$1 = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c) {
    var l = a.call(this, c) || this;
    return l.window = new Subject(), c.next(l.window), l;
  }
  return u.prototype.notifyNext = function() {
    this.openWindow();
  }, u.prototype.notifyError = function(c) {
    this._error(c);
  }, u.prototype.notifyComplete = function() {
    this._complete();
  }, u.prototype._next = function(c) {
    this.window.next(c);
  }, u.prototype._error = function(c) {
    this.window.error(c), this.destination.error(c);
  }, u.prototype._complete = function() {
    this.window.complete(), this.destination.complete();
  }, u.prototype._unsubscribe = function() {
    this.window = null;
  }, u.prototype.openWindow = function() {
    var c = this.window;
    c && c.complete();
    var l = this.destination, v = this.window = new Subject();
    l.next(v);
  }, u;
}(SimpleOuterSubscriber);
function windowCount(a, u) {
  return u === void 0 && (u = 0), function(l) {
    return l.lift(new WindowCountOperator(a, u));
  };
}
var WindowCountOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.windowSize = u, this.startWindowEvery = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new WindowCountSubscriber(u, this.windowSize, this.startWindowEvery));
  }, a;
}(), WindowCountSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.destination = c, p.windowSize = l, p.startWindowEvery = v, p.windows = [new Subject()], p.count = 0, c.next(p.windows[0]), p;
  }
  return u.prototype._next = function(c) {
    for (var l = this.startWindowEvery > 0 ? this.startWindowEvery : this.windowSize, v = this.destination, p = this.windowSize, _ = this.windows, k = _.length, O = 0; O < k && !this.closed; O++)
      _[O].next(c);
    var D = this.count - p + 1;
    if (D >= 0 && D % l === 0 && !this.closed && _.shift().complete(), ++this.count % l === 0 && !this.closed) {
      var F = new Subject();
      _.push(F), v.next(F);
    }
  }, u.prototype._error = function(c) {
    var l = this.windows;
    if (l)
      for (; l.length > 0 && !this.closed; )
        l.shift().error(c);
    this.destination.error(c);
  }, u.prototype._complete = function() {
    var c = this.windows;
    if (c)
      for (; c.length > 0 && !this.closed; )
        c.shift().complete();
    this.destination.complete();
  }, u.prototype._unsubscribe = function() {
    this.count = 0, this.windows = null;
  }, u;
}(Subscriber);
function windowTime(a) {
  var u = async$1, c = null, l = Number.POSITIVE_INFINITY;
  return isScheduler(arguments[3]) && (u = arguments[3]), isScheduler(arguments[2]) ? u = arguments[2] : isNumeric(arguments[2]) && (l = Number(arguments[2])), isScheduler(arguments[1]) ? u = arguments[1] : isNumeric(arguments[1]) && (c = Number(arguments[1])), function(p) {
    return p.lift(new WindowTimeOperator(a, c, l, u));
  };
}
var WindowTimeOperator = /* @__PURE__ */ function() {
  function a(u, c, l, v) {
    this.windowTimeSpan = u, this.windowCreationInterval = c, this.maxWindowSize = l, this.scheduler = v;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new WindowTimeSubscriber(u, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));
  }, a;
}(), CountedSubject = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u() {
    var c = a !== null && a.apply(this, arguments) || this;
    return c._numberOfNextedValues = 0, c;
  }
  return u.prototype.next = function(c) {
    this._numberOfNextedValues++, a.prototype.next.call(this, c);
  }, Object.defineProperty(u.prototype, "numberOfNextedValues", {
    get: function() {
      return this._numberOfNextedValues;
    },
    enumerable: !0,
    configurable: !0
  }), u;
}(Subject), WindowTimeSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v, p, _) {
    var k = a.call(this, c) || this;
    k.destination = c, k.windowTimeSpan = l, k.windowCreationInterval = v, k.maxWindowSize = p, k.scheduler = _, k.windows = [];
    var O = k.openWindow();
    if (v !== null && v >= 0) {
      var D = { subscriber: k, window: O, context: null }, F = { windowTimeSpan: l, windowCreationInterval: v, subscriber: k, scheduler: _ };
      k.add(_.schedule(dispatchWindowClose, l, D)), k.add(_.schedule(dispatchWindowCreation, v, F));
    } else {
      var z = { subscriber: k, window: O, windowTimeSpan: l };
      k.add(_.schedule(dispatchWindowTimeSpanOnly, l, z));
    }
    return k;
  }
  return u.prototype._next = function(c) {
    for (var l = this.windows, v = l.length, p = 0; p < v; p++) {
      var _ = l[p];
      _.closed || (_.next(c), _.numberOfNextedValues >= this.maxWindowSize && this.closeWindow(_));
    }
  }, u.prototype._error = function(c) {
    for (var l = this.windows; l.length > 0; )
      l.shift().error(c);
    this.destination.error(c);
  }, u.prototype._complete = function() {
    for (var c = this.windows; c.length > 0; ) {
      var l = c.shift();
      l.closed || l.complete();
    }
    this.destination.complete();
  }, u.prototype.openWindow = function() {
    var c = new CountedSubject();
    this.windows.push(c);
    var l = this.destination;
    return l.next(c), c;
  }, u.prototype.closeWindow = function(c) {
    c.complete();
    var l = this.windows;
    l.splice(l.indexOf(c), 1);
  }, u;
}(Subscriber);
function dispatchWindowTimeSpanOnly(a) {
  var u = a.subscriber, c = a.windowTimeSpan, l = a.window;
  l && u.closeWindow(l), a.window = u.openWindow(), this.schedule(a, c);
}
function dispatchWindowCreation(a) {
  var u = a.windowTimeSpan, c = a.subscriber, l = a.scheduler, v = a.windowCreationInterval, p = c.openWindow(), _ = this, k = { action: _, subscription: null }, O = { subscriber: c, window: p, context: k };
  k.subscription = l.schedule(dispatchWindowClose, u, O), _.add(k.subscription), _.schedule(a, v);
}
function dispatchWindowClose(a) {
  var u = a.subscriber, c = a.window, l = a.context;
  l && l.action && l.subscription && l.action.remove(l.subscription), u.closeWindow(c);
}
function windowToggle(a, u) {
  return function(c) {
    return c.lift(new WindowToggleOperator(a, u));
  };
}
var WindowToggleOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.openings = u, this.closingSelector = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new WindowToggleSubscriber(u, this.openings, this.closingSelector));
  }, a;
}(), WindowToggleSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.openings = l, p.closingSelector = v, p.contexts = [], p.add(p.openSubscription = subscribeToResult(p, l, l)), p;
  }
  return u.prototype._next = function(c) {
    var l = this.contexts;
    if (l)
      for (var v = l.length, p = 0; p < v; p++)
        l[p].window.next(c);
  }, u.prototype._error = function(c) {
    var l = this.contexts;
    if (this.contexts = null, l)
      for (var v = l.length, p = -1; ++p < v; ) {
        var _ = l[p];
        _.window.error(c), _.subscription.unsubscribe();
      }
    a.prototype._error.call(this, c);
  }, u.prototype._complete = function() {
    var c = this.contexts;
    if (this.contexts = null, c)
      for (var l = c.length, v = -1; ++v < l; ) {
        var p = c[v];
        p.window.complete(), p.subscription.unsubscribe();
      }
    a.prototype._complete.call(this);
  }, u.prototype._unsubscribe = function() {
    var c = this.contexts;
    if (this.contexts = null, c)
      for (var l = c.length, v = -1; ++v < l; ) {
        var p = c[v];
        p.window.unsubscribe(), p.subscription.unsubscribe();
      }
  }, u.prototype.notifyNext = function(c, l, v, p, _) {
    if (c === this.openings) {
      var k = void 0;
      try {
        var O = this.closingSelector;
        k = O(l);
      } catch (ee) {
        return this.error(ee);
      }
      var D = new Subject(), F = new Subscription(), z = { window: D, subscription: F };
      this.contexts.push(z);
      var j = subscribeToResult(this, k, z);
      j.closed ? this.closeWindow(this.contexts.length - 1) : (j.context = z, F.add(j)), this.destination.next(D);
    } else
      this.closeWindow(this.contexts.indexOf(c));
  }, u.prototype.notifyError = function(c) {
    this.error(c);
  }, u.prototype.notifyComplete = function(c) {
    c !== this.openSubscription && this.closeWindow(this.contexts.indexOf(c.context));
  }, u.prototype.closeWindow = function(c) {
    if (c !== -1) {
      var l = this.contexts, v = l[c], p = v.window, _ = v.subscription;
      l.splice(c, 1), p.complete(), _.unsubscribe();
    }
  }, u;
}(OuterSubscriber);
function windowWhen(a) {
  return function(c) {
    return c.lift(new WindowOperator(a));
  };
}
var WindowOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.closingSelector = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new WindowSubscriber(u, this.closingSelector));
  }, a;
}(), WindowSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.destination = c, v.closingSelector = l, v.openWindow(), v;
  }
  return u.prototype.notifyNext = function(c, l, v, p, _) {
    this.openWindow(_);
  }, u.prototype.notifyError = function(c) {
    this._error(c);
  }, u.prototype.notifyComplete = function(c) {
    this.openWindow(c);
  }, u.prototype._next = function(c) {
    this.window.next(c);
  }, u.prototype._error = function(c) {
    this.window.error(c), this.destination.error(c), this.unsubscribeClosingNotification();
  }, u.prototype._complete = function() {
    this.window.complete(), this.destination.complete(), this.unsubscribeClosingNotification();
  }, u.prototype.unsubscribeClosingNotification = function() {
    this.closingNotification && this.closingNotification.unsubscribe();
  }, u.prototype.openWindow = function(c) {
    c === void 0 && (c = null), c && (this.remove(c), c.unsubscribe());
    var l = this.window;
    l && l.complete();
    var v = this.window = new Subject();
    this.destination.next(v);
    var p;
    try {
      var _ = this.closingSelector;
      p = _();
    } catch (k) {
      this.destination.error(k), this.window.error(k);
      return;
    }
    this.add(this.closingNotification = subscribeToResult(this, p));
  }, u;
}(OuterSubscriber);
function withLatestFrom() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  return function(c) {
    var l;
    typeof a[a.length - 1] == "function" && (l = a.pop());
    var v = a;
    return c.lift(new WithLatestFromOperator(v, l));
  };
}
var WithLatestFromOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.observables = u, this.project = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new WithLatestFromSubscriber(u, this.observables, this.project));
  }, a;
}(), WithLatestFromSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    p.observables = l, p.project = v, p.toRespond = [];
    var _ = l.length;
    p.values = new Array(_);
    for (var k = 0; k < _; k++)
      p.toRespond.push(k);
    for (var k = 0; k < _; k++) {
      var O = l[k];
      p.add(subscribeToResult(p, O, void 0, k));
    }
    return p;
  }
  return u.prototype.notifyNext = function(c, l, v) {
    this.values[v] = l;
    var p = this.toRespond;
    if (p.length > 0) {
      var _ = p.indexOf(v);
      _ !== -1 && p.splice(_, 1);
    }
  }, u.prototype.notifyComplete = function() {
  }, u.prototype._next = function(c) {
    if (this.toRespond.length === 0) {
      var l = [c].concat(this.values);
      this.project ? this._tryProject(l) : this.destination.next(l);
    }
  }, u.prototype._tryProject = function(c) {
    var l;
    try {
      l = this.project.apply(this, c);
    } catch (v) {
      this.destination.error(v);
      return;
    }
    this.destination.next(l);
  }, u;
}(OuterSubscriber);
function zip$1() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  var c = a[a.length - 1];
  return typeof c == "function" && a.pop(), fromArray$1(a, void 0).lift(new ZipOperator(c));
}
var ZipOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.resultSelector = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new ZipSubscriber(u, this.resultSelector));
  }, a;
}(), ZipSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.resultSelector = l, p.iterators = [], p.active = 0, p.resultSelector = typeof l == "function" ? l : void 0, p;
  }
  return u.prototype._next = function(c) {
    var l = this.iterators;
    isArray$5(c) ? l.push(new StaticArrayIterator(c)) : typeof c[iterator] == "function" ? l.push(new StaticIterator(c[iterator]())) : l.push(new ZipBufferIterator(this.destination, this, c));
  }, u.prototype._complete = function() {
    var c = this.iterators, l = c.length;
    if (this.unsubscribe(), l === 0) {
      this.destination.complete();
      return;
    }
    this.active = l;
    for (var v = 0; v < l; v++) {
      var p = c[v];
      if (p.stillUnsubscribed) {
        var _ = this.destination;
        _.add(p.subscribe());
      } else
        this.active--;
    }
  }, u.prototype.notifyInactive = function() {
    this.active--, this.active === 0 && this.destination.complete();
  }, u.prototype.checkIterators = function() {
    for (var c = this.iterators, l = c.length, v = this.destination, p = 0; p < l; p++) {
      var _ = c[p];
      if (typeof _.hasValue == "function" && !_.hasValue())
        return;
    }
    for (var k = !1, O = [], p = 0; p < l; p++) {
      var _ = c[p], D = _.next();
      if (_.hasCompleted() && (k = !0), D.done) {
        v.complete();
        return;
      }
      O.push(D.value);
    }
    this.resultSelector ? this._tryresultSelector(O) : v.next(O), k && v.complete();
  }, u.prototype._tryresultSelector = function(c) {
    var l;
    try {
      l = this.resultSelector.apply(this, c);
    } catch (v) {
      this.destination.error(v);
      return;
    }
    this.destination.next(l);
  }, u;
}(Subscriber), StaticIterator = /* @__PURE__ */ function() {
  function a(u) {
    this.iterator = u, this.nextResult = u.next();
  }
  return a.prototype.hasValue = function() {
    return !0;
  }, a.prototype.next = function() {
    var u = this.nextResult;
    return this.nextResult = this.iterator.next(), u;
  }, a.prototype.hasCompleted = function() {
    var u = this.nextResult;
    return !!(u && u.done);
  }, a;
}(), StaticArrayIterator = /* @__PURE__ */ function() {
  function a(u) {
    this.array = u, this.index = 0, this.length = 0, this.length = u.length;
  }
  return a.prototype[iterator] = function() {
    return this;
  }, a.prototype.next = function(u) {
    var c = this.index++, l = this.array;
    return c < this.length ? { value: l[c], done: !1 } : { value: null, done: !0 };
  }, a.prototype.hasValue = function() {
    return this.array.length > this.index;
  }, a.prototype.hasCompleted = function() {
    return this.array.length === this.index;
  }, a;
}(), ZipBufferIterator = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.parent = l, p.observable = v, p.stillUnsubscribed = !0, p.buffer = [], p.isComplete = !1, p;
  }
  return u.prototype[iterator] = function() {
    return this;
  }, u.prototype.next = function() {
    var c = this.buffer;
    return c.length === 0 && this.isComplete ? { value: null, done: !0 } : { value: c.shift(), done: !1 };
  }, u.prototype.hasValue = function() {
    return this.buffer.length > 0;
  }, u.prototype.hasCompleted = function() {
    return this.buffer.length === 0 && this.isComplete;
  }, u.prototype.notifyComplete = function() {
    this.buffer.length > 0 ? (this.isComplete = !0, this.parent.notifyInactive()) : this.destination.complete();
  }, u.prototype.notifyNext = function(c) {
    this.buffer.push(c), this.parent.checkIterators();
  }, u.prototype.subscribe = function() {
    return innerSubscribe(this.observable, new SimpleInnerSubscriber(this));
  }, u;
}(SimpleOuterSubscriber);
function zip() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  return function(l) {
    return l.lift.call(zip$1.apply(void 0, [l].concat(a)));
  };
}
function zipAll(a) {
  return function(u) {
    return u.lift(new ZipOperator(a));
  };
}
const operators = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  audit,
  auditTime,
  buffer: buffer$2,
  bufferCount,
  bufferTime,
  bufferToggle,
  bufferWhen,
  catchError,
  combineAll,
  combineLatest,
  concat,
  concatAll,
  concatMap,
  concatMapTo,
  count,
  debounce: debounce$1,
  debounceTime,
  defaultIfEmpty,
  delay,
  delayWhen,
  dematerialize,
  distinct,
  distinctUntilChanged,
  distinctUntilKeyChanged,
  elementAt,
  endWith,
  every: every$1,
  exhaust,
  exhaustMap,
  expand,
  filter,
  finalize,
  find: find$2,
  findIndex,
  first,
  flatMap,
  groupBy,
  ignoreElements,
  isEmpty,
  last: last$1,
  map,
  mapTo,
  materialize,
  max: max$1,
  merge: merge$1,
  mergeAll,
  mergeMap,
  mergeMapTo,
  mergeScan,
  min,
  multicast,
  observeOn,
  onErrorResumeNext,
  pairwise,
  partition,
  pluck,
  publish,
  publishBehavior,
  publishLast,
  publishReplay,
  race,
  reduce,
  refCount,
  repeat,
  repeatWhen,
  retry,
  retryWhen,
  sample,
  sampleTime,
  scan,
  sequenceEqual,
  share,
  shareReplay,
  single,
  skip,
  skipLast,
  skipUntil,
  skipWhile,
  startWith,
  subscribeOn,
  switchAll,
  switchMap,
  switchMapTo,
  take,
  takeLast,
  takeUntil,
  takeWhile,
  tap,
  throttle,
  throttleTime,
  throwIfEmpty,
  timeInterval,
  timeout,
  timeoutWith,
  timestamp: timestamp$1,
  toArray: toArray$2,
  window: window$1,
  windowCount,
  windowTime,
  windowToggle,
  windowWhen,
  withLatestFrom,
  zip,
  zipAll
}, Symbol.toStringTag, { value: "Module" })), require$$2$1 = /* @__PURE__ */ getAugmentedNamespace(operators);
var struct = {};
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(Z, de, fe, Te) {
    Te === void 0 && (Te = fe), Object.defineProperty(Z, Te, { enumerable: !0, get: function() {
      return de[fe];
    } });
  } : function(Z, de, fe, Te) {
    Te === void 0 && (Te = fe), Z[Te] = de[fe];
  }), c = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(Z, de) {
    Object.defineProperty(Z, "default", { enumerable: !0, value: de });
  } : function(Z, de) {
    Z.default = de;
  }), l = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(Z) {
    if (Z && Z.__esModule)
      return Z;
    var de = {};
    if (Z != null)
      for (var fe in Z)
        fe !== "default" && Object.hasOwnProperty.call(Z, fe) && u(de, Z, fe);
    return c(de, Z), de;
  }, v = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(Z) {
    return Z && Z.__esModule ? Z : { default: Z };
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.ListValue = a.Value = a.Struct_FieldsEntry = a.Struct = a.nullValueToNumber = a.nullValueToJSON = a.nullValueFromJSON = a.NullValue = a.protobufPackage = void 0;
  const p = v(umdExports), _ = l(minimal);
  a.protobufPackage = "google.protobuf";
  var k;
  (function(Z) {
    Z.NULL_VALUE = "NULL_VALUE";
  })(k = a.NullValue || (a.NullValue = {}));
  function O(Z) {
    switch (Z) {
      case 0:
      case "NULL_VALUE":
        return k.NULL_VALUE;
      default:
        throw new ae.Error("Unrecognized enum value " + Z + " for enum NullValue");
    }
  }
  a.nullValueFromJSON = O;
  function D(Z) {
    switch (Z) {
      case k.NULL_VALUE:
        return "NULL_VALUE";
      default:
        return "UNKNOWN";
    }
  }
  a.nullValueToJSON = D;
  function F(Z) {
    switch (Z) {
      case k.NULL_VALUE:
        return 0;
      default:
        return 0;
    }
  }
  a.nullValueToNumber = F;
  function z() {
    return { fields: {} };
  }
  a.Struct = {
    encode(Z, de = _.Writer.create()) {
      return Object.entries(Z.fields).forEach(([fe, Te]) => {
        Te !== void 0 && a.Struct_FieldsEntry.encode({ key: fe, value: Te }, de.uint32(10).fork()).ldelim();
      }), de;
    },
    decode(Z, de) {
      const fe = Z instanceof _.Reader ? Z : new _.Reader(Z);
      let Te = de === void 0 ? fe.len : fe.pos + de;
      const Re = z();
      for (; fe.pos < Te; ) {
        const Le = fe.uint32();
        switch (Le >>> 3) {
          case 1:
            const be = a.Struct_FieldsEntry.decode(fe, fe.uint32());
            be.value !== void 0 && (Re.fields[be.key] = be.value);
            break;
          default:
            fe.skipType(Le & 7);
            break;
        }
      }
      return Re;
    },
    fromJSON(Z) {
      return {
        fields: Q(Z.fields) ? Object.entries(Z.fields).reduce((de, [fe, Te]) => (de[fe] = Te, de), {}) : {}
      };
    },
    toJSON(Z) {
      const de = {};
      return de.fields = {}, Z.fields && Object.entries(Z.fields).forEach(([fe, Te]) => {
        de.fields[fe] = Te;
      }), de;
    },
    fromPartial(Z) {
      var de;
      const fe = z();
      return fe.fields = Object.entries((de = Z.fields) !== null && de !== void 0 ? de : {}).reduce((Te, [Re, Le]) => (Le !== void 0 && (Te[Re] = Le), Te), {}), fe;
    },
    wrap(Z) {
      const de = z();
      return Z !== void 0 && Object.keys(Z).forEach((fe) => {
        de.fields[fe] = Z[fe];
      }), de;
    },
    unwrap(Z) {
      const de = {};
      return Object.keys(Z.fields).forEach((fe) => {
        de[fe] = Z.fields[fe];
      }), de;
    }
  };
  function j() {
    return { key: "", value: void 0 };
  }
  a.Struct_FieldsEntry = {
    encode(Z, de = _.Writer.create()) {
      return Z.key !== "" && de.uint32(10).string(Z.key), Z.value !== void 0 && a.Value.encode(a.Value.wrap(Z.value), de.uint32(18).fork()).ldelim(), de;
    },
    decode(Z, de) {
      const fe = Z instanceof _.Reader ? Z : new _.Reader(Z);
      let Te = de === void 0 ? fe.len : fe.pos + de;
      const Re = j();
      for (; fe.pos < Te; ) {
        const Le = fe.uint32();
        switch (Le >>> 3) {
          case 1:
            Re.key = fe.string();
            break;
          case 2:
            Re.value = a.Value.unwrap(a.Value.decode(fe, fe.uint32()));
            break;
          default:
            fe.skipType(Le & 7);
            break;
        }
      }
      return Re;
    },
    fromJSON(Z) {
      return {
        key: ne(Z.key) ? String(Z.key) : "",
        value: ne(Z == null ? void 0 : Z.value) ? Z.value : void 0
      };
    },
    toJSON(Z) {
      const de = {};
      return Z.key !== void 0 && (de.key = Z.key), Z.value !== void 0 && (de.value = Z.value), de;
    },
    fromPartial(Z) {
      var de, fe;
      const Te = j();
      return Te.key = (de = Z.key) !== null && de !== void 0 ? de : "", Te.value = (fe = Z.value) !== null && fe !== void 0 ? fe : void 0, Te;
    }
  };
  function ee() {
    return {
      nullValue: void 0,
      numberValue: void 0,
      stringValue: void 0,
      boolValue: void 0,
      structValue: void 0,
      listValue: void 0
    };
  }
  a.Value = {
    encode(Z, de = _.Writer.create()) {
      return Z.nullValue !== void 0 && de.uint32(8).int32(F(Z.nullValue)), Z.numberValue !== void 0 && de.uint32(17).double(Z.numberValue), Z.stringValue !== void 0 && de.uint32(26).string(Z.stringValue), Z.boolValue !== void 0 && de.uint32(32).bool(Z.boolValue), Z.structValue !== void 0 && a.Struct.encode(a.Struct.wrap(Z.structValue), de.uint32(42).fork()).ldelim(), Z.listValue !== void 0 && a.ListValue.encode(a.ListValue.wrap(Z.listValue), de.uint32(50).fork()).ldelim(), de;
    },
    decode(Z, de) {
      const fe = Z instanceof _.Reader ? Z : new _.Reader(Z);
      let Te = de === void 0 ? fe.len : fe.pos + de;
      const Re = ee();
      for (; fe.pos < Te; ) {
        const Le = fe.uint32();
        switch (Le >>> 3) {
          case 1:
            Re.nullValue = O(fe.int32());
            break;
          case 2:
            Re.numberValue = fe.double();
            break;
          case 3:
            Re.stringValue = fe.string();
            break;
          case 4:
            Re.boolValue = fe.bool();
            break;
          case 5:
            Re.structValue = a.Struct.unwrap(a.Struct.decode(fe, fe.uint32()));
            break;
          case 6:
            Re.listValue = a.ListValue.unwrap(a.ListValue.decode(fe, fe.uint32()));
            break;
          default:
            fe.skipType(Le & 7);
            break;
        }
      }
      return Re;
    },
    fromJSON(Z) {
      return {
        nullValue: ne(Z.nullValue) ? O(Z.nullValue) : void 0,
        numberValue: ne(Z.numberValue) ? Number(Z.numberValue) : void 0,
        stringValue: ne(Z.stringValue) ? String(Z.stringValue) : void 0,
        boolValue: ne(Z.boolValue) ? !!Z.boolValue : void 0,
        structValue: Q(Z.structValue) ? Z.structValue : void 0,
        listValue: Array.isArray(Z.listValue) ? [...Z.listValue] : void 0
      };
    },
    toJSON(Z) {
      const de = {};
      return Z.nullValue !== void 0 && (de.nullValue = Z.nullValue !== void 0 ? D(Z.nullValue) : void 0), Z.numberValue !== void 0 && (de.numberValue = Z.numberValue), Z.stringValue !== void 0 && (de.stringValue = Z.stringValue), Z.boolValue !== void 0 && (de.boolValue = Z.boolValue), Z.structValue !== void 0 && (de.structValue = Z.structValue), Z.listValue !== void 0 && (de.listValue = Z.listValue), de;
    },
    fromPartial(Z) {
      var de, fe, Te, Re, Le, be;
      const q = ee();
      return q.nullValue = (de = Z.nullValue) !== null && de !== void 0 ? de : void 0, q.numberValue = (fe = Z.numberValue) !== null && fe !== void 0 ? fe : void 0, q.stringValue = (Te = Z.stringValue) !== null && Te !== void 0 ? Te : void 0, q.boolValue = (Re = Z.boolValue) !== null && Re !== void 0 ? Re : void 0, q.structValue = (Le = Z.structValue) !== null && Le !== void 0 ? Le : void 0, q.listValue = (be = Z.listValue) !== null && be !== void 0 ? be : void 0, q;
    },
    wrap(Z) {
      const de = ee();
      if (Z === null)
        de.nullValue = k.NULL_VALUE;
      else if (typeof Z == "boolean")
        de.boolValue = Z;
      else if (typeof Z == "number")
        de.numberValue = Z;
      else if (typeof Z == "string")
        de.stringValue = Z;
      else if (Array.isArray(Z))
        de.listValue = Z;
      else if (typeof Z == "object")
        de.structValue = Z;
      else if (typeof Z < "u")
        throw new Error("Unsupported any value type: " + typeof Z);
      return de;
    },
    unwrap(Z) {
      if ((Z == null ? void 0 : Z.stringValue) !== void 0)
        return Z.stringValue;
      if ((Z == null ? void 0 : Z.numberValue) !== void 0)
        return Z.numberValue;
      if ((Z == null ? void 0 : Z.boolValue) !== void 0)
        return Z.boolValue;
      if ((Z == null ? void 0 : Z.structValue) !== void 0)
        return Z.structValue;
      if ((Z == null ? void 0 : Z.listValue) !== void 0)
        return Z.listValue;
      if ((Z == null ? void 0 : Z.nullValue) !== void 0)
        return null;
    }
  };
  function X() {
    return { values: [] };
  }
  a.ListValue = {
    encode(Z, de = _.Writer.create()) {
      for (const fe of Z.values)
        a.Value.encode(a.Value.wrap(fe), de.uint32(10).fork()).ldelim();
      return de;
    },
    decode(Z, de) {
      const fe = Z instanceof _.Reader ? Z : new _.Reader(Z);
      let Te = de === void 0 ? fe.len : fe.pos + de;
      const Re = X();
      for (; fe.pos < Te; ) {
        const Le = fe.uint32();
        switch (Le >>> 3) {
          case 1:
            Re.values.push(a.Value.unwrap(a.Value.decode(fe, fe.uint32())));
            break;
          default:
            fe.skipType(Le & 7);
            break;
        }
      }
      return Re;
    },
    fromJSON(Z) {
      return {
        values: Array.isArray(Z == null ? void 0 : Z.values) ? [...Z.values] : []
      };
    },
    toJSON(Z) {
      const de = {};
      return Z.values ? de.values = Z.values.map((fe) => fe) : de.values = [], de;
    },
    fromPartial(Z) {
      var de;
      const fe = X();
      return fe.values = ((de = Z.values) === null || de === void 0 ? void 0 : de.map((Te) => Te)) || [], fe;
    },
    wrap(Z) {
      const de = X();
      return de.values = Z ?? [], de;
    },
    unwrap(Z) {
      return Z.values;
    }
  };
  var ae = (() => {
    if (typeof ae < "u")
      return ae;
    if (typeof self < "u")
      return self;
    if (typeof window < "u")
      return window;
    if (typeof commonjsGlobal$1 < "u")
      return commonjsGlobal$1;
    throw "Unable to locate global object";
  })();
  _.util.Long !== p.default && (_.util.Long = p.default, _.configure());
  function Q(Z) {
    return typeof Z == "object" && Z !== null;
  }
  function ne(Z) {
    return Z != null;
  }
})(struct);
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(q, J, C, S) {
    S === void 0 && (S = C), Object.defineProperty(q, S, { enumerable: !0, get: function() {
      return J[C];
    } });
  } : function(q, J, C, S) {
    S === void 0 && (S = C), q[S] = J[C];
  }), c = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(q, J) {
    Object.defineProperty(q, "default", { enumerable: !0, value: J });
  } : function(q, J) {
    q.default = J;
  }), l = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(q) {
    if (q && q.__esModule)
      return q;
    var J = {};
    if (q != null)
      for (var C in q)
        C !== "default" && Object.hasOwnProperty.call(q, C) && u(J, q, C);
    return c(J, q), J;
  }, v = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(q) {
    return q && q.__esModule ? q : { default: q };
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.EventServiceDefinition = a.EventServiceClientImpl = a.EventsStreamResponse = a.EventsStreamRequest = a.EventsStreamReconnectRequest = a.EventsStreamError = a.SubscribePayload = a.PublishEventResponse = a.PublishEventRequest = a.EventTarget = a.eventsStreamMessageTypeToNumber = a.eventsStreamMessageTypeToJSON = a.eventsStreamMessageTypeFromJSON = a.EventsStreamMessageType = a.protobufPackage = void 0;
  const p = v(umdExports), _ = l(minimal), k = require$$2$1, O = struct;
  a.protobufPackage = "apis.event.v2";
  var D;
  (function(q) {
    q.EVENTS_STREAM_MESSAGE_TYPE_UNSPECIFIED = "EVENTS_STREAM_MESSAGE_TYPE_UNSPECIFIED", q.EVENTS_STREAM_MESSAGE_TYPE_PING = "EVENTS_STREAM_MESSAGE_TYPE_PING", q.EVENTS_STREAM_MESSAGE_TYPE_ERROR = "EVENTS_STREAM_MESSAGE_TYPE_ERROR", q.EVENTS_STREAM_MESSAGE_TYPE_SUBSCRIBED = "EVENTS_STREAM_MESSAGE_TYPE_SUBSCRIBED", q.EVENTS_STREAM_MESSAGE_TYPE_UNSUBSCRIBED = "EVENTS_STREAM_MESSAGE_TYPE_UNSUBSCRIBED", q.EVENTS_STREAM_MESSAGE_TYPE_PUBLISHED = "EVENTS_STREAM_MESSAGE_TYPE_PUBLISHED";
  })(D = a.EventsStreamMessageType || (a.EventsStreamMessageType = {}));
  function F(q) {
    switch (q) {
      case 0:
      case "EVENTS_STREAM_MESSAGE_TYPE_UNSPECIFIED":
        return D.EVENTS_STREAM_MESSAGE_TYPE_UNSPECIFIED;
      case 1:
      case "EVENTS_STREAM_MESSAGE_TYPE_PING":
        return D.EVENTS_STREAM_MESSAGE_TYPE_PING;
      case 2:
      case "EVENTS_STREAM_MESSAGE_TYPE_ERROR":
        return D.EVENTS_STREAM_MESSAGE_TYPE_ERROR;
      case 3:
      case "EVENTS_STREAM_MESSAGE_TYPE_SUBSCRIBED":
        return D.EVENTS_STREAM_MESSAGE_TYPE_SUBSCRIBED;
      case 4:
      case "EVENTS_STREAM_MESSAGE_TYPE_UNSUBSCRIBED":
        return D.EVENTS_STREAM_MESSAGE_TYPE_UNSUBSCRIBED;
      case 5:
      case "EVENTS_STREAM_MESSAGE_TYPE_PUBLISHED":
        return D.EVENTS_STREAM_MESSAGE_TYPE_PUBLISHED;
      default:
        throw new Re.Error("Unrecognized enum value " + q + " for enum EventsStreamMessageType");
    }
  }
  a.eventsStreamMessageTypeFromJSON = F;
  function z(q) {
    switch (q) {
      case D.EVENTS_STREAM_MESSAGE_TYPE_UNSPECIFIED:
        return "EVENTS_STREAM_MESSAGE_TYPE_UNSPECIFIED";
      case D.EVENTS_STREAM_MESSAGE_TYPE_PING:
        return "EVENTS_STREAM_MESSAGE_TYPE_PING";
      case D.EVENTS_STREAM_MESSAGE_TYPE_ERROR:
        return "EVENTS_STREAM_MESSAGE_TYPE_ERROR";
      case D.EVENTS_STREAM_MESSAGE_TYPE_SUBSCRIBED:
        return "EVENTS_STREAM_MESSAGE_TYPE_SUBSCRIBED";
      case D.EVENTS_STREAM_MESSAGE_TYPE_UNSUBSCRIBED:
        return "EVENTS_STREAM_MESSAGE_TYPE_UNSUBSCRIBED";
      case D.EVENTS_STREAM_MESSAGE_TYPE_PUBLISHED:
        return "EVENTS_STREAM_MESSAGE_TYPE_PUBLISHED";
      default:
        return "UNKNOWN";
    }
  }
  a.eventsStreamMessageTypeToJSON = z;
  function j(q) {
    switch (q) {
      case D.EVENTS_STREAM_MESSAGE_TYPE_UNSPECIFIED:
        return 0;
      case D.EVENTS_STREAM_MESSAGE_TYPE_PING:
        return 1;
      case D.EVENTS_STREAM_MESSAGE_TYPE_ERROR:
        return 2;
      case D.EVENTS_STREAM_MESSAGE_TYPE_SUBSCRIBED:
        return 3;
      case D.EVENTS_STREAM_MESSAGE_TYPE_UNSUBSCRIBED:
        return 4;
      case D.EVENTS_STREAM_MESSAGE_TYPE_PUBLISHED:
        return 5;
      default:
        return 0;
    }
  }
  a.eventsStreamMessageTypeToNumber = j;
  function ee() {
    return { collectionId: void 0, projectId: void 0, layoutId: void 0 };
  }
  a.EventTarget = {
    encode(q, J = _.Writer.create()) {
      return q.collectionId !== void 0 && J.uint32(42).string(q.collectionId), q.projectId !== void 0 && J.uint32(34).string(q.projectId), q.layoutId !== void 0 && J.uint32(10).string(q.layoutId), J;
    },
    decode(q, J) {
      const C = q instanceof _.Reader ? q : new _.Reader(q);
      let S = J === void 0 ? C.len : C.pos + J;
      const E = ee();
      for (; C.pos < S; ) {
        const I = C.uint32();
        switch (I >>> 3) {
          case 5:
            E.collectionId = C.string();
            break;
          case 4:
            E.projectId = C.string();
            break;
          case 1:
            E.layoutId = C.string();
            break;
          default:
            C.skipType(I & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(q) {
      return {
        collectionId: be(q.collectionId) ? String(q.collectionId) : void 0,
        projectId: be(q.projectId) ? String(q.projectId) : void 0,
        layoutId: be(q.layoutId) ? String(q.layoutId) : void 0
      };
    },
    toJSON(q) {
      const J = {};
      return q.collectionId !== void 0 && (J.collectionId = q.collectionId), q.projectId !== void 0 && (J.projectId = q.projectId), q.layoutId !== void 0 && (J.layoutId = q.layoutId), J;
    },
    fromPartial(q) {
      var J, C, S;
      const E = ee();
      return E.collectionId = (J = q.collectionId) !== null && J !== void 0 ? J : void 0, E.projectId = (C = q.projectId) !== null && C !== void 0 ? C : void 0, E.layoutId = (S = q.layoutId) !== null && S !== void 0 ? S : void 0, E;
    }
  };
  function X() {
    return {
      name: "",
      payload: void 0,
      requestMetadata: void 0,
      target: void 0
    };
  }
  a.PublishEventRequest = {
    encode(q, J = _.Writer.create()) {
      return q.name !== "" && J.uint32(10).string(q.name), q.payload !== void 0 && O.Struct.encode(O.Struct.wrap(q.payload), J.uint32(18).fork()).ldelim(), q.requestMetadata !== void 0 && O.Value.encode(O.Value.wrap(q.requestMetadata), J.uint32(34).fork()).ldelim(), q.target !== void 0 && a.EventTarget.encode(q.target, J.uint32(26).fork()).ldelim(), J;
    },
    decode(q, J) {
      const C = q instanceof _.Reader ? q : new _.Reader(q);
      let S = J === void 0 ? C.len : C.pos + J;
      const E = X();
      for (; C.pos < S; ) {
        const I = C.uint32();
        switch (I >>> 3) {
          case 1:
            E.name = C.string();
            break;
          case 2:
            E.payload = O.Struct.unwrap(O.Struct.decode(C, C.uint32()));
            break;
          case 4:
            E.requestMetadata = O.Value.unwrap(O.Value.decode(C, C.uint32()));
            break;
          case 3:
            E.target = a.EventTarget.decode(C, C.uint32());
            break;
          default:
            C.skipType(I & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(q) {
      return {
        name: be(q.name) ? String(q.name) : "",
        payload: Le(q.payload) ? q.payload : void 0,
        requestMetadata: be(q == null ? void 0 : q.requestMetadata) ? q.requestMetadata : void 0,
        target: be(q.target) ? a.EventTarget.fromJSON(q.target) : void 0
      };
    },
    toJSON(q) {
      const J = {};
      return q.name !== void 0 && (J.name = q.name), q.payload !== void 0 && (J.payload = q.payload), q.requestMetadata !== void 0 && (J.requestMetadata = q.requestMetadata), q.target !== void 0 && (J.target = q.target ? a.EventTarget.toJSON(q.target) : void 0), J;
    },
    fromPartial(q) {
      var J, C, S;
      const E = X();
      return E.name = (J = q.name) !== null && J !== void 0 ? J : "", E.payload = (C = q.payload) !== null && C !== void 0 ? C : void 0, E.requestMetadata = (S = q.requestMetadata) !== null && S !== void 0 ? S : void 0, E.target = q.target !== void 0 && q.target !== null ? a.EventTarget.fromPartial(q.target) : void 0, E;
    }
  };
  function ae() {
    return {
      name: "",
      payload: void 0,
      target: void 0,
      requestMetadata: void 0,
      id: ""
    };
  }
  a.PublishEventResponse = {
    encode(q, J = _.Writer.create()) {
      return q.name !== "" && J.uint32(10).string(q.name), q.payload !== void 0 && O.Struct.encode(O.Struct.wrap(q.payload), J.uint32(18).fork()).ldelim(), q.target !== void 0 && a.EventTarget.encode(q.target, J.uint32(26).fork()).ldelim(), q.requestMetadata !== void 0 && O.Value.encode(O.Value.wrap(q.requestMetadata), J.uint32(34).fork()).ldelim(), q.id !== "" && J.uint32(42).string(q.id), J;
    },
    decode(q, J) {
      const C = q instanceof _.Reader ? q : new _.Reader(q);
      let S = J === void 0 ? C.len : C.pos + J;
      const E = ae();
      for (; C.pos < S; ) {
        const I = C.uint32();
        switch (I >>> 3) {
          case 1:
            E.name = C.string();
            break;
          case 2:
            E.payload = O.Struct.unwrap(O.Struct.decode(C, C.uint32()));
            break;
          case 3:
            E.target = a.EventTarget.decode(C, C.uint32());
            break;
          case 4:
            E.requestMetadata = O.Value.unwrap(O.Value.decode(C, C.uint32()));
            break;
          case 5:
            E.id = C.string();
            break;
          default:
            C.skipType(I & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(q) {
      return {
        name: be(q.name) ? String(q.name) : "",
        payload: Le(q.payload) ? q.payload : void 0,
        target: be(q.target) ? a.EventTarget.fromJSON(q.target) : void 0,
        requestMetadata: be(q == null ? void 0 : q.requestMetadata) ? q.requestMetadata : void 0,
        id: be(q.id) ? String(q.id) : ""
      };
    },
    toJSON(q) {
      const J = {};
      return q.name !== void 0 && (J.name = q.name), q.payload !== void 0 && (J.payload = q.payload), q.target !== void 0 && (J.target = q.target ? a.EventTarget.toJSON(q.target) : void 0), q.requestMetadata !== void 0 && (J.requestMetadata = q.requestMetadata), q.id !== void 0 && (J.id = q.id), J;
    },
    fromPartial(q) {
      var J, C, S, E;
      const I = ae();
      return I.name = (J = q.name) !== null && J !== void 0 ? J : "", I.payload = (C = q.payload) !== null && C !== void 0 ? C : void 0, I.target = q.target !== void 0 && q.target !== null ? a.EventTarget.fromPartial(q.target) : void 0, I.requestMetadata = (S = q.requestMetadata) !== null && S !== void 0 ? S : void 0, I.id = (E = q.id) !== null && E !== void 0 ? E : "", I;
    }
  };
  function Q() {
    return { name: "", target: void 0 };
  }
  a.SubscribePayload = {
    encode(q, J = _.Writer.create()) {
      return q.name !== "" && J.uint32(10).string(q.name), q.target !== void 0 && a.EventTarget.encode(q.target, J.uint32(18).fork()).ldelim(), J;
    },
    decode(q, J) {
      const C = q instanceof _.Reader ? q : new _.Reader(q);
      let S = J === void 0 ? C.len : C.pos + J;
      const E = Q();
      for (; C.pos < S; ) {
        const I = C.uint32();
        switch (I >>> 3) {
          case 1:
            E.name = C.string();
            break;
          case 2:
            E.target = a.EventTarget.decode(C, C.uint32());
            break;
          default:
            C.skipType(I & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(q) {
      return {
        name: be(q.name) ? String(q.name) : "",
        target: be(q.target) ? a.EventTarget.fromJSON(q.target) : void 0
      };
    },
    toJSON(q) {
      const J = {};
      return q.name !== void 0 && (J.name = q.name), q.target !== void 0 && (J.target = q.target ? a.EventTarget.toJSON(q.target) : void 0), J;
    },
    fromPartial(q) {
      var J;
      const C = Q();
      return C.name = (J = q.name) !== null && J !== void 0 ? J : "", C.target = q.target !== void 0 && q.target !== null ? a.EventTarget.fromPartial(q.target) : void 0, C;
    }
  };
  function ne() {
    return { code: 0, message: "" };
  }
  a.EventsStreamError = {
    encode(q, J = _.Writer.create()) {
      return q.code !== 0 && J.uint32(8).int32(q.code), q.message !== "" && J.uint32(18).string(q.message), J;
    },
    decode(q, J) {
      const C = q instanceof _.Reader ? q : new _.Reader(q);
      let S = J === void 0 ? C.len : C.pos + J;
      const E = ne();
      for (; C.pos < S; ) {
        const I = C.uint32();
        switch (I >>> 3) {
          case 1:
            E.code = C.int32();
            break;
          case 2:
            E.message = C.string();
            break;
          default:
            C.skipType(I & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(q) {
      return {
        code: be(q.code) ? Number(q.code) : 0,
        message: be(q.message) ? String(q.message) : ""
      };
    },
    toJSON(q) {
      const J = {};
      return q.code !== void 0 && (J.code = Math.round(q.code)), q.message !== void 0 && (J.message = q.message), J;
    },
    fromPartial(q) {
      var J, C;
      const S = ne();
      return S.code = (J = q.code) !== null && J !== void 0 ? J : 0, S.message = (C = q.message) !== null && C !== void 0 ? C : "", S;
    }
  };
  function Z() {
    return { reauthenticate: !1, beforeTimestamp: "" };
  }
  a.EventsStreamReconnectRequest = {
    encode(q, J = _.Writer.create()) {
      return q.reauthenticate === !0 && J.uint32(8).bool(q.reauthenticate), q.beforeTimestamp !== "" && J.uint32(18).string(q.beforeTimestamp), J;
    },
    decode(q, J) {
      const C = q instanceof _.Reader ? q : new _.Reader(q);
      let S = J === void 0 ? C.len : C.pos + J;
      const E = Z();
      for (; C.pos < S; ) {
        const I = C.uint32();
        switch (I >>> 3) {
          case 1:
            E.reauthenticate = C.bool();
            break;
          case 2:
            E.beforeTimestamp = C.string();
            break;
          default:
            C.skipType(I & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(q) {
      return {
        reauthenticate: be(q.reauthenticate) ? !!q.reauthenticate : !1,
        beforeTimestamp: be(q.beforeTimestamp) ? String(q.beforeTimestamp) : ""
      };
    },
    toJSON(q) {
      const J = {};
      return q.reauthenticate !== void 0 && (J.reauthenticate = q.reauthenticate), q.beforeTimestamp !== void 0 && (J.beforeTimestamp = q.beforeTimestamp), J;
    },
    fromPartial(q) {
      var J, C;
      const S = Z();
      return S.reauthenticate = (J = q.reauthenticate) !== null && J !== void 0 ? J : !1, S.beforeTimestamp = (C = q.beforeTimestamp) !== null && C !== void 0 ? C : "", S;
    }
  };
  function de() {
    return {
      correlationId: void 0,
      subscribe: void 0,
      unsubscribe: void 0,
      publish: void 0,
      ping: void 0
    };
  }
  a.EventsStreamRequest = {
    encode(q, J = _.Writer.create()) {
      return q.correlationId !== void 0 && J.uint32(10).string(q.correlationId), q.subscribe !== void 0 && a.SubscribePayload.encode(q.subscribe, J.uint32(802).fork()).ldelim(), q.unsubscribe !== void 0 && a.SubscribePayload.encode(q.unsubscribe, J.uint32(810).fork()).ldelim(), q.publish !== void 0 && a.PublishEventRequest.encode(q.publish, J.uint32(818).fork()).ldelim(), q.ping !== void 0 && J.uint32(826).string(q.ping), J;
    },
    decode(q, J) {
      const C = q instanceof _.Reader ? q : new _.Reader(q);
      let S = J === void 0 ? C.len : C.pos + J;
      const E = de();
      for (; C.pos < S; ) {
        const I = C.uint32();
        switch (I >>> 3) {
          case 1:
            E.correlationId = C.string();
            break;
          case 100:
            E.subscribe = a.SubscribePayload.decode(C, C.uint32());
            break;
          case 101:
            E.unsubscribe = a.SubscribePayload.decode(C, C.uint32());
            break;
          case 102:
            E.publish = a.PublishEventRequest.decode(C, C.uint32());
            break;
          case 103:
            E.ping = C.string();
            break;
          default:
            C.skipType(I & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(q) {
      return {
        correlationId: be(q.correlationId) ? String(q.correlationId) : void 0,
        subscribe: be(q.subscribe) ? a.SubscribePayload.fromJSON(q.subscribe) : void 0,
        unsubscribe: be(q.unsubscribe) ? a.SubscribePayload.fromJSON(q.unsubscribe) : void 0,
        publish: be(q.publish) ? a.PublishEventRequest.fromJSON(q.publish) : void 0,
        ping: be(q.ping) ? String(q.ping) : void 0
      };
    },
    toJSON(q) {
      const J = {};
      return q.correlationId !== void 0 && (J.correlationId = q.correlationId), q.subscribe !== void 0 && (J.subscribe = q.subscribe ? a.SubscribePayload.toJSON(q.subscribe) : void 0), q.unsubscribe !== void 0 && (J.unsubscribe = q.unsubscribe ? a.SubscribePayload.toJSON(q.unsubscribe) : void 0), q.publish !== void 0 && (J.publish = q.publish ? a.PublishEventRequest.toJSON(q.publish) : void 0), q.ping !== void 0 && (J.ping = q.ping), J;
    },
    fromPartial(q) {
      var J, C;
      const S = de();
      return S.correlationId = (J = q.correlationId) !== null && J !== void 0 ? J : void 0, S.subscribe = q.subscribe !== void 0 && q.subscribe !== null ? a.SubscribePayload.fromPartial(q.subscribe) : void 0, S.unsubscribe = q.unsubscribe !== void 0 && q.unsubscribe !== null ? a.SubscribePayload.fromPartial(q.unsubscribe) : void 0, S.publish = q.publish !== void 0 && q.publish !== null ? a.PublishEventRequest.fromPartial(q.publish) : void 0, S.ping = (C = q.ping) !== null && C !== void 0 ? C : void 0, S;
    }
  };
  function fe() {
    return {
      correlationId: void 0,
      sessionId: void 0,
      event: void 0,
      pong: void 0,
      error: void 0,
      subscribed: void 0,
      unsubscribed: void 0,
      published: void 0,
      reconnectBefore: void 0
    };
  }
  a.EventsStreamResponse = {
    encode(q, J = _.Writer.create()) {
      return q.correlationId !== void 0 && J.uint32(18).string(q.correlationId), q.sessionId !== void 0 && J.uint32(26).string(q.sessionId), q.event !== void 0 && a.PublishEventResponse.encode(q.event, J.uint32(802).fork()).ldelim(), q.pong !== void 0 && J.uint32(1602).string(q.pong), q.error !== void 0 && a.EventsStreamError.encode(q.error, J.uint32(1610).fork()).ldelim(), q.subscribed !== void 0 && a.SubscribePayload.encode(q.subscribed, J.uint32(1618).fork()).ldelim(), q.unsubscribed !== void 0 && a.SubscribePayload.encode(q.unsubscribed, J.uint32(1626).fork()).ldelim(), q.published !== void 0 && a.PublishEventResponse.encode(q.published, J.uint32(1634).fork()).ldelim(), q.reconnectBefore !== void 0 && a.EventsStreamReconnectRequest.encode(q.reconnectBefore, J.uint32(1642).fork()).ldelim(), J;
    },
    decode(q, J) {
      const C = q instanceof _.Reader ? q : new _.Reader(q);
      let S = J === void 0 ? C.len : C.pos + J;
      const E = fe();
      for (; C.pos < S; ) {
        const I = C.uint32();
        switch (I >>> 3) {
          case 2:
            E.correlationId = C.string();
            break;
          case 3:
            E.sessionId = C.string();
            break;
          case 100:
            E.event = a.PublishEventResponse.decode(C, C.uint32());
            break;
          case 200:
            E.pong = C.string();
            break;
          case 201:
            E.error = a.EventsStreamError.decode(C, C.uint32());
            break;
          case 202:
            E.subscribed = a.SubscribePayload.decode(C, C.uint32());
            break;
          case 203:
            E.unsubscribed = a.SubscribePayload.decode(C, C.uint32());
            break;
          case 204:
            E.published = a.PublishEventResponse.decode(C, C.uint32());
            break;
          case 205:
            E.reconnectBefore = a.EventsStreamReconnectRequest.decode(C, C.uint32());
            break;
          default:
            C.skipType(I & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(q) {
      return {
        correlationId: be(q.correlationId) ? String(q.correlationId) : void 0,
        sessionId: be(q.sessionId) ? String(q.sessionId) : void 0,
        event: be(q.event) ? a.PublishEventResponse.fromJSON(q.event) : void 0,
        pong: be(q.pong) ? String(q.pong) : void 0,
        error: be(q.error) ? a.EventsStreamError.fromJSON(q.error) : void 0,
        subscribed: be(q.subscribed) ? a.SubscribePayload.fromJSON(q.subscribed) : void 0,
        unsubscribed: be(q.unsubscribed) ? a.SubscribePayload.fromJSON(q.unsubscribed) : void 0,
        published: be(q.published) ? a.PublishEventResponse.fromJSON(q.published) : void 0,
        reconnectBefore: be(q.reconnectBefore) ? a.EventsStreamReconnectRequest.fromJSON(q.reconnectBefore) : void 0
      };
    },
    toJSON(q) {
      const J = {};
      return q.correlationId !== void 0 && (J.correlationId = q.correlationId), q.sessionId !== void 0 && (J.sessionId = q.sessionId), q.event !== void 0 && (J.event = q.event ? a.PublishEventResponse.toJSON(q.event) : void 0), q.pong !== void 0 && (J.pong = q.pong), q.error !== void 0 && (J.error = q.error ? a.EventsStreamError.toJSON(q.error) : void 0), q.subscribed !== void 0 && (J.subscribed = q.subscribed ? a.SubscribePayload.toJSON(q.subscribed) : void 0), q.unsubscribed !== void 0 && (J.unsubscribed = q.unsubscribed ? a.SubscribePayload.toJSON(q.unsubscribed) : void 0), q.published !== void 0 && (J.published = q.published ? a.PublishEventResponse.toJSON(q.published) : void 0), q.reconnectBefore !== void 0 && (J.reconnectBefore = q.reconnectBefore ? a.EventsStreamReconnectRequest.toJSON(q.reconnectBefore) : void 0), J;
    },
    fromPartial(q) {
      var J, C, S;
      const E = fe();
      return E.correlationId = (J = q.correlationId) !== null && J !== void 0 ? J : void 0, E.sessionId = (C = q.sessionId) !== null && C !== void 0 ? C : void 0, E.event = q.event !== void 0 && q.event !== null ? a.PublishEventResponse.fromPartial(q.event) : void 0, E.pong = (S = q.pong) !== null && S !== void 0 ? S : void 0, E.error = q.error !== void 0 && q.error !== null ? a.EventsStreamError.fromPartial(q.error) : void 0, E.subscribed = q.subscribed !== void 0 && q.subscribed !== null ? a.SubscribePayload.fromPartial(q.subscribed) : void 0, E.unsubscribed = q.unsubscribed !== void 0 && q.unsubscribed !== null ? a.SubscribePayload.fromPartial(q.unsubscribed) : void 0, E.published = q.published !== void 0 && q.published !== null ? a.PublishEventResponse.fromPartial(q.published) : void 0, E.reconnectBefore = q.reconnectBefore !== void 0 && q.reconnectBefore !== null ? a.EventsStreamReconnectRequest.fromPartial(q.reconnectBefore) : void 0, E;
    }
  };
  class Te {
    constructor(J) {
      this.rpc = J, this.Stream = this.Stream.bind(this), this.Publish = this.Publish.bind(this);
    }
    Stream(J) {
      const C = J.pipe(k.map((E) => a.EventsStreamRequest.encode(E).finish()));
      return this.rpc.bidirectionalStreamingRequest("apis.event.v2.EventService", "Stream", C).pipe(k.map((E) => a.EventsStreamResponse.decode(new _.Reader(E))));
    }
    Publish(J) {
      const C = a.PublishEventRequest.encode(J).finish();
      return this.rpc.request("apis.event.v2.EventService", "Publish", C).then((E) => a.PublishEventResponse.decode(new _.Reader(E)));
    }
  }
  a.EventServiceClientImpl = Te, a.EventServiceDefinition = {
    name: "EventService",
    fullName: "apis.event.v2.EventService",
    methods: {
      /**
       * Stream Events
       * buf:lint:ignore RPC_REQUEST_STANDARD_NAME
       * buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
       */
      stream: {
        name: "Stream",
        requestType: a.EventsStreamRequest,
        requestStream: !0,
        responseType: a.EventsStreamResponse,
        responseStream: !0,
        options: {}
      },
      /**
       * Publish Event
       * buf:lint:ignore RPC_REQUEST_STANDARD_NAME
       * buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
       */
      publish: {
        name: "Publish",
        requestType: a.PublishEventRequest,
        requestStream: !1,
        responseType: a.PublishEventResponse,
        responseStream: !1,
        options: {}
      }
    }
  };
  var Re = (() => {
    if (typeof Re < "u")
      return Re;
    if (typeof self < "u")
      return self;
    if (typeof window < "u")
      return window;
    if (typeof commonjsGlobal$1 < "u")
      return commonjsGlobal$1;
    throw "Unable to locate global object";
  })();
  _.util.Long !== p.default && (_.util.Long = p.default, _.configure());
  function Le(q) {
    return typeof q == "object" && q !== null;
  }
  function be(q) {
    return q != null;
  }
})(api$1);
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(l, v, p, _) {
    _ === void 0 && (_ = p), Object.defineProperty(l, _, { enumerable: !0, get: function() {
      return v[p];
    } });
  } : function(l, v, p, _) {
    _ === void 0 && (_ = p), l[_] = v[p];
  }), c = commonjsGlobal$1 && commonjsGlobal$1.__exportStar || function(l, v) {
    for (var p in l)
      p !== "default" && !v.hasOwnProperty(p) && u(v, l, p);
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.eventsApiSupportedEvents = a.eventsApiEventRpcCalls = void 0, c(api$1, a), a.eventsApiEventRpcCalls = {
    ping: "pong",
    publish: "published",
    subscribe: "subscribed",
    unsubscribe: "unsubscribed"
  }, a.eventsApiSupportedEvents = [...Object.values(a.eventsApiEventRpcCalls), "error", "event", "reconnectBefore"];
})(dist$1);
var ws = null;
typeof WebSocket < "u" ? ws = WebSocket : typeof MozWebSocket < "u" ? ws = MozWebSocket : typeof commonjsGlobal$1 < "u" ? ws = commonjsGlobal$1.WebSocket || commonjsGlobal$1.MozWebSocket : typeof window < "u" ? ws = window.WebSocket || window.MozWebSocket : typeof self < "u" && (ws = self.WebSocket || self.MozWebSocket);
var browser$e = ws, matcher = { exports: {} }, escapeStringRegexp$1 = (a) => {
  if (typeof a != "string")
    throw new TypeError("Expected a string");
  return a.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
};
const escapeStringRegexp = escapeStringRegexp$1, regexpCache = /* @__PURE__ */ new Map();
function sanitizeArray(a, u) {
  if (!Array.isArray(a))
    switch (typeof a) {
      case "string":
        a = [a];
        break;
      case "undefined":
        a = [];
        break;
      default:
        throw new TypeError(`Expected '${u}' to be a string or an array, but got a type of '${typeof a}'`);
    }
  return a.filter((c) => {
    if (typeof c != "string") {
      if (typeof c > "u")
        return !1;
      throw new TypeError(`Expected '${u}' to be an array of strings, but found a type of '${typeof c}' in the array`);
    }
    return !0;
  });
}
function makeRegexp(a, u) {
  u = {
    caseSensitive: !1,
    ...u
  };
  const c = a + JSON.stringify(u);
  if (regexpCache.has(c))
    return regexpCache.get(c);
  const l = a[0] === "!";
  l && (a = a.slice(1)), a = escapeStringRegexp(a).replace(/\\\*/g, "[\\s\\S]*");
  const v = new RegExp(`^${a}$`, u.caseSensitive ? "" : "i");
  return v.negated = l, regexpCache.set(c, v), v;
}
matcher.exports = (a, u, c) => {
  if (a = sanitizeArray(a, "inputs"), u = sanitizeArray(u, "patterns"), u.length === 0)
    return [];
  const l = u[0][0] === "!";
  u = u.map((p) => makeRegexp(p, c));
  const v = [];
  for (const p of a) {
    let _ = l;
    for (const k of u)
      k.test(p) && (_ = !k.negated);
    _ && v.push(p);
  }
  return v;
};
matcher.exports.isMatch = (a, u, c) => (a = sanitizeArray(a, "inputs"), u = sanitizeArray(u, "patterns"), u.length === 0 ? !1 : a.some((l) => u.every((v) => {
  const p = makeRegexp(v, c), _ = p.test(l);
  return p.negated ? !_ : _;
})));
var matcherExports = matcher.exports, __createBinding$1 = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(a, u, c, l) {
  l === void 0 && (l = c);
  var v = Object.getOwnPropertyDescriptor(u, c);
  (!v || ("get" in v ? !u.__esModule : v.writable || v.configurable)) && (v = { enumerable: !0, get: function() {
    return u[c];
  } }), Object.defineProperty(a, l, v);
} : function(a, u, c, l) {
  l === void 0 && (l = c), a[l] = u[c];
}), __setModuleDefault$1 = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(a, u) {
  Object.defineProperty(a, "default", { enumerable: !0, value: u });
} : function(a, u) {
  a.default = u;
}), __importStar$1 = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(a) {
  if (a && a.__esModule)
    return a;
  var u = {};
  if (a != null)
    for (var c in a)
      c !== "default" && Object.prototype.hasOwnProperty.call(a, c) && __createBinding$1(u, a, c);
  return __setModuleDefault$1(u, a), u;
}, __importDefault$8 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(eventapi, "__esModule", { value: !0 });
eventapi.EventApi = void 0;
const EventApiModel = __importStar$1(dist$1), isomorphic_ws_1 = __importDefault$8(browser$e), uuid_1 = require$$1$4, NiceGrpc = __importStar$1(lib$1), matcher_1 = matcherExports, api_1 = api$3, clientVersion = version$4, WS_PING_INTERVAL = 2e4, WS_PING_TIMEOUT = 1e4, WS_RECONNECT_DELAY = 2e3, WS_MAX_BADAUTH_ATTEMPTS = 3, LOG_CATEGORY = "EventApi";
class EventApi extends api_1.ApiClient {
  constructor(u, c, l, v, p, _) {
    super(u, c, v, LOG_CATEGORY, p, _), this.websocketServer = l, this.subscriptions = /* @__PURE__ */ new Set(), this.eventHandlers = {}, this.calls = {}, this.messageQueue = [], this.websocketReady = !1, this.reconnectionAttempts = 0, this.badAuthentication = !1, this.eventsClient = null;
  }
  /**
   * Publish a custom event
   *
   * note: if this session has an established stream, all custom
   * events will use that transport.
   *
   * @param request
   * @returns
   */
  publish(...u) {
    return this.websocketReady ? this.call("publish", u[0]) : this.eventsClient.publish(...u);
  }
  /**
   * Open the connection
   */
  connect() {
    if (!this.ws) {
      this.cleanup();
      const u = this.accessToken, c = [`version=${clientVersion}`, `sessionid=${this.sessionId}`];
      this.sdkVersion && c.push(`sdkversion=${this.sdkVersion}`), this.ws = new isomorphic_ws_1.default(`${this.websocketServer}/stream?${c.join("&")}`, [
        "Bearer",
        this.accessToken
      ]);
      let l;
      this.ws.addEventListener("message", (v) => {
        const p = JSON.parse(v.data.toString()), _ = p.result;
        if (p.error && (l = p.error, this.handleEvent("error", {
          error: {
            code: p.code,
            message: p.message
          }
        }), ["You do not have permission to this resource", "You do not have permission to this resource"].includes(p.message) && (this.badAuthentication = !0)), !_)
          return;
        _.reconnectBefore && _.reconnectBefore.reauthenticate && this.accessToken === u && (this.badAuthentication = !0);
        const k = EventApiModel.eventsApiSupportedEvents.find((O) => !!_[O]);
        k && this.handleEvent(k, _);
      }), this.ws.addEventListener("open", () => {
        this.log.info("websocket connected"), this.call("ping", "hello", { timeout: WS_PING_TIMEOUT, skipQueue: !0 }).then(() => {
          this.ready();
        }).catch((v) => {
          !l && v.message !== "Stream connection closed" && this.disconnect("hello timeout");
        });
      }), this.ws.addEventListener("close", (v) => {
        var p;
        l ? this.reconnect(`${(p = l == null ? void 0 : l.message) !== null && p !== void 0 ? p : "unknown"}`) : this.reconnect(`closed - ${v.reason || v.code}`);
      }), this.ws.addEventListener("error", (v) => {
        l = v;
      });
    }
  }
  /**
   * Subscribe to an event
   *
   * note: if a connection does not exist, one will be established.
   *
   * @param type
   * @param payload
   */
  async subscribe(u, c = {}) {
    return this.call("subscribe", { name: u, ...c }).then(() => {
      this.subscriptions.add(JSON.stringify({ name: u, ...c }));
    });
  }
  /**
   * Unsubscribe from an event
   * @param type
   * @param payload
   */
  async unsubscribe(u, c = {}) {
    this.subscriptions.delete(JSON.stringify({ name: u, payload: c })), await this.call("unsubscribe", { name: u, ...c });
  }
  on(u, c, l) {
    const v = l || c, p = {
      ignoreSessionEvents: !1,
      allowedSessionEvents: [],
      ...l ? c : {}
    };
    this.eventHandlers[u] || (this.eventHandlers[u] = []), this.eventHandlers[u].push({
      ...p,
      handler: v
    });
  }
  off(u, c, l) {
    var v;
    const p = l || c, _ = {
      ignoreSessionEvents: !1,
      allowedSessionEvents: [],
      ...l ? c : {}
    };
    this.eventHandlers[u] = ((v = this.eventHandlers[u]) !== null && v !== void 0 ? v : []).filter((k) => !(k.ignoreSessionEvents === _.ignoreSessionEvents && k.allowedSessionEvents === _.allowedSessionEvents && k.handler === p && k.name === _.name));
  }
  /**
   * Disconnect the websocket connection
   */
  disconnect(u) {
    this.log.warn(`disconnected from events reason=${u}`), Object.values(this.calls).forEach((c) => {
      clearTimeout(c.timeout), c.reject(new Error("Stream connection closed"));
    }), this.calls = {}, this.cleanup();
  }
  _setup(u) {
    this.eventsClient = this.clientFactory.create(EventApiModel.EventServiceDefinition, this.channel, {
      "*": u
    }), this.badAuthentication && (this.badAuthentication = !1, this.reconnectionAttempts = 0, this.reconnect("updated token"));
  }
  /**
   * Called when the websocket is ready.
   */
  ready() {
    this.reconnectionAttempts = 0, this.badAuthentication = !1, this.websocketReady = !0, this.handleEvent("connected", { connected: void 0 });
    for (const u of this.subscriptions.values())
      this.send({ subscribe: JSON.parse(u), correlationId: (0, uuid_1.v4)() });
    for (const u of this.messageQueue)
      this.send(u);
    this.messageQueue = [], this.pingLoop = setInterval(() => {
      this.ping();
    }, WS_PING_INTERVAL);
  }
  ping() {
    this.call("ping", `${+/* @__PURE__ */ new Date()}`, { timeout: WS_PING_TIMEOUT }).catch(() => {
      this.reconnect("connection stalled");
    });
  }
  /**
   * Reconnect event stream
   *
   * @param reason Rec
   */
  reconnect(u) {
    this.disconnect(u), this.reconnectTimeout = setTimeout(() => {
      if (this.reconnectionAttempts++, this.badAuthentication && this.reconnectionAttempts >= WS_MAX_BADAUTH_ATTEMPTS) {
        this.log.warn("Maximum number of reconnection attempts reached with bad authentication, please re-authenticate the SDK");
        return;
      }
      this.connect();
    }, WS_RECONNECT_DELAY);
  }
  /**
   * Send a raw message to the websocket.
   *
   * @param data
   */
  send(u) {
    this.ws && this.ws.readyState === this.ws.OPEN ? this.ws.send(JSON.stringify(u)) : this.log.warn("Message sent to a disconnected stream");
  }
  /**
   * Process a stream event
   *
   * @param name the name of the event
   * @param payload the full event stream payload
   *
   * @returns void
   */
  handleEvent(u, c) {
    var l;
    if (this.calls[c.correlationId]) {
      const v = EventApiModel.eventsApiEventRpcCalls[this.calls[c.correlationId].method] === u, p = !!c.error;
      if (v || p) {
        this.resolveCall(u, c);
        return;
      }
    }
    for (const v of (l = this.eventHandlers[u]) !== null && l !== void 0 ? l : []) {
      if (u === "event" && c.event) {
        if (c.sessionId === this.sessionId && v.ignoreSessionEvents && !v.allowedSessionEvents.includes(c.event.name)) {
          this.log.trace("ignoring user event from self: " + c.event.name + ", payload.sessionId=" + c.sessionId + ", this.sessionId");
          continue;
        }
        if (v.name && !(0, matcher_1.isMatch)(c.event.name, v.name))
          continue;
        if (this.eventLogCallback) {
          let p, _ = c.event.name, k;
          if (c.event.name.startsWith(EventApi.APISTREAM_EVENT_PREFIX)) {
            let O = c.event.name.split(":");
            O.length == 4 && (p = O[1], _ = O[2], k = O[3]), this.eventLogCallback(p, _, k, c);
          }
        }
      } else if (c.sessionId === this.sessionId && v.ignoreSessionEvents) {
        this.log.trace("ignoring event from self: " + c.event.name + ", payload.sessionId=" + c.sessionId + ", this.sessionId");
        continue;
      }
      this.log.trace("processing event: payload.sessionId=" + c.sessionId + ", this.sessionId"), v.handler(c ? c[u] : void 0, { isFromCurrentSession: c.sessionId === this.sessionId });
    }
  }
  /**
   * Make an RPC call
   *
   * Initiates an async request via the stream. A correlationId is generated and used to track
   * responses and errors. A handler is registered
   *
   * @param method request method to call
   * @param payload payload to send
   * @param opts timeout
   * @returns
   */
  async call(u, c, l = { timeout: 2e4, skipQueue: !1 }) {
    this.ws || this.connect();
    const v = (0, uuid_1.v4)();
    return new Promise((p, _) => {
      const k = setTimeout(() => {
        delete this.calls[v], _(new Error("Request timed out"));
      }, l.timeout);
      this.calls[v] = { resolve: p, reject: _, timeout: k, method: u }, this.websocketReady || l.skipQueue ? this.send({ [u]: c, correlationId: v }) : this.messageQueue.push({ [u]: c, correlationId: v });
    });
  }
  /**
   * Handler for `.call()`
   *
   * Handle response events for a socket call.
   *
   * @param name name of responding event
   * @param payload payload of the event
   * @returns void
   */
  resolveCall(u, c) {
    const l = this.calls[c.correlationId];
    if (l) {
      if (clearTimeout(l.timeout), delete this.calls[c.correlationId], u === "error" && c.error) {
        l.reject(new NiceGrpc.ClientError("error", c.error.code, c.error.message));
        return;
      }
      l.resolve(c[u]);
    }
  }
  /**
   * Cleanup connection
   *
   * This cleans up the local state for a given websocket connection.
   */
  cleanup() {
    clearTimeout(this.pingLoop), clearTimeout(this.reconnectTimeout), this.websocketReady = !1, this.ws && (this.ws.onclose = function() {
    }, this.ws.close(), this.ws = null);
  }
}
eventapi.EventApi = EventApi;
EventApi.APISTREAM_EVENT_PREFIX = "apistream";
var livekit = {}, __importDefault$7 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(livekit, "__esModule", { value: !0 });
livekit.LiveKitUtils = void 0;
const jwt_decode_1 = __importDefault$7(require$$0$3);
class LiveKitUtils {
  static decodeJwt(u) {
    return (0, jwt_decode_1.default)(u, { header: !1 });
  }
  static isRoomAdmin(u) {
    return LiveKitUtils.decodeJwt(u).video.roomAdmin;
  }
  static getRoomName(u) {
    return LiveKitUtils.decodeJwt(u).video.room;
  }
}
livekit.LiveKitUtils = LiveKitUtils;
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(be, q, J, C) {
    C === void 0 && (C = J);
    var S = Object.getOwnPropertyDescriptor(q, J);
    (!S || ("get" in S ? !q.__esModule : S.writable || S.configurable)) && (S = { enumerable: !0, get: function() {
      return q[J];
    } }), Object.defineProperty(be, C, S);
  } : function(be, q, J, C) {
    C === void 0 && (C = J), be[C] = q[J];
  }), c = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(be, q) {
    Object.defineProperty(be, "default", { enumerable: !0, value: q });
  } : function(be, q) {
    be.default = q;
  }), l = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(be) {
    if (be && be.__esModule)
      return be;
    var q = {};
    if (be != null)
      for (var J in be)
        J !== "default" && Object.prototype.hasOwnProperty.call(be, J) && u(q, be, J);
    return c(q, be), q;
  }, v = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(be) {
    return be && be.__esModule ? be : { default: be };
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.ApiStream = a.LiveKitUtils = a.EventApiModel = a.LayoutApiModel = a.LiveApiModel = void 0;
  const p = v(require$$0$3), _ = require$$1$4, k = require$$2$2, O = layoutapi, D = liveapi, F = eventapi, z = l(api$2);
  a.LiveApiModel = z;
  const j = l(dist$2);
  a.LayoutApiModel = j;
  const ee = l(dist$1);
  a.EventApiModel = ee;
  const X = livekit;
  Object.defineProperty(a, "LiveKitUtils", { enumerable: !0, get: function() {
    return X.LiveKitUtils;
  } });
  const ae = logger, Q = version$4, ne = {
    dev: "http://127.0.0.1:8081",
    stage: "https://live.silly.horse/grpcweb/live/v2",
    prod: "https://live.api.stream/grpcweb/live/v2"
  }, Z = {
    dev: "https://live.silly.horse/grpcweb/layout/v2",
    stage: "https://live.silly.horse/grpcweb/layout/v2",
    prod: "https://live.api.stream/grpcweb/layout/v2"
  }, de = {
    dev: "wss://live.silly.horse/event/v2",
    stage: "wss://live.silly.horse/event/v2",
    prod: "wss://live.api.stream/event/v2"
  }, fe = {
    dev: "https://live.silly.horse/grpcweb/event/v2",
    stage: "https://live.silly.horse/grpcweb/event/v2",
    prod: "https://live.api.stream/grpcweb/event/v2"
  }, Te = {
    dev: "wss://live.silly.horse/webrtc/v2",
    stage: "wss://live.silly.horse/webrtc/v2",
    prod: "wss://live.api.stream/webrtc/v2"
  }, Re = {
    dev: "https://live.silly.horse/webrtc/v2",
    stage: "https://live.silly.horse/webrtc/v2",
    prod: "https://live.api.stream/webrtc/v2"
  };
  class Le {
    /**
     * Create an ApiStream API Client
     */
    constructor(q = {}) {
      var J;
      const C = {
        env: "prod",
        logLevel: "Warn",
        ...q
      };
      this.env = C.env;
      let S = (0, _.v4)();
      C.sessionId != null && (S = C.sessionId), this.log = ae.logger.getCategory("ApiStream"), this.setLogLevel(C.env == "dev" ? "Trace" : C.logLevel);
      const E = (J = C.overrideEndpoints) !== null && J !== void 0 ? J : {};
      E.liveApiServer == null && (E.liveApiServer = ne[this.env]), E.layoutApiServer == null && (E.layoutApiServer = Z[this.env]), E.eventApiServer == null && (E.eventApiServer = fe[this.env]), E.eventApiWebSocketServer == null && (E.eventApiWebSocketServer = de[this.env]), this.eventApi = new F.EventApi(S, E.eventApiServer, E.eventApiWebSocketServer, C.sdkVersion, C.apiLogCallback, C.eventLogCallback), this.layoutApi = new O.LayoutApi(S, this.eventApi, E.layoutApiServer, C.sdkVersion, C.apiLogCallback), this.liveApi = new D.LiveApi(S, this.eventApi, E.liveApiServer, this.setAccessToken.bind(this), C.apiKey, C.sdkVersion, C.apiLogCallback), this.eventApi.on("reconnectBefore", (I) => {
        I.reauthenticate && this.liveApi.authentication.refreshAccessToken({}).catch(() => {
        });
      }), this.log.info("api.stream: sessionid=" + S + ", version=" + Q + ", sdkVersion=" + C.sdkVersion);
    }
    /**
     * Returns the live api client
     *
     * @returns the live api client
     */
    LiveApi() {
      return this.liveApi;
    }
    /**
     * Returns the layout api client
     *
     * @returns the layout api client
     */
    LayoutApi() {
      return this.layoutApi;
    }
    /**
     * Returns the layout api client
     *
     * @returns the layout api client
     */
    EventApi() {
      return this.eventApi;
    }
    setLogLevel(q) {
      try {
        let J = k.LogLevel.toLogLevel(q);
        ae.logger.updateRuntimeSettings({
          level: J
        });
      } catch {
        this.log.warn(`unknown logging level ${q}`);
      }
    }
    setAccessToken(q) {
      this.decodedAccessToken = Le.decodeAccessToken(q), this.log.debug("setting accessToken", q, this.decodedAccessToken), this.layoutApi.setAccessToken(q), this.liveApi.setAccessToken(q), this.eventApi.setAccessToken(q);
    }
    getAccessToken() {
      return this.decodedAccessToken;
    }
    /**
     * Are we running as a guest role?
     *
     * @returns {(ApiStream.GuestProject | null)} return the active project if running as a guest role
     */
    getGuestProject() {
      return this.decodedAccessToken.guestControl;
    }
    /**
     * Initialize the api library and check if we are running inside of the rendering engine
     * @async
     * @param {string} accessToken - a valid ApiStream access token
     * @returns {(ApiStream.GuestProject | null)} if we are operating inside of the rendering engine, this is the active project
     */
    async load(q) {
      if (q == null && typeof window < "u") {
        let J = this.parseQuery();
        J.get(Le.ACCESS_TOKEN_QUERY_PARAM) != null && (q = J.get(Le.ACCESS_TOKEN_QUERY_PARAM));
      }
      return q != null && (this.setAccessToken(q), this.decodedAccessToken.guestControl != null) ? (this.log.info("loading guest token and exchanging"), await this.LiveApi().authentication.refreshAccessToken({}), this.log.info("auto-loading project = " + JSON.stringify(this.decodedAccessToken.guestControl)), this.decodedAccessToken.guestControl) : null;
    }
    /**
     * get the signaling address of the appropriate livekit webrtc server
     *
     * @param {boolean} admin - if true, return the admin (vs. client) address
     * @returns {string} the address of the appropriate livekit webrtc server
     */
    getLiveKitServer(q = !1) {
      return q ? Re[this.env] : Te[this.env];
    }
    parseQuery() {
      let q = window.location.search, J = /* @__PURE__ */ new Map(), C = (q[0] === "?" ? q.substr(1) : q).split("&");
      for (let S = 0; S < C.length; S++) {
        let E = C[S].split("=");
        E.length == 2 && (J.set(decodeURIComponent(E[0]), decodeURIComponent(E[1] || "")), this.log.debug(`found query param: ${decodeURIComponent(E[0])}=${decodeURIComponent(E[1] || "")}`));
      }
      return J;
    }
    static decodeAccessToken(q) {
      let J = (0, p.default)(q, { header: !1 }), C = {
        serviceUserId: J.user.serviceUserId,
        userId: J.user.userId,
        displayName: J.user.displayName,
        trial: J.user.trial,
        demo: J.user.demo
      };
      return J.guestControl != null && (C.guestControl = {
        collectionId: J.guestControl.collectionId,
        projectId: J.guestControl.projectId,
        role: z.roleFromJSON(J.guestControl.role)
      }), C;
    }
  }
  a.ApiStream = Le, Le.ACCESS_TOKEN_QUERY_PARAM = "at";
})(lib$2);
const config$2 = (a) => ({
  defaults: {
    previewTokenDuration: 1e3 * 60 * 60,
    guestTokenDuration: 1e3 * 60 * 60 * 12,
    transforms: {
      RoomParticipant: "LS-Room-Participant",
      Image: "LS-Image",
      Banner: "LS-Banner",
      Text: "LS-Text"
    }
  }
});
var fastDeepEqual = function a(u, c) {
  if (u === c)
    return !0;
  if (u && c && typeof u == "object" && typeof c == "object") {
    if (u.constructor !== c.constructor)
      return !1;
    var l, v, p;
    if (Array.isArray(u)) {
      if (l = u.length, l != c.length)
        return !1;
      for (v = l; v-- !== 0; )
        if (!a(u[v], c[v]))
          return !1;
      return !0;
    }
    if (u.constructor === RegExp)
      return u.source === c.source && u.flags === c.flags;
    if (u.valueOf !== Object.prototype.valueOf)
      return u.valueOf() === c.valueOf();
    if (u.toString !== Object.prototype.toString)
      return u.toString() === c.toString();
    if (p = Object.keys(u), l = p.length, l !== Object.keys(c).length)
      return !1;
    for (v = l; v-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(c, p[v]))
        return !1;
    for (v = l; v-- !== 0; ) {
      var _ = p[v];
      if (!a(u[_], c[_]))
        return !1;
    }
    return !0;
  }
  return u !== u && c !== c;
};
const deepEqual = /* @__PURE__ */ getDefaultExportFromCjs$2(fastDeepEqual), global$1 = globalThis || void 0 || self;
var freeGlobal = typeof global$1 == "object" && global$1 && global$1.Object === Object && global$1, freeSelf = typeof self == "object" && self && self.Object === Object && self, root = freeGlobal || freeSelf || Function("return this")(), Symbol$1 = root.Symbol, objectProto$m = Object.prototype, hasOwnProperty$f = objectProto$m.hasOwnProperty, nativeObjectToString$1 = objectProto$m.toString, symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : void 0;
function getRawTag(a) {
  var u = hasOwnProperty$f.call(a, symToStringTag$1), c = a[symToStringTag$1];
  try {
    a[symToStringTag$1] = void 0;
    var l = !0;
  } catch {
  }
  var v = nativeObjectToString$1.call(a);
  return l && (u ? a[symToStringTag$1] = c : delete a[symToStringTag$1]), v;
}
var objectProto$l = Object.prototype, nativeObjectToString = objectProto$l.toString;
function objectToString$7(a) {
  return nativeObjectToString.call(a);
}
var nullTag = "[object Null]", undefinedTag = "[object Undefined]", symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
function baseGetTag(a) {
  return a == null ? a === void 0 ? undefinedTag : nullTag : symToStringTag && symToStringTag in Object(a) ? getRawTag(a) : objectToString$7(a);
}
function isObjectLike$7(a) {
  return a != null && typeof a == "object";
}
var symbolTag$6 = "[object Symbol]";
function isSymbol$3(a) {
  return typeof a == "symbol" || isObjectLike$7(a) && baseGetTag(a) == symbolTag$6;
}
function arrayMap$1(a, u) {
  for (var c = -1, l = a == null ? 0 : a.length, v = Array(l); ++c < l; )
    v[c] = u(a[c], c, a);
  return v;
}
var isArray$4 = Array.isArray, INFINITY$4 = 1 / 0, symbolProto$2 = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString = symbolProto$2 ? symbolProto$2.toString : void 0;
function baseToString(a) {
  if (typeof a == "string")
    return a;
  if (isArray$4(a))
    return arrayMap$1(a, baseToString) + "";
  if (isSymbol$3(a))
    return symbolToString ? symbolToString.call(a) : "";
  var u = a + "";
  return u == "0" && 1 / a == -INFINITY$4 ? "-0" : u;
}
var reWhitespace = /\s/;
function trimmedEndIndex(a) {
  for (var u = a.length; u-- && reWhitespace.test(a.charAt(u)); )
    ;
  return u;
}
var reTrimStart = /^\s+/;
function baseTrim(a) {
  return a && a.slice(0, trimmedEndIndex(a) + 1).replace(reTrimStart, "");
}
function isObject$8(a) {
  var u = typeof a;
  return a != null && (u == "object" || u == "function");
}
var NAN$3 = NaN, reIsBadHex$3 = /^[-+]0x[0-9a-f]+$/i, reIsBinary$3 = /^0b[01]+$/i, reIsOctal$3 = /^0o[0-7]+$/i, freeParseInt$3 = parseInt;
function toNumber$3(a) {
  if (typeof a == "number")
    return a;
  if (isSymbol$3(a))
    return NAN$3;
  if (isObject$8(a)) {
    var u = typeof a.valueOf == "function" ? a.valueOf() : a;
    a = isObject$8(u) ? u + "" : u;
  }
  if (typeof a != "string")
    return a === 0 ? a : +a;
  a = baseTrim(a);
  var c = reIsBinary$3.test(a);
  return c || reIsOctal$3.test(a) ? freeParseInt$3(a.slice(2), c ? 2 : 8) : reIsBadHex$3.test(a) ? NAN$3 : +a;
}
function identity(a) {
  return a;
}
var asyncTag = "[object AsyncFunction]", funcTag$3 = "[object Function]", genTag$2 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction$2(a) {
  if (!isObject$8(a))
    return !1;
  var u = baseGetTag(a);
  return u == funcTag$3 || u == genTag$2 || u == asyncTag || u == proxyTag;
}
var coreJsData = root["__core-js_shared__"], maskSrcKey = function() {
  var a = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return a ? "Symbol(src)_1." + a : "";
}();
function isMasked(a) {
  return !!maskSrcKey && maskSrcKey in a;
}
var funcProto$3 = Function.prototype, funcToString$3 = funcProto$3.toString;
function toSource(a) {
  if (a != null) {
    try {
      return funcToString$3.call(a);
    } catch {
    }
    try {
      return a + "";
    } catch {
    }
  }
  return "";
}
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reIsHostCtor = /^\[object .+?Constructor\]$/, funcProto$2 = Function.prototype, objectProto$k = Object.prototype, funcToString$2 = funcProto$2.toString, hasOwnProperty$e = objectProto$k.hasOwnProperty, reIsNative = RegExp(
  "^" + funcToString$2.call(hasOwnProperty$e).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative(a) {
  if (!isObject$8(a) || isMasked(a))
    return !1;
  var u = isFunction$2(a) ? reIsNative : reIsHostCtor;
  return u.test(toSource(a));
}
function getValue(a, u) {
  return a == null ? void 0 : a[u];
}
function getNative(a, u) {
  var c = getValue(a, u);
  return baseIsNative(c) ? c : void 0;
}
var WeakMap$2 = getNative(root, "WeakMap"), objectCreate = Object.create, baseCreate = /* @__PURE__ */ function() {
  function a() {
  }
  return function(u) {
    if (!isObject$8(u))
      return {};
    if (objectCreate)
      return objectCreate(u);
    a.prototype = u;
    var c = new a();
    return a.prototype = void 0, c;
  };
}();
function apply(a, u, c) {
  switch (c.length) {
    case 0:
      return a.call(u);
    case 1:
      return a.call(u, c[0]);
    case 2:
      return a.call(u, c[0], c[1]);
    case 3:
      return a.call(u, c[0], c[1], c[2]);
  }
  return a.apply(u, c);
}
function copyArray(a, u) {
  var c = -1, l = a.length;
  for (u || (u = Array(l)); ++c < l; )
    u[c] = a[c];
  return u;
}
var HOT_COUNT = 800, HOT_SPAN = 16, nativeNow = Date.now;
function shortOut(a) {
  var u = 0, c = 0;
  return function() {
    var l = nativeNow(), v = HOT_SPAN - (l - c);
    if (c = l, v > 0) {
      if (++u >= HOT_COUNT)
        return arguments[0];
    } else
      u = 0;
    return a.apply(void 0, arguments);
  };
}
function constant(a) {
  return function() {
    return a;
  };
}
var defineProperty = function() {
  try {
    var a = getNative(Object, "defineProperty");
    return a({}, "", {}), a;
  } catch {
  }
}(), baseSetToString = defineProperty ? function(a, u) {
  return defineProperty(a, "toString", {
    configurable: !0,
    enumerable: !1,
    value: constant(u),
    writable: !0
  });
} : identity;
const baseSetToString$1 = baseSetToString;
var setToString = shortOut(baseSetToString$1);
function arrayEach(a, u) {
  for (var c = -1, l = a == null ? 0 : a.length; ++c < l && u(a[c], c, a) !== !1; )
    ;
  return a;
}
function baseFindIndex$1(a, u, c, l) {
  for (var v = a.length, p = c + (l ? 1 : -1); l ? p-- : ++p < v; )
    if (u(a[p], p, a))
      return p;
  return -1;
}
function baseIsNaN$1(a) {
  return a !== a;
}
function strictIndexOf(a, u, c) {
  for (var l = c - 1, v = a.length; ++l < v; )
    if (a[l] === u)
      return l;
  return -1;
}
function baseIndexOf$1(a, u, c) {
  return u === u ? strictIndexOf(a, u, c) : baseFindIndex$1(a, baseIsNaN$1, c);
}
var MAX_SAFE_INTEGER$2 = 9007199254740991, reIsUint$1 = /^(?:0|[1-9]\d*)$/;
function isIndex$1(a, u) {
  var c = typeof a;
  return u = u ?? MAX_SAFE_INTEGER$2, !!u && (c == "number" || c != "symbol" && reIsUint$1.test(a)) && a > -1 && a % 1 == 0 && a < u;
}
function baseAssignValue(a, u, c) {
  u == "__proto__" && defineProperty ? defineProperty(a, u, {
    configurable: !0,
    enumerable: !0,
    value: c,
    writable: !0
  }) : a[u] = c;
}
function eq(a, u) {
  return a === u || a !== a && u !== u;
}
var objectProto$j = Object.prototype, hasOwnProperty$d = objectProto$j.hasOwnProperty;
function assignValue(a, u, c) {
  var l = a[u];
  (!(hasOwnProperty$d.call(a, u) && eq(l, c)) || c === void 0 && !(u in a)) && baseAssignValue(a, u, c);
}
function copyObject(a, u, c, l) {
  var v = !c;
  c || (c = {});
  for (var p = -1, _ = u.length; ++p < _; ) {
    var k = u[p], O = l ? l(c[k], a[k], k, c, a) : void 0;
    O === void 0 && (O = a[k]), v ? baseAssignValue(c, k, O) : assignValue(c, k, O);
  }
  return c;
}
var nativeMax$2 = Math.max;
function overRest(a, u, c) {
  return u = nativeMax$2(u === void 0 ? a.length - 1 : u, 0), function() {
    for (var l = arguments, v = -1, p = nativeMax$2(l.length - u, 0), _ = Array(p); ++v < p; )
      _[v] = l[u + v];
    v = -1;
    for (var k = Array(u + 1); ++v < u; )
      k[v] = l[v];
    return k[u] = c(_), apply(a, this, k);
  };
}
function baseRest(a, u) {
  return setToString(overRest(a, u, identity), a + "");
}
var MAX_SAFE_INTEGER$1 = 9007199254740991;
function isLength$1(a) {
  return typeof a == "number" && a > -1 && a % 1 == 0 && a <= MAX_SAFE_INTEGER$1;
}
function isArrayLike$1(a) {
  return a != null && isLength$1(a.length) && !isFunction$2(a);
}
function isIterateeCall(a, u, c) {
  if (!isObject$8(c))
    return !1;
  var l = typeof u;
  return (l == "number" ? isArrayLike$1(c) && isIndex$1(u, c.length) : l == "string" && u in c) ? eq(c[u], a) : !1;
}
var objectProto$i = Object.prototype;
function isPrototype$1(a) {
  var u = a && a.constructor, c = typeof u == "function" && u.prototype || objectProto$i;
  return a === c;
}
function baseTimes$1(a, u) {
  for (var c = -1, l = Array(a); ++c < a; )
    l[c] = u(c);
  return l;
}
var argsTag$4 = "[object Arguments]";
function baseIsArguments(a) {
  return isObjectLike$7(a) && baseGetTag(a) == argsTag$4;
}
var objectProto$h = Object.prototype, hasOwnProperty$c = objectProto$h.hasOwnProperty, propertyIsEnumerable$2 = objectProto$h.propertyIsEnumerable, isArguments$2 = baseIsArguments(/* @__PURE__ */ function() {
  return arguments;
}()) ? baseIsArguments : function(a) {
  return isObjectLike$7(a) && hasOwnProperty$c.call(a, "callee") && !propertyIsEnumerable$2.call(a, "callee");
};
function stubFalse() {
  return !1;
}
var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports, freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module, moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2, Buffer$N = moduleExports$2 ? root.Buffer : void 0, nativeIsBuffer = Buffer$N ? Buffer$N.isBuffer : void 0, isBuffer$1 = nativeIsBuffer || stubFalse, argsTag$3 = "[object Arguments]", arrayTag$2 = "[object Array]", boolTag$4 = "[object Boolean]", dateTag$3 = "[object Date]", errorTag$2 = "[object Error]", funcTag$2 = "[object Function]", mapTag$5 = "[object Map]", numberTag$4 = "[object Number]", objectTag$5 = "[object Object]", regexpTag$3 = "[object RegExp]", setTag$5 = "[object Set]", stringTag$5 = "[object String]", weakMapTag$2 = "[object WeakMap]", arrayBufferTag$3 = "[object ArrayBuffer]", dataViewTag$4 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]", typedArrayTags = {};
typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = !0;
typedArrayTags[argsTag$3] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$3] = typedArrayTags[boolTag$4] = typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$3] = typedArrayTags[errorTag$2] = typedArrayTags[funcTag$2] = typedArrayTags[mapTag$5] = typedArrayTags[numberTag$4] = typedArrayTags[objectTag$5] = typedArrayTags[regexpTag$3] = typedArrayTags[setTag$5] = typedArrayTags[stringTag$5] = typedArrayTags[weakMapTag$2] = !1;
function baseIsTypedArray(a) {
  return isObjectLike$7(a) && isLength$1(a.length) && !!typedArrayTags[baseGetTag(a)];
}
function baseUnary(a) {
  return function(u) {
    return a(u);
  };
}
var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports, freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module, moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1, freeProcess = moduleExports$1 && freeGlobal.process, nodeUtil = function() {
  try {
    var a = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
    return a || freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch {
  }
}(), nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray, isTypedArray$1 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray, objectProto$g = Object.prototype, hasOwnProperty$b = objectProto$g.hasOwnProperty;
function arrayLikeKeys$1(a, u) {
  var c = isArray$4(a), l = !c && isArguments$2(a), v = !c && !l && isBuffer$1(a), p = !c && !l && !v && isTypedArray$1(a), _ = c || l || v || p, k = _ ? baseTimes$1(a.length, String) : [], O = k.length;
  for (var D in a)
    (u || hasOwnProperty$b.call(a, D)) && !(_ && // Safari 9 has enumerable `arguments.length` in strict mode.
    (D == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    v && (D == "offset" || D == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    p && (D == "buffer" || D == "byteLength" || D == "byteOffset") || // Skip index properties.
    isIndex$1(D, O))) && k.push(D);
  return k;
}
function overArg$2(a, u) {
  return function(c) {
    return a(u(c));
  };
}
var nativeKeys$1 = overArg$2(Object.keys, Object), objectProto$f = Object.prototype, hasOwnProperty$a = objectProto$f.hasOwnProperty;
function baseKeys$1(a) {
  if (!isPrototype$1(a))
    return nativeKeys$1(a);
  var u = [];
  for (var c in Object(a))
    hasOwnProperty$a.call(a, c) && c != "constructor" && u.push(c);
  return u;
}
function keys$2(a) {
  return isArrayLike$1(a) ? arrayLikeKeys$1(a) : baseKeys$1(a);
}
function nativeKeysIn(a) {
  var u = [];
  if (a != null)
    for (var c in Object(a))
      u.push(c);
  return u;
}
var objectProto$e = Object.prototype, hasOwnProperty$9 = objectProto$e.hasOwnProperty;
function baseKeysIn(a) {
  if (!isObject$8(a))
    return nativeKeysIn(a);
  var u = isPrototype$1(a), c = [];
  for (var l in a)
    l == "constructor" && (u || !hasOwnProperty$9.call(a, l)) || c.push(l);
  return c;
}
function keysIn(a) {
  return isArrayLike$1(a) ? arrayLikeKeys$1(a, !0) : baseKeysIn(a);
}
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
function isKey(a, u) {
  if (isArray$4(a))
    return !1;
  var c = typeof a;
  return c == "number" || c == "symbol" || c == "boolean" || a == null || isSymbol$3(a) ? !0 : reIsPlainProp.test(a) || !reIsDeepProp.test(a) || u != null && a in Object(u);
}
var nativeCreate = getNative(Object, "create");
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {}, this.size = 0;
}
function hashDelete(a) {
  var u = this.has(a) && delete this.__data__[a];
  return this.size -= u ? 1 : 0, u;
}
var HASH_UNDEFINED$2 = "__lodash_hash_undefined__", objectProto$d = Object.prototype, hasOwnProperty$8 = objectProto$d.hasOwnProperty;
function hashGet(a) {
  var u = this.__data__;
  if (nativeCreate) {
    var c = u[a];
    return c === HASH_UNDEFINED$2 ? void 0 : c;
  }
  return hasOwnProperty$8.call(u, a) ? u[a] : void 0;
}
var objectProto$c = Object.prototype, hasOwnProperty$7 = objectProto$c.hasOwnProperty;
function hashHas(a) {
  var u = this.__data__;
  return nativeCreate ? u[a] !== void 0 : hasOwnProperty$7.call(u, a);
}
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
function hashSet(a, u) {
  var c = this.__data__;
  return this.size += this.has(a) ? 0 : 1, c[a] = nativeCreate && u === void 0 ? HASH_UNDEFINED$1 : u, this;
}
function Hash$8(a) {
  var u = -1, c = a == null ? 0 : a.length;
  for (this.clear(); ++u < c; ) {
    var l = a[u];
    this.set(l[0], l[1]);
  }
}
Hash$8.prototype.clear = hashClear;
Hash$8.prototype.delete = hashDelete;
Hash$8.prototype.get = hashGet;
Hash$8.prototype.has = hashHas;
Hash$8.prototype.set = hashSet;
function listCacheClear() {
  this.__data__ = [], this.size = 0;
}
function assocIndexOf(a, u) {
  for (var c = a.length; c--; )
    if (eq(a[c][0], u))
      return c;
  return -1;
}
var arrayProto$1 = Array.prototype, splice$1 = arrayProto$1.splice;
function listCacheDelete(a) {
  var u = this.__data__, c = assocIndexOf(u, a);
  if (c < 0)
    return !1;
  var l = u.length - 1;
  return c == l ? u.pop() : splice$1.call(u, c, 1), --this.size, !0;
}
function listCacheGet(a) {
  var u = this.__data__, c = assocIndexOf(u, a);
  return c < 0 ? void 0 : u[c][1];
}
function listCacheHas(a) {
  return assocIndexOf(this.__data__, a) > -1;
}
function listCacheSet(a, u) {
  var c = this.__data__, l = assocIndexOf(c, a);
  return l < 0 ? (++this.size, c.push([a, u])) : c[l][1] = u, this;
}
function ListCache(a) {
  var u = -1, c = a == null ? 0 : a.length;
  for (this.clear(); ++u < c; ) {
    var l = a[u];
    this.set(l[0], l[1]);
  }
}
ListCache.prototype.clear = listCacheClear;
ListCache.prototype.delete = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
var Map$1 = getNative(root, "Map");
function mapCacheClear() {
  this.size = 0, this.__data__ = {
    hash: new Hash$8(),
    map: new (Map$1 || ListCache)(),
    string: new Hash$8()
  };
}
function isKeyable(a) {
  var u = typeof a;
  return u == "string" || u == "number" || u == "symbol" || u == "boolean" ? a !== "__proto__" : a === null;
}
function getMapData(a, u) {
  var c = a.__data__;
  return isKeyable(u) ? c[typeof u == "string" ? "string" : "hash"] : c.map;
}
function mapCacheDelete(a) {
  var u = getMapData(this, a).delete(a);
  return this.size -= u ? 1 : 0, u;
}
function mapCacheGet(a) {
  return getMapData(this, a).get(a);
}
function mapCacheHas(a) {
  return getMapData(this, a).has(a);
}
function mapCacheSet(a, u) {
  var c = getMapData(this, a), l = c.size;
  return c.set(a, u), this.size += c.size == l ? 0 : 1, this;
}
function MapCache(a) {
  var u = -1, c = a == null ? 0 : a.length;
  for (this.clear(); ++u < c; ) {
    var l = a[u];
    this.set(l[0], l[1]);
  }
}
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype.delete = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
var FUNC_ERROR_TEXT$2 = "Expected a function";
function memoize(a, u) {
  if (typeof a != "function" || u != null && typeof u != "function")
    throw new TypeError(FUNC_ERROR_TEXT$2);
  var c = function() {
    var l = arguments, v = u ? u.apply(this, l) : l[0], p = c.cache;
    if (p.has(v))
      return p.get(v);
    var _ = a.apply(this, l);
    return c.cache = p.set(v, _) || p, _;
  };
  return c.cache = new (memoize.Cache || MapCache)(), c;
}
memoize.Cache = MapCache;
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(a) {
  var u = memoize(a, function(l) {
    return c.size === MAX_MEMOIZE_SIZE && c.clear(), l;
  }), c = u.cache;
  return u;
}
var rePropName$1 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, reEscapeChar$1 = /\\(\\)?/g, stringToPath$1 = memoizeCapped(function(a) {
  var u = [];
  return a.charCodeAt(0) === 46 && u.push(""), a.replace(rePropName$1, function(c, l, v, p) {
    u.push(v ? p.replace(reEscapeChar$1, "$1") : l || c);
  }), u;
});
function toString$3(a) {
  return a == null ? "" : baseToString(a);
}
function castPath(a, u) {
  return isArray$4(a) ? a : isKey(a, u) ? [a] : stringToPath$1(toString$3(a));
}
var INFINITY$3 = 1 / 0;
function toKey(a) {
  if (typeof a == "string" || isSymbol$3(a))
    return a;
  var u = a + "";
  return u == "0" && 1 / a == -INFINITY$3 ? "-0" : u;
}
function baseGet(a, u) {
  u = castPath(u, a);
  for (var c = 0, l = u.length; a != null && c < l; )
    a = a[toKey(u[c++])];
  return c && c == l ? a : void 0;
}
function get(a, u, c) {
  var l = a == null ? void 0 : baseGet(a, u);
  return l === void 0 ? c : l;
}
function arrayPush(a, u) {
  for (var c = -1, l = u.length, v = a.length; ++c < l; )
    a[v + c] = u[c];
  return a;
}
var spreadableSymbol = Symbol$1 ? Symbol$1.isConcatSpreadable : void 0;
function isFlattenable(a) {
  return isArray$4(a) || isArguments$2(a) || !!(spreadableSymbol && a && a[spreadableSymbol]);
}
function baseFlatten(a, u, c, l, v) {
  var p = -1, _ = a.length;
  for (c || (c = isFlattenable), v || (v = []); ++p < _; ) {
    var k = a[p];
    u > 0 && c(k) ? u > 1 ? baseFlatten(k, u - 1, c, l, v) : arrayPush(v, k) : l || (v[v.length] = k);
  }
  return v;
}
function flatten(a) {
  var u = a == null ? 0 : a.length;
  return u ? baseFlatten(a, 1) : [];
}
function flatRest(a) {
  return setToString(overRest(a, void 0, flatten), a + "");
}
var getPrototype$1 = overArg$2(Object.getPrototypeOf, Object);
const getPrototype$2 = getPrototype$1;
var objectTag$4 = "[object Object]", funcProto$1 = Function.prototype, objectProto$b = Object.prototype, funcToString$1 = funcProto$1.toString, hasOwnProperty$6 = objectProto$b.hasOwnProperty, objectCtorString$1 = funcToString$1.call(Object);
function isPlainObject$3(a) {
  if (!isObjectLike$7(a) || baseGetTag(a) != objectTag$4)
    return !1;
  var u = getPrototype$2(a);
  if (u === null)
    return !0;
  var c = hasOwnProperty$6.call(u, "constructor") && u.constructor;
  return typeof c == "function" && c instanceof c && funcToString$1.call(c) == objectCtorString$1;
}
function baseSlice(a, u, c) {
  var l = -1, v = a.length;
  u < 0 && (u = -u > v ? 0 : v + u), c = c > v ? v : c, c < 0 && (c += v), v = u > c ? 0 : c - u >>> 0, u >>>= 0;
  for (var p = Array(v); ++l < v; )
    p[l] = a[l + u];
  return p;
}
function castSlice(a, u, c) {
  var l = a.length;
  return c = c === void 0 ? l : c, !u && c >= l ? a : baseSlice(a, u, c);
}
var rsAstralRange$2 = "\\ud800-\\udfff", rsComboMarksRange$3 = "\\u0300-\\u036f", reComboHalfMarksRange$3 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$3 = "\\u20d0-\\u20ff", rsComboRange$3 = rsComboMarksRange$3 + reComboHalfMarksRange$3 + rsComboSymbolsRange$3, rsVarRange$2 = "\\ufe0e\\ufe0f", rsZWJ$2 = "\\u200d", reHasUnicode = RegExp("[" + rsZWJ$2 + rsAstralRange$2 + rsComboRange$3 + rsVarRange$2 + "]");
function hasUnicode(a) {
  return reHasUnicode.test(a);
}
function asciiToArray(a) {
  return a.split("");
}
var rsAstralRange$1 = "\\ud800-\\udfff", rsComboMarksRange$2 = "\\u0300-\\u036f", reComboHalfMarksRange$2 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$2 = "\\u20d0-\\u20ff", rsComboRange$2 = rsComboMarksRange$2 + reComboHalfMarksRange$2 + rsComboSymbolsRange$2, rsVarRange$1 = "\\ufe0e\\ufe0f", rsAstral = "[" + rsAstralRange$1 + "]", rsCombo$2 = "[" + rsComboRange$2 + "]", rsFitz$1 = "\\ud83c[\\udffb-\\udfff]", rsModifier$1 = "(?:" + rsCombo$2 + "|" + rsFitz$1 + ")", rsNonAstral$1 = "[^" + rsAstralRange$1 + "]", rsRegional$1 = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair$1 = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsZWJ$1 = "\\u200d", reOptMod$1 = rsModifier$1 + "?", rsOptVar$1 = "[" + rsVarRange$1 + "]?", rsOptJoin$1 = "(?:" + rsZWJ$1 + "(?:" + [rsNonAstral$1, rsRegional$1, rsSurrPair$1].join("|") + ")" + rsOptVar$1 + reOptMod$1 + ")*", rsSeq$1 = rsOptVar$1 + reOptMod$1 + rsOptJoin$1, rsSymbol = "(?:" + [rsNonAstral$1 + rsCombo$2 + "?", rsCombo$2, rsRegional$1, rsSurrPair$1, rsAstral].join("|") + ")", reUnicode = RegExp(rsFitz$1 + "(?=" + rsFitz$1 + ")|" + rsSymbol + rsSeq$1, "g");
function unicodeToArray(a) {
  return a.match(reUnicode) || [];
}
function stringToArray(a) {
  return hasUnicode(a) ? unicodeToArray(a) : asciiToArray(a);
}
function createCaseFirst(a) {
  return function(u) {
    u = toString$3(u);
    var c = hasUnicode(u) ? stringToArray(u) : void 0, l = c ? c[0] : u.charAt(0), v = c ? castSlice(c, 1).join("") : u.slice(1);
    return l[a]() + v;
  };
}
var upperFirst = createCaseFirst("toUpperCase");
function capitalize(a) {
  return upperFirst(toString$3(a).toLowerCase());
}
function arrayReduce(a, u, c, l) {
  var v = -1, p = a == null ? 0 : a.length;
  for (l && p && (c = a[++v]); ++v < p; )
    c = u(c, a[v], v, a);
  return c;
}
function basePropertyOf(a) {
  return function(u) {
    return a == null ? void 0 : a[u];
  };
}
var deburredLetters = {
  // Latin-1 Supplement block.
  À: "A",
  Á: "A",
  Â: "A",
  Ã: "A",
  Ä: "A",
  Å: "A",
  à: "a",
  á: "a",
  â: "a",
  ã: "a",
  ä: "a",
  å: "a",
  Ç: "C",
  ç: "c",
  Ð: "D",
  ð: "d",
  È: "E",
  É: "E",
  Ê: "E",
  Ë: "E",
  è: "e",
  é: "e",
  ê: "e",
  ë: "e",
  Ì: "I",
  Í: "I",
  Î: "I",
  Ï: "I",
  ì: "i",
  í: "i",
  î: "i",
  ï: "i",
  Ñ: "N",
  ñ: "n",
  Ò: "O",
  Ó: "O",
  Ô: "O",
  Õ: "O",
  Ö: "O",
  Ø: "O",
  ò: "o",
  ó: "o",
  ô: "o",
  õ: "o",
  ö: "o",
  ø: "o",
  Ù: "U",
  Ú: "U",
  Û: "U",
  Ü: "U",
  ù: "u",
  ú: "u",
  û: "u",
  ü: "u",
  Ý: "Y",
  ý: "y",
  ÿ: "y",
  Æ: "Ae",
  æ: "ae",
  Þ: "Th",
  þ: "th",
  ß: "ss",
  // Latin Extended-A block.
  Ā: "A",
  Ă: "A",
  Ą: "A",
  ā: "a",
  ă: "a",
  ą: "a",
  Ć: "C",
  Ĉ: "C",
  Ċ: "C",
  Č: "C",
  ć: "c",
  ĉ: "c",
  ċ: "c",
  č: "c",
  Ď: "D",
  Đ: "D",
  ď: "d",
  đ: "d",
  Ē: "E",
  Ĕ: "E",
  Ė: "E",
  Ę: "E",
  Ě: "E",
  ē: "e",
  ĕ: "e",
  ė: "e",
  ę: "e",
  ě: "e",
  Ĝ: "G",
  Ğ: "G",
  Ġ: "G",
  Ģ: "G",
  ĝ: "g",
  ğ: "g",
  ġ: "g",
  ģ: "g",
  Ĥ: "H",
  Ħ: "H",
  ĥ: "h",
  ħ: "h",
  Ĩ: "I",
  Ī: "I",
  Ĭ: "I",
  Į: "I",
  İ: "I",
  ĩ: "i",
  ī: "i",
  ĭ: "i",
  į: "i",
  ı: "i",
  Ĵ: "J",
  ĵ: "j",
  Ķ: "K",
  ķ: "k",
  ĸ: "k",
  Ĺ: "L",
  Ļ: "L",
  Ľ: "L",
  Ŀ: "L",
  Ł: "L",
  ĺ: "l",
  ļ: "l",
  ľ: "l",
  ŀ: "l",
  ł: "l",
  Ń: "N",
  Ņ: "N",
  Ň: "N",
  Ŋ: "N",
  ń: "n",
  ņ: "n",
  ň: "n",
  ŋ: "n",
  Ō: "O",
  Ŏ: "O",
  Ő: "O",
  ō: "o",
  ŏ: "o",
  ő: "o",
  Ŕ: "R",
  Ŗ: "R",
  Ř: "R",
  ŕ: "r",
  ŗ: "r",
  ř: "r",
  Ś: "S",
  Ŝ: "S",
  Ş: "S",
  Š: "S",
  ś: "s",
  ŝ: "s",
  ş: "s",
  š: "s",
  Ţ: "T",
  Ť: "T",
  Ŧ: "T",
  ţ: "t",
  ť: "t",
  ŧ: "t",
  Ũ: "U",
  Ū: "U",
  Ŭ: "U",
  Ů: "U",
  Ű: "U",
  Ų: "U",
  ũ: "u",
  ū: "u",
  ŭ: "u",
  ů: "u",
  ű: "u",
  ų: "u",
  Ŵ: "W",
  ŵ: "w",
  Ŷ: "Y",
  ŷ: "y",
  Ÿ: "Y",
  Ź: "Z",
  Ż: "Z",
  Ž: "Z",
  ź: "z",
  ż: "z",
  ž: "z",
  Ĳ: "IJ",
  ĳ: "ij",
  Œ: "Oe",
  œ: "oe",
  ŉ: "'n",
  ſ: "s"
}, deburrLetter = basePropertyOf(deburredLetters);
const deburrLetter$1 = deburrLetter;
var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, rsComboMarksRange$1 = "\\u0300-\\u036f", reComboHalfMarksRange$1 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$1 = "\\u20d0-\\u20ff", rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1, rsCombo$1 = "[" + rsComboRange$1 + "]", reComboMark = RegExp(rsCombo$1, "g");
function deburr(a) {
  return a = toString$3(a), a && a.replace(reLatin, deburrLetter$1).replace(reComboMark, "");
}
var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
function asciiWords(a) {
  return a.match(reAsciiWord) || [];
}
var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
function hasUnicodeWord(a) {
  return reHasUnicodeWord.test(a);
}
var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange, rsApos$1 = "['’]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d", rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos$1 + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos$1 + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, reUnicodeWord = RegExp([
  rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
  rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
  rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
  rsUpper + "+" + rsOptContrUpper,
  rsOrdUpper,
  rsOrdLower,
  rsDigits,
  rsEmoji
].join("|"), "g");
function unicodeWords(a) {
  return a.match(reUnicodeWord) || [];
}
function words(a, u, c) {
  return a = toString$3(a), u = c ? void 0 : u, u === void 0 ? hasUnicodeWord(a) ? unicodeWords(a) : asciiWords(a) : a.match(u) || [];
}
var rsApos = "['’]", reApos = RegExp(rsApos, "g");
function createCompounder(a) {
  return function(u) {
    return arrayReduce(words(deburr(u).replace(reApos, "")), a, "");
  };
}
var camelCase$2 = createCompounder(function(a, u, c) {
  return u = u.toLowerCase(), a + (c ? capitalize(u) : u);
});
const camelCase$3 = camelCase$2;
function stackClear() {
  this.__data__ = new ListCache(), this.size = 0;
}
function stackDelete(a) {
  var u = this.__data__, c = u.delete(a);
  return this.size = u.size, c;
}
function stackGet(a) {
  return this.__data__.get(a);
}
function stackHas(a) {
  return this.__data__.has(a);
}
var LARGE_ARRAY_SIZE = 200;
function stackSet(a, u) {
  var c = this.__data__;
  if (c instanceof ListCache) {
    var l = c.__data__;
    if (!Map$1 || l.length < LARGE_ARRAY_SIZE - 1)
      return l.push([a, u]), this.size = ++c.size, this;
    c = this.__data__ = new MapCache(l);
  }
  return c.set(a, u), this.size = c.size, this;
}
function Stack(a) {
  var u = this.__data__ = new ListCache(a);
  this.size = u.size;
}
Stack.prototype.clear = stackClear;
Stack.prototype.delete = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
function baseAssign(a, u) {
  return a && copyObject(u, keys$2(u), a);
}
function baseAssignIn(a, u) {
  return a && copyObject(u, keysIn(u), a);
}
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports, freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module, moduleExports = freeModule && freeModule.exports === freeExports, Buffer$M = moduleExports ? root.Buffer : void 0, allocUnsafe = Buffer$M ? Buffer$M.allocUnsafe : void 0;
function cloneBuffer(a, u) {
  if (u)
    return a.slice();
  var c = a.length, l = allocUnsafe ? allocUnsafe(c) : new a.constructor(c);
  return a.copy(l), l;
}
function arrayFilter(a, u) {
  for (var c = -1, l = a == null ? 0 : a.length, v = 0, p = []; ++c < l; ) {
    var _ = a[c];
    u(_, c, a) && (p[v++] = _);
  }
  return p;
}
function stubArray() {
  return [];
}
var objectProto$a = Object.prototype, propertyIsEnumerable$1 = objectProto$a.propertyIsEnumerable, nativeGetSymbols$1 = Object.getOwnPropertySymbols, getSymbols = nativeGetSymbols$1 ? function(a) {
  return a == null ? [] : (a = Object(a), arrayFilter(nativeGetSymbols$1(a), function(u) {
    return propertyIsEnumerable$1.call(a, u);
  }));
} : stubArray;
function copySymbols(a, u) {
  return copyObject(a, getSymbols(a), u);
}
var nativeGetSymbols = Object.getOwnPropertySymbols, getSymbolsIn = nativeGetSymbols ? function(a) {
  for (var u = []; a; )
    arrayPush(u, getSymbols(a)), a = getPrototype$2(a);
  return u;
} : stubArray;
function copySymbolsIn(a, u) {
  return copyObject(a, getSymbolsIn(a), u);
}
function baseGetAllKeys(a, u, c) {
  var l = u(a);
  return isArray$4(a) ? l : arrayPush(l, c(a));
}
function getAllKeys(a) {
  return baseGetAllKeys(a, keys$2, getSymbols);
}
function getAllKeysIn(a) {
  return baseGetAllKeys(a, keysIn, getSymbolsIn);
}
var DataView$1 = getNative(root, "DataView"), Promise$1 = getNative(root, "Promise"), Set$1 = getNative(root, "Set"), mapTag$4 = "[object Map]", objectTag$3 = "[object Object]", promiseTag = "[object Promise]", setTag$4 = "[object Set]", weakMapTag$1 = "[object WeakMap]", dataViewTag$3 = "[object DataView]", dataViewCtorString = toSource(DataView$1), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap$2), getTag = baseGetTag;
(DataView$1 && getTag(new DataView$1(new ArrayBuffer(1))) != dataViewTag$3 || Map$1 && getTag(new Map$1()) != mapTag$4 || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set$1 && getTag(new Set$1()) != setTag$4 || WeakMap$2 && getTag(new WeakMap$2()) != weakMapTag$1) && (getTag = function(a) {
  var u = baseGetTag(a), c = u == objectTag$3 ? a.constructor : void 0, l = c ? toSource(c) : "";
  if (l)
    switch (l) {
      case dataViewCtorString:
        return dataViewTag$3;
      case mapCtorString:
        return mapTag$4;
      case promiseCtorString:
        return promiseTag;
      case setCtorString:
        return setTag$4;
      case weakMapCtorString:
        return weakMapTag$1;
    }
  return u;
});
const getTag$1 = getTag;
var objectProto$9 = Object.prototype, hasOwnProperty$5 = objectProto$9.hasOwnProperty;
function initCloneArray(a) {
  var u = a.length, c = new a.constructor(u);
  return u && typeof a[0] == "string" && hasOwnProperty$5.call(a, "index") && (c.index = a.index, c.input = a.input), c;
}
var Uint8Array$1 = root.Uint8Array;
function cloneArrayBuffer(a) {
  var u = new a.constructor(a.byteLength);
  return new Uint8Array$1(u).set(new Uint8Array$1(a)), u;
}
function cloneDataView(a, u) {
  var c = u ? cloneArrayBuffer(a.buffer) : a.buffer;
  return new a.constructor(c, a.byteOffset, a.byteLength);
}
var reFlags = /\w*$/;
function cloneRegExp(a) {
  var u = new a.constructor(a.source, reFlags.exec(a));
  return u.lastIndex = a.lastIndex, u;
}
var symbolProto$1 = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : void 0;
function cloneSymbol(a) {
  return symbolValueOf$1 ? Object(symbolValueOf$1.call(a)) : {};
}
function cloneTypedArray(a, u) {
  var c = u ? cloneArrayBuffer(a.buffer) : a.buffer;
  return new a.constructor(c, a.byteOffset, a.length);
}
var boolTag$3 = "[object Boolean]", dateTag$2 = "[object Date]", mapTag$3 = "[object Map]", numberTag$3 = "[object Number]", regexpTag$2 = "[object RegExp]", setTag$3 = "[object Set]", stringTag$4 = "[object String]", symbolTag$5 = "[object Symbol]", arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
function initCloneByTag(a, u, c) {
  var l = a.constructor;
  switch (u) {
    case arrayBufferTag$2:
      return cloneArrayBuffer(a);
    case boolTag$3:
    case dateTag$2:
      return new l(+a);
    case dataViewTag$2:
      return cloneDataView(a, c);
    case float32Tag$1:
    case float64Tag$1:
    case int8Tag$1:
    case int16Tag$1:
    case int32Tag$1:
    case uint8Tag$1:
    case uint8ClampedTag$1:
    case uint16Tag$1:
    case uint32Tag$1:
      return cloneTypedArray(a, c);
    case mapTag$3:
      return new l();
    case numberTag$3:
    case stringTag$4:
      return new l(a);
    case regexpTag$2:
      return cloneRegExp(a);
    case setTag$3:
      return new l();
    case symbolTag$5:
      return cloneSymbol(a);
  }
}
function initCloneObject(a) {
  return typeof a.constructor == "function" && !isPrototype$1(a) ? baseCreate(getPrototype$2(a)) : {};
}
var mapTag$2 = "[object Map]";
function baseIsMap(a) {
  return isObjectLike$7(a) && getTag$1(a) == mapTag$2;
}
var nodeIsMap = nodeUtil && nodeUtil.isMap, isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap, setTag$2 = "[object Set]";
function baseIsSet(a) {
  return isObjectLike$7(a) && getTag$1(a) == setTag$2;
}
var nodeIsSet = nodeUtil && nodeUtil.isSet, isSet$2 = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet, CLONE_DEEP_FLAG$3 = 1, CLONE_FLAT_FLAG$1 = 2, CLONE_SYMBOLS_FLAG$2 = 4, argsTag$2 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$2 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", funcTag$1 = "[object Function]", genTag$1 = "[object GeneratorFunction]", mapTag$1 = "[object Map]", numberTag$2 = "[object Number]", objectTag$2 = "[object Object]", regexpTag$1 = "[object RegExp]", setTag$1 = "[object Set]", stringTag$3 = "[object String]", symbolTag$4 = "[object Symbol]", weakMapTag = "[object WeakMap]", arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]", cloneableTags = {};
cloneableTags[argsTag$2] = cloneableTags[arrayTag$1] = cloneableTags[arrayBufferTag$1] = cloneableTags[dataViewTag$1] = cloneableTags[boolTag$2] = cloneableTags[dateTag$1] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag$1] = cloneableTags[numberTag$2] = cloneableTags[objectTag$2] = cloneableTags[regexpTag$1] = cloneableTags[setTag$1] = cloneableTags[stringTag$3] = cloneableTags[symbolTag$4] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = !0;
cloneableTags[errorTag$1] = cloneableTags[funcTag$1] = cloneableTags[weakMapTag] = !1;
function baseClone(a, u, c, l, v, p) {
  var _, k = u & CLONE_DEEP_FLAG$3, O = u & CLONE_FLAT_FLAG$1, D = u & CLONE_SYMBOLS_FLAG$2;
  if (c && (_ = v ? c(a, l, v, p) : c(a)), _ !== void 0)
    return _;
  if (!isObject$8(a))
    return a;
  var F = isArray$4(a);
  if (F) {
    if (_ = initCloneArray(a), !k)
      return copyArray(a, _);
  } else {
    var z = getTag$1(a), j = z == funcTag$1 || z == genTag$1;
    if (isBuffer$1(a))
      return cloneBuffer(a, k);
    if (z == objectTag$2 || z == argsTag$2 || j && !v) {
      if (_ = O || j ? {} : initCloneObject(a), !k)
        return O ? copySymbolsIn(a, baseAssignIn(_, a)) : copySymbols(a, baseAssign(_, a));
    } else {
      if (!cloneableTags[z])
        return v ? a : {};
      _ = initCloneByTag(a, z, k);
    }
  }
  p || (p = new Stack());
  var ee = p.get(a);
  if (ee)
    return ee;
  p.set(a, _), isSet$2(a) ? a.forEach(function(Q) {
    _.add(baseClone(Q, u, c, Q, a, p));
  }) : isMap(a) && a.forEach(function(Q, ne) {
    _.set(ne, baseClone(Q, u, c, ne, a, p));
  });
  var X = D ? O ? getAllKeysIn : getAllKeys : O ? keysIn : keys$2, ae = F ? void 0 : X(a);
  return arrayEach(ae || a, function(Q, ne) {
    ae && (ne = Q, Q = a[ne]), assignValue(_, ne, baseClone(Q, u, c, ne, a, p));
  }), _;
}
var CLONE_DEEP_FLAG$2 = 1, CLONE_SYMBOLS_FLAG$1 = 4;
function cloneDeep$1(a) {
  return baseClone(a, CLONE_DEEP_FLAG$2 | CLONE_SYMBOLS_FLAG$1);
}
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function setCacheAdd(a) {
  return this.__data__.set(a, HASH_UNDEFINED), this;
}
function setCacheHas(a) {
  return this.__data__.has(a);
}
function SetCache(a) {
  var u = -1, c = a == null ? 0 : a.length;
  for (this.__data__ = new MapCache(); ++u < c; )
    this.add(a[u]);
}
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;
function arraySome(a, u) {
  for (var c = -1, l = a == null ? 0 : a.length; ++c < l; )
    if (u(a[c], c, a))
      return !0;
  return !1;
}
function cacheHas(a, u) {
  return a.has(u);
}
var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
function equalArrays(a, u, c, l, v, p) {
  var _ = c & COMPARE_PARTIAL_FLAG$5, k = a.length, O = u.length;
  if (k != O && !(_ && O > k))
    return !1;
  var D = p.get(a), F = p.get(u);
  if (D && F)
    return D == u && F == a;
  var z = -1, j = !0, ee = c & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : void 0;
  for (p.set(a, u), p.set(u, a); ++z < k; ) {
    var X = a[z], ae = u[z];
    if (l)
      var Q = _ ? l(ae, X, z, u, a, p) : l(X, ae, z, a, u, p);
    if (Q !== void 0) {
      if (Q)
        continue;
      j = !1;
      break;
    }
    if (ee) {
      if (!arraySome(u, function(ne, Z) {
        if (!cacheHas(ee, Z) && (X === ne || v(X, ne, c, l, p)))
          return ee.push(Z);
      })) {
        j = !1;
        break;
      }
    } else if (!(X === ae || v(X, ae, c, l, p))) {
      j = !1;
      break;
    }
  }
  return p.delete(a), p.delete(u), j;
}
function mapToArray(a) {
  var u = -1, c = Array(a.size);
  return a.forEach(function(l, v) {
    c[++u] = [v, l];
  }), c;
}
function setToArray(a) {
  var u = -1, c = Array(a.size);
  return a.forEach(function(l) {
    c[++u] = l;
  }), c;
}
var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2, boolTag$1 = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag = "[object Map]", numberTag$1 = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag$2 = "[object String]", symbolTag$3 = "[object Symbol]", arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
function equalByTag(a, u, c, l, v, p, _) {
  switch (c) {
    case dataViewTag:
      if (a.byteLength != u.byteLength || a.byteOffset != u.byteOffset)
        return !1;
      a = a.buffer, u = u.buffer;
    case arrayBufferTag:
      return !(a.byteLength != u.byteLength || !p(new Uint8Array$1(a), new Uint8Array$1(u)));
    case boolTag$1:
    case dateTag:
    case numberTag$1:
      return eq(+a, +u);
    case errorTag:
      return a.name == u.name && a.message == u.message;
    case regexpTag:
    case stringTag$2:
      return a == u + "";
    case mapTag:
      var k = mapToArray;
    case setTag:
      var O = l & COMPARE_PARTIAL_FLAG$4;
      if (k || (k = setToArray), a.size != u.size && !O)
        return !1;
      var D = _.get(a);
      if (D)
        return D == u;
      l |= COMPARE_UNORDERED_FLAG$2, _.set(a, u);
      var F = equalArrays(k(a), k(u), l, v, p, _);
      return _.delete(a), F;
    case symbolTag$3:
      if (symbolValueOf)
        return symbolValueOf.call(a) == symbolValueOf.call(u);
  }
  return !1;
}
var COMPARE_PARTIAL_FLAG$3 = 1, objectProto$8 = Object.prototype, hasOwnProperty$4 = objectProto$8.hasOwnProperty;
function equalObjects(a, u, c, l, v, p) {
  var _ = c & COMPARE_PARTIAL_FLAG$3, k = getAllKeys(a), O = k.length, D = getAllKeys(u), F = D.length;
  if (O != F && !_)
    return !1;
  for (var z = O; z--; ) {
    var j = k[z];
    if (!(_ ? j in u : hasOwnProperty$4.call(u, j)))
      return !1;
  }
  var ee = p.get(a), X = p.get(u);
  if (ee && X)
    return ee == u && X == a;
  var ae = !0;
  p.set(a, u), p.set(u, a);
  for (var Q = _; ++z < O; ) {
    j = k[z];
    var ne = a[j], Z = u[j];
    if (l)
      var de = _ ? l(Z, ne, j, u, a, p) : l(ne, Z, j, a, u, p);
    if (!(de === void 0 ? ne === Z || v(ne, Z, c, l, p) : de)) {
      ae = !1;
      break;
    }
    Q || (Q = j == "constructor");
  }
  if (ae && !Q) {
    var fe = a.constructor, Te = u.constructor;
    fe != Te && "constructor" in a && "constructor" in u && !(typeof fe == "function" && fe instanceof fe && typeof Te == "function" && Te instanceof Te) && (ae = !1);
  }
  return p.delete(a), p.delete(u), ae;
}
var COMPARE_PARTIAL_FLAG$2 = 1, argsTag$1 = "[object Arguments]", arrayTag = "[object Array]", objectTag$1 = "[object Object]", objectProto$7 = Object.prototype, hasOwnProperty$3 = objectProto$7.hasOwnProperty;
function baseIsEqualDeep(a, u, c, l, v, p) {
  var _ = isArray$4(a), k = isArray$4(u), O = _ ? arrayTag : getTag$1(a), D = k ? arrayTag : getTag$1(u);
  O = O == argsTag$1 ? objectTag$1 : O, D = D == argsTag$1 ? objectTag$1 : D;
  var F = O == objectTag$1, z = D == objectTag$1, j = O == D;
  if (j && isBuffer$1(a)) {
    if (!isBuffer$1(u))
      return !1;
    _ = !0, F = !1;
  }
  if (j && !F)
    return p || (p = new Stack()), _ || isTypedArray$1(a) ? equalArrays(a, u, c, l, v, p) : equalByTag(a, u, O, c, l, v, p);
  if (!(c & COMPARE_PARTIAL_FLAG$2)) {
    var ee = F && hasOwnProperty$3.call(a, "__wrapped__"), X = z && hasOwnProperty$3.call(u, "__wrapped__");
    if (ee || X) {
      var ae = ee ? a.value() : a, Q = X ? u.value() : u;
      return p || (p = new Stack()), v(ae, Q, c, l, p);
    }
  }
  return j ? (p || (p = new Stack()), equalObjects(a, u, c, l, v, p)) : !1;
}
function baseIsEqual(a, u, c, l, v) {
  return a === u ? !0 : a == null || u == null || !isObjectLike$7(a) && !isObjectLike$7(u) ? a !== a && u !== u : baseIsEqualDeep(a, u, c, l, baseIsEqual, v);
}
var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
function baseIsMatch(a, u, c, l) {
  var v = c.length, p = v, _ = !l;
  if (a == null)
    return !p;
  for (a = Object(a); v--; ) {
    var k = c[v];
    if (_ && k[2] ? k[1] !== a[k[0]] : !(k[0] in a))
      return !1;
  }
  for (; ++v < p; ) {
    k = c[v];
    var O = k[0], D = a[O], F = k[1];
    if (_ && k[2]) {
      if (D === void 0 && !(O in a))
        return !1;
    } else {
      var z = new Stack();
      if (l)
        var j = l(D, F, O, a, u, z);
      if (!(j === void 0 ? baseIsEqual(F, D, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, l, z) : j))
        return !1;
    }
  }
  return !0;
}
function isStrictComparable(a) {
  return a === a && !isObject$8(a);
}
function getMatchData(a) {
  for (var u = keys$2(a), c = u.length; c--; ) {
    var l = u[c], v = a[l];
    u[c] = [l, v, isStrictComparable(v)];
  }
  return u;
}
function matchesStrictComparable(a, u) {
  return function(c) {
    return c == null ? !1 : c[a] === u && (u !== void 0 || a in Object(c));
  };
}
function baseMatches(a) {
  var u = getMatchData(a);
  return u.length == 1 && u[0][2] ? matchesStrictComparable(u[0][0], u[0][1]) : function(c) {
    return c === a || baseIsMatch(c, a, u);
  };
}
function baseHasIn(a, u) {
  return a != null && u in Object(a);
}
function hasPath(a, u, c) {
  u = castPath(u, a);
  for (var l = -1, v = u.length, p = !1; ++l < v; ) {
    var _ = toKey(u[l]);
    if (!(p = a != null && c(a, _)))
      break;
    a = a[_];
  }
  return p || ++l != v ? p : (v = a == null ? 0 : a.length, !!v && isLength$1(v) && isIndex$1(_, v) && (isArray$4(a) || isArguments$2(a)));
}
function hasIn(a, u) {
  return a != null && hasPath(a, u, baseHasIn);
}
var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
function baseMatchesProperty(a, u) {
  return isKey(a) && isStrictComparable(u) ? matchesStrictComparable(toKey(a), u) : function(c) {
    var l = get(c, a);
    return l === void 0 && l === u ? hasIn(c, a) : baseIsEqual(u, l, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}
function baseProperty(a) {
  return function(u) {
    return u == null ? void 0 : u[a];
  };
}
function basePropertyDeep(a) {
  return function(u) {
    return baseGet(u, a);
  };
}
function property(a) {
  return isKey(a) ? baseProperty(toKey(a)) : basePropertyDeep(a);
}
function baseIteratee(a) {
  return typeof a == "function" ? a : a == null ? identity : typeof a == "object" ? isArray$4(a) ? baseMatchesProperty(a[0], a[1]) : baseMatches(a) : property(a);
}
function createBaseFor(a) {
  return function(u, c, l) {
    for (var v = -1, p = Object(u), _ = l(u), k = _.length; k--; ) {
      var O = _[a ? k : ++v];
      if (c(p[O], O, p) === !1)
        break;
    }
    return u;
  };
}
var baseFor = createBaseFor();
const baseFor$1 = baseFor;
function baseForOwn(a, u) {
  return a && baseFor$1(a, u, keys$2);
}
function createBaseEach(a, u) {
  return function(c, l) {
    if (c == null)
      return c;
    if (!isArrayLike$1(c))
      return a(c, l);
    for (var v = c.length, p = u ? v : -1, _ = Object(c); (u ? p-- : ++p < v) && l(_[p], p, _) !== !1; )
      ;
    return c;
  };
}
var baseEach = createBaseEach(baseForOwn), now = function() {
  return root.Date.now();
}, FUNC_ERROR_TEXT$1 = "Expected a function", nativeMax$1 = Math.max, nativeMin = Math.min;
function debounce(a, u, c) {
  var l, v, p, _, k, O, D = 0, F = !1, z = !1, j = !0;
  if (typeof a != "function")
    throw new TypeError(FUNC_ERROR_TEXT$1);
  u = toNumber$3(u) || 0, isObject$8(c) && (F = !!c.leading, z = "maxWait" in c, p = z ? nativeMax$1(toNumber$3(c.maxWait) || 0, u) : p, j = "trailing" in c ? !!c.trailing : j);
  function ee(Re) {
    var Le = l, be = v;
    return l = v = void 0, D = Re, _ = a.apply(be, Le), _;
  }
  function X(Re) {
    return D = Re, k = setTimeout(ne, u), F ? ee(Re) : _;
  }
  function ae(Re) {
    var Le = Re - O, be = Re - D, q = u - Le;
    return z ? nativeMin(q, p - be) : q;
  }
  function Q(Re) {
    var Le = Re - O, be = Re - D;
    return O === void 0 || Le >= u || Le < 0 || z && be >= p;
  }
  function ne() {
    var Re = now();
    if (Q(Re))
      return Z(Re);
    k = setTimeout(ne, ae(Re));
  }
  function Z(Re) {
    return k = void 0, j && l ? ee(Re) : (l = v = void 0, _);
  }
  function de() {
    k !== void 0 && clearTimeout(k), D = 0, l = O = v = k = void 0;
  }
  function fe() {
    return k === void 0 ? _ : Z(now());
  }
  function Te() {
    var Re = now(), Le = Q(Re);
    if (l = arguments, v = this, O = Re, Le) {
      if (k === void 0)
        return X(O);
      if (z)
        return clearTimeout(k), k = setTimeout(ne, u), ee(O);
    }
    return k === void 0 && (k = setTimeout(ne, u)), _;
  }
  return Te.cancel = de, Te.flush = fe, Te;
}
function last(a) {
  var u = a == null ? 0 : a.length;
  return u ? a[u - 1] : void 0;
}
function arrayEvery(a, u) {
  for (var c = -1, l = a == null ? 0 : a.length; ++c < l; )
    if (!u(a[c], c, a))
      return !1;
  return !0;
}
function baseEvery(a, u) {
  var c = !0;
  return baseEach(a, function(l, v, p) {
    return c = !!u(l, v, p), c;
  }), c;
}
function every(a, u, c) {
  var l = isArray$4(a) ? arrayEvery : baseEvery;
  return c && isIterateeCall(a, u, c) && (u = void 0), l(a, baseIteratee(u));
}
function baseMap(a, u) {
  var c = -1, l = isArrayLike$1(a) ? Array(a.length) : [];
  return baseEach(a, function(v, p, _) {
    l[++c] = u(v, p, _);
  }), l;
}
function parent(a, u) {
  return u.length < 2 ? a : baseGet(a, baseSlice(u, 0, -1));
}
function isEqual(a, u) {
  return baseIsEqual(a, u);
}
function isMatch(a, u) {
  return a === u || baseIsMatch(a, u, getMatchData(u));
}
var CLONE_DEEP_FLAG$1 = 1;
function iteratee(a) {
  return baseIteratee(typeof a == "function" ? a : baseClone(a, CLONE_DEEP_FLAG$1));
}
var kebabCase = createCompounder(function(a, u, c) {
  return a + (c ? "-" : "") + u.toLowerCase();
});
const kebabCase$1 = kebabCase;
function baseUnset(a, u) {
  return u = castPath(u, a), a = parent(a, u), a == null || delete a[toKey(last(u))];
}
function customOmitClone(a) {
  return isPlainObject$3(a) ? void 0 : a;
}
var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4, omit = flatRest(function(a, u) {
  var c = {};
  if (a == null)
    return c;
  var l = !1;
  u = arrayMap$1(u, function(p) {
    return p = castPath(p, a), l || (l = p.length > 1), p;
  }), copyObject(a, getAllKeysIn(a), c), l && (c = baseClone(c, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone));
  for (var v = u.length; v--; )
    baseUnset(c, u[v]);
  return c;
});
function baseSet(a, u, c, l) {
  if (!isObject$8(a))
    return a;
  u = castPath(u, a);
  for (var v = -1, p = u.length, _ = p - 1, k = a; k != null && ++v < p; ) {
    var O = toKey(u[v]), D = c;
    if (O === "__proto__" || O === "constructor" || O === "prototype")
      return a;
    if (v != _) {
      var F = k[O];
      D = l ? l(F, O, k) : void 0, D === void 0 && (D = isObject$8(F) ? F : isIndex$1(u[v + 1]) ? [] : {});
    }
    assignValue(k, O, D), k = k[O];
  }
  return a;
}
function basePickBy(a, u, c) {
  for (var l = -1, v = u.length, p = {}; ++l < v; ) {
    var _ = u[l], k = baseGet(a, _);
    c(k, _) && baseSet(p, castPath(_, a), k);
  }
  return p;
}
function baseSortBy(a, u) {
  var c = a.length;
  for (a.sort(u); c--; )
    a[c] = a[c].value;
  return a;
}
function compareAscending(a, u) {
  if (a !== u) {
    var c = a !== void 0, l = a === null, v = a === a, p = isSymbol$3(a), _ = u !== void 0, k = u === null, O = u === u, D = isSymbol$3(u);
    if (!k && !D && !p && a > u || p && _ && O && !k && !D || l && _ && O || !c && O || !v)
      return 1;
    if (!l && !p && !D && a < u || D && c && v && !l && !p || k && c && v || !_ && v || !O)
      return -1;
  }
  return 0;
}
function compareMultiple(a, u, c) {
  for (var l = -1, v = a.criteria, p = u.criteria, _ = v.length, k = c.length; ++l < _; ) {
    var O = compareAscending(v[l], p[l]);
    if (O) {
      if (l >= k)
        return O;
      var D = c[l];
      return O * (D == "desc" ? -1 : 1);
    }
  }
  return a.index - u.index;
}
function baseOrderBy(a, u, c) {
  u.length ? u = arrayMap$1(u, function(p) {
    return isArray$4(p) ? function(_) {
      return baseGet(_, p.length === 1 ? p[0] : p);
    } : p;
  }) : u = [identity];
  var l = -1;
  u = arrayMap$1(u, baseUnary(baseIteratee));
  var v = baseMap(a, function(p, _, k) {
    var O = arrayMap$1(u, function(D) {
      return D(p);
    });
    return { criteria: O, index: ++l, value: p };
  });
  return baseSortBy(v, function(p, _) {
    return compareMultiple(p, _, c);
  });
}
function basePick(a, u) {
  return basePickBy(a, u, function(c, l) {
    return hasIn(a, l);
  });
}
var pick = flatRest(function(a, u) {
  return a == null ? {} : basePick(a, u);
});
const pick$1 = pick;
function baseIndexOfWith(a, u, c, l) {
  for (var v = c - 1, p = a.length; ++v < p; )
    if (l(a[v], u))
      return v;
  return -1;
}
var arrayProto = Array.prototype, splice = arrayProto.splice;
function basePullAll(a, u, c, l) {
  var v = l ? baseIndexOfWith : baseIndexOf$1, p = -1, _ = u.length, k = a;
  for (a === u && (u = copyArray(u)), c && (k = arrayMap$1(a, baseUnary(c))); ++p < _; )
    for (var O = 0, D = u[p], F = c ? c(D) : D; (O = v(k, F, O, l)) > -1; )
      k !== a && splice.call(k, O, 1), splice.call(a, O, 1);
  return a;
}
function pullAll(a, u) {
  return a && a.length && u && u.length ? basePullAll(a, u) : a;
}
var pull$1 = baseRest(pullAll), sortBy = baseRest(function(a, u) {
  if (a == null)
    return [];
  var c = u.length;
  return c > 1 && isIterateeCall(a, u[0], u[1]) ? u = [] : c > 2 && isIterateeCall(u[0], u[1], u[2]) && (u = [u[0]]), baseOrderBy(a, baseFlatten(u, 1), []);
});
const sortBy$1 = sortBy, convert = (
  // Note: overloads in JSDoc can’t yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(a) {
    if (a == null)
      return ok;
    if (typeof a == "function")
      return castFactory(a);
    if (typeof a == "object")
      return Array.isArray(a) ? anyFactory(a) : propsFactory(a);
    if (typeof a == "string")
      return typeFactory(a);
    throw new Error("Expected function, string, or object as test");
  }
);
function anyFactory(a) {
  const u = [];
  let c = -1;
  for (; ++c < a.length; )
    u[c] = convert(a[c]);
  return castFactory(l);
  function l(...v) {
    let p = -1;
    for (; ++p < u.length; )
      if (u[p].apply(this, v))
        return !0;
    return !1;
  }
}
function propsFactory(a) {
  const u = (
    /** @type {Record<string, unknown>} */
    a
  );
  return castFactory(c);
  function c(l) {
    const v = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      l
    );
    let p;
    for (p in a)
      if (v[p] !== u[p])
        return !1;
    return !0;
  }
}
function typeFactory(a) {
  return castFactory(u);
  function u(c) {
    return c && c.type === a;
  }
}
function castFactory(a) {
  return u;
  function u(c, l, v) {
    return !!(looksLikeANode(c) && a.call(
      this,
      c,
      typeof l == "number" ? l : void 0,
      v || void 0
    ));
  }
}
function ok() {
  return !0;
}
function looksLikeANode(a) {
  return a !== null && typeof a == "object" && "type" in a;
}
function color$1(a) {
  return a;
}
const empty$1 = [], CONTINUE = !0, EXIT = !1, SKIP = "skip";
function visitParents(a, u, c, l) {
  let v;
  typeof u == "function" && typeof c != "function" ? (l = c, c = u) : v = u;
  const p = convert(v), _ = l ? -1 : 1;
  k(a, void 0, [])();
  function k(O, D, F) {
    const z = (
      /** @type {Record<string, unknown>} */
      O && typeof O == "object" ? O : {}
    );
    if (typeof z.type == "string") {
      const ee = (
        // `hast`
        typeof z.tagName == "string" ? z.tagName : (
          // `xast`
          typeof z.name == "string" ? z.name : void 0
        )
      );
      Object.defineProperty(j, "name", {
        value: "node (" + (O.type + (ee ? "<" + ee + ">" : "")) + ")"
      });
    }
    return j;
    function j() {
      let ee = empty$1, X, ae, Q;
      if ((!u || p(O, D, F[F.length - 1] || void 0)) && (ee = toResult(c(O, F)), ee[0] === EXIT))
        return ee;
      if ("children" in O && O.children) {
        const ne = (
          /** @type {UnistParent} */
          O
        );
        if (ne.children && ee[0] !== SKIP)
          for (ae = (l ? ne.children.length : -1) + _, Q = F.concat(ne); ae > -1 && ae < ne.children.length; ) {
            const Z = ne.children[ae];
            if (X = k(Z, ae, Q)(), X[0] === EXIT)
              return X;
            ae = typeof X[1] == "number" ? X[1] : ae + _;
          }
      }
      return ee;
    }
  }
}
function toResult(a) {
  return Array.isArray(a) ? a : typeof a == "number" ? [CONTINUE, a] : a == null ? empty$1 : [a];
}
function visit(a, u, c, l) {
  let v, p, _;
  typeof u == "function" && typeof c != "function" ? (p = void 0, _ = u, v = c) : (p = u, _ = c, v = l), visitParents(a, p, k, v);
  function k(O, D) {
    const F = D[D.length - 1], z = F ? F.children.indexOf(O) : void 0;
    return _(O, z, F);
  }
}
const generateId = () => (Math.random() * 1e20).toString(36), insertAt$1 = (a = 0, u, c, l = !1) => [...c.slice(0, a), ...[u].flat(), ...c.slice(l ? a + 1 : a)], replaceItem$1 = (a, u, c) => {
  a = typeof a == "function" ? a : (v) => v === a;
  const l = c.findIndex(a);
  return l < 0 ? c : insertAt$1(l, u, c, !0);
}, swapIndex = (a, u, c) => {
  if (!c[a] || !c[u])
    return c;
  c = [...c];
  const l = c[a];
  return c[a] = c[u], c[u] = l, c;
}, swapItems = (a, u, c) => {
  const l = c.findIndex((p) => p === a), v = c.findIndex((p) => p === u);
  return l < 0 || v < 0 ? c : swapIndex(l, v, c);
}, toDataNode$1 = (a) => a ? {
  id: a.id,
  props: a.props,
  childIds: (a.children || []).map((u) => u.id)
} : null, toSceneNode = (a) => ({
  id: a.id,
  props: a.props,
  children: []
}), toSceneTree = (a, u) => {
  const c = a.find((v) => v.id === u);
  if (!c)
    return null;
  const l = c.childIds;
  return {
    id: c.id,
    props: c.props,
    children: l.map((v) => toSceneTree(a, v)).filter(Boolean)
  };
}, forEachDown$1 = (a, u) => {
  u(a), (a.children || []).forEach((l) => forEachDown$1(l, (v, p) => {
    u(v, p || a);
  }));
}, mapDown = (a, u) => {
  const c = u(a);
  return {
    ...c,
    children: ((c == null ? void 0 : c.children) || (a == null ? void 0 : a.children) || []).map((l) => mapDown(l, u))
  };
}, mapDownAsync = async (a, u) => {
  const c = (a == null ? void 0 : a.children) ?? [];
  return {
    ...await u(a),
    children: await Promise.all(c.map((l) => mapDownAsync(l, u)))
  };
}, getElementAttributes = (a) => Object.values(a.attributes).reduce((u, c) => ({
  ...u,
  [c.name]: c.value
}), {}), asArray = (a) => isArray$4(a) ? a : [a], sizeToNum = (a, u) => typeof a == "number" ? a : typeof a == "string" ? a.indexOf("%") > -1 ? parseFloat(a) / 100 * u : parseFloat(a) : 0, asSize = (a) => typeof a == "number" ? a + "px" : typeof a == "string" ? a.indexOf("%") > -1 ? parseFloat(a) + "%" : a : "0px", asDuration = (a) => typeof a == "string" ? a : typeof a == "number" ? a + "ms" : "0ms", find$1 = (a, u) => {
  if (!a)
    throw new Error("requires a tree to search");
  if (!u)
    throw new Error("requires a condition");
  const c = iteratee(u);
  let l;
  return visit(a, function(v) {
    if (c(v))
      return l = v, !1;
  }), l;
}, findAll = (a, u) => {
  if (!a)
    throw new Error("requires a tree to search");
  if (!u)
    throw new Error("requires a condition");
  const c = iteratee(u);
  let l = [];
  return visit(a, function(v) {
    c(v) && l.push(v);
  }), l;
}, lookupDevice = (a, u) => {
  const c = a.find((v) => v.label === u && v.kind === "videoinput"), l = a.find((v) => v.label === `Monitor of ${u}` && v.kind === "audioinput");
  if (c && l)
    return {
      videoDevice: c,
      audioDevice: l
    };
  if (c) {
    if (c.label === "Logitech BRIO (046d:085e)") {
      const v = a.find((p) => (
        /*(device.groupId === videoDevice.groupId) &&*/
        p.kind === "audioinput" && p.label === "Loopback Audio 2 (Virtual)"
      ));
      return {
        videoDevice: c,
        audioDevice: v
      };
    }
    if (c.label === "OBS Virtual Camera (m-de:vice)") {
      const v = a.find((p) => (
        /*(device.groupId === videoDevice.groupId) &&*/
        p.kind === "audioinput" && p.label === "Loopback Audio (Virtual)"
      ));
      return {
        videoDevice: c,
        audioDevice: v
      };
    }
    return {
      videoDevice: c,
      audioDevice: null
    };
  }
  return null;
}, connectDevice = async (a) => {
  const u = await navigator.mediaDevices.enumerateDevices(), c = lookupDevice(u, a);
  if (c) {
    const l = {
      video: {
        width: 999999,
        height: 999999,
        deviceId: {
          exact: c.videoDevice.deviceId
        }
      }
    };
    c.audioDevice && (l.audio = {
      autoGainControl: !1,
      channelCount: 2,
      echoCancellation: !1,
      // @ts-ignore: https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints/latency
      latency: 0,
      noiseSuppression: !1,
      sampleRate: 128e3,
      sampleSize: 16,
      deviceId: {
        exact: c.audioDevice.deviceId
      }
    });
    const v = await navigator.mediaDevices.getUserMedia(l);
    if (v)
      return v;
    console.warn(`No stream found for source ${a}.`);
  } else
    console.warn(`No device found for source ${a}.`);
}, values$1 = (a) => Array.from(a.values()), Logic = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  asArray,
  asDuration,
  asSize,
  camelCase: camelCase$3,
  cloneDeep: cloneDeep$1,
  connectDevice,
  debounce,
  deepEqual,
  every,
  find: find$1,
  findAll,
  forEachDown: forEachDown$1,
  generateId,
  getElementAttributes,
  insertAt: insertAt$1,
  isArray: isArray$4,
  isEqual,
  kebabCase: kebabCase$1,
  lookupDevice,
  mapDown,
  mapDownAsync,
  omit,
  pick: pick$1,
  pull: pull$1,
  replaceItem: replaceItem$1,
  sizeToNum,
  sortBy: sortBy$1,
  swapIndex,
  swapItems,
  toDataNode: toDataNode$1,
  toSceneNode,
  toSceneTree,
  values: values$1
}, Symbol.toStringTag, { value: "Module" }));
function getDefaultExportFromCjs$1(a) {
  return a && a.__esModule && Object.prototype.hasOwnProperty.call(a, "default") ? a.default : a;
}
var browser$d = { exports: {} }, process = browser$d.exports = {}, cachedSetTimeout, cachedClearTimeout;
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? cachedSetTimeout = setTimeout : cachedSetTimeout = defaultSetTimout;
  } catch {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    typeof clearTimeout == "function" ? cachedClearTimeout = clearTimeout : cachedClearTimeout = defaultClearTimeout;
  } catch {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(a) {
  if (cachedSetTimeout === setTimeout)
    return setTimeout(a, 0);
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout)
    return cachedSetTimeout = setTimeout, setTimeout(a, 0);
  try {
    return cachedSetTimeout(a, 0);
  } catch {
    try {
      return cachedSetTimeout.call(null, a, 0);
    } catch {
      return cachedSetTimeout.call(this, a, 0);
    }
  }
}
function runClearTimeout(a) {
  if (cachedClearTimeout === clearTimeout)
    return clearTimeout(a);
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout)
    return cachedClearTimeout = clearTimeout, clearTimeout(a);
  try {
    return cachedClearTimeout(a);
  } catch {
    try {
      return cachedClearTimeout.call(null, a);
    } catch {
      return cachedClearTimeout.call(this, a);
    }
  }
}
var queue = [], draining = !1, currentQueue, queueIndex = -1;
function cleanUpNextTick() {
  !draining || !currentQueue || (draining = !1, currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1, queue.length && drainQueue());
}
function drainQueue() {
  if (!draining) {
    var a = runTimeout(cleanUpNextTick);
    draining = !0;
    for (var u = queue.length; u; ) {
      for (currentQueue = queue, queue = []; ++queueIndex < u; )
        currentQueue && currentQueue[queueIndex].run();
      queueIndex = -1, u = queue.length;
    }
    currentQueue = null, draining = !1, runClearTimeout(a);
  }
}
process.nextTick = function(a) {
  var u = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var c = 1; c < arguments.length; c++)
      u[c - 1] = arguments[c];
  queue.push(new Item(a, u)), queue.length === 1 && !draining && runTimeout(drainQueue);
};
function Item(a, u) {
  this.fun = a, this.array = u;
}
Item.prototype.run = function() {
  this.fun.apply(null, this.array);
};
process.title = "browser";
process.browser = !0;
process.env = {};
process.argv = [];
process.version = "";
process.versions = {};
function noop$5() {
}
process.on = noop$5;
process.addListener = noop$5;
process.once = noop$5;
process.off = noop$5;
process.removeListener = noop$5;
process.removeAllListeners = noop$5;
process.emit = noop$5;
process.prependListener = noop$5;
process.prependOnceListener = noop$5;
process.listeners = function(a) {
  return [];
};
process.binding = function(a) {
  throw new Error("process.binding is not supported");
};
process.cwd = function() {
  return "/";
};
process.chdir = function(a) {
  throw new Error("process.chdir is not supported");
};
process.umask = function() {
  return 0;
};
var browserExports$1 = browser$d.exports;
const process$1 = /* @__PURE__ */ getDefaultExportFromCjs$1(browserExports$1);
function _mergeNamespaces(a, u) {
  return u.forEach(function(c) {
    c && typeof c != "string" && !Array.isArray(c) && Object.keys(c).forEach(function(l) {
      if (l !== "default" && !(l in a)) {
        var v = Object.getOwnPropertyDescriptor(c, l);
        Object.defineProperty(a, l, v.get ? v : {
          enumerable: !0,
          get: function() {
            return c[l];
          }
        });
      }
    });
  }), Object.freeze(a);
}
function assert$k(a, u) {
  if (!a)
    throw new Error(u);
}
const FLOAT32_MAX = 34028234663852886e22, FLOAT32_MIN = -34028234663852886e22, UINT32_MAX = 4294967295, INT32_MAX = 2147483647, INT32_MIN = -2147483648;
function assertInt32(a) {
  if (typeof a != "number")
    throw new Error("invalid int 32: " + typeof a);
  if (!Number.isInteger(a) || a > INT32_MAX || a < INT32_MIN)
    throw new Error("invalid int 32: " + a);
}
function assertUInt32(a) {
  if (typeof a != "number")
    throw new Error("invalid uint 32: " + typeof a);
  if (!Number.isInteger(a) || a > UINT32_MAX || a < 0)
    throw new Error("invalid uint 32: " + a);
}
function assertFloat32(a) {
  if (typeof a != "number")
    throw new Error("invalid float 32: " + typeof a);
  if (Number.isFinite(a) && (a > FLOAT32_MAX || a < FLOAT32_MIN))
    throw new Error("invalid float 32: " + a);
}
const enumTypeSymbol = Symbol("@bufbuild/protobuf/enum-type");
function getEnumType(a) {
  const u = a[enumTypeSymbol];
  return assert$k(u, "missing enum type on enum object"), u;
}
function setEnumType(a, u, c, l) {
  a[enumTypeSymbol] = makeEnumType(u, c.map((v) => ({
    no: v.no,
    name: v.name,
    localName: a[v.no]
  })));
}
function makeEnumType(a, u, c) {
  const l = /* @__PURE__ */ Object.create(null), v = /* @__PURE__ */ Object.create(null), p = [];
  for (const _ of u) {
    const k = normalizeEnumValue(_);
    p.push(k), l[_.name] = k, v[_.no] = k;
  }
  return {
    typeName: a,
    values: p,
    // We do not surface options at this time
    // options: opt?.options ?? Object.create(null),
    findName(_) {
      return l[_];
    },
    findNumber(_) {
      return v[_];
    }
  };
}
function makeEnum(a, u, c) {
  const l = {};
  for (const v of u) {
    const p = normalizeEnumValue(v);
    l[p.localName] = p.no, l[p.no] = p.localName;
  }
  return setEnumType(l, a, u), l;
}
function normalizeEnumValue(a) {
  return "localName" in a ? a : Object.assign(Object.assign({}, a), {
    localName: a.name
  });
}
class Message {
  /**
   * Compare with a message of the same type.
   */
  equals(u) {
    return this.getType().runtime.util.equals(this.getType(), this, u);
  }
  /**
   * Create a deep copy.
   */
  clone() {
    return this.getType().runtime.util.clone(this);
  }
  /**
   * Parse from binary data, merging fields.
   *
   * Repeated fields are appended. Map entries are added, overwriting
   * existing keys.
   *
   * If a message field is already present, it will be merged with the
   * new data.
   */
  fromBinary(u, c) {
    const l = this.getType(), v = l.runtime.bin, p = v.makeReadOptions(c);
    return v.readMessage(this, p.readerFactory(u), u.byteLength, p), this;
  }
  /**
   * Parse a message from a JSON value.
   */
  fromJson(u, c) {
    const l = this.getType(), v = l.runtime.json, p = v.makeReadOptions(c);
    return v.readMessage(l, u, p, this), this;
  }
  /**
   * Parse a message from a JSON string.
   */
  fromJsonString(u, c) {
    let l;
    try {
      l = JSON.parse(u);
    } catch (v) {
      throw new Error("cannot decode ".concat(this.getType().typeName, " from JSON: ").concat(v instanceof Error ? v.message : String(v)));
    }
    return this.fromJson(l, c);
  }
  /**
   * Serialize the message to binary data.
   */
  toBinary(u) {
    const c = this.getType(), l = c.runtime.bin, v = l.makeWriteOptions(u), p = v.writerFactory();
    return l.writeMessage(this, p, v), p.finish();
  }
  /**
   * Serialize the message to a JSON value, a JavaScript value that can be
   * passed to JSON.stringify().
   */
  toJson(u) {
    const c = this.getType(), l = c.runtime.json, v = l.makeWriteOptions(u);
    return l.writeMessage(this, v);
  }
  /**
   * Serialize the message to a JSON string.
   */
  toJsonString(u) {
    var c;
    const l = this.toJson(u);
    return JSON.stringify(l, null, (c = u == null ? void 0 : u.prettySpaces) !== null && c !== void 0 ? c : 0);
  }
  /**
   * Override for serialization behavior. This will be invoked when calling
   * JSON.stringify on this message (i.e. JSON.stringify(msg)).
   *
   * Note that this will not serialize google.protobuf.Any with a packed
   * message because the protobuf JSON format specifies that it needs to be
   * unpacked, and this is only possible with a type registry to look up the
   * message type.  As a result, attempting to serialize a message with this
   * type will throw an Error.
   *
   * This method is protected because you should not need to invoke it
   * directly -- instead use JSON.stringify or toJsonString for
   * stringified JSON.  Alternatively, if actual JSON is desired, you should
   * use toJson.
   */
  toJSON() {
    return this.toJson({
      emitDefaultValues: !0
    });
  }
  /**
   * Retrieve the MessageType of this message - a singleton that represents
   * the protobuf message declaration and provides metadata for reflection-
   * based operations.
   */
  getType() {
    return Object.getPrototypeOf(this).constructor;
  }
}
function makeMessageType(a, u, c, l) {
  var v;
  const p = (v = l == null ? void 0 : l.localName) !== null && v !== void 0 ? v : u.substring(u.lastIndexOf(".") + 1), _ = {
    [p]: function(k) {
      a.util.initFields(this), a.util.initPartial(k, this);
    }
  }[p];
  return Object.setPrototypeOf(_.prototype, new Message()), Object.assign(_, {
    runtime: a,
    typeName: u,
    fields: a.util.newFieldList(c),
    fromBinary(k, O) {
      return new _().fromBinary(k, O);
    },
    fromJson(k, O) {
      return new _().fromJson(k, O);
    },
    fromJsonString(k, O) {
      return new _().fromJsonString(k, O);
    },
    equals(k, O) {
      return a.util.equals(_, k, O);
    }
  }), _;
}
var ScalarType;
(function(a) {
  a[a.DOUBLE = 1] = "DOUBLE", a[a.FLOAT = 2] = "FLOAT", a[a.INT64 = 3] = "INT64", a[a.UINT64 = 4] = "UINT64", a[a.INT32 = 5] = "INT32", a[a.FIXED64 = 6] = "FIXED64", a[a.FIXED32 = 7] = "FIXED32", a[a.BOOL = 8] = "BOOL", a[a.STRING = 9] = "STRING", a[a.BYTES = 12] = "BYTES", a[a.UINT32 = 13] = "UINT32", a[a.SFIXED32 = 15] = "SFIXED32", a[a.SFIXED64 = 16] = "SFIXED64", a[a.SINT32 = 17] = "SINT32", a[a.SINT64 = 18] = "SINT64";
})(ScalarType || (ScalarType = {}));
var LongType;
(function(a) {
  a[a.BIGINT = 0] = "BIGINT", a[a.STRING = 1] = "STRING";
})(LongType || (LongType = {}));
function varint64read() {
  let a = 0, u = 0;
  for (let l = 0; l < 28; l += 7) {
    let v = this.buf[this.pos++];
    if (a |= (v & 127) << l, !(v & 128))
      return this.assertBounds(), [a, u];
  }
  let c = this.buf[this.pos++];
  if (a |= (c & 15) << 28, u = (c & 112) >> 4, !(c & 128))
    return this.assertBounds(), [a, u];
  for (let l = 3; l <= 31; l += 7) {
    let v = this.buf[this.pos++];
    if (u |= (v & 127) << l, !(v & 128))
      return this.assertBounds(), [a, u];
  }
  throw new Error("invalid varint");
}
function varint64write(a, u, c) {
  for (let p = 0; p < 28; p = p + 7) {
    const _ = a >>> p, k = !(!(_ >>> 7) && u == 0), O = (k ? _ | 128 : _) & 255;
    if (c.push(O), !k)
      return;
  }
  const l = a >>> 28 & 15 | (u & 7) << 4, v = !!(u >> 3);
  if (c.push((v ? l | 128 : l) & 255), !!v) {
    for (let p = 3; p < 31; p = p + 7) {
      const _ = u >>> p, k = !!(_ >>> 7), O = (k ? _ | 128 : _) & 255;
      if (c.push(O), !k)
        return;
    }
    c.push(u >>> 31 & 1);
  }
}
const TWO_PWR_32_DBL = 4294967296;
function int64FromString(a) {
  const u = a[0] === "-";
  u && (a = a.slice(1));
  const c = 1e6;
  let l = 0, v = 0;
  function p(_, k) {
    const O = Number(a.slice(_, k));
    v *= c, l = l * c + O, l >= TWO_PWR_32_DBL && (v = v + (l / TWO_PWR_32_DBL | 0), l = l % TWO_PWR_32_DBL);
  }
  return p(-24, -18), p(-18, -12), p(-12, -6), p(-6), u ? negate(l, v) : newBits(l, v);
}
function int64ToString(a, u) {
  let c = newBits(a, u);
  const l = c.hi & 2147483648;
  l && (c = negate(c.lo, c.hi));
  const v = uInt64ToString(c.lo, c.hi);
  return l ? "-" + v : v;
}
function uInt64ToString(a, u) {
  if ({
    lo: a,
    hi: u
  } = toUnsigned(a, u), u <= 2097151)
    return String(TWO_PWR_32_DBL * u + a);
  const c = a & 16777215, l = (a >>> 24 | u << 8) & 16777215, v = u >> 16 & 65535;
  let p = c + l * 6777216 + v * 6710656, _ = l + v * 8147497, k = v * 2;
  const O = 1e7;
  return p >= O && (_ += Math.floor(p / O), p %= O), _ >= O && (k += Math.floor(_ / O), _ %= O), k.toString() + decimalFrom1e7WithLeadingZeros(_) + decimalFrom1e7WithLeadingZeros(p);
}
function toUnsigned(a, u) {
  return {
    lo: a >>> 0,
    hi: u >>> 0
  };
}
function newBits(a, u) {
  return {
    lo: a | 0,
    hi: u | 0
  };
}
function negate(a, u) {
  return u = ~u, a ? a = ~a + 1 : u += 1, newBits(a, u);
}
const decimalFrom1e7WithLeadingZeros = (a) => {
  const u = String(a);
  return "0000000".slice(u.length) + u;
};
function varint32write(a, u) {
  if (a >= 0) {
    for (; a > 127; )
      u.push(a & 127 | 128), a = a >>> 7;
    u.push(a);
  } else {
    for (let c = 0; c < 9; c++)
      u.push(a & 127 | 128), a = a >> 7;
    u.push(1);
  }
}
function varint32read() {
  let a = this.buf[this.pos++], u = a & 127;
  if (!(a & 128))
    return this.assertBounds(), u;
  if (a = this.buf[this.pos++], u |= (a & 127) << 7, !(a & 128))
    return this.assertBounds(), u;
  if (a = this.buf[this.pos++], u |= (a & 127) << 14, !(a & 128))
    return this.assertBounds(), u;
  if (a = this.buf[this.pos++], u |= (a & 127) << 21, !(a & 128))
    return this.assertBounds(), u;
  a = this.buf[this.pos++], u |= (a & 15) << 28;
  for (let c = 5; a & 128 && c < 10; c++)
    a = this.buf[this.pos++];
  if (a & 128)
    throw new Error("invalid varint");
  return this.assertBounds(), u >>> 0;
}
function makeInt64Support() {
  const a = new DataView(new ArrayBuffer(8));
  if (typeof BigInt == "function" && typeof a.getBigInt64 == "function" && typeof a.getBigUint64 == "function" && typeof a.setBigInt64 == "function" && typeof a.setBigUint64 == "function" && (typeof process$1 != "object" || typeof process$1.env != "object" || process$1.env.BUF_BIGINT_DISABLE !== "1")) {
    const v = BigInt("-9223372036854775808"), p = BigInt("9223372036854775807"), _ = BigInt("0"), k = BigInt("18446744073709551615");
    return {
      zero: BigInt(0),
      supported: !0,
      parse(O) {
        const D = typeof O == "bigint" ? O : BigInt(O);
        if (D > p || D < v)
          throw new Error("int64 invalid: ".concat(O));
        return D;
      },
      uParse(O) {
        const D = typeof O == "bigint" ? O : BigInt(O);
        if (D > k || D < _)
          throw new Error("uint64 invalid: ".concat(O));
        return D;
      },
      enc(O) {
        return a.setBigInt64(0, this.parse(O), !0), {
          lo: a.getInt32(0, !0),
          hi: a.getInt32(4, !0)
        };
      },
      uEnc(O) {
        return a.setBigInt64(0, this.uParse(O), !0), {
          lo: a.getInt32(0, !0),
          hi: a.getInt32(4, !0)
        };
      },
      dec(O, D) {
        return a.setInt32(0, O, !0), a.setInt32(4, D, !0), a.getBigInt64(0, !0);
      },
      uDec(O, D) {
        return a.setInt32(0, O, !0), a.setInt32(4, D, !0), a.getBigUint64(0, !0);
      }
    };
  }
  const c = (v) => assert$k(/^-?[0-9]+$/.test(v), "int64 invalid: ".concat(v)), l = (v) => assert$k(/^[0-9]+$/.test(v), "uint64 invalid: ".concat(v));
  return {
    zero: "0",
    supported: !1,
    parse(v) {
      return typeof v != "string" && (v = v.toString()), c(v), v;
    },
    uParse(v) {
      return typeof v != "string" && (v = v.toString()), l(v), v;
    },
    enc(v) {
      return typeof v != "string" && (v = v.toString()), c(v), int64FromString(v);
    },
    uEnc(v) {
      return typeof v != "string" && (v = v.toString()), l(v), int64FromString(v);
    },
    dec(v, p) {
      return int64ToString(v, p);
    },
    uDec(v, p) {
      return uInt64ToString(v, p);
    }
  };
}
const protoInt64 = makeInt64Support();
var WireType;
(function(a) {
  a[a.Varint = 0] = "Varint", a[a.Bit64 = 1] = "Bit64", a[a.LengthDelimited = 2] = "LengthDelimited", a[a.StartGroup = 3] = "StartGroup", a[a.EndGroup = 4] = "EndGroup", a[a.Bit32 = 5] = "Bit32";
})(WireType || (WireType = {}));
class BinaryWriter {
  constructor(u) {
    this.stack = [], this.textEncoder = u ?? new TextEncoder(), this.chunks = [], this.buf = [];
  }
  /**
   * Return all bytes written and reset this writer.
   */
  finish() {
    this.chunks.push(new Uint8Array(this.buf));
    let u = 0;
    for (let v = 0; v < this.chunks.length; v++)
      u += this.chunks[v].length;
    let c = new Uint8Array(u), l = 0;
    for (let v = 0; v < this.chunks.length; v++)
      c.set(this.chunks[v], l), l += this.chunks[v].length;
    return this.chunks = [], c;
  }
  /**
   * Start a new fork for length-delimited data like a message
   * or a packed repeated field.
   *
   * Must be joined later with `join()`.
   */
  fork() {
    return this.stack.push({
      chunks: this.chunks,
      buf: this.buf
    }), this.chunks = [], this.buf = [], this;
  }
  /**
   * Join the last fork. Write its length and bytes, then
   * return to the previous state.
   */
  join() {
    let u = this.finish(), c = this.stack.pop();
    if (!c)
      throw new Error("invalid state, fork stack empty");
    return this.chunks = c.chunks, this.buf = c.buf, this.uint32(u.byteLength), this.raw(u);
  }
  /**
   * Writes a tag (field number and wire type).
   *
   * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.
   *
   * Generated code should compute the tag ahead of time and call `uint32()`.
   */
  tag(u, c) {
    return this.uint32((u << 3 | c) >>> 0);
  }
  /**
   * Write a chunk of raw bytes.
   */
  raw(u) {
    return this.buf.length && (this.chunks.push(new Uint8Array(this.buf)), this.buf = []), this.chunks.push(u), this;
  }
  /**
   * Write a `uint32` value, an unsigned 32 bit varint.
   */
  uint32(u) {
    for (assertUInt32(u); u > 127; )
      this.buf.push(u & 127 | 128), u = u >>> 7;
    return this.buf.push(u), this;
  }
  /**
   * Write a `int32` value, a signed 32 bit varint.
   */
  int32(u) {
    return assertInt32(u), varint32write(u, this.buf), this;
  }
  /**
   * Write a `bool` value, a variant.
   */
  bool(u) {
    return this.buf.push(u ? 1 : 0), this;
  }
  /**
   * Write a `bytes` value, length-delimited arbitrary data.
   */
  bytes(u) {
    return this.uint32(u.byteLength), this.raw(u);
  }
  /**
   * Write a `string` value, length-delimited data converted to UTF-8 text.
   */
  string(u) {
    let c = this.textEncoder.encode(u);
    return this.uint32(c.byteLength), this.raw(c);
  }
  /**
   * Write a `float` value, 32-bit floating point number.
   */
  float(u) {
    assertFloat32(u);
    let c = new Uint8Array(4);
    return new DataView(c.buffer).setFloat32(0, u, !0), this.raw(c);
  }
  /**
   * Write a `double` value, a 64-bit floating point number.
   */
  double(u) {
    let c = new Uint8Array(8);
    return new DataView(c.buffer).setFloat64(0, u, !0), this.raw(c);
  }
  /**
   * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.
   */
  fixed32(u) {
    assertUInt32(u);
    let c = new Uint8Array(4);
    return new DataView(c.buffer).setUint32(0, u, !0), this.raw(c);
  }
  /**
   * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.
   */
  sfixed32(u) {
    assertInt32(u);
    let c = new Uint8Array(4);
    return new DataView(c.buffer).setInt32(0, u, !0), this.raw(c);
  }
  /**
   * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.
   */
  sint32(u) {
    return assertInt32(u), u = (u << 1 ^ u >> 31) >>> 0, varint32write(u, this.buf), this;
  }
  /**
   * Write a `fixed64` value, a signed, fixed-length 64-bit integer.
   */
  sfixed64(u) {
    let c = new Uint8Array(8), l = new DataView(c.buffer), v = protoInt64.enc(u);
    return l.setInt32(0, v.lo, !0), l.setInt32(4, v.hi, !0), this.raw(c);
  }
  /**
   * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.
   */
  fixed64(u) {
    let c = new Uint8Array(8), l = new DataView(c.buffer), v = protoInt64.uEnc(u);
    return l.setInt32(0, v.lo, !0), l.setInt32(4, v.hi, !0), this.raw(c);
  }
  /**
   * Write a `int64` value, a signed 64-bit varint.
   */
  int64(u) {
    let c = protoInt64.enc(u);
    return varint64write(c.lo, c.hi, this.buf), this;
  }
  /**
   * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64(u) {
    let c = protoInt64.enc(u), l = c.hi >> 31, v = c.lo << 1 ^ l, p = (c.hi << 1 | c.lo >>> 31) ^ l;
    return varint64write(v, p, this.buf), this;
  }
  /**
   * Write a `uint64` value, an unsigned 64-bit varint.
   */
  uint64(u) {
    let c = protoInt64.uEnc(u);
    return varint64write(c.lo, c.hi, this.buf), this;
  }
}
class BinaryReader {
  constructor(u, c) {
    this.varint64 = varint64read, this.uint32 = varint32read, this.buf = u, this.len = u.length, this.pos = 0, this.view = new DataView(u.buffer, u.byteOffset, u.byteLength), this.textDecoder = c ?? new TextDecoder();
  }
  /**
   * Reads a tag - field number and wire type.
   */
  tag() {
    let u = this.uint32(), c = u >>> 3, l = u & 7;
    if (c <= 0 || l < 0 || l > 5)
      throw new Error("illegal tag: field no " + c + " wire type " + l);
    return [c, l];
  }
  /**
   * Skip one element on the wire and return the skipped data.
   * Supports WireType.StartGroup since v2.0.0-alpha.23.
   */
  skip(u) {
    let c = this.pos;
    switch (u) {
      case WireType.Varint:
        for (; this.buf[this.pos++] & 128; )
          ;
        break;
      case WireType.Bit64:
        this.pos += 4;
      case WireType.Bit32:
        this.pos += 4;
        break;
      case WireType.LengthDelimited:
        let l = this.uint32();
        this.pos += l;
        break;
      case WireType.StartGroup:
        let v;
        for (; (v = this.tag()[1]) !== WireType.EndGroup; )
          this.skip(v);
        break;
      default:
        throw new Error("cant skip wire type " + u);
    }
    return this.assertBounds(), this.buf.subarray(c, this.pos);
  }
  /**
   * Throws error if position in byte array is out of range.
   */
  assertBounds() {
    if (this.pos > this.len)
      throw new RangeError("premature EOF");
  }
  /**
   * Read a `int32` field, a signed 32 bit varint.
   */
  int32() {
    return this.uint32() | 0;
  }
  /**
   * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.
   */
  sint32() {
    let u = this.uint32();
    return u >>> 1 ^ -(u & 1);
  }
  /**
   * Read a `int64` field, a signed 64-bit varint.
   */
  int64() {
    return protoInt64.dec(...this.varint64());
  }
  /**
   * Read a `uint64` field, an unsigned 64-bit varint.
   */
  uint64() {
    return protoInt64.uDec(...this.varint64());
  }
  /**
   * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64() {
    let [u, c] = this.varint64(), l = -(u & 1);
    return u = (u >>> 1 | (c & 1) << 31) ^ l, c = c >>> 1 ^ l, protoInt64.dec(u, c);
  }
  /**
   * Read a `bool` field, a variant.
   */
  bool() {
    let [u, c] = this.varint64();
    return u !== 0 || c !== 0;
  }
  /**
   * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.
   */
  fixed32() {
    return this.view.getUint32((this.pos += 4) - 4, !0);
  }
  /**
   * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.
   */
  sfixed32() {
    return this.view.getInt32((this.pos += 4) - 4, !0);
  }
  /**
   * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.
   */
  fixed64() {
    return protoInt64.uDec(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `fixed64` field, a signed, fixed-length 64-bit integer.
   */
  sfixed64() {
    return protoInt64.dec(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `float` field, 32-bit floating point number.
   */
  float() {
    return this.view.getFloat32((this.pos += 4) - 4, !0);
  }
  /**
   * Read a `double` field, a 64-bit floating point number.
   */
  double() {
    return this.view.getFloat64((this.pos += 8) - 8, !0);
  }
  /**
   * Read a `bytes` field, length-delimited arbitrary data.
   */
  bytes() {
    let u = this.uint32(), c = this.pos;
    return this.pos += u, this.assertBounds(), this.buf.subarray(c, c + u);
  }
  /**
   * Read a `string` field, length-delimited data converted to UTF-8 text.
   */
  string() {
    return this.textDecoder.decode(this.bytes());
  }
}
function scalarEquals(a, u, c) {
  if (u === c)
    return !0;
  if (a == ScalarType.BYTES) {
    if (!(u instanceof Uint8Array) || !(c instanceof Uint8Array) || u.length !== c.length)
      return !1;
    for (let l = 0; l < u.length; l++)
      if (u[l] !== c[l])
        return !1;
    return !0;
  }
  switch (a) {
    case ScalarType.UINT64:
    case ScalarType.FIXED64:
    case ScalarType.INT64:
    case ScalarType.SFIXED64:
    case ScalarType.SINT64:
      return u == c;
  }
  return !1;
}
function scalarDefaultValue(a, u) {
  switch (a) {
    case ScalarType.BOOL:
      return !1;
    case ScalarType.UINT64:
    case ScalarType.FIXED64:
    case ScalarType.INT64:
    case ScalarType.SFIXED64:
    case ScalarType.SINT64:
      return u == 0 ? protoInt64.zero : "0";
    case ScalarType.DOUBLE:
    case ScalarType.FLOAT:
      return 0;
    case ScalarType.BYTES:
      return new Uint8Array(0);
    case ScalarType.STRING:
      return "";
    default:
      return 0;
  }
}
function scalarTypeInfo(a, u) {
  const c = u === void 0;
  let l = WireType.Varint, v = u === 0;
  switch (a) {
    case ScalarType.STRING:
      v = c || !u.length, l = WireType.LengthDelimited;
      break;
    case ScalarType.BOOL:
      v = u === !1;
      break;
    case ScalarType.DOUBLE:
      l = WireType.Bit64;
      break;
    case ScalarType.FLOAT:
      l = WireType.Bit32;
      break;
    case ScalarType.INT64:
      v = c || u == 0;
      break;
    case ScalarType.UINT64:
      v = c || u == 0;
      break;
    case ScalarType.FIXED64:
      v = c || u == 0, l = WireType.Bit64;
      break;
    case ScalarType.BYTES:
      v = c || !u.byteLength, l = WireType.LengthDelimited;
      break;
    case ScalarType.FIXED32:
      l = WireType.Bit32;
      break;
    case ScalarType.SFIXED32:
      l = WireType.Bit32;
      break;
    case ScalarType.SFIXED64:
      v = c || u == 0, l = WireType.Bit64;
      break;
    case ScalarType.SINT64:
      v = c || u == 0;
      break;
  }
  const p = ScalarType[a].toLowerCase();
  return [l, p, c || v];
}
function makeExtension(a, u, c, l) {
  let v;
  return {
    typeName: u,
    extendee: c,
    get field() {
      if (!v) {
        const p = typeof l == "function" ? l() : l;
        p.name = u.split(".").pop(), p.jsonName = "[".concat(u, "]"), v = a.util.newFieldList([p]).list()[0];
      }
      return v;
    },
    runtime: a
  };
}
function createExtensionContainer(a) {
  const u = a.field.localName, c = /* @__PURE__ */ Object.create(null);
  return c[u] = initExtensionField(a), [c, () => c[u]];
}
function initExtensionField(a) {
  const u = a.field;
  if (u.repeated)
    return [];
  if (u.default !== void 0)
    return u.default;
  switch (u.kind) {
    case "enum":
      return u.T.values[0].no;
    case "scalar":
      return scalarDefaultValue(u.T, u.L);
    case "message":
      const c = u.T, l = new c();
      return c.fieldWrapper ? c.fieldWrapper.unwrapField(l) : l;
    case "map":
      throw "map fields are not allowed to be extensions";
  }
}
function filterUnknownFields(a, u) {
  if (!u.repeated && (u.kind == "enum" || u.kind == "scalar")) {
    for (let c = a.length - 1; c >= 0; --c)
      if (a[c].no == u.no)
        return [a[c]];
    return [];
  }
  return a.filter((c) => c.no === u.no);
}
function makeProtoRuntime(a, u, c, l) {
  return {
    syntax: a,
    json: u,
    bin: c,
    util: l,
    makeMessageType(v, p, _) {
      return makeMessageType(this, v, p, _);
    },
    makeEnum,
    makeEnumType,
    getEnumType,
    makeExtension(v, p, _) {
      return makeExtension(this, v, p, _);
    }
  };
}
function wrapField(a, u) {
  return u instanceof Message || !a.fieldWrapper ? u : a.fieldWrapper.wrapField(u);
}
ScalarType.DOUBLE, ScalarType.FLOAT, ScalarType.INT64, ScalarType.UINT64, ScalarType.INT32, ScalarType.UINT32, ScalarType.BOOL, ScalarType.STRING, ScalarType.BYTES;
const unknownFieldsSymbol = Symbol("@bufbuild/protobuf/unknown-fields"), readDefaults = {
  readUnknownFields: !0,
  readerFactory: (a) => new BinaryReader(a)
}, writeDefaults = {
  writeUnknownFields: !0,
  writerFactory: () => new BinaryWriter()
};
function makeReadOptions$1(a) {
  return a ? Object.assign(Object.assign({}, readDefaults), a) : readDefaults;
}
function makeWriteOptions$1(a) {
  return a ? Object.assign(Object.assign({}, writeDefaults), a) : writeDefaults;
}
function makeBinaryFormatCommon() {
  return {
    makeReadOptions: makeReadOptions$1,
    makeWriteOptions: makeWriteOptions$1,
    listUnknownFields(a) {
      var u;
      return (u = a[unknownFieldsSymbol]) !== null && u !== void 0 ? u : [];
    },
    discardUnknownFields(a) {
      delete a[unknownFieldsSymbol];
    },
    writeUnknownFields(a, u) {
      const l = a[unknownFieldsSymbol];
      if (l)
        for (const v of l)
          u.tag(v.no, v.wireType).raw(v.data);
    },
    onUnknownField(a, u, c, l) {
      const v = a;
      Array.isArray(v[unknownFieldsSymbol]) || (v[unknownFieldsSymbol] = []), v[unknownFieldsSymbol].push({
        no: u,
        wireType: c,
        data: l
      });
    },
    readMessage(a, u, c, l, v) {
      const p = a.getType(), _ = v ? u.len : u.pos + c;
      let k, O;
      for (; u.pos < _ && ([k, O] = u.tag(), O != WireType.EndGroup); ) {
        const D = p.fields.find(k);
        if (!D) {
          const F = u.skip(O);
          l.readUnknownFields && this.onUnknownField(a, k, O, F);
          continue;
        }
        readField$1(a, u, D, O, l);
      }
      if (v && // eslint-disable-line @typescript-eslint/strict-boolean-expressions
      (O != WireType.EndGroup || k !== c))
        throw new Error("invalid end group tag");
    },
    readField: readField$1
  };
}
function readField$1(a, u, c, l, v) {
  let {
    repeated: p,
    localName: _
  } = c;
  switch (c.oneof && (a = a[c.oneof.localName], a.case != _ && delete a.value, a.case = _, _ = "value"), c.kind) {
    case "scalar":
    case "enum":
      const k = c.kind == "enum" ? ScalarType.INT32 : c.T;
      let O = readScalar$1;
      if (c.kind == "scalar" && c.L > 0 && (O = readScalarLTString), p) {
        let j = a[_];
        if (l == WireType.LengthDelimited && k != ScalarType.STRING && k != ScalarType.BYTES) {
          let X = u.uint32() + u.pos;
          for (; u.pos < X; )
            j.push(O(u, k));
        } else
          j.push(O(u, k));
      } else
        a[_] = O(u, k);
      break;
    case "message":
      const D = c.T;
      p ? a[_].push(readMessageField(u, new D(), v, c)) : a[_] instanceof Message ? readMessageField(u, a[_], v, c) : (a[_] = readMessageField(u, new D(), v, c), D.fieldWrapper && !c.oneof && !c.repeated && (a[_] = D.fieldWrapper.unwrapField(a[_])));
      break;
    case "map":
      let [F, z] = readMapEntry(c, u, v);
      a[_][F] = z;
      break;
  }
}
function readMessageField(a, u, c, l) {
  const v = u.getType().runtime.bin, p = l == null ? void 0 : l.delimited;
  return v.readMessage(
    u,
    a,
    p ? l == null ? void 0 : l.no : a.uint32(),
    // eslint-disable-line @typescript-eslint/strict-boolean-expressions
    c,
    p
  ), u;
}
function readMapEntry(a, u, c) {
  const l = u.uint32(), v = u.pos + l;
  let p, _;
  for (; u.pos < v; ) {
    let [k] = u.tag();
    switch (k) {
      case 1:
        p = readScalar$1(u, a.K);
        break;
      case 2:
        switch (a.V.kind) {
          case "scalar":
            _ = readScalar$1(u, a.V.T);
            break;
          case "enum":
            _ = u.int32();
            break;
          case "message":
            _ = readMessageField(u, new a.V.T(), c, void 0);
            break;
        }
        break;
    }
  }
  if (p === void 0) {
    let k = scalarDefaultValue(a.K, LongType.BIGINT);
    p = a.K == ScalarType.BOOL ? k.toString() : k;
  }
  if (typeof p != "string" && typeof p != "number" && (p = p.toString()), _ === void 0)
    switch (a.V.kind) {
      case "scalar":
        _ = scalarDefaultValue(a.V.T, LongType.BIGINT);
        break;
      case "enum":
        _ = 0;
        break;
      case "message":
        _ = new a.V.T();
        break;
    }
  return [p, _];
}
function readScalarLTString(a, u) {
  const c = readScalar$1(a, u);
  return typeof c == "bigint" ? c.toString() : c;
}
function readScalar$1(a, u) {
  switch (u) {
    case ScalarType.STRING:
      return a.string();
    case ScalarType.BOOL:
      return a.bool();
    case ScalarType.DOUBLE:
      return a.double();
    case ScalarType.FLOAT:
      return a.float();
    case ScalarType.INT32:
      return a.int32();
    case ScalarType.INT64:
      return a.int64();
    case ScalarType.UINT64:
      return a.uint64();
    case ScalarType.FIXED64:
      return a.fixed64();
    case ScalarType.BYTES:
      return a.bytes();
    case ScalarType.FIXED32:
      return a.fixed32();
    case ScalarType.SFIXED32:
      return a.sfixed32();
    case ScalarType.SFIXED64:
      return a.sfixed64();
    case ScalarType.SINT64:
      return a.sint64();
    case ScalarType.UINT32:
      return a.uint32();
    case ScalarType.SINT32:
      return a.sint32();
  }
}
function writeMapEntry(a, u, c, l, v) {
  a.tag(c.no, WireType.LengthDelimited), a.fork();
  let p = l;
  switch (c.K) {
    case ScalarType.INT32:
    case ScalarType.FIXED32:
    case ScalarType.UINT32:
    case ScalarType.SFIXED32:
    case ScalarType.SINT32:
      p = Number.parseInt(l);
      break;
    case ScalarType.BOOL:
      assert$k(l == "true" || l == "false"), p = l == "true";
      break;
  }
  switch (writeScalar$1(a, c.K, 1, p, !0), c.V.kind) {
    case "scalar":
      writeScalar$1(a, c.V.T, 2, v, !0);
      break;
    case "enum":
      writeScalar$1(a, ScalarType.INT32, 2, v, !0);
      break;
    case "message":
      a.tag(2, WireType.LengthDelimited).bytes(v.toBinary(u));
      break;
  }
  a.join();
}
function writeMessageField(a, u, c, l) {
  const v = wrapField(c.T, l);
  c != null && c.delimited ? a.tag(c.no, WireType.StartGroup).raw(v.toBinary(u)).tag(c.no, WireType.EndGroup) : a.tag(c.no, WireType.LengthDelimited).bytes(v.toBinary(u));
}
function writeScalar$1(a, u, c, l, v) {
  let [p, _, k] = scalarTypeInfo(u, l);
  (!k || v) && a.tag(c, p)[_](l);
}
function writePacked(a, u, c, l) {
  if (!l.length)
    return;
  a.tag(c, WireType.LengthDelimited).fork();
  let [, v] = scalarTypeInfo(u);
  for (let p = 0; p < l.length; p++)
    a[v](l[p]);
  a.join();
}
function makeBinaryFormatProto3() {
  return Object.assign(Object.assign({}, makeBinaryFormatCommon()), {
    writeField,
    writeMessage(a, u, c) {
      const l = a.getType();
      for (const v of l.fields.byNumber()) {
        let p, _ = v.localName;
        if (v.oneof) {
          const k = a[v.oneof.localName];
          if (k.case !== _)
            continue;
          p = k.value;
        } else
          p = a[_];
        writeField(v, p, u, c);
      }
      return c.writeUnknownFields && this.writeUnknownFields(a, u), u;
    }
  });
}
function writeField(a, u, c, l) {
  const v = a.repeated;
  switch (a.kind) {
    case "scalar":
    case "enum":
      let p = a.kind == "enum" ? ScalarType.INT32 : a.T;
      if (v)
        if (a.packed)
          writePacked(c, p, a.no, u);
        else
          for (const _ of u)
            writeScalar$1(c, p, a.no, _, !0);
      else
        u !== void 0 && writeScalar$1(c, p, a.no, u, !!a.oneof || a.opt);
      break;
    case "message":
      if (v)
        for (const _ of u)
          writeMessageField(c, l, a, _);
      else
        u !== void 0 && writeMessageField(c, l, a, u);
      break;
    case "map":
      for (const [_, k] of Object.entries(u))
        writeMapEntry(c, l, a, _, k);
      break;
  }
}
let encTable = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split(""), decTable = [];
for (let a = 0; a < encTable.length; a++)
  decTable[encTable[a].charCodeAt(0)] = a;
decTable[45] = encTable.indexOf("+");
decTable[95] = encTable.indexOf("/");
const protoBase64 = {
  /**
   * Decodes a base64 string to a byte array.
   *
   * - ignores white-space, including line breaks and tabs
   * - allows inner padding (can decode concatenated base64 strings)
   * - does not require padding
   * - understands base64url encoding:
   *   "-" instead of "+",
   *   "_" instead of "/",
   *   no padding
   */
  dec(a) {
    let u = a.length * 3 / 4;
    a[a.length - 2] == "=" ? u -= 2 : a[a.length - 1] == "=" && (u -= 1);
    let c = new Uint8Array(u), l = 0, v = 0, p, _ = 0;
    for (let k = 0; k < a.length; k++) {
      if (p = decTable[a.charCodeAt(k)], p === void 0)
        switch (a[k]) {
          case "=":
            v = 0;
          case `
`:
          case "\r":
          case "	":
          case " ":
            continue;
          default:
            throw Error("invalid base64 string.");
        }
      switch (v) {
        case 0:
          _ = p, v = 1;
          break;
        case 1:
          c[l++] = _ << 2 | (p & 48) >> 4, _ = p, v = 2;
          break;
        case 2:
          c[l++] = (_ & 15) << 4 | (p & 60) >> 2, _ = p, v = 3;
          break;
        case 3:
          c[l++] = (_ & 3) << 6 | p, v = 0;
          break;
      }
    }
    if (v == 1)
      throw Error("invalid base64 string.");
    return c.subarray(0, l);
  },
  /**
   * Encode a byte array to a base64 string.
   */
  enc(a) {
    let u = "", c = 0, l, v = 0;
    for (let p = 0; p < a.length; p++)
      switch (l = a[p], c) {
        case 0:
          u += encTable[l >> 2], v = (l & 3) << 4, c = 1;
          break;
        case 1:
          u += encTable[v | l >> 4], v = (l & 15) << 2, c = 2;
          break;
        case 2:
          u += encTable[v | l >> 6], u += encTable[l & 63], c = 0;
          break;
      }
    return c && (u += encTable[v], u += "=", c == 1 && (u += "=")), u;
  }
};
function getExtension(a, u, c) {
  assertExtendee(u, a);
  const l = u.runtime.bin.makeReadOptions(c), v = filterUnknownFields(a.getType().runtime.bin.listUnknownFields(a), u.field), [p, _] = createExtensionContainer(u);
  for (const k of v)
    u.runtime.bin.readField(p, l.readerFactory(k.data), u.field, k.wireType, l);
  return _();
}
function setExtension(a, u, c, l) {
  assertExtendee(u, a);
  const v = u.runtime.bin.makeReadOptions(l), p = u.runtime.bin.makeWriteOptions(l);
  if (hasExtension(a, u)) {
    const D = a.getType().runtime.bin.listUnknownFields(a).filter((F) => F.no != u.field.no);
    a.getType().runtime.bin.discardUnknownFields(a);
    for (const F of D)
      a.getType().runtime.bin.onUnknownField(a, F.no, F.wireType, F.data);
  }
  const _ = p.writerFactory();
  let k = u.field;
  !k.opt && !k.repeated && (k.kind == "enum" || k.kind == "scalar") && (k = Object.assign(Object.assign({}, u.field), {
    opt: !0
  })), u.runtime.bin.writeField(k, c, _, p);
  const O = v.readerFactory(_.finish());
  for (; O.pos < O.len; ) {
    const [D, F] = O.tag(), z = O.skip(F);
    a.getType().runtime.bin.onUnknownField(a, D, F, z);
  }
}
function hasExtension(a, u) {
  const c = a.getType();
  return u.extendee.typeName === c.typeName && !!c.runtime.bin.listUnknownFields(a).find((l) => l.no == u.field.no);
}
function assertExtendee(a, u) {
  assert$k(a.extendee.typeName == u.getType().typeName, "extension ".concat(a.typeName, " can only be applied to message ").concat(a.extendee.typeName));
}
const jsonReadDefaults = {
  ignoreUnknownFields: !1
}, jsonWriteDefaults = {
  emitDefaultValues: !1,
  enumAsInteger: !1,
  useProtoFieldName: !1,
  prettySpaces: 0
};
function makeReadOptions(a) {
  return a ? Object.assign(Object.assign({}, jsonReadDefaults), a) : jsonReadDefaults;
}
function makeWriteOptions(a) {
  return a ? Object.assign(Object.assign({}, jsonWriteDefaults), a) : jsonWriteDefaults;
}
function makeJsonFormatCommon(a, u) {
  const c = u(writeEnum, writeScalar);
  return {
    makeReadOptions,
    makeWriteOptions,
    readMessage(l, v, p, _) {
      if (v == null || Array.isArray(v) || typeof v != "object")
        throw new Error("cannot decode message ".concat(l.typeName, " from JSON: ").concat(debugJsonValue(v)));
      _ = _ ?? new l();
      const k = /* @__PURE__ */ new Map(), O = p.typeRegistry;
      for (const [D, F] of Object.entries(v)) {
        const z = l.fields.findJsonName(D);
        if (z) {
          if (z.oneof) {
            if (F === null && z.kind == "scalar")
              continue;
            const j = k.get(z.oneof);
            if (j !== void 0)
              throw new Error("cannot decode message ".concat(l.typeName, ' from JSON: multiple keys for oneof "').concat(z.oneof.name, '" present: "').concat(j, '", "').concat(D, '"'));
            k.set(z.oneof, D);
          }
          readField(_, F, z, p, l, a);
        } else {
          let j = !1;
          if (O != null && O.findExtension && D.startsWith("[") && D.endsWith("]")) {
            const ee = O.findExtension(D.substring(1, D.length - 1));
            if (ee && ee.extendee.typeName == l.typeName) {
              j = !0;
              const [X, ae] = createExtensionContainer(ee);
              readField(X, F, ee.field, p, ee, !0), setExtension(_, ee, ae(), p);
            }
          }
          if (!j && !p.ignoreUnknownFields)
            throw new Error("cannot decode message ".concat(l.typeName, ' from JSON: key "').concat(D, '" is unknown'));
        }
      }
      return _;
    },
    writeMessage(l, v) {
      const p = l.getType(), _ = {};
      let k;
      try {
        for (const D of p.fields.byMember()) {
          let F;
          if (D.kind == "oneof") {
            const z = l[D.localName];
            if (z.value === void 0)
              continue;
            if (k = D.findField(z.case), !k)
              throw "oneof case not found: " + z.case;
            F = c(k, z.value, v);
          } else
            k = D, F = c(k, l[k.localName], v);
          F !== void 0 && (_[v.useProtoFieldName ? k.name : k.jsonName] = F);
        }
        const O = v.typeRegistry;
        if (O != null && O.findExtensionFor)
          for (const D of p.runtime.bin.listUnknownFields(l)) {
            const F = O.findExtensionFor(p.typeName, D.no);
            if (F && hasExtension(l, F)) {
              const z = getExtension(l, F, v), j = c(F.field, z, v);
              j !== void 0 && (_[F.field.jsonName] = j);
            }
          }
      } catch (O) {
        const D = k ? "cannot encode field ".concat(p.typeName, ".").concat(k.name, " to JSON") : "cannot encode message ".concat(p.typeName, " to JSON"), F = O instanceof Error ? O.message : String(O);
        throw new Error(D + (F.length > 0 ? ": ".concat(F) : ""));
      }
      return _;
    },
    readScalar: (l, v, p) => readScalar(l, v, p, a),
    // eslint-disable-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-return
    writeScalar,
    debug: debugJsonValue
  };
}
function debugJsonValue(a) {
  if (a === null)
    return "null";
  switch (typeof a) {
    case "object":
      return Array.isArray(a) ? "array" : "object";
    case "string":
      return a.length > 100 ? "string" : '"'.concat(a.split('"').join('\\"'), '"');
    default:
      return String(a);
  }
}
function readField(a, u, c, l, v, p) {
  let _ = c.localName;
  if (c.oneof) {
    if (u === null && c.kind == "scalar")
      return;
    a = a[c.oneof.localName] = {
      case: _
    }, _ = "value";
  }
  if (c.repeated) {
    if (u === null)
      return;
    if (!Array.isArray(u))
      throw new Error("cannot decode field ".concat(v.typeName, ".").concat(c.name, " from JSON: ").concat(debugJsonValue(u)));
    const k = a[_];
    for (const O of u) {
      if (O === null)
        throw new Error("cannot decode field ".concat(v.typeName, ".").concat(c.name, " from JSON: ").concat(debugJsonValue(O)));
      let D;
      switch (c.kind) {
        case "message":
          D = c.T.fromJson(O, l);
          break;
        case "enum":
          if (D = readEnum(c.T, O, l.ignoreUnknownFields, !0), D === void 0)
            continue;
          break;
        case "scalar":
          try {
            D = readScalar(c.T, O, c.L, !0);
          } catch (F) {
            let z = "cannot decode field ".concat(v.typeName, ".").concat(c.name, " from JSON: ").concat(debugJsonValue(O));
            throw F instanceof Error && F.message.length > 0 && (z += ": ".concat(F.message)), new Error(z);
          }
          break;
      }
      k.push(D);
    }
  } else if (c.kind == "map") {
    if (u === null)
      return;
    if (typeof u != "object" || Array.isArray(u))
      throw new Error("cannot decode field ".concat(v.typeName, ".").concat(c.name, " from JSON: ").concat(debugJsonValue(u)));
    const k = a[_];
    for (const [O, D] of Object.entries(u)) {
      if (D === null)
        throw new Error("cannot decode field ".concat(v.typeName, ".").concat(c.name, " from JSON: map value null"));
      let F;
      switch (c.V.kind) {
        case "message":
          F = c.V.T.fromJson(D, l);
          break;
        case "enum":
          if (F = readEnum(c.V.T, D, l.ignoreUnknownFields, !0), F === void 0)
            continue;
          break;
        case "scalar":
          try {
            F = readScalar(c.V.T, D, LongType.BIGINT, !0);
          } catch (z) {
            let j = "cannot decode map value for field ".concat(v.typeName, ".").concat(c.name, " from JSON: ").concat(debugJsonValue(u));
            throw z instanceof Error && z.message.length > 0 && (j += ": ".concat(z.message)), new Error(j);
          }
          break;
      }
      try {
        k[readScalar(c.K, c.K == ScalarType.BOOL ? O == "true" ? !0 : O == "false" ? !1 : O : O, LongType.BIGINT, !0).toString()] = F;
      } catch (z) {
        let j = "cannot decode map key for field ".concat(v.typeName, ".").concat(c.name, " from JSON: ").concat(debugJsonValue(u));
        throw z instanceof Error && z.message.length > 0 && (j += ": ".concat(z.message)), new Error(j);
      }
    }
  } else
    switch (c.kind) {
      case "message":
        const k = c.T;
        if (u === null && k.typeName != "google.protobuf.Value") {
          if (c.oneof)
            throw new Error("cannot decode field ".concat(v.typeName, ".").concat(c.name, " from JSON: null is invalid for oneof field"));
          return;
        }
        a[_] instanceof Message ? a[_].fromJson(u, l) : (a[_] = k.fromJson(u, l), k.fieldWrapper && !c.oneof && (a[_] = k.fieldWrapper.unwrapField(a[_])));
        break;
      case "enum":
        const O = readEnum(c.T, u, l.ignoreUnknownFields, p);
        O !== void 0 && (a[_] = O);
        break;
      case "scalar":
        try {
          a[_] = readScalar(c.T, u, c.L, p);
        } catch (D) {
          let F = "cannot decode field ".concat(v.typeName, ".").concat(c.name, " from JSON: ").concat(debugJsonValue(u));
          throw D instanceof Error && D.message.length > 0 && (F += ": ".concat(D.message)), new Error(F);
        }
        break;
    }
}
function readScalar(a, u, c, l) {
  switch (a) {
    case ScalarType.DOUBLE:
    case ScalarType.FLOAT:
      if (u === null)
        return l ? 0 : void 0;
      if (u === "NaN")
        return Number.NaN;
      if (u === "Infinity")
        return Number.POSITIVE_INFINITY;
      if (u === "-Infinity")
        return Number.NEGATIVE_INFINITY;
      if (u === "" || typeof u == "string" && u.trim().length !== u.length || typeof u != "string" && typeof u != "number")
        break;
      const v = Number(u);
      if (Number.isNaN(v) || !Number.isFinite(v))
        break;
      return a == ScalarType.FLOAT && assertFloat32(v), v;
    case ScalarType.INT32:
    case ScalarType.FIXED32:
    case ScalarType.SFIXED32:
    case ScalarType.SINT32:
    case ScalarType.UINT32:
      if (u === null)
        return l ? 0 : void 0;
      let p;
      if (typeof u == "number" ? p = u : typeof u == "string" && u.length > 0 && u.trim().length === u.length && (p = Number(u)), p === void 0)
        break;
      return a == ScalarType.UINT32 ? assertUInt32(p) : assertInt32(p), p;
    case ScalarType.INT64:
    case ScalarType.SFIXED64:
    case ScalarType.SINT64:
      if (u === null)
        return l ? protoInt64.zero : void 0;
      if (typeof u != "number" && typeof u != "string")
        break;
      const _ = protoInt64.parse(u);
      return c ? _.toString() : _;
    case ScalarType.FIXED64:
    case ScalarType.UINT64:
      if (u === null)
        return l ? protoInt64.zero : void 0;
      if (typeof u != "number" && typeof u != "string")
        break;
      const k = protoInt64.uParse(u);
      return c ? k.toString() : k;
    case ScalarType.BOOL:
      if (u === null)
        return l ? !1 : void 0;
      if (typeof u != "boolean")
        break;
      return u;
    case ScalarType.STRING:
      if (u === null)
        return l ? "" : void 0;
      if (typeof u != "string")
        break;
      try {
        encodeURIComponent(u);
      } catch {
        throw new Error("invalid UTF8");
      }
      return u;
    case ScalarType.BYTES:
      if (u === null)
        return l ? new Uint8Array(0) : void 0;
      if (u === "")
        return new Uint8Array(0);
      if (typeof u != "string")
        break;
      return protoBase64.dec(u);
  }
  throw new Error();
}
function readEnum(a, u, c, l) {
  if (u === null)
    return l ? a.values[0].no : void 0;
  switch (typeof u) {
    case "number":
      if (Number.isInteger(u))
        return u;
      break;
    case "string":
      const v = a.findName(u);
      if (v || c)
        return v == null ? void 0 : v.no;
      break;
  }
  throw new Error("cannot decode enum ".concat(a.typeName, " from JSON: ").concat(debugJsonValue(u)));
}
function writeEnum(a, u, c, l) {
  var v;
  if (u === void 0)
    return u;
  if (!c && a.values[0].no === u)
    return;
  if (l)
    return u;
  if (a.typeName == "google.protobuf.NullValue")
    return null;
  const p = a.findNumber(u);
  return (v = p == null ? void 0 : p.name) !== null && v !== void 0 ? v : u;
}
function writeScalar(a, u, c) {
  if (u !== void 0)
    switch (a) {
      case ScalarType.INT32:
      case ScalarType.SFIXED32:
      case ScalarType.SINT32:
      case ScalarType.FIXED32:
      case ScalarType.UINT32:
        return assert$k(typeof u == "number"), u != 0 || c ? u : void 0;
      case ScalarType.FLOAT:
      case ScalarType.DOUBLE:
        return assert$k(typeof u == "number"), Number.isNaN(u) ? "NaN" : u === Number.POSITIVE_INFINITY ? "Infinity" : u === Number.NEGATIVE_INFINITY ? "-Infinity" : u !== 0 || c ? u : void 0;
      case ScalarType.STRING:
        return assert$k(typeof u == "string"), u.length > 0 || c ? u : void 0;
      case ScalarType.BOOL:
        return assert$k(typeof u == "boolean"), u || c ? u : void 0;
      case ScalarType.UINT64:
      case ScalarType.FIXED64:
      case ScalarType.INT64:
      case ScalarType.SFIXED64:
      case ScalarType.SINT64:
        return assert$k(typeof u == "bigint" || typeof u == "string" || typeof u == "number"), c || u != 0 ? u.toString(10) : void 0;
      case ScalarType.BYTES:
        return assert$k(u instanceof Uint8Array), c || u.byteLength > 0 ? protoBase64.enc(u) : void 0;
    }
}
function makeJsonFormatProto3() {
  return makeJsonFormatCommon(!0, (a, u) => function(l, v, p) {
    if (l.kind == "map") {
      const _ = {};
      switch (l.V.kind) {
        case "scalar":
          for (const [O, D] of Object.entries(v)) {
            const F = u(l.V.T, D, !0);
            assert$k(F !== void 0), _[O.toString()] = F;
          }
          break;
        case "message":
          for (const [O, D] of Object.entries(v))
            _[O.toString()] = D.toJson(p);
          break;
        case "enum":
          const k = l.V.T;
          for (const [O, D] of Object.entries(v)) {
            assert$k(D === void 0 || typeof D == "number");
            const F = a(k, D, !0, p.enumAsInteger);
            assert$k(F !== void 0), _[O.toString()] = F;
          }
          break;
      }
      return p.emitDefaultValues || Object.keys(_).length > 0 ? _ : void 0;
    } else if (l.repeated) {
      const _ = [];
      switch (l.kind) {
        case "scalar":
          for (let k = 0; k < v.length; k++)
            _.push(u(l.T, v[k], !0));
          break;
        case "enum":
          for (let k = 0; k < v.length; k++)
            _.push(a(l.T, v[k], !0, p.enumAsInteger));
          break;
        case "message":
          for (let k = 0; k < v.length; k++)
            _.push(v[k].toJson(p));
          break;
      }
      return p.emitDefaultValues || _.length > 0 ? _ : void 0;
    } else {
      if (v === void 0)
        return;
      switch (l.kind) {
        case "scalar":
          return u(l.T, v, !!l.oneof || l.opt || p.emitDefaultValues);
        case "enum":
          return a(l.T, v, !!l.oneof || l.opt || p.emitDefaultValues, p.enumAsInteger);
        case "message":
          return wrapField(l.T, v).toJson(p);
      }
    }
  });
}
function makeUtilCommon() {
  return {
    setEnumType,
    initPartial(a, u) {
      if (a === void 0)
        return;
      const c = u.getType();
      for (const l of c.fields.byMember()) {
        const v = l.localName, p = u, _ = a;
        if (_[v] !== void 0)
          switch (l.kind) {
            case "oneof":
              const k = _[v].case;
              if (k === void 0)
                continue;
              const O = l.findField(k);
              let D = _[v].value;
              O && O.kind == "message" && !(D instanceof O.T) ? D = new O.T(D) : O && O.kind === "scalar" && O.T === ScalarType.BYTES && (D = toU8Arr(D)), p[v] = {
                case: k,
                value: D
              };
              break;
            case "scalar":
            case "enum":
              let F = _[v];
              l.T === ScalarType.BYTES && (F = l.repeated ? F.map(toU8Arr) : toU8Arr(F)), p[v] = F;
              break;
            case "map":
              switch (l.V.kind) {
                case "scalar":
                case "enum":
                  if (l.V.T === ScalarType.BYTES)
                    for (const [ee, X] of Object.entries(_[v]))
                      p[v][ee] = toU8Arr(X);
                  else
                    Object.assign(p[v], _[v]);
                  break;
                case "message":
                  const j = l.V.T;
                  for (const ee of Object.keys(_[v])) {
                    let X = _[v][ee];
                    j.fieldWrapper || (X = new j(X)), p[v][ee] = X;
                  }
                  break;
              }
              break;
            case "message":
              const z = l.T;
              if (l.repeated)
                p[v] = _[v].map((j) => j instanceof z ? j : new z(j));
              else if (_[v] !== void 0) {
                const j = _[v];
                z.fieldWrapper ? /* We can't use BytesValue.typeName as that will create a circular import */ z.typeName === "google.protobuf.BytesValue" ? p[v] = toU8Arr(j) : p[v] = j : p[v] = j instanceof z ? j : new z(j);
              }
              break;
          }
      }
    },
    equals(a, u, c) {
      return u === c ? !0 : !u || !c ? !1 : a.fields.byMember().every((l) => {
        const v = u[l.localName], p = c[l.localName];
        if (l.repeated) {
          if (v.length !== p.length)
            return !1;
          switch (l.kind) {
            case "message":
              return v.every((_, k) => l.T.equals(_, p[k]));
            case "scalar":
              return v.every((_, k) => scalarEquals(l.T, _, p[k]));
            case "enum":
              return v.every((_, k) => scalarEquals(ScalarType.INT32, _, p[k]));
          }
          throw new Error("repeated cannot contain ".concat(l.kind));
        }
        switch (l.kind) {
          case "message":
            return l.T.equals(v, p);
          case "enum":
            return scalarEquals(ScalarType.INT32, v, p);
          case "scalar":
            return scalarEquals(l.T, v, p);
          case "oneof":
            if (v.case !== p.case)
              return !1;
            const _ = l.findField(v.case);
            if (_ === void 0)
              return !0;
            switch (_.kind) {
              case "message":
                return _.T.equals(v.value, p.value);
              case "enum":
                return scalarEquals(ScalarType.INT32, v.value, p.value);
              case "scalar":
                return scalarEquals(_.T, v.value, p.value);
            }
            throw new Error("oneof cannot contain ".concat(_.kind));
          case "map":
            const k = Object.keys(v).concat(Object.keys(p));
            switch (l.V.kind) {
              case "message":
                const O = l.V.T;
                return k.every((F) => O.equals(v[F], p[F]));
              case "enum":
                return k.every((F) => scalarEquals(ScalarType.INT32, v[F], p[F]));
              case "scalar":
                const D = l.V.T;
                return k.every((F) => scalarEquals(D, v[F], p[F]));
            }
            break;
        }
      });
    },
    clone(a) {
      const u = a.getType(), c = new u(), l = c;
      for (const v of u.fields.byMember()) {
        const p = a[v.localName];
        let _;
        if (v.repeated)
          _ = p.map(cloneSingularField);
        else if (v.kind == "map") {
          _ = l[v.localName];
          for (const [k, O] of Object.entries(p))
            _[k] = cloneSingularField(O);
        } else
          v.kind == "oneof" ? _ = v.findField(p.case) ? {
            case: p.case,
            value: cloneSingularField(p.value)
          } : {
            case: void 0
          } : _ = cloneSingularField(p);
        l[v.localName] = _;
      }
      return c;
    }
  };
}
function cloneSingularField(a) {
  if (a === void 0)
    return a;
  if (a instanceof Message)
    return a.clone();
  if (a instanceof Uint8Array) {
    const u = new Uint8Array(a.byteLength);
    return u.set(a), u;
  }
  return a;
}
function toU8Arr(a) {
  return a instanceof Uint8Array ? a : new Uint8Array(a);
}
class InternalFieldList {
  constructor(u, c) {
    this._fields = u, this._normalizer = c;
  }
  findJsonName(u) {
    if (!this.jsonNames) {
      const c = {};
      for (const l of this.list())
        c[l.jsonName] = c[l.name] = l;
      this.jsonNames = c;
    }
    return this.jsonNames[u];
  }
  find(u) {
    if (!this.numbers) {
      const c = {};
      for (const l of this.list())
        c[l.no] = l;
      this.numbers = c;
    }
    return this.numbers[u];
  }
  list() {
    return this.all || (this.all = this._normalizer(this._fields)), this.all;
  }
  byNumber() {
    return this.numbersAsc || (this.numbersAsc = this.list().concat().sort((u, c) => u.no - c.no)), this.numbersAsc;
  }
  byMember() {
    if (!this.members) {
      this.members = [];
      const u = this.members;
      let c;
      for (const l of this.list())
        l.oneof ? l.oneof !== c && (c = l.oneof, u.push(c)) : u.push(l);
    }
    return this.members;
  }
}
function localFieldName(a, u) {
  const c = protoCamelCase(a);
  return u ? c : safeObjectProperty(safeMessageProperty(c));
}
function localOneofName(a) {
  return localFieldName(a, !1);
}
const fieldJsonName = protoCamelCase;
function protoCamelCase(a) {
  let u = !1;
  const c = [];
  for (let l = 0; l < a.length; l++) {
    let v = a.charAt(l);
    switch (v) {
      case "_":
        u = !0;
        break;
      case "0":
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        c.push(v), u = !1;
        break;
      default:
        u && (u = !1, v = v.toUpperCase()), c.push(v);
        break;
    }
  }
  return c.join("");
}
const reservedObjectProperties = /* @__PURE__ */ new Set([
  // names reserved by JavaScript
  "constructor",
  "toString",
  "toJSON",
  "valueOf"
]), reservedMessageProperties = /* @__PURE__ */ new Set([
  // names reserved by the runtime
  "getType",
  "clone",
  "equals",
  "fromBinary",
  "fromJson",
  "fromJsonString",
  "toBinary",
  "toJson",
  "toJsonString",
  // names reserved by the runtime for the future
  "toObject"
]), fallback = (a) => "".concat(a, "$"), safeMessageProperty = (a) => reservedMessageProperties.has(a) ? fallback(a) : a, safeObjectProperty = (a) => reservedObjectProperties.has(a) ? fallback(a) : a;
class InternalOneofInfo {
  constructor(u) {
    this.kind = "oneof", this.repeated = !1, this.packed = !1, this.opt = !1, this.default = void 0, this.fields = [], this.name = u, this.localName = localOneofName(u);
  }
  addField(u) {
    assert$k(u.oneof === this, "field ".concat(u.name, " not one of ").concat(this.name)), this.fields.push(u);
  }
  findField(u) {
    if (!this._lookup) {
      this._lookup = /* @__PURE__ */ Object.create(null);
      for (let c = 0; c < this.fields.length; c++)
        this._lookup[this.fields[c].localName] = this.fields[c];
    }
    return this._lookup[u];
  }
}
const proto3 = makeProtoRuntime("proto3", makeJsonFormatProto3(), makeBinaryFormatProto3(), Object.assign(Object.assign({}, makeUtilCommon()), {
  newFieldList(a) {
    return new InternalFieldList(a, normalizeFieldInfosProto3);
  },
  initFields(a) {
    for (const u of a.getType().fields.byMember()) {
      if (u.opt)
        continue;
      const c = u.localName, l = a;
      if (u.repeated) {
        l[c] = [];
        continue;
      }
      switch (u.kind) {
        case "oneof":
          l[c] = {
            case: void 0
          };
          break;
        case "enum":
          l[c] = 0;
          break;
        case "map":
          l[c] = {};
          break;
        case "scalar":
          l[c] = scalarDefaultValue(u.T, u.L);
          break;
      }
    }
  }
}));
function normalizeFieldInfosProto3(a) {
  var u, c, l, v;
  const p = [];
  let _;
  for (const k of typeof a == "function" ? a() : a) {
    const O = k;
    if (O.localName = localFieldName(k.name, k.oneof !== void 0), O.jsonName = (u = k.jsonName) !== null && u !== void 0 ? u : fieldJsonName(k.name), O.repeated = (c = k.repeated) !== null && c !== void 0 ? c : !1, k.kind == "scalar" && (O.L = (l = k.L) !== null && l !== void 0 ? l : LongType.BIGINT), k.oneof !== void 0) {
      const D = typeof k.oneof == "string" ? k.oneof : k.oneof.name;
      (!_ || _.name != D) && (_ = new InternalOneofInfo(D)), O.oneof = _, _.addField(O);
    }
    k.kind == "message" && (O.delimited = !1), O.packed = (v = k.packed) !== null && v !== void 0 ? v : k.kind == "enum" || k.kind == "scalar" && k.T != ScalarType.BYTES && k.T != ScalarType.STRING, p.push(O);
  }
  return p;
}
class Timestamp extends Message {
  constructor(u) {
    super(), this.seconds = protoInt64.zero, this.nanos = 0, proto3.util.initPartial(u, this);
  }
  fromJson(u, c) {
    if (typeof u != "string")
      throw new Error("cannot decode google.protobuf.Timestamp from JSON: ".concat(proto3.json.debug(u)));
    const l = u.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:Z|\.([0-9]{3,9})Z|([+-][0-9][0-9]:[0-9][0-9]))$/);
    if (!l)
      throw new Error("cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string");
    const v = Date.parse(l[1] + "-" + l[2] + "-" + l[3] + "T" + l[4] + ":" + l[5] + ":" + l[6] + (l[8] ? l[8] : "Z"));
    if (Number.isNaN(v))
      throw new Error("cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string");
    if (v < Date.parse("0001-01-01T00:00:00Z") || v > Date.parse("9999-12-31T23:59:59Z"))
      throw new Error("cannot decode message google.protobuf.Timestamp from JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive");
    return this.seconds = protoInt64.parse(v / 1e3), this.nanos = 0, l[7] && (this.nanos = parseInt("1" + l[7] + "0".repeat(9 - l[7].length)) - 1e9), this;
  }
  toJson(u) {
    const c = Number(this.seconds) * 1e3;
    if (c < Date.parse("0001-01-01T00:00:00Z") || c > Date.parse("9999-12-31T23:59:59Z"))
      throw new Error("cannot encode google.protobuf.Timestamp to JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive");
    if (this.nanos < 0)
      throw new Error("cannot encode google.protobuf.Timestamp to JSON: nanos must not be negative");
    let l = "Z";
    if (this.nanos > 0) {
      const v = (this.nanos + 1e9).toString().substring(1);
      v.substring(3) === "000000" ? l = "." + v.substring(0, 3) + "Z" : v.substring(6) === "000" ? l = "." + v.substring(0, 6) + "Z" : l = "." + v + "Z";
    }
    return new Date(c).toISOString().replace(".000Z", l);
  }
  toDate() {
    return new Date(Number(this.seconds) * 1e3 + Math.ceil(this.nanos / 1e6));
  }
  static now() {
    return Timestamp.fromDate(/* @__PURE__ */ new Date());
  }
  static fromDate(u) {
    const c = u.getTime();
    return new Timestamp({
      seconds: protoInt64.parse(Math.floor(c / 1e3)),
      nanos: c % 1e3 * 1e6
    });
  }
  static fromBinary(u, c) {
    return new Timestamp().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new Timestamp().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new Timestamp().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(Timestamp, u, c);
  }
}
Timestamp.runtime = proto3;
Timestamp.typeName = "google.protobuf.Timestamp";
Timestamp.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "seconds",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 2,
  name: "nanos",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}]);
const AudioCodec$1 = proto3.makeEnum("livekit.AudioCodec", [{
  no: 0,
  name: "DEFAULT_AC"
}, {
  no: 1,
  name: "OPUS"
}, {
  no: 2,
  name: "AAC"
}]), VideoCodec$1 = proto3.makeEnum("livekit.VideoCodec", [{
  no: 0,
  name: "DEFAULT_VC"
}, {
  no: 1,
  name: "H264_BASELINE"
}, {
  no: 2,
  name: "H264_MAIN"
}, {
  no: 3,
  name: "H264_HIGH"
}, {
  no: 4,
  name: "VP8"
}]), ImageCodec = proto3.makeEnum("livekit.ImageCodec", [{
  no: 0,
  name: "IC_DEFAULT"
}, {
  no: 1,
  name: "IC_JPEG"
}]), TrackType = proto3.makeEnum("livekit.TrackType", [{
  no: 0,
  name: "AUDIO"
}, {
  no: 1,
  name: "VIDEO"
}, {
  no: 2,
  name: "DATA"
}]), TrackSource = proto3.makeEnum("livekit.TrackSource", [{
  no: 0,
  name: "UNKNOWN"
}, {
  no: 1,
  name: "CAMERA"
}, {
  no: 2,
  name: "MICROPHONE"
}, {
  no: 3,
  name: "SCREEN_SHARE"
}, {
  no: 4,
  name: "SCREEN_SHARE_AUDIO"
}]), VideoQuality$1 = proto3.makeEnum("livekit.VideoQuality", [{
  no: 0,
  name: "LOW"
}, {
  no: 1,
  name: "MEDIUM"
}, {
  no: 2,
  name: "HIGH"
}, {
  no: 3,
  name: "OFF"
}]), ConnectionQuality$1 = proto3.makeEnum("livekit.ConnectionQuality", [{
  no: 0,
  name: "POOR"
}, {
  no: 1,
  name: "GOOD"
}, {
  no: 2,
  name: "EXCELLENT"
}, {
  no: 3,
  name: "LOST"
}]), ClientConfigSetting = proto3.makeEnum("livekit.ClientConfigSetting", [{
  no: 0,
  name: "UNSET"
}, {
  no: 1,
  name: "DISABLED"
}, {
  no: 2,
  name: "ENABLED"
}]), DisconnectReason = proto3.makeEnum("livekit.DisconnectReason", [{
  no: 0,
  name: "UNKNOWN_REASON"
}, {
  no: 1,
  name: "CLIENT_INITIATED"
}, {
  no: 2,
  name: "DUPLICATE_IDENTITY"
}, {
  no: 3,
  name: "SERVER_SHUTDOWN"
}, {
  no: 4,
  name: "PARTICIPANT_REMOVED"
}, {
  no: 5,
  name: "ROOM_DELETED"
}, {
  no: 6,
  name: "STATE_MISMATCH"
}, {
  no: 7,
  name: "JOIN_FAILURE"
}, {
  no: 8,
  name: "MIGRATION"
}, {
  no: 9,
  name: "SIGNAL_CLOSE"
}]), ReconnectReason = proto3.makeEnum("livekit.ReconnectReason", [{
  no: 0,
  name: "RR_UNKNOWN"
}, {
  no: 1,
  name: "RR_SIGNAL_DISCONNECTED"
}, {
  no: 2,
  name: "RR_PUBLISHER_FAILED"
}, {
  no: 3,
  name: "RR_SUBSCRIBER_FAILED"
}, {
  no: 4,
  name: "RR_SWITCH_CANDIDATE"
}]), SubscriptionError = proto3.makeEnum("livekit.SubscriptionError", [{
  no: 0,
  name: "SE_UNKNOWN"
}, {
  no: 1,
  name: "SE_CODEC_UNSUPPORTED"
}, {
  no: 2,
  name: "SE_TRACK_NOTFOUND"
}]), Room$1 = proto3.makeMessageType("livekit.Room", () => [{
  no: 1,
  name: "sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "empty_timeout",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 14,
  name: "departure_timeout",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 4,
  name: "max_participants",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 5,
  name: "creation_time",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 6,
  name: "turn_password",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 7,
  name: "enabled_codecs",
  kind: "message",
  T: Codec,
  repeated: !0
}, {
  no: 8,
  name: "metadata",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 9,
  name: "num_participants",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 11,
  name: "num_publishers",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 10,
  name: "active_recording",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 13,
  name: "version",
  kind: "message",
  T: TimedVersion
}]), Codec = proto3.makeMessageType("livekit.Codec", () => [{
  no: 1,
  name: "mime",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "fmtp_line",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
proto3.makeMessageType("livekit.PlayoutDelay", () => [{
  no: 1,
  name: "enabled",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 2,
  name: "min",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 3,
  name: "max",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}]);
const ParticipantPermission = proto3.makeMessageType("livekit.ParticipantPermission", () => [{
  no: 1,
  name: "can_subscribe",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 2,
  name: "can_publish",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 3,
  name: "can_publish_data",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 9,
  name: "can_publish_sources",
  kind: "enum",
  T: proto3.getEnumType(TrackSource),
  repeated: !0
}, {
  no: 7,
  name: "hidden",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 8,
  name: "recorder",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 10,
  name: "can_update_metadata",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 11,
  name: "agent",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}]), ParticipantInfo = proto3.makeMessageType("livekit.ParticipantInfo", () => [{
  no: 1,
  name: "sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "identity",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "state",
  kind: "enum",
  T: proto3.getEnumType(ParticipantInfo_State)
}, {
  no: 4,
  name: "tracks",
  kind: "message",
  T: TrackInfo,
  repeated: !0
}, {
  no: 5,
  name: "metadata",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 6,
  name: "joined_at",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 9,
  name: "name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 10,
  name: "version",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 11,
  name: "permission",
  kind: "message",
  T: ParticipantPermission
}, {
  no: 12,
  name: "region",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 13,
  name: "is_publisher",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 14,
  name: "kind",
  kind: "enum",
  T: proto3.getEnumType(ParticipantInfo_Kind)
}]), ParticipantInfo_State = proto3.makeEnum("livekit.ParticipantInfo.State", [{
  no: 0,
  name: "JOINING"
}, {
  no: 1,
  name: "JOINED"
}, {
  no: 2,
  name: "ACTIVE"
}, {
  no: 3,
  name: "DISCONNECTED"
}]), ParticipantInfo_Kind = proto3.makeEnum("livekit.ParticipantInfo.Kind", [{
  no: 0,
  name: "STANDARD"
}, {
  no: 1,
  name: "INGRESS"
}, {
  no: 2,
  name: "EGRESS"
}, {
  no: 3,
  name: "SIP"
}, {
  no: 4,
  name: "AGENT"
}]);
proto3.makeMessageType("livekit.Encryption", []);
const Encryption_Type = proto3.makeEnum("livekit.Encryption.Type", [{
  no: 0,
  name: "NONE"
}, {
  no: 1,
  name: "GCM"
}, {
  no: 2,
  name: "CUSTOM"
}]), SimulcastCodecInfo = proto3.makeMessageType("livekit.SimulcastCodecInfo", () => [{
  no: 1,
  name: "mime_type",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "mid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "cid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 4,
  name: "layers",
  kind: "message",
  T: VideoLayer,
  repeated: !0
}]), TrackInfo = proto3.makeMessageType("livekit.TrackInfo", () => [{
  no: 1,
  name: "sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "type",
  kind: "enum",
  T: proto3.getEnumType(TrackType)
}, {
  no: 3,
  name: "name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 4,
  name: "muted",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 5,
  name: "width",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 6,
  name: "height",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 7,
  name: "simulcast",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 8,
  name: "disable_dtx",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 9,
  name: "source",
  kind: "enum",
  T: proto3.getEnumType(TrackSource)
}, {
  no: 10,
  name: "layers",
  kind: "message",
  T: VideoLayer,
  repeated: !0
}, {
  no: 11,
  name: "mime_type",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 12,
  name: "mid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 13,
  name: "codecs",
  kind: "message",
  T: SimulcastCodecInfo,
  repeated: !0
}, {
  no: 14,
  name: "stereo",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 15,
  name: "disable_red",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 16,
  name: "encryption",
  kind: "enum",
  T: proto3.getEnumType(Encryption_Type)
}, {
  no: 17,
  name: "stream",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 18,
  name: "version",
  kind: "message",
  T: TimedVersion
}]), VideoLayer = proto3.makeMessageType("livekit.VideoLayer", () => [{
  no: 1,
  name: "quality",
  kind: "enum",
  T: proto3.getEnumType(VideoQuality$1)
}, {
  no: 2,
  name: "width",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 3,
  name: "height",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 4,
  name: "bitrate",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 5,
  name: "ssrc",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}]), DataPacket = proto3.makeMessageType("livekit.DataPacket", () => [{
  no: 1,
  name: "kind",
  kind: "enum",
  T: proto3.getEnumType(DataPacket_Kind)
}, {
  no: 4,
  name: "participant_identity",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "destination_identities",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 2,
  name: "user",
  kind: "message",
  T: UserPacket,
  oneof: "value"
}, {
  no: 3,
  name: "speaker",
  kind: "message",
  T: ActiveSpeakerUpdate,
  oneof: "value"
}, {
  no: 6,
  name: "sip_dtmf",
  kind: "message",
  T: SipDTMF,
  oneof: "value"
}]), DataPacket_Kind = proto3.makeEnum("livekit.DataPacket.Kind", [{
  no: 0,
  name: "RELIABLE"
}, {
  no: 1,
  name: "LOSSY"
}]), ActiveSpeakerUpdate = proto3.makeMessageType("livekit.ActiveSpeakerUpdate", () => [{
  no: 1,
  name: "speakers",
  kind: "message",
  T: SpeakerInfo,
  repeated: !0
}]), SpeakerInfo = proto3.makeMessageType("livekit.SpeakerInfo", () => [{
  no: 1,
  name: "sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "level",
  kind: "scalar",
  T: 2
  /* ScalarType.FLOAT */
}, {
  no: 3,
  name: "active",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}]), UserPacket = proto3.makeMessageType("livekit.UserPacket", () => [{
  no: 1,
  name: "participant_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "participant_identity",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "payload",
  kind: "scalar",
  T: 12
  /* ScalarType.BYTES */
}, {
  no: 3,
  name: "destination_sids",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 6,
  name: "destination_identities",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 4,
  name: "topic",
  kind: "scalar",
  T: 9,
  opt: !0
}]), SipDTMF = proto3.makeMessageType("livekit.SipDTMF", () => [{
  no: 3,
  name: "code",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 4,
  name: "digit",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), ParticipantTracks = proto3.makeMessageType("livekit.ParticipantTracks", () => [{
  no: 1,
  name: "participant_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "track_sids",
  kind: "scalar",
  T: 9,
  repeated: !0
}]), ServerInfo = proto3.makeMessageType("livekit.ServerInfo", () => [{
  no: 1,
  name: "edition",
  kind: "enum",
  T: proto3.getEnumType(ServerInfo_Edition)
}, {
  no: 2,
  name: "version",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "protocol",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}, {
  no: 4,
  name: "region",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "node_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 6,
  name: "debug_info",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), ServerInfo_Edition = proto3.makeEnum("livekit.ServerInfo.Edition", [{
  no: 0,
  name: "Standard"
}, {
  no: 1,
  name: "Cloud"
}]), ClientInfo = proto3.makeMessageType("livekit.ClientInfo", () => [{
  no: 1,
  name: "sdk",
  kind: "enum",
  T: proto3.getEnumType(ClientInfo_SDK)
}, {
  no: 2,
  name: "version",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "protocol",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}, {
  no: 4,
  name: "os",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "os_version",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 6,
  name: "device_model",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 7,
  name: "browser",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 8,
  name: "browser_version",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 9,
  name: "address",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 10,
  name: "network",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), ClientInfo_SDK = proto3.makeEnum("livekit.ClientInfo.SDK", [{
  no: 0,
  name: "UNKNOWN"
}, {
  no: 1,
  name: "JS"
}, {
  no: 2,
  name: "SWIFT"
}, {
  no: 3,
  name: "ANDROID"
}, {
  no: 4,
  name: "FLUTTER"
}, {
  no: 5,
  name: "GO"
}, {
  no: 6,
  name: "UNITY"
}, {
  no: 7,
  name: "REACT_NATIVE"
}, {
  no: 8,
  name: "RUST"
}, {
  no: 9,
  name: "PYTHON"
}, {
  no: 10,
  name: "CPP"
}]), ClientConfiguration = proto3.makeMessageType("livekit.ClientConfiguration", () => [{
  no: 1,
  name: "video",
  kind: "message",
  T: VideoConfiguration
}, {
  no: 2,
  name: "screen",
  kind: "message",
  T: VideoConfiguration
}, {
  no: 3,
  name: "resume_connection",
  kind: "enum",
  T: proto3.getEnumType(ClientConfigSetting)
}, {
  no: 4,
  name: "disabled_codecs",
  kind: "message",
  T: DisabledCodecs
}, {
  no: 5,
  name: "force_relay",
  kind: "enum",
  T: proto3.getEnumType(ClientConfigSetting)
}]), VideoConfiguration = proto3.makeMessageType("livekit.VideoConfiguration", () => [{
  no: 1,
  name: "hardware_encoder",
  kind: "enum",
  T: proto3.getEnumType(ClientConfigSetting)
}]), DisabledCodecs = proto3.makeMessageType("livekit.DisabledCodecs", () => [{
  no: 1,
  name: "codecs",
  kind: "message",
  T: Codec,
  repeated: !0
}, {
  no: 2,
  name: "publish",
  kind: "message",
  T: Codec,
  repeated: !0
}]), RTPDrift = proto3.makeMessageType("livekit.RTPDrift", () => [{
  no: 1,
  name: "start_time",
  kind: "message",
  T: Timestamp
}, {
  no: 2,
  name: "end_time",
  kind: "message",
  T: Timestamp
}, {
  no: 3,
  name: "duration",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}, {
  no: 4,
  name: "start_timestamp",
  kind: "scalar",
  T: 4
  /* ScalarType.UINT64 */
}, {
  no: 5,
  name: "end_timestamp",
  kind: "scalar",
  T: 4
  /* ScalarType.UINT64 */
}, {
  no: 6,
  name: "rtp_clock_ticks",
  kind: "scalar",
  T: 4
  /* ScalarType.UINT64 */
}, {
  no: 7,
  name: "drift_samples",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 8,
  name: "drift_ms",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}, {
  no: 9,
  name: "clock_rate",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}]);
proto3.makeMessageType("livekit.RTPStats", () => [{
  no: 1,
  name: "start_time",
  kind: "message",
  T: Timestamp
}, {
  no: 2,
  name: "end_time",
  kind: "message",
  T: Timestamp
}, {
  no: 3,
  name: "duration",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}, {
  no: 4,
  name: "packets",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 5,
  name: "packet_rate",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}, {
  no: 6,
  name: "bytes",
  kind: "scalar",
  T: 4
  /* ScalarType.UINT64 */
}, {
  no: 39,
  name: "header_bytes",
  kind: "scalar",
  T: 4
  /* ScalarType.UINT64 */
}, {
  no: 7,
  name: "bitrate",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}, {
  no: 8,
  name: "packets_lost",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 9,
  name: "packet_loss_rate",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}, {
  no: 10,
  name: "packet_loss_percentage",
  kind: "scalar",
  T: 2
  /* ScalarType.FLOAT */
}, {
  no: 11,
  name: "packets_duplicate",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 12,
  name: "packet_duplicate_rate",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}, {
  no: 13,
  name: "bytes_duplicate",
  kind: "scalar",
  T: 4
  /* ScalarType.UINT64 */
}, {
  no: 40,
  name: "header_bytes_duplicate",
  kind: "scalar",
  T: 4
  /* ScalarType.UINT64 */
}, {
  no: 14,
  name: "bitrate_duplicate",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}, {
  no: 15,
  name: "packets_padding",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 16,
  name: "packet_padding_rate",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}, {
  no: 17,
  name: "bytes_padding",
  kind: "scalar",
  T: 4
  /* ScalarType.UINT64 */
}, {
  no: 41,
  name: "header_bytes_padding",
  kind: "scalar",
  T: 4
  /* ScalarType.UINT64 */
}, {
  no: 18,
  name: "bitrate_padding",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}, {
  no: 19,
  name: "packets_out_of_order",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 20,
  name: "frames",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 21,
  name: "frame_rate",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}, {
  no: 22,
  name: "jitter_current",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}, {
  no: 23,
  name: "jitter_max",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}, {
  no: 24,
  name: "gap_histogram",
  kind: "map",
  K: 5,
  V: {
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }
}, {
  no: 25,
  name: "nacks",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 37,
  name: "nack_acks",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 26,
  name: "nack_misses",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 38,
  name: "nack_repeated",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 27,
  name: "plis",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 28,
  name: "last_pli",
  kind: "message",
  T: Timestamp
}, {
  no: 29,
  name: "firs",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 30,
  name: "last_fir",
  kind: "message",
  T: Timestamp
}, {
  no: 31,
  name: "rtt_current",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 32,
  name: "rtt_max",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 33,
  name: "key_frames",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 34,
  name: "last_key_frame",
  kind: "message",
  T: Timestamp
}, {
  no: 35,
  name: "layer_lock_plis",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 36,
  name: "last_layer_lock_pli",
  kind: "message",
  T: Timestamp
}, {
  no: 44,
  name: "packet_drift",
  kind: "message",
  T: RTPDrift
}, {
  no: 45,
  name: "report_drift",
  kind: "message",
  T: RTPDrift
}]);
const TimedVersion = proto3.makeMessageType("livekit.TimedVersion", () => [{
  no: 1,
  name: "unix_micro",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 2,
  name: "ticks",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}]), EncodedFileType = proto3.makeEnum("livekit.EncodedFileType", [{
  no: 0,
  name: "DEFAULT_FILETYPE"
}, {
  no: 1,
  name: "MP4"
}, {
  no: 2,
  name: "OGG"
}]), SegmentedFileProtocol = proto3.makeEnum("livekit.SegmentedFileProtocol", [{
  no: 0,
  name: "DEFAULT_SEGMENTED_FILE_PROTOCOL"
}, {
  no: 1,
  name: "HLS_PROTOCOL"
}]), SegmentedFileSuffix = proto3.makeEnum("livekit.SegmentedFileSuffix", [{
  no: 0,
  name: "INDEX"
}, {
  no: 1,
  name: "TIMESTAMP"
}]), ImageFileSuffix = proto3.makeEnum("livekit.ImageFileSuffix", [{
  no: 0,
  name: "IMAGE_SUFFIX_INDEX"
}, {
  no: 1,
  name: "IMAGE_SUFFIX_TIMESTAMP"
}]), StreamProtocol = proto3.makeEnum("livekit.StreamProtocol", [{
  no: 0,
  name: "DEFAULT_PROTOCOL"
}, {
  no: 1,
  name: "RTMP"
}]), EncodingOptionsPreset = proto3.makeEnum("livekit.EncodingOptionsPreset", [{
  no: 0,
  name: "H264_720P_30"
}, {
  no: 1,
  name: "H264_720P_60"
}, {
  no: 2,
  name: "H264_1080P_30"
}, {
  no: 3,
  name: "H264_1080P_60"
}, {
  no: 4,
  name: "PORTRAIT_H264_720P_30"
}, {
  no: 5,
  name: "PORTRAIT_H264_720P_60"
}, {
  no: 6,
  name: "PORTRAIT_H264_1080P_30"
}, {
  no: 7,
  name: "PORTRAIT_H264_1080P_60"
}]), EgressStatus = proto3.makeEnum("livekit.EgressStatus", [{
  no: 0,
  name: "EGRESS_STARTING"
}, {
  no: 1,
  name: "EGRESS_ACTIVE"
}, {
  no: 2,
  name: "EGRESS_ENDING"
}, {
  no: 3,
  name: "EGRESS_COMPLETE"
}, {
  no: 4,
  name: "EGRESS_FAILED"
}, {
  no: 5,
  name: "EGRESS_ABORTED"
}, {
  no: 6,
  name: "EGRESS_LIMIT_REACHED"
}]), RoomCompositeEgressRequest = proto3.makeMessageType("livekit.RoomCompositeEgressRequest", () => [{
  no: 1,
  name: "room_name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "layout",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "audio_only",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 4,
  name: "video_only",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 5,
  name: "custom_base_url",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 6,
  name: "file",
  kind: "message",
  T: EncodedFileOutput,
  oneof: "output"
}, {
  no: 7,
  name: "stream",
  kind: "message",
  T: StreamOutput,
  oneof: "output"
}, {
  no: 10,
  name: "segments",
  kind: "message",
  T: SegmentedFileOutput,
  oneof: "output"
}, {
  no: 8,
  name: "preset",
  kind: "enum",
  T: proto3.getEnumType(EncodingOptionsPreset),
  oneof: "options"
}, {
  no: 9,
  name: "advanced",
  kind: "message",
  T: EncodingOptions,
  oneof: "options"
}, {
  no: 11,
  name: "file_outputs",
  kind: "message",
  T: EncodedFileOutput,
  repeated: !0
}, {
  no: 12,
  name: "stream_outputs",
  kind: "message",
  T: StreamOutput,
  repeated: !0
}, {
  no: 13,
  name: "segment_outputs",
  kind: "message",
  T: SegmentedFileOutput,
  repeated: !0
}, {
  no: 14,
  name: "image_outputs",
  kind: "message",
  T: ImageOutput,
  repeated: !0
}]), WebEgressRequest = proto3.makeMessageType("livekit.WebEgressRequest", () => [{
  no: 1,
  name: "url",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "audio_only",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 3,
  name: "video_only",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 12,
  name: "await_start_signal",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 4,
  name: "file",
  kind: "message",
  T: EncodedFileOutput,
  oneof: "output"
}, {
  no: 5,
  name: "stream",
  kind: "message",
  T: StreamOutput,
  oneof: "output"
}, {
  no: 6,
  name: "segments",
  kind: "message",
  T: SegmentedFileOutput,
  oneof: "output"
}, {
  no: 7,
  name: "preset",
  kind: "enum",
  T: proto3.getEnumType(EncodingOptionsPreset),
  oneof: "options"
}, {
  no: 8,
  name: "advanced",
  kind: "message",
  T: EncodingOptions,
  oneof: "options"
}, {
  no: 9,
  name: "file_outputs",
  kind: "message",
  T: EncodedFileOutput,
  repeated: !0
}, {
  no: 10,
  name: "stream_outputs",
  kind: "message",
  T: StreamOutput,
  repeated: !0
}, {
  no: 11,
  name: "segment_outputs",
  kind: "message",
  T: SegmentedFileOutput,
  repeated: !0
}, {
  no: 13,
  name: "image_outputs",
  kind: "message",
  T: ImageOutput,
  repeated: !0
}]), ParticipantEgressRequest = proto3.makeMessageType("livekit.ParticipantEgressRequest", () => [{
  no: 1,
  name: "room_name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "identity",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "screen_share",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 4,
  name: "preset",
  kind: "enum",
  T: proto3.getEnumType(EncodingOptionsPreset),
  oneof: "options"
}, {
  no: 5,
  name: "advanced",
  kind: "message",
  T: EncodingOptions,
  oneof: "options"
}, {
  no: 6,
  name: "file_outputs",
  kind: "message",
  T: EncodedFileOutput,
  repeated: !0
}, {
  no: 7,
  name: "stream_outputs",
  kind: "message",
  T: StreamOutput,
  repeated: !0
}, {
  no: 8,
  name: "segment_outputs",
  kind: "message",
  T: SegmentedFileOutput,
  repeated: !0
}, {
  no: 9,
  name: "image_outputs",
  kind: "message",
  T: ImageOutput,
  repeated: !0
}]), TrackCompositeEgressRequest = proto3.makeMessageType("livekit.TrackCompositeEgressRequest", () => [{
  no: 1,
  name: "room_name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "audio_track_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "video_track_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 4,
  name: "file",
  kind: "message",
  T: EncodedFileOutput,
  oneof: "output"
}, {
  no: 5,
  name: "stream",
  kind: "message",
  T: StreamOutput,
  oneof: "output"
}, {
  no: 8,
  name: "segments",
  kind: "message",
  T: SegmentedFileOutput,
  oneof: "output"
}, {
  no: 6,
  name: "preset",
  kind: "enum",
  T: proto3.getEnumType(EncodingOptionsPreset),
  oneof: "options"
}, {
  no: 7,
  name: "advanced",
  kind: "message",
  T: EncodingOptions,
  oneof: "options"
}, {
  no: 11,
  name: "file_outputs",
  kind: "message",
  T: EncodedFileOutput,
  repeated: !0
}, {
  no: 12,
  name: "stream_outputs",
  kind: "message",
  T: StreamOutput,
  repeated: !0
}, {
  no: 13,
  name: "segment_outputs",
  kind: "message",
  T: SegmentedFileOutput,
  repeated: !0
}, {
  no: 14,
  name: "image_outputs",
  kind: "message",
  T: ImageOutput,
  repeated: !0
}]), TrackEgressRequest = proto3.makeMessageType("livekit.TrackEgressRequest", () => [{
  no: 1,
  name: "room_name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "track_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "file",
  kind: "message",
  T: DirectFileOutput,
  oneof: "output"
}, {
  no: 4,
  name: "websocket_url",
  kind: "scalar",
  T: 9,
  oneof: "output"
}]), EncodedFileOutput = proto3.makeMessageType("livekit.EncodedFileOutput", () => [{
  no: 1,
  name: "file_type",
  kind: "enum",
  T: proto3.getEnumType(EncodedFileType)
}, {
  no: 2,
  name: "filepath",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 6,
  name: "disable_manifest",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 3,
  name: "s3",
  kind: "message",
  T: S3Upload,
  oneof: "output"
}, {
  no: 4,
  name: "gcp",
  kind: "message",
  T: GCPUpload,
  oneof: "output"
}, {
  no: 5,
  name: "azure",
  kind: "message",
  T: AzureBlobUpload,
  oneof: "output"
}, {
  no: 7,
  name: "aliOSS",
  kind: "message",
  T: AliOSSUpload,
  oneof: "output"
}]), SegmentedFileOutput = proto3.makeMessageType("livekit.SegmentedFileOutput", () => [{
  no: 1,
  name: "protocol",
  kind: "enum",
  T: proto3.getEnumType(SegmentedFileProtocol)
}, {
  no: 2,
  name: "filename_prefix",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "playlist_name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 11,
  name: "live_playlist_name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 4,
  name: "segment_duration",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 10,
  name: "filename_suffix",
  kind: "enum",
  T: proto3.getEnumType(SegmentedFileSuffix)
}, {
  no: 8,
  name: "disable_manifest",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 5,
  name: "s3",
  kind: "message",
  T: S3Upload,
  oneof: "output"
}, {
  no: 6,
  name: "gcp",
  kind: "message",
  T: GCPUpload,
  oneof: "output"
}, {
  no: 7,
  name: "azure",
  kind: "message",
  T: AzureBlobUpload,
  oneof: "output"
}, {
  no: 9,
  name: "aliOSS",
  kind: "message",
  T: AliOSSUpload,
  oneof: "output"
}]), DirectFileOutput = proto3.makeMessageType("livekit.DirectFileOutput", () => [{
  no: 1,
  name: "filepath",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "disable_manifest",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 2,
  name: "s3",
  kind: "message",
  T: S3Upload,
  oneof: "output"
}, {
  no: 3,
  name: "gcp",
  kind: "message",
  T: GCPUpload,
  oneof: "output"
}, {
  no: 4,
  name: "azure",
  kind: "message",
  T: AzureBlobUpload,
  oneof: "output"
}, {
  no: 6,
  name: "aliOSS",
  kind: "message",
  T: AliOSSUpload,
  oneof: "output"
}]), ImageOutput = proto3.makeMessageType("livekit.ImageOutput", () => [{
  no: 1,
  name: "capture_interval",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 2,
  name: "width",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}, {
  no: 3,
  name: "height",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}, {
  no: 4,
  name: "filename_prefix",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "filename_suffix",
  kind: "enum",
  T: proto3.getEnumType(ImageFileSuffix)
}, {
  no: 6,
  name: "image_codec",
  kind: "enum",
  T: proto3.getEnumType(ImageCodec)
}, {
  no: 7,
  name: "disable_manifest",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 8,
  name: "s3",
  kind: "message",
  T: S3Upload,
  oneof: "output"
}, {
  no: 9,
  name: "gcp",
  kind: "message",
  T: GCPUpload,
  oneof: "output"
}, {
  no: 10,
  name: "azure",
  kind: "message",
  T: AzureBlobUpload,
  oneof: "output"
}, {
  no: 11,
  name: "aliOSS",
  kind: "message",
  T: AliOSSUpload,
  oneof: "output"
}]), S3Upload = proto3.makeMessageType("livekit.S3Upload", () => [{
  no: 1,
  name: "access_key",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "secret",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "region",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 4,
  name: "endpoint",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "bucket",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 6,
  name: "force_path_style",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 7,
  name: "metadata",
  kind: "map",
  K: 9,
  V: {
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
}, {
  no: 8,
  name: "tagging",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 9,
  name: "content_disposition",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), GCPUpload = proto3.makeMessageType("livekit.GCPUpload", () => [{
  no: 1,
  name: "credentials",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "bucket",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "endpoint",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), AzureBlobUpload = proto3.makeMessageType("livekit.AzureBlobUpload", () => [{
  no: 1,
  name: "account_name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "account_key",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "container_name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), AliOSSUpload = proto3.makeMessageType("livekit.AliOSSUpload", () => [{
  no: 1,
  name: "access_key",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "secret",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "region",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 4,
  name: "endpoint",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "bucket",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), StreamOutput = proto3.makeMessageType("livekit.StreamOutput", () => [{
  no: 1,
  name: "protocol",
  kind: "enum",
  T: proto3.getEnumType(StreamProtocol)
}, {
  no: 2,
  name: "urls",
  kind: "scalar",
  T: 9,
  repeated: !0
}]), EncodingOptions = proto3.makeMessageType("livekit.EncodingOptions", () => [{
  no: 1,
  name: "width",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}, {
  no: 2,
  name: "height",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}, {
  no: 3,
  name: "depth",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}, {
  no: 4,
  name: "framerate",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}, {
  no: 5,
  name: "audio_codec",
  kind: "enum",
  T: proto3.getEnumType(AudioCodec$1)
}, {
  no: 6,
  name: "audio_bitrate",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}, {
  no: 11,
  name: "audio_quality",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}, {
  no: 7,
  name: "audio_frequency",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}, {
  no: 8,
  name: "video_codec",
  kind: "enum",
  T: proto3.getEnumType(VideoCodec$1)
}, {
  no: 9,
  name: "video_bitrate",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}, {
  no: 12,
  name: "video_quality",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}, {
  no: 10,
  name: "key_frame_interval",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}]);
proto3.makeMessageType("livekit.UpdateLayoutRequest", () => [{
  no: 1,
  name: "egress_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "layout",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
proto3.makeMessageType("livekit.UpdateStreamRequest", () => [{
  no: 1,
  name: "egress_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "add_output_urls",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 3,
  name: "remove_output_urls",
  kind: "scalar",
  T: 9,
  repeated: !0
}]);
proto3.makeMessageType("livekit.ListEgressRequest", () => [{
  no: 1,
  name: "room_name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "egress_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "active",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}]);
proto3.makeMessageType("livekit.ListEgressResponse", () => [{
  no: 1,
  name: "items",
  kind: "message",
  T: EgressInfo,
  repeated: !0
}]);
proto3.makeMessageType("livekit.StopEgressRequest", () => [{
  no: 1,
  name: "egress_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
const EgressInfo = proto3.makeMessageType("livekit.EgressInfo", () => [{
  no: 1,
  name: "egress_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "room_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 13,
  name: "room_name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "status",
  kind: "enum",
  T: proto3.getEnumType(EgressStatus)
}, {
  no: 10,
  name: "started_at",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 11,
  name: "ended_at",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 18,
  name: "updated_at",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 21,
  name: "details",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 9,
  name: "error",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 4,
  name: "room_composite",
  kind: "message",
  T: RoomCompositeEgressRequest,
  oneof: "request"
}, {
  no: 14,
  name: "web",
  kind: "message",
  T: WebEgressRequest,
  oneof: "request"
}, {
  no: 19,
  name: "participant",
  kind: "message",
  T: ParticipantEgressRequest,
  oneof: "request"
}, {
  no: 5,
  name: "track_composite",
  kind: "message",
  T: TrackCompositeEgressRequest,
  oneof: "request"
}, {
  no: 6,
  name: "track",
  kind: "message",
  T: TrackEgressRequest,
  oneof: "request"
}, {
  no: 7,
  name: "stream",
  kind: "message",
  T: StreamInfoList,
  oneof: "result"
}, {
  no: 8,
  name: "file",
  kind: "message",
  T: FileInfo,
  oneof: "result"
}, {
  no: 12,
  name: "segments",
  kind: "message",
  T: SegmentsInfo,
  oneof: "result"
}, {
  no: 15,
  name: "stream_results",
  kind: "message",
  T: StreamInfo,
  repeated: !0
}, {
  no: 16,
  name: "file_results",
  kind: "message",
  T: FileInfo,
  repeated: !0
}, {
  no: 17,
  name: "segment_results",
  kind: "message",
  T: SegmentsInfo,
  repeated: !0
}, {
  no: 20,
  name: "image_results",
  kind: "message",
  T: ImagesInfo,
  repeated: !0
}]), StreamInfoList = proto3.makeMessageType("livekit.StreamInfoList", () => [{
  no: 1,
  name: "info",
  kind: "message",
  T: StreamInfo,
  repeated: !0
}]), StreamInfo = proto3.makeMessageType("livekit.StreamInfo", () => [{
  no: 1,
  name: "url",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "started_at",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 3,
  name: "ended_at",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 4,
  name: "duration",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 5,
  name: "status",
  kind: "enum",
  T: proto3.getEnumType(StreamInfo_Status)
}, {
  no: 6,
  name: "error",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), StreamInfo_Status = proto3.makeEnum("livekit.StreamInfo.Status", [{
  no: 0,
  name: "ACTIVE"
}, {
  no: 1,
  name: "FINISHED"
}, {
  no: 2,
  name: "FAILED"
}]), FileInfo = proto3.makeMessageType("livekit.FileInfo", () => [{
  no: 1,
  name: "filename",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "started_at",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 3,
  name: "ended_at",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 6,
  name: "duration",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 4,
  name: "size",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 5,
  name: "location",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), SegmentsInfo = proto3.makeMessageType("livekit.SegmentsInfo", () => [{
  no: 1,
  name: "playlist_name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 8,
  name: "live_playlist_name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "duration",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 3,
  name: "size",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 4,
  name: "playlist_location",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 9,
  name: "live_playlist_location",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "segment_count",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 6,
  name: "started_at",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 7,
  name: "ended_at",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}]), ImagesInfo = proto3.makeMessageType("livekit.ImagesInfo", () => [{
  no: 1,
  name: "image_count",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 2,
  name: "started_at",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 3,
  name: "ended_at",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}]), AutoParticipantEgress = proto3.makeMessageType("livekit.AutoParticipantEgress", () => [{
  no: 1,
  name: "preset",
  kind: "enum",
  T: proto3.getEnumType(EncodingOptionsPreset),
  oneof: "options"
}, {
  no: 2,
  name: "advanced",
  kind: "message",
  T: EncodingOptions,
  oneof: "options"
}, {
  no: 3,
  name: "file_outputs",
  kind: "message",
  T: EncodedFileOutput,
  repeated: !0
}, {
  no: 4,
  name: "segment_outputs",
  kind: "message",
  T: SegmentedFileOutput,
  repeated: !0
}]), AutoTrackEgress = proto3.makeMessageType("livekit.AutoTrackEgress", () => [{
  no: 1,
  name: "filepath",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "disable_manifest",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 2,
  name: "s3",
  kind: "message",
  T: S3Upload,
  oneof: "output"
}, {
  no: 3,
  name: "gcp",
  kind: "message",
  T: GCPUpload,
  oneof: "output"
}, {
  no: 4,
  name: "azure",
  kind: "message",
  T: AzureBlobUpload,
  oneof: "output"
}]);
proto3.makeMessageType("livekit.CreateRoomRequest", () => [{
  no: 1,
  name: "name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "empty_timeout",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 10,
  name: "departure_timeout",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 3,
  name: "max_participants",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 4,
  name: "node_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "metadata",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 6,
  name: "egress",
  kind: "message",
  T: RoomEgress
}, {
  no: 7,
  name: "min_playout_delay",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 8,
  name: "max_playout_delay",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 9,
  name: "sync_streams",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}]);
const RoomEgress = proto3.makeMessageType("livekit.RoomEgress", () => [{
  no: 1,
  name: "room",
  kind: "message",
  T: RoomCompositeEgressRequest
}, {
  no: 3,
  name: "participant",
  kind: "message",
  T: AutoParticipantEgress
}, {
  no: 2,
  name: "tracks",
  kind: "message",
  T: AutoTrackEgress
}]);
proto3.makeMessageType("livekit.ListRoomsRequest", () => [{
  no: 1,
  name: "names",
  kind: "scalar",
  T: 9,
  repeated: !0
}]);
proto3.makeMessageType("livekit.ListRoomsResponse", () => [{
  no: 1,
  name: "rooms",
  kind: "message",
  T: Room$1,
  repeated: !0
}]);
proto3.makeMessageType("livekit.DeleteRoomRequest", () => [{
  no: 1,
  name: "room",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
proto3.makeMessageType("livekit.DeleteRoomResponse", []);
proto3.makeMessageType("livekit.ListParticipantsRequest", () => [{
  no: 1,
  name: "room",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
proto3.makeMessageType("livekit.ListParticipantsResponse", () => [{
  no: 1,
  name: "participants",
  kind: "message",
  T: ParticipantInfo,
  repeated: !0
}]);
proto3.makeMessageType("livekit.RoomParticipantIdentity", () => [{
  no: 1,
  name: "room",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "identity",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
proto3.makeMessageType("livekit.RemoveParticipantResponse", []);
proto3.makeMessageType("livekit.MuteRoomTrackRequest", () => [{
  no: 1,
  name: "room",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "identity",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "track_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 4,
  name: "muted",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}]);
proto3.makeMessageType("livekit.MuteRoomTrackResponse", () => [{
  no: 1,
  name: "track",
  kind: "message",
  T: TrackInfo
}]);
proto3.makeMessageType("livekit.UpdateParticipantRequest", () => [{
  no: 1,
  name: "room",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "identity",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "metadata",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 4,
  name: "permission",
  kind: "message",
  T: ParticipantPermission
}, {
  no: 5,
  name: "name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
proto3.makeMessageType("livekit.UpdateSubscriptionsRequest", () => [{
  no: 1,
  name: "room",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "identity",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "track_sids",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 4,
  name: "subscribe",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 5,
  name: "participant_tracks",
  kind: "message",
  T: ParticipantTracks,
  repeated: !0
}]);
proto3.makeMessageType("livekit.UpdateSubscriptionsResponse", []);
proto3.makeMessageType("livekit.SendDataRequest", () => [{
  no: 1,
  name: "room",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "data",
  kind: "scalar",
  T: 12
  /* ScalarType.BYTES */
}, {
  no: 3,
  name: "kind",
  kind: "enum",
  T: proto3.getEnumType(DataPacket_Kind)
}, {
  no: 4,
  name: "destination_sids",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 6,
  name: "destination_identities",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 5,
  name: "topic",
  kind: "scalar",
  T: 9,
  opt: !0
}]);
proto3.makeMessageType("livekit.SendDataResponse", []);
proto3.makeMessageType("livekit.UpdateRoomMetadataRequest", () => [{
  no: 1,
  name: "room",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "metadata",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
const JobType = proto3.makeEnum("livekit.JobType", [{
  no: 0,
  name: "JT_ROOM"
}, {
  no: 1,
  name: "JT_PUBLISHER"
}]), WorkerStatus = proto3.makeEnum("livekit.WorkerStatus", [{
  no: 0,
  name: "WS_AVAILABLE"
}, {
  no: 1,
  name: "WS_FULL"
}]), JobStatus = proto3.makeEnum("livekit.JobStatus", [{
  no: 0,
  name: "JS_UNKNOWN"
}, {
  no: 1,
  name: "JS_SUCCESS"
}, {
  no: 2,
  name: "JS_FAILED"
}]);
proto3.makeMessageType("livekit.AgentInfo", () => [{
  no: 1,
  name: "id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "version",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
const Job = proto3.makeMessageType("livekit.Job", () => [{
  no: 1,
  name: "id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "type",
  kind: "enum",
  T: proto3.getEnumType(JobType)
}, {
  no: 3,
  name: "room",
  kind: "message",
  T: Room$1
}, {
  no: 4,
  name: "participant",
  kind: "message",
  T: ParticipantInfo,
  opt: !0
}]);
proto3.makeMessageType("livekit.WorkerMessage", () => [{
  no: 1,
  name: "register",
  kind: "message",
  T: RegisterWorkerRequest,
  oneof: "message"
}, {
  no: 2,
  name: "availability",
  kind: "message",
  T: AvailabilityResponse,
  oneof: "message"
}, {
  no: 3,
  name: "status",
  kind: "message",
  T: UpdateWorkerStatus,
  oneof: "message"
}, {
  no: 4,
  name: "job_update",
  kind: "message",
  T: JobStatusUpdate,
  oneof: "message"
}]);
proto3.makeMessageType("livekit.ServerMessage", () => [{
  no: 1,
  name: "register",
  kind: "message",
  T: RegisterWorkerResponse,
  oneof: "message"
}, {
  no: 2,
  name: "availability",
  kind: "message",
  T: AvailabilityRequest,
  oneof: "message"
}, {
  no: 3,
  name: "assignment",
  kind: "message",
  T: JobAssignment,
  oneof: "message"
}]);
const RegisterWorkerRequest = proto3.makeMessageType("livekit.RegisterWorkerRequest", () => [{
  no: 1,
  name: "type",
  kind: "enum",
  T: proto3.getEnumType(JobType)
}, {
  no: 2,
  name: "worker_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "version",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 4,
  name: "name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), RegisterWorkerResponse = proto3.makeMessageType("livekit.RegisterWorkerResponse", () => [{
  no: 1,
  name: "worker_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "server_version",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), AvailabilityRequest = proto3.makeMessageType("livekit.AvailabilityRequest", () => [{
  no: 1,
  name: "job",
  kind: "message",
  T: Job
}]), AvailabilityResponse = proto3.makeMessageType("livekit.AvailabilityResponse", () => [{
  no: 1,
  name: "job_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "available",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}]), JobStatusUpdate = proto3.makeMessageType("livekit.JobStatusUpdate", () => [{
  no: 1,
  name: "job_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "status",
  kind: "enum",
  T: proto3.getEnumType(JobStatus)
}, {
  no: 3,
  name: "error",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 4,
  name: "user_data",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), JobAssignment = proto3.makeMessageType("livekit.JobAssignment", () => [{
  no: 1,
  name: "job",
  kind: "message",
  T: Job
}]), UpdateWorkerStatus = proto3.makeMessageType("livekit.UpdateWorkerStatus", () => [{
  no: 1,
  name: "status",
  kind: "enum",
  T: proto3.getEnumType(WorkerStatus)
}]), SignalTarget = proto3.makeEnum("livekit.SignalTarget", [{
  no: 0,
  name: "PUBLISHER"
}, {
  no: 1,
  name: "SUBSCRIBER"
}]), StreamState = proto3.makeEnum("livekit.StreamState", [{
  no: 0,
  name: "ACTIVE"
}, {
  no: 1,
  name: "PAUSED"
}]), CandidateProtocol = proto3.makeEnum("livekit.CandidateProtocol", [{
  no: 0,
  name: "UDP"
}, {
  no: 1,
  name: "TCP"
}, {
  no: 2,
  name: "TLS"
}]), SignalRequest = proto3.makeMessageType("livekit.SignalRequest", () => [{
  no: 1,
  name: "offer",
  kind: "message",
  T: SessionDescription,
  oneof: "message"
}, {
  no: 2,
  name: "answer",
  kind: "message",
  T: SessionDescription,
  oneof: "message"
}, {
  no: 3,
  name: "trickle",
  kind: "message",
  T: TrickleRequest,
  oneof: "message"
}, {
  no: 4,
  name: "add_track",
  kind: "message",
  T: AddTrackRequest,
  oneof: "message"
}, {
  no: 5,
  name: "mute",
  kind: "message",
  T: MuteTrackRequest,
  oneof: "message"
}, {
  no: 6,
  name: "subscription",
  kind: "message",
  T: UpdateSubscription,
  oneof: "message"
}, {
  no: 7,
  name: "track_setting",
  kind: "message",
  T: UpdateTrackSettings,
  oneof: "message"
}, {
  no: 8,
  name: "leave",
  kind: "message",
  T: LeaveRequest,
  oneof: "message"
}, {
  no: 10,
  name: "update_layers",
  kind: "message",
  T: UpdateVideoLayers,
  oneof: "message"
}, {
  no: 11,
  name: "subscription_permission",
  kind: "message",
  T: SubscriptionPermission,
  oneof: "message"
}, {
  no: 12,
  name: "sync_state",
  kind: "message",
  T: SyncState,
  oneof: "message"
}, {
  no: 13,
  name: "simulate",
  kind: "message",
  T: SimulateScenario,
  oneof: "message"
}, {
  no: 14,
  name: "ping",
  kind: "scalar",
  T: 3,
  oneof: "message"
}, {
  no: 15,
  name: "update_metadata",
  kind: "message",
  T: UpdateParticipantMetadata,
  oneof: "message"
}, {
  no: 16,
  name: "ping_req",
  kind: "message",
  T: Ping,
  oneof: "message"
}]), SignalResponse = proto3.makeMessageType("livekit.SignalResponse", () => [{
  no: 1,
  name: "join",
  kind: "message",
  T: JoinResponse,
  oneof: "message"
}, {
  no: 2,
  name: "answer",
  kind: "message",
  T: SessionDescription,
  oneof: "message"
}, {
  no: 3,
  name: "offer",
  kind: "message",
  T: SessionDescription,
  oneof: "message"
}, {
  no: 4,
  name: "trickle",
  kind: "message",
  T: TrickleRequest,
  oneof: "message"
}, {
  no: 5,
  name: "update",
  kind: "message",
  T: ParticipantUpdate,
  oneof: "message"
}, {
  no: 6,
  name: "track_published",
  kind: "message",
  T: TrackPublishedResponse,
  oneof: "message"
}, {
  no: 8,
  name: "leave",
  kind: "message",
  T: LeaveRequest,
  oneof: "message"
}, {
  no: 9,
  name: "mute",
  kind: "message",
  T: MuteTrackRequest,
  oneof: "message"
}, {
  no: 10,
  name: "speakers_changed",
  kind: "message",
  T: SpeakersChanged,
  oneof: "message"
}, {
  no: 11,
  name: "room_update",
  kind: "message",
  T: RoomUpdate,
  oneof: "message"
}, {
  no: 12,
  name: "connection_quality",
  kind: "message",
  T: ConnectionQualityUpdate,
  oneof: "message"
}, {
  no: 13,
  name: "stream_state_update",
  kind: "message",
  T: StreamStateUpdate,
  oneof: "message"
}, {
  no: 14,
  name: "subscribed_quality_update",
  kind: "message",
  T: SubscribedQualityUpdate,
  oneof: "message"
}, {
  no: 15,
  name: "subscription_permission_update",
  kind: "message",
  T: SubscriptionPermissionUpdate,
  oneof: "message"
}, {
  no: 16,
  name: "refresh_token",
  kind: "scalar",
  T: 9,
  oneof: "message"
}, {
  no: 17,
  name: "track_unpublished",
  kind: "message",
  T: TrackUnpublishedResponse,
  oneof: "message"
}, {
  no: 18,
  name: "pong",
  kind: "scalar",
  T: 3,
  oneof: "message"
}, {
  no: 19,
  name: "reconnect",
  kind: "message",
  T: ReconnectResponse,
  oneof: "message"
}, {
  no: 20,
  name: "pong_resp",
  kind: "message",
  T: Pong,
  oneof: "message"
}, {
  no: 21,
  name: "subscription_response",
  kind: "message",
  T: SubscriptionResponse,
  oneof: "message"
}]), SimulcastCodec = proto3.makeMessageType("livekit.SimulcastCodec", () => [{
  no: 1,
  name: "codec",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "cid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), AddTrackRequest = proto3.makeMessageType("livekit.AddTrackRequest", () => [{
  no: 1,
  name: "cid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "type",
  kind: "enum",
  T: proto3.getEnumType(TrackType)
}, {
  no: 4,
  name: "width",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 5,
  name: "height",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 6,
  name: "muted",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 7,
  name: "disable_dtx",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 8,
  name: "source",
  kind: "enum",
  T: proto3.getEnumType(TrackSource)
}, {
  no: 9,
  name: "layers",
  kind: "message",
  T: VideoLayer,
  repeated: !0
}, {
  no: 10,
  name: "simulcast_codecs",
  kind: "message",
  T: SimulcastCodec,
  repeated: !0
}, {
  no: 11,
  name: "sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 12,
  name: "stereo",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 13,
  name: "disable_red",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 14,
  name: "encryption",
  kind: "enum",
  T: proto3.getEnumType(Encryption_Type)
}, {
  no: 15,
  name: "stream",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), TrickleRequest = proto3.makeMessageType("livekit.TrickleRequest", () => [{
  no: 1,
  name: "candidateInit",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "target",
  kind: "enum",
  T: proto3.getEnumType(SignalTarget)
}]), MuteTrackRequest = proto3.makeMessageType("livekit.MuteTrackRequest", () => [{
  no: 1,
  name: "sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "muted",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}]), JoinResponse = proto3.makeMessageType("livekit.JoinResponse", () => [{
  no: 1,
  name: "room",
  kind: "message",
  T: Room$1
}, {
  no: 2,
  name: "participant",
  kind: "message",
  T: ParticipantInfo
}, {
  no: 3,
  name: "other_participants",
  kind: "message",
  T: ParticipantInfo,
  repeated: !0
}, {
  no: 4,
  name: "server_version",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "ice_servers",
  kind: "message",
  T: ICEServer,
  repeated: !0
}, {
  no: 6,
  name: "subscriber_primary",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 7,
  name: "alternative_url",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 8,
  name: "client_configuration",
  kind: "message",
  T: ClientConfiguration
}, {
  no: 9,
  name: "server_region",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 10,
  name: "ping_timeout",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}, {
  no: 11,
  name: "ping_interval",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}, {
  no: 12,
  name: "server_info",
  kind: "message",
  T: ServerInfo
}, {
  no: 13,
  name: "sif_trailer",
  kind: "scalar",
  T: 12
  /* ScalarType.BYTES */
}]), ReconnectResponse = proto3.makeMessageType("livekit.ReconnectResponse", () => [{
  no: 1,
  name: "ice_servers",
  kind: "message",
  T: ICEServer,
  repeated: !0
}, {
  no: 2,
  name: "client_configuration",
  kind: "message",
  T: ClientConfiguration
}]), TrackPublishedResponse = proto3.makeMessageType("livekit.TrackPublishedResponse", () => [{
  no: 1,
  name: "cid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "track",
  kind: "message",
  T: TrackInfo
}]), TrackUnpublishedResponse = proto3.makeMessageType("livekit.TrackUnpublishedResponse", () => [{
  no: 1,
  name: "track_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), SessionDescription = proto3.makeMessageType("livekit.SessionDescription", () => [{
  no: 1,
  name: "type",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "sdp",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), ParticipantUpdate = proto3.makeMessageType("livekit.ParticipantUpdate", () => [{
  no: 1,
  name: "participants",
  kind: "message",
  T: ParticipantInfo,
  repeated: !0
}]), UpdateSubscription = proto3.makeMessageType("livekit.UpdateSubscription", () => [{
  no: 1,
  name: "track_sids",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 2,
  name: "subscribe",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 3,
  name: "participant_tracks",
  kind: "message",
  T: ParticipantTracks,
  repeated: !0
}]), UpdateTrackSettings = proto3.makeMessageType("livekit.UpdateTrackSettings", () => [{
  no: 1,
  name: "track_sids",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 3,
  name: "disabled",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 4,
  name: "quality",
  kind: "enum",
  T: proto3.getEnumType(VideoQuality$1)
}, {
  no: 5,
  name: "width",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 6,
  name: "height",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 7,
  name: "fps",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 8,
  name: "priority",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}]), LeaveRequest = proto3.makeMessageType("livekit.LeaveRequest", () => [{
  no: 1,
  name: "can_reconnect",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 2,
  name: "reason",
  kind: "enum",
  T: proto3.getEnumType(DisconnectReason)
}, {
  no: 3,
  name: "action",
  kind: "enum",
  T: proto3.getEnumType(LeaveRequest_Action)
}, {
  no: 4,
  name: "regions",
  kind: "message",
  T: RegionSettings
}]), LeaveRequest_Action = proto3.makeEnum("livekit.LeaveRequest.Action", [{
  no: 0,
  name: "DISCONNECT"
}, {
  no: 1,
  name: "RESUME"
}, {
  no: 2,
  name: "RECONNECT"
}]), UpdateVideoLayers = proto3.makeMessageType("livekit.UpdateVideoLayers", () => [{
  no: 1,
  name: "track_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "layers",
  kind: "message",
  T: VideoLayer,
  repeated: !0
}]), UpdateParticipantMetadata = proto3.makeMessageType("livekit.UpdateParticipantMetadata", () => [{
  no: 1,
  name: "metadata",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), ICEServer = proto3.makeMessageType("livekit.ICEServer", () => [{
  no: 1,
  name: "urls",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 2,
  name: "username",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "credential",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), SpeakersChanged = proto3.makeMessageType("livekit.SpeakersChanged", () => [{
  no: 1,
  name: "speakers",
  kind: "message",
  T: SpeakerInfo,
  repeated: !0
}]), RoomUpdate = proto3.makeMessageType("livekit.RoomUpdate", () => [{
  no: 1,
  name: "room",
  kind: "message",
  T: Room$1
}]), ConnectionQualityInfo = proto3.makeMessageType("livekit.ConnectionQualityInfo", () => [{
  no: 1,
  name: "participant_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "quality",
  kind: "enum",
  T: proto3.getEnumType(ConnectionQuality$1)
}, {
  no: 3,
  name: "score",
  kind: "scalar",
  T: 2
  /* ScalarType.FLOAT */
}]), ConnectionQualityUpdate = proto3.makeMessageType("livekit.ConnectionQualityUpdate", () => [{
  no: 1,
  name: "updates",
  kind: "message",
  T: ConnectionQualityInfo,
  repeated: !0
}]), StreamStateInfo = proto3.makeMessageType("livekit.StreamStateInfo", () => [{
  no: 1,
  name: "participant_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "track_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "state",
  kind: "enum",
  T: proto3.getEnumType(StreamState)
}]), StreamStateUpdate = proto3.makeMessageType("livekit.StreamStateUpdate", () => [{
  no: 1,
  name: "stream_states",
  kind: "message",
  T: StreamStateInfo,
  repeated: !0
}]), SubscribedQuality = proto3.makeMessageType("livekit.SubscribedQuality", () => [{
  no: 1,
  name: "quality",
  kind: "enum",
  T: proto3.getEnumType(VideoQuality$1)
}, {
  no: 2,
  name: "enabled",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}]), SubscribedCodec = proto3.makeMessageType("livekit.SubscribedCodec", () => [{
  no: 1,
  name: "codec",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "qualities",
  kind: "message",
  T: SubscribedQuality,
  repeated: !0
}]), SubscribedQualityUpdate = proto3.makeMessageType("livekit.SubscribedQualityUpdate", () => [{
  no: 1,
  name: "track_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "subscribed_qualities",
  kind: "message",
  T: SubscribedQuality,
  repeated: !0
}, {
  no: 3,
  name: "subscribed_codecs",
  kind: "message",
  T: SubscribedCodec,
  repeated: !0
}]), TrackPermission = proto3.makeMessageType("livekit.TrackPermission", () => [{
  no: 1,
  name: "participant_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "all_tracks",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 3,
  name: "track_sids",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 4,
  name: "participant_identity",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), SubscriptionPermission = proto3.makeMessageType("livekit.SubscriptionPermission", () => [{
  no: 1,
  name: "all_participants",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 2,
  name: "track_permissions",
  kind: "message",
  T: TrackPermission,
  repeated: !0
}]), SubscriptionPermissionUpdate = proto3.makeMessageType("livekit.SubscriptionPermissionUpdate", () => [{
  no: 1,
  name: "participant_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "track_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "allowed",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}]), SyncState = proto3.makeMessageType("livekit.SyncState", () => [{
  no: 1,
  name: "answer",
  kind: "message",
  T: SessionDescription
}, {
  no: 2,
  name: "subscription",
  kind: "message",
  T: UpdateSubscription
}, {
  no: 3,
  name: "publish_tracks",
  kind: "message",
  T: TrackPublishedResponse,
  repeated: !0
}, {
  no: 4,
  name: "data_channels",
  kind: "message",
  T: DataChannelInfo,
  repeated: !0
}, {
  no: 5,
  name: "offer",
  kind: "message",
  T: SessionDescription
}, {
  no: 6,
  name: "track_sids_disabled",
  kind: "scalar",
  T: 9,
  repeated: !0
}]), DataChannelInfo = proto3.makeMessageType("livekit.DataChannelInfo", () => [{
  no: 1,
  name: "label",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "id",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 3,
  name: "target",
  kind: "enum",
  T: proto3.getEnumType(SignalTarget)
}]), SimulateScenario = proto3.makeMessageType("livekit.SimulateScenario", () => [{
  no: 1,
  name: "speaker_update",
  kind: "scalar",
  T: 5,
  oneof: "scenario"
}, {
  no: 2,
  name: "node_failure",
  kind: "scalar",
  T: 8,
  oneof: "scenario"
}, {
  no: 3,
  name: "migration",
  kind: "scalar",
  T: 8,
  oneof: "scenario"
}, {
  no: 4,
  name: "server_leave",
  kind: "scalar",
  T: 8,
  oneof: "scenario"
}, {
  no: 5,
  name: "switch_candidate_protocol",
  kind: "enum",
  T: proto3.getEnumType(CandidateProtocol),
  oneof: "scenario"
}, {
  no: 6,
  name: "subscriber_bandwidth",
  kind: "scalar",
  T: 3,
  oneof: "scenario"
}, {
  no: 7,
  name: "disconnect_signal_on_resume",
  kind: "scalar",
  T: 8,
  oneof: "scenario"
}, {
  no: 8,
  name: "disconnect_signal_on_resume_no_messages",
  kind: "scalar",
  T: 8,
  oneof: "scenario"
}]), Ping = proto3.makeMessageType("livekit.Ping", () => [{
  no: 1,
  name: "timestamp",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 2,
  name: "rtt",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}]), Pong = proto3.makeMessageType("livekit.Pong", () => [{
  no: 1,
  name: "last_ping_timestamp",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 2,
  name: "timestamp",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}]), RegionSettings = proto3.makeMessageType("livekit.RegionSettings", () => [{
  no: 1,
  name: "regions",
  kind: "message",
  T: RegionInfo,
  repeated: !0
}]), RegionInfo = proto3.makeMessageType("livekit.RegionInfo", () => [{
  no: 1,
  name: "region",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "url",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "distance",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}]), SubscriptionResponse = proto3.makeMessageType("livekit.SubscriptionResponse", () => [{
  no: 1,
  name: "track_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "err",
  kind: "enum",
  T: proto3.getEnumType(SubscriptionError)
}]), IngressInput = proto3.makeEnum("livekit.IngressInput", [{
  no: 0,
  name: "RTMP_INPUT"
}, {
  no: 1,
  name: "WHIP_INPUT"
}, {
  no: 2,
  name: "URL_INPUT"
}]), IngressAudioEncodingPreset = proto3.makeEnum("livekit.IngressAudioEncodingPreset", [{
  no: 0,
  name: "OPUS_STEREO_96KBPS"
}, {
  no: 1,
  name: "OPUS_MONO_64KBS"
}]), IngressVideoEncodingPreset = proto3.makeEnum("livekit.IngressVideoEncodingPreset", [{
  no: 0,
  name: "H264_720P_30FPS_3_LAYERS"
}, {
  no: 1,
  name: "H264_1080P_30FPS_3_LAYERS"
}, {
  no: 2,
  name: "H264_540P_25FPS_2_LAYERS"
}, {
  no: 3,
  name: "H264_720P_30FPS_1_LAYER"
}, {
  no: 4,
  name: "H264_1080P_30FPS_1_LAYER"
}, {
  no: 5,
  name: "H264_720P_30FPS_3_LAYERS_HIGH_MOTION"
}, {
  no: 6,
  name: "H264_1080P_30FPS_3_LAYERS_HIGH_MOTION"
}, {
  no: 7,
  name: "H264_540P_25FPS_2_LAYERS_HIGH_MOTION"
}, {
  no: 8,
  name: "H264_720P_30FPS_1_LAYER_HIGH_MOTION"
}, {
  no: 9,
  name: "H264_1080P_30FPS_1_LAYER_HIGH_MOTION"
}]);
proto3.makeMessageType("livekit.CreateIngressRequest", () => [{
  no: 1,
  name: "input_type",
  kind: "enum",
  T: proto3.getEnumType(IngressInput)
}, {
  no: 9,
  name: "url",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "room_name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 4,
  name: "participant_identity",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "participant_name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 10,
  name: "participant_metadata",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 8,
  name: "bypass_transcoding",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 6,
  name: "audio",
  kind: "message",
  T: IngressAudioOptions
}, {
  no: 7,
  name: "video",
  kind: "message",
  T: IngressVideoOptions
}]);
const IngressAudioOptions = proto3.makeMessageType("livekit.IngressAudioOptions", () => [{
  no: 1,
  name: "name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "source",
  kind: "enum",
  T: proto3.getEnumType(TrackSource)
}, {
  no: 3,
  name: "preset",
  kind: "enum",
  T: proto3.getEnumType(IngressAudioEncodingPreset),
  oneof: "encoding_options"
}, {
  no: 4,
  name: "options",
  kind: "message",
  T: IngressAudioEncodingOptions,
  oneof: "encoding_options"
}]), IngressVideoOptions = proto3.makeMessageType("livekit.IngressVideoOptions", () => [{
  no: 1,
  name: "name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "source",
  kind: "enum",
  T: proto3.getEnumType(TrackSource)
}, {
  no: 3,
  name: "preset",
  kind: "enum",
  T: proto3.getEnumType(IngressVideoEncodingPreset),
  oneof: "encoding_options"
}, {
  no: 4,
  name: "options",
  kind: "message",
  T: IngressVideoEncodingOptions,
  oneof: "encoding_options"
}]), IngressAudioEncodingOptions = proto3.makeMessageType("livekit.IngressAudioEncodingOptions", () => [{
  no: 1,
  name: "audio_codec",
  kind: "enum",
  T: proto3.getEnumType(AudioCodec$1)
}, {
  no: 2,
  name: "bitrate",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 3,
  name: "disable_dtx",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 4,
  name: "channels",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}]), IngressVideoEncodingOptions = proto3.makeMessageType("livekit.IngressVideoEncodingOptions", () => [{
  no: 1,
  name: "video_codec",
  kind: "enum",
  T: proto3.getEnumType(VideoCodec$1)
}, {
  no: 2,
  name: "frame_rate",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}, {
  no: 3,
  name: "layers",
  kind: "message",
  T: VideoLayer,
  repeated: !0
}]), IngressInfo = proto3.makeMessageType("livekit.IngressInfo", () => [{
  no: 1,
  name: "ingress_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "stream_key",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 4,
  name: "url",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "input_type",
  kind: "enum",
  T: proto3.getEnumType(IngressInput)
}, {
  no: 13,
  name: "bypass_transcoding",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 6,
  name: "audio",
  kind: "message",
  T: IngressAudioOptions
}, {
  no: 7,
  name: "video",
  kind: "message",
  T: IngressVideoOptions
}, {
  no: 8,
  name: "room_name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 9,
  name: "participant_identity",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 10,
  name: "participant_name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 14,
  name: "participant_metadata",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 11,
  name: "reusable",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 12,
  name: "state",
  kind: "message",
  T: IngressState
}]), IngressState = proto3.makeMessageType("livekit.IngressState", () => [{
  no: 1,
  name: "status",
  kind: "enum",
  T: proto3.getEnumType(IngressState_Status)
}, {
  no: 2,
  name: "error",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "video",
  kind: "message",
  T: InputVideoState
}, {
  no: 4,
  name: "audio",
  kind: "message",
  T: InputAudioState
}, {
  no: 5,
  name: "room_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 7,
  name: "started_at",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 8,
  name: "ended_at",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 9,
  name: "resource_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 6,
  name: "tracks",
  kind: "message",
  T: TrackInfo,
  repeated: !0
}]), IngressState_Status = proto3.makeEnum("livekit.IngressState.Status", [{
  no: 0,
  name: "ENDPOINT_INACTIVE"
}, {
  no: 1,
  name: "ENDPOINT_BUFFERING"
}, {
  no: 2,
  name: "ENDPOINT_PUBLISHING"
}, {
  no: 3,
  name: "ENDPOINT_ERROR"
}, {
  no: 4,
  name: "ENDPOINT_COMPLETE"
}]), InputVideoState = proto3.makeMessageType("livekit.InputVideoState", () => [{
  no: 1,
  name: "mime_type",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "average_bitrate",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 3,
  name: "width",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 4,
  name: "height",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 5,
  name: "framerate",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}]), InputAudioState = proto3.makeMessageType("livekit.InputAudioState", () => [{
  no: 1,
  name: "mime_type",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "average_bitrate",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 3,
  name: "channels",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 4,
  name: "sample_rate",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}]);
proto3.makeMessageType("livekit.UpdateIngressRequest", () => [{
  no: 1,
  name: "ingress_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "room_name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 4,
  name: "participant_identity",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "participant_name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 9,
  name: "participant_metadata",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 8,
  name: "bypass_transcoding",
  kind: "scalar",
  T: 8,
  opt: !0
}, {
  no: 6,
  name: "audio",
  kind: "message",
  T: IngressAudioOptions
}, {
  no: 7,
  name: "video",
  kind: "message",
  T: IngressVideoOptions
}]);
proto3.makeMessageType("livekit.ListIngressRequest", () => [{
  no: 1,
  name: "room_name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "ingress_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
proto3.makeMessageType("livekit.ListIngressResponse", () => [{
  no: 1,
  name: "items",
  kind: "message",
  T: IngressInfo,
  repeated: !0
}]);
proto3.makeMessageType("livekit.DeleteIngressRequest", () => [{
  no: 1,
  name: "ingress_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
proto3.makeMessageType("livekit.WebhookEvent", () => [{
  no: 1,
  name: "event",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "room",
  kind: "message",
  T: Room$1
}, {
  no: 3,
  name: "participant",
  kind: "message",
  T: ParticipantInfo
}, {
  no: 9,
  name: "egress_info",
  kind: "message",
  T: EgressInfo
}, {
  no: 10,
  name: "ingress_info",
  kind: "message",
  T: IngressInfo
}, {
  no: 8,
  name: "track",
  kind: "message",
  T: TrackInfo
}, {
  no: 6,
  name: "id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 7,
  name: "created_at",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 11,
  name: "num_dropped",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}]);
proto3.makeMessageType("livekit.CreateSIPTrunkRequest", () => [{
  no: 1,
  name: "inbound_addresses",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 2,
  name: "outbound_address",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "outbound_number",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 4,
  name: "inbound_numbers_regex",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 9,
  name: "inbound_numbers",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 5,
  name: "inbound_username",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 6,
  name: "inbound_password",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 7,
  name: "outbound_username",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 8,
  name: "outbound_password",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
const SIPTrunkInfo = proto3.makeMessageType("livekit.SIPTrunkInfo", () => [{
  no: 1,
  name: "sip_trunk_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "inbound_addresses",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 3,
  name: "outbound_address",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 4,
  name: "outbound_number",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "inbound_numbers_regex",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 10,
  name: "inbound_numbers",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 6,
  name: "inbound_username",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 7,
  name: "inbound_password",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 8,
  name: "outbound_username",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 9,
  name: "outbound_password",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
proto3.makeMessageType("livekit.ListSIPTrunkRequest", []);
proto3.makeMessageType("livekit.ListSIPTrunkResponse", () => [{
  no: 1,
  name: "items",
  kind: "message",
  T: SIPTrunkInfo,
  repeated: !0
}]);
proto3.makeMessageType("livekit.DeleteSIPTrunkRequest", () => [{
  no: 1,
  name: "sip_trunk_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
const SIPDispatchRuleDirect = proto3.makeMessageType("livekit.SIPDispatchRuleDirect", () => [{
  no: 1,
  name: "room_name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "pin",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), SIPDispatchRuleIndividual = proto3.makeMessageType("livekit.SIPDispatchRuleIndividual", () => [{
  no: 1,
  name: "room_prefix",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "pin",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), SIPDispatchRule = proto3.makeMessageType("livekit.SIPDispatchRule", () => [{
  no: 1,
  name: "dispatch_rule_direct",
  kind: "message",
  T: SIPDispatchRuleDirect,
  oneof: "rule"
}, {
  no: 2,
  name: "dispatch_rule_individual",
  kind: "message",
  T: SIPDispatchRuleIndividual,
  oneof: "rule"
}]);
proto3.makeMessageType("livekit.CreateSIPDispatchRuleRequest", () => [{
  no: 1,
  name: "rule",
  kind: "message",
  T: SIPDispatchRule
}, {
  no: 2,
  name: "trunk_ids",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 3,
  name: "hide_phone_number",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}]);
const SIPDispatchRuleInfo = proto3.makeMessageType("livekit.SIPDispatchRuleInfo", () => [{
  no: 1,
  name: "sip_dispatch_rule_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "rule",
  kind: "message",
  T: SIPDispatchRule
}, {
  no: 3,
  name: "trunk_ids",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 4,
  name: "hide_phone_number",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}]);
proto3.makeMessageType("livekit.ListSIPDispatchRuleRequest", []);
proto3.makeMessageType("livekit.ListSIPDispatchRuleResponse", () => [{
  no: 1,
  name: "items",
  kind: "message",
  T: SIPDispatchRuleInfo,
  repeated: !0
}]);
proto3.makeMessageType("livekit.DeleteSIPDispatchRuleRequest", () => [{
  no: 1,
  name: "sip_dispatch_rule_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
proto3.makeMessageType("livekit.CreateSIPParticipantRequest", () => [{
  no: 1,
  name: "sip_trunk_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "sip_call_to",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "room_name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 4,
  name: "participant_identity",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
proto3.makeMessageType("livekit.SIPParticipantInfo", () => [{
  no: 1,
  name: "participant_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "participant_identity",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "room_name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global$1 < "u" ? global$1 : typeof self < "u" ? self : {};
function getDefaultExportFromCjs(a) {
  return a && a.__esModule && Object.prototype.hasOwnProperty.call(a, "default") ? a.default : a;
}
var loglevel$1 = { exports: {} };
(function(a) {
  (function(u, c) {
    a.exports ? a.exports = c() : u.log = c();
  })(commonjsGlobal, function() {
    var u = function() {
    }, c = "undefined", l = typeof window !== c && typeof window.navigator !== c && /Trident\/|MSIE /.test(window.navigator.userAgent), v = ["trace", "debug", "info", "warn", "error"];
    function p(ae, Q) {
      var ne = ae[Q];
      if (typeof ne.bind == "function")
        return ne.bind(ae);
      try {
        return Function.prototype.bind.call(ne, ae);
      } catch {
        return function() {
          return Function.prototype.apply.apply(ne, [ae, arguments]);
        };
      }
    }
    function _() {
      console.log && (console.log.apply ? console.log.apply(console, arguments) : Function.prototype.apply.apply(console.log, [console, arguments])), console.trace && console.trace();
    }
    function k(ae) {
      return ae === "debug" && (ae = "log"), typeof console === c ? !1 : ae === "trace" && l ? _ : console[ae] !== void 0 ? p(console, ae) : console.log !== void 0 ? p(console, "log") : u;
    }
    function O(ae, Q) {
      for (var ne = 0; ne < v.length; ne++) {
        var Z = v[ne];
        this[Z] = ne < ae ? u : this.methodFactory(Z, ae, Q);
      }
      this.log = this.debug;
    }
    function D(ae, Q, ne) {
      return function() {
        typeof console !== c && (O.call(this, Q, ne), this[ae].apply(this, arguments));
      };
    }
    function F(ae, Q, ne) {
      return k(ae) || D.apply(this, arguments);
    }
    function z(ae, Q, ne) {
      var Z = this, de;
      Q = Q ?? "WARN";
      var fe = "loglevel";
      typeof ae == "string" ? fe += ":" + ae : typeof ae == "symbol" && (fe = void 0);
      function Te(q) {
        var J = (v[q] || "silent").toUpperCase();
        if (!(typeof window === c || !fe)) {
          try {
            window.localStorage[fe] = J;
            return;
          } catch {
          }
          try {
            window.document.cookie = encodeURIComponent(fe) + "=" + J + ";";
          } catch {
          }
        }
      }
      function Re() {
        var q;
        if (!(typeof window === c || !fe)) {
          try {
            q = window.localStorage[fe];
          } catch {
          }
          if (typeof q === c)
            try {
              var J = window.document.cookie, C = J.indexOf(encodeURIComponent(fe) + "=");
              C !== -1 && (q = /^([^;]+)/.exec(J.slice(C))[1]);
            } catch {
            }
          return Z.levels[q] === void 0 && (q = void 0), q;
        }
      }
      function Le() {
        if (!(typeof window === c || !fe)) {
          try {
            window.localStorage.removeItem(fe);
            return;
          } catch {
          }
          try {
            window.document.cookie = encodeURIComponent(fe) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
          } catch {
          }
        }
      }
      Z.name = ae, Z.levels = {
        TRACE: 0,
        DEBUG: 1,
        INFO: 2,
        WARN: 3,
        ERROR: 4,
        SILENT: 5
      }, Z.methodFactory = ne || F, Z.getLevel = function() {
        return de;
      }, Z.setLevel = function(q, J) {
        if (typeof q == "string" && Z.levels[q.toUpperCase()] !== void 0 && (q = Z.levels[q.toUpperCase()]), typeof q == "number" && q >= 0 && q <= Z.levels.SILENT) {
          if (de = q, J !== !1 && Te(q), O.call(Z, q, ae), typeof console === c && q < Z.levels.SILENT)
            return "No console available for logging";
        } else
          throw "log.setLevel() called with invalid level: " + q;
      }, Z.setDefaultLevel = function(q) {
        Q = q, Re() || Z.setLevel(q, !1);
      }, Z.resetLevel = function() {
        Z.setLevel(Q, !1), Le();
      }, Z.enableAll = function(q) {
        Z.setLevel(Z.levels.TRACE, q);
      }, Z.disableAll = function(q) {
        Z.setLevel(Z.levels.SILENT, q);
      };
      var be = Re();
      be == null && (be = Q), Z.setLevel(be, !1);
    }
    var j = new z(), ee = {};
    j.getLogger = function(Q) {
      if (typeof Q != "symbol" && typeof Q != "string" || Q === "")
        throw new TypeError("You must supply a name when creating a logger.");
      var ne = ee[Q];
      return ne || (ne = ee[Q] = new z(Q, j.getLevel(), j.methodFactory)), ne;
    };
    var X = typeof window !== c ? window.log : void 0;
    return j.noConflict = function() {
      return typeof window !== c && window.log === j && (window.log = X), j;
    }, j.getLoggers = function() {
      return ee;
    }, j.default = j, j;
  });
})(loglevel$1);
var loglevelExports$1 = loglevel$1.exports, LogLevel;
(function(a) {
  a[a.trace = 0] = "trace", a[a.debug = 1] = "debug", a[a.info = 2] = "info", a[a.warn = 3] = "warn", a[a.error = 4] = "error", a[a.silent = 5] = "silent";
})(LogLevel || (LogLevel = {}));
var LoggerNames;
(function(a) {
  a.Default = "livekit", a.Room = "livekit-room", a.Participant = "livekit-participant", a.Track = "livekit-track", a.Publication = "livekit-track-publication", a.Engine = "livekit-engine", a.Signal = "livekit-signal", a.PCManager = "livekit-pc-manager", a.PCTransport = "livekit-pc-transport", a.E2EE = "lk-e2ee";
})(LoggerNames || (LoggerNames = {}));
let livekitLogger = loglevelExports$1.getLogger("livekit");
const livekitLoggers = Object.values(LoggerNames).map((a) => loglevelExports$1.getLogger(a));
livekitLogger.setDefaultLevel(LogLevel.info);
function getLogger(a) {
  const u = loglevelExports$1.getLogger(a);
  return u.setDefaultLevel(livekitLogger.getLevel()), u;
}
function setLogLevel(a, u) {
  u && loglevelExports$1.getLogger(u).setLevel(a);
  for (const c of livekitLoggers)
    c.setLevel(a);
}
const workerLogger = loglevelExports$1.getLogger("lk-e2ee"), maxRetryDelay = 7e3, DEFAULT_RETRY_DELAYS_IN_MS = [0, 300, 2 * 2 * 300, 3 * 3 * 300, 4 * 4 * 300, maxRetryDelay, maxRetryDelay, maxRetryDelay, maxRetryDelay, maxRetryDelay];
class DefaultReconnectPolicy {
  constructor(u) {
    this._retryDelays = u !== void 0 ? [...u] : DEFAULT_RETRY_DELAYS_IN_MS;
  }
  nextRetryDelayInMs(u) {
    if (u.retryCount >= this._retryDelays.length)
      return null;
    const c = this._retryDelays[u.retryCount];
    return u.retryCount <= 1 ? c : c + Math.random() * 1e3;
  }
}
function __awaiter$3(a, u, c, l) {
  function v(p) {
    return p instanceof c ? p : new c(function(_) {
      _(p);
    });
  }
  return new (c || (c = Promise))(function(p, _) {
    function k(F) {
      try {
        D(l.next(F));
      } catch (z) {
        _(z);
      }
    }
    function O(F) {
      try {
        D(l.throw(F));
      } catch (z) {
        _(z);
      }
    }
    function D(F) {
      F.done ? p(F.value) : v(F.value).then(k, O);
    }
    D((l = l.apply(a, u || [])).next());
  });
}
function __values(a) {
  var u = typeof Symbol == "function" && Symbol.iterator, c = u && a[u], l = 0;
  if (c)
    return c.call(a);
  if (a && typeof a.length == "number")
    return {
      next: function() {
        return a && l >= a.length && (a = void 0), { value: a && a[l++], done: !a };
      }
    };
  throw new TypeError(u ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __asyncValues(a) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var u = a[Symbol.asyncIterator], c;
  return u ? u.call(a) : (a = typeof __values == "function" ? __values(a) : a[Symbol.iterator](), c = {}, l("next"), l("throw"), l("return"), c[Symbol.asyncIterator] = function() {
    return this;
  }, c);
  function l(p) {
    c[p] = a[p] && function(_) {
      return new Promise(function(k, O) {
        _ = a[p](_), v(k, O, _.done, _.value);
      });
    };
  }
  function v(p, _, k, O) {
    Promise.resolve(O).then(function(D) {
      p({ value: D, done: k });
    }, _);
  }
}
typeof SuppressedError == "function" && SuppressedError;
var events$2 = { exports: {} }, R$1 = typeof Reflect == "object" ? Reflect : null, ReflectApply$1 = R$1 && typeof R$1.apply == "function" ? R$1.apply : function a(u, c, l) {
  return Function.prototype.apply.call(u, c, l);
}, ReflectOwnKeys$1;
R$1 && typeof R$1.ownKeys == "function" ? ReflectOwnKeys$1 = R$1.ownKeys : Object.getOwnPropertySymbols ? ReflectOwnKeys$1 = function(u) {
  return Object.getOwnPropertyNames(u).concat(Object.getOwnPropertySymbols(u));
} : ReflectOwnKeys$1 = function(u) {
  return Object.getOwnPropertyNames(u);
};
function ProcessEmitWarning$1(a) {
  console && console.warn && console.warn(a);
}
var NumberIsNaN$1 = Number.isNaN || function a(u) {
  return u !== u;
};
function EventEmitter$1() {
  EventEmitter$1.init.call(this);
}
events$2.exports = EventEmitter$1;
events$2.exports.once = once$7;
EventEmitter$1.EventEmitter = EventEmitter$1;
EventEmitter$1.prototype._events = void 0;
EventEmitter$1.prototype._eventsCount = 0;
EventEmitter$1.prototype._maxListeners = void 0;
var defaultMaxListeners$1 = 10;
function checkListener$1(a) {
  if (typeof a != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof a);
}
Object.defineProperty(EventEmitter$1, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return defaultMaxListeners$1;
  },
  set: function(a) {
    if (typeof a != "number" || a < 0 || NumberIsNaN$1(a))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + a + ".");
    defaultMaxListeners$1 = a;
  }
});
EventEmitter$1.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
EventEmitter$1.prototype.setMaxListeners = function a(u) {
  if (typeof u != "number" || u < 0 || NumberIsNaN$1(u))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + u + ".");
  return this._maxListeners = u, this;
};
function _getMaxListeners$1(a) {
  return a._maxListeners === void 0 ? EventEmitter$1.defaultMaxListeners : a._maxListeners;
}
EventEmitter$1.prototype.getMaxListeners = function a() {
  return _getMaxListeners$1(this);
};
EventEmitter$1.prototype.emit = function a(u) {
  for (var c = [], l = 1; l < arguments.length; l++)
    c.push(arguments[l]);
  var v = u === "error", p = this._events;
  if (p !== void 0)
    v = v && p.error === void 0;
  else if (!v)
    return !1;
  if (v) {
    var _;
    if (c.length > 0 && (_ = c[0]), _ instanceof Error)
      throw _;
    var k = new Error("Unhandled error." + (_ ? " (" + _.message + ")" : ""));
    throw k.context = _, k;
  }
  var O = p[u];
  if (O === void 0)
    return !1;
  if (typeof O == "function")
    ReflectApply$1(O, this, c);
  else
    for (var D = O.length, F = arrayClone$1(O, D), l = 0; l < D; ++l)
      ReflectApply$1(F[l], this, c);
  return !0;
};
function _addListener$1(a, u, c, l) {
  var v, p, _;
  if (checkListener$1(c), p = a._events, p === void 0 ? (p = a._events = /* @__PURE__ */ Object.create(null), a._eventsCount = 0) : (p.newListener !== void 0 && (a.emit("newListener", u, c.listener ? c.listener : c), p = a._events), _ = p[u]), _ === void 0)
    _ = p[u] = c, ++a._eventsCount;
  else if (typeof _ == "function" ? _ = p[u] = l ? [c, _] : [_, c] : l ? _.unshift(c) : _.push(c), v = _getMaxListeners$1(a), v > 0 && _.length > v && !_.warned) {
    _.warned = !0;
    var k = new Error("Possible EventEmitter memory leak detected. " + _.length + " " + String(u) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    k.name = "MaxListenersExceededWarning", k.emitter = a, k.type = u, k.count = _.length, ProcessEmitWarning$1(k);
  }
  return a;
}
EventEmitter$1.prototype.addListener = function a(u, c) {
  return _addListener$1(this, u, c, !1);
};
EventEmitter$1.prototype.on = EventEmitter$1.prototype.addListener;
EventEmitter$1.prototype.prependListener = function a(u, c) {
  return _addListener$1(this, u, c, !0);
};
function onceWrapper$1() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function _onceWrap$1(a, u, c) {
  var l = {
    fired: !1,
    wrapFn: void 0,
    target: a,
    type: u,
    listener: c
  }, v = onceWrapper$1.bind(l);
  return v.listener = c, l.wrapFn = v, v;
}
EventEmitter$1.prototype.once = function a(u, c) {
  return checkListener$1(c), this.on(u, _onceWrap$1(this, u, c)), this;
};
EventEmitter$1.prototype.prependOnceListener = function a(u, c) {
  return checkListener$1(c), this.prependListener(u, _onceWrap$1(this, u, c)), this;
};
EventEmitter$1.prototype.removeListener = function a(u, c) {
  var l, v, p, _, k;
  if (checkListener$1(c), v = this._events, v === void 0)
    return this;
  if (l = v[u], l === void 0)
    return this;
  if (l === c || l.listener === c)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete v[u], v.removeListener && this.emit("removeListener", u, l.listener || c));
  else if (typeof l != "function") {
    for (p = -1, _ = l.length - 1; _ >= 0; _--)
      if (l[_] === c || l[_].listener === c) {
        k = l[_].listener, p = _;
        break;
      }
    if (p < 0)
      return this;
    p === 0 ? l.shift() : spliceOne$1(l, p), l.length === 1 && (v[u] = l[0]), v.removeListener !== void 0 && this.emit("removeListener", u, k || c);
  }
  return this;
};
EventEmitter$1.prototype.off = EventEmitter$1.prototype.removeListener;
EventEmitter$1.prototype.removeAllListeners = function a(u) {
  var c, l, v;
  if (l = this._events, l === void 0)
    return this;
  if (l.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : l[u] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete l[u]), this;
  if (arguments.length === 0) {
    var p = Object.keys(l), _;
    for (v = 0; v < p.length; ++v)
      _ = p[v], _ !== "removeListener" && this.removeAllListeners(_);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (c = l[u], typeof c == "function")
    this.removeListener(u, c);
  else if (c !== void 0)
    for (v = c.length - 1; v >= 0; v--)
      this.removeListener(u, c[v]);
  return this;
};
function _listeners$1(a, u, c) {
  var l = a._events;
  if (l === void 0)
    return [];
  var v = l[u];
  return v === void 0 ? [] : typeof v == "function" ? c ? [v.listener || v] : [v] : c ? unwrapListeners$1(v) : arrayClone$1(v, v.length);
}
EventEmitter$1.prototype.listeners = function a(u) {
  return _listeners$1(this, u, !0);
};
EventEmitter$1.prototype.rawListeners = function a(u) {
  return _listeners$1(this, u, !1);
};
EventEmitter$1.listenerCount = function(a, u) {
  return typeof a.listenerCount == "function" ? a.listenerCount(u) : listenerCount$1.call(a, u);
};
EventEmitter$1.prototype.listenerCount = listenerCount$1;
function listenerCount$1(a) {
  var u = this._events;
  if (u !== void 0) {
    var c = u[a];
    if (typeof c == "function")
      return 1;
    if (c !== void 0)
      return c.length;
  }
  return 0;
}
EventEmitter$1.prototype.eventNames = function a() {
  return this._eventsCount > 0 ? ReflectOwnKeys$1(this._events) : [];
};
function arrayClone$1(a, u) {
  for (var c = new Array(u), l = 0; l < u; ++l)
    c[l] = a[l];
  return c;
}
function spliceOne$1(a, u) {
  for (; u + 1 < a.length; u++)
    a[u] = a[u + 1];
  a.pop();
}
function unwrapListeners$1(a) {
  for (var u = new Array(a.length), c = 0; c < u.length; ++c)
    u[c] = a[c].listener || a[c];
  return u;
}
function once$7(a, u) {
  return new Promise(function(c, l) {
    function v(_) {
      a.removeListener(u, p), l(_);
    }
    function p() {
      typeof a.removeListener == "function" && a.removeListener("error", v), c([].slice.call(arguments));
    }
    eventTargetAgnosticAddListener$1(a, u, p, {
      once: !0
    }), u !== "error" && addErrorHandlerIfEventEmitter$1(a, v, {
      once: !0
    });
  });
}
function addErrorHandlerIfEventEmitter$1(a, u, c) {
  typeof a.on == "function" && eventTargetAgnosticAddListener$1(a, "error", u, c);
}
function eventTargetAgnosticAddListener$1(a, u, c, l) {
  if (typeof a.on == "function")
    l.once ? a.once(u, c) : a.on(u, c);
  else if (typeof a.addEventListener == "function")
    a.addEventListener(u, function v(p) {
      l.once && a.removeEventListener(u, v), c(p);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof a);
}
var eventsExports$1 = events$2.exports;
let logDisabled_ = !0, deprecationWarnings_ = !0;
function extractVersion(a, u, c) {
  const l = a.match(u);
  return l && l.length >= c && parseInt(l[c], 10);
}
function wrapPeerConnectionEvent(a, u, c) {
  if (!a.RTCPeerConnection)
    return;
  const l = a.RTCPeerConnection.prototype, v = l.addEventListener;
  l.addEventListener = function(_, k) {
    if (_ !== u)
      return v.apply(this, arguments);
    const O = (D) => {
      const F = c(D);
      F && (k.handleEvent ? k.handleEvent(F) : k(F));
    };
    return this._eventMap = this._eventMap || {}, this._eventMap[u] || (this._eventMap[u] = /* @__PURE__ */ new Map()), this._eventMap[u].set(k, O), v.apply(this, [_, O]);
  };
  const p = l.removeEventListener;
  l.removeEventListener = function(_, k) {
    if (_ !== u || !this._eventMap || !this._eventMap[u])
      return p.apply(this, arguments);
    if (!this._eventMap[u].has(k))
      return p.apply(this, arguments);
    const O = this._eventMap[u].get(k);
    return this._eventMap[u].delete(k), this._eventMap[u].size === 0 && delete this._eventMap[u], Object.keys(this._eventMap).length === 0 && delete this._eventMap, p.apply(this, [_, O]);
  }, Object.defineProperty(l, "on" + u, {
    get() {
      return this["_on" + u];
    },
    set(_) {
      this["_on" + u] && (this.removeEventListener(u, this["_on" + u]), delete this["_on" + u]), _ && this.addEventListener(u, this["_on" + u] = _);
    },
    enumerable: !0,
    configurable: !0
  });
}
function disableLog(a) {
  return typeof a != "boolean" ? new Error("Argument type: " + typeof a + ". Please use a boolean.") : (logDisabled_ = a, a ? "adapter.js logging disabled" : "adapter.js logging enabled");
}
function disableWarnings(a) {
  return typeof a != "boolean" ? new Error("Argument type: " + typeof a + ". Please use a boolean.") : (deprecationWarnings_ = !a, "adapter.js deprecation warnings " + (a ? "disabled" : "enabled"));
}
function log$1() {
  if (typeof window == "object") {
    if (logDisabled_)
      return;
    typeof console < "u" && typeof console.log == "function" && console.log.apply(console, arguments);
  }
}
function deprecated(a, u) {
  deprecationWarnings_ && console.warn(a + " is deprecated, please use " + u + " instead.");
}
function detectBrowser(a) {
  const u = {
    browser: null,
    version: null
  };
  if (typeof a > "u" || !a.navigator || !a.navigator.userAgent)
    return u.browser = "Not a browser.", u;
  const {
    navigator: c
  } = a;
  if (c.mozGetUserMedia)
    u.browser = "firefox", u.version = extractVersion(c.userAgent, /Firefox\/(\d+)\./, 1);
  else if (c.webkitGetUserMedia || a.isSecureContext === !1 && a.webkitRTCPeerConnection)
    u.browser = "chrome", u.version = extractVersion(c.userAgent, /Chrom(e|ium)\/(\d+)\./, 2);
  else if (a.RTCPeerConnection && c.userAgent.match(/AppleWebKit\/(\d+)\./))
    u.browser = "safari", u.version = extractVersion(c.userAgent, /AppleWebKit\/(\d+)\./, 1), u.supportsUnifiedPlan = a.RTCRtpTransceiver && "currentDirection" in a.RTCRtpTransceiver.prototype;
  else
    return u.browser = "Not a supported browser.", u;
  return u;
}
function isObject$7(a) {
  return Object.prototype.toString.call(a) === "[object Object]";
}
function compactObject(a) {
  return isObject$7(a) ? Object.keys(a).reduce(function(u, c) {
    const l = isObject$7(a[c]), v = l ? compactObject(a[c]) : a[c], p = l && !Object.keys(v).length;
    return v === void 0 || p ? u : Object.assign(u, {
      [c]: v
    });
  }, {}) : a;
}
function walkStats(a, u, c) {
  !u || c.has(u.id) || (c.set(u.id, u), Object.keys(u).forEach((l) => {
    l.endsWith("Id") ? walkStats(a, a.get(u[l]), c) : l.endsWith("Ids") && u[l].forEach((v) => {
      walkStats(a, a.get(v), c);
    });
  }));
}
function filterStats(a, u, c) {
  const l = c ? "outbound-rtp" : "inbound-rtp", v = /* @__PURE__ */ new Map();
  if (u === null)
    return v;
  const p = [];
  return a.forEach((_) => {
    _.type === "track" && _.trackIdentifier === u.id && p.push(_);
  }), p.forEach((_) => {
    a.forEach((k) => {
      k.type === l && k.trackId === _.id && walkStats(a, k, v);
    });
  }), v;
}
const logging = log$1;
function shimGetUserMedia$2(a, u) {
  const c = a && a.navigator;
  if (!c.mediaDevices)
    return;
  const l = function(k) {
    if (typeof k != "object" || k.mandatory || k.optional)
      return k;
    const O = {};
    return Object.keys(k).forEach((D) => {
      if (D === "require" || D === "advanced" || D === "mediaSource")
        return;
      const F = typeof k[D] == "object" ? k[D] : {
        ideal: k[D]
      };
      F.exact !== void 0 && typeof F.exact == "number" && (F.min = F.max = F.exact);
      const z = function(j, ee) {
        return j ? j + ee.charAt(0).toUpperCase() + ee.slice(1) : ee === "deviceId" ? "sourceId" : ee;
      };
      if (F.ideal !== void 0) {
        O.optional = O.optional || [];
        let j = {};
        typeof F.ideal == "number" ? (j[z("min", D)] = F.ideal, O.optional.push(j), j = {}, j[z("max", D)] = F.ideal, O.optional.push(j)) : (j[z("", D)] = F.ideal, O.optional.push(j));
      }
      F.exact !== void 0 && typeof F.exact != "number" ? (O.mandatory = O.mandatory || {}, O.mandatory[z("", D)] = F.exact) : ["min", "max"].forEach((j) => {
        F[j] !== void 0 && (O.mandatory = O.mandatory || {}, O.mandatory[z(j, D)] = F[j]);
      });
    }), k.advanced && (O.optional = (O.optional || []).concat(k.advanced)), O;
  }, v = function(k, O) {
    if (u.version >= 61)
      return O(k);
    if (k = JSON.parse(JSON.stringify(k)), k && typeof k.audio == "object") {
      const D = function(F, z, j) {
        z in F && !(j in F) && (F[j] = F[z], delete F[z]);
      };
      k = JSON.parse(JSON.stringify(k)), D(k.audio, "autoGainControl", "googAutoGainControl"), D(k.audio, "noiseSuppression", "googNoiseSuppression"), k.audio = l(k.audio);
    }
    if (k && typeof k.video == "object") {
      let D = k.video.facingMode;
      D = D && (typeof D == "object" ? D : {
        ideal: D
      });
      const F = u.version < 66;
      if (D && (D.exact === "user" || D.exact === "environment" || D.ideal === "user" || D.ideal === "environment") && !(c.mediaDevices.getSupportedConstraints && c.mediaDevices.getSupportedConstraints().facingMode && !F)) {
        delete k.video.facingMode;
        let z;
        if (D.exact === "environment" || D.ideal === "environment" ? z = ["back", "rear"] : (D.exact === "user" || D.ideal === "user") && (z = ["front"]), z)
          return c.mediaDevices.enumerateDevices().then((j) => {
            j = j.filter((X) => X.kind === "videoinput");
            let ee = j.find((X) => z.some((ae) => X.label.toLowerCase().includes(ae)));
            return !ee && j.length && z.includes("back") && (ee = j[j.length - 1]), ee && (k.video.deviceId = D.exact ? {
              exact: ee.deviceId
            } : {
              ideal: ee.deviceId
            }), k.video = l(k.video), logging("chrome: " + JSON.stringify(k)), O(k);
          });
      }
      k.video = l(k.video);
    }
    return logging("chrome: " + JSON.stringify(k)), O(k);
  }, p = function(k) {
    return u.version >= 64 ? k : {
      name: {
        PermissionDeniedError: "NotAllowedError",
        PermissionDismissedError: "NotAllowedError",
        InvalidStateError: "NotAllowedError",
        DevicesNotFoundError: "NotFoundError",
        ConstraintNotSatisfiedError: "OverconstrainedError",
        TrackStartError: "NotReadableError",
        MediaDeviceFailedDueToShutdown: "NotAllowedError",
        MediaDeviceKillSwitchOn: "NotAllowedError",
        TabCaptureError: "AbortError",
        ScreenCaptureError: "AbortError",
        DeviceCaptureError: "AbortError"
      }[k.name] || k.name,
      message: k.message,
      constraint: k.constraint || k.constraintName,
      toString() {
        return this.name + (this.message && ": ") + this.message;
      }
    };
  }, _ = function(k, O, D) {
    v(k, (F) => {
      c.webkitGetUserMedia(F, O, (z) => {
        D && D(p(z));
      });
    });
  };
  if (c.getUserMedia = _.bind(c), c.mediaDevices.getUserMedia) {
    const k = c.mediaDevices.getUserMedia.bind(c.mediaDevices);
    c.mediaDevices.getUserMedia = function(O) {
      return v(O, (D) => k(D).then((F) => {
        if (D.audio && !F.getAudioTracks().length || D.video && !F.getVideoTracks().length)
          throw F.getTracks().forEach((z) => {
            z.stop();
          }), new DOMException("", "NotFoundError");
        return F;
      }, (F) => Promise.reject(p(F))));
    };
  }
}
function shimGetDisplayMedia$1(a, u) {
  if (!(a.navigator.mediaDevices && "getDisplayMedia" in a.navigator.mediaDevices) && a.navigator.mediaDevices) {
    if (typeof u != "function") {
      console.error("shimGetDisplayMedia: getSourceId argument is not a function");
      return;
    }
    a.navigator.mediaDevices.getDisplayMedia = function(l) {
      return u(l).then((v) => {
        const p = l.video && l.video.width, _ = l.video && l.video.height, k = l.video && l.video.frameRate;
        return l.video = {
          mandatory: {
            chromeMediaSource: "desktop",
            chromeMediaSourceId: v,
            maxFrameRate: k || 3
          }
        }, p && (l.video.mandatory.maxWidth = p), _ && (l.video.mandatory.maxHeight = _), a.navigator.mediaDevices.getUserMedia(l);
      });
    };
  }
}
function shimMediaStream(a) {
  a.MediaStream = a.MediaStream || a.webkitMediaStream;
}
function shimOnTrack$1(a) {
  if (typeof a == "object" && a.RTCPeerConnection && !("ontrack" in a.RTCPeerConnection.prototype)) {
    Object.defineProperty(a.RTCPeerConnection.prototype, "ontrack", {
      get() {
        return this._ontrack;
      },
      set(c) {
        this._ontrack && this.removeEventListener("track", this._ontrack), this.addEventListener("track", this._ontrack = c);
      },
      enumerable: !0,
      configurable: !0
    });
    const u = a.RTCPeerConnection.prototype.setRemoteDescription;
    a.RTCPeerConnection.prototype.setRemoteDescription = function() {
      return this._ontrackpoly || (this._ontrackpoly = (l) => {
        l.stream.addEventListener("addtrack", (v) => {
          let p;
          a.RTCPeerConnection.prototype.getReceivers ? p = this.getReceivers().find((k) => k.track && k.track.id === v.track.id) : p = {
            track: v.track
          };
          const _ = new Event("track");
          _.track = v.track, _.receiver = p, _.transceiver = {
            receiver: p
          }, _.streams = [l.stream], this.dispatchEvent(_);
        }), l.stream.getTracks().forEach((v) => {
          let p;
          a.RTCPeerConnection.prototype.getReceivers ? p = this.getReceivers().find((k) => k.track && k.track.id === v.id) : p = {
            track: v
          };
          const _ = new Event("track");
          _.track = v, _.receiver = p, _.transceiver = {
            receiver: p
          }, _.streams = [l.stream], this.dispatchEvent(_);
        });
      }, this.addEventListener("addstream", this._ontrackpoly)), u.apply(this, arguments);
    };
  } else
    wrapPeerConnectionEvent(a, "track", (u) => (u.transceiver || Object.defineProperty(u, "transceiver", {
      value: {
        receiver: u.receiver
      }
    }), u));
}
function shimGetSendersWithDtmf(a) {
  if (typeof a == "object" && a.RTCPeerConnection && !("getSenders" in a.RTCPeerConnection.prototype) && "createDTMFSender" in a.RTCPeerConnection.prototype) {
    const u = function(v, p) {
      return {
        track: p,
        get dtmf() {
          return this._dtmf === void 0 && (p.kind === "audio" ? this._dtmf = v.createDTMFSender(p) : this._dtmf = null), this._dtmf;
        },
        _pc: v
      };
    };
    if (!a.RTCPeerConnection.prototype.getSenders) {
      a.RTCPeerConnection.prototype.getSenders = function() {
        return this._senders = this._senders || [], this._senders.slice();
      };
      const v = a.RTCPeerConnection.prototype.addTrack;
      a.RTCPeerConnection.prototype.addTrack = function(k, O) {
        let D = v.apply(this, arguments);
        return D || (D = u(this, k), this._senders.push(D)), D;
      };
      const p = a.RTCPeerConnection.prototype.removeTrack;
      a.RTCPeerConnection.prototype.removeTrack = function(k) {
        p.apply(this, arguments);
        const O = this._senders.indexOf(k);
        O !== -1 && this._senders.splice(O, 1);
      };
    }
    const c = a.RTCPeerConnection.prototype.addStream;
    a.RTCPeerConnection.prototype.addStream = function(p) {
      this._senders = this._senders || [], c.apply(this, [p]), p.getTracks().forEach((_) => {
        this._senders.push(u(this, _));
      });
    };
    const l = a.RTCPeerConnection.prototype.removeStream;
    a.RTCPeerConnection.prototype.removeStream = function(p) {
      this._senders = this._senders || [], l.apply(this, [p]), p.getTracks().forEach((_) => {
        const k = this._senders.find((O) => O.track === _);
        k && this._senders.splice(this._senders.indexOf(k), 1);
      });
    };
  } else if (typeof a == "object" && a.RTCPeerConnection && "getSenders" in a.RTCPeerConnection.prototype && "createDTMFSender" in a.RTCPeerConnection.prototype && a.RTCRtpSender && !("dtmf" in a.RTCRtpSender.prototype)) {
    const u = a.RTCPeerConnection.prototype.getSenders;
    a.RTCPeerConnection.prototype.getSenders = function() {
      const l = u.apply(this, []);
      return l.forEach((v) => v._pc = this), l;
    }, Object.defineProperty(a.RTCRtpSender.prototype, "dtmf", {
      get() {
        return this._dtmf === void 0 && (this.track.kind === "audio" ? this._dtmf = this._pc.createDTMFSender(this.track) : this._dtmf = null), this._dtmf;
      }
    });
  }
}
function shimGetStats(a) {
  if (!a.RTCPeerConnection)
    return;
  const u = a.RTCPeerConnection.prototype.getStats;
  a.RTCPeerConnection.prototype.getStats = function() {
    const [l, v, p] = arguments;
    if (arguments.length > 0 && typeof l == "function")
      return u.apply(this, arguments);
    if (u.length === 0 && (arguments.length === 0 || typeof l != "function"))
      return u.apply(this, []);
    const _ = function(O) {
      const D = {};
      return O.result().forEach((z) => {
        const j = {
          id: z.id,
          timestamp: z.timestamp,
          type: {
            localcandidate: "local-candidate",
            remotecandidate: "remote-candidate"
          }[z.type] || z.type
        };
        z.names().forEach((ee) => {
          j[ee] = z.stat(ee);
        }), D[j.id] = j;
      }), D;
    }, k = function(O) {
      return new Map(Object.keys(O).map((D) => [D, O[D]]));
    };
    if (arguments.length >= 2) {
      const O = function(D) {
        v(k(_(D)));
      };
      return u.apply(this, [O, l]);
    }
    return new Promise((O, D) => {
      u.apply(this, [function(F) {
        O(k(_(F)));
      }, D]);
    }).then(v, p);
  };
}
function shimSenderReceiverGetStats(a) {
  if (!(typeof a == "object" && a.RTCPeerConnection && a.RTCRtpSender && a.RTCRtpReceiver))
    return;
  if (!("getStats" in a.RTCRtpSender.prototype)) {
    const c = a.RTCPeerConnection.prototype.getSenders;
    c && (a.RTCPeerConnection.prototype.getSenders = function() {
      const p = c.apply(this, []);
      return p.forEach((_) => _._pc = this), p;
    });
    const l = a.RTCPeerConnection.prototype.addTrack;
    l && (a.RTCPeerConnection.prototype.addTrack = function() {
      const p = l.apply(this, arguments);
      return p._pc = this, p;
    }), a.RTCRtpSender.prototype.getStats = function() {
      const p = this;
      return this._pc.getStats().then((_) => (
        /* Note: this will include stats of all senders that
         *   send a track with the same id as sender.track as
         *   it is not possible to identify the RTCRtpSender.
         */
        filterStats(_, p.track, !0)
      ));
    };
  }
  if (!("getStats" in a.RTCRtpReceiver.prototype)) {
    const c = a.RTCPeerConnection.prototype.getReceivers;
    c && (a.RTCPeerConnection.prototype.getReceivers = function() {
      const v = c.apply(this, []);
      return v.forEach((p) => p._pc = this), v;
    }), wrapPeerConnectionEvent(a, "track", (l) => (l.receiver._pc = l.srcElement, l)), a.RTCRtpReceiver.prototype.getStats = function() {
      const v = this;
      return this._pc.getStats().then((p) => filterStats(p, v.track, !1));
    };
  }
  if (!("getStats" in a.RTCRtpSender.prototype && "getStats" in a.RTCRtpReceiver.prototype))
    return;
  const u = a.RTCPeerConnection.prototype.getStats;
  a.RTCPeerConnection.prototype.getStats = function() {
    if (arguments.length > 0 && arguments[0] instanceof a.MediaStreamTrack) {
      const l = arguments[0];
      let v, p, _;
      return this.getSenders().forEach((k) => {
        k.track === l && (v ? _ = !0 : v = k);
      }), this.getReceivers().forEach((k) => (k.track === l && (p ? _ = !0 : p = k), k.track === l)), _ || v && p ? Promise.reject(new DOMException("There are more than one sender or receiver for the track.", "InvalidAccessError")) : v ? v.getStats() : p ? p.getStats() : Promise.reject(new DOMException("There is no sender or receiver for the track.", "InvalidAccessError"));
    }
    return u.apply(this, arguments);
  };
}
function shimAddTrackRemoveTrackWithNative(a) {
  a.RTCPeerConnection.prototype.getLocalStreams = function() {
    return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, Object.keys(this._shimmedLocalStreams).map((_) => this._shimmedLocalStreams[_][0]);
  };
  const u = a.RTCPeerConnection.prototype.addTrack;
  a.RTCPeerConnection.prototype.addTrack = function(_, k) {
    if (!k)
      return u.apply(this, arguments);
    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
    const O = u.apply(this, arguments);
    return this._shimmedLocalStreams[k.id] ? this._shimmedLocalStreams[k.id].indexOf(O) === -1 && this._shimmedLocalStreams[k.id].push(O) : this._shimmedLocalStreams[k.id] = [k, O], O;
  };
  const c = a.RTCPeerConnection.prototype.addStream;
  a.RTCPeerConnection.prototype.addStream = function(_) {
    this._shimmedLocalStreams = this._shimmedLocalStreams || {}, _.getTracks().forEach((D) => {
      if (this.getSenders().find((z) => z.track === D))
        throw new DOMException("Track already exists.", "InvalidAccessError");
    });
    const k = this.getSenders();
    c.apply(this, arguments);
    const O = this.getSenders().filter((D) => k.indexOf(D) === -1);
    this._shimmedLocalStreams[_.id] = [_].concat(O);
  };
  const l = a.RTCPeerConnection.prototype.removeStream;
  a.RTCPeerConnection.prototype.removeStream = function(_) {
    return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, delete this._shimmedLocalStreams[_.id], l.apply(this, arguments);
  };
  const v = a.RTCPeerConnection.prototype.removeTrack;
  a.RTCPeerConnection.prototype.removeTrack = function(_) {
    return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, _ && Object.keys(this._shimmedLocalStreams).forEach((k) => {
      const O = this._shimmedLocalStreams[k].indexOf(_);
      O !== -1 && this._shimmedLocalStreams[k].splice(O, 1), this._shimmedLocalStreams[k].length === 1 && delete this._shimmedLocalStreams[k];
    }), v.apply(this, arguments);
  };
}
function shimAddTrackRemoveTrack(a, u) {
  if (!a.RTCPeerConnection)
    return;
  if (a.RTCPeerConnection.prototype.addTrack && u.version >= 65)
    return shimAddTrackRemoveTrackWithNative(a);
  const c = a.RTCPeerConnection.prototype.getLocalStreams;
  a.RTCPeerConnection.prototype.getLocalStreams = function() {
    const F = c.apply(this);
    return this._reverseStreams = this._reverseStreams || {}, F.map((z) => this._reverseStreams[z.id]);
  };
  const l = a.RTCPeerConnection.prototype.addStream;
  a.RTCPeerConnection.prototype.addStream = function(F) {
    if (this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, F.getTracks().forEach((z) => {
      if (this.getSenders().find((ee) => ee.track === z))
        throw new DOMException("Track already exists.", "InvalidAccessError");
    }), !this._reverseStreams[F.id]) {
      const z = new a.MediaStream(F.getTracks());
      this._streams[F.id] = z, this._reverseStreams[z.id] = F, F = z;
    }
    l.apply(this, [F]);
  };
  const v = a.RTCPeerConnection.prototype.removeStream;
  a.RTCPeerConnection.prototype.removeStream = function(F) {
    this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, v.apply(this, [this._streams[F.id] || F]), delete this._reverseStreams[this._streams[F.id] ? this._streams[F.id].id : F.id], delete this._streams[F.id];
  }, a.RTCPeerConnection.prototype.addTrack = function(F, z) {
    if (this.signalingState === "closed")
      throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
    const j = [].slice.call(arguments, 1);
    if (j.length !== 1 || !j[0].getTracks().find((ae) => ae === F))
      throw new DOMException("The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.", "NotSupportedError");
    if (this.getSenders().find((ae) => ae.track === F))
      throw new DOMException("Track already exists.", "InvalidAccessError");
    this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {};
    const X = this._streams[z.id];
    if (X)
      X.addTrack(F), Promise.resolve().then(() => {
        this.dispatchEvent(new Event("negotiationneeded"));
      });
    else {
      const ae = new a.MediaStream([F]);
      this._streams[z.id] = ae, this._reverseStreams[ae.id] = z, this.addStream(ae);
    }
    return this.getSenders().find((ae) => ae.track === F);
  };
  function p(D, F) {
    let z = F.sdp;
    return Object.keys(D._reverseStreams || []).forEach((j) => {
      const ee = D._reverseStreams[j], X = D._streams[ee.id];
      z = z.replace(new RegExp(X.id, "g"), ee.id);
    }), new RTCSessionDescription({
      type: F.type,
      sdp: z
    });
  }
  function _(D, F) {
    let z = F.sdp;
    return Object.keys(D._reverseStreams || []).forEach((j) => {
      const ee = D._reverseStreams[j], X = D._streams[ee.id];
      z = z.replace(new RegExp(ee.id, "g"), X.id);
    }), new RTCSessionDescription({
      type: F.type,
      sdp: z
    });
  }
  ["createOffer", "createAnswer"].forEach(function(D) {
    const F = a.RTCPeerConnection.prototype[D], z = {
      [D]() {
        const j = arguments;
        return arguments.length && typeof arguments[0] == "function" ? F.apply(this, [(X) => {
          const ae = p(this, X);
          j[0].apply(null, [ae]);
        }, (X) => {
          j[1] && j[1].apply(null, X);
        }, arguments[2]]) : F.apply(this, arguments).then((X) => p(this, X));
      }
    };
    a.RTCPeerConnection.prototype[D] = z[D];
  });
  const k = a.RTCPeerConnection.prototype.setLocalDescription;
  a.RTCPeerConnection.prototype.setLocalDescription = function() {
    return !arguments.length || !arguments[0].type ? k.apply(this, arguments) : (arguments[0] = _(this, arguments[0]), k.apply(this, arguments));
  };
  const O = Object.getOwnPropertyDescriptor(a.RTCPeerConnection.prototype, "localDescription");
  Object.defineProperty(a.RTCPeerConnection.prototype, "localDescription", {
    get() {
      const D = O.get.apply(this);
      return D.type === "" ? D : p(this, D);
    }
  }), a.RTCPeerConnection.prototype.removeTrack = function(F) {
    if (this.signalingState === "closed")
      throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
    if (!F._pc)
      throw new DOMException("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.", "TypeError");
    if (!(F._pc === this))
      throw new DOMException("Sender was not created by this connection.", "InvalidAccessError");
    this._streams = this._streams || {};
    let j;
    Object.keys(this._streams).forEach((ee) => {
      this._streams[ee].getTracks().find((ae) => F.track === ae) && (j = this._streams[ee]);
    }), j && (j.getTracks().length === 1 ? this.removeStream(this._reverseStreams[j.id]) : j.removeTrack(F.track), this.dispatchEvent(new Event("negotiationneeded")));
  };
}
function shimPeerConnection$1(a, u) {
  !a.RTCPeerConnection && a.webkitRTCPeerConnection && (a.RTCPeerConnection = a.webkitRTCPeerConnection), a.RTCPeerConnection && u.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(c) {
    const l = a.RTCPeerConnection.prototype[c], v = {
      [c]() {
        return arguments[0] = new (c === "addIceCandidate" ? a.RTCIceCandidate : a.RTCSessionDescription)(arguments[0]), l.apply(this, arguments);
      }
    };
    a.RTCPeerConnection.prototype[c] = v[c];
  });
}
function fixNegotiationNeeded(a, u) {
  wrapPeerConnectionEvent(a, "negotiationneeded", (c) => {
    const l = c.target;
    if (!((u.version < 72 || l.getConfiguration && l.getConfiguration().sdpSemantics === "plan-b") && l.signalingState !== "stable"))
      return c;
  });
}
var chromeShim = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  fixNegotiationNeeded,
  shimAddTrackRemoveTrack,
  shimAddTrackRemoveTrackWithNative,
  shimGetDisplayMedia: shimGetDisplayMedia$1,
  shimGetSendersWithDtmf,
  shimGetStats,
  shimGetUserMedia: shimGetUserMedia$2,
  shimMediaStream,
  shimOnTrack: shimOnTrack$1,
  shimPeerConnection: shimPeerConnection$1,
  shimSenderReceiverGetStats
});
function shimGetUserMedia$1(a, u) {
  const c = a && a.navigator, l = a && a.MediaStreamTrack;
  if (c.getUserMedia = function(v, p, _) {
    deprecated("navigator.getUserMedia", "navigator.mediaDevices.getUserMedia"), c.mediaDevices.getUserMedia(v).then(p, _);
  }, !(u.version > 55 && "autoGainControl" in c.mediaDevices.getSupportedConstraints())) {
    const v = function(_, k, O) {
      k in _ && !(O in _) && (_[O] = _[k], delete _[k]);
    }, p = c.mediaDevices.getUserMedia.bind(c.mediaDevices);
    if (c.mediaDevices.getUserMedia = function(_) {
      return typeof _ == "object" && typeof _.audio == "object" && (_ = JSON.parse(JSON.stringify(_)), v(_.audio, "autoGainControl", "mozAutoGainControl"), v(_.audio, "noiseSuppression", "mozNoiseSuppression")), p(_);
    }, l && l.prototype.getSettings) {
      const _ = l.prototype.getSettings;
      l.prototype.getSettings = function() {
        const k = _.apply(this, arguments);
        return v(k, "mozAutoGainControl", "autoGainControl"), v(k, "mozNoiseSuppression", "noiseSuppression"), k;
      };
    }
    if (l && l.prototype.applyConstraints) {
      const _ = l.prototype.applyConstraints;
      l.prototype.applyConstraints = function(k) {
        return this.kind === "audio" && typeof k == "object" && (k = JSON.parse(JSON.stringify(k)), v(k, "autoGainControl", "mozAutoGainControl"), v(k, "noiseSuppression", "mozNoiseSuppression")), _.apply(this, [k]);
      };
    }
  }
}
function shimGetDisplayMedia(a, u) {
  a.navigator.mediaDevices && "getDisplayMedia" in a.navigator.mediaDevices || a.navigator.mediaDevices && (a.navigator.mediaDevices.getDisplayMedia = function(l) {
    if (!(l && l.video)) {
      const v = new DOMException("getDisplayMedia without video constraints is undefined");
      return v.name = "NotFoundError", v.code = 8, Promise.reject(v);
    }
    return l.video === !0 ? l.video = {
      mediaSource: u
    } : l.video.mediaSource = u, a.navigator.mediaDevices.getUserMedia(l);
  });
}
function shimOnTrack(a) {
  typeof a == "object" && a.RTCTrackEvent && "receiver" in a.RTCTrackEvent.prototype && !("transceiver" in a.RTCTrackEvent.prototype) && Object.defineProperty(a.RTCTrackEvent.prototype, "transceiver", {
    get() {
      return {
        receiver: this.receiver
      };
    }
  });
}
function shimPeerConnection(a, u) {
  if (typeof a != "object" || !(a.RTCPeerConnection || a.mozRTCPeerConnection))
    return;
  !a.RTCPeerConnection && a.mozRTCPeerConnection && (a.RTCPeerConnection = a.mozRTCPeerConnection), u.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(v) {
    const p = a.RTCPeerConnection.prototype[v], _ = {
      [v]() {
        return arguments[0] = new (v === "addIceCandidate" ? a.RTCIceCandidate : a.RTCSessionDescription)(arguments[0]), p.apply(this, arguments);
      }
    };
    a.RTCPeerConnection.prototype[v] = _[v];
  });
  const c = {
    inboundrtp: "inbound-rtp",
    outboundrtp: "outbound-rtp",
    candidatepair: "candidate-pair",
    localcandidate: "local-candidate",
    remotecandidate: "remote-candidate"
  }, l = a.RTCPeerConnection.prototype.getStats;
  a.RTCPeerConnection.prototype.getStats = function() {
    const [p, _, k] = arguments;
    return l.apply(this, [p || null]).then((O) => {
      if (u.version < 53 && !_)
        try {
          O.forEach((D) => {
            D.type = c[D.type] || D.type;
          });
        } catch (D) {
          if (D.name !== "TypeError")
            throw D;
          O.forEach((F, z) => {
            O.set(z, Object.assign({}, F, {
              type: c[F.type] || F.type
            }));
          });
        }
      return O;
    }).then(_, k);
  };
}
function shimSenderGetStats(a) {
  if (!(typeof a == "object" && a.RTCPeerConnection && a.RTCRtpSender) || a.RTCRtpSender && "getStats" in a.RTCRtpSender.prototype)
    return;
  const u = a.RTCPeerConnection.prototype.getSenders;
  u && (a.RTCPeerConnection.prototype.getSenders = function() {
    const v = u.apply(this, []);
    return v.forEach((p) => p._pc = this), v;
  });
  const c = a.RTCPeerConnection.prototype.addTrack;
  c && (a.RTCPeerConnection.prototype.addTrack = function() {
    const v = c.apply(this, arguments);
    return v._pc = this, v;
  }), a.RTCRtpSender.prototype.getStats = function() {
    return this.track ? this._pc.getStats(this.track) : Promise.resolve(/* @__PURE__ */ new Map());
  };
}
function shimReceiverGetStats(a) {
  if (!(typeof a == "object" && a.RTCPeerConnection && a.RTCRtpSender) || a.RTCRtpSender && "getStats" in a.RTCRtpReceiver.prototype)
    return;
  const u = a.RTCPeerConnection.prototype.getReceivers;
  u && (a.RTCPeerConnection.prototype.getReceivers = function() {
    const l = u.apply(this, []);
    return l.forEach((v) => v._pc = this), l;
  }), wrapPeerConnectionEvent(a, "track", (c) => (c.receiver._pc = c.srcElement, c)), a.RTCRtpReceiver.prototype.getStats = function() {
    return this._pc.getStats(this.track);
  };
}
function shimRemoveStream(a) {
  !a.RTCPeerConnection || "removeStream" in a.RTCPeerConnection.prototype || (a.RTCPeerConnection.prototype.removeStream = function(c) {
    deprecated("removeStream", "removeTrack"), this.getSenders().forEach((l) => {
      l.track && c.getTracks().includes(l.track) && this.removeTrack(l);
    });
  });
}
function shimRTCDataChannel(a) {
  a.DataChannel && !a.RTCDataChannel && (a.RTCDataChannel = a.DataChannel);
}
function shimAddTransceiver(a) {
  if (!(typeof a == "object" && a.RTCPeerConnection))
    return;
  const u = a.RTCPeerConnection.prototype.addTransceiver;
  u && (a.RTCPeerConnection.prototype.addTransceiver = function() {
    this.setParametersPromises = [];
    let l = arguments[1] && arguments[1].sendEncodings;
    l === void 0 && (l = []), l = [...l];
    const v = l.length > 0;
    v && l.forEach((_) => {
      if ("rid" in _ && !/^[a-z0-9]{0,16}$/i.test(_.rid))
        throw new TypeError("Invalid RID value provided.");
      if ("scaleResolutionDownBy" in _ && !(parseFloat(_.scaleResolutionDownBy) >= 1))
        throw new RangeError("scale_resolution_down_by must be >= 1.0");
      if ("maxFramerate" in _ && !(parseFloat(_.maxFramerate) >= 0))
        throw new RangeError("max_framerate must be >= 0.0");
    });
    const p = u.apply(this, arguments);
    if (v) {
      const {
        sender: _
      } = p, k = _.getParameters();
      (!("encodings" in k) || // Avoid being fooled by patched getParameters() below.
      k.encodings.length === 1 && Object.keys(k.encodings[0]).length === 0) && (k.encodings = l, _.sendEncodings = l, this.setParametersPromises.push(_.setParameters(k).then(() => {
        delete _.sendEncodings;
      }).catch(() => {
        delete _.sendEncodings;
      })));
    }
    return p;
  });
}
function shimGetParameters(a) {
  if (!(typeof a == "object" && a.RTCRtpSender))
    return;
  const u = a.RTCRtpSender.prototype.getParameters;
  u && (a.RTCRtpSender.prototype.getParameters = function() {
    const l = u.apply(this, arguments);
    return "encodings" in l || (l.encodings = [].concat(this.sendEncodings || [{}])), l;
  });
}
function shimCreateOffer(a) {
  if (!(typeof a == "object" && a.RTCPeerConnection))
    return;
  const u = a.RTCPeerConnection.prototype.createOffer;
  a.RTCPeerConnection.prototype.createOffer = function() {
    return this.setParametersPromises && this.setParametersPromises.length ? Promise.all(this.setParametersPromises).then(() => u.apply(this, arguments)).finally(() => {
      this.setParametersPromises = [];
    }) : u.apply(this, arguments);
  };
}
function shimCreateAnswer(a) {
  if (!(typeof a == "object" && a.RTCPeerConnection))
    return;
  const u = a.RTCPeerConnection.prototype.createAnswer;
  a.RTCPeerConnection.prototype.createAnswer = function() {
    return this.setParametersPromises && this.setParametersPromises.length ? Promise.all(this.setParametersPromises).then(() => u.apply(this, arguments)).finally(() => {
      this.setParametersPromises = [];
    }) : u.apply(this, arguments);
  };
}
var firefoxShim = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  shimAddTransceiver,
  shimCreateAnswer,
  shimCreateOffer,
  shimGetDisplayMedia,
  shimGetParameters,
  shimGetUserMedia: shimGetUserMedia$1,
  shimOnTrack,
  shimPeerConnection,
  shimRTCDataChannel,
  shimReceiverGetStats,
  shimRemoveStream,
  shimSenderGetStats
});
function shimLocalStreamsAPI(a) {
  if (!(typeof a != "object" || !a.RTCPeerConnection)) {
    if ("getLocalStreams" in a.RTCPeerConnection.prototype || (a.RTCPeerConnection.prototype.getLocalStreams = function() {
      return this._localStreams || (this._localStreams = []), this._localStreams;
    }), !("addStream" in a.RTCPeerConnection.prototype)) {
      const u = a.RTCPeerConnection.prototype.addTrack;
      a.RTCPeerConnection.prototype.addStream = function(l) {
        this._localStreams || (this._localStreams = []), this._localStreams.includes(l) || this._localStreams.push(l), l.getAudioTracks().forEach((v) => u.call(this, v, l)), l.getVideoTracks().forEach((v) => u.call(this, v, l));
      }, a.RTCPeerConnection.prototype.addTrack = function(l) {
        for (var v = arguments.length, p = new Array(v > 1 ? v - 1 : 0), _ = 1; _ < v; _++)
          p[_ - 1] = arguments[_];
        return p && p.forEach((k) => {
          this._localStreams ? this._localStreams.includes(k) || this._localStreams.push(k) : this._localStreams = [k];
        }), u.apply(this, arguments);
      };
    }
    "removeStream" in a.RTCPeerConnection.prototype || (a.RTCPeerConnection.prototype.removeStream = function(c) {
      this._localStreams || (this._localStreams = []);
      const l = this._localStreams.indexOf(c);
      if (l === -1)
        return;
      this._localStreams.splice(l, 1);
      const v = c.getTracks();
      this.getSenders().forEach((p) => {
        v.includes(p.track) && this.removeTrack(p);
      });
    });
  }
}
function shimRemoteStreamsAPI(a) {
  if (!(typeof a != "object" || !a.RTCPeerConnection) && ("getRemoteStreams" in a.RTCPeerConnection.prototype || (a.RTCPeerConnection.prototype.getRemoteStreams = function() {
    return this._remoteStreams ? this._remoteStreams : [];
  }), !("onaddstream" in a.RTCPeerConnection.prototype))) {
    Object.defineProperty(a.RTCPeerConnection.prototype, "onaddstream", {
      get() {
        return this._onaddstream;
      },
      set(c) {
        this._onaddstream && (this.removeEventListener("addstream", this._onaddstream), this.removeEventListener("track", this._onaddstreampoly)), this.addEventListener("addstream", this._onaddstream = c), this.addEventListener("track", this._onaddstreampoly = (l) => {
          l.streams.forEach((v) => {
            if (this._remoteStreams || (this._remoteStreams = []), this._remoteStreams.includes(v))
              return;
            this._remoteStreams.push(v);
            const p = new Event("addstream");
            p.stream = v, this.dispatchEvent(p);
          });
        });
      }
    });
    const u = a.RTCPeerConnection.prototype.setRemoteDescription;
    a.RTCPeerConnection.prototype.setRemoteDescription = function() {
      const l = this;
      return this._onaddstreampoly || this.addEventListener("track", this._onaddstreampoly = function(v) {
        v.streams.forEach((p) => {
          if (l._remoteStreams || (l._remoteStreams = []), l._remoteStreams.indexOf(p) >= 0)
            return;
          l._remoteStreams.push(p);
          const _ = new Event("addstream");
          _.stream = p, l.dispatchEvent(_);
        });
      }), u.apply(l, arguments);
    };
  }
}
function shimCallbacksAPI(a) {
  if (typeof a != "object" || !a.RTCPeerConnection)
    return;
  const u = a.RTCPeerConnection.prototype, c = u.createOffer, l = u.createAnswer, v = u.setLocalDescription, p = u.setRemoteDescription, _ = u.addIceCandidate;
  u.createOffer = function(D, F) {
    const z = arguments.length >= 2 ? arguments[2] : arguments[0], j = c.apply(this, [z]);
    return F ? (j.then(D, F), Promise.resolve()) : j;
  }, u.createAnswer = function(D, F) {
    const z = arguments.length >= 2 ? arguments[2] : arguments[0], j = l.apply(this, [z]);
    return F ? (j.then(D, F), Promise.resolve()) : j;
  };
  let k = function(O, D, F) {
    const z = v.apply(this, [O]);
    return F ? (z.then(D, F), Promise.resolve()) : z;
  };
  u.setLocalDescription = k, k = function(O, D, F) {
    const z = p.apply(this, [O]);
    return F ? (z.then(D, F), Promise.resolve()) : z;
  }, u.setRemoteDescription = k, k = function(O, D, F) {
    const z = _.apply(this, [O]);
    return F ? (z.then(D, F), Promise.resolve()) : z;
  }, u.addIceCandidate = k;
}
function shimGetUserMedia(a) {
  const u = a && a.navigator;
  if (u.mediaDevices && u.mediaDevices.getUserMedia) {
    const c = u.mediaDevices, l = c.getUserMedia.bind(c);
    u.mediaDevices.getUserMedia = (v) => l(shimConstraints(v));
  }
  !u.getUserMedia && u.mediaDevices && u.mediaDevices.getUserMedia && (u.getUserMedia = (function(l, v, p) {
    u.mediaDevices.getUserMedia(l).then(v, p);
  }).bind(u));
}
function shimConstraints(a) {
  return a && a.video !== void 0 ? Object.assign({}, a, {
    video: compactObject(a.video)
  }) : a;
}
function shimRTCIceServerUrls(a) {
  if (!a.RTCPeerConnection)
    return;
  const u = a.RTCPeerConnection;
  a.RTCPeerConnection = function(l, v) {
    if (l && l.iceServers) {
      const p = [];
      for (let _ = 0; _ < l.iceServers.length; _++) {
        let k = l.iceServers[_];
        k.urls === void 0 && k.url ? (deprecated("RTCIceServer.url", "RTCIceServer.urls"), k = JSON.parse(JSON.stringify(k)), k.urls = k.url, delete k.url, p.push(k)) : p.push(l.iceServers[_]);
      }
      l.iceServers = p;
    }
    return new u(l, v);
  }, a.RTCPeerConnection.prototype = u.prototype, "generateCertificate" in u && Object.defineProperty(a.RTCPeerConnection, "generateCertificate", {
    get() {
      return u.generateCertificate;
    }
  });
}
function shimTrackEventTransceiver(a) {
  typeof a == "object" && a.RTCTrackEvent && "receiver" in a.RTCTrackEvent.prototype && !("transceiver" in a.RTCTrackEvent.prototype) && Object.defineProperty(a.RTCTrackEvent.prototype, "transceiver", {
    get() {
      return {
        receiver: this.receiver
      };
    }
  });
}
function shimCreateOfferLegacy(a) {
  const u = a.RTCPeerConnection.prototype.createOffer;
  a.RTCPeerConnection.prototype.createOffer = function(l) {
    if (l) {
      typeof l.offerToReceiveAudio < "u" && (l.offerToReceiveAudio = !!l.offerToReceiveAudio);
      const v = this.getTransceivers().find((_) => _.receiver.track.kind === "audio");
      l.offerToReceiveAudio === !1 && v ? v.direction === "sendrecv" ? v.setDirection ? v.setDirection("sendonly") : v.direction = "sendonly" : v.direction === "recvonly" && (v.setDirection ? v.setDirection("inactive") : v.direction = "inactive") : l.offerToReceiveAudio === !0 && !v && this.addTransceiver("audio", {
        direction: "recvonly"
      }), typeof l.offerToReceiveVideo < "u" && (l.offerToReceiveVideo = !!l.offerToReceiveVideo);
      const p = this.getTransceivers().find((_) => _.receiver.track.kind === "video");
      l.offerToReceiveVideo === !1 && p ? p.direction === "sendrecv" ? p.setDirection ? p.setDirection("sendonly") : p.direction = "sendonly" : p.direction === "recvonly" && (p.setDirection ? p.setDirection("inactive") : p.direction = "inactive") : l.offerToReceiveVideo === !0 && !p && this.addTransceiver("video", {
        direction: "recvonly"
      });
    }
    return u.apply(this, arguments);
  };
}
function shimAudioContext(a) {
  typeof a != "object" || a.AudioContext || (a.AudioContext = a.webkitAudioContext);
}
var safariShim = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  shimAudioContext,
  shimCallbacksAPI,
  shimConstraints,
  shimCreateOfferLegacy,
  shimGetUserMedia,
  shimLocalStreamsAPI,
  shimRTCIceServerUrls,
  shimRemoteStreamsAPI,
  shimTrackEventTransceiver
}), sdp$1 = { exports: {} };
(function(a) {
  const u = {};
  u.generateIdentifier = function() {
    return Math.random().toString(36).substring(2, 12);
  }, u.localCName = u.generateIdentifier(), u.splitLines = function(c) {
    return c.trim().split(`
`).map((l) => l.trim());
  }, u.splitSections = function(c) {
    return c.split(`
m=`).map((v, p) => (p > 0 ? "m=" + v : v).trim() + `\r
`);
  }, u.getDescription = function(c) {
    const l = u.splitSections(c);
    return l && l[0];
  }, u.getMediaSections = function(c) {
    const l = u.splitSections(c);
    return l.shift(), l;
  }, u.matchPrefix = function(c, l) {
    return u.splitLines(c).filter((v) => v.indexOf(l) === 0);
  }, u.parseCandidate = function(c) {
    let l;
    c.indexOf("a=candidate:") === 0 ? l = c.substring(12).split(" ") : l = c.substring(10).split(" ");
    const v = {
      foundation: l[0],
      component: {
        1: "rtp",
        2: "rtcp"
      }[l[1]] || l[1],
      protocol: l[2].toLowerCase(),
      priority: parseInt(l[3], 10),
      ip: l[4],
      address: l[4],
      // address is an alias for ip.
      port: parseInt(l[5], 10),
      // skip parts[6] == 'typ'
      type: l[7]
    };
    for (let p = 8; p < l.length; p += 2)
      switch (l[p]) {
        case "raddr":
          v.relatedAddress = l[p + 1];
          break;
        case "rport":
          v.relatedPort = parseInt(l[p + 1], 10);
          break;
        case "tcptype":
          v.tcpType = l[p + 1];
          break;
        case "ufrag":
          v.ufrag = l[p + 1], v.usernameFragment = l[p + 1];
          break;
        default:
          v[l[p]] === void 0 && (v[l[p]] = l[p + 1]);
          break;
      }
    return v;
  }, u.writeCandidate = function(c) {
    const l = [];
    l.push(c.foundation);
    const v = c.component;
    v === "rtp" ? l.push(1) : v === "rtcp" ? l.push(2) : l.push(v), l.push(c.protocol.toUpperCase()), l.push(c.priority), l.push(c.address || c.ip), l.push(c.port);
    const p = c.type;
    return l.push("typ"), l.push(p), p !== "host" && c.relatedAddress && c.relatedPort && (l.push("raddr"), l.push(c.relatedAddress), l.push("rport"), l.push(c.relatedPort)), c.tcpType && c.protocol.toLowerCase() === "tcp" && (l.push("tcptype"), l.push(c.tcpType)), (c.usernameFragment || c.ufrag) && (l.push("ufrag"), l.push(c.usernameFragment || c.ufrag)), "candidate:" + l.join(" ");
  }, u.parseIceOptions = function(c) {
    return c.substring(14).split(" ");
  }, u.parseRtpMap = function(c) {
    let l = c.substring(9).split(" ");
    const v = {
      payloadType: parseInt(l.shift(), 10)
      // was: id
    };
    return l = l[0].split("/"), v.name = l[0], v.clockRate = parseInt(l[1], 10), v.channels = l.length === 3 ? parseInt(l[2], 10) : 1, v.numChannels = v.channels, v;
  }, u.writeRtpMap = function(c) {
    let l = c.payloadType;
    c.preferredPayloadType !== void 0 && (l = c.preferredPayloadType);
    const v = c.channels || c.numChannels || 1;
    return "a=rtpmap:" + l + " " + c.name + "/" + c.clockRate + (v !== 1 ? "/" + v : "") + `\r
`;
  }, u.parseExtmap = function(c) {
    const l = c.substring(9).split(" ");
    return {
      id: parseInt(l[0], 10),
      direction: l[0].indexOf("/") > 0 ? l[0].split("/")[1] : "sendrecv",
      uri: l[1],
      attributes: l.slice(2).join(" ")
    };
  }, u.writeExtmap = function(c) {
    return "a=extmap:" + (c.id || c.preferredId) + (c.direction && c.direction !== "sendrecv" ? "/" + c.direction : "") + " " + c.uri + (c.attributes ? " " + c.attributes : "") + `\r
`;
  }, u.parseFmtp = function(c) {
    const l = {};
    let v;
    const p = c.substring(c.indexOf(" ") + 1).split(";");
    for (let _ = 0; _ < p.length; _++)
      v = p[_].trim().split("="), l[v[0].trim()] = v[1];
    return l;
  }, u.writeFmtp = function(c) {
    let l = "", v = c.payloadType;
    if (c.preferredPayloadType !== void 0 && (v = c.preferredPayloadType), c.parameters && Object.keys(c.parameters).length) {
      const p = [];
      Object.keys(c.parameters).forEach((_) => {
        c.parameters[_] !== void 0 ? p.push(_ + "=" + c.parameters[_]) : p.push(_);
      }), l += "a=fmtp:" + v + " " + p.join(";") + `\r
`;
    }
    return l;
  }, u.parseRtcpFb = function(c) {
    const l = c.substring(c.indexOf(" ") + 1).split(" ");
    return {
      type: l.shift(),
      parameter: l.join(" ")
    };
  }, u.writeRtcpFb = function(c) {
    let l = "", v = c.payloadType;
    return c.preferredPayloadType !== void 0 && (v = c.preferredPayloadType), c.rtcpFeedback && c.rtcpFeedback.length && c.rtcpFeedback.forEach((p) => {
      l += "a=rtcp-fb:" + v + " " + p.type + (p.parameter && p.parameter.length ? " " + p.parameter : "") + `\r
`;
    }), l;
  }, u.parseSsrcMedia = function(c) {
    const l = c.indexOf(" "), v = {
      ssrc: parseInt(c.substring(7, l), 10)
    }, p = c.indexOf(":", l);
    return p > -1 ? (v.attribute = c.substring(l + 1, p), v.value = c.substring(p + 1)) : v.attribute = c.substring(l + 1), v;
  }, u.parseSsrcGroup = function(c) {
    const l = c.substring(13).split(" ");
    return {
      semantics: l.shift(),
      ssrcs: l.map((v) => parseInt(v, 10))
    };
  }, u.getMid = function(c) {
    const l = u.matchPrefix(c, "a=mid:")[0];
    if (l)
      return l.substring(6);
  }, u.parseFingerprint = function(c) {
    const l = c.substring(14).split(" ");
    return {
      algorithm: l[0].toLowerCase(),
      // algorithm is case-sensitive in Edge.
      value: l[1].toUpperCase()
      // the definition is upper-case in RFC 4572.
    };
  }, u.getDtlsParameters = function(c, l) {
    return {
      role: "auto",
      fingerprints: u.matchPrefix(c + l, "a=fingerprint:").map(u.parseFingerprint)
    };
  }, u.writeDtlsParameters = function(c, l) {
    let v = "a=setup:" + l + `\r
`;
    return c.fingerprints.forEach((p) => {
      v += "a=fingerprint:" + p.algorithm + " " + p.value + `\r
`;
    }), v;
  }, u.parseCryptoLine = function(c) {
    const l = c.substring(9).split(" ");
    return {
      tag: parseInt(l[0], 10),
      cryptoSuite: l[1],
      keyParams: l[2],
      sessionParams: l.slice(3)
    };
  }, u.writeCryptoLine = function(c) {
    return "a=crypto:" + c.tag + " " + c.cryptoSuite + " " + (typeof c.keyParams == "object" ? u.writeCryptoKeyParams(c.keyParams) : c.keyParams) + (c.sessionParams ? " " + c.sessionParams.join(" ") : "") + `\r
`;
  }, u.parseCryptoKeyParams = function(c) {
    if (c.indexOf("inline:") !== 0)
      return null;
    const l = c.substring(7).split("|");
    return {
      keyMethod: "inline",
      keySalt: l[0],
      lifeTime: l[1],
      mkiValue: l[2] ? l[2].split(":")[0] : void 0,
      mkiLength: l[2] ? l[2].split(":")[1] : void 0
    };
  }, u.writeCryptoKeyParams = function(c) {
    return c.keyMethod + ":" + c.keySalt + (c.lifeTime ? "|" + c.lifeTime : "") + (c.mkiValue && c.mkiLength ? "|" + c.mkiValue + ":" + c.mkiLength : "");
  }, u.getCryptoParameters = function(c, l) {
    return u.matchPrefix(c + l, "a=crypto:").map(u.parseCryptoLine);
  }, u.getIceParameters = function(c, l) {
    const v = u.matchPrefix(c + l, "a=ice-ufrag:")[0], p = u.matchPrefix(c + l, "a=ice-pwd:")[0];
    return v && p ? {
      usernameFragment: v.substring(12),
      password: p.substring(10)
    } : null;
  }, u.writeIceParameters = function(c) {
    let l = "a=ice-ufrag:" + c.usernameFragment + `\r
a=ice-pwd:` + c.password + `\r
`;
    return c.iceLite && (l += `a=ice-lite\r
`), l;
  }, u.parseRtpParameters = function(c) {
    const l = {
      codecs: [],
      headerExtensions: [],
      fecMechanisms: [],
      rtcp: []
    }, p = u.splitLines(c)[0].split(" ");
    l.profile = p[2];
    for (let k = 3; k < p.length; k++) {
      const O = p[k], D = u.matchPrefix(c, "a=rtpmap:" + O + " ")[0];
      if (D) {
        const F = u.parseRtpMap(D), z = u.matchPrefix(c, "a=fmtp:" + O + " ");
        switch (F.parameters = z.length ? u.parseFmtp(z[0]) : {}, F.rtcpFeedback = u.matchPrefix(c, "a=rtcp-fb:" + O + " ").map(u.parseRtcpFb), l.codecs.push(F), F.name.toUpperCase()) {
          case "RED":
          case "ULPFEC":
            l.fecMechanisms.push(F.name.toUpperCase());
            break;
        }
      }
    }
    u.matchPrefix(c, "a=extmap:").forEach((k) => {
      l.headerExtensions.push(u.parseExtmap(k));
    });
    const _ = u.matchPrefix(c, "a=rtcp-fb:* ").map(u.parseRtcpFb);
    return l.codecs.forEach((k) => {
      _.forEach((O) => {
        k.rtcpFeedback.find((F) => F.type === O.type && F.parameter === O.parameter) || k.rtcpFeedback.push(O);
      });
    }), l;
  }, u.writeRtpDescription = function(c, l) {
    let v = "";
    v += "m=" + c + " ", v += l.codecs.length > 0 ? "9" : "0", v += " " + (l.profile || "UDP/TLS/RTP/SAVPF") + " ", v += l.codecs.map((_) => _.preferredPayloadType !== void 0 ? _.preferredPayloadType : _.payloadType).join(" ") + `\r
`, v += `c=IN IP4 0.0.0.0\r
`, v += `a=rtcp:9 IN IP4 0.0.0.0\r
`, l.codecs.forEach((_) => {
      v += u.writeRtpMap(_), v += u.writeFmtp(_), v += u.writeRtcpFb(_);
    });
    let p = 0;
    return l.codecs.forEach((_) => {
      _.maxptime > p && (p = _.maxptime);
    }), p > 0 && (v += "a=maxptime:" + p + `\r
`), l.headerExtensions && l.headerExtensions.forEach((_) => {
      v += u.writeExtmap(_);
    }), v;
  }, u.parseRtpEncodingParameters = function(c) {
    const l = [], v = u.parseRtpParameters(c), p = v.fecMechanisms.indexOf("RED") !== -1, _ = v.fecMechanisms.indexOf("ULPFEC") !== -1, k = u.matchPrefix(c, "a=ssrc:").map((j) => u.parseSsrcMedia(j)).filter((j) => j.attribute === "cname"), O = k.length > 0 && k[0].ssrc;
    let D;
    const F = u.matchPrefix(c, "a=ssrc-group:FID").map((j) => j.substring(17).split(" ").map((X) => parseInt(X, 10)));
    F.length > 0 && F[0].length > 1 && F[0][0] === O && (D = F[0][1]), v.codecs.forEach((j) => {
      if (j.name.toUpperCase() === "RTX" && j.parameters.apt) {
        let ee = {
          ssrc: O,
          codecPayloadType: parseInt(j.parameters.apt, 10)
        };
        O && D && (ee.rtx = {
          ssrc: D
        }), l.push(ee), p && (ee = JSON.parse(JSON.stringify(ee)), ee.fec = {
          ssrc: O,
          mechanism: _ ? "red+ulpfec" : "red"
        }, l.push(ee));
      }
    }), l.length === 0 && O && l.push({
      ssrc: O
    });
    let z = u.matchPrefix(c, "b=");
    return z.length && (z[0].indexOf("b=TIAS:") === 0 ? z = parseInt(z[0].substring(7), 10) : z[0].indexOf("b=AS:") === 0 ? z = parseInt(z[0].substring(5), 10) * 1e3 * 0.95 - 50 * 40 * 8 : z = void 0, l.forEach((j) => {
      j.maxBitrate = z;
    })), l;
  }, u.parseRtcpParameters = function(c) {
    const l = {}, v = u.matchPrefix(c, "a=ssrc:").map((k) => u.parseSsrcMedia(k)).filter((k) => k.attribute === "cname")[0];
    v && (l.cname = v.value, l.ssrc = v.ssrc);
    const p = u.matchPrefix(c, "a=rtcp-rsize");
    l.reducedSize = p.length > 0, l.compound = p.length === 0;
    const _ = u.matchPrefix(c, "a=rtcp-mux");
    return l.mux = _.length > 0, l;
  }, u.writeRtcpParameters = function(c) {
    let l = "";
    return c.reducedSize && (l += `a=rtcp-rsize\r
`), c.mux && (l += `a=rtcp-mux\r
`), c.ssrc !== void 0 && c.cname && (l += "a=ssrc:" + c.ssrc + " cname:" + c.cname + `\r
`), l;
  }, u.parseMsid = function(c) {
    let l;
    const v = u.matchPrefix(c, "a=msid:");
    if (v.length === 1)
      return l = v[0].substring(7).split(" "), {
        stream: l[0],
        track: l[1]
      };
    const p = u.matchPrefix(c, "a=ssrc:").map((_) => u.parseSsrcMedia(_)).filter((_) => _.attribute === "msid");
    if (p.length > 0)
      return l = p[0].value.split(" "), {
        stream: l[0],
        track: l[1]
      };
  }, u.parseSctpDescription = function(c) {
    const l = u.parseMLine(c), v = u.matchPrefix(c, "a=max-message-size:");
    let p;
    v.length > 0 && (p = parseInt(v[0].substring(19), 10)), isNaN(p) && (p = 65536);
    const _ = u.matchPrefix(c, "a=sctp-port:");
    if (_.length > 0)
      return {
        port: parseInt(_[0].substring(12), 10),
        protocol: l.fmt,
        maxMessageSize: p
      };
    const k = u.matchPrefix(c, "a=sctpmap:");
    if (k.length > 0) {
      const O = k[0].substring(10).split(" ");
      return {
        port: parseInt(O[0], 10),
        protocol: O[1],
        maxMessageSize: p
      };
    }
  }, u.writeSctpDescription = function(c, l) {
    let v = [];
    return c.protocol !== "DTLS/SCTP" ? v = ["m=" + c.kind + " 9 " + c.protocol + " " + l.protocol + `\r
`, `c=IN IP4 0.0.0.0\r
`, "a=sctp-port:" + l.port + `\r
`] : v = ["m=" + c.kind + " 9 " + c.protocol + " " + l.port + `\r
`, `c=IN IP4 0.0.0.0\r
`, "a=sctpmap:" + l.port + " " + l.protocol + ` 65535\r
`], l.maxMessageSize !== void 0 && v.push("a=max-message-size:" + l.maxMessageSize + `\r
`), v.join("");
  }, u.generateSessionId = function() {
    return Math.random().toString().substr(2, 22);
  }, u.writeSessionBoilerplate = function(c, l, v) {
    let p;
    const _ = l !== void 0 ? l : 2;
    return c ? p = c : p = u.generateSessionId(), `v=0\r
o=` + (v || "thisisadapterortc") + " " + p + " " + _ + ` IN IP4 127.0.0.1\r
s=-\r
t=0 0\r
`;
  }, u.getDirection = function(c, l) {
    const v = u.splitLines(c);
    for (let p = 0; p < v.length; p++)
      switch (v[p]) {
        case "a=sendrecv":
        case "a=sendonly":
        case "a=recvonly":
        case "a=inactive":
          return v[p].substring(2);
      }
    return l ? u.getDirection(l) : "sendrecv";
  }, u.getKind = function(c) {
    return u.splitLines(c)[0].split(" ")[0].substring(2);
  }, u.isRejected = function(c) {
    return c.split(" ", 2)[1] === "0";
  }, u.parseMLine = function(c) {
    const v = u.splitLines(c)[0].substring(2).split(" ");
    return {
      kind: v[0],
      port: parseInt(v[1], 10),
      protocol: v[2],
      fmt: v.slice(3).join(" ")
    };
  }, u.parseOLine = function(c) {
    const v = u.matchPrefix(c, "o=")[0].substring(2).split(" ");
    return {
      username: v[0],
      sessionId: v[1],
      sessionVersion: parseInt(v[2], 10),
      netType: v[3],
      addressType: v[4],
      address: v[5]
    };
  }, u.isValidSDP = function(c) {
    if (typeof c != "string" || c.length === 0)
      return !1;
    const l = u.splitLines(c);
    for (let v = 0; v < l.length; v++)
      if (l[v].length < 2 || l[v].charAt(1) !== "=")
        return !1;
    return !0;
  }, a.exports = u;
})(sdp$1);
var sdpExports = sdp$1.exports, SDPUtils = /* @__PURE__ */ getDefaultExportFromCjs(sdpExports), sdp = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: SDPUtils
}, [sdpExports]);
function shimRTCIceCandidate(a) {
  if (!a.RTCIceCandidate || a.RTCIceCandidate && "foundation" in a.RTCIceCandidate.prototype)
    return;
  const u = a.RTCIceCandidate;
  a.RTCIceCandidate = function(l) {
    if (typeof l == "object" && l.candidate && l.candidate.indexOf("a=") === 0 && (l = JSON.parse(JSON.stringify(l)), l.candidate = l.candidate.substring(2)), l.candidate && l.candidate.length) {
      const v = new u(l), p = SDPUtils.parseCandidate(l.candidate);
      for (const _ in p)
        _ in v || Object.defineProperty(v, _, {
          value: p[_]
        });
      return v.toJSON = function() {
        return {
          candidate: v.candidate,
          sdpMid: v.sdpMid,
          sdpMLineIndex: v.sdpMLineIndex,
          usernameFragment: v.usernameFragment
        };
      }, v;
    }
    return new u(l);
  }, a.RTCIceCandidate.prototype = u.prototype, wrapPeerConnectionEvent(a, "icecandidate", (c) => (c.candidate && Object.defineProperty(c, "candidate", {
    value: new a.RTCIceCandidate(c.candidate),
    writable: "false"
  }), c));
}
function shimRTCIceCandidateRelayProtocol(a) {
  !a.RTCIceCandidate || a.RTCIceCandidate && "relayProtocol" in a.RTCIceCandidate.prototype || wrapPeerConnectionEvent(a, "icecandidate", (u) => {
    if (u.candidate) {
      const c = SDPUtils.parseCandidate(u.candidate.candidate);
      c.type === "relay" && (u.candidate.relayProtocol = {
        0: "tls",
        1: "tcp",
        2: "udp"
      }[c.priority >> 24]);
    }
    return u;
  });
}
function shimMaxMessageSize(a, u) {
  if (!a.RTCPeerConnection)
    return;
  "sctp" in a.RTCPeerConnection.prototype || Object.defineProperty(a.RTCPeerConnection.prototype, "sctp", {
    get() {
      return typeof this._sctp > "u" ? null : this._sctp;
    }
  });
  const c = function(k) {
    if (!k || !k.sdp)
      return !1;
    const O = SDPUtils.splitSections(k.sdp);
    return O.shift(), O.some((D) => {
      const F = SDPUtils.parseMLine(D);
      return F && F.kind === "application" && F.protocol.indexOf("SCTP") !== -1;
    });
  }, l = function(k) {
    const O = k.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
    if (O === null || O.length < 2)
      return -1;
    const D = parseInt(O[1], 10);
    return D !== D ? -1 : D;
  }, v = function(k) {
    let O = 65536;
    return u.browser === "firefox" && (u.version < 57 ? k === -1 ? O = 16384 : O = 2147483637 : u.version < 60 ? O = u.version === 57 ? 65535 : 65536 : O = 2147483637), O;
  }, p = function(k, O) {
    let D = 65536;
    u.browser === "firefox" && u.version === 57 && (D = 65535);
    const F = SDPUtils.matchPrefix(k.sdp, "a=max-message-size:");
    return F.length > 0 ? D = parseInt(F[0].substring(19), 10) : u.browser === "firefox" && O !== -1 && (D = 2147483637), D;
  }, _ = a.RTCPeerConnection.prototype.setRemoteDescription;
  a.RTCPeerConnection.prototype.setRemoteDescription = function() {
    if (this._sctp = null, u.browser === "chrome" && u.version >= 76) {
      const {
        sdpSemantics: O
      } = this.getConfiguration();
      O === "plan-b" && Object.defineProperty(this, "sctp", {
        get() {
          return typeof this._sctp > "u" ? null : this._sctp;
        },
        enumerable: !0,
        configurable: !0
      });
    }
    if (c(arguments[0])) {
      const O = l(arguments[0]), D = v(O), F = p(arguments[0], O);
      let z;
      D === 0 && F === 0 ? z = Number.POSITIVE_INFINITY : D === 0 || F === 0 ? z = Math.max(D, F) : z = Math.min(D, F);
      const j = {};
      Object.defineProperty(j, "maxMessageSize", {
        get() {
          return z;
        }
      }), this._sctp = j;
    }
    return _.apply(this, arguments);
  };
}
function shimSendThrowTypeError(a) {
  if (!(a.RTCPeerConnection && "createDataChannel" in a.RTCPeerConnection.prototype))
    return;
  function u(l, v) {
    const p = l.send;
    l.send = function() {
      const k = arguments[0], O = k.length || k.size || k.byteLength;
      if (l.readyState === "open" && v.sctp && O > v.sctp.maxMessageSize)
        throw new TypeError("Message too large (can send a maximum of " + v.sctp.maxMessageSize + " bytes)");
      return p.apply(l, arguments);
    };
  }
  const c = a.RTCPeerConnection.prototype.createDataChannel;
  a.RTCPeerConnection.prototype.createDataChannel = function() {
    const v = c.apply(this, arguments);
    return u(v, this), v;
  }, wrapPeerConnectionEvent(a, "datachannel", (l) => (u(l.channel, l.target), l));
}
function shimConnectionState(a) {
  if (!a.RTCPeerConnection || "connectionState" in a.RTCPeerConnection.prototype)
    return;
  const u = a.RTCPeerConnection.prototype;
  Object.defineProperty(u, "connectionState", {
    get() {
      return {
        completed: "connected",
        checking: "connecting"
      }[this.iceConnectionState] || this.iceConnectionState;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(u, "onconnectionstatechange", {
    get() {
      return this._onconnectionstatechange || null;
    },
    set(c) {
      this._onconnectionstatechange && (this.removeEventListener("connectionstatechange", this._onconnectionstatechange), delete this._onconnectionstatechange), c && this.addEventListener("connectionstatechange", this._onconnectionstatechange = c);
    },
    enumerable: !0,
    configurable: !0
  }), ["setLocalDescription", "setRemoteDescription"].forEach((c) => {
    const l = u[c];
    u[c] = function() {
      return this._connectionstatechangepoly || (this._connectionstatechangepoly = (v) => {
        const p = v.target;
        if (p._lastConnectionState !== p.connectionState) {
          p._lastConnectionState = p.connectionState;
          const _ = new Event("connectionstatechange", v);
          p.dispatchEvent(_);
        }
        return v;
      }, this.addEventListener("iceconnectionstatechange", this._connectionstatechangepoly)), l.apply(this, arguments);
    };
  });
}
function removeExtmapAllowMixed(a, u) {
  if (!a.RTCPeerConnection || u.browser === "chrome" && u.version >= 71 || u.browser === "safari" && u.version >= 605)
    return;
  const c = a.RTCPeerConnection.prototype.setRemoteDescription;
  a.RTCPeerConnection.prototype.setRemoteDescription = function(v) {
    if (v && v.sdp && v.sdp.indexOf(`
a=extmap-allow-mixed`) !== -1) {
      const p = v.sdp.split(`
`).filter((_) => _.trim() !== "a=extmap-allow-mixed").join(`
`);
      a.RTCSessionDescription && v instanceof a.RTCSessionDescription ? arguments[0] = new a.RTCSessionDescription({
        type: v.type,
        sdp: p
      }) : v.sdp = p;
    }
    return c.apply(this, arguments);
  };
}
function shimAddIceCandidateNullOrEmpty(a, u) {
  if (!(a.RTCPeerConnection && a.RTCPeerConnection.prototype))
    return;
  const c = a.RTCPeerConnection.prototype.addIceCandidate;
  !c || c.length === 0 || (a.RTCPeerConnection.prototype.addIceCandidate = function() {
    return arguments[0] ? (u.browser === "chrome" && u.version < 78 || u.browser === "firefox" && u.version < 68 || u.browser === "safari") && arguments[0] && arguments[0].candidate === "" ? Promise.resolve() : c.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), Promise.resolve());
  });
}
function shimParameterlessSetLocalDescription(a, u) {
  if (!(a.RTCPeerConnection && a.RTCPeerConnection.prototype))
    return;
  const c = a.RTCPeerConnection.prototype.setLocalDescription;
  !c || c.length === 0 || (a.RTCPeerConnection.prototype.setLocalDescription = function() {
    let v = arguments[0] || {};
    if (typeof v != "object" || v.type && v.sdp)
      return c.apply(this, arguments);
    if (v = {
      type: v.type,
      sdp: v.sdp
    }, !v.type)
      switch (this.signalingState) {
        case "stable":
        case "have-local-offer":
        case "have-remote-pranswer":
          v.type = "offer";
          break;
        default:
          v.type = "answer";
          break;
      }
    return v.sdp || v.type !== "offer" && v.type !== "answer" ? c.apply(this, [v]) : (v.type === "offer" ? this.createOffer : this.createAnswer).apply(this).then((_) => c.apply(this, [_]));
  });
}
var commonShim = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  removeExtmapAllowMixed,
  shimAddIceCandidateNullOrEmpty,
  shimConnectionState,
  shimMaxMessageSize,
  shimParameterlessSetLocalDescription,
  shimRTCIceCandidate,
  shimRTCIceCandidateRelayProtocol,
  shimSendThrowTypeError
});
function adapterFactory() {
  let {
    window: a
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    shimChrome: !0,
    shimFirefox: !0,
    shimSafari: !0
  };
  const c = log$1, l = detectBrowser(a), v = {
    browserDetails: l,
    commonShim,
    extractVersion,
    disableLog,
    disableWarnings,
    // Expose sdp as a convenience. For production apps include directly.
    sdp
  };
  switch (l.browser) {
    case "chrome":
      if (!chromeShim || !shimPeerConnection$1 || !u.shimChrome)
        return c("Chrome shim is not included in this adapter release."), v;
      if (l.version === null)
        return c("Chrome shim can not determine version, not shimming."), v;
      c("adapter.js shimming chrome."), v.browserShim = chromeShim, shimAddIceCandidateNullOrEmpty(a, l), shimParameterlessSetLocalDescription(a), shimGetUserMedia$2(a, l), shimMediaStream(a), shimPeerConnection$1(a, l), shimOnTrack$1(a), shimAddTrackRemoveTrack(a, l), shimGetSendersWithDtmf(a), shimGetStats(a), shimSenderReceiverGetStats(a), fixNegotiationNeeded(a, l), shimRTCIceCandidate(a), shimRTCIceCandidateRelayProtocol(a), shimConnectionState(a), shimMaxMessageSize(a, l), shimSendThrowTypeError(a), removeExtmapAllowMixed(a, l);
      break;
    case "firefox":
      if (!firefoxShim || !shimPeerConnection || !u.shimFirefox)
        return c("Firefox shim is not included in this adapter release."), v;
      c("adapter.js shimming firefox."), v.browserShim = firefoxShim, shimAddIceCandidateNullOrEmpty(a, l), shimParameterlessSetLocalDescription(a), shimGetUserMedia$1(a, l), shimPeerConnection(a, l), shimOnTrack(a), shimRemoveStream(a), shimSenderGetStats(a), shimReceiverGetStats(a), shimRTCDataChannel(a), shimAddTransceiver(a), shimGetParameters(a), shimCreateOffer(a), shimCreateAnswer(a), shimRTCIceCandidate(a), shimConnectionState(a), shimMaxMessageSize(a, l), shimSendThrowTypeError(a);
      break;
    case "safari":
      if (!safariShim || !u.shimSafari)
        return c("Safari shim is not included in this adapter release."), v;
      c("adapter.js shimming safari."), v.browserShim = safariShim, shimAddIceCandidateNullOrEmpty(a, l), shimParameterlessSetLocalDescription(a), shimRTCIceServerUrls(a), shimCreateOfferLegacy(a), shimCallbacksAPI(a), shimLocalStreamsAPI(a), shimRemoteStreamsAPI(a), shimTrackEventTransceiver(a), shimGetUserMedia(a), shimAudioContext(a), shimRTCIceCandidate(a), shimRTCIceCandidateRelayProtocol(a), shimMaxMessageSize(a, l), shimSendThrowTypeError(a), removeExtmapAllowMixed(a, l);
      break;
    default:
      c("Unsupported browser!");
      break;
  }
  return v;
}
adapterFactory({
  window: typeof window > "u" ? void 0 : window
});
const DECRYPTION_FAILURE_TOLERANCE = 10, E2EE_FLAG = "lk_e2ee", SALT = "LKFrameEncryptionKey", KEY_PROVIDER_DEFAULTS = {
  sharedKey: !1,
  ratchetSalt: SALT,
  ratchetWindowSize: 8,
  failureTolerance: DECRYPTION_FAILURE_TOLERANCE,
  keyringSize: 16
};
var KeyProviderEvent;
(function(a) {
  a.SetKey = "setKey", a.RatchetRequest = "ratchetRequest", a.KeyRatcheted = "keyRatcheted";
})(KeyProviderEvent || (KeyProviderEvent = {}));
var KeyHandlerEvent;
(function(a) {
  a.KeyRatcheted = "keyRatcheted";
})(KeyHandlerEvent || (KeyHandlerEvent = {}));
var EncryptionEvent;
(function(a) {
  a.ParticipantEncryptionStatusChanged = "participantEncryptionStatusChanged", a.EncryptionError = "encryptionError";
})(EncryptionEvent || (EncryptionEvent = {}));
var CryptorEvent;
(function(a) {
  a.Error = "cryptorError";
})(CryptorEvent || (CryptorEvent = {}));
function isE2EESupported() {
  return isInsertableStreamSupported() || isScriptTransformSupported();
}
function isScriptTransformSupported() {
  return typeof window.RTCRtpScriptTransform < "u";
}
function isInsertableStreamSupported() {
  return typeof window.RTCRtpSender < "u" && // @ts-ignore
  typeof window.RTCRtpSender.prototype.createEncodedStreams < "u";
}
class BaseKeyProvider extends eventsExports$1.EventEmitter {
  constructor() {
    let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    super(), this.onKeyRatcheted = (c, l) => {
      livekitLogger.debug("key ratcheted event received", {
        material: c,
        keyIndex: l
      });
    }, this.keyInfoMap = /* @__PURE__ */ new Map(), this.options = Object.assign(Object.assign({}, KEY_PROVIDER_DEFAULTS), u), this.on(KeyProviderEvent.KeyRatcheted, this.onKeyRatcheted);
  }
  /**
   * callback to invoke once a key has been set for a participant
   * @param key
   * @param participantIdentity
   * @param keyIndex
   */
  onSetEncryptionKey(u, c, l) {
    const v = {
      key: u,
      participantIdentity: c,
      keyIndex: l
    };
    if (!this.options.sharedKey && !c)
      throw new Error("participant identity needs to be passed for encryption key if sharedKey option is false");
    this.keyInfoMap.set("".concat(c ?? "shared", "-").concat(l ?? 0), v), this.emit(KeyProviderEvent.SetKey, v);
  }
  getKeys() {
    return Array.from(this.keyInfoMap.values());
  }
  getOptions() {
    return this.options;
  }
  ratchetKey(u, c) {
    this.emit(KeyProviderEvent.RatchetRequest, u, c);
  }
}
class LivekitError extends Error {
  constructor(u, c) {
    super(c || "an error has occured"), this.code = u;
  }
}
class ConnectionError extends LivekitError {
  constructor(u, c, l) {
    super(1, u), this.status = l, this.reason = c;
  }
}
class DeviceUnsupportedError extends LivekitError {
  constructor(u) {
    super(21, u ?? "device is unsupported");
  }
}
class TrackInvalidError extends LivekitError {
  constructor(u) {
    super(20, u ?? "track is invalid");
  }
}
class UnsupportedServer extends LivekitError {
  constructor(u) {
    super(10, u ?? "unsupported server");
  }
}
class UnexpectedConnectionState extends LivekitError {
  constructor(u) {
    super(12, u ?? "unexpected connection state");
  }
}
class NegotiationError extends LivekitError {
  constructor(u) {
    super(13, u ?? "unable to negotiate");
  }
}
var MediaDeviceFailure;
(function(a) {
  a.PermissionDenied = "PermissionDenied", a.NotFound = "NotFound", a.DeviceInUse = "DeviceInUse", a.Other = "Other";
})(MediaDeviceFailure || (MediaDeviceFailure = {}));
(function(a) {
  function u(c) {
    if (c && "name" in c)
      return c.name === "NotFoundError" || c.name === "DevicesNotFoundError" ? a.NotFound : c.name === "NotAllowedError" || c.name === "PermissionDeniedError" ? a.PermissionDenied : c.name === "NotReadableError" || c.name === "TrackStartError" ? a.DeviceInUse : a.Other;
  }
  a.getFailure = u;
})(MediaDeviceFailure || (MediaDeviceFailure = {}));
var RoomEvent;
(function(a) {
  a.Connected = "connected", a.Reconnecting = "reconnecting", a.Reconnected = "reconnected", a.Disconnected = "disconnected", a.ConnectionStateChanged = "connectionStateChanged", a.MediaDevicesChanged = "mediaDevicesChanged", a.ParticipantConnected = "participantConnected", a.ParticipantDisconnected = "participantDisconnected", a.TrackPublished = "trackPublished", a.TrackSubscribed = "trackSubscribed", a.TrackSubscriptionFailed = "trackSubscriptionFailed", a.TrackUnpublished = "trackUnpublished", a.TrackUnsubscribed = "trackUnsubscribed", a.TrackMuted = "trackMuted", a.TrackUnmuted = "trackUnmuted", a.LocalTrackPublished = "localTrackPublished", a.LocalTrackUnpublished = "localTrackUnpublished", a.LocalAudioSilenceDetected = "localAudioSilenceDetected", a.ActiveSpeakersChanged = "activeSpeakersChanged", a.ParticipantMetadataChanged = "participantMetadataChanged", a.ParticipantNameChanged = "participantNameChanged", a.RoomMetadataChanged = "roomMetadataChanged", a.DataReceived = "dataReceived", a.ConnectionQualityChanged = "connectionQualityChanged", a.TrackStreamStateChanged = "trackStreamStateChanged", a.TrackSubscriptionPermissionChanged = "trackSubscriptionPermissionChanged", a.TrackSubscriptionStatusChanged = "trackSubscriptionStatusChanged", a.AudioPlaybackStatusChanged = "audioPlaybackChanged", a.VideoPlaybackStatusChanged = "videoPlaybackChanged", a.MediaDevicesError = "mediaDevicesError", a.ParticipantPermissionsChanged = "participantPermissionsChanged", a.SignalConnected = "signalConnected", a.RecordingStatusChanged = "recordingStatusChanged", a.ParticipantEncryptionStatusChanged = "participantEncryptionStatusChanged", a.EncryptionError = "encryptionError", a.DCBufferStatusChanged = "dcBufferStatusChanged", a.ActiveDeviceChanged = "activeDeviceChanged";
})(RoomEvent || (RoomEvent = {}));
var ParticipantEvent;
(function(a) {
  a.TrackPublished = "trackPublished", a.TrackSubscribed = "trackSubscribed", a.TrackSubscriptionFailed = "trackSubscriptionFailed", a.TrackUnpublished = "trackUnpublished", a.TrackUnsubscribed = "trackUnsubscribed", a.TrackMuted = "trackMuted", a.TrackUnmuted = "trackUnmuted", a.LocalTrackPublished = "localTrackPublished", a.LocalTrackUnpublished = "localTrackUnpublished", a.ParticipantMetadataChanged = "participantMetadataChanged", a.ParticipantNameChanged = "participantNameChanged", a.DataReceived = "dataReceived", a.IsSpeakingChanged = "isSpeakingChanged", a.ConnectionQualityChanged = "connectionQualityChanged", a.TrackStreamStateChanged = "trackStreamStateChanged", a.TrackSubscriptionPermissionChanged = "trackSubscriptionPermissionChanged", a.TrackSubscriptionStatusChanged = "trackSubscriptionStatusChanged", a.MediaDevicesError = "mediaDevicesError", a.AudioStreamAcquired = "audioStreamAcquired", a.ParticipantPermissionsChanged = "participantPermissionsChanged", a.PCTrackAdded = "pcTrackAdded";
})(ParticipantEvent || (ParticipantEvent = {}));
var EngineEvent;
(function(a) {
  a.TransportsCreated = "transportsCreated", a.Connected = "connected", a.Disconnected = "disconnected", a.Resuming = "resuming", a.Resumed = "resumed", a.Restarting = "restarting", a.Restarted = "restarted", a.SignalResumed = "signalResumed", a.SignalRestarted = "signalRestarted", a.Closing = "closing", a.MediaTrackAdded = "mediaTrackAdded", a.ActiveSpeakersUpdate = "activeSpeakersUpdate", a.DataPacketReceived = "dataPacketReceived", a.RTPVideoMapUpdate = "rtpVideoMapUpdate", a.DCBufferStatusChanged = "dcBufferStatusChanged", a.ParticipantUpdate = "participantUpdate", a.RoomUpdate = "roomUpdate", a.SpeakersChanged = "speakersChanged", a.StreamStateChanged = "streamStateChanged", a.ConnectionQualityUpdate = "connectionQualityUpdate", a.SubscriptionError = "subscriptionError", a.SubscriptionPermissionUpdate = "subscriptionPermissionUpdate", a.RemoteMute = "remoteMute", a.SubscribedQualityUpdate = "subscribedQualityUpdate", a.LocalTrackUnpublished = "localTrackUnpublished", a.Offline = "offline";
})(EngineEvent || (EngineEvent = {}));
var TrackEvent;
(function(a) {
  a.Message = "message", a.Muted = "muted", a.Unmuted = "unmuted", a.Restarted = "restarted", a.Ended = "ended", a.Subscribed = "subscribed", a.Unsubscribed = "unsubscribed", a.UpdateSettings = "updateSettings", a.UpdateSubscription = "updateSubscription", a.AudioPlaybackStarted = "audioPlaybackStarted", a.AudioPlaybackFailed = "audioPlaybackFailed", a.AudioSilenceDetected = "audioSilenceDetected", a.VisibilityChanged = "visibilityChanged", a.VideoDimensionsChanged = "videoDimensionsChanged", a.VideoPlaybackStarted = "videoPlaybackStarted", a.VideoPlaybackFailed = "videoPlaybackFailed", a.ElementAttached = "elementAttached", a.ElementDetached = "elementDetached", a.UpstreamPaused = "upstreamPaused", a.UpstreamResumed = "upstreamResumed", a.SubscriptionPermissionChanged = "subscriptionPermissionChanged", a.SubscriptionStatusChanged = "subscriptionStatusChanged", a.SubscriptionFailed = "subscriptionFailed", a.TrackProcessorUpdate = "trackProcessorUpdate";
})(TrackEvent || (TrackEvent = {}));
function r$1(a, u, c) {
  var l, v, p;
  u === void 0 && (u = 50), c === void 0 && (c = {});
  var _ = (l = c.isImmediate) != null && l, k = (v = c.callback) != null && v, O = c.maxWait, D = Date.now(), F = [];
  function z() {
    if (O !== void 0) {
      var ee = Date.now() - D;
      if (ee + u >= O)
        return O - ee;
    }
    return u;
  }
  var j = function() {
    var ee = [].slice.call(arguments), X = this;
    return new Promise(function(ae, Q) {
      var ne = _ && p === void 0;
      if (p !== void 0 && clearTimeout(p), p = setTimeout(function() {
        if (p = void 0, D = Date.now(), !_) {
          var de = a.apply(X, ee);
          k && k(de), F.forEach(function(fe) {
            return (0, fe.resolve)(de);
          }), F = [];
        }
      }, z()), ne) {
        var Z = a.apply(X, ee);
        return k && k(Z), ae(Z);
      }
      F.push({
        resolve: ae,
        reject: Q
      });
    });
  };
  return j.cancel = function(ee) {
    p !== void 0 && clearTimeout(p), F.forEach(function(X) {
      return (0, X.reject)(ee);
    }), F = [];
  }, j;
}
const commonVersionIdentifier = /version\/(\d+(\.?_?\d+)+)/i;
let browserDetails;
function getBrowser(a) {
  let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
  if (typeof a > "u" && typeof navigator > "u")
    return;
  const c = (a ?? navigator.userAgent).toLowerCase();
  if (browserDetails === void 0 || u) {
    const l = browsersList.find((v) => {
      let {
        test: p
      } = v;
      return p.test(c);
    });
    browserDetails = l == null ? void 0 : l.describe(c);
  }
  return browserDetails;
}
const browsersList = [
  {
    test: /firefox|iceweasel|fxios/i,
    describe(a) {
      return {
        name: "Firefox",
        version: getMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, a),
        os: a.toLowerCase().includes("fxios") ? "iOS" : void 0
      };
    }
  },
  {
    test: /chrom|crios|crmo/i,
    describe(a) {
      return {
        name: "Chrome",
        version: getMatch(/(?:chrome|chromium|crios|crmo)\/(\d+(\.?_?\d+)+)/i, a),
        os: a.toLowerCase().includes("crios") ? "iOS" : void 0
      };
    }
  },
  /* Safari */
  {
    test: /safari|applewebkit/i,
    describe(a) {
      return {
        name: "Safari",
        version: getMatch(commonVersionIdentifier, a),
        os: a.includes("mobile/") ? "iOS" : "macOS"
      };
    }
  }
];
function getMatch(a, u) {
  let c = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
  const l = u.match(a);
  return l && l.length >= c && l[c] || "";
}
var version$1$1 = "2.0.10";
const version$3 = version$1$1, protocolVersion = 12;
class CriticalTimers {
}
CriticalTimers.setTimeout = function() {
  return setTimeout(...arguments);
};
CriticalTimers.setInterval = function() {
  return setInterval(...arguments);
};
CriticalTimers.clearTimeout = function() {
  return clearTimeout(...arguments);
};
CriticalTimers.clearInterval = function() {
  return clearInterval(...arguments);
};
class VideoPreset {
  constructor(u, c, l, v, p) {
    if (typeof u == "object")
      this.width = u.width, this.height = u.height, this.aspectRatio = u.aspectRatio, this.encoding = {
        maxBitrate: u.maxBitrate,
        maxFramerate: u.maxFramerate,
        priority: u.priority
      };
    else if (c !== void 0 && l !== void 0)
      this.width = u, this.height = c, this.aspectRatio = u / c, this.encoding = {
        maxBitrate: l,
        maxFramerate: v,
        priority: p
      };
    else
      throw new TypeError("Unsupported options: provide at least width, height and maxBitrate");
  }
  get resolution() {
    return {
      width: this.width,
      height: this.height,
      frameRate: this.encoding.maxFramerate,
      aspectRatio: this.aspectRatio
    };
  }
}
const backupCodecs = ["vp8", "h264"], videoCodecs = ["vp8", "h264", "vp9", "av1"];
function isBackupCodec(a) {
  return !!backupCodecs.find((u) => u === a);
}
var AudioPresets;
(function(a) {
  a.telephone = {
    maxBitrate: 12e3
  }, a.speech = {
    maxBitrate: 2e4
  }, a.music = {
    maxBitrate: 32e3
  }, a.musicStereo = {
    maxBitrate: 48e3
  }, a.musicHighQuality = {
    maxBitrate: 64e3
  }, a.musicHighQualityStereo = {
    maxBitrate: 96e3
  };
})(AudioPresets || (AudioPresets = {}));
const VideoPresets = {
  h90: new VideoPreset(160, 90, 9e4, 20),
  h180: new VideoPreset(320, 180, 16e4, 20),
  h216: new VideoPreset(384, 216, 18e4, 20),
  h360: new VideoPreset(640, 360, 45e4, 20),
  h540: new VideoPreset(960, 540, 8e5, 25),
  h720: new VideoPreset(1280, 720, 17e5, 30),
  h1080: new VideoPreset(1920, 1080, 3e6, 30),
  h1440: new VideoPreset(2560, 1440, 5e6, 30),
  h2160: new VideoPreset(3840, 2160, 8e6, 30)
}, VideoPresets43 = {
  h120: new VideoPreset(160, 120, 7e4, 20),
  h180: new VideoPreset(240, 180, 125e3, 20),
  h240: new VideoPreset(320, 240, 14e4, 20),
  h360: new VideoPreset(480, 360, 33e4, 20),
  h480: new VideoPreset(640, 480, 5e5, 20),
  h540: new VideoPreset(720, 540, 6e5, 25),
  h720: new VideoPreset(960, 720, 13e5, 30),
  h1080: new VideoPreset(1440, 1080, 23e5, 30),
  h1440: new VideoPreset(1920, 1440, 38e5, 30)
}, ScreenSharePresets = {
  h360fps3: new VideoPreset(640, 360, 2e5, 3, "medium"),
  h360fps15: new VideoPreset(640, 360, 4e5, 15, "medium"),
  h720fps5: new VideoPreset(1280, 720, 8e5, 5, "medium"),
  h720fps15: new VideoPreset(1280, 720, 15e5, 15, "medium"),
  h720fps30: new VideoPreset(1280, 720, 2e6, 30, "medium"),
  h1080fps15: new VideoPreset(1920, 1080, 25e5, 15, "medium"),
  h1080fps30: new VideoPreset(1920, 1080, 5e6, 30, "medium"),
  // original resolution, without resizing
  original: new VideoPreset(0, 0, 7e6, 30, "medium")
};
function cloneDeep(a) {
  if (!(typeof a > "u"))
    return typeof structuredClone == "function" ? structuredClone(a) : JSON.parse(JSON.stringify(a));
}
const BACKGROUND_REACTION_DELAY = 5e3, recycledElements = [];
var VideoQuality;
(function(a) {
  a[a.LOW = 0] = "LOW", a[a.MEDIUM = 1] = "MEDIUM", a[a.HIGH = 2] = "HIGH";
})(VideoQuality || (VideoQuality = {}));
class Track extends eventsExports$1.EventEmitter {
  constructor(u, c) {
    let l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var v;
    super(), this.attachedElements = [], this.isMuted = !1, this.streamState = Track.StreamState.Active, this.isInBackground = !1, this._currentBitrate = 0, this.log = livekitLogger, this.appVisibilityChangedListener = () => {
      this.backgroundTimeout && clearTimeout(this.backgroundTimeout), document.visibilityState === "hidden" ? this.backgroundTimeout = setTimeout(() => this.handleAppVisibilityChanged(), BACKGROUND_REACTION_DELAY) : this.handleAppVisibilityChanged();
    }, this.log = getLogger((v = l.loggerName) !== null && v !== void 0 ? v : LoggerNames.Track), this.loggerContextCb = l.loggerContextCb, this.setMaxListeners(100), this.kind = c, this._mediaStreamTrack = u, this._mediaStreamID = u.id, this.source = Track.Source.Unknown;
  }
  get logContext() {
    var u;
    return Object.assign(Object.assign({}, (u = this.loggerContextCb) === null || u === void 0 ? void 0 : u.call(this)), getLogContextFromTrack(this));
  }
  /** current receive bits per second */
  get currentBitrate() {
    return this._currentBitrate;
  }
  get mediaStreamTrack() {
    return this._mediaStreamTrack;
  }
  /**
   * @internal
   * used for keep mediaStream's first id, since it's id might change
   * if we disable/enable a track
   */
  get mediaStreamID() {
    return this._mediaStreamID;
  }
  attach(u) {
    let c = "audio";
    this.kind === Track.Kind.Video && (c = "video"), this.attachedElements.length === 0 && Track.Kind.Video && this.addAppVisibilityListener(), u || (c === "audio" && (recycledElements.forEach((p) => {
      p.parentElement === null && !u && (u = p);
    }), u && recycledElements.splice(recycledElements.indexOf(u), 1)), u || (u = document.createElement(c))), this.attachedElements.includes(u) || this.attachedElements.push(u), attachToElement(this.mediaStreamTrack, u);
    const l = u.srcObject.getTracks(), v = l.some((p) => p.kind === "audio");
    return u.play().then(() => {
      this.emit(v ? TrackEvent.AudioPlaybackStarted : TrackEvent.VideoPlaybackStarted);
    }).catch((p) => {
      p.name === "NotAllowedError" ? this.emit(v ? TrackEvent.AudioPlaybackFailed : TrackEvent.VideoPlaybackFailed, p) : p.name === "AbortError" ? livekitLogger.debug("".concat(v ? "audio" : "video", " playback aborted, likely due to new play request")) : livekitLogger.warn("could not playback ".concat(v ? "audio" : "video"), p), v && u && l.some((_) => _.kind === "video") && p.name === "NotAllowedError" && (u.muted = !0, u.play().catch(() => {
      }));
    }), this.emit(TrackEvent.ElementAttached, u), u;
  }
  detach(u) {
    try {
      if (u) {
        detachTrack(this.mediaStreamTrack, u);
        const l = this.attachedElements.indexOf(u);
        return l >= 0 && (this.attachedElements.splice(l, 1), this.recycleElement(u), this.emit(TrackEvent.ElementDetached, u)), u;
      }
      const c = [];
      return this.attachedElements.forEach((l) => {
        detachTrack(this.mediaStreamTrack, l), c.push(l), this.recycleElement(l), this.emit(TrackEvent.ElementDetached, l);
      }), this.attachedElements = [], c;
    } finally {
      this.attachedElements.length === 0 && this.removeAppVisibilityListener();
    }
  }
  stop() {
    this.stopMonitor(), this._mediaStreamTrack.stop();
  }
  enable() {
    this._mediaStreamTrack.enabled = !0;
  }
  disable() {
    this._mediaStreamTrack.enabled = !1;
  }
  /* @internal */
  stopMonitor() {
    this.monitorInterval && clearInterval(this.monitorInterval);
  }
  /** @internal */
  updateLoggerOptions(u) {
    u.loggerName && (this.log = getLogger(u.loggerName)), u.loggerContextCb && (this.loggerContextCb = u.loggerContextCb);
  }
  recycleElement(u) {
    if (u instanceof HTMLAudioElement) {
      let c = !0;
      u.pause(), recycledElements.forEach((l) => {
        l.parentElement || (c = !1);
      }), c && recycledElements.push(u);
    }
  }
  handleAppVisibilityChanged() {
    return __awaiter$3(this, void 0, void 0, function* () {
      this.isInBackground = document.visibilityState === "hidden";
    });
  }
  addAppVisibilityListener() {
    isWeb() ? (this.isInBackground = document.visibilityState === "hidden", document.addEventListener("visibilitychange", this.appVisibilityChangedListener)) : this.isInBackground = !1;
  }
  removeAppVisibilityListener() {
    isWeb() && document.removeEventListener("visibilitychange", this.appVisibilityChangedListener);
  }
}
function attachToElement(a, u) {
  let c;
  u.srcObject instanceof MediaStream ? c = u.srcObject : c = new MediaStream();
  let l;
  a.kind === "audio" ? l = c.getAudioTracks() : l = c.getVideoTracks(), l.includes(a) || (l.forEach((v) => {
    c.removeTrack(v);
  }), c.addTrack(a)), (!isSafari() || !(u instanceof HTMLVideoElement)) && (u.autoplay = !0), u.muted = c.getAudioTracks().length === 0, u instanceof HTMLVideoElement && (u.playsInline = !0), u.srcObject !== c && (u.srcObject = c, (isSafari() || isFireFox()) && u instanceof HTMLVideoElement && setTimeout(() => {
    u.srcObject = c, u.play().catch(() => {
    });
  }, 0));
}
function detachTrack(a, u) {
  if (u.srcObject instanceof MediaStream) {
    const c = u.srcObject;
    c.removeTrack(a), c.getTracks().length > 0 ? u.srcObject = c : u.srcObject = null;
  }
}
(function(a) {
  let u;
  (function(D) {
    D.Audio = "audio", D.Video = "video", D.Unknown = "unknown";
  })(u = a.Kind || (a.Kind = {}));
  let c;
  (function(D) {
    D.Camera = "camera", D.Microphone = "microphone", D.ScreenShare = "screen_share", D.ScreenShareAudio = "screen_share_audio", D.Unknown = "unknown";
  })(c = a.Source || (a.Source = {}));
  let l;
  (function(D) {
    D.Active = "active", D.Paused = "paused", D.Unknown = "unknown";
  })(l = a.StreamState || (a.StreamState = {}));
  function v(D) {
    switch (D) {
      case u.Audio:
        return TrackType.AUDIO;
      case u.Video:
        return TrackType.VIDEO;
      default:
        return TrackType.DATA;
    }
  }
  a.kindToProto = v;
  function p(D) {
    switch (D) {
      case TrackType.AUDIO:
        return u.Audio;
      case TrackType.VIDEO:
        return u.Video;
      default:
        return u.Unknown;
    }
  }
  a.kindFromProto = p;
  function _(D) {
    switch (D) {
      case c.Camera:
        return TrackSource.CAMERA;
      case c.Microphone:
        return TrackSource.MICROPHONE;
      case c.ScreenShare:
        return TrackSource.SCREEN_SHARE;
      case c.ScreenShareAudio:
        return TrackSource.SCREEN_SHARE_AUDIO;
      default:
        return TrackSource.UNKNOWN;
    }
  }
  a.sourceToProto = _;
  function k(D) {
    switch (D) {
      case TrackSource.CAMERA:
        return c.Camera;
      case TrackSource.MICROPHONE:
        return c.Microphone;
      case TrackSource.SCREEN_SHARE:
        return c.ScreenShare;
      case TrackSource.SCREEN_SHARE_AUDIO:
        return c.ScreenShareAudio;
      default:
        return c.Unknown;
    }
  }
  a.sourceFromProto = k;
  function O(D) {
    switch (D) {
      case StreamState.ACTIVE:
        return l.Active;
      case StreamState.PAUSED:
        return l.Paused;
      default:
        return l.Unknown;
    }
  }
  a.streamStateFromProto = O;
})(Track || (Track = {}));
function mergeDefaultOptions(a, u, c) {
  var l;
  const v = (l = cloneDeep(a)) !== null && l !== void 0 ? l : {};
  return v.audio === !0 && (v.audio = {}), v.video === !0 && (v.video = {}), v.audio && mergeObjectWithoutOverwriting(v.audio, u), v.video && mergeObjectWithoutOverwriting(v.video, c), v;
}
function mergeObjectWithoutOverwriting(a, u) {
  return Object.keys(u).forEach((c) => {
    a[c] === void 0 && (a[c] = u[c]);
  }), a;
}
function constraintsForOptions(a) {
  const u = {};
  if (a.video)
    if (typeof a.video == "object") {
      const c = {}, l = c, v = a.video;
      Object.keys(v).forEach((p) => {
        switch (p) {
          case "resolution":
            mergeObjectWithoutOverwriting(l, v.resolution);
            break;
          default:
            l[p] = v[p];
        }
      }), u.video = c;
    } else
      u.video = a.video;
  else
    u.video = !1;
  return a.audio ? typeof a.audio == "object" ? u.audio = a.audio : u.audio = !0 : u.audio = !1, u;
}
function detectSilence(a) {
  let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 200;
  return __awaiter$3(this, void 0, void 0, function* () {
    const c = getNewAudioContext();
    if (c) {
      const l = c.createAnalyser();
      l.fftSize = 2048;
      const v = l.frequencyBinCount, p = new Uint8Array(v);
      c.createMediaStreamSource(new MediaStream([a.mediaStreamTrack])).connect(l), yield sleep(u), l.getByteTimeDomainData(p);
      const k = p.some((O) => O !== 128 && O !== 0);
      return c.close(), !k;
    }
    return !1;
  });
}
function getNewAudioContext() {
  const a = (
    // @ts-ignore
    typeof window < "u" && (window.AudioContext || window.webkitAudioContext)
  );
  if (a)
    return new a({
      latencyHint: "interactive"
    });
}
function sourceToKind(a) {
  return a === Track.Source.Microphone ? "audioinput" : a === Track.Source.Camera ? "videoinput" : void 0;
}
function screenCaptureToDisplayMediaStreamOptions(a) {
  var u, c;
  let l = (u = a.video) !== null && u !== void 0 ? u : !0;
  return a.resolution && a.resolution.width > 0 && a.resolution.height > 0 && (l = typeof l == "boolean" ? {} : l, isSafari() ? l = Object.assign(Object.assign({}, l), {
    width: {
      max: a.resolution.width
    },
    height: {
      max: a.resolution.height
    },
    frameRate: a.resolution.frameRate
  }) : l = Object.assign(Object.assign({}, l), {
    width: {
      ideal: a.resolution.width
    },
    height: {
      ideal: a.resolution.height
    },
    frameRate: a.resolution.frameRate
  })), {
    audio: (c = a.audio) !== null && c !== void 0 ? c : !1,
    video: l,
    // @ts-expect-error support for experimental display media features
    controller: a.controller,
    selfBrowserSurface: a.selfBrowserSurface,
    surfaceSwitching: a.surfaceSwitching,
    systemAudio: a.systemAudio,
    preferCurrentTab: a.preferCurrentTab
  };
}
function mimeTypeToVideoCodecString(a) {
  const u = a.split("/")[1].toLowerCase();
  if (!videoCodecs.includes(u))
    throw Error("Video codec not supported: ".concat(u));
  return u;
}
function getTrackPublicationInfo(a) {
  const u = [];
  return a.forEach((c) => {
    c.track !== void 0 && u.push(new TrackPublishedResponse({
      cid: c.track.mediaStreamID,
      track: c.trackInfo
    }));
  }), u;
}
function getLogContextFromTrack(a) {
  return a instanceof Track ? {
    trackID: a.sid,
    source: a.source,
    muted: a.isMuted,
    enabled: a.mediaStreamTrack.enabled,
    kind: a.kind,
    streamID: a.mediaStreamID,
    streamTrackID: a.mediaStreamTrack.id
  } : {
    trackID: a.trackSid,
    enabled: a.isEnabled,
    muted: a.isMuted,
    trackInfo: Object.assign({
      mimeType: a.mimeType,
      name: a.trackName,
      encrypted: a.isEncrypted,
      kind: a.kind,
      source: a.source
    }, a.track ? getLogContextFromTrack(a.track) : {})
  };
}
const separator = "|", ddExtensionURI = "https://aomediacodec.github.io/av1-rtp-spec/#dependency-descriptor-rtp-header-extension";
function unpackStreamId(a) {
  const u = a.split(separator);
  return u.length > 1 ? [u[0], a.substr(u[0].length + 1)] : [a, ""];
}
function sleep(a) {
  return __awaiter$3(this, void 0, void 0, function* () {
    return new Promise((u) => CriticalTimers.setTimeout(u, a));
  });
}
function supportsTransceiver() {
  return "addTransceiver" in RTCPeerConnection.prototype;
}
function supportsAddTrack() {
  return "addTrack" in RTCPeerConnection.prototype;
}
function supportsAV1() {
  if (!("getCapabilities" in RTCRtpSender) || isSafari())
    return !1;
  const a = RTCRtpSender.getCapabilities("video");
  let u = !1;
  if (a) {
    for (const c of a.codecs)
      if (c.mimeType === "video/AV1") {
        u = !0;
        break;
      }
  }
  return u;
}
function supportsVP9() {
  if (!("getCapabilities" in RTCRtpSender) || isFireFox())
    return !1;
  if (isSafari()) {
    const c = getBrowser();
    if (c != null && c.version && compareVersions(c.version, "16") < 0)
      return !1;
  }
  const a = RTCRtpSender.getCapabilities("video");
  let u = !1;
  if (a) {
    for (const c of a.codecs)
      if (c.mimeType === "video/VP9") {
        u = !0;
        break;
      }
  }
  return u;
}
function isSVCCodec(a) {
  return a === "av1" || a === "vp9";
}
function supportsSetSinkId(a) {
  return document ? (a || (a = document.createElement("audio")), "setSinkId" in a) : !1;
}
const setCodecPreferencesVersions = {
  Chrome: "100",
  Safari: "15",
  Firefox: "100"
};
function supportsSetCodecPreferences(a) {
  if (!isWeb() || !("setCodecPreferences" in a))
    return !1;
  const u = getBrowser();
  if (!(u != null && u.name) || !u.version)
    return !1;
  const c = setCodecPreferencesVersions[u.name];
  return c ? compareVersions(u.version, c) >= 0 : !1;
}
function isBrowserSupported() {
  return typeof RTCPeerConnection > "u" ? !1 : supportsTransceiver() || supportsAddTrack();
}
function isFireFox() {
  var a;
  return ((a = getBrowser()) === null || a === void 0 ? void 0 : a.name) === "Firefox";
}
function isSafari() {
  var a;
  return ((a = getBrowser()) === null || a === void 0 ? void 0 : a.name) === "Safari";
}
function isSafari17() {
  const a = getBrowser();
  return (a == null ? void 0 : a.name) === "Safari" && a.version.startsWith("17.");
}
function isMobile() {
  return isWeb() ? /Tablet|iPad|Mobile|Android|BlackBerry/.test(navigator.userAgent) : !1;
}
function isWeb() {
  return typeof document < "u";
}
function isReactNative() {
  return navigator.product == "ReactNative";
}
function isCloud(a) {
  return a.hostname.endsWith(".livekit.cloud") || a.hostname.endsWith(".livekit.run");
}
function getLKReactNativeInfo() {
  if (global$1 && global$1.LiveKitReactNativeGlobal)
    return global$1.LiveKitReactNativeGlobal;
}
function getReactNativeOs() {
  if (!isReactNative())
    return;
  let a = getLKReactNativeInfo();
  if (a)
    return a.platform;
}
function getDevicePixelRatio() {
  if (isWeb())
    return window.devicePixelRatio;
  if (isReactNative()) {
    let a = getLKReactNativeInfo();
    if (a)
      return a.devicePixelRatio;
  }
  return 1;
}
function compareVersions(a, u) {
  const c = a.split("."), l = u.split("."), v = Math.min(c.length, l.length);
  for (let p = 0; p < v; ++p) {
    const _ = parseInt(c[p], 10), k = parseInt(l[p], 10);
    if (_ > k)
      return 1;
    if (_ < k)
      return -1;
    if (p === v - 1 && _ === k)
      return 0;
  }
  return a === "" && u !== "" ? -1 : u === "" ? 1 : c.length == l.length ? 0 : c.length < l.length ? -1 : 1;
}
function roDispatchCallback(a) {
  for (const u of a)
    u.target.handleResize(u);
}
function ioDispatchCallback(a) {
  for (const u of a)
    u.target.handleVisibilityChanged(u);
}
let resizeObserver = null;
const getResizeObserver = () => (resizeObserver || (resizeObserver = new ResizeObserver(roDispatchCallback)), resizeObserver);
let intersectionObserver = null;
const getIntersectionObserver = () => (intersectionObserver || (intersectionObserver = new IntersectionObserver(ioDispatchCallback, {
  root: null,
  rootMargin: "0px"
})), intersectionObserver);
function getClientInfo() {
  var a;
  const u = new ClientInfo({
    sdk: ClientInfo_SDK.JS,
    protocol: protocolVersion,
    version: version$3
  });
  return isReactNative() && (u.os = (a = getReactNativeOs()) !== null && a !== void 0 ? a : ""), u;
}
function createDummyVideoStreamTrack() {
  let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 16, u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 16, c = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, l = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
  const v = document.createElement("canvas");
  v.width = a, v.height = u;
  const p = v.getContext("2d");
  p == null || p.fillRect(0, 0, v.width, v.height), l && p && (p.beginPath(), p.arc(a / 2, u / 2, 50, 0, Math.PI * 2, !0), p.closePath(), p.fillStyle = "grey", p.fill());
  const _ = v.captureStream(), [k] = _.getTracks();
  if (!k)
    throw Error("Could not get empty media stream video track");
  return k.enabled = c, k;
}
let emptyAudioStreamTrack;
function getEmptyAudioStreamTrack() {
  if (!emptyAudioStreamTrack) {
    const a = new AudioContext(), u = a.createOscillator(), c = a.createGain();
    c.gain.setValueAtTime(0, 0);
    const l = a.createMediaStreamDestination();
    if (u.connect(c), c.connect(l), u.start(), [emptyAudioStreamTrack] = l.stream.getAudioTracks(), !emptyAudioStreamTrack)
      throw Error("Could not get empty media stream audio track");
    emptyAudioStreamTrack.enabled = !1;
  }
  return emptyAudioStreamTrack.clone();
}
class Future {
  constructor(u, c) {
    this.onFinally = c, this.promise = new Promise((l, v) => __awaiter$3(this, void 0, void 0, function* () {
      this.resolve = l, this.reject = v, u && (yield u(l, v));
    })).finally(() => {
      var l;
      return (l = this.onFinally) === null || l === void 0 ? void 0 : l.call(this);
    });
  }
}
class Mutex {
  constructor() {
    this._locking = Promise.resolve(), this._locks = 0;
  }
  isLocked() {
    return this._locks > 0;
  }
  lock() {
    this._locks += 1;
    let u;
    const c = new Promise((v) => u = () => {
      this._locks -= 1, v();
    }), l = this._locking.then(() => u);
    return this._locking = this._locking.then(() => c), l;
  }
}
function isVideoCodec(a) {
  return videoCodecs.includes(a);
}
function unwrapConstraint(a) {
  if (typeof a == "string")
    return a;
  if (Array.isArray(a))
    return a[0];
  if (a.exact)
    return Array.isArray(a.exact) ? a.exact[0] : a.exact;
  if (a.ideal)
    return Array.isArray(a.ideal) ? a.ideal[0] : a.ideal;
  throw Error("could not unwrap constraint");
}
function toWebsocketUrl(a) {
  return a.startsWith("http") ? a.replace(/^(http)/, "ws") : a;
}
function toHttpUrl(a) {
  return a.startsWith("ws") ? a.replace(/^(ws)/, "http") : a;
}
const defaultId = "default";
class DeviceManager {
  static getInstance() {
    return this.instance === void 0 && (this.instance = new DeviceManager()), this.instance;
  }
  getDevices(u) {
    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
    var l;
    return __awaiter$3(this, void 0, void 0, function* () {
      if (((l = DeviceManager.userMediaPromiseMap) === null || l === void 0 ? void 0 : l.size) > 0) {
        livekitLogger.debug("awaiting getUserMedia promise");
        try {
          u ? yield DeviceManager.userMediaPromiseMap.get(u) : yield Promise.all(DeviceManager.userMediaPromiseMap.values());
        } catch {
          livekitLogger.warn("error waiting for media permissons");
        }
      }
      let v = yield navigator.mediaDevices.enumerateDevices();
      if (c && // for safari we need to skip this check, as otherwise it will re-acquire user media and fail on iOS https://bugs.webkit.org/show_bug.cgi?id=179363
      !(isSafari() && this.hasDeviceInUse(u)) && (v.length === 0 || v.some((_) => {
        const k = _.label === "", O = u ? _.kind === u : !0;
        return k && O;
      }))) {
        const _ = {
          video: u !== "audioinput" && u !== "audiooutput",
          audio: u !== "videoinput"
        }, k = yield navigator.mediaDevices.getUserMedia(_);
        v = yield navigator.mediaDevices.enumerateDevices(), k.getTracks().forEach((O) => {
          O.stop();
        });
      }
      return u && (v = v.filter((p) => p.kind === u)), v;
    });
  }
  normalizeDeviceId(u, c, l) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (c !== defaultId)
        return c;
      const v = yield this.getDevices(u), p = new Map(v.map((k) => [k.groupId, 0]));
      v.forEach((k) => {
        var O;
        return p.set(k.groupId, ((O = p.get(k.groupId)) !== null && O !== void 0 ? O : 0) + 1);
      });
      const _ = v.find((k) => {
        var O;
        return (l === k.groupId || ((O = p.get(k.groupId)) !== null && O !== void 0 ? O : 0) > 1) && k.deviceId !== defaultId;
      });
      return _ == null ? void 0 : _.deviceId;
    });
  }
  hasDeviceInUse(u) {
    return u ? DeviceManager.userMediaPromiseMap.has(u) : DeviceManager.userMediaPromiseMap.size > 0;
  }
}
DeviceManager.mediaDeviceKinds = ["audioinput", "audiooutput", "videoinput"];
DeviceManager.userMediaPromiseMap = /* @__PURE__ */ new Map();
const defaultDimensionsTimeout = 1e3;
class LocalTrack extends Track {
  get constraints() {
    return this._constraints;
  }
  /**
   *
   * @param mediaTrack
   * @param kind
   * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks
   * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK
   */
  constructor(u, c, l) {
    let v = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1, p = arguments.length > 4 ? arguments[4] : void 0;
    super(u, c, p), this._isUpstreamPaused = !1, this.handleTrackMuteEvent = () => this.debouncedTrackMuteHandler().catch(() => this.log.debug("track mute bounce got cancelled by an unmute event", this.logContext)), this.debouncedTrackMuteHandler = r$1(() => __awaiter$3(this, void 0, void 0, function* () {
      yield this.pauseUpstream();
    }), 5e3), this.handleTrackUnmuteEvent = () => __awaiter$3(this, void 0, void 0, function* () {
      this.debouncedTrackMuteHandler.cancel("unmute"), yield this.resumeUpstream();
    }), this.handleEnded = () => {
      this.isInBackground && (this.reacquireTrack = !0), this._mediaStreamTrack.removeEventListener("mute", this.handleTrackMuteEvent), this._mediaStreamTrack.removeEventListener("unmute", this.handleTrackUnmuteEvent), this.emit(TrackEvent.Ended, this);
    }, this.reacquireTrack = !1, this.providedByUser = v, this.muteLock = new Mutex(), this.pauseUpstreamLock = new Mutex(), this.processorLock = new Mutex(), this.restartLock = new Mutex(), this.setMediaStreamTrack(u, !0), this._constraints = u.getConstraints(), l && (this._constraints = l);
  }
  get id() {
    return this._mediaStreamTrack.id;
  }
  get dimensions() {
    if (this.kind !== Track.Kind.Video)
      return;
    const {
      width: u,
      height: c
    } = this._mediaStreamTrack.getSettings();
    if (u && c)
      return {
        width: u,
        height: c
      };
  }
  get isUpstreamPaused() {
    return this._isUpstreamPaused;
  }
  get isUserProvided() {
    return this.providedByUser;
  }
  get mediaStreamTrack() {
    var u, c;
    return (c = (u = this.processor) === null || u === void 0 ? void 0 : u.processedTrack) !== null && c !== void 0 ? c : this._mediaStreamTrack;
  }
  setMediaStreamTrack(u, c) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (u === this._mediaStreamTrack && !c)
        return;
      this._mediaStreamTrack && (this.attachedElements.forEach((v) => {
        detachTrack(this._mediaStreamTrack, v);
      }), this.debouncedTrackMuteHandler.cancel("new-track"), this._mediaStreamTrack.removeEventListener("ended", this.handleEnded), this._mediaStreamTrack.removeEventListener("mute", this.handleTrackMuteEvent), this._mediaStreamTrack.removeEventListener("unmute", this.handleTrackUnmuteEvent)), this.mediaStream = new MediaStream([u]), u && (u.addEventListener("ended", this.handleEnded), u.addEventListener("mute", this.handleTrackMuteEvent), u.addEventListener("unmute", this.handleTrackUnmuteEvent), this._constraints = u.getConstraints());
      let l;
      if (this.processor && u) {
        const v = yield this.processorLock.lock();
        try {
          if (this.log.debug("restarting processor", this.logContext), this.kind === "unknown")
            throw TypeError("cannot set processor on track of unknown kind");
          this.processorElement && (attachToElement(u, this.processorElement), this.processorElement.muted = !0), yield this.processor.restart({
            track: u,
            kind: this.kind,
            element: this.processorElement
          }), l = this.processor.processedTrack;
        } finally {
          v();
        }
      }
      this.sender && (yield this.sender.replaceTrack(l ?? u)), !this.providedByUser && this._mediaStreamTrack !== u && this._mediaStreamTrack.stop(), this._mediaStreamTrack = u, u && (this._mediaStreamTrack.enabled = !this.isMuted, yield this.resumeUpstream(), this.attachedElements.forEach((v) => {
        attachToElement(l ?? u, v);
      }));
    });
  }
  waitForDimensions() {
    let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : defaultDimensionsTimeout;
    var c;
    return __awaiter$3(this, void 0, void 0, function* () {
      if (this.kind === Track.Kind.Audio)
        throw new Error("cannot get dimensions for audio tracks");
      ((c = getBrowser()) === null || c === void 0 ? void 0 : c.os) === "iOS" && (yield sleep(10));
      const l = Date.now();
      for (; Date.now() - l < u; ) {
        const v = this.dimensions;
        if (v)
          return v;
        yield sleep(50);
      }
      throw new TrackInvalidError("unable to get track dimensions after timeout");
    });
  }
  /**
   * @returns DeviceID of the device that is currently being used for this track
   */
  getDeviceId() {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (this.source === Track.Source.ScreenShare)
        return;
      const {
        deviceId: u,
        groupId: c
      } = this._mediaStreamTrack.getSettings(), l = this.kind === Track.Kind.Audio ? "audioinput" : "videoinput";
      return DeviceManager.getInstance().normalizeDeviceId(l, u, c);
    });
  }
  mute() {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this.setTrackMuted(!0), this;
    });
  }
  unmute() {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this.setTrackMuted(!1), this;
    });
  }
  replaceTrack(u, c) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!this.sender)
        throw new TrackInvalidError("unable to replace an unpublished track");
      let l, v;
      return typeof c == "boolean" ? l = c : c !== void 0 && (l = c.userProvidedTrack, v = c.stopProcessor), this.providedByUser = l ?? !0, this.log.debug("replace MediaStreamTrack", this.logContext), yield this.setMediaStreamTrack(u), v && this.processor && (yield this.stopProcessor()), this;
    });
  }
  restart(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      const c = yield this.restartLock.lock();
      try {
        u || (u = this._constraints), this.log.debug("restarting track with constraints", Object.assign(Object.assign({}, this.logContext), {
          constraints: u
        }));
        const l = {
          audio: !1,
          video: !1
        };
        this.kind === Track.Kind.Video ? l.video = u : l.audio = u, this.attachedElements.forEach((_) => {
          detachTrack(this.mediaStreamTrack, _);
        }), this._mediaStreamTrack.removeEventListener("ended", this.handleEnded), this._mediaStreamTrack.stop();
        const p = (yield navigator.mediaDevices.getUserMedia(l)).getTracks()[0];
        return p.addEventListener("ended", this.handleEnded), this.log.debug("re-acquired MediaStreamTrack", this.logContext), yield this.setMediaStreamTrack(p), this._constraints = u, this.emit(TrackEvent.Restarted, this), this;
      } finally {
        c();
      }
    });
  }
  setTrackMuted(u) {
    this.log.debug("setting ".concat(this.kind, " track ").concat(u ? "muted" : "unmuted"), this.logContext), !(this.isMuted === u && this._mediaStreamTrack.enabled !== u) && (this.isMuted = u, this._mediaStreamTrack.enabled = !u, this.emit(u ? TrackEvent.Muted : TrackEvent.Unmuted, this));
  }
  get needsReAcquisition() {
    return this._mediaStreamTrack.readyState !== "live" || this._mediaStreamTrack.muted || !this._mediaStreamTrack.enabled || this.reacquireTrack;
  }
  handleAppVisibilityChanged() {
    const u = Object.create(null, {
      handleAppVisibilityChanged: {
        get: () => super.handleAppVisibilityChanged
      }
    });
    return __awaiter$3(this, void 0, void 0, function* () {
      yield u.handleAppVisibilityChanged.call(this), isMobile() && (this.log.debug("visibility changed, is in Background: ".concat(this.isInBackground), this.logContext), !this.isInBackground && this.needsReAcquisition && !this.isUserProvided && !this.isMuted && (this.log.debug("track needs to be reacquired, restarting ".concat(this.source), this.logContext), yield this.restart(), this.reacquireTrack = !1));
    });
  }
  stop() {
    var u;
    super.stop(), this._mediaStreamTrack.removeEventListener("ended", this.handleEnded), this._mediaStreamTrack.removeEventListener("mute", this.handleTrackMuteEvent), this._mediaStreamTrack.removeEventListener("unmute", this.handleTrackUnmuteEvent), (u = this.processor) === null || u === void 0 || u.destroy(), this.processor = void 0;
  }
  /**
   * pauses publishing to the server without disabling the local MediaStreamTrack
   * this is used to display a user's own video locally while pausing publishing to
   * the server.
   * this API is unsupported on Safari < 12 due to a bug
   **/
  pauseUpstream() {
    return __awaiter$3(this, void 0, void 0, function* () {
      const u = yield this.pauseUpstreamLock.lock();
      try {
        if (this._isUpstreamPaused === !0)
          return;
        if (!this.sender) {
          this.log.warn("unable to pause upstream for an unpublished track", this.logContext);
          return;
        }
        this._isUpstreamPaused = !0, this.emit(TrackEvent.UpstreamPaused, this);
        const c = getBrowser();
        if ((c == null ? void 0 : c.name) === "Safari" && compareVersions(c.version, "12.0") < 0)
          throw new DeviceUnsupportedError("pauseUpstream is not supported on Safari < 12.");
        yield this.sender.replaceTrack(null);
      } finally {
        u();
      }
    });
  }
  resumeUpstream() {
    return __awaiter$3(this, void 0, void 0, function* () {
      const u = yield this.pauseUpstreamLock.lock();
      try {
        if (this._isUpstreamPaused === !1)
          return;
        if (!this.sender) {
          this.log.warn("unable to resume upstream for an unpublished track", this.logContext);
          return;
        }
        this._isUpstreamPaused = !1, this.emit(TrackEvent.UpstreamResumed, this), yield this.sender.replaceTrack(this._mediaStreamTrack);
      } finally {
        u();
      }
    });
  }
  /**
   * Gets the RTCStatsReport for the LocalTrack's underlying RTCRtpSender
   * See https://developer.mozilla.org/en-US/docs/Web/API/RTCStatsReport
   *
   * @returns Promise<RTCStatsReport> | undefined
   */
  getRTCStatsReport() {
    var u;
    return __awaiter$3(this, void 0, void 0, function* () {
      return !((u = this.sender) === null || u === void 0) && u.getStats ? yield this.sender.getStats() : void 0;
    });
  }
  /**
   * Sets a processor on this track.
   * See https://github.com/livekit/track-processors-js for example usage
   *
   * @experimental
   *
   * @param processor
   * @param showProcessedStreamLocally
   * @returns
   */
  setProcessor(u) {
    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
    var l, v;
    return __awaiter$3(this, void 0, void 0, function* () {
      const p = yield this.processorLock.lock();
      try {
        this.log.debug("setting up processor", this.logContext), this.processorElement = (l = this.processorElement) !== null && l !== void 0 ? l : document.createElement(this.kind);
        const _ = {
          kind: this.kind,
          track: this._mediaStreamTrack,
          element: this.processorElement,
          audioContext: this.audioContext
        };
        if (yield u.init(_), this.processor && (yield this.stopProcessor()), this.kind === "unknown")
          throw TypeError("cannot set processor on track of unknown kind");
        if (attachToElement(this._mediaStreamTrack, this.processorElement), this.processorElement.muted = !0, this.processorElement.play().catch((k) => this.log.error("failed to play processor element", Object.assign(Object.assign({}, this.logContext), {
          error: k
        }))), this.processor = u, this.processor.processedTrack) {
          for (const k of this.attachedElements)
            k !== this.processorElement && c && (detachTrack(this._mediaStreamTrack, k), attachToElement(this.processor.processedTrack, k));
          yield (v = this.sender) === null || v === void 0 ? void 0 : v.replaceTrack(this.processor.processedTrack);
        }
        this.emit(TrackEvent.TrackProcessorUpdate, this.processor);
      } finally {
        p();
      }
    });
  }
  getProcessor() {
    return this.processor;
  }
  /**
   * Stops the track processor
   * See https://github.com/livekit/track-processors-js for example usage
   *
   * @experimental
   * @returns
   */
  stopProcessor() {
    var u, c;
    return __awaiter$3(this, void 0, void 0, function* () {
      this.processor && (this.log.debug("stopping processor", this.logContext), (u = this.processor.processedTrack) === null || u === void 0 || u.stop(), yield this.processor.destroy(), this.processor = void 0, (c = this.processorElement) === null || c === void 0 || c.remove(), this.processorElement = void 0, yield this._mediaStreamTrack.applyConstraints(this._constraints), yield this.setMediaStreamTrack(this._mediaStreamTrack, !0), this.emit(TrackEvent.TrackProcessorUpdate));
    });
  }
}
class E2EEManager extends eventsExports$1.EventEmitter {
  constructor(u) {
    super(), this.onWorkerMessage = (c) => {
      var l, v;
      const {
        kind: p,
        data: _
      } = c.data;
      switch (p) {
        case "error":
          livekitLogger.error(_.error.message), this.emit(EncryptionEvent.EncryptionError, _.error);
          break;
        case "initAck":
          _.enabled && this.keyProvider.getKeys().forEach((k) => {
            this.postKey(k);
          });
          break;
        case "enable":
          if (this.encryptionEnabled !== _.enabled && _.participantIdentity === ((l = this.room) === null || l === void 0 ? void 0 : l.localParticipant.identity))
            this.emit(EncryptionEvent.ParticipantEncryptionStatusChanged, _.enabled, this.room.localParticipant), this.encryptionEnabled = _.enabled;
          else if (_.participantIdentity) {
            const k = (v = this.room) === null || v === void 0 ? void 0 : v.getParticipantByIdentity(_.participantIdentity);
            if (!k)
              throw TypeError("couldn't set encryption status, participant not found".concat(_.participantIdentity));
            this.emit(EncryptionEvent.ParticipantEncryptionStatusChanged, _.enabled, k);
          }
          this.encryptionEnabled && this.keyProvider.getKeys().forEach((k) => {
            this.postKey(k);
          });
          break;
        case "ratchetKey":
          this.keyProvider.emit(KeyProviderEvent.KeyRatcheted, _.material, _.keyIndex);
          break;
      }
    }, this.onWorkerError = (c) => {
      livekitLogger.error("e2ee worker encountered an error:", {
        error: c.error
      }), this.emit(EncryptionEvent.EncryptionError, c.error);
    }, this.keyProvider = u.keyProvider, this.worker = u.worker, this.encryptionEnabled = !1;
  }
  /**
   * @internal
   */
  setup(u) {
    if (!isE2EESupported())
      throw new DeviceUnsupportedError("tried to setup end-to-end encryption on an unsupported browser");
    if (livekitLogger.info("setting up e2ee"), u !== this.room) {
      this.room = u, this.setupEventListeners(u, this.keyProvider);
      const c = {
        kind: "init",
        data: {
          keyProviderOptions: this.keyProvider.getOptions(),
          loglevel: workerLogger.getLevel()
        }
      };
      this.worker && (livekitLogger.info("initializing worker", {
        worker: this.worker
      }), this.worker.onmessage = this.onWorkerMessage, this.worker.onerror = this.onWorkerError, this.worker.postMessage(c));
    }
  }
  /**
   * @internal
   */
  setParticipantCryptorEnabled(u, c) {
    livekitLogger.debug("set e2ee to ".concat(u, " for participant ").concat(c)), this.postEnable(u, c);
  }
  /**
   * @internal
   */
  setSifTrailer(u) {
    !u || u.length === 0 ? livekitLogger.warn("ignoring server sent trailer as it's empty") : this.postSifTrailer(u);
  }
  setupEngine(u) {
    u.on(EngineEvent.RTPVideoMapUpdate, (c) => {
      this.postRTPMap(c);
    });
  }
  setupEventListeners(u, c) {
    u.on(RoomEvent.TrackPublished, (l, v) => this.setParticipantCryptorEnabled(l.trackInfo.encryption !== Encryption_Type.NONE, v.identity)), u.on(RoomEvent.ConnectionStateChanged, (l) => {
      l === ConnectionState.Connected && u.remoteParticipants.forEach((v) => {
        v.trackPublications.forEach((p) => {
          this.setParticipantCryptorEnabled(p.trackInfo.encryption !== Encryption_Type.NONE, v.identity);
        });
      });
    }).on(RoomEvent.TrackUnsubscribed, (l, v, p) => {
      var _;
      const k = {
        kind: "removeTransform",
        data: {
          participantIdentity: p.identity,
          trackId: l.mediaStreamID
        }
      };
      (_ = this.worker) === null || _ === void 0 || _.postMessage(k);
    }).on(RoomEvent.TrackSubscribed, (l, v, p) => {
      this.setupE2EEReceiver(l, p.identity, v.trackInfo);
    }).on(RoomEvent.SignalConnected, () => {
      if (!this.room)
        throw new TypeError("expected room to be present on signal connect");
      this.setParticipantCryptorEnabled(this.room.localParticipant.isE2EEEnabled, this.room.localParticipant.identity), c.getKeys().forEach((l) => {
        this.postKey(l);
      });
    }), u.localParticipant.on(ParticipantEvent.LocalTrackPublished, (l) => __awaiter$3(this, void 0, void 0, function* () {
      this.setupE2EESender(l.track, l.track.sender);
    })), c.on(KeyProviderEvent.SetKey, (l) => this.postKey(l)).on(KeyProviderEvent.RatchetRequest, (l, v) => this.postRatchetRequest(l, v));
  }
  postRatchetRequest(u, c) {
    if (!this.worker)
      throw Error("could not ratchet key, worker is missing");
    const l = {
      kind: "ratchetRequest",
      data: {
        participantIdentity: u,
        keyIndex: c
      }
    };
    this.worker.postMessage(l);
  }
  postKey(u) {
    let {
      key: c,
      participantIdentity: l,
      keyIndex: v
    } = u;
    var p;
    if (!this.worker)
      throw Error("could not set key, worker is missing");
    const _ = {
      kind: "setKey",
      data: {
        participantIdentity: l,
        isPublisher: l === ((p = this.room) === null || p === void 0 ? void 0 : p.localParticipant.identity),
        key: c,
        keyIndex: v
      }
    };
    this.worker.postMessage(_);
  }
  postEnable(u, c) {
    if (this.worker) {
      const l = {
        kind: "enable",
        data: {
          enabled: u,
          participantIdentity: c
        }
      };
      this.worker.postMessage(l);
    } else
      throw new ReferenceError("failed to enable e2ee, worker is not ready");
  }
  postRTPMap(u) {
    var c;
    if (!this.worker)
      throw TypeError("could not post rtp map, worker is missing");
    if (!(!((c = this.room) === null || c === void 0) && c.localParticipant.identity))
      throw TypeError("could not post rtp map, local participant identity is missing");
    const l = {
      kind: "setRTPMap",
      data: {
        map: u,
        participantIdentity: this.room.localParticipant.identity
      }
    };
    this.worker.postMessage(l);
  }
  postSifTrailer(u) {
    if (!this.worker)
      throw Error("could not post SIF trailer, worker is missing");
    const c = {
      kind: "setSifTrailer",
      data: {
        trailer: u
      }
    };
    this.worker.postMessage(c);
  }
  setupE2EEReceiver(u, c, l) {
    if (u.receiver) {
      if (!(l != null && l.mimeType) || l.mimeType === "")
        throw new TypeError("MimeType missing from trackInfo, cannot set up E2EE cryptor");
      this.handleReceiver(u.receiver, u.mediaStreamID, c, u.kind === "video" ? mimeTypeToVideoCodecString(l.mimeType) : void 0);
    }
  }
  setupE2EESender(u, c) {
    if (!(u instanceof LocalTrack) || !c) {
      c || livekitLogger.warn("early return because sender is not ready");
      return;
    }
    this.handleSender(c, u.mediaStreamID, void 0);
  }
  /**
   * Handles the given {@code RTCRtpReceiver} by creating a {@code TransformStream} which will inject
   * a frame decoder.
   *
   */
  handleReceiver(u, c, l, v) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (this.worker) {
        if (isScriptTransformSupported()) {
          const p = {
            kind: "decode",
            participantIdentity: l,
            trackId: c,
            codec: v
          };
          u.transform = new RTCRtpScriptTransform(this.worker, p);
        } else {
          if (E2EE_FLAG in u && v) {
            const O = {
              kind: "updateCodec",
              data: {
                trackId: c,
                codec: v,
                participantIdentity: l
              }
            };
            this.worker.postMessage(O);
            return;
          }
          let p = u.writableStream, _ = u.readableStream;
          if (!p || !_) {
            const O = u.createEncodedStreams();
            u.writableStream = O.writable, p = O.writable, u.readableStream = O.readable, _ = O.readable;
          }
          const k = {
            kind: "decode",
            data: {
              readableStream: _,
              writableStream: p,
              trackId: c,
              codec: v,
              participantIdentity: l
            }
          };
          this.worker.postMessage(k, [_, p]);
        }
        u[E2EE_FLAG] = !0;
      }
    });
  }
  /**
   * Handles the given {@code RTCRtpSender} by creating a {@code TransformStream} which will inject
   * a frame encoder.
   *
   */
  handleSender(u, c, l) {
    var v;
    if (!(E2EE_FLAG in u || !this.worker)) {
      if (!(!((v = this.room) === null || v === void 0) && v.localParticipant.identity) || this.room.localParticipant.identity === "")
        throw TypeError("local identity needs to be known in order to set up encrypted sender");
      if (isScriptTransformSupported()) {
        livekitLogger.info("initialize script transform");
        const p = {
          kind: "encode",
          participantIdentity: this.room.localParticipant.identity,
          trackId: c,
          codec: l
        };
        u.transform = new RTCRtpScriptTransform(this.worker, p);
      } else {
        livekitLogger.info("initialize encoded streams");
        const p = u.createEncodedStreams(), _ = {
          kind: "encode",
          data: {
            readableStream: p.readable,
            writableStream: p.writable,
            codec: l,
            trackId: c,
            participantIdentity: this.room.localParticipant.identity
          }
        };
        this.worker.postMessage(_, [p.readable, p.writable]);
      }
      u[E2EE_FLAG] = !0;
    }
  }
}
var QueueTaskStatus;
(function(a) {
  a[a.WAITING = 0] = "WAITING", a[a.RUNNING = 1] = "RUNNING", a[a.COMPLETED = 2] = "COMPLETED";
})(QueueTaskStatus || (QueueTaskStatus = {}));
class AsyncQueue {
  constructor() {
    this.pendingTasks = /* @__PURE__ */ new Map(), this.taskMutex = new Mutex(), this.nextTaskIndex = 0;
  }
  run(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      const c = {
        id: this.nextTaskIndex++,
        enqueuedAt: Date.now(),
        status: QueueTaskStatus.WAITING
      };
      this.pendingTasks.set(c.id, c);
      const l = yield this.taskMutex.lock();
      try {
        return c.executedAt = Date.now(), c.status = QueueTaskStatus.RUNNING, yield u();
      } finally {
        c.status = QueueTaskStatus.COMPLETED, this.pendingTasks.delete(c.id), l();
      }
    });
  }
  flush() {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this.run(() => __awaiter$3(this, void 0, void 0, function* () {
      }));
    });
  }
  snapshot() {
    return Array.from(this.pendingTasks.values());
  }
}
const passThroughQueueSignals = ["syncState", "trickle", "offer", "answer", "simulate", "leave"];
function canPassThroughQueue(a) {
  const u = passThroughQueueSignals.indexOf(a.case) >= 0;
  return livekitLogger.trace("request allowed to bypass queue:", {
    canPass: u,
    req: a
  }), u;
}
var SignalConnectionState;
(function(a) {
  a[a.CONNECTING = 0] = "CONNECTING", a[a.CONNECTED = 1] = "CONNECTED", a[a.RECONNECTING = 2] = "RECONNECTING", a[a.DISCONNECTING = 3] = "DISCONNECTING", a[a.DISCONNECTED = 4] = "DISCONNECTED";
})(SignalConnectionState || (SignalConnectionState = {}));
class SignalClient {
  get currentState() {
    return this.state;
  }
  get isDisconnected() {
    return this.state === SignalConnectionState.DISCONNECTING || this.state === SignalConnectionState.DISCONNECTED;
  }
  get isEstablishingConnection() {
    return this.state === SignalConnectionState.CONNECTING || this.state === SignalConnectionState.RECONNECTING;
  }
  constructor() {
    let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1, c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var l;
    this.rtt = 0, this.state = SignalConnectionState.DISCONNECTED, this.log = livekitLogger, this.resetCallbacks = () => {
      this.onAnswer = void 0, this.onLeave = void 0, this.onLocalTrackPublished = void 0, this.onLocalTrackUnpublished = void 0, this.onNegotiateRequested = void 0, this.onOffer = void 0, this.onRemoteMuteChanged = void 0, this.onSubscribedQualityUpdate = void 0, this.onTokenRefresh = void 0, this.onTrickle = void 0, this.onClose = void 0;
    }, this.log = getLogger((l = c.loggerName) !== null && l !== void 0 ? l : LoggerNames.Signal), this.loggerContextCb = c.loggerContextCb, this.useJSON = u, this.requestQueue = new AsyncQueue(), this.queuedRequests = [], this.closingLock = new Mutex(), this.connectionLock = new Mutex(), this.state = SignalConnectionState.DISCONNECTED;
  }
  get logContext() {
    var u, c;
    return (c = (u = this.loggerContextCb) === null || u === void 0 ? void 0 : u.call(this)) !== null && c !== void 0 ? c : {};
  }
  join(u, c, l, v) {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this.state = SignalConnectionState.CONNECTING, this.options = l, yield this.connect(u, c, l, v);
    });
  }
  reconnect(u, c, l, v) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!this.options) {
        this.log.warn("attempted to reconnect without signal options being set, ignoring", this.logContext);
        return;
      }
      return this.state = SignalConnectionState.RECONNECTING, this.clearPingInterval(), yield this.connect(u, c, Object.assign(Object.assign({}, this.options), {
        reconnect: !0,
        sid: l,
        reconnectReason: v
      }));
    });
  }
  connect(u, c, l, v) {
    this.connectOptions = l, u = toWebsocketUrl(u), u = u.replace(/\/$/, ""), u += "/rtc";
    const p = getClientInfo(), _ = createConnectionParams(c, p, l);
    return new Promise((k, O) => __awaiter$3(this, void 0, void 0, function* () {
      const D = yield this.connectionLock.lock();
      try {
        const F = () => __awaiter$3(this, void 0, void 0, function* () {
          this.close(), clearTimeout(z), O(new ConnectionError("room connection has been cancelled (signal)"));
        }), z = setTimeout(() => {
          this.close(), O(new ConnectionError("room connection has timed out (signal)"));
        }, l.websocketTimeout);
        v != null && v.aborted && F(), v == null || v.addEventListener("abort", F), this.log.debug("connecting to ".concat(u + _), this.logContext), this.ws && (yield this.close(!1)), this.ws = new WebSocket(u + _), this.ws.binaryType = "arraybuffer", this.ws.onopen = () => {
          clearTimeout(z);
        }, this.ws.onerror = (j) => __awaiter$3(this, void 0, void 0, function* () {
          if (this.state !== SignalConnectionState.CONNECTED) {
            this.state = SignalConnectionState.DISCONNECTED, clearTimeout(z);
            try {
              const ee = yield fetch("http".concat(u.substring(2), "/validate").concat(_));
              if (ee.status.toFixed(0).startsWith("4")) {
                const X = yield ee.text();
                O(new ConnectionError(X, 0, ee.status));
              } else
                O(new ConnectionError("Internal error", 2, ee.status));
            } catch {
              O(new ConnectionError(
                "server was not reachable",
                1
                /* ConnectionErrorReason.ServerUnreachable */
              ));
            }
            return;
          }
          this.handleWSError(j);
        }), this.ws.onmessage = (j) => __awaiter$3(this, void 0, void 0, function* () {
          var ee, X, ae;
          let Q;
          if (typeof j.data == "string") {
            const ne = JSON.parse(j.data);
            Q = SignalResponse.fromJson(ne, {
              ignoreUnknownFields: !0
            });
          } else if (j.data instanceof ArrayBuffer)
            Q = SignalResponse.fromBinary(new Uint8Array(j.data));
          else {
            this.log.error("could not decode websocket message: ".concat(typeof j.data), this.logContext);
            return;
          }
          if (this.state !== SignalConnectionState.CONNECTED) {
            let ne = !1;
            if (((ee = Q.message) === null || ee === void 0 ? void 0 : ee.case) === "join" ? (this.state = SignalConnectionState.CONNECTED, v == null || v.removeEventListener("abort", F), this.pingTimeoutDuration = Q.message.value.pingTimeout, this.pingIntervalDuration = Q.message.value.pingInterval, this.pingTimeoutDuration && this.pingTimeoutDuration > 0 && (this.log.debug("ping config", Object.assign(Object.assign({}, this.logContext), {
              timeout: this.pingTimeoutDuration,
              interval: this.pingIntervalDuration
            })), this.startPingInterval()), k(Q.message.value)) : this.state === SignalConnectionState.RECONNECTING && Q.message.case !== "leave" ? (this.state = SignalConnectionState.CONNECTED, v == null || v.removeEventListener("abort", F), this.startPingInterval(), ((X = Q.message) === null || X === void 0 ? void 0 : X.case) === "reconnect" ? k(Q.message.value) : (this.log.debug("declaring signal reconnected without reconnect response received", this.logContext), k(void 0), ne = !0)) : this.isEstablishingConnection && Q.message.case === "leave" ? O(new ConnectionError(
              "Received leave request while trying to (re)connect",
              4
              /* ConnectionErrorReason.LeaveRequest */
            )) : l.reconnect || O(new ConnectionError("did not receive join response, got ".concat((ae = Q.message) === null || ae === void 0 ? void 0 : ae.case, " instead"))), !ne)
              return;
          }
          this.signalLatency && (yield sleep(this.signalLatency)), this.handleSignalResponse(Q);
        }), this.ws.onclose = (j) => {
          this.isEstablishingConnection && O(new ConnectionError("Websocket got closed during a (re)connection attempt")), this.log.warn("websocket closed", Object.assign(Object.assign({}, this.logContext), {
            reason: j.reason,
            code: j.code,
            wasClean: j.wasClean,
            state: this.state
          })), this.handleOnClose(j.reason);
        };
      } finally {
        D();
      }
    }));
  }
  close() {
    let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
    return __awaiter$3(this, void 0, void 0, function* () {
      const c = yield this.closingLock.lock();
      try {
        if (u && (this.state = SignalConnectionState.DISCONNECTING), this.ws) {
          this.ws.onmessage = null, this.ws.onopen = null, this.ws.onclose = null;
          const l = new Promise((v) => {
            this.ws ? this.ws.onclose = () => {
              v();
            } : v();
          });
          this.ws.readyState < this.ws.CLOSING && (this.ws.close(), yield Promise.race([l, sleep(250)])), this.ws = void 0;
        }
      } finally {
        u && (this.state = SignalConnectionState.DISCONNECTED), this.clearPingInterval(), c();
      }
    });
  }
  // initial offer after joining
  sendOffer(u) {
    this.log.debug("sending offer", Object.assign(Object.assign({}, this.logContext), {
      offerSdp: u.sdp
    })), this.sendRequest({
      case: "offer",
      value: toProtoSessionDescription(u)
    });
  }
  // answer a server-initiated offer
  sendAnswer(u) {
    return this.log.debug("sending answer", Object.assign(Object.assign({}, this.logContext), {
      answerSdp: u.sdp
    })), this.sendRequest({
      case: "answer",
      value: toProtoSessionDescription(u)
    });
  }
  sendIceCandidate(u, c) {
    return this.log.trace("sending ice candidate", Object.assign(Object.assign({}, this.logContext), {
      candidate: u
    })), this.sendRequest({
      case: "trickle",
      value: new TrickleRequest({
        candidateInit: JSON.stringify(u),
        target: c
      })
    });
  }
  sendMuteTrack(u, c) {
    return this.sendRequest({
      case: "mute",
      value: new MuteTrackRequest({
        sid: u,
        muted: c
      })
    });
  }
  sendAddTrack(u) {
    return this.sendRequest({
      case: "addTrack",
      value: u
    });
  }
  sendUpdateLocalMetadata(u, c) {
    return this.sendRequest({
      case: "updateMetadata",
      value: new UpdateParticipantMetadata({
        metadata: u,
        name: c
      })
    });
  }
  sendUpdateTrackSettings(u) {
    this.sendRequest({
      case: "trackSetting",
      value: u
    });
  }
  sendUpdateSubscription(u) {
    return this.sendRequest({
      case: "subscription",
      value: u
    });
  }
  sendSyncState(u) {
    return this.sendRequest({
      case: "syncState",
      value: u
    });
  }
  sendUpdateVideoLayers(u, c) {
    return this.sendRequest({
      case: "updateLayers",
      value: new UpdateVideoLayers({
        trackSid: u,
        layers: c
      })
    });
  }
  sendUpdateSubscriptionPermissions(u, c) {
    return this.sendRequest({
      case: "subscriptionPermission",
      value: new SubscriptionPermission({
        allParticipants: u,
        trackPermissions: c
      })
    });
  }
  sendSimulateScenario(u) {
    return this.sendRequest({
      case: "simulate",
      value: u
    });
  }
  sendPing() {
    return Promise.all([this.sendRequest({
      case: "ping",
      value: protoInt64.parse(Date.now())
    }), this.sendRequest({
      case: "pingReq",
      value: new Ping({
        timestamp: protoInt64.parse(Date.now()),
        rtt: protoInt64.parse(this.rtt)
      })
    })]);
  }
  sendLeave() {
    return this.sendRequest({
      case: "leave",
      value: new LeaveRequest({
        canReconnect: !1,
        reason: DisconnectReason.CLIENT_INITIATED
      })
    });
  }
  sendRequest(u) {
    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!c && !canPassThroughQueue(u) && this.state === SignalConnectionState.RECONNECTING) {
        this.queuedRequests.push(() => __awaiter$3(this, void 0, void 0, function* () {
          yield this.sendRequest(u, !0);
        }));
        return;
      }
      if (c || (yield this.requestQueue.flush()), this.signalLatency && (yield sleep(this.signalLatency)), !this.ws || this.ws.readyState !== this.ws.OPEN) {
        this.log.error("cannot send signal request before connected, type: ".concat(u == null ? void 0 : u.case), this.logContext);
        return;
      }
      const v = new SignalRequest({
        message: u
      });
      try {
        this.useJSON ? this.ws.send(v.toJsonString()) : this.ws.send(v.toBinary());
      } catch (p) {
        this.log.error("error sending signal message", Object.assign(Object.assign({}, this.logContext), {
          error: p
        }));
      }
    });
  }
  handleSignalResponse(u) {
    var c, l;
    const v = u.message;
    if (v == null) {
      this.log.debug("received unsupported message", this.logContext);
      return;
    }
    let p = !1;
    if (v.case === "answer") {
      const _ = fromProtoSessionDescription(v.value);
      this.onAnswer && this.onAnswer(_);
    } else if (v.case === "offer") {
      const _ = fromProtoSessionDescription(v.value);
      this.onOffer && this.onOffer(_);
    } else if (v.case === "trickle") {
      const _ = JSON.parse(v.value.candidateInit);
      this.onTrickle && this.onTrickle(_, v.value.target);
    } else
      v.case === "update" ? this.onParticipantUpdate && this.onParticipantUpdate((c = v.value.participants) !== null && c !== void 0 ? c : []) : v.case === "trackPublished" ? this.onLocalTrackPublished && this.onLocalTrackPublished(v.value) : v.case === "speakersChanged" ? this.onSpeakersChanged && this.onSpeakersChanged((l = v.value.speakers) !== null && l !== void 0 ? l : []) : v.case === "leave" ? this.onLeave && this.onLeave(v.value) : v.case === "mute" ? this.onRemoteMuteChanged && this.onRemoteMuteChanged(v.value.sid, v.value.muted) : v.case === "roomUpdate" ? this.onRoomUpdate && v.value.room && this.onRoomUpdate(v.value.room) : v.case === "connectionQuality" ? this.onConnectionQuality && this.onConnectionQuality(v.value) : v.case === "streamStateUpdate" ? this.onStreamStateUpdate && this.onStreamStateUpdate(v.value) : v.case === "subscribedQualityUpdate" ? this.onSubscribedQualityUpdate && this.onSubscribedQualityUpdate(v.value) : v.case === "subscriptionPermissionUpdate" ? this.onSubscriptionPermissionUpdate && this.onSubscriptionPermissionUpdate(v.value) : v.case === "refreshToken" ? this.onTokenRefresh && this.onTokenRefresh(v.value) : v.case === "trackUnpublished" ? this.onLocalTrackUnpublished && this.onLocalTrackUnpublished(v.value) : v.case === "subscriptionResponse" ? this.onSubscriptionError && this.onSubscriptionError(v.value) : v.case === "pong" || (v.case === "pongResp" ? (this.rtt = Date.now() - Number.parseInt(v.value.lastPingTimestamp.toString()), this.resetPingTimeout(), p = !0) : this.log.debug("unsupported message", Object.assign(Object.assign({}, this.logContext), {
        msgCase: v.case
      })));
    p || this.resetPingTimeout();
  }
  setReconnected() {
    for (; this.queuedRequests.length > 0; ) {
      const u = this.queuedRequests.shift();
      u && this.requestQueue.run(u);
    }
  }
  handleOnClose(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (this.state === SignalConnectionState.DISCONNECTED)
        return;
      const c = this.onClose;
      yield this.close(), this.log.debug("websocket connection closed: ".concat(u), Object.assign(Object.assign({}, this.logContext), {
        reason: u
      })), c && c(u);
    });
  }
  handleWSError(u) {
    this.log.error("websocket error", Object.assign(Object.assign({}, this.logContext), {
      error: u
    }));
  }
  /**
   * Resets the ping timeout and starts a new timeout.
   * Call this after receiving a pong message
   */
  resetPingTimeout() {
    if (this.clearPingTimeout(), !this.pingTimeoutDuration) {
      this.log.warn("ping timeout duration not set", this.logContext);
      return;
    }
    this.pingTimeout = CriticalTimers.setTimeout(() => {
      this.log.warn("ping timeout triggered. last pong received at: ".concat(new Date(Date.now() - this.pingTimeoutDuration * 1e3).toUTCString()), this.logContext), this.handleOnClose("ping timeout");
    }, this.pingTimeoutDuration * 1e3);
  }
  /**
   * Clears ping timeout (does not start a new timeout)
   */
  clearPingTimeout() {
    this.pingTimeout && CriticalTimers.clearTimeout(this.pingTimeout);
  }
  startPingInterval() {
    if (this.clearPingInterval(), this.resetPingTimeout(), !this.pingIntervalDuration) {
      this.log.warn("ping interval duration not set", this.logContext);
      return;
    }
    this.log.debug("start ping interval", this.logContext), this.pingInterval = CriticalTimers.setInterval(() => {
      this.sendPing();
    }, this.pingIntervalDuration * 1e3);
  }
  clearPingInterval() {
    this.log.debug("clearing ping interval", this.logContext), this.clearPingTimeout(), this.pingInterval && CriticalTimers.clearInterval(this.pingInterval);
  }
}
function fromProtoSessionDescription(a) {
  const u = {
    type: "offer",
    sdp: a.sdp
  };
  switch (a.type) {
    case "answer":
    case "offer":
    case "pranswer":
    case "rollback":
      u.type = a.type;
      break;
  }
  return u;
}
function toProtoSessionDescription(a) {
  return new SessionDescription({
    sdp: a.sdp,
    type: a.type
  });
}
function createConnectionParams(a, u, c) {
  var l;
  const v = new URLSearchParams();
  return v.set("access_token", a), c.reconnect && (v.set("reconnect", "1"), c.sid && v.set("sid", c.sid)), v.set("auto_subscribe", c.autoSubscribe ? "1" : "0"), v.set("sdk", isReactNative() ? "reactnative" : "js"), v.set("version", u.version), v.set("protocol", u.protocol.toString()), u.deviceModel && v.set("device_model", u.deviceModel), u.os && v.set("os", u.os), u.osVersion && v.set("os_version", u.osVersion), u.browser && v.set("browser", u.browser), u.browserVersion && v.set("browser_version", u.browserVersion), c.adaptiveStream && v.set("adaptive_stream", "1"), c.reconnectReason && v.set("reconnect_reason", c.reconnectReason.toString()), !((l = navigator.connection) === null || l === void 0) && l.type && v.set("network", navigator.connection.type), "?".concat(v.toString());
}
var parser$1 = {}, grammar$2 = { exports: {} }, grammar$1 = grammar$2.exports = {
  v: [{
    name: "version",
    reg: /^(\d*)$/
  }],
  o: [{
    // o=- 20518 0 IN IP4 203.0.113.1
    // NB: sessionId will be a String in most cases because it is huge
    name: "origin",
    reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,
    names: ["username", "sessionId", "sessionVersion", "netType", "ipVer", "address"],
    format: "%s %s %d %s IP%d %s"
  }],
  // default parsing of these only (though some of these feel outdated)
  s: [{
    name: "name"
  }],
  i: [{
    name: "description"
  }],
  u: [{
    name: "uri"
  }],
  e: [{
    name: "email"
  }],
  p: [{
    name: "phone"
  }],
  z: [{
    name: "timezones"
  }],
  // TODO: this one can actually be parsed properly...
  r: [{
    name: "repeats"
  }],
  // TODO: this one can also be parsed properly
  // k: [{}], // outdated thing ignored
  t: [{
    // t=0 0
    name: "timing",
    reg: /^(\d*) (\d*)/,
    names: ["start", "stop"],
    format: "%d %d"
  }],
  c: [{
    // c=IN IP4 10.47.197.26
    name: "connection",
    reg: /^IN IP(\d) (\S*)/,
    names: ["version", "ip"],
    format: "IN IP%d %s"
  }],
  b: [{
    // b=AS:4000
    push: "bandwidth",
    reg: /^(TIAS|AS|CT|RR|RS):(\d*)/,
    names: ["type", "limit"],
    format: "%s:%s"
  }],
  m: [{
    // m=video 51744 RTP/AVP 126 97 98 34 31
    // NB: special - pushes to session
    // TODO: rtp/fmtp should be filtered by the payloads found here?
    reg: /^(\w*) (\d*) ([\w/]*)(?: (.*))?/,
    names: ["type", "port", "protocol", "payloads"],
    format: "%s %d %s %s"
  }],
  a: [
    {
      // a=rtpmap:110 opus/48000/2
      push: "rtp",
      reg: /^rtpmap:(\d*) ([\w\-.]*)(?:\s*\/(\d*)(?:\s*\/(\S*))?)?/,
      names: ["payload", "codec", "rate", "encoding"],
      format: function(a) {
        return a.encoding ? "rtpmap:%d %s/%s/%s" : a.rate ? "rtpmap:%d %s/%s" : "rtpmap:%d %s";
      }
    },
    {
      // a=fmtp:108 profile-level-id=24;object=23;bitrate=64000
      // a=fmtp:111 minptime=10; useinbandfec=1
      push: "fmtp",
      reg: /^fmtp:(\d*) ([\S| ]*)/,
      names: ["payload", "config"],
      format: "fmtp:%d %s"
    },
    {
      // a=control:streamid=0
      name: "control",
      reg: /^control:(.*)/,
      format: "control:%s"
    },
    {
      // a=rtcp:65179 IN IP4 193.84.77.194
      name: "rtcp",
      reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,
      names: ["port", "netType", "ipVer", "address"],
      format: function(a) {
        return a.address != null ? "rtcp:%d %s IP%d %s" : "rtcp:%d";
      }
    },
    {
      // a=rtcp-fb:98 trr-int 100
      push: "rtcpFbTrrInt",
      reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/,
      names: ["payload", "value"],
      format: "rtcp-fb:%s trr-int %d"
    },
    {
      // a=rtcp-fb:98 nack rpsi
      push: "rtcpFb",
      reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,
      names: ["payload", "type", "subtype"],
      format: function(a) {
        return a.subtype != null ? "rtcp-fb:%s %s %s" : "rtcp-fb:%s %s";
      }
    },
    {
      // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
      // a=extmap:1/recvonly URI-gps-string
      // a=extmap:3 urn:ietf:params:rtp-hdrext:encrypt urn:ietf:params:rtp-hdrext:smpte-tc 25@600/24
      push: "ext",
      reg: /^extmap:(\d+)(?:\/(\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\S*)(?: (\S*))?/,
      names: ["value", "direction", "encrypt-uri", "uri", "config"],
      format: function(a) {
        return "extmap:%d" + (a.direction ? "/%s" : "%v") + (a["encrypt-uri"] ? " %s" : "%v") + " %s" + (a.config ? " %s" : "");
      }
    },
    {
      // a=extmap-allow-mixed
      name: "extmapAllowMixed",
      reg: /^(extmap-allow-mixed)/
    },
    {
      // a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32
      push: "crypto",
      reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,
      names: ["id", "suite", "config", "sessionConfig"],
      format: function(a) {
        return a.sessionConfig != null ? "crypto:%d %s %s %s" : "crypto:%d %s %s";
      }
    },
    {
      // a=setup:actpass
      name: "setup",
      reg: /^setup:(\w*)/,
      format: "setup:%s"
    },
    {
      // a=connection:new
      name: "connectionType",
      reg: /^connection:(new|existing)/,
      format: "connection:%s"
    },
    {
      // a=mid:1
      name: "mid",
      reg: /^mid:([^\s]*)/,
      format: "mid:%s"
    },
    {
      // a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a
      name: "msid",
      reg: /^msid:(.*)/,
      format: "msid:%s"
    },
    {
      // a=ptime:20
      name: "ptime",
      reg: /^ptime:(\d*(?:\.\d*)*)/,
      format: "ptime:%d"
    },
    {
      // a=maxptime:60
      name: "maxptime",
      reg: /^maxptime:(\d*(?:\.\d*)*)/,
      format: "maxptime:%d"
    },
    {
      // a=sendrecv
      name: "direction",
      reg: /^(sendrecv|recvonly|sendonly|inactive)/
    },
    {
      // a=ice-lite
      name: "icelite",
      reg: /^(ice-lite)/
    },
    {
      // a=ice-ufrag:F7gI
      name: "iceUfrag",
      reg: /^ice-ufrag:(\S*)/,
      format: "ice-ufrag:%s"
    },
    {
      // a=ice-pwd:x9cml/YzichV2+XlhiMu8g
      name: "icePwd",
      reg: /^ice-pwd:(\S*)/,
      format: "ice-pwd:%s"
    },
    {
      // a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33
      name: "fingerprint",
      reg: /^fingerprint:(\S*) (\S*)/,
      names: ["type", "hash"],
      format: "fingerprint:%s %s"
    },
    {
      // a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host
      // a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10
      // a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10
      // a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10
      // a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10
      push: "candidates",
      reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?(?: network-id (\d*))?(?: network-cost (\d*))?/,
      names: ["foundation", "component", "transport", "priority", "ip", "port", "type", "raddr", "rport", "tcptype", "generation", "network-id", "network-cost"],
      format: function(a) {
        var u = "candidate:%s %d %s %d %s %d typ %s";
        return u += a.raddr != null ? " raddr %s rport %d" : "%v%v", u += a.tcptype != null ? " tcptype %s" : "%v", a.generation != null && (u += " generation %d"), u += a["network-id"] != null ? " network-id %d" : "%v", u += a["network-cost"] != null ? " network-cost %d" : "%v", u;
      }
    },
    {
      // a=end-of-candidates (keep after the candidates line for readability)
      name: "endOfCandidates",
      reg: /^(end-of-candidates)/
    },
    {
      // a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...
      name: "remoteCandidates",
      reg: /^remote-candidates:(.*)/,
      format: "remote-candidates:%s"
    },
    {
      // a=ice-options:google-ice
      name: "iceOptions",
      reg: /^ice-options:(\S*)/,
      format: "ice-options:%s"
    },
    {
      // a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1
      push: "ssrcs",
      reg: /^ssrc:(\d*) ([\w_-]*)(?::(.*))?/,
      names: ["id", "attribute", "value"],
      format: function(a) {
        var u = "ssrc:%d";
        return a.attribute != null && (u += " %s", a.value != null && (u += ":%s")), u;
      }
    },
    {
      // a=ssrc-group:FEC 1 2
      // a=ssrc-group:FEC-FR 3004364195 1080772241
      push: "ssrcGroups",
      // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E
      reg: /^ssrc-group:([\x21\x23\x24\x25\x26\x27\x2A\x2B\x2D\x2E\w]*) (.*)/,
      names: ["semantics", "ssrcs"],
      format: "ssrc-group:%s %s"
    },
    {
      // a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV
      name: "msidSemantic",
      reg: /^msid-semantic:\s?(\w*) (\S*)/,
      names: ["semantic", "token"],
      format: "msid-semantic: %s %s"
      // space after ':' is not accidental
    },
    {
      // a=group:BUNDLE audio video
      push: "groups",
      reg: /^group:(\w*) (.*)/,
      names: ["type", "mids"],
      format: "group:%s %s"
    },
    {
      // a=rtcp-mux
      name: "rtcpMux",
      reg: /^(rtcp-mux)/
    },
    {
      // a=rtcp-rsize
      name: "rtcpRsize",
      reg: /^(rtcp-rsize)/
    },
    {
      // a=sctpmap:5000 webrtc-datachannel 1024
      name: "sctpmap",
      reg: /^sctpmap:([\w_/]*) (\S*)(?: (\S*))?/,
      names: ["sctpmapNumber", "app", "maxMessageSize"],
      format: function(a) {
        return a.maxMessageSize != null ? "sctpmap:%s %s %s" : "sctpmap:%s %s";
      }
    },
    {
      // a=x-google-flag:conference
      name: "xGoogleFlag",
      reg: /^x-google-flag:([^\s]*)/,
      format: "x-google-flag:%s"
    },
    {
      // a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0
      push: "rids",
      reg: /^rid:([\d\w]+) (\w+)(?: ([\S| ]*))?/,
      names: ["id", "direction", "params"],
      format: function(a) {
        return a.params ? "rid:%s %s %s" : "rid:%s %s";
      }
    },
    {
      // a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]
      // a=imageattr:* send [x=800,y=640] recv *
      // a=imageattr:100 recv [x=320,y=240]
      push: "imageattrs",
      reg: new RegExp(
        // a=imageattr:97
        "^imageattr:(\\d+|\\*)[\\s\\t]+(send|recv)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*)(?:[\\s\\t]+(recv|send)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*))?"
      ),
      names: ["pt", "dir1", "attrs1", "dir2", "attrs2"],
      format: function(a) {
        return "imageattr:%s %s %s" + (a.dir2 ? " %s %s" : "");
      }
    },
    {
      // a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8
      // a=simulcast:recv 1;4,5 send 6;7
      name: "simulcast",
      reg: new RegExp(
        // a=simulcast:
        "^simulcast:(send|recv) ([a-zA-Z0-9\\-_~;,]+)(?:\\s?(send|recv) ([a-zA-Z0-9\\-_~;,]+))?$"
      ),
      names: ["dir1", "list1", "dir2", "list2"],
      format: function(a) {
        return "simulcast:%s %s" + (a.dir2 ? " %s %s" : "");
      }
    },
    {
      // old simulcast draft 03 (implemented by Firefox)
      //   https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03
      // a=simulcast: recv pt=97;98 send pt=97
      // a=simulcast: send rid=5;6;7 paused=6,7
      name: "simulcast_03",
      reg: /^simulcast:[\s\t]+([\S+\s\t]+)$/,
      names: ["value"],
      format: "simulcast: %s"
    },
    {
      // a=framerate:25
      // a=framerate:29.97
      name: "framerate",
      reg: /^framerate:(\d+(?:$|\.\d+))/,
      format: "framerate:%s"
    },
    {
      // RFC4570
      // a=source-filter: incl IN IP4 239.5.2.31 10.1.15.5
      name: "sourceFilter",
      reg: /^source-filter: *(excl|incl) (\S*) (IP4|IP6|\*) (\S*) (.*)/,
      names: ["filterMode", "netType", "addressTypes", "destAddress", "srcList"],
      format: "source-filter: %s %s %s %s %s"
    },
    {
      // a=bundle-only
      name: "bundleOnly",
      reg: /^(bundle-only)/
    },
    {
      // a=label:1
      name: "label",
      reg: /^label:(.+)/,
      format: "label:%s"
    },
    {
      // RFC version 26 for SCTP over DTLS
      // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-5
      name: "sctpPort",
      reg: /^sctp-port:(\d+)$/,
      format: "sctp-port:%s"
    },
    {
      // RFC version 26 for SCTP over DTLS
      // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-6
      name: "maxMessageSize",
      reg: /^max-message-size:(\d+)$/,
      format: "max-message-size:%s"
    },
    {
      // RFC7273
      // a=ts-refclk:ptp=IEEE1588-2008:39-A7-94-FF-FE-07-CB-D0:37
      push: "tsRefClocks",
      reg: /^ts-refclk:([^\s=]*)(?:=(\S*))?/,
      names: ["clksrc", "clksrcExt"],
      format: function(a) {
        return "ts-refclk:%s" + (a.clksrcExt != null ? "=%s" : "");
      }
    },
    {
      // RFC7273
      // a=mediaclk:direct=963214424
      name: "mediaClk",
      reg: /^mediaclk:(?:id=(\S*))? *([^\s=]*)(?:=(\S*))?(?: *rate=(\d+)\/(\d+))?/,
      names: ["id", "mediaClockName", "mediaClockValue", "rateNumerator", "rateDenominator"],
      format: function(a) {
        var u = "mediaclk:";
        return u += a.id != null ? "id=%s %s" : "%v%s", u += a.mediaClockValue != null ? "=%s" : "", u += a.rateNumerator != null ? " rate=%s" : "", u += a.rateDenominator != null ? "/%s" : "", u;
      }
    },
    {
      // a=keywds:keywords
      name: "keywords",
      reg: /^keywds:(.+)$/,
      format: "keywds:%s"
    },
    {
      // a=content:main
      name: "content",
      reg: /^content:(.+)/,
      format: "content:%s"
    },
    // BFCP https://tools.ietf.org/html/rfc4583
    {
      // a=floorctrl:c-s
      name: "bfcpFloorCtrl",
      reg: /^floorctrl:(c-only|s-only|c-s)/,
      format: "floorctrl:%s"
    },
    {
      // a=confid:1
      name: "bfcpConfId",
      reg: /^confid:(\d+)/,
      format: "confid:%s"
    },
    {
      // a=userid:1
      name: "bfcpUserId",
      reg: /^userid:(\d+)/,
      format: "userid:%s"
    },
    {
      // a=floorid:1
      name: "bfcpFloorId",
      reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/,
      names: ["id", "mStream"],
      format: "floorid:%s mstrm:%s"
    },
    {
      // any a= that we don't understand is kept verbatim on media.invalid
      push: "invalid",
      names: ["value"]
    }
  ]
};
Object.keys(grammar$1).forEach(function(a) {
  var u = grammar$1[a];
  u.forEach(function(c) {
    c.reg || (c.reg = /(.*)/), c.format || (c.format = "%s");
  });
});
var grammarExports = grammar$2.exports;
(function(a) {
  var u = function(k) {
    return String(Number(k)) === k ? Number(k) : k;
  }, c = function(k, O, D, F) {
    if (F && !D)
      O[F] = u(k[1]);
    else
      for (var z = 0; z < D.length; z += 1)
        k[z + 1] != null && (O[D[z]] = u(k[z + 1]));
  }, l = function(k, O, D) {
    var F = k.name && k.names;
    k.push && !O[k.push] ? O[k.push] = [] : F && !O[k.name] && (O[k.name] = {});
    var z = k.push ? {} : (
      // blank object that will be pushed
      F ? O[k.name] : O
    );
    c(D.match(k.reg), z, k.names, k.name), k.push && O[k.push].push(z);
  }, v = grammarExports, p = RegExp.prototype.test.bind(/^([a-z])=(.*)/);
  a.parse = function(k) {
    var O = {}, D = [], F = O;
    return k.split(/(\r\n|\r|\n)/).filter(p).forEach(function(z) {
      var j = z[0], ee = z.slice(2);
      j === "m" && (D.push({
        rtp: [],
        fmtp: []
      }), F = D[D.length - 1]);
      for (var X = 0; X < (v[j] || []).length; X += 1) {
        var ae = v[j][X];
        if (ae.reg.test(ee))
          return l(ae, F, ee);
      }
    }), O.media = D, O;
  };
  var _ = function(k, O) {
    var D = O.split(/=(.+)/, 2);
    return D.length === 2 ? k[D[0]] = u(D[1]) : D.length === 1 && O.length > 1 && (k[D[0]] = void 0), k;
  };
  a.parseParams = function(k) {
    return k.split(/;\s?/).reduce(_, {});
  }, a.parseFmtpConfig = a.parseParams, a.parsePayloads = function(k) {
    return k.toString().split(" ").map(Number);
  }, a.parseRemoteCandidates = function(k) {
    for (var O = [], D = k.split(" ").map(u), F = 0; F < D.length; F += 3)
      O.push({
        component: D[F],
        ip: D[F + 1],
        port: D[F + 2]
      });
    return O;
  }, a.parseImageAttributes = function(k) {
    return k.split(" ").map(function(O) {
      return O.substring(1, O.length - 1).split(",").reduce(_, {});
    });
  }, a.parseSimulcastStreamList = function(k) {
    return k.split(";").map(function(O) {
      return O.split(",").map(function(D) {
        var F, z = !1;
        return D[0] !== "~" ? F = u(D) : (F = u(D.substring(1, D.length)), z = !0), {
          scid: F,
          paused: z
        };
      });
    });
  };
})(parser$1);
var grammar = grammarExports, formatRegExp = /%[sdv%]/g, format = function(a) {
  var u = 1, c = arguments, l = c.length;
  return a.replace(formatRegExp, function(v) {
    if (u >= l)
      return v;
    var p = c[u];
    switch (u += 1, v) {
      case "%%":
        return "%";
      case "%s":
        return String(p);
      case "%d":
        return Number(p);
      case "%v":
        return "";
    }
  });
}, makeLine = function(a, u, c) {
  var l = u.format instanceof Function ? u.format(u.push ? c : c[u.name]) : u.format, v = [a + "=" + l];
  if (u.names)
    for (var p = 0; p < u.names.length; p += 1) {
      var _ = u.names[p];
      u.name ? v.push(c[u.name][_]) : v.push(c[u.names[p]]);
    }
  else
    v.push(c[u.name]);
  return format.apply(null, v);
}, defaultOuterOrder = ["v", "o", "s", "i", "u", "e", "p", "c", "b", "t", "r", "z", "a"], defaultInnerOrder = ["i", "c", "b", "a"], writer$1 = function(a, u) {
  u = u || {}, a.version == null && (a.version = 0), a.name == null && (a.name = " "), a.media.forEach(function(p) {
    p.payloads == null && (p.payloads = "");
  });
  var c = u.outerOrder || defaultOuterOrder, l = u.innerOrder || defaultInnerOrder, v = [];
  return c.forEach(function(p) {
    grammar[p].forEach(function(_) {
      _.name in a && a[_.name] != null ? v.push(makeLine(p, _, a)) : _.push in a && a[_.push] != null && a[_.push].forEach(function(k) {
        v.push(makeLine(p, _, k));
      });
    });
  }), a.media.forEach(function(p) {
    v.push(makeLine("m", grammar.m[0], p)), l.forEach(function(_) {
      grammar[_].forEach(function(k) {
        k.name in p && p[k.name] != null ? v.push(makeLine(_, k, p)) : k.push in p && p[k.push] != null && p[k.push].forEach(function(O) {
          v.push(makeLine(_, k, O));
        });
      });
    });
  }), v.join(`\r
`) + `\r
`;
}, parser = parser$1, writer = writer$1, write = writer, parse$2 = parser.parse;
const startBitrateForSVC = 0.7, PCEvents = {
  NegotiationStarted: "negotiationStarted",
  NegotiationComplete: "negotiationComplete",
  RTPVideoPayloadTypes: "rtpVideoPayloadTypes"
};
class PCTransport extends eventsExports$1.EventEmitter {
  get pc() {
    return this._pc || (this._pc = this.createPC()), this._pc;
  }
  constructor(u) {
    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var l;
    super(), this.log = livekitLogger, this.pendingCandidates = [], this.restartingIce = !1, this.renegotiate = !1, this.trackBitrates = [], this.remoteStereoMids = [], this.remoteNackMids = [], this.negotiate = r$1((v) => __awaiter$3(this, void 0, void 0, function* () {
      this.emit(PCEvents.NegotiationStarted);
      try {
        yield this.createAndSendOffer();
      } catch (p) {
        if (v)
          v(p);
        else
          throw p;
      }
    }), 100), this.close = () => {
      this._pc && (this._pc.close(), this._pc.onconnectionstatechange = null, this._pc.oniceconnectionstatechange = null, this._pc.onicegatheringstatechange = null, this._pc.ondatachannel = null, this._pc.onnegotiationneeded = null, this._pc.onsignalingstatechange = null, this._pc.onicecandidate = null, this._pc.ondatachannel = null, this._pc.ontrack = null, this._pc.onconnectionstatechange = null, this._pc.oniceconnectionstatechange = null, this._pc = null);
    }, this.log = getLogger((l = c.loggerName) !== null && l !== void 0 ? l : LoggerNames.PCTransport), this.loggerOptions = c, this.config = u, this._pc = this.createPC();
  }
  createPC() {
    const u = new RTCPeerConnection(this.config);
    return u.onicecandidate = (c) => {
      var l;
      c.candidate && ((l = this.onIceCandidate) === null || l === void 0 || l.call(this, c.candidate));
    }, u.onicecandidateerror = (c) => {
      var l;
      (l = this.onIceCandidateError) === null || l === void 0 || l.call(this, c);
    }, u.oniceconnectionstatechange = () => {
      var c;
      (c = this.onIceConnectionStateChange) === null || c === void 0 || c.call(this, u.iceConnectionState);
    }, u.onsignalingstatechange = () => {
      var c;
      (c = this.onSignalingStatechange) === null || c === void 0 || c.call(this, u.signalingState);
    }, u.onconnectionstatechange = () => {
      var c;
      (c = this.onConnectionStateChange) === null || c === void 0 || c.call(this, u.connectionState);
    }, u.ondatachannel = (c) => {
      var l;
      (l = this.onDataChannel) === null || l === void 0 || l.call(this, c);
    }, u.ontrack = (c) => {
      var l;
      (l = this.onTrack) === null || l === void 0 || l.call(this, c);
    }, u;
  }
  get logContext() {
    var u, c;
    return Object.assign({}, (c = (u = this.loggerOptions).loggerContextCb) === null || c === void 0 ? void 0 : c.call(u));
  }
  get isICEConnected() {
    return this._pc !== null && (this.pc.iceConnectionState === "connected" || this.pc.iceConnectionState === "completed");
  }
  addIceCandidate(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (this.pc.remoteDescription && !this.restartingIce)
        return this.pc.addIceCandidate(u);
      this.pendingCandidates.push(u);
    });
  }
  setRemoteDescription(u) {
    var c;
    return __awaiter$3(this, void 0, void 0, function* () {
      let l;
      if (u.type === "offer") {
        let {
          stereoMids: v,
          nackMids: p
        } = extractStereoAndNackAudioFromOffer(u);
        this.remoteStereoMids = v, this.remoteNackMids = p;
      } else if (u.type === "answer") {
        const v = parse$2((c = u.sdp) !== null && c !== void 0 ? c : "");
        v.media.forEach((p) => {
          p.type === "audio" && this.trackBitrates.some((_) => {
            if (!_.transceiver || p.mid != _.transceiver.mid)
              return !1;
            let k = 0;
            if (p.rtp.some((D) => D.codec.toUpperCase() === _.codec.toUpperCase() ? (k = D.payload, !0) : !1), k === 0)
              return !0;
            let O = !1;
            for (const D of p.fmtp)
              if (D.payload === k) {
                D.config = D.config.split(";").filter((F) => !F.includes("maxaveragebitrate")).join(";"), _.maxbr > 0 && (D.config += ";maxaveragebitrate=".concat(_.maxbr * 1e3)), O = !0;
                break;
              }
            return O || _.maxbr > 0 && p.fmtp.push({
              payload: k,
              config: "maxaveragebitrate=".concat(_.maxbr * 1e3)
            }), !0;
          });
        }), l = write(v);
      }
      yield this.setMungedSDP(u, l, !0), this.pendingCandidates.forEach((v) => {
        this.pc.addIceCandidate(v);
      }), this.pendingCandidates = [], this.restartingIce = !1, this.renegotiate ? (this.renegotiate = !1, yield this.createAndSendOffer()) : u.type === "answer" && (this.emit(PCEvents.NegotiationComplete), u.sdp && parse$2(u.sdp).media.forEach((p) => {
        p.type === "video" && this.emit(PCEvents.RTPVideoPayloadTypes, p.rtp);
      }));
    });
  }
  createAndSendOffer(u) {
    var c;
    return __awaiter$3(this, void 0, void 0, function* () {
      if (this.onOffer === void 0)
        return;
      if (u != null && u.iceRestart && (this.log.debug("restarting ICE", this.logContext), this.restartingIce = !0), this._pc && this._pc.signalingState === "have-local-offer") {
        const p = this._pc.remoteDescription;
        if (u != null && u.iceRestart && p)
          yield this._pc.setRemoteDescription(p);
        else {
          this.renegotiate = !0;
          return;
        }
      } else if (!this._pc || this._pc.signalingState === "closed") {
        this.log.warn("could not createOffer with closed peer connection", this.logContext);
        return;
      }
      this.log.debug("starting to negotiate", this.logContext);
      const l = yield this.pc.createOffer(u), v = parse$2((c = l.sdp) !== null && c !== void 0 ? c : "");
      v.media.forEach((p) => {
        p.type === "audio" ? ensureAudioNackAndStereo(p, [], []) : p.type === "video" && (ensureVideoDDExtensionForSVC(p), this.trackBitrates.some((_) => {
          if (!p.msid || !_.cid || !p.msid.includes(_.cid))
            return !1;
          let k = 0;
          if (p.rtp.some((D) => D.codec.toUpperCase() === _.codec.toUpperCase() ? (k = D.payload, !0) : !1), k === 0)
            return !0;
          const O = Math.round(_.maxbr * startBitrateForSVC);
          for (const D of p.fmtp)
            if (D.payload === k) {
              D.config.includes("x-google-start-bitrate") || (D.config += ";x-google-start-bitrate=".concat(O));
              break;
            }
          return !0;
        }));
      }), yield this.setMungedSDP(l, write(v)), this.onOffer(l);
    });
  }
  createAndSetAnswer() {
    var u;
    return __awaiter$3(this, void 0, void 0, function* () {
      const c = yield this.pc.createAnswer(), l = parse$2((u = c.sdp) !== null && u !== void 0 ? u : "");
      return l.media.forEach((v) => {
        v.type === "audio" && ensureAudioNackAndStereo(v, this.remoteStereoMids, this.remoteNackMids);
      }), yield this.setMungedSDP(c, write(l)), c;
    });
  }
  createDataChannel(u, c) {
    return this.pc.createDataChannel(u, c);
  }
  addTransceiver(u, c) {
    return this.pc.addTransceiver(u, c);
  }
  addTrack(u) {
    if (!this._pc)
      throw new UnexpectedConnectionState("PC closed, cannot add track");
    return this._pc.addTrack(u);
  }
  setTrackCodecBitrate(u) {
    this.trackBitrates.push(u);
  }
  setConfiguration(u) {
    var c;
    if (!this._pc)
      throw new UnexpectedConnectionState("PC closed, cannot configure");
    return (c = this._pc) === null || c === void 0 ? void 0 : c.setConfiguration(u);
  }
  canRemoveTrack() {
    var u;
    return !!(!((u = this._pc) === null || u === void 0) && u.removeTrack);
  }
  removeTrack(u) {
    var c;
    return (c = this._pc) === null || c === void 0 ? void 0 : c.removeTrack(u);
  }
  getConnectionState() {
    var u, c;
    return (c = (u = this._pc) === null || u === void 0 ? void 0 : u.connectionState) !== null && c !== void 0 ? c : "closed";
  }
  getICEConnectionState() {
    var u, c;
    return (c = (u = this._pc) === null || u === void 0 ? void 0 : u.iceConnectionState) !== null && c !== void 0 ? c : "closed";
  }
  getSignallingState() {
    var u, c;
    return (c = (u = this._pc) === null || u === void 0 ? void 0 : u.signalingState) !== null && c !== void 0 ? c : "closed";
  }
  getTransceivers() {
    var u, c;
    return (c = (u = this._pc) === null || u === void 0 ? void 0 : u.getTransceivers()) !== null && c !== void 0 ? c : [];
  }
  getSenders() {
    var u, c;
    return (c = (u = this._pc) === null || u === void 0 ? void 0 : u.getSenders()) !== null && c !== void 0 ? c : [];
  }
  getLocalDescription() {
    var u;
    return (u = this._pc) === null || u === void 0 ? void 0 : u.localDescription;
  }
  getRemoteDescription() {
    var u;
    return (u = this.pc) === null || u === void 0 ? void 0 : u.remoteDescription;
  }
  getStats() {
    return this.pc.getStats();
  }
  getConnectedAddress() {
    var u;
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!this._pc)
        return;
      let c = "";
      const l = /* @__PURE__ */ new Map(), v = /* @__PURE__ */ new Map();
      if ((yield this._pc.getStats()).forEach((k) => {
        switch (k.type) {
          case "transport":
            c = k.selectedCandidatePairId;
            break;
          case "candidate-pair":
            c === "" && k.selected && (c = k.id), l.set(k.id, k);
            break;
          case "remote-candidate":
            v.set(k.id, "".concat(k.address, ":").concat(k.port));
            break;
        }
      }), c === "")
        return;
      const _ = (u = l.get(c)) === null || u === void 0 ? void 0 : u.remoteCandidateId;
      if (_ !== void 0)
        return v.get(_);
    });
  }
  setMungedSDP(u, c, l) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (c) {
        const v = u.sdp;
        u.sdp = c;
        try {
          this.log.debug("setting munged ".concat(l ? "remote" : "local", " description"), this.logContext), l ? yield this.pc.setRemoteDescription(u) : yield this.pc.setLocalDescription(u);
          return;
        } catch (p) {
          this.log.warn("not able to set ".concat(u.type, ", falling back to unmodified sdp"), Object.assign(Object.assign({}, this.logContext), {
            error: p,
            sdp: c
          })), u.sdp = v;
        }
      }
      try {
        l ? yield this.pc.setRemoteDescription(u) : yield this.pc.setLocalDescription(u);
      } catch (v) {
        let p = "unknown error";
        v instanceof Error ? p = v.message : typeof v == "string" && (p = v);
        const _ = {
          error: p,
          sdp: u.sdp
        };
        throw !l && this.pc.remoteDescription && (_.remoteSdp = this.pc.remoteDescription), this.log.error("unable to set ".concat(u.type), Object.assign(Object.assign({}, this.logContext), {
          fields: _
        })), new NegotiationError(p);
      }
    });
  }
}
function ensureAudioNackAndStereo(a, u, c) {
  let l = 0;
  a.rtp.some((v) => v.codec === "opus" ? (l = v.payload, !0) : !1), l > 0 && (a.rtcpFb || (a.rtcpFb = []), c.includes(a.mid) && !a.rtcpFb.some((v) => v.payload === l && v.type === "nack") && a.rtcpFb.push({
    payload: l,
    type: "nack"
  }), u.includes(a.mid) && a.fmtp.some((v) => v.payload === l ? (v.config.includes("stereo=1") || (v.config += ";stereo=1"), !0) : !1));
}
function ensureVideoDDExtensionForSVC(a) {
  var u, c, l, v;
  const p = (c = (u = a.rtp[0]) === null || u === void 0 ? void 0 : u.codec) === null || c === void 0 ? void 0 : c.toLowerCase();
  if (!isSVCCodec(p))
    return;
  let _ = 0;
  ((l = a.ext) === null || l === void 0 ? void 0 : l.some((O) => O.uri === ddExtensionURI ? !0 : (O.value > _ && (_ = O.value), !1))) || (v = a.ext) === null || v === void 0 || v.push({
    value: _ + 1,
    uri: ddExtensionURI
  });
}
function extractStereoAndNackAudioFromOffer(a) {
  var u;
  const c = [], l = [], v = parse$2((u = a.sdp) !== null && u !== void 0 ? u : "");
  let p = 0;
  return v.media.forEach((_) => {
    var k;
    _.type === "audio" && (_.rtp.some((O) => O.codec === "opus" ? (p = O.payload, !0) : !1), !((k = _.rtcpFb) === null || k === void 0) && k.some((O) => O.payload === p && O.type === "nack") && l.push(_.mid), _.fmtp.some((O) => O.payload === p ? (O.config.includes("sprop-stereo=1") && c.push(_.mid), !0) : !1));
  }), {
    stereoMids: c,
    nackMids: l
  };
}
const defaultVideoCodec = "vp8", publishDefaults = {
  audioPreset: AudioPresets.music,
  dtx: !0,
  red: !0,
  forceStereo: !1,
  simulcast: !0,
  screenShareEncoding: ScreenSharePresets.h1080fps15.encoding,
  stopMicTrackOnMute: !1,
  videoCodec: defaultVideoCodec,
  backupCodec: !0
}, audioDefaults = {
  autoGainControl: !0,
  echoCancellation: !0,
  noiseSuppression: !0
}, videoDefaults = {
  resolution: VideoPresets.h720.resolution
}, roomOptionDefaults = {
  adaptiveStream: !1,
  dynacast: !1,
  stopLocalTrackOnUnpublish: !0,
  reconnectPolicy: new DefaultReconnectPolicy(),
  disconnectOnPageLeave: !0,
  webAudioMix: !0
}, roomConnectOptionDefaults = {
  autoSubscribe: !0,
  maxRetries: 1,
  peerConnectionTimeout: 15e3,
  websocketTimeout: 15e3
};
var PCTransportState;
(function(a) {
  a[a.NEW = 0] = "NEW", a[a.CONNECTING = 1] = "CONNECTING", a[a.CONNECTED = 2] = "CONNECTED", a[a.FAILED = 3] = "FAILED", a[a.CLOSING = 4] = "CLOSING", a[a.CLOSED = 5] = "CLOSED";
})(PCTransportState || (PCTransportState = {}));
class PCTransportManager {
  get needsPublisher() {
    return this.isPublisherConnectionRequired;
  }
  get needsSubscriber() {
    return this.isSubscriberConnectionRequired;
  }
  get currentState() {
    return this.state;
  }
  constructor(u, c, l) {
    var v;
    this.peerConnectionTimeout = roomConnectOptionDefaults.peerConnectionTimeout, this.log = livekitLogger, this.updateState = () => {
      var p;
      const _ = this.state, k = this.requiredTransports.map((O) => O.getConnectionState());
      k.every((O) => O === "connected") ? this.state = PCTransportState.CONNECTED : k.some((O) => O === "failed") ? this.state = PCTransportState.FAILED : k.some((O) => O === "connecting") ? this.state = PCTransportState.CONNECTING : k.every((O) => O === "closed") ? this.state = PCTransportState.CLOSED : k.some((O) => O === "closed") ? this.state = PCTransportState.CLOSING : k.every((O) => O === "new") && (this.state = PCTransportState.NEW), _ !== this.state && (this.log.debug("pc state change: from ".concat(PCTransportState[_], " to ").concat(PCTransportState[this.state]), this.logContext), (p = this.onStateChange) === null || p === void 0 || p.call(this, this.state, this.publisher.getConnectionState(), this.subscriber.getConnectionState()));
    }, this.log = getLogger((v = l.loggerName) !== null && v !== void 0 ? v : LoggerNames.PCManager), this.loggerOptions = l, this.isPublisherConnectionRequired = !c, this.isSubscriberConnectionRequired = c, this.publisher = new PCTransport(u, l), this.subscriber = new PCTransport(u, l), this.publisher.onConnectionStateChange = this.updateState, this.subscriber.onConnectionStateChange = this.updateState, this.publisher.onIceConnectionStateChange = this.updateState, this.subscriber.onIceConnectionStateChange = this.updateState, this.publisher.onSignalingStatechange = this.updateState, this.subscriber.onSignalingStatechange = this.updateState, this.publisher.onIceCandidate = (p) => {
      var _;
      (_ = this.onIceCandidate) === null || _ === void 0 || _.call(this, p, SignalTarget.PUBLISHER);
    }, this.subscriber.onIceCandidate = (p) => {
      var _;
      (_ = this.onIceCandidate) === null || _ === void 0 || _.call(this, p, SignalTarget.SUBSCRIBER);
    }, this.subscriber.onDataChannel = (p) => {
      var _;
      (_ = this.onDataChannel) === null || _ === void 0 || _.call(this, p);
    }, this.subscriber.onTrack = (p) => {
      var _;
      (_ = this.onTrack) === null || _ === void 0 || _.call(this, p);
    }, this.publisher.onOffer = (p) => {
      var _;
      (_ = this.onPublisherOffer) === null || _ === void 0 || _.call(this, p);
    }, this.state = PCTransportState.NEW, this.connectionLock = new Mutex();
  }
  get logContext() {
    var u, c;
    return Object.assign({}, (c = (u = this.loggerOptions).loggerContextCb) === null || c === void 0 ? void 0 : c.call(u));
  }
  requirePublisher() {
    let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
    this.isPublisherConnectionRequired = u, this.updateState();
  }
  requireSubscriber() {
    let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
    this.isSubscriberConnectionRequired = u, this.updateState();
  }
  createAndSendPublisherOffer(u) {
    return this.publisher.createAndSendOffer(u);
  }
  setPublisherAnswer(u) {
    return this.publisher.setRemoteDescription(u);
  }
  removeTrack(u) {
    return this.publisher.removeTrack(u);
  }
  close() {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (this.publisher && this.publisher.getSignallingState() !== "closed") {
        const u = this.publisher;
        for (const c of u.getSenders())
          try {
            u.canRemoveTrack() && u.removeTrack(c);
          } catch (l) {
            this.log.warn("could not removeTrack", Object.assign(Object.assign({}, this.logContext), {
              error: l
            }));
          }
      }
      yield Promise.all([this.publisher.close(), this.subscriber.close()]), this.updateState();
    });
  }
  triggerIceRestart() {
    return __awaiter$3(this, void 0, void 0, function* () {
      this.subscriber.restartingIce = !0, this.needsPublisher && (yield this.createAndSendPublisherOffer({
        iceRestart: !0
      }));
    });
  }
  addIceCandidate(u, c) {
    return __awaiter$3(this, void 0, void 0, function* () {
      c === SignalTarget.PUBLISHER ? yield this.publisher.addIceCandidate(u) : yield this.subscriber.addIceCandidate(u);
    });
  }
  createSubscriberAnswerFromOffer(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this.log.debug("received server offer", Object.assign(Object.assign({}, this.logContext), {
        RTCSdpType: u.type,
        sdp: u.sdp,
        signalingState: this.subscriber.getSignallingState().toString()
      })), yield this.subscriber.setRemoteDescription(u), yield this.subscriber.createAndSetAnswer();
    });
  }
  updateConfiguration(u, c) {
    this.publisher.setConfiguration(u), this.subscriber.setConfiguration(u), c && this.triggerIceRestart();
  }
  ensurePCTransportConnection(u, c) {
    var l;
    return __awaiter$3(this, void 0, void 0, function* () {
      const v = yield this.connectionLock.lock();
      try {
        this.isPublisherConnectionRequired && this.publisher.getConnectionState() !== "connected" && this.publisher.getConnectionState() !== "connecting" && (this.log.debug("negotiation required, start negotiating", this.logContext), this.publisher.negotiate()), yield Promise.all((l = this.requiredTransports) === null || l === void 0 ? void 0 : l.map((p) => this.ensureTransportConnected(p, u, c)));
      } finally {
        v();
      }
    });
  }
  negotiate(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      return new Promise((c, l) => __awaiter$3(this, void 0, void 0, function* () {
        const v = setTimeout(() => {
          l("negotiation timed out");
        }, this.peerConnectionTimeout), p = () => {
          clearTimeout(v), l("negotiation aborted");
        };
        u.signal.addEventListener("abort", p), this.publisher.once(PCEvents.NegotiationStarted, () => {
          u.signal.aborted || this.publisher.once(PCEvents.NegotiationComplete, () => {
            clearTimeout(v), c();
          });
        }), yield this.publisher.negotiate((_) => {
          clearTimeout(v), l(_);
        });
      }));
    });
  }
  addPublisherTransceiver(u, c) {
    return this.publisher.addTransceiver(u, c);
  }
  addPublisherTrack(u) {
    return this.publisher.addTrack(u);
  }
  createPublisherDataChannel(u, c) {
    return this.publisher.createDataChannel(u, c);
  }
  /**
   * Returns the first required transport's address if no explicit target is specified
   */
  getConnectedAddress(u) {
    return u === SignalTarget.PUBLISHER ? this.publisher.getConnectedAddress() : u === SignalTarget.SUBSCRIBER ? this.publisher.getConnectedAddress() : this.requiredTransports[0].getConnectedAddress();
  }
  get requiredTransports() {
    const u = [];
    return this.isPublisherConnectionRequired && u.push(this.publisher), this.isSubscriberConnectionRequired && u.push(this.subscriber), u;
  }
  ensureTransportConnected(u, c) {
    let l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.peerConnectionTimeout;
    return __awaiter$3(this, void 0, void 0, function* () {
      if (u.getConnectionState() !== "connected")
        return new Promise((p, _) => __awaiter$3(this, void 0, void 0, function* () {
          const k = () => {
            this.log.warn("abort transport connection", this.logContext), CriticalTimers.clearTimeout(O), _(new ConnectionError(
              "room connection has been cancelled",
              3
              /* ConnectionErrorReason.Cancelled */
            ));
          };
          c != null && c.signal.aborted && k(), c == null || c.signal.addEventListener("abort", k);
          const O = CriticalTimers.setTimeout(() => {
            c == null || c.signal.removeEventListener("abort", k), _(new ConnectionError("could not establish pc connection"));
          }, l);
          for (; this.state !== PCTransportState.CONNECTED; )
            if (yield sleep(50), c != null && c.signal.aborted) {
              _(new ConnectionError(
                "room connection has been cancelled",
                3
                /* ConnectionErrorReason.Cancelled */
              ));
              return;
            }
          CriticalTimers.clearTimeout(O), c == null || c.signal.removeEventListener("abort", k), p();
        }));
    });
  }
}
const lossyDataChannel = "_lossy", reliableDataChannel = "_reliable", minReconnectWait = 2 * 1e3, leaveReconnect = "leave-reconnect";
var PCState;
(function(a) {
  a[a.New = 0] = "New", a[a.Connected = 1] = "Connected", a[a.Disconnected = 2] = "Disconnected", a[a.Reconnecting = 3] = "Reconnecting", a[a.Closed = 4] = "Closed";
})(PCState || (PCState = {}));
class RTCEngine extends eventsExports$1.EventEmitter {
  get isClosed() {
    return this._isClosed;
  }
  get pendingReconnect() {
    return !!this.reconnectTimeout;
  }
  constructor(u) {
    var c;
    super(), this.options = u, this.rtcConfig = {}, this.peerConnectionTimeout = roomConnectOptionDefaults.peerConnectionTimeout, this.fullReconnectOnNext = !1, this.subscriberPrimary = !1, this.pcState = PCState.New, this._isClosed = !0, this.pendingTrackResolvers = {}, this.reconnectAttempts = 0, this.reconnectStart = 0, this.attemptingReconnect = !1, this.joinAttempts = 0, this.maxJoinAttempts = 1, this.shouldFailNext = !1, this.log = livekitLogger, this.handleDataChannel = (l) => {
      let {
        channel: v
      } = l;
      return __awaiter$3(this, void 0, void 0, function* () {
        if (v) {
          if (v.label === reliableDataChannel)
            this.reliableDCSub = v;
          else if (v.label === lossyDataChannel)
            this.lossyDCSub = v;
          else
            return;
          this.log.debug("on data channel ".concat(v.id, ", ").concat(v.label), this.logContext), v.onmessage = this.handleDataMessage;
        }
      });
    }, this.handleDataMessage = (l) => __awaiter$3(this, void 0, void 0, function* () {
      var v, p;
      const _ = yield this.dataProcessLock.lock();
      try {
        let k;
        if (l.data instanceof ArrayBuffer)
          k = l.data;
        else if (l.data instanceof Blob)
          k = yield l.data.arrayBuffer();
        else {
          this.log.error("unsupported data type", Object.assign(Object.assign({}, this.logContext), {
            data: l.data
          }));
          return;
        }
        const O = DataPacket.fromBinary(new Uint8Array(k));
        ((v = O.value) === null || v === void 0 ? void 0 : v.case) === "speaker" ? this.emit(EngineEvent.ActiveSpeakersUpdate, O.value.value.speakers) : ((p = O.value) === null || p === void 0 ? void 0 : p.case) === "user" && this.emit(EngineEvent.DataPacketReceived, O.value.value, O.kind);
      } finally {
        _();
      }
    }), this.handleDataError = (l) => {
      const p = l.currentTarget.maxRetransmits === 0 ? "lossy" : "reliable";
      if (l instanceof ErrorEvent && l.error) {
        const {
          error: _
        } = l.error;
        this.log.error("DataChannel error on ".concat(p, ": ").concat(l.message), Object.assign(Object.assign({}, this.logContext), {
          error: _
        }));
      } else
        this.log.error("Unknown DataChannel error on ".concat(p), Object.assign(Object.assign({}, this.logContext), {
          event: l
        }));
    }, this.handleBufferedAmountLow = (l) => {
      const p = l.currentTarget.maxRetransmits === 0 ? DataPacket_Kind.LOSSY : DataPacket_Kind.RELIABLE;
      this.updateAndEmitDCBufferStatus(p);
    }, this.handleDisconnect = (l, v) => {
      if (this._isClosed)
        return;
      this.log.warn("".concat(l, " disconnected"), this.logContext), this.reconnectAttempts === 0 && (this.reconnectStart = Date.now());
      const p = (O) => {
        this.log.warn("could not recover connection after ".concat(this.reconnectAttempts, " attempts, ").concat(O, "ms. giving up"), this.logContext), this.emit(EngineEvent.Disconnected), this.close();
      }, _ = Date.now() - this.reconnectStart;
      let k = this.getNextRetryDelay({
        elapsedMs: _,
        retryCount: this.reconnectAttempts
      });
      if (k === null) {
        p(_);
        return;
      }
      l === leaveReconnect && (k = 0), this.log.debug("reconnecting in ".concat(k, "ms"), this.logContext), this.clearReconnectTimeout(), this.token && this.regionUrlProvider && this.regionUrlProvider.updateToken(this.token), this.reconnectTimeout = CriticalTimers.setTimeout(() => this.attemptReconnect(v).finally(() => this.reconnectTimeout = void 0), k);
    }, this.waitForRestarted = () => new Promise((l, v) => {
      this.pcState === PCState.Connected && l();
      const p = () => {
        this.off(EngineEvent.Disconnected, _), l();
      }, _ = () => {
        this.off(EngineEvent.Restarted, p), v();
      };
      this.once(EngineEvent.Restarted, p), this.once(EngineEvent.Disconnected, _);
    }), this.updateAndEmitDCBufferStatus = (l) => {
      const v = this.isBufferStatusLow(l);
      typeof v < "u" && v !== this.dcBufferStatus.get(l) && (this.dcBufferStatus.set(l, v), this.emit(EngineEvent.DCBufferStatusChanged, v, l));
    }, this.isBufferStatusLow = (l) => {
      const v = this.dataChannelForKind(l);
      if (v)
        return v.bufferedAmount <= v.bufferedAmountLowThreshold;
    }, this.handleBrowserOnLine = () => {
      this.client.currentState === SignalConnectionState.RECONNECTING && (this.clearReconnectTimeout(), this.attemptReconnect(ReconnectReason.RR_SIGNAL_DISCONNECTED));
    }, this.log = getLogger((c = u.loggerName) !== null && c !== void 0 ? c : LoggerNames.Engine), this.loggerOptions = {
      loggerName: u.loggerName,
      loggerContextCb: () => this.logContext
    }, this.client = new SignalClient(void 0, this.loggerOptions), this.client.signalLatency = this.options.expSignalLatency, this.reconnectPolicy = this.options.reconnectPolicy, this.registerOnLineListener(), this.closingLock = new Mutex(), this.dataProcessLock = new Mutex(), this.dcBufferStatus = /* @__PURE__ */ new Map([[DataPacket_Kind.LOSSY, !0], [DataPacket_Kind.RELIABLE, !0]]), this.client.onParticipantUpdate = (l) => this.emit(EngineEvent.ParticipantUpdate, l), this.client.onConnectionQuality = (l) => this.emit(EngineEvent.ConnectionQualityUpdate, l), this.client.onRoomUpdate = (l) => this.emit(EngineEvent.RoomUpdate, l), this.client.onSubscriptionError = (l) => this.emit(EngineEvent.SubscriptionError, l), this.client.onSubscriptionPermissionUpdate = (l) => this.emit(EngineEvent.SubscriptionPermissionUpdate, l), this.client.onSpeakersChanged = (l) => this.emit(EngineEvent.SpeakersChanged, l), this.client.onStreamStateUpdate = (l) => this.emit(EngineEvent.StreamStateChanged, l);
  }
  /** @internal */
  get logContext() {
    var u, c, l, v, p, _, k, O;
    return {
      room: (c = (u = this.latestJoinResponse) === null || u === void 0 ? void 0 : u.room) === null || c === void 0 ? void 0 : c.name,
      roomID: (v = (l = this.latestJoinResponse) === null || l === void 0 ? void 0 : l.room) === null || v === void 0 ? void 0 : v.sid,
      participant: (_ = (p = this.latestJoinResponse) === null || p === void 0 ? void 0 : p.participant) === null || _ === void 0 ? void 0 : _.identity,
      pID: (O = (k = this.latestJoinResponse) === null || k === void 0 ? void 0 : k.participant) === null || O === void 0 ? void 0 : O.sid
    };
  }
  join(u, c, l, v) {
    return __awaiter$3(this, void 0, void 0, function* () {
      this.url = u, this.token = c, this.signalOpts = l, this.maxJoinAttempts = l.maxRetries;
      try {
        this.joinAttempts += 1, this.setupSignalClientCallbacks();
        const p = yield this.client.join(u, c, l, v);
        return this._isClosed = !1, this.latestJoinResponse = p, this.subscriberPrimary = p.subscriberPrimary, this.pcManager || (yield this.configure(p)), this.subscriberPrimary || this.negotiate(), this.clientConfiguration = p.clientConfiguration, p;
      } catch (p) {
        if (p instanceof ConnectionError && p.reason === 1 && (this.log.warn("Couldn't connect to server, attempt ".concat(this.joinAttempts, " of ").concat(this.maxJoinAttempts), this.logContext), this.joinAttempts < this.maxJoinAttempts))
          return this.join(u, c, l, v);
        throw p;
      }
    });
  }
  close() {
    return __awaiter$3(this, void 0, void 0, function* () {
      const u = yield this.closingLock.lock();
      if (this.isClosed) {
        u();
        return;
      }
      try {
        this._isClosed = !0, this.emit(EngineEvent.Closing), this.removeAllListeners(), this.deregisterOnLineListener(), this.clearPendingReconnect(), yield this.cleanupPeerConnections(), yield this.cleanupClient();
      } finally {
        u();
      }
    });
  }
  cleanupPeerConnections() {
    var u;
    return __awaiter$3(this, void 0, void 0, function* () {
      yield (u = this.pcManager) === null || u === void 0 ? void 0 : u.close(), this.pcManager = void 0;
      const c = (l) => {
        l && (l.close(), l.onbufferedamountlow = null, l.onclose = null, l.onclosing = null, l.onerror = null, l.onmessage = null, l.onopen = null);
      };
      c(this.lossyDC), c(this.lossyDCSub), c(this.reliableDC), c(this.reliableDCSub), this.lossyDC = void 0, this.lossyDCSub = void 0, this.reliableDC = void 0, this.reliableDCSub = void 0;
    });
  }
  cleanupClient() {
    return __awaiter$3(this, void 0, void 0, function* () {
      yield this.client.close(), this.client.resetCallbacks();
    });
  }
  addTrack(u) {
    if (this.pendingTrackResolvers[u.cid])
      throw new TrackInvalidError("a track with the same ID has already been published");
    return new Promise((c, l) => {
      const v = setTimeout(() => {
        delete this.pendingTrackResolvers[u.cid], l(new ConnectionError("publication of local track timed out, no response from server"));
      }, 1e4);
      this.pendingTrackResolvers[u.cid] = {
        resolve: (p) => {
          clearTimeout(v), c(p);
        },
        reject: () => {
          clearTimeout(v), l(new Error("Cancelled publication by calling unpublish"));
        }
      }, this.client.sendAddTrack(u);
    });
  }
  /**
   * Removes sender from PeerConnection, returning true if it was removed successfully
   * and a negotiation is necessary
   * @param sender
   * @returns
   */
  removeTrack(u) {
    if (u.track && this.pendingTrackResolvers[u.track.id]) {
      const {
        reject: c
      } = this.pendingTrackResolvers[u.track.id];
      c && c(), delete this.pendingTrackResolvers[u.track.id];
    }
    try {
      return this.pcManager.removeTrack(u), !0;
    } catch (c) {
      this.log.warn("failed to remove track", Object.assign(Object.assign({}, this.logContext), {
        error: c
      }));
    }
    return !1;
  }
  updateMuteStatus(u, c) {
    this.client.sendMuteTrack(u, c);
  }
  get dataSubscriberReadyState() {
    var u;
    return (u = this.reliableDCSub) === null || u === void 0 ? void 0 : u.readyState;
  }
  getConnectedServerAddress() {
    var u;
    return __awaiter$3(this, void 0, void 0, function* () {
      return (u = this.pcManager) === null || u === void 0 ? void 0 : u.getConnectedAddress();
    });
  }
  /* @internal */
  setRegionUrlProvider(u) {
    this.regionUrlProvider = u;
  }
  configure(u) {
    var c;
    return __awaiter$3(this, void 0, void 0, function* () {
      if (this.pcManager && this.pcManager.currentState !== PCTransportState.NEW)
        return;
      this.participantSid = (c = u.participant) === null || c === void 0 ? void 0 : c.sid;
      const l = this.makeRTCConfiguration(u);
      this.pcManager = new PCTransportManager(l, u.subscriberPrimary, this.loggerOptions), this.emit(EngineEvent.TransportsCreated, this.pcManager.publisher, this.pcManager.subscriber), this.pcManager.onIceCandidate = (v, p) => {
        this.client.sendIceCandidate(v, p);
      }, this.pcManager.onPublisherOffer = (v) => {
        this.client.sendOffer(v);
      }, this.pcManager.onDataChannel = this.handleDataChannel, this.pcManager.onStateChange = (v, p, _) => __awaiter$3(this, void 0, void 0, function* () {
        if (this.log.debug("primary PC state changed ".concat(v), this.logContext), v === PCTransportState.CONNECTED) {
          const D = this.pcState === PCState.New;
          this.pcState = PCState.Connected, D && this.emit(EngineEvent.Connected, u);
        } else
          v === PCTransportState.FAILED && this.pcState === PCState.Connected && (this.pcState = PCState.Disconnected, this.handleDisconnect("peerconnection failed", _ === "failed" ? ReconnectReason.RR_SUBSCRIBER_FAILED : ReconnectReason.RR_PUBLISHER_FAILED));
        const k = this.client.isDisconnected || this.client.currentState === SignalConnectionState.RECONNECTING, O = [PCTransportState.FAILED, PCTransportState.CLOSING, PCTransportState.CLOSED].includes(v);
        k && O && !this._isClosed && this.emit(EngineEvent.Offline);
      }), this.pcManager.onTrack = (v) => {
        this.emit(EngineEvent.MediaTrackAdded, v.track, v.streams[0], v.receiver);
      }, this.createDataChannels();
    });
  }
  setupSignalClientCallbacks() {
    this.client.onAnswer = (u) => __awaiter$3(this, void 0, void 0, function* () {
      this.pcManager && (this.log.debug("received server answer", Object.assign(Object.assign({}, this.logContext), {
        RTCSdpType: u.type
      })), yield this.pcManager.setPublisherAnswer(u));
    }), this.client.onTrickle = (u, c) => {
      this.pcManager && (this.log.trace("got ICE candidate from peer", Object.assign(Object.assign({}, this.logContext), {
        candidate: u,
        target: c
      })), this.pcManager.addIceCandidate(u, c));
    }, this.client.onOffer = (u) => __awaiter$3(this, void 0, void 0, function* () {
      if (!this.pcManager)
        return;
      const c = yield this.pcManager.createSubscriberAnswerFromOffer(u);
      this.client.sendAnswer(c);
    }), this.client.onLocalTrackPublished = (u) => {
      var c;
      if (this.log.debug("received trackPublishedResponse", Object.assign(Object.assign({}, this.logContext), {
        cid: u.cid,
        track: (c = u.track) === null || c === void 0 ? void 0 : c.sid
      })), !this.pendingTrackResolvers[u.cid]) {
        this.log.error("missing track resolver for ".concat(u.cid), Object.assign(Object.assign({}, this.logContext), {
          cid: u.cid
        }));
        return;
      }
      const {
        resolve: l
      } = this.pendingTrackResolvers[u.cid];
      delete this.pendingTrackResolvers[u.cid], l(u.track);
    }, this.client.onLocalTrackUnpublished = (u) => {
      this.emit(EngineEvent.LocalTrackUnpublished, u);
    }, this.client.onTokenRefresh = (u) => {
      this.token = u;
    }, this.client.onRemoteMuteChanged = (u, c) => {
      this.emit(EngineEvent.RemoteMute, u, c);
    }, this.client.onSubscribedQualityUpdate = (u) => {
      this.emit(EngineEvent.SubscribedQualityUpdate, u);
    }, this.client.onClose = () => {
      this.handleDisconnect("signal", ReconnectReason.RR_SIGNAL_DISCONNECTED);
    }, this.client.onLeave = (u) => {
      u != null && u.canReconnect ? (this.fullReconnectOnNext = !0, this.handleDisconnect(leaveReconnect)) : (this.emit(EngineEvent.Disconnected, u == null ? void 0 : u.reason), this.close()), this.log.debug("client leave request", Object.assign(Object.assign({}, this.logContext), {
        reason: u == null ? void 0 : u.reason
      }));
    };
  }
  makeRTCConfiguration(u) {
    var c;
    const l = Object.assign({}, this.rtcConfig);
    if (!((c = this.signalOpts) === null || c === void 0) && c.e2eeEnabled && (this.log.debug("E2EE - setting up transports with insertable streams", this.logContext), l.encodedInsertableStreams = !0), u.iceServers && !l.iceServers) {
      const v = [];
      u.iceServers.forEach((p) => {
        const _ = {
          urls: p.urls
        };
        p.username && (_.username = p.username), p.credential && (_.credential = p.credential), v.push(_);
      }), l.iceServers = v;
    }
    return u.clientConfiguration && u.clientConfiguration.forceRelay === ClientConfigSetting.ENABLED && (l.iceTransportPolicy = "relay"), l.sdpSemantics = "unified-plan", l.continualGatheringPolicy = "gather_continually", l;
  }
  createDataChannels() {
    this.pcManager && (this.lossyDC && (this.lossyDC.onmessage = null, this.lossyDC.onerror = null), this.reliableDC && (this.reliableDC.onmessage = null, this.reliableDC.onerror = null), this.lossyDC = this.pcManager.createPublisherDataChannel(lossyDataChannel, {
      // will drop older packets that arrive
      ordered: !0,
      maxRetransmits: 0
    }), this.reliableDC = this.pcManager.createPublisherDataChannel(reliableDataChannel, {
      ordered: !0
    }), this.lossyDC.onmessage = this.handleDataMessage, this.reliableDC.onmessage = this.handleDataMessage, this.lossyDC.onerror = this.handleDataError, this.reliableDC.onerror = this.handleDataError, this.lossyDC.bufferedAmountLowThreshold = 65535, this.reliableDC.bufferedAmountLowThreshold = 65535, this.lossyDC.onbufferedamountlow = this.handleBufferedAmountLow, this.reliableDC.onbufferedamountlow = this.handleBufferedAmountLow);
  }
  setPreferredCodec(u, c, l) {
    if (!("getCapabilities" in RTCRtpReceiver))
      return;
    const v = RTCRtpReceiver.getCapabilities(c);
    if (!v)
      return;
    this.log.debug("get receiver capabilities", Object.assign(Object.assign({}, this.logContext), {
      cap: v
    }));
    const p = [], _ = [], k = [];
    v.codecs.forEach((O) => {
      const D = O.mimeType.toLowerCase();
      if (D === "audio/opus") {
        p.push(O);
        return;
      }
      if (!(D === "video/".concat(l))) {
        k.push(O);
        return;
      }
      if (l === "h264") {
        O.sdpFmtpLine && O.sdpFmtpLine.includes("profile-level-id=42e01f") ? p.push(O) : _.push(O);
        return;
      }
      p.push(O);
    }), supportsSetCodecPreferences(u) && u.setCodecPreferences(p.concat(_, k));
  }
  createSender(u, c, l) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (supportsTransceiver())
        return yield this.createTransceiverRTCRtpSender(u, c, l);
      if (supportsAddTrack())
        return this.log.warn("using add-track fallback", this.logContext), yield this.createRTCRtpSender(u.mediaStreamTrack);
      throw new UnexpectedConnectionState("Required webRTC APIs not supported on this device");
    });
  }
  createSimulcastSender(u, c, l, v) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (supportsTransceiver())
        return this.createSimulcastTransceiverSender(u, c, l, v);
      if (supportsAddTrack())
        return this.log.debug("using add-track fallback", this.logContext), this.createRTCRtpSender(u.mediaStreamTrack);
      throw new UnexpectedConnectionState("Cannot stream on this device");
    });
  }
  createTransceiverRTCRtpSender(u, c, l) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!this.pcManager)
        throw new UnexpectedConnectionState("publisher is closed");
      const v = [];
      u.mediaStream && v.push(u.mediaStream);
      const p = {
        direction: "sendonly",
        streams: v
      };
      l && (p.sendEncodings = l);
      const _ = yield this.pcManager.addPublisherTransceiver(u.mediaStreamTrack, p);
      return u.kind === Track.Kind.Video && c.videoCodec && (this.setPreferredCodec(_, u.kind, c.videoCodec), u.codec = c.videoCodec), _.sender;
    });
  }
  createSimulcastTransceiverSender(u, c, l, v) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!this.pcManager)
        throw new UnexpectedConnectionState("publisher is closed");
      const p = {
        direction: "sendonly"
      };
      v && (p.sendEncodings = v);
      const _ = yield this.pcManager.addPublisherTransceiver(c.mediaStreamTrack, p);
      if (l.videoCodec)
        return this.setPreferredCodec(_, u.kind, l.videoCodec), u.setSimulcastTrackSender(l.videoCodec, _.sender), _.sender;
    });
  }
  createRTCRtpSender(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!this.pcManager)
        throw new UnexpectedConnectionState("publisher is closed");
      return this.pcManager.addPublisherTrack(u);
    });
  }
  attemptReconnect(u) {
    var c, l, v;
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!this._isClosed) {
        if (this.attemptingReconnect) {
          livekitLogger.warn("already attempting reconnect, returning early", this.logContext);
          return;
        }
        (((c = this.clientConfiguration) === null || c === void 0 ? void 0 : c.resumeConnection) === ClientConfigSetting.DISABLED || // signaling state could change to closed due to hardware sleep
        // those connections cannot be resumed
        ((v = (l = this.pcManager) === null || l === void 0 ? void 0 : l.currentState) !== null && v !== void 0 ? v : PCTransportState.NEW) === PCTransportState.NEW) && (this.fullReconnectOnNext = !0);
        try {
          this.attemptingReconnect = !0, this.fullReconnectOnNext ? yield this.restartConnection() : yield this.resumeConnection(u), this.clearPendingReconnect(), this.fullReconnectOnNext = !1;
        } catch (p) {
          this.reconnectAttempts += 1;
          let _ = !0;
          p instanceof UnexpectedConnectionState ? (this.log.debug("received unrecoverable error", Object.assign(Object.assign({}, this.logContext), {
            error: p
          })), _ = !1) : p instanceof SignalReconnectError || (this.fullReconnectOnNext = !0), _ ? this.handleDisconnect("reconnect", ReconnectReason.RR_UNKNOWN) : (this.log.info("could not recover connection after ".concat(this.reconnectAttempts, " attempts, ").concat(Date.now() - this.reconnectStart, "ms. giving up"), this.logContext), this.emit(EngineEvent.Disconnected), yield this.close());
        } finally {
          this.attemptingReconnect = !1;
        }
      }
    });
  }
  getNextRetryDelay(u) {
    try {
      return this.reconnectPolicy.nextRetryDelayInMs(u);
    } catch (c) {
      this.log.warn("encountered error in reconnect policy", Object.assign(Object.assign({}, this.logContext), {
        error: c
      }));
    }
    return null;
  }
  restartConnection(u) {
    var c, l, v;
    return __awaiter$3(this, void 0, void 0, function* () {
      try {
        if (!this.url || !this.token)
          throw new UnexpectedConnectionState("could not reconnect, url or token not saved");
        this.log.info("reconnecting, attempt: ".concat(this.reconnectAttempts), this.logContext), this.emit(EngineEvent.Restarting), this.client.isDisconnected || (yield this.client.sendLeave()), yield this.cleanupPeerConnections(), yield this.cleanupClient();
        let p;
        try {
          if (!this.signalOpts)
            throw this.log.warn("attempted connection restart, without signal options present", this.logContext), new SignalReconnectError();
          p = yield this.join(u ?? this.url, this.token, this.signalOpts);
        } catch (_) {
          throw _ instanceof ConnectionError && _.reason === 0 ? new UnexpectedConnectionState("could not reconnect, token might be expired") : new SignalReconnectError();
        }
        if (this.shouldFailNext)
          throw this.shouldFailNext = !1, new Error("simulated failure");
        if (this.client.setReconnected(), this.emit(EngineEvent.SignalRestarted, p), yield this.waitForPCReconnected(), this.client.currentState !== SignalConnectionState.CONNECTED)
          throw new SignalReconnectError("Signal connection got severed during reconnect");
        (c = this.regionUrlProvider) === null || c === void 0 || c.resetAttempts(), this.emit(EngineEvent.Restarted);
      } catch (p) {
        const _ = yield (l = this.regionUrlProvider) === null || l === void 0 ? void 0 : l.getNextBestRegionUrl();
        if (_) {
          yield this.restartConnection(_);
          return;
        } else
          throw (v = this.regionUrlProvider) === null || v === void 0 || v.resetAttempts(), p;
      }
    });
  }
  resumeConnection(u) {
    var c;
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!this.url || !this.token)
        throw new UnexpectedConnectionState("could not reconnect, url or token not saved");
      if (!this.pcManager)
        throw new UnexpectedConnectionState("publisher and subscriber connections unset");
      this.log.info("resuming signal connection, attempt ".concat(this.reconnectAttempts), this.logContext), this.emit(EngineEvent.Resuming);
      let l;
      try {
        this.setupSignalClientCallbacks(), l = yield this.client.reconnect(this.url, this.token, this.participantSid, u);
      } catch (v) {
        let p = "";
        throw v instanceof Error && (p = v.message, this.log.error(v.message, Object.assign(Object.assign({}, this.logContext), {
          error: v
        }))), v instanceof ConnectionError && v.reason === 0 ? new UnexpectedConnectionState("could not reconnect, token might be expired") : v instanceof ConnectionError && v.reason === 4 ? v : new SignalReconnectError(p);
      }
      if (this.emit(EngineEvent.SignalResumed), l) {
        const v = this.makeRTCConfiguration(l);
        this.pcManager.updateConfiguration(v);
      } else
        this.log.warn("Did not receive reconnect response", this.logContext);
      if (this.shouldFailNext)
        throw this.shouldFailNext = !1, new Error("simulated failure");
      if (yield this.pcManager.triggerIceRestart(), yield this.waitForPCReconnected(), this.client.currentState !== SignalConnectionState.CONNECTED)
        throw new SignalReconnectError("Signal connection got severed during reconnect");
      this.client.setReconnected(), ((c = this.reliableDC) === null || c === void 0 ? void 0 : c.readyState) === "open" && this.reliableDC.id === null && this.createDataChannels(), this.emit(EngineEvent.Resumed);
    });
  }
  waitForPCInitialConnection(u, c) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!this.pcManager)
        throw new UnexpectedConnectionState("PC manager is closed");
      yield this.pcManager.ensurePCTransportConnection(c, u);
    });
  }
  waitForPCReconnected() {
    return __awaiter$3(this, void 0, void 0, function* () {
      this.pcState = PCState.Reconnecting, this.log.debug("waiting for peer connection to reconnect", this.logContext);
      try {
        if (yield sleep(minReconnectWait), !this.pcManager)
          throw new UnexpectedConnectionState("PC manager is closed");
        yield this.pcManager.ensurePCTransportConnection(void 0, this.peerConnectionTimeout), this.pcState = PCState.Connected;
      } catch (u) {
        throw this.pcState = PCState.Disconnected, new ConnectionError("could not establish PC connection, ".concat(u.message));
      }
    });
  }
  /* @internal */
  sendDataPacket(u, c) {
    return __awaiter$3(this, void 0, void 0, function* () {
      const l = u.toBinary();
      yield this.ensurePublisherConnected(c);
      const v = this.dataChannelForKind(c);
      v && v.send(l), this.updateAndEmitDCBufferStatus(c);
    });
  }
  /**
   * @internal
   */
  ensureDataTransportConnected(u) {
    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.subscriberPrimary;
    var l;
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!this.pcManager)
        throw new UnexpectedConnectionState("PC manager is closed");
      const v = c ? this.pcManager.subscriber : this.pcManager.publisher, p = c ? "Subscriber" : "Publisher";
      if (!v)
        throw new ConnectionError("".concat(p, " connection not set"));
      !c && !this.pcManager.publisher.isICEConnected && this.pcManager.publisher.getICEConnectionState() !== "checking" && this.negotiate();
      const _ = this.dataChannelForKind(u, c);
      if ((_ == null ? void 0 : _.readyState) === "open")
        return;
      const k = (/* @__PURE__ */ new Date()).getTime() + this.peerConnectionTimeout;
      for (; (/* @__PURE__ */ new Date()).getTime() < k; ) {
        if (v.isICEConnected && ((l = this.dataChannelForKind(u, c)) === null || l === void 0 ? void 0 : l.readyState) === "open")
          return;
        yield sleep(50);
      }
      throw new ConnectionError("could not establish ".concat(p, " connection, state: ").concat(v.getICEConnectionState()));
    });
  }
  ensurePublisherConnected(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      yield this.ensureDataTransportConnected(u, !1);
    });
  }
  /* @internal */
  verifyTransport() {
    return !(!this.pcManager || this.pcManager.currentState !== PCTransportState.CONNECTED || !this.client.ws || this.client.ws.readyState === WebSocket.CLOSED);
  }
  /** @internal */
  negotiate() {
    return __awaiter$3(this, void 0, void 0, function* () {
      return new Promise((u, c) => __awaiter$3(this, void 0, void 0, function* () {
        if (!this.pcManager) {
          c(new NegotiationError("PC manager is closed"));
          return;
        }
        this.pcManager.requirePublisher();
        const l = new AbortController(), v = () => {
          l.abort(), this.log.debug("engine disconnected while negotiation was ongoing", this.logContext), u();
        };
        this.isClosed && c("cannot negotiate on closed engine"), this.on(EngineEvent.Closing, v), this.pcManager.publisher.once(PCEvents.RTPVideoPayloadTypes, (p) => {
          const _ = /* @__PURE__ */ new Map();
          p.forEach((k) => {
            const O = k.codec.toLowerCase();
            isVideoCodec(O) && _.set(k.payload, O);
          }), this.emit(EngineEvent.RTPVideoMapUpdate, _);
        });
        try {
          yield this.pcManager.negotiate(l), u();
        } catch (p) {
          p instanceof NegotiationError && (this.fullReconnectOnNext = !0), this.handleDisconnect("negotiation", ReconnectReason.RR_UNKNOWN), c(p);
        } finally {
          this.off(EngineEvent.Closing, v);
        }
      }));
    });
  }
  dataChannelForKind(u, c) {
    if (c) {
      if (u === DataPacket_Kind.LOSSY)
        return this.lossyDCSub;
      if (u === DataPacket_Kind.RELIABLE)
        return this.reliableDCSub;
    } else {
      if (u === DataPacket_Kind.LOSSY)
        return this.lossyDC;
      if (u === DataPacket_Kind.RELIABLE)
        return this.reliableDC;
    }
  }
  /** @internal */
  sendSyncState(u, c) {
    var l, v;
    if (!this.pcManager) {
      this.log.warn("sync state cannot be sent without peer connection setup", this.logContext);
      return;
    }
    const p = this.pcManager.subscriber.getLocalDescription(), _ = this.pcManager.subscriber.getRemoteDescription(), k = (v = (l = this.signalOpts) === null || l === void 0 ? void 0 : l.autoSubscribe) !== null && v !== void 0 ? v : !0, O = new Array(), D = new Array();
    u.forEach((F) => {
      F.isDesired !== k && O.push(F.trackSid), F.isEnabled || D.push(F.trackSid);
    }), this.client.sendSyncState(new SyncState({
      answer: p ? toProtoSessionDescription({
        sdp: p.sdp,
        type: p.type
      }) : void 0,
      offer: _ ? toProtoSessionDescription({
        sdp: _.sdp,
        type: _.type
      }) : void 0,
      subscription: new UpdateSubscription({
        trackSids: O,
        subscribe: !k,
        participantTracks: []
      }),
      publishTracks: getTrackPublicationInfo(c),
      dataChannels: this.dataChannelsInfo(),
      trackSidsDisabled: D
    }));
  }
  /* @internal */
  failNext() {
    this.shouldFailNext = !0;
  }
  dataChannelsInfo() {
    const u = [], c = (l, v) => {
      (l == null ? void 0 : l.id) !== void 0 && l.id !== null && u.push(new DataChannelInfo({
        label: l.label,
        id: l.id,
        target: v
      }));
    };
    return c(this.dataChannelForKind(DataPacket_Kind.LOSSY), SignalTarget.PUBLISHER), c(this.dataChannelForKind(DataPacket_Kind.RELIABLE), SignalTarget.PUBLISHER), c(this.dataChannelForKind(DataPacket_Kind.LOSSY, !0), SignalTarget.SUBSCRIBER), c(this.dataChannelForKind(DataPacket_Kind.RELIABLE, !0), SignalTarget.SUBSCRIBER), u;
  }
  clearReconnectTimeout() {
    this.reconnectTimeout && CriticalTimers.clearTimeout(this.reconnectTimeout);
  }
  clearPendingReconnect() {
    this.clearReconnectTimeout(), this.reconnectAttempts = 0;
  }
  registerOnLineListener() {
    isWeb() && window.addEventListener("online", this.handleBrowserOnLine);
  }
  deregisterOnLineListener() {
    isWeb() && window.removeEventListener("online", this.handleBrowserOnLine);
  }
}
class SignalReconnectError extends Error {
}
class RegionUrlProvider {
  constructor(u, c) {
    this.lastUpdateAt = 0, this.settingsCacheTime = 3e3, this.attemptedRegions = [], this.serverUrl = new URL(u), this.token = c;
  }
  updateToken(u) {
    this.token = u;
  }
  isCloud() {
    return isCloud(this.serverUrl);
  }
  getServerUrl() {
    return this.serverUrl;
  }
  getNextBestRegionUrl(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!this.isCloud())
        throw Error("region availability is only supported for LiveKit Cloud domains");
      (!this.regionSettings || Date.now() - this.lastUpdateAt > this.settingsCacheTime) && (this.regionSettings = yield this.fetchRegionSettings(u));
      const c = this.regionSettings.regions.filter((l) => !this.attemptedRegions.find((v) => v.url === l.url));
      if (c.length > 0) {
        const l = c[0];
        return this.attemptedRegions.push(l), livekitLogger.debug("next region: ".concat(l.region)), l.url;
      } else
        return null;
    });
  }
  resetAttempts() {
    this.attemptedRegions = [];
  }
  /* @internal */
  fetchRegionSettings(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      const c = yield fetch("".concat(getCloudConfigUrl(this.serverUrl), "/regions"), {
        headers: {
          authorization: "Bearer ".concat(this.token)
        },
        signal: u
      });
      if (c.ok) {
        const l = yield c.json();
        return this.lastUpdateAt = Date.now(), l;
      } else
        throw new ConnectionError("Could not fetch region settings: ".concat(c.statusText), c.status === 401 ? 0 : void 0, c.status);
    });
  }
}
function getCloudConfigUrl(a) {
  return "".concat(a.protocol.replace("ws", "http"), "//").concat(a.host, "/settings");
}
const monitorFrequency = 2e3;
function computeBitrate(a, u) {
  if (!u)
    return 0;
  let c, l;
  return "bytesReceived" in a ? (c = a.bytesReceived, l = u.bytesReceived) : "bytesSent" in a && (c = a.bytesSent, l = u.bytesSent), c === void 0 || l === void 0 || a.timestamp === void 0 || u.timestamp === void 0 ? 0 : (c - l) * 8 * 1e3 / (a.timestamp - u.timestamp);
}
class LocalAudioTrack extends LocalTrack {
  /**
   *
   * @param mediaTrack
   * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks
   * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK
   */
  constructor(u, c) {
    let l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0, v = arguments.length > 3 ? arguments[3] : void 0, p = arguments.length > 4 ? arguments[4] : void 0;
    super(u, Track.Kind.Audio, c, l, p), this.stopOnMute = !1, this.monitorSender = () => __awaiter$3(this, void 0, void 0, function* () {
      if (!this.sender) {
        this._currentBitrate = 0;
        return;
      }
      let _;
      try {
        _ = yield this.getSenderStats();
      } catch (k) {
        this.log.error("could not get audio sender stats", Object.assign(Object.assign({}, this.logContext), {
          error: k
        }));
        return;
      }
      _ && this.prevStats && (this._currentBitrate = computeBitrate(_, this.prevStats)), this.prevStats = _;
    }), this.audioContext = v, this.checkForSilence();
  }
  setDeviceId(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this._constraints.deviceId === u && this._mediaStreamTrack.getSettings().deviceId === unwrapConstraint(u) ? !0 : (this._constraints.deviceId = u, this.isMuted || (yield this.restartTrack()), this.isMuted || unwrapConstraint(u) === this._mediaStreamTrack.getSettings().deviceId);
    });
  }
  mute() {
    const u = Object.create(null, {
      mute: {
        get: () => super.mute
      }
    });
    return __awaiter$3(this, void 0, void 0, function* () {
      const c = yield this.muteLock.lock();
      try {
        return this.isMuted ? (this.log.debug("Track already muted", this.logContext), this) : (this.source === Track.Source.Microphone && this.stopOnMute && !this.isUserProvided && (this.log.debug("stopping mic track", this.logContext), this._mediaStreamTrack.stop()), yield u.mute.call(this), this);
      } finally {
        c();
      }
    });
  }
  unmute() {
    const u = Object.create(null, {
      unmute: {
        get: () => super.unmute
      }
    });
    return __awaiter$3(this, void 0, void 0, function* () {
      const c = yield this.muteLock.lock();
      try {
        if (!this.isMuted)
          return this.log.debug("Track already unmuted", this.logContext), this;
        const l = this._constraints.deviceId && this._mediaStreamTrack.getSettings().deviceId !== unwrapConstraint(this._constraints.deviceId);
        return this.source === Track.Source.Microphone && (this.stopOnMute || this._mediaStreamTrack.readyState === "ended" || l) && !this.isUserProvided && (this.log.debug("reacquiring mic track", this.logContext), yield this.restartTrack()), yield u.unmute.call(this), this;
      } finally {
        c();
      }
    });
  }
  restartTrack(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      let c;
      if (u) {
        const l = constraintsForOptions({
          audio: u
        });
        typeof l.audio != "boolean" && (c = l.audio);
      }
      yield this.restart(c);
    });
  }
  restart(u) {
    const c = Object.create(null, {
      restart: {
        get: () => super.restart
      }
    });
    return __awaiter$3(this, void 0, void 0, function* () {
      const l = yield c.restart.call(this, u);
      return this.checkForSilence(), l;
    });
  }
  /* @internal */
  startMonitor() {
    isWeb() && (this.monitorInterval || (this.monitorInterval = setInterval(() => {
      this.monitorSender();
    }, monitorFrequency)));
  }
  setProcessor(u) {
    var c;
    return __awaiter$3(this, void 0, void 0, function* () {
      const l = yield this.processorLock.lock();
      try {
        if (!this.audioContext)
          throw Error("Audio context needs to be set on LocalAudioTrack in order to enable processors");
        this.processor && (yield this.stopProcessor());
        const v = {
          kind: this.kind,
          track: this._mediaStreamTrack,
          audioContext: this.audioContext
        };
        this.log.debug("setting up audio processor ".concat(u.name), this.logContext), yield u.init(v), this.processor = u, this.processor.processedTrack && (yield (c = this.sender) === null || c === void 0 ? void 0 : c.replaceTrack(this.processor.processedTrack)), this.emit(TrackEvent.TrackProcessorUpdate, this.processor);
      } finally {
        l();
      }
    });
  }
  /**
   * @internal
   * @experimental
   */
  setAudioContext(u) {
    this.audioContext = u;
  }
  getSenderStats() {
    var u;
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!(!((u = this.sender) === null || u === void 0) && u.getStats))
        return;
      const c = yield this.sender.getStats();
      let l;
      return c.forEach((v) => {
        v.type === "outbound-rtp" && (l = {
          type: "audio",
          streamId: v.id,
          packetsSent: v.packetsSent,
          packetsLost: v.packetsLost,
          bytesSent: v.bytesSent,
          timestamp: v.timestamp,
          roundTripTime: v.roundTripTime,
          jitter: v.jitter
        });
      }), l;
    });
  }
  checkForSilence() {
    return __awaiter$3(this, void 0, void 0, function* () {
      const u = yield detectSilence(this);
      return u && (this.isMuted || this.log.warn("silence detected on local audio track", this.logContext), this.emit(TrackEvent.AudioSilenceDetected)), u;
    });
  }
}
function mediaTrackToLocalTrack(a, u, c) {
  switch (a.kind) {
    case "audio":
      return new LocalAudioTrack(a, u, !1, void 0, c);
    case "video":
      return new LocalVideoTrack(a, u, !1, c);
    default:
      throw new TrackInvalidError("unsupported track type: ".concat(a.kind));
  }
}
const presets169 = Object.values(VideoPresets), presets43 = Object.values(VideoPresets43), presetsScreenShare = Object.values(ScreenSharePresets), defaultSimulcastPresets169 = [VideoPresets.h180, VideoPresets.h360], defaultSimulcastPresets43 = [VideoPresets43.h180, VideoPresets43.h360], computeDefaultScreenShareSimulcastPresets = (a) => [{
  scaleResolutionDownBy: 2,
  fps: a.encoding.maxFramerate
}].map((c) => {
  var l, v;
  return new VideoPreset(Math.floor(a.width / c.scaleResolutionDownBy), Math.floor(a.height / c.scaleResolutionDownBy), Math.max(15e4, Math.floor(a.encoding.maxBitrate / (Math.pow(c.scaleResolutionDownBy, 2) * (((l = a.encoding.maxFramerate) !== null && l !== void 0 ? l : 30) / ((v = c.fps) !== null && v !== void 0 ? v : 30))))), c.fps, a.encoding.priority);
}), videoRids = ["q", "h", "f"];
function computeVideoEncodings(a, u, c, l) {
  var v, p;
  let _ = l == null ? void 0 : l.videoEncoding;
  a && (_ = l == null ? void 0 : l.screenShareEncoding);
  const k = l == null ? void 0 : l.simulcast, O = l == null ? void 0 : l.scalabilityMode, D = l == null ? void 0 : l.videoCodec;
  if (!_ && !k && !O || !u || !c)
    return [{}];
  _ || (_ = determineAppropriateEncoding(a, u, c, D), livekitLogger.debug("using video encoding", _));
  const F = new VideoPreset(u, c, _.maxBitrate, _.maxFramerate, _.priority);
  if (O && isSVCCodec(D)) {
    const ee = new ScalabilityMode(O), X = [];
    if (ee.spatial > 3)
      throw new Error("unsupported scalabilityMode: ".concat(O));
    const ae = getBrowser();
    if (isSafari() || (ae == null ? void 0 : ae.name) === "Chrome" && compareVersions(ae == null ? void 0 : ae.version, "113") < 0) {
      for (let Q = 0; Q < ee.spatial; Q += 1)
        X.push({
          rid: videoRids[2 - Q],
          maxBitrate: _.maxBitrate / Math.pow(3, Q),
          maxFramerate: F.encoding.maxFramerate
        });
      X[0].scalabilityMode = O;
    } else
      X.push({
        maxBitrate: _.maxBitrate,
        maxFramerate: F.encoding.maxFramerate,
        /* @ts-ignore */
        scalabilityMode: O
      });
    return livekitLogger.debug("using svc encoding", {
      encodings: X
    }), X;
  }
  if (!k)
    return [_];
  let z = [];
  a ? z = (v = sortPresets(l == null ? void 0 : l.screenShareSimulcastLayers)) !== null && v !== void 0 ? v : defaultSimulcastLayers(a, F) : z = (p = sortPresets(l == null ? void 0 : l.videoSimulcastLayers)) !== null && p !== void 0 ? p : defaultSimulcastLayers(a, F);
  let j;
  if (z.length > 0) {
    const ee = z[0];
    z.length > 1 && ([, j] = z);
    const X = Math.max(u, c);
    if (X >= 960 && j)
      return encodingsFromPresets(u, c, [ee, j, F]);
    if (X >= 480)
      return encodingsFromPresets(u, c, [ee, F]);
  }
  return encodingsFromPresets(u, c, [F]);
}
function computeTrackBackupEncodings(a, u, c) {
  var l, v, p, _;
  if (!c.backupCodec || c.backupCodec === !0 || c.backupCodec.codec === c.videoCodec)
    return;
  u !== c.backupCodec.codec && livekitLogger.warn("requested a different codec than specified as backup", {
    serverRequested: u,
    backup: c.backupCodec.codec
  }), c.videoCodec = u, c.videoEncoding = c.backupCodec.encoding;
  const k = a.mediaStreamTrack.getSettings(), O = (l = k.width) !== null && l !== void 0 ? l : (v = a.dimensions) === null || v === void 0 ? void 0 : v.width, D = (p = k.height) !== null && p !== void 0 ? p : (_ = a.dimensions) === null || _ === void 0 ? void 0 : _.height;
  return computeVideoEncodings(a.source === Track.Source.ScreenShare, O, D, c);
}
function determineAppropriateEncoding(a, u, c, l) {
  const v = presetsForResolution(a, u, c);
  let {
    encoding: p
  } = v[0];
  const _ = Math.max(u, c);
  for (let k = 0; k < v.length; k += 1) {
    const O = v[k];
    if (p = O.encoding, O.width >= _)
      break;
  }
  if (l)
    switch (l) {
      case "av1":
        p = Object.assign({}, p), p.maxBitrate = p.maxBitrate * 0.7;
        break;
      case "vp9":
        p = Object.assign({}, p), p.maxBitrate = p.maxBitrate * 0.85;
        break;
    }
  return p;
}
function presetsForResolution(a, u, c) {
  if (a)
    return presetsScreenShare;
  const l = u > c ? u / c : c / u;
  return Math.abs(l - 16 / 9) < Math.abs(l - 4 / 3) ? presets169 : presets43;
}
function defaultSimulcastLayers(a, u) {
  if (a)
    return computeDefaultScreenShareSimulcastPresets(u);
  const {
    width: c,
    height: l
  } = u, v = c > l ? c / l : l / c;
  return Math.abs(v - 16 / 9) < Math.abs(v - 4 / 3) ? defaultSimulcastPresets169 : defaultSimulcastPresets43;
}
function encodingsFromPresets(a, u, c) {
  const l = [];
  if (c.forEach((v, p) => {
    if (p >= videoRids.length)
      return;
    const _ = Math.min(a, u), O = {
      rid: videoRids[p],
      scaleResolutionDownBy: Math.max(1, _ / Math.min(v.width, v.height)),
      maxBitrate: v.encoding.maxBitrate
    };
    v.encoding.maxFramerate && (O.maxFramerate = v.encoding.maxFramerate);
    const D = isFireFox() || p === 0;
    v.encoding.priority && D && (O.priority = v.encoding.priority, O.networkPriority = v.encoding.priority), l.push(O);
  }), isReactNative() && getReactNativeOs() === "ios") {
    let v;
    l.forEach((_) => {
      v ? _.maxFramerate && _.maxFramerate > v && (v = _.maxFramerate) : v = _.maxFramerate;
    });
    let p = !0;
    l.forEach((_) => {
      var k;
      _.maxFramerate != v && (p && (p = !1, livekitLogger.info("Simulcast on iOS React-Native requires all encodings to share the same framerate.")), livekitLogger.info('Setting framerate of encoding "'.concat((k = _.rid) !== null && k !== void 0 ? k : "", '" to ').concat(v)), _.maxFramerate = v);
    });
  }
  return l;
}
function sortPresets(a) {
  if (a)
    return a.sort((u, c) => {
      const {
        encoding: l
      } = u, {
        encoding: v
      } = c;
      return l.maxBitrate > v.maxBitrate ? 1 : l.maxBitrate < v.maxBitrate ? -1 : l.maxBitrate === v.maxBitrate && l.maxFramerate && v.maxFramerate ? l.maxFramerate > v.maxFramerate ? 1 : -1 : 0;
    });
}
class ScalabilityMode {
  constructor(u) {
    const c = u.match(/^L(\d)T(\d)(h|_KEY|_KEY_SHIFT){0,1}$/);
    if (!c)
      throw new Error("invalid scalability mode");
    if (this.spatial = parseInt(c[1]), this.temporal = parseInt(c[2]), c.length > 3)
      switch (c[3]) {
        case "h":
        case "_KEY":
        case "_KEY_SHIFT":
          this.suffix = c[3];
      }
  }
  toString() {
    var u;
    return "L".concat(this.spatial, "T").concat(this.temporal).concat((u = this.suffix) !== null && u !== void 0 ? u : "");
  }
}
const refreshSubscribedCodecAfterNewCodec = 5e3;
class LocalVideoTrack extends LocalTrack {
  /**
   *
   * @param mediaTrack
   * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks
   * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK
   */
  constructor(u, c) {
    let l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0, v = arguments.length > 3 ? arguments[3] : void 0;
    super(u, Track.Kind.Video, c, l, v), this.simulcastCodecs = /* @__PURE__ */ new Map(), this.monitorSender = () => __awaiter$3(this, void 0, void 0, function* () {
      if (!this.sender) {
        this._currentBitrate = 0;
        return;
      }
      let p;
      try {
        p = yield this.getSenderStats();
      } catch (k) {
        this.log.error("could not get audio sender stats", Object.assign(Object.assign({}, this.logContext), {
          error: k
        }));
        return;
      }
      const _ = new Map(p.map((k) => [k.rid, k]));
      if (this.prevStats) {
        let k = 0;
        _.forEach((O, D) => {
          var F;
          const z = (F = this.prevStats) === null || F === void 0 ? void 0 : F.get(D);
          k += computeBitrate(O, z);
        }), this._currentBitrate = k;
      }
      this.prevStats = _;
    }), this.senderLock = new Mutex();
  }
  get isSimulcast() {
    return !!(this.sender && this.sender.getParameters().encodings.length > 1);
  }
  /* @internal */
  startMonitor(u) {
    var c;
    if (this.signalClient = u, !isWeb())
      return;
    const l = (c = this.sender) === null || c === void 0 ? void 0 : c.getParameters();
    l && (this.encodings = l.encodings), !this.monitorInterval && (this.monitorInterval = setInterval(() => {
      this.monitorSender();
    }, monitorFrequency));
  }
  stop() {
    this._mediaStreamTrack.getConstraints(), this.simulcastCodecs.forEach((u) => {
      u.mediaStreamTrack.stop();
    }), super.stop();
  }
  pauseUpstream() {
    const u = Object.create(null, {
      pauseUpstream: {
        get: () => super.pauseUpstream
      }
    });
    var c, l, v, p, _;
    return __awaiter$3(this, void 0, void 0, function* () {
      yield u.pauseUpstream.call(this);
      try {
        for (var k = !0, O = __asyncValues(this.simulcastCodecs.values()), D; D = yield O.next(), c = D.done, !c; k = !0)
          p = D.value, k = !1, yield (_ = p.sender) === null || _ === void 0 ? void 0 : _.replaceTrack(null);
      } catch (F) {
        l = {
          error: F
        };
      } finally {
        try {
          !k && !c && (v = O.return) && (yield v.call(O));
        } finally {
          if (l)
            throw l.error;
        }
      }
    });
  }
  resumeUpstream() {
    const u = Object.create(null, {
      resumeUpstream: {
        get: () => super.resumeUpstream
      }
    });
    var c, l, v, p, _;
    return __awaiter$3(this, void 0, void 0, function* () {
      yield u.resumeUpstream.call(this);
      try {
        for (var k = !0, O = __asyncValues(this.simulcastCodecs.values()), D; D = yield O.next(), c = D.done, !c; k = !0) {
          p = D.value, k = !1;
          const F = p;
          yield (_ = F.sender) === null || _ === void 0 ? void 0 : _.replaceTrack(F.mediaStreamTrack);
        }
      } catch (F) {
        l = {
          error: F
        };
      } finally {
        try {
          !k && !c && (v = O.return) && (yield v.call(O));
        } finally {
          if (l)
            throw l.error;
        }
      }
    });
  }
  mute() {
    const u = Object.create(null, {
      mute: {
        get: () => super.mute
      }
    });
    return __awaiter$3(this, void 0, void 0, function* () {
      const c = yield this.muteLock.lock();
      try {
        return this.isMuted ? (this.log.debug("Track already muted", this.logContext), this) : (this.source === Track.Source.Camera && !this.isUserProvided && (this.log.debug("stopping camera track", this.logContext), this._mediaStreamTrack.stop()), yield u.mute.call(this), this);
      } finally {
        c();
      }
    });
  }
  unmute() {
    const u = Object.create(null, {
      unmute: {
        get: () => super.unmute
      }
    });
    return __awaiter$3(this, void 0, void 0, function* () {
      const c = yield this.muteLock.lock();
      try {
        return this.isMuted ? (this.source === Track.Source.Camera && !this.isUserProvided && (this.log.debug("reacquiring camera track", this.logContext), yield this.restartTrack()), yield u.unmute.call(this), this) : (this.log.debug("Track already unmuted", this.logContext), this);
      } finally {
        c();
      }
    });
  }
  setTrackMuted(u) {
    super.setTrackMuted(u);
    for (const c of this.simulcastCodecs.values())
      c.mediaStreamTrack.enabled = !u;
  }
  getSenderStats() {
    var u;
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!(!((u = this.sender) === null || u === void 0) && u.getStats))
        return [];
      const c = [], l = yield this.sender.getStats();
      return l.forEach((v) => {
        var p;
        if (v.type === "outbound-rtp") {
          const _ = {
            type: "video",
            streamId: v.id,
            frameHeight: v.frameHeight,
            frameWidth: v.frameWidth,
            framesPerSecond: v.framesPerSecond,
            framesSent: v.framesSent,
            firCount: v.firCount,
            pliCount: v.pliCount,
            nackCount: v.nackCount,
            packetsSent: v.packetsSent,
            bytesSent: v.bytesSent,
            qualityLimitationReason: v.qualityLimitationReason,
            qualityLimitationDurations: v.qualityLimitationDurations,
            qualityLimitationResolutionChanges: v.qualityLimitationResolutionChanges,
            rid: (p = v.rid) !== null && p !== void 0 ? p : v.id,
            retransmittedPacketsSent: v.retransmittedPacketsSent,
            targetBitrate: v.targetBitrate,
            timestamp: v.timestamp
          }, k = l.get(v.remoteId);
          k && (_.jitter = k.jitter, _.packetsLost = k.packetsLost, _.roundTripTime = k.roundTripTime), c.push(_);
        }
      }), c.sort((v, p) => {
        var _, k;
        return ((_ = p.frameWidth) !== null && _ !== void 0 ? _ : 0) - ((k = v.frameWidth) !== null && k !== void 0 ? k : 0);
      }), c;
    });
  }
  setPublishingQuality(u) {
    const c = [];
    for (let l = VideoQuality.LOW; l <= VideoQuality.HIGH; l += 1)
      c.push(new SubscribedQuality({
        quality: l,
        enabled: l <= u
      }));
    this.log.debug("setting publishing quality. max quality ".concat(u), this.logContext), this.setPublishingLayers(c);
  }
  setDeviceId(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this._constraints.deviceId === u && this._mediaStreamTrack.getSettings().deviceId === unwrapConstraint(u) ? !0 : (this._constraints.deviceId = u, this.isMuted || (yield this.restartTrack()), this.isMuted || unwrapConstraint(u) === this._mediaStreamTrack.getSettings().deviceId);
    });
  }
  restartTrack(u) {
    var c, l, v, p;
    return __awaiter$3(this, void 0, void 0, function* () {
      let _;
      if (u) {
        const F = constraintsForOptions({
          video: u
        });
        typeof F.video != "boolean" && (_ = F.video);
      }
      yield this.restart(_);
      try {
        for (var k = !0, O = __asyncValues(this.simulcastCodecs.values()), D; D = yield O.next(), c = D.done, !c; k = !0) {
          p = D.value, k = !1;
          const F = p;
          F.sender && (F.mediaStreamTrack = this.mediaStreamTrack.clone(), yield F.sender.replaceTrack(F.mediaStreamTrack));
        }
      } catch (F) {
        l = {
          error: F
        };
      } finally {
        try {
          !k && !c && (v = O.return) && (yield v.call(O));
        } finally {
          if (l)
            throw l.error;
        }
      }
    });
  }
  setProcessor(u) {
    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
    const l = Object.create(null, {
      setProcessor: {
        get: () => super.setProcessor
      }
    });
    var v, p, _, k, O, D;
    return __awaiter$3(this, void 0, void 0, function* () {
      if (yield l.setProcessor.call(this, u, c), !((O = this.processor) === null || O === void 0) && O.processedTrack)
        try {
          for (var F = !0, z = __asyncValues(this.simulcastCodecs.values()), j; j = yield z.next(), v = j.done, !v; F = !0)
            k = j.value, F = !1, yield (D = k.sender) === null || D === void 0 ? void 0 : D.replaceTrack(this.processor.processedTrack);
        } catch (ee) {
          p = {
            error: ee
          };
        } finally {
          try {
            !F && !v && (_ = z.return) && (yield _.call(z));
          } finally {
            if (p)
              throw p.error;
          }
        }
    });
  }
  addSimulcastTrack(u, c) {
    if (this.simulcastCodecs.has(u)) {
      this.log.error("".concat(u, " already added, skipping adding simulcast codec"), this.logContext);
      return;
    }
    const l = {
      codec: u,
      mediaStreamTrack: this.mediaStreamTrack.clone(),
      sender: void 0,
      encodings: c
    };
    return this.simulcastCodecs.set(u, l), l;
  }
  setSimulcastTrackSender(u, c) {
    const l = this.simulcastCodecs.get(u);
    l && (l.sender = c, setTimeout(() => {
      this.subscribedCodecs && this.setPublishingCodecs(this.subscribedCodecs);
    }, refreshSubscribedCodecAfterNewCodec));
  }
  /**
   * @internal
   * Sets codecs that should be publishing, returns new codecs that have not yet
   * been published
   */
  setPublishingCodecs(u) {
    var c, l, v, p, _, k, O;
    return __awaiter$3(this, void 0, void 0, function* () {
      if (this.log.debug("setting publishing codecs", Object.assign(Object.assign({}, this.logContext), {
        codecs: u,
        currentCodec: this.codec
      })), !this.codec && u.length > 0)
        return yield this.setPublishingLayers(u[0].qualities), [];
      this.subscribedCodecs = u;
      const D = [];
      try {
        for (c = !0, l = __asyncValues(u); v = yield l.next(), p = v.done, !p; c = !0) {
          O = v.value, c = !1;
          const F = O;
          if (!this.codec || this.codec === F.codec)
            yield this.setPublishingLayers(F.qualities);
          else {
            const z = this.simulcastCodecs.get(F.codec);
            if (this.log.debug("try setPublishingCodec for ".concat(F.codec), Object.assign(Object.assign({}, this.logContext), {
              simulcastCodecInfo: z
            })), !z || !z.sender) {
              for (const j of F.qualities)
                if (j.enabled) {
                  D.push(F.codec);
                  break;
                }
            } else
              z.encodings && (this.log.debug("try setPublishingLayersForSender ".concat(F.codec), this.logContext), yield setPublishingLayersForSender(z.sender, z.encodings, F.qualities, this.senderLock, this.log, this.logContext));
          }
        }
      } catch (F) {
        _ = {
          error: F
        };
      } finally {
        try {
          !c && !p && (k = l.return) && (yield k.call(l));
        } finally {
          if (_)
            throw _.error;
        }
      }
      return D;
    });
  }
  /**
   * @internal
   * Sets layers that should be publishing
   */
  setPublishingLayers(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      this.log.debug("setting publishing layers", Object.assign(Object.assign({}, this.logContext), {
        qualities: u
      })), !(!this.sender || !this.encodings) && (yield setPublishingLayersForSender(this.sender, this.encodings, u, this.senderLock, this.log, this.logContext));
    });
  }
  handleAppVisibilityChanged() {
    const u = Object.create(null, {
      handleAppVisibilityChanged: {
        get: () => super.handleAppVisibilityChanged
      }
    });
    return __awaiter$3(this, void 0, void 0, function* () {
      yield u.handleAppVisibilityChanged.call(this), isMobile() && this.isInBackground && this.source === Track.Source.Camera && (this._mediaStreamTrack.enabled = !1);
    });
  }
}
function setPublishingLayersForSender(a, u, c, l, v, p) {
  return __awaiter$3(this, void 0, void 0, function* () {
    const _ = yield l.lock();
    v.debug("setPublishingLayersForSender", Object.assign(Object.assign({}, p), {
      sender: a,
      qualities: c,
      senderEncodings: u
    }));
    try {
      const k = a.getParameters(), {
        encodings: O
      } = k;
      if (!O)
        return;
      if (O.length !== u.length) {
        v.warn("cannot set publishing layers, encodings mismatch", Object.assign(Object.assign({}, p), {
          encodings: O,
          senderEncodings: u
        }));
        return;
      }
      let D = !1;
      !1 && O[0].scalabilityMode || O.forEach((z, j) => {
        var ee;
        let X = (ee = z.rid) !== null && ee !== void 0 ? ee : "";
        X === "" && (X = "q");
        const ae = videoQualityForRid(X), Q = c.find((ne) => ne.quality === ae);
        Q && z.active !== Q.enabled && (D = !0, z.active = Q.enabled, v.debug("setting layer ".concat(Q.quality, " to ").concat(z.active ? "enabled" : "disabled"), p), isFireFox() && (Q.enabled ? (z.scaleResolutionDownBy = u[j].scaleResolutionDownBy, z.maxBitrate = u[j].maxBitrate, z.maxFrameRate = u[j].maxFrameRate) : (z.scaleResolutionDownBy = 4, z.maxBitrate = 10, z.maxFrameRate = 2)));
      }), D && (k.encodings = O, v.debug("setting encodings", Object.assign(Object.assign({}, p), {
        encodings: k.encodings
      })), yield a.setParameters(k));
    } finally {
      _();
    }
  });
}
function videoQualityForRid(a) {
  switch (a) {
    case "f":
      return VideoQuality.HIGH;
    case "h":
      return VideoQuality.MEDIUM;
    case "q":
      return VideoQuality.LOW;
    default:
      return VideoQuality.HIGH;
  }
}
function videoLayersFromEncodings(a, u, c, l) {
  if (!c)
    return [new VideoLayer({
      quality: VideoQuality.HIGH,
      width: a,
      height: u,
      bitrate: 0,
      ssrc: 0
    })];
  if (l) {
    const v = c[0].scalabilityMode, p = new ScalabilityMode(v), _ = [];
    for (let k = 0; k < p.spatial; k += 1)
      _.push(new VideoLayer({
        quality: VideoQuality.HIGH - k,
        width: Math.ceil(a / Math.pow(2, k)),
        height: Math.ceil(u / Math.pow(2, k)),
        bitrate: c[0].maxBitrate ? Math.ceil(c[0].maxBitrate / Math.pow(3, k)) : 0,
        ssrc: 0
      }));
    return _;
  }
  return c.map((v) => {
    var p, _, k;
    const O = (p = v.scaleResolutionDownBy) !== null && p !== void 0 ? p : 1;
    let D = videoQualityForRid((_ = v.rid) !== null && _ !== void 0 ? _ : "");
    return new VideoLayer({
      quality: D,
      width: Math.ceil(a / O),
      height: Math.ceil(u / O),
      bitrate: (k = v.maxBitrate) !== null && k !== void 0 ? k : 0,
      ssrc: 0
    });
  });
}
class RemoteTrack extends Track {
  constructor(u, c, l, v, p) {
    super(u, l, p), this.sid = c, this.receiver = v;
  }
  /** @internal */
  setMuted(u) {
    this.isMuted !== u && (this.isMuted = u, this._mediaStreamTrack.enabled = !u, this.emit(u ? TrackEvent.Muted : TrackEvent.Unmuted, this));
  }
  /** @internal */
  setMediaStream(u) {
    this.mediaStream = u;
    const c = (l) => {
      l.track === this._mediaStreamTrack && (u.removeEventListener("removetrack", c), this.receiver = void 0, this._currentBitrate = 0, this.emit(TrackEvent.Ended, this));
    };
    u.addEventListener("removetrack", c);
  }
  start() {
    this.startMonitor(), super.enable();
  }
  stop() {
    this.stopMonitor(), super.disable();
  }
  /**
   * Gets the RTCStatsReport for the RemoteTrack's underlying RTCRtpReceiver
   * See https://developer.mozilla.org/en-US/docs/Web/API/RTCStatsReport
   *
   * @returns Promise<RTCStatsReport> | undefined
   */
  getRTCStatsReport() {
    var u;
    return __awaiter$3(this, void 0, void 0, function* () {
      return !((u = this.receiver) === null || u === void 0) && u.getStats ? yield this.receiver.getStats() : void 0;
    });
  }
  /* @internal */
  startMonitor() {
    this.monitorInterval || (this.monitorInterval = setInterval(() => this.monitorReceiver(), monitorFrequency));
  }
}
class RemoteAudioTrack extends RemoteTrack {
  constructor(u, c, l, v, p, _) {
    super(u, c, Track.Kind.Audio, l, _), this.monitorReceiver = () => __awaiter$3(this, void 0, void 0, function* () {
      if (!this.receiver) {
        this._currentBitrate = 0;
        return;
      }
      const k = yield this.getReceiverStats();
      k && this.prevStats && this.receiver && (this._currentBitrate = computeBitrate(k, this.prevStats)), this.prevStats = k;
    }), this.audioContext = v, this.webAudioPluginNodes = [], p && (this.sinkId = p.deviceId);
  }
  /**
   * sets the volume for all attached audio elements
   */
  setVolume(u) {
    var c;
    for (const l of this.attachedElements)
      this.audioContext ? (c = this.gainNode) === null || c === void 0 || c.gain.setTargetAtTime(u, 0, 0.1) : l.volume = u;
    isReactNative() && this._mediaStreamTrack._setVolume(u), this.elementVolume = u;
  }
  /**
   * gets the volume of attached audio elements (loudest)
   */
  getVolume() {
    if (this.elementVolume)
      return this.elementVolume;
    if (isReactNative())
      return 1;
    let u = 0;
    return this.attachedElements.forEach((c) => {
      c.volume > u && (u = c.volume);
    }), u;
  }
  /**
   * calls setSinkId on all attached elements, if supported
   * @param deviceId audio output device
   */
  setSinkId(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      this.sinkId = u, yield Promise.all(this.attachedElements.map((c) => {
        if (supportsSetSinkId(c))
          return c.setSinkId(u);
      }));
    });
  }
  attach(u) {
    const c = this.attachedElements.length === 0;
    return u ? super.attach(u) : u = super.attach(), this.sinkId && supportsSetSinkId(u) && u.setSinkId(this.sinkId), this.audioContext && c && (this.log.debug("using audio context mapping", this.logContext), this.connectWebAudio(this.audioContext, u), u.volume = 0, u.muted = !0), this.elementVolume && this.setVolume(this.elementVolume), u;
  }
  detach(u) {
    let c;
    return u ? (c = super.detach(u), this.audioContext && (this.attachedElements.length > 0 ? this.connectWebAudio(this.audioContext, this.attachedElements[0]) : this.disconnectWebAudio())) : (c = super.detach(), this.disconnectWebAudio()), c;
  }
  /**
   * @internal
   * @experimental
   */
  setAudioContext(u) {
    this.audioContext = u, u && this.attachedElements.length > 0 ? this.connectWebAudio(u, this.attachedElements[0]) : u || this.disconnectWebAudio();
  }
  /**
   * @internal
   * @experimental
   * @param {AudioNode[]} nodes - An array of WebAudio nodes. These nodes should not be connected to each other when passed, as the sdk will take care of connecting them in the order of the array.
   */
  setWebAudioPlugins(u) {
    this.webAudioPluginNodes = u, this.attachedElements.length > 0 && this.audioContext && this.connectWebAudio(this.audioContext, this.attachedElements[0]);
  }
  connectWebAudio(u, c) {
    this.disconnectWebAudio(), this.sourceNode = u.createMediaStreamSource(c.srcObject);
    let l = this.sourceNode;
    this.webAudioPluginNodes.forEach((v) => {
      l.connect(v), l = v;
    }), this.gainNode = u.createGain(), l.connect(this.gainNode), this.gainNode.connect(u.destination), this.elementVolume && this.gainNode.gain.setTargetAtTime(this.elementVolume, 0, 0.1), u.state !== "running" && u.resume().then(() => {
      u.state !== "running" && this.emit(TrackEvent.AudioPlaybackFailed, new Error("Audio Context couldn't be started automatically"));
    }).catch((v) => {
      this.emit(TrackEvent.AudioPlaybackFailed, v);
    });
  }
  disconnectWebAudio() {
    var u, c;
    (u = this.gainNode) === null || u === void 0 || u.disconnect(), (c = this.sourceNode) === null || c === void 0 || c.disconnect(), this.gainNode = void 0, this.sourceNode = void 0;
  }
  getReceiverStats() {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!this.receiver || !this.receiver.getStats)
        return;
      const u = yield this.receiver.getStats();
      let c;
      return u.forEach((l) => {
        l.type === "inbound-rtp" && (c = {
          type: "audio",
          timestamp: l.timestamp,
          jitter: l.jitter,
          bytesReceived: l.bytesReceived,
          concealedSamples: l.concealedSamples,
          concealmentEvents: l.concealmentEvents,
          silentConcealedSamples: l.silentConcealedSamples,
          silentConcealmentEvents: l.silentConcealmentEvents,
          totalAudioEnergy: l.totalAudioEnergy,
          totalSamplesDuration: l.totalSamplesDuration
        });
      }), c;
    });
  }
}
const REACTION_DELAY = 100;
class RemoteVideoTrack extends RemoteTrack {
  constructor(u, c, l, v, p) {
    super(u, c, Track.Kind.Video, l, p), this.elementInfos = [], this.monitorReceiver = () => __awaiter$3(this, void 0, void 0, function* () {
      if (!this.receiver) {
        this._currentBitrate = 0;
        return;
      }
      const _ = yield this.getReceiverStats();
      _ && this.prevStats && this.receiver && (this._currentBitrate = computeBitrate(_, this.prevStats)), this.prevStats = _;
    }), this.debouncedHandleResize = r$1(() => {
      this.updateDimensions();
    }, REACTION_DELAY), this.adaptiveStreamSettings = v;
  }
  get isAdaptiveStream() {
    return this.adaptiveStreamSettings !== void 0;
  }
  /**
   * Note: When using adaptiveStream, you need to use remoteVideoTrack.attach() to add the track to a HTMLVideoElement, otherwise your video tracks might never start
   */
  get mediaStreamTrack() {
    return this._mediaStreamTrack;
  }
  /** @internal */
  setMuted(u) {
    super.setMuted(u), this.attachedElements.forEach((c) => {
      u ? detachTrack(this._mediaStreamTrack, c) : attachToElement(this._mediaStreamTrack, c);
    });
  }
  attach(u) {
    if (u ? super.attach(u) : u = super.attach(), this.adaptiveStreamSettings && this.elementInfos.find((c) => c.element === u) === void 0) {
      const c = new HTMLElementInfo(u);
      this.observeElementInfo(c);
    }
    return u;
  }
  /**
   * Observe an ElementInfo for changes when adaptive streaming.
   * @param elementInfo
   * @internal
   */
  observeElementInfo(u) {
    this.adaptiveStreamSettings && this.elementInfos.find((c) => c === u) === void 0 ? (u.handleResize = () => {
      this.debouncedHandleResize();
    }, u.handleVisibilityChanged = () => {
      this.updateVisibility();
    }, this.elementInfos.push(u), u.observe(), this.debouncedHandleResize(), this.updateVisibility()) : this.log.warn("visibility resize observer not triggered", this.logContext);
  }
  /**
   * Stop observing an ElementInfo for changes.
   * @param elementInfo
   * @internal
   */
  stopObservingElementInfo(u) {
    if (!this.isAdaptiveStream) {
      this.log.warn("stopObservingElementInfo ignored", this.logContext);
      return;
    }
    const c = this.elementInfos.filter((l) => l === u);
    for (const l of c)
      l.stopObserving();
    this.elementInfos = this.elementInfos.filter((l) => l !== u), this.updateVisibility(), this.debouncedHandleResize();
  }
  detach(u) {
    let c = [];
    if (u)
      return this.stopObservingElement(u), super.detach(u);
    c = super.detach();
    for (const l of c)
      this.stopObservingElement(l);
    return c;
  }
  /** @internal */
  getDecoderImplementation() {
    var u;
    return (u = this.prevStats) === null || u === void 0 ? void 0 : u.decoderImplementation;
  }
  getReceiverStats() {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!this.receiver || !this.receiver.getStats)
        return;
      const u = yield this.receiver.getStats();
      let c, l = "", v = /* @__PURE__ */ new Map();
      return u.forEach((p) => {
        p.type === "inbound-rtp" ? (l = p.codecId, c = {
          type: "video",
          framesDecoded: p.framesDecoded,
          framesDropped: p.framesDropped,
          framesReceived: p.framesReceived,
          packetsReceived: p.packetsReceived,
          packetsLost: p.packetsLost,
          frameWidth: p.frameWidth,
          frameHeight: p.frameHeight,
          pliCount: p.pliCount,
          firCount: p.firCount,
          nackCount: p.nackCount,
          jitter: p.jitter,
          timestamp: p.timestamp,
          bytesReceived: p.bytesReceived,
          decoderImplementation: p.decoderImplementation
        }) : p.type === "codec" && v.set(p.id, p);
      }), c && l !== "" && v.get(l) && (c.mimeType = v.get(l).mimeType), c;
    });
  }
  stopObservingElement(u) {
    const c = this.elementInfos.filter((l) => l.element === u);
    for (const l of c)
      this.stopObservingElementInfo(l);
  }
  handleAppVisibilityChanged() {
    const u = Object.create(null, {
      handleAppVisibilityChanged: {
        get: () => super.handleAppVisibilityChanged
      }
    });
    return __awaiter$3(this, void 0, void 0, function* () {
      yield u.handleAppVisibilityChanged.call(this), this.isAdaptiveStream && this.updateVisibility();
    });
  }
  updateVisibility() {
    var u, c;
    const l = this.elementInfos.reduce((k, O) => Math.max(k, O.visibilityChangedAt || 0), 0), v = !((c = (u = this.adaptiveStreamSettings) === null || u === void 0 ? void 0 : u.pauseVideoInBackground) !== null && c !== void 0) || c ? this.isInBackground : !1, p = this.elementInfos.some((k) => k.pictureInPicture), _ = this.elementInfos.some((k) => k.visible) && !v || p;
    if (this.lastVisible !== _) {
      if (!_ && Date.now() - l < REACTION_DELAY) {
        CriticalTimers.setTimeout(() => {
          this.updateVisibility();
        }, REACTION_DELAY);
        return;
      }
      this.lastVisible = _, this.emit(TrackEvent.VisibilityChanged, _, this);
    }
  }
  updateDimensions() {
    var u, c;
    let l = 0, v = 0;
    const p = this.getPixelDensity();
    for (const _ of this.elementInfos) {
      const k = _.width() * p, O = _.height() * p;
      k + O > l + v && (l = k, v = O);
    }
    ((u = this.lastDimensions) === null || u === void 0 ? void 0 : u.width) === l && ((c = this.lastDimensions) === null || c === void 0 ? void 0 : c.height) === v || (this.lastDimensions = {
      width: l,
      height: v
    }, this.emit(TrackEvent.VideoDimensionsChanged, this.lastDimensions, this));
  }
  getPixelDensity() {
    var u;
    const c = (u = this.adaptiveStreamSettings) === null || u === void 0 ? void 0 : u.pixelDensity;
    return c === "screen" ? getDevicePixelRatio() : c || (getDevicePixelRatio() > 2 ? 2 : 1);
  }
}
class HTMLElementInfo {
  get visible() {
    return this.isPiP || this.isIntersecting;
  }
  get pictureInPicture() {
    return this.isPiP;
  }
  constructor(u, c) {
    this.onVisibilityChanged = (l) => {
      var v;
      const {
        target: p,
        isIntersecting: _
      } = l;
      p === this.element && (this.isIntersecting = _, this.visibilityChangedAt = Date.now(), (v = this.handleVisibilityChanged) === null || v === void 0 || v.call(this));
    }, this.onEnterPiP = () => {
      var l;
      this.isPiP = !0, (l = this.handleVisibilityChanged) === null || l === void 0 || l.call(this);
    }, this.onLeavePiP = () => {
      var l;
      this.isPiP = !1, (l = this.handleVisibilityChanged) === null || l === void 0 || l.call(this);
    }, this.element = u, this.isIntersecting = c ?? isElementInViewport(u), this.isPiP = isWeb() && document.pictureInPictureElement === u, this.visibilityChangedAt = 0;
  }
  width() {
    return this.element.clientWidth;
  }
  height() {
    return this.element.clientHeight;
  }
  observe() {
    this.isIntersecting = isElementInViewport(this.element), this.isPiP = document.pictureInPictureElement === this.element, this.element.handleResize = () => {
      var u;
      (u = this.handleResize) === null || u === void 0 || u.call(this);
    }, this.element.handleVisibilityChanged = this.onVisibilityChanged, getIntersectionObserver().observe(this.element), getResizeObserver().observe(this.element), this.element.addEventListener("enterpictureinpicture", this.onEnterPiP), this.element.addEventListener("leavepictureinpicture", this.onLeavePiP);
  }
  stopObserving() {
    var u, c;
    (u = getIntersectionObserver()) === null || u === void 0 || u.unobserve(this.element), (c = getResizeObserver()) === null || c === void 0 || c.unobserve(this.element), this.element.removeEventListener("enterpictureinpicture", this.onEnterPiP), this.element.removeEventListener("leavepictureinpicture", this.onLeavePiP);
  }
}
function isElementInViewport(a) {
  let u = a.offsetTop, c = a.offsetLeft;
  const l = a.offsetWidth, v = a.offsetHeight, {
    hidden: p
  } = a, {
    opacity: _,
    display: k
  } = getComputedStyle(a);
  for (; a.offsetParent; )
    a = a.offsetParent, u += a.offsetTop, c += a.offsetLeft;
  return u < window.pageYOffset + window.innerHeight && c < window.pageXOffset + window.innerWidth && u + v > window.pageYOffset && c + l > window.pageXOffset && !p && (_ !== "" ? parseFloat(_) > 0 : !0) && k !== "none";
}
class TrackPublication extends eventsExports$1.EventEmitter {
  constructor(u, c, l, v) {
    var p;
    super(), this.metadataMuted = !1, this.encryption = Encryption_Type.NONE, this.log = livekitLogger, this.handleMuted = () => {
      this.emit(TrackEvent.Muted);
    }, this.handleUnmuted = () => {
      this.emit(TrackEvent.Unmuted);
    }, this.log = getLogger((p = v == null ? void 0 : v.loggerName) !== null && p !== void 0 ? p : LoggerNames.Publication), this.loggerContextCb = this.loggerContextCb, this.setMaxListeners(100), this.kind = u, this.trackSid = c, this.trackName = l, this.source = Track.Source.Unknown;
  }
  /** @internal */
  setTrack(u) {
    this.track && (this.track.off(TrackEvent.Muted, this.handleMuted), this.track.off(TrackEvent.Unmuted, this.handleUnmuted)), this.track = u, u && (u.on(TrackEvent.Muted, this.handleMuted), u.on(TrackEvent.Unmuted, this.handleUnmuted));
  }
  get logContext() {
    var u;
    return Object.assign(Object.assign({}, (u = this.loggerContextCb) === null || u === void 0 ? void 0 : u.call(this)), getLogContextFromTrack(this));
  }
  get isMuted() {
    return this.metadataMuted;
  }
  get isEnabled() {
    return !0;
  }
  get isSubscribed() {
    return this.track !== void 0;
  }
  get isEncrypted() {
    return this.encryption !== Encryption_Type.NONE;
  }
  /**
   * an [AudioTrack] if this publication holds an audio track
   */
  get audioTrack() {
    if (this.track instanceof LocalAudioTrack || this.track instanceof RemoteAudioTrack)
      return this.track;
  }
  /**
   * an [VideoTrack] if this publication holds a video track
   */
  get videoTrack() {
    if (this.track instanceof LocalVideoTrack || this.track instanceof RemoteVideoTrack)
      return this.track;
  }
  /** @internal */
  updateInfo(u) {
    this.trackSid = u.sid, this.trackName = u.name, this.source = Track.sourceFromProto(u.source), this.mimeType = u.mimeType, this.kind === Track.Kind.Video && u.width > 0 && (this.dimensions = {
      width: u.width,
      height: u.height
    }, this.simulcasted = u.simulcast), this.encryption = u.encryption, this.trackInfo = u, this.log.debug("update publication info", Object.assign(Object.assign({}, this.logContext), {
      info: u
    }));
  }
}
(function(a) {
  (function(u) {
    u.Desired = "desired", u.Subscribed = "subscribed", u.Unsubscribed = "unsubscribed";
  })(a.SubscriptionStatus || (a.SubscriptionStatus = {})), function(u) {
    u.Allowed = "allowed", u.NotAllowed = "not_allowed";
  }(a.PermissionStatus || (a.PermissionStatus = {}));
})(TrackPublication || (TrackPublication = {}));
class LocalTrackPublication extends TrackPublication {
  get isUpstreamPaused() {
    var u;
    return (u = this.track) === null || u === void 0 ? void 0 : u.isUpstreamPaused;
  }
  constructor(u, c, l, v) {
    super(u, c.sid, c.name, v), this.track = void 0, this.handleTrackEnded = () => {
      this.emit(TrackEvent.Ended);
    }, this.updateInfo(c), this.setTrack(l);
  }
  setTrack(u) {
    this.track && this.track.off(TrackEvent.Ended, this.handleTrackEnded), super.setTrack(u), u && u.on(TrackEvent.Ended, this.handleTrackEnded);
  }
  get isMuted() {
    return this.track ? this.track.isMuted : super.isMuted;
  }
  get audioTrack() {
    return super.audioTrack;
  }
  get videoTrack() {
    return super.videoTrack;
  }
  /**
   * Mute the track associated with this publication
   */
  mute() {
    var u;
    return __awaiter$3(this, void 0, void 0, function* () {
      return (u = this.track) === null || u === void 0 ? void 0 : u.mute();
    });
  }
  /**
   * Unmute track associated with this publication
   */
  unmute() {
    var u;
    return __awaiter$3(this, void 0, void 0, function* () {
      return (u = this.track) === null || u === void 0 ? void 0 : u.unmute();
    });
  }
  /**
   * Pauses the media stream track associated with this publication from being sent to the server
   * and signals "muted" event to other participants
   * Useful if you want to pause the stream without pausing the local media stream track
   */
  pauseUpstream() {
    var u;
    return __awaiter$3(this, void 0, void 0, function* () {
      yield (u = this.track) === null || u === void 0 ? void 0 : u.pauseUpstream();
    });
  }
  /**
   * Resumes sending the media stream track associated with this publication to the server after a call to [[pauseUpstream()]]
   * and signals "unmuted" event to other participants (unless the track is explicitly muted)
   */
  resumeUpstream() {
    var u;
    return __awaiter$3(this, void 0, void 0, function* () {
      yield (u = this.track) === null || u === void 0 ? void 0 : u.resumeUpstream();
    });
  }
}
var ConnectionQuality;
(function(a) {
  a.Excellent = "excellent", a.Good = "good", a.Poor = "poor", a.Lost = "lost", a.Unknown = "unknown";
})(ConnectionQuality || (ConnectionQuality = {}));
function qualityFromProto(a) {
  switch (a) {
    case ConnectionQuality$1.EXCELLENT:
      return ConnectionQuality.Excellent;
    case ConnectionQuality$1.GOOD:
      return ConnectionQuality.Good;
    case ConnectionQuality$1.POOR:
      return ConnectionQuality.Poor;
    case ConnectionQuality$1.LOST:
      return ConnectionQuality.Lost;
    default:
      return ConnectionQuality.Unknown;
  }
}
class Participant extends eventsExports$1.EventEmitter {
  get logContext() {
    var u, c;
    return Object.assign({}, (c = (u = this.loggerOptions) === null || u === void 0 ? void 0 : u.loggerContextCb) === null || c === void 0 ? void 0 : c.call(u));
  }
  get isEncrypted() {
    return this.trackPublications.size > 0 && Array.from(this.trackPublications.values()).every((u) => u.isEncrypted);
  }
  get isAgent() {
    var u, c;
    return (c = (u = this.permissions) === null || u === void 0 ? void 0 : u.agent) !== null && c !== void 0 ? c : !1;
  }
  /** @internal */
  constructor(u, c, l, v, p) {
    var _;
    super(), this.audioLevel = 0, this.isSpeaking = !1, this._connectionQuality = ConnectionQuality.Unknown, this.log = livekitLogger, this.log = getLogger((_ = p == null ? void 0 : p.loggerName) !== null && _ !== void 0 ? _ : LoggerNames.Participant), this.loggerOptions = p, this.setMaxListeners(100), this.sid = u, this.identity = c, this.name = l, this.metadata = v, this.audioTrackPublications = /* @__PURE__ */ new Map(), this.videoTrackPublications = /* @__PURE__ */ new Map(), this.trackPublications = /* @__PURE__ */ new Map();
  }
  getTrackPublications() {
    return Array.from(this.trackPublications.values());
  }
  /**
   * Finds the first track that matches the source filter, for example, getting
   * the user's camera track with getTrackBySource(Track.Source.Camera).
   */
  getTrackPublication(u) {
    for (const [, c] of this.trackPublications)
      if (c.source === u)
        return c;
  }
  /**
   * Finds the first track that matches the track's name.
   */
  getTrackPublicationByName(u) {
    for (const [, c] of this.trackPublications)
      if (c.trackName === u)
        return c;
  }
  get connectionQuality() {
    return this._connectionQuality;
  }
  get isCameraEnabled() {
    var u;
    const c = this.getTrackPublication(Track.Source.Camera);
    return !(!((u = c == null ? void 0 : c.isMuted) !== null && u !== void 0) || u);
  }
  get isMicrophoneEnabled() {
    var u;
    const c = this.getTrackPublication(Track.Source.Microphone);
    return !(!((u = c == null ? void 0 : c.isMuted) !== null && u !== void 0) || u);
  }
  get isScreenShareEnabled() {
    return !!this.getTrackPublication(Track.Source.ScreenShare);
  }
  get isLocal() {
    return !1;
  }
  /** when participant joined the room */
  get joinedAt() {
    return this.participantInfo ? new Date(Number.parseInt(this.participantInfo.joinedAt.toString()) * 1e3) : /* @__PURE__ */ new Date();
  }
  /** @internal */
  updateInfo(u) {
    return this.participantInfo && this.participantInfo.sid === u.sid && this.participantInfo.version > u.version ? !1 : (this.identity = u.identity, this.sid = u.sid, this._setName(u.name), this._setMetadata(u.metadata), u.permission && this.setPermissions(u.permission), this.participantInfo = u, this.log.trace("update participant info", Object.assign(Object.assign({}, this.logContext), {
      info: u
    })), !0);
  }
  /**
   * Updates metadata from server
   **/
  _setMetadata(u) {
    const c = this.metadata !== u, l = this.metadata;
    this.metadata = u, c && this.emit(ParticipantEvent.ParticipantMetadataChanged, l);
  }
  _setName(u) {
    const c = this.name !== u;
    this.name = u, c && this.emit(ParticipantEvent.ParticipantNameChanged, u);
  }
  /** @internal */
  setPermissions(u) {
    var c, l, v, p, _;
    const k = this.permissions, O = u.canPublish !== ((c = this.permissions) === null || c === void 0 ? void 0 : c.canPublish) || u.canSubscribe !== ((l = this.permissions) === null || l === void 0 ? void 0 : l.canSubscribe) || u.canPublishData !== ((v = this.permissions) === null || v === void 0 ? void 0 : v.canPublishData) || u.hidden !== ((p = this.permissions) === null || p === void 0 ? void 0 : p.hidden) || u.recorder !== ((_ = this.permissions) === null || _ === void 0 ? void 0 : _.recorder) || u.canPublishSources.length !== this.permissions.canPublishSources.length || u.canPublishSources.some((D, F) => {
      var z;
      return D !== ((z = this.permissions) === null || z === void 0 ? void 0 : z.canPublishSources[F]);
    });
    return this.permissions = u, O && this.emit(ParticipantEvent.ParticipantPermissionsChanged, k), O;
  }
  /** @internal */
  setIsSpeaking(u) {
    u !== this.isSpeaking && (this.isSpeaking = u, u && (this.lastSpokeAt = /* @__PURE__ */ new Date()), this.emit(ParticipantEvent.IsSpeakingChanged, u));
  }
  /** @internal */
  setConnectionQuality(u) {
    const c = this._connectionQuality;
    this._connectionQuality = qualityFromProto(u), c !== this._connectionQuality && this.emit(ParticipantEvent.ConnectionQualityChanged, this._connectionQuality);
  }
  /**
   * @internal
   */
  setAudioContext(u) {
    this.audioContext = u, this.audioTrackPublications.forEach((c) => (c.track instanceof RemoteAudioTrack || c.track instanceof LocalAudioTrack) && c.track.setAudioContext(u));
  }
  addTrackPublication(u) {
    u.on(TrackEvent.Muted, () => {
      this.emit(ParticipantEvent.TrackMuted, u);
    }), u.on(TrackEvent.Unmuted, () => {
      this.emit(ParticipantEvent.TrackUnmuted, u);
    });
    const c = u;
    switch (c.track && (c.track.sid = u.trackSid), this.trackPublications.set(u.trackSid, u), u.kind) {
      case Track.Kind.Audio:
        this.audioTrackPublications.set(u.trackSid, u);
        break;
      case Track.Kind.Video:
        this.videoTrackPublications.set(u.trackSid, u);
        break;
    }
  }
}
function trackPermissionToProto(a) {
  var u, c, l;
  if (!a.participantSid && !a.participantIdentity)
    throw new Error("Invalid track permission, must provide at least one of participantIdentity and participantSid");
  return new TrackPermission({
    participantIdentity: (u = a.participantIdentity) !== null && u !== void 0 ? u : "",
    participantSid: (c = a.participantSid) !== null && c !== void 0 ? c : "",
    allTracks: (l = a.allowAll) !== null && l !== void 0 ? l : !1,
    trackSids: a.allowedTrackSids || []
  });
}
class LocalParticipant extends Participant {
  /** @internal */
  constructor(u, c, l, v) {
    super(u, c, void 0, void 0, {
      loggerName: v.loggerName,
      loggerContextCb: () => this.engine.logContext
    }), this.pendingPublishing = /* @__PURE__ */ new Set(), this.pendingPublishPromises = /* @__PURE__ */ new Map(), this.participantTrackPermissions = [], this.allParticipantsAllowedToSubscribe = !0, this.encryptionType = Encryption_Type.NONE, this.handleReconnecting = () => {
      this.reconnectFuture || (this.reconnectFuture = new Future());
    }, this.handleReconnected = () => {
      var p, _;
      (_ = (p = this.reconnectFuture) === null || p === void 0 ? void 0 : p.resolve) === null || _ === void 0 || _.call(p), this.reconnectFuture = void 0, this.updateTrackSubscriptionPermissions();
    }, this.handleDisconnected = () => {
      var p, _;
      this.reconnectFuture && (this.reconnectFuture.promise.catch((k) => this.log.warn(k.message, this.logContext)), (_ = (p = this.reconnectFuture) === null || p === void 0 ? void 0 : p.reject) === null || _ === void 0 || _.call(p, "Got disconnected during reconnection attempt"), this.reconnectFuture = void 0);
    }, this.updateTrackSubscriptionPermissions = () => {
      this.log.debug("updating track subscription permissions", Object.assign(Object.assign({}, this.logContext), {
        allParticipantsAllowed: this.allParticipantsAllowedToSubscribe,
        participantTrackPermissions: this.participantTrackPermissions
      })), this.engine.client.sendUpdateSubscriptionPermissions(this.allParticipantsAllowedToSubscribe, this.participantTrackPermissions.map((p) => trackPermissionToProto(p)));
    }, this.onTrackUnmuted = (p) => {
      this.onTrackMuted(p, p.isUpstreamPaused);
    }, this.onTrackMuted = (p, _) => {
      if (_ === void 0 && (_ = !0), !p.sid) {
        this.log.error("could not update mute status for unpublished track", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(p)));
        return;
      }
      this.engine.updateMuteStatus(p.sid, _);
    }, this.onTrackUpstreamPaused = (p) => {
      this.log.debug("upstream paused", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(p))), this.onTrackMuted(p, !0);
    }, this.onTrackUpstreamResumed = (p) => {
      this.log.debug("upstream resumed", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(p))), this.onTrackMuted(p, p.isMuted);
    }, this.handleSubscribedQualityUpdate = (p) => __awaiter$3(this, void 0, void 0, function* () {
      var _, k, O, D, F, z;
      if (!(!((F = this.roomOptions) === null || F === void 0) && F.dynacast))
        return;
      const j = this.videoTrackPublications.get(p.trackSid);
      if (!j) {
        this.log.warn("received subscribed quality update for unknown track", Object.assign(Object.assign({}, this.logContext), {
          trackSid: p.trackSid
        }));
        return;
      }
      if (p.subscribedCodecs.length > 0) {
        if (!j.videoTrack)
          return;
        const Q = yield j.videoTrack.setPublishingCodecs(p.subscribedCodecs);
        try {
          for (var ee = !0, X = __asyncValues(Q), ae; ae = yield X.next(), _ = ae.done, !_; ee = !0) {
            D = ae.value, ee = !1;
            const ne = D;
            isBackupCodec(ne) && (this.log.debug("publish ".concat(ne, " for ").concat(j.videoTrack.sid), Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(j))), yield this.publishAdditionalCodecForTrack(j.videoTrack, ne, j.options));
          }
        } catch (ne) {
          k = {
            error: ne
          };
        } finally {
          try {
            !ee && !_ && (O = X.return) && (yield O.call(X));
          } finally {
            if (k)
              throw k.error;
          }
        }
      } else
        p.subscribedQualities.length > 0 && (yield (z = j.videoTrack) === null || z === void 0 ? void 0 : z.setPublishingLayers(p.subscribedQualities));
    }), this.handleLocalTrackUnpublished = (p) => {
      const _ = this.trackPublications.get(p.trackSid);
      if (!_) {
        this.log.warn("received unpublished event for unknown track", Object.assign(Object.assign({}, this.logContext), {
          trackSid: p.trackSid
        }));
        return;
      }
      this.unpublishTrack(_.track);
    }, this.handleTrackEnded = (p) => __awaiter$3(this, void 0, void 0, function* () {
      if (p.source === Track.Source.ScreenShare || p.source === Track.Source.ScreenShareAudio)
        this.log.debug("unpublishing local track due to TrackEnded", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(p))), this.unpublishTrack(p);
      else if (p.isUserProvided)
        yield p.mute();
      else if (p instanceof LocalAudioTrack || p instanceof LocalVideoTrack)
        try {
          if (isWeb())
            try {
              const _ = yield navigator == null ? void 0 : navigator.permissions.query({
                // the permission query for camera and microphone currently not supported in Safari and Firefox
                // @ts-ignore
                name: p.source === Track.Source.Camera ? "camera" : "microphone"
              });
              if (_ && _.state === "denied")
                throw this.log.warn("user has revoked access to ".concat(p.source), Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(p))), _.onchange = () => {
                  _.state !== "denied" && (p.isMuted || p.restartTrack(), _.onchange = null);
                }, new Error("GetUserMedia Permission denied");
            } catch {
            }
          p.isMuted || (this.log.debug("track ended, attempting to use a different device", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(p))), yield p.restartTrack());
        } catch {
          this.log.warn("could not restart track, muting instead", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(p))), yield p.mute();
        }
    }), this.audioTrackPublications = /* @__PURE__ */ new Map(), this.videoTrackPublications = /* @__PURE__ */ new Map(), this.trackPublications = /* @__PURE__ */ new Map(), this.engine = l, this.roomOptions = v, this.setupEngine(l), this.activeDeviceMap = /* @__PURE__ */ new Map();
  }
  get lastCameraError() {
    return this.cameraError;
  }
  get lastMicrophoneError() {
    return this.microphoneError;
  }
  get isE2EEEnabled() {
    return this.encryptionType !== Encryption_Type.NONE;
  }
  getTrackPublication(u) {
    const c = super.getTrackPublication(u);
    if (c)
      return c;
  }
  getTrackPublicationByName(u) {
    const c = super.getTrackPublicationByName(u);
    if (c)
      return c;
  }
  /**
   * @internal
   */
  setupEngine(u) {
    this.engine = u, this.engine.on(EngineEvent.RemoteMute, (c, l) => {
      const v = this.trackPublications.get(c);
      !v || !v.track || (l ? v.mute() : v.unmute());
    }), this.engine.on(EngineEvent.Connected, this.handleReconnected).on(EngineEvent.SignalRestarted, this.handleReconnected).on(EngineEvent.SignalResumed, this.handleReconnected).on(EngineEvent.Restarting, this.handleReconnecting).on(EngineEvent.Resuming, this.handleReconnecting).on(EngineEvent.LocalTrackUnpublished, this.handleLocalTrackUnpublished).on(EngineEvent.SubscribedQualityUpdate, this.handleSubscribedQualityUpdate).on(EngineEvent.Disconnected, this.handleDisconnected);
  }
  /**
   * Sets and updates the metadata of the local participant.
   * The change does not take immediate effect.
   * If successful, a `ParticipantEvent.MetadataChanged` event will be emitted on the local participant.
   * Note: this requires `canUpdateOwnMetadata` permission.
   * @param metadata
   */
  setMetadata(u) {
    var c;
    this.engine.client.sendUpdateLocalMetadata(u, (c = this.name) !== null && c !== void 0 ? c : "");
  }
  /**
   * Sets and updates the name of the local participant.
   * The change does not take immediate effect.
   * If successful, a `ParticipantEvent.ParticipantNameChanged` event will be emitted on the local participant.
   * Note: this requires `canUpdateOwnMetadata` permission.
   * @param metadata
   */
  setName(u) {
    var c;
    this.engine.client.sendUpdateLocalMetadata((c = this.metadata) !== null && c !== void 0 ? c : "", u);
  }
  /**
   * Enable or disable a participant's camera track.
   *
   * If a track has already published, it'll mute or unmute the track.
   * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise
   */
  setCameraEnabled(u, c, l) {
    return this.setTrackEnabled(Track.Source.Camera, u, c, l);
  }
  /**
   * Enable or disable a participant's microphone track.
   *
   * If a track has already published, it'll mute or unmute the track.
   * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise
   */
  setMicrophoneEnabled(u, c, l) {
    return this.setTrackEnabled(Track.Source.Microphone, u, c, l);
  }
  /**
   * Start or stop sharing a participant's screen
   * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise
   */
  setScreenShareEnabled(u, c, l) {
    return this.setTrackEnabled(Track.Source.ScreenShare, u, c, l);
  }
  /** @internal */
  setPermissions(u) {
    const c = this.permissions, l = super.setPermissions(u);
    return l && c && this.emit(ParticipantEvent.ParticipantPermissionsChanged, c), l;
  }
  /** @internal */
  setE2EEEnabled(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      this.encryptionType = u ? Encryption_Type.GCM : Encryption_Type.NONE, yield this.republishAllTracks(void 0, !1);
    });
  }
  setTrackEnabled(u, c, l, v) {
    var p, _;
    return __awaiter$3(this, void 0, void 0, function* () {
      this.log.debug("setTrackEnabled", Object.assign(Object.assign({}, this.logContext), {
        source: u,
        enabled: c
      }));
      let k = this.getTrackPublication(u);
      if (c)
        if (k)
          yield k.unmute();
        else {
          let O;
          if (this.pendingPublishing.has(u)) {
            this.log.info("skipping duplicate published source", Object.assign(Object.assign({}, this.logContext), {
              source: u
            }));
            return;
          }
          this.pendingPublishing.add(u);
          try {
            switch (u) {
              case Track.Source.Camera:
                O = yield this.createTracks({
                  video: (p = l) !== null && p !== void 0 ? p : !0
                });
                break;
              case Track.Source.Microphone:
                O = yield this.createTracks({
                  audio: (_ = l) !== null && _ !== void 0 ? _ : !0
                });
                break;
              case Track.Source.ScreenShare:
                O = yield this.createScreenTracks(Object.assign({}, l));
                break;
              default:
                throw new TrackInvalidError(u);
            }
            const D = [];
            for (const z of O)
              this.log.info("publishing track", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(z))), D.push(this.publishTrack(z, v));
            [k] = yield Promise.all(D);
          } catch (D) {
            throw O == null || O.forEach((F) => {
              F.stop();
            }), D instanceof Error && !(D instanceof TrackInvalidError) && this.emit(ParticipantEvent.MediaDevicesError, D), D;
          } finally {
            this.pendingPublishing.delete(u);
          }
        }
      else if (k && k.track)
        if (u === Track.Source.ScreenShare) {
          k = yield this.unpublishTrack(k.track);
          const O = this.getTrackPublication(Track.Source.ScreenShareAudio);
          O && O.track && this.unpublishTrack(O.track);
        } else
          yield k.mute();
      return k;
    });
  }
  /**
   * Publish both camera and microphone at the same time. This is useful for
   * displaying a single Permission Dialog box to the end user.
   */
  enableCameraAndMicrophone() {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!(this.pendingPublishing.has(Track.Source.Camera) || this.pendingPublishing.has(Track.Source.Microphone))) {
        this.pendingPublishing.add(Track.Source.Camera), this.pendingPublishing.add(Track.Source.Microphone);
        try {
          const u = yield this.createTracks({
            audio: !0,
            video: !0
          });
          yield Promise.all(u.map((c) => this.publishTrack(c)));
        } finally {
          this.pendingPublishing.delete(Track.Source.Camera), this.pendingPublishing.delete(Track.Source.Microphone);
        }
      }
    });
  }
  /**
   * Create local camera and/or microphone tracks
   * @param options
   * @returns
   */
  createTracks(u) {
    var c, l;
    return __awaiter$3(this, void 0, void 0, function* () {
      const v = mergeDefaultOptions(u, (c = this.roomOptions) === null || c === void 0 ? void 0 : c.audioCaptureDefaults, (l = this.roomOptions) === null || l === void 0 ? void 0 : l.videoCaptureDefaults), p = constraintsForOptions(v);
      let _;
      try {
        _ = yield navigator.mediaDevices.getUserMedia(p);
      } catch (k) {
        throw k instanceof Error && (p.audio && (this.microphoneError = k), p.video && (this.cameraError = k)), k;
      }
      return p.audio && (this.microphoneError = void 0, this.emit(ParticipantEvent.AudioStreamAcquired)), p.video && (this.cameraError = void 0), _.getTracks().map((k) => {
        const O = k.kind === "audio";
        O ? u.audio : u.video;
        let D;
        const F = O ? p.audio : p.video;
        typeof F != "boolean" && (D = F);
        const z = mediaTrackToLocalTrack(k, D, {
          loggerName: this.roomOptions.loggerName,
          loggerContextCb: () => this.logContext
        });
        return z.kind === Track.Kind.Video ? z.source = Track.Source.Camera : z.kind === Track.Kind.Audio && (z.source = Track.Source.Microphone), z.mediaStream = _, z;
      });
    });
  }
  /**
   * Creates a screen capture tracks with getDisplayMedia().
   * A LocalVideoTrack is always created and returned.
   * If { audio: true }, and the browser supports audio capture, a LocalAudioTrack is also created.
   */
  createScreenTracks(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (u === void 0 && (u = {}), navigator.mediaDevices.getDisplayMedia === void 0)
        throw new DeviceUnsupportedError("getDisplayMedia not supported");
      u.resolution === void 0 && !isSafari17() && (u.resolution = ScreenSharePresets.h1080fps30.resolution);
      const c = screenCaptureToDisplayMediaStreamOptions(u), l = yield navigator.mediaDevices.getDisplayMedia(c), v = l.getVideoTracks();
      if (v.length === 0)
        throw new TrackInvalidError("no video track found");
      const p = new LocalVideoTrack(v[0], void 0, !1, {
        loggerName: this.roomOptions.loggerName,
        loggerContextCb: () => this.logContext
      });
      p.source = Track.Source.ScreenShare, u.contentHint && (p.mediaStreamTrack.contentHint = u.contentHint);
      const _ = [p];
      if (l.getAudioTracks().length > 0) {
        this.emit(ParticipantEvent.AudioStreamAcquired);
        const k = new LocalAudioTrack(l.getAudioTracks()[0], void 0, !1, this.audioContext, {
          loggerName: this.roomOptions.loggerName,
          loggerContextCb: () => this.logContext
        });
        k.source = Track.Source.ScreenShareAudio, _.push(k);
      }
      return _;
    });
  }
  /**
   * Publish a new track to the room
   * @param track
   * @param options
   */
  publishTrack(u, c) {
    var l, v, p, _;
    return __awaiter$3(this, void 0, void 0, function* () {
      u instanceof LocalAudioTrack && u.setAudioContext(this.audioContext), yield (l = this.reconnectFuture) === null || l === void 0 ? void 0 : l.promise, u instanceof LocalTrack && this.pendingPublishPromises.has(u) && (yield this.pendingPublishPromises.get(u));
      let k;
      if (u instanceof MediaStreamTrack)
        k = u.getConstraints();
      else {
        k = u.constraints;
        let ee;
        switch (u.source) {
          case Track.Source.Microphone:
            ee = "audioinput";
            break;
          case Track.Source.Camera:
            ee = "videoinput";
        }
        ee && this.activeDeviceMap.has(ee) && (k = Object.assign(Object.assign({}, k), {
          deviceId: this.activeDeviceMap.get(ee)
        }));
      }
      if (u instanceof MediaStreamTrack)
        switch (u.kind) {
          case "audio":
            u = new LocalAudioTrack(u, k, !0, this.audioContext, {
              loggerName: this.roomOptions.loggerName,
              loggerContextCb: () => this.logContext
            });
            break;
          case "video":
            u = new LocalVideoTrack(u, k, !0, {
              loggerName: this.roomOptions.loggerName,
              loggerContextCb: () => this.logContext
            });
            break;
          default:
            throw new TrackInvalidError("unsupported MediaStreamTrack kind ".concat(u.kind));
        }
      else
        u.updateLoggerOptions({
          loggerName: this.roomOptions.loggerName,
          loggerContextCb: () => this.logContext
        });
      let O;
      if (this.trackPublications.forEach((ee) => {
        ee.track && ee.track === u && (O = ee);
      }), O)
        return this.log.warn("track has already been published, skipping", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(O))), O;
      const D = "channelCount" in u.mediaStreamTrack.getSettings() && // @ts-ignore `channelCount` on getSettings() is currently only available for Safari, but is generally the best way to determine a stereo track https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackSettings/channelCount
      u.mediaStreamTrack.getSettings().channelCount === 2 || u.mediaStreamTrack.getConstraints().channelCount === 2, F = (v = c == null ? void 0 : c.forceStereo) !== null && v !== void 0 ? v : D;
      F && (c || (c = {}), c.dtx === void 0 && this.log.info("Opus DTX will be disabled for stereo tracks by default. Enable them explicitly to make it work.", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(u))), c.red === void 0 && this.log.info("Opus RED will be disabled for stereo tracks by default. Enable them explicitly to make it work."), (p = c.dtx) !== null && p !== void 0 || (c.dtx = !1), (_ = c.red) !== null && _ !== void 0 || (c.red = !1));
      const z = Object.assign(Object.assign({}, this.roomOptions.publishDefaults), c);
      isSafari() && this.roomOptions.e2ee && (this.log.info("End-to-end encryption is set up, simulcast publishing will be disabled on Safari", Object.assign({}, this.logContext)), z.simulcast = !1), z.source && (u.source = z.source);
      const j = this.publish(u, z, F);
      this.pendingPublishPromises.set(u, j);
      try {
        return yield j;
      } catch (ee) {
        throw ee;
      } finally {
        this.pendingPublishPromises.delete(u);
      }
    });
  }
  publish(u, c, l) {
    var v, p, _, k, O, D, F, z, j, ee, X, ae;
    return __awaiter$3(this, void 0, void 0, function* () {
      Array.from(this.trackPublications.values()).find((Le) => u instanceof LocalTrack && Le.source === u.source) && u.source !== Track.Source.Unknown && this.log.info("publishing a second track with the same source: ".concat(u.source), Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(u))), c.stopMicTrackOnMute && u instanceof LocalAudioTrack && (u.stopOnMute = !0), u.source === Track.Source.ScreenShare && isFireFox() && (c.simulcast = !1), c.videoCodec === "av1" && !supportsAV1() && (c.videoCodec = void 0), c.videoCodec === "vp9" && !supportsVP9() && (c.videoCodec = void 0), c.videoCodec === void 0 && (c.videoCodec = defaultVideoCodec);
      const ne = c.videoCodec;
      u.on(TrackEvent.Muted, this.onTrackMuted), u.on(TrackEvent.Unmuted, this.onTrackUnmuted), u.on(TrackEvent.Ended, this.handleTrackEnded), u.on(TrackEvent.UpstreamPaused, this.onTrackUpstreamPaused), u.on(TrackEvent.UpstreamResumed, this.onTrackUpstreamResumed);
      const Z = new AddTrackRequest({
        // get local track id for use during publishing
        cid: u.mediaStreamTrack.id,
        name: c.name,
        type: Track.kindToProto(u.kind),
        muted: u.isMuted,
        source: Track.sourceToProto(u.source),
        disableDtx: !(!((v = c.dtx) !== null && v !== void 0) || v),
        encryption: this.encryptionType,
        stereo: l,
        disableRed: this.isE2EEEnabled || !(!((p = c.red) !== null && p !== void 0) || p),
        stream: c == null ? void 0 : c.stream
      });
      let de;
      if (u.kind === Track.Kind.Video) {
        let Le = {
          width: 0,
          height: 0
        };
        try {
          Le = yield u.waitForDimensions();
        } catch {
          const q = (k = (_ = this.roomOptions.videoCaptureDefaults) === null || _ === void 0 ? void 0 : _.resolution) !== null && k !== void 0 ? k : VideoPresets.h720.resolution;
          Le = {
            width: q.width,
            height: q.height
          }, this.log.error("could not determine track dimensions, using defaults", Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(u)), {
            dims: Le
          }));
        }
        Z.width = Le.width, Z.height = Le.height, u instanceof LocalVideoTrack && (isSVCCodec(ne) && (u.source === Track.Source.ScreenShare && (c.scalabilityMode = "L1T3", "contentHint" in u.mediaStreamTrack && (u.mediaStreamTrack.contentHint = "motion", this.log.info("forcing contentHint to motion for screenshare with SVC codecs", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(u))))), c.scalabilityMode = (O = c.scalabilityMode) !== null && O !== void 0 ? O : "L3T3_KEY"), Z.simulcastCodecs = [new SimulcastCodec({
          codec: ne,
          cid: u.mediaStreamTrack.id
        })], c.backupCodec === !0 && (c.backupCodec = {
          codec: defaultVideoCodec
        }), c.backupCodec && ne !== c.backupCodec.codec && // TODO remove this once e2ee is supported for backup codecs
        Z.encryption === Encryption_Type.NONE && (this.roomOptions.dynacast || (this.roomOptions.dynacast = !0), Z.simulcastCodecs.push(new SimulcastCodec({
          codec: c.backupCodec.codec,
          cid: ""
        })))), de = computeVideoEncodings(u.source === Track.Source.ScreenShare, Z.width, Z.height, c), Z.layers = videoLayersFromEncodings(Z.width, Z.height, de, isSVCCodec(c.videoCodec));
      } else
        u.kind === Track.Kind.Audio && (de = [{
          maxBitrate: (D = c.audioPreset) === null || D === void 0 ? void 0 : D.maxBitrate,
          priority: (z = (F = c.audioPreset) === null || F === void 0 ? void 0 : F.priority) !== null && z !== void 0 ? z : "high",
          networkPriority: (ee = (j = c.audioPreset) === null || j === void 0 ? void 0 : j.priority) !== null && ee !== void 0 ? ee : "high"
        }]);
      if (!this.engine || this.engine.isClosed)
        throw new UnexpectedConnectionState("cannot publish track when not connected");
      const fe = yield this.engine.addTrack(Z);
      let Te;
      if (fe.codecs.forEach((Le) => {
        Te === void 0 && (Te = Le.mimeType);
      }), Te && u.kind === Track.Kind.Video) {
        const Le = mimeTypeToVideoCodecString(Te);
        Le !== ne && (this.log.debug("falling back to server selected codec", Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(u)), {
          codec: Le
        })), c.videoCodec = Le, de = computeVideoEncodings(u.source === Track.Source.ScreenShare, Z.width, Z.height, c));
      }
      const Re = new LocalTrackPublication(u.kind, fe, u, {
        loggerName: this.roomOptions.loggerName,
        loggerContextCb: () => this.logContext
      });
      if (Re.options = c, u.sid = fe.sid, !this.engine.pcManager)
        throw new UnexpectedConnectionState("pcManager is not ready");
      if (this.log.debug("publishing ".concat(u.kind, " with encodings"), Object.assign(Object.assign({}, this.logContext), {
        encodings: de,
        trackInfo: fe
      })), u.sender = yield this.engine.createSender(u, c, de), de)
        if (isFireFox() && u.kind === Track.Kind.Audio) {
          let Le;
          for (const be of this.engine.pcManager.publisher.getTransceivers())
            if (be.sender === u.sender) {
              Le = be;
              break;
            }
          Le && this.engine.pcManager.publisher.setTrackCodecBitrate({
            transceiver: Le,
            codec: "opus",
            maxbr: !((X = de[0]) === null || X === void 0) && X.maxBitrate ? de[0].maxBitrate / 1e3 : 0
          });
        } else
          u.codec && u.codec == "av1" && (!((ae = de[0]) === null || ae === void 0) && ae.maxBitrate) && this.engine.pcManager.publisher.setTrackCodecBitrate({
            cid: Z.cid,
            codec: u.codec,
            maxbr: de[0].maxBitrate / 1e3
          });
      if (u.kind === Track.Kind.Video && u.source === Track.Source.ScreenShare)
        try {
          this.log.debug("setting degradationPreference to maintain-resolution");
          const Le = u.sender.getParameters();
          Le.degradationPreference = "maintain-resolution", yield u.sender.setParameters(Le);
        } catch (Le) {
          this.log.warn("failed to set degradationPreference: ".concat(Le));
        }
      return yield this.engine.negotiate(), u instanceof LocalVideoTrack ? u.startMonitor(this.engine.client) : u instanceof LocalAudioTrack && u.startMonitor(), this.addTrackPublication(Re), this.emit(ParticipantEvent.LocalTrackPublished, Re), Re;
    });
  }
  get isLocal() {
    return !0;
  }
  /** @internal
   * publish additional codec to existing track
   */
  publishAdditionalCodecForTrack(u, c, l) {
    var v;
    return __awaiter$3(this, void 0, void 0, function* () {
      if (this.encryptionType !== Encryption_Type.NONE)
        return;
      let p;
      if (this.trackPublications.forEach((z) => {
        z.track && z.track === u && (p = z);
      }), !p)
        throw new TrackInvalidError("track is not published");
      if (!(u instanceof LocalVideoTrack))
        throw new TrackInvalidError("track is not a video track");
      const _ = Object.assign(Object.assign({}, (v = this.roomOptions) === null || v === void 0 ? void 0 : v.publishDefaults), l), k = computeTrackBackupEncodings(u, c, _);
      if (!k) {
        this.log.info("backup codec has been disabled, ignoring request to add additional codec for track", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(u)));
        return;
      }
      const O = u.addSimulcastTrack(c, k);
      if (!O)
        return;
      const D = new AddTrackRequest({
        cid: O.mediaStreamTrack.id,
        type: Track.kindToProto(u.kind),
        muted: u.isMuted,
        source: Track.sourceToProto(u.source),
        sid: u.sid,
        simulcastCodecs: [{
          codec: _.videoCodec,
          cid: O.mediaStreamTrack.id
        }]
      });
      if (D.layers = videoLayersFromEncodings(D.width, D.height, k), !this.engine || this.engine.isClosed)
        throw new UnexpectedConnectionState("cannot publish track when not connected");
      const F = yield this.engine.addTrack(D);
      yield this.engine.createSimulcastSender(u, O, _, k), yield this.engine.negotiate(), this.log.debug("published ".concat(c, " for track ").concat(u.sid), Object.assign(Object.assign({}, this.logContext), {
        encodings: k,
        trackInfo: F
      }));
    });
  }
  unpublishTrack(u, c) {
    var l, v;
    return __awaiter$3(this, void 0, void 0, function* () {
      const p = this.getPublicationForTrack(u), _ = p ? getLogContextFromTrack(p) : void 0;
      if (this.log.debug("unpublishing track", Object.assign(Object.assign({}, this.logContext), _)), !p || !p.track) {
        this.log.warn("track was not unpublished because no publication was found", Object.assign(Object.assign({}, this.logContext), _));
        return;
      }
      u = p.track, u.off(TrackEvent.Muted, this.onTrackMuted), u.off(TrackEvent.Unmuted, this.onTrackUnmuted), u.off(TrackEvent.Ended, this.handleTrackEnded), u.off(TrackEvent.UpstreamPaused, this.onTrackUpstreamPaused), u.off(TrackEvent.UpstreamResumed, this.onTrackUpstreamResumed), c === void 0 && (c = (v = (l = this.roomOptions) === null || l === void 0 ? void 0 : l.stopLocalTrackOnUnpublish) !== null && v !== void 0 ? v : !0), c && u.stop();
      let k = !1;
      const O = u.sender;
      if (u.sender = void 0, this.engine.pcManager && this.engine.pcManager.currentState < PCTransportState.FAILED && O)
        try {
          for (const D of this.engine.pcManager.publisher.getTransceivers())
            D.sender === O && (D.direction = "inactive", k = !0);
          if (this.engine.removeTrack(O) && (k = !0), u instanceof LocalVideoTrack) {
            for (const [, D] of u.simulcastCodecs)
              D.sender && (this.engine.removeTrack(D.sender) && (k = !0), D.sender = void 0);
            u.simulcastCodecs.clear();
          }
        } catch (D) {
          this.log.warn("failed to unpublish track", Object.assign(Object.assign(Object.assign({}, this.logContext), _), {
            error: D
          }));
        }
      switch (this.trackPublications.delete(p.trackSid), p.kind) {
        case Track.Kind.Audio:
          this.audioTrackPublications.delete(p.trackSid);
          break;
        case Track.Kind.Video:
          this.videoTrackPublications.delete(p.trackSid);
          break;
      }
      return this.emit(ParticipantEvent.LocalTrackUnpublished, p), p.setTrack(void 0), k && (yield this.engine.negotiate()), p;
    });
  }
  unpublishTracks(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      return (yield Promise.all(u.map((l) => this.unpublishTrack(l)))).filter((l) => l instanceof LocalTrackPublication);
    });
  }
  republishAllTracks(u) {
    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
    return __awaiter$3(this, void 0, void 0, function* () {
      const l = [];
      this.trackPublications.forEach((v) => {
        v.track && (u && (v.options = Object.assign(Object.assign({}, v.options), u)), l.push(v));
      }), yield Promise.all(l.map((v) => __awaiter$3(this, void 0, void 0, function* () {
        const p = v.track;
        yield this.unpublishTrack(p, !1), c && !p.isMuted && p.source !== Track.Source.ScreenShare && p.source !== Track.Source.ScreenShareAudio && (p instanceof LocalAudioTrack || p instanceof LocalVideoTrack) && !p.isUserProvided && (this.log.debug("restarting existing track", Object.assign(Object.assign({}, this.logContext), {
          track: v.trackSid
        })), yield p.restartTrack()), yield this.publishTrack(p, v.options);
      })));
    });
  }
  /**
   * Publish a new data payload to the room. Data will be forwarded to each
   * participant in the room if the destination field in publishOptions is empty
   *
   * @param data Uint8Array of the payload. To send string data, use TextEncoder.encode
   * @param options optionally specify a `reliable`, `topic` and `destination`
   */
  publishData(u) {
    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return __awaiter$3(this, void 0, void 0, function* () {
      const l = c.reliable ? DataPacket_Kind.RELIABLE : DataPacket_Kind.LOSSY, v = c.destinationIdentities, p = c.topic, _ = new DataPacket({
        kind: l,
        value: {
          case: "user",
          value: new UserPacket({
            participantIdentity: this.identity,
            payload: u,
            destinationIdentities: v,
            topic: p
          })
        }
      });
      yield this.engine.sendDataPacket(_, l);
    });
  }
  /**
   * Control who can subscribe to LocalParticipant's published tracks.
   *
   * By default, all participants can subscribe. This allows fine-grained control over
   * who is able to subscribe at a participant and track level.
   *
   * Note: if access is given at a track-level (i.e. both [allParticipantsAllowed] and
   * [ParticipantTrackPermission.allTracksAllowed] are false), any newer published tracks
   * will not grant permissions to any participants and will require a subsequent
   * permissions update to allow subscription.
   *
   * @param allParticipantsAllowed Allows all participants to subscribe all tracks.
   *  Takes precedence over [[participantTrackPermissions]] if set to true.
   *  By default this is set to true.
   * @param participantTrackPermissions Full list of individual permissions per
   *  participant/track. Any omitted participants will not receive any permissions.
   */
  setTrackSubscriptionPermissions(u) {
    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    this.participantTrackPermissions = c, this.allParticipantsAllowedToSubscribe = u, this.engine.client.isDisconnected || this.updateTrackSubscriptionPermissions();
  }
  /** @internal */
  updateInfo(u) {
    return u.sid !== this.sid || !super.updateInfo(u) ? !1 : (u.tracks.forEach((c) => {
      var l, v;
      const p = this.trackPublications.get(c.sid);
      if (p) {
        const _ = p.isMuted || ((v = (l = p.track) === null || l === void 0 ? void 0 : l.isUpstreamPaused) !== null && v !== void 0 ? v : !1);
        _ !== c.muted && (this.log.debug("updating server mute state after reconcile", Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(p)), {
          mutedOnServer: _
        })), this.engine.client.sendMuteTrack(c.sid, _));
      }
    }), !0);
  }
  getPublicationForTrack(u) {
    let c;
    return this.trackPublications.forEach((l) => {
      const v = l.track;
      v && (u instanceof MediaStreamTrack ? (v instanceof LocalAudioTrack || v instanceof LocalVideoTrack) && v.mediaStreamTrack === u && (c = l) : u === v && (c = l));
    }), c;
  }
}
class RemoteTrackPublication extends TrackPublication {
  constructor(u, c, l, v) {
    super(u, c.sid, c.name, v), this.track = void 0, this.allowed = !0, this.disabled = !1, this.currentVideoQuality = VideoQuality.HIGH, this.handleEnded = (p) => {
      this.setTrack(void 0), this.emit(TrackEvent.Ended, p);
    }, this.handleVisibilityChange = (p) => {
      this.log.debug("adaptivestream video visibility ".concat(this.trackSid, ", visible=").concat(p), this.logContext), this.disabled = !p, this.emitTrackUpdate();
    }, this.handleVideoDimensionsChange = (p) => {
      this.log.debug("adaptivestream video dimensions ".concat(p.width, "x").concat(p.height), this.logContext), this.videoDimensions = p, this.emitTrackUpdate();
    }, this.subscribed = l, this.updateInfo(c);
  }
  /**
   * Subscribe or unsubscribe to this remote track
   * @param subscribed true to subscribe to a track, false to unsubscribe
   */
  setSubscribed(u) {
    const c = this.subscriptionStatus, l = this.permissionStatus;
    this.subscribed = u, u && (this.allowed = !0);
    const v = new UpdateSubscription({
      trackSids: [this.trackSid],
      subscribe: this.subscribed,
      participantTracks: [new ParticipantTracks({
        // sending an empty participant id since TrackPublication doesn't keep it
        // this is filled in by the participant that receives this message
        participantSid: "",
        trackSids: [this.trackSid]
      })]
    });
    this.emit(TrackEvent.UpdateSubscription, v), this.emitSubscriptionUpdateIfChanged(c), this.emitPermissionUpdateIfChanged(l);
  }
  get subscriptionStatus() {
    return this.subscribed === !1 ? TrackPublication.SubscriptionStatus.Unsubscribed : super.isSubscribed ? TrackPublication.SubscriptionStatus.Subscribed : TrackPublication.SubscriptionStatus.Desired;
  }
  get permissionStatus() {
    return this.allowed ? TrackPublication.PermissionStatus.Allowed : TrackPublication.PermissionStatus.NotAllowed;
  }
  /**
   * Returns true if track is subscribed, and ready for playback
   */
  get isSubscribed() {
    return this.subscribed === !1 ? !1 : super.isSubscribed;
  }
  // returns client's desire to subscribe to a track, also true if autoSubscribe is enabled
  get isDesired() {
    return this.subscribed !== !1;
  }
  get isEnabled() {
    return !this.disabled;
  }
  /**
   * disable server from sending down data for this track. this is useful when
   * the participant is off screen, you may disable streaming down their video
   * to reduce bandwidth requirements
   * @param enabled
   */
  setEnabled(u) {
    !this.isManualOperationAllowed() || this.disabled === !u || (this.disabled = !u, this.emitTrackUpdate());
  }
  /**
   * for tracks that support simulcasting, adjust subscribed quality
   *
   * This indicates the highest quality the client can accept. if network
   * bandwidth does not allow, server will automatically reduce quality to
   * optimize for uninterrupted video
   */
  setVideoQuality(u) {
    !this.isManualOperationAllowed() || this.currentVideoQuality === u || (this.currentVideoQuality = u, this.videoDimensions = void 0, this.emitTrackUpdate());
  }
  setVideoDimensions(u) {
    var c, l;
    this.isManualOperationAllowed() && (((c = this.videoDimensions) === null || c === void 0 ? void 0 : c.width) === u.width && ((l = this.videoDimensions) === null || l === void 0 ? void 0 : l.height) === u.height || (this.track instanceof RemoteVideoTrack && (this.videoDimensions = u), this.currentVideoQuality = void 0, this.emitTrackUpdate()));
  }
  setVideoFPS(u) {
    this.isManualOperationAllowed() && this.track instanceof RemoteVideoTrack && this.fps !== u && (this.fps = u, this.emitTrackUpdate());
  }
  get videoQuality() {
    return this.currentVideoQuality;
  }
  /** @internal */
  setTrack(u) {
    const c = this.subscriptionStatus, l = this.permissionStatus, v = this.track;
    v !== u && (v && (v.off(TrackEvent.VideoDimensionsChanged, this.handleVideoDimensionsChange), v.off(TrackEvent.VisibilityChanged, this.handleVisibilityChange), v.off(TrackEvent.Ended, this.handleEnded), v.detach(), v.stopMonitor(), this.emit(TrackEvent.Unsubscribed, v)), super.setTrack(u), u && (u.sid = this.trackSid, u.on(TrackEvent.VideoDimensionsChanged, this.handleVideoDimensionsChange), u.on(TrackEvent.VisibilityChanged, this.handleVisibilityChange), u.on(TrackEvent.Ended, this.handleEnded), this.emit(TrackEvent.Subscribed, u)), this.emitPermissionUpdateIfChanged(l), this.emitSubscriptionUpdateIfChanged(c));
  }
  /** @internal */
  setAllowed(u) {
    const c = this.subscriptionStatus, l = this.permissionStatus;
    this.allowed = u, this.emitPermissionUpdateIfChanged(l), this.emitSubscriptionUpdateIfChanged(c);
  }
  /** @internal */
  setSubscriptionError(u) {
    this.emit(TrackEvent.SubscriptionFailed, u);
  }
  /** @internal */
  updateInfo(u) {
    super.updateInfo(u);
    const c = this.metadataMuted;
    this.metadataMuted = u.muted, this.track ? this.track.setMuted(u.muted) : c !== u.muted && this.emit(u.muted ? TrackEvent.Muted : TrackEvent.Unmuted);
  }
  emitSubscriptionUpdateIfChanged(u) {
    const c = this.subscriptionStatus;
    u !== c && this.emit(TrackEvent.SubscriptionStatusChanged, c, u);
  }
  emitPermissionUpdateIfChanged(u) {
    this.permissionStatus !== u && this.emit(TrackEvent.SubscriptionPermissionChanged, this.permissionStatus, u);
  }
  isManualOperationAllowed() {
    return this.kind === Track.Kind.Video && this.isAdaptiveStream ? (this.log.warn("adaptive stream is enabled, cannot change video track settings", this.logContext), !1) : this.isDesired ? !0 : (this.log.warn("cannot update track settings when not subscribed", this.logContext), !1);
  }
  get isAdaptiveStream() {
    return this.track instanceof RemoteVideoTrack && this.track.isAdaptiveStream;
  }
  /* @internal */
  emitTrackUpdate() {
    const u = new UpdateTrackSettings({
      trackSids: [this.trackSid],
      disabled: this.disabled,
      fps: this.fps
    });
    this.videoDimensions ? (u.width = Math.ceil(this.videoDimensions.width), u.height = Math.ceil(this.videoDimensions.height)) : this.currentVideoQuality !== void 0 ? u.quality = this.currentVideoQuality : u.quality = VideoQuality.HIGH, this.emit(TrackEvent.UpdateSettings, u);
  }
}
class RemoteParticipant extends Participant {
  /** @internal */
  static fromParticipantInfo(u, c) {
    return new RemoteParticipant(u, c.sid, c.identity, c.name, c.metadata);
  }
  get logContext() {
    return Object.assign(Object.assign({}, super.logContext), {
      rpID: this.sid,
      remoteParticipant: this.identity
    });
  }
  /** @internal */
  constructor(u, c, l, v, p, _) {
    super(c, l || "", v, p, _), this.signalClient = u, this.trackPublications = /* @__PURE__ */ new Map(), this.audioTrackPublications = /* @__PURE__ */ new Map(), this.videoTrackPublications = /* @__PURE__ */ new Map(), this.volumeMap = /* @__PURE__ */ new Map();
  }
  addTrackPublication(u) {
    super.addTrackPublication(u), u.on(TrackEvent.UpdateSettings, (c) => {
      this.log.debug("send update settings", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(u))), this.signalClient.sendUpdateTrackSettings(c);
    }), u.on(TrackEvent.UpdateSubscription, (c) => {
      c.participantTracks.forEach((l) => {
        l.participantSid = this.sid;
      }), this.signalClient.sendUpdateSubscription(c);
    }), u.on(TrackEvent.SubscriptionPermissionChanged, (c) => {
      this.emit(ParticipantEvent.TrackSubscriptionPermissionChanged, u, c);
    }), u.on(TrackEvent.SubscriptionStatusChanged, (c) => {
      this.emit(ParticipantEvent.TrackSubscriptionStatusChanged, u, c);
    }), u.on(TrackEvent.Subscribed, (c) => {
      this.emit(ParticipantEvent.TrackSubscribed, c, u);
    }), u.on(TrackEvent.Unsubscribed, (c) => {
      this.emit(ParticipantEvent.TrackUnsubscribed, c, u);
    }), u.on(TrackEvent.SubscriptionFailed, (c) => {
      this.emit(ParticipantEvent.TrackSubscriptionFailed, u.trackSid, c);
    });
  }
  getTrackPublication(u) {
    const c = super.getTrackPublication(u);
    if (c)
      return c;
  }
  getTrackPublicationByName(u) {
    const c = super.getTrackPublicationByName(u);
    if (c)
      return c;
  }
  /**
   * sets the volume on the participant's audio track
   * by default, this affects the microphone publication
   * a different source can be passed in as a second argument
   * if no track exists the volume will be applied when the microphone track is added
   */
  setVolume(u) {
    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Track.Source.Microphone;
    this.volumeMap.set(c, u);
    const l = this.getTrackPublication(c);
    l && l.track && l.track.setVolume(u);
  }
  /**
   * gets the volume on the participant's microphone track
   */
  getVolume() {
    let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Track.Source.Microphone;
    const c = this.getTrackPublication(u);
    return c && c.track ? c.track.getVolume() : this.volumeMap.get(u);
  }
  /** @internal */
  addSubscribedMediaTrack(u, c, l, v, p, _) {
    let k = this.getTrackPublicationBySid(c);
    if (k || c.startsWith("TR") || this.trackPublications.forEach((F) => {
      !k && u.kind === F.kind.toString() && (k = F);
    }), !k) {
      if (_ === 0) {
        this.log.error("could not find published track", Object.assign(Object.assign({}, this.logContext), {
          trackSid: c
        })), this.emit(ParticipantEvent.TrackSubscriptionFailed, c);
        return;
      }
      _ === void 0 && (_ = 20), setTimeout(() => {
        this.addSubscribedMediaTrack(u, c, l, v, p, _ - 1);
      }, 150);
      return;
    }
    if (u.readyState === "ended") {
      this.log.error("unable to subscribe because MediaStreamTrack is ended. Do not call MediaStreamTrack.stop()", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(k))), this.emit(ParticipantEvent.TrackSubscriptionFailed, c);
      return;
    }
    const O = u.kind === "video";
    let D;
    return O ? D = new RemoteVideoTrack(u, c, v, p) : D = new RemoteAudioTrack(u, c, v, this.audioContext, this.audioOutput), D.source = k.source, D.isMuted = k.isMuted, D.setMediaStream(l), D.start(), k.setTrack(D), this.volumeMap.has(k.source) && D instanceof RemoteAudioTrack && D.setVolume(this.volumeMap.get(k.source)), k;
  }
  /** @internal */
  get hasMetadata() {
    return !!this.participantInfo;
  }
  /**
   * @internal
   */
  getTrackPublicationBySid(u) {
    return this.trackPublications.get(u);
  }
  /** @internal */
  updateInfo(u) {
    if (!super.updateInfo(u))
      return !1;
    const c = /* @__PURE__ */ new Map(), l = /* @__PURE__ */ new Map();
    return u.tracks.forEach((v) => {
      var p, _;
      let k = this.getTrackPublicationBySid(v.sid);
      if (k)
        k.updateInfo(v);
      else {
        const O = Track.kindFromProto(v.type);
        if (!O)
          return;
        k = new RemoteTrackPublication(O, v, (p = this.signalClient.connectOptions) === null || p === void 0 ? void 0 : p.autoSubscribe, {
          loggerContextCb: () => this.logContext,
          loggerName: (_ = this.loggerOptions) === null || _ === void 0 ? void 0 : _.loggerName
        }), k.updateInfo(v), l.set(v.sid, k);
        const D = Array.from(this.trackPublications.values()).find((F) => F.source === (k == null ? void 0 : k.source));
        D && k.source !== Track.Source.Unknown && this.log.debug("received a second track publication for ".concat(this.identity, " with the same source: ").concat(k.source), Object.assign(Object.assign({}, this.logContext), {
          oldTrack: getLogContextFromTrack(D),
          newTrack: getLogContextFromTrack(k)
        })), this.addTrackPublication(k);
      }
      c.set(v.sid, k);
    }), this.trackPublications.forEach((v) => {
      c.has(v.trackSid) || (this.log.trace("detected removed track on remote participant, unpublishing", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(v))), this.unpublishTrack(v.trackSid, !0));
    }), l.forEach((v) => {
      this.emit(ParticipantEvent.TrackPublished, v);
    }), !0;
  }
  /** @internal */
  unpublishTrack(u, c) {
    const l = this.trackPublications.get(u);
    if (!l)
      return;
    const {
      track: v
    } = l;
    switch (v && (v.stop(), l.setTrack(void 0)), this.trackPublications.delete(u), l.kind) {
      case Track.Kind.Audio:
        this.audioTrackPublications.delete(u);
        break;
      case Track.Kind.Video:
        this.videoTrackPublications.delete(u);
        break;
    }
    c && this.emit(ParticipantEvent.TrackUnpublished, l);
  }
  /**
   * @internal
   */
  setAudioOutput(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      this.audioOutput = u;
      const c = [];
      this.audioTrackPublications.forEach((l) => {
        var v;
        l.track instanceof RemoteAudioTrack && c.push(l.track.setSinkId((v = u.deviceId) !== null && v !== void 0 ? v : "default"));
      }), yield Promise.all(c);
    });
  }
  /** @internal */
  emit(u) {
    for (var c = arguments.length, l = new Array(c > 1 ? c - 1 : 0), v = 1; v < c; v++)
      l[v - 1] = arguments[v];
    return this.log.trace("participant event", Object.assign(Object.assign({}, this.logContext), {
      event: u,
      args: l
    })), super.emit(u, ...l);
  }
}
var ConnectionState;
(function(a) {
  a.Disconnected = "disconnected", a.Connecting = "connecting", a.Connected = "connected", a.Reconnecting = "reconnecting";
})(ConnectionState || (ConnectionState = {}));
const connectionReconcileFrequency = 2 * 1e3;
class Room extends eventsExports$1.EventEmitter {
  /**
   * Creates a new Room, the primary construct for a LiveKit session.
   * @param options
   */
  constructor(u) {
    var c, l, v;
    super(), c = this, this.state = ConnectionState.Disconnected, this.activeSpeakers = [], this.isE2EEEnabled = !1, this.audioEnabled = !0, this.isVideoPlaybackBlocked = !1, this.log = livekitLogger, this.bufferedEvents = [], this.isResuming = !1, this.connect = (p, _, k) => __awaiter$3(this, void 0, void 0, function* () {
      var O;
      if (!isBrowserSupported())
        throw isReactNative() ? Error("WebRTC isn't detected, have you called registerGlobals?") : Error("LiveKit doesn't seem to be supported on this browser. Try to update your browser and make sure no browser extensions are disabling webRTC.");
      const D = yield this.disconnectLock.lock();
      if (this.state === ConnectionState.Connected)
        return this.log.info("already connected to room ".concat(this.name), this.logContext), D(), Promise.resolve();
      if (this.connectFuture)
        return D(), this.connectFuture.promise;
      this.setAndEmitConnectionState(ConnectionState.Connecting), ((O = this.regionUrlProvider) === null || O === void 0 ? void 0 : O.getServerUrl().toString()) !== p && (this.regionUrl = void 0, this.regionUrlProvider = void 0), isCloud(new URL(p)) && (this.regionUrlProvider === void 0 ? this.regionUrlProvider = new RegionUrlProvider(p, _) : this.regionUrlProvider.updateToken(_), this.regionUrlProvider.fetchRegionSettings().catch((j) => {
        this.log.warn("could not fetch region settings", Object.assign(Object.assign({}, this.logContext), {
          error: j
        }));
      }));
      const F = (j, ee, X) => __awaiter$3(this, void 0, void 0, function* () {
        var ae;
        this.abortController && this.abortController.abort();
        const Q = new AbortController();
        this.abortController = Q, D == null || D();
        try {
          yield this.attemptConnection(X ?? p, _, k, Q), this.abortController = void 0, j();
        } catch (ne) {
          if (this.regionUrlProvider && ne instanceof ConnectionError && ne.reason !== 3 && ne.reason !== 0) {
            let Z = null;
            try {
              Z = yield this.regionUrlProvider.getNextBestRegionUrl((ae = this.abortController) === null || ae === void 0 ? void 0 : ae.signal);
            } catch (de) {
              if (de instanceof ConnectionError && (de.status === 401 || de.reason === 3)) {
                this.handleDisconnect(this.options.stopLocalTrackOnUnpublish), ee(de);
                return;
              }
            }
            Z ? (this.log.info("Initial connection failed with ConnectionError: ".concat(ne.message, ". Retrying with another region: ").concat(Z), this.logContext), this.recreateEngine(), yield F(j, ee, Z)) : (this.handleDisconnect(this.options.stopLocalTrackOnUnpublish), ee(ne));
          } else
            this.handleDisconnect(this.options.stopLocalTrackOnUnpublish), ee(ne);
        }
      }), z = this.regionUrl;
      return this.regionUrl = void 0, this.connectFuture = new Future((j, ee) => {
        F(j, ee, z);
      }, () => {
        this.clearConnectionFutures();
      }), this.connectFuture.promise;
    }), this.connectSignal = (p, _, k, O, D, F) => __awaiter$3(this, void 0, void 0, function* () {
      var z, j, ee;
      const X = yield k.join(p, _, {
        autoSubscribe: O.autoSubscribe,
        adaptiveStream: typeof D.adaptiveStream == "object" ? !0 : D.adaptiveStream,
        maxRetries: O.maxRetries,
        e2eeEnabled: !!this.e2eeManager,
        websocketTimeout: O.websocketTimeout
      }, F.signal);
      let ae = X.serverInfo;
      if (ae || (ae = {
        version: X.serverVersion,
        region: X.serverRegion
      }), this.log.debug("connected to Livekit Server ".concat(Object.entries(ae).map((Q) => {
        let [ne, Z] = Q;
        return "".concat(ne, ": ").concat(Z);
      }).join(", ")), {
        room: (z = X.room) === null || z === void 0 ? void 0 : z.name,
        roomSid: (j = X.room) === null || j === void 0 ? void 0 : j.sid,
        identity: (ee = X.participant) === null || ee === void 0 ? void 0 : ee.identity
      }), !X.serverVersion)
        throw new UnsupportedServer("unknown server version");
      return X.serverVersion === "0.15.1" && this.options.dynacast && (this.log.debug("disabling dynacast due to server version", this.logContext), D.dynacast = !1), X;
    }), this.applyJoinResponse = (p) => {
      const _ = p.participant;
      if (this.localParticipant.sid = _.sid, this.localParticipant.identity = _.identity, this.options.e2ee && this.e2eeManager)
        try {
          this.e2eeManager.setSifTrailer(p.sifTrailer);
        } catch (k) {
          this.log.error(k instanceof Error ? k.message : "Could not set SifTrailer", Object.assign(Object.assign({}, this.logContext), {
            error: k
          }));
        }
      this.handleParticipantUpdates([_, ...p.otherParticipants]), p.room && this.handleRoomUpdate(p.room);
    }, this.attemptConnection = (p, _, k, O) => __awaiter$3(this, void 0, void 0, function* () {
      var D, F, z;
      this.state === ConnectionState.Reconnecting || this.isResuming || !((D = this.engine) === null || D === void 0) && D.pendingReconnect ? (this.log.info("Reconnection attempt replaced by new connection attempt", this.logContext), this.recreateEngine()) : this.maybeCreateEngine(), !((F = this.regionUrlProvider) === null || F === void 0) && F.isCloud() && this.engine.setRegionUrlProvider(this.regionUrlProvider), this.acquireAudioContext(), this.connOptions = Object.assign(Object.assign({}, roomConnectOptionDefaults), k), this.connOptions.rtcConfig && (this.engine.rtcConfig = this.connOptions.rtcConfig), this.connOptions.peerConnectionTimeout && (this.engine.peerConnectionTimeout = this.connOptions.peerConnectionTimeout);
      try {
        const j = yield this.connectSignal(p, _, this.engine, this.connOptions, this.options, O);
        this.applyJoinResponse(j), this.setupLocalParticipantEvents(), this.emit(RoomEvent.SignalConnected);
      } catch (j) {
        yield this.engine.close(), this.recreateEngine();
        const ee = new ConnectionError("could not establish signal connection");
        throw j instanceof Error && (ee.message = "".concat(ee.message, ": ").concat(j.message)), j instanceof ConnectionError && (ee.reason = j.reason, ee.status = j.status), this.log.debug("error trying to establish signal connection", Object.assign(Object.assign({}, this.logContext), {
          error: j
        })), ee;
      }
      if (O.signal.aborted)
        throw yield this.engine.close(), this.recreateEngine(), new ConnectionError("Connection attempt aborted");
      try {
        yield this.engine.waitForPCInitialConnection(this.connOptions.peerConnectionTimeout, O);
      } catch (j) {
        throw yield this.engine.close(), this.recreateEngine(), j;
      }
      isWeb() && this.options.disconnectOnPageLeave && (window.addEventListener("pagehide", this.onPageLeave), window.addEventListener("beforeunload", this.onPageLeave)), isWeb() && (document.addEventListener("freeze", this.onPageLeave), (z = navigator.mediaDevices) === null || z === void 0 || z.addEventListener("devicechange", this.handleDeviceChange)), this.setAndEmitConnectionState(ConnectionState.Connected), this.emit(RoomEvent.Connected), this.registerConnectionReconcile();
    }), this.disconnect = function() {
      let p = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
      return __awaiter$3(c, void 0, void 0, function* () {
        var _, k, O, D;
        const F = yield this.disconnectLock.lock();
        try {
          if (this.state === ConnectionState.Disconnected) {
            this.log.debug("already disconnected", this.logContext);
            return;
          }
          this.log.info("disconnect from room", Object.assign({}, this.logContext)), (this.state === ConnectionState.Connecting || this.state === ConnectionState.Reconnecting || this.isResuming) && (this.log.warn("abort connection attempt", this.logContext), (_ = this.abortController) === null || _ === void 0 || _.abort(), (O = (k = this.connectFuture) === null || k === void 0 ? void 0 : k.reject) === null || O === void 0 || O.call(k, new ConnectionError("Client initiated disconnect")), this.connectFuture = void 0), !((D = this.engine) === null || D === void 0) && D.client.isDisconnected || (yield this.engine.client.sendLeave()), this.engine && (yield this.engine.close()), this.handleDisconnect(p, DisconnectReason.CLIENT_INITIATED), this.engine = void 0;
        } finally {
          F();
        }
      });
    }, this.onPageLeave = () => __awaiter$3(this, void 0, void 0, function* () {
      this.log.info("Page leave detected, disconnecting", this.logContext), yield this.disconnect();
    }), this.startAudio = () => __awaiter$3(this, void 0, void 0, function* () {
      const p = [], _ = getBrowser();
      if (_ && _.os === "iOS") {
        const k = "livekit-dummy-audio-el";
        let O = document.getElementById(k);
        if (!O) {
          O = document.createElement("audio"), O.id = k, O.autoplay = !0, O.hidden = !0;
          const D = getEmptyAudioStreamTrack();
          D.enabled = !0;
          const F = new MediaStream([D]);
          O.srcObject = F, document.addEventListener("visibilitychange", () => {
            O && (O.srcObject = document.hidden ? null : F, document.hidden || (this.log.debug("page visible again, triggering startAudio to resume playback and update playback status", this.logContext), this.startAudio()));
          }), document.body.append(O), this.once(RoomEvent.Disconnected, () => {
            O == null || O.remove(), O = null;
          });
        }
        p.push(O);
      }
      this.remoteParticipants.forEach((k) => {
        k.audioTrackPublications.forEach((O) => {
          O.track && O.track.attachedElements.forEach((D) => {
            p.push(D);
          });
        });
      });
      try {
        yield Promise.all([this.acquireAudioContext(), ...p.map((k) => (k.muted = !1, k.play()))]), this.handleAudioPlaybackStarted();
      } catch (k) {
        throw this.handleAudioPlaybackFailed(k), k;
      }
    }), this.startVideo = () => __awaiter$3(this, void 0, void 0, function* () {
      const p = [];
      for (const _ of this.remoteParticipants.values())
        _.videoTrackPublications.forEach((k) => {
          var O;
          (O = k.track) === null || O === void 0 || O.attachedElements.forEach((D) => {
            p.includes(D) || p.push(D);
          });
        });
      yield Promise.all(p.map((_) => _.play())).then(() => {
        this.handleVideoPlaybackStarted();
      }).catch((_) => {
        _.name === "NotAllowedError" ? this.handleVideoPlaybackFailed() : this.log.warn("Resuming video playback failed, make sure you call `startVideo` directly in a user gesture handler", this.logContext);
      });
    }), this.handleRestarting = () => {
      this.clearConnectionReconcile(), this.isResuming = !1;
      for (const p of this.remoteParticipants.values())
        this.handleParticipantDisconnected(p.identity, p);
      this.setAndEmitConnectionState(ConnectionState.Reconnecting) && this.emit(RoomEvent.Reconnecting);
    }, this.handleSignalRestarted = (p) => __awaiter$3(this, void 0, void 0, function* () {
      this.log.debug("signal reconnected to server, region ".concat(p.serverRegion), Object.assign(Object.assign({}, this.logContext), {
        region: p.serverRegion
      })), this.bufferedEvents = [], this.applyJoinResponse(p);
      try {
        yield this.localParticipant.republishAllTracks(void 0, !0);
      } catch (_) {
        this.log.error("error trying to re-publish tracks after reconnection", Object.assign(Object.assign({}, this.logContext), {
          error: _
        }));
      }
      try {
        yield this.engine.waitForRestarted(), this.log.debug("fully reconnected to server", Object.assign(Object.assign({}, this.logContext), {
          region: p.serverRegion
        }));
      } catch {
        return;
      }
      this.setAndEmitConnectionState(ConnectionState.Connected), this.emit(RoomEvent.Reconnected), this.registerConnectionReconcile(), this.emitBufferedEvents();
    }), this.handleParticipantUpdates = (p) => {
      p.forEach((_) => {
        var k;
        if (_.identity === this.localParticipant.identity) {
          this.localParticipant.updateInfo(_);
          return;
        }
        _.identity === "" && (_.identity = (k = this.sidToIdentity.get(_.sid)) !== null && k !== void 0 ? k : "");
        let O = this.remoteParticipants.get(_.identity);
        _.state === ParticipantInfo_State.DISCONNECTED ? this.handleParticipantDisconnected(_.identity, O) : O = this.getOrCreateParticipant(_.identity, _);
      });
    }, this.handleActiveSpeakersUpdate = (p) => {
      const _ = [], k = {};
      p.forEach((O) => {
        if (k[O.sid] = !0, O.sid === this.localParticipant.sid)
          this.localParticipant.audioLevel = O.level, this.localParticipant.setIsSpeaking(!0), _.push(this.localParticipant);
        else {
          const D = this.getRemoteParticipantBySid(O.sid);
          D && (D.audioLevel = O.level, D.setIsSpeaking(!0), _.push(D));
        }
      }), k[this.localParticipant.sid] || (this.localParticipant.audioLevel = 0, this.localParticipant.setIsSpeaking(!1)), this.remoteParticipants.forEach((O) => {
        k[O.sid] || (O.audioLevel = 0, O.setIsSpeaking(!1));
      }), this.activeSpeakers = _, this.emitWhenConnected(RoomEvent.ActiveSpeakersChanged, _);
    }, this.handleSpeakersChanged = (p) => {
      const _ = /* @__PURE__ */ new Map();
      this.activeSpeakers.forEach((O) => {
        _.set(O.sid, O);
      }), p.forEach((O) => {
        let D = this.getRemoteParticipantBySid(O.sid);
        O.sid === this.localParticipant.sid && (D = this.localParticipant), D && (D.audioLevel = O.level, D.setIsSpeaking(O.active), O.active ? _.set(O.sid, D) : _.delete(O.sid));
      });
      const k = Array.from(_.values());
      k.sort((O, D) => D.audioLevel - O.audioLevel), this.activeSpeakers = k, this.emitWhenConnected(RoomEvent.ActiveSpeakersChanged, k);
    }, this.handleStreamStateUpdate = (p) => {
      p.streamStates.forEach((_) => {
        const k = this.getRemoteParticipantBySid(_.participantSid);
        if (!k)
          return;
        const O = k.getTrackPublicationBySid(_.trackSid);
        !O || !O.track || (O.track.streamState = Track.streamStateFromProto(_.state), k.emit(ParticipantEvent.TrackStreamStateChanged, O, O.track.streamState), this.emitWhenConnected(RoomEvent.TrackStreamStateChanged, O, O.track.streamState, k));
      });
    }, this.handleSubscriptionPermissionUpdate = (p) => {
      const _ = this.getRemoteParticipantBySid(p.participantSid);
      if (!_)
        return;
      const k = _.getTrackPublicationBySid(p.trackSid);
      k && k.setAllowed(p.allowed);
    }, this.handleSubscriptionError = (p) => {
      const _ = Array.from(this.remoteParticipants.values()).find((O) => O.trackPublications.has(p.trackSid));
      if (!_)
        return;
      const k = _.getTrackPublicationBySid(p.trackSid);
      k && k.setSubscriptionError(p.err);
    }, this.handleDataPacket = (p, _) => {
      const k = this.remoteParticipants.get(p.participantIdentity);
      this.emit(RoomEvent.DataReceived, p.payload, k, _, p.topic), k == null || k.emit(ParticipantEvent.DataReceived, p.payload, _);
    }, this.handleAudioPlaybackStarted = () => {
      this.canPlaybackAudio || (this.audioEnabled = !0, this.emit(RoomEvent.AudioPlaybackStatusChanged, !0));
    }, this.handleAudioPlaybackFailed = (p) => {
      this.log.warn("could not playback audio", Object.assign(Object.assign({}, this.logContext), {
        error: p
      })), this.canPlaybackAudio && (this.audioEnabled = !1, this.emit(RoomEvent.AudioPlaybackStatusChanged, !1));
    }, this.handleVideoPlaybackStarted = () => {
      this.isVideoPlaybackBlocked && (this.isVideoPlaybackBlocked = !1, this.emit(RoomEvent.VideoPlaybackStatusChanged, !0));
    }, this.handleVideoPlaybackFailed = () => {
      this.isVideoPlaybackBlocked || (this.isVideoPlaybackBlocked = !0, this.emit(RoomEvent.VideoPlaybackStatusChanged, !1));
    }, this.handleDeviceChange = () => __awaiter$3(this, void 0, void 0, function* () {
      this.emit(RoomEvent.MediaDevicesChanged);
    }), this.handleRoomUpdate = (p) => {
      const _ = this.roomInfo;
      this.roomInfo = p, _ && _.metadata !== p.metadata && this.emitWhenConnected(RoomEvent.RoomMetadataChanged, p.metadata), (_ == null ? void 0 : _.activeRecording) !== p.activeRecording && this.emitWhenConnected(RoomEvent.RecordingStatusChanged, p.activeRecording);
    }, this.handleConnectionQualityUpdate = (p) => {
      p.updates.forEach((_) => {
        if (_.participantSid === this.localParticipant.sid) {
          this.localParticipant.setConnectionQuality(_.quality);
          return;
        }
        const k = this.getRemoteParticipantBySid(_.participantSid);
        k && k.setConnectionQuality(_.quality);
      });
    }, this.onLocalParticipantMetadataChanged = (p) => {
      this.emit(RoomEvent.ParticipantMetadataChanged, p, this.localParticipant);
    }, this.onLocalParticipantNameChanged = (p) => {
      this.emit(RoomEvent.ParticipantNameChanged, p, this.localParticipant);
    }, this.onLocalTrackMuted = (p) => {
      this.emit(RoomEvent.TrackMuted, p, this.localParticipant);
    }, this.onLocalTrackUnmuted = (p) => {
      this.emit(RoomEvent.TrackUnmuted, p, this.localParticipant);
    }, this.onTrackProcessorUpdate = (p) => {
      var _;
      (_ = p == null ? void 0 : p.onPublish) === null || _ === void 0 || _.call(p, this);
    }, this.onLocalTrackPublished = (p) => __awaiter$3(this, void 0, void 0, function* () {
      var _, k, O, D, F;
      (_ = p.track) === null || _ === void 0 || _.on(TrackEvent.TrackProcessorUpdate, this.onTrackProcessorUpdate), (D = (O = (k = p.track) === null || k === void 0 ? void 0 : k.getProcessor()) === null || O === void 0 ? void 0 : O.onPublish) === null || D === void 0 || D.call(O, this), this.emit(RoomEvent.LocalTrackPublished, p, this.localParticipant), p.track instanceof LocalAudioTrack && (yield p.track.checkForSilence()) && this.emit(RoomEvent.LocalAudioSilenceDetected, p);
      const z = yield (F = p.track) === null || F === void 0 ? void 0 : F.getDeviceId(), j = sourceToKind(p.source);
      j && z && z !== this.localParticipant.activeDeviceMap.get(j) && (this.localParticipant.activeDeviceMap.set(j, z), this.emit(RoomEvent.ActiveDeviceChanged, j, z));
    }), this.onLocalTrackUnpublished = (p) => {
      var _;
      (_ = p.track) === null || _ === void 0 || _.off(TrackEvent.TrackProcessorUpdate, this.onTrackProcessorUpdate), this.emit(RoomEvent.LocalTrackUnpublished, p, this.localParticipant);
    }, this.onLocalConnectionQualityChanged = (p) => {
      this.emit(RoomEvent.ConnectionQualityChanged, p, this.localParticipant);
    }, this.onMediaDevicesError = (p) => {
      this.emit(RoomEvent.MediaDevicesError, p);
    }, this.onLocalParticipantPermissionsChanged = (p) => {
      this.emit(RoomEvent.ParticipantPermissionsChanged, p, this.localParticipant);
    }, this.setMaxListeners(100), this.remoteParticipants = /* @__PURE__ */ new Map(), this.sidToIdentity = /* @__PURE__ */ new Map(), this.options = Object.assign(Object.assign({}, roomOptionDefaults), u), this.log = getLogger((l = this.options.loggerName) !== null && l !== void 0 ? l : LoggerNames.Room), this.options.audioCaptureDefaults = Object.assign(Object.assign({}, audioDefaults), u == null ? void 0 : u.audioCaptureDefaults), this.options.videoCaptureDefaults = Object.assign(Object.assign({}, videoDefaults), u == null ? void 0 : u.videoCaptureDefaults), this.options.publishDefaults = Object.assign(Object.assign({}, publishDefaults), u == null ? void 0 : u.publishDefaults), this.maybeCreateEngine(), this.disconnectLock = new Mutex(), this.localParticipant = new LocalParticipant("", "", this.engine, this.options), this.options.videoCaptureDefaults.deviceId && this.localParticipant.activeDeviceMap.set("videoinput", unwrapConstraint(this.options.videoCaptureDefaults.deviceId)), this.options.audioCaptureDefaults.deviceId && this.localParticipant.activeDeviceMap.set("audioinput", unwrapConstraint(this.options.audioCaptureDefaults.deviceId)), !((v = this.options.audioOutput) === null || v === void 0) && v.deviceId && this.switchActiveDevice("audiooutput", unwrapConstraint(this.options.audioOutput.deviceId)).catch((p) => this.log.warn("Could not set audio output: ".concat(p.message), this.logContext)), this.options.e2ee && this.setupE2EE();
  }
  /**
   * @experimental
   */
  setE2EEEnabled(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (this.e2eeManager)
        yield Promise.all([this.localParticipant.setE2EEEnabled(u)]), this.localParticipant.identity !== "" && this.e2eeManager.setParticipantCryptorEnabled(u, this.localParticipant.identity);
      else
        throw Error("e2ee not configured, please set e2ee settings within the room options");
    });
  }
  setupE2EE() {
    var u;
    this.options.e2ee && (this.e2eeManager = new E2EEManager(this.options.e2ee), this.e2eeManager.on(EncryptionEvent.ParticipantEncryptionStatusChanged, (c, l) => {
      l instanceof LocalParticipant && (this.isE2EEEnabled = c), this.emit(RoomEvent.ParticipantEncryptionStatusChanged, c, l);
    }), this.e2eeManager.on(EncryptionEvent.EncryptionError, (c) => this.emit(RoomEvent.EncryptionError, c)), (u = this.e2eeManager) === null || u === void 0 || u.setup(this));
  }
  get logContext() {
    var u;
    return {
      room: this.name,
      roomID: (u = this.roomInfo) === null || u === void 0 ? void 0 : u.sid,
      participant: this.localParticipant.identity,
      pID: this.localParticipant.sid
    };
  }
  /**
   * if the current room has a participant with `recorder: true` in its JWT grant
   **/
  get isRecording() {
    var u, c;
    return (c = (u = this.roomInfo) === null || u === void 0 ? void 0 : u.activeRecording) !== null && c !== void 0 ? c : !1;
  }
  /**
   * server assigned unique room id.
   * returns once a sid has been issued by the server.
   */
  getSid() {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this.state === ConnectionState.Disconnected ? "" : this.roomInfo && this.roomInfo.sid !== "" ? this.roomInfo.sid : new Promise((u, c) => {
        const l = (v) => {
          v.sid !== "" && (this.engine.off(EngineEvent.RoomUpdate, l), u(v.sid));
        };
        this.engine.on(EngineEvent.RoomUpdate, l), this.once(RoomEvent.Disconnected, () => {
          this.engine.off(EngineEvent.RoomUpdate, l), c("Room disconnected before room server id was available");
        });
      });
    });
  }
  /** user assigned name, derived from JWT token */
  get name() {
    var u, c;
    return (c = (u = this.roomInfo) === null || u === void 0 ? void 0 : u.name) !== null && c !== void 0 ? c : "";
  }
  /** room metadata */
  get metadata() {
    var u;
    return (u = this.roomInfo) === null || u === void 0 ? void 0 : u.metadata;
  }
  get numParticipants() {
    var u, c;
    return (c = (u = this.roomInfo) === null || u === void 0 ? void 0 : u.numParticipants) !== null && c !== void 0 ? c : 0;
  }
  get numPublishers() {
    var u, c;
    return (c = (u = this.roomInfo) === null || u === void 0 ? void 0 : u.numPublishers) !== null && c !== void 0 ? c : 0;
  }
  maybeCreateEngine() {
    this.engine && !this.engine.isClosed || (this.engine = new RTCEngine(this.options), this.engine.on(EngineEvent.ParticipantUpdate, this.handleParticipantUpdates).on(EngineEvent.RoomUpdate, this.handleRoomUpdate).on(EngineEvent.SpeakersChanged, this.handleSpeakersChanged).on(EngineEvent.StreamStateChanged, this.handleStreamStateUpdate).on(EngineEvent.ConnectionQualityUpdate, this.handleConnectionQualityUpdate).on(EngineEvent.SubscriptionError, this.handleSubscriptionError).on(EngineEvent.SubscriptionPermissionUpdate, this.handleSubscriptionPermissionUpdate).on(EngineEvent.MediaTrackAdded, (u, c, l) => {
      this.onTrackAdded(u, c, l);
    }).on(EngineEvent.Disconnected, (u) => {
      this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, u);
    }).on(EngineEvent.ActiveSpeakersUpdate, this.handleActiveSpeakersUpdate).on(EngineEvent.DataPacketReceived, this.handleDataPacket).on(EngineEvent.Resuming, () => {
      this.clearConnectionReconcile(), this.isResuming = !0, this.log.info("Resuming signal connection", this.logContext);
    }).on(EngineEvent.Resumed, () => {
      this.registerConnectionReconcile(), this.isResuming = !1, this.log.info("Resumed signal connection", this.logContext), this.updateSubscriptions(), this.emitBufferedEvents();
    }).on(EngineEvent.SignalResumed, () => {
      this.bufferedEvents = [], (this.state === ConnectionState.Reconnecting || this.isResuming) && this.sendSyncState();
    }).on(EngineEvent.Restarting, this.handleRestarting).on(EngineEvent.SignalRestarted, this.handleSignalRestarted).on(EngineEvent.Offline, () => {
      this.setAndEmitConnectionState(ConnectionState.Reconnecting) && this.emit(RoomEvent.Reconnecting);
    }).on(EngineEvent.DCBufferStatusChanged, (u, c) => {
      this.emit(RoomEvent.DCBufferStatusChanged, u, c);
    }), this.localParticipant && this.localParticipant.setupEngine(this.engine), this.e2eeManager && this.e2eeManager.setupEngine(this.engine));
  }
  /**
   * getLocalDevices abstracts navigator.mediaDevices.enumerateDevices.
   * In particular, it handles Chrome's unique behavior of creating `default`
   * devices. When encountered, it'll be removed from the list of devices.
   * The actual default device will be placed at top.
   * @param kind
   * @returns a list of available local devices
   */
  static getLocalDevices(u) {
    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
    return DeviceManager.getInstance().getDevices(u, c);
  }
  /**
   * prepareConnection should be called as soon as the page is loaded, in order
   * to speed up the connection attempt. This function will
   * - perform DNS resolution and pre-warm the DNS cache
   * - establish TLS connection and cache TLS keys
   *
   * With LiveKit Cloud, it will also determine the best edge data center for
   * the current client to connect to if a token is provided.
   */
  prepareConnection(u, c) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (this.state === ConnectionState.Disconnected) {
        this.log.debug("prepareConnection to ".concat(u), this.logContext);
        try {
          if (isCloud(new URL(u)) && c) {
            this.regionUrlProvider = new RegionUrlProvider(u, c);
            const l = yield this.regionUrlProvider.getNextBestRegionUrl();
            l && this.state === ConnectionState.Disconnected && (this.regionUrl = l, yield fetch(toHttpUrl(l), {
              method: "HEAD"
            }), this.log.debug("prepared connection to ".concat(l), this.logContext));
          } else
            yield fetch(toHttpUrl(u), {
              method: "HEAD"
            });
        } catch (l) {
          this.log.warn("could not prepare connection", Object.assign(Object.assign({}, this.logContext), {
            error: l
          }));
        }
      }
    });
  }
  /**
   * retrieves a participant by identity
   * @param identity
   * @returns
   */
  getParticipantByIdentity(u) {
    return this.localParticipant.identity === u ? this.localParticipant : this.remoteParticipants.get(u);
  }
  clearConnectionFutures() {
    this.connectFuture = void 0;
  }
  /**
   * @internal for testing
   */
  simulateScenario(u, c) {
    return __awaiter$3(this, void 0, void 0, function* () {
      let l = () => {
      }, v;
      switch (u) {
        case "signal-reconnect":
          yield this.engine.client.handleOnClose("simulate disconnect");
          break;
        case "speaker":
          v = new SimulateScenario({
            scenario: {
              case: "speakerUpdate",
              value: 3
            }
          });
          break;
        case "node-failure":
          v = new SimulateScenario({
            scenario: {
              case: "nodeFailure",
              value: !0
            }
          });
          break;
        case "server-leave":
          v = new SimulateScenario({
            scenario: {
              case: "serverLeave",
              value: !0
            }
          });
          break;
        case "migration":
          v = new SimulateScenario({
            scenario: {
              case: "migration",
              value: !0
            }
          });
          break;
        case "resume-reconnect":
          this.engine.failNext(), yield this.engine.client.handleOnClose("simulate resume-disconnect");
          break;
        case "disconnect-signal-on-resume":
          l = () => __awaiter$3(this, void 0, void 0, function* () {
            yield this.engine.client.handleOnClose("simulate resume-disconnect");
          }), v = new SimulateScenario({
            scenario: {
              case: "disconnectSignalOnResume",
              value: !0
            }
          });
          break;
        case "disconnect-signal-on-resume-no-messages":
          l = () => __awaiter$3(this, void 0, void 0, function* () {
            yield this.engine.client.handleOnClose("simulate resume-disconnect");
          }), v = new SimulateScenario({
            scenario: {
              case: "disconnectSignalOnResumeNoMessages",
              value: !0
            }
          });
          break;
        case "full-reconnect":
          this.engine.fullReconnectOnNext = !0, yield this.engine.client.handleOnClose("simulate full-reconnect");
          break;
        case "force-tcp":
        case "force-tls":
          v = new SimulateScenario({
            scenario: {
              case: "switchCandidateProtocol",
              value: u === "force-tls" ? 2 : 1
            }
          }), l = () => __awaiter$3(this, void 0, void 0, function* () {
            const p = this.engine.client.onLeave;
            p && p(new LeaveRequest({
              reason: DisconnectReason.CLIENT_INITIATED,
              canReconnect: !0
            }));
          });
          break;
        case "subscriber-bandwidth":
          if (c === void 0 || typeof c != "number")
            throw new Error("subscriber-bandwidth requires a number as argument");
          v = new SimulateScenario({
            scenario: {
              case: "subscriberBandwidth",
              value: BigInt(c)
            }
          });
          break;
      }
      v && (yield this.engine.client.sendSimulateScenario(v), yield l());
    });
  }
  /**
   * Returns true if audio playback is enabled
   */
  get canPlaybackAudio() {
    return this.audioEnabled;
  }
  /**
   * Returns true if video playback is enabled
   */
  get canPlaybackVideo() {
    return !this.isVideoPlaybackBlocked;
  }
  getActiveDevice(u) {
    return this.localParticipant.activeDeviceMap.get(u);
  }
  /**
   * Switches all active devices used in this room to the given device.
   *
   * Note: setting AudioOutput is not supported on some browsers. See [setSinkId](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/setSinkId#browser_compatibility)
   *
   * @param kind use `videoinput` for camera track,
   *  `audioinput` for microphone track,
   *  `audiooutput` to set speaker for all incoming audio tracks
   * @param deviceId
   */
  switchActiveDevice(u, c) {
    let l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
    var v, p, _, k;
    return __awaiter$3(this, void 0, void 0, function* () {
      let O = !1, D = !0;
      const F = l ? {
        exact: c
      } : c;
      if (u === "audioinput") {
        const z = this.options.audioCaptureDefaults.deviceId;
        this.options.audioCaptureDefaults.deviceId = F, O = z !== F;
        const j = Array.from(this.localParticipant.audioTrackPublications.values()).filter((ee) => ee.source === Track.Source.Microphone);
        try {
          D = (yield Promise.all(j.map((ee) => {
            var X;
            return (X = ee.audioTrack) === null || X === void 0 ? void 0 : X.setDeviceId(F);
          }))).every((ee) => ee === !0);
        } catch (ee) {
          throw this.options.audioCaptureDefaults.deviceId = z, ee;
        }
      } else if (u === "videoinput") {
        const z = this.options.videoCaptureDefaults.deviceId;
        this.options.videoCaptureDefaults.deviceId = F, O = z !== F;
        const j = Array.from(this.localParticipant.videoTrackPublications.values()).filter((ee) => ee.source === Track.Source.Camera);
        try {
          D = (yield Promise.all(j.map((ee) => {
            var X;
            return (X = ee.videoTrack) === null || X === void 0 ? void 0 : X.setDeviceId(F);
          }))).every((ee) => ee === !0);
        } catch (ee) {
          throw this.options.videoCaptureDefaults.deviceId = z, ee;
        }
      } else if (u === "audiooutput") {
        if (!supportsSetSinkId() && !this.options.webAudioMix || this.options.webAudioMix && this.audioContext && !("setSinkId" in this.audioContext))
          throw new Error("cannot switch audio output, setSinkId not supported");
        this.options.webAudioMix && (c = (v = yield DeviceManager.getInstance().normalizeDeviceId("audiooutput", c)) !== null && v !== void 0 ? v : ""), (p = (k = this.options).audioOutput) !== null && p !== void 0 || (k.audioOutput = {});
        const z = this.options.audioOutput.deviceId;
        this.options.audioOutput.deviceId = c, O = z !== F;
        try {
          this.options.webAudioMix ? (_ = this.audioContext) === null || _ === void 0 || _.setSinkId(c) : yield Promise.all(Array.from(this.remoteParticipants.values()).map((j) => j.setAudioOutput({
            deviceId: c
          })));
        } catch (j) {
          throw this.options.audioOutput.deviceId = z, j;
        }
      }
      return O && D && (this.localParticipant.activeDeviceMap.set(u, c), this.emit(RoomEvent.ActiveDeviceChanged, u, c)), D;
    });
  }
  setupLocalParticipantEvents() {
    this.localParticipant.on(ParticipantEvent.ParticipantMetadataChanged, this.onLocalParticipantMetadataChanged).on(ParticipantEvent.ParticipantNameChanged, this.onLocalParticipantNameChanged).on(ParticipantEvent.TrackMuted, this.onLocalTrackMuted).on(ParticipantEvent.TrackUnmuted, this.onLocalTrackUnmuted).on(ParticipantEvent.LocalTrackPublished, this.onLocalTrackPublished).on(ParticipantEvent.LocalTrackUnpublished, this.onLocalTrackUnpublished).on(ParticipantEvent.ConnectionQualityChanged, this.onLocalConnectionQualityChanged).on(ParticipantEvent.MediaDevicesError, this.onMediaDevicesError).on(ParticipantEvent.AudioStreamAcquired, this.startAudio).on(ParticipantEvent.ParticipantPermissionsChanged, this.onLocalParticipantPermissionsChanged);
  }
  recreateEngine() {
    var u;
    (u = this.engine) === null || u === void 0 || u.close(), this.engine = void 0, this.isResuming = !1, this.remoteParticipants.clear(), this.sidToIdentity.clear(), this.bufferedEvents = [], this.maybeCreateEngine();
  }
  onTrackAdded(u, c, l) {
    if (this.state === ConnectionState.Connecting || this.state === ConnectionState.Reconnecting) {
      const F = () => {
        this.onTrackAdded(u, c, l), z();
      }, z = () => {
        this.off(RoomEvent.Reconnected, F), this.off(RoomEvent.Connected, F), this.off(RoomEvent.Disconnected, z);
      };
      this.once(RoomEvent.Reconnected, F), this.once(RoomEvent.Connected, F), this.once(RoomEvent.Disconnected, z);
      return;
    }
    if (this.state === ConnectionState.Disconnected) {
      this.log.warn("skipping incoming track after Room disconnected", this.logContext);
      return;
    }
    const v = unpackStreamId(c.id), p = v[0];
    let _ = v[1], k = u.id;
    if (_ && _.startsWith("TR") && (k = _), p === this.localParticipant.sid) {
      this.log.warn("tried to create RemoteParticipant for local participant", this.logContext);
      return;
    }
    const O = Array.from(this.remoteParticipants.values()).find((F) => F.sid === p);
    if (!O) {
      this.log.error("Tried to add a track for a participant, that's not present. Sid: ".concat(p), this.logContext);
      return;
    }
    let D;
    this.options.adaptiveStream && (typeof this.options.adaptiveStream == "object" ? D = this.options.adaptiveStream : D = {}), O.addSubscribedMediaTrack(u, k, c, l, D);
  }
  handleDisconnect() {
    let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0, c = arguments.length > 1 ? arguments[1] : void 0;
    var l;
    if (this.clearConnectionReconcile(), this.isResuming = !1, this.bufferedEvents = [], this.state !== ConnectionState.Disconnected) {
      this.regionUrl = void 0;
      try {
        this.remoteParticipants.forEach((v) => {
          v.trackPublications.forEach((p) => {
            v.unpublishTrack(p.trackSid);
          });
        }), this.localParticipant.trackPublications.forEach((v) => {
          var p, _;
          v.track && this.localParticipant.unpublishTrack(v.track, u), u && ((p = v.track) === null || p === void 0 || p.detach(), (_ = v.track) === null || _ === void 0 || _.stop());
        }), this.localParticipant.off(ParticipantEvent.ParticipantMetadataChanged, this.onLocalParticipantMetadataChanged).off(ParticipantEvent.ParticipantNameChanged, this.onLocalParticipantNameChanged).off(ParticipantEvent.TrackMuted, this.onLocalTrackMuted).off(ParticipantEvent.TrackUnmuted, this.onLocalTrackUnmuted).off(ParticipantEvent.LocalTrackPublished, this.onLocalTrackPublished).off(ParticipantEvent.LocalTrackUnpublished, this.onLocalTrackUnpublished).off(ParticipantEvent.ConnectionQualityChanged, this.onLocalConnectionQualityChanged).off(ParticipantEvent.MediaDevicesError, this.onMediaDevicesError).off(ParticipantEvent.AudioStreamAcquired, this.startAudio).off(ParticipantEvent.ParticipantPermissionsChanged, this.onLocalParticipantPermissionsChanged), this.localParticipant.trackPublications.clear(), this.localParticipant.videoTrackPublications.clear(), this.localParticipant.audioTrackPublications.clear(), this.remoteParticipants.clear(), this.sidToIdentity.clear(), this.activeSpeakers = [], this.audioContext && typeof this.options.webAudioMix == "boolean" && (this.audioContext.close(), this.audioContext = void 0), isWeb() && (window.removeEventListener("beforeunload", this.onPageLeave), window.removeEventListener("pagehide", this.onPageLeave), window.removeEventListener("freeze", this.onPageLeave), (l = navigator.mediaDevices) === null || l === void 0 || l.removeEventListener("devicechange", this.handleDeviceChange));
      } finally {
        this.setAndEmitConnectionState(ConnectionState.Disconnected), this.emit(RoomEvent.Disconnected, c);
      }
    }
  }
  handleParticipantDisconnected(u, c) {
    this.remoteParticipants.delete(u), c && (c.trackPublications.forEach((l) => {
      c.unpublishTrack(l.trackSid, !0);
    }), this.emit(RoomEvent.ParticipantDisconnected, c));
  }
  acquireAudioContext() {
    var u, c;
    return __awaiter$3(this, void 0, void 0, function* () {
      if (typeof this.options.webAudioMix != "boolean" && this.options.webAudioMix.audioContext ? this.audioContext = this.options.webAudioMix.audioContext : (!this.audioContext || this.audioContext.state === "closed") && (this.audioContext = (u = getNewAudioContext()) !== null && u !== void 0 ? u : void 0), this.audioContext && this.audioContext.state === "suspended")
        try {
          yield this.audioContext.resume();
        } catch (v) {
          this.log.warn("Could not resume audio context", Object.assign(Object.assign({}, this.logContext), {
            error: v
          }));
        }
      this.options.webAudioMix && this.remoteParticipants.forEach((v) => v.setAudioContext(this.audioContext)), this.localParticipant.setAudioContext(this.audioContext);
      const l = ((c = this.audioContext) === null || c === void 0 ? void 0 : c.state) === "running";
      l !== this.canPlaybackAudio && (this.audioEnabled = l, this.emit(RoomEvent.AudioPlaybackStatusChanged, l));
    });
  }
  createParticipant(u, c) {
    var l;
    let v;
    return c ? v = RemoteParticipant.fromParticipantInfo(this.engine.client, c) : v = new RemoteParticipant(this.engine.client, "", u, void 0, void 0, {
      loggerContextCb: () => this.logContext,
      loggerName: this.options.loggerName
    }), this.options.webAudioMix && v.setAudioContext(this.audioContext), !((l = this.options.audioOutput) === null || l === void 0) && l.deviceId && v.setAudioOutput(this.options.audioOutput).catch((p) => this.log.warn("Could not set audio output: ".concat(p.message), this.logContext)), v;
  }
  getOrCreateParticipant(u, c) {
    if (this.remoteParticipants.has(u)) {
      const v = this.remoteParticipants.get(u);
      return c && v.updateInfo(c) && this.sidToIdentity.set(c.sid, c.identity), v;
    }
    const l = this.createParticipant(u, c);
    return this.remoteParticipants.set(u, l), this.sidToIdentity.set(c.sid, c.identity), this.emitWhenConnected(RoomEvent.ParticipantConnected, l), l.on(ParticipantEvent.TrackPublished, (v) => {
      this.emitWhenConnected(RoomEvent.TrackPublished, v, l);
    }).on(ParticipantEvent.TrackSubscribed, (v, p) => {
      v.kind === Track.Kind.Audio ? (v.on(TrackEvent.AudioPlaybackStarted, this.handleAudioPlaybackStarted), v.on(TrackEvent.AudioPlaybackFailed, this.handleAudioPlaybackFailed)) : v.kind === Track.Kind.Video && (v.on(TrackEvent.VideoPlaybackFailed, this.handleVideoPlaybackFailed), v.on(TrackEvent.VideoPlaybackStarted, this.handleVideoPlaybackStarted)), this.emit(RoomEvent.TrackSubscribed, v, p, l);
    }).on(ParticipantEvent.TrackUnpublished, (v) => {
      this.emit(RoomEvent.TrackUnpublished, v, l);
    }).on(ParticipantEvent.TrackUnsubscribed, (v, p) => {
      this.emit(RoomEvent.TrackUnsubscribed, v, p, l);
    }).on(ParticipantEvent.TrackSubscriptionFailed, (v) => {
      this.emit(RoomEvent.TrackSubscriptionFailed, v, l);
    }).on(ParticipantEvent.TrackMuted, (v) => {
      this.emitWhenConnected(RoomEvent.TrackMuted, v, l);
    }).on(ParticipantEvent.TrackUnmuted, (v) => {
      this.emitWhenConnected(RoomEvent.TrackUnmuted, v, l);
    }).on(ParticipantEvent.ParticipantMetadataChanged, (v) => {
      this.emitWhenConnected(RoomEvent.ParticipantMetadataChanged, v, l);
    }).on(ParticipantEvent.ParticipantNameChanged, (v) => {
      this.emitWhenConnected(RoomEvent.ParticipantNameChanged, v, l);
    }).on(ParticipantEvent.ConnectionQualityChanged, (v) => {
      this.emitWhenConnected(RoomEvent.ConnectionQualityChanged, v, l);
    }).on(ParticipantEvent.ParticipantPermissionsChanged, (v) => {
      this.emitWhenConnected(RoomEvent.ParticipantPermissionsChanged, v, l);
    }).on(ParticipantEvent.TrackSubscriptionStatusChanged, (v, p) => {
      this.emitWhenConnected(RoomEvent.TrackSubscriptionStatusChanged, v, p, l);
    }).on(ParticipantEvent.TrackSubscriptionFailed, (v, p) => {
      this.emit(RoomEvent.TrackSubscriptionFailed, v, l, p);
    }).on(ParticipantEvent.TrackSubscriptionPermissionChanged, (v, p) => {
      this.emitWhenConnected(RoomEvent.TrackSubscriptionPermissionChanged, v, p, l);
    }), c && l.updateInfo(c), l;
  }
  sendSyncState() {
    const u = Array.from(this.remoteParticipants.values()).reduce((l, v) => (l.push(...v.getTrackPublications()), l), []), c = this.localParticipant.getTrackPublications();
    this.engine.sendSyncState(u, c);
  }
  /**
   * After resuming, we'll need to notify the server of the current
   * subscription settings.
   */
  updateSubscriptions() {
    for (const u of this.remoteParticipants.values())
      for (const c of u.videoTrackPublications.values())
        c.isSubscribed && c instanceof RemoteTrackPublication && c.emitTrackUpdate();
  }
  getRemoteParticipantBySid(u) {
    const c = this.sidToIdentity.get(u);
    if (c)
      return this.remoteParticipants.get(c);
  }
  registerConnectionReconcile() {
    this.clearConnectionReconcile();
    let u = 0;
    this.connectionReconcileInterval = CriticalTimers.setInterval(() => {
      // ensure we didn't tear it down
      !this.engine || // engine detected close, but Room missed it
      this.engine.isClosed || // transports failed without notifying engine
      !this.engine.verifyTransport() ? (u++, this.log.warn("detected connection state mismatch", Object.assign(Object.assign({}, this.logContext), {
        numFailures: u,
        engine: {
          closed: this.engine.isClosed,
          transportsConnected: this.engine.verifyTransport()
        }
      })), u >= 3 && (this.recreateEngine(), this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, DisconnectReason.STATE_MISMATCH))) : u = 0;
    }, connectionReconcileFrequency);
  }
  clearConnectionReconcile() {
    this.connectionReconcileInterval && CriticalTimers.clearInterval(this.connectionReconcileInterval);
  }
  setAndEmitConnectionState(u) {
    return u === this.state ? !1 : (this.state = u, this.emit(RoomEvent.ConnectionStateChanged, this.state), !0);
  }
  emitBufferedEvents() {
    this.bufferedEvents.forEach((u) => {
      let [c, l] = u;
      this.emit(c, ...l);
    }), this.bufferedEvents = [];
  }
  emitWhenConnected(u) {
    for (var c = arguments.length, l = new Array(c > 1 ? c - 1 : 0), v = 1; v < c; v++)
      l[v - 1] = arguments[v];
    if (this.state === ConnectionState.Reconnecting || this.isResuming || !this.engine || this.engine.pendingReconnect)
      this.bufferedEvents.push([u, l]);
    else if (this.state === ConnectionState.Connected)
      return this.emit(u, ...l);
    return !1;
  }
  /**
   * Allows to populate a room with simulated participants.
   * No actual connection to a server will be established, all state is
   * @experimental
   */
  simulateParticipants(u) {
    var c, l;
    return __awaiter$3(this, void 0, void 0, function* () {
      const v = Object.assign({
        audio: !0,
        video: !0,
        useRealTracks: !1
      }, u.publish), p = Object.assign({
        count: 9,
        audio: !1,
        video: !0,
        aspectRatios: [1.66, 1.7, 1.3]
      }, u.participants);
      if (this.handleDisconnect(), this.roomInfo = new Room$1({
        sid: "RM_SIMULATED",
        name: "simulated-room",
        emptyTimeout: 0,
        maxParticipants: 0,
        creationTime: protoInt64.parse((/* @__PURE__ */ new Date()).getTime()),
        metadata: "",
        numParticipants: 1,
        numPublishers: 1,
        turnPassword: "",
        enabledCodecs: [],
        activeRecording: !1
      }), this.localParticipant.updateInfo(new ParticipantInfo({
        identity: "simulated-local",
        name: "local-name"
      })), this.setupLocalParticipantEvents(), this.emit(RoomEvent.SignalConnected), this.emit(RoomEvent.Connected), this.setAndEmitConnectionState(ConnectionState.Connected), v.video) {
        const _ = new LocalTrackPublication(Track.Kind.Video, new TrackInfo({
          source: TrackSource.CAMERA,
          sid: Math.floor(Math.random() * 1e4).toString(),
          type: TrackType.AUDIO,
          name: "video-dummy"
        }), new LocalVideoTrack(v.useRealTracks ? (yield window.navigator.mediaDevices.getUserMedia({
          video: !0
        })).getVideoTracks()[0] : createDummyVideoStreamTrack(160 * ((c = p.aspectRatios[0]) !== null && c !== void 0 ? c : 1), 160, !0, !0), void 0, !1, {
          loggerName: this.options.loggerName,
          loggerContextCb: () => this.logContext
        }), {
          loggerName: this.options.loggerName,
          loggerContextCb: () => this.logContext
        });
        this.localParticipant.addTrackPublication(_), this.localParticipant.emit(ParticipantEvent.LocalTrackPublished, _);
      }
      if (v.audio) {
        const _ = new LocalTrackPublication(Track.Kind.Audio, new TrackInfo({
          source: TrackSource.MICROPHONE,
          sid: Math.floor(Math.random() * 1e4).toString(),
          type: TrackType.AUDIO
        }), new LocalAudioTrack(v.useRealTracks ? (yield navigator.mediaDevices.getUserMedia({
          audio: !0
        })).getAudioTracks()[0] : getEmptyAudioStreamTrack(), void 0, !1, this.audioContext, {
          loggerName: this.options.loggerName,
          loggerContextCb: () => this.logContext
        }), {
          loggerName: this.options.loggerName,
          loggerContextCb: () => this.logContext
        });
        this.localParticipant.addTrackPublication(_), this.localParticipant.emit(ParticipantEvent.LocalTrackPublished, _);
      }
      for (let _ = 0; _ < p.count - 1; _ += 1) {
        let k = new ParticipantInfo({
          sid: Math.floor(Math.random() * 1e4).toString(),
          identity: "simulated-".concat(_),
          state: ParticipantInfo_State.ACTIVE,
          tracks: [],
          joinedAt: protoInt64.parse(Date.now())
        });
        const O = this.getOrCreateParticipant(k.identity, k);
        if (p.video) {
          const D = createDummyVideoStreamTrack(160 * ((l = p.aspectRatios[_ % p.aspectRatios.length]) !== null && l !== void 0 ? l : 1), 160, !1, !0), F = new TrackInfo({
            source: TrackSource.CAMERA,
            sid: Math.floor(Math.random() * 1e4).toString(),
            type: TrackType.AUDIO
          });
          O.addSubscribedMediaTrack(D, F.sid, new MediaStream([D])), k.tracks = [...k.tracks, F];
        }
        if (p.audio) {
          const D = getEmptyAudioStreamTrack(), F = new TrackInfo({
            source: TrackSource.MICROPHONE,
            sid: Math.floor(Math.random() * 1e4).toString(),
            type: TrackType.AUDIO
          });
          O.addSubscribedMediaTrack(D, F.sid, new MediaStream([D])), k.tracks = [...k.tracks, F];
        }
        O.updateInfo(k);
      }
    });
  }
  // /** @internal */
  emit(u) {
    for (var c = arguments.length, l = new Array(c > 1 ? c - 1 : 0), v = 1; v < c; v++)
      l[v - 1] = arguments[v];
    if (u !== RoomEvent.ActiveSpeakersChanged) {
      const p = mapArgs(l).filter((_) => _ !== void 0);
      this.log.debug("room event ".concat(u), Object.assign(Object.assign({}, this.logContext), {
        event: u,
        args: p
      }));
    }
    return super.emit(u, ...l);
  }
}
function mapArgs(a) {
  return a.map((u) => {
    if (u)
      return Array.isArray(u) ? mapArgs(u) : typeof u == "object" ? "logContext" in u && u.logContext : u;
  });
}
var CheckStatus;
(function(a) {
  a[a.IDLE = 0] = "IDLE", a[a.RUNNING = 1] = "RUNNING", a[a.SKIPPED = 2] = "SKIPPED", a[a.SUCCESS = 3] = "SUCCESS", a[a.FAILED = 4] = "FAILED";
})(CheckStatus || (CheckStatus = {}));
class Checker extends eventsExports$1.EventEmitter {
  constructor(u, c) {
    let l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    super(), this.status = CheckStatus.IDLE, this.logs = [], this.errorsAsWarnings = !1, this.url = u, this.token = c, this.name = this.constructor.name, this.room = new Room(l.roomOptions), this.connectOptions = l.connectOptions, l.errorsAsWarnings && (this.errorsAsWarnings = l.errorsAsWarnings);
  }
  run(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (this.status !== CheckStatus.IDLE)
        throw Error("check is running already");
      this.setStatus(CheckStatus.RUNNING);
      try {
        yield this.perform();
      } catch (c) {
        c instanceof Error && (this.errorsAsWarnings ? this.appendWarning(c.message) : this.appendError(c.message));
      }
      return yield this.disconnect(), yield new Promise((c) => setTimeout(c, 500)), this.status !== CheckStatus.SKIPPED && this.setStatus(this.isSuccess() ? CheckStatus.SUCCESS : CheckStatus.FAILED), u && u(), this.getInfo();
    });
  }
  isSuccess() {
    return !this.logs.some((u) => u.level === "error");
  }
  connect() {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this.room.state === ConnectionState.Connected ? this.room : (yield this.room.connect(this.url, this.token), this.room);
    });
  }
  disconnect() {
    return __awaiter$3(this, void 0, void 0, function* () {
      this.room && this.room.state !== ConnectionState.Disconnected && (yield this.room.disconnect(), yield new Promise((u) => setTimeout(u, 500)));
    });
  }
  skip() {
    this.setStatus(CheckStatus.SKIPPED);
  }
  appendMessage(u) {
    this.logs.push({
      level: "info",
      message: u
    }), this.emit("update", this.getInfo());
  }
  appendWarning(u) {
    this.logs.push({
      level: "warning",
      message: u
    }), this.emit("update", this.getInfo());
  }
  appendError(u) {
    this.logs.push({
      level: "error",
      message: u
    }), this.emit("update", this.getInfo());
  }
  setStatus(u) {
    this.status = u, this.emit("update", this.getInfo());
  }
  get engine() {
    var u;
    return (u = this.room) === null || u === void 0 ? void 0 : u.engine;
  }
  getInfo() {
    return {
      logs: this.logs,
      name: this.name,
      status: this.status,
      description: this.description
    };
  }
}
function createLocalTracks(a) {
  var u, c;
  return __awaiter$3(this, void 0, void 0, function* () {
    a ?? (a = {}), (u = a.audio) !== null && u !== void 0 || (a.audio = !0), (c = a.video) !== null && c !== void 0 || (a.video = !0);
    const l = mergeDefaultOptions(a, audioDefaults, videoDefaults), v = constraintsForOptions(l), p = navigator.mediaDevices.getUserMedia(v);
    a.audio && (DeviceManager.userMediaPromiseMap.set("audioinput", p), p.catch(() => DeviceManager.userMediaPromiseMap.delete("audioinput"))), a.video && (DeviceManager.userMediaPromiseMap.set("videoinput", p), p.catch(() => DeviceManager.userMediaPromiseMap.delete("videoinput")));
    const _ = yield p;
    return _.getTracks().map((k) => {
      const O = k.kind === "audio";
      O ? a.audio : a.video;
      let D;
      const F = O ? v.audio : v.video;
      typeof F != "boolean" && (D = F), D ? D.deviceId = k.getSettings().deviceId : D = {
        deviceId: k.getSettings().deviceId
      };
      const z = mediaTrackToLocalTrack(k, D);
      return z.kind === Track.Kind.Video ? z.source = Track.Source.Camera : z.kind === Track.Kind.Audio && (z.source = Track.Source.Microphone), z.mediaStream = _, z;
    });
  });
}
function createLocalVideoTrack(a) {
  return __awaiter$3(this, void 0, void 0, function* () {
    return (yield createLocalTracks({
      audio: !1,
      video: a
    }))[0];
  });
}
function createLocalAudioTrack(a) {
  return __awaiter$3(this, void 0, void 0, function* () {
    return (yield createLocalTracks({
      audio: a,
      video: !1
    }))[0];
  });
}
class PublishAudioCheck extends Checker {
  get description() {
    return "Can publish audio";
  }
  perform() {
    var u;
    return __awaiter$3(this, void 0, void 0, function* () {
      const c = yield this.connect(), l = yield createLocalAudioTrack();
      c.localParticipant.publishTrack(l), yield new Promise((_) => setTimeout(_, 3e3));
      const v = yield (u = l.sender) === null || u === void 0 ? void 0 : u.getStats();
      if (!v)
        throw new Error("Could not get RTCStats");
      let p = 0;
      if (v.forEach((_) => {
        _.type === "outbound-rtp" && _.mediaType === "audio" && (p = _.packetsSent);
      }), p === 0)
        throw new Error("Could not determine packets are sent");
      this.appendMessage("published ".concat(p, " audio packets"));
    });
  }
}
class PublishVideoCheck extends Checker {
  get description() {
    return "Can publish video";
  }
  perform() {
    var u;
    return __awaiter$3(this, void 0, void 0, function* () {
      const c = yield this.connect(), l = yield createLocalVideoTrack();
      c.localParticipant.publishTrack(l), yield new Promise((_) => setTimeout(_, 3e3));
      const v = yield (u = l.sender) === null || u === void 0 ? void 0 : u.getStats();
      if (!v)
        throw new Error("Could not get RTCStats");
      let p = 0;
      if (v.forEach((_) => {
        _.type === "outbound-rtp" && _.mediaType === "video" && (p = _.packetsSent);
      }), p === 0)
        throw new Error("Could not determine packets are sent");
      this.appendMessage("published ".concat(p, " video packets"));
    });
  }
}
class ReconnectCheck extends Checker {
  get description() {
    return "Resuming connection after interruption";
  }
  perform() {
    var u;
    return __awaiter$3(this, void 0, void 0, function* () {
      const c = yield this.connect();
      let l = !1, v = !1, p;
      const _ = new Promise((O) => {
        setTimeout(O, 5e3), p = O;
      });
      c.on(RoomEvent.Reconnecting, () => {
        l = !0;
      }).on(RoomEvent.Reconnected, () => {
        v = !0, p(!0);
      }), (u = c.engine.client.ws) === null || u === void 0 || u.close();
      const k = c.engine.client.onClose;
      if (k && k(""), yield _, l) {
        if (!v || c.state !== ConnectionState.Connected)
          throw this.appendWarning("reconnection is only possible in Redis-based configurations"), new Error("Not able to reconnect");
      } else
        throw new Error("Did not attempt to reconnect");
    });
  }
}
class TURNCheck extends Checker {
  get description() {
    return "Can connect via TURN";
  }
  perform() {
    var u, c;
    return __awaiter$3(this, void 0, void 0, function* () {
      const l = new SignalClient(), v = yield l.join(this.url, this.token, {
        autoSubscribe: !0,
        maxRetries: 0,
        e2eeEnabled: !1,
        websocketTimeout: 15e3
      });
      let p = !1, _ = !1, k = !1;
      for (let O of v.iceServers)
        for (let D of O.urls)
          D.startsWith("turn:") ? (_ = !0, k = !0) : D.startsWith("turns:") && (_ = !0, k = !0, p = !0), D.startsWith("stun:") && (k = !0);
      k ? _ && !p && this.appendWarning("TURN is configured server side, but TURN/TLS is unavailable.") : this.appendWarning("No STUN servers configured on server side."), yield l.close(), !((c = (u = this.connectOptions) === null || u === void 0 ? void 0 : u.rtcConfig) === null || c === void 0) && c.iceServers || _ ? yield this.room.connect(this.url, this.token, {
        rtcConfig: {
          iceTransportPolicy: "relay"
        }
      }) : (this.appendWarning("No TURN servers configured."), this.skip(), yield new Promise((O) => setTimeout(O, 0)));
    });
  }
}
class WebRTCCheck extends Checker {
  get description() {
    return "Establishing WebRTC connection";
  }
  perform() {
    return __awaiter$3(this, void 0, void 0, function* () {
      let u = !1, c = !1;
      this.room.on(RoomEvent.SignalConnected, () => {
        const l = this.room.engine.client.onTrickle;
        this.room.engine.client.onTrickle = (v, p) => {
          if (v.candidate) {
            const _ = new RTCIceCandidate(v);
            let k = "".concat(_.protocol, " ").concat(_.address, ":").concat(_.port, " ").concat(_.type);
            _.address && (isIPPrivate(_.address) ? k += " (private)" : _.protocol === "tcp" && _.tcpType === "passive" ? (u = !0, k += " (passive)") : _.protocol === "udp" && (c = !0)), this.appendMessage(k);
          }
          l && l(v, p);
        }, this.room.engine.pcManager && (this.room.engine.pcManager.subscriber.onIceCandidateError = (v) => {
          v instanceof RTCPeerConnectionIceErrorEvent && this.appendWarning("error with ICE candidate: ".concat(v.errorCode, " ").concat(v.errorText, " ").concat(v.url));
        });
      });
      try {
        yield this.connect(), livekitLogger.info("now the room is connected");
      } catch (l) {
        throw this.appendWarning("ports need to be open on firewall in order to connect."), l;
      }
      u || this.appendWarning("Server is not configured for ICE/TCP"), c || this.appendWarning("No public IPv4 UDP candidates were found. Your server is likely not configured correctly");
    });
  }
}
function isIPPrivate(a) {
  const u = a.split(".");
  if (u.length === 4) {
    if (u[0] === "10")
      return !0;
    if (u[0] === "192" && u[1] === "168")
      return !0;
    if (u[0] === "172") {
      const c = parseInt(u[1], 10);
      if (c >= 16 && c <= 31)
        return !0;
    }
  }
  return !1;
}
class WebSocketCheck extends Checker {
  get description() {
    return "Connecting to signal connection via WebSocket";
  }
  perform() {
    var u, c, l;
    return __awaiter$3(this, void 0, void 0, function* () {
      (this.url.startsWith("ws:") || this.url.startsWith("http:")) && this.appendWarning("Server is insecure, clients may block connections to it");
      let v = new SignalClient();
      const p = yield v.join(this.url, this.token, {
        autoSubscribe: !0,
        maxRetries: 0,
        e2eeEnabled: !1,
        websocketTimeout: 15e3
      });
      this.appendMessage("Connected to server, version ".concat(p.serverVersion, ".")), ((u = p.serverInfo) === null || u === void 0 ? void 0 : u.edition) === ServerInfo_Edition.Cloud && (!((c = p.serverInfo) === null || c === void 0) && c.region) && this.appendMessage("LiveKit Cloud: ".concat((l = p.serverInfo) === null || l === void 0 ? void 0 : l.region)), yield v.close();
    });
  }
}
class ConnectionCheck extends eventsExports$1.EventEmitter {
  constructor(u, c) {
    super(), this.checkResults = /* @__PURE__ */ new Map(), this.url = u, this.token = c;
  }
  getNextCheckId() {
    const u = this.checkResults.size;
    return this.checkResults.set(u, {
      logs: [],
      status: CheckStatus.IDLE,
      name: "",
      description: ""
    }), u;
  }
  updateCheck(u, c) {
    this.checkResults.set(u, c), this.emit("checkUpdate", u, c);
  }
  isSuccess() {
    return Array.from(this.checkResults.values()).every((u) => u.status !== CheckStatus.FAILED);
  }
  getResults() {
    return Array.from(this.checkResults.values());
  }
  createAndRunCheck(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      const c = this.getNextCheckId(), l = new u(this.url, this.token), v = (_) => {
        this.updateCheck(c, _);
      };
      l.on("update", v);
      const p = yield l.run();
      return l.off("update", v), p;
    });
  }
  checkWebsocket() {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this.createAndRunCheck(WebSocketCheck);
    });
  }
  checkWebRTC() {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this.createAndRunCheck(WebRTCCheck);
    });
  }
  checkTURN() {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this.createAndRunCheck(TURNCheck);
    });
  }
  checkReconnect() {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this.createAndRunCheck(ReconnectCheck);
    });
  }
  checkPublishAudio() {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this.createAndRunCheck(PublishAudioCheck);
    });
  }
  checkPublishVideo() {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this.createAndRunCheck(PublishVideoCheck);
    });
  }
}
const Rendering = lib$2.LiveApiModel.Rendering, VideoRendering = lib$2.LiveApiModel.VideoRendering, AudioRendering = lib$2.LiveApiModel.AudioRendering, RenderingQuality = lib$2.LiveApiModel.RenderingQuality, Encoding = lib$2.LiveApiModel.Encoding, VideoEncoding = lib$2.LiveApiModel.VideoEncoding, AudioEncoding = lib$2.LiveApiModel.AudioEncoding, ProjectBroadcastPhase = lib$2.LiveApiModel.ProjectBroadcastPhase, Role = lib$2.LiveApiModel.Role, DestinationAddress = lib$2.LiveApiModel.DestinationAddress, VideoCodec = lib$2.LiveApiModel.VideoCodec, AudioCodec = lib$2.LiveApiModel.AudioCodec, VideoCodecRateControl = lib$2.LiveApiModel.VideoCodecRateControl, VideoCodecProfile = lib$2.LiveApiModel.VideoCodecProfile, types$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AudioCodec,
  AudioEncoding,
  AudioRendering,
  DestinationAddress,
  Encoding,
  ProjectBroadcastPhase,
  Rendering,
  RenderingQuality,
  Role,
  VideoCodec,
  VideoCodecProfile,
  VideoCodecRateControl,
  VideoEncoding,
  VideoRendering
}, Symbol.toStringTag, { value: "Module" }));
var Permission = /* @__PURE__ */ ((a) => (a[a.ReadProject = 0] = "ReadProject", a[a.UpdateProject = 1] = "UpdateProject", a[a.JoinRoom = 2] = "JoinRoom", a[a.InviteGuests = 3] = "InviteGuests", a[a.ManageGuests = 4] = "ManageGuests", a[a.ManageBroadcast = 5] = "ManageBroadcast", a[a.ManageSelf = 6] = "ManageSelf", a))(Permission || {});
const permissions = {
  [Role.ROLE_HOST]: [
    0,
    1,
    2,
    3,
    4,
    5
    /* ManageBroadcast */
  ],
  [Role.ROLE_COHOST]: [
    0,
    1,
    2,
    3,
    4,
    5
    /* ManageBroadcast */
  ],
  [Role.ROLE_CONTRIBUTOR]: [
    0,
    1,
    2,
    3
    /* InviteGuests */
  ],
  [Role.ROLE_GUEST]: [
    0,
    2,
    6
    /* ManageSelf */
  ],
  [Role.ROLE_VIEWER]: [
    0,
    2
    /* JoinRoom */
  ],
  [Role.ROLE_IMPERSONATE]: [
    0,
    1,
    3,
    4,
    5
    /* ManageBroadcast */
  ]
}, hasPermission = (a, u) => {
  var c;
  return a ? !!((c = permissions[a]) != null && c.find((l) => l === u)) : !1;
};
let currentSubId = 0;
const subscribers = /* @__PURE__ */ new Map(), subscribersInternal = /* @__PURE__ */ new Map();
function createSubscribe(a = {}) {
  return function(u) {
    if (typeof u != "function")
      return;
    const c = a.internal ? subscribersInternal : subscribers, l = ++currentSubId;
    return c.set(l, u), () => {
      c.delete(l);
    };
  };
}
function createOn(a = {}) {
  return function(u, c) {
    return (a.internal ? subscribeInternal : subscribe)((v, p) => {
      if (u === v)
        return c(p);
    });
  };
}
function createTrigger(a = {}) {
  const u = a.internal ? subscribersInternal : subscribers;
  return async function(c, ...l) {
    let v = {
      type: c,
      payload: l[0]
    };
    const p = a.internal ? "Internal" : "External";
    log.info(`${p} Event:`, v), await Promise.all(Array.from(u.values()).map((_) => _(v.type, v.payload)));
  };
}
const trigger$1 = createTrigger(), subscribe = createSubscribe(), on = createOn(), triggerInternal$1 = createTrigger({
  internal: !0
}), subscribeInternal = createSubscribe({
  internal: !0
}), onInternal = createOn({
  internal: !0
}), events$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  on,
  onInternal,
  subscribe,
  subscribeInternal,
  trigger: trigger$1,
  triggerInternal: triggerInternal$1
}, Symbol.toStringTag, { value: "Module" }));
var loglevel = { exports: {} };
(function(a) {
  (function(u, c) {
    a.exports ? a.exports = c() : u.log = c();
  })(commonjsGlobal$1, function() {
    var u = function() {
    }, c = "undefined", l = typeof window !== c && typeof window.navigator !== c && /Trident\/|MSIE /.test(window.navigator.userAgent), v = [
      "trace",
      "debug",
      "info",
      "warn",
      "error"
    ], p = {}, _ = null;
    function k(ae, Q) {
      var ne = ae[Q];
      if (typeof ne.bind == "function")
        return ne.bind(ae);
      try {
        return Function.prototype.bind.call(ne, ae);
      } catch {
        return function() {
          return Function.prototype.apply.apply(ne, [ae, arguments]);
        };
      }
    }
    function O() {
      console.log && (console.log.apply ? console.log.apply(console, arguments) : Function.prototype.apply.apply(console.log, [console, arguments])), console.trace && console.trace();
    }
    function D(ae) {
      return ae === "debug" && (ae = "log"), typeof console === c ? !1 : ae === "trace" && l ? O : console[ae] !== void 0 ? k(console, ae) : console.log !== void 0 ? k(console, "log") : u;
    }
    function F() {
      for (var ae = this.getLevel(), Q = 0; Q < v.length; Q++) {
        var ne = v[Q];
        this[ne] = Q < ae ? u : this.methodFactory(ne, ae, this.name);
      }
      if (this.log = this.debug, typeof console === c && ae < this.levels.SILENT)
        return "No console available for logging";
    }
    function z(ae) {
      return function() {
        typeof console !== c && (F.call(this), this[ae].apply(this, arguments));
      };
    }
    function j(ae, Q, ne) {
      return D(ae) || z.apply(this, arguments);
    }
    function ee(ae, Q) {
      var ne = this, Z, de, fe, Te = "loglevel";
      typeof ae == "string" ? Te += ":" + ae : typeof ae == "symbol" && (Te = void 0);
      function Re(C) {
        var S = (v[C] || "silent").toUpperCase();
        if (!(typeof window === c || !Te)) {
          try {
            window.localStorage[Te] = S;
            return;
          } catch {
          }
          try {
            window.document.cookie = encodeURIComponent(Te) + "=" + S + ";";
          } catch {
          }
        }
      }
      function Le() {
        var C;
        if (!(typeof window === c || !Te)) {
          try {
            C = window.localStorage[Te];
          } catch {
          }
          if (typeof C === c)
            try {
              var S = window.document.cookie, E = encodeURIComponent(Te), I = S.indexOf(E + "=");
              I !== -1 && (C = /^([^;]+)/.exec(
                S.slice(I + E.length + 1)
              )[1]);
            } catch {
            }
          return ne.levels[C] === void 0 && (C = void 0), C;
        }
      }
      function be() {
        if (!(typeof window === c || !Te)) {
          try {
            window.localStorage.removeItem(Te);
          } catch {
          }
          try {
            window.document.cookie = encodeURIComponent(Te) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
          } catch {
          }
        }
      }
      function q(C) {
        var S = C;
        if (typeof S == "string" && ne.levels[S.toUpperCase()] !== void 0 && (S = ne.levels[S.toUpperCase()]), typeof S == "number" && S >= 0 && S <= ne.levels.SILENT)
          return S;
        throw new TypeError("log.setLevel() called with invalid level: " + C);
      }
      ne.name = ae, ne.levels = {
        TRACE: 0,
        DEBUG: 1,
        INFO: 2,
        WARN: 3,
        ERROR: 4,
        SILENT: 5
      }, ne.methodFactory = Q || j, ne.getLevel = function() {
        return fe ?? de ?? Z;
      }, ne.setLevel = function(C, S) {
        return fe = q(C), S !== !1 && Re(fe), F.call(ne);
      }, ne.setDefaultLevel = function(C) {
        de = q(C), Le() || ne.setLevel(C, !1);
      }, ne.resetLevel = function() {
        fe = null, be(), F.call(ne);
      }, ne.enableAll = function(C) {
        ne.setLevel(ne.levels.TRACE, C);
      }, ne.disableAll = function(C) {
        ne.setLevel(ne.levels.SILENT, C);
      }, ne.rebuild = function() {
        if (_ !== ne && (Z = q(_.getLevel())), F.call(ne), _ === ne)
          for (var C in p)
            p[C].rebuild();
      }, Z = q(
        _ ? _.getLevel() : "WARN"
      );
      var J = Le();
      J != null && (fe = q(J)), F.call(ne);
    }
    _ = new ee(), _.getLogger = function(Q) {
      if (typeof Q != "symbol" && typeof Q != "string" || Q === "")
        throw new TypeError("You must supply a name when creating a logger.");
      var ne = p[Q];
      return ne || (ne = p[Q] = new ee(
        Q,
        _.methodFactory
      )), ne;
    };
    var X = typeof window !== c ? window.log : void 0;
    return _.noConflict = function() {
      return typeof window !== c && window.log === _ && (window.log = X), _;
    }, _.getLoggers = function() {
      return p;
    }, _.default = _, _;
  });
})(loglevel);
var loglevelExports = loglevel.exports;
const log = /* @__PURE__ */ getDefaultExportFromCjs$2(loglevelExports), connectionId$1 = (Math.random() * 1e20).toString(36), version$2 = "3.0.24", CoreContext = {
  config: null,
  // TODO: Rename to client
  clients: null,
  Request: {},
  Command: {},
  on,
  subscribe,
  /** @private @internal */
  onInternal,
  /** @private @internal */
  subscribeInternal,
  /** @private @internal */
  trigger: trigger$1,
  /** @private @internal */
  triggerInternal: triggerInternal$1,
  /** @private @internal */
  state: {},
  compositor: {},
  connectionId: connectionId$1,
  version: version$2,
  /** @private @internal */
  rendererVersion: version$2,
  log,
  logLevel: null
}, setAppState = (a) => {
  Object.keys(a).forEach((u) => {
    CoreContext.state[u] = a[u];
  });
}, context = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CoreContext,
  default: CoreContext,
  log,
  setAppState
}, Symbol.toStringTag, { value: "Module" }));
var dist = {}, AccessToken$1 = {}, jws$3 = {}, safeBuffer$4 = { exports: {} };
const require$$0$2 = /* @__PURE__ */ getAugmentedNamespace(dist$3);
(function(a, u) {
  var c = require$$0$2, l = c.Buffer;
  function v(_, k) {
    for (var O in _)
      k[O] = _[O];
  }
  l.from && l.alloc && l.allocUnsafe && l.allocUnsafeSlow ? a.exports = c : (v(c, u), u.Buffer = p);
  function p(_, k, O) {
    return l(_, k, O);
  }
  v(l, p), p.from = function(_, k, O) {
    if (typeof _ == "number")
      throw new TypeError("Argument must not be a number");
    return l(_, k, O);
  }, p.alloc = function(_, k, O) {
    if (typeof _ != "number")
      throw new TypeError("Argument must be a number");
    var D = l(_);
    return k !== void 0 ? typeof O == "string" ? D.fill(k, O) : D.fill(k) : D.fill(0), D;
  }, p.allocUnsafe = function(_) {
    if (typeof _ != "number")
      throw new TypeError("Argument must be a number");
    return l(_);
  }, p.allocUnsafeSlow = function(_) {
    if (typeof _ != "number")
      throw new TypeError("Argument must be a number");
    return c.SlowBuffer(_);
  };
})(safeBuffer$4, safeBuffer$4.exports);
var safeBufferExports$3 = safeBuffer$4.exports, events = { exports: {} }, R = typeof Reflect == "object" ? Reflect : null, ReflectApply = R && typeof R.apply == "function" ? R.apply : function a(u, c, l) {
  return Function.prototype.apply.call(u, c, l);
}, ReflectOwnKeys;
R && typeof R.ownKeys == "function" ? ReflectOwnKeys = R.ownKeys : Object.getOwnPropertySymbols ? ReflectOwnKeys = function(u) {
  return Object.getOwnPropertyNames(u).concat(Object.getOwnPropertySymbols(u));
} : ReflectOwnKeys = function(u) {
  return Object.getOwnPropertyNames(u);
};
function ProcessEmitWarning(a) {
  console && console.warn && console.warn(a);
}
var NumberIsNaN = Number.isNaN || function a(u) {
  return u !== u;
};
function EventEmitter() {
  EventEmitter.init.call(this);
}
events.exports = EventEmitter;
events.exports.once = once$6;
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = void 0;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = void 0;
var defaultMaxListeners = 10;
function checkListener(a) {
  if (typeof a != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof a);
}
Object.defineProperty(EventEmitter, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(a) {
    if (typeof a != "number" || a < 0 || NumberIsNaN(a))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + a + ".");
    defaultMaxListeners = a;
  }
});
EventEmitter.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
EventEmitter.prototype.setMaxListeners = function a(u) {
  if (typeof u != "number" || u < 0 || NumberIsNaN(u))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + u + ".");
  return this._maxListeners = u, this;
};
function _getMaxListeners(a) {
  return a._maxListeners === void 0 ? EventEmitter.defaultMaxListeners : a._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function a() {
  return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function a(u) {
  for (var c = [], l = 1; l < arguments.length; l++)
    c.push(arguments[l]);
  var v = u === "error", p = this._events;
  if (p !== void 0)
    v = v && p.error === void 0;
  else if (!v)
    return !1;
  if (v) {
    var _;
    if (c.length > 0 && (_ = c[0]), _ instanceof Error)
      throw _;
    var k = new Error("Unhandled error." + (_ ? " (" + _.message + ")" : ""));
    throw k.context = _, k;
  }
  var O = p[u];
  if (O === void 0)
    return !1;
  if (typeof O == "function")
    ReflectApply(O, this, c);
  else
    for (var D = O.length, F = arrayClone(O, D), l = 0; l < D; ++l)
      ReflectApply(F[l], this, c);
  return !0;
};
function _addListener(a, u, c, l) {
  var v, p, _;
  if (checkListener(c), p = a._events, p === void 0 ? (p = a._events = /* @__PURE__ */ Object.create(null), a._eventsCount = 0) : (p.newListener !== void 0 && (a.emit(
    "newListener",
    u,
    c.listener ? c.listener : c
  ), p = a._events), _ = p[u]), _ === void 0)
    _ = p[u] = c, ++a._eventsCount;
  else if (typeof _ == "function" ? _ = p[u] = l ? [c, _] : [_, c] : l ? _.unshift(c) : _.push(c), v = _getMaxListeners(a), v > 0 && _.length > v && !_.warned) {
    _.warned = !0;
    var k = new Error("Possible EventEmitter memory leak detected. " + _.length + " " + String(u) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    k.name = "MaxListenersExceededWarning", k.emitter = a, k.type = u, k.count = _.length, ProcessEmitWarning(k);
  }
  return a;
}
EventEmitter.prototype.addListener = function a(u, c) {
  return _addListener(this, u, c, !1);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function a(u, c) {
  return _addListener(this, u, c, !0);
};
function onceWrapper() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function _onceWrap(a, u, c) {
  var l = { fired: !1, wrapFn: void 0, target: a, type: u, listener: c }, v = onceWrapper.bind(l);
  return v.listener = c, l.wrapFn = v, v;
}
EventEmitter.prototype.once = function a(u, c) {
  return checkListener(c), this.on(u, _onceWrap(this, u, c)), this;
};
EventEmitter.prototype.prependOnceListener = function a(u, c) {
  return checkListener(c), this.prependListener(u, _onceWrap(this, u, c)), this;
};
EventEmitter.prototype.removeListener = function a(u, c) {
  var l, v, p, _, k;
  if (checkListener(c), v = this._events, v === void 0)
    return this;
  if (l = v[u], l === void 0)
    return this;
  if (l === c || l.listener === c)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete v[u], v.removeListener && this.emit("removeListener", u, l.listener || c));
  else if (typeof l != "function") {
    for (p = -1, _ = l.length - 1; _ >= 0; _--)
      if (l[_] === c || l[_].listener === c) {
        k = l[_].listener, p = _;
        break;
      }
    if (p < 0)
      return this;
    p === 0 ? l.shift() : spliceOne(l, p), l.length === 1 && (v[u] = l[0]), v.removeListener !== void 0 && this.emit("removeListener", u, k || c);
  }
  return this;
};
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function a(u) {
  var c, l, v;
  if (l = this._events, l === void 0)
    return this;
  if (l.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : l[u] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete l[u]), this;
  if (arguments.length === 0) {
    var p = Object.keys(l), _;
    for (v = 0; v < p.length; ++v)
      _ = p[v], _ !== "removeListener" && this.removeAllListeners(_);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (c = l[u], typeof c == "function")
    this.removeListener(u, c);
  else if (c !== void 0)
    for (v = c.length - 1; v >= 0; v--)
      this.removeListener(u, c[v]);
  return this;
};
function _listeners(a, u, c) {
  var l = a._events;
  if (l === void 0)
    return [];
  var v = l[u];
  return v === void 0 ? [] : typeof v == "function" ? c ? [v.listener || v] : [v] : c ? unwrapListeners(v) : arrayClone(v, v.length);
}
EventEmitter.prototype.listeners = function a(u) {
  return _listeners(this, u, !0);
};
EventEmitter.prototype.rawListeners = function a(u) {
  return _listeners(this, u, !1);
};
EventEmitter.listenerCount = function(a, u) {
  return typeof a.listenerCount == "function" ? a.listenerCount(u) : listenerCount.call(a, u);
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(a) {
  var u = this._events;
  if (u !== void 0) {
    var c = u[a];
    if (typeof c == "function")
      return 1;
    if (c !== void 0)
      return c.length;
  }
  return 0;
}
EventEmitter.prototype.eventNames = function a() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone(a, u) {
  for (var c = new Array(u), l = 0; l < u; ++l)
    c[l] = a[l];
  return c;
}
function spliceOne(a, u) {
  for (; u + 1 < a.length; u++)
    a[u] = a[u + 1];
  a.pop();
}
function unwrapListeners(a) {
  for (var u = new Array(a.length), c = 0; c < u.length; ++c)
    u[c] = a[c].listener || a[c];
  return u;
}
function once$6(a, u) {
  return new Promise(function(c, l) {
    function v(_) {
      a.removeListener(u, p), l(_);
    }
    function p() {
      typeof a.removeListener == "function" && a.removeListener("error", v), c([].slice.call(arguments));
    }
    eventTargetAgnosticAddListener(a, u, p, { once: !0 }), u !== "error" && addErrorHandlerIfEventEmitter(a, v, { once: !0 });
  });
}
function addErrorHandlerIfEventEmitter(a, u, c) {
  typeof a.on == "function" && eventTargetAgnosticAddListener(a, "error", u, c);
}
function eventTargetAgnosticAddListener(a, u, c, l) {
  if (typeof a.on == "function")
    l.once ? a.once(u, c) : a.on(u, c);
  else if (typeof a.addEventListener == "function")
    a.addEventListener(u, function v(p) {
      l.once && a.removeEventListener(u, v), c(p);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof a);
}
var eventsExports = events.exports, inherits_browser = { exports: {} };
typeof Object.create == "function" ? inherits_browser.exports = function(u, c) {
  c && (u.super_ = c, u.prototype = Object.create(c.prototype, {
    constructor: {
      value: u,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }));
} : inherits_browser.exports = function(u, c) {
  if (c) {
    u.super_ = c;
    var l = function() {
    };
    l.prototype = c.prototype, u.prototype = new l(), u.prototype.constructor = u;
  }
};
var inherits_browserExports = inherits_browser.exports, streamBrowser$2, hasRequiredStreamBrowser;
function requireStreamBrowser() {
  return hasRequiredStreamBrowser || (hasRequiredStreamBrowser = 1, streamBrowser$2 = eventsExports.EventEmitter), streamBrowser$2;
}
var util$4 = {}, types$1 = {}, shams$1 = function a() {
  if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
    return !1;
  if (typeof Symbol.iterator == "symbol")
    return !0;
  var u = {}, c = Symbol("test"), l = Object(c);
  if (typeof c == "string" || Object.prototype.toString.call(c) !== "[object Symbol]" || Object.prototype.toString.call(l) !== "[object Symbol]")
    return !1;
  var v = 42;
  u[c] = v;
  for (c in u)
    return !1;
  if (typeof Object.keys == "function" && Object.keys(u).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(u).length !== 0)
    return !1;
  var p = Object.getOwnPropertySymbols(u);
  if (p.length !== 1 || p[0] !== c || !Object.prototype.propertyIsEnumerable.call(u, c))
    return !1;
  if (typeof Object.getOwnPropertyDescriptor == "function") {
    var _ = Object.getOwnPropertyDescriptor(u, c);
    if (_.value !== v || _.enumerable !== !0)
      return !1;
  }
  return !0;
}, hasSymbols$2 = shams$1, shams = function a() {
  return hasSymbols$2() && !!Symbol.toStringTag;
}, esErrors = Error, _eval = EvalError, range = RangeError, ref$1 = ReferenceError, syntax = SyntaxError, type = TypeError, uri = URIError, origSymbol = typeof Symbol < "u" && Symbol, hasSymbolSham = shams$1, hasSymbols$1 = function a() {
  return typeof origSymbol != "function" || typeof Symbol != "function" || typeof origSymbol("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : hasSymbolSham();
}, test = {
  foo: {}
}, $Object = Object, hasProto$1 = function a() {
  return { __proto__: test }.foo === test.foo && !({ __proto__: null } instanceof $Object);
}, ERROR_MESSAGE = "Function.prototype.bind called on incompatible ", toStr$3 = Object.prototype.toString, max = Math.max, funcType = "[object Function]", concatty = function a(u, c) {
  for (var l = [], v = 0; v < u.length; v += 1)
    l[v] = u[v];
  for (var p = 0; p < c.length; p += 1)
    l[p + u.length] = c[p];
  return l;
}, slicy = function a(u, c) {
  for (var l = [], v = c || 0, p = 0; v < u.length; v += 1, p += 1)
    l[p] = u[v];
  return l;
}, joiny = function(a, u) {
  for (var c = "", l = 0; l < a.length; l += 1)
    c += a[l], l + 1 < a.length && (c += u);
  return c;
}, implementation$1 = function a(u) {
  var c = this;
  if (typeof c != "function" || toStr$3.apply(c) !== funcType)
    throw new TypeError(ERROR_MESSAGE + c);
  for (var l = slicy(arguments, 1), v, p = function() {
    if (this instanceof v) {
      var F = c.apply(
        this,
        concatty(l, arguments)
      );
      return Object(F) === F ? F : this;
    }
    return c.apply(
      u,
      concatty(l, arguments)
    );
  }, _ = max(0, c.length - l.length), k = [], O = 0; O < _; O++)
    k[O] = "$" + O;
  if (v = Function("binder", "return function (" + joiny(k, ",") + "){ return binder.apply(this,arguments); }")(p), c.prototype) {
    var D = function() {
    };
    D.prototype = c.prototype, v.prototype = new D(), D.prototype = null;
  }
  return v;
}, implementation = implementation$1, functionBind = Function.prototype.bind || implementation, call$2 = Function.prototype.call, $hasOwn = Object.prototype.hasOwnProperty, bind$4 = functionBind, hasown = bind$4.call(call$2, $hasOwn), undefined$1, $Error = esErrors, $EvalError = _eval, $RangeError = range, $ReferenceError = ref$1, $SyntaxError$1 = syntax, $TypeError$2 = type, $URIError = uri, $Function = Function, getEvalledConstructor = function(a) {
  try {
    return $Function('"use strict"; return (' + a + ").constructor;")();
  } catch {
  }
}, $gOPD$1 = Object.getOwnPropertyDescriptor;
if ($gOPD$1)
  try {
    $gOPD$1({}, "");
  } catch {
    $gOPD$1 = null;
  }
var throwTypeError = function() {
  throw new $TypeError$2();
}, ThrowTypeError = $gOPD$1 ? function() {
  try {
    return arguments.callee, throwTypeError;
  } catch {
    try {
      return $gOPD$1(arguments, "callee").get;
    } catch {
      return throwTypeError;
    }
  }
}() : throwTypeError, hasSymbols = hasSymbols$1(), hasProto = hasProto$1(), getProto$1 = Object.getPrototypeOf || (hasProto ? function(a) {
  return a.__proto__;
} : null), needsEval = {}, TypedArray = typeof Uint8Array > "u" || !getProto$1 ? undefined$1 : getProto$1(Uint8Array), INTRINSICS = {
  __proto__: null,
  "%AggregateError%": typeof AggregateError > "u" ? undefined$1 : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer > "u" ? undefined$1 : ArrayBuffer,
  "%ArrayIteratorPrototype%": hasSymbols && getProto$1 ? getProto$1([][Symbol.iterator]()) : undefined$1,
  "%AsyncFromSyncIteratorPrototype%": undefined$1,
  "%AsyncFunction%": needsEval,
  "%AsyncGenerator%": needsEval,
  "%AsyncGeneratorFunction%": needsEval,
  "%AsyncIteratorPrototype%": needsEval,
  "%Atomics%": typeof Atomics > "u" ? undefined$1 : Atomics,
  "%BigInt%": typeof BigInt > "u" ? undefined$1 : BigInt,
  "%BigInt64Array%": typeof BigInt64Array > "u" ? undefined$1 : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array > "u" ? undefined$1 : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView > "u" ? undefined$1 : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": $Error,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": $EvalError,
  "%Float32Array%": typeof Float32Array > "u" ? undefined$1 : Float32Array,
  "%Float64Array%": typeof Float64Array > "u" ? undefined$1 : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? undefined$1 : FinalizationRegistry,
  "%Function%": $Function,
  "%GeneratorFunction%": needsEval,
  "%Int8Array%": typeof Int8Array > "u" ? undefined$1 : Int8Array,
  "%Int16Array%": typeof Int16Array > "u" ? undefined$1 : Int16Array,
  "%Int32Array%": typeof Int32Array > "u" ? undefined$1 : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": hasSymbols && getProto$1 ? getProto$1(getProto$1([][Symbol.iterator]())) : undefined$1,
  "%JSON%": typeof JSON == "object" ? JSON : undefined$1,
  "%Map%": typeof Map > "u" ? undefined$1 : Map,
  "%MapIteratorPrototype%": typeof Map > "u" || !hasSymbols || !getProto$1 ? undefined$1 : getProto$1((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Object,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise > "u" ? undefined$1 : Promise,
  "%Proxy%": typeof Proxy > "u" ? undefined$1 : Proxy,
  "%RangeError%": $RangeError,
  "%ReferenceError%": $ReferenceError,
  "%Reflect%": typeof Reflect > "u" ? undefined$1 : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set > "u" ? undefined$1 : Set,
  "%SetIteratorPrototype%": typeof Set > "u" || !hasSymbols || !getProto$1 ? undefined$1 : getProto$1((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? undefined$1 : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": hasSymbols && getProto$1 ? getProto$1(""[Symbol.iterator]()) : undefined$1,
  "%Symbol%": hasSymbols ? Symbol : undefined$1,
  "%SyntaxError%": $SyntaxError$1,
  "%ThrowTypeError%": ThrowTypeError,
  "%TypedArray%": TypedArray,
  "%TypeError%": $TypeError$2,
  "%Uint8Array%": typeof Uint8Array > "u" ? undefined$1 : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? undefined$1 : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array > "u" ? undefined$1 : Uint16Array,
  "%Uint32Array%": typeof Uint32Array > "u" ? undefined$1 : Uint32Array,
  "%URIError%": $URIError,
  "%WeakMap%": typeof WeakMap > "u" ? undefined$1 : WeakMap,
  "%WeakRef%": typeof WeakRef > "u" ? undefined$1 : WeakRef,
  "%WeakSet%": typeof WeakSet > "u" ? undefined$1 : WeakSet
};
if (getProto$1)
  try {
    null.error;
  } catch (a) {
    var errorProto = getProto$1(getProto$1(a));
    INTRINSICS["%Error.prototype%"] = errorProto;
  }
var doEval = function a(u) {
  var c;
  if (u === "%AsyncFunction%")
    c = getEvalledConstructor("async function () {}");
  else if (u === "%GeneratorFunction%")
    c = getEvalledConstructor("function* () {}");
  else if (u === "%AsyncGeneratorFunction%")
    c = getEvalledConstructor("async function* () {}");
  else if (u === "%AsyncGenerator%") {
    var l = a("%AsyncGeneratorFunction%");
    l && (c = l.prototype);
  } else if (u === "%AsyncIteratorPrototype%") {
    var v = a("%AsyncGenerator%");
    v && getProto$1 && (c = getProto$1(v.prototype));
  }
  return INTRINSICS[u] = c, c;
}, LEGACY_ALIASES = {
  __proto__: null,
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
}, bind$3 = functionBind, hasOwn = hasown, $concat = bind$3.call(Function.call, Array.prototype.concat), $spliceApply = bind$3.call(Function.apply, Array.prototype.splice), $replace = bind$3.call(Function.call, String.prototype.replace), $strSlice = bind$3.call(Function.call, String.prototype.slice), $exec = bind$3.call(Function.call, RegExp.prototype.exec), rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, reEscapeChar = /\\(\\)?/g, stringToPath = function a(u) {
  var c = $strSlice(u, 0, 1), l = $strSlice(u, -1);
  if (c === "%" && l !== "%")
    throw new $SyntaxError$1("invalid intrinsic syntax, expected closing `%`");
  if (l === "%" && c !== "%")
    throw new $SyntaxError$1("invalid intrinsic syntax, expected opening `%`");
  var v = [];
  return $replace(u, rePropName, function(p, _, k, O) {
    v[v.length] = k ? $replace(O, reEscapeChar, "$1") : _ || p;
  }), v;
}, getBaseIntrinsic = function a(u, c) {
  var l = u, v;
  if (hasOwn(LEGACY_ALIASES, l) && (v = LEGACY_ALIASES[l], l = "%" + v[0] + "%"), hasOwn(INTRINSICS, l)) {
    var p = INTRINSICS[l];
    if (p === needsEval && (p = doEval(l)), typeof p > "u" && !c)
      throw new $TypeError$2("intrinsic " + u + " exists, but is not available. Please file an issue!");
    return {
      alias: v,
      name: l,
      value: p
    };
  }
  throw new $SyntaxError$1("intrinsic " + u + " does not exist!");
}, getIntrinsic = function a(u, c) {
  if (typeof u != "string" || u.length === 0)
    throw new $TypeError$2("intrinsic name must be a non-empty string");
  if (arguments.length > 1 && typeof c != "boolean")
    throw new $TypeError$2('"allowMissing" argument must be a boolean');
  if ($exec(/^%?[^%]*%?$/, u) === null)
    throw new $SyntaxError$1("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  var l = stringToPath(u), v = l.length > 0 ? l[0] : "", p = getBaseIntrinsic("%" + v + "%", c), _ = p.name, k = p.value, O = !1, D = p.alias;
  D && (v = D[0], $spliceApply(l, $concat([0, 1], D)));
  for (var F = 1, z = !0; F < l.length; F += 1) {
    var j = l[F], ee = $strSlice(j, 0, 1), X = $strSlice(j, -1);
    if ((ee === '"' || ee === "'" || ee === "`" || X === '"' || X === "'" || X === "`") && ee !== X)
      throw new $SyntaxError$1("property names with quotes must have matching quotes");
    if ((j === "constructor" || !z) && (O = !0), v += "." + j, _ = "%" + v + "%", hasOwn(INTRINSICS, _))
      k = INTRINSICS[_];
    else if (k != null) {
      if (!(j in k)) {
        if (!c)
          throw new $TypeError$2("base intrinsic for " + u + " exists, but the property is not available.");
        return;
      }
      if ($gOPD$1 && F + 1 >= l.length) {
        var ae = $gOPD$1(k, j);
        z = !!ae, z && "get" in ae && !("originalValue" in ae.get) ? k = ae.get : k = k[j];
      } else
        z = hasOwn(k, j), k = k[j];
      z && !O && (INTRINSICS[_] = k);
    }
  }
  return k;
}, callBind$2 = { exports: {} }, esDefineProperty, hasRequiredEsDefineProperty;
function requireEsDefineProperty() {
  if (hasRequiredEsDefineProperty)
    return esDefineProperty;
  hasRequiredEsDefineProperty = 1;
  var a = getIntrinsic, u = a("%Object.defineProperty%", !0) || !1;
  if (u)
    try {
      u({}, "a", { value: 1 });
    } catch {
      u = !1;
    }
  return esDefineProperty = u, esDefineProperty;
}
var GetIntrinsic$2 = getIntrinsic, $gOPD = GetIntrinsic$2("%Object.getOwnPropertyDescriptor%", !0);
if ($gOPD)
  try {
    $gOPD([], "length");
  } catch {
    $gOPD = null;
  }
var gopd$1 = $gOPD, $defineProperty$1 = requireEsDefineProperty(), $SyntaxError = syntax, $TypeError$1 = type, gopd = gopd$1, defineDataProperty = function a(u, c, l) {
  if (!u || typeof u != "object" && typeof u != "function")
    throw new $TypeError$1("`obj` must be an object or a function`");
  if (typeof c != "string" && typeof c != "symbol")
    throw new $TypeError$1("`property` must be a string or a symbol`");
  if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
    throw new $TypeError$1("`nonEnumerable`, if provided, must be a boolean or null");
  if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
    throw new $TypeError$1("`nonWritable`, if provided, must be a boolean or null");
  if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
    throw new $TypeError$1("`nonConfigurable`, if provided, must be a boolean or null");
  if (arguments.length > 6 && typeof arguments[6] != "boolean")
    throw new $TypeError$1("`loose`, if provided, must be a boolean");
  var v = arguments.length > 3 ? arguments[3] : null, p = arguments.length > 4 ? arguments[4] : null, _ = arguments.length > 5 ? arguments[5] : null, k = arguments.length > 6 ? arguments[6] : !1, O = !!gopd && gopd(u, c);
  if ($defineProperty$1)
    $defineProperty$1(u, c, {
      configurable: _ === null && O ? O.configurable : !_,
      enumerable: v === null && O ? O.enumerable : !v,
      value: l,
      writable: p === null && O ? O.writable : !p
    });
  else if (k || !v && !p && !_)
    u[c] = l;
  else
    throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
}, $defineProperty = requireEsDefineProperty(), hasPropertyDescriptors = function a() {
  return !!$defineProperty;
};
hasPropertyDescriptors.hasArrayLengthDefineBug = function a() {
  if (!$defineProperty)
    return null;
  try {
    return $defineProperty([], "length", { value: 1 }).length !== 1;
  } catch {
    return !0;
  }
};
var hasPropertyDescriptors_1 = hasPropertyDescriptors, GetIntrinsic$1 = getIntrinsic, define = defineDataProperty, hasDescriptors = hasPropertyDescriptors_1(), gOPD$1 = gopd$1, $TypeError = type, $floor = GetIntrinsic$1("%Math.floor%"), setFunctionLength = function a(u, c) {
  if (typeof u != "function")
    throw new $TypeError("`fn` is not a function");
  if (typeof c != "number" || c < 0 || c > 4294967295 || $floor(c) !== c)
    throw new $TypeError("`length` must be a positive 32-bit integer");
  var l = arguments.length > 2 && !!arguments[2], v = !0, p = !0;
  if ("length" in u && gOPD$1) {
    var _ = gOPD$1(u, "length");
    _ && !_.configurable && (v = !1), _ && !_.writable && (p = !1);
  }
  return (v || p || !l) && (hasDescriptors ? define(
    /** @type {Parameters<define>[0]} */
    u,
    "length",
    c,
    !0,
    !0
  ) : define(
    /** @type {Parameters<define>[0]} */
    u,
    "length",
    c
  )), u;
};
(function(a) {
  var u = functionBind, c = getIntrinsic, l = setFunctionLength, v = type, p = c("%Function.prototype.apply%"), _ = c("%Function.prototype.call%"), k = c("%Reflect.apply%", !0) || u.call(_, p), O = requireEsDefineProperty(), D = c("%Math.max%");
  a.exports = function(j) {
    if (typeof j != "function")
      throw new v("a function is required");
    var ee = k(u, _, arguments);
    return l(
      ee,
      1 + D(0, j.length - (arguments.length - 1)),
      !0
    );
  };
  var F = function() {
    return k(u, p, arguments);
  };
  O ? O(a.exports, "apply", { value: F }) : a.exports.apply = F;
})(callBind$2);
var callBindExports = callBind$2.exports, GetIntrinsic = getIntrinsic, callBind$1 = callBindExports, $indexOf$1 = callBind$1(GetIntrinsic("String.prototype.indexOf")), callBound$2 = function a(u, c) {
  var l = GetIntrinsic(u, !!c);
  return typeof l == "function" && $indexOf$1(u, ".prototype.") > -1 ? callBind$1(l) : l;
}, hasToStringTag$3 = shams(), callBound$1 = callBound$2, $toString$1 = callBound$1("Object.prototype.toString"), isStandardArguments = function a(u) {
  return hasToStringTag$3 && u && typeof u == "object" && Symbol.toStringTag in u ? !1 : $toString$1(u) === "[object Arguments]";
}, isLegacyArguments = function a(u) {
  return isStandardArguments(u) ? !0 : u !== null && typeof u == "object" && typeof u.length == "number" && u.length >= 0 && $toString$1(u) !== "[object Array]" && $toString$1(u.callee) === "[object Function]";
}, supportsStandardArguments = function() {
  return isStandardArguments(arguments);
}();
isStandardArguments.isLegacyArguments = isLegacyArguments;
var isArguments$1 = supportsStandardArguments ? isStandardArguments : isLegacyArguments, toStr$2 = Object.prototype.toString, fnToStr$1 = Function.prototype.toString, isFnRegex = /^\s*(?:function)?\*/, hasToStringTag$2 = shams(), getProto = Object.getPrototypeOf, getGeneratorFunc = function() {
  if (!hasToStringTag$2)
    return !1;
  try {
    return Function("return function*() {}")();
  } catch {
  }
}, GeneratorFunction, isGeneratorFunction = function a(u) {
  if (typeof u != "function")
    return !1;
  if (isFnRegex.test(fnToStr$1.call(u)))
    return !0;
  if (!hasToStringTag$2) {
    var c = toStr$2.call(u);
    return c === "[object GeneratorFunction]";
  }
  if (!getProto)
    return !1;
  if (typeof GeneratorFunction > "u") {
    var l = getGeneratorFunc();
    GeneratorFunction = l ? getProto(l) : !1;
  }
  return getProto(u) === GeneratorFunction;
}, fnToStr = Function.prototype.toString, reflectApply = typeof Reflect == "object" && Reflect !== null && Reflect.apply, badArrayLike, isCallableMarker;
if (typeof reflectApply == "function" && typeof Object.defineProperty == "function")
  try {
    badArrayLike = Object.defineProperty({}, "length", {
      get: function() {
        throw isCallableMarker;
      }
    }), isCallableMarker = {}, reflectApply(function() {
      throw 42;
    }, null, badArrayLike);
  } catch (a) {
    a !== isCallableMarker && (reflectApply = null);
  }
else
  reflectApply = null;
var constructorRegex = /^\s*class\b/, isES6ClassFn = function a(u) {
  try {
    var c = fnToStr.call(u);
    return constructorRegex.test(c);
  } catch {
    return !1;
  }
}, tryFunctionObject = function a(u) {
  try {
    return isES6ClassFn(u) ? !1 : (fnToStr.call(u), !0);
  } catch {
    return !1;
  }
}, toStr$1 = Object.prototype.toString, fnClass = "[object Function]", genClass = "[object GeneratorFunction]", hasToStringTag$1 = typeof Symbol == "function" && !!Symbol.toStringTag, documentDotAll = typeof document == "object" && typeof document.all > "u" && document.all !== void 0 ? document.all : {}, isCallable$1 = reflectApply ? function a(u) {
  if (u === documentDotAll)
    return !0;
  if (!u || typeof u != "function" && typeof u != "object")
    return !1;
  if (typeof u == "function" && !u.prototype)
    return !0;
  try {
    reflectApply(u, null, badArrayLike);
  } catch (c) {
    if (c !== isCallableMarker)
      return !1;
  }
  return !isES6ClassFn(u);
} : function a(u) {
  if (u === documentDotAll)
    return !0;
  if (!u || typeof u != "function" && typeof u != "object")
    return !1;
  if (typeof u == "function" && !u.prototype)
    return !0;
  if (hasToStringTag$1)
    return tryFunctionObject(u);
  if (isES6ClassFn(u))
    return !1;
  var c = toStr$1.call(u);
  return c === fnClass || c === genClass;
}, isCallable = isCallable$1, toStr = Object.prototype.toString, hasOwnProperty$2 = Object.prototype.hasOwnProperty, forEachArray = function a(u, c, l) {
  for (var v = 0, p = u.length; v < p; v++)
    hasOwnProperty$2.call(u, v) && (l == null ? c(u[v], v, u) : c.call(l, u[v], v, u));
}, forEachString = function a(u, c, l) {
  for (var v = 0, p = u.length; v < p; v++)
    l == null ? c(u.charAt(v), v, u) : c.call(l, u.charAt(v), v, u);
}, forEachObject = function a(u, c, l) {
  for (var v in u)
    hasOwnProperty$2.call(u, v) && (l == null ? c(u[v], v, u) : c.call(l, u[v], v, u));
}, forEach$2 = function a(u, c, l) {
  if (!isCallable(c))
    throw new TypeError("iterator must be a function");
  var v;
  arguments.length >= 3 && (v = l), toStr.call(u) === "[object Array]" ? forEachArray(u, c, v) : typeof u == "string" ? forEachString(u, c, v) : forEachObject(u, c, v);
}, forEach_1 = forEach$2, possibleNames = [
  "BigInt64Array",
  "BigUint64Array",
  "Float32Array",
  "Float64Array",
  "Int16Array",
  "Int32Array",
  "Int8Array",
  "Uint16Array",
  "Uint32Array",
  "Uint8Array",
  "Uint8ClampedArray"
], g$1 = typeof globalThis > "u" ? commonjsGlobal$1 : globalThis, availableTypedArrays$1 = function a() {
  for (var u = [], c = 0; c < possibleNames.length; c++)
    typeof g$1[possibleNames[c]] == "function" && (u[u.length] = possibleNames[c]);
  return u;
}, forEach$1 = forEach_1, availableTypedArrays = availableTypedArrays$1, callBind = callBindExports, callBound = callBound$2, gOPD = gopd$1, $toString = callBound("Object.prototype.toString"), hasToStringTag = shams(), g = typeof globalThis > "u" ? commonjsGlobal$1 : globalThis, typedArrays = availableTypedArrays(), $slice = callBound("String.prototype.slice"), getPrototypeOf = Object.getPrototypeOf, $indexOf = callBound("Array.prototype.indexOf", !0) || /** @type {(array: readonly unknown[], value: unknown) => keyof array} */
function a(u, c) {
  for (var l = 0; l < u.length; l += 1)
    if (u[l] === c)
      return l;
  return -1;
}, cache$2 = { __proto__: null };
hasToStringTag && gOPD && getPrototypeOf ? forEach$1(typedArrays, function(a) {
  var u = new g[a]();
  if (Symbol.toStringTag in u) {
    var c = getPrototypeOf(u), l = gOPD(c, Symbol.toStringTag);
    if (!l) {
      var v = getPrototypeOf(c);
      l = gOPD(v, Symbol.toStringTag);
    }
    cache$2["$" + a] = callBind(l.get);
  }
}) : forEach$1(typedArrays, function(a) {
  var u = new g[a](), c = u.slice || u.set;
  c && (cache$2["$" + a] = callBind(c));
});
var tryTypedArrays = function a(u) {
  var c = !1;
  return forEach$1(
    // eslint-disable-next-line no-extra-parens
    /** @type {Record<`\$${TypedArrayName}`, typeof cache>} */
    /** @type {any} */
    cache$2,
    /** @type {(getter: typeof cache, name: `\$${TypedArrayName}`) => void} */
    function(l, v) {
      if (!c)
        try {
          "$" + l(u) === v && (c = $slice(v, 1));
        } catch {
        }
    }
  ), c;
}, trySlices = function a(u) {
  var c = !1;
  return forEach$1(
    // eslint-disable-next-line no-extra-parens
    /** @type {any} */
    cache$2,
    /** @type {(getter: typeof cache, name: `\$${TypedArrayName}`) => void} */
    function(l, v) {
      if (!c)
        try {
          l(u), c = $slice(v, 1);
        } catch {
        }
    }
  ), c;
}, whichTypedArray$1 = function a(u) {
  if (!u || typeof u != "object")
    return !1;
  if (!hasToStringTag) {
    var c = $slice($toString(u), 8, -1);
    return $indexOf(typedArrays, c) > -1 ? c : c !== "Object" ? !1 : trySlices(u);
  }
  return gOPD ? tryTypedArrays(u) : null;
}, whichTypedArray = whichTypedArray$1, isTypedArray = function a(u) {
  return !!whichTypedArray(u);
};
(function(a) {
  var u = isArguments$1, c = isGeneratorFunction, l = whichTypedArray$1, v = isTypedArray;
  function p(qe) {
    return qe.call.bind(qe);
  }
  var _ = typeof BigInt < "u", k = typeof Symbol < "u", O = p(Object.prototype.toString), D = p(Number.prototype.valueOf), F = p(String.prototype.valueOf), z = p(Boolean.prototype.valueOf);
  if (_)
    var j = p(BigInt.prototype.valueOf);
  if (k)
    var ee = p(Symbol.prototype.valueOf);
  function X(qe, yt) {
    if (typeof qe != "object")
      return !1;
    try {
      return yt(qe), !0;
    } catch {
      return !1;
    }
  }
  a.isArgumentsObject = u, a.isGeneratorFunction = c, a.isTypedArray = v;
  function ae(qe) {
    return typeof Promise < "u" && qe instanceof Promise || qe !== null && typeof qe == "object" && typeof qe.then == "function" && typeof qe.catch == "function";
  }
  a.isPromise = ae;
  function Q(qe) {
    return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(qe) : v(qe) || pe(qe);
  }
  a.isArrayBufferView = Q;
  function ne(qe) {
    return l(qe) === "Uint8Array";
  }
  a.isUint8Array = ne;
  function Z(qe) {
    return l(qe) === "Uint8ClampedArray";
  }
  a.isUint8ClampedArray = Z;
  function de(qe) {
    return l(qe) === "Uint16Array";
  }
  a.isUint16Array = de;
  function fe(qe) {
    return l(qe) === "Uint32Array";
  }
  a.isUint32Array = fe;
  function Te(qe) {
    return l(qe) === "Int8Array";
  }
  a.isInt8Array = Te;
  function Re(qe) {
    return l(qe) === "Int16Array";
  }
  a.isInt16Array = Re;
  function Le(qe) {
    return l(qe) === "Int32Array";
  }
  a.isInt32Array = Le;
  function be(qe) {
    return l(qe) === "Float32Array";
  }
  a.isFloat32Array = be;
  function q(qe) {
    return l(qe) === "Float64Array";
  }
  a.isFloat64Array = q;
  function J(qe) {
    return l(qe) === "BigInt64Array";
  }
  a.isBigInt64Array = J;
  function C(qe) {
    return l(qe) === "BigUint64Array";
  }
  a.isBigUint64Array = C;
  function S(qe) {
    return O(qe) === "[object Map]";
  }
  S.working = typeof Map < "u" && S(/* @__PURE__ */ new Map());
  function E(qe) {
    return typeof Map > "u" ? !1 : S.working ? S(qe) : qe instanceof Map;
  }
  a.isMap = E;
  function I(qe) {
    return O(qe) === "[object Set]";
  }
  I.working = typeof Set < "u" && I(/* @__PURE__ */ new Set());
  function M(qe) {
    return typeof Set > "u" ? !1 : I.working ? I(qe) : qe instanceof Set;
  }
  a.isSet = M;
  function $(qe) {
    return O(qe) === "[object WeakMap]";
  }
  $.working = typeof WeakMap < "u" && $(/* @__PURE__ */ new WeakMap());
  function U(qe) {
    return typeof WeakMap > "u" ? !1 : $.working ? $(qe) : qe instanceof WeakMap;
  }
  a.isWeakMap = U;
  function Y(qe) {
    return O(qe) === "[object WeakSet]";
  }
  Y.working = typeof WeakSet < "u" && Y(/* @__PURE__ */ new WeakSet());
  function L(qe) {
    return Y(qe);
  }
  a.isWeakSet = L;
  function T(qe) {
    return O(qe) === "[object ArrayBuffer]";
  }
  T.working = typeof ArrayBuffer < "u" && T(new ArrayBuffer());
  function B(qe) {
    return typeof ArrayBuffer > "u" ? !1 : T.working ? T(qe) : qe instanceof ArrayBuffer;
  }
  a.isArrayBuffer = B;
  function te(qe) {
    return O(qe) === "[object DataView]";
  }
  te.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && te(new DataView(new ArrayBuffer(1), 0, 1));
  function pe(qe) {
    return typeof DataView > "u" ? !1 : te.working ? te(qe) : qe instanceof DataView;
  }
  a.isDataView = pe;
  var Ie = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
  function $e(qe) {
    return O(qe) === "[object SharedArrayBuffer]";
  }
  function ve(qe) {
    return typeof Ie > "u" ? !1 : (typeof $e.working > "u" && ($e.working = $e(new Ie())), $e.working ? $e(qe) : qe instanceof Ie);
  }
  a.isSharedArrayBuffer = ve;
  function he(qe) {
    return O(qe) === "[object AsyncFunction]";
  }
  a.isAsyncFunction = he;
  function Oe(qe) {
    return O(qe) === "[object Map Iterator]";
  }
  a.isMapIterator = Oe;
  function Ae(qe) {
    return O(qe) === "[object Set Iterator]";
  }
  a.isSetIterator = Ae;
  function Ue(qe) {
    return O(qe) === "[object Generator]";
  }
  a.isGeneratorObject = Ue;
  function oe(qe) {
    return O(qe) === "[object WebAssembly.Module]";
  }
  a.isWebAssemblyCompiledModule = oe;
  function A(qe) {
    return X(qe, D);
  }
  a.isNumberObject = A;
  function re(qe) {
    return X(qe, F);
  }
  a.isStringObject = re;
  function le(qe) {
    return X(qe, z);
  }
  a.isBooleanObject = le;
  function Ne(qe) {
    return _ && X(qe, j);
  }
  a.isBigIntObject = Ne;
  function Pe(qe) {
    return k && X(qe, ee);
  }
  a.isSymbolObject = Pe;
  function Fe(qe) {
    return A(qe) || re(qe) || le(qe) || Ne(qe) || Pe(qe);
  }
  a.isBoxedPrimitive = Fe;
  function je(qe) {
    return typeof Uint8Array < "u" && (B(qe) || ve(qe));
  }
  a.isAnyArrayBuffer = je, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(qe) {
    Object.defineProperty(a, qe, {
      enumerable: !1,
      value: function() {
        throw new Error(qe + " is not supported in userland");
      }
    });
  });
})(types$1);
var isBufferBrowser = function a(u) {
  return u && typeof u == "object" && typeof u.copy == "function" && typeof u.fill == "function" && typeof u.readUInt8 == "function";
};
(function(a) {
  var u = Object.getOwnPropertyDescriptors || function(pe) {
    for (var Ie = Object.keys(pe), $e = {}, ve = 0; ve < Ie.length; ve++)
      $e[Ie[ve]] = Object.getOwnPropertyDescriptor(pe, Ie[ve]);
    return $e;
  }, c = /%[sdj%]/g;
  a.format = function(te) {
    if (!Te(te)) {
      for (var pe = [], Ie = 0; Ie < arguments.length; Ie++)
        pe.push(_(arguments[Ie]));
      return pe.join(" ");
    }
    for (var Ie = 1, $e = arguments, ve = $e.length, he = String(te).replace(c, function(Ae) {
      if (Ae === "%%")
        return "%";
      if (Ie >= ve)
        return Ae;
      switch (Ae) {
        case "%s":
          return String($e[Ie++]);
        case "%d":
          return Number($e[Ie++]);
        case "%j":
          try {
            return JSON.stringify($e[Ie++]);
          } catch {
            return "[Circular]";
          }
        default:
          return Ae;
      }
    }), Oe = $e[Ie]; Ie < ve; Oe = $e[++Ie])
      Z(Oe) || !q(Oe) ? he += " " + Oe : he += " " + _(Oe);
    return he;
  }, a.deprecate = function(te, pe) {
    if (typeof process$1 < "u" && process$1.noDeprecation === !0)
      return te;
    if (typeof process$1 > "u")
      return function() {
        return a.deprecate(te, pe).apply(this, arguments);
      };
    var Ie = !1;
    function $e() {
      if (!Ie) {
        if (process$1.throwDeprecation)
          throw new Error(pe);
        process$1.traceDeprecation ? console.trace(pe) : console.error(pe), Ie = !0;
      }
      return te.apply(this, arguments);
    }
    return $e;
  };
  var l = {}, v = /^$/;
  if (process$1.env.NODE_DEBUG) {
    var p = process$1.env.NODE_DEBUG;
    p = p.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), v = new RegExp("^" + p + "$", "i");
  }
  a.debuglog = function(te) {
    if (te = te.toUpperCase(), !l[te])
      if (v.test(te)) {
        var pe = process$1.pid;
        l[te] = function() {
          var Ie = a.format.apply(a, arguments);
          console.error("%s %d: %s", te, pe, Ie);
        };
      } else
        l[te] = function() {
        };
    return l[te];
  };
  function _(te, pe) {
    var Ie = {
      seen: [],
      stylize: O
    };
    return arguments.length >= 3 && (Ie.depth = arguments[2]), arguments.length >= 4 && (Ie.colors = arguments[3]), ne(pe) ? Ie.showHidden = pe : pe && a._extend(Ie, pe), Le(Ie.showHidden) && (Ie.showHidden = !1), Le(Ie.depth) && (Ie.depth = 2), Le(Ie.colors) && (Ie.colors = !1), Le(Ie.customInspect) && (Ie.customInspect = !0), Ie.colors && (Ie.stylize = k), F(Ie, te, Ie.depth);
  }
  a.inspect = _, _.colors = {
    bold: [1, 22],
    italic: [3, 23],
    underline: [4, 24],
    inverse: [7, 27],
    white: [37, 39],
    grey: [90, 39],
    black: [30, 39],
    blue: [34, 39],
    cyan: [36, 39],
    green: [32, 39],
    magenta: [35, 39],
    red: [31, 39],
    yellow: [33, 39]
  }, _.styles = {
    special: "cyan",
    number: "yellow",
    boolean: "yellow",
    undefined: "grey",
    null: "bold",
    string: "green",
    date: "magenta",
    // "name": intentionally not styling
    regexp: "red"
  };
  function k(te, pe) {
    var Ie = _.styles[pe];
    return Ie ? "\x1B[" + _.colors[Ie][0] + "m" + te + "\x1B[" + _.colors[Ie][1] + "m" : te;
  }
  function O(te, pe) {
    return te;
  }
  function D(te) {
    var pe = {};
    return te.forEach(function(Ie, $e) {
      pe[Ie] = !0;
    }), pe;
  }
  function F(te, pe, Ie) {
    if (te.customInspect && pe && S(pe.inspect) && // Filter out the util module, it's inspect function is special
    pe.inspect !== a.inspect && // Also filter out any prototype objects using the circular check.
    !(pe.constructor && pe.constructor.prototype === pe)) {
      var $e = pe.inspect(Ie, te);
      return Te($e) || ($e = F(te, $e, Ie)), $e;
    }
    var ve = z(te, pe);
    if (ve)
      return ve;
    var he = Object.keys(pe), Oe = D(he);
    if (te.showHidden && (he = Object.getOwnPropertyNames(pe)), C(pe) && (he.indexOf("message") >= 0 || he.indexOf("description") >= 0))
      return j(pe);
    if (he.length === 0) {
      if (S(pe)) {
        var Ae = pe.name ? ": " + pe.name : "";
        return te.stylize("[Function" + Ae + "]", "special");
      }
      if (be(pe))
        return te.stylize(RegExp.prototype.toString.call(pe), "regexp");
      if (J(pe))
        return te.stylize(Date.prototype.toString.call(pe), "date");
      if (C(pe))
        return j(pe);
    }
    var Ue = "", oe = !1, A = ["{", "}"];
    if (Q(pe) && (oe = !0, A = ["[", "]"]), S(pe)) {
      var re = pe.name ? ": " + pe.name : "";
      Ue = " [Function" + re + "]";
    }
    if (be(pe) && (Ue = " " + RegExp.prototype.toString.call(pe)), J(pe) && (Ue = " " + Date.prototype.toUTCString.call(pe)), C(pe) && (Ue = " " + j(pe)), he.length === 0 && (!oe || pe.length == 0))
      return A[0] + Ue + A[1];
    if (Ie < 0)
      return be(pe) ? te.stylize(RegExp.prototype.toString.call(pe), "regexp") : te.stylize("[Object]", "special");
    te.seen.push(pe);
    var le;
    return oe ? le = ee(te, pe, Ie, Oe, he) : le = he.map(function(Ne) {
      return X(te, pe, Ie, Oe, Ne, oe);
    }), te.seen.pop(), ae(le, Ue, A);
  }
  function z(te, pe) {
    if (Le(pe))
      return te.stylize("undefined", "undefined");
    if (Te(pe)) {
      var Ie = "'" + JSON.stringify(pe).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return te.stylize(Ie, "string");
    }
    if (fe(pe))
      return te.stylize("" + pe, "number");
    if (ne(pe))
      return te.stylize("" + pe, "boolean");
    if (Z(pe))
      return te.stylize("null", "null");
  }
  function j(te) {
    return "[" + Error.prototype.toString.call(te) + "]";
  }
  function ee(te, pe, Ie, $e, ve) {
    for (var he = [], Oe = 0, Ae = pe.length; Oe < Ae; ++Oe)
      Y(pe, String(Oe)) ? he.push(X(
        te,
        pe,
        Ie,
        $e,
        String(Oe),
        !0
      )) : he.push("");
    return ve.forEach(function(Ue) {
      Ue.match(/^\d+$/) || he.push(X(
        te,
        pe,
        Ie,
        $e,
        Ue,
        !0
      ));
    }), he;
  }
  function X(te, pe, Ie, $e, ve, he) {
    var Oe, Ae, Ue;
    if (Ue = Object.getOwnPropertyDescriptor(pe, ve) || { value: pe[ve] }, Ue.get ? Ue.set ? Ae = te.stylize("[Getter/Setter]", "special") : Ae = te.stylize("[Getter]", "special") : Ue.set && (Ae = te.stylize("[Setter]", "special")), Y($e, ve) || (Oe = "[" + ve + "]"), Ae || (te.seen.indexOf(Ue.value) < 0 ? (Z(Ie) ? Ae = F(te, Ue.value, null) : Ae = F(te, Ue.value, Ie - 1), Ae.indexOf(`
`) > -1 && (he ? Ae = Ae.split(`
`).map(function(oe) {
      return "  " + oe;
    }).join(`
`).slice(2) : Ae = `
` + Ae.split(`
`).map(function(oe) {
      return "   " + oe;
    }).join(`
`))) : Ae = te.stylize("[Circular]", "special")), Le(Oe)) {
      if (he && ve.match(/^\d+$/))
        return Ae;
      Oe = JSON.stringify("" + ve), Oe.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (Oe = Oe.slice(1, -1), Oe = te.stylize(Oe, "name")) : (Oe = Oe.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), Oe = te.stylize(Oe, "string"));
    }
    return Oe + ": " + Ae;
  }
  function ae(te, pe, Ie) {
    var $e = te.reduce(function(ve, he) {
      return he.indexOf(`
`) >= 0, ve + he.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0);
    return $e > 60 ? Ie[0] + (pe === "" ? "" : pe + `
 `) + " " + te.join(`,
  `) + " " + Ie[1] : Ie[0] + pe + " " + te.join(", ") + " " + Ie[1];
  }
  a.types = types$1;
  function Q(te) {
    return Array.isArray(te);
  }
  a.isArray = Q;
  function ne(te) {
    return typeof te == "boolean";
  }
  a.isBoolean = ne;
  function Z(te) {
    return te === null;
  }
  a.isNull = Z;
  function de(te) {
    return te == null;
  }
  a.isNullOrUndefined = de;
  function fe(te) {
    return typeof te == "number";
  }
  a.isNumber = fe;
  function Te(te) {
    return typeof te == "string";
  }
  a.isString = Te;
  function Re(te) {
    return typeof te == "symbol";
  }
  a.isSymbol = Re;
  function Le(te) {
    return te === void 0;
  }
  a.isUndefined = Le;
  function be(te) {
    return q(te) && I(te) === "[object RegExp]";
  }
  a.isRegExp = be, a.types.isRegExp = be;
  function q(te) {
    return typeof te == "object" && te !== null;
  }
  a.isObject = q;
  function J(te) {
    return q(te) && I(te) === "[object Date]";
  }
  a.isDate = J, a.types.isDate = J;
  function C(te) {
    return q(te) && (I(te) === "[object Error]" || te instanceof Error);
  }
  a.isError = C, a.types.isNativeError = C;
  function S(te) {
    return typeof te == "function";
  }
  a.isFunction = S;
  function E(te) {
    return te === null || typeof te == "boolean" || typeof te == "number" || typeof te == "string" || typeof te == "symbol" || // ES6 symbol
    typeof te > "u";
  }
  a.isPrimitive = E, a.isBuffer = isBufferBrowser;
  function I(te) {
    return Object.prototype.toString.call(te);
  }
  function M(te) {
    return te < 10 ? "0" + te.toString(10) : te.toString(10);
  }
  var $ = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ];
  function U() {
    var te = /* @__PURE__ */ new Date(), pe = [
      M(te.getHours()),
      M(te.getMinutes()),
      M(te.getSeconds())
    ].join(":");
    return [te.getDate(), $[te.getMonth()], pe].join(" ");
  }
  a.log = function() {
    console.log("%s - %s", U(), a.format.apply(a, arguments));
  }, a.inherits = inherits_browserExports, a._extend = function(te, pe) {
    if (!pe || !q(pe))
      return te;
    for (var Ie = Object.keys(pe), $e = Ie.length; $e--; )
      te[Ie[$e]] = pe[Ie[$e]];
    return te;
  };
  function Y(te, pe) {
    return Object.prototype.hasOwnProperty.call(te, pe);
  }
  var L = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
  a.promisify = function(pe) {
    if (typeof pe != "function")
      throw new TypeError('The "original" argument must be of type Function');
    if (L && pe[L]) {
      var Ie = pe[L];
      if (typeof Ie != "function")
        throw new TypeError('The "util.promisify.custom" argument must be of type Function');
      return Object.defineProperty(Ie, L, {
        value: Ie,
        enumerable: !1,
        writable: !1,
        configurable: !0
      }), Ie;
    }
    function Ie() {
      for (var $e, ve, he = new Promise(function(Ue, oe) {
        $e = Ue, ve = oe;
      }), Oe = [], Ae = 0; Ae < arguments.length; Ae++)
        Oe.push(arguments[Ae]);
      Oe.push(function(Ue, oe) {
        Ue ? ve(Ue) : $e(oe);
      });
      try {
        pe.apply(this, Oe);
      } catch (Ue) {
        ve(Ue);
      }
      return he;
    }
    return Object.setPrototypeOf(Ie, Object.getPrototypeOf(pe)), L && Object.defineProperty(Ie, L, {
      value: Ie,
      enumerable: !1,
      writable: !1,
      configurable: !0
    }), Object.defineProperties(
      Ie,
      u(pe)
    );
  }, a.promisify.custom = L;
  function T(te, pe) {
    if (!te) {
      var Ie = new Error("Promise was rejected with a falsy value");
      Ie.reason = te, te = Ie;
    }
    return pe(te);
  }
  function B(te) {
    if (typeof te != "function")
      throw new TypeError('The "original" argument must be of type Function');
    function pe() {
      for (var Ie = [], $e = 0; $e < arguments.length; $e++)
        Ie.push(arguments[$e]);
      var ve = Ie.pop();
      if (typeof ve != "function")
        throw new TypeError("The last argument must be of type Function");
      var he = this, Oe = function() {
        return ve.apply(he, arguments);
      };
      te.apply(this, Ie).then(
        function(Ae) {
          process$1.nextTick(Oe.bind(null, null, Ae));
        },
        function(Ae) {
          process$1.nextTick(T.bind(null, Ae, Oe));
        }
      );
    }
    return Object.setPrototypeOf(pe, Object.getPrototypeOf(te)), Object.defineProperties(
      pe,
      u(te)
    ), pe;
  }
  a.callbackify = B;
})(util$4);
var buffer_list$2, hasRequiredBuffer_list$2;
function requireBuffer_list$2() {
  if (hasRequiredBuffer_list$2)
    return buffer_list$2;
  hasRequiredBuffer_list$2 = 1;
  function a(X, ae) {
    var Q = Object.keys(X);
    if (Object.getOwnPropertySymbols) {
      var ne = Object.getOwnPropertySymbols(X);
      ae && (ne = ne.filter(function(Z) {
        return Object.getOwnPropertyDescriptor(X, Z).enumerable;
      })), Q.push.apply(Q, ne);
    }
    return Q;
  }
  function u(X) {
    for (var ae = 1; ae < arguments.length; ae++) {
      var Q = arguments[ae] != null ? arguments[ae] : {};
      ae % 2 ? a(Object(Q), !0).forEach(function(ne) {
        c(X, ne, Q[ne]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(X, Object.getOwnPropertyDescriptors(Q)) : a(Object(Q)).forEach(function(ne) {
        Object.defineProperty(X, ne, Object.getOwnPropertyDescriptor(Q, ne));
      });
    }
    return X;
  }
  function c(X, ae, Q) {
    return ae = _(ae), ae in X ? Object.defineProperty(X, ae, { value: Q, enumerable: !0, configurable: !0, writable: !0 }) : X[ae] = Q, X;
  }
  function l(X, ae) {
    if (!(X instanceof ae))
      throw new TypeError("Cannot call a class as a function");
  }
  function v(X, ae) {
    for (var Q = 0; Q < ae.length; Q++) {
      var ne = ae[Q];
      ne.enumerable = ne.enumerable || !1, ne.configurable = !0, "value" in ne && (ne.writable = !0), Object.defineProperty(X, _(ne.key), ne);
    }
  }
  function p(X, ae, Q) {
    return ae && v(X.prototype, ae), Q && v(X, Q), Object.defineProperty(X, "prototype", { writable: !1 }), X;
  }
  function _(X) {
    var ae = k(X, "string");
    return typeof ae == "symbol" ? ae : String(ae);
  }
  function k(X, ae) {
    if (typeof X != "object" || X === null)
      return X;
    var Q = X[Symbol.toPrimitive];
    if (Q !== void 0) {
      var ne = Q.call(X, ae || "default");
      if (typeof ne != "object")
        return ne;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (ae === "string" ? String : Number)(X);
  }
  var O = require$$0$2, D = O.Buffer, F = util$4, z = F.inspect, j = z && z.custom || "inspect";
  function ee(X, ae, Q) {
    D.prototype.copy.call(X, ae, Q);
  }
  return buffer_list$2 = /* @__PURE__ */ function() {
    function X() {
      l(this, X), this.head = null, this.tail = null, this.length = 0;
    }
    return p(X, [{
      key: "push",
      value: function(Q) {
        var ne = {
          data: Q,
          next: null
        };
        this.length > 0 ? this.tail.next = ne : this.head = ne, this.tail = ne, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(Q) {
        var ne = {
          data: Q,
          next: this.head
        };
        this.length === 0 && (this.tail = ne), this.head = ne, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var Q = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, Q;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(Q) {
        if (this.length === 0)
          return "";
        for (var ne = this.head, Z = "" + ne.data; ne = ne.next; )
          Z += Q + ne.data;
        return Z;
      }
    }, {
      key: "concat",
      value: function(Q) {
        if (this.length === 0)
          return D.alloc(0);
        for (var ne = D.allocUnsafe(Q >>> 0), Z = this.head, de = 0; Z; )
          ee(Z.data, ne, de), de += Z.data.length, Z = Z.next;
        return ne;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(Q, ne) {
        var Z;
        return Q < this.head.data.length ? (Z = this.head.data.slice(0, Q), this.head.data = this.head.data.slice(Q)) : Q === this.head.data.length ? Z = this.shift() : Z = ne ? this._getString(Q) : this._getBuffer(Q), Z;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(Q) {
        var ne = this.head, Z = 1, de = ne.data;
        for (Q -= de.length; ne = ne.next; ) {
          var fe = ne.data, Te = Q > fe.length ? fe.length : Q;
          if (Te === fe.length ? de += fe : de += fe.slice(0, Q), Q -= Te, Q === 0) {
            Te === fe.length ? (++Z, ne.next ? this.head = ne.next : this.head = this.tail = null) : (this.head = ne, ne.data = fe.slice(Te));
            break;
          }
          ++Z;
        }
        return this.length -= Z, de;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(Q) {
        var ne = D.allocUnsafe(Q), Z = this.head, de = 1;
        for (Z.data.copy(ne), Q -= Z.data.length; Z = Z.next; ) {
          var fe = Z.data, Te = Q > fe.length ? fe.length : Q;
          if (fe.copy(ne, ne.length - Q, 0, Te), Q -= Te, Q === 0) {
            Te === fe.length ? (++de, Z.next ? this.head = Z.next : this.head = this.tail = null) : (this.head = Z, Z.data = fe.slice(Te));
            break;
          }
          ++de;
        }
        return this.length -= de, ne;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: j,
      value: function(Q, ne) {
        return z(this, u(u({}, ne), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), X;
  }(), buffer_list$2;
}
var destroy_1$2, hasRequiredDestroy;
function requireDestroy() {
  if (hasRequiredDestroy)
    return destroy_1$2;
  hasRequiredDestroy = 1;
  function a(_, k) {
    var O = this, D = this._readableState && this._readableState.destroyed, F = this._writableState && this._writableState.destroyed;
    return D || F ? (k ? k(_) : _ && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process$1.nextTick(v, this, _)) : process$1.nextTick(v, this, _)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(_ || null, function(z) {
      !k && z ? O._writableState ? O._writableState.errorEmitted ? process$1.nextTick(c, O) : (O._writableState.errorEmitted = !0, process$1.nextTick(u, O, z)) : process$1.nextTick(u, O, z) : k ? (process$1.nextTick(c, O), k(z)) : process$1.nextTick(c, O);
    }), this);
  }
  function u(_, k) {
    v(_, k), c(_);
  }
  function c(_) {
    _._writableState && !_._writableState.emitClose || _._readableState && !_._readableState.emitClose || _.emit("close");
  }
  function l() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function v(_, k) {
    _.emit("error", k);
  }
  function p(_, k) {
    var O = _._readableState, D = _._writableState;
    O && O.autoDestroy || D && D.autoDestroy ? _.destroy(k) : _.emit("error", k);
  }
  return destroy_1$2 = {
    destroy: a,
    undestroy: l,
    errorOrDestroy: p
  }, destroy_1$2;
}
var errorsBrowser$2 = {}, hasRequiredErrorsBrowser;
function requireErrorsBrowser() {
  if (hasRequiredErrorsBrowser)
    return errorsBrowser$2;
  hasRequiredErrorsBrowser = 1;
  function a(k, O) {
    k.prototype = Object.create(O.prototype), k.prototype.constructor = k, k.__proto__ = O;
  }
  var u = {};
  function c(k, O, D) {
    D || (D = Error);
    function F(j, ee, X) {
      return typeof O == "string" ? O : O(j, ee, X);
    }
    var z = /* @__PURE__ */ function(j) {
      a(ee, j);
      function ee(X, ae, Q) {
        return j.call(this, F(X, ae, Q)) || this;
      }
      return ee;
    }(D);
    z.prototype.name = D.name, z.prototype.code = k, u[k] = z;
  }
  function l(k, O) {
    if (Array.isArray(k)) {
      var D = k.length;
      return k = k.map(function(F) {
        return String(F);
      }), D > 2 ? "one of ".concat(O, " ").concat(k.slice(0, D - 1).join(", "), ", or ") + k[D - 1] : D === 2 ? "one of ".concat(O, " ").concat(k[0], " or ").concat(k[1]) : "of ".concat(O, " ").concat(k[0]);
    } else
      return "of ".concat(O, " ").concat(String(k));
  }
  function v(k, O, D) {
    return k.substr(!D || D < 0 ? 0 : +D, O.length) === O;
  }
  function p(k, O, D) {
    return (D === void 0 || D > k.length) && (D = k.length), k.substring(D - O.length, D) === O;
  }
  function _(k, O, D) {
    return typeof D != "number" && (D = 0), D + O.length > k.length ? !1 : k.indexOf(O, D) !== -1;
  }
  return c("ERR_INVALID_OPT_VALUE", function(k, O) {
    return 'The value "' + O + '" is invalid for option "' + k + '"';
  }, TypeError), c("ERR_INVALID_ARG_TYPE", function(k, O, D) {
    var F;
    typeof O == "string" && v(O, "not ") ? (F = "must not be", O = O.replace(/^not /, "")) : F = "must be";
    var z;
    if (p(k, " argument"))
      z = "The ".concat(k, " ").concat(F, " ").concat(l(O, "type"));
    else {
      var j = _(k, ".") ? "property" : "argument";
      z = 'The "'.concat(k, '" ').concat(j, " ").concat(F, " ").concat(l(O, "type"));
    }
    return z += ". Received type ".concat(typeof D), z;
  }, TypeError), c("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), c("ERR_METHOD_NOT_IMPLEMENTED", function(k) {
    return "The " + k + " method is not implemented";
  }), c("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), c("ERR_STREAM_DESTROYED", function(k) {
    return "Cannot call " + k + " after a stream was destroyed";
  }), c("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), c("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), c("ERR_STREAM_WRITE_AFTER_END", "write after end"), c("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), c("ERR_UNKNOWN_ENCODING", function(k) {
    return "Unknown encoding: " + k;
  }, TypeError), c("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), errorsBrowser$2.codes = u, errorsBrowser$2;
}
var state$5, hasRequiredState;
function requireState() {
  if (hasRequiredState)
    return state$5;
  hasRequiredState = 1;
  var a = requireErrorsBrowser().codes.ERR_INVALID_OPT_VALUE;
  function u(l, v, p) {
    return l.highWaterMark != null ? l.highWaterMark : v ? l[p] : null;
  }
  function c(l, v, p, _) {
    var k = u(v, _, p);
    if (k != null) {
      if (!(isFinite(k) && Math.floor(k) === k) || k < 0) {
        var O = _ ? p : "highWaterMark";
        throw new a(O, k);
      }
      return Math.floor(k);
    }
    return l.objectMode ? 16 : 16 * 1024;
  }
  return state$5 = {
    getHighWaterMark: c
  }, state$5;
}
var browser$c = deprecate;
function deprecate(a, u) {
  if (config$1("noDeprecation"))
    return a;
  var c = !1;
  function l() {
    if (!c) {
      if (config$1("throwDeprecation"))
        throw new Error(u);
      config$1("traceDeprecation") ? console.trace(u) : console.warn(u), c = !0;
    }
    return a.apply(this, arguments);
  }
  return l;
}
function config$1(a) {
  try {
    if (!commonjsGlobal$1.localStorage)
      return !1;
  } catch {
    return !1;
  }
  var u = commonjsGlobal$1.localStorage[a];
  return u == null ? !1 : String(u).toLowerCase() === "true";
}
var _stream_writable$2, hasRequired_stream_writable$2;
function require_stream_writable$2() {
  if (hasRequired_stream_writable$2)
    return _stream_writable$2;
  hasRequired_stream_writable$2 = 1, _stream_writable$2 = be;
  function a(ve) {
    var he = this;
    this.next = null, this.entry = null, this.finish = function() {
      $e(he, ve);
    };
  }
  var u;
  be.WritableState = Re;
  var c = {
    deprecate: browser$c
  }, l = requireStreamBrowser(), v = require$$0$2.Buffer, p = (typeof commonjsGlobal$1 < "u" ? commonjsGlobal$1 : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function _(ve) {
    return v.from(ve);
  }
  function k(ve) {
    return v.isBuffer(ve) || ve instanceof p;
  }
  var O = requireDestroy(), D = requireState(), F = D.getHighWaterMark, z = requireErrorsBrowser().codes, j = z.ERR_INVALID_ARG_TYPE, ee = z.ERR_METHOD_NOT_IMPLEMENTED, X = z.ERR_MULTIPLE_CALLBACK, ae = z.ERR_STREAM_CANNOT_PIPE, Q = z.ERR_STREAM_DESTROYED, ne = z.ERR_STREAM_NULL_VALUES, Z = z.ERR_STREAM_WRITE_AFTER_END, de = z.ERR_UNKNOWN_ENCODING, fe = O.errorOrDestroy;
  inherits_browserExports(be, l);
  function Te() {
  }
  function Re(ve, he, Oe) {
    u = u || require_stream_duplex$2(), ve = ve || {}, typeof Oe != "boolean" && (Oe = he instanceof u), this.objectMode = !!ve.objectMode, Oe && (this.objectMode = this.objectMode || !!ve.writableObjectMode), this.highWaterMark = F(this, ve, "writableHighWaterMark", Oe), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var Ae = ve.decodeStrings === !1;
    this.decodeStrings = !Ae, this.defaultEncoding = ve.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(Ue) {
      $(he, Ue);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = ve.emitClose !== !1, this.autoDestroy = !!ve.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new a(this);
  }
  Re.prototype.getBuffer = function() {
    for (var he = this.bufferedRequest, Oe = []; he; )
      Oe.push(he), he = he.next;
    return Oe;
  }, function() {
    try {
      Object.defineProperty(Re.prototype, "buffer", {
        get: c.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var Le;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (Le = Function.prototype[Symbol.hasInstance], Object.defineProperty(be, Symbol.hasInstance, {
    value: function(he) {
      return Le.call(this, he) ? !0 : this !== be ? !1 : he && he._writableState instanceof Re;
    }
  })) : Le = function(he) {
    return he instanceof this;
  };
  function be(ve) {
    u = u || require_stream_duplex$2();
    var he = this instanceof u;
    if (!he && !Le.call(be, this))
      return new be(ve);
    this._writableState = new Re(ve, this, he), this.writable = !0, ve && (typeof ve.write == "function" && (this._write = ve.write), typeof ve.writev == "function" && (this._writev = ve.writev), typeof ve.destroy == "function" && (this._destroy = ve.destroy), typeof ve.final == "function" && (this._final = ve.final)), l.call(this);
  }
  be.prototype.pipe = function() {
    fe(this, new ae());
  };
  function q(ve, he) {
    var Oe = new Z();
    fe(ve, Oe), process$1.nextTick(he, Oe);
  }
  function J(ve, he, Oe, Ae) {
    var Ue;
    return Oe === null ? Ue = new ne() : typeof Oe != "string" && !he.objectMode && (Ue = new j("chunk", ["string", "Buffer"], Oe)), Ue ? (fe(ve, Ue), process$1.nextTick(Ae, Ue), !1) : !0;
  }
  be.prototype.write = function(ve, he, Oe) {
    var Ae = this._writableState, Ue = !1, oe = !Ae.objectMode && k(ve);
    return oe && !v.isBuffer(ve) && (ve = _(ve)), typeof he == "function" && (Oe = he, he = null), oe ? he = "buffer" : he || (he = Ae.defaultEncoding), typeof Oe != "function" && (Oe = Te), Ae.ending ? q(this, Oe) : (oe || J(this, Ae, ve, Oe)) && (Ae.pendingcb++, Ue = S(this, Ae, oe, ve, he, Oe)), Ue;
  }, be.prototype.cork = function() {
    this._writableState.corked++;
  }, be.prototype.uncork = function() {
    var ve = this._writableState;
    ve.corked && (ve.corked--, !ve.writing && !ve.corked && !ve.bufferProcessing && ve.bufferedRequest && L(this, ve));
  }, be.prototype.setDefaultEncoding = function(he) {
    if (typeof he == "string" && (he = he.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((he + "").toLowerCase()) > -1))
      throw new de(he);
    return this._writableState.defaultEncoding = he, this;
  }, Object.defineProperty(be.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function C(ve, he, Oe) {
    return !ve.objectMode && ve.decodeStrings !== !1 && typeof he == "string" && (he = v.from(he, Oe)), he;
  }
  Object.defineProperty(be.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function S(ve, he, Oe, Ae, Ue, oe) {
    if (!Oe) {
      var A = C(he, Ae, Ue);
      Ae !== A && (Oe = !0, Ue = "buffer", Ae = A);
    }
    var re = he.objectMode ? 1 : Ae.length;
    he.length += re;
    var le = he.length < he.highWaterMark;
    if (le || (he.needDrain = !0), he.writing || he.corked) {
      var Ne = he.lastBufferedRequest;
      he.lastBufferedRequest = {
        chunk: Ae,
        encoding: Ue,
        isBuf: Oe,
        callback: oe,
        next: null
      }, Ne ? Ne.next = he.lastBufferedRequest : he.bufferedRequest = he.lastBufferedRequest, he.bufferedRequestCount += 1;
    } else
      E(ve, he, !1, re, Ae, Ue, oe);
    return le;
  }
  function E(ve, he, Oe, Ae, Ue, oe, A) {
    he.writelen = Ae, he.writecb = A, he.writing = !0, he.sync = !0, he.destroyed ? he.onwrite(new Q("write")) : Oe ? ve._writev(Ue, he.onwrite) : ve._write(Ue, oe, he.onwrite), he.sync = !1;
  }
  function I(ve, he, Oe, Ae, Ue) {
    --he.pendingcb, Oe ? (process$1.nextTick(Ue, Ae), process$1.nextTick(pe, ve, he), ve._writableState.errorEmitted = !0, fe(ve, Ae)) : (Ue(Ae), ve._writableState.errorEmitted = !0, fe(ve, Ae), pe(ve, he));
  }
  function M(ve) {
    ve.writing = !1, ve.writecb = null, ve.length -= ve.writelen, ve.writelen = 0;
  }
  function $(ve, he) {
    var Oe = ve._writableState, Ae = Oe.sync, Ue = Oe.writecb;
    if (typeof Ue != "function")
      throw new X();
    if (M(Oe), he)
      I(ve, Oe, Ae, he, Ue);
    else {
      var oe = T(Oe) || ve.destroyed;
      !oe && !Oe.corked && !Oe.bufferProcessing && Oe.bufferedRequest && L(ve, Oe), Ae ? process$1.nextTick(U, ve, Oe, oe, Ue) : U(ve, Oe, oe, Ue);
    }
  }
  function U(ve, he, Oe, Ae) {
    Oe || Y(ve, he), he.pendingcb--, Ae(), pe(ve, he);
  }
  function Y(ve, he) {
    he.length === 0 && he.needDrain && (he.needDrain = !1, ve.emit("drain"));
  }
  function L(ve, he) {
    he.bufferProcessing = !0;
    var Oe = he.bufferedRequest;
    if (ve._writev && Oe && Oe.next) {
      var Ae = he.bufferedRequestCount, Ue = new Array(Ae), oe = he.corkedRequestsFree;
      oe.entry = Oe;
      for (var A = 0, re = !0; Oe; )
        Ue[A] = Oe, Oe.isBuf || (re = !1), Oe = Oe.next, A += 1;
      Ue.allBuffers = re, E(ve, he, !0, he.length, Ue, "", oe.finish), he.pendingcb++, he.lastBufferedRequest = null, oe.next ? (he.corkedRequestsFree = oe.next, oe.next = null) : he.corkedRequestsFree = new a(he), he.bufferedRequestCount = 0;
    } else {
      for (; Oe; ) {
        var le = Oe.chunk, Ne = Oe.encoding, Pe = Oe.callback, Fe = he.objectMode ? 1 : le.length;
        if (E(ve, he, !1, Fe, le, Ne, Pe), Oe = Oe.next, he.bufferedRequestCount--, he.writing)
          break;
      }
      Oe === null && (he.lastBufferedRequest = null);
    }
    he.bufferedRequest = Oe, he.bufferProcessing = !1;
  }
  be.prototype._write = function(ve, he, Oe) {
    Oe(new ee("_write()"));
  }, be.prototype._writev = null, be.prototype.end = function(ve, he, Oe) {
    var Ae = this._writableState;
    return typeof ve == "function" ? (Oe = ve, ve = null, he = null) : typeof he == "function" && (Oe = he, he = null), ve != null && this.write(ve, he), Ae.corked && (Ae.corked = 1, this.uncork()), Ae.ending || Ie(this, Ae, Oe), this;
  }, Object.defineProperty(be.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function T(ve) {
    return ve.ending && ve.length === 0 && ve.bufferedRequest === null && !ve.finished && !ve.writing;
  }
  function B(ve, he) {
    ve._final(function(Oe) {
      he.pendingcb--, Oe && fe(ve, Oe), he.prefinished = !0, ve.emit("prefinish"), pe(ve, he);
    });
  }
  function te(ve, he) {
    !he.prefinished && !he.finalCalled && (typeof ve._final == "function" && !he.destroyed ? (he.pendingcb++, he.finalCalled = !0, process$1.nextTick(B, ve, he)) : (he.prefinished = !0, ve.emit("prefinish")));
  }
  function pe(ve, he) {
    var Oe = T(he);
    if (Oe && (te(ve, he), he.pendingcb === 0 && (he.finished = !0, ve.emit("finish"), he.autoDestroy))) {
      var Ae = ve._readableState;
      (!Ae || Ae.autoDestroy && Ae.endEmitted) && ve.destroy();
    }
    return Oe;
  }
  function Ie(ve, he, Oe) {
    he.ending = !0, pe(ve, he), Oe && (he.finished ? process$1.nextTick(Oe) : ve.once("finish", Oe)), he.ended = !0, ve.writable = !1;
  }
  function $e(ve, he, Oe) {
    var Ae = ve.entry;
    for (ve.entry = null; Ae; ) {
      var Ue = Ae.callback;
      he.pendingcb--, Ue(Oe), Ae = Ae.next;
    }
    he.corkedRequestsFree.next = ve;
  }
  return Object.defineProperty(be.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(he) {
      this._writableState && (this._writableState.destroyed = he);
    }
  }), be.prototype.destroy = O.destroy, be.prototype._undestroy = O.undestroy, be.prototype._destroy = function(ve, he) {
    he(ve);
  }, _stream_writable$2;
}
var _stream_duplex$2, hasRequired_stream_duplex$2;
function require_stream_duplex$2() {
  if (hasRequired_stream_duplex$2)
    return _stream_duplex$2;
  hasRequired_stream_duplex$2 = 1;
  var a = Object.keys || function(D) {
    var F = [];
    for (var z in D)
      F.push(z);
    return F;
  };
  _stream_duplex$2 = _;
  var u = require_stream_readable$2(), c = require_stream_writable$2();
  inherits_browserExports(_, u);
  for (var l = a(c.prototype), v = 0; v < l.length; v++) {
    var p = l[v];
    _.prototype[p] || (_.prototype[p] = c.prototype[p]);
  }
  function _(D) {
    if (!(this instanceof _))
      return new _(D);
    u.call(this, D), c.call(this, D), this.allowHalfOpen = !0, D && (D.readable === !1 && (this.readable = !1), D.writable === !1 && (this.writable = !1), D.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", k)));
  }
  Object.defineProperty(_.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(_.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(_.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function k() {
    this._writableState.ended || process$1.nextTick(O, this);
  }
  function O(D) {
    D.end();
  }
  return Object.defineProperty(_.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(F) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = F, this._writableState.destroyed = F);
    }
  }), _stream_duplex$2;
}
var string_decoder = {}, safeBuffer$3 = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(a, u) {
  var c = require$$0$2, l = c.Buffer;
  function v(_, k) {
    for (var O in _)
      k[O] = _[O];
  }
  l.from && l.alloc && l.allocUnsafe && l.allocUnsafeSlow ? a.exports = c : (v(c, u), u.Buffer = p);
  function p(_, k, O) {
    return l(_, k, O);
  }
  p.prototype = Object.create(l.prototype), v(l, p), p.from = function(_, k, O) {
    if (typeof _ == "number")
      throw new TypeError("Argument must not be a number");
    return l(_, k, O);
  }, p.alloc = function(_, k, O) {
    if (typeof _ != "number")
      throw new TypeError("Argument must be a number");
    var D = l(_);
    return k !== void 0 ? typeof O == "string" ? D.fill(k, O) : D.fill(k) : D.fill(0), D;
  }, p.allocUnsafe = function(_) {
    if (typeof _ != "number")
      throw new TypeError("Argument must be a number");
    return l(_);
  }, p.allocUnsafeSlow = function(_) {
    if (typeof _ != "number")
      throw new TypeError("Argument must be a number");
    return c.SlowBuffer(_);
  };
})(safeBuffer$3, safeBuffer$3.exports);
var safeBufferExports$2 = safeBuffer$3.exports, Buffer$L = safeBufferExports$2.Buffer, isEncoding = Buffer$L.isEncoding || function(a) {
  switch (a = "" + a, a && a.toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
    case "raw":
      return !0;
    default:
      return !1;
  }
};
function _normalizeEncoding(a) {
  if (!a)
    return "utf8";
  for (var u; ; )
    switch (a) {
      case "utf8":
      case "utf-8":
        return "utf8";
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return "utf16le";
      case "latin1":
      case "binary":
        return "latin1";
      case "base64":
      case "ascii":
      case "hex":
        return a;
      default:
        if (u)
          return;
        a = ("" + a).toLowerCase(), u = !0;
    }
}
function normalizeEncoding(a) {
  var u = _normalizeEncoding(a);
  if (typeof u != "string" && (Buffer$L.isEncoding === isEncoding || !isEncoding(a)))
    throw new Error("Unknown encoding: " + a);
  return u || a;
}
string_decoder.StringDecoder = StringDecoder$1;
function StringDecoder$1(a) {
  this.encoding = normalizeEncoding(a);
  var u;
  switch (this.encoding) {
    case "utf16le":
      this.text = utf16Text, this.end = utf16End, u = 4;
      break;
    case "utf8":
      this.fillLast = utf8FillLast, u = 4;
      break;
    case "base64":
      this.text = base64Text, this.end = base64End, u = 3;
      break;
    default:
      this.write = simpleWrite, this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0, this.lastTotal = 0, this.lastChar = Buffer$L.allocUnsafe(u);
}
StringDecoder$1.prototype.write = function(a) {
  if (a.length === 0)
    return "";
  var u, c;
  if (this.lastNeed) {
    if (u = this.fillLast(a), u === void 0)
      return "";
    c = this.lastNeed, this.lastNeed = 0;
  } else
    c = 0;
  return c < a.length ? u ? u + this.text(a, c) : this.text(a, c) : u || "";
};
StringDecoder$1.prototype.end = utf8End;
StringDecoder$1.prototype.text = utf8Text;
StringDecoder$1.prototype.fillLast = function(a) {
  if (this.lastNeed <= a.length)
    return a.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
  a.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, a.length), this.lastNeed -= a.length;
};
function utf8CheckByte(a) {
  return a <= 127 ? 0 : a >> 5 === 6 ? 2 : a >> 4 === 14 ? 3 : a >> 3 === 30 ? 4 : a >> 6 === 2 ? -1 : -2;
}
function utf8CheckIncomplete(a, u, c) {
  var l = u.length - 1;
  if (l < c)
    return 0;
  var v = utf8CheckByte(u[l]);
  return v >= 0 ? (v > 0 && (a.lastNeed = v - 1), v) : --l < c || v === -2 ? 0 : (v = utf8CheckByte(u[l]), v >= 0 ? (v > 0 && (a.lastNeed = v - 2), v) : --l < c || v === -2 ? 0 : (v = utf8CheckByte(u[l]), v >= 0 ? (v > 0 && (v === 2 ? v = 0 : a.lastNeed = v - 3), v) : 0));
}
function utf8CheckExtraBytes(a, u, c) {
  if ((u[0] & 192) !== 128)
    return a.lastNeed = 0, "�";
  if (a.lastNeed > 1 && u.length > 1) {
    if ((u[1] & 192) !== 128)
      return a.lastNeed = 1, "�";
    if (a.lastNeed > 2 && u.length > 2 && (u[2] & 192) !== 128)
      return a.lastNeed = 2, "�";
  }
}
function utf8FillLast(a) {
  var u = this.lastTotal - this.lastNeed, c = utf8CheckExtraBytes(this, a);
  if (c !== void 0)
    return c;
  if (this.lastNeed <= a.length)
    return a.copy(this.lastChar, u, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
  a.copy(this.lastChar, u, 0, a.length), this.lastNeed -= a.length;
}
function utf8Text(a, u) {
  var c = utf8CheckIncomplete(this, a, u);
  if (!this.lastNeed)
    return a.toString("utf8", u);
  this.lastTotal = c;
  var l = a.length - (c - this.lastNeed);
  return a.copy(this.lastChar, 0, l), a.toString("utf8", u, l);
}
function utf8End(a) {
  var u = a && a.length ? this.write(a) : "";
  return this.lastNeed ? u + "�" : u;
}
function utf16Text(a, u) {
  if ((a.length - u) % 2 === 0) {
    var c = a.toString("utf16le", u);
    if (c) {
      var l = c.charCodeAt(c.length - 1);
      if (l >= 55296 && l <= 56319)
        return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = a[a.length - 2], this.lastChar[1] = a[a.length - 1], c.slice(0, -1);
    }
    return c;
  }
  return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = a[a.length - 1], a.toString("utf16le", u, a.length - 1);
}
function utf16End(a) {
  var u = a && a.length ? this.write(a) : "";
  if (this.lastNeed) {
    var c = this.lastTotal - this.lastNeed;
    return u + this.lastChar.toString("utf16le", 0, c);
  }
  return u;
}
function base64Text(a, u) {
  var c = (a.length - u) % 3;
  return c === 0 ? a.toString("base64", u) : (this.lastNeed = 3 - c, this.lastTotal = 3, c === 1 ? this.lastChar[0] = a[a.length - 1] : (this.lastChar[0] = a[a.length - 2], this.lastChar[1] = a[a.length - 1]), a.toString("base64", u, a.length - c));
}
function base64End(a) {
  var u = a && a.length ? this.write(a) : "";
  return this.lastNeed ? u + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : u;
}
function simpleWrite(a) {
  return a.toString(this.encoding);
}
function simpleEnd(a) {
  return a && a.length ? this.write(a) : "";
}
var endOfStream$2, hasRequiredEndOfStream;
function requireEndOfStream() {
  if (hasRequiredEndOfStream)
    return endOfStream$2;
  hasRequiredEndOfStream = 1;
  var a = requireErrorsBrowser().codes.ERR_STREAM_PREMATURE_CLOSE;
  function u(p) {
    var _ = !1;
    return function() {
      if (!_) {
        _ = !0;
        for (var k = arguments.length, O = new Array(k), D = 0; D < k; D++)
          O[D] = arguments[D];
        p.apply(this, O);
      }
    };
  }
  function c() {
  }
  function l(p) {
    return p.setHeader && typeof p.abort == "function";
  }
  function v(p, _, k) {
    if (typeof _ == "function")
      return v(p, null, _);
    _ || (_ = {}), k = u(k || c);
    var O = _.readable || _.readable !== !1 && p.readable, D = _.writable || _.writable !== !1 && p.writable, F = function() {
      p.writable || j();
    }, z = p._writableState && p._writableState.finished, j = function() {
      D = !1, z = !0, O || k.call(p);
    }, ee = p._readableState && p._readableState.endEmitted, X = function() {
      O = !1, ee = !0, D || k.call(p);
    }, ae = function(de) {
      k.call(p, de);
    }, Q = function() {
      var de;
      if (O && !ee)
        return (!p._readableState || !p._readableState.ended) && (de = new a()), k.call(p, de);
      if (D && !z)
        return (!p._writableState || !p._writableState.ended) && (de = new a()), k.call(p, de);
    }, ne = function() {
      p.req.on("finish", j);
    };
    return l(p) ? (p.on("complete", j), p.on("abort", Q), p.req ? ne() : p.on("request", ne)) : D && !p._writableState && (p.on("end", F), p.on("close", F)), p.on("end", X), p.on("finish", j), _.error !== !1 && p.on("error", ae), p.on("close", Q), function() {
      p.removeListener("complete", j), p.removeListener("abort", Q), p.removeListener("request", ne), p.req && p.req.removeListener("finish", j), p.removeListener("end", F), p.removeListener("close", F), p.removeListener("finish", j), p.removeListener("end", X), p.removeListener("error", ae), p.removeListener("close", Q);
    };
  }
  return endOfStream$2 = v, endOfStream$2;
}
var async_iterator$2, hasRequiredAsync_iterator$2;
function requireAsync_iterator$2() {
  if (hasRequiredAsync_iterator$2)
    return async_iterator$2;
  hasRequiredAsync_iterator$2 = 1;
  var a;
  function u(de, fe, Te) {
    return fe = c(fe), fe in de ? Object.defineProperty(de, fe, { value: Te, enumerable: !0, configurable: !0, writable: !0 }) : de[fe] = Te, de;
  }
  function c(de) {
    var fe = l(de, "string");
    return typeof fe == "symbol" ? fe : String(fe);
  }
  function l(de, fe) {
    if (typeof de != "object" || de === null)
      return de;
    var Te = de[Symbol.toPrimitive];
    if (Te !== void 0) {
      var Re = Te.call(de, fe || "default");
      if (typeof Re != "object")
        return Re;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (fe === "string" ? String : Number)(de);
  }
  var v = requireEndOfStream(), p = Symbol("lastResolve"), _ = Symbol("lastReject"), k = Symbol("error"), O = Symbol("ended"), D = Symbol("lastPromise"), F = Symbol("handlePromise"), z = Symbol("stream");
  function j(de, fe) {
    return {
      value: de,
      done: fe
    };
  }
  function ee(de) {
    var fe = de[p];
    if (fe !== null) {
      var Te = de[z].read();
      Te !== null && (de[D] = null, de[p] = null, de[_] = null, fe(j(Te, !1)));
    }
  }
  function X(de) {
    process$1.nextTick(ee, de);
  }
  function ae(de, fe) {
    return function(Te, Re) {
      de.then(function() {
        if (fe[O]) {
          Te(j(void 0, !0));
          return;
        }
        fe[F](Te, Re);
      }, Re);
    };
  }
  var Q = Object.getPrototypeOf(function() {
  }), ne = Object.setPrototypeOf((a = {
    get stream() {
      return this[z];
    },
    next: function() {
      var fe = this, Te = this[k];
      if (Te !== null)
        return Promise.reject(Te);
      if (this[O])
        return Promise.resolve(j(void 0, !0));
      if (this[z].destroyed)
        return new Promise(function(q, J) {
          process$1.nextTick(function() {
            fe[k] ? J(fe[k]) : q(j(void 0, !0));
          });
        });
      var Re = this[D], Le;
      if (Re)
        Le = new Promise(ae(Re, this));
      else {
        var be = this[z].read();
        if (be !== null)
          return Promise.resolve(j(be, !1));
        Le = new Promise(this[F]);
      }
      return this[D] = Le, Le;
    }
  }, u(a, Symbol.asyncIterator, function() {
    return this;
  }), u(a, "return", function() {
    var fe = this;
    return new Promise(function(Te, Re) {
      fe[z].destroy(null, function(Le) {
        if (Le) {
          Re(Le);
          return;
        }
        Te(j(void 0, !0));
      });
    });
  }), a), Q), Z = function(fe) {
    var Te, Re = Object.create(ne, (Te = {}, u(Te, z, {
      value: fe,
      writable: !0
    }), u(Te, p, {
      value: null,
      writable: !0
    }), u(Te, _, {
      value: null,
      writable: !0
    }), u(Te, k, {
      value: null,
      writable: !0
    }), u(Te, O, {
      value: fe._readableState.endEmitted,
      writable: !0
    }), u(Te, F, {
      value: function(be, q) {
        var J = Re[z].read();
        J ? (Re[D] = null, Re[p] = null, Re[_] = null, be(j(J, !1))) : (Re[p] = be, Re[_] = q);
      },
      writable: !0
    }), Te));
    return Re[D] = null, v(fe, function(Le) {
      if (Le && Le.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var be = Re[_];
        be !== null && (Re[D] = null, Re[p] = null, Re[_] = null, be(Le)), Re[k] = Le;
        return;
      }
      var q = Re[p];
      q !== null && (Re[D] = null, Re[p] = null, Re[_] = null, q(j(void 0, !0))), Re[O] = !0;
    }), fe.on("readable", X.bind(null, Re)), Re;
  };
  return async_iterator$2 = Z, async_iterator$2;
}
var fromBrowser$2, hasRequiredFromBrowser$2;
function requireFromBrowser$2() {
  return hasRequiredFromBrowser$2 || (hasRequiredFromBrowser$2 = 1, fromBrowser$2 = function() {
    throw new Error("Readable.from is not available in the browser");
  }), fromBrowser$2;
}
var _stream_readable$2, hasRequired_stream_readable$2;
function require_stream_readable$2() {
  if (hasRequired_stream_readable$2)
    return _stream_readable$2;
  hasRequired_stream_readable$2 = 1, _stream_readable$2 = q;
  var a;
  q.ReadableState = be, eventsExports.EventEmitter;
  var u = function(A, re) {
    return A.listeners(re).length;
  }, c = requireStreamBrowser(), l = require$$0$2.Buffer, v = (typeof commonjsGlobal$1 < "u" ? commonjsGlobal$1 : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function p(oe) {
    return l.from(oe);
  }
  function _(oe) {
    return l.isBuffer(oe) || oe instanceof v;
  }
  var k = util$4, O;
  k && k.debuglog ? O = k.debuglog("stream") : O = function() {
  };
  var D = requireBuffer_list$2(), F = requireDestroy(), z = requireState(), j = z.getHighWaterMark, ee = requireErrorsBrowser().codes, X = ee.ERR_INVALID_ARG_TYPE, ae = ee.ERR_STREAM_PUSH_AFTER_EOF, Q = ee.ERR_METHOD_NOT_IMPLEMENTED, ne = ee.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, Z, de, fe;
  inherits_browserExports(q, c);
  var Te = F.errorOrDestroy, Re = ["error", "close", "destroy", "pause", "resume"];
  function Le(oe, A, re) {
    if (typeof oe.prependListener == "function")
      return oe.prependListener(A, re);
    !oe._events || !oe._events[A] ? oe.on(A, re) : Array.isArray(oe._events[A]) ? oe._events[A].unshift(re) : oe._events[A] = [re, oe._events[A]];
  }
  function be(oe, A, re) {
    a = a || require_stream_duplex$2(), oe = oe || {}, typeof re != "boolean" && (re = A instanceof a), this.objectMode = !!oe.objectMode, re && (this.objectMode = this.objectMode || !!oe.readableObjectMode), this.highWaterMark = j(this, oe, "readableHighWaterMark", re), this.buffer = new D(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = oe.emitClose !== !1, this.autoDestroy = !!oe.autoDestroy, this.destroyed = !1, this.defaultEncoding = oe.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, oe.encoding && (Z || (Z = string_decoder.StringDecoder), this.decoder = new Z(oe.encoding), this.encoding = oe.encoding);
  }
  function q(oe) {
    if (a = a || require_stream_duplex$2(), !(this instanceof q))
      return new q(oe);
    var A = this instanceof a;
    this._readableState = new be(oe, this, A), this.readable = !0, oe && (typeof oe.read == "function" && (this._read = oe.read), typeof oe.destroy == "function" && (this._destroy = oe.destroy)), c.call(this);
  }
  Object.defineProperty(q.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(A) {
      this._readableState && (this._readableState.destroyed = A);
    }
  }), q.prototype.destroy = F.destroy, q.prototype._undestroy = F.undestroy, q.prototype._destroy = function(oe, A) {
    A(oe);
  }, q.prototype.push = function(oe, A) {
    var re = this._readableState, le;
    return re.objectMode ? le = !0 : typeof oe == "string" && (A = A || re.defaultEncoding, A !== re.encoding && (oe = l.from(oe, A), A = ""), le = !0), J(this, oe, A, !1, le);
  }, q.prototype.unshift = function(oe) {
    return J(this, oe, null, !0, !1);
  };
  function J(oe, A, re, le, Ne) {
    O("readableAddChunk", A);
    var Pe = oe._readableState;
    if (A === null)
      Pe.reading = !1, $(oe, Pe);
    else {
      var Fe;
      if (Ne || (Fe = S(Pe, A)), Fe)
        Te(oe, Fe);
      else if (Pe.objectMode || A && A.length > 0)
        if (typeof A != "string" && !Pe.objectMode && Object.getPrototypeOf(A) !== l.prototype && (A = p(A)), le)
          Pe.endEmitted ? Te(oe, new ne()) : C(oe, Pe, A, !0);
        else if (Pe.ended)
          Te(oe, new ae());
        else {
          if (Pe.destroyed)
            return !1;
          Pe.reading = !1, Pe.decoder && !re ? (A = Pe.decoder.write(A), Pe.objectMode || A.length !== 0 ? C(oe, Pe, A, !1) : L(oe, Pe)) : C(oe, Pe, A, !1);
        }
      else
        le || (Pe.reading = !1, L(oe, Pe));
    }
    return !Pe.ended && (Pe.length < Pe.highWaterMark || Pe.length === 0);
  }
  function C(oe, A, re, le) {
    A.flowing && A.length === 0 && !A.sync ? (A.awaitDrain = 0, oe.emit("data", re)) : (A.length += A.objectMode ? 1 : re.length, le ? A.buffer.unshift(re) : A.buffer.push(re), A.needReadable && U(oe)), L(oe, A);
  }
  function S(oe, A) {
    var re;
    return !_(A) && typeof A != "string" && A !== void 0 && !oe.objectMode && (re = new X("chunk", ["string", "Buffer", "Uint8Array"], A)), re;
  }
  q.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, q.prototype.setEncoding = function(oe) {
    Z || (Z = string_decoder.StringDecoder);
    var A = new Z(oe);
    this._readableState.decoder = A, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var re = this._readableState.buffer.head, le = ""; re !== null; )
      le += A.write(re.data), re = re.next;
    return this._readableState.buffer.clear(), le !== "" && this._readableState.buffer.push(le), this._readableState.length = le.length, this;
  };
  var E = 1073741824;
  function I(oe) {
    return oe >= E ? oe = E : (oe--, oe |= oe >>> 1, oe |= oe >>> 2, oe |= oe >>> 4, oe |= oe >>> 8, oe |= oe >>> 16, oe++), oe;
  }
  function M(oe, A) {
    return oe <= 0 || A.length === 0 && A.ended ? 0 : A.objectMode ? 1 : oe !== oe ? A.flowing && A.length ? A.buffer.head.data.length : A.length : (oe > A.highWaterMark && (A.highWaterMark = I(oe)), oe <= A.length ? oe : A.ended ? A.length : (A.needReadable = !0, 0));
  }
  q.prototype.read = function(oe) {
    O("read", oe), oe = parseInt(oe, 10);
    var A = this._readableState, re = oe;
    if (oe !== 0 && (A.emittedReadable = !1), oe === 0 && A.needReadable && ((A.highWaterMark !== 0 ? A.length >= A.highWaterMark : A.length > 0) || A.ended))
      return O("read: emitReadable", A.length, A.ended), A.length === 0 && A.ended ? Oe(this) : U(this), null;
    if (oe = M(oe, A), oe === 0 && A.ended)
      return A.length === 0 && Oe(this), null;
    var le = A.needReadable;
    O("need readable", le), (A.length === 0 || A.length - oe < A.highWaterMark) && (le = !0, O("length less than watermark", le)), A.ended || A.reading ? (le = !1, O("reading or ended", le)) : le && (O("do read"), A.reading = !0, A.sync = !0, A.length === 0 && (A.needReadable = !0), this._read(A.highWaterMark), A.sync = !1, A.reading || (oe = M(re, A)));
    var Ne;
    return oe > 0 ? Ne = he(oe, A) : Ne = null, Ne === null ? (A.needReadable = A.length <= A.highWaterMark, oe = 0) : (A.length -= oe, A.awaitDrain = 0), A.length === 0 && (A.ended || (A.needReadable = !0), re !== oe && A.ended && Oe(this)), Ne !== null && this.emit("data", Ne), Ne;
  };
  function $(oe, A) {
    if (O("onEofChunk"), !A.ended) {
      if (A.decoder) {
        var re = A.decoder.end();
        re && re.length && (A.buffer.push(re), A.length += A.objectMode ? 1 : re.length);
      }
      A.ended = !0, A.sync ? U(oe) : (A.needReadable = !1, A.emittedReadable || (A.emittedReadable = !0, Y(oe)));
    }
  }
  function U(oe) {
    var A = oe._readableState;
    O("emitReadable", A.needReadable, A.emittedReadable), A.needReadable = !1, A.emittedReadable || (O("emitReadable", A.flowing), A.emittedReadable = !0, process$1.nextTick(Y, oe));
  }
  function Y(oe) {
    var A = oe._readableState;
    O("emitReadable_", A.destroyed, A.length, A.ended), !A.destroyed && (A.length || A.ended) && (oe.emit("readable"), A.emittedReadable = !1), A.needReadable = !A.flowing && !A.ended && A.length <= A.highWaterMark, ve(oe);
  }
  function L(oe, A) {
    A.readingMore || (A.readingMore = !0, process$1.nextTick(T, oe, A));
  }
  function T(oe, A) {
    for (; !A.reading && !A.ended && (A.length < A.highWaterMark || A.flowing && A.length === 0); ) {
      var re = A.length;
      if (O("maybeReadMore read 0"), oe.read(0), re === A.length)
        break;
    }
    A.readingMore = !1;
  }
  q.prototype._read = function(oe) {
    Te(this, new Q("_read()"));
  }, q.prototype.pipe = function(oe, A) {
    var re = this, le = this._readableState;
    switch (le.pipesCount) {
      case 0:
        le.pipes = oe;
        break;
      case 1:
        le.pipes = [le.pipes, oe];
        break;
      default:
        le.pipes.push(oe);
        break;
    }
    le.pipesCount += 1, O("pipe count=%d opts=%j", le.pipesCount, A);
    var Ne = (!A || A.end !== !1) && oe !== process$1.stdout && oe !== process$1.stderr, Pe = Ne ? je : We;
    le.endEmitted ? process$1.nextTick(Pe) : re.once("end", Pe), oe.on("unpipe", Fe);
    function Fe(we, V) {
      O("onunpipe"), we === re && V && V.hasUnpiped === !1 && (V.hasUnpiped = !0, Xe());
    }
    function je() {
      O("onend"), oe.end();
    }
    var qe = B(re);
    oe.on("drain", qe);
    var yt = !1;
    function Xe() {
      O("cleanup"), oe.removeListener("close", ye), oe.removeListener("finish", Ee), oe.removeListener("drain", qe), oe.removeListener("error", H), oe.removeListener("unpipe", Fe), re.removeListener("end", je), re.removeListener("end", We), re.removeListener("data", Ge), yt = !0, le.awaitDrain && (!oe._writableState || oe._writableState.needDrain) && qe();
    }
    re.on("data", Ge);
    function Ge(we) {
      O("ondata");
      var V = oe.write(we);
      O("dest.write", V), V === !1 && ((le.pipesCount === 1 && le.pipes === oe || le.pipesCount > 1 && Ue(le.pipes, oe) !== -1) && !yt && (O("false write response, pause", le.awaitDrain), le.awaitDrain++), re.pause());
    }
    function H(we) {
      O("onerror", we), We(), oe.removeListener("error", H), u(oe, "error") === 0 && Te(oe, we);
    }
    Le(oe, "error", H);
    function ye() {
      oe.removeListener("finish", Ee), We();
    }
    oe.once("close", ye);
    function Ee() {
      O("onfinish"), oe.removeListener("close", ye), We();
    }
    oe.once("finish", Ee);
    function We() {
      O("unpipe"), re.unpipe(oe);
    }
    return oe.emit("pipe", re), le.flowing || (O("pipe resume"), re.resume()), oe;
  };
  function B(oe) {
    return function() {
      var re = oe._readableState;
      O("pipeOnDrain", re.awaitDrain), re.awaitDrain && re.awaitDrain--, re.awaitDrain === 0 && u(oe, "data") && (re.flowing = !0, ve(oe));
    };
  }
  q.prototype.unpipe = function(oe) {
    var A = this._readableState, re = {
      hasUnpiped: !1
    };
    if (A.pipesCount === 0)
      return this;
    if (A.pipesCount === 1)
      return oe && oe !== A.pipes ? this : (oe || (oe = A.pipes), A.pipes = null, A.pipesCount = 0, A.flowing = !1, oe && oe.emit("unpipe", this, re), this);
    if (!oe) {
      var le = A.pipes, Ne = A.pipesCount;
      A.pipes = null, A.pipesCount = 0, A.flowing = !1;
      for (var Pe = 0; Pe < Ne; Pe++)
        le[Pe].emit("unpipe", this, {
          hasUnpiped: !1
        });
      return this;
    }
    var Fe = Ue(A.pipes, oe);
    return Fe === -1 ? this : (A.pipes.splice(Fe, 1), A.pipesCount -= 1, A.pipesCount === 1 && (A.pipes = A.pipes[0]), oe.emit("unpipe", this, re), this);
  }, q.prototype.on = function(oe, A) {
    var re = c.prototype.on.call(this, oe, A), le = this._readableState;
    return oe === "data" ? (le.readableListening = this.listenerCount("readable") > 0, le.flowing !== !1 && this.resume()) : oe === "readable" && !le.endEmitted && !le.readableListening && (le.readableListening = le.needReadable = !0, le.flowing = !1, le.emittedReadable = !1, O("on readable", le.length, le.reading), le.length ? U(this) : le.reading || process$1.nextTick(pe, this)), re;
  }, q.prototype.addListener = q.prototype.on, q.prototype.removeListener = function(oe, A) {
    var re = c.prototype.removeListener.call(this, oe, A);
    return oe === "readable" && process$1.nextTick(te, this), re;
  }, q.prototype.removeAllListeners = function(oe) {
    var A = c.prototype.removeAllListeners.apply(this, arguments);
    return (oe === "readable" || oe === void 0) && process$1.nextTick(te, this), A;
  };
  function te(oe) {
    var A = oe._readableState;
    A.readableListening = oe.listenerCount("readable") > 0, A.resumeScheduled && !A.paused ? A.flowing = !0 : oe.listenerCount("data") > 0 && oe.resume();
  }
  function pe(oe) {
    O("readable nexttick read 0"), oe.read(0);
  }
  q.prototype.resume = function() {
    var oe = this._readableState;
    return oe.flowing || (O("resume"), oe.flowing = !oe.readableListening, Ie(this, oe)), oe.paused = !1, this;
  };
  function Ie(oe, A) {
    A.resumeScheduled || (A.resumeScheduled = !0, process$1.nextTick($e, oe, A));
  }
  function $e(oe, A) {
    O("resume", A.reading), A.reading || oe.read(0), A.resumeScheduled = !1, oe.emit("resume"), ve(oe), A.flowing && !A.reading && oe.read(0);
  }
  q.prototype.pause = function() {
    return O("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (O("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function ve(oe) {
    var A = oe._readableState;
    for (O("flow", A.flowing); A.flowing && oe.read() !== null; )
      ;
  }
  q.prototype.wrap = function(oe) {
    var A = this, re = this._readableState, le = !1;
    oe.on("end", function() {
      if (O("wrapped end"), re.decoder && !re.ended) {
        var Fe = re.decoder.end();
        Fe && Fe.length && A.push(Fe);
      }
      A.push(null);
    }), oe.on("data", function(Fe) {
      if (O("wrapped data"), re.decoder && (Fe = re.decoder.write(Fe)), !(re.objectMode && Fe == null) && !(!re.objectMode && (!Fe || !Fe.length))) {
        var je = A.push(Fe);
        je || (le = !0, oe.pause());
      }
    });
    for (var Ne in oe)
      this[Ne] === void 0 && typeof oe[Ne] == "function" && (this[Ne] = /* @__PURE__ */ function(je) {
        return function() {
          return oe[je].apply(oe, arguments);
        };
      }(Ne));
    for (var Pe = 0; Pe < Re.length; Pe++)
      oe.on(Re[Pe], this.emit.bind(this, Re[Pe]));
    return this._read = function(Fe) {
      O("wrapped _read", Fe), le && (le = !1, oe.resume());
    }, this;
  }, typeof Symbol == "function" && (q.prototype[Symbol.asyncIterator] = function() {
    return de === void 0 && (de = requireAsync_iterator$2()), de(this);
  }), Object.defineProperty(q.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(q.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(q.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(A) {
      this._readableState && (this._readableState.flowing = A);
    }
  }), q._fromList = he, Object.defineProperty(q.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function he(oe, A) {
    if (A.length === 0)
      return null;
    var re;
    return A.objectMode ? re = A.buffer.shift() : !oe || oe >= A.length ? (A.decoder ? re = A.buffer.join("") : A.buffer.length === 1 ? re = A.buffer.first() : re = A.buffer.concat(A.length), A.buffer.clear()) : re = A.buffer.consume(oe, A.decoder), re;
  }
  function Oe(oe) {
    var A = oe._readableState;
    O("endReadable", A.endEmitted), A.endEmitted || (A.ended = !0, process$1.nextTick(Ae, A, oe));
  }
  function Ae(oe, A) {
    if (O("endReadableNT", oe.endEmitted, oe.length), !oe.endEmitted && oe.length === 0 && (oe.endEmitted = !0, A.readable = !1, A.emit("end"), oe.autoDestroy)) {
      var re = A._writableState;
      (!re || re.autoDestroy && re.finished) && A.destroy();
    }
  }
  typeof Symbol == "function" && (q.from = function(oe, A) {
    return fe === void 0 && (fe = requireFromBrowser$2()), fe(q, oe, A);
  });
  function Ue(oe, A) {
    for (var re = 0, le = oe.length; re < le; re++)
      if (oe[re] === A)
        return re;
    return -1;
  }
  return _stream_readable$2;
}
var _stream_transform$2, hasRequired_stream_transform;
function require_stream_transform() {
  if (hasRequired_stream_transform)
    return _stream_transform$2;
  hasRequired_stream_transform = 1, _stream_transform$2 = k;
  var a = requireErrorsBrowser().codes, u = a.ERR_METHOD_NOT_IMPLEMENTED, c = a.ERR_MULTIPLE_CALLBACK, l = a.ERR_TRANSFORM_ALREADY_TRANSFORMING, v = a.ERR_TRANSFORM_WITH_LENGTH_0, p = require_stream_duplex$2();
  inherits_browserExports(k, p);
  function _(F, z) {
    var j = this._transformState;
    j.transforming = !1;
    var ee = j.writecb;
    if (ee === null)
      return this.emit("error", new c());
    j.writechunk = null, j.writecb = null, z != null && this.push(z), ee(F);
    var X = this._readableState;
    X.reading = !1, (X.needReadable || X.length < X.highWaterMark) && this._read(X.highWaterMark);
  }
  function k(F) {
    if (!(this instanceof k))
      return new k(F);
    p.call(this, F), this._transformState = {
      afterTransform: _.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, F && (typeof F.transform == "function" && (this._transform = F.transform), typeof F.flush == "function" && (this._flush = F.flush)), this.on("prefinish", O);
  }
  function O() {
    var F = this;
    typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(z, j) {
      D(F, z, j);
    }) : D(this, null, null);
  }
  k.prototype.push = function(F, z) {
    return this._transformState.needTransform = !1, p.prototype.push.call(this, F, z);
  }, k.prototype._transform = function(F, z, j) {
    j(new u("_transform()"));
  }, k.prototype._write = function(F, z, j) {
    var ee = this._transformState;
    if (ee.writecb = j, ee.writechunk = F, ee.writeencoding = z, !ee.transforming) {
      var X = this._readableState;
      (ee.needTransform || X.needReadable || X.length < X.highWaterMark) && this._read(X.highWaterMark);
    }
  }, k.prototype._read = function(F) {
    var z = this._transformState;
    z.writechunk !== null && !z.transforming ? (z.transforming = !0, this._transform(z.writechunk, z.writeencoding, z.afterTransform)) : z.needTransform = !0;
  }, k.prototype._destroy = function(F, z) {
    p.prototype._destroy.call(this, F, function(j) {
      z(j);
    });
  };
  function D(F, z, j) {
    if (z)
      return F.emit("error", z);
    if (j != null && F.push(j), F._writableState.length)
      throw new v();
    if (F._transformState.transforming)
      throw new l();
    return F.push(null);
  }
  return _stream_transform$2;
}
var _stream_passthrough$2, hasRequired_stream_passthrough;
function require_stream_passthrough() {
  if (hasRequired_stream_passthrough)
    return _stream_passthrough$2;
  hasRequired_stream_passthrough = 1, _stream_passthrough$2 = u;
  var a = require_stream_transform();
  inherits_browserExports(u, a);
  function u(c) {
    if (!(this instanceof u))
      return new u(c);
    a.call(this, c);
  }
  return u.prototype._transform = function(c, l, v) {
    v(null, c);
  }, _stream_passthrough$2;
}
var pipeline_1$2, hasRequiredPipeline;
function requirePipeline() {
  if (hasRequiredPipeline)
    return pipeline_1$2;
  hasRequiredPipeline = 1;
  var a;
  function u(j) {
    var ee = !1;
    return function() {
      ee || (ee = !0, j.apply(void 0, arguments));
    };
  }
  var c = requireErrorsBrowser().codes, l = c.ERR_MISSING_ARGS, v = c.ERR_STREAM_DESTROYED;
  function p(j) {
    if (j)
      throw j;
  }
  function _(j) {
    return j.setHeader && typeof j.abort == "function";
  }
  function k(j, ee, X, ae) {
    ae = u(ae);
    var Q = !1;
    j.on("close", function() {
      Q = !0;
    }), a === void 0 && (a = requireEndOfStream()), a(j, {
      readable: ee,
      writable: X
    }, function(Z) {
      if (Z)
        return ae(Z);
      Q = !0, ae();
    });
    var ne = !1;
    return function(Z) {
      if (!Q && !ne) {
        if (ne = !0, _(j))
          return j.abort();
        if (typeof j.destroy == "function")
          return j.destroy();
        ae(Z || new v("pipe"));
      }
    };
  }
  function O(j) {
    j();
  }
  function D(j, ee) {
    return j.pipe(ee);
  }
  function F(j) {
    return !j.length || typeof j[j.length - 1] != "function" ? p : j.pop();
  }
  function z() {
    for (var j = arguments.length, ee = new Array(j), X = 0; X < j; X++)
      ee[X] = arguments[X];
    var ae = F(ee);
    if (Array.isArray(ee[0]) && (ee = ee[0]), ee.length < 2)
      throw new l("streams");
    var Q, ne = ee.map(function(Z, de) {
      var fe = de < ee.length - 1, Te = de > 0;
      return k(Z, fe, Te, function(Re) {
        Q || (Q = Re), Re && ne.forEach(O), !fe && (ne.forEach(O), ae(Q));
      });
    });
    return ee.reduce(D);
  }
  return pipeline_1$2 = z, pipeline_1$2;
}
var streamBrowserify = Stream$3, EE = eventsExports.EventEmitter, inherits$v = inherits_browserExports;
inherits$v(Stream$3, EE);
Stream$3.Readable = require_stream_readable$2();
Stream$3.Writable = require_stream_writable$2();
Stream$3.Duplex = require_stream_duplex$2();
Stream$3.Transform = require_stream_transform();
Stream$3.PassThrough = require_stream_passthrough();
Stream$3.finished = requireEndOfStream();
Stream$3.pipeline = requirePipeline();
Stream$3.Stream = Stream$3;
function Stream$3() {
  EE.call(this);
}
Stream$3.prototype.pipe = function(a, u) {
  var c = this;
  function l(F) {
    a.writable && a.write(F) === !1 && c.pause && c.pause();
  }
  c.on("data", l);
  function v() {
    c.readable && c.resume && c.resume();
  }
  a.on("drain", v), !a._isStdio && (!u || u.end !== !1) && (c.on("end", _), c.on("close", k));
  var p = !1;
  function _() {
    p || (p = !0, a.end());
  }
  function k() {
    p || (p = !0, typeof a.destroy == "function" && a.destroy());
  }
  function O(F) {
    if (D(), EE.listenerCount(this, "error") === 0)
      throw F;
  }
  c.on("error", O), a.on("error", O);
  function D() {
    c.removeListener("data", l), a.removeListener("drain", v), c.removeListener("end", _), c.removeListener("close", k), c.removeListener("error", O), a.removeListener("error", O), c.removeListener("end", D), c.removeListener("close", D), a.removeListener("close", D);
  }
  return c.on("end", D), c.on("close", D), a.on("close", D), a.emit("pipe", c), a;
};
var Buffer$K = safeBufferExports$3.Buffer, Stream$2 = streamBrowserify, util$3 = util$4;
function DataStream$2(a) {
  if (this.buffer = null, this.writable = !0, this.readable = !0, !a)
    return this.buffer = Buffer$K.alloc(0), this;
  if (typeof a.pipe == "function")
    return this.buffer = Buffer$K.alloc(0), a.pipe(this), this;
  if (a.length || typeof a == "object")
    return this.buffer = a, this.writable = !1, process$1.nextTick((function() {
      this.emit("end", a), this.readable = !1, this.emit("close");
    }).bind(this)), this;
  throw new TypeError("Unexpected data type (" + typeof a + ")");
}
util$3.inherits(DataStream$2, Stream$2);
DataStream$2.prototype.write = function a(u) {
  this.buffer = Buffer$K.concat([this.buffer, Buffer$K.from(u)]), this.emit("data", u);
};
DataStream$2.prototype.end = function a(u) {
  u && this.write(u), this.emit("end", u), this.emit("close"), this.writable = !1, this.readable = !1;
};
var dataStream = DataStream$2, Buffer$J = require$$0$2.Buffer, SlowBuffer = require$$0$2.SlowBuffer, bufferEqualConstantTime = bufferEq;
function bufferEq(a, u) {
  if (!Buffer$J.isBuffer(a) || !Buffer$J.isBuffer(u) || a.length !== u.length)
    return !1;
  for (var c = 0, l = 0; l < a.length; l++)
    c |= a[l] ^ u[l];
  return c === 0;
}
bufferEq.install = function() {
  Buffer$J.prototype.equal = SlowBuffer.prototype.equal = function(u) {
    return bufferEq(this, u);
  };
};
var origBufEqual = Buffer$J.prototype.equal, origSlowBufEqual = SlowBuffer.prototype.equal;
bufferEq.restore = function() {
  Buffer$J.prototype.equal = origBufEqual, SlowBuffer.prototype.equal = origSlowBufEqual;
};
var cryptoBrowserify = {}, browser$b = { exports: {} }, MAX_BYTES = 65536, MAX_UINT32 = 4294967295;
function oldBrowser$1() {
  throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
}
var Buffer$I = safeBufferExports$3.Buffer, crypto$3 = commonjsGlobal$1.crypto || commonjsGlobal$1.msCrypto;
crypto$3 && crypto$3.getRandomValues ? browser$b.exports = randomBytes$2 : browser$b.exports = oldBrowser$1;
function randomBytes$2(a, u) {
  if (a > MAX_UINT32)
    throw new RangeError("requested too many random bytes");
  var c = Buffer$I.allocUnsafe(a);
  if (a > 0)
    if (a > MAX_BYTES)
      for (var l = 0; l < a; l += MAX_BYTES)
        crypto$3.getRandomValues(c.slice(l, l + MAX_BYTES));
    else
      crypto$3.getRandomValues(c);
  return typeof u == "function" ? process$1.nextTick(function() {
    u(null, c);
  }) : c;
}
var browserExports = browser$b.exports, safeBuffer$2 = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(a, u) {
  var c = require$$0$2, l = c.Buffer;
  function v(_, k) {
    for (var O in _)
      k[O] = _[O];
  }
  l.from && l.alloc && l.allocUnsafe && l.allocUnsafeSlow ? a.exports = c : (v(c, u), u.Buffer = p);
  function p(_, k, O) {
    return l(_, k, O);
  }
  p.prototype = Object.create(l.prototype), v(l, p), p.from = function(_, k, O) {
    if (typeof _ == "number")
      throw new TypeError("Argument must not be a number");
    return l(_, k, O);
  }, p.alloc = function(_, k, O) {
    if (typeof _ != "number")
      throw new TypeError("Argument must be a number");
    var D = l(_);
    return k !== void 0 ? typeof O == "string" ? D.fill(k, O) : D.fill(k) : D.fill(0), D;
  }, p.allocUnsafe = function(_) {
    if (typeof _ != "number")
      throw new TypeError("Argument must be a number");
    return l(_);
  }, p.allocUnsafeSlow = function(_) {
    if (typeof _ != "number")
      throw new TypeError("Argument must be a number");
    return c.SlowBuffer(_);
  };
})(safeBuffer$2, safeBuffer$2.exports);
var safeBufferExports$1 = safeBuffer$2.exports, readableBrowser$1 = { exports: {} }, streamBrowser$1 = eventsExports.EventEmitter, buffer_list$1, hasRequiredBuffer_list$1;
function requireBuffer_list$1() {
  if (hasRequiredBuffer_list$1)
    return buffer_list$1;
  hasRequiredBuffer_list$1 = 1;
  function a(X, ae) {
    var Q = Object.keys(X);
    if (Object.getOwnPropertySymbols) {
      var ne = Object.getOwnPropertySymbols(X);
      ae && (ne = ne.filter(function(Z) {
        return Object.getOwnPropertyDescriptor(X, Z).enumerable;
      })), Q.push.apply(Q, ne);
    }
    return Q;
  }
  function u(X) {
    for (var ae = 1; ae < arguments.length; ae++) {
      var Q = arguments[ae] != null ? arguments[ae] : {};
      ae % 2 ? a(Object(Q), !0).forEach(function(ne) {
        c(X, ne, Q[ne]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(X, Object.getOwnPropertyDescriptors(Q)) : a(Object(Q)).forEach(function(ne) {
        Object.defineProperty(X, ne, Object.getOwnPropertyDescriptor(Q, ne));
      });
    }
    return X;
  }
  function c(X, ae, Q) {
    return ae = _(ae), ae in X ? Object.defineProperty(X, ae, { value: Q, enumerable: !0, configurable: !0, writable: !0 }) : X[ae] = Q, X;
  }
  function l(X, ae) {
    if (!(X instanceof ae))
      throw new TypeError("Cannot call a class as a function");
  }
  function v(X, ae) {
    for (var Q = 0; Q < ae.length; Q++) {
      var ne = ae[Q];
      ne.enumerable = ne.enumerable || !1, ne.configurable = !0, "value" in ne && (ne.writable = !0), Object.defineProperty(X, _(ne.key), ne);
    }
  }
  function p(X, ae, Q) {
    return ae && v(X.prototype, ae), Q && v(X, Q), Object.defineProperty(X, "prototype", { writable: !1 }), X;
  }
  function _(X) {
    var ae = k(X, "string");
    return typeof ae == "symbol" ? ae : String(ae);
  }
  function k(X, ae) {
    if (typeof X != "object" || X === null)
      return X;
    var Q = X[Symbol.toPrimitive];
    if (Q !== void 0) {
      var ne = Q.call(X, ae || "default");
      if (typeof ne != "object")
        return ne;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (ae === "string" ? String : Number)(X);
  }
  var O = require$$0$2, D = O.Buffer, F = util$4, z = F.inspect, j = z && z.custom || "inspect";
  function ee(X, ae, Q) {
    D.prototype.copy.call(X, ae, Q);
  }
  return buffer_list$1 = /* @__PURE__ */ function() {
    function X() {
      l(this, X), this.head = null, this.tail = null, this.length = 0;
    }
    return p(X, [{
      key: "push",
      value: function(Q) {
        var ne = {
          data: Q,
          next: null
        };
        this.length > 0 ? this.tail.next = ne : this.head = ne, this.tail = ne, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(Q) {
        var ne = {
          data: Q,
          next: this.head
        };
        this.length === 0 && (this.tail = ne), this.head = ne, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var Q = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, Q;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(Q) {
        if (this.length === 0)
          return "";
        for (var ne = this.head, Z = "" + ne.data; ne = ne.next; )
          Z += Q + ne.data;
        return Z;
      }
    }, {
      key: "concat",
      value: function(Q) {
        if (this.length === 0)
          return D.alloc(0);
        for (var ne = D.allocUnsafe(Q >>> 0), Z = this.head, de = 0; Z; )
          ee(Z.data, ne, de), de += Z.data.length, Z = Z.next;
        return ne;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(Q, ne) {
        var Z;
        return Q < this.head.data.length ? (Z = this.head.data.slice(0, Q), this.head.data = this.head.data.slice(Q)) : Q === this.head.data.length ? Z = this.shift() : Z = ne ? this._getString(Q) : this._getBuffer(Q), Z;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(Q) {
        var ne = this.head, Z = 1, de = ne.data;
        for (Q -= de.length; ne = ne.next; ) {
          var fe = ne.data, Te = Q > fe.length ? fe.length : Q;
          if (Te === fe.length ? de += fe : de += fe.slice(0, Q), Q -= Te, Q === 0) {
            Te === fe.length ? (++Z, ne.next ? this.head = ne.next : this.head = this.tail = null) : (this.head = ne, ne.data = fe.slice(Te));
            break;
          }
          ++Z;
        }
        return this.length -= Z, de;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(Q) {
        var ne = D.allocUnsafe(Q), Z = this.head, de = 1;
        for (Z.data.copy(ne), Q -= Z.data.length; Z = Z.next; ) {
          var fe = Z.data, Te = Q > fe.length ? fe.length : Q;
          if (fe.copy(ne, ne.length - Q, 0, Te), Q -= Te, Q === 0) {
            Te === fe.length ? (++de, Z.next ? this.head = Z.next : this.head = this.tail = null) : (this.head = Z, Z.data = fe.slice(Te));
            break;
          }
          ++de;
        }
        return this.length -= de, ne;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: j,
      value: function(Q, ne) {
        return z(this, u(u({}, ne), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), X;
  }(), buffer_list$1;
}
function destroy$1(a, u) {
  var c = this, l = this._readableState && this._readableState.destroyed, v = this._writableState && this._writableState.destroyed;
  return l || v ? (u ? u(a) : a && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process$1.nextTick(emitErrorNT$1, this, a)) : process$1.nextTick(emitErrorNT$1, this, a)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(a || null, function(p) {
    !u && p ? c._writableState ? c._writableState.errorEmitted ? process$1.nextTick(emitCloseNT$1, c) : (c._writableState.errorEmitted = !0, process$1.nextTick(emitErrorAndCloseNT$1, c, p)) : process$1.nextTick(emitErrorAndCloseNT$1, c, p) : u ? (process$1.nextTick(emitCloseNT$1, c), u(p)) : process$1.nextTick(emitCloseNT$1, c);
  }), this);
}
function emitErrorAndCloseNT$1(a, u) {
  emitErrorNT$1(a, u), emitCloseNT$1(a);
}
function emitCloseNT$1(a) {
  a._writableState && !a._writableState.emitClose || a._readableState && !a._readableState.emitClose || a.emit("close");
}
function undestroy$1() {
  this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
}
function emitErrorNT$1(a, u) {
  a.emit("error", u);
}
function errorOrDestroy$1(a, u) {
  var c = a._readableState, l = a._writableState;
  c && c.autoDestroy || l && l.autoDestroy ? a.destroy(u) : a.emit("error", u);
}
var destroy_1$1 = {
  destroy: destroy$1,
  undestroy: undestroy$1,
  errorOrDestroy: errorOrDestroy$1
}, errorsBrowser$1 = {};
function _inheritsLoose$2(a, u) {
  a.prototype = Object.create(u.prototype), a.prototype.constructor = a, a.__proto__ = u;
}
var codes$1 = {};
function createErrorType$1(a, u, c) {
  c || (c = Error);
  function l(p, _, k) {
    return typeof u == "string" ? u : u(p, _, k);
  }
  var v = /* @__PURE__ */ function(p) {
    _inheritsLoose$2(_, p);
    function _(k, O, D) {
      return p.call(this, l(k, O, D)) || this;
    }
    return _;
  }(c);
  v.prototype.name = c.name, v.prototype.code = a, codes$1[a] = v;
}
function oneOf$1(a, u) {
  if (Array.isArray(a)) {
    var c = a.length;
    return a = a.map(function(l) {
      return String(l);
    }), c > 2 ? "one of ".concat(u, " ").concat(a.slice(0, c - 1).join(", "), ", or ") + a[c - 1] : c === 2 ? "one of ".concat(u, " ").concat(a[0], " or ").concat(a[1]) : "of ".concat(u, " ").concat(a[0]);
  } else
    return "of ".concat(u, " ").concat(String(a));
}
function startsWith$1(a, u, c) {
  return a.substr(!c || c < 0 ? 0 : +c, u.length) === u;
}
function endsWith$1(a, u, c) {
  return (c === void 0 || c > a.length) && (c = a.length), a.substring(c - u.length, c) === u;
}
function includes$3(a, u, c) {
  return typeof c != "number" && (c = 0), c + u.length > a.length ? !1 : a.indexOf(u, c) !== -1;
}
createErrorType$1("ERR_INVALID_OPT_VALUE", function(a, u) {
  return 'The value "' + u + '" is invalid for option "' + a + '"';
}, TypeError);
createErrorType$1("ERR_INVALID_ARG_TYPE", function(a, u, c) {
  var l;
  typeof u == "string" && startsWith$1(u, "not ") ? (l = "must not be", u = u.replace(/^not /, "")) : l = "must be";
  var v;
  if (endsWith$1(a, " argument"))
    v = "The ".concat(a, " ").concat(l, " ").concat(oneOf$1(u, "type"));
  else {
    var p = includes$3(a, ".") ? "property" : "argument";
    v = 'The "'.concat(a, '" ').concat(p, " ").concat(l, " ").concat(oneOf$1(u, "type"));
  }
  return v += ". Received type ".concat(typeof c), v;
}, TypeError);
createErrorType$1("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
createErrorType$1("ERR_METHOD_NOT_IMPLEMENTED", function(a) {
  return "The " + a + " method is not implemented";
});
createErrorType$1("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
createErrorType$1("ERR_STREAM_DESTROYED", function(a) {
  return "Cannot call " + a + " after a stream was destroyed";
});
createErrorType$1("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
createErrorType$1("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
createErrorType$1("ERR_STREAM_WRITE_AFTER_END", "write after end");
createErrorType$1("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
createErrorType$1("ERR_UNKNOWN_ENCODING", function(a) {
  return "Unknown encoding: " + a;
}, TypeError);
createErrorType$1("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
errorsBrowser$1.codes = codes$1;
var ERR_INVALID_OPT_VALUE$1 = errorsBrowser$1.codes.ERR_INVALID_OPT_VALUE;
function highWaterMarkFrom$1(a, u, c) {
  return a.highWaterMark != null ? a.highWaterMark : u ? a[c] : null;
}
function getHighWaterMark$1(a, u, c, l) {
  var v = highWaterMarkFrom$1(u, l, c);
  if (v != null) {
    if (!(isFinite(v) && Math.floor(v) === v) || v < 0) {
      var p = l ? c : "highWaterMark";
      throw new ERR_INVALID_OPT_VALUE$1(p, v);
    }
    return Math.floor(v);
  }
  return a.objectMode ? 16 : 16 * 1024;
}
var state$4 = {
  getHighWaterMark: getHighWaterMark$1
}, _stream_writable$1, hasRequired_stream_writable$1;
function require_stream_writable$1() {
  if (hasRequired_stream_writable$1)
    return _stream_writable$1;
  hasRequired_stream_writable$1 = 1, _stream_writable$1 = be;
  function a(ve) {
    var he = this;
    this.next = null, this.entry = null, this.finish = function() {
      $e(he, ve);
    };
  }
  var u;
  be.WritableState = Re;
  var c = {
    deprecate: browser$c
  }, l = streamBrowser$1, v = require$$0$2.Buffer, p = (typeof commonjsGlobal$1 < "u" ? commonjsGlobal$1 : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function _(ve) {
    return v.from(ve);
  }
  function k(ve) {
    return v.isBuffer(ve) || ve instanceof p;
  }
  var O = destroy_1$1, D = state$4, F = D.getHighWaterMark, z = errorsBrowser$1.codes, j = z.ERR_INVALID_ARG_TYPE, ee = z.ERR_METHOD_NOT_IMPLEMENTED, X = z.ERR_MULTIPLE_CALLBACK, ae = z.ERR_STREAM_CANNOT_PIPE, Q = z.ERR_STREAM_DESTROYED, ne = z.ERR_STREAM_NULL_VALUES, Z = z.ERR_STREAM_WRITE_AFTER_END, de = z.ERR_UNKNOWN_ENCODING, fe = O.errorOrDestroy;
  inherits_browserExports(be, l);
  function Te() {
  }
  function Re(ve, he, Oe) {
    u = u || require_stream_duplex$1(), ve = ve || {}, typeof Oe != "boolean" && (Oe = he instanceof u), this.objectMode = !!ve.objectMode, Oe && (this.objectMode = this.objectMode || !!ve.writableObjectMode), this.highWaterMark = F(this, ve, "writableHighWaterMark", Oe), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var Ae = ve.decodeStrings === !1;
    this.decodeStrings = !Ae, this.defaultEncoding = ve.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(Ue) {
      $(he, Ue);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = ve.emitClose !== !1, this.autoDestroy = !!ve.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new a(this);
  }
  Re.prototype.getBuffer = function() {
    for (var he = this.bufferedRequest, Oe = []; he; )
      Oe.push(he), he = he.next;
    return Oe;
  }, function() {
    try {
      Object.defineProperty(Re.prototype, "buffer", {
        get: c.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var Le;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (Le = Function.prototype[Symbol.hasInstance], Object.defineProperty(be, Symbol.hasInstance, {
    value: function(he) {
      return Le.call(this, he) ? !0 : this !== be ? !1 : he && he._writableState instanceof Re;
    }
  })) : Le = function(he) {
    return he instanceof this;
  };
  function be(ve) {
    u = u || require_stream_duplex$1();
    var he = this instanceof u;
    if (!he && !Le.call(be, this))
      return new be(ve);
    this._writableState = new Re(ve, this, he), this.writable = !0, ve && (typeof ve.write == "function" && (this._write = ve.write), typeof ve.writev == "function" && (this._writev = ve.writev), typeof ve.destroy == "function" && (this._destroy = ve.destroy), typeof ve.final == "function" && (this._final = ve.final)), l.call(this);
  }
  be.prototype.pipe = function() {
    fe(this, new ae());
  };
  function q(ve, he) {
    var Oe = new Z();
    fe(ve, Oe), process$1.nextTick(he, Oe);
  }
  function J(ve, he, Oe, Ae) {
    var Ue;
    return Oe === null ? Ue = new ne() : typeof Oe != "string" && !he.objectMode && (Ue = new j("chunk", ["string", "Buffer"], Oe)), Ue ? (fe(ve, Ue), process$1.nextTick(Ae, Ue), !1) : !0;
  }
  be.prototype.write = function(ve, he, Oe) {
    var Ae = this._writableState, Ue = !1, oe = !Ae.objectMode && k(ve);
    return oe && !v.isBuffer(ve) && (ve = _(ve)), typeof he == "function" && (Oe = he, he = null), oe ? he = "buffer" : he || (he = Ae.defaultEncoding), typeof Oe != "function" && (Oe = Te), Ae.ending ? q(this, Oe) : (oe || J(this, Ae, ve, Oe)) && (Ae.pendingcb++, Ue = S(this, Ae, oe, ve, he, Oe)), Ue;
  }, be.prototype.cork = function() {
    this._writableState.corked++;
  }, be.prototype.uncork = function() {
    var ve = this._writableState;
    ve.corked && (ve.corked--, !ve.writing && !ve.corked && !ve.bufferProcessing && ve.bufferedRequest && L(this, ve));
  }, be.prototype.setDefaultEncoding = function(he) {
    if (typeof he == "string" && (he = he.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((he + "").toLowerCase()) > -1))
      throw new de(he);
    return this._writableState.defaultEncoding = he, this;
  }, Object.defineProperty(be.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function C(ve, he, Oe) {
    return !ve.objectMode && ve.decodeStrings !== !1 && typeof he == "string" && (he = v.from(he, Oe)), he;
  }
  Object.defineProperty(be.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function S(ve, he, Oe, Ae, Ue, oe) {
    if (!Oe) {
      var A = C(he, Ae, Ue);
      Ae !== A && (Oe = !0, Ue = "buffer", Ae = A);
    }
    var re = he.objectMode ? 1 : Ae.length;
    he.length += re;
    var le = he.length < he.highWaterMark;
    if (le || (he.needDrain = !0), he.writing || he.corked) {
      var Ne = he.lastBufferedRequest;
      he.lastBufferedRequest = {
        chunk: Ae,
        encoding: Ue,
        isBuf: Oe,
        callback: oe,
        next: null
      }, Ne ? Ne.next = he.lastBufferedRequest : he.bufferedRequest = he.lastBufferedRequest, he.bufferedRequestCount += 1;
    } else
      E(ve, he, !1, re, Ae, Ue, oe);
    return le;
  }
  function E(ve, he, Oe, Ae, Ue, oe, A) {
    he.writelen = Ae, he.writecb = A, he.writing = !0, he.sync = !0, he.destroyed ? he.onwrite(new Q("write")) : Oe ? ve._writev(Ue, he.onwrite) : ve._write(Ue, oe, he.onwrite), he.sync = !1;
  }
  function I(ve, he, Oe, Ae, Ue) {
    --he.pendingcb, Oe ? (process$1.nextTick(Ue, Ae), process$1.nextTick(pe, ve, he), ve._writableState.errorEmitted = !0, fe(ve, Ae)) : (Ue(Ae), ve._writableState.errorEmitted = !0, fe(ve, Ae), pe(ve, he));
  }
  function M(ve) {
    ve.writing = !1, ve.writecb = null, ve.length -= ve.writelen, ve.writelen = 0;
  }
  function $(ve, he) {
    var Oe = ve._writableState, Ae = Oe.sync, Ue = Oe.writecb;
    if (typeof Ue != "function")
      throw new X();
    if (M(Oe), he)
      I(ve, Oe, Ae, he, Ue);
    else {
      var oe = T(Oe) || ve.destroyed;
      !oe && !Oe.corked && !Oe.bufferProcessing && Oe.bufferedRequest && L(ve, Oe), Ae ? process$1.nextTick(U, ve, Oe, oe, Ue) : U(ve, Oe, oe, Ue);
    }
  }
  function U(ve, he, Oe, Ae) {
    Oe || Y(ve, he), he.pendingcb--, Ae(), pe(ve, he);
  }
  function Y(ve, he) {
    he.length === 0 && he.needDrain && (he.needDrain = !1, ve.emit("drain"));
  }
  function L(ve, he) {
    he.bufferProcessing = !0;
    var Oe = he.bufferedRequest;
    if (ve._writev && Oe && Oe.next) {
      var Ae = he.bufferedRequestCount, Ue = new Array(Ae), oe = he.corkedRequestsFree;
      oe.entry = Oe;
      for (var A = 0, re = !0; Oe; )
        Ue[A] = Oe, Oe.isBuf || (re = !1), Oe = Oe.next, A += 1;
      Ue.allBuffers = re, E(ve, he, !0, he.length, Ue, "", oe.finish), he.pendingcb++, he.lastBufferedRequest = null, oe.next ? (he.corkedRequestsFree = oe.next, oe.next = null) : he.corkedRequestsFree = new a(he), he.bufferedRequestCount = 0;
    } else {
      for (; Oe; ) {
        var le = Oe.chunk, Ne = Oe.encoding, Pe = Oe.callback, Fe = he.objectMode ? 1 : le.length;
        if (E(ve, he, !1, Fe, le, Ne, Pe), Oe = Oe.next, he.bufferedRequestCount--, he.writing)
          break;
      }
      Oe === null && (he.lastBufferedRequest = null);
    }
    he.bufferedRequest = Oe, he.bufferProcessing = !1;
  }
  be.prototype._write = function(ve, he, Oe) {
    Oe(new ee("_write()"));
  }, be.prototype._writev = null, be.prototype.end = function(ve, he, Oe) {
    var Ae = this._writableState;
    return typeof ve == "function" ? (Oe = ve, ve = null, he = null) : typeof he == "function" && (Oe = he, he = null), ve != null && this.write(ve, he), Ae.corked && (Ae.corked = 1, this.uncork()), Ae.ending || Ie(this, Ae, Oe), this;
  }, Object.defineProperty(be.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function T(ve) {
    return ve.ending && ve.length === 0 && ve.bufferedRequest === null && !ve.finished && !ve.writing;
  }
  function B(ve, he) {
    ve._final(function(Oe) {
      he.pendingcb--, Oe && fe(ve, Oe), he.prefinished = !0, ve.emit("prefinish"), pe(ve, he);
    });
  }
  function te(ve, he) {
    !he.prefinished && !he.finalCalled && (typeof ve._final == "function" && !he.destroyed ? (he.pendingcb++, he.finalCalled = !0, process$1.nextTick(B, ve, he)) : (he.prefinished = !0, ve.emit("prefinish")));
  }
  function pe(ve, he) {
    var Oe = T(he);
    if (Oe && (te(ve, he), he.pendingcb === 0 && (he.finished = !0, ve.emit("finish"), he.autoDestroy))) {
      var Ae = ve._readableState;
      (!Ae || Ae.autoDestroy && Ae.endEmitted) && ve.destroy();
    }
    return Oe;
  }
  function Ie(ve, he, Oe) {
    he.ending = !0, pe(ve, he), Oe && (he.finished ? process$1.nextTick(Oe) : ve.once("finish", Oe)), he.ended = !0, ve.writable = !1;
  }
  function $e(ve, he, Oe) {
    var Ae = ve.entry;
    for (ve.entry = null; Ae; ) {
      var Ue = Ae.callback;
      he.pendingcb--, Ue(Oe), Ae = Ae.next;
    }
    he.corkedRequestsFree.next = ve;
  }
  return Object.defineProperty(be.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(he) {
      this._writableState && (this._writableState.destroyed = he);
    }
  }), be.prototype.destroy = O.destroy, be.prototype._undestroy = O.undestroy, be.prototype._destroy = function(ve, he) {
    he(ve);
  }, _stream_writable$1;
}
var _stream_duplex$1, hasRequired_stream_duplex$1;
function require_stream_duplex$1() {
  if (hasRequired_stream_duplex$1)
    return _stream_duplex$1;
  hasRequired_stream_duplex$1 = 1;
  var a = Object.keys || function(D) {
    var F = [];
    for (var z in D)
      F.push(z);
    return F;
  };
  _stream_duplex$1 = _;
  var u = require_stream_readable$1(), c = require_stream_writable$1();
  inherits_browserExports(_, u);
  for (var l = a(c.prototype), v = 0; v < l.length; v++) {
    var p = l[v];
    _.prototype[p] || (_.prototype[p] = c.prototype[p]);
  }
  function _(D) {
    if (!(this instanceof _))
      return new _(D);
    u.call(this, D), c.call(this, D), this.allowHalfOpen = !0, D && (D.readable === !1 && (this.readable = !1), D.writable === !1 && (this.writable = !1), D.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", k)));
  }
  Object.defineProperty(_.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(_.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(_.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function k() {
    this._writableState.ended || process$1.nextTick(O, this);
  }
  function O(D) {
    D.end();
  }
  return Object.defineProperty(_.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(F) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = F, this._writableState.destroyed = F);
    }
  }), _stream_duplex$1;
}
var ERR_STREAM_PREMATURE_CLOSE$1 = errorsBrowser$1.codes.ERR_STREAM_PREMATURE_CLOSE;
function once$5(a) {
  var u = !1;
  return function() {
    if (!u) {
      u = !0;
      for (var c = arguments.length, l = new Array(c), v = 0; v < c; v++)
        l[v] = arguments[v];
      a.apply(this, l);
    }
  };
}
function noop$4() {
}
function isRequest$3(a) {
  return a.setHeader && typeof a.abort == "function";
}
function eos$3(a, u, c) {
  if (typeof u == "function")
    return eos$3(a, null, u);
  u || (u = {}), c = once$5(c || noop$4);
  var l = u.readable || u.readable !== !1 && a.readable, v = u.writable || u.writable !== !1 && a.writable, p = function() {
    a.writable || k();
  }, _ = a._writableState && a._writableState.finished, k = function() {
    v = !1, _ = !0, l || c.call(a);
  }, O = a._readableState && a._readableState.endEmitted, D = function() {
    l = !1, O = !0, v || c.call(a);
  }, F = function(X) {
    c.call(a, X);
  }, z = function() {
    var X;
    if (l && !O)
      return (!a._readableState || !a._readableState.ended) && (X = new ERR_STREAM_PREMATURE_CLOSE$1()), c.call(a, X);
    if (v && !_)
      return (!a._writableState || !a._writableState.ended) && (X = new ERR_STREAM_PREMATURE_CLOSE$1()), c.call(a, X);
  }, j = function() {
    a.req.on("finish", k);
  };
  return isRequest$3(a) ? (a.on("complete", k), a.on("abort", z), a.req ? j() : a.on("request", j)) : v && !a._writableState && (a.on("end", p), a.on("close", p)), a.on("end", D), a.on("finish", k), u.error !== !1 && a.on("error", F), a.on("close", z), function() {
    a.removeListener("complete", k), a.removeListener("abort", z), a.removeListener("request", j), a.req && a.req.removeListener("finish", k), a.removeListener("end", p), a.removeListener("close", p), a.removeListener("finish", k), a.removeListener("end", D), a.removeListener("error", F), a.removeListener("close", z);
  };
}
var endOfStream$1 = eos$3, async_iterator$1, hasRequiredAsync_iterator$1;
function requireAsync_iterator$1() {
  if (hasRequiredAsync_iterator$1)
    return async_iterator$1;
  hasRequiredAsync_iterator$1 = 1;
  var a;
  function u(de, fe, Te) {
    return fe = c(fe), fe in de ? Object.defineProperty(de, fe, { value: Te, enumerable: !0, configurable: !0, writable: !0 }) : de[fe] = Te, de;
  }
  function c(de) {
    var fe = l(de, "string");
    return typeof fe == "symbol" ? fe : String(fe);
  }
  function l(de, fe) {
    if (typeof de != "object" || de === null)
      return de;
    var Te = de[Symbol.toPrimitive];
    if (Te !== void 0) {
      var Re = Te.call(de, fe || "default");
      if (typeof Re != "object")
        return Re;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (fe === "string" ? String : Number)(de);
  }
  var v = endOfStream$1, p = Symbol("lastResolve"), _ = Symbol("lastReject"), k = Symbol("error"), O = Symbol("ended"), D = Symbol("lastPromise"), F = Symbol("handlePromise"), z = Symbol("stream");
  function j(de, fe) {
    return {
      value: de,
      done: fe
    };
  }
  function ee(de) {
    var fe = de[p];
    if (fe !== null) {
      var Te = de[z].read();
      Te !== null && (de[D] = null, de[p] = null, de[_] = null, fe(j(Te, !1)));
    }
  }
  function X(de) {
    process$1.nextTick(ee, de);
  }
  function ae(de, fe) {
    return function(Te, Re) {
      de.then(function() {
        if (fe[O]) {
          Te(j(void 0, !0));
          return;
        }
        fe[F](Te, Re);
      }, Re);
    };
  }
  var Q = Object.getPrototypeOf(function() {
  }), ne = Object.setPrototypeOf((a = {
    get stream() {
      return this[z];
    },
    next: function() {
      var fe = this, Te = this[k];
      if (Te !== null)
        return Promise.reject(Te);
      if (this[O])
        return Promise.resolve(j(void 0, !0));
      if (this[z].destroyed)
        return new Promise(function(q, J) {
          process$1.nextTick(function() {
            fe[k] ? J(fe[k]) : q(j(void 0, !0));
          });
        });
      var Re = this[D], Le;
      if (Re)
        Le = new Promise(ae(Re, this));
      else {
        var be = this[z].read();
        if (be !== null)
          return Promise.resolve(j(be, !1));
        Le = new Promise(this[F]);
      }
      return this[D] = Le, Le;
    }
  }, u(a, Symbol.asyncIterator, function() {
    return this;
  }), u(a, "return", function() {
    var fe = this;
    return new Promise(function(Te, Re) {
      fe[z].destroy(null, function(Le) {
        if (Le) {
          Re(Le);
          return;
        }
        Te(j(void 0, !0));
      });
    });
  }), a), Q), Z = function(fe) {
    var Te, Re = Object.create(ne, (Te = {}, u(Te, z, {
      value: fe,
      writable: !0
    }), u(Te, p, {
      value: null,
      writable: !0
    }), u(Te, _, {
      value: null,
      writable: !0
    }), u(Te, k, {
      value: null,
      writable: !0
    }), u(Te, O, {
      value: fe._readableState.endEmitted,
      writable: !0
    }), u(Te, F, {
      value: function(be, q) {
        var J = Re[z].read();
        J ? (Re[D] = null, Re[p] = null, Re[_] = null, be(j(J, !1))) : (Re[p] = be, Re[_] = q);
      },
      writable: !0
    }), Te));
    return Re[D] = null, v(fe, function(Le) {
      if (Le && Le.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var be = Re[_];
        be !== null && (Re[D] = null, Re[p] = null, Re[_] = null, be(Le)), Re[k] = Le;
        return;
      }
      var q = Re[p];
      q !== null && (Re[D] = null, Re[p] = null, Re[_] = null, q(j(void 0, !0))), Re[O] = !0;
    }), fe.on("readable", X.bind(null, Re)), Re;
  };
  return async_iterator$1 = Z, async_iterator$1;
}
var fromBrowser$1, hasRequiredFromBrowser$1;
function requireFromBrowser$1() {
  return hasRequiredFromBrowser$1 || (hasRequiredFromBrowser$1 = 1, fromBrowser$1 = function() {
    throw new Error("Readable.from is not available in the browser");
  }), fromBrowser$1;
}
var _stream_readable$1, hasRequired_stream_readable$1;
function require_stream_readable$1() {
  if (hasRequired_stream_readable$1)
    return _stream_readable$1;
  hasRequired_stream_readable$1 = 1, _stream_readable$1 = q;
  var a;
  q.ReadableState = be, eventsExports.EventEmitter;
  var u = function(A, re) {
    return A.listeners(re).length;
  }, c = streamBrowser$1, l = require$$0$2.Buffer, v = (typeof commonjsGlobal$1 < "u" ? commonjsGlobal$1 : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function p(oe) {
    return l.from(oe);
  }
  function _(oe) {
    return l.isBuffer(oe) || oe instanceof v;
  }
  var k = util$4, O;
  k && k.debuglog ? O = k.debuglog("stream") : O = function() {
  };
  var D = requireBuffer_list$1(), F = destroy_1$1, z = state$4, j = z.getHighWaterMark, ee = errorsBrowser$1.codes, X = ee.ERR_INVALID_ARG_TYPE, ae = ee.ERR_STREAM_PUSH_AFTER_EOF, Q = ee.ERR_METHOD_NOT_IMPLEMENTED, ne = ee.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, Z, de, fe;
  inherits_browserExports(q, c);
  var Te = F.errorOrDestroy, Re = ["error", "close", "destroy", "pause", "resume"];
  function Le(oe, A, re) {
    if (typeof oe.prependListener == "function")
      return oe.prependListener(A, re);
    !oe._events || !oe._events[A] ? oe.on(A, re) : Array.isArray(oe._events[A]) ? oe._events[A].unshift(re) : oe._events[A] = [re, oe._events[A]];
  }
  function be(oe, A, re) {
    a = a || require_stream_duplex$1(), oe = oe || {}, typeof re != "boolean" && (re = A instanceof a), this.objectMode = !!oe.objectMode, re && (this.objectMode = this.objectMode || !!oe.readableObjectMode), this.highWaterMark = j(this, oe, "readableHighWaterMark", re), this.buffer = new D(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = oe.emitClose !== !1, this.autoDestroy = !!oe.autoDestroy, this.destroyed = !1, this.defaultEncoding = oe.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, oe.encoding && (Z || (Z = string_decoder.StringDecoder), this.decoder = new Z(oe.encoding), this.encoding = oe.encoding);
  }
  function q(oe) {
    if (a = a || require_stream_duplex$1(), !(this instanceof q))
      return new q(oe);
    var A = this instanceof a;
    this._readableState = new be(oe, this, A), this.readable = !0, oe && (typeof oe.read == "function" && (this._read = oe.read), typeof oe.destroy == "function" && (this._destroy = oe.destroy)), c.call(this);
  }
  Object.defineProperty(q.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(A) {
      this._readableState && (this._readableState.destroyed = A);
    }
  }), q.prototype.destroy = F.destroy, q.prototype._undestroy = F.undestroy, q.prototype._destroy = function(oe, A) {
    A(oe);
  }, q.prototype.push = function(oe, A) {
    var re = this._readableState, le;
    return re.objectMode ? le = !0 : typeof oe == "string" && (A = A || re.defaultEncoding, A !== re.encoding && (oe = l.from(oe, A), A = ""), le = !0), J(this, oe, A, !1, le);
  }, q.prototype.unshift = function(oe) {
    return J(this, oe, null, !0, !1);
  };
  function J(oe, A, re, le, Ne) {
    O("readableAddChunk", A);
    var Pe = oe._readableState;
    if (A === null)
      Pe.reading = !1, $(oe, Pe);
    else {
      var Fe;
      if (Ne || (Fe = S(Pe, A)), Fe)
        Te(oe, Fe);
      else if (Pe.objectMode || A && A.length > 0)
        if (typeof A != "string" && !Pe.objectMode && Object.getPrototypeOf(A) !== l.prototype && (A = p(A)), le)
          Pe.endEmitted ? Te(oe, new ne()) : C(oe, Pe, A, !0);
        else if (Pe.ended)
          Te(oe, new ae());
        else {
          if (Pe.destroyed)
            return !1;
          Pe.reading = !1, Pe.decoder && !re ? (A = Pe.decoder.write(A), Pe.objectMode || A.length !== 0 ? C(oe, Pe, A, !1) : L(oe, Pe)) : C(oe, Pe, A, !1);
        }
      else
        le || (Pe.reading = !1, L(oe, Pe));
    }
    return !Pe.ended && (Pe.length < Pe.highWaterMark || Pe.length === 0);
  }
  function C(oe, A, re, le) {
    A.flowing && A.length === 0 && !A.sync ? (A.awaitDrain = 0, oe.emit("data", re)) : (A.length += A.objectMode ? 1 : re.length, le ? A.buffer.unshift(re) : A.buffer.push(re), A.needReadable && U(oe)), L(oe, A);
  }
  function S(oe, A) {
    var re;
    return !_(A) && typeof A != "string" && A !== void 0 && !oe.objectMode && (re = new X("chunk", ["string", "Buffer", "Uint8Array"], A)), re;
  }
  q.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, q.prototype.setEncoding = function(oe) {
    Z || (Z = string_decoder.StringDecoder);
    var A = new Z(oe);
    this._readableState.decoder = A, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var re = this._readableState.buffer.head, le = ""; re !== null; )
      le += A.write(re.data), re = re.next;
    return this._readableState.buffer.clear(), le !== "" && this._readableState.buffer.push(le), this._readableState.length = le.length, this;
  };
  var E = 1073741824;
  function I(oe) {
    return oe >= E ? oe = E : (oe--, oe |= oe >>> 1, oe |= oe >>> 2, oe |= oe >>> 4, oe |= oe >>> 8, oe |= oe >>> 16, oe++), oe;
  }
  function M(oe, A) {
    return oe <= 0 || A.length === 0 && A.ended ? 0 : A.objectMode ? 1 : oe !== oe ? A.flowing && A.length ? A.buffer.head.data.length : A.length : (oe > A.highWaterMark && (A.highWaterMark = I(oe)), oe <= A.length ? oe : A.ended ? A.length : (A.needReadable = !0, 0));
  }
  q.prototype.read = function(oe) {
    O("read", oe), oe = parseInt(oe, 10);
    var A = this._readableState, re = oe;
    if (oe !== 0 && (A.emittedReadable = !1), oe === 0 && A.needReadable && ((A.highWaterMark !== 0 ? A.length >= A.highWaterMark : A.length > 0) || A.ended))
      return O("read: emitReadable", A.length, A.ended), A.length === 0 && A.ended ? Oe(this) : U(this), null;
    if (oe = M(oe, A), oe === 0 && A.ended)
      return A.length === 0 && Oe(this), null;
    var le = A.needReadable;
    O("need readable", le), (A.length === 0 || A.length - oe < A.highWaterMark) && (le = !0, O("length less than watermark", le)), A.ended || A.reading ? (le = !1, O("reading or ended", le)) : le && (O("do read"), A.reading = !0, A.sync = !0, A.length === 0 && (A.needReadable = !0), this._read(A.highWaterMark), A.sync = !1, A.reading || (oe = M(re, A)));
    var Ne;
    return oe > 0 ? Ne = he(oe, A) : Ne = null, Ne === null ? (A.needReadable = A.length <= A.highWaterMark, oe = 0) : (A.length -= oe, A.awaitDrain = 0), A.length === 0 && (A.ended || (A.needReadable = !0), re !== oe && A.ended && Oe(this)), Ne !== null && this.emit("data", Ne), Ne;
  };
  function $(oe, A) {
    if (O("onEofChunk"), !A.ended) {
      if (A.decoder) {
        var re = A.decoder.end();
        re && re.length && (A.buffer.push(re), A.length += A.objectMode ? 1 : re.length);
      }
      A.ended = !0, A.sync ? U(oe) : (A.needReadable = !1, A.emittedReadable || (A.emittedReadable = !0, Y(oe)));
    }
  }
  function U(oe) {
    var A = oe._readableState;
    O("emitReadable", A.needReadable, A.emittedReadable), A.needReadable = !1, A.emittedReadable || (O("emitReadable", A.flowing), A.emittedReadable = !0, process$1.nextTick(Y, oe));
  }
  function Y(oe) {
    var A = oe._readableState;
    O("emitReadable_", A.destroyed, A.length, A.ended), !A.destroyed && (A.length || A.ended) && (oe.emit("readable"), A.emittedReadable = !1), A.needReadable = !A.flowing && !A.ended && A.length <= A.highWaterMark, ve(oe);
  }
  function L(oe, A) {
    A.readingMore || (A.readingMore = !0, process$1.nextTick(T, oe, A));
  }
  function T(oe, A) {
    for (; !A.reading && !A.ended && (A.length < A.highWaterMark || A.flowing && A.length === 0); ) {
      var re = A.length;
      if (O("maybeReadMore read 0"), oe.read(0), re === A.length)
        break;
    }
    A.readingMore = !1;
  }
  q.prototype._read = function(oe) {
    Te(this, new Q("_read()"));
  }, q.prototype.pipe = function(oe, A) {
    var re = this, le = this._readableState;
    switch (le.pipesCount) {
      case 0:
        le.pipes = oe;
        break;
      case 1:
        le.pipes = [le.pipes, oe];
        break;
      default:
        le.pipes.push(oe);
        break;
    }
    le.pipesCount += 1, O("pipe count=%d opts=%j", le.pipesCount, A);
    var Ne = (!A || A.end !== !1) && oe !== process$1.stdout && oe !== process$1.stderr, Pe = Ne ? je : We;
    le.endEmitted ? process$1.nextTick(Pe) : re.once("end", Pe), oe.on("unpipe", Fe);
    function Fe(we, V) {
      O("onunpipe"), we === re && V && V.hasUnpiped === !1 && (V.hasUnpiped = !0, Xe());
    }
    function je() {
      O("onend"), oe.end();
    }
    var qe = B(re);
    oe.on("drain", qe);
    var yt = !1;
    function Xe() {
      O("cleanup"), oe.removeListener("close", ye), oe.removeListener("finish", Ee), oe.removeListener("drain", qe), oe.removeListener("error", H), oe.removeListener("unpipe", Fe), re.removeListener("end", je), re.removeListener("end", We), re.removeListener("data", Ge), yt = !0, le.awaitDrain && (!oe._writableState || oe._writableState.needDrain) && qe();
    }
    re.on("data", Ge);
    function Ge(we) {
      O("ondata");
      var V = oe.write(we);
      O("dest.write", V), V === !1 && ((le.pipesCount === 1 && le.pipes === oe || le.pipesCount > 1 && Ue(le.pipes, oe) !== -1) && !yt && (O("false write response, pause", le.awaitDrain), le.awaitDrain++), re.pause());
    }
    function H(we) {
      O("onerror", we), We(), oe.removeListener("error", H), u(oe, "error") === 0 && Te(oe, we);
    }
    Le(oe, "error", H);
    function ye() {
      oe.removeListener("finish", Ee), We();
    }
    oe.once("close", ye);
    function Ee() {
      O("onfinish"), oe.removeListener("close", ye), We();
    }
    oe.once("finish", Ee);
    function We() {
      O("unpipe"), re.unpipe(oe);
    }
    return oe.emit("pipe", re), le.flowing || (O("pipe resume"), re.resume()), oe;
  };
  function B(oe) {
    return function() {
      var re = oe._readableState;
      O("pipeOnDrain", re.awaitDrain), re.awaitDrain && re.awaitDrain--, re.awaitDrain === 0 && u(oe, "data") && (re.flowing = !0, ve(oe));
    };
  }
  q.prototype.unpipe = function(oe) {
    var A = this._readableState, re = {
      hasUnpiped: !1
    };
    if (A.pipesCount === 0)
      return this;
    if (A.pipesCount === 1)
      return oe && oe !== A.pipes ? this : (oe || (oe = A.pipes), A.pipes = null, A.pipesCount = 0, A.flowing = !1, oe && oe.emit("unpipe", this, re), this);
    if (!oe) {
      var le = A.pipes, Ne = A.pipesCount;
      A.pipes = null, A.pipesCount = 0, A.flowing = !1;
      for (var Pe = 0; Pe < Ne; Pe++)
        le[Pe].emit("unpipe", this, {
          hasUnpiped: !1
        });
      return this;
    }
    var Fe = Ue(A.pipes, oe);
    return Fe === -1 ? this : (A.pipes.splice(Fe, 1), A.pipesCount -= 1, A.pipesCount === 1 && (A.pipes = A.pipes[0]), oe.emit("unpipe", this, re), this);
  }, q.prototype.on = function(oe, A) {
    var re = c.prototype.on.call(this, oe, A), le = this._readableState;
    return oe === "data" ? (le.readableListening = this.listenerCount("readable") > 0, le.flowing !== !1 && this.resume()) : oe === "readable" && !le.endEmitted && !le.readableListening && (le.readableListening = le.needReadable = !0, le.flowing = !1, le.emittedReadable = !1, O("on readable", le.length, le.reading), le.length ? U(this) : le.reading || process$1.nextTick(pe, this)), re;
  }, q.prototype.addListener = q.prototype.on, q.prototype.removeListener = function(oe, A) {
    var re = c.prototype.removeListener.call(this, oe, A);
    return oe === "readable" && process$1.nextTick(te, this), re;
  }, q.prototype.removeAllListeners = function(oe) {
    var A = c.prototype.removeAllListeners.apply(this, arguments);
    return (oe === "readable" || oe === void 0) && process$1.nextTick(te, this), A;
  };
  function te(oe) {
    var A = oe._readableState;
    A.readableListening = oe.listenerCount("readable") > 0, A.resumeScheduled && !A.paused ? A.flowing = !0 : oe.listenerCount("data") > 0 && oe.resume();
  }
  function pe(oe) {
    O("readable nexttick read 0"), oe.read(0);
  }
  q.prototype.resume = function() {
    var oe = this._readableState;
    return oe.flowing || (O("resume"), oe.flowing = !oe.readableListening, Ie(this, oe)), oe.paused = !1, this;
  };
  function Ie(oe, A) {
    A.resumeScheduled || (A.resumeScheduled = !0, process$1.nextTick($e, oe, A));
  }
  function $e(oe, A) {
    O("resume", A.reading), A.reading || oe.read(0), A.resumeScheduled = !1, oe.emit("resume"), ve(oe), A.flowing && !A.reading && oe.read(0);
  }
  q.prototype.pause = function() {
    return O("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (O("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function ve(oe) {
    var A = oe._readableState;
    for (O("flow", A.flowing); A.flowing && oe.read() !== null; )
      ;
  }
  q.prototype.wrap = function(oe) {
    var A = this, re = this._readableState, le = !1;
    oe.on("end", function() {
      if (O("wrapped end"), re.decoder && !re.ended) {
        var Fe = re.decoder.end();
        Fe && Fe.length && A.push(Fe);
      }
      A.push(null);
    }), oe.on("data", function(Fe) {
      if (O("wrapped data"), re.decoder && (Fe = re.decoder.write(Fe)), !(re.objectMode && Fe == null) && !(!re.objectMode && (!Fe || !Fe.length))) {
        var je = A.push(Fe);
        je || (le = !0, oe.pause());
      }
    });
    for (var Ne in oe)
      this[Ne] === void 0 && typeof oe[Ne] == "function" && (this[Ne] = /* @__PURE__ */ function(je) {
        return function() {
          return oe[je].apply(oe, arguments);
        };
      }(Ne));
    for (var Pe = 0; Pe < Re.length; Pe++)
      oe.on(Re[Pe], this.emit.bind(this, Re[Pe]));
    return this._read = function(Fe) {
      O("wrapped _read", Fe), le && (le = !1, oe.resume());
    }, this;
  }, typeof Symbol == "function" && (q.prototype[Symbol.asyncIterator] = function() {
    return de === void 0 && (de = requireAsync_iterator$1()), de(this);
  }), Object.defineProperty(q.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(q.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(q.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(A) {
      this._readableState && (this._readableState.flowing = A);
    }
  }), q._fromList = he, Object.defineProperty(q.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function he(oe, A) {
    if (A.length === 0)
      return null;
    var re;
    return A.objectMode ? re = A.buffer.shift() : !oe || oe >= A.length ? (A.decoder ? re = A.buffer.join("") : A.buffer.length === 1 ? re = A.buffer.first() : re = A.buffer.concat(A.length), A.buffer.clear()) : re = A.buffer.consume(oe, A.decoder), re;
  }
  function Oe(oe) {
    var A = oe._readableState;
    O("endReadable", A.endEmitted), A.endEmitted || (A.ended = !0, process$1.nextTick(Ae, A, oe));
  }
  function Ae(oe, A) {
    if (O("endReadableNT", oe.endEmitted, oe.length), !oe.endEmitted && oe.length === 0 && (oe.endEmitted = !0, A.readable = !1, A.emit("end"), oe.autoDestroy)) {
      var re = A._writableState;
      (!re || re.autoDestroy && re.finished) && A.destroy();
    }
  }
  typeof Symbol == "function" && (q.from = function(oe, A) {
    return fe === void 0 && (fe = requireFromBrowser$1()), fe(q, oe, A);
  });
  function Ue(oe, A) {
    for (var re = 0, le = oe.length; re < le; re++)
      if (oe[re] === A)
        return re;
    return -1;
  }
  return _stream_readable$1;
}
var _stream_transform$1 = Transform$9, _require$codes$3 = errorsBrowser$1.codes, ERR_METHOD_NOT_IMPLEMENTED$1 = _require$codes$3.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK$1 = _require$codes$3.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING$1 = _require$codes$3.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0$1 = _require$codes$3.ERR_TRANSFORM_WITH_LENGTH_0, Duplex$1 = require_stream_duplex$1();
inherits_browserExports(Transform$9, Duplex$1);
function afterTransform$1(a, u) {
  var c = this._transformState;
  c.transforming = !1;
  var l = c.writecb;
  if (l === null)
    return this.emit("error", new ERR_MULTIPLE_CALLBACK$1());
  c.writechunk = null, c.writecb = null, u != null && this.push(u), l(a);
  var v = this._readableState;
  v.reading = !1, (v.needReadable || v.length < v.highWaterMark) && this._read(v.highWaterMark);
}
function Transform$9(a) {
  if (!(this instanceof Transform$9))
    return new Transform$9(a);
  Duplex$1.call(this, a), this._transformState = {
    afterTransform: afterTransform$1.bind(this),
    needTransform: !1,
    transforming: !1,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }, this._readableState.needReadable = !0, this._readableState.sync = !1, a && (typeof a.transform == "function" && (this._transform = a.transform), typeof a.flush == "function" && (this._flush = a.flush)), this.on("prefinish", prefinish$1);
}
function prefinish$1() {
  var a = this;
  typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(u, c) {
    done$1(a, u, c);
  }) : done$1(this, null, null);
}
Transform$9.prototype.push = function(a, u) {
  return this._transformState.needTransform = !1, Duplex$1.prototype.push.call(this, a, u);
};
Transform$9.prototype._transform = function(a, u, c) {
  c(new ERR_METHOD_NOT_IMPLEMENTED$1("_transform()"));
};
Transform$9.prototype._write = function(a, u, c) {
  var l = this._transformState;
  if (l.writecb = c, l.writechunk = a, l.writeencoding = u, !l.transforming) {
    var v = this._readableState;
    (l.needTransform || v.needReadable || v.length < v.highWaterMark) && this._read(v.highWaterMark);
  }
};
Transform$9.prototype._read = function(a) {
  var u = this._transformState;
  u.writechunk !== null && !u.transforming ? (u.transforming = !0, this._transform(u.writechunk, u.writeencoding, u.afterTransform)) : u.needTransform = !0;
};
Transform$9.prototype._destroy = function(a, u) {
  Duplex$1.prototype._destroy.call(this, a, function(c) {
    u(c);
  });
};
function done$1(a, u, c) {
  if (u)
    return a.emit("error", u);
  if (c != null && a.push(c), a._writableState.length)
    throw new ERR_TRANSFORM_WITH_LENGTH_0$1();
  if (a._transformState.transforming)
    throw new ERR_TRANSFORM_ALREADY_TRANSFORMING$1();
  return a.push(null);
}
var _stream_passthrough$1 = PassThrough$1, Transform$8 = _stream_transform$1;
inherits_browserExports(PassThrough$1, Transform$8);
function PassThrough$1(a) {
  if (!(this instanceof PassThrough$1))
    return new PassThrough$1(a);
  Transform$8.call(this, a);
}
PassThrough$1.prototype._transform = function(a, u, c) {
  c(null, a);
};
var eos$2;
function once$4(a) {
  var u = !1;
  return function() {
    u || (u = !0, a.apply(void 0, arguments));
  };
}
var _require$codes$2 = errorsBrowser$1.codes, ERR_MISSING_ARGS$1 = _require$codes$2.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED$1 = _require$codes$2.ERR_STREAM_DESTROYED;
function noop$3(a) {
  if (a)
    throw a;
}
function isRequest$2(a) {
  return a.setHeader && typeof a.abort == "function";
}
function destroyer$1(a, u, c, l) {
  l = once$4(l);
  var v = !1;
  a.on("close", function() {
    v = !0;
  }), eos$2 === void 0 && (eos$2 = endOfStream$1), eos$2(a, {
    readable: u,
    writable: c
  }, function(_) {
    if (_)
      return l(_);
    v = !0, l();
  });
  var p = !1;
  return function(_) {
    if (!v && !p) {
      if (p = !0, isRequest$2(a))
        return a.abort();
      if (typeof a.destroy == "function")
        return a.destroy();
      l(_ || new ERR_STREAM_DESTROYED$1("pipe"));
    }
  };
}
function call$1(a) {
  a();
}
function pipe$1(a, u) {
  return a.pipe(u);
}
function popCallback$1(a) {
  return !a.length || typeof a[a.length - 1] != "function" ? noop$3 : a.pop();
}
function pipeline$1() {
  for (var a = arguments.length, u = new Array(a), c = 0; c < a; c++)
    u[c] = arguments[c];
  var l = popCallback$1(u);
  if (Array.isArray(u[0]) && (u = u[0]), u.length < 2)
    throw new ERR_MISSING_ARGS$1("streams");
  var v, p = u.map(function(_, k) {
    var O = k < u.length - 1, D = k > 0;
    return destroyer$1(_, O, D, function(F) {
      v || (v = F), F && p.forEach(call$1), !O && (p.forEach(call$1), l(v));
    });
  });
  return u.reduce(pipe$1);
}
var pipeline_1$1 = pipeline$1;
(function(a, u) {
  u = a.exports = require_stream_readable$1(), u.Stream = u, u.Readable = u, u.Writable = require_stream_writable$1(), u.Duplex = require_stream_duplex$1(), u.Transform = _stream_transform$1, u.PassThrough = _stream_passthrough$1, u.finished = endOfStream$1, u.pipeline = pipeline_1$1;
})(readableBrowser$1, readableBrowser$1.exports);
var readableBrowserExports$1 = readableBrowser$1.exports, Buffer$H = safeBufferExports$1.Buffer, Transform$7 = readableBrowserExports$1.Transform, inherits$u = inherits_browserExports;
function throwIfNotStringOrBuffer(a, u) {
  if (!Buffer$H.isBuffer(a) && typeof a != "string")
    throw new TypeError(u + " must be a string or a buffer");
}
function HashBase$2(a) {
  Transform$7.call(this), this._block = Buffer$H.allocUnsafe(a), this._blockSize = a, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = !1;
}
inherits$u(HashBase$2, Transform$7);
HashBase$2.prototype._transform = function(a, u, c) {
  var l = null;
  try {
    this.update(a, u);
  } catch (v) {
    l = v;
  }
  c(l);
};
HashBase$2.prototype._flush = function(a) {
  var u = null;
  try {
    this.push(this.digest());
  } catch (c) {
    u = c;
  }
  a(u);
};
HashBase$2.prototype.update = function(a, u) {
  if (throwIfNotStringOrBuffer(a, "Data"), this._finalized)
    throw new Error("Digest already called");
  Buffer$H.isBuffer(a) || (a = Buffer$H.from(a, u));
  for (var c = this._block, l = 0; this._blockOffset + a.length - l >= this._blockSize; ) {
    for (var v = this._blockOffset; v < this._blockSize; )
      c[v++] = a[l++];
    this._update(), this._blockOffset = 0;
  }
  for (; l < a.length; )
    c[this._blockOffset++] = a[l++];
  for (var p = 0, _ = a.length * 8; _ > 0; ++p)
    this._length[p] += _, _ = this._length[p] / 4294967296 | 0, _ > 0 && (this._length[p] -= 4294967296 * _);
  return this;
};
HashBase$2.prototype._update = function() {
  throw new Error("_update is not implemented");
};
HashBase$2.prototype.digest = function(a) {
  if (this._finalized)
    throw new Error("Digest already called");
  this._finalized = !0;
  var u = this._digest();
  a !== void 0 && (u = u.toString(a)), this._block.fill(0), this._blockOffset = 0;
  for (var c = 0; c < 4; ++c)
    this._length[c] = 0;
  return u;
};
HashBase$2.prototype._digest = function() {
  throw new Error("_digest is not implemented");
};
var hashBase = HashBase$2, inherits$t = inherits_browserExports, HashBase$1 = hashBase, Buffer$G = safeBufferExports$3.Buffer, ARRAY16$1 = new Array(16);
function MD5$3() {
  HashBase$1.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
}
inherits$t(MD5$3, HashBase$1);
MD5$3.prototype._update = function() {
  for (var a = ARRAY16$1, u = 0; u < 16; ++u)
    a[u] = this._block.readInt32LE(u * 4);
  var c = this._a, l = this._b, v = this._c, p = this._d;
  c = fnF(c, l, v, p, a[0], 3614090360, 7), p = fnF(p, c, l, v, a[1], 3905402710, 12), v = fnF(v, p, c, l, a[2], 606105819, 17), l = fnF(l, v, p, c, a[3], 3250441966, 22), c = fnF(c, l, v, p, a[4], 4118548399, 7), p = fnF(p, c, l, v, a[5], 1200080426, 12), v = fnF(v, p, c, l, a[6], 2821735955, 17), l = fnF(l, v, p, c, a[7], 4249261313, 22), c = fnF(c, l, v, p, a[8], 1770035416, 7), p = fnF(p, c, l, v, a[9], 2336552879, 12), v = fnF(v, p, c, l, a[10], 4294925233, 17), l = fnF(l, v, p, c, a[11], 2304563134, 22), c = fnF(c, l, v, p, a[12], 1804603682, 7), p = fnF(p, c, l, v, a[13], 4254626195, 12), v = fnF(v, p, c, l, a[14], 2792965006, 17), l = fnF(l, v, p, c, a[15], 1236535329, 22), c = fnG(c, l, v, p, a[1], 4129170786, 5), p = fnG(p, c, l, v, a[6], 3225465664, 9), v = fnG(v, p, c, l, a[11], 643717713, 14), l = fnG(l, v, p, c, a[0], 3921069994, 20), c = fnG(c, l, v, p, a[5], 3593408605, 5), p = fnG(p, c, l, v, a[10], 38016083, 9), v = fnG(v, p, c, l, a[15], 3634488961, 14), l = fnG(l, v, p, c, a[4], 3889429448, 20), c = fnG(c, l, v, p, a[9], 568446438, 5), p = fnG(p, c, l, v, a[14], 3275163606, 9), v = fnG(v, p, c, l, a[3], 4107603335, 14), l = fnG(l, v, p, c, a[8], 1163531501, 20), c = fnG(c, l, v, p, a[13], 2850285829, 5), p = fnG(p, c, l, v, a[2], 4243563512, 9), v = fnG(v, p, c, l, a[7], 1735328473, 14), l = fnG(l, v, p, c, a[12], 2368359562, 20), c = fnH(c, l, v, p, a[5], 4294588738, 4), p = fnH(p, c, l, v, a[8], 2272392833, 11), v = fnH(v, p, c, l, a[11], 1839030562, 16), l = fnH(l, v, p, c, a[14], 4259657740, 23), c = fnH(c, l, v, p, a[1], 2763975236, 4), p = fnH(p, c, l, v, a[4], 1272893353, 11), v = fnH(v, p, c, l, a[7], 4139469664, 16), l = fnH(l, v, p, c, a[10], 3200236656, 23), c = fnH(c, l, v, p, a[13], 681279174, 4), p = fnH(p, c, l, v, a[0], 3936430074, 11), v = fnH(v, p, c, l, a[3], 3572445317, 16), l = fnH(l, v, p, c, a[6], 76029189, 23), c = fnH(c, l, v, p, a[9], 3654602809, 4), p = fnH(p, c, l, v, a[12], 3873151461, 11), v = fnH(v, p, c, l, a[15], 530742520, 16), l = fnH(l, v, p, c, a[2], 3299628645, 23), c = fnI(c, l, v, p, a[0], 4096336452, 6), p = fnI(p, c, l, v, a[7], 1126891415, 10), v = fnI(v, p, c, l, a[14], 2878612391, 15), l = fnI(l, v, p, c, a[5], 4237533241, 21), c = fnI(c, l, v, p, a[12], 1700485571, 6), p = fnI(p, c, l, v, a[3], 2399980690, 10), v = fnI(v, p, c, l, a[10], 4293915773, 15), l = fnI(l, v, p, c, a[1], 2240044497, 21), c = fnI(c, l, v, p, a[8], 1873313359, 6), p = fnI(p, c, l, v, a[15], 4264355552, 10), v = fnI(v, p, c, l, a[6], 2734768916, 15), l = fnI(l, v, p, c, a[13], 1309151649, 21), c = fnI(c, l, v, p, a[4], 4149444226, 6), p = fnI(p, c, l, v, a[11], 3174756917, 10), v = fnI(v, p, c, l, a[2], 718787259, 15), l = fnI(l, v, p, c, a[9], 3951481745, 21), this._a = this._a + c | 0, this._b = this._b + l | 0, this._c = this._c + v | 0, this._d = this._d + p | 0;
};
MD5$3.prototype._digest = function() {
  this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
  var a = Buffer$G.allocUnsafe(16);
  return a.writeInt32LE(this._a, 0), a.writeInt32LE(this._b, 4), a.writeInt32LE(this._c, 8), a.writeInt32LE(this._d, 12), a;
};
function rotl$1(a, u) {
  return a << u | a >>> 32 - u;
}
function fnF(a, u, c, l, v, p, _) {
  return rotl$1(a + (u & c | ~u & l) + v + p | 0, _) + u | 0;
}
function fnG(a, u, c, l, v, p, _) {
  return rotl$1(a + (u & l | c & ~l) + v + p | 0, _) + u | 0;
}
function fnH(a, u, c, l, v, p, _) {
  return rotl$1(a + (u ^ c ^ l) + v + p | 0, _) + u | 0;
}
function fnI(a, u, c, l, v, p, _) {
  return rotl$1(a + (c ^ (u | ~l)) + v + p | 0, _) + u | 0;
}
var md5_js = MD5$3, Buffer$F = require$$0$2.Buffer, inherits$s = inherits_browserExports, HashBase = hashBase, ARRAY16 = new Array(16), zl = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
], zr = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
], sl = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
], sr = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
], hl = [0, 1518500249, 1859775393, 2400959708, 2840853838], hr = [1352829926, 1548603684, 1836072691, 2053994217, 0];
function RIPEMD160$4() {
  HashBase.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
}
inherits$s(RIPEMD160$4, HashBase);
RIPEMD160$4.prototype._update = function() {
  for (var a = ARRAY16, u = 0; u < 16; ++u)
    a[u] = this._block.readInt32LE(u * 4);
  for (var c = this._a | 0, l = this._b | 0, v = this._c | 0, p = this._d | 0, _ = this._e | 0, k = this._a | 0, O = this._b | 0, D = this._c | 0, F = this._d | 0, z = this._e | 0, j = 0; j < 80; j += 1) {
    var ee, X;
    j < 16 ? (ee = fn1(c, l, v, p, _, a[zl[j]], hl[0], sl[j]), X = fn5(k, O, D, F, z, a[zr[j]], hr[0], sr[j])) : j < 32 ? (ee = fn2(c, l, v, p, _, a[zl[j]], hl[1], sl[j]), X = fn4(k, O, D, F, z, a[zr[j]], hr[1], sr[j])) : j < 48 ? (ee = fn3(c, l, v, p, _, a[zl[j]], hl[2], sl[j]), X = fn3(k, O, D, F, z, a[zr[j]], hr[2], sr[j])) : j < 64 ? (ee = fn4(c, l, v, p, _, a[zl[j]], hl[3], sl[j]), X = fn2(k, O, D, F, z, a[zr[j]], hr[3], sr[j])) : (ee = fn5(c, l, v, p, _, a[zl[j]], hl[4], sl[j]), X = fn1(k, O, D, F, z, a[zr[j]], hr[4], sr[j])), c = _, _ = p, p = rotl(v, 10), v = l, l = ee, k = z, z = F, F = rotl(D, 10), D = O, O = X;
  }
  var ae = this._b + v + F | 0;
  this._b = this._c + p + z | 0, this._c = this._d + _ + k | 0, this._d = this._e + c + O | 0, this._e = this._a + l + D | 0, this._a = ae;
};
RIPEMD160$4.prototype._digest = function() {
  this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
  var a = Buffer$F.alloc ? Buffer$F.alloc(20) : new Buffer$F(20);
  return a.writeInt32LE(this._a, 0), a.writeInt32LE(this._b, 4), a.writeInt32LE(this._c, 8), a.writeInt32LE(this._d, 12), a.writeInt32LE(this._e, 16), a;
};
function rotl(a, u) {
  return a << u | a >>> 32 - u;
}
function fn1(a, u, c, l, v, p, _, k) {
  return rotl(a + (u ^ c ^ l) + p + _ | 0, k) + v | 0;
}
function fn2(a, u, c, l, v, p, _, k) {
  return rotl(a + (u & c | ~u & l) + p + _ | 0, k) + v | 0;
}
function fn3(a, u, c, l, v, p, _, k) {
  return rotl(a + ((u | ~c) ^ l) + p + _ | 0, k) + v | 0;
}
function fn4(a, u, c, l, v, p, _, k) {
  return rotl(a + (u & l | c & ~l) + p + _ | 0, k) + v | 0;
}
function fn5(a, u, c, l, v, p, _, k) {
  return rotl(a + (u ^ (c | ~l)) + p + _ | 0, k) + v | 0;
}
var ripemd160 = RIPEMD160$4, sha_js = { exports: {} }, Buffer$E = safeBufferExports$3.Buffer;
function Hash$7(a, u) {
  this._block = Buffer$E.alloc(a), this._finalSize = u, this._blockSize = a, this._len = 0;
}
Hash$7.prototype.update = function(a, u) {
  typeof a == "string" && (u = u || "utf8", a = Buffer$E.from(a, u));
  for (var c = this._block, l = this._blockSize, v = a.length, p = this._len, _ = 0; _ < v; ) {
    for (var k = p % l, O = Math.min(v - _, l - k), D = 0; D < O; D++)
      c[k + D] = a[_ + D];
    p += O, _ += O, p % l === 0 && this._update(c);
  }
  return this._len += v, this;
};
Hash$7.prototype.digest = function(a) {
  var u = this._len % this._blockSize;
  this._block[u] = 128, this._block.fill(0, u + 1), u >= this._finalSize && (this._update(this._block), this._block.fill(0));
  var c = this._len * 8;
  if (c <= 4294967295)
    this._block.writeUInt32BE(c, this._blockSize - 4);
  else {
    var l = (c & 4294967295) >>> 0, v = (c - l) / 4294967296;
    this._block.writeUInt32BE(v, this._blockSize - 8), this._block.writeUInt32BE(l, this._blockSize - 4);
  }
  this._update(this._block);
  var p = this._hash();
  return a ? p.toString(a) : p;
};
Hash$7.prototype._update = function() {
  throw new Error("_update must be implemented by subclass");
};
var hash$3 = Hash$7, inherits$r = inherits_browserExports, Hash$6 = hash$3, Buffer$D = safeBufferExports$3.Buffer, K$4 = [
  1518500249,
  1859775393,
  -1894007588,
  -899497514
], W$5 = new Array(80);
function Sha() {
  this.init(), this._w = W$5, Hash$6.call(this, 64, 56);
}
inherits$r(Sha, Hash$6);
Sha.prototype.init = function() {
  return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
};
function rotl5$1(a) {
  return a << 5 | a >>> 27;
}
function rotl30$1(a) {
  return a << 30 | a >>> 2;
}
function ft$1(a, u, c, l) {
  return a === 0 ? u & c | ~u & l : a === 2 ? u & c | u & l | c & l : u ^ c ^ l;
}
Sha.prototype._update = function(a) {
  for (var u = this._w, c = this._a | 0, l = this._b | 0, v = this._c | 0, p = this._d | 0, _ = this._e | 0, k = 0; k < 16; ++k)
    u[k] = a.readInt32BE(k * 4);
  for (; k < 80; ++k)
    u[k] = u[k - 3] ^ u[k - 8] ^ u[k - 14] ^ u[k - 16];
  for (var O = 0; O < 80; ++O) {
    var D = ~~(O / 20), F = rotl5$1(c) + ft$1(D, l, v, p) + _ + u[O] + K$4[D] | 0;
    _ = p, p = v, v = rotl30$1(l), l = c, c = F;
  }
  this._a = c + this._a | 0, this._b = l + this._b | 0, this._c = v + this._c | 0, this._d = p + this._d | 0, this._e = _ + this._e | 0;
};
Sha.prototype._hash = function() {
  var a = Buffer$D.allocUnsafe(20);
  return a.writeInt32BE(this._a | 0, 0), a.writeInt32BE(this._b | 0, 4), a.writeInt32BE(this._c | 0, 8), a.writeInt32BE(this._d | 0, 12), a.writeInt32BE(this._e | 0, 16), a;
};
var sha$4 = Sha, inherits$q = inherits_browserExports, Hash$5 = hash$3, Buffer$C = safeBufferExports$3.Buffer, K$3 = [
  1518500249,
  1859775393,
  -1894007588,
  -899497514
], W$4 = new Array(80);
function Sha1() {
  this.init(), this._w = W$4, Hash$5.call(this, 64, 56);
}
inherits$q(Sha1, Hash$5);
Sha1.prototype.init = function() {
  return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
};
function rotl1(a) {
  return a << 1 | a >>> 31;
}
function rotl5(a) {
  return a << 5 | a >>> 27;
}
function rotl30(a) {
  return a << 30 | a >>> 2;
}
function ft(a, u, c, l) {
  return a === 0 ? u & c | ~u & l : a === 2 ? u & c | u & l | c & l : u ^ c ^ l;
}
Sha1.prototype._update = function(a) {
  for (var u = this._w, c = this._a | 0, l = this._b | 0, v = this._c | 0, p = this._d | 0, _ = this._e | 0, k = 0; k < 16; ++k)
    u[k] = a.readInt32BE(k * 4);
  for (; k < 80; ++k)
    u[k] = rotl1(u[k - 3] ^ u[k - 8] ^ u[k - 14] ^ u[k - 16]);
  for (var O = 0; O < 80; ++O) {
    var D = ~~(O / 20), F = rotl5(c) + ft(D, l, v, p) + _ + u[O] + K$3[D] | 0;
    _ = p, p = v, v = rotl30(l), l = c, c = F;
  }
  this._a = c + this._a | 0, this._b = l + this._b | 0, this._c = v + this._c | 0, this._d = p + this._d | 0, this._e = _ + this._e | 0;
};
Sha1.prototype._hash = function() {
  var a = Buffer$C.allocUnsafe(20);
  return a.writeInt32BE(this._a | 0, 0), a.writeInt32BE(this._b | 0, 4), a.writeInt32BE(this._c | 0, 8), a.writeInt32BE(this._d | 0, 12), a.writeInt32BE(this._e | 0, 16), a;
};
var sha1 = Sha1, inherits$p = inherits_browserExports, Hash$4 = hash$3, Buffer$B = safeBufferExports$3.Buffer, K$2 = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
], W$3 = new Array(64);
function Sha256$1() {
  this.init(), this._w = W$3, Hash$4.call(this, 64, 56);
}
inherits$p(Sha256$1, Hash$4);
Sha256$1.prototype.init = function() {
  return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
};
function ch(a, u, c) {
  return c ^ a & (u ^ c);
}
function maj$1(a, u, c) {
  return a & u | c & (a | u);
}
function sigma0$1(a) {
  return (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10);
}
function sigma1$1(a) {
  return (a >>> 6 | a << 26) ^ (a >>> 11 | a << 21) ^ (a >>> 25 | a << 7);
}
function gamma0(a) {
  return (a >>> 7 | a << 25) ^ (a >>> 18 | a << 14) ^ a >>> 3;
}
function gamma1(a) {
  return (a >>> 17 | a << 15) ^ (a >>> 19 | a << 13) ^ a >>> 10;
}
Sha256$1.prototype._update = function(a) {
  for (var u = this._w, c = this._a | 0, l = this._b | 0, v = this._c | 0, p = this._d | 0, _ = this._e | 0, k = this._f | 0, O = this._g | 0, D = this._h | 0, F = 0; F < 16; ++F)
    u[F] = a.readInt32BE(F * 4);
  for (; F < 64; ++F)
    u[F] = gamma1(u[F - 2]) + u[F - 7] + gamma0(u[F - 15]) + u[F - 16] | 0;
  for (var z = 0; z < 64; ++z) {
    var j = D + sigma1$1(_) + ch(_, k, O) + K$2[z] + u[z] | 0, ee = sigma0$1(c) + maj$1(c, l, v) | 0;
    D = O, O = k, k = _, _ = p + j | 0, p = v, v = l, l = c, c = j + ee | 0;
  }
  this._a = c + this._a | 0, this._b = l + this._b | 0, this._c = v + this._c | 0, this._d = p + this._d | 0, this._e = _ + this._e | 0, this._f = k + this._f | 0, this._g = O + this._g | 0, this._h = D + this._h | 0;
};
Sha256$1.prototype._hash = function() {
  var a = Buffer$B.allocUnsafe(32);
  return a.writeInt32BE(this._a, 0), a.writeInt32BE(this._b, 4), a.writeInt32BE(this._c, 8), a.writeInt32BE(this._d, 12), a.writeInt32BE(this._e, 16), a.writeInt32BE(this._f, 20), a.writeInt32BE(this._g, 24), a.writeInt32BE(this._h, 28), a;
};
var sha256$1 = Sha256$1, inherits$o = inherits_browserExports, Sha256 = sha256$1, Hash$3 = hash$3, Buffer$A = safeBufferExports$3.Buffer, W$2 = new Array(64);
function Sha224() {
  this.init(), this._w = W$2, Hash$3.call(this, 64, 56);
}
inherits$o(Sha224, Sha256);
Sha224.prototype.init = function() {
  return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
};
Sha224.prototype._hash = function() {
  var a = Buffer$A.allocUnsafe(28);
  return a.writeInt32BE(this._a, 0), a.writeInt32BE(this._b, 4), a.writeInt32BE(this._c, 8), a.writeInt32BE(this._d, 12), a.writeInt32BE(this._e, 16), a.writeInt32BE(this._f, 20), a.writeInt32BE(this._g, 24), a;
};
var sha224$1 = Sha224, inherits$n = inherits_browserExports, Hash$2 = hash$3, Buffer$z = safeBufferExports$3.Buffer, K$1 = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
], W$1 = new Array(160);
function Sha512() {
  this.init(), this._w = W$1, Hash$2.call(this, 128, 112);
}
inherits$n(Sha512, Hash$2);
Sha512.prototype.init = function() {
  return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
};
function Ch(a, u, c) {
  return c ^ a & (u ^ c);
}
function maj(a, u, c) {
  return a & u | c & (a | u);
}
function sigma0(a, u) {
  return (a >>> 28 | u << 4) ^ (u >>> 2 | a << 30) ^ (u >>> 7 | a << 25);
}
function sigma1(a, u) {
  return (a >>> 14 | u << 18) ^ (a >>> 18 | u << 14) ^ (u >>> 9 | a << 23);
}
function Gamma0(a, u) {
  return (a >>> 1 | u << 31) ^ (a >>> 8 | u << 24) ^ a >>> 7;
}
function Gamma0l(a, u) {
  return (a >>> 1 | u << 31) ^ (a >>> 8 | u << 24) ^ (a >>> 7 | u << 25);
}
function Gamma1(a, u) {
  return (a >>> 19 | u << 13) ^ (u >>> 29 | a << 3) ^ a >>> 6;
}
function Gamma1l(a, u) {
  return (a >>> 19 | u << 13) ^ (u >>> 29 | a << 3) ^ (a >>> 6 | u << 26);
}
function getCarry(a, u) {
  return a >>> 0 < u >>> 0 ? 1 : 0;
}
Sha512.prototype._update = function(a) {
  for (var u = this._w, c = this._ah | 0, l = this._bh | 0, v = this._ch | 0, p = this._dh | 0, _ = this._eh | 0, k = this._fh | 0, O = this._gh | 0, D = this._hh | 0, F = this._al | 0, z = this._bl | 0, j = this._cl | 0, ee = this._dl | 0, X = this._el | 0, ae = this._fl | 0, Q = this._gl | 0, ne = this._hl | 0, Z = 0; Z < 32; Z += 2)
    u[Z] = a.readInt32BE(Z * 4), u[Z + 1] = a.readInt32BE(Z * 4 + 4);
  for (; Z < 160; Z += 2) {
    var de = u[Z - 30], fe = u[Z - 15 * 2 + 1], Te = Gamma0(de, fe), Re = Gamma0l(fe, de);
    de = u[Z - 2 * 2], fe = u[Z - 2 * 2 + 1];
    var Le = Gamma1(de, fe), be = Gamma1l(fe, de), q = u[Z - 7 * 2], J = u[Z - 7 * 2 + 1], C = u[Z - 16 * 2], S = u[Z - 16 * 2 + 1], E = Re + J | 0, I = Te + q + getCarry(E, Re) | 0;
    E = E + be | 0, I = I + Le + getCarry(E, be) | 0, E = E + S | 0, I = I + C + getCarry(E, S) | 0, u[Z] = I, u[Z + 1] = E;
  }
  for (var M = 0; M < 160; M += 2) {
    I = u[M], E = u[M + 1];
    var $ = maj(c, l, v), U = maj(F, z, j), Y = sigma0(c, F), L = sigma0(F, c), T = sigma1(_, X), B = sigma1(X, _), te = K$1[M], pe = K$1[M + 1], Ie = Ch(_, k, O), $e = Ch(X, ae, Q), ve = ne + B | 0, he = D + T + getCarry(ve, ne) | 0;
    ve = ve + $e | 0, he = he + Ie + getCarry(ve, $e) | 0, ve = ve + pe | 0, he = he + te + getCarry(ve, pe) | 0, ve = ve + E | 0, he = he + I + getCarry(ve, E) | 0;
    var Oe = L + U | 0, Ae = Y + $ + getCarry(Oe, L) | 0;
    D = O, ne = Q, O = k, Q = ae, k = _, ae = X, X = ee + ve | 0, _ = p + he + getCarry(X, ee) | 0, p = v, ee = j, v = l, j = z, l = c, z = F, F = ve + Oe | 0, c = he + Ae + getCarry(F, ve) | 0;
  }
  this._al = this._al + F | 0, this._bl = this._bl + z | 0, this._cl = this._cl + j | 0, this._dl = this._dl + ee | 0, this._el = this._el + X | 0, this._fl = this._fl + ae | 0, this._gl = this._gl + Q | 0, this._hl = this._hl + ne | 0, this._ah = this._ah + c + getCarry(this._al, F) | 0, this._bh = this._bh + l + getCarry(this._bl, z) | 0, this._ch = this._ch + v + getCarry(this._cl, j) | 0, this._dh = this._dh + p + getCarry(this._dl, ee) | 0, this._eh = this._eh + _ + getCarry(this._el, X) | 0, this._fh = this._fh + k + getCarry(this._fl, ae) | 0, this._gh = this._gh + O + getCarry(this._gl, Q) | 0, this._hh = this._hh + D + getCarry(this._hl, ne) | 0;
};
Sha512.prototype._hash = function() {
  var a = Buffer$z.allocUnsafe(64);
  function u(c, l, v) {
    a.writeInt32BE(c, v), a.writeInt32BE(l, v + 4);
  }
  return u(this._ah, this._al, 0), u(this._bh, this._bl, 8), u(this._ch, this._cl, 16), u(this._dh, this._dl, 24), u(this._eh, this._el, 32), u(this._fh, this._fl, 40), u(this._gh, this._gl, 48), u(this._hh, this._hl, 56), a;
};
var sha512$1 = Sha512, inherits$m = inherits_browserExports, SHA512$2 = sha512$1, Hash$1 = hash$3, Buffer$y = safeBufferExports$3.Buffer, W = new Array(160);
function Sha384() {
  this.init(), this._w = W, Hash$1.call(this, 128, 112);
}
inherits$m(Sha384, SHA512$2);
Sha384.prototype.init = function() {
  return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
};
Sha384.prototype._hash = function() {
  var a = Buffer$y.allocUnsafe(48);
  function u(c, l, v) {
    a.writeInt32BE(c, v), a.writeInt32BE(l, v + 4);
  }
  return u(this._ah, this._al, 0), u(this._bh, this._bl, 8), u(this._ch, this._cl, 16), u(this._dh, this._dl, 24), u(this._eh, this._el, 32), u(this._fh, this._fl, 40), a;
};
var sha384$1 = Sha384, exports$1 = sha_js.exports = function a(u) {
  u = u.toLowerCase();
  var c = exports$1[u];
  if (!c)
    throw new Error(u + " is not supported (we accept pull requests)");
  return new c();
};
exports$1.sha = sha$4;
exports$1.sha1 = sha1;
exports$1.sha224 = sha224$1;
exports$1.sha256 = sha256$1;
exports$1.sha384 = sha384$1;
exports$1.sha512 = sha512$1;
var sha_jsExports = sha_js.exports, Buffer$x = safeBufferExports$3.Buffer, Transform$6 = streamBrowserify.Transform, StringDecoder = string_decoder.StringDecoder, inherits$l = inherits_browserExports;
function CipherBase$1(a) {
  Transform$6.call(this), this.hashMode = typeof a == "string", this.hashMode ? this[a] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;
}
inherits$l(CipherBase$1, Transform$6);
CipherBase$1.prototype.update = function(a, u, c) {
  typeof a == "string" && (a = Buffer$x.from(a, u));
  var l = this._update(a);
  return this.hashMode ? this : (c && (l = this._toString(l, c)), l);
};
CipherBase$1.prototype.setAutoPadding = function() {
};
CipherBase$1.prototype.getAuthTag = function() {
  throw new Error("trying to get auth tag in unsupported state");
};
CipherBase$1.prototype.setAuthTag = function() {
  throw new Error("trying to set auth tag in unsupported state");
};
CipherBase$1.prototype.setAAD = function() {
  throw new Error("trying to set aad in unsupported state");
};
CipherBase$1.prototype._transform = function(a, u, c) {
  var l;
  try {
    this.hashMode ? this._update(a) : this.push(this._update(a));
  } catch (v) {
    l = v;
  } finally {
    c(l);
  }
};
CipherBase$1.prototype._flush = function(a) {
  var u;
  try {
    this.push(this.__final());
  } catch (c) {
    u = c;
  }
  a(u);
};
CipherBase$1.prototype._finalOrDigest = function(a) {
  var u = this.__final() || Buffer$x.alloc(0);
  return a && (u = this._toString(u, a, !0)), u;
};
CipherBase$1.prototype._toString = function(a, u, c) {
  if (this._decoder || (this._decoder = new StringDecoder(u), this._encoding = u), this._encoding !== u)
    throw new Error("can't switch encodings");
  var l = this._decoder.write(a);
  return c && (l += this._decoder.end()), l;
};
var cipherBase = CipherBase$1, inherits$k = inherits_browserExports, MD5$2 = md5_js, RIPEMD160$3 = ripemd160, sha$3 = sha_jsExports, Base$5 = cipherBase;
function Hash(a) {
  Base$5.call(this, "digest"), this._hash = a;
}
inherits$k(Hash, Base$5);
Hash.prototype._update = function(a) {
  this._hash.update(a);
};
Hash.prototype._final = function() {
  return this._hash.digest();
};
var browser$a = function a(u) {
  return u = u.toLowerCase(), u === "md5" ? new MD5$2() : u === "rmd160" || u === "ripemd160" ? new RIPEMD160$3() : new Hash(sha$3(u));
}, inherits$j = inherits_browserExports, Buffer$w = safeBufferExports$3.Buffer, Base$4 = cipherBase, ZEROS$2 = Buffer$w.alloc(128), blocksize = 64;
function Hmac$3(a, u) {
  Base$4.call(this, "digest"), typeof u == "string" && (u = Buffer$w.from(u)), this._alg = a, this._key = u, u.length > blocksize ? u = a(u) : u.length < blocksize && (u = Buffer$w.concat([u, ZEROS$2], blocksize));
  for (var c = this._ipad = Buffer$w.allocUnsafe(blocksize), l = this._opad = Buffer$w.allocUnsafe(blocksize), v = 0; v < blocksize; v++)
    c[v] = u[v] ^ 54, l[v] = u[v] ^ 92;
  this._hash = [c];
}
inherits$j(Hmac$3, Base$4);
Hmac$3.prototype._update = function(a) {
  this._hash.push(a);
};
Hmac$3.prototype._final = function() {
  var a = this._alg(Buffer$w.concat(this._hash));
  return this._alg(Buffer$w.concat([this._opad, a]));
};
var legacy = Hmac$3, MD5$1 = md5_js, md5$2 = function(a) {
  return new MD5$1().update(a).digest();
}, inherits$i = inherits_browserExports, Legacy = legacy, Base$3 = cipherBase, Buffer$v = safeBufferExports$3.Buffer, md5$1 = md5$2, RIPEMD160$2 = ripemd160, sha$2 = sha_jsExports, ZEROS$1 = Buffer$v.alloc(128);
function Hmac$2(a, u) {
  Base$3.call(this, "digest"), typeof u == "string" && (u = Buffer$v.from(u));
  var c = a === "sha512" || a === "sha384" ? 128 : 64;
  if (this._alg = a, this._key = u, u.length > c) {
    var l = a === "rmd160" ? new RIPEMD160$2() : sha$2(a);
    u = l.update(u).digest();
  } else
    u.length < c && (u = Buffer$v.concat([u, ZEROS$1], c));
  for (var v = this._ipad = Buffer$v.allocUnsafe(c), p = this._opad = Buffer$v.allocUnsafe(c), _ = 0; _ < c; _++)
    v[_] = u[_] ^ 54, p[_] = u[_] ^ 92;
  this._hash = a === "rmd160" ? new RIPEMD160$2() : sha$2(a), this._hash.update(v);
}
inherits$i(Hmac$2, Base$3);
Hmac$2.prototype._update = function(a) {
  this._hash.update(a);
};
Hmac$2.prototype._final = function() {
  var a = this._hash.digest(), u = this._alg === "rmd160" ? new RIPEMD160$2() : sha$2(this._alg);
  return u.update(this._opad).update(a).digest();
};
var browser$9 = function a(u, c) {
  return u = u.toLowerCase(), u === "rmd160" || u === "ripemd160" ? new Hmac$2("rmd160", c) : u === "md5" ? new Legacy(md5$1, c) : new Hmac$2(u, c);
};
const sha224WithRSAEncryption = {
  sign: "rsa",
  hash: "sha224",
  id: "302d300d06096086480165030402040500041c"
}, sha256WithRSAEncryption = {
  sign: "rsa",
  hash: "sha256",
  id: "3031300d060960864801650304020105000420"
}, sha384WithRSAEncryption = {
  sign: "rsa",
  hash: "sha384",
  id: "3041300d060960864801650304020205000430"
}, sha512WithRSAEncryption = {
  sign: "rsa",
  hash: "sha512",
  id: "3051300d060960864801650304020305000440"
}, sha256 = {
  sign: "ecdsa",
  hash: "sha256",
  id: ""
}, sha224 = {
  sign: "ecdsa",
  hash: "sha224",
  id: ""
}, sha384 = {
  sign: "ecdsa",
  hash: "sha384",
  id: ""
}, sha512 = {
  sign: "ecdsa",
  hash: "sha512",
  id: ""
}, DSA = {
  sign: "dsa",
  hash: "sha1",
  id: ""
}, ripemd160WithRSA = {
  sign: "rsa",
  hash: "rmd160",
  id: "3021300906052b2403020105000414"
}, md5WithRSAEncryption = {
  sign: "rsa",
  hash: "md5",
  id: "3020300c06082a864886f70d020505000410"
}, require$$6 = {
  sha224WithRSAEncryption,
  "RSA-SHA224": {
    sign: "ecdsa/rsa",
    hash: "sha224",
    id: "302d300d06096086480165030402040500041c"
  },
  sha256WithRSAEncryption,
  "RSA-SHA256": {
    sign: "ecdsa/rsa",
    hash: "sha256",
    id: "3031300d060960864801650304020105000420"
  },
  sha384WithRSAEncryption,
  "RSA-SHA384": {
    sign: "ecdsa/rsa",
    hash: "sha384",
    id: "3041300d060960864801650304020205000430"
  },
  sha512WithRSAEncryption,
  "RSA-SHA512": {
    sign: "ecdsa/rsa",
    hash: "sha512",
    id: "3051300d060960864801650304020305000440"
  },
  "RSA-SHA1": {
    sign: "rsa",
    hash: "sha1",
    id: "3021300906052b0e03021a05000414"
  },
  "ecdsa-with-SHA1": {
    sign: "ecdsa",
    hash: "sha1",
    id: ""
  },
  sha256,
  sha224,
  sha384,
  sha512,
  "DSA-SHA": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  "DSA-SHA1": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  DSA,
  "DSA-WITH-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-WITH-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-WITH-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-WITH-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-RIPEMD160": {
    sign: "dsa",
    hash: "rmd160",
    id: ""
  },
  ripemd160WithRSA,
  "RSA-RIPEMD160": {
    sign: "rsa",
    hash: "rmd160",
    id: "3021300906052b2403020105000414"
  },
  md5WithRSAEncryption,
  "RSA-MD5": {
    sign: "rsa",
    hash: "md5",
    id: "3020300c06082a864886f70d020505000410"
  }
};
var algos = require$$6, browser$8 = {}, MAX_ALLOC = Math.pow(2, 30) - 1, precondition = function(a, u) {
  if (typeof a != "number")
    throw new TypeError("Iterations not a number");
  if (a < 0)
    throw new TypeError("Bad iterations");
  if (typeof u != "number")
    throw new TypeError("Key length not a number");
  if (u < 0 || u > MAX_ALLOC || u !== u)
    throw new TypeError("Bad key length");
}, defaultEncoding$2;
if (commonjsGlobal$1.process && commonjsGlobal$1.process.browser)
  defaultEncoding$2 = "utf-8";
else if (commonjsGlobal$1.process && commonjsGlobal$1.process.version) {
  var pVersionMajor = parseInt(process$1.version.split(".")[0].slice(1), 10);
  defaultEncoding$2 = pVersionMajor >= 6 ? "utf-8" : "binary";
} else
  defaultEncoding$2 = "utf-8";
var defaultEncoding_1 = defaultEncoding$2, Buffer$u = safeBufferExports$3.Buffer, toBuffer$2 = function(a, u, c) {
  if (Buffer$u.isBuffer(a))
    return a;
  if (typeof a == "string")
    return Buffer$u.from(a, u);
  if (ArrayBuffer.isView(a))
    return Buffer$u.from(a.buffer);
  throw new TypeError(c + " must be a string, a Buffer, a typed array or a DataView");
}, md5 = md5$2, RIPEMD160$1 = ripemd160, sha$1 = sha_jsExports, Buffer$t = safeBufferExports$3.Buffer, checkParameters$1 = precondition, defaultEncoding$1 = defaultEncoding_1, toBuffer$1 = toBuffer$2, ZEROS = Buffer$t.alloc(128), sizes = {
  md5: 16,
  sha1: 20,
  sha224: 28,
  sha256: 32,
  sha384: 48,
  sha512: 64,
  rmd160: 20,
  ripemd160: 20
};
function Hmac$1(a, u, c) {
  var l = getDigest(a), v = a === "sha512" || a === "sha384" ? 128 : 64;
  u.length > v ? u = l(u) : u.length < v && (u = Buffer$t.concat([u, ZEROS], v));
  for (var p = Buffer$t.allocUnsafe(v + sizes[a]), _ = Buffer$t.allocUnsafe(v + sizes[a]), k = 0; k < v; k++)
    p[k] = u[k] ^ 54, _[k] = u[k] ^ 92;
  var O = Buffer$t.allocUnsafe(v + c + 4);
  p.copy(O, 0, 0, v), this.ipad1 = O, this.ipad2 = p, this.opad = _, this.alg = a, this.blocksize = v, this.hash = l, this.size = sizes[a];
}
Hmac$1.prototype.run = function(a, u) {
  a.copy(u, this.blocksize);
  var c = this.hash(u);
  return c.copy(this.opad, this.blocksize), this.hash(this.opad);
};
function getDigest(a) {
  function u(l) {
    return sha$1(a).update(l).digest();
  }
  function c(l) {
    return new RIPEMD160$1().update(l).digest();
  }
  return a === "rmd160" || a === "ripemd160" ? c : a === "md5" ? md5 : u;
}
function pbkdf2(a, u, c, l, v) {
  checkParameters$1(c, l), a = toBuffer$1(a, defaultEncoding$1, "Password"), u = toBuffer$1(u, defaultEncoding$1, "Salt"), v = v || "sha1";
  var p = new Hmac$1(v, a, u.length), _ = Buffer$t.allocUnsafe(l), k = Buffer$t.allocUnsafe(u.length + 4);
  u.copy(k, 0, 0, u.length);
  for (var O = 0, D = sizes[v], F = Math.ceil(l / D), z = 1; z <= F; z++) {
    k.writeUInt32BE(z, u.length);
    for (var j = p.run(k, p.ipad1), ee = j, X = 1; X < c; X++) {
      ee = p.run(ee, p.ipad2);
      for (var ae = 0; ae < D; ae++)
        j[ae] ^= ee[ae];
    }
    j.copy(_, O), O += D;
  }
  return _;
}
var syncBrowser = pbkdf2, Buffer$s = safeBufferExports$3.Buffer, checkParameters = precondition, defaultEncoding = defaultEncoding_1, sync = syncBrowser, toBuffer = toBuffer$2, ZERO_BUF, subtle = commonjsGlobal$1.crypto && commonjsGlobal$1.crypto.subtle, toBrowser = {
  sha: "SHA-1",
  "sha-1": "SHA-1",
  sha1: "SHA-1",
  sha256: "SHA-256",
  "sha-256": "SHA-256",
  sha384: "SHA-384",
  "sha-384": "SHA-384",
  "sha-512": "SHA-512",
  sha512: "SHA-512"
}, checks = [];
function checkNative(a) {
  if (commonjsGlobal$1.process && !commonjsGlobal$1.process.browser || !subtle || !subtle.importKey || !subtle.deriveBits)
    return Promise.resolve(!1);
  if (checks[a] !== void 0)
    return checks[a];
  ZERO_BUF = ZERO_BUF || Buffer$s.alloc(8);
  var u = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, a).then(function() {
    return !0;
  }).catch(function() {
    return !1;
  });
  return checks[a] = u, u;
}
var nextTick$1;
function getNextTick() {
  return nextTick$1 || (commonjsGlobal$1.process && commonjsGlobal$1.process.nextTick ? nextTick$1 = commonjsGlobal$1.process.nextTick : commonjsGlobal$1.queueMicrotask ? nextTick$1 = commonjsGlobal$1.queueMicrotask : commonjsGlobal$1.setImmediate ? nextTick$1 = commonjsGlobal$1.setImmediate : nextTick$1 = commonjsGlobal$1.setTimeout, nextTick$1);
}
function browserPbkdf2(a, u, c, l, v) {
  return subtle.importKey(
    "raw",
    a,
    { name: "PBKDF2" },
    !1,
    ["deriveBits"]
  ).then(function(p) {
    return subtle.deriveBits({
      name: "PBKDF2",
      salt: u,
      iterations: c,
      hash: {
        name: v
      }
    }, p, l << 3);
  }).then(function(p) {
    return Buffer$s.from(p);
  });
}
function resolvePromise(a, u) {
  a.then(function(c) {
    getNextTick()(function() {
      u(null, c);
    });
  }, function(c) {
    getNextTick()(function() {
      u(c);
    });
  });
}
var async = function(a, u, c, l, v, p) {
  typeof v == "function" && (p = v, v = void 0), v = v || "sha1";
  var _ = toBrowser[v.toLowerCase()];
  if (!_ || typeof commonjsGlobal$1.Promise != "function") {
    getNextTick()(function() {
      var k;
      try {
        k = sync(a, u, c, l, v);
      } catch (O) {
        return p(O);
      }
      p(null, k);
    });
    return;
  }
  if (checkParameters(c, l), a = toBuffer(a, defaultEncoding, "Password"), u = toBuffer(u, defaultEncoding, "Salt"), typeof p != "function")
    throw new Error("No callback provided to pbkdf2");
  resolvePromise(checkNative(_).then(function(k) {
    return k ? browserPbkdf2(a, u, c, l, _) : sync(a, u, c, l, v);
  }), p);
};
browser$8.pbkdf2 = async;
browser$8.pbkdf2Sync = syncBrowser;
var browser$7 = {}, des$2 = {}, utils$x = {};
utils$x.readUInt32BE = function a(u, c) {
  var l = u[0 + c] << 24 | u[1 + c] << 16 | u[2 + c] << 8 | u[3 + c];
  return l >>> 0;
};
utils$x.writeUInt32BE = function a(u, c, l) {
  u[0 + l] = c >>> 24, u[1 + l] = c >>> 16 & 255, u[2 + l] = c >>> 8 & 255, u[3 + l] = c & 255;
};
utils$x.ip = function a(u, c, l, v) {
  for (var p = 0, _ = 0, k = 6; k >= 0; k -= 2) {
    for (var O = 0; O <= 24; O += 8)
      p <<= 1, p |= c >>> O + k & 1;
    for (var O = 0; O <= 24; O += 8)
      p <<= 1, p |= u >>> O + k & 1;
  }
  for (var k = 6; k >= 0; k -= 2) {
    for (var O = 1; O <= 25; O += 8)
      _ <<= 1, _ |= c >>> O + k & 1;
    for (var O = 1; O <= 25; O += 8)
      _ <<= 1, _ |= u >>> O + k & 1;
  }
  l[v + 0] = p >>> 0, l[v + 1] = _ >>> 0;
};
utils$x.rip = function a(u, c, l, v) {
  for (var p = 0, _ = 0, k = 0; k < 4; k++)
    for (var O = 24; O >= 0; O -= 8)
      p <<= 1, p |= c >>> O + k & 1, p <<= 1, p |= u >>> O + k & 1;
  for (var k = 4; k < 8; k++)
    for (var O = 24; O >= 0; O -= 8)
      _ <<= 1, _ |= c >>> O + k & 1, _ <<= 1, _ |= u >>> O + k & 1;
  l[v + 0] = p >>> 0, l[v + 1] = _ >>> 0;
};
utils$x.pc1 = function a(u, c, l, v) {
  for (var p = 0, _ = 0, k = 7; k >= 5; k--) {
    for (var O = 0; O <= 24; O += 8)
      p <<= 1, p |= c >> O + k & 1;
    for (var O = 0; O <= 24; O += 8)
      p <<= 1, p |= u >> O + k & 1;
  }
  for (var O = 0; O <= 24; O += 8)
    p <<= 1, p |= c >> O + k & 1;
  for (var k = 1; k <= 3; k++) {
    for (var O = 0; O <= 24; O += 8)
      _ <<= 1, _ |= c >> O + k & 1;
    for (var O = 0; O <= 24; O += 8)
      _ <<= 1, _ |= u >> O + k & 1;
  }
  for (var O = 0; O <= 24; O += 8)
    _ <<= 1, _ |= u >> O + k & 1;
  l[v + 0] = p >>> 0, l[v + 1] = _ >>> 0;
};
utils$x.r28shl = function a(u, c) {
  return u << c & 268435455 | u >>> 28 - c;
};
var pc2table = [
  // inL => outL
  14,
  11,
  17,
  4,
  27,
  23,
  25,
  0,
  13,
  22,
  7,
  18,
  5,
  9,
  16,
  24,
  2,
  20,
  12,
  21,
  1,
  8,
  15,
  26,
  // inR => outR
  15,
  4,
  25,
  19,
  9,
  1,
  26,
  16,
  5,
  11,
  23,
  8,
  12,
  7,
  17,
  0,
  22,
  3,
  10,
  14,
  6,
  20,
  27,
  24
];
utils$x.pc2 = function a(u, c, l, v) {
  for (var p = 0, _ = 0, k = pc2table.length >>> 1, O = 0; O < k; O++)
    p <<= 1, p |= u >>> pc2table[O] & 1;
  for (var O = k; O < pc2table.length; O++)
    _ <<= 1, _ |= c >>> pc2table[O] & 1;
  l[v + 0] = p >>> 0, l[v + 1] = _ >>> 0;
};
utils$x.expand = function a(u, c, l) {
  var v = 0, p = 0;
  v = (u & 1) << 5 | u >>> 27;
  for (var _ = 23; _ >= 15; _ -= 4)
    v <<= 6, v |= u >>> _ & 63;
  for (var _ = 11; _ >= 3; _ -= 4)
    p |= u >>> _ & 63, p <<= 6;
  p |= (u & 31) << 1 | u >>> 31, c[l + 0] = v >>> 0, c[l + 1] = p >>> 0;
};
var sTable = [
  14,
  0,
  4,
  15,
  13,
  7,
  1,
  4,
  2,
  14,
  15,
  2,
  11,
  13,
  8,
  1,
  3,
  10,
  10,
  6,
  6,
  12,
  12,
  11,
  5,
  9,
  9,
  5,
  0,
  3,
  7,
  8,
  4,
  15,
  1,
  12,
  14,
  8,
  8,
  2,
  13,
  4,
  6,
  9,
  2,
  1,
  11,
  7,
  15,
  5,
  12,
  11,
  9,
  3,
  7,
  14,
  3,
  10,
  10,
  0,
  5,
  6,
  0,
  13,
  15,
  3,
  1,
  13,
  8,
  4,
  14,
  7,
  6,
  15,
  11,
  2,
  3,
  8,
  4,
  14,
  9,
  12,
  7,
  0,
  2,
  1,
  13,
  10,
  12,
  6,
  0,
  9,
  5,
  11,
  10,
  5,
  0,
  13,
  14,
  8,
  7,
  10,
  11,
  1,
  10,
  3,
  4,
  15,
  13,
  4,
  1,
  2,
  5,
  11,
  8,
  6,
  12,
  7,
  6,
  12,
  9,
  0,
  3,
  5,
  2,
  14,
  15,
  9,
  10,
  13,
  0,
  7,
  9,
  0,
  14,
  9,
  6,
  3,
  3,
  4,
  15,
  6,
  5,
  10,
  1,
  2,
  13,
  8,
  12,
  5,
  7,
  14,
  11,
  12,
  4,
  11,
  2,
  15,
  8,
  1,
  13,
  1,
  6,
  10,
  4,
  13,
  9,
  0,
  8,
  6,
  15,
  9,
  3,
  8,
  0,
  7,
  11,
  4,
  1,
  15,
  2,
  14,
  12,
  3,
  5,
  11,
  10,
  5,
  14,
  2,
  7,
  12,
  7,
  13,
  13,
  8,
  14,
  11,
  3,
  5,
  0,
  6,
  6,
  15,
  9,
  0,
  10,
  3,
  1,
  4,
  2,
  7,
  8,
  2,
  5,
  12,
  11,
  1,
  12,
  10,
  4,
  14,
  15,
  9,
  10,
  3,
  6,
  15,
  9,
  0,
  0,
  6,
  12,
  10,
  11,
  1,
  7,
  13,
  13,
  8,
  15,
  9,
  1,
  4,
  3,
  5,
  14,
  11,
  5,
  12,
  2,
  7,
  8,
  2,
  4,
  14,
  2,
  14,
  12,
  11,
  4,
  2,
  1,
  12,
  7,
  4,
  10,
  7,
  11,
  13,
  6,
  1,
  8,
  5,
  5,
  0,
  3,
  15,
  15,
  10,
  13,
  3,
  0,
  9,
  14,
  8,
  9,
  6,
  4,
  11,
  2,
  8,
  1,
  12,
  11,
  7,
  10,
  1,
  13,
  14,
  7,
  2,
  8,
  13,
  15,
  6,
  9,
  15,
  12,
  0,
  5,
  9,
  6,
  10,
  3,
  4,
  0,
  5,
  14,
  3,
  12,
  10,
  1,
  15,
  10,
  4,
  15,
  2,
  9,
  7,
  2,
  12,
  6,
  9,
  8,
  5,
  0,
  6,
  13,
  1,
  3,
  13,
  4,
  14,
  14,
  0,
  7,
  11,
  5,
  3,
  11,
  8,
  9,
  4,
  14,
  3,
  15,
  2,
  5,
  12,
  2,
  9,
  8,
  5,
  12,
  15,
  3,
  10,
  7,
  11,
  0,
  14,
  4,
  1,
  10,
  7,
  1,
  6,
  13,
  0,
  11,
  8,
  6,
  13,
  4,
  13,
  11,
  0,
  2,
  11,
  14,
  7,
  15,
  4,
  0,
  9,
  8,
  1,
  13,
  10,
  3,
  14,
  12,
  3,
  9,
  5,
  7,
  12,
  5,
  2,
  10,
  15,
  6,
  8,
  1,
  6,
  1,
  6,
  4,
  11,
  11,
  13,
  13,
  8,
  12,
  1,
  3,
  4,
  7,
  10,
  14,
  7,
  10,
  9,
  15,
  5,
  6,
  0,
  8,
  15,
  0,
  14,
  5,
  2,
  9,
  3,
  2,
  12,
  13,
  1,
  2,
  15,
  8,
  13,
  4,
  8,
  6,
  10,
  15,
  3,
  11,
  7,
  1,
  4,
  10,
  12,
  9,
  5,
  3,
  6,
  14,
  11,
  5,
  0,
  0,
  14,
  12,
  9,
  7,
  2,
  7,
  2,
  11,
  1,
  4,
  14,
  1,
  7,
  9,
  4,
  12,
  10,
  14,
  8,
  2,
  13,
  0,
  15,
  6,
  12,
  10,
  9,
  13,
  0,
  15,
  3,
  3,
  5,
  5,
  6,
  8,
  11
];
utils$x.substitute = function a(u, c) {
  for (var l = 0, v = 0; v < 4; v++) {
    var p = u >>> 18 - v * 6 & 63, _ = sTable[v * 64 + p];
    l <<= 4, l |= _;
  }
  for (var v = 0; v < 4; v++) {
    var p = c >>> 18 - v * 6 & 63, _ = sTable[4 * 64 + v * 64 + p];
    l <<= 4, l |= _;
  }
  return l >>> 0;
};
var permuteTable = [
  16,
  25,
  12,
  11,
  3,
  20,
  4,
  15,
  31,
  17,
  9,
  6,
  27,
  14,
  1,
  22,
  30,
  24,
  8,
  18,
  0,
  5,
  29,
  23,
  13,
  19,
  2,
  26,
  10,
  21,
  28,
  7
];
utils$x.permute = function a(u) {
  for (var c = 0, l = 0; l < permuteTable.length; l++)
    c <<= 1, c |= u >>> permuteTable[l] & 1;
  return c >>> 0;
};
utils$x.padSplit = function a(u, c, l) {
  for (var v = u.toString(2); v.length < c; )
    v = "0" + v;
  for (var p = [], _ = 0; _ < c; _ += l)
    p.push(v.slice(_, _ + l));
  return p.join(" ");
};
var minimalisticAssert = assert$j;
function assert$j(a, u) {
  if (!a)
    throw new Error(u || "Assertion failed");
}
assert$j.equal = function a(u, c, l) {
  if (u != c)
    throw new Error(l || "Assertion failed: " + u + " != " + c);
};
var assert$i = minimalisticAssert;
function Cipher$3(a) {
  this.options = a, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0, this.padding = a.padding !== !1;
}
var cipher = Cipher$3;
Cipher$3.prototype._init = function a() {
};
Cipher$3.prototype.update = function a(u) {
  return u.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(u) : this._updateEncrypt(u);
};
Cipher$3.prototype._buffer = function a(u, c) {
  for (var l = Math.min(this.buffer.length - this.bufferOff, u.length - c), v = 0; v < l; v++)
    this.buffer[this.bufferOff + v] = u[c + v];
  return this.bufferOff += l, l;
};
Cipher$3.prototype._flushBuffer = function a(u, c) {
  return this._update(this.buffer, 0, u, c), this.bufferOff = 0, this.blockSize;
};
Cipher$3.prototype._updateEncrypt = function a(u) {
  var c = 0, l = 0, v = (this.bufferOff + u.length) / this.blockSize | 0, p = new Array(v * this.blockSize);
  this.bufferOff !== 0 && (c += this._buffer(u, c), this.bufferOff === this.buffer.length && (l += this._flushBuffer(p, l)));
  for (var _ = u.length - (u.length - c) % this.blockSize; c < _; c += this.blockSize)
    this._update(u, c, p, l), l += this.blockSize;
  for (; c < u.length; c++, this.bufferOff++)
    this.buffer[this.bufferOff] = u[c];
  return p;
};
Cipher$3.prototype._updateDecrypt = function a(u) {
  for (var c = 0, l = 0, v = Math.ceil((this.bufferOff + u.length) / this.blockSize) - 1, p = new Array(v * this.blockSize); v > 0; v--)
    c += this._buffer(u, c), l += this._flushBuffer(p, l);
  return c += this._buffer(u, c), p;
};
Cipher$3.prototype.final = function a(u) {
  var c;
  u && (c = this.update(u));
  var l;
  return this.type === "encrypt" ? l = this._finalEncrypt() : l = this._finalDecrypt(), c ? c.concat(l) : l;
};
Cipher$3.prototype._pad = function a(u, c) {
  if (c === 0)
    return !1;
  for (; c < u.length; )
    u[c++] = 0;
  return !0;
};
Cipher$3.prototype._finalEncrypt = function a() {
  if (!this._pad(this.buffer, this.bufferOff))
    return [];
  var u = new Array(this.blockSize);
  return this._update(this.buffer, 0, u, 0), u;
};
Cipher$3.prototype._unpad = function a(u) {
  return u;
};
Cipher$3.prototype._finalDecrypt = function a() {
  assert$i.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
  var u = new Array(this.blockSize);
  return this._flushBuffer(u, 0), this._unpad(u);
};
var assert$h = minimalisticAssert, inherits$h = inherits_browserExports, utils$w = utils$x, Cipher$2 = cipher;
function DESState() {
  this.tmp = new Array(2), this.keys = null;
}
function DES$3(a) {
  Cipher$2.call(this, a);
  var u = new DESState();
  this._desState = u, this.deriveKeys(u, a.key);
}
inherits$h(DES$3, Cipher$2);
var des$1 = DES$3;
DES$3.create = function a(u) {
  return new DES$3(u);
};
var shiftTable = [
  1,
  1,
  2,
  2,
  2,
  2,
  2,
  2,
  1,
  2,
  2,
  2,
  2,
  2,
  2,
  1
];
DES$3.prototype.deriveKeys = function a(u, c) {
  u.keys = new Array(16 * 2), assert$h.equal(c.length, this.blockSize, "Invalid key length");
  var l = utils$w.readUInt32BE(c, 0), v = utils$w.readUInt32BE(c, 4);
  utils$w.pc1(l, v, u.tmp, 0), l = u.tmp[0], v = u.tmp[1];
  for (var p = 0; p < u.keys.length; p += 2) {
    var _ = shiftTable[p >>> 1];
    l = utils$w.r28shl(l, _), v = utils$w.r28shl(v, _), utils$w.pc2(l, v, u.keys, p);
  }
};
DES$3.prototype._update = function a(u, c, l, v) {
  var p = this._desState, _ = utils$w.readUInt32BE(u, c), k = utils$w.readUInt32BE(u, c + 4);
  utils$w.ip(_, k, p.tmp, 0), _ = p.tmp[0], k = p.tmp[1], this.type === "encrypt" ? this._encrypt(p, _, k, p.tmp, 0) : this._decrypt(p, _, k, p.tmp, 0), _ = p.tmp[0], k = p.tmp[1], utils$w.writeUInt32BE(l, _, v), utils$w.writeUInt32BE(l, k, v + 4);
};
DES$3.prototype._pad = function a(u, c) {
  if (this.padding === !1)
    return !1;
  for (var l = u.length - c, v = c; v < u.length; v++)
    u[v] = l;
  return !0;
};
DES$3.prototype._unpad = function a(u) {
  if (this.padding === !1)
    return u;
  for (var c = u[u.length - 1], l = u.length - c; l < u.length; l++)
    assert$h.equal(u[l], c);
  return u.slice(0, u.length - c);
};
DES$3.prototype._encrypt = function a(u, c, l, v, p) {
  for (var _ = c, k = l, O = 0; O < u.keys.length; O += 2) {
    var D = u.keys[O], F = u.keys[O + 1];
    utils$w.expand(k, u.tmp, 0), D ^= u.tmp[0], F ^= u.tmp[1];
    var z = utils$w.substitute(D, F), j = utils$w.permute(z), ee = k;
    k = (_ ^ j) >>> 0, _ = ee;
  }
  utils$w.rip(k, _, v, p);
};
DES$3.prototype._decrypt = function a(u, c, l, v, p) {
  for (var _ = l, k = c, O = u.keys.length - 2; O >= 0; O -= 2) {
    var D = u.keys[O], F = u.keys[O + 1];
    utils$w.expand(_, u.tmp, 0), D ^= u.tmp[0], F ^= u.tmp[1];
    var z = utils$w.substitute(D, F), j = utils$w.permute(z), ee = _;
    _ = (k ^ j) >>> 0, k = ee;
  }
  utils$w.rip(_, k, v, p);
};
var cbc$1 = {}, assert$g = minimalisticAssert, inherits$g = inherits_browserExports, proto = {};
function CBCState(a) {
  assert$g.equal(a.length, 8, "Invalid IV length"), this.iv = new Array(8);
  for (var u = 0; u < this.iv.length; u++)
    this.iv[u] = a[u];
}
function instantiate(a) {
  function u(p) {
    a.call(this, p), this._cbcInit();
  }
  inherits$g(u, a);
  for (var c = Object.keys(proto), l = 0; l < c.length; l++) {
    var v = c[l];
    u.prototype[v] = proto[v];
  }
  return u.create = function(_) {
    return new u(_);
  }, u;
}
cbc$1.instantiate = instantiate;
proto._cbcInit = function a() {
  var u = new CBCState(this.options.iv);
  this._cbcState = u;
};
proto._update = function a(u, c, l, v) {
  var p = this._cbcState, _ = this.constructor.super_.prototype, k = p.iv;
  if (this.type === "encrypt") {
    for (var O = 0; O < this.blockSize; O++)
      k[O] ^= u[c + O];
    _._update.call(this, k, 0, l, v);
    for (var O = 0; O < this.blockSize; O++)
      k[O] = l[v + O];
  } else {
    _._update.call(this, u, c, l, v);
    for (var O = 0; O < this.blockSize; O++)
      l[v + O] ^= k[O];
    for (var O = 0; O < this.blockSize; O++)
      k[O] = u[c + O];
  }
};
var assert$f = minimalisticAssert, inherits$f = inherits_browserExports, Cipher$1 = cipher, DES$2 = des$1;
function EDEState(a, u) {
  assert$f.equal(u.length, 24, "Invalid key length");
  var c = u.slice(0, 8), l = u.slice(8, 16), v = u.slice(16, 24);
  a === "encrypt" ? this.ciphers = [
    DES$2.create({ type: "encrypt", key: c }),
    DES$2.create({ type: "decrypt", key: l }),
    DES$2.create({ type: "encrypt", key: v })
  ] : this.ciphers = [
    DES$2.create({ type: "decrypt", key: v }),
    DES$2.create({ type: "encrypt", key: l }),
    DES$2.create({ type: "decrypt", key: c })
  ];
}
function EDE(a) {
  Cipher$1.call(this, a);
  var u = new EDEState(this.type, this.options.key);
  this._edeState = u;
}
inherits$f(EDE, Cipher$1);
var ede = EDE;
EDE.create = function a(u) {
  return new EDE(u);
};
EDE.prototype._update = function a(u, c, l, v) {
  var p = this._edeState;
  p.ciphers[0]._update(u, c, l, v), p.ciphers[1]._update(l, v, l, v), p.ciphers[2]._update(l, v, l, v);
};
EDE.prototype._pad = DES$2.prototype._pad;
EDE.prototype._unpad = DES$2.prototype._unpad;
des$2.utils = utils$x;
des$2.Cipher = cipher;
des$2.DES = des$1;
des$2.CBC = cbc$1;
des$2.EDE = ede;
var CipherBase = cipherBase, des = des$2, inherits$e = inherits_browserExports, Buffer$r = safeBufferExports$3.Buffer, modes$4 = {
  "des-ede3-cbc": des.CBC.instantiate(des.EDE),
  "des-ede3": des.EDE,
  "des-ede-cbc": des.CBC.instantiate(des.EDE),
  "des-ede": des.EDE,
  "des-cbc": des.CBC.instantiate(des.DES),
  "des-ecb": des.DES
};
modes$4.des = modes$4["des-cbc"];
modes$4.des3 = modes$4["des-ede3-cbc"];
var browserifyDes = DES$1;
inherits$e(DES$1, CipherBase);
function DES$1(a) {
  CipherBase.call(this);
  var u = a.mode.toLowerCase(), c = modes$4[u], l;
  a.decrypt ? l = "decrypt" : l = "encrypt";
  var v = a.key;
  Buffer$r.isBuffer(v) || (v = Buffer$r.from(v)), (u === "des-ede" || u === "des-ede-cbc") && (v = Buffer$r.concat([v, v.slice(0, 8)]));
  var p = a.iv;
  Buffer$r.isBuffer(p) || (p = Buffer$r.from(p)), this._des = c.create({
    key: v,
    iv: p,
    type: l
  });
}
DES$1.prototype._update = function(a) {
  return Buffer$r.from(this._des.update(a));
};
DES$1.prototype._final = function() {
  return Buffer$r.from(this._des.final());
};
var browser$6 = {}, encrypter = {}, ecb = {};
ecb.encrypt = function(a, u) {
  return a._cipher.encryptBlock(u);
};
ecb.decrypt = function(a, u) {
  return a._cipher.decryptBlock(u);
};
var cbc = {}, bufferXor = function a(u, c) {
  for (var l = Math.min(u.length, c.length), v = new Buffer$O(l), p = 0; p < l; ++p)
    v[p] = u[p] ^ c[p];
  return v;
}, xor$7 = bufferXor;
cbc.encrypt = function(a, u) {
  var c = xor$7(u, a._prev);
  return a._prev = a._cipher.encryptBlock(c), a._prev;
};
cbc.decrypt = function(a, u) {
  var c = a._prev;
  a._prev = u;
  var l = a._cipher.decryptBlock(u);
  return xor$7(l, c);
};
var cfb = {}, Buffer$q = safeBufferExports$3.Buffer, xor$6 = bufferXor;
function encryptStart(a, u, c) {
  var l = u.length, v = xor$6(u, a._cache);
  return a._cache = a._cache.slice(l), a._prev = Buffer$q.concat([a._prev, c ? u : v]), v;
}
cfb.encrypt = function(a, u, c) {
  for (var l = Buffer$q.allocUnsafe(0), v; u.length; )
    if (a._cache.length === 0 && (a._cache = a._cipher.encryptBlock(a._prev), a._prev = Buffer$q.allocUnsafe(0)), a._cache.length <= u.length)
      v = a._cache.length, l = Buffer$q.concat([l, encryptStart(a, u.slice(0, v), c)]), u = u.slice(v);
    else {
      l = Buffer$q.concat([l, encryptStart(a, u, c)]);
      break;
    }
  return l;
};
var cfb8 = {}, Buffer$p = safeBufferExports$3.Buffer;
function encryptByte$1(a, u, c) {
  var l = a._cipher.encryptBlock(a._prev), v = l[0] ^ u;
  return a._prev = Buffer$p.concat([
    a._prev.slice(1),
    Buffer$p.from([c ? u : v])
  ]), v;
}
cfb8.encrypt = function(a, u, c) {
  for (var l = u.length, v = Buffer$p.allocUnsafe(l), p = -1; ++p < l; )
    v[p] = encryptByte$1(a, u[p], c);
  return v;
};
var cfb1 = {}, Buffer$o = safeBufferExports$3.Buffer;
function encryptByte(a, u, c) {
  for (var l, v = -1, p = 8, _ = 0, k, O; ++v < p; )
    l = a._cipher.encryptBlock(a._prev), k = u & 1 << 7 - v ? 128 : 0, O = l[0] ^ k, _ += (O & 128) >> v % 8, a._prev = shiftIn(a._prev, c ? k : O);
  return _;
}
function shiftIn(a, u) {
  var c = a.length, l = -1, v = Buffer$o.allocUnsafe(a.length);
  for (a = Buffer$o.concat([a, Buffer$o.from([u])]); ++l < c; )
    v[l] = a[l] << 1 | a[l + 1] >> 7;
  return v;
}
cfb1.encrypt = function(a, u, c) {
  for (var l = u.length, v = Buffer$o.allocUnsafe(l), p = -1; ++p < l; )
    v[p] = encryptByte(a, u[p], c);
  return v;
};
var ofb = {}, xor$5 = bufferXor;
function getBlock$1(a) {
  return a._prev = a._cipher.encryptBlock(a._prev), a._prev;
}
ofb.encrypt = function(a, u) {
  for (; a._cache.length < u.length; )
    a._cache = Buffer$O.concat([a._cache, getBlock$1(a)]);
  var c = a._cache.slice(0, u.length);
  return a._cache = a._cache.slice(u.length), xor$5(u, c);
};
var ctr = {};
function incr32$2(a) {
  for (var u = a.length, c; u--; )
    if (c = a.readUInt8(u), c === 255)
      a.writeUInt8(0, u);
    else {
      c++, a.writeUInt8(c, u);
      break;
    }
}
var incr32_1 = incr32$2, xor$4 = bufferXor, Buffer$n = safeBufferExports$3.Buffer, incr32$1 = incr32_1;
function getBlock(a) {
  var u = a._cipher.encryptBlockRaw(a._prev);
  return incr32$1(a._prev), u;
}
var blockSize = 16;
ctr.encrypt = function(a, u) {
  var c = Math.ceil(u.length / blockSize), l = a._cache.length;
  a._cache = Buffer$n.concat([
    a._cache,
    Buffer$n.allocUnsafe(c * blockSize)
  ]);
  for (var v = 0; v < c; v++) {
    var p = getBlock(a), _ = l + v * blockSize;
    a._cache.writeUInt32BE(p[0], _ + 0), a._cache.writeUInt32BE(p[1], _ + 4), a._cache.writeUInt32BE(p[2], _ + 8), a._cache.writeUInt32BE(p[3], _ + 12);
  }
  var k = a._cache.slice(0, u.length);
  return a._cache = a._cache.slice(u.length), xor$4(u, k);
};
const aes128 = {
  cipher: "AES",
  key: 128,
  iv: 16,
  mode: "CBC",
  type: "block"
}, aes192 = {
  cipher: "AES",
  key: 192,
  iv: 16,
  mode: "CBC",
  type: "block"
}, aes256 = {
  cipher: "AES",
  key: 256,
  iv: 16,
  mode: "CBC",
  type: "block"
}, require$$2 = {
  "aes-128-ecb": {
    cipher: "AES",
    key: 128,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-192-ecb": {
    cipher: "AES",
    key: 192,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-256-ecb": {
    cipher: "AES",
    key: 256,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-128-cbc": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-192-cbc": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-256-cbc": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  aes128,
  aes192,
  aes256,
  "aes-128-cfb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-192-cfb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-256-cfb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-128-cfb8": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-192-cfb8": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-256-cfb8": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-128-cfb1": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-192-cfb1": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-256-cfb1": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-128-ofb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-192-ofb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-256-ofb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-128-ctr": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-192-ctr": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-256-ctr": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-128-gcm": {
    cipher: "AES",
    key: 128,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-192-gcm": {
    cipher: "AES",
    key: 192,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-256-gcm": {
    cipher: "AES",
    key: 256,
    iv: 12,
    mode: "GCM",
    type: "auth"
  }
};
var modeModules = {
  ECB: ecb,
  CBC: cbc,
  CFB: cfb,
  CFB8: cfb8,
  CFB1: cfb1,
  OFB: ofb,
  CTR: ctr,
  GCM: ctr
}, modes$3 = require$$2;
for (var key$3 in modes$3)
  modes$3[key$3].module = modeModules[modes$3[key$3].mode];
var modes_1 = modes$3, aes$5 = {}, Buffer$m = safeBufferExports$3.Buffer;
function asUInt32Array(a) {
  Buffer$m.isBuffer(a) || (a = Buffer$m.from(a));
  for (var u = a.length / 4 | 0, c = new Array(u), l = 0; l < u; l++)
    c[l] = a.readUInt32BE(l * 4);
  return c;
}
function scrubVec(a) {
  for (var u = 0; u < a.length; a++)
    a[u] = 0;
}
function cryptBlock(a, u, c, l, v) {
  for (var p = c[0], _ = c[1], k = c[2], O = c[3], D = a[0] ^ u[0], F = a[1] ^ u[1], z = a[2] ^ u[2], j = a[3] ^ u[3], ee, X, ae, Q, ne = 4, Z = 1; Z < v; Z++)
    ee = p[D >>> 24] ^ _[F >>> 16 & 255] ^ k[z >>> 8 & 255] ^ O[j & 255] ^ u[ne++], X = p[F >>> 24] ^ _[z >>> 16 & 255] ^ k[j >>> 8 & 255] ^ O[D & 255] ^ u[ne++], ae = p[z >>> 24] ^ _[j >>> 16 & 255] ^ k[D >>> 8 & 255] ^ O[F & 255] ^ u[ne++], Q = p[j >>> 24] ^ _[D >>> 16 & 255] ^ k[F >>> 8 & 255] ^ O[z & 255] ^ u[ne++], D = ee, F = X, z = ae, j = Q;
  return ee = (l[D >>> 24] << 24 | l[F >>> 16 & 255] << 16 | l[z >>> 8 & 255] << 8 | l[j & 255]) ^ u[ne++], X = (l[F >>> 24] << 24 | l[z >>> 16 & 255] << 16 | l[j >>> 8 & 255] << 8 | l[D & 255]) ^ u[ne++], ae = (l[z >>> 24] << 24 | l[j >>> 16 & 255] << 16 | l[D >>> 8 & 255] << 8 | l[F & 255]) ^ u[ne++], Q = (l[j >>> 24] << 24 | l[D >>> 16 & 255] << 16 | l[F >>> 8 & 255] << 8 | l[z & 255]) ^ u[ne++], ee = ee >>> 0, X = X >>> 0, ae = ae >>> 0, Q = Q >>> 0, [ee, X, ae, Q];
}
var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], G = function() {
  for (var a = new Array(256), u = 0; u < 256; u++)
    u < 128 ? a[u] = u << 1 : a[u] = u << 1 ^ 283;
  for (var c = [], l = [], v = [[], [], [], []], p = [[], [], [], []], _ = 0, k = 0, O = 0; O < 256; ++O) {
    var D = k ^ k << 1 ^ k << 2 ^ k << 3 ^ k << 4;
    D = D >>> 8 ^ D & 255 ^ 99, c[_] = D, l[D] = _;
    var F = a[_], z = a[F], j = a[z], ee = a[D] * 257 ^ D * 16843008;
    v[0][_] = ee << 24 | ee >>> 8, v[1][_] = ee << 16 | ee >>> 16, v[2][_] = ee << 8 | ee >>> 24, v[3][_] = ee, ee = j * 16843009 ^ z * 65537 ^ F * 257 ^ _ * 16843008, p[0][D] = ee << 24 | ee >>> 8, p[1][D] = ee << 16 | ee >>> 16, p[2][D] = ee << 8 | ee >>> 24, p[3][D] = ee, _ === 0 ? _ = k = 1 : (_ = F ^ a[a[a[j ^ F]]], k ^= a[a[k]]);
  }
  return {
    SBOX: c,
    INV_SBOX: l,
    SUB_MIX: v,
    INV_SUB_MIX: p
  };
}();
function AES(a) {
  this._key = asUInt32Array(a), this._reset();
}
AES.blockSize = 4 * 4;
AES.keySize = 256 / 8;
AES.prototype.blockSize = AES.blockSize;
AES.prototype.keySize = AES.keySize;
AES.prototype._reset = function() {
  for (var a = this._key, u = a.length, c = u + 6, l = (c + 1) * 4, v = [], p = 0; p < u; p++)
    v[p] = a[p];
  for (p = u; p < l; p++) {
    var _ = v[p - 1];
    p % u === 0 ? (_ = _ << 8 | _ >>> 24, _ = G.SBOX[_ >>> 24] << 24 | G.SBOX[_ >>> 16 & 255] << 16 | G.SBOX[_ >>> 8 & 255] << 8 | G.SBOX[_ & 255], _ ^= RCON[p / u | 0] << 24) : u > 6 && p % u === 4 && (_ = G.SBOX[_ >>> 24] << 24 | G.SBOX[_ >>> 16 & 255] << 16 | G.SBOX[_ >>> 8 & 255] << 8 | G.SBOX[_ & 255]), v[p] = v[p - u] ^ _;
  }
  for (var k = [], O = 0; O < l; O++) {
    var D = l - O, F = v[D - (O % 4 ? 0 : 4)];
    O < 4 || D <= 4 ? k[O] = F : k[O] = G.INV_SUB_MIX[0][G.SBOX[F >>> 24]] ^ G.INV_SUB_MIX[1][G.SBOX[F >>> 16 & 255]] ^ G.INV_SUB_MIX[2][G.SBOX[F >>> 8 & 255]] ^ G.INV_SUB_MIX[3][G.SBOX[F & 255]];
  }
  this._nRounds = c, this._keySchedule = v, this._invKeySchedule = k;
};
AES.prototype.encryptBlockRaw = function(a) {
  return a = asUInt32Array(a), cryptBlock(a, this._keySchedule, G.SUB_MIX, G.SBOX, this._nRounds);
};
AES.prototype.encryptBlock = function(a) {
  var u = this.encryptBlockRaw(a), c = Buffer$m.allocUnsafe(16);
  return c.writeUInt32BE(u[0], 0), c.writeUInt32BE(u[1], 4), c.writeUInt32BE(u[2], 8), c.writeUInt32BE(u[3], 12), c;
};
AES.prototype.decryptBlock = function(a) {
  a = asUInt32Array(a);
  var u = a[1];
  a[1] = a[3], a[3] = u;
  var c = cryptBlock(a, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX, this._nRounds), l = Buffer$m.allocUnsafe(16);
  return l.writeUInt32BE(c[0], 0), l.writeUInt32BE(c[3], 4), l.writeUInt32BE(c[2], 8), l.writeUInt32BE(c[1], 12), l;
};
AES.prototype.scrub = function() {
  scrubVec(this._keySchedule), scrubVec(this._invKeySchedule), scrubVec(this._key);
};
aes$5.AES = AES;
var Buffer$l = safeBufferExports$3.Buffer, ZEROES = Buffer$l.alloc(16, 0);
function toArray$1(a) {
  return [
    a.readUInt32BE(0),
    a.readUInt32BE(4),
    a.readUInt32BE(8),
    a.readUInt32BE(12)
  ];
}
function fromArray(a) {
  var u = Buffer$l.allocUnsafe(16);
  return u.writeUInt32BE(a[0] >>> 0, 0), u.writeUInt32BE(a[1] >>> 0, 4), u.writeUInt32BE(a[2] >>> 0, 8), u.writeUInt32BE(a[3] >>> 0, 12), u;
}
function GHASH$1(a) {
  this.h = a, this.state = Buffer$l.alloc(16, 0), this.cache = Buffer$l.allocUnsafe(0);
}
GHASH$1.prototype.ghash = function(a) {
  for (var u = -1; ++u < a.length; )
    this.state[u] ^= a[u];
  this._multiply();
};
GHASH$1.prototype._multiply = function() {
  for (var a = toArray$1(this.h), u = [0, 0, 0, 0], c, l, v, p = -1; ++p < 128; ) {
    for (l = (this.state[~~(p / 8)] & 1 << 7 - p % 8) !== 0, l && (u[0] ^= a[0], u[1] ^= a[1], u[2] ^= a[2], u[3] ^= a[3]), v = (a[3] & 1) !== 0, c = 3; c > 0; c--)
      a[c] = a[c] >>> 1 | (a[c - 1] & 1) << 31;
    a[0] = a[0] >>> 1, v && (a[0] = a[0] ^ 225 << 24);
  }
  this.state = fromArray(u);
};
GHASH$1.prototype.update = function(a) {
  this.cache = Buffer$l.concat([this.cache, a]);
  for (var u; this.cache.length >= 16; )
    u = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(u);
};
GHASH$1.prototype.final = function(a, u) {
  return this.cache.length && this.ghash(Buffer$l.concat([this.cache, ZEROES], 16)), this.ghash(fromArray([0, a, 0, u])), this.state;
};
var ghash = GHASH$1, aes$4 = aes$5, Buffer$k = safeBufferExports$3.Buffer, Transform$5 = cipherBase, inherits$d = inherits_browserExports, GHASH = ghash, xor$3 = bufferXor, incr32 = incr32_1;
function xorTest(a, u) {
  var c = 0;
  a.length !== u.length && c++;
  for (var l = Math.min(a.length, u.length), v = 0; v < l; ++v)
    c += a[v] ^ u[v];
  return c;
}
function calcIv(a, u, c) {
  if (u.length === 12)
    return a._finID = Buffer$k.concat([u, Buffer$k.from([0, 0, 0, 1])]), Buffer$k.concat([u, Buffer$k.from([0, 0, 0, 2])]);
  var l = new GHASH(c), v = u.length, p = v % 16;
  l.update(u), p && (p = 16 - p, l.update(Buffer$k.alloc(p, 0))), l.update(Buffer$k.alloc(8, 0));
  var _ = v * 8, k = Buffer$k.alloc(8);
  k.writeUIntBE(_, 0, 8), l.update(k), a._finID = l.state;
  var O = Buffer$k.from(a._finID);
  return incr32(O), O;
}
function StreamCipher$3(a, u, c, l) {
  Transform$5.call(this);
  var v = Buffer$k.alloc(4, 0);
  this._cipher = new aes$4.AES(u);
  var p = this._cipher.encryptBlock(v);
  this._ghash = new GHASH(p), c = calcIv(this, c, p), this._prev = Buffer$k.from(c), this._cache = Buffer$k.allocUnsafe(0), this._secCache = Buffer$k.allocUnsafe(0), this._decrypt = l, this._alen = 0, this._len = 0, this._mode = a, this._authTag = null, this._called = !1;
}
inherits$d(StreamCipher$3, Transform$5);
StreamCipher$3.prototype._update = function(a) {
  if (!this._called && this._alen) {
    var u = 16 - this._alen % 16;
    u < 16 && (u = Buffer$k.alloc(u, 0), this._ghash.update(u));
  }
  this._called = !0;
  var c = this._mode.encrypt(this, a);
  return this._decrypt ? this._ghash.update(a) : this._ghash.update(c), this._len += a.length, c;
};
StreamCipher$3.prototype._final = function() {
  if (this._decrypt && !this._authTag)
    throw new Error("Unsupported state or unable to authenticate data");
  var a = xor$3(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
  if (this._decrypt && xorTest(a, this._authTag))
    throw new Error("Unsupported state or unable to authenticate data");
  this._authTag = a, this._cipher.scrub();
};
StreamCipher$3.prototype.getAuthTag = function a() {
  if (this._decrypt || !Buffer$k.isBuffer(this._authTag))
    throw new Error("Attempting to get auth tag in unsupported state");
  return this._authTag;
};
StreamCipher$3.prototype.setAuthTag = function a(u) {
  if (!this._decrypt)
    throw new Error("Attempting to set auth tag in unsupported state");
  this._authTag = u;
};
StreamCipher$3.prototype.setAAD = function a(u) {
  if (this._called)
    throw new Error("Attempting to set AAD in unsupported state");
  this._ghash.update(u), this._alen += u.length;
};
var authCipher = StreamCipher$3, aes$3 = aes$5, Buffer$j = safeBufferExports$3.Buffer, Transform$4 = cipherBase, inherits$c = inherits_browserExports;
function StreamCipher$2(a, u, c, l) {
  Transform$4.call(this), this._cipher = new aes$3.AES(u), this._prev = Buffer$j.from(c), this._cache = Buffer$j.allocUnsafe(0), this._secCache = Buffer$j.allocUnsafe(0), this._decrypt = l, this._mode = a;
}
inherits$c(StreamCipher$2, Transform$4);
StreamCipher$2.prototype._update = function(a) {
  return this._mode.encrypt(this, a, this._decrypt);
};
StreamCipher$2.prototype._final = function() {
  this._cipher.scrub();
};
var streamCipher = StreamCipher$2, Buffer$i = safeBufferExports$3.Buffer, MD5 = md5_js;
function EVP_BytesToKey(a, u, c, l) {
  if (Buffer$i.isBuffer(a) || (a = Buffer$i.from(a, "binary")), u && (Buffer$i.isBuffer(u) || (u = Buffer$i.from(u, "binary")), u.length !== 8))
    throw new RangeError("salt should be Buffer with 8 byte length");
  for (var v = c / 8, p = Buffer$i.alloc(v), _ = Buffer$i.alloc(l || 0), k = Buffer$i.alloc(0); v > 0 || l > 0; ) {
    var O = new MD5();
    O.update(k), O.update(a), u && O.update(u), k = O.digest();
    var D = 0;
    if (v > 0) {
      var F = p.length - v;
      D = Math.min(v, k.length), k.copy(p, F, 0, D), v -= D;
    }
    if (D < k.length && l > 0) {
      var z = _.length - l, j = Math.min(l, k.length - D);
      k.copy(_, z, D, D + j), l -= j;
    }
  }
  return k.fill(0), { key: p, iv: _ };
}
var evp_bytestokey = EVP_BytesToKey, MODES$1 = modes_1, AuthCipher$1 = authCipher, Buffer$h = safeBufferExports$3.Buffer, StreamCipher$1 = streamCipher, Transform$3 = cipherBase, aes$2 = aes$5, ebtk$2 = evp_bytestokey, inherits$b = inherits_browserExports;
function Cipher(a, u, c) {
  Transform$3.call(this), this._cache = new Splitter$1(), this._cipher = new aes$2.AES(u), this._prev = Buffer$h.from(c), this._mode = a, this._autopadding = !0;
}
inherits$b(Cipher, Transform$3);
Cipher.prototype._update = function(a) {
  this._cache.add(a);
  for (var u, c, l = []; u = this._cache.get(); )
    c = this._mode.encrypt(this, u), l.push(c);
  return Buffer$h.concat(l);
};
var PADDING$1 = Buffer$h.alloc(16, 16);
Cipher.prototype._final = function() {
  var a = this._cache.flush();
  if (this._autopadding)
    return a = this._mode.encrypt(this, a), this._cipher.scrub(), a;
  if (!a.equals(PADDING$1))
    throw this._cipher.scrub(), new Error("data not multiple of block length");
};
Cipher.prototype.setAutoPadding = function(a) {
  return this._autopadding = !!a, this;
};
function Splitter$1() {
  this.cache = Buffer$h.allocUnsafe(0);
}
Splitter$1.prototype.add = function(a) {
  this.cache = Buffer$h.concat([this.cache, a]);
};
Splitter$1.prototype.get = function() {
  if (this.cache.length > 15) {
    var a = this.cache.slice(0, 16);
    return this.cache = this.cache.slice(16), a;
  }
  return null;
};
Splitter$1.prototype.flush = function() {
  for (var a = 16 - this.cache.length, u = Buffer$h.allocUnsafe(a), c = -1; ++c < a; )
    u.writeUInt8(a, c);
  return Buffer$h.concat([this.cache, u]);
};
function createCipheriv$1(a, u, c) {
  var l = MODES$1[a.toLowerCase()];
  if (!l)
    throw new TypeError("invalid suite type");
  if (typeof u == "string" && (u = Buffer$h.from(u)), u.length !== l.key / 8)
    throw new TypeError("invalid key length " + u.length);
  if (typeof c == "string" && (c = Buffer$h.from(c)), l.mode !== "GCM" && c.length !== l.iv)
    throw new TypeError("invalid iv length " + c.length);
  return l.type === "stream" ? new StreamCipher$1(l.module, u, c) : l.type === "auth" ? new AuthCipher$1(l.module, u, c) : new Cipher(l.module, u, c);
}
function createCipher$1(a, u) {
  var c = MODES$1[a.toLowerCase()];
  if (!c)
    throw new TypeError("invalid suite type");
  var l = ebtk$2(u, !1, c.key, c.iv);
  return createCipheriv$1(a, l.key, l.iv);
}
encrypter.createCipheriv = createCipheriv$1;
encrypter.createCipher = createCipher$1;
var decrypter = {}, AuthCipher = authCipher, Buffer$g = safeBufferExports$3.Buffer, MODES = modes_1, StreamCipher = streamCipher, Transform$2 = cipherBase, aes$1 = aes$5, ebtk$1 = evp_bytestokey, inherits$a = inherits_browserExports;
function Decipher(a, u, c) {
  Transform$2.call(this), this._cache = new Splitter(), this._last = void 0, this._cipher = new aes$1.AES(u), this._prev = Buffer$g.from(c), this._mode = a, this._autopadding = !0;
}
inherits$a(Decipher, Transform$2);
Decipher.prototype._update = function(a) {
  this._cache.add(a);
  for (var u, c, l = []; u = this._cache.get(this._autopadding); )
    c = this._mode.decrypt(this, u), l.push(c);
  return Buffer$g.concat(l);
};
Decipher.prototype._final = function() {
  var a = this._cache.flush();
  if (this._autopadding)
    return unpad(this._mode.decrypt(this, a));
  if (a)
    throw new Error("data not multiple of block length");
};
Decipher.prototype.setAutoPadding = function(a) {
  return this._autopadding = !!a, this;
};
function Splitter() {
  this.cache = Buffer$g.allocUnsafe(0);
}
Splitter.prototype.add = function(a) {
  this.cache = Buffer$g.concat([this.cache, a]);
};
Splitter.prototype.get = function(a) {
  var u;
  if (a) {
    if (this.cache.length > 16)
      return u = this.cache.slice(0, 16), this.cache = this.cache.slice(16), u;
  } else if (this.cache.length >= 16)
    return u = this.cache.slice(0, 16), this.cache = this.cache.slice(16), u;
  return null;
};
Splitter.prototype.flush = function() {
  if (this.cache.length)
    return this.cache;
};
function unpad(a) {
  var u = a[15];
  if (u < 1 || u > 16)
    throw new Error("unable to decrypt data");
  for (var c = -1; ++c < u; )
    if (a[c + (16 - u)] !== u)
      throw new Error("unable to decrypt data");
  if (u !== 16)
    return a.slice(0, 16 - u);
}
function createDecipheriv$1(a, u, c) {
  var l = MODES[a.toLowerCase()];
  if (!l)
    throw new TypeError("invalid suite type");
  if (typeof c == "string" && (c = Buffer$g.from(c)), l.mode !== "GCM" && c.length !== l.iv)
    throw new TypeError("invalid iv length " + c.length);
  if (typeof u == "string" && (u = Buffer$g.from(u)), u.length !== l.key / 8)
    throw new TypeError("invalid key length " + u.length);
  return l.type === "stream" ? new StreamCipher(l.module, u, c, !0) : l.type === "auth" ? new AuthCipher(l.module, u, c, !0) : new Decipher(l.module, u, c);
}
function createDecipher$1(a, u) {
  var c = MODES[a.toLowerCase()];
  if (!c)
    throw new TypeError("invalid suite type");
  var l = ebtk$1(u, !1, c.key, c.iv);
  return createDecipheriv$1(a, l.key, l.iv);
}
decrypter.createDecipher = createDecipher$1;
decrypter.createDecipheriv = createDecipheriv$1;
var ciphers$2 = encrypter, deciphers = decrypter, modes$2 = require$$2;
function getCiphers$1() {
  return Object.keys(modes$2);
}
browser$6.createCipher = browser$6.Cipher = ciphers$2.createCipher;
browser$6.createCipheriv = browser$6.Cipheriv = ciphers$2.createCipheriv;
browser$6.createDecipher = browser$6.Decipher = deciphers.createDecipher;
browser$6.createDecipheriv = browser$6.Decipheriv = deciphers.createDecipheriv;
browser$6.listCiphers = browser$6.getCiphers = getCiphers$1;
var modes$1 = {};
(function(a) {
  a["des-ecb"] = {
    key: 8,
    iv: 0
  }, a["des-cbc"] = a.des = {
    key: 8,
    iv: 8
  }, a["des-ede3-cbc"] = a.des3 = {
    key: 24,
    iv: 8
  }, a["des-ede3"] = {
    key: 24,
    iv: 0
  }, a["des-ede-cbc"] = {
    key: 16,
    iv: 8
  }, a["des-ede"] = {
    key: 16,
    iv: 0
  };
})(modes$1);
var DES = browserifyDes, aes = browser$6, aesModes = modes_1, desModes = modes$1, ebtk = evp_bytestokey;
function createCipher(a, u) {
  a = a.toLowerCase();
  var c, l;
  if (aesModes[a])
    c = aesModes[a].key, l = aesModes[a].iv;
  else if (desModes[a])
    c = desModes[a].key * 8, l = desModes[a].iv;
  else
    throw new TypeError("invalid suite type");
  var v = ebtk(u, !1, c, l);
  return createCipheriv(a, v.key, v.iv);
}
function createDecipher(a, u) {
  a = a.toLowerCase();
  var c, l;
  if (aesModes[a])
    c = aesModes[a].key, l = aesModes[a].iv;
  else if (desModes[a])
    c = desModes[a].key * 8, l = desModes[a].iv;
  else
    throw new TypeError("invalid suite type");
  var v = ebtk(u, !1, c, l);
  return createDecipheriv(a, v.key, v.iv);
}
function createCipheriv(a, u, c) {
  if (a = a.toLowerCase(), aesModes[a])
    return aes.createCipheriv(a, u, c);
  if (desModes[a])
    return new DES({ key: u, iv: c, mode: a });
  throw new TypeError("invalid suite type");
}
function createDecipheriv(a, u, c) {
  if (a = a.toLowerCase(), aesModes[a])
    return aes.createDecipheriv(a, u, c);
  if (desModes[a])
    return new DES({ key: u, iv: c, mode: a, decrypt: !0 });
  throw new TypeError("invalid suite type");
}
function getCiphers() {
  return Object.keys(desModes).concat(aes.getCiphers());
}
browser$7.createCipher = browser$7.Cipher = createCipher;
browser$7.createCipheriv = browser$7.Cipheriv = createCipheriv;
browser$7.createDecipher = browser$7.Decipher = createDecipher;
browser$7.createDecipheriv = browser$7.Decipheriv = createDecipheriv;
browser$7.listCiphers = browser$7.getCiphers = getCiphers;
var browser$5 = {}, bn$6 = { exports: {} };
bn$6.exports;
(function(a) {
  (function(u, c) {
    function l(C, S) {
      if (!C)
        throw new Error(S || "Assertion failed");
    }
    function v(C, S) {
      C.super_ = S;
      var E = function() {
      };
      E.prototype = S.prototype, C.prototype = new E(), C.prototype.constructor = C;
    }
    function p(C, S, E) {
      if (p.isBN(C))
        return C;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, C !== null && ((S === "le" || S === "be") && (E = S, S = 10), this._init(C || 0, S || 10, E || "be"));
    }
    typeof u == "object" ? u.exports = p : c.BN = p, p.BN = p, p.wordSize = 26;
    var _;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? _ = window.Buffer : _ = require$$0$2.Buffer;
    } catch {
    }
    p.isBN = function(S) {
      return S instanceof p ? !0 : S !== null && typeof S == "object" && S.constructor.wordSize === p.wordSize && Array.isArray(S.words);
    }, p.max = function(S, E) {
      return S.cmp(E) > 0 ? S : E;
    }, p.min = function(S, E) {
      return S.cmp(E) < 0 ? S : E;
    }, p.prototype._init = function(S, E, I) {
      if (typeof S == "number")
        return this._initNumber(S, E, I);
      if (typeof S == "object")
        return this._initArray(S, E, I);
      E === "hex" && (E = 16), l(E === (E | 0) && E >= 2 && E <= 36), S = S.toString().replace(/\s+/g, "");
      var M = 0;
      S[0] === "-" && (M++, this.negative = 1), M < S.length && (E === 16 ? this._parseHex(S, M, I) : (this._parseBase(S, E, M), I === "le" && this._initArray(this.toArray(), E, I)));
    }, p.prototype._initNumber = function(S, E, I) {
      S < 0 && (this.negative = 1, S = -S), S < 67108864 ? (this.words = [S & 67108863], this.length = 1) : S < 4503599627370496 ? (this.words = [
        S & 67108863,
        S / 67108864 & 67108863
      ], this.length = 2) : (l(S < 9007199254740992), this.words = [
        S & 67108863,
        S / 67108864 & 67108863,
        1
      ], this.length = 3), I === "le" && this._initArray(this.toArray(), E, I);
    }, p.prototype._initArray = function(S, E, I) {
      if (l(typeof S.length == "number"), S.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(S.length / 3), this.words = new Array(this.length);
      for (var M = 0; M < this.length; M++)
        this.words[M] = 0;
      var $, U, Y = 0;
      if (I === "be")
        for (M = S.length - 1, $ = 0; M >= 0; M -= 3)
          U = S[M] | S[M - 1] << 8 | S[M - 2] << 16, this.words[$] |= U << Y & 67108863, this.words[$ + 1] = U >>> 26 - Y & 67108863, Y += 24, Y >= 26 && (Y -= 26, $++);
      else if (I === "le")
        for (M = 0, $ = 0; M < S.length; M += 3)
          U = S[M] | S[M + 1] << 8 | S[M + 2] << 16, this.words[$] |= U << Y & 67108863, this.words[$ + 1] = U >>> 26 - Y & 67108863, Y += 24, Y >= 26 && (Y -= 26, $++);
      return this.strip();
    };
    function k(C, S) {
      var E = C.charCodeAt(S);
      return E >= 65 && E <= 70 ? E - 55 : E >= 97 && E <= 102 ? E - 87 : E - 48 & 15;
    }
    function O(C, S, E) {
      var I = k(C, E);
      return E - 1 >= S && (I |= k(C, E - 1) << 4), I;
    }
    p.prototype._parseHex = function(S, E, I) {
      this.length = Math.ceil((S.length - E) / 6), this.words = new Array(this.length);
      for (var M = 0; M < this.length; M++)
        this.words[M] = 0;
      var $ = 0, U = 0, Y;
      if (I === "be")
        for (M = S.length - 1; M >= E; M -= 2)
          Y = O(S, E, M) << $, this.words[U] |= Y & 67108863, $ >= 18 ? ($ -= 18, U += 1, this.words[U] |= Y >>> 26) : $ += 8;
      else {
        var L = S.length - E;
        for (M = L % 2 === 0 ? E + 1 : E; M < S.length; M += 2)
          Y = O(S, E, M) << $, this.words[U] |= Y & 67108863, $ >= 18 ? ($ -= 18, U += 1, this.words[U] |= Y >>> 26) : $ += 8;
      }
      this.strip();
    };
    function D(C, S, E, I) {
      for (var M = 0, $ = Math.min(C.length, E), U = S; U < $; U++) {
        var Y = C.charCodeAt(U) - 48;
        M *= I, Y >= 49 ? M += Y - 49 + 10 : Y >= 17 ? M += Y - 17 + 10 : M += Y;
      }
      return M;
    }
    p.prototype._parseBase = function(S, E, I) {
      this.words = [0], this.length = 1;
      for (var M = 0, $ = 1; $ <= 67108863; $ *= E)
        M++;
      M--, $ = $ / E | 0;
      for (var U = S.length - I, Y = U % M, L = Math.min(U, U - Y) + I, T = 0, B = I; B < L; B += M)
        T = D(S, B, B + M, E), this.imuln($), this.words[0] + T < 67108864 ? this.words[0] += T : this._iaddn(T);
      if (Y !== 0) {
        var te = 1;
        for (T = D(S, B, S.length, E), B = 0; B < Y; B++)
          te *= E;
        this.imuln(te), this.words[0] + T < 67108864 ? this.words[0] += T : this._iaddn(T);
      }
      this.strip();
    }, p.prototype.copy = function(S) {
      S.words = new Array(this.length);
      for (var E = 0; E < this.length; E++)
        S.words[E] = this.words[E];
      S.length = this.length, S.negative = this.negative, S.red = this.red;
    }, p.prototype.clone = function() {
      var S = new p(null);
      return this.copy(S), S;
    }, p.prototype._expand = function(S) {
      for (; this.length < S; )
        this.words[this.length++] = 0;
      return this;
    }, p.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, p.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, p.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var F = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], z = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], j = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    p.prototype.toString = function(S, E) {
      S = S || 10, E = E | 0 || 1;
      var I;
      if (S === 16 || S === "hex") {
        I = "";
        for (var M = 0, $ = 0, U = 0; U < this.length; U++) {
          var Y = this.words[U], L = ((Y << M | $) & 16777215).toString(16);
          $ = Y >>> 24 - M & 16777215, $ !== 0 || U !== this.length - 1 ? I = F[6 - L.length] + L + I : I = L + I, M += 2, M >= 26 && (M -= 26, U--);
        }
        for ($ !== 0 && (I = $.toString(16) + I); I.length % E !== 0; )
          I = "0" + I;
        return this.negative !== 0 && (I = "-" + I), I;
      }
      if (S === (S | 0) && S >= 2 && S <= 36) {
        var T = z[S], B = j[S];
        I = "";
        var te = this.clone();
        for (te.negative = 0; !te.isZero(); ) {
          var pe = te.modn(B).toString(S);
          te = te.idivn(B), te.isZero() ? I = pe + I : I = F[T - pe.length] + pe + I;
        }
        for (this.isZero() && (I = "0" + I); I.length % E !== 0; )
          I = "0" + I;
        return this.negative !== 0 && (I = "-" + I), I;
      }
      l(!1, "Base should be between 2 and 36");
    }, p.prototype.toNumber = function() {
      var S = this.words[0];
      return this.length === 2 ? S += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? S += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && l(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -S : S;
    }, p.prototype.toJSON = function() {
      return this.toString(16);
    }, p.prototype.toBuffer = function(S, E) {
      return l(typeof _ < "u"), this.toArrayLike(_, S, E);
    }, p.prototype.toArray = function(S, E) {
      return this.toArrayLike(Array, S, E);
    }, p.prototype.toArrayLike = function(S, E, I) {
      var M = this.byteLength(), $ = I || Math.max(1, M);
      l(M <= $, "byte array longer than desired length"), l($ > 0, "Requested array length <= 0"), this.strip();
      var U = E === "le", Y = new S($), L, T, B = this.clone();
      if (U) {
        for (T = 0; !B.isZero(); T++)
          L = B.andln(255), B.iushrn(8), Y[T] = L;
        for (; T < $; T++)
          Y[T] = 0;
      } else {
        for (T = 0; T < $ - M; T++)
          Y[T] = 0;
        for (T = 0; !B.isZero(); T++)
          L = B.andln(255), B.iushrn(8), Y[$ - T - 1] = L;
      }
      return Y;
    }, Math.clz32 ? p.prototype._countBits = function(S) {
      return 32 - Math.clz32(S);
    } : p.prototype._countBits = function(S) {
      var E = S, I = 0;
      return E >= 4096 && (I += 13, E >>>= 13), E >= 64 && (I += 7, E >>>= 7), E >= 8 && (I += 4, E >>>= 4), E >= 2 && (I += 2, E >>>= 2), I + E;
    }, p.prototype._zeroBits = function(S) {
      if (S === 0)
        return 26;
      var E = S, I = 0;
      return E & 8191 || (I += 13, E >>>= 13), E & 127 || (I += 7, E >>>= 7), E & 15 || (I += 4, E >>>= 4), E & 3 || (I += 2, E >>>= 2), E & 1 || I++, I;
    }, p.prototype.bitLength = function() {
      var S = this.words[this.length - 1], E = this._countBits(S);
      return (this.length - 1) * 26 + E;
    };
    function ee(C) {
      for (var S = new Array(C.bitLength()), E = 0; E < S.length; E++) {
        var I = E / 26 | 0, M = E % 26;
        S[E] = (C.words[I] & 1 << M) >>> M;
      }
      return S;
    }
    p.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var S = 0, E = 0; E < this.length; E++) {
        var I = this._zeroBits(this.words[E]);
        if (S += I, I !== 26)
          break;
      }
      return S;
    }, p.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, p.prototype.toTwos = function(S) {
      return this.negative !== 0 ? this.abs().inotn(S).iaddn(1) : this.clone();
    }, p.prototype.fromTwos = function(S) {
      return this.testn(S - 1) ? this.notn(S).iaddn(1).ineg() : this.clone();
    }, p.prototype.isNeg = function() {
      return this.negative !== 0;
    }, p.prototype.neg = function() {
      return this.clone().ineg();
    }, p.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, p.prototype.iuor = function(S) {
      for (; this.length < S.length; )
        this.words[this.length++] = 0;
      for (var E = 0; E < S.length; E++)
        this.words[E] = this.words[E] | S.words[E];
      return this.strip();
    }, p.prototype.ior = function(S) {
      return l((this.negative | S.negative) === 0), this.iuor(S);
    }, p.prototype.or = function(S) {
      return this.length > S.length ? this.clone().ior(S) : S.clone().ior(this);
    }, p.prototype.uor = function(S) {
      return this.length > S.length ? this.clone().iuor(S) : S.clone().iuor(this);
    }, p.prototype.iuand = function(S) {
      var E;
      this.length > S.length ? E = S : E = this;
      for (var I = 0; I < E.length; I++)
        this.words[I] = this.words[I] & S.words[I];
      return this.length = E.length, this.strip();
    }, p.prototype.iand = function(S) {
      return l((this.negative | S.negative) === 0), this.iuand(S);
    }, p.prototype.and = function(S) {
      return this.length > S.length ? this.clone().iand(S) : S.clone().iand(this);
    }, p.prototype.uand = function(S) {
      return this.length > S.length ? this.clone().iuand(S) : S.clone().iuand(this);
    }, p.prototype.iuxor = function(S) {
      var E, I;
      this.length > S.length ? (E = this, I = S) : (E = S, I = this);
      for (var M = 0; M < I.length; M++)
        this.words[M] = E.words[M] ^ I.words[M];
      if (this !== E)
        for (; M < E.length; M++)
          this.words[M] = E.words[M];
      return this.length = E.length, this.strip();
    }, p.prototype.ixor = function(S) {
      return l((this.negative | S.negative) === 0), this.iuxor(S);
    }, p.prototype.xor = function(S) {
      return this.length > S.length ? this.clone().ixor(S) : S.clone().ixor(this);
    }, p.prototype.uxor = function(S) {
      return this.length > S.length ? this.clone().iuxor(S) : S.clone().iuxor(this);
    }, p.prototype.inotn = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = Math.ceil(S / 26) | 0, I = S % 26;
      this._expand(E), I > 0 && E--;
      for (var M = 0; M < E; M++)
        this.words[M] = ~this.words[M] & 67108863;
      return I > 0 && (this.words[M] = ~this.words[M] & 67108863 >> 26 - I), this.strip();
    }, p.prototype.notn = function(S) {
      return this.clone().inotn(S);
    }, p.prototype.setn = function(S, E) {
      l(typeof S == "number" && S >= 0);
      var I = S / 26 | 0, M = S % 26;
      return this._expand(I + 1), E ? this.words[I] = this.words[I] | 1 << M : this.words[I] = this.words[I] & ~(1 << M), this.strip();
    }, p.prototype.iadd = function(S) {
      var E;
      if (this.negative !== 0 && S.negative === 0)
        return this.negative = 0, E = this.isub(S), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && S.negative !== 0)
        return S.negative = 0, E = this.isub(S), S.negative = 1, E._normSign();
      var I, M;
      this.length > S.length ? (I = this, M = S) : (I = S, M = this);
      for (var $ = 0, U = 0; U < M.length; U++)
        E = (I.words[U] | 0) + (M.words[U] | 0) + $, this.words[U] = E & 67108863, $ = E >>> 26;
      for (; $ !== 0 && U < I.length; U++)
        E = (I.words[U] | 0) + $, this.words[U] = E & 67108863, $ = E >>> 26;
      if (this.length = I.length, $ !== 0)
        this.words[this.length] = $, this.length++;
      else if (I !== this)
        for (; U < I.length; U++)
          this.words[U] = I.words[U];
      return this;
    }, p.prototype.add = function(S) {
      var E;
      return S.negative !== 0 && this.negative === 0 ? (S.negative = 0, E = this.sub(S), S.negative ^= 1, E) : S.negative === 0 && this.negative !== 0 ? (this.negative = 0, E = S.sub(this), this.negative = 1, E) : this.length > S.length ? this.clone().iadd(S) : S.clone().iadd(this);
    }, p.prototype.isub = function(S) {
      if (S.negative !== 0) {
        S.negative = 0;
        var E = this.iadd(S);
        return S.negative = 1, E._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(S), this.negative = 1, this._normSign();
      var I = this.cmp(S);
      if (I === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var M, $;
      I > 0 ? (M = this, $ = S) : (M = S, $ = this);
      for (var U = 0, Y = 0; Y < $.length; Y++)
        E = (M.words[Y] | 0) - ($.words[Y] | 0) + U, U = E >> 26, this.words[Y] = E & 67108863;
      for (; U !== 0 && Y < M.length; Y++)
        E = (M.words[Y] | 0) + U, U = E >> 26, this.words[Y] = E & 67108863;
      if (U === 0 && Y < M.length && M !== this)
        for (; Y < M.length; Y++)
          this.words[Y] = M.words[Y];
      return this.length = Math.max(this.length, Y), M !== this && (this.negative = 1), this.strip();
    }, p.prototype.sub = function(S) {
      return this.clone().isub(S);
    };
    function X(C, S, E) {
      E.negative = S.negative ^ C.negative;
      var I = C.length + S.length | 0;
      E.length = I, I = I - 1 | 0;
      var M = C.words[0] | 0, $ = S.words[0] | 0, U = M * $, Y = U & 67108863, L = U / 67108864 | 0;
      E.words[0] = Y;
      for (var T = 1; T < I; T++) {
        for (var B = L >>> 26, te = L & 67108863, pe = Math.min(T, S.length - 1), Ie = Math.max(0, T - C.length + 1); Ie <= pe; Ie++) {
          var $e = T - Ie | 0;
          M = C.words[$e] | 0, $ = S.words[Ie] | 0, U = M * $ + te, B += U / 67108864 | 0, te = U & 67108863;
        }
        E.words[T] = te | 0, L = B | 0;
      }
      return L !== 0 ? E.words[T] = L | 0 : E.length--, E.strip();
    }
    var ae = function(S, E, I) {
      var M = S.words, $ = E.words, U = I.words, Y = 0, L, T, B, te = M[0] | 0, pe = te & 8191, Ie = te >>> 13, $e = M[1] | 0, ve = $e & 8191, he = $e >>> 13, Oe = M[2] | 0, Ae = Oe & 8191, Ue = Oe >>> 13, oe = M[3] | 0, A = oe & 8191, re = oe >>> 13, le = M[4] | 0, Ne = le & 8191, Pe = le >>> 13, Fe = M[5] | 0, je = Fe & 8191, qe = Fe >>> 13, yt = M[6] | 0, Xe = yt & 8191, Ge = yt >>> 13, H = M[7] | 0, ye = H & 8191, Ee = H >>> 13, We = M[8] | 0, we = We & 8191, V = We >>> 13, _e = M[9] | 0, ue = _e & 8191, ce = _e >>> 13, me = $[0] | 0, Ce = me & 8191, Be = me >>> 13, ze = $[1] | 0, Je = ze & 8191, Ze = ze >>> 13, Ke = $[2] | 0, x = Ke & 8191, se = Ke >>> 13, ge = $[3] | 0, xe = ge & 8191, Me = ge >>> 13, Ye = $[4] | 0, et = Ye & 8191, dt = Ye >>> 13, St = $[5] | 0, tt = St & 8191, at = St >>> 13, kt = $[6] | 0, rt = kt & 8191, ut = kt >>> 13, wt = $[7] | 0, nt = wt & 8191, it = wt >>> 13, bt = $[8] | 0, ot = bt & 8191, ct = bt >>> 13, Pt = $[9] | 0, st = Pt & 8191, lt = Pt >>> 13;
      I.negative = S.negative ^ E.negative, I.length = 19, L = Math.imul(pe, Ce), T = Math.imul(pe, Be), T = T + Math.imul(Ie, Ce) | 0, B = Math.imul(Ie, Be);
      var It = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (It >>> 26) | 0, It &= 67108863, L = Math.imul(ve, Ce), T = Math.imul(ve, Be), T = T + Math.imul(he, Ce) | 0, B = Math.imul(he, Be), L = L + Math.imul(pe, Je) | 0, T = T + Math.imul(pe, Ze) | 0, T = T + Math.imul(Ie, Je) | 0, B = B + Math.imul(Ie, Ze) | 0;
      var Rt = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (Rt >>> 26) | 0, Rt &= 67108863, L = Math.imul(Ae, Ce), T = Math.imul(Ae, Be), T = T + Math.imul(Ue, Ce) | 0, B = Math.imul(Ue, Be), L = L + Math.imul(ve, Je) | 0, T = T + Math.imul(ve, Ze) | 0, T = T + Math.imul(he, Je) | 0, B = B + Math.imul(he, Ze) | 0, L = L + Math.imul(pe, x) | 0, T = T + Math.imul(pe, se) | 0, T = T + Math.imul(Ie, x) | 0, B = B + Math.imul(Ie, se) | 0;
      var Ve = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, L = Math.imul(A, Ce), T = Math.imul(A, Be), T = T + Math.imul(re, Ce) | 0, B = Math.imul(re, Be), L = L + Math.imul(Ae, Je) | 0, T = T + Math.imul(Ae, Ze) | 0, T = T + Math.imul(Ue, Je) | 0, B = B + Math.imul(Ue, Ze) | 0, L = L + Math.imul(ve, x) | 0, T = T + Math.imul(ve, se) | 0, T = T + Math.imul(he, x) | 0, B = B + Math.imul(he, se) | 0, L = L + Math.imul(pe, xe) | 0, T = T + Math.imul(pe, Me) | 0, T = T + Math.imul(Ie, xe) | 0, B = B + Math.imul(Ie, Me) | 0;
      var He = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, L = Math.imul(Ne, Ce), T = Math.imul(Ne, Be), T = T + Math.imul(Pe, Ce) | 0, B = Math.imul(Pe, Be), L = L + Math.imul(A, Je) | 0, T = T + Math.imul(A, Ze) | 0, T = T + Math.imul(re, Je) | 0, B = B + Math.imul(re, Ze) | 0, L = L + Math.imul(Ae, x) | 0, T = T + Math.imul(Ae, se) | 0, T = T + Math.imul(Ue, x) | 0, B = B + Math.imul(Ue, se) | 0, L = L + Math.imul(ve, xe) | 0, T = T + Math.imul(ve, Me) | 0, T = T + Math.imul(he, xe) | 0, B = B + Math.imul(he, Me) | 0, L = L + Math.imul(pe, et) | 0, T = T + Math.imul(pe, dt) | 0, T = T + Math.imul(Ie, et) | 0, B = B + Math.imul(Ie, dt) | 0;
      var Qe = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, L = Math.imul(je, Ce), T = Math.imul(je, Be), T = T + Math.imul(qe, Ce) | 0, B = Math.imul(qe, Be), L = L + Math.imul(Ne, Je) | 0, T = T + Math.imul(Ne, Ze) | 0, T = T + Math.imul(Pe, Je) | 0, B = B + Math.imul(Pe, Ze) | 0, L = L + Math.imul(A, x) | 0, T = T + Math.imul(A, se) | 0, T = T + Math.imul(re, x) | 0, B = B + Math.imul(re, se) | 0, L = L + Math.imul(Ae, xe) | 0, T = T + Math.imul(Ae, Me) | 0, T = T + Math.imul(Ue, xe) | 0, B = B + Math.imul(Ue, Me) | 0, L = L + Math.imul(ve, et) | 0, T = T + Math.imul(ve, dt) | 0, T = T + Math.imul(he, et) | 0, B = B + Math.imul(he, dt) | 0, L = L + Math.imul(pe, tt) | 0, T = T + Math.imul(pe, at) | 0, T = T + Math.imul(Ie, tt) | 0, B = B + Math.imul(Ie, at) | 0;
      var pt = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (pt >>> 26) | 0, pt &= 67108863, L = Math.imul(Xe, Ce), T = Math.imul(Xe, Be), T = T + Math.imul(Ge, Ce) | 0, B = Math.imul(Ge, Be), L = L + Math.imul(je, Je) | 0, T = T + Math.imul(je, Ze) | 0, T = T + Math.imul(qe, Je) | 0, B = B + Math.imul(qe, Ze) | 0, L = L + Math.imul(Ne, x) | 0, T = T + Math.imul(Ne, se) | 0, T = T + Math.imul(Pe, x) | 0, B = B + Math.imul(Pe, se) | 0, L = L + Math.imul(A, xe) | 0, T = T + Math.imul(A, Me) | 0, T = T + Math.imul(re, xe) | 0, B = B + Math.imul(re, Me) | 0, L = L + Math.imul(Ae, et) | 0, T = T + Math.imul(Ae, dt) | 0, T = T + Math.imul(Ue, et) | 0, B = B + Math.imul(Ue, dt) | 0, L = L + Math.imul(ve, tt) | 0, T = T + Math.imul(ve, at) | 0, T = T + Math.imul(he, tt) | 0, B = B + Math.imul(he, at) | 0, L = L + Math.imul(pe, rt) | 0, T = T + Math.imul(pe, ut) | 0, T = T + Math.imul(Ie, rt) | 0, B = B + Math.imul(Ie, ut) | 0;
      var mt = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (mt >>> 26) | 0, mt &= 67108863, L = Math.imul(ye, Ce), T = Math.imul(ye, Be), T = T + Math.imul(Ee, Ce) | 0, B = Math.imul(Ee, Be), L = L + Math.imul(Xe, Je) | 0, T = T + Math.imul(Xe, Ze) | 0, T = T + Math.imul(Ge, Je) | 0, B = B + Math.imul(Ge, Ze) | 0, L = L + Math.imul(je, x) | 0, T = T + Math.imul(je, se) | 0, T = T + Math.imul(qe, x) | 0, B = B + Math.imul(qe, se) | 0, L = L + Math.imul(Ne, xe) | 0, T = T + Math.imul(Ne, Me) | 0, T = T + Math.imul(Pe, xe) | 0, B = B + Math.imul(Pe, Me) | 0, L = L + Math.imul(A, et) | 0, T = T + Math.imul(A, dt) | 0, T = T + Math.imul(re, et) | 0, B = B + Math.imul(re, dt) | 0, L = L + Math.imul(Ae, tt) | 0, T = T + Math.imul(Ae, at) | 0, T = T + Math.imul(Ue, tt) | 0, B = B + Math.imul(Ue, at) | 0, L = L + Math.imul(ve, rt) | 0, T = T + Math.imul(ve, ut) | 0, T = T + Math.imul(he, rt) | 0, B = B + Math.imul(he, ut) | 0, L = L + Math.imul(pe, nt) | 0, T = T + Math.imul(pe, it) | 0, T = T + Math.imul(Ie, nt) | 0, B = B + Math.imul(Ie, it) | 0;
      var vt = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, L = Math.imul(we, Ce), T = Math.imul(we, Be), T = T + Math.imul(V, Ce) | 0, B = Math.imul(V, Be), L = L + Math.imul(ye, Je) | 0, T = T + Math.imul(ye, Ze) | 0, T = T + Math.imul(Ee, Je) | 0, B = B + Math.imul(Ee, Ze) | 0, L = L + Math.imul(Xe, x) | 0, T = T + Math.imul(Xe, se) | 0, T = T + Math.imul(Ge, x) | 0, B = B + Math.imul(Ge, se) | 0, L = L + Math.imul(je, xe) | 0, T = T + Math.imul(je, Me) | 0, T = T + Math.imul(qe, xe) | 0, B = B + Math.imul(qe, Me) | 0, L = L + Math.imul(Ne, et) | 0, T = T + Math.imul(Ne, dt) | 0, T = T + Math.imul(Pe, et) | 0, B = B + Math.imul(Pe, dt) | 0, L = L + Math.imul(A, tt) | 0, T = T + Math.imul(A, at) | 0, T = T + Math.imul(re, tt) | 0, B = B + Math.imul(re, at) | 0, L = L + Math.imul(Ae, rt) | 0, T = T + Math.imul(Ae, ut) | 0, T = T + Math.imul(Ue, rt) | 0, B = B + Math.imul(Ue, ut) | 0, L = L + Math.imul(ve, nt) | 0, T = T + Math.imul(ve, it) | 0, T = T + Math.imul(he, nt) | 0, B = B + Math.imul(he, it) | 0, L = L + Math.imul(pe, ot) | 0, T = T + Math.imul(pe, ct) | 0, T = T + Math.imul(Ie, ot) | 0, B = B + Math.imul(Ie, ct) | 0;
      var ht = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (ht >>> 26) | 0, ht &= 67108863, L = Math.imul(ue, Ce), T = Math.imul(ue, Be), T = T + Math.imul(ce, Ce) | 0, B = Math.imul(ce, Be), L = L + Math.imul(we, Je) | 0, T = T + Math.imul(we, Ze) | 0, T = T + Math.imul(V, Je) | 0, B = B + Math.imul(V, Ze) | 0, L = L + Math.imul(ye, x) | 0, T = T + Math.imul(ye, se) | 0, T = T + Math.imul(Ee, x) | 0, B = B + Math.imul(Ee, se) | 0, L = L + Math.imul(Xe, xe) | 0, T = T + Math.imul(Xe, Me) | 0, T = T + Math.imul(Ge, xe) | 0, B = B + Math.imul(Ge, Me) | 0, L = L + Math.imul(je, et) | 0, T = T + Math.imul(je, dt) | 0, T = T + Math.imul(qe, et) | 0, B = B + Math.imul(qe, dt) | 0, L = L + Math.imul(Ne, tt) | 0, T = T + Math.imul(Ne, at) | 0, T = T + Math.imul(Pe, tt) | 0, B = B + Math.imul(Pe, at) | 0, L = L + Math.imul(A, rt) | 0, T = T + Math.imul(A, ut) | 0, T = T + Math.imul(re, rt) | 0, B = B + Math.imul(re, ut) | 0, L = L + Math.imul(Ae, nt) | 0, T = T + Math.imul(Ae, it) | 0, T = T + Math.imul(Ue, nt) | 0, B = B + Math.imul(Ue, it) | 0, L = L + Math.imul(ve, ot) | 0, T = T + Math.imul(ve, ct) | 0, T = T + Math.imul(he, ot) | 0, B = B + Math.imul(he, ct) | 0, L = L + Math.imul(pe, st) | 0, T = T + Math.imul(pe, lt) | 0, T = T + Math.imul(Ie, st) | 0, B = B + Math.imul(Ie, lt) | 0;
      var Et = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, L = Math.imul(ue, Je), T = Math.imul(ue, Ze), T = T + Math.imul(ce, Je) | 0, B = Math.imul(ce, Ze), L = L + Math.imul(we, x) | 0, T = T + Math.imul(we, se) | 0, T = T + Math.imul(V, x) | 0, B = B + Math.imul(V, se) | 0, L = L + Math.imul(ye, xe) | 0, T = T + Math.imul(ye, Me) | 0, T = T + Math.imul(Ee, xe) | 0, B = B + Math.imul(Ee, Me) | 0, L = L + Math.imul(Xe, et) | 0, T = T + Math.imul(Xe, dt) | 0, T = T + Math.imul(Ge, et) | 0, B = B + Math.imul(Ge, dt) | 0, L = L + Math.imul(je, tt) | 0, T = T + Math.imul(je, at) | 0, T = T + Math.imul(qe, tt) | 0, B = B + Math.imul(qe, at) | 0, L = L + Math.imul(Ne, rt) | 0, T = T + Math.imul(Ne, ut) | 0, T = T + Math.imul(Pe, rt) | 0, B = B + Math.imul(Pe, ut) | 0, L = L + Math.imul(A, nt) | 0, T = T + Math.imul(A, it) | 0, T = T + Math.imul(re, nt) | 0, B = B + Math.imul(re, it) | 0, L = L + Math.imul(Ae, ot) | 0, T = T + Math.imul(Ae, ct) | 0, T = T + Math.imul(Ue, ot) | 0, B = B + Math.imul(Ue, ct) | 0, L = L + Math.imul(ve, st) | 0, T = T + Math.imul(ve, lt) | 0, T = T + Math.imul(he, st) | 0, B = B + Math.imul(he, lt) | 0;
      var Tt = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (Tt >>> 26) | 0, Tt &= 67108863, L = Math.imul(ue, x), T = Math.imul(ue, se), T = T + Math.imul(ce, x) | 0, B = Math.imul(ce, se), L = L + Math.imul(we, xe) | 0, T = T + Math.imul(we, Me) | 0, T = T + Math.imul(V, xe) | 0, B = B + Math.imul(V, Me) | 0, L = L + Math.imul(ye, et) | 0, T = T + Math.imul(ye, dt) | 0, T = T + Math.imul(Ee, et) | 0, B = B + Math.imul(Ee, dt) | 0, L = L + Math.imul(Xe, tt) | 0, T = T + Math.imul(Xe, at) | 0, T = T + Math.imul(Ge, tt) | 0, B = B + Math.imul(Ge, at) | 0, L = L + Math.imul(je, rt) | 0, T = T + Math.imul(je, ut) | 0, T = T + Math.imul(qe, rt) | 0, B = B + Math.imul(qe, ut) | 0, L = L + Math.imul(Ne, nt) | 0, T = T + Math.imul(Ne, it) | 0, T = T + Math.imul(Pe, nt) | 0, B = B + Math.imul(Pe, it) | 0, L = L + Math.imul(A, ot) | 0, T = T + Math.imul(A, ct) | 0, T = T + Math.imul(re, ot) | 0, B = B + Math.imul(re, ct) | 0, L = L + Math.imul(Ae, st) | 0, T = T + Math.imul(Ae, lt) | 0, T = T + Math.imul(Ue, st) | 0, B = B + Math.imul(Ue, lt) | 0;
      var Ot = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (Ot >>> 26) | 0, Ot &= 67108863, L = Math.imul(ue, xe), T = Math.imul(ue, Me), T = T + Math.imul(ce, xe) | 0, B = Math.imul(ce, Me), L = L + Math.imul(we, et) | 0, T = T + Math.imul(we, dt) | 0, T = T + Math.imul(V, et) | 0, B = B + Math.imul(V, dt) | 0, L = L + Math.imul(ye, tt) | 0, T = T + Math.imul(ye, at) | 0, T = T + Math.imul(Ee, tt) | 0, B = B + Math.imul(Ee, at) | 0, L = L + Math.imul(Xe, rt) | 0, T = T + Math.imul(Xe, ut) | 0, T = T + Math.imul(Ge, rt) | 0, B = B + Math.imul(Ge, ut) | 0, L = L + Math.imul(je, nt) | 0, T = T + Math.imul(je, it) | 0, T = T + Math.imul(qe, nt) | 0, B = B + Math.imul(qe, it) | 0, L = L + Math.imul(Ne, ot) | 0, T = T + Math.imul(Ne, ct) | 0, T = T + Math.imul(Pe, ot) | 0, B = B + Math.imul(Pe, ct) | 0, L = L + Math.imul(A, st) | 0, T = T + Math.imul(A, lt) | 0, T = T + Math.imul(re, st) | 0, B = B + Math.imul(re, lt) | 0;
      var Nt = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, L = Math.imul(ue, et), T = Math.imul(ue, dt), T = T + Math.imul(ce, et) | 0, B = Math.imul(ce, dt), L = L + Math.imul(we, tt) | 0, T = T + Math.imul(we, at) | 0, T = T + Math.imul(V, tt) | 0, B = B + Math.imul(V, at) | 0, L = L + Math.imul(ye, rt) | 0, T = T + Math.imul(ye, ut) | 0, T = T + Math.imul(Ee, rt) | 0, B = B + Math.imul(Ee, ut) | 0, L = L + Math.imul(Xe, nt) | 0, T = T + Math.imul(Xe, it) | 0, T = T + Math.imul(Ge, nt) | 0, B = B + Math.imul(Ge, it) | 0, L = L + Math.imul(je, ot) | 0, T = T + Math.imul(je, ct) | 0, T = T + Math.imul(qe, ot) | 0, B = B + Math.imul(qe, ct) | 0, L = L + Math.imul(Ne, st) | 0, T = T + Math.imul(Ne, lt) | 0, T = T + Math.imul(Pe, st) | 0, B = B + Math.imul(Pe, lt) | 0;
      var At = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, L = Math.imul(ue, tt), T = Math.imul(ue, at), T = T + Math.imul(ce, tt) | 0, B = Math.imul(ce, at), L = L + Math.imul(we, rt) | 0, T = T + Math.imul(we, ut) | 0, T = T + Math.imul(V, rt) | 0, B = B + Math.imul(V, ut) | 0, L = L + Math.imul(ye, nt) | 0, T = T + Math.imul(ye, it) | 0, T = T + Math.imul(Ee, nt) | 0, B = B + Math.imul(Ee, it) | 0, L = L + Math.imul(Xe, ot) | 0, T = T + Math.imul(Xe, ct) | 0, T = T + Math.imul(Ge, ot) | 0, B = B + Math.imul(Ge, ct) | 0, L = L + Math.imul(je, st) | 0, T = T + Math.imul(je, lt) | 0, T = T + Math.imul(qe, st) | 0, B = B + Math.imul(qe, lt) | 0;
      var Mt = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (Mt >>> 26) | 0, Mt &= 67108863, L = Math.imul(ue, rt), T = Math.imul(ue, ut), T = T + Math.imul(ce, rt) | 0, B = Math.imul(ce, ut), L = L + Math.imul(we, nt) | 0, T = T + Math.imul(we, it) | 0, T = T + Math.imul(V, nt) | 0, B = B + Math.imul(V, it) | 0, L = L + Math.imul(ye, ot) | 0, T = T + Math.imul(ye, ct) | 0, T = T + Math.imul(Ee, ot) | 0, B = B + Math.imul(Ee, ct) | 0, L = L + Math.imul(Xe, st) | 0, T = T + Math.imul(Xe, lt) | 0, T = T + Math.imul(Ge, st) | 0, B = B + Math.imul(Ge, lt) | 0;
      var $t = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + ($t >>> 26) | 0, $t &= 67108863, L = Math.imul(ue, nt), T = Math.imul(ue, it), T = T + Math.imul(ce, nt) | 0, B = Math.imul(ce, it), L = L + Math.imul(we, ot) | 0, T = T + Math.imul(we, ct) | 0, T = T + Math.imul(V, ot) | 0, B = B + Math.imul(V, ct) | 0, L = L + Math.imul(ye, st) | 0, T = T + Math.imul(ye, lt) | 0, T = T + Math.imul(Ee, st) | 0, B = B + Math.imul(Ee, lt) | 0;
      var Bt = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, L = Math.imul(ue, ot), T = Math.imul(ue, ct), T = T + Math.imul(ce, ot) | 0, B = Math.imul(ce, ct), L = L + Math.imul(we, st) | 0, T = T + Math.imul(we, lt) | 0, T = T + Math.imul(V, st) | 0, B = B + Math.imul(V, lt) | 0;
      var Ut = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (Ut >>> 26) | 0, Ut &= 67108863, L = Math.imul(ue, st), T = Math.imul(ue, lt), T = T + Math.imul(ce, st) | 0, B = Math.imul(ce, lt);
      var xt = (Y + L | 0) + ((T & 8191) << 13) | 0;
      return Y = (B + (T >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, U[0] = It, U[1] = Rt, U[2] = Ve, U[3] = He, U[4] = Qe, U[5] = pt, U[6] = mt, U[7] = vt, U[8] = ht, U[9] = Et, U[10] = Tt, U[11] = Ot, U[12] = Nt, U[13] = At, U[14] = Mt, U[15] = $t, U[16] = Bt, U[17] = Ut, U[18] = xt, Y !== 0 && (U[19] = Y, I.length++), I;
    };
    Math.imul || (ae = X);
    function Q(C, S, E) {
      E.negative = S.negative ^ C.negative, E.length = C.length + S.length;
      for (var I = 0, M = 0, $ = 0; $ < E.length - 1; $++) {
        var U = M;
        M = 0;
        for (var Y = I & 67108863, L = Math.min($, S.length - 1), T = Math.max(0, $ - C.length + 1); T <= L; T++) {
          var B = $ - T, te = C.words[B] | 0, pe = S.words[T] | 0, Ie = te * pe, $e = Ie & 67108863;
          U = U + (Ie / 67108864 | 0) | 0, $e = $e + Y | 0, Y = $e & 67108863, U = U + ($e >>> 26) | 0, M += U >>> 26, U &= 67108863;
        }
        E.words[$] = Y, I = U, U = M;
      }
      return I !== 0 ? E.words[$] = I : E.length--, E.strip();
    }
    function ne(C, S, E) {
      var I = new Z();
      return I.mulp(C, S, E);
    }
    p.prototype.mulTo = function(S, E) {
      var I, M = this.length + S.length;
      return this.length === 10 && S.length === 10 ? I = ae(this, S, E) : M < 63 ? I = X(this, S, E) : M < 1024 ? I = Q(this, S, E) : I = ne(this, S, E), I;
    };
    function Z(C, S) {
      this.x = C, this.y = S;
    }
    Z.prototype.makeRBT = function(S) {
      for (var E = new Array(S), I = p.prototype._countBits(S) - 1, M = 0; M < S; M++)
        E[M] = this.revBin(M, I, S);
      return E;
    }, Z.prototype.revBin = function(S, E, I) {
      if (S === 0 || S === I - 1)
        return S;
      for (var M = 0, $ = 0; $ < E; $++)
        M |= (S & 1) << E - $ - 1, S >>= 1;
      return M;
    }, Z.prototype.permute = function(S, E, I, M, $, U) {
      for (var Y = 0; Y < U; Y++)
        M[Y] = E[S[Y]], $[Y] = I[S[Y]];
    }, Z.prototype.transform = function(S, E, I, M, $, U) {
      this.permute(U, S, E, I, M, $);
      for (var Y = 1; Y < $; Y <<= 1)
        for (var L = Y << 1, T = Math.cos(2 * Math.PI / L), B = Math.sin(2 * Math.PI / L), te = 0; te < $; te += L)
          for (var pe = T, Ie = B, $e = 0; $e < Y; $e++) {
            var ve = I[te + $e], he = M[te + $e], Oe = I[te + $e + Y], Ae = M[te + $e + Y], Ue = pe * Oe - Ie * Ae;
            Ae = pe * Ae + Ie * Oe, Oe = Ue, I[te + $e] = ve + Oe, M[te + $e] = he + Ae, I[te + $e + Y] = ve - Oe, M[te + $e + Y] = he - Ae, $e !== L && (Ue = T * pe - B * Ie, Ie = T * Ie + B * pe, pe = Ue);
          }
    }, Z.prototype.guessLen13b = function(S, E) {
      var I = Math.max(E, S) | 1, M = I & 1, $ = 0;
      for (I = I / 2 | 0; I; I = I >>> 1)
        $++;
      return 1 << $ + 1 + M;
    }, Z.prototype.conjugate = function(S, E, I) {
      if (!(I <= 1))
        for (var M = 0; M < I / 2; M++) {
          var $ = S[M];
          S[M] = S[I - M - 1], S[I - M - 1] = $, $ = E[M], E[M] = -E[I - M - 1], E[I - M - 1] = -$;
        }
    }, Z.prototype.normalize13b = function(S, E) {
      for (var I = 0, M = 0; M < E / 2; M++) {
        var $ = Math.round(S[2 * M + 1] / E) * 8192 + Math.round(S[2 * M] / E) + I;
        S[M] = $ & 67108863, $ < 67108864 ? I = 0 : I = $ / 67108864 | 0;
      }
      return S;
    }, Z.prototype.convert13b = function(S, E, I, M) {
      for (var $ = 0, U = 0; U < E; U++)
        $ = $ + (S[U] | 0), I[2 * U] = $ & 8191, $ = $ >>> 13, I[2 * U + 1] = $ & 8191, $ = $ >>> 13;
      for (U = 2 * E; U < M; ++U)
        I[U] = 0;
      l($ === 0), l(($ & -8192) === 0);
    }, Z.prototype.stub = function(S) {
      for (var E = new Array(S), I = 0; I < S; I++)
        E[I] = 0;
      return E;
    }, Z.prototype.mulp = function(S, E, I) {
      var M = 2 * this.guessLen13b(S.length, E.length), $ = this.makeRBT(M), U = this.stub(M), Y = new Array(M), L = new Array(M), T = new Array(M), B = new Array(M), te = new Array(M), pe = new Array(M), Ie = I.words;
      Ie.length = M, this.convert13b(S.words, S.length, Y, M), this.convert13b(E.words, E.length, B, M), this.transform(Y, U, L, T, M, $), this.transform(B, U, te, pe, M, $);
      for (var $e = 0; $e < M; $e++) {
        var ve = L[$e] * te[$e] - T[$e] * pe[$e];
        T[$e] = L[$e] * pe[$e] + T[$e] * te[$e], L[$e] = ve;
      }
      return this.conjugate(L, T, M), this.transform(L, T, Ie, U, M, $), this.conjugate(Ie, U, M), this.normalize13b(Ie, M), I.negative = S.negative ^ E.negative, I.length = S.length + E.length, I.strip();
    }, p.prototype.mul = function(S) {
      var E = new p(null);
      return E.words = new Array(this.length + S.length), this.mulTo(S, E);
    }, p.prototype.mulf = function(S) {
      var E = new p(null);
      return E.words = new Array(this.length + S.length), ne(this, S, E);
    }, p.prototype.imul = function(S) {
      return this.clone().mulTo(S, this);
    }, p.prototype.imuln = function(S) {
      l(typeof S == "number"), l(S < 67108864);
      for (var E = 0, I = 0; I < this.length; I++) {
        var M = (this.words[I] | 0) * S, $ = (M & 67108863) + (E & 67108863);
        E >>= 26, E += M / 67108864 | 0, E += $ >>> 26, this.words[I] = $ & 67108863;
      }
      return E !== 0 && (this.words[I] = E, this.length++), this;
    }, p.prototype.muln = function(S) {
      return this.clone().imuln(S);
    }, p.prototype.sqr = function() {
      return this.mul(this);
    }, p.prototype.isqr = function() {
      return this.imul(this.clone());
    }, p.prototype.pow = function(S) {
      var E = ee(S);
      if (E.length === 0)
        return new p(1);
      for (var I = this, M = 0; M < E.length && E[M] === 0; M++, I = I.sqr())
        ;
      if (++M < E.length)
        for (var $ = I.sqr(); M < E.length; M++, $ = $.sqr())
          E[M] !== 0 && (I = I.mul($));
      return I;
    }, p.prototype.iushln = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = S % 26, I = (S - E) / 26, M = 67108863 >>> 26 - E << 26 - E, $;
      if (E !== 0) {
        var U = 0;
        for ($ = 0; $ < this.length; $++) {
          var Y = this.words[$] & M, L = (this.words[$] | 0) - Y << E;
          this.words[$] = L | U, U = Y >>> 26 - E;
        }
        U && (this.words[$] = U, this.length++);
      }
      if (I !== 0) {
        for ($ = this.length - 1; $ >= 0; $--)
          this.words[$ + I] = this.words[$];
        for ($ = 0; $ < I; $++)
          this.words[$] = 0;
        this.length += I;
      }
      return this.strip();
    }, p.prototype.ishln = function(S) {
      return l(this.negative === 0), this.iushln(S);
    }, p.prototype.iushrn = function(S, E, I) {
      l(typeof S == "number" && S >= 0);
      var M;
      E ? M = (E - E % 26) / 26 : M = 0;
      var $ = S % 26, U = Math.min((S - $) / 26, this.length), Y = 67108863 ^ 67108863 >>> $ << $, L = I;
      if (M -= U, M = Math.max(0, M), L) {
        for (var T = 0; T < U; T++)
          L.words[T] = this.words[T];
        L.length = U;
      }
      if (U !== 0)
        if (this.length > U)
          for (this.length -= U, T = 0; T < this.length; T++)
            this.words[T] = this.words[T + U];
        else
          this.words[0] = 0, this.length = 1;
      var B = 0;
      for (T = this.length - 1; T >= 0 && (B !== 0 || T >= M); T--) {
        var te = this.words[T] | 0;
        this.words[T] = B << 26 - $ | te >>> $, B = te & Y;
      }
      return L && B !== 0 && (L.words[L.length++] = B), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, p.prototype.ishrn = function(S, E, I) {
      return l(this.negative === 0), this.iushrn(S, E, I);
    }, p.prototype.shln = function(S) {
      return this.clone().ishln(S);
    }, p.prototype.ushln = function(S) {
      return this.clone().iushln(S);
    }, p.prototype.shrn = function(S) {
      return this.clone().ishrn(S);
    }, p.prototype.ushrn = function(S) {
      return this.clone().iushrn(S);
    }, p.prototype.testn = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = S % 26, I = (S - E) / 26, M = 1 << E;
      if (this.length <= I)
        return !1;
      var $ = this.words[I];
      return !!($ & M);
    }, p.prototype.imaskn = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = S % 26, I = (S - E) / 26;
      if (l(this.negative === 0, "imaskn works only with positive numbers"), this.length <= I)
        return this;
      if (E !== 0 && I++, this.length = Math.min(I, this.length), E !== 0) {
        var M = 67108863 ^ 67108863 >>> E << E;
        this.words[this.length - 1] &= M;
      }
      return this.strip();
    }, p.prototype.maskn = function(S) {
      return this.clone().imaskn(S);
    }, p.prototype.iaddn = function(S) {
      return l(typeof S == "number"), l(S < 67108864), S < 0 ? this.isubn(-S) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < S ? (this.words[0] = S - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(S), this.negative = 1, this) : this._iaddn(S);
    }, p.prototype._iaddn = function(S) {
      this.words[0] += S;
      for (var E = 0; E < this.length && this.words[E] >= 67108864; E++)
        this.words[E] -= 67108864, E === this.length - 1 ? this.words[E + 1] = 1 : this.words[E + 1]++;
      return this.length = Math.max(this.length, E + 1), this;
    }, p.prototype.isubn = function(S) {
      if (l(typeof S == "number"), l(S < 67108864), S < 0)
        return this.iaddn(-S);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(S), this.negative = 1, this;
      if (this.words[0] -= S, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var E = 0; E < this.length && this.words[E] < 0; E++)
          this.words[E] += 67108864, this.words[E + 1] -= 1;
      return this.strip();
    }, p.prototype.addn = function(S) {
      return this.clone().iaddn(S);
    }, p.prototype.subn = function(S) {
      return this.clone().isubn(S);
    }, p.prototype.iabs = function() {
      return this.negative = 0, this;
    }, p.prototype.abs = function() {
      return this.clone().iabs();
    }, p.prototype._ishlnsubmul = function(S, E, I) {
      var M = S.length + I, $;
      this._expand(M);
      var U, Y = 0;
      for ($ = 0; $ < S.length; $++) {
        U = (this.words[$ + I] | 0) + Y;
        var L = (S.words[$] | 0) * E;
        U -= L & 67108863, Y = (U >> 26) - (L / 67108864 | 0), this.words[$ + I] = U & 67108863;
      }
      for (; $ < this.length - I; $++)
        U = (this.words[$ + I] | 0) + Y, Y = U >> 26, this.words[$ + I] = U & 67108863;
      if (Y === 0)
        return this.strip();
      for (l(Y === -1), Y = 0, $ = 0; $ < this.length; $++)
        U = -(this.words[$] | 0) + Y, Y = U >> 26, this.words[$] = U & 67108863;
      return this.negative = 1, this.strip();
    }, p.prototype._wordDiv = function(S, E) {
      var I = this.length - S.length, M = this.clone(), $ = S, U = $.words[$.length - 1] | 0, Y = this._countBits(U);
      I = 26 - Y, I !== 0 && ($ = $.ushln(I), M.iushln(I), U = $.words[$.length - 1] | 0);
      var L = M.length - $.length, T;
      if (E !== "mod") {
        T = new p(null), T.length = L + 1, T.words = new Array(T.length);
        for (var B = 0; B < T.length; B++)
          T.words[B] = 0;
      }
      var te = M.clone()._ishlnsubmul($, 1, L);
      te.negative === 0 && (M = te, T && (T.words[L] = 1));
      for (var pe = L - 1; pe >= 0; pe--) {
        var Ie = (M.words[$.length + pe] | 0) * 67108864 + (M.words[$.length + pe - 1] | 0);
        for (Ie = Math.min(Ie / U | 0, 67108863), M._ishlnsubmul($, Ie, pe); M.negative !== 0; )
          Ie--, M.negative = 0, M._ishlnsubmul($, 1, pe), M.isZero() || (M.negative ^= 1);
        T && (T.words[pe] = Ie);
      }
      return T && T.strip(), M.strip(), E !== "div" && I !== 0 && M.iushrn(I), {
        div: T || null,
        mod: M
      };
    }, p.prototype.divmod = function(S, E, I) {
      if (l(!S.isZero()), this.isZero())
        return {
          div: new p(0),
          mod: new p(0)
        };
      var M, $, U;
      return this.negative !== 0 && S.negative === 0 ? (U = this.neg().divmod(S, E), E !== "mod" && (M = U.div.neg()), E !== "div" && ($ = U.mod.neg(), I && $.negative !== 0 && $.iadd(S)), {
        div: M,
        mod: $
      }) : this.negative === 0 && S.negative !== 0 ? (U = this.divmod(S.neg(), E), E !== "mod" && (M = U.div.neg()), {
        div: M,
        mod: U.mod
      }) : this.negative & S.negative ? (U = this.neg().divmod(S.neg(), E), E !== "div" && ($ = U.mod.neg(), I && $.negative !== 0 && $.isub(S)), {
        div: U.div,
        mod: $
      }) : S.length > this.length || this.cmp(S) < 0 ? {
        div: new p(0),
        mod: this
      } : S.length === 1 ? E === "div" ? {
        div: this.divn(S.words[0]),
        mod: null
      } : E === "mod" ? {
        div: null,
        mod: new p(this.modn(S.words[0]))
      } : {
        div: this.divn(S.words[0]),
        mod: new p(this.modn(S.words[0]))
      } : this._wordDiv(S, E);
    }, p.prototype.div = function(S) {
      return this.divmod(S, "div", !1).div;
    }, p.prototype.mod = function(S) {
      return this.divmod(S, "mod", !1).mod;
    }, p.prototype.umod = function(S) {
      return this.divmod(S, "mod", !0).mod;
    }, p.prototype.divRound = function(S) {
      var E = this.divmod(S);
      if (E.mod.isZero())
        return E.div;
      var I = E.div.negative !== 0 ? E.mod.isub(S) : E.mod, M = S.ushrn(1), $ = S.andln(1), U = I.cmp(M);
      return U < 0 || $ === 1 && U === 0 ? E.div : E.div.negative !== 0 ? E.div.isubn(1) : E.div.iaddn(1);
    }, p.prototype.modn = function(S) {
      l(S <= 67108863);
      for (var E = (1 << 26) % S, I = 0, M = this.length - 1; M >= 0; M--)
        I = (E * I + (this.words[M] | 0)) % S;
      return I;
    }, p.prototype.idivn = function(S) {
      l(S <= 67108863);
      for (var E = 0, I = this.length - 1; I >= 0; I--) {
        var M = (this.words[I] | 0) + E * 67108864;
        this.words[I] = M / S | 0, E = M % S;
      }
      return this.strip();
    }, p.prototype.divn = function(S) {
      return this.clone().idivn(S);
    }, p.prototype.egcd = function(S) {
      l(S.negative === 0), l(!S.isZero());
      var E = this, I = S.clone();
      E.negative !== 0 ? E = E.umod(S) : E = E.clone();
      for (var M = new p(1), $ = new p(0), U = new p(0), Y = new p(1), L = 0; E.isEven() && I.isEven(); )
        E.iushrn(1), I.iushrn(1), ++L;
      for (var T = I.clone(), B = E.clone(); !E.isZero(); ) {
        for (var te = 0, pe = 1; !(E.words[0] & pe) && te < 26; ++te, pe <<= 1)
          ;
        if (te > 0)
          for (E.iushrn(te); te-- > 0; )
            (M.isOdd() || $.isOdd()) && (M.iadd(T), $.isub(B)), M.iushrn(1), $.iushrn(1);
        for (var Ie = 0, $e = 1; !(I.words[0] & $e) && Ie < 26; ++Ie, $e <<= 1)
          ;
        if (Ie > 0)
          for (I.iushrn(Ie); Ie-- > 0; )
            (U.isOdd() || Y.isOdd()) && (U.iadd(T), Y.isub(B)), U.iushrn(1), Y.iushrn(1);
        E.cmp(I) >= 0 ? (E.isub(I), M.isub(U), $.isub(Y)) : (I.isub(E), U.isub(M), Y.isub($));
      }
      return {
        a: U,
        b: Y,
        gcd: I.iushln(L)
      };
    }, p.prototype._invmp = function(S) {
      l(S.negative === 0), l(!S.isZero());
      var E = this, I = S.clone();
      E.negative !== 0 ? E = E.umod(S) : E = E.clone();
      for (var M = new p(1), $ = new p(0), U = I.clone(); E.cmpn(1) > 0 && I.cmpn(1) > 0; ) {
        for (var Y = 0, L = 1; !(E.words[0] & L) && Y < 26; ++Y, L <<= 1)
          ;
        if (Y > 0)
          for (E.iushrn(Y); Y-- > 0; )
            M.isOdd() && M.iadd(U), M.iushrn(1);
        for (var T = 0, B = 1; !(I.words[0] & B) && T < 26; ++T, B <<= 1)
          ;
        if (T > 0)
          for (I.iushrn(T); T-- > 0; )
            $.isOdd() && $.iadd(U), $.iushrn(1);
        E.cmp(I) >= 0 ? (E.isub(I), M.isub($)) : (I.isub(E), $.isub(M));
      }
      var te;
      return E.cmpn(1) === 0 ? te = M : te = $, te.cmpn(0) < 0 && te.iadd(S), te;
    }, p.prototype.gcd = function(S) {
      if (this.isZero())
        return S.abs();
      if (S.isZero())
        return this.abs();
      var E = this.clone(), I = S.clone();
      E.negative = 0, I.negative = 0;
      for (var M = 0; E.isEven() && I.isEven(); M++)
        E.iushrn(1), I.iushrn(1);
      do {
        for (; E.isEven(); )
          E.iushrn(1);
        for (; I.isEven(); )
          I.iushrn(1);
        var $ = E.cmp(I);
        if ($ < 0) {
          var U = E;
          E = I, I = U;
        } else if ($ === 0 || I.cmpn(1) === 0)
          break;
        E.isub(I);
      } while (!0);
      return I.iushln(M);
    }, p.prototype.invm = function(S) {
      return this.egcd(S).a.umod(S);
    }, p.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, p.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, p.prototype.andln = function(S) {
      return this.words[0] & S;
    }, p.prototype.bincn = function(S) {
      l(typeof S == "number");
      var E = S % 26, I = (S - E) / 26, M = 1 << E;
      if (this.length <= I)
        return this._expand(I + 1), this.words[I] |= M, this;
      for (var $ = M, U = I; $ !== 0 && U < this.length; U++) {
        var Y = this.words[U] | 0;
        Y += $, $ = Y >>> 26, Y &= 67108863, this.words[U] = Y;
      }
      return $ !== 0 && (this.words[U] = $, this.length++), this;
    }, p.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, p.prototype.cmpn = function(S) {
      var E = S < 0;
      if (this.negative !== 0 && !E)
        return -1;
      if (this.negative === 0 && E)
        return 1;
      this.strip();
      var I;
      if (this.length > 1)
        I = 1;
      else {
        E && (S = -S), l(S <= 67108863, "Number is too big");
        var M = this.words[0] | 0;
        I = M === S ? 0 : M < S ? -1 : 1;
      }
      return this.negative !== 0 ? -I | 0 : I;
    }, p.prototype.cmp = function(S) {
      if (this.negative !== 0 && S.negative === 0)
        return -1;
      if (this.negative === 0 && S.negative !== 0)
        return 1;
      var E = this.ucmp(S);
      return this.negative !== 0 ? -E | 0 : E;
    }, p.prototype.ucmp = function(S) {
      if (this.length > S.length)
        return 1;
      if (this.length < S.length)
        return -1;
      for (var E = 0, I = this.length - 1; I >= 0; I--) {
        var M = this.words[I] | 0, $ = S.words[I] | 0;
        if (M !== $) {
          M < $ ? E = -1 : M > $ && (E = 1);
          break;
        }
      }
      return E;
    }, p.prototype.gtn = function(S) {
      return this.cmpn(S) === 1;
    }, p.prototype.gt = function(S) {
      return this.cmp(S) === 1;
    }, p.prototype.gten = function(S) {
      return this.cmpn(S) >= 0;
    }, p.prototype.gte = function(S) {
      return this.cmp(S) >= 0;
    }, p.prototype.ltn = function(S) {
      return this.cmpn(S) === -1;
    }, p.prototype.lt = function(S) {
      return this.cmp(S) === -1;
    }, p.prototype.lten = function(S) {
      return this.cmpn(S) <= 0;
    }, p.prototype.lte = function(S) {
      return this.cmp(S) <= 0;
    }, p.prototype.eqn = function(S) {
      return this.cmpn(S) === 0;
    }, p.prototype.eq = function(S) {
      return this.cmp(S) === 0;
    }, p.red = function(S) {
      return new q(S);
    }, p.prototype.toRed = function(S) {
      return l(!this.red, "Already a number in reduction context"), l(this.negative === 0, "red works only with positives"), S.convertTo(this)._forceRed(S);
    }, p.prototype.fromRed = function() {
      return l(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, p.prototype._forceRed = function(S) {
      return this.red = S, this;
    }, p.prototype.forceRed = function(S) {
      return l(!this.red, "Already a number in reduction context"), this._forceRed(S);
    }, p.prototype.redAdd = function(S) {
      return l(this.red, "redAdd works only with red numbers"), this.red.add(this, S);
    }, p.prototype.redIAdd = function(S) {
      return l(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, S);
    }, p.prototype.redSub = function(S) {
      return l(this.red, "redSub works only with red numbers"), this.red.sub(this, S);
    }, p.prototype.redISub = function(S) {
      return l(this.red, "redISub works only with red numbers"), this.red.isub(this, S);
    }, p.prototype.redShl = function(S) {
      return l(this.red, "redShl works only with red numbers"), this.red.shl(this, S);
    }, p.prototype.redMul = function(S) {
      return l(this.red, "redMul works only with red numbers"), this.red._verify2(this, S), this.red.mul(this, S);
    }, p.prototype.redIMul = function(S) {
      return l(this.red, "redMul works only with red numbers"), this.red._verify2(this, S), this.red.imul(this, S);
    }, p.prototype.redSqr = function() {
      return l(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, p.prototype.redISqr = function() {
      return l(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, p.prototype.redSqrt = function() {
      return l(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, p.prototype.redInvm = function() {
      return l(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, p.prototype.redNeg = function() {
      return l(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, p.prototype.redPow = function(S) {
      return l(this.red && !S.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, S);
    };
    var de = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function fe(C, S) {
      this.name = C, this.p = new p(S, 16), this.n = this.p.bitLength(), this.k = new p(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    fe.prototype._tmp = function() {
      var S = new p(null);
      return S.words = new Array(Math.ceil(this.n / 13)), S;
    }, fe.prototype.ireduce = function(S) {
      var E = S, I;
      do
        this.split(E, this.tmp), E = this.imulK(E), E = E.iadd(this.tmp), I = E.bitLength();
      while (I > this.n);
      var M = I < this.n ? -1 : E.ucmp(this.p);
      return M === 0 ? (E.words[0] = 0, E.length = 1) : M > 0 ? E.isub(this.p) : E.strip !== void 0 ? E.strip() : E._strip(), E;
    }, fe.prototype.split = function(S, E) {
      S.iushrn(this.n, 0, E);
    }, fe.prototype.imulK = function(S) {
      return S.imul(this.k);
    };
    function Te() {
      fe.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    v(Te, fe), Te.prototype.split = function(S, E) {
      for (var I = 4194303, M = Math.min(S.length, 9), $ = 0; $ < M; $++)
        E.words[$] = S.words[$];
      if (E.length = M, S.length <= 9) {
        S.words[0] = 0, S.length = 1;
        return;
      }
      var U = S.words[9];
      for (E.words[E.length++] = U & I, $ = 10; $ < S.length; $++) {
        var Y = S.words[$] | 0;
        S.words[$ - 10] = (Y & I) << 4 | U >>> 22, U = Y;
      }
      U >>>= 22, S.words[$ - 10] = U, U === 0 && S.length > 10 ? S.length -= 10 : S.length -= 9;
    }, Te.prototype.imulK = function(S) {
      S.words[S.length] = 0, S.words[S.length + 1] = 0, S.length += 2;
      for (var E = 0, I = 0; I < S.length; I++) {
        var M = S.words[I] | 0;
        E += M * 977, S.words[I] = E & 67108863, E = M * 64 + (E / 67108864 | 0);
      }
      return S.words[S.length - 1] === 0 && (S.length--, S.words[S.length - 1] === 0 && S.length--), S;
    };
    function Re() {
      fe.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    v(Re, fe);
    function Le() {
      fe.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    v(Le, fe);
    function be() {
      fe.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    v(be, fe), be.prototype.imulK = function(S) {
      for (var E = 0, I = 0; I < S.length; I++) {
        var M = (S.words[I] | 0) * 19 + E, $ = M & 67108863;
        M >>>= 26, S.words[I] = $, E = M;
      }
      return E !== 0 && (S.words[S.length++] = E), S;
    }, p._prime = function(S) {
      if (de[S])
        return de[S];
      var E;
      if (S === "k256")
        E = new Te();
      else if (S === "p224")
        E = new Re();
      else if (S === "p192")
        E = new Le();
      else if (S === "p25519")
        E = new be();
      else
        throw new Error("Unknown prime " + S);
      return de[S] = E, E;
    };
    function q(C) {
      if (typeof C == "string") {
        var S = p._prime(C);
        this.m = S.p, this.prime = S;
      } else
        l(C.gtn(1), "modulus must be greater than 1"), this.m = C, this.prime = null;
    }
    q.prototype._verify1 = function(S) {
      l(S.negative === 0, "red works only with positives"), l(S.red, "red works only with red numbers");
    }, q.prototype._verify2 = function(S, E) {
      l((S.negative | E.negative) === 0, "red works only with positives"), l(
        S.red && S.red === E.red,
        "red works only with red numbers"
      );
    }, q.prototype.imod = function(S) {
      return this.prime ? this.prime.ireduce(S)._forceRed(this) : S.umod(this.m)._forceRed(this);
    }, q.prototype.neg = function(S) {
      return S.isZero() ? S.clone() : this.m.sub(S)._forceRed(this);
    }, q.prototype.add = function(S, E) {
      this._verify2(S, E);
      var I = S.add(E);
      return I.cmp(this.m) >= 0 && I.isub(this.m), I._forceRed(this);
    }, q.prototype.iadd = function(S, E) {
      this._verify2(S, E);
      var I = S.iadd(E);
      return I.cmp(this.m) >= 0 && I.isub(this.m), I;
    }, q.prototype.sub = function(S, E) {
      this._verify2(S, E);
      var I = S.sub(E);
      return I.cmpn(0) < 0 && I.iadd(this.m), I._forceRed(this);
    }, q.prototype.isub = function(S, E) {
      this._verify2(S, E);
      var I = S.isub(E);
      return I.cmpn(0) < 0 && I.iadd(this.m), I;
    }, q.prototype.shl = function(S, E) {
      return this._verify1(S), this.imod(S.ushln(E));
    }, q.prototype.imul = function(S, E) {
      return this._verify2(S, E), this.imod(S.imul(E));
    }, q.prototype.mul = function(S, E) {
      return this._verify2(S, E), this.imod(S.mul(E));
    }, q.prototype.isqr = function(S) {
      return this.imul(S, S.clone());
    }, q.prototype.sqr = function(S) {
      return this.mul(S, S);
    }, q.prototype.sqrt = function(S) {
      if (S.isZero())
        return S.clone();
      var E = this.m.andln(3);
      if (l(E % 2 === 1), E === 3) {
        var I = this.m.add(new p(1)).iushrn(2);
        return this.pow(S, I);
      }
      for (var M = this.m.subn(1), $ = 0; !M.isZero() && M.andln(1) === 0; )
        $++, M.iushrn(1);
      l(!M.isZero());
      var U = new p(1).toRed(this), Y = U.redNeg(), L = this.m.subn(1).iushrn(1), T = this.m.bitLength();
      for (T = new p(2 * T * T).toRed(this); this.pow(T, L).cmp(Y) !== 0; )
        T.redIAdd(Y);
      for (var B = this.pow(T, M), te = this.pow(S, M.addn(1).iushrn(1)), pe = this.pow(S, M), Ie = $; pe.cmp(U) !== 0; ) {
        for (var $e = pe, ve = 0; $e.cmp(U) !== 0; ve++)
          $e = $e.redSqr();
        l(ve < Ie);
        var he = this.pow(B, new p(1).iushln(Ie - ve - 1));
        te = te.redMul(he), B = he.redSqr(), pe = pe.redMul(B), Ie = ve;
      }
      return te;
    }, q.prototype.invm = function(S) {
      var E = S._invmp(this.m);
      return E.negative !== 0 ? (E.negative = 0, this.imod(E).redNeg()) : this.imod(E);
    }, q.prototype.pow = function(S, E) {
      if (E.isZero())
        return new p(1).toRed(this);
      if (E.cmpn(1) === 0)
        return S.clone();
      var I = 4, M = new Array(1 << I);
      M[0] = new p(1).toRed(this), M[1] = S;
      for (var $ = 2; $ < M.length; $++)
        M[$] = this.mul(M[$ - 1], S);
      var U = M[0], Y = 0, L = 0, T = E.bitLength() % 26;
      for (T === 0 && (T = 26), $ = E.length - 1; $ >= 0; $--) {
        for (var B = E.words[$], te = T - 1; te >= 0; te--) {
          var pe = B >> te & 1;
          if (U !== M[0] && (U = this.sqr(U)), pe === 0 && Y === 0) {
            L = 0;
            continue;
          }
          Y <<= 1, Y |= pe, L++, !(L !== I && ($ !== 0 || te !== 0)) && (U = this.mul(U, M[Y]), L = 0, Y = 0);
        }
        T = 26;
      }
      return U;
    }, q.prototype.convertTo = function(S) {
      var E = S.umod(this.m);
      return E === S ? E.clone() : E;
    }, q.prototype.convertFrom = function(S) {
      var E = S.clone();
      return E.red = null, E;
    }, p.mont = function(S) {
      return new J(S);
    };
    function J(C) {
      q.call(this, C), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new p(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    v(J, q), J.prototype.convertTo = function(S) {
      return this.imod(S.ushln(this.shift));
    }, J.prototype.convertFrom = function(S) {
      var E = this.imod(S.mul(this.rinv));
      return E.red = null, E;
    }, J.prototype.imul = function(S, E) {
      if (S.isZero() || E.isZero())
        return S.words[0] = 0, S.length = 1, S;
      var I = S.imul(E), M = I.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), $ = I.isub(M).iushrn(this.shift), U = $;
      return $.cmp(this.m) >= 0 ? U = $.isub(this.m) : $.cmpn(0) < 0 && (U = $.iadd(this.m)), U._forceRed(this);
    }, J.prototype.mul = function(S, E) {
      if (S.isZero() || E.isZero())
        return new p(0)._forceRed(this);
      var I = S.mul(E), M = I.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), $ = I.isub(M).iushrn(this.shift), U = $;
      return $.cmp(this.m) >= 0 ? U = $.isub(this.m) : $.cmpn(0) < 0 && (U = $.iadd(this.m)), U._forceRed(this);
    }, J.prototype.invm = function(S) {
      var E = this.imod(S._invmp(this.m).mul(this.r2));
      return E._forceRed(this);
    };
  })(a, commonjsGlobal$1);
})(bn$6);
var bnExports$6 = bn$6.exports, bn$5 = { exports: {} };
bn$5.exports;
(function(a) {
  (function(u, c) {
    function l(C, S) {
      if (!C)
        throw new Error(S || "Assertion failed");
    }
    function v(C, S) {
      C.super_ = S;
      var E = function() {
      };
      E.prototype = S.prototype, C.prototype = new E(), C.prototype.constructor = C;
    }
    function p(C, S, E) {
      if (p.isBN(C))
        return C;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, C !== null && ((S === "le" || S === "be") && (E = S, S = 10), this._init(C || 0, S || 10, E || "be"));
    }
    typeof u == "object" ? u.exports = p : c.BN = p, p.BN = p, p.wordSize = 26;
    var _;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? _ = window.Buffer : _ = require$$0$2.Buffer;
    } catch {
    }
    p.isBN = function(S) {
      return S instanceof p ? !0 : S !== null && typeof S == "object" && S.constructor.wordSize === p.wordSize && Array.isArray(S.words);
    }, p.max = function(S, E) {
      return S.cmp(E) > 0 ? S : E;
    }, p.min = function(S, E) {
      return S.cmp(E) < 0 ? S : E;
    }, p.prototype._init = function(S, E, I) {
      if (typeof S == "number")
        return this._initNumber(S, E, I);
      if (typeof S == "object")
        return this._initArray(S, E, I);
      E === "hex" && (E = 16), l(E === (E | 0) && E >= 2 && E <= 36), S = S.toString().replace(/\s+/g, "");
      var M = 0;
      S[0] === "-" && (M++, this.negative = 1), M < S.length && (E === 16 ? this._parseHex(S, M, I) : (this._parseBase(S, E, M), I === "le" && this._initArray(this.toArray(), E, I)));
    }, p.prototype._initNumber = function(S, E, I) {
      S < 0 && (this.negative = 1, S = -S), S < 67108864 ? (this.words = [S & 67108863], this.length = 1) : S < 4503599627370496 ? (this.words = [
        S & 67108863,
        S / 67108864 & 67108863
      ], this.length = 2) : (l(S < 9007199254740992), this.words = [
        S & 67108863,
        S / 67108864 & 67108863,
        1
      ], this.length = 3), I === "le" && this._initArray(this.toArray(), E, I);
    }, p.prototype._initArray = function(S, E, I) {
      if (l(typeof S.length == "number"), S.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(S.length / 3), this.words = new Array(this.length);
      for (var M = 0; M < this.length; M++)
        this.words[M] = 0;
      var $, U, Y = 0;
      if (I === "be")
        for (M = S.length - 1, $ = 0; M >= 0; M -= 3)
          U = S[M] | S[M - 1] << 8 | S[M - 2] << 16, this.words[$] |= U << Y & 67108863, this.words[$ + 1] = U >>> 26 - Y & 67108863, Y += 24, Y >= 26 && (Y -= 26, $++);
      else if (I === "le")
        for (M = 0, $ = 0; M < S.length; M += 3)
          U = S[M] | S[M + 1] << 8 | S[M + 2] << 16, this.words[$] |= U << Y & 67108863, this.words[$ + 1] = U >>> 26 - Y & 67108863, Y += 24, Y >= 26 && (Y -= 26, $++);
      return this.strip();
    };
    function k(C, S) {
      var E = C.charCodeAt(S);
      return E >= 65 && E <= 70 ? E - 55 : E >= 97 && E <= 102 ? E - 87 : E - 48 & 15;
    }
    function O(C, S, E) {
      var I = k(C, E);
      return E - 1 >= S && (I |= k(C, E - 1) << 4), I;
    }
    p.prototype._parseHex = function(S, E, I) {
      this.length = Math.ceil((S.length - E) / 6), this.words = new Array(this.length);
      for (var M = 0; M < this.length; M++)
        this.words[M] = 0;
      var $ = 0, U = 0, Y;
      if (I === "be")
        for (M = S.length - 1; M >= E; M -= 2)
          Y = O(S, E, M) << $, this.words[U] |= Y & 67108863, $ >= 18 ? ($ -= 18, U += 1, this.words[U] |= Y >>> 26) : $ += 8;
      else {
        var L = S.length - E;
        for (M = L % 2 === 0 ? E + 1 : E; M < S.length; M += 2)
          Y = O(S, E, M) << $, this.words[U] |= Y & 67108863, $ >= 18 ? ($ -= 18, U += 1, this.words[U] |= Y >>> 26) : $ += 8;
      }
      this.strip();
    };
    function D(C, S, E, I) {
      for (var M = 0, $ = Math.min(C.length, E), U = S; U < $; U++) {
        var Y = C.charCodeAt(U) - 48;
        M *= I, Y >= 49 ? M += Y - 49 + 10 : Y >= 17 ? M += Y - 17 + 10 : M += Y;
      }
      return M;
    }
    p.prototype._parseBase = function(S, E, I) {
      this.words = [0], this.length = 1;
      for (var M = 0, $ = 1; $ <= 67108863; $ *= E)
        M++;
      M--, $ = $ / E | 0;
      for (var U = S.length - I, Y = U % M, L = Math.min(U, U - Y) + I, T = 0, B = I; B < L; B += M)
        T = D(S, B, B + M, E), this.imuln($), this.words[0] + T < 67108864 ? this.words[0] += T : this._iaddn(T);
      if (Y !== 0) {
        var te = 1;
        for (T = D(S, B, S.length, E), B = 0; B < Y; B++)
          te *= E;
        this.imuln(te), this.words[0] + T < 67108864 ? this.words[0] += T : this._iaddn(T);
      }
      this.strip();
    }, p.prototype.copy = function(S) {
      S.words = new Array(this.length);
      for (var E = 0; E < this.length; E++)
        S.words[E] = this.words[E];
      S.length = this.length, S.negative = this.negative, S.red = this.red;
    }, p.prototype.clone = function() {
      var S = new p(null);
      return this.copy(S), S;
    }, p.prototype._expand = function(S) {
      for (; this.length < S; )
        this.words[this.length++] = 0;
      return this;
    }, p.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, p.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, p.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var F = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], z = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], j = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    p.prototype.toString = function(S, E) {
      S = S || 10, E = E | 0 || 1;
      var I;
      if (S === 16 || S === "hex") {
        I = "";
        for (var M = 0, $ = 0, U = 0; U < this.length; U++) {
          var Y = this.words[U], L = ((Y << M | $) & 16777215).toString(16);
          $ = Y >>> 24 - M & 16777215, $ !== 0 || U !== this.length - 1 ? I = F[6 - L.length] + L + I : I = L + I, M += 2, M >= 26 && (M -= 26, U--);
        }
        for ($ !== 0 && (I = $.toString(16) + I); I.length % E !== 0; )
          I = "0" + I;
        return this.negative !== 0 && (I = "-" + I), I;
      }
      if (S === (S | 0) && S >= 2 && S <= 36) {
        var T = z[S], B = j[S];
        I = "";
        var te = this.clone();
        for (te.negative = 0; !te.isZero(); ) {
          var pe = te.modn(B).toString(S);
          te = te.idivn(B), te.isZero() ? I = pe + I : I = F[T - pe.length] + pe + I;
        }
        for (this.isZero() && (I = "0" + I); I.length % E !== 0; )
          I = "0" + I;
        return this.negative !== 0 && (I = "-" + I), I;
      }
      l(!1, "Base should be between 2 and 36");
    }, p.prototype.toNumber = function() {
      var S = this.words[0];
      return this.length === 2 ? S += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? S += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && l(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -S : S;
    }, p.prototype.toJSON = function() {
      return this.toString(16);
    }, p.prototype.toBuffer = function(S, E) {
      return l(typeof _ < "u"), this.toArrayLike(_, S, E);
    }, p.prototype.toArray = function(S, E) {
      return this.toArrayLike(Array, S, E);
    }, p.prototype.toArrayLike = function(S, E, I) {
      var M = this.byteLength(), $ = I || Math.max(1, M);
      l(M <= $, "byte array longer than desired length"), l($ > 0, "Requested array length <= 0"), this.strip();
      var U = E === "le", Y = new S($), L, T, B = this.clone();
      if (U) {
        for (T = 0; !B.isZero(); T++)
          L = B.andln(255), B.iushrn(8), Y[T] = L;
        for (; T < $; T++)
          Y[T] = 0;
      } else {
        for (T = 0; T < $ - M; T++)
          Y[T] = 0;
        for (T = 0; !B.isZero(); T++)
          L = B.andln(255), B.iushrn(8), Y[$ - T - 1] = L;
      }
      return Y;
    }, Math.clz32 ? p.prototype._countBits = function(S) {
      return 32 - Math.clz32(S);
    } : p.prototype._countBits = function(S) {
      var E = S, I = 0;
      return E >= 4096 && (I += 13, E >>>= 13), E >= 64 && (I += 7, E >>>= 7), E >= 8 && (I += 4, E >>>= 4), E >= 2 && (I += 2, E >>>= 2), I + E;
    }, p.prototype._zeroBits = function(S) {
      if (S === 0)
        return 26;
      var E = S, I = 0;
      return E & 8191 || (I += 13, E >>>= 13), E & 127 || (I += 7, E >>>= 7), E & 15 || (I += 4, E >>>= 4), E & 3 || (I += 2, E >>>= 2), E & 1 || I++, I;
    }, p.prototype.bitLength = function() {
      var S = this.words[this.length - 1], E = this._countBits(S);
      return (this.length - 1) * 26 + E;
    };
    function ee(C) {
      for (var S = new Array(C.bitLength()), E = 0; E < S.length; E++) {
        var I = E / 26 | 0, M = E % 26;
        S[E] = (C.words[I] & 1 << M) >>> M;
      }
      return S;
    }
    p.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var S = 0, E = 0; E < this.length; E++) {
        var I = this._zeroBits(this.words[E]);
        if (S += I, I !== 26)
          break;
      }
      return S;
    }, p.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, p.prototype.toTwos = function(S) {
      return this.negative !== 0 ? this.abs().inotn(S).iaddn(1) : this.clone();
    }, p.prototype.fromTwos = function(S) {
      return this.testn(S - 1) ? this.notn(S).iaddn(1).ineg() : this.clone();
    }, p.prototype.isNeg = function() {
      return this.negative !== 0;
    }, p.prototype.neg = function() {
      return this.clone().ineg();
    }, p.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, p.prototype.iuor = function(S) {
      for (; this.length < S.length; )
        this.words[this.length++] = 0;
      for (var E = 0; E < S.length; E++)
        this.words[E] = this.words[E] | S.words[E];
      return this.strip();
    }, p.prototype.ior = function(S) {
      return l((this.negative | S.negative) === 0), this.iuor(S);
    }, p.prototype.or = function(S) {
      return this.length > S.length ? this.clone().ior(S) : S.clone().ior(this);
    }, p.prototype.uor = function(S) {
      return this.length > S.length ? this.clone().iuor(S) : S.clone().iuor(this);
    }, p.prototype.iuand = function(S) {
      var E;
      this.length > S.length ? E = S : E = this;
      for (var I = 0; I < E.length; I++)
        this.words[I] = this.words[I] & S.words[I];
      return this.length = E.length, this.strip();
    }, p.prototype.iand = function(S) {
      return l((this.negative | S.negative) === 0), this.iuand(S);
    }, p.prototype.and = function(S) {
      return this.length > S.length ? this.clone().iand(S) : S.clone().iand(this);
    }, p.prototype.uand = function(S) {
      return this.length > S.length ? this.clone().iuand(S) : S.clone().iuand(this);
    }, p.prototype.iuxor = function(S) {
      var E, I;
      this.length > S.length ? (E = this, I = S) : (E = S, I = this);
      for (var M = 0; M < I.length; M++)
        this.words[M] = E.words[M] ^ I.words[M];
      if (this !== E)
        for (; M < E.length; M++)
          this.words[M] = E.words[M];
      return this.length = E.length, this.strip();
    }, p.prototype.ixor = function(S) {
      return l((this.negative | S.negative) === 0), this.iuxor(S);
    }, p.prototype.xor = function(S) {
      return this.length > S.length ? this.clone().ixor(S) : S.clone().ixor(this);
    }, p.prototype.uxor = function(S) {
      return this.length > S.length ? this.clone().iuxor(S) : S.clone().iuxor(this);
    }, p.prototype.inotn = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = Math.ceil(S / 26) | 0, I = S % 26;
      this._expand(E), I > 0 && E--;
      for (var M = 0; M < E; M++)
        this.words[M] = ~this.words[M] & 67108863;
      return I > 0 && (this.words[M] = ~this.words[M] & 67108863 >> 26 - I), this.strip();
    }, p.prototype.notn = function(S) {
      return this.clone().inotn(S);
    }, p.prototype.setn = function(S, E) {
      l(typeof S == "number" && S >= 0);
      var I = S / 26 | 0, M = S % 26;
      return this._expand(I + 1), E ? this.words[I] = this.words[I] | 1 << M : this.words[I] = this.words[I] & ~(1 << M), this.strip();
    }, p.prototype.iadd = function(S) {
      var E;
      if (this.negative !== 0 && S.negative === 0)
        return this.negative = 0, E = this.isub(S), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && S.negative !== 0)
        return S.negative = 0, E = this.isub(S), S.negative = 1, E._normSign();
      var I, M;
      this.length > S.length ? (I = this, M = S) : (I = S, M = this);
      for (var $ = 0, U = 0; U < M.length; U++)
        E = (I.words[U] | 0) + (M.words[U] | 0) + $, this.words[U] = E & 67108863, $ = E >>> 26;
      for (; $ !== 0 && U < I.length; U++)
        E = (I.words[U] | 0) + $, this.words[U] = E & 67108863, $ = E >>> 26;
      if (this.length = I.length, $ !== 0)
        this.words[this.length] = $, this.length++;
      else if (I !== this)
        for (; U < I.length; U++)
          this.words[U] = I.words[U];
      return this;
    }, p.prototype.add = function(S) {
      var E;
      return S.negative !== 0 && this.negative === 0 ? (S.negative = 0, E = this.sub(S), S.negative ^= 1, E) : S.negative === 0 && this.negative !== 0 ? (this.negative = 0, E = S.sub(this), this.negative = 1, E) : this.length > S.length ? this.clone().iadd(S) : S.clone().iadd(this);
    }, p.prototype.isub = function(S) {
      if (S.negative !== 0) {
        S.negative = 0;
        var E = this.iadd(S);
        return S.negative = 1, E._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(S), this.negative = 1, this._normSign();
      var I = this.cmp(S);
      if (I === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var M, $;
      I > 0 ? (M = this, $ = S) : (M = S, $ = this);
      for (var U = 0, Y = 0; Y < $.length; Y++)
        E = (M.words[Y] | 0) - ($.words[Y] | 0) + U, U = E >> 26, this.words[Y] = E & 67108863;
      for (; U !== 0 && Y < M.length; Y++)
        E = (M.words[Y] | 0) + U, U = E >> 26, this.words[Y] = E & 67108863;
      if (U === 0 && Y < M.length && M !== this)
        for (; Y < M.length; Y++)
          this.words[Y] = M.words[Y];
      return this.length = Math.max(this.length, Y), M !== this && (this.negative = 1), this.strip();
    }, p.prototype.sub = function(S) {
      return this.clone().isub(S);
    };
    function X(C, S, E) {
      E.negative = S.negative ^ C.negative;
      var I = C.length + S.length | 0;
      E.length = I, I = I - 1 | 0;
      var M = C.words[0] | 0, $ = S.words[0] | 0, U = M * $, Y = U & 67108863, L = U / 67108864 | 0;
      E.words[0] = Y;
      for (var T = 1; T < I; T++) {
        for (var B = L >>> 26, te = L & 67108863, pe = Math.min(T, S.length - 1), Ie = Math.max(0, T - C.length + 1); Ie <= pe; Ie++) {
          var $e = T - Ie | 0;
          M = C.words[$e] | 0, $ = S.words[Ie] | 0, U = M * $ + te, B += U / 67108864 | 0, te = U & 67108863;
        }
        E.words[T] = te | 0, L = B | 0;
      }
      return L !== 0 ? E.words[T] = L | 0 : E.length--, E.strip();
    }
    var ae = function(S, E, I) {
      var M = S.words, $ = E.words, U = I.words, Y = 0, L, T, B, te = M[0] | 0, pe = te & 8191, Ie = te >>> 13, $e = M[1] | 0, ve = $e & 8191, he = $e >>> 13, Oe = M[2] | 0, Ae = Oe & 8191, Ue = Oe >>> 13, oe = M[3] | 0, A = oe & 8191, re = oe >>> 13, le = M[4] | 0, Ne = le & 8191, Pe = le >>> 13, Fe = M[5] | 0, je = Fe & 8191, qe = Fe >>> 13, yt = M[6] | 0, Xe = yt & 8191, Ge = yt >>> 13, H = M[7] | 0, ye = H & 8191, Ee = H >>> 13, We = M[8] | 0, we = We & 8191, V = We >>> 13, _e = M[9] | 0, ue = _e & 8191, ce = _e >>> 13, me = $[0] | 0, Ce = me & 8191, Be = me >>> 13, ze = $[1] | 0, Je = ze & 8191, Ze = ze >>> 13, Ke = $[2] | 0, x = Ke & 8191, se = Ke >>> 13, ge = $[3] | 0, xe = ge & 8191, Me = ge >>> 13, Ye = $[4] | 0, et = Ye & 8191, dt = Ye >>> 13, St = $[5] | 0, tt = St & 8191, at = St >>> 13, kt = $[6] | 0, rt = kt & 8191, ut = kt >>> 13, wt = $[7] | 0, nt = wt & 8191, it = wt >>> 13, bt = $[8] | 0, ot = bt & 8191, ct = bt >>> 13, Pt = $[9] | 0, st = Pt & 8191, lt = Pt >>> 13;
      I.negative = S.negative ^ E.negative, I.length = 19, L = Math.imul(pe, Ce), T = Math.imul(pe, Be), T = T + Math.imul(Ie, Ce) | 0, B = Math.imul(Ie, Be);
      var It = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (It >>> 26) | 0, It &= 67108863, L = Math.imul(ve, Ce), T = Math.imul(ve, Be), T = T + Math.imul(he, Ce) | 0, B = Math.imul(he, Be), L = L + Math.imul(pe, Je) | 0, T = T + Math.imul(pe, Ze) | 0, T = T + Math.imul(Ie, Je) | 0, B = B + Math.imul(Ie, Ze) | 0;
      var Rt = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (Rt >>> 26) | 0, Rt &= 67108863, L = Math.imul(Ae, Ce), T = Math.imul(Ae, Be), T = T + Math.imul(Ue, Ce) | 0, B = Math.imul(Ue, Be), L = L + Math.imul(ve, Je) | 0, T = T + Math.imul(ve, Ze) | 0, T = T + Math.imul(he, Je) | 0, B = B + Math.imul(he, Ze) | 0, L = L + Math.imul(pe, x) | 0, T = T + Math.imul(pe, se) | 0, T = T + Math.imul(Ie, x) | 0, B = B + Math.imul(Ie, se) | 0;
      var Ve = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, L = Math.imul(A, Ce), T = Math.imul(A, Be), T = T + Math.imul(re, Ce) | 0, B = Math.imul(re, Be), L = L + Math.imul(Ae, Je) | 0, T = T + Math.imul(Ae, Ze) | 0, T = T + Math.imul(Ue, Je) | 0, B = B + Math.imul(Ue, Ze) | 0, L = L + Math.imul(ve, x) | 0, T = T + Math.imul(ve, se) | 0, T = T + Math.imul(he, x) | 0, B = B + Math.imul(he, se) | 0, L = L + Math.imul(pe, xe) | 0, T = T + Math.imul(pe, Me) | 0, T = T + Math.imul(Ie, xe) | 0, B = B + Math.imul(Ie, Me) | 0;
      var He = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, L = Math.imul(Ne, Ce), T = Math.imul(Ne, Be), T = T + Math.imul(Pe, Ce) | 0, B = Math.imul(Pe, Be), L = L + Math.imul(A, Je) | 0, T = T + Math.imul(A, Ze) | 0, T = T + Math.imul(re, Je) | 0, B = B + Math.imul(re, Ze) | 0, L = L + Math.imul(Ae, x) | 0, T = T + Math.imul(Ae, se) | 0, T = T + Math.imul(Ue, x) | 0, B = B + Math.imul(Ue, se) | 0, L = L + Math.imul(ve, xe) | 0, T = T + Math.imul(ve, Me) | 0, T = T + Math.imul(he, xe) | 0, B = B + Math.imul(he, Me) | 0, L = L + Math.imul(pe, et) | 0, T = T + Math.imul(pe, dt) | 0, T = T + Math.imul(Ie, et) | 0, B = B + Math.imul(Ie, dt) | 0;
      var Qe = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, L = Math.imul(je, Ce), T = Math.imul(je, Be), T = T + Math.imul(qe, Ce) | 0, B = Math.imul(qe, Be), L = L + Math.imul(Ne, Je) | 0, T = T + Math.imul(Ne, Ze) | 0, T = T + Math.imul(Pe, Je) | 0, B = B + Math.imul(Pe, Ze) | 0, L = L + Math.imul(A, x) | 0, T = T + Math.imul(A, se) | 0, T = T + Math.imul(re, x) | 0, B = B + Math.imul(re, se) | 0, L = L + Math.imul(Ae, xe) | 0, T = T + Math.imul(Ae, Me) | 0, T = T + Math.imul(Ue, xe) | 0, B = B + Math.imul(Ue, Me) | 0, L = L + Math.imul(ve, et) | 0, T = T + Math.imul(ve, dt) | 0, T = T + Math.imul(he, et) | 0, B = B + Math.imul(he, dt) | 0, L = L + Math.imul(pe, tt) | 0, T = T + Math.imul(pe, at) | 0, T = T + Math.imul(Ie, tt) | 0, B = B + Math.imul(Ie, at) | 0;
      var pt = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (pt >>> 26) | 0, pt &= 67108863, L = Math.imul(Xe, Ce), T = Math.imul(Xe, Be), T = T + Math.imul(Ge, Ce) | 0, B = Math.imul(Ge, Be), L = L + Math.imul(je, Je) | 0, T = T + Math.imul(je, Ze) | 0, T = T + Math.imul(qe, Je) | 0, B = B + Math.imul(qe, Ze) | 0, L = L + Math.imul(Ne, x) | 0, T = T + Math.imul(Ne, se) | 0, T = T + Math.imul(Pe, x) | 0, B = B + Math.imul(Pe, se) | 0, L = L + Math.imul(A, xe) | 0, T = T + Math.imul(A, Me) | 0, T = T + Math.imul(re, xe) | 0, B = B + Math.imul(re, Me) | 0, L = L + Math.imul(Ae, et) | 0, T = T + Math.imul(Ae, dt) | 0, T = T + Math.imul(Ue, et) | 0, B = B + Math.imul(Ue, dt) | 0, L = L + Math.imul(ve, tt) | 0, T = T + Math.imul(ve, at) | 0, T = T + Math.imul(he, tt) | 0, B = B + Math.imul(he, at) | 0, L = L + Math.imul(pe, rt) | 0, T = T + Math.imul(pe, ut) | 0, T = T + Math.imul(Ie, rt) | 0, B = B + Math.imul(Ie, ut) | 0;
      var mt = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (mt >>> 26) | 0, mt &= 67108863, L = Math.imul(ye, Ce), T = Math.imul(ye, Be), T = T + Math.imul(Ee, Ce) | 0, B = Math.imul(Ee, Be), L = L + Math.imul(Xe, Je) | 0, T = T + Math.imul(Xe, Ze) | 0, T = T + Math.imul(Ge, Je) | 0, B = B + Math.imul(Ge, Ze) | 0, L = L + Math.imul(je, x) | 0, T = T + Math.imul(je, se) | 0, T = T + Math.imul(qe, x) | 0, B = B + Math.imul(qe, se) | 0, L = L + Math.imul(Ne, xe) | 0, T = T + Math.imul(Ne, Me) | 0, T = T + Math.imul(Pe, xe) | 0, B = B + Math.imul(Pe, Me) | 0, L = L + Math.imul(A, et) | 0, T = T + Math.imul(A, dt) | 0, T = T + Math.imul(re, et) | 0, B = B + Math.imul(re, dt) | 0, L = L + Math.imul(Ae, tt) | 0, T = T + Math.imul(Ae, at) | 0, T = T + Math.imul(Ue, tt) | 0, B = B + Math.imul(Ue, at) | 0, L = L + Math.imul(ve, rt) | 0, T = T + Math.imul(ve, ut) | 0, T = T + Math.imul(he, rt) | 0, B = B + Math.imul(he, ut) | 0, L = L + Math.imul(pe, nt) | 0, T = T + Math.imul(pe, it) | 0, T = T + Math.imul(Ie, nt) | 0, B = B + Math.imul(Ie, it) | 0;
      var vt = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, L = Math.imul(we, Ce), T = Math.imul(we, Be), T = T + Math.imul(V, Ce) | 0, B = Math.imul(V, Be), L = L + Math.imul(ye, Je) | 0, T = T + Math.imul(ye, Ze) | 0, T = T + Math.imul(Ee, Je) | 0, B = B + Math.imul(Ee, Ze) | 0, L = L + Math.imul(Xe, x) | 0, T = T + Math.imul(Xe, se) | 0, T = T + Math.imul(Ge, x) | 0, B = B + Math.imul(Ge, se) | 0, L = L + Math.imul(je, xe) | 0, T = T + Math.imul(je, Me) | 0, T = T + Math.imul(qe, xe) | 0, B = B + Math.imul(qe, Me) | 0, L = L + Math.imul(Ne, et) | 0, T = T + Math.imul(Ne, dt) | 0, T = T + Math.imul(Pe, et) | 0, B = B + Math.imul(Pe, dt) | 0, L = L + Math.imul(A, tt) | 0, T = T + Math.imul(A, at) | 0, T = T + Math.imul(re, tt) | 0, B = B + Math.imul(re, at) | 0, L = L + Math.imul(Ae, rt) | 0, T = T + Math.imul(Ae, ut) | 0, T = T + Math.imul(Ue, rt) | 0, B = B + Math.imul(Ue, ut) | 0, L = L + Math.imul(ve, nt) | 0, T = T + Math.imul(ve, it) | 0, T = T + Math.imul(he, nt) | 0, B = B + Math.imul(he, it) | 0, L = L + Math.imul(pe, ot) | 0, T = T + Math.imul(pe, ct) | 0, T = T + Math.imul(Ie, ot) | 0, B = B + Math.imul(Ie, ct) | 0;
      var ht = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (ht >>> 26) | 0, ht &= 67108863, L = Math.imul(ue, Ce), T = Math.imul(ue, Be), T = T + Math.imul(ce, Ce) | 0, B = Math.imul(ce, Be), L = L + Math.imul(we, Je) | 0, T = T + Math.imul(we, Ze) | 0, T = T + Math.imul(V, Je) | 0, B = B + Math.imul(V, Ze) | 0, L = L + Math.imul(ye, x) | 0, T = T + Math.imul(ye, se) | 0, T = T + Math.imul(Ee, x) | 0, B = B + Math.imul(Ee, se) | 0, L = L + Math.imul(Xe, xe) | 0, T = T + Math.imul(Xe, Me) | 0, T = T + Math.imul(Ge, xe) | 0, B = B + Math.imul(Ge, Me) | 0, L = L + Math.imul(je, et) | 0, T = T + Math.imul(je, dt) | 0, T = T + Math.imul(qe, et) | 0, B = B + Math.imul(qe, dt) | 0, L = L + Math.imul(Ne, tt) | 0, T = T + Math.imul(Ne, at) | 0, T = T + Math.imul(Pe, tt) | 0, B = B + Math.imul(Pe, at) | 0, L = L + Math.imul(A, rt) | 0, T = T + Math.imul(A, ut) | 0, T = T + Math.imul(re, rt) | 0, B = B + Math.imul(re, ut) | 0, L = L + Math.imul(Ae, nt) | 0, T = T + Math.imul(Ae, it) | 0, T = T + Math.imul(Ue, nt) | 0, B = B + Math.imul(Ue, it) | 0, L = L + Math.imul(ve, ot) | 0, T = T + Math.imul(ve, ct) | 0, T = T + Math.imul(he, ot) | 0, B = B + Math.imul(he, ct) | 0, L = L + Math.imul(pe, st) | 0, T = T + Math.imul(pe, lt) | 0, T = T + Math.imul(Ie, st) | 0, B = B + Math.imul(Ie, lt) | 0;
      var Et = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, L = Math.imul(ue, Je), T = Math.imul(ue, Ze), T = T + Math.imul(ce, Je) | 0, B = Math.imul(ce, Ze), L = L + Math.imul(we, x) | 0, T = T + Math.imul(we, se) | 0, T = T + Math.imul(V, x) | 0, B = B + Math.imul(V, se) | 0, L = L + Math.imul(ye, xe) | 0, T = T + Math.imul(ye, Me) | 0, T = T + Math.imul(Ee, xe) | 0, B = B + Math.imul(Ee, Me) | 0, L = L + Math.imul(Xe, et) | 0, T = T + Math.imul(Xe, dt) | 0, T = T + Math.imul(Ge, et) | 0, B = B + Math.imul(Ge, dt) | 0, L = L + Math.imul(je, tt) | 0, T = T + Math.imul(je, at) | 0, T = T + Math.imul(qe, tt) | 0, B = B + Math.imul(qe, at) | 0, L = L + Math.imul(Ne, rt) | 0, T = T + Math.imul(Ne, ut) | 0, T = T + Math.imul(Pe, rt) | 0, B = B + Math.imul(Pe, ut) | 0, L = L + Math.imul(A, nt) | 0, T = T + Math.imul(A, it) | 0, T = T + Math.imul(re, nt) | 0, B = B + Math.imul(re, it) | 0, L = L + Math.imul(Ae, ot) | 0, T = T + Math.imul(Ae, ct) | 0, T = T + Math.imul(Ue, ot) | 0, B = B + Math.imul(Ue, ct) | 0, L = L + Math.imul(ve, st) | 0, T = T + Math.imul(ve, lt) | 0, T = T + Math.imul(he, st) | 0, B = B + Math.imul(he, lt) | 0;
      var Tt = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (Tt >>> 26) | 0, Tt &= 67108863, L = Math.imul(ue, x), T = Math.imul(ue, se), T = T + Math.imul(ce, x) | 0, B = Math.imul(ce, se), L = L + Math.imul(we, xe) | 0, T = T + Math.imul(we, Me) | 0, T = T + Math.imul(V, xe) | 0, B = B + Math.imul(V, Me) | 0, L = L + Math.imul(ye, et) | 0, T = T + Math.imul(ye, dt) | 0, T = T + Math.imul(Ee, et) | 0, B = B + Math.imul(Ee, dt) | 0, L = L + Math.imul(Xe, tt) | 0, T = T + Math.imul(Xe, at) | 0, T = T + Math.imul(Ge, tt) | 0, B = B + Math.imul(Ge, at) | 0, L = L + Math.imul(je, rt) | 0, T = T + Math.imul(je, ut) | 0, T = T + Math.imul(qe, rt) | 0, B = B + Math.imul(qe, ut) | 0, L = L + Math.imul(Ne, nt) | 0, T = T + Math.imul(Ne, it) | 0, T = T + Math.imul(Pe, nt) | 0, B = B + Math.imul(Pe, it) | 0, L = L + Math.imul(A, ot) | 0, T = T + Math.imul(A, ct) | 0, T = T + Math.imul(re, ot) | 0, B = B + Math.imul(re, ct) | 0, L = L + Math.imul(Ae, st) | 0, T = T + Math.imul(Ae, lt) | 0, T = T + Math.imul(Ue, st) | 0, B = B + Math.imul(Ue, lt) | 0;
      var Ot = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (Ot >>> 26) | 0, Ot &= 67108863, L = Math.imul(ue, xe), T = Math.imul(ue, Me), T = T + Math.imul(ce, xe) | 0, B = Math.imul(ce, Me), L = L + Math.imul(we, et) | 0, T = T + Math.imul(we, dt) | 0, T = T + Math.imul(V, et) | 0, B = B + Math.imul(V, dt) | 0, L = L + Math.imul(ye, tt) | 0, T = T + Math.imul(ye, at) | 0, T = T + Math.imul(Ee, tt) | 0, B = B + Math.imul(Ee, at) | 0, L = L + Math.imul(Xe, rt) | 0, T = T + Math.imul(Xe, ut) | 0, T = T + Math.imul(Ge, rt) | 0, B = B + Math.imul(Ge, ut) | 0, L = L + Math.imul(je, nt) | 0, T = T + Math.imul(je, it) | 0, T = T + Math.imul(qe, nt) | 0, B = B + Math.imul(qe, it) | 0, L = L + Math.imul(Ne, ot) | 0, T = T + Math.imul(Ne, ct) | 0, T = T + Math.imul(Pe, ot) | 0, B = B + Math.imul(Pe, ct) | 0, L = L + Math.imul(A, st) | 0, T = T + Math.imul(A, lt) | 0, T = T + Math.imul(re, st) | 0, B = B + Math.imul(re, lt) | 0;
      var Nt = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, L = Math.imul(ue, et), T = Math.imul(ue, dt), T = T + Math.imul(ce, et) | 0, B = Math.imul(ce, dt), L = L + Math.imul(we, tt) | 0, T = T + Math.imul(we, at) | 0, T = T + Math.imul(V, tt) | 0, B = B + Math.imul(V, at) | 0, L = L + Math.imul(ye, rt) | 0, T = T + Math.imul(ye, ut) | 0, T = T + Math.imul(Ee, rt) | 0, B = B + Math.imul(Ee, ut) | 0, L = L + Math.imul(Xe, nt) | 0, T = T + Math.imul(Xe, it) | 0, T = T + Math.imul(Ge, nt) | 0, B = B + Math.imul(Ge, it) | 0, L = L + Math.imul(je, ot) | 0, T = T + Math.imul(je, ct) | 0, T = T + Math.imul(qe, ot) | 0, B = B + Math.imul(qe, ct) | 0, L = L + Math.imul(Ne, st) | 0, T = T + Math.imul(Ne, lt) | 0, T = T + Math.imul(Pe, st) | 0, B = B + Math.imul(Pe, lt) | 0;
      var At = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, L = Math.imul(ue, tt), T = Math.imul(ue, at), T = T + Math.imul(ce, tt) | 0, B = Math.imul(ce, at), L = L + Math.imul(we, rt) | 0, T = T + Math.imul(we, ut) | 0, T = T + Math.imul(V, rt) | 0, B = B + Math.imul(V, ut) | 0, L = L + Math.imul(ye, nt) | 0, T = T + Math.imul(ye, it) | 0, T = T + Math.imul(Ee, nt) | 0, B = B + Math.imul(Ee, it) | 0, L = L + Math.imul(Xe, ot) | 0, T = T + Math.imul(Xe, ct) | 0, T = T + Math.imul(Ge, ot) | 0, B = B + Math.imul(Ge, ct) | 0, L = L + Math.imul(je, st) | 0, T = T + Math.imul(je, lt) | 0, T = T + Math.imul(qe, st) | 0, B = B + Math.imul(qe, lt) | 0;
      var Mt = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (Mt >>> 26) | 0, Mt &= 67108863, L = Math.imul(ue, rt), T = Math.imul(ue, ut), T = T + Math.imul(ce, rt) | 0, B = Math.imul(ce, ut), L = L + Math.imul(we, nt) | 0, T = T + Math.imul(we, it) | 0, T = T + Math.imul(V, nt) | 0, B = B + Math.imul(V, it) | 0, L = L + Math.imul(ye, ot) | 0, T = T + Math.imul(ye, ct) | 0, T = T + Math.imul(Ee, ot) | 0, B = B + Math.imul(Ee, ct) | 0, L = L + Math.imul(Xe, st) | 0, T = T + Math.imul(Xe, lt) | 0, T = T + Math.imul(Ge, st) | 0, B = B + Math.imul(Ge, lt) | 0;
      var $t = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + ($t >>> 26) | 0, $t &= 67108863, L = Math.imul(ue, nt), T = Math.imul(ue, it), T = T + Math.imul(ce, nt) | 0, B = Math.imul(ce, it), L = L + Math.imul(we, ot) | 0, T = T + Math.imul(we, ct) | 0, T = T + Math.imul(V, ot) | 0, B = B + Math.imul(V, ct) | 0, L = L + Math.imul(ye, st) | 0, T = T + Math.imul(ye, lt) | 0, T = T + Math.imul(Ee, st) | 0, B = B + Math.imul(Ee, lt) | 0;
      var Bt = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, L = Math.imul(ue, ot), T = Math.imul(ue, ct), T = T + Math.imul(ce, ot) | 0, B = Math.imul(ce, ct), L = L + Math.imul(we, st) | 0, T = T + Math.imul(we, lt) | 0, T = T + Math.imul(V, st) | 0, B = B + Math.imul(V, lt) | 0;
      var Ut = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (Ut >>> 26) | 0, Ut &= 67108863, L = Math.imul(ue, st), T = Math.imul(ue, lt), T = T + Math.imul(ce, st) | 0, B = Math.imul(ce, lt);
      var xt = (Y + L | 0) + ((T & 8191) << 13) | 0;
      return Y = (B + (T >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, U[0] = It, U[1] = Rt, U[2] = Ve, U[3] = He, U[4] = Qe, U[5] = pt, U[6] = mt, U[7] = vt, U[8] = ht, U[9] = Et, U[10] = Tt, U[11] = Ot, U[12] = Nt, U[13] = At, U[14] = Mt, U[15] = $t, U[16] = Bt, U[17] = Ut, U[18] = xt, Y !== 0 && (U[19] = Y, I.length++), I;
    };
    Math.imul || (ae = X);
    function Q(C, S, E) {
      E.negative = S.negative ^ C.negative, E.length = C.length + S.length;
      for (var I = 0, M = 0, $ = 0; $ < E.length - 1; $++) {
        var U = M;
        M = 0;
        for (var Y = I & 67108863, L = Math.min($, S.length - 1), T = Math.max(0, $ - C.length + 1); T <= L; T++) {
          var B = $ - T, te = C.words[B] | 0, pe = S.words[T] | 0, Ie = te * pe, $e = Ie & 67108863;
          U = U + (Ie / 67108864 | 0) | 0, $e = $e + Y | 0, Y = $e & 67108863, U = U + ($e >>> 26) | 0, M += U >>> 26, U &= 67108863;
        }
        E.words[$] = Y, I = U, U = M;
      }
      return I !== 0 ? E.words[$] = I : E.length--, E.strip();
    }
    function ne(C, S, E) {
      var I = new Z();
      return I.mulp(C, S, E);
    }
    p.prototype.mulTo = function(S, E) {
      var I, M = this.length + S.length;
      return this.length === 10 && S.length === 10 ? I = ae(this, S, E) : M < 63 ? I = X(this, S, E) : M < 1024 ? I = Q(this, S, E) : I = ne(this, S, E), I;
    };
    function Z(C, S) {
      this.x = C, this.y = S;
    }
    Z.prototype.makeRBT = function(S) {
      for (var E = new Array(S), I = p.prototype._countBits(S) - 1, M = 0; M < S; M++)
        E[M] = this.revBin(M, I, S);
      return E;
    }, Z.prototype.revBin = function(S, E, I) {
      if (S === 0 || S === I - 1)
        return S;
      for (var M = 0, $ = 0; $ < E; $++)
        M |= (S & 1) << E - $ - 1, S >>= 1;
      return M;
    }, Z.prototype.permute = function(S, E, I, M, $, U) {
      for (var Y = 0; Y < U; Y++)
        M[Y] = E[S[Y]], $[Y] = I[S[Y]];
    }, Z.prototype.transform = function(S, E, I, M, $, U) {
      this.permute(U, S, E, I, M, $);
      for (var Y = 1; Y < $; Y <<= 1)
        for (var L = Y << 1, T = Math.cos(2 * Math.PI / L), B = Math.sin(2 * Math.PI / L), te = 0; te < $; te += L)
          for (var pe = T, Ie = B, $e = 0; $e < Y; $e++) {
            var ve = I[te + $e], he = M[te + $e], Oe = I[te + $e + Y], Ae = M[te + $e + Y], Ue = pe * Oe - Ie * Ae;
            Ae = pe * Ae + Ie * Oe, Oe = Ue, I[te + $e] = ve + Oe, M[te + $e] = he + Ae, I[te + $e + Y] = ve - Oe, M[te + $e + Y] = he - Ae, $e !== L && (Ue = T * pe - B * Ie, Ie = T * Ie + B * pe, pe = Ue);
          }
    }, Z.prototype.guessLen13b = function(S, E) {
      var I = Math.max(E, S) | 1, M = I & 1, $ = 0;
      for (I = I / 2 | 0; I; I = I >>> 1)
        $++;
      return 1 << $ + 1 + M;
    }, Z.prototype.conjugate = function(S, E, I) {
      if (!(I <= 1))
        for (var M = 0; M < I / 2; M++) {
          var $ = S[M];
          S[M] = S[I - M - 1], S[I - M - 1] = $, $ = E[M], E[M] = -E[I - M - 1], E[I - M - 1] = -$;
        }
    }, Z.prototype.normalize13b = function(S, E) {
      for (var I = 0, M = 0; M < E / 2; M++) {
        var $ = Math.round(S[2 * M + 1] / E) * 8192 + Math.round(S[2 * M] / E) + I;
        S[M] = $ & 67108863, $ < 67108864 ? I = 0 : I = $ / 67108864 | 0;
      }
      return S;
    }, Z.prototype.convert13b = function(S, E, I, M) {
      for (var $ = 0, U = 0; U < E; U++)
        $ = $ + (S[U] | 0), I[2 * U] = $ & 8191, $ = $ >>> 13, I[2 * U + 1] = $ & 8191, $ = $ >>> 13;
      for (U = 2 * E; U < M; ++U)
        I[U] = 0;
      l($ === 0), l(($ & -8192) === 0);
    }, Z.prototype.stub = function(S) {
      for (var E = new Array(S), I = 0; I < S; I++)
        E[I] = 0;
      return E;
    }, Z.prototype.mulp = function(S, E, I) {
      var M = 2 * this.guessLen13b(S.length, E.length), $ = this.makeRBT(M), U = this.stub(M), Y = new Array(M), L = new Array(M), T = new Array(M), B = new Array(M), te = new Array(M), pe = new Array(M), Ie = I.words;
      Ie.length = M, this.convert13b(S.words, S.length, Y, M), this.convert13b(E.words, E.length, B, M), this.transform(Y, U, L, T, M, $), this.transform(B, U, te, pe, M, $);
      for (var $e = 0; $e < M; $e++) {
        var ve = L[$e] * te[$e] - T[$e] * pe[$e];
        T[$e] = L[$e] * pe[$e] + T[$e] * te[$e], L[$e] = ve;
      }
      return this.conjugate(L, T, M), this.transform(L, T, Ie, U, M, $), this.conjugate(Ie, U, M), this.normalize13b(Ie, M), I.negative = S.negative ^ E.negative, I.length = S.length + E.length, I.strip();
    }, p.prototype.mul = function(S) {
      var E = new p(null);
      return E.words = new Array(this.length + S.length), this.mulTo(S, E);
    }, p.prototype.mulf = function(S) {
      var E = new p(null);
      return E.words = new Array(this.length + S.length), ne(this, S, E);
    }, p.prototype.imul = function(S) {
      return this.clone().mulTo(S, this);
    }, p.prototype.imuln = function(S) {
      l(typeof S == "number"), l(S < 67108864);
      for (var E = 0, I = 0; I < this.length; I++) {
        var M = (this.words[I] | 0) * S, $ = (M & 67108863) + (E & 67108863);
        E >>= 26, E += M / 67108864 | 0, E += $ >>> 26, this.words[I] = $ & 67108863;
      }
      return E !== 0 && (this.words[I] = E, this.length++), this;
    }, p.prototype.muln = function(S) {
      return this.clone().imuln(S);
    }, p.prototype.sqr = function() {
      return this.mul(this);
    }, p.prototype.isqr = function() {
      return this.imul(this.clone());
    }, p.prototype.pow = function(S) {
      var E = ee(S);
      if (E.length === 0)
        return new p(1);
      for (var I = this, M = 0; M < E.length && E[M] === 0; M++, I = I.sqr())
        ;
      if (++M < E.length)
        for (var $ = I.sqr(); M < E.length; M++, $ = $.sqr())
          E[M] !== 0 && (I = I.mul($));
      return I;
    }, p.prototype.iushln = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = S % 26, I = (S - E) / 26, M = 67108863 >>> 26 - E << 26 - E, $;
      if (E !== 0) {
        var U = 0;
        for ($ = 0; $ < this.length; $++) {
          var Y = this.words[$] & M, L = (this.words[$] | 0) - Y << E;
          this.words[$] = L | U, U = Y >>> 26 - E;
        }
        U && (this.words[$] = U, this.length++);
      }
      if (I !== 0) {
        for ($ = this.length - 1; $ >= 0; $--)
          this.words[$ + I] = this.words[$];
        for ($ = 0; $ < I; $++)
          this.words[$] = 0;
        this.length += I;
      }
      return this.strip();
    }, p.prototype.ishln = function(S) {
      return l(this.negative === 0), this.iushln(S);
    }, p.prototype.iushrn = function(S, E, I) {
      l(typeof S == "number" && S >= 0);
      var M;
      E ? M = (E - E % 26) / 26 : M = 0;
      var $ = S % 26, U = Math.min((S - $) / 26, this.length), Y = 67108863 ^ 67108863 >>> $ << $, L = I;
      if (M -= U, M = Math.max(0, M), L) {
        for (var T = 0; T < U; T++)
          L.words[T] = this.words[T];
        L.length = U;
      }
      if (U !== 0)
        if (this.length > U)
          for (this.length -= U, T = 0; T < this.length; T++)
            this.words[T] = this.words[T + U];
        else
          this.words[0] = 0, this.length = 1;
      var B = 0;
      for (T = this.length - 1; T >= 0 && (B !== 0 || T >= M); T--) {
        var te = this.words[T] | 0;
        this.words[T] = B << 26 - $ | te >>> $, B = te & Y;
      }
      return L && B !== 0 && (L.words[L.length++] = B), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, p.prototype.ishrn = function(S, E, I) {
      return l(this.negative === 0), this.iushrn(S, E, I);
    }, p.prototype.shln = function(S) {
      return this.clone().ishln(S);
    }, p.prototype.ushln = function(S) {
      return this.clone().iushln(S);
    }, p.prototype.shrn = function(S) {
      return this.clone().ishrn(S);
    }, p.prototype.ushrn = function(S) {
      return this.clone().iushrn(S);
    }, p.prototype.testn = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = S % 26, I = (S - E) / 26, M = 1 << E;
      if (this.length <= I)
        return !1;
      var $ = this.words[I];
      return !!($ & M);
    }, p.prototype.imaskn = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = S % 26, I = (S - E) / 26;
      if (l(this.negative === 0, "imaskn works only with positive numbers"), this.length <= I)
        return this;
      if (E !== 0 && I++, this.length = Math.min(I, this.length), E !== 0) {
        var M = 67108863 ^ 67108863 >>> E << E;
        this.words[this.length - 1] &= M;
      }
      return this.strip();
    }, p.prototype.maskn = function(S) {
      return this.clone().imaskn(S);
    }, p.prototype.iaddn = function(S) {
      return l(typeof S == "number"), l(S < 67108864), S < 0 ? this.isubn(-S) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < S ? (this.words[0] = S - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(S), this.negative = 1, this) : this._iaddn(S);
    }, p.prototype._iaddn = function(S) {
      this.words[0] += S;
      for (var E = 0; E < this.length && this.words[E] >= 67108864; E++)
        this.words[E] -= 67108864, E === this.length - 1 ? this.words[E + 1] = 1 : this.words[E + 1]++;
      return this.length = Math.max(this.length, E + 1), this;
    }, p.prototype.isubn = function(S) {
      if (l(typeof S == "number"), l(S < 67108864), S < 0)
        return this.iaddn(-S);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(S), this.negative = 1, this;
      if (this.words[0] -= S, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var E = 0; E < this.length && this.words[E] < 0; E++)
          this.words[E] += 67108864, this.words[E + 1] -= 1;
      return this.strip();
    }, p.prototype.addn = function(S) {
      return this.clone().iaddn(S);
    }, p.prototype.subn = function(S) {
      return this.clone().isubn(S);
    }, p.prototype.iabs = function() {
      return this.negative = 0, this;
    }, p.prototype.abs = function() {
      return this.clone().iabs();
    }, p.prototype._ishlnsubmul = function(S, E, I) {
      var M = S.length + I, $;
      this._expand(M);
      var U, Y = 0;
      for ($ = 0; $ < S.length; $++) {
        U = (this.words[$ + I] | 0) + Y;
        var L = (S.words[$] | 0) * E;
        U -= L & 67108863, Y = (U >> 26) - (L / 67108864 | 0), this.words[$ + I] = U & 67108863;
      }
      for (; $ < this.length - I; $++)
        U = (this.words[$ + I] | 0) + Y, Y = U >> 26, this.words[$ + I] = U & 67108863;
      if (Y === 0)
        return this.strip();
      for (l(Y === -1), Y = 0, $ = 0; $ < this.length; $++)
        U = -(this.words[$] | 0) + Y, Y = U >> 26, this.words[$] = U & 67108863;
      return this.negative = 1, this.strip();
    }, p.prototype._wordDiv = function(S, E) {
      var I = this.length - S.length, M = this.clone(), $ = S, U = $.words[$.length - 1] | 0, Y = this._countBits(U);
      I = 26 - Y, I !== 0 && ($ = $.ushln(I), M.iushln(I), U = $.words[$.length - 1] | 0);
      var L = M.length - $.length, T;
      if (E !== "mod") {
        T = new p(null), T.length = L + 1, T.words = new Array(T.length);
        for (var B = 0; B < T.length; B++)
          T.words[B] = 0;
      }
      var te = M.clone()._ishlnsubmul($, 1, L);
      te.negative === 0 && (M = te, T && (T.words[L] = 1));
      for (var pe = L - 1; pe >= 0; pe--) {
        var Ie = (M.words[$.length + pe] | 0) * 67108864 + (M.words[$.length + pe - 1] | 0);
        for (Ie = Math.min(Ie / U | 0, 67108863), M._ishlnsubmul($, Ie, pe); M.negative !== 0; )
          Ie--, M.negative = 0, M._ishlnsubmul($, 1, pe), M.isZero() || (M.negative ^= 1);
        T && (T.words[pe] = Ie);
      }
      return T && T.strip(), M.strip(), E !== "div" && I !== 0 && M.iushrn(I), {
        div: T || null,
        mod: M
      };
    }, p.prototype.divmod = function(S, E, I) {
      if (l(!S.isZero()), this.isZero())
        return {
          div: new p(0),
          mod: new p(0)
        };
      var M, $, U;
      return this.negative !== 0 && S.negative === 0 ? (U = this.neg().divmod(S, E), E !== "mod" && (M = U.div.neg()), E !== "div" && ($ = U.mod.neg(), I && $.negative !== 0 && $.iadd(S)), {
        div: M,
        mod: $
      }) : this.negative === 0 && S.negative !== 0 ? (U = this.divmod(S.neg(), E), E !== "mod" && (M = U.div.neg()), {
        div: M,
        mod: U.mod
      }) : this.negative & S.negative ? (U = this.neg().divmod(S.neg(), E), E !== "div" && ($ = U.mod.neg(), I && $.negative !== 0 && $.isub(S)), {
        div: U.div,
        mod: $
      }) : S.length > this.length || this.cmp(S) < 0 ? {
        div: new p(0),
        mod: this
      } : S.length === 1 ? E === "div" ? {
        div: this.divn(S.words[0]),
        mod: null
      } : E === "mod" ? {
        div: null,
        mod: new p(this.modn(S.words[0]))
      } : {
        div: this.divn(S.words[0]),
        mod: new p(this.modn(S.words[0]))
      } : this._wordDiv(S, E);
    }, p.prototype.div = function(S) {
      return this.divmod(S, "div", !1).div;
    }, p.prototype.mod = function(S) {
      return this.divmod(S, "mod", !1).mod;
    }, p.prototype.umod = function(S) {
      return this.divmod(S, "mod", !0).mod;
    }, p.prototype.divRound = function(S) {
      var E = this.divmod(S);
      if (E.mod.isZero())
        return E.div;
      var I = E.div.negative !== 0 ? E.mod.isub(S) : E.mod, M = S.ushrn(1), $ = S.andln(1), U = I.cmp(M);
      return U < 0 || $ === 1 && U === 0 ? E.div : E.div.negative !== 0 ? E.div.isubn(1) : E.div.iaddn(1);
    }, p.prototype.modn = function(S) {
      l(S <= 67108863);
      for (var E = (1 << 26) % S, I = 0, M = this.length - 1; M >= 0; M--)
        I = (E * I + (this.words[M] | 0)) % S;
      return I;
    }, p.prototype.idivn = function(S) {
      l(S <= 67108863);
      for (var E = 0, I = this.length - 1; I >= 0; I--) {
        var M = (this.words[I] | 0) + E * 67108864;
        this.words[I] = M / S | 0, E = M % S;
      }
      return this.strip();
    }, p.prototype.divn = function(S) {
      return this.clone().idivn(S);
    }, p.prototype.egcd = function(S) {
      l(S.negative === 0), l(!S.isZero());
      var E = this, I = S.clone();
      E.negative !== 0 ? E = E.umod(S) : E = E.clone();
      for (var M = new p(1), $ = new p(0), U = new p(0), Y = new p(1), L = 0; E.isEven() && I.isEven(); )
        E.iushrn(1), I.iushrn(1), ++L;
      for (var T = I.clone(), B = E.clone(); !E.isZero(); ) {
        for (var te = 0, pe = 1; !(E.words[0] & pe) && te < 26; ++te, pe <<= 1)
          ;
        if (te > 0)
          for (E.iushrn(te); te-- > 0; )
            (M.isOdd() || $.isOdd()) && (M.iadd(T), $.isub(B)), M.iushrn(1), $.iushrn(1);
        for (var Ie = 0, $e = 1; !(I.words[0] & $e) && Ie < 26; ++Ie, $e <<= 1)
          ;
        if (Ie > 0)
          for (I.iushrn(Ie); Ie-- > 0; )
            (U.isOdd() || Y.isOdd()) && (U.iadd(T), Y.isub(B)), U.iushrn(1), Y.iushrn(1);
        E.cmp(I) >= 0 ? (E.isub(I), M.isub(U), $.isub(Y)) : (I.isub(E), U.isub(M), Y.isub($));
      }
      return {
        a: U,
        b: Y,
        gcd: I.iushln(L)
      };
    }, p.prototype._invmp = function(S) {
      l(S.negative === 0), l(!S.isZero());
      var E = this, I = S.clone();
      E.negative !== 0 ? E = E.umod(S) : E = E.clone();
      for (var M = new p(1), $ = new p(0), U = I.clone(); E.cmpn(1) > 0 && I.cmpn(1) > 0; ) {
        for (var Y = 0, L = 1; !(E.words[0] & L) && Y < 26; ++Y, L <<= 1)
          ;
        if (Y > 0)
          for (E.iushrn(Y); Y-- > 0; )
            M.isOdd() && M.iadd(U), M.iushrn(1);
        for (var T = 0, B = 1; !(I.words[0] & B) && T < 26; ++T, B <<= 1)
          ;
        if (T > 0)
          for (I.iushrn(T); T-- > 0; )
            $.isOdd() && $.iadd(U), $.iushrn(1);
        E.cmp(I) >= 0 ? (E.isub(I), M.isub($)) : (I.isub(E), $.isub(M));
      }
      var te;
      return E.cmpn(1) === 0 ? te = M : te = $, te.cmpn(0) < 0 && te.iadd(S), te;
    }, p.prototype.gcd = function(S) {
      if (this.isZero())
        return S.abs();
      if (S.isZero())
        return this.abs();
      var E = this.clone(), I = S.clone();
      E.negative = 0, I.negative = 0;
      for (var M = 0; E.isEven() && I.isEven(); M++)
        E.iushrn(1), I.iushrn(1);
      do {
        for (; E.isEven(); )
          E.iushrn(1);
        for (; I.isEven(); )
          I.iushrn(1);
        var $ = E.cmp(I);
        if ($ < 0) {
          var U = E;
          E = I, I = U;
        } else if ($ === 0 || I.cmpn(1) === 0)
          break;
        E.isub(I);
      } while (!0);
      return I.iushln(M);
    }, p.prototype.invm = function(S) {
      return this.egcd(S).a.umod(S);
    }, p.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, p.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, p.prototype.andln = function(S) {
      return this.words[0] & S;
    }, p.prototype.bincn = function(S) {
      l(typeof S == "number");
      var E = S % 26, I = (S - E) / 26, M = 1 << E;
      if (this.length <= I)
        return this._expand(I + 1), this.words[I] |= M, this;
      for (var $ = M, U = I; $ !== 0 && U < this.length; U++) {
        var Y = this.words[U] | 0;
        Y += $, $ = Y >>> 26, Y &= 67108863, this.words[U] = Y;
      }
      return $ !== 0 && (this.words[U] = $, this.length++), this;
    }, p.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, p.prototype.cmpn = function(S) {
      var E = S < 0;
      if (this.negative !== 0 && !E)
        return -1;
      if (this.negative === 0 && E)
        return 1;
      this.strip();
      var I;
      if (this.length > 1)
        I = 1;
      else {
        E && (S = -S), l(S <= 67108863, "Number is too big");
        var M = this.words[0] | 0;
        I = M === S ? 0 : M < S ? -1 : 1;
      }
      return this.negative !== 0 ? -I | 0 : I;
    }, p.prototype.cmp = function(S) {
      if (this.negative !== 0 && S.negative === 0)
        return -1;
      if (this.negative === 0 && S.negative !== 0)
        return 1;
      var E = this.ucmp(S);
      return this.negative !== 0 ? -E | 0 : E;
    }, p.prototype.ucmp = function(S) {
      if (this.length > S.length)
        return 1;
      if (this.length < S.length)
        return -1;
      for (var E = 0, I = this.length - 1; I >= 0; I--) {
        var M = this.words[I] | 0, $ = S.words[I] | 0;
        if (M !== $) {
          M < $ ? E = -1 : M > $ && (E = 1);
          break;
        }
      }
      return E;
    }, p.prototype.gtn = function(S) {
      return this.cmpn(S) === 1;
    }, p.prototype.gt = function(S) {
      return this.cmp(S) === 1;
    }, p.prototype.gten = function(S) {
      return this.cmpn(S) >= 0;
    }, p.prototype.gte = function(S) {
      return this.cmp(S) >= 0;
    }, p.prototype.ltn = function(S) {
      return this.cmpn(S) === -1;
    }, p.prototype.lt = function(S) {
      return this.cmp(S) === -1;
    }, p.prototype.lten = function(S) {
      return this.cmpn(S) <= 0;
    }, p.prototype.lte = function(S) {
      return this.cmp(S) <= 0;
    }, p.prototype.eqn = function(S) {
      return this.cmpn(S) === 0;
    }, p.prototype.eq = function(S) {
      return this.cmp(S) === 0;
    }, p.red = function(S) {
      return new q(S);
    }, p.prototype.toRed = function(S) {
      return l(!this.red, "Already a number in reduction context"), l(this.negative === 0, "red works only with positives"), S.convertTo(this)._forceRed(S);
    }, p.prototype.fromRed = function() {
      return l(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, p.prototype._forceRed = function(S) {
      return this.red = S, this;
    }, p.prototype.forceRed = function(S) {
      return l(!this.red, "Already a number in reduction context"), this._forceRed(S);
    }, p.prototype.redAdd = function(S) {
      return l(this.red, "redAdd works only with red numbers"), this.red.add(this, S);
    }, p.prototype.redIAdd = function(S) {
      return l(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, S);
    }, p.prototype.redSub = function(S) {
      return l(this.red, "redSub works only with red numbers"), this.red.sub(this, S);
    }, p.prototype.redISub = function(S) {
      return l(this.red, "redISub works only with red numbers"), this.red.isub(this, S);
    }, p.prototype.redShl = function(S) {
      return l(this.red, "redShl works only with red numbers"), this.red.shl(this, S);
    }, p.prototype.redMul = function(S) {
      return l(this.red, "redMul works only with red numbers"), this.red._verify2(this, S), this.red.mul(this, S);
    }, p.prototype.redIMul = function(S) {
      return l(this.red, "redMul works only with red numbers"), this.red._verify2(this, S), this.red.imul(this, S);
    }, p.prototype.redSqr = function() {
      return l(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, p.prototype.redISqr = function() {
      return l(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, p.prototype.redSqrt = function() {
      return l(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, p.prototype.redInvm = function() {
      return l(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, p.prototype.redNeg = function() {
      return l(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, p.prototype.redPow = function(S) {
      return l(this.red && !S.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, S);
    };
    var de = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function fe(C, S) {
      this.name = C, this.p = new p(S, 16), this.n = this.p.bitLength(), this.k = new p(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    fe.prototype._tmp = function() {
      var S = new p(null);
      return S.words = new Array(Math.ceil(this.n / 13)), S;
    }, fe.prototype.ireduce = function(S) {
      var E = S, I;
      do
        this.split(E, this.tmp), E = this.imulK(E), E = E.iadd(this.tmp), I = E.bitLength();
      while (I > this.n);
      var M = I < this.n ? -1 : E.ucmp(this.p);
      return M === 0 ? (E.words[0] = 0, E.length = 1) : M > 0 ? E.isub(this.p) : E.strip !== void 0 ? E.strip() : E._strip(), E;
    }, fe.prototype.split = function(S, E) {
      S.iushrn(this.n, 0, E);
    }, fe.prototype.imulK = function(S) {
      return S.imul(this.k);
    };
    function Te() {
      fe.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    v(Te, fe), Te.prototype.split = function(S, E) {
      for (var I = 4194303, M = Math.min(S.length, 9), $ = 0; $ < M; $++)
        E.words[$] = S.words[$];
      if (E.length = M, S.length <= 9) {
        S.words[0] = 0, S.length = 1;
        return;
      }
      var U = S.words[9];
      for (E.words[E.length++] = U & I, $ = 10; $ < S.length; $++) {
        var Y = S.words[$] | 0;
        S.words[$ - 10] = (Y & I) << 4 | U >>> 22, U = Y;
      }
      U >>>= 22, S.words[$ - 10] = U, U === 0 && S.length > 10 ? S.length -= 10 : S.length -= 9;
    }, Te.prototype.imulK = function(S) {
      S.words[S.length] = 0, S.words[S.length + 1] = 0, S.length += 2;
      for (var E = 0, I = 0; I < S.length; I++) {
        var M = S.words[I] | 0;
        E += M * 977, S.words[I] = E & 67108863, E = M * 64 + (E / 67108864 | 0);
      }
      return S.words[S.length - 1] === 0 && (S.length--, S.words[S.length - 1] === 0 && S.length--), S;
    };
    function Re() {
      fe.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    v(Re, fe);
    function Le() {
      fe.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    v(Le, fe);
    function be() {
      fe.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    v(be, fe), be.prototype.imulK = function(S) {
      for (var E = 0, I = 0; I < S.length; I++) {
        var M = (S.words[I] | 0) * 19 + E, $ = M & 67108863;
        M >>>= 26, S.words[I] = $, E = M;
      }
      return E !== 0 && (S.words[S.length++] = E), S;
    }, p._prime = function(S) {
      if (de[S])
        return de[S];
      var E;
      if (S === "k256")
        E = new Te();
      else if (S === "p224")
        E = new Re();
      else if (S === "p192")
        E = new Le();
      else if (S === "p25519")
        E = new be();
      else
        throw new Error("Unknown prime " + S);
      return de[S] = E, E;
    };
    function q(C) {
      if (typeof C == "string") {
        var S = p._prime(C);
        this.m = S.p, this.prime = S;
      } else
        l(C.gtn(1), "modulus must be greater than 1"), this.m = C, this.prime = null;
    }
    q.prototype._verify1 = function(S) {
      l(S.negative === 0, "red works only with positives"), l(S.red, "red works only with red numbers");
    }, q.prototype._verify2 = function(S, E) {
      l((S.negative | E.negative) === 0, "red works only with positives"), l(
        S.red && S.red === E.red,
        "red works only with red numbers"
      );
    }, q.prototype.imod = function(S) {
      return this.prime ? this.prime.ireduce(S)._forceRed(this) : S.umod(this.m)._forceRed(this);
    }, q.prototype.neg = function(S) {
      return S.isZero() ? S.clone() : this.m.sub(S)._forceRed(this);
    }, q.prototype.add = function(S, E) {
      this._verify2(S, E);
      var I = S.add(E);
      return I.cmp(this.m) >= 0 && I.isub(this.m), I._forceRed(this);
    }, q.prototype.iadd = function(S, E) {
      this._verify2(S, E);
      var I = S.iadd(E);
      return I.cmp(this.m) >= 0 && I.isub(this.m), I;
    }, q.prototype.sub = function(S, E) {
      this._verify2(S, E);
      var I = S.sub(E);
      return I.cmpn(0) < 0 && I.iadd(this.m), I._forceRed(this);
    }, q.prototype.isub = function(S, E) {
      this._verify2(S, E);
      var I = S.isub(E);
      return I.cmpn(0) < 0 && I.iadd(this.m), I;
    }, q.prototype.shl = function(S, E) {
      return this._verify1(S), this.imod(S.ushln(E));
    }, q.prototype.imul = function(S, E) {
      return this._verify2(S, E), this.imod(S.imul(E));
    }, q.prototype.mul = function(S, E) {
      return this._verify2(S, E), this.imod(S.mul(E));
    }, q.prototype.isqr = function(S) {
      return this.imul(S, S.clone());
    }, q.prototype.sqr = function(S) {
      return this.mul(S, S);
    }, q.prototype.sqrt = function(S) {
      if (S.isZero())
        return S.clone();
      var E = this.m.andln(3);
      if (l(E % 2 === 1), E === 3) {
        var I = this.m.add(new p(1)).iushrn(2);
        return this.pow(S, I);
      }
      for (var M = this.m.subn(1), $ = 0; !M.isZero() && M.andln(1) === 0; )
        $++, M.iushrn(1);
      l(!M.isZero());
      var U = new p(1).toRed(this), Y = U.redNeg(), L = this.m.subn(1).iushrn(1), T = this.m.bitLength();
      for (T = new p(2 * T * T).toRed(this); this.pow(T, L).cmp(Y) !== 0; )
        T.redIAdd(Y);
      for (var B = this.pow(T, M), te = this.pow(S, M.addn(1).iushrn(1)), pe = this.pow(S, M), Ie = $; pe.cmp(U) !== 0; ) {
        for (var $e = pe, ve = 0; $e.cmp(U) !== 0; ve++)
          $e = $e.redSqr();
        l(ve < Ie);
        var he = this.pow(B, new p(1).iushln(Ie - ve - 1));
        te = te.redMul(he), B = he.redSqr(), pe = pe.redMul(B), Ie = ve;
      }
      return te;
    }, q.prototype.invm = function(S) {
      var E = S._invmp(this.m);
      return E.negative !== 0 ? (E.negative = 0, this.imod(E).redNeg()) : this.imod(E);
    }, q.prototype.pow = function(S, E) {
      if (E.isZero())
        return new p(1).toRed(this);
      if (E.cmpn(1) === 0)
        return S.clone();
      var I = 4, M = new Array(1 << I);
      M[0] = new p(1).toRed(this), M[1] = S;
      for (var $ = 2; $ < M.length; $++)
        M[$] = this.mul(M[$ - 1], S);
      var U = M[0], Y = 0, L = 0, T = E.bitLength() % 26;
      for (T === 0 && (T = 26), $ = E.length - 1; $ >= 0; $--) {
        for (var B = E.words[$], te = T - 1; te >= 0; te--) {
          var pe = B >> te & 1;
          if (U !== M[0] && (U = this.sqr(U)), pe === 0 && Y === 0) {
            L = 0;
            continue;
          }
          Y <<= 1, Y |= pe, L++, !(L !== I && ($ !== 0 || te !== 0)) && (U = this.mul(U, M[Y]), L = 0, Y = 0);
        }
        T = 26;
      }
      return U;
    }, q.prototype.convertTo = function(S) {
      var E = S.umod(this.m);
      return E === S ? E.clone() : E;
    }, q.prototype.convertFrom = function(S) {
      var E = S.clone();
      return E.red = null, E;
    }, p.mont = function(S) {
      return new J(S);
    };
    function J(C) {
      q.call(this, C), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new p(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    v(J, q), J.prototype.convertTo = function(S) {
      return this.imod(S.ushln(this.shift));
    }, J.prototype.convertFrom = function(S) {
      var E = this.imod(S.mul(this.rinv));
      return E.red = null, E;
    }, J.prototype.imul = function(S, E) {
      if (S.isZero() || E.isZero())
        return S.words[0] = 0, S.length = 1, S;
      var I = S.imul(E), M = I.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), $ = I.isub(M).iushrn(this.shift), U = $;
      return $.cmp(this.m) >= 0 ? U = $.isub(this.m) : $.cmpn(0) < 0 && (U = $.iadd(this.m)), U._forceRed(this);
    }, J.prototype.mul = function(S, E) {
      if (S.isZero() || E.isZero())
        return new p(0)._forceRed(this);
      var I = S.mul(E), M = I.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), $ = I.isub(M).iushrn(this.shift), U = $;
      return $.cmp(this.m) >= 0 ? U = $.isub(this.m) : $.cmpn(0) < 0 && (U = $.iadd(this.m)), U._forceRed(this);
    }, J.prototype.invm = function(S) {
      var E = this.imod(S._invmp(this.m).mul(this.r2));
      return E._forceRed(this);
    };
  })(a, commonjsGlobal$1);
})(bn$5);
var bnExports$5 = bn$5.exports, brorand = { exports: {} }, hasRequiredBrorand;
function requireBrorand() {
  if (hasRequiredBrorand)
    return brorand.exports;
  hasRequiredBrorand = 1;
  var a;
  brorand.exports = function(v) {
    return a || (a = new u(null)), a.generate(v);
  };
  function u(l) {
    this.rand = l;
  }
  if (brorand.exports.Rand = u, u.prototype.generate = function(v) {
    return this._rand(v);
  }, u.prototype._rand = function(v) {
    if (this.rand.getBytes)
      return this.rand.getBytes(v);
    for (var p = new Uint8Array(v), _ = 0; _ < p.length; _++)
      p[_] = this.rand.getByte();
    return p;
  }, typeof self == "object")
    self.crypto && self.crypto.getRandomValues ? u.prototype._rand = function(v) {
      var p = new Uint8Array(v);
      return self.crypto.getRandomValues(p), p;
    } : self.msCrypto && self.msCrypto.getRandomValues ? u.prototype._rand = function(v) {
      var p = new Uint8Array(v);
      return self.msCrypto.getRandomValues(p), p;
    } : typeof window == "object" && (u.prototype._rand = function() {
      throw new Error("Not implemented yet");
    });
  else
    try {
      var c = requireCryptoBrowserify();
      if (typeof c.randomBytes != "function")
        throw new Error("Not supported");
      u.prototype._rand = function(v) {
        return c.randomBytes(v);
      };
    } catch {
    }
  return brorand.exports;
}
var mr, hasRequiredMr;
function requireMr() {
  if (hasRequiredMr)
    return mr;
  hasRequiredMr = 1;
  var a = bnExports$5, u = requireBrorand();
  function c(l) {
    this.rand = l || new u.Rand();
  }
  return mr = c, c.create = function(v) {
    return new c(v);
  }, c.prototype._randbelow = function(v) {
    var p = v.bitLength(), _ = Math.ceil(p / 8);
    do
      var k = new a(this.rand.generate(_));
    while (k.cmp(v) >= 0);
    return k;
  }, c.prototype._randrange = function(v, p) {
    var _ = p.sub(v);
    return v.add(this._randbelow(_));
  }, c.prototype.test = function(v, p, _) {
    var k = v.bitLength(), O = a.mont(v), D = new a(1).toRed(O);
    p || (p = Math.max(1, k / 48 | 0));
    for (var F = v.subn(1), z = 0; !F.testn(z); z++)
      ;
    for (var j = v.shrn(z), ee = F.toRed(O), X = !0; p > 0; p--) {
      var ae = this._randrange(new a(2), F);
      _ && _(ae);
      var Q = ae.toRed(O).redPow(j);
      if (!(Q.cmp(D) === 0 || Q.cmp(ee) === 0)) {
        for (var ne = 1; ne < z; ne++) {
          if (Q = Q.redSqr(), Q.cmp(D) === 0)
            return !1;
          if (Q.cmp(ee) === 0)
            break;
        }
        if (ne === z)
          return !1;
      }
    }
    return X;
  }, c.prototype.getDivisor = function(v, p) {
    var _ = v.bitLength(), k = a.mont(v), O = new a(1).toRed(k);
    p || (p = Math.max(1, _ / 48 | 0));
    for (var D = v.subn(1), F = 0; !D.testn(F); F++)
      ;
    for (var z = v.shrn(F), j = D.toRed(k); p > 0; p--) {
      var ee = this._randrange(new a(2), D), X = v.gcd(ee);
      if (X.cmpn(1) !== 0)
        return X;
      var ae = ee.toRed(k).redPow(z);
      if (!(ae.cmp(O) === 0 || ae.cmp(j) === 0)) {
        for (var Q = 1; Q < F; Q++) {
          if (ae = ae.redSqr(), ae.cmp(O) === 0)
            return ae.fromRed().subn(1).gcd(v);
          if (ae.cmp(j) === 0)
            break;
        }
        if (Q === F)
          return ae = ae.redSqr(), ae.fromRed().subn(1).gcd(v);
      }
    }
    return !1;
  }, mr;
}
var generatePrime, hasRequiredGeneratePrime;
function requireGeneratePrime() {
  if (hasRequiredGeneratePrime)
    return generatePrime;
  hasRequiredGeneratePrime = 1;
  var a = browserExports;
  generatePrime = Q, Q.simpleSieve = X, Q.fermatTest = ae;
  var u = bnExports$6, c = new u(24), l = requireMr(), v = new l(), p = new u(1), _ = new u(2), k = new u(5);
  new u(16), new u(8);
  var O = new u(10), D = new u(3);
  new u(7);
  var F = new u(11), z = new u(4);
  new u(12);
  var j = null;
  function ee() {
    if (j !== null)
      return j;
    var ne = 1048576, Z = [];
    Z[0] = 2;
    for (var de = 1, fe = 3; fe < ne; fe += 2) {
      for (var Te = Math.ceil(Math.sqrt(fe)), Re = 0; Re < de && Z[Re] <= Te && fe % Z[Re] !== 0; Re++)
        ;
      de !== Re && Z[Re] <= Te || (Z[de++] = fe);
    }
    return j = Z, Z;
  }
  function X(ne) {
    for (var Z = ee(), de = 0; de < Z.length; de++)
      if (ne.modn(Z[de]) === 0)
        return ne.cmpn(Z[de]) === 0;
    return !0;
  }
  function ae(ne) {
    var Z = u.mont(ne);
    return _.toRed(Z).redPow(ne.subn(1)).fromRed().cmpn(1) === 0;
  }
  function Q(ne, Z) {
    if (ne < 16)
      return Z === 2 || Z === 5 ? new u([140, 123]) : new u([140, 39]);
    Z = new u(Z);
    for (var de, fe; ; ) {
      for (de = new u(a(Math.ceil(ne / 8))); de.bitLength() > ne; )
        de.ishrn(1);
      if (de.isEven() && de.iadd(p), de.testn(1) || de.iadd(_), Z.cmp(_)) {
        if (!Z.cmp(k))
          for (; de.mod(O).cmp(D); )
            de.iadd(z);
      } else
        for (; de.mod(c).cmp(F); )
          de.iadd(z);
      if (fe = de.shrn(1), X(fe) && X(de) && ae(fe) && ae(de) && v.test(fe) && v.test(de))
        return de;
    }
  }
  return generatePrime;
}
const modp1 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
}, modp2 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
}, modp5 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
}, modp14 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
}, modp15 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
}, modp16 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
}, modp17 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
}, modp18 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
}, require$$1$1 = {
  modp1,
  modp2,
  modp5,
  modp14,
  modp15,
  modp16,
  modp17,
  modp18
};
var dh, hasRequiredDh;
function requireDh() {
  if (hasRequiredDh)
    return dh;
  hasRequiredDh = 1;
  var a = bnExports$6, u = requireMr(), c = new u(), l = new a(24), v = new a(11), p = new a(10), _ = new a(3), k = new a(7), O = requireGeneratePrime(), D = browserExports;
  dh = X;
  function F(Q, ne) {
    return ne = ne || "utf8", Buffer$O.isBuffer(Q) || (Q = new Buffer$O(Q, ne)), this._pub = new a(Q), this;
  }
  function z(Q, ne) {
    return ne = ne || "utf8", Buffer$O.isBuffer(Q) || (Q = new Buffer$O(Q, ne)), this._priv = new a(Q), this;
  }
  var j = {};
  function ee(Q, ne) {
    var Z = ne.toString("hex"), de = [Z, Q.toString(16)].join("_");
    if (de in j)
      return j[de];
    var fe = 0;
    if (Q.isEven() || !O.simpleSieve || !O.fermatTest(Q) || !c.test(Q))
      return fe += 1, Z === "02" || Z === "05" ? fe += 8 : fe += 4, j[de] = fe, fe;
    c.test(Q.shrn(1)) || (fe += 2);
    var Te;
    switch (Z) {
      case "02":
        Q.mod(l).cmp(v) && (fe += 8);
        break;
      case "05":
        Te = Q.mod(p), Te.cmp(_) && Te.cmp(k) && (fe += 8);
        break;
      default:
        fe += 4;
    }
    return j[de] = fe, fe;
  }
  function X(Q, ne, Z) {
    this.setGenerator(ne), this.__prime = new a(Q), this._prime = a.mont(this.__prime), this._primeLen = Q.length, this._pub = void 0, this._priv = void 0, this._primeCode = void 0, Z ? (this.setPublicKey = F, this.setPrivateKey = z) : this._primeCode = 8;
  }
  Object.defineProperty(X.prototype, "verifyError", {
    enumerable: !0,
    get: function() {
      return typeof this._primeCode != "number" && (this._primeCode = ee(this.__prime, this.__gen)), this._primeCode;
    }
  }), X.prototype.generateKeys = function() {
    return this._priv || (this._priv = new a(D(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey();
  }, X.prototype.computeSecret = function(Q) {
    Q = new a(Q), Q = Q.toRed(this._prime);
    var ne = Q.redPow(this._priv).fromRed(), Z = new Buffer$O(ne.toArray()), de = this.getPrime();
    if (Z.length < de.length) {
      var fe = new Buffer$O(de.length - Z.length);
      fe.fill(0), Z = Buffer$O.concat([fe, Z]);
    }
    return Z;
  }, X.prototype.getPublicKey = function(ne) {
    return ae(this._pub, ne);
  }, X.prototype.getPrivateKey = function(ne) {
    return ae(this._priv, ne);
  }, X.prototype.getPrime = function(Q) {
    return ae(this.__prime, Q);
  }, X.prototype.getGenerator = function(Q) {
    return ae(this._gen, Q);
  }, X.prototype.setGenerator = function(Q, ne) {
    return ne = ne || "utf8", Buffer$O.isBuffer(Q) || (Q = new Buffer$O(Q, ne)), this.__gen = Q, this._gen = new a(Q), this;
  };
  function ae(Q, ne) {
    var Z = new Buffer$O(Q.toArray());
    return ne ? Z.toString(ne) : Z;
  }
  return dh;
}
var hasRequiredBrowser$2;
function requireBrowser$2() {
  if (hasRequiredBrowser$2)
    return browser$5;
  hasRequiredBrowser$2 = 1;
  var a = requireGeneratePrime(), u = require$$1$1, c = requireDh();
  function l(_) {
    var k = new Buffer$O(u[_].prime, "hex"), O = new Buffer$O(u[_].gen, "hex");
    return new c(k, O);
  }
  var v = {
    binary: !0,
    hex: !0,
    base64: !0
  };
  function p(_, k, O, D) {
    return Buffer$O.isBuffer(k) || v[k] === void 0 ? p(_, "binary", k, O) : (k = k || "binary", D = D || "binary", O = O || new Buffer$O([2]), Buffer$O.isBuffer(O) || (O = new Buffer$O(O, D)), typeof _ == "number" ? new c(a(_, O), O, !0) : (Buffer$O.isBuffer(_) || (_ = new Buffer$O(_, k)), new c(_, O, !0)));
  }
  return browser$5.DiffieHellmanGroup = browser$5.createDiffieHellmanGroup = browser$5.getDiffieHellman = l, browser$5.createDiffieHellman = browser$5.DiffieHellman = p, browser$5;
}
var safeBuffer$1 = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(a, u) {
  var c = require$$0$2, l = c.Buffer;
  function v(_, k) {
    for (var O in _)
      k[O] = _[O];
  }
  l.from && l.alloc && l.allocUnsafe && l.allocUnsafeSlow ? a.exports = c : (v(c, u), u.Buffer = p);
  function p(_, k, O) {
    return l(_, k, O);
  }
  p.prototype = Object.create(l.prototype), v(l, p), p.from = function(_, k, O) {
    if (typeof _ == "number")
      throw new TypeError("Argument must not be a number");
    return l(_, k, O);
  }, p.alloc = function(_, k, O) {
    if (typeof _ != "number")
      throw new TypeError("Argument must be a number");
    var D = l(_);
    return k !== void 0 ? typeof O == "string" ? D.fill(k, O) : D.fill(k) : D.fill(0), D;
  }, p.allocUnsafe = function(_) {
    if (typeof _ != "number")
      throw new TypeError("Argument must be a number");
    return l(_);
  }, p.allocUnsafeSlow = function(_) {
    if (typeof _ != "number")
      throw new TypeError("Argument must be a number");
    return c.SlowBuffer(_);
  };
})(safeBuffer$1, safeBuffer$1.exports);
var safeBufferExports = safeBuffer$1.exports, readableBrowser = { exports: {} }, streamBrowser = eventsExports.EventEmitter, buffer_list, hasRequiredBuffer_list;
function requireBuffer_list() {
  if (hasRequiredBuffer_list)
    return buffer_list;
  hasRequiredBuffer_list = 1;
  function a(X, ae) {
    var Q = Object.keys(X);
    if (Object.getOwnPropertySymbols) {
      var ne = Object.getOwnPropertySymbols(X);
      ae && (ne = ne.filter(function(Z) {
        return Object.getOwnPropertyDescriptor(X, Z).enumerable;
      })), Q.push.apply(Q, ne);
    }
    return Q;
  }
  function u(X) {
    for (var ae = 1; ae < arguments.length; ae++) {
      var Q = arguments[ae] != null ? arguments[ae] : {};
      ae % 2 ? a(Object(Q), !0).forEach(function(ne) {
        c(X, ne, Q[ne]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(X, Object.getOwnPropertyDescriptors(Q)) : a(Object(Q)).forEach(function(ne) {
        Object.defineProperty(X, ne, Object.getOwnPropertyDescriptor(Q, ne));
      });
    }
    return X;
  }
  function c(X, ae, Q) {
    return ae = _(ae), ae in X ? Object.defineProperty(X, ae, { value: Q, enumerable: !0, configurable: !0, writable: !0 }) : X[ae] = Q, X;
  }
  function l(X, ae) {
    if (!(X instanceof ae))
      throw new TypeError("Cannot call a class as a function");
  }
  function v(X, ae) {
    for (var Q = 0; Q < ae.length; Q++) {
      var ne = ae[Q];
      ne.enumerable = ne.enumerable || !1, ne.configurable = !0, "value" in ne && (ne.writable = !0), Object.defineProperty(X, _(ne.key), ne);
    }
  }
  function p(X, ae, Q) {
    return ae && v(X.prototype, ae), Q && v(X, Q), Object.defineProperty(X, "prototype", { writable: !1 }), X;
  }
  function _(X) {
    var ae = k(X, "string");
    return typeof ae == "symbol" ? ae : String(ae);
  }
  function k(X, ae) {
    if (typeof X != "object" || X === null)
      return X;
    var Q = X[Symbol.toPrimitive];
    if (Q !== void 0) {
      var ne = Q.call(X, ae || "default");
      if (typeof ne != "object")
        return ne;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (ae === "string" ? String : Number)(X);
  }
  var O = require$$0$2, D = O.Buffer, F = util$4, z = F.inspect, j = z && z.custom || "inspect";
  function ee(X, ae, Q) {
    D.prototype.copy.call(X, ae, Q);
  }
  return buffer_list = /* @__PURE__ */ function() {
    function X() {
      l(this, X), this.head = null, this.tail = null, this.length = 0;
    }
    return p(X, [{
      key: "push",
      value: function(Q) {
        var ne = {
          data: Q,
          next: null
        };
        this.length > 0 ? this.tail.next = ne : this.head = ne, this.tail = ne, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(Q) {
        var ne = {
          data: Q,
          next: this.head
        };
        this.length === 0 && (this.tail = ne), this.head = ne, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var Q = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, Q;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(Q) {
        if (this.length === 0)
          return "";
        for (var ne = this.head, Z = "" + ne.data; ne = ne.next; )
          Z += Q + ne.data;
        return Z;
      }
    }, {
      key: "concat",
      value: function(Q) {
        if (this.length === 0)
          return D.alloc(0);
        for (var ne = D.allocUnsafe(Q >>> 0), Z = this.head, de = 0; Z; )
          ee(Z.data, ne, de), de += Z.data.length, Z = Z.next;
        return ne;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(Q, ne) {
        var Z;
        return Q < this.head.data.length ? (Z = this.head.data.slice(0, Q), this.head.data = this.head.data.slice(Q)) : Q === this.head.data.length ? Z = this.shift() : Z = ne ? this._getString(Q) : this._getBuffer(Q), Z;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(Q) {
        var ne = this.head, Z = 1, de = ne.data;
        for (Q -= de.length; ne = ne.next; ) {
          var fe = ne.data, Te = Q > fe.length ? fe.length : Q;
          if (Te === fe.length ? de += fe : de += fe.slice(0, Q), Q -= Te, Q === 0) {
            Te === fe.length ? (++Z, ne.next ? this.head = ne.next : this.head = this.tail = null) : (this.head = ne, ne.data = fe.slice(Te));
            break;
          }
          ++Z;
        }
        return this.length -= Z, de;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(Q) {
        var ne = D.allocUnsafe(Q), Z = this.head, de = 1;
        for (Z.data.copy(ne), Q -= Z.data.length; Z = Z.next; ) {
          var fe = Z.data, Te = Q > fe.length ? fe.length : Q;
          if (fe.copy(ne, ne.length - Q, 0, Te), Q -= Te, Q === 0) {
            Te === fe.length ? (++de, Z.next ? this.head = Z.next : this.head = this.tail = null) : (this.head = Z, Z.data = fe.slice(Te));
            break;
          }
          ++de;
        }
        return this.length -= de, ne;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: j,
      value: function(Q, ne) {
        return z(this, u(u({}, ne), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), X;
  }(), buffer_list;
}
function destroy(a, u) {
  var c = this, l = this._readableState && this._readableState.destroyed, v = this._writableState && this._writableState.destroyed;
  return l || v ? (u ? u(a) : a && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process$1.nextTick(emitErrorNT, this, a)) : process$1.nextTick(emitErrorNT, this, a)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(a || null, function(p) {
    !u && p ? c._writableState ? c._writableState.errorEmitted ? process$1.nextTick(emitCloseNT, c) : (c._writableState.errorEmitted = !0, process$1.nextTick(emitErrorAndCloseNT, c, p)) : process$1.nextTick(emitErrorAndCloseNT, c, p) : u ? (process$1.nextTick(emitCloseNT, c), u(p)) : process$1.nextTick(emitCloseNT, c);
  }), this);
}
function emitErrorAndCloseNT(a, u) {
  emitErrorNT(a, u), emitCloseNT(a);
}
function emitCloseNT(a) {
  a._writableState && !a._writableState.emitClose || a._readableState && !a._readableState.emitClose || a.emit("close");
}
function undestroy() {
  this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
}
function emitErrorNT(a, u) {
  a.emit("error", u);
}
function errorOrDestroy(a, u) {
  var c = a._readableState, l = a._writableState;
  c && c.autoDestroy || l && l.autoDestroy ? a.destroy(u) : a.emit("error", u);
}
var destroy_1 = {
  destroy,
  undestroy,
  errorOrDestroy
}, errorsBrowser = {};
function _inheritsLoose$1(a, u) {
  a.prototype = Object.create(u.prototype), a.prototype.constructor = a, a.__proto__ = u;
}
var codes = {};
function createErrorType(a, u, c) {
  c || (c = Error);
  function l(p, _, k) {
    return typeof u == "string" ? u : u(p, _, k);
  }
  var v = /* @__PURE__ */ function(p) {
    _inheritsLoose$1(_, p);
    function _(k, O, D) {
      return p.call(this, l(k, O, D)) || this;
    }
    return _;
  }(c);
  v.prototype.name = c.name, v.prototype.code = a, codes[a] = v;
}
function oneOf(a, u) {
  if (Array.isArray(a)) {
    var c = a.length;
    return a = a.map(function(l) {
      return String(l);
    }), c > 2 ? "one of ".concat(u, " ").concat(a.slice(0, c - 1).join(", "), ", or ") + a[c - 1] : c === 2 ? "one of ".concat(u, " ").concat(a[0], " or ").concat(a[1]) : "of ".concat(u, " ").concat(a[0]);
  } else
    return "of ".concat(u, " ").concat(String(a));
}
function startsWith(a, u, c) {
  return a.substr(!c || c < 0 ? 0 : +c, u.length) === u;
}
function endsWith(a, u, c) {
  return (c === void 0 || c > a.length) && (c = a.length), a.substring(c - u.length, c) === u;
}
function includes$2(a, u, c) {
  return typeof c != "number" && (c = 0), c + u.length > a.length ? !1 : a.indexOf(u, c) !== -1;
}
createErrorType("ERR_INVALID_OPT_VALUE", function(a, u) {
  return 'The value "' + u + '" is invalid for option "' + a + '"';
}, TypeError);
createErrorType("ERR_INVALID_ARG_TYPE", function(a, u, c) {
  var l;
  typeof u == "string" && startsWith(u, "not ") ? (l = "must not be", u = u.replace(/^not /, "")) : l = "must be";
  var v;
  if (endsWith(a, " argument"))
    v = "The ".concat(a, " ").concat(l, " ").concat(oneOf(u, "type"));
  else {
    var p = includes$2(a, ".") ? "property" : "argument";
    v = 'The "'.concat(a, '" ').concat(p, " ").concat(l, " ").concat(oneOf(u, "type"));
  }
  return v += ". Received type ".concat(typeof c), v;
}, TypeError);
createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(a) {
  return "The " + a + " method is not implemented";
});
createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
createErrorType("ERR_STREAM_DESTROYED", function(a) {
  return "Cannot call " + a + " after a stream was destroyed";
});
createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
createErrorType("ERR_UNKNOWN_ENCODING", function(a) {
  return "Unknown encoding: " + a;
}, TypeError);
createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
errorsBrowser.codes = codes;
var ERR_INVALID_OPT_VALUE = errorsBrowser.codes.ERR_INVALID_OPT_VALUE;
function highWaterMarkFrom(a, u, c) {
  return a.highWaterMark != null ? a.highWaterMark : u ? a[c] : null;
}
function getHighWaterMark(a, u, c, l) {
  var v = highWaterMarkFrom(u, l, c);
  if (v != null) {
    if (!(isFinite(v) && Math.floor(v) === v) || v < 0) {
      var p = l ? c : "highWaterMark";
      throw new ERR_INVALID_OPT_VALUE(p, v);
    }
    return Math.floor(v);
  }
  return a.objectMode ? 16 : 16 * 1024;
}
var state$3 = {
  getHighWaterMark
}, _stream_writable, hasRequired_stream_writable;
function require_stream_writable() {
  if (hasRequired_stream_writable)
    return _stream_writable;
  hasRequired_stream_writable = 1, _stream_writable = be;
  function a(ve) {
    var he = this;
    this.next = null, this.entry = null, this.finish = function() {
      $e(he, ve);
    };
  }
  var u;
  be.WritableState = Re;
  var c = {
    deprecate: browser$c
  }, l = streamBrowser, v = require$$0$2.Buffer, p = (typeof commonjsGlobal$1 < "u" ? commonjsGlobal$1 : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function _(ve) {
    return v.from(ve);
  }
  function k(ve) {
    return v.isBuffer(ve) || ve instanceof p;
  }
  var O = destroy_1, D = state$3, F = D.getHighWaterMark, z = errorsBrowser.codes, j = z.ERR_INVALID_ARG_TYPE, ee = z.ERR_METHOD_NOT_IMPLEMENTED, X = z.ERR_MULTIPLE_CALLBACK, ae = z.ERR_STREAM_CANNOT_PIPE, Q = z.ERR_STREAM_DESTROYED, ne = z.ERR_STREAM_NULL_VALUES, Z = z.ERR_STREAM_WRITE_AFTER_END, de = z.ERR_UNKNOWN_ENCODING, fe = O.errorOrDestroy;
  inherits_browserExports(be, l);
  function Te() {
  }
  function Re(ve, he, Oe) {
    u = u || require_stream_duplex(), ve = ve || {}, typeof Oe != "boolean" && (Oe = he instanceof u), this.objectMode = !!ve.objectMode, Oe && (this.objectMode = this.objectMode || !!ve.writableObjectMode), this.highWaterMark = F(this, ve, "writableHighWaterMark", Oe), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var Ae = ve.decodeStrings === !1;
    this.decodeStrings = !Ae, this.defaultEncoding = ve.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(Ue) {
      $(he, Ue);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = ve.emitClose !== !1, this.autoDestroy = !!ve.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new a(this);
  }
  Re.prototype.getBuffer = function() {
    for (var he = this.bufferedRequest, Oe = []; he; )
      Oe.push(he), he = he.next;
    return Oe;
  }, function() {
    try {
      Object.defineProperty(Re.prototype, "buffer", {
        get: c.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var Le;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (Le = Function.prototype[Symbol.hasInstance], Object.defineProperty(be, Symbol.hasInstance, {
    value: function(he) {
      return Le.call(this, he) ? !0 : this !== be ? !1 : he && he._writableState instanceof Re;
    }
  })) : Le = function(he) {
    return he instanceof this;
  };
  function be(ve) {
    u = u || require_stream_duplex();
    var he = this instanceof u;
    if (!he && !Le.call(be, this))
      return new be(ve);
    this._writableState = new Re(ve, this, he), this.writable = !0, ve && (typeof ve.write == "function" && (this._write = ve.write), typeof ve.writev == "function" && (this._writev = ve.writev), typeof ve.destroy == "function" && (this._destroy = ve.destroy), typeof ve.final == "function" && (this._final = ve.final)), l.call(this);
  }
  be.prototype.pipe = function() {
    fe(this, new ae());
  };
  function q(ve, he) {
    var Oe = new Z();
    fe(ve, Oe), process$1.nextTick(he, Oe);
  }
  function J(ve, he, Oe, Ae) {
    var Ue;
    return Oe === null ? Ue = new ne() : typeof Oe != "string" && !he.objectMode && (Ue = new j("chunk", ["string", "Buffer"], Oe)), Ue ? (fe(ve, Ue), process$1.nextTick(Ae, Ue), !1) : !0;
  }
  be.prototype.write = function(ve, he, Oe) {
    var Ae = this._writableState, Ue = !1, oe = !Ae.objectMode && k(ve);
    return oe && !v.isBuffer(ve) && (ve = _(ve)), typeof he == "function" && (Oe = he, he = null), oe ? he = "buffer" : he || (he = Ae.defaultEncoding), typeof Oe != "function" && (Oe = Te), Ae.ending ? q(this, Oe) : (oe || J(this, Ae, ve, Oe)) && (Ae.pendingcb++, Ue = S(this, Ae, oe, ve, he, Oe)), Ue;
  }, be.prototype.cork = function() {
    this._writableState.corked++;
  }, be.prototype.uncork = function() {
    var ve = this._writableState;
    ve.corked && (ve.corked--, !ve.writing && !ve.corked && !ve.bufferProcessing && ve.bufferedRequest && L(this, ve));
  }, be.prototype.setDefaultEncoding = function(he) {
    if (typeof he == "string" && (he = he.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((he + "").toLowerCase()) > -1))
      throw new de(he);
    return this._writableState.defaultEncoding = he, this;
  }, Object.defineProperty(be.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function C(ve, he, Oe) {
    return !ve.objectMode && ve.decodeStrings !== !1 && typeof he == "string" && (he = v.from(he, Oe)), he;
  }
  Object.defineProperty(be.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function S(ve, he, Oe, Ae, Ue, oe) {
    if (!Oe) {
      var A = C(he, Ae, Ue);
      Ae !== A && (Oe = !0, Ue = "buffer", Ae = A);
    }
    var re = he.objectMode ? 1 : Ae.length;
    he.length += re;
    var le = he.length < he.highWaterMark;
    if (le || (he.needDrain = !0), he.writing || he.corked) {
      var Ne = he.lastBufferedRequest;
      he.lastBufferedRequest = {
        chunk: Ae,
        encoding: Ue,
        isBuf: Oe,
        callback: oe,
        next: null
      }, Ne ? Ne.next = he.lastBufferedRequest : he.bufferedRequest = he.lastBufferedRequest, he.bufferedRequestCount += 1;
    } else
      E(ve, he, !1, re, Ae, Ue, oe);
    return le;
  }
  function E(ve, he, Oe, Ae, Ue, oe, A) {
    he.writelen = Ae, he.writecb = A, he.writing = !0, he.sync = !0, he.destroyed ? he.onwrite(new Q("write")) : Oe ? ve._writev(Ue, he.onwrite) : ve._write(Ue, oe, he.onwrite), he.sync = !1;
  }
  function I(ve, he, Oe, Ae, Ue) {
    --he.pendingcb, Oe ? (process$1.nextTick(Ue, Ae), process$1.nextTick(pe, ve, he), ve._writableState.errorEmitted = !0, fe(ve, Ae)) : (Ue(Ae), ve._writableState.errorEmitted = !0, fe(ve, Ae), pe(ve, he));
  }
  function M(ve) {
    ve.writing = !1, ve.writecb = null, ve.length -= ve.writelen, ve.writelen = 0;
  }
  function $(ve, he) {
    var Oe = ve._writableState, Ae = Oe.sync, Ue = Oe.writecb;
    if (typeof Ue != "function")
      throw new X();
    if (M(Oe), he)
      I(ve, Oe, Ae, he, Ue);
    else {
      var oe = T(Oe) || ve.destroyed;
      !oe && !Oe.corked && !Oe.bufferProcessing && Oe.bufferedRequest && L(ve, Oe), Ae ? process$1.nextTick(U, ve, Oe, oe, Ue) : U(ve, Oe, oe, Ue);
    }
  }
  function U(ve, he, Oe, Ae) {
    Oe || Y(ve, he), he.pendingcb--, Ae(), pe(ve, he);
  }
  function Y(ve, he) {
    he.length === 0 && he.needDrain && (he.needDrain = !1, ve.emit("drain"));
  }
  function L(ve, he) {
    he.bufferProcessing = !0;
    var Oe = he.bufferedRequest;
    if (ve._writev && Oe && Oe.next) {
      var Ae = he.bufferedRequestCount, Ue = new Array(Ae), oe = he.corkedRequestsFree;
      oe.entry = Oe;
      for (var A = 0, re = !0; Oe; )
        Ue[A] = Oe, Oe.isBuf || (re = !1), Oe = Oe.next, A += 1;
      Ue.allBuffers = re, E(ve, he, !0, he.length, Ue, "", oe.finish), he.pendingcb++, he.lastBufferedRequest = null, oe.next ? (he.corkedRequestsFree = oe.next, oe.next = null) : he.corkedRequestsFree = new a(he), he.bufferedRequestCount = 0;
    } else {
      for (; Oe; ) {
        var le = Oe.chunk, Ne = Oe.encoding, Pe = Oe.callback, Fe = he.objectMode ? 1 : le.length;
        if (E(ve, he, !1, Fe, le, Ne, Pe), Oe = Oe.next, he.bufferedRequestCount--, he.writing)
          break;
      }
      Oe === null && (he.lastBufferedRequest = null);
    }
    he.bufferedRequest = Oe, he.bufferProcessing = !1;
  }
  be.prototype._write = function(ve, he, Oe) {
    Oe(new ee("_write()"));
  }, be.prototype._writev = null, be.prototype.end = function(ve, he, Oe) {
    var Ae = this._writableState;
    return typeof ve == "function" ? (Oe = ve, ve = null, he = null) : typeof he == "function" && (Oe = he, he = null), ve != null && this.write(ve, he), Ae.corked && (Ae.corked = 1, this.uncork()), Ae.ending || Ie(this, Ae, Oe), this;
  }, Object.defineProperty(be.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function T(ve) {
    return ve.ending && ve.length === 0 && ve.bufferedRequest === null && !ve.finished && !ve.writing;
  }
  function B(ve, he) {
    ve._final(function(Oe) {
      he.pendingcb--, Oe && fe(ve, Oe), he.prefinished = !0, ve.emit("prefinish"), pe(ve, he);
    });
  }
  function te(ve, he) {
    !he.prefinished && !he.finalCalled && (typeof ve._final == "function" && !he.destroyed ? (he.pendingcb++, he.finalCalled = !0, process$1.nextTick(B, ve, he)) : (he.prefinished = !0, ve.emit("prefinish")));
  }
  function pe(ve, he) {
    var Oe = T(he);
    if (Oe && (te(ve, he), he.pendingcb === 0 && (he.finished = !0, ve.emit("finish"), he.autoDestroy))) {
      var Ae = ve._readableState;
      (!Ae || Ae.autoDestroy && Ae.endEmitted) && ve.destroy();
    }
    return Oe;
  }
  function Ie(ve, he, Oe) {
    he.ending = !0, pe(ve, he), Oe && (he.finished ? process$1.nextTick(Oe) : ve.once("finish", Oe)), he.ended = !0, ve.writable = !1;
  }
  function $e(ve, he, Oe) {
    var Ae = ve.entry;
    for (ve.entry = null; Ae; ) {
      var Ue = Ae.callback;
      he.pendingcb--, Ue(Oe), Ae = Ae.next;
    }
    he.corkedRequestsFree.next = ve;
  }
  return Object.defineProperty(be.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(he) {
      this._writableState && (this._writableState.destroyed = he);
    }
  }), be.prototype.destroy = O.destroy, be.prototype._undestroy = O.undestroy, be.prototype._destroy = function(ve, he) {
    he(ve);
  }, _stream_writable;
}
var _stream_duplex, hasRequired_stream_duplex;
function require_stream_duplex() {
  if (hasRequired_stream_duplex)
    return _stream_duplex;
  hasRequired_stream_duplex = 1;
  var a = Object.keys || function(D) {
    var F = [];
    for (var z in D)
      F.push(z);
    return F;
  };
  _stream_duplex = _;
  var u = require_stream_readable(), c = require_stream_writable();
  inherits_browserExports(_, u);
  for (var l = a(c.prototype), v = 0; v < l.length; v++) {
    var p = l[v];
    _.prototype[p] || (_.prototype[p] = c.prototype[p]);
  }
  function _(D) {
    if (!(this instanceof _))
      return new _(D);
    u.call(this, D), c.call(this, D), this.allowHalfOpen = !0, D && (D.readable === !1 && (this.readable = !1), D.writable === !1 && (this.writable = !1), D.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", k)));
  }
  Object.defineProperty(_.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(_.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(_.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function k() {
    this._writableState.ended || process$1.nextTick(O, this);
  }
  function O(D) {
    D.end();
  }
  return Object.defineProperty(_.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(F) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = F, this._writableState.destroyed = F);
    }
  }), _stream_duplex;
}
var ERR_STREAM_PREMATURE_CLOSE = errorsBrowser.codes.ERR_STREAM_PREMATURE_CLOSE;
function once$3(a) {
  var u = !1;
  return function() {
    if (!u) {
      u = !0;
      for (var c = arguments.length, l = new Array(c), v = 0; v < c; v++)
        l[v] = arguments[v];
      a.apply(this, l);
    }
  };
}
function noop$2() {
}
function isRequest$1(a) {
  return a.setHeader && typeof a.abort == "function";
}
function eos$1(a, u, c) {
  if (typeof u == "function")
    return eos$1(a, null, u);
  u || (u = {}), c = once$3(c || noop$2);
  var l = u.readable || u.readable !== !1 && a.readable, v = u.writable || u.writable !== !1 && a.writable, p = function() {
    a.writable || k();
  }, _ = a._writableState && a._writableState.finished, k = function() {
    v = !1, _ = !0, l || c.call(a);
  }, O = a._readableState && a._readableState.endEmitted, D = function() {
    l = !1, O = !0, v || c.call(a);
  }, F = function(X) {
    c.call(a, X);
  }, z = function() {
    var X;
    if (l && !O)
      return (!a._readableState || !a._readableState.ended) && (X = new ERR_STREAM_PREMATURE_CLOSE()), c.call(a, X);
    if (v && !_)
      return (!a._writableState || !a._writableState.ended) && (X = new ERR_STREAM_PREMATURE_CLOSE()), c.call(a, X);
  }, j = function() {
    a.req.on("finish", k);
  };
  return isRequest$1(a) ? (a.on("complete", k), a.on("abort", z), a.req ? j() : a.on("request", j)) : v && !a._writableState && (a.on("end", p), a.on("close", p)), a.on("end", D), a.on("finish", k), u.error !== !1 && a.on("error", F), a.on("close", z), function() {
    a.removeListener("complete", k), a.removeListener("abort", z), a.removeListener("request", j), a.req && a.req.removeListener("finish", k), a.removeListener("end", p), a.removeListener("close", p), a.removeListener("finish", k), a.removeListener("end", D), a.removeListener("error", F), a.removeListener("close", z);
  };
}
var endOfStream = eos$1, async_iterator, hasRequiredAsync_iterator;
function requireAsync_iterator() {
  if (hasRequiredAsync_iterator)
    return async_iterator;
  hasRequiredAsync_iterator = 1;
  var a;
  function u(de, fe, Te) {
    return fe = c(fe), fe in de ? Object.defineProperty(de, fe, { value: Te, enumerable: !0, configurable: !0, writable: !0 }) : de[fe] = Te, de;
  }
  function c(de) {
    var fe = l(de, "string");
    return typeof fe == "symbol" ? fe : String(fe);
  }
  function l(de, fe) {
    if (typeof de != "object" || de === null)
      return de;
    var Te = de[Symbol.toPrimitive];
    if (Te !== void 0) {
      var Re = Te.call(de, fe || "default");
      if (typeof Re != "object")
        return Re;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (fe === "string" ? String : Number)(de);
  }
  var v = endOfStream, p = Symbol("lastResolve"), _ = Symbol("lastReject"), k = Symbol("error"), O = Symbol("ended"), D = Symbol("lastPromise"), F = Symbol("handlePromise"), z = Symbol("stream");
  function j(de, fe) {
    return {
      value: de,
      done: fe
    };
  }
  function ee(de) {
    var fe = de[p];
    if (fe !== null) {
      var Te = de[z].read();
      Te !== null && (de[D] = null, de[p] = null, de[_] = null, fe(j(Te, !1)));
    }
  }
  function X(de) {
    process$1.nextTick(ee, de);
  }
  function ae(de, fe) {
    return function(Te, Re) {
      de.then(function() {
        if (fe[O]) {
          Te(j(void 0, !0));
          return;
        }
        fe[F](Te, Re);
      }, Re);
    };
  }
  var Q = Object.getPrototypeOf(function() {
  }), ne = Object.setPrototypeOf((a = {
    get stream() {
      return this[z];
    },
    next: function() {
      var fe = this, Te = this[k];
      if (Te !== null)
        return Promise.reject(Te);
      if (this[O])
        return Promise.resolve(j(void 0, !0));
      if (this[z].destroyed)
        return new Promise(function(q, J) {
          process$1.nextTick(function() {
            fe[k] ? J(fe[k]) : q(j(void 0, !0));
          });
        });
      var Re = this[D], Le;
      if (Re)
        Le = new Promise(ae(Re, this));
      else {
        var be = this[z].read();
        if (be !== null)
          return Promise.resolve(j(be, !1));
        Le = new Promise(this[F]);
      }
      return this[D] = Le, Le;
    }
  }, u(a, Symbol.asyncIterator, function() {
    return this;
  }), u(a, "return", function() {
    var fe = this;
    return new Promise(function(Te, Re) {
      fe[z].destroy(null, function(Le) {
        if (Le) {
          Re(Le);
          return;
        }
        Te(j(void 0, !0));
      });
    });
  }), a), Q), Z = function(fe) {
    var Te, Re = Object.create(ne, (Te = {}, u(Te, z, {
      value: fe,
      writable: !0
    }), u(Te, p, {
      value: null,
      writable: !0
    }), u(Te, _, {
      value: null,
      writable: !0
    }), u(Te, k, {
      value: null,
      writable: !0
    }), u(Te, O, {
      value: fe._readableState.endEmitted,
      writable: !0
    }), u(Te, F, {
      value: function(be, q) {
        var J = Re[z].read();
        J ? (Re[D] = null, Re[p] = null, Re[_] = null, be(j(J, !1))) : (Re[p] = be, Re[_] = q);
      },
      writable: !0
    }), Te));
    return Re[D] = null, v(fe, function(Le) {
      if (Le && Le.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var be = Re[_];
        be !== null && (Re[D] = null, Re[p] = null, Re[_] = null, be(Le)), Re[k] = Le;
        return;
      }
      var q = Re[p];
      q !== null && (Re[D] = null, Re[p] = null, Re[_] = null, q(j(void 0, !0))), Re[O] = !0;
    }), fe.on("readable", X.bind(null, Re)), Re;
  };
  return async_iterator = Z, async_iterator;
}
var fromBrowser, hasRequiredFromBrowser;
function requireFromBrowser() {
  return hasRequiredFromBrowser || (hasRequiredFromBrowser = 1, fromBrowser = function() {
    throw new Error("Readable.from is not available in the browser");
  }), fromBrowser;
}
var _stream_readable, hasRequired_stream_readable;
function require_stream_readable() {
  if (hasRequired_stream_readable)
    return _stream_readable;
  hasRequired_stream_readable = 1, _stream_readable = q;
  var a;
  q.ReadableState = be, eventsExports.EventEmitter;
  var u = function(A, re) {
    return A.listeners(re).length;
  }, c = streamBrowser, l = require$$0$2.Buffer, v = (typeof commonjsGlobal$1 < "u" ? commonjsGlobal$1 : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function p(oe) {
    return l.from(oe);
  }
  function _(oe) {
    return l.isBuffer(oe) || oe instanceof v;
  }
  var k = util$4, O;
  k && k.debuglog ? O = k.debuglog("stream") : O = function() {
  };
  var D = requireBuffer_list(), F = destroy_1, z = state$3, j = z.getHighWaterMark, ee = errorsBrowser.codes, X = ee.ERR_INVALID_ARG_TYPE, ae = ee.ERR_STREAM_PUSH_AFTER_EOF, Q = ee.ERR_METHOD_NOT_IMPLEMENTED, ne = ee.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, Z, de, fe;
  inherits_browserExports(q, c);
  var Te = F.errorOrDestroy, Re = ["error", "close", "destroy", "pause", "resume"];
  function Le(oe, A, re) {
    if (typeof oe.prependListener == "function")
      return oe.prependListener(A, re);
    !oe._events || !oe._events[A] ? oe.on(A, re) : Array.isArray(oe._events[A]) ? oe._events[A].unshift(re) : oe._events[A] = [re, oe._events[A]];
  }
  function be(oe, A, re) {
    a = a || require_stream_duplex(), oe = oe || {}, typeof re != "boolean" && (re = A instanceof a), this.objectMode = !!oe.objectMode, re && (this.objectMode = this.objectMode || !!oe.readableObjectMode), this.highWaterMark = j(this, oe, "readableHighWaterMark", re), this.buffer = new D(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = oe.emitClose !== !1, this.autoDestroy = !!oe.autoDestroy, this.destroyed = !1, this.defaultEncoding = oe.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, oe.encoding && (Z || (Z = string_decoder.StringDecoder), this.decoder = new Z(oe.encoding), this.encoding = oe.encoding);
  }
  function q(oe) {
    if (a = a || require_stream_duplex(), !(this instanceof q))
      return new q(oe);
    var A = this instanceof a;
    this._readableState = new be(oe, this, A), this.readable = !0, oe && (typeof oe.read == "function" && (this._read = oe.read), typeof oe.destroy == "function" && (this._destroy = oe.destroy)), c.call(this);
  }
  Object.defineProperty(q.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(A) {
      this._readableState && (this._readableState.destroyed = A);
    }
  }), q.prototype.destroy = F.destroy, q.prototype._undestroy = F.undestroy, q.prototype._destroy = function(oe, A) {
    A(oe);
  }, q.prototype.push = function(oe, A) {
    var re = this._readableState, le;
    return re.objectMode ? le = !0 : typeof oe == "string" && (A = A || re.defaultEncoding, A !== re.encoding && (oe = l.from(oe, A), A = ""), le = !0), J(this, oe, A, !1, le);
  }, q.prototype.unshift = function(oe) {
    return J(this, oe, null, !0, !1);
  };
  function J(oe, A, re, le, Ne) {
    O("readableAddChunk", A);
    var Pe = oe._readableState;
    if (A === null)
      Pe.reading = !1, $(oe, Pe);
    else {
      var Fe;
      if (Ne || (Fe = S(Pe, A)), Fe)
        Te(oe, Fe);
      else if (Pe.objectMode || A && A.length > 0)
        if (typeof A != "string" && !Pe.objectMode && Object.getPrototypeOf(A) !== l.prototype && (A = p(A)), le)
          Pe.endEmitted ? Te(oe, new ne()) : C(oe, Pe, A, !0);
        else if (Pe.ended)
          Te(oe, new ae());
        else {
          if (Pe.destroyed)
            return !1;
          Pe.reading = !1, Pe.decoder && !re ? (A = Pe.decoder.write(A), Pe.objectMode || A.length !== 0 ? C(oe, Pe, A, !1) : L(oe, Pe)) : C(oe, Pe, A, !1);
        }
      else
        le || (Pe.reading = !1, L(oe, Pe));
    }
    return !Pe.ended && (Pe.length < Pe.highWaterMark || Pe.length === 0);
  }
  function C(oe, A, re, le) {
    A.flowing && A.length === 0 && !A.sync ? (A.awaitDrain = 0, oe.emit("data", re)) : (A.length += A.objectMode ? 1 : re.length, le ? A.buffer.unshift(re) : A.buffer.push(re), A.needReadable && U(oe)), L(oe, A);
  }
  function S(oe, A) {
    var re;
    return !_(A) && typeof A != "string" && A !== void 0 && !oe.objectMode && (re = new X("chunk", ["string", "Buffer", "Uint8Array"], A)), re;
  }
  q.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, q.prototype.setEncoding = function(oe) {
    Z || (Z = string_decoder.StringDecoder);
    var A = new Z(oe);
    this._readableState.decoder = A, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var re = this._readableState.buffer.head, le = ""; re !== null; )
      le += A.write(re.data), re = re.next;
    return this._readableState.buffer.clear(), le !== "" && this._readableState.buffer.push(le), this._readableState.length = le.length, this;
  };
  var E = 1073741824;
  function I(oe) {
    return oe >= E ? oe = E : (oe--, oe |= oe >>> 1, oe |= oe >>> 2, oe |= oe >>> 4, oe |= oe >>> 8, oe |= oe >>> 16, oe++), oe;
  }
  function M(oe, A) {
    return oe <= 0 || A.length === 0 && A.ended ? 0 : A.objectMode ? 1 : oe !== oe ? A.flowing && A.length ? A.buffer.head.data.length : A.length : (oe > A.highWaterMark && (A.highWaterMark = I(oe)), oe <= A.length ? oe : A.ended ? A.length : (A.needReadable = !0, 0));
  }
  q.prototype.read = function(oe) {
    O("read", oe), oe = parseInt(oe, 10);
    var A = this._readableState, re = oe;
    if (oe !== 0 && (A.emittedReadable = !1), oe === 0 && A.needReadable && ((A.highWaterMark !== 0 ? A.length >= A.highWaterMark : A.length > 0) || A.ended))
      return O("read: emitReadable", A.length, A.ended), A.length === 0 && A.ended ? Oe(this) : U(this), null;
    if (oe = M(oe, A), oe === 0 && A.ended)
      return A.length === 0 && Oe(this), null;
    var le = A.needReadable;
    O("need readable", le), (A.length === 0 || A.length - oe < A.highWaterMark) && (le = !0, O("length less than watermark", le)), A.ended || A.reading ? (le = !1, O("reading or ended", le)) : le && (O("do read"), A.reading = !0, A.sync = !0, A.length === 0 && (A.needReadable = !0), this._read(A.highWaterMark), A.sync = !1, A.reading || (oe = M(re, A)));
    var Ne;
    return oe > 0 ? Ne = he(oe, A) : Ne = null, Ne === null ? (A.needReadable = A.length <= A.highWaterMark, oe = 0) : (A.length -= oe, A.awaitDrain = 0), A.length === 0 && (A.ended || (A.needReadable = !0), re !== oe && A.ended && Oe(this)), Ne !== null && this.emit("data", Ne), Ne;
  };
  function $(oe, A) {
    if (O("onEofChunk"), !A.ended) {
      if (A.decoder) {
        var re = A.decoder.end();
        re && re.length && (A.buffer.push(re), A.length += A.objectMode ? 1 : re.length);
      }
      A.ended = !0, A.sync ? U(oe) : (A.needReadable = !1, A.emittedReadable || (A.emittedReadable = !0, Y(oe)));
    }
  }
  function U(oe) {
    var A = oe._readableState;
    O("emitReadable", A.needReadable, A.emittedReadable), A.needReadable = !1, A.emittedReadable || (O("emitReadable", A.flowing), A.emittedReadable = !0, process$1.nextTick(Y, oe));
  }
  function Y(oe) {
    var A = oe._readableState;
    O("emitReadable_", A.destroyed, A.length, A.ended), !A.destroyed && (A.length || A.ended) && (oe.emit("readable"), A.emittedReadable = !1), A.needReadable = !A.flowing && !A.ended && A.length <= A.highWaterMark, ve(oe);
  }
  function L(oe, A) {
    A.readingMore || (A.readingMore = !0, process$1.nextTick(T, oe, A));
  }
  function T(oe, A) {
    for (; !A.reading && !A.ended && (A.length < A.highWaterMark || A.flowing && A.length === 0); ) {
      var re = A.length;
      if (O("maybeReadMore read 0"), oe.read(0), re === A.length)
        break;
    }
    A.readingMore = !1;
  }
  q.prototype._read = function(oe) {
    Te(this, new Q("_read()"));
  }, q.prototype.pipe = function(oe, A) {
    var re = this, le = this._readableState;
    switch (le.pipesCount) {
      case 0:
        le.pipes = oe;
        break;
      case 1:
        le.pipes = [le.pipes, oe];
        break;
      default:
        le.pipes.push(oe);
        break;
    }
    le.pipesCount += 1, O("pipe count=%d opts=%j", le.pipesCount, A);
    var Ne = (!A || A.end !== !1) && oe !== process$1.stdout && oe !== process$1.stderr, Pe = Ne ? je : We;
    le.endEmitted ? process$1.nextTick(Pe) : re.once("end", Pe), oe.on("unpipe", Fe);
    function Fe(we, V) {
      O("onunpipe"), we === re && V && V.hasUnpiped === !1 && (V.hasUnpiped = !0, Xe());
    }
    function je() {
      O("onend"), oe.end();
    }
    var qe = B(re);
    oe.on("drain", qe);
    var yt = !1;
    function Xe() {
      O("cleanup"), oe.removeListener("close", ye), oe.removeListener("finish", Ee), oe.removeListener("drain", qe), oe.removeListener("error", H), oe.removeListener("unpipe", Fe), re.removeListener("end", je), re.removeListener("end", We), re.removeListener("data", Ge), yt = !0, le.awaitDrain && (!oe._writableState || oe._writableState.needDrain) && qe();
    }
    re.on("data", Ge);
    function Ge(we) {
      O("ondata");
      var V = oe.write(we);
      O("dest.write", V), V === !1 && ((le.pipesCount === 1 && le.pipes === oe || le.pipesCount > 1 && Ue(le.pipes, oe) !== -1) && !yt && (O("false write response, pause", le.awaitDrain), le.awaitDrain++), re.pause());
    }
    function H(we) {
      O("onerror", we), We(), oe.removeListener("error", H), u(oe, "error") === 0 && Te(oe, we);
    }
    Le(oe, "error", H);
    function ye() {
      oe.removeListener("finish", Ee), We();
    }
    oe.once("close", ye);
    function Ee() {
      O("onfinish"), oe.removeListener("close", ye), We();
    }
    oe.once("finish", Ee);
    function We() {
      O("unpipe"), re.unpipe(oe);
    }
    return oe.emit("pipe", re), le.flowing || (O("pipe resume"), re.resume()), oe;
  };
  function B(oe) {
    return function() {
      var re = oe._readableState;
      O("pipeOnDrain", re.awaitDrain), re.awaitDrain && re.awaitDrain--, re.awaitDrain === 0 && u(oe, "data") && (re.flowing = !0, ve(oe));
    };
  }
  q.prototype.unpipe = function(oe) {
    var A = this._readableState, re = {
      hasUnpiped: !1
    };
    if (A.pipesCount === 0)
      return this;
    if (A.pipesCount === 1)
      return oe && oe !== A.pipes ? this : (oe || (oe = A.pipes), A.pipes = null, A.pipesCount = 0, A.flowing = !1, oe && oe.emit("unpipe", this, re), this);
    if (!oe) {
      var le = A.pipes, Ne = A.pipesCount;
      A.pipes = null, A.pipesCount = 0, A.flowing = !1;
      for (var Pe = 0; Pe < Ne; Pe++)
        le[Pe].emit("unpipe", this, {
          hasUnpiped: !1
        });
      return this;
    }
    var Fe = Ue(A.pipes, oe);
    return Fe === -1 ? this : (A.pipes.splice(Fe, 1), A.pipesCount -= 1, A.pipesCount === 1 && (A.pipes = A.pipes[0]), oe.emit("unpipe", this, re), this);
  }, q.prototype.on = function(oe, A) {
    var re = c.prototype.on.call(this, oe, A), le = this._readableState;
    return oe === "data" ? (le.readableListening = this.listenerCount("readable") > 0, le.flowing !== !1 && this.resume()) : oe === "readable" && !le.endEmitted && !le.readableListening && (le.readableListening = le.needReadable = !0, le.flowing = !1, le.emittedReadable = !1, O("on readable", le.length, le.reading), le.length ? U(this) : le.reading || process$1.nextTick(pe, this)), re;
  }, q.prototype.addListener = q.prototype.on, q.prototype.removeListener = function(oe, A) {
    var re = c.prototype.removeListener.call(this, oe, A);
    return oe === "readable" && process$1.nextTick(te, this), re;
  }, q.prototype.removeAllListeners = function(oe) {
    var A = c.prototype.removeAllListeners.apply(this, arguments);
    return (oe === "readable" || oe === void 0) && process$1.nextTick(te, this), A;
  };
  function te(oe) {
    var A = oe._readableState;
    A.readableListening = oe.listenerCount("readable") > 0, A.resumeScheduled && !A.paused ? A.flowing = !0 : oe.listenerCount("data") > 0 && oe.resume();
  }
  function pe(oe) {
    O("readable nexttick read 0"), oe.read(0);
  }
  q.prototype.resume = function() {
    var oe = this._readableState;
    return oe.flowing || (O("resume"), oe.flowing = !oe.readableListening, Ie(this, oe)), oe.paused = !1, this;
  };
  function Ie(oe, A) {
    A.resumeScheduled || (A.resumeScheduled = !0, process$1.nextTick($e, oe, A));
  }
  function $e(oe, A) {
    O("resume", A.reading), A.reading || oe.read(0), A.resumeScheduled = !1, oe.emit("resume"), ve(oe), A.flowing && !A.reading && oe.read(0);
  }
  q.prototype.pause = function() {
    return O("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (O("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function ve(oe) {
    var A = oe._readableState;
    for (O("flow", A.flowing); A.flowing && oe.read() !== null; )
      ;
  }
  q.prototype.wrap = function(oe) {
    var A = this, re = this._readableState, le = !1;
    oe.on("end", function() {
      if (O("wrapped end"), re.decoder && !re.ended) {
        var Fe = re.decoder.end();
        Fe && Fe.length && A.push(Fe);
      }
      A.push(null);
    }), oe.on("data", function(Fe) {
      if (O("wrapped data"), re.decoder && (Fe = re.decoder.write(Fe)), !(re.objectMode && Fe == null) && !(!re.objectMode && (!Fe || !Fe.length))) {
        var je = A.push(Fe);
        je || (le = !0, oe.pause());
      }
    });
    for (var Ne in oe)
      this[Ne] === void 0 && typeof oe[Ne] == "function" && (this[Ne] = /* @__PURE__ */ function(je) {
        return function() {
          return oe[je].apply(oe, arguments);
        };
      }(Ne));
    for (var Pe = 0; Pe < Re.length; Pe++)
      oe.on(Re[Pe], this.emit.bind(this, Re[Pe]));
    return this._read = function(Fe) {
      O("wrapped _read", Fe), le && (le = !1, oe.resume());
    }, this;
  }, typeof Symbol == "function" && (q.prototype[Symbol.asyncIterator] = function() {
    return de === void 0 && (de = requireAsync_iterator()), de(this);
  }), Object.defineProperty(q.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(q.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(q.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(A) {
      this._readableState && (this._readableState.flowing = A);
    }
  }), q._fromList = he, Object.defineProperty(q.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function he(oe, A) {
    if (A.length === 0)
      return null;
    var re;
    return A.objectMode ? re = A.buffer.shift() : !oe || oe >= A.length ? (A.decoder ? re = A.buffer.join("") : A.buffer.length === 1 ? re = A.buffer.first() : re = A.buffer.concat(A.length), A.buffer.clear()) : re = A.buffer.consume(oe, A.decoder), re;
  }
  function Oe(oe) {
    var A = oe._readableState;
    O("endReadable", A.endEmitted), A.endEmitted || (A.ended = !0, process$1.nextTick(Ae, A, oe));
  }
  function Ae(oe, A) {
    if (O("endReadableNT", oe.endEmitted, oe.length), !oe.endEmitted && oe.length === 0 && (oe.endEmitted = !0, A.readable = !1, A.emit("end"), oe.autoDestroy)) {
      var re = A._writableState;
      (!re || re.autoDestroy && re.finished) && A.destroy();
    }
  }
  typeof Symbol == "function" && (q.from = function(oe, A) {
    return fe === void 0 && (fe = requireFromBrowser()), fe(q, oe, A);
  });
  function Ue(oe, A) {
    for (var re = 0, le = oe.length; re < le; re++)
      if (oe[re] === A)
        return re;
    return -1;
  }
  return _stream_readable;
}
var _stream_transform = Transform$1, _require$codes$1 = errorsBrowser.codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes$1.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes$1.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes$1.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes$1.ERR_TRANSFORM_WITH_LENGTH_0, Duplex = require_stream_duplex();
inherits_browserExports(Transform$1, Duplex);
function afterTransform(a, u) {
  var c = this._transformState;
  c.transforming = !1;
  var l = c.writecb;
  if (l === null)
    return this.emit("error", new ERR_MULTIPLE_CALLBACK());
  c.writechunk = null, c.writecb = null, u != null && this.push(u), l(a);
  var v = this._readableState;
  v.reading = !1, (v.needReadable || v.length < v.highWaterMark) && this._read(v.highWaterMark);
}
function Transform$1(a) {
  if (!(this instanceof Transform$1))
    return new Transform$1(a);
  Duplex.call(this, a), this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: !1,
    transforming: !1,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }, this._readableState.needReadable = !0, this._readableState.sync = !1, a && (typeof a.transform == "function" && (this._transform = a.transform), typeof a.flush == "function" && (this._flush = a.flush)), this.on("prefinish", prefinish);
}
function prefinish() {
  var a = this;
  typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(u, c) {
    done(a, u, c);
  }) : done(this, null, null);
}
Transform$1.prototype.push = function(a, u) {
  return this._transformState.needTransform = !1, Duplex.prototype.push.call(this, a, u);
};
Transform$1.prototype._transform = function(a, u, c) {
  c(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
};
Transform$1.prototype._write = function(a, u, c) {
  var l = this._transformState;
  if (l.writecb = c, l.writechunk = a, l.writeencoding = u, !l.transforming) {
    var v = this._readableState;
    (l.needTransform || v.needReadable || v.length < v.highWaterMark) && this._read(v.highWaterMark);
  }
};
Transform$1.prototype._read = function(a) {
  var u = this._transformState;
  u.writechunk !== null && !u.transforming ? (u.transforming = !0, this._transform(u.writechunk, u.writeencoding, u.afterTransform)) : u.needTransform = !0;
};
Transform$1.prototype._destroy = function(a, u) {
  Duplex.prototype._destroy.call(this, a, function(c) {
    u(c);
  });
};
function done(a, u, c) {
  if (u)
    return a.emit("error", u);
  if (c != null && a.push(c), a._writableState.length)
    throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (a._transformState.transforming)
    throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return a.push(null);
}
var _stream_passthrough = PassThrough, Transform = _stream_transform;
inherits_browserExports(PassThrough, Transform);
function PassThrough(a) {
  if (!(this instanceof PassThrough))
    return new PassThrough(a);
  Transform.call(this, a);
}
PassThrough.prototype._transform = function(a, u, c) {
  c(null, a);
};
var eos;
function once$2(a) {
  var u = !1;
  return function() {
    u || (u = !0, a.apply(void 0, arguments));
  };
}
var _require$codes = errorsBrowser.codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
function noop$1(a) {
  if (a)
    throw a;
}
function isRequest(a) {
  return a.setHeader && typeof a.abort == "function";
}
function destroyer(a, u, c, l) {
  l = once$2(l);
  var v = !1;
  a.on("close", function() {
    v = !0;
  }), eos === void 0 && (eos = endOfStream), eos(a, {
    readable: u,
    writable: c
  }, function(_) {
    if (_)
      return l(_);
    v = !0, l();
  });
  var p = !1;
  return function(_) {
    if (!v && !p) {
      if (p = !0, isRequest(a))
        return a.abort();
      if (typeof a.destroy == "function")
        return a.destroy();
      l(_ || new ERR_STREAM_DESTROYED("pipe"));
    }
  };
}
function call(a) {
  a();
}
function pipe(a, u) {
  return a.pipe(u);
}
function popCallback(a) {
  return !a.length || typeof a[a.length - 1] != "function" ? noop$1 : a.pop();
}
function pipeline() {
  for (var a = arguments.length, u = new Array(a), c = 0; c < a; c++)
    u[c] = arguments[c];
  var l = popCallback(u);
  if (Array.isArray(u[0]) && (u = u[0]), u.length < 2)
    throw new ERR_MISSING_ARGS("streams");
  var v, p = u.map(function(_, k) {
    var O = k < u.length - 1, D = k > 0;
    return destroyer(_, O, D, function(F) {
      v || (v = F), F && p.forEach(call), !O && (p.forEach(call), l(v));
    });
  });
  return u.reduce(pipe);
}
var pipeline_1 = pipeline;
(function(a, u) {
  u = a.exports = require_stream_readable(), u.Stream = u, u.Readable = u, u.Writable = require_stream_writable(), u.Duplex = require_stream_duplex(), u.Transform = _stream_transform, u.PassThrough = _stream_passthrough, u.finished = endOfStream, u.pipeline = pipeline_1;
})(readableBrowser, readableBrowser.exports);
var readableBrowserExports = readableBrowser.exports, sign$1 = { exports: {} }, bn$4 = { exports: {} };
bn$4.exports;
(function(a) {
  (function(u, c) {
    function l(E, I) {
      if (!E)
        throw new Error(I || "Assertion failed");
    }
    function v(E, I) {
      E.super_ = I;
      var M = function() {
      };
      M.prototype = I.prototype, E.prototype = new M(), E.prototype.constructor = E;
    }
    function p(E, I, M) {
      if (p.isBN(E))
        return E;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, E !== null && ((I === "le" || I === "be") && (M = I, I = 10), this._init(E || 0, I || 10, M || "be"));
    }
    typeof u == "object" ? u.exports = p : c.BN = p, p.BN = p, p.wordSize = 26;
    var _;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? _ = window.Buffer : _ = require$$0$2.Buffer;
    } catch {
    }
    p.isBN = function(I) {
      return I instanceof p ? !0 : I !== null && typeof I == "object" && I.constructor.wordSize === p.wordSize && Array.isArray(I.words);
    }, p.max = function(I, M) {
      return I.cmp(M) > 0 ? I : M;
    }, p.min = function(I, M) {
      return I.cmp(M) < 0 ? I : M;
    }, p.prototype._init = function(I, M, $) {
      if (typeof I == "number")
        return this._initNumber(I, M, $);
      if (typeof I == "object")
        return this._initArray(I, M, $);
      M === "hex" && (M = 16), l(M === (M | 0) && M >= 2 && M <= 36), I = I.toString().replace(/\s+/g, "");
      var U = 0;
      I[0] === "-" && (U++, this.negative = 1), U < I.length && (M === 16 ? this._parseHex(I, U, $) : (this._parseBase(I, M, U), $ === "le" && this._initArray(this.toArray(), M, $)));
    }, p.prototype._initNumber = function(I, M, $) {
      I < 0 && (this.negative = 1, I = -I), I < 67108864 ? (this.words = [I & 67108863], this.length = 1) : I < 4503599627370496 ? (this.words = [
        I & 67108863,
        I / 67108864 & 67108863
      ], this.length = 2) : (l(I < 9007199254740992), this.words = [
        I & 67108863,
        I / 67108864 & 67108863,
        1
      ], this.length = 3), $ === "le" && this._initArray(this.toArray(), M, $);
    }, p.prototype._initArray = function(I, M, $) {
      if (l(typeof I.length == "number"), I.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(I.length / 3), this.words = new Array(this.length);
      for (var U = 0; U < this.length; U++)
        this.words[U] = 0;
      var Y, L, T = 0;
      if ($ === "be")
        for (U = I.length - 1, Y = 0; U >= 0; U -= 3)
          L = I[U] | I[U - 1] << 8 | I[U - 2] << 16, this.words[Y] |= L << T & 67108863, this.words[Y + 1] = L >>> 26 - T & 67108863, T += 24, T >= 26 && (T -= 26, Y++);
      else if ($ === "le")
        for (U = 0, Y = 0; U < I.length; U += 3)
          L = I[U] | I[U + 1] << 8 | I[U + 2] << 16, this.words[Y] |= L << T & 67108863, this.words[Y + 1] = L >>> 26 - T & 67108863, T += 24, T >= 26 && (T -= 26, Y++);
      return this._strip();
    };
    function k(E, I) {
      var M = E.charCodeAt(I);
      if (M >= 48 && M <= 57)
        return M - 48;
      if (M >= 65 && M <= 70)
        return M - 55;
      if (M >= 97 && M <= 102)
        return M - 87;
      l(!1, "Invalid character in " + E);
    }
    function O(E, I, M) {
      var $ = k(E, M);
      return M - 1 >= I && ($ |= k(E, M - 1) << 4), $;
    }
    p.prototype._parseHex = function(I, M, $) {
      this.length = Math.ceil((I.length - M) / 6), this.words = new Array(this.length);
      for (var U = 0; U < this.length; U++)
        this.words[U] = 0;
      var Y = 0, L = 0, T;
      if ($ === "be")
        for (U = I.length - 1; U >= M; U -= 2)
          T = O(I, M, U) << Y, this.words[L] |= T & 67108863, Y >= 18 ? (Y -= 18, L += 1, this.words[L] |= T >>> 26) : Y += 8;
      else {
        var B = I.length - M;
        for (U = B % 2 === 0 ? M + 1 : M; U < I.length; U += 2)
          T = O(I, M, U) << Y, this.words[L] |= T & 67108863, Y >= 18 ? (Y -= 18, L += 1, this.words[L] |= T >>> 26) : Y += 8;
      }
      this._strip();
    };
    function D(E, I, M, $) {
      for (var U = 0, Y = 0, L = Math.min(E.length, M), T = I; T < L; T++) {
        var B = E.charCodeAt(T) - 48;
        U *= $, B >= 49 ? Y = B - 49 + 10 : B >= 17 ? Y = B - 17 + 10 : Y = B, l(B >= 0 && Y < $, "Invalid character"), U += Y;
      }
      return U;
    }
    p.prototype._parseBase = function(I, M, $) {
      this.words = [0], this.length = 1;
      for (var U = 0, Y = 1; Y <= 67108863; Y *= M)
        U++;
      U--, Y = Y / M | 0;
      for (var L = I.length - $, T = L % U, B = Math.min(L, L - T) + $, te = 0, pe = $; pe < B; pe += U)
        te = D(I, pe, pe + U, M), this.imuln(Y), this.words[0] + te < 67108864 ? this.words[0] += te : this._iaddn(te);
      if (T !== 0) {
        var Ie = 1;
        for (te = D(I, pe, I.length, M), pe = 0; pe < T; pe++)
          Ie *= M;
        this.imuln(Ie), this.words[0] + te < 67108864 ? this.words[0] += te : this._iaddn(te);
      }
      this._strip();
    }, p.prototype.copy = function(I) {
      I.words = new Array(this.length);
      for (var M = 0; M < this.length; M++)
        I.words[M] = this.words[M];
      I.length = this.length, I.negative = this.negative, I.red = this.red;
    };
    function F(E, I) {
      E.words = I.words, E.length = I.length, E.negative = I.negative, E.red = I.red;
    }
    if (p.prototype._move = function(I) {
      F(I, this);
    }, p.prototype.clone = function() {
      var I = new p(null);
      return this.copy(I), I;
    }, p.prototype._expand = function(I) {
      for (; this.length < I; )
        this.words[this.length++] = 0;
      return this;
    }, p.prototype._strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, p.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol < "u" && typeof Symbol.for == "function")
      try {
        p.prototype[Symbol.for("nodejs.util.inspect.custom")] = z;
      } catch {
        p.prototype.inspect = z;
      }
    else
      p.prototype.inspect = z;
    function z() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var j = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], ee = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], X = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    p.prototype.toString = function(I, M) {
      I = I || 10, M = M | 0 || 1;
      var $;
      if (I === 16 || I === "hex") {
        $ = "";
        for (var U = 0, Y = 0, L = 0; L < this.length; L++) {
          var T = this.words[L], B = ((T << U | Y) & 16777215).toString(16);
          Y = T >>> 24 - U & 16777215, U += 2, U >= 26 && (U -= 26, L--), Y !== 0 || L !== this.length - 1 ? $ = j[6 - B.length] + B + $ : $ = B + $;
        }
        for (Y !== 0 && ($ = Y.toString(16) + $); $.length % M !== 0; )
          $ = "0" + $;
        return this.negative !== 0 && ($ = "-" + $), $;
      }
      if (I === (I | 0) && I >= 2 && I <= 36) {
        var te = ee[I], pe = X[I];
        $ = "";
        var Ie = this.clone();
        for (Ie.negative = 0; !Ie.isZero(); ) {
          var $e = Ie.modrn(pe).toString(I);
          Ie = Ie.idivn(pe), Ie.isZero() ? $ = $e + $ : $ = j[te - $e.length] + $e + $;
        }
        for (this.isZero() && ($ = "0" + $); $.length % M !== 0; )
          $ = "0" + $;
        return this.negative !== 0 && ($ = "-" + $), $;
      }
      l(!1, "Base should be between 2 and 36");
    }, p.prototype.toNumber = function() {
      var I = this.words[0];
      return this.length === 2 ? I += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? I += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && l(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -I : I;
    }, p.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, _ && (p.prototype.toBuffer = function(I, M) {
      return this.toArrayLike(_, I, M);
    }), p.prototype.toArray = function(I, M) {
      return this.toArrayLike(Array, I, M);
    };
    var ae = function(I, M) {
      return I.allocUnsafe ? I.allocUnsafe(M) : new I(M);
    };
    p.prototype.toArrayLike = function(I, M, $) {
      this._strip();
      var U = this.byteLength(), Y = $ || Math.max(1, U);
      l(U <= Y, "byte array longer than desired length"), l(Y > 0, "Requested array length <= 0");
      var L = ae(I, Y), T = M === "le" ? "LE" : "BE";
      return this["_toArrayLike" + T](L, U), L;
    }, p.prototype._toArrayLikeLE = function(I, M) {
      for (var $ = 0, U = 0, Y = 0, L = 0; Y < this.length; Y++) {
        var T = this.words[Y] << L | U;
        I[$++] = T & 255, $ < I.length && (I[$++] = T >> 8 & 255), $ < I.length && (I[$++] = T >> 16 & 255), L === 6 ? ($ < I.length && (I[$++] = T >> 24 & 255), U = 0, L = 0) : (U = T >>> 24, L += 2);
      }
      if ($ < I.length)
        for (I[$++] = U; $ < I.length; )
          I[$++] = 0;
    }, p.prototype._toArrayLikeBE = function(I, M) {
      for (var $ = I.length - 1, U = 0, Y = 0, L = 0; Y < this.length; Y++) {
        var T = this.words[Y] << L | U;
        I[$--] = T & 255, $ >= 0 && (I[$--] = T >> 8 & 255), $ >= 0 && (I[$--] = T >> 16 & 255), L === 6 ? ($ >= 0 && (I[$--] = T >> 24 & 255), U = 0, L = 0) : (U = T >>> 24, L += 2);
      }
      if ($ >= 0)
        for (I[$--] = U; $ >= 0; )
          I[$--] = 0;
    }, Math.clz32 ? p.prototype._countBits = function(I) {
      return 32 - Math.clz32(I);
    } : p.prototype._countBits = function(I) {
      var M = I, $ = 0;
      return M >= 4096 && ($ += 13, M >>>= 13), M >= 64 && ($ += 7, M >>>= 7), M >= 8 && ($ += 4, M >>>= 4), M >= 2 && ($ += 2, M >>>= 2), $ + M;
    }, p.prototype._zeroBits = function(I) {
      if (I === 0)
        return 26;
      var M = I, $ = 0;
      return M & 8191 || ($ += 13, M >>>= 13), M & 127 || ($ += 7, M >>>= 7), M & 15 || ($ += 4, M >>>= 4), M & 3 || ($ += 2, M >>>= 2), M & 1 || $++, $;
    }, p.prototype.bitLength = function() {
      var I = this.words[this.length - 1], M = this._countBits(I);
      return (this.length - 1) * 26 + M;
    };
    function Q(E) {
      for (var I = new Array(E.bitLength()), M = 0; M < I.length; M++) {
        var $ = M / 26 | 0, U = M % 26;
        I[M] = E.words[$] >>> U & 1;
      }
      return I;
    }
    p.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var I = 0, M = 0; M < this.length; M++) {
        var $ = this._zeroBits(this.words[M]);
        if (I += $, $ !== 26)
          break;
      }
      return I;
    }, p.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, p.prototype.toTwos = function(I) {
      return this.negative !== 0 ? this.abs().inotn(I).iaddn(1) : this.clone();
    }, p.prototype.fromTwos = function(I) {
      return this.testn(I - 1) ? this.notn(I).iaddn(1).ineg() : this.clone();
    }, p.prototype.isNeg = function() {
      return this.negative !== 0;
    }, p.prototype.neg = function() {
      return this.clone().ineg();
    }, p.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, p.prototype.iuor = function(I) {
      for (; this.length < I.length; )
        this.words[this.length++] = 0;
      for (var M = 0; M < I.length; M++)
        this.words[M] = this.words[M] | I.words[M];
      return this._strip();
    }, p.prototype.ior = function(I) {
      return l((this.negative | I.negative) === 0), this.iuor(I);
    }, p.prototype.or = function(I) {
      return this.length > I.length ? this.clone().ior(I) : I.clone().ior(this);
    }, p.prototype.uor = function(I) {
      return this.length > I.length ? this.clone().iuor(I) : I.clone().iuor(this);
    }, p.prototype.iuand = function(I) {
      var M;
      this.length > I.length ? M = I : M = this;
      for (var $ = 0; $ < M.length; $++)
        this.words[$] = this.words[$] & I.words[$];
      return this.length = M.length, this._strip();
    }, p.prototype.iand = function(I) {
      return l((this.negative | I.negative) === 0), this.iuand(I);
    }, p.prototype.and = function(I) {
      return this.length > I.length ? this.clone().iand(I) : I.clone().iand(this);
    }, p.prototype.uand = function(I) {
      return this.length > I.length ? this.clone().iuand(I) : I.clone().iuand(this);
    }, p.prototype.iuxor = function(I) {
      var M, $;
      this.length > I.length ? (M = this, $ = I) : (M = I, $ = this);
      for (var U = 0; U < $.length; U++)
        this.words[U] = M.words[U] ^ $.words[U];
      if (this !== M)
        for (; U < M.length; U++)
          this.words[U] = M.words[U];
      return this.length = M.length, this._strip();
    }, p.prototype.ixor = function(I) {
      return l((this.negative | I.negative) === 0), this.iuxor(I);
    }, p.prototype.xor = function(I) {
      return this.length > I.length ? this.clone().ixor(I) : I.clone().ixor(this);
    }, p.prototype.uxor = function(I) {
      return this.length > I.length ? this.clone().iuxor(I) : I.clone().iuxor(this);
    }, p.prototype.inotn = function(I) {
      l(typeof I == "number" && I >= 0);
      var M = Math.ceil(I / 26) | 0, $ = I % 26;
      this._expand(M), $ > 0 && M--;
      for (var U = 0; U < M; U++)
        this.words[U] = ~this.words[U] & 67108863;
      return $ > 0 && (this.words[U] = ~this.words[U] & 67108863 >> 26 - $), this._strip();
    }, p.prototype.notn = function(I) {
      return this.clone().inotn(I);
    }, p.prototype.setn = function(I, M) {
      l(typeof I == "number" && I >= 0);
      var $ = I / 26 | 0, U = I % 26;
      return this._expand($ + 1), M ? this.words[$] = this.words[$] | 1 << U : this.words[$] = this.words[$] & ~(1 << U), this._strip();
    }, p.prototype.iadd = function(I) {
      var M;
      if (this.negative !== 0 && I.negative === 0)
        return this.negative = 0, M = this.isub(I), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && I.negative !== 0)
        return I.negative = 0, M = this.isub(I), I.negative = 1, M._normSign();
      var $, U;
      this.length > I.length ? ($ = this, U = I) : ($ = I, U = this);
      for (var Y = 0, L = 0; L < U.length; L++)
        M = ($.words[L] | 0) + (U.words[L] | 0) + Y, this.words[L] = M & 67108863, Y = M >>> 26;
      for (; Y !== 0 && L < $.length; L++)
        M = ($.words[L] | 0) + Y, this.words[L] = M & 67108863, Y = M >>> 26;
      if (this.length = $.length, Y !== 0)
        this.words[this.length] = Y, this.length++;
      else if ($ !== this)
        for (; L < $.length; L++)
          this.words[L] = $.words[L];
      return this;
    }, p.prototype.add = function(I) {
      var M;
      return I.negative !== 0 && this.negative === 0 ? (I.negative = 0, M = this.sub(I), I.negative ^= 1, M) : I.negative === 0 && this.negative !== 0 ? (this.negative = 0, M = I.sub(this), this.negative = 1, M) : this.length > I.length ? this.clone().iadd(I) : I.clone().iadd(this);
    }, p.prototype.isub = function(I) {
      if (I.negative !== 0) {
        I.negative = 0;
        var M = this.iadd(I);
        return I.negative = 1, M._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(I), this.negative = 1, this._normSign();
      var $ = this.cmp(I);
      if ($ === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var U, Y;
      $ > 0 ? (U = this, Y = I) : (U = I, Y = this);
      for (var L = 0, T = 0; T < Y.length; T++)
        M = (U.words[T] | 0) - (Y.words[T] | 0) + L, L = M >> 26, this.words[T] = M & 67108863;
      for (; L !== 0 && T < U.length; T++)
        M = (U.words[T] | 0) + L, L = M >> 26, this.words[T] = M & 67108863;
      if (L === 0 && T < U.length && U !== this)
        for (; T < U.length; T++)
          this.words[T] = U.words[T];
      return this.length = Math.max(this.length, T), U !== this && (this.negative = 1), this._strip();
    }, p.prototype.sub = function(I) {
      return this.clone().isub(I);
    };
    function ne(E, I, M) {
      M.negative = I.negative ^ E.negative;
      var $ = E.length + I.length | 0;
      M.length = $, $ = $ - 1 | 0;
      var U = E.words[0] | 0, Y = I.words[0] | 0, L = U * Y, T = L & 67108863, B = L / 67108864 | 0;
      M.words[0] = T;
      for (var te = 1; te < $; te++) {
        for (var pe = B >>> 26, Ie = B & 67108863, $e = Math.min(te, I.length - 1), ve = Math.max(0, te - E.length + 1); ve <= $e; ve++) {
          var he = te - ve | 0;
          U = E.words[he] | 0, Y = I.words[ve] | 0, L = U * Y + Ie, pe += L / 67108864 | 0, Ie = L & 67108863;
        }
        M.words[te] = Ie | 0, B = pe | 0;
      }
      return B !== 0 ? M.words[te] = B | 0 : M.length--, M._strip();
    }
    var Z = function(I, M, $) {
      var U = I.words, Y = M.words, L = $.words, T = 0, B, te, pe, Ie = U[0] | 0, $e = Ie & 8191, ve = Ie >>> 13, he = U[1] | 0, Oe = he & 8191, Ae = he >>> 13, Ue = U[2] | 0, oe = Ue & 8191, A = Ue >>> 13, re = U[3] | 0, le = re & 8191, Ne = re >>> 13, Pe = U[4] | 0, Fe = Pe & 8191, je = Pe >>> 13, qe = U[5] | 0, yt = qe & 8191, Xe = qe >>> 13, Ge = U[6] | 0, H = Ge & 8191, ye = Ge >>> 13, Ee = U[7] | 0, We = Ee & 8191, we = Ee >>> 13, V = U[8] | 0, _e = V & 8191, ue = V >>> 13, ce = U[9] | 0, me = ce & 8191, Ce = ce >>> 13, Be = Y[0] | 0, ze = Be & 8191, Je = Be >>> 13, Ze = Y[1] | 0, Ke = Ze & 8191, x = Ze >>> 13, se = Y[2] | 0, ge = se & 8191, xe = se >>> 13, Me = Y[3] | 0, Ye = Me & 8191, et = Me >>> 13, dt = Y[4] | 0, St = dt & 8191, tt = dt >>> 13, at = Y[5] | 0, kt = at & 8191, rt = at >>> 13, ut = Y[6] | 0, wt = ut & 8191, nt = ut >>> 13, it = Y[7] | 0, bt = it & 8191, ot = it >>> 13, ct = Y[8] | 0, Pt = ct & 8191, st = ct >>> 13, lt = Y[9] | 0, It = lt & 8191, Rt = lt >>> 13;
      $.negative = I.negative ^ M.negative, $.length = 19, B = Math.imul($e, ze), te = Math.imul($e, Je), te = te + Math.imul(ve, ze) | 0, pe = Math.imul(ve, Je);
      var Ve = (T + B | 0) + ((te & 8191) << 13) | 0;
      T = (pe + (te >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, B = Math.imul(Oe, ze), te = Math.imul(Oe, Je), te = te + Math.imul(Ae, ze) | 0, pe = Math.imul(Ae, Je), B = B + Math.imul($e, Ke) | 0, te = te + Math.imul($e, x) | 0, te = te + Math.imul(ve, Ke) | 0, pe = pe + Math.imul(ve, x) | 0;
      var He = (T + B | 0) + ((te & 8191) << 13) | 0;
      T = (pe + (te >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, B = Math.imul(oe, ze), te = Math.imul(oe, Je), te = te + Math.imul(A, ze) | 0, pe = Math.imul(A, Je), B = B + Math.imul(Oe, Ke) | 0, te = te + Math.imul(Oe, x) | 0, te = te + Math.imul(Ae, Ke) | 0, pe = pe + Math.imul(Ae, x) | 0, B = B + Math.imul($e, ge) | 0, te = te + Math.imul($e, xe) | 0, te = te + Math.imul(ve, ge) | 0, pe = pe + Math.imul(ve, xe) | 0;
      var Qe = (T + B | 0) + ((te & 8191) << 13) | 0;
      T = (pe + (te >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, B = Math.imul(le, ze), te = Math.imul(le, Je), te = te + Math.imul(Ne, ze) | 0, pe = Math.imul(Ne, Je), B = B + Math.imul(oe, Ke) | 0, te = te + Math.imul(oe, x) | 0, te = te + Math.imul(A, Ke) | 0, pe = pe + Math.imul(A, x) | 0, B = B + Math.imul(Oe, ge) | 0, te = te + Math.imul(Oe, xe) | 0, te = te + Math.imul(Ae, ge) | 0, pe = pe + Math.imul(Ae, xe) | 0, B = B + Math.imul($e, Ye) | 0, te = te + Math.imul($e, et) | 0, te = te + Math.imul(ve, Ye) | 0, pe = pe + Math.imul(ve, et) | 0;
      var pt = (T + B | 0) + ((te & 8191) << 13) | 0;
      T = (pe + (te >>> 13) | 0) + (pt >>> 26) | 0, pt &= 67108863, B = Math.imul(Fe, ze), te = Math.imul(Fe, Je), te = te + Math.imul(je, ze) | 0, pe = Math.imul(je, Je), B = B + Math.imul(le, Ke) | 0, te = te + Math.imul(le, x) | 0, te = te + Math.imul(Ne, Ke) | 0, pe = pe + Math.imul(Ne, x) | 0, B = B + Math.imul(oe, ge) | 0, te = te + Math.imul(oe, xe) | 0, te = te + Math.imul(A, ge) | 0, pe = pe + Math.imul(A, xe) | 0, B = B + Math.imul(Oe, Ye) | 0, te = te + Math.imul(Oe, et) | 0, te = te + Math.imul(Ae, Ye) | 0, pe = pe + Math.imul(Ae, et) | 0, B = B + Math.imul($e, St) | 0, te = te + Math.imul($e, tt) | 0, te = te + Math.imul(ve, St) | 0, pe = pe + Math.imul(ve, tt) | 0;
      var mt = (T + B | 0) + ((te & 8191) << 13) | 0;
      T = (pe + (te >>> 13) | 0) + (mt >>> 26) | 0, mt &= 67108863, B = Math.imul(yt, ze), te = Math.imul(yt, Je), te = te + Math.imul(Xe, ze) | 0, pe = Math.imul(Xe, Je), B = B + Math.imul(Fe, Ke) | 0, te = te + Math.imul(Fe, x) | 0, te = te + Math.imul(je, Ke) | 0, pe = pe + Math.imul(je, x) | 0, B = B + Math.imul(le, ge) | 0, te = te + Math.imul(le, xe) | 0, te = te + Math.imul(Ne, ge) | 0, pe = pe + Math.imul(Ne, xe) | 0, B = B + Math.imul(oe, Ye) | 0, te = te + Math.imul(oe, et) | 0, te = te + Math.imul(A, Ye) | 0, pe = pe + Math.imul(A, et) | 0, B = B + Math.imul(Oe, St) | 0, te = te + Math.imul(Oe, tt) | 0, te = te + Math.imul(Ae, St) | 0, pe = pe + Math.imul(Ae, tt) | 0, B = B + Math.imul($e, kt) | 0, te = te + Math.imul($e, rt) | 0, te = te + Math.imul(ve, kt) | 0, pe = pe + Math.imul(ve, rt) | 0;
      var vt = (T + B | 0) + ((te & 8191) << 13) | 0;
      T = (pe + (te >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, B = Math.imul(H, ze), te = Math.imul(H, Je), te = te + Math.imul(ye, ze) | 0, pe = Math.imul(ye, Je), B = B + Math.imul(yt, Ke) | 0, te = te + Math.imul(yt, x) | 0, te = te + Math.imul(Xe, Ke) | 0, pe = pe + Math.imul(Xe, x) | 0, B = B + Math.imul(Fe, ge) | 0, te = te + Math.imul(Fe, xe) | 0, te = te + Math.imul(je, ge) | 0, pe = pe + Math.imul(je, xe) | 0, B = B + Math.imul(le, Ye) | 0, te = te + Math.imul(le, et) | 0, te = te + Math.imul(Ne, Ye) | 0, pe = pe + Math.imul(Ne, et) | 0, B = B + Math.imul(oe, St) | 0, te = te + Math.imul(oe, tt) | 0, te = te + Math.imul(A, St) | 0, pe = pe + Math.imul(A, tt) | 0, B = B + Math.imul(Oe, kt) | 0, te = te + Math.imul(Oe, rt) | 0, te = te + Math.imul(Ae, kt) | 0, pe = pe + Math.imul(Ae, rt) | 0, B = B + Math.imul($e, wt) | 0, te = te + Math.imul($e, nt) | 0, te = te + Math.imul(ve, wt) | 0, pe = pe + Math.imul(ve, nt) | 0;
      var ht = (T + B | 0) + ((te & 8191) << 13) | 0;
      T = (pe + (te >>> 13) | 0) + (ht >>> 26) | 0, ht &= 67108863, B = Math.imul(We, ze), te = Math.imul(We, Je), te = te + Math.imul(we, ze) | 0, pe = Math.imul(we, Je), B = B + Math.imul(H, Ke) | 0, te = te + Math.imul(H, x) | 0, te = te + Math.imul(ye, Ke) | 0, pe = pe + Math.imul(ye, x) | 0, B = B + Math.imul(yt, ge) | 0, te = te + Math.imul(yt, xe) | 0, te = te + Math.imul(Xe, ge) | 0, pe = pe + Math.imul(Xe, xe) | 0, B = B + Math.imul(Fe, Ye) | 0, te = te + Math.imul(Fe, et) | 0, te = te + Math.imul(je, Ye) | 0, pe = pe + Math.imul(je, et) | 0, B = B + Math.imul(le, St) | 0, te = te + Math.imul(le, tt) | 0, te = te + Math.imul(Ne, St) | 0, pe = pe + Math.imul(Ne, tt) | 0, B = B + Math.imul(oe, kt) | 0, te = te + Math.imul(oe, rt) | 0, te = te + Math.imul(A, kt) | 0, pe = pe + Math.imul(A, rt) | 0, B = B + Math.imul(Oe, wt) | 0, te = te + Math.imul(Oe, nt) | 0, te = te + Math.imul(Ae, wt) | 0, pe = pe + Math.imul(Ae, nt) | 0, B = B + Math.imul($e, bt) | 0, te = te + Math.imul($e, ot) | 0, te = te + Math.imul(ve, bt) | 0, pe = pe + Math.imul(ve, ot) | 0;
      var Et = (T + B | 0) + ((te & 8191) << 13) | 0;
      T = (pe + (te >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, B = Math.imul(_e, ze), te = Math.imul(_e, Je), te = te + Math.imul(ue, ze) | 0, pe = Math.imul(ue, Je), B = B + Math.imul(We, Ke) | 0, te = te + Math.imul(We, x) | 0, te = te + Math.imul(we, Ke) | 0, pe = pe + Math.imul(we, x) | 0, B = B + Math.imul(H, ge) | 0, te = te + Math.imul(H, xe) | 0, te = te + Math.imul(ye, ge) | 0, pe = pe + Math.imul(ye, xe) | 0, B = B + Math.imul(yt, Ye) | 0, te = te + Math.imul(yt, et) | 0, te = te + Math.imul(Xe, Ye) | 0, pe = pe + Math.imul(Xe, et) | 0, B = B + Math.imul(Fe, St) | 0, te = te + Math.imul(Fe, tt) | 0, te = te + Math.imul(je, St) | 0, pe = pe + Math.imul(je, tt) | 0, B = B + Math.imul(le, kt) | 0, te = te + Math.imul(le, rt) | 0, te = te + Math.imul(Ne, kt) | 0, pe = pe + Math.imul(Ne, rt) | 0, B = B + Math.imul(oe, wt) | 0, te = te + Math.imul(oe, nt) | 0, te = te + Math.imul(A, wt) | 0, pe = pe + Math.imul(A, nt) | 0, B = B + Math.imul(Oe, bt) | 0, te = te + Math.imul(Oe, ot) | 0, te = te + Math.imul(Ae, bt) | 0, pe = pe + Math.imul(Ae, ot) | 0, B = B + Math.imul($e, Pt) | 0, te = te + Math.imul($e, st) | 0, te = te + Math.imul(ve, Pt) | 0, pe = pe + Math.imul(ve, st) | 0;
      var Tt = (T + B | 0) + ((te & 8191) << 13) | 0;
      T = (pe + (te >>> 13) | 0) + (Tt >>> 26) | 0, Tt &= 67108863, B = Math.imul(me, ze), te = Math.imul(me, Je), te = te + Math.imul(Ce, ze) | 0, pe = Math.imul(Ce, Je), B = B + Math.imul(_e, Ke) | 0, te = te + Math.imul(_e, x) | 0, te = te + Math.imul(ue, Ke) | 0, pe = pe + Math.imul(ue, x) | 0, B = B + Math.imul(We, ge) | 0, te = te + Math.imul(We, xe) | 0, te = te + Math.imul(we, ge) | 0, pe = pe + Math.imul(we, xe) | 0, B = B + Math.imul(H, Ye) | 0, te = te + Math.imul(H, et) | 0, te = te + Math.imul(ye, Ye) | 0, pe = pe + Math.imul(ye, et) | 0, B = B + Math.imul(yt, St) | 0, te = te + Math.imul(yt, tt) | 0, te = te + Math.imul(Xe, St) | 0, pe = pe + Math.imul(Xe, tt) | 0, B = B + Math.imul(Fe, kt) | 0, te = te + Math.imul(Fe, rt) | 0, te = te + Math.imul(je, kt) | 0, pe = pe + Math.imul(je, rt) | 0, B = B + Math.imul(le, wt) | 0, te = te + Math.imul(le, nt) | 0, te = te + Math.imul(Ne, wt) | 0, pe = pe + Math.imul(Ne, nt) | 0, B = B + Math.imul(oe, bt) | 0, te = te + Math.imul(oe, ot) | 0, te = te + Math.imul(A, bt) | 0, pe = pe + Math.imul(A, ot) | 0, B = B + Math.imul(Oe, Pt) | 0, te = te + Math.imul(Oe, st) | 0, te = te + Math.imul(Ae, Pt) | 0, pe = pe + Math.imul(Ae, st) | 0, B = B + Math.imul($e, It) | 0, te = te + Math.imul($e, Rt) | 0, te = te + Math.imul(ve, It) | 0, pe = pe + Math.imul(ve, Rt) | 0;
      var Ot = (T + B | 0) + ((te & 8191) << 13) | 0;
      T = (pe + (te >>> 13) | 0) + (Ot >>> 26) | 0, Ot &= 67108863, B = Math.imul(me, Ke), te = Math.imul(me, x), te = te + Math.imul(Ce, Ke) | 0, pe = Math.imul(Ce, x), B = B + Math.imul(_e, ge) | 0, te = te + Math.imul(_e, xe) | 0, te = te + Math.imul(ue, ge) | 0, pe = pe + Math.imul(ue, xe) | 0, B = B + Math.imul(We, Ye) | 0, te = te + Math.imul(We, et) | 0, te = te + Math.imul(we, Ye) | 0, pe = pe + Math.imul(we, et) | 0, B = B + Math.imul(H, St) | 0, te = te + Math.imul(H, tt) | 0, te = te + Math.imul(ye, St) | 0, pe = pe + Math.imul(ye, tt) | 0, B = B + Math.imul(yt, kt) | 0, te = te + Math.imul(yt, rt) | 0, te = te + Math.imul(Xe, kt) | 0, pe = pe + Math.imul(Xe, rt) | 0, B = B + Math.imul(Fe, wt) | 0, te = te + Math.imul(Fe, nt) | 0, te = te + Math.imul(je, wt) | 0, pe = pe + Math.imul(je, nt) | 0, B = B + Math.imul(le, bt) | 0, te = te + Math.imul(le, ot) | 0, te = te + Math.imul(Ne, bt) | 0, pe = pe + Math.imul(Ne, ot) | 0, B = B + Math.imul(oe, Pt) | 0, te = te + Math.imul(oe, st) | 0, te = te + Math.imul(A, Pt) | 0, pe = pe + Math.imul(A, st) | 0, B = B + Math.imul(Oe, It) | 0, te = te + Math.imul(Oe, Rt) | 0, te = te + Math.imul(Ae, It) | 0, pe = pe + Math.imul(Ae, Rt) | 0;
      var Nt = (T + B | 0) + ((te & 8191) << 13) | 0;
      T = (pe + (te >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, B = Math.imul(me, ge), te = Math.imul(me, xe), te = te + Math.imul(Ce, ge) | 0, pe = Math.imul(Ce, xe), B = B + Math.imul(_e, Ye) | 0, te = te + Math.imul(_e, et) | 0, te = te + Math.imul(ue, Ye) | 0, pe = pe + Math.imul(ue, et) | 0, B = B + Math.imul(We, St) | 0, te = te + Math.imul(We, tt) | 0, te = te + Math.imul(we, St) | 0, pe = pe + Math.imul(we, tt) | 0, B = B + Math.imul(H, kt) | 0, te = te + Math.imul(H, rt) | 0, te = te + Math.imul(ye, kt) | 0, pe = pe + Math.imul(ye, rt) | 0, B = B + Math.imul(yt, wt) | 0, te = te + Math.imul(yt, nt) | 0, te = te + Math.imul(Xe, wt) | 0, pe = pe + Math.imul(Xe, nt) | 0, B = B + Math.imul(Fe, bt) | 0, te = te + Math.imul(Fe, ot) | 0, te = te + Math.imul(je, bt) | 0, pe = pe + Math.imul(je, ot) | 0, B = B + Math.imul(le, Pt) | 0, te = te + Math.imul(le, st) | 0, te = te + Math.imul(Ne, Pt) | 0, pe = pe + Math.imul(Ne, st) | 0, B = B + Math.imul(oe, It) | 0, te = te + Math.imul(oe, Rt) | 0, te = te + Math.imul(A, It) | 0, pe = pe + Math.imul(A, Rt) | 0;
      var At = (T + B | 0) + ((te & 8191) << 13) | 0;
      T = (pe + (te >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, B = Math.imul(me, Ye), te = Math.imul(me, et), te = te + Math.imul(Ce, Ye) | 0, pe = Math.imul(Ce, et), B = B + Math.imul(_e, St) | 0, te = te + Math.imul(_e, tt) | 0, te = te + Math.imul(ue, St) | 0, pe = pe + Math.imul(ue, tt) | 0, B = B + Math.imul(We, kt) | 0, te = te + Math.imul(We, rt) | 0, te = te + Math.imul(we, kt) | 0, pe = pe + Math.imul(we, rt) | 0, B = B + Math.imul(H, wt) | 0, te = te + Math.imul(H, nt) | 0, te = te + Math.imul(ye, wt) | 0, pe = pe + Math.imul(ye, nt) | 0, B = B + Math.imul(yt, bt) | 0, te = te + Math.imul(yt, ot) | 0, te = te + Math.imul(Xe, bt) | 0, pe = pe + Math.imul(Xe, ot) | 0, B = B + Math.imul(Fe, Pt) | 0, te = te + Math.imul(Fe, st) | 0, te = te + Math.imul(je, Pt) | 0, pe = pe + Math.imul(je, st) | 0, B = B + Math.imul(le, It) | 0, te = te + Math.imul(le, Rt) | 0, te = te + Math.imul(Ne, It) | 0, pe = pe + Math.imul(Ne, Rt) | 0;
      var Mt = (T + B | 0) + ((te & 8191) << 13) | 0;
      T = (pe + (te >>> 13) | 0) + (Mt >>> 26) | 0, Mt &= 67108863, B = Math.imul(me, St), te = Math.imul(me, tt), te = te + Math.imul(Ce, St) | 0, pe = Math.imul(Ce, tt), B = B + Math.imul(_e, kt) | 0, te = te + Math.imul(_e, rt) | 0, te = te + Math.imul(ue, kt) | 0, pe = pe + Math.imul(ue, rt) | 0, B = B + Math.imul(We, wt) | 0, te = te + Math.imul(We, nt) | 0, te = te + Math.imul(we, wt) | 0, pe = pe + Math.imul(we, nt) | 0, B = B + Math.imul(H, bt) | 0, te = te + Math.imul(H, ot) | 0, te = te + Math.imul(ye, bt) | 0, pe = pe + Math.imul(ye, ot) | 0, B = B + Math.imul(yt, Pt) | 0, te = te + Math.imul(yt, st) | 0, te = te + Math.imul(Xe, Pt) | 0, pe = pe + Math.imul(Xe, st) | 0, B = B + Math.imul(Fe, It) | 0, te = te + Math.imul(Fe, Rt) | 0, te = te + Math.imul(je, It) | 0, pe = pe + Math.imul(je, Rt) | 0;
      var $t = (T + B | 0) + ((te & 8191) << 13) | 0;
      T = (pe + (te >>> 13) | 0) + ($t >>> 26) | 0, $t &= 67108863, B = Math.imul(me, kt), te = Math.imul(me, rt), te = te + Math.imul(Ce, kt) | 0, pe = Math.imul(Ce, rt), B = B + Math.imul(_e, wt) | 0, te = te + Math.imul(_e, nt) | 0, te = te + Math.imul(ue, wt) | 0, pe = pe + Math.imul(ue, nt) | 0, B = B + Math.imul(We, bt) | 0, te = te + Math.imul(We, ot) | 0, te = te + Math.imul(we, bt) | 0, pe = pe + Math.imul(we, ot) | 0, B = B + Math.imul(H, Pt) | 0, te = te + Math.imul(H, st) | 0, te = te + Math.imul(ye, Pt) | 0, pe = pe + Math.imul(ye, st) | 0, B = B + Math.imul(yt, It) | 0, te = te + Math.imul(yt, Rt) | 0, te = te + Math.imul(Xe, It) | 0, pe = pe + Math.imul(Xe, Rt) | 0;
      var Bt = (T + B | 0) + ((te & 8191) << 13) | 0;
      T = (pe + (te >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, B = Math.imul(me, wt), te = Math.imul(me, nt), te = te + Math.imul(Ce, wt) | 0, pe = Math.imul(Ce, nt), B = B + Math.imul(_e, bt) | 0, te = te + Math.imul(_e, ot) | 0, te = te + Math.imul(ue, bt) | 0, pe = pe + Math.imul(ue, ot) | 0, B = B + Math.imul(We, Pt) | 0, te = te + Math.imul(We, st) | 0, te = te + Math.imul(we, Pt) | 0, pe = pe + Math.imul(we, st) | 0, B = B + Math.imul(H, It) | 0, te = te + Math.imul(H, Rt) | 0, te = te + Math.imul(ye, It) | 0, pe = pe + Math.imul(ye, Rt) | 0;
      var Ut = (T + B | 0) + ((te & 8191) << 13) | 0;
      T = (pe + (te >>> 13) | 0) + (Ut >>> 26) | 0, Ut &= 67108863, B = Math.imul(me, bt), te = Math.imul(me, ot), te = te + Math.imul(Ce, bt) | 0, pe = Math.imul(Ce, ot), B = B + Math.imul(_e, Pt) | 0, te = te + Math.imul(_e, st) | 0, te = te + Math.imul(ue, Pt) | 0, pe = pe + Math.imul(ue, st) | 0, B = B + Math.imul(We, It) | 0, te = te + Math.imul(We, Rt) | 0, te = te + Math.imul(we, It) | 0, pe = pe + Math.imul(we, Rt) | 0;
      var xt = (T + B | 0) + ((te & 8191) << 13) | 0;
      T = (pe + (te >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, B = Math.imul(me, Pt), te = Math.imul(me, st), te = te + Math.imul(Ce, Pt) | 0, pe = Math.imul(Ce, st), B = B + Math.imul(_e, It) | 0, te = te + Math.imul(_e, Rt) | 0, te = te + Math.imul(ue, It) | 0, pe = pe + Math.imul(ue, Rt) | 0;
      var Jt = (T + B | 0) + ((te & 8191) << 13) | 0;
      T = (pe + (te >>> 13) | 0) + (Jt >>> 26) | 0, Jt &= 67108863, B = Math.imul(me, It), te = Math.imul(me, Rt), te = te + Math.imul(Ce, It) | 0, pe = Math.imul(Ce, Rt);
      var Gt = (T + B | 0) + ((te & 8191) << 13) | 0;
      return T = (pe + (te >>> 13) | 0) + (Gt >>> 26) | 0, Gt &= 67108863, L[0] = Ve, L[1] = He, L[2] = Qe, L[3] = pt, L[4] = mt, L[5] = vt, L[6] = ht, L[7] = Et, L[8] = Tt, L[9] = Ot, L[10] = Nt, L[11] = At, L[12] = Mt, L[13] = $t, L[14] = Bt, L[15] = Ut, L[16] = xt, L[17] = Jt, L[18] = Gt, T !== 0 && (L[19] = T, $.length++), $;
    };
    Math.imul || (Z = ne);
    function de(E, I, M) {
      M.negative = I.negative ^ E.negative, M.length = E.length + I.length;
      for (var $ = 0, U = 0, Y = 0; Y < M.length - 1; Y++) {
        var L = U;
        U = 0;
        for (var T = $ & 67108863, B = Math.min(Y, I.length - 1), te = Math.max(0, Y - E.length + 1); te <= B; te++) {
          var pe = Y - te, Ie = E.words[pe] | 0, $e = I.words[te] | 0, ve = Ie * $e, he = ve & 67108863;
          L = L + (ve / 67108864 | 0) | 0, he = he + T | 0, T = he & 67108863, L = L + (he >>> 26) | 0, U += L >>> 26, L &= 67108863;
        }
        M.words[Y] = T, $ = L, L = U;
      }
      return $ !== 0 ? M.words[Y] = $ : M.length--, M._strip();
    }
    function fe(E, I, M) {
      return de(E, I, M);
    }
    p.prototype.mulTo = function(I, M) {
      var $, U = this.length + I.length;
      return this.length === 10 && I.length === 10 ? $ = Z(this, I, M) : U < 63 ? $ = ne(this, I, M) : U < 1024 ? $ = de(this, I, M) : $ = fe(this, I, M), $;
    }, p.prototype.mul = function(I) {
      var M = new p(null);
      return M.words = new Array(this.length + I.length), this.mulTo(I, M);
    }, p.prototype.mulf = function(I) {
      var M = new p(null);
      return M.words = new Array(this.length + I.length), fe(this, I, M);
    }, p.prototype.imul = function(I) {
      return this.clone().mulTo(I, this);
    }, p.prototype.imuln = function(I) {
      var M = I < 0;
      M && (I = -I), l(typeof I == "number"), l(I < 67108864);
      for (var $ = 0, U = 0; U < this.length; U++) {
        var Y = (this.words[U] | 0) * I, L = (Y & 67108863) + ($ & 67108863);
        $ >>= 26, $ += Y / 67108864 | 0, $ += L >>> 26, this.words[U] = L & 67108863;
      }
      return $ !== 0 && (this.words[U] = $, this.length++), M ? this.ineg() : this;
    }, p.prototype.muln = function(I) {
      return this.clone().imuln(I);
    }, p.prototype.sqr = function() {
      return this.mul(this);
    }, p.prototype.isqr = function() {
      return this.imul(this.clone());
    }, p.prototype.pow = function(I) {
      var M = Q(I);
      if (M.length === 0)
        return new p(1);
      for (var $ = this, U = 0; U < M.length && M[U] === 0; U++, $ = $.sqr())
        ;
      if (++U < M.length)
        for (var Y = $.sqr(); U < M.length; U++, Y = Y.sqr())
          M[U] !== 0 && ($ = $.mul(Y));
      return $;
    }, p.prototype.iushln = function(I) {
      l(typeof I == "number" && I >= 0);
      var M = I % 26, $ = (I - M) / 26, U = 67108863 >>> 26 - M << 26 - M, Y;
      if (M !== 0) {
        var L = 0;
        for (Y = 0; Y < this.length; Y++) {
          var T = this.words[Y] & U, B = (this.words[Y] | 0) - T << M;
          this.words[Y] = B | L, L = T >>> 26 - M;
        }
        L && (this.words[Y] = L, this.length++);
      }
      if ($ !== 0) {
        for (Y = this.length - 1; Y >= 0; Y--)
          this.words[Y + $] = this.words[Y];
        for (Y = 0; Y < $; Y++)
          this.words[Y] = 0;
        this.length += $;
      }
      return this._strip();
    }, p.prototype.ishln = function(I) {
      return l(this.negative === 0), this.iushln(I);
    }, p.prototype.iushrn = function(I, M, $) {
      l(typeof I == "number" && I >= 0);
      var U;
      M ? U = (M - M % 26) / 26 : U = 0;
      var Y = I % 26, L = Math.min((I - Y) / 26, this.length), T = 67108863 ^ 67108863 >>> Y << Y, B = $;
      if (U -= L, U = Math.max(0, U), B) {
        for (var te = 0; te < L; te++)
          B.words[te] = this.words[te];
        B.length = L;
      }
      if (L !== 0)
        if (this.length > L)
          for (this.length -= L, te = 0; te < this.length; te++)
            this.words[te] = this.words[te + L];
        else
          this.words[0] = 0, this.length = 1;
      var pe = 0;
      for (te = this.length - 1; te >= 0 && (pe !== 0 || te >= U); te--) {
        var Ie = this.words[te] | 0;
        this.words[te] = pe << 26 - Y | Ie >>> Y, pe = Ie & T;
      }
      return B && pe !== 0 && (B.words[B.length++] = pe), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, p.prototype.ishrn = function(I, M, $) {
      return l(this.negative === 0), this.iushrn(I, M, $);
    }, p.prototype.shln = function(I) {
      return this.clone().ishln(I);
    }, p.prototype.ushln = function(I) {
      return this.clone().iushln(I);
    }, p.prototype.shrn = function(I) {
      return this.clone().ishrn(I);
    }, p.prototype.ushrn = function(I) {
      return this.clone().iushrn(I);
    }, p.prototype.testn = function(I) {
      l(typeof I == "number" && I >= 0);
      var M = I % 26, $ = (I - M) / 26, U = 1 << M;
      if (this.length <= $)
        return !1;
      var Y = this.words[$];
      return !!(Y & U);
    }, p.prototype.imaskn = function(I) {
      l(typeof I == "number" && I >= 0);
      var M = I % 26, $ = (I - M) / 26;
      if (l(this.negative === 0, "imaskn works only with positive numbers"), this.length <= $)
        return this;
      if (M !== 0 && $++, this.length = Math.min($, this.length), M !== 0) {
        var U = 67108863 ^ 67108863 >>> M << M;
        this.words[this.length - 1] &= U;
      }
      return this._strip();
    }, p.prototype.maskn = function(I) {
      return this.clone().imaskn(I);
    }, p.prototype.iaddn = function(I) {
      return l(typeof I == "number"), l(I < 67108864), I < 0 ? this.isubn(-I) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= I ? (this.words[0] = I - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(I), this.negative = 1, this) : this._iaddn(I);
    }, p.prototype._iaddn = function(I) {
      this.words[0] += I;
      for (var M = 0; M < this.length && this.words[M] >= 67108864; M++)
        this.words[M] -= 67108864, M === this.length - 1 ? this.words[M + 1] = 1 : this.words[M + 1]++;
      return this.length = Math.max(this.length, M + 1), this;
    }, p.prototype.isubn = function(I) {
      if (l(typeof I == "number"), l(I < 67108864), I < 0)
        return this.iaddn(-I);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(I), this.negative = 1, this;
      if (this.words[0] -= I, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var M = 0; M < this.length && this.words[M] < 0; M++)
          this.words[M] += 67108864, this.words[M + 1] -= 1;
      return this._strip();
    }, p.prototype.addn = function(I) {
      return this.clone().iaddn(I);
    }, p.prototype.subn = function(I) {
      return this.clone().isubn(I);
    }, p.prototype.iabs = function() {
      return this.negative = 0, this;
    }, p.prototype.abs = function() {
      return this.clone().iabs();
    }, p.prototype._ishlnsubmul = function(I, M, $) {
      var U = I.length + $, Y;
      this._expand(U);
      var L, T = 0;
      for (Y = 0; Y < I.length; Y++) {
        L = (this.words[Y + $] | 0) + T;
        var B = (I.words[Y] | 0) * M;
        L -= B & 67108863, T = (L >> 26) - (B / 67108864 | 0), this.words[Y + $] = L & 67108863;
      }
      for (; Y < this.length - $; Y++)
        L = (this.words[Y + $] | 0) + T, T = L >> 26, this.words[Y + $] = L & 67108863;
      if (T === 0)
        return this._strip();
      for (l(T === -1), T = 0, Y = 0; Y < this.length; Y++)
        L = -(this.words[Y] | 0) + T, T = L >> 26, this.words[Y] = L & 67108863;
      return this.negative = 1, this._strip();
    }, p.prototype._wordDiv = function(I, M) {
      var $ = this.length - I.length, U = this.clone(), Y = I, L = Y.words[Y.length - 1] | 0, T = this._countBits(L);
      $ = 26 - T, $ !== 0 && (Y = Y.ushln($), U.iushln($), L = Y.words[Y.length - 1] | 0);
      var B = U.length - Y.length, te;
      if (M !== "mod") {
        te = new p(null), te.length = B + 1, te.words = new Array(te.length);
        for (var pe = 0; pe < te.length; pe++)
          te.words[pe] = 0;
      }
      var Ie = U.clone()._ishlnsubmul(Y, 1, B);
      Ie.negative === 0 && (U = Ie, te && (te.words[B] = 1));
      for (var $e = B - 1; $e >= 0; $e--) {
        var ve = (U.words[Y.length + $e] | 0) * 67108864 + (U.words[Y.length + $e - 1] | 0);
        for (ve = Math.min(ve / L | 0, 67108863), U._ishlnsubmul(Y, ve, $e); U.negative !== 0; )
          ve--, U.negative = 0, U._ishlnsubmul(Y, 1, $e), U.isZero() || (U.negative ^= 1);
        te && (te.words[$e] = ve);
      }
      return te && te._strip(), U._strip(), M !== "div" && $ !== 0 && U.iushrn($), {
        div: te || null,
        mod: U
      };
    }, p.prototype.divmod = function(I, M, $) {
      if (l(!I.isZero()), this.isZero())
        return {
          div: new p(0),
          mod: new p(0)
        };
      var U, Y, L;
      return this.negative !== 0 && I.negative === 0 ? (L = this.neg().divmod(I, M), M !== "mod" && (U = L.div.neg()), M !== "div" && (Y = L.mod.neg(), $ && Y.negative !== 0 && Y.iadd(I)), {
        div: U,
        mod: Y
      }) : this.negative === 0 && I.negative !== 0 ? (L = this.divmod(I.neg(), M), M !== "mod" && (U = L.div.neg()), {
        div: U,
        mod: L.mod
      }) : this.negative & I.negative ? (L = this.neg().divmod(I.neg(), M), M !== "div" && (Y = L.mod.neg(), $ && Y.negative !== 0 && Y.isub(I)), {
        div: L.div,
        mod: Y
      }) : I.length > this.length || this.cmp(I) < 0 ? {
        div: new p(0),
        mod: this
      } : I.length === 1 ? M === "div" ? {
        div: this.divn(I.words[0]),
        mod: null
      } : M === "mod" ? {
        div: null,
        mod: new p(this.modrn(I.words[0]))
      } : {
        div: this.divn(I.words[0]),
        mod: new p(this.modrn(I.words[0]))
      } : this._wordDiv(I, M);
    }, p.prototype.div = function(I) {
      return this.divmod(I, "div", !1).div;
    }, p.prototype.mod = function(I) {
      return this.divmod(I, "mod", !1).mod;
    }, p.prototype.umod = function(I) {
      return this.divmod(I, "mod", !0).mod;
    }, p.prototype.divRound = function(I) {
      var M = this.divmod(I);
      if (M.mod.isZero())
        return M.div;
      var $ = M.div.negative !== 0 ? M.mod.isub(I) : M.mod, U = I.ushrn(1), Y = I.andln(1), L = $.cmp(U);
      return L < 0 || Y === 1 && L === 0 ? M.div : M.div.negative !== 0 ? M.div.isubn(1) : M.div.iaddn(1);
    }, p.prototype.modrn = function(I) {
      var M = I < 0;
      M && (I = -I), l(I <= 67108863);
      for (var $ = (1 << 26) % I, U = 0, Y = this.length - 1; Y >= 0; Y--)
        U = ($ * U + (this.words[Y] | 0)) % I;
      return M ? -U : U;
    }, p.prototype.modn = function(I) {
      return this.modrn(I);
    }, p.prototype.idivn = function(I) {
      var M = I < 0;
      M && (I = -I), l(I <= 67108863);
      for (var $ = 0, U = this.length - 1; U >= 0; U--) {
        var Y = (this.words[U] | 0) + $ * 67108864;
        this.words[U] = Y / I | 0, $ = Y % I;
      }
      return this._strip(), M ? this.ineg() : this;
    }, p.prototype.divn = function(I) {
      return this.clone().idivn(I);
    }, p.prototype.egcd = function(I) {
      l(I.negative === 0), l(!I.isZero());
      var M = this, $ = I.clone();
      M.negative !== 0 ? M = M.umod(I) : M = M.clone();
      for (var U = new p(1), Y = new p(0), L = new p(0), T = new p(1), B = 0; M.isEven() && $.isEven(); )
        M.iushrn(1), $.iushrn(1), ++B;
      for (var te = $.clone(), pe = M.clone(); !M.isZero(); ) {
        for (var Ie = 0, $e = 1; !(M.words[0] & $e) && Ie < 26; ++Ie, $e <<= 1)
          ;
        if (Ie > 0)
          for (M.iushrn(Ie); Ie-- > 0; )
            (U.isOdd() || Y.isOdd()) && (U.iadd(te), Y.isub(pe)), U.iushrn(1), Y.iushrn(1);
        for (var ve = 0, he = 1; !($.words[0] & he) && ve < 26; ++ve, he <<= 1)
          ;
        if (ve > 0)
          for ($.iushrn(ve); ve-- > 0; )
            (L.isOdd() || T.isOdd()) && (L.iadd(te), T.isub(pe)), L.iushrn(1), T.iushrn(1);
        M.cmp($) >= 0 ? (M.isub($), U.isub(L), Y.isub(T)) : ($.isub(M), L.isub(U), T.isub(Y));
      }
      return {
        a: L,
        b: T,
        gcd: $.iushln(B)
      };
    }, p.prototype._invmp = function(I) {
      l(I.negative === 0), l(!I.isZero());
      var M = this, $ = I.clone();
      M.negative !== 0 ? M = M.umod(I) : M = M.clone();
      for (var U = new p(1), Y = new p(0), L = $.clone(); M.cmpn(1) > 0 && $.cmpn(1) > 0; ) {
        for (var T = 0, B = 1; !(M.words[0] & B) && T < 26; ++T, B <<= 1)
          ;
        if (T > 0)
          for (M.iushrn(T); T-- > 0; )
            U.isOdd() && U.iadd(L), U.iushrn(1);
        for (var te = 0, pe = 1; !($.words[0] & pe) && te < 26; ++te, pe <<= 1)
          ;
        if (te > 0)
          for ($.iushrn(te); te-- > 0; )
            Y.isOdd() && Y.iadd(L), Y.iushrn(1);
        M.cmp($) >= 0 ? (M.isub($), U.isub(Y)) : ($.isub(M), Y.isub(U));
      }
      var Ie;
      return M.cmpn(1) === 0 ? Ie = U : Ie = Y, Ie.cmpn(0) < 0 && Ie.iadd(I), Ie;
    }, p.prototype.gcd = function(I) {
      if (this.isZero())
        return I.abs();
      if (I.isZero())
        return this.abs();
      var M = this.clone(), $ = I.clone();
      M.negative = 0, $.negative = 0;
      for (var U = 0; M.isEven() && $.isEven(); U++)
        M.iushrn(1), $.iushrn(1);
      do {
        for (; M.isEven(); )
          M.iushrn(1);
        for (; $.isEven(); )
          $.iushrn(1);
        var Y = M.cmp($);
        if (Y < 0) {
          var L = M;
          M = $, $ = L;
        } else if (Y === 0 || $.cmpn(1) === 0)
          break;
        M.isub($);
      } while (!0);
      return $.iushln(U);
    }, p.prototype.invm = function(I) {
      return this.egcd(I).a.umod(I);
    }, p.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, p.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, p.prototype.andln = function(I) {
      return this.words[0] & I;
    }, p.prototype.bincn = function(I) {
      l(typeof I == "number");
      var M = I % 26, $ = (I - M) / 26, U = 1 << M;
      if (this.length <= $)
        return this._expand($ + 1), this.words[$] |= U, this;
      for (var Y = U, L = $; Y !== 0 && L < this.length; L++) {
        var T = this.words[L] | 0;
        T += Y, Y = T >>> 26, T &= 67108863, this.words[L] = T;
      }
      return Y !== 0 && (this.words[L] = Y, this.length++), this;
    }, p.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, p.prototype.cmpn = function(I) {
      var M = I < 0;
      if (this.negative !== 0 && !M)
        return -1;
      if (this.negative === 0 && M)
        return 1;
      this._strip();
      var $;
      if (this.length > 1)
        $ = 1;
      else {
        M && (I = -I), l(I <= 67108863, "Number is too big");
        var U = this.words[0] | 0;
        $ = U === I ? 0 : U < I ? -1 : 1;
      }
      return this.negative !== 0 ? -$ | 0 : $;
    }, p.prototype.cmp = function(I) {
      if (this.negative !== 0 && I.negative === 0)
        return -1;
      if (this.negative === 0 && I.negative !== 0)
        return 1;
      var M = this.ucmp(I);
      return this.negative !== 0 ? -M | 0 : M;
    }, p.prototype.ucmp = function(I) {
      if (this.length > I.length)
        return 1;
      if (this.length < I.length)
        return -1;
      for (var M = 0, $ = this.length - 1; $ >= 0; $--) {
        var U = this.words[$] | 0, Y = I.words[$] | 0;
        if (U !== Y) {
          U < Y ? M = -1 : U > Y && (M = 1);
          break;
        }
      }
      return M;
    }, p.prototype.gtn = function(I) {
      return this.cmpn(I) === 1;
    }, p.prototype.gt = function(I) {
      return this.cmp(I) === 1;
    }, p.prototype.gten = function(I) {
      return this.cmpn(I) >= 0;
    }, p.prototype.gte = function(I) {
      return this.cmp(I) >= 0;
    }, p.prototype.ltn = function(I) {
      return this.cmpn(I) === -1;
    }, p.prototype.lt = function(I) {
      return this.cmp(I) === -1;
    }, p.prototype.lten = function(I) {
      return this.cmpn(I) <= 0;
    }, p.prototype.lte = function(I) {
      return this.cmp(I) <= 0;
    }, p.prototype.eqn = function(I) {
      return this.cmpn(I) === 0;
    }, p.prototype.eq = function(I) {
      return this.cmp(I) === 0;
    }, p.red = function(I) {
      return new C(I);
    }, p.prototype.toRed = function(I) {
      return l(!this.red, "Already a number in reduction context"), l(this.negative === 0, "red works only with positives"), I.convertTo(this)._forceRed(I);
    }, p.prototype.fromRed = function() {
      return l(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, p.prototype._forceRed = function(I) {
      return this.red = I, this;
    }, p.prototype.forceRed = function(I) {
      return l(!this.red, "Already a number in reduction context"), this._forceRed(I);
    }, p.prototype.redAdd = function(I) {
      return l(this.red, "redAdd works only with red numbers"), this.red.add(this, I);
    }, p.prototype.redIAdd = function(I) {
      return l(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, I);
    }, p.prototype.redSub = function(I) {
      return l(this.red, "redSub works only with red numbers"), this.red.sub(this, I);
    }, p.prototype.redISub = function(I) {
      return l(this.red, "redISub works only with red numbers"), this.red.isub(this, I);
    }, p.prototype.redShl = function(I) {
      return l(this.red, "redShl works only with red numbers"), this.red.shl(this, I);
    }, p.prototype.redMul = function(I) {
      return l(this.red, "redMul works only with red numbers"), this.red._verify2(this, I), this.red.mul(this, I);
    }, p.prototype.redIMul = function(I) {
      return l(this.red, "redMul works only with red numbers"), this.red._verify2(this, I), this.red.imul(this, I);
    }, p.prototype.redSqr = function() {
      return l(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, p.prototype.redISqr = function() {
      return l(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, p.prototype.redSqrt = function() {
      return l(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, p.prototype.redInvm = function() {
      return l(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, p.prototype.redNeg = function() {
      return l(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, p.prototype.redPow = function(I) {
      return l(this.red && !I.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, I);
    };
    var Te = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function Re(E, I) {
      this.name = E, this.p = new p(I, 16), this.n = this.p.bitLength(), this.k = new p(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    Re.prototype._tmp = function() {
      var I = new p(null);
      return I.words = new Array(Math.ceil(this.n / 13)), I;
    }, Re.prototype.ireduce = function(I) {
      var M = I, $;
      do
        this.split(M, this.tmp), M = this.imulK(M), M = M.iadd(this.tmp), $ = M.bitLength();
      while ($ > this.n);
      var U = $ < this.n ? -1 : M.ucmp(this.p);
      return U === 0 ? (M.words[0] = 0, M.length = 1) : U > 0 ? M.isub(this.p) : M.strip !== void 0 ? M.strip() : M._strip(), M;
    }, Re.prototype.split = function(I, M) {
      I.iushrn(this.n, 0, M);
    }, Re.prototype.imulK = function(I) {
      return I.imul(this.k);
    };
    function Le() {
      Re.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    v(Le, Re), Le.prototype.split = function(I, M) {
      for (var $ = 4194303, U = Math.min(I.length, 9), Y = 0; Y < U; Y++)
        M.words[Y] = I.words[Y];
      if (M.length = U, I.length <= 9) {
        I.words[0] = 0, I.length = 1;
        return;
      }
      var L = I.words[9];
      for (M.words[M.length++] = L & $, Y = 10; Y < I.length; Y++) {
        var T = I.words[Y] | 0;
        I.words[Y - 10] = (T & $) << 4 | L >>> 22, L = T;
      }
      L >>>= 22, I.words[Y - 10] = L, L === 0 && I.length > 10 ? I.length -= 10 : I.length -= 9;
    }, Le.prototype.imulK = function(I) {
      I.words[I.length] = 0, I.words[I.length + 1] = 0, I.length += 2;
      for (var M = 0, $ = 0; $ < I.length; $++) {
        var U = I.words[$] | 0;
        M += U * 977, I.words[$] = M & 67108863, M = U * 64 + (M / 67108864 | 0);
      }
      return I.words[I.length - 1] === 0 && (I.length--, I.words[I.length - 1] === 0 && I.length--), I;
    };
    function be() {
      Re.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    v(be, Re);
    function q() {
      Re.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    v(q, Re);
    function J() {
      Re.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    v(J, Re), J.prototype.imulK = function(I) {
      for (var M = 0, $ = 0; $ < I.length; $++) {
        var U = (I.words[$] | 0) * 19 + M, Y = U & 67108863;
        U >>>= 26, I.words[$] = Y, M = U;
      }
      return M !== 0 && (I.words[I.length++] = M), I;
    }, p._prime = function(I) {
      if (Te[I])
        return Te[I];
      var M;
      if (I === "k256")
        M = new Le();
      else if (I === "p224")
        M = new be();
      else if (I === "p192")
        M = new q();
      else if (I === "p25519")
        M = new J();
      else
        throw new Error("Unknown prime " + I);
      return Te[I] = M, M;
    };
    function C(E) {
      if (typeof E == "string") {
        var I = p._prime(E);
        this.m = I.p, this.prime = I;
      } else
        l(E.gtn(1), "modulus must be greater than 1"), this.m = E, this.prime = null;
    }
    C.prototype._verify1 = function(I) {
      l(I.negative === 0, "red works only with positives"), l(I.red, "red works only with red numbers");
    }, C.prototype._verify2 = function(I, M) {
      l((I.negative | M.negative) === 0, "red works only with positives"), l(
        I.red && I.red === M.red,
        "red works only with red numbers"
      );
    }, C.prototype.imod = function(I) {
      return this.prime ? this.prime.ireduce(I)._forceRed(this) : (F(I, I.umod(this.m)._forceRed(this)), I);
    }, C.prototype.neg = function(I) {
      return I.isZero() ? I.clone() : this.m.sub(I)._forceRed(this);
    }, C.prototype.add = function(I, M) {
      this._verify2(I, M);
      var $ = I.add(M);
      return $.cmp(this.m) >= 0 && $.isub(this.m), $._forceRed(this);
    }, C.prototype.iadd = function(I, M) {
      this._verify2(I, M);
      var $ = I.iadd(M);
      return $.cmp(this.m) >= 0 && $.isub(this.m), $;
    }, C.prototype.sub = function(I, M) {
      this._verify2(I, M);
      var $ = I.sub(M);
      return $.cmpn(0) < 0 && $.iadd(this.m), $._forceRed(this);
    }, C.prototype.isub = function(I, M) {
      this._verify2(I, M);
      var $ = I.isub(M);
      return $.cmpn(0) < 0 && $.iadd(this.m), $;
    }, C.prototype.shl = function(I, M) {
      return this._verify1(I), this.imod(I.ushln(M));
    }, C.prototype.imul = function(I, M) {
      return this._verify2(I, M), this.imod(I.imul(M));
    }, C.prototype.mul = function(I, M) {
      return this._verify2(I, M), this.imod(I.mul(M));
    }, C.prototype.isqr = function(I) {
      return this.imul(I, I.clone());
    }, C.prototype.sqr = function(I) {
      return this.mul(I, I);
    }, C.prototype.sqrt = function(I) {
      if (I.isZero())
        return I.clone();
      var M = this.m.andln(3);
      if (l(M % 2 === 1), M === 3) {
        var $ = this.m.add(new p(1)).iushrn(2);
        return this.pow(I, $);
      }
      for (var U = this.m.subn(1), Y = 0; !U.isZero() && U.andln(1) === 0; )
        Y++, U.iushrn(1);
      l(!U.isZero());
      var L = new p(1).toRed(this), T = L.redNeg(), B = this.m.subn(1).iushrn(1), te = this.m.bitLength();
      for (te = new p(2 * te * te).toRed(this); this.pow(te, B).cmp(T) !== 0; )
        te.redIAdd(T);
      for (var pe = this.pow(te, U), Ie = this.pow(I, U.addn(1).iushrn(1)), $e = this.pow(I, U), ve = Y; $e.cmp(L) !== 0; ) {
        for (var he = $e, Oe = 0; he.cmp(L) !== 0; Oe++)
          he = he.redSqr();
        l(Oe < ve);
        var Ae = this.pow(pe, new p(1).iushln(ve - Oe - 1));
        Ie = Ie.redMul(Ae), pe = Ae.redSqr(), $e = $e.redMul(pe), ve = Oe;
      }
      return Ie;
    }, C.prototype.invm = function(I) {
      var M = I._invmp(this.m);
      return M.negative !== 0 ? (M.negative = 0, this.imod(M).redNeg()) : this.imod(M);
    }, C.prototype.pow = function(I, M) {
      if (M.isZero())
        return new p(1).toRed(this);
      if (M.cmpn(1) === 0)
        return I.clone();
      var $ = 4, U = new Array(1 << $);
      U[0] = new p(1).toRed(this), U[1] = I;
      for (var Y = 2; Y < U.length; Y++)
        U[Y] = this.mul(U[Y - 1], I);
      var L = U[0], T = 0, B = 0, te = M.bitLength() % 26;
      for (te === 0 && (te = 26), Y = M.length - 1; Y >= 0; Y--) {
        for (var pe = M.words[Y], Ie = te - 1; Ie >= 0; Ie--) {
          var $e = pe >> Ie & 1;
          if (L !== U[0] && (L = this.sqr(L)), $e === 0 && T === 0) {
            B = 0;
            continue;
          }
          T <<= 1, T |= $e, B++, !(B !== $ && (Y !== 0 || Ie !== 0)) && (L = this.mul(L, U[T]), B = 0, T = 0);
        }
        te = 26;
      }
      return L;
    }, C.prototype.convertTo = function(I) {
      var M = I.umod(this.m);
      return M === I ? M.clone() : M;
    }, C.prototype.convertFrom = function(I) {
      var M = I.clone();
      return M.red = null, M;
    }, p.mont = function(I) {
      return new S(I);
    };
    function S(E) {
      C.call(this, E), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new p(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    v(S, C), S.prototype.convertTo = function(I) {
      return this.imod(I.ushln(this.shift));
    }, S.prototype.convertFrom = function(I) {
      var M = this.imod(I.mul(this.rinv));
      return M.red = null, M;
    }, S.prototype.imul = function(I, M) {
      if (I.isZero() || M.isZero())
        return I.words[0] = 0, I.length = 1, I;
      var $ = I.imul(M), U = $.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), Y = $.isub(U).iushrn(this.shift), L = Y;
      return Y.cmp(this.m) >= 0 ? L = Y.isub(this.m) : Y.cmpn(0) < 0 && (L = Y.iadd(this.m)), L._forceRed(this);
    }, S.prototype.mul = function(I, M) {
      if (I.isZero() || M.isZero())
        return new p(0)._forceRed(this);
      var $ = I.mul(M), U = $.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), Y = $.isub(U).iushrn(this.shift), L = Y;
      return Y.cmp(this.m) >= 0 ? L = Y.isub(this.m) : Y.cmpn(0) < 0 && (L = Y.iadd(this.m)), L._forceRed(this);
    }, S.prototype.invm = function(I) {
      var M = this.imod(I._invmp(this.m).mul(this.r2));
      return M._forceRed(this);
    };
  })(a, commonjsGlobal$1);
})(bn$4);
var bnExports$4 = bn$4.exports, BN$a = bnExports$4, randomBytes$1 = browserExports;
function blind(a) {
  var u = getr(a), c = u.toRed(BN$a.mont(a.modulus)).redPow(new BN$a(a.publicExponent)).fromRed();
  return { blinder: c, unblinder: u.invm(a.modulus) };
}
function getr(a) {
  var u = a.modulus.byteLength(), c;
  do
    c = new BN$a(randomBytes$1(u));
  while (c.cmp(a.modulus) >= 0 || !c.umod(a.prime1) || !c.umod(a.prime2));
  return c;
}
function crt$2(a, u) {
  var c = blind(u), l = u.modulus.byteLength(), v = new BN$a(a).mul(c.blinder).umod(u.modulus), p = v.toRed(BN$a.mont(u.prime1)), _ = v.toRed(BN$a.mont(u.prime2)), k = u.coefficient, O = u.prime1, D = u.prime2, F = p.redPow(u.exponent1).fromRed(), z = _.redPow(u.exponent2).fromRed(), j = F.isub(z).imul(k).umod(O).imul(D);
  return z.iadd(j).imul(c.unblinder).umod(u.modulus).toArrayLike(Buffer$O, "be", l);
}
crt$2.getr = getr;
var browserifyRsa = crt$2, elliptic = {};
const name$1 = "elliptic", version$1 = "6.5.4", description$1 = "EC cryptography", main$1 = "lib/elliptic.js", files = [
  "lib"
], scripts$1 = {
  lint: "eslint lib test",
  "lint:fix": "npm run lint -- --fix",
  unit: "istanbul test _mocha --reporter=spec test/index.js",
  test: "npm run lint && npm run unit",
  version: "grunt dist && git add dist/"
}, repository$1 = {
  type: "git",
  url: "git@github.com:indutny/elliptic"
}, keywords$1 = [
  "EC",
  "Elliptic",
  "curve",
  "Cryptography"
], author$1 = "Fedor Indutny <fedor@indutny.com>", license$1 = "MIT", bugs$1 = {
  url: "https://github.com/indutny/elliptic/issues"
}, homepage$1 = "https://github.com/indutny/elliptic", devDependencies$1 = {
  brfs: "^2.0.2",
  coveralls: "^3.1.0",
  eslint: "^7.6.0",
  grunt: "^1.2.1",
  "grunt-browserify": "^5.3.0",
  "grunt-cli": "^1.3.2",
  "grunt-contrib-connect": "^3.0.0",
  "grunt-contrib-copy": "^1.0.0",
  "grunt-contrib-uglify": "^5.0.0",
  "grunt-mocha-istanbul": "^5.0.2",
  "grunt-saucelabs": "^9.0.1",
  istanbul: "^0.4.5",
  mocha: "^8.0.1"
}, dependencies$1 = {
  "bn.js": "^4.11.9",
  brorand: "^1.1.0",
  "hash.js": "^1.0.0",
  "hmac-drbg": "^1.0.1",
  inherits: "^2.0.4",
  "minimalistic-assert": "^1.0.1",
  "minimalistic-crypto-utils": "^1.0.1"
}, require$$0$1 = {
  name: name$1,
  version: version$1,
  description: description$1,
  main: main$1,
  files,
  scripts: scripts$1,
  repository: repository$1,
  keywords: keywords$1,
  author: author$1,
  license: license$1,
  bugs: bugs$1,
  homepage: homepage$1,
  devDependencies: devDependencies$1,
  dependencies: dependencies$1
};
var utils$v = {}, bn$3 = { exports: {} };
bn$3.exports;
(function(a) {
  (function(u, c) {
    function l(C, S) {
      if (!C)
        throw new Error(S || "Assertion failed");
    }
    function v(C, S) {
      C.super_ = S;
      var E = function() {
      };
      E.prototype = S.prototype, C.prototype = new E(), C.prototype.constructor = C;
    }
    function p(C, S, E) {
      if (p.isBN(C))
        return C;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, C !== null && ((S === "le" || S === "be") && (E = S, S = 10), this._init(C || 0, S || 10, E || "be"));
    }
    typeof u == "object" ? u.exports = p : c.BN = p, p.BN = p, p.wordSize = 26;
    var _;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? _ = window.Buffer : _ = require$$0$2.Buffer;
    } catch {
    }
    p.isBN = function(S) {
      return S instanceof p ? !0 : S !== null && typeof S == "object" && S.constructor.wordSize === p.wordSize && Array.isArray(S.words);
    }, p.max = function(S, E) {
      return S.cmp(E) > 0 ? S : E;
    }, p.min = function(S, E) {
      return S.cmp(E) < 0 ? S : E;
    }, p.prototype._init = function(S, E, I) {
      if (typeof S == "number")
        return this._initNumber(S, E, I);
      if (typeof S == "object")
        return this._initArray(S, E, I);
      E === "hex" && (E = 16), l(E === (E | 0) && E >= 2 && E <= 36), S = S.toString().replace(/\s+/g, "");
      var M = 0;
      S[0] === "-" && (M++, this.negative = 1), M < S.length && (E === 16 ? this._parseHex(S, M, I) : (this._parseBase(S, E, M), I === "le" && this._initArray(this.toArray(), E, I)));
    }, p.prototype._initNumber = function(S, E, I) {
      S < 0 && (this.negative = 1, S = -S), S < 67108864 ? (this.words = [S & 67108863], this.length = 1) : S < 4503599627370496 ? (this.words = [
        S & 67108863,
        S / 67108864 & 67108863
      ], this.length = 2) : (l(S < 9007199254740992), this.words = [
        S & 67108863,
        S / 67108864 & 67108863,
        1
      ], this.length = 3), I === "le" && this._initArray(this.toArray(), E, I);
    }, p.prototype._initArray = function(S, E, I) {
      if (l(typeof S.length == "number"), S.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(S.length / 3), this.words = new Array(this.length);
      for (var M = 0; M < this.length; M++)
        this.words[M] = 0;
      var $, U, Y = 0;
      if (I === "be")
        for (M = S.length - 1, $ = 0; M >= 0; M -= 3)
          U = S[M] | S[M - 1] << 8 | S[M - 2] << 16, this.words[$] |= U << Y & 67108863, this.words[$ + 1] = U >>> 26 - Y & 67108863, Y += 24, Y >= 26 && (Y -= 26, $++);
      else if (I === "le")
        for (M = 0, $ = 0; M < S.length; M += 3)
          U = S[M] | S[M + 1] << 8 | S[M + 2] << 16, this.words[$] |= U << Y & 67108863, this.words[$ + 1] = U >>> 26 - Y & 67108863, Y += 24, Y >= 26 && (Y -= 26, $++);
      return this.strip();
    };
    function k(C, S) {
      var E = C.charCodeAt(S);
      return E >= 65 && E <= 70 ? E - 55 : E >= 97 && E <= 102 ? E - 87 : E - 48 & 15;
    }
    function O(C, S, E) {
      var I = k(C, E);
      return E - 1 >= S && (I |= k(C, E - 1) << 4), I;
    }
    p.prototype._parseHex = function(S, E, I) {
      this.length = Math.ceil((S.length - E) / 6), this.words = new Array(this.length);
      for (var M = 0; M < this.length; M++)
        this.words[M] = 0;
      var $ = 0, U = 0, Y;
      if (I === "be")
        for (M = S.length - 1; M >= E; M -= 2)
          Y = O(S, E, M) << $, this.words[U] |= Y & 67108863, $ >= 18 ? ($ -= 18, U += 1, this.words[U] |= Y >>> 26) : $ += 8;
      else {
        var L = S.length - E;
        for (M = L % 2 === 0 ? E + 1 : E; M < S.length; M += 2)
          Y = O(S, E, M) << $, this.words[U] |= Y & 67108863, $ >= 18 ? ($ -= 18, U += 1, this.words[U] |= Y >>> 26) : $ += 8;
      }
      this.strip();
    };
    function D(C, S, E, I) {
      for (var M = 0, $ = Math.min(C.length, E), U = S; U < $; U++) {
        var Y = C.charCodeAt(U) - 48;
        M *= I, Y >= 49 ? M += Y - 49 + 10 : Y >= 17 ? M += Y - 17 + 10 : M += Y;
      }
      return M;
    }
    p.prototype._parseBase = function(S, E, I) {
      this.words = [0], this.length = 1;
      for (var M = 0, $ = 1; $ <= 67108863; $ *= E)
        M++;
      M--, $ = $ / E | 0;
      for (var U = S.length - I, Y = U % M, L = Math.min(U, U - Y) + I, T = 0, B = I; B < L; B += M)
        T = D(S, B, B + M, E), this.imuln($), this.words[0] + T < 67108864 ? this.words[0] += T : this._iaddn(T);
      if (Y !== 0) {
        var te = 1;
        for (T = D(S, B, S.length, E), B = 0; B < Y; B++)
          te *= E;
        this.imuln(te), this.words[0] + T < 67108864 ? this.words[0] += T : this._iaddn(T);
      }
      this.strip();
    }, p.prototype.copy = function(S) {
      S.words = new Array(this.length);
      for (var E = 0; E < this.length; E++)
        S.words[E] = this.words[E];
      S.length = this.length, S.negative = this.negative, S.red = this.red;
    }, p.prototype.clone = function() {
      var S = new p(null);
      return this.copy(S), S;
    }, p.prototype._expand = function(S) {
      for (; this.length < S; )
        this.words[this.length++] = 0;
      return this;
    }, p.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, p.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, p.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var F = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], z = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], j = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    p.prototype.toString = function(S, E) {
      S = S || 10, E = E | 0 || 1;
      var I;
      if (S === 16 || S === "hex") {
        I = "";
        for (var M = 0, $ = 0, U = 0; U < this.length; U++) {
          var Y = this.words[U], L = ((Y << M | $) & 16777215).toString(16);
          $ = Y >>> 24 - M & 16777215, $ !== 0 || U !== this.length - 1 ? I = F[6 - L.length] + L + I : I = L + I, M += 2, M >= 26 && (M -= 26, U--);
        }
        for ($ !== 0 && (I = $.toString(16) + I); I.length % E !== 0; )
          I = "0" + I;
        return this.negative !== 0 && (I = "-" + I), I;
      }
      if (S === (S | 0) && S >= 2 && S <= 36) {
        var T = z[S], B = j[S];
        I = "";
        var te = this.clone();
        for (te.negative = 0; !te.isZero(); ) {
          var pe = te.modn(B).toString(S);
          te = te.idivn(B), te.isZero() ? I = pe + I : I = F[T - pe.length] + pe + I;
        }
        for (this.isZero() && (I = "0" + I); I.length % E !== 0; )
          I = "0" + I;
        return this.negative !== 0 && (I = "-" + I), I;
      }
      l(!1, "Base should be between 2 and 36");
    }, p.prototype.toNumber = function() {
      var S = this.words[0];
      return this.length === 2 ? S += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? S += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && l(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -S : S;
    }, p.prototype.toJSON = function() {
      return this.toString(16);
    }, p.prototype.toBuffer = function(S, E) {
      return l(typeof _ < "u"), this.toArrayLike(_, S, E);
    }, p.prototype.toArray = function(S, E) {
      return this.toArrayLike(Array, S, E);
    }, p.prototype.toArrayLike = function(S, E, I) {
      var M = this.byteLength(), $ = I || Math.max(1, M);
      l(M <= $, "byte array longer than desired length"), l($ > 0, "Requested array length <= 0"), this.strip();
      var U = E === "le", Y = new S($), L, T, B = this.clone();
      if (U) {
        for (T = 0; !B.isZero(); T++)
          L = B.andln(255), B.iushrn(8), Y[T] = L;
        for (; T < $; T++)
          Y[T] = 0;
      } else {
        for (T = 0; T < $ - M; T++)
          Y[T] = 0;
        for (T = 0; !B.isZero(); T++)
          L = B.andln(255), B.iushrn(8), Y[$ - T - 1] = L;
      }
      return Y;
    }, Math.clz32 ? p.prototype._countBits = function(S) {
      return 32 - Math.clz32(S);
    } : p.prototype._countBits = function(S) {
      var E = S, I = 0;
      return E >= 4096 && (I += 13, E >>>= 13), E >= 64 && (I += 7, E >>>= 7), E >= 8 && (I += 4, E >>>= 4), E >= 2 && (I += 2, E >>>= 2), I + E;
    }, p.prototype._zeroBits = function(S) {
      if (S === 0)
        return 26;
      var E = S, I = 0;
      return E & 8191 || (I += 13, E >>>= 13), E & 127 || (I += 7, E >>>= 7), E & 15 || (I += 4, E >>>= 4), E & 3 || (I += 2, E >>>= 2), E & 1 || I++, I;
    }, p.prototype.bitLength = function() {
      var S = this.words[this.length - 1], E = this._countBits(S);
      return (this.length - 1) * 26 + E;
    };
    function ee(C) {
      for (var S = new Array(C.bitLength()), E = 0; E < S.length; E++) {
        var I = E / 26 | 0, M = E % 26;
        S[E] = (C.words[I] & 1 << M) >>> M;
      }
      return S;
    }
    p.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var S = 0, E = 0; E < this.length; E++) {
        var I = this._zeroBits(this.words[E]);
        if (S += I, I !== 26)
          break;
      }
      return S;
    }, p.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, p.prototype.toTwos = function(S) {
      return this.negative !== 0 ? this.abs().inotn(S).iaddn(1) : this.clone();
    }, p.prototype.fromTwos = function(S) {
      return this.testn(S - 1) ? this.notn(S).iaddn(1).ineg() : this.clone();
    }, p.prototype.isNeg = function() {
      return this.negative !== 0;
    }, p.prototype.neg = function() {
      return this.clone().ineg();
    }, p.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, p.prototype.iuor = function(S) {
      for (; this.length < S.length; )
        this.words[this.length++] = 0;
      for (var E = 0; E < S.length; E++)
        this.words[E] = this.words[E] | S.words[E];
      return this.strip();
    }, p.prototype.ior = function(S) {
      return l((this.negative | S.negative) === 0), this.iuor(S);
    }, p.prototype.or = function(S) {
      return this.length > S.length ? this.clone().ior(S) : S.clone().ior(this);
    }, p.prototype.uor = function(S) {
      return this.length > S.length ? this.clone().iuor(S) : S.clone().iuor(this);
    }, p.prototype.iuand = function(S) {
      var E;
      this.length > S.length ? E = S : E = this;
      for (var I = 0; I < E.length; I++)
        this.words[I] = this.words[I] & S.words[I];
      return this.length = E.length, this.strip();
    }, p.prototype.iand = function(S) {
      return l((this.negative | S.negative) === 0), this.iuand(S);
    }, p.prototype.and = function(S) {
      return this.length > S.length ? this.clone().iand(S) : S.clone().iand(this);
    }, p.prototype.uand = function(S) {
      return this.length > S.length ? this.clone().iuand(S) : S.clone().iuand(this);
    }, p.prototype.iuxor = function(S) {
      var E, I;
      this.length > S.length ? (E = this, I = S) : (E = S, I = this);
      for (var M = 0; M < I.length; M++)
        this.words[M] = E.words[M] ^ I.words[M];
      if (this !== E)
        for (; M < E.length; M++)
          this.words[M] = E.words[M];
      return this.length = E.length, this.strip();
    }, p.prototype.ixor = function(S) {
      return l((this.negative | S.negative) === 0), this.iuxor(S);
    }, p.prototype.xor = function(S) {
      return this.length > S.length ? this.clone().ixor(S) : S.clone().ixor(this);
    }, p.prototype.uxor = function(S) {
      return this.length > S.length ? this.clone().iuxor(S) : S.clone().iuxor(this);
    }, p.prototype.inotn = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = Math.ceil(S / 26) | 0, I = S % 26;
      this._expand(E), I > 0 && E--;
      for (var M = 0; M < E; M++)
        this.words[M] = ~this.words[M] & 67108863;
      return I > 0 && (this.words[M] = ~this.words[M] & 67108863 >> 26 - I), this.strip();
    }, p.prototype.notn = function(S) {
      return this.clone().inotn(S);
    }, p.prototype.setn = function(S, E) {
      l(typeof S == "number" && S >= 0);
      var I = S / 26 | 0, M = S % 26;
      return this._expand(I + 1), E ? this.words[I] = this.words[I] | 1 << M : this.words[I] = this.words[I] & ~(1 << M), this.strip();
    }, p.prototype.iadd = function(S) {
      var E;
      if (this.negative !== 0 && S.negative === 0)
        return this.negative = 0, E = this.isub(S), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && S.negative !== 0)
        return S.negative = 0, E = this.isub(S), S.negative = 1, E._normSign();
      var I, M;
      this.length > S.length ? (I = this, M = S) : (I = S, M = this);
      for (var $ = 0, U = 0; U < M.length; U++)
        E = (I.words[U] | 0) + (M.words[U] | 0) + $, this.words[U] = E & 67108863, $ = E >>> 26;
      for (; $ !== 0 && U < I.length; U++)
        E = (I.words[U] | 0) + $, this.words[U] = E & 67108863, $ = E >>> 26;
      if (this.length = I.length, $ !== 0)
        this.words[this.length] = $, this.length++;
      else if (I !== this)
        for (; U < I.length; U++)
          this.words[U] = I.words[U];
      return this;
    }, p.prototype.add = function(S) {
      var E;
      return S.negative !== 0 && this.negative === 0 ? (S.negative = 0, E = this.sub(S), S.negative ^= 1, E) : S.negative === 0 && this.negative !== 0 ? (this.negative = 0, E = S.sub(this), this.negative = 1, E) : this.length > S.length ? this.clone().iadd(S) : S.clone().iadd(this);
    }, p.prototype.isub = function(S) {
      if (S.negative !== 0) {
        S.negative = 0;
        var E = this.iadd(S);
        return S.negative = 1, E._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(S), this.negative = 1, this._normSign();
      var I = this.cmp(S);
      if (I === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var M, $;
      I > 0 ? (M = this, $ = S) : (M = S, $ = this);
      for (var U = 0, Y = 0; Y < $.length; Y++)
        E = (M.words[Y] | 0) - ($.words[Y] | 0) + U, U = E >> 26, this.words[Y] = E & 67108863;
      for (; U !== 0 && Y < M.length; Y++)
        E = (M.words[Y] | 0) + U, U = E >> 26, this.words[Y] = E & 67108863;
      if (U === 0 && Y < M.length && M !== this)
        for (; Y < M.length; Y++)
          this.words[Y] = M.words[Y];
      return this.length = Math.max(this.length, Y), M !== this && (this.negative = 1), this.strip();
    }, p.prototype.sub = function(S) {
      return this.clone().isub(S);
    };
    function X(C, S, E) {
      E.negative = S.negative ^ C.negative;
      var I = C.length + S.length | 0;
      E.length = I, I = I - 1 | 0;
      var M = C.words[0] | 0, $ = S.words[0] | 0, U = M * $, Y = U & 67108863, L = U / 67108864 | 0;
      E.words[0] = Y;
      for (var T = 1; T < I; T++) {
        for (var B = L >>> 26, te = L & 67108863, pe = Math.min(T, S.length - 1), Ie = Math.max(0, T - C.length + 1); Ie <= pe; Ie++) {
          var $e = T - Ie | 0;
          M = C.words[$e] | 0, $ = S.words[Ie] | 0, U = M * $ + te, B += U / 67108864 | 0, te = U & 67108863;
        }
        E.words[T] = te | 0, L = B | 0;
      }
      return L !== 0 ? E.words[T] = L | 0 : E.length--, E.strip();
    }
    var ae = function(S, E, I) {
      var M = S.words, $ = E.words, U = I.words, Y = 0, L, T, B, te = M[0] | 0, pe = te & 8191, Ie = te >>> 13, $e = M[1] | 0, ve = $e & 8191, he = $e >>> 13, Oe = M[2] | 0, Ae = Oe & 8191, Ue = Oe >>> 13, oe = M[3] | 0, A = oe & 8191, re = oe >>> 13, le = M[4] | 0, Ne = le & 8191, Pe = le >>> 13, Fe = M[5] | 0, je = Fe & 8191, qe = Fe >>> 13, yt = M[6] | 0, Xe = yt & 8191, Ge = yt >>> 13, H = M[7] | 0, ye = H & 8191, Ee = H >>> 13, We = M[8] | 0, we = We & 8191, V = We >>> 13, _e = M[9] | 0, ue = _e & 8191, ce = _e >>> 13, me = $[0] | 0, Ce = me & 8191, Be = me >>> 13, ze = $[1] | 0, Je = ze & 8191, Ze = ze >>> 13, Ke = $[2] | 0, x = Ke & 8191, se = Ke >>> 13, ge = $[3] | 0, xe = ge & 8191, Me = ge >>> 13, Ye = $[4] | 0, et = Ye & 8191, dt = Ye >>> 13, St = $[5] | 0, tt = St & 8191, at = St >>> 13, kt = $[6] | 0, rt = kt & 8191, ut = kt >>> 13, wt = $[7] | 0, nt = wt & 8191, it = wt >>> 13, bt = $[8] | 0, ot = bt & 8191, ct = bt >>> 13, Pt = $[9] | 0, st = Pt & 8191, lt = Pt >>> 13;
      I.negative = S.negative ^ E.negative, I.length = 19, L = Math.imul(pe, Ce), T = Math.imul(pe, Be), T = T + Math.imul(Ie, Ce) | 0, B = Math.imul(Ie, Be);
      var It = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (It >>> 26) | 0, It &= 67108863, L = Math.imul(ve, Ce), T = Math.imul(ve, Be), T = T + Math.imul(he, Ce) | 0, B = Math.imul(he, Be), L = L + Math.imul(pe, Je) | 0, T = T + Math.imul(pe, Ze) | 0, T = T + Math.imul(Ie, Je) | 0, B = B + Math.imul(Ie, Ze) | 0;
      var Rt = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (Rt >>> 26) | 0, Rt &= 67108863, L = Math.imul(Ae, Ce), T = Math.imul(Ae, Be), T = T + Math.imul(Ue, Ce) | 0, B = Math.imul(Ue, Be), L = L + Math.imul(ve, Je) | 0, T = T + Math.imul(ve, Ze) | 0, T = T + Math.imul(he, Je) | 0, B = B + Math.imul(he, Ze) | 0, L = L + Math.imul(pe, x) | 0, T = T + Math.imul(pe, se) | 0, T = T + Math.imul(Ie, x) | 0, B = B + Math.imul(Ie, se) | 0;
      var Ve = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, L = Math.imul(A, Ce), T = Math.imul(A, Be), T = T + Math.imul(re, Ce) | 0, B = Math.imul(re, Be), L = L + Math.imul(Ae, Je) | 0, T = T + Math.imul(Ae, Ze) | 0, T = T + Math.imul(Ue, Je) | 0, B = B + Math.imul(Ue, Ze) | 0, L = L + Math.imul(ve, x) | 0, T = T + Math.imul(ve, se) | 0, T = T + Math.imul(he, x) | 0, B = B + Math.imul(he, se) | 0, L = L + Math.imul(pe, xe) | 0, T = T + Math.imul(pe, Me) | 0, T = T + Math.imul(Ie, xe) | 0, B = B + Math.imul(Ie, Me) | 0;
      var He = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, L = Math.imul(Ne, Ce), T = Math.imul(Ne, Be), T = T + Math.imul(Pe, Ce) | 0, B = Math.imul(Pe, Be), L = L + Math.imul(A, Je) | 0, T = T + Math.imul(A, Ze) | 0, T = T + Math.imul(re, Je) | 0, B = B + Math.imul(re, Ze) | 0, L = L + Math.imul(Ae, x) | 0, T = T + Math.imul(Ae, se) | 0, T = T + Math.imul(Ue, x) | 0, B = B + Math.imul(Ue, se) | 0, L = L + Math.imul(ve, xe) | 0, T = T + Math.imul(ve, Me) | 0, T = T + Math.imul(he, xe) | 0, B = B + Math.imul(he, Me) | 0, L = L + Math.imul(pe, et) | 0, T = T + Math.imul(pe, dt) | 0, T = T + Math.imul(Ie, et) | 0, B = B + Math.imul(Ie, dt) | 0;
      var Qe = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, L = Math.imul(je, Ce), T = Math.imul(je, Be), T = T + Math.imul(qe, Ce) | 0, B = Math.imul(qe, Be), L = L + Math.imul(Ne, Je) | 0, T = T + Math.imul(Ne, Ze) | 0, T = T + Math.imul(Pe, Je) | 0, B = B + Math.imul(Pe, Ze) | 0, L = L + Math.imul(A, x) | 0, T = T + Math.imul(A, se) | 0, T = T + Math.imul(re, x) | 0, B = B + Math.imul(re, se) | 0, L = L + Math.imul(Ae, xe) | 0, T = T + Math.imul(Ae, Me) | 0, T = T + Math.imul(Ue, xe) | 0, B = B + Math.imul(Ue, Me) | 0, L = L + Math.imul(ve, et) | 0, T = T + Math.imul(ve, dt) | 0, T = T + Math.imul(he, et) | 0, B = B + Math.imul(he, dt) | 0, L = L + Math.imul(pe, tt) | 0, T = T + Math.imul(pe, at) | 0, T = T + Math.imul(Ie, tt) | 0, B = B + Math.imul(Ie, at) | 0;
      var pt = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (pt >>> 26) | 0, pt &= 67108863, L = Math.imul(Xe, Ce), T = Math.imul(Xe, Be), T = T + Math.imul(Ge, Ce) | 0, B = Math.imul(Ge, Be), L = L + Math.imul(je, Je) | 0, T = T + Math.imul(je, Ze) | 0, T = T + Math.imul(qe, Je) | 0, B = B + Math.imul(qe, Ze) | 0, L = L + Math.imul(Ne, x) | 0, T = T + Math.imul(Ne, se) | 0, T = T + Math.imul(Pe, x) | 0, B = B + Math.imul(Pe, se) | 0, L = L + Math.imul(A, xe) | 0, T = T + Math.imul(A, Me) | 0, T = T + Math.imul(re, xe) | 0, B = B + Math.imul(re, Me) | 0, L = L + Math.imul(Ae, et) | 0, T = T + Math.imul(Ae, dt) | 0, T = T + Math.imul(Ue, et) | 0, B = B + Math.imul(Ue, dt) | 0, L = L + Math.imul(ve, tt) | 0, T = T + Math.imul(ve, at) | 0, T = T + Math.imul(he, tt) | 0, B = B + Math.imul(he, at) | 0, L = L + Math.imul(pe, rt) | 0, T = T + Math.imul(pe, ut) | 0, T = T + Math.imul(Ie, rt) | 0, B = B + Math.imul(Ie, ut) | 0;
      var mt = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (mt >>> 26) | 0, mt &= 67108863, L = Math.imul(ye, Ce), T = Math.imul(ye, Be), T = T + Math.imul(Ee, Ce) | 0, B = Math.imul(Ee, Be), L = L + Math.imul(Xe, Je) | 0, T = T + Math.imul(Xe, Ze) | 0, T = T + Math.imul(Ge, Je) | 0, B = B + Math.imul(Ge, Ze) | 0, L = L + Math.imul(je, x) | 0, T = T + Math.imul(je, se) | 0, T = T + Math.imul(qe, x) | 0, B = B + Math.imul(qe, se) | 0, L = L + Math.imul(Ne, xe) | 0, T = T + Math.imul(Ne, Me) | 0, T = T + Math.imul(Pe, xe) | 0, B = B + Math.imul(Pe, Me) | 0, L = L + Math.imul(A, et) | 0, T = T + Math.imul(A, dt) | 0, T = T + Math.imul(re, et) | 0, B = B + Math.imul(re, dt) | 0, L = L + Math.imul(Ae, tt) | 0, T = T + Math.imul(Ae, at) | 0, T = T + Math.imul(Ue, tt) | 0, B = B + Math.imul(Ue, at) | 0, L = L + Math.imul(ve, rt) | 0, T = T + Math.imul(ve, ut) | 0, T = T + Math.imul(he, rt) | 0, B = B + Math.imul(he, ut) | 0, L = L + Math.imul(pe, nt) | 0, T = T + Math.imul(pe, it) | 0, T = T + Math.imul(Ie, nt) | 0, B = B + Math.imul(Ie, it) | 0;
      var vt = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, L = Math.imul(we, Ce), T = Math.imul(we, Be), T = T + Math.imul(V, Ce) | 0, B = Math.imul(V, Be), L = L + Math.imul(ye, Je) | 0, T = T + Math.imul(ye, Ze) | 0, T = T + Math.imul(Ee, Je) | 0, B = B + Math.imul(Ee, Ze) | 0, L = L + Math.imul(Xe, x) | 0, T = T + Math.imul(Xe, se) | 0, T = T + Math.imul(Ge, x) | 0, B = B + Math.imul(Ge, se) | 0, L = L + Math.imul(je, xe) | 0, T = T + Math.imul(je, Me) | 0, T = T + Math.imul(qe, xe) | 0, B = B + Math.imul(qe, Me) | 0, L = L + Math.imul(Ne, et) | 0, T = T + Math.imul(Ne, dt) | 0, T = T + Math.imul(Pe, et) | 0, B = B + Math.imul(Pe, dt) | 0, L = L + Math.imul(A, tt) | 0, T = T + Math.imul(A, at) | 0, T = T + Math.imul(re, tt) | 0, B = B + Math.imul(re, at) | 0, L = L + Math.imul(Ae, rt) | 0, T = T + Math.imul(Ae, ut) | 0, T = T + Math.imul(Ue, rt) | 0, B = B + Math.imul(Ue, ut) | 0, L = L + Math.imul(ve, nt) | 0, T = T + Math.imul(ve, it) | 0, T = T + Math.imul(he, nt) | 0, B = B + Math.imul(he, it) | 0, L = L + Math.imul(pe, ot) | 0, T = T + Math.imul(pe, ct) | 0, T = T + Math.imul(Ie, ot) | 0, B = B + Math.imul(Ie, ct) | 0;
      var ht = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (ht >>> 26) | 0, ht &= 67108863, L = Math.imul(ue, Ce), T = Math.imul(ue, Be), T = T + Math.imul(ce, Ce) | 0, B = Math.imul(ce, Be), L = L + Math.imul(we, Je) | 0, T = T + Math.imul(we, Ze) | 0, T = T + Math.imul(V, Je) | 0, B = B + Math.imul(V, Ze) | 0, L = L + Math.imul(ye, x) | 0, T = T + Math.imul(ye, se) | 0, T = T + Math.imul(Ee, x) | 0, B = B + Math.imul(Ee, se) | 0, L = L + Math.imul(Xe, xe) | 0, T = T + Math.imul(Xe, Me) | 0, T = T + Math.imul(Ge, xe) | 0, B = B + Math.imul(Ge, Me) | 0, L = L + Math.imul(je, et) | 0, T = T + Math.imul(je, dt) | 0, T = T + Math.imul(qe, et) | 0, B = B + Math.imul(qe, dt) | 0, L = L + Math.imul(Ne, tt) | 0, T = T + Math.imul(Ne, at) | 0, T = T + Math.imul(Pe, tt) | 0, B = B + Math.imul(Pe, at) | 0, L = L + Math.imul(A, rt) | 0, T = T + Math.imul(A, ut) | 0, T = T + Math.imul(re, rt) | 0, B = B + Math.imul(re, ut) | 0, L = L + Math.imul(Ae, nt) | 0, T = T + Math.imul(Ae, it) | 0, T = T + Math.imul(Ue, nt) | 0, B = B + Math.imul(Ue, it) | 0, L = L + Math.imul(ve, ot) | 0, T = T + Math.imul(ve, ct) | 0, T = T + Math.imul(he, ot) | 0, B = B + Math.imul(he, ct) | 0, L = L + Math.imul(pe, st) | 0, T = T + Math.imul(pe, lt) | 0, T = T + Math.imul(Ie, st) | 0, B = B + Math.imul(Ie, lt) | 0;
      var Et = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, L = Math.imul(ue, Je), T = Math.imul(ue, Ze), T = T + Math.imul(ce, Je) | 0, B = Math.imul(ce, Ze), L = L + Math.imul(we, x) | 0, T = T + Math.imul(we, se) | 0, T = T + Math.imul(V, x) | 0, B = B + Math.imul(V, se) | 0, L = L + Math.imul(ye, xe) | 0, T = T + Math.imul(ye, Me) | 0, T = T + Math.imul(Ee, xe) | 0, B = B + Math.imul(Ee, Me) | 0, L = L + Math.imul(Xe, et) | 0, T = T + Math.imul(Xe, dt) | 0, T = T + Math.imul(Ge, et) | 0, B = B + Math.imul(Ge, dt) | 0, L = L + Math.imul(je, tt) | 0, T = T + Math.imul(je, at) | 0, T = T + Math.imul(qe, tt) | 0, B = B + Math.imul(qe, at) | 0, L = L + Math.imul(Ne, rt) | 0, T = T + Math.imul(Ne, ut) | 0, T = T + Math.imul(Pe, rt) | 0, B = B + Math.imul(Pe, ut) | 0, L = L + Math.imul(A, nt) | 0, T = T + Math.imul(A, it) | 0, T = T + Math.imul(re, nt) | 0, B = B + Math.imul(re, it) | 0, L = L + Math.imul(Ae, ot) | 0, T = T + Math.imul(Ae, ct) | 0, T = T + Math.imul(Ue, ot) | 0, B = B + Math.imul(Ue, ct) | 0, L = L + Math.imul(ve, st) | 0, T = T + Math.imul(ve, lt) | 0, T = T + Math.imul(he, st) | 0, B = B + Math.imul(he, lt) | 0;
      var Tt = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (Tt >>> 26) | 0, Tt &= 67108863, L = Math.imul(ue, x), T = Math.imul(ue, se), T = T + Math.imul(ce, x) | 0, B = Math.imul(ce, se), L = L + Math.imul(we, xe) | 0, T = T + Math.imul(we, Me) | 0, T = T + Math.imul(V, xe) | 0, B = B + Math.imul(V, Me) | 0, L = L + Math.imul(ye, et) | 0, T = T + Math.imul(ye, dt) | 0, T = T + Math.imul(Ee, et) | 0, B = B + Math.imul(Ee, dt) | 0, L = L + Math.imul(Xe, tt) | 0, T = T + Math.imul(Xe, at) | 0, T = T + Math.imul(Ge, tt) | 0, B = B + Math.imul(Ge, at) | 0, L = L + Math.imul(je, rt) | 0, T = T + Math.imul(je, ut) | 0, T = T + Math.imul(qe, rt) | 0, B = B + Math.imul(qe, ut) | 0, L = L + Math.imul(Ne, nt) | 0, T = T + Math.imul(Ne, it) | 0, T = T + Math.imul(Pe, nt) | 0, B = B + Math.imul(Pe, it) | 0, L = L + Math.imul(A, ot) | 0, T = T + Math.imul(A, ct) | 0, T = T + Math.imul(re, ot) | 0, B = B + Math.imul(re, ct) | 0, L = L + Math.imul(Ae, st) | 0, T = T + Math.imul(Ae, lt) | 0, T = T + Math.imul(Ue, st) | 0, B = B + Math.imul(Ue, lt) | 0;
      var Ot = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (Ot >>> 26) | 0, Ot &= 67108863, L = Math.imul(ue, xe), T = Math.imul(ue, Me), T = T + Math.imul(ce, xe) | 0, B = Math.imul(ce, Me), L = L + Math.imul(we, et) | 0, T = T + Math.imul(we, dt) | 0, T = T + Math.imul(V, et) | 0, B = B + Math.imul(V, dt) | 0, L = L + Math.imul(ye, tt) | 0, T = T + Math.imul(ye, at) | 0, T = T + Math.imul(Ee, tt) | 0, B = B + Math.imul(Ee, at) | 0, L = L + Math.imul(Xe, rt) | 0, T = T + Math.imul(Xe, ut) | 0, T = T + Math.imul(Ge, rt) | 0, B = B + Math.imul(Ge, ut) | 0, L = L + Math.imul(je, nt) | 0, T = T + Math.imul(je, it) | 0, T = T + Math.imul(qe, nt) | 0, B = B + Math.imul(qe, it) | 0, L = L + Math.imul(Ne, ot) | 0, T = T + Math.imul(Ne, ct) | 0, T = T + Math.imul(Pe, ot) | 0, B = B + Math.imul(Pe, ct) | 0, L = L + Math.imul(A, st) | 0, T = T + Math.imul(A, lt) | 0, T = T + Math.imul(re, st) | 0, B = B + Math.imul(re, lt) | 0;
      var Nt = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, L = Math.imul(ue, et), T = Math.imul(ue, dt), T = T + Math.imul(ce, et) | 0, B = Math.imul(ce, dt), L = L + Math.imul(we, tt) | 0, T = T + Math.imul(we, at) | 0, T = T + Math.imul(V, tt) | 0, B = B + Math.imul(V, at) | 0, L = L + Math.imul(ye, rt) | 0, T = T + Math.imul(ye, ut) | 0, T = T + Math.imul(Ee, rt) | 0, B = B + Math.imul(Ee, ut) | 0, L = L + Math.imul(Xe, nt) | 0, T = T + Math.imul(Xe, it) | 0, T = T + Math.imul(Ge, nt) | 0, B = B + Math.imul(Ge, it) | 0, L = L + Math.imul(je, ot) | 0, T = T + Math.imul(je, ct) | 0, T = T + Math.imul(qe, ot) | 0, B = B + Math.imul(qe, ct) | 0, L = L + Math.imul(Ne, st) | 0, T = T + Math.imul(Ne, lt) | 0, T = T + Math.imul(Pe, st) | 0, B = B + Math.imul(Pe, lt) | 0;
      var At = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, L = Math.imul(ue, tt), T = Math.imul(ue, at), T = T + Math.imul(ce, tt) | 0, B = Math.imul(ce, at), L = L + Math.imul(we, rt) | 0, T = T + Math.imul(we, ut) | 0, T = T + Math.imul(V, rt) | 0, B = B + Math.imul(V, ut) | 0, L = L + Math.imul(ye, nt) | 0, T = T + Math.imul(ye, it) | 0, T = T + Math.imul(Ee, nt) | 0, B = B + Math.imul(Ee, it) | 0, L = L + Math.imul(Xe, ot) | 0, T = T + Math.imul(Xe, ct) | 0, T = T + Math.imul(Ge, ot) | 0, B = B + Math.imul(Ge, ct) | 0, L = L + Math.imul(je, st) | 0, T = T + Math.imul(je, lt) | 0, T = T + Math.imul(qe, st) | 0, B = B + Math.imul(qe, lt) | 0;
      var Mt = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (Mt >>> 26) | 0, Mt &= 67108863, L = Math.imul(ue, rt), T = Math.imul(ue, ut), T = T + Math.imul(ce, rt) | 0, B = Math.imul(ce, ut), L = L + Math.imul(we, nt) | 0, T = T + Math.imul(we, it) | 0, T = T + Math.imul(V, nt) | 0, B = B + Math.imul(V, it) | 0, L = L + Math.imul(ye, ot) | 0, T = T + Math.imul(ye, ct) | 0, T = T + Math.imul(Ee, ot) | 0, B = B + Math.imul(Ee, ct) | 0, L = L + Math.imul(Xe, st) | 0, T = T + Math.imul(Xe, lt) | 0, T = T + Math.imul(Ge, st) | 0, B = B + Math.imul(Ge, lt) | 0;
      var $t = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + ($t >>> 26) | 0, $t &= 67108863, L = Math.imul(ue, nt), T = Math.imul(ue, it), T = T + Math.imul(ce, nt) | 0, B = Math.imul(ce, it), L = L + Math.imul(we, ot) | 0, T = T + Math.imul(we, ct) | 0, T = T + Math.imul(V, ot) | 0, B = B + Math.imul(V, ct) | 0, L = L + Math.imul(ye, st) | 0, T = T + Math.imul(ye, lt) | 0, T = T + Math.imul(Ee, st) | 0, B = B + Math.imul(Ee, lt) | 0;
      var Bt = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, L = Math.imul(ue, ot), T = Math.imul(ue, ct), T = T + Math.imul(ce, ot) | 0, B = Math.imul(ce, ct), L = L + Math.imul(we, st) | 0, T = T + Math.imul(we, lt) | 0, T = T + Math.imul(V, st) | 0, B = B + Math.imul(V, lt) | 0;
      var Ut = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (Ut >>> 26) | 0, Ut &= 67108863, L = Math.imul(ue, st), T = Math.imul(ue, lt), T = T + Math.imul(ce, st) | 0, B = Math.imul(ce, lt);
      var xt = (Y + L | 0) + ((T & 8191) << 13) | 0;
      return Y = (B + (T >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, U[0] = It, U[1] = Rt, U[2] = Ve, U[3] = He, U[4] = Qe, U[5] = pt, U[6] = mt, U[7] = vt, U[8] = ht, U[9] = Et, U[10] = Tt, U[11] = Ot, U[12] = Nt, U[13] = At, U[14] = Mt, U[15] = $t, U[16] = Bt, U[17] = Ut, U[18] = xt, Y !== 0 && (U[19] = Y, I.length++), I;
    };
    Math.imul || (ae = X);
    function Q(C, S, E) {
      E.negative = S.negative ^ C.negative, E.length = C.length + S.length;
      for (var I = 0, M = 0, $ = 0; $ < E.length - 1; $++) {
        var U = M;
        M = 0;
        for (var Y = I & 67108863, L = Math.min($, S.length - 1), T = Math.max(0, $ - C.length + 1); T <= L; T++) {
          var B = $ - T, te = C.words[B] | 0, pe = S.words[T] | 0, Ie = te * pe, $e = Ie & 67108863;
          U = U + (Ie / 67108864 | 0) | 0, $e = $e + Y | 0, Y = $e & 67108863, U = U + ($e >>> 26) | 0, M += U >>> 26, U &= 67108863;
        }
        E.words[$] = Y, I = U, U = M;
      }
      return I !== 0 ? E.words[$] = I : E.length--, E.strip();
    }
    function ne(C, S, E) {
      var I = new Z();
      return I.mulp(C, S, E);
    }
    p.prototype.mulTo = function(S, E) {
      var I, M = this.length + S.length;
      return this.length === 10 && S.length === 10 ? I = ae(this, S, E) : M < 63 ? I = X(this, S, E) : M < 1024 ? I = Q(this, S, E) : I = ne(this, S, E), I;
    };
    function Z(C, S) {
      this.x = C, this.y = S;
    }
    Z.prototype.makeRBT = function(S) {
      for (var E = new Array(S), I = p.prototype._countBits(S) - 1, M = 0; M < S; M++)
        E[M] = this.revBin(M, I, S);
      return E;
    }, Z.prototype.revBin = function(S, E, I) {
      if (S === 0 || S === I - 1)
        return S;
      for (var M = 0, $ = 0; $ < E; $++)
        M |= (S & 1) << E - $ - 1, S >>= 1;
      return M;
    }, Z.prototype.permute = function(S, E, I, M, $, U) {
      for (var Y = 0; Y < U; Y++)
        M[Y] = E[S[Y]], $[Y] = I[S[Y]];
    }, Z.prototype.transform = function(S, E, I, M, $, U) {
      this.permute(U, S, E, I, M, $);
      for (var Y = 1; Y < $; Y <<= 1)
        for (var L = Y << 1, T = Math.cos(2 * Math.PI / L), B = Math.sin(2 * Math.PI / L), te = 0; te < $; te += L)
          for (var pe = T, Ie = B, $e = 0; $e < Y; $e++) {
            var ve = I[te + $e], he = M[te + $e], Oe = I[te + $e + Y], Ae = M[te + $e + Y], Ue = pe * Oe - Ie * Ae;
            Ae = pe * Ae + Ie * Oe, Oe = Ue, I[te + $e] = ve + Oe, M[te + $e] = he + Ae, I[te + $e + Y] = ve - Oe, M[te + $e + Y] = he - Ae, $e !== L && (Ue = T * pe - B * Ie, Ie = T * Ie + B * pe, pe = Ue);
          }
    }, Z.prototype.guessLen13b = function(S, E) {
      var I = Math.max(E, S) | 1, M = I & 1, $ = 0;
      for (I = I / 2 | 0; I; I = I >>> 1)
        $++;
      return 1 << $ + 1 + M;
    }, Z.prototype.conjugate = function(S, E, I) {
      if (!(I <= 1))
        for (var M = 0; M < I / 2; M++) {
          var $ = S[M];
          S[M] = S[I - M - 1], S[I - M - 1] = $, $ = E[M], E[M] = -E[I - M - 1], E[I - M - 1] = -$;
        }
    }, Z.prototype.normalize13b = function(S, E) {
      for (var I = 0, M = 0; M < E / 2; M++) {
        var $ = Math.round(S[2 * M + 1] / E) * 8192 + Math.round(S[2 * M] / E) + I;
        S[M] = $ & 67108863, $ < 67108864 ? I = 0 : I = $ / 67108864 | 0;
      }
      return S;
    }, Z.prototype.convert13b = function(S, E, I, M) {
      for (var $ = 0, U = 0; U < E; U++)
        $ = $ + (S[U] | 0), I[2 * U] = $ & 8191, $ = $ >>> 13, I[2 * U + 1] = $ & 8191, $ = $ >>> 13;
      for (U = 2 * E; U < M; ++U)
        I[U] = 0;
      l($ === 0), l(($ & -8192) === 0);
    }, Z.prototype.stub = function(S) {
      for (var E = new Array(S), I = 0; I < S; I++)
        E[I] = 0;
      return E;
    }, Z.prototype.mulp = function(S, E, I) {
      var M = 2 * this.guessLen13b(S.length, E.length), $ = this.makeRBT(M), U = this.stub(M), Y = new Array(M), L = new Array(M), T = new Array(M), B = new Array(M), te = new Array(M), pe = new Array(M), Ie = I.words;
      Ie.length = M, this.convert13b(S.words, S.length, Y, M), this.convert13b(E.words, E.length, B, M), this.transform(Y, U, L, T, M, $), this.transform(B, U, te, pe, M, $);
      for (var $e = 0; $e < M; $e++) {
        var ve = L[$e] * te[$e] - T[$e] * pe[$e];
        T[$e] = L[$e] * pe[$e] + T[$e] * te[$e], L[$e] = ve;
      }
      return this.conjugate(L, T, M), this.transform(L, T, Ie, U, M, $), this.conjugate(Ie, U, M), this.normalize13b(Ie, M), I.negative = S.negative ^ E.negative, I.length = S.length + E.length, I.strip();
    }, p.prototype.mul = function(S) {
      var E = new p(null);
      return E.words = new Array(this.length + S.length), this.mulTo(S, E);
    }, p.prototype.mulf = function(S) {
      var E = new p(null);
      return E.words = new Array(this.length + S.length), ne(this, S, E);
    }, p.prototype.imul = function(S) {
      return this.clone().mulTo(S, this);
    }, p.prototype.imuln = function(S) {
      l(typeof S == "number"), l(S < 67108864);
      for (var E = 0, I = 0; I < this.length; I++) {
        var M = (this.words[I] | 0) * S, $ = (M & 67108863) + (E & 67108863);
        E >>= 26, E += M / 67108864 | 0, E += $ >>> 26, this.words[I] = $ & 67108863;
      }
      return E !== 0 && (this.words[I] = E, this.length++), this;
    }, p.prototype.muln = function(S) {
      return this.clone().imuln(S);
    }, p.prototype.sqr = function() {
      return this.mul(this);
    }, p.prototype.isqr = function() {
      return this.imul(this.clone());
    }, p.prototype.pow = function(S) {
      var E = ee(S);
      if (E.length === 0)
        return new p(1);
      for (var I = this, M = 0; M < E.length && E[M] === 0; M++, I = I.sqr())
        ;
      if (++M < E.length)
        for (var $ = I.sqr(); M < E.length; M++, $ = $.sqr())
          E[M] !== 0 && (I = I.mul($));
      return I;
    }, p.prototype.iushln = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = S % 26, I = (S - E) / 26, M = 67108863 >>> 26 - E << 26 - E, $;
      if (E !== 0) {
        var U = 0;
        for ($ = 0; $ < this.length; $++) {
          var Y = this.words[$] & M, L = (this.words[$] | 0) - Y << E;
          this.words[$] = L | U, U = Y >>> 26 - E;
        }
        U && (this.words[$] = U, this.length++);
      }
      if (I !== 0) {
        for ($ = this.length - 1; $ >= 0; $--)
          this.words[$ + I] = this.words[$];
        for ($ = 0; $ < I; $++)
          this.words[$] = 0;
        this.length += I;
      }
      return this.strip();
    }, p.prototype.ishln = function(S) {
      return l(this.negative === 0), this.iushln(S);
    }, p.prototype.iushrn = function(S, E, I) {
      l(typeof S == "number" && S >= 0);
      var M;
      E ? M = (E - E % 26) / 26 : M = 0;
      var $ = S % 26, U = Math.min((S - $) / 26, this.length), Y = 67108863 ^ 67108863 >>> $ << $, L = I;
      if (M -= U, M = Math.max(0, M), L) {
        for (var T = 0; T < U; T++)
          L.words[T] = this.words[T];
        L.length = U;
      }
      if (U !== 0)
        if (this.length > U)
          for (this.length -= U, T = 0; T < this.length; T++)
            this.words[T] = this.words[T + U];
        else
          this.words[0] = 0, this.length = 1;
      var B = 0;
      for (T = this.length - 1; T >= 0 && (B !== 0 || T >= M); T--) {
        var te = this.words[T] | 0;
        this.words[T] = B << 26 - $ | te >>> $, B = te & Y;
      }
      return L && B !== 0 && (L.words[L.length++] = B), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, p.prototype.ishrn = function(S, E, I) {
      return l(this.negative === 0), this.iushrn(S, E, I);
    }, p.prototype.shln = function(S) {
      return this.clone().ishln(S);
    }, p.prototype.ushln = function(S) {
      return this.clone().iushln(S);
    }, p.prototype.shrn = function(S) {
      return this.clone().ishrn(S);
    }, p.prototype.ushrn = function(S) {
      return this.clone().iushrn(S);
    }, p.prototype.testn = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = S % 26, I = (S - E) / 26, M = 1 << E;
      if (this.length <= I)
        return !1;
      var $ = this.words[I];
      return !!($ & M);
    }, p.prototype.imaskn = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = S % 26, I = (S - E) / 26;
      if (l(this.negative === 0, "imaskn works only with positive numbers"), this.length <= I)
        return this;
      if (E !== 0 && I++, this.length = Math.min(I, this.length), E !== 0) {
        var M = 67108863 ^ 67108863 >>> E << E;
        this.words[this.length - 1] &= M;
      }
      return this.strip();
    }, p.prototype.maskn = function(S) {
      return this.clone().imaskn(S);
    }, p.prototype.iaddn = function(S) {
      return l(typeof S == "number"), l(S < 67108864), S < 0 ? this.isubn(-S) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < S ? (this.words[0] = S - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(S), this.negative = 1, this) : this._iaddn(S);
    }, p.prototype._iaddn = function(S) {
      this.words[0] += S;
      for (var E = 0; E < this.length && this.words[E] >= 67108864; E++)
        this.words[E] -= 67108864, E === this.length - 1 ? this.words[E + 1] = 1 : this.words[E + 1]++;
      return this.length = Math.max(this.length, E + 1), this;
    }, p.prototype.isubn = function(S) {
      if (l(typeof S == "number"), l(S < 67108864), S < 0)
        return this.iaddn(-S);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(S), this.negative = 1, this;
      if (this.words[0] -= S, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var E = 0; E < this.length && this.words[E] < 0; E++)
          this.words[E] += 67108864, this.words[E + 1] -= 1;
      return this.strip();
    }, p.prototype.addn = function(S) {
      return this.clone().iaddn(S);
    }, p.prototype.subn = function(S) {
      return this.clone().isubn(S);
    }, p.prototype.iabs = function() {
      return this.negative = 0, this;
    }, p.prototype.abs = function() {
      return this.clone().iabs();
    }, p.prototype._ishlnsubmul = function(S, E, I) {
      var M = S.length + I, $;
      this._expand(M);
      var U, Y = 0;
      for ($ = 0; $ < S.length; $++) {
        U = (this.words[$ + I] | 0) + Y;
        var L = (S.words[$] | 0) * E;
        U -= L & 67108863, Y = (U >> 26) - (L / 67108864 | 0), this.words[$ + I] = U & 67108863;
      }
      for (; $ < this.length - I; $++)
        U = (this.words[$ + I] | 0) + Y, Y = U >> 26, this.words[$ + I] = U & 67108863;
      if (Y === 0)
        return this.strip();
      for (l(Y === -1), Y = 0, $ = 0; $ < this.length; $++)
        U = -(this.words[$] | 0) + Y, Y = U >> 26, this.words[$] = U & 67108863;
      return this.negative = 1, this.strip();
    }, p.prototype._wordDiv = function(S, E) {
      var I = this.length - S.length, M = this.clone(), $ = S, U = $.words[$.length - 1] | 0, Y = this._countBits(U);
      I = 26 - Y, I !== 0 && ($ = $.ushln(I), M.iushln(I), U = $.words[$.length - 1] | 0);
      var L = M.length - $.length, T;
      if (E !== "mod") {
        T = new p(null), T.length = L + 1, T.words = new Array(T.length);
        for (var B = 0; B < T.length; B++)
          T.words[B] = 0;
      }
      var te = M.clone()._ishlnsubmul($, 1, L);
      te.negative === 0 && (M = te, T && (T.words[L] = 1));
      for (var pe = L - 1; pe >= 0; pe--) {
        var Ie = (M.words[$.length + pe] | 0) * 67108864 + (M.words[$.length + pe - 1] | 0);
        for (Ie = Math.min(Ie / U | 0, 67108863), M._ishlnsubmul($, Ie, pe); M.negative !== 0; )
          Ie--, M.negative = 0, M._ishlnsubmul($, 1, pe), M.isZero() || (M.negative ^= 1);
        T && (T.words[pe] = Ie);
      }
      return T && T.strip(), M.strip(), E !== "div" && I !== 0 && M.iushrn(I), {
        div: T || null,
        mod: M
      };
    }, p.prototype.divmod = function(S, E, I) {
      if (l(!S.isZero()), this.isZero())
        return {
          div: new p(0),
          mod: new p(0)
        };
      var M, $, U;
      return this.negative !== 0 && S.negative === 0 ? (U = this.neg().divmod(S, E), E !== "mod" && (M = U.div.neg()), E !== "div" && ($ = U.mod.neg(), I && $.negative !== 0 && $.iadd(S)), {
        div: M,
        mod: $
      }) : this.negative === 0 && S.negative !== 0 ? (U = this.divmod(S.neg(), E), E !== "mod" && (M = U.div.neg()), {
        div: M,
        mod: U.mod
      }) : this.negative & S.negative ? (U = this.neg().divmod(S.neg(), E), E !== "div" && ($ = U.mod.neg(), I && $.negative !== 0 && $.isub(S)), {
        div: U.div,
        mod: $
      }) : S.length > this.length || this.cmp(S) < 0 ? {
        div: new p(0),
        mod: this
      } : S.length === 1 ? E === "div" ? {
        div: this.divn(S.words[0]),
        mod: null
      } : E === "mod" ? {
        div: null,
        mod: new p(this.modn(S.words[0]))
      } : {
        div: this.divn(S.words[0]),
        mod: new p(this.modn(S.words[0]))
      } : this._wordDiv(S, E);
    }, p.prototype.div = function(S) {
      return this.divmod(S, "div", !1).div;
    }, p.prototype.mod = function(S) {
      return this.divmod(S, "mod", !1).mod;
    }, p.prototype.umod = function(S) {
      return this.divmod(S, "mod", !0).mod;
    }, p.prototype.divRound = function(S) {
      var E = this.divmod(S);
      if (E.mod.isZero())
        return E.div;
      var I = E.div.negative !== 0 ? E.mod.isub(S) : E.mod, M = S.ushrn(1), $ = S.andln(1), U = I.cmp(M);
      return U < 0 || $ === 1 && U === 0 ? E.div : E.div.negative !== 0 ? E.div.isubn(1) : E.div.iaddn(1);
    }, p.prototype.modn = function(S) {
      l(S <= 67108863);
      for (var E = (1 << 26) % S, I = 0, M = this.length - 1; M >= 0; M--)
        I = (E * I + (this.words[M] | 0)) % S;
      return I;
    }, p.prototype.idivn = function(S) {
      l(S <= 67108863);
      for (var E = 0, I = this.length - 1; I >= 0; I--) {
        var M = (this.words[I] | 0) + E * 67108864;
        this.words[I] = M / S | 0, E = M % S;
      }
      return this.strip();
    }, p.prototype.divn = function(S) {
      return this.clone().idivn(S);
    }, p.prototype.egcd = function(S) {
      l(S.negative === 0), l(!S.isZero());
      var E = this, I = S.clone();
      E.negative !== 0 ? E = E.umod(S) : E = E.clone();
      for (var M = new p(1), $ = new p(0), U = new p(0), Y = new p(1), L = 0; E.isEven() && I.isEven(); )
        E.iushrn(1), I.iushrn(1), ++L;
      for (var T = I.clone(), B = E.clone(); !E.isZero(); ) {
        for (var te = 0, pe = 1; !(E.words[0] & pe) && te < 26; ++te, pe <<= 1)
          ;
        if (te > 0)
          for (E.iushrn(te); te-- > 0; )
            (M.isOdd() || $.isOdd()) && (M.iadd(T), $.isub(B)), M.iushrn(1), $.iushrn(1);
        for (var Ie = 0, $e = 1; !(I.words[0] & $e) && Ie < 26; ++Ie, $e <<= 1)
          ;
        if (Ie > 0)
          for (I.iushrn(Ie); Ie-- > 0; )
            (U.isOdd() || Y.isOdd()) && (U.iadd(T), Y.isub(B)), U.iushrn(1), Y.iushrn(1);
        E.cmp(I) >= 0 ? (E.isub(I), M.isub(U), $.isub(Y)) : (I.isub(E), U.isub(M), Y.isub($));
      }
      return {
        a: U,
        b: Y,
        gcd: I.iushln(L)
      };
    }, p.prototype._invmp = function(S) {
      l(S.negative === 0), l(!S.isZero());
      var E = this, I = S.clone();
      E.negative !== 0 ? E = E.umod(S) : E = E.clone();
      for (var M = new p(1), $ = new p(0), U = I.clone(); E.cmpn(1) > 0 && I.cmpn(1) > 0; ) {
        for (var Y = 0, L = 1; !(E.words[0] & L) && Y < 26; ++Y, L <<= 1)
          ;
        if (Y > 0)
          for (E.iushrn(Y); Y-- > 0; )
            M.isOdd() && M.iadd(U), M.iushrn(1);
        for (var T = 0, B = 1; !(I.words[0] & B) && T < 26; ++T, B <<= 1)
          ;
        if (T > 0)
          for (I.iushrn(T); T-- > 0; )
            $.isOdd() && $.iadd(U), $.iushrn(1);
        E.cmp(I) >= 0 ? (E.isub(I), M.isub($)) : (I.isub(E), $.isub(M));
      }
      var te;
      return E.cmpn(1) === 0 ? te = M : te = $, te.cmpn(0) < 0 && te.iadd(S), te;
    }, p.prototype.gcd = function(S) {
      if (this.isZero())
        return S.abs();
      if (S.isZero())
        return this.abs();
      var E = this.clone(), I = S.clone();
      E.negative = 0, I.negative = 0;
      for (var M = 0; E.isEven() && I.isEven(); M++)
        E.iushrn(1), I.iushrn(1);
      do {
        for (; E.isEven(); )
          E.iushrn(1);
        for (; I.isEven(); )
          I.iushrn(1);
        var $ = E.cmp(I);
        if ($ < 0) {
          var U = E;
          E = I, I = U;
        } else if ($ === 0 || I.cmpn(1) === 0)
          break;
        E.isub(I);
      } while (!0);
      return I.iushln(M);
    }, p.prototype.invm = function(S) {
      return this.egcd(S).a.umod(S);
    }, p.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, p.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, p.prototype.andln = function(S) {
      return this.words[0] & S;
    }, p.prototype.bincn = function(S) {
      l(typeof S == "number");
      var E = S % 26, I = (S - E) / 26, M = 1 << E;
      if (this.length <= I)
        return this._expand(I + 1), this.words[I] |= M, this;
      for (var $ = M, U = I; $ !== 0 && U < this.length; U++) {
        var Y = this.words[U] | 0;
        Y += $, $ = Y >>> 26, Y &= 67108863, this.words[U] = Y;
      }
      return $ !== 0 && (this.words[U] = $, this.length++), this;
    }, p.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, p.prototype.cmpn = function(S) {
      var E = S < 0;
      if (this.negative !== 0 && !E)
        return -1;
      if (this.negative === 0 && E)
        return 1;
      this.strip();
      var I;
      if (this.length > 1)
        I = 1;
      else {
        E && (S = -S), l(S <= 67108863, "Number is too big");
        var M = this.words[0] | 0;
        I = M === S ? 0 : M < S ? -1 : 1;
      }
      return this.negative !== 0 ? -I | 0 : I;
    }, p.prototype.cmp = function(S) {
      if (this.negative !== 0 && S.negative === 0)
        return -1;
      if (this.negative === 0 && S.negative !== 0)
        return 1;
      var E = this.ucmp(S);
      return this.negative !== 0 ? -E | 0 : E;
    }, p.prototype.ucmp = function(S) {
      if (this.length > S.length)
        return 1;
      if (this.length < S.length)
        return -1;
      for (var E = 0, I = this.length - 1; I >= 0; I--) {
        var M = this.words[I] | 0, $ = S.words[I] | 0;
        if (M !== $) {
          M < $ ? E = -1 : M > $ && (E = 1);
          break;
        }
      }
      return E;
    }, p.prototype.gtn = function(S) {
      return this.cmpn(S) === 1;
    }, p.prototype.gt = function(S) {
      return this.cmp(S) === 1;
    }, p.prototype.gten = function(S) {
      return this.cmpn(S) >= 0;
    }, p.prototype.gte = function(S) {
      return this.cmp(S) >= 0;
    }, p.prototype.ltn = function(S) {
      return this.cmpn(S) === -1;
    }, p.prototype.lt = function(S) {
      return this.cmp(S) === -1;
    }, p.prototype.lten = function(S) {
      return this.cmpn(S) <= 0;
    }, p.prototype.lte = function(S) {
      return this.cmp(S) <= 0;
    }, p.prototype.eqn = function(S) {
      return this.cmpn(S) === 0;
    }, p.prototype.eq = function(S) {
      return this.cmp(S) === 0;
    }, p.red = function(S) {
      return new q(S);
    }, p.prototype.toRed = function(S) {
      return l(!this.red, "Already a number in reduction context"), l(this.negative === 0, "red works only with positives"), S.convertTo(this)._forceRed(S);
    }, p.prototype.fromRed = function() {
      return l(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, p.prototype._forceRed = function(S) {
      return this.red = S, this;
    }, p.prototype.forceRed = function(S) {
      return l(!this.red, "Already a number in reduction context"), this._forceRed(S);
    }, p.prototype.redAdd = function(S) {
      return l(this.red, "redAdd works only with red numbers"), this.red.add(this, S);
    }, p.prototype.redIAdd = function(S) {
      return l(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, S);
    }, p.prototype.redSub = function(S) {
      return l(this.red, "redSub works only with red numbers"), this.red.sub(this, S);
    }, p.prototype.redISub = function(S) {
      return l(this.red, "redISub works only with red numbers"), this.red.isub(this, S);
    }, p.prototype.redShl = function(S) {
      return l(this.red, "redShl works only with red numbers"), this.red.shl(this, S);
    }, p.prototype.redMul = function(S) {
      return l(this.red, "redMul works only with red numbers"), this.red._verify2(this, S), this.red.mul(this, S);
    }, p.prototype.redIMul = function(S) {
      return l(this.red, "redMul works only with red numbers"), this.red._verify2(this, S), this.red.imul(this, S);
    }, p.prototype.redSqr = function() {
      return l(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, p.prototype.redISqr = function() {
      return l(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, p.prototype.redSqrt = function() {
      return l(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, p.prototype.redInvm = function() {
      return l(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, p.prototype.redNeg = function() {
      return l(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, p.prototype.redPow = function(S) {
      return l(this.red && !S.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, S);
    };
    var de = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function fe(C, S) {
      this.name = C, this.p = new p(S, 16), this.n = this.p.bitLength(), this.k = new p(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    fe.prototype._tmp = function() {
      var S = new p(null);
      return S.words = new Array(Math.ceil(this.n / 13)), S;
    }, fe.prototype.ireduce = function(S) {
      var E = S, I;
      do
        this.split(E, this.tmp), E = this.imulK(E), E = E.iadd(this.tmp), I = E.bitLength();
      while (I > this.n);
      var M = I < this.n ? -1 : E.ucmp(this.p);
      return M === 0 ? (E.words[0] = 0, E.length = 1) : M > 0 ? E.isub(this.p) : E.strip !== void 0 ? E.strip() : E._strip(), E;
    }, fe.prototype.split = function(S, E) {
      S.iushrn(this.n, 0, E);
    }, fe.prototype.imulK = function(S) {
      return S.imul(this.k);
    };
    function Te() {
      fe.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    v(Te, fe), Te.prototype.split = function(S, E) {
      for (var I = 4194303, M = Math.min(S.length, 9), $ = 0; $ < M; $++)
        E.words[$] = S.words[$];
      if (E.length = M, S.length <= 9) {
        S.words[0] = 0, S.length = 1;
        return;
      }
      var U = S.words[9];
      for (E.words[E.length++] = U & I, $ = 10; $ < S.length; $++) {
        var Y = S.words[$] | 0;
        S.words[$ - 10] = (Y & I) << 4 | U >>> 22, U = Y;
      }
      U >>>= 22, S.words[$ - 10] = U, U === 0 && S.length > 10 ? S.length -= 10 : S.length -= 9;
    }, Te.prototype.imulK = function(S) {
      S.words[S.length] = 0, S.words[S.length + 1] = 0, S.length += 2;
      for (var E = 0, I = 0; I < S.length; I++) {
        var M = S.words[I] | 0;
        E += M * 977, S.words[I] = E & 67108863, E = M * 64 + (E / 67108864 | 0);
      }
      return S.words[S.length - 1] === 0 && (S.length--, S.words[S.length - 1] === 0 && S.length--), S;
    };
    function Re() {
      fe.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    v(Re, fe);
    function Le() {
      fe.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    v(Le, fe);
    function be() {
      fe.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    v(be, fe), be.prototype.imulK = function(S) {
      for (var E = 0, I = 0; I < S.length; I++) {
        var M = (S.words[I] | 0) * 19 + E, $ = M & 67108863;
        M >>>= 26, S.words[I] = $, E = M;
      }
      return E !== 0 && (S.words[S.length++] = E), S;
    }, p._prime = function(S) {
      if (de[S])
        return de[S];
      var E;
      if (S === "k256")
        E = new Te();
      else if (S === "p224")
        E = new Re();
      else if (S === "p192")
        E = new Le();
      else if (S === "p25519")
        E = new be();
      else
        throw new Error("Unknown prime " + S);
      return de[S] = E, E;
    };
    function q(C) {
      if (typeof C == "string") {
        var S = p._prime(C);
        this.m = S.p, this.prime = S;
      } else
        l(C.gtn(1), "modulus must be greater than 1"), this.m = C, this.prime = null;
    }
    q.prototype._verify1 = function(S) {
      l(S.negative === 0, "red works only with positives"), l(S.red, "red works only with red numbers");
    }, q.prototype._verify2 = function(S, E) {
      l((S.negative | E.negative) === 0, "red works only with positives"), l(
        S.red && S.red === E.red,
        "red works only with red numbers"
      );
    }, q.prototype.imod = function(S) {
      return this.prime ? this.prime.ireduce(S)._forceRed(this) : S.umod(this.m)._forceRed(this);
    }, q.prototype.neg = function(S) {
      return S.isZero() ? S.clone() : this.m.sub(S)._forceRed(this);
    }, q.prototype.add = function(S, E) {
      this._verify2(S, E);
      var I = S.add(E);
      return I.cmp(this.m) >= 0 && I.isub(this.m), I._forceRed(this);
    }, q.prototype.iadd = function(S, E) {
      this._verify2(S, E);
      var I = S.iadd(E);
      return I.cmp(this.m) >= 0 && I.isub(this.m), I;
    }, q.prototype.sub = function(S, E) {
      this._verify2(S, E);
      var I = S.sub(E);
      return I.cmpn(0) < 0 && I.iadd(this.m), I._forceRed(this);
    }, q.prototype.isub = function(S, E) {
      this._verify2(S, E);
      var I = S.isub(E);
      return I.cmpn(0) < 0 && I.iadd(this.m), I;
    }, q.prototype.shl = function(S, E) {
      return this._verify1(S), this.imod(S.ushln(E));
    }, q.prototype.imul = function(S, E) {
      return this._verify2(S, E), this.imod(S.imul(E));
    }, q.prototype.mul = function(S, E) {
      return this._verify2(S, E), this.imod(S.mul(E));
    }, q.prototype.isqr = function(S) {
      return this.imul(S, S.clone());
    }, q.prototype.sqr = function(S) {
      return this.mul(S, S);
    }, q.prototype.sqrt = function(S) {
      if (S.isZero())
        return S.clone();
      var E = this.m.andln(3);
      if (l(E % 2 === 1), E === 3) {
        var I = this.m.add(new p(1)).iushrn(2);
        return this.pow(S, I);
      }
      for (var M = this.m.subn(1), $ = 0; !M.isZero() && M.andln(1) === 0; )
        $++, M.iushrn(1);
      l(!M.isZero());
      var U = new p(1).toRed(this), Y = U.redNeg(), L = this.m.subn(1).iushrn(1), T = this.m.bitLength();
      for (T = new p(2 * T * T).toRed(this); this.pow(T, L).cmp(Y) !== 0; )
        T.redIAdd(Y);
      for (var B = this.pow(T, M), te = this.pow(S, M.addn(1).iushrn(1)), pe = this.pow(S, M), Ie = $; pe.cmp(U) !== 0; ) {
        for (var $e = pe, ve = 0; $e.cmp(U) !== 0; ve++)
          $e = $e.redSqr();
        l(ve < Ie);
        var he = this.pow(B, new p(1).iushln(Ie - ve - 1));
        te = te.redMul(he), B = he.redSqr(), pe = pe.redMul(B), Ie = ve;
      }
      return te;
    }, q.prototype.invm = function(S) {
      var E = S._invmp(this.m);
      return E.negative !== 0 ? (E.negative = 0, this.imod(E).redNeg()) : this.imod(E);
    }, q.prototype.pow = function(S, E) {
      if (E.isZero())
        return new p(1).toRed(this);
      if (E.cmpn(1) === 0)
        return S.clone();
      var I = 4, M = new Array(1 << I);
      M[0] = new p(1).toRed(this), M[1] = S;
      for (var $ = 2; $ < M.length; $++)
        M[$] = this.mul(M[$ - 1], S);
      var U = M[0], Y = 0, L = 0, T = E.bitLength() % 26;
      for (T === 0 && (T = 26), $ = E.length - 1; $ >= 0; $--) {
        for (var B = E.words[$], te = T - 1; te >= 0; te--) {
          var pe = B >> te & 1;
          if (U !== M[0] && (U = this.sqr(U)), pe === 0 && Y === 0) {
            L = 0;
            continue;
          }
          Y <<= 1, Y |= pe, L++, !(L !== I && ($ !== 0 || te !== 0)) && (U = this.mul(U, M[Y]), L = 0, Y = 0);
        }
        T = 26;
      }
      return U;
    }, q.prototype.convertTo = function(S) {
      var E = S.umod(this.m);
      return E === S ? E.clone() : E;
    }, q.prototype.convertFrom = function(S) {
      var E = S.clone();
      return E.red = null, E;
    }, p.mont = function(S) {
      return new J(S);
    };
    function J(C) {
      q.call(this, C), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new p(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    v(J, q), J.prototype.convertTo = function(S) {
      return this.imod(S.ushln(this.shift));
    }, J.prototype.convertFrom = function(S) {
      var E = this.imod(S.mul(this.rinv));
      return E.red = null, E;
    }, J.prototype.imul = function(S, E) {
      if (S.isZero() || E.isZero())
        return S.words[0] = 0, S.length = 1, S;
      var I = S.imul(E), M = I.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), $ = I.isub(M).iushrn(this.shift), U = $;
      return $.cmp(this.m) >= 0 ? U = $.isub(this.m) : $.cmpn(0) < 0 && (U = $.iadd(this.m)), U._forceRed(this);
    }, J.prototype.mul = function(S, E) {
      if (S.isZero() || E.isZero())
        return new p(0)._forceRed(this);
      var I = S.mul(E), M = I.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), $ = I.isub(M).iushrn(this.shift), U = $;
      return $.cmp(this.m) >= 0 ? U = $.isub(this.m) : $.cmpn(0) < 0 && (U = $.iadd(this.m)), U._forceRed(this);
    }, J.prototype.invm = function(S) {
      var E = this.imod(S._invmp(this.m).mul(this.r2));
      return E._forceRed(this);
    };
  })(a, commonjsGlobal$1);
})(bn$3);
var bnExports$3 = bn$3.exports, utils$u = {};
(function(a) {
  var u = a;
  function c(p, _) {
    if (Array.isArray(p))
      return p.slice();
    if (!p)
      return [];
    var k = [];
    if (typeof p != "string") {
      for (var O = 0; O < p.length; O++)
        k[O] = p[O] | 0;
      return k;
    }
    if (_ === "hex") {
      p = p.replace(/[^a-z0-9]+/ig, ""), p.length % 2 !== 0 && (p = "0" + p);
      for (var O = 0; O < p.length; O += 2)
        k.push(parseInt(p[O] + p[O + 1], 16));
    } else
      for (var O = 0; O < p.length; O++) {
        var D = p.charCodeAt(O), F = D >> 8, z = D & 255;
        F ? k.push(F, z) : k.push(z);
      }
    return k;
  }
  u.toArray = c;
  function l(p) {
    return p.length === 1 ? "0" + p : p;
  }
  u.zero2 = l;
  function v(p) {
    for (var _ = "", k = 0; k < p.length; k++)
      _ += l(p[k].toString(16));
    return _;
  }
  u.toHex = v, u.encode = function(_, k) {
    return k === "hex" ? v(_) : _;
  };
})(utils$u);
(function(a) {
  var u = a, c = bnExports$3, l = minimalisticAssert, v = utils$u;
  u.assert = l, u.toArray = v.toArray, u.zero2 = v.zero2, u.toHex = v.toHex, u.encode = v.encode;
  function p(F, z, j) {
    var ee = new Array(Math.max(F.bitLength(), j) + 1);
    ee.fill(0);
    for (var X = 1 << z + 1, ae = F.clone(), Q = 0; Q < ee.length; Q++) {
      var ne, Z = ae.andln(X - 1);
      ae.isOdd() ? (Z > (X >> 1) - 1 ? ne = (X >> 1) - Z : ne = Z, ae.isubn(ne)) : ne = 0, ee[Q] = ne, ae.iushrn(1);
    }
    return ee;
  }
  u.getNAF = p;
  function _(F, z) {
    var j = [
      [],
      []
    ];
    F = F.clone(), z = z.clone();
    for (var ee = 0, X = 0, ae; F.cmpn(-ee) > 0 || z.cmpn(-X) > 0; ) {
      var Q = F.andln(3) + ee & 3, ne = z.andln(3) + X & 3;
      Q === 3 && (Q = -1), ne === 3 && (ne = -1);
      var Z;
      Q & 1 ? (ae = F.andln(7) + ee & 7, (ae === 3 || ae === 5) && ne === 2 ? Z = -Q : Z = Q) : Z = 0, j[0].push(Z);
      var de;
      ne & 1 ? (ae = z.andln(7) + X & 7, (ae === 3 || ae === 5) && Q === 2 ? de = -ne : de = ne) : de = 0, j[1].push(de), 2 * ee === Z + 1 && (ee = 1 - ee), 2 * X === de + 1 && (X = 1 - X), F.iushrn(1), z.iushrn(1);
    }
    return j;
  }
  u.getJSF = _;
  function k(F, z, j) {
    var ee = "_" + z;
    F.prototype[z] = function() {
      return this[ee] !== void 0 ? this[ee] : this[ee] = j.call(this);
    };
  }
  u.cachedProperty = k;
  function O(F) {
    return typeof F == "string" ? u.toArray(F, "hex") : F;
  }
  u.parseBytes = O;
  function D(F) {
    return new c(F, "hex", "le");
  }
  u.intFromLE = D;
})(utils$v);
var curve = {}, BN$9 = bnExports$3, utils$t = utils$v, getNAF = utils$t.getNAF, getJSF = utils$t.getJSF, assert$e = utils$t.assert;
function BaseCurve(a, u) {
  this.type = a, this.p = new BN$9(u.p, 16), this.red = u.prime ? BN$9.red(u.prime) : BN$9.mont(this.p), this.zero = new BN$9(0).toRed(this.red), this.one = new BN$9(1).toRed(this.red), this.two = new BN$9(2).toRed(this.red), this.n = u.n && new BN$9(u.n, 16), this.g = u.g && this.pointFromJSON(u.g, u.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
  var c = this.n && this.p.div(this.n);
  !c || c.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
}
var base$1 = BaseCurve;
BaseCurve.prototype.point = function a() {
  throw new Error("Not implemented");
};
BaseCurve.prototype.validate = function a() {
  throw new Error("Not implemented");
};
BaseCurve.prototype._fixedNafMul = function a(u, c) {
  assert$e(u.precomputed);
  var l = u._getDoubles(), v = getNAF(c, 1, this._bitLength), p = (1 << l.step + 1) - (l.step % 2 === 0 ? 2 : 1);
  p /= 3;
  var _ = [], k, O;
  for (k = 0; k < v.length; k += l.step) {
    O = 0;
    for (var D = k + l.step - 1; D >= k; D--)
      O = (O << 1) + v[D];
    _.push(O);
  }
  for (var F = this.jpoint(null, null, null), z = this.jpoint(null, null, null), j = p; j > 0; j--) {
    for (k = 0; k < _.length; k++)
      O = _[k], O === j ? z = z.mixedAdd(l.points[k]) : O === -j && (z = z.mixedAdd(l.points[k].neg()));
    F = F.add(z);
  }
  return F.toP();
};
BaseCurve.prototype._wnafMul = function a(u, c) {
  var l = 4, v = u._getNAFPoints(l);
  l = v.wnd;
  for (var p = v.points, _ = getNAF(c, l, this._bitLength), k = this.jpoint(null, null, null), O = _.length - 1; O >= 0; O--) {
    for (var D = 0; O >= 0 && _[O] === 0; O--)
      D++;
    if (O >= 0 && D++, k = k.dblp(D), O < 0)
      break;
    var F = _[O];
    assert$e(F !== 0), u.type === "affine" ? F > 0 ? k = k.mixedAdd(p[F - 1 >> 1]) : k = k.mixedAdd(p[-F - 1 >> 1].neg()) : F > 0 ? k = k.add(p[F - 1 >> 1]) : k = k.add(p[-F - 1 >> 1].neg());
  }
  return u.type === "affine" ? k.toP() : k;
};
BaseCurve.prototype._wnafMulAdd = function a(u, c, l, v, p) {
  var _ = this._wnafT1, k = this._wnafT2, O = this._wnafT3, D = 0, F, z, j;
  for (F = 0; F < v; F++) {
    j = c[F];
    var ee = j._getNAFPoints(u);
    _[F] = ee.wnd, k[F] = ee.points;
  }
  for (F = v - 1; F >= 1; F -= 2) {
    var X = F - 1, ae = F;
    if (_[X] !== 1 || _[ae] !== 1) {
      O[X] = getNAF(l[X], _[X], this._bitLength), O[ae] = getNAF(l[ae], _[ae], this._bitLength), D = Math.max(O[X].length, D), D = Math.max(O[ae].length, D);
      continue;
    }
    var Q = [
      c[X],
      /* 1 */
      null,
      /* 3 */
      null,
      /* 5 */
      c[ae]
      /* 7 */
    ];
    c[X].y.cmp(c[ae].y) === 0 ? (Q[1] = c[X].add(c[ae]), Q[2] = c[X].toJ().mixedAdd(c[ae].neg())) : c[X].y.cmp(c[ae].y.redNeg()) === 0 ? (Q[1] = c[X].toJ().mixedAdd(c[ae]), Q[2] = c[X].add(c[ae].neg())) : (Q[1] = c[X].toJ().mixedAdd(c[ae]), Q[2] = c[X].toJ().mixedAdd(c[ae].neg()));
    var ne = [
      -3,
      /* -1 -1 */
      -1,
      /* -1 0 */
      -5,
      /* -1 1 */
      -7,
      /* 0 -1 */
      0,
      /* 0 0 */
      7,
      /* 0 1 */
      5,
      /* 1 -1 */
      1,
      /* 1 0 */
      3
      /* 1 1 */
    ], Z = getJSF(l[X], l[ae]);
    for (D = Math.max(Z[0].length, D), O[X] = new Array(D), O[ae] = new Array(D), z = 0; z < D; z++) {
      var de = Z[0][z] | 0, fe = Z[1][z] | 0;
      O[X][z] = ne[(de + 1) * 3 + (fe + 1)], O[ae][z] = 0, k[X] = Q;
    }
  }
  var Te = this.jpoint(null, null, null), Re = this._wnafT4;
  for (F = D; F >= 0; F--) {
    for (var Le = 0; F >= 0; ) {
      var be = !0;
      for (z = 0; z < v; z++)
        Re[z] = O[z][F] | 0, Re[z] !== 0 && (be = !1);
      if (!be)
        break;
      Le++, F--;
    }
    if (F >= 0 && Le++, Te = Te.dblp(Le), F < 0)
      break;
    for (z = 0; z < v; z++) {
      var q = Re[z];
      q !== 0 && (q > 0 ? j = k[z][q - 1 >> 1] : q < 0 && (j = k[z][-q - 1 >> 1].neg()), j.type === "affine" ? Te = Te.mixedAdd(j) : Te = Te.add(j));
    }
  }
  for (F = 0; F < v; F++)
    k[F] = null;
  return p ? Te : Te.toP();
};
function BasePoint(a, u) {
  this.curve = a, this.type = u, this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;
BasePoint.prototype.eq = function a() {
  throw new Error("Not implemented");
};
BasePoint.prototype.validate = function a() {
  return this.curve.validate(this);
};
BaseCurve.prototype.decodePoint = function a(u, c) {
  u = utils$t.toArray(u, c);
  var l = this.p.byteLength();
  if ((u[0] === 4 || u[0] === 6 || u[0] === 7) && u.length - 1 === 2 * l) {
    u[0] === 6 ? assert$e(u[u.length - 1] % 2 === 0) : u[0] === 7 && assert$e(u[u.length - 1] % 2 === 1);
    var v = this.point(
      u.slice(1, 1 + l),
      u.slice(1 + l, 1 + 2 * l)
    );
    return v;
  } else if ((u[0] === 2 || u[0] === 3) && u.length - 1 === l)
    return this.pointFromX(u.slice(1, 1 + l), u[0] === 3);
  throw new Error("Unknown point format");
};
BasePoint.prototype.encodeCompressed = function a(u) {
  return this.encode(u, !0);
};
BasePoint.prototype._encode = function a(u) {
  var c = this.curve.p.byteLength(), l = this.getX().toArray("be", c);
  return u ? [this.getY().isEven() ? 2 : 3].concat(l) : [4].concat(l, this.getY().toArray("be", c));
};
BasePoint.prototype.encode = function a(u, c) {
  return utils$t.encode(this._encode(c), u);
};
BasePoint.prototype.precompute = function a(u) {
  if (this.precomputed)
    return this;
  var c = {
    doubles: null,
    naf: null,
    beta: null
  };
  return c.naf = this._getNAFPoints(8), c.doubles = this._getDoubles(4, u), c.beta = this._getBeta(), this.precomputed = c, this;
};
BasePoint.prototype._hasDoubles = function a(u) {
  if (!this.precomputed)
    return !1;
  var c = this.precomputed.doubles;
  return c ? c.points.length >= Math.ceil((u.bitLength() + 1) / c.step) : !1;
};
BasePoint.prototype._getDoubles = function a(u, c) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  for (var l = [this], v = this, p = 0; p < c; p += u) {
    for (var _ = 0; _ < u; _++)
      v = v.dbl();
    l.push(v);
  }
  return {
    step: u,
    points: l
  };
};
BasePoint.prototype._getNAFPoints = function a(u) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  for (var c = [this], l = (1 << u) - 1, v = l === 1 ? null : this.dbl(), p = 1; p < l; p++)
    c[p] = c[p - 1].add(v);
  return {
    wnd: u,
    points: c
  };
};
BasePoint.prototype._getBeta = function a() {
  return null;
};
BasePoint.prototype.dblp = function a(u) {
  for (var c = this, l = 0; l < u; l++)
    c = c.dbl();
  return c;
};
var utils$s = utils$v, BN$8 = bnExports$3, inherits$9 = inherits_browserExports, Base$2 = base$1, assert$d = utils$s.assert;
function ShortCurve(a) {
  Base$2.call(this, "short", a), this.a = new BN$8(a.a, 16).toRed(this.red), this.b = new BN$8(a.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(a), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
}
inherits$9(ShortCurve, Base$2);
var short = ShortCurve;
ShortCurve.prototype._getEndomorphism = function a(u) {
  if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
    var c, l;
    if (u.beta)
      c = new BN$8(u.beta, 16).toRed(this.red);
    else {
      var v = this._getEndoRoots(this.p);
      c = v[0].cmp(v[1]) < 0 ? v[0] : v[1], c = c.toRed(this.red);
    }
    if (u.lambda)
      l = new BN$8(u.lambda, 16);
    else {
      var p = this._getEndoRoots(this.n);
      this.g.mul(p[0]).x.cmp(this.g.x.redMul(c)) === 0 ? l = p[0] : (l = p[1], assert$d(this.g.mul(l).x.cmp(this.g.x.redMul(c)) === 0));
    }
    var _;
    return u.basis ? _ = u.basis.map(function(k) {
      return {
        a: new BN$8(k.a, 16),
        b: new BN$8(k.b, 16)
      };
    }) : _ = this._getEndoBasis(l), {
      beta: c,
      lambda: l,
      basis: _
    };
  }
};
ShortCurve.prototype._getEndoRoots = function a(u) {
  var c = u === this.p ? this.red : BN$8.mont(u), l = new BN$8(2).toRed(c).redInvm(), v = l.redNeg(), p = new BN$8(3).toRed(c).redNeg().redSqrt().redMul(l), _ = v.redAdd(p).fromRed(), k = v.redSub(p).fromRed();
  return [_, k];
};
ShortCurve.prototype._getEndoBasis = function a(u) {
  for (var c = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), l = u, v = this.n.clone(), p = new BN$8(1), _ = new BN$8(0), k = new BN$8(0), O = new BN$8(1), D, F, z, j, ee, X, ae, Q = 0, ne, Z; l.cmpn(0) !== 0; ) {
    var de = v.div(l);
    ne = v.sub(de.mul(l)), Z = k.sub(de.mul(p));
    var fe = O.sub(de.mul(_));
    if (!z && ne.cmp(c) < 0)
      D = ae.neg(), F = p, z = ne.neg(), j = Z;
    else if (z && ++Q === 2)
      break;
    ae = ne, v = l, l = ne, k = p, p = Z, O = _, _ = fe;
  }
  ee = ne.neg(), X = Z;
  var Te = z.sqr().add(j.sqr()), Re = ee.sqr().add(X.sqr());
  return Re.cmp(Te) >= 0 && (ee = D, X = F), z.negative && (z = z.neg(), j = j.neg()), ee.negative && (ee = ee.neg(), X = X.neg()), [
    { a: z, b: j },
    { a: ee, b: X }
  ];
};
ShortCurve.prototype._endoSplit = function a(u) {
  var c = this.endo.basis, l = c[0], v = c[1], p = v.b.mul(u).divRound(this.n), _ = l.b.neg().mul(u).divRound(this.n), k = p.mul(l.a), O = _.mul(v.a), D = p.mul(l.b), F = _.mul(v.b), z = u.sub(k).sub(O), j = D.add(F).neg();
  return { k1: z, k2: j };
};
ShortCurve.prototype.pointFromX = function a(u, c) {
  u = new BN$8(u, 16), u.red || (u = u.toRed(this.red));
  var l = u.redSqr().redMul(u).redIAdd(u.redMul(this.a)).redIAdd(this.b), v = l.redSqrt();
  if (v.redSqr().redSub(l).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var p = v.fromRed().isOdd();
  return (c && !p || !c && p) && (v = v.redNeg()), this.point(u, v);
};
ShortCurve.prototype.validate = function a(u) {
  if (u.inf)
    return !0;
  var c = u.x, l = u.y, v = this.a.redMul(c), p = c.redSqr().redMul(c).redIAdd(v).redIAdd(this.b);
  return l.redSqr().redISub(p).cmpn(0) === 0;
};
ShortCurve.prototype._endoWnafMulAdd = function a(u, c, l) {
  for (var v = this._endoWnafT1, p = this._endoWnafT2, _ = 0; _ < u.length; _++) {
    var k = this._endoSplit(c[_]), O = u[_], D = O._getBeta();
    k.k1.negative && (k.k1.ineg(), O = O.neg(!0)), k.k2.negative && (k.k2.ineg(), D = D.neg(!0)), v[_ * 2] = O, v[_ * 2 + 1] = D, p[_ * 2] = k.k1, p[_ * 2 + 1] = k.k2;
  }
  for (var F = this._wnafMulAdd(1, v, p, _ * 2, l), z = 0; z < _ * 2; z++)
    v[z] = null, p[z] = null;
  return F;
};
function Point$2(a, u, c, l) {
  Base$2.BasePoint.call(this, a, "affine"), u === null && c === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new BN$8(u, 16), this.y = new BN$8(c, 16), l && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
}
inherits$9(Point$2, Base$2.BasePoint);
ShortCurve.prototype.point = function a(u, c, l) {
  return new Point$2(this, u, c, l);
};
ShortCurve.prototype.pointFromJSON = function a(u, c) {
  return Point$2.fromJSON(this, u, c);
};
Point$2.prototype._getBeta = function a() {
  if (this.curve.endo) {
    var u = this.precomputed;
    if (u && u.beta)
      return u.beta;
    var c = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (u) {
      var l = this.curve, v = function(p) {
        return l.point(p.x.redMul(l.endo.beta), p.y);
      };
      u.beta = c, c.precomputed = {
        beta: null,
        naf: u.naf && {
          wnd: u.naf.wnd,
          points: u.naf.points.map(v)
        },
        doubles: u.doubles && {
          step: u.doubles.step,
          points: u.doubles.points.map(v)
        }
      };
    }
    return c;
  }
};
Point$2.prototype.toJSON = function a() {
  return this.precomputed ? [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }] : [this.x, this.y];
};
Point$2.fromJSON = function a(u, c, l) {
  typeof c == "string" && (c = JSON.parse(c));
  var v = u.point(c[0], c[1], l);
  if (!c[2])
    return v;
  function p(k) {
    return u.point(k[0], k[1], l);
  }
  var _ = c[2];
  return v.precomputed = {
    beta: null,
    doubles: _.doubles && {
      step: _.doubles.step,
      points: [v].concat(_.doubles.points.map(p))
    },
    naf: _.naf && {
      wnd: _.naf.wnd,
      points: [v].concat(_.naf.points.map(p))
    }
  }, v;
};
Point$2.prototype.inspect = function a() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
Point$2.prototype.isInfinity = function a() {
  return this.inf;
};
Point$2.prototype.add = function a(u) {
  if (this.inf)
    return u;
  if (u.inf)
    return this;
  if (this.eq(u))
    return this.dbl();
  if (this.neg().eq(u))
    return this.curve.point(null, null);
  if (this.x.cmp(u.x) === 0)
    return this.curve.point(null, null);
  var c = this.y.redSub(u.y);
  c.cmpn(0) !== 0 && (c = c.redMul(this.x.redSub(u.x).redInvm()));
  var l = c.redSqr().redISub(this.x).redISub(u.x), v = c.redMul(this.x.redSub(l)).redISub(this.y);
  return this.curve.point(l, v);
};
Point$2.prototype.dbl = function a() {
  if (this.inf)
    return this;
  var u = this.y.redAdd(this.y);
  if (u.cmpn(0) === 0)
    return this.curve.point(null, null);
  var c = this.curve.a, l = this.x.redSqr(), v = u.redInvm(), p = l.redAdd(l).redIAdd(l).redIAdd(c).redMul(v), _ = p.redSqr().redISub(this.x.redAdd(this.x)), k = p.redMul(this.x.redSub(_)).redISub(this.y);
  return this.curve.point(_, k);
};
Point$2.prototype.getX = function a() {
  return this.x.fromRed();
};
Point$2.prototype.getY = function a() {
  return this.y.fromRed();
};
Point$2.prototype.mul = function a(u) {
  return u = new BN$8(u, 16), this.isInfinity() ? this : this._hasDoubles(u) ? this.curve._fixedNafMul(this, u) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [u]) : this.curve._wnafMul(this, u);
};
Point$2.prototype.mulAdd = function a(u, c, l) {
  var v = [this, c], p = [u, l];
  return this.curve.endo ? this.curve._endoWnafMulAdd(v, p) : this.curve._wnafMulAdd(1, v, p, 2);
};
Point$2.prototype.jmulAdd = function a(u, c, l) {
  var v = [this, c], p = [u, l];
  return this.curve.endo ? this.curve._endoWnafMulAdd(v, p, !0) : this.curve._wnafMulAdd(1, v, p, 2, !0);
};
Point$2.prototype.eq = function a(u) {
  return this === u || this.inf === u.inf && (this.inf || this.x.cmp(u.x) === 0 && this.y.cmp(u.y) === 0);
};
Point$2.prototype.neg = function a(u) {
  if (this.inf)
    return this;
  var c = this.curve.point(this.x, this.y.redNeg());
  if (u && this.precomputed) {
    var l = this.precomputed, v = function(p) {
      return p.neg();
    };
    c.precomputed = {
      naf: l.naf && {
        wnd: l.naf.wnd,
        points: l.naf.points.map(v)
      },
      doubles: l.doubles && {
        step: l.doubles.step,
        points: l.doubles.points.map(v)
      }
    };
  }
  return c;
};
Point$2.prototype.toJ = function a() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var u = this.curve.jpoint(this.x, this.y, this.curve.one);
  return u;
};
function JPoint(a, u, c, l) {
  Base$2.BasePoint.call(this, a, "jacobian"), u === null && c === null && l === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new BN$8(0)) : (this.x = new BN$8(u, 16), this.y = new BN$8(c, 16), this.z = new BN$8(l, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
}
inherits$9(JPoint, Base$2.BasePoint);
ShortCurve.prototype.jpoint = function a(u, c, l) {
  return new JPoint(this, u, c, l);
};
JPoint.prototype.toP = function a() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var u = this.z.redInvm(), c = u.redSqr(), l = this.x.redMul(c), v = this.y.redMul(c).redMul(u);
  return this.curve.point(l, v);
};
JPoint.prototype.neg = function a() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
JPoint.prototype.add = function a(u) {
  if (this.isInfinity())
    return u;
  if (u.isInfinity())
    return this;
  var c = u.z.redSqr(), l = this.z.redSqr(), v = this.x.redMul(c), p = u.x.redMul(l), _ = this.y.redMul(c.redMul(u.z)), k = u.y.redMul(l.redMul(this.z)), O = v.redSub(p), D = _.redSub(k);
  if (O.cmpn(0) === 0)
    return D.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var F = O.redSqr(), z = F.redMul(O), j = v.redMul(F), ee = D.redSqr().redIAdd(z).redISub(j).redISub(j), X = D.redMul(j.redISub(ee)).redISub(_.redMul(z)), ae = this.z.redMul(u.z).redMul(O);
  return this.curve.jpoint(ee, X, ae);
};
JPoint.prototype.mixedAdd = function a(u) {
  if (this.isInfinity())
    return u.toJ();
  if (u.isInfinity())
    return this;
  var c = this.z.redSqr(), l = this.x, v = u.x.redMul(c), p = this.y, _ = u.y.redMul(c).redMul(this.z), k = l.redSub(v), O = p.redSub(_);
  if (k.cmpn(0) === 0)
    return O.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var D = k.redSqr(), F = D.redMul(k), z = l.redMul(D), j = O.redSqr().redIAdd(F).redISub(z).redISub(z), ee = O.redMul(z.redISub(j)).redISub(p.redMul(F)), X = this.z.redMul(k);
  return this.curve.jpoint(j, ee, X);
};
JPoint.prototype.dblp = function a(u) {
  if (u === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!u)
    return this.dbl();
  var c;
  if (this.curve.zeroA || this.curve.threeA) {
    var l = this;
    for (c = 0; c < u; c++)
      l = l.dbl();
    return l;
  }
  var v = this.curve.a, p = this.curve.tinv, _ = this.x, k = this.y, O = this.z, D = O.redSqr().redSqr(), F = k.redAdd(k);
  for (c = 0; c < u; c++) {
    var z = _.redSqr(), j = F.redSqr(), ee = j.redSqr(), X = z.redAdd(z).redIAdd(z).redIAdd(v.redMul(D)), ae = _.redMul(j), Q = X.redSqr().redISub(ae.redAdd(ae)), ne = ae.redISub(Q), Z = X.redMul(ne);
    Z = Z.redIAdd(Z).redISub(ee);
    var de = F.redMul(O);
    c + 1 < u && (D = D.redMul(ee)), _ = Q, O = de, F = Z;
  }
  return this.curve.jpoint(_, F.redMul(p), O);
};
JPoint.prototype.dbl = function a() {
  return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
};
JPoint.prototype._zeroDbl = function a() {
  var u, c, l;
  if (this.zOne) {
    var v = this.x.redSqr(), p = this.y.redSqr(), _ = p.redSqr(), k = this.x.redAdd(p).redSqr().redISub(v).redISub(_);
    k = k.redIAdd(k);
    var O = v.redAdd(v).redIAdd(v), D = O.redSqr().redISub(k).redISub(k), F = _.redIAdd(_);
    F = F.redIAdd(F), F = F.redIAdd(F), u = D, c = O.redMul(k.redISub(D)).redISub(F), l = this.y.redAdd(this.y);
  } else {
    var z = this.x.redSqr(), j = this.y.redSqr(), ee = j.redSqr(), X = this.x.redAdd(j).redSqr().redISub(z).redISub(ee);
    X = X.redIAdd(X);
    var ae = z.redAdd(z).redIAdd(z), Q = ae.redSqr(), ne = ee.redIAdd(ee);
    ne = ne.redIAdd(ne), ne = ne.redIAdd(ne), u = Q.redISub(X).redISub(X), c = ae.redMul(X.redISub(u)).redISub(ne), l = this.y.redMul(this.z), l = l.redIAdd(l);
  }
  return this.curve.jpoint(u, c, l);
};
JPoint.prototype._threeDbl = function a() {
  var u, c, l;
  if (this.zOne) {
    var v = this.x.redSqr(), p = this.y.redSqr(), _ = p.redSqr(), k = this.x.redAdd(p).redSqr().redISub(v).redISub(_);
    k = k.redIAdd(k);
    var O = v.redAdd(v).redIAdd(v).redIAdd(this.curve.a), D = O.redSqr().redISub(k).redISub(k);
    u = D;
    var F = _.redIAdd(_);
    F = F.redIAdd(F), F = F.redIAdd(F), c = O.redMul(k.redISub(D)).redISub(F), l = this.y.redAdd(this.y);
  } else {
    var z = this.z.redSqr(), j = this.y.redSqr(), ee = this.x.redMul(j), X = this.x.redSub(z).redMul(this.x.redAdd(z));
    X = X.redAdd(X).redIAdd(X);
    var ae = ee.redIAdd(ee);
    ae = ae.redIAdd(ae);
    var Q = ae.redAdd(ae);
    u = X.redSqr().redISub(Q), l = this.y.redAdd(this.z).redSqr().redISub(j).redISub(z);
    var ne = j.redSqr();
    ne = ne.redIAdd(ne), ne = ne.redIAdd(ne), ne = ne.redIAdd(ne), c = X.redMul(ae.redISub(u)).redISub(ne);
  }
  return this.curve.jpoint(u, c, l);
};
JPoint.prototype._dbl = function a() {
  var u = this.curve.a, c = this.x, l = this.y, v = this.z, p = v.redSqr().redSqr(), _ = c.redSqr(), k = l.redSqr(), O = _.redAdd(_).redIAdd(_).redIAdd(u.redMul(p)), D = c.redAdd(c);
  D = D.redIAdd(D);
  var F = D.redMul(k), z = O.redSqr().redISub(F.redAdd(F)), j = F.redISub(z), ee = k.redSqr();
  ee = ee.redIAdd(ee), ee = ee.redIAdd(ee), ee = ee.redIAdd(ee);
  var X = O.redMul(j).redISub(ee), ae = l.redAdd(l).redMul(v);
  return this.curve.jpoint(z, X, ae);
};
JPoint.prototype.trpl = function a() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var u = this.x.redSqr(), c = this.y.redSqr(), l = this.z.redSqr(), v = c.redSqr(), p = u.redAdd(u).redIAdd(u), _ = p.redSqr(), k = this.x.redAdd(c).redSqr().redISub(u).redISub(v);
  k = k.redIAdd(k), k = k.redAdd(k).redIAdd(k), k = k.redISub(_);
  var O = k.redSqr(), D = v.redIAdd(v);
  D = D.redIAdd(D), D = D.redIAdd(D), D = D.redIAdd(D);
  var F = p.redIAdd(k).redSqr().redISub(_).redISub(O).redISub(D), z = c.redMul(F);
  z = z.redIAdd(z), z = z.redIAdd(z);
  var j = this.x.redMul(O).redISub(z);
  j = j.redIAdd(j), j = j.redIAdd(j);
  var ee = this.y.redMul(F.redMul(D.redISub(F)).redISub(k.redMul(O)));
  ee = ee.redIAdd(ee), ee = ee.redIAdd(ee), ee = ee.redIAdd(ee);
  var X = this.z.redAdd(k).redSqr().redISub(l).redISub(O);
  return this.curve.jpoint(j, ee, X);
};
JPoint.prototype.mul = function a(u, c) {
  return u = new BN$8(u, c), this.curve._wnafMul(this, u);
};
JPoint.prototype.eq = function a(u) {
  if (u.type === "affine")
    return this.eq(u.toJ());
  if (this === u)
    return !0;
  var c = this.z.redSqr(), l = u.z.redSqr();
  if (this.x.redMul(l).redISub(u.x.redMul(c)).cmpn(0) !== 0)
    return !1;
  var v = c.redMul(this.z), p = l.redMul(u.z);
  return this.y.redMul(p).redISub(u.y.redMul(v)).cmpn(0) === 0;
};
JPoint.prototype.eqXToP = function a(u) {
  var c = this.z.redSqr(), l = u.toRed(this.curve.red).redMul(c);
  if (this.x.cmp(l) === 0)
    return !0;
  for (var v = u.clone(), p = this.curve.redN.redMul(c); ; ) {
    if (v.iadd(this.curve.n), v.cmp(this.curve.p) >= 0)
      return !1;
    if (l.redIAdd(p), this.x.cmp(l) === 0)
      return !0;
  }
};
JPoint.prototype.inspect = function a() {
  return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
JPoint.prototype.isInfinity = function a() {
  return this.z.cmpn(0) === 0;
};
var BN$7 = bnExports$3, inherits$8 = inherits_browserExports, Base$1 = base$1, utils$r = utils$v;
function MontCurve(a) {
  Base$1.call(this, "mont", a), this.a = new BN$7(a.a, 16).toRed(this.red), this.b = new BN$7(a.b, 16).toRed(this.red), this.i4 = new BN$7(4).toRed(this.red).redInvm(), this.two = new BN$7(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
inherits$8(MontCurve, Base$1);
var mont = MontCurve;
MontCurve.prototype.validate = function a(u) {
  var c = u.normalize().x, l = c.redSqr(), v = l.redMul(c).redAdd(l.redMul(this.a)).redAdd(c), p = v.redSqrt();
  return p.redSqr().cmp(v) === 0;
};
function Point$1(a, u, c) {
  Base$1.BasePoint.call(this, a, "projective"), u === null && c === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new BN$7(u, 16), this.z = new BN$7(c, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
}
inherits$8(Point$1, Base$1.BasePoint);
MontCurve.prototype.decodePoint = function a(u, c) {
  return this.point(utils$r.toArray(u, c), 1);
};
MontCurve.prototype.point = function a(u, c) {
  return new Point$1(this, u, c);
};
MontCurve.prototype.pointFromJSON = function a(u) {
  return Point$1.fromJSON(this, u);
};
Point$1.prototype.precompute = function a() {
};
Point$1.prototype._encode = function a() {
  return this.getX().toArray("be", this.curve.p.byteLength());
};
Point$1.fromJSON = function a(u, c) {
  return new Point$1(u, c[0], c[1] || u.one);
};
Point$1.prototype.inspect = function a() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
Point$1.prototype.isInfinity = function a() {
  return this.z.cmpn(0) === 0;
};
Point$1.prototype.dbl = function a() {
  var u = this.x.redAdd(this.z), c = u.redSqr(), l = this.x.redSub(this.z), v = l.redSqr(), p = c.redSub(v), _ = c.redMul(v), k = p.redMul(v.redAdd(this.curve.a24.redMul(p)));
  return this.curve.point(_, k);
};
Point$1.prototype.add = function a() {
  throw new Error("Not supported on Montgomery curve");
};
Point$1.prototype.diffAdd = function a(u, c) {
  var l = this.x.redAdd(this.z), v = this.x.redSub(this.z), p = u.x.redAdd(u.z), _ = u.x.redSub(u.z), k = _.redMul(l), O = p.redMul(v), D = c.z.redMul(k.redAdd(O).redSqr()), F = c.x.redMul(k.redISub(O).redSqr());
  return this.curve.point(D, F);
};
Point$1.prototype.mul = function a(u) {
  for (var c = u.clone(), l = this, v = this.curve.point(null, null), p = this, _ = []; c.cmpn(0) !== 0; c.iushrn(1))
    _.push(c.andln(1));
  for (var k = _.length - 1; k >= 0; k--)
    _[k] === 0 ? (l = l.diffAdd(v, p), v = v.dbl()) : (v = l.diffAdd(v, p), l = l.dbl());
  return v;
};
Point$1.prototype.mulAdd = function a() {
  throw new Error("Not supported on Montgomery curve");
};
Point$1.prototype.jumlAdd = function a() {
  throw new Error("Not supported on Montgomery curve");
};
Point$1.prototype.eq = function a(u) {
  return this.getX().cmp(u.getX()) === 0;
};
Point$1.prototype.normalize = function a() {
  return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
};
Point$1.prototype.getX = function a() {
  return this.normalize(), this.x.fromRed();
};
var utils$q = utils$v, BN$6 = bnExports$3, inherits$7 = inherits_browserExports, Base = base$1, assert$c = utils$q.assert;
function EdwardsCurve(a) {
  this.twisted = (a.a | 0) !== 1, this.mOneA = this.twisted && (a.a | 0) === -1, this.extended = this.mOneA, Base.call(this, "edwards", a), this.a = new BN$6(a.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new BN$6(a.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new BN$6(a.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), assert$c(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (a.c | 0) === 1;
}
inherits$7(EdwardsCurve, Base);
var edwards = EdwardsCurve;
EdwardsCurve.prototype._mulA = function a(u) {
  return this.mOneA ? u.redNeg() : this.a.redMul(u);
};
EdwardsCurve.prototype._mulC = function a(u) {
  return this.oneC ? u : this.c.redMul(u);
};
EdwardsCurve.prototype.jpoint = function a(u, c, l, v) {
  return this.point(u, c, l, v);
};
EdwardsCurve.prototype.pointFromX = function a(u, c) {
  u = new BN$6(u, 16), u.red || (u = u.toRed(this.red));
  var l = u.redSqr(), v = this.c2.redSub(this.a.redMul(l)), p = this.one.redSub(this.c2.redMul(this.d).redMul(l)), _ = v.redMul(p.redInvm()), k = _.redSqrt();
  if (k.redSqr().redSub(_).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var O = k.fromRed().isOdd();
  return (c && !O || !c && O) && (k = k.redNeg()), this.point(u, k);
};
EdwardsCurve.prototype.pointFromY = function a(u, c) {
  u = new BN$6(u, 16), u.red || (u = u.toRed(this.red));
  var l = u.redSqr(), v = l.redSub(this.c2), p = l.redMul(this.d).redMul(this.c2).redSub(this.a), _ = v.redMul(p.redInvm());
  if (_.cmp(this.zero) === 0) {
    if (c)
      throw new Error("invalid point");
    return this.point(this.zero, u);
  }
  var k = _.redSqrt();
  if (k.redSqr().redSub(_).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  return k.fromRed().isOdd() !== c && (k = k.redNeg()), this.point(k, u);
};
EdwardsCurve.prototype.validate = function a(u) {
  if (u.isInfinity())
    return !0;
  u.normalize();
  var c = u.x.redSqr(), l = u.y.redSqr(), v = c.redMul(this.a).redAdd(l), p = this.c2.redMul(this.one.redAdd(this.d.redMul(c).redMul(l)));
  return v.cmp(p) === 0;
};
function Point(a, u, c, l, v) {
  Base.BasePoint.call(this, a, "projective"), u === null && c === null && l === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new BN$6(u, 16), this.y = new BN$6(c, 16), this.z = l ? new BN$6(l, 16) : this.curve.one, this.t = v && new BN$6(v, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
}
inherits$7(Point, Base.BasePoint);
EdwardsCurve.prototype.pointFromJSON = function a(u) {
  return Point.fromJSON(this, u);
};
EdwardsCurve.prototype.point = function a(u, c, l, v) {
  return new Point(this, u, c, l, v);
};
Point.fromJSON = function a(u, c) {
  return new Point(u, c[0], c[1], c[2]);
};
Point.prototype.inspect = function a() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
Point.prototype.isInfinity = function a() {
  return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
};
Point.prototype._extDbl = function a() {
  var u = this.x.redSqr(), c = this.y.redSqr(), l = this.z.redSqr();
  l = l.redIAdd(l);
  var v = this.curve._mulA(u), p = this.x.redAdd(this.y).redSqr().redISub(u).redISub(c), _ = v.redAdd(c), k = _.redSub(l), O = v.redSub(c), D = p.redMul(k), F = _.redMul(O), z = p.redMul(O), j = k.redMul(_);
  return this.curve.point(D, F, j, z);
};
Point.prototype._projDbl = function a() {
  var u = this.x.redAdd(this.y).redSqr(), c = this.x.redSqr(), l = this.y.redSqr(), v, p, _, k, O, D;
  if (this.curve.twisted) {
    k = this.curve._mulA(c);
    var F = k.redAdd(l);
    this.zOne ? (v = u.redSub(c).redSub(l).redMul(F.redSub(this.curve.two)), p = F.redMul(k.redSub(l)), _ = F.redSqr().redSub(F).redSub(F)) : (O = this.z.redSqr(), D = F.redSub(O).redISub(O), v = u.redSub(c).redISub(l).redMul(D), p = F.redMul(k.redSub(l)), _ = F.redMul(D));
  } else
    k = c.redAdd(l), O = this.curve._mulC(this.z).redSqr(), D = k.redSub(O).redSub(O), v = this.curve._mulC(u.redISub(k)).redMul(D), p = this.curve._mulC(k).redMul(c.redISub(l)), _ = k.redMul(D);
  return this.curve.point(v, p, _);
};
Point.prototype.dbl = function a() {
  return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
};
Point.prototype._extAdd = function a(u) {
  var c = this.y.redSub(this.x).redMul(u.y.redSub(u.x)), l = this.y.redAdd(this.x).redMul(u.y.redAdd(u.x)), v = this.t.redMul(this.curve.dd).redMul(u.t), p = this.z.redMul(u.z.redAdd(u.z)), _ = l.redSub(c), k = p.redSub(v), O = p.redAdd(v), D = l.redAdd(c), F = _.redMul(k), z = O.redMul(D), j = _.redMul(D), ee = k.redMul(O);
  return this.curve.point(F, z, ee, j);
};
Point.prototype._projAdd = function a(u) {
  var c = this.z.redMul(u.z), l = c.redSqr(), v = this.x.redMul(u.x), p = this.y.redMul(u.y), _ = this.curve.d.redMul(v).redMul(p), k = l.redSub(_), O = l.redAdd(_), D = this.x.redAdd(this.y).redMul(u.x.redAdd(u.y)).redISub(v).redISub(p), F = c.redMul(k).redMul(D), z, j;
  return this.curve.twisted ? (z = c.redMul(O).redMul(p.redSub(this.curve._mulA(v))), j = k.redMul(O)) : (z = c.redMul(O).redMul(p.redSub(v)), j = this.curve._mulC(k).redMul(O)), this.curve.point(F, z, j);
};
Point.prototype.add = function a(u) {
  return this.isInfinity() ? u : u.isInfinity() ? this : this.curve.extended ? this._extAdd(u) : this._projAdd(u);
};
Point.prototype.mul = function a(u) {
  return this._hasDoubles(u) ? this.curve._fixedNafMul(this, u) : this.curve._wnafMul(this, u);
};
Point.prototype.mulAdd = function a(u, c, l) {
  return this.curve._wnafMulAdd(1, [this, c], [u, l], 2, !1);
};
Point.prototype.jmulAdd = function a(u, c, l) {
  return this.curve._wnafMulAdd(1, [this, c], [u, l], 2, !0);
};
Point.prototype.normalize = function a() {
  if (this.zOne)
    return this;
  var u = this.z.redInvm();
  return this.x = this.x.redMul(u), this.y = this.y.redMul(u), this.t && (this.t = this.t.redMul(u)), this.z = this.curve.one, this.zOne = !0, this;
};
Point.prototype.neg = function a() {
  return this.curve.point(
    this.x.redNeg(),
    this.y,
    this.z,
    this.t && this.t.redNeg()
  );
};
Point.prototype.getX = function a() {
  return this.normalize(), this.x.fromRed();
};
Point.prototype.getY = function a() {
  return this.normalize(), this.y.fromRed();
};
Point.prototype.eq = function a(u) {
  return this === u || this.getX().cmp(u.getX()) === 0 && this.getY().cmp(u.getY()) === 0;
};
Point.prototype.eqXToP = function a(u) {
  var c = u.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(c) === 0)
    return !0;
  for (var l = u.clone(), v = this.curve.redN.redMul(this.z); ; ) {
    if (l.iadd(this.curve.n), l.cmp(this.curve.p) >= 0)
      return !1;
    if (c.redIAdd(v), this.x.cmp(c) === 0)
      return !0;
  }
};
Point.prototype.toP = Point.prototype.normalize;
Point.prototype.mixedAdd = Point.prototype.add;
(function(a) {
  var u = a;
  u.base = base$1, u.short = short, u.mont = mont, u.edwards = edwards;
})(curve);
var curves$1 = {}, hash$2 = {}, utils$p = {}, assert$b = minimalisticAssert, inherits$6 = inherits_browserExports;
utils$p.inherits = inherits$6;
function isSurrogatePair(a, u) {
  return (a.charCodeAt(u) & 64512) !== 55296 || u < 0 || u + 1 >= a.length ? !1 : (a.charCodeAt(u + 1) & 64512) === 56320;
}
function toArray(a, u) {
  if (Array.isArray(a))
    return a.slice();
  if (!a)
    return [];
  var c = [];
  if (typeof a == "string")
    if (u) {
      if (u === "hex")
        for (a = a.replace(/[^a-z0-9]+/ig, ""), a.length % 2 !== 0 && (a = "0" + a), v = 0; v < a.length; v += 2)
          c.push(parseInt(a[v] + a[v + 1], 16));
    } else
      for (var l = 0, v = 0; v < a.length; v++) {
        var p = a.charCodeAt(v);
        p < 128 ? c[l++] = p : p < 2048 ? (c[l++] = p >> 6 | 192, c[l++] = p & 63 | 128) : isSurrogatePair(a, v) ? (p = 65536 + ((p & 1023) << 10) + (a.charCodeAt(++v) & 1023), c[l++] = p >> 18 | 240, c[l++] = p >> 12 & 63 | 128, c[l++] = p >> 6 & 63 | 128, c[l++] = p & 63 | 128) : (c[l++] = p >> 12 | 224, c[l++] = p >> 6 & 63 | 128, c[l++] = p & 63 | 128);
      }
  else
    for (v = 0; v < a.length; v++)
      c[v] = a[v] | 0;
  return c;
}
utils$p.toArray = toArray;
function toHex$1(a) {
  for (var u = "", c = 0; c < a.length; c++)
    u += zero2(a[c].toString(16));
  return u;
}
utils$p.toHex = toHex$1;
function htonl(a) {
  var u = a >>> 24 | a >>> 8 & 65280 | a << 8 & 16711680 | (a & 255) << 24;
  return u >>> 0;
}
utils$p.htonl = htonl;
function toHex32(a, u) {
  for (var c = "", l = 0; l < a.length; l++) {
    var v = a[l];
    u === "little" && (v = htonl(v)), c += zero8(v.toString(16));
  }
  return c;
}
utils$p.toHex32 = toHex32;
function zero2(a) {
  return a.length === 1 ? "0" + a : a;
}
utils$p.zero2 = zero2;
function zero8(a) {
  return a.length === 7 ? "0" + a : a.length === 6 ? "00" + a : a.length === 5 ? "000" + a : a.length === 4 ? "0000" + a : a.length === 3 ? "00000" + a : a.length === 2 ? "000000" + a : a.length === 1 ? "0000000" + a : a;
}
utils$p.zero8 = zero8;
function join32(a, u, c, l) {
  var v = c - u;
  assert$b(v % 4 === 0);
  for (var p = new Array(v / 4), _ = 0, k = u; _ < p.length; _++, k += 4) {
    var O;
    l === "big" ? O = a[k] << 24 | a[k + 1] << 16 | a[k + 2] << 8 | a[k + 3] : O = a[k + 3] << 24 | a[k + 2] << 16 | a[k + 1] << 8 | a[k], p[_] = O >>> 0;
  }
  return p;
}
utils$p.join32 = join32;
function split32(a, u) {
  for (var c = new Array(a.length * 4), l = 0, v = 0; l < a.length; l++, v += 4) {
    var p = a[l];
    u === "big" ? (c[v] = p >>> 24, c[v + 1] = p >>> 16 & 255, c[v + 2] = p >>> 8 & 255, c[v + 3] = p & 255) : (c[v + 3] = p >>> 24, c[v + 2] = p >>> 16 & 255, c[v + 1] = p >>> 8 & 255, c[v] = p & 255);
  }
  return c;
}
utils$p.split32 = split32;
function rotr32$1(a, u) {
  return a >>> u | a << 32 - u;
}
utils$p.rotr32 = rotr32$1;
function rotl32$2(a, u) {
  return a << u | a >>> 32 - u;
}
utils$p.rotl32 = rotl32$2;
function sum32$3(a, u) {
  return a + u >>> 0;
}
utils$p.sum32 = sum32$3;
function sum32_3$1(a, u, c) {
  return a + u + c >>> 0;
}
utils$p.sum32_3 = sum32_3$1;
function sum32_4$2(a, u, c, l) {
  return a + u + c + l >>> 0;
}
utils$p.sum32_4 = sum32_4$2;
function sum32_5$2(a, u, c, l, v) {
  return a + u + c + l + v >>> 0;
}
utils$p.sum32_5 = sum32_5$2;
function sum64$1(a, u, c, l) {
  var v = a[u], p = a[u + 1], _ = l + p >>> 0, k = (_ < l ? 1 : 0) + c + v;
  a[u] = k >>> 0, a[u + 1] = _;
}
utils$p.sum64 = sum64$1;
function sum64_hi$1(a, u, c, l) {
  var v = u + l >>> 0, p = (v < u ? 1 : 0) + a + c;
  return p >>> 0;
}
utils$p.sum64_hi = sum64_hi$1;
function sum64_lo$1(a, u, c, l) {
  var v = u + l;
  return v >>> 0;
}
utils$p.sum64_lo = sum64_lo$1;
function sum64_4_hi$1(a, u, c, l, v, p, _, k) {
  var O = 0, D = u;
  D = D + l >>> 0, O += D < u ? 1 : 0, D = D + p >>> 0, O += D < p ? 1 : 0, D = D + k >>> 0, O += D < k ? 1 : 0;
  var F = a + c + v + _ + O;
  return F >>> 0;
}
utils$p.sum64_4_hi = sum64_4_hi$1;
function sum64_4_lo$1(a, u, c, l, v, p, _, k) {
  var O = u + l + p + k;
  return O >>> 0;
}
utils$p.sum64_4_lo = sum64_4_lo$1;
function sum64_5_hi$1(a, u, c, l, v, p, _, k, O, D) {
  var F = 0, z = u;
  z = z + l >>> 0, F += z < u ? 1 : 0, z = z + p >>> 0, F += z < p ? 1 : 0, z = z + k >>> 0, F += z < k ? 1 : 0, z = z + D >>> 0, F += z < D ? 1 : 0;
  var j = a + c + v + _ + O + F;
  return j >>> 0;
}
utils$p.sum64_5_hi = sum64_5_hi$1;
function sum64_5_lo$1(a, u, c, l, v, p, _, k, O, D) {
  var F = u + l + p + k + D;
  return F >>> 0;
}
utils$p.sum64_5_lo = sum64_5_lo$1;
function rotr64_hi$1(a, u, c) {
  var l = u << 32 - c | a >>> c;
  return l >>> 0;
}
utils$p.rotr64_hi = rotr64_hi$1;
function rotr64_lo$1(a, u, c) {
  var l = a << 32 - c | u >>> c;
  return l >>> 0;
}
utils$p.rotr64_lo = rotr64_lo$1;
function shr64_hi$1(a, u, c) {
  return a >>> c;
}
utils$p.shr64_hi = shr64_hi$1;
function shr64_lo$1(a, u, c) {
  var l = a << 32 - c | u >>> c;
  return l >>> 0;
}
utils$p.shr64_lo = shr64_lo$1;
var common$5 = {}, utils$o = utils$p, assert$a = minimalisticAssert;
function BlockHash$4() {
  this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
}
common$5.BlockHash = BlockHash$4;
BlockHash$4.prototype.update = function a(u, c) {
  if (u = utils$o.toArray(u, c), this.pending ? this.pending = this.pending.concat(u) : this.pending = u, this.pendingTotal += u.length, this.pending.length >= this._delta8) {
    u = this.pending;
    var l = u.length % this._delta8;
    this.pending = u.slice(u.length - l, u.length), this.pending.length === 0 && (this.pending = null), u = utils$o.join32(u, 0, u.length - l, this.endian);
    for (var v = 0; v < u.length; v += this._delta32)
      this._update(u, v, v + this._delta32);
  }
  return this;
};
BlockHash$4.prototype.digest = function a(u) {
  return this.update(this._pad()), assert$a(this.pending === null), this._digest(u);
};
BlockHash$4.prototype._pad = function a() {
  var u = this.pendingTotal, c = this._delta8, l = c - (u + this.padLength) % c, v = new Array(l + this.padLength);
  v[0] = 128;
  for (var p = 1; p < l; p++)
    v[p] = 0;
  if (u <<= 3, this.endian === "big") {
    for (var _ = 8; _ < this.padLength; _++)
      v[p++] = 0;
    v[p++] = 0, v[p++] = 0, v[p++] = 0, v[p++] = 0, v[p++] = u >>> 24 & 255, v[p++] = u >>> 16 & 255, v[p++] = u >>> 8 & 255, v[p++] = u & 255;
  } else
    for (v[p++] = u & 255, v[p++] = u >>> 8 & 255, v[p++] = u >>> 16 & 255, v[p++] = u >>> 24 & 255, v[p++] = 0, v[p++] = 0, v[p++] = 0, v[p++] = 0, _ = 8; _ < this.padLength; _++)
      v[p++] = 0;
  return v;
};
var sha = {}, common$4 = {}, utils$n = utils$p, rotr32 = utils$n.rotr32;
function ft_1$1(a, u, c, l) {
  if (a === 0)
    return ch32$1(u, c, l);
  if (a === 1 || a === 3)
    return p32(u, c, l);
  if (a === 2)
    return maj32$1(u, c, l);
}
common$4.ft_1 = ft_1$1;
function ch32$1(a, u, c) {
  return a & u ^ ~a & c;
}
common$4.ch32 = ch32$1;
function maj32$1(a, u, c) {
  return a & u ^ a & c ^ u & c;
}
common$4.maj32 = maj32$1;
function p32(a, u, c) {
  return a ^ u ^ c;
}
common$4.p32 = p32;
function s0_256$1(a) {
  return rotr32(a, 2) ^ rotr32(a, 13) ^ rotr32(a, 22);
}
common$4.s0_256 = s0_256$1;
function s1_256$1(a) {
  return rotr32(a, 6) ^ rotr32(a, 11) ^ rotr32(a, 25);
}
common$4.s1_256 = s1_256$1;
function g0_256$1(a) {
  return rotr32(a, 7) ^ rotr32(a, 18) ^ a >>> 3;
}
common$4.g0_256 = g0_256$1;
function g1_256$1(a) {
  return rotr32(a, 17) ^ rotr32(a, 19) ^ a >>> 10;
}
common$4.g1_256 = g1_256$1;
var utils$m = utils$p, common$3 = common$5, shaCommon$1 = common$4, rotl32$1 = utils$m.rotl32, sum32$2 = utils$m.sum32, sum32_5$1 = utils$m.sum32_5, ft_1 = shaCommon$1.ft_1, BlockHash$3 = common$3.BlockHash, sha1_K = [
  1518500249,
  1859775393,
  2400959708,
  3395469782
];
function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();
  BlockHash$3.call(this), this.h = [
    1732584193,
    4023233417,
    2562383102,
    271733878,
    3285377520
  ], this.W = new Array(80);
}
utils$m.inherits(SHA1, BlockHash$3);
var _1 = SHA1;
SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;
SHA1.prototype._update = function a(u, c) {
  for (var l = this.W, v = 0; v < 16; v++)
    l[v] = u[c + v];
  for (; v < l.length; v++)
    l[v] = rotl32$1(l[v - 3] ^ l[v - 8] ^ l[v - 14] ^ l[v - 16], 1);
  var p = this.h[0], _ = this.h[1], k = this.h[2], O = this.h[3], D = this.h[4];
  for (v = 0; v < l.length; v++) {
    var F = ~~(v / 20), z = sum32_5$1(rotl32$1(p, 5), ft_1(F, _, k, O), D, l[v], sha1_K[F]);
    D = O, O = k, k = rotl32$1(_, 30), _ = p, p = z;
  }
  this.h[0] = sum32$2(this.h[0], p), this.h[1] = sum32$2(this.h[1], _), this.h[2] = sum32$2(this.h[2], k), this.h[3] = sum32$2(this.h[3], O), this.h[4] = sum32$2(this.h[4], D);
};
SHA1.prototype._digest = function a(u) {
  return u === "hex" ? utils$m.toHex32(this.h, "big") : utils$m.split32(this.h, "big");
};
var utils$l = utils$p, common$2 = common$5, shaCommon = common$4, assert$9 = minimalisticAssert, sum32$1 = utils$l.sum32, sum32_4$1 = utils$l.sum32_4, sum32_5 = utils$l.sum32_5, ch32 = shaCommon.ch32, maj32 = shaCommon.maj32, s0_256 = shaCommon.s0_256, s1_256 = shaCommon.s1_256, g0_256 = shaCommon.g0_256, g1_256 = shaCommon.g1_256, BlockHash$2 = common$2.BlockHash, sha256_K = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
];
function SHA256$1() {
  if (!(this instanceof SHA256$1))
    return new SHA256$1();
  BlockHash$2.call(this), this.h = [
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ], this.k = sha256_K, this.W = new Array(64);
}
utils$l.inherits(SHA256$1, BlockHash$2);
var _256 = SHA256$1;
SHA256$1.blockSize = 512;
SHA256$1.outSize = 256;
SHA256$1.hmacStrength = 192;
SHA256$1.padLength = 64;
SHA256$1.prototype._update = function a(u, c) {
  for (var l = this.W, v = 0; v < 16; v++)
    l[v] = u[c + v];
  for (; v < l.length; v++)
    l[v] = sum32_4$1(g1_256(l[v - 2]), l[v - 7], g0_256(l[v - 15]), l[v - 16]);
  var p = this.h[0], _ = this.h[1], k = this.h[2], O = this.h[3], D = this.h[4], F = this.h[5], z = this.h[6], j = this.h[7];
  for (assert$9(this.k.length === l.length), v = 0; v < l.length; v++) {
    var ee = sum32_5(j, s1_256(D), ch32(D, F, z), this.k[v], l[v]), X = sum32$1(s0_256(p), maj32(p, _, k));
    j = z, z = F, F = D, D = sum32$1(O, ee), O = k, k = _, _ = p, p = sum32$1(ee, X);
  }
  this.h[0] = sum32$1(this.h[0], p), this.h[1] = sum32$1(this.h[1], _), this.h[2] = sum32$1(this.h[2], k), this.h[3] = sum32$1(this.h[3], O), this.h[4] = sum32$1(this.h[4], D), this.h[5] = sum32$1(this.h[5], F), this.h[6] = sum32$1(this.h[6], z), this.h[7] = sum32$1(this.h[7], j);
};
SHA256$1.prototype._digest = function a(u) {
  return u === "hex" ? utils$l.toHex32(this.h, "big") : utils$l.split32(this.h, "big");
};
var utils$k = utils$p, SHA256 = _256;
function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();
  SHA256.call(this), this.h = [
    3238371032,
    914150663,
    812702999,
    4144912697,
    4290775857,
    1750603025,
    1694076839,
    3204075428
  ];
}
utils$k.inherits(SHA224, SHA256);
var _224 = SHA224;
SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;
SHA224.prototype._digest = function a(u) {
  return u === "hex" ? utils$k.toHex32(this.h.slice(0, 7), "big") : utils$k.split32(this.h.slice(0, 7), "big");
};
var utils$j = utils$p, common$1 = common$5, assert$8 = minimalisticAssert, rotr64_hi = utils$j.rotr64_hi, rotr64_lo = utils$j.rotr64_lo, shr64_hi = utils$j.shr64_hi, shr64_lo = utils$j.shr64_lo, sum64 = utils$j.sum64, sum64_hi = utils$j.sum64_hi, sum64_lo = utils$j.sum64_lo, sum64_4_hi = utils$j.sum64_4_hi, sum64_4_lo = utils$j.sum64_4_lo, sum64_5_hi = utils$j.sum64_5_hi, sum64_5_lo = utils$j.sum64_5_lo, BlockHash$1 = common$1.BlockHash, sha512_K = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
];
function SHA512$1() {
  if (!(this instanceof SHA512$1))
    return new SHA512$1();
  BlockHash$1.call(this), this.h = [
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
  ], this.k = sha512_K, this.W = new Array(160);
}
utils$j.inherits(SHA512$1, BlockHash$1);
var _512 = SHA512$1;
SHA512$1.blockSize = 1024;
SHA512$1.outSize = 512;
SHA512$1.hmacStrength = 192;
SHA512$1.padLength = 128;
SHA512$1.prototype._prepareBlock = function a(u, c) {
  for (var l = this.W, v = 0; v < 32; v++)
    l[v] = u[c + v];
  for (; v < l.length; v += 2) {
    var p = g1_512_hi(l[v - 4], l[v - 3]), _ = g1_512_lo(l[v - 4], l[v - 3]), k = l[v - 14], O = l[v - 13], D = g0_512_hi(l[v - 30], l[v - 29]), F = g0_512_lo(l[v - 30], l[v - 29]), z = l[v - 32], j = l[v - 31];
    l[v] = sum64_4_hi(
      p,
      _,
      k,
      O,
      D,
      F,
      z,
      j
    ), l[v + 1] = sum64_4_lo(
      p,
      _,
      k,
      O,
      D,
      F,
      z,
      j
    );
  }
};
SHA512$1.prototype._update = function a(u, c) {
  this._prepareBlock(u, c);
  var l = this.W, v = this.h[0], p = this.h[1], _ = this.h[2], k = this.h[3], O = this.h[4], D = this.h[5], F = this.h[6], z = this.h[7], j = this.h[8], ee = this.h[9], X = this.h[10], ae = this.h[11], Q = this.h[12], ne = this.h[13], Z = this.h[14], de = this.h[15];
  assert$8(this.k.length === l.length);
  for (var fe = 0; fe < l.length; fe += 2) {
    var Te = Z, Re = de, Le = s1_512_hi(j, ee), be = s1_512_lo(j, ee), q = ch64_hi(j, ee, X, ae, Q), J = ch64_lo(j, ee, X, ae, Q, ne), C = this.k[fe], S = this.k[fe + 1], E = l[fe], I = l[fe + 1], M = sum64_5_hi(
      Te,
      Re,
      Le,
      be,
      q,
      J,
      C,
      S,
      E,
      I
    ), $ = sum64_5_lo(
      Te,
      Re,
      Le,
      be,
      q,
      J,
      C,
      S,
      E,
      I
    );
    Te = s0_512_hi(v, p), Re = s0_512_lo(v, p), Le = maj64_hi(v, p, _, k, O), be = maj64_lo(v, p, _, k, O, D);
    var U = sum64_hi(Te, Re, Le, be), Y = sum64_lo(Te, Re, Le, be);
    Z = Q, de = ne, Q = X, ne = ae, X = j, ae = ee, j = sum64_hi(F, z, M, $), ee = sum64_lo(z, z, M, $), F = O, z = D, O = _, D = k, _ = v, k = p, v = sum64_hi(M, $, U, Y), p = sum64_lo(M, $, U, Y);
  }
  sum64(this.h, 0, v, p), sum64(this.h, 2, _, k), sum64(this.h, 4, O, D), sum64(this.h, 6, F, z), sum64(this.h, 8, j, ee), sum64(this.h, 10, X, ae), sum64(this.h, 12, Q, ne), sum64(this.h, 14, Z, de);
};
SHA512$1.prototype._digest = function a(u) {
  return u === "hex" ? utils$j.toHex32(this.h, "big") : utils$j.split32(this.h, "big");
};
function ch64_hi(a, u, c, l, v) {
  var p = a & c ^ ~a & v;
  return p < 0 && (p += 4294967296), p;
}
function ch64_lo(a, u, c, l, v, p) {
  var _ = u & l ^ ~u & p;
  return _ < 0 && (_ += 4294967296), _;
}
function maj64_hi(a, u, c, l, v) {
  var p = a & c ^ a & v ^ c & v;
  return p < 0 && (p += 4294967296), p;
}
function maj64_lo(a, u, c, l, v, p) {
  var _ = u & l ^ u & p ^ l & p;
  return _ < 0 && (_ += 4294967296), _;
}
function s0_512_hi(a, u) {
  var c = rotr64_hi(a, u, 28), l = rotr64_hi(u, a, 2), v = rotr64_hi(u, a, 7), p = c ^ l ^ v;
  return p < 0 && (p += 4294967296), p;
}
function s0_512_lo(a, u) {
  var c = rotr64_lo(a, u, 28), l = rotr64_lo(u, a, 2), v = rotr64_lo(u, a, 7), p = c ^ l ^ v;
  return p < 0 && (p += 4294967296), p;
}
function s1_512_hi(a, u) {
  var c = rotr64_hi(a, u, 14), l = rotr64_hi(a, u, 18), v = rotr64_hi(u, a, 9), p = c ^ l ^ v;
  return p < 0 && (p += 4294967296), p;
}
function s1_512_lo(a, u) {
  var c = rotr64_lo(a, u, 14), l = rotr64_lo(a, u, 18), v = rotr64_lo(u, a, 9), p = c ^ l ^ v;
  return p < 0 && (p += 4294967296), p;
}
function g0_512_hi(a, u) {
  var c = rotr64_hi(a, u, 1), l = rotr64_hi(a, u, 8), v = shr64_hi(a, u, 7), p = c ^ l ^ v;
  return p < 0 && (p += 4294967296), p;
}
function g0_512_lo(a, u) {
  var c = rotr64_lo(a, u, 1), l = rotr64_lo(a, u, 8), v = shr64_lo(a, u, 7), p = c ^ l ^ v;
  return p < 0 && (p += 4294967296), p;
}
function g1_512_hi(a, u) {
  var c = rotr64_hi(a, u, 19), l = rotr64_hi(u, a, 29), v = shr64_hi(a, u, 6), p = c ^ l ^ v;
  return p < 0 && (p += 4294967296), p;
}
function g1_512_lo(a, u) {
  var c = rotr64_lo(a, u, 19), l = rotr64_lo(u, a, 29), v = shr64_lo(a, u, 6), p = c ^ l ^ v;
  return p < 0 && (p += 4294967296), p;
}
var utils$i = utils$p, SHA512 = _512;
function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();
  SHA512.call(this), this.h = [
    3418070365,
    3238371032,
    1654270250,
    914150663,
    2438529370,
    812702999,
    355462360,
    4144912697,
    1731405415,
    4290775857,
    2394180231,
    1750603025,
    3675008525,
    1694076839,
    1203062813,
    3204075428
  ];
}
utils$i.inherits(SHA384, SHA512);
var _384 = SHA384;
SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;
SHA384.prototype._digest = function a(u) {
  return u === "hex" ? utils$i.toHex32(this.h.slice(0, 12), "big") : utils$i.split32(this.h.slice(0, 12), "big");
};
sha.sha1 = _1;
sha.sha224 = _224;
sha.sha256 = _256;
sha.sha384 = _384;
sha.sha512 = _512;
var ripemd = {}, utils$h = utils$p, common = common$5, rotl32 = utils$h.rotl32, sum32 = utils$h.sum32, sum32_3 = utils$h.sum32_3, sum32_4 = utils$h.sum32_4, BlockHash = common.BlockHash;
function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();
  BlockHash.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
}
utils$h.inherits(RIPEMD160, BlockHash);
ripemd.ripemd160 = RIPEMD160;
RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;
RIPEMD160.prototype._update = function a(u, c) {
  for (var l = this.h[0], v = this.h[1], p = this.h[2], _ = this.h[3], k = this.h[4], O = l, D = v, F = p, z = _, j = k, ee = 0; ee < 80; ee++) {
    var X = sum32(
      rotl32(
        sum32_4(l, f(ee, v, p, _), u[r[ee] + c], K(ee)),
        s$1[ee]
      ),
      k
    );
    l = k, k = _, _ = rotl32(p, 10), p = v, v = X, X = sum32(
      rotl32(
        sum32_4(O, f(79 - ee, D, F, z), u[rh[ee] + c], Kh(ee)),
        sh[ee]
      ),
      j
    ), O = j, j = z, z = rotl32(F, 10), F = D, D = X;
  }
  X = sum32_3(this.h[1], p, z), this.h[1] = sum32_3(this.h[2], _, j), this.h[2] = sum32_3(this.h[3], k, O), this.h[3] = sum32_3(this.h[4], l, D), this.h[4] = sum32_3(this.h[0], v, F), this.h[0] = X;
};
RIPEMD160.prototype._digest = function a(u) {
  return u === "hex" ? utils$h.toHex32(this.h, "little") : utils$h.split32(this.h, "little");
};
function f(a, u, c, l) {
  return a <= 15 ? u ^ c ^ l : a <= 31 ? u & c | ~u & l : a <= 47 ? (u | ~c) ^ l : a <= 63 ? u & l | c & ~l : u ^ (c | ~l);
}
function K(a) {
  return a <= 15 ? 0 : a <= 31 ? 1518500249 : a <= 47 ? 1859775393 : a <= 63 ? 2400959708 : 2840853838;
}
function Kh(a) {
  return a <= 15 ? 1352829926 : a <= 31 ? 1548603684 : a <= 47 ? 1836072691 : a <= 63 ? 2053994217 : 0;
}
var r = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
], rh = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
], s$1 = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
], sh = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
], utils$g = utils$p, assert$7 = minimalisticAssert;
function Hmac(a, u, c) {
  if (!(this instanceof Hmac))
    return new Hmac(a, u, c);
  this.Hash = a, this.blockSize = a.blockSize / 8, this.outSize = a.outSize / 8, this.inner = null, this.outer = null, this._init(utils$g.toArray(u, c));
}
var hmac = Hmac;
Hmac.prototype._init = function a(u) {
  u.length > this.blockSize && (u = new this.Hash().update(u).digest()), assert$7(u.length <= this.blockSize);
  for (var c = u.length; c < this.blockSize; c++)
    u.push(0);
  for (c = 0; c < u.length; c++)
    u[c] ^= 54;
  for (this.inner = new this.Hash().update(u), c = 0; c < u.length; c++)
    u[c] ^= 106;
  this.outer = new this.Hash().update(u);
};
Hmac.prototype.update = function a(u, c) {
  return this.inner.update(u, c), this;
};
Hmac.prototype.digest = function a(u) {
  return this.outer.update(this.inner.digest()), this.outer.digest(u);
};
(function(a) {
  var u = a;
  u.utils = utils$p, u.common = common$5, u.sha = sha, u.ripemd = ripemd, u.hmac = hmac, u.sha1 = u.sha.sha1, u.sha256 = u.sha.sha256, u.sha224 = u.sha.sha224, u.sha384 = u.sha.sha384, u.sha512 = u.sha.sha512, u.ripemd160 = u.ripemd.ripemd160;
})(hash$2);
var secp256k1, hasRequiredSecp256k1;
function requireSecp256k1() {
  return hasRequiredSecp256k1 || (hasRequiredSecp256k1 = 1, secp256k1 = {
    doubles: {
      step: 4,
      points: [
        [
          "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
          "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
        ],
        [
          "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
          "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
        ],
        [
          "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
          "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
        ],
        [
          "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
          "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
        ],
        [
          "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
          "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
        ],
        [
          "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
          "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
        ],
        [
          "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
          "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
        ],
        [
          "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
          "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
        ],
        [
          "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
          "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
        ],
        [
          "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
          "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
        ],
        [
          "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
          "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
        ],
        [
          "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
          "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
        ],
        [
          "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
          "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
        ],
        [
          "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
          "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
        ],
        [
          "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
          "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
        ],
        [
          "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
          "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
        ],
        [
          "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
          "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
        ],
        [
          "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
          "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
        ],
        [
          "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
          "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
        ],
        [
          "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
          "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
        ],
        [
          "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
          "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
        ],
        [
          "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
          "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
        ],
        [
          "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
          "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
        ],
        [
          "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
          "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
        ],
        [
          "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
          "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
        ],
        [
          "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
          "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
        ],
        [
          "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
          "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
        ],
        [
          "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
          "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
        ],
        [
          "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
          "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
        ],
        [
          "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
          "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
        ],
        [
          "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
          "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
        ],
        [
          "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
          "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
        ],
        [
          "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
          "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
        ],
        [
          "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
          "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
        ],
        [
          "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
          "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
        ],
        [
          "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
          "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
        ],
        [
          "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
          "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
        ],
        [
          "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
          "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
        ],
        [
          "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
          "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
        ],
        [
          "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
          "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
        ],
        [
          "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
          "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
        ],
        [
          "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
          "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
        ],
        [
          "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
          "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
        ],
        [
          "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
          "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
        ],
        [
          "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
          "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
        ],
        [
          "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
          "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
        ],
        [
          "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
          "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
        ],
        [
          "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
          "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
        ],
        [
          "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
          "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
        ],
        [
          "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
          "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
        ],
        [
          "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
          "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
        ],
        [
          "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
          "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
        ],
        [
          "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
          "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
        ],
        [
          "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
          "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
        ],
        [
          "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
          "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
        ],
        [
          "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
          "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
        ],
        [
          "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
          "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
        ],
        [
          "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
          "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
        ],
        [
          "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
          "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
        ],
        [
          "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
          "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
        ],
        [
          "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
          "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
        ],
        [
          "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
          "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
        ],
        [
          "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
          "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
        ],
        [
          "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
          "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
        ],
        [
          "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
          "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
        ]
      ]
    },
    naf: {
      wnd: 7,
      points: [
        [
          "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
          "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
        ],
        [
          "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
          "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
        ],
        [
          "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
          "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
        ],
        [
          "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
          "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
        ],
        [
          "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
          "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
        ],
        [
          "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
          "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
        ],
        [
          "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
          "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
        ],
        [
          "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
          "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
        ],
        [
          "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
          "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
        ],
        [
          "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
          "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
        ],
        [
          "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
          "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
        ],
        [
          "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
          "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
        ],
        [
          "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
          "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
        ],
        [
          "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
          "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
        ],
        [
          "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
          "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
        ],
        [
          "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
          "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
        ],
        [
          "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
          "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
        ],
        [
          "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
          "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
        ],
        [
          "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
          "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
        ],
        [
          "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
          "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
        ],
        [
          "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
          "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
        ],
        [
          "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
          "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
        ],
        [
          "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
          "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
        ],
        [
          "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
          "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
        ],
        [
          "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
          "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
        ],
        [
          "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
          "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
        ],
        [
          "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
          "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
        ],
        [
          "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
          "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
        ],
        [
          "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
          "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
        ],
        [
          "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
          "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
        ],
        [
          "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
          "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
        ],
        [
          "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
          "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
        ],
        [
          "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
          "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
        ],
        [
          "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
          "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
        ],
        [
          "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
          "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
        ],
        [
          "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
          "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
        ],
        [
          "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
          "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
        ],
        [
          "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
          "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
        ],
        [
          "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
          "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
        ],
        [
          "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
          "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
        ],
        [
          "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
          "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
        ],
        [
          "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
          "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
        ],
        [
          "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
          "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
        ],
        [
          "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
          "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
        ],
        [
          "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
          "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
        ],
        [
          "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
          "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
        ],
        [
          "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
          "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
        ],
        [
          "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
          "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
        ],
        [
          "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
          "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
        ],
        [
          "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
          "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
        ],
        [
          "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
          "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
        ],
        [
          "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
          "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
        ],
        [
          "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
          "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
        ],
        [
          "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
          "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
        ],
        [
          "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
          "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
        ],
        [
          "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
          "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
        ],
        [
          "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
          "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
        ],
        [
          "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
          "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
        ],
        [
          "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
          "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
        ],
        [
          "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
          "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
        ],
        [
          "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
          "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
        ],
        [
          "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
          "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
        ],
        [
          "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
          "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
        ],
        [
          "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
          "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
        ],
        [
          "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
          "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
        ],
        [
          "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
          "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
        ],
        [
          "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
          "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
        ],
        [
          "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
          "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
        ],
        [
          "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
          "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
        ],
        [
          "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
          "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
        ],
        [
          "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
          "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
        ],
        [
          "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
          "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
        ],
        [
          "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
          "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
        ],
        [
          "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
          "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
        ],
        [
          "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
          "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
        ],
        [
          "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
          "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
        ],
        [
          "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
          "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
        ],
        [
          "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
          "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
        ],
        [
          "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
          "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
        ],
        [
          "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
          "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
        ],
        [
          "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
          "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
        ],
        [
          "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
          "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
        ],
        [
          "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
          "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
        ],
        [
          "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
          "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
        ],
        [
          "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
          "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
        ],
        [
          "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
          "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
        ],
        [
          "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
          "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
        ],
        [
          "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
          "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
        ],
        [
          "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
          "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
        ],
        [
          "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
          "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
        ],
        [
          "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
          "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
        ],
        [
          "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
          "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
        ],
        [
          "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
          "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
        ],
        [
          "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
          "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
        ],
        [
          "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
          "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
        ],
        [
          "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
          "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
        ],
        [
          "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
          "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
        ],
        [
          "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
          "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
        ],
        [
          "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
          "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
        ],
        [
          "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
          "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
        ],
        [
          "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
          "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
        ],
        [
          "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
          "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
        ],
        [
          "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
          "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
        ],
        [
          "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
          "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
        ],
        [
          "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
          "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
        ],
        [
          "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
          "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
        ],
        [
          "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
          "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
        ],
        [
          "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
          "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
        ],
        [
          "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
          "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
        ],
        [
          "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
          "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
        ],
        [
          "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
          "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
        ],
        [
          "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
          "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
        ],
        [
          "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
          "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
        ],
        [
          "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
          "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
        ],
        [
          "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
          "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
        ],
        [
          "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
          "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
        ],
        [
          "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
          "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
        ],
        [
          "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
          "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
        ],
        [
          "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
          "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
        ],
        [
          "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
          "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
        ],
        [
          "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
          "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
        ],
        [
          "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
          "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
        ],
        [
          "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
          "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
        ],
        [
          "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
          "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
        ],
        [
          "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
          "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
        ],
        [
          "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
          "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
        ],
        [
          "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
          "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
        ]
      ]
    }
  }), secp256k1;
}
(function(a) {
  var u = a, c = hash$2, l = curve, v = utils$v, p = v.assert;
  function _(D) {
    D.type === "short" ? this.curve = new l.short(D) : D.type === "edwards" ? this.curve = new l.edwards(D) : this.curve = new l.mont(D), this.g = this.curve.g, this.n = this.curve.n, this.hash = D.hash, p(this.g.validate(), "Invalid curve"), p(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  u.PresetCurve = _;
  function k(D, F) {
    Object.defineProperty(u, D, {
      configurable: !0,
      enumerable: !0,
      get: function() {
        var z = new _(F);
        return Object.defineProperty(u, D, {
          configurable: !0,
          enumerable: !0,
          value: z
        }), z;
      }
    });
  }
  k("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: c.sha256,
    gRed: !1,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  }), k("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: c.sha256,
    gRed: !1,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  }), k("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: c.sha256,
    gRed: !1,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  }), k("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: c.sha384,
    gRed: !1,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  }), k("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: c.sha512,
    gRed: !1,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  }), k("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: c.sha256,
    gRed: !1,
    g: [
      "9"
    ]
  }), k("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    // -121665 * (121666^(-1)) (mod P)
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: c.sha256,
    gRed: !1,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      // 4/5
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var O;
  try {
    O = requireSecp256k1();
  } catch {
    O = void 0;
  }
  k("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: c.sha256,
    // Precomputed endomorphism
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: !1,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      O
    ]
  });
})(curves$1);
var hash$1 = hash$2, utils$f = utils$u, assert$6 = minimalisticAssert;
function HmacDRBG(a) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(a);
  this.hash = a.hash, this.predResist = !!a.predResist, this.outLen = this.hash.outSize, this.minEntropy = a.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
  var u = utils$f.toArray(a.entropy, a.entropyEnc || "hex"), c = utils$f.toArray(a.nonce, a.nonceEnc || "hex"), l = utils$f.toArray(a.pers, a.persEnc || "hex");
  assert$6(
    u.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._init(u, c, l);
}
var hmacDrbg = HmacDRBG;
HmacDRBG.prototype._init = function a(u, c, l) {
  var v = u.concat(c).concat(l);
  this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
  for (var p = 0; p < this.V.length; p++)
    this.K[p] = 0, this.V[p] = 1;
  this._update(v), this._reseed = 1, this.reseedInterval = 281474976710656;
};
HmacDRBG.prototype._hmac = function a() {
  return new hash$1.hmac(this.hash, this.K);
};
HmacDRBG.prototype._update = function a(u) {
  var c = this._hmac().update(this.V).update([0]);
  u && (c = c.update(u)), this.K = c.digest(), this.V = this._hmac().update(this.V).digest(), u && (this.K = this._hmac().update(this.V).update([1]).update(u).digest(), this.V = this._hmac().update(this.V).digest());
};
HmacDRBG.prototype.reseed = function a(u, c, l, v) {
  typeof c != "string" && (v = l, l = c, c = null), u = utils$f.toArray(u, c), l = utils$f.toArray(l, v), assert$6(
    u.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._update(u.concat(l || [])), this._reseed = 1;
};
HmacDRBG.prototype.generate = function a(u, c, l, v) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  typeof c != "string" && (v = l, l = c, c = null), l && (l = utils$f.toArray(l, v || "hex"), this._update(l));
  for (var p = []; p.length < u; )
    this.V = this._hmac().update(this.V).digest(), p = p.concat(this.V);
  var _ = p.slice(0, u);
  return this._update(l), this._reseed++, utils$f.encode(_, c);
};
var BN$5 = bnExports$3, utils$e = utils$v, assert$5 = utils$e.assert;
function KeyPair$2(a, u) {
  this.ec = a, this.priv = null, this.pub = null, u.priv && this._importPrivate(u.priv, u.privEnc), u.pub && this._importPublic(u.pub, u.pubEnc);
}
var key$2 = KeyPair$2;
KeyPair$2.fromPublic = function a(u, c, l) {
  return c instanceof KeyPair$2 ? c : new KeyPair$2(u, {
    pub: c,
    pubEnc: l
  });
};
KeyPair$2.fromPrivate = function a(u, c, l) {
  return c instanceof KeyPair$2 ? c : new KeyPair$2(u, {
    priv: c,
    privEnc: l
  });
};
KeyPair$2.prototype.validate = function a() {
  var u = this.getPublic();
  return u.isInfinity() ? { result: !1, reason: "Invalid public key" } : u.validate() ? u.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" };
};
KeyPair$2.prototype.getPublic = function a(u, c) {
  return typeof u == "string" && (c = u, u = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), c ? this.pub.encode(c, u) : this.pub;
};
KeyPair$2.prototype.getPrivate = function a(u) {
  return u === "hex" ? this.priv.toString(16, 2) : this.priv;
};
KeyPair$2.prototype._importPrivate = function a(u, c) {
  this.priv = new BN$5(u, c || 16), this.priv = this.priv.umod(this.ec.curve.n);
};
KeyPair$2.prototype._importPublic = function a(u, c) {
  if (u.x || u.y) {
    this.ec.curve.type === "mont" ? assert$5(u.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && assert$5(u.x && u.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(u.x, u.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(u, c);
};
KeyPair$2.prototype.derive = function a(u) {
  return u.validate() || assert$5(u.validate(), "public point not validated"), u.mul(this.priv).getX();
};
KeyPair$2.prototype.sign = function a(u, c, l) {
  return this.ec.sign(u, this, c, l);
};
KeyPair$2.prototype.verify = function a(u, c) {
  return this.ec.verify(u, c, this);
};
KeyPair$2.prototype.inspect = function a() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var BN$4 = bnExports$3, utils$d = utils$v, assert$4 = utils$d.assert;
function Signature$2(a, u) {
  if (a instanceof Signature$2)
    return a;
  this._importDER(a, u) || (assert$4(a.r && a.s, "Signature without r or s"), this.r = new BN$4(a.r, 16), this.s = new BN$4(a.s, 16), a.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = a.recoveryParam);
}
var signature$1 = Signature$2;
function Position() {
  this.place = 0;
}
function getLength(a, u) {
  var c = a[u.place++];
  if (!(c & 128))
    return c;
  var l = c & 15;
  if (l === 0 || l > 4)
    return !1;
  for (var v = 0, p = 0, _ = u.place; p < l; p++, _++)
    v <<= 8, v |= a[_], v >>>= 0;
  return v <= 127 ? !1 : (u.place = _, v);
}
function rmPadding(a) {
  for (var u = 0, c = a.length - 1; !a[u] && !(a[u + 1] & 128) && u < c; )
    u++;
  return u === 0 ? a : a.slice(u);
}
Signature$2.prototype._importDER = function a(u, c) {
  u = utils$d.toArray(u, c);
  var l = new Position();
  if (u[l.place++] !== 48)
    return !1;
  var v = getLength(u, l);
  if (v === !1 || v + l.place !== u.length || u[l.place++] !== 2)
    return !1;
  var p = getLength(u, l);
  if (p === !1)
    return !1;
  var _ = u.slice(l.place, p + l.place);
  if (l.place += p, u[l.place++] !== 2)
    return !1;
  var k = getLength(u, l);
  if (k === !1 || u.length !== k + l.place)
    return !1;
  var O = u.slice(l.place, k + l.place);
  if (_[0] === 0)
    if (_[1] & 128)
      _ = _.slice(1);
    else
      return !1;
  if (O[0] === 0)
    if (O[1] & 128)
      O = O.slice(1);
    else
      return !1;
  return this.r = new BN$4(_), this.s = new BN$4(O), this.recoveryParam = null, !0;
};
function constructLength(a, u) {
  if (u < 128) {
    a.push(u);
    return;
  }
  var c = 1 + (Math.log(u) / Math.LN2 >>> 3);
  for (a.push(c | 128); --c; )
    a.push(u >>> (c << 3) & 255);
  a.push(u);
}
Signature$2.prototype.toDER = function a(u) {
  var c = this.r.toArray(), l = this.s.toArray();
  for (c[0] & 128 && (c = [0].concat(c)), l[0] & 128 && (l = [0].concat(l)), c = rmPadding(c), l = rmPadding(l); !l[0] && !(l[1] & 128); )
    l = l.slice(1);
  var v = [2];
  constructLength(v, c.length), v = v.concat(c), v.push(2), constructLength(v, l.length);
  var p = v.concat(l), _ = [48];
  return constructLength(_, p.length), _ = _.concat(p), utils$d.encode(_, u);
};
var ec, hasRequiredEc;
function requireEc() {
  if (hasRequiredEc)
    return ec;
  hasRequiredEc = 1;
  var a = bnExports$3, u = hmacDrbg, c = utils$v, l = curves$1, v = requireBrorand(), p = c.assert, _ = key$2, k = signature$1;
  function O(D) {
    if (!(this instanceof O))
      return new O(D);
    typeof D == "string" && (p(
      Object.prototype.hasOwnProperty.call(l, D),
      "Unknown curve " + D
    ), D = l[D]), D instanceof l.PresetCurve && (D = { curve: D }), this.curve = D.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = D.curve.g, this.g.precompute(D.curve.n.bitLength() + 1), this.hash = D.hash || D.curve.hash;
  }
  return ec = O, O.prototype.keyPair = function(F) {
    return new _(this, F);
  }, O.prototype.keyFromPrivate = function(F, z) {
    return _.fromPrivate(this, F, z);
  }, O.prototype.keyFromPublic = function(F, z) {
    return _.fromPublic(this, F, z);
  }, O.prototype.genKeyPair = function(F) {
    F || (F = {});
    for (var z = new u({
      hash: this.hash,
      pers: F.pers,
      persEnc: F.persEnc || "utf8",
      entropy: F.entropy || v(this.hash.hmacStrength),
      entropyEnc: F.entropy && F.entropyEnc || "utf8",
      nonce: this.n.toArray()
    }), j = this.n.byteLength(), ee = this.n.sub(new a(2)); ; ) {
      var X = new a(z.generate(j));
      if (!(X.cmp(ee) > 0))
        return X.iaddn(1), this.keyFromPrivate(X);
    }
  }, O.prototype._truncateToN = function(F, z) {
    var j = F.byteLength() * 8 - this.n.bitLength();
    return j > 0 && (F = F.ushrn(j)), !z && F.cmp(this.n) >= 0 ? F.sub(this.n) : F;
  }, O.prototype.sign = function(F, z, j, ee) {
    typeof j == "object" && (ee = j, j = null), ee || (ee = {}), z = this.keyFromPrivate(z, j), F = this._truncateToN(new a(F, 16));
    for (var X = this.n.byteLength(), ae = z.getPrivate().toArray("be", X), Q = F.toArray("be", X), ne = new u({
      hash: this.hash,
      entropy: ae,
      nonce: Q,
      pers: ee.pers,
      persEnc: ee.persEnc || "utf8"
    }), Z = this.n.sub(new a(1)), de = 0; ; de++) {
      var fe = ee.k ? ee.k(de) : new a(ne.generate(this.n.byteLength()));
      if (fe = this._truncateToN(fe, !0), !(fe.cmpn(1) <= 0 || fe.cmp(Z) >= 0)) {
        var Te = this.g.mul(fe);
        if (!Te.isInfinity()) {
          var Re = Te.getX(), Le = Re.umod(this.n);
          if (Le.cmpn(0) !== 0) {
            var be = fe.invm(this.n).mul(Le.mul(z.getPrivate()).iadd(F));
            if (be = be.umod(this.n), be.cmpn(0) !== 0) {
              var q = (Te.getY().isOdd() ? 1 : 0) | (Re.cmp(Le) !== 0 ? 2 : 0);
              return ee.canonical && be.cmp(this.nh) > 0 && (be = this.n.sub(be), q ^= 1), new k({ r: Le, s: be, recoveryParam: q });
            }
          }
        }
      }
    }
  }, O.prototype.verify = function(F, z, j, ee) {
    F = this._truncateToN(new a(F, 16)), j = this.keyFromPublic(j, ee), z = new k(z, "hex");
    var X = z.r, ae = z.s;
    if (X.cmpn(1) < 0 || X.cmp(this.n) >= 0 || ae.cmpn(1) < 0 || ae.cmp(this.n) >= 0)
      return !1;
    var Q = ae.invm(this.n), ne = Q.mul(F).umod(this.n), Z = Q.mul(X).umod(this.n), de;
    return this.curve._maxwellTrick ? (de = this.g.jmulAdd(ne, j.getPublic(), Z), de.isInfinity() ? !1 : de.eqXToP(X)) : (de = this.g.mulAdd(ne, j.getPublic(), Z), de.isInfinity() ? !1 : de.getX().umod(this.n).cmp(X) === 0);
  }, O.prototype.recoverPubKey = function(D, F, z, j) {
    p((3 & z) === z, "The recovery param is more than two bits"), F = new k(F, j);
    var ee = this.n, X = new a(D), ae = F.r, Q = F.s, ne = z & 1, Z = z >> 1;
    if (ae.cmp(this.curve.p.umod(this.curve.n)) >= 0 && Z)
      throw new Error("Unable to find sencond key candinate");
    Z ? ae = this.curve.pointFromX(ae.add(this.curve.n), ne) : ae = this.curve.pointFromX(ae, ne);
    var de = F.r.invm(ee), fe = ee.sub(X).mul(de).umod(ee), Te = Q.mul(de).umod(ee);
    return this.g.mulAdd(fe, ae, Te);
  }, O.prototype.getKeyRecoveryParam = function(D, F, z, j) {
    if (F = new k(F, j), F.recoveryParam !== null)
      return F.recoveryParam;
    for (var ee = 0; ee < 4; ee++) {
      var X;
      try {
        X = this.recoverPubKey(D, F, ee);
      } catch {
        continue;
      }
      if (X.eq(z))
        return ee;
    }
    throw new Error("Unable to find valid recovery factor");
  }, ec;
}
var utils$c = utils$v, assert$3 = utils$c.assert, parseBytes$2 = utils$c.parseBytes, cachedProperty$1 = utils$c.cachedProperty;
function KeyPair$1(a, u) {
  this.eddsa = a, this._secret = parseBytes$2(u.secret), a.isPoint(u.pub) ? this._pub = u.pub : this._pubBytes = parseBytes$2(u.pub);
}
KeyPair$1.fromPublic = function a(u, c) {
  return c instanceof KeyPair$1 ? c : new KeyPair$1(u, { pub: c });
};
KeyPair$1.fromSecret = function a(u, c) {
  return c instanceof KeyPair$1 ? c : new KeyPair$1(u, { secret: c });
};
KeyPair$1.prototype.secret = function a() {
  return this._secret;
};
cachedProperty$1(KeyPair$1, "pubBytes", function a() {
  return this.eddsa.encodePoint(this.pub());
});
cachedProperty$1(KeyPair$1, "pub", function a() {
  return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
});
cachedProperty$1(KeyPair$1, "privBytes", function a() {
  var u = this.eddsa, c = this.hash(), l = u.encodingLength - 1, v = c.slice(0, u.encodingLength);
  return v[0] &= 248, v[l] &= 127, v[l] |= 64, v;
});
cachedProperty$1(KeyPair$1, "priv", function a() {
  return this.eddsa.decodeInt(this.privBytes());
});
cachedProperty$1(KeyPair$1, "hash", function a() {
  return this.eddsa.hash().update(this.secret()).digest();
});
cachedProperty$1(KeyPair$1, "messagePrefix", function a() {
  return this.hash().slice(this.eddsa.encodingLength);
});
KeyPair$1.prototype.sign = function a(u) {
  return assert$3(this._secret, "KeyPair can only verify"), this.eddsa.sign(u, this);
};
KeyPair$1.prototype.verify = function a(u, c) {
  return this.eddsa.verify(u, c, this);
};
KeyPair$1.prototype.getSecret = function a(u) {
  return assert$3(this._secret, "KeyPair is public only"), utils$c.encode(this.secret(), u);
};
KeyPair$1.prototype.getPublic = function a(u) {
  return utils$c.encode(this.pubBytes(), u);
};
var key$1 = KeyPair$1, BN$3 = bnExports$3, utils$b = utils$v, assert$2 = utils$b.assert, cachedProperty = utils$b.cachedProperty, parseBytes$1 = utils$b.parseBytes;
function Signature$1(a, u) {
  this.eddsa = a, typeof u != "object" && (u = parseBytes$1(u)), Array.isArray(u) && (u = {
    R: u.slice(0, a.encodingLength),
    S: u.slice(a.encodingLength)
  }), assert$2(u.R && u.S, "Signature without R or S"), a.isPoint(u.R) && (this._R = u.R), u.S instanceof BN$3 && (this._S = u.S), this._Rencoded = Array.isArray(u.R) ? u.R : u.Rencoded, this._Sencoded = Array.isArray(u.S) ? u.S : u.Sencoded;
}
cachedProperty(Signature$1, "S", function a() {
  return this.eddsa.decodeInt(this.Sencoded());
});
cachedProperty(Signature$1, "R", function a() {
  return this.eddsa.decodePoint(this.Rencoded());
});
cachedProperty(Signature$1, "Rencoded", function a() {
  return this.eddsa.encodePoint(this.R());
});
cachedProperty(Signature$1, "Sencoded", function a() {
  return this.eddsa.encodeInt(this.S());
});
Signature$1.prototype.toBytes = function a() {
  return this.Rencoded().concat(this.Sencoded());
};
Signature$1.prototype.toHex = function a() {
  return utils$b.encode(this.toBytes(), "hex").toUpperCase();
};
var signature = Signature$1, hash = hash$2, curves = curves$1, utils$a = utils$v, assert$1 = utils$a.assert, parseBytes = utils$a.parseBytes, KeyPair = key$1, Signature = signature;
function EDDSA(a) {
  if (assert$1(a === "ed25519", "only tested with ed25519 so far"), !(this instanceof EDDSA))
    return new EDDSA(a);
  a = curves[a].curve, this.curve = a, this.g = a.g, this.g.precompute(a.n.bitLength() + 1), this.pointClass = a.point().constructor, this.encodingLength = Math.ceil(a.n.bitLength() / 8), this.hash = hash.sha512;
}
var eddsa = EDDSA;
EDDSA.prototype.sign = function a(u, c) {
  u = parseBytes(u);
  var l = this.keyFromSecret(c), v = this.hashInt(l.messagePrefix(), u), p = this.g.mul(v), _ = this.encodePoint(p), k = this.hashInt(_, l.pubBytes(), u).mul(l.priv()), O = v.add(k).umod(this.curve.n);
  return this.makeSignature({ R: p, S: O, Rencoded: _ });
};
EDDSA.prototype.verify = function a(u, c, l) {
  u = parseBytes(u), c = this.makeSignature(c);
  var v = this.keyFromPublic(l), p = this.hashInt(c.Rencoded(), v.pubBytes(), u), _ = this.g.mul(c.S()), k = c.R().add(v.pub().mul(p));
  return k.eq(_);
};
EDDSA.prototype.hashInt = function a() {
  for (var u = this.hash(), c = 0; c < arguments.length; c++)
    u.update(arguments[c]);
  return utils$a.intFromLE(u.digest()).umod(this.curve.n);
};
EDDSA.prototype.keyFromPublic = function a(u) {
  return KeyPair.fromPublic(this, u);
};
EDDSA.prototype.keyFromSecret = function a(u) {
  return KeyPair.fromSecret(this, u);
};
EDDSA.prototype.makeSignature = function a(u) {
  return u instanceof Signature ? u : new Signature(this, u);
};
EDDSA.prototype.encodePoint = function a(u) {
  var c = u.getY().toArray("le", this.encodingLength);
  return c[this.encodingLength - 1] |= u.getX().isOdd() ? 128 : 0, c;
};
EDDSA.prototype.decodePoint = function a(u) {
  u = utils$a.parseBytes(u);
  var c = u.length - 1, l = u.slice(0, c).concat(u[c] & -129), v = (u[c] & 128) !== 0, p = utils$a.intFromLE(l);
  return this.curve.pointFromY(p, v);
};
EDDSA.prototype.encodeInt = function a(u) {
  return u.toArray("le", this.encodingLength);
};
EDDSA.prototype.decodeInt = function a(u) {
  return utils$a.intFromLE(u);
};
EDDSA.prototype.isPoint = function a(u) {
  return u instanceof this.pointClass;
};
var hasRequiredElliptic;
function requireElliptic() {
  return hasRequiredElliptic || (hasRequiredElliptic = 1, function(a) {
    var u = a;
    u.version = require$$0$1.version, u.utils = utils$v, u.rand = requireBrorand(), u.curve = curve, u.curves = curves$1, u.ec = requireEc(), u.eddsa = eddsa;
  }(elliptic)), elliptic;
}
var asn1$3 = {}, asn1$2 = {}, bn$2 = { exports: {} };
bn$2.exports;
(function(a) {
  (function(u, c) {
    function l(C, S) {
      if (!C)
        throw new Error(S || "Assertion failed");
    }
    function v(C, S) {
      C.super_ = S;
      var E = function() {
      };
      E.prototype = S.prototype, C.prototype = new E(), C.prototype.constructor = C;
    }
    function p(C, S, E) {
      if (p.isBN(C))
        return C;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, C !== null && ((S === "le" || S === "be") && (E = S, S = 10), this._init(C || 0, S || 10, E || "be"));
    }
    typeof u == "object" ? u.exports = p : c.BN = p, p.BN = p, p.wordSize = 26;
    var _;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? _ = window.Buffer : _ = require$$0$2.Buffer;
    } catch {
    }
    p.isBN = function(S) {
      return S instanceof p ? !0 : S !== null && typeof S == "object" && S.constructor.wordSize === p.wordSize && Array.isArray(S.words);
    }, p.max = function(S, E) {
      return S.cmp(E) > 0 ? S : E;
    }, p.min = function(S, E) {
      return S.cmp(E) < 0 ? S : E;
    }, p.prototype._init = function(S, E, I) {
      if (typeof S == "number")
        return this._initNumber(S, E, I);
      if (typeof S == "object")
        return this._initArray(S, E, I);
      E === "hex" && (E = 16), l(E === (E | 0) && E >= 2 && E <= 36), S = S.toString().replace(/\s+/g, "");
      var M = 0;
      S[0] === "-" && (M++, this.negative = 1), M < S.length && (E === 16 ? this._parseHex(S, M, I) : (this._parseBase(S, E, M), I === "le" && this._initArray(this.toArray(), E, I)));
    }, p.prototype._initNumber = function(S, E, I) {
      S < 0 && (this.negative = 1, S = -S), S < 67108864 ? (this.words = [S & 67108863], this.length = 1) : S < 4503599627370496 ? (this.words = [
        S & 67108863,
        S / 67108864 & 67108863
      ], this.length = 2) : (l(S < 9007199254740992), this.words = [
        S & 67108863,
        S / 67108864 & 67108863,
        1
      ], this.length = 3), I === "le" && this._initArray(this.toArray(), E, I);
    }, p.prototype._initArray = function(S, E, I) {
      if (l(typeof S.length == "number"), S.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(S.length / 3), this.words = new Array(this.length);
      for (var M = 0; M < this.length; M++)
        this.words[M] = 0;
      var $, U, Y = 0;
      if (I === "be")
        for (M = S.length - 1, $ = 0; M >= 0; M -= 3)
          U = S[M] | S[M - 1] << 8 | S[M - 2] << 16, this.words[$] |= U << Y & 67108863, this.words[$ + 1] = U >>> 26 - Y & 67108863, Y += 24, Y >= 26 && (Y -= 26, $++);
      else if (I === "le")
        for (M = 0, $ = 0; M < S.length; M += 3)
          U = S[M] | S[M + 1] << 8 | S[M + 2] << 16, this.words[$] |= U << Y & 67108863, this.words[$ + 1] = U >>> 26 - Y & 67108863, Y += 24, Y >= 26 && (Y -= 26, $++);
      return this.strip();
    };
    function k(C, S) {
      var E = C.charCodeAt(S);
      return E >= 65 && E <= 70 ? E - 55 : E >= 97 && E <= 102 ? E - 87 : E - 48 & 15;
    }
    function O(C, S, E) {
      var I = k(C, E);
      return E - 1 >= S && (I |= k(C, E - 1) << 4), I;
    }
    p.prototype._parseHex = function(S, E, I) {
      this.length = Math.ceil((S.length - E) / 6), this.words = new Array(this.length);
      for (var M = 0; M < this.length; M++)
        this.words[M] = 0;
      var $ = 0, U = 0, Y;
      if (I === "be")
        for (M = S.length - 1; M >= E; M -= 2)
          Y = O(S, E, M) << $, this.words[U] |= Y & 67108863, $ >= 18 ? ($ -= 18, U += 1, this.words[U] |= Y >>> 26) : $ += 8;
      else {
        var L = S.length - E;
        for (M = L % 2 === 0 ? E + 1 : E; M < S.length; M += 2)
          Y = O(S, E, M) << $, this.words[U] |= Y & 67108863, $ >= 18 ? ($ -= 18, U += 1, this.words[U] |= Y >>> 26) : $ += 8;
      }
      this.strip();
    };
    function D(C, S, E, I) {
      for (var M = 0, $ = Math.min(C.length, E), U = S; U < $; U++) {
        var Y = C.charCodeAt(U) - 48;
        M *= I, Y >= 49 ? M += Y - 49 + 10 : Y >= 17 ? M += Y - 17 + 10 : M += Y;
      }
      return M;
    }
    p.prototype._parseBase = function(S, E, I) {
      this.words = [0], this.length = 1;
      for (var M = 0, $ = 1; $ <= 67108863; $ *= E)
        M++;
      M--, $ = $ / E | 0;
      for (var U = S.length - I, Y = U % M, L = Math.min(U, U - Y) + I, T = 0, B = I; B < L; B += M)
        T = D(S, B, B + M, E), this.imuln($), this.words[0] + T < 67108864 ? this.words[0] += T : this._iaddn(T);
      if (Y !== 0) {
        var te = 1;
        for (T = D(S, B, S.length, E), B = 0; B < Y; B++)
          te *= E;
        this.imuln(te), this.words[0] + T < 67108864 ? this.words[0] += T : this._iaddn(T);
      }
      this.strip();
    }, p.prototype.copy = function(S) {
      S.words = new Array(this.length);
      for (var E = 0; E < this.length; E++)
        S.words[E] = this.words[E];
      S.length = this.length, S.negative = this.negative, S.red = this.red;
    }, p.prototype.clone = function() {
      var S = new p(null);
      return this.copy(S), S;
    }, p.prototype._expand = function(S) {
      for (; this.length < S; )
        this.words[this.length++] = 0;
      return this;
    }, p.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, p.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, p.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var F = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], z = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], j = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    p.prototype.toString = function(S, E) {
      S = S || 10, E = E | 0 || 1;
      var I;
      if (S === 16 || S === "hex") {
        I = "";
        for (var M = 0, $ = 0, U = 0; U < this.length; U++) {
          var Y = this.words[U], L = ((Y << M | $) & 16777215).toString(16);
          $ = Y >>> 24 - M & 16777215, $ !== 0 || U !== this.length - 1 ? I = F[6 - L.length] + L + I : I = L + I, M += 2, M >= 26 && (M -= 26, U--);
        }
        for ($ !== 0 && (I = $.toString(16) + I); I.length % E !== 0; )
          I = "0" + I;
        return this.negative !== 0 && (I = "-" + I), I;
      }
      if (S === (S | 0) && S >= 2 && S <= 36) {
        var T = z[S], B = j[S];
        I = "";
        var te = this.clone();
        for (te.negative = 0; !te.isZero(); ) {
          var pe = te.modn(B).toString(S);
          te = te.idivn(B), te.isZero() ? I = pe + I : I = F[T - pe.length] + pe + I;
        }
        for (this.isZero() && (I = "0" + I); I.length % E !== 0; )
          I = "0" + I;
        return this.negative !== 0 && (I = "-" + I), I;
      }
      l(!1, "Base should be between 2 and 36");
    }, p.prototype.toNumber = function() {
      var S = this.words[0];
      return this.length === 2 ? S += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? S += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && l(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -S : S;
    }, p.prototype.toJSON = function() {
      return this.toString(16);
    }, p.prototype.toBuffer = function(S, E) {
      return l(typeof _ < "u"), this.toArrayLike(_, S, E);
    }, p.prototype.toArray = function(S, E) {
      return this.toArrayLike(Array, S, E);
    }, p.prototype.toArrayLike = function(S, E, I) {
      var M = this.byteLength(), $ = I || Math.max(1, M);
      l(M <= $, "byte array longer than desired length"), l($ > 0, "Requested array length <= 0"), this.strip();
      var U = E === "le", Y = new S($), L, T, B = this.clone();
      if (U) {
        for (T = 0; !B.isZero(); T++)
          L = B.andln(255), B.iushrn(8), Y[T] = L;
        for (; T < $; T++)
          Y[T] = 0;
      } else {
        for (T = 0; T < $ - M; T++)
          Y[T] = 0;
        for (T = 0; !B.isZero(); T++)
          L = B.andln(255), B.iushrn(8), Y[$ - T - 1] = L;
      }
      return Y;
    }, Math.clz32 ? p.prototype._countBits = function(S) {
      return 32 - Math.clz32(S);
    } : p.prototype._countBits = function(S) {
      var E = S, I = 0;
      return E >= 4096 && (I += 13, E >>>= 13), E >= 64 && (I += 7, E >>>= 7), E >= 8 && (I += 4, E >>>= 4), E >= 2 && (I += 2, E >>>= 2), I + E;
    }, p.prototype._zeroBits = function(S) {
      if (S === 0)
        return 26;
      var E = S, I = 0;
      return E & 8191 || (I += 13, E >>>= 13), E & 127 || (I += 7, E >>>= 7), E & 15 || (I += 4, E >>>= 4), E & 3 || (I += 2, E >>>= 2), E & 1 || I++, I;
    }, p.prototype.bitLength = function() {
      var S = this.words[this.length - 1], E = this._countBits(S);
      return (this.length - 1) * 26 + E;
    };
    function ee(C) {
      for (var S = new Array(C.bitLength()), E = 0; E < S.length; E++) {
        var I = E / 26 | 0, M = E % 26;
        S[E] = (C.words[I] & 1 << M) >>> M;
      }
      return S;
    }
    p.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var S = 0, E = 0; E < this.length; E++) {
        var I = this._zeroBits(this.words[E]);
        if (S += I, I !== 26)
          break;
      }
      return S;
    }, p.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, p.prototype.toTwos = function(S) {
      return this.negative !== 0 ? this.abs().inotn(S).iaddn(1) : this.clone();
    }, p.prototype.fromTwos = function(S) {
      return this.testn(S - 1) ? this.notn(S).iaddn(1).ineg() : this.clone();
    }, p.prototype.isNeg = function() {
      return this.negative !== 0;
    }, p.prototype.neg = function() {
      return this.clone().ineg();
    }, p.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, p.prototype.iuor = function(S) {
      for (; this.length < S.length; )
        this.words[this.length++] = 0;
      for (var E = 0; E < S.length; E++)
        this.words[E] = this.words[E] | S.words[E];
      return this.strip();
    }, p.prototype.ior = function(S) {
      return l((this.negative | S.negative) === 0), this.iuor(S);
    }, p.prototype.or = function(S) {
      return this.length > S.length ? this.clone().ior(S) : S.clone().ior(this);
    }, p.prototype.uor = function(S) {
      return this.length > S.length ? this.clone().iuor(S) : S.clone().iuor(this);
    }, p.prototype.iuand = function(S) {
      var E;
      this.length > S.length ? E = S : E = this;
      for (var I = 0; I < E.length; I++)
        this.words[I] = this.words[I] & S.words[I];
      return this.length = E.length, this.strip();
    }, p.prototype.iand = function(S) {
      return l((this.negative | S.negative) === 0), this.iuand(S);
    }, p.prototype.and = function(S) {
      return this.length > S.length ? this.clone().iand(S) : S.clone().iand(this);
    }, p.prototype.uand = function(S) {
      return this.length > S.length ? this.clone().iuand(S) : S.clone().iuand(this);
    }, p.prototype.iuxor = function(S) {
      var E, I;
      this.length > S.length ? (E = this, I = S) : (E = S, I = this);
      for (var M = 0; M < I.length; M++)
        this.words[M] = E.words[M] ^ I.words[M];
      if (this !== E)
        for (; M < E.length; M++)
          this.words[M] = E.words[M];
      return this.length = E.length, this.strip();
    }, p.prototype.ixor = function(S) {
      return l((this.negative | S.negative) === 0), this.iuxor(S);
    }, p.prototype.xor = function(S) {
      return this.length > S.length ? this.clone().ixor(S) : S.clone().ixor(this);
    }, p.prototype.uxor = function(S) {
      return this.length > S.length ? this.clone().iuxor(S) : S.clone().iuxor(this);
    }, p.prototype.inotn = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = Math.ceil(S / 26) | 0, I = S % 26;
      this._expand(E), I > 0 && E--;
      for (var M = 0; M < E; M++)
        this.words[M] = ~this.words[M] & 67108863;
      return I > 0 && (this.words[M] = ~this.words[M] & 67108863 >> 26 - I), this.strip();
    }, p.prototype.notn = function(S) {
      return this.clone().inotn(S);
    }, p.prototype.setn = function(S, E) {
      l(typeof S == "number" && S >= 0);
      var I = S / 26 | 0, M = S % 26;
      return this._expand(I + 1), E ? this.words[I] = this.words[I] | 1 << M : this.words[I] = this.words[I] & ~(1 << M), this.strip();
    }, p.prototype.iadd = function(S) {
      var E;
      if (this.negative !== 0 && S.negative === 0)
        return this.negative = 0, E = this.isub(S), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && S.negative !== 0)
        return S.negative = 0, E = this.isub(S), S.negative = 1, E._normSign();
      var I, M;
      this.length > S.length ? (I = this, M = S) : (I = S, M = this);
      for (var $ = 0, U = 0; U < M.length; U++)
        E = (I.words[U] | 0) + (M.words[U] | 0) + $, this.words[U] = E & 67108863, $ = E >>> 26;
      for (; $ !== 0 && U < I.length; U++)
        E = (I.words[U] | 0) + $, this.words[U] = E & 67108863, $ = E >>> 26;
      if (this.length = I.length, $ !== 0)
        this.words[this.length] = $, this.length++;
      else if (I !== this)
        for (; U < I.length; U++)
          this.words[U] = I.words[U];
      return this;
    }, p.prototype.add = function(S) {
      var E;
      return S.negative !== 0 && this.negative === 0 ? (S.negative = 0, E = this.sub(S), S.negative ^= 1, E) : S.negative === 0 && this.negative !== 0 ? (this.negative = 0, E = S.sub(this), this.negative = 1, E) : this.length > S.length ? this.clone().iadd(S) : S.clone().iadd(this);
    }, p.prototype.isub = function(S) {
      if (S.negative !== 0) {
        S.negative = 0;
        var E = this.iadd(S);
        return S.negative = 1, E._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(S), this.negative = 1, this._normSign();
      var I = this.cmp(S);
      if (I === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var M, $;
      I > 0 ? (M = this, $ = S) : (M = S, $ = this);
      for (var U = 0, Y = 0; Y < $.length; Y++)
        E = (M.words[Y] | 0) - ($.words[Y] | 0) + U, U = E >> 26, this.words[Y] = E & 67108863;
      for (; U !== 0 && Y < M.length; Y++)
        E = (M.words[Y] | 0) + U, U = E >> 26, this.words[Y] = E & 67108863;
      if (U === 0 && Y < M.length && M !== this)
        for (; Y < M.length; Y++)
          this.words[Y] = M.words[Y];
      return this.length = Math.max(this.length, Y), M !== this && (this.negative = 1), this.strip();
    }, p.prototype.sub = function(S) {
      return this.clone().isub(S);
    };
    function X(C, S, E) {
      E.negative = S.negative ^ C.negative;
      var I = C.length + S.length | 0;
      E.length = I, I = I - 1 | 0;
      var M = C.words[0] | 0, $ = S.words[0] | 0, U = M * $, Y = U & 67108863, L = U / 67108864 | 0;
      E.words[0] = Y;
      for (var T = 1; T < I; T++) {
        for (var B = L >>> 26, te = L & 67108863, pe = Math.min(T, S.length - 1), Ie = Math.max(0, T - C.length + 1); Ie <= pe; Ie++) {
          var $e = T - Ie | 0;
          M = C.words[$e] | 0, $ = S.words[Ie] | 0, U = M * $ + te, B += U / 67108864 | 0, te = U & 67108863;
        }
        E.words[T] = te | 0, L = B | 0;
      }
      return L !== 0 ? E.words[T] = L | 0 : E.length--, E.strip();
    }
    var ae = function(S, E, I) {
      var M = S.words, $ = E.words, U = I.words, Y = 0, L, T, B, te = M[0] | 0, pe = te & 8191, Ie = te >>> 13, $e = M[1] | 0, ve = $e & 8191, he = $e >>> 13, Oe = M[2] | 0, Ae = Oe & 8191, Ue = Oe >>> 13, oe = M[3] | 0, A = oe & 8191, re = oe >>> 13, le = M[4] | 0, Ne = le & 8191, Pe = le >>> 13, Fe = M[5] | 0, je = Fe & 8191, qe = Fe >>> 13, yt = M[6] | 0, Xe = yt & 8191, Ge = yt >>> 13, H = M[7] | 0, ye = H & 8191, Ee = H >>> 13, We = M[8] | 0, we = We & 8191, V = We >>> 13, _e = M[9] | 0, ue = _e & 8191, ce = _e >>> 13, me = $[0] | 0, Ce = me & 8191, Be = me >>> 13, ze = $[1] | 0, Je = ze & 8191, Ze = ze >>> 13, Ke = $[2] | 0, x = Ke & 8191, se = Ke >>> 13, ge = $[3] | 0, xe = ge & 8191, Me = ge >>> 13, Ye = $[4] | 0, et = Ye & 8191, dt = Ye >>> 13, St = $[5] | 0, tt = St & 8191, at = St >>> 13, kt = $[6] | 0, rt = kt & 8191, ut = kt >>> 13, wt = $[7] | 0, nt = wt & 8191, it = wt >>> 13, bt = $[8] | 0, ot = bt & 8191, ct = bt >>> 13, Pt = $[9] | 0, st = Pt & 8191, lt = Pt >>> 13;
      I.negative = S.negative ^ E.negative, I.length = 19, L = Math.imul(pe, Ce), T = Math.imul(pe, Be), T = T + Math.imul(Ie, Ce) | 0, B = Math.imul(Ie, Be);
      var It = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (It >>> 26) | 0, It &= 67108863, L = Math.imul(ve, Ce), T = Math.imul(ve, Be), T = T + Math.imul(he, Ce) | 0, B = Math.imul(he, Be), L = L + Math.imul(pe, Je) | 0, T = T + Math.imul(pe, Ze) | 0, T = T + Math.imul(Ie, Je) | 0, B = B + Math.imul(Ie, Ze) | 0;
      var Rt = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (Rt >>> 26) | 0, Rt &= 67108863, L = Math.imul(Ae, Ce), T = Math.imul(Ae, Be), T = T + Math.imul(Ue, Ce) | 0, B = Math.imul(Ue, Be), L = L + Math.imul(ve, Je) | 0, T = T + Math.imul(ve, Ze) | 0, T = T + Math.imul(he, Je) | 0, B = B + Math.imul(he, Ze) | 0, L = L + Math.imul(pe, x) | 0, T = T + Math.imul(pe, se) | 0, T = T + Math.imul(Ie, x) | 0, B = B + Math.imul(Ie, se) | 0;
      var Ve = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, L = Math.imul(A, Ce), T = Math.imul(A, Be), T = T + Math.imul(re, Ce) | 0, B = Math.imul(re, Be), L = L + Math.imul(Ae, Je) | 0, T = T + Math.imul(Ae, Ze) | 0, T = T + Math.imul(Ue, Je) | 0, B = B + Math.imul(Ue, Ze) | 0, L = L + Math.imul(ve, x) | 0, T = T + Math.imul(ve, se) | 0, T = T + Math.imul(he, x) | 0, B = B + Math.imul(he, se) | 0, L = L + Math.imul(pe, xe) | 0, T = T + Math.imul(pe, Me) | 0, T = T + Math.imul(Ie, xe) | 0, B = B + Math.imul(Ie, Me) | 0;
      var He = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, L = Math.imul(Ne, Ce), T = Math.imul(Ne, Be), T = T + Math.imul(Pe, Ce) | 0, B = Math.imul(Pe, Be), L = L + Math.imul(A, Je) | 0, T = T + Math.imul(A, Ze) | 0, T = T + Math.imul(re, Je) | 0, B = B + Math.imul(re, Ze) | 0, L = L + Math.imul(Ae, x) | 0, T = T + Math.imul(Ae, se) | 0, T = T + Math.imul(Ue, x) | 0, B = B + Math.imul(Ue, se) | 0, L = L + Math.imul(ve, xe) | 0, T = T + Math.imul(ve, Me) | 0, T = T + Math.imul(he, xe) | 0, B = B + Math.imul(he, Me) | 0, L = L + Math.imul(pe, et) | 0, T = T + Math.imul(pe, dt) | 0, T = T + Math.imul(Ie, et) | 0, B = B + Math.imul(Ie, dt) | 0;
      var Qe = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, L = Math.imul(je, Ce), T = Math.imul(je, Be), T = T + Math.imul(qe, Ce) | 0, B = Math.imul(qe, Be), L = L + Math.imul(Ne, Je) | 0, T = T + Math.imul(Ne, Ze) | 0, T = T + Math.imul(Pe, Je) | 0, B = B + Math.imul(Pe, Ze) | 0, L = L + Math.imul(A, x) | 0, T = T + Math.imul(A, se) | 0, T = T + Math.imul(re, x) | 0, B = B + Math.imul(re, se) | 0, L = L + Math.imul(Ae, xe) | 0, T = T + Math.imul(Ae, Me) | 0, T = T + Math.imul(Ue, xe) | 0, B = B + Math.imul(Ue, Me) | 0, L = L + Math.imul(ve, et) | 0, T = T + Math.imul(ve, dt) | 0, T = T + Math.imul(he, et) | 0, B = B + Math.imul(he, dt) | 0, L = L + Math.imul(pe, tt) | 0, T = T + Math.imul(pe, at) | 0, T = T + Math.imul(Ie, tt) | 0, B = B + Math.imul(Ie, at) | 0;
      var pt = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (pt >>> 26) | 0, pt &= 67108863, L = Math.imul(Xe, Ce), T = Math.imul(Xe, Be), T = T + Math.imul(Ge, Ce) | 0, B = Math.imul(Ge, Be), L = L + Math.imul(je, Je) | 0, T = T + Math.imul(je, Ze) | 0, T = T + Math.imul(qe, Je) | 0, B = B + Math.imul(qe, Ze) | 0, L = L + Math.imul(Ne, x) | 0, T = T + Math.imul(Ne, se) | 0, T = T + Math.imul(Pe, x) | 0, B = B + Math.imul(Pe, se) | 0, L = L + Math.imul(A, xe) | 0, T = T + Math.imul(A, Me) | 0, T = T + Math.imul(re, xe) | 0, B = B + Math.imul(re, Me) | 0, L = L + Math.imul(Ae, et) | 0, T = T + Math.imul(Ae, dt) | 0, T = T + Math.imul(Ue, et) | 0, B = B + Math.imul(Ue, dt) | 0, L = L + Math.imul(ve, tt) | 0, T = T + Math.imul(ve, at) | 0, T = T + Math.imul(he, tt) | 0, B = B + Math.imul(he, at) | 0, L = L + Math.imul(pe, rt) | 0, T = T + Math.imul(pe, ut) | 0, T = T + Math.imul(Ie, rt) | 0, B = B + Math.imul(Ie, ut) | 0;
      var mt = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (mt >>> 26) | 0, mt &= 67108863, L = Math.imul(ye, Ce), T = Math.imul(ye, Be), T = T + Math.imul(Ee, Ce) | 0, B = Math.imul(Ee, Be), L = L + Math.imul(Xe, Je) | 0, T = T + Math.imul(Xe, Ze) | 0, T = T + Math.imul(Ge, Je) | 0, B = B + Math.imul(Ge, Ze) | 0, L = L + Math.imul(je, x) | 0, T = T + Math.imul(je, se) | 0, T = T + Math.imul(qe, x) | 0, B = B + Math.imul(qe, se) | 0, L = L + Math.imul(Ne, xe) | 0, T = T + Math.imul(Ne, Me) | 0, T = T + Math.imul(Pe, xe) | 0, B = B + Math.imul(Pe, Me) | 0, L = L + Math.imul(A, et) | 0, T = T + Math.imul(A, dt) | 0, T = T + Math.imul(re, et) | 0, B = B + Math.imul(re, dt) | 0, L = L + Math.imul(Ae, tt) | 0, T = T + Math.imul(Ae, at) | 0, T = T + Math.imul(Ue, tt) | 0, B = B + Math.imul(Ue, at) | 0, L = L + Math.imul(ve, rt) | 0, T = T + Math.imul(ve, ut) | 0, T = T + Math.imul(he, rt) | 0, B = B + Math.imul(he, ut) | 0, L = L + Math.imul(pe, nt) | 0, T = T + Math.imul(pe, it) | 0, T = T + Math.imul(Ie, nt) | 0, B = B + Math.imul(Ie, it) | 0;
      var vt = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, L = Math.imul(we, Ce), T = Math.imul(we, Be), T = T + Math.imul(V, Ce) | 0, B = Math.imul(V, Be), L = L + Math.imul(ye, Je) | 0, T = T + Math.imul(ye, Ze) | 0, T = T + Math.imul(Ee, Je) | 0, B = B + Math.imul(Ee, Ze) | 0, L = L + Math.imul(Xe, x) | 0, T = T + Math.imul(Xe, se) | 0, T = T + Math.imul(Ge, x) | 0, B = B + Math.imul(Ge, se) | 0, L = L + Math.imul(je, xe) | 0, T = T + Math.imul(je, Me) | 0, T = T + Math.imul(qe, xe) | 0, B = B + Math.imul(qe, Me) | 0, L = L + Math.imul(Ne, et) | 0, T = T + Math.imul(Ne, dt) | 0, T = T + Math.imul(Pe, et) | 0, B = B + Math.imul(Pe, dt) | 0, L = L + Math.imul(A, tt) | 0, T = T + Math.imul(A, at) | 0, T = T + Math.imul(re, tt) | 0, B = B + Math.imul(re, at) | 0, L = L + Math.imul(Ae, rt) | 0, T = T + Math.imul(Ae, ut) | 0, T = T + Math.imul(Ue, rt) | 0, B = B + Math.imul(Ue, ut) | 0, L = L + Math.imul(ve, nt) | 0, T = T + Math.imul(ve, it) | 0, T = T + Math.imul(he, nt) | 0, B = B + Math.imul(he, it) | 0, L = L + Math.imul(pe, ot) | 0, T = T + Math.imul(pe, ct) | 0, T = T + Math.imul(Ie, ot) | 0, B = B + Math.imul(Ie, ct) | 0;
      var ht = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (ht >>> 26) | 0, ht &= 67108863, L = Math.imul(ue, Ce), T = Math.imul(ue, Be), T = T + Math.imul(ce, Ce) | 0, B = Math.imul(ce, Be), L = L + Math.imul(we, Je) | 0, T = T + Math.imul(we, Ze) | 0, T = T + Math.imul(V, Je) | 0, B = B + Math.imul(V, Ze) | 0, L = L + Math.imul(ye, x) | 0, T = T + Math.imul(ye, se) | 0, T = T + Math.imul(Ee, x) | 0, B = B + Math.imul(Ee, se) | 0, L = L + Math.imul(Xe, xe) | 0, T = T + Math.imul(Xe, Me) | 0, T = T + Math.imul(Ge, xe) | 0, B = B + Math.imul(Ge, Me) | 0, L = L + Math.imul(je, et) | 0, T = T + Math.imul(je, dt) | 0, T = T + Math.imul(qe, et) | 0, B = B + Math.imul(qe, dt) | 0, L = L + Math.imul(Ne, tt) | 0, T = T + Math.imul(Ne, at) | 0, T = T + Math.imul(Pe, tt) | 0, B = B + Math.imul(Pe, at) | 0, L = L + Math.imul(A, rt) | 0, T = T + Math.imul(A, ut) | 0, T = T + Math.imul(re, rt) | 0, B = B + Math.imul(re, ut) | 0, L = L + Math.imul(Ae, nt) | 0, T = T + Math.imul(Ae, it) | 0, T = T + Math.imul(Ue, nt) | 0, B = B + Math.imul(Ue, it) | 0, L = L + Math.imul(ve, ot) | 0, T = T + Math.imul(ve, ct) | 0, T = T + Math.imul(he, ot) | 0, B = B + Math.imul(he, ct) | 0, L = L + Math.imul(pe, st) | 0, T = T + Math.imul(pe, lt) | 0, T = T + Math.imul(Ie, st) | 0, B = B + Math.imul(Ie, lt) | 0;
      var Et = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, L = Math.imul(ue, Je), T = Math.imul(ue, Ze), T = T + Math.imul(ce, Je) | 0, B = Math.imul(ce, Ze), L = L + Math.imul(we, x) | 0, T = T + Math.imul(we, se) | 0, T = T + Math.imul(V, x) | 0, B = B + Math.imul(V, se) | 0, L = L + Math.imul(ye, xe) | 0, T = T + Math.imul(ye, Me) | 0, T = T + Math.imul(Ee, xe) | 0, B = B + Math.imul(Ee, Me) | 0, L = L + Math.imul(Xe, et) | 0, T = T + Math.imul(Xe, dt) | 0, T = T + Math.imul(Ge, et) | 0, B = B + Math.imul(Ge, dt) | 0, L = L + Math.imul(je, tt) | 0, T = T + Math.imul(je, at) | 0, T = T + Math.imul(qe, tt) | 0, B = B + Math.imul(qe, at) | 0, L = L + Math.imul(Ne, rt) | 0, T = T + Math.imul(Ne, ut) | 0, T = T + Math.imul(Pe, rt) | 0, B = B + Math.imul(Pe, ut) | 0, L = L + Math.imul(A, nt) | 0, T = T + Math.imul(A, it) | 0, T = T + Math.imul(re, nt) | 0, B = B + Math.imul(re, it) | 0, L = L + Math.imul(Ae, ot) | 0, T = T + Math.imul(Ae, ct) | 0, T = T + Math.imul(Ue, ot) | 0, B = B + Math.imul(Ue, ct) | 0, L = L + Math.imul(ve, st) | 0, T = T + Math.imul(ve, lt) | 0, T = T + Math.imul(he, st) | 0, B = B + Math.imul(he, lt) | 0;
      var Tt = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (Tt >>> 26) | 0, Tt &= 67108863, L = Math.imul(ue, x), T = Math.imul(ue, se), T = T + Math.imul(ce, x) | 0, B = Math.imul(ce, se), L = L + Math.imul(we, xe) | 0, T = T + Math.imul(we, Me) | 0, T = T + Math.imul(V, xe) | 0, B = B + Math.imul(V, Me) | 0, L = L + Math.imul(ye, et) | 0, T = T + Math.imul(ye, dt) | 0, T = T + Math.imul(Ee, et) | 0, B = B + Math.imul(Ee, dt) | 0, L = L + Math.imul(Xe, tt) | 0, T = T + Math.imul(Xe, at) | 0, T = T + Math.imul(Ge, tt) | 0, B = B + Math.imul(Ge, at) | 0, L = L + Math.imul(je, rt) | 0, T = T + Math.imul(je, ut) | 0, T = T + Math.imul(qe, rt) | 0, B = B + Math.imul(qe, ut) | 0, L = L + Math.imul(Ne, nt) | 0, T = T + Math.imul(Ne, it) | 0, T = T + Math.imul(Pe, nt) | 0, B = B + Math.imul(Pe, it) | 0, L = L + Math.imul(A, ot) | 0, T = T + Math.imul(A, ct) | 0, T = T + Math.imul(re, ot) | 0, B = B + Math.imul(re, ct) | 0, L = L + Math.imul(Ae, st) | 0, T = T + Math.imul(Ae, lt) | 0, T = T + Math.imul(Ue, st) | 0, B = B + Math.imul(Ue, lt) | 0;
      var Ot = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (Ot >>> 26) | 0, Ot &= 67108863, L = Math.imul(ue, xe), T = Math.imul(ue, Me), T = T + Math.imul(ce, xe) | 0, B = Math.imul(ce, Me), L = L + Math.imul(we, et) | 0, T = T + Math.imul(we, dt) | 0, T = T + Math.imul(V, et) | 0, B = B + Math.imul(V, dt) | 0, L = L + Math.imul(ye, tt) | 0, T = T + Math.imul(ye, at) | 0, T = T + Math.imul(Ee, tt) | 0, B = B + Math.imul(Ee, at) | 0, L = L + Math.imul(Xe, rt) | 0, T = T + Math.imul(Xe, ut) | 0, T = T + Math.imul(Ge, rt) | 0, B = B + Math.imul(Ge, ut) | 0, L = L + Math.imul(je, nt) | 0, T = T + Math.imul(je, it) | 0, T = T + Math.imul(qe, nt) | 0, B = B + Math.imul(qe, it) | 0, L = L + Math.imul(Ne, ot) | 0, T = T + Math.imul(Ne, ct) | 0, T = T + Math.imul(Pe, ot) | 0, B = B + Math.imul(Pe, ct) | 0, L = L + Math.imul(A, st) | 0, T = T + Math.imul(A, lt) | 0, T = T + Math.imul(re, st) | 0, B = B + Math.imul(re, lt) | 0;
      var Nt = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, L = Math.imul(ue, et), T = Math.imul(ue, dt), T = T + Math.imul(ce, et) | 0, B = Math.imul(ce, dt), L = L + Math.imul(we, tt) | 0, T = T + Math.imul(we, at) | 0, T = T + Math.imul(V, tt) | 0, B = B + Math.imul(V, at) | 0, L = L + Math.imul(ye, rt) | 0, T = T + Math.imul(ye, ut) | 0, T = T + Math.imul(Ee, rt) | 0, B = B + Math.imul(Ee, ut) | 0, L = L + Math.imul(Xe, nt) | 0, T = T + Math.imul(Xe, it) | 0, T = T + Math.imul(Ge, nt) | 0, B = B + Math.imul(Ge, it) | 0, L = L + Math.imul(je, ot) | 0, T = T + Math.imul(je, ct) | 0, T = T + Math.imul(qe, ot) | 0, B = B + Math.imul(qe, ct) | 0, L = L + Math.imul(Ne, st) | 0, T = T + Math.imul(Ne, lt) | 0, T = T + Math.imul(Pe, st) | 0, B = B + Math.imul(Pe, lt) | 0;
      var At = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, L = Math.imul(ue, tt), T = Math.imul(ue, at), T = T + Math.imul(ce, tt) | 0, B = Math.imul(ce, at), L = L + Math.imul(we, rt) | 0, T = T + Math.imul(we, ut) | 0, T = T + Math.imul(V, rt) | 0, B = B + Math.imul(V, ut) | 0, L = L + Math.imul(ye, nt) | 0, T = T + Math.imul(ye, it) | 0, T = T + Math.imul(Ee, nt) | 0, B = B + Math.imul(Ee, it) | 0, L = L + Math.imul(Xe, ot) | 0, T = T + Math.imul(Xe, ct) | 0, T = T + Math.imul(Ge, ot) | 0, B = B + Math.imul(Ge, ct) | 0, L = L + Math.imul(je, st) | 0, T = T + Math.imul(je, lt) | 0, T = T + Math.imul(qe, st) | 0, B = B + Math.imul(qe, lt) | 0;
      var Mt = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (Mt >>> 26) | 0, Mt &= 67108863, L = Math.imul(ue, rt), T = Math.imul(ue, ut), T = T + Math.imul(ce, rt) | 0, B = Math.imul(ce, ut), L = L + Math.imul(we, nt) | 0, T = T + Math.imul(we, it) | 0, T = T + Math.imul(V, nt) | 0, B = B + Math.imul(V, it) | 0, L = L + Math.imul(ye, ot) | 0, T = T + Math.imul(ye, ct) | 0, T = T + Math.imul(Ee, ot) | 0, B = B + Math.imul(Ee, ct) | 0, L = L + Math.imul(Xe, st) | 0, T = T + Math.imul(Xe, lt) | 0, T = T + Math.imul(Ge, st) | 0, B = B + Math.imul(Ge, lt) | 0;
      var $t = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + ($t >>> 26) | 0, $t &= 67108863, L = Math.imul(ue, nt), T = Math.imul(ue, it), T = T + Math.imul(ce, nt) | 0, B = Math.imul(ce, it), L = L + Math.imul(we, ot) | 0, T = T + Math.imul(we, ct) | 0, T = T + Math.imul(V, ot) | 0, B = B + Math.imul(V, ct) | 0, L = L + Math.imul(ye, st) | 0, T = T + Math.imul(ye, lt) | 0, T = T + Math.imul(Ee, st) | 0, B = B + Math.imul(Ee, lt) | 0;
      var Bt = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, L = Math.imul(ue, ot), T = Math.imul(ue, ct), T = T + Math.imul(ce, ot) | 0, B = Math.imul(ce, ct), L = L + Math.imul(we, st) | 0, T = T + Math.imul(we, lt) | 0, T = T + Math.imul(V, st) | 0, B = B + Math.imul(V, lt) | 0;
      var Ut = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (Ut >>> 26) | 0, Ut &= 67108863, L = Math.imul(ue, st), T = Math.imul(ue, lt), T = T + Math.imul(ce, st) | 0, B = Math.imul(ce, lt);
      var xt = (Y + L | 0) + ((T & 8191) << 13) | 0;
      return Y = (B + (T >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, U[0] = It, U[1] = Rt, U[2] = Ve, U[3] = He, U[4] = Qe, U[5] = pt, U[6] = mt, U[7] = vt, U[8] = ht, U[9] = Et, U[10] = Tt, U[11] = Ot, U[12] = Nt, U[13] = At, U[14] = Mt, U[15] = $t, U[16] = Bt, U[17] = Ut, U[18] = xt, Y !== 0 && (U[19] = Y, I.length++), I;
    };
    Math.imul || (ae = X);
    function Q(C, S, E) {
      E.negative = S.negative ^ C.negative, E.length = C.length + S.length;
      for (var I = 0, M = 0, $ = 0; $ < E.length - 1; $++) {
        var U = M;
        M = 0;
        for (var Y = I & 67108863, L = Math.min($, S.length - 1), T = Math.max(0, $ - C.length + 1); T <= L; T++) {
          var B = $ - T, te = C.words[B] | 0, pe = S.words[T] | 0, Ie = te * pe, $e = Ie & 67108863;
          U = U + (Ie / 67108864 | 0) | 0, $e = $e + Y | 0, Y = $e & 67108863, U = U + ($e >>> 26) | 0, M += U >>> 26, U &= 67108863;
        }
        E.words[$] = Y, I = U, U = M;
      }
      return I !== 0 ? E.words[$] = I : E.length--, E.strip();
    }
    function ne(C, S, E) {
      var I = new Z();
      return I.mulp(C, S, E);
    }
    p.prototype.mulTo = function(S, E) {
      var I, M = this.length + S.length;
      return this.length === 10 && S.length === 10 ? I = ae(this, S, E) : M < 63 ? I = X(this, S, E) : M < 1024 ? I = Q(this, S, E) : I = ne(this, S, E), I;
    };
    function Z(C, S) {
      this.x = C, this.y = S;
    }
    Z.prototype.makeRBT = function(S) {
      for (var E = new Array(S), I = p.prototype._countBits(S) - 1, M = 0; M < S; M++)
        E[M] = this.revBin(M, I, S);
      return E;
    }, Z.prototype.revBin = function(S, E, I) {
      if (S === 0 || S === I - 1)
        return S;
      for (var M = 0, $ = 0; $ < E; $++)
        M |= (S & 1) << E - $ - 1, S >>= 1;
      return M;
    }, Z.prototype.permute = function(S, E, I, M, $, U) {
      for (var Y = 0; Y < U; Y++)
        M[Y] = E[S[Y]], $[Y] = I[S[Y]];
    }, Z.prototype.transform = function(S, E, I, M, $, U) {
      this.permute(U, S, E, I, M, $);
      for (var Y = 1; Y < $; Y <<= 1)
        for (var L = Y << 1, T = Math.cos(2 * Math.PI / L), B = Math.sin(2 * Math.PI / L), te = 0; te < $; te += L)
          for (var pe = T, Ie = B, $e = 0; $e < Y; $e++) {
            var ve = I[te + $e], he = M[te + $e], Oe = I[te + $e + Y], Ae = M[te + $e + Y], Ue = pe * Oe - Ie * Ae;
            Ae = pe * Ae + Ie * Oe, Oe = Ue, I[te + $e] = ve + Oe, M[te + $e] = he + Ae, I[te + $e + Y] = ve - Oe, M[te + $e + Y] = he - Ae, $e !== L && (Ue = T * pe - B * Ie, Ie = T * Ie + B * pe, pe = Ue);
          }
    }, Z.prototype.guessLen13b = function(S, E) {
      var I = Math.max(E, S) | 1, M = I & 1, $ = 0;
      for (I = I / 2 | 0; I; I = I >>> 1)
        $++;
      return 1 << $ + 1 + M;
    }, Z.prototype.conjugate = function(S, E, I) {
      if (!(I <= 1))
        for (var M = 0; M < I / 2; M++) {
          var $ = S[M];
          S[M] = S[I - M - 1], S[I - M - 1] = $, $ = E[M], E[M] = -E[I - M - 1], E[I - M - 1] = -$;
        }
    }, Z.prototype.normalize13b = function(S, E) {
      for (var I = 0, M = 0; M < E / 2; M++) {
        var $ = Math.round(S[2 * M + 1] / E) * 8192 + Math.round(S[2 * M] / E) + I;
        S[M] = $ & 67108863, $ < 67108864 ? I = 0 : I = $ / 67108864 | 0;
      }
      return S;
    }, Z.prototype.convert13b = function(S, E, I, M) {
      for (var $ = 0, U = 0; U < E; U++)
        $ = $ + (S[U] | 0), I[2 * U] = $ & 8191, $ = $ >>> 13, I[2 * U + 1] = $ & 8191, $ = $ >>> 13;
      for (U = 2 * E; U < M; ++U)
        I[U] = 0;
      l($ === 0), l(($ & -8192) === 0);
    }, Z.prototype.stub = function(S) {
      for (var E = new Array(S), I = 0; I < S; I++)
        E[I] = 0;
      return E;
    }, Z.prototype.mulp = function(S, E, I) {
      var M = 2 * this.guessLen13b(S.length, E.length), $ = this.makeRBT(M), U = this.stub(M), Y = new Array(M), L = new Array(M), T = new Array(M), B = new Array(M), te = new Array(M), pe = new Array(M), Ie = I.words;
      Ie.length = M, this.convert13b(S.words, S.length, Y, M), this.convert13b(E.words, E.length, B, M), this.transform(Y, U, L, T, M, $), this.transform(B, U, te, pe, M, $);
      for (var $e = 0; $e < M; $e++) {
        var ve = L[$e] * te[$e] - T[$e] * pe[$e];
        T[$e] = L[$e] * pe[$e] + T[$e] * te[$e], L[$e] = ve;
      }
      return this.conjugate(L, T, M), this.transform(L, T, Ie, U, M, $), this.conjugate(Ie, U, M), this.normalize13b(Ie, M), I.negative = S.negative ^ E.negative, I.length = S.length + E.length, I.strip();
    }, p.prototype.mul = function(S) {
      var E = new p(null);
      return E.words = new Array(this.length + S.length), this.mulTo(S, E);
    }, p.prototype.mulf = function(S) {
      var E = new p(null);
      return E.words = new Array(this.length + S.length), ne(this, S, E);
    }, p.prototype.imul = function(S) {
      return this.clone().mulTo(S, this);
    }, p.prototype.imuln = function(S) {
      l(typeof S == "number"), l(S < 67108864);
      for (var E = 0, I = 0; I < this.length; I++) {
        var M = (this.words[I] | 0) * S, $ = (M & 67108863) + (E & 67108863);
        E >>= 26, E += M / 67108864 | 0, E += $ >>> 26, this.words[I] = $ & 67108863;
      }
      return E !== 0 && (this.words[I] = E, this.length++), this;
    }, p.prototype.muln = function(S) {
      return this.clone().imuln(S);
    }, p.prototype.sqr = function() {
      return this.mul(this);
    }, p.prototype.isqr = function() {
      return this.imul(this.clone());
    }, p.prototype.pow = function(S) {
      var E = ee(S);
      if (E.length === 0)
        return new p(1);
      for (var I = this, M = 0; M < E.length && E[M] === 0; M++, I = I.sqr())
        ;
      if (++M < E.length)
        for (var $ = I.sqr(); M < E.length; M++, $ = $.sqr())
          E[M] !== 0 && (I = I.mul($));
      return I;
    }, p.prototype.iushln = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = S % 26, I = (S - E) / 26, M = 67108863 >>> 26 - E << 26 - E, $;
      if (E !== 0) {
        var U = 0;
        for ($ = 0; $ < this.length; $++) {
          var Y = this.words[$] & M, L = (this.words[$] | 0) - Y << E;
          this.words[$] = L | U, U = Y >>> 26 - E;
        }
        U && (this.words[$] = U, this.length++);
      }
      if (I !== 0) {
        for ($ = this.length - 1; $ >= 0; $--)
          this.words[$ + I] = this.words[$];
        for ($ = 0; $ < I; $++)
          this.words[$] = 0;
        this.length += I;
      }
      return this.strip();
    }, p.prototype.ishln = function(S) {
      return l(this.negative === 0), this.iushln(S);
    }, p.prototype.iushrn = function(S, E, I) {
      l(typeof S == "number" && S >= 0);
      var M;
      E ? M = (E - E % 26) / 26 : M = 0;
      var $ = S % 26, U = Math.min((S - $) / 26, this.length), Y = 67108863 ^ 67108863 >>> $ << $, L = I;
      if (M -= U, M = Math.max(0, M), L) {
        for (var T = 0; T < U; T++)
          L.words[T] = this.words[T];
        L.length = U;
      }
      if (U !== 0)
        if (this.length > U)
          for (this.length -= U, T = 0; T < this.length; T++)
            this.words[T] = this.words[T + U];
        else
          this.words[0] = 0, this.length = 1;
      var B = 0;
      for (T = this.length - 1; T >= 0 && (B !== 0 || T >= M); T--) {
        var te = this.words[T] | 0;
        this.words[T] = B << 26 - $ | te >>> $, B = te & Y;
      }
      return L && B !== 0 && (L.words[L.length++] = B), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, p.prototype.ishrn = function(S, E, I) {
      return l(this.negative === 0), this.iushrn(S, E, I);
    }, p.prototype.shln = function(S) {
      return this.clone().ishln(S);
    }, p.prototype.ushln = function(S) {
      return this.clone().iushln(S);
    }, p.prototype.shrn = function(S) {
      return this.clone().ishrn(S);
    }, p.prototype.ushrn = function(S) {
      return this.clone().iushrn(S);
    }, p.prototype.testn = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = S % 26, I = (S - E) / 26, M = 1 << E;
      if (this.length <= I)
        return !1;
      var $ = this.words[I];
      return !!($ & M);
    }, p.prototype.imaskn = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = S % 26, I = (S - E) / 26;
      if (l(this.negative === 0, "imaskn works only with positive numbers"), this.length <= I)
        return this;
      if (E !== 0 && I++, this.length = Math.min(I, this.length), E !== 0) {
        var M = 67108863 ^ 67108863 >>> E << E;
        this.words[this.length - 1] &= M;
      }
      return this.strip();
    }, p.prototype.maskn = function(S) {
      return this.clone().imaskn(S);
    }, p.prototype.iaddn = function(S) {
      return l(typeof S == "number"), l(S < 67108864), S < 0 ? this.isubn(-S) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < S ? (this.words[0] = S - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(S), this.negative = 1, this) : this._iaddn(S);
    }, p.prototype._iaddn = function(S) {
      this.words[0] += S;
      for (var E = 0; E < this.length && this.words[E] >= 67108864; E++)
        this.words[E] -= 67108864, E === this.length - 1 ? this.words[E + 1] = 1 : this.words[E + 1]++;
      return this.length = Math.max(this.length, E + 1), this;
    }, p.prototype.isubn = function(S) {
      if (l(typeof S == "number"), l(S < 67108864), S < 0)
        return this.iaddn(-S);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(S), this.negative = 1, this;
      if (this.words[0] -= S, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var E = 0; E < this.length && this.words[E] < 0; E++)
          this.words[E] += 67108864, this.words[E + 1] -= 1;
      return this.strip();
    }, p.prototype.addn = function(S) {
      return this.clone().iaddn(S);
    }, p.prototype.subn = function(S) {
      return this.clone().isubn(S);
    }, p.prototype.iabs = function() {
      return this.negative = 0, this;
    }, p.prototype.abs = function() {
      return this.clone().iabs();
    }, p.prototype._ishlnsubmul = function(S, E, I) {
      var M = S.length + I, $;
      this._expand(M);
      var U, Y = 0;
      for ($ = 0; $ < S.length; $++) {
        U = (this.words[$ + I] | 0) + Y;
        var L = (S.words[$] | 0) * E;
        U -= L & 67108863, Y = (U >> 26) - (L / 67108864 | 0), this.words[$ + I] = U & 67108863;
      }
      for (; $ < this.length - I; $++)
        U = (this.words[$ + I] | 0) + Y, Y = U >> 26, this.words[$ + I] = U & 67108863;
      if (Y === 0)
        return this.strip();
      for (l(Y === -1), Y = 0, $ = 0; $ < this.length; $++)
        U = -(this.words[$] | 0) + Y, Y = U >> 26, this.words[$] = U & 67108863;
      return this.negative = 1, this.strip();
    }, p.prototype._wordDiv = function(S, E) {
      var I = this.length - S.length, M = this.clone(), $ = S, U = $.words[$.length - 1] | 0, Y = this._countBits(U);
      I = 26 - Y, I !== 0 && ($ = $.ushln(I), M.iushln(I), U = $.words[$.length - 1] | 0);
      var L = M.length - $.length, T;
      if (E !== "mod") {
        T = new p(null), T.length = L + 1, T.words = new Array(T.length);
        for (var B = 0; B < T.length; B++)
          T.words[B] = 0;
      }
      var te = M.clone()._ishlnsubmul($, 1, L);
      te.negative === 0 && (M = te, T && (T.words[L] = 1));
      for (var pe = L - 1; pe >= 0; pe--) {
        var Ie = (M.words[$.length + pe] | 0) * 67108864 + (M.words[$.length + pe - 1] | 0);
        for (Ie = Math.min(Ie / U | 0, 67108863), M._ishlnsubmul($, Ie, pe); M.negative !== 0; )
          Ie--, M.negative = 0, M._ishlnsubmul($, 1, pe), M.isZero() || (M.negative ^= 1);
        T && (T.words[pe] = Ie);
      }
      return T && T.strip(), M.strip(), E !== "div" && I !== 0 && M.iushrn(I), {
        div: T || null,
        mod: M
      };
    }, p.prototype.divmod = function(S, E, I) {
      if (l(!S.isZero()), this.isZero())
        return {
          div: new p(0),
          mod: new p(0)
        };
      var M, $, U;
      return this.negative !== 0 && S.negative === 0 ? (U = this.neg().divmod(S, E), E !== "mod" && (M = U.div.neg()), E !== "div" && ($ = U.mod.neg(), I && $.negative !== 0 && $.iadd(S)), {
        div: M,
        mod: $
      }) : this.negative === 0 && S.negative !== 0 ? (U = this.divmod(S.neg(), E), E !== "mod" && (M = U.div.neg()), {
        div: M,
        mod: U.mod
      }) : this.negative & S.negative ? (U = this.neg().divmod(S.neg(), E), E !== "div" && ($ = U.mod.neg(), I && $.negative !== 0 && $.isub(S)), {
        div: U.div,
        mod: $
      }) : S.length > this.length || this.cmp(S) < 0 ? {
        div: new p(0),
        mod: this
      } : S.length === 1 ? E === "div" ? {
        div: this.divn(S.words[0]),
        mod: null
      } : E === "mod" ? {
        div: null,
        mod: new p(this.modn(S.words[0]))
      } : {
        div: this.divn(S.words[0]),
        mod: new p(this.modn(S.words[0]))
      } : this._wordDiv(S, E);
    }, p.prototype.div = function(S) {
      return this.divmod(S, "div", !1).div;
    }, p.prototype.mod = function(S) {
      return this.divmod(S, "mod", !1).mod;
    }, p.prototype.umod = function(S) {
      return this.divmod(S, "mod", !0).mod;
    }, p.prototype.divRound = function(S) {
      var E = this.divmod(S);
      if (E.mod.isZero())
        return E.div;
      var I = E.div.negative !== 0 ? E.mod.isub(S) : E.mod, M = S.ushrn(1), $ = S.andln(1), U = I.cmp(M);
      return U < 0 || $ === 1 && U === 0 ? E.div : E.div.negative !== 0 ? E.div.isubn(1) : E.div.iaddn(1);
    }, p.prototype.modn = function(S) {
      l(S <= 67108863);
      for (var E = (1 << 26) % S, I = 0, M = this.length - 1; M >= 0; M--)
        I = (E * I + (this.words[M] | 0)) % S;
      return I;
    }, p.prototype.idivn = function(S) {
      l(S <= 67108863);
      for (var E = 0, I = this.length - 1; I >= 0; I--) {
        var M = (this.words[I] | 0) + E * 67108864;
        this.words[I] = M / S | 0, E = M % S;
      }
      return this.strip();
    }, p.prototype.divn = function(S) {
      return this.clone().idivn(S);
    }, p.prototype.egcd = function(S) {
      l(S.negative === 0), l(!S.isZero());
      var E = this, I = S.clone();
      E.negative !== 0 ? E = E.umod(S) : E = E.clone();
      for (var M = new p(1), $ = new p(0), U = new p(0), Y = new p(1), L = 0; E.isEven() && I.isEven(); )
        E.iushrn(1), I.iushrn(1), ++L;
      for (var T = I.clone(), B = E.clone(); !E.isZero(); ) {
        for (var te = 0, pe = 1; !(E.words[0] & pe) && te < 26; ++te, pe <<= 1)
          ;
        if (te > 0)
          for (E.iushrn(te); te-- > 0; )
            (M.isOdd() || $.isOdd()) && (M.iadd(T), $.isub(B)), M.iushrn(1), $.iushrn(1);
        for (var Ie = 0, $e = 1; !(I.words[0] & $e) && Ie < 26; ++Ie, $e <<= 1)
          ;
        if (Ie > 0)
          for (I.iushrn(Ie); Ie-- > 0; )
            (U.isOdd() || Y.isOdd()) && (U.iadd(T), Y.isub(B)), U.iushrn(1), Y.iushrn(1);
        E.cmp(I) >= 0 ? (E.isub(I), M.isub(U), $.isub(Y)) : (I.isub(E), U.isub(M), Y.isub($));
      }
      return {
        a: U,
        b: Y,
        gcd: I.iushln(L)
      };
    }, p.prototype._invmp = function(S) {
      l(S.negative === 0), l(!S.isZero());
      var E = this, I = S.clone();
      E.negative !== 0 ? E = E.umod(S) : E = E.clone();
      for (var M = new p(1), $ = new p(0), U = I.clone(); E.cmpn(1) > 0 && I.cmpn(1) > 0; ) {
        for (var Y = 0, L = 1; !(E.words[0] & L) && Y < 26; ++Y, L <<= 1)
          ;
        if (Y > 0)
          for (E.iushrn(Y); Y-- > 0; )
            M.isOdd() && M.iadd(U), M.iushrn(1);
        for (var T = 0, B = 1; !(I.words[0] & B) && T < 26; ++T, B <<= 1)
          ;
        if (T > 0)
          for (I.iushrn(T); T-- > 0; )
            $.isOdd() && $.iadd(U), $.iushrn(1);
        E.cmp(I) >= 0 ? (E.isub(I), M.isub($)) : (I.isub(E), $.isub(M));
      }
      var te;
      return E.cmpn(1) === 0 ? te = M : te = $, te.cmpn(0) < 0 && te.iadd(S), te;
    }, p.prototype.gcd = function(S) {
      if (this.isZero())
        return S.abs();
      if (S.isZero())
        return this.abs();
      var E = this.clone(), I = S.clone();
      E.negative = 0, I.negative = 0;
      for (var M = 0; E.isEven() && I.isEven(); M++)
        E.iushrn(1), I.iushrn(1);
      do {
        for (; E.isEven(); )
          E.iushrn(1);
        for (; I.isEven(); )
          I.iushrn(1);
        var $ = E.cmp(I);
        if ($ < 0) {
          var U = E;
          E = I, I = U;
        } else if ($ === 0 || I.cmpn(1) === 0)
          break;
        E.isub(I);
      } while (!0);
      return I.iushln(M);
    }, p.prototype.invm = function(S) {
      return this.egcd(S).a.umod(S);
    }, p.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, p.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, p.prototype.andln = function(S) {
      return this.words[0] & S;
    }, p.prototype.bincn = function(S) {
      l(typeof S == "number");
      var E = S % 26, I = (S - E) / 26, M = 1 << E;
      if (this.length <= I)
        return this._expand(I + 1), this.words[I] |= M, this;
      for (var $ = M, U = I; $ !== 0 && U < this.length; U++) {
        var Y = this.words[U] | 0;
        Y += $, $ = Y >>> 26, Y &= 67108863, this.words[U] = Y;
      }
      return $ !== 0 && (this.words[U] = $, this.length++), this;
    }, p.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, p.prototype.cmpn = function(S) {
      var E = S < 0;
      if (this.negative !== 0 && !E)
        return -1;
      if (this.negative === 0 && E)
        return 1;
      this.strip();
      var I;
      if (this.length > 1)
        I = 1;
      else {
        E && (S = -S), l(S <= 67108863, "Number is too big");
        var M = this.words[0] | 0;
        I = M === S ? 0 : M < S ? -1 : 1;
      }
      return this.negative !== 0 ? -I | 0 : I;
    }, p.prototype.cmp = function(S) {
      if (this.negative !== 0 && S.negative === 0)
        return -1;
      if (this.negative === 0 && S.negative !== 0)
        return 1;
      var E = this.ucmp(S);
      return this.negative !== 0 ? -E | 0 : E;
    }, p.prototype.ucmp = function(S) {
      if (this.length > S.length)
        return 1;
      if (this.length < S.length)
        return -1;
      for (var E = 0, I = this.length - 1; I >= 0; I--) {
        var M = this.words[I] | 0, $ = S.words[I] | 0;
        if (M !== $) {
          M < $ ? E = -1 : M > $ && (E = 1);
          break;
        }
      }
      return E;
    }, p.prototype.gtn = function(S) {
      return this.cmpn(S) === 1;
    }, p.prototype.gt = function(S) {
      return this.cmp(S) === 1;
    }, p.prototype.gten = function(S) {
      return this.cmpn(S) >= 0;
    }, p.prototype.gte = function(S) {
      return this.cmp(S) >= 0;
    }, p.prototype.ltn = function(S) {
      return this.cmpn(S) === -1;
    }, p.prototype.lt = function(S) {
      return this.cmp(S) === -1;
    }, p.prototype.lten = function(S) {
      return this.cmpn(S) <= 0;
    }, p.prototype.lte = function(S) {
      return this.cmp(S) <= 0;
    }, p.prototype.eqn = function(S) {
      return this.cmpn(S) === 0;
    }, p.prototype.eq = function(S) {
      return this.cmp(S) === 0;
    }, p.red = function(S) {
      return new q(S);
    }, p.prototype.toRed = function(S) {
      return l(!this.red, "Already a number in reduction context"), l(this.negative === 0, "red works only with positives"), S.convertTo(this)._forceRed(S);
    }, p.prototype.fromRed = function() {
      return l(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, p.prototype._forceRed = function(S) {
      return this.red = S, this;
    }, p.prototype.forceRed = function(S) {
      return l(!this.red, "Already a number in reduction context"), this._forceRed(S);
    }, p.prototype.redAdd = function(S) {
      return l(this.red, "redAdd works only with red numbers"), this.red.add(this, S);
    }, p.prototype.redIAdd = function(S) {
      return l(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, S);
    }, p.prototype.redSub = function(S) {
      return l(this.red, "redSub works only with red numbers"), this.red.sub(this, S);
    }, p.prototype.redISub = function(S) {
      return l(this.red, "redISub works only with red numbers"), this.red.isub(this, S);
    }, p.prototype.redShl = function(S) {
      return l(this.red, "redShl works only with red numbers"), this.red.shl(this, S);
    }, p.prototype.redMul = function(S) {
      return l(this.red, "redMul works only with red numbers"), this.red._verify2(this, S), this.red.mul(this, S);
    }, p.prototype.redIMul = function(S) {
      return l(this.red, "redMul works only with red numbers"), this.red._verify2(this, S), this.red.imul(this, S);
    }, p.prototype.redSqr = function() {
      return l(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, p.prototype.redISqr = function() {
      return l(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, p.prototype.redSqrt = function() {
      return l(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, p.prototype.redInvm = function() {
      return l(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, p.prototype.redNeg = function() {
      return l(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, p.prototype.redPow = function(S) {
      return l(this.red && !S.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, S);
    };
    var de = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function fe(C, S) {
      this.name = C, this.p = new p(S, 16), this.n = this.p.bitLength(), this.k = new p(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    fe.prototype._tmp = function() {
      var S = new p(null);
      return S.words = new Array(Math.ceil(this.n / 13)), S;
    }, fe.prototype.ireduce = function(S) {
      var E = S, I;
      do
        this.split(E, this.tmp), E = this.imulK(E), E = E.iadd(this.tmp), I = E.bitLength();
      while (I > this.n);
      var M = I < this.n ? -1 : E.ucmp(this.p);
      return M === 0 ? (E.words[0] = 0, E.length = 1) : M > 0 ? E.isub(this.p) : E.strip !== void 0 ? E.strip() : E._strip(), E;
    }, fe.prototype.split = function(S, E) {
      S.iushrn(this.n, 0, E);
    }, fe.prototype.imulK = function(S) {
      return S.imul(this.k);
    };
    function Te() {
      fe.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    v(Te, fe), Te.prototype.split = function(S, E) {
      for (var I = 4194303, M = Math.min(S.length, 9), $ = 0; $ < M; $++)
        E.words[$] = S.words[$];
      if (E.length = M, S.length <= 9) {
        S.words[0] = 0, S.length = 1;
        return;
      }
      var U = S.words[9];
      for (E.words[E.length++] = U & I, $ = 10; $ < S.length; $++) {
        var Y = S.words[$] | 0;
        S.words[$ - 10] = (Y & I) << 4 | U >>> 22, U = Y;
      }
      U >>>= 22, S.words[$ - 10] = U, U === 0 && S.length > 10 ? S.length -= 10 : S.length -= 9;
    }, Te.prototype.imulK = function(S) {
      S.words[S.length] = 0, S.words[S.length + 1] = 0, S.length += 2;
      for (var E = 0, I = 0; I < S.length; I++) {
        var M = S.words[I] | 0;
        E += M * 977, S.words[I] = E & 67108863, E = M * 64 + (E / 67108864 | 0);
      }
      return S.words[S.length - 1] === 0 && (S.length--, S.words[S.length - 1] === 0 && S.length--), S;
    };
    function Re() {
      fe.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    v(Re, fe);
    function Le() {
      fe.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    v(Le, fe);
    function be() {
      fe.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    v(be, fe), be.prototype.imulK = function(S) {
      for (var E = 0, I = 0; I < S.length; I++) {
        var M = (S.words[I] | 0) * 19 + E, $ = M & 67108863;
        M >>>= 26, S.words[I] = $, E = M;
      }
      return E !== 0 && (S.words[S.length++] = E), S;
    }, p._prime = function(S) {
      if (de[S])
        return de[S];
      var E;
      if (S === "k256")
        E = new Te();
      else if (S === "p224")
        E = new Re();
      else if (S === "p192")
        E = new Le();
      else if (S === "p25519")
        E = new be();
      else
        throw new Error("Unknown prime " + S);
      return de[S] = E, E;
    };
    function q(C) {
      if (typeof C == "string") {
        var S = p._prime(C);
        this.m = S.p, this.prime = S;
      } else
        l(C.gtn(1), "modulus must be greater than 1"), this.m = C, this.prime = null;
    }
    q.prototype._verify1 = function(S) {
      l(S.negative === 0, "red works only with positives"), l(S.red, "red works only with red numbers");
    }, q.prototype._verify2 = function(S, E) {
      l((S.negative | E.negative) === 0, "red works only with positives"), l(
        S.red && S.red === E.red,
        "red works only with red numbers"
      );
    }, q.prototype.imod = function(S) {
      return this.prime ? this.prime.ireduce(S)._forceRed(this) : S.umod(this.m)._forceRed(this);
    }, q.prototype.neg = function(S) {
      return S.isZero() ? S.clone() : this.m.sub(S)._forceRed(this);
    }, q.prototype.add = function(S, E) {
      this._verify2(S, E);
      var I = S.add(E);
      return I.cmp(this.m) >= 0 && I.isub(this.m), I._forceRed(this);
    }, q.prototype.iadd = function(S, E) {
      this._verify2(S, E);
      var I = S.iadd(E);
      return I.cmp(this.m) >= 0 && I.isub(this.m), I;
    }, q.prototype.sub = function(S, E) {
      this._verify2(S, E);
      var I = S.sub(E);
      return I.cmpn(0) < 0 && I.iadd(this.m), I._forceRed(this);
    }, q.prototype.isub = function(S, E) {
      this._verify2(S, E);
      var I = S.isub(E);
      return I.cmpn(0) < 0 && I.iadd(this.m), I;
    }, q.prototype.shl = function(S, E) {
      return this._verify1(S), this.imod(S.ushln(E));
    }, q.prototype.imul = function(S, E) {
      return this._verify2(S, E), this.imod(S.imul(E));
    }, q.prototype.mul = function(S, E) {
      return this._verify2(S, E), this.imod(S.mul(E));
    }, q.prototype.isqr = function(S) {
      return this.imul(S, S.clone());
    }, q.prototype.sqr = function(S) {
      return this.mul(S, S);
    }, q.prototype.sqrt = function(S) {
      if (S.isZero())
        return S.clone();
      var E = this.m.andln(3);
      if (l(E % 2 === 1), E === 3) {
        var I = this.m.add(new p(1)).iushrn(2);
        return this.pow(S, I);
      }
      for (var M = this.m.subn(1), $ = 0; !M.isZero() && M.andln(1) === 0; )
        $++, M.iushrn(1);
      l(!M.isZero());
      var U = new p(1).toRed(this), Y = U.redNeg(), L = this.m.subn(1).iushrn(1), T = this.m.bitLength();
      for (T = new p(2 * T * T).toRed(this); this.pow(T, L).cmp(Y) !== 0; )
        T.redIAdd(Y);
      for (var B = this.pow(T, M), te = this.pow(S, M.addn(1).iushrn(1)), pe = this.pow(S, M), Ie = $; pe.cmp(U) !== 0; ) {
        for (var $e = pe, ve = 0; $e.cmp(U) !== 0; ve++)
          $e = $e.redSqr();
        l(ve < Ie);
        var he = this.pow(B, new p(1).iushln(Ie - ve - 1));
        te = te.redMul(he), B = he.redSqr(), pe = pe.redMul(B), Ie = ve;
      }
      return te;
    }, q.prototype.invm = function(S) {
      var E = S._invmp(this.m);
      return E.negative !== 0 ? (E.negative = 0, this.imod(E).redNeg()) : this.imod(E);
    }, q.prototype.pow = function(S, E) {
      if (E.isZero())
        return new p(1).toRed(this);
      if (E.cmpn(1) === 0)
        return S.clone();
      var I = 4, M = new Array(1 << I);
      M[0] = new p(1).toRed(this), M[1] = S;
      for (var $ = 2; $ < M.length; $++)
        M[$] = this.mul(M[$ - 1], S);
      var U = M[0], Y = 0, L = 0, T = E.bitLength() % 26;
      for (T === 0 && (T = 26), $ = E.length - 1; $ >= 0; $--) {
        for (var B = E.words[$], te = T - 1; te >= 0; te--) {
          var pe = B >> te & 1;
          if (U !== M[0] && (U = this.sqr(U)), pe === 0 && Y === 0) {
            L = 0;
            continue;
          }
          Y <<= 1, Y |= pe, L++, !(L !== I && ($ !== 0 || te !== 0)) && (U = this.mul(U, M[Y]), L = 0, Y = 0);
        }
        T = 26;
      }
      return U;
    }, q.prototype.convertTo = function(S) {
      var E = S.umod(this.m);
      return E === S ? E.clone() : E;
    }, q.prototype.convertFrom = function(S) {
      var E = S.clone();
      return E.red = null, E;
    }, p.mont = function(S) {
      return new J(S);
    };
    function J(C) {
      q.call(this, C), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new p(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    v(J, q), J.prototype.convertTo = function(S) {
      return this.imod(S.ushln(this.shift));
    }, J.prototype.convertFrom = function(S) {
      var E = this.imod(S.mul(this.rinv));
      return E.red = null, E;
    }, J.prototype.imul = function(S, E) {
      if (S.isZero() || E.isZero())
        return S.words[0] = 0, S.length = 1, S;
      var I = S.imul(E), M = I.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), $ = I.isub(M).iushrn(this.shift), U = $;
      return $.cmp(this.m) >= 0 ? U = $.isub(this.m) : $.cmpn(0) < 0 && (U = $.iadd(this.m)), U._forceRed(this);
    }, J.prototype.mul = function(S, E) {
      if (S.isZero() || E.isZero())
        return new p(0)._forceRed(this);
      var I = S.mul(E), M = I.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), $ = I.isub(M).iushrn(this.shift), U = $;
      return $.cmp(this.m) >= 0 ? U = $.isub(this.m) : $.cmpn(0) < 0 && (U = $.iadd(this.m)), U._forceRed(this);
    }, J.prototype.invm = function(S) {
      var E = this.imod(S._invmp(this.m).mul(this.r2));
      return E._forceRed(this);
    };
  })(a, commonjsGlobal$1);
})(bn$2);
var bnExports$2 = bn$2.exports, api = {}, encoders = {}, buffer$1 = require$$0$2, Buffer$f = buffer$1.Buffer, safer = {}, key;
for (key in buffer$1)
  buffer$1.hasOwnProperty(key) && (key === "SlowBuffer" || key === "Buffer" || (safer[key] = buffer$1[key]));
var Safer = safer.Buffer = {};
for (key in Buffer$f)
  Buffer$f.hasOwnProperty(key) && (key === "allocUnsafe" || key === "allocUnsafeSlow" || (Safer[key] = Buffer$f[key]));
safer.Buffer.prototype = Buffer$f.prototype;
(!Safer.from || Safer.from === Uint8Array.from) && (Safer.from = function(a, u, c) {
  if (typeof a == "number")
    throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof a);
  if (a && typeof a.length > "u")
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof a);
  return Buffer$f(a, u, c);
});
Safer.alloc || (Safer.alloc = function(a, u, c) {
  if (typeof a != "number")
    throw new TypeError('The "size" argument must be of type number. Received type ' + typeof a);
  if (a < 0 || a >= 2 * (1 << 30))
    throw new RangeError('The value "' + a + '" is invalid for option "size"');
  var l = Buffer$f(a);
  return !u || u.length === 0 ? l.fill(0) : typeof c == "string" ? l.fill(u, c) : l.fill(u), l;
});
if (!safer.kStringMaxLength)
  try {
    safer.kStringMaxLength = process$1.binding("buffer").kStringMaxLength;
  } catch {
  }
safer.constants || (safer.constants = {
  MAX_LENGTH: safer.kMaxLength
}, safer.kStringMaxLength && (safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength));
var safer_1 = safer, reporter = {};
const inherits$5 = inherits_browserExports;
function Reporter$2(a) {
  this._reporterState = {
    obj: null,
    path: [],
    options: a || {},
    errors: []
  };
}
reporter.Reporter = Reporter$2;
Reporter$2.prototype.isError = function a(u) {
  return u instanceof ReporterError;
};
Reporter$2.prototype.save = function a() {
  const u = this._reporterState;
  return { obj: u.obj, pathLen: u.path.length };
};
Reporter$2.prototype.restore = function a(u) {
  const c = this._reporterState;
  c.obj = u.obj, c.path = c.path.slice(0, u.pathLen);
};
Reporter$2.prototype.enterKey = function a(u) {
  return this._reporterState.path.push(u);
};
Reporter$2.prototype.exitKey = function a(u) {
  const c = this._reporterState;
  c.path = c.path.slice(0, u - 1);
};
Reporter$2.prototype.leaveKey = function a(u, c, l) {
  const v = this._reporterState;
  this.exitKey(u), v.obj !== null && (v.obj[c] = l);
};
Reporter$2.prototype.path = function a() {
  return this._reporterState.path.join("/");
};
Reporter$2.prototype.enterObject = function a() {
  const u = this._reporterState, c = u.obj;
  return u.obj = {}, c;
};
Reporter$2.prototype.leaveObject = function a(u) {
  const c = this._reporterState, l = c.obj;
  return c.obj = u, l;
};
Reporter$2.prototype.error = function a(u) {
  let c;
  const l = this._reporterState, v = u instanceof ReporterError;
  if (v ? c = u : c = new ReporterError(l.path.map(function(p) {
    return "[" + JSON.stringify(p) + "]";
  }).join(""), u.message || u, u.stack), !l.options.partial)
    throw c;
  return v || l.errors.push(c), c;
};
Reporter$2.prototype.wrapResult = function a(u) {
  const c = this._reporterState;
  return c.options.partial ? {
    result: this.isError(u) ? null : u,
    errors: c.errors
  } : u;
};
function ReporterError(a, u) {
  this.path = a, this.rethrow(u);
}
inherits$5(ReporterError, Error);
ReporterError.prototype.rethrow = function a(u) {
  if (this.message = u + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, ReporterError), !this.stack)
    try {
      throw new Error(this.message);
    } catch (c) {
      this.stack = c.stack;
    }
  return this;
};
var buffer = {};
const inherits$4 = inherits_browserExports, Reporter$1 = reporter.Reporter, Buffer$e = safer_1.Buffer;
function DecoderBuffer$2(a, u) {
  if (Reporter$1.call(this, u), !Buffer$e.isBuffer(a)) {
    this.error("Input not Buffer");
    return;
  }
  this.base = a, this.offset = 0, this.length = a.length;
}
inherits$4(DecoderBuffer$2, Reporter$1);
buffer.DecoderBuffer = DecoderBuffer$2;
DecoderBuffer$2.isDecoderBuffer = function a(u) {
  return u instanceof DecoderBuffer$2 ? !0 : typeof u == "object" && Buffer$e.isBuffer(u.base) && u.constructor.name === "DecoderBuffer" && typeof u.offset == "number" && typeof u.length == "number" && typeof u.save == "function" && typeof u.restore == "function" && typeof u.isEmpty == "function" && typeof u.readUInt8 == "function" && typeof u.skip == "function" && typeof u.raw == "function";
};
DecoderBuffer$2.prototype.save = function a() {
  return { offset: this.offset, reporter: Reporter$1.prototype.save.call(this) };
};
DecoderBuffer$2.prototype.restore = function a(u) {
  const c = new DecoderBuffer$2(this.base);
  return c.offset = u.offset, c.length = this.offset, this.offset = u.offset, Reporter$1.prototype.restore.call(this, u.reporter), c;
};
DecoderBuffer$2.prototype.isEmpty = function a() {
  return this.offset === this.length;
};
DecoderBuffer$2.prototype.readUInt8 = function a(u) {
  return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, !0) : this.error(u || "DecoderBuffer overrun");
};
DecoderBuffer$2.prototype.skip = function a(u, c) {
  if (!(this.offset + u <= this.length))
    return this.error(c || "DecoderBuffer overrun");
  const l = new DecoderBuffer$2(this.base);
  return l._reporterState = this._reporterState, l.offset = this.offset, l.length = this.offset + u, this.offset += u, l;
};
DecoderBuffer$2.prototype.raw = function a(u) {
  return this.base.slice(u ? u.offset : this.offset, this.length);
};
function EncoderBuffer$1(a, u) {
  if (Array.isArray(a))
    this.length = 0, this.value = a.map(function(c) {
      return EncoderBuffer$1.isEncoderBuffer(c) || (c = new EncoderBuffer$1(c, u)), this.length += c.length, c;
    }, this);
  else if (typeof a == "number") {
    if (!(0 <= a && a <= 255))
      return u.error("non-byte EncoderBuffer value");
    this.value = a, this.length = 1;
  } else if (typeof a == "string")
    this.value = a, this.length = Buffer$e.byteLength(a);
  else if (Buffer$e.isBuffer(a))
    this.value = a, this.length = a.length;
  else
    return u.error("Unsupported type: " + typeof a);
}
buffer.EncoderBuffer = EncoderBuffer$1;
EncoderBuffer$1.isEncoderBuffer = function a(u) {
  return u instanceof EncoderBuffer$1 ? !0 : typeof u == "object" && u.constructor.name === "EncoderBuffer" && typeof u.length == "number" && typeof u.join == "function";
};
EncoderBuffer$1.prototype.join = function a(u, c) {
  return u || (u = Buffer$e.alloc(this.length)), c || (c = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(l) {
    l.join(u, c), c += l.length;
  }) : (typeof this.value == "number" ? u[c] = this.value : typeof this.value == "string" ? u.write(this.value, c) : Buffer$e.isBuffer(this.value) && this.value.copy(u, c), c += this.length)), u;
};
const Reporter = reporter.Reporter, EncoderBuffer = buffer.EncoderBuffer, DecoderBuffer$1 = buffer.DecoderBuffer, assert = minimalisticAssert, tags = [
  "seq",
  "seqof",
  "set",
  "setof",
  "objid",
  "bool",
  "gentime",
  "utctime",
  "null_",
  "enum",
  "int",
  "objDesc",
  "bitstr",
  "bmpstr",
  "charstr",
  "genstr",
  "graphstr",
  "ia5str",
  "iso646str",
  "numstr",
  "octstr",
  "printstr",
  "t61str",
  "unistr",
  "utf8str",
  "videostr"
], methods = [
  "key",
  "obj",
  "use",
  "optional",
  "explicit",
  "implicit",
  "def",
  "choice",
  "any",
  "contains"
].concat(tags), overrided = [
  "_peekTag",
  "_decodeTag",
  "_use",
  "_decodeStr",
  "_decodeObjid",
  "_decodeTime",
  "_decodeNull",
  "_decodeInt",
  "_decodeBool",
  "_decodeList",
  "_encodeComposite",
  "_encodeStr",
  "_encodeObjid",
  "_encodeTime",
  "_encodeNull",
  "_encodeInt",
  "_encodeBool"
];
function Node$2(a, u, c) {
  const l = {};
  this._baseState = l, l.name = c, l.enc = a, l.parent = u || null, l.children = null, l.tag = null, l.args = null, l.reverseArgs = null, l.choice = null, l.optional = !1, l.any = !1, l.obj = !1, l.use = null, l.useDecoder = null, l.key = null, l.default = null, l.explicit = null, l.implicit = null, l.contains = null, l.parent || (l.children = [], this._wrap());
}
var node = Node$2;
const stateProps = [
  "enc",
  "parent",
  "children",
  "tag",
  "args",
  "reverseArgs",
  "choice",
  "optional",
  "any",
  "obj",
  "use",
  "alteredUse",
  "key",
  "default",
  "explicit",
  "implicit",
  "contains"
];
Node$2.prototype.clone = function a() {
  const u = this._baseState, c = {};
  stateProps.forEach(function(v) {
    c[v] = u[v];
  });
  const l = new this.constructor(c.parent);
  return l._baseState = c, l;
};
Node$2.prototype._wrap = function a() {
  const u = this._baseState;
  methods.forEach(function(c) {
    this[c] = function() {
      const v = new this.constructor(this);
      return u.children.push(v), v[c].apply(v, arguments);
    };
  }, this);
};
Node$2.prototype._init = function a(u) {
  const c = this._baseState;
  assert(c.parent === null), u.call(this), c.children = c.children.filter(function(l) {
    return l._baseState.parent === this;
  }, this), assert.equal(c.children.length, 1, "Root node can have only one child");
};
Node$2.prototype._useArgs = function a(u) {
  const c = this._baseState, l = u.filter(function(v) {
    return v instanceof this.constructor;
  }, this);
  u = u.filter(function(v) {
    return !(v instanceof this.constructor);
  }, this), l.length !== 0 && (assert(c.children === null), c.children = l, l.forEach(function(v) {
    v._baseState.parent = this;
  }, this)), u.length !== 0 && (assert(c.args === null), c.args = u, c.reverseArgs = u.map(function(v) {
    if (typeof v != "object" || v.constructor !== Object)
      return v;
    const p = {};
    return Object.keys(v).forEach(function(_) {
      _ == (_ | 0) && (_ |= 0);
      const k = v[_];
      p[k] = _;
    }), p;
  }));
};
overrided.forEach(function(a) {
  Node$2.prototype[a] = function() {
    const c = this._baseState;
    throw new Error(a + " not implemented for encoding: " + c.enc);
  };
});
tags.forEach(function(a) {
  Node$2.prototype[a] = function() {
    const c = this._baseState, l = Array.prototype.slice.call(arguments);
    return assert(c.tag === null), c.tag = a, this._useArgs(l), this;
  };
});
Node$2.prototype.use = function a(u) {
  assert(u);
  const c = this._baseState;
  return assert(c.use === null), c.use = u, this;
};
Node$2.prototype.optional = function a() {
  const u = this._baseState;
  return u.optional = !0, this;
};
Node$2.prototype.def = function a(u) {
  const c = this._baseState;
  return assert(c.default === null), c.default = u, c.optional = !0, this;
};
Node$2.prototype.explicit = function a(u) {
  const c = this._baseState;
  return assert(c.explicit === null && c.implicit === null), c.explicit = u, this;
};
Node$2.prototype.implicit = function a(u) {
  const c = this._baseState;
  return assert(c.explicit === null && c.implicit === null), c.implicit = u, this;
};
Node$2.prototype.obj = function a() {
  const u = this._baseState, c = Array.prototype.slice.call(arguments);
  return u.obj = !0, c.length !== 0 && this._useArgs(c), this;
};
Node$2.prototype.key = function a(u) {
  const c = this._baseState;
  return assert(c.key === null), c.key = u, this;
};
Node$2.prototype.any = function a() {
  const u = this._baseState;
  return u.any = !0, this;
};
Node$2.prototype.choice = function a(u) {
  const c = this._baseState;
  return assert(c.choice === null), c.choice = u, this._useArgs(Object.keys(u).map(function(l) {
    return u[l];
  })), this;
};
Node$2.prototype.contains = function a(u) {
  const c = this._baseState;
  return assert(c.use === null), c.contains = u, this;
};
Node$2.prototype._decode = function a(u, c) {
  const l = this._baseState;
  if (l.parent === null)
    return u.wrapResult(l.children[0]._decode(u, c));
  let v = l.default, p = !0, _ = null;
  if (l.key !== null && (_ = u.enterKey(l.key)), l.optional) {
    let O = null;
    if (l.explicit !== null ? O = l.explicit : l.implicit !== null ? O = l.implicit : l.tag !== null && (O = l.tag), O === null && !l.any) {
      const D = u.save();
      try {
        l.choice === null ? this._decodeGeneric(l.tag, u, c) : this._decodeChoice(u, c), p = !0;
      } catch {
        p = !1;
      }
      u.restore(D);
    } else if (p = this._peekTag(u, O, l.any), u.isError(p))
      return p;
  }
  let k;
  if (l.obj && p && (k = u.enterObject()), p) {
    if (l.explicit !== null) {
      const D = this._decodeTag(u, l.explicit);
      if (u.isError(D))
        return D;
      u = D;
    }
    const O = u.offset;
    if (l.use === null && l.choice === null) {
      let D;
      l.any && (D = u.save());
      const F = this._decodeTag(
        u,
        l.implicit !== null ? l.implicit : l.tag,
        l.any
      );
      if (u.isError(F))
        return F;
      l.any ? v = u.raw(D) : u = F;
    }
    if (c && c.track && l.tag !== null && c.track(u.path(), O, u.length, "tagged"), c && c.track && l.tag !== null && c.track(u.path(), u.offset, u.length, "content"), l.any || (l.choice === null ? v = this._decodeGeneric(l.tag, u, c) : v = this._decodeChoice(u, c)), u.isError(v))
      return v;
    if (!l.any && l.choice === null && l.children !== null && l.children.forEach(function(F) {
      F._decode(u, c);
    }), l.contains && (l.tag === "octstr" || l.tag === "bitstr")) {
      const D = new DecoderBuffer$1(v);
      v = this._getUse(l.contains, u._reporterState.obj)._decode(D, c);
    }
  }
  return l.obj && p && (v = u.leaveObject(k)), l.key !== null && (v !== null || p === !0) ? u.leaveKey(_, l.key, v) : _ !== null && u.exitKey(_), v;
};
Node$2.prototype._decodeGeneric = function a(u, c, l) {
  const v = this._baseState;
  return u === "seq" || u === "set" ? null : u === "seqof" || u === "setof" ? this._decodeList(c, u, v.args[0], l) : /str$/.test(u) ? this._decodeStr(c, u, l) : u === "objid" && v.args ? this._decodeObjid(c, v.args[0], v.args[1], l) : u === "objid" ? this._decodeObjid(c, null, null, l) : u === "gentime" || u === "utctime" ? this._decodeTime(c, u, l) : u === "null_" ? this._decodeNull(c, l) : u === "bool" ? this._decodeBool(c, l) : u === "objDesc" ? this._decodeStr(c, u, l) : u === "int" || u === "enum" ? this._decodeInt(c, v.args && v.args[0], l) : v.use !== null ? this._getUse(v.use, c._reporterState.obj)._decode(c, l) : c.error("unknown tag: " + u);
};
Node$2.prototype._getUse = function a(u, c) {
  const l = this._baseState;
  return l.useDecoder = this._use(u, c), assert(l.useDecoder._baseState.parent === null), l.useDecoder = l.useDecoder._baseState.children[0], l.implicit !== l.useDecoder._baseState.implicit && (l.useDecoder = l.useDecoder.clone(), l.useDecoder._baseState.implicit = l.implicit), l.useDecoder;
};
Node$2.prototype._decodeChoice = function a(u, c) {
  const l = this._baseState;
  let v = null, p = !1;
  return Object.keys(l.choice).some(function(_) {
    const k = u.save(), O = l.choice[_];
    try {
      const D = O._decode(u, c);
      if (u.isError(D))
        return !1;
      v = { type: _, value: D }, p = !0;
    } catch {
      return u.restore(k), !1;
    }
    return !0;
  }, this), p ? v : u.error("Choice not matched");
};
Node$2.prototype._createEncoderBuffer = function a(u) {
  return new EncoderBuffer(u, this.reporter);
};
Node$2.prototype._encode = function a(u, c, l) {
  const v = this._baseState;
  if (v.default !== null && v.default === u)
    return;
  const p = this._encodeValue(u, c, l);
  if (p !== void 0 && !this._skipDefault(p, c, l))
    return p;
};
Node$2.prototype._encodeValue = function a(u, c, l) {
  const v = this._baseState;
  if (v.parent === null)
    return v.children[0]._encode(u, c || new Reporter());
  let p = null;
  if (this.reporter = c, v.optional && u === void 0)
    if (v.default !== null)
      u = v.default;
    else
      return;
  let _ = null, k = !1;
  if (v.any)
    p = this._createEncoderBuffer(u);
  else if (v.choice)
    p = this._encodeChoice(u, c);
  else if (v.contains)
    _ = this._getUse(v.contains, l)._encode(u, c), k = !0;
  else if (v.children)
    _ = v.children.map(function(O) {
      if (O._baseState.tag === "null_")
        return O._encode(null, c, u);
      if (O._baseState.key === null)
        return c.error("Child should have a key");
      const D = c.enterKey(O._baseState.key);
      if (typeof u != "object")
        return c.error("Child expected, but input is not object");
      const F = O._encode(u[O._baseState.key], c, u);
      return c.leaveKey(D), F;
    }, this).filter(function(O) {
      return O;
    }), _ = this._createEncoderBuffer(_);
  else if (v.tag === "seqof" || v.tag === "setof") {
    if (!(v.args && v.args.length === 1))
      return c.error("Too many args for : " + v.tag);
    if (!Array.isArray(u))
      return c.error("seqof/setof, but data is not Array");
    const O = this.clone();
    O._baseState.implicit = null, _ = this._createEncoderBuffer(u.map(function(D) {
      const F = this._baseState;
      return this._getUse(F.args[0], u)._encode(D, c);
    }, O));
  } else
    v.use !== null ? p = this._getUse(v.use, l)._encode(u, c) : (_ = this._encodePrimitive(v.tag, u), k = !0);
  if (!v.any && v.choice === null) {
    const O = v.implicit !== null ? v.implicit : v.tag, D = v.implicit === null ? "universal" : "context";
    O === null ? v.use === null && c.error("Tag could be omitted only for .use()") : v.use === null && (p = this._encodeComposite(O, k, D, _));
  }
  return v.explicit !== null && (p = this._encodeComposite(v.explicit, !1, "context", p)), p;
};
Node$2.prototype._encodeChoice = function a(u, c) {
  const l = this._baseState, v = l.choice[u.type];
  return v || assert(
    !1,
    u.type + " not found in " + JSON.stringify(Object.keys(l.choice))
  ), v._encode(u.value, c);
};
Node$2.prototype._encodePrimitive = function a(u, c) {
  const l = this._baseState;
  if (/str$/.test(u))
    return this._encodeStr(c, u);
  if (u === "objid" && l.args)
    return this._encodeObjid(c, l.reverseArgs[0], l.args[1]);
  if (u === "objid")
    return this._encodeObjid(c, null, null);
  if (u === "gentime" || u === "utctime")
    return this._encodeTime(c, u);
  if (u === "null_")
    return this._encodeNull();
  if (u === "int" || u === "enum")
    return this._encodeInt(c, l.args && l.reverseArgs[0]);
  if (u === "bool")
    return this._encodeBool(c);
  if (u === "objDesc")
    return this._encodeStr(c, u);
  throw new Error("Unsupported tag: " + u);
};
Node$2.prototype._isNumstr = function a(u) {
  return /^[0-9 ]*$/.test(u);
};
Node$2.prototype._isPrintstr = function a(u) {
  return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(u);
};
var der$2 = {};
(function(a) {
  function u(c) {
    const l = {};
    return Object.keys(c).forEach(function(v) {
      (v | 0) == v && (v = v | 0);
      const p = c[v];
      l[p] = v;
    }), l;
  }
  a.tagClass = {
    0: "universal",
    1: "application",
    2: "context",
    3: "private"
  }, a.tagClassByName = u(a.tagClass), a.tag = {
    0: "end",
    1: "bool",
    2: "int",
    3: "bitstr",
    4: "octstr",
    5: "null_",
    6: "objid",
    7: "objDesc",
    8: "external",
    9: "real",
    10: "enum",
    11: "embed",
    12: "utf8str",
    13: "relativeOid",
    16: "seq",
    17: "set",
    18: "numstr",
    19: "printstr",
    20: "t61str",
    21: "videostr",
    22: "ia5str",
    23: "utctime",
    24: "gentime",
    25: "graphstr",
    26: "iso646str",
    27: "genstr",
    28: "unistr",
    29: "charstr",
    30: "bmpstr"
  }, a.tagByName = u(a.tag);
})(der$2);
const inherits$3 = inherits_browserExports, Buffer$d = safer_1.Buffer, Node$1 = node, der$1 = der$2;
function DEREncoder$1(a) {
  this.enc = "der", this.name = a.name, this.entity = a, this.tree = new DERNode$1(), this.tree._init(a.body);
}
var der_1$1 = DEREncoder$1;
DEREncoder$1.prototype.encode = function a(u, c) {
  return this.tree._encode(u, c).join();
};
function DERNode$1(a) {
  Node$1.call(this, "der", a);
}
inherits$3(DERNode$1, Node$1);
DERNode$1.prototype._encodeComposite = function a(u, c, l, v) {
  const p = encodeTag(u, c, l, this.reporter);
  if (v.length < 128) {
    const O = Buffer$d.alloc(2);
    return O[0] = p, O[1] = v.length, this._createEncoderBuffer([O, v]);
  }
  let _ = 1;
  for (let O = v.length; O >= 256; O >>= 8)
    _++;
  const k = Buffer$d.alloc(2 + _);
  k[0] = p, k[1] = 128 | _;
  for (let O = 1 + _, D = v.length; D > 0; O--, D >>= 8)
    k[O] = D & 255;
  return this._createEncoderBuffer([k, v]);
};
DERNode$1.prototype._encodeStr = function a(u, c) {
  if (c === "bitstr")
    return this._createEncoderBuffer([u.unused | 0, u.data]);
  if (c === "bmpstr") {
    const l = Buffer$d.alloc(u.length * 2);
    for (let v = 0; v < u.length; v++)
      l.writeUInt16BE(u.charCodeAt(v), v * 2);
    return this._createEncoderBuffer(l);
  } else
    return c === "numstr" ? this._isNumstr(u) ? this._createEncoderBuffer(u) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : c === "printstr" ? this._isPrintstr(u) ? this._createEncoderBuffer(u) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(c) ? this._createEncoderBuffer(u) : c === "objDesc" ? this._createEncoderBuffer(u) : this.reporter.error("Encoding of string type: " + c + " unsupported");
};
DERNode$1.prototype._encodeObjid = function a(u, c, l) {
  if (typeof u == "string") {
    if (!c)
      return this.reporter.error("string objid given, but no values map found");
    if (!c.hasOwnProperty(u))
      return this.reporter.error("objid not found in values map");
    u = c[u].split(/[\s.]+/g);
    for (let k = 0; k < u.length; k++)
      u[k] |= 0;
  } else if (Array.isArray(u)) {
    u = u.slice();
    for (let k = 0; k < u.length; k++)
      u[k] |= 0;
  }
  if (!Array.isArray(u))
    return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(u));
  if (!l) {
    if (u[1] >= 40)
      return this.reporter.error("Second objid identifier OOB");
    u.splice(0, 2, u[0] * 40 + u[1]);
  }
  let v = 0;
  for (let k = 0; k < u.length; k++) {
    let O = u[k];
    for (v++; O >= 128; O >>= 7)
      v++;
  }
  const p = Buffer$d.alloc(v);
  let _ = p.length - 1;
  for (let k = u.length - 1; k >= 0; k--) {
    let O = u[k];
    for (p[_--] = O & 127; (O >>= 7) > 0; )
      p[_--] = 128 | O & 127;
  }
  return this._createEncoderBuffer(p);
};
function two(a) {
  return a < 10 ? "0" + a : a;
}
DERNode$1.prototype._encodeTime = function a(u, c) {
  let l;
  const v = new Date(u);
  return c === "gentime" ? l = [
    two(v.getUTCFullYear()),
    two(v.getUTCMonth() + 1),
    two(v.getUTCDate()),
    two(v.getUTCHours()),
    two(v.getUTCMinutes()),
    two(v.getUTCSeconds()),
    "Z"
  ].join("") : c === "utctime" ? l = [
    two(v.getUTCFullYear() % 100),
    two(v.getUTCMonth() + 1),
    two(v.getUTCDate()),
    two(v.getUTCHours()),
    two(v.getUTCMinutes()),
    two(v.getUTCSeconds()),
    "Z"
  ].join("") : this.reporter.error("Encoding " + c + " time is not supported yet"), this._encodeStr(l, "octstr");
};
DERNode$1.prototype._encodeNull = function a() {
  return this._createEncoderBuffer("");
};
DERNode$1.prototype._encodeInt = function a(u, c) {
  if (typeof u == "string") {
    if (!c)
      return this.reporter.error("String int or enum given, but no values map");
    if (!c.hasOwnProperty(u))
      return this.reporter.error("Values map doesn't contain: " + JSON.stringify(u));
    u = c[u];
  }
  if (typeof u != "number" && !Buffer$d.isBuffer(u)) {
    const p = u.toArray();
    !u.sign && p[0] & 128 && p.unshift(0), u = Buffer$d.from(p);
  }
  if (Buffer$d.isBuffer(u)) {
    let p = u.length;
    u.length === 0 && p++;
    const _ = Buffer$d.alloc(p);
    return u.copy(_), u.length === 0 && (_[0] = 0), this._createEncoderBuffer(_);
  }
  if (u < 128)
    return this._createEncoderBuffer(u);
  if (u < 256)
    return this._createEncoderBuffer([0, u]);
  let l = 1;
  for (let p = u; p >= 256; p >>= 8)
    l++;
  const v = new Array(l);
  for (let p = v.length - 1; p >= 0; p--)
    v[p] = u & 255, u >>= 8;
  return v[0] & 128 && v.unshift(0), this._createEncoderBuffer(Buffer$d.from(v));
};
DERNode$1.prototype._encodeBool = function a(u) {
  return this._createEncoderBuffer(u ? 255 : 0);
};
DERNode$1.prototype._use = function a(u, c) {
  return typeof u == "function" && (u = u(c)), u._getEncoder("der").tree;
};
DERNode$1.prototype._skipDefault = function a(u, c, l) {
  const v = this._baseState;
  let p;
  if (v.default === null)
    return !1;
  const _ = u.join();
  if (v.defaultBuffer === void 0 && (v.defaultBuffer = this._encodeValue(v.default, c, l).join()), _.length !== v.defaultBuffer.length)
    return !1;
  for (p = 0; p < _.length; p++)
    if (_[p] !== v.defaultBuffer[p])
      return !1;
  return !0;
};
function encodeTag(a, u, c, l) {
  let v;
  if (a === "seqof" ? a = "seq" : a === "setof" && (a = "set"), der$1.tagByName.hasOwnProperty(a))
    v = der$1.tagByName[a];
  else if (typeof a == "number" && (a | 0) === a)
    v = a;
  else
    return l.error("Unknown tag: " + a);
  return v >= 31 ? l.error("Multi-octet tag encoding unsupported") : (u || (v |= 32), v |= der$1.tagClassByName[c || "universal"] << 6, v);
}
const inherits$2 = inherits_browserExports, DEREncoder = der_1$1;
function PEMEncoder(a) {
  DEREncoder.call(this, a), this.enc = "pem";
}
inherits$2(PEMEncoder, DEREncoder);
var pem$1 = PEMEncoder;
PEMEncoder.prototype.encode = function a(u, c) {
  const v = DEREncoder.prototype.encode.call(this, u).toString("base64"), p = ["-----BEGIN " + c.label + "-----"];
  for (let _ = 0; _ < v.length; _ += 64)
    p.push(v.slice(_, _ + 64));
  return p.push("-----END " + c.label + "-----"), p.join(`
`);
};
(function(a) {
  const u = a;
  u.der = der_1$1, u.pem = pem$1;
})(encoders);
var decoders = {};
const inherits$1 = inherits_browserExports, bignum = bnExports$2, DecoderBuffer = buffer.DecoderBuffer, Node = node, der = der$2;
function DERDecoder$1(a) {
  this.enc = "der", this.name = a.name, this.entity = a, this.tree = new DERNode(), this.tree._init(a.body);
}
var der_1 = DERDecoder$1;
DERDecoder$1.prototype.decode = function a(u, c) {
  return DecoderBuffer.isDecoderBuffer(u) || (u = new DecoderBuffer(u, c)), this.tree._decode(u, c);
};
function DERNode(a) {
  Node.call(this, "der", a);
}
inherits$1(DERNode, Node);
DERNode.prototype._peekTag = function a(u, c, l) {
  if (u.isEmpty())
    return !1;
  const v = u.save(), p = derDecodeTag(u, 'Failed to peek tag: "' + c + '"');
  return u.isError(p) ? p : (u.restore(v), p.tag === c || p.tagStr === c || p.tagStr + "of" === c || l);
};
DERNode.prototype._decodeTag = function a(u, c, l) {
  const v = derDecodeTag(
    u,
    'Failed to decode tag of "' + c + '"'
  );
  if (u.isError(v))
    return v;
  let p = derDecodeLen(
    u,
    v.primitive,
    'Failed to get length of "' + c + '"'
  );
  if (u.isError(p))
    return p;
  if (!l && v.tag !== c && v.tagStr !== c && v.tagStr + "of" !== c)
    return u.error('Failed to match tag: "' + c + '"');
  if (v.primitive || p !== null)
    return u.skip(p, 'Failed to match body of: "' + c + '"');
  const _ = u.save(), k = this._skipUntilEnd(
    u,
    'Failed to skip indefinite length body: "' + this.tag + '"'
  );
  return u.isError(k) ? k : (p = u.offset - _.offset, u.restore(_), u.skip(p, 'Failed to match body of: "' + c + '"'));
};
DERNode.prototype._skipUntilEnd = function a(u, c) {
  for (; ; ) {
    const l = derDecodeTag(u, c);
    if (u.isError(l))
      return l;
    const v = derDecodeLen(u, l.primitive, c);
    if (u.isError(v))
      return v;
    let p;
    if (l.primitive || v !== null ? p = u.skip(v) : p = this._skipUntilEnd(u, c), u.isError(p))
      return p;
    if (l.tagStr === "end")
      break;
  }
};
DERNode.prototype._decodeList = function a(u, c, l, v) {
  const p = [];
  for (; !u.isEmpty(); ) {
    const _ = this._peekTag(u, "end");
    if (u.isError(_))
      return _;
    const k = l.decode(u, "der", v);
    if (u.isError(k) && _)
      break;
    p.push(k);
  }
  return p;
};
DERNode.prototype._decodeStr = function a(u, c) {
  if (c === "bitstr") {
    const l = u.readUInt8();
    return u.isError(l) ? l : { unused: l, data: u.raw() };
  } else if (c === "bmpstr") {
    const l = u.raw();
    if (l.length % 2 === 1)
      return u.error("Decoding of string type: bmpstr length mismatch");
    let v = "";
    for (let p = 0; p < l.length / 2; p++)
      v += String.fromCharCode(l.readUInt16BE(p * 2));
    return v;
  } else if (c === "numstr") {
    const l = u.raw().toString("ascii");
    return this._isNumstr(l) ? l : u.error("Decoding of string type: numstr unsupported characters");
  } else {
    if (c === "octstr")
      return u.raw();
    if (c === "objDesc")
      return u.raw();
    if (c === "printstr") {
      const l = u.raw().toString("ascii");
      return this._isPrintstr(l) ? l : u.error("Decoding of string type: printstr unsupported characters");
    } else
      return /str$/.test(c) ? u.raw().toString() : u.error("Decoding of string type: " + c + " unsupported");
  }
};
DERNode.prototype._decodeObjid = function a(u, c, l) {
  let v;
  const p = [];
  let _ = 0, k = 0;
  for (; !u.isEmpty(); )
    k = u.readUInt8(), _ <<= 7, _ |= k & 127, k & 128 || (p.push(_), _ = 0);
  k & 128 && p.push(_);
  const O = p[0] / 40 | 0, D = p[0] % 40;
  if (l ? v = p : v = [O, D].concat(p.slice(1)), c) {
    let F = c[v.join(" ")];
    F === void 0 && (F = c[v.join(".")]), F !== void 0 && (v = F);
  }
  return v;
};
DERNode.prototype._decodeTime = function a(u, c) {
  const l = u.raw().toString();
  let v, p, _, k, O, D;
  if (c === "gentime")
    v = l.slice(0, 4) | 0, p = l.slice(4, 6) | 0, _ = l.slice(6, 8) | 0, k = l.slice(8, 10) | 0, O = l.slice(10, 12) | 0, D = l.slice(12, 14) | 0;
  else if (c === "utctime")
    v = l.slice(0, 2) | 0, p = l.slice(2, 4) | 0, _ = l.slice(4, 6) | 0, k = l.slice(6, 8) | 0, O = l.slice(8, 10) | 0, D = l.slice(10, 12) | 0, v < 70 ? v = 2e3 + v : v = 1900 + v;
  else
    return u.error("Decoding " + c + " time is not supported yet");
  return Date.UTC(v, p - 1, _, k, O, D, 0);
};
DERNode.prototype._decodeNull = function a() {
  return null;
};
DERNode.prototype._decodeBool = function a(u) {
  const c = u.readUInt8();
  return u.isError(c) ? c : c !== 0;
};
DERNode.prototype._decodeInt = function a(u, c) {
  const l = u.raw();
  let v = new bignum(l);
  return c && (v = c[v.toString(10)] || v), v;
};
DERNode.prototype._use = function a(u, c) {
  return typeof u == "function" && (u = u(c)), u._getDecoder("der").tree;
};
function derDecodeTag(a, u) {
  let c = a.readUInt8(u);
  if (a.isError(c))
    return c;
  const l = der.tagClass[c >> 6], v = (c & 32) === 0;
  if ((c & 31) === 31) {
    let _ = c;
    for (c = 0; (_ & 128) === 128; ) {
      if (_ = a.readUInt8(u), a.isError(_))
        return _;
      c <<= 7, c |= _ & 127;
    }
  } else
    c &= 31;
  const p = der.tag[c];
  return {
    cls: l,
    primitive: v,
    tag: c,
    tagStr: p
  };
}
function derDecodeLen(a, u, c) {
  let l = a.readUInt8(c);
  if (a.isError(l))
    return l;
  if (!u && l === 128)
    return null;
  if (!(l & 128))
    return l;
  const v = l & 127;
  if (v > 4)
    return a.error("length octect is too long");
  l = 0;
  for (let p = 0; p < v; p++) {
    l <<= 8;
    const _ = a.readUInt8(c);
    if (a.isError(_))
      return _;
    l |= _;
  }
  return l;
}
const inherits = inherits_browserExports, Buffer$c = safer_1.Buffer, DERDecoder = der_1;
function PEMDecoder(a) {
  DERDecoder.call(this, a), this.enc = "pem";
}
inherits(PEMDecoder, DERDecoder);
var pem = PEMDecoder;
PEMDecoder.prototype.decode = function a(u, c) {
  const l = u.toString().split(/[\r\n]+/g), v = c.label.toUpperCase(), p = /^-----(BEGIN|END) ([^-]+)-----$/;
  let _ = -1, k = -1;
  for (let F = 0; F < l.length; F++) {
    const z = l[F].match(p);
    if (z !== null && z[2] === v)
      if (_ === -1) {
        if (z[1] !== "BEGIN")
          break;
        _ = F;
      } else {
        if (z[1] !== "END")
          break;
        k = F;
        break;
      }
  }
  if (_ === -1 || k === -1)
    throw new Error("PEM section not found for: " + v);
  const O = l.slice(_ + 1, k).join("");
  O.replace(/[^a-z0-9+/=]+/gi, "");
  const D = Buffer$c.from(O, "base64");
  return DERDecoder.prototype.decode.call(this, D, c);
};
(function(a) {
  const u = a;
  u.der = der_1, u.pem = pem;
})(decoders);
(function(a) {
  const u = encoders, c = decoders, l = inherits_browserExports, v = a;
  v.define = function(k, O) {
    return new p(k, O);
  };
  function p(_, k) {
    this.name = _, this.body = k, this.decoders = {}, this.encoders = {};
  }
  p.prototype._createNamed = function(k) {
    const O = this.name;
    function D(F) {
      this._initNamed(F, O);
    }
    return l(D, k), D.prototype._initNamed = function(z, j) {
      k.call(this, z, j);
    }, new D(this);
  }, p.prototype._getDecoder = function(k) {
    return k = k || "der", this.decoders.hasOwnProperty(k) || (this.decoders[k] = this._createNamed(c[k])), this.decoders[k];
  }, p.prototype.decode = function(k, O, D) {
    return this._getDecoder(O).decode(k, D);
  }, p.prototype._getEncoder = function(k) {
    return k = k || "der", this.encoders.hasOwnProperty(k) || (this.encoders[k] = this._createNamed(u[k])), this.encoders[k];
  }, p.prototype.encode = function(k, O, D) {
    return this._getEncoder(O).encode(k, D);
  };
})(api);
var base = {};
(function(a) {
  const u = a;
  u.Reporter = reporter.Reporter, u.DecoderBuffer = buffer.DecoderBuffer, u.EncoderBuffer = buffer.EncoderBuffer, u.Node = node;
})(base);
var constants = {};
(function(a) {
  const u = a;
  u._reverse = function(l) {
    const v = {};
    return Object.keys(l).forEach(function(p) {
      (p | 0) == p && (p = p | 0);
      const _ = l[p];
      v[_] = p;
    }), v;
  }, u.der = der$2;
})(constants);
(function(a) {
  const u = a;
  u.bignum = bnExports$2, u.define = api.define, u.base = base, u.constants = constants, u.decoders = decoders, u.encoders = encoders;
})(asn1$2);
var asn = asn1$2, Time = asn.define("Time", function() {
  this.choice({
    utcTime: this.utctime(),
    generalTime: this.gentime()
  });
}), AttributeTypeValue = asn.define("AttributeTypeValue", function() {
  this.seq().obj(
    this.key("type").objid(),
    this.key("value").any()
  );
}), AlgorithmIdentifier$1 = asn.define("AlgorithmIdentifier", function() {
  this.seq().obj(
    this.key("algorithm").objid(),
    this.key("parameters").optional(),
    this.key("curve").objid().optional()
  );
}), SubjectPublicKeyInfo = asn.define("SubjectPublicKeyInfo", function() {
  this.seq().obj(
    this.key("algorithm").use(AlgorithmIdentifier$1),
    this.key("subjectPublicKey").bitstr()
  );
}), RelativeDistinguishedName = asn.define("RelativeDistinguishedName", function() {
  this.setof(AttributeTypeValue);
}), RDNSequence = asn.define("RDNSequence", function() {
  this.seqof(RelativeDistinguishedName);
}), Name = asn.define("Name", function() {
  this.choice({
    rdnSequence: this.use(RDNSequence)
  });
}), Validity = asn.define("Validity", function() {
  this.seq().obj(
    this.key("notBefore").use(Time),
    this.key("notAfter").use(Time)
  );
}), Extension = asn.define("Extension", function() {
  this.seq().obj(
    this.key("extnID").objid(),
    this.key("critical").bool().def(!1),
    this.key("extnValue").octstr()
  );
}), TBSCertificate = asn.define("TBSCertificate", function() {
  this.seq().obj(
    this.key("version").explicit(0).int().optional(),
    this.key("serialNumber").int(),
    this.key("signature").use(AlgorithmIdentifier$1),
    this.key("issuer").use(Name),
    this.key("validity").use(Validity),
    this.key("subject").use(Name),
    this.key("subjectPublicKeyInfo").use(SubjectPublicKeyInfo),
    this.key("issuerUniqueID").implicit(1).bitstr().optional(),
    this.key("subjectUniqueID").implicit(2).bitstr().optional(),
    this.key("extensions").explicit(3).seqof(Extension).optional()
  );
}), X509Certificate = asn.define("X509Certificate", function() {
  this.seq().obj(
    this.key("tbsCertificate").use(TBSCertificate),
    this.key("signatureAlgorithm").use(AlgorithmIdentifier$1),
    this.key("signatureValue").bitstr()
  );
}), certificate = X509Certificate, asn1$1 = asn1$2;
asn1$3.certificate = certificate;
var RSAPrivateKey = asn1$1.define("RSAPrivateKey", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("modulus").int(),
    this.key("publicExponent").int(),
    this.key("privateExponent").int(),
    this.key("prime1").int(),
    this.key("prime2").int(),
    this.key("exponent1").int(),
    this.key("exponent2").int(),
    this.key("coefficient").int()
  );
});
asn1$3.RSAPrivateKey = RSAPrivateKey;
var RSAPublicKey = asn1$1.define("RSAPublicKey", function() {
  this.seq().obj(
    this.key("modulus").int(),
    this.key("publicExponent").int()
  );
});
asn1$3.RSAPublicKey = RSAPublicKey;
var PublicKey = asn1$1.define("SubjectPublicKeyInfo", function() {
  this.seq().obj(
    this.key("algorithm").use(AlgorithmIdentifier),
    this.key("subjectPublicKey").bitstr()
  );
});
asn1$3.PublicKey = PublicKey;
var AlgorithmIdentifier = asn1$1.define("AlgorithmIdentifier", function() {
  this.seq().obj(
    this.key("algorithm").objid(),
    this.key("none").null_().optional(),
    this.key("curve").objid().optional(),
    this.key("params").seq().obj(
      this.key("p").int(),
      this.key("q").int(),
      this.key("g").int()
    ).optional()
  );
}), PrivateKeyInfo = asn1$1.define("PrivateKeyInfo", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("algorithm").use(AlgorithmIdentifier),
    this.key("subjectPrivateKey").octstr()
  );
});
asn1$3.PrivateKey = PrivateKeyInfo;
var EncryptedPrivateKeyInfo = asn1$1.define("EncryptedPrivateKeyInfo", function() {
  this.seq().obj(
    this.key("algorithm").seq().obj(
      this.key("id").objid(),
      this.key("decrypt").seq().obj(
        this.key("kde").seq().obj(
          this.key("id").objid(),
          this.key("kdeparams").seq().obj(
            this.key("salt").octstr(),
            this.key("iters").int()
          )
        ),
        this.key("cipher").seq().obj(
          this.key("algo").objid(),
          this.key("iv").octstr()
        )
      )
    ),
    this.key("subjectPrivateKey").octstr()
  );
});
asn1$3.EncryptedPrivateKey = EncryptedPrivateKeyInfo;
var DSAPrivateKey = asn1$1.define("DSAPrivateKey", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("p").int(),
    this.key("q").int(),
    this.key("g").int(),
    this.key("pub_key").int(),
    this.key("priv_key").int()
  );
});
asn1$3.DSAPrivateKey = DSAPrivateKey;
asn1$3.DSAparam = asn1$1.define("DSAparam", function() {
  this.int();
});
var ECPrivateKey = asn1$1.define("ECPrivateKey", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("privateKey").octstr(),
    this.key("parameters").optional().explicit(0).use(ECParameters),
    this.key("publicKey").optional().explicit(1).bitstr()
  );
});
asn1$3.ECPrivateKey = ECPrivateKey;
var ECParameters = asn1$1.define("ECParameters", function() {
  this.choice({
    namedCurve: this.objid()
  });
});
asn1$3.signature = asn1$1.define("signature", function() {
  this.seq().obj(
    this.key("r").int(),
    this.key("s").int()
  );
});
const require$$1 = {
  "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
  "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
  "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
  "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
  "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
  "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
  "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
  "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
  "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
  "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
  "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
  "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
};
var findProc = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, startRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, fullRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, evp = evp_bytestokey, ciphers$1 = browser$6, Buffer$b = safeBufferExports$3.Buffer, fixProc$1 = function(a, u) {
  var c = a.toString(), l = c.match(findProc), v;
  if (l) {
    var _ = "aes" + l[1], k = Buffer$b.from(l[2], "hex"), O = Buffer$b.from(l[3].replace(/[\r\n]/g, ""), "base64"), D = evp(u, k.slice(0, 8), parseInt(l[1], 10)).key, F = [], z = ciphers$1.createDecipheriv(_, D, k);
    F.push(z.update(O)), F.push(z.final()), v = Buffer$b.concat(F);
  } else {
    var p = c.match(fullRegex);
    v = Buffer$b.from(p[2].replace(/[\r\n]/g, ""), "base64");
  }
  var j = c.match(startRegex)[1];
  return {
    tag: j,
    data: v
  };
}, asn1 = asn1$3, aesid = require$$1, fixProc = fixProc$1, ciphers = browser$6, compat = browser$8, Buffer$a = safeBufferExports$3.Buffer, parseAsn1 = parseKeys$2;
function parseKeys$2(a) {
  var u;
  typeof a == "object" && !Buffer$a.isBuffer(a) && (u = a.passphrase, a = a.key), typeof a == "string" && (a = Buffer$a.from(a));
  var c = fixProc(a, u), l = c.tag, v = c.data, p, _;
  switch (l) {
    case "CERTIFICATE":
      _ = asn1.certificate.decode(v, "der").tbsCertificate.subjectPublicKeyInfo;
    case "PUBLIC KEY":
      switch (_ || (_ = asn1.PublicKey.decode(v, "der")), p = _.algorithm.algorithm.join("."), p) {
        case "1.2.840.113549.1.1.1":
          return asn1.RSAPublicKey.decode(_.subjectPublicKey.data, "der");
        case "1.2.840.10045.2.1":
          return _.subjectPrivateKey = _.subjectPublicKey, {
            type: "ec",
            data: _
          };
        case "1.2.840.10040.4.1":
          return _.algorithm.params.pub_key = asn1.DSAparam.decode(_.subjectPublicKey.data, "der"), {
            type: "dsa",
            data: _.algorithm.params
          };
        default:
          throw new Error("unknown key id " + p);
      }
    case "ENCRYPTED PRIVATE KEY":
      v = asn1.EncryptedPrivateKey.decode(v, "der"), v = decrypt(v, u);
    case "PRIVATE KEY":
      switch (_ = asn1.PrivateKey.decode(v, "der"), p = _.algorithm.algorithm.join("."), p) {
        case "1.2.840.113549.1.1.1":
          return asn1.RSAPrivateKey.decode(_.subjectPrivateKey, "der");
        case "1.2.840.10045.2.1":
          return {
            curve: _.algorithm.curve,
            privateKey: asn1.ECPrivateKey.decode(_.subjectPrivateKey, "der").privateKey
          };
        case "1.2.840.10040.4.1":
          return _.algorithm.params.priv_key = asn1.DSAparam.decode(_.subjectPrivateKey, "der"), {
            type: "dsa",
            params: _.algorithm.params
          };
        default:
          throw new Error("unknown key id " + p);
      }
    case "RSA PUBLIC KEY":
      return asn1.RSAPublicKey.decode(v, "der");
    case "RSA PRIVATE KEY":
      return asn1.RSAPrivateKey.decode(v, "der");
    case "DSA PRIVATE KEY":
      return {
        type: "dsa",
        params: asn1.DSAPrivateKey.decode(v, "der")
      };
    case "EC PRIVATE KEY":
      return v = asn1.ECPrivateKey.decode(v, "der"), {
        curve: v.parameters.value,
        privateKey: v.privateKey
      };
    default:
      throw new Error("unknown key type " + l);
  }
}
parseKeys$2.signature = asn1.signature;
function decrypt(a, u) {
  var c = a.algorithm.decrypt.kde.kdeparams.salt, l = parseInt(a.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), v = aesid[a.algorithm.decrypt.cipher.algo.join(".")], p = a.algorithm.decrypt.cipher.iv, _ = a.subjectPrivateKey, k = parseInt(v.split("-")[1], 10) / 8, O = compat.pbkdf2Sync(u, c, l, k, "sha1"), D = ciphers.createDecipheriv(v, O, p), F = [];
  return F.push(D.update(_)), F.push(D.final()), Buffer$a.concat(F);
}
const require$$4 = {
  "1.3.132.0.10": "secp256k1",
  "1.3.132.0.33": "p224",
  "1.2.840.10045.3.1.1": "p192",
  "1.2.840.10045.3.1.7": "p256",
  "1.3.132.0.34": "p384",
  "1.3.132.0.35": "p521"
};
var hasRequiredSign;
function requireSign() {
  if (hasRequiredSign)
    return sign$1.exports;
  hasRequiredSign = 1;
  var a = safeBufferExports.Buffer, u = browser$9, c = browserifyRsa, l = requireElliptic().ec, v = bnExports$4, p = parseAsn1, _ = require$$4, k = 1;
  function O(ne, Z, de, fe, Te) {
    var Re = p(Z);
    if (Re.curve) {
      if (fe !== "ecdsa" && fe !== "ecdsa/rsa")
        throw new Error("wrong private key type");
      return D(ne, Re);
    } else if (Re.type === "dsa") {
      if (fe !== "dsa")
        throw new Error("wrong private key type");
      return F(ne, Re, de);
    }
    if (fe !== "rsa" && fe !== "ecdsa/rsa")
      throw new Error("wrong private key type");
    if (Z.padding !== void 0 && Z.padding !== k)
      throw new Error("illegal or unsupported padding mode");
    ne = a.concat([Te, ne]);
    for (var Le = Re.modulus.byteLength(), be = [0, 1]; ne.length + be.length + 1 < Le; )
      be.push(255);
    be.push(0);
    for (var q = -1; ++q < ne.length; )
      be.push(ne[q]);
    var J = c(be, Re);
    return J;
  }
  function D(ne, Z) {
    var de = _[Z.curve.join(".")];
    if (!de)
      throw new Error("unknown curve " + Z.curve.join("."));
    var fe = new l(de), Te = fe.keyFromPrivate(Z.privateKey), Re = Te.sign(ne);
    return a.from(Re.toDER());
  }
  function F(ne, Z, de) {
    for (var fe = Z.params.priv_key, Te = Z.params.p, Re = Z.params.q, Le = Z.params.g, be = new v(0), q, J = ee(ne, Re).mod(Re), C = !1, S = j(fe, Re, ne, de); C === !1; )
      q = ae(Re, S, de), be = Q(Le, q, Te, Re), C = q.invm(Re).imul(J.add(fe.mul(be))).mod(Re), C.cmpn(0) === 0 && (C = !1, be = new v(0));
    return z(be, C);
  }
  function z(ne, Z) {
    ne = ne.toArray(), Z = Z.toArray(), ne[0] & 128 && (ne = [0].concat(ne)), Z[0] & 128 && (Z = [0].concat(Z));
    var de = ne.length + Z.length + 4, fe = [
      48,
      de,
      2,
      ne.length
    ];
    return fe = fe.concat(ne, [2, Z.length], Z), a.from(fe);
  }
  function j(ne, Z, de, fe) {
    if (ne = a.from(ne.toArray()), ne.length < Z.byteLength()) {
      var Te = a.alloc(Z.byteLength() - ne.length);
      ne = a.concat([Te, ne]);
    }
    var Re = de.length, Le = X(de, Z), be = a.alloc(Re);
    be.fill(1);
    var q = a.alloc(Re);
    return q = u(fe, q).update(be).update(a.from([0])).update(ne).update(Le).digest(), be = u(fe, q).update(be).digest(), q = u(fe, q).update(be).update(a.from([1])).update(ne).update(Le).digest(), be = u(fe, q).update(be).digest(), { k: q, v: be };
  }
  function ee(ne, Z) {
    var de = new v(ne), fe = (ne.length << 3) - Z.bitLength();
    return fe > 0 && de.ishrn(fe), de;
  }
  function X(ne, Z) {
    ne = ee(ne, Z), ne = ne.mod(Z);
    var de = a.from(ne.toArray());
    if (de.length < Z.byteLength()) {
      var fe = a.alloc(Z.byteLength() - de.length);
      de = a.concat([fe, de]);
    }
    return de;
  }
  function ae(ne, Z, de) {
    var fe, Te;
    do {
      for (fe = a.alloc(0); fe.length * 8 < ne.bitLength(); )
        Z.v = u(de, Z.k).update(Z.v).digest(), fe = a.concat([fe, Z.v]);
      Te = ee(fe, ne), Z.k = u(de, Z.k).update(Z.v).update(a.from([0])).digest(), Z.v = u(de, Z.k).update(Z.v).digest();
    } while (Te.cmp(ne) !== -1);
    return Te;
  }
  function Q(ne, Z, de, fe) {
    return ne.toRed(v.mont(de)).redPow(Z).fromRed().mod(fe);
  }
  return sign$1.exports = O, sign$1.exports.getKey = j, sign$1.exports.makeKey = ae, sign$1.exports;
}
var verify_1, hasRequiredVerify;
function requireVerify() {
  if (hasRequiredVerify)
    return verify_1;
  hasRequiredVerify = 1;
  var a = safeBufferExports.Buffer, u = bnExports$4, c = requireElliptic().ec, l = parseAsn1, v = require$$4;
  function p(D, F, z, j, ee) {
    var X = l(z);
    if (X.type === "ec") {
      if (j !== "ecdsa" && j !== "ecdsa/rsa")
        throw new Error("wrong public key type");
      return _(D, F, X);
    } else if (X.type === "dsa") {
      if (j !== "dsa")
        throw new Error("wrong public key type");
      return k(D, F, X);
    }
    if (j !== "rsa" && j !== "ecdsa/rsa")
      throw new Error("wrong public key type");
    F = a.concat([ee, F]);
    for (var ae = X.modulus.byteLength(), Q = [1], ne = 0; F.length + Q.length + 2 < ae; )
      Q.push(255), ne += 1;
    Q.push(0);
    for (var Z = -1; ++Z < F.length; )
      Q.push(F[Z]);
    Q = a.from(Q);
    var de = u.mont(X.modulus);
    D = new u(D).toRed(de), D = D.redPow(new u(X.publicExponent)), D = a.from(D.fromRed().toArray());
    var fe = ne < 8 ? 1 : 0;
    for (ae = Math.min(D.length, Q.length), D.length !== Q.length && (fe = 1), Z = -1; ++Z < ae; )
      fe |= D[Z] ^ Q[Z];
    return fe === 0;
  }
  function _(D, F, z) {
    var j = v[z.data.algorithm.curve.join(".")];
    if (!j)
      throw new Error("unknown curve " + z.data.algorithm.curve.join("."));
    var ee = new c(j), X = z.data.subjectPrivateKey.data;
    return ee.verify(F, D, X);
  }
  function k(D, F, z) {
    var j = z.data.p, ee = z.data.q, X = z.data.g, ae = z.data.pub_key, Q = l.signature.decode(D, "der"), ne = Q.s, Z = Q.r;
    O(ne, ee), O(Z, ee);
    var de = u.mont(j), fe = ne.invm(ee), Te = X.toRed(de).redPow(new u(F).mul(fe).mod(ee)).fromRed().mul(ae.toRed(de).redPow(Z.mul(fe).mod(ee)).fromRed()).mod(j).mod(ee);
    return Te.cmp(Z) === 0;
  }
  function O(D, F) {
    if (D.cmpn(0) <= 0)
      throw new Error("invalid sig");
    if (D.cmp(F) >= 0)
      throw new Error("invalid sig");
  }
  return verify_1 = p, verify_1;
}
var browser$4, hasRequiredBrowser$1;
function requireBrowser$1() {
  if (hasRequiredBrowser$1)
    return browser$4;
  hasRequiredBrowser$1 = 1;
  var a = safeBufferExports.Buffer, u = browser$a, c = readableBrowserExports, l = inherits_browserExports, v = requireSign(), p = requireVerify(), _ = require$$6;
  Object.keys(_).forEach(function(z) {
    _[z].id = a.from(_[z].id, "hex"), _[z.toLowerCase()] = _[z];
  });
  function k(z) {
    c.Writable.call(this);
    var j = _[z];
    if (!j)
      throw new Error("Unknown message digest");
    this._hashType = j.hash, this._hash = u(j.hash), this._tag = j.id, this._signType = j.sign;
  }
  l(k, c.Writable), k.prototype._write = function(j, ee, X) {
    this._hash.update(j), X();
  }, k.prototype.update = function(j, ee) {
    return this._hash.update(typeof j == "string" ? a.from(j, ee) : j), this;
  }, k.prototype.sign = function(j, ee) {
    this.end();
    var X = this._hash.digest(), ae = v(X, j, this._hashType, this._signType, this._tag);
    return ee ? ae.toString(ee) : ae;
  };
  function O(z) {
    c.Writable.call(this);
    var j = _[z];
    if (!j)
      throw new Error("Unknown message digest");
    this._hash = u(j.hash), this._tag = j.id, this._signType = j.sign;
  }
  l(O, c.Writable), O.prototype._write = function(j, ee, X) {
    this._hash.update(j), X();
  }, O.prototype.update = function(j, ee) {
    return this._hash.update(typeof j == "string" ? a.from(j, ee) : j), this;
  }, O.prototype.verify = function(j, ee, X) {
    var ae = typeof ee == "string" ? a.from(ee, X) : ee;
    this.end();
    var Q = this._hash.digest();
    return p(ae, Q, j, this._signType, this._tag);
  };
  function D(z) {
    return new k(z);
  }
  function F(z) {
    return new O(z);
  }
  return browser$4 = {
    Sign: D,
    Verify: F,
    createSign: D,
    createVerify: F
  }, browser$4;
}
var bn$1 = { exports: {} };
bn$1.exports;
(function(a) {
  (function(u, c) {
    function l(C, S) {
      if (!C)
        throw new Error(S || "Assertion failed");
    }
    function v(C, S) {
      C.super_ = S;
      var E = function() {
      };
      E.prototype = S.prototype, C.prototype = new E(), C.prototype.constructor = C;
    }
    function p(C, S, E) {
      if (p.isBN(C))
        return C;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, C !== null && ((S === "le" || S === "be") && (E = S, S = 10), this._init(C || 0, S || 10, E || "be"));
    }
    typeof u == "object" ? u.exports = p : c.BN = p, p.BN = p, p.wordSize = 26;
    var _;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? _ = window.Buffer : _ = require$$0$2.Buffer;
    } catch {
    }
    p.isBN = function(S) {
      return S instanceof p ? !0 : S !== null && typeof S == "object" && S.constructor.wordSize === p.wordSize && Array.isArray(S.words);
    }, p.max = function(S, E) {
      return S.cmp(E) > 0 ? S : E;
    }, p.min = function(S, E) {
      return S.cmp(E) < 0 ? S : E;
    }, p.prototype._init = function(S, E, I) {
      if (typeof S == "number")
        return this._initNumber(S, E, I);
      if (typeof S == "object")
        return this._initArray(S, E, I);
      E === "hex" && (E = 16), l(E === (E | 0) && E >= 2 && E <= 36), S = S.toString().replace(/\s+/g, "");
      var M = 0;
      S[0] === "-" && (M++, this.negative = 1), M < S.length && (E === 16 ? this._parseHex(S, M, I) : (this._parseBase(S, E, M), I === "le" && this._initArray(this.toArray(), E, I)));
    }, p.prototype._initNumber = function(S, E, I) {
      S < 0 && (this.negative = 1, S = -S), S < 67108864 ? (this.words = [S & 67108863], this.length = 1) : S < 4503599627370496 ? (this.words = [
        S & 67108863,
        S / 67108864 & 67108863
      ], this.length = 2) : (l(S < 9007199254740992), this.words = [
        S & 67108863,
        S / 67108864 & 67108863,
        1
      ], this.length = 3), I === "le" && this._initArray(this.toArray(), E, I);
    }, p.prototype._initArray = function(S, E, I) {
      if (l(typeof S.length == "number"), S.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(S.length / 3), this.words = new Array(this.length);
      for (var M = 0; M < this.length; M++)
        this.words[M] = 0;
      var $, U, Y = 0;
      if (I === "be")
        for (M = S.length - 1, $ = 0; M >= 0; M -= 3)
          U = S[M] | S[M - 1] << 8 | S[M - 2] << 16, this.words[$] |= U << Y & 67108863, this.words[$ + 1] = U >>> 26 - Y & 67108863, Y += 24, Y >= 26 && (Y -= 26, $++);
      else if (I === "le")
        for (M = 0, $ = 0; M < S.length; M += 3)
          U = S[M] | S[M + 1] << 8 | S[M + 2] << 16, this.words[$] |= U << Y & 67108863, this.words[$ + 1] = U >>> 26 - Y & 67108863, Y += 24, Y >= 26 && (Y -= 26, $++);
      return this.strip();
    };
    function k(C, S) {
      var E = C.charCodeAt(S);
      return E >= 65 && E <= 70 ? E - 55 : E >= 97 && E <= 102 ? E - 87 : E - 48 & 15;
    }
    function O(C, S, E) {
      var I = k(C, E);
      return E - 1 >= S && (I |= k(C, E - 1) << 4), I;
    }
    p.prototype._parseHex = function(S, E, I) {
      this.length = Math.ceil((S.length - E) / 6), this.words = new Array(this.length);
      for (var M = 0; M < this.length; M++)
        this.words[M] = 0;
      var $ = 0, U = 0, Y;
      if (I === "be")
        for (M = S.length - 1; M >= E; M -= 2)
          Y = O(S, E, M) << $, this.words[U] |= Y & 67108863, $ >= 18 ? ($ -= 18, U += 1, this.words[U] |= Y >>> 26) : $ += 8;
      else {
        var L = S.length - E;
        for (M = L % 2 === 0 ? E + 1 : E; M < S.length; M += 2)
          Y = O(S, E, M) << $, this.words[U] |= Y & 67108863, $ >= 18 ? ($ -= 18, U += 1, this.words[U] |= Y >>> 26) : $ += 8;
      }
      this.strip();
    };
    function D(C, S, E, I) {
      for (var M = 0, $ = Math.min(C.length, E), U = S; U < $; U++) {
        var Y = C.charCodeAt(U) - 48;
        M *= I, Y >= 49 ? M += Y - 49 + 10 : Y >= 17 ? M += Y - 17 + 10 : M += Y;
      }
      return M;
    }
    p.prototype._parseBase = function(S, E, I) {
      this.words = [0], this.length = 1;
      for (var M = 0, $ = 1; $ <= 67108863; $ *= E)
        M++;
      M--, $ = $ / E | 0;
      for (var U = S.length - I, Y = U % M, L = Math.min(U, U - Y) + I, T = 0, B = I; B < L; B += M)
        T = D(S, B, B + M, E), this.imuln($), this.words[0] + T < 67108864 ? this.words[0] += T : this._iaddn(T);
      if (Y !== 0) {
        var te = 1;
        for (T = D(S, B, S.length, E), B = 0; B < Y; B++)
          te *= E;
        this.imuln(te), this.words[0] + T < 67108864 ? this.words[0] += T : this._iaddn(T);
      }
      this.strip();
    }, p.prototype.copy = function(S) {
      S.words = new Array(this.length);
      for (var E = 0; E < this.length; E++)
        S.words[E] = this.words[E];
      S.length = this.length, S.negative = this.negative, S.red = this.red;
    }, p.prototype.clone = function() {
      var S = new p(null);
      return this.copy(S), S;
    }, p.prototype._expand = function(S) {
      for (; this.length < S; )
        this.words[this.length++] = 0;
      return this;
    }, p.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, p.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, p.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var F = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], z = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], j = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    p.prototype.toString = function(S, E) {
      S = S || 10, E = E | 0 || 1;
      var I;
      if (S === 16 || S === "hex") {
        I = "";
        for (var M = 0, $ = 0, U = 0; U < this.length; U++) {
          var Y = this.words[U], L = ((Y << M | $) & 16777215).toString(16);
          $ = Y >>> 24 - M & 16777215, $ !== 0 || U !== this.length - 1 ? I = F[6 - L.length] + L + I : I = L + I, M += 2, M >= 26 && (M -= 26, U--);
        }
        for ($ !== 0 && (I = $.toString(16) + I); I.length % E !== 0; )
          I = "0" + I;
        return this.negative !== 0 && (I = "-" + I), I;
      }
      if (S === (S | 0) && S >= 2 && S <= 36) {
        var T = z[S], B = j[S];
        I = "";
        var te = this.clone();
        for (te.negative = 0; !te.isZero(); ) {
          var pe = te.modn(B).toString(S);
          te = te.idivn(B), te.isZero() ? I = pe + I : I = F[T - pe.length] + pe + I;
        }
        for (this.isZero() && (I = "0" + I); I.length % E !== 0; )
          I = "0" + I;
        return this.negative !== 0 && (I = "-" + I), I;
      }
      l(!1, "Base should be between 2 and 36");
    }, p.prototype.toNumber = function() {
      var S = this.words[0];
      return this.length === 2 ? S += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? S += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && l(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -S : S;
    }, p.prototype.toJSON = function() {
      return this.toString(16);
    }, p.prototype.toBuffer = function(S, E) {
      return l(typeof _ < "u"), this.toArrayLike(_, S, E);
    }, p.prototype.toArray = function(S, E) {
      return this.toArrayLike(Array, S, E);
    }, p.prototype.toArrayLike = function(S, E, I) {
      var M = this.byteLength(), $ = I || Math.max(1, M);
      l(M <= $, "byte array longer than desired length"), l($ > 0, "Requested array length <= 0"), this.strip();
      var U = E === "le", Y = new S($), L, T, B = this.clone();
      if (U) {
        for (T = 0; !B.isZero(); T++)
          L = B.andln(255), B.iushrn(8), Y[T] = L;
        for (; T < $; T++)
          Y[T] = 0;
      } else {
        for (T = 0; T < $ - M; T++)
          Y[T] = 0;
        for (T = 0; !B.isZero(); T++)
          L = B.andln(255), B.iushrn(8), Y[$ - T - 1] = L;
      }
      return Y;
    }, Math.clz32 ? p.prototype._countBits = function(S) {
      return 32 - Math.clz32(S);
    } : p.prototype._countBits = function(S) {
      var E = S, I = 0;
      return E >= 4096 && (I += 13, E >>>= 13), E >= 64 && (I += 7, E >>>= 7), E >= 8 && (I += 4, E >>>= 4), E >= 2 && (I += 2, E >>>= 2), I + E;
    }, p.prototype._zeroBits = function(S) {
      if (S === 0)
        return 26;
      var E = S, I = 0;
      return E & 8191 || (I += 13, E >>>= 13), E & 127 || (I += 7, E >>>= 7), E & 15 || (I += 4, E >>>= 4), E & 3 || (I += 2, E >>>= 2), E & 1 || I++, I;
    }, p.prototype.bitLength = function() {
      var S = this.words[this.length - 1], E = this._countBits(S);
      return (this.length - 1) * 26 + E;
    };
    function ee(C) {
      for (var S = new Array(C.bitLength()), E = 0; E < S.length; E++) {
        var I = E / 26 | 0, M = E % 26;
        S[E] = (C.words[I] & 1 << M) >>> M;
      }
      return S;
    }
    p.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var S = 0, E = 0; E < this.length; E++) {
        var I = this._zeroBits(this.words[E]);
        if (S += I, I !== 26)
          break;
      }
      return S;
    }, p.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, p.prototype.toTwos = function(S) {
      return this.negative !== 0 ? this.abs().inotn(S).iaddn(1) : this.clone();
    }, p.prototype.fromTwos = function(S) {
      return this.testn(S - 1) ? this.notn(S).iaddn(1).ineg() : this.clone();
    }, p.prototype.isNeg = function() {
      return this.negative !== 0;
    }, p.prototype.neg = function() {
      return this.clone().ineg();
    }, p.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, p.prototype.iuor = function(S) {
      for (; this.length < S.length; )
        this.words[this.length++] = 0;
      for (var E = 0; E < S.length; E++)
        this.words[E] = this.words[E] | S.words[E];
      return this.strip();
    }, p.prototype.ior = function(S) {
      return l((this.negative | S.negative) === 0), this.iuor(S);
    }, p.prototype.or = function(S) {
      return this.length > S.length ? this.clone().ior(S) : S.clone().ior(this);
    }, p.prototype.uor = function(S) {
      return this.length > S.length ? this.clone().iuor(S) : S.clone().iuor(this);
    }, p.prototype.iuand = function(S) {
      var E;
      this.length > S.length ? E = S : E = this;
      for (var I = 0; I < E.length; I++)
        this.words[I] = this.words[I] & S.words[I];
      return this.length = E.length, this.strip();
    }, p.prototype.iand = function(S) {
      return l((this.negative | S.negative) === 0), this.iuand(S);
    }, p.prototype.and = function(S) {
      return this.length > S.length ? this.clone().iand(S) : S.clone().iand(this);
    }, p.prototype.uand = function(S) {
      return this.length > S.length ? this.clone().iuand(S) : S.clone().iuand(this);
    }, p.prototype.iuxor = function(S) {
      var E, I;
      this.length > S.length ? (E = this, I = S) : (E = S, I = this);
      for (var M = 0; M < I.length; M++)
        this.words[M] = E.words[M] ^ I.words[M];
      if (this !== E)
        for (; M < E.length; M++)
          this.words[M] = E.words[M];
      return this.length = E.length, this.strip();
    }, p.prototype.ixor = function(S) {
      return l((this.negative | S.negative) === 0), this.iuxor(S);
    }, p.prototype.xor = function(S) {
      return this.length > S.length ? this.clone().ixor(S) : S.clone().ixor(this);
    }, p.prototype.uxor = function(S) {
      return this.length > S.length ? this.clone().iuxor(S) : S.clone().iuxor(this);
    }, p.prototype.inotn = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = Math.ceil(S / 26) | 0, I = S % 26;
      this._expand(E), I > 0 && E--;
      for (var M = 0; M < E; M++)
        this.words[M] = ~this.words[M] & 67108863;
      return I > 0 && (this.words[M] = ~this.words[M] & 67108863 >> 26 - I), this.strip();
    }, p.prototype.notn = function(S) {
      return this.clone().inotn(S);
    }, p.prototype.setn = function(S, E) {
      l(typeof S == "number" && S >= 0);
      var I = S / 26 | 0, M = S % 26;
      return this._expand(I + 1), E ? this.words[I] = this.words[I] | 1 << M : this.words[I] = this.words[I] & ~(1 << M), this.strip();
    }, p.prototype.iadd = function(S) {
      var E;
      if (this.negative !== 0 && S.negative === 0)
        return this.negative = 0, E = this.isub(S), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && S.negative !== 0)
        return S.negative = 0, E = this.isub(S), S.negative = 1, E._normSign();
      var I, M;
      this.length > S.length ? (I = this, M = S) : (I = S, M = this);
      for (var $ = 0, U = 0; U < M.length; U++)
        E = (I.words[U] | 0) + (M.words[U] | 0) + $, this.words[U] = E & 67108863, $ = E >>> 26;
      for (; $ !== 0 && U < I.length; U++)
        E = (I.words[U] | 0) + $, this.words[U] = E & 67108863, $ = E >>> 26;
      if (this.length = I.length, $ !== 0)
        this.words[this.length] = $, this.length++;
      else if (I !== this)
        for (; U < I.length; U++)
          this.words[U] = I.words[U];
      return this;
    }, p.prototype.add = function(S) {
      var E;
      return S.negative !== 0 && this.negative === 0 ? (S.negative = 0, E = this.sub(S), S.negative ^= 1, E) : S.negative === 0 && this.negative !== 0 ? (this.negative = 0, E = S.sub(this), this.negative = 1, E) : this.length > S.length ? this.clone().iadd(S) : S.clone().iadd(this);
    }, p.prototype.isub = function(S) {
      if (S.negative !== 0) {
        S.negative = 0;
        var E = this.iadd(S);
        return S.negative = 1, E._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(S), this.negative = 1, this._normSign();
      var I = this.cmp(S);
      if (I === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var M, $;
      I > 0 ? (M = this, $ = S) : (M = S, $ = this);
      for (var U = 0, Y = 0; Y < $.length; Y++)
        E = (M.words[Y] | 0) - ($.words[Y] | 0) + U, U = E >> 26, this.words[Y] = E & 67108863;
      for (; U !== 0 && Y < M.length; Y++)
        E = (M.words[Y] | 0) + U, U = E >> 26, this.words[Y] = E & 67108863;
      if (U === 0 && Y < M.length && M !== this)
        for (; Y < M.length; Y++)
          this.words[Y] = M.words[Y];
      return this.length = Math.max(this.length, Y), M !== this && (this.negative = 1), this.strip();
    }, p.prototype.sub = function(S) {
      return this.clone().isub(S);
    };
    function X(C, S, E) {
      E.negative = S.negative ^ C.negative;
      var I = C.length + S.length | 0;
      E.length = I, I = I - 1 | 0;
      var M = C.words[0] | 0, $ = S.words[0] | 0, U = M * $, Y = U & 67108863, L = U / 67108864 | 0;
      E.words[0] = Y;
      for (var T = 1; T < I; T++) {
        for (var B = L >>> 26, te = L & 67108863, pe = Math.min(T, S.length - 1), Ie = Math.max(0, T - C.length + 1); Ie <= pe; Ie++) {
          var $e = T - Ie | 0;
          M = C.words[$e] | 0, $ = S.words[Ie] | 0, U = M * $ + te, B += U / 67108864 | 0, te = U & 67108863;
        }
        E.words[T] = te | 0, L = B | 0;
      }
      return L !== 0 ? E.words[T] = L | 0 : E.length--, E.strip();
    }
    var ae = function(S, E, I) {
      var M = S.words, $ = E.words, U = I.words, Y = 0, L, T, B, te = M[0] | 0, pe = te & 8191, Ie = te >>> 13, $e = M[1] | 0, ve = $e & 8191, he = $e >>> 13, Oe = M[2] | 0, Ae = Oe & 8191, Ue = Oe >>> 13, oe = M[3] | 0, A = oe & 8191, re = oe >>> 13, le = M[4] | 0, Ne = le & 8191, Pe = le >>> 13, Fe = M[5] | 0, je = Fe & 8191, qe = Fe >>> 13, yt = M[6] | 0, Xe = yt & 8191, Ge = yt >>> 13, H = M[7] | 0, ye = H & 8191, Ee = H >>> 13, We = M[8] | 0, we = We & 8191, V = We >>> 13, _e = M[9] | 0, ue = _e & 8191, ce = _e >>> 13, me = $[0] | 0, Ce = me & 8191, Be = me >>> 13, ze = $[1] | 0, Je = ze & 8191, Ze = ze >>> 13, Ke = $[2] | 0, x = Ke & 8191, se = Ke >>> 13, ge = $[3] | 0, xe = ge & 8191, Me = ge >>> 13, Ye = $[4] | 0, et = Ye & 8191, dt = Ye >>> 13, St = $[5] | 0, tt = St & 8191, at = St >>> 13, kt = $[6] | 0, rt = kt & 8191, ut = kt >>> 13, wt = $[7] | 0, nt = wt & 8191, it = wt >>> 13, bt = $[8] | 0, ot = bt & 8191, ct = bt >>> 13, Pt = $[9] | 0, st = Pt & 8191, lt = Pt >>> 13;
      I.negative = S.negative ^ E.negative, I.length = 19, L = Math.imul(pe, Ce), T = Math.imul(pe, Be), T = T + Math.imul(Ie, Ce) | 0, B = Math.imul(Ie, Be);
      var It = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (It >>> 26) | 0, It &= 67108863, L = Math.imul(ve, Ce), T = Math.imul(ve, Be), T = T + Math.imul(he, Ce) | 0, B = Math.imul(he, Be), L = L + Math.imul(pe, Je) | 0, T = T + Math.imul(pe, Ze) | 0, T = T + Math.imul(Ie, Je) | 0, B = B + Math.imul(Ie, Ze) | 0;
      var Rt = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (Rt >>> 26) | 0, Rt &= 67108863, L = Math.imul(Ae, Ce), T = Math.imul(Ae, Be), T = T + Math.imul(Ue, Ce) | 0, B = Math.imul(Ue, Be), L = L + Math.imul(ve, Je) | 0, T = T + Math.imul(ve, Ze) | 0, T = T + Math.imul(he, Je) | 0, B = B + Math.imul(he, Ze) | 0, L = L + Math.imul(pe, x) | 0, T = T + Math.imul(pe, se) | 0, T = T + Math.imul(Ie, x) | 0, B = B + Math.imul(Ie, se) | 0;
      var Ve = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, L = Math.imul(A, Ce), T = Math.imul(A, Be), T = T + Math.imul(re, Ce) | 0, B = Math.imul(re, Be), L = L + Math.imul(Ae, Je) | 0, T = T + Math.imul(Ae, Ze) | 0, T = T + Math.imul(Ue, Je) | 0, B = B + Math.imul(Ue, Ze) | 0, L = L + Math.imul(ve, x) | 0, T = T + Math.imul(ve, se) | 0, T = T + Math.imul(he, x) | 0, B = B + Math.imul(he, se) | 0, L = L + Math.imul(pe, xe) | 0, T = T + Math.imul(pe, Me) | 0, T = T + Math.imul(Ie, xe) | 0, B = B + Math.imul(Ie, Me) | 0;
      var He = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, L = Math.imul(Ne, Ce), T = Math.imul(Ne, Be), T = T + Math.imul(Pe, Ce) | 0, B = Math.imul(Pe, Be), L = L + Math.imul(A, Je) | 0, T = T + Math.imul(A, Ze) | 0, T = T + Math.imul(re, Je) | 0, B = B + Math.imul(re, Ze) | 0, L = L + Math.imul(Ae, x) | 0, T = T + Math.imul(Ae, se) | 0, T = T + Math.imul(Ue, x) | 0, B = B + Math.imul(Ue, se) | 0, L = L + Math.imul(ve, xe) | 0, T = T + Math.imul(ve, Me) | 0, T = T + Math.imul(he, xe) | 0, B = B + Math.imul(he, Me) | 0, L = L + Math.imul(pe, et) | 0, T = T + Math.imul(pe, dt) | 0, T = T + Math.imul(Ie, et) | 0, B = B + Math.imul(Ie, dt) | 0;
      var Qe = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, L = Math.imul(je, Ce), T = Math.imul(je, Be), T = T + Math.imul(qe, Ce) | 0, B = Math.imul(qe, Be), L = L + Math.imul(Ne, Je) | 0, T = T + Math.imul(Ne, Ze) | 0, T = T + Math.imul(Pe, Je) | 0, B = B + Math.imul(Pe, Ze) | 0, L = L + Math.imul(A, x) | 0, T = T + Math.imul(A, se) | 0, T = T + Math.imul(re, x) | 0, B = B + Math.imul(re, se) | 0, L = L + Math.imul(Ae, xe) | 0, T = T + Math.imul(Ae, Me) | 0, T = T + Math.imul(Ue, xe) | 0, B = B + Math.imul(Ue, Me) | 0, L = L + Math.imul(ve, et) | 0, T = T + Math.imul(ve, dt) | 0, T = T + Math.imul(he, et) | 0, B = B + Math.imul(he, dt) | 0, L = L + Math.imul(pe, tt) | 0, T = T + Math.imul(pe, at) | 0, T = T + Math.imul(Ie, tt) | 0, B = B + Math.imul(Ie, at) | 0;
      var pt = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (pt >>> 26) | 0, pt &= 67108863, L = Math.imul(Xe, Ce), T = Math.imul(Xe, Be), T = T + Math.imul(Ge, Ce) | 0, B = Math.imul(Ge, Be), L = L + Math.imul(je, Je) | 0, T = T + Math.imul(je, Ze) | 0, T = T + Math.imul(qe, Je) | 0, B = B + Math.imul(qe, Ze) | 0, L = L + Math.imul(Ne, x) | 0, T = T + Math.imul(Ne, se) | 0, T = T + Math.imul(Pe, x) | 0, B = B + Math.imul(Pe, se) | 0, L = L + Math.imul(A, xe) | 0, T = T + Math.imul(A, Me) | 0, T = T + Math.imul(re, xe) | 0, B = B + Math.imul(re, Me) | 0, L = L + Math.imul(Ae, et) | 0, T = T + Math.imul(Ae, dt) | 0, T = T + Math.imul(Ue, et) | 0, B = B + Math.imul(Ue, dt) | 0, L = L + Math.imul(ve, tt) | 0, T = T + Math.imul(ve, at) | 0, T = T + Math.imul(he, tt) | 0, B = B + Math.imul(he, at) | 0, L = L + Math.imul(pe, rt) | 0, T = T + Math.imul(pe, ut) | 0, T = T + Math.imul(Ie, rt) | 0, B = B + Math.imul(Ie, ut) | 0;
      var mt = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (mt >>> 26) | 0, mt &= 67108863, L = Math.imul(ye, Ce), T = Math.imul(ye, Be), T = T + Math.imul(Ee, Ce) | 0, B = Math.imul(Ee, Be), L = L + Math.imul(Xe, Je) | 0, T = T + Math.imul(Xe, Ze) | 0, T = T + Math.imul(Ge, Je) | 0, B = B + Math.imul(Ge, Ze) | 0, L = L + Math.imul(je, x) | 0, T = T + Math.imul(je, se) | 0, T = T + Math.imul(qe, x) | 0, B = B + Math.imul(qe, se) | 0, L = L + Math.imul(Ne, xe) | 0, T = T + Math.imul(Ne, Me) | 0, T = T + Math.imul(Pe, xe) | 0, B = B + Math.imul(Pe, Me) | 0, L = L + Math.imul(A, et) | 0, T = T + Math.imul(A, dt) | 0, T = T + Math.imul(re, et) | 0, B = B + Math.imul(re, dt) | 0, L = L + Math.imul(Ae, tt) | 0, T = T + Math.imul(Ae, at) | 0, T = T + Math.imul(Ue, tt) | 0, B = B + Math.imul(Ue, at) | 0, L = L + Math.imul(ve, rt) | 0, T = T + Math.imul(ve, ut) | 0, T = T + Math.imul(he, rt) | 0, B = B + Math.imul(he, ut) | 0, L = L + Math.imul(pe, nt) | 0, T = T + Math.imul(pe, it) | 0, T = T + Math.imul(Ie, nt) | 0, B = B + Math.imul(Ie, it) | 0;
      var vt = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, L = Math.imul(we, Ce), T = Math.imul(we, Be), T = T + Math.imul(V, Ce) | 0, B = Math.imul(V, Be), L = L + Math.imul(ye, Je) | 0, T = T + Math.imul(ye, Ze) | 0, T = T + Math.imul(Ee, Je) | 0, B = B + Math.imul(Ee, Ze) | 0, L = L + Math.imul(Xe, x) | 0, T = T + Math.imul(Xe, se) | 0, T = T + Math.imul(Ge, x) | 0, B = B + Math.imul(Ge, se) | 0, L = L + Math.imul(je, xe) | 0, T = T + Math.imul(je, Me) | 0, T = T + Math.imul(qe, xe) | 0, B = B + Math.imul(qe, Me) | 0, L = L + Math.imul(Ne, et) | 0, T = T + Math.imul(Ne, dt) | 0, T = T + Math.imul(Pe, et) | 0, B = B + Math.imul(Pe, dt) | 0, L = L + Math.imul(A, tt) | 0, T = T + Math.imul(A, at) | 0, T = T + Math.imul(re, tt) | 0, B = B + Math.imul(re, at) | 0, L = L + Math.imul(Ae, rt) | 0, T = T + Math.imul(Ae, ut) | 0, T = T + Math.imul(Ue, rt) | 0, B = B + Math.imul(Ue, ut) | 0, L = L + Math.imul(ve, nt) | 0, T = T + Math.imul(ve, it) | 0, T = T + Math.imul(he, nt) | 0, B = B + Math.imul(he, it) | 0, L = L + Math.imul(pe, ot) | 0, T = T + Math.imul(pe, ct) | 0, T = T + Math.imul(Ie, ot) | 0, B = B + Math.imul(Ie, ct) | 0;
      var ht = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (ht >>> 26) | 0, ht &= 67108863, L = Math.imul(ue, Ce), T = Math.imul(ue, Be), T = T + Math.imul(ce, Ce) | 0, B = Math.imul(ce, Be), L = L + Math.imul(we, Je) | 0, T = T + Math.imul(we, Ze) | 0, T = T + Math.imul(V, Je) | 0, B = B + Math.imul(V, Ze) | 0, L = L + Math.imul(ye, x) | 0, T = T + Math.imul(ye, se) | 0, T = T + Math.imul(Ee, x) | 0, B = B + Math.imul(Ee, se) | 0, L = L + Math.imul(Xe, xe) | 0, T = T + Math.imul(Xe, Me) | 0, T = T + Math.imul(Ge, xe) | 0, B = B + Math.imul(Ge, Me) | 0, L = L + Math.imul(je, et) | 0, T = T + Math.imul(je, dt) | 0, T = T + Math.imul(qe, et) | 0, B = B + Math.imul(qe, dt) | 0, L = L + Math.imul(Ne, tt) | 0, T = T + Math.imul(Ne, at) | 0, T = T + Math.imul(Pe, tt) | 0, B = B + Math.imul(Pe, at) | 0, L = L + Math.imul(A, rt) | 0, T = T + Math.imul(A, ut) | 0, T = T + Math.imul(re, rt) | 0, B = B + Math.imul(re, ut) | 0, L = L + Math.imul(Ae, nt) | 0, T = T + Math.imul(Ae, it) | 0, T = T + Math.imul(Ue, nt) | 0, B = B + Math.imul(Ue, it) | 0, L = L + Math.imul(ve, ot) | 0, T = T + Math.imul(ve, ct) | 0, T = T + Math.imul(he, ot) | 0, B = B + Math.imul(he, ct) | 0, L = L + Math.imul(pe, st) | 0, T = T + Math.imul(pe, lt) | 0, T = T + Math.imul(Ie, st) | 0, B = B + Math.imul(Ie, lt) | 0;
      var Et = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, L = Math.imul(ue, Je), T = Math.imul(ue, Ze), T = T + Math.imul(ce, Je) | 0, B = Math.imul(ce, Ze), L = L + Math.imul(we, x) | 0, T = T + Math.imul(we, se) | 0, T = T + Math.imul(V, x) | 0, B = B + Math.imul(V, se) | 0, L = L + Math.imul(ye, xe) | 0, T = T + Math.imul(ye, Me) | 0, T = T + Math.imul(Ee, xe) | 0, B = B + Math.imul(Ee, Me) | 0, L = L + Math.imul(Xe, et) | 0, T = T + Math.imul(Xe, dt) | 0, T = T + Math.imul(Ge, et) | 0, B = B + Math.imul(Ge, dt) | 0, L = L + Math.imul(je, tt) | 0, T = T + Math.imul(je, at) | 0, T = T + Math.imul(qe, tt) | 0, B = B + Math.imul(qe, at) | 0, L = L + Math.imul(Ne, rt) | 0, T = T + Math.imul(Ne, ut) | 0, T = T + Math.imul(Pe, rt) | 0, B = B + Math.imul(Pe, ut) | 0, L = L + Math.imul(A, nt) | 0, T = T + Math.imul(A, it) | 0, T = T + Math.imul(re, nt) | 0, B = B + Math.imul(re, it) | 0, L = L + Math.imul(Ae, ot) | 0, T = T + Math.imul(Ae, ct) | 0, T = T + Math.imul(Ue, ot) | 0, B = B + Math.imul(Ue, ct) | 0, L = L + Math.imul(ve, st) | 0, T = T + Math.imul(ve, lt) | 0, T = T + Math.imul(he, st) | 0, B = B + Math.imul(he, lt) | 0;
      var Tt = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (Tt >>> 26) | 0, Tt &= 67108863, L = Math.imul(ue, x), T = Math.imul(ue, se), T = T + Math.imul(ce, x) | 0, B = Math.imul(ce, se), L = L + Math.imul(we, xe) | 0, T = T + Math.imul(we, Me) | 0, T = T + Math.imul(V, xe) | 0, B = B + Math.imul(V, Me) | 0, L = L + Math.imul(ye, et) | 0, T = T + Math.imul(ye, dt) | 0, T = T + Math.imul(Ee, et) | 0, B = B + Math.imul(Ee, dt) | 0, L = L + Math.imul(Xe, tt) | 0, T = T + Math.imul(Xe, at) | 0, T = T + Math.imul(Ge, tt) | 0, B = B + Math.imul(Ge, at) | 0, L = L + Math.imul(je, rt) | 0, T = T + Math.imul(je, ut) | 0, T = T + Math.imul(qe, rt) | 0, B = B + Math.imul(qe, ut) | 0, L = L + Math.imul(Ne, nt) | 0, T = T + Math.imul(Ne, it) | 0, T = T + Math.imul(Pe, nt) | 0, B = B + Math.imul(Pe, it) | 0, L = L + Math.imul(A, ot) | 0, T = T + Math.imul(A, ct) | 0, T = T + Math.imul(re, ot) | 0, B = B + Math.imul(re, ct) | 0, L = L + Math.imul(Ae, st) | 0, T = T + Math.imul(Ae, lt) | 0, T = T + Math.imul(Ue, st) | 0, B = B + Math.imul(Ue, lt) | 0;
      var Ot = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (Ot >>> 26) | 0, Ot &= 67108863, L = Math.imul(ue, xe), T = Math.imul(ue, Me), T = T + Math.imul(ce, xe) | 0, B = Math.imul(ce, Me), L = L + Math.imul(we, et) | 0, T = T + Math.imul(we, dt) | 0, T = T + Math.imul(V, et) | 0, B = B + Math.imul(V, dt) | 0, L = L + Math.imul(ye, tt) | 0, T = T + Math.imul(ye, at) | 0, T = T + Math.imul(Ee, tt) | 0, B = B + Math.imul(Ee, at) | 0, L = L + Math.imul(Xe, rt) | 0, T = T + Math.imul(Xe, ut) | 0, T = T + Math.imul(Ge, rt) | 0, B = B + Math.imul(Ge, ut) | 0, L = L + Math.imul(je, nt) | 0, T = T + Math.imul(je, it) | 0, T = T + Math.imul(qe, nt) | 0, B = B + Math.imul(qe, it) | 0, L = L + Math.imul(Ne, ot) | 0, T = T + Math.imul(Ne, ct) | 0, T = T + Math.imul(Pe, ot) | 0, B = B + Math.imul(Pe, ct) | 0, L = L + Math.imul(A, st) | 0, T = T + Math.imul(A, lt) | 0, T = T + Math.imul(re, st) | 0, B = B + Math.imul(re, lt) | 0;
      var Nt = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, L = Math.imul(ue, et), T = Math.imul(ue, dt), T = T + Math.imul(ce, et) | 0, B = Math.imul(ce, dt), L = L + Math.imul(we, tt) | 0, T = T + Math.imul(we, at) | 0, T = T + Math.imul(V, tt) | 0, B = B + Math.imul(V, at) | 0, L = L + Math.imul(ye, rt) | 0, T = T + Math.imul(ye, ut) | 0, T = T + Math.imul(Ee, rt) | 0, B = B + Math.imul(Ee, ut) | 0, L = L + Math.imul(Xe, nt) | 0, T = T + Math.imul(Xe, it) | 0, T = T + Math.imul(Ge, nt) | 0, B = B + Math.imul(Ge, it) | 0, L = L + Math.imul(je, ot) | 0, T = T + Math.imul(je, ct) | 0, T = T + Math.imul(qe, ot) | 0, B = B + Math.imul(qe, ct) | 0, L = L + Math.imul(Ne, st) | 0, T = T + Math.imul(Ne, lt) | 0, T = T + Math.imul(Pe, st) | 0, B = B + Math.imul(Pe, lt) | 0;
      var At = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, L = Math.imul(ue, tt), T = Math.imul(ue, at), T = T + Math.imul(ce, tt) | 0, B = Math.imul(ce, at), L = L + Math.imul(we, rt) | 0, T = T + Math.imul(we, ut) | 0, T = T + Math.imul(V, rt) | 0, B = B + Math.imul(V, ut) | 0, L = L + Math.imul(ye, nt) | 0, T = T + Math.imul(ye, it) | 0, T = T + Math.imul(Ee, nt) | 0, B = B + Math.imul(Ee, it) | 0, L = L + Math.imul(Xe, ot) | 0, T = T + Math.imul(Xe, ct) | 0, T = T + Math.imul(Ge, ot) | 0, B = B + Math.imul(Ge, ct) | 0, L = L + Math.imul(je, st) | 0, T = T + Math.imul(je, lt) | 0, T = T + Math.imul(qe, st) | 0, B = B + Math.imul(qe, lt) | 0;
      var Mt = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (Mt >>> 26) | 0, Mt &= 67108863, L = Math.imul(ue, rt), T = Math.imul(ue, ut), T = T + Math.imul(ce, rt) | 0, B = Math.imul(ce, ut), L = L + Math.imul(we, nt) | 0, T = T + Math.imul(we, it) | 0, T = T + Math.imul(V, nt) | 0, B = B + Math.imul(V, it) | 0, L = L + Math.imul(ye, ot) | 0, T = T + Math.imul(ye, ct) | 0, T = T + Math.imul(Ee, ot) | 0, B = B + Math.imul(Ee, ct) | 0, L = L + Math.imul(Xe, st) | 0, T = T + Math.imul(Xe, lt) | 0, T = T + Math.imul(Ge, st) | 0, B = B + Math.imul(Ge, lt) | 0;
      var $t = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + ($t >>> 26) | 0, $t &= 67108863, L = Math.imul(ue, nt), T = Math.imul(ue, it), T = T + Math.imul(ce, nt) | 0, B = Math.imul(ce, it), L = L + Math.imul(we, ot) | 0, T = T + Math.imul(we, ct) | 0, T = T + Math.imul(V, ot) | 0, B = B + Math.imul(V, ct) | 0, L = L + Math.imul(ye, st) | 0, T = T + Math.imul(ye, lt) | 0, T = T + Math.imul(Ee, st) | 0, B = B + Math.imul(Ee, lt) | 0;
      var Bt = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, L = Math.imul(ue, ot), T = Math.imul(ue, ct), T = T + Math.imul(ce, ot) | 0, B = Math.imul(ce, ct), L = L + Math.imul(we, st) | 0, T = T + Math.imul(we, lt) | 0, T = T + Math.imul(V, st) | 0, B = B + Math.imul(V, lt) | 0;
      var Ut = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (Ut >>> 26) | 0, Ut &= 67108863, L = Math.imul(ue, st), T = Math.imul(ue, lt), T = T + Math.imul(ce, st) | 0, B = Math.imul(ce, lt);
      var xt = (Y + L | 0) + ((T & 8191) << 13) | 0;
      return Y = (B + (T >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, U[0] = It, U[1] = Rt, U[2] = Ve, U[3] = He, U[4] = Qe, U[5] = pt, U[6] = mt, U[7] = vt, U[8] = ht, U[9] = Et, U[10] = Tt, U[11] = Ot, U[12] = Nt, U[13] = At, U[14] = Mt, U[15] = $t, U[16] = Bt, U[17] = Ut, U[18] = xt, Y !== 0 && (U[19] = Y, I.length++), I;
    };
    Math.imul || (ae = X);
    function Q(C, S, E) {
      E.negative = S.negative ^ C.negative, E.length = C.length + S.length;
      for (var I = 0, M = 0, $ = 0; $ < E.length - 1; $++) {
        var U = M;
        M = 0;
        for (var Y = I & 67108863, L = Math.min($, S.length - 1), T = Math.max(0, $ - C.length + 1); T <= L; T++) {
          var B = $ - T, te = C.words[B] | 0, pe = S.words[T] | 0, Ie = te * pe, $e = Ie & 67108863;
          U = U + (Ie / 67108864 | 0) | 0, $e = $e + Y | 0, Y = $e & 67108863, U = U + ($e >>> 26) | 0, M += U >>> 26, U &= 67108863;
        }
        E.words[$] = Y, I = U, U = M;
      }
      return I !== 0 ? E.words[$] = I : E.length--, E.strip();
    }
    function ne(C, S, E) {
      var I = new Z();
      return I.mulp(C, S, E);
    }
    p.prototype.mulTo = function(S, E) {
      var I, M = this.length + S.length;
      return this.length === 10 && S.length === 10 ? I = ae(this, S, E) : M < 63 ? I = X(this, S, E) : M < 1024 ? I = Q(this, S, E) : I = ne(this, S, E), I;
    };
    function Z(C, S) {
      this.x = C, this.y = S;
    }
    Z.prototype.makeRBT = function(S) {
      for (var E = new Array(S), I = p.prototype._countBits(S) - 1, M = 0; M < S; M++)
        E[M] = this.revBin(M, I, S);
      return E;
    }, Z.prototype.revBin = function(S, E, I) {
      if (S === 0 || S === I - 1)
        return S;
      for (var M = 0, $ = 0; $ < E; $++)
        M |= (S & 1) << E - $ - 1, S >>= 1;
      return M;
    }, Z.prototype.permute = function(S, E, I, M, $, U) {
      for (var Y = 0; Y < U; Y++)
        M[Y] = E[S[Y]], $[Y] = I[S[Y]];
    }, Z.prototype.transform = function(S, E, I, M, $, U) {
      this.permute(U, S, E, I, M, $);
      for (var Y = 1; Y < $; Y <<= 1)
        for (var L = Y << 1, T = Math.cos(2 * Math.PI / L), B = Math.sin(2 * Math.PI / L), te = 0; te < $; te += L)
          for (var pe = T, Ie = B, $e = 0; $e < Y; $e++) {
            var ve = I[te + $e], he = M[te + $e], Oe = I[te + $e + Y], Ae = M[te + $e + Y], Ue = pe * Oe - Ie * Ae;
            Ae = pe * Ae + Ie * Oe, Oe = Ue, I[te + $e] = ve + Oe, M[te + $e] = he + Ae, I[te + $e + Y] = ve - Oe, M[te + $e + Y] = he - Ae, $e !== L && (Ue = T * pe - B * Ie, Ie = T * Ie + B * pe, pe = Ue);
          }
    }, Z.prototype.guessLen13b = function(S, E) {
      var I = Math.max(E, S) | 1, M = I & 1, $ = 0;
      for (I = I / 2 | 0; I; I = I >>> 1)
        $++;
      return 1 << $ + 1 + M;
    }, Z.prototype.conjugate = function(S, E, I) {
      if (!(I <= 1))
        for (var M = 0; M < I / 2; M++) {
          var $ = S[M];
          S[M] = S[I - M - 1], S[I - M - 1] = $, $ = E[M], E[M] = -E[I - M - 1], E[I - M - 1] = -$;
        }
    }, Z.prototype.normalize13b = function(S, E) {
      for (var I = 0, M = 0; M < E / 2; M++) {
        var $ = Math.round(S[2 * M + 1] / E) * 8192 + Math.round(S[2 * M] / E) + I;
        S[M] = $ & 67108863, $ < 67108864 ? I = 0 : I = $ / 67108864 | 0;
      }
      return S;
    }, Z.prototype.convert13b = function(S, E, I, M) {
      for (var $ = 0, U = 0; U < E; U++)
        $ = $ + (S[U] | 0), I[2 * U] = $ & 8191, $ = $ >>> 13, I[2 * U + 1] = $ & 8191, $ = $ >>> 13;
      for (U = 2 * E; U < M; ++U)
        I[U] = 0;
      l($ === 0), l(($ & -8192) === 0);
    }, Z.prototype.stub = function(S) {
      for (var E = new Array(S), I = 0; I < S; I++)
        E[I] = 0;
      return E;
    }, Z.prototype.mulp = function(S, E, I) {
      var M = 2 * this.guessLen13b(S.length, E.length), $ = this.makeRBT(M), U = this.stub(M), Y = new Array(M), L = new Array(M), T = new Array(M), B = new Array(M), te = new Array(M), pe = new Array(M), Ie = I.words;
      Ie.length = M, this.convert13b(S.words, S.length, Y, M), this.convert13b(E.words, E.length, B, M), this.transform(Y, U, L, T, M, $), this.transform(B, U, te, pe, M, $);
      for (var $e = 0; $e < M; $e++) {
        var ve = L[$e] * te[$e] - T[$e] * pe[$e];
        T[$e] = L[$e] * pe[$e] + T[$e] * te[$e], L[$e] = ve;
      }
      return this.conjugate(L, T, M), this.transform(L, T, Ie, U, M, $), this.conjugate(Ie, U, M), this.normalize13b(Ie, M), I.negative = S.negative ^ E.negative, I.length = S.length + E.length, I.strip();
    }, p.prototype.mul = function(S) {
      var E = new p(null);
      return E.words = new Array(this.length + S.length), this.mulTo(S, E);
    }, p.prototype.mulf = function(S) {
      var E = new p(null);
      return E.words = new Array(this.length + S.length), ne(this, S, E);
    }, p.prototype.imul = function(S) {
      return this.clone().mulTo(S, this);
    }, p.prototype.imuln = function(S) {
      l(typeof S == "number"), l(S < 67108864);
      for (var E = 0, I = 0; I < this.length; I++) {
        var M = (this.words[I] | 0) * S, $ = (M & 67108863) + (E & 67108863);
        E >>= 26, E += M / 67108864 | 0, E += $ >>> 26, this.words[I] = $ & 67108863;
      }
      return E !== 0 && (this.words[I] = E, this.length++), this;
    }, p.prototype.muln = function(S) {
      return this.clone().imuln(S);
    }, p.prototype.sqr = function() {
      return this.mul(this);
    }, p.prototype.isqr = function() {
      return this.imul(this.clone());
    }, p.prototype.pow = function(S) {
      var E = ee(S);
      if (E.length === 0)
        return new p(1);
      for (var I = this, M = 0; M < E.length && E[M] === 0; M++, I = I.sqr())
        ;
      if (++M < E.length)
        for (var $ = I.sqr(); M < E.length; M++, $ = $.sqr())
          E[M] !== 0 && (I = I.mul($));
      return I;
    }, p.prototype.iushln = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = S % 26, I = (S - E) / 26, M = 67108863 >>> 26 - E << 26 - E, $;
      if (E !== 0) {
        var U = 0;
        for ($ = 0; $ < this.length; $++) {
          var Y = this.words[$] & M, L = (this.words[$] | 0) - Y << E;
          this.words[$] = L | U, U = Y >>> 26 - E;
        }
        U && (this.words[$] = U, this.length++);
      }
      if (I !== 0) {
        for ($ = this.length - 1; $ >= 0; $--)
          this.words[$ + I] = this.words[$];
        for ($ = 0; $ < I; $++)
          this.words[$] = 0;
        this.length += I;
      }
      return this.strip();
    }, p.prototype.ishln = function(S) {
      return l(this.negative === 0), this.iushln(S);
    }, p.prototype.iushrn = function(S, E, I) {
      l(typeof S == "number" && S >= 0);
      var M;
      E ? M = (E - E % 26) / 26 : M = 0;
      var $ = S % 26, U = Math.min((S - $) / 26, this.length), Y = 67108863 ^ 67108863 >>> $ << $, L = I;
      if (M -= U, M = Math.max(0, M), L) {
        for (var T = 0; T < U; T++)
          L.words[T] = this.words[T];
        L.length = U;
      }
      if (U !== 0)
        if (this.length > U)
          for (this.length -= U, T = 0; T < this.length; T++)
            this.words[T] = this.words[T + U];
        else
          this.words[0] = 0, this.length = 1;
      var B = 0;
      for (T = this.length - 1; T >= 0 && (B !== 0 || T >= M); T--) {
        var te = this.words[T] | 0;
        this.words[T] = B << 26 - $ | te >>> $, B = te & Y;
      }
      return L && B !== 0 && (L.words[L.length++] = B), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, p.prototype.ishrn = function(S, E, I) {
      return l(this.negative === 0), this.iushrn(S, E, I);
    }, p.prototype.shln = function(S) {
      return this.clone().ishln(S);
    }, p.prototype.ushln = function(S) {
      return this.clone().iushln(S);
    }, p.prototype.shrn = function(S) {
      return this.clone().ishrn(S);
    }, p.prototype.ushrn = function(S) {
      return this.clone().iushrn(S);
    }, p.prototype.testn = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = S % 26, I = (S - E) / 26, M = 1 << E;
      if (this.length <= I)
        return !1;
      var $ = this.words[I];
      return !!($ & M);
    }, p.prototype.imaskn = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = S % 26, I = (S - E) / 26;
      if (l(this.negative === 0, "imaskn works only with positive numbers"), this.length <= I)
        return this;
      if (E !== 0 && I++, this.length = Math.min(I, this.length), E !== 0) {
        var M = 67108863 ^ 67108863 >>> E << E;
        this.words[this.length - 1] &= M;
      }
      return this.strip();
    }, p.prototype.maskn = function(S) {
      return this.clone().imaskn(S);
    }, p.prototype.iaddn = function(S) {
      return l(typeof S == "number"), l(S < 67108864), S < 0 ? this.isubn(-S) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < S ? (this.words[0] = S - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(S), this.negative = 1, this) : this._iaddn(S);
    }, p.prototype._iaddn = function(S) {
      this.words[0] += S;
      for (var E = 0; E < this.length && this.words[E] >= 67108864; E++)
        this.words[E] -= 67108864, E === this.length - 1 ? this.words[E + 1] = 1 : this.words[E + 1]++;
      return this.length = Math.max(this.length, E + 1), this;
    }, p.prototype.isubn = function(S) {
      if (l(typeof S == "number"), l(S < 67108864), S < 0)
        return this.iaddn(-S);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(S), this.negative = 1, this;
      if (this.words[0] -= S, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var E = 0; E < this.length && this.words[E] < 0; E++)
          this.words[E] += 67108864, this.words[E + 1] -= 1;
      return this.strip();
    }, p.prototype.addn = function(S) {
      return this.clone().iaddn(S);
    }, p.prototype.subn = function(S) {
      return this.clone().isubn(S);
    }, p.prototype.iabs = function() {
      return this.negative = 0, this;
    }, p.prototype.abs = function() {
      return this.clone().iabs();
    }, p.prototype._ishlnsubmul = function(S, E, I) {
      var M = S.length + I, $;
      this._expand(M);
      var U, Y = 0;
      for ($ = 0; $ < S.length; $++) {
        U = (this.words[$ + I] | 0) + Y;
        var L = (S.words[$] | 0) * E;
        U -= L & 67108863, Y = (U >> 26) - (L / 67108864 | 0), this.words[$ + I] = U & 67108863;
      }
      for (; $ < this.length - I; $++)
        U = (this.words[$ + I] | 0) + Y, Y = U >> 26, this.words[$ + I] = U & 67108863;
      if (Y === 0)
        return this.strip();
      for (l(Y === -1), Y = 0, $ = 0; $ < this.length; $++)
        U = -(this.words[$] | 0) + Y, Y = U >> 26, this.words[$] = U & 67108863;
      return this.negative = 1, this.strip();
    }, p.prototype._wordDiv = function(S, E) {
      var I = this.length - S.length, M = this.clone(), $ = S, U = $.words[$.length - 1] | 0, Y = this._countBits(U);
      I = 26 - Y, I !== 0 && ($ = $.ushln(I), M.iushln(I), U = $.words[$.length - 1] | 0);
      var L = M.length - $.length, T;
      if (E !== "mod") {
        T = new p(null), T.length = L + 1, T.words = new Array(T.length);
        for (var B = 0; B < T.length; B++)
          T.words[B] = 0;
      }
      var te = M.clone()._ishlnsubmul($, 1, L);
      te.negative === 0 && (M = te, T && (T.words[L] = 1));
      for (var pe = L - 1; pe >= 0; pe--) {
        var Ie = (M.words[$.length + pe] | 0) * 67108864 + (M.words[$.length + pe - 1] | 0);
        for (Ie = Math.min(Ie / U | 0, 67108863), M._ishlnsubmul($, Ie, pe); M.negative !== 0; )
          Ie--, M.negative = 0, M._ishlnsubmul($, 1, pe), M.isZero() || (M.negative ^= 1);
        T && (T.words[pe] = Ie);
      }
      return T && T.strip(), M.strip(), E !== "div" && I !== 0 && M.iushrn(I), {
        div: T || null,
        mod: M
      };
    }, p.prototype.divmod = function(S, E, I) {
      if (l(!S.isZero()), this.isZero())
        return {
          div: new p(0),
          mod: new p(0)
        };
      var M, $, U;
      return this.negative !== 0 && S.negative === 0 ? (U = this.neg().divmod(S, E), E !== "mod" && (M = U.div.neg()), E !== "div" && ($ = U.mod.neg(), I && $.negative !== 0 && $.iadd(S)), {
        div: M,
        mod: $
      }) : this.negative === 0 && S.negative !== 0 ? (U = this.divmod(S.neg(), E), E !== "mod" && (M = U.div.neg()), {
        div: M,
        mod: U.mod
      }) : this.negative & S.negative ? (U = this.neg().divmod(S.neg(), E), E !== "div" && ($ = U.mod.neg(), I && $.negative !== 0 && $.isub(S)), {
        div: U.div,
        mod: $
      }) : S.length > this.length || this.cmp(S) < 0 ? {
        div: new p(0),
        mod: this
      } : S.length === 1 ? E === "div" ? {
        div: this.divn(S.words[0]),
        mod: null
      } : E === "mod" ? {
        div: null,
        mod: new p(this.modn(S.words[0]))
      } : {
        div: this.divn(S.words[0]),
        mod: new p(this.modn(S.words[0]))
      } : this._wordDiv(S, E);
    }, p.prototype.div = function(S) {
      return this.divmod(S, "div", !1).div;
    }, p.prototype.mod = function(S) {
      return this.divmod(S, "mod", !1).mod;
    }, p.prototype.umod = function(S) {
      return this.divmod(S, "mod", !0).mod;
    }, p.prototype.divRound = function(S) {
      var E = this.divmod(S);
      if (E.mod.isZero())
        return E.div;
      var I = E.div.negative !== 0 ? E.mod.isub(S) : E.mod, M = S.ushrn(1), $ = S.andln(1), U = I.cmp(M);
      return U < 0 || $ === 1 && U === 0 ? E.div : E.div.negative !== 0 ? E.div.isubn(1) : E.div.iaddn(1);
    }, p.prototype.modn = function(S) {
      l(S <= 67108863);
      for (var E = (1 << 26) % S, I = 0, M = this.length - 1; M >= 0; M--)
        I = (E * I + (this.words[M] | 0)) % S;
      return I;
    }, p.prototype.idivn = function(S) {
      l(S <= 67108863);
      for (var E = 0, I = this.length - 1; I >= 0; I--) {
        var M = (this.words[I] | 0) + E * 67108864;
        this.words[I] = M / S | 0, E = M % S;
      }
      return this.strip();
    }, p.prototype.divn = function(S) {
      return this.clone().idivn(S);
    }, p.prototype.egcd = function(S) {
      l(S.negative === 0), l(!S.isZero());
      var E = this, I = S.clone();
      E.negative !== 0 ? E = E.umod(S) : E = E.clone();
      for (var M = new p(1), $ = new p(0), U = new p(0), Y = new p(1), L = 0; E.isEven() && I.isEven(); )
        E.iushrn(1), I.iushrn(1), ++L;
      for (var T = I.clone(), B = E.clone(); !E.isZero(); ) {
        for (var te = 0, pe = 1; !(E.words[0] & pe) && te < 26; ++te, pe <<= 1)
          ;
        if (te > 0)
          for (E.iushrn(te); te-- > 0; )
            (M.isOdd() || $.isOdd()) && (M.iadd(T), $.isub(B)), M.iushrn(1), $.iushrn(1);
        for (var Ie = 0, $e = 1; !(I.words[0] & $e) && Ie < 26; ++Ie, $e <<= 1)
          ;
        if (Ie > 0)
          for (I.iushrn(Ie); Ie-- > 0; )
            (U.isOdd() || Y.isOdd()) && (U.iadd(T), Y.isub(B)), U.iushrn(1), Y.iushrn(1);
        E.cmp(I) >= 0 ? (E.isub(I), M.isub(U), $.isub(Y)) : (I.isub(E), U.isub(M), Y.isub($));
      }
      return {
        a: U,
        b: Y,
        gcd: I.iushln(L)
      };
    }, p.prototype._invmp = function(S) {
      l(S.negative === 0), l(!S.isZero());
      var E = this, I = S.clone();
      E.negative !== 0 ? E = E.umod(S) : E = E.clone();
      for (var M = new p(1), $ = new p(0), U = I.clone(); E.cmpn(1) > 0 && I.cmpn(1) > 0; ) {
        for (var Y = 0, L = 1; !(E.words[0] & L) && Y < 26; ++Y, L <<= 1)
          ;
        if (Y > 0)
          for (E.iushrn(Y); Y-- > 0; )
            M.isOdd() && M.iadd(U), M.iushrn(1);
        for (var T = 0, B = 1; !(I.words[0] & B) && T < 26; ++T, B <<= 1)
          ;
        if (T > 0)
          for (I.iushrn(T); T-- > 0; )
            $.isOdd() && $.iadd(U), $.iushrn(1);
        E.cmp(I) >= 0 ? (E.isub(I), M.isub($)) : (I.isub(E), $.isub(M));
      }
      var te;
      return E.cmpn(1) === 0 ? te = M : te = $, te.cmpn(0) < 0 && te.iadd(S), te;
    }, p.prototype.gcd = function(S) {
      if (this.isZero())
        return S.abs();
      if (S.isZero())
        return this.abs();
      var E = this.clone(), I = S.clone();
      E.negative = 0, I.negative = 0;
      for (var M = 0; E.isEven() && I.isEven(); M++)
        E.iushrn(1), I.iushrn(1);
      do {
        for (; E.isEven(); )
          E.iushrn(1);
        for (; I.isEven(); )
          I.iushrn(1);
        var $ = E.cmp(I);
        if ($ < 0) {
          var U = E;
          E = I, I = U;
        } else if ($ === 0 || I.cmpn(1) === 0)
          break;
        E.isub(I);
      } while (!0);
      return I.iushln(M);
    }, p.prototype.invm = function(S) {
      return this.egcd(S).a.umod(S);
    }, p.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, p.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, p.prototype.andln = function(S) {
      return this.words[0] & S;
    }, p.prototype.bincn = function(S) {
      l(typeof S == "number");
      var E = S % 26, I = (S - E) / 26, M = 1 << E;
      if (this.length <= I)
        return this._expand(I + 1), this.words[I] |= M, this;
      for (var $ = M, U = I; $ !== 0 && U < this.length; U++) {
        var Y = this.words[U] | 0;
        Y += $, $ = Y >>> 26, Y &= 67108863, this.words[U] = Y;
      }
      return $ !== 0 && (this.words[U] = $, this.length++), this;
    }, p.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, p.prototype.cmpn = function(S) {
      var E = S < 0;
      if (this.negative !== 0 && !E)
        return -1;
      if (this.negative === 0 && E)
        return 1;
      this.strip();
      var I;
      if (this.length > 1)
        I = 1;
      else {
        E && (S = -S), l(S <= 67108863, "Number is too big");
        var M = this.words[0] | 0;
        I = M === S ? 0 : M < S ? -1 : 1;
      }
      return this.negative !== 0 ? -I | 0 : I;
    }, p.prototype.cmp = function(S) {
      if (this.negative !== 0 && S.negative === 0)
        return -1;
      if (this.negative === 0 && S.negative !== 0)
        return 1;
      var E = this.ucmp(S);
      return this.negative !== 0 ? -E | 0 : E;
    }, p.prototype.ucmp = function(S) {
      if (this.length > S.length)
        return 1;
      if (this.length < S.length)
        return -1;
      for (var E = 0, I = this.length - 1; I >= 0; I--) {
        var M = this.words[I] | 0, $ = S.words[I] | 0;
        if (M !== $) {
          M < $ ? E = -1 : M > $ && (E = 1);
          break;
        }
      }
      return E;
    }, p.prototype.gtn = function(S) {
      return this.cmpn(S) === 1;
    }, p.prototype.gt = function(S) {
      return this.cmp(S) === 1;
    }, p.prototype.gten = function(S) {
      return this.cmpn(S) >= 0;
    }, p.prototype.gte = function(S) {
      return this.cmp(S) >= 0;
    }, p.prototype.ltn = function(S) {
      return this.cmpn(S) === -1;
    }, p.prototype.lt = function(S) {
      return this.cmp(S) === -1;
    }, p.prototype.lten = function(S) {
      return this.cmpn(S) <= 0;
    }, p.prototype.lte = function(S) {
      return this.cmp(S) <= 0;
    }, p.prototype.eqn = function(S) {
      return this.cmpn(S) === 0;
    }, p.prototype.eq = function(S) {
      return this.cmp(S) === 0;
    }, p.red = function(S) {
      return new q(S);
    }, p.prototype.toRed = function(S) {
      return l(!this.red, "Already a number in reduction context"), l(this.negative === 0, "red works only with positives"), S.convertTo(this)._forceRed(S);
    }, p.prototype.fromRed = function() {
      return l(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, p.prototype._forceRed = function(S) {
      return this.red = S, this;
    }, p.prototype.forceRed = function(S) {
      return l(!this.red, "Already a number in reduction context"), this._forceRed(S);
    }, p.prototype.redAdd = function(S) {
      return l(this.red, "redAdd works only with red numbers"), this.red.add(this, S);
    }, p.prototype.redIAdd = function(S) {
      return l(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, S);
    }, p.prototype.redSub = function(S) {
      return l(this.red, "redSub works only with red numbers"), this.red.sub(this, S);
    }, p.prototype.redISub = function(S) {
      return l(this.red, "redISub works only with red numbers"), this.red.isub(this, S);
    }, p.prototype.redShl = function(S) {
      return l(this.red, "redShl works only with red numbers"), this.red.shl(this, S);
    }, p.prototype.redMul = function(S) {
      return l(this.red, "redMul works only with red numbers"), this.red._verify2(this, S), this.red.mul(this, S);
    }, p.prototype.redIMul = function(S) {
      return l(this.red, "redMul works only with red numbers"), this.red._verify2(this, S), this.red.imul(this, S);
    }, p.prototype.redSqr = function() {
      return l(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, p.prototype.redISqr = function() {
      return l(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, p.prototype.redSqrt = function() {
      return l(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, p.prototype.redInvm = function() {
      return l(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, p.prototype.redNeg = function() {
      return l(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, p.prototype.redPow = function(S) {
      return l(this.red && !S.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, S);
    };
    var de = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function fe(C, S) {
      this.name = C, this.p = new p(S, 16), this.n = this.p.bitLength(), this.k = new p(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    fe.prototype._tmp = function() {
      var S = new p(null);
      return S.words = new Array(Math.ceil(this.n / 13)), S;
    }, fe.prototype.ireduce = function(S) {
      var E = S, I;
      do
        this.split(E, this.tmp), E = this.imulK(E), E = E.iadd(this.tmp), I = E.bitLength();
      while (I > this.n);
      var M = I < this.n ? -1 : E.ucmp(this.p);
      return M === 0 ? (E.words[0] = 0, E.length = 1) : M > 0 ? E.isub(this.p) : E.strip !== void 0 ? E.strip() : E._strip(), E;
    }, fe.prototype.split = function(S, E) {
      S.iushrn(this.n, 0, E);
    }, fe.prototype.imulK = function(S) {
      return S.imul(this.k);
    };
    function Te() {
      fe.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    v(Te, fe), Te.prototype.split = function(S, E) {
      for (var I = 4194303, M = Math.min(S.length, 9), $ = 0; $ < M; $++)
        E.words[$] = S.words[$];
      if (E.length = M, S.length <= 9) {
        S.words[0] = 0, S.length = 1;
        return;
      }
      var U = S.words[9];
      for (E.words[E.length++] = U & I, $ = 10; $ < S.length; $++) {
        var Y = S.words[$] | 0;
        S.words[$ - 10] = (Y & I) << 4 | U >>> 22, U = Y;
      }
      U >>>= 22, S.words[$ - 10] = U, U === 0 && S.length > 10 ? S.length -= 10 : S.length -= 9;
    }, Te.prototype.imulK = function(S) {
      S.words[S.length] = 0, S.words[S.length + 1] = 0, S.length += 2;
      for (var E = 0, I = 0; I < S.length; I++) {
        var M = S.words[I] | 0;
        E += M * 977, S.words[I] = E & 67108863, E = M * 64 + (E / 67108864 | 0);
      }
      return S.words[S.length - 1] === 0 && (S.length--, S.words[S.length - 1] === 0 && S.length--), S;
    };
    function Re() {
      fe.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    v(Re, fe);
    function Le() {
      fe.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    v(Le, fe);
    function be() {
      fe.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    v(be, fe), be.prototype.imulK = function(S) {
      for (var E = 0, I = 0; I < S.length; I++) {
        var M = (S.words[I] | 0) * 19 + E, $ = M & 67108863;
        M >>>= 26, S.words[I] = $, E = M;
      }
      return E !== 0 && (S.words[S.length++] = E), S;
    }, p._prime = function(S) {
      if (de[S])
        return de[S];
      var E;
      if (S === "k256")
        E = new Te();
      else if (S === "p224")
        E = new Re();
      else if (S === "p192")
        E = new Le();
      else if (S === "p25519")
        E = new be();
      else
        throw new Error("Unknown prime " + S);
      return de[S] = E, E;
    };
    function q(C) {
      if (typeof C == "string") {
        var S = p._prime(C);
        this.m = S.p, this.prime = S;
      } else
        l(C.gtn(1), "modulus must be greater than 1"), this.m = C, this.prime = null;
    }
    q.prototype._verify1 = function(S) {
      l(S.negative === 0, "red works only with positives"), l(S.red, "red works only with red numbers");
    }, q.prototype._verify2 = function(S, E) {
      l((S.negative | E.negative) === 0, "red works only with positives"), l(
        S.red && S.red === E.red,
        "red works only with red numbers"
      );
    }, q.prototype.imod = function(S) {
      return this.prime ? this.prime.ireduce(S)._forceRed(this) : S.umod(this.m)._forceRed(this);
    }, q.prototype.neg = function(S) {
      return S.isZero() ? S.clone() : this.m.sub(S)._forceRed(this);
    }, q.prototype.add = function(S, E) {
      this._verify2(S, E);
      var I = S.add(E);
      return I.cmp(this.m) >= 0 && I.isub(this.m), I._forceRed(this);
    }, q.prototype.iadd = function(S, E) {
      this._verify2(S, E);
      var I = S.iadd(E);
      return I.cmp(this.m) >= 0 && I.isub(this.m), I;
    }, q.prototype.sub = function(S, E) {
      this._verify2(S, E);
      var I = S.sub(E);
      return I.cmpn(0) < 0 && I.iadd(this.m), I._forceRed(this);
    }, q.prototype.isub = function(S, E) {
      this._verify2(S, E);
      var I = S.isub(E);
      return I.cmpn(0) < 0 && I.iadd(this.m), I;
    }, q.prototype.shl = function(S, E) {
      return this._verify1(S), this.imod(S.ushln(E));
    }, q.prototype.imul = function(S, E) {
      return this._verify2(S, E), this.imod(S.imul(E));
    }, q.prototype.mul = function(S, E) {
      return this._verify2(S, E), this.imod(S.mul(E));
    }, q.prototype.isqr = function(S) {
      return this.imul(S, S.clone());
    }, q.prototype.sqr = function(S) {
      return this.mul(S, S);
    }, q.prototype.sqrt = function(S) {
      if (S.isZero())
        return S.clone();
      var E = this.m.andln(3);
      if (l(E % 2 === 1), E === 3) {
        var I = this.m.add(new p(1)).iushrn(2);
        return this.pow(S, I);
      }
      for (var M = this.m.subn(1), $ = 0; !M.isZero() && M.andln(1) === 0; )
        $++, M.iushrn(1);
      l(!M.isZero());
      var U = new p(1).toRed(this), Y = U.redNeg(), L = this.m.subn(1).iushrn(1), T = this.m.bitLength();
      for (T = new p(2 * T * T).toRed(this); this.pow(T, L).cmp(Y) !== 0; )
        T.redIAdd(Y);
      for (var B = this.pow(T, M), te = this.pow(S, M.addn(1).iushrn(1)), pe = this.pow(S, M), Ie = $; pe.cmp(U) !== 0; ) {
        for (var $e = pe, ve = 0; $e.cmp(U) !== 0; ve++)
          $e = $e.redSqr();
        l(ve < Ie);
        var he = this.pow(B, new p(1).iushln(Ie - ve - 1));
        te = te.redMul(he), B = he.redSqr(), pe = pe.redMul(B), Ie = ve;
      }
      return te;
    }, q.prototype.invm = function(S) {
      var E = S._invmp(this.m);
      return E.negative !== 0 ? (E.negative = 0, this.imod(E).redNeg()) : this.imod(E);
    }, q.prototype.pow = function(S, E) {
      if (E.isZero())
        return new p(1).toRed(this);
      if (E.cmpn(1) === 0)
        return S.clone();
      var I = 4, M = new Array(1 << I);
      M[0] = new p(1).toRed(this), M[1] = S;
      for (var $ = 2; $ < M.length; $++)
        M[$] = this.mul(M[$ - 1], S);
      var U = M[0], Y = 0, L = 0, T = E.bitLength() % 26;
      for (T === 0 && (T = 26), $ = E.length - 1; $ >= 0; $--) {
        for (var B = E.words[$], te = T - 1; te >= 0; te--) {
          var pe = B >> te & 1;
          if (U !== M[0] && (U = this.sqr(U)), pe === 0 && Y === 0) {
            L = 0;
            continue;
          }
          Y <<= 1, Y |= pe, L++, !(L !== I && ($ !== 0 || te !== 0)) && (U = this.mul(U, M[Y]), L = 0, Y = 0);
        }
        T = 26;
      }
      return U;
    }, q.prototype.convertTo = function(S) {
      var E = S.umod(this.m);
      return E === S ? E.clone() : E;
    }, q.prototype.convertFrom = function(S) {
      var E = S.clone();
      return E.red = null, E;
    }, p.mont = function(S) {
      return new J(S);
    };
    function J(C) {
      q.call(this, C), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new p(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    v(J, q), J.prototype.convertTo = function(S) {
      return this.imod(S.ushln(this.shift));
    }, J.prototype.convertFrom = function(S) {
      var E = this.imod(S.mul(this.rinv));
      return E.red = null, E;
    }, J.prototype.imul = function(S, E) {
      if (S.isZero() || E.isZero())
        return S.words[0] = 0, S.length = 1, S;
      var I = S.imul(E), M = I.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), $ = I.isub(M).iushrn(this.shift), U = $;
      return $.cmp(this.m) >= 0 ? U = $.isub(this.m) : $.cmpn(0) < 0 && (U = $.iadd(this.m)), U._forceRed(this);
    }, J.prototype.mul = function(S, E) {
      if (S.isZero() || E.isZero())
        return new p(0)._forceRed(this);
      var I = S.mul(E), M = I.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), $ = I.isub(M).iushrn(this.shift), U = $;
      return $.cmp(this.m) >= 0 ? U = $.isub(this.m) : $.cmpn(0) < 0 && (U = $.iadd(this.m)), U._forceRed(this);
    }, J.prototype.invm = function(S) {
      var E = this.imod(S._invmp(this.m).mul(this.r2));
      return E._forceRed(this);
    };
  })(a, commonjsGlobal$1);
})(bn$1);
var bnExports$1 = bn$1.exports, browser$3, hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser)
    return browser$3;
  hasRequiredBrowser = 1;
  var a = requireElliptic(), u = bnExports$1;
  browser$3 = function(_) {
    return new l(_);
  };
  var c = {
    secp256k1: {
      name: "secp256k1",
      byteLength: 32
    },
    secp224r1: {
      name: "p224",
      byteLength: 28
    },
    prime256v1: {
      name: "p256",
      byteLength: 32
    },
    prime192v1: {
      name: "p192",
      byteLength: 24
    },
    ed25519: {
      name: "ed25519",
      byteLength: 32
    },
    secp384r1: {
      name: "p384",
      byteLength: 48
    },
    secp521r1: {
      name: "p521",
      byteLength: 66
    }
  };
  c.p224 = c.secp224r1, c.p256 = c.secp256r1 = c.prime256v1, c.p192 = c.secp192r1 = c.prime192v1, c.p384 = c.secp384r1, c.p521 = c.secp521r1;
  function l(p) {
    this.curveType = c[p], this.curveType || (this.curveType = {
      name: p
    }), this.curve = new a.ec(this.curveType.name), this.keys = void 0;
  }
  l.prototype.generateKeys = function(p, _) {
    return this.keys = this.curve.genKeyPair(), this.getPublicKey(p, _);
  }, l.prototype.computeSecret = function(p, _, k) {
    _ = _ || "utf8", Buffer$O.isBuffer(p) || (p = new Buffer$O(p, _));
    var O = this.curve.keyFromPublic(p).getPublic(), D = O.mul(this.keys.getPrivate()).getX();
    return v(D, k, this.curveType.byteLength);
  }, l.prototype.getPublicKey = function(p, _) {
    var k = this.keys.getPublic(_ === "compressed", !0);
    return _ === "hybrid" && (k[k.length - 1] % 2 ? k[0] = 7 : k[0] = 6), v(k, p);
  }, l.prototype.getPrivateKey = function(p) {
    return v(this.keys.getPrivate(), p);
  }, l.prototype.setPublicKey = function(p, _) {
    return _ = _ || "utf8", Buffer$O.isBuffer(p) || (p = new Buffer$O(p, _)), this.keys._importPublic(p), this;
  }, l.prototype.setPrivateKey = function(p, _) {
    _ = _ || "utf8", Buffer$O.isBuffer(p) || (p = new Buffer$O(p, _));
    var k = new u(p);
    return k = k.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(k), this;
  };
  function v(p, _, k) {
    Array.isArray(p) || (p = p.toArray());
    var O = new Buffer$O(p);
    if (k && O.length < k) {
      var D = new Buffer$O(k - O.length);
      D.fill(0), O = Buffer$O.concat([D, O]);
    }
    return _ ? O.toString(_) : O;
  }
  return browser$3;
}
var browser$2 = {}, createHash$2 = browser$a, Buffer$9 = safeBufferExports$3.Buffer, mgf$2 = function(a, u) {
  for (var c = Buffer$9.alloc(0), l = 0, v; c.length < u; )
    v = i2ops(l++), c = Buffer$9.concat([c, createHash$2("sha1").update(a).update(v).digest()]);
  return c.slice(0, u);
};
function i2ops(a) {
  var u = Buffer$9.allocUnsafe(4);
  return u.writeUInt32BE(a, 0), u;
}
var xor$2 = function a(u, c) {
  for (var l = u.length, v = -1; ++v < l; )
    u[v] ^= c[v];
  return u;
}, bn = { exports: {} };
bn.exports;
(function(a) {
  (function(u, c) {
    function l(C, S) {
      if (!C)
        throw new Error(S || "Assertion failed");
    }
    function v(C, S) {
      C.super_ = S;
      var E = function() {
      };
      E.prototype = S.prototype, C.prototype = new E(), C.prototype.constructor = C;
    }
    function p(C, S, E) {
      if (p.isBN(C))
        return C;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, C !== null && ((S === "le" || S === "be") && (E = S, S = 10), this._init(C || 0, S || 10, E || "be"));
    }
    typeof u == "object" ? u.exports = p : c.BN = p, p.BN = p, p.wordSize = 26;
    var _;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? _ = window.Buffer : _ = require$$0$2.Buffer;
    } catch {
    }
    p.isBN = function(S) {
      return S instanceof p ? !0 : S !== null && typeof S == "object" && S.constructor.wordSize === p.wordSize && Array.isArray(S.words);
    }, p.max = function(S, E) {
      return S.cmp(E) > 0 ? S : E;
    }, p.min = function(S, E) {
      return S.cmp(E) < 0 ? S : E;
    }, p.prototype._init = function(S, E, I) {
      if (typeof S == "number")
        return this._initNumber(S, E, I);
      if (typeof S == "object")
        return this._initArray(S, E, I);
      E === "hex" && (E = 16), l(E === (E | 0) && E >= 2 && E <= 36), S = S.toString().replace(/\s+/g, "");
      var M = 0;
      S[0] === "-" && (M++, this.negative = 1), M < S.length && (E === 16 ? this._parseHex(S, M, I) : (this._parseBase(S, E, M), I === "le" && this._initArray(this.toArray(), E, I)));
    }, p.prototype._initNumber = function(S, E, I) {
      S < 0 && (this.negative = 1, S = -S), S < 67108864 ? (this.words = [S & 67108863], this.length = 1) : S < 4503599627370496 ? (this.words = [
        S & 67108863,
        S / 67108864 & 67108863
      ], this.length = 2) : (l(S < 9007199254740992), this.words = [
        S & 67108863,
        S / 67108864 & 67108863,
        1
      ], this.length = 3), I === "le" && this._initArray(this.toArray(), E, I);
    }, p.prototype._initArray = function(S, E, I) {
      if (l(typeof S.length == "number"), S.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(S.length / 3), this.words = new Array(this.length);
      for (var M = 0; M < this.length; M++)
        this.words[M] = 0;
      var $, U, Y = 0;
      if (I === "be")
        for (M = S.length - 1, $ = 0; M >= 0; M -= 3)
          U = S[M] | S[M - 1] << 8 | S[M - 2] << 16, this.words[$] |= U << Y & 67108863, this.words[$ + 1] = U >>> 26 - Y & 67108863, Y += 24, Y >= 26 && (Y -= 26, $++);
      else if (I === "le")
        for (M = 0, $ = 0; M < S.length; M += 3)
          U = S[M] | S[M + 1] << 8 | S[M + 2] << 16, this.words[$] |= U << Y & 67108863, this.words[$ + 1] = U >>> 26 - Y & 67108863, Y += 24, Y >= 26 && (Y -= 26, $++);
      return this.strip();
    };
    function k(C, S) {
      var E = C.charCodeAt(S);
      return E >= 65 && E <= 70 ? E - 55 : E >= 97 && E <= 102 ? E - 87 : E - 48 & 15;
    }
    function O(C, S, E) {
      var I = k(C, E);
      return E - 1 >= S && (I |= k(C, E - 1) << 4), I;
    }
    p.prototype._parseHex = function(S, E, I) {
      this.length = Math.ceil((S.length - E) / 6), this.words = new Array(this.length);
      for (var M = 0; M < this.length; M++)
        this.words[M] = 0;
      var $ = 0, U = 0, Y;
      if (I === "be")
        for (M = S.length - 1; M >= E; M -= 2)
          Y = O(S, E, M) << $, this.words[U] |= Y & 67108863, $ >= 18 ? ($ -= 18, U += 1, this.words[U] |= Y >>> 26) : $ += 8;
      else {
        var L = S.length - E;
        for (M = L % 2 === 0 ? E + 1 : E; M < S.length; M += 2)
          Y = O(S, E, M) << $, this.words[U] |= Y & 67108863, $ >= 18 ? ($ -= 18, U += 1, this.words[U] |= Y >>> 26) : $ += 8;
      }
      this.strip();
    };
    function D(C, S, E, I) {
      for (var M = 0, $ = Math.min(C.length, E), U = S; U < $; U++) {
        var Y = C.charCodeAt(U) - 48;
        M *= I, Y >= 49 ? M += Y - 49 + 10 : Y >= 17 ? M += Y - 17 + 10 : M += Y;
      }
      return M;
    }
    p.prototype._parseBase = function(S, E, I) {
      this.words = [0], this.length = 1;
      for (var M = 0, $ = 1; $ <= 67108863; $ *= E)
        M++;
      M--, $ = $ / E | 0;
      for (var U = S.length - I, Y = U % M, L = Math.min(U, U - Y) + I, T = 0, B = I; B < L; B += M)
        T = D(S, B, B + M, E), this.imuln($), this.words[0] + T < 67108864 ? this.words[0] += T : this._iaddn(T);
      if (Y !== 0) {
        var te = 1;
        for (T = D(S, B, S.length, E), B = 0; B < Y; B++)
          te *= E;
        this.imuln(te), this.words[0] + T < 67108864 ? this.words[0] += T : this._iaddn(T);
      }
      this.strip();
    }, p.prototype.copy = function(S) {
      S.words = new Array(this.length);
      for (var E = 0; E < this.length; E++)
        S.words[E] = this.words[E];
      S.length = this.length, S.negative = this.negative, S.red = this.red;
    }, p.prototype.clone = function() {
      var S = new p(null);
      return this.copy(S), S;
    }, p.prototype._expand = function(S) {
      for (; this.length < S; )
        this.words[this.length++] = 0;
      return this;
    }, p.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, p.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, p.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var F = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], z = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], j = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    p.prototype.toString = function(S, E) {
      S = S || 10, E = E | 0 || 1;
      var I;
      if (S === 16 || S === "hex") {
        I = "";
        for (var M = 0, $ = 0, U = 0; U < this.length; U++) {
          var Y = this.words[U], L = ((Y << M | $) & 16777215).toString(16);
          $ = Y >>> 24 - M & 16777215, $ !== 0 || U !== this.length - 1 ? I = F[6 - L.length] + L + I : I = L + I, M += 2, M >= 26 && (M -= 26, U--);
        }
        for ($ !== 0 && (I = $.toString(16) + I); I.length % E !== 0; )
          I = "0" + I;
        return this.negative !== 0 && (I = "-" + I), I;
      }
      if (S === (S | 0) && S >= 2 && S <= 36) {
        var T = z[S], B = j[S];
        I = "";
        var te = this.clone();
        for (te.negative = 0; !te.isZero(); ) {
          var pe = te.modn(B).toString(S);
          te = te.idivn(B), te.isZero() ? I = pe + I : I = F[T - pe.length] + pe + I;
        }
        for (this.isZero() && (I = "0" + I); I.length % E !== 0; )
          I = "0" + I;
        return this.negative !== 0 && (I = "-" + I), I;
      }
      l(!1, "Base should be between 2 and 36");
    }, p.prototype.toNumber = function() {
      var S = this.words[0];
      return this.length === 2 ? S += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? S += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && l(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -S : S;
    }, p.prototype.toJSON = function() {
      return this.toString(16);
    }, p.prototype.toBuffer = function(S, E) {
      return l(typeof _ < "u"), this.toArrayLike(_, S, E);
    }, p.prototype.toArray = function(S, E) {
      return this.toArrayLike(Array, S, E);
    }, p.prototype.toArrayLike = function(S, E, I) {
      var M = this.byteLength(), $ = I || Math.max(1, M);
      l(M <= $, "byte array longer than desired length"), l($ > 0, "Requested array length <= 0"), this.strip();
      var U = E === "le", Y = new S($), L, T, B = this.clone();
      if (U) {
        for (T = 0; !B.isZero(); T++)
          L = B.andln(255), B.iushrn(8), Y[T] = L;
        for (; T < $; T++)
          Y[T] = 0;
      } else {
        for (T = 0; T < $ - M; T++)
          Y[T] = 0;
        for (T = 0; !B.isZero(); T++)
          L = B.andln(255), B.iushrn(8), Y[$ - T - 1] = L;
      }
      return Y;
    }, Math.clz32 ? p.prototype._countBits = function(S) {
      return 32 - Math.clz32(S);
    } : p.prototype._countBits = function(S) {
      var E = S, I = 0;
      return E >= 4096 && (I += 13, E >>>= 13), E >= 64 && (I += 7, E >>>= 7), E >= 8 && (I += 4, E >>>= 4), E >= 2 && (I += 2, E >>>= 2), I + E;
    }, p.prototype._zeroBits = function(S) {
      if (S === 0)
        return 26;
      var E = S, I = 0;
      return E & 8191 || (I += 13, E >>>= 13), E & 127 || (I += 7, E >>>= 7), E & 15 || (I += 4, E >>>= 4), E & 3 || (I += 2, E >>>= 2), E & 1 || I++, I;
    }, p.prototype.bitLength = function() {
      var S = this.words[this.length - 1], E = this._countBits(S);
      return (this.length - 1) * 26 + E;
    };
    function ee(C) {
      for (var S = new Array(C.bitLength()), E = 0; E < S.length; E++) {
        var I = E / 26 | 0, M = E % 26;
        S[E] = (C.words[I] & 1 << M) >>> M;
      }
      return S;
    }
    p.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var S = 0, E = 0; E < this.length; E++) {
        var I = this._zeroBits(this.words[E]);
        if (S += I, I !== 26)
          break;
      }
      return S;
    }, p.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, p.prototype.toTwos = function(S) {
      return this.negative !== 0 ? this.abs().inotn(S).iaddn(1) : this.clone();
    }, p.prototype.fromTwos = function(S) {
      return this.testn(S - 1) ? this.notn(S).iaddn(1).ineg() : this.clone();
    }, p.prototype.isNeg = function() {
      return this.negative !== 0;
    }, p.prototype.neg = function() {
      return this.clone().ineg();
    }, p.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, p.prototype.iuor = function(S) {
      for (; this.length < S.length; )
        this.words[this.length++] = 0;
      for (var E = 0; E < S.length; E++)
        this.words[E] = this.words[E] | S.words[E];
      return this.strip();
    }, p.prototype.ior = function(S) {
      return l((this.negative | S.negative) === 0), this.iuor(S);
    }, p.prototype.or = function(S) {
      return this.length > S.length ? this.clone().ior(S) : S.clone().ior(this);
    }, p.prototype.uor = function(S) {
      return this.length > S.length ? this.clone().iuor(S) : S.clone().iuor(this);
    }, p.prototype.iuand = function(S) {
      var E;
      this.length > S.length ? E = S : E = this;
      for (var I = 0; I < E.length; I++)
        this.words[I] = this.words[I] & S.words[I];
      return this.length = E.length, this.strip();
    }, p.prototype.iand = function(S) {
      return l((this.negative | S.negative) === 0), this.iuand(S);
    }, p.prototype.and = function(S) {
      return this.length > S.length ? this.clone().iand(S) : S.clone().iand(this);
    }, p.prototype.uand = function(S) {
      return this.length > S.length ? this.clone().iuand(S) : S.clone().iuand(this);
    }, p.prototype.iuxor = function(S) {
      var E, I;
      this.length > S.length ? (E = this, I = S) : (E = S, I = this);
      for (var M = 0; M < I.length; M++)
        this.words[M] = E.words[M] ^ I.words[M];
      if (this !== E)
        for (; M < E.length; M++)
          this.words[M] = E.words[M];
      return this.length = E.length, this.strip();
    }, p.prototype.ixor = function(S) {
      return l((this.negative | S.negative) === 0), this.iuxor(S);
    }, p.prototype.xor = function(S) {
      return this.length > S.length ? this.clone().ixor(S) : S.clone().ixor(this);
    }, p.prototype.uxor = function(S) {
      return this.length > S.length ? this.clone().iuxor(S) : S.clone().iuxor(this);
    }, p.prototype.inotn = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = Math.ceil(S / 26) | 0, I = S % 26;
      this._expand(E), I > 0 && E--;
      for (var M = 0; M < E; M++)
        this.words[M] = ~this.words[M] & 67108863;
      return I > 0 && (this.words[M] = ~this.words[M] & 67108863 >> 26 - I), this.strip();
    }, p.prototype.notn = function(S) {
      return this.clone().inotn(S);
    }, p.prototype.setn = function(S, E) {
      l(typeof S == "number" && S >= 0);
      var I = S / 26 | 0, M = S % 26;
      return this._expand(I + 1), E ? this.words[I] = this.words[I] | 1 << M : this.words[I] = this.words[I] & ~(1 << M), this.strip();
    }, p.prototype.iadd = function(S) {
      var E;
      if (this.negative !== 0 && S.negative === 0)
        return this.negative = 0, E = this.isub(S), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && S.negative !== 0)
        return S.negative = 0, E = this.isub(S), S.negative = 1, E._normSign();
      var I, M;
      this.length > S.length ? (I = this, M = S) : (I = S, M = this);
      for (var $ = 0, U = 0; U < M.length; U++)
        E = (I.words[U] | 0) + (M.words[U] | 0) + $, this.words[U] = E & 67108863, $ = E >>> 26;
      for (; $ !== 0 && U < I.length; U++)
        E = (I.words[U] | 0) + $, this.words[U] = E & 67108863, $ = E >>> 26;
      if (this.length = I.length, $ !== 0)
        this.words[this.length] = $, this.length++;
      else if (I !== this)
        for (; U < I.length; U++)
          this.words[U] = I.words[U];
      return this;
    }, p.prototype.add = function(S) {
      var E;
      return S.negative !== 0 && this.negative === 0 ? (S.negative = 0, E = this.sub(S), S.negative ^= 1, E) : S.negative === 0 && this.negative !== 0 ? (this.negative = 0, E = S.sub(this), this.negative = 1, E) : this.length > S.length ? this.clone().iadd(S) : S.clone().iadd(this);
    }, p.prototype.isub = function(S) {
      if (S.negative !== 0) {
        S.negative = 0;
        var E = this.iadd(S);
        return S.negative = 1, E._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(S), this.negative = 1, this._normSign();
      var I = this.cmp(S);
      if (I === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var M, $;
      I > 0 ? (M = this, $ = S) : (M = S, $ = this);
      for (var U = 0, Y = 0; Y < $.length; Y++)
        E = (M.words[Y] | 0) - ($.words[Y] | 0) + U, U = E >> 26, this.words[Y] = E & 67108863;
      for (; U !== 0 && Y < M.length; Y++)
        E = (M.words[Y] | 0) + U, U = E >> 26, this.words[Y] = E & 67108863;
      if (U === 0 && Y < M.length && M !== this)
        for (; Y < M.length; Y++)
          this.words[Y] = M.words[Y];
      return this.length = Math.max(this.length, Y), M !== this && (this.negative = 1), this.strip();
    }, p.prototype.sub = function(S) {
      return this.clone().isub(S);
    };
    function X(C, S, E) {
      E.negative = S.negative ^ C.negative;
      var I = C.length + S.length | 0;
      E.length = I, I = I - 1 | 0;
      var M = C.words[0] | 0, $ = S.words[0] | 0, U = M * $, Y = U & 67108863, L = U / 67108864 | 0;
      E.words[0] = Y;
      for (var T = 1; T < I; T++) {
        for (var B = L >>> 26, te = L & 67108863, pe = Math.min(T, S.length - 1), Ie = Math.max(0, T - C.length + 1); Ie <= pe; Ie++) {
          var $e = T - Ie | 0;
          M = C.words[$e] | 0, $ = S.words[Ie] | 0, U = M * $ + te, B += U / 67108864 | 0, te = U & 67108863;
        }
        E.words[T] = te | 0, L = B | 0;
      }
      return L !== 0 ? E.words[T] = L | 0 : E.length--, E.strip();
    }
    var ae = function(S, E, I) {
      var M = S.words, $ = E.words, U = I.words, Y = 0, L, T, B, te = M[0] | 0, pe = te & 8191, Ie = te >>> 13, $e = M[1] | 0, ve = $e & 8191, he = $e >>> 13, Oe = M[2] | 0, Ae = Oe & 8191, Ue = Oe >>> 13, oe = M[3] | 0, A = oe & 8191, re = oe >>> 13, le = M[4] | 0, Ne = le & 8191, Pe = le >>> 13, Fe = M[5] | 0, je = Fe & 8191, qe = Fe >>> 13, yt = M[6] | 0, Xe = yt & 8191, Ge = yt >>> 13, H = M[7] | 0, ye = H & 8191, Ee = H >>> 13, We = M[8] | 0, we = We & 8191, V = We >>> 13, _e = M[9] | 0, ue = _e & 8191, ce = _e >>> 13, me = $[0] | 0, Ce = me & 8191, Be = me >>> 13, ze = $[1] | 0, Je = ze & 8191, Ze = ze >>> 13, Ke = $[2] | 0, x = Ke & 8191, se = Ke >>> 13, ge = $[3] | 0, xe = ge & 8191, Me = ge >>> 13, Ye = $[4] | 0, et = Ye & 8191, dt = Ye >>> 13, St = $[5] | 0, tt = St & 8191, at = St >>> 13, kt = $[6] | 0, rt = kt & 8191, ut = kt >>> 13, wt = $[7] | 0, nt = wt & 8191, it = wt >>> 13, bt = $[8] | 0, ot = bt & 8191, ct = bt >>> 13, Pt = $[9] | 0, st = Pt & 8191, lt = Pt >>> 13;
      I.negative = S.negative ^ E.negative, I.length = 19, L = Math.imul(pe, Ce), T = Math.imul(pe, Be), T = T + Math.imul(Ie, Ce) | 0, B = Math.imul(Ie, Be);
      var It = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (It >>> 26) | 0, It &= 67108863, L = Math.imul(ve, Ce), T = Math.imul(ve, Be), T = T + Math.imul(he, Ce) | 0, B = Math.imul(he, Be), L = L + Math.imul(pe, Je) | 0, T = T + Math.imul(pe, Ze) | 0, T = T + Math.imul(Ie, Je) | 0, B = B + Math.imul(Ie, Ze) | 0;
      var Rt = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (Rt >>> 26) | 0, Rt &= 67108863, L = Math.imul(Ae, Ce), T = Math.imul(Ae, Be), T = T + Math.imul(Ue, Ce) | 0, B = Math.imul(Ue, Be), L = L + Math.imul(ve, Je) | 0, T = T + Math.imul(ve, Ze) | 0, T = T + Math.imul(he, Je) | 0, B = B + Math.imul(he, Ze) | 0, L = L + Math.imul(pe, x) | 0, T = T + Math.imul(pe, se) | 0, T = T + Math.imul(Ie, x) | 0, B = B + Math.imul(Ie, se) | 0;
      var Ve = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, L = Math.imul(A, Ce), T = Math.imul(A, Be), T = T + Math.imul(re, Ce) | 0, B = Math.imul(re, Be), L = L + Math.imul(Ae, Je) | 0, T = T + Math.imul(Ae, Ze) | 0, T = T + Math.imul(Ue, Je) | 0, B = B + Math.imul(Ue, Ze) | 0, L = L + Math.imul(ve, x) | 0, T = T + Math.imul(ve, se) | 0, T = T + Math.imul(he, x) | 0, B = B + Math.imul(he, se) | 0, L = L + Math.imul(pe, xe) | 0, T = T + Math.imul(pe, Me) | 0, T = T + Math.imul(Ie, xe) | 0, B = B + Math.imul(Ie, Me) | 0;
      var He = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, L = Math.imul(Ne, Ce), T = Math.imul(Ne, Be), T = T + Math.imul(Pe, Ce) | 0, B = Math.imul(Pe, Be), L = L + Math.imul(A, Je) | 0, T = T + Math.imul(A, Ze) | 0, T = T + Math.imul(re, Je) | 0, B = B + Math.imul(re, Ze) | 0, L = L + Math.imul(Ae, x) | 0, T = T + Math.imul(Ae, se) | 0, T = T + Math.imul(Ue, x) | 0, B = B + Math.imul(Ue, se) | 0, L = L + Math.imul(ve, xe) | 0, T = T + Math.imul(ve, Me) | 0, T = T + Math.imul(he, xe) | 0, B = B + Math.imul(he, Me) | 0, L = L + Math.imul(pe, et) | 0, T = T + Math.imul(pe, dt) | 0, T = T + Math.imul(Ie, et) | 0, B = B + Math.imul(Ie, dt) | 0;
      var Qe = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, L = Math.imul(je, Ce), T = Math.imul(je, Be), T = T + Math.imul(qe, Ce) | 0, B = Math.imul(qe, Be), L = L + Math.imul(Ne, Je) | 0, T = T + Math.imul(Ne, Ze) | 0, T = T + Math.imul(Pe, Je) | 0, B = B + Math.imul(Pe, Ze) | 0, L = L + Math.imul(A, x) | 0, T = T + Math.imul(A, se) | 0, T = T + Math.imul(re, x) | 0, B = B + Math.imul(re, se) | 0, L = L + Math.imul(Ae, xe) | 0, T = T + Math.imul(Ae, Me) | 0, T = T + Math.imul(Ue, xe) | 0, B = B + Math.imul(Ue, Me) | 0, L = L + Math.imul(ve, et) | 0, T = T + Math.imul(ve, dt) | 0, T = T + Math.imul(he, et) | 0, B = B + Math.imul(he, dt) | 0, L = L + Math.imul(pe, tt) | 0, T = T + Math.imul(pe, at) | 0, T = T + Math.imul(Ie, tt) | 0, B = B + Math.imul(Ie, at) | 0;
      var pt = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (pt >>> 26) | 0, pt &= 67108863, L = Math.imul(Xe, Ce), T = Math.imul(Xe, Be), T = T + Math.imul(Ge, Ce) | 0, B = Math.imul(Ge, Be), L = L + Math.imul(je, Je) | 0, T = T + Math.imul(je, Ze) | 0, T = T + Math.imul(qe, Je) | 0, B = B + Math.imul(qe, Ze) | 0, L = L + Math.imul(Ne, x) | 0, T = T + Math.imul(Ne, se) | 0, T = T + Math.imul(Pe, x) | 0, B = B + Math.imul(Pe, se) | 0, L = L + Math.imul(A, xe) | 0, T = T + Math.imul(A, Me) | 0, T = T + Math.imul(re, xe) | 0, B = B + Math.imul(re, Me) | 0, L = L + Math.imul(Ae, et) | 0, T = T + Math.imul(Ae, dt) | 0, T = T + Math.imul(Ue, et) | 0, B = B + Math.imul(Ue, dt) | 0, L = L + Math.imul(ve, tt) | 0, T = T + Math.imul(ve, at) | 0, T = T + Math.imul(he, tt) | 0, B = B + Math.imul(he, at) | 0, L = L + Math.imul(pe, rt) | 0, T = T + Math.imul(pe, ut) | 0, T = T + Math.imul(Ie, rt) | 0, B = B + Math.imul(Ie, ut) | 0;
      var mt = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (mt >>> 26) | 0, mt &= 67108863, L = Math.imul(ye, Ce), T = Math.imul(ye, Be), T = T + Math.imul(Ee, Ce) | 0, B = Math.imul(Ee, Be), L = L + Math.imul(Xe, Je) | 0, T = T + Math.imul(Xe, Ze) | 0, T = T + Math.imul(Ge, Je) | 0, B = B + Math.imul(Ge, Ze) | 0, L = L + Math.imul(je, x) | 0, T = T + Math.imul(je, se) | 0, T = T + Math.imul(qe, x) | 0, B = B + Math.imul(qe, se) | 0, L = L + Math.imul(Ne, xe) | 0, T = T + Math.imul(Ne, Me) | 0, T = T + Math.imul(Pe, xe) | 0, B = B + Math.imul(Pe, Me) | 0, L = L + Math.imul(A, et) | 0, T = T + Math.imul(A, dt) | 0, T = T + Math.imul(re, et) | 0, B = B + Math.imul(re, dt) | 0, L = L + Math.imul(Ae, tt) | 0, T = T + Math.imul(Ae, at) | 0, T = T + Math.imul(Ue, tt) | 0, B = B + Math.imul(Ue, at) | 0, L = L + Math.imul(ve, rt) | 0, T = T + Math.imul(ve, ut) | 0, T = T + Math.imul(he, rt) | 0, B = B + Math.imul(he, ut) | 0, L = L + Math.imul(pe, nt) | 0, T = T + Math.imul(pe, it) | 0, T = T + Math.imul(Ie, nt) | 0, B = B + Math.imul(Ie, it) | 0;
      var vt = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, L = Math.imul(we, Ce), T = Math.imul(we, Be), T = T + Math.imul(V, Ce) | 0, B = Math.imul(V, Be), L = L + Math.imul(ye, Je) | 0, T = T + Math.imul(ye, Ze) | 0, T = T + Math.imul(Ee, Je) | 0, B = B + Math.imul(Ee, Ze) | 0, L = L + Math.imul(Xe, x) | 0, T = T + Math.imul(Xe, se) | 0, T = T + Math.imul(Ge, x) | 0, B = B + Math.imul(Ge, se) | 0, L = L + Math.imul(je, xe) | 0, T = T + Math.imul(je, Me) | 0, T = T + Math.imul(qe, xe) | 0, B = B + Math.imul(qe, Me) | 0, L = L + Math.imul(Ne, et) | 0, T = T + Math.imul(Ne, dt) | 0, T = T + Math.imul(Pe, et) | 0, B = B + Math.imul(Pe, dt) | 0, L = L + Math.imul(A, tt) | 0, T = T + Math.imul(A, at) | 0, T = T + Math.imul(re, tt) | 0, B = B + Math.imul(re, at) | 0, L = L + Math.imul(Ae, rt) | 0, T = T + Math.imul(Ae, ut) | 0, T = T + Math.imul(Ue, rt) | 0, B = B + Math.imul(Ue, ut) | 0, L = L + Math.imul(ve, nt) | 0, T = T + Math.imul(ve, it) | 0, T = T + Math.imul(he, nt) | 0, B = B + Math.imul(he, it) | 0, L = L + Math.imul(pe, ot) | 0, T = T + Math.imul(pe, ct) | 0, T = T + Math.imul(Ie, ot) | 0, B = B + Math.imul(Ie, ct) | 0;
      var ht = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (ht >>> 26) | 0, ht &= 67108863, L = Math.imul(ue, Ce), T = Math.imul(ue, Be), T = T + Math.imul(ce, Ce) | 0, B = Math.imul(ce, Be), L = L + Math.imul(we, Je) | 0, T = T + Math.imul(we, Ze) | 0, T = T + Math.imul(V, Je) | 0, B = B + Math.imul(V, Ze) | 0, L = L + Math.imul(ye, x) | 0, T = T + Math.imul(ye, se) | 0, T = T + Math.imul(Ee, x) | 0, B = B + Math.imul(Ee, se) | 0, L = L + Math.imul(Xe, xe) | 0, T = T + Math.imul(Xe, Me) | 0, T = T + Math.imul(Ge, xe) | 0, B = B + Math.imul(Ge, Me) | 0, L = L + Math.imul(je, et) | 0, T = T + Math.imul(je, dt) | 0, T = T + Math.imul(qe, et) | 0, B = B + Math.imul(qe, dt) | 0, L = L + Math.imul(Ne, tt) | 0, T = T + Math.imul(Ne, at) | 0, T = T + Math.imul(Pe, tt) | 0, B = B + Math.imul(Pe, at) | 0, L = L + Math.imul(A, rt) | 0, T = T + Math.imul(A, ut) | 0, T = T + Math.imul(re, rt) | 0, B = B + Math.imul(re, ut) | 0, L = L + Math.imul(Ae, nt) | 0, T = T + Math.imul(Ae, it) | 0, T = T + Math.imul(Ue, nt) | 0, B = B + Math.imul(Ue, it) | 0, L = L + Math.imul(ve, ot) | 0, T = T + Math.imul(ve, ct) | 0, T = T + Math.imul(he, ot) | 0, B = B + Math.imul(he, ct) | 0, L = L + Math.imul(pe, st) | 0, T = T + Math.imul(pe, lt) | 0, T = T + Math.imul(Ie, st) | 0, B = B + Math.imul(Ie, lt) | 0;
      var Et = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, L = Math.imul(ue, Je), T = Math.imul(ue, Ze), T = T + Math.imul(ce, Je) | 0, B = Math.imul(ce, Ze), L = L + Math.imul(we, x) | 0, T = T + Math.imul(we, se) | 0, T = T + Math.imul(V, x) | 0, B = B + Math.imul(V, se) | 0, L = L + Math.imul(ye, xe) | 0, T = T + Math.imul(ye, Me) | 0, T = T + Math.imul(Ee, xe) | 0, B = B + Math.imul(Ee, Me) | 0, L = L + Math.imul(Xe, et) | 0, T = T + Math.imul(Xe, dt) | 0, T = T + Math.imul(Ge, et) | 0, B = B + Math.imul(Ge, dt) | 0, L = L + Math.imul(je, tt) | 0, T = T + Math.imul(je, at) | 0, T = T + Math.imul(qe, tt) | 0, B = B + Math.imul(qe, at) | 0, L = L + Math.imul(Ne, rt) | 0, T = T + Math.imul(Ne, ut) | 0, T = T + Math.imul(Pe, rt) | 0, B = B + Math.imul(Pe, ut) | 0, L = L + Math.imul(A, nt) | 0, T = T + Math.imul(A, it) | 0, T = T + Math.imul(re, nt) | 0, B = B + Math.imul(re, it) | 0, L = L + Math.imul(Ae, ot) | 0, T = T + Math.imul(Ae, ct) | 0, T = T + Math.imul(Ue, ot) | 0, B = B + Math.imul(Ue, ct) | 0, L = L + Math.imul(ve, st) | 0, T = T + Math.imul(ve, lt) | 0, T = T + Math.imul(he, st) | 0, B = B + Math.imul(he, lt) | 0;
      var Tt = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (Tt >>> 26) | 0, Tt &= 67108863, L = Math.imul(ue, x), T = Math.imul(ue, se), T = T + Math.imul(ce, x) | 0, B = Math.imul(ce, se), L = L + Math.imul(we, xe) | 0, T = T + Math.imul(we, Me) | 0, T = T + Math.imul(V, xe) | 0, B = B + Math.imul(V, Me) | 0, L = L + Math.imul(ye, et) | 0, T = T + Math.imul(ye, dt) | 0, T = T + Math.imul(Ee, et) | 0, B = B + Math.imul(Ee, dt) | 0, L = L + Math.imul(Xe, tt) | 0, T = T + Math.imul(Xe, at) | 0, T = T + Math.imul(Ge, tt) | 0, B = B + Math.imul(Ge, at) | 0, L = L + Math.imul(je, rt) | 0, T = T + Math.imul(je, ut) | 0, T = T + Math.imul(qe, rt) | 0, B = B + Math.imul(qe, ut) | 0, L = L + Math.imul(Ne, nt) | 0, T = T + Math.imul(Ne, it) | 0, T = T + Math.imul(Pe, nt) | 0, B = B + Math.imul(Pe, it) | 0, L = L + Math.imul(A, ot) | 0, T = T + Math.imul(A, ct) | 0, T = T + Math.imul(re, ot) | 0, B = B + Math.imul(re, ct) | 0, L = L + Math.imul(Ae, st) | 0, T = T + Math.imul(Ae, lt) | 0, T = T + Math.imul(Ue, st) | 0, B = B + Math.imul(Ue, lt) | 0;
      var Ot = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (Ot >>> 26) | 0, Ot &= 67108863, L = Math.imul(ue, xe), T = Math.imul(ue, Me), T = T + Math.imul(ce, xe) | 0, B = Math.imul(ce, Me), L = L + Math.imul(we, et) | 0, T = T + Math.imul(we, dt) | 0, T = T + Math.imul(V, et) | 0, B = B + Math.imul(V, dt) | 0, L = L + Math.imul(ye, tt) | 0, T = T + Math.imul(ye, at) | 0, T = T + Math.imul(Ee, tt) | 0, B = B + Math.imul(Ee, at) | 0, L = L + Math.imul(Xe, rt) | 0, T = T + Math.imul(Xe, ut) | 0, T = T + Math.imul(Ge, rt) | 0, B = B + Math.imul(Ge, ut) | 0, L = L + Math.imul(je, nt) | 0, T = T + Math.imul(je, it) | 0, T = T + Math.imul(qe, nt) | 0, B = B + Math.imul(qe, it) | 0, L = L + Math.imul(Ne, ot) | 0, T = T + Math.imul(Ne, ct) | 0, T = T + Math.imul(Pe, ot) | 0, B = B + Math.imul(Pe, ct) | 0, L = L + Math.imul(A, st) | 0, T = T + Math.imul(A, lt) | 0, T = T + Math.imul(re, st) | 0, B = B + Math.imul(re, lt) | 0;
      var Nt = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, L = Math.imul(ue, et), T = Math.imul(ue, dt), T = T + Math.imul(ce, et) | 0, B = Math.imul(ce, dt), L = L + Math.imul(we, tt) | 0, T = T + Math.imul(we, at) | 0, T = T + Math.imul(V, tt) | 0, B = B + Math.imul(V, at) | 0, L = L + Math.imul(ye, rt) | 0, T = T + Math.imul(ye, ut) | 0, T = T + Math.imul(Ee, rt) | 0, B = B + Math.imul(Ee, ut) | 0, L = L + Math.imul(Xe, nt) | 0, T = T + Math.imul(Xe, it) | 0, T = T + Math.imul(Ge, nt) | 0, B = B + Math.imul(Ge, it) | 0, L = L + Math.imul(je, ot) | 0, T = T + Math.imul(je, ct) | 0, T = T + Math.imul(qe, ot) | 0, B = B + Math.imul(qe, ct) | 0, L = L + Math.imul(Ne, st) | 0, T = T + Math.imul(Ne, lt) | 0, T = T + Math.imul(Pe, st) | 0, B = B + Math.imul(Pe, lt) | 0;
      var At = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, L = Math.imul(ue, tt), T = Math.imul(ue, at), T = T + Math.imul(ce, tt) | 0, B = Math.imul(ce, at), L = L + Math.imul(we, rt) | 0, T = T + Math.imul(we, ut) | 0, T = T + Math.imul(V, rt) | 0, B = B + Math.imul(V, ut) | 0, L = L + Math.imul(ye, nt) | 0, T = T + Math.imul(ye, it) | 0, T = T + Math.imul(Ee, nt) | 0, B = B + Math.imul(Ee, it) | 0, L = L + Math.imul(Xe, ot) | 0, T = T + Math.imul(Xe, ct) | 0, T = T + Math.imul(Ge, ot) | 0, B = B + Math.imul(Ge, ct) | 0, L = L + Math.imul(je, st) | 0, T = T + Math.imul(je, lt) | 0, T = T + Math.imul(qe, st) | 0, B = B + Math.imul(qe, lt) | 0;
      var Mt = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (Mt >>> 26) | 0, Mt &= 67108863, L = Math.imul(ue, rt), T = Math.imul(ue, ut), T = T + Math.imul(ce, rt) | 0, B = Math.imul(ce, ut), L = L + Math.imul(we, nt) | 0, T = T + Math.imul(we, it) | 0, T = T + Math.imul(V, nt) | 0, B = B + Math.imul(V, it) | 0, L = L + Math.imul(ye, ot) | 0, T = T + Math.imul(ye, ct) | 0, T = T + Math.imul(Ee, ot) | 0, B = B + Math.imul(Ee, ct) | 0, L = L + Math.imul(Xe, st) | 0, T = T + Math.imul(Xe, lt) | 0, T = T + Math.imul(Ge, st) | 0, B = B + Math.imul(Ge, lt) | 0;
      var $t = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + ($t >>> 26) | 0, $t &= 67108863, L = Math.imul(ue, nt), T = Math.imul(ue, it), T = T + Math.imul(ce, nt) | 0, B = Math.imul(ce, it), L = L + Math.imul(we, ot) | 0, T = T + Math.imul(we, ct) | 0, T = T + Math.imul(V, ot) | 0, B = B + Math.imul(V, ct) | 0, L = L + Math.imul(ye, st) | 0, T = T + Math.imul(ye, lt) | 0, T = T + Math.imul(Ee, st) | 0, B = B + Math.imul(Ee, lt) | 0;
      var Bt = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, L = Math.imul(ue, ot), T = Math.imul(ue, ct), T = T + Math.imul(ce, ot) | 0, B = Math.imul(ce, ct), L = L + Math.imul(we, st) | 0, T = T + Math.imul(we, lt) | 0, T = T + Math.imul(V, st) | 0, B = B + Math.imul(V, lt) | 0;
      var Ut = (Y + L | 0) + ((T & 8191) << 13) | 0;
      Y = (B + (T >>> 13) | 0) + (Ut >>> 26) | 0, Ut &= 67108863, L = Math.imul(ue, st), T = Math.imul(ue, lt), T = T + Math.imul(ce, st) | 0, B = Math.imul(ce, lt);
      var xt = (Y + L | 0) + ((T & 8191) << 13) | 0;
      return Y = (B + (T >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, U[0] = It, U[1] = Rt, U[2] = Ve, U[3] = He, U[4] = Qe, U[5] = pt, U[6] = mt, U[7] = vt, U[8] = ht, U[9] = Et, U[10] = Tt, U[11] = Ot, U[12] = Nt, U[13] = At, U[14] = Mt, U[15] = $t, U[16] = Bt, U[17] = Ut, U[18] = xt, Y !== 0 && (U[19] = Y, I.length++), I;
    };
    Math.imul || (ae = X);
    function Q(C, S, E) {
      E.negative = S.negative ^ C.negative, E.length = C.length + S.length;
      for (var I = 0, M = 0, $ = 0; $ < E.length - 1; $++) {
        var U = M;
        M = 0;
        for (var Y = I & 67108863, L = Math.min($, S.length - 1), T = Math.max(0, $ - C.length + 1); T <= L; T++) {
          var B = $ - T, te = C.words[B] | 0, pe = S.words[T] | 0, Ie = te * pe, $e = Ie & 67108863;
          U = U + (Ie / 67108864 | 0) | 0, $e = $e + Y | 0, Y = $e & 67108863, U = U + ($e >>> 26) | 0, M += U >>> 26, U &= 67108863;
        }
        E.words[$] = Y, I = U, U = M;
      }
      return I !== 0 ? E.words[$] = I : E.length--, E.strip();
    }
    function ne(C, S, E) {
      var I = new Z();
      return I.mulp(C, S, E);
    }
    p.prototype.mulTo = function(S, E) {
      var I, M = this.length + S.length;
      return this.length === 10 && S.length === 10 ? I = ae(this, S, E) : M < 63 ? I = X(this, S, E) : M < 1024 ? I = Q(this, S, E) : I = ne(this, S, E), I;
    };
    function Z(C, S) {
      this.x = C, this.y = S;
    }
    Z.prototype.makeRBT = function(S) {
      for (var E = new Array(S), I = p.prototype._countBits(S) - 1, M = 0; M < S; M++)
        E[M] = this.revBin(M, I, S);
      return E;
    }, Z.prototype.revBin = function(S, E, I) {
      if (S === 0 || S === I - 1)
        return S;
      for (var M = 0, $ = 0; $ < E; $++)
        M |= (S & 1) << E - $ - 1, S >>= 1;
      return M;
    }, Z.prototype.permute = function(S, E, I, M, $, U) {
      for (var Y = 0; Y < U; Y++)
        M[Y] = E[S[Y]], $[Y] = I[S[Y]];
    }, Z.prototype.transform = function(S, E, I, M, $, U) {
      this.permute(U, S, E, I, M, $);
      for (var Y = 1; Y < $; Y <<= 1)
        for (var L = Y << 1, T = Math.cos(2 * Math.PI / L), B = Math.sin(2 * Math.PI / L), te = 0; te < $; te += L)
          for (var pe = T, Ie = B, $e = 0; $e < Y; $e++) {
            var ve = I[te + $e], he = M[te + $e], Oe = I[te + $e + Y], Ae = M[te + $e + Y], Ue = pe * Oe - Ie * Ae;
            Ae = pe * Ae + Ie * Oe, Oe = Ue, I[te + $e] = ve + Oe, M[te + $e] = he + Ae, I[te + $e + Y] = ve - Oe, M[te + $e + Y] = he - Ae, $e !== L && (Ue = T * pe - B * Ie, Ie = T * Ie + B * pe, pe = Ue);
          }
    }, Z.prototype.guessLen13b = function(S, E) {
      var I = Math.max(E, S) | 1, M = I & 1, $ = 0;
      for (I = I / 2 | 0; I; I = I >>> 1)
        $++;
      return 1 << $ + 1 + M;
    }, Z.prototype.conjugate = function(S, E, I) {
      if (!(I <= 1))
        for (var M = 0; M < I / 2; M++) {
          var $ = S[M];
          S[M] = S[I - M - 1], S[I - M - 1] = $, $ = E[M], E[M] = -E[I - M - 1], E[I - M - 1] = -$;
        }
    }, Z.prototype.normalize13b = function(S, E) {
      for (var I = 0, M = 0; M < E / 2; M++) {
        var $ = Math.round(S[2 * M + 1] / E) * 8192 + Math.round(S[2 * M] / E) + I;
        S[M] = $ & 67108863, $ < 67108864 ? I = 0 : I = $ / 67108864 | 0;
      }
      return S;
    }, Z.prototype.convert13b = function(S, E, I, M) {
      for (var $ = 0, U = 0; U < E; U++)
        $ = $ + (S[U] | 0), I[2 * U] = $ & 8191, $ = $ >>> 13, I[2 * U + 1] = $ & 8191, $ = $ >>> 13;
      for (U = 2 * E; U < M; ++U)
        I[U] = 0;
      l($ === 0), l(($ & -8192) === 0);
    }, Z.prototype.stub = function(S) {
      for (var E = new Array(S), I = 0; I < S; I++)
        E[I] = 0;
      return E;
    }, Z.prototype.mulp = function(S, E, I) {
      var M = 2 * this.guessLen13b(S.length, E.length), $ = this.makeRBT(M), U = this.stub(M), Y = new Array(M), L = new Array(M), T = new Array(M), B = new Array(M), te = new Array(M), pe = new Array(M), Ie = I.words;
      Ie.length = M, this.convert13b(S.words, S.length, Y, M), this.convert13b(E.words, E.length, B, M), this.transform(Y, U, L, T, M, $), this.transform(B, U, te, pe, M, $);
      for (var $e = 0; $e < M; $e++) {
        var ve = L[$e] * te[$e] - T[$e] * pe[$e];
        T[$e] = L[$e] * pe[$e] + T[$e] * te[$e], L[$e] = ve;
      }
      return this.conjugate(L, T, M), this.transform(L, T, Ie, U, M, $), this.conjugate(Ie, U, M), this.normalize13b(Ie, M), I.negative = S.negative ^ E.negative, I.length = S.length + E.length, I.strip();
    }, p.prototype.mul = function(S) {
      var E = new p(null);
      return E.words = new Array(this.length + S.length), this.mulTo(S, E);
    }, p.prototype.mulf = function(S) {
      var E = new p(null);
      return E.words = new Array(this.length + S.length), ne(this, S, E);
    }, p.prototype.imul = function(S) {
      return this.clone().mulTo(S, this);
    }, p.prototype.imuln = function(S) {
      l(typeof S == "number"), l(S < 67108864);
      for (var E = 0, I = 0; I < this.length; I++) {
        var M = (this.words[I] | 0) * S, $ = (M & 67108863) + (E & 67108863);
        E >>= 26, E += M / 67108864 | 0, E += $ >>> 26, this.words[I] = $ & 67108863;
      }
      return E !== 0 && (this.words[I] = E, this.length++), this;
    }, p.prototype.muln = function(S) {
      return this.clone().imuln(S);
    }, p.prototype.sqr = function() {
      return this.mul(this);
    }, p.prototype.isqr = function() {
      return this.imul(this.clone());
    }, p.prototype.pow = function(S) {
      var E = ee(S);
      if (E.length === 0)
        return new p(1);
      for (var I = this, M = 0; M < E.length && E[M] === 0; M++, I = I.sqr())
        ;
      if (++M < E.length)
        for (var $ = I.sqr(); M < E.length; M++, $ = $.sqr())
          E[M] !== 0 && (I = I.mul($));
      return I;
    }, p.prototype.iushln = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = S % 26, I = (S - E) / 26, M = 67108863 >>> 26 - E << 26 - E, $;
      if (E !== 0) {
        var U = 0;
        for ($ = 0; $ < this.length; $++) {
          var Y = this.words[$] & M, L = (this.words[$] | 0) - Y << E;
          this.words[$] = L | U, U = Y >>> 26 - E;
        }
        U && (this.words[$] = U, this.length++);
      }
      if (I !== 0) {
        for ($ = this.length - 1; $ >= 0; $--)
          this.words[$ + I] = this.words[$];
        for ($ = 0; $ < I; $++)
          this.words[$] = 0;
        this.length += I;
      }
      return this.strip();
    }, p.prototype.ishln = function(S) {
      return l(this.negative === 0), this.iushln(S);
    }, p.prototype.iushrn = function(S, E, I) {
      l(typeof S == "number" && S >= 0);
      var M;
      E ? M = (E - E % 26) / 26 : M = 0;
      var $ = S % 26, U = Math.min((S - $) / 26, this.length), Y = 67108863 ^ 67108863 >>> $ << $, L = I;
      if (M -= U, M = Math.max(0, M), L) {
        for (var T = 0; T < U; T++)
          L.words[T] = this.words[T];
        L.length = U;
      }
      if (U !== 0)
        if (this.length > U)
          for (this.length -= U, T = 0; T < this.length; T++)
            this.words[T] = this.words[T + U];
        else
          this.words[0] = 0, this.length = 1;
      var B = 0;
      for (T = this.length - 1; T >= 0 && (B !== 0 || T >= M); T--) {
        var te = this.words[T] | 0;
        this.words[T] = B << 26 - $ | te >>> $, B = te & Y;
      }
      return L && B !== 0 && (L.words[L.length++] = B), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, p.prototype.ishrn = function(S, E, I) {
      return l(this.negative === 0), this.iushrn(S, E, I);
    }, p.prototype.shln = function(S) {
      return this.clone().ishln(S);
    }, p.prototype.ushln = function(S) {
      return this.clone().iushln(S);
    }, p.prototype.shrn = function(S) {
      return this.clone().ishrn(S);
    }, p.prototype.ushrn = function(S) {
      return this.clone().iushrn(S);
    }, p.prototype.testn = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = S % 26, I = (S - E) / 26, M = 1 << E;
      if (this.length <= I)
        return !1;
      var $ = this.words[I];
      return !!($ & M);
    }, p.prototype.imaskn = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = S % 26, I = (S - E) / 26;
      if (l(this.negative === 0, "imaskn works only with positive numbers"), this.length <= I)
        return this;
      if (E !== 0 && I++, this.length = Math.min(I, this.length), E !== 0) {
        var M = 67108863 ^ 67108863 >>> E << E;
        this.words[this.length - 1] &= M;
      }
      return this.strip();
    }, p.prototype.maskn = function(S) {
      return this.clone().imaskn(S);
    }, p.prototype.iaddn = function(S) {
      return l(typeof S == "number"), l(S < 67108864), S < 0 ? this.isubn(-S) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < S ? (this.words[0] = S - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(S), this.negative = 1, this) : this._iaddn(S);
    }, p.prototype._iaddn = function(S) {
      this.words[0] += S;
      for (var E = 0; E < this.length && this.words[E] >= 67108864; E++)
        this.words[E] -= 67108864, E === this.length - 1 ? this.words[E + 1] = 1 : this.words[E + 1]++;
      return this.length = Math.max(this.length, E + 1), this;
    }, p.prototype.isubn = function(S) {
      if (l(typeof S == "number"), l(S < 67108864), S < 0)
        return this.iaddn(-S);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(S), this.negative = 1, this;
      if (this.words[0] -= S, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var E = 0; E < this.length && this.words[E] < 0; E++)
          this.words[E] += 67108864, this.words[E + 1] -= 1;
      return this.strip();
    }, p.prototype.addn = function(S) {
      return this.clone().iaddn(S);
    }, p.prototype.subn = function(S) {
      return this.clone().isubn(S);
    }, p.prototype.iabs = function() {
      return this.negative = 0, this;
    }, p.prototype.abs = function() {
      return this.clone().iabs();
    }, p.prototype._ishlnsubmul = function(S, E, I) {
      var M = S.length + I, $;
      this._expand(M);
      var U, Y = 0;
      for ($ = 0; $ < S.length; $++) {
        U = (this.words[$ + I] | 0) + Y;
        var L = (S.words[$] | 0) * E;
        U -= L & 67108863, Y = (U >> 26) - (L / 67108864 | 0), this.words[$ + I] = U & 67108863;
      }
      for (; $ < this.length - I; $++)
        U = (this.words[$ + I] | 0) + Y, Y = U >> 26, this.words[$ + I] = U & 67108863;
      if (Y === 0)
        return this.strip();
      for (l(Y === -1), Y = 0, $ = 0; $ < this.length; $++)
        U = -(this.words[$] | 0) + Y, Y = U >> 26, this.words[$] = U & 67108863;
      return this.negative = 1, this.strip();
    }, p.prototype._wordDiv = function(S, E) {
      var I = this.length - S.length, M = this.clone(), $ = S, U = $.words[$.length - 1] | 0, Y = this._countBits(U);
      I = 26 - Y, I !== 0 && ($ = $.ushln(I), M.iushln(I), U = $.words[$.length - 1] | 0);
      var L = M.length - $.length, T;
      if (E !== "mod") {
        T = new p(null), T.length = L + 1, T.words = new Array(T.length);
        for (var B = 0; B < T.length; B++)
          T.words[B] = 0;
      }
      var te = M.clone()._ishlnsubmul($, 1, L);
      te.negative === 0 && (M = te, T && (T.words[L] = 1));
      for (var pe = L - 1; pe >= 0; pe--) {
        var Ie = (M.words[$.length + pe] | 0) * 67108864 + (M.words[$.length + pe - 1] | 0);
        for (Ie = Math.min(Ie / U | 0, 67108863), M._ishlnsubmul($, Ie, pe); M.negative !== 0; )
          Ie--, M.negative = 0, M._ishlnsubmul($, 1, pe), M.isZero() || (M.negative ^= 1);
        T && (T.words[pe] = Ie);
      }
      return T && T.strip(), M.strip(), E !== "div" && I !== 0 && M.iushrn(I), {
        div: T || null,
        mod: M
      };
    }, p.prototype.divmod = function(S, E, I) {
      if (l(!S.isZero()), this.isZero())
        return {
          div: new p(0),
          mod: new p(0)
        };
      var M, $, U;
      return this.negative !== 0 && S.negative === 0 ? (U = this.neg().divmod(S, E), E !== "mod" && (M = U.div.neg()), E !== "div" && ($ = U.mod.neg(), I && $.negative !== 0 && $.iadd(S)), {
        div: M,
        mod: $
      }) : this.negative === 0 && S.negative !== 0 ? (U = this.divmod(S.neg(), E), E !== "mod" && (M = U.div.neg()), {
        div: M,
        mod: U.mod
      }) : this.negative & S.negative ? (U = this.neg().divmod(S.neg(), E), E !== "div" && ($ = U.mod.neg(), I && $.negative !== 0 && $.isub(S)), {
        div: U.div,
        mod: $
      }) : S.length > this.length || this.cmp(S) < 0 ? {
        div: new p(0),
        mod: this
      } : S.length === 1 ? E === "div" ? {
        div: this.divn(S.words[0]),
        mod: null
      } : E === "mod" ? {
        div: null,
        mod: new p(this.modn(S.words[0]))
      } : {
        div: this.divn(S.words[0]),
        mod: new p(this.modn(S.words[0]))
      } : this._wordDiv(S, E);
    }, p.prototype.div = function(S) {
      return this.divmod(S, "div", !1).div;
    }, p.prototype.mod = function(S) {
      return this.divmod(S, "mod", !1).mod;
    }, p.prototype.umod = function(S) {
      return this.divmod(S, "mod", !0).mod;
    }, p.prototype.divRound = function(S) {
      var E = this.divmod(S);
      if (E.mod.isZero())
        return E.div;
      var I = E.div.negative !== 0 ? E.mod.isub(S) : E.mod, M = S.ushrn(1), $ = S.andln(1), U = I.cmp(M);
      return U < 0 || $ === 1 && U === 0 ? E.div : E.div.negative !== 0 ? E.div.isubn(1) : E.div.iaddn(1);
    }, p.prototype.modn = function(S) {
      l(S <= 67108863);
      for (var E = (1 << 26) % S, I = 0, M = this.length - 1; M >= 0; M--)
        I = (E * I + (this.words[M] | 0)) % S;
      return I;
    }, p.prototype.idivn = function(S) {
      l(S <= 67108863);
      for (var E = 0, I = this.length - 1; I >= 0; I--) {
        var M = (this.words[I] | 0) + E * 67108864;
        this.words[I] = M / S | 0, E = M % S;
      }
      return this.strip();
    }, p.prototype.divn = function(S) {
      return this.clone().idivn(S);
    }, p.prototype.egcd = function(S) {
      l(S.negative === 0), l(!S.isZero());
      var E = this, I = S.clone();
      E.negative !== 0 ? E = E.umod(S) : E = E.clone();
      for (var M = new p(1), $ = new p(0), U = new p(0), Y = new p(1), L = 0; E.isEven() && I.isEven(); )
        E.iushrn(1), I.iushrn(1), ++L;
      for (var T = I.clone(), B = E.clone(); !E.isZero(); ) {
        for (var te = 0, pe = 1; !(E.words[0] & pe) && te < 26; ++te, pe <<= 1)
          ;
        if (te > 0)
          for (E.iushrn(te); te-- > 0; )
            (M.isOdd() || $.isOdd()) && (M.iadd(T), $.isub(B)), M.iushrn(1), $.iushrn(1);
        for (var Ie = 0, $e = 1; !(I.words[0] & $e) && Ie < 26; ++Ie, $e <<= 1)
          ;
        if (Ie > 0)
          for (I.iushrn(Ie); Ie-- > 0; )
            (U.isOdd() || Y.isOdd()) && (U.iadd(T), Y.isub(B)), U.iushrn(1), Y.iushrn(1);
        E.cmp(I) >= 0 ? (E.isub(I), M.isub(U), $.isub(Y)) : (I.isub(E), U.isub(M), Y.isub($));
      }
      return {
        a: U,
        b: Y,
        gcd: I.iushln(L)
      };
    }, p.prototype._invmp = function(S) {
      l(S.negative === 0), l(!S.isZero());
      var E = this, I = S.clone();
      E.negative !== 0 ? E = E.umod(S) : E = E.clone();
      for (var M = new p(1), $ = new p(0), U = I.clone(); E.cmpn(1) > 0 && I.cmpn(1) > 0; ) {
        for (var Y = 0, L = 1; !(E.words[0] & L) && Y < 26; ++Y, L <<= 1)
          ;
        if (Y > 0)
          for (E.iushrn(Y); Y-- > 0; )
            M.isOdd() && M.iadd(U), M.iushrn(1);
        for (var T = 0, B = 1; !(I.words[0] & B) && T < 26; ++T, B <<= 1)
          ;
        if (T > 0)
          for (I.iushrn(T); T-- > 0; )
            $.isOdd() && $.iadd(U), $.iushrn(1);
        E.cmp(I) >= 0 ? (E.isub(I), M.isub($)) : (I.isub(E), $.isub(M));
      }
      var te;
      return E.cmpn(1) === 0 ? te = M : te = $, te.cmpn(0) < 0 && te.iadd(S), te;
    }, p.prototype.gcd = function(S) {
      if (this.isZero())
        return S.abs();
      if (S.isZero())
        return this.abs();
      var E = this.clone(), I = S.clone();
      E.negative = 0, I.negative = 0;
      for (var M = 0; E.isEven() && I.isEven(); M++)
        E.iushrn(1), I.iushrn(1);
      do {
        for (; E.isEven(); )
          E.iushrn(1);
        for (; I.isEven(); )
          I.iushrn(1);
        var $ = E.cmp(I);
        if ($ < 0) {
          var U = E;
          E = I, I = U;
        } else if ($ === 0 || I.cmpn(1) === 0)
          break;
        E.isub(I);
      } while (!0);
      return I.iushln(M);
    }, p.prototype.invm = function(S) {
      return this.egcd(S).a.umod(S);
    }, p.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, p.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, p.prototype.andln = function(S) {
      return this.words[0] & S;
    }, p.prototype.bincn = function(S) {
      l(typeof S == "number");
      var E = S % 26, I = (S - E) / 26, M = 1 << E;
      if (this.length <= I)
        return this._expand(I + 1), this.words[I] |= M, this;
      for (var $ = M, U = I; $ !== 0 && U < this.length; U++) {
        var Y = this.words[U] | 0;
        Y += $, $ = Y >>> 26, Y &= 67108863, this.words[U] = Y;
      }
      return $ !== 0 && (this.words[U] = $, this.length++), this;
    }, p.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, p.prototype.cmpn = function(S) {
      var E = S < 0;
      if (this.negative !== 0 && !E)
        return -1;
      if (this.negative === 0 && E)
        return 1;
      this.strip();
      var I;
      if (this.length > 1)
        I = 1;
      else {
        E && (S = -S), l(S <= 67108863, "Number is too big");
        var M = this.words[0] | 0;
        I = M === S ? 0 : M < S ? -1 : 1;
      }
      return this.negative !== 0 ? -I | 0 : I;
    }, p.prototype.cmp = function(S) {
      if (this.negative !== 0 && S.negative === 0)
        return -1;
      if (this.negative === 0 && S.negative !== 0)
        return 1;
      var E = this.ucmp(S);
      return this.negative !== 0 ? -E | 0 : E;
    }, p.prototype.ucmp = function(S) {
      if (this.length > S.length)
        return 1;
      if (this.length < S.length)
        return -1;
      for (var E = 0, I = this.length - 1; I >= 0; I--) {
        var M = this.words[I] | 0, $ = S.words[I] | 0;
        if (M !== $) {
          M < $ ? E = -1 : M > $ && (E = 1);
          break;
        }
      }
      return E;
    }, p.prototype.gtn = function(S) {
      return this.cmpn(S) === 1;
    }, p.prototype.gt = function(S) {
      return this.cmp(S) === 1;
    }, p.prototype.gten = function(S) {
      return this.cmpn(S) >= 0;
    }, p.prototype.gte = function(S) {
      return this.cmp(S) >= 0;
    }, p.prototype.ltn = function(S) {
      return this.cmpn(S) === -1;
    }, p.prototype.lt = function(S) {
      return this.cmp(S) === -1;
    }, p.prototype.lten = function(S) {
      return this.cmpn(S) <= 0;
    }, p.prototype.lte = function(S) {
      return this.cmp(S) <= 0;
    }, p.prototype.eqn = function(S) {
      return this.cmpn(S) === 0;
    }, p.prototype.eq = function(S) {
      return this.cmp(S) === 0;
    }, p.red = function(S) {
      return new q(S);
    }, p.prototype.toRed = function(S) {
      return l(!this.red, "Already a number in reduction context"), l(this.negative === 0, "red works only with positives"), S.convertTo(this)._forceRed(S);
    }, p.prototype.fromRed = function() {
      return l(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, p.prototype._forceRed = function(S) {
      return this.red = S, this;
    }, p.prototype.forceRed = function(S) {
      return l(!this.red, "Already a number in reduction context"), this._forceRed(S);
    }, p.prototype.redAdd = function(S) {
      return l(this.red, "redAdd works only with red numbers"), this.red.add(this, S);
    }, p.prototype.redIAdd = function(S) {
      return l(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, S);
    }, p.prototype.redSub = function(S) {
      return l(this.red, "redSub works only with red numbers"), this.red.sub(this, S);
    }, p.prototype.redISub = function(S) {
      return l(this.red, "redISub works only with red numbers"), this.red.isub(this, S);
    }, p.prototype.redShl = function(S) {
      return l(this.red, "redShl works only with red numbers"), this.red.shl(this, S);
    }, p.prototype.redMul = function(S) {
      return l(this.red, "redMul works only with red numbers"), this.red._verify2(this, S), this.red.mul(this, S);
    }, p.prototype.redIMul = function(S) {
      return l(this.red, "redMul works only with red numbers"), this.red._verify2(this, S), this.red.imul(this, S);
    }, p.prototype.redSqr = function() {
      return l(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, p.prototype.redISqr = function() {
      return l(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, p.prototype.redSqrt = function() {
      return l(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, p.prototype.redInvm = function() {
      return l(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, p.prototype.redNeg = function() {
      return l(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, p.prototype.redPow = function(S) {
      return l(this.red && !S.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, S);
    };
    var de = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function fe(C, S) {
      this.name = C, this.p = new p(S, 16), this.n = this.p.bitLength(), this.k = new p(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    fe.prototype._tmp = function() {
      var S = new p(null);
      return S.words = new Array(Math.ceil(this.n / 13)), S;
    }, fe.prototype.ireduce = function(S) {
      var E = S, I;
      do
        this.split(E, this.tmp), E = this.imulK(E), E = E.iadd(this.tmp), I = E.bitLength();
      while (I > this.n);
      var M = I < this.n ? -1 : E.ucmp(this.p);
      return M === 0 ? (E.words[0] = 0, E.length = 1) : M > 0 ? E.isub(this.p) : E.strip !== void 0 ? E.strip() : E._strip(), E;
    }, fe.prototype.split = function(S, E) {
      S.iushrn(this.n, 0, E);
    }, fe.prototype.imulK = function(S) {
      return S.imul(this.k);
    };
    function Te() {
      fe.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    v(Te, fe), Te.prototype.split = function(S, E) {
      for (var I = 4194303, M = Math.min(S.length, 9), $ = 0; $ < M; $++)
        E.words[$] = S.words[$];
      if (E.length = M, S.length <= 9) {
        S.words[0] = 0, S.length = 1;
        return;
      }
      var U = S.words[9];
      for (E.words[E.length++] = U & I, $ = 10; $ < S.length; $++) {
        var Y = S.words[$] | 0;
        S.words[$ - 10] = (Y & I) << 4 | U >>> 22, U = Y;
      }
      U >>>= 22, S.words[$ - 10] = U, U === 0 && S.length > 10 ? S.length -= 10 : S.length -= 9;
    }, Te.prototype.imulK = function(S) {
      S.words[S.length] = 0, S.words[S.length + 1] = 0, S.length += 2;
      for (var E = 0, I = 0; I < S.length; I++) {
        var M = S.words[I] | 0;
        E += M * 977, S.words[I] = E & 67108863, E = M * 64 + (E / 67108864 | 0);
      }
      return S.words[S.length - 1] === 0 && (S.length--, S.words[S.length - 1] === 0 && S.length--), S;
    };
    function Re() {
      fe.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    v(Re, fe);
    function Le() {
      fe.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    v(Le, fe);
    function be() {
      fe.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    v(be, fe), be.prototype.imulK = function(S) {
      for (var E = 0, I = 0; I < S.length; I++) {
        var M = (S.words[I] | 0) * 19 + E, $ = M & 67108863;
        M >>>= 26, S.words[I] = $, E = M;
      }
      return E !== 0 && (S.words[S.length++] = E), S;
    }, p._prime = function(S) {
      if (de[S])
        return de[S];
      var E;
      if (S === "k256")
        E = new Te();
      else if (S === "p224")
        E = new Re();
      else if (S === "p192")
        E = new Le();
      else if (S === "p25519")
        E = new be();
      else
        throw new Error("Unknown prime " + S);
      return de[S] = E, E;
    };
    function q(C) {
      if (typeof C == "string") {
        var S = p._prime(C);
        this.m = S.p, this.prime = S;
      } else
        l(C.gtn(1), "modulus must be greater than 1"), this.m = C, this.prime = null;
    }
    q.prototype._verify1 = function(S) {
      l(S.negative === 0, "red works only with positives"), l(S.red, "red works only with red numbers");
    }, q.prototype._verify2 = function(S, E) {
      l((S.negative | E.negative) === 0, "red works only with positives"), l(
        S.red && S.red === E.red,
        "red works only with red numbers"
      );
    }, q.prototype.imod = function(S) {
      return this.prime ? this.prime.ireduce(S)._forceRed(this) : S.umod(this.m)._forceRed(this);
    }, q.prototype.neg = function(S) {
      return S.isZero() ? S.clone() : this.m.sub(S)._forceRed(this);
    }, q.prototype.add = function(S, E) {
      this._verify2(S, E);
      var I = S.add(E);
      return I.cmp(this.m) >= 0 && I.isub(this.m), I._forceRed(this);
    }, q.prototype.iadd = function(S, E) {
      this._verify2(S, E);
      var I = S.iadd(E);
      return I.cmp(this.m) >= 0 && I.isub(this.m), I;
    }, q.prototype.sub = function(S, E) {
      this._verify2(S, E);
      var I = S.sub(E);
      return I.cmpn(0) < 0 && I.iadd(this.m), I._forceRed(this);
    }, q.prototype.isub = function(S, E) {
      this._verify2(S, E);
      var I = S.isub(E);
      return I.cmpn(0) < 0 && I.iadd(this.m), I;
    }, q.prototype.shl = function(S, E) {
      return this._verify1(S), this.imod(S.ushln(E));
    }, q.prototype.imul = function(S, E) {
      return this._verify2(S, E), this.imod(S.imul(E));
    }, q.prototype.mul = function(S, E) {
      return this._verify2(S, E), this.imod(S.mul(E));
    }, q.prototype.isqr = function(S) {
      return this.imul(S, S.clone());
    }, q.prototype.sqr = function(S) {
      return this.mul(S, S);
    }, q.prototype.sqrt = function(S) {
      if (S.isZero())
        return S.clone();
      var E = this.m.andln(3);
      if (l(E % 2 === 1), E === 3) {
        var I = this.m.add(new p(1)).iushrn(2);
        return this.pow(S, I);
      }
      for (var M = this.m.subn(1), $ = 0; !M.isZero() && M.andln(1) === 0; )
        $++, M.iushrn(1);
      l(!M.isZero());
      var U = new p(1).toRed(this), Y = U.redNeg(), L = this.m.subn(1).iushrn(1), T = this.m.bitLength();
      for (T = new p(2 * T * T).toRed(this); this.pow(T, L).cmp(Y) !== 0; )
        T.redIAdd(Y);
      for (var B = this.pow(T, M), te = this.pow(S, M.addn(1).iushrn(1)), pe = this.pow(S, M), Ie = $; pe.cmp(U) !== 0; ) {
        for (var $e = pe, ve = 0; $e.cmp(U) !== 0; ve++)
          $e = $e.redSqr();
        l(ve < Ie);
        var he = this.pow(B, new p(1).iushln(Ie - ve - 1));
        te = te.redMul(he), B = he.redSqr(), pe = pe.redMul(B), Ie = ve;
      }
      return te;
    }, q.prototype.invm = function(S) {
      var E = S._invmp(this.m);
      return E.negative !== 0 ? (E.negative = 0, this.imod(E).redNeg()) : this.imod(E);
    }, q.prototype.pow = function(S, E) {
      if (E.isZero())
        return new p(1).toRed(this);
      if (E.cmpn(1) === 0)
        return S.clone();
      var I = 4, M = new Array(1 << I);
      M[0] = new p(1).toRed(this), M[1] = S;
      for (var $ = 2; $ < M.length; $++)
        M[$] = this.mul(M[$ - 1], S);
      var U = M[0], Y = 0, L = 0, T = E.bitLength() % 26;
      for (T === 0 && (T = 26), $ = E.length - 1; $ >= 0; $--) {
        for (var B = E.words[$], te = T - 1; te >= 0; te--) {
          var pe = B >> te & 1;
          if (U !== M[0] && (U = this.sqr(U)), pe === 0 && Y === 0) {
            L = 0;
            continue;
          }
          Y <<= 1, Y |= pe, L++, !(L !== I && ($ !== 0 || te !== 0)) && (U = this.mul(U, M[Y]), L = 0, Y = 0);
        }
        T = 26;
      }
      return U;
    }, q.prototype.convertTo = function(S) {
      var E = S.umod(this.m);
      return E === S ? E.clone() : E;
    }, q.prototype.convertFrom = function(S) {
      var E = S.clone();
      return E.red = null, E;
    }, p.mont = function(S) {
      return new J(S);
    };
    function J(C) {
      q.call(this, C), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new p(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    v(J, q), J.prototype.convertTo = function(S) {
      return this.imod(S.ushln(this.shift));
    }, J.prototype.convertFrom = function(S) {
      var E = this.imod(S.mul(this.rinv));
      return E.red = null, E;
    }, J.prototype.imul = function(S, E) {
      if (S.isZero() || E.isZero())
        return S.words[0] = 0, S.length = 1, S;
      var I = S.imul(E), M = I.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), $ = I.isub(M).iushrn(this.shift), U = $;
      return $.cmp(this.m) >= 0 ? U = $.isub(this.m) : $.cmpn(0) < 0 && (U = $.iadd(this.m)), U._forceRed(this);
    }, J.prototype.mul = function(S, E) {
      if (S.isZero() || E.isZero())
        return new p(0)._forceRed(this);
      var I = S.mul(E), M = I.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), $ = I.isub(M).iushrn(this.shift), U = $;
      return $.cmp(this.m) >= 0 ? U = $.isub(this.m) : $.cmpn(0) < 0 && (U = $.iadd(this.m)), U._forceRed(this);
    }, J.prototype.invm = function(S) {
      var E = this.imod(S._invmp(this.m).mul(this.r2));
      return E._forceRed(this);
    };
  })(a, commonjsGlobal$1);
})(bn);
var bnExports = bn.exports, BN$2 = bnExports, Buffer$8 = safeBufferExports$3.Buffer;
function withPublic$2(a, u) {
  return Buffer$8.from(a.toRed(BN$2.mont(u.modulus)).redPow(new BN$2(u.publicExponent)).fromRed().toArray());
}
var withPublic_1 = withPublic$2, parseKeys$1 = parseAsn1, randomBytes = browserExports, createHash$1 = browser$a, mgf$1 = mgf$2, xor$1 = xor$2, BN$1 = bnExports, withPublic$1 = withPublic_1, crt$1 = browserifyRsa, Buffer$7 = safeBufferExports$3.Buffer, publicEncrypt = function a(u, c, l) {
  var v;
  u.padding ? v = u.padding : l ? v = 1 : v = 4;
  var p = parseKeys$1(u), _;
  if (v === 4)
    _ = oaep$1(p, c);
  else if (v === 1)
    _ = pkcs1$1(p, c, l);
  else if (v === 3) {
    if (_ = new BN$1(c), _.cmp(p.modulus) >= 0)
      throw new Error("data too long for modulus");
  } else
    throw new Error("unknown padding");
  return l ? crt$1(_, p) : withPublic$1(_, p);
};
function oaep$1(a, u) {
  var c = a.modulus.byteLength(), l = u.length, v = createHash$1("sha1").update(Buffer$7.alloc(0)).digest(), p = v.length, _ = 2 * p;
  if (l > c - _ - 2)
    throw new Error("message too long");
  var k = Buffer$7.alloc(c - l - _ - 2), O = c - p - 1, D = randomBytes(p), F = xor$1(Buffer$7.concat([v, k, Buffer$7.alloc(1, 1), u], O), mgf$1(D, O)), z = xor$1(D, mgf$1(F, p));
  return new BN$1(Buffer$7.concat([Buffer$7.alloc(1), z, F], c));
}
function pkcs1$1(a, u, c) {
  var l = u.length, v = a.modulus.byteLength();
  if (l > v - 11)
    throw new Error("message too long");
  var p;
  return c ? p = Buffer$7.alloc(v - l - 3, 255) : p = nonZero(v - l - 3), new BN$1(Buffer$7.concat([Buffer$7.from([0, c ? 1 : 2]), p, Buffer$7.alloc(1), u], v));
}
function nonZero(a) {
  for (var u = Buffer$7.allocUnsafe(a), c = 0, l = randomBytes(a * 2), v = 0, p; c < a; )
    v === l.length && (l = randomBytes(a * 2), v = 0), p = l[v++], p && (u[c++] = p);
  return u;
}
var parseKeys = parseAsn1, mgf = mgf$2, xor = xor$2, BN = bnExports, crt = browserifyRsa, createHash = browser$a, withPublic = withPublic_1, Buffer$6 = safeBufferExports$3.Buffer, privateDecrypt = function a(u, c, l) {
  var v;
  u.padding ? v = u.padding : l ? v = 1 : v = 4;
  var p = parseKeys(u), _ = p.modulus.byteLength();
  if (c.length > _ || new BN(c).cmp(p.modulus) >= 0)
    throw new Error("decryption error");
  var k;
  l ? k = withPublic(new BN(c), p) : k = crt(c, p);
  var O = Buffer$6.alloc(_ - k.length);
  if (k = Buffer$6.concat([O, k], _), v === 4)
    return oaep(p, k);
  if (v === 1)
    return pkcs1(p, k, l);
  if (v === 3)
    return k;
  throw new Error("unknown padding");
};
function oaep(a, u) {
  var c = a.modulus.byteLength(), l = createHash("sha1").update(Buffer$6.alloc(0)).digest(), v = l.length;
  if (u[0] !== 0)
    throw new Error("decryption error");
  var p = u.slice(1, v + 1), _ = u.slice(v + 1), k = xor(p, mgf(_, v)), O = xor(_, mgf(k, c - v - 1));
  if (compare(l, O.slice(0, v)))
    throw new Error("decryption error");
  for (var D = v; O[D] === 0; )
    D++;
  if (O[D++] !== 1)
    throw new Error("decryption error");
  return O.slice(D);
}
function pkcs1(a, u, c) {
  for (var l = u.slice(0, 2), v = 2, p = 0; u[v++] !== 0; )
    if (v >= u.length) {
      p++;
      break;
    }
  var _ = u.slice(2, v - 1);
  if ((l.toString("hex") !== "0002" && !c || l.toString("hex") !== "0001" && c) && p++, _.length < 8 && p++, p)
    throw new Error("decryption error");
  return u.slice(v);
}
function compare(a, u) {
  a = Buffer$6.from(a), u = Buffer$6.from(u);
  var c = 0, l = a.length;
  a.length !== u.length && (c++, l = Math.min(a.length, u.length));
  for (var v = -1; ++v < l; )
    c += a[v] ^ u[v];
  return c;
}
(function(a) {
  a.publicEncrypt = publicEncrypt, a.privateDecrypt = privateDecrypt, a.privateEncrypt = function(c, l) {
    return a.publicEncrypt(c, l, !0);
  }, a.publicDecrypt = function(c, l) {
    return a.privateDecrypt(c, l, !0);
  };
})(browser$2);
var browser$1 = {};
function oldBrowser() {
  throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`);
}
var safeBuffer = safeBufferExports$3, randombytes = browserExports, Buffer$5 = safeBuffer.Buffer, kBufferMaxLength = safeBuffer.kMaxLength, crypto$2 = commonjsGlobal$1.crypto || commonjsGlobal$1.msCrypto, kMaxUint32 = Math.pow(2, 32) - 1;
function assertOffset(a, u) {
  if (typeof a != "number" || a !== a)
    throw new TypeError("offset must be a number");
  if (a > kMaxUint32 || a < 0)
    throw new TypeError("offset must be a uint32");
  if (a > kBufferMaxLength || a > u)
    throw new RangeError("offset out of range");
}
function assertSize(a, u, c) {
  if (typeof a != "number" || a !== a)
    throw new TypeError("size must be a number");
  if (a > kMaxUint32 || a < 0)
    throw new TypeError("size must be a uint32");
  if (a + u > c || a > kBufferMaxLength)
    throw new RangeError("buffer too small");
}
crypto$2 && crypto$2.getRandomValues || !process$1.browser ? (browser$1.randomFill = randomFill, browser$1.randomFillSync = randomFillSync) : (browser$1.randomFill = oldBrowser, browser$1.randomFillSync = oldBrowser);
function randomFill(a, u, c, l) {
  if (!Buffer$5.isBuffer(a) && !(a instanceof commonjsGlobal$1.Uint8Array))
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
  if (typeof u == "function")
    l = u, u = 0, c = a.length;
  else if (typeof c == "function")
    l = c, c = a.length - u;
  else if (typeof l != "function")
    throw new TypeError('"cb" argument must be a function');
  return assertOffset(u, a.length), assertSize(c, u, a.length), actualFill(a, u, c, l);
}
function actualFill(a, u, c, l) {
  if (process$1.browser) {
    var v = a.buffer, p = new Uint8Array(v, u, c);
    if (crypto$2.getRandomValues(p), l) {
      process$1.nextTick(function() {
        l(null, a);
      });
      return;
    }
    return a;
  }
  if (l) {
    randombytes(c, function(k, O) {
      if (k)
        return l(k);
      O.copy(a, u), l(null, a);
    });
    return;
  }
  var _ = randombytes(c);
  return _.copy(a, u), a;
}
function randomFillSync(a, u, c) {
  if (typeof u > "u" && (u = 0), !Buffer$5.isBuffer(a) && !(a instanceof commonjsGlobal$1.Uint8Array))
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
  return assertOffset(u, a.length), c === void 0 && (c = a.length - u), assertSize(c, u, a.length), actualFill(a, u, c);
}
var hasRequiredCryptoBrowserify;
function requireCryptoBrowserify() {
  if (hasRequiredCryptoBrowserify)
    return cryptoBrowserify;
  hasRequiredCryptoBrowserify = 1, cryptoBrowserify.randomBytes = cryptoBrowserify.rng = cryptoBrowserify.pseudoRandomBytes = cryptoBrowserify.prng = browserExports, cryptoBrowserify.createHash = cryptoBrowserify.Hash = browser$a, cryptoBrowserify.createHmac = cryptoBrowserify.Hmac = browser$9;
  var a = algos, u = Object.keys(a), c = ["sha1", "sha224", "sha256", "sha384", "sha512", "md5", "rmd160"].concat(u);
  cryptoBrowserify.getHashes = function() {
    return c;
  };
  var l = browser$8;
  cryptoBrowserify.pbkdf2 = l.pbkdf2, cryptoBrowserify.pbkdf2Sync = l.pbkdf2Sync;
  var v = browser$7;
  cryptoBrowserify.Cipher = v.Cipher, cryptoBrowserify.createCipher = v.createCipher, cryptoBrowserify.Cipheriv = v.Cipheriv, cryptoBrowserify.createCipheriv = v.createCipheriv, cryptoBrowserify.Decipher = v.Decipher, cryptoBrowserify.createDecipher = v.createDecipher, cryptoBrowserify.Decipheriv = v.Decipheriv, cryptoBrowserify.createDecipheriv = v.createDecipheriv, cryptoBrowserify.getCiphers = v.getCiphers, cryptoBrowserify.listCiphers = v.listCiphers;
  var p = requireBrowser$2();
  cryptoBrowserify.DiffieHellmanGroup = p.DiffieHellmanGroup, cryptoBrowserify.createDiffieHellmanGroup = p.createDiffieHellmanGroup, cryptoBrowserify.getDiffieHellman = p.getDiffieHellman, cryptoBrowserify.createDiffieHellman = p.createDiffieHellman, cryptoBrowserify.DiffieHellman = p.DiffieHellman;
  var _ = requireBrowser$1();
  cryptoBrowserify.createSign = _.createSign, cryptoBrowserify.Sign = _.Sign, cryptoBrowserify.createVerify = _.createVerify, cryptoBrowserify.Verify = _.Verify, cryptoBrowserify.createECDH = requireBrowser();
  var k = browser$2;
  cryptoBrowserify.publicEncrypt = k.publicEncrypt, cryptoBrowserify.privateEncrypt = k.privateEncrypt, cryptoBrowserify.publicDecrypt = k.publicDecrypt, cryptoBrowserify.privateDecrypt = k.privateDecrypt;
  var O = browser$1;
  return cryptoBrowserify.randomFill = O.randomFill, cryptoBrowserify.randomFillSync = O.randomFillSync, cryptoBrowserify.createCredentials = function() {
    throw new Error([
      "sorry, createCredentials is not implemented yet",
      "we accept pull requests",
      "https://github.com/crypto-browserify/crypto-browserify"
    ].join(`
`));
  }, cryptoBrowserify.constants = {
    DH_CHECK_P_NOT_SAFE_PRIME: 2,
    DH_CHECK_P_NOT_PRIME: 1,
    DH_UNABLE_TO_CHECK_GENERATOR: 4,
    DH_NOT_SUITABLE_GENERATOR: 8,
    NPN_ENABLED: 1,
    ALPN_ENABLED: 1,
    RSA_PKCS1_PADDING: 1,
    RSA_SSLV23_PADDING: 2,
    RSA_NO_PADDING: 3,
    RSA_PKCS1_OAEP_PADDING: 4,
    RSA_X931_PADDING: 5,
    RSA_PKCS1_PSS_PADDING: 6,
    POINT_CONVERSION_COMPRESSED: 2,
    POINT_CONVERSION_UNCOMPRESSED: 4,
    POINT_CONVERSION_HYBRID: 6
  }, cryptoBrowserify;
}
function getParamSize(a) {
  var u = (a / 8 | 0) + (a % 8 === 0 ? 0 : 1);
  return u;
}
var paramBytesForAlg = {
  ES256: getParamSize(256),
  ES384: getParamSize(384),
  ES512: getParamSize(521)
};
function getParamBytesForAlg$1(a) {
  var u = paramBytesForAlg[a];
  if (u)
    return u;
  throw new Error('Unknown algorithm "' + a + '"');
}
var paramBytesForAlg_1 = getParamBytesForAlg$1, Buffer$4 = safeBufferExports$3.Buffer, getParamBytesForAlg = paramBytesForAlg_1, MAX_OCTET = 128, CLASS_UNIVERSAL = 0, PRIMITIVE_BIT = 32, TAG_SEQ = 16, TAG_INT = 2, ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | CLASS_UNIVERSAL << 6, ENCODED_TAG_INT = TAG_INT | CLASS_UNIVERSAL << 6;
function base64Url(a) {
  return a.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function signatureAsBuffer(a) {
  if (Buffer$4.isBuffer(a))
    return a;
  if (typeof a == "string")
    return Buffer$4.from(a, "base64");
  throw new TypeError("ECDSA signature must be a Base64 string or a Buffer");
}
function derToJose(a, u) {
  a = signatureAsBuffer(a);
  var c = getParamBytesForAlg(u), l = c + 1, v = a.length, p = 0;
  if (a[p++] !== ENCODED_TAG_SEQ)
    throw new Error('Could not find expected "seq"');
  var _ = a[p++];
  if (_ === (MAX_OCTET | 1) && (_ = a[p++]), v - p < _)
    throw new Error('"seq" specified length of "' + _ + '", only "' + (v - p) + '" remaining');
  if (a[p++] !== ENCODED_TAG_INT)
    throw new Error('Could not find expected "int" for "r"');
  var k = a[p++];
  if (v - p - 2 < k)
    throw new Error('"r" specified length of "' + k + '", only "' + (v - p - 2) + '" available');
  if (l < k)
    throw new Error('"r" specified length of "' + k + '", max of "' + l + '" is acceptable');
  var O = p;
  if (p += k, a[p++] !== ENCODED_TAG_INT)
    throw new Error('Could not find expected "int" for "s"');
  var D = a[p++];
  if (v - p !== D)
    throw new Error('"s" specified length of "' + D + '", expected "' + (v - p) + '"');
  if (l < D)
    throw new Error('"s" specified length of "' + D + '", max of "' + l + '" is acceptable');
  var F = p;
  if (p += D, p !== v)
    throw new Error('Expected to consume entire buffer, but "' + (v - p) + '" bytes remain');
  var z = c - k, j = c - D, ee = Buffer$4.allocUnsafe(z + k + j + D);
  for (p = 0; p < z; ++p)
    ee[p] = 0;
  a.copy(ee, p, O + Math.max(-z, 0), O + k), p = c;
  for (var X = p; p < X + j; ++p)
    ee[p] = 0;
  return a.copy(ee, p, F + Math.max(-j, 0), F + D), ee = ee.toString("base64"), ee = base64Url(ee), ee;
}
function countPadding(a, u, c) {
  for (var l = 0; u + l < c && a[u + l] === 0; )
    ++l;
  var v = a[u + l] >= MAX_OCTET;
  return v && --l, l;
}
function joseToDer(a, u) {
  a = signatureAsBuffer(a);
  var c = getParamBytesForAlg(u), l = a.length;
  if (l !== c * 2)
    throw new TypeError('"' + u + '" signatures must be "' + c * 2 + '" bytes, saw "' + l + '"');
  var v = countPadding(a, 0, c), p = countPadding(a, c, a.length), _ = c - v, k = c - p, O = 2 + _ + 1 + 1 + k, D = O < MAX_OCTET, F = Buffer$4.allocUnsafe((D ? 2 : 3) + O), z = 0;
  return F[z++] = ENCODED_TAG_SEQ, D ? F[z++] = O : (F[z++] = MAX_OCTET | 1, F[z++] = O & 255), F[z++] = ENCODED_TAG_INT, F[z++] = _, v < 0 ? (F[z++] = 0, z += a.copy(F, z, 0, c)) : z += a.copy(F, z, v, c), F[z++] = ENCODED_TAG_INT, F[z++] = k, p < 0 ? (F[z++] = 0, a.copy(F, z, c)) : a.copy(F, z, c + p), F;
}
var ecdsaSigFormatter = {
  derToJose,
  joseToDer
}, bufferEqual = bufferEqualConstantTime, Buffer$3 = safeBufferExports$3.Buffer, crypto$1 = requireCryptoBrowserify(), formatEcdsa = ecdsaSigFormatter, util$2 = util$4, MSG_INVALID_ALGORITHM = `"%s" is not a valid algorithm.
  Supported algorithms are:
  "HS256", "HS384", "HS512", "RS256", "RS384", "RS512", "PS256", "PS384", "PS512", "ES256", "ES384", "ES512" and "none".`, MSG_INVALID_SECRET = "secret must be a string or buffer", MSG_INVALID_VERIFIER_KEY = "key must be a string or a buffer", MSG_INVALID_SIGNER_KEY = "key must be a string, a buffer or an object", supportsKeyObjects = typeof crypto$1.createPublicKey == "function";
supportsKeyObjects && (MSG_INVALID_VERIFIER_KEY += " or a KeyObject", MSG_INVALID_SECRET += "or a KeyObject");
function checkIsPublicKey(a) {
  if (!Buffer$3.isBuffer(a) && typeof a != "string" && (!supportsKeyObjects || typeof a != "object" || typeof a.type != "string" || typeof a.asymmetricKeyType != "string" || typeof a.export != "function"))
    throw typeError(MSG_INVALID_VERIFIER_KEY);
}
function checkIsPrivateKey(a) {
  if (!Buffer$3.isBuffer(a) && typeof a != "string" && typeof a != "object")
    throw typeError(MSG_INVALID_SIGNER_KEY);
}
function checkIsSecretKey(a) {
  if (!Buffer$3.isBuffer(a)) {
    if (typeof a == "string")
      return a;
    if (!supportsKeyObjects || typeof a != "object" || a.type !== "secret" || typeof a.export != "function")
      throw typeError(MSG_INVALID_SECRET);
  }
}
function fromBase64(a) {
  return a.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function toBase64(a) {
  a = a.toString();
  var u = 4 - a.length % 4;
  if (u !== 4)
    for (var c = 0; c < u; ++c)
      a += "=";
  return a.replace(/\-/g, "+").replace(/_/g, "/");
}
function typeError(a) {
  var u = [].slice.call(arguments, 1), c = util$2.format.bind(util$2, a).apply(null, u);
  return new TypeError(c);
}
function bufferOrString(a) {
  return Buffer$3.isBuffer(a) || typeof a == "string";
}
function normalizeInput(a) {
  return bufferOrString(a) || (a = JSON.stringify(a)), a;
}
function createHmacSigner(a) {
  return function(c, l) {
    checkIsSecretKey(l), c = normalizeInput(c);
    var v = crypto$1.createHmac("sha" + a, l), p = (v.update(c), v.digest("base64"));
    return fromBase64(p);
  };
}
function createHmacVerifier(a) {
  return function(c, l, v) {
    var p = createHmacSigner(a)(c, v);
    return bufferEqual(Buffer$3.from(l), Buffer$3.from(p));
  };
}
function createKeySigner(a) {
  return function(c, l) {
    checkIsPrivateKey(l), c = normalizeInput(c);
    var v = crypto$1.createSign("RSA-SHA" + a), p = (v.update(c), v.sign(l, "base64"));
    return fromBase64(p);
  };
}
function createKeyVerifier(a) {
  return function(c, l, v) {
    checkIsPublicKey(v), c = normalizeInput(c), l = toBase64(l);
    var p = crypto$1.createVerify("RSA-SHA" + a);
    return p.update(c), p.verify(v, l, "base64");
  };
}
function createPSSKeySigner(a) {
  return function(c, l) {
    checkIsPrivateKey(l), c = normalizeInput(c);
    var v = crypto$1.createSign("RSA-SHA" + a), p = (v.update(c), v.sign({
      key: l,
      padding: crypto$1.constants.RSA_PKCS1_PSS_PADDING,
      saltLength: crypto$1.constants.RSA_PSS_SALTLEN_DIGEST
    }, "base64"));
    return fromBase64(p);
  };
}
function createPSSKeyVerifier(a) {
  return function(c, l, v) {
    checkIsPublicKey(v), c = normalizeInput(c), l = toBase64(l);
    var p = crypto$1.createVerify("RSA-SHA" + a);
    return p.update(c), p.verify({
      key: v,
      padding: crypto$1.constants.RSA_PKCS1_PSS_PADDING,
      saltLength: crypto$1.constants.RSA_PSS_SALTLEN_DIGEST
    }, l, "base64");
  };
}
function createECDSASigner(a) {
  var u = createKeySigner(a);
  return function() {
    var l = u.apply(null, arguments);
    return l = formatEcdsa.derToJose(l, "ES" + a), l;
  };
}
function createECDSAVerifer(a) {
  var u = createKeyVerifier(a);
  return function(l, v, p) {
    v = formatEcdsa.joseToDer(v, "ES" + a).toString("base64");
    var _ = u(l, v, p);
    return _;
  };
}
function createNoneSigner() {
  return function() {
    return "";
  };
}
function createNoneVerifier() {
  return function(u, c) {
    return c === "";
  };
}
var jwa$2 = function a(u) {
  var c = {
    hs: createHmacSigner,
    rs: createKeySigner,
    ps: createPSSKeySigner,
    es: createECDSASigner,
    none: createNoneSigner
  }, l = {
    hs: createHmacVerifier,
    rs: createKeyVerifier,
    ps: createPSSKeyVerifier,
    es: createECDSAVerifer,
    none: createNoneVerifier
  }, v = u.match(/^(RS|PS|ES|HS)(256|384|512)$|^(none)$/i);
  if (!v)
    throw typeError(MSG_INVALID_ALGORITHM, u);
  var p = (v[1] || v[3]).toLowerCase(), _ = v[2];
  return {
    sign: c[p](_),
    verify: l[p](_)
  };
}, Buffer$2 = require$$0$2.Buffer, tostring = function a(u) {
  return typeof u == "string" ? u : typeof u == "number" || Buffer$2.isBuffer(u) ? u.toString() : JSON.stringify(u);
}, Buffer$1 = safeBufferExports$3.Buffer, DataStream$1 = dataStream, jwa$1 = jwa$2, Stream$1 = streamBrowserify, toString$2 = tostring, util$1 = util$4;
function base64url(a, u) {
  return Buffer$1.from(a, u).toString("base64").replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function jwsSecuredInput(a, u, c) {
  c = c || "utf8";
  var l = base64url(toString$2(a), "binary"), v = base64url(toString$2(u), c);
  return util$1.format("%s.%s", l, v);
}
function jwsSign(a) {
  var u = a.header, c = a.payload, l = a.secret || a.privateKey, v = a.encoding, p = jwa$1(u.alg), _ = jwsSecuredInput(u, c, v), k = p.sign(_, l);
  return util$1.format("%s.%s", _, k);
}
function SignStream$1(a) {
  var u = a.secret || a.privateKey || a.key, c = new DataStream$1(u);
  this.readable = !0, this.header = a.header, this.encoding = a.encoding, this.secret = this.privateKey = this.key = c, this.payload = new DataStream$1(a.payload), this.secret.once("close", (function() {
    !this.payload.writable && this.readable && this.sign();
  }).bind(this)), this.payload.once("close", (function() {
    !this.secret.writable && this.readable && this.sign();
  }).bind(this));
}
util$1.inherits(SignStream$1, Stream$1);
SignStream$1.prototype.sign = function a() {
  try {
    var u = jwsSign({
      header: this.header,
      payload: this.payload.buffer,
      secret: this.secret.buffer,
      encoding: this.encoding
    });
    return this.emit("done", u), this.emit("data", u), this.emit("end"), this.readable = !1, u;
  } catch (c) {
    this.readable = !1, this.emit("error", c), this.emit("close");
  }
};
SignStream$1.sign = jwsSign;
var signStream = SignStream$1, Buffer = safeBufferExports$3.Buffer, DataStream = dataStream, jwa = jwa$2, Stream = streamBrowserify, toString$1 = tostring, util = util$4, JWS_REGEX = /^[a-zA-Z0-9\-_]+?\.[a-zA-Z0-9\-_]+?\.([a-zA-Z0-9\-_]+)?$/;
function isObject$6(a) {
  return Object.prototype.toString.call(a) === "[object Object]";
}
function safeJsonParse(a) {
  if (isObject$6(a))
    return a;
  try {
    return JSON.parse(a);
  } catch {
    return;
  }
}
function headerFromJWS(a) {
  var u = a.split(".", 1)[0];
  return safeJsonParse(Buffer.from(u, "base64").toString("binary"));
}
function securedInputFromJWS(a) {
  return a.split(".", 2).join(".");
}
function signatureFromJWS(a) {
  return a.split(".")[2];
}
function payloadFromJWS(a, u) {
  u = u || "utf8";
  var c = a.split(".")[1];
  return Buffer.from(c, "base64").toString(u);
}
function isValidJws(a) {
  return JWS_REGEX.test(a) && !!headerFromJWS(a);
}
function jwsVerify(a, u, c) {
  if (!u) {
    var l = new Error("Missing algorithm parameter for jws.verify");
    throw l.code = "MISSING_ALGORITHM", l;
  }
  a = toString$1(a);
  var v = signatureFromJWS(a), p = securedInputFromJWS(a), _ = jwa(u);
  return _.verify(p, v, c);
}
function jwsDecode(a, u) {
  if (u = u || {}, a = toString$1(a), !isValidJws(a))
    return null;
  var c = headerFromJWS(a);
  if (!c)
    return null;
  var l = payloadFromJWS(a);
  return (c.typ === "JWT" || u.json) && (l = JSON.parse(l, u.encoding)), {
    header: c,
    payload: l,
    signature: signatureFromJWS(a)
  };
}
function VerifyStream$1(a) {
  a = a || {};
  var u = a.secret || a.publicKey || a.key, c = new DataStream(u);
  this.readable = !0, this.algorithm = a.algorithm, this.encoding = a.encoding, this.secret = this.publicKey = this.key = c, this.signature = new DataStream(a.signature), this.secret.once("close", (function() {
    !this.signature.writable && this.readable && this.verify();
  }).bind(this)), this.signature.once("close", (function() {
    !this.secret.writable && this.readable && this.verify();
  }).bind(this));
}
util.inherits(VerifyStream$1, Stream);
VerifyStream$1.prototype.verify = function a() {
  try {
    var u = jwsVerify(this.signature.buffer, this.algorithm, this.key.buffer), c = jwsDecode(this.signature.buffer, this.encoding);
    return this.emit("done", u, c), this.emit("data", u), this.emit("end"), this.readable = !1, u;
  } catch (l) {
    this.readable = !1, this.emit("error", l), this.emit("close");
  }
};
VerifyStream$1.decode = jwsDecode;
VerifyStream$1.isValid = isValidJws;
VerifyStream$1.verify = jwsVerify;
var verifyStream = VerifyStream$1, SignStream = signStream, VerifyStream = verifyStream, ALGORITHMS = [
  "HS256",
  "HS384",
  "HS512",
  "RS256",
  "RS384",
  "RS512",
  "PS256",
  "PS384",
  "PS512",
  "ES256",
  "ES384",
  "ES512"
];
jws$3.ALGORITHMS = ALGORITHMS;
jws$3.sign = SignStream.sign;
jws$3.verify = VerifyStream.verify;
jws$3.decode = VerifyStream.decode;
jws$3.isValid = VerifyStream.isValid;
jws$3.createSign = function a(u) {
  return new SignStream(u);
};
jws$3.createVerify = function a(u) {
  return new VerifyStream(u);
};
var jws$2 = jws$3, decode$1 = function(a, u) {
  u = u || {};
  var c = jws$2.decode(a, u);
  if (!c)
    return null;
  var l = c.payload;
  if (typeof l == "string")
    try {
      var v = JSON.parse(l);
      v !== null && typeof v == "object" && (l = v);
    } catch {
    }
  return u.complete === !0 ? {
    header: c.header,
    payload: l,
    signature: c.signature
  } : l;
}, JsonWebTokenError$3 = function(a, u) {
  Error.call(this, a), Error.captureStackTrace && Error.captureStackTrace(this, this.constructor), this.name = "JsonWebTokenError", this.message = a, u && (this.inner = u);
};
JsonWebTokenError$3.prototype = Object.create(Error.prototype);
JsonWebTokenError$3.prototype.constructor = JsonWebTokenError$3;
var JsonWebTokenError_1 = JsonWebTokenError$3, JsonWebTokenError$2 = JsonWebTokenError_1, NotBeforeError$1 = function(a, u) {
  JsonWebTokenError$2.call(this, a), this.name = "NotBeforeError", this.date = u;
};
NotBeforeError$1.prototype = Object.create(JsonWebTokenError$2.prototype);
NotBeforeError$1.prototype.constructor = NotBeforeError$1;
var NotBeforeError_1 = NotBeforeError$1, JsonWebTokenError$1 = JsonWebTokenError_1, TokenExpiredError$1 = function(a, u) {
  JsonWebTokenError$1.call(this, a), this.name = "TokenExpiredError", this.expiredAt = u;
};
TokenExpiredError$1.prototype = Object.create(JsonWebTokenError$1.prototype);
TokenExpiredError$1.prototype.constructor = TokenExpiredError$1;
var TokenExpiredError_1 = TokenExpiredError$1, s = 1e3, m$1 = s * 60, h = m$1 * 60, d = h * 24, w = d * 7, y = d * 365.25, ms$1 = function(a, u) {
  u = u || {};
  var c = typeof a;
  if (c === "string" && a.length > 0)
    return parse$1(a);
  if (c === "number" && isFinite(a))
    return u.long ? fmtLong(a) : fmtShort(a);
  throw new Error(
    "val is not a non-empty string or a valid number. val=" + JSON.stringify(a)
  );
};
function parse$1(a) {
  if (a = String(a), !(a.length > 100)) {
    var u = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      a
    );
    if (u) {
      var c = parseFloat(u[1]), l = (u[2] || "ms").toLowerCase();
      switch (l) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return c * y;
        case "weeks":
        case "week":
        case "w":
          return c * w;
        case "days":
        case "day":
        case "d":
          return c * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return c * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return c * m$1;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return c * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return c;
        default:
          return;
      }
    }
  }
}
function fmtShort(a) {
  var u = Math.abs(a);
  return u >= d ? Math.round(a / d) + "d" : u >= h ? Math.round(a / h) + "h" : u >= m$1 ? Math.round(a / m$1) + "m" : u >= s ? Math.round(a / s) + "s" : a + "ms";
}
function fmtLong(a) {
  var u = Math.abs(a);
  return u >= d ? plural(a, u, d, "day") : u >= h ? plural(a, u, h, "hour") : u >= m$1 ? plural(a, u, m$1, "minute") : u >= s ? plural(a, u, s, "second") : a + " ms";
}
function plural(a, u, c, l) {
  var v = u >= c * 1.5;
  return Math.round(a / c) + " " + l + (v ? "s" : "");
}
var ms = ms$1, timespan$2 = function(a, u) {
  var c = u || Math.floor(Date.now() / 1e3);
  if (typeof a == "string") {
    var l = ms(a);
    return typeof l > "u" ? void 0 : Math.floor(c + l / 1e3);
  } else
    return typeof a == "number" ? c + a : void 0;
}, semver$1 = { exports: {} };
(function(a, u) {
  u = a.exports = Fe;
  var c;
  typeof process$1 == "object" && process$1.env && process$1.env.NODE_DEBUG && /\bsemver\b/i.test(process$1.env.NODE_DEBUG) ? c = function() {
    var Ve = Array.prototype.slice.call(arguments, 0);
    Ve.unshift("SEMVER"), console.log.apply(console, Ve);
  } : c = function() {
  }, u.SEMVER_SPEC_VERSION = "2.0.0";
  var l = 256, v = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
  9007199254740991, p = 16, _ = u.re = [], k = u.src = [], O = 0, D = O++;
  k[D] = "0|[1-9]\\d*";
  var F = O++;
  k[F] = "[0-9]+";
  var z = O++;
  k[z] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
  var j = O++;
  k[j] = "(" + k[D] + ")\\.(" + k[D] + ")\\.(" + k[D] + ")";
  var ee = O++;
  k[ee] = "(" + k[F] + ")\\.(" + k[F] + ")\\.(" + k[F] + ")";
  var X = O++;
  k[X] = "(?:" + k[D] + "|" + k[z] + ")";
  var ae = O++;
  k[ae] = "(?:" + k[F] + "|" + k[z] + ")";
  var Q = O++;
  k[Q] = "(?:-(" + k[X] + "(?:\\." + k[X] + ")*))";
  var ne = O++;
  k[ne] = "(?:-?(" + k[ae] + "(?:\\." + k[ae] + ")*))";
  var Z = O++;
  k[Z] = "[0-9A-Za-z-]+";
  var de = O++;
  k[de] = "(?:\\+(" + k[Z] + "(?:\\." + k[Z] + ")*))";
  var fe = O++, Te = "v?" + k[j] + k[Q] + "?" + k[de] + "?";
  k[fe] = "^" + Te + "$";
  var Re = "[v=\\s]*" + k[ee] + k[ne] + "?" + k[de] + "?", Le = O++;
  k[Le] = "^" + Re + "$";
  var be = O++;
  k[be] = "((?:<|>)?=?)";
  var q = O++;
  k[q] = k[F] + "|x|X|\\*";
  var J = O++;
  k[J] = k[D] + "|x|X|\\*";
  var C = O++;
  k[C] = "[v=\\s]*(" + k[J] + ")(?:\\.(" + k[J] + ")(?:\\.(" + k[J] + ")(?:" + k[Q] + ")?" + k[de] + "?)?)?";
  var S = O++;
  k[S] = "[v=\\s]*(" + k[q] + ")(?:\\.(" + k[q] + ")(?:\\.(" + k[q] + ")(?:" + k[ne] + ")?" + k[de] + "?)?)?";
  var E = O++;
  k[E] = "^" + k[be] + "\\s*" + k[C] + "$";
  var I = O++;
  k[I] = "^" + k[be] + "\\s*" + k[S] + "$";
  var M = O++;
  k[M] = "(?:^|[^\\d])(\\d{1," + p + "})(?:\\.(\\d{1," + p + "}))?(?:\\.(\\d{1," + p + "}))?(?:$|[^\\d])";
  var $ = O++;
  k[$] = "(?:~>?)";
  var U = O++;
  k[U] = "(\\s*)" + k[$] + "\\s+", _[U] = new RegExp(k[U], "g");
  var Y = "$1~", L = O++;
  k[L] = "^" + k[$] + k[C] + "$";
  var T = O++;
  k[T] = "^" + k[$] + k[S] + "$";
  var B = O++;
  k[B] = "(?:\\^)";
  var te = O++;
  k[te] = "(\\s*)" + k[B] + "\\s+", _[te] = new RegExp(k[te], "g");
  var pe = "$1^", Ie = O++;
  k[Ie] = "^" + k[B] + k[C] + "$";
  var $e = O++;
  k[$e] = "^" + k[B] + k[S] + "$";
  var ve = O++;
  k[ve] = "^" + k[be] + "\\s*(" + Re + ")$|^$";
  var he = O++;
  k[he] = "^" + k[be] + "\\s*(" + Te + ")$|^$";
  var Oe = O++;
  k[Oe] = "(\\s*)" + k[be] + "\\s*(" + Re + "|" + k[C] + ")", _[Oe] = new RegExp(k[Oe], "g");
  var Ae = "$1$2$3", Ue = O++;
  k[Ue] = "^\\s*(" + k[C] + ")\\s+-\\s+(" + k[C] + ")\\s*$";
  var oe = O++;
  k[oe] = "^\\s*(" + k[S] + ")\\s+-\\s+(" + k[S] + ")\\s*$";
  var A = O++;
  k[A] = "(<|>)?=?\\s*\\*";
  for (var re = 0; re < O; re++)
    c(re, k[re]), _[re] || (_[re] = new RegExp(k[re]));
  u.parse = le;
  function le(Ve, He) {
    if ((!He || typeof He != "object") && (He = {
      loose: !!He,
      includePrerelease: !1
    }), Ve instanceof Fe)
      return Ve;
    if (typeof Ve != "string" || Ve.length > l)
      return null;
    var Qe = He.loose ? _[Le] : _[fe];
    if (!Qe.test(Ve))
      return null;
    try {
      return new Fe(Ve, He);
    } catch {
      return null;
    }
  }
  u.valid = Ne;
  function Ne(Ve, He) {
    var Qe = le(Ve, He);
    return Qe ? Qe.version : null;
  }
  u.clean = Pe;
  function Pe(Ve, He) {
    var Qe = le(Ve.trim().replace(/^[=v]+/, ""), He);
    return Qe ? Qe.version : null;
  }
  u.SemVer = Fe;
  function Fe(Ve, He) {
    if ((!He || typeof He != "object") && (He = {
      loose: !!He,
      includePrerelease: !1
    }), Ve instanceof Fe) {
      if (Ve.loose === He.loose)
        return Ve;
      Ve = Ve.version;
    } else if (typeof Ve != "string")
      throw new TypeError("Invalid Version: " + Ve);
    if (Ve.length > l)
      throw new TypeError("version is longer than " + l + " characters");
    if (!(this instanceof Fe))
      return new Fe(Ve, He);
    c("SemVer", Ve, He), this.options = He, this.loose = !!He.loose;
    var Qe = Ve.trim().match(He.loose ? _[Le] : _[fe]);
    if (!Qe)
      throw new TypeError("Invalid Version: " + Ve);
    if (this.raw = Ve, this.major = +Qe[1], this.minor = +Qe[2], this.patch = +Qe[3], this.major > v || this.major < 0)
      throw new TypeError("Invalid major version");
    if (this.minor > v || this.minor < 0)
      throw new TypeError("Invalid minor version");
    if (this.patch > v || this.patch < 0)
      throw new TypeError("Invalid patch version");
    Qe[4] ? this.prerelease = Qe[4].split(".").map(function(pt) {
      if (/^[0-9]+$/.test(pt)) {
        var mt = +pt;
        if (mt >= 0 && mt < v)
          return mt;
      }
      return pt;
    }) : this.prerelease = [], this.build = Qe[5] ? Qe[5].split(".") : [], this.format();
  }
  Fe.prototype.format = function() {
    return this.version = this.major + "." + this.minor + "." + this.patch, this.prerelease.length && (this.version += "-" + this.prerelease.join(".")), this.version;
  }, Fe.prototype.toString = function() {
    return this.version;
  }, Fe.prototype.compare = function(Ve) {
    return c("SemVer.compare", this.version, this.options, Ve), Ve instanceof Fe || (Ve = new Fe(Ve, this.options)), this.compareMain(Ve) || this.comparePre(Ve);
  }, Fe.prototype.compareMain = function(Ve) {
    return Ve instanceof Fe || (Ve = new Fe(Ve, this.options)), Xe(this.major, Ve.major) || Xe(this.minor, Ve.minor) || Xe(this.patch, Ve.patch);
  }, Fe.prototype.comparePre = function(Ve) {
    if (Ve instanceof Fe || (Ve = new Fe(Ve, this.options)), this.prerelease.length && !Ve.prerelease.length)
      return -1;
    if (!this.prerelease.length && Ve.prerelease.length)
      return 1;
    if (!this.prerelease.length && !Ve.prerelease.length)
      return 0;
    var He = 0;
    do {
      var Qe = this.prerelease[He], pt = Ve.prerelease[He];
      if (c("prerelease compare", He, Qe, pt), Qe === void 0 && pt === void 0)
        return 0;
      if (pt === void 0)
        return 1;
      if (Qe === void 0)
        return -1;
      if (Qe === pt)
        continue;
      return Xe(Qe, pt);
    } while (++He);
  }, Fe.prototype.inc = function(Ve, He) {
    switch (Ve) {
      case "premajor":
        this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", He);
        break;
      case "preminor":
        this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", He);
        break;
      case "prepatch":
        this.prerelease.length = 0, this.inc("patch", He), this.inc("pre", He);
        break;
      case "prerelease":
        this.prerelease.length === 0 && this.inc("patch", He), this.inc("pre", He);
        break;
      case "major":
        (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
        break;
      case "minor":
        (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
        break;
      case "patch":
        this.prerelease.length === 0 && this.patch++, this.prerelease = [];
        break;
      case "pre":
        if (this.prerelease.length === 0)
          this.prerelease = [0];
        else {
          for (var Qe = this.prerelease.length; --Qe >= 0; )
            typeof this.prerelease[Qe] == "number" && (this.prerelease[Qe]++, Qe = -2);
          Qe === -1 && this.prerelease.push(0);
        }
        He && (this.prerelease[0] === He ? isNaN(this.prerelease[1]) && (this.prerelease = [He, 0]) : this.prerelease = [He, 0]);
        break;
      default:
        throw new Error("invalid increment argument: " + Ve);
    }
    return this.format(), this.raw = this.version, this;
  }, u.inc = je;
  function je(Ve, He, Qe, pt) {
    typeof Qe == "string" && (pt = Qe, Qe = void 0);
    try {
      return new Fe(Ve, Qe).inc(He, pt).version;
    } catch {
      return null;
    }
  }
  u.diff = qe;
  function qe(Ve, He) {
    if (Ce(Ve, He))
      return null;
    var Qe = le(Ve), pt = le(He), mt = "";
    if (Qe.prerelease.length || pt.prerelease.length) {
      mt = "pre";
      var vt = "prerelease";
    }
    for (var ht in Qe)
      if ((ht === "major" || ht === "minor" || ht === "patch") && Qe[ht] !== pt[ht])
        return mt + ht;
    return vt;
  }
  u.compareIdentifiers = Xe;
  var yt = /^[0-9]+$/;
  function Xe(Ve, He) {
    var Qe = yt.test(Ve), pt = yt.test(He);
    return Qe && pt && (Ve = +Ve, He = +He), Ve === He ? 0 : Qe && !pt ? -1 : pt && !Qe ? 1 : Ve < He ? -1 : 1;
  }
  u.rcompareIdentifiers = Ge;
  function Ge(Ve, He) {
    return Xe(He, Ve);
  }
  u.major = H;
  function H(Ve, He) {
    return new Fe(Ve, He).major;
  }
  u.minor = ye;
  function ye(Ve, He) {
    return new Fe(Ve, He).minor;
  }
  u.patch = Ee;
  function Ee(Ve, He) {
    return new Fe(Ve, He).patch;
  }
  u.compare = We;
  function We(Ve, He, Qe) {
    return new Fe(Ve, Qe).compare(new Fe(He, Qe));
  }
  u.compareLoose = we;
  function we(Ve, He) {
    return We(Ve, He, !0);
  }
  u.rcompare = V;
  function V(Ve, He, Qe) {
    return We(He, Ve, Qe);
  }
  u.sort = _e;
  function _e(Ve, He) {
    return Ve.sort(function(Qe, pt) {
      return u.compare(Qe, pt, He);
    });
  }
  u.rsort = ue;
  function ue(Ve, He) {
    return Ve.sort(function(Qe, pt) {
      return u.rcompare(Qe, pt, He);
    });
  }
  u.gt = ce;
  function ce(Ve, He, Qe) {
    return We(Ve, He, Qe) > 0;
  }
  u.lt = me;
  function me(Ve, He, Qe) {
    return We(Ve, He, Qe) < 0;
  }
  u.eq = Ce;
  function Ce(Ve, He, Qe) {
    return We(Ve, He, Qe) === 0;
  }
  u.neq = Be;
  function Be(Ve, He, Qe) {
    return We(Ve, He, Qe) !== 0;
  }
  u.gte = ze;
  function ze(Ve, He, Qe) {
    return We(Ve, He, Qe) >= 0;
  }
  u.lte = Je;
  function Je(Ve, He, Qe) {
    return We(Ve, He, Qe) <= 0;
  }
  u.cmp = Ze;
  function Ze(Ve, He, Qe, pt) {
    switch (He) {
      case "===":
        return typeof Ve == "object" && (Ve = Ve.version), typeof Qe == "object" && (Qe = Qe.version), Ve === Qe;
      case "!==":
        return typeof Ve == "object" && (Ve = Ve.version), typeof Qe == "object" && (Qe = Qe.version), Ve !== Qe;
      case "":
      case "=":
      case "==":
        return Ce(Ve, Qe, pt);
      case "!=":
        return Be(Ve, Qe, pt);
      case ">":
        return ce(Ve, Qe, pt);
      case ">=":
        return ze(Ve, Qe, pt);
      case "<":
        return me(Ve, Qe, pt);
      case "<=":
        return Je(Ve, Qe, pt);
      default:
        throw new TypeError("Invalid operator: " + He);
    }
  }
  u.Comparator = Ke;
  function Ke(Ve, He) {
    if ((!He || typeof He != "object") && (He = {
      loose: !!He,
      includePrerelease: !1
    }), Ve instanceof Ke) {
      if (Ve.loose === !!He.loose)
        return Ve;
      Ve = Ve.value;
    }
    if (!(this instanceof Ke))
      return new Ke(Ve, He);
    c("comparator", Ve, He), this.options = He, this.loose = !!He.loose, this.parse(Ve), this.semver === x ? this.value = "" : this.value = this.operator + this.semver.version, c("comp", this);
  }
  var x = {};
  Ke.prototype.parse = function(Ve) {
    var He = this.options.loose ? _[ve] : _[he], Qe = Ve.match(He);
    if (!Qe)
      throw new TypeError("Invalid comparator: " + Ve);
    this.operator = Qe[1], this.operator === "=" && (this.operator = ""), Qe[2] ? this.semver = new Fe(Qe[2], this.options.loose) : this.semver = x;
  }, Ke.prototype.toString = function() {
    return this.value;
  }, Ke.prototype.test = function(Ve) {
    return c("Comparator.test", Ve, this.options.loose), this.semver === x ? !0 : (typeof Ve == "string" && (Ve = new Fe(Ve, this.options)), Ze(Ve, this.operator, this.semver, this.options));
  }, Ke.prototype.intersects = function(Ve, He) {
    if (!(Ve instanceof Ke))
      throw new TypeError("a Comparator is required");
    (!He || typeof He != "object") && (He = {
      loose: !!He,
      includePrerelease: !1
    });
    var Qe;
    if (this.operator === "")
      return Qe = new se(Ve.value, He), wt(this.value, Qe, He);
    if (Ve.operator === "")
      return Qe = new se(this.value, He), wt(Ve.semver, Qe, He);
    var pt = (this.operator === ">=" || this.operator === ">") && (Ve.operator === ">=" || Ve.operator === ">"), mt = (this.operator === "<=" || this.operator === "<") && (Ve.operator === "<=" || Ve.operator === "<"), vt = this.semver.version === Ve.semver.version, ht = (this.operator === ">=" || this.operator === "<=") && (Ve.operator === ">=" || Ve.operator === "<="), Et = Ze(this.semver, "<", Ve.semver, He) && (this.operator === ">=" || this.operator === ">") && (Ve.operator === "<=" || Ve.operator === "<"), Tt = Ze(this.semver, ">", Ve.semver, He) && (this.operator === "<=" || this.operator === "<") && (Ve.operator === ">=" || Ve.operator === ">");
    return pt || mt || vt && ht || Et || Tt;
  }, u.Range = se;
  function se(Ve, He) {
    if ((!He || typeof He != "object") && (He = {
      loose: !!He,
      includePrerelease: !1
    }), Ve instanceof se)
      return Ve.loose === !!He.loose && Ve.includePrerelease === !!He.includePrerelease ? Ve : new se(Ve.raw, He);
    if (Ve instanceof Ke)
      return new se(Ve.value, He);
    if (!(this instanceof se))
      return new se(Ve, He);
    if (this.options = He, this.loose = !!He.loose, this.includePrerelease = !!He.includePrerelease, this.raw = Ve, this.set = Ve.split(/\s*\|\|\s*/).map(function(Qe) {
      return this.parseRange(Qe.trim());
    }, this).filter(function(Qe) {
      return Qe.length;
    }), !this.set.length)
      throw new TypeError("Invalid SemVer Range: " + Ve);
    this.format();
  }
  se.prototype.format = function() {
    return this.range = this.set.map(function(Ve) {
      return Ve.join(" ").trim();
    }).join("||").trim(), this.range;
  }, se.prototype.toString = function() {
    return this.range;
  }, se.prototype.parseRange = function(Ve) {
    var He = this.options.loose;
    Ve = Ve.trim();
    var Qe = He ? _[oe] : _[Ue];
    Ve = Ve.replace(Qe, rt), c("hyphen replace", Ve), Ve = Ve.replace(_[Oe], Ae), c("comparator trim", Ve, _[Oe]), Ve = Ve.replace(_[U], Y), Ve = Ve.replace(_[te], pe), Ve = Ve.split(/\s+/).join(" ");
    var pt = He ? _[ve] : _[he], mt = Ve.split(" ").map(function(vt) {
      return xe(vt, this.options);
    }, this).join(" ").split(/\s+/);
    return this.options.loose && (mt = mt.filter(function(vt) {
      return !!vt.match(pt);
    })), mt = mt.map(function(vt) {
      return new Ke(vt, this.options);
    }, this), mt;
  }, se.prototype.intersects = function(Ve, He) {
    if (!(Ve instanceof se))
      throw new TypeError("a Range is required");
    return this.set.some(function(Qe) {
      return Qe.every(function(pt) {
        return Ve.set.some(function(mt) {
          return mt.every(function(vt) {
            return pt.intersects(vt, He);
          });
        });
      });
    });
  }, u.toComparators = ge;
  function ge(Ve, He) {
    return new se(Ve, He).set.map(function(Qe) {
      return Qe.map(function(pt) {
        return pt.value;
      }).join(" ").trim().split(" ");
    });
  }
  function xe(Ve, He) {
    return c("comp", Ve, He), Ve = dt(Ve, He), c("caret", Ve), Ve = Ye(Ve, He), c("tildes", Ve), Ve = tt(Ve, He), c("xrange", Ve), Ve = kt(Ve, He), c("stars", Ve), Ve;
  }
  function Me(Ve) {
    return !Ve || Ve.toLowerCase() === "x" || Ve === "*";
  }
  function Ye(Ve, He) {
    return Ve.trim().split(/\s+/).map(function(Qe) {
      return et(Qe, He);
    }).join(" ");
  }
  function et(Ve, He) {
    var Qe = He.loose ? _[T] : _[L];
    return Ve.replace(Qe, function(pt, mt, vt, ht, Et) {
      c("tilde", Ve, pt, mt, vt, ht, Et);
      var Tt;
      return Me(mt) ? Tt = "" : Me(vt) ? Tt = ">=" + mt + ".0.0 <" + (+mt + 1) + ".0.0" : Me(ht) ? Tt = ">=" + mt + "." + vt + ".0 <" + mt + "." + (+vt + 1) + ".0" : Et ? (c("replaceTilde pr", Et), Tt = ">=" + mt + "." + vt + "." + ht + "-" + Et + " <" + mt + "." + (+vt + 1) + ".0") : Tt = ">=" + mt + "." + vt + "." + ht + " <" + mt + "." + (+vt + 1) + ".0", c("tilde return", Tt), Tt;
    });
  }
  function dt(Ve, He) {
    return Ve.trim().split(/\s+/).map(function(Qe) {
      return St(Qe, He);
    }).join(" ");
  }
  function St(Ve, He) {
    c("caret", Ve, He);
    var Qe = He.loose ? _[$e] : _[Ie];
    return Ve.replace(Qe, function(pt, mt, vt, ht, Et) {
      c("caret", Ve, pt, mt, vt, ht, Et);
      var Tt;
      return Me(mt) ? Tt = "" : Me(vt) ? Tt = ">=" + mt + ".0.0 <" + (+mt + 1) + ".0.0" : Me(ht) ? mt === "0" ? Tt = ">=" + mt + "." + vt + ".0 <" + mt + "." + (+vt + 1) + ".0" : Tt = ">=" + mt + "." + vt + ".0 <" + (+mt + 1) + ".0.0" : Et ? (c("replaceCaret pr", Et), mt === "0" ? vt === "0" ? Tt = ">=" + mt + "." + vt + "." + ht + "-" + Et + " <" + mt + "." + vt + "." + (+ht + 1) : Tt = ">=" + mt + "." + vt + "." + ht + "-" + Et + " <" + mt + "." + (+vt + 1) + ".0" : Tt = ">=" + mt + "." + vt + "." + ht + "-" + Et + " <" + (+mt + 1) + ".0.0") : (c("no pr"), mt === "0" ? vt === "0" ? Tt = ">=" + mt + "." + vt + "." + ht + " <" + mt + "." + vt + "." + (+ht + 1) : Tt = ">=" + mt + "." + vt + "." + ht + " <" + mt + "." + (+vt + 1) + ".0" : Tt = ">=" + mt + "." + vt + "." + ht + " <" + (+mt + 1) + ".0.0"), c("caret return", Tt), Tt;
    });
  }
  function tt(Ve, He) {
    return c("replaceXRanges", Ve, He), Ve.split(/\s+/).map(function(Qe) {
      return at(Qe, He);
    }).join(" ");
  }
  function at(Ve, He) {
    Ve = Ve.trim();
    var Qe = He.loose ? _[I] : _[E];
    return Ve.replace(Qe, function(pt, mt, vt, ht, Et, Tt) {
      c("xRange", Ve, pt, mt, vt, ht, Et, Tt);
      var Ot = Me(vt), Nt = Ot || Me(ht), At = Nt || Me(Et), Mt = At;
      return mt === "=" && Mt && (mt = ""), Ot ? mt === ">" || mt === "<" ? pt = "<0.0.0" : pt = "*" : mt && Mt ? (Nt && (ht = 0), Et = 0, mt === ">" ? (mt = ">=", Nt ? (vt = +vt + 1, ht = 0, Et = 0) : (ht = +ht + 1, Et = 0)) : mt === "<=" && (mt = "<", Nt ? vt = +vt + 1 : ht = +ht + 1), pt = mt + vt + "." + ht + "." + Et) : Nt ? pt = ">=" + vt + ".0.0 <" + (+vt + 1) + ".0.0" : At && (pt = ">=" + vt + "." + ht + ".0 <" + vt + "." + (+ht + 1) + ".0"), c("xRange return", pt), pt;
    });
  }
  function kt(Ve, He) {
    return c("replaceStars", Ve, He), Ve.trim().replace(_[A], "");
  }
  function rt(Ve, He, Qe, pt, mt, vt, ht, Et, Tt, Ot, Nt, At, Mt) {
    return Me(Qe) ? He = "" : Me(pt) ? He = ">=" + Qe + ".0.0" : Me(mt) ? He = ">=" + Qe + "." + pt + ".0" : He = ">=" + He, Me(Tt) ? Et = "" : Me(Ot) ? Et = "<" + (+Tt + 1) + ".0.0" : Me(Nt) ? Et = "<" + Tt + "." + (+Ot + 1) + ".0" : At ? Et = "<=" + Tt + "." + Ot + "." + Nt + "-" + At : Et = "<=" + Et, (He + " " + Et).trim();
  }
  se.prototype.test = function(Ve) {
    if (!Ve)
      return !1;
    typeof Ve == "string" && (Ve = new Fe(Ve, this.options));
    for (var He = 0; He < this.set.length; He++)
      if (ut(this.set[He], Ve, this.options))
        return !0;
    return !1;
  };
  function ut(Ve, He, Qe) {
    for (var pt = 0; pt < Ve.length; pt++)
      if (!Ve[pt].test(He))
        return !1;
    if (He.prerelease.length && !Qe.includePrerelease) {
      for (pt = 0; pt < Ve.length; pt++)
        if (c(Ve[pt].semver), Ve[pt].semver !== x && Ve[pt].semver.prerelease.length > 0) {
          var mt = Ve[pt].semver;
          if (mt.major === He.major && mt.minor === He.minor && mt.patch === He.patch)
            return !0;
        }
      return !1;
    }
    return !0;
  }
  u.satisfies = wt;
  function wt(Ve, He, Qe) {
    try {
      He = new se(He, Qe);
    } catch {
      return !1;
    }
    return He.test(Ve);
  }
  u.maxSatisfying = nt;
  function nt(Ve, He, Qe) {
    var pt = null, mt = null;
    try {
      var vt = new se(He, Qe);
    } catch {
      return null;
    }
    return Ve.forEach(function(ht) {
      vt.test(ht) && (!pt || mt.compare(ht) === -1) && (pt = ht, mt = new Fe(pt, Qe));
    }), pt;
  }
  u.minSatisfying = it;
  function it(Ve, He, Qe) {
    var pt = null, mt = null;
    try {
      var vt = new se(He, Qe);
    } catch {
      return null;
    }
    return Ve.forEach(function(ht) {
      vt.test(ht) && (!pt || mt.compare(ht) === 1) && (pt = ht, mt = new Fe(pt, Qe));
    }), pt;
  }
  u.minVersion = bt;
  function bt(Ve, He) {
    Ve = new se(Ve, He);
    var Qe = new Fe("0.0.0");
    if (Ve.test(Qe) || (Qe = new Fe("0.0.0-0"), Ve.test(Qe)))
      return Qe;
    Qe = null;
    for (var pt = 0; pt < Ve.set.length; ++pt) {
      var mt = Ve.set[pt];
      mt.forEach(function(vt) {
        var ht = new Fe(vt.semver.version);
        switch (vt.operator) {
          case ">":
            ht.prerelease.length === 0 ? ht.patch++ : ht.prerelease.push(0), ht.raw = ht.format();
          case "":
          case ">=":
            (!Qe || ce(Qe, ht)) && (Qe = ht);
            break;
          case "<":
          case "<=":
            break;
          default:
            throw new Error("Unexpected operation: " + vt.operator);
        }
      });
    }
    return Qe && Ve.test(Qe) ? Qe : null;
  }
  u.validRange = ot;
  function ot(Ve, He) {
    try {
      return new se(Ve, He).range || "*";
    } catch {
      return null;
    }
  }
  u.ltr = ct;
  function ct(Ve, He, Qe) {
    return st(Ve, He, "<", Qe);
  }
  u.gtr = Pt;
  function Pt(Ve, He, Qe) {
    return st(Ve, He, ">", Qe);
  }
  u.outside = st;
  function st(Ve, He, Qe, pt) {
    Ve = new Fe(Ve, pt), He = new se(He, pt);
    var mt, vt, ht, Et, Tt;
    switch (Qe) {
      case ">":
        mt = ce, vt = Je, ht = me, Et = ">", Tt = ">=";
        break;
      case "<":
        mt = me, vt = ze, ht = ce, Et = "<", Tt = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (wt(Ve, He, pt))
      return !1;
    for (var Ot = 0; Ot < He.set.length; ++Ot) {
      var Nt = He.set[Ot], At = null, Mt = null;
      if (Nt.forEach(function($t) {
        $t.semver === x && ($t = new Ke(">=0.0.0")), At = At || $t, Mt = Mt || $t, mt($t.semver, At.semver, pt) ? At = $t : ht($t.semver, Mt.semver, pt) && (Mt = $t);
      }), At.operator === Et || At.operator === Tt || (!Mt.operator || Mt.operator === Et) && vt(Ve, Mt.semver))
        return !1;
      if (Mt.operator === Tt && ht(Ve, Mt.semver))
        return !1;
    }
    return !0;
  }
  u.prerelease = lt;
  function lt(Ve, He) {
    var Qe = le(Ve, He);
    return Qe && Qe.prerelease.length ? Qe.prerelease : null;
  }
  u.intersects = It;
  function It(Ve, He, Qe) {
    return Ve = new se(Ve, Qe), He = new se(He, Qe), Ve.intersects(He);
  }
  u.coerce = Rt;
  function Rt(Ve) {
    if (Ve instanceof Fe)
      return Ve;
    if (typeof Ve != "string")
      return null;
    var He = Ve.match(_[M]);
    return He == null ? null : le(He[1] + "." + (He[2] || "0") + "." + (He[3] || "0"));
  }
})(semver$1, semver$1.exports);
var semverExports = semver$1.exports, semver = semverExports, psSupported = semver.satisfies(process$1.version, "^6.12.0 || >=8.0.0"), JsonWebTokenError = JsonWebTokenError_1, NotBeforeError = NotBeforeError_1, TokenExpiredError = TokenExpiredError_1, decode = decode$1, timespan$1 = timespan$2, PS_SUPPORTED$1 = psSupported, jws$1 = jws$3, PUB_KEY_ALGS = ["RS256", "RS384", "RS512", "ES256", "ES384", "ES512"], RSA_KEY_ALGS = ["RS256", "RS384", "RS512"], HS_ALGS = ["HS256", "HS384", "HS512"];
PS_SUPPORTED$1 && (PUB_KEY_ALGS.splice(3, 0, "PS256", "PS384", "PS512"), RSA_KEY_ALGS.splice(3, 0, "PS256", "PS384", "PS512"));
var verify = function(a, u, c, l) {
  typeof c == "function" && !l && (l = c, c = {}), c || (c = {}), c = Object.assign({}, c);
  var v;
  if (l ? v = l : v = function(F, z) {
    if (F)
      throw F;
    return z;
  }, c.clockTimestamp && typeof c.clockTimestamp != "number")
    return v(new JsonWebTokenError("clockTimestamp must be a number"));
  if (c.nonce !== void 0 && (typeof c.nonce != "string" || c.nonce.trim() === ""))
    return v(new JsonWebTokenError("nonce must be a non-empty string"));
  var p = c.clockTimestamp || Math.floor(Date.now() / 1e3);
  if (!a)
    return v(new JsonWebTokenError("jwt must be provided"));
  if (typeof a != "string")
    return v(new JsonWebTokenError("jwt must be a string"));
  var _ = a.split(".");
  if (_.length !== 3)
    return v(new JsonWebTokenError("jwt malformed"));
  var k;
  try {
    k = decode(a, { complete: !0 });
  } catch (F) {
    return v(F);
  }
  if (!k)
    return v(new JsonWebTokenError("invalid token"));
  var O = k.header, D;
  if (typeof u == "function") {
    if (!l)
      return v(new JsonWebTokenError("verify must be called asynchronous if secret or public key is provided as a callback"));
    D = u;
  } else
    D = function(F, z) {
      return z(null, u);
    };
  return D(O, function(F, z) {
    if (F)
      return v(new JsonWebTokenError("error in secret or public key callback: " + F.message));
    var j = _[2].trim() !== "";
    if (!j && z)
      return v(new JsonWebTokenError("jwt signature is required"));
    if (j && !z)
      return v(new JsonWebTokenError("secret or public key must be provided"));
    if (!j && !c.algorithms && (c.algorithms = ["none"]), c.algorithms || (c.algorithms = ~z.toString().indexOf("BEGIN CERTIFICATE") || ~z.toString().indexOf("BEGIN PUBLIC KEY") ? PUB_KEY_ALGS : ~z.toString().indexOf("BEGIN RSA PUBLIC KEY") ? RSA_KEY_ALGS : HS_ALGS), !~c.algorithms.indexOf(k.header.alg))
      return v(new JsonWebTokenError("invalid algorithm"));
    var ee;
    try {
      ee = jws$1.verify(a, k.header.alg, z);
    } catch (Te) {
      return v(Te);
    }
    if (!ee)
      return v(new JsonWebTokenError("invalid signature"));
    var X = k.payload;
    if (typeof X.nbf < "u" && !c.ignoreNotBefore) {
      if (typeof X.nbf != "number")
        return v(new JsonWebTokenError("invalid nbf value"));
      if (X.nbf > p + (c.clockTolerance || 0))
        return v(new NotBeforeError("jwt not active", new Date(X.nbf * 1e3)));
    }
    if (typeof X.exp < "u" && !c.ignoreExpiration) {
      if (typeof X.exp != "number")
        return v(new JsonWebTokenError("invalid exp value"));
      if (p >= X.exp + (c.clockTolerance || 0))
        return v(new TokenExpiredError("jwt expired", new Date(X.exp * 1e3)));
    }
    if (c.audience) {
      var ae = Array.isArray(c.audience) ? c.audience : [c.audience], Q = Array.isArray(X.aud) ? X.aud : [X.aud], ne = Q.some(function(Te) {
        return ae.some(function(Re) {
          return Re instanceof RegExp ? Re.test(Te) : Re === Te;
        });
      });
      if (!ne)
        return v(new JsonWebTokenError("jwt audience invalid. expected: " + ae.join(" or ")));
    }
    if (c.issuer) {
      var Z = typeof c.issuer == "string" && X.iss !== c.issuer || Array.isArray(c.issuer) && c.issuer.indexOf(X.iss) === -1;
      if (Z)
        return v(new JsonWebTokenError("jwt issuer invalid. expected: " + c.issuer));
    }
    if (c.subject && X.sub !== c.subject)
      return v(new JsonWebTokenError("jwt subject invalid. expected: " + c.subject));
    if (c.jwtid && X.jti !== c.jwtid)
      return v(new JsonWebTokenError("jwt jwtid invalid. expected: " + c.jwtid));
    if (c.nonce && X.nonce !== c.nonce)
      return v(new JsonWebTokenError("jwt nonce invalid. expected: " + c.nonce));
    if (c.maxAge) {
      if (typeof X.iat != "number")
        return v(new JsonWebTokenError("iat required when maxAge is specified"));
      var de = timespan$1(c.maxAge, X.iat);
      if (typeof de > "u")
        return v(new JsonWebTokenError('"maxAge" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
      if (p >= de + (c.clockTolerance || 0))
        return v(new TokenExpiredError("maxAge exceeded", new Date(de * 1e3)));
    }
    if (c.complete === !0) {
      var fe = k.signature;
      return v(null, {
        header: O,
        payload: X,
        signature: fe
      });
    }
    return v(null, X);
  });
}, INFINITY$2 = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER$2 = 17976931348623157e292, NAN$2 = NaN, argsTag = "[object Arguments]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", stringTag$1 = "[object String]", symbolTag$2 = "[object Symbol]", reTrim$2 = /^\s+|\s+$/g, reIsBadHex$2 = /^[-+]0x[0-9a-f]+$/i, reIsBinary$2 = /^0b[01]+$/i, reIsOctal$2 = /^0o[0-7]+$/i, reIsUint = /^(?:0|[1-9]\d*)$/, freeParseInt$2 = parseInt;
function arrayMap(a, u) {
  for (var c = -1, l = a ? a.length : 0, v = Array(l); ++c < l; )
    v[c] = u(a[c], c, a);
  return v;
}
function baseFindIndex(a, u, c, l) {
  for (var v = a.length, p = c + (l ? 1 : -1); l ? p-- : ++p < v; )
    if (u(a[p], p, a))
      return p;
  return -1;
}
function baseIndexOf(a, u, c) {
  if (u !== u)
    return baseFindIndex(a, baseIsNaN, c);
  for (var l = c - 1, v = a.length; ++l < v; )
    if (a[l] === u)
      return l;
  return -1;
}
function baseIsNaN(a) {
  return a !== a;
}
function baseTimes(a, u) {
  for (var c = -1, l = Array(a); ++c < a; )
    l[c] = u(c);
  return l;
}
function baseValues(a, u) {
  return arrayMap(u, function(c) {
    return a[c];
  });
}
function overArg$1(a, u) {
  return function(c) {
    return a(u(c));
  };
}
var objectProto$6 = Object.prototype, hasOwnProperty$1 = objectProto$6.hasOwnProperty, objectToString$6 = objectProto$6.toString, propertyIsEnumerable = objectProto$6.propertyIsEnumerable, nativeKeys = overArg$1(Object.keys, Object), nativeMax = Math.max;
function arrayLikeKeys(a, u) {
  var c = isArray$3(a) || isArguments(a) ? baseTimes(a.length, String) : [], l = c.length, v = !!l;
  for (var p in a)
    (u || hasOwnProperty$1.call(a, p)) && !(v && (p == "length" || isIndex(p, l))) && c.push(p);
  return c;
}
function baseKeys(a) {
  if (!isPrototype(a))
    return nativeKeys(a);
  var u = [];
  for (var c in Object(a))
    hasOwnProperty$1.call(a, c) && c != "constructor" && u.push(c);
  return u;
}
function isIndex(a, u) {
  return u = u ?? MAX_SAFE_INTEGER, !!u && (typeof a == "number" || reIsUint.test(a)) && a > -1 && a % 1 == 0 && a < u;
}
function isPrototype(a) {
  var u = a && a.constructor, c = typeof u == "function" && u.prototype || objectProto$6;
  return a === c;
}
function includes$1(a, u, c, l) {
  a = isArrayLike(a) ? a : values(a), c = c && !l ? toInteger$2(c) : 0;
  var v = a.length;
  return c < 0 && (c = nativeMax(v + c, 0)), isString$3(a) ? c <= v && a.indexOf(u, c) > -1 : !!v && baseIndexOf(a, u, c) > -1;
}
function isArguments(a) {
  return isArrayLikeObject(a) && hasOwnProperty$1.call(a, "callee") && (!propertyIsEnumerable.call(a, "callee") || objectToString$6.call(a) == argsTag);
}
var isArray$3 = Array.isArray;
function isArrayLike(a) {
  return a != null && isLength(a.length) && !isFunction$1(a);
}
function isArrayLikeObject(a) {
  return isObjectLike$6(a) && isArrayLike(a);
}
function isFunction$1(a) {
  var u = isObject$5(a) ? objectToString$6.call(a) : "";
  return u == funcTag || u == genTag;
}
function isLength(a) {
  return typeof a == "number" && a > -1 && a % 1 == 0 && a <= MAX_SAFE_INTEGER;
}
function isObject$5(a) {
  var u = typeof a;
  return !!a && (u == "object" || u == "function");
}
function isObjectLike$6(a) {
  return !!a && typeof a == "object";
}
function isString$3(a) {
  return typeof a == "string" || !isArray$3(a) && isObjectLike$6(a) && objectToString$6.call(a) == stringTag$1;
}
function isSymbol$2(a) {
  return typeof a == "symbol" || isObjectLike$6(a) && objectToString$6.call(a) == symbolTag$2;
}
function toFinite$2(a) {
  if (!a)
    return a === 0 ? a : 0;
  if (a = toNumber$2(a), a === INFINITY$2 || a === -INFINITY$2) {
    var u = a < 0 ? -1 : 1;
    return u * MAX_INTEGER$2;
  }
  return a === a ? a : 0;
}
function toInteger$2(a) {
  var u = toFinite$2(a), c = u % 1;
  return u === u ? c ? u - c : u : 0;
}
function toNumber$2(a) {
  if (typeof a == "number")
    return a;
  if (isSymbol$2(a))
    return NAN$2;
  if (isObject$5(a)) {
    var u = typeof a.valueOf == "function" ? a.valueOf() : a;
    a = isObject$5(u) ? u + "" : u;
  }
  if (typeof a != "string")
    return a === 0 ? a : +a;
  a = a.replace(reTrim$2, "");
  var c = reIsBinary$2.test(a);
  return c || reIsOctal$2.test(a) ? freeParseInt$2(a.slice(2), c ? 2 : 8) : reIsBadHex$2.test(a) ? NAN$2 : +a;
}
function keys$1(a) {
  return isArrayLike(a) ? arrayLikeKeys(a) : baseKeys(a);
}
function values(a) {
  return a ? baseValues(a, keys$1(a)) : [];
}
var lodash_includes = includes$1, boolTag = "[object Boolean]", objectProto$5 = Object.prototype, objectToString$5 = objectProto$5.toString;
function isBoolean$1(a) {
  return a === !0 || a === !1 || isObjectLike$5(a) && objectToString$5.call(a) == boolTag;
}
function isObjectLike$5(a) {
  return !!a && typeof a == "object";
}
var lodash_isboolean = isBoolean$1, INFINITY$1 = 1 / 0, MAX_INTEGER$1 = 17976931348623157e292, NAN$1 = NaN, symbolTag$1 = "[object Symbol]", reTrim$1 = /^\s+|\s+$/g, reIsBadHex$1 = /^[-+]0x[0-9a-f]+$/i, reIsBinary$1 = /^0b[01]+$/i, reIsOctal$1 = /^0o[0-7]+$/i, freeParseInt$1 = parseInt, objectProto$4 = Object.prototype, objectToString$4 = objectProto$4.toString;
function isInteger$1(a) {
  return typeof a == "number" && a == toInteger$1(a);
}
function isObject$4(a) {
  var u = typeof a;
  return !!a && (u == "object" || u == "function");
}
function isObjectLike$4(a) {
  return !!a && typeof a == "object";
}
function isSymbol$1(a) {
  return typeof a == "symbol" || isObjectLike$4(a) && objectToString$4.call(a) == symbolTag$1;
}
function toFinite$1(a) {
  if (!a)
    return a === 0 ? a : 0;
  if (a = toNumber$1(a), a === INFINITY$1 || a === -INFINITY$1) {
    var u = a < 0 ? -1 : 1;
    return u * MAX_INTEGER$1;
  }
  return a === a ? a : 0;
}
function toInteger$1(a) {
  var u = toFinite$1(a), c = u % 1;
  return u === u ? c ? u - c : u : 0;
}
function toNumber$1(a) {
  if (typeof a == "number")
    return a;
  if (isSymbol$1(a))
    return NAN$1;
  if (isObject$4(a)) {
    var u = typeof a.valueOf == "function" ? a.valueOf() : a;
    a = isObject$4(u) ? u + "" : u;
  }
  if (typeof a != "string")
    return a === 0 ? a : +a;
  a = a.replace(reTrim$1, "");
  var c = reIsBinary$1.test(a);
  return c || reIsOctal$1.test(a) ? freeParseInt$1(a.slice(2), c ? 2 : 8) : reIsBadHex$1.test(a) ? NAN$1 : +a;
}
var lodash_isinteger = isInteger$1, numberTag = "[object Number]", objectProto$3 = Object.prototype, objectToString$3 = objectProto$3.toString;
function isObjectLike$3(a) {
  return !!a && typeof a == "object";
}
function isNumber$2(a) {
  return typeof a == "number" || isObjectLike$3(a) && objectToString$3.call(a) == numberTag;
}
var lodash_isnumber = isNumber$2, objectTag = "[object Object]";
function isHostObject(a) {
  var u = !1;
  if (a != null && typeof a.toString != "function")
    try {
      u = !!(a + "");
    } catch {
    }
  return u;
}
function overArg(a, u) {
  return function(c) {
    return a(u(c));
  };
}
var funcProto = Function.prototype, objectProto$2 = Object.prototype, funcToString = funcProto.toString, hasOwnProperty = objectProto$2.hasOwnProperty, objectCtorString = funcToString.call(Object), objectToString$2 = objectProto$2.toString, getPrototype = overArg(Object.getPrototypeOf, Object);
function isObjectLike$2(a) {
  return !!a && typeof a == "object";
}
function isPlainObject$2(a) {
  if (!isObjectLike$2(a) || objectToString$2.call(a) != objectTag || isHostObject(a))
    return !1;
  var u = getPrototype(a);
  if (u === null)
    return !0;
  var c = hasOwnProperty.call(u, "constructor") && u.constructor;
  return typeof c == "function" && c instanceof c && funcToString.call(c) == objectCtorString;
}
var lodash_isplainobject = isPlainObject$2, stringTag = "[object String]", objectProto$1 = Object.prototype, objectToString$1 = objectProto$1.toString, isArray$2 = Array.isArray;
function isObjectLike$1(a) {
  return !!a && typeof a == "object";
}
function isString$2(a) {
  return typeof a == "string" || !isArray$2(a) && isObjectLike$1(a) && objectToString$1.call(a) == stringTag;
}
var lodash_isstring = isString$2, FUNC_ERROR_TEXT = "Expected a function", INFINITY = 1 / 0, MAX_INTEGER = 17976931348623157e292, NAN = NaN, symbolTag = "[object Symbol]", reTrim = /^\s+|\s+$/g, reIsBadHex = /^[-+]0x[0-9a-f]+$/i, reIsBinary = /^0b[01]+$/i, reIsOctal = /^0o[0-7]+$/i, freeParseInt = parseInt, objectProto = Object.prototype, objectToString = objectProto.toString;
function before(a, u) {
  var c;
  if (typeof u != "function")
    throw new TypeError(FUNC_ERROR_TEXT);
  return a = toInteger(a), function() {
    return --a > 0 && (c = u.apply(this, arguments)), a <= 1 && (u = void 0), c;
  };
}
function once$1(a) {
  return before(2, a);
}
function isObject$3(a) {
  var u = typeof a;
  return !!a && (u == "object" || u == "function");
}
function isObjectLike(a) {
  return !!a && typeof a == "object";
}
function isSymbol(a) {
  return typeof a == "symbol" || isObjectLike(a) && objectToString.call(a) == symbolTag;
}
function toFinite(a) {
  if (!a)
    return a === 0 ? a : 0;
  if (a = toNumber(a), a === INFINITY || a === -INFINITY) {
    var u = a < 0 ? -1 : 1;
    return u * MAX_INTEGER;
  }
  return a === a ? a : 0;
}
function toInteger(a) {
  var u = toFinite(a), c = u % 1;
  return u === u ? c ? u - c : u : 0;
}
function toNumber(a) {
  if (typeof a == "number")
    return a;
  if (isSymbol(a))
    return NAN;
  if (isObject$3(a)) {
    var u = typeof a.valueOf == "function" ? a.valueOf() : a;
    a = isObject$3(u) ? u + "" : u;
  }
  if (typeof a != "string")
    return a === 0 ? a : +a;
  a = a.replace(reTrim, "");
  var c = reIsBinary.test(a);
  return c || reIsOctal.test(a) ? freeParseInt(a.slice(2), c ? 2 : 8) : reIsBadHex.test(a) ? NAN : +a;
}
var lodash_once = once$1, timespan = timespan$2, PS_SUPPORTED = psSupported, jws = jws$3, includes = lodash_includes, isBoolean = lodash_isboolean, isInteger = lodash_isinteger, isNumber$1 = lodash_isnumber, isPlainObject$1 = lodash_isplainobject, isString$1 = lodash_isstring, once = lodash_once, SUPPORTED_ALGS = ["RS256", "RS384", "RS512", "ES256", "ES384", "ES512", "HS256", "HS384", "HS512", "none"];
PS_SUPPORTED && SUPPORTED_ALGS.splice(3, 0, "PS256", "PS384", "PS512");
var sign_options_schema = {
  expiresIn: { isValid: function(a) {
    return isInteger(a) || isString$1(a) && a;
  }, message: '"expiresIn" should be a number of seconds or string representing a timespan' },
  notBefore: { isValid: function(a) {
    return isInteger(a) || isString$1(a) && a;
  }, message: '"notBefore" should be a number of seconds or string representing a timespan' },
  audience: { isValid: function(a) {
    return isString$1(a) || Array.isArray(a);
  }, message: '"audience" must be a string or array' },
  algorithm: { isValid: includes.bind(null, SUPPORTED_ALGS), message: '"algorithm" must be a valid string enum value' },
  header: { isValid: isPlainObject$1, message: '"header" must be an object' },
  encoding: { isValid: isString$1, message: '"encoding" must be a string' },
  issuer: { isValid: isString$1, message: '"issuer" must be a string' },
  subject: { isValid: isString$1, message: '"subject" must be a string' },
  jwtid: { isValid: isString$1, message: '"jwtid" must be a string' },
  noTimestamp: { isValid: isBoolean, message: '"noTimestamp" must be a boolean' },
  keyid: { isValid: isString$1, message: '"keyid" must be a string' },
  mutatePayload: { isValid: isBoolean, message: '"mutatePayload" must be a boolean' }
}, registered_claims_schema = {
  iat: { isValid: isNumber$1, message: '"iat" should be a number of seconds' },
  exp: { isValid: isNumber$1, message: '"exp" should be a number of seconds' },
  nbf: { isValid: isNumber$1, message: '"nbf" should be a number of seconds' }
};
function validate(a, u, c, l) {
  if (!isPlainObject$1(c))
    throw new Error('Expected "' + l + '" to be a plain object.');
  Object.keys(c).forEach(function(v) {
    var p = a[v];
    if (!p) {
      if (!u)
        throw new Error('"' + v + '" is not allowed in "' + l + '"');
      return;
    }
    if (!p.isValid(c[v]))
      throw new Error(p.message);
  });
}
function validateOptions(a) {
  return validate(sign_options_schema, !1, a, "options");
}
function validatePayload(a) {
  return validate(registered_claims_schema, !0, a, "payload");
}
var options_to_payload = {
  audience: "aud",
  issuer: "iss",
  subject: "sub",
  jwtid: "jti"
}, options_for_objects = [
  "expiresIn",
  "notBefore",
  "noTimestamp",
  "audience",
  "issuer",
  "subject",
  "jwtid"
], sign = function(a, u, c, l) {
  typeof c == "function" ? (l = c, c = {}) : c = c || {};
  var v = typeof a == "object" && !Buffer$O.isBuffer(a), p = Object.assign({
    alg: c.algorithm || "HS256",
    typ: v ? "JWT" : void 0,
    kid: c.keyid
  }, c.header);
  function _(F) {
    if (l)
      return l(F);
    throw F;
  }
  if (!u && c.algorithm !== "none")
    return _(new Error("secretOrPrivateKey must have a value"));
  if (typeof a > "u")
    return _(new Error("payload is required"));
  if (v) {
    try {
      validatePayload(a);
    } catch (F) {
      return _(F);
    }
    c.mutatePayload || (a = Object.assign({}, a));
  } else {
    var k = options_for_objects.filter(function(F) {
      return typeof c[F] < "u";
    });
    if (k.length > 0)
      return _(new Error("invalid " + k.join(",") + " option for " + typeof a + " payload"));
  }
  if (typeof a.exp < "u" && typeof c.expiresIn < "u")
    return _(new Error('Bad "options.expiresIn" option the payload already has an "exp" property.'));
  if (typeof a.nbf < "u" && typeof c.notBefore < "u")
    return _(new Error('Bad "options.notBefore" option the payload already has an "nbf" property.'));
  try {
    validateOptions(c);
  } catch (F) {
    return _(F);
  }
  var O = a.iat || Math.floor(Date.now() / 1e3);
  if (c.noTimestamp ? delete a.iat : v && (a.iat = O), typeof c.notBefore < "u") {
    try {
      a.nbf = timespan(c.notBefore, O);
    } catch (F) {
      return _(F);
    }
    if (typeof a.nbf > "u")
      return _(new Error('"notBefore" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
  }
  if (typeof c.expiresIn < "u" && typeof a == "object") {
    try {
      a.exp = timespan(c.expiresIn, O);
    } catch (F) {
      return _(F);
    }
    if (typeof a.exp > "u")
      return _(new Error('"expiresIn" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
  }
  Object.keys(options_to_payload).forEach(function(F) {
    var z = options_to_payload[F];
    if (typeof c[F] < "u") {
      if (typeof a[z] < "u")
        return _(new Error('Bad "options.' + F + '" option. The payload already has an "' + z + '" property.'));
      a[z] = c[F];
    }
  });
  var D = c.encoding || "utf8";
  if (typeof l == "function")
    l = l && once(l), jws.createSign({
      header: p,
      privateKey: u,
      payload: a,
      encoding: D
    }).once("error", l).once("done", function(F) {
      l(null, F);
    });
  else
    return jws.sign({ header: p, payload: a, secret: u, encoding: D });
}, jsonwebtoken = {
  decode: decode$1,
  verify,
  sign,
  JsonWebTokenError: JsonWebTokenError_1,
  NotBeforeError: NotBeforeError_1,
  TokenExpiredError: TokenExpiredError_1
}, __createBinding = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(a, u, c, l) {
  l === void 0 && (l = c), Object.defineProperty(a, l, { enumerable: !0, get: function() {
    return u[c];
  } });
} : function(a, u, c, l) {
  l === void 0 && (l = c), a[l] = u[c];
}), __setModuleDefault = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(a, u) {
  Object.defineProperty(a, "default", { enumerable: !0, value: u });
} : function(a, u) {
  a.default = u;
}), __importStar = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(a) {
  if (a && a.__esModule)
    return a;
  var u = {};
  if (a != null)
    for (var c in a)
      c !== "default" && Object.prototype.hasOwnProperty.call(a, c) && __createBinding(u, a, c);
  return __setModuleDefault(u, a), u;
};
Object.defineProperty(AccessToken$1, "__esModule", { value: !0 });
AccessToken$1.TokenVerifier = AccessToken$1.AccessToken = void 0;
const jwt = __importStar(jsonwebtoken), defaultTTL = 6 * 60 * 60;
class AccessToken {
  /**
   * Creates a new AccessToken
   * @param apiKey API Key, can be set in env LIVEKIT_API_KEY
   * @param apiSecret Secret, can be set in env LIVEKIT_API_SECRET
   */
  constructor(u, c, l) {
    if (u || (u = process$1.env.LIVEKIT_API_KEY), c || (c = process$1.env.LIVEKIT_API_SECRET), !u || !c)
      throw Error("api-key and api-secret must be set");
    this.apiKey = u, this.apiSecret = c, this.grants = {}, this.identity = l == null ? void 0 : l.identity, this.ttl = (l == null ? void 0 : l.ttl) || defaultTTL, l != null && l.metadata && (this.metadata = l.metadata), l != null && l.name && (this.name = l.name);
  }
  /**
   * Adds a video grant to this token.
   * @param grant
   */
  addGrant(u) {
    this.grants.video = u;
  }
  /**
   * Set metadata to be passed to the Participant, used only when joining the room
   */
  set metadata(u) {
    this.grants.metadata = u;
  }
  set name(u) {
    this.grants.name = u;
  }
  get sha256() {
    return this.grants.sha256;
  }
  set sha256(u) {
    this.grants.sha256 = u;
  }
  /**
   * @returns JWT encoded token
   */
  toJwt() {
    var u;
    const c = {
      issuer: this.apiKey,
      expiresIn: this.ttl,
      notBefore: 0
    };
    if (this.identity)
      c.subject = this.identity, c.jwtid = this.identity;
    else if (!((u = this.grants.video) === null || u === void 0) && u.roomJoin)
      throw Error("identity is required for join but not set");
    return jwt.sign(this.grants, this.apiSecret, c);
  }
}
AccessToken$1.AccessToken = AccessToken;
class TokenVerifier {
  constructor(u, c) {
    this.apiKey = u, this.apiSecret = c;
  }
  verify(u) {
    const c = jwt.verify(u, this.apiSecret, { issuer: this.apiKey });
    if (!c)
      throw Error("invalid token");
    return c;
  }
}
AccessToken$1.TokenVerifier = TokenVerifier;
var EgressClient$1 = {}, livekit_egress = {};
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(H) {
    return H && H.__esModule ? H : { default: H };
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.AutoTrackEgress = a.SegmentsInfo = a.FileInfo = a.StreamInfo = a.StreamInfoList = a.EgressInfo = a.StopEgressRequest = a.ListEgressResponse = a.ListEgressRequest = a.UpdateStreamRequest = a.UpdateLayoutRequest = a.EncodingOptions = a.StreamOutput = a.AliOSSUpload = a.AzureBlobUpload = a.GCPUpload = a.S3Upload_MetadataEntry = a.S3Upload = a.DirectFileOutput = a.SegmentedFileOutput = a.EncodedFileOutput = a.WebEgressRequest = a.TrackEgressRequest = a.TrackCompositeEgressRequest = a.RoomCompositeEgressRequest = a.streamInfo_StatusToJSON = a.streamInfo_StatusFromJSON = a.StreamInfo_Status = a.egressStatusToJSON = a.egressStatusFromJSON = a.EgressStatus = a.encodingOptionsPresetToJSON = a.encodingOptionsPresetFromJSON = a.EncodingOptionsPreset = a.videoCodecToJSON = a.videoCodecFromJSON = a.VideoCodec = a.audioCodecToJSON = a.audioCodecFromJSON = a.AudioCodec = a.segmentedFileProtocolToJSON = a.segmentedFileProtocolFromJSON = a.SegmentedFileProtocol = a.streamProtocolToJSON = a.streamProtocolFromJSON = a.StreamProtocol = a.encodedFileTypeToJSON = a.encodedFileTypeFromJSON = a.EncodedFileType = a.protobufPackage = void 0;
  const c = u(umdExports), l = u(minimal);
  a.protobufPackage = "livekit";
  var v;
  (function(H) {
    H[H.DEFAULT_FILETYPE = 0] = "DEFAULT_FILETYPE", H[H.MP4 = 1] = "MP4", H[H.OGG = 2] = "OGG", H[H.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(v = a.EncodedFileType || (a.EncodedFileType = {}));
  function p(H) {
    switch (H) {
      case 0:
      case "DEFAULT_FILETYPE":
        return v.DEFAULT_FILETYPE;
      case 1:
      case "MP4":
        return v.MP4;
      case 2:
      case "OGG":
        return v.OGG;
      case -1:
      case "UNRECOGNIZED":
      default:
        return v.UNRECOGNIZED;
    }
  }
  a.encodedFileTypeFromJSON = p;
  function _(H) {
    switch (H) {
      case v.DEFAULT_FILETYPE:
        return "DEFAULT_FILETYPE";
      case v.MP4:
        return "MP4";
      case v.OGG:
        return "OGG";
      case v.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.encodedFileTypeToJSON = _;
  var k;
  (function(H) {
    H[H.DEFAULT_PROTOCOL = 0] = "DEFAULT_PROTOCOL", H[H.RTMP = 1] = "RTMP", H[H.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(k = a.StreamProtocol || (a.StreamProtocol = {}));
  function O(H) {
    switch (H) {
      case 0:
      case "DEFAULT_PROTOCOL":
        return k.DEFAULT_PROTOCOL;
      case 1:
      case "RTMP":
        return k.RTMP;
      case -1:
      case "UNRECOGNIZED":
      default:
        return k.UNRECOGNIZED;
    }
  }
  a.streamProtocolFromJSON = O;
  function D(H) {
    switch (H) {
      case k.DEFAULT_PROTOCOL:
        return "DEFAULT_PROTOCOL";
      case k.RTMP:
        return "RTMP";
      case k.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.streamProtocolToJSON = D;
  var F;
  (function(H) {
    H[H.DEFAULT_SEGMENTED_FILE_PROTOCOL = 0] = "DEFAULT_SEGMENTED_FILE_PROTOCOL", H[H.HLS_PROTOCOL = 1] = "HLS_PROTOCOL", H[H.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(F = a.SegmentedFileProtocol || (a.SegmentedFileProtocol = {}));
  function z(H) {
    switch (H) {
      case 0:
      case "DEFAULT_SEGMENTED_FILE_PROTOCOL":
        return F.DEFAULT_SEGMENTED_FILE_PROTOCOL;
      case 1:
      case "HLS_PROTOCOL":
        return F.HLS_PROTOCOL;
      case -1:
      case "UNRECOGNIZED":
      default:
        return F.UNRECOGNIZED;
    }
  }
  a.segmentedFileProtocolFromJSON = z;
  function j(H) {
    switch (H) {
      case F.DEFAULT_SEGMENTED_FILE_PROTOCOL:
        return "DEFAULT_SEGMENTED_FILE_PROTOCOL";
      case F.HLS_PROTOCOL:
        return "HLS_PROTOCOL";
      case F.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.segmentedFileProtocolToJSON = j;
  var ee;
  (function(H) {
    H[H.DEFAULT_AC = 0] = "DEFAULT_AC", H[H.OPUS = 1] = "OPUS", H[H.AAC = 2] = "AAC", H[H.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(ee = a.AudioCodec || (a.AudioCodec = {}));
  function X(H) {
    switch (H) {
      case 0:
      case "DEFAULT_AC":
        return ee.DEFAULT_AC;
      case 1:
      case "OPUS":
        return ee.OPUS;
      case 2:
      case "AAC":
        return ee.AAC;
      case -1:
      case "UNRECOGNIZED":
      default:
        return ee.UNRECOGNIZED;
    }
  }
  a.audioCodecFromJSON = X;
  function ae(H) {
    switch (H) {
      case ee.DEFAULT_AC:
        return "DEFAULT_AC";
      case ee.OPUS:
        return "OPUS";
      case ee.AAC:
        return "AAC";
      case ee.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.audioCodecToJSON = ae;
  var Q;
  (function(H) {
    H[H.DEFAULT_VC = 0] = "DEFAULT_VC", H[H.H264_BASELINE = 1] = "H264_BASELINE", H[H.H264_MAIN = 2] = "H264_MAIN", H[H.H264_HIGH = 3] = "H264_HIGH", H[H.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(Q = a.VideoCodec || (a.VideoCodec = {}));
  function ne(H) {
    switch (H) {
      case 0:
      case "DEFAULT_VC":
        return Q.DEFAULT_VC;
      case 1:
      case "H264_BASELINE":
        return Q.H264_BASELINE;
      case 2:
      case "H264_MAIN":
        return Q.H264_MAIN;
      case 3:
      case "H264_HIGH":
        return Q.H264_HIGH;
      case -1:
      case "UNRECOGNIZED":
      default:
        return Q.UNRECOGNIZED;
    }
  }
  a.videoCodecFromJSON = ne;
  function Z(H) {
    switch (H) {
      case Q.DEFAULT_VC:
        return "DEFAULT_VC";
      case Q.H264_BASELINE:
        return "H264_BASELINE";
      case Q.H264_MAIN:
        return "H264_MAIN";
      case Q.H264_HIGH:
        return "H264_HIGH";
      case Q.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.videoCodecToJSON = Z;
  var de;
  (function(H) {
    H[H.H264_720P_30 = 0] = "H264_720P_30", H[H.H264_720P_60 = 1] = "H264_720P_60", H[H.H264_1080P_30 = 2] = "H264_1080P_30", H[H.H264_1080P_60 = 3] = "H264_1080P_60", H[H.PORTRAIT_H264_720P_30 = 4] = "PORTRAIT_H264_720P_30", H[H.PORTRAIT_H264_720P_60 = 5] = "PORTRAIT_H264_720P_60", H[H.PORTRAIT_H264_1080P_30 = 6] = "PORTRAIT_H264_1080P_30", H[H.PORTRAIT_H264_1080P_60 = 7] = "PORTRAIT_H264_1080P_60", H[H.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(de = a.EncodingOptionsPreset || (a.EncodingOptionsPreset = {}));
  function fe(H) {
    switch (H) {
      case 0:
      case "H264_720P_30":
        return de.H264_720P_30;
      case 1:
      case "H264_720P_60":
        return de.H264_720P_60;
      case 2:
      case "H264_1080P_30":
        return de.H264_1080P_30;
      case 3:
      case "H264_1080P_60":
        return de.H264_1080P_60;
      case 4:
      case "PORTRAIT_H264_720P_30":
        return de.PORTRAIT_H264_720P_30;
      case 5:
      case "PORTRAIT_H264_720P_60":
        return de.PORTRAIT_H264_720P_60;
      case 6:
      case "PORTRAIT_H264_1080P_30":
        return de.PORTRAIT_H264_1080P_30;
      case 7:
      case "PORTRAIT_H264_1080P_60":
        return de.PORTRAIT_H264_1080P_60;
      case -1:
      case "UNRECOGNIZED":
      default:
        return de.UNRECOGNIZED;
    }
  }
  a.encodingOptionsPresetFromJSON = fe;
  function Te(H) {
    switch (H) {
      case de.H264_720P_30:
        return "H264_720P_30";
      case de.H264_720P_60:
        return "H264_720P_60";
      case de.H264_1080P_30:
        return "H264_1080P_30";
      case de.H264_1080P_60:
        return "H264_1080P_60";
      case de.PORTRAIT_H264_720P_30:
        return "PORTRAIT_H264_720P_30";
      case de.PORTRAIT_H264_720P_60:
        return "PORTRAIT_H264_720P_60";
      case de.PORTRAIT_H264_1080P_30:
        return "PORTRAIT_H264_1080P_30";
      case de.PORTRAIT_H264_1080P_60:
        return "PORTRAIT_H264_1080P_60";
      case de.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.encodingOptionsPresetToJSON = Te;
  var Re;
  (function(H) {
    H[H.EGRESS_STARTING = 0] = "EGRESS_STARTING", H[H.EGRESS_ACTIVE = 1] = "EGRESS_ACTIVE", H[H.EGRESS_ENDING = 2] = "EGRESS_ENDING", H[H.EGRESS_COMPLETE = 3] = "EGRESS_COMPLETE", H[H.EGRESS_FAILED = 4] = "EGRESS_FAILED", H[H.EGRESS_ABORTED = 5] = "EGRESS_ABORTED", H[H.EGRESS_LIMIT_REACHED = 6] = "EGRESS_LIMIT_REACHED", H[H.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(Re = a.EgressStatus || (a.EgressStatus = {}));
  function Le(H) {
    switch (H) {
      case 0:
      case "EGRESS_STARTING":
        return Re.EGRESS_STARTING;
      case 1:
      case "EGRESS_ACTIVE":
        return Re.EGRESS_ACTIVE;
      case 2:
      case "EGRESS_ENDING":
        return Re.EGRESS_ENDING;
      case 3:
      case "EGRESS_COMPLETE":
        return Re.EGRESS_COMPLETE;
      case 4:
      case "EGRESS_FAILED":
        return Re.EGRESS_FAILED;
      case 5:
      case "EGRESS_ABORTED":
        return Re.EGRESS_ABORTED;
      case 6:
      case "EGRESS_LIMIT_REACHED":
        return Re.EGRESS_LIMIT_REACHED;
      case -1:
      case "UNRECOGNIZED":
      default:
        return Re.UNRECOGNIZED;
    }
  }
  a.egressStatusFromJSON = Le;
  function be(H) {
    switch (H) {
      case Re.EGRESS_STARTING:
        return "EGRESS_STARTING";
      case Re.EGRESS_ACTIVE:
        return "EGRESS_ACTIVE";
      case Re.EGRESS_ENDING:
        return "EGRESS_ENDING";
      case Re.EGRESS_COMPLETE:
        return "EGRESS_COMPLETE";
      case Re.EGRESS_FAILED:
        return "EGRESS_FAILED";
      case Re.EGRESS_ABORTED:
        return "EGRESS_ABORTED";
      case Re.EGRESS_LIMIT_REACHED:
        return "EGRESS_LIMIT_REACHED";
      case Re.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.egressStatusToJSON = be;
  var q;
  (function(H) {
    H[H.ACTIVE = 0] = "ACTIVE", H[H.FINISHED = 1] = "FINISHED", H[H.FAILED = 2] = "FAILED", H[H.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(q = a.StreamInfo_Status || (a.StreamInfo_Status = {}));
  function J(H) {
    switch (H) {
      case 0:
      case "ACTIVE":
        return q.ACTIVE;
      case 1:
      case "FINISHED":
        return q.FINISHED;
      case 2:
      case "FAILED":
        return q.FAILED;
      case -1:
      case "UNRECOGNIZED":
      default:
        return q.UNRECOGNIZED;
    }
  }
  a.streamInfo_StatusFromJSON = J;
  function C(H) {
    switch (H) {
      case q.ACTIVE:
        return "ACTIVE";
      case q.FINISHED:
        return "FINISHED";
      case q.FAILED:
        return "FAILED";
      case q.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.streamInfo_StatusToJSON = C;
  function S() {
    return {
      roomName: "",
      layout: "",
      audioOnly: !1,
      videoOnly: !1,
      customBaseUrl: "",
      file: void 0,
      stream: void 0,
      segments: void 0,
      preset: void 0,
      advanced: void 0
    };
  }
  a.RoomCompositeEgressRequest = {
    encode(H, ye = l.default.Writer.create()) {
      return H.roomName !== void 0 && H.roomName !== "" && ye.uint32(10).string(H.roomName), H.layout !== void 0 && H.layout !== "" && ye.uint32(18).string(H.layout), H.audioOnly === !0 && ye.uint32(24).bool(H.audioOnly), H.videoOnly === !0 && ye.uint32(32).bool(H.videoOnly), H.customBaseUrl !== void 0 && H.customBaseUrl !== "" && ye.uint32(42).string(H.customBaseUrl), H.file !== void 0 && a.EncodedFileOutput.encode(H.file, ye.uint32(50).fork()).ldelim(), H.stream !== void 0 && a.StreamOutput.encode(H.stream, ye.uint32(58).fork()).ldelim(), H.segments !== void 0 && a.SegmentedFileOutput.encode(H.segments, ye.uint32(82).fork()).ldelim(), H.preset !== void 0 && ye.uint32(64).int32(H.preset), H.advanced !== void 0 && a.EncodingOptions.encode(H.advanced, ye.uint32(74).fork()).ldelim(), ye;
    },
    decode(H, ye) {
      const Ee = H instanceof l.default.Reader ? H : new l.default.Reader(H);
      let We = ye === void 0 ? Ee.len : Ee.pos + ye;
      const we = S();
      for (; Ee.pos < We; ) {
        const V = Ee.uint32();
        switch (V >>> 3) {
          case 1:
            we.roomName = Ee.string();
            break;
          case 2:
            we.layout = Ee.string();
            break;
          case 3:
            we.audioOnly = Ee.bool();
            break;
          case 4:
            we.videoOnly = Ee.bool();
            break;
          case 5:
            we.customBaseUrl = Ee.string();
            break;
          case 6:
            we.file = a.EncodedFileOutput.decode(Ee, Ee.uint32());
            break;
          case 7:
            we.stream = a.StreamOutput.decode(Ee, Ee.uint32());
            break;
          case 10:
            we.segments = a.SegmentedFileOutput.decode(Ee, Ee.uint32());
            break;
          case 8:
            we.preset = Ee.int32();
            break;
          case 9:
            we.advanced = a.EncodingOptions.decode(Ee, Ee.uint32());
            break;
          default:
            Ee.skipType(V & 7);
            break;
        }
      }
      return we;
    },
    fromJSON(H) {
      return {
        roomName: Ge(H.roomName) ? String(H.roomName) : "",
        layout: Ge(H.layout) ? String(H.layout) : "",
        audioOnly: Ge(H.audioOnly) ? !!H.audioOnly : !1,
        videoOnly: Ge(H.videoOnly) ? !!H.videoOnly : !1,
        customBaseUrl: Ge(H.customBaseUrl) ? String(H.customBaseUrl) : "",
        file: Ge(H.file) ? a.EncodedFileOutput.fromJSON(H.file) : void 0,
        stream: Ge(H.stream) ? a.StreamOutput.fromJSON(H.stream) : void 0,
        segments: Ge(H.segments) ? a.SegmentedFileOutput.fromJSON(H.segments) : void 0,
        preset: Ge(H.preset) ? fe(H.preset) : void 0,
        advanced: Ge(H.advanced) ? a.EncodingOptions.fromJSON(H.advanced) : void 0
      };
    },
    toJSON(H) {
      const ye = {};
      return H.roomName !== void 0 && (ye.roomName = H.roomName), H.layout !== void 0 && (ye.layout = H.layout), H.audioOnly !== void 0 && (ye.audioOnly = H.audioOnly), H.videoOnly !== void 0 && (ye.videoOnly = H.videoOnly), H.customBaseUrl !== void 0 && (ye.customBaseUrl = H.customBaseUrl), H.file !== void 0 && (ye.file = H.file ? a.EncodedFileOutput.toJSON(H.file) : void 0), H.stream !== void 0 && (ye.stream = H.stream ? a.StreamOutput.toJSON(H.stream) : void 0), H.segments !== void 0 && (ye.segments = H.segments ? a.SegmentedFileOutput.toJSON(H.segments) : void 0), H.preset !== void 0 && (ye.preset = H.preset !== void 0 ? Te(H.preset) : void 0), H.advanced !== void 0 && (ye.advanced = H.advanced ? a.EncodingOptions.toJSON(H.advanced) : void 0), ye;
    },
    fromPartial(H) {
      var ye, Ee, We, we, V, _e;
      const ue = S();
      return ue.roomName = (ye = H.roomName) !== null && ye !== void 0 ? ye : "", ue.layout = (Ee = H.layout) !== null && Ee !== void 0 ? Ee : "", ue.audioOnly = (We = H.audioOnly) !== null && We !== void 0 ? We : !1, ue.videoOnly = (we = H.videoOnly) !== null && we !== void 0 ? we : !1, ue.customBaseUrl = (V = H.customBaseUrl) !== null && V !== void 0 ? V : "", ue.file = H.file !== void 0 && H.file !== null ? a.EncodedFileOutput.fromPartial(H.file) : void 0, ue.stream = H.stream !== void 0 && H.stream !== null ? a.StreamOutput.fromPartial(H.stream) : void 0, ue.segments = H.segments !== void 0 && H.segments !== null ? a.SegmentedFileOutput.fromPartial(H.segments) : void 0, ue.preset = (_e = H.preset) !== null && _e !== void 0 ? _e : void 0, ue.advanced = H.advanced !== void 0 && H.advanced !== null ? a.EncodingOptions.fromPartial(H.advanced) : void 0, ue;
    }
  };
  function E() {
    return {
      roomName: "",
      audioTrackId: "",
      videoTrackId: "",
      file: void 0,
      stream: void 0,
      segments: void 0,
      preset: void 0,
      advanced: void 0
    };
  }
  a.TrackCompositeEgressRequest = {
    encode(H, ye = l.default.Writer.create()) {
      return H.roomName !== void 0 && H.roomName !== "" && ye.uint32(10).string(H.roomName), H.audioTrackId !== void 0 && H.audioTrackId !== "" && ye.uint32(18).string(H.audioTrackId), H.videoTrackId !== void 0 && H.videoTrackId !== "" && ye.uint32(26).string(H.videoTrackId), H.file !== void 0 && a.EncodedFileOutput.encode(H.file, ye.uint32(34).fork()).ldelim(), H.stream !== void 0 && a.StreamOutput.encode(H.stream, ye.uint32(42).fork()).ldelim(), H.segments !== void 0 && a.SegmentedFileOutput.encode(H.segments, ye.uint32(66).fork()).ldelim(), H.preset !== void 0 && ye.uint32(48).int32(H.preset), H.advanced !== void 0 && a.EncodingOptions.encode(H.advanced, ye.uint32(58).fork()).ldelim(), ye;
    },
    decode(H, ye) {
      const Ee = H instanceof l.default.Reader ? H : new l.default.Reader(H);
      let We = ye === void 0 ? Ee.len : Ee.pos + ye;
      const we = E();
      for (; Ee.pos < We; ) {
        const V = Ee.uint32();
        switch (V >>> 3) {
          case 1:
            we.roomName = Ee.string();
            break;
          case 2:
            we.audioTrackId = Ee.string();
            break;
          case 3:
            we.videoTrackId = Ee.string();
            break;
          case 4:
            we.file = a.EncodedFileOutput.decode(Ee, Ee.uint32());
            break;
          case 5:
            we.stream = a.StreamOutput.decode(Ee, Ee.uint32());
            break;
          case 8:
            we.segments = a.SegmentedFileOutput.decode(Ee, Ee.uint32());
            break;
          case 6:
            we.preset = Ee.int32();
            break;
          case 7:
            we.advanced = a.EncodingOptions.decode(Ee, Ee.uint32());
            break;
          default:
            Ee.skipType(V & 7);
            break;
        }
      }
      return we;
    },
    fromJSON(H) {
      return {
        roomName: Ge(H.roomName) ? String(H.roomName) : "",
        audioTrackId: Ge(H.audioTrackId) ? String(H.audioTrackId) : "",
        videoTrackId: Ge(H.videoTrackId) ? String(H.videoTrackId) : "",
        file: Ge(H.file) ? a.EncodedFileOutput.fromJSON(H.file) : void 0,
        stream: Ge(H.stream) ? a.StreamOutput.fromJSON(H.stream) : void 0,
        segments: Ge(H.segments) ? a.SegmentedFileOutput.fromJSON(H.segments) : void 0,
        preset: Ge(H.preset) ? fe(H.preset) : void 0,
        advanced: Ge(H.advanced) ? a.EncodingOptions.fromJSON(H.advanced) : void 0
      };
    },
    toJSON(H) {
      const ye = {};
      return H.roomName !== void 0 && (ye.roomName = H.roomName), H.audioTrackId !== void 0 && (ye.audioTrackId = H.audioTrackId), H.videoTrackId !== void 0 && (ye.videoTrackId = H.videoTrackId), H.file !== void 0 && (ye.file = H.file ? a.EncodedFileOutput.toJSON(H.file) : void 0), H.stream !== void 0 && (ye.stream = H.stream ? a.StreamOutput.toJSON(H.stream) : void 0), H.segments !== void 0 && (ye.segments = H.segments ? a.SegmentedFileOutput.toJSON(H.segments) : void 0), H.preset !== void 0 && (ye.preset = H.preset !== void 0 ? Te(H.preset) : void 0), H.advanced !== void 0 && (ye.advanced = H.advanced ? a.EncodingOptions.toJSON(H.advanced) : void 0), ye;
    },
    fromPartial(H) {
      var ye, Ee, We, we;
      const V = E();
      return V.roomName = (ye = H.roomName) !== null && ye !== void 0 ? ye : "", V.audioTrackId = (Ee = H.audioTrackId) !== null && Ee !== void 0 ? Ee : "", V.videoTrackId = (We = H.videoTrackId) !== null && We !== void 0 ? We : "", V.file = H.file !== void 0 && H.file !== null ? a.EncodedFileOutput.fromPartial(H.file) : void 0, V.stream = H.stream !== void 0 && H.stream !== null ? a.StreamOutput.fromPartial(H.stream) : void 0, V.segments = H.segments !== void 0 && H.segments !== null ? a.SegmentedFileOutput.fromPartial(H.segments) : void 0, V.preset = (we = H.preset) !== null && we !== void 0 ? we : void 0, V.advanced = H.advanced !== void 0 && H.advanced !== null ? a.EncodingOptions.fromPartial(H.advanced) : void 0, V;
    }
  };
  function I() {
    return { roomName: "", trackId: "", file: void 0, websocketUrl: void 0 };
  }
  a.TrackEgressRequest = {
    encode(H, ye = l.default.Writer.create()) {
      return H.roomName !== void 0 && H.roomName !== "" && ye.uint32(10).string(H.roomName), H.trackId !== void 0 && H.trackId !== "" && ye.uint32(18).string(H.trackId), H.file !== void 0 && a.DirectFileOutput.encode(H.file, ye.uint32(26).fork()).ldelim(), H.websocketUrl !== void 0 && ye.uint32(34).string(H.websocketUrl), ye;
    },
    decode(H, ye) {
      const Ee = H instanceof l.default.Reader ? H : new l.default.Reader(H);
      let We = ye === void 0 ? Ee.len : Ee.pos + ye;
      const we = I();
      for (; Ee.pos < We; ) {
        const V = Ee.uint32();
        switch (V >>> 3) {
          case 1:
            we.roomName = Ee.string();
            break;
          case 2:
            we.trackId = Ee.string();
            break;
          case 3:
            we.file = a.DirectFileOutput.decode(Ee, Ee.uint32());
            break;
          case 4:
            we.websocketUrl = Ee.string();
            break;
          default:
            Ee.skipType(V & 7);
            break;
        }
      }
      return we;
    },
    fromJSON(H) {
      return {
        roomName: Ge(H.roomName) ? String(H.roomName) : "",
        trackId: Ge(H.trackId) ? String(H.trackId) : "",
        file: Ge(H.file) ? a.DirectFileOutput.fromJSON(H.file) : void 0,
        websocketUrl: Ge(H.websocketUrl) ? String(H.websocketUrl) : void 0
      };
    },
    toJSON(H) {
      const ye = {};
      return H.roomName !== void 0 && (ye.roomName = H.roomName), H.trackId !== void 0 && (ye.trackId = H.trackId), H.file !== void 0 && (ye.file = H.file ? a.DirectFileOutput.toJSON(H.file) : void 0), H.websocketUrl !== void 0 && (ye.websocketUrl = H.websocketUrl), ye;
    },
    fromPartial(H) {
      var ye, Ee, We;
      const we = I();
      return we.roomName = (ye = H.roomName) !== null && ye !== void 0 ? ye : "", we.trackId = (Ee = H.trackId) !== null && Ee !== void 0 ? Ee : "", we.file = H.file !== void 0 && H.file !== null ? a.DirectFileOutput.fromPartial(H.file) : void 0, we.websocketUrl = (We = H.websocketUrl) !== null && We !== void 0 ? We : void 0, we;
    }
  };
  function M() {
    return {
      url: "",
      audioOnly: !1,
      videoOnly: !1,
      file: void 0,
      stream: void 0,
      segments: void 0,
      preset: void 0,
      advanced: void 0
    };
  }
  a.WebEgressRequest = {
    encode(H, ye = l.default.Writer.create()) {
      return H.url !== void 0 && H.url !== "" && ye.uint32(10).string(H.url), H.audioOnly === !0 && ye.uint32(16).bool(H.audioOnly), H.videoOnly === !0 && ye.uint32(24).bool(H.videoOnly), H.file !== void 0 && a.EncodedFileOutput.encode(H.file, ye.uint32(34).fork()).ldelim(), H.stream !== void 0 && a.StreamOutput.encode(H.stream, ye.uint32(42).fork()).ldelim(), H.segments !== void 0 && a.SegmentedFileOutput.encode(H.segments, ye.uint32(50).fork()).ldelim(), H.preset !== void 0 && ye.uint32(56).int32(H.preset), H.advanced !== void 0 && a.EncodingOptions.encode(H.advanced, ye.uint32(66).fork()).ldelim(), ye;
    },
    decode(H, ye) {
      const Ee = H instanceof l.default.Reader ? H : new l.default.Reader(H);
      let We = ye === void 0 ? Ee.len : Ee.pos + ye;
      const we = M();
      for (; Ee.pos < We; ) {
        const V = Ee.uint32();
        switch (V >>> 3) {
          case 1:
            we.url = Ee.string();
            break;
          case 2:
            we.audioOnly = Ee.bool();
            break;
          case 3:
            we.videoOnly = Ee.bool();
            break;
          case 4:
            we.file = a.EncodedFileOutput.decode(Ee, Ee.uint32());
            break;
          case 5:
            we.stream = a.StreamOutput.decode(Ee, Ee.uint32());
            break;
          case 6:
            we.segments = a.SegmentedFileOutput.decode(Ee, Ee.uint32());
            break;
          case 7:
            we.preset = Ee.int32();
            break;
          case 8:
            we.advanced = a.EncodingOptions.decode(Ee, Ee.uint32());
            break;
          default:
            Ee.skipType(V & 7);
            break;
        }
      }
      return we;
    },
    fromJSON(H) {
      return {
        url: Ge(H.url) ? String(H.url) : "",
        audioOnly: Ge(H.audioOnly) ? !!H.audioOnly : !1,
        videoOnly: Ge(H.videoOnly) ? !!H.videoOnly : !1,
        file: Ge(H.file) ? a.EncodedFileOutput.fromJSON(H.file) : void 0,
        stream: Ge(H.stream) ? a.StreamOutput.fromJSON(H.stream) : void 0,
        segments: Ge(H.segments) ? a.SegmentedFileOutput.fromJSON(H.segments) : void 0,
        preset: Ge(H.preset) ? fe(H.preset) : void 0,
        advanced: Ge(H.advanced) ? a.EncodingOptions.fromJSON(H.advanced) : void 0
      };
    },
    toJSON(H) {
      const ye = {};
      return H.url !== void 0 && (ye.url = H.url), H.audioOnly !== void 0 && (ye.audioOnly = H.audioOnly), H.videoOnly !== void 0 && (ye.videoOnly = H.videoOnly), H.file !== void 0 && (ye.file = H.file ? a.EncodedFileOutput.toJSON(H.file) : void 0), H.stream !== void 0 && (ye.stream = H.stream ? a.StreamOutput.toJSON(H.stream) : void 0), H.segments !== void 0 && (ye.segments = H.segments ? a.SegmentedFileOutput.toJSON(H.segments) : void 0), H.preset !== void 0 && (ye.preset = H.preset !== void 0 ? Te(H.preset) : void 0), H.advanced !== void 0 && (ye.advanced = H.advanced ? a.EncodingOptions.toJSON(H.advanced) : void 0), ye;
    },
    fromPartial(H) {
      var ye, Ee, We, we;
      const V = M();
      return V.url = (ye = H.url) !== null && ye !== void 0 ? ye : "", V.audioOnly = (Ee = H.audioOnly) !== null && Ee !== void 0 ? Ee : !1, V.videoOnly = (We = H.videoOnly) !== null && We !== void 0 ? We : !1, V.file = H.file !== void 0 && H.file !== null ? a.EncodedFileOutput.fromPartial(H.file) : void 0, V.stream = H.stream !== void 0 && H.stream !== null ? a.StreamOutput.fromPartial(H.stream) : void 0, V.segments = H.segments !== void 0 && H.segments !== null ? a.SegmentedFileOutput.fromPartial(H.segments) : void 0, V.preset = (we = H.preset) !== null && we !== void 0 ? we : void 0, V.advanced = H.advanced !== void 0 && H.advanced !== null ? a.EncodingOptions.fromPartial(H.advanced) : void 0, V;
    }
  };
  function $() {
    return {
      fileType: 0,
      filepath: "",
      disableManifest: !1,
      s3: void 0,
      gcp: void 0,
      azure: void 0,
      aliOSS: void 0
    };
  }
  a.EncodedFileOutput = {
    encode(H, ye = l.default.Writer.create()) {
      return H.fileType !== void 0 && H.fileType !== 0 && ye.uint32(8).int32(H.fileType), H.filepath !== void 0 && H.filepath !== "" && ye.uint32(18).string(H.filepath), H.disableManifest === !0 && ye.uint32(48).bool(H.disableManifest), H.s3 !== void 0 && a.S3Upload.encode(H.s3, ye.uint32(26).fork()).ldelim(), H.gcp !== void 0 && a.GCPUpload.encode(H.gcp, ye.uint32(34).fork()).ldelim(), H.azure !== void 0 && a.AzureBlobUpload.encode(H.azure, ye.uint32(42).fork()).ldelim(), H.aliOSS !== void 0 && a.AliOSSUpload.encode(H.aliOSS, ye.uint32(58).fork()).ldelim(), ye;
    },
    decode(H, ye) {
      const Ee = H instanceof l.default.Reader ? H : new l.default.Reader(H);
      let We = ye === void 0 ? Ee.len : Ee.pos + ye;
      const we = $();
      for (; Ee.pos < We; ) {
        const V = Ee.uint32();
        switch (V >>> 3) {
          case 1:
            we.fileType = Ee.int32();
            break;
          case 2:
            we.filepath = Ee.string();
            break;
          case 6:
            we.disableManifest = Ee.bool();
            break;
          case 3:
            we.s3 = a.S3Upload.decode(Ee, Ee.uint32());
            break;
          case 4:
            we.gcp = a.GCPUpload.decode(Ee, Ee.uint32());
            break;
          case 5:
            we.azure = a.AzureBlobUpload.decode(Ee, Ee.uint32());
            break;
          case 7:
            we.aliOSS = a.AliOSSUpload.decode(Ee, Ee.uint32());
            break;
          default:
            Ee.skipType(V & 7);
            break;
        }
      }
      return we;
    },
    fromJSON(H) {
      return {
        fileType: Ge(H.fileType) ? p(H.fileType) : 0,
        filepath: Ge(H.filepath) ? String(H.filepath) : "",
        disableManifest: Ge(H.disableManifest) ? !!H.disableManifest : !1,
        s3: Ge(H.s3) ? a.S3Upload.fromJSON(H.s3) : void 0,
        gcp: Ge(H.gcp) ? a.GCPUpload.fromJSON(H.gcp) : void 0,
        azure: Ge(H.azure) ? a.AzureBlobUpload.fromJSON(H.azure) : void 0,
        aliOSS: Ge(H.aliOSS) ? a.AliOSSUpload.fromJSON(H.aliOSS) : void 0
      };
    },
    toJSON(H) {
      const ye = {};
      return H.fileType !== void 0 && (ye.fileType = _(H.fileType)), H.filepath !== void 0 && (ye.filepath = H.filepath), H.disableManifest !== void 0 && (ye.disableManifest = H.disableManifest), H.s3 !== void 0 && (ye.s3 = H.s3 ? a.S3Upload.toJSON(H.s3) : void 0), H.gcp !== void 0 && (ye.gcp = H.gcp ? a.GCPUpload.toJSON(H.gcp) : void 0), H.azure !== void 0 && (ye.azure = H.azure ? a.AzureBlobUpload.toJSON(H.azure) : void 0), H.aliOSS !== void 0 && (ye.aliOSS = H.aliOSS ? a.AliOSSUpload.toJSON(H.aliOSS) : void 0), ye;
    },
    fromPartial(H) {
      var ye, Ee, We;
      const we = $();
      return we.fileType = (ye = H.fileType) !== null && ye !== void 0 ? ye : 0, we.filepath = (Ee = H.filepath) !== null && Ee !== void 0 ? Ee : "", we.disableManifest = (We = H.disableManifest) !== null && We !== void 0 ? We : !1, we.s3 = H.s3 !== void 0 && H.s3 !== null ? a.S3Upload.fromPartial(H.s3) : void 0, we.gcp = H.gcp !== void 0 && H.gcp !== null ? a.GCPUpload.fromPartial(H.gcp) : void 0, we.azure = H.azure !== void 0 && H.azure !== null ? a.AzureBlobUpload.fromPartial(H.azure) : void 0, we.aliOSS = H.aliOSS !== void 0 && H.aliOSS !== null ? a.AliOSSUpload.fromPartial(H.aliOSS) : void 0, we;
    }
  };
  function U() {
    return {
      protocol: 0,
      filenamePrefix: "",
      playlistName: "",
      segmentDuration: 0,
      disableManifest: !1,
      s3: void 0,
      gcp: void 0,
      azure: void 0,
      aliOSS: void 0
    };
  }
  a.SegmentedFileOutput = {
    encode(H, ye = l.default.Writer.create()) {
      return H.protocol !== void 0 && H.protocol !== 0 && ye.uint32(8).int32(H.protocol), H.filenamePrefix !== void 0 && H.filenamePrefix !== "" && ye.uint32(18).string(H.filenamePrefix), H.playlistName !== void 0 && H.playlistName !== "" && ye.uint32(26).string(H.playlistName), H.segmentDuration !== void 0 && H.segmentDuration !== 0 && ye.uint32(32).uint32(H.segmentDuration), H.disableManifest === !0 && ye.uint32(64).bool(H.disableManifest), H.s3 !== void 0 && a.S3Upload.encode(H.s3, ye.uint32(42).fork()).ldelim(), H.gcp !== void 0 && a.GCPUpload.encode(H.gcp, ye.uint32(50).fork()).ldelim(), H.azure !== void 0 && a.AzureBlobUpload.encode(H.azure, ye.uint32(58).fork()).ldelim(), H.aliOSS !== void 0 && a.AliOSSUpload.encode(H.aliOSS, ye.uint32(74).fork()).ldelim(), ye;
    },
    decode(H, ye) {
      const Ee = H instanceof l.default.Reader ? H : new l.default.Reader(H);
      let We = ye === void 0 ? Ee.len : Ee.pos + ye;
      const we = U();
      for (; Ee.pos < We; ) {
        const V = Ee.uint32();
        switch (V >>> 3) {
          case 1:
            we.protocol = Ee.int32();
            break;
          case 2:
            we.filenamePrefix = Ee.string();
            break;
          case 3:
            we.playlistName = Ee.string();
            break;
          case 4:
            we.segmentDuration = Ee.uint32();
            break;
          case 8:
            we.disableManifest = Ee.bool();
            break;
          case 5:
            we.s3 = a.S3Upload.decode(Ee, Ee.uint32());
            break;
          case 6:
            we.gcp = a.GCPUpload.decode(Ee, Ee.uint32());
            break;
          case 7:
            we.azure = a.AzureBlobUpload.decode(Ee, Ee.uint32());
            break;
          case 9:
            we.aliOSS = a.AliOSSUpload.decode(Ee, Ee.uint32());
            break;
          default:
            Ee.skipType(V & 7);
            break;
        }
      }
      return we;
    },
    fromJSON(H) {
      return {
        protocol: Ge(H.protocol) ? z(H.protocol) : 0,
        filenamePrefix: Ge(H.filenamePrefix) ? String(H.filenamePrefix) : "",
        playlistName: Ge(H.playlistName) ? String(H.playlistName) : "",
        segmentDuration: Ge(H.segmentDuration) ? Number(H.segmentDuration) : 0,
        disableManifest: Ge(H.disableManifest) ? !!H.disableManifest : !1,
        s3: Ge(H.s3) ? a.S3Upload.fromJSON(H.s3) : void 0,
        gcp: Ge(H.gcp) ? a.GCPUpload.fromJSON(H.gcp) : void 0,
        azure: Ge(H.azure) ? a.AzureBlobUpload.fromJSON(H.azure) : void 0,
        aliOSS: Ge(H.aliOSS) ? a.AliOSSUpload.fromJSON(H.aliOSS) : void 0
      };
    },
    toJSON(H) {
      const ye = {};
      return H.protocol !== void 0 && (ye.protocol = j(H.protocol)), H.filenamePrefix !== void 0 && (ye.filenamePrefix = H.filenamePrefix), H.playlistName !== void 0 && (ye.playlistName = H.playlistName), H.segmentDuration !== void 0 && (ye.segmentDuration = Math.round(H.segmentDuration)), H.disableManifest !== void 0 && (ye.disableManifest = H.disableManifest), H.s3 !== void 0 && (ye.s3 = H.s3 ? a.S3Upload.toJSON(H.s3) : void 0), H.gcp !== void 0 && (ye.gcp = H.gcp ? a.GCPUpload.toJSON(H.gcp) : void 0), H.azure !== void 0 && (ye.azure = H.azure ? a.AzureBlobUpload.toJSON(H.azure) : void 0), H.aliOSS !== void 0 && (ye.aliOSS = H.aliOSS ? a.AliOSSUpload.toJSON(H.aliOSS) : void 0), ye;
    },
    fromPartial(H) {
      var ye, Ee, We, we, V;
      const _e = U();
      return _e.protocol = (ye = H.protocol) !== null && ye !== void 0 ? ye : 0, _e.filenamePrefix = (Ee = H.filenamePrefix) !== null && Ee !== void 0 ? Ee : "", _e.playlistName = (We = H.playlistName) !== null && We !== void 0 ? We : "", _e.segmentDuration = (we = H.segmentDuration) !== null && we !== void 0 ? we : 0, _e.disableManifest = (V = H.disableManifest) !== null && V !== void 0 ? V : !1, _e.s3 = H.s3 !== void 0 && H.s3 !== null ? a.S3Upload.fromPartial(H.s3) : void 0, _e.gcp = H.gcp !== void 0 && H.gcp !== null ? a.GCPUpload.fromPartial(H.gcp) : void 0, _e.azure = H.azure !== void 0 && H.azure !== null ? a.AzureBlobUpload.fromPartial(H.azure) : void 0, _e.aliOSS = H.aliOSS !== void 0 && H.aliOSS !== null ? a.AliOSSUpload.fromPartial(H.aliOSS) : void 0, _e;
    }
  };
  function Y() {
    return { filepath: "", disableManifest: !1, s3: void 0, gcp: void 0, azure: void 0, aliOSS: void 0 };
  }
  a.DirectFileOutput = {
    encode(H, ye = l.default.Writer.create()) {
      return H.filepath !== void 0 && H.filepath !== "" && ye.uint32(10).string(H.filepath), H.disableManifest === !0 && ye.uint32(40).bool(H.disableManifest), H.s3 !== void 0 && a.S3Upload.encode(H.s3, ye.uint32(18).fork()).ldelim(), H.gcp !== void 0 && a.GCPUpload.encode(H.gcp, ye.uint32(26).fork()).ldelim(), H.azure !== void 0 && a.AzureBlobUpload.encode(H.azure, ye.uint32(34).fork()).ldelim(), H.aliOSS !== void 0 && a.AliOSSUpload.encode(H.aliOSS, ye.uint32(50).fork()).ldelim(), ye;
    },
    decode(H, ye) {
      const Ee = H instanceof l.default.Reader ? H : new l.default.Reader(H);
      let We = ye === void 0 ? Ee.len : Ee.pos + ye;
      const we = Y();
      for (; Ee.pos < We; ) {
        const V = Ee.uint32();
        switch (V >>> 3) {
          case 1:
            we.filepath = Ee.string();
            break;
          case 5:
            we.disableManifest = Ee.bool();
            break;
          case 2:
            we.s3 = a.S3Upload.decode(Ee, Ee.uint32());
            break;
          case 3:
            we.gcp = a.GCPUpload.decode(Ee, Ee.uint32());
            break;
          case 4:
            we.azure = a.AzureBlobUpload.decode(Ee, Ee.uint32());
            break;
          case 6:
            we.aliOSS = a.AliOSSUpload.decode(Ee, Ee.uint32());
            break;
          default:
            Ee.skipType(V & 7);
            break;
        }
      }
      return we;
    },
    fromJSON(H) {
      return {
        filepath: Ge(H.filepath) ? String(H.filepath) : "",
        disableManifest: Ge(H.disableManifest) ? !!H.disableManifest : !1,
        s3: Ge(H.s3) ? a.S3Upload.fromJSON(H.s3) : void 0,
        gcp: Ge(H.gcp) ? a.GCPUpload.fromJSON(H.gcp) : void 0,
        azure: Ge(H.azure) ? a.AzureBlobUpload.fromJSON(H.azure) : void 0,
        aliOSS: Ge(H.aliOSS) ? a.AliOSSUpload.fromJSON(H.aliOSS) : void 0
      };
    },
    toJSON(H) {
      const ye = {};
      return H.filepath !== void 0 && (ye.filepath = H.filepath), H.disableManifest !== void 0 && (ye.disableManifest = H.disableManifest), H.s3 !== void 0 && (ye.s3 = H.s3 ? a.S3Upload.toJSON(H.s3) : void 0), H.gcp !== void 0 && (ye.gcp = H.gcp ? a.GCPUpload.toJSON(H.gcp) : void 0), H.azure !== void 0 && (ye.azure = H.azure ? a.AzureBlobUpload.toJSON(H.azure) : void 0), H.aliOSS !== void 0 && (ye.aliOSS = H.aliOSS ? a.AliOSSUpload.toJSON(H.aliOSS) : void 0), ye;
    },
    fromPartial(H) {
      var ye, Ee;
      const We = Y();
      return We.filepath = (ye = H.filepath) !== null && ye !== void 0 ? ye : "", We.disableManifest = (Ee = H.disableManifest) !== null && Ee !== void 0 ? Ee : !1, We.s3 = H.s3 !== void 0 && H.s3 !== null ? a.S3Upload.fromPartial(H.s3) : void 0, We.gcp = H.gcp !== void 0 && H.gcp !== null ? a.GCPUpload.fromPartial(H.gcp) : void 0, We.azure = H.azure !== void 0 && H.azure !== null ? a.AzureBlobUpload.fromPartial(H.azure) : void 0, We.aliOSS = H.aliOSS !== void 0 && H.aliOSS !== null ? a.AliOSSUpload.fromPartial(H.aliOSS) : void 0, We;
    }
  };
  function L() {
    return {
      accessKey: "",
      secret: "",
      region: "",
      endpoint: "",
      bucket: "",
      forcePathStyle: !1,
      metadata: {},
      tagging: ""
    };
  }
  a.S3Upload = {
    encode(H, ye = l.default.Writer.create()) {
      return H.accessKey !== void 0 && H.accessKey !== "" && ye.uint32(10).string(H.accessKey), H.secret !== void 0 && H.secret !== "" && ye.uint32(18).string(H.secret), H.region !== void 0 && H.region !== "" && ye.uint32(26).string(H.region), H.endpoint !== void 0 && H.endpoint !== "" && ye.uint32(34).string(H.endpoint), H.bucket !== void 0 && H.bucket !== "" && ye.uint32(42).string(H.bucket), H.forcePathStyle === !0 && ye.uint32(48).bool(H.forcePathStyle), Object.entries(H.metadata || {}).forEach(([Ee, We]) => {
        a.S3Upload_MetadataEntry.encode({ key: Ee, value: We }, ye.uint32(58).fork()).ldelim();
      }), H.tagging !== void 0 && H.tagging !== "" && ye.uint32(66).string(H.tagging), ye;
    },
    decode(H, ye) {
      const Ee = H instanceof l.default.Reader ? H : new l.default.Reader(H);
      let We = ye === void 0 ? Ee.len : Ee.pos + ye;
      const we = L();
      for (; Ee.pos < We; ) {
        const V = Ee.uint32();
        switch (V >>> 3) {
          case 1:
            we.accessKey = Ee.string();
            break;
          case 2:
            we.secret = Ee.string();
            break;
          case 3:
            we.region = Ee.string();
            break;
          case 4:
            we.endpoint = Ee.string();
            break;
          case 5:
            we.bucket = Ee.string();
            break;
          case 6:
            we.forcePathStyle = Ee.bool();
            break;
          case 7:
            const _e = a.S3Upload_MetadataEntry.decode(Ee, Ee.uint32());
            _e.value !== void 0 && (we.metadata[_e.key] = _e.value);
            break;
          case 8:
            we.tagging = Ee.string();
            break;
          default:
            Ee.skipType(V & 7);
            break;
        }
      }
      return we;
    },
    fromJSON(H) {
      return {
        accessKey: Ge(H.accessKey) ? String(H.accessKey) : "",
        secret: Ge(H.secret) ? String(H.secret) : "",
        region: Ge(H.region) ? String(H.region) : "",
        endpoint: Ge(H.endpoint) ? String(H.endpoint) : "",
        bucket: Ge(H.bucket) ? String(H.bucket) : "",
        forcePathStyle: Ge(H.forcePathStyle) ? !!H.forcePathStyle : !1,
        metadata: Xe(H.metadata) ? Object.entries(H.metadata).reduce((ye, [Ee, We]) => (ye[Ee] = String(We), ye), {}) : {},
        tagging: Ge(H.tagging) ? String(H.tagging) : ""
      };
    },
    toJSON(H) {
      const ye = {};
      return H.accessKey !== void 0 && (ye.accessKey = H.accessKey), H.secret !== void 0 && (ye.secret = H.secret), H.region !== void 0 && (ye.region = H.region), H.endpoint !== void 0 && (ye.endpoint = H.endpoint), H.bucket !== void 0 && (ye.bucket = H.bucket), H.forcePathStyle !== void 0 && (ye.forcePathStyle = H.forcePathStyle), ye.metadata = {}, H.metadata && Object.entries(H.metadata).forEach(([Ee, We]) => {
        ye.metadata[Ee] = We;
      }), H.tagging !== void 0 && (ye.tagging = H.tagging), ye;
    },
    fromPartial(H) {
      var ye, Ee, We, we, V, _e, ue, ce;
      const me = L();
      return me.accessKey = (ye = H.accessKey) !== null && ye !== void 0 ? ye : "", me.secret = (Ee = H.secret) !== null && Ee !== void 0 ? Ee : "", me.region = (We = H.region) !== null && We !== void 0 ? We : "", me.endpoint = (we = H.endpoint) !== null && we !== void 0 ? we : "", me.bucket = (V = H.bucket) !== null && V !== void 0 ? V : "", me.forcePathStyle = (_e = H.forcePathStyle) !== null && _e !== void 0 ? _e : !1, me.metadata = Object.entries((ue = H.metadata) !== null && ue !== void 0 ? ue : {}).reduce((Ce, [Be, ze]) => (ze !== void 0 && (Ce[Be] = String(ze)), Ce), {}), me.tagging = (ce = H.tagging) !== null && ce !== void 0 ? ce : "", me;
    }
  };
  function T() {
    return { key: "", value: "" };
  }
  a.S3Upload_MetadataEntry = {
    encode(H, ye = l.default.Writer.create()) {
      return H.key !== "" && ye.uint32(10).string(H.key), H.value !== "" && ye.uint32(18).string(H.value), ye;
    },
    decode(H, ye) {
      const Ee = H instanceof l.default.Reader ? H : new l.default.Reader(H);
      let We = ye === void 0 ? Ee.len : Ee.pos + ye;
      const we = T();
      for (; Ee.pos < We; ) {
        const V = Ee.uint32();
        switch (V >>> 3) {
          case 1:
            we.key = Ee.string();
            break;
          case 2:
            we.value = Ee.string();
            break;
          default:
            Ee.skipType(V & 7);
            break;
        }
      }
      return we;
    },
    fromJSON(H) {
      return { key: Ge(H.key) ? String(H.key) : "", value: Ge(H.value) ? String(H.value) : "" };
    },
    toJSON(H) {
      const ye = {};
      return H.key !== void 0 && (ye.key = H.key), H.value !== void 0 && (ye.value = H.value), ye;
    },
    fromPartial(H) {
      var ye, Ee;
      const We = T();
      return We.key = (ye = H.key) !== null && ye !== void 0 ? ye : "", We.value = (Ee = H.value) !== null && Ee !== void 0 ? Ee : "", We;
    }
  };
  function B() {
    return { credentials: new Uint8Array(), bucket: "" };
  }
  a.GCPUpload = {
    encode(H, ye = l.default.Writer.create()) {
      return H.credentials !== void 0 && H.credentials.length !== 0 && ye.uint32(10).bytes(H.credentials), H.bucket !== void 0 && H.bucket !== "" && ye.uint32(18).string(H.bucket), ye;
    },
    decode(H, ye) {
      const Ee = H instanceof l.default.Reader ? H : new l.default.Reader(H);
      let We = ye === void 0 ? Ee.len : Ee.pos + ye;
      const we = B();
      for (; Ee.pos < We; ) {
        const V = Ee.uint32();
        switch (V >>> 3) {
          case 1:
            we.credentials = Ee.bytes();
            break;
          case 2:
            we.bucket = Ee.string();
            break;
          default:
            Ee.skipType(V & 7);
            break;
        }
      }
      return we;
    },
    fromJSON(H) {
      return {
        credentials: Ge(H.credentials) ? je(H.credentials) : new Uint8Array(),
        bucket: Ge(H.bucket) ? String(H.bucket) : ""
      };
    },
    toJSON(H) {
      const ye = {};
      return H.credentials !== void 0 && (ye.credentials = qe(H.credentials !== void 0 ? H.credentials : new Uint8Array())), H.bucket !== void 0 && (ye.bucket = H.bucket), ye;
    },
    fromPartial(H) {
      var ye, Ee;
      const We = B();
      return We.credentials = (ye = H.credentials) !== null && ye !== void 0 ? ye : new Uint8Array(), We.bucket = (Ee = H.bucket) !== null && Ee !== void 0 ? Ee : "", We;
    }
  };
  function te() {
    return { accountName: "", accountKey: "", containerName: "" };
  }
  a.AzureBlobUpload = {
    encode(H, ye = l.default.Writer.create()) {
      return H.accountName !== void 0 && H.accountName !== "" && ye.uint32(10).string(H.accountName), H.accountKey !== void 0 && H.accountKey !== "" && ye.uint32(18).string(H.accountKey), H.containerName !== void 0 && H.containerName !== "" && ye.uint32(26).string(H.containerName), ye;
    },
    decode(H, ye) {
      const Ee = H instanceof l.default.Reader ? H : new l.default.Reader(H);
      let We = ye === void 0 ? Ee.len : Ee.pos + ye;
      const we = te();
      for (; Ee.pos < We; ) {
        const V = Ee.uint32();
        switch (V >>> 3) {
          case 1:
            we.accountName = Ee.string();
            break;
          case 2:
            we.accountKey = Ee.string();
            break;
          case 3:
            we.containerName = Ee.string();
            break;
          default:
            Ee.skipType(V & 7);
            break;
        }
      }
      return we;
    },
    fromJSON(H) {
      return {
        accountName: Ge(H.accountName) ? String(H.accountName) : "",
        accountKey: Ge(H.accountKey) ? String(H.accountKey) : "",
        containerName: Ge(H.containerName) ? String(H.containerName) : ""
      };
    },
    toJSON(H) {
      const ye = {};
      return H.accountName !== void 0 && (ye.accountName = H.accountName), H.accountKey !== void 0 && (ye.accountKey = H.accountKey), H.containerName !== void 0 && (ye.containerName = H.containerName), ye;
    },
    fromPartial(H) {
      var ye, Ee, We;
      const we = te();
      return we.accountName = (ye = H.accountName) !== null && ye !== void 0 ? ye : "", we.accountKey = (Ee = H.accountKey) !== null && Ee !== void 0 ? Ee : "", we.containerName = (We = H.containerName) !== null && We !== void 0 ? We : "", we;
    }
  };
  function pe() {
    return { accessKey: "", secret: "", region: "", endpoint: "", bucket: "" };
  }
  a.AliOSSUpload = {
    encode(H, ye = l.default.Writer.create()) {
      return H.accessKey !== void 0 && H.accessKey !== "" && ye.uint32(10).string(H.accessKey), H.secret !== void 0 && H.secret !== "" && ye.uint32(18).string(H.secret), H.region !== void 0 && H.region !== "" && ye.uint32(26).string(H.region), H.endpoint !== void 0 && H.endpoint !== "" && ye.uint32(34).string(H.endpoint), H.bucket !== void 0 && H.bucket !== "" && ye.uint32(42).string(H.bucket), ye;
    },
    decode(H, ye) {
      const Ee = H instanceof l.default.Reader ? H : new l.default.Reader(H);
      let We = ye === void 0 ? Ee.len : Ee.pos + ye;
      const we = pe();
      for (; Ee.pos < We; ) {
        const V = Ee.uint32();
        switch (V >>> 3) {
          case 1:
            we.accessKey = Ee.string();
            break;
          case 2:
            we.secret = Ee.string();
            break;
          case 3:
            we.region = Ee.string();
            break;
          case 4:
            we.endpoint = Ee.string();
            break;
          case 5:
            we.bucket = Ee.string();
            break;
          default:
            Ee.skipType(V & 7);
            break;
        }
      }
      return we;
    },
    fromJSON(H) {
      return {
        accessKey: Ge(H.accessKey) ? String(H.accessKey) : "",
        secret: Ge(H.secret) ? String(H.secret) : "",
        region: Ge(H.region) ? String(H.region) : "",
        endpoint: Ge(H.endpoint) ? String(H.endpoint) : "",
        bucket: Ge(H.bucket) ? String(H.bucket) : ""
      };
    },
    toJSON(H) {
      const ye = {};
      return H.accessKey !== void 0 && (ye.accessKey = H.accessKey), H.secret !== void 0 && (ye.secret = H.secret), H.region !== void 0 && (ye.region = H.region), H.endpoint !== void 0 && (ye.endpoint = H.endpoint), H.bucket !== void 0 && (ye.bucket = H.bucket), ye;
    },
    fromPartial(H) {
      var ye, Ee, We, we, V;
      const _e = pe();
      return _e.accessKey = (ye = H.accessKey) !== null && ye !== void 0 ? ye : "", _e.secret = (Ee = H.secret) !== null && Ee !== void 0 ? Ee : "", _e.region = (We = H.region) !== null && We !== void 0 ? We : "", _e.endpoint = (we = H.endpoint) !== null && we !== void 0 ? we : "", _e.bucket = (V = H.bucket) !== null && V !== void 0 ? V : "", _e;
    }
  };
  function Ie() {
    return { protocol: 0, urls: [] };
  }
  a.StreamOutput = {
    encode(H, ye = l.default.Writer.create()) {
      if (H.protocol !== void 0 && H.protocol !== 0 && ye.uint32(8).int32(H.protocol), H.urls !== void 0 && H.urls.length !== 0)
        for (const Ee of H.urls)
          ye.uint32(18).string(Ee);
      return ye;
    },
    decode(H, ye) {
      const Ee = H instanceof l.default.Reader ? H : new l.default.Reader(H);
      let We = ye === void 0 ? Ee.len : Ee.pos + ye;
      const we = Ie();
      for (; Ee.pos < We; ) {
        const V = Ee.uint32();
        switch (V >>> 3) {
          case 1:
            we.protocol = Ee.int32();
            break;
          case 2:
            we.urls.push(Ee.string());
            break;
          default:
            Ee.skipType(V & 7);
            break;
        }
      }
      return we;
    },
    fromJSON(H) {
      return {
        protocol: Ge(H.protocol) ? O(H.protocol) : 0,
        urls: Array.isArray(H == null ? void 0 : H.urls) ? H.urls.map((ye) => String(ye)) : []
      };
    },
    toJSON(H) {
      const ye = {};
      return H.protocol !== void 0 && (ye.protocol = D(H.protocol)), H.urls ? ye.urls = H.urls.map((Ee) => Ee) : ye.urls = [], ye;
    },
    fromPartial(H) {
      var ye, Ee;
      const We = Ie();
      return We.protocol = (ye = H.protocol) !== null && ye !== void 0 ? ye : 0, We.urls = ((Ee = H.urls) === null || Ee === void 0 ? void 0 : Ee.map((we) => we)) || [], We;
    }
  };
  function $e() {
    return {
      width: 0,
      height: 0,
      depth: 0,
      framerate: 0,
      audioCodec: 0,
      audioBitrate: 0,
      audioFrequency: 0,
      videoCodec: 0,
      videoBitrate: 0
    };
  }
  a.EncodingOptions = {
    encode(H, ye = l.default.Writer.create()) {
      return H.width !== void 0 && H.width !== 0 && ye.uint32(8).int32(H.width), H.height !== void 0 && H.height !== 0 && ye.uint32(16).int32(H.height), H.depth !== void 0 && H.depth !== 0 && ye.uint32(24).int32(H.depth), H.framerate !== void 0 && H.framerate !== 0 && ye.uint32(32).int32(H.framerate), H.audioCodec !== void 0 && H.audioCodec !== 0 && ye.uint32(40).int32(H.audioCodec), H.audioBitrate !== void 0 && H.audioBitrate !== 0 && ye.uint32(48).int32(H.audioBitrate), H.audioFrequency !== void 0 && H.audioFrequency !== 0 && ye.uint32(56).int32(H.audioFrequency), H.videoCodec !== void 0 && H.videoCodec !== 0 && ye.uint32(64).int32(H.videoCodec), H.videoBitrate !== void 0 && H.videoBitrate !== 0 && ye.uint32(72).int32(H.videoBitrate), ye;
    },
    decode(H, ye) {
      const Ee = H instanceof l.default.Reader ? H : new l.default.Reader(H);
      let We = ye === void 0 ? Ee.len : Ee.pos + ye;
      const we = $e();
      for (; Ee.pos < We; ) {
        const V = Ee.uint32();
        switch (V >>> 3) {
          case 1:
            we.width = Ee.int32();
            break;
          case 2:
            we.height = Ee.int32();
            break;
          case 3:
            we.depth = Ee.int32();
            break;
          case 4:
            we.framerate = Ee.int32();
            break;
          case 5:
            we.audioCodec = Ee.int32();
            break;
          case 6:
            we.audioBitrate = Ee.int32();
            break;
          case 7:
            we.audioFrequency = Ee.int32();
            break;
          case 8:
            we.videoCodec = Ee.int32();
            break;
          case 9:
            we.videoBitrate = Ee.int32();
            break;
          default:
            Ee.skipType(V & 7);
            break;
        }
      }
      return we;
    },
    fromJSON(H) {
      return {
        width: Ge(H.width) ? Number(H.width) : 0,
        height: Ge(H.height) ? Number(H.height) : 0,
        depth: Ge(H.depth) ? Number(H.depth) : 0,
        framerate: Ge(H.framerate) ? Number(H.framerate) : 0,
        audioCodec: Ge(H.audioCodec) ? X(H.audioCodec) : 0,
        audioBitrate: Ge(H.audioBitrate) ? Number(H.audioBitrate) : 0,
        audioFrequency: Ge(H.audioFrequency) ? Number(H.audioFrequency) : 0,
        videoCodec: Ge(H.videoCodec) ? ne(H.videoCodec) : 0,
        videoBitrate: Ge(H.videoBitrate) ? Number(H.videoBitrate) : 0
      };
    },
    toJSON(H) {
      const ye = {};
      return H.width !== void 0 && (ye.width = Math.round(H.width)), H.height !== void 0 && (ye.height = Math.round(H.height)), H.depth !== void 0 && (ye.depth = Math.round(H.depth)), H.framerate !== void 0 && (ye.framerate = Math.round(H.framerate)), H.audioCodec !== void 0 && (ye.audioCodec = ae(H.audioCodec)), H.audioBitrate !== void 0 && (ye.audioBitrate = Math.round(H.audioBitrate)), H.audioFrequency !== void 0 && (ye.audioFrequency = Math.round(H.audioFrequency)), H.videoCodec !== void 0 && (ye.videoCodec = Z(H.videoCodec)), H.videoBitrate !== void 0 && (ye.videoBitrate = Math.round(H.videoBitrate)), ye;
    },
    fromPartial(H) {
      var ye, Ee, We, we, V, _e, ue, ce, me;
      const Ce = $e();
      return Ce.width = (ye = H.width) !== null && ye !== void 0 ? ye : 0, Ce.height = (Ee = H.height) !== null && Ee !== void 0 ? Ee : 0, Ce.depth = (We = H.depth) !== null && We !== void 0 ? We : 0, Ce.framerate = (we = H.framerate) !== null && we !== void 0 ? we : 0, Ce.audioCodec = (V = H.audioCodec) !== null && V !== void 0 ? V : 0, Ce.audioBitrate = (_e = H.audioBitrate) !== null && _e !== void 0 ? _e : 0, Ce.audioFrequency = (ue = H.audioFrequency) !== null && ue !== void 0 ? ue : 0, Ce.videoCodec = (ce = H.videoCodec) !== null && ce !== void 0 ? ce : 0, Ce.videoBitrate = (me = H.videoBitrate) !== null && me !== void 0 ? me : 0, Ce;
    }
  };
  function ve() {
    return { egressId: "", layout: "" };
  }
  a.UpdateLayoutRequest = {
    encode(H, ye = l.default.Writer.create()) {
      return H.egressId !== void 0 && H.egressId !== "" && ye.uint32(10).string(H.egressId), H.layout !== void 0 && H.layout !== "" && ye.uint32(18).string(H.layout), ye;
    },
    decode(H, ye) {
      const Ee = H instanceof l.default.Reader ? H : new l.default.Reader(H);
      let We = ye === void 0 ? Ee.len : Ee.pos + ye;
      const we = ve();
      for (; Ee.pos < We; ) {
        const V = Ee.uint32();
        switch (V >>> 3) {
          case 1:
            we.egressId = Ee.string();
            break;
          case 2:
            we.layout = Ee.string();
            break;
          default:
            Ee.skipType(V & 7);
            break;
        }
      }
      return we;
    },
    fromJSON(H) {
      return {
        egressId: Ge(H.egressId) ? String(H.egressId) : "",
        layout: Ge(H.layout) ? String(H.layout) : ""
      };
    },
    toJSON(H) {
      const ye = {};
      return H.egressId !== void 0 && (ye.egressId = H.egressId), H.layout !== void 0 && (ye.layout = H.layout), ye;
    },
    fromPartial(H) {
      var ye, Ee;
      const We = ve();
      return We.egressId = (ye = H.egressId) !== null && ye !== void 0 ? ye : "", We.layout = (Ee = H.layout) !== null && Ee !== void 0 ? Ee : "", We;
    }
  };
  function he() {
    return { egressId: "", addOutputUrls: [], removeOutputUrls: [] };
  }
  a.UpdateStreamRequest = {
    encode(H, ye = l.default.Writer.create()) {
      if (H.egressId !== void 0 && H.egressId !== "" && ye.uint32(10).string(H.egressId), H.addOutputUrls !== void 0 && H.addOutputUrls.length !== 0)
        for (const Ee of H.addOutputUrls)
          ye.uint32(18).string(Ee);
      if (H.removeOutputUrls !== void 0 && H.removeOutputUrls.length !== 0)
        for (const Ee of H.removeOutputUrls)
          ye.uint32(26).string(Ee);
      return ye;
    },
    decode(H, ye) {
      const Ee = H instanceof l.default.Reader ? H : new l.default.Reader(H);
      let We = ye === void 0 ? Ee.len : Ee.pos + ye;
      const we = he();
      for (; Ee.pos < We; ) {
        const V = Ee.uint32();
        switch (V >>> 3) {
          case 1:
            we.egressId = Ee.string();
            break;
          case 2:
            we.addOutputUrls.push(Ee.string());
            break;
          case 3:
            we.removeOutputUrls.push(Ee.string());
            break;
          default:
            Ee.skipType(V & 7);
            break;
        }
      }
      return we;
    },
    fromJSON(H) {
      return {
        egressId: Ge(H.egressId) ? String(H.egressId) : "",
        addOutputUrls: Array.isArray(H == null ? void 0 : H.addOutputUrls) ? H.addOutputUrls.map((ye) => String(ye)) : [],
        removeOutputUrls: Array.isArray(H == null ? void 0 : H.removeOutputUrls) ? H.removeOutputUrls.map((ye) => String(ye)) : []
      };
    },
    toJSON(H) {
      const ye = {};
      return H.egressId !== void 0 && (ye.egressId = H.egressId), H.addOutputUrls ? ye.addOutputUrls = H.addOutputUrls.map((Ee) => Ee) : ye.addOutputUrls = [], H.removeOutputUrls ? ye.removeOutputUrls = H.removeOutputUrls.map((Ee) => Ee) : ye.removeOutputUrls = [], ye;
    },
    fromPartial(H) {
      var ye, Ee, We;
      const we = he();
      return we.egressId = (ye = H.egressId) !== null && ye !== void 0 ? ye : "", we.addOutputUrls = ((Ee = H.addOutputUrls) === null || Ee === void 0 ? void 0 : Ee.map((V) => V)) || [], we.removeOutputUrls = ((We = H.removeOutputUrls) === null || We === void 0 ? void 0 : We.map((V) => V)) || [], we;
    }
  };
  function Oe() {
    return { roomName: "" };
  }
  a.ListEgressRequest = {
    encode(H, ye = l.default.Writer.create()) {
      return H.roomName !== void 0 && H.roomName !== "" && ye.uint32(10).string(H.roomName), ye;
    },
    decode(H, ye) {
      const Ee = H instanceof l.default.Reader ? H : new l.default.Reader(H);
      let We = ye === void 0 ? Ee.len : Ee.pos + ye;
      const we = Oe();
      for (; Ee.pos < We; ) {
        const V = Ee.uint32();
        switch (V >>> 3) {
          case 1:
            we.roomName = Ee.string();
            break;
          default:
            Ee.skipType(V & 7);
            break;
        }
      }
      return we;
    },
    fromJSON(H) {
      return { roomName: Ge(H.roomName) ? String(H.roomName) : "" };
    },
    toJSON(H) {
      const ye = {};
      return H.roomName !== void 0 && (ye.roomName = H.roomName), ye;
    },
    fromPartial(H) {
      var ye;
      const Ee = Oe();
      return Ee.roomName = (ye = H.roomName) !== null && ye !== void 0 ? ye : "", Ee;
    }
  };
  function Ae() {
    return { items: [] };
  }
  a.ListEgressResponse = {
    encode(H, ye = l.default.Writer.create()) {
      if (H.items !== void 0 && H.items.length !== 0)
        for (const Ee of H.items)
          a.EgressInfo.encode(Ee, ye.uint32(10).fork()).ldelim();
      return ye;
    },
    decode(H, ye) {
      const Ee = H instanceof l.default.Reader ? H : new l.default.Reader(H);
      let We = ye === void 0 ? Ee.len : Ee.pos + ye;
      const we = Ae();
      for (; Ee.pos < We; ) {
        const V = Ee.uint32();
        switch (V >>> 3) {
          case 1:
            we.items.push(a.EgressInfo.decode(Ee, Ee.uint32()));
            break;
          default:
            Ee.skipType(V & 7);
            break;
        }
      }
      return we;
    },
    fromJSON(H) {
      return { items: Array.isArray(H == null ? void 0 : H.items) ? H.items.map((ye) => a.EgressInfo.fromJSON(ye)) : [] };
    },
    toJSON(H) {
      const ye = {};
      return H.items ? ye.items = H.items.map((Ee) => Ee ? a.EgressInfo.toJSON(Ee) : void 0) : ye.items = [], ye;
    },
    fromPartial(H) {
      var ye;
      const Ee = Ae();
      return Ee.items = ((ye = H.items) === null || ye === void 0 ? void 0 : ye.map((We) => a.EgressInfo.fromPartial(We))) || [], Ee;
    }
  };
  function Ue() {
    return { egressId: "" };
  }
  a.StopEgressRequest = {
    encode(H, ye = l.default.Writer.create()) {
      return H.egressId !== void 0 && H.egressId !== "" && ye.uint32(10).string(H.egressId), ye;
    },
    decode(H, ye) {
      const Ee = H instanceof l.default.Reader ? H : new l.default.Reader(H);
      let We = ye === void 0 ? Ee.len : Ee.pos + ye;
      const we = Ue();
      for (; Ee.pos < We; ) {
        const V = Ee.uint32();
        switch (V >>> 3) {
          case 1:
            we.egressId = Ee.string();
            break;
          default:
            Ee.skipType(V & 7);
            break;
        }
      }
      return we;
    },
    fromJSON(H) {
      return { egressId: Ge(H.egressId) ? String(H.egressId) : "" };
    },
    toJSON(H) {
      const ye = {};
      return H.egressId !== void 0 && (ye.egressId = H.egressId), ye;
    },
    fromPartial(H) {
      var ye;
      const Ee = Ue();
      return Ee.egressId = (ye = H.egressId) !== null && ye !== void 0 ? ye : "", Ee;
    }
  };
  function oe() {
    return {
      egressId: "",
      roomId: "",
      roomName: "",
      status: 0,
      startedAt: 0,
      endedAt: 0,
      error: "",
      roomComposite: void 0,
      trackComposite: void 0,
      track: void 0,
      web: void 0,
      stream: void 0,
      file: void 0,
      segments: void 0
    };
  }
  a.EgressInfo = {
    encode(H, ye = l.default.Writer.create()) {
      return H.egressId !== void 0 && H.egressId !== "" && ye.uint32(10).string(H.egressId), H.roomId !== void 0 && H.roomId !== "" && ye.uint32(18).string(H.roomId), H.roomName !== void 0 && H.roomName !== "" && ye.uint32(106).string(H.roomName), H.status !== void 0 && H.status !== 0 && ye.uint32(24).int32(H.status), H.startedAt !== void 0 && H.startedAt !== 0 && ye.uint32(80).int64(H.startedAt), H.endedAt !== void 0 && H.endedAt !== 0 && ye.uint32(88).int64(H.endedAt), H.error !== void 0 && H.error !== "" && ye.uint32(74).string(H.error), H.roomComposite !== void 0 && a.RoomCompositeEgressRequest.encode(H.roomComposite, ye.uint32(34).fork()).ldelim(), H.trackComposite !== void 0 && a.TrackCompositeEgressRequest.encode(H.trackComposite, ye.uint32(42).fork()).ldelim(), H.track !== void 0 && a.TrackEgressRequest.encode(H.track, ye.uint32(50).fork()).ldelim(), H.web !== void 0 && a.WebEgressRequest.encode(H.web, ye.uint32(114).fork()).ldelim(), H.stream !== void 0 && a.StreamInfoList.encode(H.stream, ye.uint32(58).fork()).ldelim(), H.file !== void 0 && a.FileInfo.encode(H.file, ye.uint32(66).fork()).ldelim(), H.segments !== void 0 && a.SegmentsInfo.encode(H.segments, ye.uint32(98).fork()).ldelim(), ye;
    },
    decode(H, ye) {
      const Ee = H instanceof l.default.Reader ? H : new l.default.Reader(H);
      let We = ye === void 0 ? Ee.len : Ee.pos + ye;
      const we = oe();
      for (; Ee.pos < We; ) {
        const V = Ee.uint32();
        switch (V >>> 3) {
          case 1:
            we.egressId = Ee.string();
            break;
          case 2:
            we.roomId = Ee.string();
            break;
          case 13:
            we.roomName = Ee.string();
            break;
          case 3:
            we.status = Ee.int32();
            break;
          case 10:
            we.startedAt = yt(Ee.int64());
            break;
          case 11:
            we.endedAt = yt(Ee.int64());
            break;
          case 9:
            we.error = Ee.string();
            break;
          case 4:
            we.roomComposite = a.RoomCompositeEgressRequest.decode(Ee, Ee.uint32());
            break;
          case 5:
            we.trackComposite = a.TrackCompositeEgressRequest.decode(Ee, Ee.uint32());
            break;
          case 6:
            we.track = a.TrackEgressRequest.decode(Ee, Ee.uint32());
            break;
          case 14:
            we.web = a.WebEgressRequest.decode(Ee, Ee.uint32());
            break;
          case 7:
            we.stream = a.StreamInfoList.decode(Ee, Ee.uint32());
            break;
          case 8:
            we.file = a.FileInfo.decode(Ee, Ee.uint32());
            break;
          case 12:
            we.segments = a.SegmentsInfo.decode(Ee, Ee.uint32());
            break;
          default:
            Ee.skipType(V & 7);
            break;
        }
      }
      return we;
    },
    fromJSON(H) {
      return {
        egressId: Ge(H.egressId) ? String(H.egressId) : "",
        roomId: Ge(H.roomId) ? String(H.roomId) : "",
        roomName: Ge(H.roomName) ? String(H.roomName) : "",
        status: Ge(H.status) ? Le(H.status) : 0,
        startedAt: Ge(H.startedAt) ? Number(H.startedAt) : 0,
        endedAt: Ge(H.endedAt) ? Number(H.endedAt) : 0,
        error: Ge(H.error) ? String(H.error) : "",
        roomComposite: Ge(H.roomComposite) ? a.RoomCompositeEgressRequest.fromJSON(H.roomComposite) : void 0,
        trackComposite: Ge(H.trackComposite) ? a.TrackCompositeEgressRequest.fromJSON(H.trackComposite) : void 0,
        track: Ge(H.track) ? a.TrackEgressRequest.fromJSON(H.track) : void 0,
        web: Ge(H.web) ? a.WebEgressRequest.fromJSON(H.web) : void 0,
        stream: Ge(H.stream) ? a.StreamInfoList.fromJSON(H.stream) : void 0,
        file: Ge(H.file) ? a.FileInfo.fromJSON(H.file) : void 0,
        segments: Ge(H.segments) ? a.SegmentsInfo.fromJSON(H.segments) : void 0
      };
    },
    toJSON(H) {
      const ye = {};
      return H.egressId !== void 0 && (ye.egressId = H.egressId), H.roomId !== void 0 && (ye.roomId = H.roomId), H.roomName !== void 0 && (ye.roomName = H.roomName), H.status !== void 0 && (ye.status = be(H.status)), H.startedAt !== void 0 && (ye.startedAt = Math.round(H.startedAt)), H.endedAt !== void 0 && (ye.endedAt = Math.round(H.endedAt)), H.error !== void 0 && (ye.error = H.error), H.roomComposite !== void 0 && (ye.roomComposite = H.roomComposite ? a.RoomCompositeEgressRequest.toJSON(H.roomComposite) : void 0), H.trackComposite !== void 0 && (ye.trackComposite = H.trackComposite ? a.TrackCompositeEgressRequest.toJSON(H.trackComposite) : void 0), H.track !== void 0 && (ye.track = H.track ? a.TrackEgressRequest.toJSON(H.track) : void 0), H.web !== void 0 && (ye.web = H.web ? a.WebEgressRequest.toJSON(H.web) : void 0), H.stream !== void 0 && (ye.stream = H.stream ? a.StreamInfoList.toJSON(H.stream) : void 0), H.file !== void 0 && (ye.file = H.file ? a.FileInfo.toJSON(H.file) : void 0), H.segments !== void 0 && (ye.segments = H.segments ? a.SegmentsInfo.toJSON(H.segments) : void 0), ye;
    },
    fromPartial(H) {
      var ye, Ee, We, we, V, _e, ue;
      const ce = oe();
      return ce.egressId = (ye = H.egressId) !== null && ye !== void 0 ? ye : "", ce.roomId = (Ee = H.roomId) !== null && Ee !== void 0 ? Ee : "", ce.roomName = (We = H.roomName) !== null && We !== void 0 ? We : "", ce.status = (we = H.status) !== null && we !== void 0 ? we : 0, ce.startedAt = (V = H.startedAt) !== null && V !== void 0 ? V : 0, ce.endedAt = (_e = H.endedAt) !== null && _e !== void 0 ? _e : 0, ce.error = (ue = H.error) !== null && ue !== void 0 ? ue : "", ce.roomComposite = H.roomComposite !== void 0 && H.roomComposite !== null ? a.RoomCompositeEgressRequest.fromPartial(H.roomComposite) : void 0, ce.trackComposite = H.trackComposite !== void 0 && H.trackComposite !== null ? a.TrackCompositeEgressRequest.fromPartial(H.trackComposite) : void 0, ce.track = H.track !== void 0 && H.track !== null ? a.TrackEgressRequest.fromPartial(H.track) : void 0, ce.web = H.web !== void 0 && H.web !== null ? a.WebEgressRequest.fromPartial(H.web) : void 0, ce.stream = H.stream !== void 0 && H.stream !== null ? a.StreamInfoList.fromPartial(H.stream) : void 0, ce.file = H.file !== void 0 && H.file !== null ? a.FileInfo.fromPartial(H.file) : void 0, ce.segments = H.segments !== void 0 && H.segments !== null ? a.SegmentsInfo.fromPartial(H.segments) : void 0, ce;
    }
  };
  function A() {
    return { info: [] };
  }
  a.StreamInfoList = {
    encode(H, ye = l.default.Writer.create()) {
      if (H.info !== void 0 && H.info.length !== 0)
        for (const Ee of H.info)
          a.StreamInfo.encode(Ee, ye.uint32(10).fork()).ldelim();
      return ye;
    },
    decode(H, ye) {
      const Ee = H instanceof l.default.Reader ? H : new l.default.Reader(H);
      let We = ye === void 0 ? Ee.len : Ee.pos + ye;
      const we = A();
      for (; Ee.pos < We; ) {
        const V = Ee.uint32();
        switch (V >>> 3) {
          case 1:
            we.info.push(a.StreamInfo.decode(Ee, Ee.uint32()));
            break;
          default:
            Ee.skipType(V & 7);
            break;
        }
      }
      return we;
    },
    fromJSON(H) {
      return { info: Array.isArray(H == null ? void 0 : H.info) ? H.info.map((ye) => a.StreamInfo.fromJSON(ye)) : [] };
    },
    toJSON(H) {
      const ye = {};
      return H.info ? ye.info = H.info.map((Ee) => Ee ? a.StreamInfo.toJSON(Ee) : void 0) : ye.info = [], ye;
    },
    fromPartial(H) {
      var ye;
      const Ee = A();
      return Ee.info = ((ye = H.info) === null || ye === void 0 ? void 0 : ye.map((We) => a.StreamInfo.fromPartial(We))) || [], Ee;
    }
  };
  function re() {
    return { url: "", startedAt: 0, endedAt: 0, duration: 0, status: 0 };
  }
  a.StreamInfo = {
    encode(H, ye = l.default.Writer.create()) {
      return H.url !== void 0 && H.url !== "" && ye.uint32(10).string(H.url), H.startedAt !== void 0 && H.startedAt !== 0 && ye.uint32(16).int64(H.startedAt), H.endedAt !== void 0 && H.endedAt !== 0 && ye.uint32(24).int64(H.endedAt), H.duration !== void 0 && H.duration !== 0 && ye.uint32(32).int64(H.duration), H.status !== void 0 && H.status !== 0 && ye.uint32(40).int32(H.status), ye;
    },
    decode(H, ye) {
      const Ee = H instanceof l.default.Reader ? H : new l.default.Reader(H);
      let We = ye === void 0 ? Ee.len : Ee.pos + ye;
      const we = re();
      for (; Ee.pos < We; ) {
        const V = Ee.uint32();
        switch (V >>> 3) {
          case 1:
            we.url = Ee.string();
            break;
          case 2:
            we.startedAt = yt(Ee.int64());
            break;
          case 3:
            we.endedAt = yt(Ee.int64());
            break;
          case 4:
            we.duration = yt(Ee.int64());
            break;
          case 5:
            we.status = Ee.int32();
            break;
          default:
            Ee.skipType(V & 7);
            break;
        }
      }
      return we;
    },
    fromJSON(H) {
      return {
        url: Ge(H.url) ? String(H.url) : "",
        startedAt: Ge(H.startedAt) ? Number(H.startedAt) : 0,
        endedAt: Ge(H.endedAt) ? Number(H.endedAt) : 0,
        duration: Ge(H.duration) ? Number(H.duration) : 0,
        status: Ge(H.status) ? J(H.status) : 0
      };
    },
    toJSON(H) {
      const ye = {};
      return H.url !== void 0 && (ye.url = H.url), H.startedAt !== void 0 && (ye.startedAt = Math.round(H.startedAt)), H.endedAt !== void 0 && (ye.endedAt = Math.round(H.endedAt)), H.duration !== void 0 && (ye.duration = Math.round(H.duration)), H.status !== void 0 && (ye.status = C(H.status)), ye;
    },
    fromPartial(H) {
      var ye, Ee, We, we, V;
      const _e = re();
      return _e.url = (ye = H.url) !== null && ye !== void 0 ? ye : "", _e.startedAt = (Ee = H.startedAt) !== null && Ee !== void 0 ? Ee : 0, _e.endedAt = (We = H.endedAt) !== null && We !== void 0 ? We : 0, _e.duration = (we = H.duration) !== null && we !== void 0 ? we : 0, _e.status = (V = H.status) !== null && V !== void 0 ? V : 0, _e;
    }
  };
  function le() {
    return { filename: "", startedAt: 0, endedAt: 0, duration: 0, size: 0, location: "" };
  }
  a.FileInfo = {
    encode(H, ye = l.default.Writer.create()) {
      return H.filename !== void 0 && H.filename !== "" && ye.uint32(10).string(H.filename), H.startedAt !== void 0 && H.startedAt !== 0 && ye.uint32(16).int64(H.startedAt), H.endedAt !== void 0 && H.endedAt !== 0 && ye.uint32(24).int64(H.endedAt), H.duration !== void 0 && H.duration !== 0 && ye.uint32(48).int64(H.duration), H.size !== void 0 && H.size !== 0 && ye.uint32(32).int64(H.size), H.location !== void 0 && H.location !== "" && ye.uint32(42).string(H.location), ye;
    },
    decode(H, ye) {
      const Ee = H instanceof l.default.Reader ? H : new l.default.Reader(H);
      let We = ye === void 0 ? Ee.len : Ee.pos + ye;
      const we = le();
      for (; Ee.pos < We; ) {
        const V = Ee.uint32();
        switch (V >>> 3) {
          case 1:
            we.filename = Ee.string();
            break;
          case 2:
            we.startedAt = yt(Ee.int64());
            break;
          case 3:
            we.endedAt = yt(Ee.int64());
            break;
          case 6:
            we.duration = yt(Ee.int64());
            break;
          case 4:
            we.size = yt(Ee.int64());
            break;
          case 5:
            we.location = Ee.string();
            break;
          default:
            Ee.skipType(V & 7);
            break;
        }
      }
      return we;
    },
    fromJSON(H) {
      return {
        filename: Ge(H.filename) ? String(H.filename) : "",
        startedAt: Ge(H.startedAt) ? Number(H.startedAt) : 0,
        endedAt: Ge(H.endedAt) ? Number(H.endedAt) : 0,
        duration: Ge(H.duration) ? Number(H.duration) : 0,
        size: Ge(H.size) ? Number(H.size) : 0,
        location: Ge(H.location) ? String(H.location) : ""
      };
    },
    toJSON(H) {
      const ye = {};
      return H.filename !== void 0 && (ye.filename = H.filename), H.startedAt !== void 0 && (ye.startedAt = Math.round(H.startedAt)), H.endedAt !== void 0 && (ye.endedAt = Math.round(H.endedAt)), H.duration !== void 0 && (ye.duration = Math.round(H.duration)), H.size !== void 0 && (ye.size = Math.round(H.size)), H.location !== void 0 && (ye.location = H.location), ye;
    },
    fromPartial(H) {
      var ye, Ee, We, we, V, _e;
      const ue = le();
      return ue.filename = (ye = H.filename) !== null && ye !== void 0 ? ye : "", ue.startedAt = (Ee = H.startedAt) !== null && Ee !== void 0 ? Ee : 0, ue.endedAt = (We = H.endedAt) !== null && We !== void 0 ? We : 0, ue.duration = (we = H.duration) !== null && we !== void 0 ? we : 0, ue.size = (V = H.size) !== null && V !== void 0 ? V : 0, ue.location = (_e = H.location) !== null && _e !== void 0 ? _e : "", ue;
    }
  };
  function Ne() {
    return { playlistName: "", duration: 0, size: 0, playlistLocation: "", segmentCount: 0, startedAt: 0, endedAt: 0 };
  }
  a.SegmentsInfo = {
    encode(H, ye = l.default.Writer.create()) {
      return H.playlistName !== void 0 && H.playlistName !== "" && ye.uint32(10).string(H.playlistName), H.duration !== void 0 && H.duration !== 0 && ye.uint32(16).int64(H.duration), H.size !== void 0 && H.size !== 0 && ye.uint32(24).int64(H.size), H.playlistLocation !== void 0 && H.playlistLocation !== "" && ye.uint32(34).string(H.playlistLocation), H.segmentCount !== void 0 && H.segmentCount !== 0 && ye.uint32(40).int64(H.segmentCount), H.startedAt !== void 0 && H.startedAt !== 0 && ye.uint32(48).int64(H.startedAt), H.endedAt !== void 0 && H.endedAt !== 0 && ye.uint32(56).int64(H.endedAt), ye;
    },
    decode(H, ye) {
      const Ee = H instanceof l.default.Reader ? H : new l.default.Reader(H);
      let We = ye === void 0 ? Ee.len : Ee.pos + ye;
      const we = Ne();
      for (; Ee.pos < We; ) {
        const V = Ee.uint32();
        switch (V >>> 3) {
          case 1:
            we.playlistName = Ee.string();
            break;
          case 2:
            we.duration = yt(Ee.int64());
            break;
          case 3:
            we.size = yt(Ee.int64());
            break;
          case 4:
            we.playlistLocation = Ee.string();
            break;
          case 5:
            we.segmentCount = yt(Ee.int64());
            break;
          case 6:
            we.startedAt = yt(Ee.int64());
            break;
          case 7:
            we.endedAt = yt(Ee.int64());
            break;
          default:
            Ee.skipType(V & 7);
            break;
        }
      }
      return we;
    },
    fromJSON(H) {
      return {
        playlistName: Ge(H.playlistName) ? String(H.playlistName) : "",
        duration: Ge(H.duration) ? Number(H.duration) : 0,
        size: Ge(H.size) ? Number(H.size) : 0,
        playlistLocation: Ge(H.playlistLocation) ? String(H.playlistLocation) : "",
        segmentCount: Ge(H.segmentCount) ? Number(H.segmentCount) : 0,
        startedAt: Ge(H.startedAt) ? Number(H.startedAt) : 0,
        endedAt: Ge(H.endedAt) ? Number(H.endedAt) : 0
      };
    },
    toJSON(H) {
      const ye = {};
      return H.playlistName !== void 0 && (ye.playlistName = H.playlistName), H.duration !== void 0 && (ye.duration = Math.round(H.duration)), H.size !== void 0 && (ye.size = Math.round(H.size)), H.playlistLocation !== void 0 && (ye.playlistLocation = H.playlistLocation), H.segmentCount !== void 0 && (ye.segmentCount = Math.round(H.segmentCount)), H.startedAt !== void 0 && (ye.startedAt = Math.round(H.startedAt)), H.endedAt !== void 0 && (ye.endedAt = Math.round(H.endedAt)), ye;
    },
    fromPartial(H) {
      var ye, Ee, We, we, V, _e, ue;
      const ce = Ne();
      return ce.playlistName = (ye = H.playlistName) !== null && ye !== void 0 ? ye : "", ce.duration = (Ee = H.duration) !== null && Ee !== void 0 ? Ee : 0, ce.size = (We = H.size) !== null && We !== void 0 ? We : 0, ce.playlistLocation = (we = H.playlistLocation) !== null && we !== void 0 ? we : "", ce.segmentCount = (V = H.segmentCount) !== null && V !== void 0 ? V : 0, ce.startedAt = (_e = H.startedAt) !== null && _e !== void 0 ? _e : 0, ce.endedAt = (ue = H.endedAt) !== null && ue !== void 0 ? ue : 0, ce;
    }
  };
  function Pe() {
    return { filepath: "", disableManifest: !1, s3: void 0, gcp: void 0, azure: void 0 };
  }
  a.AutoTrackEgress = {
    encode(H, ye = l.default.Writer.create()) {
      return H.filepath !== void 0 && H.filepath !== "" && ye.uint32(10).string(H.filepath), H.disableManifest === !0 && ye.uint32(40).bool(H.disableManifest), H.s3 !== void 0 && a.S3Upload.encode(H.s3, ye.uint32(18).fork()).ldelim(), H.gcp !== void 0 && a.GCPUpload.encode(H.gcp, ye.uint32(26).fork()).ldelim(), H.azure !== void 0 && a.AzureBlobUpload.encode(H.azure, ye.uint32(34).fork()).ldelim(), ye;
    },
    decode(H, ye) {
      const Ee = H instanceof l.default.Reader ? H : new l.default.Reader(H);
      let We = ye === void 0 ? Ee.len : Ee.pos + ye;
      const we = Pe();
      for (; Ee.pos < We; ) {
        const V = Ee.uint32();
        switch (V >>> 3) {
          case 1:
            we.filepath = Ee.string();
            break;
          case 5:
            we.disableManifest = Ee.bool();
            break;
          case 2:
            we.s3 = a.S3Upload.decode(Ee, Ee.uint32());
            break;
          case 3:
            we.gcp = a.GCPUpload.decode(Ee, Ee.uint32());
            break;
          case 4:
            we.azure = a.AzureBlobUpload.decode(Ee, Ee.uint32());
            break;
          default:
            Ee.skipType(V & 7);
            break;
        }
      }
      return we;
    },
    fromJSON(H) {
      return {
        filepath: Ge(H.filepath) ? String(H.filepath) : "",
        disableManifest: Ge(H.disableManifest) ? !!H.disableManifest : !1,
        s3: Ge(H.s3) ? a.S3Upload.fromJSON(H.s3) : void 0,
        gcp: Ge(H.gcp) ? a.GCPUpload.fromJSON(H.gcp) : void 0,
        azure: Ge(H.azure) ? a.AzureBlobUpload.fromJSON(H.azure) : void 0
      };
    },
    toJSON(H) {
      const ye = {};
      return H.filepath !== void 0 && (ye.filepath = H.filepath), H.disableManifest !== void 0 && (ye.disableManifest = H.disableManifest), H.s3 !== void 0 && (ye.s3 = H.s3 ? a.S3Upload.toJSON(H.s3) : void 0), H.gcp !== void 0 && (ye.gcp = H.gcp ? a.GCPUpload.toJSON(H.gcp) : void 0), H.azure !== void 0 && (ye.azure = H.azure ? a.AzureBlobUpload.toJSON(H.azure) : void 0), ye;
    },
    fromPartial(H) {
      var ye, Ee;
      const We = Pe();
      return We.filepath = (ye = H.filepath) !== null && ye !== void 0 ? ye : "", We.disableManifest = (Ee = H.disableManifest) !== null && Ee !== void 0 ? Ee : !1, We.s3 = H.s3 !== void 0 && H.s3 !== null ? a.S3Upload.fromPartial(H.s3) : void 0, We.gcp = H.gcp !== void 0 && H.gcp !== null ? a.GCPUpload.fromPartial(H.gcp) : void 0, We.azure = H.azure !== void 0 && H.azure !== null ? a.AzureBlobUpload.fromPartial(H.azure) : void 0, We;
    }
  };
  var Fe = (() => {
    if (typeof Fe < "u")
      return Fe;
    if (typeof self < "u")
      return self;
    if (typeof window < "u")
      return window;
    if (typeof commonjsGlobal$1 < "u")
      return commonjsGlobal$1;
    throw "Unable to locate global object";
  })();
  function je(H) {
    if (Fe.Buffer)
      return Uint8Array.from(Fe.Buffer.from(H, "base64"));
    {
      const ye = Fe.atob(H), Ee = new Uint8Array(ye.length);
      for (let We = 0; We < ye.length; ++We)
        Ee[We] = ye.charCodeAt(We);
      return Ee;
    }
  }
  function qe(H) {
    if (Fe.Buffer)
      return Fe.Buffer.from(H).toString("base64");
    {
      const ye = [];
      return H.forEach((Ee) => {
        ye.push(String.fromCharCode(Ee));
      }), Fe.btoa(ye.join(""));
    }
  }
  function yt(H) {
    if (H.gt(Number.MAX_SAFE_INTEGER))
      throw new Fe.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    return H.toNumber();
  }
  l.default.util.Long !== c.default && (l.default.util.Long = c.default, l.default.configure());
  function Xe(H) {
    return typeof H == "object" && H !== null;
  }
  function Ge(H) {
    return H != null;
  }
})(livekit_egress);
var ServiceBase$1 = {};
Object.defineProperty(ServiceBase$1, "__esModule", { value: !0 });
const AccessToken_1$1 = AccessToken$1;
class ServiceBase {
  /**
   * @param apiKey API Key.
   * @param secret API Secret.
   * @param ttl token TTL
   */
  constructor(u, c, l) {
    this.apiKey = u, this.secret = c, this.ttl = l || "10m";
  }
  authHeader(u) {
    const c = new AccessToken_1$1.AccessToken(this.apiKey, this.secret, { ttl: this.ttl });
    return c.addGrant(u), {
      Authorization: `Bearer ${c.toJwt()}`
    };
  }
}
ServiceBase$1.default = ServiceBase;
var TwirpRPC = {}, axios$2 = { exports: {} }, bind$2 = function a(u, c) {
  return function() {
    for (var v = new Array(arguments.length), p = 0; p < v.length; p++)
      v[p] = arguments[p];
    return u.apply(c, v);
  };
}, bind$1 = bind$2, toString = Object.prototype.toString;
function isArray$1(a) {
  return toString.call(a) === "[object Array]";
}
function isUndefined(a) {
  return typeof a > "u";
}
function isBuffer(a) {
  return a !== null && !isUndefined(a) && a.constructor !== null && !isUndefined(a.constructor) && typeof a.constructor.isBuffer == "function" && a.constructor.isBuffer(a);
}
function isArrayBuffer(a) {
  return toString.call(a) === "[object ArrayBuffer]";
}
function isFormData(a) {
  return typeof FormData < "u" && a instanceof FormData;
}
function isArrayBufferView(a) {
  var u;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? u = ArrayBuffer.isView(a) : u = a && a.buffer && a.buffer instanceof ArrayBuffer, u;
}
function isString(a) {
  return typeof a == "string";
}
function isNumber(a) {
  return typeof a == "number";
}
function isObject$2(a) {
  return a !== null && typeof a == "object";
}
function isPlainObject(a) {
  if (toString.call(a) !== "[object Object]")
    return !1;
  var u = Object.getPrototypeOf(a);
  return u === null || u === Object.prototype;
}
function isDate(a) {
  return toString.call(a) === "[object Date]";
}
function isFile(a) {
  return toString.call(a) === "[object File]";
}
function isBlob(a) {
  return toString.call(a) === "[object Blob]";
}
function isFunction(a) {
  return toString.call(a) === "[object Function]";
}
function isStream(a) {
  return isObject$2(a) && isFunction(a.pipe);
}
function isURLSearchParams(a) {
  return typeof URLSearchParams < "u" && a instanceof URLSearchParams;
}
function trim$1(a) {
  return a.trim ? a.trim() : a.replace(/^\s+|\s+$/g, "");
}
function isStandardBrowserEnv() {
  return typeof navigator < "u" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS") ? !1 : typeof window < "u" && typeof document < "u";
}
function forEach(a, u) {
  if (!(a === null || typeof a > "u"))
    if (typeof a != "object" && (a = [a]), isArray$1(a))
      for (var c = 0, l = a.length; c < l; c++)
        u.call(null, a[c], c, a);
    else
      for (var v in a)
        Object.prototype.hasOwnProperty.call(a, v) && u.call(null, a[v], v, a);
}
function merge() {
  var a = {};
  function u(v, p) {
    isPlainObject(a[p]) && isPlainObject(v) ? a[p] = merge(a[p], v) : isPlainObject(v) ? a[p] = merge({}, v) : isArray$1(v) ? a[p] = v.slice() : a[p] = v;
  }
  for (var c = 0, l = arguments.length; c < l; c++)
    forEach(arguments[c], u);
  return a;
}
function extend(a, u, c) {
  return forEach(u, function(v, p) {
    c && typeof v == "function" ? a[p] = bind$1(v, c) : a[p] = v;
  }), a;
}
function stripBOM(a) {
  return a.charCodeAt(0) === 65279 && (a = a.slice(1)), a;
}
var utils$9 = {
  isArray: isArray$1,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isObject: isObject$2,
  isPlainObject,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isFunction,
  isStream,
  isURLSearchParams,
  isStandardBrowserEnv,
  forEach,
  merge,
  extend,
  trim: trim$1,
  stripBOM
}, utils$8 = utils$9;
function encode(a) {
  return encodeURIComponent(a).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
var buildURL$1 = function a(u, c, l) {
  if (!c)
    return u;
  var v;
  if (l)
    v = l(c);
  else if (utils$8.isURLSearchParams(c))
    v = c.toString();
  else {
    var p = [];
    utils$8.forEach(c, function(O, D) {
      O === null || typeof O > "u" || (utils$8.isArray(O) ? D = D + "[]" : O = [O], utils$8.forEach(O, function(z) {
        utils$8.isDate(z) ? z = z.toISOString() : utils$8.isObject(z) && (z = JSON.stringify(z)), p.push(encode(D) + "=" + encode(z));
      }));
    }), v = p.join("&");
  }
  if (v) {
    var _ = u.indexOf("#");
    _ !== -1 && (u = u.slice(0, _)), u += (u.indexOf("?") === -1 ? "?" : "&") + v;
  }
  return u;
}, utils$7 = utils$9;
function InterceptorManager$1() {
  this.handlers = [];
}
InterceptorManager$1.prototype.use = function a(u, c, l) {
  return this.handlers.push({
    fulfilled: u,
    rejected: c,
    synchronous: l ? l.synchronous : !1,
    runWhen: l ? l.runWhen : null
  }), this.handlers.length - 1;
};
InterceptorManager$1.prototype.eject = function a(u) {
  this.handlers[u] && (this.handlers[u] = null);
};
InterceptorManager$1.prototype.forEach = function a(u) {
  utils$7.forEach(this.handlers, function(l) {
    l !== null && u(l);
  });
};
var InterceptorManager_1 = InterceptorManager$1, utils$6 = utils$9, normalizeHeaderName$1 = function a(u, c) {
  utils$6.forEach(u, function(v, p) {
    p !== c && p.toUpperCase() === c.toUpperCase() && (u[c] = v, delete u[p]);
  });
}, enhanceError$1 = function a(u, c, l, v, p) {
  return u.config = c, l && (u.code = l), u.request = v, u.response = p, u.isAxiosError = !0, u.toJSON = function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code
    };
  }, u;
}, createError, hasRequiredCreateError;
function requireCreateError() {
  if (hasRequiredCreateError)
    return createError;
  hasRequiredCreateError = 1;
  var a = enhanceError$1;
  return createError = function(c, l, v, p, _) {
    var k = new Error(c);
    return a(k, l, v, p, _);
  }, createError;
}
var settle, hasRequiredSettle;
function requireSettle() {
  if (hasRequiredSettle)
    return settle;
  hasRequiredSettle = 1;
  var a = requireCreateError();
  return settle = function(c, l, v) {
    var p = v.config.validateStatus;
    !v.status || !p || p(v.status) ? c(v) : l(a(
      "Request failed with status code " + v.status,
      v.config,
      null,
      v.request,
      v
    ));
  }, settle;
}
var cookies, hasRequiredCookies;
function requireCookies() {
  if (hasRequiredCookies)
    return cookies;
  hasRequiredCookies = 1;
  var a = utils$9;
  return cookies = a.isStandardBrowserEnv() ? (
    // Standard browser envs support document.cookie
    /* @__PURE__ */ function() {
      return {
        write: function(l, v, p, _, k, O) {
          var D = [];
          D.push(l + "=" + encodeURIComponent(v)), a.isNumber(p) && D.push("expires=" + new Date(p).toGMTString()), a.isString(_) && D.push("path=" + _), a.isString(k) && D.push("domain=" + k), O === !0 && D.push("secure"), document.cookie = D.join("; ");
        },
        read: function(l) {
          var v = document.cookie.match(new RegExp("(^|;\\s*)(" + l + ")=([^;]*)"));
          return v ? decodeURIComponent(v[3]) : null;
        },
        remove: function(l) {
          this.write(l, "", Date.now() - 864e5);
        }
      };
    }()
  ) : (
    // Non standard browser env (web workers, react-native) lack needed support.
    /* @__PURE__ */ function() {
      return {
        write: function() {
        },
        read: function() {
          return null;
        },
        remove: function() {
        }
      };
    }()
  ), cookies;
}
var isAbsoluteURL, hasRequiredIsAbsoluteURL;
function requireIsAbsoluteURL() {
  return hasRequiredIsAbsoluteURL || (hasRequiredIsAbsoluteURL = 1, isAbsoluteURL = function(u) {
    return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(u);
  }), isAbsoluteURL;
}
var combineURLs, hasRequiredCombineURLs;
function requireCombineURLs() {
  return hasRequiredCombineURLs || (hasRequiredCombineURLs = 1, combineURLs = function(u, c) {
    return c ? u.replace(/\/+$/, "") + "/" + c.replace(/^\/+/, "") : u;
  }), combineURLs;
}
var buildFullPath, hasRequiredBuildFullPath;
function requireBuildFullPath() {
  if (hasRequiredBuildFullPath)
    return buildFullPath;
  hasRequiredBuildFullPath = 1;
  var a = requireIsAbsoluteURL(), u = requireCombineURLs();
  return buildFullPath = function(l, v) {
    return l && !a(v) ? u(l, v) : v;
  }, buildFullPath;
}
var parseHeaders, hasRequiredParseHeaders;
function requireParseHeaders() {
  if (hasRequiredParseHeaders)
    return parseHeaders;
  hasRequiredParseHeaders = 1;
  var a = utils$9, u = [
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ];
  return parseHeaders = function(l) {
    var v = {}, p, _, k;
    return l && a.forEach(l.split(`
`), function(D) {
      if (k = D.indexOf(":"), p = a.trim(D.substr(0, k)).toLowerCase(), _ = a.trim(D.substr(k + 1)), p) {
        if (v[p] && u.indexOf(p) >= 0)
          return;
        p === "set-cookie" ? v[p] = (v[p] ? v[p] : []).concat([_]) : v[p] = v[p] ? v[p] + ", " + _ : _;
      }
    }), v;
  }, parseHeaders;
}
var isURLSameOrigin, hasRequiredIsURLSameOrigin;
function requireIsURLSameOrigin() {
  if (hasRequiredIsURLSameOrigin)
    return isURLSameOrigin;
  hasRequiredIsURLSameOrigin = 1;
  var a = utils$9;
  return isURLSameOrigin = a.isStandardBrowserEnv() ? (
    // Standard browser envs have full support of the APIs needed to test
    // whether the request URL is of the same origin as current location.
    function() {
      var c = /(msie|trident)/i.test(navigator.userAgent), l = document.createElement("a"), v;
      function p(_) {
        var k = _;
        return c && (l.setAttribute("href", k), k = l.href), l.setAttribute("href", k), {
          href: l.href,
          protocol: l.protocol ? l.protocol.replace(/:$/, "") : "",
          host: l.host,
          search: l.search ? l.search.replace(/^\?/, "") : "",
          hash: l.hash ? l.hash.replace(/^#/, "") : "",
          hostname: l.hostname,
          port: l.port,
          pathname: l.pathname.charAt(0) === "/" ? l.pathname : "/" + l.pathname
        };
      }
      return v = p(window.location.href), function(k) {
        var O = a.isString(k) ? p(k) : k;
        return O.protocol === v.protocol && O.host === v.host;
      };
    }()
  ) : (
    // Non standard browser envs (web workers, react-native) lack needed support.
    /* @__PURE__ */ function() {
      return function() {
        return !0;
      };
    }()
  ), isURLSameOrigin;
}
var xhr, hasRequiredXhr;
function requireXhr() {
  if (hasRequiredXhr)
    return xhr;
  hasRequiredXhr = 1;
  var a = utils$9, u = requireSettle(), c = requireCookies(), l = buildURL$1, v = requireBuildFullPath(), p = requireParseHeaders(), _ = requireIsURLSameOrigin(), k = requireCreateError();
  return xhr = function(D) {
    return new Promise(function(z, j) {
      var ee = D.data, X = D.headers, ae = D.responseType;
      a.isFormData(ee) && delete X["Content-Type"];
      var Q = new XMLHttpRequest();
      if (D.auth) {
        var ne = D.auth.username || "", Z = D.auth.password ? unescape(encodeURIComponent(D.auth.password)) : "";
        X.Authorization = "Basic " + btoa(ne + ":" + Z);
      }
      var de = v(D.baseURL, D.url);
      Q.open(D.method.toUpperCase(), l(de, D.params, D.paramsSerializer), !0), Q.timeout = D.timeout;
      function fe() {
        if (Q) {
          var Re = "getAllResponseHeaders" in Q ? p(Q.getAllResponseHeaders()) : null, Le = !ae || ae === "text" || ae === "json" ? Q.responseText : Q.response, be = {
            data: Le,
            status: Q.status,
            statusText: Q.statusText,
            headers: Re,
            config: D,
            request: Q
          };
          u(z, j, be), Q = null;
        }
      }
      if ("onloadend" in Q ? Q.onloadend = fe : Q.onreadystatechange = function() {
        !Q || Q.readyState !== 4 || Q.status === 0 && !(Q.responseURL && Q.responseURL.indexOf("file:") === 0) || setTimeout(fe);
      }, Q.onabort = function() {
        Q && (j(k("Request aborted", D, "ECONNABORTED", Q)), Q = null);
      }, Q.onerror = function() {
        j(k("Network Error", D, null, Q)), Q = null;
      }, Q.ontimeout = function() {
        var Le = "timeout of " + D.timeout + "ms exceeded";
        D.timeoutErrorMessage && (Le = D.timeoutErrorMessage), j(k(
          Le,
          D,
          D.transitional && D.transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED",
          Q
        )), Q = null;
      }, a.isStandardBrowserEnv()) {
        var Te = (D.withCredentials || _(de)) && D.xsrfCookieName ? c.read(D.xsrfCookieName) : void 0;
        Te && (X[D.xsrfHeaderName] = Te);
      }
      "setRequestHeader" in Q && a.forEach(X, function(Le, be) {
        typeof ee > "u" && be.toLowerCase() === "content-type" ? delete X[be] : Q.setRequestHeader(be, Le);
      }), a.isUndefined(D.withCredentials) || (Q.withCredentials = !!D.withCredentials), ae && ae !== "json" && (Q.responseType = D.responseType), typeof D.onDownloadProgress == "function" && Q.addEventListener("progress", D.onDownloadProgress), typeof D.onUploadProgress == "function" && Q.upload && Q.upload.addEventListener("progress", D.onUploadProgress), D.cancelToken && D.cancelToken.promise.then(function(Le) {
        Q && (Q.abort(), j(Le), Q = null);
      }), ee || (ee = null), Q.send(ee);
    });
  }, xhr;
}
var utils$5 = utils$9, normalizeHeaderName = normalizeHeaderName$1, enhanceError = enhanceError$1, DEFAULT_CONTENT_TYPE = {
  "Content-Type": "application/x-www-form-urlencoded"
};
function setContentTypeIfUnset(a, u) {
  !utils$5.isUndefined(a) && utils$5.isUndefined(a["Content-Type"]) && (a["Content-Type"] = u);
}
function getDefaultAdapter() {
  var a;
  return (typeof XMLHttpRequest < "u" || typeof process$1 < "u" && Object.prototype.toString.call(process$1) === "[object process]") && (a = requireXhr()), a;
}
function stringifySafely(a, u, c) {
  if (utils$5.isString(a))
    try {
      return (u || JSON.parse)(a), utils$5.trim(a);
    } catch (l) {
      if (l.name !== "SyntaxError")
        throw l;
    }
  return (c || JSON.stringify)(a);
}
var defaults$3 = {
  transitional: {
    silentJSONParsing: !0,
    forcedJSONParsing: !0,
    clarifyTimeoutError: !1
  },
  adapter: getDefaultAdapter(),
  transformRequest: [function a(u, c) {
    return normalizeHeaderName(c, "Accept"), normalizeHeaderName(c, "Content-Type"), utils$5.isFormData(u) || utils$5.isArrayBuffer(u) || utils$5.isBuffer(u) || utils$5.isStream(u) || utils$5.isFile(u) || utils$5.isBlob(u) ? u : utils$5.isArrayBufferView(u) ? u.buffer : utils$5.isURLSearchParams(u) ? (setContentTypeIfUnset(c, "application/x-www-form-urlencoded;charset=utf-8"), u.toString()) : utils$5.isObject(u) || c && c["Content-Type"] === "application/json" ? (setContentTypeIfUnset(c, "application/json"), stringifySafely(u)) : u;
  }],
  transformResponse: [function a(u) {
    var c = this.transitional, l = c && c.silentJSONParsing, v = c && c.forcedJSONParsing, p = !l && this.responseType === "json";
    if (p || v && utils$5.isString(u) && u.length)
      try {
        return JSON.parse(u);
      } catch (_) {
        if (p)
          throw _.name === "SyntaxError" ? enhanceError(_, this, "E_JSON_PARSE") : _;
      }
    return u;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  validateStatus: function a(u) {
    return u >= 200 && u < 300;
  }
};
defaults$3.headers = {
  common: {
    Accept: "application/json, text/plain, */*"
  }
};
utils$5.forEach(["delete", "get", "head"], function a(u) {
  defaults$3.headers[u] = {};
});
utils$5.forEach(["post", "put", "patch"], function a(u) {
  defaults$3.headers[u] = utils$5.merge(DEFAULT_CONTENT_TYPE);
});
var defaults_1 = defaults$3, utils$4 = utils$9, defaults$2 = defaults_1, transformData$1 = function a(u, c, l) {
  var v = this || defaults$2;
  return utils$4.forEach(l, function(_) {
    u = _.call(v, u, c);
  }), u;
}, isCancel$1, hasRequiredIsCancel;
function requireIsCancel() {
  return hasRequiredIsCancel || (hasRequiredIsCancel = 1, isCancel$1 = function(u) {
    return !!(u && u.__CANCEL__);
  }), isCancel$1;
}
var utils$3 = utils$9, transformData = transformData$1, isCancel = requireIsCancel(), defaults$1 = defaults_1;
function throwIfCancellationRequested(a) {
  a.cancelToken && a.cancelToken.throwIfRequested();
}
var dispatchRequest$1 = function a(u) {
  throwIfCancellationRequested(u), u.headers = u.headers || {}, u.data = transformData.call(
    u,
    u.data,
    u.headers,
    u.transformRequest
  ), u.headers = utils$3.merge(
    u.headers.common || {},
    u.headers[u.method] || {},
    u.headers
  ), utils$3.forEach(
    ["delete", "get", "head", "post", "put", "patch", "common"],
    function(v) {
      delete u.headers[v];
    }
  );
  var c = u.adapter || defaults$1.adapter;
  return c(u).then(function(v) {
    return throwIfCancellationRequested(u), v.data = transformData.call(
      u,
      v.data,
      v.headers,
      u.transformResponse
    ), v;
  }, function(v) {
    return isCancel(v) || (throwIfCancellationRequested(u), v && v.response && (v.response.data = transformData.call(
      u,
      v.response.data,
      v.response.headers,
      u.transformResponse
    ))), Promise.reject(v);
  });
}, utils$2 = utils$9, mergeConfig$2 = function a(u, c) {
  c = c || {};
  var l = {}, v = ["url", "method", "data"], p = ["headers", "auth", "proxy", "params"], _ = [
    "baseURL",
    "transformRequest",
    "transformResponse",
    "paramsSerializer",
    "timeout",
    "timeoutMessage",
    "withCredentials",
    "adapter",
    "responseType",
    "xsrfCookieName",
    "xsrfHeaderName",
    "onUploadProgress",
    "onDownloadProgress",
    "decompress",
    "maxContentLength",
    "maxBodyLength",
    "maxRedirects",
    "transport",
    "httpAgent",
    "httpsAgent",
    "cancelToken",
    "socketPath",
    "responseEncoding"
  ], k = ["validateStatus"];
  function O(j, ee) {
    return utils$2.isPlainObject(j) && utils$2.isPlainObject(ee) ? utils$2.merge(j, ee) : utils$2.isPlainObject(ee) ? utils$2.merge({}, ee) : utils$2.isArray(ee) ? ee.slice() : ee;
  }
  function D(j) {
    utils$2.isUndefined(c[j]) ? utils$2.isUndefined(u[j]) || (l[j] = O(void 0, u[j])) : l[j] = O(u[j], c[j]);
  }
  utils$2.forEach(v, function(ee) {
    utils$2.isUndefined(c[ee]) || (l[ee] = O(void 0, c[ee]));
  }), utils$2.forEach(p, D), utils$2.forEach(_, function(ee) {
    utils$2.isUndefined(c[ee]) ? utils$2.isUndefined(u[ee]) || (l[ee] = O(void 0, u[ee])) : l[ee] = O(void 0, c[ee]);
  }), utils$2.forEach(k, function(ee) {
    ee in c ? l[ee] = O(u[ee], c[ee]) : ee in u && (l[ee] = O(void 0, u[ee]));
  });
  var F = v.concat(p).concat(_).concat(k), z = Object.keys(u).concat(Object.keys(c)).filter(function(ee) {
    return F.indexOf(ee) === -1;
  });
  return utils$2.forEach(z, D), l;
};
const name = "axios", version = "0.21.4", description = "Promise based HTTP client for the browser and node.js", main = "index.js", scripts = {
  test: "grunt test",
  start: "node ./sandbox/server.js",
  build: "NODE_ENV=production grunt build",
  preversion: "npm test",
  version: "npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json",
  postversion: "git push && git push --tags",
  examples: "node ./examples/server.js",
  coveralls: "cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js",
  fix: "eslint --fix lib/**/*.js"
}, repository = {
  type: "git",
  url: "https://github.com/axios/axios.git"
}, keywords = [
  "xhr",
  "http",
  "ajax",
  "promise",
  "node"
], author = "Matt Zabriskie", license = "MIT", bugs = {
  url: "https://github.com/axios/axios/issues"
}, homepage = "https://axios-http.com", devDependencies = {
  coveralls: "^3.0.0",
  "es6-promise": "^4.2.4",
  grunt: "^1.3.0",
  "grunt-banner": "^0.6.0",
  "grunt-cli": "^1.2.0",
  "grunt-contrib-clean": "^1.1.0",
  "grunt-contrib-watch": "^1.0.0",
  "grunt-eslint": "^23.0.0",
  "grunt-karma": "^4.0.0",
  "grunt-mocha-test": "^0.13.3",
  "grunt-ts": "^6.0.0-beta.19",
  "grunt-webpack": "^4.0.2",
  "istanbul-instrumenter-loader": "^1.0.0",
  "jasmine-core": "^2.4.1",
  karma: "^6.3.2",
  "karma-chrome-launcher": "^3.1.0",
  "karma-firefox-launcher": "^2.1.0",
  "karma-jasmine": "^1.1.1",
  "karma-jasmine-ajax": "^0.1.13",
  "karma-safari-launcher": "^1.0.0",
  "karma-sauce-launcher": "^4.3.6",
  "karma-sinon": "^1.0.5",
  "karma-sourcemap-loader": "^0.3.8",
  "karma-webpack": "^4.0.2",
  "load-grunt-tasks": "^3.5.2",
  minimist: "^1.2.0",
  mocha: "^8.2.1",
  sinon: "^4.5.0",
  "terser-webpack-plugin": "^4.2.3",
  typescript: "^4.0.5",
  "url-search-params": "^0.10.0",
  webpack: "^4.44.2",
  "webpack-dev-server": "^3.11.0"
}, browser = {
  "./lib/adapters/http.js": "./lib/adapters/xhr.js"
}, jsdelivr = "dist/axios.min.js", unpkg = "dist/axios.min.js", typings = "./index.d.ts", dependencies = {
  "follow-redirects": "^1.14.0"
}, bundlesize = [
  {
    path: "./dist/axios.min.js",
    threshold: "5kB"
  }
], require$$0 = {
  name,
  version,
  description,
  main,
  scripts,
  repository,
  keywords,
  author,
  license,
  bugs,
  homepage,
  devDependencies,
  browser,
  jsdelivr,
  unpkg,
  typings,
  dependencies,
  bundlesize
};
var pkg = require$$0, validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach(function(a, u) {
  validators$1[a] = function(l) {
    return typeof l === a || "a" + (u < 1 ? "n " : " ") + a;
  };
});
var deprecatedWarnings = {}, currentVerArr = pkg.version.split(".");
function isOlderVersion(a, u) {
  for (var c = u ? u.split(".") : currentVerArr, l = a.split("."), v = 0; v < 3; v++) {
    if (c[v] > l[v])
      return !0;
    if (c[v] < l[v])
      return !1;
  }
  return !1;
}
validators$1.transitional = function a(u, c, l) {
  var v = c && isOlderVersion(c);
  function p(_, k) {
    return "[Axios v" + pkg.version + "] Transitional option '" + _ + "'" + k + (l ? ". " + l : "");
  }
  return function(_, k, O) {
    if (u === !1)
      throw new Error(p(k, " has been removed in " + c));
    return v && !deprecatedWarnings[k] && (deprecatedWarnings[k] = !0, console.warn(
      p(
        k,
        " has been deprecated since v" + c + " and will be removed in the near future"
      )
    )), u ? u(_, k, O) : !0;
  };
};
function assertOptions(a, u, c) {
  if (typeof a != "object")
    throw new TypeError("options must be an object");
  for (var l = Object.keys(a), v = l.length; v-- > 0; ) {
    var p = l[v], _ = u[p];
    if (_) {
      var k = a[p], O = k === void 0 || _(k, p, a);
      if (O !== !0)
        throw new TypeError("option " + p + " must be " + O);
      continue;
    }
    if (c !== !0)
      throw Error("Unknown option " + p);
  }
}
var validator$1 = {
  isOlderVersion,
  assertOptions,
  validators: validators$1
}, utils$1 = utils$9, buildURL = buildURL$1, InterceptorManager = InterceptorManager_1, dispatchRequest = dispatchRequest$1, mergeConfig$1 = mergeConfig$2, validator = validator$1, validators = validator.validators;
function Axios$1(a) {
  this.defaults = a, this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}
Axios$1.prototype.request = function a(u) {
  typeof u == "string" ? (u = arguments[1] || {}, u.url = arguments[0]) : u = u || {}, u = mergeConfig$1(this.defaults, u), u.method ? u.method = u.method.toLowerCase() : this.defaults.method ? u.method = this.defaults.method.toLowerCase() : u.method = "get";
  var c = u.transitional;
  c !== void 0 && validator.assertOptions(c, {
    silentJSONParsing: validators.transitional(validators.boolean, "1.0.0"),
    forcedJSONParsing: validators.transitional(validators.boolean, "1.0.0"),
    clarifyTimeoutError: validators.transitional(validators.boolean, "1.0.0")
  }, !1);
  var l = [], v = !0;
  this.interceptors.request.forEach(function(j) {
    typeof j.runWhen == "function" && j.runWhen(u) === !1 || (v = v && j.synchronous, l.unshift(j.fulfilled, j.rejected));
  });
  var p = [];
  this.interceptors.response.forEach(function(j) {
    p.push(j.fulfilled, j.rejected);
  });
  var _;
  if (!v) {
    var k = [dispatchRequest, void 0];
    for (Array.prototype.unshift.apply(k, l), k = k.concat(p), _ = Promise.resolve(u); k.length; )
      _ = _.then(k.shift(), k.shift());
    return _;
  }
  for (var O = u; l.length; ) {
    var D = l.shift(), F = l.shift();
    try {
      O = D(O);
    } catch (z) {
      F(z);
      break;
    }
  }
  try {
    _ = dispatchRequest(O);
  } catch (z) {
    return Promise.reject(z);
  }
  for (; p.length; )
    _ = _.then(p.shift(), p.shift());
  return _;
};
Axios$1.prototype.getUri = function a(u) {
  return u = mergeConfig$1(this.defaults, u), buildURL(u.url, u.params, u.paramsSerializer).replace(/^\?/, "");
};
utils$1.forEach(["delete", "get", "head", "options"], function a(u) {
  Axios$1.prototype[u] = function(c, l) {
    return this.request(mergeConfig$1(l || {}, {
      method: u,
      url: c,
      data: (l || {}).data
    }));
  };
});
utils$1.forEach(["post", "put", "patch"], function a(u) {
  Axios$1.prototype[u] = function(c, l, v) {
    return this.request(mergeConfig$1(v || {}, {
      method: u,
      url: c,
      data: l
    }));
  };
});
var Axios_1 = Axios$1, Cancel_1, hasRequiredCancel;
function requireCancel() {
  if (hasRequiredCancel)
    return Cancel_1;
  hasRequiredCancel = 1;
  function a(u) {
    this.message = u;
  }
  return a.prototype.toString = function() {
    return "Cancel" + (this.message ? ": " + this.message : "");
  }, a.prototype.__CANCEL__ = !0, Cancel_1 = a, Cancel_1;
}
var CancelToken_1, hasRequiredCancelToken;
function requireCancelToken() {
  if (hasRequiredCancelToken)
    return CancelToken_1;
  hasRequiredCancelToken = 1;
  var a = requireCancel();
  function u(c) {
    if (typeof c != "function")
      throw new TypeError("executor must be a function.");
    var l;
    this.promise = new Promise(function(_) {
      l = _;
    });
    var v = this;
    c(function(_) {
      v.reason || (v.reason = new a(_), l(v.reason));
    });
  }
  return u.prototype.throwIfRequested = function() {
    if (this.reason)
      throw this.reason;
  }, u.source = function() {
    var l, v = new u(function(_) {
      l = _;
    });
    return {
      token: v,
      cancel: l
    };
  }, CancelToken_1 = u, CancelToken_1;
}
var spread, hasRequiredSpread;
function requireSpread() {
  return hasRequiredSpread || (hasRequiredSpread = 1, spread = function(u) {
    return function(l) {
      return u.apply(null, l);
    };
  }), spread;
}
var isAxiosError, hasRequiredIsAxiosError;
function requireIsAxiosError() {
  return hasRequiredIsAxiosError || (hasRequiredIsAxiosError = 1, isAxiosError = function(u) {
    return typeof u == "object" && u.isAxiosError === !0;
  }), isAxiosError;
}
var utils = utils$9, bind = bind$2, Axios = Axios_1, mergeConfig = mergeConfig$2, defaults = defaults_1;
function createInstance(a) {
  var u = new Axios(a), c = bind(Axios.prototype.request, u);
  return utils.extend(c, Axios.prototype, u), utils.extend(c, u), c;
}
var axios$1 = createInstance(defaults);
axios$1.Axios = Axios;
axios$1.create = function a(u) {
  return createInstance(mergeConfig(axios$1.defaults, u));
};
axios$1.Cancel = requireCancel();
axios$1.CancelToken = requireCancelToken();
axios$1.isCancel = requireIsCancel();
axios$1.all = function a(u) {
  return Promise.all(u);
};
axios$1.spread = requireSpread();
axios$1.isAxiosError = requireIsAxiosError();
axios$2.exports = axios$1;
axios$2.exports.default = axios$1;
var axiosExports = axios$2.exports, axios = axiosExports, mapObj$1 = { exports: {} };
const isObject$1 = (a) => typeof a == "object" && a !== null, mapObjectSkip = Symbol("skip"), isObjectCustom = (a) => isObject$1(a) && !(a instanceof RegExp) && !(a instanceof Error) && !(a instanceof Date), mapObject = (a, u, c, l = /* @__PURE__ */ new WeakMap()) => {
  if (c = {
    deep: !1,
    target: {},
    ...c
  }, l.has(a))
    return l.get(a);
  l.set(a, c.target);
  const { target: v } = c;
  delete c.target;
  const p = (_) => _.map((k) => isObjectCustom(k) ? mapObject(k, u, c, l) : k);
  if (Array.isArray(a))
    return p(a);
  for (const [_, k] of Object.entries(a)) {
    const O = u(_, k, a);
    if (O === mapObjectSkip)
      continue;
    let [D, F, { shouldRecurse: z = !0 } = {}] = O;
    D !== "__proto__" && (c.deep && z && isObjectCustom(F) && (F = Array.isArray(F) ? p(F) : mapObject(F, u, c, l)), v[D] = F);
  }
  return v;
};
mapObj$1.exports = (a, u, c) => {
  if (!isObject$1(a))
    throw new TypeError(`Expected an object, got \`${a}\` (${typeof a})`);
  return mapObject(a, u, c);
};
mapObj$1.exports.mapObjectSkip = mapObjectSkip;
var mapObjExports = mapObj$1.exports, camelcase = { exports: {} };
const UPPERCASE = /[\p{Lu}]/u, LOWERCASE = /[\p{Ll}]/u, LEADING_CAPITAL = /^[\p{Lu}](?![\p{Lu}])/gu, IDENTIFIER = /([\p{Alpha}\p{N}_]|$)/u, SEPARATORS = /[_.\- ]+/, LEADING_SEPARATORS = new RegExp("^" + SEPARATORS.source), SEPARATORS_AND_IDENTIFIER = new RegExp(SEPARATORS.source + IDENTIFIER.source, "gu"), NUMBERS_AND_IDENTIFIER = new RegExp("\\d+" + IDENTIFIER.source, "gu"), preserveCamelCase = (a, u, c) => {
  let l = !1, v = !1, p = !1;
  for (let _ = 0; _ < a.length; _++) {
    const k = a[_];
    l && UPPERCASE.test(k) ? (a = a.slice(0, _) + "-" + a.slice(_), l = !1, p = v, v = !0, _++) : v && p && LOWERCASE.test(k) ? (a = a.slice(0, _ - 1) + "-" + a.slice(_ - 1), p = v, v = !1, l = !0) : (l = u(k) === k && c(k) !== k, p = v, v = c(k) === k && u(k) !== k);
  }
  return a;
}, preserveConsecutiveUppercase = (a, u) => (LEADING_CAPITAL.lastIndex = 0, a.replace(LEADING_CAPITAL, (c) => u(c))), postProcess = (a, u) => (SEPARATORS_AND_IDENTIFIER.lastIndex = 0, NUMBERS_AND_IDENTIFIER.lastIndex = 0, a.replace(SEPARATORS_AND_IDENTIFIER, (c, l) => u(l)).replace(NUMBERS_AND_IDENTIFIER, (c) => u(c))), camelCase$1 = (a, u) => {
  if (!(typeof a == "string" || Array.isArray(a)))
    throw new TypeError("Expected the input to be `string | string[]`");
  if (u = {
    pascalCase: !1,
    preserveConsecutiveUppercase: !1,
    ...u
  }, Array.isArray(a) ? a = a.map((p) => p.trim()).filter((p) => p.length).join("-") : a = a.trim(), a.length === 0)
    return "";
  const c = u.locale === !1 ? (p) => p.toLowerCase() : (p) => p.toLocaleLowerCase(u.locale), l = u.locale === !1 ? (p) => p.toUpperCase() : (p) => p.toLocaleUpperCase(u.locale);
  return a.length === 1 ? u.pascalCase ? l(a) : c(a) : (a !== c(a) && (a = preserveCamelCase(a, c, l)), a = a.replace(LEADING_SEPARATORS, ""), u.preserveConsecutiveUppercase ? a = preserveConsecutiveUppercase(a, c) : a = c(a), u.pascalCase && (a = l(a.charAt(0)) + a.slice(1)), postProcess(a, l));
};
camelcase.exports = camelCase$1;
camelcase.exports.default = camelCase$1;
var camelcaseExports = camelcase.exports;
class QuickLRU {
  constructor(u = {}) {
    if (!(u.maxSize && u.maxSize > 0))
      throw new TypeError("`maxSize` must be a number greater than 0");
    this.maxSize = u.maxSize, this.onEviction = u.onEviction, this.cache = /* @__PURE__ */ new Map(), this.oldCache = /* @__PURE__ */ new Map(), this._size = 0;
  }
  _set(u, c) {
    if (this.cache.set(u, c), this._size++, this._size >= this.maxSize) {
      if (this._size = 0, typeof this.onEviction == "function")
        for (const [l, v] of this.oldCache.entries())
          this.onEviction(l, v);
      this.oldCache = this.cache, this.cache = /* @__PURE__ */ new Map();
    }
  }
  get(u) {
    if (this.cache.has(u))
      return this.cache.get(u);
    if (this.oldCache.has(u)) {
      const c = this.oldCache.get(u);
      return this.oldCache.delete(u), this._set(u, c), c;
    }
  }
  set(u, c) {
    return this.cache.has(u) ? this.cache.set(u, c) : this._set(u, c), this;
  }
  has(u) {
    return this.cache.has(u) || this.oldCache.has(u);
  }
  peek(u) {
    if (this.cache.has(u))
      return this.cache.get(u);
    if (this.oldCache.has(u))
      return this.oldCache.get(u);
  }
  delete(u) {
    const c = this.cache.delete(u);
    return c && this._size--, this.oldCache.delete(u) || c;
  }
  clear() {
    this.cache.clear(), this.oldCache.clear(), this._size = 0;
  }
  *keys() {
    for (const [u] of this)
      yield u;
  }
  *values() {
    for (const [, u] of this)
      yield u;
  }
  *[Symbol.iterator]() {
    for (const u of this.cache)
      yield u;
    for (const u of this.oldCache) {
      const [c] = u;
      this.cache.has(c) || (yield u);
    }
  }
  get size() {
    let u = 0;
    for (const c of this.oldCache.keys())
      this.cache.has(c) || u++;
    return Math.min(this._size + u, this.maxSize);
  }
}
var quickLru = QuickLRU;
const mapObj = mapObjExports, camelCase = camelcaseExports, QuickLru = quickLru, has$1 = (a, u) => a.some((c) => typeof c == "string" ? c === u : (c.lastIndex = 0, c.test(u))), cache$1 = new QuickLru({ maxSize: 1e5 }), isObject = (a) => typeof a == "object" && a !== null && !(a instanceof RegExp) && !(a instanceof Error) && !(a instanceof Date), camelCaseConvert = (a, u) => {
  if (!isObject(a))
    return a;
  u = {
    deep: !1,
    pascalCase: !1,
    ...u
  };
  const { exclude: c, pascalCase: l, stopPaths: v, deep: p } = u, _ = new Set(v), k = (O) => (D, F) => {
    if (p && isObject(F)) {
      const z = O === void 0 ? D : `${O}.${D}`;
      _.has(z) || (F = mapObj(F, k(z)));
    }
    if (!(c && has$1(c, D))) {
      const z = l ? `${D}_` : D;
      if (cache$1.has(z))
        D = cache$1.get(z);
      else {
        const j = camelCase(D, { pascalCase: l, locale: !1 });
        D.length < 100 && cache$1.set(z, j), D = j;
      }
    }
    return [D, F];
  };
  return mapObj(a, k(void 0));
};
var camelcaseKeys = (a, u) => Array.isArray(a) ? Object.keys(a).map((c) => camelCaseConvert(a[c], u)) : camelCaseConvert(a, u), __importDefault$6 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(TwirpRPC, "__esModule", { value: !0 });
TwirpRPC.TwirpRpc = TwirpRPC.livekitPackage = void 0;
const axios_1 = __importDefault$6(axios), camelcase_keys_1 = __importDefault$6(camelcaseKeys), defaultPrefix = "/twirp";
TwirpRPC.livekitPackage = "livekit";
class TwirpRpc {
  constructor(u, c, l, v) {
    this.host = u, this.pkg = c, this.prefix = l || defaultPrefix, this.instance = axios_1.default.create({
      baseURL: u,
      headers: Object.assign({}, v ? { Host: v } : {})
    });
  }
  request(u, c, l, v) {
    return new Promise((p, _) => {
      const k = `${this.prefix}/${this.pkg}.${u}/${c}`;
      this.instance.post(k, l, { headers: v }).then((O) => {
        p(camelcase_keys_1.default(O.data, { deep: !0 }));
      }).catch(_);
    });
  }
}
TwirpRPC.TwirpRpc = TwirpRpc;
var __awaiter$2 = commonjsGlobal$1 && commonjsGlobal$1.__awaiter || function(a, u, c, l) {
  function v(p) {
    return p instanceof c ? p : new c(function(_) {
      _(p);
    });
  }
  return new (c || (c = Promise))(function(p, _) {
    function k(F) {
      try {
        D(l.next(F));
      } catch (z) {
        _(z);
      }
    }
    function O(F) {
      try {
        D(l.throw(F));
      } catch (z) {
        _(z);
      }
    }
    function D(F) {
      F.done ? p(F.value) : v(F.value).then(k, O);
    }
    D((l = l.apply(a, u || [])).next());
  });
}, __importDefault$5 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(EgressClient$1, "__esModule", { value: !0 });
EgressClient$1.EgressClient = void 0;
const livekit_egress_1$1 = livekit_egress, ServiceBase_1$2 = __importDefault$5(ServiceBase$1), TwirpRPC_1$2 = TwirpRPC, svc$2 = "Egress";
class EgressClient extends ServiceBase_1$2.default {
  /**
   * @param host hostname including protocol. i.e. 'https://cluster.livekit.io'
   * @param apiKey API Key, can be set in env var LIVEKIT_API_KEY
   * @param secret API Secret, can be set in env var LIVEKIT_API_SECRET
   */
  constructor(u, c, l) {
    super(c, l), this.rpc = new TwirpRPC_1$2.TwirpRpc(u, TwirpRPC_1$2.livekitPackage);
  }
  startRoomCompositeEgress(u, c, l, v, p, _, k) {
    return __awaiter$2(this, void 0, void 0, function* () {
      let O;
      if (l !== void 0)
        if (typeof l == "string")
          O = l;
        else {
          const Q = l;
          O = Q.layout, v = Q.encodingOptions, p = Q.audioOnly, _ = Q.videoOnly, k = Q.customBaseUrl;
        }
      O ?? (O = ""), p ?? (p = !1), _ ?? (_ = !1), k ?? (k = "");
      const { file: D, segments: F, stream: z, preset: j, advanced: ee } = this.getOutputParams(c, v), X = livekit_egress_1$1.RoomCompositeEgressRequest.toJSON({
        roomName: u,
        layout: O,
        audioOnly: p,
        videoOnly: _,
        customBaseUrl: k,
        file: D,
        stream: z,
        segments: F,
        preset: j,
        advanced: ee
      }), ae = yield this.rpc.request(svc$2, "StartRoomCompositeEgress", X, this.authHeader({ roomRecord: !0 }));
      return livekit_egress_1$1.EgressInfo.fromJSON(ae);
    });
  }
  /**
   * @param url url
   * @param output file or stream output
   * @param opts WebOptions
   */
  startWebEgress(u, c, l) {
    return __awaiter$2(this, void 0, void 0, function* () {
      const v = (l == null ? void 0 : l.audioOnly) || !1, p = (l == null ? void 0 : l.videoOnly) || !1, { file: _, segments: k, stream: O, preset: D, advanced: F } = this.getOutputParams(c, l == null ? void 0 : l.encodingOptions), z = livekit_egress_1$1.WebEgressRequest.toJSON({
        url: u,
        audioOnly: v,
        videoOnly: p,
        file: _,
        stream: O,
        segments: k,
        preset: D,
        advanced: F
      }), j = yield this.rpc.request(svc$2, "StartWebEgress", z, this.authHeader({ roomRecord: !0 }));
      return livekit_egress_1$1.EgressInfo.fromJSON(j);
    });
  }
  startTrackCompositeEgress(u, c, l, v, p) {
    return __awaiter$2(this, void 0, void 0, function* () {
      let _;
      if (l !== void 0)
        if (typeof l == "string")
          _ = l;
        else {
          const X = l;
          _ = X.audioTrackId, v = X.videoTrackId, p = X.encodingOptions;
        }
      _ ?? (_ = ""), v ?? (v = "");
      const { file: k, segments: O, stream: D, preset: F, advanced: z } = this.getOutputParams(c, p), j = livekit_egress_1$1.TrackCompositeEgressRequest.toJSON({
        roomName: u,
        audioTrackId: _,
        videoTrackId: v,
        file: k,
        stream: D,
        segments: O,
        preset: F,
        advanced: z
      }), ee = yield this.rpc.request(svc$2, "StartTrackCompositeEgress", j, this.authHeader({ roomRecord: !0 }));
      return livekit_egress_1$1.EgressInfo.fromJSON(ee);
    });
  }
  getOutputParams(u, c) {
    let l, v, p, _, k;
    return u.filepath !== void 0 ? l = u : u.filenamePrefix !== void 0 ? p = u : v = u, c && (typeof c == "number" ? _ = c : k = c), { file: l, segments: p, stream: v, preset: _, advanced: k };
  }
  /**
   * @param roomName room name
   * @param output file or websocket output
   * @param trackId track Id
   */
  startTrackEgress(u, c, l) {
    return __awaiter$2(this, void 0, void 0, function* () {
      let v, p;
      c.filepath !== void 0 ? v = c : p = c;
      const _ = livekit_egress_1$1.TrackEgressRequest.toJSON({
        roomName: u,
        trackId: l,
        file: v,
        websocketUrl: p
      }), k = yield this.rpc.request(svc$2, "StartTrackEgress", _, this.authHeader({ roomRecord: !0 }));
      return livekit_egress_1$1.EgressInfo.fromJSON(k);
    });
  }
  /**
   * @param egressId
   * @param layout
   */
  updateLayout(u, c) {
    return __awaiter$2(this, void 0, void 0, function* () {
      const l = yield this.rpc.request(svc$2, "UpdateLayout", livekit_egress_1$1.UpdateLayoutRequest.toJSON({ egressId: u, layout: c }), this.authHeader({ roomRecord: !0 }));
      return livekit_egress_1$1.EgressInfo.fromJSON(l);
    });
  }
  /**
   * @param egressId
   * @param addOutputUrls
   * @param removeOutputUrls
   */
  updateStream(u, c, l) {
    return __awaiter$2(this, void 0, void 0, function* () {
      c ?? (c = []), l ?? (l = []);
      const v = yield this.rpc.request(svc$2, "UpdateStream", livekit_egress_1$1.UpdateStreamRequest.toJSON({ egressId: u, addOutputUrls: c, removeOutputUrls: l }), this.authHeader({ roomRecord: !0 }));
      return livekit_egress_1$1.EgressInfo.fromJSON(v);
    });
  }
  /**
   * @param roomName list egress for one room only
   */
  listEgress(u) {
    var c;
    return __awaiter$2(this, void 0, void 0, function* () {
      u ?? (u = "");
      const l = yield this.rpc.request(svc$2, "ListEgress", livekit_egress_1$1.ListEgressRequest.toJSON({ roomName: u }), this.authHeader({ roomRecord: !0 }));
      return (c = livekit_egress_1$1.ListEgressResponse.fromJSON(l).items) !== null && c !== void 0 ? c : [];
    });
  }
  /**
   * @param egressId
   */
  stopEgress(u) {
    return __awaiter$2(this, void 0, void 0, function* () {
      const c = yield this.rpc.request(svc$2, "StopEgress", livekit_egress_1$1.StopEgressRequest.toJSON({ egressId: u }), this.authHeader({ roomRecord: !0 }));
      return livekit_egress_1$1.EgressInfo.fromJSON(c);
    });
  }
}
EgressClient$1.EgressClient = EgressClient;
var grants = {};
Object.defineProperty(grants, "__esModule", { value: !0 });
var IngressClient$1 = {}, livekit_ingress = {}, livekit_models = {}, timestamp = {}, __importDefault$4 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(timestamp, "__esModule", { value: !0 });
timestamp.Timestamp = timestamp.protobufPackage = void 0;
const long_1$1 = __importDefault$4(umdExports), minimal_1$1 = __importDefault$4(minimal);
timestamp.protobufPackage = "google.protobuf";
function createBaseTimestamp() {
  return { seconds: 0, nanos: 0 };
}
timestamp.Timestamp = {
  encode(a, u = minimal_1$1.default.Writer.create()) {
    return a.seconds !== 0 && u.uint32(8).int64(a.seconds), a.nanos !== 0 && u.uint32(16).int32(a.nanos), u;
  },
  decode(a, u) {
    const c = a instanceof minimal_1$1.default.Reader ? a : new minimal_1$1.default.Reader(a);
    let l = u === void 0 ? c.len : c.pos + u;
    const v = createBaseTimestamp();
    for (; c.pos < l; ) {
      const p = c.uint32();
      switch (p >>> 3) {
        case 1:
          v.seconds = longToNumber$1(c.int64());
          break;
        case 2:
          v.nanos = c.int32();
          break;
        default:
          c.skipType(p & 7);
          break;
      }
    }
    return v;
  },
  fromJSON(a) {
    return {
      seconds: isSet$1(a.seconds) ? Number(a.seconds) : 0,
      nanos: isSet$1(a.nanos) ? Number(a.nanos) : 0
    };
  },
  toJSON(a) {
    const u = {};
    return a.seconds !== void 0 && (u.seconds = Math.round(a.seconds)), a.nanos !== void 0 && (u.nanos = Math.round(a.nanos)), u;
  },
  fromPartial(a) {
    var u, c;
    const l = createBaseTimestamp();
    return l.seconds = (u = a.seconds) !== null && u !== void 0 ? u : 0, l.nanos = (c = a.nanos) !== null && c !== void 0 ? c : 0, l;
  }
};
var globalThis$2 = (() => {
  if (typeof globalThis$2 < "u")
    return globalThis$2;
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof commonjsGlobal$1 < "u")
    return commonjsGlobal$1;
  throw "Unable to locate global object";
})();
function longToNumber$1(a) {
  if (a.gt(Number.MAX_SAFE_INTEGER))
    throw new globalThis$2.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  return a.toNumber();
}
minimal_1$1.default.util.Long !== long_1$1.default && (minimal_1$1.default.util.Long = long_1$1.default, minimal_1$1.default.configure());
function isSet$1(a) {
  return a != null;
}
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(V) {
    return V && V.__esModule ? V : { default: V };
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.RTPStats_GapHistogramEntry = a.RTPStats = a.DisabledCodecs = a.VideoConfiguration = a.ClientConfiguration = a.ClientInfo = a.ServerInfo = a.ParticipantTracks = a.UserPacket = a.SpeakerInfo = a.ActiveSpeakerUpdate = a.DataPacket = a.VideoLayer = a.TrackInfo = a.SimulcastCodecInfo = a.ParticipantInfo = a.ParticipantPermission = a.Codec = a.Room = a.clientInfo_SDKToJSON = a.clientInfo_SDKFromJSON = a.ClientInfo_SDK = a.serverInfo_EditionToJSON = a.serverInfo_EditionFromJSON = a.ServerInfo_Edition = a.dataPacket_KindToJSON = a.dataPacket_KindFromJSON = a.DataPacket_Kind = a.participantInfo_StateToJSON = a.participantInfo_StateFromJSON = a.ParticipantInfo_State = a.disconnectReasonToJSON = a.disconnectReasonFromJSON = a.DisconnectReason = a.clientConfigSettingToJSON = a.clientConfigSettingFromJSON = a.ClientConfigSetting = a.connectionQualityToJSON = a.connectionQualityFromJSON = a.ConnectionQuality = a.videoQualityToJSON = a.videoQualityFromJSON = a.VideoQuality = a.trackSourceToJSON = a.trackSourceFromJSON = a.TrackSource = a.trackTypeToJSON = a.trackTypeFromJSON = a.TrackType = a.protobufPackage = void 0, a.TimedVersion = void 0;
  const c = u(umdExports), l = u(minimal), v = timestamp;
  a.protobufPackage = "livekit";
  var p;
  (function(V) {
    V[V.AUDIO = 0] = "AUDIO", V[V.VIDEO = 1] = "VIDEO", V[V.DATA = 2] = "DATA", V[V.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(p = a.TrackType || (a.TrackType = {}));
  function _(V) {
    switch (V) {
      case 0:
      case "AUDIO":
        return p.AUDIO;
      case 1:
      case "VIDEO":
        return p.VIDEO;
      case 2:
      case "DATA":
        return p.DATA;
      case -1:
      case "UNRECOGNIZED":
      default:
        return p.UNRECOGNIZED;
    }
  }
  a.trackTypeFromJSON = _;
  function k(V) {
    switch (V) {
      case p.AUDIO:
        return "AUDIO";
      case p.VIDEO:
        return "VIDEO";
      case p.DATA:
        return "DATA";
      case p.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.trackTypeToJSON = k;
  var O;
  (function(V) {
    V[V.UNKNOWN = 0] = "UNKNOWN", V[V.CAMERA = 1] = "CAMERA", V[V.MICROPHONE = 2] = "MICROPHONE", V[V.SCREEN_SHARE = 3] = "SCREEN_SHARE", V[V.SCREEN_SHARE_AUDIO = 4] = "SCREEN_SHARE_AUDIO", V[V.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(O = a.TrackSource || (a.TrackSource = {}));
  function D(V) {
    switch (V) {
      case 0:
      case "UNKNOWN":
        return O.UNKNOWN;
      case 1:
      case "CAMERA":
        return O.CAMERA;
      case 2:
      case "MICROPHONE":
        return O.MICROPHONE;
      case 3:
      case "SCREEN_SHARE":
        return O.SCREEN_SHARE;
      case 4:
      case "SCREEN_SHARE_AUDIO":
        return O.SCREEN_SHARE_AUDIO;
      case -1:
      case "UNRECOGNIZED":
      default:
        return O.UNRECOGNIZED;
    }
  }
  a.trackSourceFromJSON = D;
  function F(V) {
    switch (V) {
      case O.UNKNOWN:
        return "UNKNOWN";
      case O.CAMERA:
        return "CAMERA";
      case O.MICROPHONE:
        return "MICROPHONE";
      case O.SCREEN_SHARE:
        return "SCREEN_SHARE";
      case O.SCREEN_SHARE_AUDIO:
        return "SCREEN_SHARE_AUDIO";
      case O.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.trackSourceToJSON = F;
  var z;
  (function(V) {
    V[V.LOW = 0] = "LOW", V[V.MEDIUM = 1] = "MEDIUM", V[V.HIGH = 2] = "HIGH", V[V.OFF = 3] = "OFF", V[V.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(z = a.VideoQuality || (a.VideoQuality = {}));
  function j(V) {
    switch (V) {
      case 0:
      case "LOW":
        return z.LOW;
      case 1:
      case "MEDIUM":
        return z.MEDIUM;
      case 2:
      case "HIGH":
        return z.HIGH;
      case 3:
      case "OFF":
        return z.OFF;
      case -1:
      case "UNRECOGNIZED":
      default:
        return z.UNRECOGNIZED;
    }
  }
  a.videoQualityFromJSON = j;
  function ee(V) {
    switch (V) {
      case z.LOW:
        return "LOW";
      case z.MEDIUM:
        return "MEDIUM";
      case z.HIGH:
        return "HIGH";
      case z.OFF:
        return "OFF";
      case z.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.videoQualityToJSON = ee;
  var X;
  (function(V) {
    V[V.POOR = 0] = "POOR", V[V.GOOD = 1] = "GOOD", V[V.EXCELLENT = 2] = "EXCELLENT", V[V.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(X = a.ConnectionQuality || (a.ConnectionQuality = {}));
  function ae(V) {
    switch (V) {
      case 0:
      case "POOR":
        return X.POOR;
      case 1:
      case "GOOD":
        return X.GOOD;
      case 2:
      case "EXCELLENT":
        return X.EXCELLENT;
      case -1:
      case "UNRECOGNIZED":
      default:
        return X.UNRECOGNIZED;
    }
  }
  a.connectionQualityFromJSON = ae;
  function Q(V) {
    switch (V) {
      case X.POOR:
        return "POOR";
      case X.GOOD:
        return "GOOD";
      case X.EXCELLENT:
        return "EXCELLENT";
      case X.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.connectionQualityToJSON = Q;
  var ne;
  (function(V) {
    V[V.UNSET = 0] = "UNSET", V[V.DISABLED = 1] = "DISABLED", V[V.ENABLED = 2] = "ENABLED", V[V.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(ne = a.ClientConfigSetting || (a.ClientConfigSetting = {}));
  function Z(V) {
    switch (V) {
      case 0:
      case "UNSET":
        return ne.UNSET;
      case 1:
      case "DISABLED":
        return ne.DISABLED;
      case 2:
      case "ENABLED":
        return ne.ENABLED;
      case -1:
      case "UNRECOGNIZED":
      default:
        return ne.UNRECOGNIZED;
    }
  }
  a.clientConfigSettingFromJSON = Z;
  function de(V) {
    switch (V) {
      case ne.UNSET:
        return "UNSET";
      case ne.DISABLED:
        return "DISABLED";
      case ne.ENABLED:
        return "ENABLED";
      case ne.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.clientConfigSettingToJSON = de;
  var fe;
  (function(V) {
    V[V.UNKNOWN_REASON = 0] = "UNKNOWN_REASON", V[V.CLIENT_INITIATED = 1] = "CLIENT_INITIATED", V[V.DUPLICATE_IDENTITY = 2] = "DUPLICATE_IDENTITY", V[V.SERVER_SHUTDOWN = 3] = "SERVER_SHUTDOWN", V[V.PARTICIPANT_REMOVED = 4] = "PARTICIPANT_REMOVED", V[V.ROOM_DELETED = 5] = "ROOM_DELETED", V[V.STATE_MISMATCH = 6] = "STATE_MISMATCH", V[V.JOIN_FAILURE = 7] = "JOIN_FAILURE", V[V.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(fe = a.DisconnectReason || (a.DisconnectReason = {}));
  function Te(V) {
    switch (V) {
      case 0:
      case "UNKNOWN_REASON":
        return fe.UNKNOWN_REASON;
      case 1:
      case "CLIENT_INITIATED":
        return fe.CLIENT_INITIATED;
      case 2:
      case "DUPLICATE_IDENTITY":
        return fe.DUPLICATE_IDENTITY;
      case 3:
      case "SERVER_SHUTDOWN":
        return fe.SERVER_SHUTDOWN;
      case 4:
      case "PARTICIPANT_REMOVED":
        return fe.PARTICIPANT_REMOVED;
      case 5:
      case "ROOM_DELETED":
        return fe.ROOM_DELETED;
      case 6:
      case "STATE_MISMATCH":
        return fe.STATE_MISMATCH;
      case 7:
      case "JOIN_FAILURE":
        return fe.JOIN_FAILURE;
      case -1:
      case "UNRECOGNIZED":
      default:
        return fe.UNRECOGNIZED;
    }
  }
  a.disconnectReasonFromJSON = Te;
  function Re(V) {
    switch (V) {
      case fe.UNKNOWN_REASON:
        return "UNKNOWN_REASON";
      case fe.CLIENT_INITIATED:
        return "CLIENT_INITIATED";
      case fe.DUPLICATE_IDENTITY:
        return "DUPLICATE_IDENTITY";
      case fe.SERVER_SHUTDOWN:
        return "SERVER_SHUTDOWN";
      case fe.PARTICIPANT_REMOVED:
        return "PARTICIPANT_REMOVED";
      case fe.ROOM_DELETED:
        return "ROOM_DELETED";
      case fe.STATE_MISMATCH:
        return "STATE_MISMATCH";
      case fe.JOIN_FAILURE:
        return "JOIN_FAILURE";
      case fe.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.disconnectReasonToJSON = Re;
  var Le;
  (function(V) {
    V[V.JOINING = 0] = "JOINING", V[V.JOINED = 1] = "JOINED", V[V.ACTIVE = 2] = "ACTIVE", V[V.DISCONNECTED = 3] = "DISCONNECTED", V[V.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(Le = a.ParticipantInfo_State || (a.ParticipantInfo_State = {}));
  function be(V) {
    switch (V) {
      case 0:
      case "JOINING":
        return Le.JOINING;
      case 1:
      case "JOINED":
        return Le.JOINED;
      case 2:
      case "ACTIVE":
        return Le.ACTIVE;
      case 3:
      case "DISCONNECTED":
        return Le.DISCONNECTED;
      case -1:
      case "UNRECOGNIZED":
      default:
        return Le.UNRECOGNIZED;
    }
  }
  a.participantInfo_StateFromJSON = be;
  function q(V) {
    switch (V) {
      case Le.JOINING:
        return "JOINING";
      case Le.JOINED:
        return "JOINED";
      case Le.ACTIVE:
        return "ACTIVE";
      case Le.DISCONNECTED:
        return "DISCONNECTED";
      case Le.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.participantInfo_StateToJSON = q;
  var J;
  (function(V) {
    V[V.RELIABLE = 0] = "RELIABLE", V[V.LOSSY = 1] = "LOSSY", V[V.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(J = a.DataPacket_Kind || (a.DataPacket_Kind = {}));
  function C(V) {
    switch (V) {
      case 0:
      case "RELIABLE":
        return J.RELIABLE;
      case 1:
      case "LOSSY":
        return J.LOSSY;
      case -1:
      case "UNRECOGNIZED":
      default:
        return J.UNRECOGNIZED;
    }
  }
  a.dataPacket_KindFromJSON = C;
  function S(V) {
    switch (V) {
      case J.RELIABLE:
        return "RELIABLE";
      case J.LOSSY:
        return "LOSSY";
      case J.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.dataPacket_KindToJSON = S;
  var E;
  (function(V) {
    V[V.Standard = 0] = "Standard", V[V.Cloud = 1] = "Cloud", V[V.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(E = a.ServerInfo_Edition || (a.ServerInfo_Edition = {}));
  function I(V) {
    switch (V) {
      case 0:
      case "Standard":
        return E.Standard;
      case 1:
      case "Cloud":
        return E.Cloud;
      case -1:
      case "UNRECOGNIZED":
      default:
        return E.UNRECOGNIZED;
    }
  }
  a.serverInfo_EditionFromJSON = I;
  function M(V) {
    switch (V) {
      case E.Standard:
        return "Standard";
      case E.Cloud:
        return "Cloud";
      case E.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.serverInfo_EditionToJSON = M;
  var $;
  (function(V) {
    V[V.UNKNOWN = 0] = "UNKNOWN", V[V.JS = 1] = "JS", V[V.SWIFT = 2] = "SWIFT", V[V.ANDROID = 3] = "ANDROID", V[V.FLUTTER = 4] = "FLUTTER", V[V.GO = 5] = "GO", V[V.UNITY = 6] = "UNITY", V[V.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })($ = a.ClientInfo_SDK || (a.ClientInfo_SDK = {}));
  function U(V) {
    switch (V) {
      case 0:
      case "UNKNOWN":
        return $.UNKNOWN;
      case 1:
      case "JS":
        return $.JS;
      case 2:
      case "SWIFT":
        return $.SWIFT;
      case 3:
      case "ANDROID":
        return $.ANDROID;
      case 4:
      case "FLUTTER":
        return $.FLUTTER;
      case 5:
      case "GO":
        return $.GO;
      case 6:
      case "UNITY":
        return $.UNITY;
      case -1:
      case "UNRECOGNIZED":
      default:
        return $.UNRECOGNIZED;
    }
  }
  a.clientInfo_SDKFromJSON = U;
  function Y(V) {
    switch (V) {
      case $.UNKNOWN:
        return "UNKNOWN";
      case $.JS:
        return "JS";
      case $.SWIFT:
        return "SWIFT";
      case $.ANDROID:
        return "ANDROID";
      case $.FLUTTER:
        return "FLUTTER";
      case $.GO:
        return "GO";
      case $.UNITY:
        return "UNITY";
      case $.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.clientInfo_SDKToJSON = Y;
  function L() {
    return {
      sid: "",
      name: "",
      emptyTimeout: 0,
      maxParticipants: 0,
      creationTime: 0,
      turnPassword: "",
      enabledCodecs: [],
      metadata: "",
      numParticipants: 0,
      activeRecording: !1
    };
  }
  a.Room = {
    encode(V, _e = l.default.Writer.create()) {
      V.sid !== "" && _e.uint32(10).string(V.sid), V.name !== "" && _e.uint32(18).string(V.name), V.emptyTimeout !== 0 && _e.uint32(24).uint32(V.emptyTimeout), V.maxParticipants !== 0 && _e.uint32(32).uint32(V.maxParticipants), V.creationTime !== 0 && _e.uint32(40).int64(V.creationTime), V.turnPassword !== "" && _e.uint32(50).string(V.turnPassword);
      for (const ue of V.enabledCodecs)
        a.Codec.encode(ue, _e.uint32(58).fork()).ldelim();
      return V.metadata !== "" && _e.uint32(66).string(V.metadata), V.numParticipants !== 0 && _e.uint32(72).uint32(V.numParticipants), V.activeRecording === !0 && _e.uint32(80).bool(V.activeRecording), _e;
    },
    decode(V, _e) {
      const ue = V instanceof l.default.Reader ? V : new l.default.Reader(V);
      let ce = _e === void 0 ? ue.len : ue.pos + _e;
      const me = L();
      for (; ue.pos < ce; ) {
        const Ce = ue.uint32();
        switch (Ce >>> 3) {
          case 1:
            me.sid = ue.string();
            break;
          case 2:
            me.name = ue.string();
            break;
          case 3:
            me.emptyTimeout = ue.uint32();
            break;
          case 4:
            me.maxParticipants = ue.uint32();
            break;
          case 5:
            me.creationTime = Ee(ue.int64());
            break;
          case 6:
            me.turnPassword = ue.string();
            break;
          case 7:
            me.enabledCodecs.push(a.Codec.decode(ue, ue.uint32()));
            break;
          case 8:
            me.metadata = ue.string();
            break;
          case 9:
            me.numParticipants = ue.uint32();
            break;
          case 10:
            me.activeRecording = ue.bool();
            break;
          default:
            ue.skipType(Ce & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(V) {
      return {
        sid: we(V.sid) ? String(V.sid) : "",
        name: we(V.name) ? String(V.name) : "",
        emptyTimeout: we(V.emptyTimeout) ? Number(V.emptyTimeout) : 0,
        maxParticipants: we(V.maxParticipants) ? Number(V.maxParticipants) : 0,
        creationTime: we(V.creationTime) ? Number(V.creationTime) : 0,
        turnPassword: we(V.turnPassword) ? String(V.turnPassword) : "",
        enabledCodecs: Array.isArray(V == null ? void 0 : V.enabledCodecs) ? V.enabledCodecs.map((_e) => a.Codec.fromJSON(_e)) : [],
        metadata: we(V.metadata) ? String(V.metadata) : "",
        numParticipants: we(V.numParticipants) ? Number(V.numParticipants) : 0,
        activeRecording: we(V.activeRecording) ? !!V.activeRecording : !1
      };
    },
    toJSON(V) {
      const _e = {};
      return V.sid !== void 0 && (_e.sid = V.sid), V.name !== void 0 && (_e.name = V.name), V.emptyTimeout !== void 0 && (_e.emptyTimeout = Math.round(V.emptyTimeout)), V.maxParticipants !== void 0 && (_e.maxParticipants = Math.round(V.maxParticipants)), V.creationTime !== void 0 && (_e.creationTime = Math.round(V.creationTime)), V.turnPassword !== void 0 && (_e.turnPassword = V.turnPassword), V.enabledCodecs ? _e.enabledCodecs = V.enabledCodecs.map((ue) => ue ? a.Codec.toJSON(ue) : void 0) : _e.enabledCodecs = [], V.metadata !== void 0 && (_e.metadata = V.metadata), V.numParticipants !== void 0 && (_e.numParticipants = Math.round(V.numParticipants)), V.activeRecording !== void 0 && (_e.activeRecording = V.activeRecording), _e;
    },
    fromPartial(V) {
      var _e, ue, ce, me, Ce, Be, ze, Je, Ze, Ke;
      const x = L();
      return x.sid = (_e = V.sid) !== null && _e !== void 0 ? _e : "", x.name = (ue = V.name) !== null && ue !== void 0 ? ue : "", x.emptyTimeout = (ce = V.emptyTimeout) !== null && ce !== void 0 ? ce : 0, x.maxParticipants = (me = V.maxParticipants) !== null && me !== void 0 ? me : 0, x.creationTime = (Ce = V.creationTime) !== null && Ce !== void 0 ? Ce : 0, x.turnPassword = (Be = V.turnPassword) !== null && Be !== void 0 ? Be : "", x.enabledCodecs = ((ze = V.enabledCodecs) === null || ze === void 0 ? void 0 : ze.map((se) => a.Codec.fromPartial(se))) || [], x.metadata = (Je = V.metadata) !== null && Je !== void 0 ? Je : "", x.numParticipants = (Ze = V.numParticipants) !== null && Ze !== void 0 ? Ze : 0, x.activeRecording = (Ke = V.activeRecording) !== null && Ke !== void 0 ? Ke : !1, x;
    }
  };
  function T() {
    return { mime: "", fmtpLine: "" };
  }
  a.Codec = {
    encode(V, _e = l.default.Writer.create()) {
      return V.mime !== "" && _e.uint32(10).string(V.mime), V.fmtpLine !== "" && _e.uint32(18).string(V.fmtpLine), _e;
    },
    decode(V, _e) {
      const ue = V instanceof l.default.Reader ? V : new l.default.Reader(V);
      let ce = _e === void 0 ? ue.len : ue.pos + _e;
      const me = T();
      for (; ue.pos < ce; ) {
        const Ce = ue.uint32();
        switch (Ce >>> 3) {
          case 1:
            me.mime = ue.string();
            break;
          case 2:
            me.fmtpLine = ue.string();
            break;
          default:
            ue.skipType(Ce & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(V) {
      return {
        mime: we(V.mime) ? String(V.mime) : "",
        fmtpLine: we(V.fmtpLine) ? String(V.fmtpLine) : ""
      };
    },
    toJSON(V) {
      const _e = {};
      return V.mime !== void 0 && (_e.mime = V.mime), V.fmtpLine !== void 0 && (_e.fmtpLine = V.fmtpLine), _e;
    },
    fromPartial(V) {
      var _e, ue;
      const ce = T();
      return ce.mime = (_e = V.mime) !== null && _e !== void 0 ? _e : "", ce.fmtpLine = (ue = V.fmtpLine) !== null && ue !== void 0 ? ue : "", ce;
    }
  };
  function B() {
    return { canSubscribe: !1, canPublish: !1, canPublishData: !1, hidden: !1, recorder: !1 };
  }
  a.ParticipantPermission = {
    encode(V, _e = l.default.Writer.create()) {
      return V.canSubscribe === !0 && _e.uint32(8).bool(V.canSubscribe), V.canPublish === !0 && _e.uint32(16).bool(V.canPublish), V.canPublishData === !0 && _e.uint32(24).bool(V.canPublishData), V.hidden === !0 && _e.uint32(56).bool(V.hidden), V.recorder === !0 && _e.uint32(64).bool(V.recorder), _e;
    },
    decode(V, _e) {
      const ue = V instanceof l.default.Reader ? V : new l.default.Reader(V);
      let ce = _e === void 0 ? ue.len : ue.pos + _e;
      const me = B();
      for (; ue.pos < ce; ) {
        const Ce = ue.uint32();
        switch (Ce >>> 3) {
          case 1:
            me.canSubscribe = ue.bool();
            break;
          case 2:
            me.canPublish = ue.bool();
            break;
          case 3:
            me.canPublishData = ue.bool();
            break;
          case 7:
            me.hidden = ue.bool();
            break;
          case 8:
            me.recorder = ue.bool();
            break;
          default:
            ue.skipType(Ce & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(V) {
      return {
        canSubscribe: we(V.canSubscribe) ? !!V.canSubscribe : !1,
        canPublish: we(V.canPublish) ? !!V.canPublish : !1,
        canPublishData: we(V.canPublishData) ? !!V.canPublishData : !1,
        hidden: we(V.hidden) ? !!V.hidden : !1,
        recorder: we(V.recorder) ? !!V.recorder : !1
      };
    },
    toJSON(V) {
      const _e = {};
      return V.canSubscribe !== void 0 && (_e.canSubscribe = V.canSubscribe), V.canPublish !== void 0 && (_e.canPublish = V.canPublish), V.canPublishData !== void 0 && (_e.canPublishData = V.canPublishData), V.hidden !== void 0 && (_e.hidden = V.hidden), V.recorder !== void 0 && (_e.recorder = V.recorder), _e;
    },
    fromPartial(V) {
      var _e, ue, ce, me, Ce;
      const Be = B();
      return Be.canSubscribe = (_e = V.canSubscribe) !== null && _e !== void 0 ? _e : !1, Be.canPublish = (ue = V.canPublish) !== null && ue !== void 0 ? ue : !1, Be.canPublishData = (ce = V.canPublishData) !== null && ce !== void 0 ? ce : !1, Be.hidden = (me = V.hidden) !== null && me !== void 0 ? me : !1, Be.recorder = (Ce = V.recorder) !== null && Ce !== void 0 ? Ce : !1, Be;
    }
  };
  function te() {
    return {
      sid: "",
      identity: "",
      state: 0,
      tracks: [],
      metadata: "",
      joinedAt: 0,
      name: "",
      version: 0,
      permission: void 0,
      region: "",
      isPublisher: !1
    };
  }
  a.ParticipantInfo = {
    encode(V, _e = l.default.Writer.create()) {
      V.sid !== "" && _e.uint32(10).string(V.sid), V.identity !== "" && _e.uint32(18).string(V.identity), V.state !== 0 && _e.uint32(24).int32(V.state);
      for (const ue of V.tracks)
        a.TrackInfo.encode(ue, _e.uint32(34).fork()).ldelim();
      return V.metadata !== "" && _e.uint32(42).string(V.metadata), V.joinedAt !== 0 && _e.uint32(48).int64(V.joinedAt), V.name !== "" && _e.uint32(74).string(V.name), V.version !== 0 && _e.uint32(80).uint32(V.version), V.permission !== void 0 && a.ParticipantPermission.encode(V.permission, _e.uint32(90).fork()).ldelim(), V.region !== "" && _e.uint32(98).string(V.region), V.isPublisher === !0 && _e.uint32(104).bool(V.isPublisher), _e;
    },
    decode(V, _e) {
      const ue = V instanceof l.default.Reader ? V : new l.default.Reader(V);
      let ce = _e === void 0 ? ue.len : ue.pos + _e;
      const me = te();
      for (; ue.pos < ce; ) {
        const Ce = ue.uint32();
        switch (Ce >>> 3) {
          case 1:
            me.sid = ue.string();
            break;
          case 2:
            me.identity = ue.string();
            break;
          case 3:
            me.state = ue.int32();
            break;
          case 4:
            me.tracks.push(a.TrackInfo.decode(ue, ue.uint32()));
            break;
          case 5:
            me.metadata = ue.string();
            break;
          case 6:
            me.joinedAt = Ee(ue.int64());
            break;
          case 9:
            me.name = ue.string();
            break;
          case 10:
            me.version = ue.uint32();
            break;
          case 11:
            me.permission = a.ParticipantPermission.decode(ue, ue.uint32());
            break;
          case 12:
            me.region = ue.string();
            break;
          case 13:
            me.isPublisher = ue.bool();
            break;
          default:
            ue.skipType(Ce & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(V) {
      return {
        sid: we(V.sid) ? String(V.sid) : "",
        identity: we(V.identity) ? String(V.identity) : "",
        state: we(V.state) ? be(V.state) : 0,
        tracks: Array.isArray(V == null ? void 0 : V.tracks) ? V.tracks.map((_e) => a.TrackInfo.fromJSON(_e)) : [],
        metadata: we(V.metadata) ? String(V.metadata) : "",
        joinedAt: we(V.joinedAt) ? Number(V.joinedAt) : 0,
        name: we(V.name) ? String(V.name) : "",
        version: we(V.version) ? Number(V.version) : 0,
        permission: we(V.permission) ? a.ParticipantPermission.fromJSON(V.permission) : void 0,
        region: we(V.region) ? String(V.region) : "",
        isPublisher: we(V.isPublisher) ? !!V.isPublisher : !1
      };
    },
    toJSON(V) {
      const _e = {};
      return V.sid !== void 0 && (_e.sid = V.sid), V.identity !== void 0 && (_e.identity = V.identity), V.state !== void 0 && (_e.state = q(V.state)), V.tracks ? _e.tracks = V.tracks.map((ue) => ue ? a.TrackInfo.toJSON(ue) : void 0) : _e.tracks = [], V.metadata !== void 0 && (_e.metadata = V.metadata), V.joinedAt !== void 0 && (_e.joinedAt = Math.round(V.joinedAt)), V.name !== void 0 && (_e.name = V.name), V.version !== void 0 && (_e.version = Math.round(V.version)), V.permission !== void 0 && (_e.permission = V.permission ? a.ParticipantPermission.toJSON(V.permission) : void 0), V.region !== void 0 && (_e.region = V.region), V.isPublisher !== void 0 && (_e.isPublisher = V.isPublisher), _e;
    },
    fromPartial(V) {
      var _e, ue, ce, me, Ce, Be, ze, Je, Ze, Ke;
      const x = te();
      return x.sid = (_e = V.sid) !== null && _e !== void 0 ? _e : "", x.identity = (ue = V.identity) !== null && ue !== void 0 ? ue : "", x.state = (ce = V.state) !== null && ce !== void 0 ? ce : 0, x.tracks = ((me = V.tracks) === null || me === void 0 ? void 0 : me.map((se) => a.TrackInfo.fromPartial(se))) || [], x.metadata = (Ce = V.metadata) !== null && Ce !== void 0 ? Ce : "", x.joinedAt = (Be = V.joinedAt) !== null && Be !== void 0 ? Be : 0, x.name = (ze = V.name) !== null && ze !== void 0 ? ze : "", x.version = (Je = V.version) !== null && Je !== void 0 ? Je : 0, x.permission = V.permission !== void 0 && V.permission !== null ? a.ParticipantPermission.fromPartial(V.permission) : void 0, x.region = (Ze = V.region) !== null && Ze !== void 0 ? Ze : "", x.isPublisher = (Ke = V.isPublisher) !== null && Ke !== void 0 ? Ke : !1, x;
    }
  };
  function pe() {
    return { mimeType: "", mid: "", cid: "", layers: [] };
  }
  a.SimulcastCodecInfo = {
    encode(V, _e = l.default.Writer.create()) {
      V.mimeType !== "" && _e.uint32(10).string(V.mimeType), V.mid !== "" && _e.uint32(18).string(V.mid), V.cid !== "" && _e.uint32(26).string(V.cid);
      for (const ue of V.layers)
        a.VideoLayer.encode(ue, _e.uint32(34).fork()).ldelim();
      return _e;
    },
    decode(V, _e) {
      const ue = V instanceof l.default.Reader ? V : new l.default.Reader(V);
      let ce = _e === void 0 ? ue.len : ue.pos + _e;
      const me = pe();
      for (; ue.pos < ce; ) {
        const Ce = ue.uint32();
        switch (Ce >>> 3) {
          case 1:
            me.mimeType = ue.string();
            break;
          case 2:
            me.mid = ue.string();
            break;
          case 3:
            me.cid = ue.string();
            break;
          case 4:
            me.layers.push(a.VideoLayer.decode(ue, ue.uint32()));
            break;
          default:
            ue.skipType(Ce & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(V) {
      return {
        mimeType: we(V.mimeType) ? String(V.mimeType) : "",
        mid: we(V.mid) ? String(V.mid) : "",
        cid: we(V.cid) ? String(V.cid) : "",
        layers: Array.isArray(V == null ? void 0 : V.layers) ? V.layers.map((_e) => a.VideoLayer.fromJSON(_e)) : []
      };
    },
    toJSON(V) {
      const _e = {};
      return V.mimeType !== void 0 && (_e.mimeType = V.mimeType), V.mid !== void 0 && (_e.mid = V.mid), V.cid !== void 0 && (_e.cid = V.cid), V.layers ? _e.layers = V.layers.map((ue) => ue ? a.VideoLayer.toJSON(ue) : void 0) : _e.layers = [], _e;
    },
    fromPartial(V) {
      var _e, ue, ce, me;
      const Ce = pe();
      return Ce.mimeType = (_e = V.mimeType) !== null && _e !== void 0 ? _e : "", Ce.mid = (ue = V.mid) !== null && ue !== void 0 ? ue : "", Ce.cid = (ce = V.cid) !== null && ce !== void 0 ? ce : "", Ce.layers = ((me = V.layers) === null || me === void 0 ? void 0 : me.map((Be) => a.VideoLayer.fromPartial(Be))) || [], Ce;
    }
  };
  function Ie() {
    return {
      sid: "",
      type: 0,
      name: "",
      muted: !1,
      width: 0,
      height: 0,
      simulcast: !1,
      disableDtx: !1,
      source: 0,
      layers: [],
      mimeType: "",
      mid: "",
      codecs: [],
      stereo: !1,
      disableRed: !1
    };
  }
  a.TrackInfo = {
    encode(V, _e = l.default.Writer.create()) {
      V.sid !== "" && _e.uint32(10).string(V.sid), V.type !== 0 && _e.uint32(16).int32(V.type), V.name !== "" && _e.uint32(26).string(V.name), V.muted === !0 && _e.uint32(32).bool(V.muted), V.width !== 0 && _e.uint32(40).uint32(V.width), V.height !== 0 && _e.uint32(48).uint32(V.height), V.simulcast === !0 && _e.uint32(56).bool(V.simulcast), V.disableDtx === !0 && _e.uint32(64).bool(V.disableDtx), V.source !== 0 && _e.uint32(72).int32(V.source);
      for (const ue of V.layers)
        a.VideoLayer.encode(ue, _e.uint32(82).fork()).ldelim();
      V.mimeType !== "" && _e.uint32(90).string(V.mimeType), V.mid !== "" && _e.uint32(98).string(V.mid);
      for (const ue of V.codecs)
        a.SimulcastCodecInfo.encode(ue, _e.uint32(106).fork()).ldelim();
      return V.stereo === !0 && _e.uint32(112).bool(V.stereo), V.disableRed === !0 && _e.uint32(120).bool(V.disableRed), _e;
    },
    decode(V, _e) {
      const ue = V instanceof l.default.Reader ? V : new l.default.Reader(V);
      let ce = _e === void 0 ? ue.len : ue.pos + _e;
      const me = Ie();
      for (; ue.pos < ce; ) {
        const Ce = ue.uint32();
        switch (Ce >>> 3) {
          case 1:
            me.sid = ue.string();
            break;
          case 2:
            me.type = ue.int32();
            break;
          case 3:
            me.name = ue.string();
            break;
          case 4:
            me.muted = ue.bool();
            break;
          case 5:
            me.width = ue.uint32();
            break;
          case 6:
            me.height = ue.uint32();
            break;
          case 7:
            me.simulcast = ue.bool();
            break;
          case 8:
            me.disableDtx = ue.bool();
            break;
          case 9:
            me.source = ue.int32();
            break;
          case 10:
            me.layers.push(a.VideoLayer.decode(ue, ue.uint32()));
            break;
          case 11:
            me.mimeType = ue.string();
            break;
          case 12:
            me.mid = ue.string();
            break;
          case 13:
            me.codecs.push(a.SimulcastCodecInfo.decode(ue, ue.uint32()));
            break;
          case 14:
            me.stereo = ue.bool();
            break;
          case 15:
            me.disableRed = ue.bool();
            break;
          default:
            ue.skipType(Ce & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(V) {
      return {
        sid: we(V.sid) ? String(V.sid) : "",
        type: we(V.type) ? _(V.type) : 0,
        name: we(V.name) ? String(V.name) : "",
        muted: we(V.muted) ? !!V.muted : !1,
        width: we(V.width) ? Number(V.width) : 0,
        height: we(V.height) ? Number(V.height) : 0,
        simulcast: we(V.simulcast) ? !!V.simulcast : !1,
        disableDtx: we(V.disableDtx) ? !!V.disableDtx : !1,
        source: we(V.source) ? D(V.source) : 0,
        layers: Array.isArray(V == null ? void 0 : V.layers) ? V.layers.map((_e) => a.VideoLayer.fromJSON(_e)) : [],
        mimeType: we(V.mimeType) ? String(V.mimeType) : "",
        mid: we(V.mid) ? String(V.mid) : "",
        codecs: Array.isArray(V == null ? void 0 : V.codecs) ? V.codecs.map((_e) => a.SimulcastCodecInfo.fromJSON(_e)) : [],
        stereo: we(V.stereo) ? !!V.stereo : !1,
        disableRed: we(V.disableRed) ? !!V.disableRed : !1
      };
    },
    toJSON(V) {
      const _e = {};
      return V.sid !== void 0 && (_e.sid = V.sid), V.type !== void 0 && (_e.type = k(V.type)), V.name !== void 0 && (_e.name = V.name), V.muted !== void 0 && (_e.muted = V.muted), V.width !== void 0 && (_e.width = Math.round(V.width)), V.height !== void 0 && (_e.height = Math.round(V.height)), V.simulcast !== void 0 && (_e.simulcast = V.simulcast), V.disableDtx !== void 0 && (_e.disableDtx = V.disableDtx), V.source !== void 0 && (_e.source = F(V.source)), V.layers ? _e.layers = V.layers.map((ue) => ue ? a.VideoLayer.toJSON(ue) : void 0) : _e.layers = [], V.mimeType !== void 0 && (_e.mimeType = V.mimeType), V.mid !== void 0 && (_e.mid = V.mid), V.codecs ? _e.codecs = V.codecs.map((ue) => ue ? a.SimulcastCodecInfo.toJSON(ue) : void 0) : _e.codecs = [], V.stereo !== void 0 && (_e.stereo = V.stereo), V.disableRed !== void 0 && (_e.disableRed = V.disableRed), _e;
    },
    fromPartial(V) {
      var _e, ue, ce, me, Ce, Be, ze, Je, Ze, Ke, x, se, ge, xe, Me;
      const Ye = Ie();
      return Ye.sid = (_e = V.sid) !== null && _e !== void 0 ? _e : "", Ye.type = (ue = V.type) !== null && ue !== void 0 ? ue : 0, Ye.name = (ce = V.name) !== null && ce !== void 0 ? ce : "", Ye.muted = (me = V.muted) !== null && me !== void 0 ? me : !1, Ye.width = (Ce = V.width) !== null && Ce !== void 0 ? Ce : 0, Ye.height = (Be = V.height) !== null && Be !== void 0 ? Be : 0, Ye.simulcast = (ze = V.simulcast) !== null && ze !== void 0 ? ze : !1, Ye.disableDtx = (Je = V.disableDtx) !== null && Je !== void 0 ? Je : !1, Ye.source = (Ze = V.source) !== null && Ze !== void 0 ? Ze : 0, Ye.layers = ((Ke = V.layers) === null || Ke === void 0 ? void 0 : Ke.map((et) => a.VideoLayer.fromPartial(et))) || [], Ye.mimeType = (x = V.mimeType) !== null && x !== void 0 ? x : "", Ye.mid = (se = V.mid) !== null && se !== void 0 ? se : "", Ye.codecs = ((ge = V.codecs) === null || ge === void 0 ? void 0 : ge.map((et) => a.SimulcastCodecInfo.fromPartial(et))) || [], Ye.stereo = (xe = V.stereo) !== null && xe !== void 0 ? xe : !1, Ye.disableRed = (Me = V.disableRed) !== null && Me !== void 0 ? Me : !1, Ye;
    }
  };
  function $e() {
    return { quality: 0, width: 0, height: 0, bitrate: 0, ssrc: 0 };
  }
  a.VideoLayer = {
    encode(V, _e = l.default.Writer.create()) {
      return V.quality !== 0 && _e.uint32(8).int32(V.quality), V.width !== 0 && _e.uint32(16).uint32(V.width), V.height !== 0 && _e.uint32(24).uint32(V.height), V.bitrate !== 0 && _e.uint32(32).uint32(V.bitrate), V.ssrc !== 0 && _e.uint32(40).uint32(V.ssrc), _e;
    },
    decode(V, _e) {
      const ue = V instanceof l.default.Reader ? V : new l.default.Reader(V);
      let ce = _e === void 0 ? ue.len : ue.pos + _e;
      const me = $e();
      for (; ue.pos < ce; ) {
        const Ce = ue.uint32();
        switch (Ce >>> 3) {
          case 1:
            me.quality = ue.int32();
            break;
          case 2:
            me.width = ue.uint32();
            break;
          case 3:
            me.height = ue.uint32();
            break;
          case 4:
            me.bitrate = ue.uint32();
            break;
          case 5:
            me.ssrc = ue.uint32();
            break;
          default:
            ue.skipType(Ce & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(V) {
      return {
        quality: we(V.quality) ? j(V.quality) : 0,
        width: we(V.width) ? Number(V.width) : 0,
        height: we(V.height) ? Number(V.height) : 0,
        bitrate: we(V.bitrate) ? Number(V.bitrate) : 0,
        ssrc: we(V.ssrc) ? Number(V.ssrc) : 0
      };
    },
    toJSON(V) {
      const _e = {};
      return V.quality !== void 0 && (_e.quality = ee(V.quality)), V.width !== void 0 && (_e.width = Math.round(V.width)), V.height !== void 0 && (_e.height = Math.round(V.height)), V.bitrate !== void 0 && (_e.bitrate = Math.round(V.bitrate)), V.ssrc !== void 0 && (_e.ssrc = Math.round(V.ssrc)), _e;
    },
    fromPartial(V) {
      var _e, ue, ce, me, Ce;
      const Be = $e();
      return Be.quality = (_e = V.quality) !== null && _e !== void 0 ? _e : 0, Be.width = (ue = V.width) !== null && ue !== void 0 ? ue : 0, Be.height = (ce = V.height) !== null && ce !== void 0 ? ce : 0, Be.bitrate = (me = V.bitrate) !== null && me !== void 0 ? me : 0, Be.ssrc = (Ce = V.ssrc) !== null && Ce !== void 0 ? Ce : 0, Be;
    }
  };
  function ve() {
    return { kind: 0, user: void 0, speaker: void 0 };
  }
  a.DataPacket = {
    encode(V, _e = l.default.Writer.create()) {
      return V.kind !== 0 && _e.uint32(8).int32(V.kind), V.user !== void 0 && a.UserPacket.encode(V.user, _e.uint32(18).fork()).ldelim(), V.speaker !== void 0 && a.ActiveSpeakerUpdate.encode(V.speaker, _e.uint32(26).fork()).ldelim(), _e;
    },
    decode(V, _e) {
      const ue = V instanceof l.default.Reader ? V : new l.default.Reader(V);
      let ce = _e === void 0 ? ue.len : ue.pos + _e;
      const me = ve();
      for (; ue.pos < ce; ) {
        const Ce = ue.uint32();
        switch (Ce >>> 3) {
          case 1:
            me.kind = ue.int32();
            break;
          case 2:
            me.user = a.UserPacket.decode(ue, ue.uint32());
            break;
          case 3:
            me.speaker = a.ActiveSpeakerUpdate.decode(ue, ue.uint32());
            break;
          default:
            ue.skipType(Ce & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(V) {
      return {
        kind: we(V.kind) ? C(V.kind) : 0,
        user: we(V.user) ? a.UserPacket.fromJSON(V.user) : void 0,
        speaker: we(V.speaker) ? a.ActiveSpeakerUpdate.fromJSON(V.speaker) : void 0
      };
    },
    toJSON(V) {
      const _e = {};
      return V.kind !== void 0 && (_e.kind = S(V.kind)), V.user !== void 0 && (_e.user = V.user ? a.UserPacket.toJSON(V.user) : void 0), V.speaker !== void 0 && (_e.speaker = V.speaker ? a.ActiveSpeakerUpdate.toJSON(V.speaker) : void 0), _e;
    },
    fromPartial(V) {
      var _e;
      const ue = ve();
      return ue.kind = (_e = V.kind) !== null && _e !== void 0 ? _e : 0, ue.user = V.user !== void 0 && V.user !== null ? a.UserPacket.fromPartial(V.user) : void 0, ue.speaker = V.speaker !== void 0 && V.speaker !== null ? a.ActiveSpeakerUpdate.fromPartial(V.speaker) : void 0, ue;
    }
  };
  function he() {
    return { speakers: [] };
  }
  a.ActiveSpeakerUpdate = {
    encode(V, _e = l.default.Writer.create()) {
      for (const ue of V.speakers)
        a.SpeakerInfo.encode(ue, _e.uint32(10).fork()).ldelim();
      return _e;
    },
    decode(V, _e) {
      const ue = V instanceof l.default.Reader ? V : new l.default.Reader(V);
      let ce = _e === void 0 ? ue.len : ue.pos + _e;
      const me = he();
      for (; ue.pos < ce; ) {
        const Ce = ue.uint32();
        switch (Ce >>> 3) {
          case 1:
            me.speakers.push(a.SpeakerInfo.decode(ue, ue.uint32()));
            break;
          default:
            ue.skipType(Ce & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(V) {
      return {
        speakers: Array.isArray(V == null ? void 0 : V.speakers) ? V.speakers.map((_e) => a.SpeakerInfo.fromJSON(_e)) : []
      };
    },
    toJSON(V) {
      const _e = {};
      return V.speakers ? _e.speakers = V.speakers.map((ue) => ue ? a.SpeakerInfo.toJSON(ue) : void 0) : _e.speakers = [], _e;
    },
    fromPartial(V) {
      var _e;
      const ue = he();
      return ue.speakers = ((_e = V.speakers) === null || _e === void 0 ? void 0 : _e.map((ce) => a.SpeakerInfo.fromPartial(ce))) || [], ue;
    }
  };
  function Oe() {
    return { sid: "", level: 0, active: !1 };
  }
  a.SpeakerInfo = {
    encode(V, _e = l.default.Writer.create()) {
      return V.sid !== "" && _e.uint32(10).string(V.sid), V.level !== 0 && _e.uint32(21).float(V.level), V.active === !0 && _e.uint32(24).bool(V.active), _e;
    },
    decode(V, _e) {
      const ue = V instanceof l.default.Reader ? V : new l.default.Reader(V);
      let ce = _e === void 0 ? ue.len : ue.pos + _e;
      const me = Oe();
      for (; ue.pos < ce; ) {
        const Ce = ue.uint32();
        switch (Ce >>> 3) {
          case 1:
            me.sid = ue.string();
            break;
          case 2:
            me.level = ue.float();
            break;
          case 3:
            me.active = ue.bool();
            break;
          default:
            ue.skipType(Ce & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(V) {
      return {
        sid: we(V.sid) ? String(V.sid) : "",
        level: we(V.level) ? Number(V.level) : 0,
        active: we(V.active) ? !!V.active : !1
      };
    },
    toJSON(V) {
      const _e = {};
      return V.sid !== void 0 && (_e.sid = V.sid), V.level !== void 0 && (_e.level = V.level), V.active !== void 0 && (_e.active = V.active), _e;
    },
    fromPartial(V) {
      var _e, ue, ce;
      const me = Oe();
      return me.sid = (_e = V.sid) !== null && _e !== void 0 ? _e : "", me.level = (ue = V.level) !== null && ue !== void 0 ? ue : 0, me.active = (ce = V.active) !== null && ce !== void 0 ? ce : !1, me;
    }
  };
  function Ae() {
    return { participantSid: "", payload: new Uint8Array(), destinationSids: [] };
  }
  a.UserPacket = {
    encode(V, _e = l.default.Writer.create()) {
      V.participantSid !== "" && _e.uint32(10).string(V.participantSid), V.payload.length !== 0 && _e.uint32(18).bytes(V.payload);
      for (const ue of V.destinationSids)
        _e.uint32(26).string(ue);
      return _e;
    },
    decode(V, _e) {
      const ue = V instanceof l.default.Reader ? V : new l.default.Reader(V);
      let ce = _e === void 0 ? ue.len : ue.pos + _e;
      const me = Ae();
      for (; ue.pos < ce; ) {
        const Ce = ue.uint32();
        switch (Ce >>> 3) {
          case 1:
            me.participantSid = ue.string();
            break;
          case 2:
            me.payload = ue.bytes();
            break;
          case 3:
            me.destinationSids.push(ue.string());
            break;
          default:
            ue.skipType(Ce & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(V) {
      return {
        participantSid: we(V.participantSid) ? String(V.participantSid) : "",
        payload: we(V.payload) ? yt(V.payload) : new Uint8Array(),
        destinationSids: Array.isArray(V == null ? void 0 : V.destinationSids) ? V.destinationSids.map((_e) => String(_e)) : []
      };
    },
    toJSON(V) {
      const _e = {};
      return V.participantSid !== void 0 && (_e.participantSid = V.participantSid), V.payload !== void 0 && (_e.payload = Xe(V.payload !== void 0 ? V.payload : new Uint8Array())), V.destinationSids ? _e.destinationSids = V.destinationSids.map((ue) => ue) : _e.destinationSids = [], _e;
    },
    fromPartial(V) {
      var _e, ue, ce;
      const me = Ae();
      return me.participantSid = (_e = V.participantSid) !== null && _e !== void 0 ? _e : "", me.payload = (ue = V.payload) !== null && ue !== void 0 ? ue : new Uint8Array(), me.destinationSids = ((ce = V.destinationSids) === null || ce === void 0 ? void 0 : ce.map((Ce) => Ce)) || [], me;
    }
  };
  function Ue() {
    return { participantSid: "", trackSids: [] };
  }
  a.ParticipantTracks = {
    encode(V, _e = l.default.Writer.create()) {
      V.participantSid !== "" && _e.uint32(10).string(V.participantSid);
      for (const ue of V.trackSids)
        _e.uint32(18).string(ue);
      return _e;
    },
    decode(V, _e) {
      const ue = V instanceof l.default.Reader ? V : new l.default.Reader(V);
      let ce = _e === void 0 ? ue.len : ue.pos + _e;
      const me = Ue();
      for (; ue.pos < ce; ) {
        const Ce = ue.uint32();
        switch (Ce >>> 3) {
          case 1:
            me.participantSid = ue.string();
            break;
          case 2:
            me.trackSids.push(ue.string());
            break;
          default:
            ue.skipType(Ce & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(V) {
      return {
        participantSid: we(V.participantSid) ? String(V.participantSid) : "",
        trackSids: Array.isArray(V == null ? void 0 : V.trackSids) ? V.trackSids.map((_e) => String(_e)) : []
      };
    },
    toJSON(V) {
      const _e = {};
      return V.participantSid !== void 0 && (_e.participantSid = V.participantSid), V.trackSids ? _e.trackSids = V.trackSids.map((ue) => ue) : _e.trackSids = [], _e;
    },
    fromPartial(V) {
      var _e, ue;
      const ce = Ue();
      return ce.participantSid = (_e = V.participantSid) !== null && _e !== void 0 ? _e : "", ce.trackSids = ((ue = V.trackSids) === null || ue === void 0 ? void 0 : ue.map((me) => me)) || [], ce;
    }
  };
  function oe() {
    return { edition: 0, version: "", protocol: 0, region: "", nodeId: "", debugInfo: "" };
  }
  a.ServerInfo = {
    encode(V, _e = l.default.Writer.create()) {
      return V.edition !== 0 && _e.uint32(8).int32(V.edition), V.version !== "" && _e.uint32(18).string(V.version), V.protocol !== 0 && _e.uint32(24).int32(V.protocol), V.region !== "" && _e.uint32(34).string(V.region), V.nodeId !== "" && _e.uint32(42).string(V.nodeId), V.debugInfo !== "" && _e.uint32(50).string(V.debugInfo), _e;
    },
    decode(V, _e) {
      const ue = V instanceof l.default.Reader ? V : new l.default.Reader(V);
      let ce = _e === void 0 ? ue.len : ue.pos + _e;
      const me = oe();
      for (; ue.pos < ce; ) {
        const Ce = ue.uint32();
        switch (Ce >>> 3) {
          case 1:
            me.edition = ue.int32();
            break;
          case 2:
            me.version = ue.string();
            break;
          case 3:
            me.protocol = ue.int32();
            break;
          case 4:
            me.region = ue.string();
            break;
          case 5:
            me.nodeId = ue.string();
            break;
          case 6:
            me.debugInfo = ue.string();
            break;
          default:
            ue.skipType(Ce & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(V) {
      return {
        edition: we(V.edition) ? I(V.edition) : 0,
        version: we(V.version) ? String(V.version) : "",
        protocol: we(V.protocol) ? Number(V.protocol) : 0,
        region: we(V.region) ? String(V.region) : "",
        nodeId: we(V.nodeId) ? String(V.nodeId) : "",
        debugInfo: we(V.debugInfo) ? String(V.debugInfo) : ""
      };
    },
    toJSON(V) {
      const _e = {};
      return V.edition !== void 0 && (_e.edition = M(V.edition)), V.version !== void 0 && (_e.version = V.version), V.protocol !== void 0 && (_e.protocol = Math.round(V.protocol)), V.region !== void 0 && (_e.region = V.region), V.nodeId !== void 0 && (_e.nodeId = V.nodeId), V.debugInfo !== void 0 && (_e.debugInfo = V.debugInfo), _e;
    },
    fromPartial(V) {
      var _e, ue, ce, me, Ce, Be;
      const ze = oe();
      return ze.edition = (_e = V.edition) !== null && _e !== void 0 ? _e : 0, ze.version = (ue = V.version) !== null && ue !== void 0 ? ue : "", ze.protocol = (ce = V.protocol) !== null && ce !== void 0 ? ce : 0, ze.region = (me = V.region) !== null && me !== void 0 ? me : "", ze.nodeId = (Ce = V.nodeId) !== null && Ce !== void 0 ? Ce : "", ze.debugInfo = (Be = V.debugInfo) !== null && Be !== void 0 ? Be : "", ze;
    }
  };
  function A() {
    return {
      sdk: 0,
      version: "",
      protocol: 0,
      os: "",
      osVersion: "",
      deviceModel: "",
      browser: "",
      browserVersion: "",
      address: "",
      network: ""
    };
  }
  a.ClientInfo = {
    encode(V, _e = l.default.Writer.create()) {
      return V.sdk !== 0 && _e.uint32(8).int32(V.sdk), V.version !== "" && _e.uint32(18).string(V.version), V.protocol !== 0 && _e.uint32(24).int32(V.protocol), V.os !== "" && _e.uint32(34).string(V.os), V.osVersion !== "" && _e.uint32(42).string(V.osVersion), V.deviceModel !== "" && _e.uint32(50).string(V.deviceModel), V.browser !== "" && _e.uint32(58).string(V.browser), V.browserVersion !== "" && _e.uint32(66).string(V.browserVersion), V.address !== "" && _e.uint32(74).string(V.address), V.network !== "" && _e.uint32(82).string(V.network), _e;
    },
    decode(V, _e) {
      const ue = V instanceof l.default.Reader ? V : new l.default.Reader(V);
      let ce = _e === void 0 ? ue.len : ue.pos + _e;
      const me = A();
      for (; ue.pos < ce; ) {
        const Ce = ue.uint32();
        switch (Ce >>> 3) {
          case 1:
            me.sdk = ue.int32();
            break;
          case 2:
            me.version = ue.string();
            break;
          case 3:
            me.protocol = ue.int32();
            break;
          case 4:
            me.os = ue.string();
            break;
          case 5:
            me.osVersion = ue.string();
            break;
          case 6:
            me.deviceModel = ue.string();
            break;
          case 7:
            me.browser = ue.string();
            break;
          case 8:
            me.browserVersion = ue.string();
            break;
          case 9:
            me.address = ue.string();
            break;
          case 10:
            me.network = ue.string();
            break;
          default:
            ue.skipType(Ce & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(V) {
      return {
        sdk: we(V.sdk) ? U(V.sdk) : 0,
        version: we(V.version) ? String(V.version) : "",
        protocol: we(V.protocol) ? Number(V.protocol) : 0,
        os: we(V.os) ? String(V.os) : "",
        osVersion: we(V.osVersion) ? String(V.osVersion) : "",
        deviceModel: we(V.deviceModel) ? String(V.deviceModel) : "",
        browser: we(V.browser) ? String(V.browser) : "",
        browserVersion: we(V.browserVersion) ? String(V.browserVersion) : "",
        address: we(V.address) ? String(V.address) : "",
        network: we(V.network) ? String(V.network) : ""
      };
    },
    toJSON(V) {
      const _e = {};
      return V.sdk !== void 0 && (_e.sdk = Y(V.sdk)), V.version !== void 0 && (_e.version = V.version), V.protocol !== void 0 && (_e.protocol = Math.round(V.protocol)), V.os !== void 0 && (_e.os = V.os), V.osVersion !== void 0 && (_e.osVersion = V.osVersion), V.deviceModel !== void 0 && (_e.deviceModel = V.deviceModel), V.browser !== void 0 && (_e.browser = V.browser), V.browserVersion !== void 0 && (_e.browserVersion = V.browserVersion), V.address !== void 0 && (_e.address = V.address), V.network !== void 0 && (_e.network = V.network), _e;
    },
    fromPartial(V) {
      var _e, ue, ce, me, Ce, Be, ze, Je, Ze, Ke;
      const x = A();
      return x.sdk = (_e = V.sdk) !== null && _e !== void 0 ? _e : 0, x.version = (ue = V.version) !== null && ue !== void 0 ? ue : "", x.protocol = (ce = V.protocol) !== null && ce !== void 0 ? ce : 0, x.os = (me = V.os) !== null && me !== void 0 ? me : "", x.osVersion = (Ce = V.osVersion) !== null && Ce !== void 0 ? Ce : "", x.deviceModel = (Be = V.deviceModel) !== null && Be !== void 0 ? Be : "", x.browser = (ze = V.browser) !== null && ze !== void 0 ? ze : "", x.browserVersion = (Je = V.browserVersion) !== null && Je !== void 0 ? Je : "", x.address = (Ze = V.address) !== null && Ze !== void 0 ? Ze : "", x.network = (Ke = V.network) !== null && Ke !== void 0 ? Ke : "", x;
    }
  };
  function re() {
    return { video: void 0, screen: void 0, resumeConnection: 0, disabledCodecs: void 0, forceRelay: 0 };
  }
  a.ClientConfiguration = {
    encode(V, _e = l.default.Writer.create()) {
      return V.video !== void 0 && a.VideoConfiguration.encode(V.video, _e.uint32(10).fork()).ldelim(), V.screen !== void 0 && a.VideoConfiguration.encode(V.screen, _e.uint32(18).fork()).ldelim(), V.resumeConnection !== 0 && _e.uint32(24).int32(V.resumeConnection), V.disabledCodecs !== void 0 && a.DisabledCodecs.encode(V.disabledCodecs, _e.uint32(34).fork()).ldelim(), V.forceRelay !== 0 && _e.uint32(40).int32(V.forceRelay), _e;
    },
    decode(V, _e) {
      const ue = V instanceof l.default.Reader ? V : new l.default.Reader(V);
      let ce = _e === void 0 ? ue.len : ue.pos + _e;
      const me = re();
      for (; ue.pos < ce; ) {
        const Ce = ue.uint32();
        switch (Ce >>> 3) {
          case 1:
            me.video = a.VideoConfiguration.decode(ue, ue.uint32());
            break;
          case 2:
            me.screen = a.VideoConfiguration.decode(ue, ue.uint32());
            break;
          case 3:
            me.resumeConnection = ue.int32();
            break;
          case 4:
            me.disabledCodecs = a.DisabledCodecs.decode(ue, ue.uint32());
            break;
          case 5:
            me.forceRelay = ue.int32();
            break;
          default:
            ue.skipType(Ce & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(V) {
      return {
        video: we(V.video) ? a.VideoConfiguration.fromJSON(V.video) : void 0,
        screen: we(V.screen) ? a.VideoConfiguration.fromJSON(V.screen) : void 0,
        resumeConnection: we(V.resumeConnection) ? Z(V.resumeConnection) : 0,
        disabledCodecs: we(V.disabledCodecs) ? a.DisabledCodecs.fromJSON(V.disabledCodecs) : void 0,
        forceRelay: we(V.forceRelay) ? Z(V.forceRelay) : 0
      };
    },
    toJSON(V) {
      const _e = {};
      return V.video !== void 0 && (_e.video = V.video ? a.VideoConfiguration.toJSON(V.video) : void 0), V.screen !== void 0 && (_e.screen = V.screen ? a.VideoConfiguration.toJSON(V.screen) : void 0), V.resumeConnection !== void 0 && (_e.resumeConnection = de(V.resumeConnection)), V.disabledCodecs !== void 0 && (_e.disabledCodecs = V.disabledCodecs ? a.DisabledCodecs.toJSON(V.disabledCodecs) : void 0), V.forceRelay !== void 0 && (_e.forceRelay = de(V.forceRelay)), _e;
    },
    fromPartial(V) {
      var _e, ue;
      const ce = re();
      return ce.video = V.video !== void 0 && V.video !== null ? a.VideoConfiguration.fromPartial(V.video) : void 0, ce.screen = V.screen !== void 0 && V.screen !== null ? a.VideoConfiguration.fromPartial(V.screen) : void 0, ce.resumeConnection = (_e = V.resumeConnection) !== null && _e !== void 0 ? _e : 0, ce.disabledCodecs = V.disabledCodecs !== void 0 && V.disabledCodecs !== null ? a.DisabledCodecs.fromPartial(V.disabledCodecs) : void 0, ce.forceRelay = (ue = V.forceRelay) !== null && ue !== void 0 ? ue : 0, ce;
    }
  };
  function le() {
    return { hardwareEncoder: 0 };
  }
  a.VideoConfiguration = {
    encode(V, _e = l.default.Writer.create()) {
      return V.hardwareEncoder !== 0 && _e.uint32(8).int32(V.hardwareEncoder), _e;
    },
    decode(V, _e) {
      const ue = V instanceof l.default.Reader ? V : new l.default.Reader(V);
      let ce = _e === void 0 ? ue.len : ue.pos + _e;
      const me = le();
      for (; ue.pos < ce; ) {
        const Ce = ue.uint32();
        switch (Ce >>> 3) {
          case 1:
            me.hardwareEncoder = ue.int32();
            break;
          default:
            ue.skipType(Ce & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(V) {
      return { hardwareEncoder: we(V.hardwareEncoder) ? Z(V.hardwareEncoder) : 0 };
    },
    toJSON(V) {
      const _e = {};
      return V.hardwareEncoder !== void 0 && (_e.hardwareEncoder = de(V.hardwareEncoder)), _e;
    },
    fromPartial(V) {
      var _e;
      const ue = le();
      return ue.hardwareEncoder = (_e = V.hardwareEncoder) !== null && _e !== void 0 ? _e : 0, ue;
    }
  };
  function Ne() {
    return { codecs: [] };
  }
  a.DisabledCodecs = {
    encode(V, _e = l.default.Writer.create()) {
      for (const ue of V.codecs)
        a.Codec.encode(ue, _e.uint32(10).fork()).ldelim();
      return _e;
    },
    decode(V, _e) {
      const ue = V instanceof l.default.Reader ? V : new l.default.Reader(V);
      let ce = _e === void 0 ? ue.len : ue.pos + _e;
      const me = Ne();
      for (; ue.pos < ce; ) {
        const Ce = ue.uint32();
        switch (Ce >>> 3) {
          case 1:
            me.codecs.push(a.Codec.decode(ue, ue.uint32()));
            break;
          default:
            ue.skipType(Ce & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(V) {
      return { codecs: Array.isArray(V == null ? void 0 : V.codecs) ? V.codecs.map((_e) => a.Codec.fromJSON(_e)) : [] };
    },
    toJSON(V) {
      const _e = {};
      return V.codecs ? _e.codecs = V.codecs.map((ue) => ue ? a.Codec.toJSON(ue) : void 0) : _e.codecs = [], _e;
    },
    fromPartial(V) {
      var _e;
      const ue = Ne();
      return ue.codecs = ((_e = V.codecs) === null || _e === void 0 ? void 0 : _e.map((ce) => a.Codec.fromPartial(ce))) || [], ue;
    }
  };
  function Pe() {
    return {
      startTime: void 0,
      endTime: void 0,
      duration: 0,
      packets: 0,
      packetRate: 0,
      bytes: 0,
      headerBytes: 0,
      bitrate: 0,
      packetsLost: 0,
      packetLossRate: 0,
      packetLossPercentage: 0,
      packetsDuplicate: 0,
      packetDuplicateRate: 0,
      bytesDuplicate: 0,
      headerBytesDuplicate: 0,
      bitrateDuplicate: 0,
      packetsPadding: 0,
      packetPaddingRate: 0,
      bytesPadding: 0,
      headerBytesPadding: 0,
      bitratePadding: 0,
      packetsOutOfOrder: 0,
      frames: 0,
      frameRate: 0,
      jitterCurrent: 0,
      jitterMax: 0,
      gapHistogram: {},
      nacks: 0,
      nackAcks: 0,
      nackMisses: 0,
      nackRepeated: 0,
      plis: 0,
      lastPli: void 0,
      firs: 0,
      lastFir: void 0,
      rttCurrent: 0,
      rttMax: 0,
      keyFrames: 0,
      lastKeyFrame: void 0,
      layerLockPlis: 0,
      lastLayerLockPli: void 0
    };
  }
  a.RTPStats = {
    encode(V, _e = l.default.Writer.create()) {
      return V.startTime !== void 0 && v.Timestamp.encode(Ge(V.startTime), _e.uint32(10).fork()).ldelim(), V.endTime !== void 0 && v.Timestamp.encode(Ge(V.endTime), _e.uint32(18).fork()).ldelim(), V.duration !== 0 && _e.uint32(25).double(V.duration), V.packets !== 0 && _e.uint32(32).uint32(V.packets), V.packetRate !== 0 && _e.uint32(41).double(V.packetRate), V.bytes !== 0 && _e.uint32(48).uint64(V.bytes), V.headerBytes !== 0 && _e.uint32(312).uint64(V.headerBytes), V.bitrate !== 0 && _e.uint32(57).double(V.bitrate), V.packetsLost !== 0 && _e.uint32(64).uint32(V.packetsLost), V.packetLossRate !== 0 && _e.uint32(73).double(V.packetLossRate), V.packetLossPercentage !== 0 && _e.uint32(85).float(V.packetLossPercentage), V.packetsDuplicate !== 0 && _e.uint32(88).uint32(V.packetsDuplicate), V.packetDuplicateRate !== 0 && _e.uint32(97).double(V.packetDuplicateRate), V.bytesDuplicate !== 0 && _e.uint32(104).uint64(V.bytesDuplicate), V.headerBytesDuplicate !== 0 && _e.uint32(320).uint64(V.headerBytesDuplicate), V.bitrateDuplicate !== 0 && _e.uint32(113).double(V.bitrateDuplicate), V.packetsPadding !== 0 && _e.uint32(120).uint32(V.packetsPadding), V.packetPaddingRate !== 0 && _e.uint32(129).double(V.packetPaddingRate), V.bytesPadding !== 0 && _e.uint32(136).uint64(V.bytesPadding), V.headerBytesPadding !== 0 && _e.uint32(328).uint64(V.headerBytesPadding), V.bitratePadding !== 0 && _e.uint32(145).double(V.bitratePadding), V.packetsOutOfOrder !== 0 && _e.uint32(152).uint32(V.packetsOutOfOrder), V.frames !== 0 && _e.uint32(160).uint32(V.frames), V.frameRate !== 0 && _e.uint32(169).double(V.frameRate), V.jitterCurrent !== 0 && _e.uint32(177).double(V.jitterCurrent), V.jitterMax !== 0 && _e.uint32(185).double(V.jitterMax), Object.entries(V.gapHistogram).forEach(([ue, ce]) => {
        a.RTPStats_GapHistogramEntry.encode({ key: ue, value: ce }, _e.uint32(194).fork()).ldelim();
      }), V.nacks !== 0 && _e.uint32(200).uint32(V.nacks), V.nackAcks !== 0 && _e.uint32(296).uint32(V.nackAcks), V.nackMisses !== 0 && _e.uint32(208).uint32(V.nackMisses), V.nackRepeated !== 0 && _e.uint32(304).uint32(V.nackRepeated), V.plis !== 0 && _e.uint32(216).uint32(V.plis), V.lastPli !== void 0 && v.Timestamp.encode(Ge(V.lastPli), _e.uint32(226).fork()).ldelim(), V.firs !== 0 && _e.uint32(232).uint32(V.firs), V.lastFir !== void 0 && v.Timestamp.encode(Ge(V.lastFir), _e.uint32(242).fork()).ldelim(), V.rttCurrent !== 0 && _e.uint32(248).uint32(V.rttCurrent), V.rttMax !== 0 && _e.uint32(256).uint32(V.rttMax), V.keyFrames !== 0 && _e.uint32(264).uint32(V.keyFrames), V.lastKeyFrame !== void 0 && v.Timestamp.encode(Ge(V.lastKeyFrame), _e.uint32(274).fork()).ldelim(), V.layerLockPlis !== 0 && _e.uint32(280).uint32(V.layerLockPlis), V.lastLayerLockPli !== void 0 && v.Timestamp.encode(Ge(V.lastLayerLockPli), _e.uint32(290).fork()).ldelim(), _e;
    },
    decode(V, _e) {
      const ue = V instanceof l.default.Reader ? V : new l.default.Reader(V);
      let ce = _e === void 0 ? ue.len : ue.pos + _e;
      const me = Pe();
      for (; ue.pos < ce; ) {
        const Ce = ue.uint32();
        switch (Ce >>> 3) {
          case 1:
            me.startTime = H(v.Timestamp.decode(ue, ue.uint32()));
            break;
          case 2:
            me.endTime = H(v.Timestamp.decode(ue, ue.uint32()));
            break;
          case 3:
            me.duration = ue.double();
            break;
          case 4:
            me.packets = ue.uint32();
            break;
          case 5:
            me.packetRate = ue.double();
            break;
          case 6:
            me.bytes = Ee(ue.uint64());
            break;
          case 39:
            me.headerBytes = Ee(ue.uint64());
            break;
          case 7:
            me.bitrate = ue.double();
            break;
          case 8:
            me.packetsLost = ue.uint32();
            break;
          case 9:
            me.packetLossRate = ue.double();
            break;
          case 10:
            me.packetLossPercentage = ue.float();
            break;
          case 11:
            me.packetsDuplicate = ue.uint32();
            break;
          case 12:
            me.packetDuplicateRate = ue.double();
            break;
          case 13:
            me.bytesDuplicate = Ee(ue.uint64());
            break;
          case 40:
            me.headerBytesDuplicate = Ee(ue.uint64());
            break;
          case 14:
            me.bitrateDuplicate = ue.double();
            break;
          case 15:
            me.packetsPadding = ue.uint32();
            break;
          case 16:
            me.packetPaddingRate = ue.double();
            break;
          case 17:
            me.bytesPadding = Ee(ue.uint64());
            break;
          case 41:
            me.headerBytesPadding = Ee(ue.uint64());
            break;
          case 18:
            me.bitratePadding = ue.double();
            break;
          case 19:
            me.packetsOutOfOrder = ue.uint32();
            break;
          case 20:
            me.frames = ue.uint32();
            break;
          case 21:
            me.frameRate = ue.double();
            break;
          case 22:
            me.jitterCurrent = ue.double();
            break;
          case 23:
            me.jitterMax = ue.double();
            break;
          case 24:
            const Be = a.RTPStats_GapHistogramEntry.decode(ue, ue.uint32());
            Be.value !== void 0 && (me.gapHistogram[Be.key] = Be.value);
            break;
          case 25:
            me.nacks = ue.uint32();
            break;
          case 37:
            me.nackAcks = ue.uint32();
            break;
          case 26:
            me.nackMisses = ue.uint32();
            break;
          case 38:
            me.nackRepeated = ue.uint32();
            break;
          case 27:
            me.plis = ue.uint32();
            break;
          case 28:
            me.lastPli = H(v.Timestamp.decode(ue, ue.uint32()));
            break;
          case 29:
            me.firs = ue.uint32();
            break;
          case 30:
            me.lastFir = H(v.Timestamp.decode(ue, ue.uint32()));
            break;
          case 31:
            me.rttCurrent = ue.uint32();
            break;
          case 32:
            me.rttMax = ue.uint32();
            break;
          case 33:
            me.keyFrames = ue.uint32();
            break;
          case 34:
            me.lastKeyFrame = H(v.Timestamp.decode(ue, ue.uint32()));
            break;
          case 35:
            me.layerLockPlis = ue.uint32();
            break;
          case 36:
            me.lastLayerLockPli = H(v.Timestamp.decode(ue, ue.uint32()));
            break;
          default:
            ue.skipType(Ce & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(V) {
      return {
        startTime: we(V.startTime) ? ye(V.startTime) : void 0,
        endTime: we(V.endTime) ? ye(V.endTime) : void 0,
        duration: we(V.duration) ? Number(V.duration) : 0,
        packets: we(V.packets) ? Number(V.packets) : 0,
        packetRate: we(V.packetRate) ? Number(V.packetRate) : 0,
        bytes: we(V.bytes) ? Number(V.bytes) : 0,
        headerBytes: we(V.headerBytes) ? Number(V.headerBytes) : 0,
        bitrate: we(V.bitrate) ? Number(V.bitrate) : 0,
        packetsLost: we(V.packetsLost) ? Number(V.packetsLost) : 0,
        packetLossRate: we(V.packetLossRate) ? Number(V.packetLossRate) : 0,
        packetLossPercentage: we(V.packetLossPercentage) ? Number(V.packetLossPercentage) : 0,
        packetsDuplicate: we(V.packetsDuplicate) ? Number(V.packetsDuplicate) : 0,
        packetDuplicateRate: we(V.packetDuplicateRate) ? Number(V.packetDuplicateRate) : 0,
        bytesDuplicate: we(V.bytesDuplicate) ? Number(V.bytesDuplicate) : 0,
        headerBytesDuplicate: we(V.headerBytesDuplicate) ? Number(V.headerBytesDuplicate) : 0,
        bitrateDuplicate: we(V.bitrateDuplicate) ? Number(V.bitrateDuplicate) : 0,
        packetsPadding: we(V.packetsPadding) ? Number(V.packetsPadding) : 0,
        packetPaddingRate: we(V.packetPaddingRate) ? Number(V.packetPaddingRate) : 0,
        bytesPadding: we(V.bytesPadding) ? Number(V.bytesPadding) : 0,
        headerBytesPadding: we(V.headerBytesPadding) ? Number(V.headerBytesPadding) : 0,
        bitratePadding: we(V.bitratePadding) ? Number(V.bitratePadding) : 0,
        packetsOutOfOrder: we(V.packetsOutOfOrder) ? Number(V.packetsOutOfOrder) : 0,
        frames: we(V.frames) ? Number(V.frames) : 0,
        frameRate: we(V.frameRate) ? Number(V.frameRate) : 0,
        jitterCurrent: we(V.jitterCurrent) ? Number(V.jitterCurrent) : 0,
        jitterMax: we(V.jitterMax) ? Number(V.jitterMax) : 0,
        gapHistogram: We(V.gapHistogram) ? Object.entries(V.gapHistogram).reduce((_e, [ue, ce]) => (_e[Number(ue)] = Number(ce), _e), {}) : {},
        nacks: we(V.nacks) ? Number(V.nacks) : 0,
        nackAcks: we(V.nackAcks) ? Number(V.nackAcks) : 0,
        nackMisses: we(V.nackMisses) ? Number(V.nackMisses) : 0,
        nackRepeated: we(V.nackRepeated) ? Number(V.nackRepeated) : 0,
        plis: we(V.plis) ? Number(V.plis) : 0,
        lastPli: we(V.lastPli) ? ye(V.lastPli) : void 0,
        firs: we(V.firs) ? Number(V.firs) : 0,
        lastFir: we(V.lastFir) ? ye(V.lastFir) : void 0,
        rttCurrent: we(V.rttCurrent) ? Number(V.rttCurrent) : 0,
        rttMax: we(V.rttMax) ? Number(V.rttMax) : 0,
        keyFrames: we(V.keyFrames) ? Number(V.keyFrames) : 0,
        lastKeyFrame: we(V.lastKeyFrame) ? ye(V.lastKeyFrame) : void 0,
        layerLockPlis: we(V.layerLockPlis) ? Number(V.layerLockPlis) : 0,
        lastLayerLockPli: we(V.lastLayerLockPli) ? ye(V.lastLayerLockPli) : void 0
      };
    },
    toJSON(V) {
      const _e = {};
      return V.startTime !== void 0 && (_e.startTime = V.startTime.toISOString()), V.endTime !== void 0 && (_e.endTime = V.endTime.toISOString()), V.duration !== void 0 && (_e.duration = V.duration), V.packets !== void 0 && (_e.packets = Math.round(V.packets)), V.packetRate !== void 0 && (_e.packetRate = V.packetRate), V.bytes !== void 0 && (_e.bytes = Math.round(V.bytes)), V.headerBytes !== void 0 && (_e.headerBytes = Math.round(V.headerBytes)), V.bitrate !== void 0 && (_e.bitrate = V.bitrate), V.packetsLost !== void 0 && (_e.packetsLost = Math.round(V.packetsLost)), V.packetLossRate !== void 0 && (_e.packetLossRate = V.packetLossRate), V.packetLossPercentage !== void 0 && (_e.packetLossPercentage = V.packetLossPercentage), V.packetsDuplicate !== void 0 && (_e.packetsDuplicate = Math.round(V.packetsDuplicate)), V.packetDuplicateRate !== void 0 && (_e.packetDuplicateRate = V.packetDuplicateRate), V.bytesDuplicate !== void 0 && (_e.bytesDuplicate = Math.round(V.bytesDuplicate)), V.headerBytesDuplicate !== void 0 && (_e.headerBytesDuplicate = Math.round(V.headerBytesDuplicate)), V.bitrateDuplicate !== void 0 && (_e.bitrateDuplicate = V.bitrateDuplicate), V.packetsPadding !== void 0 && (_e.packetsPadding = Math.round(V.packetsPadding)), V.packetPaddingRate !== void 0 && (_e.packetPaddingRate = V.packetPaddingRate), V.bytesPadding !== void 0 && (_e.bytesPadding = Math.round(V.bytesPadding)), V.headerBytesPadding !== void 0 && (_e.headerBytesPadding = Math.round(V.headerBytesPadding)), V.bitratePadding !== void 0 && (_e.bitratePadding = V.bitratePadding), V.packetsOutOfOrder !== void 0 && (_e.packetsOutOfOrder = Math.round(V.packetsOutOfOrder)), V.frames !== void 0 && (_e.frames = Math.round(V.frames)), V.frameRate !== void 0 && (_e.frameRate = V.frameRate), V.jitterCurrent !== void 0 && (_e.jitterCurrent = V.jitterCurrent), V.jitterMax !== void 0 && (_e.jitterMax = V.jitterMax), _e.gapHistogram = {}, V.gapHistogram && Object.entries(V.gapHistogram).forEach(([ue, ce]) => {
        _e.gapHistogram[ue] = Math.round(ce);
      }), V.nacks !== void 0 && (_e.nacks = Math.round(V.nacks)), V.nackAcks !== void 0 && (_e.nackAcks = Math.round(V.nackAcks)), V.nackMisses !== void 0 && (_e.nackMisses = Math.round(V.nackMisses)), V.nackRepeated !== void 0 && (_e.nackRepeated = Math.round(V.nackRepeated)), V.plis !== void 0 && (_e.plis = Math.round(V.plis)), V.lastPli !== void 0 && (_e.lastPli = V.lastPli.toISOString()), V.firs !== void 0 && (_e.firs = Math.round(V.firs)), V.lastFir !== void 0 && (_e.lastFir = V.lastFir.toISOString()), V.rttCurrent !== void 0 && (_e.rttCurrent = Math.round(V.rttCurrent)), V.rttMax !== void 0 && (_e.rttMax = Math.round(V.rttMax)), V.keyFrames !== void 0 && (_e.keyFrames = Math.round(V.keyFrames)), V.lastKeyFrame !== void 0 && (_e.lastKeyFrame = V.lastKeyFrame.toISOString()), V.layerLockPlis !== void 0 && (_e.layerLockPlis = Math.round(V.layerLockPlis)), V.lastLayerLockPli !== void 0 && (_e.lastLayerLockPli = V.lastLayerLockPli.toISOString()), _e;
    },
    fromPartial(V) {
      var _e, ue, ce, me, Ce, Be, ze, Je, Ze, Ke, x, se, ge, xe, Me, Ye, et, dt, St, tt, at, kt, rt, ut, wt, nt, it, bt, ot, ct, Pt, st, lt, It, Rt, Ve, He, Qe, pt, mt, vt;
      const ht = Pe();
      return ht.startTime = (_e = V.startTime) !== null && _e !== void 0 ? _e : void 0, ht.endTime = (ue = V.endTime) !== null && ue !== void 0 ? ue : void 0, ht.duration = (ce = V.duration) !== null && ce !== void 0 ? ce : 0, ht.packets = (me = V.packets) !== null && me !== void 0 ? me : 0, ht.packetRate = (Ce = V.packetRate) !== null && Ce !== void 0 ? Ce : 0, ht.bytes = (Be = V.bytes) !== null && Be !== void 0 ? Be : 0, ht.headerBytes = (ze = V.headerBytes) !== null && ze !== void 0 ? ze : 0, ht.bitrate = (Je = V.bitrate) !== null && Je !== void 0 ? Je : 0, ht.packetsLost = (Ze = V.packetsLost) !== null && Ze !== void 0 ? Ze : 0, ht.packetLossRate = (Ke = V.packetLossRate) !== null && Ke !== void 0 ? Ke : 0, ht.packetLossPercentage = (x = V.packetLossPercentage) !== null && x !== void 0 ? x : 0, ht.packetsDuplicate = (se = V.packetsDuplicate) !== null && se !== void 0 ? se : 0, ht.packetDuplicateRate = (ge = V.packetDuplicateRate) !== null && ge !== void 0 ? ge : 0, ht.bytesDuplicate = (xe = V.bytesDuplicate) !== null && xe !== void 0 ? xe : 0, ht.headerBytesDuplicate = (Me = V.headerBytesDuplicate) !== null && Me !== void 0 ? Me : 0, ht.bitrateDuplicate = (Ye = V.bitrateDuplicate) !== null && Ye !== void 0 ? Ye : 0, ht.packetsPadding = (et = V.packetsPadding) !== null && et !== void 0 ? et : 0, ht.packetPaddingRate = (dt = V.packetPaddingRate) !== null && dt !== void 0 ? dt : 0, ht.bytesPadding = (St = V.bytesPadding) !== null && St !== void 0 ? St : 0, ht.headerBytesPadding = (tt = V.headerBytesPadding) !== null && tt !== void 0 ? tt : 0, ht.bitratePadding = (at = V.bitratePadding) !== null && at !== void 0 ? at : 0, ht.packetsOutOfOrder = (kt = V.packetsOutOfOrder) !== null && kt !== void 0 ? kt : 0, ht.frames = (rt = V.frames) !== null && rt !== void 0 ? rt : 0, ht.frameRate = (ut = V.frameRate) !== null && ut !== void 0 ? ut : 0, ht.jitterCurrent = (wt = V.jitterCurrent) !== null && wt !== void 0 ? wt : 0, ht.jitterMax = (nt = V.jitterMax) !== null && nt !== void 0 ? nt : 0, ht.gapHistogram = Object.entries((it = V.gapHistogram) !== null && it !== void 0 ? it : {}).reduce((Et, [Tt, Ot]) => (Ot !== void 0 && (Et[Number(Tt)] = Number(Ot)), Et), {}), ht.nacks = (bt = V.nacks) !== null && bt !== void 0 ? bt : 0, ht.nackAcks = (ot = V.nackAcks) !== null && ot !== void 0 ? ot : 0, ht.nackMisses = (ct = V.nackMisses) !== null && ct !== void 0 ? ct : 0, ht.nackRepeated = (Pt = V.nackRepeated) !== null && Pt !== void 0 ? Pt : 0, ht.plis = (st = V.plis) !== null && st !== void 0 ? st : 0, ht.lastPli = (lt = V.lastPli) !== null && lt !== void 0 ? lt : void 0, ht.firs = (It = V.firs) !== null && It !== void 0 ? It : 0, ht.lastFir = (Rt = V.lastFir) !== null && Rt !== void 0 ? Rt : void 0, ht.rttCurrent = (Ve = V.rttCurrent) !== null && Ve !== void 0 ? Ve : 0, ht.rttMax = (He = V.rttMax) !== null && He !== void 0 ? He : 0, ht.keyFrames = (Qe = V.keyFrames) !== null && Qe !== void 0 ? Qe : 0, ht.lastKeyFrame = (pt = V.lastKeyFrame) !== null && pt !== void 0 ? pt : void 0, ht.layerLockPlis = (mt = V.layerLockPlis) !== null && mt !== void 0 ? mt : 0, ht.lastLayerLockPli = (vt = V.lastLayerLockPli) !== null && vt !== void 0 ? vt : void 0, ht;
    }
  };
  function Fe() {
    return { key: 0, value: 0 };
  }
  a.RTPStats_GapHistogramEntry = {
    encode(V, _e = l.default.Writer.create()) {
      return V.key !== 0 && _e.uint32(8).int32(V.key), V.value !== 0 && _e.uint32(16).uint32(V.value), _e;
    },
    decode(V, _e) {
      const ue = V instanceof l.default.Reader ? V : new l.default.Reader(V);
      let ce = _e === void 0 ? ue.len : ue.pos + _e;
      const me = Fe();
      for (; ue.pos < ce; ) {
        const Ce = ue.uint32();
        switch (Ce >>> 3) {
          case 1:
            me.key = ue.int32();
            break;
          case 2:
            me.value = ue.uint32();
            break;
          default:
            ue.skipType(Ce & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(V) {
      return { key: we(V.key) ? Number(V.key) : 0, value: we(V.value) ? Number(V.value) : 0 };
    },
    toJSON(V) {
      const _e = {};
      return V.key !== void 0 && (_e.key = Math.round(V.key)), V.value !== void 0 && (_e.value = Math.round(V.value)), _e;
    },
    fromPartial(V) {
      var _e, ue;
      const ce = Fe();
      return ce.key = (_e = V.key) !== null && _e !== void 0 ? _e : 0, ce.value = (ue = V.value) !== null && ue !== void 0 ? ue : 0, ce;
    }
  };
  function je() {
    return { unixMicro: 0, ticks: 0 };
  }
  a.TimedVersion = {
    encode(V, _e = l.default.Writer.create()) {
      return V.unixMicro !== 0 && _e.uint32(8).int64(V.unixMicro), V.ticks !== 0 && _e.uint32(16).int32(V.ticks), _e;
    },
    decode(V, _e) {
      const ue = V instanceof l.default.Reader ? V : new l.default.Reader(V);
      let ce = _e === void 0 ? ue.len : ue.pos + _e;
      const me = je();
      for (; ue.pos < ce; ) {
        const Ce = ue.uint32();
        switch (Ce >>> 3) {
          case 1:
            me.unixMicro = Ee(ue.int64());
            break;
          case 2:
            me.ticks = ue.int32();
            break;
          default:
            ue.skipType(Ce & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(V) {
      return {
        unixMicro: we(V.unixMicro) ? Number(V.unixMicro) : 0,
        ticks: we(V.ticks) ? Number(V.ticks) : 0
      };
    },
    toJSON(V) {
      const _e = {};
      return V.unixMicro !== void 0 && (_e.unixMicro = Math.round(V.unixMicro)), V.ticks !== void 0 && (_e.ticks = Math.round(V.ticks)), _e;
    },
    fromPartial(V) {
      var _e, ue;
      const ce = je();
      return ce.unixMicro = (_e = V.unixMicro) !== null && _e !== void 0 ? _e : 0, ce.ticks = (ue = V.ticks) !== null && ue !== void 0 ? ue : 0, ce;
    }
  };
  var qe = (() => {
    if (typeof qe < "u")
      return qe;
    if (typeof self < "u")
      return self;
    if (typeof window < "u")
      return window;
    if (typeof commonjsGlobal$1 < "u")
      return commonjsGlobal$1;
    throw "Unable to locate global object";
  })();
  function yt(V) {
    if (qe.Buffer)
      return Uint8Array.from(qe.Buffer.from(V, "base64"));
    {
      const _e = qe.atob(V), ue = new Uint8Array(_e.length);
      for (let ce = 0; ce < _e.length; ++ce)
        ue[ce] = _e.charCodeAt(ce);
      return ue;
    }
  }
  function Xe(V) {
    if (qe.Buffer)
      return qe.Buffer.from(V).toString("base64");
    {
      const _e = [];
      return V.forEach((ue) => {
        _e.push(String.fromCharCode(ue));
      }), qe.btoa(_e.join(""));
    }
  }
  function Ge(V) {
    const _e = V.getTime() / 1e3, ue = V.getTime() % 1e3 * 1e6;
    return { seconds: _e, nanos: ue };
  }
  function H(V) {
    let _e = V.seconds * 1e3;
    return _e += V.nanos / 1e6, new Date(_e);
  }
  function ye(V) {
    return V instanceof Date ? V : typeof V == "string" ? new Date(V) : H(v.Timestamp.fromJSON(V));
  }
  function Ee(V) {
    if (V.gt(Number.MAX_SAFE_INTEGER))
      throw new qe.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    return V.toNumber();
  }
  l.default.util.Long !== c.default && (l.default.util.Long = c.default, l.default.configure());
  function We(V) {
    return typeof V == "object" && V !== null;
  }
  function we(V) {
    return V != null;
  }
})(livekit_models);
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(q) {
    return q && q.__esModule ? q : { default: q };
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.DeleteIngressRequest = a.ListIngressResponse = a.ListIngressRequest = a.UpdateIngressRequest = a.InputAudioState = a.InputVideoState = a.IngressState = a.IngressInfo = a.IngressVideoOptions = a.IngressAudioOptions = a.CreateIngressRequest = a.ingressState_StatusToJSON = a.ingressState_StatusFromJSON = a.IngressState_Status = a.ingressInputToJSON = a.ingressInputFromJSON = a.IngressInput = a.protobufPackage = void 0;
  const c = u(umdExports), l = u(minimal), v = livekit_models;
  a.protobufPackage = "livekit";
  var p;
  (function(q) {
    q[q.RTMP_INPUT = 0] = "RTMP_INPUT", q[q.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(p = a.IngressInput || (a.IngressInput = {}));
  function _(q) {
    switch (q) {
      case 0:
      case "RTMP_INPUT":
        return p.RTMP_INPUT;
      case -1:
      case "UNRECOGNIZED":
      default:
        return p.UNRECOGNIZED;
    }
  }
  a.ingressInputFromJSON = _;
  function k(q) {
    switch (q) {
      case p.RTMP_INPUT:
        return "RTMP_INPUT";
      case p.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.ingressInputToJSON = k;
  var O;
  (function(q) {
    q[q.ENDPOINT_INACTIVE = 0] = "ENDPOINT_INACTIVE", q[q.ENDPOINT_BUFFERING = 1] = "ENDPOINT_BUFFERING", q[q.ENDPOINT_PUBLISHING = 2] = "ENDPOINT_PUBLISHING", q[q.ENDPOINT_ERROR = 3] = "ENDPOINT_ERROR", q[q.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(O = a.IngressState_Status || (a.IngressState_Status = {}));
  function D(q) {
    switch (q) {
      case 0:
      case "ENDPOINT_INACTIVE":
        return O.ENDPOINT_INACTIVE;
      case 1:
      case "ENDPOINT_BUFFERING":
        return O.ENDPOINT_BUFFERING;
      case 2:
      case "ENDPOINT_PUBLISHING":
        return O.ENDPOINT_PUBLISHING;
      case 3:
      case "ENDPOINT_ERROR":
        return O.ENDPOINT_ERROR;
      case -1:
      case "UNRECOGNIZED":
      default:
        return O.UNRECOGNIZED;
    }
  }
  a.ingressState_StatusFromJSON = D;
  function F(q) {
    switch (q) {
      case O.ENDPOINT_INACTIVE:
        return "ENDPOINT_INACTIVE";
      case O.ENDPOINT_BUFFERING:
        return "ENDPOINT_BUFFERING";
      case O.ENDPOINT_PUBLISHING:
        return "ENDPOINT_PUBLISHING";
      case O.ENDPOINT_ERROR:
        return "ENDPOINT_ERROR";
      case O.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.ingressState_StatusToJSON = F;
  function z() {
    return {
      inputType: 0,
      name: "",
      roomName: "",
      participantIdentity: "",
      participantName: "",
      audio: void 0,
      video: void 0
    };
  }
  a.CreateIngressRequest = {
    encode(q, J = l.default.Writer.create()) {
      return q.inputType !== void 0 && q.inputType !== 0 && J.uint32(8).int32(q.inputType), q.name !== void 0 && q.name !== "" && J.uint32(18).string(q.name), q.roomName !== void 0 && q.roomName !== "" && J.uint32(26).string(q.roomName), q.participantIdentity !== void 0 && q.participantIdentity !== "" && J.uint32(34).string(q.participantIdentity), q.participantName !== void 0 && q.participantName !== "" && J.uint32(42).string(q.participantName), q.audio !== void 0 && a.IngressAudioOptions.encode(q.audio, J.uint32(50).fork()).ldelim(), q.video !== void 0 && a.IngressVideoOptions.encode(q.video, J.uint32(58).fork()).ldelim(), J;
    },
    decode(q, J) {
      const C = q instanceof l.default.Reader ? q : new l.default.Reader(q);
      let S = J === void 0 ? C.len : C.pos + J;
      const E = z();
      for (; C.pos < S; ) {
        const I = C.uint32();
        switch (I >>> 3) {
          case 1:
            E.inputType = C.int32();
            break;
          case 2:
            E.name = C.string();
            break;
          case 3:
            E.roomName = C.string();
            break;
          case 4:
            E.participantIdentity = C.string();
            break;
          case 5:
            E.participantName = C.string();
            break;
          case 6:
            E.audio = a.IngressAudioOptions.decode(C, C.uint32());
            break;
          case 7:
            E.video = a.IngressVideoOptions.decode(C, C.uint32());
            break;
          default:
            C.skipType(I & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(q) {
      return {
        inputType: be(q.inputType) ? _(q.inputType) : 0,
        name: be(q.name) ? String(q.name) : "",
        roomName: be(q.roomName) ? String(q.roomName) : "",
        participantIdentity: be(q.participantIdentity) ? String(q.participantIdentity) : "",
        participantName: be(q.participantName) ? String(q.participantName) : "",
        audio: be(q.audio) ? a.IngressAudioOptions.fromJSON(q.audio) : void 0,
        video: be(q.video) ? a.IngressVideoOptions.fromJSON(q.video) : void 0
      };
    },
    toJSON(q) {
      const J = {};
      return q.inputType !== void 0 && (J.inputType = k(q.inputType)), q.name !== void 0 && (J.name = q.name), q.roomName !== void 0 && (J.roomName = q.roomName), q.participantIdentity !== void 0 && (J.participantIdentity = q.participantIdentity), q.participantName !== void 0 && (J.participantName = q.participantName), q.audio !== void 0 && (J.audio = q.audio ? a.IngressAudioOptions.toJSON(q.audio) : void 0), q.video !== void 0 && (J.video = q.video ? a.IngressVideoOptions.toJSON(q.video) : void 0), J;
    },
    fromPartial(q) {
      var J, C, S, E, I;
      const M = z();
      return M.inputType = (J = q.inputType) !== null && J !== void 0 ? J : 0, M.name = (C = q.name) !== null && C !== void 0 ? C : "", M.roomName = (S = q.roomName) !== null && S !== void 0 ? S : "", M.participantIdentity = (E = q.participantIdentity) !== null && E !== void 0 ? E : "", M.participantName = (I = q.participantName) !== null && I !== void 0 ? I : "", M.audio = q.audio !== void 0 && q.audio !== null ? a.IngressAudioOptions.fromPartial(q.audio) : void 0, M.video = q.video !== void 0 && q.video !== null ? a.IngressVideoOptions.fromPartial(q.video) : void 0, M;
    }
  };
  function j() {
    return { name: "", source: 0, mimeType: "", bitrate: 0, disableDtx: !1, channels: 0 };
  }
  a.IngressAudioOptions = {
    encode(q, J = l.default.Writer.create()) {
      return q.name !== void 0 && q.name !== "" && J.uint32(10).string(q.name), q.source !== void 0 && q.source !== 0 && J.uint32(16).int32(q.source), q.mimeType !== void 0 && q.mimeType !== "" && J.uint32(26).string(q.mimeType), q.bitrate !== void 0 && q.bitrate !== 0 && J.uint32(32).uint32(q.bitrate), q.disableDtx === !0 && J.uint32(40).bool(q.disableDtx), q.channels !== void 0 && q.channels !== 0 && J.uint32(48).uint32(q.channels), J;
    },
    decode(q, J) {
      const C = q instanceof l.default.Reader ? q : new l.default.Reader(q);
      let S = J === void 0 ? C.len : C.pos + J;
      const E = j();
      for (; C.pos < S; ) {
        const I = C.uint32();
        switch (I >>> 3) {
          case 1:
            E.name = C.string();
            break;
          case 2:
            E.source = C.int32();
            break;
          case 3:
            E.mimeType = C.string();
            break;
          case 4:
            E.bitrate = C.uint32();
            break;
          case 5:
            E.disableDtx = C.bool();
            break;
          case 6:
            E.channels = C.uint32();
            break;
          default:
            C.skipType(I & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(q) {
      return {
        name: be(q.name) ? String(q.name) : "",
        source: be(q.source) ? v.trackSourceFromJSON(q.source) : 0,
        mimeType: be(q.mimeType) ? String(q.mimeType) : "",
        bitrate: be(q.bitrate) ? Number(q.bitrate) : 0,
        disableDtx: be(q.disableDtx) ? !!q.disableDtx : !1,
        channels: be(q.channels) ? Number(q.channels) : 0
      };
    },
    toJSON(q) {
      const J = {};
      return q.name !== void 0 && (J.name = q.name), q.source !== void 0 && (J.source = v.trackSourceToJSON(q.source)), q.mimeType !== void 0 && (J.mimeType = q.mimeType), q.bitrate !== void 0 && (J.bitrate = Math.round(q.bitrate)), q.disableDtx !== void 0 && (J.disableDtx = q.disableDtx), q.channels !== void 0 && (J.channels = Math.round(q.channels)), J;
    },
    fromPartial(q) {
      var J, C, S, E, I, M;
      const $ = j();
      return $.name = (J = q.name) !== null && J !== void 0 ? J : "", $.source = (C = q.source) !== null && C !== void 0 ? C : 0, $.mimeType = (S = q.mimeType) !== null && S !== void 0 ? S : "", $.bitrate = (E = q.bitrate) !== null && E !== void 0 ? E : 0, $.disableDtx = (I = q.disableDtx) !== null && I !== void 0 ? I : !1, $.channels = (M = q.channels) !== null && M !== void 0 ? M : 0, $;
    }
  };
  function ee() {
    return { name: "", source: 0, mimeType: "", layers: [] };
  }
  a.IngressVideoOptions = {
    encode(q, J = l.default.Writer.create()) {
      if (q.name !== void 0 && q.name !== "" && J.uint32(10).string(q.name), q.source !== void 0 && q.source !== 0 && J.uint32(16).int32(q.source), q.mimeType !== void 0 && q.mimeType !== "" && J.uint32(26).string(q.mimeType), q.layers !== void 0 && q.layers.length !== 0)
        for (const C of q.layers)
          v.VideoLayer.encode(C, J.uint32(34).fork()).ldelim();
      return J;
    },
    decode(q, J) {
      const C = q instanceof l.default.Reader ? q : new l.default.Reader(q);
      let S = J === void 0 ? C.len : C.pos + J;
      const E = ee();
      for (; C.pos < S; ) {
        const I = C.uint32();
        switch (I >>> 3) {
          case 1:
            E.name = C.string();
            break;
          case 2:
            E.source = C.int32();
            break;
          case 3:
            E.mimeType = C.string();
            break;
          case 4:
            E.layers.push(v.VideoLayer.decode(C, C.uint32()));
            break;
          default:
            C.skipType(I & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(q) {
      return {
        name: be(q.name) ? String(q.name) : "",
        source: be(q.source) ? v.trackSourceFromJSON(q.source) : 0,
        mimeType: be(q.mimeType) ? String(q.mimeType) : "",
        layers: Array.isArray(q == null ? void 0 : q.layers) ? q.layers.map((J) => v.VideoLayer.fromJSON(J)) : []
      };
    },
    toJSON(q) {
      const J = {};
      return q.name !== void 0 && (J.name = q.name), q.source !== void 0 && (J.source = v.trackSourceToJSON(q.source)), q.mimeType !== void 0 && (J.mimeType = q.mimeType), q.layers ? J.layers = q.layers.map((C) => C ? v.VideoLayer.toJSON(C) : void 0) : J.layers = [], J;
    },
    fromPartial(q) {
      var J, C, S, E;
      const I = ee();
      return I.name = (J = q.name) !== null && J !== void 0 ? J : "", I.source = (C = q.source) !== null && C !== void 0 ? C : 0, I.mimeType = (S = q.mimeType) !== null && S !== void 0 ? S : "", I.layers = ((E = q.layers) === null || E === void 0 ? void 0 : E.map((M) => v.VideoLayer.fromPartial(M))) || [], I;
    }
  };
  function X() {
    return {
      ingressId: "",
      name: "",
      streamKey: "",
      url: "",
      inputType: 0,
      audio: void 0,
      video: void 0,
      roomName: "",
      participantIdentity: "",
      participantName: "",
      reusable: !1,
      state: void 0
    };
  }
  a.IngressInfo = {
    encode(q, J = l.default.Writer.create()) {
      return q.ingressId !== void 0 && q.ingressId !== "" && J.uint32(10).string(q.ingressId), q.name !== void 0 && q.name !== "" && J.uint32(18).string(q.name), q.streamKey !== void 0 && q.streamKey !== "" && J.uint32(26).string(q.streamKey), q.url !== void 0 && q.url !== "" && J.uint32(34).string(q.url), q.inputType !== void 0 && q.inputType !== 0 && J.uint32(40).int32(q.inputType), q.audio !== void 0 && a.IngressAudioOptions.encode(q.audio, J.uint32(50).fork()).ldelim(), q.video !== void 0 && a.IngressVideoOptions.encode(q.video, J.uint32(58).fork()).ldelim(), q.roomName !== void 0 && q.roomName !== "" && J.uint32(66).string(q.roomName), q.participantIdentity !== void 0 && q.participantIdentity !== "" && J.uint32(74).string(q.participantIdentity), q.participantName !== void 0 && q.participantName !== "" && J.uint32(82).string(q.participantName), q.reusable === !0 && J.uint32(88).bool(q.reusable), q.state !== void 0 && a.IngressState.encode(q.state, J.uint32(98).fork()).ldelim(), J;
    },
    decode(q, J) {
      const C = q instanceof l.default.Reader ? q : new l.default.Reader(q);
      let S = J === void 0 ? C.len : C.pos + J;
      const E = X();
      for (; C.pos < S; ) {
        const I = C.uint32();
        switch (I >>> 3) {
          case 1:
            E.ingressId = C.string();
            break;
          case 2:
            E.name = C.string();
            break;
          case 3:
            E.streamKey = C.string();
            break;
          case 4:
            E.url = C.string();
            break;
          case 5:
            E.inputType = C.int32();
            break;
          case 6:
            E.audio = a.IngressAudioOptions.decode(C, C.uint32());
            break;
          case 7:
            E.video = a.IngressVideoOptions.decode(C, C.uint32());
            break;
          case 8:
            E.roomName = C.string();
            break;
          case 9:
            E.participantIdentity = C.string();
            break;
          case 10:
            E.participantName = C.string();
            break;
          case 11:
            E.reusable = C.bool();
            break;
          case 12:
            E.state = a.IngressState.decode(C, C.uint32());
            break;
          default:
            C.skipType(I & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(q) {
      return {
        ingressId: be(q.ingressId) ? String(q.ingressId) : "",
        name: be(q.name) ? String(q.name) : "",
        streamKey: be(q.streamKey) ? String(q.streamKey) : "",
        url: be(q.url) ? String(q.url) : "",
        inputType: be(q.inputType) ? _(q.inputType) : 0,
        audio: be(q.audio) ? a.IngressAudioOptions.fromJSON(q.audio) : void 0,
        video: be(q.video) ? a.IngressVideoOptions.fromJSON(q.video) : void 0,
        roomName: be(q.roomName) ? String(q.roomName) : "",
        participantIdentity: be(q.participantIdentity) ? String(q.participantIdentity) : "",
        participantName: be(q.participantName) ? String(q.participantName) : "",
        reusable: be(q.reusable) ? !!q.reusable : !1,
        state: be(q.state) ? a.IngressState.fromJSON(q.state) : void 0
      };
    },
    toJSON(q) {
      const J = {};
      return q.ingressId !== void 0 && (J.ingressId = q.ingressId), q.name !== void 0 && (J.name = q.name), q.streamKey !== void 0 && (J.streamKey = q.streamKey), q.url !== void 0 && (J.url = q.url), q.inputType !== void 0 && (J.inputType = k(q.inputType)), q.audio !== void 0 && (J.audio = q.audio ? a.IngressAudioOptions.toJSON(q.audio) : void 0), q.video !== void 0 && (J.video = q.video ? a.IngressVideoOptions.toJSON(q.video) : void 0), q.roomName !== void 0 && (J.roomName = q.roomName), q.participantIdentity !== void 0 && (J.participantIdentity = q.participantIdentity), q.participantName !== void 0 && (J.participantName = q.participantName), q.reusable !== void 0 && (J.reusable = q.reusable), q.state !== void 0 && (J.state = q.state ? a.IngressState.toJSON(q.state) : void 0), J;
    },
    fromPartial(q) {
      var J, C, S, E, I, M, $, U, Y;
      const L = X();
      return L.ingressId = (J = q.ingressId) !== null && J !== void 0 ? J : "", L.name = (C = q.name) !== null && C !== void 0 ? C : "", L.streamKey = (S = q.streamKey) !== null && S !== void 0 ? S : "", L.url = (E = q.url) !== null && E !== void 0 ? E : "", L.inputType = (I = q.inputType) !== null && I !== void 0 ? I : 0, L.audio = q.audio !== void 0 && q.audio !== null ? a.IngressAudioOptions.fromPartial(q.audio) : void 0, L.video = q.video !== void 0 && q.video !== null ? a.IngressVideoOptions.fromPartial(q.video) : void 0, L.roomName = (M = q.roomName) !== null && M !== void 0 ? M : "", L.participantIdentity = ($ = q.participantIdentity) !== null && $ !== void 0 ? $ : "", L.participantName = (U = q.participantName) !== null && U !== void 0 ? U : "", L.reusable = (Y = q.reusable) !== null && Y !== void 0 ? Y : !1, L.state = q.state !== void 0 && q.state !== null ? a.IngressState.fromPartial(q.state) : void 0, L;
    }
  };
  function ae() {
    return { status: 0, error: "", video: void 0, audio: void 0, roomId: "", startedAt: 0, tracks: [] };
  }
  a.IngressState = {
    encode(q, J = l.default.Writer.create()) {
      if (q.status !== void 0 && q.status !== 0 && J.uint32(8).int32(q.status), q.error !== void 0 && q.error !== "" && J.uint32(18).string(q.error), q.video !== void 0 && a.InputVideoState.encode(q.video, J.uint32(26).fork()).ldelim(), q.audio !== void 0 && a.InputAudioState.encode(q.audio, J.uint32(34).fork()).ldelim(), q.roomId !== void 0 && q.roomId !== "" && J.uint32(42).string(q.roomId), q.startedAt !== void 0 && q.startedAt !== 0 && J.uint32(56).int64(q.startedAt), q.tracks !== void 0 && q.tracks.length !== 0)
        for (const C of q.tracks)
          v.TrackInfo.encode(C, J.uint32(50).fork()).ldelim();
      return J;
    },
    decode(q, J) {
      const C = q instanceof l.default.Reader ? q : new l.default.Reader(q);
      let S = J === void 0 ? C.len : C.pos + J;
      const E = ae();
      for (; C.pos < S; ) {
        const I = C.uint32();
        switch (I >>> 3) {
          case 1:
            E.status = C.int32();
            break;
          case 2:
            E.error = C.string();
            break;
          case 3:
            E.video = a.InputVideoState.decode(C, C.uint32());
            break;
          case 4:
            E.audio = a.InputAudioState.decode(C, C.uint32());
            break;
          case 5:
            E.roomId = C.string();
            break;
          case 7:
            E.startedAt = Le(C.int64());
            break;
          case 6:
            E.tracks.push(v.TrackInfo.decode(C, C.uint32()));
            break;
          default:
            C.skipType(I & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(q) {
      return {
        status: be(q.status) ? D(q.status) : 0,
        error: be(q.error) ? String(q.error) : "",
        video: be(q.video) ? a.InputVideoState.fromJSON(q.video) : void 0,
        audio: be(q.audio) ? a.InputAudioState.fromJSON(q.audio) : void 0,
        roomId: be(q.roomId) ? String(q.roomId) : "",
        startedAt: be(q.startedAt) ? Number(q.startedAt) : 0,
        tracks: Array.isArray(q == null ? void 0 : q.tracks) ? q.tracks.map((J) => v.TrackInfo.fromJSON(J)) : []
      };
    },
    toJSON(q) {
      const J = {};
      return q.status !== void 0 && (J.status = F(q.status)), q.error !== void 0 && (J.error = q.error), q.video !== void 0 && (J.video = q.video ? a.InputVideoState.toJSON(q.video) : void 0), q.audio !== void 0 && (J.audio = q.audio ? a.InputAudioState.toJSON(q.audio) : void 0), q.roomId !== void 0 && (J.roomId = q.roomId), q.startedAt !== void 0 && (J.startedAt = Math.round(q.startedAt)), q.tracks ? J.tracks = q.tracks.map((C) => C ? v.TrackInfo.toJSON(C) : void 0) : J.tracks = [], J;
    },
    fromPartial(q) {
      var J, C, S, E, I;
      const M = ae();
      return M.status = (J = q.status) !== null && J !== void 0 ? J : 0, M.error = (C = q.error) !== null && C !== void 0 ? C : "", M.video = q.video !== void 0 && q.video !== null ? a.InputVideoState.fromPartial(q.video) : void 0, M.audio = q.audio !== void 0 && q.audio !== null ? a.InputAudioState.fromPartial(q.audio) : void 0, M.roomId = (S = q.roomId) !== null && S !== void 0 ? S : "", M.startedAt = (E = q.startedAt) !== null && E !== void 0 ? E : 0, M.tracks = ((I = q.tracks) === null || I === void 0 ? void 0 : I.map(($) => v.TrackInfo.fromPartial($))) || [], M;
    }
  };
  function Q() {
    return { mimeType: 0, width: 0, height: 0, framerate: 0 };
  }
  a.InputVideoState = {
    encode(q, J = l.default.Writer.create()) {
      return q.mimeType !== void 0 && q.mimeType !== 0 && J.uint32(8).uint32(q.mimeType), q.width !== void 0 && q.width !== 0 && J.uint32(24).uint32(q.width), q.height !== void 0 && q.height !== 0 && J.uint32(32).uint32(q.height), q.framerate !== void 0 && q.framerate !== 0 && J.uint32(40).uint32(q.framerate), J;
    },
    decode(q, J) {
      const C = q instanceof l.default.Reader ? q : new l.default.Reader(q);
      let S = J === void 0 ? C.len : C.pos + J;
      const E = Q();
      for (; C.pos < S; ) {
        const I = C.uint32();
        switch (I >>> 3) {
          case 1:
            E.mimeType = C.uint32();
            break;
          case 3:
            E.width = C.uint32();
            break;
          case 4:
            E.height = C.uint32();
            break;
          case 5:
            E.framerate = C.uint32();
            break;
          default:
            C.skipType(I & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(q) {
      return {
        mimeType: be(q.mimeType) ? Number(q.mimeType) : 0,
        width: be(q.width) ? Number(q.width) : 0,
        height: be(q.height) ? Number(q.height) : 0,
        framerate: be(q.framerate) ? Number(q.framerate) : 0
      };
    },
    toJSON(q) {
      const J = {};
      return q.mimeType !== void 0 && (J.mimeType = Math.round(q.mimeType)), q.width !== void 0 && (J.width = Math.round(q.width)), q.height !== void 0 && (J.height = Math.round(q.height)), q.framerate !== void 0 && (J.framerate = Math.round(q.framerate)), J;
    },
    fromPartial(q) {
      var J, C, S, E;
      const I = Q();
      return I.mimeType = (J = q.mimeType) !== null && J !== void 0 ? J : 0, I.width = (C = q.width) !== null && C !== void 0 ? C : 0, I.height = (S = q.height) !== null && S !== void 0 ? S : 0, I.framerate = (E = q.framerate) !== null && E !== void 0 ? E : 0, I;
    }
  };
  function ne() {
    return { mimeType: 0, channels: 0, sampleRate: 0 };
  }
  a.InputAudioState = {
    encode(q, J = l.default.Writer.create()) {
      return q.mimeType !== void 0 && q.mimeType !== 0 && J.uint32(8).uint32(q.mimeType), q.channels !== void 0 && q.channels !== 0 && J.uint32(24).uint32(q.channels), q.sampleRate !== void 0 && q.sampleRate !== 0 && J.uint32(32).uint32(q.sampleRate), J;
    },
    decode(q, J) {
      const C = q instanceof l.default.Reader ? q : new l.default.Reader(q);
      let S = J === void 0 ? C.len : C.pos + J;
      const E = ne();
      for (; C.pos < S; ) {
        const I = C.uint32();
        switch (I >>> 3) {
          case 1:
            E.mimeType = C.uint32();
            break;
          case 3:
            E.channels = C.uint32();
            break;
          case 4:
            E.sampleRate = C.uint32();
            break;
          default:
            C.skipType(I & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(q) {
      return {
        mimeType: be(q.mimeType) ? Number(q.mimeType) : 0,
        channels: be(q.channels) ? Number(q.channels) : 0,
        sampleRate: be(q.sampleRate) ? Number(q.sampleRate) : 0
      };
    },
    toJSON(q) {
      const J = {};
      return q.mimeType !== void 0 && (J.mimeType = Math.round(q.mimeType)), q.channels !== void 0 && (J.channels = Math.round(q.channels)), q.sampleRate !== void 0 && (J.sampleRate = Math.round(q.sampleRate)), J;
    },
    fromPartial(q) {
      var J, C, S;
      const E = ne();
      return E.mimeType = (J = q.mimeType) !== null && J !== void 0 ? J : 0, E.channels = (C = q.channels) !== null && C !== void 0 ? C : 0, E.sampleRate = (S = q.sampleRate) !== null && S !== void 0 ? S : 0, E;
    }
  };
  function Z() {
    return {
      ingressId: "",
      name: "",
      roomName: "",
      participantIdentity: "",
      participantName: "",
      audio: void 0,
      video: void 0
    };
  }
  a.UpdateIngressRequest = {
    encode(q, J = l.default.Writer.create()) {
      return q.ingressId !== void 0 && q.ingressId !== "" && J.uint32(10).string(q.ingressId), q.name !== void 0 && q.name !== "" && J.uint32(18).string(q.name), q.roomName !== void 0 && q.roomName !== "" && J.uint32(26).string(q.roomName), q.participantIdentity !== void 0 && q.participantIdentity !== "" && J.uint32(34).string(q.participantIdentity), q.participantName !== void 0 && q.participantName !== "" && J.uint32(42).string(q.participantName), q.audio !== void 0 && a.IngressAudioOptions.encode(q.audio, J.uint32(50).fork()).ldelim(), q.video !== void 0 && a.IngressVideoOptions.encode(q.video, J.uint32(58).fork()).ldelim(), J;
    },
    decode(q, J) {
      const C = q instanceof l.default.Reader ? q : new l.default.Reader(q);
      let S = J === void 0 ? C.len : C.pos + J;
      const E = Z();
      for (; C.pos < S; ) {
        const I = C.uint32();
        switch (I >>> 3) {
          case 1:
            E.ingressId = C.string();
            break;
          case 2:
            E.name = C.string();
            break;
          case 3:
            E.roomName = C.string();
            break;
          case 4:
            E.participantIdentity = C.string();
            break;
          case 5:
            E.participantName = C.string();
            break;
          case 6:
            E.audio = a.IngressAudioOptions.decode(C, C.uint32());
            break;
          case 7:
            E.video = a.IngressVideoOptions.decode(C, C.uint32());
            break;
          default:
            C.skipType(I & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(q) {
      return {
        ingressId: be(q.ingressId) ? String(q.ingressId) : "",
        name: be(q.name) ? String(q.name) : "",
        roomName: be(q.roomName) ? String(q.roomName) : "",
        participantIdentity: be(q.participantIdentity) ? String(q.participantIdentity) : "",
        participantName: be(q.participantName) ? String(q.participantName) : "",
        audio: be(q.audio) ? a.IngressAudioOptions.fromJSON(q.audio) : void 0,
        video: be(q.video) ? a.IngressVideoOptions.fromJSON(q.video) : void 0
      };
    },
    toJSON(q) {
      const J = {};
      return q.ingressId !== void 0 && (J.ingressId = q.ingressId), q.name !== void 0 && (J.name = q.name), q.roomName !== void 0 && (J.roomName = q.roomName), q.participantIdentity !== void 0 && (J.participantIdentity = q.participantIdentity), q.participantName !== void 0 && (J.participantName = q.participantName), q.audio !== void 0 && (J.audio = q.audio ? a.IngressAudioOptions.toJSON(q.audio) : void 0), q.video !== void 0 && (J.video = q.video ? a.IngressVideoOptions.toJSON(q.video) : void 0), J;
    },
    fromPartial(q) {
      var J, C, S, E, I;
      const M = Z();
      return M.ingressId = (J = q.ingressId) !== null && J !== void 0 ? J : "", M.name = (C = q.name) !== null && C !== void 0 ? C : "", M.roomName = (S = q.roomName) !== null && S !== void 0 ? S : "", M.participantIdentity = (E = q.participantIdentity) !== null && E !== void 0 ? E : "", M.participantName = (I = q.participantName) !== null && I !== void 0 ? I : "", M.audio = q.audio !== void 0 && q.audio !== null ? a.IngressAudioOptions.fromPartial(q.audio) : void 0, M.video = q.video !== void 0 && q.video !== null ? a.IngressVideoOptions.fromPartial(q.video) : void 0, M;
    }
  };
  function de() {
    return { roomName: "" };
  }
  a.ListIngressRequest = {
    encode(q, J = l.default.Writer.create()) {
      return q.roomName !== void 0 && q.roomName !== "" && J.uint32(10).string(q.roomName), J;
    },
    decode(q, J) {
      const C = q instanceof l.default.Reader ? q : new l.default.Reader(q);
      let S = J === void 0 ? C.len : C.pos + J;
      const E = de();
      for (; C.pos < S; ) {
        const I = C.uint32();
        switch (I >>> 3) {
          case 1:
            E.roomName = C.string();
            break;
          default:
            C.skipType(I & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(q) {
      return { roomName: be(q.roomName) ? String(q.roomName) : "" };
    },
    toJSON(q) {
      const J = {};
      return q.roomName !== void 0 && (J.roomName = q.roomName), J;
    },
    fromPartial(q) {
      var J;
      const C = de();
      return C.roomName = (J = q.roomName) !== null && J !== void 0 ? J : "", C;
    }
  };
  function fe() {
    return { items: [] };
  }
  a.ListIngressResponse = {
    encode(q, J = l.default.Writer.create()) {
      if (q.items !== void 0 && q.items.length !== 0)
        for (const C of q.items)
          a.IngressInfo.encode(C, J.uint32(10).fork()).ldelim();
      return J;
    },
    decode(q, J) {
      const C = q instanceof l.default.Reader ? q : new l.default.Reader(q);
      let S = J === void 0 ? C.len : C.pos + J;
      const E = fe();
      for (; C.pos < S; ) {
        const I = C.uint32();
        switch (I >>> 3) {
          case 1:
            E.items.push(a.IngressInfo.decode(C, C.uint32()));
            break;
          default:
            C.skipType(I & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(q) {
      return { items: Array.isArray(q == null ? void 0 : q.items) ? q.items.map((J) => a.IngressInfo.fromJSON(J)) : [] };
    },
    toJSON(q) {
      const J = {};
      return q.items ? J.items = q.items.map((C) => C ? a.IngressInfo.toJSON(C) : void 0) : J.items = [], J;
    },
    fromPartial(q) {
      var J;
      const C = fe();
      return C.items = ((J = q.items) === null || J === void 0 ? void 0 : J.map((S) => a.IngressInfo.fromPartial(S))) || [], C;
    }
  };
  function Te() {
    return { ingressId: "" };
  }
  a.DeleteIngressRequest = {
    encode(q, J = l.default.Writer.create()) {
      return q.ingressId !== void 0 && q.ingressId !== "" && J.uint32(10).string(q.ingressId), J;
    },
    decode(q, J) {
      const C = q instanceof l.default.Reader ? q : new l.default.Reader(q);
      let S = J === void 0 ? C.len : C.pos + J;
      const E = Te();
      for (; C.pos < S; ) {
        const I = C.uint32();
        switch (I >>> 3) {
          case 1:
            E.ingressId = C.string();
            break;
          default:
            C.skipType(I & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(q) {
      return { ingressId: be(q.ingressId) ? String(q.ingressId) : "" };
    },
    toJSON(q) {
      const J = {};
      return q.ingressId !== void 0 && (J.ingressId = q.ingressId), J;
    },
    fromPartial(q) {
      var J;
      const C = Te();
      return C.ingressId = (J = q.ingressId) !== null && J !== void 0 ? J : "", C;
    }
  };
  var Re = (() => {
    if (typeof Re < "u")
      return Re;
    if (typeof self < "u")
      return self;
    if (typeof window < "u")
      return window;
    if (typeof commonjsGlobal$1 < "u")
      return commonjsGlobal$1;
    throw "Unable to locate global object";
  })();
  function Le(q) {
    if (q.gt(Number.MAX_SAFE_INTEGER))
      throw new Re.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    return q.toNumber();
  }
  l.default.util.Long !== c.default && (l.default.util.Long = c.default, l.default.configure());
  function be(q) {
    return q != null;
  }
})(livekit_ingress);
var __awaiter$1 = commonjsGlobal$1 && commonjsGlobal$1.__awaiter || function(a, u, c, l) {
  function v(p) {
    return p instanceof c ? p : new c(function(_) {
      _(p);
    });
  }
  return new (c || (c = Promise))(function(p, _) {
    function k(F) {
      try {
        D(l.next(F));
      } catch (z) {
        _(z);
      }
    }
    function O(F) {
      try {
        D(l.throw(F));
      } catch (z) {
        _(z);
      }
    }
    function D(F) {
      F.done ? p(F.value) : v(F.value).then(k, O);
    }
    D((l = l.apply(a, u || [])).next());
  });
}, __importDefault$3 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(IngressClient$1, "__esModule", { value: !0 });
IngressClient$1.IngressClient = void 0;
const livekit_ingress_1$1 = livekit_ingress, ServiceBase_1$1 = __importDefault$3(ServiceBase$1), TwirpRPC_1$1 = TwirpRPC, svc$1 = "Ingress";
class IngressClient extends ServiceBase_1$1.default {
  /**
   * @param host hostname including protocol. i.e. 'https://cluster.livekit.io'
   * @param apiKey API Key, can be set in env var LIVEKIT_API_KEY
   * @param secret API Secret, can be set in env var LIVEKIT_API_SECRET
   */
  constructor(u, c, l) {
    super(c, l), this.rpc = new TwirpRPC_1$1.TwirpRpc(u, TwirpRPC_1$1.livekitPackage);
  }
  /**
   * @param inputType protocol for the ingress
   * @param opts CreateIngressOptions
   */
  createIngress(u, c) {
    return __awaiter$1(this, void 0, void 0, function* () {
      let l = "", v = "", p = "", _ = "", k, O;
      c !== void 0 && (l = c.name || "", v = c.roomName || "", p = c.participantName || "", _ = c.participantIdentity || "", k = c.audioParams, O = c.videoParams);
      const D = livekit_ingress_1$1.CreateIngressRequest.toJSON({
        inputType: u,
        name: l,
        roomName: v,
        participantIdentity: _,
        participantName: p,
        audio: k,
        video: O
      }), F = yield this.rpc.request(svc$1, "CreateIngress", D, this.authHeader({ ingressAdmin: !0 }));
      return livekit_ingress_1$1.IngressInfo.fromJSON(F);
    });
  }
  /**
   * @param ingressId ID of the ingress to update
   * @param opts UpdateIngressOptions
   */
  updateIngress(u, c) {
    return __awaiter$1(this, void 0, void 0, function* () {
      const l = c.name || "", v = c.roomName || "", p = c.participantName || "", _ = c.participantIdentity || "", k = c.audioParams, O = c.videoParams, D = livekit_ingress_1$1.UpdateIngressRequest.toJSON({
        ingressId: u,
        name: l,
        roomName: v,
        participantIdentity: _,
        participantName: p,
        audio: k,
        video: O
      }), F = yield this.rpc.request(svc$1, "UpdateIngress", D, this.authHeader({ ingressAdmin: !0 }));
      return livekit_ingress_1$1.IngressInfo.fromJSON(F);
    });
  }
  /**
   * @param roomName list ingress for one room only
   */
  listIngress(u) {
    var c;
    return __awaiter$1(this, void 0, void 0, function* () {
      u ?? (u = "");
      const l = yield this.rpc.request(svc$1, "ListIngress", livekit_ingress_1$1.ListIngressRequest.toJSON({ roomName: u }), this.authHeader({ ingressAdmin: !0 }));
      return (c = livekit_ingress_1$1.ListIngressResponse.fromJSON(l).items) !== null && c !== void 0 ? c : [];
    });
  }
  /**
   * @param ingressId ingress to delete
   */
  deleteIngress(u) {
    return __awaiter$1(this, void 0, void 0, function* () {
      const c = yield this.rpc.request(svc$1, "DeleteIngress", livekit_ingress_1$1.DeleteIngressRequest.toJSON({ ingressId: u }), this.authHeader({ ingressAdmin: !0 }));
      return livekit_ingress_1$1.IngressInfo.fromJSON(c);
    });
  }
}
IngressClient$1.IngressClient = IngressClient;
var RoomServiceClient$1 = {}, livekit_room = {};
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(C) {
    return C && C.__esModule ? C : { default: C };
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.UpdateRoomMetadataRequest = a.SendDataResponse = a.SendDataRequest = a.UpdateSubscriptionsResponse = a.UpdateSubscriptionsRequest = a.UpdateParticipantRequest = a.MuteRoomTrackResponse = a.MuteRoomTrackRequest = a.RemoveParticipantResponse = a.RoomParticipantIdentity = a.ListParticipantsResponse = a.ListParticipantsRequest = a.DeleteRoomResponse = a.DeleteRoomRequest = a.ListRoomsResponse = a.ListRoomsRequest = a.RoomEgress = a.CreateRoomRequest = a.protobufPackage = void 0;
  const c = u(minimal), l = livekit_egress, v = livekit_models;
  a.protobufPackage = "livekit";
  function p() {
    return { name: "", emptyTimeout: 0, maxParticipants: 0, nodeId: "", metadata: "", egress: void 0 };
  }
  a.CreateRoomRequest = {
    encode(C, S = c.default.Writer.create()) {
      return C.name !== void 0 && C.name !== "" && S.uint32(10).string(C.name), C.emptyTimeout !== void 0 && C.emptyTimeout !== 0 && S.uint32(16).uint32(C.emptyTimeout), C.maxParticipants !== void 0 && C.maxParticipants !== 0 && S.uint32(24).uint32(C.maxParticipants), C.nodeId !== void 0 && C.nodeId !== "" && S.uint32(34).string(C.nodeId), C.metadata !== void 0 && C.metadata !== "" && S.uint32(42).string(C.metadata), C.egress !== void 0 && a.RoomEgress.encode(C.egress, S.uint32(50).fork()).ldelim(), S;
    },
    decode(C, S) {
      const E = C instanceof c.default.Reader ? C : new c.default.Reader(C);
      let I = S === void 0 ? E.len : E.pos + S;
      const M = p();
      for (; E.pos < I; ) {
        const $ = E.uint32();
        switch ($ >>> 3) {
          case 1:
            M.name = E.string();
            break;
          case 2:
            M.emptyTimeout = E.uint32();
            break;
          case 3:
            M.maxParticipants = E.uint32();
            break;
          case 4:
            M.nodeId = E.string();
            break;
          case 5:
            M.metadata = E.string();
            break;
          case 6:
            M.egress = a.RoomEgress.decode(E, E.uint32());
            break;
          default:
            E.skipType($ & 7);
            break;
        }
      }
      return M;
    },
    fromJSON(C) {
      return {
        name: J(C.name) ? String(C.name) : "",
        emptyTimeout: J(C.emptyTimeout) ? Number(C.emptyTimeout) : 0,
        maxParticipants: J(C.maxParticipants) ? Number(C.maxParticipants) : 0,
        nodeId: J(C.nodeId) ? String(C.nodeId) : "",
        metadata: J(C.metadata) ? String(C.metadata) : "",
        egress: J(C.egress) ? a.RoomEgress.fromJSON(C.egress) : void 0
      };
    },
    toJSON(C) {
      const S = {};
      return C.name !== void 0 && (S.name = C.name), C.emptyTimeout !== void 0 && (S.emptyTimeout = Math.round(C.emptyTimeout)), C.maxParticipants !== void 0 && (S.maxParticipants = Math.round(C.maxParticipants)), C.nodeId !== void 0 && (S.nodeId = C.nodeId), C.metadata !== void 0 && (S.metadata = C.metadata), C.egress !== void 0 && (S.egress = C.egress ? a.RoomEgress.toJSON(C.egress) : void 0), S;
    },
    fromPartial(C) {
      var S, E, I, M, $;
      const U = p();
      return U.name = (S = C.name) !== null && S !== void 0 ? S : "", U.emptyTimeout = (E = C.emptyTimeout) !== null && E !== void 0 ? E : 0, U.maxParticipants = (I = C.maxParticipants) !== null && I !== void 0 ? I : 0, U.nodeId = (M = C.nodeId) !== null && M !== void 0 ? M : "", U.metadata = ($ = C.metadata) !== null && $ !== void 0 ? $ : "", U.egress = C.egress !== void 0 && C.egress !== null ? a.RoomEgress.fromPartial(C.egress) : void 0, U;
    }
  };
  function _() {
    return { room: void 0, tracks: void 0 };
  }
  a.RoomEgress = {
    encode(C, S = c.default.Writer.create()) {
      return C.room !== void 0 && l.RoomCompositeEgressRequest.encode(C.room, S.uint32(10).fork()).ldelim(), C.tracks !== void 0 && l.AutoTrackEgress.encode(C.tracks, S.uint32(18).fork()).ldelim(), S;
    },
    decode(C, S) {
      const E = C instanceof c.default.Reader ? C : new c.default.Reader(C);
      let I = S === void 0 ? E.len : E.pos + S;
      const M = _();
      for (; E.pos < I; ) {
        const $ = E.uint32();
        switch ($ >>> 3) {
          case 1:
            M.room = l.RoomCompositeEgressRequest.decode(E, E.uint32());
            break;
          case 2:
            M.tracks = l.AutoTrackEgress.decode(E, E.uint32());
            break;
          default:
            E.skipType($ & 7);
            break;
        }
      }
      return M;
    },
    fromJSON(C) {
      return {
        room: J(C.room) ? l.RoomCompositeEgressRequest.fromJSON(C.room) : void 0,
        tracks: J(C.tracks) ? l.AutoTrackEgress.fromJSON(C.tracks) : void 0
      };
    },
    toJSON(C) {
      const S = {};
      return C.room !== void 0 && (S.room = C.room ? l.RoomCompositeEgressRequest.toJSON(C.room) : void 0), C.tracks !== void 0 && (S.tracks = C.tracks ? l.AutoTrackEgress.toJSON(C.tracks) : void 0), S;
    },
    fromPartial(C) {
      const S = _();
      return S.room = C.room !== void 0 && C.room !== null ? l.RoomCompositeEgressRequest.fromPartial(C.room) : void 0, S.tracks = C.tracks !== void 0 && C.tracks !== null ? l.AutoTrackEgress.fromPartial(C.tracks) : void 0, S;
    }
  };
  function k() {
    return { names: [] };
  }
  a.ListRoomsRequest = {
    encode(C, S = c.default.Writer.create()) {
      if (C.names !== void 0 && C.names.length !== 0)
        for (const E of C.names)
          S.uint32(10).string(E);
      return S;
    },
    decode(C, S) {
      const E = C instanceof c.default.Reader ? C : new c.default.Reader(C);
      let I = S === void 0 ? E.len : E.pos + S;
      const M = k();
      for (; E.pos < I; ) {
        const $ = E.uint32();
        switch ($ >>> 3) {
          case 1:
            M.names.push(E.string());
            break;
          default:
            E.skipType($ & 7);
            break;
        }
      }
      return M;
    },
    fromJSON(C) {
      return { names: Array.isArray(C == null ? void 0 : C.names) ? C.names.map((S) => String(S)) : [] };
    },
    toJSON(C) {
      const S = {};
      return C.names ? S.names = C.names.map((E) => E) : S.names = [], S;
    },
    fromPartial(C) {
      var S;
      const E = k();
      return E.names = ((S = C.names) === null || S === void 0 ? void 0 : S.map((I) => I)) || [], E;
    }
  };
  function O() {
    return { rooms: [] };
  }
  a.ListRoomsResponse = {
    encode(C, S = c.default.Writer.create()) {
      if (C.rooms !== void 0 && C.rooms.length !== 0)
        for (const E of C.rooms)
          v.Room.encode(E, S.uint32(10).fork()).ldelim();
      return S;
    },
    decode(C, S) {
      const E = C instanceof c.default.Reader ? C : new c.default.Reader(C);
      let I = S === void 0 ? E.len : E.pos + S;
      const M = O();
      for (; E.pos < I; ) {
        const $ = E.uint32();
        switch ($ >>> 3) {
          case 1:
            M.rooms.push(v.Room.decode(E, E.uint32()));
            break;
          default:
            E.skipType($ & 7);
            break;
        }
      }
      return M;
    },
    fromJSON(C) {
      return { rooms: Array.isArray(C == null ? void 0 : C.rooms) ? C.rooms.map((S) => v.Room.fromJSON(S)) : [] };
    },
    toJSON(C) {
      const S = {};
      return C.rooms ? S.rooms = C.rooms.map((E) => E ? v.Room.toJSON(E) : void 0) : S.rooms = [], S;
    },
    fromPartial(C) {
      var S;
      const E = O();
      return E.rooms = ((S = C.rooms) === null || S === void 0 ? void 0 : S.map((I) => v.Room.fromPartial(I))) || [], E;
    }
  };
  function D() {
    return { room: "" };
  }
  a.DeleteRoomRequest = {
    encode(C, S = c.default.Writer.create()) {
      return C.room !== void 0 && C.room !== "" && S.uint32(10).string(C.room), S;
    },
    decode(C, S) {
      const E = C instanceof c.default.Reader ? C : new c.default.Reader(C);
      let I = S === void 0 ? E.len : E.pos + S;
      const M = D();
      for (; E.pos < I; ) {
        const $ = E.uint32();
        switch ($ >>> 3) {
          case 1:
            M.room = E.string();
            break;
          default:
            E.skipType($ & 7);
            break;
        }
      }
      return M;
    },
    fromJSON(C) {
      return { room: J(C.room) ? String(C.room) : "" };
    },
    toJSON(C) {
      const S = {};
      return C.room !== void 0 && (S.room = C.room), S;
    },
    fromPartial(C) {
      var S;
      const E = D();
      return E.room = (S = C.room) !== null && S !== void 0 ? S : "", E;
    }
  };
  function F() {
    return {};
  }
  a.DeleteRoomResponse = {
    encode(C, S = c.default.Writer.create()) {
      return S;
    },
    decode(C, S) {
      const E = C instanceof c.default.Reader ? C : new c.default.Reader(C);
      let I = S === void 0 ? E.len : E.pos + S;
      const M = F();
      for (; E.pos < I; ) {
        const $ = E.uint32();
        switch ($ >>> 3) {
          default:
            E.skipType($ & 7);
            break;
        }
      }
      return M;
    },
    fromJSON(C) {
      return {};
    },
    toJSON(C) {
      return {};
    },
    fromPartial(C) {
      return F();
    }
  };
  function z() {
    return { room: "" };
  }
  a.ListParticipantsRequest = {
    encode(C, S = c.default.Writer.create()) {
      return C.room !== void 0 && C.room !== "" && S.uint32(10).string(C.room), S;
    },
    decode(C, S) {
      const E = C instanceof c.default.Reader ? C : new c.default.Reader(C);
      let I = S === void 0 ? E.len : E.pos + S;
      const M = z();
      for (; E.pos < I; ) {
        const $ = E.uint32();
        switch ($ >>> 3) {
          case 1:
            M.room = E.string();
            break;
          default:
            E.skipType($ & 7);
            break;
        }
      }
      return M;
    },
    fromJSON(C) {
      return { room: J(C.room) ? String(C.room) : "" };
    },
    toJSON(C) {
      const S = {};
      return C.room !== void 0 && (S.room = C.room), S;
    },
    fromPartial(C) {
      var S;
      const E = z();
      return E.room = (S = C.room) !== null && S !== void 0 ? S : "", E;
    }
  };
  function j() {
    return { participants: [] };
  }
  a.ListParticipantsResponse = {
    encode(C, S = c.default.Writer.create()) {
      if (C.participants !== void 0 && C.participants.length !== 0)
        for (const E of C.participants)
          v.ParticipantInfo.encode(E, S.uint32(10).fork()).ldelim();
      return S;
    },
    decode(C, S) {
      const E = C instanceof c.default.Reader ? C : new c.default.Reader(C);
      let I = S === void 0 ? E.len : E.pos + S;
      const M = j();
      for (; E.pos < I; ) {
        const $ = E.uint32();
        switch ($ >>> 3) {
          case 1:
            M.participants.push(v.ParticipantInfo.decode(E, E.uint32()));
            break;
          default:
            E.skipType($ & 7);
            break;
        }
      }
      return M;
    },
    fromJSON(C) {
      return {
        participants: Array.isArray(C == null ? void 0 : C.participants) ? C.participants.map((S) => v.ParticipantInfo.fromJSON(S)) : []
      };
    },
    toJSON(C) {
      const S = {};
      return C.participants ? S.participants = C.participants.map((E) => E ? v.ParticipantInfo.toJSON(E) : void 0) : S.participants = [], S;
    },
    fromPartial(C) {
      var S;
      const E = j();
      return E.participants = ((S = C.participants) === null || S === void 0 ? void 0 : S.map((I) => v.ParticipantInfo.fromPartial(I))) || [], E;
    }
  };
  function ee() {
    return { room: "", identity: "" };
  }
  a.RoomParticipantIdentity = {
    encode(C, S = c.default.Writer.create()) {
      return C.room !== void 0 && C.room !== "" && S.uint32(10).string(C.room), C.identity !== void 0 && C.identity !== "" && S.uint32(18).string(C.identity), S;
    },
    decode(C, S) {
      const E = C instanceof c.default.Reader ? C : new c.default.Reader(C);
      let I = S === void 0 ? E.len : E.pos + S;
      const M = ee();
      for (; E.pos < I; ) {
        const $ = E.uint32();
        switch ($ >>> 3) {
          case 1:
            M.room = E.string();
            break;
          case 2:
            M.identity = E.string();
            break;
          default:
            E.skipType($ & 7);
            break;
        }
      }
      return M;
    },
    fromJSON(C) {
      return {
        room: J(C.room) ? String(C.room) : "",
        identity: J(C.identity) ? String(C.identity) : ""
      };
    },
    toJSON(C) {
      const S = {};
      return C.room !== void 0 && (S.room = C.room), C.identity !== void 0 && (S.identity = C.identity), S;
    },
    fromPartial(C) {
      var S, E;
      const I = ee();
      return I.room = (S = C.room) !== null && S !== void 0 ? S : "", I.identity = (E = C.identity) !== null && E !== void 0 ? E : "", I;
    }
  };
  function X() {
    return {};
  }
  a.RemoveParticipantResponse = {
    encode(C, S = c.default.Writer.create()) {
      return S;
    },
    decode(C, S) {
      const E = C instanceof c.default.Reader ? C : new c.default.Reader(C);
      let I = S === void 0 ? E.len : E.pos + S;
      const M = X();
      for (; E.pos < I; ) {
        const $ = E.uint32();
        switch ($ >>> 3) {
          default:
            E.skipType($ & 7);
            break;
        }
      }
      return M;
    },
    fromJSON(C) {
      return {};
    },
    toJSON(C) {
      return {};
    },
    fromPartial(C) {
      return X();
    }
  };
  function ae() {
    return { room: "", identity: "", trackSid: "", muted: !1 };
  }
  a.MuteRoomTrackRequest = {
    encode(C, S = c.default.Writer.create()) {
      return C.room !== void 0 && C.room !== "" && S.uint32(10).string(C.room), C.identity !== void 0 && C.identity !== "" && S.uint32(18).string(C.identity), C.trackSid !== void 0 && C.trackSid !== "" && S.uint32(26).string(C.trackSid), C.muted === !0 && S.uint32(32).bool(C.muted), S;
    },
    decode(C, S) {
      const E = C instanceof c.default.Reader ? C : new c.default.Reader(C);
      let I = S === void 0 ? E.len : E.pos + S;
      const M = ae();
      for (; E.pos < I; ) {
        const $ = E.uint32();
        switch ($ >>> 3) {
          case 1:
            M.room = E.string();
            break;
          case 2:
            M.identity = E.string();
            break;
          case 3:
            M.trackSid = E.string();
            break;
          case 4:
            M.muted = E.bool();
            break;
          default:
            E.skipType($ & 7);
            break;
        }
      }
      return M;
    },
    fromJSON(C) {
      return {
        room: J(C.room) ? String(C.room) : "",
        identity: J(C.identity) ? String(C.identity) : "",
        trackSid: J(C.trackSid) ? String(C.trackSid) : "",
        muted: J(C.muted) ? !!C.muted : !1
      };
    },
    toJSON(C) {
      const S = {};
      return C.room !== void 0 && (S.room = C.room), C.identity !== void 0 && (S.identity = C.identity), C.trackSid !== void 0 && (S.trackSid = C.trackSid), C.muted !== void 0 && (S.muted = C.muted), S;
    },
    fromPartial(C) {
      var S, E, I, M;
      const $ = ae();
      return $.room = (S = C.room) !== null && S !== void 0 ? S : "", $.identity = (E = C.identity) !== null && E !== void 0 ? E : "", $.trackSid = (I = C.trackSid) !== null && I !== void 0 ? I : "", $.muted = (M = C.muted) !== null && M !== void 0 ? M : !1, $;
    }
  };
  function Q() {
    return { track: void 0 };
  }
  a.MuteRoomTrackResponse = {
    encode(C, S = c.default.Writer.create()) {
      return C.track !== void 0 && v.TrackInfo.encode(C.track, S.uint32(10).fork()).ldelim(), S;
    },
    decode(C, S) {
      const E = C instanceof c.default.Reader ? C : new c.default.Reader(C);
      let I = S === void 0 ? E.len : E.pos + S;
      const M = Q();
      for (; E.pos < I; ) {
        const $ = E.uint32();
        switch ($ >>> 3) {
          case 1:
            M.track = v.TrackInfo.decode(E, E.uint32());
            break;
          default:
            E.skipType($ & 7);
            break;
        }
      }
      return M;
    },
    fromJSON(C) {
      return { track: J(C.track) ? v.TrackInfo.fromJSON(C.track) : void 0 };
    },
    toJSON(C) {
      const S = {};
      return C.track !== void 0 && (S.track = C.track ? v.TrackInfo.toJSON(C.track) : void 0), S;
    },
    fromPartial(C) {
      const S = Q();
      return S.track = C.track !== void 0 && C.track !== null ? v.TrackInfo.fromPartial(C.track) : void 0, S;
    }
  };
  function ne() {
    return { room: "", identity: "", metadata: "", permission: void 0, name: "" };
  }
  a.UpdateParticipantRequest = {
    encode(C, S = c.default.Writer.create()) {
      return C.room !== void 0 && C.room !== "" && S.uint32(10).string(C.room), C.identity !== void 0 && C.identity !== "" && S.uint32(18).string(C.identity), C.metadata !== void 0 && C.metadata !== "" && S.uint32(26).string(C.metadata), C.permission !== void 0 && v.ParticipantPermission.encode(C.permission, S.uint32(34).fork()).ldelim(), C.name !== void 0 && C.name !== "" && S.uint32(42).string(C.name), S;
    },
    decode(C, S) {
      const E = C instanceof c.default.Reader ? C : new c.default.Reader(C);
      let I = S === void 0 ? E.len : E.pos + S;
      const M = ne();
      for (; E.pos < I; ) {
        const $ = E.uint32();
        switch ($ >>> 3) {
          case 1:
            M.room = E.string();
            break;
          case 2:
            M.identity = E.string();
            break;
          case 3:
            M.metadata = E.string();
            break;
          case 4:
            M.permission = v.ParticipantPermission.decode(E, E.uint32());
            break;
          case 5:
            M.name = E.string();
            break;
          default:
            E.skipType($ & 7);
            break;
        }
      }
      return M;
    },
    fromJSON(C) {
      return {
        room: J(C.room) ? String(C.room) : "",
        identity: J(C.identity) ? String(C.identity) : "",
        metadata: J(C.metadata) ? String(C.metadata) : "",
        permission: J(C.permission) ? v.ParticipantPermission.fromJSON(C.permission) : void 0,
        name: J(C.name) ? String(C.name) : ""
      };
    },
    toJSON(C) {
      const S = {};
      return C.room !== void 0 && (S.room = C.room), C.identity !== void 0 && (S.identity = C.identity), C.metadata !== void 0 && (S.metadata = C.metadata), C.permission !== void 0 && (S.permission = C.permission ? v.ParticipantPermission.toJSON(C.permission) : void 0), C.name !== void 0 && (S.name = C.name), S;
    },
    fromPartial(C) {
      var S, E, I, M;
      const $ = ne();
      return $.room = (S = C.room) !== null && S !== void 0 ? S : "", $.identity = (E = C.identity) !== null && E !== void 0 ? E : "", $.metadata = (I = C.metadata) !== null && I !== void 0 ? I : "", $.permission = C.permission !== void 0 && C.permission !== null ? v.ParticipantPermission.fromPartial(C.permission) : void 0, $.name = (M = C.name) !== null && M !== void 0 ? M : "", $;
    }
  };
  function Z() {
    return { room: "", identity: "", trackSids: [], subscribe: !1, participantTracks: [] };
  }
  a.UpdateSubscriptionsRequest = {
    encode(C, S = c.default.Writer.create()) {
      if (C.room !== void 0 && C.room !== "" && S.uint32(10).string(C.room), C.identity !== void 0 && C.identity !== "" && S.uint32(18).string(C.identity), C.trackSids !== void 0 && C.trackSids.length !== 0)
        for (const E of C.trackSids)
          S.uint32(26).string(E);
      if (C.subscribe === !0 && S.uint32(32).bool(C.subscribe), C.participantTracks !== void 0 && C.participantTracks.length !== 0)
        for (const E of C.participantTracks)
          v.ParticipantTracks.encode(E, S.uint32(42).fork()).ldelim();
      return S;
    },
    decode(C, S) {
      const E = C instanceof c.default.Reader ? C : new c.default.Reader(C);
      let I = S === void 0 ? E.len : E.pos + S;
      const M = Z();
      for (; E.pos < I; ) {
        const $ = E.uint32();
        switch ($ >>> 3) {
          case 1:
            M.room = E.string();
            break;
          case 2:
            M.identity = E.string();
            break;
          case 3:
            M.trackSids.push(E.string());
            break;
          case 4:
            M.subscribe = E.bool();
            break;
          case 5:
            M.participantTracks.push(v.ParticipantTracks.decode(E, E.uint32()));
            break;
          default:
            E.skipType($ & 7);
            break;
        }
      }
      return M;
    },
    fromJSON(C) {
      return {
        room: J(C.room) ? String(C.room) : "",
        identity: J(C.identity) ? String(C.identity) : "",
        trackSids: Array.isArray(C == null ? void 0 : C.trackSids) ? C.trackSids.map((S) => String(S)) : [],
        subscribe: J(C.subscribe) ? !!C.subscribe : !1,
        participantTracks: Array.isArray(C == null ? void 0 : C.participantTracks) ? C.participantTracks.map((S) => v.ParticipantTracks.fromJSON(S)) : []
      };
    },
    toJSON(C) {
      const S = {};
      return C.room !== void 0 && (S.room = C.room), C.identity !== void 0 && (S.identity = C.identity), C.trackSids ? S.trackSids = C.trackSids.map((E) => E) : S.trackSids = [], C.subscribe !== void 0 && (S.subscribe = C.subscribe), C.participantTracks ? S.participantTracks = C.participantTracks.map((E) => E ? v.ParticipantTracks.toJSON(E) : void 0) : S.participantTracks = [], S;
    },
    fromPartial(C) {
      var S, E, I, M, $;
      const U = Z();
      return U.room = (S = C.room) !== null && S !== void 0 ? S : "", U.identity = (E = C.identity) !== null && E !== void 0 ? E : "", U.trackSids = ((I = C.trackSids) === null || I === void 0 ? void 0 : I.map((Y) => Y)) || [], U.subscribe = (M = C.subscribe) !== null && M !== void 0 ? M : !1, U.participantTracks = (($ = C.participantTracks) === null || $ === void 0 ? void 0 : $.map((Y) => v.ParticipantTracks.fromPartial(Y))) || [], U;
    }
  };
  function de() {
    return {};
  }
  a.UpdateSubscriptionsResponse = {
    encode(C, S = c.default.Writer.create()) {
      return S;
    },
    decode(C, S) {
      const E = C instanceof c.default.Reader ? C : new c.default.Reader(C);
      let I = S === void 0 ? E.len : E.pos + S;
      const M = de();
      for (; E.pos < I; ) {
        const $ = E.uint32();
        switch ($ >>> 3) {
          default:
            E.skipType($ & 7);
            break;
        }
      }
      return M;
    },
    fromJSON(C) {
      return {};
    },
    toJSON(C) {
      return {};
    },
    fromPartial(C) {
      return de();
    }
  };
  function fe() {
    return { room: "", data: new Uint8Array(), kind: 0, destinationSids: [] };
  }
  a.SendDataRequest = {
    encode(C, S = c.default.Writer.create()) {
      if (C.room !== void 0 && C.room !== "" && S.uint32(10).string(C.room), C.data !== void 0 && C.data.length !== 0 && S.uint32(18).bytes(C.data), C.kind !== void 0 && C.kind !== 0 && S.uint32(24).int32(C.kind), C.destinationSids !== void 0 && C.destinationSids.length !== 0)
        for (const E of C.destinationSids)
          S.uint32(34).string(E);
      return S;
    },
    decode(C, S) {
      const E = C instanceof c.default.Reader ? C : new c.default.Reader(C);
      let I = S === void 0 ? E.len : E.pos + S;
      const M = fe();
      for (; E.pos < I; ) {
        const $ = E.uint32();
        switch ($ >>> 3) {
          case 1:
            M.room = E.string();
            break;
          case 2:
            M.data = E.bytes();
            break;
          case 3:
            M.kind = E.int32();
            break;
          case 4:
            M.destinationSids.push(E.string());
            break;
          default:
            E.skipType($ & 7);
            break;
        }
      }
      return M;
    },
    fromJSON(C) {
      return {
        room: J(C.room) ? String(C.room) : "",
        data: J(C.data) ? be(C.data) : new Uint8Array(),
        kind: J(C.kind) ? v.dataPacket_KindFromJSON(C.kind) : 0,
        destinationSids: Array.isArray(C == null ? void 0 : C.destinationSids) ? C.destinationSids.map((S) => String(S)) : []
      };
    },
    toJSON(C) {
      const S = {};
      return C.room !== void 0 && (S.room = C.room), C.data !== void 0 && (S.data = q(C.data !== void 0 ? C.data : new Uint8Array())), C.kind !== void 0 && (S.kind = v.dataPacket_KindToJSON(C.kind)), C.destinationSids ? S.destinationSids = C.destinationSids.map((E) => E) : S.destinationSids = [], S;
    },
    fromPartial(C) {
      var S, E, I, M;
      const $ = fe();
      return $.room = (S = C.room) !== null && S !== void 0 ? S : "", $.data = (E = C.data) !== null && E !== void 0 ? E : new Uint8Array(), $.kind = (I = C.kind) !== null && I !== void 0 ? I : 0, $.destinationSids = ((M = C.destinationSids) === null || M === void 0 ? void 0 : M.map((U) => U)) || [], $;
    }
  };
  function Te() {
    return {};
  }
  a.SendDataResponse = {
    encode(C, S = c.default.Writer.create()) {
      return S;
    },
    decode(C, S) {
      const E = C instanceof c.default.Reader ? C : new c.default.Reader(C);
      let I = S === void 0 ? E.len : E.pos + S;
      const M = Te();
      for (; E.pos < I; ) {
        const $ = E.uint32();
        switch ($ >>> 3) {
          default:
            E.skipType($ & 7);
            break;
        }
      }
      return M;
    },
    fromJSON(C) {
      return {};
    },
    toJSON(C) {
      return {};
    },
    fromPartial(C) {
      return Te();
    }
  };
  function Re() {
    return { room: "", metadata: "" };
  }
  a.UpdateRoomMetadataRequest = {
    encode(C, S = c.default.Writer.create()) {
      return C.room !== void 0 && C.room !== "" && S.uint32(10).string(C.room), C.metadata !== void 0 && C.metadata !== "" && S.uint32(18).string(C.metadata), S;
    },
    decode(C, S) {
      const E = C instanceof c.default.Reader ? C : new c.default.Reader(C);
      let I = S === void 0 ? E.len : E.pos + S;
      const M = Re();
      for (; E.pos < I; ) {
        const $ = E.uint32();
        switch ($ >>> 3) {
          case 1:
            M.room = E.string();
            break;
          case 2:
            M.metadata = E.string();
            break;
          default:
            E.skipType($ & 7);
            break;
        }
      }
      return M;
    },
    fromJSON(C) {
      return {
        room: J(C.room) ? String(C.room) : "",
        metadata: J(C.metadata) ? String(C.metadata) : ""
      };
    },
    toJSON(C) {
      const S = {};
      return C.room !== void 0 && (S.room = C.room), C.metadata !== void 0 && (S.metadata = C.metadata), S;
    },
    fromPartial(C) {
      var S, E;
      const I = Re();
      return I.room = (S = C.room) !== null && S !== void 0 ? S : "", I.metadata = (E = C.metadata) !== null && E !== void 0 ? E : "", I;
    }
  };
  var Le = (() => {
    if (typeof Le < "u")
      return Le;
    if (typeof self < "u")
      return self;
    if (typeof window < "u")
      return window;
    if (typeof commonjsGlobal$1 < "u")
      return commonjsGlobal$1;
    throw "Unable to locate global object";
  })();
  function be(C) {
    if (Le.Buffer)
      return Uint8Array.from(Le.Buffer.from(C, "base64"));
    {
      const S = Le.atob(C), E = new Uint8Array(S.length);
      for (let I = 0; I < S.length; ++I)
        E[I] = S.charCodeAt(I);
      return E;
    }
  }
  function q(C) {
    if (Le.Buffer)
      return Le.Buffer.from(C).toString("base64");
    {
      const S = [];
      return C.forEach((E) => {
        S.push(String.fromCharCode(E));
      }), Le.btoa(S.join(""));
    }
  }
  function J(C) {
    return C != null;
  }
})(livekit_room);
var __awaiter = commonjsGlobal$1 && commonjsGlobal$1.__awaiter || function(a, u, c, l) {
  function v(p) {
    return p instanceof c ? p : new c(function(_) {
      _(p);
    });
  }
  return new (c || (c = Promise))(function(p, _) {
    function k(F) {
      try {
        D(l.next(F));
      } catch (z) {
        _(z);
      }
    }
    function O(F) {
      try {
        D(l.throw(F));
      } catch (z) {
        _(z);
      }
    }
    function D(F) {
      F.done ? p(F.value) : v(F.value).then(k, O);
    }
    D((l = l.apply(a, u || [])).next());
  });
}, __importDefault$2 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(RoomServiceClient$1, "__esModule", { value: !0 });
RoomServiceClient$1.RoomServiceClient = void 0;
const livekit_models_1$1 = livekit_models, livekit_room_1 = livekit_room, ServiceBase_1 = __importDefault$2(ServiceBase$1), TwirpRPC_1 = TwirpRPC, svc = "RoomService";
class RoomServiceClient extends ServiceBase_1.default {
  /**
   *
   * @param host hostname including protocol. i.e. 'https://cluster.livekit.io'
   * @param apiKey API Key, can be set in env var LIVEKIT_API_KEY
   * @param secret API Secret, can be set in env var LIVEKIT_API_SECRET
   * @param jwt JWT Token, a pregenerated JWT token for authentication.
   * @param hostHeader A host header to send with the request.
   *
   */
  constructor(u, c, l, v, p) {
    super(c, l), this.jwt = v, this.rpc = new TwirpRPC_1.TwirpRpc(u, TwirpRPC_1.livekitPackage, void 0, p);
  }
  /**
   * Creates a new room. Explicit room creation is not required, since rooms will
   * be automatically created when the first participant joins. This method can be
   * used to customize room settings.
   * @param options
   */
  createRoom(u) {
    return __awaiter(this, void 0, void 0, function* () {
      const c = yield this.rpc.request(svc, "CreateRoom", livekit_room_1.CreateRoomRequest.toJSON(livekit_room_1.CreateRoomRequest.fromPartial(u)), this.authHeader({ roomCreate: !0 }));
      return livekit_models_1$1.Room.fromJSON(c);
    });
  }
  /**
   * List active rooms
   * @param names when undefined or empty, list all rooms.
   *              otherwise returns rooms with matching names
   * @returns
   */
  listRooms(u) {
    var c;
    return __awaiter(this, void 0, void 0, function* () {
      const l = yield this.rpc.request(svc, "ListRooms", livekit_room_1.ListRoomsRequest.toJSON({ names: u ?? [] }), this.authHeader({ roomList: !0 }));
      return (c = livekit_room_1.ListRoomsResponse.fromJSON(l).rooms) !== null && c !== void 0 ? c : [];
    });
  }
  deleteRoom(u) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.rpc.request(svc, "DeleteRoom", livekit_room_1.DeleteRoomRequest.toJSON({ room: u }), this.authHeader({ roomCreate: !0 }));
    });
  }
  /**
   * Update metadata of a room
   * @param room name of the room
   * @param metadata the new metadata for the room
   */
  updateRoomMetadata(u, c) {
    return __awaiter(this, void 0, void 0, function* () {
      const l = yield this.rpc.request(svc, "UpdateRoomMetadata", livekit_room_1.UpdateRoomMetadataRequest.toJSON({ room: u, metadata: c }), this.authHeader({ roomAdmin: !0, room: u }));
      return livekit_models_1$1.Room.fromJSON(l);
    });
  }
  /**
   * List participants in a room
   * @param room name of the room
   */
  listParticipants(u) {
    var c;
    return __awaiter(this, void 0, void 0, function* () {
      const l = yield this.rpc.request(svc, "ListParticipants", livekit_room_1.ListParticipantsRequest.toJSON({ room: u }), this.authHeader({ roomAdmin: !0, room: u }));
      return (c = livekit_room_1.ListParticipantsResponse.fromJSON(l).participants) !== null && c !== void 0 ? c : [];
    });
  }
  /**
   * Get information on a specific participant, including the tracks that participant
   * has published
   * @param room name of the room
   * @param identity identity of the participant to return
   */
  getParticipant(u, c) {
    return __awaiter(this, void 0, void 0, function* () {
      const l = yield this.rpc.request(svc, "GetParticipant", livekit_room_1.RoomParticipantIdentity.toJSON({ room: u, identity: c }), this.authHeader({ roomAdmin: !0, room: u }));
      return livekit_models_1$1.ParticipantInfo.fromJSON(l);
    });
  }
  /**
   * Removes a participant in the room. This will disconnect the participant
   * and will emit a Disconnected event for that participant.
   * Even after being removed, the participant can still re-join the room.
   * @param room
   * @param identity
   */
  removeParticipant(u, c) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.rpc.request(svc, "RemoveParticipant", livekit_room_1.RoomParticipantIdentity.toJSON({ room: u, identity: c }), this.authHeader({ roomAdmin: !0, room: u }));
    });
  }
  /**
   * Mutes a track that the participant has published.
   * @param room
   * @param identity
   * @param trackSid sid of the track to be muted
   * @param muted true to mute, false to unmute
   */
  mutePublishedTrack(u, c, l, v) {
    return __awaiter(this, void 0, void 0, function* () {
      const p = livekit_room_1.MuteRoomTrackRequest.toJSON({
        room: u,
        identity: c,
        trackSid: l,
        muted: v
      }), _ = yield this.rpc.request(svc, "MutePublishedTrack", p, this.authHeader({ roomAdmin: !0, room: u }));
      return livekit_room_1.MuteRoomTrackResponse.fromJSON(_).track;
    });
  }
  /**
   * Updates a participant's metadata or permissions
   * @param room
   * @param identity
   * @param metadata optional, metadata to update
   * @param permission optional, new permissions to assign to participant
   * @param name optional, new name for participant
   */
  updateParticipant(u, c, l, v, p) {
    return __awaiter(this, void 0, void 0, function* () {
      const _ = {
        room: u,
        identity: c,
        metadata: l || "",
        permission: v,
        name: p || ""
      }, k = yield this.rpc.request(svc, "UpdateParticipant", livekit_room_1.UpdateParticipantRequest.toJSON(_), this.authHeader({ roomAdmin: !0, room: u }));
      return livekit_models_1$1.ParticipantInfo.fromJSON(k);
    });
  }
  /**
   * Updates a participant's subscription to tracks
   * @param room
   * @param identity
   * @param trackSids
   * @param subscribe true to subscribe, false to unsubscribe
   */
  updateSubscriptions(u, c, l, v) {
    return __awaiter(this, void 0, void 0, function* () {
      const p = livekit_room_1.UpdateSubscriptionsRequest.toJSON({
        room: u,
        identity: c,
        trackSids: l,
        subscribe: v,
        participantTracks: []
      });
      yield this.rpc.request(svc, "UpdateSubscriptions", p, this.authHeader({ roomAdmin: !0, room: u }));
    });
  }
  /**
   * Sends data message to participants in the room
   * @param room
   * @param data opaque payload to send
   * @param kind delivery reliability
   * @param destinationSids optional. when empty, message is sent to everyone
   */
  sendData(u, c, l, v = []) {
    return __awaiter(this, void 0, void 0, function* () {
      const p = livekit_room_1.SendDataRequest.toJSON({
        room: u,
        data: c,
        kind: l,
        destinationSids: v
      });
      yield this.rpc.request(svc, "SendData", p, this.authHeader({ roomAdmin: !0, room: u }));
    });
  }
  authHeader(u) {
    return this.jwt ? { Authorization: `Bearer ${this.jwt}` } : super.authHeader(u);
  }
}
RoomServiceClient$1.RoomServiceClient = RoomServiceClient;
var WebhookReceiver$1 = {}, livekit_webhook = {}, __importDefault$1 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(livekit_webhook, "__esModule", { value: !0 });
livekit_webhook.WebhookEvent = livekit_webhook.protobufPackage = void 0;
const long_1 = __importDefault$1(umdExports), minimal_1 = __importDefault$1(minimal), livekit_egress_1 = livekit_egress, livekit_ingress_1 = livekit_ingress, livekit_models_1 = livekit_models;
livekit_webhook.protobufPackage = "livekit";
function createBaseWebhookEvent() {
  return {
    event: "",
    room: void 0,
    participant: void 0,
    egressInfo: void 0,
    ingressInfo: void 0,
    track: void 0,
    id: "",
    createdAt: 0
  };
}
livekit_webhook.WebhookEvent = {
  encode(a, u = minimal_1.default.Writer.create()) {
    return a.event !== void 0 && a.event !== "" && u.uint32(10).string(a.event), a.room !== void 0 && livekit_models_1.Room.encode(a.room, u.uint32(18).fork()).ldelim(), a.participant !== void 0 && livekit_models_1.ParticipantInfo.encode(a.participant, u.uint32(26).fork()).ldelim(), a.egressInfo !== void 0 && livekit_egress_1.EgressInfo.encode(a.egressInfo, u.uint32(74).fork()).ldelim(), a.ingressInfo !== void 0 && livekit_ingress_1.IngressInfo.encode(a.ingressInfo, u.uint32(82).fork()).ldelim(), a.track !== void 0 && livekit_models_1.TrackInfo.encode(a.track, u.uint32(66).fork()).ldelim(), a.id !== void 0 && a.id !== "" && u.uint32(50).string(a.id), a.createdAt !== void 0 && a.createdAt !== 0 && u.uint32(56).int64(a.createdAt), u;
  },
  decode(a, u) {
    const c = a instanceof minimal_1.default.Reader ? a : new minimal_1.default.Reader(a);
    let l = u === void 0 ? c.len : c.pos + u;
    const v = createBaseWebhookEvent();
    for (; c.pos < l; ) {
      const p = c.uint32();
      switch (p >>> 3) {
        case 1:
          v.event = c.string();
          break;
        case 2:
          v.room = livekit_models_1.Room.decode(c, c.uint32());
          break;
        case 3:
          v.participant = livekit_models_1.ParticipantInfo.decode(c, c.uint32());
          break;
        case 9:
          v.egressInfo = livekit_egress_1.EgressInfo.decode(c, c.uint32());
          break;
        case 10:
          v.ingressInfo = livekit_ingress_1.IngressInfo.decode(c, c.uint32());
          break;
        case 8:
          v.track = livekit_models_1.TrackInfo.decode(c, c.uint32());
          break;
        case 6:
          v.id = c.string();
          break;
        case 7:
          v.createdAt = longToNumber(c.int64());
          break;
        default:
          c.skipType(p & 7);
          break;
      }
    }
    return v;
  },
  fromJSON(a) {
    return {
      event: isSet(a.event) ? String(a.event) : "",
      room: isSet(a.room) ? livekit_models_1.Room.fromJSON(a.room) : void 0,
      participant: isSet(a.participant) ? livekit_models_1.ParticipantInfo.fromJSON(a.participant) : void 0,
      egressInfo: isSet(a.egressInfo) ? livekit_egress_1.EgressInfo.fromJSON(a.egressInfo) : void 0,
      ingressInfo: isSet(a.ingressInfo) ? livekit_ingress_1.IngressInfo.fromJSON(a.ingressInfo) : void 0,
      track: isSet(a.track) ? livekit_models_1.TrackInfo.fromJSON(a.track) : void 0,
      id: isSet(a.id) ? String(a.id) : "",
      createdAt: isSet(a.createdAt) ? Number(a.createdAt) : 0
    };
  },
  toJSON(a) {
    const u = {};
    return a.event !== void 0 && (u.event = a.event), a.room !== void 0 && (u.room = a.room ? livekit_models_1.Room.toJSON(a.room) : void 0), a.participant !== void 0 && (u.participant = a.participant ? livekit_models_1.ParticipantInfo.toJSON(a.participant) : void 0), a.egressInfo !== void 0 && (u.egressInfo = a.egressInfo ? livekit_egress_1.EgressInfo.toJSON(a.egressInfo) : void 0), a.ingressInfo !== void 0 && (u.ingressInfo = a.ingressInfo ? livekit_ingress_1.IngressInfo.toJSON(a.ingressInfo) : void 0), a.track !== void 0 && (u.track = a.track ? livekit_models_1.TrackInfo.toJSON(a.track) : void 0), a.id !== void 0 && (u.id = a.id), a.createdAt !== void 0 && (u.createdAt = Math.round(a.createdAt)), u;
  },
  fromPartial(a) {
    var u, c, l;
    const v = createBaseWebhookEvent();
    return v.event = (u = a.event) !== null && u !== void 0 ? u : "", v.room = a.room !== void 0 && a.room !== null ? livekit_models_1.Room.fromPartial(a.room) : void 0, v.participant = a.participant !== void 0 && a.participant !== null ? livekit_models_1.ParticipantInfo.fromPartial(a.participant) : void 0, v.egressInfo = a.egressInfo !== void 0 && a.egressInfo !== null ? livekit_egress_1.EgressInfo.fromPartial(a.egressInfo) : void 0, v.ingressInfo = a.ingressInfo !== void 0 && a.ingressInfo !== null ? livekit_ingress_1.IngressInfo.fromPartial(a.ingressInfo) : void 0, v.track = a.track !== void 0 && a.track !== null ? livekit_models_1.TrackInfo.fromPartial(a.track) : void 0, v.id = (c = a.id) !== null && c !== void 0 ? c : "", v.createdAt = (l = a.createdAt) !== null && l !== void 0 ? l : 0, v;
  }
};
var globalThis$1 = (() => {
  if (typeof globalThis$1 < "u")
    return globalThis$1;
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof commonjsGlobal$1 < "u")
    return commonjsGlobal$1;
  throw "Unable to locate global object";
})();
function longToNumber(a) {
  if (a.gt(Number.MAX_SAFE_INTEGER))
    throw new globalThis$1.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  return a.toNumber();
}
minimal_1.default.util.Long !== long_1.default && (minimal_1.default.util.Long = long_1.default, minimal_1.default.configure());
function isSet(a) {
  return a != null;
}
var __importDefault = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(WebhookReceiver$1, "__esModule", { value: !0 });
WebhookReceiver$1.WebhookReceiver = WebhookReceiver$1.authorizeHeader = void 0;
const crypto_1 = __importDefault(requireCryptoBrowserify()), AccessToken_1 = AccessToken$1, livekit_webhook_1 = livekit_webhook;
WebhookReceiver$1.authorizeHeader = "Authorize";
class WebhookReceiver {
  constructor(u, c) {
    this.verifier = new AccessToken_1.TokenVerifier(u, c);
  }
  /**
   *
   * @param body string of the posted body
   * @param authHeader `Authorization` header from the request
   * @param skipAuth true to skip auth validation
   * @returns
   */
  receive(u, c, l = !1) {
    if (!l) {
      if (!c)
        throw new Error("authorization header is empty");
      const v = this.verifier.verify(c), p = crypto_1.default.createHash("sha256");
      if (p.update(u), v.sha256 !== p.digest("base64"))
        throw new Error("sha256 checksum of body does not match");
    }
    return livekit_webhook_1.WebhookEvent.fromJSON(JSON.parse(u));
  }
}
WebhookReceiver$1.WebhookReceiver = WebhookReceiver;
var livekit_internal = {}, livekit_rtc = {};
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(A) {
    return A && A.__esModule ? A : { default: A };
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.SimulateScenario = a.DataChannelInfo = a.SyncState = a.SubscriptionPermissionUpdate = a.SubscriptionPermission = a.TrackPermission = a.SubscribedQualityUpdate = a.SubscribedCodec = a.SubscribedQuality = a.StreamStateUpdate = a.StreamStateInfo = a.ConnectionQualityUpdate = a.ConnectionQualityInfo = a.RoomUpdate = a.SpeakersChanged = a.ICEServer = a.UpdateVideoLayers = a.LeaveRequest = a.UpdateTrackSettings = a.UpdateSubscription = a.ParticipantUpdate = a.SessionDescription = a.TrackUnpublishedResponse = a.TrackPublishedResponse = a.JoinResponse = a.MuteTrackRequest = a.TrickleRequest = a.AddTrackRequest = a.SimulcastCodec = a.SignalResponse = a.SignalRequest = a.candidateProtocolToJSON = a.candidateProtocolFromJSON = a.CandidateProtocol = a.streamStateToJSON = a.streamStateFromJSON = a.StreamState = a.signalTargetToJSON = a.signalTargetFromJSON = a.SignalTarget = a.protobufPackage = void 0;
  const c = u(umdExports), l = u(minimal), v = livekit_models;
  a.protobufPackage = "livekit";
  var p;
  (function(A) {
    A[A.PUBLISHER = 0] = "PUBLISHER", A[A.SUBSCRIBER = 1] = "SUBSCRIBER", A[A.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(p = a.SignalTarget || (a.SignalTarget = {}));
  function _(A) {
    switch (A) {
      case 0:
      case "PUBLISHER":
        return p.PUBLISHER;
      case 1:
      case "SUBSCRIBER":
        return p.SUBSCRIBER;
      case -1:
      case "UNRECOGNIZED":
      default:
        return p.UNRECOGNIZED;
    }
  }
  a.signalTargetFromJSON = _;
  function k(A) {
    switch (A) {
      case p.PUBLISHER:
        return "PUBLISHER";
      case p.SUBSCRIBER:
        return "SUBSCRIBER";
      case p.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.signalTargetToJSON = k;
  var O;
  (function(A) {
    A[A.ACTIVE = 0] = "ACTIVE", A[A.PAUSED = 1] = "PAUSED", A[A.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(O = a.StreamState || (a.StreamState = {}));
  function D(A) {
    switch (A) {
      case 0:
      case "ACTIVE":
        return O.ACTIVE;
      case 1:
      case "PAUSED":
        return O.PAUSED;
      case -1:
      case "UNRECOGNIZED":
      default:
        return O.UNRECOGNIZED;
    }
  }
  a.streamStateFromJSON = D;
  function F(A) {
    switch (A) {
      case O.ACTIVE:
        return "ACTIVE";
      case O.PAUSED:
        return "PAUSED";
      case O.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.streamStateToJSON = F;
  var z;
  (function(A) {
    A[A.UDP = 0] = "UDP", A[A.TCP = 1] = "TCP", A[A.TLS = 2] = "TLS", A[A.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(z = a.CandidateProtocol || (a.CandidateProtocol = {}));
  function j(A) {
    switch (A) {
      case 0:
      case "UDP":
        return z.UDP;
      case 1:
      case "TCP":
        return z.TCP;
      case 2:
      case "TLS":
        return z.TLS;
      case -1:
      case "UNRECOGNIZED":
      default:
        return z.UNRECOGNIZED;
    }
  }
  a.candidateProtocolFromJSON = j;
  function ee(A) {
    switch (A) {
      case z.UDP:
        return "UDP";
      case z.TCP:
        return "TCP";
      case z.TLS:
        return "TLS";
      case z.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.candidateProtocolToJSON = ee;
  function X() {
    return {
      offer: void 0,
      answer: void 0,
      trickle: void 0,
      addTrack: void 0,
      mute: void 0,
      subscription: void 0,
      trackSetting: void 0,
      leave: void 0,
      updateLayers: void 0,
      subscriptionPermission: void 0,
      syncState: void 0,
      simulate: void 0,
      ping: void 0
    };
  }
  a.SignalRequest = {
    encode(A, re = l.default.Writer.create()) {
      return A.offer !== void 0 && a.SessionDescription.encode(A.offer, re.uint32(10).fork()).ldelim(), A.answer !== void 0 && a.SessionDescription.encode(A.answer, re.uint32(18).fork()).ldelim(), A.trickle !== void 0 && a.TrickleRequest.encode(A.trickle, re.uint32(26).fork()).ldelim(), A.addTrack !== void 0 && a.AddTrackRequest.encode(A.addTrack, re.uint32(34).fork()).ldelim(), A.mute !== void 0 && a.MuteTrackRequest.encode(A.mute, re.uint32(42).fork()).ldelim(), A.subscription !== void 0 && a.UpdateSubscription.encode(A.subscription, re.uint32(50).fork()).ldelim(), A.trackSetting !== void 0 && a.UpdateTrackSettings.encode(A.trackSetting, re.uint32(58).fork()).ldelim(), A.leave !== void 0 && a.LeaveRequest.encode(A.leave, re.uint32(66).fork()).ldelim(), A.updateLayers !== void 0 && a.UpdateVideoLayers.encode(A.updateLayers, re.uint32(82).fork()).ldelim(), A.subscriptionPermission !== void 0 && a.SubscriptionPermission.encode(A.subscriptionPermission, re.uint32(90).fork()).ldelim(), A.syncState !== void 0 && a.SyncState.encode(A.syncState, re.uint32(98).fork()).ldelim(), A.simulate !== void 0 && a.SimulateScenario.encode(A.simulate, re.uint32(106).fork()).ldelim(), A.ping !== void 0 && re.uint32(112).int64(A.ping), re;
    },
    decode(A, re) {
      const le = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let Ne = re === void 0 ? le.len : le.pos + re;
      const Pe = X();
      for (; le.pos < Ne; ) {
        const Fe = le.uint32();
        switch (Fe >>> 3) {
          case 1:
            Pe.offer = a.SessionDescription.decode(le, le.uint32());
            break;
          case 2:
            Pe.answer = a.SessionDescription.decode(le, le.uint32());
            break;
          case 3:
            Pe.trickle = a.TrickleRequest.decode(le, le.uint32());
            break;
          case 4:
            Pe.addTrack = a.AddTrackRequest.decode(le, le.uint32());
            break;
          case 5:
            Pe.mute = a.MuteTrackRequest.decode(le, le.uint32());
            break;
          case 6:
            Pe.subscription = a.UpdateSubscription.decode(le, le.uint32());
            break;
          case 7:
            Pe.trackSetting = a.UpdateTrackSettings.decode(le, le.uint32());
            break;
          case 8:
            Pe.leave = a.LeaveRequest.decode(le, le.uint32());
            break;
          case 10:
            Pe.updateLayers = a.UpdateVideoLayers.decode(le, le.uint32());
            break;
          case 11:
            Pe.subscriptionPermission = a.SubscriptionPermission.decode(le, le.uint32());
            break;
          case 12:
            Pe.syncState = a.SyncState.decode(le, le.uint32());
            break;
          case 13:
            Pe.simulate = a.SimulateScenario.decode(le, le.uint32());
            break;
          case 14:
            Pe.ping = Ue(le.int64());
            break;
          default:
            le.skipType(Fe & 7);
            break;
        }
      }
      return Pe;
    },
    fromJSON(A) {
      return {
        offer: oe(A.offer) ? a.SessionDescription.fromJSON(A.offer) : void 0,
        answer: oe(A.answer) ? a.SessionDescription.fromJSON(A.answer) : void 0,
        trickle: oe(A.trickle) ? a.TrickleRequest.fromJSON(A.trickle) : void 0,
        addTrack: oe(A.addTrack) ? a.AddTrackRequest.fromJSON(A.addTrack) : void 0,
        mute: oe(A.mute) ? a.MuteTrackRequest.fromJSON(A.mute) : void 0,
        subscription: oe(A.subscription) ? a.UpdateSubscription.fromJSON(A.subscription) : void 0,
        trackSetting: oe(A.trackSetting) ? a.UpdateTrackSettings.fromJSON(A.trackSetting) : void 0,
        leave: oe(A.leave) ? a.LeaveRequest.fromJSON(A.leave) : void 0,
        updateLayers: oe(A.updateLayers) ? a.UpdateVideoLayers.fromJSON(A.updateLayers) : void 0,
        subscriptionPermission: oe(A.subscriptionPermission) ? a.SubscriptionPermission.fromJSON(A.subscriptionPermission) : void 0,
        syncState: oe(A.syncState) ? a.SyncState.fromJSON(A.syncState) : void 0,
        simulate: oe(A.simulate) ? a.SimulateScenario.fromJSON(A.simulate) : void 0,
        ping: oe(A.ping) ? Number(A.ping) : void 0
      };
    },
    toJSON(A) {
      const re = {};
      return A.offer !== void 0 && (re.offer = A.offer ? a.SessionDescription.toJSON(A.offer) : void 0), A.answer !== void 0 && (re.answer = A.answer ? a.SessionDescription.toJSON(A.answer) : void 0), A.trickle !== void 0 && (re.trickle = A.trickle ? a.TrickleRequest.toJSON(A.trickle) : void 0), A.addTrack !== void 0 && (re.addTrack = A.addTrack ? a.AddTrackRequest.toJSON(A.addTrack) : void 0), A.mute !== void 0 && (re.mute = A.mute ? a.MuteTrackRequest.toJSON(A.mute) : void 0), A.subscription !== void 0 && (re.subscription = A.subscription ? a.UpdateSubscription.toJSON(A.subscription) : void 0), A.trackSetting !== void 0 && (re.trackSetting = A.trackSetting ? a.UpdateTrackSettings.toJSON(A.trackSetting) : void 0), A.leave !== void 0 && (re.leave = A.leave ? a.LeaveRequest.toJSON(A.leave) : void 0), A.updateLayers !== void 0 && (re.updateLayers = A.updateLayers ? a.UpdateVideoLayers.toJSON(A.updateLayers) : void 0), A.subscriptionPermission !== void 0 && (re.subscriptionPermission = A.subscriptionPermission ? a.SubscriptionPermission.toJSON(A.subscriptionPermission) : void 0), A.syncState !== void 0 && (re.syncState = A.syncState ? a.SyncState.toJSON(A.syncState) : void 0), A.simulate !== void 0 && (re.simulate = A.simulate ? a.SimulateScenario.toJSON(A.simulate) : void 0), A.ping !== void 0 && (re.ping = Math.round(A.ping)), re;
    },
    fromPartial(A) {
      var re;
      const le = X();
      return le.offer = A.offer !== void 0 && A.offer !== null ? a.SessionDescription.fromPartial(A.offer) : void 0, le.answer = A.answer !== void 0 && A.answer !== null ? a.SessionDescription.fromPartial(A.answer) : void 0, le.trickle = A.trickle !== void 0 && A.trickle !== null ? a.TrickleRequest.fromPartial(A.trickle) : void 0, le.addTrack = A.addTrack !== void 0 && A.addTrack !== null ? a.AddTrackRequest.fromPartial(A.addTrack) : void 0, le.mute = A.mute !== void 0 && A.mute !== null ? a.MuteTrackRequest.fromPartial(A.mute) : void 0, le.subscription = A.subscription !== void 0 && A.subscription !== null ? a.UpdateSubscription.fromPartial(A.subscription) : void 0, le.trackSetting = A.trackSetting !== void 0 && A.trackSetting !== null ? a.UpdateTrackSettings.fromPartial(A.trackSetting) : void 0, le.leave = A.leave !== void 0 && A.leave !== null ? a.LeaveRequest.fromPartial(A.leave) : void 0, le.updateLayers = A.updateLayers !== void 0 && A.updateLayers !== null ? a.UpdateVideoLayers.fromPartial(A.updateLayers) : void 0, le.subscriptionPermission = A.subscriptionPermission !== void 0 && A.subscriptionPermission !== null ? a.SubscriptionPermission.fromPartial(A.subscriptionPermission) : void 0, le.syncState = A.syncState !== void 0 && A.syncState !== null ? a.SyncState.fromPartial(A.syncState) : void 0, le.simulate = A.simulate !== void 0 && A.simulate !== null ? a.SimulateScenario.fromPartial(A.simulate) : void 0, le.ping = (re = A.ping) !== null && re !== void 0 ? re : void 0, le;
    }
  };
  function ae() {
    return {
      join: void 0,
      answer: void 0,
      offer: void 0,
      trickle: void 0,
      update: void 0,
      trackPublished: void 0,
      leave: void 0,
      mute: void 0,
      speakersChanged: void 0,
      roomUpdate: void 0,
      connectionQuality: void 0,
      streamStateUpdate: void 0,
      subscribedQualityUpdate: void 0,
      subscriptionPermissionUpdate: void 0,
      refreshToken: void 0,
      trackUnpublished: void 0,
      pong: void 0
    };
  }
  a.SignalResponse = {
    encode(A, re = l.default.Writer.create()) {
      return A.join !== void 0 && a.JoinResponse.encode(A.join, re.uint32(10).fork()).ldelim(), A.answer !== void 0 && a.SessionDescription.encode(A.answer, re.uint32(18).fork()).ldelim(), A.offer !== void 0 && a.SessionDescription.encode(A.offer, re.uint32(26).fork()).ldelim(), A.trickle !== void 0 && a.TrickleRequest.encode(A.trickle, re.uint32(34).fork()).ldelim(), A.update !== void 0 && a.ParticipantUpdate.encode(A.update, re.uint32(42).fork()).ldelim(), A.trackPublished !== void 0 && a.TrackPublishedResponse.encode(A.trackPublished, re.uint32(50).fork()).ldelim(), A.leave !== void 0 && a.LeaveRequest.encode(A.leave, re.uint32(66).fork()).ldelim(), A.mute !== void 0 && a.MuteTrackRequest.encode(A.mute, re.uint32(74).fork()).ldelim(), A.speakersChanged !== void 0 && a.SpeakersChanged.encode(A.speakersChanged, re.uint32(82).fork()).ldelim(), A.roomUpdate !== void 0 && a.RoomUpdate.encode(A.roomUpdate, re.uint32(90).fork()).ldelim(), A.connectionQuality !== void 0 && a.ConnectionQualityUpdate.encode(A.connectionQuality, re.uint32(98).fork()).ldelim(), A.streamStateUpdate !== void 0 && a.StreamStateUpdate.encode(A.streamStateUpdate, re.uint32(106).fork()).ldelim(), A.subscribedQualityUpdate !== void 0 && a.SubscribedQualityUpdate.encode(A.subscribedQualityUpdate, re.uint32(114).fork()).ldelim(), A.subscriptionPermissionUpdate !== void 0 && a.SubscriptionPermissionUpdate.encode(A.subscriptionPermissionUpdate, re.uint32(122).fork()).ldelim(), A.refreshToken !== void 0 && re.uint32(130).string(A.refreshToken), A.trackUnpublished !== void 0 && a.TrackUnpublishedResponse.encode(A.trackUnpublished, re.uint32(138).fork()).ldelim(), A.pong !== void 0 && re.uint32(144).int64(A.pong), re;
    },
    decode(A, re) {
      const le = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let Ne = re === void 0 ? le.len : le.pos + re;
      const Pe = ae();
      for (; le.pos < Ne; ) {
        const Fe = le.uint32();
        switch (Fe >>> 3) {
          case 1:
            Pe.join = a.JoinResponse.decode(le, le.uint32());
            break;
          case 2:
            Pe.answer = a.SessionDescription.decode(le, le.uint32());
            break;
          case 3:
            Pe.offer = a.SessionDescription.decode(le, le.uint32());
            break;
          case 4:
            Pe.trickle = a.TrickleRequest.decode(le, le.uint32());
            break;
          case 5:
            Pe.update = a.ParticipantUpdate.decode(le, le.uint32());
            break;
          case 6:
            Pe.trackPublished = a.TrackPublishedResponse.decode(le, le.uint32());
            break;
          case 8:
            Pe.leave = a.LeaveRequest.decode(le, le.uint32());
            break;
          case 9:
            Pe.mute = a.MuteTrackRequest.decode(le, le.uint32());
            break;
          case 10:
            Pe.speakersChanged = a.SpeakersChanged.decode(le, le.uint32());
            break;
          case 11:
            Pe.roomUpdate = a.RoomUpdate.decode(le, le.uint32());
            break;
          case 12:
            Pe.connectionQuality = a.ConnectionQualityUpdate.decode(le, le.uint32());
            break;
          case 13:
            Pe.streamStateUpdate = a.StreamStateUpdate.decode(le, le.uint32());
            break;
          case 14:
            Pe.subscribedQualityUpdate = a.SubscribedQualityUpdate.decode(le, le.uint32());
            break;
          case 15:
            Pe.subscriptionPermissionUpdate = a.SubscriptionPermissionUpdate.decode(le, le.uint32());
            break;
          case 16:
            Pe.refreshToken = le.string();
            break;
          case 17:
            Pe.trackUnpublished = a.TrackUnpublishedResponse.decode(le, le.uint32());
            break;
          case 18:
            Pe.pong = Ue(le.int64());
            break;
          default:
            le.skipType(Fe & 7);
            break;
        }
      }
      return Pe;
    },
    fromJSON(A) {
      return {
        join: oe(A.join) ? a.JoinResponse.fromJSON(A.join) : void 0,
        answer: oe(A.answer) ? a.SessionDescription.fromJSON(A.answer) : void 0,
        offer: oe(A.offer) ? a.SessionDescription.fromJSON(A.offer) : void 0,
        trickle: oe(A.trickle) ? a.TrickleRequest.fromJSON(A.trickle) : void 0,
        update: oe(A.update) ? a.ParticipantUpdate.fromJSON(A.update) : void 0,
        trackPublished: oe(A.trackPublished) ? a.TrackPublishedResponse.fromJSON(A.trackPublished) : void 0,
        leave: oe(A.leave) ? a.LeaveRequest.fromJSON(A.leave) : void 0,
        mute: oe(A.mute) ? a.MuteTrackRequest.fromJSON(A.mute) : void 0,
        speakersChanged: oe(A.speakersChanged) ? a.SpeakersChanged.fromJSON(A.speakersChanged) : void 0,
        roomUpdate: oe(A.roomUpdate) ? a.RoomUpdate.fromJSON(A.roomUpdate) : void 0,
        connectionQuality: oe(A.connectionQuality) ? a.ConnectionQualityUpdate.fromJSON(A.connectionQuality) : void 0,
        streamStateUpdate: oe(A.streamStateUpdate) ? a.StreamStateUpdate.fromJSON(A.streamStateUpdate) : void 0,
        subscribedQualityUpdate: oe(A.subscribedQualityUpdate) ? a.SubscribedQualityUpdate.fromJSON(A.subscribedQualityUpdate) : void 0,
        subscriptionPermissionUpdate: oe(A.subscriptionPermissionUpdate) ? a.SubscriptionPermissionUpdate.fromJSON(A.subscriptionPermissionUpdate) : void 0,
        refreshToken: oe(A.refreshToken) ? String(A.refreshToken) : void 0,
        trackUnpublished: oe(A.trackUnpublished) ? a.TrackUnpublishedResponse.fromJSON(A.trackUnpublished) : void 0,
        pong: oe(A.pong) ? Number(A.pong) : void 0
      };
    },
    toJSON(A) {
      const re = {};
      return A.join !== void 0 && (re.join = A.join ? a.JoinResponse.toJSON(A.join) : void 0), A.answer !== void 0 && (re.answer = A.answer ? a.SessionDescription.toJSON(A.answer) : void 0), A.offer !== void 0 && (re.offer = A.offer ? a.SessionDescription.toJSON(A.offer) : void 0), A.trickle !== void 0 && (re.trickle = A.trickle ? a.TrickleRequest.toJSON(A.trickle) : void 0), A.update !== void 0 && (re.update = A.update ? a.ParticipantUpdate.toJSON(A.update) : void 0), A.trackPublished !== void 0 && (re.trackPublished = A.trackPublished ? a.TrackPublishedResponse.toJSON(A.trackPublished) : void 0), A.leave !== void 0 && (re.leave = A.leave ? a.LeaveRequest.toJSON(A.leave) : void 0), A.mute !== void 0 && (re.mute = A.mute ? a.MuteTrackRequest.toJSON(A.mute) : void 0), A.speakersChanged !== void 0 && (re.speakersChanged = A.speakersChanged ? a.SpeakersChanged.toJSON(A.speakersChanged) : void 0), A.roomUpdate !== void 0 && (re.roomUpdate = A.roomUpdate ? a.RoomUpdate.toJSON(A.roomUpdate) : void 0), A.connectionQuality !== void 0 && (re.connectionQuality = A.connectionQuality ? a.ConnectionQualityUpdate.toJSON(A.connectionQuality) : void 0), A.streamStateUpdate !== void 0 && (re.streamStateUpdate = A.streamStateUpdate ? a.StreamStateUpdate.toJSON(A.streamStateUpdate) : void 0), A.subscribedQualityUpdate !== void 0 && (re.subscribedQualityUpdate = A.subscribedQualityUpdate ? a.SubscribedQualityUpdate.toJSON(A.subscribedQualityUpdate) : void 0), A.subscriptionPermissionUpdate !== void 0 && (re.subscriptionPermissionUpdate = A.subscriptionPermissionUpdate ? a.SubscriptionPermissionUpdate.toJSON(A.subscriptionPermissionUpdate) : void 0), A.refreshToken !== void 0 && (re.refreshToken = A.refreshToken), A.trackUnpublished !== void 0 && (re.trackUnpublished = A.trackUnpublished ? a.TrackUnpublishedResponse.toJSON(A.trackUnpublished) : void 0), A.pong !== void 0 && (re.pong = Math.round(A.pong)), re;
    },
    fromPartial(A) {
      var re, le;
      const Ne = ae();
      return Ne.join = A.join !== void 0 && A.join !== null ? a.JoinResponse.fromPartial(A.join) : void 0, Ne.answer = A.answer !== void 0 && A.answer !== null ? a.SessionDescription.fromPartial(A.answer) : void 0, Ne.offer = A.offer !== void 0 && A.offer !== null ? a.SessionDescription.fromPartial(A.offer) : void 0, Ne.trickle = A.trickle !== void 0 && A.trickle !== null ? a.TrickleRequest.fromPartial(A.trickle) : void 0, Ne.update = A.update !== void 0 && A.update !== null ? a.ParticipantUpdate.fromPartial(A.update) : void 0, Ne.trackPublished = A.trackPublished !== void 0 && A.trackPublished !== null ? a.TrackPublishedResponse.fromPartial(A.trackPublished) : void 0, Ne.leave = A.leave !== void 0 && A.leave !== null ? a.LeaveRequest.fromPartial(A.leave) : void 0, Ne.mute = A.mute !== void 0 && A.mute !== null ? a.MuteTrackRequest.fromPartial(A.mute) : void 0, Ne.speakersChanged = A.speakersChanged !== void 0 && A.speakersChanged !== null ? a.SpeakersChanged.fromPartial(A.speakersChanged) : void 0, Ne.roomUpdate = A.roomUpdate !== void 0 && A.roomUpdate !== null ? a.RoomUpdate.fromPartial(A.roomUpdate) : void 0, Ne.connectionQuality = A.connectionQuality !== void 0 && A.connectionQuality !== null ? a.ConnectionQualityUpdate.fromPartial(A.connectionQuality) : void 0, Ne.streamStateUpdate = A.streamStateUpdate !== void 0 && A.streamStateUpdate !== null ? a.StreamStateUpdate.fromPartial(A.streamStateUpdate) : void 0, Ne.subscribedQualityUpdate = A.subscribedQualityUpdate !== void 0 && A.subscribedQualityUpdate !== null ? a.SubscribedQualityUpdate.fromPartial(A.subscribedQualityUpdate) : void 0, Ne.subscriptionPermissionUpdate = A.subscriptionPermissionUpdate !== void 0 && A.subscriptionPermissionUpdate !== null ? a.SubscriptionPermissionUpdate.fromPartial(A.subscriptionPermissionUpdate) : void 0, Ne.refreshToken = (re = A.refreshToken) !== null && re !== void 0 ? re : void 0, Ne.trackUnpublished = A.trackUnpublished !== void 0 && A.trackUnpublished !== null ? a.TrackUnpublishedResponse.fromPartial(A.trackUnpublished) : void 0, Ne.pong = (le = A.pong) !== null && le !== void 0 ? le : void 0, Ne;
    }
  };
  function Q() {
    return { codec: "", cid: "", enableSimulcastLayers: !1 };
  }
  a.SimulcastCodec = {
    encode(A, re = l.default.Writer.create()) {
      return A.codec !== void 0 && A.codec !== "" && re.uint32(10).string(A.codec), A.cid !== void 0 && A.cid !== "" && re.uint32(18).string(A.cid), A.enableSimulcastLayers === !0 && re.uint32(24).bool(A.enableSimulcastLayers), re;
    },
    decode(A, re) {
      const le = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let Ne = re === void 0 ? le.len : le.pos + re;
      const Pe = Q();
      for (; le.pos < Ne; ) {
        const Fe = le.uint32();
        switch (Fe >>> 3) {
          case 1:
            Pe.codec = le.string();
            break;
          case 2:
            Pe.cid = le.string();
            break;
          case 3:
            Pe.enableSimulcastLayers = le.bool();
            break;
          default:
            le.skipType(Fe & 7);
            break;
        }
      }
      return Pe;
    },
    fromJSON(A) {
      return {
        codec: oe(A.codec) ? String(A.codec) : "",
        cid: oe(A.cid) ? String(A.cid) : "",
        enableSimulcastLayers: oe(A.enableSimulcastLayers) ? !!A.enableSimulcastLayers : !1
      };
    },
    toJSON(A) {
      const re = {};
      return A.codec !== void 0 && (re.codec = A.codec), A.cid !== void 0 && (re.cid = A.cid), A.enableSimulcastLayers !== void 0 && (re.enableSimulcastLayers = A.enableSimulcastLayers), re;
    },
    fromPartial(A) {
      var re, le, Ne;
      const Pe = Q();
      return Pe.codec = (re = A.codec) !== null && re !== void 0 ? re : "", Pe.cid = (le = A.cid) !== null && le !== void 0 ? le : "", Pe.enableSimulcastLayers = (Ne = A.enableSimulcastLayers) !== null && Ne !== void 0 ? Ne : !1, Pe;
    }
  };
  function ne() {
    return {
      cid: "",
      name: "",
      type: 0,
      width: 0,
      height: 0,
      muted: !1,
      disableDtx: !1,
      source: 0,
      layers: [],
      simulcastCodecs: [],
      sid: "",
      stereo: !1,
      disableRed: !1
    };
  }
  a.AddTrackRequest = {
    encode(A, re = l.default.Writer.create()) {
      if (A.cid !== void 0 && A.cid !== "" && re.uint32(10).string(A.cid), A.name !== void 0 && A.name !== "" && re.uint32(18).string(A.name), A.type !== void 0 && A.type !== 0 && re.uint32(24).int32(A.type), A.width !== void 0 && A.width !== 0 && re.uint32(32).uint32(A.width), A.height !== void 0 && A.height !== 0 && re.uint32(40).uint32(A.height), A.muted === !0 && re.uint32(48).bool(A.muted), A.disableDtx === !0 && re.uint32(56).bool(A.disableDtx), A.source !== void 0 && A.source !== 0 && re.uint32(64).int32(A.source), A.layers !== void 0 && A.layers.length !== 0)
        for (const le of A.layers)
          v.VideoLayer.encode(le, re.uint32(74).fork()).ldelim();
      if (A.simulcastCodecs !== void 0 && A.simulcastCodecs.length !== 0)
        for (const le of A.simulcastCodecs)
          a.SimulcastCodec.encode(le, re.uint32(82).fork()).ldelim();
      return A.sid !== void 0 && A.sid !== "" && re.uint32(90).string(A.sid), A.stereo === !0 && re.uint32(96).bool(A.stereo), A.disableRed === !0 && re.uint32(104).bool(A.disableRed), re;
    },
    decode(A, re) {
      const le = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let Ne = re === void 0 ? le.len : le.pos + re;
      const Pe = ne();
      for (; le.pos < Ne; ) {
        const Fe = le.uint32();
        switch (Fe >>> 3) {
          case 1:
            Pe.cid = le.string();
            break;
          case 2:
            Pe.name = le.string();
            break;
          case 3:
            Pe.type = le.int32();
            break;
          case 4:
            Pe.width = le.uint32();
            break;
          case 5:
            Pe.height = le.uint32();
            break;
          case 6:
            Pe.muted = le.bool();
            break;
          case 7:
            Pe.disableDtx = le.bool();
            break;
          case 8:
            Pe.source = le.int32();
            break;
          case 9:
            Pe.layers.push(v.VideoLayer.decode(le, le.uint32()));
            break;
          case 10:
            Pe.simulcastCodecs.push(a.SimulcastCodec.decode(le, le.uint32()));
            break;
          case 11:
            Pe.sid = le.string();
            break;
          case 12:
            Pe.stereo = le.bool();
            break;
          case 13:
            Pe.disableRed = le.bool();
            break;
          default:
            le.skipType(Fe & 7);
            break;
        }
      }
      return Pe;
    },
    fromJSON(A) {
      return {
        cid: oe(A.cid) ? String(A.cid) : "",
        name: oe(A.name) ? String(A.name) : "",
        type: oe(A.type) ? v.trackTypeFromJSON(A.type) : 0,
        width: oe(A.width) ? Number(A.width) : 0,
        height: oe(A.height) ? Number(A.height) : 0,
        muted: oe(A.muted) ? !!A.muted : !1,
        disableDtx: oe(A.disableDtx) ? !!A.disableDtx : !1,
        source: oe(A.source) ? v.trackSourceFromJSON(A.source) : 0,
        layers: Array.isArray(A == null ? void 0 : A.layers) ? A.layers.map((re) => v.VideoLayer.fromJSON(re)) : [],
        simulcastCodecs: Array.isArray(A == null ? void 0 : A.simulcastCodecs) ? A.simulcastCodecs.map((re) => a.SimulcastCodec.fromJSON(re)) : [],
        sid: oe(A.sid) ? String(A.sid) : "",
        stereo: oe(A.stereo) ? !!A.stereo : !1,
        disableRed: oe(A.disableRed) ? !!A.disableRed : !1
      };
    },
    toJSON(A) {
      const re = {};
      return A.cid !== void 0 && (re.cid = A.cid), A.name !== void 0 && (re.name = A.name), A.type !== void 0 && (re.type = v.trackTypeToJSON(A.type)), A.width !== void 0 && (re.width = Math.round(A.width)), A.height !== void 0 && (re.height = Math.round(A.height)), A.muted !== void 0 && (re.muted = A.muted), A.disableDtx !== void 0 && (re.disableDtx = A.disableDtx), A.source !== void 0 && (re.source = v.trackSourceToJSON(A.source)), A.layers ? re.layers = A.layers.map((le) => le ? v.VideoLayer.toJSON(le) : void 0) : re.layers = [], A.simulcastCodecs ? re.simulcastCodecs = A.simulcastCodecs.map((le) => le ? a.SimulcastCodec.toJSON(le) : void 0) : re.simulcastCodecs = [], A.sid !== void 0 && (re.sid = A.sid), A.stereo !== void 0 && (re.stereo = A.stereo), A.disableRed !== void 0 && (re.disableRed = A.disableRed), re;
    },
    fromPartial(A) {
      var re, le, Ne, Pe, Fe, je, qe, yt, Xe, Ge, H, ye, Ee;
      const We = ne();
      return We.cid = (re = A.cid) !== null && re !== void 0 ? re : "", We.name = (le = A.name) !== null && le !== void 0 ? le : "", We.type = (Ne = A.type) !== null && Ne !== void 0 ? Ne : 0, We.width = (Pe = A.width) !== null && Pe !== void 0 ? Pe : 0, We.height = (Fe = A.height) !== null && Fe !== void 0 ? Fe : 0, We.muted = (je = A.muted) !== null && je !== void 0 ? je : !1, We.disableDtx = (qe = A.disableDtx) !== null && qe !== void 0 ? qe : !1, We.source = (yt = A.source) !== null && yt !== void 0 ? yt : 0, We.layers = ((Xe = A.layers) === null || Xe === void 0 ? void 0 : Xe.map((we) => v.VideoLayer.fromPartial(we))) || [], We.simulcastCodecs = ((Ge = A.simulcastCodecs) === null || Ge === void 0 ? void 0 : Ge.map((we) => a.SimulcastCodec.fromPartial(we))) || [], We.sid = (H = A.sid) !== null && H !== void 0 ? H : "", We.stereo = (ye = A.stereo) !== null && ye !== void 0 ? ye : !1, We.disableRed = (Ee = A.disableRed) !== null && Ee !== void 0 ? Ee : !1, We;
    }
  };
  function Z() {
    return { candidateInit: "", target: 0 };
  }
  a.TrickleRequest = {
    encode(A, re = l.default.Writer.create()) {
      return A.candidateInit !== void 0 && A.candidateInit !== "" && re.uint32(10).string(A.candidateInit), A.target !== void 0 && A.target !== 0 && re.uint32(16).int32(A.target), re;
    },
    decode(A, re) {
      const le = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let Ne = re === void 0 ? le.len : le.pos + re;
      const Pe = Z();
      for (; le.pos < Ne; ) {
        const Fe = le.uint32();
        switch (Fe >>> 3) {
          case 1:
            Pe.candidateInit = le.string();
            break;
          case 2:
            Pe.target = le.int32();
            break;
          default:
            le.skipType(Fe & 7);
            break;
        }
      }
      return Pe;
    },
    fromJSON(A) {
      return {
        candidateInit: oe(A.candidateInit) ? String(A.candidateInit) : "",
        target: oe(A.target) ? _(A.target) : 0
      };
    },
    toJSON(A) {
      const re = {};
      return A.candidateInit !== void 0 && (re.candidateInit = A.candidateInit), A.target !== void 0 && (re.target = k(A.target)), re;
    },
    fromPartial(A) {
      var re, le;
      const Ne = Z();
      return Ne.candidateInit = (re = A.candidateInit) !== null && re !== void 0 ? re : "", Ne.target = (le = A.target) !== null && le !== void 0 ? le : 0, Ne;
    }
  };
  function de() {
    return { sid: "", muted: !1 };
  }
  a.MuteTrackRequest = {
    encode(A, re = l.default.Writer.create()) {
      return A.sid !== void 0 && A.sid !== "" && re.uint32(10).string(A.sid), A.muted === !0 && re.uint32(16).bool(A.muted), re;
    },
    decode(A, re) {
      const le = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let Ne = re === void 0 ? le.len : le.pos + re;
      const Pe = de();
      for (; le.pos < Ne; ) {
        const Fe = le.uint32();
        switch (Fe >>> 3) {
          case 1:
            Pe.sid = le.string();
            break;
          case 2:
            Pe.muted = le.bool();
            break;
          default:
            le.skipType(Fe & 7);
            break;
        }
      }
      return Pe;
    },
    fromJSON(A) {
      return {
        sid: oe(A.sid) ? String(A.sid) : "",
        muted: oe(A.muted) ? !!A.muted : !1
      };
    },
    toJSON(A) {
      const re = {};
      return A.sid !== void 0 && (re.sid = A.sid), A.muted !== void 0 && (re.muted = A.muted), re;
    },
    fromPartial(A) {
      var re, le;
      const Ne = de();
      return Ne.sid = (re = A.sid) !== null && re !== void 0 ? re : "", Ne.muted = (le = A.muted) !== null && le !== void 0 ? le : !1, Ne;
    }
  };
  function fe() {
    return {
      room: void 0,
      participant: void 0,
      otherParticipants: [],
      serverVersion: "",
      iceServers: [],
      subscriberPrimary: !1,
      alternativeUrl: "",
      clientConfiguration: void 0,
      serverRegion: "",
      pingTimeout: 0,
      pingInterval: 0,
      serverInfo: void 0
    };
  }
  a.JoinResponse = {
    encode(A, re = l.default.Writer.create()) {
      if (A.room !== void 0 && v.Room.encode(A.room, re.uint32(10).fork()).ldelim(), A.participant !== void 0 && v.ParticipantInfo.encode(A.participant, re.uint32(18).fork()).ldelim(), A.otherParticipants !== void 0 && A.otherParticipants.length !== 0)
        for (const le of A.otherParticipants)
          v.ParticipantInfo.encode(le, re.uint32(26).fork()).ldelim();
      if (A.serverVersion !== void 0 && A.serverVersion !== "" && re.uint32(34).string(A.serverVersion), A.iceServers !== void 0 && A.iceServers.length !== 0)
        for (const le of A.iceServers)
          a.ICEServer.encode(le, re.uint32(42).fork()).ldelim();
      return A.subscriberPrimary === !0 && re.uint32(48).bool(A.subscriberPrimary), A.alternativeUrl !== void 0 && A.alternativeUrl !== "" && re.uint32(58).string(A.alternativeUrl), A.clientConfiguration !== void 0 && v.ClientConfiguration.encode(A.clientConfiguration, re.uint32(66).fork()).ldelim(), A.serverRegion !== void 0 && A.serverRegion !== "" && re.uint32(74).string(A.serverRegion), A.pingTimeout !== void 0 && A.pingTimeout !== 0 && re.uint32(80).int32(A.pingTimeout), A.pingInterval !== void 0 && A.pingInterval !== 0 && re.uint32(88).int32(A.pingInterval), A.serverInfo !== void 0 && v.ServerInfo.encode(A.serverInfo, re.uint32(98).fork()).ldelim(), re;
    },
    decode(A, re) {
      const le = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let Ne = re === void 0 ? le.len : le.pos + re;
      const Pe = fe();
      for (; le.pos < Ne; ) {
        const Fe = le.uint32();
        switch (Fe >>> 3) {
          case 1:
            Pe.room = v.Room.decode(le, le.uint32());
            break;
          case 2:
            Pe.participant = v.ParticipantInfo.decode(le, le.uint32());
            break;
          case 3:
            Pe.otherParticipants.push(v.ParticipantInfo.decode(le, le.uint32()));
            break;
          case 4:
            Pe.serverVersion = le.string();
            break;
          case 5:
            Pe.iceServers.push(a.ICEServer.decode(le, le.uint32()));
            break;
          case 6:
            Pe.subscriberPrimary = le.bool();
            break;
          case 7:
            Pe.alternativeUrl = le.string();
            break;
          case 8:
            Pe.clientConfiguration = v.ClientConfiguration.decode(le, le.uint32());
            break;
          case 9:
            Pe.serverRegion = le.string();
            break;
          case 10:
            Pe.pingTimeout = le.int32();
            break;
          case 11:
            Pe.pingInterval = le.int32();
            break;
          case 12:
            Pe.serverInfo = v.ServerInfo.decode(le, le.uint32());
            break;
          default:
            le.skipType(Fe & 7);
            break;
        }
      }
      return Pe;
    },
    fromJSON(A) {
      return {
        room: oe(A.room) ? v.Room.fromJSON(A.room) : void 0,
        participant: oe(A.participant) ? v.ParticipantInfo.fromJSON(A.participant) : void 0,
        otherParticipants: Array.isArray(A == null ? void 0 : A.otherParticipants) ? A.otherParticipants.map((re) => v.ParticipantInfo.fromJSON(re)) : [],
        serverVersion: oe(A.serverVersion) ? String(A.serverVersion) : "",
        iceServers: Array.isArray(A == null ? void 0 : A.iceServers) ? A.iceServers.map((re) => a.ICEServer.fromJSON(re)) : [],
        subscriberPrimary: oe(A.subscriberPrimary) ? !!A.subscriberPrimary : !1,
        alternativeUrl: oe(A.alternativeUrl) ? String(A.alternativeUrl) : "",
        clientConfiguration: oe(A.clientConfiguration) ? v.ClientConfiguration.fromJSON(A.clientConfiguration) : void 0,
        serverRegion: oe(A.serverRegion) ? String(A.serverRegion) : "",
        pingTimeout: oe(A.pingTimeout) ? Number(A.pingTimeout) : 0,
        pingInterval: oe(A.pingInterval) ? Number(A.pingInterval) : 0,
        serverInfo: oe(A.serverInfo) ? v.ServerInfo.fromJSON(A.serverInfo) : void 0
      };
    },
    toJSON(A) {
      const re = {};
      return A.room !== void 0 && (re.room = A.room ? v.Room.toJSON(A.room) : void 0), A.participant !== void 0 && (re.participant = A.participant ? v.ParticipantInfo.toJSON(A.participant) : void 0), A.otherParticipants ? re.otherParticipants = A.otherParticipants.map((le) => le ? v.ParticipantInfo.toJSON(le) : void 0) : re.otherParticipants = [], A.serverVersion !== void 0 && (re.serverVersion = A.serverVersion), A.iceServers ? re.iceServers = A.iceServers.map((le) => le ? a.ICEServer.toJSON(le) : void 0) : re.iceServers = [], A.subscriberPrimary !== void 0 && (re.subscriberPrimary = A.subscriberPrimary), A.alternativeUrl !== void 0 && (re.alternativeUrl = A.alternativeUrl), A.clientConfiguration !== void 0 && (re.clientConfiguration = A.clientConfiguration ? v.ClientConfiguration.toJSON(A.clientConfiguration) : void 0), A.serverRegion !== void 0 && (re.serverRegion = A.serverRegion), A.pingTimeout !== void 0 && (re.pingTimeout = Math.round(A.pingTimeout)), A.pingInterval !== void 0 && (re.pingInterval = Math.round(A.pingInterval)), A.serverInfo !== void 0 && (re.serverInfo = A.serverInfo ? v.ServerInfo.toJSON(A.serverInfo) : void 0), re;
    },
    fromPartial(A) {
      var re, le, Ne, Pe, Fe, je, qe, yt;
      const Xe = fe();
      return Xe.room = A.room !== void 0 && A.room !== null ? v.Room.fromPartial(A.room) : void 0, Xe.participant = A.participant !== void 0 && A.participant !== null ? v.ParticipantInfo.fromPartial(A.participant) : void 0, Xe.otherParticipants = ((re = A.otherParticipants) === null || re === void 0 ? void 0 : re.map((Ge) => v.ParticipantInfo.fromPartial(Ge))) || [], Xe.serverVersion = (le = A.serverVersion) !== null && le !== void 0 ? le : "", Xe.iceServers = ((Ne = A.iceServers) === null || Ne === void 0 ? void 0 : Ne.map((Ge) => a.ICEServer.fromPartial(Ge))) || [], Xe.subscriberPrimary = (Pe = A.subscriberPrimary) !== null && Pe !== void 0 ? Pe : !1, Xe.alternativeUrl = (Fe = A.alternativeUrl) !== null && Fe !== void 0 ? Fe : "", Xe.clientConfiguration = A.clientConfiguration !== void 0 && A.clientConfiguration !== null ? v.ClientConfiguration.fromPartial(A.clientConfiguration) : void 0, Xe.serverRegion = (je = A.serverRegion) !== null && je !== void 0 ? je : "", Xe.pingTimeout = (qe = A.pingTimeout) !== null && qe !== void 0 ? qe : 0, Xe.pingInterval = (yt = A.pingInterval) !== null && yt !== void 0 ? yt : 0, Xe.serverInfo = A.serverInfo !== void 0 && A.serverInfo !== null ? v.ServerInfo.fromPartial(A.serverInfo) : void 0, Xe;
    }
  };
  function Te() {
    return { cid: "", track: void 0 };
  }
  a.TrackPublishedResponse = {
    encode(A, re = l.default.Writer.create()) {
      return A.cid !== void 0 && A.cid !== "" && re.uint32(10).string(A.cid), A.track !== void 0 && v.TrackInfo.encode(A.track, re.uint32(18).fork()).ldelim(), re;
    },
    decode(A, re) {
      const le = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let Ne = re === void 0 ? le.len : le.pos + re;
      const Pe = Te();
      for (; le.pos < Ne; ) {
        const Fe = le.uint32();
        switch (Fe >>> 3) {
          case 1:
            Pe.cid = le.string();
            break;
          case 2:
            Pe.track = v.TrackInfo.decode(le, le.uint32());
            break;
          default:
            le.skipType(Fe & 7);
            break;
        }
      }
      return Pe;
    },
    fromJSON(A) {
      return {
        cid: oe(A.cid) ? String(A.cid) : "",
        track: oe(A.track) ? v.TrackInfo.fromJSON(A.track) : void 0
      };
    },
    toJSON(A) {
      const re = {};
      return A.cid !== void 0 && (re.cid = A.cid), A.track !== void 0 && (re.track = A.track ? v.TrackInfo.toJSON(A.track) : void 0), re;
    },
    fromPartial(A) {
      var re;
      const le = Te();
      return le.cid = (re = A.cid) !== null && re !== void 0 ? re : "", le.track = A.track !== void 0 && A.track !== null ? v.TrackInfo.fromPartial(A.track) : void 0, le;
    }
  };
  function Re() {
    return { trackSid: "" };
  }
  a.TrackUnpublishedResponse = {
    encode(A, re = l.default.Writer.create()) {
      return A.trackSid !== void 0 && A.trackSid !== "" && re.uint32(10).string(A.trackSid), re;
    },
    decode(A, re) {
      const le = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let Ne = re === void 0 ? le.len : le.pos + re;
      const Pe = Re();
      for (; le.pos < Ne; ) {
        const Fe = le.uint32();
        switch (Fe >>> 3) {
          case 1:
            Pe.trackSid = le.string();
            break;
          default:
            le.skipType(Fe & 7);
            break;
        }
      }
      return Pe;
    },
    fromJSON(A) {
      return { trackSid: oe(A.trackSid) ? String(A.trackSid) : "" };
    },
    toJSON(A) {
      const re = {};
      return A.trackSid !== void 0 && (re.trackSid = A.trackSid), re;
    },
    fromPartial(A) {
      var re;
      const le = Re();
      return le.trackSid = (re = A.trackSid) !== null && re !== void 0 ? re : "", le;
    }
  };
  function Le() {
    return { type: "", sdp: "" };
  }
  a.SessionDescription = {
    encode(A, re = l.default.Writer.create()) {
      return A.type !== void 0 && A.type !== "" && re.uint32(10).string(A.type), A.sdp !== void 0 && A.sdp !== "" && re.uint32(18).string(A.sdp), re;
    },
    decode(A, re) {
      const le = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let Ne = re === void 0 ? le.len : le.pos + re;
      const Pe = Le();
      for (; le.pos < Ne; ) {
        const Fe = le.uint32();
        switch (Fe >>> 3) {
          case 1:
            Pe.type = le.string();
            break;
          case 2:
            Pe.sdp = le.string();
            break;
          default:
            le.skipType(Fe & 7);
            break;
        }
      }
      return Pe;
    },
    fromJSON(A) {
      return { type: oe(A.type) ? String(A.type) : "", sdp: oe(A.sdp) ? String(A.sdp) : "" };
    },
    toJSON(A) {
      const re = {};
      return A.type !== void 0 && (re.type = A.type), A.sdp !== void 0 && (re.sdp = A.sdp), re;
    },
    fromPartial(A) {
      var re, le;
      const Ne = Le();
      return Ne.type = (re = A.type) !== null && re !== void 0 ? re : "", Ne.sdp = (le = A.sdp) !== null && le !== void 0 ? le : "", Ne;
    }
  };
  function be() {
    return { participants: [] };
  }
  a.ParticipantUpdate = {
    encode(A, re = l.default.Writer.create()) {
      if (A.participants !== void 0 && A.participants.length !== 0)
        for (const le of A.participants)
          v.ParticipantInfo.encode(le, re.uint32(10).fork()).ldelim();
      return re;
    },
    decode(A, re) {
      const le = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let Ne = re === void 0 ? le.len : le.pos + re;
      const Pe = be();
      for (; le.pos < Ne; ) {
        const Fe = le.uint32();
        switch (Fe >>> 3) {
          case 1:
            Pe.participants.push(v.ParticipantInfo.decode(le, le.uint32()));
            break;
          default:
            le.skipType(Fe & 7);
            break;
        }
      }
      return Pe;
    },
    fromJSON(A) {
      return {
        participants: Array.isArray(A == null ? void 0 : A.participants) ? A.participants.map((re) => v.ParticipantInfo.fromJSON(re)) : []
      };
    },
    toJSON(A) {
      const re = {};
      return A.participants ? re.participants = A.participants.map((le) => le ? v.ParticipantInfo.toJSON(le) : void 0) : re.participants = [], re;
    },
    fromPartial(A) {
      var re;
      const le = be();
      return le.participants = ((re = A.participants) === null || re === void 0 ? void 0 : re.map((Ne) => v.ParticipantInfo.fromPartial(Ne))) || [], le;
    }
  };
  function q() {
    return { trackSids: [], subscribe: !1, participantTracks: [] };
  }
  a.UpdateSubscription = {
    encode(A, re = l.default.Writer.create()) {
      if (A.trackSids !== void 0 && A.trackSids.length !== 0)
        for (const le of A.trackSids)
          re.uint32(10).string(le);
      if (A.subscribe === !0 && re.uint32(16).bool(A.subscribe), A.participantTracks !== void 0 && A.participantTracks.length !== 0)
        for (const le of A.participantTracks)
          v.ParticipantTracks.encode(le, re.uint32(26).fork()).ldelim();
      return re;
    },
    decode(A, re) {
      const le = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let Ne = re === void 0 ? le.len : le.pos + re;
      const Pe = q();
      for (; le.pos < Ne; ) {
        const Fe = le.uint32();
        switch (Fe >>> 3) {
          case 1:
            Pe.trackSids.push(le.string());
            break;
          case 2:
            Pe.subscribe = le.bool();
            break;
          case 3:
            Pe.participantTracks.push(v.ParticipantTracks.decode(le, le.uint32()));
            break;
          default:
            le.skipType(Fe & 7);
            break;
        }
      }
      return Pe;
    },
    fromJSON(A) {
      return {
        trackSids: Array.isArray(A == null ? void 0 : A.trackSids) ? A.trackSids.map((re) => String(re)) : [],
        subscribe: oe(A.subscribe) ? !!A.subscribe : !1,
        participantTracks: Array.isArray(A == null ? void 0 : A.participantTracks) ? A.participantTracks.map((re) => v.ParticipantTracks.fromJSON(re)) : []
      };
    },
    toJSON(A) {
      const re = {};
      return A.trackSids ? re.trackSids = A.trackSids.map((le) => le) : re.trackSids = [], A.subscribe !== void 0 && (re.subscribe = A.subscribe), A.participantTracks ? re.participantTracks = A.participantTracks.map((le) => le ? v.ParticipantTracks.toJSON(le) : void 0) : re.participantTracks = [], re;
    },
    fromPartial(A) {
      var re, le, Ne;
      const Pe = q();
      return Pe.trackSids = ((re = A.trackSids) === null || re === void 0 ? void 0 : re.map((Fe) => Fe)) || [], Pe.subscribe = (le = A.subscribe) !== null && le !== void 0 ? le : !1, Pe.participantTracks = ((Ne = A.participantTracks) === null || Ne === void 0 ? void 0 : Ne.map((Fe) => v.ParticipantTracks.fromPartial(Fe))) || [], Pe;
    }
  };
  function J() {
    return { trackSids: [], disabled: !1, quality: 0, width: 0, height: 0, fps: 0 };
  }
  a.UpdateTrackSettings = {
    encode(A, re = l.default.Writer.create()) {
      if (A.trackSids !== void 0 && A.trackSids.length !== 0)
        for (const le of A.trackSids)
          re.uint32(10).string(le);
      return A.disabled === !0 && re.uint32(24).bool(A.disabled), A.quality !== void 0 && A.quality !== 0 && re.uint32(32).int32(A.quality), A.width !== void 0 && A.width !== 0 && re.uint32(40).uint32(A.width), A.height !== void 0 && A.height !== 0 && re.uint32(48).uint32(A.height), A.fps !== void 0 && A.fps !== 0 && re.uint32(56).uint32(A.fps), re;
    },
    decode(A, re) {
      const le = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let Ne = re === void 0 ? le.len : le.pos + re;
      const Pe = J();
      for (; le.pos < Ne; ) {
        const Fe = le.uint32();
        switch (Fe >>> 3) {
          case 1:
            Pe.trackSids.push(le.string());
            break;
          case 3:
            Pe.disabled = le.bool();
            break;
          case 4:
            Pe.quality = le.int32();
            break;
          case 5:
            Pe.width = le.uint32();
            break;
          case 6:
            Pe.height = le.uint32();
            break;
          case 7:
            Pe.fps = le.uint32();
            break;
          default:
            le.skipType(Fe & 7);
            break;
        }
      }
      return Pe;
    },
    fromJSON(A) {
      return {
        trackSids: Array.isArray(A == null ? void 0 : A.trackSids) ? A.trackSids.map((re) => String(re)) : [],
        disabled: oe(A.disabled) ? !!A.disabled : !1,
        quality: oe(A.quality) ? v.videoQualityFromJSON(A.quality) : 0,
        width: oe(A.width) ? Number(A.width) : 0,
        height: oe(A.height) ? Number(A.height) : 0,
        fps: oe(A.fps) ? Number(A.fps) : 0
      };
    },
    toJSON(A) {
      const re = {};
      return A.trackSids ? re.trackSids = A.trackSids.map((le) => le) : re.trackSids = [], A.disabled !== void 0 && (re.disabled = A.disabled), A.quality !== void 0 && (re.quality = v.videoQualityToJSON(A.quality)), A.width !== void 0 && (re.width = Math.round(A.width)), A.height !== void 0 && (re.height = Math.round(A.height)), A.fps !== void 0 && (re.fps = Math.round(A.fps)), re;
    },
    fromPartial(A) {
      var re, le, Ne, Pe, Fe, je;
      const qe = J();
      return qe.trackSids = ((re = A.trackSids) === null || re === void 0 ? void 0 : re.map((yt) => yt)) || [], qe.disabled = (le = A.disabled) !== null && le !== void 0 ? le : !1, qe.quality = (Ne = A.quality) !== null && Ne !== void 0 ? Ne : 0, qe.width = (Pe = A.width) !== null && Pe !== void 0 ? Pe : 0, qe.height = (Fe = A.height) !== null && Fe !== void 0 ? Fe : 0, qe.fps = (je = A.fps) !== null && je !== void 0 ? je : 0, qe;
    }
  };
  function C() {
    return { canReconnect: !1, reason: 0 };
  }
  a.LeaveRequest = {
    encode(A, re = l.default.Writer.create()) {
      return A.canReconnect === !0 && re.uint32(8).bool(A.canReconnect), A.reason !== void 0 && A.reason !== 0 && re.uint32(16).int32(A.reason), re;
    },
    decode(A, re) {
      const le = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let Ne = re === void 0 ? le.len : le.pos + re;
      const Pe = C();
      for (; le.pos < Ne; ) {
        const Fe = le.uint32();
        switch (Fe >>> 3) {
          case 1:
            Pe.canReconnect = le.bool();
            break;
          case 2:
            Pe.reason = le.int32();
            break;
          default:
            le.skipType(Fe & 7);
            break;
        }
      }
      return Pe;
    },
    fromJSON(A) {
      return {
        canReconnect: oe(A.canReconnect) ? !!A.canReconnect : !1,
        reason: oe(A.reason) ? v.disconnectReasonFromJSON(A.reason) : 0
      };
    },
    toJSON(A) {
      const re = {};
      return A.canReconnect !== void 0 && (re.canReconnect = A.canReconnect), A.reason !== void 0 && (re.reason = v.disconnectReasonToJSON(A.reason)), re;
    },
    fromPartial(A) {
      var re, le;
      const Ne = C();
      return Ne.canReconnect = (re = A.canReconnect) !== null && re !== void 0 ? re : !1, Ne.reason = (le = A.reason) !== null && le !== void 0 ? le : 0, Ne;
    }
  };
  function S() {
    return { trackSid: "", layers: [] };
  }
  a.UpdateVideoLayers = {
    encode(A, re = l.default.Writer.create()) {
      if (A.trackSid !== void 0 && A.trackSid !== "" && re.uint32(10).string(A.trackSid), A.layers !== void 0 && A.layers.length !== 0)
        for (const le of A.layers)
          v.VideoLayer.encode(le, re.uint32(18).fork()).ldelim();
      return re;
    },
    decode(A, re) {
      const le = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let Ne = re === void 0 ? le.len : le.pos + re;
      const Pe = S();
      for (; le.pos < Ne; ) {
        const Fe = le.uint32();
        switch (Fe >>> 3) {
          case 1:
            Pe.trackSid = le.string();
            break;
          case 2:
            Pe.layers.push(v.VideoLayer.decode(le, le.uint32()));
            break;
          default:
            le.skipType(Fe & 7);
            break;
        }
      }
      return Pe;
    },
    fromJSON(A) {
      return {
        trackSid: oe(A.trackSid) ? String(A.trackSid) : "",
        layers: Array.isArray(A == null ? void 0 : A.layers) ? A.layers.map((re) => v.VideoLayer.fromJSON(re)) : []
      };
    },
    toJSON(A) {
      const re = {};
      return A.trackSid !== void 0 && (re.trackSid = A.trackSid), A.layers ? re.layers = A.layers.map((le) => le ? v.VideoLayer.toJSON(le) : void 0) : re.layers = [], re;
    },
    fromPartial(A) {
      var re, le;
      const Ne = S();
      return Ne.trackSid = (re = A.trackSid) !== null && re !== void 0 ? re : "", Ne.layers = ((le = A.layers) === null || le === void 0 ? void 0 : le.map((Pe) => v.VideoLayer.fromPartial(Pe))) || [], Ne;
    }
  };
  function E() {
    return { urls: [], username: "", credential: "" };
  }
  a.ICEServer = {
    encode(A, re = l.default.Writer.create()) {
      if (A.urls !== void 0 && A.urls.length !== 0)
        for (const le of A.urls)
          re.uint32(10).string(le);
      return A.username !== void 0 && A.username !== "" && re.uint32(18).string(A.username), A.credential !== void 0 && A.credential !== "" && re.uint32(26).string(A.credential), re;
    },
    decode(A, re) {
      const le = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let Ne = re === void 0 ? le.len : le.pos + re;
      const Pe = E();
      for (; le.pos < Ne; ) {
        const Fe = le.uint32();
        switch (Fe >>> 3) {
          case 1:
            Pe.urls.push(le.string());
            break;
          case 2:
            Pe.username = le.string();
            break;
          case 3:
            Pe.credential = le.string();
            break;
          default:
            le.skipType(Fe & 7);
            break;
        }
      }
      return Pe;
    },
    fromJSON(A) {
      return {
        urls: Array.isArray(A == null ? void 0 : A.urls) ? A.urls.map((re) => String(re)) : [],
        username: oe(A.username) ? String(A.username) : "",
        credential: oe(A.credential) ? String(A.credential) : ""
      };
    },
    toJSON(A) {
      const re = {};
      return A.urls ? re.urls = A.urls.map((le) => le) : re.urls = [], A.username !== void 0 && (re.username = A.username), A.credential !== void 0 && (re.credential = A.credential), re;
    },
    fromPartial(A) {
      var re, le, Ne;
      const Pe = E();
      return Pe.urls = ((re = A.urls) === null || re === void 0 ? void 0 : re.map((Fe) => Fe)) || [], Pe.username = (le = A.username) !== null && le !== void 0 ? le : "", Pe.credential = (Ne = A.credential) !== null && Ne !== void 0 ? Ne : "", Pe;
    }
  };
  function I() {
    return { speakers: [] };
  }
  a.SpeakersChanged = {
    encode(A, re = l.default.Writer.create()) {
      if (A.speakers !== void 0 && A.speakers.length !== 0)
        for (const le of A.speakers)
          v.SpeakerInfo.encode(le, re.uint32(10).fork()).ldelim();
      return re;
    },
    decode(A, re) {
      const le = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let Ne = re === void 0 ? le.len : le.pos + re;
      const Pe = I();
      for (; le.pos < Ne; ) {
        const Fe = le.uint32();
        switch (Fe >>> 3) {
          case 1:
            Pe.speakers.push(v.SpeakerInfo.decode(le, le.uint32()));
            break;
          default:
            le.skipType(Fe & 7);
            break;
        }
      }
      return Pe;
    },
    fromJSON(A) {
      return {
        speakers: Array.isArray(A == null ? void 0 : A.speakers) ? A.speakers.map((re) => v.SpeakerInfo.fromJSON(re)) : []
      };
    },
    toJSON(A) {
      const re = {};
      return A.speakers ? re.speakers = A.speakers.map((le) => le ? v.SpeakerInfo.toJSON(le) : void 0) : re.speakers = [], re;
    },
    fromPartial(A) {
      var re;
      const le = I();
      return le.speakers = ((re = A.speakers) === null || re === void 0 ? void 0 : re.map((Ne) => v.SpeakerInfo.fromPartial(Ne))) || [], le;
    }
  };
  function M() {
    return { room: void 0 };
  }
  a.RoomUpdate = {
    encode(A, re = l.default.Writer.create()) {
      return A.room !== void 0 && v.Room.encode(A.room, re.uint32(10).fork()).ldelim(), re;
    },
    decode(A, re) {
      const le = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let Ne = re === void 0 ? le.len : le.pos + re;
      const Pe = M();
      for (; le.pos < Ne; ) {
        const Fe = le.uint32();
        switch (Fe >>> 3) {
          case 1:
            Pe.room = v.Room.decode(le, le.uint32());
            break;
          default:
            le.skipType(Fe & 7);
            break;
        }
      }
      return Pe;
    },
    fromJSON(A) {
      return { room: oe(A.room) ? v.Room.fromJSON(A.room) : void 0 };
    },
    toJSON(A) {
      const re = {};
      return A.room !== void 0 && (re.room = A.room ? v.Room.toJSON(A.room) : void 0), re;
    },
    fromPartial(A) {
      const re = M();
      return re.room = A.room !== void 0 && A.room !== null ? v.Room.fromPartial(A.room) : void 0, re;
    }
  };
  function $() {
    return { participantSid: "", quality: 0, score: 0 };
  }
  a.ConnectionQualityInfo = {
    encode(A, re = l.default.Writer.create()) {
      return A.participantSid !== void 0 && A.participantSid !== "" && re.uint32(10).string(A.participantSid), A.quality !== void 0 && A.quality !== 0 && re.uint32(16).int32(A.quality), A.score !== void 0 && A.score !== 0 && re.uint32(29).float(A.score), re;
    },
    decode(A, re) {
      const le = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let Ne = re === void 0 ? le.len : le.pos + re;
      const Pe = $();
      for (; le.pos < Ne; ) {
        const Fe = le.uint32();
        switch (Fe >>> 3) {
          case 1:
            Pe.participantSid = le.string();
            break;
          case 2:
            Pe.quality = le.int32();
            break;
          case 3:
            Pe.score = le.float();
            break;
          default:
            le.skipType(Fe & 7);
            break;
        }
      }
      return Pe;
    },
    fromJSON(A) {
      return {
        participantSid: oe(A.participantSid) ? String(A.participantSid) : "",
        quality: oe(A.quality) ? v.connectionQualityFromJSON(A.quality) : 0,
        score: oe(A.score) ? Number(A.score) : 0
      };
    },
    toJSON(A) {
      const re = {};
      return A.participantSid !== void 0 && (re.participantSid = A.participantSid), A.quality !== void 0 && (re.quality = v.connectionQualityToJSON(A.quality)), A.score !== void 0 && (re.score = A.score), re;
    },
    fromPartial(A) {
      var re, le, Ne;
      const Pe = $();
      return Pe.participantSid = (re = A.participantSid) !== null && re !== void 0 ? re : "", Pe.quality = (le = A.quality) !== null && le !== void 0 ? le : 0, Pe.score = (Ne = A.score) !== null && Ne !== void 0 ? Ne : 0, Pe;
    }
  };
  function U() {
    return { updates: [] };
  }
  a.ConnectionQualityUpdate = {
    encode(A, re = l.default.Writer.create()) {
      if (A.updates !== void 0 && A.updates.length !== 0)
        for (const le of A.updates)
          a.ConnectionQualityInfo.encode(le, re.uint32(10).fork()).ldelim();
      return re;
    },
    decode(A, re) {
      const le = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let Ne = re === void 0 ? le.len : le.pos + re;
      const Pe = U();
      for (; le.pos < Ne; ) {
        const Fe = le.uint32();
        switch (Fe >>> 3) {
          case 1:
            Pe.updates.push(a.ConnectionQualityInfo.decode(le, le.uint32()));
            break;
          default:
            le.skipType(Fe & 7);
            break;
        }
      }
      return Pe;
    },
    fromJSON(A) {
      return {
        updates: Array.isArray(A == null ? void 0 : A.updates) ? A.updates.map((re) => a.ConnectionQualityInfo.fromJSON(re)) : []
      };
    },
    toJSON(A) {
      const re = {};
      return A.updates ? re.updates = A.updates.map((le) => le ? a.ConnectionQualityInfo.toJSON(le) : void 0) : re.updates = [], re;
    },
    fromPartial(A) {
      var re;
      const le = U();
      return le.updates = ((re = A.updates) === null || re === void 0 ? void 0 : re.map((Ne) => a.ConnectionQualityInfo.fromPartial(Ne))) || [], le;
    }
  };
  function Y() {
    return { participantSid: "", trackSid: "", state: 0 };
  }
  a.StreamStateInfo = {
    encode(A, re = l.default.Writer.create()) {
      return A.participantSid !== void 0 && A.participantSid !== "" && re.uint32(10).string(A.participantSid), A.trackSid !== void 0 && A.trackSid !== "" && re.uint32(18).string(A.trackSid), A.state !== void 0 && A.state !== 0 && re.uint32(24).int32(A.state), re;
    },
    decode(A, re) {
      const le = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let Ne = re === void 0 ? le.len : le.pos + re;
      const Pe = Y();
      for (; le.pos < Ne; ) {
        const Fe = le.uint32();
        switch (Fe >>> 3) {
          case 1:
            Pe.participantSid = le.string();
            break;
          case 2:
            Pe.trackSid = le.string();
            break;
          case 3:
            Pe.state = le.int32();
            break;
          default:
            le.skipType(Fe & 7);
            break;
        }
      }
      return Pe;
    },
    fromJSON(A) {
      return {
        participantSid: oe(A.participantSid) ? String(A.participantSid) : "",
        trackSid: oe(A.trackSid) ? String(A.trackSid) : "",
        state: oe(A.state) ? D(A.state) : 0
      };
    },
    toJSON(A) {
      const re = {};
      return A.participantSid !== void 0 && (re.participantSid = A.participantSid), A.trackSid !== void 0 && (re.trackSid = A.trackSid), A.state !== void 0 && (re.state = F(A.state)), re;
    },
    fromPartial(A) {
      var re, le, Ne;
      const Pe = Y();
      return Pe.participantSid = (re = A.participantSid) !== null && re !== void 0 ? re : "", Pe.trackSid = (le = A.trackSid) !== null && le !== void 0 ? le : "", Pe.state = (Ne = A.state) !== null && Ne !== void 0 ? Ne : 0, Pe;
    }
  };
  function L() {
    return { streamStates: [] };
  }
  a.StreamStateUpdate = {
    encode(A, re = l.default.Writer.create()) {
      if (A.streamStates !== void 0 && A.streamStates.length !== 0)
        for (const le of A.streamStates)
          a.StreamStateInfo.encode(le, re.uint32(10).fork()).ldelim();
      return re;
    },
    decode(A, re) {
      const le = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let Ne = re === void 0 ? le.len : le.pos + re;
      const Pe = L();
      for (; le.pos < Ne; ) {
        const Fe = le.uint32();
        switch (Fe >>> 3) {
          case 1:
            Pe.streamStates.push(a.StreamStateInfo.decode(le, le.uint32()));
            break;
          default:
            le.skipType(Fe & 7);
            break;
        }
      }
      return Pe;
    },
    fromJSON(A) {
      return {
        streamStates: Array.isArray(A == null ? void 0 : A.streamStates) ? A.streamStates.map((re) => a.StreamStateInfo.fromJSON(re)) : []
      };
    },
    toJSON(A) {
      const re = {};
      return A.streamStates ? re.streamStates = A.streamStates.map((le) => le ? a.StreamStateInfo.toJSON(le) : void 0) : re.streamStates = [], re;
    },
    fromPartial(A) {
      var re;
      const le = L();
      return le.streamStates = ((re = A.streamStates) === null || re === void 0 ? void 0 : re.map((Ne) => a.StreamStateInfo.fromPartial(Ne))) || [], le;
    }
  };
  function T() {
    return { quality: 0, enabled: !1 };
  }
  a.SubscribedQuality = {
    encode(A, re = l.default.Writer.create()) {
      return A.quality !== void 0 && A.quality !== 0 && re.uint32(8).int32(A.quality), A.enabled === !0 && re.uint32(16).bool(A.enabled), re;
    },
    decode(A, re) {
      const le = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let Ne = re === void 0 ? le.len : le.pos + re;
      const Pe = T();
      for (; le.pos < Ne; ) {
        const Fe = le.uint32();
        switch (Fe >>> 3) {
          case 1:
            Pe.quality = le.int32();
            break;
          case 2:
            Pe.enabled = le.bool();
            break;
          default:
            le.skipType(Fe & 7);
            break;
        }
      }
      return Pe;
    },
    fromJSON(A) {
      return {
        quality: oe(A.quality) ? v.videoQualityFromJSON(A.quality) : 0,
        enabled: oe(A.enabled) ? !!A.enabled : !1
      };
    },
    toJSON(A) {
      const re = {};
      return A.quality !== void 0 && (re.quality = v.videoQualityToJSON(A.quality)), A.enabled !== void 0 && (re.enabled = A.enabled), re;
    },
    fromPartial(A) {
      var re, le;
      const Ne = T();
      return Ne.quality = (re = A.quality) !== null && re !== void 0 ? re : 0, Ne.enabled = (le = A.enabled) !== null && le !== void 0 ? le : !1, Ne;
    }
  };
  function B() {
    return { codec: "", qualities: [] };
  }
  a.SubscribedCodec = {
    encode(A, re = l.default.Writer.create()) {
      if (A.codec !== void 0 && A.codec !== "" && re.uint32(10).string(A.codec), A.qualities !== void 0 && A.qualities.length !== 0)
        for (const le of A.qualities)
          a.SubscribedQuality.encode(le, re.uint32(18).fork()).ldelim();
      return re;
    },
    decode(A, re) {
      const le = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let Ne = re === void 0 ? le.len : le.pos + re;
      const Pe = B();
      for (; le.pos < Ne; ) {
        const Fe = le.uint32();
        switch (Fe >>> 3) {
          case 1:
            Pe.codec = le.string();
            break;
          case 2:
            Pe.qualities.push(a.SubscribedQuality.decode(le, le.uint32()));
            break;
          default:
            le.skipType(Fe & 7);
            break;
        }
      }
      return Pe;
    },
    fromJSON(A) {
      return {
        codec: oe(A.codec) ? String(A.codec) : "",
        qualities: Array.isArray(A == null ? void 0 : A.qualities) ? A.qualities.map((re) => a.SubscribedQuality.fromJSON(re)) : []
      };
    },
    toJSON(A) {
      const re = {};
      return A.codec !== void 0 && (re.codec = A.codec), A.qualities ? re.qualities = A.qualities.map((le) => le ? a.SubscribedQuality.toJSON(le) : void 0) : re.qualities = [], re;
    },
    fromPartial(A) {
      var re, le;
      const Ne = B();
      return Ne.codec = (re = A.codec) !== null && re !== void 0 ? re : "", Ne.qualities = ((le = A.qualities) === null || le === void 0 ? void 0 : le.map((Pe) => a.SubscribedQuality.fromPartial(Pe))) || [], Ne;
    }
  };
  function te() {
    return { trackSid: "", subscribedQualities: [], subscribedCodecs: [] };
  }
  a.SubscribedQualityUpdate = {
    encode(A, re = l.default.Writer.create()) {
      if (A.trackSid !== void 0 && A.trackSid !== "" && re.uint32(10).string(A.trackSid), A.subscribedQualities !== void 0 && A.subscribedQualities.length !== 0)
        for (const le of A.subscribedQualities)
          a.SubscribedQuality.encode(le, re.uint32(18).fork()).ldelim();
      if (A.subscribedCodecs !== void 0 && A.subscribedCodecs.length !== 0)
        for (const le of A.subscribedCodecs)
          a.SubscribedCodec.encode(le, re.uint32(26).fork()).ldelim();
      return re;
    },
    decode(A, re) {
      const le = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let Ne = re === void 0 ? le.len : le.pos + re;
      const Pe = te();
      for (; le.pos < Ne; ) {
        const Fe = le.uint32();
        switch (Fe >>> 3) {
          case 1:
            Pe.trackSid = le.string();
            break;
          case 2:
            Pe.subscribedQualities.push(a.SubscribedQuality.decode(le, le.uint32()));
            break;
          case 3:
            Pe.subscribedCodecs.push(a.SubscribedCodec.decode(le, le.uint32()));
            break;
          default:
            le.skipType(Fe & 7);
            break;
        }
      }
      return Pe;
    },
    fromJSON(A) {
      return {
        trackSid: oe(A.trackSid) ? String(A.trackSid) : "",
        subscribedQualities: Array.isArray(A == null ? void 0 : A.subscribedQualities) ? A.subscribedQualities.map((re) => a.SubscribedQuality.fromJSON(re)) : [],
        subscribedCodecs: Array.isArray(A == null ? void 0 : A.subscribedCodecs) ? A.subscribedCodecs.map((re) => a.SubscribedCodec.fromJSON(re)) : []
      };
    },
    toJSON(A) {
      const re = {};
      return A.trackSid !== void 0 && (re.trackSid = A.trackSid), A.subscribedQualities ? re.subscribedQualities = A.subscribedQualities.map((le) => le ? a.SubscribedQuality.toJSON(le) : void 0) : re.subscribedQualities = [], A.subscribedCodecs ? re.subscribedCodecs = A.subscribedCodecs.map((le) => le ? a.SubscribedCodec.toJSON(le) : void 0) : re.subscribedCodecs = [], re;
    },
    fromPartial(A) {
      var re, le, Ne;
      const Pe = te();
      return Pe.trackSid = (re = A.trackSid) !== null && re !== void 0 ? re : "", Pe.subscribedQualities = ((le = A.subscribedQualities) === null || le === void 0 ? void 0 : le.map((Fe) => a.SubscribedQuality.fromPartial(Fe))) || [], Pe.subscribedCodecs = ((Ne = A.subscribedCodecs) === null || Ne === void 0 ? void 0 : Ne.map((Fe) => a.SubscribedCodec.fromPartial(Fe))) || [], Pe;
    }
  };
  function pe() {
    return { participantSid: "", allTracks: !1, trackSids: [], participantIdentity: "" };
  }
  a.TrackPermission = {
    encode(A, re = l.default.Writer.create()) {
      if (A.participantSid !== void 0 && A.participantSid !== "" && re.uint32(10).string(A.participantSid), A.allTracks === !0 && re.uint32(16).bool(A.allTracks), A.trackSids !== void 0 && A.trackSids.length !== 0)
        for (const le of A.trackSids)
          re.uint32(26).string(le);
      return A.participantIdentity !== void 0 && A.participantIdentity !== "" && re.uint32(34).string(A.participantIdentity), re;
    },
    decode(A, re) {
      const le = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let Ne = re === void 0 ? le.len : le.pos + re;
      const Pe = pe();
      for (; le.pos < Ne; ) {
        const Fe = le.uint32();
        switch (Fe >>> 3) {
          case 1:
            Pe.participantSid = le.string();
            break;
          case 2:
            Pe.allTracks = le.bool();
            break;
          case 3:
            Pe.trackSids.push(le.string());
            break;
          case 4:
            Pe.participantIdentity = le.string();
            break;
          default:
            le.skipType(Fe & 7);
            break;
        }
      }
      return Pe;
    },
    fromJSON(A) {
      return {
        participantSid: oe(A.participantSid) ? String(A.participantSid) : "",
        allTracks: oe(A.allTracks) ? !!A.allTracks : !1,
        trackSids: Array.isArray(A == null ? void 0 : A.trackSids) ? A.trackSids.map((re) => String(re)) : [],
        participantIdentity: oe(A.participantIdentity) ? String(A.participantIdentity) : ""
      };
    },
    toJSON(A) {
      const re = {};
      return A.participantSid !== void 0 && (re.participantSid = A.participantSid), A.allTracks !== void 0 && (re.allTracks = A.allTracks), A.trackSids ? re.trackSids = A.trackSids.map((le) => le) : re.trackSids = [], A.participantIdentity !== void 0 && (re.participantIdentity = A.participantIdentity), re;
    },
    fromPartial(A) {
      var re, le, Ne, Pe;
      const Fe = pe();
      return Fe.participantSid = (re = A.participantSid) !== null && re !== void 0 ? re : "", Fe.allTracks = (le = A.allTracks) !== null && le !== void 0 ? le : !1, Fe.trackSids = ((Ne = A.trackSids) === null || Ne === void 0 ? void 0 : Ne.map((je) => je)) || [], Fe.participantIdentity = (Pe = A.participantIdentity) !== null && Pe !== void 0 ? Pe : "", Fe;
    }
  };
  function Ie() {
    return { allParticipants: !1, trackPermissions: [] };
  }
  a.SubscriptionPermission = {
    encode(A, re = l.default.Writer.create()) {
      if (A.allParticipants === !0 && re.uint32(8).bool(A.allParticipants), A.trackPermissions !== void 0 && A.trackPermissions.length !== 0)
        for (const le of A.trackPermissions)
          a.TrackPermission.encode(le, re.uint32(18).fork()).ldelim();
      return re;
    },
    decode(A, re) {
      const le = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let Ne = re === void 0 ? le.len : le.pos + re;
      const Pe = Ie();
      for (; le.pos < Ne; ) {
        const Fe = le.uint32();
        switch (Fe >>> 3) {
          case 1:
            Pe.allParticipants = le.bool();
            break;
          case 2:
            Pe.trackPermissions.push(a.TrackPermission.decode(le, le.uint32()));
            break;
          default:
            le.skipType(Fe & 7);
            break;
        }
      }
      return Pe;
    },
    fromJSON(A) {
      return {
        allParticipants: oe(A.allParticipants) ? !!A.allParticipants : !1,
        trackPermissions: Array.isArray(A == null ? void 0 : A.trackPermissions) ? A.trackPermissions.map((re) => a.TrackPermission.fromJSON(re)) : []
      };
    },
    toJSON(A) {
      const re = {};
      return A.allParticipants !== void 0 && (re.allParticipants = A.allParticipants), A.trackPermissions ? re.trackPermissions = A.trackPermissions.map((le) => le ? a.TrackPermission.toJSON(le) : void 0) : re.trackPermissions = [], re;
    },
    fromPartial(A) {
      var re, le;
      const Ne = Ie();
      return Ne.allParticipants = (re = A.allParticipants) !== null && re !== void 0 ? re : !1, Ne.trackPermissions = ((le = A.trackPermissions) === null || le === void 0 ? void 0 : le.map((Pe) => a.TrackPermission.fromPartial(Pe))) || [], Ne;
    }
  };
  function $e() {
    return { participantSid: "", trackSid: "", allowed: !1 };
  }
  a.SubscriptionPermissionUpdate = {
    encode(A, re = l.default.Writer.create()) {
      return A.participantSid !== void 0 && A.participantSid !== "" && re.uint32(10).string(A.participantSid), A.trackSid !== void 0 && A.trackSid !== "" && re.uint32(18).string(A.trackSid), A.allowed === !0 && re.uint32(24).bool(A.allowed), re;
    },
    decode(A, re) {
      const le = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let Ne = re === void 0 ? le.len : le.pos + re;
      const Pe = $e();
      for (; le.pos < Ne; ) {
        const Fe = le.uint32();
        switch (Fe >>> 3) {
          case 1:
            Pe.participantSid = le.string();
            break;
          case 2:
            Pe.trackSid = le.string();
            break;
          case 3:
            Pe.allowed = le.bool();
            break;
          default:
            le.skipType(Fe & 7);
            break;
        }
      }
      return Pe;
    },
    fromJSON(A) {
      return {
        participantSid: oe(A.participantSid) ? String(A.participantSid) : "",
        trackSid: oe(A.trackSid) ? String(A.trackSid) : "",
        allowed: oe(A.allowed) ? !!A.allowed : !1
      };
    },
    toJSON(A) {
      const re = {};
      return A.participantSid !== void 0 && (re.participantSid = A.participantSid), A.trackSid !== void 0 && (re.trackSid = A.trackSid), A.allowed !== void 0 && (re.allowed = A.allowed), re;
    },
    fromPartial(A) {
      var re, le, Ne;
      const Pe = $e();
      return Pe.participantSid = (re = A.participantSid) !== null && re !== void 0 ? re : "", Pe.trackSid = (le = A.trackSid) !== null && le !== void 0 ? le : "", Pe.allowed = (Ne = A.allowed) !== null && Ne !== void 0 ? Ne : !1, Pe;
    }
  };
  function ve() {
    return { answer: void 0, subscription: void 0, publishTracks: [], dataChannels: [], offer: void 0 };
  }
  a.SyncState = {
    encode(A, re = l.default.Writer.create()) {
      if (A.answer !== void 0 && a.SessionDescription.encode(A.answer, re.uint32(10).fork()).ldelim(), A.subscription !== void 0 && a.UpdateSubscription.encode(A.subscription, re.uint32(18).fork()).ldelim(), A.publishTracks !== void 0 && A.publishTracks.length !== 0)
        for (const le of A.publishTracks)
          a.TrackPublishedResponse.encode(le, re.uint32(26).fork()).ldelim();
      if (A.dataChannels !== void 0 && A.dataChannels.length !== 0)
        for (const le of A.dataChannels)
          a.DataChannelInfo.encode(le, re.uint32(34).fork()).ldelim();
      return A.offer !== void 0 && a.SessionDescription.encode(A.offer, re.uint32(42).fork()).ldelim(), re;
    },
    decode(A, re) {
      const le = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let Ne = re === void 0 ? le.len : le.pos + re;
      const Pe = ve();
      for (; le.pos < Ne; ) {
        const Fe = le.uint32();
        switch (Fe >>> 3) {
          case 1:
            Pe.answer = a.SessionDescription.decode(le, le.uint32());
            break;
          case 2:
            Pe.subscription = a.UpdateSubscription.decode(le, le.uint32());
            break;
          case 3:
            Pe.publishTracks.push(a.TrackPublishedResponse.decode(le, le.uint32()));
            break;
          case 4:
            Pe.dataChannels.push(a.DataChannelInfo.decode(le, le.uint32()));
            break;
          case 5:
            Pe.offer = a.SessionDescription.decode(le, le.uint32());
            break;
          default:
            le.skipType(Fe & 7);
            break;
        }
      }
      return Pe;
    },
    fromJSON(A) {
      return {
        answer: oe(A.answer) ? a.SessionDescription.fromJSON(A.answer) : void 0,
        subscription: oe(A.subscription) ? a.UpdateSubscription.fromJSON(A.subscription) : void 0,
        publishTracks: Array.isArray(A == null ? void 0 : A.publishTracks) ? A.publishTracks.map((re) => a.TrackPublishedResponse.fromJSON(re)) : [],
        dataChannels: Array.isArray(A == null ? void 0 : A.dataChannels) ? A.dataChannels.map((re) => a.DataChannelInfo.fromJSON(re)) : [],
        offer: oe(A.offer) ? a.SessionDescription.fromJSON(A.offer) : void 0
      };
    },
    toJSON(A) {
      const re = {};
      return A.answer !== void 0 && (re.answer = A.answer ? a.SessionDescription.toJSON(A.answer) : void 0), A.subscription !== void 0 && (re.subscription = A.subscription ? a.UpdateSubscription.toJSON(A.subscription) : void 0), A.publishTracks ? re.publishTracks = A.publishTracks.map((le) => le ? a.TrackPublishedResponse.toJSON(le) : void 0) : re.publishTracks = [], A.dataChannels ? re.dataChannels = A.dataChannels.map((le) => le ? a.DataChannelInfo.toJSON(le) : void 0) : re.dataChannels = [], A.offer !== void 0 && (re.offer = A.offer ? a.SessionDescription.toJSON(A.offer) : void 0), re;
    },
    fromPartial(A) {
      var re, le;
      const Ne = ve();
      return Ne.answer = A.answer !== void 0 && A.answer !== null ? a.SessionDescription.fromPartial(A.answer) : void 0, Ne.subscription = A.subscription !== void 0 && A.subscription !== null ? a.UpdateSubscription.fromPartial(A.subscription) : void 0, Ne.publishTracks = ((re = A.publishTracks) === null || re === void 0 ? void 0 : re.map((Pe) => a.TrackPublishedResponse.fromPartial(Pe))) || [], Ne.dataChannels = ((le = A.dataChannels) === null || le === void 0 ? void 0 : le.map((Pe) => a.DataChannelInfo.fromPartial(Pe))) || [], Ne.offer = A.offer !== void 0 && A.offer !== null ? a.SessionDescription.fromPartial(A.offer) : void 0, Ne;
    }
  };
  function he() {
    return { label: "", id: 0, target: 0 };
  }
  a.DataChannelInfo = {
    encode(A, re = l.default.Writer.create()) {
      return A.label !== void 0 && A.label !== "" && re.uint32(10).string(A.label), A.id !== void 0 && A.id !== 0 && re.uint32(16).uint32(A.id), A.target !== void 0 && A.target !== 0 && re.uint32(24).int32(A.target), re;
    },
    decode(A, re) {
      const le = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let Ne = re === void 0 ? le.len : le.pos + re;
      const Pe = he();
      for (; le.pos < Ne; ) {
        const Fe = le.uint32();
        switch (Fe >>> 3) {
          case 1:
            Pe.label = le.string();
            break;
          case 2:
            Pe.id = le.uint32();
            break;
          case 3:
            Pe.target = le.int32();
            break;
          default:
            le.skipType(Fe & 7);
            break;
        }
      }
      return Pe;
    },
    fromJSON(A) {
      return {
        label: oe(A.label) ? String(A.label) : "",
        id: oe(A.id) ? Number(A.id) : 0,
        target: oe(A.target) ? _(A.target) : 0
      };
    },
    toJSON(A) {
      const re = {};
      return A.label !== void 0 && (re.label = A.label), A.id !== void 0 && (re.id = Math.round(A.id)), A.target !== void 0 && (re.target = k(A.target)), re;
    },
    fromPartial(A) {
      var re, le, Ne;
      const Pe = he();
      return Pe.label = (re = A.label) !== null && re !== void 0 ? re : "", Pe.id = (le = A.id) !== null && le !== void 0 ? le : 0, Pe.target = (Ne = A.target) !== null && Ne !== void 0 ? Ne : 0, Pe;
    }
  };
  function Oe() {
    return {
      speakerUpdate: void 0,
      nodeFailure: void 0,
      migration: void 0,
      serverLeave: void 0,
      switchCandidateProtocol: void 0
    };
  }
  a.SimulateScenario = {
    encode(A, re = l.default.Writer.create()) {
      return A.speakerUpdate !== void 0 && re.uint32(8).int32(A.speakerUpdate), A.nodeFailure !== void 0 && re.uint32(16).bool(A.nodeFailure), A.migration !== void 0 && re.uint32(24).bool(A.migration), A.serverLeave !== void 0 && re.uint32(32).bool(A.serverLeave), A.switchCandidateProtocol !== void 0 && re.uint32(40).int32(A.switchCandidateProtocol), re;
    },
    decode(A, re) {
      const le = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let Ne = re === void 0 ? le.len : le.pos + re;
      const Pe = Oe();
      for (; le.pos < Ne; ) {
        const Fe = le.uint32();
        switch (Fe >>> 3) {
          case 1:
            Pe.speakerUpdate = le.int32();
            break;
          case 2:
            Pe.nodeFailure = le.bool();
            break;
          case 3:
            Pe.migration = le.bool();
            break;
          case 4:
            Pe.serverLeave = le.bool();
            break;
          case 5:
            Pe.switchCandidateProtocol = le.int32();
            break;
          default:
            le.skipType(Fe & 7);
            break;
        }
      }
      return Pe;
    },
    fromJSON(A) {
      return {
        speakerUpdate: oe(A.speakerUpdate) ? Number(A.speakerUpdate) : void 0,
        nodeFailure: oe(A.nodeFailure) ? !!A.nodeFailure : void 0,
        migration: oe(A.migration) ? !!A.migration : void 0,
        serverLeave: oe(A.serverLeave) ? !!A.serverLeave : void 0,
        switchCandidateProtocol: oe(A.switchCandidateProtocol) ? j(A.switchCandidateProtocol) : void 0
      };
    },
    toJSON(A) {
      const re = {};
      return A.speakerUpdate !== void 0 && (re.speakerUpdate = Math.round(A.speakerUpdate)), A.nodeFailure !== void 0 && (re.nodeFailure = A.nodeFailure), A.migration !== void 0 && (re.migration = A.migration), A.serverLeave !== void 0 && (re.serverLeave = A.serverLeave), A.switchCandidateProtocol !== void 0 && (re.switchCandidateProtocol = A.switchCandidateProtocol !== void 0 ? ee(A.switchCandidateProtocol) : void 0), re;
    },
    fromPartial(A) {
      var re, le, Ne, Pe, Fe;
      const je = Oe();
      return je.speakerUpdate = (re = A.speakerUpdate) !== null && re !== void 0 ? re : void 0, je.nodeFailure = (le = A.nodeFailure) !== null && le !== void 0 ? le : void 0, je.migration = (Ne = A.migration) !== null && Ne !== void 0 ? Ne : void 0, je.serverLeave = (Pe = A.serverLeave) !== null && Pe !== void 0 ? Pe : void 0, je.switchCandidateProtocol = (Fe = A.switchCandidateProtocol) !== null && Fe !== void 0 ? Fe : void 0, je;
    }
  };
  var Ae = (() => {
    if (typeof Ae < "u")
      return Ae;
    if (typeof self < "u")
      return self;
    if (typeof window < "u")
      return window;
    if (typeof commonjsGlobal$1 < "u")
      return commonjsGlobal$1;
    throw "Unable to locate global object";
  })();
  function Ue(A) {
    if (A.gt(Number.MAX_SAFE_INTEGER))
      throw new Ae.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    return A.toNumber();
  }
  l.default.util.Long !== c.default && (l.default.util.Long = c.default, l.default.configure());
  function oe(A) {
    return A != null;
  }
})(livekit_rtc);
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(J) {
    return J && J.__esModule ? J : { default: J };
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.RoomInternal = a.KeepAlive = a.RemoveParticipant = a.EndSession = a.StartSession = a.SignalNodeMessage = a.RTCNodeMessage = a.NodeStats = a.Node = a.nodeStateToJSON = a.nodeStateFromJSON = a.NodeState = a.nodeTypeToJSON = a.nodeTypeFromJSON = a.NodeType = a.protobufPackage = void 0;
  const c = u(umdExports), l = u(minimal), v = livekit_egress, p = livekit_models, _ = livekit_room, k = livekit_rtc;
  a.protobufPackage = "livekit";
  var O;
  (function(J) {
    J[J.SERVER = 0] = "SERVER", J[J.CONTROLLER = 1] = "CONTROLLER", J[J.MEDIA = 2] = "MEDIA", J[J.TURN = 4] = "TURN", J[J.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(O = a.NodeType || (a.NodeType = {}));
  function D(J) {
    switch (J) {
      case 0:
      case "SERVER":
        return O.SERVER;
      case 1:
      case "CONTROLLER":
        return O.CONTROLLER;
      case 2:
      case "MEDIA":
        return O.MEDIA;
      case 4:
      case "TURN":
        return O.TURN;
      case -1:
      case "UNRECOGNIZED":
      default:
        return O.UNRECOGNIZED;
    }
  }
  a.nodeTypeFromJSON = D;
  function F(J) {
    switch (J) {
      case O.SERVER:
        return "SERVER";
      case O.CONTROLLER:
        return "CONTROLLER";
      case O.MEDIA:
        return "MEDIA";
      case O.TURN:
        return "TURN";
      case O.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.nodeTypeToJSON = F;
  var z;
  (function(J) {
    J[J.STARTING_UP = 0] = "STARTING_UP", J[J.SERVING = 1] = "SERVING", J[J.SHUTTING_DOWN = 2] = "SHUTTING_DOWN", J[J.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(z = a.NodeState || (a.NodeState = {}));
  function j(J) {
    switch (J) {
      case 0:
      case "STARTING_UP":
        return z.STARTING_UP;
      case 1:
      case "SERVING":
        return z.SERVING;
      case 2:
      case "SHUTTING_DOWN":
        return z.SHUTTING_DOWN;
      case -1:
      case "UNRECOGNIZED":
      default:
        return z.UNRECOGNIZED;
    }
  }
  a.nodeStateFromJSON = j;
  function ee(J) {
    switch (J) {
      case z.STARTING_UP:
        return "STARTING_UP";
      case z.SERVING:
        return "SERVING";
      case z.SHUTTING_DOWN:
        return "SHUTTING_DOWN";
      case z.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.nodeStateToJSON = ee;
  function X() {
    return { id: "", ip: "", numCpus: 0, stats: void 0, type: 0, state: 0, region: "" };
  }
  a.Node = {
    encode(J, C = l.default.Writer.create()) {
      return J.id !== void 0 && J.id !== "" && C.uint32(10).string(J.id), J.ip !== void 0 && J.ip !== "" && C.uint32(18).string(J.ip), J.numCpus !== void 0 && J.numCpus !== 0 && C.uint32(24).uint32(J.numCpus), J.stats !== void 0 && a.NodeStats.encode(J.stats, C.uint32(34).fork()).ldelim(), J.type !== void 0 && J.type !== 0 && C.uint32(40).int32(J.type), J.state !== void 0 && J.state !== 0 && C.uint32(48).int32(J.state), J.region !== void 0 && J.region !== "" && C.uint32(58).string(J.region), C;
    },
    decode(J, C) {
      const S = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let E = C === void 0 ? S.len : S.pos + C;
      const I = X();
      for (; S.pos < E; ) {
        const M = S.uint32();
        switch (M >>> 3) {
          case 1:
            I.id = S.string();
            break;
          case 2:
            I.ip = S.string();
            break;
          case 3:
            I.numCpus = S.uint32();
            break;
          case 4:
            I.stats = a.NodeStats.decode(S, S.uint32());
            break;
          case 5:
            I.type = S.int32();
            break;
          case 6:
            I.state = S.int32();
            break;
          case 7:
            I.region = S.string();
            break;
          default:
            S.skipType(M & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(J) {
      return {
        id: q(J.id) ? String(J.id) : "",
        ip: q(J.ip) ? String(J.ip) : "",
        numCpus: q(J.numCpus) ? Number(J.numCpus) : 0,
        stats: q(J.stats) ? a.NodeStats.fromJSON(J.stats) : void 0,
        type: q(J.type) ? D(J.type) : 0,
        state: q(J.state) ? j(J.state) : 0,
        region: q(J.region) ? String(J.region) : ""
      };
    },
    toJSON(J) {
      const C = {};
      return J.id !== void 0 && (C.id = J.id), J.ip !== void 0 && (C.ip = J.ip), J.numCpus !== void 0 && (C.numCpus = Math.round(J.numCpus)), J.stats !== void 0 && (C.stats = J.stats ? a.NodeStats.toJSON(J.stats) : void 0), J.type !== void 0 && (C.type = F(J.type)), J.state !== void 0 && (C.state = ee(J.state)), J.region !== void 0 && (C.region = J.region), C;
    },
    fromPartial(J) {
      var C, S, E, I, M, $;
      const U = X();
      return U.id = (C = J.id) !== null && C !== void 0 ? C : "", U.ip = (S = J.ip) !== null && S !== void 0 ? S : "", U.numCpus = (E = J.numCpus) !== null && E !== void 0 ? E : 0, U.stats = J.stats !== void 0 && J.stats !== null ? a.NodeStats.fromPartial(J.stats) : void 0, U.type = (I = J.type) !== null && I !== void 0 ? I : 0, U.state = (M = J.state) !== null && M !== void 0 ? M : 0, U.region = ($ = J.region) !== null && $ !== void 0 ? $ : "", U;
    }
  };
  function ae() {
    return {
      startedAt: 0,
      updatedAt: 0,
      numRooms: 0,
      numClients: 0,
      numTracksIn: 0,
      numTracksOut: 0,
      bytesIn: 0,
      bytesOut: 0,
      packetsIn: 0,
      packetsOut: 0,
      nackTotal: 0,
      bytesInPerSec: 0,
      bytesOutPerSec: 0,
      packetsInPerSec: 0,
      packetsOutPerSec: 0,
      nackPerSec: 0,
      numCpus: 0,
      loadAvgLast1min: 0,
      loadAvgLast5min: 0,
      loadAvgLast15min: 0,
      cpuLoad: 0,
      memoryLoad: 0,
      sysPacketsOut: 0,
      sysPacketsDropped: 0,
      sysPacketsOutPerSec: 0,
      sysPacketsDroppedPerSec: 0,
      sysPacketsDroppedPctPerSec: 0,
      retransmitBytesOut: 0,
      retransmitPacketsOut: 0,
      retransmitBytesOutPerSec: 0,
      retransmitPacketsOutPerSec: 0,
      participantJoin: 0,
      participantJoinPerSec: 0
    };
  }
  a.NodeStats = {
    encode(J, C = l.default.Writer.create()) {
      return J.startedAt !== void 0 && J.startedAt !== 0 && C.uint32(8).int64(J.startedAt), J.updatedAt !== void 0 && J.updatedAt !== 0 && C.uint32(16).int64(J.updatedAt), J.numRooms !== void 0 && J.numRooms !== 0 && C.uint32(24).int32(J.numRooms), J.numClients !== void 0 && J.numClients !== 0 && C.uint32(32).int32(J.numClients), J.numTracksIn !== void 0 && J.numTracksIn !== 0 && C.uint32(40).int32(J.numTracksIn), J.numTracksOut !== void 0 && J.numTracksOut !== 0 && C.uint32(48).int32(J.numTracksOut), J.bytesIn !== void 0 && J.bytesIn !== 0 && C.uint32(56).uint64(J.bytesIn), J.bytesOut !== void 0 && J.bytesOut !== 0 && C.uint32(64).uint64(J.bytesOut), J.packetsIn !== void 0 && J.packetsIn !== 0 && C.uint32(72).uint64(J.packetsIn), J.packetsOut !== void 0 && J.packetsOut !== 0 && C.uint32(80).uint64(J.packetsOut), J.nackTotal !== void 0 && J.nackTotal !== 0 && C.uint32(88).uint64(J.nackTotal), J.bytesInPerSec !== void 0 && J.bytesInPerSec !== 0 && C.uint32(101).float(J.bytesInPerSec), J.bytesOutPerSec !== void 0 && J.bytesOutPerSec !== 0 && C.uint32(109).float(J.bytesOutPerSec), J.packetsInPerSec !== void 0 && J.packetsInPerSec !== 0 && C.uint32(117).float(J.packetsInPerSec), J.packetsOutPerSec !== void 0 && J.packetsOutPerSec !== 0 && C.uint32(125).float(J.packetsOutPerSec), J.nackPerSec !== void 0 && J.nackPerSec !== 0 && C.uint32(133).float(J.nackPerSec), J.numCpus !== void 0 && J.numCpus !== 0 && C.uint32(136).uint32(J.numCpus), J.loadAvgLast1min !== void 0 && J.loadAvgLast1min !== 0 && C.uint32(149).float(J.loadAvgLast1min), J.loadAvgLast5min !== void 0 && J.loadAvgLast5min !== 0 && C.uint32(157).float(J.loadAvgLast5min), J.loadAvgLast15min !== void 0 && J.loadAvgLast15min !== 0 && C.uint32(165).float(J.loadAvgLast15min), J.cpuLoad !== void 0 && J.cpuLoad !== 0 && C.uint32(173).float(J.cpuLoad), J.memoryLoad !== void 0 && J.memoryLoad !== 0 && C.uint32(269).float(J.memoryLoad), J.sysPacketsOut !== void 0 && J.sysPacketsOut !== 0 && C.uint32(224).uint32(J.sysPacketsOut), J.sysPacketsDropped !== void 0 && J.sysPacketsDropped !== 0 && C.uint32(232).uint32(J.sysPacketsDropped), J.sysPacketsOutPerSec !== void 0 && J.sysPacketsOutPerSec !== 0 && C.uint32(245).float(J.sysPacketsOutPerSec), J.sysPacketsDroppedPerSec !== void 0 && J.sysPacketsDroppedPerSec !== 0 && C.uint32(253).float(J.sysPacketsDroppedPerSec), J.sysPacketsDroppedPctPerSec !== void 0 && J.sysPacketsDroppedPctPerSec !== 0 && C.uint32(261).float(J.sysPacketsDroppedPctPerSec), J.retransmitBytesOut !== void 0 && J.retransmitBytesOut !== 0 && C.uint32(176).uint64(J.retransmitBytesOut), J.retransmitPacketsOut !== void 0 && J.retransmitPacketsOut !== 0 && C.uint32(184).uint64(J.retransmitPacketsOut), J.retransmitBytesOutPerSec !== void 0 && J.retransmitBytesOutPerSec !== 0 && C.uint32(197).float(J.retransmitBytesOutPerSec), J.retransmitPacketsOutPerSec !== void 0 && J.retransmitPacketsOutPerSec !== 0 && C.uint32(205).float(J.retransmitPacketsOutPerSec), J.participantJoin !== void 0 && J.participantJoin !== 0 && C.uint32(208).uint64(J.participantJoin), J.participantJoinPerSec !== void 0 && J.participantJoinPerSec !== 0 && C.uint32(221).float(J.participantJoinPerSec), C;
    },
    decode(J, C) {
      const S = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let E = C === void 0 ? S.len : S.pos + C;
      const I = ae();
      for (; S.pos < E; ) {
        const M = S.uint32();
        switch (M >>> 3) {
          case 1:
            I.startedAt = be(S.int64());
            break;
          case 2:
            I.updatedAt = be(S.int64());
            break;
          case 3:
            I.numRooms = S.int32();
            break;
          case 4:
            I.numClients = S.int32();
            break;
          case 5:
            I.numTracksIn = S.int32();
            break;
          case 6:
            I.numTracksOut = S.int32();
            break;
          case 7:
            I.bytesIn = be(S.uint64());
            break;
          case 8:
            I.bytesOut = be(S.uint64());
            break;
          case 9:
            I.packetsIn = be(S.uint64());
            break;
          case 10:
            I.packetsOut = be(S.uint64());
            break;
          case 11:
            I.nackTotal = be(S.uint64());
            break;
          case 12:
            I.bytesInPerSec = S.float();
            break;
          case 13:
            I.bytesOutPerSec = S.float();
            break;
          case 14:
            I.packetsInPerSec = S.float();
            break;
          case 15:
            I.packetsOutPerSec = S.float();
            break;
          case 16:
            I.nackPerSec = S.float();
            break;
          case 17:
            I.numCpus = S.uint32();
            break;
          case 18:
            I.loadAvgLast1min = S.float();
            break;
          case 19:
            I.loadAvgLast5min = S.float();
            break;
          case 20:
            I.loadAvgLast15min = S.float();
            break;
          case 21:
            I.cpuLoad = S.float();
            break;
          case 33:
            I.memoryLoad = S.float();
            break;
          case 28:
            I.sysPacketsOut = S.uint32();
            break;
          case 29:
            I.sysPacketsDropped = S.uint32();
            break;
          case 30:
            I.sysPacketsOutPerSec = S.float();
            break;
          case 31:
            I.sysPacketsDroppedPerSec = S.float();
            break;
          case 32:
            I.sysPacketsDroppedPctPerSec = S.float();
            break;
          case 22:
            I.retransmitBytesOut = be(S.uint64());
            break;
          case 23:
            I.retransmitPacketsOut = be(S.uint64());
            break;
          case 24:
            I.retransmitBytesOutPerSec = S.float();
            break;
          case 25:
            I.retransmitPacketsOutPerSec = S.float();
            break;
          case 26:
            I.participantJoin = be(S.uint64());
            break;
          case 27:
            I.participantJoinPerSec = S.float();
            break;
          default:
            S.skipType(M & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(J) {
      return {
        startedAt: q(J.startedAt) ? Number(J.startedAt) : 0,
        updatedAt: q(J.updatedAt) ? Number(J.updatedAt) : 0,
        numRooms: q(J.numRooms) ? Number(J.numRooms) : 0,
        numClients: q(J.numClients) ? Number(J.numClients) : 0,
        numTracksIn: q(J.numTracksIn) ? Number(J.numTracksIn) : 0,
        numTracksOut: q(J.numTracksOut) ? Number(J.numTracksOut) : 0,
        bytesIn: q(J.bytesIn) ? Number(J.bytesIn) : 0,
        bytesOut: q(J.bytesOut) ? Number(J.bytesOut) : 0,
        packetsIn: q(J.packetsIn) ? Number(J.packetsIn) : 0,
        packetsOut: q(J.packetsOut) ? Number(J.packetsOut) : 0,
        nackTotal: q(J.nackTotal) ? Number(J.nackTotal) : 0,
        bytesInPerSec: q(J.bytesInPerSec) ? Number(J.bytesInPerSec) : 0,
        bytesOutPerSec: q(J.bytesOutPerSec) ? Number(J.bytesOutPerSec) : 0,
        packetsInPerSec: q(J.packetsInPerSec) ? Number(J.packetsInPerSec) : 0,
        packetsOutPerSec: q(J.packetsOutPerSec) ? Number(J.packetsOutPerSec) : 0,
        nackPerSec: q(J.nackPerSec) ? Number(J.nackPerSec) : 0,
        numCpus: q(J.numCpus) ? Number(J.numCpus) : 0,
        loadAvgLast1min: q(J.loadAvgLast1min) ? Number(J.loadAvgLast1min) : 0,
        loadAvgLast5min: q(J.loadAvgLast5min) ? Number(J.loadAvgLast5min) : 0,
        loadAvgLast15min: q(J.loadAvgLast15min) ? Number(J.loadAvgLast15min) : 0,
        cpuLoad: q(J.cpuLoad) ? Number(J.cpuLoad) : 0,
        memoryLoad: q(J.memoryLoad) ? Number(J.memoryLoad) : 0,
        sysPacketsOut: q(J.sysPacketsOut) ? Number(J.sysPacketsOut) : 0,
        sysPacketsDropped: q(J.sysPacketsDropped) ? Number(J.sysPacketsDropped) : 0,
        sysPacketsOutPerSec: q(J.sysPacketsOutPerSec) ? Number(J.sysPacketsOutPerSec) : 0,
        sysPacketsDroppedPerSec: q(J.sysPacketsDroppedPerSec) ? Number(J.sysPacketsDroppedPerSec) : 0,
        sysPacketsDroppedPctPerSec: q(J.sysPacketsDroppedPctPerSec) ? Number(J.sysPacketsDroppedPctPerSec) : 0,
        retransmitBytesOut: q(J.retransmitBytesOut) ? Number(J.retransmitBytesOut) : 0,
        retransmitPacketsOut: q(J.retransmitPacketsOut) ? Number(J.retransmitPacketsOut) : 0,
        retransmitBytesOutPerSec: q(J.retransmitBytesOutPerSec) ? Number(J.retransmitBytesOutPerSec) : 0,
        retransmitPacketsOutPerSec: q(J.retransmitPacketsOutPerSec) ? Number(J.retransmitPacketsOutPerSec) : 0,
        participantJoin: q(J.participantJoin) ? Number(J.participantJoin) : 0,
        participantJoinPerSec: q(J.participantJoinPerSec) ? Number(J.participantJoinPerSec) : 0
      };
    },
    toJSON(J) {
      const C = {};
      return J.startedAt !== void 0 && (C.startedAt = Math.round(J.startedAt)), J.updatedAt !== void 0 && (C.updatedAt = Math.round(J.updatedAt)), J.numRooms !== void 0 && (C.numRooms = Math.round(J.numRooms)), J.numClients !== void 0 && (C.numClients = Math.round(J.numClients)), J.numTracksIn !== void 0 && (C.numTracksIn = Math.round(J.numTracksIn)), J.numTracksOut !== void 0 && (C.numTracksOut = Math.round(J.numTracksOut)), J.bytesIn !== void 0 && (C.bytesIn = Math.round(J.bytesIn)), J.bytesOut !== void 0 && (C.bytesOut = Math.round(J.bytesOut)), J.packetsIn !== void 0 && (C.packetsIn = Math.round(J.packetsIn)), J.packetsOut !== void 0 && (C.packetsOut = Math.round(J.packetsOut)), J.nackTotal !== void 0 && (C.nackTotal = Math.round(J.nackTotal)), J.bytesInPerSec !== void 0 && (C.bytesInPerSec = J.bytesInPerSec), J.bytesOutPerSec !== void 0 && (C.bytesOutPerSec = J.bytesOutPerSec), J.packetsInPerSec !== void 0 && (C.packetsInPerSec = J.packetsInPerSec), J.packetsOutPerSec !== void 0 && (C.packetsOutPerSec = J.packetsOutPerSec), J.nackPerSec !== void 0 && (C.nackPerSec = J.nackPerSec), J.numCpus !== void 0 && (C.numCpus = Math.round(J.numCpus)), J.loadAvgLast1min !== void 0 && (C.loadAvgLast1min = J.loadAvgLast1min), J.loadAvgLast5min !== void 0 && (C.loadAvgLast5min = J.loadAvgLast5min), J.loadAvgLast15min !== void 0 && (C.loadAvgLast15min = J.loadAvgLast15min), J.cpuLoad !== void 0 && (C.cpuLoad = J.cpuLoad), J.memoryLoad !== void 0 && (C.memoryLoad = J.memoryLoad), J.sysPacketsOut !== void 0 && (C.sysPacketsOut = Math.round(J.sysPacketsOut)), J.sysPacketsDropped !== void 0 && (C.sysPacketsDropped = Math.round(J.sysPacketsDropped)), J.sysPacketsOutPerSec !== void 0 && (C.sysPacketsOutPerSec = J.sysPacketsOutPerSec), J.sysPacketsDroppedPerSec !== void 0 && (C.sysPacketsDroppedPerSec = J.sysPacketsDroppedPerSec), J.sysPacketsDroppedPctPerSec !== void 0 && (C.sysPacketsDroppedPctPerSec = J.sysPacketsDroppedPctPerSec), J.retransmitBytesOut !== void 0 && (C.retransmitBytesOut = Math.round(J.retransmitBytesOut)), J.retransmitPacketsOut !== void 0 && (C.retransmitPacketsOut = Math.round(J.retransmitPacketsOut)), J.retransmitBytesOutPerSec !== void 0 && (C.retransmitBytesOutPerSec = J.retransmitBytesOutPerSec), J.retransmitPacketsOutPerSec !== void 0 && (C.retransmitPacketsOutPerSec = J.retransmitPacketsOutPerSec), J.participantJoin !== void 0 && (C.participantJoin = Math.round(J.participantJoin)), J.participantJoinPerSec !== void 0 && (C.participantJoinPerSec = J.participantJoinPerSec), C;
    },
    fromPartial(J) {
      var C, S, E, I, M, $, U, Y, L, T, B, te, pe, Ie, $e, ve, he, Oe, Ae, Ue, oe, A, re, le, Ne, Pe, Fe, je, qe, yt, Xe, Ge, H;
      const ye = ae();
      return ye.startedAt = (C = J.startedAt) !== null && C !== void 0 ? C : 0, ye.updatedAt = (S = J.updatedAt) !== null && S !== void 0 ? S : 0, ye.numRooms = (E = J.numRooms) !== null && E !== void 0 ? E : 0, ye.numClients = (I = J.numClients) !== null && I !== void 0 ? I : 0, ye.numTracksIn = (M = J.numTracksIn) !== null && M !== void 0 ? M : 0, ye.numTracksOut = ($ = J.numTracksOut) !== null && $ !== void 0 ? $ : 0, ye.bytesIn = (U = J.bytesIn) !== null && U !== void 0 ? U : 0, ye.bytesOut = (Y = J.bytesOut) !== null && Y !== void 0 ? Y : 0, ye.packetsIn = (L = J.packetsIn) !== null && L !== void 0 ? L : 0, ye.packetsOut = (T = J.packetsOut) !== null && T !== void 0 ? T : 0, ye.nackTotal = (B = J.nackTotal) !== null && B !== void 0 ? B : 0, ye.bytesInPerSec = (te = J.bytesInPerSec) !== null && te !== void 0 ? te : 0, ye.bytesOutPerSec = (pe = J.bytesOutPerSec) !== null && pe !== void 0 ? pe : 0, ye.packetsInPerSec = (Ie = J.packetsInPerSec) !== null && Ie !== void 0 ? Ie : 0, ye.packetsOutPerSec = ($e = J.packetsOutPerSec) !== null && $e !== void 0 ? $e : 0, ye.nackPerSec = (ve = J.nackPerSec) !== null && ve !== void 0 ? ve : 0, ye.numCpus = (he = J.numCpus) !== null && he !== void 0 ? he : 0, ye.loadAvgLast1min = (Oe = J.loadAvgLast1min) !== null && Oe !== void 0 ? Oe : 0, ye.loadAvgLast5min = (Ae = J.loadAvgLast5min) !== null && Ae !== void 0 ? Ae : 0, ye.loadAvgLast15min = (Ue = J.loadAvgLast15min) !== null && Ue !== void 0 ? Ue : 0, ye.cpuLoad = (oe = J.cpuLoad) !== null && oe !== void 0 ? oe : 0, ye.memoryLoad = (A = J.memoryLoad) !== null && A !== void 0 ? A : 0, ye.sysPacketsOut = (re = J.sysPacketsOut) !== null && re !== void 0 ? re : 0, ye.sysPacketsDropped = (le = J.sysPacketsDropped) !== null && le !== void 0 ? le : 0, ye.sysPacketsOutPerSec = (Ne = J.sysPacketsOutPerSec) !== null && Ne !== void 0 ? Ne : 0, ye.sysPacketsDroppedPerSec = (Pe = J.sysPacketsDroppedPerSec) !== null && Pe !== void 0 ? Pe : 0, ye.sysPacketsDroppedPctPerSec = (Fe = J.sysPacketsDroppedPctPerSec) !== null && Fe !== void 0 ? Fe : 0, ye.retransmitBytesOut = (je = J.retransmitBytesOut) !== null && je !== void 0 ? je : 0, ye.retransmitPacketsOut = (qe = J.retransmitPacketsOut) !== null && qe !== void 0 ? qe : 0, ye.retransmitBytesOutPerSec = (yt = J.retransmitBytesOutPerSec) !== null && yt !== void 0 ? yt : 0, ye.retransmitPacketsOutPerSec = (Xe = J.retransmitPacketsOutPerSec) !== null && Xe !== void 0 ? Xe : 0, ye.participantJoin = (Ge = J.participantJoin) !== null && Ge !== void 0 ? Ge : 0, ye.participantJoinPerSec = (H = J.participantJoinPerSec) !== null && H !== void 0 ? H : 0, ye;
    }
  };
  function Q() {
    return {
      participantKey: "",
      senderTime: 0,
      connectionId: "",
      startSession: void 0,
      request: void 0,
      removeParticipant: void 0,
      muteTrack: void 0,
      updateParticipant: void 0,
      deleteRoom: void 0,
      updateSubscriptions: void 0,
      sendData: void 0,
      updateRoomMetadata: void 0,
      keepAlive: void 0
    };
  }
  a.RTCNodeMessage = {
    encode(J, C = l.default.Writer.create()) {
      return J.participantKey !== void 0 && J.participantKey !== "" && C.uint32(10).string(J.participantKey), J.senderTime !== void 0 && J.senderTime !== 0 && C.uint32(88).int64(J.senderTime), J.connectionId !== void 0 && J.connectionId !== "" && C.uint32(106).string(J.connectionId), J.startSession !== void 0 && a.StartSession.encode(J.startSession, C.uint32(18).fork()).ldelim(), J.request !== void 0 && k.SignalRequest.encode(J.request, C.uint32(26).fork()).ldelim(), J.removeParticipant !== void 0 && _.RoomParticipantIdentity.encode(J.removeParticipant, C.uint32(34).fork()).ldelim(), J.muteTrack !== void 0 && _.MuteRoomTrackRequest.encode(J.muteTrack, C.uint32(42).fork()).ldelim(), J.updateParticipant !== void 0 && _.UpdateParticipantRequest.encode(J.updateParticipant, C.uint32(50).fork()).ldelim(), J.deleteRoom !== void 0 && _.DeleteRoomRequest.encode(J.deleteRoom, C.uint32(58).fork()).ldelim(), J.updateSubscriptions !== void 0 && _.UpdateSubscriptionsRequest.encode(J.updateSubscriptions, C.uint32(66).fork()).ldelim(), J.sendData !== void 0 && _.SendDataRequest.encode(J.sendData, C.uint32(74).fork()).ldelim(), J.updateRoomMetadata !== void 0 && _.UpdateRoomMetadataRequest.encode(J.updateRoomMetadata, C.uint32(82).fork()).ldelim(), J.keepAlive !== void 0 && a.KeepAlive.encode(J.keepAlive, C.uint32(98).fork()).ldelim(), C;
    },
    decode(J, C) {
      const S = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let E = C === void 0 ? S.len : S.pos + C;
      const I = Q();
      for (; S.pos < E; ) {
        const M = S.uint32();
        switch (M >>> 3) {
          case 1:
            I.participantKey = S.string();
            break;
          case 11:
            I.senderTime = be(S.int64());
            break;
          case 13:
            I.connectionId = S.string();
            break;
          case 2:
            I.startSession = a.StartSession.decode(S, S.uint32());
            break;
          case 3:
            I.request = k.SignalRequest.decode(S, S.uint32());
            break;
          case 4:
            I.removeParticipant = _.RoomParticipantIdentity.decode(S, S.uint32());
            break;
          case 5:
            I.muteTrack = _.MuteRoomTrackRequest.decode(S, S.uint32());
            break;
          case 6:
            I.updateParticipant = _.UpdateParticipantRequest.decode(S, S.uint32());
            break;
          case 7:
            I.deleteRoom = _.DeleteRoomRequest.decode(S, S.uint32());
            break;
          case 8:
            I.updateSubscriptions = _.UpdateSubscriptionsRequest.decode(S, S.uint32());
            break;
          case 9:
            I.sendData = _.SendDataRequest.decode(S, S.uint32());
            break;
          case 10:
            I.updateRoomMetadata = _.UpdateRoomMetadataRequest.decode(S, S.uint32());
            break;
          case 12:
            I.keepAlive = a.KeepAlive.decode(S, S.uint32());
            break;
          default:
            S.skipType(M & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(J) {
      return {
        participantKey: q(J.participantKey) ? String(J.participantKey) : "",
        senderTime: q(J.senderTime) ? Number(J.senderTime) : 0,
        connectionId: q(J.connectionId) ? String(J.connectionId) : "",
        startSession: q(J.startSession) ? a.StartSession.fromJSON(J.startSession) : void 0,
        request: q(J.request) ? k.SignalRequest.fromJSON(J.request) : void 0,
        removeParticipant: q(J.removeParticipant) ? _.RoomParticipantIdentity.fromJSON(J.removeParticipant) : void 0,
        muteTrack: q(J.muteTrack) ? _.MuteRoomTrackRequest.fromJSON(J.muteTrack) : void 0,
        updateParticipant: q(J.updateParticipant) ? _.UpdateParticipantRequest.fromJSON(J.updateParticipant) : void 0,
        deleteRoom: q(J.deleteRoom) ? _.DeleteRoomRequest.fromJSON(J.deleteRoom) : void 0,
        updateSubscriptions: q(J.updateSubscriptions) ? _.UpdateSubscriptionsRequest.fromJSON(J.updateSubscriptions) : void 0,
        sendData: q(J.sendData) ? _.SendDataRequest.fromJSON(J.sendData) : void 0,
        updateRoomMetadata: q(J.updateRoomMetadata) ? _.UpdateRoomMetadataRequest.fromJSON(J.updateRoomMetadata) : void 0,
        keepAlive: q(J.keepAlive) ? a.KeepAlive.fromJSON(J.keepAlive) : void 0
      };
    },
    toJSON(J) {
      const C = {};
      return J.participantKey !== void 0 && (C.participantKey = J.participantKey), J.senderTime !== void 0 && (C.senderTime = Math.round(J.senderTime)), J.connectionId !== void 0 && (C.connectionId = J.connectionId), J.startSession !== void 0 && (C.startSession = J.startSession ? a.StartSession.toJSON(J.startSession) : void 0), J.request !== void 0 && (C.request = J.request ? k.SignalRequest.toJSON(J.request) : void 0), J.removeParticipant !== void 0 && (C.removeParticipant = J.removeParticipant ? _.RoomParticipantIdentity.toJSON(J.removeParticipant) : void 0), J.muteTrack !== void 0 && (C.muteTrack = J.muteTrack ? _.MuteRoomTrackRequest.toJSON(J.muteTrack) : void 0), J.updateParticipant !== void 0 && (C.updateParticipant = J.updateParticipant ? _.UpdateParticipantRequest.toJSON(J.updateParticipant) : void 0), J.deleteRoom !== void 0 && (C.deleteRoom = J.deleteRoom ? _.DeleteRoomRequest.toJSON(J.deleteRoom) : void 0), J.updateSubscriptions !== void 0 && (C.updateSubscriptions = J.updateSubscriptions ? _.UpdateSubscriptionsRequest.toJSON(J.updateSubscriptions) : void 0), J.sendData !== void 0 && (C.sendData = J.sendData ? _.SendDataRequest.toJSON(J.sendData) : void 0), J.updateRoomMetadata !== void 0 && (C.updateRoomMetadata = J.updateRoomMetadata ? _.UpdateRoomMetadataRequest.toJSON(J.updateRoomMetadata) : void 0), J.keepAlive !== void 0 && (C.keepAlive = J.keepAlive ? a.KeepAlive.toJSON(J.keepAlive) : void 0), C;
    },
    fromPartial(J) {
      var C, S, E;
      const I = Q();
      return I.participantKey = (C = J.participantKey) !== null && C !== void 0 ? C : "", I.senderTime = (S = J.senderTime) !== null && S !== void 0 ? S : 0, I.connectionId = (E = J.connectionId) !== null && E !== void 0 ? E : "", I.startSession = J.startSession !== void 0 && J.startSession !== null ? a.StartSession.fromPartial(J.startSession) : void 0, I.request = J.request !== void 0 && J.request !== null ? k.SignalRequest.fromPartial(J.request) : void 0, I.removeParticipant = J.removeParticipant !== void 0 && J.removeParticipant !== null ? _.RoomParticipantIdentity.fromPartial(J.removeParticipant) : void 0, I.muteTrack = J.muteTrack !== void 0 && J.muteTrack !== null ? _.MuteRoomTrackRequest.fromPartial(J.muteTrack) : void 0, I.updateParticipant = J.updateParticipant !== void 0 && J.updateParticipant !== null ? _.UpdateParticipantRequest.fromPartial(J.updateParticipant) : void 0, I.deleteRoom = J.deleteRoom !== void 0 && J.deleteRoom !== null ? _.DeleteRoomRequest.fromPartial(J.deleteRoom) : void 0, I.updateSubscriptions = J.updateSubscriptions !== void 0 && J.updateSubscriptions !== null ? _.UpdateSubscriptionsRequest.fromPartial(J.updateSubscriptions) : void 0, I.sendData = J.sendData !== void 0 && J.sendData !== null ? _.SendDataRequest.fromPartial(J.sendData) : void 0, I.updateRoomMetadata = J.updateRoomMetadata !== void 0 && J.updateRoomMetadata !== null ? _.UpdateRoomMetadataRequest.fromPartial(J.updateRoomMetadata) : void 0, I.keepAlive = J.keepAlive !== void 0 && J.keepAlive !== null ? a.KeepAlive.fromPartial(J.keepAlive) : void 0, I;
    }
  };
  function ne() {
    return { connectionId: "", response: void 0, endSession: void 0 };
  }
  a.SignalNodeMessage = {
    encode(J, C = l.default.Writer.create()) {
      return J.connectionId !== void 0 && J.connectionId !== "" && C.uint32(10).string(J.connectionId), J.response !== void 0 && k.SignalResponse.encode(J.response, C.uint32(18).fork()).ldelim(), J.endSession !== void 0 && a.EndSession.encode(J.endSession, C.uint32(26).fork()).ldelim(), C;
    },
    decode(J, C) {
      const S = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let E = C === void 0 ? S.len : S.pos + C;
      const I = ne();
      for (; S.pos < E; ) {
        const M = S.uint32();
        switch (M >>> 3) {
          case 1:
            I.connectionId = S.string();
            break;
          case 2:
            I.response = k.SignalResponse.decode(S, S.uint32());
            break;
          case 3:
            I.endSession = a.EndSession.decode(S, S.uint32());
            break;
          default:
            S.skipType(M & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(J) {
      return {
        connectionId: q(J.connectionId) ? String(J.connectionId) : "",
        response: q(J.response) ? k.SignalResponse.fromJSON(J.response) : void 0,
        endSession: q(J.endSession) ? a.EndSession.fromJSON(J.endSession) : void 0
      };
    },
    toJSON(J) {
      const C = {};
      return J.connectionId !== void 0 && (C.connectionId = J.connectionId), J.response !== void 0 && (C.response = J.response ? k.SignalResponse.toJSON(J.response) : void 0), J.endSession !== void 0 && (C.endSession = J.endSession ? a.EndSession.toJSON(J.endSession) : void 0), C;
    },
    fromPartial(J) {
      var C;
      const S = ne();
      return S.connectionId = (C = J.connectionId) !== null && C !== void 0 ? C : "", S.response = J.response !== void 0 && J.response !== null ? k.SignalResponse.fromPartial(J.response) : void 0, S.endSession = J.endSession !== void 0 && J.endSession !== null ? a.EndSession.fromPartial(J.endSession) : void 0, S;
    }
  };
  function Z() {
    return {
      roomName: "",
      identity: "",
      connectionId: "",
      reconnect: !1,
      autoSubscribe: !1,
      hidden: !1,
      client: void 0,
      recorder: !1,
      name: "",
      grantsJson: "",
      adaptiveStream: !1,
      participantId: ""
    };
  }
  a.StartSession = {
    encode(J, C = l.default.Writer.create()) {
      return J.roomName !== void 0 && J.roomName !== "" && C.uint32(10).string(J.roomName), J.identity !== void 0 && J.identity !== "" && C.uint32(18).string(J.identity), J.connectionId !== void 0 && J.connectionId !== "" && C.uint32(26).string(J.connectionId), J.reconnect === !0 && C.uint32(32).bool(J.reconnect), J.autoSubscribe === !0 && C.uint32(72).bool(J.autoSubscribe), J.hidden === !0 && C.uint32(80).bool(J.hidden), J.client !== void 0 && p.ClientInfo.encode(J.client, C.uint32(90).fork()).ldelim(), J.recorder === !0 && C.uint32(96).bool(J.recorder), J.name !== void 0 && J.name !== "" && C.uint32(106).string(J.name), J.grantsJson !== void 0 && J.grantsJson !== "" && C.uint32(114).string(J.grantsJson), J.adaptiveStream === !0 && C.uint32(120).bool(J.adaptiveStream), J.participantId !== void 0 && J.participantId !== "" && C.uint32(130).string(J.participantId), C;
    },
    decode(J, C) {
      const S = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let E = C === void 0 ? S.len : S.pos + C;
      const I = Z();
      for (; S.pos < E; ) {
        const M = S.uint32();
        switch (M >>> 3) {
          case 1:
            I.roomName = S.string();
            break;
          case 2:
            I.identity = S.string();
            break;
          case 3:
            I.connectionId = S.string();
            break;
          case 4:
            I.reconnect = S.bool();
            break;
          case 9:
            I.autoSubscribe = S.bool();
            break;
          case 10:
            I.hidden = S.bool();
            break;
          case 11:
            I.client = p.ClientInfo.decode(S, S.uint32());
            break;
          case 12:
            I.recorder = S.bool();
            break;
          case 13:
            I.name = S.string();
            break;
          case 14:
            I.grantsJson = S.string();
            break;
          case 15:
            I.adaptiveStream = S.bool();
            break;
          case 16:
            I.participantId = S.string();
            break;
          default:
            S.skipType(M & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(J) {
      return {
        roomName: q(J.roomName) ? String(J.roomName) : "",
        identity: q(J.identity) ? String(J.identity) : "",
        connectionId: q(J.connectionId) ? String(J.connectionId) : "",
        reconnect: q(J.reconnect) ? !!J.reconnect : !1,
        autoSubscribe: q(J.autoSubscribe) ? !!J.autoSubscribe : !1,
        hidden: q(J.hidden) ? !!J.hidden : !1,
        client: q(J.client) ? p.ClientInfo.fromJSON(J.client) : void 0,
        recorder: q(J.recorder) ? !!J.recorder : !1,
        name: q(J.name) ? String(J.name) : "",
        grantsJson: q(J.grantsJson) ? String(J.grantsJson) : "",
        adaptiveStream: q(J.adaptiveStream) ? !!J.adaptiveStream : !1,
        participantId: q(J.participantId) ? String(J.participantId) : ""
      };
    },
    toJSON(J) {
      const C = {};
      return J.roomName !== void 0 && (C.roomName = J.roomName), J.identity !== void 0 && (C.identity = J.identity), J.connectionId !== void 0 && (C.connectionId = J.connectionId), J.reconnect !== void 0 && (C.reconnect = J.reconnect), J.autoSubscribe !== void 0 && (C.autoSubscribe = J.autoSubscribe), J.hidden !== void 0 && (C.hidden = J.hidden), J.client !== void 0 && (C.client = J.client ? p.ClientInfo.toJSON(J.client) : void 0), J.recorder !== void 0 && (C.recorder = J.recorder), J.name !== void 0 && (C.name = J.name), J.grantsJson !== void 0 && (C.grantsJson = J.grantsJson), J.adaptiveStream !== void 0 && (C.adaptiveStream = J.adaptiveStream), J.participantId !== void 0 && (C.participantId = J.participantId), C;
    },
    fromPartial(J) {
      var C, S, E, I, M, $, U, Y, L, T, B;
      const te = Z();
      return te.roomName = (C = J.roomName) !== null && C !== void 0 ? C : "", te.identity = (S = J.identity) !== null && S !== void 0 ? S : "", te.connectionId = (E = J.connectionId) !== null && E !== void 0 ? E : "", te.reconnect = (I = J.reconnect) !== null && I !== void 0 ? I : !1, te.autoSubscribe = (M = J.autoSubscribe) !== null && M !== void 0 ? M : !1, te.hidden = ($ = J.hidden) !== null && $ !== void 0 ? $ : !1, te.client = J.client !== void 0 && J.client !== null ? p.ClientInfo.fromPartial(J.client) : void 0, te.recorder = (U = J.recorder) !== null && U !== void 0 ? U : !1, te.name = (Y = J.name) !== null && Y !== void 0 ? Y : "", te.grantsJson = (L = J.grantsJson) !== null && L !== void 0 ? L : "", te.adaptiveStream = (T = J.adaptiveStream) !== null && T !== void 0 ? T : !1, te.participantId = (B = J.participantId) !== null && B !== void 0 ? B : "", te;
    }
  };
  function de() {
    return {};
  }
  a.EndSession = {
    encode(J, C = l.default.Writer.create()) {
      return C;
    },
    decode(J, C) {
      const S = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let E = C === void 0 ? S.len : S.pos + C;
      const I = de();
      for (; S.pos < E; ) {
        const M = S.uint32();
        switch (M >>> 3) {
          default:
            S.skipType(M & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(J) {
      return {};
    },
    toJSON(J) {
      return {};
    },
    fromPartial(J) {
      return de();
    }
  };
  function fe() {
    return { participantId: "" };
  }
  a.RemoveParticipant = {
    encode(J, C = l.default.Writer.create()) {
      return J.participantId !== void 0 && J.participantId !== "" && C.uint32(10).string(J.participantId), C;
    },
    decode(J, C) {
      const S = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let E = C === void 0 ? S.len : S.pos + C;
      const I = fe();
      for (; S.pos < E; ) {
        const M = S.uint32();
        switch (M >>> 3) {
          case 1:
            I.participantId = S.string();
            break;
          default:
            S.skipType(M & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(J) {
      return { participantId: q(J.participantId) ? String(J.participantId) : "" };
    },
    toJSON(J) {
      const C = {};
      return J.participantId !== void 0 && (C.participantId = J.participantId), C;
    },
    fromPartial(J) {
      var C;
      const S = fe();
      return S.participantId = (C = J.participantId) !== null && C !== void 0 ? C : "", S;
    }
  };
  function Te() {
    return {};
  }
  a.KeepAlive = {
    encode(J, C = l.default.Writer.create()) {
      return C;
    },
    decode(J, C) {
      const S = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let E = C === void 0 ? S.len : S.pos + C;
      const I = Te();
      for (; S.pos < E; ) {
        const M = S.uint32();
        switch (M >>> 3) {
          default:
            S.skipType(M & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(J) {
      return {};
    },
    toJSON(J) {
      return {};
    },
    fromPartial(J) {
      return Te();
    }
  };
  function Re() {
    return { trackEgress: void 0 };
  }
  a.RoomInternal = {
    encode(J, C = l.default.Writer.create()) {
      return J.trackEgress !== void 0 && v.AutoTrackEgress.encode(J.trackEgress, C.uint32(10).fork()).ldelim(), C;
    },
    decode(J, C) {
      const S = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let E = C === void 0 ? S.len : S.pos + C;
      const I = Re();
      for (; S.pos < E; ) {
        const M = S.uint32();
        switch (M >>> 3) {
          case 1:
            I.trackEgress = v.AutoTrackEgress.decode(S, S.uint32());
            break;
          default:
            S.skipType(M & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(J) {
      return { trackEgress: q(J.trackEgress) ? v.AutoTrackEgress.fromJSON(J.trackEgress) : void 0 };
    },
    toJSON(J) {
      const C = {};
      return J.trackEgress !== void 0 && (C.trackEgress = J.trackEgress ? v.AutoTrackEgress.toJSON(J.trackEgress) : void 0), C;
    },
    fromPartial(J) {
      const C = Re();
      return C.trackEgress = J.trackEgress !== void 0 && J.trackEgress !== null ? v.AutoTrackEgress.fromPartial(J.trackEgress) : void 0, C;
    }
  };
  var Le = (() => {
    if (typeof Le < "u")
      return Le;
    if (typeof self < "u")
      return self;
    if (typeof window < "u")
      return window;
    if (typeof commonjsGlobal$1 < "u")
      return commonjsGlobal$1;
    throw "Unable to locate global object";
  })();
  function be(J) {
    if (J.gt(Number.MAX_SAFE_INTEGER))
      throw new Le.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    return J.toNumber();
  }
  l.default.util.Long !== c.default && (l.default.util.Long = c.default, l.default.configure());
  function q(J) {
    return J != null;
  }
})(livekit_internal);
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(O, D, F, z) {
    z === void 0 && (z = F), Object.defineProperty(O, z, { enumerable: !0, get: function() {
      return D[F];
    } });
  } : function(O, D, F, z) {
    z === void 0 && (z = F), O[z] = D[F];
  }), c = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(O, D) {
    Object.defineProperty(O, "default", { enumerable: !0, value: D });
  } : function(O, D) {
    O.default = D;
  }), l = commonjsGlobal$1 && commonjsGlobal$1.__exportStar || function(O, D) {
    for (var F in O)
      F !== "default" && !Object.prototype.hasOwnProperty.call(D, F) && u(D, O, F);
  }, v = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(O) {
    if (O && O.__esModule)
      return O;
    var D = {};
    if (O != null)
      for (var F in O)
        F !== "default" && Object.prototype.hasOwnProperty.call(O, F) && u(D, O, F);
    return c(D, O), D;
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.LivekitInternal = a.TrackType = a.TrackInfo = a.Room = a.ParticipantPermission = a.ParticipantInfo_State = a.ParticipantInfo = a.DataPacket_Kind = a.IngressVideoOptions = a.IngressState = a.IngressInput = a.IngressInfo = a.IngressAudioOptions = a.StreamProtocol = a.StreamOutput = a.SegmentedFileProtocol = a.SegmentedFileOutput = a.EncodingOptionsPreset = a.EncodingOptions = a.EncodedFileType = a.EncodedFileOutput = a.EgressInfo = a.DirectFileOutput = void 0, l(AccessToken$1, a), l(EgressClient$1, a), l(grants, a), l(IngressClient$1, a);
  var p = livekit_egress;
  Object.defineProperty(a, "DirectFileOutput", { enumerable: !0, get: function() {
    return p.DirectFileOutput;
  } }), Object.defineProperty(a, "EgressInfo", { enumerable: !0, get: function() {
    return p.EgressInfo;
  } }), Object.defineProperty(a, "EncodedFileOutput", { enumerable: !0, get: function() {
    return p.EncodedFileOutput;
  } }), Object.defineProperty(a, "EncodedFileType", { enumerable: !0, get: function() {
    return p.EncodedFileType;
  } }), Object.defineProperty(a, "EncodingOptions", { enumerable: !0, get: function() {
    return p.EncodingOptions;
  } }), Object.defineProperty(a, "EncodingOptionsPreset", { enumerable: !0, get: function() {
    return p.EncodingOptionsPreset;
  } }), Object.defineProperty(a, "SegmentedFileOutput", { enumerable: !0, get: function() {
    return p.SegmentedFileOutput;
  } }), Object.defineProperty(a, "SegmentedFileProtocol", { enumerable: !0, get: function() {
    return p.SegmentedFileProtocol;
  } }), Object.defineProperty(a, "StreamOutput", { enumerable: !0, get: function() {
    return p.StreamOutput;
  } }), Object.defineProperty(a, "StreamProtocol", { enumerable: !0, get: function() {
    return p.StreamProtocol;
  } });
  var _ = livekit_ingress;
  Object.defineProperty(a, "IngressAudioOptions", { enumerable: !0, get: function() {
    return _.IngressAudioOptions;
  } }), Object.defineProperty(a, "IngressInfo", { enumerable: !0, get: function() {
    return _.IngressInfo;
  } }), Object.defineProperty(a, "IngressInput", { enumerable: !0, get: function() {
    return _.IngressInput;
  } }), Object.defineProperty(a, "IngressState", { enumerable: !0, get: function() {
    return _.IngressState;
  } }), Object.defineProperty(a, "IngressVideoOptions", { enumerable: !0, get: function() {
    return _.IngressVideoOptions;
  } });
  var k = livekit_models;
  Object.defineProperty(a, "DataPacket_Kind", { enumerable: !0, get: function() {
    return k.DataPacket_Kind;
  } }), Object.defineProperty(a, "ParticipantInfo", { enumerable: !0, get: function() {
    return k.ParticipantInfo;
  } }), Object.defineProperty(a, "ParticipantInfo_State", { enumerable: !0, get: function() {
    return k.ParticipantInfo_State;
  } }), Object.defineProperty(a, "ParticipantPermission", { enumerable: !0, get: function() {
    return k.ParticipantPermission;
  } }), Object.defineProperty(a, "Room", { enumerable: !0, get: function() {
    return k.Room;
  } }), Object.defineProperty(a, "TrackInfo", { enumerable: !0, get: function() {
    return k.TrackInfo;
  } }), Object.defineProperty(a, "TrackType", { enumerable: !0, get: function() {
    return k.TrackType;
  } }), l(RoomServiceClient$1, a), l(WebhookReceiver$1, a), a.LivekitInternal = v(livekit_internal);
})(dist);
class InvalidTokenError extends Error {
}
InvalidTokenError.prototype.name = "InvalidTokenError";
function b64DecodeUnicode(a) {
  return decodeURIComponent(atob(a).replace(/(.)/g, (u, c) => {
    let l = c.charCodeAt(0).toString(16).toUpperCase();
    return l.length < 2 && (l = "0" + l), "%" + l;
  }));
}
function base64UrlDecode(a) {
  let u = a.replace(/-/g, "+").replace(/_/g, "/");
  switch (u.length % 4) {
    case 0:
      break;
    case 2:
      u += "==";
      break;
    case 3:
      u += "=";
      break;
    default:
      throw new Error("base64 string is not of the correct length");
  }
  try {
    return b64DecodeUnicode(u);
  } catch {
    return atob(u);
  }
}
function jwtDecode(a, u) {
  if (typeof a != "string")
    throw new InvalidTokenError("Invalid token specified: must be a string");
  u || (u = {});
  const c = u.header === !0 ? 0 : 1, l = a.split(".")[c];
  if (typeof l != "string")
    throw new InvalidTokenError(`Invalid token specified: missing part #${c + 1}`);
  let v;
  try {
    v = base64UrlDecode(l);
  } catch (p) {
    throw new InvalidTokenError(`Invalid token specified: invalid base64 for part #${c + 1} (${p.message})`);
  }
  try {
    return JSON.parse(v);
  } catch (p) {
    throw new InvalidTokenError(`Invalid token specified: invalid json for part #${c + 1} (${p.message})`);
  }
}
var DataType = /* @__PURE__ */ ((a) => (a.ChatMessage = "ChatMessage", a.ParticipantMetadataUpdate = "ParticipantMetadataUpdate", a))(DataType || {}), SpecialEvent = /* @__PURE__ */ ((a) => (a.Chat = "Chat", a))(SpecialEvent || {});
const decoder$1 = new TextDecoder(), encoder$1 = new TextEncoder();
class RoomsManager {
  constructor() {
    Ft(this, "rooms");
    this.rooms = /* @__PURE__ */ new Map(), this.addRoom = this.addRoom.bind(this), this.ensureRoom = this.ensureRoom.bind(this), this.removeRoom = this.removeRoom.bind(this);
  }
  addRoom(u, c, l) {
    const v = new RoomContext(u, c, l, this);
    return this.rooms.set(c, v), v;
  }
  ensureRoom(u, c, l) {
    return this.rooms.get(c) ? (this.rooms.get(c).token = l, this.rooms.get(c)) : this.addRoom(u, c, l);
  }
  async removeRoom(u) {
    const c = this.rooms.get(u);
    if (!Room)
      throw new Error("room not found!");
    if (c.isConnecting)
      throw new Error("Cannot remove room: Room is in connecting state");
    c.livekitRoom && await c.livekitRoom.disconnect(!0), this.rooms.delete(u);
  }
}
class RoomContext {
  /**
   * @param baseUrl base url for the webrtc server
   * @param token get
   */
  constructor(u, c, l, v) {
    /**
     * base URL for the webrtc server
     */
    Ft(this, "_baseUrl");
    Ft(this, "_chatHistory");
    /**
     * event listeners just for livekit room connect
     */
    Ft(this, "_connectListeners");
    /**
     * Event listeners that are registered OR to be registered upon connection
     * Keys are of type RoomEvent
     */
    Ft(this, "_roomEventListenerRegistry");
    /**
     * Event listeners that are registered OR to be registered on the localParticipant upon connection
     * Keys are of type ParticipantEvent
     */
    Ft(this, "_localParticipantEventListenerRegistry");
    /**
     * Registry for special/custom events such as chat events
     */
    Ft(this, "_specialEventListenerRegistry");
    /**
     * access token for our connection
     * Should be acquired from vapi
     */
    Ft(this, "_jwt");
    /**
     * reference to the rooms manager that contains it
     */
    Ft(this, "_manager");
    Ft(this, "_apiClient");
    Ft(this, "audioTracks");
    Ft(this, "isConnecting");
    Ft(this, "livekitRoom");
    Ft(this, "participants");
    Ft(this, "guestParticipantMetadata");
    Ft(this, "roomName");
    /**
     * Livekit Room Service client, for performing admin functions
     * Should only be defined if user is room admin
     */
    Ft(this, "_admin");
    let p = CoreContext.logLevel.toLowerCase();
    setLogLevel(p), this.livekitRoom = new Room({
      // automatically manage subscribed video quality
      // adaptiveStream: true,
      // optimize publishing bandwidth and CPU for published tracks
      dynacast: !0,
      // default capture settings
      videoCaptureDefaults: {
        resolution: VideoPresets.h720.resolution
      }
    }), this._baseUrl = u, this._connectListeners = [], this._roomEventListenerRegistry = {}, this._jwt = l, Object.values(RoomEvent).forEach((_) => {
      this._roomEventListenerRegistry[_] = /* @__PURE__ */ new Set();
    }), this._localParticipantEventListenerRegistry = {}, Object.values(ParticipantEvent).forEach((_) => {
      this._localParticipantEventListenerRegistry[_] = /* @__PURE__ */ new Set();
    }), this._specialEventListenerRegistry = {}, this._manager = v, this._chatHistory = [], this.roomName = c, this.audioTracks = [], this.participants = [], this.guestParticipantMetadata = [], this.isConnecting = !1, this.subscribeToRoomEvent(RoomEvent.DataReceived, (_, k) => {
      var F;
      const O = decoder$1.decode(_);
      switch (JSON.parse(O).type) {
        case "ChatMessage":
          return this._appendChat(_, k);
        case "ParticipantMetadataUpdate": {
          const z = decoder$1.decode(_), j = JSON.parse(z);
          hasPermission((F = j == null ? void 0 : j.metadata) == null ? void 0 : F.participantRole, Permission.ManageSelf) && this._updateGuestParticipantsStore(j);
          return;
        }
        default:
          return;
      }
    }), this.connect = this.connect.bind(this), this.subscribeToRoomEvent = this.subscribeToRoomEvent.bind(this), this.subscribeToConnect = this.subscribeToConnect.bind(this), this.subscribeToLocalParticipantEvent = this.subscribeToLocalParticipantEvent.bind(this), this.subscribeToSpecialEvent = this.subscribeToSpecialEvent.bind(this), this.unsubscribeFromRoomEvent = this.unsubscribeFromRoomEvent.bind(this), this.unsubscribeFromSpecialEvent = this.unsubscribeFromSpecialEvent.bind(this), this.unsubscribeFromConnect = this.unsubscribeFromConnect.bind(this), this.unsubscribeFromLocalParticipantEvent = this.unsubscribeFromLocalParticipantEvent.bind(this), this.sendChatMessage = this.sendChatMessage.bind(this), this.kickParticipant = this.kickParticipant.bind(this), this.updateParticipant = this.updateParticipant.bind(this), this.muteTrackAsAdmin = this.muteTrackAsAdmin.bind(this), this._updateParticipants = this._updateParticipants.bind(this), this.subscribeToRoomEvent(RoomEvent.ParticipantConnected, this._updateParticipants), this.subscribeToRoomEvent(RoomEvent.ParticipantDisconnected, this._updateParticipants), this.subscribeToRoomEvent(RoomEvent.TrackSubscribed, this._updateParticipants), this.subscribeToRoomEvent(RoomEvent.TrackUnsubscribed, this._updateParticipants), this.subscribeToRoomEvent(RoomEvent.LocalTrackPublished, this._updateParticipants), this.subscribeToRoomEvent(RoomEvent.LocalTrackUnpublished, this._updateParticipants), this.subscribeToRoomEvent(RoomEvent.Disconnected, () => {
      this._updateParticipants();
    }), this.subscribeToRoomEvent(RoomEvent.ParticipantMetadataChanged, (_, k) => {
      if (_ !== (k == null ? void 0 : k.metadata)) {
        const O = JSON.parse(k == null ? void 0 : k.metadata);
        if (hasPermission(O == null ? void 0 : O.participantRole, Permission.ManageSelf)) {
          if (O.hasOwnProperty("isMirrored")) {
            const D = {
              participantId: k == null ? void 0 : k.identity,
              metadata: O,
              type: "ParticipantMetadataUpdate"
              /* ParticipantMetadataUpdate */
            };
            this._updateGuestParticipantsStore(D);
          }
          return;
        }
      }
    });
  }
  bindApiClient(u) {
    this._apiClient = u;
  }
  get isAdmin() {
    return jwtDecode(this._jwt).video.roomAdmin;
  }
  set isAdmin(u) {
    log.warn("isAdmin cannot be set");
  }
  get token() {
    return this._jwt;
  }
  set token(u) {
    this._jwt = u;
  }
  get url() {
    return this._baseUrl;
  }
  set url(u) {
  }
  get chatHistory() {
    return this._chatHistory;
  }
  set chatHistory(u) {
    this._chatHistory = u;
  }
  _updateGuestParticipantsStore(u) {
    if (!this.guestParticipantMetadata.length)
      this.guestParticipantMetadata.push(u);
    else {
      const c = this.guestParticipantMetadata.findIndex((l) => l.participantId === (u == null ? void 0 : u.participantId));
      c > -1 ? this.guestParticipantMetadata[c] = u : this.guestParticipantMetadata.push(u);
    }
  }
  _updateParticipants() {
    if (!this.livekitRoom || this.livekitRoom.state === ConnectionState.Disconnected) {
      this.participants = [];
      return;
    } else {
      const u = Array.from(this.livekitRoom.remoteParticipants.values()), c = [this.livekitRoom.localParticipant];
      c.push(...u), this.guestParticipantMetadata = this.guestParticipantMetadata.filter((l) => c.find((v) => (v == null ? void 0 : v.identity) === (l == null ? void 0 : l.participantId))), this.participants = c;
    }
  }
  /**
   * @param identity Identity of the user that you wish to kick
   */
  async kickParticipant(u) {
    if (this._admin)
      this._admin.removeParticipant(this.roomName, u);
    else
      throw new Error("no admin permissions");
  }
  updateParticipant(u, c) {
    if (this._admin) {
      const l = JSON.stringify(c);
      this._admin.updateParticipant(this.roomName, u, l);
    } else
      throw new Error("no admin permissions");
  }
  muteTrackAsAdmin(u, c = !0) {
    if (this._admin) {
      const l = this.participants.find((v) => [...v.audioTrackPublications.values(), ...v.videoTrackPublications.values()].find((p) => p.trackSid === u));
      if (!l) {
        log.warn("Could not find participant for track:", {
          trackSid: u
        });
        return;
      }
      this._admin.mutePublishedTrack(this.roomName, l == null ? void 0 : l.identity, u, c);
    } else
      throw new Error("no admin permissions");
  }
  _appendChat(u, c) {
    const l = decoder$1.decode(u), v = JSON.parse(l), p = c.identity, _ = c.name, k = {
      ...v,
      displayName: _,
      sender: p
    };
    this.chatHistory = [...this.chatHistory, k], this._triggerSpecialEvents("Chat", k);
  }
  subscribeToConnect(u) {
    return this._connectListeners.push(u), () => this.unsubscribeFromConnect(u);
  }
  unsubscribeFromConnect(u) {
    this._connectListeners = this._connectListeners.filter((c) => c !== u);
  }
  subscribeToSpecialEvent(u, c) {
    return this._specialEventListenerRegistry[u] || (this._specialEventListenerRegistry[u] = /* @__PURE__ */ new Set()), this._specialEventListenerRegistry[u].add(c), () => {
      this.unsubscribeFromSpecialEvent(u, c);
    };
  }
  unsubscribeFromSpecialEvent(u, c) {
    this._specialEventListenerRegistry[u] || (this._specialEventListenerRegistry[u] = /* @__PURE__ */ new Set()), this._specialEventListenerRegistry[u].delete(c);
  }
  _triggerSpecialEvents(u, ...c) {
    this._specialEventListenerRegistry[u] || (this._specialEventListenerRegistry[u] = /* @__PURE__ */ new Set()), this._specialEventListenerRegistry[u].forEach((l) => {
      l(...c);
    });
  }
  /**
   * connect to livekit webrtc room
   * @param {string} identity unique user name to be displayed to other users
   */
  async connect(u = {}) {
    var c, l;
    try {
      if (this.livekitRoom.state === "connected" || this.isConnecting)
        return;
      this.isConnecting = !0, await this.livekitRoom.connect(`wss://${this._baseUrl}`, this._jwt, {
        ...u
      }), this.isConnecting = !1, Object.values(RoomEvent).forEach((v) => {
        this.livekitRoom.on(v, (...p) => {
          this._roomEventListenerRegistry[v].forEach((_) => {
            _(...p);
          });
        });
      }), Object.values(ParticipantEvent).forEach((v) => {
        this.livekitRoom.localParticipant.on(v, (...p) => {
          this._localParticipantEventListenerRegistry[v].forEach((_) => {
            _(...p);
          });
        });
      }), this._updateParticipants(), this._connectListeners.forEach((v) => v(this.livekitRoom)), lib$2.LiveKitUtils.isRoomAdmin(this._jwt) ? (log.info("Room: Granting admin permissions"), log.debug("Livekit server: ", (c = this._apiClient) == null ? void 0 : c.getLiveKitServer(!0)), this._admin = new dist.RoomServiceClient((l = this._apiClient) == null ? void 0 : l.getLiveKitServer(!0), void 0, void 0, this._jwt)) : log.debug("Room: Not an admin");
    } catch (v) {
      this.isConnecting = !1, log.error(v);
    }
  }
  subscribeToLocalParticipantEvent(u, c) {
    return this._localParticipantEventListenerRegistry[u] || (this._localParticipantEventListenerRegistry[u] = /* @__PURE__ */ new Set()), this._localParticipantEventListenerRegistry[u].add(c), () => {
      this.unsubscribeFromLocalParticipantEvent(u, c);
    };
  }
  unsubscribeFromLocalParticipantEvent(u, c) {
    this._localParticipantEventListenerRegistry[u] || (this._localParticipantEventListenerRegistry[u] = /* @__PURE__ */ new Set()), this._localParticipantEventListenerRegistry[u].delete(c);
  }
  subscribeToRoomEvent(u, c) {
    return this._roomEventListenerRegistry[u] || (this._roomEventListenerRegistry[u] = /* @__PURE__ */ new Set()), this._roomEventListenerRegistry[u].add(c), () => {
      this.unsubscribeFromRoomEvent(u, c);
    };
  }
  unsubscribeFromRoomEvent(u, c) {
    this._roomEventListenerRegistry[u] || (this._roomEventListenerRegistry[u] = /* @__PURE__ */ new Set()), this._roomEventListenerRegistry[u].delete(c);
  }
  /**
   * Sends chat message to entire livekit room, or a private message (if specified) from local participant
   * @param {string[]} [recipients] The identities of the recipient participants. If undefined, will send message to all participants in the chat.
   * Only specify for private messages.
   * Do not include the local participant's identity in this.
   */
  sendChatMessage(u) {
    const {
      message: c,
      recipients: l,
      metadata: v
    } = u;
    if (!this.livekitRoom || this.livekitRoom.state !== "connected")
      return;
    const p = {
      type: "ChatMessage",
      recipients: l,
      metadata: v,
      content: c,
      timestamp: Date.now()
    }, _ = JSON.stringify(p), k = encoder$1.encode(_);
    if ({
      ...p,
      sender: this.livekitRoom.localParticipant.identity,
      displayName: this.livekitRoom.localParticipant.identity
    }, l) {
      const O = l.map(this.livekitRoom.getParticipantByIdentity);
      return this.livekitRoom.localParticipant.publishData(k, {
        reliable: !0,
        destinationIdentities: O.map((D) => D.identity)
      }).then(() => {
        this._appendChat(k, this.livekitRoom.localParticipant);
      });
    } else
      return this.livekitRoom.localParticipant.publishData(k, {
        reliable: !0
      }).then(() => {
        this._appendChat(k, this.livekitRoom.localParticipant);
      });
  }
}
const webrtcManager = new RoomsManager(), index$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  webrtcManager
}, Symbol.toStringTag, { value: "Module" })), encoder = new TextEncoder(), decoder = new TextDecoder(), simpleRooms = /* @__PURE__ */ new Map(), getRoom = (a) => {
  if (!a)
    return null;
  if (simpleRooms.get(a))
    return simpleRooms.get(a);
  const u = webrtcManager.rooms.get(a);
  if (!u)
    return null;
  const c = u.livekitRoom, l = c == null ? void 0 : c.localParticipant;
  window.__StudioRoom = c, l || log.warn("No local participant!");
  const v = {
    useTracks: /* @__PURE__ */ new Set(),
    useTrack: /* @__PURE__ */ new Map(),
    useParticipants: /* @__PURE__ */ new Set(),
    useParticipant: /* @__PURE__ */ new Map(),
    useChatHistory: /* @__PURE__ */ new Set()
  };
  let p = {
    tracks: [],
    participants: [],
    result: {
      participants: [],
      tracks: []
    },
    chat: u.chatHistory
  };
  const _ = () => {
    const ae = u.participants, Q = u.guestParticipantMetadata, ne = ae.flatMap((de) => de.getTrackPublications().map((fe) => ({
      ...fe,
      participant: de
    }))), Z = {
      participants: ae.map((de) => {
        const fe = Q.find((Re) => Re.participantId === de.identity);
        if (fe) {
          let Re = JSON.parse(de.metadata);
          Re = {
            ...Re,
            ...fe.metadata
          }, de.metadata = JSON.stringify(Re);
        }
        const Te = JSON.parse(de.metadata);
        return {
          id: de.identity,
          isSelf: de === l,
          connectionQuality: de.connectionQuality,
          displayName: Te.displayName || de.name,
          joinedAt: de.joinedAt,
          role: Te.participantRole,
          meta: Te,
          trackIds: ne.filter((Re) => Re.participant.sid === de.sid).map((Re) => Re.trackSid)
        };
      }),
      tracks: ne.map((de) => {
        var Te, Re, Le, be;
        const fe = JSON.parse((Te = de == null ? void 0 : de.participant) == null ? void 0 : Te.metadata);
        return {
          mediaStreamTrack: (Re = de.track) == null ? void 0 : Re.mediaStreamTrack,
          id: de.trackSid,
          participantId: (Le = de.participant) == null ? void 0 : Le.identity,
          isMuted: (be = de.track) == null ? void 0 : be.isMuted,
          type: de.source,
          isExternal: !!(fe != null && fe[de.trackSid])
        };
      })
    };
    p = {
      tracks: ne,
      participants: ae,
      result: Z,
      chat: u.chatHistory
    }, v.useTracks.forEach((de) => de(Z.tracks)), v.useTrack.forEach((de, fe) => {
      fe(D(de));
    }), v.useParticipants.forEach((de) => de(Z.participants)), v.useParticipant.forEach((de, fe) => {
      fe(F(de));
    }), v.useChatHistory.forEach((de) => {
      de(p.chat);
    });
  }, k = [RoomEvent.ParticipantConnected, RoomEvent.ParticipantDisconnected, RoomEvent.ParticipantMetadataChanged, RoomEvent.Disconnected, RoomEvent.TrackSubscribed, RoomEvent.TrackUnsubscribed, RoomEvent.LocalTrackPublished, RoomEvent.LocalTrackUnpublished, RoomEvent.ConnectionQualityChanged, RoomEvent.TrackMuted, RoomEvent.TrackUnmuted, RoomEvent.TrackStreamStateChanged];
  u.subscribeToRoomEvent(RoomEvent.DataReceived, (ae, Q, ne) => {
    const Z = decoder.decode(ae);
    JSON.parse(Z).type === DataType.ParticipantMetadataUpdate && _();
  }), k.map((ae) => u.subscribeToRoomEvent(ae, () => _())).push(u.subscribeToSpecialEvent(SpecialEvent.Chat, _));
  const D = (ae) => p.result.tracks.find((Q) => Q.id === ae), F = (ae) => p.result.participants.find((Q) => Q.id === ae), z = (ae, Q) => {
    const ne = l.getTrackPublications().find((Z) => Z.trackSid === ae);
    ne && (Q ? ne.mute() : ne.unmute());
  };
  let j, ee;
  const X = {
    id: u.roomName,
    participantId: l.identity,
    setTrackEnabled: z,
    setCameraEnabled: (ae = !0) => l.setCameraEnabled(ae),
    setMicrophoneEnabled: (ae = !0) => l.setMicrophoneEnabled(ae),
    setCamera: async (ae = {}) => {
      var ne;
      if (j) {
        log.warn("Cannot set camera until previous has resolved");
        return;
      }
      j = !0;
      let Q;
      try {
        const de = l.getTrackPublications().filter((Te) => (Te == null ? void 0 : Te.source) === Track.Source.Camera).find((Te) => !D(Te == null ? void 0 : Te.trackSid).isExternal), fe = await l.createTracks({
          video: {
            deviceId: ae.deviceId,
            resolution: ae.resolution || {
              width: 1280,
              height: 720,
              frameRate: 30,
              aspectRatio: 16 / 9
            }
          }
        });
        de != null && de.isMuted && fe.forEach((Te) => {
          Te.mute();
        }), Q = await Promise.all(fe.map((Te) => l.publishTrack(Te))), de && l.unpublishTrack(de.track);
      } catch (Z) {
        throw Z;
      } finally {
        return j = !1, D((ne = Q[0]) == null ? void 0 : ne.trackSid);
      }
    },
    setMicrophone: async (ae) => {
      var ne;
      if (ee) {
        log.warn("Cannot set microphone until previous has resolved");
        return;
      }
      ee = !0;
      let Q;
      try {
        const de = l.getTrackPublications().filter((Te) => Te.source === Track.Source.Microphone).find((Te) => !D(Te == null ? void 0 : Te.trackSid).isExternal), fe = await l.createTracks({
          audio: ae || !0
        });
        de != null && de.isMuted && fe.forEach((Te) => {
          Te.mute();
        }), Q = await Promise.all(fe.map((Te) => l.publishTrack(Te))), de && l.unpublishTrack(de.track);
      } catch (Z) {
        throw Z;
      } finally {
        return ee = !1, D((ne = Q[0]) == null ? void 0 : ne.trackSid);
      }
    },
    addMicrophone: async (ae) => {
      var fe;
      if (ee) {
        log.warn("Cannot set microphone until previous has resolved");
        return;
      }
      ee = !0;
      const Q = await l.createTracks({
        audio: ae || !0
      }), Z = l.getTrackPublications().filter((Te) => Te.source === Track.Source.Microphone).find((Te) => {
        var Le, be;
        const Re = D(Te == null ? void 0 : Te.trackSid);
        ((be = (Le = Re == null ? void 0 : Re.mediaStreamTrack) == null ? void 0 : Le.getSettings()) == null ? void 0 : be.deviceId) === ae.deviceId && (Re == null || Re.isExternal);
      });
      Z != null && Z.isMuted && Q.forEach((Te) => {
        Te.mute();
      });
      const de = await Promise.all(Q.map((Te) => l.publishTrack(Te)));
      return Z && l.unpublishTrack(Z.track), ee = !1, D((fe = de[0]) == null ? void 0 : fe.trackSid);
    },
    addCamera: async (ae = {}) => {
      var de;
      const Q = await l.createTracks({
        video: {
          deviceId: ae.deviceId,
          resolution: ae.resolution || {
            width: 1280,
            height: 720,
            frameRate: 30,
            aspectRatio: 1.7777777777777777
          }
        }
      }), ne = l.getTrackPublications().find((fe) => {
        var Te, Re, Le;
        return (fe == null ? void 0 : fe.source) === Track.Source.Camera && ((Le = (Re = (Te = fe == null ? void 0 : fe.track) == null ? void 0 : Te.mediaStreamTrack) == null ? void 0 : Re.getSettings()) == null ? void 0 : Le.deviceId) === ae.deviceId;
      });
      ne != null && ne.isMuted && Q.forEach((fe) => {
        fe.mute();
      });
      const Z = await Promise.all(Q.map((fe) => l.publishTrack(fe)));
      return ne && l.unpublishTrack(ne.track), ee = !1, D((de = Z[0]) == null ? void 0 : de.trackSid);
    },
    addScreen: async (ae = {
      audio: !1
    }) => {
      const Q = await l.createScreenTracks(ae), ne = await Promise.all(Q.map((fe) => l.publishTrack(fe))), Z = ne.find((fe) => fe.kind === "video"), de = ne.find((fe) => fe.kind === "audio");
      return {
        screen: D(Z == null ? void 0 : Z.trackSid),
        audio: D(de == null ? void 0 : de.trackSid)
      };
    },
    removeTrack: async (ae) => {
      const Q = p.tracks.find((ne) => ne.trackSid === ae);
      l.unpublishTrack(Q.track);
    },
    /* Setting the local participant metadata. */
    setLocalParticipantMetadata: async (ae, Q) => {
      const ne = JSON.stringify(Q), Z = encoder.encode(JSON.stringify({
        metadata: Q,
        type: DataType.ParticipantMetadataUpdate,
        participantId: ae
      }));
      return l.setMetadata(ne), await l.publishData(Z, {
        reliable: !0
      });
    },
    setParticipantMetadata: (ae, Q) => u.updateParticipant(ae, Q),
    kickParticipant: u.kickParticipant,
    muteTrackAsAdmin: u.muteTrackAsAdmin,
    sendChatMessage: u.sendChatMessage,
    // Callbacks
    getTracks: () => p.result.tracks,
    useTracks: (ae) => (v.useTracks.add(ae), ae(p.result.tracks), () => {
      v.useTracks.delete(ae);
    }),
    getTrack: D,
    useTrack: (ae, Q) => (v.useTrack.set(Q, ae), Q(D(ae)), () => {
      v.useTrack.delete(Q);
    }),
    getParticipant: F,
    getParticipants: () => p.result.participants,
    useParticipants: (ae) => (v.useParticipants.add(ae), ae(p.result.participants), () => {
      v.useParticipants.delete(ae);
    }),
    useParticipant: (ae, Q) => (v.useParticipant.set(Q, ae), Q(F(ae)), () => {
      v.useTrack.delete(Q);
    }),
    useChatHistory: (ae) => (v.useChatHistory.add(ae), ae(p.chat), () => {
      v.useChatHistory.delete(ae);
    }),
    useActiveSpeakers: (ae) => {
      var ne, Z;
      const Q = (de) => {
        ae(de.map((fe) => fe.identity));
      };
      return (ne = u.livekitRoom) == null || ne.on(RoomEvent.ActiveSpeakersChanged, Q), Q((Z = u.livekitRoom) == null ? void 0 : Z.activeSpeakers), () => {
        var de;
        (de = u.livekitRoom) == null || de.off(RoomEvent.ActiveSpeakersChanged, Q);
      };
    },
    sendData: (ae, Q = []) => {
      const ne = encoder.encode(JSON.stringify(ae)), Z = Q == null ? void 0 : Q.map((de) => {
        var fe;
        return (fe = u.livekitRoom) == null ? void 0 : fe.getParticipantByIdentity(de);
      }).filter(Boolean);
      return l.publishData(ne, {
        reliable: !0,
        destinationIdentities: Z.map((de) => de.identity)
      });
    },
    onData: (ae) => {
      var ne;
      const Q = (Z, de) => {
        const fe = JSON.parse(decoder.decode(Z));
        ae(fe, de == null ? void 0 : de.identity);
      };
      return (ne = u.livekitRoom) == null || ne.on(RoomEvent.DataReceived, Q), () => {
        var Z;
        (Z = u.livekitRoom) == null || Z.off(RoomEvent.DataReceived, Q);
      };
    },
    connect: () => u.connect(),
    disconnect: () => {
      var ae;
      return (ae = u.livekitRoom) == null ? void 0 : ae.disconnect();
    },
    onDisconnected: (ae) => {
      var Q;
      return (Q = u.livekitRoom) == null || Q.on(RoomEvent.Disconnected, ae), () => {
        var ne;
        (ne = u.livekitRoom) == null || ne.off(RoomEvent.DataReceived, ae);
      };
    },
    setAudioOutput: (ae) => {
      var Q;
      return (Q = u.livekitRoom) == null ? void 0 : Q.switchActiveDevice("audiooutput", ae);
    }
  };
  return _(), simpleRooms.set(a, X), X;
}, {
  state: state$2
} = CoreContext, getAccessTokenData = () => {
  var a;
  return ((a = CoreContext.clients.accessTokenClaims) == null ? void 0 : a.user) || {};
}, getBaseUser = () => state$2.user ? {
  id: state$2.user.id,
  props: state$2.user.props,
  name: state$2.user.name,
  projects: state$2.projects.map(toBaseProject),
  sources: state$2.sources.map(toBaseSource)
} : null, toBaseProject = (a) => {
  const {
    compositor: u,
    videoApi: c,
    props: l = {},
    role: v
  } = a, {
    destinations: p,
    encoding: _,
    rendering: k,
    sources: O
  } = c.project, D = {
    get: u.get,
    getRoot: u.getRoot,
    getParent: u.getParent
  };
  Object.defineProperty(D, "nodes", {
    get() {
      return u.nodes.filter((j) => !j._deleted);
    }
  });
  const F = a.videoApi.phase, z = a.videoApi.broadcastId || null;
  return {
    broadcastPhase: F,
    role: v,
    broadcastId: z,
    layoutId: a.layoutApi.layoutId,
    isLive: [ProjectBroadcastPhase.PROJECT_BROADCAST_PHASE_RUNNING, ProjectBroadcastPhase.PROJECT_BROADCAST_PHASE_STOPPING].includes(F),
    scene: D,
    joinRoom: async (j = {}) => CoreContext.Command.joinRoom({
      projectId: a.id,
      ...j
    }),
    subscribe: (j) => CoreContext.subscribe((ee, X) => {
      X.projectId && (X == null ? void 0 : X.projectId) === a.id && j(ee, X);
    }),
    destinations: p.map(toBaseDestination),
    sources: O.map(toBaseSource),
    encoding: _,
    rendering: k,
    id: a.id,
    hostDisplayName: a.props.hostDisplayName,
    props: l
  };
}, toBaseDestination = (a) => {
  var u;
  return {
    id: a.destinationId,
    enabled: a.enabled,
    address: a.address,
    // For backward compatibility, fall back to "metadata" as props.
    //  All new projects have a dedicated "props" field
    props: ((u = a.metadata) == null ? void 0 : u.props) || (a == null ? void 0 : a.metadata) || {}
  };
}, toBaseSource = (a) => {
  var u;
  return {
    id: a.sourceId,
    address: a.address,
    preview: a.preview,
    props: ((u = a.metadata) == null ? void 0 : u.props) || {}
  };
}, hydrateProject = async (a, u, c) => {
  const l = a.metadata || {}, v = {
    collectionId: a.collectionId,
    projectId: a.projectId,
    updateMask: []
  };
  hasPermission(u, Permission.ManageBroadcast) && a.composition.studioSdk.version !== CoreContext.rendererVersion && (v.composition = {
    studioSdk: {
      version: CoreContext.rendererVersion
    }
  }, v.updateMask.push("composition.studioSdk.version")), c && (v.rendering = {
    video: {
      width: c.x,
      height: c.y,
      framerate: 30
    }
  }, v.updateMask.push("rendering")), v.updateMask.length && await CoreContext.clients.LiveApi().project.updateProject(v);
  const _ = await layoutToProject(l.layoutId, c);
  return {
    id: a.projectId,
    compositor: _,
    role: u,
    videoApi: {
      project: a,
      phase: ProjectBroadcastPhase.PROJECT_BROADCAST_PHASE_UNSPECIFIED
    },
    layoutApi: {
      layoutId: l.layoutId
    },
    // For backward compatibility, fall back to "metadata" as props.
    //  All new projects have a dedicated "props" field
    props: (l == null ? void 0 : l.props) || l
  };
}, sceneNodeToLayer = (a) => {
  const {
    id: u,
    props: c = {},
    children: l = []
  } = a;
  return {
    ...u ? {
      id: u
    } : {},
    type: c.type,
    data: {
      ...c
    },
    children: l.map((v) => v.id)
  };
}, nodeToLayer = (a) => ({
  id: a.id,
  type: a.props.type,
  data: {
    ...a.props
  },
  children: a.childIds.map((u) => u)
}), layerToNode = (a) => ({
  id: String(a.id),
  props: {
    type: a.type,
    ...a.data
  },
  childIds: a.children.map((u) => String(u))
}), layoutToProject = async (a, u) => {
  const {
    layers: c
  } = await CoreContext.clients.LayoutApi().layer.listLayers({
    layoutId: a
  });
  if (u && c) {
    const {
      x: _,
      y: k
    } = u, O = c == null ? void 0 : c.reduce((D, F) => D ? D.data.isRoot ? D : F.data.isRoot || !c.some((z) => z.children.includes(F.id)) ? F : D : F, null);
    if (O) {
      const D = await CoreContext.clients.LayoutApi().layer.updateLayer({
        layoutId: O.layoutId,
        layerId: O.id,
        layer: {
          x: _,
          y: k,
          data: {
            ...O.data,
            size: {
              x: _,
              y: k
            }
          }
        }
      }), F = c.findIndex((z) => z.id === D.id);
      c[F] = D;
    }
  }
  const l = c.map(layerToNode), v = l.reduce((_, k) => _ ? _.props.isRoot ? _ : k.props.isRoot || !l.some((O) => O.childIds.includes(k.id)) ? k : _ : k, null), p = v ? toSceneTree(l, v.id) : null;
  return CoreContext.compositor.loadProject(p, a);
}, getUser = () => {
  const a = state$2.user;
  if (!a)
    throw new Error("User not loaded");
  return a;
}, getProject = (a) => state$2.projects.find((u) => u.id === a), getProjectByLayoutId = (a) => state$2.projects.find((u) => u.compositor.id === a), getProjectRoom = (a) => {
  var u;
  return getRoom((u = getProject(a)) == null ? void 0 : u.roomId);
}, {
  connectionId
} = CoreContext, latestUpdateVersion = {}, getNextNodeVersion = (a) => (latestUpdateVersion[a] || (latestUpdateVersion[a] = 0), ++latestUpdateVersion[a]), request = (a, u) => {
  const c = u.map((l) => {
    const [v, p] = l;
    return {
      [v]: p
    };
  });
  return log.debug("Batch request", c), CoreContext.clients.LayoutApi().layer.batch({
    layoutId: a,
    layers: c,
    requestMetadata: {
      connectionId,
      layoutId: a,
      updateVersions: u.filter(([l]) => l === "update").map(([l, v]) => ({
        [v.id]: getNextNodeVersion(v.id)
      })).reduce((l, v) => ({
        ...v,
        ...l
      }), {})
    }
  });
}, compositorAdapter = (a, u) => ({
  async insert(c = {}, l, v) {
    const p = nodeToLayer({
      id: null,
      props: c,
      childIds: []
    });
    l ? p.type = "child" : p.type = "root", log.debug("Insert layer", p);
    const _ = await CoreContext.clients.LayoutApi().layer.createLayer({
      layoutId: a,
      layer: {
        ...p,
        requestMetadata: {
          connectionId,
          layoutId: a
        }
      }
    });
    if (_.code)
      throw new Error(_.message);
    const k = await u.get(l);
    if (l && !k)
      throw Error("Parent not found with ID");
    if (k) {
      const O = nodeToLayer(k), D = insertAt$1(v, _.id, O.children), F = {
        layoutId: a,
        layerId: O.id,
        layer: {
          children: D,
          requestMetadata: {
            connectionId,
            layoutId: a,
            updateVersion: {
              [p.id]: getNextNodeVersion(p.id)
            }
          }
        }
      };
      await CoreContext.clients.LayoutApi().layer.updateLayer(F);
    }
    return String(_.id);
  },
  async update(c, l = {}) {
    const v = u.get(c), p = nodeToLayer({
      ...v,
      props: {
        ...v.props,
        ...l
      }
    }), _ = {
      layoutId: a,
      layerId: p.id,
      layer: {
        ...p,
        requestMetadata: {
          connectionId,
          layoutId: a,
          updateVersions: {
            [p.id]: getNextNodeVersion(p.id)
          }
        }
      }
    };
    log.debug("Update layer", _), await CoreContext.clients.LayoutApi().layer.updateLayer(_);
  },
  async remove(c) {
    const l = await u.getParent(c);
    if (l) {
      const v = nodeToLayer(l), p = v.children.filter((k) => k !== c), _ = {
        layoutId: a,
        layerId: v.id,
        layer: {
          children: p,
          requestMetadata: {
            connectionId,
            layoutId: a,
            updateVersions: {
              [v.id]: getNextNodeVersion(v.id)
            }
          }
        }
      };
      await CoreContext.clients.LayoutApi().layer.updateLayer(_);
    }
    await CoreContext.clients.LayoutApi().layer.deleteLayer({
      layoutId: a,
      layerId: c,
      payload: {
        requestMetadata: {
          connectionId,
          layoutId: a
        }
      }
    });
  },
  // @ts-ignore
  async reorder(c, l) {
    const v = u.get(c), p = nodeToLayer({
      ...v,
      childIds: l
    });
    log.debug("Reorder layer children", p), await CoreContext.clients.LayoutApi().layer.updateLayer({
      layoutId: a,
      layerId: p.id,
      layer: {
        children: p.children,
        requestMetadata: {
          connectionId,
          layoutId: a,
          updateVersions: {
            [p.id]: getNextNodeVersion(p.id)
          }
        }
      }
    });
  },
  // @ts-ignore
  async move(c, l, v) {
    const p = u.get(c), _ = u.get(u.getParent(c).id), k = nodeToLayer({
      ..._,
      childIds: pull$1(_.childIds, p.id)
    }), O = u.get(l), D = nodeToLayer({
      ...O,
      childIds: insertAt$1(v, p.id, O.childIds)
    });
    log.debug("Move layers"), await Promise.all([CoreContext.clients.LayoutApi().layer.updateLayer({
      layoutId: a,
      layerId: k.id,
      layer: {
        children: k.children,
        requestMetadata: {
          connectionId,
          layoutId: a,
          updateVersions: {
            [k.id]: getNextNodeVersion(k.id)
          }
        }
      }
    }), CoreContext.clients.LayoutApi().layer.updateLayer({
      layoutId: a,
      layerId: D.id,
      layer: {
        children: D.children,
        requestMetadata: {
          connectionId,
          layoutId: a,
          updateVersions: {
            [D.id]: getNextNodeVersion(D.id)
          }
        }
      }
    })]);
  },
  async batch(c) {
    const l = c.map(([p, _]) => [p, sceneNodeToLayer(_)]), v = await request(a, l);
    return log.debug("Batch response", v), v;
  }
}), {
  state: state$1
} = CoreContext, prepareInternalEvents = () => {
  subscribeInternal(async (a, u) => {
    var c, l, v;
    switch (a) {
      case "UserChanged": {
        const {
          metadata: p
        } = u;
        state$1.user.metadata = p || {}, state$1.user.props = (p == null ? void 0 : p.props) || {}, trigger$1("UserChanged", {
          user: getBaseUser()
        });
        return;
      }
      case "ActiveProjectChanged": {
        const {
          projectId: p
        } = u;
        state$1.activeProjectId = p, trigger$1("ActiveProjectChanged", {
          projectId: p
        });
        return;
      }
      case "ProjectAdded": {
        const _ = await hydrateProject(u, "ROLE_HOST"), k = toBaseProject(_);
        state$1.projects = [...state$1.projects, _], trigger$1("ProjectAdded", {
          project: k
        });
        return;
      }
      case "ProjectRemoved": {
        const {
          projectId: p
        } = u;
        state$1.projects = state$1.projects.filter((_) => _.id !== p), trigger$1("ProjectRemoved", {
          projectId: p
        });
        return;
      }
      case "ProjectChanged": {
        const {
          project: p,
          phase: _,
          broadcastId: k
        } = u, O = getProject(p.projectId);
        if (!O)
          return;
        _ && (O.videoApi.phase = _), typeof k < "u" && (O.videoApi.broadcastId = k);
        const D = (c = p.metadata) == null ? void 0 : c.layoutId;
        D !== O.layoutApi.layoutId && (O.layoutApi.layoutId = (l = p.metadata) == null ? void 0 : l.layoutId, O.compositor = await layoutToProject(D)), O.videoApi.project = p, O.props = ((v = p.metadata) == null ? void 0 : v.props) ?? {}, trigger$1("ProjectChanged", {
          project: toBaseProject(O)
        });
        return;
      }
      case "DestinationAdded": {
        const {
          projectId: p
        } = u, _ = getProject(p);
        if (!_)
          return;
        _.videoApi.project.destinations.push(u), trigger$1("DestinationAdded", {
          projectId: p,
          destination: toBaseDestination(u)
        });
        return;
      }
      case "DestinationRemoved": {
        const {
          projectId: p,
          destinationId: _
        } = u, k = getProject(p);
        if (!k)
          return;
        k.videoApi.project.destinations = k.videoApi.project.destinations.filter((O) => O.destinationId !== _), trigger$1("DestinationRemoved", {
          projectId: p,
          destinationId: _
        });
        return;
      }
      case "DestinationChanged": {
        const p = u, {
          projectId: _,
          destinationId: k
        } = p, O = getProject(_);
        if (!O)
          return;
        const D = O.videoApi.project.destinations.find((F) => F.destinationId === k);
        if (!D)
          return;
        Object.assign(D, p), trigger$1("DestinationChanged", {
          projectId: _,
          destination: toBaseDestination(D)
        });
        return;
      }
      case "SourceAdded": {
        trigger$1("SourceAdded", {
          source: toBaseSource(u)
        });
        return;
      }
      case "SourceRemoved":
        return;
      case "SourceChanged":
        return;
      case "ProjectSourceAdded": {
        const {
          projectId: p,
          source: _
        } = u, k = getProject(p);
        if (!k)
          return;
        k.videoApi.project.sources.push(_), trigger$1("ProjectSourceAdded", {
          source: toBaseSource(_),
          projectId: p
        });
        return;
      }
      case "ProjectSourceRemoved": {
        const {
          projectId: p,
          sourceId: _
        } = u, k = getProject(p);
        if (!k)
          return;
        k.videoApi.project.sources = k.videoApi.project.sources.filter((O) => O.sourceId !== _), trigger$1("ProjectSourceRemoved", {
          sourceId: _,
          projectId: p
        });
      }
      case "NodeAdded":
        return;
      case "NodeRemoved":
        return;
      case "NodeChanged":
        return;
    }
  }), subscribeInternal(() => log.debug({
    nextState: {
      ...state$1
    }
  }));
};
/*! (c) Andrea Giammarchi - ISC */
var self$1 = {};
try {
  self$1.WeakMap = WeakMap;
} catch (a) {
  self$1.WeakMap = function(u, c) {
    var l = c.defineProperty, v = c.hasOwnProperty, p = _.prototype;
    return p.delete = function(O) {
      return this.has(O) && delete O[this._];
    }, p.get = function(O) {
      return this.has(O) ? O[this._] : void 0;
    }, p.has = function(O) {
      return v.call(O, this._);
    }, p.set = function(O, D) {
      return l(O, this._, { configurable: !0, value: D }), this;
    }, _;
    function _(O) {
      l(this, "_", { value: "_@ungap/weakmap" + u++ }), O && O.forEach(k, this);
    }
    function k(O) {
      this.set(O[0], O[1]);
    }
  }(Math.random(), Object);
}
const WeakMap$1 = self$1.WeakMap;
/*! (c) Andrea Giammarchi - ISC */
var UID = "-" + Math.random().toFixed(6) + "%", UID_IE = !1;
try {
  (function(a, u, c) {
    return u in a && (a.innerHTML = "<p " + c + '="' + UID + '"></p>', a[u].childNodes[0].getAttribute(c) == UID);
  })(document.createElement("template"), "content", "tabindex") || (UID = "_dt: " + UID.slice(1, -1) + ";", UID_IE = !0);
} catch (a) {
}
var UIDC = "<!--" + UID + "-->", COMMENT_NODE = 8, ELEMENT_NODE$1 = 1, TEXT_NODE = 3, SHOULD_USE_TEXT_CONTENT = /^(?:plaintext|script|style|textarea|title|xmp)$/i, VOID_ELEMENTS = /^(?:area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)$/i;
/*! (c) Andrea Giammarchi - ISC */
function domsanitizer(a) {
  return a.join(UIDC).replace(selfClosing, fullClosing).replace(attrSeeker, attrReplacer);
}
var spaces = " \\f\\n\\r\\t", almostEverything = "[^" + spaces + `\\/>"'=]+`, attrName = "[" + spaces + "]+" + almostEverything, tagName = "<([A-Za-z]+[A-Za-z0-9:._-]*)((?:", attrPartials = `(?:\\s*=\\s*(?:'[^']*?'|"[^"]*?"|<[^>]*?>|` + almostEverything.replace("\\/", "") + "))?)", attrSeeker = new RegExp(tagName + attrName + attrPartials + "+)([" + spaces + "]*/?>)", "g"), selfClosing = new RegExp(tagName + attrName + attrPartials + "*)([" + spaces + "]*/>)", "g"), findAttributes = new RegExp("(" + attrName + `\\s*=\\s*)(['"]?)` + UIDC + "\\2", "gi");
function attrReplacer(a, u, c, l) {
  return "<" + u + c.replace(findAttributes, replaceAttributes) + l;
}
function replaceAttributes(a, u, c) {
  return u + (c || '"') + UID + (c || '"');
}
function fullClosing(a, u, c) {
  return VOID_ELEMENTS.test(u) ? a : "<" + u + c + "></" + u + ">";
}
const { isArray } = Array, { indexOf, slice } = [], umap = (a) => ({
  // About: get: _.get.bind(_)
  // It looks like WebKit/Safari didn't optimize bind at all,
  // so that using bind slows it down by 60%.
  // Firefox and Chrome are just fine in both cases,
  // so let's use the approach that works fast everywhere 👍
  get: (u) => a.get(u),
  set: (u, c) => (a.set(u, c), c)
}), ELEMENT_NODE = 1, nodeType = 111, remove = ({ firstChild: a, lastChild: u }) => {
  const c = document.createRange();
  return c.setStartAfter(a), c.setEndAfter(u), c.deleteContents(), a;
}, diffable = (a, u) => a.nodeType === nodeType ? 1 / u < 0 ? u ? remove(a) : a.lastChild : u ? a.valueOf() : a.firstChild : a, persistent = (a) => {
  const { childNodes: u } = a, { length: c } = u;
  if (c < 2)
    return c ? u[0] : a;
  const l = slice.call(u, 0), v = l[0], p = l[c - 1];
  return {
    ELEMENT_NODE,
    nodeType,
    firstChild: v,
    lastChild: p,
    valueOf() {
      if (u.length !== c) {
        let _ = 0;
        for (; _ < c; )
          a.appendChild(l[_++]);
      }
      return a;
    }
  };
};
/*! (c) Andrea Giammarchi - ISC */
var createContent = function(a) {
  var u = "fragment", c = "template", l = "content" in _(c), v = l ? function(O) {
    var D = _(c);
    return D.innerHTML = O, D.content;
  } : function(O) {
    var D = _(u), F = _(c), z = null;
    if (/^[^\S]*?<(col(?:group)?|t(?:head|body|foot|r|d|h))/i.test(O)) {
      var j = RegExp.$1;
      F.innerHTML = "<table>" + O + "</table>", z = F.querySelectorAll(j);
    } else
      F.innerHTML = O, z = F.childNodes;
    return p(D, z), D;
  };
  return function(D, F) {
    return (F === "svg" ? k : v)(D);
  };
  function p(O, D) {
    for (var F = D.length; F--; )
      O.appendChild(D[0]);
  }
  function _(O) {
    return O === u ? a.createDocumentFragment() : a.createElementNS("http://www.w3.org/1999/xhtml", O);
  }
  function k(O) {
    var D = _(u), F = _("div");
    return F.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg">' + O + "</svg>", p(D, F.firstChild.childNodes), D;
  }
}(document);
const udomdiff = (a, u, c, l, v) => {
  const p = c.length;
  let _ = u.length, k = p, O = 0, D = 0, F = null;
  for (; O < _ || D < k; )
    if (_ === O) {
      const z = k < p ? D ? l(c[D - 1], -0).nextSibling : l(c[k - D], 0) : v;
      for (; D < k; )
        a.insertBefore(l(c[D++], 1), z);
    } else if (k === D)
      for (; O < _; )
        (!F || !F.has(u[O])) && a.removeChild(l(u[O], -1)), O++;
    else if (u[O] === c[D])
      O++, D++;
    else if (u[_ - 1] === c[k - 1])
      _--, k--;
    else if (u[O] === c[k - 1] && c[D] === u[_ - 1]) {
      const z = l(u[--_], -1).nextSibling;
      a.insertBefore(
        l(c[D++], 1),
        l(u[O++], -1).nextSibling
      ), a.insertBefore(l(c[--k], 1), z), u[_] = c[k];
    } else {
      if (!F) {
        F = /* @__PURE__ */ new Map();
        let z = D;
        for (; z < k; )
          F.set(c[z], z++);
      }
      if (F.has(u[O])) {
        const z = F.get(u[O]);
        if (D < z && z < k) {
          let j = O, ee = 1;
          for (; ++j < _ && j < k && F.get(u[j]) === z + ee; )
            ee++;
          if (ee > z - D) {
            const X = l(u[O], 0);
            for (; D < z; )
              a.insertBefore(l(c[D++], 1), X);
          } else
            a.replaceChild(
              l(c[D++], 1),
              l(u[O++], -1)
            );
        } else
          O++;
      } else
        a.removeChild(l(u[O++], -1));
    }
  return c;
};
/*! (c) Andrea Giammarchi - ISC */
var importNode = function(a, u, c, l, v) {
  var p = v in a, _ = a.createDocumentFragment();
  _[u](a[l]("g")), _[u](a[l](""));
  var k = p ? a[v](_, !0) : _[c](!0);
  return k.childNodes.length < 2 ? function O(D, F) {
    for (var z = D[c](), j = D.childNodes || [], ee = j.length, X = 0; F && X < ee; X++)
      z[u](O(j[X], F));
    return z;
  } : (
    /* istanbul ignore next */
    p ? a[v] : function(O, D) {
      return O[c](!!D);
    }
  );
}(
  document,
  "appendChild",
  "cloneNode",
  "createTextNode",
  "importNode"
), trim = "".trim || /* istanbul ignore next */
function() {
  return String(this).replace(/^\s+|\s+/g, "");
}, normalizeAttributes = UID_IE ? function(a, u) {
  var c = u.join(" ");
  return u.slice.call(a, 0).sort(function(l, v) {
    return c.indexOf(l.name) <= c.indexOf(v.name) ? -1 : 1;
  });
} : function(a, u) {
  return u.slice.call(a, 0);
};
function find(a, u) {
  for (var c = u.length, l = 0; l < c; )
    a = a.childNodes[u[l++]];
  return a;
}
function parse(a, u, c, l) {
  for (var v = a.childNodes, p = v.length, _ = 0; _ < p; ) {
    var k = v[_];
    switch (k.nodeType) {
      case ELEMENT_NODE$1:
        var O = l.concat(_);
        parseAttributes(k, u, c, O), parse(k, u, c, O);
        break;
      case COMMENT_NODE:
        var D = k.textContent;
        if (D === UID)
          c.shift(), u.push(
            // basicHTML or other non standard engines
            // might end up having comments in nodes
            // where they shouldn't, hence this check.
            SHOULD_USE_TEXT_CONTENT.test(a.nodeName) ? Text(a, l) : Any(k, l.concat(_))
          );
        else
          switch (D.slice(0, 2)) {
            case "/*":
              if (D.slice(-2) !== "*/")
                break;
            case "👻":
              a.removeChild(k), _--, p--;
          }
        break;
      case TEXT_NODE:
        SHOULD_USE_TEXT_CONTENT.test(a.nodeName) && trim.call(k.textContent) === UIDC && (c.shift(), u.push(Text(a, l)));
        break;
    }
    _++;
  }
}
function parseAttributes(a, u, c, l) {
  for (var v = a.attributes, p = [], _ = [], k = normalizeAttributes(v, c), O = k.length, D = 0; D < O; ) {
    var F = k[D++], z = F.value === UID, j;
    if (z || 1 < (j = F.value.split(UIDC)).length) {
      var ee = F.name;
      if (p.indexOf(ee) < 0) {
        p.push(ee);
        var X = c.shift().replace(
          z ? /^(?:|[\S\s]*?\s)(\S+?)\s*=\s*('|")?$/ : new RegExp(
            "^(?:|[\\S\\s]*?\\s)(" + ee + `)\\s*=\\s*('|")[\\S\\s]*`,
            "i"
          ),
          "$1"
        ), ae = v[X] || // the following ignore is covered by browsers
        // while basicHTML is already case-sensitive
        /* istanbul ignore next */
        v[X.toLowerCase()];
        if (z)
          u.push(Attr(ae, l, X, null));
        else {
          for (var Q = j.length - 2; Q--; )
            c.shift();
          u.push(Attr(ae, l, X, j));
        }
      }
      _.push(F);
    }
  }
  O = _.length, D = 0;
  for (var ne = 0 < O && UID_IE && !("ownerSVGElement" in a); D < O; ) {
    var Z = _[D++];
    ne && (Z.value = ""), a.removeAttribute(Z.name);
  }
  var de = a.nodeName;
  if (/^script$/i.test(de)) {
    var fe = document.createElement(de);
    for (O = v.length, D = 0; D < O; )
      fe.setAttributeNode(v[D++].cloneNode(!0));
    fe.textContent = a.textContent, a.parentNode.replaceChild(fe, a);
  }
}
function Any(a, u) {
  return {
    type: "any",
    node: a,
    path: u
  };
}
function Attr(a, u, c, l) {
  return {
    type: "attr",
    node: a,
    path: u,
    name: c,
    sparse: l
  };
}
function Text(a, u) {
  return {
    type: "text",
    node: a,
    path: u
  };
}
var parsed = umap(new WeakMap$1());
function createInfo(a, u) {
  var c = (a.convert || domsanitizer)(u), l = a.transform;
  l && (c = l(c));
  var v = createContent(c, a.type);
  cleanContent(v);
  var p = [];
  return parse(v, p, u.slice(0), []), {
    content: v,
    updates: function(_) {
      for (var k = [], O = p.length, D = 0, F = 0; D < O; ) {
        var z = p[D++], j = find(_, z.path);
        switch (z.type) {
          case "any":
            k.push({ fn: a.any(j, []), sparse: !1 });
            break;
          case "attr":
            var ee = z.sparse, X = a.attribute(j, z.name, z.node);
            ee === null ? k.push({ fn: X, sparse: !1 }) : (F += ee.length - 2, k.push({ fn: X, sparse: !0, values: ee }));
            break;
          case "text":
            k.push({ fn: a.text(j), sparse: !1 }), j.textContent = "";
            break;
        }
      }
      return O += F, function() {
        var ae = arguments.length;
        if (O !== ae - 1)
          throw new Error(
            ae - 1 + " values instead of " + O + `
` + u.join("${value}")
          );
        for (var Q = 1, ne = 1; Q < ae; ) {
          var Z = k[Q - ne];
          if (Z.sparse) {
            var de = Z.values, fe = de[0], Te = 1, Re = de.length;
            for (ne += Re - 2; Te < Re; )
              fe += arguments[Q++] + de[Te++];
            Z.fn(fe);
          } else
            Z.fn(arguments[Q++]);
        }
        return _;
      };
    }
  };
}
function createDetails(a, u) {
  var c = parsed.get(u) || parsed.set(u, createInfo(a, u));
  return c.updates(importNode.call(document, c.content, !0));
}
var empty = [];
function domtagger(a) {
  var u = empty, c = cleanContent;
  return function(l) {
    return u !== l && (c = createDetails(a, u = l)), c.apply(null, arguments);
  };
}
function cleanContent(a) {
  for (var u = a.childNodes, c = u.length; c--; ) {
    var l = u[c];
    l.nodeType !== 1 && trim.call(l.textContent).length === 0 && a.removeChild(l);
  }
}
/*! (c) Andrea Giammarchi - ISC */
var hyperStyle = /* @__PURE__ */ function() {
  var a = /acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i, u = /([^A-Z])([A-Z]+)/g;
  return function(k, O) {
    return "ownerSVGElement" in k ? l(k, O) : p(k.style, !1);
  };
  function c(_, k, O) {
    return k + "-" + O.toLowerCase();
  }
  function l(_, k) {
    var O;
    return k ? O = k.cloneNode(!0) : (_.setAttribute("style", "--hyper:style;"), O = _.getAttributeNode("style")), O.value = "", _.setAttributeNode(O), p(O, !0);
  }
  function v(_) {
    var k, O = [];
    for (k in _)
      O.push(k.replace(u, c), ":", _[k], ";");
    return O.join("");
  }
  function p(_, k) {
    var O, D;
    return function(F) {
      var z, j, ee, X;
      switch (typeof F) {
        case "object":
          if (F) {
            if (O === "object") {
              if (!k && D !== F)
                for (j in D)
                  j in F || (_[j] = "");
            } else
              k ? _.value = "" : _.cssText = "";
            z = k ? {} : _;
            for (j in F)
              X = F[j], ee = typeof X == "number" && !a.test(j) ? X + "px" : X, !k && /^--/.test(j) ? z.setProperty(j, ee) : z[j] = ee;
            O = "object", k ? _.value = v(D = z) : D = F;
            break;
          }
        default:
          D != F && (O = "string", D = F, k ? _.value = F || "" : _.cssText = F || "");
          break;
      }
    };
  }
}();
const aria = (a) => (u) => {
  for (const c in u) {
    const l = c === "role" ? c : `aria-${c}`, v = u[c];
    v == null ? a.removeAttribute(l) : a.setAttribute(l, v);
  }
}, attribute = (a, u) => {
  let c, l = !0;
  const v = document.createAttributeNS(null, u);
  return (p) => {
    c !== p && (c = p, c == null ? l || (a.removeAttributeNode(v), l = !0) : (v.value = p, l && (a.setAttributeNodeNS(v), l = !1)));
  };
}, boolean = (a, u, c) => (l) => {
  c !== !!l && ((c = !!l) ? a.setAttribute(u, "") : a.removeAttribute(u));
}, data = ({ dataset: a }) => (u) => {
  for (const c in u) {
    const l = u[c];
    l == null ? delete a[c] : a[c] = l;
  }
}, event = (a, u) => {
  let c, l = u.slice(2);
  return !(u in a) && u.toLowerCase() in a && (l = l.toLowerCase()), (v) => {
    const p = isArray(v) ? v : [v, !1];
    c !== p[0] && (c && a.removeEventListener(l, c, p[1]), (c = p[0]) && a.addEventListener(l, c, p[1]));
  };
}, ref = (a) => (u) => {
  typeof u == "function" ? u(a) : u.current = a;
}, setter = (a, u) => u === "dataset" ? data(a) : (c) => {
  a[u] = c;
}, hyperProperty = (a, u) => {
  let c;
  return (l) => {
    c !== l && (c = l, a[u] !== l && (l == null ? (a[u] = "", a.removeAttribute(u)) : a[u] = l));
  };
}, readOnly = /^(?:form|list)$/i, text = (a, u) => a.ownerDocument.createTextNode(u);
function Tagger(a) {
  return this.type = a, domtagger(this);
}
Tagger.prototype = {
  // there are four kind of attributes, and related behavior:
  //  * events, with a name starting with `on`, to add/remove event listeners
  //  * special, with a name present in their inherited prototype, accessed directly
  //  * regular, accessed through get/setAttribute standard DOM methods
  //  * style, the only regular attribute that also accepts an object as value
  //    so that you can style=${{width: 120}}. In this case, the behavior has been
  //    fully inspired by Preact library and its simplicity.
  attribute(a, u, c) {
    const l = this.type === "svg";
    switch (u) {
      case "class":
        if (l)
          return attribute(a, u);
        u = "className";
      case "props":
        return setter(a, u);
      case "aria":
        return aria(a);
      case "style":
        return hyperStyle(a, c, l);
      case "ref":
        return ref(a);
      case ".dataset":
        return data(a);
      default:
        return u.slice(0, 1) === "." ? setter(a, u.slice(1)) : u.slice(0, 1) === "?" ? boolean(a, u.slice(1)) : u.slice(0, 2) === "on" ? event(a, u) : u in a && !(l || readOnly.test(u)) ? hyperProperty(a, u) : attribute(a, u);
    }
  },
  // in a hyper(node)`<div>${content}</div>` case
  // everything could happen:
  //  * it's a JS primitive, stored as text
  //  * it's null or undefined, the node should be cleaned
  //  * it's a promise, update the content once resolved
  //  * it's an explicit intent, perform the desired operation
  //  * it's an Array, resolve all values if Promises and/or
  //    update the node with the resulting list of content
  any(a, u) {
    const { type: c } = this;
    let l = !1, v;
    const p = (_) => {
      switch (typeof _) {
        case "string":
        case "number":
        case "boolean":
          l ? v !== _ && (v = _, u[0].textContent = _) : (l = !0, v = _, u = udomdiff(
            a.parentNode,
            u,
            [text(a, _)],
            diffable,
            a
          ));
          break;
        case "function":
          p(_(a));
          break;
        case "object":
        case "undefined":
          if (_ == null) {
            l = !1, u = udomdiff(
              a.parentNode,
              u,
              [],
              diffable,
              a
            );
            break;
          }
        default:
          if (l = !1, v = _, isArray(_))
            if (_.length === 0)
              u.length && (u = udomdiff(
                a.parentNode,
                u,
                [],
                diffable,
                a
              ));
            else
              switch (typeof _[0]) {
                case "string":
                case "number":
                case "boolean":
                  p(String(_));
                  break;
                case "function":
                  p(_.map(invoke, a));
                  break;
                case "object":
                  isArray(_[0]) && (_ = _.concat.apply([], _));
                default:
                  u = udomdiff(
                    a.parentNode,
                    u,
                    _,
                    diffable,
                    a
                  );
                  break;
              }
          else
            "ELEMENT_NODE" in _ ? u = udomdiff(
              a.parentNode,
              u,
              _.nodeType === 11 ? slice.call(_.childNodes) : [_],
              diffable,
              a
            ) : "text" in _ ? p(String(_.text)) : "any" in _ ? p(_.any) : "html" in _ ? u = udomdiff(
              a.parentNode,
              u,
              slice.call(
                createContent(
                  [].concat(_.html).join(""),
                  c
                ).childNodes
              ),
              diffable,
              a
            ) : "length" in _ && p(slice.call(_));
          break;
      }
    };
    return p;
  },
  // style or textareas don't accept HTML as content
  // it's pointless to transform or analyze anything
  // different from text there but it's worth checking
  // for possible defined intents.
  text(a) {
    let u;
    const c = (l) => {
      if (u !== l) {
        u = l;
        const v = typeof l;
        v === "object" && l ? "text" in l ? c(String(l.text)) : "any" in l ? c(l.any) : "html" in l ? c([].concat(l.html).join("")) : "length" in l && c(slice.call(l).join("")) : v === "function" ? c(l(a)) : a.textContent = l ?? "";
      }
    };
    return c;
  }
};
function invoke(a) {
  return a(this);
}
const { create: create$1, freeze, keys } = Object, cache = umap(new WeakMap$1()), createRender = (a) => ({
  html: outer("html", a),
  svg: outer("svg", a),
  render(u, c) {
    const l = typeof c == "function" ? c() : c, v = cache.get(u) || cache.set(u, createCache()), p = l instanceof LighterHole ? unroll(a, v, l) : l;
    return p !== v.wire && (v.wire = p, u.textContent = "", u.appendChild(p.valueOf())), u;
  }
}), createCache = () => ({ stack: [], entry: null, wire: null }), outer = (a, u) => {
  const c = umap(new WeakMap$1()), l = (p) => function() {
    return unroll(u, p, v.apply(null, arguments));
  };
  return v.for = (p, _) => {
    const k = c.get(p) || c.set(p, create$1(null));
    return k[_] || (k[_] = l(createCache()));
  }, v.node = function() {
    return unroll(
      u,
      createCache(),
      v.apply(null, arguments)
    ).valueOf();
  }, v;
  function v() {
    return new LighterHole(a, tta.apply(null, arguments));
  }
}, unroll = (a, u, { type: c, template: l, values: v }) => {
  const { length: p } = v;
  unrollValues(a, u, v, p);
  let { entry: _ } = u;
  if (!_ || _.template !== l || _.type !== c) {
    const k = new a(c);
    u.entry = _ = {
      type: c,
      template: l,
      tag: k,
      wire: persistent(k(l, ...v))
    };
  } else
    _.tag(l, ...v);
  return _.wire;
}, unrollValues = (a, { stack: u }, c, l) => {
  for (let v = 0; v < l; v++) {
    const p = c[v];
    p instanceof Hole ? c[v] = unroll(
      a,
      u[v] || (u[v] = createCache()),
      p
    ) : isArray(p) ? unrollValues(
      a,
      u[v] || (u[v] = createCache()),
      p,
      p.length
    ) : u[v] = null;
  }
  l < u.length && u.splice(l);
};
freeze(LighterHole);
function LighterHole(a, u) {
  this.type = a, this.template = u.shift(), this.values = u;
}
const Hole = LighterHole, { render: render$1, html, svg } = createRender(Tagger);
function tta() {
  let a = [], u = 0, { length: c } = arguments;
  for (; u < c; )
    a.push(arguments[u++]);
  return a;
}
const getPresetStyle = (a) => {
  const c = getProject(CoreContext.state.activeProjectId).compositor.getRoot(), {
    x: l,
    y: v
  } = c.props.size, p = 1, _ = 633 * p / l * 100, k = 290 * p / v * 100, O = {
    position: "absolute",
    width: `${_}%`,
    height: `${k}%`
  };
  switch (a) {
    case "center":
      return {
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        margin: "auto",
        ...O
      };
    case "top-left":
      return {
        top: 0,
        left: 0,
        ...O
      };
    case "top-right":
      return {
        top: 0,
        right: 0,
        ...O
      };
    case "top-center":
      return {
        top: 0,
        left: "50%",
        transform: "translateX(-50%)",
        ...O
      };
    case "bottom-left":
      return {
        bottom: 0,
        left: 0,
        ...O
      };
    case "bottom-right":
      return {
        bottom: 0,
        right: 0,
        ...O
      };
    case "bottom-center":
      return {
        bottom: 0,
        left: "50%",
        transform: "translateX(-50%)",
        ...O
      };
    case "center-left":
      return {
        top: "50%",
        left: 0,
        transform: "translateY(-50%)",
        ...O
      };
    case "center-right":
      return {
        top: "50%",
        right: 0,
        transform: "translateY(-50%)",
        ...O
      };
  }
}, Free = {
  name: "Free",
  layout: ({
    props: a,
    children: u,
    size: c
  }) => u.reduce((l, v) => {
    const {
      size: p = {
        x: "100%",
        y: "100%"
      },
      position: _ = {
        x: 0,
        y: 0
      },
      opacity: k = 1
    } = v.props;
    return {
      ...l,
      [v.id]: {
        position: {
          x: _.x,
          y: _.y
        },
        size: {
          x: p.x,
          y: p.y
        },
        opacity: k
      }
    };
  }, {})
}, Column = {
  name: "Column",
  layout: ({
    props: a = {},
    children: u,
    size: c
  }) => {
    let {
      justify: l = "center",
      align: v = "center",
      cover: p = !1,
      margin: _ = {},
      dimensions: k = 16 / 9,
      reverse: O = !1,
      entryTransition: D = () => ({}),
      exitTransition: F = () => ({})
    } = a;
    const z = p ? 0 : Math.min(c.y / 6, 12);
    _ = {
      left: z,
      right: z,
      top: z,
      bottom: z,
      between: z,
      ..._
    };
    const j = c.y - _.top - _.bottom, ee = c.x - _.left - _.right, X = _.between * ((u.length || 1) - 1), ae = Math.min(ee, (j - X) / (u.length || 1) * k), Q = ae / k;
    return html.node`
      <div style=${{
      height: "100%",
      width: p ? c.x + "px" : "auto",
      display: "flex",
      flexDirection: O ? "column-reverse" : "column",
      justifyContent: l,
      alignItems: v,
      paddingLeft: _.left + "px",
      paddingTop: _.top + "px",
      paddingBottom: _.bottom + "px",
      paddingRight: _.right + "px"
    }}>
      ${u.map((ne, Z) => html.node`<div data-node-id=${ne.id} .data=${{
      entryTransition: {
        delay: 400 + Z * 100,
        offset: {
          x: 0,
          y: "100%"
        },
        scale: {
          x: 0.8,
          y: 0.8
        },
        opacity: 0,
        ...D(Z)
      },
      exitTransition: {
        offset: {
          x: 0,
          y: 1e3
        },
        scale: {
          x: 0.8,
          y: 0.8
        },
        opacity: 0,
        ...F(Z)
      },
      borderRadius: p ? 0 : 5
    }} style=${{
      display: "flex",
      width: p ? "100%" : ae + "px",
      height: p ? Q + "px" : "auto",
      aspectRatio: k,
      marginBottom: Z === u.length - 1 ? 0 : _.between + "px",
      flexGrow: 0,
      flexShrink: 1,
      flexBasis: Q + "px"
    }}></div>`)}
      </div>
    `;
  }
}, Row = {
  name: "Row",
  layout: ({
    props: a = {},
    children: u,
    size: c
  }) => {
    let {
      justify: l = "center",
      align: v = "center",
      cover: p = !1,
      margin: _ = {},
      dimensions: k,
      maxWidth: O = 1,
      reverse: D = !1,
      entryTransition: F = () => ({}),
      exitTransition: z = () => ({})
    } = a;
    const j = p ? 0 : Math.min(c.y / 6, 12);
    _ = {
      left: j,
      right: j,
      top: j,
      bottom: j,
      between: j,
      ..._
    };
    const ee = c.y - _.top - _.bottom, X = c.x - _.left - _.right, ae = _.between * ((u.length || 1) - 1);
    let Q = ee, ne = Math.min((X - ae) / (u.length || 1), k ? ee * k : X, O * c.x);
    return k && (Q = ne / k), html.node`
      <div style=${{
      height: p ? c.y + "px" : "auto",
      width: "100%",
      display: "flex",
      flexDirection: D ? "row-reverse" : "row",
      justifyContent: l,
      alignItems: v,
      paddingLeft: _.left + "px",
      paddingTop: _.top + "px",
      paddingBottom: _.bottom + "px",
      paddingRight: _.right + "px"
    }}>
          ${u.map((Z, de) => html.node`<div data-node-id=${Z.id} .data=${{
      entryTransition: {
        delay: 400 + de * 100,
        offset: {
          x: 0,
          y: "100%"
        },
        scale: {
          x: 0.8,
          y: 0.8
        },
        opacity: 0,
        ...F(de)
      },
      exitTransition: {
        offset: {
          x: 0,
          y: 1e3
        },
        scale: {
          x: 0.8,
          y: 0.8
        },
        opacity: 0,
        ...z(de)
      },
      borderRadius: p ? 0 : 5
    }} style=${{
      display: "flex",
      height: p ? "100%" : Q + "px",
      width: ne + "px",
      marginRight: de === u.length - 1 ? 0 : _.between + "px",
      flexGrow: 0,
      flexShrink: 1,
      flexBasis: ne + "px"
    }}></div>`)}
      </div>
    `;
  }
}, toMatrix = (a, u) => a.reduce((c, l, v) => (v % u == 0 ? c.push([v]) : c[c.length - 1].push(v)) && c, []), Grid = {
  name: "Grid",
  layout: ({
    props: a = {},
    children: u,
    size: c
  }) => {
    let {
      dimensions: l,
      numPerRow: v,
      margin: p,
      cover: _ = !1,
      maxWidth: k,
      between: O
    } = a;
    const D = u.length === 0 || _ ? 0 : O || Math.min(c.y / u.length / 10, 30);
    p = p ?? D;
    const F = c.x < c.y;
    O = typeof O == "number" ? O : p;
    let z = [];
    v ? z = toMatrix(u, v) : z = F ? getTallGrid(u.length) : getWideGrid(u.length);
    const j = (c.y - (p * 2 + O * (z.length - 1))) / z.length, ee = c.x - p * 2;
    return html.node`
    <div style=${{
      display: "flex",
      width: "100%",
      height: "100%",
      flexDirection: "column",
      justifyContent: "center",
      padding: p + "px",
      gap: O + "px",
      flexGrow: 0
    }}>${z.map((X, ae) => Row.layout({
      props: {
        justify: "center",
        dimensions: l,
        cover: _,
        maxWidth: k || 1 / (z[0].length || 1),
        margin: {
          top: 0,
          right: 0,
          left: 0,
          bottom: 0,
          between: O
        }
      },
      children: X.map((Q) => u[Q]),
      size: {
        y: j,
        x: ee
      }
    }))}</div>`;
  }
}, Presentation = {
  name: "Presentation",
  layout: ({
    props: a = {},
    children: u,
    size: c
  }) => {
    let {
      margin: l,
      cover: v = !1,
      barWidth: p = 0.2,
      barOrientation: _ = "vertical",
      presentationDimensions: k = 16 / 9,
      viewerDimensions: O = 16 / 9,
      justifyViewers: D = "center",
      useGrid: F = !1,
      reverse: z = !1
    } = a;
    const j = _ === "vertical" ? c.x * p : c.y * p, ee = u[0], X = u.filter((Te) => Te !== ee), ae = u.length <= 1 ? 0 : Math.min(c.x / 80, 30);
    if (l = l ?? ae, !ee)
      return Grid.layout({
        props: a,
        children: u,
        size: c
      });
    const Q = u[1], ne = {
      ...c
    };
    Q && (_ === "vertical" ? (ne.x = c.x - j, ne.y = ne.x / k) : (ne.y = c.y - j, ne.x = ne.y * k));
    let Z, de = {};
    F ? (Z = Grid.layout, de = {
      cover: v,
      ...v ? {
        maxWidth: 1
      } : {
        margin: l
      }
    }) : (Z = _ === "vertical" ? Column.layout : Row.layout, de = {
      margin: {
        top: l,
        left: l,
        bottom: l,
        right: l,
        between: l
      },
      dimensions: O,
      justify: D,
      align: "flex-end",
      entryTransition: () => ({
        offset: _ === "vertical" ? {
          x: z ? "-100%" : "100%",
          y: 0
        } : {
          x: 0,
          y: z ? "-100%" : "100%"
        }
      }),
      exitTransition: () => ({
        offset: _ === "vertical" ? {
          x: z ? -1e3 : 1e3,
          y: 0
        } : {
          x: 0,
          y: z ? -1e3 : 1e3
        }
      })
    });
    const fe = _ === "vertical" ? z ? "left" : "right" : z ? "top" : "bottom";
    return html.node`
      <div style=${{
      display: "flex",
      flexDirection: (_ === "vertical" ? "row" : "column") + (z ? "-reverse" : ""),
      justifyContent: "space-around",
      alignItems: "center",
      position: "relative",
      padding: v ? 0 : l,
      [`padding-${fe}`]: 0
    }}>
        ${u[0] && html.node`<div style=${{
      // aspectRatio: String(presentationDimensions),
      width: ne.x,
      height: ne.y,
      display: "flex",
      flexGrow: 1
    }}>
            <div data-node-id=${ee.id} .data=${{
      dimensions: k,
      borderRadius: v ? 0 : 5,
      entryTransition: {
        delay: 0,
        offset: {
          x: 0,
          y: 1e3
        },
        scale: {
          x: 0.5,
          y: 0.5
        },
        opacity: 0
      },
      exitTransition: {
        offset: {
          x: 0,
          y: 1e3
        },
        scale: {
          x: 2,
          y: 2
        },
        opacity: 0
      }
    }} style=${{
      width: "100%",
      height: "100%",
      ...v ? {
        position: "absolute",
        top: 0,
        left: 0,
        width: F && Q ? 100 - p * 100 + "%" : "100%",
        height: "100%"
      } : {}
    }} />
          </div>`}
        ${html.node`<div style=${{
      ..._ === "vertical" ? {
        maxWidth: p * 100 + "%",
        height: "100%"
      } : {
        maxHeight: p * 100 + "%",
        width: "100%"
      }
    }}>${Q && Z({
      props: de,
      children: X,
      size: _ === "vertical" ? {
        x: j,
        y: c.y
      } : {
        x: c.x,
        y: j
      }
    })}</div>`}
      </div>
    `;
  }
}, Layered = {
  name: "Layered",
  layout: ({
    props: a = {},
    children: u,
    size: c
  }) => html.node`<div style=${{
    width: "100%",
    height: "100%",
    position: "relative"
  }}>
      ${u.map((l, v) => html.node`<div data-node-id=${l.id} .data=${{
    zIndex: v + 1
  }} style=${{
    position: "absolute",
    ...a.type !== "alert" ? {
      inset: "0px"
    } : {},
    ...a.type === "alert" ? getPresetStyle(a.preset) : {}
  }}></div>`)}
    </div>`
}, getWideGrid = (a = 0) => {
  switch (a) {
    case 0:
      return [[]];
    case 1:
      return [[0]];
    case 2:
      return [[0, 1]];
    case 3:
      return [[0, 1], [2]];
    case 4:
      return [[0, 1], [2, 3]];
    case 5:
      return [[0, 1, 2], [3, 4]];
    case 6:
      return [[0, 1, 2], [3, 4, 5]];
    case 7:
      return [[0, 1, 2], [3, 4, 5], [6]];
    case 8:
      return [[0, 1, 2], [3, 4, 5], [6, 7]];
  }
  const u = Array(a).fill(null).map((c, l) => l);
  return toMatrix(u, Math.round(Math.sqrt(a)));
}, getTallGrid = (a = 0) => {
  switch (a) {
    case 0:
      return [[]];
    case 1:
      return [[0]];
    case 2:
      return [[0], [1]];
    case 3:
      return [[0, 1], [2]];
    case 4:
      return [[0, 1], [2, 3]];
    case 5:
      return [[0, 1], [2, 3], [4]];
    case 6:
      return [[0, 1], [2, 3], [4, 5]];
    case 7:
      return [[0, 1], [2, 3], [4, 5], [6]];
    case 8:
      return [[0, 1], [2, 3], [4, 5], [6, 7]];
  }
  const u = Array(a).fill(null).map((c, l) => l);
  return toMatrix(u, Math.ceil(Math.sqrt(u.length)) - 1);
}, Layouts = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Column,
  Free,
  Grid,
  Layered,
  Presentation,
  Row
}, Symbol.toStringTag, { value: "Module" })), deviceWatchers = /* @__PURE__ */ new Set(), updateMediaStreamTracks = (a, u) => {
  const c = {
    audio: a.getAudioTracks()[0],
    video: a.getVideoTracks()[0]
  };
  c.audio !== u.audio && (c.audio && a.removeTrack(c.audio), u.audio && a.addTrack(u.audio)), c.video !== u.video && (c.video && a.removeTrack(c.video), u.video && a.addTrack(u.video));
}, getDevicePermissions = async () => {
  const a = {
    audio: !0,
    video: !0
  };
  return Promise.all([navigator.mediaDevices.getUserMedia({
    video: !0
  }).then((u) => {
    u.getTracks().forEach((c) => c.stop());
  }).catch((u) => {
    u.name === "NotAllowedError" && (a.video = !1);
  }), navigator.mediaDevices.getUserMedia({
    audio: !0
  }).then((u) => {
    u.getTracks().forEach((c) => c.stop());
  }).catch((u) => {
    u.name === "NotAllowedError" && (a.audio = !1);
  })]).then(() => a);
}, ensureDevicePermissions = async () => getDevicePermissions(), watchDevices = (a) => (deviceWatchers.size === 0 && navigator.mediaDevices.addEventListener("devicechange", reportDevices), deviceWatchers.add(a), reportDevices().catch(() => {
}), () => {
  deviceWatchers.delete(a), deviceWatchers.size === 0 && navigator.mediaDevices.removeEventListener("devicechange", reportDevices);
}), getUserMedia = async (...a) => {
  const u = await navigator.mediaDevices.getUserMedia(...a);
  return reportDevices(), u;
}, deviceWithDefaultLabel = (a, u) => ({
  deviceId: a.deviceId,
  groupId: a.groupId,
  kind: a.kind,
  label: a.label || u
}), reportDevices = async () => {
  const a = await navigator.mediaDevices.enumerateDevices(), u = a.filter((v) => v.kind === "videoinput").map((v, p) => deviceWithDefaultLabel(v, "Camera " + (p + 1))), c = a.filter((v) => v.kind === "audioinput").map((v, p) => deviceWithDefaultLabel(v, "Microphone " + (p + 1))), l = a.filter((v) => v.kind === "audiooutput").map((v, p) => deviceWithDefaultLabel(v, "Speaker " + (p + 1)));
  deviceWatchers.forEach((v) => v({
    webcams: u,
    microphones: c,
    speakers: l
  }));
}, webrtc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ensureDevicePermissions,
  getDevicePermissions,
  getUserMedia,
  updateMediaStreamTracks,
  watchDevices
}, Symbol.toStringTag, { value: "Module" })), RoomParticipant$1 = {
  type: "RoomParticipant",
  valueType: MediaStream,
  props: {
    id: {},
    type: {},
    // 'screen' | 'camera'
    videoEnabled: {},
    audioEnabled: {}
  },
  init({
    addSource: a,
    removeSource: u,
    updateSource: c,
    getSource: l
  }) {
    CoreContext.on("RoomJoined", ({
      room: v
    }) => {
      let p = {}, _ = [], k = [], O = {};
      const D = () => {
        _.filter((F) => (F == null ? void 0 : F.type) === "camera" && (F == null ? void 0 : F.isExternal) === !0).forEach((F) => {
          var z, j, ee;
          if (F.type === "camera") {
            const X = O[F.id], ae = v.getParticipant(F.participantId), Q = v.getTrack(F.id);
            if (l(F == null ? void 0 : F.id)) {
              const Z = v.getTrack((z = ae == null ? void 0 : ae.meta[F.id]) == null ? void 0 : z.microphone);
              updateMediaStreamTracks(X, {
                video: Q == null ? void 0 : Q.mediaStreamTrack,
                audio: Z == null ? void 0 : Z.mediaStreamTrack
              }), c(F.id, {
                videoEnabled: !!(Q && !Q.isMuted),
                audioEnabled: !!(Z && !Z.isMuted),
                displayName: ((j = ae == null ? void 0 : ae.meta[F.id]) == null ? void 0 : j.displayName) || "External Track",
                mirrored: (ee = ae == null ? void 0 : ae.meta[F.id]) == null ? void 0 : ee.isMirrored,
                microphone: Z,
                external: F == null ? void 0 : F.isExternal
              });
            }
          }
        }), k.forEach((F) => {
          var de;
          const z = O[F.id], j = O[F.id + "-screen"], ee = F.trackIds.find((fe) => {
            const Te = v.getTrack(fe);
            return (Te == null ? void 0 : Te.type) === "camera" && !(Te != null && Te.isExternal);
          }), X = F.trackIds.find((fe) => {
            const Te = v.getTrack(fe);
            return (Te == null ? void 0 : Te.type) === "microphone" && !(Te != null && Te.isExternal);
          }), ae = F.trackIds.find((fe) => {
            const Te = v.getTrack(fe);
            return (Te == null ? void 0 : Te.type) === "screen_share";
          }), Q = v.getTrack(ee), ne = v.getTrack(X), Z = v.getTrack(ae);
          updateMediaStreamTracks(z, {
            video: Q == null ? void 0 : Q.mediaStreamTrack,
            audio: ne == null ? void 0 : ne.mediaStreamTrack
          }), updateMediaStreamTracks(j, {
            video: Z == null ? void 0 : Z.mediaStreamTrack
          }), c(F.id, {
            videoEnabled: !!(Q && !Q.isMuted),
            audioEnabled: !!(ne && !ne.isMuted),
            displayName: F.displayName,
            mirrored: (de = F == null ? void 0 : F.meta) == null ? void 0 : de.isMirrored,
            external: Q == null ? void 0 : Q.isExternal
          }), c(F.id + "-screen", {
            videoEnabled: !!(Z && !Z.isMuted),
            displayName: F.meta.screenDisplayName || `${F.displayName}'s Screen`
          });
        });
      };
      v.useTracks((F) => {
        const z = F.filter((ee) => !_.some((X) => X.id === ee.id) && !!(ee != null && ee.mediaStreamTrack)), j = _.filter((ee) => !F.some((X) => X.id === ee.id));
        _ = F.filter((ee) => !!(ee != null && ee.mediaStreamTrack)), z.forEach((ee) => {
          const X = new MediaStream([]);
          O[ee.id] = X;
          const {
            id: ae,
            participantId: Q,
            type: ne,
            mediaStreamTrack: Z
          } = v.getTrack(ee.id);
          Z && a({
            id: ae,
            isActive: !0,
            value: X,
            props: {
              id: ae,
              trackId: ae,
              participantId: Q,
              isMuted: ee.isMuted,
              type: ne
            }
          });
        }), j.forEach((ee) => {
          var X;
          u(ee.id), (X = p[ee.id]) == null || X.call(p);
        }), D();
      }), v.useParticipants((F) => {
        const z = F.filter((X) => !X.id.startsWith("source")), j = z.filter((X) => !k.some((ae) => ae.id === X.id)), ee = k.filter((X) => !z.some((ae) => ae.id === X.id));
        k = z, j.forEach((X) => {
          var Z;
          const {
            id: ae
          } = X, Q = new MediaStream([]), ne = new MediaStream([]);
          O[ae] = Q, O[ae + "-screen"] = ne, a({
            id: ae,
            isActive: !0,
            value: Q,
            props: {
              id: ae,
              type: "camera",
              displayName: X.displayName || X.id,
              audioEnabled: !1,
              videoEnabled: !1,
              mirrored: (Z = X == null ? void 0 : X.meta) == null ? void 0 : Z.isMirrored
            }
          }), a({
            id: ae + "-screen",
            isActive: !0,
            value: ne,
            props: {
              id: ae,
              type: "screen",
              displayName: X.displayName || X.id,
              audioEnabled: !1,
              videoEnabled: !1
            }
          });
        }), D(), ee.forEach((X) => {
          var ae;
          u(X.id), (ae = p[X.id]) == null || ae.call(p);
        });
      });
    });
  }
}, Banner$1 = {
  type: "Banner",
  valueType: Object,
  props: {},
  init({
    addSource: a,
    removeSource: u,
    updateSource: c,
    getSource: l,
    modifySourceValue: v
  }) {
    let p = [];
    const _ = (k = []) => {
      const O = k.filter((z) => !p.some((j) => j.id === z.id)), D = p.filter((z) => !k.some((j) => j.id === z.id)), F = k.filter((z) => {
        const j = p.find((ee) => ee.id === z.id);
        return !deepEqual(z, j);
      });
      O.forEach((z) => a({
        id: z.id,
        value: {
          headerText: z.props.headerText,
          bodyText: z.props.bodyText
        },
        // TODO: It feels odd to have "props" match "value" exactly.
        //  They probably shouldn't be necessary here.
        props: z.props
      })), D.forEach((z) => u(z.id)), F.forEach((z) => {
        c(z.id, z.props), v(z.id, (j) => {
          j.headerText = z.props.headerText, j.bodyText = z.props.bodyText;
        });
      }), p = k;
    };
    CoreContext.on("ActiveProjectChanged", ({
      projectId: k
    }) => {
      var D;
      if (p = [], !k)
        return;
      const O = getProject(k);
      _(((D = O.props) == null ? void 0 : D.banners) ?? []);
    }), CoreContext.on("ProjectChanged", ({
      project: k
    }) => {
      var O;
      _(((O = k.props) == null ? void 0 : O.banners) ?? []);
    });
  }
}, {
  state
} = CoreContext, updateUserProps = async (a) => {
  const u = getUser();
  if (!u)
    return;
  const c = {
    ...u.props,
    ...a.props
  }, l = await CoreContext.clients.LiveApi().collection.updateCollection({
    collectionId: u.id,
    updateMask: ["metadata"],
    metadata: {
      ...u.metadata,
      props: c
    }
  });
  await triggerInternal$1("UserChanged", l.collection);
}, createSource = async (a) => {
  const u = getUser().id, {
    source: c
  } = await CoreContext.clients.LiveApi().source.createSource({
    metadata: {
      props: a.props || {}
    },
    collectionId: u,
    address: a.address,
    preview: {
      webrtc: {
        enabled: !0,
        displayName: a.displayName || "RTMP Source"
      }
    }
  });
  await triggerInternal$1("SourceAdded", c);
  const l = await CoreContext.clients.LiveApi().source.addSourceToProject({
    collectionId: u,
    projectId: a.projectId,
    sourceId: c.sourceId
  });
  return await triggerInternal$1("ProjectSourceAdded", {
    projectId: l.project.projectId,
    source: c
  }), c;
}, updateSource = async (a) => {
  const u = getUser().id;
  let c = [], l = {};
  a.metadata && (c.push("metadata"), l.metadata = a.metadata), a.displayName && (c.push("preview.webrtc.displayName"), l = {
    ...l,
    preview: {
      webrtc: {
        displayName: a.displayName
      }
    }
  });
  const {
    source: v
  } = await CoreContext.clients.LiveApi().source.updateSource({
    collectionId: u,
    updateMask: c,
    sourceId: a.sourceId,
    ...l
  });
  return await triggerInternal$1("SourceChanged", v), v;
}, deleteSource = async (a) => {
  const u = getUser().id;
  await CoreContext.clients.LiveApi().source.removeSourceFromProject({
    collectionId: u,
    projectId: a.projectId,
    sourceId: a.sourceId
  }), await triggerInternal$1("ProjectSourceRemoved", {
    projectId: a.projectId,
    sourceId: a.sourceId
  });
  const c = await CoreContext.clients.LiveApi().source.deleteSource({
    sourceId: a.sourceId,
    collectionId: u
  });
  return await triggerInternal$1("SourceRemoved", a.sourceId), c;
}, createProject$1 = async (a = {}) => {
  const {
    props: u = {},
    size: c,
    settings: l = {},
    type: v
  } = a, p = await CoreContext.Request.createProject({
    settings: l,
    props: u,
    size: c,
    type: v
  });
  await triggerInternal$1("ProjectAdded", p.project);
  const _ = await hydrateProject(p.project, "ROLE_HOST");
  return toBaseProject(_);
}, recreateLayout = async (a) => {
  const {
    projectId: u,
    props: c = {}
  } = a, l = getUser().id, v = await CoreContext.clients.LiveApi().project.getProject({
    collectionId: l,
    projectId: u,
    status: !0
  });
  if ([ProjectBroadcastPhase.PROJECT_BROADCAST_PHASE_RUNNING, ProjectBroadcastPhase.PROJECT_BROADCAST_PHASE_STARTING].includes(v.status.phase))
    return;
  const p = v.project.metadata || {}, {
    layoutId: _
  } = p, {
    video: k
  } = v.project.rendering, {
    type: O
  } = v.project.metadata.props || {}, D = await CoreContext.Request.createLayout({
    collectionId: l,
    projectId: u,
    type: O || "sceneless",
    settings: {},
    size: {
      x: k.width,
      y: k.height
    }
  }), F = await CoreContext.clients.LiveApi().project.updateProject({
    collectionId: l,
    projectId: u,
    updateMask: ["metadata"],
    metadata: {
      ...p,
      layoutId: D.id
    }
  });
  CoreContext.log.debug("New layout assigned to project:", {
    layout: D
  }), await triggerInternal$1("ProjectChanged", {
    project: F.project
  }), await CoreContext.clients.LayoutApi().layout.deleteLayout({
    layoutId: _
  }), CoreContext.log.debug("Previous layout deleted:", {
    layoutId: _
  });
  const z = await hydrateProject(F.project, "ROLE_HOST");
  return await z.compositor.update(z.compositor.getRoot().id, c), {
    project: toBaseProject(z),
    internalProject: z
  };
}, deleteProject$1 = async (a) => {
  const {
    projectId: u
  } = a;
  await CoreContext.Request.deleteProject({
    projectId: u
  }), await triggerInternal$1("ProjectRemoved", {
    projectId: u
  });
}, updateProjectProps = async (a) => {
  const {
    projectId: u
  } = a, c = getUser().id, l = getProject(u), v = {
    ...l.props,
    ...a.props
  }, p = await CoreContext.clients.LiveApi().project.updateProject({
    collectionId: c,
    projectId: u,
    updateMask: ["metadata"],
    metadata: {
      ...l.videoApi.project.metadata,
      props: v
    }
  });
  await triggerInternal$1("ProjectChanged", {
    project: p.project
  });
}, updateProjectVideoRendering = async (a) => {
  var _;
  const {
    projectId: u,
    videoRendering: c
  } = a, l = getUser().id, v = getProject(u), p = await CoreContext.clients.LiveApi().project.updateProject({
    collectionId: l,
    projectId: u,
    updateMask: ["rendering.video"],
    rendering: {
      video: {
        ...((_ = v.videoApi.project.rendering) == null ? void 0 : _.video) ?? {},
        ...c
      }
    }
  });
  await triggerInternal$1("ProjectChanged", {
    project: p.project
  });
}, updateProjectPropsWithoutTrigger = async (a) => {
  const {
    projectId: u
  } = a, c = getUser().id, l = getProject(u), v = {
    ...l.props,
    ...a.props
  };
  await CoreContext.clients.LiveApi().project.updateProject({
    collectionId: c,
    projectId: u,
    updateMask: ["metadata"],
    metadata: {
      ...l.videoApi.project.metadata,
      props: v
    }
  });
}, setActiveProject = async (a) => {
  const u = state.projects.find((l) => l.id === a.projectId);
  if (!u) {
    state.activeProjectId = null, triggerInternal$1("ActiveProjectChanged", {
      projectId: null
    });
    return;
  }
  const c = state.projects.find((l) => l.id === state.activeProjectId);
  if (u !== c)
    return c && (Array.from(webrtcManager.rooms.keys()).map(webrtcManager.removeRoom), await CoreContext.clients.LayoutApi().unsubscribeFromLayout(c.layoutApi.layoutId), await CoreContext.clients.LiveApi().unsubscribeFromProject(c.videoApi.project.collectionId, c.videoApi.project.projectId), await CoreContext.clients.LiveApi().unsubscribeFromCollection(c.videoApi.project.collectionId)), await CoreContext.clients.LayoutApi().subscribeToLayout(u.layoutApi.layoutId), await CoreContext.clients.LiveApi().subscribeToProject(u.videoApi.project.collectionId, u.videoApi.project.projectId), await CoreContext.clients.LiveApi().subscribeToCollection(u.videoApi.project.collectionId), CoreContext.clients.LiveApi().project.getProject({
      collectionId: u.videoApi.project.collectionId,
      projectId: u.videoApi.project.projectId,
      status: !0
    }).then((l) => {
      var v, p;
      triggerInternal$1("ProjectChanged", {
        project: l.project,
        phase: (v = l.status) == null ? void 0 : v.phase,
        broadcastId: (p = l.status) == null ? void 0 : p.broadcastId
      });
    }), triggerInternal$1("ActiveProjectChanged", {
      projectId: u.id
    }), toBaseProject(u);
}, joinRoom = async (a) => {
  const {
    projectId: u,
    displayName: c = "Guest"
  } = a, l = state.projects.find((z) => z.id === u);
  let v = l.sfuToken;
  if (!v) {
    let {
      webrtcAccess: z
    } = await CoreContext.clients.LiveApi().authentication.createWebRtcAccessToken({
      collectionId: l.videoApi.project.collectionId,
      projectId: l.videoApi.project.projectId,
      displayName: c
    });
    v = z.accessToken;
  }
  const _ = jwtDecode(v).video.room, k = new URL(CoreContext.clients.getLiveKitServer()), O = k.host + k.pathname, D = webrtcManager.ensureRoom(O, _, v);
  D.bindApiClient(CoreContext.clients), await D.connect(), l.sfuToken = v, l.roomId = _;
  const F = getRoom(_);
  return trigger$1("RoomJoined", {
    projectId: l.id,
    room: F
  }), F;
}, createNode = async (a) => {
  let {
    props: u = {},
    parentId: c,
    index: l,
    projectId: v = state.activeProjectId
  } = a;
  const p = getProject(v), _ = await p.compositor.insert(u, c, l);
  return triggerInternal$1("NodeAdded", {
    projectId: v,
    nodeId: _
  }), triggerInternal$1("NodeChanged", {
    projectId: v,
    nodeId: c
  }), p.compositor.get(_);
}, deleteNode = async (a) => {
  var p;
  let {
    nodeId: u,
    projectId: c = state.activeProjectId
  } = a;
  const l = getProject(c), v = (p = l.compositor.getParent(u)) == null ? void 0 : p.id;
  l.compositor.remove(u), triggerInternal$1("NodeRemoved", {
    projectId: c,
    nodeId: u
  }), triggerInternal$1("NodeChanged", {
    projectId: c,
    nodeId: v
  });
}, updateNode = async (a) => {
  let {
    nodeId: u,
    props: c = {},
    projectId: l = state.activeProjectId
  } = a;
  const v = getProject(l);
  return delete c.type, delete c.sourceType, v.compositor.update(u, c), triggerInternal$1("NodeChanged", {
    projectId: l,
    nodeId: u
  }), v.compositor.get(u);
}, setNodeLayout = async (a) => {
  let {
    nodeId: u,
    layout: c,
    projectId: l = state.activeProjectId,
    layoutProps: v = {}
  } = a;
  getProject(l).compositor.update(u, {
    layout: c,
    layoutProps: v
  }), triggerInternal$1("NodeChanged", {
    projectId: l,
    nodeId: u
  });
}, moveNode = async (a) => {
  const {
    nodeId: u,
    parentId: c,
    projectId: l = state.activeProjectId,
    index: v
  } = a;
  getProject(l).compositor.move(u, c, v), triggerInternal$1("NodeChanged", {
    projectId: l,
    nodeId: u
  });
}, swapNodes = async (a) => {
  var k, O;
  const {
    nodeAId: u,
    nodeBId: c,
    projectId: l = state.activeProjectId
  } = a, v = getProject(l), p = (k = v.compositor.getParent(u)) == null ? void 0 : k.id, _ = (O = v.compositor.getParent(c)) == null ? void 0 : O.id;
  v.compositor.swap(u, c), triggerInternal$1("NodeChanged", {
    projectId: l,
    nodeId: p
  }), triggerInternal$1("NodeChanged", {
    projectId: l,
    nodeId: _
  });
}, reorderNodes = async (a) => {
  const {
    parentId: u,
    childIds: c,
    projectId: l = state.activeProjectId
  } = a;
  getProject(l).compositor.reorder(u, c), triggerInternal$1("NodeChanged", {
    projectId: l,
    nodeId: u
  });
}, startBroadcast = async (a) => {
  const {
    projectId: u = state.activeProjectId,
    dynamicSources: c,
    props: l
  } = a, v = getProject(u);
  await CoreContext.clients.LiveApi().project.startProjectBroadcast({
    collectionId: v.videoApi.project.collectionId,
    projectId: v.videoApi.project.projectId,
    ...c && {
      dynamicSources: c
    },
    ...l && {
      triggerMetadata: {
        ...l
      }
    }
  });
}, stopBroadcast = async (a) => {
  const {
    projectId: u = state.activeProjectId
  } = a, c = getProject(u);
  await CoreContext.clients.LiveApi().project.stopProjectBroadcast({
    collectionId: c.videoApi.project.collectionId,
    projectId: c.videoApi.project.projectId
  });
}, getBroadcastState = async (a) => {
  const {
    projectId: u
  } = a, c = getProject(u);
  return (await CoreContext.clients.LiveApi().project.getProjectBroadcastStatus({
    collectionId: c.videoApi.project.collectionId,
    projectId: c.videoApi.project.projectId
  })).status;
}, addDestination = async (a) => {
  var D;
  const {
    rtmpUrl: u,
    rtmpKey: c,
    enabled: l,
    projectId: v = state.activeProjectId,
    props: p = {}
  } = a, _ = getProject(v), k = {
    rtmpPush: {
      key: c,
      url: u
    }
  }, O = await ((D = CoreContext.clients.LiveApi().destination) == null ? void 0 : D.createDestination({
    collectionId: _.videoApi.project.collectionId,
    projectId: _.videoApi.project.projectId,
    address: k,
    enabled: l,
    metadata: {
      props: p
    }
  }));
  return await triggerInternal$1("DestinationAdded", O.destination), toBaseDestination(O.destination);
}, removeDestination = async (a) => {
  var v;
  const {
    destinationId: u,
    projectId: c = state.activeProjectId
  } = a, l = getProject(c);
  await ((v = CoreContext.clients.LiveApi().destination) == null ? void 0 : v.deleteDestination({
    collectionId: l.videoApi.project.collectionId,
    projectId: l.videoApi.project.projectId,
    destinationId: u
  })), await triggerInternal$1("DestinationRemoved", {
    projectId: c,
    destinationId: u
  });
}, updateDestination = async (a) => {
  var O;
  const {
    rtmpUrl: u,
    rtmpKey: c,
    destinationId: l,
    projectId: v = state.activeProjectId
  } = a, p = getProject(v), _ = {
    key: c,
    url: u
  }, k = await ((O = CoreContext.clients.LiveApi().destination) == null ? void 0 : O.updateDestination({
    collectionId: p.videoApi.project.collectionId,
    projectId: p.videoApi.project.projectId,
    destinationId: l,
    updateMask: ["address.rtmpPush"],
    address: {
      rtmpPush: _
    }
  }));
  await triggerInternal$1("DestinationChanged", k.destination);
}, updateDestinationProps = async (a) => {
  var k, O;
  const {
    projectId: u = state.activeProjectId,
    destinationId: c,
    props: l = {}
  } = a, v = getProject(u), p = v.videoApi.project.destinations.find((D) => D.destinationId === c);
  if (!p)
    return;
  const _ = await ((O = CoreContext.clients.LiveApi().destination) == null ? void 0 : O.updateDestination({
    collectionId: v.videoApi.project.collectionId,
    projectId: v.videoApi.project.projectId,
    destinationId: c,
    updateMask: ["metadata"],
    metadata: {
      ...p.metadata || {},
      props: {
        ...((k = p.metadata) == null ? void 0 : k.props) || {},
        ...l
      }
    }
  }));
  await triggerInternal$1("DestinationChanged", _.destination);
}, setDestinationEnabled = async (a) => {
  var k;
  const {
    enabled: u,
    destinationId: c,
    projectId: l = state.activeProjectId
  } = a, v = getProject(l);
  if (v.videoApi.project.destinations.find((O) => c === O.destinationId).enabled === u)
    return;
  const _ = await ((k = CoreContext.clients.LiveApi().destination) == null ? void 0 : k.updateDestination({
    collectionId: v.videoApi.project.collectionId,
    projectId: v.videoApi.project.projectId,
    destinationId: c,
    updateMask: ["enabled"],
    enabled: u
  }));
  await triggerInternal$1("DestinationChanged", _.destination);
}, setDestination = async (a) => {
  var k, O;
  const {
    rtmpUrl: u,
    rtmpKey: c,
    projectId: l = state.activeProjectId
  } = a, v = getProject(l), p = {
    key: c,
    url: u
  }, _ = !0;
  if (v.videoApi.project.destinations.length > 0) {
    const D = await ((k = CoreContext.clients.LiveApi().destination) == null ? void 0 : k.updateDestination({
      collectionId: v.videoApi.project.collectionId,
      projectId: v.videoApi.project.projectId,
      destinationId: v.videoApi.project.destinations[0].destinationId,
      updateMask: ["address.rtmpPush"],
      address: {
        rtmpPush: p
      }
    }));
    await triggerInternal$1("DestinationChanged", D.destination);
  } else {
    const D = await ((O = CoreContext.clients.LiveApi().destination) == null ? void 0 : O.createDestination({
      collectionId: v.videoApi.project.collectionId,
      projectId: v.videoApi.project.projectId,
      address: {
        rtmpPush: p
      },
      enabled: _
    }));
    await triggerInternal$1("DestinationAdded", D.destination);
  }
}, commands$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  addDestination,
  createNode,
  createProject: createProject$1,
  createSource,
  deleteNode,
  deleteProject: deleteProject$1,
  deleteSource,
  getBroadcastState,
  joinRoom,
  moveNode,
  recreateLayout,
  removeDestination,
  reorderNodes,
  setActiveProject,
  setDestination,
  setDestinationEnabled,
  setNodeLayout,
  startBroadcast,
  stopBroadcast,
  swapNodes,
  updateDestination,
  updateDestinationProps,
  updateNode,
  updateProjectProps,
  updateProjectPropsWithoutTrigger,
  updateProjectVideoRendering,
  updateSource,
  updateUserProps
}, Symbol.toStringTag, { value: "Module" })), useActiveProjectRoom$1 = () => {
  const [a, u] = useState(null);
  return useEffect(() => useActiveProjectRoom(u), []), a;
}, useDevices = () => {
  const [a, u] = useState({
    webcams: [],
    microphones: [],
    speakers: []
  });
  return useEffect(() => watchDevices(u), []), a;
}, StudioContext = React.createContext({
  studio: null,
  project: null,
  room: null,
  webcamId: null,
  microphoneId: null,
  setStudio: () => {
  },
  setProject: () => {
  },
  setRoom: () => {
  },
  setWebcamId: () => {
  },
  setMicrophoneId: () => {
  },
  projectCommands: {}
}), useStudio = () => useContext(StudioContext);
let stored = {
  webcamId: null,
  microphoneId: null
};
try {
  stored.webcamId = localStorage == null ? void 0 : localStorage.getItem("__LS_webcam"), stored.microphoneId = localStorage == null ? void 0 : localStorage.getItem("__LS_microphone");
} catch {
}
const StudioProvider = ({
  children: a
}) => {
  const [u, c] = useState(), [l, v] = useState(), [p, _] = useState(), [k, O] = useState(stored.webcamId), [D, F] = useState(stored.microphoneId), z = useMemo(() => l ? commands(l) : null, [l]);
  return useEffect(() => {
  }, [l]), useEffect(() => {
    u && (k && u.setCamera({
      deviceId: k
    }).catch((j) => {
      console.warn(j);
    }), D && u.setMicrophone({
      deviceId: D
    }).catch((j) => {
      console.warn(j);
    }));
  }, [u, k, D]), /* @__PURE__ */ React.createElement(StudioContext.Provider, {
    value: {
      studio: p,
      project: l,
      room: u,
      webcamId: k,
      microphoneId: D,
      setStudio: _,
      setProject: v,
      setRoom: c,
      setWebcamId: (j) => {
        try {
          localStorage == null || localStorage.setItem("__LS_webcam", j);
        } catch {
        }
        O(j);
      },
      setMicrophoneId: (j) => {
        try {
          localStorage == null || localStorage.setItem("__LS_microphone", j);
        } catch {
        }
        F(j);
      },
      projectCommands: z
    }
  }, a);
}, react = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  StudioContext,
  StudioProvider,
  useActiveProjectRoom: useActiveProjectRoom$1,
  useDevices,
  useStudio
}, Symbol.toStringTag, { value: "Module" })), ForegroundLayers = [{
  name: "ImageIframeOverlayContainer",
  id: "fg-image-iframe",
  layout: "Free"
}, {
  name: "BannerContainer",
  id: "fg-banners",
  layout: "Column",
  layoutProps: {
    cover: !0
  }
}, {
  name: "AlertContainer",
  id: "alert",
  layout: "Layered",
  layoutProps: {
    type: "alert",
    preset: "center"
  }
}, {
  name: "VideoOverlayContainer",
  id: "fg-video",
  layout: "Free"
}, {
  name: "LogoContainer",
  layout: "Free",
  id: "logo"
}], defaultStyles = {
  custom: {
    display: "block"
  },
  alert: {
    display: "block",
    position: "absolute",
    top: 0,
    left: 0,
    bottom: 0,
    right: 0,
    margin: "auto",
    pointerEvents: "none"
  },
  video: {
    height: "100%",
    width: "100%"
  },
  image: {
    height: "100%",
    width: "100%"
  },
  logo: {
    objectFit: "contain",
    position: "unset"
  }
}, validateEachChildren = (a, u) => {
  let c = !0;
  return a.forEach((l) => {
    var v, p;
    (v = l.props) != null && v.sourceType && !u.includes((p = l.props) == null ? void 0 : p.sourceType) ? c = !1 : l.children.length > 0 && (c = c && validateEachChildren(l.children, u));
  }), c;
}, addingCache = {
  camera: /* @__PURE__ */ new Set(),
  screen: /* @__PURE__ */ new Set(),
  rtmp: /* @__PURE__ */ new Set(),
  game: /* @__PURE__ */ new Set()
}, ExternalSourceTypeMap = {
  rtmp: "RTMP",
  game: "Game"
}, commands = (a) => {
  var de, fe, Te, Re, Le;
  const u = a.id, c = a.scene.getRoot(), {
    Command: l
  } = CoreContext, v = c.children.find((be) => be.props.id === "bg"), p = c.children.find((be) => be.props.id === "content"), _ = c.children.find((be) => be.props.id === "foreground"), k = a.rendering.video;
  let O = (de = _ == null ? void 0 : _.children) == null ? void 0 : de.find((be) => be.props.id === "fg-image-iframe"), D = (fe = _ == null ? void 0 : _.children) == null ? void 0 : fe.find((be) => be.props.id === "logo"), F = (Te = _ == null ? void 0 : _.children) == null ? void 0 : Te.find((be) => be.props.id === "alert"), z = (Re = _ == null ? void 0 : _.children) == null ? void 0 : Re.find((be) => be.props.id === "fg-video");
  const j = getProject(a.id);
  let ee = (Le = _ == null ? void 0 : _.children) == null ? void 0 : Le.find((be) => be.props.id === "fg-banners");
  const X = async () => {
    var be, q;
    ((be = v == null ? void 0 : v.props) == null ? void 0 : be.layout) !== "Layered" && await j.compositor.update(v.id, {
      name: "Background",
      id: "bg",
      layout: "Layered"
    }), ((q = _ == null ? void 0 : _.props) == null ? void 0 : q.layout) !== "Layered" && await j.compositor.update(_.id, {
      id: "foreground",
      name: "Overlays",
      layout: "Layered"
    });
  }, ae = async () => {
    validateEachChildren(v.children, ["Background"]) || v.children.forEach(async (be) => {
      await CoreContext.Command.deleteNode({
        nodeId: be.id
      });
    });
  }, Q = async () => {
    const be = async () => {
      var E;
      if (ee)
        return ee.id;
      {
        const I = await j.compositor.insert({
          name: "BannerContainer",
          id: "fg-banners",
          layout: "Column",
          layoutProps: {
            cover: !0
          }
        }, _.id);
        return ee = (E = _ == null ? void 0 : _.children) == null ? void 0 : E.find((M) => M.id === I), I;
      }
    }, q = async () => {
      var E;
      if (O)
        return O.id;
      {
        const I = await j.compositor.insert({
          name: "ImageIframeOverlay",
          id: "fg-image-iframe",
          layout: "Free"
        }, _.id);
        return O = (E = _ == null ? void 0 : _.children) == null ? void 0 : E.find((M) => M.id === I), I;
      }
    }, J = async () => {
      var E;
      if (F)
        return F.id;
      {
        const I = await j.compositor.insert({
          name: "AlertContainer",
          id: "alert",
          layout: "Layered",
          layoutProps: {
            type: "alert",
            preset: "center"
          }
        }, _.id);
        return F = (E = _ == null ? void 0 : _.children) == null ? void 0 : E.find((M) => M.id === I), I;
      }
    }, C = async () => {
      var E;
      if (z)
        return z.id;
      {
        const I = await j.compositor.insert({
          name: "VideoOverlay",
          id: "fg-video",
          layout: "Free"
        }, _.id);
        return z = (E = _ == null ? void 0 : _.children) == null ? void 0 : E.find((M) => M.id === I), I;
      }
    }, S = async () => {
      var E;
      if (D)
        return D.id;
      {
        const I = await j.compositor.insert({
          name: "LogoContainer",
          layout: "Free",
          id: "logo"
        }, _.id);
        return D = (E = _ == null ? void 0 : _.children) == null ? void 0 : E.find((M) => M.id === I), I;
      }
    };
    try {
      const E = await Promise.all([be(), q(), J(), C(), S()]);
      await j.compositor.reorder(_.id, E);
    } catch {
    }
  }, ne = {
    getBackground() {
      return v;
    },
    getContent() {
      return p;
    },
    getForeground() {
      return _;
    },
    getLayout() {
      return p.props.layout;
    },
    getBanners() {
      var be;
      return ((be = getProject(a.id).props) == null ? void 0 : be.banners) || [];
    },
    getParticipants() {
      return p.children.filter((be) => be.props.sourceType === "RoomParticipant");
    },
    getLogo() {
      var be, q;
      return (q = (be = D == null ? void 0 : D.children[0]) == null ? void 0 : be.props) == null ? void 0 : q.id;
    },
    async updateLayoutProps(be, q, J) {
      l.setNodeLayout({
        nodeId: be,
        layout: q,
        layoutProps: {
          ...J
        }
      });
    },
    getVideoRendering() {
      return k;
    },
    async updateVideoRendering(be) {
      l.updateProjectVideoRendering({
        projectId: u,
        videoRendering: be
      });
    },
    async removeLogo() {
      const [be, ...q] = (D == null ? void 0 : D.children) || [];
      q.forEach((J) => {
        CoreContext.Command.deleteNode({
          nodeId: J.id
        });
      }), be && await CoreContext.Command.deleteNode({
        nodeId: be.id
      });
    },
    getImageOverlay() {
      var q, J;
      const be = (q = O == null ? void 0 : O.children) == null ? void 0 : q.find((C) => {
        var S, E;
        return ((E = (S = C == null ? void 0 : C.props) == null ? void 0 : S.sourceProps) == null ? void 0 : E.type) === "image";
      });
      return (J = be == null ? void 0 : be.props) == null ? void 0 : J.id;
    },
    getVideoOverlay() {
      var q, J;
      const be = (q = z == null ? void 0 : z.children) == null ? void 0 : q.find((C) => {
        var S, E;
        return ((E = (S = C == null ? void 0 : C.props) == null ? void 0 : S.sourceProps) == null ? void 0 : E.type) === "video";
      });
      return (J = be == null ? void 0 : be.props) == null ? void 0 : J.id;
    },
    autoPlayBackgroundVideo(be = {
      muted: !0,
      autoplay: !0
    }) {
      const q = v.children.find((J) => J.props.id === "bg-video");
      q && CoreContext.Command.updateNode({
        nodeId: q.id,
        props: {
          ...q.props,
          attributes: {
            ...q.props.attributes,
            ...be
          }
        }
      });
    },
    autoPlayVideoOverlay(be, q = {
      muted: !0,
      autoplay: !0
    }) {
      var C;
      const J = (C = z == null ? void 0 : z.children) == null ? void 0 : C.find((S) => {
        var E, I;
        return ((I = (E = S.props) == null ? void 0 : E.sourceProps) == null ? void 0 : I.id) === be;
      });
      J && J.props.sourceProps.type === "video" && CoreContext.Command.updateNode({
        nodeId: J.id,
        props: {
          ...J.props,
          attributes: {
            ...J.props.attributes,
            ...q
          }
        }
      });
    },
    getBackgroundMedia() {
      var q, J;
      return (J = (q = v.children.filter((C) => C)[0]) == null ? void 0 : q.props) == null ? void 0 : J.id;
    },
    getBackgroundImage() {
      var q;
      const be = v.children.find((J) => {
        var C, S;
        return ((S = (C = J.props) == null ? void 0 : C.sourceProps) == null ? void 0 : S.type) === "image";
      });
      return (q = be == null ? void 0 : be.props) == null ? void 0 : q.id;
    },
    getBackgroundVideo() {
      var q;
      const be = v.children.find((J) => {
        var C, S;
        return ((S = (C = J.props) == null ? void 0 : C.sourceProps) == null ? void 0 : S.type) === "video";
      });
      return (q = be == null ? void 0 : be.props) == null ? void 0 : q.id;
    },
    async addLogo(be, q) {
      const [J, ...C] = (D == null ? void 0 : D.children) || [];
      C.forEach((S) => {
        CoreContext.Command.deleteNode({
          nodeId: S.id
        });
      }), J ? await CoreContext.Command.updateNode({
        nodeId: J.id,
        props: {
          sourceType: "Logo",
          id: be,
          sourceProps: {
            ...q,
            meta: {
              style: {
                ...defaultStyles.logo
              },
              ...q.meta
            }
          }
        }
      }) : await CoreContext.Command.createNode({
        parentId: D == null ? void 0 : D.id,
        props: {
          sourceType: "Logo",
          id: be,
          sourceProps: {
            ...q,
            meta: {
              style: {
                ...defaultStyles.logo
              },
              ...q.meta
            }
          }
        }
      });
    },
    addBanner(be = {}) {
      var S;
      const q = be.meta || {}, J = {
        id: generateId(),
        props: {
          ...be,
          meta: q
        }
      }, C = ((S = getProject(u).props) == null ? void 0 : S.banners) || [];
      return l.updateProjectProps({
        projectId: u,
        props: {
          banners: [...C, J]
        }
      });
    },
    editBanner(be, q = {}) {
      const C = ne.getBanners().map((S) => S.id !== be ? S : {
        ...S,
        props: q
      });
      return l.updateProjectProps({
        projectId: u,
        props: {
          banners: C
        }
      });
    },
    removeBanner(be) {
      var J;
      const q = ne.getBanners();
      return (J = ee == null ? void 0 : ee.children) == null || J.forEach((C) => {
        C.props.bannerId === be && CoreContext.Command.deleteNode({
          nodeId: C.id
        });
      }), l.updateProjectProps({
        projectId: u,
        props: {
          banners: q.filter((C) => C.id !== be)
        }
      });
    },
    async setActiveBanner(be) {
      var S, E;
      const [q, ...{}] = (ee == null ? void 0 : ee.children) || [];
      ((E = (S = q == null ? void 0 : q.props) == null ? void 0 : S.sourceType) == null ? void 0 : E.toLowerCase()) === "chatoverlay" && await CoreContext.Command.deleteNode({
        nodeId: q.id
      });
      const [J, ...C] = (ee == null ? void 0 : ee.children) || [];
      if (C.forEach((I) => {
        CoreContext.Command.deleteNode({
          nodeId: I.id
        });
      }), J)
        CoreContext.Command.updateNode({
          nodeId: J.id,
          props: {
            sourceType: "Banner",
            bannerId: be
          }
        });
      else
        return CoreContext.Command.createNode({
          parentId: ee == null ? void 0 : ee.id,
          props: {
            sourceType: "Banner",
            bannerId: be
          }
        });
    },
    getActiveBanner() {
      var be, q, J;
      return ((J = (q = (be = ee.children) == null ? void 0 : be[0]) == null ? void 0 : q.props) == null ? void 0 : J.bannerId) ?? null;
    },
    async addChatOverlay(be, q) {
      var E, I;
      const [J, ...{}] = (ee == null ? void 0 : ee.children) || [];
      ((I = (E = J == null ? void 0 : J.props) == null ? void 0 : E.sourceType) == null ? void 0 : I.toLowerCase()) === "banner" && await CoreContext.Command.deleteNode({
        nodeId: J.id
      });
      const [C, ...S] = (ee == null ? void 0 : ee.children) || [];
      S.forEach((M) => {
        CoreContext.Command.deleteNode({
          nodeId: M.id
        });
      }), C ? await CoreContext.Command.updateNode({
        nodeId: C.id,
        props: {
          sourceType: "ChatOverlay",
          chatOverlayId: be,
          id: be,
          ...q
        }
      }) : await CoreContext.Command.createNode({
        parentId: ee == null ? void 0 : ee.id,
        props: {
          sourceType: "ChatOverlay",
          chatOverlayId: be,
          id: be,
          ...q
        }
      });
    },
    async removeChatOverlay(be) {
      var q;
      (q = ee == null ? void 0 : ee.children) == null || q.forEach(async (J) => {
        J.props.chatOverlayId === be && await CoreContext.Command.deleteNode({
          nodeId: J.id
        });
      });
    },
    getChatOverlay() {
      var be, q, J, C, S;
      return (J = (q = (be = ee.children) == null ? void 0 : be[0]) == null ? void 0 : q.props) != null && J.chatOverlayId && ((S = (C = ee.children) == null ? void 0 : C[0]) == null ? void 0 : S.props) || null;
    },
    getCustomOverlay() {
      var q, J;
      const be = (q = O == null ? void 0 : O.children) == null ? void 0 : q.find((C) => {
        var S, E;
        return ((E = (S = C == null ? void 0 : C.props) == null ? void 0 : S.sourceProps) == null ? void 0 : E.type) === "custom";
      });
      return (J = be == null ? void 0 : be.props) == null ? void 0 : J.id;
    },
    async addImageOverlay(be, q) {
      const [J, ...C] = (O == null ? void 0 : O.children) || [];
      C.forEach((E) => {
        CoreContext.Command.deleteNode({
          nodeId: E.id
        });
      });
      const S = {
        ...defaultStyles.image,
        ...(z == null ? void 0 : z.children.length) && {
          opacity: 0
        }
      };
      J ? await CoreContext.Command.updateNode({
        nodeId: J == null ? void 0 : J.id,
        props: {
          sourceType: "Overlay",
          id: be,
          sourceProps: {
            ...q,
            type: "image",
            meta: {
              style: {
                ...S
              }
            }
          }
        }
      }) : await CoreContext.Command.createNode({
        parentId: O == null ? void 0 : O.id,
        props: {
          sourceType: "Overlay",
          id: be,
          sourceProps: {
            ...q,
            type: "image",
            meta: {
              style: {
                ...S
              }
            }
          }
        }
      });
    },
    async addVideoOverlay(be, q) {
      const [J, ...C] = (z == null ? void 0 : z.children) || [];
      C.forEach((S) => {
        CoreContext.Command.deleteNode({
          nodeId: S.id
        });
      }), O.children.forEach(({
        id: S,
        props: E
      }) => {
        var I, M;
        if (((M = (I = E.sourceProps.meta) == null ? void 0 : I.style) == null ? void 0 : M.opacity) !== 0) {
          const $ = E.sourceProps.type, U = {
            ...defaultStyles[$],
            opacity: 0
          };
          CoreContext.Command.updateNode({
            nodeId: S,
            props: {
              ...E,
              sourceProps: {
                ...E.sourceProps,
                meta: {
                  style: {
                    ...U
                  }
                }
              }
            }
          });
        }
      }), J ? await CoreContext.Command.updateNode({
        nodeId: J == null ? void 0 : J.id,
        props: {
          sourceType: "Overlay",
          id: be,
          sourceProps: {
            ...q,
            type: "video",
            meta: {
              style: {
                ...defaultStyles.video
              },
              ...q.meta
            }
          }
        }
      }) : await CoreContext.Command.createNode({
        parentId: z == null ? void 0 : z.id,
        props: {
          sourceType: "Overlay",
          id: be,
          sourceProps: {
            ...q,
            type: "video",
            meta: {
              style: {
                ...defaultStyles.video
              },
              ...q.meta
            }
          }
        }
      });
    },
    async updateVideoOverlayProps(be, q) {
      var C, S;
      const J = ((C = z == null ? void 0 : z.children) == null ? void 0 : C.find((E) => {
        var I;
        return ((I = E == null ? void 0 : E.props) == null ? void 0 : I.id) === be;
      })) || null;
      J && await CoreContext.Command.updateNode({
        nodeId: J == null ? void 0 : J.id,
        props: {
          sourceType: "Overlay",
          id: be,
          sourceProps: {
            ...(S = J == null ? void 0 : J.props) == null ? void 0 : S.sourceProps,
            ...q,
            meta: {
              style: {
                ...defaultStyles.video
              },
              ...q.meta
            }
          }
        }
      });
    },
    async addAlertOverlay(be, q) {
      const [J, ...C] = (F == null ? void 0 : F.children) || [];
      C.forEach((M) => {
        CoreContext.Command.deleteNode({
          nodeId: M.id
        });
      });
      const S = {
        ...defaultStyles.alert,
        ...(z == null ? void 0 : z.children.length) && {
          opacity: 0
        }
      }, {
        x: E
      } = c.props.size, I = (E ?? 1920) / 1920;
      J ? await CoreContext.Command.updateNode({
        nodeId: J == null ? void 0 : J.id,
        props: {
          sourceType: "Alert",
          id: be,
          sourceProps: {
            ...q,
            meta: {
              style: {
                ...S,
                transform: `scale(${I})`
              }
            }
          }
        }
      }) : await CoreContext.Command.createNode({
        parentId: F == null ? void 0 : F.id,
        props: {
          sourceType: "Alert",
          id: be,
          sourceProps: {
            ...q,
            meta: {
              style: {
                ...S,
                transform: `scale(${I})`
              }
            }
          }
        }
      });
    },
    async removeAlertOverlay() {
      var J;
      const [be, ...q] = (F == null ? void 0 : F.children) || [];
      q.forEach((C) => {
        CoreContext.Command.deleteNode({
          nodeId: C.id
        });
      }), be && ((J = be == null ? void 0 : be.props) == null ? void 0 : J.sourceType) === "Alert" && await CoreContext.Command.deleteNode({
        nodeId: be.id
      });
    },
    async addCustomOverlay(be, q) {
      const [J, ...C] = (O == null ? void 0 : O.children) || [];
      C.forEach((E) => {
        CoreContext.Command.deleteNode({
          nodeId: E.id
        });
      });
      const S = {
        ...defaultStyles.custom,
        ...(z == null ? void 0 : z.children.length) && {
          opacity: 0
        }
      };
      J ? await CoreContext.Command.updateNode({
        nodeId: J == null ? void 0 : J.id,
        props: {
          sourceType: "Overlay",
          id: be,
          sourceProps: {
            ...q,
            type: "custom",
            meta: {
              style: {
                ...S
              }
            }
          }
        }
      }) : await CoreContext.Command.createNode({
        parentId: O == null ? void 0 : O.id,
        props: {
          sourceType: "Overlay",
          id: be,
          sourceProps: {
            ...q,
            type: "custom",
            meta: {
              style: {
                ...S
              }
            }
          }
        }
      });
    },
    async removeCustomOverlay() {
      var J, C;
      const [be, ...q] = (O == null ? void 0 : O.children) || [];
      q.forEach((S) => {
        CoreContext.Command.deleteNode({
          nodeId: S.id
        });
      }), be && ((C = (J = be == null ? void 0 : be.props) == null ? void 0 : J.sourceProps) == null ? void 0 : C.type) === "custom" && await CoreContext.Command.deleteNode({
        nodeId: be.id
      });
    },
    async removeImageOverlay() {
      var J, C;
      const [be, ...q] = (O == null ? void 0 : O.children) || [];
      q.forEach((S) => {
        CoreContext.Command.deleteNode({
          nodeId: S.id
        });
      }), be && ((C = (J = be == null ? void 0 : be.props) == null ? void 0 : J.sourceProps) == null ? void 0 : C.type) === "image" && await CoreContext.Command.deleteNode({
        nodeId: be.id
      });
    },
    async removeVideoOverlay() {
      const [be, ...q] = (z == null ? void 0 : z.children) || [];
      q.forEach((J) => {
        CoreContext.Command.deleteNode({
          nodeId: J.id
        });
      }), be && await CoreContext.Command.deleteNode({
        nodeId: be.id
      }), O == null || O.children.forEach(({
        id: J,
        props: C
      }) => {
        var S, E;
        if (((E = (S = C.sourceProps.meta) == null ? void 0 : S.style) == null ? void 0 : E.opacity) === 0) {
          const I = C.sourceProps.type, M = {
            ...defaultStyles[I],
            opacity: 1
          };
          CoreContext.Command.updateNode({
            nodeId: J,
            props: {
              ...C,
              sourceProps: {
                ...C.sourceProps,
                meta: {
                  style: {
                    ...M
                  }
                }
              }
            }
          });
        }
      });
    },
    setLayout(be, q = {}) {
      const J = p.props.layoutProps.showcase;
      l.setNodeLayout({
        nodeId: p.id,
        layout: be,
        layoutProps: {
          showcase: J,
          ...q
        }
      });
    },
    async setBackgroundImage(be, q) {
      const [J, ...C] = (v == null ? void 0 : v.children) || [];
      C.forEach((S) => {
        CoreContext.Command.deleteNode({
          nodeId: S.id
        });
      }), J ? await CoreContext.Command.updateNode({
        nodeId: J.id,
        props: {
          id: be,
          sourceType: "Background",
          sourceProps: {
            ...q,
            type: "image",
            meta: {
              style: {
                ...defaultStyles.image
              },
              ...q == null ? void 0 : q.meta
            }
          }
        }
      }) : await CoreContext.Command.createNode({
        parentId: v == null ? void 0 : v.id,
        props: {
          id: be,
          sourceType: "Background",
          sourceProps: {
            ...q,
            type: "image",
            meta: {
              style: {
                ...defaultStyles.image
              },
              ...q == null ? void 0 : q.meta
            }
          }
        }
      });
    },
    async setBackgroundVideo(be, q) {
      const [J, ...C] = (v == null ? void 0 : v.children) || [];
      C.forEach((S) => {
        CoreContext.Command.deleteNode({
          nodeId: S.id
        });
      }), J ? await CoreContext.Command.updateNode({
        nodeId: J.id,
        props: {
          id: be,
          sourceType: "Background",
          sourceProps: {
            ...q,
            type: "video",
            meta: {
              style: {
                ...defaultStyles.video
              },
              ...q == null ? void 0 : q.meta
            }
          }
        }
      }) : await CoreContext.Command.createNode({
        parentId: v == null ? void 0 : v.id,
        props: {
          id: be,
          sourceType: "Background",
          sourceProps: {
            ...q,
            type: "video",
            meta: {
              style: {
                ...defaultStyles.video
              },
              ...q == null ? void 0 : q.meta
            }
          }
        }
      });
    },
    async updateBackgroundVideoProps(be, q) {
      var C, S;
      const J = ((C = v == null ? void 0 : v.children) == null ? void 0 : C.find((E) => {
        var I;
        return ((I = E == null ? void 0 : E.props) == null ? void 0 : I.id) === be;
      })) || null;
      J && await CoreContext.Command.updateNode({
        nodeId: J == null ? void 0 : J.id,
        props: {
          sourceType: "Background",
          id: be,
          sourceProps: {
            ...(S = J == null ? void 0 : J.props) == null ? void 0 : S.sourceProps,
            ...q,
            meta: {
              style: {
                ...defaultStyles.video
              },
              ...q.meta
            }
          }
        }
      });
    },
    async removeBackgroundImage() {
      const [be, ...q] = (v == null ? void 0 : v.children) || [];
      q.forEach((J) => {
        CoreContext.Command.deleteNode({
          nodeId: J.id
        });
      }), be && be.props.sourceProps.type === "image" && await CoreContext.Command.deleteNode({
        nodeId: be.id
      });
    },
    async removeBackgroundVideo() {
      const [be, ...q] = (v == null ? void 0 : v.children) || [];
      q.forEach((J) => {
        CoreContext.Command.deleteNode({
          nodeId: J.id
        });
      }), be && be.props.sourceProps.type === "video" && await CoreContext.Command.deleteNode({
        nodeId: be.id
      });
    },
    /* A function that takes in a sourceType and a callback function. It then creates a shallow copy of
      the root node and finds all the nodes that have the same sourceType as the one passed in. It then
      creates a listener for when the node changes, is added, or is removed. When any of these events
      happen, it will call the callback function with the new state. */
    useLayerState(be, q) {
      const J = cloneDeep$1(c);
      let C = findAll(J, ($) => $.props.sourceType === be);
      const S = () => {
        q((C == null ? void 0 : C.map(($) => $.props)) || {});
      }, E = CoreContext.onInternal("NodeChanged", ($) => {
        const U = C == null ? void 0 : C.find((T) => T.id === $.nodeId);
        if (C != null && C.length && !U)
          return;
        const Y = C, L = cloneDeep$1(c);
        C = findAll(L, (T) => {
          var B;
          return ((B = T == null ? void 0 : T.props) == null ? void 0 : B.sourceType) === be;
        }), deepEqual(Y, C) || S();
      }), I = CoreContext.onInternal("NodeAdded", ($) => {
        var T;
        if (C == null ? void 0 : C.find((B) => B.id === $.nodeId))
          return;
        const Y = cloneDeep$1(c);
        C = findAll(Y, (B) => {
          var te;
          return ((te = B == null ? void 0 : B.props) == null ? void 0 : te.sourceType) === be;
        });
        const L = C == null ? void 0 : C.find((B) => B.id === $.nodeId);
        ((T = L == null ? void 0 : L.props) == null ? void 0 : T.sourceType) === be && S();
      }), M = CoreContext.onInternal("NodeRemoved", ($) => {
        var Y;
        const U = C == null ? void 0 : C.find((L) => L.id === $.nodeId);
        U && (C = C == null ? void 0 : C.filter((L) => L.id !== $.nodeId), ((Y = U == null ? void 0 : U.props) == null ? void 0 : Y.sourceType) === be && S());
      });
      return S(), () => {
        E(), I(), M();
      };
    },
    setShowcase(be, q = "camera") {
      const J = ne.getParticipantNode(be, q);
      return CoreContext.Command.updateNode({
        nodeId: p.id,
        props: {
          layoutProps: {
            ...p.props.layoutProps,
            showcase: (J == null ? void 0 : J.id) ?? null
          }
        }
      });
    },
    useShowcase(be) {
      const q = () => {
        const J = p.props.layoutProps.showcase, C = p.children.find((E) => E.id === J);
        if (!C)
          return be({
            participantId: null,
            type: null
          });
        const {
          sourceProps: S
        } = C.props;
        return be({
          participantId: S.id,
          type: S.type
        });
      };
      return q(), CoreContext.onInternal("NodeChanged", (J) => {
        J.nodeId === p.id && q();
      });
    },
    async addSourceNode(be, q = {
      isMuted: !0,
      isHidden: !1,
      volume: 0
    }, J = "rtmp") {
      if (addingCache[J].has(be))
        return;
      const {
        isMuted: C = !1,
        isHidden: S = !1,
        volume: E = 1
      } = q;
      p.children.find((M) => {
        var $;
        return (($ = M.props.sourceProps) == null ? void 0 : $.id) === be;
      }) || (addingCache[J].add(be), await CoreContext.Command.createNode({
        props: {
          name: ExternalSourceTypeMap[J],
          sourceType: ExternalSourceTypeMap[J],
          sourceProps: {
            type: J,
            id: be
          },
          volume: E,
          isMuted: C,
          isHidden: S
        },
        parentId: p.id
      }).finally(() => {
        addingCache[J].delete(be);
      }));
    },
    async removeSourceNode(be) {
      const q = a.sources.find((C) => C.preview.webrtc.participantId === be);
      if (!q)
        return;
      const J = q.address.dynamic.id === "integration" ? ExternalSourceTypeMap.game : ExternalSourceTypeMap.rtmp;
      p.children.filter((C) => {
        var S;
        return ((S = C.props.sourceProps) == null ? void 0 : S.id) === be && C.props.sourceType === J;
      }).forEach((C) => {
        CoreContext.Command.deleteNode({
          nodeId: C.id
        });
      });
    },
    getSourceNode(be) {
      return p.children.find((q) => {
        var J;
        return ((J = q.props.sourceProps) == null ? void 0 : J.id) === be;
      });
    },
    useSourceNodes(be, q = "rtmp") {
      let J = [];
      const C = () => {
        const I = p.children.filter((M) => {
          var $, U;
          return ((U = ($ = M.props) == null ? void 0 : $.sourceProps) == null ? void 0 : U.type) === q;
        });
        return J = I.map((M) => M.id), be(I);
      };
      C();
      const S = CoreContext.onInternal("NodeChanged", (I) => {
        I.nodeId === p.id && C();
      }), E = CoreContext.onInternal("NodeRemoved", (I) => {
        J.indexOf(I.nodeId) !== -1 && C();
      });
      return () => {
        S(), E();
      };
    },
    async addParticipantTrack(be, q = {
      isMuted: !0,
      isHidden: !1,
      volume: 0
    }, J = "camera") {
      if (addingCache[J].has(be))
        return;
      const {
        isMuted: C = !1,
        isHidden: S = !1,
        volume: E = 1
      } = q;
      if (p.children.find((U) => {
        var Y, L;
        return ((Y = U.props.sourceProps) == null ? void 0 : Y.id) === be && ((L = U.props.sourceProps) == null ? void 0 : L.type) === J;
      }))
        return;
      addingCache[J].add(be);
      const M = p.children[0];
      let $ = p.children.length;
      J === "screen" && (M == null ? void 0 : M.props.sourceProps.type) !== "screen" && ($ = 0), await CoreContext.Command.createNode({
        props: {
          name: "Participant",
          sourceType: "RoomParticipant",
          sourceProps: {
            type: J,
            id: be
          },
          volume: E,
          isMuted: C,
          isHidden: S
        },
        parentId: p.id,
        index: $
      }).finally(() => {
        addingCache[J].delete(be);
      });
    },
    removeParticipantTrack(be, q = "camera") {
      p.children.filter((J) => {
        var C, S;
        return ((C = J.props.sourceProps) == null ? void 0 : C.id) === be && ((S = J.props.sourceProps) == null ? void 0 : S.type) === q && J.props.sourceType === "RoomParticipant";
      }).forEach((J) => {
        CoreContext.Command.deleteNode({
          nodeId: J.id
        });
      });
    },
    async addParticipant(be, q = {}, J = "camera") {
      if (addingCache[J].has(be))
        return;
      const {
        isMuted: C = !1,
        isHidden: S = !1,
        volume: E = 1
      } = q;
      if (p.children.find((U) => {
        var Y, L;
        return ((Y = U.props.sourceProps) == null ? void 0 : Y.id) === be && ((L = U.props.sourceProps) == null ? void 0 : L.type) === J;
      }))
        return;
      addingCache[J].add(be);
      const M = p.children[0];
      let $ = p.children.length;
      J === "screen" && (M == null ? void 0 : M.props.sourceProps.type) !== "screen" && ($ = 0), await CoreContext.Command.createNode({
        props: {
          name: "Participant",
          sourceType: "RoomParticipant",
          sourceProps: {
            type: J,
            id: be
          },
          volume: E,
          isMuted: C,
          isHidden: S
        },
        parentId: p.id,
        index: $
      }).finally(() => {
        addingCache[J].delete(be);
      });
    },
    removeParticipant(be, q = "camera") {
      p.children.filter((J) => {
        var C, S;
        return ((C = J.props.sourceProps) == null ? void 0 : C.id) === be && ((S = J.props.sourceProps) == null ? void 0 : S.type) === q && J.props.sourceType === "RoomParticipant";
      }).forEach((J) => {
        CoreContext.Command.deleteNode({
          nodeId: J.id
        });
      });
    },
    getParticipantNode(be, q = "camera") {
      return p.children.find((J) => {
        var C, S;
        return ((C = J.props.sourceProps) == null ? void 0 : C.id) === be && ((S = J.props.sourceProps) == null ? void 0 : S.type) === q;
      });
    },
    getParticipantState(be, q = "camera") {
      var J;
      return (J = ne.getParticipantNode(be, q)) == null ? void 0 : J.props;
    },
    useParticipantState(be, q, J = "camera") {
      let C = ne.getParticipantNode(be, J);
      const S = () => {
        q(C == null ? void 0 : C.props);
      }, E = CoreContext.onInternal("NodeChanged", (M) => {
        if (M.nodeId !== p.id)
          return;
        const $ = C;
        C = ne.getParticipantNode(be, J), $ !== C && S();
      }), I = CoreContext.onInternal("NodeChanged", (M) => {
        !C || M.nodeId !== C.id || S();
      });
      return S(), () => {
        E(), I();
      };
    },
    setParticipantVolume(be, q) {
      const J = ne.getParticipantNode(be);
      J && CoreContext.Command.updateNode({
        nodeId: J.id,
        props: {
          volume: q
        }
      });
    },
    setParticipantMuted(be, q) {
      const J = ne.getParticipantNode(be);
      J && CoreContext.Command.updateNode({
        nodeId: J.id,
        props: {
          isMuted: q
        }
      });
    },
    setParticipantHidden(be, q) {
      const J = ne.getParticipantNode(be);
      J && CoreContext.Command.updateNode({
        nodeId: J.id,
        props: {
          isHidden: q
        }
      });
    },
    pruneParticipants() {
      const be = getProjectRoom(u);
      be && p.children.filter((q) => {
        var M, $, U;
        if (q.props.sourceType !== "RoomParticipant")
          return !1;
        const J = (M = q.props.sourceProps) == null ? void 0 : M.type, C = be.getParticipant(($ = q.props.sourceProps) == null ? void 0 : $.id), S = be.getTrack((U = q.props.sourceProps) == null ? void 0 : U.id);
        return !C && !S ? !0 : J === "camera" ? !1 : !C.trackIds.map((Y) => be.getTrack(Y)).filter(Boolean).some((Y) => (Y.type === Track.Source.Camera || Y.type === Track.Source.Microphone ? "camera" : "screen") === J);
      }).forEach((q) => {
        CoreContext.Command.deleteNode({
          nodeId: q.id
        });
      });
    },
    getProp(be) {
      return getProject(a.id).props[be];
    },
    setProp(be, q) {
      return l.updateProjectProps({
        projectId: u,
        props: {
          [be]: q
        }
      });
    },
    useProp(be, q) {
      return CoreContext.on("ProjectChanged", (J) => {
        u === J.project.id && q(J.project.props[be]);
      });
    },
    createSource(be) {
      return CoreContext.Command.createSource({
        projectId: u,
        ...be
      });
    },
    deleteSource(be) {
      return CoreContext.Command.deleteSource({
        projectId: u,
        sourceId: be
      });
    },
    createGameSource(be) {
      if (!getProject(a.id).videoApi.project.sources.find((J) => {
        var C, S;
        return ((S = (C = J.address) == null ? void 0 : C.dynamic) == null ? void 0 : S.id) === "integration";
      }))
        return CoreContext.Command.createSource({
          projectId: u,
          ...be
        });
    }
  };
  return (async () => {
    await X(), await ae(), await Q();
  })(), ne;
}, create = async (a = {}, u = {}, c) => CoreContext.Command.createProject({
  settings: a,
  props: u,
  size: c
}), createCompositor = async (a, u, c) => {
  const {
    layout: l,
    layoutProps: v = {}
  } = c, p = await CoreContext.compositor.createProject({
    props: {
      name: "Root",
      type: "sceneless-project",
      sourceType: "Element",
      layout: "Layered",
      size: u,
      isRoot: !0,
      tagName: "div",
      version: "beta",
      fields: {
        style: {
          background: "black"
        }
      }
    }
  }, a), _ = p.getRoot(), k = await Promise.all([p.insert({
    name: "Background",
    id: "bg",
    layout: "Layered"
  }, _.id), p.insert({
    id: "content",
    name: "Content",
    layout: l,
    layoutProps: v
  }, _.id), p.insert({
    id: "foreground",
    name: "Overlays",
    layout: "Layered"
  }, _.id)]);
  await p.reorder(_.id, k);
  const O = _.children.find((z) => z.props.id === "foreground"), D = ForegroundLayers.map((z) => p.insert(z, O.id)), F = await Promise.all(D);
  return await p.reorder(O.id, F), p;
}, scenelessProject = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  commands,
  create,
  createCompositor
}, Symbol.toStringTag, { value: "Module" })), useActiveProjectRoom = (a) => {
  const u = getProject(CoreContext.state.activeProjectId);
  return a(u ? getRoom(u.roomId) : null), CoreContext.on("RoomJoined", () => {
    const c = getProject(CoreContext.state.activeProjectId);
    a(c ? getRoom(c.roomId) : null);
  });
}, callbacks = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  useActiveProjectRoom
}, Symbol.toStringTag, { value: "Module" })), index$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Callback: callbacks,
  React: react,
  Room: webrtc,
  ScenelessProject: scenelessProject
}, Symbol.toStringTag, { value: "Module" })), runFilters = (a, u = []) => u.reduce((c, l) => l(c), a), transforms = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  runFilters
}, Symbol.toStringTag, { value: "Module" })), createDefault = () => ({
  root: document.createElement("div")
}), init$2 = (a = {}, u, c) => {
  const l = {}, v = a.defaultTransforms || {}, p = (Q) => {
    asArray(Q).forEach((ne) => {
      l[ne.name] = ne;
    });
  }, _ = {}, k = {}, O = {}, D = (Q) => O[Q] || [], F = (Q) => k[Q] || [], z = (Q) => _[Q], j = (Q) => l[Q];
  u.on("SourceChanged", (Q) => {
    F(Q.id).forEach((Z) => {
      const de = u.getNode(Z.nodeId);
      Z._onUpdateHandlers.forEach((fe) => fe(de.props || {}));
    });
  }), u.on("AvailableSourcesChanged", ({
    type: Q,
    sources: ne
  }) => {
    D(Q).forEach((de) => {
      ee(de.nodeId);
    });
  });
  const ee = (Q) => {
    var q, J, C;
    const ne = z(Q);
    if (!ne)
      return;
    const Z = j(ne.transformName);
    if (!Z.useSource)
      return;
    const de = u.getNode(Q), fe = ne.sourceType, Te = c.getSources(fe), Re = Z.useSource(Te, de.props), Le = ne.sourceValue, be = Re == null ? void 0 : Re.value;
    ne.source !== Re && (k[(q = ne.source) == null ? void 0 : q.id] && (k[(J = ne.source) == null ? void 0 : J.id] = k[(C = ne.source) == null ? void 0 : C.id].filter((S) => S.nodeId !== Q)), k[Re == null ? void 0 : Re.id] = [...k[Re == null ? void 0 : Re.id] || [], ne]), ne.source = Re, ne.sourceValue = be, Object.is(Le, be) || ne._onNewSourceHandlers.forEach((S) => S(Re));
  }, X = (Q) => {
    const ne = ae(Q), de = runFilters(Q, []);
    return ee(Q.id), ne == null || ne._onUpdateHandlers.forEach((fe) => fe(Q.props || {})), {
      ...de,
      children: de.children.map(X)
    };
  }, ae = (Q) => {
    if (_[Q.id])
      return _[Q.id];
    const {
      props: ne = {}
    } = Q, {
      sourceType: Z
    } = ne;
    if (!Z)
      return null;
    let de = v[Z], fe;
    if (de ? fe = l[de] : fe = Object.values(l).find((E) => E.sourceType === Z), !fe)
      throw new Error("Could not find matching transform for sourceType: " + Z);
    const Te = [], Re = [], Le = [], be = [], J = {
      ...(fe.create || createDefault)({
        onEvent: (E, I, ...M) => {
          const $ = u.on(E, I, ...M);
          return be.push($), $;
        },
        onNewSource: (E) => Te.push(E),
        onUpdate: (E) => Re.push(E),
        onRemove: (E) => Le.push(E)
      }, Q.props),
      sourceType: Z,
      nodeId: Q.id,
      transformName: fe.name,
      _onNewSourceHandlers: Te,
      _onUpdateHandlers: Re,
      _disposables: be
    };
    _[Q.id] = J;
    const C = Z;
    O[C] = [...O[C] || [], J], fe.useSource && ee(Q.id);
    const S = [
      // Dispose when node is removed
      u.on("NodeRemoved", ({
        nodeId: E
      }) => {
        if (E === Q.id) {
          const I = u.getNode(E), {
            sourceType: M = "Element"
          } = I.props;
          S.forEach((U) => U == null ? void 0 : U()), be.forEach((U) => U == null ? void 0 : U()), Le.forEach((U) => U == null ? void 0 : U()), delete _[I.id];
          const $ = M;
          O[$] = O[$].filter((U) => U !== _[I.id]);
        }
      })
    ];
    return J;
  };
  return {
    transforms: l,
    nodeElementIndex: _,
    elementSourceTypeIndex: O,
    registerTransform: p,
    getElementsBySourceType: D,
    getElementByNodeId: z,
    getTransformByName: j,
    updateSourceForNode: ee,
    renderTree: X,
    getElement: ae
  };
}, TRANSITION_DURATION = 300, findLayoutUp = (a, u, c = 0) => {
  const v = a.parentElement;
  return v instanceof Layout && (c = 0, !u || u(v)) ? v : v ? c > 4 ? null : findLayoutUp(v, u, c + 1) : null;
}, TRANSITION_FIELDS = "opacity, transform, width, height, left, right, top, bottom, inset", layoutIndex = {}, parentIdIndex = {}, childIndex = {};
let rootLayout, _cid = 1;
const ignoredAttributes = ["style", "id", "className"];
let tickOps = {};
const tick = () => {
  nextTick = null;
  const a = /* @__PURE__ */ new Set(), u = /* @__PURE__ */ new Set(), c = /* @__PURE__ */ new Set();
  Object.entries(tickOps).forEach(([l, v]) => {
    v.forEach(([p, _, k]) => {
      switch (p) {
        case "childInserted": {
          u.has(k) ? u.delete(k) : a.add(k);
          break;
        }
        case "childRemoved": {
          a.has(k) ? a.delete(k) : u.add(k);
          break;
        }
        case "childRemoveFinished": {
          c.add(k);
          break;
        }
      }
    });
  });
  try {
    u.forEach((v) => {
      var k, O, D;
      const p = childIndex[v], _ = Array.from(((k = p.parentEl) == null ? void 0 : k.children) || []);
      p.nextSiblingEl && _.includes(p.nextSiblingEl) ? (O = p.parentEl) == null || O.insertBefore(p, p.nextSiblingEl) : (p.nextSiblingEl = null, (D = p.parentEl) == null || D.append(p)), p.runRemove();
    }), c.forEach((v) => {
      const p = childIndex[v];
      if (p.removed) {
        p.previousSiblingEl && (p.previousSiblingEl.nextSiblingEl = p.nextSiblingEl), p.nextSiblingEl && (p.nextSiblingEl.previousSiblingEl = p.previousSiblingEl);
        return;
      }
    });
    const l = window.__scale;
    Object.entries(tickOps).forEach(([v, p]) => {
      const _ = layoutIndex[v], k = _.getBoundingClientRect(), O = {
        x: k.width / l,
        y: k.height / l
      };
      _.updatePositions({
        size: O,
        inserted: a,
        removed: u
      });
    });
  } catch (l) {
    log.warn("Failed to run Layout ops", l);
  }
  tickOps = {};
};
let nextTick;
const queueOp = (a) => {
  const [u, c] = a, l = tickOps[c] || [];
  tickOps[c] = [...l, a], nextTick = nextTick || requestAnimationFrame(tick);
};
class Layout extends HTMLElement {
  constructor() {
    super();
    Ft(this, "parentEl");
    Ft(this, "slotEl");
    Ft(this, "parentLayout");
    Ft(this, "nodes");
    Ft(this, "mutationObserver");
    Ft(this, "latestSize");
    Ft(this, "isFirst", !0);
    Ft(this, "isUpdating", !1);
    Ft(this, "cid");
    this.cid = ++_cid;
  }
  log(...c) {
    var l;
    log.debug(...c, {
      id: this.dataset.id,
      parent: (l = this.parentLayout) == null ? void 0 : l.dataset.id
    }, this);
  }
  connectedCallback() {
    var c;
    this.parentEl = this.parentElement, this.parentLayout = findLayoutUp(this), this.slotEl = this.closest("[data-layout-child]"), Array.from(this.children).forEach((l) => this.initializeChild(l)), rootLayout || (rootLayout = this), layoutIndex[this.dataset.id] = this, parentIdIndex[this.dataset.id] = (c = this.parentLayout) == null ? void 0 : c.id, Object.assign(this.style, {
      width: "100%",
      height: "100%",
      position: "absolute",
      top: "0px",
      left: "0px",
      pointerEvents: "none",
      boxSizing: "border-box"
    }), this.mutationObserver && this.mutationObserver.disconnect(), this.mutationObserver = new MutationObserver((l) => {
      this.isConnected && l.forEach((v) => {
        v.type === "attributes" && !ignoredAttributes.includes(v.attributeName) ? queueOp(["attributesChanged", this.dataset.id]) : v.type === "childList" && (v.addedNodes.forEach((p) => {
          const _ = childIndex[p.dataset.id];
          p.removed || (_ ? _ !== p && (this.initializeChild(p), p.setAttribute("style", _.getAttribute("style")), p.data = _.data) : this.initializeChild(p), queueOp(["childInserted", this.dataset.id, p.dataset.id]));
        }), v.removedNodes.forEach((p) => {
          p.removed || queueOp(["childRemoved", this.dataset.id, p.dataset.id]);
        }));
      });
    }), this.mutationObserver.observe(this, {
      childList: !0,
      attributes: !0
    }), this.latestSize || queueOp(["attributesChanged", this.dataset.id]);
  }
  disconnectedCallback() {
  }
  adoptedCallback() {
  }
  updatePositions(c) {
    if (this.isUpdating)
      return;
    this.isUpdating = !0;
    const {
      size: l,
      inserted: v = /* @__PURE__ */ new Set(),
      removed: p = /* @__PURE__ */ new Set()
    } = c;
    this.nodes = Array.from(this.children || []).filter((D) => !D.removed).map((D, F) => {
      const z = getElementAttributes(D);
      return {
        // TODO: Does this work well enough? Think through keying
        id: D.dataset.id,
        props: z,
        children: []
      };
    });
    const _ = JSON.parse(this.getAttribute("props") || "{}");
    this.latestSize = l;
    const k = {
      id: this.dataset.id,
      props: _,
      children: this.nodes,
      size: l
    };
    let O = layoutChildren(k);
    Promise.all(Object.entries(O).map(async ([D, F]) => {
      var fe, Te, Re, Le;
      let z = childIndex[D] || this.querySelector(`[data-layout-child][data-id="${D}"]`);
      const j = {
        ...z.data,
        ...F
      };
      z.data = j;
      const {
        size: ee,
        position: X,
        zIndex: ae = 1,
        opacity: Q = 1,
        borderRadius: ne = 0,
        entryTransition: Z = {},
        exitTransition: de = {}
      } = j;
      if (z) {
        if (z.removed)
          return;
        de && (z.data.exitTransition = de), Z && (z.data.entryTransition = Z), z.data.size = ee, z.data.position = X;
        const be = window.__scale, q = this.getBoundingClientRect(), J = q.width / be, C = J - sizeToNum(X.x, J) - sizeToNum(ee.x, J), S = q.height / be, E = S - sizeToNum(X.y, S) - sizeToNum(ee.y, S);
        Object.assign(z.style, {
          position: "absolute",
          transformOrigin: "50% 50%",
          transitionDuration: "0ms",
          transitionDelay: "0ms",
          transform: "translate3d(0, 0, 0) scaleX(1) scaleY(1)",
          visibility: "visible",
          boxSizing: "border-box",
          overflow: "hidden",
          borderRadius: ne + "px",
          width: "auto",
          height: "auto"
        });
        let I = "0ms", M = this.isFirst ? asDuration(0) : asDuration(TRANSITION_DURATION);
        if (v.has(D))
          Object.assign(z.style, {
            transitionProperty: TRANSITION_FIELDS,
            transitionDuration: "0ms",
            transitionTimingFunction: Z.timingFn ?? "ease",
            transform: `translate3d(calc(${asSize(((fe = Z.offset) == null ? void 0 : fe.x) ?? 0)}), calc(${asSize(((Te = Z.offset) == null ? void 0 : Te.y) ?? 0)}), 0) scaleX(${((Re = Z.scale) == null ? void 0 : Re.x) ?? 1}) scaleY(${((Le = Z.scale) == null ? void 0 : Le.y) ?? 1})`,
            opacity: Z.opacity ?? Q,
            left: asSize(X.x) || 0,
            right: asSize(C) || 0,
            top: asSize(X.y) || 0,
            bottom: asSize(E) || 0
          }), I = asDuration(Z.delay ?? 0);
        else if (z.data.rootOffset) {
          const Y = rootLayout.getBoundingClientRect(), L = this.getBoundingClientRect(), T = {
            x: L.x / be - Y.x / be,
            y: L.y / be - Y.y / be
          }, B = T.x + L.width / be, te = z.data.rootOffset.x + Number(z.data.size.x), pe = T.y + L.height / be, Ie = z.data.rootOffset.y + Number(z.data.size.y);
          z.data.rootOffset.x - T.x, z.data.rootOffset.y - T.y, B - te, pe - Ie;
        }
        z.addEventListener("transitionstart", () => {
          z.style.zIndex = String(ae + 1);
        }), await new Promise((Y) => window.setTimeout(Y)), Object.assign(z.style, {
          transitionProperty: TRANSITION_FIELDS,
          transitionDuration: M,
          transitionDelay: I,
          transform: "translate3d(0, 0, 0) scaleX(1) scaleY(1)",
          opacity: Q,
          left: asSize(X.x) || 0,
          top: asSize(X.y) || 0,
          width: J ? "auto" : ee.x,
          right: J ? asSize(C) || 0 : "auto",
          height: S ? "auto" : ee.y,
          bottom: S ? asSize(E) || 0 : "auto",
          zIndex: ae
        });
        const U = () => {
          const Y = rootLayout.getBoundingClientRect(), L = z.getBoundingClientRect();
          z.data.rootOffset = {
            x: L.x / be - Y.x / be,
            y: L.y / be - Y.y / be
          };
        };
        U(), z.addEventListener("transitionend", () => {
          z.style.zIndex = String(ae), U();
        });
      }
    })).then(() => {
      this.isUpdating = !1;
    }), this.isFirst = !1, Array.from(this.querySelectorAll("ls-layout")).forEach((D) => {
      if (!O[D.dataset.id])
        return;
      const F = O[D.dataset.id].size;
      D.updatePositions({
        size: {
          x: sizeToNum(F.x, l.x),
          y: sizeToNum(F.y, l.y)
        }
      });
    });
  }
  initializeChild(c) {
    var v;
    if (!((v = c.dataset) != null && v.id))
      return log.warn("Layout: Child requires `data-id` at the time it is added to a Layout");
    c._remove = c.remove, c.remove = () => {
      this.removeChild(c);
    }, c.mutationObserver || (c.mutationObserver = new MutationObserver((p) => {
      p.forEach((_) => {
        if (_.type === "attributes") {
          if (_.attributeName === "style")
            return;
          queueOp(["childAttributesChanged", this.dataset.id, c.dataset.id]);
        }
      });
    }), c.mutationObserver.observe(c, {
      childList: !0,
      attributes: !0
    }));
    const l = {
      entryTransition: {
        delay: 0,
        opacity: 0,
        scale: {
          x: 1,
          y: 1
        },
        offset: {
          x: 0,
          y: 0
        }
      },
      exitTransition: {
        delay: 0,
        opacity: 0,
        scale: {
          x: 1,
          y: 1
        },
        offset: {
          x: 0,
          y: 0
        }
      },
      position: {
        x: 0,
        y: 0
      },
      size: {
        x: 0,
        y: 0
      },
      opacity: 0,
      fit: "cover",
      borderRadius: 0,
      zIndex: 1
    };
    c.data = l, c.parentEl = c.parentElement, c.nextSiblingEl = c.nextSibling, c.previousSiblingEl = c.previousSibling, c.previousSiblingEl && (c.previousSiblingEl.nextSiblingEl = c), c.toggleAttribute("data-layout-child", !0), childIndex[c.dataset.id] = c, c.runRemove = async () => {
      var _, k, O, D;
      c.removed = !0;
      const p = TRANSITION_DURATION;
      return await new Promise((F) => window.setTimeout(F)), Object.assign(c.style, {
        zIndex: 0,
        transitionDelay: asDuration(0),
        transitionDuration: asDuration(p),
        transitionProperty: TRANSITION_FIELDS,
        transitionTimingFunction: c.data.exitTransition.timingFn ?? "ease",
        transform: `translate3d(calc(${asSize(((_ = c.data.exitTransition.offset) == null ? void 0 : _.x) ?? 0)}), calc( ${asSize(((k = c.data.exitTransition.offset) == null ? void 0 : k.y) ?? 0)}), 0) scaleX(${((O = c.data.exitTransition.scale) == null ? void 0 : O.x) ?? 1}) scaleY(${((D = c.data.exitTransition.scale) == null ? void 0 : D.y) ?? 1})`,
        opacity: c.data.exitTransition.opacity ?? 0
      }), c.removed = !0, c.transition = new Promise((F) => {
        const z = () => {
          c.transition = null, c._remove(), queueOp(["childRemoveFinished", this.dataset.id, c.dataset.id]), clearTimeout(j), F();
        }, j = window.setTimeout(z, parseInt(String(p)) + 600);
        c.addEventListener("transitionend", z, {
          once: !0
        });
      }), c.transition;
    };
  }
}
const ensureLayoutContainer = (a) => {
  const u = document.getElementById("__ls-layout-container");
  if (u)
    return Object.assign(u.style, {
      width: a.x + "px",
      height: a.y + "px"
    }), u;
  const c = document.createElement("div");
  return c.id = "__ls-layout-container", Object.assign(c.style, {
    position: "fixed",
    // pointerEvents: 'none',
    visibility: "hidden",
    top: "0px",
    left: "0px",
    zIndex: -1,
    width: a.x + "px",
    height: a.y + "px"
  }), document.body.append(c), c;
}, layoutChildren = ({
  id: a,
  props: u = {},
  children: c,
  size: l
}) => {
  const v = {
    props: u,
    children: c,
    size: l
  }, p = htmlLayouts[u.layout] ? htmlLayouts[u.layout].layout(v) : htmlLayouts.Free.layout(v);
  if (!(p instanceof HTMLElement))
    return p;
  const _ = Array.from(p.querySelectorAll("[data-node-id]")), k = document.createElement("div");
  k.style.height = p.style.height = l.y + "px", k.style.width = p.style.width = l.x + "px", k.style.position = "absolute", k.style.top = "0px", k.style.left = "0px", k.style.boxSizing = "border-box", k.setAttribute("data-wrapper-id", a), k.append(p);
  const O = ensureLayoutContainer(l), D = O.querySelector(`[data-wrapper-id="${a}"]`);
  D ? D.replaceWith(k) : O.append(k);
  const F = p.getBoundingClientRect(), z = {};
  return _.forEach((j) => {
    var ne, Z, de, fe;
    const ee = j.dataset.nodeId;
    if (!ee)
      return;
    const X = Number(j.dataset.opacity ?? (j.style.opacity || 1)), ae = j.getBoundingClientRect();
    let Q = {
      position: {
        x: ae.x - F.x + "px",
        y: ae.y - F.y + "px"
      },
      size: {
        x: ae.width + "px",
        y: ae.height + "px"
      },
      opacity: X,
      zIndex: (ne = j.data) == null ? void 0 : ne.zIndex,
      entryTransition: ((Z = j.data) == null ? void 0 : Z.entryTransition) ?? {},
      exitTransition: ((de = j.data) == null ? void 0 : de.exitTransition) ?? {},
      borderRadius: ((fe = j.data) == null ? void 0 : fe.borderRadius) ?? 0
    };
    `${u.showcase}-x` === ee && (Q.position = {
      x: F.x + "px",
      y: F.y + "px"
    }, Q.size = {
      x: F.width + "px",
      y: F.height + "px"
    }, Q.zIndex = 10), z[ee] = Q, positionIndex[j.dataset.nodeId] = Q;
  }), z;
}, positionIndex = {}, htmlLayouts = {}, registerLayout = (a) => {
  asArray(a).forEach((u) => {
    htmlLayouts[u.name] = u;
  });
}, sourceTypes = {}, init$1 = (a = {}, u) => {
  const c = {}, l = {}, v = (O) => {
    u.triggerEvent("SourceChanged", O);
  }, p = (O) => {
    u.triggerEvent("AvailableSourcesChanged", {
      type: O,
      sources: l[O]
    });
  }, k = {
    sourceIndex: c,
    sourceTypeIndex: l,
    registerSource: (O) => {
      asArray(O).forEach((D) => {
        var z;
        const F = (j) => {
          const ee = c[j];
          if (ee && ee.type !== D.type)
            throw new Error(`Attempted to modify source of type ${ee.type} from ${D.type}`);
        };
        (z = D.init) == null || z.call(D, {
          getSource: (j) => k.getSource(j),
          removeSource: (j) => (F(j), k.removeSource(j)),
          setSourceActive: (j, ee) => (F(j), k.setSourceActive(j, ee)),
          updateSource: (j, ee) => (F(j), k.updateSource(j, ee)),
          modifySourceValue(j, ee) {
            return F(j), k.modifySourceValue(j, ee);
          },
          addSource: (j) => k.addSource(D.type, j)
        }), sourceTypes[D.type] = D;
      });
    },
    getSource: (O) => c[O],
    getSources: (O) => l[O] || [],
    useSource: (O, D) => (D(c[O]), u.on("SourceChanged", (F) => {
      F.id === O && D(F);
    })),
    useSources: (O, D) => (D(l[O] || []), u.on("AvailableSourcesChanged", (F) => {
      F.type === O && D(F.sources);
    })),
    addSource: (O, D) => {
      if (!D.id)
        throw new Error('Cannot add source without field "id"');
      if (c[D.id])
        return;
      if (!D.value)
        throw new Error('Cannot add source with an empty field "value"');
      if (!sourceTypes[O])
        throw new Error("Could not find definition for source type: " + O);
      const {
        id: z,
        value: j = null,
        props: ee = {},
        isActive: X = !0
      } = D;
      c[z] = {
        id: z,
        type: O,
        props: ee,
        value: j,
        isActive: X
      }, l[O] = [...l[O] || [], c[z]], v(c[z]), p(O);
    },
    removeSource: (O) => {
      const D = c[O];
      D && (delete c[O], l[D.type] = l[D.type].filter((F) => F.id !== O), p(D.type));
    },
    updateSource: (O, D) => {
      const F = c[O];
      F.props = {
        ...F.props,
        ...D
      }, v(F), p(F.type);
    },
    /**
     * Imperatively update a Source's value.
     * Triggers an event to inform elements to re-render.
     */
    modifySourceValue: async (O, D) => {
      const F = c[O];
      await D(F.value), v(F);
    },
    setSourceActive: (O, D = !0) => {
      const F = c[O];
      F.isActive = D, p(F.type);
    }
  };
  return k;
}, sources = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  init: init$1,
  sourceTypes
}, Symbol.toStringTag, { value: "Module" })), layouts = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), {
  forEachDown,
  insertAt,
  toDataNode,
  pull,
  replaceItem
} = Logic;
let compositor;
const start = (a) => {
  if (compositor)
    return compositor;
  const {
    dbAdapter: u,
    transformSettings: c = {},
    sourceSettings: l = {}
  } = a, v = {}, p = {};
  try {
    customElements.define("ls-layout", Layout);
  } catch (ne) {
    log.warn(ne);
  }
  const _ = {}, k = {}, O = {};
  let D = 0;
  const F = /* @__PURE__ */ new Map(), z = (ne, Z) => {
    if (typeof ne != "function")
      return;
    const de = ++D;
    return F.set(de, ne), ne.nodeId = Z, () => {
      F.delete(de);
    };
  }, j = (ne, Z, de) => z((fe, Te) => {
    fe === ne && Z(Te);
  }, de), ee = (ne, Z) => {
    F.forEach((de) => {
      de.nodeId ? Z != null && Z.nodeId && (Z == null ? void 0 : Z.nodeId) === de.nodeId && de(ne, Z) : de(ne, Z);
    });
  }, X = {
    projects: p,
    subscribe: z,
    on: j,
    triggerEvent: ee,
    getProject: (ne) => p[ne],
    getNodeProject: (ne) => p[_[ne]],
    getNodeParent: (ne) => O[k[ne]],
    getNode: (ne) => O[ne],
    createProject: async (ne = {}, Z) => {
      const {
        id: de,
        props: fe = {},
        children: Te = []
      } = ne, Re = await u(Z, {
        get: () => null,
        getParent: () => null
      }).insert(fe), Le = {
        id: Re,
        props: fe,
        children: Te
      };
      return forEachDown(ne, (be) => {
      }), O[Re] = Le, compositor.loadProject(Le, Z);
    },
    loadProject: (ne, Z) => {
      if (!ne)
        return;
      if (Z = Z || ne.id, p[Z])
        return p[Z];
      forEachDown(ne, (Re, Le) => {
        O[Re.id] = Re, k[Re.id] = Le == null ? void 0 : Le.id, _[Re.id] = Z;
      });
      const de = {
        insert: async (Re, Le, be = 0) => {
          if (Re.id && O[Re.id])
            return O[Re.id];
          if (Re.children || (Re.children = []), Re.props || (Re.props = {}), Le) {
            const q = O[Le];
            if (!q)
              throw "Parent node not found with ID";
            q.children = insertAt(be, Re, q.children || []), k[Re.id] = Le;
          }
          return O[Re.id] = Re, _[Re.id] = Z, Re.id;
        },
        update: async (Re, Le = {}, be) => {
          const q = O[Re];
          if (be) {
            const J = be.map((C) => {
              const S = O[C];
              return k[S.id] = Re, S;
            });
            q.children = J;
          }
          q.props = {
            ...q.props,
            ...Le
          };
        },
        remove: async (Re) => {
          const Le = O[k[Re]];
          Le && (Le.children = Le.children.filter((q) => q.id !== Re));
          const be = O[Re];
          forEachDown(be, (q) => {
            O[q.id] && (O[q.id]._deleted = !0), ee("NodeRemoved", {
              projectId: fe.id,
              nodeId: q.id
            });
          });
        }
      }, fe = {
        id: Z,
        getRoot: () => ne,
        get(Re) {
          return O[Re];
        },
        getParent(Re) {
          return O[k[Re]];
        },
        renderTree() {
          return Q.renderTree(ne);
        },
        local: de,
        insert: async (Re = {}, Le, be = 0) => {
          const J = {
            id: await Te.insert(Re, Le, be),
            props: Re,
            children: []
          };
          return de.insert(J, Le, be);
        },
        update: async (Re, Le) => (await de.update(Re, Le), Te.update(Re, Le)),
        remove: async (Re) => {
          await de.remove(Re);
          const Le = O[k[Re]], be = Le.children.filter((q) => q.id !== Re);
          return Te.batch([["delete", {
            id: Re
          }], ["update", {
            ...Le,
            children: be
          }]]);
        },
        reorder: async (Re, Le) => {
          const be = O[Re];
          return be.children = Le.map((q) => be.children.find((J) => J.id === q)), Te.batch([["update", be]]);
        },
        move: async (Re, Le, be = 0) => {
          const q = O[Re], J = O[k[Re]], C = O[Le];
          J.children = pull(J.children, q), C.children = insertAt(be, q, C.children), Te.batch([["update", C], ["update", J]]), k[Re] = Le;
        },
        swap: async (Re, Le) => {
          const be = O[Re], q = O[Le], J = O[k[Re]], C = O[k[Le]];
          J.children = replaceItem((S) => S.id === Re, q, J.children), C.children = replaceItem((S) => S.id === Le, be, C.children), k[Re] = C.id, k[Le] = J.id, Te.batch([["update", J], ["update", C]]);
        }
      };
      Object.defineProperty(fe, "nodes", {
        get() {
          return Object.values(O).filter((Re) => _[Re.id] === fe.id);
        }
      });
      const Te = v[Z] || u(Z, {
        get: (Re) => toDataNode(fe.get(Re)),
        getParent: (Re) => toDataNode(fe.getParent(Re))
      });
      return v[Z] = Te, p[Z] = fe, fe;
    }
  }, ae = init$1(l, X), Q = init$2(c, X, ae);
  return compositor = {
    registerLayout,
    registerTransform: Q.registerTransform,
    registerSource: ae.registerSource,
    getElement: Q.getElement,
    getSource: ae.getSource,
    getSources: ae.getSources,
    useSource: ae.useSource,
    useSources: ae.useSources,
    ...X
  }, compositor;
}, index = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Layout: layouts,
  Source: sources,
  Transform: transforms,
  start
}, Symbol.toStringTag, { value: "Module" })), createProject = async (a) => {
  const u = getUser().id, c = a.type || "sceneless", l = a.size || {
    x: 1280,
    y: 720
  }, v = a.settings || {};
  let p = await CoreContext.clients.LiveApi().project.createProject({
    collectionId: u,
    rendering: {
      video: {
        width: l.x,
        height: l.y,
        framerate: 30
      }
    },
    composition: {
      studioSdk: {
        version: CoreContext.rendererVersion
      }
    },
    metadata: {},
    webrtc: {
      hosted: {}
    }
  });
  const _ = await createLayout({
    projectId: p.project.projectId,
    collectionId: p.project.collectionId,
    settings: v,
    size: l,
    type: c
  }), {
    displayName: k
  } = getAccessTokenData(), O = {
    type: c,
    layoutId: _.id,
    hostDisplayName: k,
    props: a.props || {}
  };
  let D = await CoreContext.clients.LiveApi().project.updateProject({
    collectionId: u,
    projectId: p.project.projectId,
    updateMask: ["metadata"],
    metadata: O
  });
  return p.project = D.project, p.project.metadata = O, {
    project: p.project,
    layout: _
  };
}, deleteProject = async (a) => {
  const {
    projectId: u
  } = a, c = getProject(u), l = getUser().id;
  await Promise.all([CoreContext.clients.LiveApi().project.deleteProject({
    collectionId: l,
    projectId: u
  }), CoreContext.clients.LayoutApi().layout.deleteLayout({
    layoutId: c.layoutApi.layoutId
  })]);
}, loadUser = async (a) => {
  var _;
  const u = await loadCollections();
  let c;
  const {
    displayName: l,
    serviceUserId: v
  } = getAccessTokenData();
  u.length === 0 ? c = (await CoreContext.clients.LiveApi().collection.createCollection({
    metadata: {
      serviceUserId: v,
      displayName: l,
      props: {}
    }
  })).collection : c = u[0], await CoreContext.clients.LiveApi().subscribeToCollection(c.collectionId);
  const p = await Promise.all(c.projects.filter((k) => {
    var O;
    return !!((O = k.metadata) != null && O.layoutId);
  }).map((k) => hydrateProject(k, "ROLE_HOST", a)));
  return {
    user: {
      id: c.collectionId,
      metadata: c.metadata,
      props: ((_ = c.metadata) == null ? void 0 : _.props) || {},
      name: l
    },
    projects: p,
    sources: c.sources
  };
}, loadCollections = async () => (await CoreContext.clients.LiveApi().collection.getCollections({})).collections, createLayout = async (a) => {
  const {
    settings: u,
    size: c,
    type: l,
    projectId: v,
    collectionId: p
  } = a, _ = await CoreContext.clients.LayoutApi().layout.createLayout({
    layout: {
      projectId: v,
      collectionId: p
    }
  });
  return l === "sceneless" ? await createCompositor(_.id, c, u) : await CoreContext.compositor.createProject({
    props: {
      name: "Root",
      layout: "Free",
      ...u,
      isRoot: !0,
      size: c
    }
  }, _.id), _;
}, requests = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createLayout,
  createProject,
  deleteProject,
  loadCollections,
  loadUser
}, Symbol.toStringTag, { value: "Module" })), RTMP = {
  type: "RTMP",
  valueType: MediaStream,
  props: {
    id: {},
    type: {},
    videoEnabled: {},
    audioEnabled: {}
  },
  init({
    addSource: a,
    removeSource: u,
    updateSource: c,
    getSource: l
  }) {
    let v = {}, p = [], _ = [];
    const k = (O) => {
      const D = O.filter((z) => !_.some((j) => j.id === z.id)), F = _.filter((z) => !O.some((j) => j.id === z.id));
      _ = O, D.forEach(async (z) => {
        const j = new MediaStream([]);
        v[z.id] = j;
        const ee = j.getVideoTracks();
        a({
          id: `rtmp-${z.id}`,
          isActive: !0,
          value: j,
          props: {
            id: z.id,
            isMuted: !1,
            participantId: z.id,
            type: "rtmp",
            videoEnabled: !!ee.length,
            audioEnabled: !0
          }
        });
      }), F.forEach((z) => {
        u(`rtmp-${z.id}`);
      });
    };
    CoreContext.on("ActiveProjectChanged", ({
      projectId: O
    }) => {
      const F = toBaseProject(getProject(O)).sources.filter((z) => {
        var j, ee;
        return !((ee = (j = z.address) == null ? void 0 : j.dynamic) != null && ee.id);
      });
      k(F);
    }), CoreContext.on("RoomJoined", ({
      projectId: O,
      room: D
    }) => {
      if (toBaseProject(getProject(O)).role !== Role.ROLE_RENDERER) {
        const z = () => {
          p.filter((j) => (j == null ? void 0 : j.type) === "screen_share" && (j == null ? void 0 : j.isExternal) === !0).forEach((j) => {
            if (j.type === "screen_share") {
              const ee = v[j.participantId], X = D.getParticipant(j.participantId);
              if (_.some((ae) => ae.id === X.id)) {
                const ae = D.getTrack(j.id);
                if (l(`rtmp-${X == null ? void 0 : X.id}`)) {
                  const ne = D.getTracks().find((Z) => Z.participantId === X.id && Z.mediaStreamTrack.kind === "audio");
                  updateMediaStreamTracks(ee, {
                    video: ae == null ? void 0 : ae.mediaStreamTrack,
                    audio: ne == null ? void 0 : ne.mediaStreamTrack
                  }), c(`rtmp-${X == null ? void 0 : X.id}`, {
                    videoEnabled: !!(ae != null && ae.mediaStreamTrack && !ae.isMuted),
                    audioEnabled: !!(ne && !ne.isMuted)
                  });
                }
              }
            }
          });
        };
        D.useTracks((j) => {
          const ee = j.filter((Q) => _.some((ne) => ne.id === Q.participantId)).filter((Q) => ["screen_share"].includes(Q.type)), X = ee.filter((Q) => !p.some((ne) => ne.id === Q.id) && !!(Q != null && Q.mediaStreamTrack)), ae = p.filter((Q) => !ee.some((ne) => ne.id === Q.id));
          p = ee.filter((Q) => !!(Q != null && Q.mediaStreamTrack)), ae.forEach((Q) => {
            const ne = v[Q.participantId];
            Q.mediaStreamTrack.kind === "video" && (updateMediaStreamTracks(ne, {
              video: null
            }), c(`rtmp-${Q.participantId}`, {
              videoEnabled: !1
            })), Q.mediaStreamTrack.kind === "audio" && (updateMediaStreamTracks(ne, {
              audio: null
            }), c(`rtmp-${Q.participantId}`, {
              audioEnabled: !1
            }));
          }), X.forEach((Q) => {
            if (Q.type === "screen_share" && Q.mediaStreamTrack.kind === "video") {
              const ne = v[Q.participantId], Z = p.find((de) => {
                var fe;
                return de.participantId === Q.participantId && ((fe = de.mediaStreamTrack) == null ? void 0 : fe.kind) === "audio";
              });
              updateMediaStreamTracks(ne, {
                video: Q == null ? void 0 : Q.mediaStreamTrack,
                audio: Z == null ? void 0 : Z.mediaStreamTrack
              }), c(`rtmp-${Q.participantId}`, {
                videoEnabled: !!(Q && !(Q != null && Q.isMuted)),
                audioEnabled: !!(Z && !(Z != null && Z.isMuted))
              });
            }
          }), z();
        });
      }
    }), CoreContext.onInternal("SourceConnected", async (O) => {
      const D = v[O];
      if (D) {
        const F = await connectDevice(O);
        if (l(`rtmp-${O}`) && F) {
          const j = F.getAudioTracks()[0], ee = F.getVideoTracks()[0];
          updateMediaStreamTracks(D, {
            video: ee,
            audio: j
          }), c(`rtmp-${O}`, {
            videoEnabled: !!ee,
            audioEnabled: !!j
          });
        }
      }
    }), CoreContext.onInternal("SourceDisconnected", async (O) => {
      const D = v[O];
      D && ((D == null ? void 0 : D.getTracks()).forEach((z) => {
        var j;
        (j = v[O]) == null || j.removeTrack(z);
      }), c(`rtmp-${O}`, {
        videoEnabled: !1,
        audioEnabled: !1
      }));
    }), CoreContext.on("ProjectSourceAdded", ({
      source: O,
      projectId: D
    }) => {
      const z = toBaseProject(getProject(D)).sources.filter((j) => {
        var ee, X;
        return !((X = (ee = j.address) == null ? void 0 : ee.dynamic) != null && X.id);
      });
      k(z);
    }), CoreContext.on("ProjectSourceRemoved", ({
      sourceId: O,
      projectId: D
    }) => {
      const z = toBaseProject(getProject(D)).sources.filter((j) => {
        var ee, X;
        return !((X = (ee = j.address) == null ? void 0 : ee.dynamic) != null && X.id);
      });
      k(z);
    });
  }
}, Game = {
  type: "Game",
  valueType: MediaStream,
  props: {
    id: {},
    type: {},
    videoEnabled: {},
    audioEnabled: {}
  },
  init({
    addSource: a,
    removeSource: u,
    updateSource: c,
    getSource: l,
    modifySourceValue: v
  }) {
    let p = [], _ = [];
    const k = (O) => {
      const D = O.filter((z) => !_.some((j) => j.id === z.id)), F = _.filter((z) => !O.some((j) => j.id === z.id));
      _ = O, D.forEach(async (z) => {
        var X, ae, Q, ne, Z, de, fe, Te;
        const j = new MediaStream([]), ee = j.getVideoTracks();
        a({
          id: `game-${(ae = (X = z.preview) == null ? void 0 : X.webrtc) == null ? void 0 : ae.participantId}`,
          isActive: !0,
          value: j,
          props: {
            displayName: ((ne = (Q = z.preview) == null ? void 0 : Q.webrtc) == null ? void 0 : ne.displayName) || z.id,
            id: (de = (Z = z.preview) == null ? void 0 : Z.webrtc) == null ? void 0 : de.participantId,
            isMuted: !1,
            participantId: (Te = (fe = z.preview) == null ? void 0 : fe.webrtc) == null ? void 0 : Te.participantId,
            type: "game",
            videoEnabled: !!ee.length,
            audioEnabled: !0
          }
        });
      }), F.forEach((z) => {
        var j, ee;
        u(`game-${(ee = (j = z.preview) == null ? void 0 : j.webrtc) == null ? void 0 : ee.participantId}`);
      });
    };
    CoreContext.on("RoomJoined", ({
      projectId: O,
      room: D
    }) => {
      if (toBaseProject(getProject(O)).role !== Role.ROLE_RENDERER) {
        const z = () => {
          p.filter((j) => (j == null ? void 0 : j.type) === "camera" && (j == null ? void 0 : j.isExternal) === !0).forEach((j) => {
            var ee;
            if (j.type === "camera") {
              const X = D.getParticipant(j.participantId);
              if (_.some((Q) => {
                var ne, Z;
                return ((Z = (ne = Q.preview) == null ? void 0 : ne.webrtc) == null ? void 0 : Z.participantId) === X.id;
              })) {
                const Q = D.getTrack(j.id);
                if (l(`game-${X == null ? void 0 : X.id}`)) {
                  const Z = D.getTracks().find((de) => de.participantId === X.id && de.mediaStreamTrack.kind === "audio");
                  v(`game-${X == null ? void 0 : X.id}`, (de) => {
                    updateMediaStreamTracks(de, {
                      video: Q == null ? void 0 : Q.mediaStreamTrack,
                      audio: Z == null ? void 0 : Z.mediaStreamTrack
                    });
                  }), c(`game-${X == null ? void 0 : X.id}`, {
                    videoEnabled: !!(Q != null && Q.mediaStreamTrack && !Q.isMuted),
                    audioEnabled: !!(Z && !Z.isMuted),
                    displayName: ((ee = X.meta) == null ? void 0 : ee.screenDisplayName) || (X == null ? void 0 : X.displayName) || "Game Source"
                  });
                }
              }
            }
          });
        };
        D.useTracks((j) => {
          const ee = j.filter((Q) => _.some((ne) => {
            var Z, de;
            return ((de = (Z = ne.preview) == null ? void 0 : Z.webrtc) == null ? void 0 : de.participantId) === Q.participantId;
          })).filter((Q) => ["camera"].includes(Q.type)), X = ee.filter((Q) => !p.some((ne) => ne.id === Q.id) && !!(Q != null && Q.mediaStreamTrack)), ae = p.filter((Q) => !ee.some((ne) => ne.id === Q.id));
          p = ee.filter((Q) => !!(Q != null && Q.mediaStreamTrack)), ae.forEach((Q) => {
            const {
              participantId: ne
            } = Q;
            Q.mediaStreamTrack.kind === "video" && (v(`game-${ne}`, (Z) => {
              updateMediaStreamTracks(Z, {
                video: null
              });
            }), c(`game-${ne}`, {
              videoEnabled: !1
            })), Q.mediaStreamTrack.kind === "audio" && (v(`game-${ne}`, (Z) => {
              updateMediaStreamTracks(Z, {
                audio: null
              });
            }), c(`game-${ne}`, {
              audioEnabled: !1
            }));
          }), X.forEach((Q) => {
            if (Q.type === "camera" && Q.mediaStreamTrack.kind === "video") {
              const ne = p.find((Z) => {
                var de;
                return Z.participantId === Q.participantId && ((de = Z.mediaStreamTrack) == null ? void 0 : de.kind) === "audio";
              });
              v(`game-${Q.participantId}`, (Z) => {
                updateMediaStreamTracks(Z, {
                  video: Q == null ? void 0 : Q.mediaStreamTrack,
                  audio: ne == null ? void 0 : ne.mediaStreamTrack
                });
              }), c(`game-${Q.participantId}`, {
                videoEnabled: !!(Q && !(Q != null && Q.isMuted)),
                audioEnabled: !!(ne && !(ne != null && ne.isMuted))
              });
            }
          }), z();
        });
      }
      D.useParticipants((z) => {
        z.filter((ee) => ee.id.startsWith("source")).forEach((ee) => {
          var ae;
          l(`game-${ee.id}`) && c(`game-${ee.id}`, {
            displayName: ((ae = ee.meta) == null ? void 0 : ae.screenDisplayName) || (ee == null ? void 0 : ee.displayName) || "Game Source"
          });
        });
      });
    }), CoreContext.on("ActiveProjectChanged", ({
      projectId: O
    }) => {
      const F = toBaseProject(getProject(O)).sources.filter((z) => {
        var j, ee;
        return (ee = (j = z.address) == null ? void 0 : j.dynamic) == null ? void 0 : ee.id;
      });
      k(F);
    }), CoreContext.onInternal("SourceConnected", async (O) => {
      const D = await connectDevice(O);
      if (l(`game-source-${O}`) && D) {
        const z = D.getAudioTracks()[0], j = D.getVideoTracks()[0];
        v(`game-source-${O}`, (ee) => {
          updateMediaStreamTracks(ee, {
            video: j,
            audio: z
          });
        }), c(`game-source-${O}`, {
          videoEnabled: !!j,
          audioEnabled: !!z
        });
      }
    }), CoreContext.onInternal("SourceDisconnected", (O) => {
      var F;
      const D = (F = l(`game-source-${O}`)) == null ? void 0 : F.value;
      D && ((D == null ? void 0 : D.getTracks()).forEach((j) => {
        D == null || D.removeTrack(j);
      }), c(`game-source-${O}`, {
        videoEnabled: !1,
        audioEnabled: !1
      }));
    }), CoreContext.on("ProjectSourceAdded", ({
      source: O,
      projectId: D
    }) => {
      const F = toBaseProject(getProject(D));
      k(F.sources.filter((z) => {
        var j, ee;
        return (ee = (j = z.address) == null ? void 0 : j.dynamic) == null ? void 0 : ee.id;
      }));
    }), CoreContext.on("ProjectSourceRemoved", ({
      sourceId: O,
      projectId: D
    }) => {
      const F = toBaseProject(getProject(D));
      k(F.sources.filter((z) => {
        var j, ee;
        return (ee = (j = z.address) == null ? void 0 : j.dynamic) == null ? void 0 : ee.id;
      }));
    });
  }
}, Sources = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Banner: Banner$1,
  Game,
  RTMP,
  RoomParticipant: RoomParticipant$1
}, Symbol.toStringTag, { value: "Module" }));
var createRoot, m = ReactDOM;
if (process$1.env.NODE_ENV === "production")
  createRoot = m.createRoot, m.hydrateRoot;
else {
  var i = m.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  createRoot = function(a, u) {
    i.usingClientEntryPoint = !0;
    try {
      return m.createRoot(a, u);
    } finally {
      i.usingClientEntryPoint = !1;
    }
  };
}
var APIKitAnimationTypes = /* @__PURE__ */ ((a) => (a.FADE_IN = "fade-in", a.FADE_OUT = "fade-out", a.SLIDE_IN_BLURRED_TOP = "slide-in-blurred-top", a.SLIDE_IN_LEFT = "slide-in-left", a.SLIDE_OUT_LEFT = "slide-out-left", a))(APIKitAnimationTypes || {});
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(a) {
    for (var u = 1; u < arguments.length; u++) {
      var c = arguments[u];
      for (var l in c)
        Object.prototype.hasOwnProperty.call(c, l) && (a[l] = c[l]);
    }
    return a;
  }, _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(a, u) {
  if (a == null)
    return {};
  var c = {}, l = Object.keys(a), v, p;
  for (p = 0; p < l.length; p++)
    v = l[p], !(u.indexOf(v) >= 0) && (c[v] = a[v]);
  return c;
}
function _setPrototypeOf(a, u) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(l, v) {
    return l.__proto__ = v, l;
  }, _setPrototypeOf(a, u);
}
function _inheritsLoose(a, u) {
  a.prototype = Object.create(u.prototype), a.prototype.constructor = a, _setPrototypeOf(a, u);
}
var propTypes = { exports: {} }, reactIs = { exports: {} }, reactIs_production_min = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactIs_production_min;
function requireReactIs_production_min() {
  if (hasRequiredReactIs_production_min)
    return reactIs_production_min;
  hasRequiredReactIs_production_min = 1;
  var a = typeof Symbol == "function" && Symbol.for, u = a ? Symbol.for("react.element") : 60103, c = a ? Symbol.for("react.portal") : 60106, l = a ? Symbol.for("react.fragment") : 60107, v = a ? Symbol.for("react.strict_mode") : 60108, p = a ? Symbol.for("react.profiler") : 60114, _ = a ? Symbol.for("react.provider") : 60109, k = a ? Symbol.for("react.context") : 60110, O = a ? Symbol.for("react.async_mode") : 60111, D = a ? Symbol.for("react.concurrent_mode") : 60111, F = a ? Symbol.for("react.forward_ref") : 60112, z = a ? Symbol.for("react.suspense") : 60113, j = a ? Symbol.for("react.suspense_list") : 60120, ee = a ? Symbol.for("react.memo") : 60115, X = a ? Symbol.for("react.lazy") : 60116, ae = a ? Symbol.for("react.block") : 60121, Q = a ? Symbol.for("react.fundamental") : 60117, ne = a ? Symbol.for("react.responder") : 60118, Z = a ? Symbol.for("react.scope") : 60119;
  function de(Te) {
    if (typeof Te == "object" && Te !== null) {
      var Re = Te.$$typeof;
      switch (Re) {
        case u:
          switch (Te = Te.type, Te) {
            case O:
            case D:
            case l:
            case p:
            case v:
            case z:
              return Te;
            default:
              switch (Te = Te && Te.$$typeof, Te) {
                case k:
                case F:
                case X:
                case ee:
                case _:
                  return Te;
                default:
                  return Re;
              }
          }
        case c:
          return Re;
      }
    }
  }
  function fe(Te) {
    return de(Te) === D;
  }
  return reactIs_production_min.AsyncMode = O, reactIs_production_min.ConcurrentMode = D, reactIs_production_min.ContextConsumer = k, reactIs_production_min.ContextProvider = _, reactIs_production_min.Element = u, reactIs_production_min.ForwardRef = F, reactIs_production_min.Fragment = l, reactIs_production_min.Lazy = X, reactIs_production_min.Memo = ee, reactIs_production_min.Portal = c, reactIs_production_min.Profiler = p, reactIs_production_min.StrictMode = v, reactIs_production_min.Suspense = z, reactIs_production_min.isAsyncMode = function(Te) {
    return fe(Te) || de(Te) === O;
  }, reactIs_production_min.isConcurrentMode = fe, reactIs_production_min.isContextConsumer = function(Te) {
    return de(Te) === k;
  }, reactIs_production_min.isContextProvider = function(Te) {
    return de(Te) === _;
  }, reactIs_production_min.isElement = function(Te) {
    return typeof Te == "object" && Te !== null && Te.$$typeof === u;
  }, reactIs_production_min.isForwardRef = function(Te) {
    return de(Te) === F;
  }, reactIs_production_min.isFragment = function(Te) {
    return de(Te) === l;
  }, reactIs_production_min.isLazy = function(Te) {
    return de(Te) === X;
  }, reactIs_production_min.isMemo = function(Te) {
    return de(Te) === ee;
  }, reactIs_production_min.isPortal = function(Te) {
    return de(Te) === c;
  }, reactIs_production_min.isProfiler = function(Te) {
    return de(Te) === p;
  }, reactIs_production_min.isStrictMode = function(Te) {
    return de(Te) === v;
  }, reactIs_production_min.isSuspense = function(Te) {
    return de(Te) === z;
  }, reactIs_production_min.isValidElementType = function(Te) {
    return typeof Te == "string" || typeof Te == "function" || Te === l || Te === D || Te === p || Te === v || Te === z || Te === j || typeof Te == "object" && Te !== null && (Te.$$typeof === X || Te.$$typeof === ee || Te.$$typeof === _ || Te.$$typeof === k || Te.$$typeof === F || Te.$$typeof === Q || Te.$$typeof === ne || Te.$$typeof === Z || Te.$$typeof === ae);
  }, reactIs_production_min.typeOf = de, reactIs_production_min;
}
var reactIs_development = {}, hasRequiredReactIs_development;
function requireReactIs_development() {
  return hasRequiredReactIs_development || (hasRequiredReactIs_development = 1, process$1.env.NODE_ENV !== "production" && function() {
    var a = typeof Symbol == "function" && Symbol.for, u = a ? Symbol.for("react.element") : 60103, c = a ? Symbol.for("react.portal") : 60106, l = a ? Symbol.for("react.fragment") : 60107, v = a ? Symbol.for("react.strict_mode") : 60108, p = a ? Symbol.for("react.profiler") : 60114, _ = a ? Symbol.for("react.provider") : 60109, k = a ? Symbol.for("react.context") : 60110, O = a ? Symbol.for("react.async_mode") : 60111, D = a ? Symbol.for("react.concurrent_mode") : 60111, F = a ? Symbol.for("react.forward_ref") : 60112, z = a ? Symbol.for("react.suspense") : 60113, j = a ? Symbol.for("react.suspense_list") : 60120, ee = a ? Symbol.for("react.memo") : 60115, X = a ? Symbol.for("react.lazy") : 60116, ae = a ? Symbol.for("react.block") : 60121, Q = a ? Symbol.for("react.fundamental") : 60117, ne = a ? Symbol.for("react.responder") : 60118, Z = a ? Symbol.for("react.scope") : 60119;
    function de(A) {
      return typeof A == "string" || typeof A == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      A === l || A === D || A === p || A === v || A === z || A === j || typeof A == "object" && A !== null && (A.$$typeof === X || A.$$typeof === ee || A.$$typeof === _ || A.$$typeof === k || A.$$typeof === F || A.$$typeof === Q || A.$$typeof === ne || A.$$typeof === Z || A.$$typeof === ae);
    }
    function fe(A) {
      if (typeof A == "object" && A !== null) {
        var re = A.$$typeof;
        switch (re) {
          case u:
            var le = A.type;
            switch (le) {
              case O:
              case D:
              case l:
              case p:
              case v:
              case z:
                return le;
              default:
                var Ne = le && le.$$typeof;
                switch (Ne) {
                  case k:
                  case F:
                  case X:
                  case ee:
                  case _:
                    return Ne;
                  default:
                    return re;
                }
            }
          case c:
            return re;
        }
      }
    }
    var Te = O, Re = D, Le = k, be = _, q = u, J = F, C = l, S = X, E = ee, I = c, M = p, $ = v, U = z, Y = !1;
    function L(A) {
      return Y || (Y = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), T(A) || fe(A) === O;
    }
    function T(A) {
      return fe(A) === D;
    }
    function B(A) {
      return fe(A) === k;
    }
    function te(A) {
      return fe(A) === _;
    }
    function pe(A) {
      return typeof A == "object" && A !== null && A.$$typeof === u;
    }
    function Ie(A) {
      return fe(A) === F;
    }
    function $e(A) {
      return fe(A) === l;
    }
    function ve(A) {
      return fe(A) === X;
    }
    function he(A) {
      return fe(A) === ee;
    }
    function Oe(A) {
      return fe(A) === c;
    }
    function Ae(A) {
      return fe(A) === p;
    }
    function Ue(A) {
      return fe(A) === v;
    }
    function oe(A) {
      return fe(A) === z;
    }
    reactIs_development.AsyncMode = Te, reactIs_development.ConcurrentMode = Re, reactIs_development.ContextConsumer = Le, reactIs_development.ContextProvider = be, reactIs_development.Element = q, reactIs_development.ForwardRef = J, reactIs_development.Fragment = C, reactIs_development.Lazy = S, reactIs_development.Memo = E, reactIs_development.Portal = I, reactIs_development.Profiler = M, reactIs_development.StrictMode = $, reactIs_development.Suspense = U, reactIs_development.isAsyncMode = L, reactIs_development.isConcurrentMode = T, reactIs_development.isContextConsumer = B, reactIs_development.isContextProvider = te, reactIs_development.isElement = pe, reactIs_development.isForwardRef = Ie, reactIs_development.isFragment = $e, reactIs_development.isLazy = ve, reactIs_development.isMemo = he, reactIs_development.isPortal = Oe, reactIs_development.isProfiler = Ae, reactIs_development.isStrictMode = Ue, reactIs_development.isSuspense = oe, reactIs_development.isValidElementType = de, reactIs_development.typeOf = fe;
  }()), reactIs_development;
}
var hasRequiredReactIs;
function requireReactIs() {
  return hasRequiredReactIs || (hasRequiredReactIs = 1, process$1.env.NODE_ENV === "production" ? reactIs.exports = requireReactIs_production_min() : reactIs.exports = requireReactIs_development()), reactIs.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var objectAssign, hasRequiredObjectAssign;
function requireObjectAssign() {
  if (hasRequiredObjectAssign)
    return objectAssign;
  hasRequiredObjectAssign = 1;
  var a = Object.getOwnPropertySymbols, u = Object.prototype.hasOwnProperty, c = Object.prototype.propertyIsEnumerable;
  function l(p) {
    if (p == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(p);
  }
  function v() {
    try {
      if (!Object.assign)
        return !1;
      var p = new String("abc");
      if (p[5] = "de", Object.getOwnPropertyNames(p)[0] === "5")
        return !1;
      for (var _ = {}, k = 0; k < 10; k++)
        _["_" + String.fromCharCode(k)] = k;
      var O = Object.getOwnPropertyNames(_).map(function(F) {
        return _[F];
      });
      if (O.join("") !== "0123456789")
        return !1;
      var D = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(F) {
        D[F] = F;
      }), Object.keys(Object.assign({}, D)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return objectAssign = v() ? Object.assign : function(p, _) {
    for (var k, O = l(p), D, F = 1; F < arguments.length; F++) {
      k = Object(arguments[F]);
      for (var z in k)
        u.call(k, z) && (O[z] = k[z]);
      if (a) {
        D = a(k);
        for (var j = 0; j < D.length; j++)
          c.call(k, D[j]) && (O[D[j]] = k[D[j]]);
      }
    }
    return O;
  }, objectAssign;
}
var ReactPropTypesSecret_1, hasRequiredReactPropTypesSecret;
function requireReactPropTypesSecret() {
  if (hasRequiredReactPropTypesSecret)
    return ReactPropTypesSecret_1;
  hasRequiredReactPropTypesSecret = 1;
  var a = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return ReactPropTypesSecret_1 = a, ReactPropTypesSecret_1;
}
var has, hasRequiredHas;
function requireHas() {
  return hasRequiredHas || (hasRequiredHas = 1, has = Function.call.bind(Object.prototype.hasOwnProperty)), has;
}
var checkPropTypes_1, hasRequiredCheckPropTypes;
function requireCheckPropTypes() {
  if (hasRequiredCheckPropTypes)
    return checkPropTypes_1;
  hasRequiredCheckPropTypes = 1;
  var a = function() {
  };
  if (process$1.env.NODE_ENV !== "production") {
    var u = requireReactPropTypesSecret(), c = {}, l = requireHas();
    a = function(p) {
      var _ = "Warning: " + p;
      typeof console < "u" && console.error(_);
      try {
        throw new Error(_);
      } catch {
      }
    };
  }
  function v(p, _, k, O, D) {
    if (process$1.env.NODE_ENV !== "production") {
      for (var F in p)
        if (l(p, F)) {
          var z;
          try {
            if (typeof p[F] != "function") {
              var j = Error(
                (O || "React class") + ": " + k + " type `" + F + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof p[F] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw j.name = "Invariant Violation", j;
            }
            z = p[F](_, F, O, k, null, u);
          } catch (X) {
            z = X;
          }
          if (z && !(z instanceof Error) && a(
            (O || "React class") + ": type specification of " + k + " `" + F + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof z + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), z instanceof Error && !(z.message in c)) {
            c[z.message] = !0;
            var ee = D ? D() : "";
            a(
              "Failed " + k + " type: " + z.message + (ee ?? "")
            );
          }
        }
    }
  }
  return v.resetWarningCache = function() {
    process$1.env.NODE_ENV !== "production" && (c = {});
  }, checkPropTypes_1 = v, checkPropTypes_1;
}
var factoryWithTypeCheckers, hasRequiredFactoryWithTypeCheckers;
function requireFactoryWithTypeCheckers() {
  if (hasRequiredFactoryWithTypeCheckers)
    return factoryWithTypeCheckers;
  hasRequiredFactoryWithTypeCheckers = 1;
  var a = requireReactIs(), u = requireObjectAssign(), c = requireReactPropTypesSecret(), l = requireHas(), v = requireCheckPropTypes(), p = function() {
  };
  process$1.env.NODE_ENV !== "production" && (p = function(k) {
    var O = "Warning: " + k;
    typeof console < "u" && console.error(O);
    try {
      throw new Error(O);
    } catch {
    }
  });
  function _() {
    return null;
  }
  return factoryWithTypeCheckers = function(k, O) {
    var D = typeof Symbol == "function" && Symbol.iterator, F = "@@iterator";
    function z(T) {
      var B = T && (D && T[D] || T[F]);
      if (typeof B == "function")
        return B;
    }
    var j = "<<anonymous>>", ee = {
      array: ne("array"),
      bigint: ne("bigint"),
      bool: ne("boolean"),
      func: ne("function"),
      number: ne("number"),
      object: ne("object"),
      string: ne("string"),
      symbol: ne("symbol"),
      any: Z(),
      arrayOf: de,
      element: fe(),
      elementType: Te(),
      instanceOf: Re,
      node: J(),
      objectOf: be,
      oneOf: Le,
      oneOfType: q,
      shape: S,
      exact: E
    };
    function X(T, B) {
      return T === B ? T !== 0 || 1 / T === 1 / B : T !== T && B !== B;
    }
    function ae(T, B) {
      this.message = T, this.data = B && typeof B == "object" ? B : {}, this.stack = "";
    }
    ae.prototype = Error.prototype;
    function Q(T) {
      if (process$1.env.NODE_ENV !== "production")
        var B = {}, te = 0;
      function pe($e, ve, he, Oe, Ae, Ue, oe) {
        if (Oe = Oe || j, Ue = Ue || he, oe !== c) {
          if (O) {
            var A = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw A.name = "Invariant Violation", A;
          } else if (process$1.env.NODE_ENV !== "production" && typeof console < "u") {
            var re = Oe + ":" + he;
            !B[re] && // Avoid spamming the console because they are often not actionable except for lib authors
            te < 3 && (p(
              "You are manually calling a React.PropTypes validation function for the `" + Ue + "` prop on `" + Oe + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), B[re] = !0, te++);
          }
        }
        return ve[he] == null ? $e ? ve[he] === null ? new ae("The " + Ae + " `" + Ue + "` is marked as required " + ("in `" + Oe + "`, but its value is `null`.")) : new ae("The " + Ae + " `" + Ue + "` is marked as required in " + ("`" + Oe + "`, but its value is `undefined`.")) : null : T(ve, he, Oe, Ae, Ue);
      }
      var Ie = pe.bind(null, !1);
      return Ie.isRequired = pe.bind(null, !0), Ie;
    }
    function ne(T) {
      function B(te, pe, Ie, $e, ve, he) {
        var Oe = te[pe], Ae = $(Oe);
        if (Ae !== T) {
          var Ue = U(Oe);
          return new ae(
            "Invalid " + $e + " `" + ve + "` of type " + ("`" + Ue + "` supplied to `" + Ie + "`, expected ") + ("`" + T + "`."),
            { expectedType: T }
          );
        }
        return null;
      }
      return Q(B);
    }
    function Z() {
      return Q(_);
    }
    function de(T) {
      function B(te, pe, Ie, $e, ve) {
        if (typeof T != "function")
          return new ae("Property `" + ve + "` of component `" + Ie + "` has invalid PropType notation inside arrayOf.");
        var he = te[pe];
        if (!Array.isArray(he)) {
          var Oe = $(he);
          return new ae("Invalid " + $e + " `" + ve + "` of type " + ("`" + Oe + "` supplied to `" + Ie + "`, expected an array."));
        }
        for (var Ae = 0; Ae < he.length; Ae++) {
          var Ue = T(he, Ae, Ie, $e, ve + "[" + Ae + "]", c);
          if (Ue instanceof Error)
            return Ue;
        }
        return null;
      }
      return Q(B);
    }
    function fe() {
      function T(B, te, pe, Ie, $e) {
        var ve = B[te];
        if (!k(ve)) {
          var he = $(ve);
          return new ae("Invalid " + Ie + " `" + $e + "` of type " + ("`" + he + "` supplied to `" + pe + "`, expected a single ReactElement."));
        }
        return null;
      }
      return Q(T);
    }
    function Te() {
      function T(B, te, pe, Ie, $e) {
        var ve = B[te];
        if (!a.isValidElementType(ve)) {
          var he = $(ve);
          return new ae("Invalid " + Ie + " `" + $e + "` of type " + ("`" + he + "` supplied to `" + pe + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return Q(T);
    }
    function Re(T) {
      function B(te, pe, Ie, $e, ve) {
        if (!(te[pe] instanceof T)) {
          var he = T.name || j, Oe = L(te[pe]);
          return new ae("Invalid " + $e + " `" + ve + "` of type " + ("`" + Oe + "` supplied to `" + Ie + "`, expected ") + ("instance of `" + he + "`."));
        }
        return null;
      }
      return Q(B);
    }
    function Le(T) {
      if (!Array.isArray(T))
        return process$1.env.NODE_ENV !== "production" && (arguments.length > 1 ? p(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : p("Invalid argument supplied to oneOf, expected an array.")), _;
      function B(te, pe, Ie, $e, ve) {
        for (var he = te[pe], Oe = 0; Oe < T.length; Oe++)
          if (X(he, T[Oe]))
            return null;
        var Ae = JSON.stringify(T, function(oe, A) {
          var re = U(A);
          return re === "symbol" ? String(A) : A;
        });
        return new ae("Invalid " + $e + " `" + ve + "` of value `" + String(he) + "` " + ("supplied to `" + Ie + "`, expected one of " + Ae + "."));
      }
      return Q(B);
    }
    function be(T) {
      function B(te, pe, Ie, $e, ve) {
        if (typeof T != "function")
          return new ae("Property `" + ve + "` of component `" + Ie + "` has invalid PropType notation inside objectOf.");
        var he = te[pe], Oe = $(he);
        if (Oe !== "object")
          return new ae("Invalid " + $e + " `" + ve + "` of type " + ("`" + Oe + "` supplied to `" + Ie + "`, expected an object."));
        for (var Ae in he)
          if (l(he, Ae)) {
            var Ue = T(he, Ae, Ie, $e, ve + "." + Ae, c);
            if (Ue instanceof Error)
              return Ue;
          }
        return null;
      }
      return Q(B);
    }
    function q(T) {
      if (!Array.isArray(T))
        return process$1.env.NODE_ENV !== "production" && p("Invalid argument supplied to oneOfType, expected an instance of array."), _;
      for (var B = 0; B < T.length; B++) {
        var te = T[B];
        if (typeof te != "function")
          return p(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + Y(te) + " at index " + B + "."
          ), _;
      }
      function pe(Ie, $e, ve, he, Oe) {
        for (var Ae = [], Ue = 0; Ue < T.length; Ue++) {
          var oe = T[Ue], A = oe(Ie, $e, ve, he, Oe, c);
          if (A == null)
            return null;
          A.data && l(A.data, "expectedType") && Ae.push(A.data.expectedType);
        }
        var re = Ae.length > 0 ? ", expected one of type [" + Ae.join(", ") + "]" : "";
        return new ae("Invalid " + he + " `" + Oe + "` supplied to " + ("`" + ve + "`" + re + "."));
      }
      return Q(pe);
    }
    function J() {
      function T(B, te, pe, Ie, $e) {
        return I(B[te]) ? null : new ae("Invalid " + Ie + " `" + $e + "` supplied to " + ("`" + pe + "`, expected a ReactNode."));
      }
      return Q(T);
    }
    function C(T, B, te, pe, Ie) {
      return new ae(
        (T || "React class") + ": " + B + " type `" + te + "." + pe + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + Ie + "`."
      );
    }
    function S(T) {
      function B(te, pe, Ie, $e, ve) {
        var he = te[pe], Oe = $(he);
        if (Oe !== "object")
          return new ae("Invalid " + $e + " `" + ve + "` of type `" + Oe + "` " + ("supplied to `" + Ie + "`, expected `object`."));
        for (var Ae in T) {
          var Ue = T[Ae];
          if (typeof Ue != "function")
            return C(Ie, $e, ve, Ae, U(Ue));
          var oe = Ue(he, Ae, Ie, $e, ve + "." + Ae, c);
          if (oe)
            return oe;
        }
        return null;
      }
      return Q(B);
    }
    function E(T) {
      function B(te, pe, Ie, $e, ve) {
        var he = te[pe], Oe = $(he);
        if (Oe !== "object")
          return new ae("Invalid " + $e + " `" + ve + "` of type `" + Oe + "` " + ("supplied to `" + Ie + "`, expected `object`."));
        var Ae = u({}, te[pe], T);
        for (var Ue in Ae) {
          var oe = T[Ue];
          if (l(T, Ue) && typeof oe != "function")
            return C(Ie, $e, ve, Ue, U(oe));
          if (!oe)
            return new ae(
              "Invalid " + $e + " `" + ve + "` key `" + Ue + "` supplied to `" + Ie + "`.\nBad object: " + JSON.stringify(te[pe], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(T), null, "  ")
            );
          var A = oe(he, Ue, Ie, $e, ve + "." + Ue, c);
          if (A)
            return A;
        }
        return null;
      }
      return Q(B);
    }
    function I(T) {
      switch (typeof T) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !T;
        case "object":
          if (Array.isArray(T))
            return T.every(I);
          if (T === null || k(T))
            return !0;
          var B = z(T);
          if (B) {
            var te = B.call(T), pe;
            if (B !== T.entries) {
              for (; !(pe = te.next()).done; )
                if (!I(pe.value))
                  return !1;
            } else
              for (; !(pe = te.next()).done; ) {
                var Ie = pe.value;
                if (Ie && !I(Ie[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function M(T, B) {
      return T === "symbol" ? !0 : B ? B["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && B instanceof Symbol : !1;
    }
    function $(T) {
      var B = typeof T;
      return Array.isArray(T) ? "array" : T instanceof RegExp ? "object" : M(B, T) ? "symbol" : B;
    }
    function U(T) {
      if (typeof T > "u" || T === null)
        return "" + T;
      var B = $(T);
      if (B === "object") {
        if (T instanceof Date)
          return "date";
        if (T instanceof RegExp)
          return "regexp";
      }
      return B;
    }
    function Y(T) {
      var B = U(T);
      switch (B) {
        case "array":
        case "object":
          return "an " + B;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + B;
        default:
          return B;
      }
    }
    function L(T) {
      return !T.constructor || !T.constructor.name ? j : T.constructor.name;
    }
    return ee.checkPropTypes = v, ee.resetWarningCache = v.resetWarningCache, ee.PropTypes = ee, ee;
  }, factoryWithTypeCheckers;
}
var factoryWithThrowingShims, hasRequiredFactoryWithThrowingShims;
function requireFactoryWithThrowingShims() {
  if (hasRequiredFactoryWithThrowingShims)
    return factoryWithThrowingShims;
  hasRequiredFactoryWithThrowingShims = 1;
  var a = requireReactPropTypesSecret();
  function u() {
  }
  function c() {
  }
  return c.resetWarningCache = u, factoryWithThrowingShims = function() {
    function l(_, k, O, D, F, z) {
      if (z !== a) {
        var j = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw j.name = "Invariant Violation", j;
      }
    }
    l.isRequired = l;
    function v() {
      return l;
    }
    var p = {
      array: l,
      bigint: l,
      bool: l,
      func: l,
      number: l,
      object: l,
      string: l,
      symbol: l,
      any: l,
      arrayOf: v,
      element: l,
      elementType: l,
      instanceOf: v,
      node: l,
      objectOf: v,
      oneOf: v,
      oneOfType: v,
      shape: v,
      exact: v,
      checkPropTypes: c,
      resetWarningCache: u
    };
    return p.PropTypes = p, p;
  }, factoryWithThrowingShims;
}
if (process$1.env.NODE_ENV !== "production") {
  var ReactIs = requireReactIs(), throwOnDirectAccess = !0;
  propTypes.exports = requireFactoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
} else
  propTypes.exports = requireFactoryWithThrowingShims()();
var propTypesExports = propTypes.exports;
const PropTypes = /* @__PURE__ */ getDefaultExportFromCjs$2(propTypesExports);
function hasClass(a, u) {
  return a.classList ? !!u && a.classList.contains(u) : (" " + (a.className.baseVal || a.className) + " ").indexOf(" " + u + " ") !== -1;
}
function addClass(a, u) {
  a.classList ? a.classList.add(u) : hasClass(a, u) || (typeof a.className == "string" ? a.className = a.className + " " + u : a.setAttribute("class", (a.className && a.className.baseVal || "") + " " + u));
}
function replaceClassName(a, u) {
  return a.replace(new RegExp("(^|\\s)" + u + "(?:\\s|$)", "g"), "$1").replace(/\s+/g, " ").replace(/^\s*|\s*$/g, "");
}
function removeClass$1(a, u) {
  a.classList ? a.classList.remove(u) : typeof a.className == "string" ? a.className = replaceClassName(a.className, u) : a.setAttribute("class", replaceClassName(a.className && a.className.baseVal || "", u));
}
const config = {
  disabled: !1
};
var timeoutsShape = process$1.env.NODE_ENV !== "production" ? PropTypes.oneOfType([PropTypes.number, PropTypes.shape({
  enter: PropTypes.number,
  exit: PropTypes.number,
  appear: PropTypes.number
}).isRequired]) : null, classNamesShape = process$1.env.NODE_ENV !== "production" ? PropTypes.oneOfType([PropTypes.string, PropTypes.shape({
  enter: PropTypes.string,
  exit: PropTypes.string,
  active: PropTypes.string
}), PropTypes.shape({
  enter: PropTypes.string,
  enterDone: PropTypes.string,
  enterActive: PropTypes.string,
  exit: PropTypes.string,
  exitDone: PropTypes.string,
  exitActive: PropTypes.string
})]) : null;
const TransitionGroupContext = React.createContext(null);
var forceReflow = function a(u) {
  return u.scrollTop;
}, UNMOUNTED = "unmounted", EXITED = "exited", ENTERING = "entering", ENTERED = "entered", EXITING = "exiting", Transition = /* @__PURE__ */ function(a) {
  _inheritsLoose(u, a);
  function u(l, v) {
    var p;
    p = a.call(this, l, v) || this;
    var _ = v, k = _ && !_.isMounting ? l.enter : l.appear, O;
    return p.appearStatus = null, l.in ? k ? (O = EXITED, p.appearStatus = ENTERING) : O = ENTERED : l.unmountOnExit || l.mountOnEnter ? O = UNMOUNTED : O = EXITED, p.state = {
      status: O
    }, p.nextCallback = null, p;
  }
  u.getDerivedStateFromProps = function(v, p) {
    var _ = v.in;
    return _ && p.status === UNMOUNTED ? {
      status: EXITED
    } : null;
  };
  var c = u.prototype;
  return c.componentDidMount = function() {
    this.updateStatus(!0, this.appearStatus);
  }, c.componentDidUpdate = function(v) {
    var p = null;
    if (v !== this.props) {
      var _ = this.state.status;
      this.props.in ? _ !== ENTERING && _ !== ENTERED && (p = ENTERING) : (_ === ENTERING || _ === ENTERED) && (p = EXITING);
    }
    this.updateStatus(!1, p);
  }, c.componentWillUnmount = function() {
    this.cancelNextCallback();
  }, c.getTimeouts = function() {
    var v = this.props.timeout, p, _, k;
    return p = _ = k = v, v != null && typeof v != "number" && (p = v.exit, _ = v.enter, k = v.appear !== void 0 ? v.appear : _), {
      exit: p,
      enter: _,
      appear: k
    };
  }, c.updateStatus = function(v, p) {
    if (v === void 0 && (v = !1), p !== null)
      if (this.cancelNextCallback(), p === ENTERING) {
        if (this.props.unmountOnExit || this.props.mountOnEnter) {
          var _ = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
          _ && forceReflow(_);
        }
        this.performEnter(v);
      } else
        this.performExit();
    else
      this.props.unmountOnExit && this.state.status === EXITED && this.setState({
        status: UNMOUNTED
      });
  }, c.performEnter = function(v) {
    var p = this, _ = this.props.enter, k = this.context ? this.context.isMounting : v, O = this.props.nodeRef ? [k] : [ReactDOM.findDOMNode(this), k], D = O[0], F = O[1], z = this.getTimeouts(), j = k ? z.appear : z.enter;
    if (!v && !_ || config.disabled) {
      this.safeSetState({
        status: ENTERED
      }, function() {
        p.props.onEntered(D);
      });
      return;
    }
    this.props.onEnter(D, F), this.safeSetState({
      status: ENTERING
    }, function() {
      p.props.onEntering(D, F), p.onTransitionEnd(j, function() {
        p.safeSetState({
          status: ENTERED
        }, function() {
          p.props.onEntered(D, F);
        });
      });
    });
  }, c.performExit = function() {
    var v = this, p = this.props.exit, _ = this.getTimeouts(), k = this.props.nodeRef ? void 0 : ReactDOM.findDOMNode(this);
    if (!p || config.disabled) {
      this.safeSetState({
        status: EXITED
      }, function() {
        v.props.onExited(k);
      });
      return;
    }
    this.props.onExit(k), this.safeSetState({
      status: EXITING
    }, function() {
      v.props.onExiting(k), v.onTransitionEnd(_.exit, function() {
        v.safeSetState({
          status: EXITED
        }, function() {
          v.props.onExited(k);
        });
      });
    });
  }, c.cancelNextCallback = function() {
    this.nextCallback !== null && (this.nextCallback.cancel(), this.nextCallback = null);
  }, c.safeSetState = function(v, p) {
    p = this.setNextCallback(p), this.setState(v, p);
  }, c.setNextCallback = function(v) {
    var p = this, _ = !0;
    return this.nextCallback = function(k) {
      _ && (_ = !1, p.nextCallback = null, v(k));
    }, this.nextCallback.cancel = function() {
      _ = !1;
    }, this.nextCallback;
  }, c.onTransitionEnd = function(v, p) {
    this.setNextCallback(p);
    var _ = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this), k = v == null && !this.props.addEndListener;
    if (!_ || k) {
      setTimeout(this.nextCallback, 0);
      return;
    }
    if (this.props.addEndListener) {
      var O = this.props.nodeRef ? [this.nextCallback] : [_, this.nextCallback], D = O[0], F = O[1];
      this.props.addEndListener(D, F);
    }
    v != null && setTimeout(this.nextCallback, v);
  }, c.render = function() {
    var v = this.state.status;
    if (v === UNMOUNTED)
      return null;
    var p = this.props, _ = p.children;
    p.in, p.mountOnEnter, p.unmountOnExit, p.appear, p.enter, p.exit, p.timeout, p.addEndListener, p.onEnter, p.onEntering, p.onEntered, p.onExit, p.onExiting, p.onExited, p.nodeRef;
    var k = _objectWithoutPropertiesLoose(p, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
    return (
      // allows for nested Transitions
      /* @__PURE__ */ React.createElement(TransitionGroupContext.Provider, {
        value: null
      }, typeof _ == "function" ? _(v, k) : React.cloneElement(React.Children.only(_), k))
    );
  }, u;
}(React.Component);
Transition.contextType = TransitionGroupContext;
Transition.propTypes = process$1.env.NODE_ENV !== "production" ? {
  /**
   * A React reference to DOM element that need to transition:
   * https://stackoverflow.com/a/51127130/4671932
   *
   *   - When `nodeRef` prop is used, `node` is not passed to callback functions
   *      (e.g. `onEnter`) because user already has direct access to the node.
   *   - When changing `key` prop of `Transition` in a `TransitionGroup` a new
   *     `nodeRef` need to be provided to `Transition` with changed `key` prop
   *     (see
   *     [test/CSSTransition-test.js](https://github.com/reactjs/react-transition-group/blob/13435f897b3ab71f6e19d724f145596f5910581c/test/CSSTransition-test.js#L362-L437)).
   */
  nodeRef: PropTypes.shape({
    current: typeof Element > "u" ? PropTypes.any : function(a, u, c, l, v, p) {
      var _ = a[u];
      return PropTypes.instanceOf(_ && "ownerDocument" in _ ? _.ownerDocument.defaultView.Element : Element)(a, u, c, l, v, p);
    }
  }),
  /**
   * A `function` child can be used instead of a React element. This function is
   * called with the current transition status (`'entering'`, `'entered'`,
   * `'exiting'`, `'exited'`), which can be used to apply context
   * specific props to a component.
   *
   * ```jsx
   * <Transition in={this.state.in} timeout={150}>
   *   {state => (
   *     <MyComponent className={`fade fade-${state}`} />
   *   )}
   * </Transition>
   * ```
   */
  children: PropTypes.oneOfType([PropTypes.func.isRequired, PropTypes.element.isRequired]).isRequired,
  /**
   * Show the component; triggers the enter or exit states
   */
  in: PropTypes.bool,
  /**
   * By default the child component is mounted immediately along with
   * the parent `Transition` component. If you want to "lazy mount" the component on the
   * first `in={true}` you can set `mountOnEnter`. After the first enter transition the component will stay
   * mounted, even on "exited", unless you also specify `unmountOnExit`.
   */
  mountOnEnter: PropTypes.bool,
  /**
   * By default the child component stays mounted after it reaches the `'exited'` state.
   * Set `unmountOnExit` if you'd prefer to unmount the component after it finishes exiting.
   */
  unmountOnExit: PropTypes.bool,
  /**
   * By default the child component does not perform the enter transition when
   * it first mounts, regardless of the value of `in`. If you want this
   * behavior, set both `appear` and `in` to `true`.
   *
   * > **Note**: there are no special appear states like `appearing`/`appeared`, this prop
   * > only adds an additional enter transition. However, in the
   * > `<CSSTransition>` component that first enter transition does result in
   * > additional `.appear-*` classes, that way you can choose to style it
   * > differently.
   */
  appear: PropTypes.bool,
  /**
   * Enable or disable enter transitions.
   */
  enter: PropTypes.bool,
  /**
   * Enable or disable exit transitions.
   */
  exit: PropTypes.bool,
  /**
   * The duration of the transition, in milliseconds.
   * Required unless `addEndListener` is provided.
   *
   * You may specify a single timeout for all transitions:
   *
   * ```jsx
   * timeout={500}
   * ```
   *
   * or individually:
   *
   * ```jsx
   * timeout={{
   *  appear: 500,
   *  enter: 300,
   *  exit: 500,
   * }}
   * ```
   *
   * - `appear` defaults to the value of `enter`
   * - `enter` defaults to `0`
   * - `exit` defaults to `0`
   *
   * @type {number | { enter?: number, exit?: number, appear?: number }}
   */
  timeout: function a(u) {
    var c = timeoutsShape;
    u.addEndListener || (c = c.isRequired);
    for (var l = arguments.length, v = new Array(l > 1 ? l - 1 : 0), p = 1; p < l; p++)
      v[p - 1] = arguments[p];
    return c.apply(void 0, [u].concat(v));
  },
  /**
   * Add a custom transition end trigger. Called with the transitioning
   * DOM node and a `done` callback. Allows for more fine grained transition end
   * logic. Timeouts are still used as a fallback if provided.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * ```jsx
   * addEndListener={(node, done) => {
   *   // use the css transitionend event to mark the finish of a transition
   *   node.addEventListener('transitionend', done, false);
   * }}
   * ```
   */
  addEndListener: PropTypes.func,
  /**
   * Callback fired before the "entering" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool) -> void
   */
  onEnter: PropTypes.func,
  /**
   * Callback fired after the "entering" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEntering: PropTypes.func,
  /**
   * Callback fired after the "entered" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool) -> void
   */
  onEntered: PropTypes.func,
  /**
   * Callback fired before the "exiting" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExit: PropTypes.func,
  /**
   * Callback fired after the "exiting" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExiting: PropTypes.func,
  /**
   * Callback fired after the "exited" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExited: PropTypes.func
} : {};
function noop() {
}
Transition.defaultProps = {
  in: !1,
  mountOnEnter: !1,
  unmountOnExit: !1,
  appear: !1,
  enter: !0,
  exit: !0,
  onEnter: noop,
  onEntering: noop,
  onEntered: noop,
  onExit: noop,
  onExiting: noop,
  onExited: noop
};
Transition.UNMOUNTED = UNMOUNTED;
Transition.EXITED = EXITED;
Transition.ENTERING = ENTERING;
Transition.ENTERED = ENTERED;
Transition.EXITING = EXITING;
const Transition$1 = Transition;
var _addClass = function a(u, c) {
  return u && c && c.split(" ").forEach(function(l) {
    return addClass(u, l);
  });
}, removeClass = function a(u, c) {
  return u && c && c.split(" ").forEach(function(l) {
    return removeClass$1(u, l);
  });
}, CSSTransition = /* @__PURE__ */ function(a) {
  _inheritsLoose(u, a);
  function u() {
    for (var l, v = arguments.length, p = new Array(v), _ = 0; _ < v; _++)
      p[_] = arguments[_];
    return l = a.call.apply(a, [this].concat(p)) || this, l.appliedClasses = {
      appear: {},
      enter: {},
      exit: {}
    }, l.onEnter = function(k, O) {
      var D = l.resolveArguments(k, O), F = D[0], z = D[1];
      l.removeClasses(F, "exit"), l.addClass(F, z ? "appear" : "enter", "base"), l.props.onEnter && l.props.onEnter(k, O);
    }, l.onEntering = function(k, O) {
      var D = l.resolveArguments(k, O), F = D[0], z = D[1], j = z ? "appear" : "enter";
      l.addClass(F, j, "active"), l.props.onEntering && l.props.onEntering(k, O);
    }, l.onEntered = function(k, O) {
      var D = l.resolveArguments(k, O), F = D[0], z = D[1], j = z ? "appear" : "enter";
      l.removeClasses(F, j), l.addClass(F, j, "done"), l.props.onEntered && l.props.onEntered(k, O);
    }, l.onExit = function(k) {
      var O = l.resolveArguments(k), D = O[0];
      l.removeClasses(D, "appear"), l.removeClasses(D, "enter"), l.addClass(D, "exit", "base"), l.props.onExit && l.props.onExit(k);
    }, l.onExiting = function(k) {
      var O = l.resolveArguments(k), D = O[0];
      l.addClass(D, "exit", "active"), l.props.onExiting && l.props.onExiting(k);
    }, l.onExited = function(k) {
      var O = l.resolveArguments(k), D = O[0];
      l.removeClasses(D, "exit"), l.addClass(D, "exit", "done"), l.props.onExited && l.props.onExited(k);
    }, l.resolveArguments = function(k, O) {
      return l.props.nodeRef ? [l.props.nodeRef.current, k] : [k, O];
    }, l.getClassNames = function(k) {
      var O = l.props.classNames, D = typeof O == "string", F = D && O ? O + "-" : "", z = D ? "" + F + k : O[k], j = D ? z + "-active" : O[k + "Active"], ee = D ? z + "-done" : O[k + "Done"];
      return {
        baseClassName: z,
        activeClassName: j,
        doneClassName: ee
      };
    }, l;
  }
  var c = u.prototype;
  return c.addClass = function(v, p, _) {
    var k = this.getClassNames(p)[_ + "ClassName"], O = this.getClassNames("enter"), D = O.doneClassName;
    p === "appear" && _ === "done" && D && (k += " " + D), _ === "active" && v && forceReflow(v), k && (this.appliedClasses[p][_] = k, _addClass(v, k));
  }, c.removeClasses = function(v, p) {
    var _ = this.appliedClasses[p], k = _.base, O = _.active, D = _.done;
    this.appliedClasses[p] = {}, k && removeClass(v, k), O && removeClass(v, O), D && removeClass(v, D);
  }, c.render = function() {
    var v = this.props;
    v.classNames;
    var p = _objectWithoutPropertiesLoose(v, ["classNames"]);
    return /* @__PURE__ */ React.createElement(Transition$1, _extends({}, p, {
      onEnter: this.onEnter,
      onEntered: this.onEntered,
      onEntering: this.onEntering,
      onExit: this.onExit,
      onExiting: this.onExiting,
      onExited: this.onExited
    }));
  }, u;
}(React.Component);
CSSTransition.defaultProps = {
  classNames: ""
};
CSSTransition.propTypes = process$1.env.NODE_ENV !== "production" ? _extends({}, Transition$1.propTypes, {
  /**
   * The animation classNames applied to the component as it appears, enters,
   * exits or has finished the transition. A single name can be provided, which
   * will be suffixed for each stage, e.g. `classNames="fade"` applies:
   *
   * - `fade-appear`, `fade-appear-active`, `fade-appear-done`
   * - `fade-enter`, `fade-enter-active`, `fade-enter-done`
   * - `fade-exit`, `fade-exit-active`, `fade-exit-done`
   *
   * A few details to note about how these classes are applied:
   *
   * 1. They are _joined_ with the ones that are already defined on the child
   *    component, so if you want to add some base styles, you can use
   *    `className` without worrying that it will be overridden.
   *
   * 2. If the transition component mounts with `in={false}`, no classes are
   *    applied yet. You might be expecting `*-exit-done`, but if you think
   *    about it, a component cannot finish exiting if it hasn't entered yet.
   *
   * 2. `fade-appear-done` and `fade-enter-done` will _both_ be applied. This
   *    allows you to define different behavior for when appearing is done and
   *    when regular entering is done, using selectors like
   *    `.fade-enter-done:not(.fade-appear-done)`. For example, you could apply
   *    an epic entrance animation when element first appears in the DOM using
   *    [Animate.css](https://daneden.github.io/animate.css/). Otherwise you can
   *    simply use `fade-enter-done` for defining both cases.
   *
   * Each individual classNames can also be specified independently like:
   *
   * ```js
   * classNames={{
   *  appear: 'my-appear',
   *  appearActive: 'my-active-appear',
   *  appearDone: 'my-done-appear',
   *  enter: 'my-enter',
   *  enterActive: 'my-active-enter',
   *  enterDone: 'my-done-enter',
   *  exit: 'my-exit',
   *  exitActive: 'my-active-exit',
   *  exitDone: 'my-done-exit',
   * }}
   * ```
   *
   * If you want to set these classes using CSS Modules:
   *
   * ```js
   * import styles from './styles.css';
   * ```
   *
   * you might want to use camelCase in your CSS file, that way could simply
   * spread them instead of listing them one by one:
   *
   * ```js
   * classNames={{ ...styles }}
   * ```
   *
   * @type {string | {
   *  appear?: string,
   *  appearActive?: string,
   *  appearDone?: string,
   *  enter?: string,
   *  enterActive?: string,
   *  enterDone?: string,
   *  exit?: string,
   *  exitActive?: string,
   *  exitDone?: string,
   * }}
   */
  classNames: classNamesShape,
  /**
   * A `<Transition>` callback fired immediately after the 'enter' or 'appear' class is
   * applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEnter: PropTypes.func,
  /**
   * A `<Transition>` callback fired immediately after the 'enter-active' or
   * 'appear-active' class is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEntering: PropTypes.func,
  /**
   * A `<Transition>` callback fired immediately after the 'enter' or
   * 'appear' classes are **removed** and the `done` class is added to the DOM node.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEntered: PropTypes.func,
  /**
   * A `<Transition>` callback fired immediately after the 'exit' class is
   * applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement)
   */
  onExit: PropTypes.func,
  /**
   * A `<Transition>` callback fired immediately after the 'exit-active' is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement)
   */
  onExiting: PropTypes.func,
  /**
   * A `<Transition>` callback fired immediately after the 'exit' classes
   * are **removed** and the `exit-done` class is added to the DOM node.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement)
   */
  onExited: PropTypes.func
}) : {};
const CSSTransition$1 = CSSTransition;
var _leaveRenders, _enterRenders;
function areChildrenDifferent(a, u) {
  return !(a === u || React.isValidElement(a) && React.isValidElement(u) && a.key != null && a.key === u.key);
}
var modes = {
  out: "out-in",
  in: "in-out"
}, callHook = function a(u, c, l) {
  return function() {
    var v;
    u.props[c] && (v = u.props)[c].apply(v, arguments), l();
  };
}, leaveRenders = (_leaveRenders = {}, _leaveRenders[modes.out] = function(a) {
  var u = a.current, c = a.changeState;
  return React.cloneElement(u, {
    in: !1,
    onExited: callHook(u, "onExited", function() {
      c(ENTERING, null);
    })
  });
}, _leaveRenders[modes.in] = function(a) {
  var u = a.current, c = a.changeState, l = a.children;
  return [u, React.cloneElement(l, {
    in: !0,
    onEntered: callHook(l, "onEntered", function() {
      c(ENTERING);
    })
  })];
}, _leaveRenders), enterRenders = (_enterRenders = {}, _enterRenders[modes.out] = function(a) {
  var u = a.children, c = a.changeState;
  return React.cloneElement(u, {
    in: !0,
    onEntered: callHook(u, "onEntered", function() {
      c(ENTERED, React.cloneElement(u, {
        in: !0
      }));
    })
  });
}, _enterRenders[modes.in] = function(a) {
  var u = a.current, c = a.children, l = a.changeState;
  return [React.cloneElement(u, {
    in: !1,
    onExited: callHook(u, "onExited", function() {
      l(ENTERED, React.cloneElement(c, {
        in: !0
      }));
    })
  }), React.cloneElement(c, {
    in: !0
  })];
}, _enterRenders), SwitchTransition = /* @__PURE__ */ function(a) {
  _inheritsLoose(u, a);
  function u() {
    for (var l, v = arguments.length, p = new Array(v), _ = 0; _ < v; _++)
      p[_] = arguments[_];
    return l = a.call.apply(a, [this].concat(p)) || this, l.state = {
      status: ENTERED,
      current: null
    }, l.appeared = !1, l.changeState = function(k, O) {
      O === void 0 && (O = l.state.current), l.setState({
        status: k,
        current: O
      });
    }, l;
  }
  var c = u.prototype;
  return c.componentDidMount = function() {
    this.appeared = !0;
  }, u.getDerivedStateFromProps = function(v, p) {
    return v.children == null ? {
      current: null
    } : p.status === ENTERING && v.mode === modes.in ? {
      status: ENTERING
    } : p.current && areChildrenDifferent(p.current, v.children) ? {
      status: EXITING
    } : {
      current: React.cloneElement(v.children, {
        in: !0
      })
    };
  }, c.render = function() {
    var v = this.props, p = v.children, _ = v.mode, k = this.state, O = k.status, D = k.current, F = {
      children: p,
      current: D,
      changeState: this.changeState,
      status: O
    }, z;
    switch (O) {
      case ENTERING:
        z = enterRenders[_](F);
        break;
      case EXITING:
        z = leaveRenders[_](F);
        break;
      case ENTERED:
        z = D;
    }
    return /* @__PURE__ */ React.createElement(TransitionGroupContext.Provider, {
      value: {
        isMounting: !this.appeared
      }
    }, z);
  }, u;
}(React.Component);
SwitchTransition.propTypes = process$1.env.NODE_ENV !== "production" ? {
  /**
   * Transition modes.
   * `out-in`: Current element transitions out first, then when complete, the new element transitions in.
   * `in-out`: New element transitions in first, then when complete, the current element transitions out.
   *
   * @type {'out-in'|'in-out'}
   */
  mode: PropTypes.oneOf([modes.in, modes.out]),
  /**
   * Any `Transition` or `CSSTransition` component.
   */
  children: PropTypes.oneOfType([PropTypes.element.isRequired])
} : {};
SwitchTransition.defaultProps = {
  mode: modes.out
};
const SwitchTransition$1 = SwitchTransition, Animations = {
  "fade-in": ".fade-in{-webkit-animation:fade-in;animation:fade-in}@-webkit-keyframes fade-in{0%{opacity:0}100%{opacity:1}}@keyframes fade-in{0%{opacity:0}100%{opacity:1}}",
  "fade-out": ".fade-out{-webkit-animation:fade-out;animation:fade-out}@-webkit-keyframes fade-out{0%{opacity:1}100%{opacity:0}}@keyframes fade-out{0%{opacity:1}100%{opacity:0}}",
  "slide-in-blurred-top": ".slide-in-blurred-top{-webkit-animation:slide-in-blurred-top .6s cubic-bezier(.23,1.000,.32,1.000) both;animation:slide-in-blurred-top .6s cubic-bezier(.23,1.000,.32,1.000) both}@-webkit-keyframes slide-in-blurred-top{0%{-webkit-transform:translateY(-1000px) scaleY(2.5) scaleX(.2);transform:translateY(-1000px) scaleY(2.5) scaleX(.2);-webkit-transform-origin:50% 0;transform-origin:50% 0;-webkit-filter:blur(40px);filter:blur(40px);opacity:0}100%{-webkit-transform:translateY(0) scaleY(1) scaleX(1);transform:translateY(0) scaleY(1) scaleX(1);-webkit-transform-origin:50% 50%;transform-origin:50% 50%;-webkit-filter:blur(0);filter:blur(0);opacity:1}}@keyframes slide-in-blurred-top{0%{-webkit-transform:translateY(-1000px) scaleY(2.5) scaleX(.2);transform:translateY(-1000px) scaleY(2.5) scaleX(.2);-webkit-transform-origin:50% 0;transform-origin:50% 0;-webkit-filter:blur(40px);filter:blur(40px);opacity:0}100%{-webkit-transform:translateY(0) scaleY(1) scaleX(1);transform:translateY(0) scaleY(1) scaleX(1);-webkit-transform-origin:50% 50%;transform-origin:50% 50%;-webkit-filter:blur(0);filter:blur(0);opacity:1}}",
  "slide-in-left": ".slide-in-left{-webkit-animation:slide-in-left .5s cubic-bezier(.25,.46,.45,.94) both;animation:slide-in-left .5s cubic-bezier(.25,.46,.45,.94) both}@-webkit-keyframes slide-in-left{0%{-webkit-transform:translateX(-1000px);transform:translateX(-1000px);opacity:0}100%{-webkit-transform:translateX(0);transform:translateX(0);opacity:1}}@keyframes slide-in-left{0%{-webkit-transform:translateX(-1000px);transform:translateX(-1000px);opacity:0}100%{-webkit-transform:translateX(0);transform:translateX(0);opacity:1}}",
  "slide-out-left": ".slide-out-left{-webkit-animation:slide-out-left .5s cubic-bezier(.55,.085,.68,.53) both;animation:slide-out-left .5s cubic-bezier(.55,.085,.68,.53) both}@-webkit-keyframes slide-out-left{0%{-webkit-transform:translateX(0);transform:translateX(0);opacity:1}100%{-webkit-transform:translateX(-1000px);transform:translateX(-1000px);opacity:0}}@keyframes slide-out-left{0%{-webkit-transform:translateX(0);transform:translateX(0);opacity:1}100%{-webkit-transform:translateX(-1000px);transform:translateX(-1000px);opacity:0}}"
}, APIKitAnimation = (a) => {
  const {
    enter: u,
    exit: c,
    children: l,
    tag: v = "div",
    direction: p = "normal",
    duration: _ = 500,
    id: k,
    type: O
  } = a, D = k ? `${O}-${k}` : `${O}-api-kit-animation`;
  return /* @__PURE__ */ React.createElement("div", {
    style: {
      height: "100%",
      width: "100%"
    }
  }, /* @__PURE__ */ React.createElement("style", {
    dangerouslySetInnerHTML: {
      __html: renderStyle(O, u, c, _, p)
    }
  }), /* @__PURE__ */ React.createElement(SwitchTransition$1, {
    mode: "out-in"
  }, /* @__PURE__ */ React.createElement(CSSTransition$1, {
    key: D,
    addEndListener: (F, z) => {
      F.addEventListener("transitionend", z, !1);
    },
    classNames: {
      enter: `${O}-default-enter`,
      enterActive: u,
      exit: `${O}-default-leave`,
      exitActive: c
    },
    timeout: _
  }, /* @__PURE__ */ React.createElement("div", {
    style: {
      height: "100%",
      width: "100%"
    }
  }, l))));
}, renderStyle = (a, u, c, l, v) => `
        body {
          margin: 0;
          padding: 0;
        }
        
        ${Animations[u]}
        
        ${Animations[c]}

        .${a}-transition {
          transition: opacity ${l}ms ease-out};
        }

        .${a}-default-enter {
          opacity: 0;
        }

        .${a}-default-enter.${u} {
          animation-direction: ${v};
          animation-duration: ${l / 1e3}s;
          animation-fill-mode: both;
          animation-timing-function: ease-out;
        }

        .${a}-default-leave {
          opacity: 1;
        }

        .${a}-default-leave.${c} {
          animation-direction: ${v};
          animation-duration: ${l / 1e3}s;
          animation-timing-function: ease-out;
          animation-fill-mode: both;
        }
        `, APIKitAnimation$1 = APIKitAnimation, Background = {
  name: "LS-Background",
  sourceType: "Background",
  create({
    onUpdate: a,
    onRemove: u
  }, {
    sourceProps: c
  }) {
    u(() => {
      clearInterval(p);
    });
    const l = document.createElement("div"), v = getProject(CoreContext.state.activeProjectId).role;
    let p;
    const _ = ({
      source: z,
      setStartAnimation: j
    }) => {
      var q, J;
      const {
        src: ee,
        type: X,
        meta: ae,
        loop: Q
      } = (z == null ? void 0 : z.sourceProps) || {}, {
        id: ne,
        sourceType: Z
      } = z || {}, [de, fe] = React.useState(null), Te = React.useRef(null);
      console.log("Updated current time", (q = Te == null ? void 0 : Te.current) == null ? void 0 : q.currentTime);
      const Re = React.useCallback((C) => {
        Te.current = C, fe(C ? C.id : null);
      }, []), Le = React.useCallback(() => {
        Te != null && Te.current && Te.current.play().catch(() => {
          var C;
          Te.current.muted = !0, (C = Te.current) == null || C.play();
        });
      }, [ee]), be = React.useCallback(() => {
        p && clearInterval(p), hasPermission(v, Permission.UpdateProject) && trigger$1("VideoEnded", {
          id: ne,
          category: X
        });
      }, [ee]);
      return React.useEffect(() => {
        ae && (Te != null && Te.current) && de && hasPermission(v, Permission.ManageSelf) && ae != null && ae.time && (Te.current.currentTime = Number(ae == null ? void 0 : ae.time));
      }, [ae == null ? void 0 : ae.time, de]), React.useEffect(() => () => {
        p && clearInterval(p);
      }, [ne]), React.useEffect(() => {
        de ? Te.current && (Te.current.src = ee, Te.current.play().catch(() => {
          Te.current.muted = !0, Te.current.play();
        }), hasPermission(v, Permission.UpdateProject) && (p = setInterval(() => {
          if (Te.current.duration) {
            const C = Te.current.duration - Te.current.currentTime;
            trigger$1("VideoTimeUpdate", {
              category: Z,
              id: ne,
              time: Math.floor(C)
            });
          }
        }, 1e3))) : p && clearInterval(p);
      }, [de]), /* @__PURE__ */ React.createElement(React.Fragment, {
        key: ne
      }, ee && /* @__PURE__ */ React.createElement("video", {
        loop: Q,
        id: ne,
        ref: Re,
        style: {
          ...(J = c == null ? void 0 : c.meta) == null ? void 0 : J.style,
          ...ae.style
        },
        onLoadedData: Le,
        onEnded: be,
        onCanPlay: () => j(!0)
      }));
    }, k = ({
      source: z,
      setStartAnimation: j
    }) => {
      var ne;
      const {
        src: ee,
        meta: X,
        type: ae
      } = (z == null ? void 0 : z.sourceProps) || {}, {
        id: Q
      } = z || {};
      return /* @__PURE__ */ React.createElement(React.Fragment, {
        key: Q
      }, ee && /* @__PURE__ */ React.createElement("img", {
        style: {
          ...(ne = c == null ? void 0 : c.meta) == null ? void 0 : ne.style,
          ...X == null ? void 0 : X.style
        },
        src: ee,
        onLoad: () => j(!0)
      }));
    }, O = ({
      source: z
    }) => {
      const {
        type: j
      } = z.sourceProps, {
        id: ee
      } = z || {}, [X, ae] = React.useState(!1);
      return useEffect(() => {
        ae(!1);
      }, [ee]), /* @__PURE__ */ React.createElement(APIKitAnimation$1, {
        id: ee,
        type: "background",
        enter: APIKitAnimationTypes.FADE_IN,
        exit: APIKitAnimationTypes.FADE_OUT,
        duration: 400
      }, /* @__PURE__ */ React.createElement("div", {
        style: {
          opacity: X ? 1 : 0
        },
        className: "backgroundContainer background-transition"
      }, ee && j === "image" && /* @__PURE__ */ React.createElement(k, {
        source: z,
        setStartAnimation: ae
      }), ee && j === "video" && /* @__PURE__ */ React.createElement(_, {
        source: z,
        setStartAnimation: ae
      })));
    }, D = createRoot(l), F = (z) => D.render(/* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(O, {
      source: z
    })));
    return a((z) => {
      F({
        ...z
      });
    }), {
      root: l
    };
  }
}, Banner = {
  name: "LS-Banner",
  sourceType: "Banner",
  props: {
    bannerId: {
      type: String,
      required: !0
    }
  },
  useSource(a, u) {
    return a.find((c) => c.id === u.bannerId);
  },
  create({
    onUpdate: a,
    onNewSource: u
  }, c) {
    const l = document.createElement("div");
    let v, p, _;
    const k = ({
      currentSource: F,
      latestSource: z
    }) => {
      const [j, ee] = useState(!1), {
        headerText: X,
        bodyText: ae
      } = (z == null ? void 0 : z.value) || {};
      return useEffect(() => {
        window.setTimeout(() => {
          ee(!!F);
        }), F || ee(!1);
      }, [F]), /* @__PURE__ */ React.createElement("div", {
        className: "BannerContainer",
        style: {
          position: "absolute",
          top: 0,
          left: 0,
          width: "100%",
          height: "100%",
          display: "flex",
          flexDirection: "row",
          justifyContent: "flex-start",
          alignItems: "flex-end",
          transition: "200ms ease all",
          ...j ? {
            zIndex: 2,
            opacity: 1,
            transform: "translateX(0)"
          } : {
            zIndex: 1,
            opacity: 0,
            transform: "translateX(-200px)"
          }
        }
      }, /* @__PURE__ */ React.createElement("div", {
        className: "Banner",
        style: {
          padding: 10,
          background: "orange",
          width: "fit-content",
          height: "fit-content",
          maxWidth: "84%",
          position: "relative"
        }
      }, X && /* @__PURE__ */ React.createElement("div", {
        className: "Banner-header",
        style: {
          marginBottom: 6
        }
      }, X), ae && /* @__PURE__ */ React.createElement("div", {
        className: "Banner-body"
      }, ae)));
    }, O = createRoot(l), D = () => O.render(/* @__PURE__ */ React.createElement(React.Fragment, null, _ && _.id !== p.id && /* @__PURE__ */ React.createElement(k, {
      key: _ == null ? void 0 : _.id,
      currentSource: null,
      latestSource: _
    }), /* @__PURE__ */ React.createElement(k, {
      key: p == null ? void 0 : p.id,
      currentSource: v,
      latestSource: p
    })));
    return a(() => {
      D();
    }), u((F) => {
      _ = v, v = F, v && (p = v), D();
    }), {
      root: l
    };
  }
};
var functionExpression = /[\s]*([a-z-]+)[\s]*\([\s]*([^\)]+)[\s]*\)[\s]*/i, floatExpression = /^(\-?\d+\.?\d{0,5})/, toFloat = parseFloat;
function ensurePercent(a) {
  return typeof a == "number" ? a : toFloat(a) * 0.01;
}
function formatPercent(a) {
  return formatFloat(a * 100) + "%";
}
function formatFloat(a) {
  return floatExpression.exec(a.toString())[1];
}
function parseCSSFunction(a) {
  var u = functionExpression.exec(a);
  if (!(!u || !u.length))
    return [u[1]].concat(u[2].split(","));
}
function cssFunction(a, u) {
  var c = Array.prototype.join.call(u, ", ");
  return a + "(" + c + ")";
}
var math = Math, round = math.round;
function roundFloat(a, u) {
  return round(a * u) / u;
}
var _a, RGB = "rgb", HSL = "hsl", converters = (_a = {}, _a[RGB + HSL] = RGBtoHSL, _a[HSL + RGB] = HSLtoRGB, _a), maxChannelValues = {
  r: 255,
  g: 255,
  b: 255,
  h: 360,
  s: 1,
  l: 1,
  a: 1
};
function color(a) {
  return parseHexCode(a) || parseColorFunction(a) || rgb(255, 0, 0);
}
function rgb(a, u, c, l) {
  return new ColorHelper(
    RGB,
    a,
    u,
    c,
    l === void 0 ? 1 : ensurePercent(l),
    l !== void 0
    /* hasAlpha*/
  );
}
function convertHelper(a, u, c) {
  var l = u.f, v = u.r, p = u.g, _ = u.b, k = u.a, O = c === void 0 ? u.o : c;
  return l !== a ? converters[l + a](v, p, _, k, O) : c === void 0 ? u : new ColorHelper(l, v, p, _, k, O);
}
var ColorHelper = (
  /** @class */
  function() {
    function a(u, c, l, v, p, _) {
      var k = this;
      k.f = u, k.o = _;
      var O = u === HSL;
      k.r = clampColor(O ? "h" : "r", c), k.g = clampColor(O ? "s" : "g", l), k.b = clampColor(O ? "l" : "b", v), k.a = clampColor("a", p);
    }
    return a.prototype.toString = function() {
      var u = this, c = u.o, l = u.f, v = u.r, p = u.g, _ = u.b, k = u.a, O, D;
      if (l === RGB)
        O = c ? "rgba" : RGB, D = [round(v), round(p), round(_)];
      else if (l === HSL)
        O = c ? "hsla" : HSL, D = [round(v), formatPercent(roundFloat(p, 100)), formatPercent(roundFloat(_, 100))];
      else
        throw new Error("Invalid color format");
      return c && D.push(formatFloat(roundFloat(k, 1e5))), cssFunction(O, D);
    }, a.prototype.toHexString = function() {
      var u = convertHelper(RGB, this);
      return "#" + (toHex(u.r) + toHex(u.g) + toHex(u.b)).toUpperCase();
    }, a.prototype.toHSL = function() {
      return convertHelper(HSL, this, !1);
    }, a.prototype.toHSLA = function() {
      return convertHelper(HSL, this, !0);
    }, a.prototype.toRGB = function() {
      return convertHelper(RGB, this, !1);
    }, a.prototype.toRGBA = function() {
      return convertHelper(RGB, this, !0);
    }, a.prototype.red = function() {
      var u = this;
      return (u.f === RGB ? u : u.toRGB()).r;
    }, a.prototype.green = function() {
      var u = this;
      return (u.f === RGB ? u : u.toRGB()).g;
    }, a.prototype.blue = function() {
      var u = this;
      return (u.f === RGB ? u : u.toRGB()).b;
    }, a.prototype.hue = function() {
      var u = this;
      return (u.f === HSL ? u : u.toHSL()).r;
    }, a.prototype.saturation = function() {
      var u = this;
      return (u.f === HSL ? u : u.toHSL()).g;
    }, a.prototype.lightness = function() {
      var u = this;
      return (u.f === HSL ? u : u.toHSL()).b;
    }, a.prototype.alpha = function() {
      return this.a;
    }, a.prototype.opacity = function() {
      return this.a;
    }, a.prototype.invert = function() {
      var u = this, c = convertHelper(RGB, u);
      return convertHelper(u.f, new a(RGB, 255 - c.r, 255 - c.g, 255 - c.b, u.a, u.o));
    }, a.prototype.lighten = function(u, c) {
      var l = this, v = convertHelper(HSL, l), p = maxChannelValues.l, _ = v.b + (c ? p - v.b : p) * ensurePercent(u);
      return convertHelper(l.f, new a(HSL, v.r, v.g, _, l.a, l.o));
    }, a.prototype.darken = function(u, c) {
      var l = this, v = convertHelper(HSL, l), p = v.b - (c ? v.b : maxChannelValues.l) * ensurePercent(u);
      return convertHelper(l.f, new a(HSL, v.r, v.g, p, l.a, l.o));
    }, a.prototype.saturate = function(u, c) {
      var l = this, v = convertHelper(HSL, l), p = maxChannelValues.s, _ = v.g + (c ? p - v.g : p) * ensurePercent(u);
      return convertHelper(l.f, new a(HSL, v.r, _, v.b, l.a, l.o));
    }, a.prototype.desaturate = function(u, c) {
      var l = this, v = convertHelper(HSL, l), p = maxChannelValues.s, _ = v.g - (c ? v.g : p) * ensurePercent(u);
      return convertHelper(l.f, new a(HSL, v.r, _, v.b, l.a, l.o));
    }, a.prototype.grayscale = function() {
      return this.desaturate(1);
    }, a.prototype.fade = function(u) {
      var c = this, l = clampColor("a", ensurePercent(u));
      return convertHelper(c.f, new a(c.f, c.r, c.g, c.b, l, !0));
    }, a.prototype.fadeOut = function(u, c) {
      var l = this, v = 1, p = clampColor("a", l.a - (c ? l.a : v) * ensurePercent(u));
      return convertHelper(l.f, new a(l.f, l.r, l.g, l.b, p, !0));
    }, a.prototype.fadeIn = function(u, c) {
      var l = this, v = 1, p = clampColor("a", l.a + (c ? l.a : v) * ensurePercent(u));
      return convertHelper(l.f, new a(l.f, l.r, l.g, l.b, p, !0));
    }, a.prototype.mix = function(u, c) {
      var l = this, v = ensureColor(u), p = convertHelper(RGB, l), _ = convertHelper(RGB, v), k = c === void 0 ? 0.5 : c, O = 2 * k - 1, D = Math.abs(p.a - _.a), F = ((O * D === -1 ? O : (O + D) / (1 + O * D)) + 1) / 2, z = 1 - F, j = new a(RGB, round(p.r * F + _.r * z), round(p.g * F + _.g * z), round(p.b * F + _.b * z), p.a * k + _.a * (1 - k), l.o || v.o);
      return convertHelper(this.f, j);
    }, a.prototype.tint = function(u) {
      return rgb(255, 255, 255).mix(this, u);
    }, a.prototype.shade = function(u) {
      return rgb(0, 0, 0).mix(this, u);
    }, a.prototype.spin = function(u) {
      var c = this, l = convertHelper(HSL, c);
      return convertHelper(c.f, new a(HSL, modDegrees(l.r + u), l.g, l.b, c.a, c.o));
    }, a;
  }()
);
function toHex(a) {
  var u = round(a);
  return (u < 16 ? "0" : "") + u.toString(16);
}
function modDegrees(a) {
  return ((a < 0 ? 360 : 0) + a % 360) % 360;
}
function RGBtoHSL(a, u, c, l, v) {
  var p = a / 255, _ = u / 255, k = c / 255, O = Math.min(p, _, k), D = Math.max(p, _, k), F = (O + D) / 2, z = D - O, j;
  D === O ? j = 0 : p === D ? j = (_ - k) / z : _ === D ? j = 2 + (k - p) / z : k === D ? j = 4 + (p - _) / z : j = 0, j = Math.min(j * 60, 360), j < 0 && (j += 360);
  var ee;
  return D === O ? ee = 0 : F <= 0.5 ? ee = z / (D + O) : ee = z / (2 - D - O), new ColorHelper(HSL, j, ee, F, l, v);
}
function HSLtoRGB(a, u, c, l, v) {
  var p = a / 360, _ = u, k = c;
  if (_ === 0) {
    var O = k * 255;
    return new ColorHelper(RGB, O, O, O, l, v);
  }
  for (var D = k < 0.5 ? k * (1 + _) : k + _ - k * _, F = 2 * k - D, z = 0, j = 0, ee = 0, X = 0; X < 3; X++) {
    var ae = p + 0.3333333333333333 * -(X - 1);
    ae < 0 && ae++, ae > 1 && ae--;
    var O = void 0;
    6 * ae < 1 ? O = F + (D - F) * 6 * ae : 2 * ae < 1 ? O = D : 3 * ae < 2 ? O = F + (D - F) * (2 / 3 - ae) * 6 : O = F, O *= 255, X === 0 ? z = O : X === 1 ? j = O : ee = O;
  }
  return new ColorHelper(RGB, z, j, ee, l, v);
}
function clampColor(a, u) {
  var c = 0, l = maxChannelValues[a];
  return u < c ? c : u > l ? l : u;
}
function ensureColor(a) {
  return a instanceof ColorHelper ? a : color(a);
}
function parseHexCode(a) {
  var u = a.match(/#(([a-f0-9]{6})|([a-f0-9]{3}))$/i);
  if (u) {
    var c = u[1], l = parseInt(c.length === 3 ? c[0] + c[0] + c[1] + c[1] + c[2] + c[2] : c, 16), v = l >> 16 & 255, p = l >> 8 & 255, _ = l & 255;
    return new ColorHelper(RGB, v, p, _, 1, !1);
  }
}
function parseColorFunction(a) {
  var u = parseCSSFunction(a);
  if (!(!u || !(u.length === 4 || u.length === 5))) {
    var c = u[0], l = c === "rgba", v = c === "hsla", p = c === RGB, _ = c === HSL, k = v || l, O;
    if (p || l)
      O = RGB;
    else if (_ || v)
      O = HSL;
    else
      throw new Error("unsupported color string");
    var D = toFloat(u[1]), F = p || l ? toFloat(u[2]) : ensurePercent(u[2]), z = p || l ? toFloat(u[3]) : ensurePercent(u[3]), j = k ? toFloat(u[4]) : 1;
    return new ColorHelper(O, D, F, z, j, k);
  }
}
const of = color, transparent = color("rgba(0,0,0,0)"), white = color("#ffffff"), black = color("#000000"), weights = {
  primary: {
    50: "#EAFAF5",
    100: "#D5F6EB",
    200: "#ABEDD7",
    300: "#82E3C3",
    400: "#58DAAF",
    500: "#26AD80",
    600: "#25A77C",
    700: "#1C7D5D",
    800: "#12543E"
  },
  secondary: {
    50: "#FBEAEA",
    100: "#F7D4D4",
    200: "#EFA9A9",
    300: "#E77E7E",
    400: "#FF6F64",
    500: "#E9554A",
    600: "#CB362B",
    700: "#811818",
    800: "#561010"
  },
  neutral: {
    0: "#ffffff",
    10: "#f5f5f5",
    200: "#d9d9d9",
    300: "#bababa",
    350: "#999999",
    400: "#9e9e9e",
    500: "#808080",
    600: "#666666",
    700: "#4d4d4d",
    800: "#303030",
    900: "#141414",
    1e3: "#000000"
  },
  warning: {
    400: "#FFC28A",
    500: "#FFAE64",
    600: "#F29540"
  }
}, types = Object.keys(weights), weight = (a) => (u) => {
  const c = weights[a];
  if (c[u])
    return c[u];
  const l = Object.keys(weights.primary).map(Number), v = l.find((p) => u <= p);
  return v ? c[v] : c[l.slice(l.length - 1)[0]];
}, primary = weight("primary"), neutral = weight("neutral"), secondary = weight("secondary"), warning = weight("warning"), lightstream = color("#26ad80"), twitch = color("#9156ff"), linkedin = color("#2867b2"), youtube = color("#ff0000"), facebook = color("#1877f2"), twitter = color("#1da1f2"), Color = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  black,
  color,
  facebook,
  lightstream,
  linkedin,
  neutral,
  of,
  primary,
  secondary,
  transparent,
  twitch,
  twitter,
  types,
  warning,
  white,
  youtube
}, Symbol.toStringTag, { value: "Module" })), YouTube = /* @__PURE__ */ React.createElement("svg", {
  style: {
    flex: "0 0 100%"
  },
  viewBox: "0 0 24 24"
}, /* @__PURE__ */ React.createElement("path", {
  d: "M19.6465 8.53711C19.4707 7.83398 18.9141 7.27734 18.2402 7.10156C16.9805 6.75 12 6.75 12 6.75C12 6.75 6.99023 6.75 5.73047 7.10156C5.05664 7.27734 4.5 7.83398 4.32422 8.53711C3.97266 9.76758 3.97266 12.4043 3.97266 12.4043C3.97266 12.4043 3.97266 15.0117 4.32422 16.2715C4.5 16.9746 5.05664 17.502 5.73047 17.6777C6.99023 18 12 18 12 18C12 18 16.9805 18 18.2402 17.6777C18.9141 17.502 19.4707 16.9746 19.6465 16.2715C19.998 15.0117 19.998 12.4043 19.998 12.4043C19.998 12.4043 19.998 9.76758 19.6465 8.53711ZM10.3594 14.7773V10.0312L14.5195 12.4043L10.3594 14.7773Z"
})), YouTubeDuo = /* @__PURE__ */ React.createElement("svg", {
  style: {
    flex: "0 0 100%"
  },
  viewBox: "0 0 24 24"
}, /* @__PURE__ */ React.createElement("rect", {
  x: "8",
  y: "9",
  width: "9",
  height: "7",
  fill: neutral(0)
}), /* @__PURE__ */ React.createElement("path", {
  d: "M19.6465 8.53711C19.4707 7.83398 18.9141 7.27734 18.2402 7.10156C16.9805 6.75 12 6.75 12 6.75C12 6.75 6.99023 6.75 5.73047 7.10156C5.05664 7.27734 4.5 7.83398 4.32422 8.53711C3.97266 9.76758 3.97266 12.4043 3.97266 12.4043C3.97266 12.4043 3.97266 15.0117 4.32422 16.2715C4.5 16.9746 5.05664 17.502 5.73047 17.6777C6.99023 18 12 18 12 18C12 18 16.9805 18 18.2402 17.6777C18.9141 17.502 19.4707 16.9746 19.6465 16.2715C19.998 15.0117 19.998 12.4043 19.998 12.4043C19.998 12.4043 19.998 9.76758 19.6465 8.53711ZM10.3594 14.7773V10.0312L14.5195 12.4043L10.3594 14.7773Z"
})), Facebook = /* @__PURE__ */ React.createElement("svg", {
  style: {
    flex: "0 0 100%"
  },
  viewBox: "0 0 24 24"
}, /* @__PURE__ */ React.createElement("path", {
  d: "M15.4863 13.3125L15.8965 10.6172H13.2891V8.85938C13.2891 8.09766 13.6406 7.39453 14.8125 7.39453H16.0137V5.08008C16.0137 5.08008 14.9297 4.875 13.9043 4.875C11.7656 4.875 10.3594 6.19336 10.3594 8.53711V10.6172H7.95703V13.3125H10.3594V19.875H13.2891V13.3125H15.4863Z"
})), FacebookCircle = /* @__PURE__ */ React.createElement("svg", {
  style: {
    flex: "0 0 100%"
  },
  viewBox: "0 0 24 24"
}, /* @__PURE__ */ React.createElement("path", {
  d: "M19.2656 12.375C19.2656 8.36133 16.0137 5.10938 12 5.10938C7.98633 5.10938 4.73438 8.36133 4.73438 12.375C4.73438 16.0078 7.37109 19.0254 10.8574 19.5527V14.4844H9.01172V12.375H10.8574V10.793C10.8574 8.97656 11.9414 7.95117 13.582 7.95117C14.4023 7.95117 15.2227 8.09766 15.2227 8.09766V9.88477H14.3145C13.4062 9.88477 13.1133 10.4414 13.1133 11.0273V12.375H15.1348L14.8125 14.4844H13.1133V19.5527C16.5996 19.0254 19.2656 16.0078 19.2656 12.375Z"
})), Twitch = /* @__PURE__ */ React.createElement("svg", {
  style: {
    flex: "0 0 100%"
  },
  viewBox: "0 0 24 24"
}, /* @__PURE__ */ React.createElement("path", {
  d: "M16.9551 8.92188H15.8125V12.1445H16.9551V8.92188ZM13.8496 8.89258H12.707V12.1152H13.8496V8.89258ZM9.01562 5.875L6.20312 8.57031V18.209H9.60156V20.875L12.4141 18.209H14.6699L19.7676 13.375V5.875H9.01562ZM18.6543 12.8477L16.3691 14.9863H14.1133L12.1504 16.8613V14.9863H9.60156V6.95898H18.6543V12.8477Z"
})), TwitchDuo = /* @__PURE__ */ React.createElement("svg", {
  style: {
    flex: "0 0 100%"
  },
  viewBox: "0 0 24 24"
}, /* @__PURE__ */ React.createElement("path", {
  d: "M19 6.5H9L8.8125 17.5H13.5L19 13V6.5Z",
  fill: neutral(0)
}), /* @__PURE__ */ React.createElement("path", {
  d: "M16.9551 8.92188H15.8125V12.1445H16.9551V8.92188ZM13.8496 8.89258H12.707V12.1152H13.8496V8.89258ZM9.01562 5.875L6.20312 8.57031V18.209H9.60156V20.875L12.4141 18.209H14.6699L19.7676 13.375V5.875H9.01562ZM18.6543 12.8477L16.3691 14.9863H14.1133L12.1504 16.8613V14.9863H9.60156V6.95898H18.6543V12.8477Z"
})), Twitter = /* @__PURE__ */ React.createElement("svg", {
  style: {
    flex: "0 0 100%"
  },
  viewBox: "0 0 24 24"
}, /* @__PURE__ */ React.createElement("path", {
  d: "M20.6681 7.98749C20.6806 8.16248 20.6806 8.33751 20.6806 8.5125C20.6806 13.85 16.6197 20 9.1976 20C6.91098 20 4.78681 19.3375 3 18.1875C3.32489 18.225 3.63723 18.2375 3.97462 18.2375C5.86136 18.2375 7.59821 17.6 8.98518 16.5125C7.21086 16.475 5.72393 15.3125 5.21162 13.7125C5.46155 13.75 5.71143 13.775 5.97386 13.775C6.33621 13.775 6.69859 13.725 7.03594 13.6375C5.18666 13.2625 3.79966 11.6375 3.79966 9.67499V9.62501C4.33693 9.92501 4.96174 10.1125 5.62393 10.1375C4.53685 9.41247 3.82466 8.17498 3.82466 6.77497C3.82466 6.02499 4.02454 5.33749 4.37443 4.73748C6.36117 7.18748 9.34753 8.78745 12.6962 8.96248C12.6337 8.66248 12.5962 8.35001 12.5962 8.03751C12.5962 5.81248 14.3955 4 16.6322 4C17.7942 4 18.8438 4.4875 19.581 5.275C20.4931 5.10001 21.3678 4.76249 22.1425 4.3C21.8426 5.23752 21.2054 6.02502 20.3682 6.52499C21.1804 6.43753 21.9676 6.21248 22.6923 5.90001C22.1426 6.69998 21.4553 7.41245 20.6681 7.98749Z"
})), LinkedIn = /* @__PURE__ */ React.createElement("svg", {
  style: {
    flex: "0 0 100%"
  },
  viewBox: "0 0 24 24"
}, /* @__PURE__ */ React.createElement("path", {
  d: "M19.2 3H4.8C3.81 3 3.009 3.81 3.009 4.8L3 19.2C3 20.19 3.81 21 4.8 21H19.2C20.19 21 21 20.19 21 19.2V4.8C21 3.81 20.19 3 19.2 3ZM8.4 18.3H5.7V10.2H8.4V18.3ZM7.05 8.679C6.15 8.679 5.421 7.95 5.421 7.05C5.421 6.15 6.15 5.421 7.05 5.421C7.95 5.421 8.679 6.15 8.679 7.05C8.679 7.95 7.95 8.679 7.05 8.679ZM18.3 18.3H15.6V13.53C15.6 12.783 14.997 12.18 14.25 12.18C13.503 12.18 12.9 12.783 12.9 13.53V18.3H10.2V10.2H12.9V11.28C13.368 10.524 14.331 10.02 15.15 10.02C16.887 10.02 18.3 11.433 18.3 13.17V18.3Z"
})), Lightstream = /* @__PURE__ */ React.createElement("svg", {
  style: {
    flex: "0 0 100%"
  },
  viewBox: "0.144 0 27.712 24"
}, /* @__PURE__ */ React.createElement("path", {
  d: "M16.0369 12.1232L14 15.6518L11.5642 11.4335L6.27356 10.6176L14 24L20.4627 12.805L16.0369 12.1232Z"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M9.74033 8.27418L7.37317 4.17409H20.6268L19.0921 6.83194L24.3827 6.01602L27.8558 0H0.144165L5.31453 8.95665L9.74033 8.27418Z"
})), LightstreamWithText = /* @__PURE__ */ React.createElement("svg", {
  style: {
    flex: "0 0 100%"
  },
  viewBox: "0 0 3000 524"
}, /* @__PURE__ */ React.createElement("polygon", {
  points: "330.56 263.5 299.73 316.91 262.86 253.06 182.78 240.71 299.73 443.27 397.55 273.82 330.56 263.5"
}), /* @__PURE__ */ React.createElement("polygon", {
  points: "235.25 205.24 199.42 143.18 400.03 143.18 376.8 183.41 456.88 171.06 509.45 80 90 80 168.26 215.57 235.25 205.24"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M646.32,345.72h94.91v13.73H630V167.26h16.36Z"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M846.24,359.45H830V167.26h16.23Z"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M1091.16,336.61q-8.45,12-26.46,18.74t-40.33,6.73q-22.57,0-40.13-10.82t-27.19-30.62q-9.64-19.8-9.77-45.41V250.95q0-40,20.2-63.16t54.25-23.17q29.69,0,47.78,15.11T1091,221.38h-16.24q-3.56-21.18-17.23-32.11t-35.7-10.92q-26.92,0-42.64,19.15t-15.71,54v22.72q0,21.93,7.46,38.77t21.38,26.09q13.92,9.25,32,9.25,21,0,36-6.6,9.76-4.36,14.52-10.16V282h-51.61V268.24h67.85Z"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M1333.71,359.45h-16.37V278.11H1207.53v81.33h-16.23V167.26h16.23v97.12h109.81V167.26h16.37Z"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M1563.2,181h-65.87V359.45H1481.1V181h-65.73V167.26H1563.2Z"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M1990.75,181h-65.87V359.45h-16.23V181h-65.73V167.26h147.83Z"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M2147.65,279.33h-55.84v80.12h-16.36V167.26h62.43q30.75,0,48,14.9t17.29,41.66a52,52,0,0,1-10.83,32.56q-10.82,14.11-29,19.51l48,81.83v1.72h-17.29Zm-55.84-13.73h49.76q20.45,0,32.86-11.63t12.41-30.14q0-20.36-12.93-31.59T2137.61,181h-45.8Z"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M2407.62,278.11h-89.88v67.61h103.35v13.73H2301.5V167.26h118.92V181H2317.73v83.39h89.88Z"
}), /* @__PURE__ */ React.createElement("polygon", {
  points: "2892.79 183.67 2892.79 183.67 2816.23 326.97 2724.06 154.45 2724.06 189.54 2724.06 359.75 2739.67 359.75 2739.67 218.3 2816.26 359.42 2892.79 218.32 2892.79 359.75 2908.4 359.75 2908.4 189.54 2908.4 154.45 2892.79 183.67"
}), /* @__PURE__ */ React.createElement("polygon", {
  points: "2649.77 359.45 2569.47 154.54 2569.47 154.53 2569.46 154.53 2569.46 154.53 2569.46 154.54 2489.16 359.45 2506.19 359.45 2569.46 194.32 2632.74 359.45 2649.77 359.45"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M1764.57,287q-6.73-10.56-20.06-18.15a131.55,131.55,0,0,0-21.47-9.18l-7.64,13.49q19.65,6.61,28.32,13.77,11.22,9.3,11.22,25.28,0,16.37-13.6,26.26t-36,9.9c-11.35,0-21.05-1.94-29.35-5.51l-7,12.33a94,94,0,0,0,36.33,6.91q29.7,0,47.85-13.73t18.15-36.43Q1771.3,297.55,1764.57,287Z"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M1659.11,250.93c7.28,5.25,18,10.18,32.13,14.79l7.72-13.38q-21-6.41-31.29-14.49Q1655.95,228.61,1656,214q0-15.83,13-25.66t35-9.83c13.12,0,23.78,3.19,32.26,9.21l7.23-12.51c-1.71-1-3.43-2.1-5.3-3q-15.09-7.38-34.18-7.38-28.19,0-46.31,13.76t-18.11,35.77Q1639.62,237,1659.11,250.93Z"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M1744.34,268.78a129.23,129.23,0,0,0-21.68-9.32l-7.79,13.49c13.28,4.44,22.87,9.06,28.68,13.88q11.2,9.29,11.2,25.23,0,16.33-13.57,26.21t-36,9.88c-11.8,0-21.85-2-30.34-5.91l-7.08,12.26.2.1a93.63,93.63,0,0,0,37.22,7.25q29.64,0,47.75-13.7t18.11-36.36q0-14.36-6.72-24.9T1744.34,268.78Z"
})), IconMap = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Facebook,
  FacebookCircle,
  Lightstream,
  LightstreamWithText,
  LinkedIn,
  Twitch,
  TwitchDuo,
  Twitter,
  YouTube,
  YouTubeDuo
}, Symbol.toStringTag, { value: "Module" })), nudge = (a) => {
  if (a.nudgeUp || a.nudgeDown || a.nudgeRight || a.nudgeLeft)
    return {
      position: "relative",
      top: a.nudgeDown,
      left: a.nudgeRight,
      right: a.nudgeLeft,
      bottom: a.nudgeUp
    };
}, SVGWrapper = ({
  children: a,
  width: u,
  height: c,
  color: l,
  colorWeight: v = 0,
  marginLeft: p,
  marginTop: _,
  marginRight: k,
  marginBottom: O,
  className: D,
  ...F
}) => (l && Color[l](v), /* @__PURE__ */ React.createElement("div", {
  className: D,
  style: {
    ...nudge(F),
    display: "flex",
    justifyContent: "center",
    flexBasis: u || "auto",
    flexShrink: 0,
    width: u,
    height: c || u && "fit-content",
    marginLeft: p,
    marginTop: _,
    marginBottom: O,
    marginRight: k
  }
}, a)), Icon = ({
  name: a,
  ...u
}) => /* @__PURE__ */ React.createElement(SVGWrapper, {
  ...u
}, IconMap[a]), Icon$1 = Icon, dragImageSvg = `
  <svg height="75" width="120" viewBox="0 0 120 75" xmlns="http://www.w3.org/2000/svg" style="">
    <rect width="120" height="75" rx="3" style="
      opacity: 0.4;
      stroke: white;
      stroke-width: 3px;
      stroke-opacity: 0.7;
    "/>
  </svg>`;
let dragImage;
const loadDragImage = () => dragImage || (dragImage = new Image(), dragImage.src = URL.createObjectURL(new Blob([dragImageSvg], {
  type: "image/svg+xml"
})), dragImage);
class ErrorBoundary extends React.Component {
  constructor(u) {
    super(u), this.state = {
      error: null
    };
  }
  componentDidCatch(u, c) {
    log.warn(u, c);
  }
  static getDerivedStateFromError() {
    return {
      error: !0
    };
  }
  render() {
    return this.state.error ? null : this.props.children;
  }
}
const onDrop = async (a, u) => {
  u.preventDefault(), u.stopPropagation();
  const {
    dropNodeId: c,
    dropType: l,
    project: v
  } = a, p = u.dataTransfer.getData("text/plain");
  if (log.debug("Compositor: Dropping", {
    dropType: l,
    dragNodeId: p,
    dropNodeId: c
  }), c === p)
    return;
  const [_, k, O, D] = await Promise.all([v.compositor.get(p), v.compositor.get(c), v.compositor.getParent(p), v.compositor.getParent(c)]);
  if (l === "layout")
    return O.id === c ? void 0 : CoreContext.Command.moveNode({
      projectId: v.id,
      nodeId: _.id,
      parentId: k.id
    });
  if (O.id !== (D == null ? void 0 : D.id))
    return;
  const F = O.children.map((z) => z.id);
  return CoreContext.Command.reorderNodes({
    projectId: v.id,
    parentId: O.id,
    childIds: swapItems(_.id, k.id, F)
  });
}, ElementTree = (a) => {
  var U, Y;
  const u = useRef(!1), c = useRef(), l = useRef(), v = useRef(), [p, _] = useState(), {
    projectId: k,
    interactive: O,
    draggingNodeId: D,
    onElementDoubleClick: F,
    checkDragTarget: z,
    checkDropTarget: j,
    getNodePresetsOverlay: ee,
    onPresetPreview: X,
    onPresetSelect: ae,
    setDraggingNodeId: Q
  } = useContext(CompositorContext), {
    nodeId: ne
  } = a, Z = getProject(k), de = Z.compositor.get(ne), fe = CoreContext.compositor.getElement(de), [Te, Re] = useState({}), Le = {
    ...de.props,
    ...Te
  }, be = Le.layout || "Row", q = (O && (z == null ? void 0 : z(de))) ?? !1, J = (O && (j == null ? void 0 : j(de))) ?? !1, C = ee == null ? void 0 : ee(de, Z.props);
  let S = de.children.some((L) => L.id === D), E = J ? {
    onDrop: (L) => onDrop({
      dropType: "layout",
      dropNodeId: de.id,
      project: Z
    }, L),
    onDragEnter: (L) => {
      var T;
      L.preventDefault(), L.stopPropagation(), (T = v.current) == null || T.toggleAttribute("data-layout-drop-target-active", !0);
    },
    onDragLeave: (L) => {
      var T;
      L.preventDefault(), L.stopPropagation(), (T = v.current) == null || T.toggleAttribute("data-layout-drop-target-active", !1);
    }
  } : {}, I = q ? {
    draggable: !0,
    // If a target is draggable, it will also be treated as
    //  a drop target (swap element positions)
    ondrop: (L) => onDrop(
      {
        dropType: "transform",
        dropNodeId: de.id,
        project: Z
      },
      // @ts-ignore TODO: Convert all to native drag events
      L
    ),
    ondragstart: (L) => {
      var T;
      u.current = !0, wrapperEl.toggleAttribute("data-dragging", !0), Q(de.id), log.debug("Compositor: Dragging", de.id), L.dataTransfer.setData("text/plain", de.id), L.dataTransfer.dropEffect = "move", L.dataTransfer.setDragImage(dragImage, 10, 10), (T = v.current) == null || T.toggleAttribute("data-drag-target-active", !0);
    },
    ondragend: (L) => {
      var T;
      u.current = !1, Q(null), wrapperEl.toggleAttribute("data-dragging", !1), log.debug("Compositor: DragEnd", L), (T = v.current) == null || T.toggleAttribute("data-drag-target-active", !1), wrapperEl.toggleAttribute("data-drop-target-ready", !1), wrapperEl.querySelectorAll("[data-item]").forEach((B) => {
        B.toggleAttribute("data-drag-target-active", !1), B.toggleAttribute("data-layout-drop-target-active", !1), B.toggleAttribute("data-transform-drop-target-active", !1), B.toggleAttribute("data-transform-drop-self-active", !1);
      });
    },
    ondragenter: (L) => {
      var T, B;
      L.preventDefault(), L.stopPropagation(), u.current ? (T = v.current) == null || T.toggleAttribute("data-transform-drop-self-active", !0) : (B = v.current) == null || B.toggleAttribute("data-transform-drop-target-active", !0), setTimeout(() => {
        u.current || wrapperEl.toggleAttribute("data-drop-target-ready", !0);
      });
    },
    ondragleave: (L) => {
      var T, B;
      L.preventDefault(), L.stopPropagation(), (T = v.current) == null || T.toggleAttribute("data-transform-drop-self-active", !1), (B = v.current) == null || B.toggleAttribute("data-transform-drop-target-active", !1), wrapperEl.toggleAttribute("data-drop-target-ready", !1);
    }
  } : {};
  useEffect(() => {
    l.current && fe && (l.current.appendChild(fe.root), Object.assign(l.current.style, {
      width: "100%",
      height: "100%",
      position: "relative",
      overflow: "hidden"
    }), Object.assign(fe.root.style, {
      pointerEvents: q ? "all" : "none",
      width: "100%",
      height: "100%",
      position: "relative",
      ...Le.style || {}
    }));
  }, [l.current, fe]), useEffect(() => {
    const L = q ? () => F == null ? void 0 : F(de) : () => {
    };
    return c.current && (Object.assign(c.current, I), Object.assign(c.current.style, {
      pointerEvents: q ? "all" : "none"
    }), c.current.addEventListener("dblclick", L)), () => {
      var T;
      (T = c.current) == null || T.removeEventListener("dblclick", L);
    };
  }, [c.current]);
  const M = {
    layout: be,
    ...Le.layoutProps ?? {}
  }, $ = useMemo(() => (L) => {
    L.toggleAttribute("data-preset-drag-target-active", !1), window.clearTimeout(p), Re({}), _(void 0);
  }, [p, Re]);
  return de ? /* @__PURE__ */ React.createElement("div", {
    ref: v,
    "data-id": de.id + "-x",
    "data-source-type": de.props.sourceType,
    "data-item": !0,
    ...q && {
      "data-drag-target": !0
    },
    ...J && {
      "data-drop-target": !0
    },
    ...E,
    style: {
      position: "relative",
      width: ((U = Le.size) == null ? void 0 : U.x) || "100%",
      height: ((Y = Le.size) == null ? void 0 : Y.y) || "100%",
      pointerEvents: "none"
    }
  }, /* @__PURE__ */ React.createElement("div", {
    className: "layout-preset-zones",
    style: {
      height: "100%",
      width: "100%",
      position: "absolute",
      zIndex: 4,
      pointerEvents: "none",
      transition: "opacity 300ms ease"
    }
  }, C == null ? void 0 : C.map(({
    name: L,
    position: T,
    layout: B
  }) => /* @__PURE__ */ React.createElement("div", {
    key: L,
    className: `layout-preset-zone ${B}`,
    "data-drag-target": !0,
    style: {
      position: "absolute",
      pointerEvents: S ? "all" : "none",
      opacity: S ? 1 : 0,
      transition: S ? "opacity 500ms ease 200ms, background-color 100ms ease" : "",
      ...T
    },
    onDragEnter: (te) => {
      te.currentTarget.toggleAttribute("data-preset-drag-target-active", !0);
      const pe = window.setTimeout(() => {
        X == null || X({
          node: de,
          preset: L,
          setLocalState: Re
        });
      }, 250);
      _(pe), te.stopPropagation();
    },
    onDragLeave: (te) => {
      $(te.currentTarget), te.stopPropagation();
    },
    onDrop: (te) => {
      $(te.currentTarget), ae == null || ae({
        node: de,
        preset: L
      });
    }
  }))), /* @__PURE__ */ React.createElement("div", {
    className: "interactive-overlay",
    ref: c,
    style: {
      height: "100%",
      width: "100%",
      position: "absolute",
      zIndex: 2
    }
  }), /* @__PURE__ */ React.createElement("div", {
    className: "item-element",
    style: {
      display: "flex",
      flex: "0 0 auto",
      justifyContent: "center",
      width: "100%",
      height: "100%"
    }
  }, /* @__PURE__ */ React.createElement("div", {
    ref: l
  }), /* @__PURE__ */ React.createElement(ErrorBoundary, null, /* @__PURE__ */ React.createElement("ls-layout", {
    "data-id": de.id + "-x",
    props: JSON.stringify(M),
    layout: be
  }, de.children.map((L) => /* @__PURE__ */ React.createElement(ElementTree, {
    key: L.id,
    nodeId: L.id
  })))))) : null;
}, Root = (a) => {
  const [u, c] = useState(null), {
    projectId: l
  } = useContext(CompositorContext), v = getProject(l);
  return useEffect(() => (c(v.compositor.renderTree()), CoreContext.onInternal("NodeChanged", () => {
    c(v.compositor.renderTree());
  })), []), useEffect(() => {
    const p = v.compositor.getRoot(), {
      x: _
    } = p.props.size, k = () => {
      var X, ae, Q;
      const {
        bannerStyle: O = "default",
        primaryColor: D = "#ABABAB",
        showNameBanners: F
      } = v.props ?? {}, z = ((X = v.props) == null ? void 0 : X.logoPosition) ?? ((Q = (ae = v.props) == null ? void 0 : ae.logo) == null ? void 0 : Q.logoPosition) ?? "top-right";
      if (!O || !D || !z)
        return;
      const j = themes[O](D, F, _ / 1920), ee = themes[z](_ / 1920);
      a.setStyle(`${j} ${ee}` || "");
    };
    return k(), CoreContext.onInternal("ProjectChanged", k);
  }, [v]), u ? /* @__PURE__ */ React.createElement("div", {
    onDrop: (p) => {
      p.preventDefault();
    },
    onDragOver: (p) => {
      p.preventDefault();
    },
    onDragLeave: (p) => {
      p.preventDefault();
    },
    style: {
      userSelect: "none",
      width: `${u.props.size.x + PADDING * 2}px`,
      height: `${u.props.size.y + PADDING * 2}px`,
      margin: PADDING + "px"
    }
  }, /* @__PURE__ */ React.createElement("div", {
    style: {
      width: "100%",
      height: "100%",
      overflow: "hidden"
    }
  }, /* @__PURE__ */ React.createElement(ElementTree, {
    nodeId: u.id
  }))) : null;
};
let wrapperEl, customStyleEl;
const PADDING = 0, render = (a) => {
  const {
    containerEl: u,
    projectId: c,
    interactive: l = !1,
    checkDragTarget: v = scenelessProjectDragCheck,
    checkDropTarget: p = scenelessProjectDropCheck
  } = a, _ = getProject(c);
  if (CoreContext.clients.LayoutApi().subscribeToLayout(_.layoutApi.layoutId), loadDragImage(), !u || !_)
    return;
  if (!u.shadowRoot) {
    u.attachShadow({
      mode: "open"
    }), customStyleEl = document.createElement("style");
    const ee = document.createElement("style");
    ee.textContent = getStyle(), wrapperEl = document.createElement("div"), wrapperEl.id = "compositor-root", Object.assign(wrapperEl.style, {
      width: "100%",
      height: "100%",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      transformOrigin: "center"
    }), u.shadowRoot.appendChild(ee), u.shadowRoot.appendChild(customStyleEl), u.shadowRoot.appendChild(wrapperEl), new ResizeObserver((ae) => {
      F();
    }).observe(u);
  }
  const k = _.compositor.getRoot(), {
    x: O,
    y: D
  } = k.props.size, F = () => {
    let {
      width: ee,
      height: X
    } = u.getBoundingClientRect();
    const ae = ee / X, Q = O / D;
    let ne;
    ee && X ? Q > ae ? ne = ee / (O + PADDING * 2) : ne = X / (D + PADDING * 2) : ne = 1, wrapperEl.style.willChange = "transform", wrapperEl.style.transform = `scale(${ne}) translateZ(0)`, window.__scale = ne, j();
  }, z = createRoot(wrapperEl), j = () => {
    z.render(/* @__PURE__ */ React.createElement(CompositorProvider, {
      interactive: l,
      checkDragTarget: v,
      checkDropTarget: p,
      ...a
    }, /* @__PURE__ */ React.createElement(Root, {
      setStyle: (ee) => {
        customStyleEl.textContent = ee;
      }
    })));
  };
  F();
}, scenelessProjectDragCheck = (a) => a.props.name === "Participant" || a.props.sourceType === "RoomParticipant" || a.props.sourceType === "RTMP" || a.props.sourceType === "Game", scenelessProjectDropCheck = (a) => a.props.name === "Content", CompositorContext = React.createContext(null), CompositorProvider = ({
  children: a,
  ...u
}) => {
  const [c, l] = useState(null);
  return /* @__PURE__ */ React.createElement(CompositorContext.Provider, {
    value: {
      ...u,
      draggingNodeId: c,
      setDraggingNodeId: l
    }
  }, a);
}, getStyle = () => `
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  font-family: 'Arial';
}

video {
  width: 100%;
  height: 100%;
  object-fit: contain;
}

.NameBanner {
  top: 100%;
  transform: translateY(-100%);
  left: 0;
  height: 30px;
  background: linear-gradient(90deg, rgba(0, 0, 0, 0.5) 50%, rgba(0, 0, 0, 0) 100%);
  padding: 0px 0px 0px 10px;
  color: rgba(255, 255, 255, 0.9);
  font-weight: bold;
  line-height: 30px;
  width: 100%;
  font-size: 28px;
  position: absolute;
}

.item-element {
  transition: opacity 150ms ease;
}

.interactive-overlay .interactive-overlay-hover {
  opacity: 0;
  pointer-events: none;
}

.interactive-overlay:hover .interactive-overlay-hover {
  opacity: 1;
  pointer-events: all;
}

.layout-preset-zone {
  background-color: rgba(0,0,0,0.6);
  outline: 2px solid rgba(255,255,255,0.3);
}

.layout-preset-zone[data-preset-drag-target-active] {
  background-color: rgba(255,255,255,0.3);
}

.layout-preset-zone.Alert[data-preset-drag-target-active] {
  background: rgba(88, 218, 175, 0.75) !important;
}

ls-layout[layout="Presentation"][props*="\\"cover\\"\\:true"] > :first-child .NameBanner {
  top: 0% !important;
  transform: translateY(0%) !important;
}

[layout="Layered"] > [data-item] {
  transform: scale(1.003) !important;
}
[layout="Layered"] > [data-item]:nth-child(2) {
  transform: scale(1.0015) !important;
}
[layout="Layered"] > [data-item]:nth-child(1) {
  transform: scale(1) !important;
}

.logo {
  position: absolute !important;
}

#compositor-root[data-dragging] * {
  cursor: grabbing !important;
}

[data-drag-target] {}
[data-drag-target]:hover:not([data-drag-target-active]) > .interactive-overlay {
  box-shadow: 0 0 0 3px inset rgba(255, 255, 255, 0.5);
  cursor: grab;
}
[data-drop-target] {}
[data-drop-target]:hover {}
[data-drag-target][data-drag-target-active] > .interactive-overlay {
  border: 3px solid #ffff007d;
}
[data-drag-target][data-drag-target-active]:not([data-transform-drop-self-active]) > .interactive-overlay {
  border: 3px dashed #ffff007d;
}
#compositor-root[data-drop-target-ready] [data-drag-target][data-drag-target-active] > .item-element {
  opacity: 0.6;
}
[data-layout-drop-target-active] > .interactive-overlay {
  box-shadow: 0 0 0 3px inset yellow;
}
[data-transform-drop-target-active] > .interactive-overlay {
  box-shadow: 0 0 0 3px inset white;
}
`;
var BannerStyle = /* @__PURE__ */ ((a) => (a.DEFAULT = "default", a.MINIMAL = "minimal", a.BUBBLE = "bubble", a))(BannerStyle || {});
const themes = {
  "top-left": (a = 1280 / 1920) => `
      .wrapper {
       top:0;
       left:0;
    }`,
  "top-right": (a = 1280 / 1920) => `
      .wrapper {
       top:0;
       right:0;
    }`,
  "bottom-left": (a = 1280 / 1920) => `
      .wrapper {
       bottom:0;
       left:0;
    }`,
  "bottom-right": (a = 1280 / 1920) => `
      .wrapper {
       bottom:0;
       right:0;
    }`,
  default: (a = "#ABABAB", u = !0, c = 1280 / 1920) => {
    const l = color(a).lightness() < 0.6 ? "#FFF" : "#000", v = color(a).lightness() < 0.6 ? "#FFF" : "#000", p = color(a).lightness() < 0.6 ? "#000" : "#FFF", _ = (k) => k * c + "px";
    return `
      .ChatOverlay {
        background: ${a} !important;
        margin-bottom: ${_(40)} !important;
        transition: 300ms ease all;
        left: 0;

        /* Default Size 4 */
        font-size: ${_(44)} !important;
        padding: ${_(40)} ${_(100)} !important;
        border-radius: ${_(20)} !important;
      }
      
      .ChatOverlay-badge-icon {
          width:${_(32)};
          height: ${_(32)};
          fill: currentcolor;
          color: ${p};
      }

       .ChatOverlay-badge-container {
          background-color:${v};
          display:flex;
          flex-direction:row;
          padding: ${_(6)} ${_(12)} ${_(6)} ${_(6)};
          border-radius: ${_(10)};
          align-items: center;
          border-bottom-left-radius: 0px !important;
          position: relative;
          border: none;
          cursor: pointer;
       }
      
       .ChatOverlay-badge-username {
          color:${p};
          padding:${_(6)};
          font-size:${_(18)};
          font-weight:700;
          text-transform: capitalize; 
       }
       
       .ChatOverlay-badge-container::before {
          content:"";
          width:15px;
          height:15px;
          background-color:${v};
          position: absolute;
          bottom:-14px;
          left:0;
          clip-path:polygon(0 100%, 12% 87%, 26% 73%, 45% 53%, 59% 40%, 71% 28%, 85% 14%, 100% 0, 0 0);
        }
       

       .ChatOverlay-avatar {
          height: ${_(120)};
          width: ${_(120)};
          left:0;
          right:0;
          top:0;
          bottom:0;
          border-radius:50%;
       }

      .Banner, .NameBanner, .ChatOverlay {
        background: ${a} !important;
        margin-bottom: ${_(40)} !important;
        transition: 300ms ease all;
        left: 0;

        /* Default Size 4 */
        font-size: ${_(44)} !important;
        padding: ${_(40)} ${_(100)} !important;
        border-top-right-radius: ${_(20)} !important;
        border-bottom-right-radius: ${_(20)} !important;
      }

      .Banner-body, .NameBanner-body, .ChatOverlay-body {
        color: ${l} !important;
        font-family: 'Roboto' !important;
        font-style: normal !important;
        font-weight: 700 !important;
        line-height: 120% !important;
      }

      .NameBanner {
        transform-origin: 0 100%;
        margin: 0 !important;
        transform: translateX(-100%);
        opacity: 0 !important;
        white-space: nowrap;
        ${u && `
          opacity: 1 !important;
          transform: translateX(0);
        `}
      }

      .NameBanner[data-size="4"] {
        padding: ${_(40)} ${_(100)} !important;
        font-size: ${_(44)} !important;
        border-top-right-radius: ${_(20)} !important;
        border-bottom-right-radius: ${_(20)} !important;
      }
      .NameBanner[data-size="3"] {
        padding: ${_(12)} ${_(30)} !important;
        font-size: ${_(44)} !important;
        border-top-right-radius: ${_(20)} !important;
        border-bottom-right-radius: ${_(20)} !important;
      }
      .NameBanner[data-size="2"] {
        padding: ${_(12)} ${_(20)} !important;
        font-size: ${_(28)} !important;
        border-top-right-radius: ${_(16)} !important;
        border-bottom-right-radius: ${_(16)} !important;
      }
      .NameBanner[data-size="1"], .NameBanner[data-size="0"] {
        padding: ${_(8)} ${_(8)} !important;
        font-size: ${_(20)} !important;
        border-top-right-radius: ${_(8)} !important;
        border-bottom-right-radius: ${_(8)} !important;
      }
      .NameBanner[data-size="0"] {
        opacity: 0;
        transform: translateX(-100%);
      }
    `;
  },
  minimal: (a = "#ABABAB", u = !0, c = 1280 / 1920) => {
    const l = "white", v = "#fff", p = "#000", _ = (k) => k * c + "px";
    return `

      .ChatOverlay-badge-icon {
          width:${_(32)};
          height: ${_(32)};
          fill: currentcolor;
          color: ${p};
      }

       .ChatOverlay-badge-container {
          background-color:${v};
          display:flex;
          flex-direction:row;
          padding: ${_(6)} ${_(12)} ${_(6)} ${_(6)};
          align-items: center;
          position: relative;
          border: none;
          cursor: pointer;
       }

       .ChatOverlay-badge-username {
          color:${p};
          padding:${_(6)};
          font-size:${_(18)};
          font-weight:700;
          text-transform: capitalize; 
       }

       .ChatOverlay-avatar {
          height: ${_(120)};
          width: ${_(120)};
          left:0;
          right:0;
          top:0;
          bottom:0;
          border-radius:50%;
       }


    .Banner, .NameBanner, .ChatOverlay {
        background: ${color(a).fade(color(a).alpha() * 0.7).toString()} !important;
        padding: ${_(40)} ${_(40)} ${_(40)} ${_(60)} !important;
        position: relative !important;
        margin-bottom: ${_(40)} !important;
        transition: 300ms ease all;
        font-size: ${_(34)} !important;
        left: 0;
      }

      .Banner:before, .NameBanner:before, .ChatOverlay:before {
        z-index: 1;
        content: "";
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.6);
        transition: 300ms ease all;
        opacity: ${color(a).alpha()};
      }
      .Banner:after, .NameBanner:after, .ChatOverlay:after {
        z-index: 1;
        content: "";
        position: absolute;
        left: 0;
        top: 0;
        height: 100%;
        transition: 300ms ease all;
        width: ${_(20)};
        background: ${color(a)};
        opacity: ${color(a).alpha()};
      }
      .Banner-body, .NameBanner-body, .ChatOverlay-body {
        color: ${l} !important;
        font-family: 'Roboto' !important;
        font-style: normal !important;
        font-weight: 700 !important;
        line-height: 120% !important;
        position: relative;
        z-index: 2;
      }
      .Banner-header {
        font-size: ${_(90)};
        position: relative;
        z-index: 2;
      }
      .NameBanner {
        transform-origin: 0 100%;
        margin: 0 !important;
        transform: translateX(-100%);
        opacity: 0 !important;
        white-space: nowrap;
        ${u && `
          opacity: 1 !important;
          transform: translateX(0);
        `}
      }

      .NameBanner[data-size="4"] {
        padding: ${_(40)} ${_(40)} ${_(40)} ${_(60)} !important;
        font-size: ${_(34)} !important;
      }
      .NameBanner[data-size="3"] {
        padding: ${_(16)} ${_(40)} ${_(16)} ${_(60)} !important;
        font-size: ${_(34)} !important;
      }
      .NameBanner[data-size="2"] {
        padding: ${_(12)} ${_(24)} ${_(12)} ${_(44)} !important;
        font-size: ${_(24)} !important;
      }
      .NameBanner[data-size="1"], .NameBanner[data-size="0"] {
        padding: ${_(12)} ${_(16)} ${_(12)} ${_(36)} !important;
        font-size: ${_(18)} !important;
      }
      .NameBanner[data-size="0"] {
        opacity: 0 !important;
        transform: translateX(-100%);
      }
    `;
  },
  bubble: (a = "#ABABAB", u = !0, c = 1280 / 1920) => {
    const l = color(a).lightness() < 0.6 ? "#FFF" : "#000", v = color(a).lightness() < 0.6 ? "#FFF" : "#000", p = color(a).lightness() < 0.6 ? "#000" : "#FFF", _ = (k) => k * c + "px";
    return `
      .ChatOverlay-badge-icon {
          width:${_(32)};
          height: ${_(32)};
          fill: currentcolor;
          color: ${p};
      }


       .ChatOverlay-badge-container {
          background-color:${v};
          display:flex;
          flex-direction:row;
          padding: ${_(6)} ${_(12)} ${_(6)} ${_(6)};
          align-items: center;
          z-index: 1;
          border: none;
          cursor: pointer;
          top: 0;
          margin-bottom: 2px;
          margin-left: -${_(30)};
          border-radius: 30px;
       }

       .ChatOverlay-badge-username {
          color:${p};
          padding:${_(6)};
          font-size:${_(18)};
          font-weight:700;
          text-transform: capitalize; 
       }

       .ChatOverlayAvatar-container {
          height: ${_(120)};
          width: ${_(120)};
          top: 0;
       }
       .ChatOverlay-avatar {
          height: ${_(120)};
          width: ${_(120)};
          left:0;
          right:0;
          top:0;
          bottom:0;
          border-radius:50%;
       }


      .Banner, .ChatOverlay {
        transform: translateX(-50%);
        left: 50%;
        margin-bottom: ${_(40)} !important;
      }

      .Banner, .NameBanner, .ChatOverlay {
        background: ${color(a)} !important;
        color: ${l} !important;
        border-radius: 500px !important;
        transition: 300ms ease all;

        /* Default Style */
        border: 4px solid ${l} !important;
        padding: ${_(40)} ${_(80)} !important;
        font-size: ${_(40)} !important;
      }
      .Banner-body, .NameBanner-body, .ChatOverlay-body {
        color: ${l} !important;
        text-align: center !important;
        font-family: 'Roboto' !important;
        font-style: normal !important;
        font-weight: 700 !important;
        line-height: 120% !important;
      }
      .NameBanner {
        transform-origin: 0% 100%;
        transform: translateX(-100%);
        opacity: 0 !important;
        white-space: nowrap;
        ${u && `
          opacity: 1 !important;
          transform: translateX(0);
        `}
      }

      ls-layout[layout="Presentation"][props*="\\"cover\\"\\:true"] > :first-child .NameBanner {
        top: 0% !important;
        transform: translateY(0%) !important;
        margin: ${_(20)} ${_(20)};
      }


      .NameBanner[data-size="4"] {
        padding: ${_(40)} ${_(80)} ${_(40)} ${_(80)} !important;
        font-size: ${_(40)} !important;
      }
      .NameBanner[data-size="3"] {
        padding: ${_(12)} ${_(30)} ${_(12)} ${_(30)} !important;
        font-size: ${_(40)} !important;
        margin: -${_(20)} ${_(20)};
      }
      .NameBanner[data-size="2"] {
        padding: ${_(12)} ${_(30)} ${_(12)} ${_(30)} !important;
        font-size: ${_(26)} !important;
        margin: -${_(8)} ${_(8)};
      }
      .NameBanner[data-size="1"], .NameBanner[data-size="0"] {
        padding: ${_(8)} ${_(16)} ${_(8)} ${_(16)} !important;
        font-size: ${_(18)} !important;
        border-width: ${_(2)} !important;
        margin: -${_(16)} ${_(8)};
      }
      .NameBanner[data-size="0"] {
        opacity: 0 !important;
        transform: translateX(-100%);
      }
    `;
  }
}, iconStyles = {
  twitch: {
    icon: "Twitch"
  },
  youtube: {
    icon: "YouTube"
  },
  facebook: {
    icon: "Facebook"
  }
}, fixLink = (a) => !a.startsWith("http:") && !a.startsWith("https:") ? `https://${a}` : a, ChatOverlay = {
  name: "LS-ChatOverlay",
  sourceType: "ChatOverlay",
  create({
    onUpdate: a,
    onEvent: u
  }, c) {
    const l = document.createElement("div"), v = getProject(CoreContext.state.activeProjectId), p = v.compositor.getRoot(), {
      x: _
    } = p.props.size, k = (_ ?? 1280) / 1920, O = (Q) => Q * k + "px";
    let D;
    const F = (Q, ne) => {
      const Z = Q.width / ne.width;
      return Q.height / ne.height >= 0.25 && Z >= 0.75 ? 4 : Z >= 0.75 ? 1 : Z >= 0.5 ? -2 : Z > 0.25 ? -3 : -4;
    };
    CoreContext.onInternal("ProjectChanged", () => {
      const {
        bannerStyle: Q
      } = v.props ?? {};
      Q && ae({
        ...D,
        metadata: {
          ...D.metadata,
          bannerStyle: Q
        }
      });
    });
    const z = React.memo((Q) => {
      var ne, Z, de;
      return (Q == null ? void 0 : Q.type) === "emoticon" && ((ne = Q == null ? void 0 : Q.data) == null ? void 0 : ne.type) === "direct" ? /* @__PURE__ */ React.createElement("img", {
        src: (Z = Q == null ? void 0 : Q.data) == null ? void 0 : Z.url,
        style: {
          height: O(36)
        },
        alt: Q == null ? void 0 : Q.text
      }) : (Q == null ? void 0 : Q.type) === "link" ? /* @__PURE__ */ React.createElement("a", {
        style: {
          color: "#FFF",
          wordBreak: "break-all"
        },
        target: "_blank",
        rel: "noreferrer",
        href: fixLink((de = Q == null ? void 0 : Q.data) == null ? void 0 : de.url)
      }, Q == null ? void 0 : Q.text) : /* @__PURE__ */ React.createElement("span", null, Q == null ? void 0 : Q.text);
    }), j = (Q) => {
      const ne = {
        height: `${Q.height}`,
        width: `${Q.width}`,
        background: Q.background || "transparent",
        display: "inline-block",
        verticalAlign: "middle",
        borderRadius: "50%",
        fontSize: `${Q.fontSize}`
      };
      return /* @__PURE__ */ React.createElement("div", {
        style: {
          ...ne,
          position: "relative",
          marginRight: Q == null ? void 0 : Q.marginRight
        }
      }, /* @__PURE__ */ React.createElement("div", {
        style: {
          left: "50%",
          position: "absolute",
          top: "50%",
          transform: "translate(-50%, -50%)"
        }
      }, Q.username.substring(0, 2).toUpperCase()));
    }, ee = (Q) => {
      const {
        message: ne,
        id: Z,
        username: de,
        metadata: fe
      } = Q || {}, [Te, Re] = useState(0), {
        index: Le,
        platform: be,
        avatar: q,
        bannerStyle: J
      } = fe || {}, C = useMemo(() => iconStyles[be], [be]), S = useRef();
      return useLayoutEffect(() => {
        if (!S.current)
          return;
        const E = () => {
          const M = S.current;
          M && Re(F({
            width: M.clientWidth,
            height: M.clientHeight
          }, {
            width: v.compositor.getRoot().props.size.x,
            height: v.compositor.getRoot().props.size.y
          }));
        }, I = new ResizeObserver((M) => {
          E();
        });
        return E(), I.observe(S.current), () => {
          S != null && S.current && I.unobserve(S == null ? void 0 : S.current);
        };
      }, [S.current, v]), /* @__PURE__ */ React.createElement(APIKitAnimation$1, {
        id: `${Z}_${Le}`,
        type: "chatoverlay",
        enter: APIKitAnimationTypes.SLIDE_IN_LEFT,
        exit: APIKitAnimationTypes.SLIDE_OUT_LEFT,
        duration: 200
      }, /* @__PURE__ */ React.createElement("div", {
        className: "ChatOverlayContainer",
        style: {
          position: "absolute",
          top: 0,
          left: 0,
          width: "100%",
          height: "100%",
          display: "flex",
          flexDirection: "row",
          justifyContent: "flex-start",
          alignItems: "flex-end",
          marginLeft: J !== BannerStyle.BUBBLE ? "5%" : "0px"
        }
      }, J !== BannerStyle.BUBBLE ? (
        /* It's a ternary operator. If the style is not equal to BannerStyle.BUBBLE.toString(), then it will
        render the first div. Otherwise, it will render the second div. */
        /* @__PURE__ */ React.createElement("div", {
          style: {
            width: "100%",
            display: "flex"
          }
        }, q ? /* @__PURE__ */ React.createElement("span", {
          style: {
            marginRight: "20px"
          }
        }, /* @__PURE__ */ React.createElement("img", {
          src: q,
          className: "ChatOverlay-avatar"
        })) : /* @__PURE__ */ React.createElement(j, {
          height: O(110),
          width: O(120),
          background: primary(500),
          username: de,
          marginRight: 20,
          fontSize: O(30)
        }), /* @__PURE__ */ React.createElement("div", {
          style: {
            width: "100%"
          }
        }, de && /* @__PURE__ */ React.createElement("button", {
          className: "ChatOverlay-badge-container"
        }, (C == null ? void 0 : C.icon) && /* @__PURE__ */ React.createElement(Icon$1, {
          className: "ChatOverlay-badge-icon",
          name: C == null ? void 0 : C.icon
        }), /* @__PURE__ */ React.createElement("div", {
          className: "ChatOverlay-badge-username"
        }, de)), /* @__PURE__ */ React.createElement("div", {
          className: "ChatOverlay",
          style: {
            padding: 10,
            background: "orange",
            width: "fit-content",
            height: "fit-content",
            maxWidth: "84%",
            position: "relative"
          }
        }, ne && /* @__PURE__ */ React.createElement("div", {
          className: "ChatOverlay-body",
          style: {
            gap: 10,
            display: "flex",
            alignItems: "center",
            flexWrap: "wrap",
            verticalAlign: "middle"
          }
        }, ne.map((E, I) => /* @__PURE__ */ React.createElement(z, {
          key: I,
          ...E
        }))))))
      ) : (
        /* It's a ternary operator. If the style is not equal to BannerStyle.BUBBLE.toString(), then it will
        render the first div. Otherwise, it will render the second div. */
        /* @__PURE__ */ React.createElement("div", {
          style: {
            width: "100%",
            display: "flex"
          }
        }, /* @__PURE__ */ React.createElement("div", {
          className: "ChatOverlay",
          style: {
            padding: 10,
            background: "orange",
            width: "fit-content",
            height: "fit-content",
            maxWidth: "84%",
            position: "relative"
          }
        }, /* @__PURE__ */ React.createElement("div", {
          style: {
            display: "flex",
            marginTop: `-${O(160)}`,
            alignItems: "flex-end",
            padding: `${O(14)} ${O(0)} ${O(14)} ${O(0)}`,
            marginLeft: `${Te * 10}px`
          }
        }, q ? /* @__PURE__ */ React.createElement("div", {
          className: "ChatOverlayAvatar-container"
        }, /* @__PURE__ */ React.createElement("img", {
          src: q,
          className: "ChatOverlay-avatar"
        })) : /* @__PURE__ */ React.createElement("div", {
          className: "ChatOverlayAvatar-container"
        }, /* @__PURE__ */ React.createElement(j, {
          height: O(120),
          width: O(120),
          background: primary(500),
          username: de,
          fontSize: O(30)
        })), de && /* @__PURE__ */ React.createElement("button", {
          className: "ChatOverlay-badge-container"
        }, (C == null ? void 0 : C.icon) && /* @__PURE__ */ React.createElement(Icon$1, {
          className: "ChatOverlay-badge-icon",
          name: C == null ? void 0 : C.icon
        }), /* @__PURE__ */ React.createElement("div", {
          className: "ChatOverlay-badge-username"
        }, de))), ne && /* @__PURE__ */ React.createElement("div", {
          ref: S,
          className: "ChatOverlay-body",
          style: {
            gap: 10,
            alignItems: "center",
            flexWrap: "wrap",
            verticalAlign: "middle"
          }
        }, ne.map((E, I) => /* @__PURE__ */ React.createElement(z, {
          key: I,
          ...E
        })))))
      )));
    }, X = createRoot(l), ae = (Q) => X.render(/* @__PURE__ */ React.createElement(ee, {
      ...Q
    }));
    return a((Q) => {
      const {
        bannerStyle: ne = BannerStyle.DEFAULT
      } = v.props ?? {};
      D = {
        ...Q,
        metadata: {
          ...Q.metadata,
          bannerStyle: ne
        }
      }, ae(D);
    }), {
      root: l
    };
  }
}, Element$1 = {
  name: "Element",
  sourceType: "Element",
  create({
    onUpdate: a
  }, {
    tagName: u = "div"
  }) {
    const c = document.createElement(u);
    return a(({
      tagName: l,
      attributes: v = {},
      fields: p = {}
    }) => {
      l === "img" ? (c == null ? void 0 : c.src) !== v.src && Object.keys(v).forEach((_) => {
        c.setAttribute(_, v[_]);
      }) : Object.keys(v).forEach((_) => {
        c.setAttribute(_, v[_]);
      }), Object.keys(p).forEach((_) => {
        try {
          typeof c[_] == "object" ? Object.assign(c[_], p[_]) : c[_] = p[_];
        } catch {
          log.warn("Cannot assign field to element", {
            field: _
          });
        }
      });
    }), {
      root: c
    };
  }
}, OfflineIcon = () => /* @__PURE__ */ React.createElement("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 256 256"
}, /* @__PURE__ */ React.createElement("rect", {
  width: "256",
  height: "256",
  fill: "none"
}), /* @__PURE__ */ React.createElement("line", {
  x1: "80",
  y1: "152",
  x2: "80",
  y2: "200",
  fill: "none",
  stroke: "currentColor",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  "stroke-width": "16"
}), /* @__PURE__ */ React.createElement("line", {
  x1: "40",
  y1: "192",
  x2: "40",
  y2: "200",
  fill: "none",
  stroke: "currentColor",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  "stroke-width": "16"
}), /* @__PURE__ */ React.createElement("line", {
  x1: "48",
  y1: "40",
  x2: "208",
  y2: "216",
  fill: "none",
  stroke: "currentColor",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  "stroke-width": "16"
}), /* @__PURE__ */ React.createElement("line", {
  x1: "160",
  y1: "163.2",
  x2: "160",
  y2: "200",
  fill: "none",
  stroke: "currentColor",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  "stroke-width": "16"
}), /* @__PURE__ */ React.createElement("line", {
  x1: "160",
  y1: "72",
  x2: "160",
  y2: "115.63",
  fill: "none",
  stroke: "currentColor",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  "stroke-width": "16"
}), /* @__PURE__ */ React.createElement("line", {
  x1: "200",
  y1: "32",
  x2: "200",
  y2: "159.63",
  fill: "none",
  stroke: "currentColor",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  "stroke-width": "16"
}), /* @__PURE__ */ React.createElement("line", {
  x1: "120",
  y1: "119.2",
  x2: "120",
  y2: "200",
  fill: "none",
  stroke: "currentColor",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  "stroke-width": "16"
})), GameSource = {
  name: "LS-Game-Source",
  sourceType: "Game",
  props: {},
  useSource(a, u) {
    return a.find((c) => isMatch(c.props, u.sourceProps));
  },
  create({
    onUpdate: a,
    onNewSource: u,
    onRemove: c
  }, l) {
    const v = document.createElement("div"), p = getProject(CoreContext.state.activeProjectId);
    Object.assign(v.style, {
      position: "relative"
    });
    let _, k = l;
    const O = (j, ee) => {
      const X = j / ee.width;
      return X >= 0.5 ? 3 : X > 0.25 ? 2 : X > 0.15 ? 1 : 0;
    }, D = ({
      props: j,
      source: ee
    }) => {
      var Te;
      const X = useRef(), {
        volume: ae = 1,
        isHidden: Q = !1
      } = j || {}, [ne, Z] = useState(0), de = j == null ? void 0 : j.isMuted, fe = !(j != null && j.isHidden) && ((Te = ee == null ? void 0 : ee.props) == null ? void 0 : Te.videoEnabled);
      return useEffect(() => {
        X.current && (X.current.play().catch((Re) => {
          document.addEventListener("click", () => {
            var Le;
            return (Le = X.current) == null ? void 0 : Le.play();
          }, {
            once: !0
          });
        }), ee != null && ee.value && (ee == null ? void 0 : ee.value) !== X.current.srcObject ? X.current.srcObject = ee == null ? void 0 : ee.value : ee != null && ee.value || (X.current.srcObject = null));
      }, [X.current, ee == null ? void 0 : ee.value]), useEffect(() => {
        !j && X.current && (X.current.srcObject = null, X.current = null);
      }, [j]), useLayoutEffect(() => {
        if (!X.current)
          return;
        const Re = () => {
          const be = X.current;
          be && Z(O(be.clientWidth, {
            width: p.compositor.getRoot().props.size.x,
            height: p.compositor.getRoot().props.size.y
          }));
        }, Le = new ResizeObserver((be) => {
          Re();
        });
        return Re(), Le == null || Le.observe(X.current), () => {
          X.current && (Le == null || Le.unobserve(X.current), X.current.srcObject = null);
        };
      }, [X.current, p]), useEffect(() => {
        X.current && (X.current.volume = ae);
      }, [X.current, ae]), /* @__PURE__ */ React.createElement("div", {
        style: {
          position: "relative",
          display: "flex",
          height: "100%",
          width: "100%"
        }
      }, /* @__PURE__ */ React.createElement("div", {
        style: {
          background: "#222",
          position: "absolute",
          height: "100%",
          width: "100%",
          fontSize: "43px",
          color: "rgba(255,255,255,0.6)",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          opacity: fe ? "0" : "1"
        }
      }, !!ee && /* @__PURE__ */ React.createElement("div", {
        style: {
          textTransform: "uppercase",
          fontSize: 20,
          display: "flex",
          flexDirection: "column",
          alignItems: "center",
          justifyContent: "center",
          lineHeight: "1.2em",
          textAlign: "center",
          gap: 10
        }
      }, /* @__PURE__ */ React.createElement("div", {
        style: {
          color: "gray",
          width: 40,
          height: 40
        }
      }, /* @__PURE__ */ React.createElement(OfflineIcon, null)), "Game Source Offline")), /* @__PURE__ */ React.createElement("div", {
        style: {
          position: "relative",
          display: "flex",
          height: "100%",
          width: "100%"
        }
      }, /* @__PURE__ */ React.createElement("video", {
        ref: X,
        autoPlay: !0,
        muted: de,
        disablePictureInPicture: !0,
        playsInline: !0,
        style: {
          left: "50%",
          top: "50%",
          position: "relative",
          transform: "translate3d(-50%, -50%, 0)",
          height: "100%",
          opacity: fe ? "1" : "0",
          objectFit: "cover",
          background: "rgba(0,0,0,0.6)"
        }
      })));
    }, F = createRoot(v), z = () => F.render(/* @__PURE__ */ React.createElement(D, {
      source: _,
      props: k
    }));
    return a((j) => {
      k = j, z();
    }), u((j) => {
      _ = j, z();
    }), c((j) => {
      k = j, z();
    }), {
      root: v
    };
  }
}, Logo = {
  name: "LS-Logo",
  sourceType: "Logo",
  create({
    onUpdate: a
  }, {
    sourceProps: u
  }) {
    const c = document.createElement("div"), v = getProject(CoreContext.state.activeProjectId).compositor.getRoot(), {
      x: p
    } = v.props.size, _ = (p ?? 1280) / 1920, k = (z) => z * _ + "px", O = ({
      source: z
    }) => {
      var Te;
      const {
        src: j,
        meta: ee
      } = (z == null ? void 0 : z.sourceProps) || {}, {
        id: X
      } = z || {}, [ae, Q] = React.useState(!1);
      useEffect(() => {
        Q(!1);
      }, [X]);
      const {
        offsetX: ne = 40,
        offsetY: Z = 40,
        height: de = 135,
        width: fe = 240
      } = (ee == null ? void 0 : ee.style) || {};
      return /* @__PURE__ */ React.createElement(APIKitAnimation$1, {
        type: "logo",
        id: X,
        enter: APIKitAnimationTypes.FADE_IN,
        exit: APIKitAnimationTypes.FADE_OUT,
        duration: 400
      }, /* @__PURE__ */ React.createElement("div", {
        style: {
          opacity: ae ? 1 : 0,
          width: "100%",
          height: "100%"
        },
        className: "logo-transition"
      }, j && /* @__PURE__ */ React.createElement("div", {
        className: "logo wrapper",
        style: {
          padding: `${k(Z)} ${k(ne)}`
        }
      }, /* @__PURE__ */ React.createElement("img", {
        style: {
          height: "100%",
          width: "100%",
          maxHeight: de ? k(de) : "none",
          maxWidth: fe ? k(fe) : "none",
          ...(Te = u == null ? void 0 : u.meta) == null ? void 0 : Te.style,
          ...ee == null ? void 0 : ee.style
        },
        src: j,
        onLoad: () => Q(!0)
      }))));
    }, D = createRoot(c), F = (z) => D.render(/* @__PURE__ */ React.createElement(O, {
      source: z
    }));
    return a((z) => {
      F({
        ...z
      });
    }), {
      root: c
    };
  }
}, Iframe = ({
  url: a,
  allowFullScreen: u,
  position: c,
  display: l,
  height: v,
  width: p,
  overflow: _,
  styles: k,
  onLoad: O,
  id: D,
  frameBorder: F,
  className: z,
  name: j,
  target: ee,
  iframeRef: X,
  children: ae,
  src: Q
}) => {
  const ne = Object.assign({
    src: Q || a,
    target: ee || null,
    style: {
      position: c || null,
      display: l || "block",
      overflow: _ || null,
      ...k
    },
    name: j || null,
    className: z || null,
    id: D || null,
    onLoad: O || null,
    height: v || "100%",
    width: p || "100%",
    allow: "autoplay"
  });
  let Z = /* @__PURE__ */ Object.create(null);
  for (let de of Object.keys(ne))
    ne[de] != null && (Z[de] = ne[de]);
  for (let de of Object.keys(Z.style))
    Z.style[de] == null && delete Z.style[de];
  if (u)
    if ("allow" in Z) {
      const de = Z.allow.replace("fullscreen", "");
      Z.allow = `fullscreen ${de.trim()}`.trim();
    } else
      Z.allow = "fullscreen";
  return F >= 0 && (Z.style.hasOwnProperty("border") || (Z.style.border = F)), /* @__PURE__ */ React.createElement(React.Fragment, null, ae ? /* @__PURE__ */ React.createElement("iframe", {
    ref: X,
    ...Z,
    style: {
      colorScheme: "normal",
      ...Z.style
    }
  }, ae) : /* @__PURE__ */ React.createElement("iframe", {
    ref: X,
    ...Z,
    style: {
      colorScheme: "normal",
      ...Z.style
    }
  }));
}, Iframe$1 = Iframe, Overlay = {
  name: "LS-Overlay",
  sourceType: "Overlay",
  create({
    onUpdate: a,
    onRemove: u
  }, {
    sourceProps: c
  }) {
    u(() => {
      clearInterval(p);
    });
    const l = document.createElement("div"), v = getProject(CoreContext.state.activeProjectId).role;
    let p;
    const _ = React.memo(({
      source: j,
      setStartAnimation: ee
    }) => {
      const {
        src: X,
        meta: ae,
        height: Q,
        width: ne
      } = (j == null ? void 0 : j.sourceProps) || {}, Z = React.useRef(null);
      useEffect(() => {
        Z.current && (Z.current.style.removeProperty("transformOrigin"), Z.current.style.removeProperty("transform"));
      }, [X]);
      const de = () => {
        if (Z.current) {
          const Te = getProject(CoreContext.state.activeProjectId).compositor.getRoot(), {
            x: Re,
            y: Le
          } = Te.props.size;
          let be = Z.current.clientWidth, q = Z.current.clientHeight, J;
          be && q ? J = Math.min(Re / be, Le / q) : J = 1, Z.current.style.willChange = "transform", Z.current.style.transformOrigin = "0 0", Z.current.style.transform = `scale(${J}) translateZ(0)`, ee(!0);
        }
      };
      return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Iframe$1, {
        key: j.id,
        url: X,
        frameBorder: 0,
        iframeRef: Z,
        height: Q,
        width: ne,
        onLoad: de,
        styles: {
          ...ae == null ? void 0 : ae.style
        }
      }));
    }), k = React.memo(({
      source: j,
      setStartAnimation: ee
    }) => {
      var J;
      const {
        src: X,
        type: ae,
        meta: Q,
        loop: ne
      } = (j == null ? void 0 : j.sourceProps) || {}, {
        id: Z,
        sourceType: de
      } = j || {}, [fe, Te] = React.useState(null), Re = React.useRef(null);
      console.log("Updated current time", (J = Re == null ? void 0 : Re.current) == null ? void 0 : J.currentTime);
      const Le = React.useCallback((C) => {
        Re.current = C, Te(C ? C.id : null);
      }, []), be = React.useCallback(() => {
        Re != null && Re.current && Re.current.play().catch(() => {
          var C;
          Re.current.muted = !0, (C = Re.current) == null || C.play();
        });
      }, [X]), q = React.useCallback(() => {
        p && clearInterval(p), hasPermission(v, Permission.UpdateProject) && trigger$1("VideoEnded", {
          id: Z,
          category: ae
        });
      }, [X]);
      return React.useEffect(() => {
        Q && (Re != null && Re.current) && fe && hasPermission(v, Permission.ManageSelf) && Q != null && Q.time && (Re.current.currentTime = Number(Q == null ? void 0 : Q.time));
      }, [Q == null ? void 0 : Q.time, fe]), React.useEffect(() => () => {
        p && clearInterval(p);
      }, [Z]), React.useEffect(() => {
        fe ? Re.current && (Re.current.src = X, Re.current.play().catch(() => {
          Re.current.muted = !0, Re.current.play();
        }), hasPermission(v, Permission.UpdateProject) && (p = setInterval(() => {
          if (Re.current.duration) {
            const C = Re.current.duration - Re.current.currentTime;
            trigger$1("VideoTimeUpdate", {
              category: de,
              id: Z,
              time: Math.floor(C)
            });
          }
        }, 1e3))) : p && clearInterval(p);
      }, [fe]), /* @__PURE__ */ React.createElement(React.Fragment, {
        key: Z
      }, X && /* @__PURE__ */ React.createElement("video", {
        loop: ne,
        id: Z,
        ref: Le,
        style: {
          ...c.meta.style,
          ...Q.style
        },
        onLoadedData: be,
        onEnded: q,
        onCanPlay: () => ee(!0)
      }));
    }), O = React.memo(({
      source: j,
      setStartAnimation: ee
    }) => {
      const {
        src: X,
        meta: ae
      } = (j == null ? void 0 : j.sourceProps) || {}, {
        id: Q
      } = j || {};
      return /* @__PURE__ */ React.createElement(React.Fragment, {
        key: Q
      }, X && /* @__PURE__ */ React.createElement("img", {
        style: {
          ...c.meta.style,
          ...ae.style
        },
        src: X,
        onLoad: () => ee(!0)
      }));
    }), D = React.memo(({
      source: j
    }) => {
      const {
        type: ee
      } = (j == null ? void 0 : j.sourceProps) || {}, {
        id: X
      } = j || {}, [ae, Q] = React.useState(!1);
      return useEffect(() => {
        Q(!1);
      }, [X]), /* @__PURE__ */ React.createElement(APIKitAnimation$1, {
        id: X,
        type: "overlay",
        enter: APIKitAnimationTypes.FADE_IN,
        exit: APIKitAnimationTypes.FADE_OUT,
        duration: 400
      }, /* @__PURE__ */ React.createElement("div", {
        style: {
          opacity: ae ? 1 : 0,
          height: "100%",
          width: "100%"
        },
        className: "overlayContainer overlay-transition"
      }, X && ee === "image" && /* @__PURE__ */ React.createElement(O, {
        source: j,
        setStartAnimation: Q
      }), X && ee === "video" && /* @__PURE__ */ React.createElement(k, {
        source: j,
        setStartAnimation: Q
      }), X && ee === "custom" && /* @__PURE__ */ React.createElement(_, {
        source: j,
        setStartAnimation: Q
      })));
    }), F = createRoot(l), z = (j) => F.render(/* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(D, {
      source: j
    })));
    return a((j) => {
      z({
        ...j
      });
    }), {
      root: l
    };
  }
}, RTMPSource = {
  name: "LS-RTMP-Source",
  sourceType: "RTMP",
  props: {},
  useSource(a, u) {
    return a.find((c) => isMatch(c.props, u.sourceProps));
  },
  create({
    onUpdate: a,
    onNewSource: u,
    onRemove: c
  }, l) {
    const v = document.createElement("div"), p = getProject(CoreContext.state.activeProjectId);
    getProjectRoom(CoreContext.state.activeProjectId), Object.assign(v.style, {
      position: "relative"
    });
    let _, k = l;
    const O = (j, ee) => {
      const X = j / ee.width;
      return X >= 0.5 ? 3 : X > 0.25 ? 2 : X > 0.15 ? 1 : 0;
    }, D = ({
      props: j,
      source: ee
    }) => {
      var Te;
      const X = useRef(), {
        volume: ae = 1,
        isHidden: Q = !1
      } = j || {}, [ne, Z] = useState(0), de = j == null ? void 0 : j.isMuted, fe = !(j != null && j.isHidden) && ((Te = ee == null ? void 0 : ee.props) == null ? void 0 : Te.videoEnabled);
      return useEffect(() => {
        X.current && (X.current.play().catch((Re) => {
          document.addEventListener("click", () => {
            var Le;
            return (Le = X.current) == null ? void 0 : Le.play();
          }, {
            once: !0
          });
        }), ee != null && ee.value && (ee == null ? void 0 : ee.value) !== X.current.srcObject ? X.current.srcObject = ee == null ? void 0 : ee.value : ee != null && ee.value || (X.current.srcObject = null));
      }, [X.current, ee == null ? void 0 : ee.value]), useEffect(() => {
        !j && X.current && (X.current.srcObject = null, X.current = null);
      }, [j]), useLayoutEffect(() => {
        if (!X.current)
          return;
        const Re = () => {
          const be = X.current;
          be && Z(O(be.clientWidth, {
            width: p.compositor.getRoot().props.size.x,
            height: p.compositor.getRoot().props.size.y
          }));
        }, Le = new ResizeObserver((be) => {
          Re();
        });
        return Re(), Le == null || Le.observe(X.current), () => {
          X.current && (Le == null || Le.unobserve(X.current), X.current.srcObject = null);
        };
      }, [X.current, p]), useEffect(() => {
        X.current && (X.current.volume = ae);
      }, [X.current, ae]), /* @__PURE__ */ React.createElement("div", {
        style: {
          position: "relative",
          display: "flex",
          height: "100%",
          width: "100%"
        }
      }, /* @__PURE__ */ React.createElement("div", {
        style: {
          background: "#222",
          position: "absolute",
          height: "100%",
          width: "100%",
          fontSize: "43px",
          color: "rgba(255,255,255,0.6)",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          opacity: fe ? "0" : "1"
        }
      }, !!ee && /* @__PURE__ */ React.createElement("div", {
        style: {
          borderRadius: "50%",
          background: "#555",
          width: "70px",
          height: "70px",
          textTransform: "uppercase",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          lineHeight: "1em"
        }
      }, "RTMP")), /* @__PURE__ */ React.createElement("div", {
        style: {
          position: "relative",
          display: "flex",
          height: "100%",
          width: "100%"
        }
      }, /* @__PURE__ */ React.createElement("video", {
        ref: X,
        autoPlay: !0,
        muted: de,
        disablePictureInPicture: !0,
        playsInline: !0,
        style: {
          left: "50%",
          top: "50%",
          position: "relative",
          transform: "translate3d(-50%, -50%, 0)",
          height: "100%",
          opacity: fe ? "1" : "0",
          objectFit: "cover",
          background: "rgba(0,0,0,0.6)"
        }
      })));
    }, F = createRoot(v), z = () => F.render(/* @__PURE__ */ React.createElement(D, {
      source: _,
      props: k
    }));
    return a((j) => {
      k = j, z();
    }), u((j) => {
      _ = j, z();
    }), c((j) => {
      k = j, z();
    }), {
      root: v
    };
  }
}, RoomParticipant = {
  name: "LS-Room-Participant",
  sourceType: "RoomParticipant",
  props: {
    isMuted: {
      type: Boolean,
      required: !1,
      default: !1
    },
    volume: {
      type: Number,
      required: !1,
      default: 1
    }
  },
  useSource(a, u) {
    return a.find((c) => isMatch(c.props, u.sourceProps));
  },
  create({
    onUpdate: a,
    onNewSource: u,
    onRemove: c
  }, l) {
    const v = document.createElement("div"), p = getProject(CoreContext.state.activeProjectId), _ = getProjectRoom(CoreContext.state.activeProjectId);
    Object.assign(v.style, {
      position: "relative"
    });
    let k, O = l;
    const D = (ee, X) => {
      const ae = ee / X.width;
      return ae >= 0.5 ? 3 : ae > 0.25 ? 2 : ae > 0.15 ? 1 : 0;
    }, F = ({
      props: ee,
      source: X
    }) => {
      var Le, be, q;
      const ae = useRef(), {
        volume: Q = 1,
        isHidden: ne = !1
      } = ee || {}, [Z, de] = useState(0), Te = (X == null ? void 0 : X.id) === (_ == null ? void 0 : _.participantId) || ((Le = X == null ? void 0 : X.props) == null ? void 0 : Le.participantId) === (_ == null ? void 0 : _.participantId) || (ee == null ? void 0 : ee.isMuted), Re = !(ee != null && ee.isHidden) && ((be = X == null ? void 0 : X.props) == null ? void 0 : be.videoEnabled);
      return useEffect(() => {
        ae.current && (ae.current.play().catch((J) => {
          document.addEventListener("click", () => {
            var C;
            return (C = ae.current) == null ? void 0 : C.play();
          }, {
            once: !0
          });
        }), X != null && X.value && (X == null ? void 0 : X.value) !== ae.current.srcObject ? ae.current.srcObject = X == null ? void 0 : X.value : X != null && X.value || (ae.current.srcObject = null));
      }, [ae.current, X == null ? void 0 : X.value]), useEffect(() => {
        !ee && ae.current && (ae.current.srcObject = null, ae.current = null);
      }, [ee]), useLayoutEffect(() => {
        if (!ae.current)
          return;
        const J = () => {
          const S = ae.current;
          S && de(D(S.clientWidth, {
            width: p.compositor.getRoot().props.size.x,
            height: p.compositor.getRoot().props.size.y
          }));
        }, C = new ResizeObserver((S) => {
          J();
        });
        return J(), C == null || C.observe(ae.current), () => {
          ae.current && (C == null || C.unobserve(ae.current), ae.current.srcObject = null);
        };
      }, [ae.current, p]), useEffect(() => {
        ae.current && (ae.current.volume = Q);
      }, [ae.current, Q]), /* @__PURE__ */ React.createElement("div", {
        style: {
          position: "relative",
          display: "flex",
          height: "100%",
          width: "100%"
        }
      }, /* @__PURE__ */ React.createElement("div", {
        style: {
          background: "#222",
          position: "absolute",
          height: "100%",
          width: "100%",
          fontSize: "43px",
          color: "rgba(255,255,255,0.6)",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          opacity: Re ? "0" : "1"
        }
      }, (X == null ? void 0 : X.props.displayName) && /* @__PURE__ */ React.createElement("div", {
        style: {
          borderRadius: "50%",
          background: "#555",
          width: "70px",
          height: "70px",
          textTransform: "uppercase",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          lineHeight: "1em"
        }
      }, (X == null ? void 0 : X.props.displayName.slice(0, 1)) || "")), /* @__PURE__ */ React.createElement("div", {
        style: {
          position: "relative",
          display: "flex",
          height: "100%",
          width: "100%",
          ...!!((q = X == null ? void 0 : X.props) != null && q.mirrored) && {
            transform: "scaleX(-1)"
          }
        }
      }, /* @__PURE__ */ React.createElement("video", {
        ref: ae,
        autoPlay: !0,
        muted: Te,
        disablePictureInPicture: !0,
        playsInline: !0,
        style: {
          left: "50%",
          top: "50%",
          position: "relative",
          transform: "translate3d(-50%, -50%, 0)",
          height: "100%",
          opacity: Re ? "1" : "0",
          objectFit: (X == null ? void 0 : X.props.type) === "screen" ? "contain" : "cover",
          background: "rgba(0,0,0,0.6)"
        }
      })), (X == null ? void 0 : X.props.displayName) && /* @__PURE__ */ React.createElement("div", {
        className: "NameBannerContainer",
        style: {
          width: "100%",
          height: "100%",
          position: "absolute"
        }
      }, /* @__PURE__ */ React.createElement("div", {
        className: "NameBanner",
        "data-size": Z,
        style: {
          padding: "12px 30px",
          width: "fit-content",
          height: "fit-content",
          top: "100%",
          transform: "translateY(-100%)",
          left: 0
        }
      }, /* @__PURE__ */ React.createElement("div", {
        className: "NameBanner-body"
      }, X.props.displayName))));
    }, z = createRoot(v), j = () => z.render(/* @__PURE__ */ React.createElement(F, {
      source: k,
      props: O
    }));
    return a((ee) => {
      O = ee, j();
    }), u((ee) => {
      k = ee, j();
    }), c((ee) => {
      O = ee, j();
    }), {
      root: v
    };
  }
}, Alert = {
  name: "LS-Alert",
  sourceType: "Alert",
  create({
    onUpdate: a
  }) {
    const u = document.createElement("div"), c = ({
      source: p
    }) => {
      const {
        id: _
      } = p || {}, [k, O] = React.useState(!1);
      useEffect(() => {
        O(!1);
      }, [_]);
      const {
        src: D,
        meta: F,
        height: z,
        width: j,
        settings: ee
      } = (p == null ? void 0 : p.sourceProps) || {}, X = React.useRef(null), ae = React.useMemo(() => Object.entries(ee).map((ne) => ne.join("=")).concat(["mode=engine"]).join("&"), [ee]), Q = React.useCallback(() => {
        X.current && O(!0);
      }, []);
      return /* @__PURE__ */ React.createElement(APIKitAnimation$1, {
        id: _,
        type: "alert",
        enter: APIKitAnimationTypes.FADE_IN,
        exit: APIKitAnimationTypes.FADE_OUT,
        duration: 400
      }, /* @__PURE__ */ React.createElement("div", {
        style: {
          opacity: k ? 1 : 0
        }
      }, /* @__PURE__ */ React.createElement(Iframe$1, {
        key: p.id,
        url: `${D}?${ae}`,
        frameBorder: 0,
        iframeRef: X,
        height: z,
        width: j,
        onLoad: Q,
        styles: {
          ...F == null ? void 0 : F.style
        }
      })));
    }, l = createRoot(u), v = (p) => l.render(/* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(c, {
      source: p
    })));
    return a((p) => {
      v({
        ...p
      });
    }), {
      root: u
    };
  }
}, Transforms = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Alert,
  Background,
  Banner,
  ChatOverlay,
  Element: Element$1,
  GameSource,
  Logo,
  Overlay,
  RTMPSource,
  RoomParticipant
}, Symbol.toStringTag, { value: "Module" }));
class EngineWebsocket {
  constructor(u, c) {
    Ft(this, "ws", null);
    Ft(this, "sources", /* @__PURE__ */ new Set());
    this.connectSource = u, this.disconnectSource = c, this.connect = this.connect.bind(this), this.handleMessage = this.handleMessage.bind(this);
  }
  getConnectionString() {
    if (!("apistreamCompositor" in window))
      return "ws://127.0.0.1:8000";
    const {
      eventsConfig: u
    } = window.apistreamCompositor;
    return `ws${u.secure ? "s" : ""}://${u.hostname}:${u.port}${u.token ? `?token=${u.token}` : ""}`;
  }
  connect() {
    const u = this.handleMessage.bind(this);
    this.ws = new WebSocket(this.getConnectionString()), this.ws.addEventListener("message", u), this.ws.addEventListener("error", (c) => {
      console.error("Unable to connect to websocket", c);
    }), this.ws.addEventListener("close", () => {
      var c, l;
      (c = this.ws) == null || c.removeEventListener("message", u);
      try {
        (l = this.ws) == null || l.close(), this.ws = null;
      } catch {
      }
      setTimeout(() => {
        this.connect();
      }, 1e3);
    });
  }
  disconnect() {
    var u, c;
    (u = this.ws) != null && u.OPEN && ((c = this.ws) == null || c.close());
  }
  handleMessage(u) {
    try {
      const c = JSON.parse(u.data);
      if (c.name === "state") {
        this.sources.clear(), console.info("[Engine]: state", c.payload);
        for (const l of c.payload.sources)
          l.connected && (this.sources.has(l.id) || (this.sources.add(l.id), this.connectSource(l.id)));
      } else
        c.name === "source.disconnect" ? (console.info("[Engine]: source disconnect", c.payload.id), this.sources.delete(c.payload.id), this.disconnectSource(c.payload.id)) : c.name === "source.connect" && (console.info("[Engine]: source connect", c.payload.id), this.sources.add(c.payload.id), this.connectSource(c.payload.id));
    } catch (c) {
      console.error("unable to handle message: ", c);
    }
  }
}
const BroadcastPhase = lib$2.LiveApiModel.ProjectBroadcastPhase, {
  trigger,
  triggerInternal
} = CoreContext, EventType = lib$2.LiveApiModel.EventType, EventSubType = lib$2.LiveApiModel.EventSubType;
let engineSocket;
const init = async (a = {}) => {
  prepareInternalEvents();
  const u = a.env || "prod", c = a.logLevel || "Warn";
  log.getLogger("livekit").setLevel(c), log.setLevel(c), log.info("Initializing Studio SDK...");
  const {
    layouts: v = [],
    transforms: p = [],
    sources: _ = [],
    defaultTransforms: k = {},
    useLatestRenderer: O = !1,
    guestToken: D,
    rendererVersion: F
  } = a, z = new lib$2.ApiStream({
    sdkVersion: CoreContext.version,
    env: u,
    logLevel: c
  }), j = config$2(), ee = start({
    dbAdapter: compositorAdapter,
    transformSettings: {
      defaultTransforms: {
        ...k,
        ...j.defaults.transforms
      }
    }
  });
  CoreContext.config = j, CoreContext.clients = z, CoreContext.compositor = ee, CoreContext.logLevel = c, CoreContext.Request = await Promise.resolve().then(() => requests), CoreContext.Command = await Promise.resolve().then(() => commands$1), CoreContext.rendererVersion = O ? "latest-v2" : F || CoreContext.version, window.__StudioKit = {
    ...CoreContext
  }, ee && (ee.registerSource([...Object.values(Sources), ..._]), ee.registerTransform([...Object.values(Transforms), ...p]), ee.registerLayout([...Object.values(Layouts), ...v]));
  const X = await z.load(D);
  let ae;
  X && await z.LiveApi().project.getProject({
    ...X
  }).then((ne) => hydrateProject(ne.project, X.role)).then(async (ne) => {
    setAppState({
      // As a contributor, `user` refers to the collection
      //  that the project belongs to. This will be referenced
      //  when making requests requiring `collectionId`.
      user: {
        id: X.collectionId,
        props: {},
        name: null,
        metadata: {}
      },
      // TODO: Populate
      sources: [],
      projects: [ne],
      activeProjectId: null
    }), ne.isInitial = !0, ae = await CoreContext.Command.setActiveProject({
      projectId: ne.id
    });
  }), z.LiveApi().on(EventType.EVENT_TYPE_COLLECTION, (ne, Z) => {
    switch (log.info("Received: Collection event", Z, ne), Z) {
      case EventSubType.EVENT_SUB_TYPE_UPDATE: {
        triggerInternal("UserChanged", ne.update.collection);
        return;
      }
    }
  }), z.LiveApi().on(EventType.EVENT_TYPE_DESTINATION, (ne, Z) => {
    switch (log.info("Received: Destination event", Z, ne), Z) {
      case EventSubType.EVENT_SUB_TYPE_CREATE: {
        const {
          destination: de
        } = ne.create;
        triggerInternal("DestinationAdded", de);
        return;
      }
      case EventSubType.EVENT_SUB_TYPE_UPDATE: {
        const {
          destination: de
        } = ne.update;
        triggerInternal("DestinationChanged", de);
        return;
      }
      case EventSubType.EVENT_SUB_TYPE_DELETE: {
        triggerInternal("DestinationRemoved", ne.delete);
        return;
      }
    }
  }), z.LiveApi().on(EventType.EVENT_TYPE_SOURCE, (ne, Z) => {
    switch (log.info("Received: Source event", Z, ne), Z) {
      case EventSubType.EVENT_SUB_TYPE_CREATE: {
        triggerInternal("SourceAdded", ne.create.source);
        return;
      }
      case EventSubType.EVENT_SUB_TYPE_UPDATE: {
        triggerInternal("SourceChanged", ne.update.source);
        return;
      }
      case EventSubType.EVENT_SUB_TYPE_DELETE: {
        triggerInternal("SourceRemoved", ne.delete.sourceId);
        return;
      }
      case EventSubType.EVENT_SUB_TYPE_ADD: {
        triggerInternal("ProjectSourceAdded", {
          projectId: ne.add.projectId,
          source: ne.add.source
        });
        return;
      }
      case EventSubType.EVENT_SUB_TYPE_REMOVE: {
        triggerInternal("ProjectSourceRemoved", {
          projectId: ne.remove.projectId,
          sourceId: ne.remove.sourceId
        });
        return;
      }
    }
  }), z.LiveApi().on(EventType.EVENT_TYPE_PROJECT, (ne, Z) => {
    var de;
    switch (log.info("Received: Project event", Z, ne), Z) {
      case EventSubType.EVENT_SUB_TYPE_CREATE: {
        const fe = ne.create.project;
        if (getProject(fe.projectId))
          return;
        triggerInternal("ProjectAdded", fe);
        return;
      }
      case EventSubType.EVENT_SUB_TYPE_UPDATE: {
        const {
          project: fe
        } = ne.update, Te = getProject(fe.projectId);
        if (!Te)
          return;
        triggerInternal("ProjectChanged", {
          project: fe,
          phase: Te.videoApi.phase
        });
        return;
      }
      case EventSubType.EVENT_SUB_TYPE_DELETE: {
        triggerInternal("ProjectRemoved", {
          projectId: ne.delete.projectId
        });
        return;
      }
      case EventSubType.EVENT_SUB_TYPE_STATE: {
        const fe = getProject((de = ne.state) == null ? void 0 : de.projectId);
        if (!fe)
          return;
        let Te = ne.state.broadcastId;
        if (ne.state.error && trigger("BroadcastError", {
          projectId: fe.id,
          broadcastId: ne.state.broadcastId,
          error: ne.state.error
        }), ne.state.phase) {
          const Re = ne.state.phase;
          Re === BroadcastPhase.PROJECT_BROADCAST_PHASE_RUNNING ? trigger("BroadcastStarted", {
            projectId: fe.id,
            broadcastId: ne.state.broadcastId
          }) : Re === BroadcastPhase.PROJECT_BROADCAST_PHASE_STOPPED && (Te = null, trigger("BroadcastStopped", {
            projectId: fe.id,
            broadcastId: ne.state.broadcastId
          }));
        }
        triggerInternal("ProjectChanged", {
          project: fe.videoApi.project,
          phase: ne.state.phase,
          broadcastId: Te
        });
        return;
      }
    }
  }), z.LayoutApi().on(lib$2.LayoutApiModel.EventType.EVENT_TYPE_LAYER, (ne, Z) => {
    var de;
    if (Z === lib$2.LayoutApiModel.EventSubType.EVENT_SUB_TYPE_CREATE) {
      log.debug("Received: Node Insert", ne.create);
      const {
        connectionId: fe,
        layoutId: Te
      } = ne.create.requestMetadata;
      if (CoreContext.connectionId === fe)
        return;
      const Re = layerToNode(ne.create), Le = getProjectByLayoutId(Te), be = [Re, ...Le.compositor.nodes.map(toDataNode$1)], q = toSceneTree(be, Re.id);
      Le.compositor.local.insert(q), triggerInternal("NodeAdded", {
        projectId: Le.id,
        nodeId: Re.id
      });
    } else if (Z === lib$2.LayoutApiModel.EventSubType.EVENT_SUB_TYPE_UPDATE) {
      log.debug("Received: Node Update", ne.update);
      const {
        connectionId: fe,
        layoutId: Te,
        updateVersions: Re = {}
      } = ((de = ne.update) == null ? void 0 : de.requestMetadata) || {};
      if (CoreContext.connectionId === fe)
        return;
      const Le = layerToNode(ne.update);
      if ((latestUpdateVersion[Le.id] || 0) > Re[Le.id])
        return log.info("Ignoring node update - updateID is less than latest.");
      latestUpdateVersion[Le.id] = Re[Le.id];
      const q = getProjectByLayoutId(Te);
      q.compositor.local.update(ne.update.id, Le.props, Le.childIds), triggerInternal("NodeChanged", {
        projectId: q.id,
        nodeId: Le.id
      });
    } else if (Z === lib$2.LayoutApiModel.EventSubType.EVENT_SUB_TYPE_DELETE) {
      log.debug("Received: Node Delete", ne.delete);
      const {
        connectionId: fe,
        layoutId: Te
      } = ne.delete.requestMetadata;
      if (CoreContext.connectionId === fe)
        return;
      const Re = getProjectByLayoutId(Te);
      Re.compositor.local.remove(ne.delete.id), triggerInternal("NodeRemoved", {
        projectId: Re.id,
        nodeId: ne.delete.id
      });
    } else if (Z === lib$2.LayoutApiModel.EventSubType.EVENT_SUB_TYPE_BATCH) {
      log.debug("Received: Node Batch Update", ne.batch);
      const {
        connectionId: fe,
        layoutId: Te,
        updateVersions: Re = {}
      } = ne.batch.requestMetadata;
      if (CoreContext.connectionId === fe)
        return;
      const Le = getProjectByLayoutId(Te);
      ne.batch.layers.forEach((be) => {
        try {
          const [q, J] = Object.entries(be)[0];
          if (q === "create") {
            const C = layerToNode(J);
            Le.compositor.local.insert(C), triggerInternal("NodeAdded", {
              projectId: Le.id,
              nodeId: C.id
            });
          } else if (q === "update") {
            const C = layerToNode(J);
            if ((latestUpdateVersion[C.id] || 0) > Re[C.id])
              return log.info("Ignoring node update - updateID is less than latest.");
            latestUpdateVersion[C.id] = Re[C.id], Le.compositor.local.update(C.id, C.props, C.childIds), triggerInternal("NodeChanged", {
              projectId: Le.id,
              nodeId: C.id
            });
          } else
            q === "delete" && (Le.compositor.local.remove(J.id), triggerInternal("NodeRemoved", {
              projectId: Le.id,
              nodeId: J.id
            }));
        } catch (q) {
          log.warn("Error handling batch item", q, {
            item: be
          });
        }
      }), Le && triggerInternal("NodeChanged", {
        projectId: Le.id,
        nodeId: Le.compositor.getRoot().id
      });
    }
  });
  const Q = (ne = {}, Z) => {
    const {
      displayName: de,
      role: fe,
      maxDuration: Te = CoreContext.config.defaults.guestTokenDuration,
      projectId: Re = CoreContext.state.activeProjectId
    } = ne, Le = getProject(Re), be = de ? {
      direct: {
        displayName: de
      }
    } : {
      exchange: {
        maxDuration: Te
      }
    };
    return z.LiveApi().authentication.createGuestAccessToken({
      projectId: Re,
      token: be,
      url: Z,
      collectionId: Le.videoApi.project.collectionId,
      maxDuration: Te,
      role: fe || lib$2.LiveApiModel.Role.ROLE_GUEST
    });
  };
  return {
    ...omit(CoreContext, ["clients", "config", "connectionId", "Request", "state", "trigger"]),
    createDemoToken: async () => (console.warn("createDemoToken() is currently unavailable."), ""),
    createPreviewLink: async (ne = {}) => {
      const {
        maxDuration: Z,
        projectId: de = CoreContext.state.activeProjectId
      } = ne, fe = getProject(de), Te = fe.videoApi.project.composition.studioSdk.rendererUrl;
      return (await z.LiveApi().authentication.createGuestAccessToken({
        projectId: de,
        token: {
          direct: {
            displayName: "Preview"
          }
        },
        url: Te,
        collectionId: fe.videoApi.project.collectionId,
        maxDuration: Z || CoreContext.config.defaults.previewTokenDuration,
        role: lib$2.LiveApiModel.Role.ROLE_VIEWER
      })).url;
    },
    createGuestLink: async (ne, Z = {}) => (await Q(Z, ne)).url,
    createGuestToken: async (ne = {}) => (await Q(ne)).accessToken,
    initialProject: ae,
    getProject: (ne) => toBaseProject(getProject(ne)),
    load,
    render
  };
};
CoreContext.on("ActiveProjectChanged", ({
  projectId: a
}) => {
  toBaseProject(getProject(a)).role === Role.ROLE_RENDERER && (log.info("Connecting to engine websocket..."), engineSocket && (log.info("Disconnecting existing engine websocket..."), engineSocket.disconnect(), engineSocket = null), engineSocket || (log.info("Creating new engine websocket..."), engineSocket = setupEngineWebsocket(async function(l) {
    triggerInternal("SourceConnected", l);
  }, async function(l) {
    triggerInternal("SourceDisconnected", l);
  }), engineSocket.connect()));
});
function setupEngineWebsocket(a, u) {
  return new EngineWebsocket(a, u);
}
const load = async (a, u) => {
  let c = getBaseUser();
  if (c)
    return log.info("Attempted to load user again - returning existing user"), c;
  if (!a) {
    log.warn("Access token required for load()");
    return;
  }
  log.info("Loading user..."), await CoreContext.clients.load(a);
  const v = await CoreContext.Request.loadUser(u);
  return setAppState({
    user: v.user,
    sources: v.sources,
    projects: v.projects,
    activeProjectId: null
  }), c = getBaseUser(), trigger("UserLoaded", c), c;
};
export {
  commands$1 as Command,
  index as Compositor,
  context as Context,
  events$1 as Events,
  index$1 as Helpers,
  Layouts,
  requests as Request,
  index$2 as Room,
  types$2 as SDK,
  init
};
//# sourceMappingURL=index.js.map
