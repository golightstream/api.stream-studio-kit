var zi = Object.defineProperty;
var Ki = (a, u, c) => u in a ? zi(a, u, { enumerable: !0, configurable: !0, writable: !0, value: c }) : a[u] = c;
var Ft = (a, u, c) => (Ki(a, typeof u != "symbol" ? u + "" : u, c), c);
import React, { useState, useEffect, useContext, useMemo, useRef, useLayoutEffect } from "react";
import ReactDOM from "react-dom";
var commonjsGlobal$1 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs$2(a) {
  return a && a.__esModule && Object.prototype.hasOwnProperty.call(a, "default") ? a.default : a;
}
function getAugmentedNamespace(a) {
  if (a.__esModule)
    return a;
  var u = a.default;
  if (typeof u == "function") {
    var c = function l() {
      return this instanceof l ? Reflect.construct(u, arguments, this.constructor) : u.apply(this, arguments);
    };
    c.prototype = u.prototype;
  } else
    c = {};
  return Object.defineProperty(c, "__esModule", { value: !0 }), Object.keys(a).forEach(function(l) {
    var v = Object.getOwnPropertyDescriptor(a, l);
    Object.defineProperty(c, l, v.get ? v : {
      enumerable: !0,
      get: function() {
        return a[l];
      }
    });
  }), c;
}
var lib$2 = {};
function e(a) {
  this.message = a;
}
e.prototype = new Error(), e.prototype.name = "InvalidCharacterError";
var r$2 = typeof window < "u" && window.atob && window.atob.bind(window) || function(a) {
  var u = String(a).replace(/=+$/, "");
  if (u.length % 4 == 1)
    throw new e("'atob' failed: The string to be decoded is not correctly encoded.");
  for (var c, l, v = 0, p = 0, _ = ""; l = u.charAt(p++); ~l && (c = v % 4 ? 64 * c + l : l, v++ % 4) ? _ += String.fromCharCode(255 & c >> (-2 * v & 6)) : 0)
    l = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(l);
  return _;
};
function t(a) {
  var u = a.replace(/-/g, "+").replace(/_/g, "/");
  switch (u.length % 4) {
    case 0:
      break;
    case 2:
      u += "==";
      break;
    case 3:
      u += "=";
      break;
    default:
      throw "Illegal base64url string!";
  }
  try {
    return function(c) {
      return decodeURIComponent(r$2(c).replace(/(.)/g, function(l, v) {
        var p = v.charCodeAt(0).toString(16).toUpperCase();
        return p.length < 2 && (p = "0" + p), "%" + p;
      }));
    }(u);
  } catch {
    return r$2(u);
  }
}
function n(a) {
  this.message = a;
}
function o(a, u) {
  if (typeof a != "string")
    throw new n("Invalid token specified");
  var c = (u = u || {}).header === !0 ? 0 : 1;
  try {
    return JSON.parse(t(a.split(".")[c]));
  } catch (l) {
    throw new n("Invalid token specified: " + l.message);
  }
}
n.prototype = new Error(), n.prototype.name = "InvalidTokenError";
const jwtDecode_esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  InvalidTokenError: n,
  default: o
}, Symbol.toStringTag, { value: "Module" })), require$$0$3 = /* @__PURE__ */ getAugmentedNamespace(jwtDecode_esm);
var getRandomValues, rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues && (getRandomValues = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto < "u" && typeof msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto), !getRandomValues))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return getRandomValues(rnds8);
}
const REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function validate$2(a) {
  return typeof a == "string" && REGEX.test(a);
}
var byteToHex = [];
for (var i$2 = 0; i$2 < 256; ++i$2)
  byteToHex.push((i$2 + 256).toString(16).substr(1));
function stringify(a) {
  var u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, c = (byteToHex[a[u + 0]] + byteToHex[a[u + 1]] + byteToHex[a[u + 2]] + byteToHex[a[u + 3]] + "-" + byteToHex[a[u + 4]] + byteToHex[a[u + 5]] + "-" + byteToHex[a[u + 6]] + byteToHex[a[u + 7]] + "-" + byteToHex[a[u + 8]] + byteToHex[a[u + 9]] + "-" + byteToHex[a[u + 10]] + byteToHex[a[u + 11]] + byteToHex[a[u + 12]] + byteToHex[a[u + 13]] + byteToHex[a[u + 14]] + byteToHex[a[u + 15]]).toLowerCase();
  if (!validate$2(c))
    throw TypeError("Stringified UUID is invalid");
  return c;
}
var _nodeId, _clockseq, _lastMSecs = 0, _lastNSecs = 0;
function v1(a, u, c) {
  var l = u && c || 0, v = u || new Array(16);
  a = a || {};
  var p = a.node || _nodeId, _ = a.clockseq !== void 0 ? a.clockseq : _clockseq;
  if (p == null || _ == null) {
    var k = a.random || (a.rng || rng)();
    p == null && (p = _nodeId = [k[0] | 1, k[1], k[2], k[3], k[4], k[5]]), _ == null && (_ = _clockseq = (k[6] << 8 | k[7]) & 16383);
  }
  var M = a.msecs !== void 0 ? a.msecs : Date.now(), L = a.nsecs !== void 0 ? a.nsecs : _lastNSecs + 1, F = M - _lastMSecs + (L - _lastNSecs) / 1e4;
  if (F < 0 && a.clockseq === void 0 && (_ = _ + 1 & 16383), (F < 0 || M > _lastMSecs) && a.nsecs === void 0 && (L = 0), L >= 1e4)
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  _lastMSecs = M, _lastNSecs = L, _clockseq = _, M += 122192928e5;
  var V = ((M & 268435455) * 1e4 + L) % 4294967296;
  v[l++] = V >>> 24 & 255, v[l++] = V >>> 16 & 255, v[l++] = V >>> 8 & 255, v[l++] = V & 255;
  var X = M / 4294967296 * 1e4 & 268435455;
  v[l++] = X >>> 8 & 255, v[l++] = X & 255, v[l++] = X >>> 24 & 15 | 16, v[l++] = X >>> 16 & 255, v[l++] = _ >>> 8 | 128, v[l++] = _ & 255;
  for (var oe = 0; oe < 6; ++oe)
    v[l + oe] = p[oe];
  return u || stringify(v);
}
function parse$3(a) {
  if (!validate$2(a))
    throw TypeError("Invalid UUID");
  var u, c = new Uint8Array(16);
  return c[0] = (u = parseInt(a.slice(0, 8), 16)) >>> 24, c[1] = u >>> 16 & 255, c[2] = u >>> 8 & 255, c[3] = u & 255, c[4] = (u = parseInt(a.slice(9, 13), 16)) >>> 8, c[5] = u & 255, c[6] = (u = parseInt(a.slice(14, 18), 16)) >>> 8, c[7] = u & 255, c[8] = (u = parseInt(a.slice(19, 23), 16)) >>> 8, c[9] = u & 255, c[10] = (u = parseInt(a.slice(24, 36), 16)) / 1099511627776 & 255, c[11] = u / 4294967296 & 255, c[12] = u >>> 24 & 255, c[13] = u >>> 16 & 255, c[14] = u >>> 8 & 255, c[15] = u & 255, c;
}
function stringToBytes(a) {
  a = unescape(encodeURIComponent(a));
  for (var u = [], c = 0; c < a.length; ++c)
    u.push(a.charCodeAt(c));
  return u;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8", URL$1 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35(a, u, c) {
  function l(v, p, _, k) {
    if (typeof v == "string" && (v = stringToBytes(v)), typeof p == "string" && (p = parse$3(p)), p.length !== 16)
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    var M = new Uint8Array(16 + v.length);
    if (M.set(p), M.set(v, p.length), M = c(M), M[6] = M[6] & 15 | u, M[8] = M[8] & 63 | 128, _) {
      k = k || 0;
      for (var L = 0; L < 16; ++L)
        _[k + L] = M[L];
      return _;
    }
    return stringify(M);
  }
  try {
    l.name = a;
  } catch {
  }
  return l.DNS = DNS, l.URL = URL$1, l;
}
function md5$3(a) {
  if (typeof a == "string") {
    var u = unescape(encodeURIComponent(a));
    a = new Uint8Array(u.length);
    for (var c = 0; c < u.length; ++c)
      a[c] = u.charCodeAt(c);
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(a), a.length * 8));
}
function md5ToHexEncodedArray(a) {
  for (var u = [], c = a.length * 32, l = "0123456789abcdef", v = 0; v < c; v += 8) {
    var p = a[v >> 5] >>> v % 32 & 255, _ = parseInt(l.charAt(p >>> 4 & 15) + l.charAt(p & 15), 16);
    u.push(_);
  }
  return u;
}
function getOutputLength(a) {
  return (a + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(a, u) {
  a[u >> 5] |= 128 << u % 32, a[getOutputLength(u) - 1] = u;
  for (var c = 1732584193, l = -271733879, v = -1732584194, p = 271733878, _ = 0; _ < a.length; _ += 16) {
    var k = c, M = l, L = v, F = p;
    c = md5ff(c, l, v, p, a[_], 7, -680876936), p = md5ff(p, c, l, v, a[_ + 1], 12, -389564586), v = md5ff(v, p, c, l, a[_ + 2], 17, 606105819), l = md5ff(l, v, p, c, a[_ + 3], 22, -1044525330), c = md5ff(c, l, v, p, a[_ + 4], 7, -176418897), p = md5ff(p, c, l, v, a[_ + 5], 12, 1200080426), v = md5ff(v, p, c, l, a[_ + 6], 17, -1473231341), l = md5ff(l, v, p, c, a[_ + 7], 22, -45705983), c = md5ff(c, l, v, p, a[_ + 8], 7, 1770035416), p = md5ff(p, c, l, v, a[_ + 9], 12, -1958414417), v = md5ff(v, p, c, l, a[_ + 10], 17, -42063), l = md5ff(l, v, p, c, a[_ + 11], 22, -1990404162), c = md5ff(c, l, v, p, a[_ + 12], 7, 1804603682), p = md5ff(p, c, l, v, a[_ + 13], 12, -40341101), v = md5ff(v, p, c, l, a[_ + 14], 17, -1502002290), l = md5ff(l, v, p, c, a[_ + 15], 22, 1236535329), c = md5gg(c, l, v, p, a[_ + 1], 5, -165796510), p = md5gg(p, c, l, v, a[_ + 6], 9, -1069501632), v = md5gg(v, p, c, l, a[_ + 11], 14, 643717713), l = md5gg(l, v, p, c, a[_], 20, -373897302), c = md5gg(c, l, v, p, a[_ + 5], 5, -701558691), p = md5gg(p, c, l, v, a[_ + 10], 9, 38016083), v = md5gg(v, p, c, l, a[_ + 15], 14, -660478335), l = md5gg(l, v, p, c, a[_ + 4], 20, -405537848), c = md5gg(c, l, v, p, a[_ + 9], 5, 568446438), p = md5gg(p, c, l, v, a[_ + 14], 9, -1019803690), v = md5gg(v, p, c, l, a[_ + 3], 14, -187363961), l = md5gg(l, v, p, c, a[_ + 8], 20, 1163531501), c = md5gg(c, l, v, p, a[_ + 13], 5, -1444681467), p = md5gg(p, c, l, v, a[_ + 2], 9, -51403784), v = md5gg(v, p, c, l, a[_ + 7], 14, 1735328473), l = md5gg(l, v, p, c, a[_ + 12], 20, -1926607734), c = md5hh(c, l, v, p, a[_ + 5], 4, -378558), p = md5hh(p, c, l, v, a[_ + 8], 11, -2022574463), v = md5hh(v, p, c, l, a[_ + 11], 16, 1839030562), l = md5hh(l, v, p, c, a[_ + 14], 23, -35309556), c = md5hh(c, l, v, p, a[_ + 1], 4, -1530992060), p = md5hh(p, c, l, v, a[_ + 4], 11, 1272893353), v = md5hh(v, p, c, l, a[_ + 7], 16, -155497632), l = md5hh(l, v, p, c, a[_ + 10], 23, -1094730640), c = md5hh(c, l, v, p, a[_ + 13], 4, 681279174), p = md5hh(p, c, l, v, a[_], 11, -358537222), v = md5hh(v, p, c, l, a[_ + 3], 16, -722521979), l = md5hh(l, v, p, c, a[_ + 6], 23, 76029189), c = md5hh(c, l, v, p, a[_ + 9], 4, -640364487), p = md5hh(p, c, l, v, a[_ + 12], 11, -421815835), v = md5hh(v, p, c, l, a[_ + 15], 16, 530742520), l = md5hh(l, v, p, c, a[_ + 2], 23, -995338651), c = md5ii(c, l, v, p, a[_], 6, -198630844), p = md5ii(p, c, l, v, a[_ + 7], 10, 1126891415), v = md5ii(v, p, c, l, a[_ + 14], 15, -1416354905), l = md5ii(l, v, p, c, a[_ + 5], 21, -57434055), c = md5ii(c, l, v, p, a[_ + 12], 6, 1700485571), p = md5ii(p, c, l, v, a[_ + 3], 10, -1894986606), v = md5ii(v, p, c, l, a[_ + 10], 15, -1051523), l = md5ii(l, v, p, c, a[_ + 1], 21, -2054922799), c = md5ii(c, l, v, p, a[_ + 8], 6, 1873313359), p = md5ii(p, c, l, v, a[_ + 15], 10, -30611744), v = md5ii(v, p, c, l, a[_ + 6], 15, -1560198380), l = md5ii(l, v, p, c, a[_ + 13], 21, 1309151649), c = md5ii(c, l, v, p, a[_ + 4], 6, -145523070), p = md5ii(p, c, l, v, a[_ + 11], 10, -1120210379), v = md5ii(v, p, c, l, a[_ + 2], 15, 718787259), l = md5ii(l, v, p, c, a[_ + 9], 21, -343485551), c = safeAdd(c, k), l = safeAdd(l, M), v = safeAdd(v, L), p = safeAdd(p, F);
  }
  return [c, l, v, p];
}
function bytesToWords(a) {
  if (a.length === 0)
    return [];
  for (var u = a.length * 8, c = new Uint32Array(getOutputLength(u)), l = 0; l < u; l += 8)
    c[l >> 5] |= (a[l / 8] & 255) << l % 32;
  return c;
}
function safeAdd(a, u) {
  var c = (a & 65535) + (u & 65535), l = (a >> 16) + (u >> 16) + (c >> 16);
  return l << 16 | c & 65535;
}
function bitRotateLeft(a, u) {
  return a << u | a >>> 32 - u;
}
function md5cmn(a, u, c, l, v, p) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(u, a), safeAdd(l, p)), v), c);
}
function md5ff(a, u, c, l, v, p, _) {
  return md5cmn(u & c | ~u & l, a, u, v, p, _);
}
function md5gg(a, u, c, l, v, p, _) {
  return md5cmn(u & l | c & ~l, a, u, v, p, _);
}
function md5hh(a, u, c, l, v, p, _) {
  return md5cmn(u ^ c ^ l, a, u, v, p, _);
}
function md5ii(a, u, c, l, v, p, _) {
  return md5cmn(c ^ (u | ~l), a, u, v, p, _);
}
var v3 = v35("v3", 48, md5$3);
const v3$1 = v3;
function v4(a, u, c) {
  a = a || {};
  var l = a.random || (a.rng || rng)();
  if (l[6] = l[6] & 15 | 64, l[8] = l[8] & 63 | 128, u) {
    c = c || 0;
    for (var v = 0; v < 16; ++v)
      u[c + v] = l[v];
    return u;
  }
  return stringify(l);
}
function f$1(a, u, c, l) {
  switch (a) {
    case 0:
      return u & c ^ ~u & l;
    case 1:
      return u ^ c ^ l;
    case 2:
      return u & c ^ u & l ^ c & l;
    case 3:
      return u ^ c ^ l;
  }
}
function ROTL(a, u) {
  return a << u | a >>> 32 - u;
}
function sha1$1(a) {
  var u = [1518500249, 1859775393, 2400959708, 3395469782], c = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof a == "string") {
    var l = unescape(encodeURIComponent(a));
    a = [];
    for (var v = 0; v < l.length; ++v)
      a.push(l.charCodeAt(v));
  } else
    Array.isArray(a) || (a = Array.prototype.slice.call(a));
  a.push(128);
  for (var p = a.length / 4 + 2, _ = Math.ceil(p / 16), k = new Array(_), M = 0; M < _; ++M) {
    for (var L = new Uint32Array(16), F = 0; F < 16; ++F)
      L[F] = a[M * 64 + F * 4] << 24 | a[M * 64 + F * 4 + 1] << 16 | a[M * 64 + F * 4 + 2] << 8 | a[M * 64 + F * 4 + 3];
    k[M] = L;
  }
  k[_ - 1][14] = (a.length - 1) * 8 / Math.pow(2, 32), k[_ - 1][14] = Math.floor(k[_ - 1][14]), k[_ - 1][15] = (a.length - 1) * 8 & 4294967295;
  for (var V = 0; V < _; ++V) {
    for (var X = new Uint32Array(80), oe = 0; oe < 16; ++oe)
      X[oe] = k[V][oe];
    for (var Y = 16; Y < 80; ++Y)
      X[Y] = ROTL(X[Y - 3] ^ X[Y - 8] ^ X[Y - 14] ^ X[Y - 16], 1);
    for (var ae = c[0], ne = c[1], fe = c[2], ie = c[3], ge = c[4], be = 0; be < 80; ++be) {
      var Ce = Math.floor(be / 20), Me = ROTL(ae, 5) + f$1(Ce, ne, fe, ie) + ge + u[Ce] + X[be] >>> 0;
      ge = ie, ie = fe, fe = ROTL(ne, 30) >>> 0, ne = ae, ae = Me;
    }
    c[0] = c[0] + ae >>> 0, c[1] = c[1] + ne >>> 0, c[2] = c[2] + fe >>> 0, c[3] = c[3] + ie >>> 0, c[4] = c[4] + ge >>> 0;
  }
  return [c[0] >> 24 & 255, c[0] >> 16 & 255, c[0] >> 8 & 255, c[0] & 255, c[1] >> 24 & 255, c[1] >> 16 & 255, c[1] >> 8 & 255, c[1] & 255, c[2] >> 24 & 255, c[2] >> 16 & 255, c[2] >> 8 & 255, c[2] & 255, c[3] >> 24 & 255, c[3] >> 16 & 255, c[3] >> 8 & 255, c[3] & 255, c[4] >> 24 & 255, c[4] >> 16 & 255, c[4] >> 8 & 255, c[4] & 255];
}
var v5 = v35("v5", 80, sha1$1);
const v5$1 = v5, nil = "00000000-0000-0000-0000-000000000000";
function version$5(a) {
  if (!validate$2(a))
    throw TypeError("Invalid UUID");
  return parseInt(a.substr(14, 1), 16);
}
const esmBrowser = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  NIL: nil,
  parse: parse$3,
  stringify,
  v1,
  v3: v3$1,
  v4,
  v5: v5$1,
  validate: validate$2,
  version: version$5
}, Symbol.toStringTag, { value: "Module" })), require$$1$6 = /* @__PURE__ */ getAugmentedNamespace(esmBrowser);
let EnhancedMap$1 = class extends Map {
  /**
   * If key has a mapping already returns the currently associated value. If
   * there is no mapping, calls the computer which must return a value V.
   * The value is then stored for given key and returned.
   * @param key Key
   * @param computer Computer which is called only if key has no mapping yet.
   * @return Existing value if the key already existed, or the newly computed value.
   */
  computeIfAbsent(u, c) {
    if (this.has(u))
      return this.get(u);
    const l = c(u);
    return this.set(u, l), l;
  }
  /**
   * If the key exists already calls given computer, if the key does not exist
   * this method does nothing.
   *
   * The computer is called with current key and current value associated. The
   * computer can return a (new) value V or undefined. When undefined is returned
   * the key is removed from this map, when a V is returned the key is updated
   * with the new value V.
   * @param key Key
   * @param computer Computer which is called only if the key has a mapping already
   * @return Undefined if the key has no mapping, otherwise the value returned from computer
   */
  computeIfPresent(u, c) {
    const l = this.get(u);
    if (l === void 0)
      return;
    const v = c(u, l);
    return v !== void 0 ? this.set(u, v) : this.delete(u), v;
  }
  /**
   * Computes a value for given key, the computer can return a value V (in which case the map
   * will set the value for given key), if it returns undefined the mapping for key K will be
   * removed.
   * @param key Key to compute
   * @param computer Computer which is called, note that the currentValue argument contains the existing
   *                 value or is undefined when no mapping exists for the key.
   * @return The newly computed value
   */
  compute(u, c) {
    const l = this.get(u), v = c(u, l);
    return v ? this.set(u, v) : this.delete(u), v;
  }
};
var InternalLogLevel$1;
(function(a) {
  a[a.Trace = 0] = "Trace", a[a.Debug = 1] = "Debug", a[a.Info = 2] = "Info", a[a.Warn = 3] = "Warn", a[a.Error = 4] = "Error";
})(InternalLogLevel$1 || (InternalLogLevel$1 = {}));
function getInternalLogger$1(a) {
  return provider$1.getLogger(a);
}
const INTERNAL_LOGGING_SETTINGS$1 = {
  /**
   * Changes the log level for the internal logging (for all new and existing loggers)
   * @param level New log level
   */
  setInternalLogLevel: (a) => provider$1.changeLogLevel(a),
  /**
   * Changes where messages are written to for all new and existing loggers),
   * by default they are written to the console.
   * @param fnOutput Function to write messages to
   */
  setOutput: (a) => provider$1.changeOutput(a),
  /**
   * Resets the log level and output back to defaults (level to error and writing to console)
   * for all new and existing loggers.
   */
  reset: () => provider$1.reset()
};
let InternalLoggerImpl$1 = class {
  constructor(u, c, l) {
    this._name = u, this._level = c, this._fnOutput = l;
  }
  trace(u) {
    this.log(InternalLogLevel$1.Trace, u);
  }
  debug(u) {
    this.log(InternalLogLevel$1.Debug, u);
  }
  error(u, c) {
    this.log(InternalLogLevel$1.Error, u, c);
  }
  info(u) {
    this.log(InternalLogLevel$1.Info, u);
  }
  warn(u, c) {
    this.log(InternalLogLevel$1.Warn, u, c);
  }
  setLevel(u) {
    this._level = u;
  }
  setOutput(u) {
    this._fnOutput = u;
  }
  log(u, c, l) {
    this._level > u || this._fnOutput(`${InternalLogLevel$1[this._level].toString()} <INTERNAL LOGGER> ${this._name} ${c()}${l ? `
` + l.stack : ""}`);
  }
}, InternalProviderImpl$1 = class Zt {
  constructor() {
    this._loggers = new EnhancedMap$1(), this._logLevel = InternalLogLevel$1.Error, this._fnOutput = Zt.logConsole;
  }
  getLogger(u) {
    return this._loggers.computeIfAbsent(u, (c) => new InternalLoggerImpl$1(c, this._logLevel, this._fnOutput));
  }
  changeLogLevel(u) {
    this._logLevel = u, this._loggers.forEach((c) => c.setLevel(u));
  }
  changeOutput(u) {
    this._fnOutput = u, this._loggers.forEach((c) => c.setOutput(this._fnOutput));
  }
  reset() {
    this.changeLogLevel(InternalLogLevel$1.Error), this._fnOutput = Zt.logConsole, this._loggers.forEach((u) => u.setOutput(this._fnOutput));
  }
  static logConsole(u) {
    console && console.log && console.log(u);
  }
};
const provider$1 = new InternalProviderImpl$1();
var InternalLogger$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  get InternalLogLevel() {
    return InternalLogLevel$1;
  },
  getInternalLogger: getInternalLogger$1,
  INTERNAL_LOGGING_SETTINGS: INTERNAL_LOGGING_SETTINGS$1
}), LogLevel$2;
(function(a) {
  a[a.Trace = 0] = "Trace", a[a.Debug = 1] = "Debug", a[a.Info = 2] = "Info", a[a.Warn = 3] = "Warn", a[a.Error = 4] = "Error", a[a.Fatal = 5] = "Fatal";
})(LogLevel$2 || (LogLevel$2 = {}));
(function(a) {
  function u(c) {
    switch (c.toLowerCase()) {
      case "trace":
        return a.Trace;
      case "debug":
        return a.Debug;
      case "info":
        return a.Info;
      case "warn":
        return a.Warn;
      case "error":
        return a.Error;
      case "fatal":
        return a.Fatal;
      default:
        return;
    }
  }
  a.toLogLevel = u;
})(LogLevel$2 || (LogLevel$2 = {}));
let CoreLoggerImpl$1 = class Ai {
  constructor(u) {
    this._runtime = u;
  }
  get id() {
    return this._runtime.id;
  }
  get logLevel() {
    return this._runtime.level;
  }
  get runtimeSettings() {
    return Object.assign({}, this._runtime);
  }
  set runtimeSettings(u) {
    this._runtime = u;
  }
  trace(u, ...c) {
    this.logMessage(LogLevel$2.Trace, u, c);
  }
  debug(u, ...c) {
    this.logMessage(LogLevel$2.Debug, u, c);
  }
  info(u, ...c) {
    this.logMessage(LogLevel$2.Info, u, c);
  }
  warn(u, ...c) {
    this.logMessage(LogLevel$2.Warn, u, c);
  }
  error(u, ...c) {
    this.logMessage(LogLevel$2.Error, u, c);
  }
  fatal(u, ...c) {
    this.logMessage(LogLevel$2.Fatal, u, c);
  }
  logMessage(u, c, l) {
    if (this._runtime.level > u)
      return;
    const v = Date.now(), p = typeof c == "string" ? c : c(), _ = Ai.getErrorAndArgs(l);
    switch (this._runtime.channel.type) {
      case "RawLogChannel":
        this._runtime.channel.write({
          message: p,
          exception: _.error,
          args: _.args,
          timeInMillis: v,
          level: u,
          logNames: this._runtime.name
        }, this._runtime.argumentFormatter);
        return;
      case "LogChannel":
        this._runtime.channel.write(this.createLogMessage(p, u, _, v));
        break;
    }
  }
  formatArgValue(u) {
    try {
      return this._runtime.argumentFormatter(u);
    } catch {
      return `>>ARG CONVERT FAILED: '${u !== void 0 ? u.toString() : "undefined"}'<<`;
    }
  }
  createLogMessage(u, c, l, v) {
    let p;
    const _ = l.error, k = l.args;
    _ && (p = `${_.name}: ${_.message}`, _.stack && (p += `@
${_.stack}`));
    const M = this._runtime.dateFormatter(v);
    let L = LogLevel$2[c].toUpperCase();
    L.length < 5 && (L += " ");
    const F = typeof this._runtime.name == "string" ? this._runtime.name : this._runtime.name.join(", "), V = typeof k < "u" && k.length > 0 ? " [" + k.map((oe) => this.formatArgValue(oe)).join(", ") + "]" : "";
    return {
      message: M + " " + L + " [" + F + "] " + u + V,
      error: p
    };
  }
  static getErrorAndArgs(u) {
    if (u.length === 0)
      return {};
    let c, l;
    const v = u[0];
    if (v instanceof Error)
      return c = v, l = u.length > 1 ? u.slice(1) : void 0, { error: c, args: l };
    if (typeof v == "function") {
      const p = v();
      return p instanceof Error ? (c = p, l = u.length > 1 ? u.slice(1) : void 0, { error: c, args: l }) : u.length === 1 ? Array.isArray(p) ? { args: p.length > 0 ? p : void 0 } : { args: p } : Array.isArray(p) ? { args: [...p, ...u.slice(1)] } : { args: [p, ...u.slice(1)] };
    }
    return { args: u };
  }
};
function padStart$1(a, u, c = " ") {
  return padInternal$1(a, u, "start", c);
}
function padEnd$1(a, u, c = " ") {
  return padInternal$1(a, u, "end", c);
}
function maxLengthStringValueInArray$1(a) {
  return a.map((u) => u.length).reduce((u, c) => c > u ? c : u, 0);
}
function padInternal$1(a, u, c, l = " ") {
  if (u <= a.length)
    return a;
  if (l.length > 1)
    throw new Error(`Fill char must be one char exactly, it is: ${l.length}`);
  const v = u - a.length;
  let p = "";
  for (let _ = 0; _ < v; _++)
    p += l;
  return c === "start" ? p + a : a + p;
}
function formatArgument$1(a) {
  return a === void 0 ? "undefined" : JSON.stringify(a);
}
function formatDate$1(a) {
  const u = new Date(a), c = u.getFullYear(), l = padStart$1((u.getMonth() + 1).toString(), 2, "0"), v = padStart$1(u.getDate().toString(), 2, "0"), p = padStart$1(u.getHours().toString(), 2, "0"), _ = padStart$1(u.getMinutes().toString(), 2, "0"), k = padStart$1(u.getSeconds().toString(), 2, "0"), M = padStart$1(u.getMilliseconds().toString(), 2, "0");
  return `${c}-${l}-${v} ${p}:${_}:${k},${M}`;
}
let ConsoleLogChannel$1 = class {
  constructor() {
    this.type = "LogChannel";
  }
  write(u) {
    console && console.log && console.log(u.message + (u.error ? `
${u.error}` : ""));
  }
};
var DefaultChannels$1;
(function(a) {
  function u() {
    return new ConsoleLogChannel$1();
  }
  a.createConsoleChannel = u;
})(DefaultChannels$1 || (DefaultChannels$1 = {}));
let LogProviderImpl$1 = class Wt {
  constructor(u, c) {
    this._log = getInternalLogger$1("core.impl.LogProviderImpl"), this._name = u, this._settings = c, this._loggers = new EnhancedMap$1(), this._idToKeyMap = new EnhancedMap$1(), this._globalRuntimeSettings = { level: c.level, channel: c.channel }, this._nextLoggerId = 1, this._log.trace(() => `Created LogProviderImpl with settings: ${JSON.stringify(this._settings)}`);
  }
  get runtimeSettings() {
    return Object.assign(Object.assign({}, this._settings), { level: this._globalRuntimeSettings.level, channel: this._globalRuntimeSettings.channel });
  }
  getLogger(u) {
    return this.getOrCreateLogger(u);
  }
  updateLoggerRuntime(u, c) {
    this._log.debug(() => `Updating logger ${u.id} runtime settings using: '${JSON.stringify(c)}'`);
    const l = this._idToKeyMap.get(u.id);
    return l === void 0 ? (this._log.warn(() => `Cannot update logger with id: ${u.id}, it was not found.`), !1) : (this._loggers.computeIfPresent(l, (v, p) => (p.runtimeSettings = Wt.mergeRuntimeSettingsIntoLogRuntime(p.runtimeSettings, c), p)), !0);
  }
  updateRuntimeSettings(u) {
    this._log.debug(() => `Updating global runtime settings and updating existing loggers runtime settings using: '${JSON.stringify(u)}'`), this._globalRuntimeSettings = {
      /* It's unclear, but not checking explicitly on undefined here makes the test fail, it makes no sense as level is a number | undefined essentially. */
      level: u.level !== void 0 ? u.level : this._globalRuntimeSettings.level,
      channel: u.channel !== void 0 ? u.channel : this._globalRuntimeSettings.channel
    }, this._loggers.forEach((c) => c.runtimeSettings = Wt.mergeRuntimeSettingsIntoLogRuntime(c.runtimeSettings, u));
  }
  /**
   * Removes all state and loggers, it reverts back to as it was after initial construction.
   */
  clear() {
    this._loggers.clear(), this._idToKeyMap.clear(), this._globalRuntimeSettings = Object.assign({}, this._settings), this._nextLoggerId = 1;
  }
  getOrCreateLogger(u) {
    const c = Wt.createKey(u), l = this._loggers.computeIfAbsent(c, () => {
      const v = {
        level: this._globalRuntimeSettings.level,
        channel: this._globalRuntimeSettings.channel,
        id: this.nextLoggerId(),
        name: u,
        argumentFormatter: this._settings.argumentFormatter,
        dateFormatter: this._settings.dateFormatter
      };
      return new CoreLoggerImpl$1(v);
    });
    return this._idToKeyMap.computeIfAbsent(l.id, () => c), l;
  }
  nextLoggerId() {
    const u = this._name + "_" + this._nextLoggerId;
    return this._nextLoggerId++, u;
  }
  static mergeRuntimeSettingsIntoLogRuntime(u, c) {
    return Object.assign(Object.assign({}, u), {
      /* It's unclear, but not checking explicitly on undefined here makes the test fail, it makes no sense as level is a number | undefined essentially. */
      level: c.level !== void 0 ? c.level : u.level,
      channel: c.channel !== void 0 ? c.channel : u.channel
    });
  }
  static createKey(u) {
    return typeof u == "string" ? u : u.join(",");
  }
};
function createLogProvider$1(a, u) {
  return new LogProviderImpl$1(a, u);
}
var index$4 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  EnhancedMap: EnhancedMap$1,
  padStart: padStart$1,
  padEnd: padEnd$1,
  maxLengthStringValueInArray: maxLengthStringValueInArray$1
});
class ArrayLogChannel {
  constructor() {
    this._buffer = [], this.type = "LogChannel";
  }
  write(u) {
    this._buffer.push(u);
  }
  get logMessages() {
    return this._buffer;
  }
  get messages() {
    return this._buffer.map((u) => u.message);
  }
}
class ArrayRawLogChannel {
  constructor() {
    this._buffer = [], this.type = "RawLogChannel";
  }
  write(u, c) {
    this._buffer.push(u);
  }
  get messages() {
    return this._buffer.map((u) => u.message);
  }
  get errors() {
    return this._buffer.map((u) => u.exception);
  }
  get size() {
    return this._buffer.length;
  }
  get rawMessages() {
    return this._buffer;
  }
  clear() {
    this._buffer = [];
  }
}
class TestControlMessage {
  constructor() {
    this._messages = [], this.write = this.write.bind(this);
  }
  get messages() {
    return this._messages;
  }
  write(u) {
    this._messages.push(u);
  }
  clear() {
    this._messages = [];
  }
}
var TestClasses = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArrayLogChannel,
  ArrayRawLogChannel,
  TestControlMessage
});
const typescriptLogging_esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  $internal: InternalLogger$1,
  $test: TestClasses,
  get DefaultChannels() {
    return DefaultChannels$1;
  },
  get LogLevel() {
    return LogLevel$2;
  },
  createLogProvider: createLogProvider$1,
  formatArgument: formatArgument$1,
  formatDate: formatDate$1,
  util: index$4
}, Symbol.toStringTag, { value: "Module" })), require$$2$1 = /* @__PURE__ */ getAugmentedNamespace(typescriptLogging_esm);
var layoutapi = {}, lib$1 = {}, lib = {}, Metadata = {};
Object.defineProperty(Metadata, "__esModule", { value: !0 });
Metadata.Metadata = void 0;
Metadata.Metadata = function(u) {
  const c = /* @__PURE__ */ new Map(), l = {
    set(v, p) {
      if (v = normalizeKey(v), Array.isArray(p))
        if (p.length === 0)
          c.delete(v);
        else {
          for (const _ of p)
            validate$1(v, _);
          c.set(v, v.endsWith("-bin") ? p : [p.join(", ")]);
        }
      else
        validate$1(v, p), c.set(v, [p]);
      return l;
    },
    append(v, p) {
      v = normalizeKey(v), validate$1(v, p);
      let _ = c.get(v);
      return _ == null && (_ = [], c.set(v, _)), _.push(p), v.endsWith("-bin") || c.set(v, [_.join(", ")]), l;
    },
    delete(v) {
      v = normalizeKey(v), c.delete(v);
    },
    get(v) {
      var p;
      return v = normalizeKey(v), (p = c.get(v)) === null || p === void 0 ? void 0 : p[0];
    },
    getAll(v) {
      var p;
      return v = normalizeKey(v), (p = c.get(v)) !== null && p !== void 0 ? p : [];
    },
    has(v) {
      return v = normalizeKey(v), c.has(v);
    },
    [Symbol.iterator]() {
      return c[Symbol.iterator]();
    }
  };
  if (u != null) {
    const v = isIterable$1(u) ? u : Object.entries(u);
    for (const [p, _] of v)
      l.set(p, _);
  }
  return l;
};
function normalizeKey(a) {
  return a.toLowerCase();
}
function validate$1(a, u) {
  if (!/^[0-9a-z_.-]+$/.test(a))
    throw new Error(`Metadata key '${a}' contains illegal characters`);
  if (a.endsWith("-bin")) {
    if (!(u instanceof Uint8Array))
      throw new Error(`Metadata key '${a}' ends with '-bin', thus it must have binary value`);
  } else {
    if (typeof u != "string")
      throw new Error(`Metadata key '${a}' doesn't end with '-bin', thus it must have string value`);
    if (!/^[ -~]*$/.test(u))
      throw new Error(`Metadata value '${u}' of key '${a}' contains illegal characters`);
  }
}
function isIterable$1(a) {
  return Symbol.iterator in a;
}
var Status = {};
(function(a) {
  Object.defineProperty(a, "__esModule", { value: !0 }), a.Status = void 0, function(u) {
    u[u.OK = 0] = "OK", u[u.CANCELLED = 1] = "CANCELLED", u[u.UNKNOWN = 2] = "UNKNOWN", u[u.INVALID_ARGUMENT = 3] = "INVALID_ARGUMENT", u[u.DEADLINE_EXCEEDED = 4] = "DEADLINE_EXCEEDED", u[u.NOT_FOUND = 5] = "NOT_FOUND", u[u.ALREADY_EXISTS = 6] = "ALREADY_EXISTS", u[u.PERMISSION_DENIED = 7] = "PERMISSION_DENIED", u[u.RESOURCE_EXHAUSTED = 8] = "RESOURCE_EXHAUSTED", u[u.FAILED_PRECONDITION = 9] = "FAILED_PRECONDITION", u[u.ABORTED = 10] = "ABORTED", u[u.OUT_OF_RANGE = 11] = "OUT_OF_RANGE", u[u.UNIMPLEMENTED = 12] = "UNIMPLEMENTED", u[u.INTERNAL = 13] = "INTERNAL", u[u.UNAVAILABLE = 14] = "UNAVAILABLE", u[u.DATA_LOSS = 15] = "DATA_LOSS", u[u.UNAUTHENTICATED = 16] = "UNAUTHENTICATED";
  }(a.Status || (a.Status = {}));
})(Status);
var MethodDescriptor = {};
Object.defineProperty(MethodDescriptor, "__esModule", { value: !0 });
var CallOptions = {};
Object.defineProperty(CallOptions, "__esModule", { value: !0 });
var ClientMiddleware = {};
Object.defineProperty(ClientMiddleware, "__esModule", { value: !0 });
var composeClientMiddleware$1 = {};
Object.defineProperty(composeClientMiddleware$1, "__esModule", { value: !0 });
composeClientMiddleware$1.composeClientMiddleware = void 0;
function composeClientMiddleware(a, u) {
  return (c, l) => u(Object.assign(Object.assign({}, c), { next: (v, p) => a(Object.assign(Object.assign({}, c), { request: v }), p) }), l);
}
composeClientMiddleware$1.composeClientMiddleware = composeClientMiddleware;
var ClientError$1 = {}, cjs = {}, helpers = {};
helpers.__esModule = void 0;
helpers.__esModule = !0;
var objectSetPrototypeOfIsDefined = typeof Object.setPrototypeOf == "function", objectGetPrototypeOfIsDefined = typeof Object.getPrototypeOf == "function", objectDefinePropertyIsDefined = typeof Object.defineProperty == "function", objectCreateIsDefined = typeof Object.create == "function", objectHasOwnPropertyIsDefined = typeof Object.prototype.hasOwnProperty == "function", setPrototypeOf = function(u, c) {
  objectSetPrototypeOfIsDefined ? Object.setPrototypeOf(u, c) : u.__proto__ = c;
};
helpers.setPrototypeOf = setPrototypeOf;
var getPrototypeOf$1 = function(u) {
  return objectGetPrototypeOfIsDefined ? Object.getPrototypeOf(u) : u.__proto__ || u.prototype;
};
helpers.getPrototypeOf = getPrototypeOf$1;
var ie8ObjectDefinePropertyBug = !1, defineProperty$1 = function a(u, c, l) {
  if (objectDefinePropertyIsDefined && !ie8ObjectDefinePropertyBug)
    try {
      Object.defineProperty(u, c, l);
    } catch {
      ie8ObjectDefinePropertyBug = !0, a(u, c, l);
    }
  else
    u[c] = l.value;
};
helpers.defineProperty = defineProperty$1;
var hasOwnProperty$g = function(u, c) {
  return objectHasOwnPropertyIsDefined ? u.hasOwnProperty(u, c) : u[c] === void 0;
};
helpers.hasOwnProperty = hasOwnProperty$g;
var objectCreate$1 = function(u, c) {
  if (objectCreateIsDefined)
    return Object.create(u, c);
  var l = function() {
  };
  l.prototype = u;
  var v = new l();
  if (typeof c > "u")
    return v;
  if (typeof c == "null")
    throw new Error("PropertyDescriptors must not be null.");
  if (typeof c == "object")
    for (var p in c)
      hasOwnProperty$g(c, p) && (v[p] = c[p].value);
  return v;
};
helpers.objectCreate = objectCreate$1;
(function(a) {
  a.__esModule = void 0, a.__esModule = !0;
  var u = helpers, c = u.setPrototypeOf, l = u.getPrototypeOf, v = u.defineProperty, p = u.objectCreate, _ = new Error().toString() === "[object Error]", k = "";
  function M(L) {
    var F = this.constructor, V = F.name || function() {
      var ne = F.toString().match(/^function\s*([^\s(]+)/);
      return ne === null ? k || "Error" : ne[1];
    }(), X = V === "Error", oe = X ? k : V, Y = Error.apply(this, arguments);
    if (c(Y, l(this)), !(Y instanceof F) || !(Y instanceof M)) {
      var Y = this;
      Error.apply(this, arguments), v(Y, "message", {
        configurable: !0,
        enumerable: !1,
        value: L,
        writable: !0
      });
    }
    if (v(Y, "name", {
      configurable: !0,
      enumerable: !1,
      value: oe,
      writable: !0
    }), Error.captureStackTrace && Error.captureStackTrace(
      Y,
      X ? M : F
    ), Y.stack === void 0) {
      var ae = new Error(L);
      ae.name = Y.name, Y.stack = ae.stack;
    }
    return _ && v(Y, "toString", {
      configurable: !0,
      enumerable: !1,
      value: function() {
        return (this.name || "Error") + (typeof this.message > "u" ? "" : ": " + this.message);
      },
      writable: !0
    }), Y;
  }
  k = M.name || "ExtendableError", M.prototype = p(Error.prototype, {
    constructor: {
      value: Error,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }), a.ExtendableError = M, a.default = a.ExtendableError;
})(cjs);
Object.defineProperty(ClientError$1, "__esModule", { value: !0 });
ClientError$1.ClientError = void 0;
const ts_error_1$1 = cjs, Status_1$1 = Status;
class ClientError extends ts_error_1$1.ExtendableError {
  constructor(u, c, l) {
    super(`${u} ${Status_1$1.Status[c]}: ${l}`), this.path = u, this.code = c, this.details = l, this.name = "ClientError", Object.defineProperty(this, "@@nice-grpc", {
      value: !0
    }), Object.defineProperty(this, "@@nice-grpc:ClientError", {
      value: !0
    });
  }
  static [Symbol.hasInstance](u) {
    return this !== ClientError ? this.prototype.isPrototypeOf(u) : typeof u == "object" && u !== null && (u.constructor === ClientError || u["@@nice-grpc:ClientError"] === !0 || u.name === "ClientError" && u["@@nice-grpc"] === !0);
  }
}
ClientError$1.ClientError = ClientError;
var CallContext = {};
Object.defineProperty(CallContext, "__esModule", { value: !0 });
var ServerMiddleware = {};
Object.defineProperty(ServerMiddleware, "__esModule", { value: !0 });
var composeServerMiddleware$1 = {};
Object.defineProperty(composeServerMiddleware$1, "__esModule", { value: !0 });
composeServerMiddleware$1.composeServerMiddleware = void 0;
function composeServerMiddleware(a, u) {
  return (c, l) => a(Object.assign(Object.assign({}, c), { next: (v, p) => u(Object.assign(Object.assign({}, c), { request: v }), p) }), l);
}
composeServerMiddleware$1.composeServerMiddleware = composeServerMiddleware;
var ServerError$1 = {};
Object.defineProperty(ServerError$1, "__esModule", { value: !0 });
ServerError$1.ServerError = void 0;
const ts_error_1 = cjs, Status_1 = Status;
class ServerError extends ts_error_1.ExtendableError {
  constructor(u, c) {
    super(`${Status_1.Status[u]}: ${c}`), this.code = u, this.details = c, this.name = "ServerError", Object.defineProperty(this, "@@nice-grpc", {
      value: !0
    }), Object.defineProperty(this, "@@nice-grpc:ServerError", {
      value: !0
    });
  }
  static [Symbol.hasInstance](u) {
    return this !== ServerError ? this.prototype.isPrototypeOf(u) : typeof u == "object" && u !== null && (u.constructor === ServerError || u["@@nice-grpc:ServerError"] === !0 || u.name === "ServerError" && u["@@nice-grpc"] === !0);
  }
}
ServerError$1.ServerError = ServerError;
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(l, v, p, _) {
    _ === void 0 && (_ = p);
    var k = Object.getOwnPropertyDescriptor(v, p);
    (!k || ("get" in k ? !v.__esModule : k.writable || k.configurable)) && (k = { enumerable: !0, get: function() {
      return v[p];
    } }), Object.defineProperty(l, _, k);
  } : function(l, v, p, _) {
    _ === void 0 && (_ = p), l[_] = v[p];
  }), c = commonjsGlobal$1 && commonjsGlobal$1.__exportStar || function(l, v) {
    for (var p in l)
      p !== "default" && !Object.prototype.hasOwnProperty.call(v, p) && u(v, l, p);
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), c(Metadata, a), c(Status, a), c(MethodDescriptor, a), c(CallOptions, a), c(ClientMiddleware, a), c(composeClientMiddleware$1, a), c(ClientError$1, a), c(CallContext, a), c(ServerMiddleware, a), c(composeServerMiddleware$1, a), c(ServerError$1, a);
})(lib);
var serviceDefinitions = {}, grpcWeb = {};
Object.defineProperty(grpcWeb, "__esModule", { value: !0 });
grpcWeb.isGrpcWebServiceDefinition = grpcWeb.fromGrpcWebServiceDefinition = void 0;
function fromGrpcWebServiceDefinition(a) {
  const u = {};
  for (const [c, l] of Object.entries(a)) {
    if (c === "serviceName")
      continue;
    const v = l;
    u[uncapitalize(c)] = {
      path: `/${a.serviceName}/${c}`,
      requestStream: v.requestStream,
      responseStream: v.responseStream,
      requestDeserialize: v.requestType.deserializeBinary,
      requestSerialize: (p) => p.serializeBinary(),
      responseDeserialize: v.responseType.deserializeBinary,
      responseSerialize: (p) => p.serializeBinary(),
      options: {}
    };
  }
  return u;
}
grpcWeb.fromGrpcWebServiceDefinition = fromGrpcWebServiceDefinition;
function isGrpcWebServiceDefinition(a) {
  return "prototype" in a;
}
grpcWeb.isGrpcWebServiceDefinition = isGrpcWebServiceDefinition;
function uncapitalize(a) {
  return a.length === 0 ? a : a[0].toLowerCase() + a.slice(1);
}
var tsProto = {};
Object.defineProperty(tsProto, "__esModule", { value: !0 });
tsProto.isTsProtoServiceDefinition = tsProto.fromTsProtoServiceDefinition = void 0;
function fromTsProtoServiceDefinition(a) {
  const u = {};
  for (const [c, l] of Object.entries(a.methods)) {
    const v = l.requestType.encode, p = l.requestType.fromPartial, _ = l.responseType.encode, k = l.responseType.fromPartial;
    u[c] = {
      path: `/${a.fullName}/${l.name}`,
      requestStream: l.requestStream,
      responseStream: l.responseStream,
      requestDeserialize: l.requestType.decode,
      requestSerialize: p != null ? (M) => v(p(M)).finish() : (M) => v(M).finish(),
      responseDeserialize: l.responseType.decode,
      responseSerialize: k != null ? (M) => _(k(M)).finish() : (M) => _(M).finish(),
      options: l.options
    };
  }
  return u;
}
tsProto.fromTsProtoServiceDefinition = fromTsProtoServiceDefinition;
function isTsProtoServiceDefinition(a) {
  return "name" in a && "fullName" in a && "methods" in a;
}
tsProto.isTsProtoServiceDefinition = isTsProtoServiceDefinition;
Object.defineProperty(serviceDefinitions, "__esModule", { value: !0 });
serviceDefinitions.normalizeServiceDefinition = void 0;
const grpc_web_1 = grpcWeb, ts_proto_1 = tsProto;
function normalizeServiceDefinition(a) {
  return (0, grpc_web_1.isGrpcWebServiceDefinition)(a) ? (0, grpc_web_1.fromGrpcWebServiceDefinition)(a) : (0, ts_proto_1.isTsProtoServiceDefinition)(a) ? (0, ts_proto_1.fromTsProtoServiceDefinition)(a) : a;
}
serviceDefinitions.normalizeServiceDefinition = normalizeServiceDefinition;
var channel = {}, fetch$1 = {};
class AbortError extends Error {
  constructor() {
    super("The operation has been aborted"), this.message = "The operation has been aborted", this.name = "AbortError", typeof Error.captureStackTrace == "function" && Error.captureStackTrace(this, this.constructor);
  }
}
function isAbortError(a) {
  return typeof a == "object" && a !== null && a.name === "AbortError";
}
function throwIfAborted(a) {
  if (a.aborted)
    throw new AbortError();
}
function rethrowAbortError(a) {
  if (isAbortError(a))
    throw a;
}
function catchAbortError(a) {
  if (!isAbortError(a))
    throw a;
}
function execute(a, u) {
  return new Promise((c, l) => {
    if (a.aborted) {
      l(new AbortError());
      return;
    }
    let v, p = !1;
    function _() {
      p || (p = !0, v != null && v());
    }
    const k = u((M) => {
      c(M), _();
    }, (M) => {
      l(M), _();
    });
    if (!p) {
      const M = () => {
        const L = k();
        L == null ? l(new AbortError()) : L.then(() => {
          l(new AbortError());
        }, (F) => {
          l(F);
        }), _();
      };
      a.addEventListener("abort", M), v = () => {
        a.removeEventListener("abort", M);
      };
    }
  });
}
function abortable(a, u) {
  if (a.aborted) {
    const c = () => {
    };
    u.then(c, c);
  }
  return execute(a, (c, l) => (u.then(c, l), () => {
  }));
}
function delay$1(a, u) {
  return execute(a, (c) => {
    const l = typeof u == "number" ? u : u.getTime() - Date.now(), v = setTimeout(c, l);
    return () => {
      clearTimeout(v);
    };
  });
}
function forever(a) {
  return execute(a, () => () => {
  });
}
function waitForEvent(a, u, c, l) {
  return execute(a, (v) => {
    let p, _ = !1;
    return p = listen(u, c, (...M) => {
      v(M.length > 1 ? M : M[0]), _ = !0, p != null && p();
    }, l), _ && p(), () => {
      _ = !0, p != null && p();
    };
  });
}
function listen(a, u, c, l) {
  if (isEventTarget(a))
    return a.addEventListener(u, c, l), () => a.removeEventListener(u, c, l);
  if (isJQueryStyleEventEmitter(a))
    return a.on(u, c), () => a.off(u, c);
  if (isNodeStyleEventEmitter(a))
    return a.addListener(u, c), () => a.removeListener(u, c);
  throw new Error("Invalid event target");
}
function isNodeStyleEventEmitter(a) {
  return isFunction$4(a.addListener) && isFunction$4(a.removeListener);
}
function isJQueryStyleEventEmitter(a) {
  return isFunction$4(a.on) && isFunction$4(a.off);
}
function isEventTarget(a) {
  return isFunction$4(a.addEventListener) && isFunction$4(a.removeEventListener);
}
const isFunction$4 = (a) => typeof a == "function";
function all(a, u) {
  return new Promise((c, l) => {
    if (a.aborted) {
      l(new AbortError());
      return;
    }
    const v = new AbortController(), p = u(v.signal);
    if (p.length === 0) {
      c([]);
      return;
    }
    const _ = () => {
      v.abort();
    };
    a.addEventListener("abort", _);
    let k;
    const M = new Array(p.length);
    let L = 0;
    function F() {
      L += 1, L === p.length && (a.removeEventListener("abort", _), k != null ? l(k.reason) : c(M));
    }
    for (const [V, X] of p.entries())
      X.then((oe) => {
        M[V] = oe, F();
      }, (oe) => {
        v.abort(), (k == null || !isAbortError(oe) && isAbortError(k.reason)) && (k = { reason: oe }), F();
      });
  });
}
function race$2(a, u) {
  return new Promise((c, l) => {
    if (a.aborted) {
      l(new AbortError());
      return;
    }
    const v = new AbortController(), p = u(v.signal), _ = () => {
      v.abort();
    };
    a.addEventListener("abort", _);
    let k = 0;
    function M(F) {
      v.abort(), k += 1, k === p.length && (a.removeEventListener("abort", _), F.status === "fulfilled" ? c(F.value) : l(F.reason));
    }
    let L;
    for (const F of p)
      F.then((V) => {
        L == null && (L = { status: "fulfilled", value: V }), M(L);
      }, (V) => {
        (L == null || !isAbortError(V) && (L.status === "fulfilled" || isAbortError(L.reason))) && (L = { status: "rejected", reason: V }), M(L);
      });
  });
}
async function retry$1(a, u, c = {}) {
  const { baseMs: l = 1e3, maxDelayMs: v = 3e4, onError: p, maxAttempts: _ = 1 / 0 } = c;
  let k = 0;
  const M = () => {
    k = -1;
  };
  for (; ; )
    try {
      return await u(a, k, M);
    } catch (L) {
      if (rethrowAbortError(L), k >= _)
        throw L;
      let F;
      if (k === -1)
        F = 0;
      else {
        const V = Math.min(v, Math.pow(2, k) * l);
        F = Math.round(V * (1 + Math.random()) / 2);
      }
      p && p(L, k, F), F !== 0 && await delay$1(a, F), k += 1;
    }
}
function spawn(a, u) {
  if (a.aborted)
    return Promise.reject(new AbortError());
  const c = [], l = new AbortController(), v = l.signal, p = () => {
    l.abort();
  };
  a.addEventListener("abort", p);
  const _ = () => {
    a.removeEventListener("abort", p);
  }, k = /* @__PURE__ */ new Set(), M = () => {
    for (const V of k)
      V.abort();
  };
  v.addEventListener("abort", M);
  const L = () => {
    v.removeEventListener("abort", M);
  };
  let F = new Promise((V, X) => {
    let oe, Y;
    ae((ne) => u(ne, {
      defer(fe) {
        c.push(fe);
      },
      fork: ae
    })).join().then((ne) => {
      l.abort(), oe = { value: ne };
    }, (ne) => {
      l.abort(), (!isAbortError(ne) || Y == null) && (Y = { error: ne });
    });
    function ae(ne) {
      if (v.aborted)
        return {
          abort() {
          },
          async join() {
            throw new AbortError();
          }
        };
      const fe = new AbortController(), ie = fe.signal, ge = ne(ie), be = {
        abort() {
          fe.abort();
        },
        join: () => ge
      };
      return k.add(be), ge.catch(catchAbortError).catch((Ce) => {
        Y = { error: Ce }, l.abort();
      }).finally(() => {
        k.delete(be), k.size === 0 && (Y != null ? X(Y.error) : V(oe.value));
      }), be;
    }
  });
  return F = F.finally(() => {
    _(), L();
    let V = Promise.resolve();
    for (let X = c.length - 1; X >= 0; X--)
      V = V.finally(c[X]);
    return V;
  }), F;
}
function run(a) {
  const u = new AbortController(), c = a(u.signal).catch(catchAbortError);
  return () => (u.abort(), c);
}
function proactiveRetry(a, u, c = {}) {
  const { baseMs: l = 1e3, onError: v, maxAttempts: p = 1 / 0 } = c;
  return execute(a, (_, k) => {
    const M = new AbortController();
    let L = !1;
    const F = /* @__PURE__ */ new Map();
    function V(Y) {
      M.abort(), F.clear(), _(Y);
    }
    function X(Y, ae) {
      if (F.delete(ae), L && F.size === 0) {
        k(Y);
        return;
      }
      if (!isAbortError(Y) && v)
        try {
          v(Y, ae);
        } catch (ne) {
          M.abort(), F.clear(), k(ne);
        }
    }
    async function oe(Y) {
      for (let ae = 0; ; ae++) {
        const ne = u(Y, ae);
        if (F.set(ae, ne), ne.then(V, (ge) => X(ge, ae)), ae + 1 >= p)
          break;
        const fe = Math.pow(2, ae) * l, ie = Math.round(fe * (1 + Math.random()) / 2);
        await delay$1(Y, ie);
      }
      L = !0;
    }
    return oe(M.signal).catch(catchAbortError), () => {
      M.abort();
    };
  });
}
const es = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AbortError,
  abortable,
  all,
  catchAbortError,
  delay: delay$1,
  execute,
  forever,
  isAbortError,
  proactiveRetry,
  race: race$2,
  rethrowAbortError,
  retry: retry$1,
  run,
  spawn,
  throwIfAborted,
  waitForEvent
}, Symbol.toStringTag, { value: "Module" })), require$$1$5 = /* @__PURE__ */ getAugmentedNamespace(es);
var buffer$3 = {}, base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [], revLookup = [], Arr = typeof Uint8Array < "u" ? Uint8Array : Array, code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$1 = 0, len = code.length; i$1 < len; ++i$1)
  lookup[i$1] = code[i$1], revLookup[code.charCodeAt(i$1)] = i$1;
revLookup[45] = 62;
revLookup[95] = 63;
function getLens(a) {
  var u = a.length;
  if (u % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var c = a.indexOf("=");
  c === -1 && (c = u);
  var l = c === u ? 0 : 4 - c % 4;
  return [c, l];
}
function byteLength(a) {
  var u = getLens(a), c = u[0], l = u[1];
  return (c + l) * 3 / 4 - l;
}
function _byteLength(a, u, c) {
  return (u + c) * 3 / 4 - c;
}
function toByteArray(a) {
  var u, c = getLens(a), l = c[0], v = c[1], p = new Arr(_byteLength(a, l, v)), _ = 0, k = v > 0 ? l - 4 : l, M;
  for (M = 0; M < k; M += 4)
    u = revLookup[a.charCodeAt(M)] << 18 | revLookup[a.charCodeAt(M + 1)] << 12 | revLookup[a.charCodeAt(M + 2)] << 6 | revLookup[a.charCodeAt(M + 3)], p[_++] = u >> 16 & 255, p[_++] = u >> 8 & 255, p[_++] = u & 255;
  return v === 2 && (u = revLookup[a.charCodeAt(M)] << 2 | revLookup[a.charCodeAt(M + 1)] >> 4, p[_++] = u & 255), v === 1 && (u = revLookup[a.charCodeAt(M)] << 10 | revLookup[a.charCodeAt(M + 1)] << 4 | revLookup[a.charCodeAt(M + 2)] >> 2, p[_++] = u >> 8 & 255, p[_++] = u & 255), p;
}
function tripletToBase64(a) {
  return lookup[a >> 18 & 63] + lookup[a >> 12 & 63] + lookup[a >> 6 & 63] + lookup[a & 63];
}
function encodeChunk(a, u, c) {
  for (var l, v = [], p = u; p < c; p += 3)
    l = (a[p] << 16 & 16711680) + (a[p + 1] << 8 & 65280) + (a[p + 2] & 255), v.push(tripletToBase64(l));
  return v.join("");
}
function fromByteArray(a) {
  for (var u, c = a.length, l = c % 3, v = [], p = 16383, _ = 0, k = c - l; _ < k; _ += p)
    v.push(encodeChunk(a, _, _ + p > k ? k : _ + p));
  return l === 1 ? (u = a[c - 1], v.push(
    lookup[u >> 2] + lookup[u << 4 & 63] + "=="
  )) : l === 2 && (u = (a[c - 2] << 8) + a[c - 1], v.push(
    lookup[u >> 10] + lookup[u >> 4 & 63] + lookup[u << 2 & 63] + "="
  )), v.join("");
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(a, u, c, l, v) {
  var p, _, k = v * 8 - l - 1, M = (1 << k) - 1, L = M >> 1, F = -7, V = c ? v - 1 : 0, X = c ? -1 : 1, oe = a[u + V];
  for (V += X, p = oe & (1 << -F) - 1, oe >>= -F, F += k; F > 0; p = p * 256 + a[u + V], V += X, F -= 8)
    ;
  for (_ = p & (1 << -F) - 1, p >>= -F, F += l; F > 0; _ = _ * 256 + a[u + V], V += X, F -= 8)
    ;
  if (p === 0)
    p = 1 - L;
  else {
    if (p === M)
      return _ ? NaN : (oe ? -1 : 1) * (1 / 0);
    _ = _ + Math.pow(2, l), p = p - L;
  }
  return (oe ? -1 : 1) * _ * Math.pow(2, p - l);
};
ieee754.write = function(a, u, c, l, v, p) {
  var _, k, M, L = p * 8 - v - 1, F = (1 << L) - 1, V = F >> 1, X = v === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, oe = l ? 0 : p - 1, Y = l ? 1 : -1, ae = u < 0 || u === 0 && 1 / u < 0 ? 1 : 0;
  for (u = Math.abs(u), isNaN(u) || u === 1 / 0 ? (k = isNaN(u) ? 1 : 0, _ = F) : (_ = Math.floor(Math.log(u) / Math.LN2), u * (M = Math.pow(2, -_)) < 1 && (_--, M *= 2), _ + V >= 1 ? u += X / M : u += X * Math.pow(2, 1 - V), u * M >= 2 && (_++, M /= 2), _ + V >= F ? (k = 0, _ = F) : _ + V >= 1 ? (k = (u * M - 1) * Math.pow(2, v), _ = _ + V) : (k = u * Math.pow(2, V - 1) * Math.pow(2, v), _ = 0)); v >= 8; a[c + oe] = k & 255, oe += Y, k /= 256, v -= 8)
    ;
  for (_ = _ << v | k, L += v; L > 0; a[c + oe] = _ & 255, oe += Y, _ /= 256, L -= 8)
    ;
  a[c + oe - Y] |= ae * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(a) {
  const u = base64Js, c = ieee754, l = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  a.Buffer = F, a.SlowBuffer = Ce, a.INSPECT_MAX_BYTES = 50;
  const v = 2147483647;
  a.kMaxLength = v;
  const { Uint8Array: p, ArrayBuffer: _, SharedArrayBuffer: k } = globalThis;
  F.TYPED_ARRAY_SUPPORT = M(), !F.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function M() {
    try {
      const de = new p(1), ue = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(ue, p.prototype), Object.setPrototypeOf(de, ue), de.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(F.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (F.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(F.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (F.isBuffer(this))
        return this.byteOffset;
    }
  });
  function L(de) {
    if (de > v)
      throw new RangeError('The value "' + de + '" is invalid for option "size"');
    const ue = new p(de);
    return Object.setPrototypeOf(ue, F.prototype), ue;
  }
  function F(de, ue, me) {
    if (typeof de == "number") {
      if (typeof ue == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return Y(de);
    }
    return V(de, ue, me);
  }
  F.poolSize = 8192;
  function V(de, ue, me) {
    if (typeof de == "string")
      return ae(de, ue);
    if (_.isView(de))
      return fe(de);
    if (de == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof de
      );
    if (we(de, _) || de && we(de.buffer, _) || typeof k < "u" && (we(de, k) || de && we(de.buffer, k)))
      return ie(de, ue, me);
    if (typeof de == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const Oe = de.valueOf && de.valueOf();
    if (Oe != null && Oe !== de)
      return F.from(Oe, ue, me);
    const Ue = ge(de);
    if (Ue)
      return Ue;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof de[Symbol.toPrimitive] == "function")
      return F.from(de[Symbol.toPrimitive]("string"), ue, me);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof de
    );
  }
  F.from = function(de, ue, me) {
    return V(de, ue, me);
  }, Object.setPrototypeOf(F.prototype, p.prototype), Object.setPrototypeOf(F, p);
  function X(de) {
    if (typeof de != "number")
      throw new TypeError('"size" argument must be of type number');
    if (de < 0)
      throw new RangeError('The value "' + de + '" is invalid for option "size"');
  }
  function oe(de, ue, me) {
    return X(de), de <= 0 ? L(de) : ue !== void 0 ? typeof me == "string" ? L(de).fill(ue, me) : L(de).fill(ue) : L(de);
  }
  F.alloc = function(de, ue, me) {
    return oe(de, ue, me);
  };
  function Y(de) {
    return X(de), L(de < 0 ? 0 : be(de) | 0);
  }
  F.allocUnsafe = function(de) {
    return Y(de);
  }, F.allocUnsafeSlow = function(de) {
    return Y(de);
  };
  function ae(de, ue) {
    if ((typeof ue != "string" || ue === "") && (ue = "utf8"), !F.isEncoding(ue))
      throw new TypeError("Unknown encoding: " + ue);
    const me = Me(de, ue) | 0;
    let Oe = L(me);
    const Ue = Oe.write(de, ue);
    return Ue !== me && (Oe = Oe.slice(0, Ue)), Oe;
  }
  function ne(de) {
    const ue = de.length < 0 ? 0 : be(de.length) | 0, me = L(ue);
    for (let Oe = 0; Oe < ue; Oe += 1)
      me[Oe] = de[Oe] & 255;
    return me;
  }
  function fe(de) {
    if (we(de, p)) {
      const ue = new p(de);
      return ie(ue.buffer, ue.byteOffset, ue.byteLength);
    }
    return ne(de);
  }
  function ie(de, ue, me) {
    if (ue < 0 || de.byteLength < ue)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (de.byteLength < ue + (me || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let Oe;
    return ue === void 0 && me === void 0 ? Oe = new p(de) : me === void 0 ? Oe = new p(de, ue) : Oe = new p(de, ue, me), Object.setPrototypeOf(Oe, F.prototype), Oe;
  }
  function ge(de) {
    if (F.isBuffer(de)) {
      const ue = be(de.length) | 0, me = L(ue);
      return me.length === 0 || de.copy(me, 0, 0, ue), me;
    }
    if (de.length !== void 0)
      return typeof de.length != "number" || We(de.length) ? L(0) : ne(de);
    if (de.type === "Buffer" && Array.isArray(de.data))
      return ne(de.data);
  }
  function be(de) {
    if (de >= v)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + v.toString(16) + " bytes");
    return de | 0;
  }
  function Ce(de) {
    return +de != de && (de = 0), F.alloc(+de);
  }
  F.isBuffer = function(ue) {
    return ue != null && ue._isBuffer === !0 && ue !== F.prototype;
  }, F.compare = function(ue, me) {
    if (we(ue, p) && (ue = F.from(ue, ue.offset, ue.byteLength)), we(me, p) && (me = F.from(me, me.offset, me.byteLength)), !F.isBuffer(ue) || !F.isBuffer(me))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (ue === me)
      return 0;
    let Oe = ue.length, Ue = me.length;
    for (let ze = 0, Ve = Math.min(Oe, Ue); ze < Ve; ++ze)
      if (ue[ze] !== me[ze]) {
        Oe = ue[ze], Ue = me[ze];
        break;
      }
    return Oe < Ue ? -1 : Ue < Oe ? 1 : 0;
  }, F.isEncoding = function(ue) {
    switch (String(ue).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, F.concat = function(ue, me) {
    if (!Array.isArray(ue))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (ue.length === 0)
      return F.alloc(0);
    let Oe;
    if (me === void 0)
      for (me = 0, Oe = 0; Oe < ue.length; ++Oe)
        me += ue[Oe].length;
    const Ue = F.allocUnsafe(me);
    let ze = 0;
    for (Oe = 0; Oe < ue.length; ++Oe) {
      let Ve = ue[Oe];
      if (we(Ve, p))
        ze + Ve.length > Ue.length ? (F.isBuffer(Ve) || (Ve = F.from(Ve)), Ve.copy(Ue, ze)) : p.prototype.set.call(
          Ue,
          Ve,
          ze
        );
      else if (F.isBuffer(Ve))
        Ve.copy(Ue, ze);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      ze += Ve.length;
    }
    return Ue;
  };
  function Me(de, ue) {
    if (F.isBuffer(de))
      return de.length;
    if (_.isView(de) || we(de, _))
      return de.byteLength;
    if (typeof de != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof de
      );
    const me = de.length, Oe = arguments.length > 2 && arguments[2] === !0;
    if (!Oe && me === 0)
      return 0;
    let Ue = !1;
    for (; ; )
      switch (ue) {
        case "ascii":
        case "latin1":
        case "binary":
          return me;
        case "utf8":
        case "utf-8":
          return gt(de).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return me * 2;
        case "hex":
          return me >>> 1;
        case "base64":
          return J(de).length;
        default:
          if (Ue)
            return Oe ? -1 : gt(de).length;
          ue = ("" + ue).toLowerCase(), Ue = !0;
      }
  }
  F.byteLength = Me;
  function Be(de, ue, me) {
    let Oe = !1;
    if ((ue === void 0 || ue < 0) && (ue = 0), ue > this.length || ((me === void 0 || me > this.length) && (me = this.length), me <= 0) || (me >>>= 0, ue >>>= 0, me <= ue))
      return "";
    for (de || (de = "utf8"); ; )
      switch (de) {
        case "hex":
          return ee(this, ue, me);
        case "utf8":
        case "utf-8":
          return U(this, ue, me);
        case "ascii":
          return T(this, ue, me);
        case "latin1":
        case "binary":
          return D(this, ue, me);
        case "base64":
          return $(this, ue, me);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return pe(this, ue, me);
        default:
          if (Oe)
            throw new TypeError("Unknown encoding: " + de);
          de = (de + "").toLowerCase(), Oe = !0;
      }
  }
  F.prototype._isBuffer = !0;
  function Ae(de, ue, me) {
    const Oe = de[ue];
    de[ue] = de[me], de[me] = Oe;
  }
  F.prototype.swap16 = function() {
    const ue = this.length;
    if (ue % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let me = 0; me < ue; me += 2)
      Ae(this, me, me + 1);
    return this;
  }, F.prototype.swap32 = function() {
    const ue = this.length;
    if (ue % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let me = 0; me < ue; me += 4)
      Ae(this, me, me + 3), Ae(this, me + 1, me + 2);
    return this;
  }, F.prototype.swap64 = function() {
    const ue = this.length;
    if (ue % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let me = 0; me < ue; me += 8)
      Ae(this, me, me + 7), Ae(this, me + 1, me + 6), Ae(this, me + 2, me + 5), Ae(this, me + 3, me + 4);
    return this;
  }, F.prototype.toString = function() {
    const ue = this.length;
    return ue === 0 ? "" : arguments.length === 0 ? U(this, 0, ue) : Be.apply(this, arguments);
  }, F.prototype.toLocaleString = F.prototype.toString, F.prototype.equals = function(ue) {
    if (!F.isBuffer(ue))
      throw new TypeError("Argument must be a Buffer");
    return this === ue ? !0 : F.compare(this, ue) === 0;
  }, F.prototype.inspect = function() {
    let ue = "";
    const me = a.INSPECT_MAX_BYTES;
    return ue = this.toString("hex", 0, me).replace(/(.{2})/g, "$1 ").trim(), this.length > me && (ue += " ... "), "<Buffer " + ue + ">";
  }, l && (F.prototype[l] = F.prototype.inspect), F.prototype.compare = function(ue, me, Oe, Ue, ze) {
    if (we(ue, p) && (ue = F.from(ue, ue.offset, ue.byteLength)), !F.isBuffer(ue))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof ue
      );
    if (me === void 0 && (me = 0), Oe === void 0 && (Oe = ue ? ue.length : 0), Ue === void 0 && (Ue = 0), ze === void 0 && (ze = this.length), me < 0 || Oe > ue.length || Ue < 0 || ze > this.length)
      throw new RangeError("out of range index");
    if (Ue >= ze && me >= Oe)
      return 0;
    if (Ue >= ze)
      return -1;
    if (me >= Oe)
      return 1;
    if (me >>>= 0, Oe >>>= 0, Ue >>>= 0, ze >>>= 0, this === ue)
      return 0;
    let Ve = ze - Ue, Qe = Oe - me;
    const Ke = Math.min(Ve, Qe), x = this.slice(Ue, ze), se = ue.slice(me, Oe);
    for (let Ee = 0; Ee < Ke; ++Ee)
      if (x[Ee] !== se[Ee]) {
        Ve = x[Ee], Qe = se[Ee];
        break;
      }
    return Ve < Qe ? -1 : Qe < Ve ? 1 : 0;
  };
  function Z(de, ue, me, Oe, Ue) {
    if (de.length === 0)
      return -1;
    if (typeof me == "string" ? (Oe = me, me = 0) : me > 2147483647 ? me = 2147483647 : me < -2147483648 && (me = -2147483648), me = +me, We(me) && (me = Ue ? 0 : de.length - 1), me < 0 && (me = de.length + me), me >= de.length) {
      if (Ue)
        return -1;
      me = de.length - 1;
    } else if (me < 0)
      if (Ue)
        me = 0;
      else
        return -1;
    if (typeof ue == "string" && (ue = F.from(ue, Oe)), F.isBuffer(ue))
      return ue.length === 0 ? -1 : z(de, ue, me, Oe, Ue);
    if (typeof ue == "number")
      return ue = ue & 255, typeof p.prototype.indexOf == "function" ? Ue ? p.prototype.indexOf.call(de, ue, me) : p.prototype.lastIndexOf.call(de, ue, me) : z(de, [ue], me, Oe, Ue);
    throw new TypeError("val must be string, number or Buffer");
  }
  function z(de, ue, me, Oe, Ue) {
    let ze = 1, Ve = de.length, Qe = ue.length;
    if (Oe !== void 0 && (Oe = String(Oe).toLowerCase(), Oe === "ucs2" || Oe === "ucs-2" || Oe === "utf16le" || Oe === "utf-16le")) {
      if (de.length < 2 || ue.length < 2)
        return -1;
      ze = 2, Ve /= 2, Qe /= 2, me /= 2;
    }
    function Ke(se, Ee) {
      return ze === 1 ? se[Ee] : se.readUInt16BE(Ee * ze);
    }
    let x;
    if (Ue) {
      let se = -1;
      for (x = me; x < Ve; x++)
        if (Ke(de, x) === Ke(ue, se === -1 ? 0 : x - se)) {
          if (se === -1 && (se = x), x - se + 1 === Qe)
            return se * ze;
        } else
          se !== -1 && (x -= x - se), se = -1;
    } else
      for (me + Qe > Ve && (me = Ve - Qe), x = me; x >= 0; x--) {
        let se = !0;
        for (let Ee = 0; Ee < Qe; Ee++)
          if (Ke(de, x + Ee) !== Ke(ue, Ee)) {
            se = !1;
            break;
          }
        if (se)
          return x;
      }
    return -1;
  }
  F.prototype.includes = function(ue, me, Oe) {
    return this.indexOf(ue, me, Oe) !== -1;
  }, F.prototype.indexOf = function(ue, me, Oe) {
    return Z(this, ue, me, Oe, !0);
  }, F.prototype.lastIndexOf = function(ue, me, Oe) {
    return Z(this, ue, me, Oe, !1);
  };
  function P(de, ue, me, Oe) {
    me = Number(me) || 0;
    const Ue = de.length - me;
    Oe ? (Oe = Number(Oe), Oe > Ue && (Oe = Ue)) : Oe = Ue;
    const ze = ue.length;
    Oe > ze / 2 && (Oe = ze / 2);
    let Ve;
    for (Ve = 0; Ve < Oe; ++Ve) {
      const Qe = parseInt(ue.substr(Ve * 2, 2), 16);
      if (We(Qe))
        return Ve;
      de[me + Ve] = Qe;
    }
    return Ve;
  }
  function S(de, ue, me, Oe) {
    return ye(gt(ue, de.length - me), de, me, Oe);
  }
  function E(de, ue, me, Oe) {
    return ye(Xe(ue), de, me, Oe);
  }
  function I(de, ue, me, Oe) {
    return ye(J(ue), de, me, Oe);
  }
  function N(de, ue, me, Oe) {
    return ye(Ge(ue, de.length - me), de, me, Oe);
  }
  F.prototype.write = function(ue, me, Oe, Ue) {
    if (me === void 0)
      Ue = "utf8", Oe = this.length, me = 0;
    else if (Oe === void 0 && typeof me == "string")
      Ue = me, Oe = this.length, me = 0;
    else if (isFinite(me))
      me = me >>> 0, isFinite(Oe) ? (Oe = Oe >>> 0, Ue === void 0 && (Ue = "utf8")) : (Ue = Oe, Oe = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const ze = this.length - me;
    if ((Oe === void 0 || Oe > ze) && (Oe = ze), ue.length > 0 && (Oe < 0 || me < 0) || me > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    Ue || (Ue = "utf8");
    let Ve = !1;
    for (; ; )
      switch (Ue) {
        case "hex":
          return P(this, ue, me, Oe);
        case "utf8":
        case "utf-8":
          return S(this, ue, me, Oe);
        case "ascii":
        case "latin1":
        case "binary":
          return E(this, ue, me, Oe);
        case "base64":
          return I(this, ue, me, Oe);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return N(this, ue, me, Oe);
        default:
          if (Ve)
            throw new TypeError("Unknown encoding: " + Ue);
          Ue = ("" + Ue).toLowerCase(), Ve = !0;
      }
  }, F.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function $(de, ue, me) {
    return ue === 0 && me === de.length ? u.fromByteArray(de) : u.fromByteArray(de.slice(ue, me));
  }
  function U(de, ue, me) {
    me = Math.min(de.length, me);
    const Oe = [];
    let Ue = ue;
    for (; Ue < me; ) {
      const ze = de[Ue];
      let Ve = null, Qe = ze > 239 ? 4 : ze > 223 ? 3 : ze > 191 ? 2 : 1;
      if (Ue + Qe <= me) {
        let Ke, x, se, Ee;
        switch (Qe) {
          case 1:
            ze < 128 && (Ve = ze);
            break;
          case 2:
            Ke = de[Ue + 1], (Ke & 192) === 128 && (Ee = (ze & 31) << 6 | Ke & 63, Ee > 127 && (Ve = Ee));
            break;
          case 3:
            Ke = de[Ue + 1], x = de[Ue + 2], (Ke & 192) === 128 && (x & 192) === 128 && (Ee = (ze & 15) << 12 | (Ke & 63) << 6 | x & 63, Ee > 2047 && (Ee < 55296 || Ee > 57343) && (Ve = Ee));
            break;
          case 4:
            Ke = de[Ue + 1], x = de[Ue + 2], se = de[Ue + 3], (Ke & 192) === 128 && (x & 192) === 128 && (se & 192) === 128 && (Ee = (ze & 15) << 18 | (Ke & 63) << 12 | (x & 63) << 6 | se & 63, Ee > 65535 && Ee < 1114112 && (Ve = Ee));
        }
      }
      Ve === null ? (Ve = 65533, Qe = 1) : Ve > 65535 && (Ve -= 65536, Oe.push(Ve >>> 10 & 1023 | 55296), Ve = 56320 | Ve & 1023), Oe.push(Ve), Ue += Qe;
    }
    return B(Oe);
  }
  const H = 4096;
  function B(de) {
    const ue = de.length;
    if (ue <= H)
      return String.fromCharCode.apply(String, de);
    let me = "", Oe = 0;
    for (; Oe < ue; )
      me += String.fromCharCode.apply(
        String,
        de.slice(Oe, Oe += H)
      );
    return me;
  }
  function T(de, ue, me) {
    let Oe = "";
    me = Math.min(de.length, me);
    for (let Ue = ue; Ue < me; ++Ue)
      Oe += String.fromCharCode(de[Ue] & 127);
    return Oe;
  }
  function D(de, ue, me) {
    let Oe = "";
    me = Math.min(de.length, me);
    for (let Ue = ue; Ue < me; ++Ue)
      Oe += String.fromCharCode(de[Ue]);
    return Oe;
  }
  function ee(de, ue, me) {
    const Oe = de.length;
    (!ue || ue < 0) && (ue = 0), (!me || me < 0 || me > Oe) && (me = Oe);
    let Ue = "";
    for (let ze = ue; ze < me; ++ze)
      Ue += Re[de[ze]];
    return Ue;
  }
  function pe(de, ue, me) {
    const Oe = de.slice(ue, me);
    let Ue = "";
    for (let ze = 0; ze < Oe.length - 1; ze += 2)
      Ue += String.fromCharCode(Oe[ze] + Oe[ze + 1] * 256);
    return Ue;
  }
  F.prototype.slice = function(ue, me) {
    const Oe = this.length;
    ue = ~~ue, me = me === void 0 ? Oe : ~~me, ue < 0 ? (ue += Oe, ue < 0 && (ue = 0)) : ue > Oe && (ue = Oe), me < 0 ? (me += Oe, me < 0 && (me = 0)) : me > Oe && (me = Oe), me < ue && (me = ue);
    const Ue = this.subarray(ue, me);
    return Object.setPrototypeOf(Ue, F.prototype), Ue;
  };
  function Ie(de, ue, me) {
    if (de % 1 !== 0 || de < 0)
      throw new RangeError("offset is not uint");
    if (de + ue > me)
      throw new RangeError("Trying to access beyond buffer length");
  }
  F.prototype.readUintLE = F.prototype.readUIntLE = function(ue, me, Oe) {
    ue = ue >>> 0, me = me >>> 0, Oe || Ie(ue, me, this.length);
    let Ue = this[ue], ze = 1, Ve = 0;
    for (; ++Ve < me && (ze *= 256); )
      Ue += this[ue + Ve] * ze;
    return Ue;
  }, F.prototype.readUintBE = F.prototype.readUIntBE = function(ue, me, Oe) {
    ue = ue >>> 0, me = me >>> 0, Oe || Ie(ue, me, this.length);
    let Ue = this[ue + --me], ze = 1;
    for (; me > 0 && (ze *= 256); )
      Ue += this[ue + --me] * ze;
    return Ue;
  }, F.prototype.readUint8 = F.prototype.readUInt8 = function(ue, me) {
    return ue = ue >>> 0, me || Ie(ue, 1, this.length), this[ue];
  }, F.prototype.readUint16LE = F.prototype.readUInt16LE = function(ue, me) {
    return ue = ue >>> 0, me || Ie(ue, 2, this.length), this[ue] | this[ue + 1] << 8;
  }, F.prototype.readUint16BE = F.prototype.readUInt16BE = function(ue, me) {
    return ue = ue >>> 0, me || Ie(ue, 2, this.length), this[ue] << 8 | this[ue + 1];
  }, F.prototype.readUint32LE = F.prototype.readUInt32LE = function(ue, me) {
    return ue = ue >>> 0, me || Ie(ue, 4, this.length), (this[ue] | this[ue + 1] << 8 | this[ue + 2] << 16) + this[ue + 3] * 16777216;
  }, F.prototype.readUint32BE = F.prototype.readUInt32BE = function(ue, me) {
    return ue = ue >>> 0, me || Ie(ue, 4, this.length), this[ue] * 16777216 + (this[ue + 1] << 16 | this[ue + 2] << 8 | this[ue + 3]);
  }, F.prototype.readBigUInt64LE = q(function(ue) {
    ue = ue >>> 0, Ne(ue, "offset");
    const me = this[ue], Oe = this[ue + 7];
    (me === void 0 || Oe === void 0) && Fe(ue, this.length - 8);
    const Ue = me + this[++ue] * 2 ** 8 + this[++ue] * 2 ** 16 + this[++ue] * 2 ** 24, ze = this[++ue] + this[++ue] * 2 ** 8 + this[++ue] * 2 ** 16 + Oe * 2 ** 24;
    return BigInt(Ue) + (BigInt(ze) << BigInt(32));
  }), F.prototype.readBigUInt64BE = q(function(ue) {
    ue = ue >>> 0, Ne(ue, "offset");
    const me = this[ue], Oe = this[ue + 7];
    (me === void 0 || Oe === void 0) && Fe(ue, this.length - 8);
    const Ue = me * 2 ** 24 + this[++ue] * 2 ** 16 + this[++ue] * 2 ** 8 + this[++ue], ze = this[++ue] * 2 ** 24 + this[++ue] * 2 ** 16 + this[++ue] * 2 ** 8 + Oe;
    return (BigInt(Ue) << BigInt(32)) + BigInt(ze);
  }), F.prototype.readIntLE = function(ue, me, Oe) {
    ue = ue >>> 0, me = me >>> 0, Oe || Ie(ue, me, this.length);
    let Ue = this[ue], ze = 1, Ve = 0;
    for (; ++Ve < me && (ze *= 256); )
      Ue += this[ue + Ve] * ze;
    return ze *= 128, Ue >= ze && (Ue -= Math.pow(2, 8 * me)), Ue;
  }, F.prototype.readIntBE = function(ue, me, Oe) {
    ue = ue >>> 0, me = me >>> 0, Oe || Ie(ue, me, this.length);
    let Ue = me, ze = 1, Ve = this[ue + --Ue];
    for (; Ue > 0 && (ze *= 256); )
      Ve += this[ue + --Ue] * ze;
    return ze *= 128, Ve >= ze && (Ve -= Math.pow(2, 8 * me)), Ve;
  }, F.prototype.readInt8 = function(ue, me) {
    return ue = ue >>> 0, me || Ie(ue, 1, this.length), this[ue] & 128 ? (255 - this[ue] + 1) * -1 : this[ue];
  }, F.prototype.readInt16LE = function(ue, me) {
    ue = ue >>> 0, me || Ie(ue, 2, this.length);
    const Oe = this[ue] | this[ue + 1] << 8;
    return Oe & 32768 ? Oe | 4294901760 : Oe;
  }, F.prototype.readInt16BE = function(ue, me) {
    ue = ue >>> 0, me || Ie(ue, 2, this.length);
    const Oe = this[ue + 1] | this[ue] << 8;
    return Oe & 32768 ? Oe | 4294901760 : Oe;
  }, F.prototype.readInt32LE = function(ue, me) {
    return ue = ue >>> 0, me || Ie(ue, 4, this.length), this[ue] | this[ue + 1] << 8 | this[ue + 2] << 16 | this[ue + 3] << 24;
  }, F.prototype.readInt32BE = function(ue, me) {
    return ue = ue >>> 0, me || Ie(ue, 4, this.length), this[ue] << 24 | this[ue + 1] << 16 | this[ue + 2] << 8 | this[ue + 3];
  }, F.prototype.readBigInt64LE = q(function(ue) {
    ue = ue >>> 0, Ne(ue, "offset");
    const me = this[ue], Oe = this[ue + 7];
    (me === void 0 || Oe === void 0) && Fe(ue, this.length - 8);
    const Ue = this[ue + 4] + this[ue + 5] * 2 ** 8 + this[ue + 6] * 2 ** 16 + (Oe << 24);
    return (BigInt(Ue) << BigInt(32)) + BigInt(me + this[++ue] * 2 ** 8 + this[++ue] * 2 ** 16 + this[++ue] * 2 ** 24);
  }), F.prototype.readBigInt64BE = q(function(ue) {
    ue = ue >>> 0, Ne(ue, "offset");
    const me = this[ue], Oe = this[ue + 7];
    (me === void 0 || Oe === void 0) && Fe(ue, this.length - 8);
    const Ue = (me << 24) + // Overflow
    this[++ue] * 2 ** 16 + this[++ue] * 2 ** 8 + this[++ue];
    return (BigInt(Ue) << BigInt(32)) + BigInt(this[++ue] * 2 ** 24 + this[++ue] * 2 ** 16 + this[++ue] * 2 ** 8 + Oe);
  }), F.prototype.readFloatLE = function(ue, me) {
    return ue = ue >>> 0, me || Ie(ue, 4, this.length), c.read(this, ue, !0, 23, 4);
  }, F.prototype.readFloatBE = function(ue, me) {
    return ue = ue >>> 0, me || Ie(ue, 4, this.length), c.read(this, ue, !1, 23, 4);
  }, F.prototype.readDoubleLE = function(ue, me) {
    return ue = ue >>> 0, me || Ie(ue, 8, this.length), c.read(this, ue, !0, 52, 8);
  }, F.prototype.readDoubleBE = function(ue, me) {
    return ue = ue >>> 0, me || Ie(ue, 8, this.length), c.read(this, ue, !1, 52, 8);
  };
  function Pe(de, ue, me, Oe, Ue, ze) {
    if (!F.isBuffer(de))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (ue > Ue || ue < ze)
      throw new RangeError('"value" argument is out of bounds');
    if (me + Oe > de.length)
      throw new RangeError("Index out of range");
  }
  F.prototype.writeUintLE = F.prototype.writeUIntLE = function(ue, me, Oe, Ue) {
    if (ue = +ue, me = me >>> 0, Oe = Oe >>> 0, !Ue) {
      const Qe = Math.pow(2, 8 * Oe) - 1;
      Pe(this, ue, me, Oe, Qe, 0);
    }
    let ze = 1, Ve = 0;
    for (this[me] = ue & 255; ++Ve < Oe && (ze *= 256); )
      this[me + Ve] = ue / ze & 255;
    return me + Oe;
  }, F.prototype.writeUintBE = F.prototype.writeUIntBE = function(ue, me, Oe, Ue) {
    if (ue = +ue, me = me >>> 0, Oe = Oe >>> 0, !Ue) {
      const Qe = Math.pow(2, 8 * Oe) - 1;
      Pe(this, ue, me, Oe, Qe, 0);
    }
    let ze = Oe - 1, Ve = 1;
    for (this[me + ze] = ue & 255; --ze >= 0 && (Ve *= 256); )
      this[me + ze] = ue / Ve & 255;
    return me + Oe;
  }, F.prototype.writeUint8 = F.prototype.writeUInt8 = function(ue, me, Oe) {
    return ue = +ue, me = me >>> 0, Oe || Pe(this, ue, me, 1, 255, 0), this[me] = ue & 255, me + 1;
  }, F.prototype.writeUint16LE = F.prototype.writeUInt16LE = function(ue, me, Oe) {
    return ue = +ue, me = me >>> 0, Oe || Pe(this, ue, me, 2, 65535, 0), this[me] = ue & 255, this[me + 1] = ue >>> 8, me + 2;
  }, F.prototype.writeUint16BE = F.prototype.writeUInt16BE = function(ue, me, Oe) {
    return ue = +ue, me = me >>> 0, Oe || Pe(this, ue, me, 2, 65535, 0), this[me] = ue >>> 8, this[me + 1] = ue & 255, me + 2;
  }, F.prototype.writeUint32LE = F.prototype.writeUInt32LE = function(ue, me, Oe) {
    return ue = +ue, me = me >>> 0, Oe || Pe(this, ue, me, 4, 4294967295, 0), this[me + 3] = ue >>> 24, this[me + 2] = ue >>> 16, this[me + 1] = ue >>> 8, this[me] = ue & 255, me + 4;
  }, F.prototype.writeUint32BE = F.prototype.writeUInt32BE = function(ue, me, Oe) {
    return ue = +ue, me = me >>> 0, Oe || Pe(this, ue, me, 4, 4294967295, 0), this[me] = ue >>> 24, this[me + 1] = ue >>> 16, this[me + 2] = ue >>> 8, this[me + 3] = ue & 255, me + 4;
  };
  function he(de, ue, me, Oe, Ue) {
    De(ue, Oe, Ue, de, me, 7);
    let ze = Number(ue & BigInt(4294967295));
    de[me++] = ze, ze = ze >> 8, de[me++] = ze, ze = ze >> 8, de[me++] = ze, ze = ze >> 8, de[me++] = ze;
    let Ve = Number(ue >> BigInt(32) & BigInt(4294967295));
    return de[me++] = Ve, Ve = Ve >> 8, de[me++] = Ve, Ve = Ve >> 8, de[me++] = Ve, Ve = Ve >> 8, de[me++] = Ve, me;
  }
  function ve(de, ue, me, Oe, Ue) {
    De(ue, Oe, Ue, de, me, 7);
    let ze = Number(ue & BigInt(4294967295));
    de[me + 7] = ze, ze = ze >> 8, de[me + 6] = ze, ze = ze >> 8, de[me + 5] = ze, ze = ze >> 8, de[me + 4] = ze;
    let Ve = Number(ue >> BigInt(32) & BigInt(4294967295));
    return de[me + 3] = Ve, Ve = Ve >> 8, de[me + 2] = Ve, Ve = Ve >> 8, de[me + 1] = Ve, Ve = Ve >> 8, de[me] = Ve, me + 8;
  }
  F.prototype.writeBigUInt64LE = q(function(ue, me = 0) {
    return he(this, ue, me, BigInt(0), BigInt("0xffffffffffffffff"));
  }), F.prototype.writeBigUInt64BE = q(function(ue, me = 0) {
    return ve(this, ue, me, BigInt(0), BigInt("0xffffffffffffffff"));
  }), F.prototype.writeIntLE = function(ue, me, Oe, Ue) {
    if (ue = +ue, me = me >>> 0, !Ue) {
      const Ke = Math.pow(2, 8 * Oe - 1);
      Pe(this, ue, me, Oe, Ke - 1, -Ke);
    }
    let ze = 0, Ve = 1, Qe = 0;
    for (this[me] = ue & 255; ++ze < Oe && (Ve *= 256); )
      ue < 0 && Qe === 0 && this[me + ze - 1] !== 0 && (Qe = 1), this[me + ze] = (ue / Ve >> 0) - Qe & 255;
    return me + Oe;
  }, F.prototype.writeIntBE = function(ue, me, Oe, Ue) {
    if (ue = +ue, me = me >>> 0, !Ue) {
      const Ke = Math.pow(2, 8 * Oe - 1);
      Pe(this, ue, me, Oe, Ke - 1, -Ke);
    }
    let ze = Oe - 1, Ve = 1, Qe = 0;
    for (this[me + ze] = ue & 255; --ze >= 0 && (Ve *= 256); )
      ue < 0 && Qe === 0 && this[me + ze + 1] !== 0 && (Qe = 1), this[me + ze] = (ue / Ve >> 0) - Qe & 255;
    return me + Oe;
  }, F.prototype.writeInt8 = function(ue, me, Oe) {
    return ue = +ue, me = me >>> 0, Oe || Pe(this, ue, me, 1, 127, -128), ue < 0 && (ue = 255 + ue + 1), this[me] = ue & 255, me + 1;
  }, F.prototype.writeInt16LE = function(ue, me, Oe) {
    return ue = +ue, me = me >>> 0, Oe || Pe(this, ue, me, 2, 32767, -32768), this[me] = ue & 255, this[me + 1] = ue >>> 8, me + 2;
  }, F.prototype.writeInt16BE = function(ue, me, Oe) {
    return ue = +ue, me = me >>> 0, Oe || Pe(this, ue, me, 2, 32767, -32768), this[me] = ue >>> 8, this[me + 1] = ue & 255, me + 2;
  }, F.prototype.writeInt32LE = function(ue, me, Oe) {
    return ue = +ue, me = me >>> 0, Oe || Pe(this, ue, me, 4, 2147483647, -2147483648), this[me] = ue & 255, this[me + 1] = ue >>> 8, this[me + 2] = ue >>> 16, this[me + 3] = ue >>> 24, me + 4;
  }, F.prototype.writeInt32BE = function(ue, me, Oe) {
    return ue = +ue, me = me >>> 0, Oe || Pe(this, ue, me, 4, 2147483647, -2147483648), ue < 0 && (ue = 4294967295 + ue + 1), this[me] = ue >>> 24, this[me + 1] = ue >>> 16, this[me + 2] = ue >>> 8, this[me + 3] = ue & 255, me + 4;
  }, F.prototype.writeBigInt64LE = q(function(ue, me = 0) {
    return he(this, ue, me, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), F.prototype.writeBigInt64BE = q(function(ue, me = 0) {
    return ve(this, ue, me, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function Q(de, ue, me, Oe, Ue, ze) {
    if (me + Oe > de.length)
      throw new RangeError("Index out of range");
    if (me < 0)
      throw new RangeError("Index out of range");
  }
  function le(de, ue, me, Oe, Ue) {
    return ue = +ue, me = me >>> 0, Ue || Q(de, ue, me, 4), c.write(de, ue, me, Oe, 23, 4), me + 4;
  }
  F.prototype.writeFloatLE = function(ue, me, Oe) {
    return le(this, ue, me, !0, Oe);
  }, F.prototype.writeFloatBE = function(ue, me, Oe) {
    return le(this, ue, me, !1, Oe);
  };
  function _e(de, ue, me, Oe, Ue) {
    return ue = +ue, me = me >>> 0, Ue || Q(de, ue, me, 8), c.write(de, ue, me, Oe, 52, 8), me + 8;
  }
  F.prototype.writeDoubleLE = function(ue, me, Oe) {
    return _e(this, ue, me, !0, Oe);
  }, F.prototype.writeDoubleBE = function(ue, me, Oe) {
    return _e(this, ue, me, !1, Oe);
  }, F.prototype.copy = function(ue, me, Oe, Ue) {
    if (!F.isBuffer(ue))
      throw new TypeError("argument should be a Buffer");
    if (Oe || (Oe = 0), !Ue && Ue !== 0 && (Ue = this.length), me >= ue.length && (me = ue.length), me || (me = 0), Ue > 0 && Ue < Oe && (Ue = Oe), Ue === Oe || ue.length === 0 || this.length === 0)
      return 0;
    if (me < 0)
      throw new RangeError("targetStart out of bounds");
    if (Oe < 0 || Oe >= this.length)
      throw new RangeError("Index out of range");
    if (Ue < 0)
      throw new RangeError("sourceEnd out of bounds");
    Ue > this.length && (Ue = this.length), ue.length - me < Ue - Oe && (Ue = ue.length - me + Oe);
    const ze = Ue - Oe;
    return this === ue && typeof p.prototype.copyWithin == "function" ? this.copyWithin(me, Oe, Ue) : p.prototype.set.call(
      ue,
      this.subarray(Oe, Ue),
      me
    ), ze;
  }, F.prototype.fill = function(ue, me, Oe, Ue) {
    if (typeof ue == "string") {
      if (typeof me == "string" ? (Ue = me, me = 0, Oe = this.length) : typeof Oe == "string" && (Ue = Oe, Oe = this.length), Ue !== void 0 && typeof Ue != "string")
        throw new TypeError("encoding must be a string");
      if (typeof Ue == "string" && !F.isEncoding(Ue))
        throw new TypeError("Unknown encoding: " + Ue);
      if (ue.length === 1) {
        const Ve = ue.charCodeAt(0);
        (Ue === "utf8" && Ve < 128 || Ue === "latin1") && (ue = Ve);
      }
    } else
      typeof ue == "number" ? ue = ue & 255 : typeof ue == "boolean" && (ue = Number(ue));
    if (me < 0 || this.length < me || this.length < Oe)
      throw new RangeError("Out of range index");
    if (Oe <= me)
      return this;
    me = me >>> 0, Oe = Oe === void 0 ? this.length : Oe >>> 0, ue || (ue = 0);
    let ze;
    if (typeof ue == "number")
      for (ze = me; ze < Oe; ++ze)
        this[ze] = ue;
    else {
      const Ve = F.isBuffer(ue) ? ue : F.from(ue, Ue), Qe = Ve.length;
      if (Qe === 0)
        throw new TypeError('The value "' + ue + '" is invalid for argument "value"');
      for (ze = 0; ze < Oe - me; ++ze)
        this[ze + me] = Ve[ze % Qe];
    }
    return this;
  };
  const re = {};
  function O(de, ue, me) {
    re[de] = class extends me {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: ue.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${de}]`, this.stack, delete this.name;
      }
      get code() {
        return de;
      }
      set code(Ue) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: Ue,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${de}]: ${this.message}`;
      }
    };
  }
  O(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(de) {
      return de ? `${de} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), O(
    "ERR_INVALID_ARG_TYPE",
    function(de, ue) {
      return `The "${de}" argument must be of type number. Received type ${typeof ue}`;
    },
    TypeError
  ), O(
    "ERR_OUT_OF_RANGE",
    function(de, ue, me) {
      let Oe = `The value of "${de}" is out of range.`, Ue = me;
      return Number.isInteger(me) && Math.abs(me) > 2 ** 32 ? Ue = j(String(me)) : typeof me == "bigint" && (Ue = String(me), (me > BigInt(2) ** BigInt(32) || me < -(BigInt(2) ** BigInt(32))) && (Ue = j(Ue)), Ue += "n"), Oe += ` It must be ${ue}. Received ${Ue}`, Oe;
    },
    RangeError
  );
  function j(de) {
    let ue = "", me = de.length;
    const Oe = de[0] === "-" ? 1 : 0;
    for (; me >= Oe + 4; me -= 3)
      ue = `_${de.slice(me - 3, me)}${ue}`;
    return `${de.slice(0, me)}${ue}`;
  }
  function ce(de, ue, me) {
    Ne(ue, "offset"), (de[ue] === void 0 || de[ue + me] === void 0) && Fe(ue, de.length - (me + 1));
  }
  function De(de, ue, me, Oe, Ue, ze) {
    if (de > me || de < ue) {
      const Ve = typeof ue == "bigint" ? "n" : "";
      let Qe;
      throw ze > 3 ? ue === 0 || ue === BigInt(0) ? Qe = `>= 0${Ve} and < 2${Ve} ** ${(ze + 1) * 8}${Ve}` : Qe = `>= -(2${Ve} ** ${(ze + 1) * 8 - 1}${Ve}) and < 2 ** ${(ze + 1) * 8 - 1}${Ve}` : Qe = `>= ${ue}${Ve} and <= ${me}${Ve}`, new re.ERR_OUT_OF_RANGE("value", Qe, de);
    }
    ce(Oe, Ue, ze);
  }
  function Ne(de, ue) {
    if (typeof de != "number")
      throw new re.ERR_INVALID_ARG_TYPE(ue, "number", de);
  }
  function Fe(de, ue, me) {
    throw Math.floor(de) !== de ? (Ne(de, me), new re.ERR_OUT_OF_RANGE(me || "offset", "an integer", de)) : ue < 0 ? new re.ERR_BUFFER_OUT_OF_BOUNDS() : new re.ERR_OUT_OF_RANGE(
      me || "offset",
      `>= ${me ? 1 : 0} and <= ${ue}`,
      de
    );
  }
  const Ze = /[^+/0-9A-Za-z-_]/g;
  function qe(de) {
    if (de = de.split("=")[0], de = de.trim().replace(Ze, ""), de.length < 2)
      return "";
    for (; de.length % 4 !== 0; )
      de = de + "=";
    return de;
  }
  function gt(de, ue) {
    ue = ue || 1 / 0;
    let me;
    const Oe = de.length;
    let Ue = null;
    const ze = [];
    for (let Ve = 0; Ve < Oe; ++Ve) {
      if (me = de.charCodeAt(Ve), me > 55295 && me < 57344) {
        if (!Ue) {
          if (me > 56319) {
            (ue -= 3) > -1 && ze.push(239, 191, 189);
            continue;
          } else if (Ve + 1 === Oe) {
            (ue -= 3) > -1 && ze.push(239, 191, 189);
            continue;
          }
          Ue = me;
          continue;
        }
        if (me < 56320) {
          (ue -= 3) > -1 && ze.push(239, 191, 189), Ue = me;
          continue;
        }
        me = (Ue - 55296 << 10 | me - 56320) + 65536;
      } else
        Ue && (ue -= 3) > -1 && ze.push(239, 191, 189);
      if (Ue = null, me < 128) {
        if ((ue -= 1) < 0)
          break;
        ze.push(me);
      } else if (me < 2048) {
        if ((ue -= 2) < 0)
          break;
        ze.push(
          me >> 6 | 192,
          me & 63 | 128
        );
      } else if (me < 65536) {
        if ((ue -= 3) < 0)
          break;
        ze.push(
          me >> 12 | 224,
          me >> 6 & 63 | 128,
          me & 63 | 128
        );
      } else if (me < 1114112) {
        if ((ue -= 4) < 0)
          break;
        ze.push(
          me >> 18 | 240,
          me >> 12 & 63 | 128,
          me >> 6 & 63 | 128,
          me & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return ze;
  }
  function Xe(de) {
    const ue = [];
    for (let me = 0; me < de.length; ++me)
      ue.push(de.charCodeAt(me) & 255);
    return ue;
  }
  function Ge(de, ue) {
    let me, Oe, Ue;
    const ze = [];
    for (let Ve = 0; Ve < de.length && !((ue -= 2) < 0); ++Ve)
      me = de.charCodeAt(Ve), Oe = me >> 8, Ue = me % 256, ze.push(Ue), ze.push(Oe);
    return ze;
  }
  function J(de) {
    return u.toByteArray(qe(de));
  }
  function ye(de, ue, me, Oe) {
    let Ue;
    for (Ue = 0; Ue < Oe && !(Ue + me >= ue.length || Ue >= de.length); ++Ue)
      ue[Ue + me] = de[Ue];
    return Ue;
  }
  function we(de, ue) {
    return de instanceof ue || de != null && de.constructor != null && de.constructor.name != null && de.constructor.name === ue.name;
  }
  function We(de) {
    return de !== de;
  }
  const Re = function() {
    const de = "0123456789abcdef", ue = new Array(256);
    for (let me = 0; me < 16; ++me) {
      const Oe = me * 16;
      for (let Ue = 0; Ue < 16; ++Ue)
        ue[Oe + Ue] = de[me] + de[Ue];
    }
    return ue;
  }();
  function q(de) {
    return typeof BigInt > "u" ? ke : de;
  }
  function ke() {
    throw new Error("BigInt not supported");
  }
})(buffer$3);
const Buffer$O = buffer$3.Buffer, Blob$1 = buffer$3.Blob, BlobOptions = buffer$3.BlobOptions, Buffer$1$1 = buffer$3.Buffer, File = buffer$3.File, FileOptions = buffer$3.FileOptions, INSPECT_MAX_BYTES = buffer$3.INSPECT_MAX_BYTES, SlowBuffer$1 = buffer$3.SlowBuffer, TranscodeEncoding = buffer$3.TranscodeEncoding, atob$1 = buffer$3.atob, btoa$1 = buffer$3.btoa, constants$1 = buffer$3.constants, isAscii = buffer$3.isAscii, isUtf8 = buffer$3.isUtf8, kMaxLength = buffer$3.kMaxLength, kStringMaxLength = buffer$3.kStringMaxLength, resolveObjectURL = buffer$3.resolveObjectURL, transcode = buffer$3.transcode, dist$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Blob: Blob$1,
  BlobOptions,
  Buffer: Buffer$1$1,
  File,
  FileOptions,
  INSPECT_MAX_BYTES,
  SlowBuffer: SlowBuffer$1,
  TranscodeEncoding,
  atob: atob$1,
  btoa: btoa$1,
  constants: constants$1,
  default: Buffer$O,
  isAscii,
  isUtf8,
  kMaxLength,
  kStringMaxLength,
  resolveObjectURL,
  transcode
}, Symbol.toStringTag, { value: "Module" }));
var base64$2 = { exports: {} };
(function(a, u) {
  (function(c, l) {
    a.exports = l();
  })(typeof self < "u" ? self : typeof window < "u" ? window : commonjsGlobal$1, function() {
    var c = "3.7.7", l = c, v = typeof Buffer$O == "function", p = typeof TextDecoder == "function" ? new TextDecoder() : void 0, _ = typeof TextEncoder == "function" ? new TextEncoder() : void 0, k = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", M = Array.prototype.slice.call(k), L = function(Pe) {
      var he = {};
      return Pe.forEach(function(ve, Q) {
        return he[ve] = Q;
      }), he;
    }(M), F = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/, V = String.fromCharCode.bind(String), X = typeof Uint8Array.from == "function" ? Uint8Array.from.bind(Uint8Array) : function(Pe) {
      return new Uint8Array(Array.prototype.slice.call(Pe, 0));
    }, oe = function(Pe) {
      return Pe.replace(/=/g, "").replace(/[+\/]/g, function(he) {
        return he == "+" ? "-" : "_";
      });
    }, Y = function(Pe) {
      return Pe.replace(/[^A-Za-z0-9\+\/]/g, "");
    }, ae = function(Pe) {
      for (var he, ve, Q, le, _e = "", re = Pe.length % 3, O = 0; O < Pe.length; ) {
        if ((ve = Pe.charCodeAt(O++)) > 255 || (Q = Pe.charCodeAt(O++)) > 255 || (le = Pe.charCodeAt(O++)) > 255)
          throw new TypeError("invalid character found");
        he = ve << 16 | Q << 8 | le, _e += M[he >> 18 & 63] + M[he >> 12 & 63] + M[he >> 6 & 63] + M[he & 63];
      }
      return re ? _e.slice(0, re - 3) + "===".substring(re) : _e;
    }, ne = typeof btoa == "function" ? function(Pe) {
      return btoa(Pe);
    } : v ? function(Pe) {
      return Buffer$O.from(Pe, "binary").toString("base64");
    } : ae, fe = v ? function(Pe) {
      return Buffer$O.from(Pe).toString("base64");
    } : function(Pe) {
      for (var he = 4096, ve = [], Q = 0, le = Pe.length; Q < le; Q += he)
        ve.push(V.apply(null, Pe.subarray(Q, Q + he)));
      return ne(ve.join(""));
    }, ie = function(Pe, he) {
      return he === void 0 && (he = !1), he ? oe(fe(Pe)) : fe(Pe);
    }, ge = function(Pe) {
      if (Pe.length < 2) {
        var he = Pe.charCodeAt(0);
        return he < 128 ? Pe : he < 2048 ? V(192 | he >>> 6) + V(128 | he & 63) : V(224 | he >>> 12 & 15) + V(128 | he >>> 6 & 63) + V(128 | he & 63);
      } else {
        var he = 65536 + (Pe.charCodeAt(0) - 55296) * 1024 + (Pe.charCodeAt(1) - 56320);
        return V(240 | he >>> 18 & 7) + V(128 | he >>> 12 & 63) + V(128 | he >>> 6 & 63) + V(128 | he & 63);
      }
    }, be = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g, Ce = function(Pe) {
      return Pe.replace(be, ge);
    }, Me = v ? function(Pe) {
      return Buffer$O.from(Pe, "utf8").toString("base64");
    } : _ ? function(Pe) {
      return fe(_.encode(Pe));
    } : function(Pe) {
      return ne(Ce(Pe));
    }, Be = function(Pe, he) {
      return he === void 0 && (he = !1), he ? oe(Me(Pe)) : Me(Pe);
    }, Ae = function(Pe) {
      return Be(Pe, !0);
    }, Z = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g, z = function(Pe) {
      switch (Pe.length) {
        case 4:
          var he = (7 & Pe.charCodeAt(0)) << 18 | (63 & Pe.charCodeAt(1)) << 12 | (63 & Pe.charCodeAt(2)) << 6 | 63 & Pe.charCodeAt(3), ve = he - 65536;
          return V((ve >>> 10) + 55296) + V((ve & 1023) + 56320);
        case 3:
          return V((15 & Pe.charCodeAt(0)) << 12 | (63 & Pe.charCodeAt(1)) << 6 | 63 & Pe.charCodeAt(2));
        default:
          return V((31 & Pe.charCodeAt(0)) << 6 | 63 & Pe.charCodeAt(1));
      }
    }, P = function(Pe) {
      return Pe.replace(Z, z);
    }, S = function(Pe) {
      if (Pe = Pe.replace(/\s+/g, ""), !F.test(Pe))
        throw new TypeError("malformed base64.");
      Pe += "==".slice(2 - (Pe.length & 3));
      for (var he, ve = "", Q, le, _e = 0; _e < Pe.length; )
        he = L[Pe.charAt(_e++)] << 18 | L[Pe.charAt(_e++)] << 12 | (Q = L[Pe.charAt(_e++)]) << 6 | (le = L[Pe.charAt(_e++)]), ve += Q === 64 ? V(he >> 16 & 255) : le === 64 ? V(he >> 16 & 255, he >> 8 & 255) : V(he >> 16 & 255, he >> 8 & 255, he & 255);
      return ve;
    }, E = typeof atob == "function" ? function(Pe) {
      return atob(Y(Pe));
    } : v ? function(Pe) {
      return Buffer$O.from(Pe, "base64").toString("binary");
    } : S, I = v ? function(Pe) {
      return X(Buffer$O.from(Pe, "base64"));
    } : function(Pe) {
      return X(E(Pe).split("").map(function(he) {
        return he.charCodeAt(0);
      }));
    }, N = function(Pe) {
      return I(U(Pe));
    }, $ = v ? function(Pe) {
      return Buffer$O.from(Pe, "base64").toString("utf8");
    } : p ? function(Pe) {
      return p.decode(I(Pe));
    } : function(Pe) {
      return P(E(Pe));
    }, U = function(Pe) {
      return Y(Pe.replace(/[-_]/g, function(he) {
        return he == "-" ? "+" : "/";
      }));
    }, H = function(Pe) {
      return $(U(Pe));
    }, B = function(Pe) {
      if (typeof Pe != "string")
        return !1;
      var he = Pe.replace(/\s+/g, "").replace(/={0,2}$/, "");
      return !/[^\s0-9a-zA-Z\+/]/.test(he) || !/[^\s0-9a-zA-Z\-_]/.test(he);
    }, T = function(Pe) {
      return {
        value: Pe,
        enumerable: !1,
        writable: !0,
        configurable: !0
      };
    }, D = function() {
      var Pe = function(he, ve) {
        return Object.defineProperty(String.prototype, he, T(ve));
      };
      Pe("fromBase64", function() {
        return H(this);
      }), Pe("toBase64", function(he) {
        return Be(this, he);
      }), Pe("toBase64URI", function() {
        return Be(this, !0);
      }), Pe("toBase64URL", function() {
        return Be(this, !0);
      }), Pe("toUint8Array", function() {
        return N(this);
      });
    }, ee = function() {
      var Pe = function(he, ve) {
        return Object.defineProperty(Uint8Array.prototype, he, T(ve));
      };
      Pe("toBase64", function(he) {
        return ie(this, he);
      }), Pe("toBase64URI", function() {
        return ie(this, !0);
      }), Pe("toBase64URL", function() {
        return ie(this, !0);
      });
    }, pe = function() {
      D(), ee();
    }, Ie = {
      version: c,
      VERSION: l,
      atob: E,
      atobPolyfill: S,
      btoa: ne,
      btoaPolyfill: ae,
      fromBase64: H,
      toBase64: Be,
      encode: Be,
      encodeURI: Ae,
      encodeURL: Ae,
      utob: Ce,
      btou: P,
      decode: H,
      isValid: B,
      fromUint8Array: ie,
      toUint8Array: N,
      extendString: D,
      extendUint8Array: ee,
      extendBuiltins: pe
    };
    return Ie.Base64 = {}, Object.keys(Ie).forEach(function(Pe) {
      return Ie.Base64[Pe] = Ie[Pe];
    }), Ie;
  });
})(base64$2);
var base64Exports = base64$2.exports;
Object.defineProperty(fetch$1, "__esModule", { value: !0 });
fetch$1.FetchTransport = void 0;
const abort_controller_x_1$3 = require$$1$5, js_base64_1$2 = base64Exports, nice_grpc_common_1$6 = lib;
function FetchTransport(a) {
  return async function* ({ url: c, body: l, metadata: v, signal: p, method: _ }) {
    let k;
    if (_.requestStream) {
      let V;
      k = new ReadableStream({
        type: "bytes",
        start() {
          V = l[Symbol.asyncIterator]();
        },
        async pull(X) {
          const { done: oe, value: Y } = await V.next();
          oe ? X.close() : X.enqueue(Y);
        },
        async cancel() {
          var X, oe;
          await ((oe = (X = V).return) === null || oe === void 0 ? void 0 : oe.call(X));
        }
      });
    } else {
      let V;
      for await (const X of l) {
        V = X;
        break;
      }
      k = V;
    }
    const M = await fetch(c, {
      method: "POST",
      body: k,
      headers: metadataToHeaders(v),
      signal: p,
      cache: a == null ? void 0 : a.cache,
      duplex: "half",
      credentials: a == null ? void 0 : a.credentials
    });
    if (yield {
      type: "header",
      header: headersToMetadata(M.headers)
    }, !M.ok) {
      const V = await M.text();
      throw new nice_grpc_common_1$6.ClientError(_.path, getStatusFromHttpCode(M.status), getErrorDetailsFromHttpResponse(M.status, V));
    }
    (0, abort_controller_x_1$3.throwIfAborted)(p);
    const L = M.body.getReader(), F = () => {
      L.cancel().catch(() => {
      });
    };
    p.addEventListener("abort", F);
    try {
      for (; ; ) {
        const { done: V, value: X } = await L.read();
        if (X != null && (yield {
          type: "data",
          data: X
        }), V)
          break;
      }
    } finally {
      p.removeEventListener("abort", F), (0, abort_controller_x_1$3.throwIfAborted)(p);
    }
  };
}
fetch$1.FetchTransport = FetchTransport;
function metadataToHeaders(a) {
  const u = new Headers();
  for (const [c, l] of a)
    for (const v of l)
      u.append(c, typeof v == "string" ? v : js_base64_1$2.Base64.fromUint8Array(v));
  return u;
}
function headersToMetadata(a) {
  const u = new nice_grpc_common_1$6.Metadata();
  for (const [c, l] of a)
    if (c.endsWith("-bin"))
      for (const v of l.split(/,\s?/))
        u.append(c, js_base64_1$2.Base64.toUint8Array(v));
    else
      u.set(c, l);
  return u;
}
function getStatusFromHttpCode(a) {
  switch (a) {
    case 400:
      return nice_grpc_common_1$6.Status.INTERNAL;
    case 401:
      return nice_grpc_common_1$6.Status.UNAUTHENTICATED;
    case 403:
      return nice_grpc_common_1$6.Status.PERMISSION_DENIED;
    case 404:
      return nice_grpc_common_1$6.Status.UNIMPLEMENTED;
    case 429:
    case 502:
    case 503:
    case 504:
      return nice_grpc_common_1$6.Status.UNAVAILABLE;
    default:
      return nice_grpc_common_1$6.Status.UNKNOWN;
  }
}
function getErrorDetailsFromHttpResponse(a, u) {
  return `Received HTTP ${a} response: ` + (u.length > 1e3 ? u.slice(0, 1e3) + "... (truncated)" : u);
}
Object.defineProperty(channel, "__esModule", { value: !0 });
channel.createChannel = void 0;
const fetch_1 = fetch$1;
function createChannel(a, u = (0, fetch_1.FetchTransport)()) {
  return { address: a, transport: u };
}
channel.createChannel = createChannel;
var ClientFactory = {}, createBidiStreamingMethod$1 = {}, isAsyncIterable$1 = {};
Object.defineProperty(isAsyncIterable$1, "__esModule", { value: !0 });
isAsyncIterable$1.isAsyncIterable = void 0;
function isAsyncIterable(a) {
  return a != null && Symbol.asyncIterator in a;
}
isAsyncIterable$1.isAsyncIterable = isAsyncIterable;
var makeCall$1 = {}, decodeResponse$1 = {}, concatBuffers$1 = {};
Object.defineProperty(concatBuffers$1, "__esModule", { value: !0 });
concatBuffers$1.concatBuffers = void 0;
function concatBuffers(a, u) {
  if (a.length === 1)
    return a[0];
  const c = new Uint8Array(u);
  let l = 0;
  for (const v of a)
    c.set(v, l), l += v.length;
  return c;
}
concatBuffers$1.concatBuffers = concatBuffers;
var decodeMetadata$1 = {};
Object.defineProperty(decodeMetadata$1, "__esModule", { value: !0 });
decodeMetadata$1.decodeMetadata = void 0;
const nice_grpc_common_1$5 = lib, js_base64_1$1 = base64Exports;
function decodeMetadata(a) {
  const u = (0, nice_grpc_common_1$5.Metadata)(), c = new TextDecoder().decode(a);
  for (const l of c.split(`\r
`)) {
    if (!l)
      continue;
    const v = l.indexOf(":");
    if (v === -1)
      throw new Error(`Invalid metadata line: ${l}`);
    const p = l.slice(0, v).trim().toLowerCase(), _ = l.slice(v + 1).trim();
    if (p.endsWith("-bin"))
      for (const k of _.split(/,\s?/))
        u.append(p, js_base64_1$1.Base64.toUint8Array(k));
    else
      u.append(p, _);
  }
  return u;
}
decodeMetadata$1.decodeMetadata = decodeMetadata;
var framing = {};
(function(a) {
  Object.defineProperty(a, "__esModule", { value: !0 }), a.encodeFrame = a.parseLpmHeader = a.LPM_HEADER_LENGTH = void 0, a.LPM_HEADER_LENGTH = 5;
  function u(l) {
    if (l.length !== a.LPM_HEADER_LENGTH)
      throw new Error(`Invalid LPM header length: ${l.length}`);
    const v = new DataView(l.buffer, l.byteOffset, l.byteLength), p = (v.getUint8(0) & 1) !== 0, _ = (v.getUint8(0) & 128) !== 0, k = v.getUint32(1);
    return {
      compressed: p,
      isMetadata: _,
      length: k
    };
  }
  a.parseLpmHeader = u;
  function c(l) {
    const v = new Uint8Array(a.LPM_HEADER_LENGTH + l.length);
    return new DataView(v.buffer, 1, 4).setUint32(0, l.length, !1), v.set(l, a.LPM_HEADER_LENGTH), v;
  }
  a.encodeFrame = c;
})(framing);
Object.defineProperty(decodeResponse$1, "__esModule", { value: !0 });
decodeResponse$1.decodeResponse = void 0;
const concatBuffers_1 = concatBuffers$1, decodeMetadata_1 = decodeMetadata$1, framing_1$1 = framing;
async function* decodeResponse({ response: a, decode: u, onHeader: c, onTrailer: l }) {
  let v = !1, p = !1, _ = !1, k = V(framing_1$1.LPM_HEADER_LENGTH), M;
  for await (const X of a)
    if (X.type === "header")
      L(X.header);
    else if (X.type === "trailer")
      F(X.trailer);
    else if (X.type === "data") {
      if (p)
        throw new Error("Received data after trailer");
      let { data: oe } = X;
      for (; oe.length > 0 || (M == null ? void 0 : M.length) === 0; ) {
        const Y = Math.min(oe.length, k.targetLength - k.totalLength), ae = oe.subarray(0, Y);
        if (oe = oe.subarray(Y), k.chunks.push(ae), k.totalLength += ae.length, k.totalLength === k.targetLength) {
          const ne = (0, concatBuffers_1.concatBuffers)(k.chunks, k.totalLength);
          if (M == null)
            M = (0, framing_1$1.parseLpmHeader)(ne), k = V(M.length);
          else {
            if (M.compressed)
              throw new Error("Compressed messages not supported");
            if (M.isMetadata)
              v ? F((0, decodeMetadata_1.decodeMetadata)(ne)) : L((0, decodeMetadata_1.decodeMetadata)(ne));
            else {
              if (!v)
                throw new Error("Received data before header");
              yield u(ne), _ = !0;
            }
            M = void 0, k = V(framing_1$1.LPM_HEADER_LENGTH);
          }
        }
      }
    }
  function L(X) {
    if (v)
      throw new Error("Received multiple headers");
    if (_)
      throw new Error("Received header after data");
    if (p)
      throw new Error("Received header after trailer");
    v = !0, c(X);
  }
  function F(X) {
    if (p)
      throw new Error("Received multiple trailers");
    p = !0, l(X);
  }
  function V(X) {
    return {
      chunks: [],
      totalLength: 0,
      targetLength: X
    };
  }
}
decodeResponse$1.decodeResponse = decodeResponse;
var encodeRequest$1 = {};
Object.defineProperty(encodeRequest$1, "__esModule", { value: !0 });
encodeRequest$1.encodeRequest = void 0;
const framing_1 = framing;
async function* encodeRequest({ request: a, encode: u }) {
  for await (const c of a) {
    const l = u(c);
    yield (0, framing_1.encodeFrame)(l);
  }
}
encodeRequest$1.encodeRequest = encodeRequest;
var makeInternalErrorMessage$1 = {};
Object.defineProperty(makeInternalErrorMessage$1, "__esModule", { value: !0 });
makeInternalErrorMessage$1.makeInternalErrorMessage = void 0;
function makeInternalErrorMessage(a) {
  return a == null || typeof a != "object" ? String(a) : typeof a.message == "string" ? a.message : JSON.stringify(a);
}
makeInternalErrorMessage$1.makeInternalErrorMessage = makeInternalErrorMessage;
var parseTrailer$1 = {};
Object.defineProperty(parseTrailer$1, "__esModule", { value: !0 });
parseTrailer$1.parseTrailer = void 0;
const nice_grpc_common_1$4 = lib;
function parseTrailer(a) {
  let u;
  const c = a.get("grpc-status");
  if (c != null) {
    const p = +c;
    if (p in nice_grpc_common_1$4.Status)
      u = p;
    else
      throw new Error(`Received invalid status code from server: ${c}`);
  } else
    throw new Error("Received no status code from server");
  let l = a.get("grpc-message");
  if (l != null)
    try {
      l = decodeURIComponent(l);
    } catch {
    }
  const v = (0, nice_grpc_common_1$4.Metadata)(a);
  return v.delete("grpc-status"), v.delete("grpc-message"), {
    status: u,
    message: l,
    trailer: v
  };
}
parseTrailer$1.parseTrailer = parseTrailer;
Object.defineProperty(makeCall$1, "__esModule", { value: !0 });
makeCall$1.makeCall = void 0;
const abort_controller_x_1$2 = require$$1$5, nice_grpc_common_1$3 = lib, decodeResponse_1 = decodeResponse$1, encodeRequest_1 = encodeRequest$1, makeInternalErrorMessage_1 = makeInternalErrorMessage$1, parseTrailer_1 = parseTrailer$1;
async function* makeCall(a, u, c, l) {
  const { metadata: v, signal: p = new AbortController().signal, onHeader: _, onTrailer: k } = l;
  let M = !1, L, F;
  function V(be) {
    if (M) {
      if (new Map(be).size > 0)
        throw new nice_grpc_common_1$3.ClientError(a.path, nice_grpc_common_1$3.Status.INTERNAL, "Received non-empty trailer after trailers-only response");
      return;
    }
    const Ce = (0, parseTrailer_1.parseTrailer)(be);
    ({ status: L, message: F } = Ce), k == null || k(Ce.trailer);
  }
  const X = (0, nice_grpc_common_1$3.Metadata)(v);
  X.set("content-type", "application/grpc-web+proto"), X.set("x-grpc-web", "1");
  const oe = new AbortController(), Y = () => {
    oe.abort();
  };
  p.addEventListener("abort", Y);
  let ae = !1, ne;
  async function* fe() {
    try {
      for await (const be of c) {
        if (ae)
          throw new Error("Request finished");
        yield be;
      }
    } catch (be) {
      throw ne = { err: be }, oe.abort(), be;
    }
  }
  async function* ie() {
    try {
      return yield* u.transport({
        url: u.address + a.path,
        metadata: X,
        body: (0, encodeRequest_1.encodeRequest)({
          request: fe(),
          encode: a.requestSerialize
        }),
        signal: oe.signal,
        method: a
      });
    } catch (be) {
      throw (0, abort_controller_x_1$2.rethrowAbortError)(be), new nice_grpc_common_1$3.ClientError(a.path, nice_grpc_common_1$3.Status.UNKNOWN, `Transport error: ${(0, makeInternalErrorMessage_1.makeInternalErrorMessage)(be)}`);
    }
  }
  const ge = (0, decodeResponse_1.decodeResponse)({
    response: ie(),
    decode: a.responseDeserialize,
    onHeader(be) {
      be.has("grpc-status") ? (V(be), M = !0) : _ == null || _(be);
    },
    onTrailer(be) {
      V(be);
    }
  });
  try {
    yield* ge;
  } catch (be) {
    throw ne !== void 0 ? ne.err : be instanceof nice_grpc_common_1$3.ClientError || (0, abort_controller_x_1$2.isAbortError)(be) ? be : new nice_grpc_common_1$3.ClientError(a.path, nice_grpc_common_1$3.Status.INTERNAL, (0, makeInternalErrorMessage_1.makeInternalErrorMessage)(be));
  } finally {
    if (ae = !0, p.removeEventListener("abort", Y), L != null && L !== nice_grpc_common_1$3.Status.OK)
      throw new nice_grpc_common_1$3.ClientError(a.path, L, F ?? "");
  }
  if (L == null)
    throw new nice_grpc_common_1$3.ClientError(a.path, nice_grpc_common_1$3.Status.UNKNOWN, 'Response stream closed without gRPC status. This may indicate a misconfigured CORS policy on the server: Access-Control-Expose-Headers must include "grpc-status" and "grpc-message".');
}
makeCall$1.makeCall = makeCall;
Object.defineProperty(createBidiStreamingMethod$1, "__esModule", { value: !0 });
createBidiStreamingMethod$1.createBidiStreamingMethod = void 0;
const isAsyncIterable_1$3 = isAsyncIterable$1, makeCall_1$3 = makeCall$1;
function createBidiStreamingMethod(a, u, c, l) {
  const v = {
    path: a.path,
    requestStream: a.requestStream,
    responseStream: a.responseStream,
    options: a.options
  };
  async function* p(k, M) {
    if (!(0, isAsyncIterable_1$3.isAsyncIterable)(k))
      throw new Error("A middleware passed invalid request to next(): expected a single message for bidirectional streaming method");
    yield* (0, makeCall_1$3.makeCall)(a, u, k, M);
  }
  const _ = c == null ? p : (k, M) => c({
    method: v,
    requestStream: !0,
    request: k,
    responseStream: !0,
    next: p
  }, M);
  return (k, M) => {
    const F = _(k, {
      ...l,
      ...M
    })[Symbol.asyncIterator]();
    return {
      [Symbol.asyncIterator]() {
        return {
          async next() {
            const V = await F.next();
            return V.done && V.value != null ? await F.throw(new Error("A middleware returned a message, but expected to return void for bidirectional streaming method")) : V;
          },
          return() {
            return F.return();
          },
          throw(V) {
            return F.throw(V);
          }
        };
      }
    };
  };
}
createBidiStreamingMethod$1.createBidiStreamingMethod = createBidiStreamingMethod;
var createClientStreamingMethod$1 = {};
Object.defineProperty(createClientStreamingMethod$1, "__esModule", { value: !0 });
createClientStreamingMethod$1.createClientStreamingMethod = void 0;
const nice_grpc_common_1$2 = lib, isAsyncIterable_1$2 = isAsyncIterable$1, makeCall_1$2 = makeCall$1;
function createClientStreamingMethod(a, u, c, l) {
  const v = {
    path: a.path,
    requestStream: a.requestStream,
    responseStream: a.responseStream,
    options: a.options
  };
  async function* p(k, M) {
    if (!(0, isAsyncIterable_1$2.isAsyncIterable)(k))
      throw Error("A middleware passed invalid request to next(): expected a single message for client streaming method");
    const L = (0, makeCall_1$2.makeCall)(a, u, k, M);
    let F;
    for await (const V of L) {
      if (F != null)
        throw new nice_grpc_common_1$2.ClientError(a.path, nice_grpc_common_1$2.Status.INTERNAL, "Received more than one message from server for client streaming method");
      F = V;
    }
    if (F == null)
      throw new nice_grpc_common_1$2.ClientError(a.path, nice_grpc_common_1$2.Status.INTERNAL, "Server did not return a response");
    return F;
  }
  const _ = c == null ? p : (k, M) => c({
    method: v,
    requestStream: !0,
    request: k,
    responseStream: !1,
    next: p
  }, M);
  return async (k, M) => {
    const F = _(k, {
      ...l,
      ...M
    })[Symbol.asyncIterator]();
    let V = await F.next();
    for (; ; ) {
      if (!V.done) {
        V = await F.throw(new Error("A middleware yielded a message, but expected to only return a message for client streaming method"));
        continue;
      }
      if (V.value == null) {
        V = await F.throw(new Error("A middleware returned void, but expected to return a message for client streaming method"));
        continue;
      }
      return V.value;
    }
  };
}
createClientStreamingMethod$1.createClientStreamingMethod = createClientStreamingMethod;
var createServerStreamingMethod$1 = {}, asyncIterableOf$1 = {};
Object.defineProperty(asyncIterableOf$1, "__esModule", { value: !0 });
asyncIterableOf$1.asyncIterableOf = void 0;
async function* asyncIterableOf(a) {
  yield a;
}
asyncIterableOf$1.asyncIterableOf = asyncIterableOf;
Object.defineProperty(createServerStreamingMethod$1, "__esModule", { value: !0 });
createServerStreamingMethod$1.createServerStreamingMethod = void 0;
const asyncIterableOf_1$1 = asyncIterableOf$1, isAsyncIterable_1$1 = isAsyncIterable$1, makeCall_1$1 = makeCall$1;
function createServerStreamingMethod(a, u, c, l) {
  const v = {
    path: a.path,
    requestStream: a.requestStream,
    responseStream: a.responseStream,
    options: a.options
  };
  async function* p(k, M) {
    if ((0, isAsyncIterable_1$1.isAsyncIterable)(k))
      throw new Error("A middleware passed invalid request to next(): expected a single message for server streaming method");
    yield* (0, makeCall_1$1.makeCall)(a, u, (0, asyncIterableOf_1$1.asyncIterableOf)(k), M);
  }
  const _ = c == null ? p : (k, M) => c({
    method: v,
    requestStream: !1,
    request: k,
    responseStream: !0,
    next: p
  }, M);
  return (k, M) => {
    const F = _(k, {
      ...l,
      ...M
    })[Symbol.asyncIterator]();
    return {
      [Symbol.asyncIterator]() {
        return {
          async next() {
            const V = await F.next();
            return V.done && V.value != null ? await F.throw(new Error("A middleware returned a message, but expected to return void for server streaming method")) : V;
          },
          return() {
            return F.return();
          },
          throw(V) {
            return F.throw(V);
          }
        };
      }
    };
  };
}
createServerStreamingMethod$1.createServerStreamingMethod = createServerStreamingMethod;
var createUnaryMethod$1 = {};
Object.defineProperty(createUnaryMethod$1, "__esModule", { value: !0 });
createUnaryMethod$1.createUnaryMethod = void 0;
const nice_grpc_common_1$1 = lib, asyncIterableOf_1 = asyncIterableOf$1, isAsyncIterable_1 = isAsyncIterable$1, makeCall_1 = makeCall$1;
function createUnaryMethod(a, u, c, l) {
  const v = {
    path: a.path,
    requestStream: a.requestStream,
    responseStream: a.responseStream,
    options: a.options
  };
  async function* p(k, M) {
    if ((0, isAsyncIterable_1.isAsyncIterable)(k))
      throw new Error("A middleware passed invalid request to next(): expected a single message for unary method");
    const L = (0, makeCall_1.makeCall)(a, u, (0, asyncIterableOf_1.asyncIterableOf)(k), M);
    let F;
    for await (const V of L) {
      if (F != null)
        throw new nice_grpc_common_1$1.ClientError(a.path, nice_grpc_common_1$1.Status.INTERNAL, "Received more than one message from server for unary method");
      F = V;
    }
    if (F == null)
      throw new nice_grpc_common_1$1.ClientError(a.path, nice_grpc_common_1$1.Status.INTERNAL, "Server did not return a response");
    return F;
  }
  const _ = c == null ? p : (k, M) => c({
    method: v,
    requestStream: !1,
    request: k,
    responseStream: !1,
    next: p
  }, M);
  return async (k, M) => {
    const F = _(k, {
      ...l,
      ...M
    })[Symbol.asyncIterator]();
    let V = await F.next();
    for (; ; ) {
      if (!V.done) {
        V = await F.throw(new Error("A middleware yielded a message, but expected to only return a message for unary method"));
        continue;
      }
      if (V.value == null) {
        V = await F.throw(new Error("A middleware returned void, but expected to return a message for unary method"));
        continue;
      }
      return V.value;
    }
  };
}
createUnaryMethod$1.createUnaryMethod = createUnaryMethod;
Object.defineProperty(ClientFactory, "__esModule", { value: !0 });
ClientFactory.createClient = ClientFactory.createClientFactory = void 0;
const nice_grpc_common_1 = lib, service_definitions_1 = serviceDefinitions, createBidiStreamingMethod_1 = createBidiStreamingMethod$1, createClientStreamingMethod_1 = createClientStreamingMethod$1, createServerStreamingMethod_1 = createServerStreamingMethod$1, createUnaryMethod_1 = createUnaryMethod$1;
function createClientFactory() {
  return createClientFactoryWithMiddleware();
}
ClientFactory.createClientFactory = createClientFactory;
function createClient(a, u, c) {
  return createClientFactory().create(a, u, c);
}
ClientFactory.createClient = createClient;
function createClientFactoryWithMiddleware(a) {
  return {
    use(u) {
      return createClientFactoryWithMiddleware(a == null ? u : (0, nice_grpc_common_1.composeClientMiddleware)(a, u));
    },
    create(u, c, l = {}) {
      const v = {}, p = Object.entries((0, service_definitions_1.normalizeServiceDefinition)(u));
      for (const [_, k] of p) {
        const M = {
          ...l["*"],
          ...l[_]
        };
        k.requestStream ? k.responseStream ? v[_] = (0, createBidiStreamingMethod_1.createBidiStreamingMethod)(k, c, a, M) : v[_] = (0, createClientStreamingMethod_1.createClientStreamingMethod)(k, c, a, M) : k.responseStream ? v[_] = (0, createServerStreamingMethod_1.createServerStreamingMethod)(k, c, a, M) : v[_] = (0, createUnaryMethod_1.createUnaryMethod)(k, c, a, M);
      }
      return v;
    }
  };
}
var Client = {};
Object.defineProperty(Client, "__esModule", { value: !0 });
var websocket = {};
const global$1 = globalThis || void 0 || self;
var ws$1 = null;
typeof WebSocket < "u" ? ws$1 = WebSocket : typeof MozWebSocket < "u" ? ws$1 = MozWebSocket : typeof global$1 < "u" ? ws$1 = global$1.WebSocket || global$1.MozWebSocket : typeof window < "u" ? ws$1 = window.WebSocket || window.MozWebSocket : typeof self < "u" && (ws$1 = self.WebSocket || self.MozWebSocket);
const ws$2 = ws$1, browser$g = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: ws$2
}, Symbol.toStringTag, { value: "Module" })), require$$1$4 = /* @__PURE__ */ getAugmentedNamespace(browser$g);
var AsyncSink$1 = {};
Object.defineProperty(AsyncSink$1, "__esModule", { value: !0 });
AsyncSink$1.AsyncSink = void 0;
const ARRAY_VALUE = "value", ARRAY_ERROR = "error";
class AsyncSink {
  constructor() {
    this._ended = !1, this._values = [], this._resolvers = [];
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  write(u) {
    this._push({ type: ARRAY_VALUE, value: u });
  }
  error(u) {
    this._push({ type: ARRAY_ERROR, error: u });
  }
  _push(u) {
    if (!this._ended)
      if (this._resolvers.length > 0) {
        const { resolve: c, reject: l } = this._resolvers.shift();
        u.type === ARRAY_ERROR ? l(u.error) : c({ done: !1, value: u.value });
      } else
        this._values.push(u);
  }
  next() {
    if (this._values.length > 0) {
      const { type: u, value: c, error: l } = this._values.shift();
      return u === ARRAY_ERROR ? Promise.reject(l) : Promise.resolve({ done: !1, value: c });
    }
    return this._ended ? Promise.resolve({ done: !0 }) : new Promise((u, c) => {
      this._resolvers.push({ resolve: u, reject: c });
    });
  }
  end() {
    for (; this._resolvers.length > 0; )
      this._resolvers.shift().resolve({ done: !0 });
    this._ended = !0;
  }
}
AsyncSink$1.AsyncSink = AsyncSink;
var __importDefault$e = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(websocket, "__esModule", { value: !0 });
websocket.WebsocketTransport = void 0;
const abort_controller_x_1$1 = require$$1$5, isomorphic_ws_1$1 = __importDefault$e(require$$1$4), js_base64_1 = base64Exports, AsyncSink_1 = AsyncSink$1;
function WebsocketTransport() {
  return async function* ({ url: a, body: u, metadata: c, signal: l }) {
    if (l.aborted)
      throw new abort_controller_x_1$1.AbortError();
    const v = new AsyncSink_1.AsyncSink();
    l.addEventListener("abort", () => {
      v.error(new abort_controller_x_1$1.AbortError());
    });
    const p = new URL(a);
    p.protocol = p.protocol.replace("http", "ws");
    const _ = new isomorphic_ws_1$1.default(p, ["grpc-websockets"]);
    _.binaryType = "arraybuffer", _.addEventListener("message", (M) => {
      M.data instanceof ArrayBuffer ? v.write({
        type: "data",
        data: new Uint8Array(M.data)
      }) : v.error(new Error(`Unexpected message type: ${typeof M.data}`));
    }), _.addEventListener("close", (M) => {
      M.wasClean ? v.end() : v.error(new Error(`WebSocket closed with code ${M.code}` + (M.reason && `: ${M.reason}`)));
    });
    const k = new AbortController();
    pipeBody(k.signal, c, u, _).catch((M) => {
      (0, abort_controller_x_1$1.isAbortError)(M) || v.error(M);
    });
    try {
      return yield* v;
    } finally {
      k.abort(), _.close();
    }
  };
}
websocket.WebsocketTransport = WebsocketTransport;
async function pipeBody(a, u, c, l) {
  l.readyState == isomorphic_ws_1$1.default.CONNECTING && await (0, abort_controller_x_1$1.waitForEvent)(a, l, "open"), l.send(encodeMetadata(u));
  for await (const v of c) {
    (0, abort_controller_x_1$1.throwIfAborted)(a);
    const p = new Uint8Array(v.length + 1);
    p.set([0], 0), p.set(v, 1), l.send(p);
  }
  l.send(new Uint8Array([1]));
}
function encodeMetadata(a) {
  let u = "";
  for (const [c, l] of a)
    for (const v of l) {
      const p = typeof v == "string" ? v : js_base64_1.Base64.fromUint8Array(v), _ = `${c}: ${p}\r
`;
      for (let k = 0; k < _.length; k++) {
        const M = _.charCodeAt(k);
        if (!isValidCharCode(M))
          throw new Error(`Metadata contains invalid characters: '${_}'`);
      }
      u += _;
    }
  return new TextEncoder().encode(u);
}
function isValidCharCode(a) {
  return a === 9 || a === 10 || a === 13 || a >= 32 && a <= 126;
}
var browser$f = {};
Object.defineProperty(browser$f, "__esModule", { value: !0 });
browser$f.NodeHttpTransport = void 0;
function NodeHttpTransport() {
  throw new Error("NodeHttpTransport is not supported in the browser");
}
browser$f.NodeHttpTransport = NodeHttpTransport;
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(k, M, L, F) {
    F === void 0 && (F = L);
    var V = Object.getOwnPropertyDescriptor(M, L);
    (!V || ("get" in V ? !M.__esModule : V.writable || V.configurable)) && (V = { enumerable: !0, get: function() {
      return M[L];
    } }), Object.defineProperty(k, F, V);
  } : function(k, M, L, F) {
    F === void 0 && (F = L), k[F] = M[L];
  }), c = commonjsGlobal$1 && commonjsGlobal$1.__exportStar || function(k, M) {
    for (var L in k)
      L !== "default" && !Object.prototype.hasOwnProperty.call(M, L) && u(M, k, L);
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.NodeHttpTransport = a.WebsocketTransport = a.FetchTransport = a.Status = a.Metadata = a.composeClientMiddleware = a.ClientError = void 0;
  var l = lib;
  Object.defineProperty(a, "ClientError", { enumerable: !0, get: function() {
    return l.ClientError;
  } }), Object.defineProperty(a, "composeClientMiddleware", { enumerable: !0, get: function() {
    return l.composeClientMiddleware;
  } }), Object.defineProperty(a, "Metadata", { enumerable: !0, get: function() {
    return l.Metadata;
  } }), Object.defineProperty(a, "Status", { enumerable: !0, get: function() {
    return l.Status;
  } }), c(serviceDefinitions, a), c(channel, a), c(ClientFactory, a), c(Client, a);
  var v = fetch$1;
  Object.defineProperty(a, "FetchTransport", { enumerable: !0, get: function() {
    return v.FetchTransport;
  } });
  var p = websocket;
  Object.defineProperty(a, "WebsocketTransport", { enumerable: !0, get: function() {
    return p.WebsocketTransport;
  } });
  var _ = browser$f;
  Object.defineProperty(a, "NodeHttpTransport", { enumerable: !0, get: function() {
    return _.NodeHttpTransport;
  } });
})(lib$1);
var dist$2 = {}, api$4 = {}, umd = { exports: {} };
(function(a, u) {
  var c = function(l) {
    Object.defineProperty(l, "__esModule", {
      value: !0
    }), l.default = void 0;
    /**
     * @license
     * Copyright 2009 The Closure Library Authors
     * Copyright 2020 Daniel Wirtz / The long.js Authors.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
     * SPDX-License-Identifier: Apache-2.0
     */
    var v = null;
    try {
      v = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
    } catch {
    }
    function p($, U, H) {
      this.low = $ | 0, this.high = U | 0, this.unsigned = !!H;
    }
    p.prototype.__isLong__, Object.defineProperty(p.prototype, "__isLong__", {
      value: !0
    });
    function _($) {
      return ($ && $.__isLong__) === !0;
    }
    function k($) {
      var U = Math.clz32($ & -$);
      return $ ? 31 - U : U;
    }
    p.isLong = _;
    var M = {}, L = {};
    function F($, U) {
      var H, B, T;
      return U ? ($ >>>= 0, (T = 0 <= $ && $ < 256) && (B = L[$], B) ? B : (H = X($, 0, !0), T && (L[$] = H), H)) : ($ |= 0, (T = -128 <= $ && $ < 128) && (B = M[$], B) ? B : (H = X($, $ < 0 ? -1 : 0, !1), T && (M[$] = H), H));
    }
    p.fromInt = F;
    function V($, U) {
      if (isNaN($))
        return U ? Be : Me;
      if (U) {
        if ($ < 0)
          return Be;
        if ($ >= ge)
          return S;
      } else {
        if ($ <= -be)
          return E;
        if ($ + 1 >= be)
          return P;
      }
      return $ < 0 ? V(-$, U).neg() : X($ % ie | 0, $ / ie | 0, U);
    }
    p.fromNumber = V;
    function X($, U, H) {
      return new p($, U, H);
    }
    p.fromBits = X;
    var oe = Math.pow;
    function Y($, U, H) {
      if ($.length === 0)
        throw Error("empty string");
      if (typeof U == "number" ? (H = U, U = !1) : U = !!U, $ === "NaN" || $ === "Infinity" || $ === "+Infinity" || $ === "-Infinity")
        return U ? Be : Me;
      if (H = H || 10, H < 2 || 36 < H)
        throw RangeError("radix");
      var B;
      if ((B = $.indexOf("-")) > 0)
        throw Error("interior hyphen");
      if (B === 0)
        return Y($.substring(1), U, H).neg();
      for (var T = V(oe(H, 8)), D = Me, ee = 0; ee < $.length; ee += 8) {
        var pe = Math.min(8, $.length - ee), Ie = parseInt($.substring(ee, ee + pe), H);
        if (pe < 8) {
          var Pe = V(oe(H, pe));
          D = D.mul(Pe).add(V(Ie));
        } else
          D = D.mul(T), D = D.add(V(Ie));
      }
      return D.unsigned = U, D;
    }
    p.fromString = Y;
    function ae($, U) {
      return typeof $ == "number" ? V($, U) : typeof $ == "string" ? Y($, U) : X($.low, $.high, typeof U == "boolean" ? U : $.unsigned);
    }
    p.fromValue = ae;
    var ne = 65536, fe = 1 << 24, ie = ne * ne, ge = ie * ie, be = ge / 2, Ce = F(fe), Me = F(0);
    p.ZERO = Me;
    var Be = F(0, !0);
    p.UZERO = Be;
    var Ae = F(1);
    p.ONE = Ae;
    var Z = F(1, !0);
    p.UONE = Z;
    var z = F(-1);
    p.NEG_ONE = z;
    var P = X(-1, 2147483647, !1);
    p.MAX_VALUE = P;
    var S = X(-1, -1, !0);
    p.MAX_UNSIGNED_VALUE = S;
    var E = X(0, -2147483648, !1);
    p.MIN_VALUE = E;
    var I = p.prototype;
    I.toInt = function() {
      return this.unsigned ? this.low >>> 0 : this.low;
    }, I.toNumber = function() {
      return this.unsigned ? (this.high >>> 0) * ie + (this.low >>> 0) : this.high * ie + (this.low >>> 0);
    }, I.toString = function(U) {
      if (U = U || 10, U < 2 || 36 < U)
        throw RangeError("radix");
      if (this.isZero())
        return "0";
      if (this.isNegative())
        if (this.eq(E)) {
          var H = V(U), B = this.div(H), T = B.mul(H).sub(this);
          return B.toString(U) + T.toInt().toString(U);
        } else
          return "-" + this.neg().toString(U);
      for (var D = V(oe(U, 6), this.unsigned), ee = this, pe = ""; ; ) {
        var Ie = ee.div(D), Pe = ee.sub(Ie.mul(D)).toInt() >>> 0, he = Pe.toString(U);
        if (ee = Ie, ee.isZero())
          return he + pe;
        for (; he.length < 6; )
          he = "0" + he;
        pe = "" + he + pe;
      }
    }, I.getHighBits = function() {
      return this.high;
    }, I.getHighBitsUnsigned = function() {
      return this.high >>> 0;
    }, I.getLowBits = function() {
      return this.low;
    }, I.getLowBitsUnsigned = function() {
      return this.low >>> 0;
    }, I.getNumBitsAbs = function() {
      if (this.isNegative())
        return this.eq(E) ? 64 : this.neg().getNumBitsAbs();
      for (var U = this.high != 0 ? this.high : this.low, H = 31; H > 0 && !(U & 1 << H); H--)
        ;
      return this.high != 0 ? H + 33 : H + 1;
    }, I.isZero = function() {
      return this.high === 0 && this.low === 0;
    }, I.eqz = I.isZero, I.isNegative = function() {
      return !this.unsigned && this.high < 0;
    }, I.isPositive = function() {
      return this.unsigned || this.high >= 0;
    }, I.isOdd = function() {
      return (this.low & 1) === 1;
    }, I.isEven = function() {
      return (this.low & 1) === 0;
    }, I.equals = function(U) {
      return _(U) || (U = ae(U)), this.unsigned !== U.unsigned && this.high >>> 31 === 1 && U.high >>> 31 === 1 ? !1 : this.high === U.high && this.low === U.low;
    }, I.eq = I.equals, I.notEquals = function(U) {
      return !this.eq(
        /* validates */
        U
      );
    }, I.neq = I.notEquals, I.ne = I.notEquals, I.lessThan = function(U) {
      return this.comp(
        /* validates */
        U
      ) < 0;
    }, I.lt = I.lessThan, I.lessThanOrEqual = function(U) {
      return this.comp(
        /* validates */
        U
      ) <= 0;
    }, I.lte = I.lessThanOrEqual, I.le = I.lessThanOrEqual, I.greaterThan = function(U) {
      return this.comp(
        /* validates */
        U
      ) > 0;
    }, I.gt = I.greaterThan, I.greaterThanOrEqual = function(U) {
      return this.comp(
        /* validates */
        U
      ) >= 0;
    }, I.gte = I.greaterThanOrEqual, I.ge = I.greaterThanOrEqual, I.compare = function(U) {
      if (_(U) || (U = ae(U)), this.eq(U))
        return 0;
      var H = this.isNegative(), B = U.isNegative();
      return H && !B ? -1 : !H && B ? 1 : this.unsigned ? U.high >>> 0 > this.high >>> 0 || U.high === this.high && U.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(U).isNegative() ? -1 : 1;
    }, I.comp = I.compare, I.negate = function() {
      return !this.unsigned && this.eq(E) ? E : this.not().add(Ae);
    }, I.neg = I.negate, I.add = function(U) {
      _(U) || (U = ae(U));
      var H = this.high >>> 16, B = this.high & 65535, T = this.low >>> 16, D = this.low & 65535, ee = U.high >>> 16, pe = U.high & 65535, Ie = U.low >>> 16, Pe = U.low & 65535, he = 0, ve = 0, Q = 0, le = 0;
      return le += D + Pe, Q += le >>> 16, le &= 65535, Q += T + Ie, ve += Q >>> 16, Q &= 65535, ve += B + pe, he += ve >>> 16, ve &= 65535, he += H + ee, he &= 65535, X(Q << 16 | le, he << 16 | ve, this.unsigned);
    }, I.subtract = function(U) {
      return _(U) || (U = ae(U)), this.add(U.neg());
    }, I.sub = I.subtract, I.multiply = function(U) {
      if (this.isZero())
        return this;
      if (_(U) || (U = ae(U)), v) {
        var H = v.mul(this.low, this.high, U.low, U.high);
        return X(H, v.get_high(), this.unsigned);
      }
      if (U.isZero())
        return this.unsigned ? Be : Me;
      if (this.eq(E))
        return U.isOdd() ? E : Me;
      if (U.eq(E))
        return this.isOdd() ? E : Me;
      if (this.isNegative())
        return U.isNegative() ? this.neg().mul(U.neg()) : this.neg().mul(U).neg();
      if (U.isNegative())
        return this.mul(U.neg()).neg();
      if (this.lt(Ce) && U.lt(Ce))
        return V(this.toNumber() * U.toNumber(), this.unsigned);
      var B = this.high >>> 16, T = this.high & 65535, D = this.low >>> 16, ee = this.low & 65535, pe = U.high >>> 16, Ie = U.high & 65535, Pe = U.low >>> 16, he = U.low & 65535, ve = 0, Q = 0, le = 0, _e = 0;
      return _e += ee * he, le += _e >>> 16, _e &= 65535, le += D * he, Q += le >>> 16, le &= 65535, le += ee * Pe, Q += le >>> 16, le &= 65535, Q += T * he, ve += Q >>> 16, Q &= 65535, Q += D * Pe, ve += Q >>> 16, Q &= 65535, Q += ee * Ie, ve += Q >>> 16, Q &= 65535, ve += B * he + T * Pe + D * Ie + ee * pe, ve &= 65535, X(le << 16 | _e, ve << 16 | Q, this.unsigned);
    }, I.mul = I.multiply, I.divide = function(U) {
      if (_(U) || (U = ae(U)), U.isZero())
        throw Error("division by zero");
      if (v) {
        if (!this.unsigned && this.high === -2147483648 && U.low === -1 && U.high === -1)
          return this;
        var H = (this.unsigned ? v.div_u : v.div_s)(this.low, this.high, U.low, U.high);
        return X(H, v.get_high(), this.unsigned);
      }
      if (this.isZero())
        return this.unsigned ? Be : Me;
      var B, T, D;
      if (this.unsigned) {
        if (U.unsigned || (U = U.toUnsigned()), U.gt(this))
          return Be;
        if (U.gt(this.shru(1)))
          return Z;
        D = Be;
      } else {
        if (this.eq(E)) {
          if (U.eq(Ae) || U.eq(z))
            return E;
          if (U.eq(E))
            return Ae;
          var ee = this.shr(1);
          return B = ee.div(U).shl(1), B.eq(Me) ? U.isNegative() ? Ae : z : (T = this.sub(U.mul(B)), D = B.add(T.div(U)), D);
        } else if (U.eq(E))
          return this.unsigned ? Be : Me;
        if (this.isNegative())
          return U.isNegative() ? this.neg().div(U.neg()) : this.neg().div(U).neg();
        if (U.isNegative())
          return this.div(U.neg()).neg();
        D = Me;
      }
      for (T = this; T.gte(U); ) {
        B = Math.max(1, Math.floor(T.toNumber() / U.toNumber()));
        for (var pe = Math.ceil(Math.log(B) / Math.LN2), Ie = pe <= 48 ? 1 : oe(2, pe - 48), Pe = V(B), he = Pe.mul(U); he.isNegative() || he.gt(T); )
          B -= Ie, Pe = V(B, this.unsigned), he = Pe.mul(U);
        Pe.isZero() && (Pe = Ae), D = D.add(Pe), T = T.sub(he);
      }
      return D;
    }, I.div = I.divide, I.modulo = function(U) {
      if (_(U) || (U = ae(U)), v) {
        var H = (this.unsigned ? v.rem_u : v.rem_s)(this.low, this.high, U.low, U.high);
        return X(H, v.get_high(), this.unsigned);
      }
      return this.sub(this.div(U).mul(U));
    }, I.mod = I.modulo, I.rem = I.modulo, I.not = function() {
      return X(~this.low, ~this.high, this.unsigned);
    }, I.countLeadingZeros = function() {
      return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
    }, I.clz = I.countLeadingZeros, I.countTrailingZeros = function() {
      return this.low ? k(this.low) : k(this.high) + 32;
    }, I.ctz = I.countTrailingZeros, I.and = function(U) {
      return _(U) || (U = ae(U)), X(this.low & U.low, this.high & U.high, this.unsigned);
    }, I.or = function(U) {
      return _(U) || (U = ae(U)), X(this.low | U.low, this.high | U.high, this.unsigned);
    }, I.xor = function(U) {
      return _(U) || (U = ae(U)), X(this.low ^ U.low, this.high ^ U.high, this.unsigned);
    }, I.shiftLeft = function(U) {
      return _(U) && (U = U.toInt()), (U &= 63) === 0 ? this : U < 32 ? X(this.low << U, this.high << U | this.low >>> 32 - U, this.unsigned) : X(0, this.low << U - 32, this.unsigned);
    }, I.shl = I.shiftLeft, I.shiftRight = function(U) {
      return _(U) && (U = U.toInt()), (U &= 63) === 0 ? this : U < 32 ? X(this.low >>> U | this.high << 32 - U, this.high >> U, this.unsigned) : X(this.high >> U - 32, this.high >= 0 ? 0 : -1, this.unsigned);
    }, I.shr = I.shiftRight, I.shiftRightUnsigned = function(U) {
      return _(U) && (U = U.toInt()), (U &= 63) === 0 ? this : U < 32 ? X(this.low >>> U | this.high << 32 - U, this.high >>> U, this.unsigned) : U === 32 ? X(this.high, 0, this.unsigned) : X(this.high >>> U - 32, 0, this.unsigned);
    }, I.shru = I.shiftRightUnsigned, I.shr_u = I.shiftRightUnsigned, I.rotateLeft = function(U) {
      var H;
      return _(U) && (U = U.toInt()), (U &= 63) === 0 ? this : U === 32 ? X(this.high, this.low, this.unsigned) : U < 32 ? (H = 32 - U, X(this.low << U | this.high >>> H, this.high << U | this.low >>> H, this.unsigned)) : (U -= 32, H = 32 - U, X(this.high << U | this.low >>> H, this.low << U | this.high >>> H, this.unsigned));
    }, I.rotl = I.rotateLeft, I.rotateRight = function(U) {
      var H;
      return _(U) && (U = U.toInt()), (U &= 63) === 0 ? this : U === 32 ? X(this.high, this.low, this.unsigned) : U < 32 ? (H = 32 - U, X(this.high << H | this.low >>> U, this.low << H | this.high >>> U, this.unsigned)) : (U -= 32, H = 32 - U, X(this.low << H | this.high >>> U, this.high << H | this.low >>> U, this.unsigned));
    }, I.rotr = I.rotateRight, I.toSigned = function() {
      return this.unsigned ? X(this.low, this.high, !1) : this;
    }, I.toUnsigned = function() {
      return this.unsigned ? this : X(this.low, this.high, !0);
    }, I.toBytes = function(U) {
      return U ? this.toBytesLE() : this.toBytesBE();
    }, I.toBytesLE = function() {
      var U = this.high, H = this.low;
      return [H & 255, H >>> 8 & 255, H >>> 16 & 255, H >>> 24, U & 255, U >>> 8 & 255, U >>> 16 & 255, U >>> 24];
    }, I.toBytesBE = function() {
      var U = this.high, H = this.low;
      return [U >>> 24, U >>> 16 & 255, U >>> 8 & 255, U & 255, H >>> 24, H >>> 16 & 255, H >>> 8 & 255, H & 255];
    }, p.fromBytes = function(U, H, B) {
      return B ? p.fromBytesLE(U, H) : p.fromBytesBE(U, H);
    }, p.fromBytesLE = function(U, H) {
      return new p(U[0] | U[1] << 8 | U[2] << 16 | U[3] << 24, U[4] | U[5] << 8 | U[6] << 16 | U[7] << 24, H);
    }, p.fromBytesBE = function(U, H) {
      return new p(U[4] << 24 | U[5] << 16 | U[6] << 8 | U[7], U[0] << 24 | U[1] << 16 | U[2] << 8 | U[3], H);
    };
    var N = p;
    return l.default = N, "default" in l ? l.default : l;
  }({});
  a.exports = c;
})(umd);
var umdExports = umd.exports, indexMinimal = {}, minimal$1 = {}, aspromise = asPromise;
function asPromise(a, u) {
  for (var c = new Array(arguments.length - 1), l = 0, v = 2, p = !0; v < arguments.length; )
    c[l++] = arguments[v++];
  return new Promise(function(k, M) {
    c[l] = function(F) {
      if (p)
        if (p = !1, F)
          M(F);
        else {
          for (var V = new Array(arguments.length - 1), X = 0; X < V.length; )
            V[X++] = arguments[X];
          k.apply(null, V);
        }
    };
    try {
      a.apply(u || null, c);
    } catch (L) {
      p && (p = !1, M(L));
    }
  });
}
var base64$1 = {};
(function(a) {
  var u = a;
  u.length = function(k) {
    var M = k.length;
    if (!M)
      return 0;
    for (var L = 0; --M % 4 > 1 && k.charAt(M) === "="; )
      ++L;
    return Math.ceil(k.length * 3) / 4 - L;
  };
  for (var c = new Array(64), l = new Array(123), v = 0; v < 64; )
    l[c[v] = v < 26 ? v + 65 : v < 52 ? v + 71 : v < 62 ? v - 4 : v - 59 | 43] = v++;
  u.encode = function(k, M, L) {
    for (var F = null, V = [], X = 0, oe = 0, Y; M < L; ) {
      var ae = k[M++];
      switch (oe) {
        case 0:
          V[X++] = c[ae >> 2], Y = (ae & 3) << 4, oe = 1;
          break;
        case 1:
          V[X++] = c[Y | ae >> 4], Y = (ae & 15) << 2, oe = 2;
          break;
        case 2:
          V[X++] = c[Y | ae >> 6], V[X++] = c[ae & 63], oe = 0;
          break;
      }
      X > 8191 && ((F || (F = [])).push(String.fromCharCode.apply(String, V)), X = 0);
    }
    return oe && (V[X++] = c[Y], V[X++] = 61, oe === 1 && (V[X++] = 61)), F ? (X && F.push(String.fromCharCode.apply(String, V.slice(0, X))), F.join("")) : String.fromCharCode.apply(String, V.slice(0, X));
  };
  var p = "invalid encoding";
  u.decode = function(k, M, L) {
    for (var F = L, V = 0, X, oe = 0; oe < k.length; ) {
      var Y = k.charCodeAt(oe++);
      if (Y === 61 && V > 1)
        break;
      if ((Y = l[Y]) === void 0)
        throw Error(p);
      switch (V) {
        case 0:
          X = Y, V = 1;
          break;
        case 1:
          M[L++] = X << 2 | (Y & 48) >> 4, X = Y, V = 2;
          break;
        case 2:
          M[L++] = (X & 15) << 4 | (Y & 60) >> 2, X = Y, V = 3;
          break;
        case 3:
          M[L++] = (X & 3) << 6 | Y, V = 0;
          break;
      }
    }
    if (V === 1)
      throw Error(p);
    return L - F;
  }, u.test = function(k) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(k);
  };
})(base64$1);
var eventemitter = EventEmitter$2;
function EventEmitter$2() {
  this._listeners = {};
}
EventEmitter$2.prototype.on = function(u, c, l) {
  return (this._listeners[u] || (this._listeners[u] = [])).push({
    fn: c,
    ctx: l || this
  }), this;
};
EventEmitter$2.prototype.off = function(u, c) {
  if (u === void 0)
    this._listeners = {};
  else if (c === void 0)
    this._listeners[u] = [];
  else
    for (var l = this._listeners[u], v = 0; v < l.length; )
      l[v].fn === c ? l.splice(v, 1) : ++v;
  return this;
};
EventEmitter$2.prototype.emit = function(u) {
  var c = this._listeners[u];
  if (c) {
    for (var l = [], v = 1; v < arguments.length; )
      l.push(arguments[v++]);
    for (v = 0; v < c.length; )
      c[v].fn.apply(c[v++].ctx, l);
  }
  return this;
};
var float = factory(factory);
function factory(a) {
  return typeof Float32Array < "u" ? function() {
    var u = new Float32Array([-0]), c = new Uint8Array(u.buffer), l = c[3] === 128;
    function v(M, L, F) {
      u[0] = M, L[F] = c[0], L[F + 1] = c[1], L[F + 2] = c[2], L[F + 3] = c[3];
    }
    function p(M, L, F) {
      u[0] = M, L[F] = c[3], L[F + 1] = c[2], L[F + 2] = c[1], L[F + 3] = c[0];
    }
    a.writeFloatLE = l ? v : p, a.writeFloatBE = l ? p : v;
    function _(M, L) {
      return c[0] = M[L], c[1] = M[L + 1], c[2] = M[L + 2], c[3] = M[L + 3], u[0];
    }
    function k(M, L) {
      return c[3] = M[L], c[2] = M[L + 1], c[1] = M[L + 2], c[0] = M[L + 3], u[0];
    }
    a.readFloatLE = l ? _ : k, a.readFloatBE = l ? k : _;
  }() : function() {
    function u(l, v, p, _) {
      var k = v < 0 ? 1 : 0;
      if (k && (v = -v), v === 0)
        l(1 / v > 0 ? (
          /* positive */
          0
        ) : (
          /* negative 0 */
          2147483648
        ), p, _);
      else if (isNaN(v))
        l(2143289344, p, _);
      else if (v > 34028234663852886e22)
        l((k << 31 | 2139095040) >>> 0, p, _);
      else if (v < 11754943508222875e-54)
        l((k << 31 | Math.round(v / 1401298464324817e-60)) >>> 0, p, _);
      else {
        var M = Math.floor(Math.log(v) / Math.LN2), L = Math.round(v * Math.pow(2, -M) * 8388608) & 8388607;
        l((k << 31 | M + 127 << 23 | L) >>> 0, p, _);
      }
    }
    a.writeFloatLE = u.bind(null, writeUintLE), a.writeFloatBE = u.bind(null, writeUintBE);
    function c(l, v, p) {
      var _ = l(v, p), k = (_ >> 31) * 2 + 1, M = _ >>> 23 & 255, L = _ & 8388607;
      return M === 255 ? L ? NaN : k * (1 / 0) : M === 0 ? k * 1401298464324817e-60 * L : k * Math.pow(2, M - 150) * (L + 8388608);
    }
    a.readFloatLE = c.bind(null, readUintLE), a.readFloatBE = c.bind(null, readUintBE);
  }(), typeof Float64Array < "u" ? function() {
    var u = new Float64Array([-0]), c = new Uint8Array(u.buffer), l = c[7] === 128;
    function v(M, L, F) {
      u[0] = M, L[F] = c[0], L[F + 1] = c[1], L[F + 2] = c[2], L[F + 3] = c[3], L[F + 4] = c[4], L[F + 5] = c[5], L[F + 6] = c[6], L[F + 7] = c[7];
    }
    function p(M, L, F) {
      u[0] = M, L[F] = c[7], L[F + 1] = c[6], L[F + 2] = c[5], L[F + 3] = c[4], L[F + 4] = c[3], L[F + 5] = c[2], L[F + 6] = c[1], L[F + 7] = c[0];
    }
    a.writeDoubleLE = l ? v : p, a.writeDoubleBE = l ? p : v;
    function _(M, L) {
      return c[0] = M[L], c[1] = M[L + 1], c[2] = M[L + 2], c[3] = M[L + 3], c[4] = M[L + 4], c[5] = M[L + 5], c[6] = M[L + 6], c[7] = M[L + 7], u[0];
    }
    function k(M, L) {
      return c[7] = M[L], c[6] = M[L + 1], c[5] = M[L + 2], c[4] = M[L + 3], c[3] = M[L + 4], c[2] = M[L + 5], c[1] = M[L + 6], c[0] = M[L + 7], u[0];
    }
    a.readDoubleLE = l ? _ : k, a.readDoubleBE = l ? k : _;
  }() : function() {
    function u(l, v, p, _, k, M) {
      var L = _ < 0 ? 1 : 0;
      if (L && (_ = -_), _ === 0)
        l(0, k, M + v), l(1 / _ > 0 ? (
          /* positive */
          0
        ) : (
          /* negative 0 */
          2147483648
        ), k, M + p);
      else if (isNaN(_))
        l(0, k, M + v), l(2146959360, k, M + p);
      else if (_ > 17976931348623157e292)
        l(0, k, M + v), l((L << 31 | 2146435072) >>> 0, k, M + p);
      else {
        var F;
        if (_ < 22250738585072014e-324)
          F = _ / 5e-324, l(F >>> 0, k, M + v), l((L << 31 | F / 4294967296) >>> 0, k, M + p);
        else {
          var V = Math.floor(Math.log(_) / Math.LN2);
          V === 1024 && (V = 1023), F = _ * Math.pow(2, -V), l(F * 4503599627370496 >>> 0, k, M + v), l((L << 31 | V + 1023 << 20 | F * 1048576 & 1048575) >>> 0, k, M + p);
        }
      }
    }
    a.writeDoubleLE = u.bind(null, writeUintLE, 0, 4), a.writeDoubleBE = u.bind(null, writeUintBE, 4, 0);
    function c(l, v, p, _, k) {
      var M = l(_, k + v), L = l(_, k + p), F = (L >> 31) * 2 + 1, V = L >>> 20 & 2047, X = 4294967296 * (L & 1048575) + M;
      return V === 2047 ? X ? NaN : F * (1 / 0) : V === 0 ? F * 5e-324 * X : F * Math.pow(2, V - 1075) * (X + 4503599627370496);
    }
    a.readDoubleLE = c.bind(null, readUintLE, 0, 4), a.readDoubleBE = c.bind(null, readUintBE, 4, 0);
  }(), a;
}
function writeUintLE(a, u, c) {
  u[c] = a & 255, u[c + 1] = a >>> 8 & 255, u[c + 2] = a >>> 16 & 255, u[c + 3] = a >>> 24;
}
function writeUintBE(a, u, c) {
  u[c] = a >>> 24, u[c + 1] = a >>> 16 & 255, u[c + 2] = a >>> 8 & 255, u[c + 3] = a & 255;
}
function readUintLE(a, u) {
  return (a[u] | a[u + 1] << 8 | a[u + 2] << 16 | a[u + 3] << 24) >>> 0;
}
function readUintBE(a, u) {
  return (a[u] << 24 | a[u + 1] << 16 | a[u + 2] << 8 | a[u + 3]) >>> 0;
}
var inquire_1 = inquire;
function inquire(moduleName) {
  try {
    var mod = eval("quire".replace(/^/, "re"))(moduleName);
    if (mod && (mod.length || Object.keys(mod).length))
      return mod;
  } catch (a) {
  }
  return null;
}
var utf8$2 = {};
(function(a) {
  var u = a;
  u.length = function(l) {
    for (var v = 0, p = 0, _ = 0; _ < l.length; ++_)
      p = l.charCodeAt(_), p < 128 ? v += 1 : p < 2048 ? v += 2 : (p & 64512) === 55296 && (l.charCodeAt(_ + 1) & 64512) === 56320 ? (++_, v += 4) : v += 3;
    return v;
  }, u.read = function(l, v, p) {
    var _ = p - v;
    if (_ < 1)
      return "";
    for (var k = null, M = [], L = 0, F; v < p; )
      F = l[v++], F < 128 ? M[L++] = F : F > 191 && F < 224 ? M[L++] = (F & 31) << 6 | l[v++] & 63 : F > 239 && F < 365 ? (F = ((F & 7) << 18 | (l[v++] & 63) << 12 | (l[v++] & 63) << 6 | l[v++] & 63) - 65536, M[L++] = 55296 + (F >> 10), M[L++] = 56320 + (F & 1023)) : M[L++] = (F & 15) << 12 | (l[v++] & 63) << 6 | l[v++] & 63, L > 8191 && ((k || (k = [])).push(String.fromCharCode.apply(String, M)), L = 0);
    return k ? (L && k.push(String.fromCharCode.apply(String, M.slice(0, L))), k.join("")) : String.fromCharCode.apply(String, M.slice(0, L));
  }, u.write = function(l, v, p) {
    for (var _ = p, k, M, L = 0; L < l.length; ++L)
      k = l.charCodeAt(L), k < 128 ? v[p++] = k : k < 2048 ? (v[p++] = k >> 6 | 192, v[p++] = k & 63 | 128) : (k & 64512) === 55296 && ((M = l.charCodeAt(L + 1)) & 64512) === 56320 ? (k = 65536 + ((k & 1023) << 10) + (M & 1023), ++L, v[p++] = k >> 18 | 240, v[p++] = k >> 12 & 63 | 128, v[p++] = k >> 6 & 63 | 128, v[p++] = k & 63 | 128) : (v[p++] = k >> 12 | 224, v[p++] = k >> 6 & 63 | 128, v[p++] = k & 63 | 128);
    return p - _;
  };
})(utf8$2);
var pool_1 = pool;
function pool(a, u, c) {
  var l = c || 8192, v = l >>> 1, p = null, _ = l;
  return function(M) {
    if (M < 1 || M > v)
      return a(M);
    _ + M > l && (p = a(l), _ = 0);
    var L = u.call(p, _, _ += M);
    return _ & 7 && (_ = (_ | 7) + 1), L;
  };
}
var longbits, hasRequiredLongbits;
function requireLongbits() {
  if (hasRequiredLongbits)
    return longbits;
  hasRequiredLongbits = 1, longbits = u;
  var a = requireMinimal();
  function u(p, _) {
    this.lo = p >>> 0, this.hi = _ >>> 0;
  }
  var c = u.zero = new u(0, 0);
  c.toNumber = function() {
    return 0;
  }, c.zzEncode = c.zzDecode = function() {
    return this;
  }, c.length = function() {
    return 1;
  };
  var l = u.zeroHash = "\0\0\0\0\0\0\0\0";
  u.fromNumber = function(_) {
    if (_ === 0)
      return c;
    var k = _ < 0;
    k && (_ = -_);
    var M = _ >>> 0, L = (_ - M) / 4294967296 >>> 0;
    return k && (L = ~L >>> 0, M = ~M >>> 0, ++M > 4294967295 && (M = 0, ++L > 4294967295 && (L = 0))), new u(M, L);
  }, u.from = function(_) {
    if (typeof _ == "number")
      return u.fromNumber(_);
    if (a.isString(_))
      if (a.Long)
        _ = a.Long.fromString(_);
      else
        return u.fromNumber(parseInt(_, 10));
    return _.low || _.high ? new u(_.low >>> 0, _.high >>> 0) : c;
  }, u.prototype.toNumber = function(_) {
    if (!_ && this.hi >>> 31) {
      var k = ~this.lo + 1 >>> 0, M = ~this.hi >>> 0;
      return k || (M = M + 1 >>> 0), -(k + M * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
  }, u.prototype.toLong = function(_) {
    return a.Long ? new a.Long(this.lo | 0, this.hi | 0, !!_) : { low: this.lo | 0, high: this.hi | 0, unsigned: !!_ };
  };
  var v = String.prototype.charCodeAt;
  return u.fromHash = function(_) {
    return _ === l ? c : new u(
      (v.call(_, 0) | v.call(_, 1) << 8 | v.call(_, 2) << 16 | v.call(_, 3) << 24) >>> 0,
      (v.call(_, 4) | v.call(_, 5) << 8 | v.call(_, 6) << 16 | v.call(_, 7) << 24) >>> 0
    );
  }, u.prototype.toHash = function() {
    return String.fromCharCode(
      this.lo & 255,
      this.lo >>> 8 & 255,
      this.lo >>> 16 & 255,
      this.lo >>> 24,
      this.hi & 255,
      this.hi >>> 8 & 255,
      this.hi >>> 16 & 255,
      this.hi >>> 24
    );
  }, u.prototype.zzEncode = function() {
    var _ = this.hi >> 31;
    return this.hi = ((this.hi << 1 | this.lo >>> 31) ^ _) >>> 0, this.lo = (this.lo << 1 ^ _) >>> 0, this;
  }, u.prototype.zzDecode = function() {
    var _ = -(this.lo & 1);
    return this.lo = ((this.lo >>> 1 | this.hi << 31) ^ _) >>> 0, this.hi = (this.hi >>> 1 ^ _) >>> 0, this;
  }, u.prototype.length = function() {
    var _ = this.lo, k = (this.lo >>> 28 | this.hi << 4) >>> 0, M = this.hi >>> 24;
    return M === 0 ? k === 0 ? _ < 16384 ? _ < 128 ? 1 : 2 : _ < 2097152 ? 3 : 4 : k < 16384 ? k < 128 ? 5 : 6 : k < 2097152 ? 7 : 8 : M < 128 ? 9 : 10;
  }, longbits;
}
var hasRequiredMinimal;
function requireMinimal() {
  return hasRequiredMinimal || (hasRequiredMinimal = 1, function(a) {
    var u = a;
    u.asPromise = aspromise, u.base64 = base64$1, u.EventEmitter = eventemitter, u.float = float, u.inquire = inquire_1, u.utf8 = utf8$2, u.pool = pool_1, u.LongBits = requireLongbits(), u.isNode = !!(typeof commonjsGlobal$1 < "u" && commonjsGlobal$1 && commonjsGlobal$1.process && commonjsGlobal$1.process.versions && commonjsGlobal$1.process.versions.node), u.global = u.isNode && commonjsGlobal$1 || typeof window < "u" && window || typeof self < "u" && self || commonjsGlobal$1, u.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    ), u.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    ), u.isInteger = Number.isInteger || /* istanbul ignore next */
    function(p) {
      return typeof p == "number" && isFinite(p) && Math.floor(p) === p;
    }, u.isString = function(p) {
      return typeof p == "string" || p instanceof String;
    }, u.isObject = function(p) {
      return p && typeof p == "object";
    }, u.isset = /**
     * Checks if a property on a message is considered to be present.
     * @param {Object} obj Plain object or message instance
     * @param {string} prop Property name
     * @returns {boolean} `true` if considered to be present, otherwise `false`
     */
    u.isSet = function(p, _) {
      var k = p[_];
      return k != null && p.hasOwnProperty(_) ? typeof k != "object" || (Array.isArray(k) ? k.length : Object.keys(k).length) > 0 : !1;
    }, u.Buffer = function() {
      try {
        var v = u.inquire("buffer").Buffer;
        return v.prototype.utf8Write ? v : (
          /* istanbul ignore next */
          null
        );
      } catch {
        return null;
      }
    }(), u._Buffer_from = null, u._Buffer_allocUnsafe = null, u.newBuffer = function(p) {
      return typeof p == "number" ? u.Buffer ? u._Buffer_allocUnsafe(p) : new u.Array(p) : u.Buffer ? u._Buffer_from(p) : typeof Uint8Array > "u" ? p : new Uint8Array(p);
    }, u.Array = typeof Uint8Array < "u" ? Uint8Array : Array, u.Long = /* istanbul ignore next */
    u.global.dcodeIO && /* istanbul ignore next */
    u.global.dcodeIO.Long || /* istanbul ignore next */
    u.global.Long || u.inquire("long"), u.key2Re = /^true|false|0|1$/, u.key32Re = /^-?(?:0|[1-9][0-9]*)$/, u.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/, u.longToHash = function(p) {
      return p ? u.LongBits.from(p).toHash() : u.LongBits.zeroHash;
    }, u.longFromHash = function(p, _) {
      var k = u.LongBits.fromHash(p);
      return u.Long ? u.Long.fromBits(k.lo, k.hi, _) : k.toNumber(!!_);
    };
    function c(v, p, _) {
      for (var k = Object.keys(p), M = 0; M < k.length; ++M)
        (v[k[M]] === void 0 || !_) && (v[k[M]] = p[k[M]]);
      return v;
    }
    u.merge = c, u.lcFirst = function(p) {
      return p.charAt(0).toLowerCase() + p.substring(1);
    };
    function l(v) {
      function p(_, k) {
        if (!(this instanceof p))
          return new p(_, k);
        Object.defineProperty(this, "message", { get: function() {
          return _;
        } }), Error.captureStackTrace ? Error.captureStackTrace(this, p) : Object.defineProperty(this, "stack", { value: new Error().stack || "" }), k && c(this, k);
      }
      return (p.prototype = Object.create(Error.prototype)).constructor = p, Object.defineProperty(p.prototype, "name", { get: function() {
        return v;
      } }), p.prototype.toString = function() {
        return this.name + ": " + this.message;
      }, p;
    }
    u.newError = l, u.ProtocolError = l("ProtocolError"), u.oneOfGetter = function(p) {
      for (var _ = {}, k = 0; k < p.length; ++k)
        _[p[k]] = 1;
      return function() {
        for (var M = Object.keys(this), L = M.length - 1; L > -1; --L)
          if (_[M[L]] === 1 && this[M[L]] !== void 0 && this[M[L]] !== null)
            return M[L];
      };
    }, u.oneOfSetter = function(p) {
      return function(_) {
        for (var k = 0; k < p.length; ++k)
          p[k] !== _ && delete this[p[k]];
      };
    }, u.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: !0
    }, u._configure = function() {
      var v = u.Buffer;
      if (!v) {
        u._Buffer_from = u._Buffer_allocUnsafe = null;
        return;
      }
      u._Buffer_from = v.from !== Uint8Array.from && v.from || /* istanbul ignore next */
      function(_, k) {
        return new v(_, k);
      }, u._Buffer_allocUnsafe = v.allocUnsafe || /* istanbul ignore next */
      function(_) {
        return new v(_);
      };
    };
  }(minimal$1)), minimal$1;
}
var writer$2 = Writer$1, util$9 = requireMinimal(), BufferWriter$1, LongBits$1 = util$9.LongBits, base64 = util$9.base64, utf8$1 = util$9.utf8;
function Op(a, u, c) {
  this.fn = a, this.len = u, this.next = void 0, this.val = c;
}
function noop$7() {
}
function State(a) {
  this.head = a.head, this.tail = a.tail, this.len = a.len, this.next = a.states;
}
function Writer$1() {
  this.len = 0, this.head = new Op(noop$7, 0, 0), this.tail = this.head, this.states = null;
}
var create$3 = function a() {
  return util$9.Buffer ? function() {
    return (Writer$1.create = function() {
      return new BufferWriter$1();
    })();
  } : function() {
    return new Writer$1();
  };
};
Writer$1.create = create$3();
Writer$1.alloc = function a(u) {
  return new util$9.Array(u);
};
util$9.Array !== Array && (Writer$1.alloc = util$9.pool(Writer$1.alloc, util$9.Array.prototype.subarray));
Writer$1.prototype._push = function a(u, c, l) {
  return this.tail = this.tail.next = new Op(u, c, l), this.len += c, this;
};
function writeByte(a, u, c) {
  u[c] = a & 255;
}
function writeVarint32(a, u, c) {
  for (; a > 127; )
    u[c++] = a & 127 | 128, a >>>= 7;
  u[c] = a;
}
function VarintOp(a, u) {
  this.len = a, this.next = void 0, this.val = u;
}
VarintOp.prototype = Object.create(Op.prototype);
VarintOp.prototype.fn = writeVarint32;
Writer$1.prototype.uint32 = function a(u) {
  return this.len += (this.tail = this.tail.next = new VarintOp(
    (u = u >>> 0) < 128 ? 1 : u < 16384 ? 2 : u < 2097152 ? 3 : u < 268435456 ? 4 : 5,
    u
  )).len, this;
};
Writer$1.prototype.int32 = function a(u) {
  return u < 0 ? this._push(writeVarint64, 10, LongBits$1.fromNumber(u)) : this.uint32(u);
};
Writer$1.prototype.sint32 = function a(u) {
  return this.uint32((u << 1 ^ u >> 31) >>> 0);
};
function writeVarint64(a, u, c) {
  for (; a.hi; )
    u[c++] = a.lo & 127 | 128, a.lo = (a.lo >>> 7 | a.hi << 25) >>> 0, a.hi >>>= 7;
  for (; a.lo > 127; )
    u[c++] = a.lo & 127 | 128, a.lo = a.lo >>> 7;
  u[c++] = a.lo;
}
Writer$1.prototype.uint64 = function a(u) {
  var c = LongBits$1.from(u);
  return this._push(writeVarint64, c.length(), c);
};
Writer$1.prototype.int64 = Writer$1.prototype.uint64;
Writer$1.prototype.sint64 = function a(u) {
  var c = LongBits$1.from(u).zzEncode();
  return this._push(writeVarint64, c.length(), c);
};
Writer$1.prototype.bool = function a(u) {
  return this._push(writeByte, 1, u ? 1 : 0);
};
function writeFixed32(a, u, c) {
  u[c] = a & 255, u[c + 1] = a >>> 8 & 255, u[c + 2] = a >>> 16 & 255, u[c + 3] = a >>> 24;
}
Writer$1.prototype.fixed32 = function a(u) {
  return this._push(writeFixed32, 4, u >>> 0);
};
Writer$1.prototype.sfixed32 = Writer$1.prototype.fixed32;
Writer$1.prototype.fixed64 = function a(u) {
  var c = LongBits$1.from(u);
  return this._push(writeFixed32, 4, c.lo)._push(writeFixed32, 4, c.hi);
};
Writer$1.prototype.sfixed64 = Writer$1.prototype.fixed64;
Writer$1.prototype.float = function a(u) {
  return this._push(util$9.float.writeFloatLE, 4, u);
};
Writer$1.prototype.double = function a(u) {
  return this._push(util$9.float.writeDoubleLE, 8, u);
};
var writeBytes = util$9.Array.prototype.set ? function a(u, c, l) {
  c.set(u, l);
} : function a(u, c, l) {
  for (var v = 0; v < u.length; ++v)
    c[l + v] = u[v];
};
Writer$1.prototype.bytes = function a(u) {
  var c = u.length >>> 0;
  if (!c)
    return this._push(writeByte, 1, 0);
  if (util$9.isString(u)) {
    var l = Writer$1.alloc(c = base64.length(u));
    base64.decode(u, l, 0), u = l;
  }
  return this.uint32(c)._push(writeBytes, c, u);
};
Writer$1.prototype.string = function a(u) {
  var c = utf8$1.length(u);
  return c ? this.uint32(c)._push(utf8$1.write, c, u) : this._push(writeByte, 1, 0);
};
Writer$1.prototype.fork = function a() {
  return this.states = new State(this), this.head = this.tail = new Op(noop$7, 0, 0), this.len = 0, this;
};
Writer$1.prototype.reset = function a() {
  return this.states ? (this.head = this.states.head, this.tail = this.states.tail, this.len = this.states.len, this.states = this.states.next) : (this.head = this.tail = new Op(noop$7, 0, 0), this.len = 0), this;
};
Writer$1.prototype.ldelim = function a() {
  var u = this.head, c = this.tail, l = this.len;
  return this.reset().uint32(l), l && (this.tail.next = u.next, this.tail = c, this.len += l), this;
};
Writer$1.prototype.finish = function a() {
  for (var u = this.head.next, c = this.constructor.alloc(this.len), l = 0; u; )
    u.fn(u.val, c, l), l += u.len, u = u.next;
  return c;
};
Writer$1._configure = function(a) {
  BufferWriter$1 = a, Writer$1.create = create$3(), BufferWriter$1._configure();
};
var writer_buffer = BufferWriter, Writer = writer$2;
(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
var util$8 = requireMinimal();
function BufferWriter() {
  Writer.call(this);
}
BufferWriter._configure = function() {
  BufferWriter.alloc = util$8._Buffer_allocUnsafe, BufferWriter.writeBytesBuffer = util$8.Buffer && util$8.Buffer.prototype instanceof Uint8Array && util$8.Buffer.prototype.set.name === "set" ? function(u, c, l) {
    c.set(u, l);
  } : function(u, c, l) {
    if (u.copy)
      u.copy(c, l, 0, u.length);
    else
      for (var v = 0; v < u.length; )
        c[l++] = u[v++];
  };
};
BufferWriter.prototype.bytes = function a(u) {
  util$8.isString(u) && (u = util$8._Buffer_from(u, "base64"));
  var c = u.length >>> 0;
  return this.uint32(c), c && this._push(BufferWriter.writeBytesBuffer, c, u), this;
};
function writeStringBuffer(a, u, c) {
  a.length < 40 ? util$8.utf8.write(a, u, c) : u.utf8Write ? u.utf8Write(a, c) : u.write(a, c);
}
BufferWriter.prototype.string = function a(u) {
  var c = util$8.Buffer.byteLength(u);
  return this.uint32(c), c && this._push(writeStringBuffer, c, u), this;
};
BufferWriter._configure();
var reader = Reader$1, util$7 = requireMinimal(), BufferReader$1, LongBits = util$7.LongBits, utf8 = util$7.utf8;
function indexOutOfRange(a, u) {
  return RangeError("index out of range: " + a.pos + " + " + (u || 1) + " > " + a.len);
}
function Reader$1(a) {
  this.buf = a, this.pos = 0, this.len = a.length;
}
var create_array = typeof Uint8Array < "u" ? function a(u) {
  if (u instanceof Uint8Array || Array.isArray(u))
    return new Reader$1(u);
  throw Error("illegal buffer");
} : function a(u) {
  if (Array.isArray(u))
    return new Reader$1(u);
  throw Error("illegal buffer");
}, create$2 = function a() {
  return util$7.Buffer ? function(c) {
    return (Reader$1.create = function(v) {
      return util$7.Buffer.isBuffer(v) ? new BufferReader$1(v) : create_array(v);
    })(c);
  } : create_array;
};
Reader$1.create = create$2();
Reader$1.prototype._slice = util$7.Array.prototype.subarray || /* istanbul ignore next */
util$7.Array.prototype.slice;
Reader$1.prototype.uint32 = /* @__PURE__ */ function a() {
  var u = 4294967295;
  return function() {
    if (u = (this.buf[this.pos] & 127) >>> 0, this.buf[this.pos++] < 128 || (u = (u | (this.buf[this.pos] & 127) << 7) >>> 0, this.buf[this.pos++] < 128) || (u = (u | (this.buf[this.pos] & 127) << 14) >>> 0, this.buf[this.pos++] < 128) || (u = (u | (this.buf[this.pos] & 127) << 21) >>> 0, this.buf[this.pos++] < 128) || (u = (u | (this.buf[this.pos] & 15) << 28) >>> 0, this.buf[this.pos++] < 128))
      return u;
    if ((this.pos += 5) > this.len)
      throw this.pos = this.len, indexOutOfRange(this, 10);
    return u;
  };
}();
Reader$1.prototype.int32 = function a() {
  return this.uint32() | 0;
};
Reader$1.prototype.sint32 = function a() {
  var u = this.uint32();
  return u >>> 1 ^ -(u & 1) | 0;
};
function readLongVarint() {
  var a = new LongBits(0, 0), u = 0;
  if (this.len - this.pos > 4) {
    for (; u < 4; ++u)
      if (a.lo = (a.lo | (this.buf[this.pos] & 127) << u * 7) >>> 0, this.buf[this.pos++] < 128)
        return a;
    if (a.lo = (a.lo | (this.buf[this.pos] & 127) << 28) >>> 0, a.hi = (a.hi | (this.buf[this.pos] & 127) >> 4) >>> 0, this.buf[this.pos++] < 128)
      return a;
    u = 0;
  } else {
    for (; u < 3; ++u) {
      if (this.pos >= this.len)
        throw indexOutOfRange(this);
      if (a.lo = (a.lo | (this.buf[this.pos] & 127) << u * 7) >>> 0, this.buf[this.pos++] < 128)
        return a;
    }
    return a.lo = (a.lo | (this.buf[this.pos++] & 127) << u * 7) >>> 0, a;
  }
  if (this.len - this.pos > 4) {
    for (; u < 5; ++u)
      if (a.hi = (a.hi | (this.buf[this.pos] & 127) << u * 7 + 3) >>> 0, this.buf[this.pos++] < 128)
        return a;
  } else
    for (; u < 5; ++u) {
      if (this.pos >= this.len)
        throw indexOutOfRange(this);
      if (a.hi = (a.hi | (this.buf[this.pos] & 127) << u * 7 + 3) >>> 0, this.buf[this.pos++] < 128)
        return a;
    }
  throw Error("invalid varint encoding");
}
Reader$1.prototype.bool = function a() {
  return this.uint32() !== 0;
};
function readFixed32_end(a, u) {
  return (a[u - 4] | a[u - 3] << 8 | a[u - 2] << 16 | a[u - 1] << 24) >>> 0;
}
Reader$1.prototype.fixed32 = function a() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange(this, 4);
  return readFixed32_end(this.buf, this.pos += 4);
};
Reader$1.prototype.sfixed32 = function a() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange(this, 4);
  return readFixed32_end(this.buf, this.pos += 4) | 0;
};
function readFixed64() {
  if (this.pos + 8 > this.len)
    throw indexOutOfRange(this, 8);
  return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}
Reader$1.prototype.float = function a() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange(this, 4);
  var u = util$7.float.readFloatLE(this.buf, this.pos);
  return this.pos += 4, u;
};
Reader$1.prototype.double = function a() {
  if (this.pos + 8 > this.len)
    throw indexOutOfRange(this, 4);
  var u = util$7.float.readDoubleLE(this.buf, this.pos);
  return this.pos += 8, u;
};
Reader$1.prototype.bytes = function a() {
  var u = this.uint32(), c = this.pos, l = this.pos + u;
  if (l > this.len)
    throw indexOutOfRange(this, u);
  return this.pos += u, Array.isArray(this.buf) ? this.buf.slice(c, l) : c === l ? new this.buf.constructor(0) : this._slice.call(this.buf, c, l);
};
Reader$1.prototype.string = function a() {
  var u = this.bytes();
  return utf8.read(u, 0, u.length);
};
Reader$1.prototype.skip = function a(u) {
  if (typeof u == "number") {
    if (this.pos + u > this.len)
      throw indexOutOfRange(this, u);
    this.pos += u;
  } else
    do
      if (this.pos >= this.len)
        throw indexOutOfRange(this);
    while (this.buf[this.pos++] & 128);
  return this;
};
Reader$1.prototype.skipType = function(a) {
  switch (a) {
    case 0:
      this.skip();
      break;
    case 1:
      this.skip(8);
      break;
    case 2:
      this.skip(this.uint32());
      break;
    case 3:
      for (; (a = this.uint32() & 7) !== 4; )
        this.skipType(a);
      break;
    case 5:
      this.skip(4);
      break;
    default:
      throw Error("invalid wire type " + a + " at offset " + this.pos);
  }
  return this;
};
Reader$1._configure = function(a) {
  BufferReader$1 = a, Reader$1.create = create$2(), BufferReader$1._configure();
  var u = util$7.Long ? "toLong" : (
    /* istanbul ignore next */
    "toNumber"
  );
  util$7.merge(Reader$1.prototype, {
    int64: function() {
      return readLongVarint.call(this)[u](!1);
    },
    uint64: function() {
      return readLongVarint.call(this)[u](!0);
    },
    sint64: function() {
      return readLongVarint.call(this).zzDecode()[u](!1);
    },
    fixed64: function() {
      return readFixed64.call(this)[u](!0);
    },
    sfixed64: function() {
      return readFixed64.call(this)[u](!1);
    }
  });
};
var reader_buffer = BufferReader, Reader = reader;
(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
var util$6 = requireMinimal();
function BufferReader(a) {
  Reader.call(this, a);
}
BufferReader._configure = function() {
  util$6.Buffer && (BufferReader.prototype._slice = util$6.Buffer.prototype.slice);
};
BufferReader.prototype.string = function a() {
  var u = this.uint32();
  return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + u, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + u, this.len));
};
BufferReader._configure();
var rpc = {}, service = Service, util$5 = requireMinimal();
(Service.prototype = Object.create(util$5.EventEmitter.prototype)).constructor = Service;
function Service(a, u, c) {
  if (typeof a != "function")
    throw TypeError("rpcImpl must be a function");
  util$5.EventEmitter.call(this), this.rpcImpl = a, this.requestDelimited = !!u, this.responseDelimited = !!c;
}
Service.prototype.rpcCall = function a(u, c, l, v, p) {
  if (!v)
    throw TypeError("request must be specified");
  var _ = this;
  if (!p)
    return util$5.asPromise(a, _, u, c, l, v);
  if (!_.rpcImpl) {
    setTimeout(function() {
      p(Error("already ended"));
    }, 0);
    return;
  }
  try {
    return _.rpcImpl(
      u,
      c[_.requestDelimited ? "encodeDelimited" : "encode"](v).finish(),
      function(M, L) {
        if (M)
          return _.emit("error", M, u), p(M);
        if (L === null) {
          _.end(
            /* endedByRPC */
            !0
          );
          return;
        }
        if (!(L instanceof l))
          try {
            L = l[_.responseDelimited ? "decodeDelimited" : "decode"](L);
          } catch (F) {
            return _.emit("error", F, u), p(F);
          }
        return _.emit("data", L, u), p(null, L);
      }
    );
  } catch (k) {
    _.emit("error", k, u), setTimeout(function() {
      p(k);
    }, 0);
    return;
  }
};
Service.prototype.end = function a(u) {
  return this.rpcImpl && (u || this.rpcImpl(null, null, null), this.rpcImpl = null, this.emit("end").off()), this;
};
(function(a) {
  var u = a;
  u.Service = service;
})(rpc);
var roots = {};
(function(a) {
  var u = a;
  u.build = "minimal", u.Writer = writer$2, u.BufferWriter = writer_buffer, u.Reader = reader, u.BufferReader = reader_buffer, u.util = requireMinimal(), u.rpc = rpc, u.roots = roots, u.configure = c;
  function c() {
    u.util._configure(), u.Writer._configure(u.BufferWriter), u.Reader._configure(u.BufferReader);
  }
  c();
})(indexMinimal);
var minimal = indexMinimal, struct$2 = {};
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(ie, ge, be, Ce) {
    Ce === void 0 && (Ce = be), Object.defineProperty(ie, Ce, { enumerable: !0, get: function() {
      return ge[be];
    } });
  } : function(ie, ge, be, Ce) {
    Ce === void 0 && (Ce = be), ie[Ce] = ge[be];
  }), c = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(ie, ge) {
    Object.defineProperty(ie, "default", { enumerable: !0, value: ge });
  } : function(ie, ge) {
    ie.default = ge;
  }), l = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(ie) {
    if (ie && ie.__esModule)
      return ie;
    var ge = {};
    if (ie != null)
      for (var be in ie)
        be !== "default" && Object.hasOwnProperty.call(ie, be) && u(ge, ie, be);
    return c(ge, ie), ge;
  }, v = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(ie) {
    return ie && ie.__esModule ? ie : { default: ie };
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.ListValue = a.Value = a.Struct_FieldsEntry = a.Struct = a.nullValueToNumber = a.nullValueToJSON = a.nullValueFromJSON = a.NullValue = a.protobufPackage = void 0;
  const p = v(umdExports), _ = l(minimal);
  a.protobufPackage = "google.protobuf";
  var k;
  (function(ie) {
    ie.NULL_VALUE = "NULL_VALUE";
  })(k = a.NullValue || (a.NullValue = {}));
  function M(ie) {
    switch (ie) {
      case 0:
      case "NULL_VALUE":
        return k.NULL_VALUE;
      default:
        throw new ae.Error("Unrecognized enum value " + ie + " for enum NullValue");
    }
  }
  a.nullValueFromJSON = M;
  function L(ie) {
    switch (ie) {
      case k.NULL_VALUE:
        return "NULL_VALUE";
      default:
        return "UNKNOWN";
    }
  }
  a.nullValueToJSON = L;
  function F(ie) {
    switch (ie) {
      case k.NULL_VALUE:
        return 0;
      default:
        return 0;
    }
  }
  a.nullValueToNumber = F;
  function V() {
    return { fields: {} };
  }
  a.Struct = {
    encode(ie, ge = _.Writer.create()) {
      return Object.entries(ie.fields).forEach(([be, Ce]) => {
        Ce !== void 0 && a.Struct_FieldsEntry.encode({ key: be, value: Ce }, ge.uint32(10).fork()).ldelim();
      }), ge;
    },
    decode(ie, ge) {
      const be = ie instanceof _.Reader ? ie : new _.Reader(ie);
      let Ce = ge === void 0 ? be.len : be.pos + ge;
      const Me = V();
      for (; be.pos < Ce; ) {
        const Be = be.uint32();
        switch (Be >>> 3) {
          case 1:
            const Ae = a.Struct_FieldsEntry.decode(be, be.uint32());
            Ae.value !== void 0 && (Me.fields[Ae.key] = Ae.value);
            break;
          default:
            be.skipType(Be & 7);
            break;
        }
      }
      return Me;
    },
    fromJSON(ie) {
      return {
        fields: ne(ie.fields) ? Object.entries(ie.fields).reduce((ge, [be, Ce]) => (ge[be] = Ce, ge), {}) : {}
      };
    },
    toJSON(ie) {
      const ge = {};
      return ge.fields = {}, ie.fields && Object.entries(ie.fields).forEach(([be, Ce]) => {
        ge.fields[be] = Ce;
      }), ge;
    },
    fromPartial(ie) {
      var ge;
      const be = V();
      return be.fields = Object.entries((ge = ie.fields) !== null && ge !== void 0 ? ge : {}).reduce((Ce, [Me, Be]) => (Be !== void 0 && (Ce[Me] = Be), Ce), {}), be;
    },
    wrap(ie) {
      const ge = V();
      return ie !== void 0 && Object.keys(ie).forEach((be) => {
        ge.fields[be] = ie[be];
      }), ge;
    },
    unwrap(ie) {
      const ge = {};
      return Object.keys(ie.fields).forEach((be) => {
        ge[be] = ie.fields[be];
      }), ge;
    }
  };
  function X() {
    return { key: "", value: void 0 };
  }
  a.Struct_FieldsEntry = {
    encode(ie, ge = _.Writer.create()) {
      return ie.key !== "" && ge.uint32(10).string(ie.key), ie.value !== void 0 && a.Value.encode(a.Value.wrap(ie.value), ge.uint32(18).fork()).ldelim(), ge;
    },
    decode(ie, ge) {
      const be = ie instanceof _.Reader ? ie : new _.Reader(ie);
      let Ce = ge === void 0 ? be.len : be.pos + ge;
      const Me = X();
      for (; be.pos < Ce; ) {
        const Be = be.uint32();
        switch (Be >>> 3) {
          case 1:
            Me.key = be.string();
            break;
          case 2:
            Me.value = a.Value.unwrap(a.Value.decode(be, be.uint32()));
            break;
          default:
            be.skipType(Be & 7);
            break;
        }
      }
      return Me;
    },
    fromJSON(ie) {
      return {
        key: fe(ie.key) ? String(ie.key) : "",
        value: fe(ie == null ? void 0 : ie.value) ? ie.value : void 0
      };
    },
    toJSON(ie) {
      const ge = {};
      return ie.key !== void 0 && (ge.key = ie.key), ie.value !== void 0 && (ge.value = ie.value), ge;
    },
    fromPartial(ie) {
      var ge, be;
      const Ce = X();
      return Ce.key = (ge = ie.key) !== null && ge !== void 0 ? ge : "", Ce.value = (be = ie.value) !== null && be !== void 0 ? be : void 0, Ce;
    }
  };
  function oe() {
    return {
      nullValue: void 0,
      numberValue: void 0,
      stringValue: void 0,
      boolValue: void 0,
      structValue: void 0,
      listValue: void 0
    };
  }
  a.Value = {
    encode(ie, ge = _.Writer.create()) {
      return ie.nullValue !== void 0 && ge.uint32(8).int32(F(ie.nullValue)), ie.numberValue !== void 0 && ge.uint32(17).double(ie.numberValue), ie.stringValue !== void 0 && ge.uint32(26).string(ie.stringValue), ie.boolValue !== void 0 && ge.uint32(32).bool(ie.boolValue), ie.structValue !== void 0 && a.Struct.encode(a.Struct.wrap(ie.structValue), ge.uint32(42).fork()).ldelim(), ie.listValue !== void 0 && a.ListValue.encode(a.ListValue.wrap(ie.listValue), ge.uint32(50).fork()).ldelim(), ge;
    },
    decode(ie, ge) {
      const be = ie instanceof _.Reader ? ie : new _.Reader(ie);
      let Ce = ge === void 0 ? be.len : be.pos + ge;
      const Me = oe();
      for (; be.pos < Ce; ) {
        const Be = be.uint32();
        switch (Be >>> 3) {
          case 1:
            Me.nullValue = M(be.int32());
            break;
          case 2:
            Me.numberValue = be.double();
            break;
          case 3:
            Me.stringValue = be.string();
            break;
          case 4:
            Me.boolValue = be.bool();
            break;
          case 5:
            Me.structValue = a.Struct.unwrap(a.Struct.decode(be, be.uint32()));
            break;
          case 6:
            Me.listValue = a.ListValue.unwrap(a.ListValue.decode(be, be.uint32()));
            break;
          default:
            be.skipType(Be & 7);
            break;
        }
      }
      return Me;
    },
    fromJSON(ie) {
      return {
        nullValue: fe(ie.nullValue) ? M(ie.nullValue) : void 0,
        numberValue: fe(ie.numberValue) ? Number(ie.numberValue) : void 0,
        stringValue: fe(ie.stringValue) ? String(ie.stringValue) : void 0,
        boolValue: fe(ie.boolValue) ? !!ie.boolValue : void 0,
        structValue: ne(ie.structValue) ? ie.structValue : void 0,
        listValue: Array.isArray(ie.listValue) ? [...ie.listValue] : void 0
      };
    },
    toJSON(ie) {
      const ge = {};
      return ie.nullValue !== void 0 && (ge.nullValue = ie.nullValue !== void 0 ? L(ie.nullValue) : void 0), ie.numberValue !== void 0 && (ge.numberValue = ie.numberValue), ie.stringValue !== void 0 && (ge.stringValue = ie.stringValue), ie.boolValue !== void 0 && (ge.boolValue = ie.boolValue), ie.structValue !== void 0 && (ge.structValue = ie.structValue), ie.listValue !== void 0 && (ge.listValue = ie.listValue), ge;
    },
    fromPartial(ie) {
      var ge, be, Ce, Me, Be, Ae;
      const Z = oe();
      return Z.nullValue = (ge = ie.nullValue) !== null && ge !== void 0 ? ge : void 0, Z.numberValue = (be = ie.numberValue) !== null && be !== void 0 ? be : void 0, Z.stringValue = (Ce = ie.stringValue) !== null && Ce !== void 0 ? Ce : void 0, Z.boolValue = (Me = ie.boolValue) !== null && Me !== void 0 ? Me : void 0, Z.structValue = (Be = ie.structValue) !== null && Be !== void 0 ? Be : void 0, Z.listValue = (Ae = ie.listValue) !== null && Ae !== void 0 ? Ae : void 0, Z;
    },
    wrap(ie) {
      const ge = oe();
      if (ie === null)
        ge.nullValue = k.NULL_VALUE;
      else if (typeof ie == "boolean")
        ge.boolValue = ie;
      else if (typeof ie == "number")
        ge.numberValue = ie;
      else if (typeof ie == "string")
        ge.stringValue = ie;
      else if (Array.isArray(ie))
        ge.listValue = ie;
      else if (typeof ie == "object")
        ge.structValue = ie;
      else if (typeof ie < "u")
        throw new Error("Unsupported any value type: " + typeof ie);
      return ge;
    },
    unwrap(ie) {
      if ((ie == null ? void 0 : ie.stringValue) !== void 0)
        return ie.stringValue;
      if ((ie == null ? void 0 : ie.numberValue) !== void 0)
        return ie.numberValue;
      if ((ie == null ? void 0 : ie.boolValue) !== void 0)
        return ie.boolValue;
      if ((ie == null ? void 0 : ie.structValue) !== void 0)
        return ie.structValue;
      if ((ie == null ? void 0 : ie.listValue) !== void 0)
        return ie.listValue;
      if ((ie == null ? void 0 : ie.nullValue) !== void 0)
        return null;
    }
  };
  function Y() {
    return { values: [] };
  }
  a.ListValue = {
    encode(ie, ge = _.Writer.create()) {
      for (const be of ie.values)
        a.Value.encode(a.Value.wrap(be), ge.uint32(10).fork()).ldelim();
      return ge;
    },
    decode(ie, ge) {
      const be = ie instanceof _.Reader ? ie : new _.Reader(ie);
      let Ce = ge === void 0 ? be.len : be.pos + ge;
      const Me = Y();
      for (; be.pos < Ce; ) {
        const Be = be.uint32();
        switch (Be >>> 3) {
          case 1:
            Me.values.push(a.Value.unwrap(a.Value.decode(be, be.uint32())));
            break;
          default:
            be.skipType(Be & 7);
            break;
        }
      }
      return Me;
    },
    fromJSON(ie) {
      return {
        values: Array.isArray(ie == null ? void 0 : ie.values) ? [...ie.values] : []
      };
    },
    toJSON(ie) {
      const ge = {};
      return ie.values ? ge.values = ie.values.map((be) => be) : ge.values = [], ge;
    },
    fromPartial(ie) {
      var ge;
      const be = Y();
      return be.values = ((ge = ie.values) === null || ge === void 0 ? void 0 : ge.map((Ce) => Ce)) || [], be;
    },
    wrap(ie) {
      const ge = Y();
      return ge.values = ie ?? [], ge;
    },
    unwrap(ie) {
      return ie.values;
    }
  };
  var ae = (() => {
    if (typeof ae < "u")
      return ae;
    if (typeof self < "u")
      return self;
    if (typeof window < "u")
      return window;
    if (typeof commonjsGlobal$1 < "u")
      return commonjsGlobal$1;
    throw "Unable to locate global object";
  })();
  _.util.Long !== p.default && (_.util.Long = p.default, _.configure());
  function ne(ie) {
    return typeof ie == "object" && ie !== null;
  }
  function fe(ie) {
    return ie != null;
  }
})(struct$2);
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(x, se, Ee, xe) {
    xe === void 0 && (xe = Ee), Object.defineProperty(x, xe, { enumerable: !0, get: function() {
      return se[Ee];
    } });
  } : function(x, se, Ee, xe) {
    xe === void 0 && (xe = Ee), x[xe] = se[Ee];
  }), c = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(x, se) {
    Object.defineProperty(x, "default", { enumerable: !0, value: se });
  } : function(x, se) {
    x.default = se;
  }), l = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(x) {
    if (x && x.__esModule)
      return x;
    var se = {};
    if (x != null)
      for (var Ee in x)
        Ee !== "default" && Object.hasOwnProperty.call(x, Ee) && u(se, x, Ee);
    return c(se, x), se;
  }, v = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(x) {
    return x && x.__esModule ? x : { default: x };
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.LayoutServiceDefinition = a.LayoutServiceClientImpl = a.LayerServiceDefinition = a.LayerServiceClientImpl = a.Event = a.LayerEvent = a.LayoutEvent = a.BatchLayerRequest_BatchItem = a.BatchLayerRequest = a.BatchDeleteLayerRequest = a.DeleteLayerPayload = a.UpdateLayerRequest = a.GetLayerRequest = a.CreateLayerRequest = a.ListLayersResponse = a.ListLayersRequest = a.PartialLayerWithID = a.PartialLayer = a.LayerAnimation = a.DeleteLayoutResponse = a.DeleteLayoutRequest = a.DeleteLayoutPayload = a.UpdateLayoutRequest = a.GetLayoutRequest = a.CreateLayoutRequest = a.ListLayoutsResponse = a.ListLayoutsRequest = a.PartialLayout = a.BatchLayerResponse_BatchLayerItem = a.BatchLayerResponse = a.DeleteLayerResponse = a.DeleteLayerRequest = a.Layer = a.Layout = a.Transition_TransitionStinger = a.Transition_TransitionStingerCut = a.Transition_TransitionSwipe = a.Transition_TransitionCrossfade = a.Transition_TransitionFadeToColor = a.Transition_TransitionCut = a.Transition_TransitionMediaType = a.Transition = a.transition_TransitionSwipeTypeToNumber = a.transition_TransitionSwipeTypeToJSON = a.transition_TransitionSwipeTypeFromJSON = a.Transition_TransitionSwipeType = a.transition_TransitionDirectionToNumber = a.transition_TransitionDirectionToJSON = a.transition_TransitionDirectionFromJSON = a.Transition_TransitionDirection = a.eventTypeToNumber = a.eventTypeToJSON = a.eventTypeFromJSON = a.EventType = a.eventSubTypeToNumber = a.eventSubTypeToJSON = a.eventSubTypeFromJSON = a.EventSubType = a.requestAnimationModeToNumber = a.requestAnimationModeToJSON = a.requestAnimationModeFromJSON = a.RequestAnimationMode = a.layoutTypeToNumber = a.layoutTypeToJSON = a.layoutTypeFromJSON = a.LayoutType = a.protobufPackage = void 0;
  const p = v(umdExports), _ = l(minimal), k = struct$2;
  a.protobufPackage = "apis.layout.v2";
  var M;
  (function(x) {
    x.LAYOUT_TYPE_UNSPECIFIED = "LAYOUT_TYPE_UNSPECIFIED", x.LAYOUT_TYPE_SCENELESS = "LAYOUT_TYPE_SCENELESS", x.LAYOUT_TYPE_SCENE = "LAYOUT_TYPE_SCENE";
  })(M = a.LayoutType || (a.LayoutType = {}));
  function L(x) {
    switch (x) {
      case 0:
      case "LAYOUT_TYPE_UNSPECIFIED":
        return M.LAYOUT_TYPE_UNSPECIFIED;
      case 1:
      case "LAYOUT_TYPE_SCENELESS":
        return M.LAYOUT_TYPE_SCENELESS;
      case 2:
      case "LAYOUT_TYPE_SCENE":
        return M.LAYOUT_TYPE_SCENE;
      default:
        throw new Ve.Error("Unrecognized enum value " + x + " for enum LayoutType");
    }
  }
  a.layoutTypeFromJSON = L;
  function F(x) {
    switch (x) {
      case M.LAYOUT_TYPE_UNSPECIFIED:
        return "LAYOUT_TYPE_UNSPECIFIED";
      case M.LAYOUT_TYPE_SCENELESS:
        return "LAYOUT_TYPE_SCENELESS";
      case M.LAYOUT_TYPE_SCENE:
        return "LAYOUT_TYPE_SCENE";
      default:
        return "UNKNOWN";
    }
  }
  a.layoutTypeToJSON = F;
  function V(x) {
    switch (x) {
      case M.LAYOUT_TYPE_UNSPECIFIED:
        return 0;
      case M.LAYOUT_TYPE_SCENELESS:
        return 1;
      case M.LAYOUT_TYPE_SCENE:
        return 2;
      default:
        return 0;
    }
  }
  a.layoutTypeToNumber = V;
  var X;
  (function(x) {
    x.REQUEST_ANIMATION_MODE_UNSPECIFIED = "REQUEST_ANIMATION_MODE_UNSPECIFIED", x.REQUEST_ANIMATION_MODE_PARALLEL = "REQUEST_ANIMATION_MODE_PARALLEL", x.REQUEST_ANIMATION_MODE_SERIES = "REQUEST_ANIMATION_MODE_SERIES";
  })(X = a.RequestAnimationMode || (a.RequestAnimationMode = {}));
  function oe(x) {
    switch (x) {
      case 0:
      case "REQUEST_ANIMATION_MODE_UNSPECIFIED":
        return X.REQUEST_ANIMATION_MODE_UNSPECIFIED;
      case 1:
      case "REQUEST_ANIMATION_MODE_PARALLEL":
        return X.REQUEST_ANIMATION_MODE_PARALLEL;
      case 2:
      case "REQUEST_ANIMATION_MODE_SERIES":
        return X.REQUEST_ANIMATION_MODE_SERIES;
      default:
        throw new Ve.Error("Unrecognized enum value " + x + " for enum RequestAnimationMode");
    }
  }
  a.requestAnimationModeFromJSON = oe;
  function Y(x) {
    switch (x) {
      case X.REQUEST_ANIMATION_MODE_UNSPECIFIED:
        return "REQUEST_ANIMATION_MODE_UNSPECIFIED";
      case X.REQUEST_ANIMATION_MODE_PARALLEL:
        return "REQUEST_ANIMATION_MODE_PARALLEL";
      case X.REQUEST_ANIMATION_MODE_SERIES:
        return "REQUEST_ANIMATION_MODE_SERIES";
      default:
        return "UNKNOWN";
    }
  }
  a.requestAnimationModeToJSON = Y;
  function ae(x) {
    switch (x) {
      case X.REQUEST_ANIMATION_MODE_UNSPECIFIED:
        return 0;
      case X.REQUEST_ANIMATION_MODE_PARALLEL:
        return 1;
      case X.REQUEST_ANIMATION_MODE_SERIES:
        return 2;
      default:
        return 0;
    }
  }
  a.requestAnimationModeToNumber = ae;
  var ne;
  (function(x) {
    x.EVENT_SUB_TYPE_UNSPECIFIED = "EVENT_SUB_TYPE_UNSPECIFIED", x.EVENT_SUB_TYPE_CREATE = "EVENT_SUB_TYPE_CREATE", x.EVENT_SUB_TYPE_UPDATE = "EVENT_SUB_TYPE_UPDATE", x.EVENT_SUB_TYPE_DELETE = "EVENT_SUB_TYPE_DELETE", x.EVENT_SUB_TYPE_BATCH = "EVENT_SUB_TYPE_BATCH";
  })(ne = a.EventSubType || (a.EventSubType = {}));
  function fe(x) {
    switch (x) {
      case 0:
      case "EVENT_SUB_TYPE_UNSPECIFIED":
        return ne.EVENT_SUB_TYPE_UNSPECIFIED;
      case 1:
      case "EVENT_SUB_TYPE_CREATE":
        return ne.EVENT_SUB_TYPE_CREATE;
      case 2:
      case "EVENT_SUB_TYPE_UPDATE":
        return ne.EVENT_SUB_TYPE_UPDATE;
      case 3:
      case "EVENT_SUB_TYPE_DELETE":
        return ne.EVENT_SUB_TYPE_DELETE;
      case 4:
      case "EVENT_SUB_TYPE_BATCH":
        return ne.EVENT_SUB_TYPE_BATCH;
      default:
        throw new Ve.Error("Unrecognized enum value " + x + " for enum EventSubType");
    }
  }
  a.eventSubTypeFromJSON = fe;
  function ie(x) {
    switch (x) {
      case ne.EVENT_SUB_TYPE_UNSPECIFIED:
        return "EVENT_SUB_TYPE_UNSPECIFIED";
      case ne.EVENT_SUB_TYPE_CREATE:
        return "EVENT_SUB_TYPE_CREATE";
      case ne.EVENT_SUB_TYPE_UPDATE:
        return "EVENT_SUB_TYPE_UPDATE";
      case ne.EVENT_SUB_TYPE_DELETE:
        return "EVENT_SUB_TYPE_DELETE";
      case ne.EVENT_SUB_TYPE_BATCH:
        return "EVENT_SUB_TYPE_BATCH";
      default:
        return "UNKNOWN";
    }
  }
  a.eventSubTypeToJSON = ie;
  function ge(x) {
    switch (x) {
      case ne.EVENT_SUB_TYPE_UNSPECIFIED:
        return 0;
      case ne.EVENT_SUB_TYPE_CREATE:
        return 1;
      case ne.EVENT_SUB_TYPE_UPDATE:
        return 2;
      case ne.EVENT_SUB_TYPE_DELETE:
        return 3;
      case ne.EVENT_SUB_TYPE_BATCH:
        return 4;
      default:
        return 0;
    }
  }
  a.eventSubTypeToNumber = ge;
  var be;
  (function(x) {
    x.EVENT_TYPE_UNSPECIFIED = "EVENT_TYPE_UNSPECIFIED", x.EVENT_TYPE_LAYOUT = "EVENT_TYPE_LAYOUT", x.EVENT_TYPE_LAYER = "EVENT_TYPE_LAYER";
  })(be = a.EventType || (a.EventType = {}));
  function Ce(x) {
    switch (x) {
      case 0:
      case "EVENT_TYPE_UNSPECIFIED":
        return be.EVENT_TYPE_UNSPECIFIED;
      case 1:
      case "EVENT_TYPE_LAYOUT":
        return be.EVENT_TYPE_LAYOUT;
      case 2:
      case "EVENT_TYPE_LAYER":
        return be.EVENT_TYPE_LAYER;
      default:
        throw new Ve.Error("Unrecognized enum value " + x + " for enum EventType");
    }
  }
  a.eventTypeFromJSON = Ce;
  function Me(x) {
    switch (x) {
      case be.EVENT_TYPE_UNSPECIFIED:
        return "EVENT_TYPE_UNSPECIFIED";
      case be.EVENT_TYPE_LAYOUT:
        return "EVENT_TYPE_LAYOUT";
      case be.EVENT_TYPE_LAYER:
        return "EVENT_TYPE_LAYER";
      default:
        return "UNKNOWN";
    }
  }
  a.eventTypeToJSON = Me;
  function Be(x) {
    switch (x) {
      case be.EVENT_TYPE_UNSPECIFIED:
        return 0;
      case be.EVENT_TYPE_LAYOUT:
        return 1;
      case be.EVENT_TYPE_LAYER:
        return 2;
      default:
        return 0;
    }
  }
  a.eventTypeToNumber = Be;
  var Ae;
  (function(x) {
    x.TRANSITION_DIRECTION_UNSPECIFIED = "TRANSITION_DIRECTION_UNSPECIFIED", x.TRANSITION_DIRECTION_LEFT = "TRANSITION_DIRECTION_LEFT", x.TRANSITION_DIRECTION_RIGHT = "TRANSITION_DIRECTION_RIGHT", x.TRANSITION_DIRECTION_UP = "TRANSITION_DIRECTION_UP", x.TRANSITION_DIRECTION_DOWN = "TRANSITION_DIRECTION_DOWN";
  })(Ae = a.Transition_TransitionDirection || (a.Transition_TransitionDirection = {}));
  function Z(x) {
    switch (x) {
      case 0:
      case "TRANSITION_DIRECTION_UNSPECIFIED":
        return Ae.TRANSITION_DIRECTION_UNSPECIFIED;
      case 1:
      case "TRANSITION_DIRECTION_LEFT":
        return Ae.TRANSITION_DIRECTION_LEFT;
      case 2:
      case "TRANSITION_DIRECTION_RIGHT":
        return Ae.TRANSITION_DIRECTION_RIGHT;
      case 3:
      case "TRANSITION_DIRECTION_UP":
        return Ae.TRANSITION_DIRECTION_UP;
      case 4:
      case "TRANSITION_DIRECTION_DOWN":
        return Ae.TRANSITION_DIRECTION_DOWN;
      default:
        throw new Ve.Error("Unrecognized enum value " + x + " for enum Transition_TransitionDirection");
    }
  }
  a.transition_TransitionDirectionFromJSON = Z;
  function z(x) {
    switch (x) {
      case Ae.TRANSITION_DIRECTION_UNSPECIFIED:
        return "TRANSITION_DIRECTION_UNSPECIFIED";
      case Ae.TRANSITION_DIRECTION_LEFT:
        return "TRANSITION_DIRECTION_LEFT";
      case Ae.TRANSITION_DIRECTION_RIGHT:
        return "TRANSITION_DIRECTION_RIGHT";
      case Ae.TRANSITION_DIRECTION_UP:
        return "TRANSITION_DIRECTION_UP";
      case Ae.TRANSITION_DIRECTION_DOWN:
        return "TRANSITION_DIRECTION_DOWN";
      default:
        return "UNKNOWN";
    }
  }
  a.transition_TransitionDirectionToJSON = z;
  function P(x) {
    switch (x) {
      case Ae.TRANSITION_DIRECTION_UNSPECIFIED:
        return 0;
      case Ae.TRANSITION_DIRECTION_LEFT:
        return 1;
      case Ae.TRANSITION_DIRECTION_RIGHT:
        return 2;
      case Ae.TRANSITION_DIRECTION_UP:
        return 3;
      case Ae.TRANSITION_DIRECTION_DOWN:
        return 4;
      default:
        return 0;
    }
  }
  a.transition_TransitionDirectionToNumber = P;
  var S;
  (function(x) {
    x.TRANSITION_SWIPE_TYPE_UNSPECIFIED = "TRANSITION_SWIPE_TYPE_UNSPECIFIED", x.TRANSITION_SWIPE_TYPE_COMBINED = "TRANSITION_SWIPE_TYPE_COMBINED", x.TRANSITION_SWIPE_TYPE_SOURCE = "TRANSITION_SWIPE_TYPE_SOURCE", x.TRANSITION_SWIPE_TYPE_DESTINATION = "TRANSITION_SWIPE_TYPE_DESTINATION";
  })(S = a.Transition_TransitionSwipeType || (a.Transition_TransitionSwipeType = {}));
  function E(x) {
    switch (x) {
      case 0:
      case "TRANSITION_SWIPE_TYPE_UNSPECIFIED":
        return S.TRANSITION_SWIPE_TYPE_UNSPECIFIED;
      case 1:
      case "TRANSITION_SWIPE_TYPE_COMBINED":
        return S.TRANSITION_SWIPE_TYPE_COMBINED;
      case 2:
      case "TRANSITION_SWIPE_TYPE_SOURCE":
        return S.TRANSITION_SWIPE_TYPE_SOURCE;
      case 3:
      case "TRANSITION_SWIPE_TYPE_DESTINATION":
        return S.TRANSITION_SWIPE_TYPE_DESTINATION;
      default:
        throw new Ve.Error("Unrecognized enum value " + x + " for enum Transition_TransitionSwipeType");
    }
  }
  a.transition_TransitionSwipeTypeFromJSON = E;
  function I(x) {
    switch (x) {
      case S.TRANSITION_SWIPE_TYPE_UNSPECIFIED:
        return "TRANSITION_SWIPE_TYPE_UNSPECIFIED";
      case S.TRANSITION_SWIPE_TYPE_COMBINED:
        return "TRANSITION_SWIPE_TYPE_COMBINED";
      case S.TRANSITION_SWIPE_TYPE_SOURCE:
        return "TRANSITION_SWIPE_TYPE_SOURCE";
      case S.TRANSITION_SWIPE_TYPE_DESTINATION:
        return "TRANSITION_SWIPE_TYPE_DESTINATION";
      default:
        return "UNKNOWN";
    }
  }
  a.transition_TransitionSwipeTypeToJSON = I;
  function N(x) {
    switch (x) {
      case S.TRANSITION_SWIPE_TYPE_UNSPECIFIED:
        return 0;
      case S.TRANSITION_SWIPE_TYPE_COMBINED:
        return 1;
      case S.TRANSITION_SWIPE_TYPE_SOURCE:
        return 2;
      case S.TRANSITION_SWIPE_TYPE_DESTINATION:
        return 3;
      default:
        return 0;
    }
  }
  a.transition_TransitionSwipeTypeToNumber = N;
  function $() {
    return {
      fromLayoutIds: [],
      cut: void 0,
      crossfade: void 0,
      fadeToColor: void 0,
      swipe: void 0,
      stinger: void 0
    };
  }
  a.Transition = {
    encode(x, se = _.Writer.create()) {
      for (const Ee of x.fromLayoutIds)
        se.uint32(10).string(Ee);
      return x.cut !== void 0 && a.Transition_TransitionCut.encode(x.cut, se.uint32(82).fork()).ldelim(), x.crossfade !== void 0 && a.Transition_TransitionCrossfade.encode(x.crossfade, se.uint32(90).fork()).ldelim(), x.fadeToColor !== void 0 && a.Transition_TransitionFadeToColor.encode(x.fadeToColor, se.uint32(98).fork()).ldelim(), x.swipe !== void 0 && a.Transition_TransitionSwipe.encode(x.swipe, se.uint32(106).fork()).ldelim(), x.stinger !== void 0 && a.Transition_TransitionStinger.encode(x.stinger, se.uint32(114).fork()).ldelim(), se;
    },
    decode(x, se) {
      const Ee = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Ee.len : Ee.pos + se;
      const $e = $();
      for (; Ee.pos < xe; ) {
        const Ye = Ee.uint32();
        switch (Ye >>> 3) {
          case 1:
            $e.fromLayoutIds.push(Ee.string());
            break;
          case 10:
            $e.cut = a.Transition_TransitionCut.decode(Ee, Ee.uint32());
            break;
          case 11:
            $e.crossfade = a.Transition_TransitionCrossfade.decode(Ee, Ee.uint32());
            break;
          case 12:
            $e.fadeToColor = a.Transition_TransitionFadeToColor.decode(Ee, Ee.uint32());
            break;
          case 13:
            $e.swipe = a.Transition_TransitionSwipe.decode(Ee, Ee.uint32());
            break;
          case 14:
            $e.stinger = a.Transition_TransitionStinger.decode(Ee, Ee.uint32());
            break;
          default:
            Ee.skipType(Ye & 7);
            break;
        }
      }
      return $e;
    },
    fromJSON(x) {
      return {
        fromLayoutIds: Array.isArray(x == null ? void 0 : x.fromLayoutIds) ? x.fromLayoutIds.map((se) => String(se)) : [],
        cut: Ke(x.cut) ? a.Transition_TransitionCut.fromJSON(x.cut) : void 0,
        crossfade: Ke(x.crossfade) ? a.Transition_TransitionCrossfade.fromJSON(x.crossfade) : void 0,
        fadeToColor: Ke(x.fadeToColor) ? a.Transition_TransitionFadeToColor.fromJSON(x.fadeToColor) : void 0,
        swipe: Ke(x.swipe) ? a.Transition_TransitionSwipe.fromJSON(x.swipe) : void 0,
        stinger: Ke(x.stinger) ? a.Transition_TransitionStinger.fromJSON(x.stinger) : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.fromLayoutIds ? se.fromLayoutIds = x.fromLayoutIds.map((Ee) => Ee) : se.fromLayoutIds = [], x.cut !== void 0 && (se.cut = x.cut ? a.Transition_TransitionCut.toJSON(x.cut) : void 0), x.crossfade !== void 0 && (se.crossfade = x.crossfade ? a.Transition_TransitionCrossfade.toJSON(x.crossfade) : void 0), x.fadeToColor !== void 0 && (se.fadeToColor = x.fadeToColor ? a.Transition_TransitionFadeToColor.toJSON(x.fadeToColor) : void 0), x.swipe !== void 0 && (se.swipe = x.swipe ? a.Transition_TransitionSwipe.toJSON(x.swipe) : void 0), x.stinger !== void 0 && (se.stinger = x.stinger ? a.Transition_TransitionStinger.toJSON(x.stinger) : void 0), se;
    },
    fromPartial(x) {
      var se;
      const Ee = $();
      return Ee.fromLayoutIds = ((se = x.fromLayoutIds) === null || se === void 0 ? void 0 : se.map((xe) => xe)) || [], Ee.cut = x.cut !== void 0 && x.cut !== null ? a.Transition_TransitionCut.fromPartial(x.cut) : void 0, Ee.crossfade = x.crossfade !== void 0 && x.crossfade !== null ? a.Transition_TransitionCrossfade.fromPartial(x.crossfade) : void 0, Ee.fadeToColor = x.fadeToColor !== void 0 && x.fadeToColor !== null ? a.Transition_TransitionFadeToColor.fromPartial(x.fadeToColor) : void 0, Ee.swipe = x.swipe !== void 0 && x.swipe !== null ? a.Transition_TransitionSwipe.fromPartial(x.swipe) : void 0, Ee.stinger = x.stinger !== void 0 && x.stinger !== null ? a.Transition_TransitionStinger.fromPartial(x.stinger) : void 0, Ee;
    }
  };
  function U() {
    return { url: "", volume: 0 };
  }
  a.Transition_TransitionMediaType = {
    encode(x, se = _.Writer.create()) {
      return x.url !== "" && se.uint32(10).string(x.url), x.volume !== 0 && se.uint32(17).double(x.volume), se;
    },
    decode(x, se) {
      const Ee = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Ee.len : Ee.pos + se;
      const $e = U();
      for (; Ee.pos < xe; ) {
        const Ye = Ee.uint32();
        switch (Ye >>> 3) {
          case 1:
            $e.url = Ee.string();
            break;
          case 2:
            $e.volume = Ee.double();
            break;
          default:
            Ee.skipType(Ye & 7);
            break;
        }
      }
      return $e;
    },
    fromJSON(x) {
      return {
        url: Ke(x.url) ? String(x.url) : "",
        volume: Ke(x.volume) ? Number(x.volume) : 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.url !== void 0 && (se.url = x.url), x.volume !== void 0 && (se.volume = x.volume), se;
    },
    fromPartial(x) {
      var se, Ee;
      const xe = U();
      return xe.url = (se = x.url) !== null && se !== void 0 ? se : "", xe.volume = (Ee = x.volume) !== null && Ee !== void 0 ? Ee : 0, xe;
    }
  };
  function H() {
    return {};
  }
  a.Transition_TransitionCut = {
    encode(x, se = _.Writer.create()) {
      return se;
    },
    decode(x, se) {
      const Ee = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Ee.len : Ee.pos + se;
      const $e = H();
      for (; Ee.pos < xe; ) {
        const Ye = Ee.uint32();
        switch (Ye >>> 3) {
          default:
            Ee.skipType(Ye & 7);
            break;
        }
      }
      return $e;
    },
    fromJSON(x) {
      return {};
    },
    toJSON(x) {
      return {};
    },
    fromPartial(x) {
      return H();
    }
  };
  function B() {
    return { durationMs: 0, backgroundColor: "" };
  }
  a.Transition_TransitionFadeToColor = {
    encode(x, se = _.Writer.create()) {
      return x.durationMs !== 0 && se.uint32(8).int32(x.durationMs), x.backgroundColor !== "" && se.uint32(18).string(x.backgroundColor), se;
    },
    decode(x, se) {
      const Ee = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Ee.len : Ee.pos + se;
      const $e = B();
      for (; Ee.pos < xe; ) {
        const Ye = Ee.uint32();
        switch (Ye >>> 3) {
          case 1:
            $e.durationMs = Ee.int32();
            break;
          case 2:
            $e.backgroundColor = Ee.string();
            break;
          default:
            Ee.skipType(Ye & 7);
            break;
        }
      }
      return $e;
    },
    fromJSON(x) {
      return {
        durationMs: Ke(x.durationMs) ? Number(x.durationMs) : 0,
        backgroundColor: Ke(x.backgroundColor) ? String(x.backgroundColor) : ""
      };
    },
    toJSON(x) {
      const se = {};
      return x.durationMs !== void 0 && (se.durationMs = Math.round(x.durationMs)), x.backgroundColor !== void 0 && (se.backgroundColor = x.backgroundColor), se;
    },
    fromPartial(x) {
      var se, Ee;
      const xe = B();
      return xe.durationMs = (se = x.durationMs) !== null && se !== void 0 ? se : 0, xe.backgroundColor = (Ee = x.backgroundColor) !== null && Ee !== void 0 ? Ee : "", xe;
    }
  };
  function T() {
    return { durationMs: 0 };
  }
  a.Transition_TransitionCrossfade = {
    encode(x, se = _.Writer.create()) {
      return x.durationMs !== 0 && se.uint32(8).int32(x.durationMs), se;
    },
    decode(x, se) {
      const Ee = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Ee.len : Ee.pos + se;
      const $e = T();
      for (; Ee.pos < xe; ) {
        const Ye = Ee.uint32();
        switch (Ye >>> 3) {
          case 1:
            $e.durationMs = Ee.int32();
            break;
          default:
            Ee.skipType(Ye & 7);
            break;
        }
      }
      return $e;
    },
    fromJSON(x) {
      return {
        durationMs: Ke(x.durationMs) ? Number(x.durationMs) : 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.durationMs !== void 0 && (se.durationMs = Math.round(x.durationMs)), se;
    },
    fromPartial(x) {
      var se;
      const Ee = T();
      return Ee.durationMs = (se = x.durationMs) !== null && se !== void 0 ? se : 0, Ee;
    }
  };
  function D() {
    return {
      durationMs: 0,
      direction: Ae.TRANSITION_DIRECTION_UNSPECIFIED,
      combinedAnimation: S.TRANSITION_SWIPE_TYPE_UNSPECIFIED
    };
  }
  a.Transition_TransitionSwipe = {
    encode(x, se = _.Writer.create()) {
      return x.durationMs !== 0 && se.uint32(8).int32(x.durationMs), x.direction !== Ae.TRANSITION_DIRECTION_UNSPECIFIED && se.uint32(16).int32(P(x.direction)), x.combinedAnimation !== S.TRANSITION_SWIPE_TYPE_UNSPECIFIED && se.uint32(24).int32(N(x.combinedAnimation)), se;
    },
    decode(x, se) {
      const Ee = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Ee.len : Ee.pos + se;
      const $e = D();
      for (; Ee.pos < xe; ) {
        const Ye = Ee.uint32();
        switch (Ye >>> 3) {
          case 1:
            $e.durationMs = Ee.int32();
            break;
          case 2:
            $e.direction = Z(Ee.int32());
            break;
          case 3:
            $e.combinedAnimation = E(Ee.int32());
            break;
          default:
            Ee.skipType(Ye & 7);
            break;
        }
      }
      return $e;
    },
    fromJSON(x) {
      return {
        durationMs: Ke(x.durationMs) ? Number(x.durationMs) : 0,
        direction: Ke(x.direction) ? Z(x.direction) : Ae.TRANSITION_DIRECTION_UNSPECIFIED,
        combinedAnimation: Ke(x.combinedAnimation) ? E(x.combinedAnimation) : S.TRANSITION_SWIPE_TYPE_UNSPECIFIED
      };
    },
    toJSON(x) {
      const se = {};
      return x.durationMs !== void 0 && (se.durationMs = Math.round(x.durationMs)), x.direction !== void 0 && (se.direction = z(x.direction)), x.combinedAnimation !== void 0 && (se.combinedAnimation = I(x.combinedAnimation)), se;
    },
    fromPartial(x) {
      var se, Ee, xe;
      const $e = D();
      return $e.durationMs = (se = x.durationMs) !== null && se !== void 0 ? se : 0, $e.direction = (Ee = x.direction) !== null && Ee !== void 0 ? Ee : Ae.TRANSITION_DIRECTION_UNSPECIFIED, $e.combinedAnimation = (xe = x.combinedAnimation) !== null && xe !== void 0 ? xe : S.TRANSITION_SWIPE_TYPE_UNSPECIFIED, $e;
    }
  };
  function ee() {
    return { cutPointMs: 0, media: void 0 };
  }
  a.Transition_TransitionStingerCut = {
    encode(x, se = _.Writer.create()) {
      return x.cutPointMs !== 0 && se.uint32(8).int32(x.cutPointMs), x.media !== void 0 && a.Transition_TransitionMediaType.encode(x.media, se.uint32(18).fork()).ldelim(), se;
    },
    decode(x, se) {
      const Ee = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Ee.len : Ee.pos + se;
      const $e = ee();
      for (; Ee.pos < xe; ) {
        const Ye = Ee.uint32();
        switch (Ye >>> 3) {
          case 1:
            $e.cutPointMs = Ee.int32();
            break;
          case 2:
            $e.media = a.Transition_TransitionMediaType.decode(Ee, Ee.uint32());
            break;
          default:
            Ee.skipType(Ye & 7);
            break;
        }
      }
      return $e;
    },
    fromJSON(x) {
      return {
        cutPointMs: Ke(x.cutPointMs) ? Number(x.cutPointMs) : 0,
        media: Ke(x.media) ? a.Transition_TransitionMediaType.fromJSON(x.media) : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.cutPointMs !== void 0 && (se.cutPointMs = Math.round(x.cutPointMs)), x.media !== void 0 && (se.media = x.media ? a.Transition_TransitionMediaType.toJSON(x.media) : void 0), se;
    },
    fromPartial(x) {
      var se;
      const Ee = ee();
      return Ee.cutPointMs = (se = x.cutPointMs) !== null && se !== void 0 ? se : 0, Ee.media = x.media !== void 0 && x.media !== null ? a.Transition_TransitionMediaType.fromPartial(x.media) : void 0, Ee;
    }
  };
  function pe() {
    return { cut: void 0 };
  }
  a.Transition_TransitionStinger = {
    encode(x, se = _.Writer.create()) {
      return x.cut !== void 0 && a.Transition_TransitionStingerCut.encode(x.cut, se.uint32(10).fork()).ldelim(), se;
    },
    decode(x, se) {
      const Ee = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Ee.len : Ee.pos + se;
      const $e = pe();
      for (; Ee.pos < xe; ) {
        const Ye = Ee.uint32();
        switch (Ye >>> 3) {
          case 1:
            $e.cut = a.Transition_TransitionStingerCut.decode(Ee, Ee.uint32());
            break;
          default:
            Ee.skipType(Ye & 7);
            break;
        }
      }
      return $e;
    },
    fromJSON(x) {
      return {
        cut: Ke(x.cut) ? a.Transition_TransitionStingerCut.fromJSON(x.cut) : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.cut !== void 0 && (se.cut = x.cut ? a.Transition_TransitionStingerCut.toJSON(x.cut) : void 0), se;
    },
    fromPartial(x) {
      const se = pe();
      return se.cut = x.cut !== void 0 && x.cut !== null ? a.Transition_TransitionStingerCut.fromPartial(x.cut) : void 0, se;
    }
  };
  function Ie() {
    return {
      id: "",
      width: 0,
      height: 0,
      metadata: void 0,
      projectId: void 0,
      collectionId: void 0,
      type: void 0,
      transitions: [],
      requestMetadata: void 0
    };
  }
  a.Layout = {
    encode(x, se = _.Writer.create()) {
      x.id !== "" && se.uint32(10).string(x.id), x.width !== 0 && se.uint32(16).int32(x.width), x.height !== 0 && se.uint32(24).int32(x.height), x.metadata !== void 0 && k.Value.encode(k.Value.wrap(x.metadata), se.uint32(50).fork()).ldelim(), x.projectId !== void 0 && se.uint32(58).string(x.projectId), x.collectionId !== void 0 && se.uint32(66).string(x.collectionId), x.type !== void 0 && se.uint32(72).int32(V(x.type));
      for (const Ee of x.transitions)
        a.Transition.encode(Ee, se.uint32(82).fork()).ldelim();
      return x.requestMetadata !== void 0 && k.Value.encode(k.Value.wrap(x.requestMetadata), se.uint32(810).fork()).ldelim(), se;
    },
    decode(x, se) {
      const Ee = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Ee.len : Ee.pos + se;
      const $e = Ie();
      for (; Ee.pos < xe; ) {
        const Ye = Ee.uint32();
        switch (Ye >>> 3) {
          case 1:
            $e.id = Ee.string();
            break;
          case 2:
            $e.width = Ee.int32();
            break;
          case 3:
            $e.height = Ee.int32();
            break;
          case 6:
            $e.metadata = k.Value.unwrap(k.Value.decode(Ee, Ee.uint32()));
            break;
          case 7:
            $e.projectId = Ee.string();
            break;
          case 8:
            $e.collectionId = Ee.string();
            break;
          case 9:
            $e.type = L(Ee.int32());
            break;
          case 10:
            $e.transitions.push(a.Transition.decode(Ee, Ee.uint32()));
            break;
          case 101:
            $e.requestMetadata = k.Value.unwrap(k.Value.decode(Ee, Ee.uint32()));
            break;
          default:
            Ee.skipType(Ye & 7);
            break;
        }
      }
      return $e;
    },
    fromJSON(x) {
      return {
        id: Ke(x.id) ? String(x.id) : "",
        width: Ke(x.width) ? Number(x.width) : 0,
        height: Ke(x.height) ? Number(x.height) : 0,
        metadata: Ke(x == null ? void 0 : x.metadata) ? x.metadata : void 0,
        projectId: Ke(x.projectId) ? String(x.projectId) : void 0,
        collectionId: Ke(x.collectionId) ? String(x.collectionId) : void 0,
        type: Ke(x.type) ? L(x.type) : void 0,
        transitions: Array.isArray(x == null ? void 0 : x.transitions) ? x.transitions.map((se) => a.Transition.fromJSON(se)) : [],
        requestMetadata: Ke(x == null ? void 0 : x.requestMetadata) ? x.requestMetadata : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.id !== void 0 && (se.id = x.id), x.width !== void 0 && (se.width = Math.round(x.width)), x.height !== void 0 && (se.height = Math.round(x.height)), x.metadata !== void 0 && (se.metadata = x.metadata), x.projectId !== void 0 && (se.projectId = x.projectId), x.collectionId !== void 0 && (se.collectionId = x.collectionId), x.type !== void 0 && (se.type = x.type !== void 0 ? F(x.type) : void 0), x.transitions ? se.transitions = x.transitions.map((Ee) => Ee ? a.Transition.toJSON(Ee) : void 0) : se.transitions = [], x.requestMetadata !== void 0 && (se.requestMetadata = x.requestMetadata), se;
    },
    fromPartial(x) {
      var se, Ee, xe, $e, Ye, et, dt, St, tt;
      const at = Ie();
      return at.id = (se = x.id) !== null && se !== void 0 ? se : "", at.width = (Ee = x.width) !== null && Ee !== void 0 ? Ee : 0, at.height = (xe = x.height) !== null && xe !== void 0 ? xe : 0, at.metadata = ($e = x.metadata) !== null && $e !== void 0 ? $e : void 0, at.projectId = (Ye = x.projectId) !== null && Ye !== void 0 ? Ye : void 0, at.collectionId = (et = x.collectionId) !== null && et !== void 0 ? et : void 0, at.type = (dt = x.type) !== null && dt !== void 0 ? dt : void 0, at.transitions = ((St = x.transitions) === null || St === void 0 ? void 0 : St.map((wt) => a.Transition.fromPartial(wt))) || [], at.requestMetadata = (tt = x.requestMetadata) !== null && tt !== void 0 ? tt : void 0, at;
    }
  };
  function Pe() {
    return {
      type: "",
      data: void 0,
      x: void 0,
      y: void 0,
      width: void 0,
      height: void 0,
      rotation: 0,
      opacity: 0,
      scale: 0,
      hidden: !1,
      children: void 0,
      metadata: void 0,
      id: "",
      layoutId: "",
      requestMetadata: void 0,
      requestAnimation: []
    };
  }
  a.Layer = {
    encode(x, se = _.Writer.create()) {
      x.type !== "" && se.uint32(10).string(x.type), x.data !== void 0 && k.Struct.encode(k.Struct.wrap(x.data), se.uint32(18).fork()).ldelim(), x.x !== void 0 && k.Value.encode(k.Value.wrap(x.x), se.uint32(26).fork()).ldelim(), x.y !== void 0 && k.Value.encode(k.Value.wrap(x.y), se.uint32(34).fork()).ldelim(), x.width !== void 0 && k.Value.encode(k.Value.wrap(x.width), se.uint32(42).fork()).ldelim(), x.height !== void 0 && k.Value.encode(k.Value.wrap(x.height), se.uint32(50).fork()).ldelim(), x.rotation !== 0 && se.uint32(57).double(x.rotation), x.opacity !== 0 && se.uint32(65).double(x.opacity), x.scale !== 0 && se.uint32(73).double(x.scale), x.hidden === !0 && se.uint32(80).bool(x.hidden), x.children !== void 0 && k.ListValue.encode(k.ListValue.wrap(x.children), se.uint32(98).fork()).ldelim(), x.metadata !== void 0 && k.Value.encode(k.Value.wrap(x.metadata), se.uint32(114).fork()).ldelim(), x.id !== "" && se.uint32(802).string(x.id), x.layoutId !== "" && se.uint32(818).string(x.layoutId), x.requestMetadata !== void 0 && k.Value.encode(k.Value.wrap(x.requestMetadata), se.uint32(810).fork()).ldelim();
      for (const Ee of x.requestAnimation)
        a.LayerAnimation.encode(Ee, se.uint32(826).fork()).ldelim();
      return se;
    },
    decode(x, se) {
      const Ee = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Ee.len : Ee.pos + se;
      const $e = Pe();
      for (; Ee.pos < xe; ) {
        const Ye = Ee.uint32();
        switch (Ye >>> 3) {
          case 1:
            $e.type = Ee.string();
            break;
          case 2:
            $e.data = k.Struct.unwrap(k.Struct.decode(Ee, Ee.uint32()));
            break;
          case 3:
            $e.x = k.Value.unwrap(k.Value.decode(Ee, Ee.uint32()));
            break;
          case 4:
            $e.y = k.Value.unwrap(k.Value.decode(Ee, Ee.uint32()));
            break;
          case 5:
            $e.width = k.Value.unwrap(k.Value.decode(Ee, Ee.uint32()));
            break;
          case 6:
            $e.height = k.Value.unwrap(k.Value.decode(Ee, Ee.uint32()));
            break;
          case 7:
            $e.rotation = Ee.double();
            break;
          case 8:
            $e.opacity = Ee.double();
            break;
          case 9:
            $e.scale = Ee.double();
            break;
          case 10:
            $e.hidden = Ee.bool();
            break;
          case 12:
            $e.children = k.ListValue.unwrap(k.ListValue.decode(Ee, Ee.uint32()));
            break;
          case 14:
            $e.metadata = k.Value.unwrap(k.Value.decode(Ee, Ee.uint32()));
            break;
          case 100:
            $e.id = Ee.string();
            break;
          case 102:
            $e.layoutId = Ee.string();
            break;
          case 101:
            $e.requestMetadata = k.Value.unwrap(k.Value.decode(Ee, Ee.uint32()));
            break;
          case 103:
            $e.requestAnimation.push(a.LayerAnimation.decode(Ee, Ee.uint32()));
            break;
          default:
            Ee.skipType(Ye & 7);
            break;
        }
      }
      return $e;
    },
    fromJSON(x) {
      return {
        type: Ke(x.type) ? String(x.type) : "",
        data: Qe(x.data) ? x.data : void 0,
        x: Ke(x == null ? void 0 : x.x) ? x.x : void 0,
        y: Ke(x == null ? void 0 : x.y) ? x.y : void 0,
        width: Ke(x == null ? void 0 : x.width) ? x.width : void 0,
        height: Ke(x == null ? void 0 : x.height) ? x.height : void 0,
        rotation: Ke(x.rotation) ? Number(x.rotation) : 0,
        opacity: Ke(x.opacity) ? Number(x.opacity) : 0,
        scale: Ke(x.scale) ? Number(x.scale) : 0,
        hidden: Ke(x.hidden) ? !!x.hidden : !1,
        children: Array.isArray(x.children) ? [...x.children] : void 0,
        metadata: Ke(x == null ? void 0 : x.metadata) ? x.metadata : void 0,
        id: Ke(x.id) ? String(x.id) : "",
        layoutId: Ke(x.layoutId) ? String(x.layoutId) : "",
        requestMetadata: Ke(x == null ? void 0 : x.requestMetadata) ? x.requestMetadata : void 0,
        requestAnimation: Array.isArray(x == null ? void 0 : x.requestAnimation) ? x.requestAnimation.map((se) => a.LayerAnimation.fromJSON(se)) : []
      };
    },
    toJSON(x) {
      const se = {};
      return x.type !== void 0 && (se.type = x.type), x.data !== void 0 && (se.data = x.data), x.x !== void 0 && (se.x = x.x), x.y !== void 0 && (se.y = x.y), x.width !== void 0 && (se.width = x.width), x.height !== void 0 && (se.height = x.height), x.rotation !== void 0 && (se.rotation = x.rotation), x.opacity !== void 0 && (se.opacity = x.opacity), x.scale !== void 0 && (se.scale = x.scale), x.hidden !== void 0 && (se.hidden = x.hidden), x.children !== void 0 && (se.children = x.children), x.metadata !== void 0 && (se.metadata = x.metadata), x.id !== void 0 && (se.id = x.id), x.layoutId !== void 0 && (se.layoutId = x.layoutId), x.requestMetadata !== void 0 && (se.requestMetadata = x.requestMetadata), x.requestAnimation ? se.requestAnimation = x.requestAnimation.map((Ee) => Ee ? a.LayerAnimation.toJSON(Ee) : void 0) : se.requestAnimation = [], se;
    },
    fromPartial(x) {
      var se, Ee, xe, $e, Ye, et, dt, St, tt, at, wt, rt, ut, kt, nt, it;
      const bt = Pe();
      return bt.type = (se = x.type) !== null && se !== void 0 ? se : "", bt.data = (Ee = x.data) !== null && Ee !== void 0 ? Ee : void 0, bt.x = (xe = x.x) !== null && xe !== void 0 ? xe : void 0, bt.y = ($e = x.y) !== null && $e !== void 0 ? $e : void 0, bt.width = (Ye = x.width) !== null && Ye !== void 0 ? Ye : void 0, bt.height = (et = x.height) !== null && et !== void 0 ? et : void 0, bt.rotation = (dt = x.rotation) !== null && dt !== void 0 ? dt : 0, bt.opacity = (St = x.opacity) !== null && St !== void 0 ? St : 0, bt.scale = (tt = x.scale) !== null && tt !== void 0 ? tt : 0, bt.hidden = (at = x.hidden) !== null && at !== void 0 ? at : !1, bt.children = (wt = x.children) !== null && wt !== void 0 ? wt : void 0, bt.metadata = (rt = x.metadata) !== null && rt !== void 0 ? rt : void 0, bt.id = (ut = x.id) !== null && ut !== void 0 ? ut : "", bt.layoutId = (kt = x.layoutId) !== null && kt !== void 0 ? kt : "", bt.requestMetadata = (nt = x.requestMetadata) !== null && nt !== void 0 ? nt : void 0, bt.requestAnimation = ((it = x.requestAnimation) === null || it === void 0 ? void 0 : it.map((ot) => a.LayerAnimation.fromPartial(ot))) || [], bt;
    }
  };
  function he() {
    return { layoutId: "", layerId: "", payload: void 0 };
  }
  a.DeleteLayerRequest = {
    encode(x, se = _.Writer.create()) {
      return x.layoutId !== "" && se.uint32(10).string(x.layoutId), x.layerId !== "" && se.uint32(18).string(x.layerId), x.payload !== void 0 && a.DeleteLayerPayload.encode(x.payload, se.uint32(26).fork()).ldelim(), se;
    },
    decode(x, se) {
      const Ee = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Ee.len : Ee.pos + se;
      const $e = he();
      for (; Ee.pos < xe; ) {
        const Ye = Ee.uint32();
        switch (Ye >>> 3) {
          case 1:
            $e.layoutId = Ee.string();
            break;
          case 2:
            $e.layerId = Ee.string();
            break;
          case 3:
            $e.payload = a.DeleteLayerPayload.decode(Ee, Ee.uint32());
            break;
          default:
            Ee.skipType(Ye & 7);
            break;
        }
      }
      return $e;
    },
    fromJSON(x) {
      return {
        layoutId: Ke(x.layoutId) ? String(x.layoutId) : "",
        layerId: Ke(x.layerId) ? String(x.layerId) : "",
        payload: Ke(x.payload) ? a.DeleteLayerPayload.fromJSON(x.payload) : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.layoutId !== void 0 && (se.layoutId = x.layoutId), x.layerId !== void 0 && (se.layerId = x.layerId), x.payload !== void 0 && (se.payload = x.payload ? a.DeleteLayerPayload.toJSON(x.payload) : void 0), se;
    },
    fromPartial(x) {
      var se, Ee;
      const xe = he();
      return xe.layoutId = (se = x.layoutId) !== null && se !== void 0 ? se : "", xe.layerId = (Ee = x.layerId) !== null && Ee !== void 0 ? Ee : "", xe.payload = x.payload !== void 0 && x.payload !== null ? a.DeleteLayerPayload.fromPartial(x.payload) : void 0, xe;
    }
  };
  function ve() {
    return { id: "", layoutId: "", requestMetadata: void 0 };
  }
  a.DeleteLayerResponse = {
    encode(x, se = _.Writer.create()) {
      return x.id !== "" && se.uint32(10).string(x.id), x.layoutId !== "" && se.uint32(18).string(x.layoutId), x.requestMetadata !== void 0 && k.Value.encode(k.Value.wrap(x.requestMetadata), se.uint32(802).fork()).ldelim(), se;
    },
    decode(x, se) {
      const Ee = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Ee.len : Ee.pos + se;
      const $e = ve();
      for (; Ee.pos < xe; ) {
        const Ye = Ee.uint32();
        switch (Ye >>> 3) {
          case 1:
            $e.id = Ee.string();
            break;
          case 2:
            $e.layoutId = Ee.string();
            break;
          case 100:
            $e.requestMetadata = k.Value.unwrap(k.Value.decode(Ee, Ee.uint32()));
            break;
          default:
            Ee.skipType(Ye & 7);
            break;
        }
      }
      return $e;
    },
    fromJSON(x) {
      return {
        id: Ke(x.id) ? String(x.id) : "",
        layoutId: Ke(x.layoutId) ? String(x.layoutId) : "",
        requestMetadata: Ke(x == null ? void 0 : x.requestMetadata) ? x.requestMetadata : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.id !== void 0 && (se.id = x.id), x.layoutId !== void 0 && (se.layoutId = x.layoutId), x.requestMetadata !== void 0 && (se.requestMetadata = x.requestMetadata), se;
    },
    fromPartial(x) {
      var se, Ee, xe;
      const $e = ve();
      return $e.id = (se = x.id) !== null && se !== void 0 ? se : "", $e.layoutId = (Ee = x.layoutId) !== null && Ee !== void 0 ? Ee : "", $e.requestMetadata = (xe = x.requestMetadata) !== null && xe !== void 0 ? xe : void 0, $e;
    }
  };
  function Q() {
    return {
      layers: [],
      layoutId: "",
      requestMetadata: void 0,
      requestAnimationMode: X.REQUEST_ANIMATION_MODE_UNSPECIFIED
    };
  }
  a.BatchLayerResponse = {
    encode(x, se = _.Writer.create()) {
      for (const Ee of x.layers)
        a.BatchLayerResponse_BatchLayerItem.encode(Ee, se.uint32(18).fork()).ldelim();
      return x.layoutId !== "" && se.uint32(26).string(x.layoutId), x.requestMetadata !== void 0 && k.Value.encode(k.Value.wrap(x.requestMetadata), se.uint32(802).fork()).ldelim(), x.requestAnimationMode !== X.REQUEST_ANIMATION_MODE_UNSPECIFIED && se.uint32(808).int32(ae(x.requestAnimationMode)), se;
    },
    decode(x, se) {
      const Ee = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Ee.len : Ee.pos + se;
      const $e = Q();
      for (; Ee.pos < xe; ) {
        const Ye = Ee.uint32();
        switch (Ye >>> 3) {
          case 2:
            $e.layers.push(a.BatchLayerResponse_BatchLayerItem.decode(Ee, Ee.uint32()));
            break;
          case 3:
            $e.layoutId = Ee.string();
            break;
          case 100:
            $e.requestMetadata = k.Value.unwrap(k.Value.decode(Ee, Ee.uint32()));
            break;
          case 101:
            $e.requestAnimationMode = oe(Ee.int32());
            break;
          default:
            Ee.skipType(Ye & 7);
            break;
        }
      }
      return $e;
    },
    fromJSON(x) {
      return {
        layers: Array.isArray(x == null ? void 0 : x.layers) ? x.layers.map((se) => a.BatchLayerResponse_BatchLayerItem.fromJSON(se)) : [],
        layoutId: Ke(x.layoutId) ? String(x.layoutId) : "",
        requestMetadata: Ke(x == null ? void 0 : x.requestMetadata) ? x.requestMetadata : void 0,
        requestAnimationMode: Ke(x.requestAnimationMode) ? oe(x.requestAnimationMode) : X.REQUEST_ANIMATION_MODE_UNSPECIFIED
      };
    },
    toJSON(x) {
      const se = {};
      return x.layers ? se.layers = x.layers.map((Ee) => Ee ? a.BatchLayerResponse_BatchLayerItem.toJSON(Ee) : void 0) : se.layers = [], x.layoutId !== void 0 && (se.layoutId = x.layoutId), x.requestMetadata !== void 0 && (se.requestMetadata = x.requestMetadata), x.requestAnimationMode !== void 0 && (se.requestAnimationMode = Y(x.requestAnimationMode)), se;
    },
    fromPartial(x) {
      var se, Ee, xe, $e;
      const Ye = Q();
      return Ye.layers = ((se = x.layers) === null || se === void 0 ? void 0 : se.map((et) => a.BatchLayerResponse_BatchLayerItem.fromPartial(et))) || [], Ye.layoutId = (Ee = x.layoutId) !== null && Ee !== void 0 ? Ee : "", Ye.requestMetadata = (xe = x.requestMetadata) !== null && xe !== void 0 ? xe : void 0, Ye.requestAnimationMode = ($e = x.requestAnimationMode) !== null && $e !== void 0 ? $e : X.REQUEST_ANIMATION_MODE_UNSPECIFIED, Ye;
    }
  };
  function le() {
    return { create: void 0, update: void 0, delete: void 0 };
  }
  a.BatchLayerResponse_BatchLayerItem = {
    encode(x, se = _.Writer.create()) {
      return x.create !== void 0 && a.Layer.encode(x.create, se.uint32(10).fork()).ldelim(), x.update !== void 0 && a.Layer.encode(x.update, se.uint32(18).fork()).ldelim(), x.delete !== void 0 && a.DeleteLayerResponse.encode(x.delete, se.uint32(26).fork()).ldelim(), se;
    },
    decode(x, se) {
      const Ee = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Ee.len : Ee.pos + se;
      const $e = le();
      for (; Ee.pos < xe; ) {
        const Ye = Ee.uint32();
        switch (Ye >>> 3) {
          case 1:
            $e.create = a.Layer.decode(Ee, Ee.uint32());
            break;
          case 2:
            $e.update = a.Layer.decode(Ee, Ee.uint32());
            break;
          case 3:
            $e.delete = a.DeleteLayerResponse.decode(Ee, Ee.uint32());
            break;
          default:
            Ee.skipType(Ye & 7);
            break;
        }
      }
      return $e;
    },
    fromJSON(x) {
      return {
        create: Ke(x.create) ? a.Layer.fromJSON(x.create) : void 0,
        update: Ke(x.update) ? a.Layer.fromJSON(x.update) : void 0,
        delete: Ke(x.delete) ? a.DeleteLayerResponse.fromJSON(x.delete) : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.create !== void 0 && (se.create = x.create ? a.Layer.toJSON(x.create) : void 0), x.update !== void 0 && (se.update = x.update ? a.Layer.toJSON(x.update) : void 0), x.delete !== void 0 && (se.delete = x.delete ? a.DeleteLayerResponse.toJSON(x.delete) : void 0), se;
    },
    fromPartial(x) {
      const se = le();
      return se.create = x.create !== void 0 && x.create !== null ? a.Layer.fromPartial(x.create) : void 0, se.update = x.update !== void 0 && x.update !== null ? a.Layer.fromPartial(x.update) : void 0, se.delete = x.delete !== void 0 && x.delete !== null ? a.DeleteLayerResponse.fromPartial(x.delete) : void 0, se;
    }
  };
  function _e() {
    return {
      width: void 0,
      height: void 0,
      metadata: void 0,
      projectId: void 0,
      collectionId: void 0,
      type: void 0,
      transitions: [],
      requestMetadata: void 0
    };
  }
  a.PartialLayout = {
    encode(x, se = _.Writer.create()) {
      x.width !== void 0 && se.uint32(16).int32(x.width), x.height !== void 0 && se.uint32(24).int32(x.height), x.metadata !== void 0 && k.Value.encode(k.Value.wrap(x.metadata), se.uint32(50).fork()).ldelim(), x.projectId !== void 0 && se.uint32(58).string(x.projectId), x.collectionId !== void 0 && se.uint32(66).string(x.collectionId), x.type !== void 0 && se.uint32(72).int32(V(x.type));
      for (const Ee of x.transitions)
        a.Transition.encode(Ee, se.uint32(82).fork()).ldelim();
      return x.requestMetadata !== void 0 && k.Value.encode(k.Value.wrap(x.requestMetadata), se.uint32(810).fork()).ldelim(), se;
    },
    decode(x, se) {
      const Ee = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Ee.len : Ee.pos + se;
      const $e = _e();
      for (; Ee.pos < xe; ) {
        const Ye = Ee.uint32();
        switch (Ye >>> 3) {
          case 2:
            $e.width = Ee.int32();
            break;
          case 3:
            $e.height = Ee.int32();
            break;
          case 6:
            $e.metadata = k.Value.unwrap(k.Value.decode(Ee, Ee.uint32()));
            break;
          case 7:
            $e.projectId = Ee.string();
            break;
          case 8:
            $e.collectionId = Ee.string();
            break;
          case 9:
            $e.type = L(Ee.int32());
            break;
          case 10:
            $e.transitions.push(a.Transition.decode(Ee, Ee.uint32()));
            break;
          case 101:
            $e.requestMetadata = k.Value.unwrap(k.Value.decode(Ee, Ee.uint32()));
            break;
          default:
            Ee.skipType(Ye & 7);
            break;
        }
      }
      return $e;
    },
    fromJSON(x) {
      return {
        width: Ke(x.width) ? Number(x.width) : void 0,
        height: Ke(x.height) ? Number(x.height) : void 0,
        metadata: Ke(x == null ? void 0 : x.metadata) ? x.metadata : void 0,
        projectId: Ke(x.projectId) ? String(x.projectId) : void 0,
        collectionId: Ke(x.collectionId) ? String(x.collectionId) : void 0,
        type: Ke(x.type) ? L(x.type) : void 0,
        transitions: Array.isArray(x == null ? void 0 : x.transitions) ? x.transitions.map((se) => a.Transition.fromJSON(se)) : [],
        requestMetadata: Ke(x == null ? void 0 : x.requestMetadata) ? x.requestMetadata : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.width !== void 0 && (se.width = Math.round(x.width)), x.height !== void 0 && (se.height = Math.round(x.height)), x.metadata !== void 0 && (se.metadata = x.metadata), x.projectId !== void 0 && (se.projectId = x.projectId), x.collectionId !== void 0 && (se.collectionId = x.collectionId), x.type !== void 0 && (se.type = x.type !== void 0 ? F(x.type) : void 0), x.transitions ? se.transitions = x.transitions.map((Ee) => Ee ? a.Transition.toJSON(Ee) : void 0) : se.transitions = [], x.requestMetadata !== void 0 && (se.requestMetadata = x.requestMetadata), se;
    },
    fromPartial(x) {
      var se, Ee, xe, $e, Ye, et, dt, St;
      const tt = _e();
      return tt.width = (se = x.width) !== null && se !== void 0 ? se : void 0, tt.height = (Ee = x.height) !== null && Ee !== void 0 ? Ee : void 0, tt.metadata = (xe = x.metadata) !== null && xe !== void 0 ? xe : void 0, tt.projectId = ($e = x.projectId) !== null && $e !== void 0 ? $e : void 0, tt.collectionId = (Ye = x.collectionId) !== null && Ye !== void 0 ? Ye : void 0, tt.type = (et = x.type) !== null && et !== void 0 ? et : void 0, tt.transitions = ((dt = x.transitions) === null || dt === void 0 ? void 0 : dt.map((at) => a.Transition.fromPartial(at))) || [], tt.requestMetadata = (St = x.requestMetadata) !== null && St !== void 0 ? St : void 0, tt;
    }
  };
  function re() {
    return { projectId: void 0, collectionId: void 0, type: void 0 };
  }
  a.ListLayoutsRequest = {
    encode(x, se = _.Writer.create()) {
      return x.projectId !== void 0 && se.uint32(10).string(x.projectId), x.collectionId !== void 0 && se.uint32(18).string(x.collectionId), x.type !== void 0 && se.uint32(24).int32(V(x.type)), se;
    },
    decode(x, se) {
      const Ee = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Ee.len : Ee.pos + se;
      const $e = re();
      for (; Ee.pos < xe; ) {
        const Ye = Ee.uint32();
        switch (Ye >>> 3) {
          case 1:
            $e.projectId = Ee.string();
            break;
          case 2:
            $e.collectionId = Ee.string();
            break;
          case 3:
            $e.type = L(Ee.int32());
            break;
          default:
            Ee.skipType(Ye & 7);
            break;
        }
      }
      return $e;
    },
    fromJSON(x) {
      return {
        projectId: Ke(x.projectId) ? String(x.projectId) : void 0,
        collectionId: Ke(x.collectionId) ? String(x.collectionId) : void 0,
        type: Ke(x.type) ? L(x.type) : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.projectId !== void 0 && (se.projectId = x.projectId), x.collectionId !== void 0 && (se.collectionId = x.collectionId), x.type !== void 0 && (se.type = x.type !== void 0 ? F(x.type) : void 0), se;
    },
    fromPartial(x) {
      var se, Ee, xe;
      const $e = re();
      return $e.projectId = (se = x.projectId) !== null && se !== void 0 ? se : void 0, $e.collectionId = (Ee = x.collectionId) !== null && Ee !== void 0 ? Ee : void 0, $e.type = (xe = x.type) !== null && xe !== void 0 ? xe : void 0, $e;
    }
  };
  function O() {
    return { layouts: [] };
  }
  a.ListLayoutsResponse = {
    encode(x, se = _.Writer.create()) {
      for (const Ee of x.layouts)
        a.Layout.encode(Ee, se.uint32(10).fork()).ldelim();
      return se;
    },
    decode(x, se) {
      const Ee = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Ee.len : Ee.pos + se;
      const $e = O();
      for (; Ee.pos < xe; ) {
        const Ye = Ee.uint32();
        switch (Ye >>> 3) {
          case 1:
            $e.layouts.push(a.Layout.decode(Ee, Ee.uint32()));
            break;
          default:
            Ee.skipType(Ye & 7);
            break;
        }
      }
      return $e;
    },
    fromJSON(x) {
      return {
        layouts: Array.isArray(x == null ? void 0 : x.layouts) ? x.layouts.map((se) => a.Layout.fromJSON(se)) : []
      };
    },
    toJSON(x) {
      const se = {};
      return x.layouts ? se.layouts = x.layouts.map((Ee) => Ee ? a.Layout.toJSON(Ee) : void 0) : se.layouts = [], se;
    },
    fromPartial(x) {
      var se;
      const Ee = O();
      return Ee.layouts = ((se = x.layouts) === null || se === void 0 ? void 0 : se.map((xe) => a.Layout.fromPartial(xe))) || [], Ee;
    }
  };
  function j() {
    return { layout: void 0 };
  }
  a.CreateLayoutRequest = {
    encode(x, se = _.Writer.create()) {
      return x.layout !== void 0 && a.PartialLayout.encode(x.layout, se.uint32(18).fork()).ldelim(), se;
    },
    decode(x, se) {
      const Ee = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Ee.len : Ee.pos + se;
      const $e = j();
      for (; Ee.pos < xe; ) {
        const Ye = Ee.uint32();
        switch (Ye >>> 3) {
          case 2:
            $e.layout = a.PartialLayout.decode(Ee, Ee.uint32());
            break;
          default:
            Ee.skipType(Ye & 7);
            break;
        }
      }
      return $e;
    },
    fromJSON(x) {
      return {
        layout: Ke(x.layout) ? a.PartialLayout.fromJSON(x.layout) : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.layout !== void 0 && (se.layout = x.layout ? a.PartialLayout.toJSON(x.layout) : void 0), se;
    },
    fromPartial(x) {
      const se = j();
      return se.layout = x.layout !== void 0 && x.layout !== null ? a.PartialLayout.fromPartial(x.layout) : void 0, se;
    }
  };
  function ce() {
    return { layoutId: "" };
  }
  a.GetLayoutRequest = {
    encode(x, se = _.Writer.create()) {
      return x.layoutId !== "" && se.uint32(10).string(x.layoutId), se;
    },
    decode(x, se) {
      const Ee = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Ee.len : Ee.pos + se;
      const $e = ce();
      for (; Ee.pos < xe; ) {
        const Ye = Ee.uint32();
        switch (Ye >>> 3) {
          case 1:
            $e.layoutId = Ee.string();
            break;
          default:
            Ee.skipType(Ye & 7);
            break;
        }
      }
      return $e;
    },
    fromJSON(x) {
      return {
        layoutId: Ke(x.layoutId) ? String(x.layoutId) : ""
      };
    },
    toJSON(x) {
      const se = {};
      return x.layoutId !== void 0 && (se.layoutId = x.layoutId), se;
    },
    fromPartial(x) {
      var se;
      const Ee = ce();
      return Ee.layoutId = (se = x.layoutId) !== null && se !== void 0 ? se : "", Ee;
    }
  };
  function De() {
    return { layoutId: "", layout: void 0 };
  }
  a.UpdateLayoutRequest = {
    encode(x, se = _.Writer.create()) {
      return x.layoutId !== "" && se.uint32(10).string(x.layoutId), x.layout !== void 0 && a.PartialLayout.encode(x.layout, se.uint32(26).fork()).ldelim(), se;
    },
    decode(x, se) {
      const Ee = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Ee.len : Ee.pos + se;
      const $e = De();
      for (; Ee.pos < xe; ) {
        const Ye = Ee.uint32();
        switch (Ye >>> 3) {
          case 1:
            $e.layoutId = Ee.string();
            break;
          case 3:
            $e.layout = a.PartialLayout.decode(Ee, Ee.uint32());
            break;
          default:
            Ee.skipType(Ye & 7);
            break;
        }
      }
      return $e;
    },
    fromJSON(x) {
      return {
        layoutId: Ke(x.layoutId) ? String(x.layoutId) : "",
        layout: Ke(x.layout) ? a.PartialLayout.fromJSON(x.layout) : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.layoutId !== void 0 && (se.layoutId = x.layoutId), x.layout !== void 0 && (se.layout = x.layout ? a.PartialLayout.toJSON(x.layout) : void 0), se;
    },
    fromPartial(x) {
      var se;
      const Ee = De();
      return Ee.layoutId = (se = x.layoutId) !== null && se !== void 0 ? se : "", Ee.layout = x.layout !== void 0 && x.layout !== null ? a.PartialLayout.fromPartial(x.layout) : void 0, Ee;
    }
  };
  function Ne() {
    return { requestMetadata: void 0 };
  }
  a.DeleteLayoutPayload = {
    encode(x, se = _.Writer.create()) {
      return x.requestMetadata !== void 0 && k.Value.encode(k.Value.wrap(x.requestMetadata), se.uint32(802).fork()).ldelim(), se;
    },
    decode(x, se) {
      const Ee = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Ee.len : Ee.pos + se;
      const $e = Ne();
      for (; Ee.pos < xe; ) {
        const Ye = Ee.uint32();
        switch (Ye >>> 3) {
          case 100:
            $e.requestMetadata = k.Value.unwrap(k.Value.decode(Ee, Ee.uint32()));
            break;
          default:
            Ee.skipType(Ye & 7);
            break;
        }
      }
      return $e;
    },
    fromJSON(x) {
      return {
        requestMetadata: Ke(x == null ? void 0 : x.requestMetadata) ? x.requestMetadata : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.requestMetadata !== void 0 && (se.requestMetadata = x.requestMetadata), se;
    },
    fromPartial(x) {
      var se;
      const Ee = Ne();
      return Ee.requestMetadata = (se = x.requestMetadata) !== null && se !== void 0 ? se : void 0, Ee;
    }
  };
  function Fe() {
    return { layoutId: "", payload: void 0 };
  }
  a.DeleteLayoutRequest = {
    encode(x, se = _.Writer.create()) {
      return x.layoutId !== "" && se.uint32(10).string(x.layoutId), x.payload !== void 0 && a.DeleteLayoutPayload.encode(x.payload, se.uint32(18).fork()).ldelim(), se;
    },
    decode(x, se) {
      const Ee = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Ee.len : Ee.pos + se;
      const $e = Fe();
      for (; Ee.pos < xe; ) {
        const Ye = Ee.uint32();
        switch (Ye >>> 3) {
          case 1:
            $e.layoutId = Ee.string();
            break;
          case 2:
            $e.payload = a.DeleteLayoutPayload.decode(Ee, Ee.uint32());
            break;
          default:
            Ee.skipType(Ye & 7);
            break;
        }
      }
      return $e;
    },
    fromJSON(x) {
      return {
        layoutId: Ke(x.layoutId) ? String(x.layoutId) : "",
        payload: Ke(x.payload) ? a.DeleteLayoutPayload.fromJSON(x.payload) : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.layoutId !== void 0 && (se.layoutId = x.layoutId), x.payload !== void 0 && (se.payload = x.payload ? a.DeleteLayoutPayload.toJSON(x.payload) : void 0), se;
    },
    fromPartial(x) {
      var se;
      const Ee = Fe();
      return Ee.layoutId = (se = x.layoutId) !== null && se !== void 0 ? se : "", Ee.payload = x.payload !== void 0 && x.payload !== null ? a.DeleteLayoutPayload.fromPartial(x.payload) : void 0, Ee;
    }
  };
  function Ze() {
    return { id: "", requestMetadata: void 0 };
  }
  a.DeleteLayoutResponse = {
    encode(x, se = _.Writer.create()) {
      return x.id !== "" && se.uint32(18).string(x.id), x.requestMetadata !== void 0 && k.Value.encode(k.Value.wrap(x.requestMetadata), se.uint32(802).fork()).ldelim(), se;
    },
    decode(x, se) {
      const Ee = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Ee.len : Ee.pos + se;
      const $e = Ze();
      for (; Ee.pos < xe; ) {
        const Ye = Ee.uint32();
        switch (Ye >>> 3) {
          case 2:
            $e.id = Ee.string();
            break;
          case 100:
            $e.requestMetadata = k.Value.unwrap(k.Value.decode(Ee, Ee.uint32()));
            break;
          default:
            Ee.skipType(Ye & 7);
            break;
        }
      }
      return $e;
    },
    fromJSON(x) {
      return {
        id: Ke(x.id) ? String(x.id) : "",
        requestMetadata: Ke(x == null ? void 0 : x.requestMetadata) ? x.requestMetadata : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.id !== void 0 && (se.id = x.id), x.requestMetadata !== void 0 && (se.requestMetadata = x.requestMetadata), se;
    },
    fromPartial(x) {
      var se, Ee;
      const xe = Ze();
      return xe.id = (se = x.id) !== null && se !== void 0 ? se : "", xe.requestMetadata = (Ee = x.requestMetadata) !== null && Ee !== void 0 ? Ee : void 0, xe;
    }
  };
  function qe() {
    return {
      properties: [],
      durationMs: 0,
      delayMs: void 0,
      easingMode: void 0
    };
  }
  a.LayerAnimation = {
    encode(x, se = _.Writer.create()) {
      for (const Ee of x.properties)
        se.uint32(10).string(Ee);
      return x.durationMs !== 0 && se.uint32(16).int32(x.durationMs), x.delayMs !== void 0 && se.uint32(32).int32(x.delayMs), x.easingMode !== void 0 && se.uint32(42).string(x.easingMode), se;
    },
    decode(x, se) {
      const Ee = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Ee.len : Ee.pos + se;
      const $e = qe();
      for (; Ee.pos < xe; ) {
        const Ye = Ee.uint32();
        switch (Ye >>> 3) {
          case 1:
            $e.properties.push(Ee.string());
            break;
          case 2:
            $e.durationMs = Ee.int32();
            break;
          case 4:
            $e.delayMs = Ee.int32();
            break;
          case 5:
            $e.easingMode = Ee.string();
            break;
          default:
            Ee.skipType(Ye & 7);
            break;
        }
      }
      return $e;
    },
    fromJSON(x) {
      return {
        properties: Array.isArray(x == null ? void 0 : x.properties) ? x.properties.map((se) => String(se)) : [],
        durationMs: Ke(x.durationMs) ? Number(x.durationMs) : 0,
        delayMs: Ke(x.delayMs) ? Number(x.delayMs) : void 0,
        easingMode: Ke(x.easingMode) ? String(x.easingMode) : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.properties ? se.properties = x.properties.map((Ee) => Ee) : se.properties = [], x.durationMs !== void 0 && (se.durationMs = Math.round(x.durationMs)), x.delayMs !== void 0 && (se.delayMs = Math.round(x.delayMs)), x.easingMode !== void 0 && (se.easingMode = x.easingMode), se;
    },
    fromPartial(x) {
      var se, Ee, xe, $e;
      const Ye = qe();
      return Ye.properties = ((se = x.properties) === null || se === void 0 ? void 0 : se.map((et) => et)) || [], Ye.durationMs = (Ee = x.durationMs) !== null && Ee !== void 0 ? Ee : 0, Ye.delayMs = (xe = x.delayMs) !== null && xe !== void 0 ? xe : void 0, Ye.easingMode = ($e = x.easingMode) !== null && $e !== void 0 ? $e : void 0, Ye;
    }
  };
  function gt() {
    return {
      type: void 0,
      data: void 0,
      x: void 0,
      y: void 0,
      width: void 0,
      height: void 0,
      rotation: void 0,
      opacity: void 0,
      scale: void 0,
      hidden: void 0,
      children: void 0,
      parentId: void 0,
      metadata: void 0,
      requestMetadata: void 0,
      requestAnimation: []
    };
  }
  a.PartialLayer = {
    encode(x, se = _.Writer.create()) {
      x.type !== void 0 && se.uint32(10).string(x.type), x.data !== void 0 && k.Struct.encode(k.Struct.wrap(x.data), se.uint32(18).fork()).ldelim(), x.x !== void 0 && k.Value.encode(k.Value.wrap(x.x), se.uint32(26).fork()).ldelim(), x.y !== void 0 && k.Value.encode(k.Value.wrap(x.y), se.uint32(34).fork()).ldelim(), x.width !== void 0 && k.Value.encode(k.Value.wrap(x.width), se.uint32(42).fork()).ldelim(), x.height !== void 0 && k.Value.encode(k.Value.wrap(x.height), se.uint32(50).fork()).ldelim(), x.rotation !== void 0 && se.uint32(57).double(x.rotation), x.opacity !== void 0 && se.uint32(65).double(x.opacity), x.scale !== void 0 && se.uint32(73).double(x.scale), x.hidden !== void 0 && se.uint32(80).bool(x.hidden), x.children !== void 0 && k.ListValue.encode(k.ListValue.wrap(x.children), se.uint32(98).fork()).ldelim(), x.parentId !== void 0 && se.uint32(106).string(x.parentId), x.metadata !== void 0 && k.Value.encode(k.Value.wrap(x.metadata), se.uint32(114).fork()).ldelim(), x.requestMetadata !== void 0 && k.Value.encode(k.Value.wrap(x.requestMetadata), se.uint32(802).fork()).ldelim();
      for (const Ee of x.requestAnimation)
        a.LayerAnimation.encode(Ee, se.uint32(826).fork()).ldelim();
      return se;
    },
    decode(x, se) {
      const Ee = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Ee.len : Ee.pos + se;
      const $e = gt();
      for (; Ee.pos < xe; ) {
        const Ye = Ee.uint32();
        switch (Ye >>> 3) {
          case 1:
            $e.type = Ee.string();
            break;
          case 2:
            $e.data = k.Struct.unwrap(k.Struct.decode(Ee, Ee.uint32()));
            break;
          case 3:
            $e.x = k.Value.unwrap(k.Value.decode(Ee, Ee.uint32()));
            break;
          case 4:
            $e.y = k.Value.unwrap(k.Value.decode(Ee, Ee.uint32()));
            break;
          case 5:
            $e.width = k.Value.unwrap(k.Value.decode(Ee, Ee.uint32()));
            break;
          case 6:
            $e.height = k.Value.unwrap(k.Value.decode(Ee, Ee.uint32()));
            break;
          case 7:
            $e.rotation = Ee.double();
            break;
          case 8:
            $e.opacity = Ee.double();
            break;
          case 9:
            $e.scale = Ee.double();
            break;
          case 10:
            $e.hidden = Ee.bool();
            break;
          case 12:
            $e.children = k.ListValue.unwrap(k.ListValue.decode(Ee, Ee.uint32()));
            break;
          case 13:
            $e.parentId = Ee.string();
            break;
          case 14:
            $e.metadata = k.Value.unwrap(k.Value.decode(Ee, Ee.uint32()));
            break;
          case 100:
            $e.requestMetadata = k.Value.unwrap(k.Value.decode(Ee, Ee.uint32()));
            break;
          case 103:
            $e.requestAnimation.push(a.LayerAnimation.decode(Ee, Ee.uint32()));
            break;
          default:
            Ee.skipType(Ye & 7);
            break;
        }
      }
      return $e;
    },
    fromJSON(x) {
      return {
        type: Ke(x.type) ? String(x.type) : void 0,
        data: Qe(x.data) ? x.data : void 0,
        x: Ke(x == null ? void 0 : x.x) ? x.x : void 0,
        y: Ke(x == null ? void 0 : x.y) ? x.y : void 0,
        width: Ke(x == null ? void 0 : x.width) ? x.width : void 0,
        height: Ke(x == null ? void 0 : x.height) ? x.height : void 0,
        rotation: Ke(x.rotation) ? Number(x.rotation) : void 0,
        opacity: Ke(x.opacity) ? Number(x.opacity) : void 0,
        scale: Ke(x.scale) ? Number(x.scale) : void 0,
        hidden: Ke(x.hidden) ? !!x.hidden : void 0,
        children: Array.isArray(x.children) ? [...x.children] : void 0,
        parentId: Ke(x.parentId) ? String(x.parentId) : void 0,
        metadata: Ke(x == null ? void 0 : x.metadata) ? x.metadata : void 0,
        requestMetadata: Ke(x == null ? void 0 : x.requestMetadata) ? x.requestMetadata : void 0,
        requestAnimation: Array.isArray(x == null ? void 0 : x.requestAnimation) ? x.requestAnimation.map((se) => a.LayerAnimation.fromJSON(se)) : []
      };
    },
    toJSON(x) {
      const se = {};
      return x.type !== void 0 && (se.type = x.type), x.data !== void 0 && (se.data = x.data), x.x !== void 0 && (se.x = x.x), x.y !== void 0 && (se.y = x.y), x.width !== void 0 && (se.width = x.width), x.height !== void 0 && (se.height = x.height), x.rotation !== void 0 && (se.rotation = x.rotation), x.opacity !== void 0 && (se.opacity = x.opacity), x.scale !== void 0 && (se.scale = x.scale), x.hidden !== void 0 && (se.hidden = x.hidden), x.children !== void 0 && (se.children = x.children), x.parentId !== void 0 && (se.parentId = x.parentId), x.metadata !== void 0 && (se.metadata = x.metadata), x.requestMetadata !== void 0 && (se.requestMetadata = x.requestMetadata), x.requestAnimation ? se.requestAnimation = x.requestAnimation.map((Ee) => Ee ? a.LayerAnimation.toJSON(Ee) : void 0) : se.requestAnimation = [], se;
    },
    fromPartial(x) {
      var se, Ee, xe, $e, Ye, et, dt, St, tt, at, wt, rt, ut, kt, nt;
      const it = gt();
      return it.type = (se = x.type) !== null && se !== void 0 ? se : void 0, it.data = (Ee = x.data) !== null && Ee !== void 0 ? Ee : void 0, it.x = (xe = x.x) !== null && xe !== void 0 ? xe : void 0, it.y = ($e = x.y) !== null && $e !== void 0 ? $e : void 0, it.width = (Ye = x.width) !== null && Ye !== void 0 ? Ye : void 0, it.height = (et = x.height) !== null && et !== void 0 ? et : void 0, it.rotation = (dt = x.rotation) !== null && dt !== void 0 ? dt : void 0, it.opacity = (St = x.opacity) !== null && St !== void 0 ? St : void 0, it.scale = (tt = x.scale) !== null && tt !== void 0 ? tt : void 0, it.hidden = (at = x.hidden) !== null && at !== void 0 ? at : void 0, it.children = (wt = x.children) !== null && wt !== void 0 ? wt : void 0, it.parentId = (rt = x.parentId) !== null && rt !== void 0 ? rt : void 0, it.metadata = (ut = x.metadata) !== null && ut !== void 0 ? ut : void 0, it.requestMetadata = (kt = x.requestMetadata) !== null && kt !== void 0 ? kt : void 0, it.requestAnimation = ((nt = x.requestAnimation) === null || nt === void 0 ? void 0 : nt.map((bt) => a.LayerAnimation.fromPartial(bt))) || [], it;
    }
  };
  function Xe() {
    return {
      id: "",
      type: void 0,
      data: void 0,
      x: void 0,
      y: void 0,
      width: void 0,
      height: void 0,
      rotation: void 0,
      opacity: void 0,
      scale: void 0,
      hidden: void 0,
      children: void 0,
      parentId: void 0,
      metadata: void 0,
      requestMetadata: void 0,
      requestAnimation: []
    };
  }
  a.PartialLayerWithID = {
    encode(x, se = _.Writer.create()) {
      x.id !== "" && se.uint32(8002).string(x.id), x.type !== void 0 && se.uint32(10).string(x.type), x.data !== void 0 && k.Struct.encode(k.Struct.wrap(x.data), se.uint32(18).fork()).ldelim(), x.x !== void 0 && k.Value.encode(k.Value.wrap(x.x), se.uint32(26).fork()).ldelim(), x.y !== void 0 && k.Value.encode(k.Value.wrap(x.y), se.uint32(34).fork()).ldelim(), x.width !== void 0 && k.Value.encode(k.Value.wrap(x.width), se.uint32(42).fork()).ldelim(), x.height !== void 0 && k.Value.encode(k.Value.wrap(x.height), se.uint32(50).fork()).ldelim(), x.rotation !== void 0 && se.uint32(57).double(x.rotation), x.opacity !== void 0 && se.uint32(65).double(x.opacity), x.scale !== void 0 && se.uint32(73).double(x.scale), x.hidden !== void 0 && se.uint32(80).bool(x.hidden), x.children !== void 0 && k.ListValue.encode(k.ListValue.wrap(x.children), se.uint32(98).fork()).ldelim(), x.parentId !== void 0 && se.uint32(106).string(x.parentId), x.metadata !== void 0 && k.Value.encode(k.Value.wrap(x.metadata), se.uint32(114).fork()).ldelim(), x.requestMetadata !== void 0 && k.Value.encode(k.Value.wrap(x.requestMetadata), se.uint32(802).fork()).ldelim();
      for (const Ee of x.requestAnimation)
        a.LayerAnimation.encode(Ee, se.uint32(826).fork()).ldelim();
      return se;
    },
    decode(x, se) {
      const Ee = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Ee.len : Ee.pos + se;
      const $e = Xe();
      for (; Ee.pos < xe; ) {
        const Ye = Ee.uint32();
        switch (Ye >>> 3) {
          case 1e3:
            $e.id = Ee.string();
            break;
          case 1:
            $e.type = Ee.string();
            break;
          case 2:
            $e.data = k.Struct.unwrap(k.Struct.decode(Ee, Ee.uint32()));
            break;
          case 3:
            $e.x = k.Value.unwrap(k.Value.decode(Ee, Ee.uint32()));
            break;
          case 4:
            $e.y = k.Value.unwrap(k.Value.decode(Ee, Ee.uint32()));
            break;
          case 5:
            $e.width = k.Value.unwrap(k.Value.decode(Ee, Ee.uint32()));
            break;
          case 6:
            $e.height = k.Value.unwrap(k.Value.decode(Ee, Ee.uint32()));
            break;
          case 7:
            $e.rotation = Ee.double();
            break;
          case 8:
            $e.opacity = Ee.double();
            break;
          case 9:
            $e.scale = Ee.double();
            break;
          case 10:
            $e.hidden = Ee.bool();
            break;
          case 12:
            $e.children = k.ListValue.unwrap(k.ListValue.decode(Ee, Ee.uint32()));
            break;
          case 13:
            $e.parentId = Ee.string();
            break;
          case 14:
            $e.metadata = k.Value.unwrap(k.Value.decode(Ee, Ee.uint32()));
            break;
          case 100:
            $e.requestMetadata = k.Value.unwrap(k.Value.decode(Ee, Ee.uint32()));
            break;
          case 103:
            $e.requestAnimation.push(a.LayerAnimation.decode(Ee, Ee.uint32()));
            break;
          default:
            Ee.skipType(Ye & 7);
            break;
        }
      }
      return $e;
    },
    fromJSON(x) {
      return {
        id: Ke(x.id) ? String(x.id) : "",
        type: Ke(x.type) ? String(x.type) : void 0,
        data: Qe(x.data) ? x.data : void 0,
        x: Ke(x == null ? void 0 : x.x) ? x.x : void 0,
        y: Ke(x == null ? void 0 : x.y) ? x.y : void 0,
        width: Ke(x == null ? void 0 : x.width) ? x.width : void 0,
        height: Ke(x == null ? void 0 : x.height) ? x.height : void 0,
        rotation: Ke(x.rotation) ? Number(x.rotation) : void 0,
        opacity: Ke(x.opacity) ? Number(x.opacity) : void 0,
        scale: Ke(x.scale) ? Number(x.scale) : void 0,
        hidden: Ke(x.hidden) ? !!x.hidden : void 0,
        children: Array.isArray(x.children) ? [...x.children] : void 0,
        parentId: Ke(x.parentId) ? String(x.parentId) : void 0,
        metadata: Ke(x == null ? void 0 : x.metadata) ? x.metadata : void 0,
        requestMetadata: Ke(x == null ? void 0 : x.requestMetadata) ? x.requestMetadata : void 0,
        requestAnimation: Array.isArray(x == null ? void 0 : x.requestAnimation) ? x.requestAnimation.map((se) => a.LayerAnimation.fromJSON(se)) : []
      };
    },
    toJSON(x) {
      const se = {};
      return x.id !== void 0 && (se.id = x.id), x.type !== void 0 && (se.type = x.type), x.data !== void 0 && (se.data = x.data), x.x !== void 0 && (se.x = x.x), x.y !== void 0 && (se.y = x.y), x.width !== void 0 && (se.width = x.width), x.height !== void 0 && (se.height = x.height), x.rotation !== void 0 && (se.rotation = x.rotation), x.opacity !== void 0 && (se.opacity = x.opacity), x.scale !== void 0 && (se.scale = x.scale), x.hidden !== void 0 && (se.hidden = x.hidden), x.children !== void 0 && (se.children = x.children), x.parentId !== void 0 && (se.parentId = x.parentId), x.metadata !== void 0 && (se.metadata = x.metadata), x.requestMetadata !== void 0 && (se.requestMetadata = x.requestMetadata), x.requestAnimation ? se.requestAnimation = x.requestAnimation.map((Ee) => Ee ? a.LayerAnimation.toJSON(Ee) : void 0) : se.requestAnimation = [], se;
    },
    fromPartial(x) {
      var se, Ee, xe, $e, Ye, et, dt, St, tt, at, wt, rt, ut, kt, nt, it;
      const bt = Xe();
      return bt.id = (se = x.id) !== null && se !== void 0 ? se : "", bt.type = (Ee = x.type) !== null && Ee !== void 0 ? Ee : void 0, bt.data = (xe = x.data) !== null && xe !== void 0 ? xe : void 0, bt.x = ($e = x.x) !== null && $e !== void 0 ? $e : void 0, bt.y = (Ye = x.y) !== null && Ye !== void 0 ? Ye : void 0, bt.width = (et = x.width) !== null && et !== void 0 ? et : void 0, bt.height = (dt = x.height) !== null && dt !== void 0 ? dt : void 0, bt.rotation = (St = x.rotation) !== null && St !== void 0 ? St : void 0, bt.opacity = (tt = x.opacity) !== null && tt !== void 0 ? tt : void 0, bt.scale = (at = x.scale) !== null && at !== void 0 ? at : void 0, bt.hidden = (wt = x.hidden) !== null && wt !== void 0 ? wt : void 0, bt.children = (rt = x.children) !== null && rt !== void 0 ? rt : void 0, bt.parentId = (ut = x.parentId) !== null && ut !== void 0 ? ut : void 0, bt.metadata = (kt = x.metadata) !== null && kt !== void 0 ? kt : void 0, bt.requestMetadata = (nt = x.requestMetadata) !== null && nt !== void 0 ? nt : void 0, bt.requestAnimation = ((it = x.requestAnimation) === null || it === void 0 ? void 0 : it.map((ot) => a.LayerAnimation.fromPartial(ot))) || [], bt;
    }
  };
  function Ge() {
    return { layoutId: "" };
  }
  a.ListLayersRequest = {
    encode(x, se = _.Writer.create()) {
      return x.layoutId !== "" && se.uint32(10).string(x.layoutId), se;
    },
    decode(x, se) {
      const Ee = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Ee.len : Ee.pos + se;
      const $e = Ge();
      for (; Ee.pos < xe; ) {
        const Ye = Ee.uint32();
        switch (Ye >>> 3) {
          case 1:
            $e.layoutId = Ee.string();
            break;
          default:
            Ee.skipType(Ye & 7);
            break;
        }
      }
      return $e;
    },
    fromJSON(x) {
      return {
        layoutId: Ke(x.layoutId) ? String(x.layoutId) : ""
      };
    },
    toJSON(x) {
      const se = {};
      return x.layoutId !== void 0 && (se.layoutId = x.layoutId), se;
    },
    fromPartial(x) {
      var se;
      const Ee = Ge();
      return Ee.layoutId = (se = x.layoutId) !== null && se !== void 0 ? se : "", Ee;
    }
  };
  function J() {
    return { layers: [] };
  }
  a.ListLayersResponse = {
    encode(x, se = _.Writer.create()) {
      for (const Ee of x.layers)
        a.Layer.encode(Ee, se.uint32(10).fork()).ldelim();
      return se;
    },
    decode(x, se) {
      const Ee = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Ee.len : Ee.pos + se;
      const $e = J();
      for (; Ee.pos < xe; ) {
        const Ye = Ee.uint32();
        switch (Ye >>> 3) {
          case 1:
            $e.layers.push(a.Layer.decode(Ee, Ee.uint32()));
            break;
          default:
            Ee.skipType(Ye & 7);
            break;
        }
      }
      return $e;
    },
    fromJSON(x) {
      return {
        layers: Array.isArray(x == null ? void 0 : x.layers) ? x.layers.map((se) => a.Layer.fromJSON(se)) : []
      };
    },
    toJSON(x) {
      const se = {};
      return x.layers ? se.layers = x.layers.map((Ee) => Ee ? a.Layer.toJSON(Ee) : void 0) : se.layers = [], se;
    },
    fromPartial(x) {
      var se;
      const Ee = J();
      return Ee.layers = ((se = x.layers) === null || se === void 0 ? void 0 : se.map((xe) => a.Layer.fromPartial(xe))) || [], Ee;
    }
  };
  function ye() {
    return { layoutId: "", layer: void 0 };
  }
  a.CreateLayerRequest = {
    encode(x, se = _.Writer.create()) {
      return x.layoutId !== "" && se.uint32(10).string(x.layoutId), x.layer !== void 0 && a.PartialLayer.encode(x.layer, se.uint32(18).fork()).ldelim(), se;
    },
    decode(x, se) {
      const Ee = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Ee.len : Ee.pos + se;
      const $e = ye();
      for (; Ee.pos < xe; ) {
        const Ye = Ee.uint32();
        switch (Ye >>> 3) {
          case 1:
            $e.layoutId = Ee.string();
            break;
          case 2:
            $e.layer = a.PartialLayer.decode(Ee, Ee.uint32());
            break;
          default:
            Ee.skipType(Ye & 7);
            break;
        }
      }
      return $e;
    },
    fromJSON(x) {
      return {
        layoutId: Ke(x.layoutId) ? String(x.layoutId) : "",
        layer: Ke(x.layer) ? a.PartialLayer.fromJSON(x.layer) : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.layoutId !== void 0 && (se.layoutId = x.layoutId), x.layer !== void 0 && (se.layer = x.layer ? a.PartialLayer.toJSON(x.layer) : void 0), se;
    },
    fromPartial(x) {
      var se;
      const Ee = ye();
      return Ee.layoutId = (se = x.layoutId) !== null && se !== void 0 ? se : "", Ee.layer = x.layer !== void 0 && x.layer !== null ? a.PartialLayer.fromPartial(x.layer) : void 0, Ee;
    }
  };
  function we() {
    return { layoutId: "", layerId: "" };
  }
  a.GetLayerRequest = {
    encode(x, se = _.Writer.create()) {
      return x.layoutId !== "" && se.uint32(10).string(x.layoutId), x.layerId !== "" && se.uint32(18).string(x.layerId), se;
    },
    decode(x, se) {
      const Ee = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Ee.len : Ee.pos + se;
      const $e = we();
      for (; Ee.pos < xe; ) {
        const Ye = Ee.uint32();
        switch (Ye >>> 3) {
          case 1:
            $e.layoutId = Ee.string();
            break;
          case 2:
            $e.layerId = Ee.string();
            break;
          default:
            Ee.skipType(Ye & 7);
            break;
        }
      }
      return $e;
    },
    fromJSON(x) {
      return {
        layoutId: Ke(x.layoutId) ? String(x.layoutId) : "",
        layerId: Ke(x.layerId) ? String(x.layerId) : ""
      };
    },
    toJSON(x) {
      const se = {};
      return x.layoutId !== void 0 && (se.layoutId = x.layoutId), x.layerId !== void 0 && (se.layerId = x.layerId), se;
    },
    fromPartial(x) {
      var se, Ee;
      const xe = we();
      return xe.layoutId = (se = x.layoutId) !== null && se !== void 0 ? se : "", xe.layerId = (Ee = x.layerId) !== null && Ee !== void 0 ? Ee : "", xe;
    }
  };
  function We() {
    return { layoutId: "", layerId: "", layer: void 0 };
  }
  a.UpdateLayerRequest = {
    encode(x, se = _.Writer.create()) {
      return x.layoutId !== "" && se.uint32(10).string(x.layoutId), x.layerId !== "" && se.uint32(18).string(x.layerId), x.layer !== void 0 && a.PartialLayer.encode(x.layer, se.uint32(26).fork()).ldelim(), se;
    },
    decode(x, se) {
      const Ee = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Ee.len : Ee.pos + se;
      const $e = We();
      for (; Ee.pos < xe; ) {
        const Ye = Ee.uint32();
        switch (Ye >>> 3) {
          case 1:
            $e.layoutId = Ee.string();
            break;
          case 2:
            $e.layerId = Ee.string();
            break;
          case 3:
            $e.layer = a.PartialLayer.decode(Ee, Ee.uint32());
            break;
          default:
            Ee.skipType(Ye & 7);
            break;
        }
      }
      return $e;
    },
    fromJSON(x) {
      return {
        layoutId: Ke(x.layoutId) ? String(x.layoutId) : "",
        layerId: Ke(x.layerId) ? String(x.layerId) : "",
        layer: Ke(x.layer) ? a.PartialLayer.fromJSON(x.layer) : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.layoutId !== void 0 && (se.layoutId = x.layoutId), x.layerId !== void 0 && (se.layerId = x.layerId), x.layer !== void 0 && (se.layer = x.layer ? a.PartialLayer.toJSON(x.layer) : void 0), se;
    },
    fromPartial(x) {
      var se, Ee;
      const xe = We();
      return xe.layoutId = (se = x.layoutId) !== null && se !== void 0 ? se : "", xe.layerId = (Ee = x.layerId) !== null && Ee !== void 0 ? Ee : "", xe.layer = x.layer !== void 0 && x.layer !== null ? a.PartialLayer.fromPartial(x.layer) : void 0, xe;
    }
  };
  function Re() {
    return { requestMetadata: void 0 };
  }
  a.DeleteLayerPayload = {
    encode(x, se = _.Writer.create()) {
      return x.requestMetadata !== void 0 && k.Value.encode(k.Value.wrap(x.requestMetadata), se.uint32(802).fork()).ldelim(), se;
    },
    decode(x, se) {
      const Ee = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Ee.len : Ee.pos + se;
      const $e = Re();
      for (; Ee.pos < xe; ) {
        const Ye = Ee.uint32();
        switch (Ye >>> 3) {
          case 100:
            $e.requestMetadata = k.Value.unwrap(k.Value.decode(Ee, Ee.uint32()));
            break;
          default:
            Ee.skipType(Ye & 7);
            break;
        }
      }
      return $e;
    },
    fromJSON(x) {
      return {
        requestMetadata: Ke(x == null ? void 0 : x.requestMetadata) ? x.requestMetadata : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.requestMetadata !== void 0 && (se.requestMetadata = x.requestMetadata), se;
    },
    fromPartial(x) {
      var se;
      const Ee = Re();
      return Ee.requestMetadata = (se = x.requestMetadata) !== null && se !== void 0 ? se : void 0, Ee;
    }
  };
  function q() {
    return { id: "", requestMetadata: void 0 };
  }
  a.BatchDeleteLayerRequest = {
    encode(x, se = _.Writer.create()) {
      return x.id !== "" && se.uint32(10).string(x.id), x.requestMetadata !== void 0 && k.Value.encode(k.Value.wrap(x.requestMetadata), se.uint32(802).fork()).ldelim(), se;
    },
    decode(x, se) {
      const Ee = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Ee.len : Ee.pos + se;
      const $e = q();
      for (; Ee.pos < xe; ) {
        const Ye = Ee.uint32();
        switch (Ye >>> 3) {
          case 1:
            $e.id = Ee.string();
            break;
          case 100:
            $e.requestMetadata = k.Value.unwrap(k.Value.decode(Ee, Ee.uint32()));
            break;
          default:
            Ee.skipType(Ye & 7);
            break;
        }
      }
      return $e;
    },
    fromJSON(x) {
      return {
        id: Ke(x.id) ? String(x.id) : "",
        requestMetadata: Ke(x == null ? void 0 : x.requestMetadata) ? x.requestMetadata : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.id !== void 0 && (se.id = x.id), x.requestMetadata !== void 0 && (se.requestMetadata = x.requestMetadata), se;
    },
    fromPartial(x) {
      var se, Ee;
      const xe = q();
      return xe.id = (se = x.id) !== null && se !== void 0 ? se : "", xe.requestMetadata = (Ee = x.requestMetadata) !== null && Ee !== void 0 ? Ee : void 0, xe;
    }
  };
  function ke() {
    return {
      layoutId: "",
      layers: [],
      requestMetadata: void 0,
      requestAnimationMode: void 0
    };
  }
  a.BatchLayerRequest = {
    encode(x, se = _.Writer.create()) {
      x.layoutId !== "" && se.uint32(10).string(x.layoutId);
      for (const Ee of x.layers)
        a.BatchLayerRequest_BatchItem.encode(Ee, se.uint32(18).fork()).ldelim();
      return x.requestMetadata !== void 0 && k.Value.encode(k.Value.wrap(x.requestMetadata), se.uint32(802).fork()).ldelim(), x.requestAnimationMode !== void 0 && se.uint32(808).int32(ae(x.requestAnimationMode)), se;
    },
    decode(x, se) {
      const Ee = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Ee.len : Ee.pos + se;
      const $e = ke();
      for (; Ee.pos < xe; ) {
        const Ye = Ee.uint32();
        switch (Ye >>> 3) {
          case 1:
            $e.layoutId = Ee.string();
            break;
          case 2:
            $e.layers.push(a.BatchLayerRequest_BatchItem.decode(Ee, Ee.uint32()));
            break;
          case 100:
            $e.requestMetadata = k.Value.unwrap(k.Value.decode(Ee, Ee.uint32()));
            break;
          case 101:
            $e.requestAnimationMode = oe(Ee.int32());
            break;
          default:
            Ee.skipType(Ye & 7);
            break;
        }
      }
      return $e;
    },
    fromJSON(x) {
      return {
        layoutId: Ke(x.layoutId) ? String(x.layoutId) : "",
        layers: Array.isArray(x == null ? void 0 : x.layers) ? x.layers.map((se) => a.BatchLayerRequest_BatchItem.fromJSON(se)) : [],
        requestMetadata: Ke(x == null ? void 0 : x.requestMetadata) ? x.requestMetadata : void 0,
        requestAnimationMode: Ke(x.requestAnimationMode) ? oe(x.requestAnimationMode) : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.layoutId !== void 0 && (se.layoutId = x.layoutId), x.layers ? se.layers = x.layers.map((Ee) => Ee ? a.BatchLayerRequest_BatchItem.toJSON(Ee) : void 0) : se.layers = [], x.requestMetadata !== void 0 && (se.requestMetadata = x.requestMetadata), x.requestAnimationMode !== void 0 && (se.requestAnimationMode = x.requestAnimationMode !== void 0 ? Y(x.requestAnimationMode) : void 0), se;
    },
    fromPartial(x) {
      var se, Ee, xe, $e;
      const Ye = ke();
      return Ye.layoutId = (se = x.layoutId) !== null && se !== void 0 ? se : "", Ye.layers = ((Ee = x.layers) === null || Ee === void 0 ? void 0 : Ee.map((et) => a.BatchLayerRequest_BatchItem.fromPartial(et))) || [], Ye.requestMetadata = (xe = x.requestMetadata) !== null && xe !== void 0 ? xe : void 0, Ye.requestAnimationMode = ($e = x.requestAnimationMode) !== null && $e !== void 0 ? $e : void 0, Ye;
    }
  };
  function de() {
    return { create: void 0, update: void 0, delete: void 0 };
  }
  a.BatchLayerRequest_BatchItem = {
    encode(x, se = _.Writer.create()) {
      return x.create !== void 0 && a.PartialLayer.encode(x.create, se.uint32(10).fork()).ldelim(), x.update !== void 0 && a.PartialLayerWithID.encode(x.update, se.uint32(18).fork()).ldelim(), x.delete !== void 0 && a.BatchDeleteLayerRequest.encode(x.delete, se.uint32(26).fork()).ldelim(), se;
    },
    decode(x, se) {
      const Ee = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Ee.len : Ee.pos + se;
      const $e = de();
      for (; Ee.pos < xe; ) {
        const Ye = Ee.uint32();
        switch (Ye >>> 3) {
          case 1:
            $e.create = a.PartialLayer.decode(Ee, Ee.uint32());
            break;
          case 2:
            $e.update = a.PartialLayerWithID.decode(Ee, Ee.uint32());
            break;
          case 3:
            $e.delete = a.BatchDeleteLayerRequest.decode(Ee, Ee.uint32());
            break;
          default:
            Ee.skipType(Ye & 7);
            break;
        }
      }
      return $e;
    },
    fromJSON(x) {
      return {
        create: Ke(x.create) ? a.PartialLayer.fromJSON(x.create) : void 0,
        update: Ke(x.update) ? a.PartialLayerWithID.fromJSON(x.update) : void 0,
        delete: Ke(x.delete) ? a.BatchDeleteLayerRequest.fromJSON(x.delete) : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.create !== void 0 && (se.create = x.create ? a.PartialLayer.toJSON(x.create) : void 0), x.update !== void 0 && (se.update = x.update ? a.PartialLayerWithID.toJSON(x.update) : void 0), x.delete !== void 0 && (se.delete = x.delete ? a.BatchDeleteLayerRequest.toJSON(x.delete) : void 0), se;
    },
    fromPartial(x) {
      const se = de();
      return se.create = x.create !== void 0 && x.create !== null ? a.PartialLayer.fromPartial(x.create) : void 0, se.update = x.update !== void 0 && x.update !== null ? a.PartialLayerWithID.fromPartial(x.update) : void 0, se.delete = x.delete !== void 0 && x.delete !== null ? a.BatchDeleteLayerRequest.fromPartial(x.delete) : void 0, se;
    }
  };
  function ue() {
    return { create: void 0, update: void 0, delete: void 0 };
  }
  a.LayoutEvent = {
    encode(x, se = _.Writer.create()) {
      return x.create !== void 0 && a.Layout.encode(x.create, se.uint32(10).fork()).ldelim(), x.update !== void 0 && a.Layout.encode(x.update, se.uint32(18).fork()).ldelim(), x.delete !== void 0 && a.DeleteLayoutResponse.encode(x.delete, se.uint32(26).fork()).ldelim(), se;
    },
    decode(x, se) {
      const Ee = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Ee.len : Ee.pos + se;
      const $e = ue();
      for (; Ee.pos < xe; ) {
        const Ye = Ee.uint32();
        switch (Ye >>> 3) {
          case 1:
            $e.create = a.Layout.decode(Ee, Ee.uint32());
            break;
          case 2:
            $e.update = a.Layout.decode(Ee, Ee.uint32());
            break;
          case 3:
            $e.delete = a.DeleteLayoutResponse.decode(Ee, Ee.uint32());
            break;
          default:
            Ee.skipType(Ye & 7);
            break;
        }
      }
      return $e;
    },
    fromJSON(x) {
      return {
        create: Ke(x.create) ? a.Layout.fromJSON(x.create) : void 0,
        update: Ke(x.update) ? a.Layout.fromJSON(x.update) : void 0,
        delete: Ke(x.delete) ? a.DeleteLayoutResponse.fromJSON(x.delete) : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.create !== void 0 && (se.create = x.create ? a.Layout.toJSON(x.create) : void 0), x.update !== void 0 && (se.update = x.update ? a.Layout.toJSON(x.update) : void 0), x.delete !== void 0 && (se.delete = x.delete ? a.DeleteLayoutResponse.toJSON(x.delete) : void 0), se;
    },
    fromPartial(x) {
      const se = ue();
      return se.create = x.create !== void 0 && x.create !== null ? a.Layout.fromPartial(x.create) : void 0, se.update = x.update !== void 0 && x.update !== null ? a.Layout.fromPartial(x.update) : void 0, se.delete = x.delete !== void 0 && x.delete !== null ? a.DeleteLayoutResponse.fromPartial(x.delete) : void 0, se;
    }
  };
  function me() {
    return {
      create: void 0,
      update: void 0,
      delete: void 0,
      batch: void 0
    };
  }
  a.LayerEvent = {
    encode(x, se = _.Writer.create()) {
      return x.create !== void 0 && a.Layer.encode(x.create, se.uint32(10).fork()).ldelim(), x.update !== void 0 && a.Layer.encode(x.update, se.uint32(18).fork()).ldelim(), x.delete !== void 0 && a.DeleteLayerResponse.encode(x.delete, se.uint32(26).fork()).ldelim(), x.batch !== void 0 && a.BatchLayerResponse.encode(x.batch, se.uint32(34).fork()).ldelim(), se;
    },
    decode(x, se) {
      const Ee = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Ee.len : Ee.pos + se;
      const $e = me();
      for (; Ee.pos < xe; ) {
        const Ye = Ee.uint32();
        switch (Ye >>> 3) {
          case 1:
            $e.create = a.Layer.decode(Ee, Ee.uint32());
            break;
          case 2:
            $e.update = a.Layer.decode(Ee, Ee.uint32());
            break;
          case 3:
            $e.delete = a.DeleteLayerResponse.decode(Ee, Ee.uint32());
            break;
          case 4:
            $e.batch = a.BatchLayerResponse.decode(Ee, Ee.uint32());
            break;
          default:
            Ee.skipType(Ye & 7);
            break;
        }
      }
      return $e;
    },
    fromJSON(x) {
      return {
        create: Ke(x.create) ? a.Layer.fromJSON(x.create) : void 0,
        update: Ke(x.update) ? a.Layer.fromJSON(x.update) : void 0,
        delete: Ke(x.delete) ? a.DeleteLayerResponse.fromJSON(x.delete) : void 0,
        batch: Ke(x.batch) ? a.BatchLayerResponse.fromJSON(x.batch) : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.create !== void 0 && (se.create = x.create ? a.Layer.toJSON(x.create) : void 0), x.update !== void 0 && (se.update = x.update ? a.Layer.toJSON(x.update) : void 0), x.delete !== void 0 && (se.delete = x.delete ? a.DeleteLayerResponse.toJSON(x.delete) : void 0), x.batch !== void 0 && (se.batch = x.batch ? a.BatchLayerResponse.toJSON(x.batch) : void 0), se;
    },
    fromPartial(x) {
      const se = me();
      return se.create = x.create !== void 0 && x.create !== null ? a.Layer.fromPartial(x.create) : void 0, se.update = x.update !== void 0 && x.update !== null ? a.Layer.fromPartial(x.update) : void 0, se.delete = x.delete !== void 0 && x.delete !== null ? a.DeleteLayerResponse.fromPartial(x.delete) : void 0, se.batch = x.batch !== void 0 && x.batch !== null ? a.BatchLayerResponse.fromPartial(x.batch) : void 0, se;
    }
  };
  function Oe() {
    return { layout: void 0, layer: void 0 };
  }
  a.Event = {
    encode(x, se = _.Writer.create()) {
      return x.layout !== void 0 && a.LayoutEvent.encode(x.layout, se.uint32(10).fork()).ldelim(), x.layer !== void 0 && a.LayerEvent.encode(x.layer, se.uint32(18).fork()).ldelim(), se;
    },
    decode(x, se) {
      const Ee = x instanceof _.Reader ? x : new _.Reader(x);
      let xe = se === void 0 ? Ee.len : Ee.pos + se;
      const $e = Oe();
      for (; Ee.pos < xe; ) {
        const Ye = Ee.uint32();
        switch (Ye >>> 3) {
          case 1:
            $e.layout = a.LayoutEvent.decode(Ee, Ee.uint32());
            break;
          case 2:
            $e.layer = a.LayerEvent.decode(Ee, Ee.uint32());
            break;
          default:
            Ee.skipType(Ye & 7);
            break;
        }
      }
      return $e;
    },
    fromJSON(x) {
      return {
        layout: Ke(x.layout) ? a.LayoutEvent.fromJSON(x.layout) : void 0,
        layer: Ke(x.layer) ? a.LayerEvent.fromJSON(x.layer) : void 0
      };
    },
    toJSON(x) {
      const se = {};
      return x.layout !== void 0 && (se.layout = x.layout ? a.LayoutEvent.toJSON(x.layout) : void 0), x.layer !== void 0 && (se.layer = x.layer ? a.LayerEvent.toJSON(x.layer) : void 0), se;
    },
    fromPartial(x) {
      const se = Oe();
      return se.layout = x.layout !== void 0 && x.layout !== null ? a.LayoutEvent.fromPartial(x.layout) : void 0, se.layer = x.layer !== void 0 && x.layer !== null ? a.LayerEvent.fromPartial(x.layer) : void 0, se;
    }
  };
  class Ue {
    constructor(se) {
      this.rpc = se, this.ListLayers = this.ListLayers.bind(this), this.CreateLayer = this.CreateLayer.bind(this), this.GetLayer = this.GetLayer.bind(this), this.UpdateLayer = this.UpdateLayer.bind(this), this.DeleteLayer = this.DeleteLayer.bind(this), this.Batch = this.Batch.bind(this);
    }
    ListLayers(se) {
      const Ee = a.ListLayersRequest.encode(se).finish();
      return this.rpc.request("apis.layout.v2.LayerService", "ListLayers", Ee).then(($e) => a.ListLayersResponse.decode(new _.Reader($e)));
    }
    CreateLayer(se) {
      const Ee = a.CreateLayerRequest.encode(se).finish();
      return this.rpc.request("apis.layout.v2.LayerService", "CreateLayer", Ee).then(($e) => a.Layer.decode(new _.Reader($e)));
    }
    GetLayer(se) {
      const Ee = a.GetLayerRequest.encode(se).finish();
      return this.rpc.request("apis.layout.v2.LayerService", "GetLayer", Ee).then(($e) => a.Layer.decode(new _.Reader($e)));
    }
    UpdateLayer(se) {
      const Ee = a.UpdateLayerRequest.encode(se).finish();
      return this.rpc.request("apis.layout.v2.LayerService", "UpdateLayer", Ee).then(($e) => a.Layer.decode(new _.Reader($e)));
    }
    DeleteLayer(se) {
      const Ee = a.DeleteLayerRequest.encode(se).finish();
      return this.rpc.request("apis.layout.v2.LayerService", "DeleteLayer", Ee).then(($e) => a.DeleteLayerResponse.decode(new _.Reader($e)));
    }
    Batch(se) {
      const Ee = a.BatchLayerRequest.encode(se).finish();
      return this.rpc.request("apis.layout.v2.LayerService", "Batch", Ee).then(($e) => a.BatchLayerResponse.decode(new _.Reader($e)));
    }
  }
  a.LayerServiceClientImpl = Ue, a.LayerServiceDefinition = {
    name: "LayerService",
    fullName: "apis.layout.v2.LayerService",
    methods: {
      /** List all layers */
      listLayers: {
        name: "ListLayers",
        requestType: a.ListLayersRequest,
        requestStream: !1,
        responseType: a.ListLayersResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Create a layer
       * buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
       * buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE
       */
      createLayer: {
        name: "CreateLayer",
        requestType: a.CreateLayerRequest,
        requestStream: !1,
        responseType: a.Layer,
        responseStream: !1,
        options: {}
      },
      /**
       * Get a single layer
       * buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
       * buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE
       */
      getLayer: {
        name: "GetLayer",
        requestType: a.GetLayerRequest,
        requestStream: !1,
        responseType: a.Layer,
        responseStream: !1,
        options: {}
      },
      /**
       * Update a layer
       * buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
       * buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE
       */
      updateLayer: {
        name: "UpdateLayer",
        requestType: a.UpdateLayerRequest,
        requestStream: !1,
        responseType: a.Layer,
        responseStream: !1,
        options: {}
      },
      /** Delete a layer */
      deleteLayer: {
        name: "DeleteLayer",
        requestType: a.DeleteLayerRequest,
        requestStream: !1,
        responseType: a.DeleteLayerResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Batch update
       * buf:lint:ignore RPC_REQUEST_STANDARD_NAME
       * buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
       */
      batch: {
        name: "Batch",
        requestType: a.BatchLayerRequest,
        requestStream: !1,
        responseType: a.BatchLayerResponse,
        responseStream: !1,
        options: {}
      }
    }
  };
  class ze {
    constructor(se) {
      this.rpc = se, this.ListLayouts = this.ListLayouts.bind(this), this.CreateLayout = this.CreateLayout.bind(this), this.GetLayout = this.GetLayout.bind(this), this.UpdateLayout = this.UpdateLayout.bind(this), this.DeleteLayout = this.DeleteLayout.bind(this);
    }
    ListLayouts(se) {
      const Ee = a.ListLayoutsRequest.encode(se).finish();
      return this.rpc.request("apis.layout.v2.LayoutService", "ListLayouts", Ee).then(($e) => a.ListLayoutsResponse.decode(new _.Reader($e)));
    }
    CreateLayout(se) {
      const Ee = a.CreateLayoutRequest.encode(se).finish();
      return this.rpc.request("apis.layout.v2.LayoutService", "CreateLayout", Ee).then(($e) => a.Layout.decode(new _.Reader($e)));
    }
    GetLayout(se) {
      const Ee = a.GetLayoutRequest.encode(se).finish();
      return this.rpc.request("apis.layout.v2.LayoutService", "GetLayout", Ee).then(($e) => a.Layout.decode(new _.Reader($e)));
    }
    UpdateLayout(se) {
      const Ee = a.UpdateLayoutRequest.encode(se).finish();
      return this.rpc.request("apis.layout.v2.LayoutService", "UpdateLayout", Ee).then(($e) => a.Layout.decode(new _.Reader($e)));
    }
    DeleteLayout(se) {
      const Ee = a.DeleteLayoutRequest.encode(se).finish();
      return this.rpc.request("apis.layout.v2.LayoutService", "DeleteLayout", Ee).then(($e) => a.DeleteLayoutResponse.decode(new _.Reader($e)));
    }
  }
  a.LayoutServiceClientImpl = ze, a.LayoutServiceDefinition = {
    name: "LayoutService",
    fullName: "apis.layout.v2.LayoutService",
    methods: {
      /** Get all layouts owned by the user. */
      listLayouts: {
        name: "ListLayouts",
        requestType: a.ListLayoutsRequest,
        requestStream: !1,
        responseType: a.ListLayoutsResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Create a new layout
       * buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
       * buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE
       */
      createLayout: {
        name: "CreateLayout",
        requestType: a.CreateLayoutRequest,
        requestStream: !1,
        responseType: a.Layout,
        responseStream: !1,
        options: {}
      },
      /**
       * Get a layout
       * buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
       * buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE
       */
      getLayout: {
        name: "GetLayout",
        requestType: a.GetLayoutRequest,
        requestStream: !1,
        responseType: a.Layout,
        responseStream: !1,
        options: {}
      },
      /**
       * Update a layout
       * buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
       * buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE
       */
      updateLayout: {
        name: "UpdateLayout",
        requestType: a.UpdateLayoutRequest,
        requestStream: !1,
        responseType: a.Layout,
        responseStream: !1,
        options: {}
      },
      /** Delete a layout */
      deleteLayout: {
        name: "DeleteLayout",
        requestType: a.DeleteLayoutRequest,
        requestStream: !1,
        responseType: a.DeleteLayoutResponse,
        responseStream: !1,
        options: {}
      }
    }
  };
  var Ve = (() => {
    if (typeof Ve < "u")
      return Ve;
    if (typeof self < "u")
      return self;
    if (typeof window < "u")
      return window;
    if (typeof commonjsGlobal$1 < "u")
      return commonjsGlobal$1;
    throw "Unable to locate global object";
  })();
  _.util.Long !== p.default && (_.util.Long = p.default, _.configure());
  function Qe(x) {
    return typeof x == "object" && x !== null;
  }
  function Ke(x) {
    return x != null;
  }
})(api$4);
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(v, p, _, k) {
    k === void 0 && (k = _), Object.defineProperty(v, k, { enumerable: !0, get: function() {
      return p[_];
    } });
  } : function(v, p, _, k) {
    k === void 0 && (k = _), v[k] = p[_];
  }), c = commonjsGlobal$1 && commonjsGlobal$1.__exportStar || function(v, p) {
    for (var _ in v)
      _ !== "default" && !p.hasOwnProperty(_) && u(p, v, _);
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.layoutApiEventMap = void 0;
  const l = api$4;
  c(api$4, a), a.layoutApiEventMap = {
    [l.EventType.EVENT_TYPE_LAYOUT]: "layout",
    [l.EventType.EVENT_TYPE_LAYER]: "layer",
    [l.EventType.EVENT_TYPE_UNSPECIFIED]: "unspecified"
  };
})(dist$2);
var api$3 = {}, logger = {};
class EnhancedMap extends Map {
  /**
   * If key has a mapping already returns the currently associated value. If
   * there is no mapping, calls the computer which must return a value V.
   * The value is then stored for given key and returned.
   * @param key Key
   * @param computer Computer which is called only if key has no mapping yet.
   * @return Existing value if the key already existed, or the newly computed value.
   */
  computeIfAbsent(u, c) {
    if (this.has(u))
      return this.get(u);
    const l = c(u);
    return this.set(u, l), l;
  }
  /**
   * If the key exists already calls given computer, if the key does not exist
   * this method does nothing.
   *
   * The computer is called with current key and current value associated. The
   * computer can return a (new) value V or undefined. When undefined is returned
   * the key is removed from this map, when a V is returned the key is updated
   * with the new value V.
   * @param key Key
   * @param computer Computer which is called only if the key has a mapping already
   * @return Undefined if the key has no mapping, otherwise the value returned from computer
   */
  computeIfPresent(u, c) {
    const l = this.get(u);
    if (l === void 0)
      return;
    const v = c(u, l);
    return v !== void 0 ? this.set(u, v) : this.delete(u), v;
  }
  /**
   * Computes a value for given key, the computer can return a value V (in which case the map
   * will set the value for given key), if it returns undefined the mapping for key K will be
   * removed.
   * @param key Key to compute
   * @param computer Computer which is called, note that the currentValue argument contains the existing
   *                 value or is undefined when no mapping exists for the key.
   * @return The newly computed value
   */
  compute(u, c) {
    const l = this.get(u), v = c(u, l);
    return v ? this.set(u, v) : this.delete(u), v;
  }
}
var InternalLogLevel;
(function(a) {
  a[a.Trace = 0] = "Trace", a[a.Debug = 1] = "Debug", a[a.Info = 2] = "Info", a[a.Warn = 3] = "Warn", a[a.Error = 4] = "Error";
})(InternalLogLevel || (InternalLogLevel = {}));
function getInternalLogger(a) {
  return provider.getLogger(a);
}
const INTERNAL_LOGGING_SETTINGS = {
  /**
   * Changes the log level for the internal logging (for all new and existing loggers)
   * @param level New log level
   */
  setInternalLogLevel: (a) => provider.changeLogLevel(a),
  /**
   * Changes where messages are written to for all new and existing loggers),
   * by default they are written to the console.
   * @param fnOutput Function to write messages to
   */
  setOutput: (a) => provider.changeOutput(a),
  /**
   * Resets the log level and output back to defaults (level to error and writing to console)
   * for all new and existing loggers.
   */
  reset: () => provider.reset()
};
class InternalLoggerImpl {
  constructor(u, c, l) {
    this._name = u, this._level = c, this._fnOutput = l;
  }
  trace(u) {
    this.log(InternalLogLevel.Trace, u);
  }
  debug(u) {
    this.log(InternalLogLevel.Debug, u);
  }
  error(u, c) {
    this.log(InternalLogLevel.Error, u, c);
  }
  info(u) {
    this.log(InternalLogLevel.Info, u);
  }
  warn(u, c) {
    this.log(InternalLogLevel.Warn, u, c);
  }
  setLevel(u) {
    this._level = u;
  }
  setOutput(u) {
    this._fnOutput = u;
  }
  log(u, c, l) {
    this._level > u || this._fnOutput(`${InternalLogLevel[this._level].toString()} <INTERNAL LOGGER> ${this._name} ${c()}${l ? `
` + l.stack : ""}`);
  }
}
class InternalProviderImpl {
  constructor() {
    this._loggers = new EnhancedMap(), this._logLevel = InternalLogLevel.Error, this._fnOutput = InternalProviderImpl.logConsole;
  }
  getLogger(u) {
    return this._loggers.computeIfAbsent(u, (c) => new InternalLoggerImpl(c, this._logLevel, this._fnOutput));
  }
  changeLogLevel(u) {
    this._logLevel = u, this._loggers.forEach((c) => c.setLevel(u));
  }
  changeOutput(u) {
    this._fnOutput = u, this._loggers.forEach((c) => c.setOutput(this._fnOutput));
  }
  reset() {
    this.changeLogLevel(InternalLogLevel.Error), this._fnOutput = InternalProviderImpl.logConsole, this._loggers.forEach((u) => u.setOutput(this._fnOutput));
  }
  static logConsole(u) {
    console && console.log && console.log(u);
  }
}
const provider = new InternalProviderImpl();
var InternalLogger = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  get InternalLogLevel() {
    return InternalLogLevel;
  },
  getInternalLogger,
  INTERNAL_LOGGING_SETTINGS
}), LogLevel$1;
(function(a) {
  a[a.Trace = 0] = "Trace", a[a.Debug = 1] = "Debug", a[a.Info = 2] = "Info", a[a.Warn = 3] = "Warn", a[a.Error = 4] = "Error", a[a.Fatal = 5] = "Fatal";
})(LogLevel$1 || (LogLevel$1 = {}));
(function(a) {
  function u(c) {
    switch (c.toLowerCase()) {
      case "trace":
        return a.Trace;
      case "debug":
        return a.Debug;
      case "info":
        return a.Info;
      case "warn":
        return a.Warn;
      case "error":
        return a.Error;
      case "fatal":
        return a.Fatal;
      default:
        return;
    }
  }
  a.toLogLevel = u;
})(LogLevel$1 || (LogLevel$1 = {}));
class CoreLoggerImpl {
  constructor(u) {
    this._runtime = u;
  }
  get id() {
    return this._runtime.id;
  }
  get logLevel() {
    return this._runtime.level;
  }
  get runtimeSettings() {
    return Object.assign({}, this._runtime);
  }
  set runtimeSettings(u) {
    this._runtime = u;
  }
  trace(u, ...c) {
    this.logMessage(LogLevel$1.Trace, u, c);
  }
  debug(u, ...c) {
    this.logMessage(LogLevel$1.Debug, u, c);
  }
  info(u, ...c) {
    this.logMessage(LogLevel$1.Info, u, c);
  }
  warn(u, ...c) {
    this.logMessage(LogLevel$1.Warn, u, c);
  }
  error(u, ...c) {
    this.logMessage(LogLevel$1.Error, u, c);
  }
  fatal(u, ...c) {
    this.logMessage(LogLevel$1.Fatal, u, c);
  }
  logMessage(u, c, l) {
    if (this._runtime.level > u)
      return;
    const v = Date.now(), p = typeof c == "string" ? c : c(), _ = CoreLoggerImpl.getErrorAndArgs(l);
    switch (this._runtime.channel.type) {
      case "RawLogChannel":
        this._runtime.channel.write({
          message: p,
          exception: _.error,
          args: _.args,
          timeInMillis: v,
          level: u,
          logNames: this._runtime.name
        }, this._runtime.argumentFormatter);
        return;
      case "LogChannel":
        this._runtime.channel.write(this.createLogMessage(p, u, _, v));
        break;
    }
  }
  formatArgValue(u) {
    try {
      return this._runtime.argumentFormatter(u);
    } catch {
      return `>>ARG CONVERT FAILED: '${u !== void 0 ? u.toString() : "undefined"}'<<`;
    }
  }
  createLogMessage(u, c, l, v) {
    let p;
    const _ = l.error, k = l.args;
    _ && (p = `${_.name}: ${_.message}`, _.stack && (p += `@
${_.stack}`));
    const M = this._runtime.dateFormatter(v);
    let L = LogLevel$1[c].toUpperCase();
    L.length < 5 && (L += " ");
    const F = typeof this._runtime.name == "string" ? this._runtime.name : this._runtime.name.join(", "), V = typeof k < "u" && k.length > 0 ? " [" + k.map((oe) => this.formatArgValue(oe)).join(", ") + "]" : "";
    return {
      message: M + " " + L + " [" + F + "] " + u + V,
      error: p
    };
  }
  static getErrorAndArgs(u) {
    if (u.length === 0)
      return {};
    let c, l;
    const v = u[0];
    if (v instanceof Error)
      return c = v, l = u.length > 1 ? u.slice(1) : void 0, { error: c, args: l };
    if (typeof v == "function") {
      const p = v();
      return p instanceof Error ? (c = p, l = u.length > 1 ? u.slice(1) : void 0, { error: c, args: l }) : u.length === 1 ? Array.isArray(p) ? { args: p.length > 0 ? p : void 0 } : { args: p } : Array.isArray(p) ? { args: [...p, ...u.slice(1)] } : { args: [p, ...u.slice(1)] };
    }
    return { args: u };
  }
}
function padStart(a, u, c = " ") {
  return padInternal(a, u, "start", c);
}
function padEnd(a, u, c = " ") {
  return padInternal(a, u, "end", c);
}
function maxLengthStringValueInArray(a) {
  return a.map((u) => u.length).reduce((u, c) => c > u ? c : u, 0);
}
function padInternal(a, u, c, l = " ") {
  if (u <= a.length)
    return a;
  if (l.length > 1)
    throw new Error(`Fill char must be one char exactly, it is: ${l.length}`);
  const v = u - a.length;
  let p = "";
  for (let _ = 0; _ < v; _++)
    p += l;
  return c === "start" ? p + a : a + p;
}
function formatArgument(a) {
  return a === void 0 ? "undefined" : JSON.stringify(a);
}
function formatDate(a) {
  const u = new Date(a), c = u.getFullYear(), l = padStart((u.getMonth() + 1).toString(), 2, "0"), v = padStart(u.getDate().toString(), 2, "0"), p = padStart(u.getHours().toString(), 2, "0"), _ = padStart(u.getMinutes().toString(), 2, "0"), k = padStart(u.getSeconds().toString(), 2, "0"), M = padStart(u.getMilliseconds().toString(), 2, "0");
  return `${c}-${l}-${v} ${p}:${_}:${k},${M}`;
}
class ConsoleLogChannel {
  constructor() {
    this.type = "LogChannel";
  }
  write(u) {
    console && console.log && console.log(u.message + (u.error ? `
${u.error}` : ""));
  }
}
var DefaultChannels;
(function(a) {
  function u() {
    return new ConsoleLogChannel();
  }
  a.createConsoleChannel = u;
})(DefaultChannels || (DefaultChannels = {}));
class LogProviderImpl {
  constructor(u, c) {
    this._log = getInternalLogger("core.impl.LogProviderImpl"), this._name = u, this._settings = c, this._loggers = new EnhancedMap(), this._idToKeyMap = new EnhancedMap(), this._globalRuntimeSettings = { level: c.level, channel: c.channel }, this._nextLoggerId = 1, this._log.trace(() => `Created LogProviderImpl with settings: ${JSON.stringify(this._settings)}`);
  }
  get runtimeSettings() {
    return Object.assign(Object.assign({}, this._settings), { level: this._globalRuntimeSettings.level, channel: this._globalRuntimeSettings.channel });
  }
  getLogger(u) {
    return this.getOrCreateLogger(u);
  }
  updateLoggerRuntime(u, c) {
    this._log.debug(() => `Updating logger ${u.id} runtime settings using: '${JSON.stringify(c)}'`);
    const l = this._idToKeyMap.get(u.id);
    return l === void 0 ? (this._log.warn(() => `Cannot update logger with id: ${u.id}, it was not found.`), !1) : (this._loggers.computeIfPresent(l, (v, p) => (p.runtimeSettings = LogProviderImpl.mergeRuntimeSettingsIntoLogRuntime(p.runtimeSettings, c), p)), !0);
  }
  updateRuntimeSettings(u) {
    this._log.debug(() => `Updating global runtime settings and updating existing loggers runtime settings using: '${JSON.stringify(u)}'`), this._globalRuntimeSettings = {
      /* It's unclear, but not checking explicitly on undefined here makes the test fail, it makes no sense as level is a number | undefined essentially. */
      level: u.level !== void 0 ? u.level : this._globalRuntimeSettings.level,
      channel: u.channel !== void 0 ? u.channel : this._globalRuntimeSettings.channel
    }, this._loggers.forEach((c) => c.runtimeSettings = LogProviderImpl.mergeRuntimeSettingsIntoLogRuntime(c.runtimeSettings, u));
  }
  /**
   * Removes all state and loggers, it reverts back to as it was after initial construction.
   */
  clear() {
    this._loggers.clear(), this._idToKeyMap.clear(), this._globalRuntimeSettings = Object.assign({}, this._settings), this._nextLoggerId = 1;
  }
  getOrCreateLogger(u) {
    const c = LogProviderImpl.createKey(u), l = this._loggers.computeIfAbsent(c, () => {
      const v = {
        level: this._globalRuntimeSettings.level,
        channel: this._globalRuntimeSettings.channel,
        id: this.nextLoggerId(),
        name: u,
        argumentFormatter: this._settings.argumentFormatter,
        dateFormatter: this._settings.dateFormatter
      };
      return new CoreLoggerImpl(v);
    });
    return this._idToKeyMap.computeIfAbsent(l.id, () => c), l;
  }
  nextLoggerId() {
    const u = this._name + "_" + this._nextLoggerId;
    return this._nextLoggerId++, u;
  }
  static mergeRuntimeSettingsIntoLogRuntime(u, c) {
    return Object.assign(Object.assign({}, u), {
      /* It's unclear, but not checking explicitly on undefined here makes the test fail, it makes no sense as level is a number | undefined essentially. */
      level: c.level !== void 0 ? c.level : u.level,
      channel: c.channel !== void 0 ? c.channel : u.channel
    });
  }
  static createKey(u) {
    return typeof u == "string" ? u : u.join(",");
  }
}
function createLogProvider(a, u) {
  return new LogProviderImpl(a, u);
}
var index$3 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  EnhancedMap,
  padStart,
  padEnd,
  maxLengthStringValueInArray
});
class CategoryImpl {
  constructor(u, c, l, v) {
    this._children = [], this._logger = u, this._name = c, this._parent = l, this._fnGetOrCreateChildCategory = v;
  }
  get name() {
    return this._name;
  }
  get parent() {
    return this._parent;
  }
  get path() {
    const u = [];
    let c = this;
    for (; c !== void 0; )
      u.push(c.name), c = c.parent;
    return u.reverse();
  }
  get children() {
    return [...this._children];
  }
  addChild(u) {
    if (u.parent !== this)
      throw new Error(`Cannot add child '${u.name}', expected parent '${this._name} but got ${u.parent ? u.parent.name : "undefined"}'`);
    this._children.push(u);
  }
  getChildCategory(u) {
    const c = this._children.find((l) => l.name === u);
    return c !== void 0 ? c : this._fnGetOrCreateChildCategory(u, this);
  }
  get id() {
    return this._logger.id;
  }
  get logLevel() {
    return this._logger.logLevel;
  }
  get runtimeSettings() {
    return this._logger.runtimeSettings;
  }
  get logger() {
    return this._logger;
  }
  trace(u, ...c) {
    this._logger.trace(u, ...c);
  }
  debug(u, ...c) {
    this._logger.debug(u, ...c);
  }
  info(u, ...c) {
    this._logger.info(u, ...c);
  }
  warn(u, ...c) {
    this._logger.warn(u, ...c);
  }
  error(u, ...c) {
    this._logger.error(u, ...c);
  }
  fatal(u, ...c) {
    this._logger.fatal(u, ...c);
  }
}
const CATEGORY_PATH_SEPARATOR = "#";
class CategoryProviderImpl {
  constructor(u, c) {
    this._name = u, this._initialConfig = c, this._categoryStorage = new CategoryStorage(u, c);
  }
  get name() {
    return this._name;
  }
  get config() {
    return this._initialConfig;
  }
  get runtimeConfig() {
    return this._categoryStorage.getCurrentRuntimeConfig();
  }
  getCategory(u, c) {
    return this._categoryStorage.getOrCreateCategory(u, c);
  }
  updateRuntimeSettingsCategory(u, c) {
    this._categoryStorage.updateRuntimeSettingsCategory(u, c);
  }
  updateRuntimeSettings(u) {
    this._categoryStorage.updateRuntimeSettings(u);
  }
  /** Returns all currently registered categories */
  getRegisteredCategories() {
    return this._categoryStorage.getRegisteredCategories();
  }
  /** Get a category by path, note that paths must be separated by #, e.g. root#child1#child1_1 */
  getCategoryByPath(u) {
    return this._categoryStorage.getCategoryByPath(u);
  }
}
class CategoryStorage {
  constructor(u, c) {
    this._categoriesById = /* @__PURE__ */ new Map(), this._categoriesByPath = /* @__PURE__ */ new Map(), this._categoryProviderName = u, this._allowSameCategoryName = c.allowSameCategoryName, this._logProvider = createLogProvider(u, Object.assign({}, c)), this.getOrCreateCategory = this.getOrCreateCategory.bind(this);
  }
  getOrCreateCategory(u, c) {
    if (u.indexOf(CATEGORY_PATH_SEPARATOR) !== -1)
      throw new Error(`Cannot create category '${u}', name cannot contain a '${CATEGORY_PATH_SEPARATOR}'.`);
    const l = c !== void 0 ? this.getParentCategory(c) : void 0;
    return l === void 0 ? this.getOrCreateRootCategory(u) : this.getOrCreateChildCategory(u, l);
  }
  updateRuntimeSettingsCategory(u, c) {
    if (!u.id.startsWith(this._categoryProviderName))
      throw new Error(`Category '${u.name}' with LogId '${u.id}' is from a different CategoryProvider, cannot mix categories between providers.`);
    const l = this._categoriesById.get(u.id);
    l !== void 0 && (this._logProvider.updateLoggerRuntime(l.logger, { level: c.level }), !(c.disableRecursion !== void 0 && c.disableRecursion) && l.children.forEach((v) => this.updateRuntimeSettingsCategory(v, c)));
  }
  updateRuntimeSettings(u) {
    this._logProvider.updateRuntimeSettings(u);
  }
  getCurrentRuntimeConfig() {
    return Object.assign(Object.assign({}, this._logProvider.runtimeSettings), { allowSameCategoryName: this._allowSameCategoryName });
  }
  /** Returns all currently registered categories */
  getRegisteredCategories() {
    return [...this._categoriesById.values()];
  }
  /** Get a category by path, note that paths must be separated by #, e.g. root#child1#child1_1 */
  getCategoryByPath(u) {
    return this._categoriesByPath.get(u);
  }
  getParentCategory(u) {
    let c;
    if (CategoryStorage.isLogId(u)) {
      if (c = this._categoriesById.get(u), c === void 0)
        throw new Error(`Parent category was not found by LogId '${u}'. Are you sure you passed in the correct argument?`);
    } else if (c = this._categoriesById.get(u.id), c === void 0)
      throw new Error(`Parent category '${u.name}' was not found by it's LogId '${u.id}'. Are you sure you passed in the correct parent category?`);
    return c;
  }
  getOrCreateRootCategory(u) {
    const c = this._categoriesByPath.get(u);
    if (c) {
      if (!this._allowSameCategoryName)
        throw new Error(`Category '${u} already exists, config flag allowSameCategoryName=false - therefore matching version 1 behavior (hence this Error)`);
      return c;
    }
    const l = this._logProvider.getLogger(u), v = new CategoryImpl(l, u, void 0, this.getOrCreateCategory);
    return this._categoriesById.set(v.id, v), this._categoriesByPath.set(u, v), v;
  }
  getOrCreateChildCategory(u, c) {
    if (!c.id.startsWith(this._categoryProviderName))
      throw new Error(`Parent category '${c.name}' with LogId '${c.id}' is from a different CategoryProvider, cannot mix categories between providers.`);
    const l = [...c.path, u].join(CATEGORY_PATH_SEPARATOR), v = this._categoriesByPath.get(l);
    if (v) {
      if (!this._allowSameCategoryName)
        throw new Error(`Child category '${u} already exists for parent category ${c.name}, config flag allowSameCategoryName=false - therefore matching version 1 behavior (hence this Error)`);
      return v;
    }
    const p = this._logProvider.getLogger(l);
    this._logProvider.updateLoggerRuntime(p, {
      level: c.logger.runtimeSettings.level,
      channel: c.logger.runtimeSettings.channel
    });
    const _ = new CategoryImpl(p, u, c, this.getOrCreateCategory);
    return this._categoriesById.set(_.id, _), this._categoriesByPath.set(_.path.join(CATEGORY_PATH_SEPARATOR), _), c.addChild(_), _;
  }
  static isLogId(u) {
    return typeof u == "string";
  }
}
class CategoryControlProviderImpl {
  constructor(u, c) {
    this._provider = u, this._messageChannel = c, this._originalLogLevels = CategoryControlProviderImpl.loadCurrentGroupLogLevels(u);
  }
  get name() {
    return this._provider.name;
  }
  /**
   * Shows current settings.
   */
  showSettings() {
    let u = `Available categories (CategoryProvider '${this._provider.name}'):
`;
    const c = this.createCategoryInfoHierarchy(), l = c.size.toString().length, v = index$3.maxLengthStringValueInArray([...c.values()].map((_) => _.category.name + " ".repeat(_.depth))), p = [...c.values()].map((_, k) => CategoryControlProviderImpl.createSettingLineCategory(_, k, l, v));
    u += p.join(`
`) + (p.length > 0 ? `
` : ""), this._messageChannel(u);
  }
  help() {
    const u = `You can use the following commands (CategoryProvider ${this._provider.name}):
  showSettings()
    Shows the current configuration settings.
  update(level: CategoryControlProviderLogLevel, categoryId?: number | string, noRecurse?: boolean)
    Change the log level for a category (by default recursively).
      @param level      The log level to set - must be one of 'trace', 'debug', 'info', 'warn', 'error' or 'fatal'
      @param categoryId The category id or path of a category (e.g. root#child1) to update. Use showSettings() for id and/or name.
                        When omitted, it applies the level to all categories recursively.
  reset()
    Resets the log levels of the config groups back to when this control provider was created.
  save()
    Saves the current log levels for all categories of this provider. Use restore() to load last saved state.
  restore()
    Restore stored saved state, if any. Log levels will be set according to the saved state.
  help()
    Shows this help.
`;
    this._messageChannel(u);
  }
  reset() {
    const u = new Map(this._provider.getRegisteredCategories().map((c) => [c.id, c]));
    this._originalLogLevels.forEach((c, l) => {
      const v = u.get(l);
      v !== void 0 && this._provider.updateRuntimeSettingsCategory(v, { level: c, disableRecursion: !0 }), u.delete(l);
    }), u.forEach((c) => {
      c.parent !== void 0 && this._provider.updateRuntimeSettingsCategory(c, { level: c.parent.logLevel, disableRecursion: !0 });
    }), this._originalLogLevels = CategoryControlProviderImpl.loadCurrentGroupLogLevels(this._provider), this._messageChannel("Successfully reset log levels back to original state (from when this CategoryControlProvider was created).");
  }
  save() {
    if (!localStorage) {
      this._messageChannel("Cannot save state, localStorage is not available.");
      return;
    }
    const u = this._provider.getRegisteredCategories().filter((l) => l.parent === void 0).map((l) => CategoryControlProviderImpl.createCategorySaveData(l)), c = {
      name: this._provider.name,
      rootCategories: u
    };
    localStorage.setItem(this.createKey(), JSON.stringify(c)), this._messageChannel(`Successfully saved state for CategoryControlProvider '${this._provider.name}'.`);
  }
  restore(u) {
    const c = u !== void 0 ? u : !0;
    if (!localStorage) {
      c && this._messageChannel(`Will not attempt to restore state for CategoryControlProvider '${this._provider.name}', localStorage is not available.`);
      return;
    }
    const l = this.createKey(), v = localStorage.getItem(l);
    if (v === null) {
      c && this._messageChannel(`Cannot restore state for CategoryControlProvider '${this._provider.name}', no data available.`);
      return;
    }
    try {
      const p = JSON.parse(v);
      if (this._provider.name !== p.name) {
        c && this._messageChannel(`Cannot restore state for CategoryControlProvider '${this._provider.name}', data is not for provider - found name '${p.name}'.`);
        return;
      }
      this.restoreBySaveData(p, c), this._messageChannel(`Successfully restored state for CategoryControlProvider '${this._provider.name}'`), this._originalLogLevels = CategoryControlProviderImpl.loadCurrentGroupLogLevels(this._provider);
    } catch {
      localStorage.removeItem(l), this._messageChannel(`Cannot restore state for CategoryControlProvider '${this._provider.name}', data is not valid. Invalid data removed from localStorage.`);
    }
  }
  update(u, c, l) {
    typeof c > "u" ? this.updateAll(u) : typeof c == "number" ? this.updateByIndex(u, c, l !== void 0 ? l : !1) : this.updateByPath(u, c, l !== void 0 ? l : !1);
  }
  updateAll(u) {
    const c = LogLevel$1.toLogLevel(u);
    this._provider.getRegisteredCategories().filter((l) => l.parent === void 0).forEach((l) => this._provider.updateRuntimeSettingsCategory(l, { level: c })), this._messageChannel(`Updated all categories to use log level '${u.toLowerCase()}'`);
  }
  updateByPath(u, c, l) {
    const v = this._provider.getCategoryByPath(c);
    if (v === void 0) {
      this._messageChannel(`Failed to find a provider by path '${c}', please make sure to separate the parts by a ${CATEGORY_PATH_SEPARATOR}.`);
      return;
    }
    this._provider.updateRuntimeSettingsCategory(v, { level: LogLevel$1.toLogLevel(u), disableRecursion: l }), this._messageChannel(`Successfully updated category '${v.name}' with path '${c}' to log level '${u.toLowerCase()}'${l ? "" : " and recursively applied to children (if any)"}.`);
  }
  updateByIndex(u, c, l) {
    if (c < 0) {
      this._messageChannel(`Cannot update category by index '${c}', it is negative.`);
      return;
    }
    const v = this.createCategoryInfoHierarchy();
    if (c >= v.size) {
      this._messageChannel(`Cannot update category by index '${c}', it is outside of the range of available categories, use showSettings() to see the indices.`);
      return;
    }
    const p = [...v.values()][c].category;
    this._provider.updateRuntimeSettingsCategory(p, { level: LogLevel$1.toLogLevel(u), disableRecursion: l }), this._messageChannel(`Successfully updated category '${p.name}' by index '${c}' to log level '${u.toLowerCase()}'${l ? "" : " and recursively applied to children (if any)"}.`);
  }
  restoreBySaveData(u, c) {
    const l = (v, p) => {
      const _ = p.length > 0 ? p + CATEGORY_PATH_SEPARATOR + v.name : v.name, k = this._provider.getCategoryByPath(_);
      if (k !== void 0) {
        const M = LogLevel$1.toLogLevel(v.level);
        M !== void 0 ? this._provider.updateRuntimeSettingsCategory(k, { level: M, disableRecursion: !0 }) : c && this._messageChannel(`CategoryControlProvider '${this._provider.name}' - cannot restore log level for category path '${_}', log level is invalid.`);
        for (const L of v.children)
          l(L, _);
      } else
        c && this._messageChannel(`CategoryControlProvider '${this._provider.name}' - failed to find a Category by path '${_}', will not restore category (and children)`);
    };
    for (const v of u.rootCategories)
      l(v, "");
  }
  createKey() {
    return `CategoryProvider-${this._provider.name}`;
  }
  createCategoryInfoHierarchy() {
    const u = /* @__PURE__ */ new Map();
    return this._provider.getRegisteredCategories().filter((l) => l.parent === void 0).forEach((l) => CategoryControlProviderImpl.addCategoryInfoHierarchy(l, 0, u)), u;
  }
  static createCategorySaveData(u) {
    return {
      name: u.name,
      level: LogLevel$1[u.logLevel],
      children: u.children.map((c) => this.createCategorySaveData(c))
    };
  }
  static loadCurrentGroupLogLevels(u) {
    return new Map(u.getRegisteredCategories().map((c) => [c.id, c.logLevel]));
  }
  static createSettingLineCategory(u, c, l, v) {
    const _ = " ".repeat(u.depth) + u.category.name;
    return `  [${index$3.padStart(c.toString(), l)}, ${index$3.padEnd(_, v)} (level=${index$3.padEnd(u.logLevel, 5)})]`;
  }
  static addCategoryInfoHierarchy(u, c, l) {
    l.set(u.id, {
      category: u,
      logLevel: LogLevel$1[u.logLevel],
      depth: c
    }), u.children.forEach((v) => this.addCategoryInfoHierarchy(v, c + 1, l));
  }
}
function categoryConfigDebug(a) {
  return `CategoryConfig=level: ${LogLevel$1[a.level].toString()}, allowSameCategoryName=${a.allowSameCategoryName}`;
}
class CategoryProviderService {
  constructor() {
    this._log = InternalLogger.getInternalLogger("category.impl.CategoryProviderService"), this._providers = new index$3.EnhancedMap();
  }
  createLogProvider(u, c) {
    const l = this._providers.compute(u, (v, p) => {
      if (p)
        throw new Error(`CategoryProvider with name '${u}' already exists, cannot create another.`);
      const _ = mergeWithDefaults(c);
      return this._log.debug(() => `Creating new CategoryProvider with name '${u}', using config settings '${categoryConfigDebug(_)}'.`), new CategoryProviderImpl(u, _);
    });
    if (l)
      return l;
    throw new Error("No CategoryProvider? This is a bug.");
  }
  getCategoryControl(u) {
    const c = u || ((l) => {
      if (console && console.log)
        console.log(l);
      else
        throw new Error("Cannot use console (it is not present), please specify a custom function to write to.");
    });
    return {
      help: () => c(CategoryProviderService.help()),
      showSettings: () => c(this.showSettings()),
      getProvider: (l) => this.getCategoryControlProviderByIdOrName(l, c)
    };
  }
  clear() {
    this._providers.clear();
  }
  /* Functions for CategoryControl follow */
  showSettings() {
    let u = `Available CategoryProviders:
`;
    const c = this._providers.size.toString().length, l = index$3.maxLengthStringValueInArray([...this._providers.keys()]), v = [...this._providers.entries()].map((p, _) => {
      const k = p[0];
      return `  [${index$3.padStart(_.toString(), c)}, ${index$3.padEnd(k, l)}]`;
    });
    return u += v.join(`
`) + (v.length > 0 ? `
` : ""), u;
  }
  getCategoryControlProviderByIdOrName(u, c) {
    if (typeof u == "string") {
      const v = this._providers.get(u);
      if (v === void 0)
        throw new Error(`Provider with name '${u}' does not exist.`);
      return new CategoryControlProviderImpl(v, c);
    }
    const l = [...this._providers.values()];
    if (u < 0 || u >= l.length)
      throw new Error(`Provider with index '${u}' does not exist (outside of range).`);
    return new CategoryControlProviderImpl(l[u], c);
  }
  static help() {
    return `You can use the following commands:
  showSettings()
    Shows the current configuration settings.
  getProvider: (id: number | string): CategoryControlProvider
    Get access to a CategoryControlProvider to change log levels.
      @param id The id (use showSettings to see) or name of the provider
  help()
    Shows this help.
`;
  }
}
const CATEGORY_PROVIDER_SERVICE = new CategoryProviderService(), CATEGORY_LOG_CONTROL = (a) => CATEGORY_PROVIDER_SERVICE.getCategoryControl(a);
function mergeWithDefaults(a) {
  const u = {
    channel: DefaultChannels.createConsoleChannel(),
    allowSameCategoryName: !0,
    level: LogLevel$1.Error,
    dateFormatter: formatDate,
    argumentFormatter: formatArgument
  };
  return a ? {
    channel: a.channel ? a.channel : u.channel,
    allowSameCategoryName: a.allowSameCategoryName !== void 0 ? a.allowSameCategoryName : u.allowSameCategoryName,
    level: a.level ? a.level : u.level,
    dateFormatter: a.dateFormatter ? a.dateFormatter : u.dateFormatter,
    argumentFormatter: a.argumentFormatter ? a.argumentFormatter : u.argumentFormatter
  } : u;
}
var CategoryProvider;
(function(a) {
  function u(l, v) {
    return CATEGORY_PROVIDER_SERVICE.createLogProvider(l, v);
  }
  a.createProvider = u;
  function c() {
    CATEGORY_PROVIDER_SERVICE.clear();
  }
  a.clear = c;
})(CategoryProvider || (CategoryProvider = {}));
const typescriptLoggingCategory_esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CATEGORY_LOG_CONTROL,
  get CategoryProvider() {
    return CategoryProvider;
  }
}, Symbol.toStringTag, { value: "Module" })), require$$1$3 = /* @__PURE__ */ getAugmentedNamespace(typescriptLoggingCategory_esm);
Object.defineProperty(logger, "__esModule", { value: !0 });
logger.logger = void 0;
const typescript_logging_1 = require$$2$1, typescript_logging_category_style_1 = require$$1$3;
logger.logger = typescript_logging_category_style_1.CategoryProvider.createProvider("ApiStream", { allowSameCategoryName: !0, level: typescript_logging_1.LogLevel.Warn });
var version$4 = "1.0.38", __createBinding$3 = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(a, u, c, l) {
  l === void 0 && (l = c);
  var v = Object.getOwnPropertyDescriptor(u, c);
  (!v || ("get" in v ? !u.__esModule : v.writable || v.configurable)) && (v = { enumerable: !0, get: function() {
    return u[c];
  } }), Object.defineProperty(a, l, v);
} : function(a, u, c, l) {
  l === void 0 && (l = c), a[l] = u[c];
}), __setModuleDefault$3 = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(a, u) {
  Object.defineProperty(a, "default", { enumerable: !0, value: u });
} : function(a, u) {
  a.default = u;
}), __importStar$3 = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(a) {
  if (a && a.__esModule)
    return a;
  var u = {};
  if (a != null)
    for (var c in a)
      c !== "default" && Object.prototype.hasOwnProperty.call(a, c) && __createBinding$3(u, a, c);
  return __setModuleDefault$3(u, a), u;
};
Object.defineProperty(api$3, "__esModule", { value: !0 });
api$3.ApiClient = void 0;
const NiceGrpc$1 = __importStar$3(lib$1), abort_controller_x_1 = require$$1$5, logger_1 = logger, clientVersion$1 = version$4;
class ApiClient {
  constructor(u, c, l, v, p, _, k) {
    this.sessionId = u, this.sdkVersion = l, this.version = clientVersion$1, this.apiLogCallback = p, this.eventLogCallback = _, this.log = logger_1.logger.getCategory(v), this.apikey = k, this.channel = NiceGrpc$1.createChannel(c, NiceGrpc$1.FetchTransport()), this.clientFactory = NiceGrpc$1.createClientFactory().use(this.logMiddleware.bind(this));
  }
  async *logMiddleware(u, c) {
    const { path: l } = u.method;
    try {
      const v = yield* u.next(u.request, c);
      if (this.log.debug(`-> ${l}: ok`), this.log.trace(`${JSON.stringify(u.request)} -> ${l}: ${JSON.stringify(v)}`), this.apiLogCallback) {
        let p = l.split("/"), _ = p[1].split("."), k = _[_.length - 1], M = _[_.length - 2], L = _[_.length - 3], F = p[2];
        this.apiLogCallback(L, k, F, u.request, v);
      }
      return v;
    } catch (v) {
      throw this.log.trace(`${JSON.stringify(u.request)} -> ${l}`), v instanceof NiceGrpc$1.ClientError ? this.log.warn(`-> ${l}: error: ${NiceGrpc$1.Status[v.code]}: ${v.details}`) : (0, abort_controller_x_1.isAbortError)(v) ? this.log.warn(`-> ${l}: cancel`) : this.log.warn(`-> ${l}: error: ${v == null ? void 0 : v.stack}`), v;
    }
  }
  setAccessToken(u) {
    (this.accessToken == null || this.accessToken != u) && (this.log.debug("access token refreshed"), this.accessToken = u, this.setup());
  }
  makeGrpcMetadata() {
    let u = NiceGrpc$1.Metadata({
      Authorization: `Bearer ${this.accessToken}`,
      ClientType: "nodejs",
      Version: this.version,
      SessionId: this.sessionId
    });
    return this.sdkVersion != null && u.set("SdkVersion", this.sdkVersion), u;
  }
  makeGrpcMetadataApikey() {
    let u = NiceGrpc$1.Metadata({
      "x-api-key": this.apikey,
      ClientType: "nodejs",
      Version: this.version,
      SessionId: this.sessionId
    });
    return this.sdkVersion != null && u.set("SdkVersion", this.sdkVersion), u;
  }
  setup() {
    let u = {
      metadata: this.makeGrpcMetadata()
    };
    this._setup(u);
  }
  _setup(u) {
  }
}
api$3.ApiClient = ApiClient;
var decorator = {};
Object.defineProperty(decorator, "__esModule", { value: !0 });
decorator.RequiresSdkAuthentication = void 0;
function RequiresSdkAuthentication() {
  return function(a, u) {
    const c = Symbol(u);
    Object.defineProperty(a, u, {
      get: function() {
        if (!this[c])
          throw new Error("Please authenticate ApiStream by calling apiStream.load( accessToken )");
        return this[c];
      },
      set: function(l) {
        this[c] = l;
      }
    });
  };
}
decorator.RequiresSdkAuthentication = RequiresSdkAuthentication;
var __createBinding$2 = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(a, u, c, l) {
  l === void 0 && (l = c);
  var v = Object.getOwnPropertyDescriptor(u, c);
  (!v || ("get" in v ? !u.__esModule : v.writable || v.configurable)) && (v = { enumerable: !0, get: function() {
    return u[c];
  } }), Object.defineProperty(a, l, v);
} : function(a, u, c, l) {
  l === void 0 && (l = c), a[l] = u[c];
}), __setModuleDefault$2 = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(a, u) {
  Object.defineProperty(a, "default", { enumerable: !0, value: u });
} : function(a, u) {
  a.default = u;
}), __decorate = commonjsGlobal$1 && commonjsGlobal$1.__decorate || function(a, u, c, l) {
  var v = arguments.length, p = v < 3 ? u : l === null ? l = Object.getOwnPropertyDescriptor(u, c) : l, _;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    p = Reflect.decorate(a, u, c, l);
  else
    for (var k = a.length - 1; k >= 0; k--)
      (_ = a[k]) && (p = (v < 3 ? _(p) : v > 3 ? _(u, c, p) : _(u, c)) || p);
  return v > 3 && p && Object.defineProperty(u, c, p), p;
}, __importStar$2 = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(a) {
  if (a && a.__esModule)
    return a;
  var u = {};
  if (a != null)
    for (var c in a)
      c !== "default" && Object.prototype.hasOwnProperty.call(a, c) && __createBinding$2(u, a, c);
  return __setModuleDefault$2(u, a), u;
}, __metadata = commonjsGlobal$1 && commonjsGlobal$1.__metadata || function(a, u) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
    return Reflect.metadata(a, u);
};
Object.defineProperty(layoutapi, "__esModule", { value: !0 });
layoutapi.LayoutApi = void 0;
__importStar$2(lib$1);
const LayoutApiModel = __importStar$2(dist$2), api_1$1 = api$3, decorator_1 = decorator, LOG_CATEGORY$1 = "LayoutApi";
class LayoutApi extends api_1$1.ApiClient {
  constructor(u, c, l, v, p, _) {
    super(u, l, v, LOG_CATEGORY$1, p, void 0, _), this.handlers = {}, this.eventApi = c, this.eventApi.on("event", { name: `${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:*`, ignoreSessionEvents: !0 }, (k) => {
      var M;
      const [, L] = k.name.split(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:`), [F, V] = L.split(":"), X = k.payload;
      for (const oe of (M = this.handlers[F]) !== null && M !== void 0 ? M : [])
        oe(Object.values(X).find((Y) => !!Y), V);
    });
  }
  _setup(u) {
    this.layer = this.clientFactory.create(LayoutApiModel.LayerServiceDefinition, this.channel, {
      "*": u
    }), this.layout = this.clientFactory.create(LayoutApiModel.LayoutServiceDefinition, this.channel, {
      "*": u
    });
  }
  /**
   * Subscribe to all events for a given layout.
   *
   * @param layoutId - the id of the layout to which you want to subscribe to layout events
   */
  async subscribeToLayout(u) {
    await Promise.all([
      this.eventApi.subscribe(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:${LayoutApiModel.EventType.EVENT_TYPE_LAYER}:*`, { target: { layoutId: u } }),
      this.eventApi.subscribe(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:${LayoutApiModel.EventType.EVENT_TYPE_LAYOUT}:*`, { target: { layoutId: u } })
    ]);
  }
  /**
   * Unsubscribe from all events for a given layout.
   *
   * @param layoutId - the id of the layout to which you want to unsubscribe to layout events
   */
  async unsubscribeFromLayout(u) {
    await Promise.all([
      this.eventApi.unsubscribe(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:${LayoutApiModel.EventType.EVENT_TYPE_LAYER}:*`, { target: { layoutId: u } }),
      this.eventApi.unsubscribe(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:${LayoutApiModel.EventType.EVENT_TYPE_LAYOUT}:*`, { target: { layoutId: u } })
    ]);
  }
  /**
   * Subscribe to all events for layouts in a project.
   *
   * @param collectionId - the id of the collection the layouts are in.
   * @param projectId - the id of the project the layouts are in.
   */
  async subscribeToLayoutsInProject(u, c) {
    await Promise.all([
      this.eventApi.subscribe(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:${LayoutApiModel.EventType.EVENT_TYPE_LAYER}:*`, { target: { collectionId: u, projectId: c } }),
      this.eventApi.subscribe(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:${LayoutApiModel.EventType.EVENT_TYPE_LAYOUT}:*`, { target: { collectionId: u, projectId: c } })
    ]);
  }
  /**
   * Unsubscribe from all events for layouts in a project.
   *
   * @param collectionId - the id of the collection the layouts are in.
   * @param projectId - the id of the project the layouts are in.
   */
  async unsubscribeFromLayoutsInProject(u, c) {
    await Promise.all([
      this.eventApi.unsubscribe(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:${LayoutApiModel.EventType.EVENT_TYPE_LAYER}:*`, { target: { collectionId: u, projectId: c } }),
      this.eventApi.unsubscribe(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:${LayoutApiModel.EventType.EVENT_TYPE_LAYOUT}:*`, { target: { collectionId: u, projectId: c } })
    ]);
  }
  /**
   * Register an event handler
   *
   * @param type Type of event
   * @param handler
   */
  on(u, c) {
    var l;
    this.handlers[u] = (l = this.handlers[u]) !== null && l !== void 0 ? l : [], this.handlers[u].push(c);
  }
  /**
   * Unregister an event handler
   *
   * @param type Type of event
   * @param handler
   */
  off(u, c) {
    this.handlers[u] = this.handlers[u].filter((l) => l !== c);
  }
}
LayoutApi.LAYOUTAPI_EVENT_PREFIX = "apistream:layout";
__decorate([
  (0, decorator_1.RequiresSdkAuthentication)(),
  __metadata("design:type", Object)
], LayoutApi.prototype, "layout", void 0);
__decorate([
  (0, decorator_1.RequiresSdkAuthentication)(),
  __metadata("design:type", Object)
], LayoutApi.prototype, "layer", void 0);
layoutapi.LayoutApi = LayoutApi;
var liveapi = {}, api$2 = {}, httpbody = {}, any = {}, __importDefault$d = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(any, "__esModule", { value: !0 });
any.Any = any.protobufPackage = void 0;
const minimal_1$6 = __importDefault$d(minimal);
any.protobufPackage = "google.protobuf";
function createBaseAny() {
  return { typeUrl: "", value: new Uint8Array() };
}
any.Any = {
  encode(a, u = minimal_1$6.default.Writer.create()) {
    return a.typeUrl !== "" && u.uint32(10).string(a.typeUrl), a.value.length !== 0 && u.uint32(18).bytes(a.value), u;
  },
  decode(a, u) {
    const c = a instanceof minimal_1$6.default.Reader ? a : new minimal_1$6.default.Reader(a);
    let l = u === void 0 ? c.len : c.pos + u;
    const v = createBaseAny();
    for (; c.pos < l; ) {
      const p = c.uint32();
      switch (p >>> 3) {
        case 1:
          v.typeUrl = c.string();
          break;
        case 2:
          v.value = c.bytes();
          break;
        default:
          c.skipType(p & 7);
          break;
      }
    }
    return v;
  },
  fromJSON(a) {
    return {
      typeUrl: isSet$6(a.typeUrl) ? String(a.typeUrl) : "",
      value: isSet$6(a.value) ? bytesFromBase64$1(a.value) : new Uint8Array()
    };
  },
  toJSON(a) {
    const u = {};
    return a.typeUrl !== void 0 && (u.typeUrl = a.typeUrl), a.value !== void 0 && (u.value = base64FromBytes$1(a.value !== void 0 ? a.value : new Uint8Array())), u;
  },
  fromPartial(a) {
    var u, c;
    const l = createBaseAny();
    return l.typeUrl = (u = a.typeUrl) !== null && u !== void 0 ? u : "", l.value = (c = a.value) !== null && c !== void 0 ? c : new Uint8Array(), l;
  }
};
var tsProtoGlobalThis$3 = (() => {
  if (typeof globalThis < "u")
    return globalThis;
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof commonjsGlobal$1 < "u")
    return commonjsGlobal$1;
  throw "Unable to locate global object";
})();
function bytesFromBase64$1(a) {
  if (tsProtoGlobalThis$3.Buffer)
    return Uint8Array.from(tsProtoGlobalThis$3.Buffer.from(a, "base64"));
  {
    const u = tsProtoGlobalThis$3.atob(a), c = new Uint8Array(u.length);
    for (let l = 0; l < u.length; ++l)
      c[l] = u.charCodeAt(l);
    return c;
  }
}
function base64FromBytes$1(a) {
  if (tsProtoGlobalThis$3.Buffer)
    return tsProtoGlobalThis$3.Buffer.from(a).toString("base64");
  {
    const u = [];
    return a.forEach((c) => {
      u.push(String.fromCharCode(c));
    }), tsProtoGlobalThis$3.btoa(u.join(""));
  }
}
function isSet$6(a) {
  return a != null;
}
var __importDefault$c = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(httpbody, "__esModule", { value: !0 });
httpbody.HttpBody = httpbody.protobufPackage = void 0;
const minimal_1$5 = __importDefault$c(minimal), any_1 = any;
httpbody.protobufPackage = "google.api";
function createBaseHttpBody() {
  return { contentType: "", data: new Uint8Array(), extensions: [] };
}
httpbody.HttpBody = {
  encode(a, u = minimal_1$5.default.Writer.create()) {
    a.contentType !== "" && u.uint32(10).string(a.contentType), a.data.length !== 0 && u.uint32(18).bytes(a.data);
    for (const c of a.extensions)
      any_1.Any.encode(c, u.uint32(26).fork()).ldelim();
    return u;
  },
  decode(a, u) {
    const c = a instanceof minimal_1$5.default.Reader ? a : new minimal_1$5.default.Reader(a);
    let l = u === void 0 ? c.len : c.pos + u;
    const v = createBaseHttpBody();
    for (; c.pos < l; ) {
      const p = c.uint32();
      switch (p >>> 3) {
        case 1:
          v.contentType = c.string();
          break;
        case 2:
          v.data = c.bytes();
          break;
        case 3:
          v.extensions.push(any_1.Any.decode(c, c.uint32()));
          break;
        default:
          c.skipType(p & 7);
          break;
      }
    }
    return v;
  },
  fromJSON(a) {
    return {
      contentType: isSet$5(a.contentType) ? String(a.contentType) : "",
      data: isSet$5(a.data) ? bytesFromBase64(a.data) : new Uint8Array(),
      extensions: Array.isArray(a == null ? void 0 : a.extensions) ? a.extensions.map((u) => any_1.Any.fromJSON(u)) : []
    };
  },
  toJSON(a) {
    const u = {};
    return a.contentType !== void 0 && (u.contentType = a.contentType), a.data !== void 0 && (u.data = base64FromBytes(a.data !== void 0 ? a.data : new Uint8Array())), a.extensions ? u.extensions = a.extensions.map((c) => c ? any_1.Any.toJSON(c) : void 0) : u.extensions = [], u;
  },
  fromPartial(a) {
    var u, c, l;
    const v = createBaseHttpBody();
    return v.contentType = (u = a.contentType) !== null && u !== void 0 ? u : "", v.data = (c = a.data) !== null && c !== void 0 ? c : new Uint8Array(), v.extensions = ((l = a.extensions) === null || l === void 0 ? void 0 : l.map((p) => any_1.Any.fromPartial(p))) || [], v;
  }
};
var tsProtoGlobalThis$2 = (() => {
  if (typeof globalThis < "u")
    return globalThis;
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof commonjsGlobal$1 < "u")
    return commonjsGlobal$1;
  throw "Unable to locate global object";
})();
function bytesFromBase64(a) {
  if (tsProtoGlobalThis$2.Buffer)
    return Uint8Array.from(tsProtoGlobalThis$2.Buffer.from(a, "base64"));
  {
    const u = tsProtoGlobalThis$2.atob(a), c = new Uint8Array(u.length);
    for (let l = 0; l < u.length; ++l)
      c[l] = u.charCodeAt(l);
    return c;
  }
}
function base64FromBytes(a) {
  if (tsProtoGlobalThis$2.Buffer)
    return tsProtoGlobalThis$2.Buffer.from(a).toString("base64");
  {
    const u = [];
    return a.forEach((c) => {
      u.push(String.fromCharCode(c));
    }), tsProtoGlobalThis$2.btoa(u.join(""));
  }
}
function isSet$5(a) {
  return a != null;
}
var field_mask = {}, __importDefault$b = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(field_mask, "__esModule", { value: !0 });
field_mask.FieldMask = field_mask.protobufPackage = void 0;
const minimal_1$4 = __importDefault$b(minimal);
field_mask.protobufPackage = "google.protobuf";
function createBaseFieldMask() {
  return { paths: [] };
}
field_mask.FieldMask = {
  encode(a, u = minimal_1$4.default.Writer.create()) {
    for (const c of a.paths)
      u.uint32(10).string(c);
    return u;
  },
  decode(a, u) {
    const c = a instanceof minimal_1$4.default.Reader ? a : new minimal_1$4.default.Reader(a);
    let l = u === void 0 ? c.len : c.pos + u;
    const v = createBaseFieldMask();
    for (; c.pos < l; ) {
      const p = c.uint32();
      switch (p >>> 3) {
        case 1:
          v.paths.push(c.string());
          break;
        default:
          c.skipType(p & 7);
          break;
      }
    }
    return v;
  },
  fromJSON(a) {
    return {
      paths: typeof a == "string" ? a.split(",").filter(Boolean) : Array.isArray(a == null ? void 0 : a.paths) ? a.paths.map(String) : []
    };
  },
  toJSON(a) {
    return a.paths.join(",");
  },
  fromPartial(a) {
    var u;
    const c = createBaseFieldMask();
    return c.paths = ((u = a.paths) === null || u === void 0 ? void 0 : u.map((l) => l)) || [], c;
  },
  wrap(a) {
    const u = createBaseFieldMask();
    return u.paths = a, u;
  },
  unwrap(a) {
    return a.paths;
  }
};
var struct$1 = {};
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(Y) {
    return Y && Y.__esModule ? Y : { default: Y };
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.ListValue = a.Value = a.Struct_FieldsEntry = a.Struct = a.nullValueToNumber = a.nullValueToJSON = a.nullValueFromJSON = a.NullValue = a.protobufPackage = void 0;
  const c = u(minimal);
  a.protobufPackage = "google.protobuf";
  var l;
  (function(Y) {
    Y.NULL_VALUE = "NULL_VALUE";
  })(l = a.NullValue || (a.NullValue = {}));
  function v(Y) {
    switch (Y) {
      case 0:
      case "NULL_VALUE":
        return l.NULL_VALUE;
      default:
        throw new V.Error("Unrecognized enum value " + Y + " for enum NullValue");
    }
  }
  a.nullValueFromJSON = v;
  function p(Y) {
    switch (Y) {
      case l.NULL_VALUE:
        return "NULL_VALUE";
      default:
        throw new V.Error("Unrecognized enum value " + Y + " for enum NullValue");
    }
  }
  a.nullValueToJSON = p;
  function _(Y) {
    switch (Y) {
      case l.NULL_VALUE:
        return 0;
      default:
        throw new V.Error("Unrecognized enum value " + Y + " for enum NullValue");
    }
  }
  a.nullValueToNumber = _;
  function k() {
    return { fields: {} };
  }
  a.Struct = {
    encode(Y, ae = c.default.Writer.create()) {
      return Object.entries(Y.fields).forEach(([ne, fe]) => {
        fe !== void 0 && a.Struct_FieldsEntry.encode({ key: ne, value: fe }, ae.uint32(10).fork()).ldelim();
      }), ae;
    },
    decode(Y, ae) {
      const ne = Y instanceof c.default.Reader ? Y : new c.default.Reader(Y);
      let fe = ae === void 0 ? ne.len : ne.pos + ae;
      const ie = k();
      for (; ne.pos < fe; ) {
        const ge = ne.uint32();
        switch (ge >>> 3) {
          case 1:
            const be = a.Struct_FieldsEntry.decode(ne, ne.uint32());
            be.value !== void 0 && (ie.fields[be.key] = be.value);
            break;
          default:
            ne.skipType(ge & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(Y) {
      return {
        fields: X(Y.fields) ? Object.entries(Y.fields).reduce((ae, [ne, fe]) => (ae[ne] = fe, ae), {}) : {}
      };
    },
    toJSON(Y) {
      const ae = {};
      return ae.fields = {}, Y.fields && Object.entries(Y.fields).forEach(([ne, fe]) => {
        ae.fields[ne] = fe;
      }), ae;
    },
    fromPartial(Y) {
      var ae;
      const ne = k();
      return ne.fields = Object.entries((ae = Y.fields) !== null && ae !== void 0 ? ae : {}).reduce((fe, [ie, ge]) => (ge !== void 0 && (fe[ie] = ge), fe), {}), ne;
    },
    wrap(Y) {
      const ae = k();
      return Y !== void 0 && Object.keys(Y).forEach((ne) => {
        ae.fields[ne] = Y[ne];
      }), ae;
    },
    unwrap(Y) {
      const ae = {};
      return Object.keys(Y.fields).forEach((ne) => {
        ae[ne] = Y.fields[ne];
      }), ae;
    }
  };
  function M() {
    return { key: "", value: void 0 };
  }
  a.Struct_FieldsEntry = {
    encode(Y, ae = c.default.Writer.create()) {
      return Y.key !== "" && ae.uint32(10).string(Y.key), Y.value !== void 0 && a.Value.encode(a.Value.wrap(Y.value), ae.uint32(18).fork()).ldelim(), ae;
    },
    decode(Y, ae) {
      const ne = Y instanceof c.default.Reader ? Y : new c.default.Reader(Y);
      let fe = ae === void 0 ? ne.len : ne.pos + ae;
      const ie = M();
      for (; ne.pos < fe; ) {
        const ge = ne.uint32();
        switch (ge >>> 3) {
          case 1:
            ie.key = ne.string();
            break;
          case 2:
            ie.value = a.Value.unwrap(a.Value.decode(ne, ne.uint32()));
            break;
          default:
            ne.skipType(ge & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(Y) {
      return { key: oe(Y.key) ? String(Y.key) : "", value: oe(Y == null ? void 0 : Y.value) ? Y.value : void 0 };
    },
    toJSON(Y) {
      const ae = {};
      return Y.key !== void 0 && (ae.key = Y.key), Y.value !== void 0 && (ae.value = Y.value), ae;
    },
    fromPartial(Y) {
      var ae, ne;
      const fe = M();
      return fe.key = (ae = Y.key) !== null && ae !== void 0 ? ae : "", fe.value = (ne = Y.value) !== null && ne !== void 0 ? ne : void 0, fe;
    }
  };
  function L() {
    return {
      nullValue: void 0,
      numberValue: void 0,
      stringValue: void 0,
      boolValue: void 0,
      structValue: void 0,
      listValue: void 0
    };
  }
  a.Value = {
    encode(Y, ae = c.default.Writer.create()) {
      return Y.nullValue !== void 0 && ae.uint32(8).int32(_(Y.nullValue)), Y.numberValue !== void 0 && ae.uint32(17).double(Y.numberValue), Y.stringValue !== void 0 && ae.uint32(26).string(Y.stringValue), Y.boolValue !== void 0 && ae.uint32(32).bool(Y.boolValue), Y.structValue !== void 0 && a.Struct.encode(a.Struct.wrap(Y.structValue), ae.uint32(42).fork()).ldelim(), Y.listValue !== void 0 && a.ListValue.encode(a.ListValue.wrap(Y.listValue), ae.uint32(50).fork()).ldelim(), ae;
    },
    decode(Y, ae) {
      const ne = Y instanceof c.default.Reader ? Y : new c.default.Reader(Y);
      let fe = ae === void 0 ? ne.len : ne.pos + ae;
      const ie = L();
      for (; ne.pos < fe; ) {
        const ge = ne.uint32();
        switch (ge >>> 3) {
          case 1:
            ie.nullValue = v(ne.int32());
            break;
          case 2:
            ie.numberValue = ne.double();
            break;
          case 3:
            ie.stringValue = ne.string();
            break;
          case 4:
            ie.boolValue = ne.bool();
            break;
          case 5:
            ie.structValue = a.Struct.unwrap(a.Struct.decode(ne, ne.uint32()));
            break;
          case 6:
            ie.listValue = a.ListValue.unwrap(a.ListValue.decode(ne, ne.uint32()));
            break;
          default:
            ne.skipType(ge & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(Y) {
      return {
        nullValue: oe(Y.nullValue) ? v(Y.nullValue) : void 0,
        numberValue: oe(Y.numberValue) ? Number(Y.numberValue) : void 0,
        stringValue: oe(Y.stringValue) ? String(Y.stringValue) : void 0,
        boolValue: oe(Y.boolValue) ? !!Y.boolValue : void 0,
        structValue: X(Y.structValue) ? Y.structValue : void 0,
        listValue: Array.isArray(Y.listValue) ? [...Y.listValue] : void 0
      };
    },
    toJSON(Y) {
      const ae = {};
      return Y.nullValue !== void 0 && (ae.nullValue = Y.nullValue !== void 0 ? p(Y.nullValue) : void 0), Y.numberValue !== void 0 && (ae.numberValue = Y.numberValue), Y.stringValue !== void 0 && (ae.stringValue = Y.stringValue), Y.boolValue !== void 0 && (ae.boolValue = Y.boolValue), Y.structValue !== void 0 && (ae.structValue = Y.structValue), Y.listValue !== void 0 && (ae.listValue = Y.listValue), ae;
    },
    fromPartial(Y) {
      var ae, ne, fe, ie, ge, be;
      const Ce = L();
      return Ce.nullValue = (ae = Y.nullValue) !== null && ae !== void 0 ? ae : void 0, Ce.numberValue = (ne = Y.numberValue) !== null && ne !== void 0 ? ne : void 0, Ce.stringValue = (fe = Y.stringValue) !== null && fe !== void 0 ? fe : void 0, Ce.boolValue = (ie = Y.boolValue) !== null && ie !== void 0 ? ie : void 0, Ce.structValue = (ge = Y.structValue) !== null && ge !== void 0 ? ge : void 0, Ce.listValue = (be = Y.listValue) !== null && be !== void 0 ? be : void 0, Ce;
    },
    wrap(Y) {
      const ae = L();
      if (Y === null)
        ae.nullValue = l.NULL_VALUE;
      else if (typeof Y == "boolean")
        ae.boolValue = Y;
      else if (typeof Y == "number")
        ae.numberValue = Y;
      else if (typeof Y == "string")
        ae.stringValue = Y;
      else if (Array.isArray(Y))
        ae.listValue = Y;
      else if (typeof Y == "object")
        ae.structValue = Y;
      else if (typeof Y < "u")
        throw new Error("Unsupported any value type: " + typeof Y);
      return ae;
    },
    unwrap(Y) {
      if ((Y == null ? void 0 : Y.stringValue) !== void 0)
        return Y.stringValue;
      if ((Y == null ? void 0 : Y.numberValue) !== void 0)
        return Y.numberValue;
      if ((Y == null ? void 0 : Y.boolValue) !== void 0)
        return Y.boolValue;
      if ((Y == null ? void 0 : Y.structValue) !== void 0)
        return Y.structValue;
      if ((Y == null ? void 0 : Y.listValue) !== void 0)
        return Y.listValue;
      if ((Y == null ? void 0 : Y.nullValue) !== void 0)
        return null;
    }
  };
  function F() {
    return { values: [] };
  }
  a.ListValue = {
    encode(Y, ae = c.default.Writer.create()) {
      for (const ne of Y.values)
        a.Value.encode(a.Value.wrap(ne), ae.uint32(10).fork()).ldelim();
      return ae;
    },
    decode(Y, ae) {
      const ne = Y instanceof c.default.Reader ? Y : new c.default.Reader(Y);
      let fe = ae === void 0 ? ne.len : ne.pos + ae;
      const ie = F();
      for (; ne.pos < fe; ) {
        const ge = ne.uint32();
        switch (ge >>> 3) {
          case 1:
            ie.values.push(a.Value.unwrap(a.Value.decode(ne, ne.uint32())));
            break;
          default:
            ne.skipType(ge & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(Y) {
      return { values: Array.isArray(Y == null ? void 0 : Y.values) ? [...Y.values] : [] };
    },
    toJSON(Y) {
      const ae = {};
      return Y.values ? ae.values = Y.values.map((ne) => ne) : ae.values = [], ae;
    },
    fromPartial(Y) {
      var ae;
      const ne = F();
      return ne.values = ((ae = Y.values) === null || ae === void 0 ? void 0 : ae.map((fe) => fe)) || [], ne;
    },
    wrap(Y) {
      const ae = F();
      return ae.values = Y ?? [], ae;
    },
    unwrap(Y) {
      return Y.values;
    }
  };
  var V = (() => {
    if (typeof globalThis < "u")
      return globalThis;
    if (typeof self < "u")
      return self;
    if (typeof window < "u")
      return window;
    if (typeof commonjsGlobal$1 < "u")
      return commonjsGlobal$1;
    throw "Unable to locate global object";
  })();
  function X(Y) {
    return typeof Y == "object" && Y !== null;
  }
  function oe(Y) {
    return Y != null;
  }
})(struct$1);
var timestamp$3 = {}, __importDefault$a = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(timestamp$3, "__esModule", { value: !0 });
timestamp$3.Timestamp = timestamp$3.protobufPackage = void 0;
const long_1$3 = __importDefault$a(umdExports), minimal_1$3 = __importDefault$a(minimal);
timestamp$3.protobufPackage = "google.protobuf";
function createBaseTimestamp$2() {
  return { seconds: 0, nanos: 0 };
}
timestamp$3.Timestamp = {
  encode(a, u = minimal_1$3.default.Writer.create()) {
    return a.seconds !== 0 && u.uint32(8).int64(a.seconds), a.nanos !== 0 && u.uint32(16).int32(a.nanos), u;
  },
  decode(a, u) {
    const c = a instanceof minimal_1$3.default.Reader ? a : new minimal_1$3.default.Reader(a);
    let l = u === void 0 ? c.len : c.pos + u;
    const v = createBaseTimestamp$2();
    for (; c.pos < l; ) {
      const p = c.uint32();
      switch (p >>> 3) {
        case 1:
          v.seconds = longToNumber$3(c.int64());
          break;
        case 2:
          v.nanos = c.int32();
          break;
        default:
          c.skipType(p & 7);
          break;
      }
    }
    return v;
  },
  fromJSON(a) {
    return {
      seconds: isSet$4(a.seconds) ? Number(a.seconds) : 0,
      nanos: isSet$4(a.nanos) ? Number(a.nanos) : 0
    };
  },
  toJSON(a) {
    const u = {};
    return a.seconds !== void 0 && (u.seconds = Math.round(a.seconds)), a.nanos !== void 0 && (u.nanos = Math.round(a.nanos)), u;
  },
  fromPartial(a) {
    var u, c;
    const l = createBaseTimestamp$2();
    return l.seconds = (u = a.seconds) !== null && u !== void 0 ? u : 0, l.nanos = (c = a.nanos) !== null && c !== void 0 ? c : 0, l;
  }
};
var tsProtoGlobalThis$1 = (() => {
  if (typeof globalThis < "u")
    return globalThis;
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof commonjsGlobal$1 < "u")
    return commonjsGlobal$1;
  throw "Unable to locate global object";
})();
function longToNumber$3(a) {
  if (a.gt(Number.MAX_SAFE_INTEGER))
    throw new tsProtoGlobalThis$1.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  return a.toNumber();
}
minimal_1$3.default.util.Long !== long_1$3.default && (minimal_1$3.default.util.Long = long_1$3.default, minimal_1$3.default.configure());
function isSet$4(a) {
  return a != null;
}
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(b) {
    return b && b.__esModule ? b : { default: b };
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.S3ACL = a.projectBroadcastPhaseToNumber = a.projectBroadcastPhaseToJSON = a.projectBroadcastPhaseFromJSON = a.ProjectBroadcastPhase = a.videoCodecRateControlModeToNumber = a.videoCodecRateControlModeToJSON = a.videoCodecRateControlModeFromJSON = a.VideoCodecRateControlMode = a.audioCodecToNumber = a.audioCodecToJSON = a.audioCodecFromJSON = a.AudioCodec = a.videoCodecProfileToNumber = a.videoCodecProfileToJSON = a.videoCodecProfileFromJSON = a.VideoCodecProfile = a.videoCodecToNumber = a.videoCodecToJSON = a.videoCodecFromJSON = a.VideoCodec = a.renderingQualityToNumber = a.renderingQualityToJSON = a.renderingQualityFromJSON = a.RenderingQuality = a.audioChannelLayoutToNumber = a.audioChannelLayoutToJSON = a.audioChannelLayoutFromJSON = a.AudioChannelLayout = a.videoColorSpaceToNumber = a.videoColorSpaceToJSON = a.videoColorSpaceFromJSON = a.VideoColorSpace = a.imageFormatToNumber = a.imageFormatToJSON = a.imageFormatFromJSON = a.ImageFormat = a.webhookSubtypeToNumber = a.webhookSubtypeToJSON = a.webhookSubtypeFromJSON = a.WebhookSubtype = a.webhookTypeToNumber = a.webhookTypeToJSON = a.webhookTypeFromJSON = a.WebhookType = a.broadcastOriginToNumber = a.broadcastOriginToJSON = a.broadcastOriginFromJSON = a.BroadcastOrigin = a.protobufPackage = void 0, a.SourceRtmpPushAddress = a.Encoding = a.AudioEncoding = a.VideoEncoding = a.VideoCodecRateControl = a.Rendering = a.AudioRendering = a.VideoRendering = a.UpdateAccountConfigurationResponse = a.UpdateAccountConfigurationRequest = a.GetAccountConfigurationResponse = a.GetAccountConfigurationRequest = a.AccountConfiguration = a.AccountConfigurationHook = a.WebhookConfiguration = a.WebhookResponse = a.WebhookRequest = a.BroadcastOriginSourceMetadata = a.BroadcastOriginExternalMetadata = a.eventTypeToNumber = a.eventTypeToJSON = a.eventTypeFromJSON = a.EventType = a.eventSubTypeToNumber = a.eventSubTypeToJSON = a.eventSubTypeFromJSON = a.EventSubType = a.connectStateToNumber = a.connectStateToJSON = a.connectStateFromJSON = a.ConnectState = a.projectBroadcastErrorToNumber = a.projectBroadcastErrorToJSON = a.projectBroadcastErrorFromJSON = a.ProjectBroadcastError = a.roleToNumber = a.roleToJSON = a.roleFromJSON = a.Role = a.regionToNumber = a.regionToJSON = a.regionFromJSON = a.Region = a.sourceTriggerActionToNumber = a.sourceTriggerActionToJSON = a.sourceTriggerActionFromJSON = a.SourceTriggerAction = a.s3ACLToNumber = a.s3ACLToJSON = a.s3ACLFromJSON = void 0, a.CreateProjectResponse = a.CreateProjectRequest = a.GetCollectionsResponse = a.GetCollectionsRequest = a.DeleteCollectionResponse = a.DeleteCollectionRequest = a.UpdateCollectionResponse = a.UpdateCollectionRequest = a.GetCollectionResponse = a.GetCollectionRequest = a.CreateCollectionResponse = a.CreateCollectionRequest = a.Collection = a.Project = a.Destination = a.Source = a.ProjectBroadcastStatus = a.DirectIngestUrl = a.LatLong = a.WebRtcAccess = a.WebRtc = a.HostedWebRtc = a.Composition = a.ExternalComposition = a.SceneComposition = a.StudioSdkComposition = a.PreviewAddress = a.PreviewHlsPullAddress = a.ProjectTrigger = a.WebRtcTrigger = a.SourceTrigger = a.DestinationAddress = a.S3StorageAddress = a.PreviewWebRtcAddress = a.ObjectStoragePackaging = a.HlsPackaging = a.HlsLifecycle = a.HlsLifecycleVod = a.HlsLifecycleLive = a.DestinationAgoraPushAddress = a.DestinationSrtPushAddress = a.DestinationRtmpPushAddress = a.SourceAddress = a.RuntimeSourceAddress = a.DirectSrtAddress = a.DirectRTMPAddress = a.DynamicAddress = a.SrtPullAddress = a.RtmpPullAddress = a.SrtPushAddress = void 0, a.GuestAccessTokenDirect = a.LookupGuestCodeResponse = a.LookupGuestCodeRequest = a.CreateAccessTokenResponse = a.CreateAccessTokenRequest = a.GetSourcePlaylistResponse = a.GetSourcePlaylistRequest = a.RemoveSourceFromProjectResponse = a.RemoveSourceFromProjectRequest = a.UpdateSourceResponse = a.UpdateSourceRequest = a.GetSourcesResponse = a.GetSourcesRequest = a.GetSourceResponse = a.GetSourceRequest = a.UpdateSourceInProjectResponse = a.UpdateSourceInProjectRequest = a.AddSourceToProjectResponse = a.AddSourceToProjectRequest = a.DeleteSourceResponse = a.DeleteSourceRequest = a.CreateSourceResponse = a.CreateSourceRequest = a.UpdateDestinationResponse = a.UpdateDestinationRequest = a.DeleteDestinationResponse = a.DeleteDestinationRequest = a.GetDestinationResponse = a.GetDestinationRequest = a.CreateDestinationResponse = a.CreateDestinationRequest = a.StopProjectWebRtcResponse = a.StopProjectWebRtcRequest = a.StartProjectWebRtcResponse = a.StartProjectWebRtcRequest = a.GetProjectBroadcastStatusResponse = a.GetProjectBroadcastStatusRequest = a.GetProjectBroadcastSnapshotResponse = a.GetProjectBroadcastSnapshotRequest = a.GetProjectResponse = a.GetProjectRequest = a.StopProjectBroadcastResponse = a.StopProjectBroadcastRequest = a.StartProjectBroadcastResponse = a.StartProjectBroadcastRequest_DynamicSourcesEntry = a.StartProjectBroadcastRequest = a.DeleteProjectResponse = a.DeleteProjectRequest = a.UpdateProjectResponse = a.UpdateProjectRequest = void 0, a.GetServiceResponse = a.Service = a.GetServiceRequest = a.LiveEvent = a.SourceEvent = a.ProjectEvent = a.DestinationEvent = a.CollectionEvent = a.SourceStateEvent = a.SourceRemoveEvent = a.SourceAddEvent = a.SourceUpdateEvent = a.SourceDeleteEvent = a.SourceCreateEvent = a.CollectionUpdateEvent = a.CollectionDeleteEvent = a.CollectionCreateEvent = a.ProjectBroadcastStateEvent = a.ProjectUpdateEvent = a.ProjectDeleteEvent = a.ProjectCreateEvent = a.DestinationStateEvent = a.DestinationUpdateEvent = a.DestinationDeleteEvent = a.DestinationCreateEvent = a.GetTestTokenResponse = a.GetTestTokenRequest = a.GetJsonWebKeySetResponse = a.GetJsonWebKeySetRequest = a.JsonWebKey = a.DeleteGuestCodeResponse = a.DeleteGuestCodeRequest = a.GetGuestCodesResponse = a.GetGuestCodesRequest = a.GetGuestCodeResponse = a.GetGuestCodeRequest = a.CreateGuestCodeResponse = a.CreateGuestCodeRequest = a.IssuedGuestCode = a.GuestCodeRedirectResponse = a.GuestCodeRedirectRequest = a.GuestCode = a.RefreshAccessTokenResponse = a.RefreshAccessTokenRequest = a.CreateWebRtcAccessTokenResponse = a.CreateWebRtcAccessTokenRequest = a.CreateGuestAccessTokenResponse = a.CreateGuestAccessTokenRequest = a.GuestAccessToken = a.GuestAccessTokenExchange = void 0, a.AccountServiceDefinition = a.AccountServiceClientImpl = a.PublicAuthenticationServiceDefinition = a.PublicAuthenticationServiceClientImpl = a.AuthenticationServiceDefinition = a.AuthenticationServiceClientImpl = a.BackendAuthenticationServiceDefinition = a.BackendAuthenticationServiceClientImpl = a.SourceServiceDefinition = a.SourceServiceClientImpl = a.DestinationServiceDefinition = a.DestinationServiceClientImpl = a.ProjectServiceDefinition = a.ProjectServiceClientImpl = a.CollectionServiceDefinition = a.CollectionServiceClientImpl = a.AccountConfigurationServiceDefinition = a.AccountConfigurationServiceClientImpl = void 0;
  const c = u(minimal), l = httpbody, v = field_mask, p = struct$1, _ = timestamp$3;
  a.protobufPackage = "live.v21";
  var k;
  (function(b) {
    b.BROADCAST_ORIGIN_UNSPECIFIED = "BROADCAST_ORIGIN_UNSPECIFIED", b.BROADCAST_ORIGIN_API = "BROADCAST_ORIGIN_API", b.BROADCAST_ORIGIN_SOURCE = "BROADCAST_ORIGIN_SOURCE", b.BROADCAST_ORIGIN_EXTERNAL = "BROADCAST_ORIGIN_EXTERNAL", b.BROADCAST_ORIGIN_SYSTEM = "BROADCAST_ORIGIN_SYSTEM";
  })(k = a.BroadcastOrigin || (a.BroadcastOrigin = {}));
  function M(b) {
    switch (b) {
      case 0:
      case "BROADCAST_ORIGIN_UNSPECIFIED":
        return k.BROADCAST_ORIGIN_UNSPECIFIED;
      case 1:
      case "BROADCAST_ORIGIN_API":
        return k.BROADCAST_ORIGIN_API;
      case 2:
      case "BROADCAST_ORIGIN_SOURCE":
        return k.BROADCAST_ORIGIN_SOURCE;
      case 3:
      case "BROADCAST_ORIGIN_EXTERNAL":
        return k.BROADCAST_ORIGIN_EXTERNAL;
      case 4:
      case "BROADCAST_ORIGIN_SYSTEM":
        return k.BROADCAST_ORIGIN_SYSTEM;
      default:
        throw new Tt.Error("Unrecognized enum value " + b + " for enum BroadcastOrigin");
    }
  }
  a.broadcastOriginFromJSON = M;
  function L(b) {
    switch (b) {
      case k.BROADCAST_ORIGIN_UNSPECIFIED:
        return "BROADCAST_ORIGIN_UNSPECIFIED";
      case k.BROADCAST_ORIGIN_API:
        return "BROADCAST_ORIGIN_API";
      case k.BROADCAST_ORIGIN_SOURCE:
        return "BROADCAST_ORIGIN_SOURCE";
      case k.BROADCAST_ORIGIN_EXTERNAL:
        return "BROADCAST_ORIGIN_EXTERNAL";
      case k.BROADCAST_ORIGIN_SYSTEM:
        return "BROADCAST_ORIGIN_SYSTEM";
      default:
        throw new Tt.Error("Unrecognized enum value " + b + " for enum BroadcastOrigin");
    }
  }
  a.broadcastOriginToJSON = L;
  function F(b) {
    switch (b) {
      case k.BROADCAST_ORIGIN_UNSPECIFIED:
        return 0;
      case k.BROADCAST_ORIGIN_API:
        return 1;
      case k.BROADCAST_ORIGIN_SOURCE:
        return 2;
      case k.BROADCAST_ORIGIN_EXTERNAL:
        return 3;
      case k.BROADCAST_ORIGIN_SYSTEM:
        return 4;
      default:
        throw new Tt.Error("Unrecognized enum value " + b + " for enum BroadcastOrigin");
    }
  }
  a.broadcastOriginToNumber = F;
  var V;
  (function(b) {
    b.WEBHOOK_TYPE_UNSPECIFIED = "WEBHOOK_TYPE_UNSPECIFIED", b.WEBHOOK_TYPE_HOOK = "WEBHOOK_TYPE_HOOK", b.WEBHOOK_TYPE_EVENT = "WEBHOOK_TYPE_EVENT";
  })(V = a.WebhookType || (a.WebhookType = {}));
  function X(b) {
    switch (b) {
      case 0:
      case "WEBHOOK_TYPE_UNSPECIFIED":
        return V.WEBHOOK_TYPE_UNSPECIFIED;
      case 1:
      case "WEBHOOK_TYPE_HOOK":
        return V.WEBHOOK_TYPE_HOOK;
      case 2:
      case "WEBHOOK_TYPE_EVENT":
        return V.WEBHOOK_TYPE_EVENT;
      default:
        throw new Tt.Error("Unrecognized enum value " + b + " for enum WebhookType");
    }
  }
  a.webhookTypeFromJSON = X;
  function oe(b) {
    switch (b) {
      case V.WEBHOOK_TYPE_UNSPECIFIED:
        return "WEBHOOK_TYPE_UNSPECIFIED";
      case V.WEBHOOK_TYPE_HOOK:
        return "WEBHOOK_TYPE_HOOK";
      case V.WEBHOOK_TYPE_EVENT:
        return "WEBHOOK_TYPE_EVENT";
      default:
        throw new Tt.Error("Unrecognized enum value " + b + " for enum WebhookType");
    }
  }
  a.webhookTypeToJSON = oe;
  function Y(b) {
    switch (b) {
      case V.WEBHOOK_TYPE_UNSPECIFIED:
        return 0;
      case V.WEBHOOK_TYPE_HOOK:
        return 1;
      case V.WEBHOOK_TYPE_EVENT:
        return 2;
      default:
        throw new Tt.Error("Unrecognized enum value " + b + " for enum WebhookType");
    }
  }
  a.webhookTypeToNumber = Y;
  var ae;
  (function(b) {
    b.WEBHOOK_SUBTYPE_UNSPECIFIED = "WEBHOOK_SUBTYPE_UNSPECIFIED", b.WEBHOOK_SUBTYPE_START_BROADCAST = "WEBHOOK_SUBTYPE_START_BROADCAST", b.WEBHOOK_SUBTYPE_START_WEBRTC = "WEBHOOK_SUBTYPE_START_WEBRTC", b.WEBHOOK_SUBTYPE_JOIN_WEBRTC = "WEBHOOK_SUBTYPE_JOIN_WEBRTC";
  })(ae = a.WebhookSubtype || (a.WebhookSubtype = {}));
  function ne(b) {
    switch (b) {
      case 0:
      case "WEBHOOK_SUBTYPE_UNSPECIFIED":
        return ae.WEBHOOK_SUBTYPE_UNSPECIFIED;
      case 1:
      case "WEBHOOK_SUBTYPE_START_BROADCAST":
        return ae.WEBHOOK_SUBTYPE_START_BROADCAST;
      case 2:
      case "WEBHOOK_SUBTYPE_START_WEBRTC":
        return ae.WEBHOOK_SUBTYPE_START_WEBRTC;
      case 3:
      case "WEBHOOK_SUBTYPE_JOIN_WEBRTC":
        return ae.WEBHOOK_SUBTYPE_JOIN_WEBRTC;
      default:
        throw new Tt.Error("Unrecognized enum value " + b + " for enum WebhookSubtype");
    }
  }
  a.webhookSubtypeFromJSON = ne;
  function fe(b) {
    switch (b) {
      case ae.WEBHOOK_SUBTYPE_UNSPECIFIED:
        return "WEBHOOK_SUBTYPE_UNSPECIFIED";
      case ae.WEBHOOK_SUBTYPE_START_BROADCAST:
        return "WEBHOOK_SUBTYPE_START_BROADCAST";
      case ae.WEBHOOK_SUBTYPE_START_WEBRTC:
        return "WEBHOOK_SUBTYPE_START_WEBRTC";
      case ae.WEBHOOK_SUBTYPE_JOIN_WEBRTC:
        return "WEBHOOK_SUBTYPE_JOIN_WEBRTC";
      default:
        throw new Tt.Error("Unrecognized enum value " + b + " for enum WebhookSubtype");
    }
  }
  a.webhookSubtypeToJSON = fe;
  function ie(b) {
    switch (b) {
      case ae.WEBHOOK_SUBTYPE_UNSPECIFIED:
        return 0;
      case ae.WEBHOOK_SUBTYPE_START_BROADCAST:
        return 1;
      case ae.WEBHOOK_SUBTYPE_START_WEBRTC:
        return 2;
      case ae.WEBHOOK_SUBTYPE_JOIN_WEBRTC:
        return 3;
      default:
        throw new Tt.Error("Unrecognized enum value " + b + " for enum WebhookSubtype");
    }
  }
  a.webhookSubtypeToNumber = ie;
  var ge;
  (function(b) {
    b.IMAGE_FORMAT_UNSPECIFIED = "IMAGE_FORMAT_UNSPECIFIED", b.IMAGE_FORMAT_JPEG = "IMAGE_FORMAT_JPEG";
  })(ge = a.ImageFormat || (a.ImageFormat = {}));
  function be(b) {
    switch (b) {
      case 0:
      case "IMAGE_FORMAT_UNSPECIFIED":
        return ge.IMAGE_FORMAT_UNSPECIFIED;
      case 1:
      case "IMAGE_FORMAT_JPEG":
        return ge.IMAGE_FORMAT_JPEG;
      default:
        throw new Tt.Error("Unrecognized enum value " + b + " for enum ImageFormat");
    }
  }
  a.imageFormatFromJSON = be;
  function Ce(b) {
    switch (b) {
      case ge.IMAGE_FORMAT_UNSPECIFIED:
        return "IMAGE_FORMAT_UNSPECIFIED";
      case ge.IMAGE_FORMAT_JPEG:
        return "IMAGE_FORMAT_JPEG";
      default:
        throw new Tt.Error("Unrecognized enum value " + b + " for enum ImageFormat");
    }
  }
  a.imageFormatToJSON = Ce;
  function Me(b) {
    switch (b) {
      case ge.IMAGE_FORMAT_UNSPECIFIED:
        return 0;
      case ge.IMAGE_FORMAT_JPEG:
        return 1;
      default:
        throw new Tt.Error("Unrecognized enum value " + b + " for enum ImageFormat");
    }
  }
  a.imageFormatToNumber = Me;
  var Be;
  (function(b) {
    b.VIDEO_COLOR_SPACE_UNSPECIFIED = "VIDEO_COLOR_SPACE_UNSPECIFIED", b.VIDEO_COLOR_SPACE_YUV420 = "VIDEO_COLOR_SPACE_YUV420";
  })(Be = a.VideoColorSpace || (a.VideoColorSpace = {}));
  function Ae(b) {
    switch (b) {
      case 0:
      case "VIDEO_COLOR_SPACE_UNSPECIFIED":
        return Be.VIDEO_COLOR_SPACE_UNSPECIFIED;
      case 1:
      case "VIDEO_COLOR_SPACE_YUV420":
        return Be.VIDEO_COLOR_SPACE_YUV420;
      default:
        throw new Tt.Error("Unrecognized enum value " + b + " for enum VideoColorSpace");
    }
  }
  a.videoColorSpaceFromJSON = Ae;
  function Z(b) {
    switch (b) {
      case Be.VIDEO_COLOR_SPACE_UNSPECIFIED:
        return "VIDEO_COLOR_SPACE_UNSPECIFIED";
      case Be.VIDEO_COLOR_SPACE_YUV420:
        return "VIDEO_COLOR_SPACE_YUV420";
      default:
        throw new Tt.Error("Unrecognized enum value " + b + " for enum VideoColorSpace");
    }
  }
  a.videoColorSpaceToJSON = Z;
  function z(b) {
    switch (b) {
      case Be.VIDEO_COLOR_SPACE_UNSPECIFIED:
        return 0;
      case Be.VIDEO_COLOR_SPACE_YUV420:
        return 1;
      default:
        throw new Tt.Error("Unrecognized enum value " + b + " for enum VideoColorSpace");
    }
  }
  a.videoColorSpaceToNumber = z;
  var P;
  (function(b) {
    b.AUDIO_CHANNEL_LAYOUT_UNSPECIFIED = "AUDIO_CHANNEL_LAYOUT_UNSPECIFIED", b.AUDIO_CHANNEL_LAYOUT_STEREO = "AUDIO_CHANNEL_LAYOUT_STEREO";
  })(P = a.AudioChannelLayout || (a.AudioChannelLayout = {}));
  function S(b) {
    switch (b) {
      case 0:
      case "AUDIO_CHANNEL_LAYOUT_UNSPECIFIED":
        return P.AUDIO_CHANNEL_LAYOUT_UNSPECIFIED;
      case 1:
      case "AUDIO_CHANNEL_LAYOUT_STEREO":
        return P.AUDIO_CHANNEL_LAYOUT_STEREO;
      default:
        throw new Tt.Error("Unrecognized enum value " + b + " for enum AudioChannelLayout");
    }
  }
  a.audioChannelLayoutFromJSON = S;
  function E(b) {
    switch (b) {
      case P.AUDIO_CHANNEL_LAYOUT_UNSPECIFIED:
        return "AUDIO_CHANNEL_LAYOUT_UNSPECIFIED";
      case P.AUDIO_CHANNEL_LAYOUT_STEREO:
        return "AUDIO_CHANNEL_LAYOUT_STEREO";
      default:
        throw new Tt.Error("Unrecognized enum value " + b + " for enum AudioChannelLayout");
    }
  }
  a.audioChannelLayoutToJSON = E;
  function I(b) {
    switch (b) {
      case P.AUDIO_CHANNEL_LAYOUT_UNSPECIFIED:
        return 0;
      case P.AUDIO_CHANNEL_LAYOUT_STEREO:
        return 1;
      default:
        throw new Tt.Error("Unrecognized enum value " + b + " for enum AudioChannelLayout");
    }
  }
  a.audioChannelLayoutToNumber = I;
  var N;
  (function(b) {
    b.RENDERING_QUALITY_UNSPECIFIED = "RENDERING_QUALITY_UNSPECIFIED", b.RENDERING_QUALITY_STANDARD = "RENDERING_QUALITY_STANDARD", b.RENDERING_QUALITY_HIGH = "RENDERING_QUALITY_HIGH";
  })(N = a.RenderingQuality || (a.RenderingQuality = {}));
  function $(b) {
    switch (b) {
      case 0:
      case "RENDERING_QUALITY_UNSPECIFIED":
        return N.RENDERING_QUALITY_UNSPECIFIED;
      case 1:
      case "RENDERING_QUALITY_STANDARD":
        return N.RENDERING_QUALITY_STANDARD;
      case 2:
      case "RENDERING_QUALITY_HIGH":
        return N.RENDERING_QUALITY_HIGH;
      default:
        throw new Tt.Error("Unrecognized enum value " + b + " for enum RenderingQuality");
    }
  }
  a.renderingQualityFromJSON = $;
  function U(b) {
    switch (b) {
      case N.RENDERING_QUALITY_UNSPECIFIED:
        return "RENDERING_QUALITY_UNSPECIFIED";
      case N.RENDERING_QUALITY_STANDARD:
        return "RENDERING_QUALITY_STANDARD";
      case N.RENDERING_QUALITY_HIGH:
        return "RENDERING_QUALITY_HIGH";
      default:
        throw new Tt.Error("Unrecognized enum value " + b + " for enum RenderingQuality");
    }
  }
  a.renderingQualityToJSON = U;
  function H(b) {
    switch (b) {
      case N.RENDERING_QUALITY_UNSPECIFIED:
        return 0;
      case N.RENDERING_QUALITY_STANDARD:
        return 1;
      case N.RENDERING_QUALITY_HIGH:
        return 2;
      default:
        throw new Tt.Error("Unrecognized enum value " + b + " for enum RenderingQuality");
    }
  }
  a.renderingQualityToNumber = H;
  var B;
  (function(b) {
    b.VIDEO_CODEC_UNSPECIFIED = "VIDEO_CODEC_UNSPECIFIED", b.VIDEO_CODEC_H264 = "VIDEO_CODEC_H264";
  })(B = a.VideoCodec || (a.VideoCodec = {}));
  function T(b) {
    switch (b) {
      case 0:
      case "VIDEO_CODEC_UNSPECIFIED":
        return B.VIDEO_CODEC_UNSPECIFIED;
      case 1:
      case "VIDEO_CODEC_H264":
        return B.VIDEO_CODEC_H264;
      default:
        throw new Tt.Error("Unrecognized enum value " + b + " for enum VideoCodec");
    }
  }
  a.videoCodecFromJSON = T;
  function D(b) {
    switch (b) {
      case B.VIDEO_CODEC_UNSPECIFIED:
        return "VIDEO_CODEC_UNSPECIFIED";
      case B.VIDEO_CODEC_H264:
        return "VIDEO_CODEC_H264";
      default:
        throw new Tt.Error("Unrecognized enum value " + b + " for enum VideoCodec");
    }
  }
  a.videoCodecToJSON = D;
  function ee(b) {
    switch (b) {
      case B.VIDEO_CODEC_UNSPECIFIED:
        return 0;
      case B.VIDEO_CODEC_H264:
        return 1;
      default:
        throw new Tt.Error("Unrecognized enum value " + b + " for enum VideoCodec");
    }
  }
  a.videoCodecToNumber = ee;
  var pe;
  (function(b) {
    b.VIDEO_CODEC_PROFILE_UNSPECIFIED = "VIDEO_CODEC_PROFILE_UNSPECIFIED", b.VIDEO_CODEC_PROFILE_BASELINE = "VIDEO_CODEC_PROFILE_BASELINE", b.VIDEO_CODEC_PROFILE_MAIN = "VIDEO_CODEC_PROFILE_MAIN", b.VIDEO_CODEC_PROFILE_HIGH = "VIDEO_CODEC_PROFILE_HIGH";
  })(pe = a.VideoCodecProfile || (a.VideoCodecProfile = {}));
  function Ie(b) {
    switch (b) {
      case 0:
      case "VIDEO_CODEC_PROFILE_UNSPECIFIED":
        return pe.VIDEO_CODEC_PROFILE_UNSPECIFIED;
      case 2:
      case "VIDEO_CODEC_PROFILE_BASELINE":
        return pe.VIDEO_CODEC_PROFILE_BASELINE;
      case 3:
      case "VIDEO_CODEC_PROFILE_MAIN":
        return pe.VIDEO_CODEC_PROFILE_MAIN;
      case 4:
      case "VIDEO_CODEC_PROFILE_HIGH":
        return pe.VIDEO_CODEC_PROFILE_HIGH;
      default:
        throw new Tt.Error("Unrecognized enum value " + b + " for enum VideoCodecProfile");
    }
  }
  a.videoCodecProfileFromJSON = Ie;
  function Pe(b) {
    switch (b) {
      case pe.VIDEO_CODEC_PROFILE_UNSPECIFIED:
        return "VIDEO_CODEC_PROFILE_UNSPECIFIED";
      case pe.VIDEO_CODEC_PROFILE_BASELINE:
        return "VIDEO_CODEC_PROFILE_BASELINE";
      case pe.VIDEO_CODEC_PROFILE_MAIN:
        return "VIDEO_CODEC_PROFILE_MAIN";
      case pe.VIDEO_CODEC_PROFILE_HIGH:
        return "VIDEO_CODEC_PROFILE_HIGH";
      default:
        throw new Tt.Error("Unrecognized enum value " + b + " for enum VideoCodecProfile");
    }
  }
  a.videoCodecProfileToJSON = Pe;
  function he(b) {
    switch (b) {
      case pe.VIDEO_CODEC_PROFILE_UNSPECIFIED:
        return 0;
      case pe.VIDEO_CODEC_PROFILE_BASELINE:
        return 2;
      case pe.VIDEO_CODEC_PROFILE_MAIN:
        return 3;
      case pe.VIDEO_CODEC_PROFILE_HIGH:
        return 4;
      default:
        throw new Tt.Error("Unrecognized enum value " + b + " for enum VideoCodecProfile");
    }
  }
  a.videoCodecProfileToNumber = he;
  var ve;
  (function(b) {
    b.AUDIO_CODEC_UNSPECIFIED = "AUDIO_CODEC_UNSPECIFIED", b.AUDIO_CODEC_AAC = "AUDIO_CODEC_AAC";
  })(ve = a.AudioCodec || (a.AudioCodec = {}));
  function Q(b) {
    switch (b) {
      case 0:
      case "AUDIO_CODEC_UNSPECIFIED":
        return ve.AUDIO_CODEC_UNSPECIFIED;
      case 1:
      case "AUDIO_CODEC_AAC":
        return ve.AUDIO_CODEC_AAC;
      default:
        throw new Tt.Error("Unrecognized enum value " + b + " for enum AudioCodec");
    }
  }
  a.audioCodecFromJSON = Q;
  function le(b) {
    switch (b) {
      case ve.AUDIO_CODEC_UNSPECIFIED:
        return "AUDIO_CODEC_UNSPECIFIED";
      case ve.AUDIO_CODEC_AAC:
        return "AUDIO_CODEC_AAC";
      default:
        throw new Tt.Error("Unrecognized enum value " + b + " for enum AudioCodec");
    }
  }
  a.audioCodecToJSON = le;
  function _e(b) {
    switch (b) {
      case ve.AUDIO_CODEC_UNSPECIFIED:
        return 0;
      case ve.AUDIO_CODEC_AAC:
        return 1;
      default:
        throw new Tt.Error("Unrecognized enum value " + b + " for enum AudioCodec");
    }
  }
  a.audioCodecToNumber = _e;
  var re;
  (function(b) {
    b.VIDEO_CODEC_RATE_CONTROL_MODE_UNSPECIFIED = "VIDEO_CODEC_RATE_CONTROL_MODE_UNSPECIFIED", b.VIDEO_CODEC_RATE_CONTROL_MODE_CBR = "VIDEO_CODEC_RATE_CONTROL_MODE_CBR";
  })(re = a.VideoCodecRateControlMode || (a.VideoCodecRateControlMode = {}));
  function O(b) {
    switch (b) {
      case 0:
      case "VIDEO_CODEC_RATE_CONTROL_MODE_UNSPECIFIED":
        return re.VIDEO_CODEC_RATE_CONTROL_MODE_UNSPECIFIED;
      case 1:
      case "VIDEO_CODEC_RATE_CONTROL_MODE_CBR":
        return re.VIDEO_CODEC_RATE_CONTROL_MODE_CBR;
      default:
        throw new Tt.Error("Unrecognized enum value " + b + " for enum VideoCodecRateControlMode");
    }
  }
  a.videoCodecRateControlModeFromJSON = O;
  function j(b) {
    switch (b) {
      case re.VIDEO_CODEC_RATE_CONTROL_MODE_UNSPECIFIED:
        return "VIDEO_CODEC_RATE_CONTROL_MODE_UNSPECIFIED";
      case re.VIDEO_CODEC_RATE_CONTROL_MODE_CBR:
        return "VIDEO_CODEC_RATE_CONTROL_MODE_CBR";
      default:
        throw new Tt.Error("Unrecognized enum value " + b + " for enum VideoCodecRateControlMode");
    }
  }
  a.videoCodecRateControlModeToJSON = j;
  function ce(b) {
    switch (b) {
      case re.VIDEO_CODEC_RATE_CONTROL_MODE_UNSPECIFIED:
        return 0;
      case re.VIDEO_CODEC_RATE_CONTROL_MODE_CBR:
        return 1;
      default:
        throw new Tt.Error("Unrecognized enum value " + b + " for enum VideoCodecRateControlMode");
    }
  }
  a.videoCodecRateControlModeToNumber = ce;
  var De;
  (function(b) {
    b.PROJECT_BROADCAST_PHASE_UNSPECIFIED = "PROJECT_BROADCAST_PHASE_UNSPECIFIED", b.PROJECT_BROADCAST_PHASE_NOT_RUNNING = "PROJECT_BROADCAST_PHASE_NOT_RUNNING", b.PROJECT_BROADCAST_PHASE_WAITING = "PROJECT_BROADCAST_PHASE_WAITING", b.PROJECT_BROADCAST_PHASE_STARTING = "PROJECT_BROADCAST_PHASE_STARTING", b.PROJECT_BROADCAST_PHASE_RUNNING = "PROJECT_BROADCAST_PHASE_RUNNING", b.PROJECT_BROADCAST_PHASE_STOPPING = "PROJECT_BROADCAST_PHASE_STOPPING", b.PROJECT_BROADCAST_PHASE_STOPPED = "PROJECT_BROADCAST_PHASE_STOPPED", b.PROJECT_BROADCAST_PHASE_ARCHIVED = "PROJECT_BROADCAST_PHASE_ARCHIVED";
  })(De = a.ProjectBroadcastPhase || (a.ProjectBroadcastPhase = {}));
  function Ne(b) {
    switch (b) {
      case 0:
      case "PROJECT_BROADCAST_PHASE_UNSPECIFIED":
        return De.PROJECT_BROADCAST_PHASE_UNSPECIFIED;
      case 1:
      case "PROJECT_BROADCAST_PHASE_NOT_RUNNING":
        return De.PROJECT_BROADCAST_PHASE_NOT_RUNNING;
      case 2:
      case "PROJECT_BROADCAST_PHASE_WAITING":
        return De.PROJECT_BROADCAST_PHASE_WAITING;
      case 3:
      case "PROJECT_BROADCAST_PHASE_STARTING":
        return De.PROJECT_BROADCAST_PHASE_STARTING;
      case 4:
      case "PROJECT_BROADCAST_PHASE_RUNNING":
        return De.PROJECT_BROADCAST_PHASE_RUNNING;
      case 5:
      case "PROJECT_BROADCAST_PHASE_STOPPING":
        return De.PROJECT_BROADCAST_PHASE_STOPPING;
      case 6:
      case "PROJECT_BROADCAST_PHASE_STOPPED":
        return De.PROJECT_BROADCAST_PHASE_STOPPED;
      case 7:
      case "PROJECT_BROADCAST_PHASE_ARCHIVED":
        return De.PROJECT_BROADCAST_PHASE_ARCHIVED;
      default:
        throw new Tt.Error("Unrecognized enum value " + b + " for enum ProjectBroadcastPhase");
    }
  }
  a.projectBroadcastPhaseFromJSON = Ne;
  function Fe(b) {
    switch (b) {
      case De.PROJECT_BROADCAST_PHASE_UNSPECIFIED:
        return "PROJECT_BROADCAST_PHASE_UNSPECIFIED";
      case De.PROJECT_BROADCAST_PHASE_NOT_RUNNING:
        return "PROJECT_BROADCAST_PHASE_NOT_RUNNING";
      case De.PROJECT_BROADCAST_PHASE_WAITING:
        return "PROJECT_BROADCAST_PHASE_WAITING";
      case De.PROJECT_BROADCAST_PHASE_STARTING:
        return "PROJECT_BROADCAST_PHASE_STARTING";
      case De.PROJECT_BROADCAST_PHASE_RUNNING:
        return "PROJECT_BROADCAST_PHASE_RUNNING";
      case De.PROJECT_BROADCAST_PHASE_STOPPING:
        return "PROJECT_BROADCAST_PHASE_STOPPING";
      case De.PROJECT_BROADCAST_PHASE_STOPPED:
        return "PROJECT_BROADCAST_PHASE_STOPPED";
      case De.PROJECT_BROADCAST_PHASE_ARCHIVED:
        return "PROJECT_BROADCAST_PHASE_ARCHIVED";
      default:
        throw new Tt.Error("Unrecognized enum value " + b + " for enum ProjectBroadcastPhase");
    }
  }
  a.projectBroadcastPhaseToJSON = Fe;
  function Ze(b) {
    switch (b) {
      case De.PROJECT_BROADCAST_PHASE_UNSPECIFIED:
        return 0;
      case De.PROJECT_BROADCAST_PHASE_NOT_RUNNING:
        return 1;
      case De.PROJECT_BROADCAST_PHASE_WAITING:
        return 2;
      case De.PROJECT_BROADCAST_PHASE_STARTING:
        return 3;
      case De.PROJECT_BROADCAST_PHASE_RUNNING:
        return 4;
      case De.PROJECT_BROADCAST_PHASE_STOPPING:
        return 5;
      case De.PROJECT_BROADCAST_PHASE_STOPPED:
        return 6;
      case De.PROJECT_BROADCAST_PHASE_ARCHIVED:
        return 7;
      default:
        throw new Tt.Error("Unrecognized enum value " + b + " for enum ProjectBroadcastPhase");
    }
  }
  a.projectBroadcastPhaseToNumber = Ze;
  var qe;
  (function(b) {
    b.S3ACL_UNSPECIFIED = "S3ACL_UNSPECIFIED", b.S3ACL_PRIVATE = "S3ACL_PRIVATE", b.S3ACL_PUBLIC_READ = "S3ACL_PUBLIC_READ", b.S3ACL_PUBLIC_READ_WRITE = "S3ACL_PUBLIC_READ_WRITE", b.S3ACL_AUTHENTICATED_READ = "S3ACL_AUTHENTICATED_READ", b.S3ACL_BUCKET_OWNER_READ = "S3ACL_BUCKET_OWNER_READ", b.S3ACL_BUCKET_OWNER_FULL_CONTROL = "S3ACL_BUCKET_OWNER_FULL_CONTROL";
  })(qe = a.S3ACL || (a.S3ACL = {}));
  function gt(b) {
    switch (b) {
      case 0:
      case "S3ACL_UNSPECIFIED":
        return qe.S3ACL_UNSPECIFIED;
      case 1:
      case "S3ACL_PRIVATE":
        return qe.S3ACL_PRIVATE;
      case 2:
      case "S3ACL_PUBLIC_READ":
        return qe.S3ACL_PUBLIC_READ;
      case 3:
      case "S3ACL_PUBLIC_READ_WRITE":
        return qe.S3ACL_PUBLIC_READ_WRITE;
      case 4:
      case "S3ACL_AUTHENTICATED_READ":
        return qe.S3ACL_AUTHENTICATED_READ;
      case 5:
      case "S3ACL_BUCKET_OWNER_READ":
        return qe.S3ACL_BUCKET_OWNER_READ;
      case 6:
      case "S3ACL_BUCKET_OWNER_FULL_CONTROL":
        return qe.S3ACL_BUCKET_OWNER_FULL_CONTROL;
      default:
        throw new Tt.Error("Unrecognized enum value " + b + " for enum S3ACL");
    }
  }
  a.s3ACLFromJSON = gt;
  function Xe(b) {
    switch (b) {
      case qe.S3ACL_UNSPECIFIED:
        return "S3ACL_UNSPECIFIED";
      case qe.S3ACL_PRIVATE:
        return "S3ACL_PRIVATE";
      case qe.S3ACL_PUBLIC_READ:
        return "S3ACL_PUBLIC_READ";
      case qe.S3ACL_PUBLIC_READ_WRITE:
        return "S3ACL_PUBLIC_READ_WRITE";
      case qe.S3ACL_AUTHENTICATED_READ:
        return "S3ACL_AUTHENTICATED_READ";
      case qe.S3ACL_BUCKET_OWNER_READ:
        return "S3ACL_BUCKET_OWNER_READ";
      case qe.S3ACL_BUCKET_OWNER_FULL_CONTROL:
        return "S3ACL_BUCKET_OWNER_FULL_CONTROL";
      default:
        throw new Tt.Error("Unrecognized enum value " + b + " for enum S3ACL");
    }
  }
  a.s3ACLToJSON = Xe;
  function Ge(b) {
    switch (b) {
      case qe.S3ACL_UNSPECIFIED:
        return 0;
      case qe.S3ACL_PRIVATE:
        return 1;
      case qe.S3ACL_PUBLIC_READ:
        return 2;
      case qe.S3ACL_PUBLIC_READ_WRITE:
        return 3;
      case qe.S3ACL_AUTHENTICATED_READ:
        return 4;
      case qe.S3ACL_BUCKET_OWNER_READ:
        return 5;
      case qe.S3ACL_BUCKET_OWNER_FULL_CONTROL:
        return 6;
      default:
        throw new Tt.Error("Unrecognized enum value " + b + " for enum S3ACL");
    }
  }
  a.s3ACLToNumber = Ge;
  var J;
  (function(b) {
    b.SOURCE_TRIGGER_ACTION_UNSPECIFIED = "SOURCE_TRIGGER_ACTION_UNSPECIFIED", b.SOURCE_TRIGGER_ACTION_IGNORE = "SOURCE_TRIGGER_ACTION_IGNORE", b.SOURCE_TRIGGER_ACTION_OR = "SOURCE_TRIGGER_ACTION_OR";
  })(J = a.SourceTriggerAction || (a.SourceTriggerAction = {}));
  function ye(b) {
    switch (b) {
      case 0:
      case "SOURCE_TRIGGER_ACTION_UNSPECIFIED":
        return J.SOURCE_TRIGGER_ACTION_UNSPECIFIED;
      case 1:
      case "SOURCE_TRIGGER_ACTION_IGNORE":
        return J.SOURCE_TRIGGER_ACTION_IGNORE;
      case 3:
      case "SOURCE_TRIGGER_ACTION_OR":
        return J.SOURCE_TRIGGER_ACTION_OR;
      default:
        throw new Tt.Error("Unrecognized enum value " + b + " for enum SourceTriggerAction");
    }
  }
  a.sourceTriggerActionFromJSON = ye;
  function we(b) {
    switch (b) {
      case J.SOURCE_TRIGGER_ACTION_UNSPECIFIED:
        return "SOURCE_TRIGGER_ACTION_UNSPECIFIED";
      case J.SOURCE_TRIGGER_ACTION_IGNORE:
        return "SOURCE_TRIGGER_ACTION_IGNORE";
      case J.SOURCE_TRIGGER_ACTION_OR:
        return "SOURCE_TRIGGER_ACTION_OR";
      default:
        throw new Tt.Error("Unrecognized enum value " + b + " for enum SourceTriggerAction");
    }
  }
  a.sourceTriggerActionToJSON = we;
  function We(b) {
    switch (b) {
      case J.SOURCE_TRIGGER_ACTION_UNSPECIFIED:
        return 0;
      case J.SOURCE_TRIGGER_ACTION_IGNORE:
        return 1;
      case J.SOURCE_TRIGGER_ACTION_OR:
        return 3;
      default:
        throw new Tt.Error("Unrecognized enum value " + b + " for enum SourceTriggerAction");
    }
  }
  a.sourceTriggerActionToNumber = We;
  var Re;
  (function(b) {
    b.REGION_UNSPECIFIED = "REGION_UNSPECIFIED", b.REGION_US_EAST_1 = "REGION_US_EAST_1", b.REGION_US_EAST_2 = "REGION_US_EAST_2", b.REGION_US_WEST_1 = "REGION_US_WEST_1", b.REGION_US_WEST_2 = "REGION_US_WEST_2", b.REGION_US_CENTRAL_1 = "REGION_US_CENTRAL_1", b.REGION_AP_SOUTHEAST_1 = "REGION_AP_SOUTHEAST_1", b.REGION_AP_SOUTHEAST_2 = "REGION_AP_SOUTHEAST_2", b.REGION_AP_SOUTH_1 = "REGION_AP_SOUTH_1", b.REGION_CA_EAST_1 = "REGION_CA_EAST_1", b.REGION_EU_CENTRAL_1 = "REGION_EU_CENTRAL_1", b.REGION_EU_WEST_1 = "REGION_EU_WEST_1";
  })(Re = a.Region || (a.Region = {}));
  function q(b) {
    switch (b) {
      case 0:
      case "REGION_UNSPECIFIED":
        return Re.REGION_UNSPECIFIED;
      case 1:
      case "REGION_US_EAST_1":
        return Re.REGION_US_EAST_1;
      case 2:
      case "REGION_US_EAST_2":
        return Re.REGION_US_EAST_2;
      case 3:
      case "REGION_US_WEST_1":
        return Re.REGION_US_WEST_1;
      case 4:
      case "REGION_US_WEST_2":
        return Re.REGION_US_WEST_2;
      case 5:
      case "REGION_US_CENTRAL_1":
        return Re.REGION_US_CENTRAL_1;
      case 10:
      case "REGION_AP_SOUTHEAST_1":
        return Re.REGION_AP_SOUTHEAST_1;
      case 11:
      case "REGION_AP_SOUTHEAST_2":
        return Re.REGION_AP_SOUTHEAST_2;
      case 15:
      case "REGION_AP_SOUTH_1":
        return Re.REGION_AP_SOUTH_1;
      case 20:
      case "REGION_CA_EAST_1":
        return Re.REGION_CA_EAST_1;
      case 30:
      case "REGION_EU_CENTRAL_1":
        return Re.REGION_EU_CENTRAL_1;
      case 31:
      case "REGION_EU_WEST_1":
        return Re.REGION_EU_WEST_1;
      default:
        throw new Tt.Error("Unrecognized enum value " + b + " for enum Region");
    }
  }
  a.regionFromJSON = q;
  function ke(b) {
    switch (b) {
      case Re.REGION_UNSPECIFIED:
        return "REGION_UNSPECIFIED";
      case Re.REGION_US_EAST_1:
        return "REGION_US_EAST_1";
      case Re.REGION_US_EAST_2:
        return "REGION_US_EAST_2";
      case Re.REGION_US_WEST_1:
        return "REGION_US_WEST_1";
      case Re.REGION_US_WEST_2:
        return "REGION_US_WEST_2";
      case Re.REGION_US_CENTRAL_1:
        return "REGION_US_CENTRAL_1";
      case Re.REGION_AP_SOUTHEAST_1:
        return "REGION_AP_SOUTHEAST_1";
      case Re.REGION_AP_SOUTHEAST_2:
        return "REGION_AP_SOUTHEAST_2";
      case Re.REGION_AP_SOUTH_1:
        return "REGION_AP_SOUTH_1";
      case Re.REGION_CA_EAST_1:
        return "REGION_CA_EAST_1";
      case Re.REGION_EU_CENTRAL_1:
        return "REGION_EU_CENTRAL_1";
      case Re.REGION_EU_WEST_1:
        return "REGION_EU_WEST_1";
      default:
        throw new Tt.Error("Unrecognized enum value " + b + " for enum Region");
    }
  }
  a.regionToJSON = ke;
  function de(b) {
    switch (b) {
      case Re.REGION_UNSPECIFIED:
        return 0;
      case Re.REGION_US_EAST_1:
        return 1;
      case Re.REGION_US_EAST_2:
        return 2;
      case Re.REGION_US_WEST_1:
        return 3;
      case Re.REGION_US_WEST_2:
        return 4;
      case Re.REGION_US_CENTRAL_1:
        return 5;
      case Re.REGION_AP_SOUTHEAST_1:
        return 10;
      case Re.REGION_AP_SOUTHEAST_2:
        return 11;
      case Re.REGION_AP_SOUTH_1:
        return 15;
      case Re.REGION_CA_EAST_1:
        return 20;
      case Re.REGION_EU_CENTRAL_1:
        return 30;
      case Re.REGION_EU_WEST_1:
        return 31;
      default:
        throw new Tt.Error("Unrecognized enum value " + b + " for enum Region");
    }
  }
  a.regionToNumber = de;
  var ue;
  (function(b) {
    b.ROLE_UNSPECIFIED = "ROLE_UNSPECIFIED", b.ROLE_HOST = "ROLE_HOST", b.ROLE_COHOST = "ROLE_COHOST", b.ROLE_CONTRIBUTOR = "ROLE_CONTRIBUTOR", b.ROLE_GUEST = "ROLE_GUEST", b.ROLE_VIEWER = "ROLE_VIEWER", b.ROLE_RENDERER = "ROLE_RENDERER", b.ROLE_PLATFORM = "ROLE_PLATFORM", b.ROLE_IMPERSONATE = "ROLE_IMPERSONATE";
  })(ue = a.Role || (a.Role = {}));
  function me(b) {
    switch (b) {
      case 0:
      case "ROLE_UNSPECIFIED":
        return ue.ROLE_UNSPECIFIED;
      case 1:
      case "ROLE_HOST":
        return ue.ROLE_HOST;
      case 2:
      case "ROLE_COHOST":
        return ue.ROLE_COHOST;
      case 3:
      case "ROLE_CONTRIBUTOR":
        return ue.ROLE_CONTRIBUTOR;
      case 4:
      case "ROLE_GUEST":
        return ue.ROLE_GUEST;
      case 5:
      case "ROLE_VIEWER":
        return ue.ROLE_VIEWER;
      case 6:
      case "ROLE_RENDERER":
        return ue.ROLE_RENDERER;
      case 7:
      case "ROLE_PLATFORM":
        return ue.ROLE_PLATFORM;
      case 8:
      case "ROLE_IMPERSONATE":
        return ue.ROLE_IMPERSONATE;
      default:
        throw new Tt.Error("Unrecognized enum value " + b + " for enum Role");
    }
  }
  a.roleFromJSON = me;
  function Oe(b) {
    switch (b) {
      case ue.ROLE_UNSPECIFIED:
        return "ROLE_UNSPECIFIED";
      case ue.ROLE_HOST:
        return "ROLE_HOST";
      case ue.ROLE_COHOST:
        return "ROLE_COHOST";
      case ue.ROLE_CONTRIBUTOR:
        return "ROLE_CONTRIBUTOR";
      case ue.ROLE_GUEST:
        return "ROLE_GUEST";
      case ue.ROLE_VIEWER:
        return "ROLE_VIEWER";
      case ue.ROLE_RENDERER:
        return "ROLE_RENDERER";
      case ue.ROLE_PLATFORM:
        return "ROLE_PLATFORM";
      case ue.ROLE_IMPERSONATE:
        return "ROLE_IMPERSONATE";
      default:
        throw new Tt.Error("Unrecognized enum value " + b + " for enum Role");
    }
  }
  a.roleToJSON = Oe;
  function Ue(b) {
    switch (b) {
      case ue.ROLE_UNSPECIFIED:
        return 0;
      case ue.ROLE_HOST:
        return 1;
      case ue.ROLE_COHOST:
        return 2;
      case ue.ROLE_CONTRIBUTOR:
        return 3;
      case ue.ROLE_GUEST:
        return 4;
      case ue.ROLE_VIEWER:
        return 5;
      case ue.ROLE_RENDERER:
        return 6;
      case ue.ROLE_PLATFORM:
        return 7;
      case ue.ROLE_IMPERSONATE:
        return 8;
      default:
        throw new Tt.Error("Unrecognized enum value " + b + " for enum Role");
    }
  }
  a.roleToNumber = Ue;
  var ze;
  (function(b) {
    b.PROJECT_BROADCAST_ERROR_UNSPECIFIED = "PROJECT_BROADCAST_ERROR_UNSPECIFIED", b.PROJECT_BROADCAST_ERROR_INTERNAL = "PROJECT_BROADCAST_ERROR_INTERNAL", b.PROJECT_BROADCAST_ERROR_DURATION_EXCEEDED = "PROJECT_BROADCAST_ERROR_DURATION_EXCEEDED";
  })(ze = a.ProjectBroadcastError || (a.ProjectBroadcastError = {}));
  function Ve(b) {
    switch (b) {
      case 0:
      case "PROJECT_BROADCAST_ERROR_UNSPECIFIED":
        return ze.PROJECT_BROADCAST_ERROR_UNSPECIFIED;
      case 1:
      case "PROJECT_BROADCAST_ERROR_INTERNAL":
        return ze.PROJECT_BROADCAST_ERROR_INTERNAL;
      case 2:
      case "PROJECT_BROADCAST_ERROR_DURATION_EXCEEDED":
        return ze.PROJECT_BROADCAST_ERROR_DURATION_EXCEEDED;
      default:
        throw new Tt.Error("Unrecognized enum value " + b + " for enum ProjectBroadcastError");
    }
  }
  a.projectBroadcastErrorFromJSON = Ve;
  function Qe(b) {
    switch (b) {
      case ze.PROJECT_BROADCAST_ERROR_UNSPECIFIED:
        return "PROJECT_BROADCAST_ERROR_UNSPECIFIED";
      case ze.PROJECT_BROADCAST_ERROR_INTERNAL:
        return "PROJECT_BROADCAST_ERROR_INTERNAL";
      case ze.PROJECT_BROADCAST_ERROR_DURATION_EXCEEDED:
        return "PROJECT_BROADCAST_ERROR_DURATION_EXCEEDED";
      default:
        throw new Tt.Error("Unrecognized enum value " + b + " for enum ProjectBroadcastError");
    }
  }
  a.projectBroadcastErrorToJSON = Qe;
  function Ke(b) {
    switch (b) {
      case ze.PROJECT_BROADCAST_ERROR_UNSPECIFIED:
        return 0;
      case ze.PROJECT_BROADCAST_ERROR_INTERNAL:
        return 1;
      case ze.PROJECT_BROADCAST_ERROR_DURATION_EXCEEDED:
        return 2;
      default:
        throw new Tt.Error("Unrecognized enum value " + b + " for enum ProjectBroadcastError");
    }
  }
  a.projectBroadcastErrorToNumber = Ke;
  var x;
  (function(b) {
    b.CONNECT_STATE_UNSPECIFIED = "CONNECT_STATE_UNSPECIFIED", b.CONNECT_STATE_CONNECTED = "CONNECT_STATE_CONNECTED", b.CONNECT_STATE_DISCONNECTED = "CONNECT_STATE_DISCONNECTED";
  })(x = a.ConnectState || (a.ConnectState = {}));
  function se(b) {
    switch (b) {
      case 0:
      case "CONNECT_STATE_UNSPECIFIED":
        return x.CONNECT_STATE_UNSPECIFIED;
      case 1:
      case "CONNECT_STATE_CONNECTED":
        return x.CONNECT_STATE_CONNECTED;
      case 2:
      case "CONNECT_STATE_DISCONNECTED":
        return x.CONNECT_STATE_DISCONNECTED;
      default:
        throw new Tt.Error("Unrecognized enum value " + b + " for enum ConnectState");
    }
  }
  a.connectStateFromJSON = se;
  function Ee(b) {
    switch (b) {
      case x.CONNECT_STATE_UNSPECIFIED:
        return "CONNECT_STATE_UNSPECIFIED";
      case x.CONNECT_STATE_CONNECTED:
        return "CONNECT_STATE_CONNECTED";
      case x.CONNECT_STATE_DISCONNECTED:
        return "CONNECT_STATE_DISCONNECTED";
      default:
        throw new Tt.Error("Unrecognized enum value " + b + " for enum ConnectState");
    }
  }
  a.connectStateToJSON = Ee;
  function xe(b) {
    switch (b) {
      case x.CONNECT_STATE_UNSPECIFIED:
        return 0;
      case x.CONNECT_STATE_CONNECTED:
        return 1;
      case x.CONNECT_STATE_DISCONNECTED:
        return 2;
      default:
        throw new Tt.Error("Unrecognized enum value " + b + " for enum ConnectState");
    }
  }
  a.connectStateToNumber = xe;
  var $e;
  (function(b) {
    b.EVENT_SUB_TYPE_UNSPECIFIED = "EVENT_SUB_TYPE_UNSPECIFIED", b.EVENT_SUB_TYPE_CREATE = "EVENT_SUB_TYPE_CREATE", b.EVENT_SUB_TYPE_UPDATE = "EVENT_SUB_TYPE_UPDATE", b.EVENT_SUB_TYPE_DELETE = "EVENT_SUB_TYPE_DELETE", b.EVENT_SUB_TYPE_ADD = "EVENT_SUB_TYPE_ADD", b.EVENT_SUB_TYPE_REMOVE = "EVENT_SUB_TYPE_REMOVE", b.EVENT_SUB_TYPE_STATE = "EVENT_SUB_TYPE_STATE";
  })($e = a.EventSubType || (a.EventSubType = {}));
  function Ye(b) {
    switch (b) {
      case 0:
      case "EVENT_SUB_TYPE_UNSPECIFIED":
        return $e.EVENT_SUB_TYPE_UNSPECIFIED;
      case 1:
      case "EVENT_SUB_TYPE_CREATE":
        return $e.EVENT_SUB_TYPE_CREATE;
      case 2:
      case "EVENT_SUB_TYPE_UPDATE":
        return $e.EVENT_SUB_TYPE_UPDATE;
      case 3:
      case "EVENT_SUB_TYPE_DELETE":
        return $e.EVENT_SUB_TYPE_DELETE;
      case 4:
      case "EVENT_SUB_TYPE_ADD":
        return $e.EVENT_SUB_TYPE_ADD;
      case 5:
      case "EVENT_SUB_TYPE_REMOVE":
        return $e.EVENT_SUB_TYPE_REMOVE;
      case 6:
      case "EVENT_SUB_TYPE_STATE":
        return $e.EVENT_SUB_TYPE_STATE;
      default:
        throw new Tt.Error("Unrecognized enum value " + b + " for enum EventSubType");
    }
  }
  a.eventSubTypeFromJSON = Ye;
  function et(b) {
    switch (b) {
      case $e.EVENT_SUB_TYPE_UNSPECIFIED:
        return "EVENT_SUB_TYPE_UNSPECIFIED";
      case $e.EVENT_SUB_TYPE_CREATE:
        return "EVENT_SUB_TYPE_CREATE";
      case $e.EVENT_SUB_TYPE_UPDATE:
        return "EVENT_SUB_TYPE_UPDATE";
      case $e.EVENT_SUB_TYPE_DELETE:
        return "EVENT_SUB_TYPE_DELETE";
      case $e.EVENT_SUB_TYPE_ADD:
        return "EVENT_SUB_TYPE_ADD";
      case $e.EVENT_SUB_TYPE_REMOVE:
        return "EVENT_SUB_TYPE_REMOVE";
      case $e.EVENT_SUB_TYPE_STATE:
        return "EVENT_SUB_TYPE_STATE";
      default:
        throw new Tt.Error("Unrecognized enum value " + b + " for enum EventSubType");
    }
  }
  a.eventSubTypeToJSON = et;
  function dt(b) {
    switch (b) {
      case $e.EVENT_SUB_TYPE_UNSPECIFIED:
        return 0;
      case $e.EVENT_SUB_TYPE_CREATE:
        return 1;
      case $e.EVENT_SUB_TYPE_UPDATE:
        return 2;
      case $e.EVENT_SUB_TYPE_DELETE:
        return 3;
      case $e.EVENT_SUB_TYPE_ADD:
        return 4;
      case $e.EVENT_SUB_TYPE_REMOVE:
        return 5;
      case $e.EVENT_SUB_TYPE_STATE:
        return 6;
      default:
        throw new Tt.Error("Unrecognized enum value " + b + " for enum EventSubType");
    }
  }
  a.eventSubTypeToNumber = dt;
  var St;
  (function(b) {
    b.EVENT_TYPE_UNSPECIFIED = "EVENT_TYPE_UNSPECIFIED", b.EVENT_TYPE_COLLECTION = "EVENT_TYPE_COLLECTION", b.EVENT_TYPE_PROJECT = "EVENT_TYPE_PROJECT", b.EVENT_TYPE_SOURCE = "EVENT_TYPE_SOURCE", b.EVENT_TYPE_DESTINATION = "EVENT_TYPE_DESTINATION";
  })(St = a.EventType || (a.EventType = {}));
  function tt(b) {
    switch (b) {
      case 0:
      case "EVENT_TYPE_UNSPECIFIED":
        return St.EVENT_TYPE_UNSPECIFIED;
      case 1:
      case "EVENT_TYPE_COLLECTION":
        return St.EVENT_TYPE_COLLECTION;
      case 2:
      case "EVENT_TYPE_PROJECT":
        return St.EVENT_TYPE_PROJECT;
      case 4:
      case "EVENT_TYPE_SOURCE":
        return St.EVENT_TYPE_SOURCE;
      case 5:
      case "EVENT_TYPE_DESTINATION":
        return St.EVENT_TYPE_DESTINATION;
      default:
        throw new Tt.Error("Unrecognized enum value " + b + " for enum EventType");
    }
  }
  a.eventTypeFromJSON = tt;
  function at(b) {
    switch (b) {
      case St.EVENT_TYPE_UNSPECIFIED:
        return "EVENT_TYPE_UNSPECIFIED";
      case St.EVENT_TYPE_COLLECTION:
        return "EVENT_TYPE_COLLECTION";
      case St.EVENT_TYPE_PROJECT:
        return "EVENT_TYPE_PROJECT";
      case St.EVENT_TYPE_SOURCE:
        return "EVENT_TYPE_SOURCE";
      case St.EVENT_TYPE_DESTINATION:
        return "EVENT_TYPE_DESTINATION";
      default:
        throw new Tt.Error("Unrecognized enum value " + b + " for enum EventType");
    }
  }
  a.eventTypeToJSON = at;
  function wt(b) {
    switch (b) {
      case St.EVENT_TYPE_UNSPECIFIED:
        return 0;
      case St.EVENT_TYPE_COLLECTION:
        return 1;
      case St.EVENT_TYPE_PROJECT:
        return 2;
      case St.EVENT_TYPE_SOURCE:
        return 4;
      case St.EVENT_TYPE_DESTINATION:
        return 5;
      default:
        throw new Tt.Error("Unrecognized enum value " + b + " for enum EventType");
    }
  }
  a.eventTypeToNumber = wt;
  function rt() {
    return { name: "", value: void 0 };
  }
  a.BroadcastOriginExternalMetadata = {
    encode(b, C = c.default.Writer.create()) {
      return b.name !== "" && C.uint32(10).string(b.name), b.value !== void 0 && p.Value.encode(p.Value.wrap(b.value), C.uint32(18).fork()).ldelim(), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = rt();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.name = A.string();
            break;
          case 2:
            te.value = p.Value.unwrap(p.Value.decode(A, A.uint32()));
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        name: Le(b.name) ? String(b.name) : "",
        value: Le(b == null ? void 0 : b.value) ? b.value : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.name !== void 0 && (C.name = b.name), b.value !== void 0 && (C.value = b.value), C;
    },
    fromPartial(b) {
      var C, A;
      const Se = rt();
      return Se.name = (C = b.name) !== null && C !== void 0 ? C : "", Se.value = (A = b.value) !== null && A !== void 0 ? A : void 0, Se;
    }
  };
  function ut() {
    return {};
  }
  a.BroadcastOriginSourceMetadata = {
    encode(b, C = c.default.Writer.create()) {
      return C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = ut();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {};
    },
    toJSON(b) {
      return {};
    },
    fromPartial(b) {
      return ut();
    }
  };
  function kt() {
    return {
      userId: "",
      collectionId: "",
      projectId: "",
      broadcastOrigin: void 0,
      broadcastOriginApiMetadata: void 0,
      broadcastOriginSourceMetadata: void 0,
      broadcastOriginExternalMetadata: void 0
    };
  }
  a.WebhookRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.userId !== "" && C.uint32(10).string(b.userId), b.collectionId !== "" && C.uint32(18).string(b.collectionId), b.projectId !== "" && C.uint32(26).string(b.projectId), b.broadcastOrigin !== void 0 && C.uint32(56).int32(F(b.broadcastOrigin)), b.broadcastOriginApiMetadata !== void 0 && p.Value.encode(p.Value.wrap(b.broadcastOriginApiMetadata), C.uint32(66).fork()).ldelim(), b.broadcastOriginSourceMetadata !== void 0 && a.BroadcastOriginSourceMetadata.encode(b.broadcastOriginSourceMetadata, C.uint32(74).fork()).ldelim(), b.broadcastOriginExternalMetadata !== void 0 && a.BroadcastOriginExternalMetadata.encode(b.broadcastOriginExternalMetadata, C.uint32(82).fork()).ldelim(), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = kt();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.userId = A.string();
            break;
          case 2:
            te.collectionId = A.string();
            break;
          case 3:
            te.projectId = A.string();
            break;
          case 7:
            te.broadcastOrigin = M(A.int32());
            break;
          case 8:
            te.broadcastOriginApiMetadata = p.Value.unwrap(p.Value.decode(A, A.uint32()));
            break;
          case 9:
            te.broadcastOriginSourceMetadata = a.BroadcastOriginSourceMetadata.decode(A, A.uint32());
            break;
          case 10:
            te.broadcastOriginExternalMetadata = a.BroadcastOriginExternalMetadata.decode(A, A.uint32());
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        userId: Le(b.userId) ? String(b.userId) : "",
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : "",
        broadcastOrigin: Le(b.broadcastOrigin) ? M(b.broadcastOrigin) : void 0,
        broadcastOriginApiMetadata: Le(b == null ? void 0 : b.broadcastOriginApiMetadata) ? b.broadcastOriginApiMetadata : void 0,
        broadcastOriginSourceMetadata: Le(b.broadcastOriginSourceMetadata) ? a.BroadcastOriginSourceMetadata.fromJSON(b.broadcastOriginSourceMetadata) : void 0,
        broadcastOriginExternalMetadata: Le(b.broadcastOriginExternalMetadata) ? a.BroadcastOriginExternalMetadata.fromJSON(b.broadcastOriginExternalMetadata) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.userId !== void 0 && (C.userId = b.userId), b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.projectId !== void 0 && (C.projectId = b.projectId), b.broadcastOrigin !== void 0 && (C.broadcastOrigin = b.broadcastOrigin !== void 0 ? L(b.broadcastOrigin) : void 0), b.broadcastOriginApiMetadata !== void 0 && (C.broadcastOriginApiMetadata = b.broadcastOriginApiMetadata), b.broadcastOriginSourceMetadata !== void 0 && (C.broadcastOriginSourceMetadata = b.broadcastOriginSourceMetadata ? a.BroadcastOriginSourceMetadata.toJSON(b.broadcastOriginSourceMetadata) : void 0), b.broadcastOriginExternalMetadata !== void 0 && (C.broadcastOriginExternalMetadata = b.broadcastOriginExternalMetadata ? a.BroadcastOriginExternalMetadata.toJSON(b.broadcastOriginExternalMetadata) : void 0), C;
    },
    fromPartial(b) {
      var C, A, Se, te, Te;
      const vt = kt();
      return vt.userId = (C = b.userId) !== null && C !== void 0 ? C : "", vt.collectionId = (A = b.collectionId) !== null && A !== void 0 ? A : "", vt.projectId = (Se = b.projectId) !== null && Se !== void 0 ? Se : "", vt.broadcastOrigin = (te = b.broadcastOrigin) !== null && te !== void 0 ? te : void 0, vt.broadcastOriginApiMetadata = (Te = b.broadcastOriginApiMetadata) !== null && Te !== void 0 ? Te : void 0, vt.broadcastOriginSourceMetadata = b.broadcastOriginSourceMetadata !== void 0 && b.broadcastOriginSourceMetadata !== null ? a.BroadcastOriginSourceMetadata.fromPartial(b.broadcastOriginSourceMetadata) : void 0, vt.broadcastOriginExternalMetadata = b.broadcastOriginExternalMetadata !== void 0 && b.broadcastOriginExternalMetadata !== null ? a.BroadcastOriginExternalMetadata.fromPartial(b.broadcastOriginExternalMetadata) : void 0, vt;
    }
  };
  function nt() {
    return {};
  }
  a.WebhookResponse = {
    encode(b, C = c.default.Writer.create()) {
      return C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = nt();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {};
    },
    toJSON(b) {
      return {};
    },
    fromPartial(b) {
      return nt();
    }
  };
  function it() {
    return { enabled: !1, url: "", timeoutMs: void 0 };
  }
  a.WebhookConfiguration = {
    encode(b, C = c.default.Writer.create()) {
      return b.enabled === !0 && C.uint32(8).bool(b.enabled), b.url !== "" && C.uint32(18).string(b.url), b.timeoutMs !== void 0 && C.uint32(24).uint32(b.timeoutMs), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = it();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.enabled = A.bool();
            break;
          case 2:
            te.url = A.string();
            break;
          case 3:
            te.timeoutMs = A.uint32();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        enabled: Le(b.enabled) ? !!b.enabled : !1,
        url: Le(b.url) ? String(b.url) : "",
        timeoutMs: Le(b.timeoutMs) ? Number(b.timeoutMs) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.enabled !== void 0 && (C.enabled = b.enabled), b.url !== void 0 && (C.url = b.url), b.timeoutMs !== void 0 && (C.timeoutMs = Math.round(b.timeoutMs)), C;
    },
    fromPartial(b) {
      var C, A, Se;
      const te = it();
      return te.enabled = (C = b.enabled) !== null && C !== void 0 ? C : !1, te.url = (A = b.url) !== null && A !== void 0 ? A : "", te.timeoutMs = (Se = b.timeoutMs) !== null && Se !== void 0 ? Se : void 0, te;
    }
  };
  function bt() {
    return { startBroadcast: void 0, startWebrtc: void 0, joinWebrtc: void 0 };
  }
  a.AccountConfigurationHook = {
    encode(b, C = c.default.Writer.create()) {
      return b.startBroadcast !== void 0 && a.WebhookConfiguration.encode(b.startBroadcast, C.uint32(10).fork()).ldelim(), b.startWebrtc !== void 0 && a.WebhookConfiguration.encode(b.startWebrtc, C.uint32(18).fork()).ldelim(), b.joinWebrtc !== void 0 && a.WebhookConfiguration.encode(b.joinWebrtc, C.uint32(26).fork()).ldelim(), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = bt();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.startBroadcast = a.WebhookConfiguration.decode(A, A.uint32());
            break;
          case 2:
            te.startWebrtc = a.WebhookConfiguration.decode(A, A.uint32());
            break;
          case 3:
            te.joinWebrtc = a.WebhookConfiguration.decode(A, A.uint32());
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        startBroadcast: Le(b.startBroadcast) ? a.WebhookConfiguration.fromJSON(b.startBroadcast) : void 0,
        startWebrtc: Le(b.startWebrtc) ? a.WebhookConfiguration.fromJSON(b.startWebrtc) : void 0,
        joinWebrtc: Le(b.joinWebrtc) ? a.WebhookConfiguration.fromJSON(b.joinWebrtc) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.startBroadcast !== void 0 && (C.startBroadcast = b.startBroadcast ? a.WebhookConfiguration.toJSON(b.startBroadcast) : void 0), b.startWebrtc !== void 0 && (C.startWebrtc = b.startWebrtc ? a.WebhookConfiguration.toJSON(b.startWebrtc) : void 0), b.joinWebrtc !== void 0 && (C.joinWebrtc = b.joinWebrtc ? a.WebhookConfiguration.toJSON(b.joinWebrtc) : void 0), C;
    },
    fromPartial(b) {
      const C = bt();
      return C.startBroadcast = b.startBroadcast !== void 0 && b.startBroadcast !== null ? a.WebhookConfiguration.fromPartial(b.startBroadcast) : void 0, C.startWebrtc = b.startWebrtc !== void 0 && b.startWebrtc !== null ? a.WebhookConfiguration.fromPartial(b.startWebrtc) : void 0, C.joinWebrtc = b.joinWebrtc !== void 0 && b.joinWebrtc !== null ? a.WebhookConfiguration.fromPartial(b.joinWebrtc) : void 0, C;
    }
  };
  function ot() {
    return { broadcastConcurrency: void 0, hooks: void 0, guestCodeUrl: void 0 };
  }
  a.AccountConfiguration = {
    encode(b, C = c.default.Writer.create()) {
      return b.broadcastConcurrency !== void 0 && C.uint32(16).int32(b.broadcastConcurrency), b.hooks !== void 0 && a.AccountConfigurationHook.encode(b.hooks, C.uint32(26).fork()).ldelim(), b.guestCodeUrl !== void 0 && C.uint32(34).string(b.guestCodeUrl), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = ot();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 2:
            te.broadcastConcurrency = A.int32();
            break;
          case 3:
            te.hooks = a.AccountConfigurationHook.decode(A, A.uint32());
            break;
          case 4:
            te.guestCodeUrl = A.string();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        broadcastConcurrency: Le(b.broadcastConcurrency) ? Number(b.broadcastConcurrency) : void 0,
        hooks: Le(b.hooks) ? a.AccountConfigurationHook.fromJSON(b.hooks) : void 0,
        guestCodeUrl: Le(b.guestCodeUrl) ? String(b.guestCodeUrl) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.broadcastConcurrency !== void 0 && (C.broadcastConcurrency = Math.round(b.broadcastConcurrency)), b.hooks !== void 0 && (C.hooks = b.hooks ? a.AccountConfigurationHook.toJSON(b.hooks) : void 0), b.guestCodeUrl !== void 0 && (C.guestCodeUrl = b.guestCodeUrl), C;
    },
    fromPartial(b) {
      var C, A;
      const Se = ot();
      return Se.broadcastConcurrency = (C = b.broadcastConcurrency) !== null && C !== void 0 ? C : void 0, Se.hooks = b.hooks !== void 0 && b.hooks !== null ? a.AccountConfigurationHook.fromPartial(b.hooks) : void 0, Se.guestCodeUrl = (A = b.guestCodeUrl) !== null && A !== void 0 ? A : void 0, Se;
    }
  };
  function ct() {
    return {};
  }
  a.GetAccountConfigurationRequest = {
    encode(b, C = c.default.Writer.create()) {
      return C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = ct();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {};
    },
    toJSON(b) {
      return {};
    },
    fromPartial(b) {
      return ct();
    }
  };
  function Ot() {
    return { accountConfiguration: void 0 };
  }
  a.GetAccountConfigurationResponse = {
    encode(b, C = c.default.Writer.create()) {
      return b.accountConfiguration !== void 0 && a.AccountConfiguration.encode(b.accountConfiguration, C.uint32(10).fork()).ldelim(), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Ot();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.accountConfiguration = a.AccountConfiguration.decode(A, A.uint32());
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        accountConfiguration: Le(b.accountConfiguration) ? a.AccountConfiguration.fromJSON(b.accountConfiguration) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.accountConfiguration !== void 0 && (C.accountConfiguration = b.accountConfiguration ? a.AccountConfiguration.toJSON(b.accountConfiguration) : void 0), C;
    },
    fromPartial(b) {
      const C = Ot();
      return C.accountConfiguration = b.accountConfiguration !== void 0 && b.accountConfiguration !== null ? a.AccountConfiguration.fromPartial(b.accountConfiguration) : void 0, C;
    }
  };
  function st() {
    return { broadcastConcurrency: void 0, hooks: void 0, guestCodeUrl: void 0, updateMask: void 0 };
  }
  a.UpdateAccountConfigurationRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.broadcastConcurrency !== void 0 && C.uint32(16).int32(b.broadcastConcurrency), b.hooks !== void 0 && a.AccountConfigurationHook.encode(b.hooks, C.uint32(26).fork()).ldelim(), b.guestCodeUrl !== void 0 && C.uint32(42).string(b.guestCodeUrl), b.updateMask !== void 0 && v.FieldMask.encode(v.FieldMask.wrap(b.updateMask), C.uint32(34).fork()).ldelim(), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = st();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 2:
            te.broadcastConcurrency = A.int32();
            break;
          case 3:
            te.hooks = a.AccountConfigurationHook.decode(A, A.uint32());
            break;
          case 5:
            te.guestCodeUrl = A.string();
            break;
          case 4:
            te.updateMask = v.FieldMask.unwrap(v.FieldMask.decode(A, A.uint32()));
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        broadcastConcurrency: Le(b.broadcastConcurrency) ? Number(b.broadcastConcurrency) : void 0,
        hooks: Le(b.hooks) ? a.AccountConfigurationHook.fromJSON(b.hooks) : void 0,
        guestCodeUrl: Le(b.guestCodeUrl) ? String(b.guestCodeUrl) : void 0,
        updateMask: Le(b.updateMask) ? v.FieldMask.unwrap(v.FieldMask.fromJSON(b.updateMask)) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.broadcastConcurrency !== void 0 && (C.broadcastConcurrency = Math.round(b.broadcastConcurrency)), b.hooks !== void 0 && (C.hooks = b.hooks ? a.AccountConfigurationHook.toJSON(b.hooks) : void 0), b.guestCodeUrl !== void 0 && (C.guestCodeUrl = b.guestCodeUrl), b.updateMask !== void 0 && (C.updateMask = v.FieldMask.toJSON(v.FieldMask.wrap(b.updateMask))), C;
    },
    fromPartial(b) {
      var C, A, Se;
      const te = st();
      return te.broadcastConcurrency = (C = b.broadcastConcurrency) !== null && C !== void 0 ? C : void 0, te.hooks = b.hooks !== void 0 && b.hooks !== null ? a.AccountConfigurationHook.fromPartial(b.hooks) : void 0, te.guestCodeUrl = (A = b.guestCodeUrl) !== null && A !== void 0 ? A : void 0, te.updateMask = (Se = b.updateMask) !== null && Se !== void 0 ? Se : void 0, te;
    }
  };
  function lt() {
    return { accountConfiguration: void 0 };
  }
  a.UpdateAccountConfigurationResponse = {
    encode(b, C = c.default.Writer.create()) {
      return b.accountConfiguration !== void 0 && a.AccountConfiguration.encode(b.accountConfiguration, C.uint32(10).fork()).ldelim(), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = lt();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.accountConfiguration = a.AccountConfiguration.decode(A, A.uint32());
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        accountConfiguration: Le(b.accountConfiguration) ? a.AccountConfiguration.fromJSON(b.accountConfiguration) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.accountConfiguration !== void 0 && (C.accountConfiguration = b.accountConfiguration ? a.AccountConfiguration.toJSON(b.accountConfiguration) : void 0), C;
    },
    fromPartial(b) {
      const C = lt();
      return C.accountConfiguration = b.accountConfiguration !== void 0 && b.accountConfiguration !== null ? a.AccountConfiguration.fromPartial(b.accountConfiguration) : void 0, C;
    }
  };
  function Rt() {
    return { height: void 0, width: void 0, framerate: void 0, colorSpace: void 0 };
  }
  a.VideoRendering = {
    encode(b, C = c.default.Writer.create()) {
      return b.height !== void 0 && C.uint32(8).uint32(b.height), b.width !== void 0 && C.uint32(16).uint32(b.width), b.framerate !== void 0 && C.uint32(29).float(b.framerate), b.colorSpace !== void 0 && C.uint32(32).int32(z(b.colorSpace)), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Rt();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.height = A.uint32();
            break;
          case 2:
            te.width = A.uint32();
            break;
          case 3:
            te.framerate = A.float();
            break;
          case 4:
            te.colorSpace = Ae(A.int32());
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        height: Le(b.height) ? Number(b.height) : void 0,
        width: Le(b.width) ? Number(b.width) : void 0,
        framerate: Le(b.framerate) ? Number(b.framerate) : void 0,
        colorSpace: Le(b.colorSpace) ? Ae(b.colorSpace) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.height !== void 0 && (C.height = Math.round(b.height)), b.width !== void 0 && (C.width = Math.round(b.width)), b.framerate !== void 0 && (C.framerate = b.framerate), b.colorSpace !== void 0 && (C.colorSpace = b.colorSpace !== void 0 ? Z(b.colorSpace) : void 0), C;
    },
    fromPartial(b) {
      var C, A, Se, te;
      const Te = Rt();
      return Te.height = (C = b.height) !== null && C !== void 0 ? C : void 0, Te.width = (A = b.width) !== null && A !== void 0 ? A : void 0, Te.framerate = (Se = b.framerate) !== null && Se !== void 0 ? Se : void 0, Te.colorSpace = (te = b.colorSpace) !== null && te !== void 0 ? te : void 0, Te;
    }
  };
  function Ct() {
    return { channelLayout: void 0 };
  }
  a.AudioRendering = {
    encode(b, C = c.default.Writer.create()) {
      return b.channelLayout !== void 0 && C.uint32(8).int32(I(b.channelLayout)), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Ct();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.channelLayout = S(A.int32());
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        channelLayout: Le(b.channelLayout) ? S(b.channelLayout) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.channelLayout !== void 0 && (C.channelLayout = b.channelLayout !== void 0 ? E(b.channelLayout) : void 0), C;
    },
    fromPartial(b) {
      var C;
      const A = Ct();
      return A.channelLayout = (C = b.channelLayout) !== null && C !== void 0 ? C : void 0, A;
    }
  };
  function Je() {
    return { video: void 0, audio: void 0, quality: void 0, targetLatency: void 0, complexity: void 0 };
  }
  a.Rendering = {
    encode(b, C = c.default.Writer.create()) {
      return b.video !== void 0 && a.VideoRendering.encode(b.video, C.uint32(10).fork()).ldelim(), b.audio !== void 0 && a.AudioRendering.encode(b.audio, C.uint32(18).fork()).ldelim(), b.quality !== void 0 && C.uint32(24).int32(H(b.quality)), b.targetLatency !== void 0 && C.uint32(32).uint32(b.targetLatency), b.complexity !== void 0 && C.uint32(40).int32(b.complexity), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Je();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.video = a.VideoRendering.decode(A, A.uint32());
            break;
          case 2:
            te.audio = a.AudioRendering.decode(A, A.uint32());
            break;
          case 3:
            te.quality = $(A.int32());
            break;
          case 4:
            te.targetLatency = A.uint32();
            break;
          case 5:
            te.complexity = A.int32();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        video: Le(b.video) ? a.VideoRendering.fromJSON(b.video) : void 0,
        audio: Le(b.audio) ? a.AudioRendering.fromJSON(b.audio) : void 0,
        quality: Le(b.quality) ? $(b.quality) : void 0,
        targetLatency: Le(b.targetLatency) ? Number(b.targetLatency) : void 0,
        complexity: Le(b.complexity) ? Number(b.complexity) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.video !== void 0 && (C.video = b.video ? a.VideoRendering.toJSON(b.video) : void 0), b.audio !== void 0 && (C.audio = b.audio ? a.AudioRendering.toJSON(b.audio) : void 0), b.quality !== void 0 && (C.quality = b.quality !== void 0 ? U(b.quality) : void 0), b.targetLatency !== void 0 && (C.targetLatency = Math.round(b.targetLatency)), b.complexity !== void 0 && (C.complexity = Math.round(b.complexity)), C;
    },
    fromPartial(b) {
      var C, A, Se;
      const te = Je();
      return te.video = b.video !== void 0 && b.video !== null ? a.VideoRendering.fromPartial(b.video) : void 0, te.audio = b.audio !== void 0 && b.audio !== null ? a.AudioRendering.fromPartial(b.audio) : void 0, te.quality = (C = b.quality) !== null && C !== void 0 ? C : void 0, te.targetLatency = (A = b.targetLatency) !== null && A !== void 0 ? A : void 0, te.complexity = (Se = b.complexity) !== null && Se !== void 0 ? Se : void 0, te;
    }
  };
  function He() {
    return { mode: void 0, targetBitrate: void 0, maxKeyFrameInterval: void 0 };
  }
  a.VideoCodecRateControl = {
    encode(b, C = c.default.Writer.create()) {
      return b.mode !== void 0 && C.uint32(8).int32(ce(b.mode)), b.targetBitrate !== void 0 && C.uint32(16).uint32(b.targetBitrate), b.maxKeyFrameInterval !== void 0 && C.uint32(24).uint32(b.maxKeyFrameInterval), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = He();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.mode = O(A.int32());
            break;
          case 2:
            te.targetBitrate = A.uint32();
            break;
          case 3:
            te.maxKeyFrameInterval = A.uint32();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        mode: Le(b.mode) ? O(b.mode) : void 0,
        targetBitrate: Le(b.targetBitrate) ? Number(b.targetBitrate) : void 0,
        maxKeyFrameInterval: Le(b.maxKeyFrameInterval) ? Number(b.maxKeyFrameInterval) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.mode !== void 0 && (C.mode = b.mode !== void 0 ? j(b.mode) : void 0), b.targetBitrate !== void 0 && (C.targetBitrate = Math.round(b.targetBitrate)), b.maxKeyFrameInterval !== void 0 && (C.maxKeyFrameInterval = Math.round(b.maxKeyFrameInterval)), C;
    },
    fromPartial(b) {
      var C, A, Se;
      const te = He();
      return te.mode = (C = b.mode) !== null && C !== void 0 ? C : void 0, te.targetBitrate = (A = b.targetBitrate) !== null && A !== void 0 ? A : void 0, te.maxKeyFrameInterval = (Se = b.maxKeyFrameInterval) !== null && Se !== void 0 ? Se : void 0, te;
    }
  };
  function je() {
    return { codec: void 0, rateControl: void 0, profile: void 0 };
  }
  a.VideoEncoding = {
    encode(b, C = c.default.Writer.create()) {
      return b.codec !== void 0 && C.uint32(8).int32(ee(b.codec)), b.rateControl !== void 0 && a.VideoCodecRateControl.encode(b.rateControl, C.uint32(18).fork()).ldelim(), b.profile !== void 0 && C.uint32(32).int32(he(b.profile)), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = je();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.codec = T(A.int32());
            break;
          case 2:
            te.rateControl = a.VideoCodecRateControl.decode(A, A.uint32());
            break;
          case 4:
            te.profile = Ie(A.int32());
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        codec: Le(b.codec) ? T(b.codec) : void 0,
        rateControl: Le(b.rateControl) ? a.VideoCodecRateControl.fromJSON(b.rateControl) : void 0,
        profile: Le(b.profile) ? Ie(b.profile) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.codec !== void 0 && (C.codec = b.codec !== void 0 ? D(b.codec) : void 0), b.rateControl !== void 0 && (C.rateControl = b.rateControl ? a.VideoCodecRateControl.toJSON(b.rateControl) : void 0), b.profile !== void 0 && (C.profile = b.profile !== void 0 ? Pe(b.profile) : void 0), C;
    },
    fromPartial(b) {
      var C, A;
      const Se = je();
      return Se.codec = (C = b.codec) !== null && C !== void 0 ? C : void 0, Se.rateControl = b.rateControl !== void 0 && b.rateControl !== null ? a.VideoCodecRateControl.fromPartial(b.rateControl) : void 0, Se.profile = (A = b.profile) !== null && A !== void 0 ? A : void 0, Se;
    }
  };
  function pt() {
    return { codec: void 0 };
  }
  a.AudioEncoding = {
    encode(b, C = c.default.Writer.create()) {
      return b.codec !== void 0 && C.uint32(8).int32(_e(b.codec)), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = pt();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.codec = Q(A.int32());
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return { codec: Le(b.codec) ? Q(b.codec) : void 0 };
    },
    toJSON(b) {
      const C = {};
      return b.codec !== void 0 && (C.codec = b.codec !== void 0 ? le(b.codec) : void 0), C;
    },
    fromPartial(b) {
      var C;
      const A = pt();
      return A.codec = (C = b.codec) !== null && C !== void 0 ? C : void 0, A;
    }
  };
  function mt() {
    return { video: void 0, audio: void 0 };
  }
  a.Encoding = {
    encode(b, C = c.default.Writer.create()) {
      return b.video !== void 0 && a.VideoEncoding.encode(b.video, C.uint32(10).fork()).ldelim(), b.audio !== void 0 && a.AudioEncoding.encode(b.audio, C.uint32(18).fork()).ldelim(), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = mt();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.video = a.VideoEncoding.decode(A, A.uint32());
            break;
          case 2:
            te.audio = a.AudioEncoding.decode(A, A.uint32());
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        video: Le(b.video) ? a.VideoEncoding.fromJSON(b.video) : void 0,
        audio: Le(b.audio) ? a.AudioEncoding.fromJSON(b.audio) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.video !== void 0 && (C.video = b.video ? a.VideoEncoding.toJSON(b.video) : void 0), b.audio !== void 0 && (C.audio = b.audio ? a.AudioEncoding.toJSON(b.audio) : void 0), C;
    },
    fromPartial(b) {
      const C = mt();
      return C.video = b.video !== void 0 && b.video !== null ? a.VideoEncoding.fromPartial(b.video) : void 0, C.audio = b.audio !== void 0 && b.audio !== null ? a.AudioEncoding.fromPartial(b.audio) : void 0, C;
    }
  };
  function yt() {
    return {
      enabled: void 0,
      key: void 0,
      url: void 0,
      baseUrl: void 0,
      previewUrl: void 0,
      ingestId: void 0,
      secure: void 0,
      ingestType: void 0
    };
  }
  a.SourceRtmpPushAddress = {
    encode(b, C = c.default.Writer.create()) {
      return b.enabled !== void 0 && C.uint32(8).bool(b.enabled), b.key !== void 0 && C.uint32(18).string(b.key), b.url !== void 0 && C.uint32(26).string(b.url), b.baseUrl !== void 0 && C.uint32(34).string(b.baseUrl), b.previewUrl !== void 0 && C.uint32(42).string(b.previewUrl), b.ingestId !== void 0 && C.uint32(50).string(b.ingestId), b.secure !== void 0 && C.uint32(56).bool(b.secure), b.ingestType !== void 0 && C.uint32(66).string(b.ingestType), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = yt();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.enabled = A.bool();
            break;
          case 2:
            te.key = A.string();
            break;
          case 3:
            te.url = A.string();
            break;
          case 4:
            te.baseUrl = A.string();
            break;
          case 5:
            te.previewUrl = A.string();
            break;
          case 6:
            te.ingestId = A.string();
            break;
          case 7:
            te.secure = A.bool();
            break;
          case 8:
            te.ingestType = A.string();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        enabled: Le(b.enabled) ? !!b.enabled : void 0,
        key: Le(b.key) ? String(b.key) : void 0,
        url: Le(b.url) ? String(b.url) : void 0,
        baseUrl: Le(b.baseUrl) ? String(b.baseUrl) : void 0,
        previewUrl: Le(b.previewUrl) ? String(b.previewUrl) : void 0,
        ingestId: Le(b.ingestId) ? String(b.ingestId) : void 0,
        secure: Le(b.secure) ? !!b.secure : void 0,
        ingestType: Le(b.ingestType) ? String(b.ingestType) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.enabled !== void 0 && (C.enabled = b.enabled), b.key !== void 0 && (C.key = b.key), b.url !== void 0 && (C.url = b.url), b.baseUrl !== void 0 && (C.baseUrl = b.baseUrl), b.previewUrl !== void 0 && (C.previewUrl = b.previewUrl), b.ingestId !== void 0 && (C.ingestId = b.ingestId), b.secure !== void 0 && (C.secure = b.secure), b.ingestType !== void 0 && (C.ingestType = b.ingestType), C;
    },
    fromPartial(b) {
      var C, A, Se, te, Te, vt, It, Pt;
      const Mt = yt();
      return Mt.enabled = (C = b.enabled) !== null && C !== void 0 ? C : void 0, Mt.key = (A = b.key) !== null && A !== void 0 ? A : void 0, Mt.url = (Se = b.url) !== null && Se !== void 0 ? Se : void 0, Mt.baseUrl = (te = b.baseUrl) !== null && te !== void 0 ? te : void 0, Mt.previewUrl = (Te = b.previewUrl) !== null && Te !== void 0 ? Te : void 0, Mt.ingestId = (vt = b.ingestId) !== null && vt !== void 0 ? vt : void 0, Mt.secure = (It = b.secure) !== null && It !== void 0 ? It : void 0, Mt.ingestType = (Pt = b.ingestType) !== null && Pt !== void 0 ? Pt : void 0, Mt;
    }
  };
  function ht() {
    return {
      enabled: void 0,
      streamId: void 0,
      url: void 0,
      baseUrl: void 0,
      previewUrl: void 0,
      ingestId: void 0,
      ingestType: void 0
    };
  }
  a.SrtPushAddress = {
    encode(b, C = c.default.Writer.create()) {
      return b.enabled !== void 0 && C.uint32(8).bool(b.enabled), b.streamId !== void 0 && C.uint32(18).string(b.streamId), b.url !== void 0 && C.uint32(26).string(b.url), b.baseUrl !== void 0 && C.uint32(34).string(b.baseUrl), b.previewUrl !== void 0 && C.uint32(42).string(b.previewUrl), b.ingestId !== void 0 && C.uint32(50).string(b.ingestId), b.ingestType !== void 0 && C.uint32(58).string(b.ingestType), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = ht();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.enabled = A.bool();
            break;
          case 2:
            te.streamId = A.string();
            break;
          case 3:
            te.url = A.string();
            break;
          case 4:
            te.baseUrl = A.string();
            break;
          case 5:
            te.previewUrl = A.string();
            break;
          case 6:
            te.ingestId = A.string();
            break;
          case 7:
            te.ingestType = A.string();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        enabled: Le(b.enabled) ? !!b.enabled : void 0,
        streamId: Le(b.streamId) ? String(b.streamId) : void 0,
        url: Le(b.url) ? String(b.url) : void 0,
        baseUrl: Le(b.baseUrl) ? String(b.baseUrl) : void 0,
        previewUrl: Le(b.previewUrl) ? String(b.previewUrl) : void 0,
        ingestId: Le(b.ingestId) ? String(b.ingestId) : void 0,
        ingestType: Le(b.ingestType) ? String(b.ingestType) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.enabled !== void 0 && (C.enabled = b.enabled), b.streamId !== void 0 && (C.streamId = b.streamId), b.url !== void 0 && (C.url = b.url), b.baseUrl !== void 0 && (C.baseUrl = b.baseUrl), b.previewUrl !== void 0 && (C.previewUrl = b.previewUrl), b.ingestId !== void 0 && (C.ingestId = b.ingestId), b.ingestType !== void 0 && (C.ingestType = b.ingestType), C;
    },
    fromPartial(b) {
      var C, A, Se, te, Te, vt, It;
      const Pt = ht();
      return Pt.enabled = (C = b.enabled) !== null && C !== void 0 ? C : void 0, Pt.streamId = (A = b.streamId) !== null && A !== void 0 ? A : void 0, Pt.url = (Se = b.url) !== null && Se !== void 0 ? Se : void 0, Pt.baseUrl = (te = b.baseUrl) !== null && te !== void 0 ? te : void 0, Pt.previewUrl = (Te = b.previewUrl) !== null && Te !== void 0 ? Te : void 0, Pt.ingestId = (vt = b.ingestId) !== null && vt !== void 0 ? vt : void 0, Pt.ingestType = (It = b.ingestType) !== null && It !== void 0 ? It : void 0, Pt;
    }
  };
  function _t() {
    return { url: "" };
  }
  a.RtmpPullAddress = {
    encode(b, C = c.default.Writer.create()) {
      return b.url !== "" && C.uint32(10).string(b.url), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = _t();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.url = A.string();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return { url: Le(b.url) ? String(b.url) : "" };
    },
    toJSON(b) {
      const C = {};
      return b.url !== void 0 && (C.url = b.url), C;
    },
    fromPartial(b) {
      var C;
      const A = _t();
      return A.url = (C = b.url) !== null && C !== void 0 ? C : "", A;
    }
  };
  function Et() {
    return { url: "" };
  }
  a.SrtPullAddress = {
    encode(b, C = c.default.Writer.create()) {
      return b.url !== "" && C.uint32(10).string(b.url), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Et();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.url = A.string();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return { url: Le(b.url) ? String(b.url) : "" };
    },
    toJSON(b) {
      const C = {};
      return b.url !== void 0 && (C.url = b.url), C;
    },
    fromPartial(b) {
      var C;
      const A = Et();
      return A.url = (C = b.url) !== null && C !== void 0 ? C : "", A;
    }
  };
  function Nt() {
    return { id: void 0 };
  }
  a.DynamicAddress = {
    encode(b, C = c.default.Writer.create()) {
      return b.id !== void 0 && C.uint32(10).string(b.id), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Nt();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.id = A.string();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return { id: Le(b.id) ? String(b.id) : void 0 };
    },
    toJSON(b) {
      const C = {};
      return b.id !== void 0 && (C.id = b.id), C;
    },
    fromPartial(b) {
      var C;
      const A = Nt();
      return A.id = (C = b.id) !== null && C !== void 0 ? C : void 0, A;
    }
  };
  function Dt() {
    return { enabled: void 0, secure: !1 };
  }
  a.DirectRTMPAddress = {
    encode(b, C = c.default.Writer.create()) {
      return b.enabled !== void 0 && C.uint32(8).bool(b.enabled), b.secure === !0 && C.uint32(16).bool(b.secure), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Dt();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.enabled = A.bool();
            break;
          case 2:
            te.secure = A.bool();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        enabled: Le(b.enabled) ? !!b.enabled : void 0,
        secure: Le(b.secure) ? !!b.secure : !1
      };
    },
    toJSON(b) {
      const C = {};
      return b.enabled !== void 0 && (C.enabled = b.enabled), b.secure !== void 0 && (C.secure = b.secure), C;
    },
    fromPartial(b) {
      var C, A;
      const Se = Dt();
      return Se.enabled = (C = b.enabled) !== null && C !== void 0 ? C : void 0, Se.secure = (A = b.secure) !== null && A !== void 0 ? A : !1, Se;
    }
  };
  function $t() {
    return { enabled: void 0, secure: !1 };
  }
  a.DirectSrtAddress = {
    encode(b, C = c.default.Writer.create()) {
      return b.enabled !== void 0 && C.uint32(8).bool(b.enabled), b.secure === !0 && C.uint32(16).bool(b.secure), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = $t();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.enabled = A.bool();
            break;
          case 2:
            te.secure = A.bool();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        enabled: Le(b.enabled) ? !!b.enabled : void 0,
        secure: Le(b.secure) ? !!b.secure : !1
      };
    },
    toJSON(b) {
      const C = {};
      return b.enabled !== void 0 && (C.enabled = b.enabled), b.secure !== void 0 && (C.secure = b.secure), C;
    },
    fromPartial(b) {
      var C, A;
      const Se = $t();
      return Se.enabled = (C = b.enabled) !== null && C !== void 0 ? C : void 0, Se.secure = (A = b.secure) !== null && A !== void 0 ? A : !1, Se;
    }
  };
  function At() {
    return { rtmpPull: void 0, srtPull: void 0, directRtmpPush: void 0, directSrtPush: void 0 };
  }
  a.RuntimeSourceAddress = {
    encode(b, C = c.default.Writer.create()) {
      return b.rtmpPull !== void 0 && a.RtmpPullAddress.encode(b.rtmpPull, C.uint32(10).fork()).ldelim(), b.srtPull !== void 0 && a.SrtPullAddress.encode(b.srtPull, C.uint32(18).fork()).ldelim(), b.directRtmpPush !== void 0 && a.DirectRTMPAddress.encode(b.directRtmpPush, C.uint32(26).fork()).ldelim(), b.directSrtPush !== void 0 && a.DirectSrtAddress.encode(b.directSrtPush, C.uint32(34).fork()).ldelim(), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = At();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.rtmpPull = a.RtmpPullAddress.decode(A, A.uint32());
            break;
          case 2:
            te.srtPull = a.SrtPullAddress.decode(A, A.uint32());
            break;
          case 3:
            te.directRtmpPush = a.DirectRTMPAddress.decode(A, A.uint32());
            break;
          case 4:
            te.directSrtPush = a.DirectSrtAddress.decode(A, A.uint32());
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        rtmpPull: Le(b.rtmpPull) ? a.RtmpPullAddress.fromJSON(b.rtmpPull) : void 0,
        srtPull: Le(b.srtPull) ? a.SrtPullAddress.fromJSON(b.srtPull) : void 0,
        directRtmpPush: Le(b.directRtmpPush) ? a.DirectRTMPAddress.fromJSON(b.directRtmpPush) : void 0,
        directSrtPush: Le(b.directSrtPush) ? a.DirectSrtAddress.fromJSON(b.directSrtPush) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.rtmpPull !== void 0 && (C.rtmpPull = b.rtmpPull ? a.RtmpPullAddress.toJSON(b.rtmpPull) : void 0), b.srtPull !== void 0 && (C.srtPull = b.srtPull ? a.SrtPullAddress.toJSON(b.srtPull) : void 0), b.directRtmpPush !== void 0 && (C.directRtmpPush = b.directRtmpPush ? a.DirectRTMPAddress.toJSON(b.directRtmpPush) : void 0), b.directSrtPush !== void 0 && (C.directSrtPush = b.directSrtPush ? a.DirectSrtAddress.toJSON(b.directSrtPush) : void 0), C;
    },
    fromPartial(b) {
      const C = At();
      return C.rtmpPull = b.rtmpPull !== void 0 && b.rtmpPull !== null ? a.RtmpPullAddress.fromPartial(b.rtmpPull) : void 0, C.srtPull = b.srtPull !== void 0 && b.srtPull !== null ? a.SrtPullAddress.fromPartial(b.srtPull) : void 0, C.directRtmpPush = b.directRtmpPush !== void 0 && b.directRtmpPush !== null ? a.DirectRTMPAddress.fromPartial(b.directRtmpPush) : void 0, C.directSrtPush = b.directSrtPush !== void 0 && b.directSrtPush !== null ? a.DirectSrtAddress.fromPartial(b.directSrtPush) : void 0, C;
    }
  };
  function Lt() {
    return { rtmpPush: void 0, srtPush: void 0, rtmpPull: void 0, srtPull: void 0, dynamic: void 0 };
  }
  a.SourceAddress = {
    encode(b, C = c.default.Writer.create()) {
      return b.rtmpPush !== void 0 && a.SourceRtmpPushAddress.encode(b.rtmpPush, C.uint32(10).fork()).ldelim(), b.srtPush !== void 0 && a.SrtPushAddress.encode(b.srtPush, C.uint32(18).fork()).ldelim(), b.rtmpPull !== void 0 && a.RtmpPullAddress.encode(b.rtmpPull, C.uint32(26).fork()).ldelim(), b.srtPull !== void 0 && a.SrtPullAddress.encode(b.srtPull, C.uint32(34).fork()).ldelim(), b.dynamic !== void 0 && a.DynamicAddress.encode(b.dynamic, C.uint32(42).fork()).ldelim(), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Lt();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.rtmpPush = a.SourceRtmpPushAddress.decode(A, A.uint32());
            break;
          case 2:
            te.srtPush = a.SrtPushAddress.decode(A, A.uint32());
            break;
          case 3:
            te.rtmpPull = a.RtmpPullAddress.decode(A, A.uint32());
            break;
          case 4:
            te.srtPull = a.SrtPullAddress.decode(A, A.uint32());
            break;
          case 5:
            te.dynamic = a.DynamicAddress.decode(A, A.uint32());
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        rtmpPush: Le(b.rtmpPush) ? a.SourceRtmpPushAddress.fromJSON(b.rtmpPush) : void 0,
        srtPush: Le(b.srtPush) ? a.SrtPushAddress.fromJSON(b.srtPush) : void 0,
        rtmpPull: Le(b.rtmpPull) ? a.RtmpPullAddress.fromJSON(b.rtmpPull) : void 0,
        srtPull: Le(b.srtPull) ? a.SrtPullAddress.fromJSON(b.srtPull) : void 0,
        dynamic: Le(b.dynamic) ? a.DynamicAddress.fromJSON(b.dynamic) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.rtmpPush !== void 0 && (C.rtmpPush = b.rtmpPush ? a.SourceRtmpPushAddress.toJSON(b.rtmpPush) : void 0), b.srtPush !== void 0 && (C.srtPush = b.srtPush ? a.SrtPushAddress.toJSON(b.srtPush) : void 0), b.rtmpPull !== void 0 && (C.rtmpPull = b.rtmpPull ? a.RtmpPullAddress.toJSON(b.rtmpPull) : void 0), b.srtPull !== void 0 && (C.srtPull = b.srtPull ? a.SrtPullAddress.toJSON(b.srtPull) : void 0), b.dynamic !== void 0 && (C.dynamic = b.dynamic ? a.DynamicAddress.toJSON(b.dynamic) : void 0), C;
    },
    fromPartial(b) {
      const C = Lt();
      return C.rtmpPush = b.rtmpPush !== void 0 && b.rtmpPush !== null ? a.SourceRtmpPushAddress.fromPartial(b.rtmpPush) : void 0, C.srtPush = b.srtPush !== void 0 && b.srtPush !== null ? a.SrtPushAddress.fromPartial(b.srtPush) : void 0, C.rtmpPull = b.rtmpPull !== void 0 && b.rtmpPull !== null ? a.RtmpPullAddress.fromPartial(b.rtmpPull) : void 0, C.srtPull = b.srtPull !== void 0 && b.srtPull !== null ? a.SrtPullAddress.fromPartial(b.srtPull) : void 0, C.dynamic = b.dynamic !== void 0 && b.dynamic !== null ? a.DynamicAddress.fromPartial(b.dynamic) : void 0, C;
    }
  };
  function Bt() {
    return { key: void 0, url: "" };
  }
  a.DestinationRtmpPushAddress = {
    encode(b, C = c.default.Writer.create()) {
      return b.key !== void 0 && C.uint32(10).string(b.key), b.url !== "" && C.uint32(18).string(b.url), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Bt();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.key = A.string();
            break;
          case 2:
            te.url = A.string();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        key: Le(b.key) ? String(b.key) : void 0,
        url: Le(b.url) ? String(b.url) : ""
      };
    },
    toJSON(b) {
      const C = {};
      return b.key !== void 0 && (C.key = b.key), b.url !== void 0 && (C.url = b.url), C;
    },
    fromPartial(b) {
      var C, A;
      const Se = Bt();
      return Se.key = (C = b.key) !== null && C !== void 0 ? C : void 0, Se.url = (A = b.url) !== null && A !== void 0 ? A : "", Se;
    }
  };
  function Ut() {
    return { url: "" };
  }
  a.DestinationSrtPushAddress = {
    encode(b, C = c.default.Writer.create()) {
      return b.url !== "" && C.uint32(18).string(b.url), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Ut();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 2:
            te.url = A.string();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return { url: Le(b.url) ? String(b.url) : "" };
    },
    toJSON(b) {
      const C = {};
      return b.url !== void 0 && (C.url = b.url), C;
    },
    fromPartial(b) {
      var C;
      const A = Ut();
      return A.url = (C = b.url) !== null && C !== void 0 ? C : "", A;
    }
  };
  function xt() {
    return { appId: "", channelId: "", userId: "" };
  }
  a.DestinationAgoraPushAddress = {
    encode(b, C = c.default.Writer.create()) {
      return b.appId !== "" && C.uint32(10).string(b.appId), b.channelId !== "" && C.uint32(18).string(b.channelId), b.userId !== "" && C.uint32(26).string(b.userId), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = xt();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.appId = A.string();
            break;
          case 2:
            te.channelId = A.string();
            break;
          case 3:
            te.userId = A.string();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        appId: Le(b.appId) ? String(b.appId) : "",
        channelId: Le(b.channelId) ? String(b.channelId) : "",
        userId: Le(b.userId) ? String(b.userId) : ""
      };
    },
    toJSON(b) {
      const C = {};
      return b.appId !== void 0 && (C.appId = b.appId), b.channelId !== void 0 && (C.channelId = b.channelId), b.userId !== void 0 && (C.userId = b.userId), C;
    },
    fromPartial(b) {
      var C, A, Se;
      const te = xt();
      return te.appId = (C = b.appId) !== null && C !== void 0 ? C : "", te.channelId = (A = b.channelId) !== null && A !== void 0 ? A : "", te.userId = (Se = b.userId) !== null && Se !== void 0 ? Se : "", te;
    }
  };
  function Vt() {
    return { playlistCount: void 0, fileCount: void 0 };
  }
  a.HlsLifecycleLive = {
    encode(b, C = c.default.Writer.create()) {
      return b.playlistCount !== void 0 && C.uint32(8).int32(b.playlistCount), b.fileCount !== void 0 && C.uint32(16).int32(b.fileCount), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Vt();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.playlistCount = A.int32();
            break;
          case 2:
            te.fileCount = A.int32();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        playlistCount: Le(b.playlistCount) ? Number(b.playlistCount) : void 0,
        fileCount: Le(b.fileCount) ? Number(b.fileCount) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.playlistCount !== void 0 && (C.playlistCount = Math.round(b.playlistCount)), b.fileCount !== void 0 && (C.fileCount = Math.round(b.fileCount)), C;
    },
    fromPartial(b) {
      var C, A;
      const Se = Vt();
      return Se.playlistCount = (C = b.playlistCount) !== null && C !== void 0 ? C : void 0, Se.fileCount = (A = b.fileCount) !== null && A !== void 0 ? A : void 0, Se;
    }
  };
  function Gt() {
    return { maxDuration: void 0 };
  }
  a.HlsLifecycleVod = {
    encode(b, C = c.default.Writer.create()) {
      return b.maxDuration !== void 0 && C.uint32(8).int32(b.maxDuration), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Gt();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.maxDuration = A.int32();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return { maxDuration: Le(b.maxDuration) ? Number(b.maxDuration) : void 0 };
    },
    toJSON(b) {
      const C = {};
      return b.maxDuration !== void 0 && (C.maxDuration = Math.round(b.maxDuration)), C;
    },
    fromPartial(b) {
      var C;
      const A = Gt();
      return A.maxDuration = (C = b.maxDuration) !== null && C !== void 0 ? C : void 0, A;
    }
  };
  function Qt() {
    return { vod: void 0, live: void 0 };
  }
  a.HlsLifecycle = {
    encode(b, C = c.default.Writer.create()) {
      return b.vod !== void 0 && a.HlsLifecycleVod.encode(b.vod, C.uint32(10).fork()).ldelim(), b.live !== void 0 && a.HlsLifecycleLive.encode(b.live, C.uint32(18).fork()).ldelim(), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Qt();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.vod = a.HlsLifecycleVod.decode(A, A.uint32());
            break;
          case 2:
            te.live = a.HlsLifecycleLive.decode(A, A.uint32());
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        vod: Le(b.vod) ? a.HlsLifecycleVod.fromJSON(b.vod) : void 0,
        live: Le(b.live) ? a.HlsLifecycleLive.fromJSON(b.live) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.vod !== void 0 && (C.vod = b.vod ? a.HlsLifecycleVod.toJSON(b.vod) : void 0), b.live !== void 0 && (C.live = b.live ? a.HlsLifecycleLive.toJSON(b.live) : void 0), C;
    },
    fromPartial(b) {
      const C = Qt();
      return C.vod = b.vod !== void 0 && b.vod !== null ? a.HlsLifecycleVod.fromPartial(b.vod) : void 0, C.live = b.live !== void 0 && b.live !== null ? a.HlsLifecycleLive.fromPartial(b.live) : void 0, C;
    }
  };
  function Xt() {
    return { lifecycle: void 0, segmentDuration: void 0 };
  }
  a.HlsPackaging = {
    encode(b, C = c.default.Writer.create()) {
      return b.lifecycle !== void 0 && a.HlsLifecycle.encode(b.lifecycle, C.uint32(10).fork()).ldelim(), b.segmentDuration !== void 0 && C.uint32(16).int32(b.segmentDuration), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Xt();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.lifecycle = a.HlsLifecycle.decode(A, A.uint32());
            break;
          case 2:
            te.segmentDuration = A.int32();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        lifecycle: Le(b.lifecycle) ? a.HlsLifecycle.fromJSON(b.lifecycle) : void 0,
        segmentDuration: Le(b.segmentDuration) ? Number(b.segmentDuration) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.lifecycle !== void 0 && (C.lifecycle = b.lifecycle ? a.HlsLifecycle.toJSON(b.lifecycle) : void 0), b.segmentDuration !== void 0 && (C.segmentDuration = Math.round(b.segmentDuration)), C;
    },
    fromPartial(b) {
      var C;
      const A = Xt();
      return A.lifecycle = b.lifecycle !== void 0 && b.lifecycle !== null ? a.HlsLifecycle.fromPartial(b.lifecycle) : void 0, A.segmentDuration = (C = b.segmentDuration) !== null && C !== void 0 ? C : void 0, A;
    }
  };
  function jt() {
    return { hls: void 0 };
  }
  a.ObjectStoragePackaging = {
    encode(b, C = c.default.Writer.create()) {
      return b.hls !== void 0 && a.HlsPackaging.encode(b.hls, C.uint32(10).fork()).ldelim(), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = jt();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.hls = a.HlsPackaging.decode(A, A.uint32());
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return { hls: Le(b.hls) ? a.HlsPackaging.fromJSON(b.hls) : void 0 };
    },
    toJSON(b) {
      const C = {};
      return b.hls !== void 0 && (C.hls = b.hls ? a.HlsPackaging.toJSON(b.hls) : void 0), C;
    },
    fromPartial(b) {
      const C = jt();
      return C.hls = b.hls !== void 0 && b.hls !== null ? a.HlsPackaging.fromPartial(b.hls) : void 0, C;
    }
  };
  function er() {
    return { enabled: void 0, displayName: void 0, participantId: void 0 };
  }
  a.PreviewWebRtcAddress = {
    encode(b, C = c.default.Writer.create()) {
      return b.enabled !== void 0 && C.uint32(8).bool(b.enabled), b.displayName !== void 0 && C.uint32(18).string(b.displayName), b.participantId !== void 0 && C.uint32(26).string(b.participantId), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = er();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.enabled = A.bool();
            break;
          case 2:
            te.displayName = A.string();
            break;
          case 3:
            te.participantId = A.string();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        enabled: Le(b.enabled) ? !!b.enabled : void 0,
        displayName: Le(b.displayName) ? String(b.displayName) : void 0,
        participantId: Le(b.participantId) ? String(b.participantId) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.enabled !== void 0 && (C.enabled = b.enabled), b.displayName !== void 0 && (C.displayName = b.displayName), b.participantId !== void 0 && (C.participantId = b.participantId), C;
    },
    fromPartial(b) {
      var C, A, Se;
      const te = er();
      return te.enabled = (C = b.enabled) !== null && C !== void 0 ? C : void 0, te.displayName = (A = b.displayName) !== null && A !== void 0 ? A : void 0, te.participantId = (Se = b.participantId) !== null && Se !== void 0 ? Se : void 0, te;
    }
  };
  function tr() {
    return {
      region: "",
      bucket: "",
      prefix: void 0,
      accessKey: "",
      secretKey: "",
      token: void 0,
      tokenDuration: void 0,
      acl: void 0,
      endpoint: void 0,
      packaging: void 0
    };
  }
  a.S3StorageAddress = {
    encode(b, C = c.default.Writer.create()) {
      return b.region !== "" && C.uint32(10).string(b.region), b.bucket !== "" && C.uint32(18).string(b.bucket), b.prefix !== void 0 && C.uint32(26).string(b.prefix), b.accessKey !== "" && C.uint32(34).string(b.accessKey), b.secretKey !== "" && C.uint32(42).string(b.secretKey), b.token !== void 0 && C.uint32(50).string(b.token), b.tokenDuration !== void 0 && C.uint32(56).int32(b.tokenDuration), b.acl !== void 0 && C.uint32(64).int32(Ge(b.acl)), b.endpoint !== void 0 && C.uint32(74).string(b.endpoint), b.packaging !== void 0 && a.ObjectStoragePackaging.encode(b.packaging, C.uint32(82).fork()).ldelim(), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = tr();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.region = A.string();
            break;
          case 2:
            te.bucket = A.string();
            break;
          case 3:
            te.prefix = A.string();
            break;
          case 4:
            te.accessKey = A.string();
            break;
          case 5:
            te.secretKey = A.string();
            break;
          case 6:
            te.token = A.string();
            break;
          case 7:
            te.tokenDuration = A.int32();
            break;
          case 8:
            te.acl = gt(A.int32());
            break;
          case 9:
            te.endpoint = A.string();
            break;
          case 10:
            te.packaging = a.ObjectStoragePackaging.decode(A, A.uint32());
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        region: Le(b.region) ? String(b.region) : "",
        bucket: Le(b.bucket) ? String(b.bucket) : "",
        prefix: Le(b.prefix) ? String(b.prefix) : void 0,
        accessKey: Le(b.accessKey) ? String(b.accessKey) : "",
        secretKey: Le(b.secretKey) ? String(b.secretKey) : "",
        token: Le(b.token) ? String(b.token) : void 0,
        tokenDuration: Le(b.tokenDuration) ? Number(b.tokenDuration) : void 0,
        acl: Le(b.acl) ? gt(b.acl) : void 0,
        endpoint: Le(b.endpoint) ? String(b.endpoint) : void 0,
        packaging: Le(b.packaging) ? a.ObjectStoragePackaging.fromJSON(b.packaging) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.region !== void 0 && (C.region = b.region), b.bucket !== void 0 && (C.bucket = b.bucket), b.prefix !== void 0 && (C.prefix = b.prefix), b.accessKey !== void 0 && (C.accessKey = b.accessKey), b.secretKey !== void 0 && (C.secretKey = b.secretKey), b.token !== void 0 && (C.token = b.token), b.tokenDuration !== void 0 && (C.tokenDuration = Math.round(b.tokenDuration)), b.acl !== void 0 && (C.acl = b.acl !== void 0 ? Xe(b.acl) : void 0), b.endpoint !== void 0 && (C.endpoint = b.endpoint), b.packaging !== void 0 && (C.packaging = b.packaging ? a.ObjectStoragePackaging.toJSON(b.packaging) : void 0), C;
    },
    fromPartial(b) {
      var C, A, Se, te, Te, vt, It, Pt, Mt;
      const qt = tr();
      return qt.region = (C = b.region) !== null && C !== void 0 ? C : "", qt.bucket = (A = b.bucket) !== null && A !== void 0 ? A : "", qt.prefix = (Se = b.prefix) !== null && Se !== void 0 ? Se : void 0, qt.accessKey = (te = b.accessKey) !== null && te !== void 0 ? te : "", qt.secretKey = (Te = b.secretKey) !== null && Te !== void 0 ? Te : "", qt.token = (vt = b.token) !== null && vt !== void 0 ? vt : void 0, qt.tokenDuration = (It = b.tokenDuration) !== null && It !== void 0 ? It : void 0, qt.acl = (Pt = b.acl) !== null && Pt !== void 0 ? Pt : void 0, qt.endpoint = (Mt = b.endpoint) !== null && Mt !== void 0 ? Mt : void 0, qt.packaging = b.packaging !== void 0 && b.packaging !== null ? a.ObjectStoragePackaging.fromPartial(b.packaging) : void 0, qt;
    }
  };
  function rr() {
    return { rtmpPush: void 0, agora: void 0, s3Storage: void 0, srtPush: void 0, webrtcPreview: void 0 };
  }
  a.DestinationAddress = {
    encode(b, C = c.default.Writer.create()) {
      return b.rtmpPush !== void 0 && a.DestinationRtmpPushAddress.encode(b.rtmpPush, C.uint32(10).fork()).ldelim(), b.agora !== void 0 && a.DestinationAgoraPushAddress.encode(b.agora, C.uint32(18).fork()).ldelim(), b.s3Storage !== void 0 && a.S3StorageAddress.encode(b.s3Storage, C.uint32(26).fork()).ldelim(), b.srtPush !== void 0 && a.DestinationSrtPushAddress.encode(b.srtPush, C.uint32(34).fork()).ldelim(), b.webrtcPreview !== void 0 && a.PreviewWebRtcAddress.encode(b.webrtcPreview, C.uint32(42).fork()).ldelim(), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = rr();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.rtmpPush = a.DestinationRtmpPushAddress.decode(A, A.uint32());
            break;
          case 2:
            te.agora = a.DestinationAgoraPushAddress.decode(A, A.uint32());
            break;
          case 3:
            te.s3Storage = a.S3StorageAddress.decode(A, A.uint32());
            break;
          case 4:
            te.srtPush = a.DestinationSrtPushAddress.decode(A, A.uint32());
            break;
          case 5:
            te.webrtcPreview = a.PreviewWebRtcAddress.decode(A, A.uint32());
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        rtmpPush: Le(b.rtmpPush) ? a.DestinationRtmpPushAddress.fromJSON(b.rtmpPush) : void 0,
        agora: Le(b.agora) ? a.DestinationAgoraPushAddress.fromJSON(b.agora) : void 0,
        s3Storage: Le(b.s3Storage) ? a.S3StorageAddress.fromJSON(b.s3Storage) : void 0,
        srtPush: Le(b.srtPush) ? a.DestinationSrtPushAddress.fromJSON(b.srtPush) : void 0,
        webrtcPreview: Le(b.webrtcPreview) ? a.PreviewWebRtcAddress.fromJSON(b.webrtcPreview) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.rtmpPush !== void 0 && (C.rtmpPush = b.rtmpPush ? a.DestinationRtmpPushAddress.toJSON(b.rtmpPush) : void 0), b.agora !== void 0 && (C.agora = b.agora ? a.DestinationAgoraPushAddress.toJSON(b.agora) : void 0), b.s3Storage !== void 0 && (C.s3Storage = b.s3Storage ? a.S3StorageAddress.toJSON(b.s3Storage) : void 0), b.srtPush !== void 0 && (C.srtPush = b.srtPush ? a.DestinationSrtPushAddress.toJSON(b.srtPush) : void 0), b.webrtcPreview !== void 0 && (C.webrtcPreview = b.webrtcPreview ? a.PreviewWebRtcAddress.toJSON(b.webrtcPreview) : void 0), C;
    },
    fromPartial(b) {
      const C = rr();
      return C.rtmpPush = b.rtmpPush !== void 0 && b.rtmpPush !== null ? a.DestinationRtmpPushAddress.fromPartial(b.rtmpPush) : void 0, C.agora = b.agora !== void 0 && b.agora !== null ? a.DestinationAgoraPushAddress.fromPartial(b.agora) : void 0, C.s3Storage = b.s3Storage !== void 0 && b.s3Storage !== null ? a.S3StorageAddress.fromPartial(b.s3Storage) : void 0, C.srtPush = b.srtPush !== void 0 && b.srtPush !== null ? a.DestinationSrtPushAddress.fromPartial(b.srtPush) : void 0, C.webrtcPreview = b.webrtcPreview !== void 0 && b.webrtcPreview !== null ? a.PreviewWebRtcAddress.fromPartial(b.webrtcPreview) : void 0, C;
    }
  };
  function nr() {
    return { sourceId: "", start: void 0, stop: void 0 };
  }
  a.SourceTrigger = {
    encode(b, C = c.default.Writer.create()) {
      return b.sourceId !== "" && C.uint32(10).string(b.sourceId), b.start !== void 0 && C.uint32(16).int32(We(b.start)), b.stop !== void 0 && C.uint32(24).int32(We(b.stop)), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = nr();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.sourceId = A.string();
            break;
          case 2:
            te.start = ye(A.int32());
            break;
          case 3:
            te.stop = ye(A.int32());
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        sourceId: Le(b.sourceId) ? String(b.sourceId) : "",
        start: Le(b.start) ? ye(b.start) : void 0,
        stop: Le(b.stop) ? ye(b.stop) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.sourceId !== void 0 && (C.sourceId = b.sourceId), b.start !== void 0 && (C.start = b.start !== void 0 ? we(b.start) : void 0), b.stop !== void 0 && (C.stop = b.stop !== void 0 ? we(b.stop) : void 0), C;
    },
    fromPartial(b) {
      var C, A, Se;
      const te = nr();
      return te.sourceId = (C = b.sourceId) !== null && C !== void 0 ? C : "", te.start = (A = b.start) !== null && A !== void 0 ? A : void 0, te.stop = (Se = b.stop) !== null && Se !== void 0 ? Se : void 0, te;
    }
  };
  function ir() {
    return { stop: void 0 };
  }
  a.WebRtcTrigger = {
    encode(b, C = c.default.Writer.create()) {
      return b.stop !== void 0 && C.uint32(24).int32(We(b.stop)), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = ir();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 3:
            te.stop = ye(A.int32());
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return { stop: Le(b.stop) ? ye(b.stop) : void 0 };
    },
    toJSON(b) {
      const C = {};
      return b.stop !== void 0 && (C.stop = b.stop !== void 0 ? we(b.stop) : void 0), C;
    },
    fromPartial(b) {
      var C;
      const A = ir();
      return A.stop = (C = b.stop) !== null && C !== void 0 ? C : void 0, A;
    }
  };
  function ar() {
    return { source: void 0 };
  }
  a.ProjectTrigger = {
    encode(b, C = c.default.Writer.create()) {
      return b.source !== void 0 && a.SourceTrigger.encode(b.source, C.uint32(10).fork()).ldelim(), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = ar();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.source = a.SourceTrigger.decode(A, A.uint32());
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return { source: Le(b.source) ? a.SourceTrigger.fromJSON(b.source) : void 0 };
    },
    toJSON(b) {
      const C = {};
      return b.source !== void 0 && (C.source = b.source ? a.SourceTrigger.toJSON(b.source) : void 0), C;
    },
    fromPartial(b) {
      const C = ar();
      return C.source = b.source !== void 0 && b.source !== null ? a.SourceTrigger.fromPartial(b.source) : void 0, C;
    }
  };
  function or() {
    return { enabled: void 0, url: void 0 };
  }
  a.PreviewHlsPullAddress = {
    encode(b, C = c.default.Writer.create()) {
      return b.enabled !== void 0 && C.uint32(8).bool(b.enabled), b.url !== void 0 && C.uint32(18).string(b.url), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = or();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.enabled = A.bool();
            break;
          case 2:
            te.url = A.string();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        enabled: Le(b.enabled) ? !!b.enabled : void 0,
        url: Le(b.url) ? String(b.url) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.enabled !== void 0 && (C.enabled = b.enabled), b.url !== void 0 && (C.url = b.url), C;
    },
    fromPartial(b) {
      var C, A;
      const Se = or();
      return Se.enabled = (C = b.enabled) !== null && C !== void 0 ? C : void 0, Se.url = (A = b.url) !== null && A !== void 0 ? A : void 0, Se;
    }
  };
  function dr() {
    return { webrtc: void 0 };
  }
  a.PreviewAddress = {
    encode(b, C = c.default.Writer.create()) {
      return b.webrtc !== void 0 && a.PreviewWebRtcAddress.encode(b.webrtc, C.uint32(18).fork()).ldelim(), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = dr();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 2:
            te.webrtc = a.PreviewWebRtcAddress.decode(A, A.uint32());
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return { webrtc: Le(b.webrtc) ? a.PreviewWebRtcAddress.fromJSON(b.webrtc) : void 0 };
    },
    toJSON(b) {
      const C = {};
      return b.webrtc !== void 0 && (C.webrtc = b.webrtc ? a.PreviewWebRtcAddress.toJSON(b.webrtc) : void 0), C;
    },
    fromPartial(b) {
      const C = dr();
      return C.webrtc = b.webrtc !== void 0 && b.webrtc !== null ? a.PreviewWebRtcAddress.fromPartial(b.webrtc) : void 0, C;
    }
  };
  function ur() {
    return { rendererUrl: void 0, version: void 0 };
  }
  a.StudioSdkComposition = {
    encode(b, C = c.default.Writer.create()) {
      return b.rendererUrl !== void 0 && C.uint32(10).string(b.rendererUrl), b.version !== void 0 && C.uint32(18).string(b.version), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = ur();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.rendererUrl = A.string();
            break;
          case 2:
            te.version = A.string();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        rendererUrl: Le(b.rendererUrl) ? String(b.rendererUrl) : void 0,
        version: Le(b.version) ? String(b.version) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.rendererUrl !== void 0 && (C.rendererUrl = b.rendererUrl), b.version !== void 0 && (C.version = b.version), C;
    },
    fromPartial(b) {
      var C, A;
      const Se = ur();
      return Se.rendererUrl = (C = b.rendererUrl) !== null && C !== void 0 ? C : void 0, Se.version = (A = b.version) !== null && A !== void 0 ? A : void 0, Se;
    }
  };
  function cr() {
    return { rendererUrl: void 0, selectedLayoutId: void 0, debug: void 0 };
  }
  a.SceneComposition = {
    encode(b, C = c.default.Writer.create()) {
      return b.rendererUrl !== void 0 && C.uint32(10).string(b.rendererUrl), b.selectedLayoutId !== void 0 && C.uint32(18).string(b.selectedLayoutId), b.debug !== void 0 && C.uint32(24).bool(b.debug), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = cr();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.rendererUrl = A.string();
            break;
          case 2:
            te.selectedLayoutId = A.string();
            break;
          case 3:
            te.debug = A.bool();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        rendererUrl: Le(b.rendererUrl) ? String(b.rendererUrl) : void 0,
        selectedLayoutId: Le(b.selectedLayoutId) ? String(b.selectedLayoutId) : void 0,
        debug: Le(b.debug) ? !!b.debug : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.rendererUrl !== void 0 && (C.rendererUrl = b.rendererUrl), b.selectedLayoutId !== void 0 && (C.selectedLayoutId = b.selectedLayoutId), b.debug !== void 0 && (C.debug = b.debug), C;
    },
    fromPartial(b) {
      var C, A, Se;
      const te = cr();
      return te.rendererUrl = (C = b.rendererUrl) !== null && C !== void 0 ? C : void 0, te.selectedLayoutId = (A = b.selectedLayoutId) !== null && A !== void 0 ? A : void 0, te.debug = (Se = b.debug) !== null && Se !== void 0 ? Se : void 0, te;
    }
  };
  function lr() {
    return { url: "" };
  }
  a.ExternalComposition = {
    encode(b, C = c.default.Writer.create()) {
      return b.url !== "" && C.uint32(10).string(b.url), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = lr();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.url = A.string();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return { url: Le(b.url) ? String(b.url) : "" };
    },
    toJSON(b) {
      const C = {};
      return b.url !== void 0 && (C.url = b.url), C;
    },
    fromPartial(b) {
      var C;
      const A = lr();
      return A.url = (C = b.url) !== null && C !== void 0 ? C : "", A;
    }
  };
  function fr() {
    return { external: void 0, studioSdk: void 0, scene: void 0 };
  }
  a.Composition = {
    encode(b, C = c.default.Writer.create()) {
      return b.external !== void 0 && a.ExternalComposition.encode(b.external, C.uint32(10).fork()).ldelim(), b.studioSdk !== void 0 && a.StudioSdkComposition.encode(b.studioSdk, C.uint32(18).fork()).ldelim(), b.scene !== void 0 && a.SceneComposition.encode(b.scene, C.uint32(34).fork()).ldelim(), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = fr();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.external = a.ExternalComposition.decode(A, A.uint32());
            break;
          case 2:
            te.studioSdk = a.StudioSdkComposition.decode(A, A.uint32());
            break;
          case 4:
            te.scene = a.SceneComposition.decode(A, A.uint32());
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        external: Le(b.external) ? a.ExternalComposition.fromJSON(b.external) : void 0,
        studioSdk: Le(b.studioSdk) ? a.StudioSdkComposition.fromJSON(b.studioSdk) : void 0,
        scene: Le(b.scene) ? a.SceneComposition.fromJSON(b.scene) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.external !== void 0 && (C.external = b.external ? a.ExternalComposition.toJSON(b.external) : void 0), b.studioSdk !== void 0 && (C.studioSdk = b.studioSdk ? a.StudioSdkComposition.toJSON(b.studioSdk) : void 0), b.scene !== void 0 && (C.scene = b.scene ? a.SceneComposition.toJSON(b.scene) : void 0), C;
    },
    fromPartial(b) {
      const C = fr();
      return C.external = b.external !== void 0 && b.external !== null ? a.ExternalComposition.fromPartial(b.external) : void 0, C.studioSdk = b.studioSdk !== void 0 && b.studioSdk !== null ? a.StudioSdkComposition.fromPartial(b.studioSdk) : void 0, C.scene = b.scene !== void 0 && b.scene !== null ? a.SceneComposition.fromPartial(b.scene) : void 0, C;
    }
  };
  function pr() {
    return { enabled: void 0 };
  }
  a.HostedWebRtc = {
    encode(b, C = c.default.Writer.create()) {
      return b.enabled !== void 0 && C.uint32(8).bool(b.enabled), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = pr();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.enabled = A.bool();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return { enabled: Le(b.enabled) ? !!b.enabled : void 0 };
    },
    toJSON(b) {
      const C = {};
      return b.enabled !== void 0 && (C.enabled = b.enabled), C;
    },
    fromPartial(b) {
      var C;
      const A = pr();
      return A.enabled = (C = b.enabled) !== null && C !== void 0 ? C : void 0, A;
    }
  };
  function vr() {
    return { hosted: void 0 };
  }
  a.WebRtc = {
    encode(b, C = c.default.Writer.create()) {
      return b.hosted !== void 0 && a.HostedWebRtc.encode(b.hosted, C.uint32(10).fork()).ldelim(), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = vr();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.hosted = a.HostedWebRtc.decode(A, A.uint32());
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return { hosted: Le(b.hosted) ? a.HostedWebRtc.fromJSON(b.hosted) : void 0 };
    },
    toJSON(b) {
      const C = {};
      return b.hosted !== void 0 && (C.hosted = b.hosted ? a.HostedWebRtc.toJSON(b.hosted) : void 0), C;
    },
    fromPartial(b) {
      const C = vr();
      return C.hosted = b.hosted !== void 0 && b.hosted !== null ? a.HostedWebRtc.fromPartial(b.hosted) : void 0, C;
    }
  };
  function yr() {
    return { accessToken: "", participantId: void 0 };
  }
  a.WebRtcAccess = {
    encode(b, C = c.default.Writer.create()) {
      return b.accessToken !== "" && C.uint32(10).string(b.accessToken), b.participantId !== void 0 && C.uint32(26).string(b.participantId), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = yr();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.accessToken = A.string();
            break;
          case 3:
            te.participantId = A.string();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        accessToken: Le(b.accessToken) ? String(b.accessToken) : "",
        participantId: Le(b.participantId) ? String(b.participantId) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.accessToken !== void 0 && (C.accessToken = b.accessToken), b.participantId !== void 0 && (C.participantId = b.participantId), C;
    },
    fromPartial(b) {
      var C, A;
      const Se = yr();
      return Se.accessToken = (C = b.accessToken) !== null && C !== void 0 ? C : "", Se.participantId = (A = b.participantId) !== null && A !== void 0 ? A : void 0, Se;
    }
  };
  function gr() {
    return { latitude: 0, longitude: 0 };
  }
  a.LatLong = {
    encode(b, C = c.default.Writer.create()) {
      return b.latitude !== 0 && C.uint32(9).double(b.latitude), b.longitude !== 0 && C.uint32(17).double(b.longitude), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = gr();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.latitude = A.double();
            break;
          case 2:
            te.longitude = A.double();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        latitude: Le(b.latitude) ? Number(b.latitude) : 0,
        longitude: Le(b.longitude) ? Number(b.longitude) : 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.latitude !== void 0 && (C.latitude = b.latitude), b.longitude !== void 0 && (C.longitude = b.longitude), C;
    },
    fromPartial(b) {
      var C, A;
      const Se = gr();
      return Se.latitude = (C = b.latitude) !== null && C !== void 0 ? C : 0, Se.longitude = (A = b.longitude) !== null && A !== void 0 ? A : 0, Se;
    }
  };
  function br() {
    return { dynamicId: void 0, sourceId: void 0, rtmpPush: void 0, srtPush: void 0 };
  }
  a.DirectIngestUrl = {
    encode(b, C = c.default.Writer.create()) {
      return b.dynamicId !== void 0 && C.uint32(10).string(b.dynamicId), b.sourceId !== void 0 && C.uint32(18).string(b.sourceId), b.rtmpPush !== void 0 && a.SourceRtmpPushAddress.encode(b.rtmpPush, C.uint32(82).fork()).ldelim(), b.srtPush !== void 0 && a.SrtPushAddress.encode(b.srtPush, C.uint32(90).fork()).ldelim(), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = br();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.dynamicId = A.string();
            break;
          case 2:
            te.sourceId = A.string();
            break;
          case 10:
            te.rtmpPush = a.SourceRtmpPushAddress.decode(A, A.uint32());
            break;
          case 11:
            te.srtPush = a.SrtPushAddress.decode(A, A.uint32());
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        dynamicId: Le(b.dynamicId) ? String(b.dynamicId) : void 0,
        sourceId: Le(b.sourceId) ? String(b.sourceId) : void 0,
        rtmpPush: Le(b.rtmpPush) ? a.SourceRtmpPushAddress.fromJSON(b.rtmpPush) : void 0,
        srtPush: Le(b.srtPush) ? a.SrtPushAddress.fromJSON(b.srtPush) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.dynamicId !== void 0 && (C.dynamicId = b.dynamicId), b.sourceId !== void 0 && (C.sourceId = b.sourceId), b.rtmpPush !== void 0 && (C.rtmpPush = b.rtmpPush ? a.SourceRtmpPushAddress.toJSON(b.rtmpPush) : void 0), b.srtPush !== void 0 && (C.srtPush = b.srtPush ? a.SrtPushAddress.toJSON(b.srtPush) : void 0), C;
    },
    fromPartial(b) {
      var C, A;
      const Se = br();
      return Se.dynamicId = (C = b.dynamicId) !== null && C !== void 0 ? C : void 0, Se.sourceId = (A = b.sourceId) !== null && A !== void 0 ? A : void 0, Se.rtmpPush = b.rtmpPush !== void 0 && b.rtmpPush !== null ? a.SourceRtmpPushAddress.fromPartial(b.rtmpPush) : void 0, Se.srtPush = b.srtPush !== void 0 && b.srtPush !== null ? a.SrtPushAddress.fromPartial(b.srtPush) : void 0, Se;
    }
  };
  function Sr() {
    return {
      collectionId: "",
      projectId: "",
      broadcastId: void 0,
      duration: void 0,
      start: void 0,
      stop: void 0,
      phase: De.PROJECT_BROADCAST_PHASE_UNSPECIFIED,
      region: void 0,
      datacenter: void 0,
      directIngests: [],
      origin: void 0,
      originApiMetadata: void 0,
      originSourceMetadata: void 0,
      originExternalMetadata: void 0
    };
  }
  a.ProjectBroadcastStatus = {
    encode(b, C = c.default.Writer.create()) {
      b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.projectId !== "" && C.uint32(18).string(b.projectId), b.broadcastId !== void 0 && C.uint32(26).string(b.broadcastId), b.duration !== void 0 && C.uint32(32).uint32(b.duration), b.start !== void 0 && _.Timestamp.encode(Ht(b.start), C.uint32(42).fork()).ldelim(), b.stop !== void 0 && _.Timestamp.encode(Ht(b.stop), C.uint32(50).fork()).ldelim(), b.phase !== De.PROJECT_BROADCAST_PHASE_UNSPECIFIED && C.uint32(56).int32(Ze(b.phase)), b.region !== void 0 && C.uint32(64).int32(de(b.region)), b.datacenter !== void 0 && C.uint32(74).string(b.datacenter);
      for (const A of b.directIngests)
        a.DirectIngestUrl.encode(A, C.uint32(82).fork()).ldelim();
      return b.origin !== void 0 && C.uint32(88).int32(F(b.origin)), b.originApiMetadata !== void 0 && p.Value.encode(p.Value.wrap(b.originApiMetadata), C.uint32(98).fork()).ldelim(), b.originSourceMetadata !== void 0 && a.BroadcastOriginSourceMetadata.encode(b.originSourceMetadata, C.uint32(106).fork()).ldelim(), b.originExternalMetadata !== void 0 && a.BroadcastOriginExternalMetadata.encode(b.originExternalMetadata, C.uint32(114).fork()).ldelim(), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Sr();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.collectionId = A.string();
            break;
          case 2:
            te.projectId = A.string();
            break;
          case 3:
            te.broadcastId = A.string();
            break;
          case 4:
            te.duration = A.uint32();
            break;
          case 5:
            te.start = zt(_.Timestamp.decode(A, A.uint32()));
            break;
          case 6:
            te.stop = zt(_.Timestamp.decode(A, A.uint32()));
            break;
          case 7:
            te.phase = Ne(A.int32());
            break;
          case 8:
            te.region = q(A.int32());
            break;
          case 9:
            te.datacenter = A.string();
            break;
          case 10:
            te.directIngests.push(a.DirectIngestUrl.decode(A, A.uint32()));
            break;
          case 11:
            te.origin = M(A.int32());
            break;
          case 12:
            te.originApiMetadata = p.Value.unwrap(p.Value.decode(A, A.uint32()));
            break;
          case 13:
            te.originSourceMetadata = a.BroadcastOriginSourceMetadata.decode(A, A.uint32());
            break;
          case 14:
            te.originExternalMetadata = a.BroadcastOriginExternalMetadata.decode(A, A.uint32());
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : "",
        broadcastId: Le(b.broadcastId) ? String(b.broadcastId) : void 0,
        duration: Le(b.duration) ? Number(b.duration) : void 0,
        start: Le(b.start) ? String(b.start) : void 0,
        stop: Le(b.stop) ? String(b.stop) : void 0,
        phase: Le(b.phase) ? Ne(b.phase) : De.PROJECT_BROADCAST_PHASE_UNSPECIFIED,
        region: Le(b.region) ? q(b.region) : void 0,
        datacenter: Le(b.datacenter) ? String(b.datacenter) : void 0,
        directIngests: Array.isArray(b == null ? void 0 : b.directIngests) ? b.directIngests.map((C) => a.DirectIngestUrl.fromJSON(C)) : [],
        origin: Le(b.origin) ? M(b.origin) : void 0,
        originApiMetadata: Le(b == null ? void 0 : b.originApiMetadata) ? b.originApiMetadata : void 0,
        originSourceMetadata: Le(b.originSourceMetadata) ? a.BroadcastOriginSourceMetadata.fromJSON(b.originSourceMetadata) : void 0,
        originExternalMetadata: Le(b.originExternalMetadata) ? a.BroadcastOriginExternalMetadata.fromJSON(b.originExternalMetadata) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.projectId !== void 0 && (C.projectId = b.projectId), b.broadcastId !== void 0 && (C.broadcastId = b.broadcastId), b.duration !== void 0 && (C.duration = Math.round(b.duration)), b.start !== void 0 && (C.start = b.start), b.stop !== void 0 && (C.stop = b.stop), b.phase !== void 0 && (C.phase = Fe(b.phase)), b.region !== void 0 && (C.region = b.region !== void 0 ? ke(b.region) : void 0), b.datacenter !== void 0 && (C.datacenter = b.datacenter), b.directIngests ? C.directIngests = b.directIngests.map((A) => A ? a.DirectIngestUrl.toJSON(A) : void 0) : C.directIngests = [], b.origin !== void 0 && (C.origin = b.origin !== void 0 ? L(b.origin) : void 0), b.originApiMetadata !== void 0 && (C.originApiMetadata = b.originApiMetadata), b.originSourceMetadata !== void 0 && (C.originSourceMetadata = b.originSourceMetadata ? a.BroadcastOriginSourceMetadata.toJSON(b.originSourceMetadata) : void 0), b.originExternalMetadata !== void 0 && (C.originExternalMetadata = b.originExternalMetadata ? a.BroadcastOriginExternalMetadata.toJSON(b.originExternalMetadata) : void 0), C;
    },
    fromPartial(b) {
      var C, A, Se, te, Te, vt, It, Pt, Mt, qt, Kt, Yt;
      const Jt = Sr();
      return Jt.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", Jt.projectId = (A = b.projectId) !== null && A !== void 0 ? A : "", Jt.broadcastId = (Se = b.broadcastId) !== null && Se !== void 0 ? Se : void 0, Jt.duration = (te = b.duration) !== null && te !== void 0 ? te : void 0, Jt.start = (Te = b.start) !== null && Te !== void 0 ? Te : void 0, Jt.stop = (vt = b.stop) !== null && vt !== void 0 ? vt : void 0, Jt.phase = (It = b.phase) !== null && It !== void 0 ? It : De.PROJECT_BROADCAST_PHASE_UNSPECIFIED, Jt.region = (Pt = b.region) !== null && Pt !== void 0 ? Pt : void 0, Jt.datacenter = (Mt = b.datacenter) !== null && Mt !== void 0 ? Mt : void 0, Jt.directIngests = ((qt = b.directIngests) === null || qt === void 0 ? void 0 : qt.map((Hi) => a.DirectIngestUrl.fromPartial(Hi))) || [], Jt.origin = (Kt = b.origin) !== null && Kt !== void 0 ? Kt : void 0, Jt.originApiMetadata = (Yt = b.originApiMetadata) !== null && Yt !== void 0 ? Yt : void 0, Jt.originSourceMetadata = b.originSourceMetadata !== void 0 && b.originSourceMetadata !== null ? a.BroadcastOriginSourceMetadata.fromPartial(b.originSourceMetadata) : void 0, Jt.originExternalMetadata = b.originExternalMetadata !== void 0 && b.originExternalMetadata !== null ? a.BroadcastOriginExternalMetadata.fromPartial(b.originExternalMetadata) : void 0, Jt;
    }
  };
  function _r() {
    return { collectionId: "", sourceId: "", metadata: void 0, preview: void 0, address: void 0 };
  }
  a.Source = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.sourceId !== "" && C.uint32(18).string(b.sourceId), b.metadata !== void 0 && p.Value.encode(p.Value.wrap(b.metadata), C.uint32(26).fork()).ldelim(), b.preview !== void 0 && a.PreviewAddress.encode(b.preview, C.uint32(34).fork()).ldelim(), b.address !== void 0 && a.SourceAddress.encode(b.address, C.uint32(50).fork()).ldelim(), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = _r();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.collectionId = A.string();
            break;
          case 2:
            te.sourceId = A.string();
            break;
          case 3:
            te.metadata = p.Value.unwrap(p.Value.decode(A, A.uint32()));
            break;
          case 4:
            te.preview = a.PreviewAddress.decode(A, A.uint32());
            break;
          case 6:
            te.address = a.SourceAddress.decode(A, A.uint32());
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        sourceId: Le(b.sourceId) ? String(b.sourceId) : "",
        metadata: Le(b == null ? void 0 : b.metadata) ? b.metadata : void 0,
        preview: Le(b.preview) ? a.PreviewAddress.fromJSON(b.preview) : void 0,
        address: Le(b.address) ? a.SourceAddress.fromJSON(b.address) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.sourceId !== void 0 && (C.sourceId = b.sourceId), b.metadata !== void 0 && (C.metadata = b.metadata), b.preview !== void 0 && (C.preview = b.preview ? a.PreviewAddress.toJSON(b.preview) : void 0), b.address !== void 0 && (C.address = b.address ? a.SourceAddress.toJSON(b.address) : void 0), C;
    },
    fromPartial(b) {
      var C, A, Se;
      const te = _r();
      return te.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", te.sourceId = (A = b.sourceId) !== null && A !== void 0 ? A : "", te.metadata = (Se = b.metadata) !== null && Se !== void 0 ? Se : void 0, te.preview = b.preview !== void 0 && b.preview !== null ? a.PreviewAddress.fromPartial(b.preview) : void 0, te.address = b.address !== void 0 && b.address !== null ? a.SourceAddress.fromPartial(b.address) : void 0, te;
    }
  };
  function Er() {
    return {
      collectionId: "",
      projectId: "",
      destinationId: "",
      metadata: void 0,
      enabled: void 0,
      address: void 0,
      timeout: void 0,
      outputDelay: void 0
    };
  }
  a.Destination = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.projectId !== "" && C.uint32(18).string(b.projectId), b.destinationId !== "" && C.uint32(26).string(b.destinationId), b.metadata !== void 0 && p.Value.encode(p.Value.wrap(b.metadata), C.uint32(34).fork()).ldelim(), b.enabled !== void 0 && C.uint32(40).bool(b.enabled), b.address !== void 0 && a.DestinationAddress.encode(b.address, C.uint32(50).fork()).ldelim(), b.timeout !== void 0 && C.uint32(56).uint32(b.timeout), b.outputDelay !== void 0 && C.uint32(72).uint32(b.outputDelay), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Er();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.collectionId = A.string();
            break;
          case 2:
            te.projectId = A.string();
            break;
          case 3:
            te.destinationId = A.string();
            break;
          case 4:
            te.metadata = p.Value.unwrap(p.Value.decode(A, A.uint32()));
            break;
          case 5:
            te.enabled = A.bool();
            break;
          case 6:
            te.address = a.DestinationAddress.decode(A, A.uint32());
            break;
          case 7:
            te.timeout = A.uint32();
            break;
          case 9:
            te.outputDelay = A.uint32();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : "",
        destinationId: Le(b.destinationId) ? String(b.destinationId) : "",
        metadata: Le(b == null ? void 0 : b.metadata) ? b.metadata : void 0,
        enabled: Le(b.enabled) ? !!b.enabled : void 0,
        address: Le(b.address) ? a.DestinationAddress.fromJSON(b.address) : void 0,
        timeout: Le(b.timeout) ? Number(b.timeout) : void 0,
        outputDelay: Le(b.outputDelay) ? Number(b.outputDelay) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.projectId !== void 0 && (C.projectId = b.projectId), b.destinationId !== void 0 && (C.destinationId = b.destinationId), b.metadata !== void 0 && (C.metadata = b.metadata), b.enabled !== void 0 && (C.enabled = b.enabled), b.address !== void 0 && (C.address = b.address ? a.DestinationAddress.toJSON(b.address) : void 0), b.timeout !== void 0 && (C.timeout = Math.round(b.timeout)), b.outputDelay !== void 0 && (C.outputDelay = Math.round(b.outputDelay)), C;
    },
    fromPartial(b) {
      var C, A, Se, te, Te, vt, It;
      const Pt = Er();
      return Pt.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", Pt.projectId = (A = b.projectId) !== null && A !== void 0 ? A : "", Pt.destinationId = (Se = b.destinationId) !== null && Se !== void 0 ? Se : "", Pt.metadata = (te = b.metadata) !== null && te !== void 0 ? te : void 0, Pt.enabled = (Te = b.enabled) !== null && Te !== void 0 ? Te : void 0, Pt.address = b.address !== void 0 && b.address !== null ? a.DestinationAddress.fromPartial(b.address) : void 0, Pt.timeout = (vt = b.timeout) !== null && vt !== void 0 ? vt : void 0, Pt.outputDelay = (It = b.outputDelay) !== null && It !== void 0 ? It : void 0, Pt;
    }
  };
  function Tr() {
    return {
      collectionId: "",
      projectId: "",
      metadata: void 0,
      rendering: void 0,
      encoding: void 0,
      sources: [],
      destinations: [],
      composition: void 0,
      maxDuration: void 0,
      webrtc: void 0,
      triggers: [],
      location: void 0,
      guestCodes: []
    };
  }
  a.Project = {
    encode(b, C = c.default.Writer.create()) {
      b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.projectId !== "" && C.uint32(18).string(b.projectId), b.metadata !== void 0 && p.Value.encode(p.Value.wrap(b.metadata), C.uint32(26).fork()).ldelim(), b.rendering !== void 0 && a.Rendering.encode(b.rendering, C.uint32(34).fork()).ldelim(), b.encoding !== void 0 && a.Encoding.encode(b.encoding, C.uint32(42).fork()).ldelim();
      for (const A of b.sources)
        a.Source.encode(A, C.uint32(50).fork()).ldelim();
      for (const A of b.destinations)
        a.Destination.encode(A, C.uint32(58).fork()).ldelim();
      b.composition !== void 0 && a.Composition.encode(b.composition, C.uint32(66).fork()).ldelim(), b.maxDuration !== void 0 && C.uint32(72).uint32(b.maxDuration), b.webrtc !== void 0 && a.WebRtc.encode(b.webrtc, C.uint32(82).fork()).ldelim();
      for (const A of b.triggers)
        a.ProjectTrigger.encode(A, C.uint32(90).fork()).ldelim();
      b.location !== void 0 && a.LatLong.encode(b.location, C.uint32(98).fork()).ldelim();
      for (const A of b.guestCodes)
        a.GuestCode.encode(A, C.uint32(106).fork()).ldelim();
      return C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Tr();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.collectionId = A.string();
            break;
          case 2:
            te.projectId = A.string();
            break;
          case 3:
            te.metadata = p.Value.unwrap(p.Value.decode(A, A.uint32()));
            break;
          case 4:
            te.rendering = a.Rendering.decode(A, A.uint32());
            break;
          case 5:
            te.encoding = a.Encoding.decode(A, A.uint32());
            break;
          case 6:
            te.sources.push(a.Source.decode(A, A.uint32()));
            break;
          case 7:
            te.destinations.push(a.Destination.decode(A, A.uint32()));
            break;
          case 8:
            te.composition = a.Composition.decode(A, A.uint32());
            break;
          case 9:
            te.maxDuration = A.uint32();
            break;
          case 10:
            te.webrtc = a.WebRtc.decode(A, A.uint32());
            break;
          case 11:
            te.triggers.push(a.ProjectTrigger.decode(A, A.uint32()));
            break;
          case 12:
            te.location = a.LatLong.decode(A, A.uint32());
            break;
          case 13:
            te.guestCodes.push(a.GuestCode.decode(A, A.uint32()));
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : "",
        metadata: Le(b == null ? void 0 : b.metadata) ? b.metadata : void 0,
        rendering: Le(b.rendering) ? a.Rendering.fromJSON(b.rendering) : void 0,
        encoding: Le(b.encoding) ? a.Encoding.fromJSON(b.encoding) : void 0,
        sources: Array.isArray(b == null ? void 0 : b.sources) ? b.sources.map((C) => a.Source.fromJSON(C)) : [],
        destinations: Array.isArray(b == null ? void 0 : b.destinations) ? b.destinations.map((C) => a.Destination.fromJSON(C)) : [],
        composition: Le(b.composition) ? a.Composition.fromJSON(b.composition) : void 0,
        maxDuration: Le(b.maxDuration) ? Number(b.maxDuration) : void 0,
        webrtc: Le(b.webrtc) ? a.WebRtc.fromJSON(b.webrtc) : void 0,
        triggers: Array.isArray(b == null ? void 0 : b.triggers) ? b.triggers.map((C) => a.ProjectTrigger.fromJSON(C)) : [],
        location: Le(b.location) ? a.LatLong.fromJSON(b.location) : void 0,
        guestCodes: Array.isArray(b == null ? void 0 : b.guestCodes) ? b.guestCodes.map((C) => a.GuestCode.fromJSON(C)) : []
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.projectId !== void 0 && (C.projectId = b.projectId), b.metadata !== void 0 && (C.metadata = b.metadata), b.rendering !== void 0 && (C.rendering = b.rendering ? a.Rendering.toJSON(b.rendering) : void 0), b.encoding !== void 0 && (C.encoding = b.encoding ? a.Encoding.toJSON(b.encoding) : void 0), b.sources ? C.sources = b.sources.map((A) => A ? a.Source.toJSON(A) : void 0) : C.sources = [], b.destinations ? C.destinations = b.destinations.map((A) => A ? a.Destination.toJSON(A) : void 0) : C.destinations = [], b.composition !== void 0 && (C.composition = b.composition ? a.Composition.toJSON(b.composition) : void 0), b.maxDuration !== void 0 && (C.maxDuration = Math.round(b.maxDuration)), b.webrtc !== void 0 && (C.webrtc = b.webrtc ? a.WebRtc.toJSON(b.webrtc) : void 0), b.triggers ? C.triggers = b.triggers.map((A) => A ? a.ProjectTrigger.toJSON(A) : void 0) : C.triggers = [], b.location !== void 0 && (C.location = b.location ? a.LatLong.toJSON(b.location) : void 0), b.guestCodes ? C.guestCodes = b.guestCodes.map((A) => A ? a.GuestCode.toJSON(A) : void 0) : C.guestCodes = [], C;
    },
    fromPartial(b) {
      var C, A, Se, te, Te, vt, It, Pt;
      const Mt = Tr();
      return Mt.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", Mt.projectId = (A = b.projectId) !== null && A !== void 0 ? A : "", Mt.metadata = (Se = b.metadata) !== null && Se !== void 0 ? Se : void 0, Mt.rendering = b.rendering !== void 0 && b.rendering !== null ? a.Rendering.fromPartial(b.rendering) : void 0, Mt.encoding = b.encoding !== void 0 && b.encoding !== null ? a.Encoding.fromPartial(b.encoding) : void 0, Mt.sources = ((te = b.sources) === null || te === void 0 ? void 0 : te.map((qt) => a.Source.fromPartial(qt))) || [], Mt.destinations = ((Te = b.destinations) === null || Te === void 0 ? void 0 : Te.map((qt) => a.Destination.fromPartial(qt))) || [], Mt.composition = b.composition !== void 0 && b.composition !== null ? a.Composition.fromPartial(b.composition) : void 0, Mt.maxDuration = (vt = b.maxDuration) !== null && vt !== void 0 ? vt : void 0, Mt.webrtc = b.webrtc !== void 0 && b.webrtc !== null ? a.WebRtc.fromPartial(b.webrtc) : void 0, Mt.triggers = ((It = b.triggers) === null || It === void 0 ? void 0 : It.map((qt) => a.ProjectTrigger.fromPartial(qt))) || [], Mt.location = b.location !== void 0 && b.location !== null ? a.LatLong.fromPartial(b.location) : void 0, Mt.guestCodes = ((Pt = b.guestCodes) === null || Pt === void 0 ? void 0 : Pt.map((qt) => a.GuestCode.fromPartial(qt))) || [], Mt;
    }
  };
  function kr() {
    return { collectionId: "", metadata: void 0, projects: [], sources: [] };
  }
  a.Collection = {
    encode(b, C = c.default.Writer.create()) {
      b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.metadata !== void 0 && p.Value.encode(p.Value.wrap(b.metadata), C.uint32(18).fork()).ldelim();
      for (const A of b.projects)
        a.Project.encode(A, C.uint32(26).fork()).ldelim();
      for (const A of b.sources)
        a.Source.encode(A, C.uint32(34).fork()).ldelim();
      return C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = kr();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.collectionId = A.string();
            break;
          case 2:
            te.metadata = p.Value.unwrap(p.Value.decode(A, A.uint32()));
            break;
          case 3:
            te.projects.push(a.Project.decode(A, A.uint32()));
            break;
          case 4:
            te.sources.push(a.Source.decode(A, A.uint32()));
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        metadata: Le(b == null ? void 0 : b.metadata) ? b.metadata : void 0,
        projects: Array.isArray(b == null ? void 0 : b.projects) ? b.projects.map((C) => a.Project.fromJSON(C)) : [],
        sources: Array.isArray(b == null ? void 0 : b.sources) ? b.sources.map((C) => a.Source.fromJSON(C)) : []
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.metadata !== void 0 && (C.metadata = b.metadata), b.projects ? C.projects = b.projects.map((A) => A ? a.Project.toJSON(A) : void 0) : C.projects = [], b.sources ? C.sources = b.sources.map((A) => A ? a.Source.toJSON(A) : void 0) : C.sources = [], C;
    },
    fromPartial(b) {
      var C, A, Se, te;
      const Te = kr();
      return Te.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", Te.metadata = (A = b.metadata) !== null && A !== void 0 ? A : void 0, Te.projects = ((Se = b.projects) === null || Se === void 0 ? void 0 : Se.map((vt) => a.Project.fromPartial(vt))) || [], Te.sources = ((te = b.sources) === null || te === void 0 ? void 0 : te.map((vt) => a.Source.fromPartial(vt))) || [], Te;
    }
  };
  function wr() {
    return { metadata: void 0 };
  }
  a.CreateCollectionRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.metadata !== void 0 && p.Value.encode(p.Value.wrap(b.metadata), C.uint32(10).fork()).ldelim(), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = wr();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.metadata = p.Value.unwrap(p.Value.decode(A, A.uint32()));
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return { metadata: Le(b == null ? void 0 : b.metadata) ? b.metadata : void 0 };
    },
    toJSON(b) {
      const C = {};
      return b.metadata !== void 0 && (C.metadata = b.metadata), C;
    },
    fromPartial(b) {
      var C;
      const A = wr();
      return A.metadata = (C = b.metadata) !== null && C !== void 0 ? C : void 0, A;
    }
  };
  function Ir() {
    return { collection: void 0 };
  }
  a.CreateCollectionResponse = {
    encode(b, C = c.default.Writer.create()) {
      return b.collection !== void 0 && a.Collection.encode(b.collection, C.uint32(10).fork()).ldelim(), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Ir();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.collection = a.Collection.decode(A, A.uint32());
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return { collection: Le(b.collection) ? a.Collection.fromJSON(b.collection) : void 0 };
    },
    toJSON(b) {
      const C = {};
      return b.collection !== void 0 && (C.collection = b.collection ? a.Collection.toJSON(b.collection) : void 0), C;
    },
    fromPartial(b) {
      const C = Ir();
      return C.collection = b.collection !== void 0 && b.collection !== null ? a.Collection.fromPartial(b.collection) : void 0, C;
    }
  };
  function Rr() {
    return { collectionId: "", populateProjects: void 0, populateSources: void 0 };
  }
  a.GetCollectionRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.populateProjects !== void 0 && C.uint32(16).bool(b.populateProjects), b.populateSources !== void 0 && C.uint32(24).bool(b.populateSources), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Rr();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.collectionId = A.string();
            break;
          case 2:
            te.populateProjects = A.bool();
            break;
          case 3:
            te.populateSources = A.bool();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        populateProjects: Le(b.populateProjects) ? !!b.populateProjects : void 0,
        populateSources: Le(b.populateSources) ? !!b.populateSources : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.populateProjects !== void 0 && (C.populateProjects = b.populateProjects), b.populateSources !== void 0 && (C.populateSources = b.populateSources), C;
    },
    fromPartial(b) {
      var C, A, Se;
      const te = Rr();
      return te.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", te.populateProjects = (A = b.populateProjects) !== null && A !== void 0 ? A : void 0, te.populateSources = (Se = b.populateSources) !== null && Se !== void 0 ? Se : void 0, te;
    }
  };
  function Cr() {
    return { collection: void 0 };
  }
  a.GetCollectionResponse = {
    encode(b, C = c.default.Writer.create()) {
      return b.collection !== void 0 && a.Collection.encode(b.collection, C.uint32(10).fork()).ldelim(), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Cr();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.collection = a.Collection.decode(A, A.uint32());
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return { collection: Le(b.collection) ? a.Collection.fromJSON(b.collection) : void 0 };
    },
    toJSON(b) {
      const C = {};
      return b.collection !== void 0 && (C.collection = b.collection ? a.Collection.toJSON(b.collection) : void 0), C;
    },
    fromPartial(b) {
      const C = Cr();
      return C.collection = b.collection !== void 0 && b.collection !== null ? a.Collection.fromPartial(b.collection) : void 0, C;
    }
  };
  function Pr() {
    return { collectionId: "", updateMask: void 0, metadata: void 0 };
  }
  a.UpdateCollectionRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.updateMask !== void 0 && v.FieldMask.encode(v.FieldMask.wrap(b.updateMask), C.uint32(18).fork()).ldelim(), b.metadata !== void 0 && p.Value.encode(p.Value.wrap(b.metadata), C.uint32(26).fork()).ldelim(), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Pr();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.collectionId = A.string();
            break;
          case 2:
            te.updateMask = v.FieldMask.unwrap(v.FieldMask.decode(A, A.uint32()));
            break;
          case 3:
            te.metadata = p.Value.unwrap(p.Value.decode(A, A.uint32()));
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        updateMask: Le(b.updateMask) ? v.FieldMask.unwrap(v.FieldMask.fromJSON(b.updateMask)) : void 0,
        metadata: Le(b == null ? void 0 : b.metadata) ? b.metadata : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.updateMask !== void 0 && (C.updateMask = v.FieldMask.toJSON(v.FieldMask.wrap(b.updateMask))), b.metadata !== void 0 && (C.metadata = b.metadata), C;
    },
    fromPartial(b) {
      var C, A, Se;
      const te = Pr();
      return te.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", te.updateMask = (A = b.updateMask) !== null && A !== void 0 ? A : void 0, te.metadata = (Se = b.metadata) !== null && Se !== void 0 ? Se : void 0, te;
    }
  };
  function Or() {
    return { collection: void 0 };
  }
  a.UpdateCollectionResponse = {
    encode(b, C = c.default.Writer.create()) {
      return b.collection !== void 0 && a.Collection.encode(b.collection, C.uint32(10).fork()).ldelim(), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Or();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.collection = a.Collection.decode(A, A.uint32());
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return { collection: Le(b.collection) ? a.Collection.fromJSON(b.collection) : void 0 };
    },
    toJSON(b) {
      const C = {};
      return b.collection !== void 0 && (C.collection = b.collection ? a.Collection.toJSON(b.collection) : void 0), C;
    },
    fromPartial(b) {
      const C = Or();
      return C.collection = b.collection !== void 0 && b.collection !== null ? a.Collection.fromPartial(b.collection) : void 0, C;
    }
  };
  function Mr() {
    return { collectionId: "", force: void 0 };
  }
  a.DeleteCollectionRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.force !== void 0 && C.uint32(16).bool(b.force), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Mr();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.collectionId = A.string();
            break;
          case 2:
            te.force = A.bool();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        force: Le(b.force) ? !!b.force : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.force !== void 0 && (C.force = b.force), C;
    },
    fromPartial(b) {
      var C, A;
      const Se = Mr();
      return Se.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", Se.force = (A = b.force) !== null && A !== void 0 ? A : void 0, Se;
    }
  };
  function Nr() {
    return { sourcesDeleted: 0, projectsDeleted: 0, projectIdsStopped: [] };
  }
  a.DeleteCollectionResponse = {
    encode(b, C = c.default.Writer.create()) {
      b.sourcesDeleted !== 0 && C.uint32(8).uint32(b.sourcesDeleted), b.projectsDeleted !== 0 && C.uint32(16).uint32(b.projectsDeleted);
      for (const A of b.projectIdsStopped)
        C.uint32(26).string(A);
      return C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Nr();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.sourcesDeleted = A.uint32();
            break;
          case 2:
            te.projectsDeleted = A.uint32();
            break;
          case 3:
            te.projectIdsStopped.push(A.string());
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        sourcesDeleted: Le(b.sourcesDeleted) ? Number(b.sourcesDeleted) : 0,
        projectsDeleted: Le(b.projectsDeleted) ? Number(b.projectsDeleted) : 0,
        projectIdsStopped: Array.isArray(b == null ? void 0 : b.projectIdsStopped) ? b.projectIdsStopped.map((C) => String(C)) : []
      };
    },
    toJSON(b) {
      const C = {};
      return b.sourcesDeleted !== void 0 && (C.sourcesDeleted = Math.round(b.sourcesDeleted)), b.projectsDeleted !== void 0 && (C.projectsDeleted = Math.round(b.projectsDeleted)), b.projectIdsStopped ? C.projectIdsStopped = b.projectIdsStopped.map((A) => A) : C.projectIdsStopped = [], C;
    },
    fromPartial(b) {
      var C, A, Se;
      const te = Nr();
      return te.sourcesDeleted = (C = b.sourcesDeleted) !== null && C !== void 0 ? C : 0, te.projectsDeleted = (A = b.projectsDeleted) !== null && A !== void 0 ? A : 0, te.projectIdsStopped = ((Se = b.projectIdsStopped) === null || Se === void 0 ? void 0 : Se.map((Te) => Te)) || [], te;
    }
  };
  function Ar() {
    return {};
  }
  a.GetCollectionsRequest = {
    encode(b, C = c.default.Writer.create()) {
      return C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Ar();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {};
    },
    toJSON(b) {
      return {};
    },
    fromPartial(b) {
      return Ar();
    }
  };
  function $r() {
    return { collections: [] };
  }
  a.GetCollectionsResponse = {
    encode(b, C = c.default.Writer.create()) {
      for (const A of b.collections)
        a.Collection.encode(A, C.uint32(10).fork()).ldelim();
      return C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = $r();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.collections.push(a.Collection.decode(A, A.uint32()));
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        collections: Array.isArray(b == null ? void 0 : b.collections) ? b.collections.map((C) => a.Collection.fromJSON(C)) : []
      };
    },
    toJSON(b) {
      const C = {};
      return b.collections ? C.collections = b.collections.map((A) => A ? a.Collection.toJSON(A) : void 0) : C.collections = [], C;
    },
    fromPartial(b) {
      var C;
      const A = $r();
      return A.collections = ((C = b.collections) === null || C === void 0 ? void 0 : C.map((Se) => a.Collection.fromPartial(Se))) || [], A;
    }
  };
  function Dr() {
    return {
      collectionId: "",
      metadata: void 0,
      rendering: void 0,
      encoding: void 0,
      composition: void 0,
      maxDuration: void 0,
      webrtc: void 0,
      location: void 0
    };
  }
  a.CreateProjectRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.metadata !== void 0 && p.Value.encode(p.Value.wrap(b.metadata), C.uint32(18).fork()).ldelim(), b.rendering !== void 0 && a.Rendering.encode(b.rendering, C.uint32(26).fork()).ldelim(), b.encoding !== void 0 && a.Encoding.encode(b.encoding, C.uint32(34).fork()).ldelim(), b.composition !== void 0 && a.Composition.encode(b.composition, C.uint32(42).fork()).ldelim(), b.maxDuration !== void 0 && C.uint32(48).uint32(b.maxDuration), b.webrtc !== void 0 && a.WebRtc.encode(b.webrtc, C.uint32(58).fork()).ldelim(), b.location !== void 0 && a.LatLong.encode(b.location, C.uint32(74).fork()).ldelim(), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Dr();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.collectionId = A.string();
            break;
          case 2:
            te.metadata = p.Value.unwrap(p.Value.decode(A, A.uint32()));
            break;
          case 3:
            te.rendering = a.Rendering.decode(A, A.uint32());
            break;
          case 4:
            te.encoding = a.Encoding.decode(A, A.uint32());
            break;
          case 5:
            te.composition = a.Composition.decode(A, A.uint32());
            break;
          case 6:
            te.maxDuration = A.uint32();
            break;
          case 7:
            te.webrtc = a.WebRtc.decode(A, A.uint32());
            break;
          case 9:
            te.location = a.LatLong.decode(A, A.uint32());
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        metadata: Le(b == null ? void 0 : b.metadata) ? b.metadata : void 0,
        rendering: Le(b.rendering) ? a.Rendering.fromJSON(b.rendering) : void 0,
        encoding: Le(b.encoding) ? a.Encoding.fromJSON(b.encoding) : void 0,
        composition: Le(b.composition) ? a.Composition.fromJSON(b.composition) : void 0,
        maxDuration: Le(b.maxDuration) ? Number(b.maxDuration) : void 0,
        webrtc: Le(b.webrtc) ? a.WebRtc.fromJSON(b.webrtc) : void 0,
        location: Le(b.location) ? a.LatLong.fromJSON(b.location) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.metadata !== void 0 && (C.metadata = b.metadata), b.rendering !== void 0 && (C.rendering = b.rendering ? a.Rendering.toJSON(b.rendering) : void 0), b.encoding !== void 0 && (C.encoding = b.encoding ? a.Encoding.toJSON(b.encoding) : void 0), b.composition !== void 0 && (C.composition = b.composition ? a.Composition.toJSON(b.composition) : void 0), b.maxDuration !== void 0 && (C.maxDuration = Math.round(b.maxDuration)), b.webrtc !== void 0 && (C.webrtc = b.webrtc ? a.WebRtc.toJSON(b.webrtc) : void 0), b.location !== void 0 && (C.location = b.location ? a.LatLong.toJSON(b.location) : void 0), C;
    },
    fromPartial(b) {
      var C, A, Se;
      const te = Dr();
      return te.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", te.metadata = (A = b.metadata) !== null && A !== void 0 ? A : void 0, te.rendering = b.rendering !== void 0 && b.rendering !== null ? a.Rendering.fromPartial(b.rendering) : void 0, te.encoding = b.encoding !== void 0 && b.encoding !== null ? a.Encoding.fromPartial(b.encoding) : void 0, te.composition = b.composition !== void 0 && b.composition !== null ? a.Composition.fromPartial(b.composition) : void 0, te.maxDuration = (Se = b.maxDuration) !== null && Se !== void 0 ? Se : void 0, te.webrtc = b.webrtc !== void 0 && b.webrtc !== null ? a.WebRtc.fromPartial(b.webrtc) : void 0, te.location = b.location !== void 0 && b.location !== null ? a.LatLong.fromPartial(b.location) : void 0, te;
    }
  };
  function Lr() {
    return { project: void 0 };
  }
  a.CreateProjectResponse = {
    encode(b, C = c.default.Writer.create()) {
      return b.project !== void 0 && a.Project.encode(b.project, C.uint32(10).fork()).ldelim(), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Lr();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.project = a.Project.decode(A, A.uint32());
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return { project: Le(b.project) ? a.Project.fromJSON(b.project) : void 0 };
    },
    toJSON(b) {
      const C = {};
      return b.project !== void 0 && (C.project = b.project ? a.Project.toJSON(b.project) : void 0), C;
    },
    fromPartial(b) {
      const C = Lr();
      return C.project = b.project !== void 0 && b.project !== null ? a.Project.fromPartial(b.project) : void 0, C;
    }
  };
  function Br() {
    return {
      collectionId: "",
      projectId: "",
      updateMask: void 0,
      metadata: void 0,
      rendering: void 0,
      encoding: void 0,
      composition: void 0,
      maxDuration: void 0,
      webrtc: void 0,
      location: void 0
    };
  }
  a.UpdateProjectRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.projectId !== "" && C.uint32(18).string(b.projectId), b.updateMask !== void 0 && v.FieldMask.encode(v.FieldMask.wrap(b.updateMask), C.uint32(26).fork()).ldelim(), b.metadata !== void 0 && p.Value.encode(p.Value.wrap(b.metadata), C.uint32(34).fork()).ldelim(), b.rendering !== void 0 && a.Rendering.encode(b.rendering, C.uint32(42).fork()).ldelim(), b.encoding !== void 0 && a.Encoding.encode(b.encoding, C.uint32(50).fork()).ldelim(), b.composition !== void 0 && a.Composition.encode(b.composition, C.uint32(58).fork()).ldelim(), b.maxDuration !== void 0 && C.uint32(64).uint32(b.maxDuration), b.webrtc !== void 0 && a.WebRtc.encode(b.webrtc, C.uint32(74).fork()).ldelim(), b.location !== void 0 && a.LatLong.encode(b.location, C.uint32(82).fork()).ldelim(), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Br();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.collectionId = A.string();
            break;
          case 2:
            te.projectId = A.string();
            break;
          case 3:
            te.updateMask = v.FieldMask.unwrap(v.FieldMask.decode(A, A.uint32()));
            break;
          case 4:
            te.metadata = p.Value.unwrap(p.Value.decode(A, A.uint32()));
            break;
          case 5:
            te.rendering = a.Rendering.decode(A, A.uint32());
            break;
          case 6:
            te.encoding = a.Encoding.decode(A, A.uint32());
            break;
          case 7:
            te.composition = a.Composition.decode(A, A.uint32());
            break;
          case 8:
            te.maxDuration = A.uint32();
            break;
          case 9:
            te.webrtc = a.WebRtc.decode(A, A.uint32());
            break;
          case 10:
            te.location = a.LatLong.decode(A, A.uint32());
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : "",
        updateMask: Le(b.updateMask) ? v.FieldMask.unwrap(v.FieldMask.fromJSON(b.updateMask)) : void 0,
        metadata: Le(b == null ? void 0 : b.metadata) ? b.metadata : void 0,
        rendering: Le(b.rendering) ? a.Rendering.fromJSON(b.rendering) : void 0,
        encoding: Le(b.encoding) ? a.Encoding.fromJSON(b.encoding) : void 0,
        composition: Le(b.composition) ? a.Composition.fromJSON(b.composition) : void 0,
        maxDuration: Le(b.maxDuration) ? Number(b.maxDuration) : void 0,
        webrtc: Le(b.webrtc) ? a.WebRtc.fromJSON(b.webrtc) : void 0,
        location: Le(b.location) ? a.LatLong.fromJSON(b.location) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.projectId !== void 0 && (C.projectId = b.projectId), b.updateMask !== void 0 && (C.updateMask = v.FieldMask.toJSON(v.FieldMask.wrap(b.updateMask))), b.metadata !== void 0 && (C.metadata = b.metadata), b.rendering !== void 0 && (C.rendering = b.rendering ? a.Rendering.toJSON(b.rendering) : void 0), b.encoding !== void 0 && (C.encoding = b.encoding ? a.Encoding.toJSON(b.encoding) : void 0), b.composition !== void 0 && (C.composition = b.composition ? a.Composition.toJSON(b.composition) : void 0), b.maxDuration !== void 0 && (C.maxDuration = Math.round(b.maxDuration)), b.webrtc !== void 0 && (C.webrtc = b.webrtc ? a.WebRtc.toJSON(b.webrtc) : void 0), b.location !== void 0 && (C.location = b.location ? a.LatLong.toJSON(b.location) : void 0), C;
    },
    fromPartial(b) {
      var C, A, Se, te, Te;
      const vt = Br();
      return vt.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", vt.projectId = (A = b.projectId) !== null && A !== void 0 ? A : "", vt.updateMask = (Se = b.updateMask) !== null && Se !== void 0 ? Se : void 0, vt.metadata = (te = b.metadata) !== null && te !== void 0 ? te : void 0, vt.rendering = b.rendering !== void 0 && b.rendering !== null ? a.Rendering.fromPartial(b.rendering) : void 0, vt.encoding = b.encoding !== void 0 && b.encoding !== null ? a.Encoding.fromPartial(b.encoding) : void 0, vt.composition = b.composition !== void 0 && b.composition !== null ? a.Composition.fromPartial(b.composition) : void 0, vt.maxDuration = (Te = b.maxDuration) !== null && Te !== void 0 ? Te : void 0, vt.webrtc = b.webrtc !== void 0 && b.webrtc !== null ? a.WebRtc.fromPartial(b.webrtc) : void 0, vt.location = b.location !== void 0 && b.location !== null ? a.LatLong.fromPartial(b.location) : void 0, vt;
    }
  };
  function Ur() {
    return { project: void 0, broadcastUpdated: !1 };
  }
  a.UpdateProjectResponse = {
    encode(b, C = c.default.Writer.create()) {
      return b.project !== void 0 && a.Project.encode(b.project, C.uint32(10).fork()).ldelim(), b.broadcastUpdated === !0 && C.uint32(16).bool(b.broadcastUpdated), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Ur();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.project = a.Project.decode(A, A.uint32());
            break;
          case 2:
            te.broadcastUpdated = A.bool();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        project: Le(b.project) ? a.Project.fromJSON(b.project) : void 0,
        broadcastUpdated: Le(b.broadcastUpdated) ? !!b.broadcastUpdated : !1
      };
    },
    toJSON(b) {
      const C = {};
      return b.project !== void 0 && (C.project = b.project ? a.Project.toJSON(b.project) : void 0), b.broadcastUpdated !== void 0 && (C.broadcastUpdated = b.broadcastUpdated), C;
    },
    fromPartial(b) {
      var C;
      const A = Ur();
      return A.project = b.project !== void 0 && b.project !== null ? a.Project.fromPartial(b.project) : void 0, A.broadcastUpdated = (C = b.broadcastUpdated) !== null && C !== void 0 ? C : !1, A;
    }
  };
  function xr() {
    return { collectionId: "", projectId: "", force: void 0 };
  }
  a.DeleteProjectRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.projectId !== "" && C.uint32(18).string(b.projectId), b.force !== void 0 && C.uint32(24).bool(b.force), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = xr();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.collectionId = A.string();
            break;
          case 2:
            te.projectId = A.string();
            break;
          case 3:
            te.force = A.bool();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : "",
        force: Le(b.force) ? !!b.force : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.projectId !== void 0 && (C.projectId = b.projectId), b.force !== void 0 && (C.force = b.force), C;
    },
    fromPartial(b) {
      var C, A, Se;
      const te = xr();
      return te.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", te.projectId = (A = b.projectId) !== null && A !== void 0 ? A : "", te.force = (Se = b.force) !== null && Se !== void 0 ? Se : void 0, te;
    }
  };
  function Fr() {
    return { broadcastStopped: !1, layoutsDeleted: 0 };
  }
  a.DeleteProjectResponse = {
    encode(b, C = c.default.Writer.create()) {
      return b.broadcastStopped === !0 && C.uint32(8).bool(b.broadcastStopped), b.layoutsDeleted !== 0 && C.uint32(16).uint32(b.layoutsDeleted), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Fr();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.broadcastStopped = A.bool();
            break;
          case 2:
            te.layoutsDeleted = A.uint32();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        broadcastStopped: Le(b.broadcastStopped) ? !!b.broadcastStopped : !1,
        layoutsDeleted: Le(b.layoutsDeleted) ? Number(b.layoutsDeleted) : 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.broadcastStopped !== void 0 && (C.broadcastStopped = b.broadcastStopped), b.layoutsDeleted !== void 0 && (C.layoutsDeleted = Math.round(b.layoutsDeleted)), C;
    },
    fromPartial(b) {
      var C, A;
      const Se = Fr();
      return Se.broadcastStopped = (C = b.broadcastStopped) !== null && C !== void 0 ? C : !1, Se.layoutsDeleted = (A = b.layoutsDeleted) !== null && A !== void 0 ? A : 0, Se;
    }
  };
  function qr() {
    return {
      collectionId: "",
      projectId: "",
      webrtcStart: void 0,
      async: void 0,
      dynamicSources: {},
      requestMetadata: void 0
    };
  }
  a.StartProjectBroadcastRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.projectId !== "" && C.uint32(18).string(b.projectId), b.webrtcStart !== void 0 && C.uint32(24).bool(b.webrtcStart), b.async !== void 0 && C.uint32(32).bool(b.async), Object.entries(b.dynamicSources).forEach(([A, Se]) => {
        a.StartProjectBroadcastRequest_DynamicSourcesEntry.encode({ key: A, value: Se }, C.uint32(42).fork()).ldelim();
      }), b.requestMetadata !== void 0 && p.Value.encode(p.Value.wrap(b.requestMetadata), C.uint32(58).fork()).ldelim(), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = qr();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.collectionId = A.string();
            break;
          case 2:
            te.projectId = A.string();
            break;
          case 3:
            te.webrtcStart = A.bool();
            break;
          case 4:
            te.async = A.bool();
            break;
          case 5:
            const vt = a.StartProjectBroadcastRequest_DynamicSourcesEntry.decode(A, A.uint32());
            vt.value !== void 0 && (te.dynamicSources[vt.key] = vt.value);
            break;
          case 7:
            te.requestMetadata = p.Value.unwrap(p.Value.decode(A, A.uint32()));
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : "",
        webrtcStart: Le(b.webrtcStart) ? !!b.webrtcStart : void 0,
        async: Le(b.async) ? !!b.async : void 0,
        dynamicSources: Wi(b.dynamicSources) ? Object.entries(b.dynamicSources).reduce((C, [A, Se]) => (C[A] = a.RuntimeSourceAddress.fromJSON(Se), C), {}) : {},
        requestMetadata: Le(b == null ? void 0 : b.requestMetadata) ? b.requestMetadata : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.projectId !== void 0 && (C.projectId = b.projectId), b.webrtcStart !== void 0 && (C.webrtcStart = b.webrtcStart), b.async !== void 0 && (C.async = b.async), C.dynamicSources = {}, b.dynamicSources && Object.entries(b.dynamicSources).forEach(([A, Se]) => {
        C.dynamicSources[A] = a.RuntimeSourceAddress.toJSON(Se);
      }), b.requestMetadata !== void 0 && (C.requestMetadata = b.requestMetadata), C;
    },
    fromPartial(b) {
      var C, A, Se, te, Te, vt;
      const It = qr();
      return It.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", It.projectId = (A = b.projectId) !== null && A !== void 0 ? A : "", It.webrtcStart = (Se = b.webrtcStart) !== null && Se !== void 0 ? Se : void 0, It.async = (te = b.async) !== null && te !== void 0 ? te : void 0, It.dynamicSources = Object.entries((Te = b.dynamicSources) !== null && Te !== void 0 ? Te : {}).reduce((Pt, [Mt, qt]) => (qt !== void 0 && (Pt[Mt] = a.RuntimeSourceAddress.fromPartial(qt)), Pt), {}), It.requestMetadata = (vt = b.requestMetadata) !== null && vt !== void 0 ? vt : void 0, It;
    }
  };
  function Jr() {
    return { key: "", value: void 0 };
  }
  a.StartProjectBroadcastRequest_DynamicSourcesEntry = {
    encode(b, C = c.default.Writer.create()) {
      return b.key !== "" && C.uint32(10).string(b.key), b.value !== void 0 && a.RuntimeSourceAddress.encode(b.value, C.uint32(18).fork()).ldelim(), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Jr();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.key = A.string();
            break;
          case 2:
            te.value = a.RuntimeSourceAddress.decode(A, A.uint32());
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        key: Le(b.key) ? String(b.key) : "",
        value: Le(b.value) ? a.RuntimeSourceAddress.fromJSON(b.value) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.key !== void 0 && (C.key = b.key), b.value !== void 0 && (C.value = b.value ? a.RuntimeSourceAddress.toJSON(b.value) : void 0), C;
    },
    fromPartial(b) {
      var C;
      const A = Jr();
      return A.key = (C = b.key) !== null && C !== void 0 ? C : "", A.value = b.value !== void 0 && b.value !== null ? a.RuntimeSourceAddress.fromPartial(b.value) : void 0, A;
    }
  };
  function Vr() {
    return { broadcastId: "" };
  }
  a.StartProjectBroadcastResponse = {
    encode(b, C = c.default.Writer.create()) {
      return b.broadcastId !== "" && C.uint32(10).string(b.broadcastId), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Vr();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.broadcastId = A.string();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return { broadcastId: Le(b.broadcastId) ? String(b.broadcastId) : "" };
    },
    toJSON(b) {
      const C = {};
      return b.broadcastId !== void 0 && (C.broadcastId = b.broadcastId), C;
    },
    fromPartial(b) {
      var C;
      const A = Vr();
      return A.broadcastId = (C = b.broadcastId) !== null && C !== void 0 ? C : "", A;
    }
  };
  function Gr() {
    return { collectionId: "", projectId: "", webrtcStop: void 0 };
  }
  a.StopProjectBroadcastRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.projectId !== "" && C.uint32(18).string(b.projectId), b.webrtcStop !== void 0 && C.uint32(24).bool(b.webrtcStop), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Gr();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.collectionId = A.string();
            break;
          case 2:
            te.projectId = A.string();
            break;
          case 3:
            te.webrtcStop = A.bool();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : "",
        webrtcStop: Le(b.webrtcStop) ? !!b.webrtcStop : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.projectId !== void 0 && (C.projectId = b.projectId), b.webrtcStop !== void 0 && (C.webrtcStop = b.webrtcStop), C;
    },
    fromPartial(b) {
      var C, A, Se;
      const te = Gr();
      return te.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", te.projectId = (A = b.projectId) !== null && A !== void 0 ? A : "", te.webrtcStop = (Se = b.webrtcStop) !== null && Se !== void 0 ? Se : void 0, te;
    }
  };
  function Wr() {
    return {};
  }
  a.StopProjectBroadcastResponse = {
    encode(b, C = c.default.Writer.create()) {
      return C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Wr();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {};
    },
    toJSON(b) {
      return {};
    },
    fromPartial(b) {
      return Wr();
    }
  };
  function Hr() {
    return { collectionId: "", projectId: "", status: void 0 };
  }
  a.GetProjectRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.projectId !== "" && C.uint32(18).string(b.projectId), b.status !== void 0 && C.uint32(24).bool(b.status), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Hr();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.collectionId = A.string();
            break;
          case 2:
            te.projectId = A.string();
            break;
          case 3:
            te.status = A.bool();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : "",
        status: Le(b.status) ? !!b.status : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.projectId !== void 0 && (C.projectId = b.projectId), b.status !== void 0 && (C.status = b.status), C;
    },
    fromPartial(b) {
      var C, A, Se;
      const te = Hr();
      return te.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", te.projectId = (A = b.projectId) !== null && A !== void 0 ? A : "", te.status = (Se = b.status) !== null && Se !== void 0 ? Se : void 0, te;
    }
  };
  function Kr() {
    return { project: void 0, status: void 0 };
  }
  a.GetProjectResponse = {
    encode(b, C = c.default.Writer.create()) {
      return b.project !== void 0 && a.Project.encode(b.project, C.uint32(10).fork()).ldelim(), b.status !== void 0 && a.ProjectBroadcastStatus.encode(b.status, C.uint32(18).fork()).ldelim(), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Kr();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.project = a.Project.decode(A, A.uint32());
            break;
          case 2:
            te.status = a.ProjectBroadcastStatus.decode(A, A.uint32());
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        project: Le(b.project) ? a.Project.fromJSON(b.project) : void 0,
        status: Le(b.status) ? a.ProjectBroadcastStatus.fromJSON(b.status) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.project !== void 0 && (C.project = b.project ? a.Project.toJSON(b.project) : void 0), b.status !== void 0 && (C.status = b.status ? a.ProjectBroadcastStatus.toJSON(b.status) : void 0), C;
    },
    fromPartial(b) {
      const C = Kr();
      return C.project = b.project !== void 0 && b.project !== null ? a.Project.fromPartial(b.project) : void 0, C.status = b.status !== void 0 && b.status !== null ? a.ProjectBroadcastStatus.fromPartial(b.status) : void 0, C;
    }
  };
  function Yr() {
    return { collectionId: "", projectId: "", format: void 0 };
  }
  a.GetProjectBroadcastSnapshotRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.projectId !== "" && C.uint32(18).string(b.projectId), b.format !== void 0 && C.uint32(24).int32(Me(b.format)), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Yr();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.collectionId = A.string();
            break;
          case 2:
            te.projectId = A.string();
            break;
          case 3:
            te.format = be(A.int32());
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : "",
        format: Le(b.format) ? be(b.format) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.projectId !== void 0 && (C.projectId = b.projectId), b.format !== void 0 && (C.format = b.format !== void 0 ? Ce(b.format) : void 0), C;
    },
    fromPartial(b) {
      var C, A, Se;
      const te = Yr();
      return te.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", te.projectId = (A = b.projectId) !== null && A !== void 0 ? A : "", te.format = (Se = b.format) !== null && Se !== void 0 ? Se : void 0, te;
    }
  };
  function Zr() {
    return { format: ge.IMAGE_FORMAT_UNSPECIFIED, image: new Uint8Array() };
  }
  a.GetProjectBroadcastSnapshotResponse = {
    encode(b, C = c.default.Writer.create()) {
      return b.format !== ge.IMAGE_FORMAT_UNSPECIFIED && C.uint32(8).int32(Me(b.format)), b.image.length !== 0 && C.uint32(18).bytes(b.image), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Zr();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.format = be(A.int32());
            break;
          case 2:
            te.image = A.bytes();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        format: Le(b.format) ? be(b.format) : ge.IMAGE_FORMAT_UNSPECIFIED,
        image: Le(b.image) ? Vi(b.image) : new Uint8Array()
      };
    },
    toJSON(b) {
      const C = {};
      return b.format !== void 0 && (C.format = Ce(b.format)), b.image !== void 0 && (C.image = Gi(b.image !== void 0 ? b.image : new Uint8Array())), C;
    },
    fromPartial(b) {
      var C, A;
      const Se = Zr();
      return Se.format = (C = b.format) !== null && C !== void 0 ? C : ge.IMAGE_FORMAT_UNSPECIFIED, Se.image = (A = b.image) !== null && A !== void 0 ? A : new Uint8Array(), Se;
    }
  };
  function Qr() {
    return { collectionId: "", projectId: "" };
  }
  a.GetProjectBroadcastStatusRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.projectId !== "" && C.uint32(18).string(b.projectId), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Qr();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.collectionId = A.string();
            break;
          case 2:
            te.projectId = A.string();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : ""
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.projectId !== void 0 && (C.projectId = b.projectId), C;
    },
    fromPartial(b) {
      var C, A;
      const Se = Qr();
      return Se.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", Se.projectId = (A = b.projectId) !== null && A !== void 0 ? A : "", Se;
    }
  };
  function Xr() {
    return { status: void 0 };
  }
  a.GetProjectBroadcastStatusResponse = {
    encode(b, C = c.default.Writer.create()) {
      return b.status !== void 0 && a.ProjectBroadcastStatus.encode(b.status, C.uint32(10).fork()).ldelim(), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Xr();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.status = a.ProjectBroadcastStatus.decode(A, A.uint32());
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return { status: Le(b.status) ? a.ProjectBroadcastStatus.fromJSON(b.status) : void 0 };
    },
    toJSON(b) {
      const C = {};
      return b.status !== void 0 && (C.status = b.status ? a.ProjectBroadcastStatus.toJSON(b.status) : void 0), C;
    },
    fromPartial(b) {
      const C = Xr();
      return C.status = b.status !== void 0 && b.status !== null ? a.ProjectBroadcastStatus.fromPartial(b.status) : void 0, C;
    }
  };
  function jr() {
    return { collectionId: "", projectId: "" };
  }
  a.StartProjectWebRtcRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.projectId !== "" && C.uint32(18).string(b.projectId), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = jr();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.collectionId = A.string();
            break;
          case 2:
            te.projectId = A.string();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : ""
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.projectId !== void 0 && (C.projectId = b.projectId), C;
    },
    fromPartial(b) {
      var C, A;
      const Se = jr();
      return Se.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", Se.projectId = (A = b.projectId) !== null && A !== void 0 ? A : "", Se;
    }
  };
  function en() {
    return {};
  }
  a.StartProjectWebRtcResponse = {
    encode(b, C = c.default.Writer.create()) {
      return C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = en();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {};
    },
    toJSON(b) {
      return {};
    },
    fromPartial(b) {
      return en();
    }
  };
  function tn() {
    return { collectionId: "", projectId: "" };
  }
  a.StopProjectWebRtcRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.projectId !== "" && C.uint32(18).string(b.projectId), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = tn();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.collectionId = A.string();
            break;
          case 2:
            te.projectId = A.string();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : ""
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.projectId !== void 0 && (C.projectId = b.projectId), C;
    },
    fromPartial(b) {
      var C, A;
      const Se = tn();
      return Se.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", Se.projectId = (A = b.projectId) !== null && A !== void 0 ? A : "", Se;
    }
  };
  function rn() {
    return {};
  }
  a.StopProjectWebRtcResponse = {
    encode(b, C = c.default.Writer.create()) {
      return C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = rn();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {};
    },
    toJSON(b) {
      return {};
    },
    fromPartial(b) {
      return rn();
    }
  };
  function nn() {
    return {
      collectionId: "",
      projectId: "",
      metadata: void 0,
      address: void 0,
      enabled: void 0,
      timeout: void 0,
      outputDelay: void 0
    };
  }
  a.CreateDestinationRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.projectId !== "" && C.uint32(18).string(b.projectId), b.metadata !== void 0 && p.Value.encode(p.Value.wrap(b.metadata), C.uint32(26).fork()).ldelim(), b.address !== void 0 && a.DestinationAddress.encode(b.address, C.uint32(42).fork()).ldelim(), b.enabled !== void 0 && C.uint32(48).bool(b.enabled), b.timeout !== void 0 && C.uint32(56).uint32(b.timeout), b.outputDelay !== void 0 && C.uint32(72).uint32(b.outputDelay), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = nn();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.collectionId = A.string();
            break;
          case 2:
            te.projectId = A.string();
            break;
          case 3:
            te.metadata = p.Value.unwrap(p.Value.decode(A, A.uint32()));
            break;
          case 5:
            te.address = a.DestinationAddress.decode(A, A.uint32());
            break;
          case 6:
            te.enabled = A.bool();
            break;
          case 7:
            te.timeout = A.uint32();
            break;
          case 9:
            te.outputDelay = A.uint32();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : "",
        metadata: Le(b == null ? void 0 : b.metadata) ? b.metadata : void 0,
        address: Le(b.address) ? a.DestinationAddress.fromJSON(b.address) : void 0,
        enabled: Le(b.enabled) ? !!b.enabled : void 0,
        timeout: Le(b.timeout) ? Number(b.timeout) : void 0,
        outputDelay: Le(b.outputDelay) ? Number(b.outputDelay) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.projectId !== void 0 && (C.projectId = b.projectId), b.metadata !== void 0 && (C.metadata = b.metadata), b.address !== void 0 && (C.address = b.address ? a.DestinationAddress.toJSON(b.address) : void 0), b.enabled !== void 0 && (C.enabled = b.enabled), b.timeout !== void 0 && (C.timeout = Math.round(b.timeout)), b.outputDelay !== void 0 && (C.outputDelay = Math.round(b.outputDelay)), C;
    },
    fromPartial(b) {
      var C, A, Se, te, Te, vt;
      const It = nn();
      return It.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", It.projectId = (A = b.projectId) !== null && A !== void 0 ? A : "", It.metadata = (Se = b.metadata) !== null && Se !== void 0 ? Se : void 0, It.address = b.address !== void 0 && b.address !== null ? a.DestinationAddress.fromPartial(b.address) : void 0, It.enabled = (te = b.enabled) !== null && te !== void 0 ? te : void 0, It.timeout = (Te = b.timeout) !== null && Te !== void 0 ? Te : void 0, It.outputDelay = (vt = b.outputDelay) !== null && vt !== void 0 ? vt : void 0, It;
    }
  };
  function an() {
    return { destination: void 0 };
  }
  a.CreateDestinationResponse = {
    encode(b, C = c.default.Writer.create()) {
      return b.destination !== void 0 && a.Destination.encode(b.destination, C.uint32(10).fork()).ldelim(), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = an();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.destination = a.Destination.decode(A, A.uint32());
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return { destination: Le(b.destination) ? a.Destination.fromJSON(b.destination) : void 0 };
    },
    toJSON(b) {
      const C = {};
      return b.destination !== void 0 && (C.destination = b.destination ? a.Destination.toJSON(b.destination) : void 0), C;
    },
    fromPartial(b) {
      const C = an();
      return C.destination = b.destination !== void 0 && b.destination !== null ? a.Destination.fromPartial(b.destination) : void 0, C;
    }
  };
  function sn() {
    return { collectionId: "", projectId: "", destinationId: "" };
  }
  a.GetDestinationRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.projectId !== "" && C.uint32(18).string(b.projectId), b.destinationId !== "" && C.uint32(26).string(b.destinationId), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = sn();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.collectionId = A.string();
            break;
          case 2:
            te.projectId = A.string();
            break;
          case 3:
            te.destinationId = A.string();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : "",
        destinationId: Le(b.destinationId) ? String(b.destinationId) : ""
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.projectId !== void 0 && (C.projectId = b.projectId), b.destinationId !== void 0 && (C.destinationId = b.destinationId), C;
    },
    fromPartial(b) {
      var C, A, Se;
      const te = sn();
      return te.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", te.projectId = (A = b.projectId) !== null && A !== void 0 ? A : "", te.destinationId = (Se = b.destinationId) !== null && Se !== void 0 ? Se : "", te;
    }
  };
  function dn() {
    return { destination: void 0 };
  }
  a.GetDestinationResponse = {
    encode(b, C = c.default.Writer.create()) {
      return b.destination !== void 0 && a.Destination.encode(b.destination, C.uint32(10).fork()).ldelim(), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = dn();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.destination = a.Destination.decode(A, A.uint32());
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return { destination: Le(b.destination) ? a.Destination.fromJSON(b.destination) : void 0 };
    },
    toJSON(b) {
      const C = {};
      return b.destination !== void 0 && (C.destination = b.destination ? a.Destination.toJSON(b.destination) : void 0), C;
    },
    fromPartial(b) {
      const C = dn();
      return C.destination = b.destination !== void 0 && b.destination !== null ? a.Destination.fromPartial(b.destination) : void 0, C;
    }
  };
  function un() {
    return { collectionId: "", projectId: "", destinationId: "", force: void 0 };
  }
  a.DeleteDestinationRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.projectId !== "" && C.uint32(18).string(b.projectId), b.destinationId !== "" && C.uint32(26).string(b.destinationId), b.force !== void 0 && C.uint32(32).bool(b.force), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = un();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.collectionId = A.string();
            break;
          case 2:
            te.projectId = A.string();
            break;
          case 3:
            te.destinationId = A.string();
            break;
          case 4:
            te.force = A.bool();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : "",
        destinationId: Le(b.destinationId) ? String(b.destinationId) : "",
        force: Le(b.force) ? !!b.force : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.projectId !== void 0 && (C.projectId = b.projectId), b.destinationId !== void 0 && (C.destinationId = b.destinationId), b.force !== void 0 && (C.force = b.force), C;
    },
    fromPartial(b) {
      var C, A, Se, te;
      const Te = un();
      return Te.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", Te.projectId = (A = b.projectId) !== null && A !== void 0 ? A : "", Te.destinationId = (Se = b.destinationId) !== null && Se !== void 0 ? Se : "", Te.force = (te = b.force) !== null && te !== void 0 ? te : void 0, Te;
    }
  };
  function cn() {
    return { broadcastUpdated: !1 };
  }
  a.DeleteDestinationResponse = {
    encode(b, C = c.default.Writer.create()) {
      return b.broadcastUpdated === !0 && C.uint32(8).bool(b.broadcastUpdated), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = cn();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.broadcastUpdated = A.bool();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return { broadcastUpdated: Le(b.broadcastUpdated) ? !!b.broadcastUpdated : !1 };
    },
    toJSON(b) {
      const C = {};
      return b.broadcastUpdated !== void 0 && (C.broadcastUpdated = b.broadcastUpdated), C;
    },
    fromPartial(b) {
      var C;
      const A = cn();
      return A.broadcastUpdated = (C = b.broadcastUpdated) !== null && C !== void 0 ? C : !1, A;
    }
  };
  function ln() {
    return {
      collectionId: "",
      projectId: "",
      destinationId: "",
      updateMask: void 0,
      metadata: void 0,
      address: void 0,
      enabled: void 0,
      timeout: void 0,
      outputDelay: void 0
    };
  }
  a.UpdateDestinationRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.projectId !== "" && C.uint32(18).string(b.projectId), b.destinationId !== "" && C.uint32(26).string(b.destinationId), b.updateMask !== void 0 && v.FieldMask.encode(v.FieldMask.wrap(b.updateMask), C.uint32(34).fork()).ldelim(), b.metadata !== void 0 && p.Value.encode(p.Value.wrap(b.metadata), C.uint32(42).fork()).ldelim(), b.address !== void 0 && a.DestinationAddress.encode(b.address, C.uint32(50).fork()).ldelim(), b.enabled !== void 0 && C.uint32(56).bool(b.enabled), b.timeout !== void 0 && C.uint32(64).uint32(b.timeout), b.outputDelay !== void 0 && C.uint32(72).uint32(b.outputDelay), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = ln();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.collectionId = A.string();
            break;
          case 2:
            te.projectId = A.string();
            break;
          case 3:
            te.destinationId = A.string();
            break;
          case 4:
            te.updateMask = v.FieldMask.unwrap(v.FieldMask.decode(A, A.uint32()));
            break;
          case 5:
            te.metadata = p.Value.unwrap(p.Value.decode(A, A.uint32()));
            break;
          case 6:
            te.address = a.DestinationAddress.decode(A, A.uint32());
            break;
          case 7:
            te.enabled = A.bool();
            break;
          case 8:
            te.timeout = A.uint32();
            break;
          case 9:
            te.outputDelay = A.uint32();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : "",
        destinationId: Le(b.destinationId) ? String(b.destinationId) : "",
        updateMask: Le(b.updateMask) ? v.FieldMask.unwrap(v.FieldMask.fromJSON(b.updateMask)) : void 0,
        metadata: Le(b == null ? void 0 : b.metadata) ? b.metadata : void 0,
        address: Le(b.address) ? a.DestinationAddress.fromJSON(b.address) : void 0,
        enabled: Le(b.enabled) ? !!b.enabled : void 0,
        timeout: Le(b.timeout) ? Number(b.timeout) : void 0,
        outputDelay: Le(b.outputDelay) ? Number(b.outputDelay) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.projectId !== void 0 && (C.projectId = b.projectId), b.destinationId !== void 0 && (C.destinationId = b.destinationId), b.updateMask !== void 0 && (C.updateMask = v.FieldMask.toJSON(v.FieldMask.wrap(b.updateMask))), b.metadata !== void 0 && (C.metadata = b.metadata), b.address !== void 0 && (C.address = b.address ? a.DestinationAddress.toJSON(b.address) : void 0), b.enabled !== void 0 && (C.enabled = b.enabled), b.timeout !== void 0 && (C.timeout = Math.round(b.timeout)), b.outputDelay !== void 0 && (C.outputDelay = Math.round(b.outputDelay)), C;
    },
    fromPartial(b) {
      var C, A, Se, te, Te, vt, It, Pt;
      const Mt = ln();
      return Mt.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", Mt.projectId = (A = b.projectId) !== null && A !== void 0 ? A : "", Mt.destinationId = (Se = b.destinationId) !== null && Se !== void 0 ? Se : "", Mt.updateMask = (te = b.updateMask) !== null && te !== void 0 ? te : void 0, Mt.metadata = (Te = b.metadata) !== null && Te !== void 0 ? Te : void 0, Mt.address = b.address !== void 0 && b.address !== null ? a.DestinationAddress.fromPartial(b.address) : void 0, Mt.enabled = (vt = b.enabled) !== null && vt !== void 0 ? vt : void 0, Mt.timeout = (It = b.timeout) !== null && It !== void 0 ? It : void 0, Mt.outputDelay = (Pt = b.outputDelay) !== null && Pt !== void 0 ? Pt : void 0, Mt;
    }
  };
  function fn() {
    return { destination: void 0, broadcastUpdated: !1 };
  }
  a.UpdateDestinationResponse = {
    encode(b, C = c.default.Writer.create()) {
      return b.destination !== void 0 && a.Destination.encode(b.destination, C.uint32(10).fork()).ldelim(), b.broadcastUpdated === !0 && C.uint32(16).bool(b.broadcastUpdated), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = fn();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.destination = a.Destination.decode(A, A.uint32());
            break;
          case 2:
            te.broadcastUpdated = A.bool();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        destination: Le(b.destination) ? a.Destination.fromJSON(b.destination) : void 0,
        broadcastUpdated: Le(b.broadcastUpdated) ? !!b.broadcastUpdated : !1
      };
    },
    toJSON(b) {
      const C = {};
      return b.destination !== void 0 && (C.destination = b.destination ? a.Destination.toJSON(b.destination) : void 0), b.broadcastUpdated !== void 0 && (C.broadcastUpdated = b.broadcastUpdated), C;
    },
    fromPartial(b) {
      var C;
      const A = fn();
      return A.destination = b.destination !== void 0 && b.destination !== null ? a.Destination.fromPartial(b.destination) : void 0, A.broadcastUpdated = (C = b.broadcastUpdated) !== null && C !== void 0 ? C : !1, A;
    }
  };
  function hn() {
    return { collectionId: "", metadata: void 0, address: void 0, preview: void 0 };
  }
  a.CreateSourceRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.metadata !== void 0 && p.Value.encode(p.Value.wrap(b.metadata), C.uint32(18).fork()).ldelim(), b.address !== void 0 && a.SourceAddress.encode(b.address, C.uint32(26).fork()).ldelim(), b.preview !== void 0 && a.PreviewAddress.encode(b.preview, C.uint32(34).fork()).ldelim(), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = hn();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.collectionId = A.string();
            break;
          case 2:
            te.metadata = p.Value.unwrap(p.Value.decode(A, A.uint32()));
            break;
          case 3:
            te.address = a.SourceAddress.decode(A, A.uint32());
            break;
          case 4:
            te.preview = a.PreviewAddress.decode(A, A.uint32());
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        metadata: Le(b == null ? void 0 : b.metadata) ? b.metadata : void 0,
        address: Le(b.address) ? a.SourceAddress.fromJSON(b.address) : void 0,
        preview: Le(b.preview) ? a.PreviewAddress.fromJSON(b.preview) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.metadata !== void 0 && (C.metadata = b.metadata), b.address !== void 0 && (C.address = b.address ? a.SourceAddress.toJSON(b.address) : void 0), b.preview !== void 0 && (C.preview = b.preview ? a.PreviewAddress.toJSON(b.preview) : void 0), C;
    },
    fromPartial(b) {
      var C, A;
      const Se = hn();
      return Se.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", Se.metadata = (A = b.metadata) !== null && A !== void 0 ? A : void 0, Se.address = b.address !== void 0 && b.address !== null ? a.SourceAddress.fromPartial(b.address) : void 0, Se.preview = b.preview !== void 0 && b.preview !== null ? a.PreviewAddress.fromPartial(b.preview) : void 0, Se;
    }
  };
  function pn() {
    return { source: void 0 };
  }
  a.CreateSourceResponse = {
    encode(b, C = c.default.Writer.create()) {
      return b.source !== void 0 && a.Source.encode(b.source, C.uint32(10).fork()).ldelim(), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = pn();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.source = a.Source.decode(A, A.uint32());
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return { source: Le(b.source) ? a.Source.fromJSON(b.source) : void 0 };
    },
    toJSON(b) {
      const C = {};
      return b.source !== void 0 && (C.source = b.source ? a.Source.toJSON(b.source) : void 0), C;
    },
    fromPartial(b) {
      const C = pn();
      return C.source = b.source !== void 0 && b.source !== null ? a.Source.fromPartial(b.source) : void 0, C;
    }
  };
  function mn() {
    return { collectionId: "", sourceId: "", force: void 0 };
  }
  a.DeleteSourceRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.sourceId !== "" && C.uint32(18).string(b.sourceId), b.force !== void 0 && C.uint32(24).bool(b.force), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = mn();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.collectionId = A.string();
            break;
          case 2:
            te.sourceId = A.string();
            break;
          case 3:
            te.force = A.bool();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        sourceId: Le(b.sourceId) ? String(b.sourceId) : "",
        force: Le(b.force) ? !!b.force : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.sourceId !== void 0 && (C.sourceId = b.sourceId), b.force !== void 0 && (C.force = b.force), C;
    },
    fromPartial(b) {
      var C, A, Se;
      const te = mn();
      return te.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", te.sourceId = (A = b.sourceId) !== null && A !== void 0 ? A : "", te.force = (Se = b.force) !== null && Se !== void 0 ? Se : void 0, te;
    }
  };
  function vn() {
    return { projectIdsUpdated: [] };
  }
  a.DeleteSourceResponse = {
    encode(b, C = c.default.Writer.create()) {
      for (const A of b.projectIdsUpdated)
        C.uint32(26).string(A);
      return C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = vn();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 3:
            te.projectIdsUpdated.push(A.string());
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        projectIdsUpdated: Array.isArray(b == null ? void 0 : b.projectIdsUpdated) ? b.projectIdsUpdated.map((C) => String(C)) : []
      };
    },
    toJSON(b) {
      const C = {};
      return b.projectIdsUpdated ? C.projectIdsUpdated = b.projectIdsUpdated.map((A) => A) : C.projectIdsUpdated = [], C;
    },
    fromPartial(b) {
      var C;
      const A = vn();
      return A.projectIdsUpdated = ((C = b.projectIdsUpdated) === null || C === void 0 ? void 0 : C.map((Se) => Se)) || [], A;
    }
  };
  function yn() {
    return { collectionId: "", projectId: "", sourceId: "", trigger: void 0 };
  }
  a.AddSourceToProjectRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.projectId !== "" && C.uint32(18).string(b.projectId), b.sourceId !== "" && C.uint32(26).string(b.sourceId), b.trigger !== void 0 && a.SourceTrigger.encode(b.trigger, C.uint32(34).fork()).ldelim(), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = yn();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.collectionId = A.string();
            break;
          case 2:
            te.projectId = A.string();
            break;
          case 3:
            te.sourceId = A.string();
            break;
          case 4:
            te.trigger = a.SourceTrigger.decode(A, A.uint32());
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : "",
        sourceId: Le(b.sourceId) ? String(b.sourceId) : "",
        trigger: Le(b.trigger) ? a.SourceTrigger.fromJSON(b.trigger) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.projectId !== void 0 && (C.projectId = b.projectId), b.sourceId !== void 0 && (C.sourceId = b.sourceId), b.trigger !== void 0 && (C.trigger = b.trigger ? a.SourceTrigger.toJSON(b.trigger) : void 0), C;
    },
    fromPartial(b) {
      var C, A, Se;
      const te = yn();
      return te.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", te.projectId = (A = b.projectId) !== null && A !== void 0 ? A : "", te.sourceId = (Se = b.sourceId) !== null && Se !== void 0 ? Se : "", te.trigger = b.trigger !== void 0 && b.trigger !== null ? a.SourceTrigger.fromPartial(b.trigger) : void 0, te;
    }
  };
  function gn() {
    return { project: void 0, broadcastUpdated: !1 };
  }
  a.AddSourceToProjectResponse = {
    encode(b, C = c.default.Writer.create()) {
      return b.project !== void 0 && a.Project.encode(b.project, C.uint32(10).fork()).ldelim(), b.broadcastUpdated === !0 && C.uint32(16).bool(b.broadcastUpdated), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = gn();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.project = a.Project.decode(A, A.uint32());
            break;
          case 2:
            te.broadcastUpdated = A.bool();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        project: Le(b.project) ? a.Project.fromJSON(b.project) : void 0,
        broadcastUpdated: Le(b.broadcastUpdated) ? !!b.broadcastUpdated : !1
      };
    },
    toJSON(b) {
      const C = {};
      return b.project !== void 0 && (C.project = b.project ? a.Project.toJSON(b.project) : void 0), b.broadcastUpdated !== void 0 && (C.broadcastUpdated = b.broadcastUpdated), C;
    },
    fromPartial(b) {
      var C;
      const A = gn();
      return A.project = b.project !== void 0 && b.project !== null ? a.Project.fromPartial(b.project) : void 0, A.broadcastUpdated = (C = b.broadcastUpdated) !== null && C !== void 0 ? C : !1, A;
    }
  };
  function Sn() {
    return { collectionId: "", projectId: "", sourceId: "", updateMask: void 0, trigger: void 0 };
  }
  a.UpdateSourceInProjectRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.projectId !== "" && C.uint32(18).string(b.projectId), b.sourceId !== "" && C.uint32(26).string(b.sourceId), b.updateMask !== void 0 && v.FieldMask.encode(v.FieldMask.wrap(b.updateMask), C.uint32(34).fork()).ldelim(), b.trigger !== void 0 && a.SourceTrigger.encode(b.trigger, C.uint32(42).fork()).ldelim(), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Sn();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.collectionId = A.string();
            break;
          case 2:
            te.projectId = A.string();
            break;
          case 3:
            te.sourceId = A.string();
            break;
          case 4:
            te.updateMask = v.FieldMask.unwrap(v.FieldMask.decode(A, A.uint32()));
            break;
          case 5:
            te.trigger = a.SourceTrigger.decode(A, A.uint32());
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : "",
        sourceId: Le(b.sourceId) ? String(b.sourceId) : "",
        updateMask: Le(b.updateMask) ? v.FieldMask.unwrap(v.FieldMask.fromJSON(b.updateMask)) : void 0,
        trigger: Le(b.trigger) ? a.SourceTrigger.fromJSON(b.trigger) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.projectId !== void 0 && (C.projectId = b.projectId), b.sourceId !== void 0 && (C.sourceId = b.sourceId), b.updateMask !== void 0 && (C.updateMask = v.FieldMask.toJSON(v.FieldMask.wrap(b.updateMask))), b.trigger !== void 0 && (C.trigger = b.trigger ? a.SourceTrigger.toJSON(b.trigger) : void 0), C;
    },
    fromPartial(b) {
      var C, A, Se, te;
      const Te = Sn();
      return Te.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", Te.projectId = (A = b.projectId) !== null && A !== void 0 ? A : "", Te.sourceId = (Se = b.sourceId) !== null && Se !== void 0 ? Se : "", Te.updateMask = (te = b.updateMask) !== null && te !== void 0 ? te : void 0, Te.trigger = b.trigger !== void 0 && b.trigger !== null ? a.SourceTrigger.fromPartial(b.trigger) : void 0, Te;
    }
  };
  function _n() {
    return { project: void 0 };
  }
  a.UpdateSourceInProjectResponse = {
    encode(b, C = c.default.Writer.create()) {
      return b.project !== void 0 && a.Project.encode(b.project, C.uint32(10).fork()).ldelim(), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = _n();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.project = a.Project.decode(A, A.uint32());
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return { project: Le(b.project) ? a.Project.fromJSON(b.project) : void 0 };
    },
    toJSON(b) {
      const C = {};
      return b.project !== void 0 && (C.project = b.project ? a.Project.toJSON(b.project) : void 0), C;
    },
    fromPartial(b) {
      const C = _n();
      return C.project = b.project !== void 0 && b.project !== null ? a.Project.fromPartial(b.project) : void 0, C;
    }
  };
  function En() {
    return { collectionId: "", sourceId: "" };
  }
  a.GetSourceRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.sourceId !== "" && C.uint32(26).string(b.sourceId), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = En();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.collectionId = A.string();
            break;
          case 3:
            te.sourceId = A.string();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        sourceId: Le(b.sourceId) ? String(b.sourceId) : ""
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.sourceId !== void 0 && (C.sourceId = b.sourceId), C;
    },
    fromPartial(b) {
      var C, A;
      const Se = En();
      return Se.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", Se.sourceId = (A = b.sourceId) !== null && A !== void 0 ? A : "", Se;
    }
  };
  function Tn() {
    return { source: void 0 };
  }
  a.GetSourceResponse = {
    encode(b, C = c.default.Writer.create()) {
      return b.source !== void 0 && a.Source.encode(b.source, C.uint32(10).fork()).ldelim(), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Tn();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.source = a.Source.decode(A, A.uint32());
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return { source: Le(b.source) ? a.Source.fromJSON(b.source) : void 0 };
    },
    toJSON(b) {
      const C = {};
      return b.source !== void 0 && (C.source = b.source ? a.Source.toJSON(b.source) : void 0), C;
    },
    fromPartial(b) {
      const C = Tn();
      return C.source = b.source !== void 0 && b.source !== null ? a.Source.fromPartial(b.source) : void 0, C;
    }
  };
  function kn() {
    return { collectionId: "" };
  }
  a.GetSourcesRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = kn();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.collectionId = A.string();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return { collectionId: Le(b.collectionId) ? String(b.collectionId) : "" };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), C;
    },
    fromPartial(b) {
      var C;
      const A = kn();
      return A.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", A;
    }
  };
  function wn() {
    return { sources: [] };
  }
  a.GetSourcesResponse = {
    encode(b, C = c.default.Writer.create()) {
      for (const A of b.sources)
        a.Source.encode(A, C.uint32(10).fork()).ldelim();
      return C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = wn();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.sources.push(a.Source.decode(A, A.uint32()));
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return { sources: Array.isArray(b == null ? void 0 : b.sources) ? b.sources.map((C) => a.Source.fromJSON(C)) : [] };
    },
    toJSON(b) {
      const C = {};
      return b.sources ? C.sources = b.sources.map((A) => A ? a.Source.toJSON(A) : void 0) : C.sources = [], C;
    },
    fromPartial(b) {
      var C;
      const A = wn();
      return A.sources = ((C = b.sources) === null || C === void 0 ? void 0 : C.map((Se) => a.Source.fromPartial(Se))) || [], A;
    }
  };
  function In() {
    return {
      collectionId: "",
      sourceId: "",
      updateMask: void 0,
      metadata: void 0,
      address: void 0,
      preview: void 0
    };
  }
  a.UpdateSourceRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.sourceId !== "" && C.uint32(26).string(b.sourceId), b.updateMask !== void 0 && v.FieldMask.encode(v.FieldMask.wrap(b.updateMask), C.uint32(34).fork()).ldelim(), b.metadata !== void 0 && p.Value.encode(p.Value.wrap(b.metadata), C.uint32(42).fork()).ldelim(), b.address !== void 0 && a.SourceAddress.encode(b.address, C.uint32(50).fork()).ldelim(), b.preview !== void 0 && a.PreviewAddress.encode(b.preview, C.uint32(58).fork()).ldelim(), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = In();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.collectionId = A.string();
            break;
          case 3:
            te.sourceId = A.string();
            break;
          case 4:
            te.updateMask = v.FieldMask.unwrap(v.FieldMask.decode(A, A.uint32()));
            break;
          case 5:
            te.metadata = p.Value.unwrap(p.Value.decode(A, A.uint32()));
            break;
          case 6:
            te.address = a.SourceAddress.decode(A, A.uint32());
            break;
          case 7:
            te.preview = a.PreviewAddress.decode(A, A.uint32());
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        sourceId: Le(b.sourceId) ? String(b.sourceId) : "",
        updateMask: Le(b.updateMask) ? v.FieldMask.unwrap(v.FieldMask.fromJSON(b.updateMask)) : void 0,
        metadata: Le(b == null ? void 0 : b.metadata) ? b.metadata : void 0,
        address: Le(b.address) ? a.SourceAddress.fromJSON(b.address) : void 0,
        preview: Le(b.preview) ? a.PreviewAddress.fromJSON(b.preview) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.sourceId !== void 0 && (C.sourceId = b.sourceId), b.updateMask !== void 0 && (C.updateMask = v.FieldMask.toJSON(v.FieldMask.wrap(b.updateMask))), b.metadata !== void 0 && (C.metadata = b.metadata), b.address !== void 0 && (C.address = b.address ? a.SourceAddress.toJSON(b.address) : void 0), b.preview !== void 0 && (C.preview = b.preview ? a.PreviewAddress.toJSON(b.preview) : void 0), C;
    },
    fromPartial(b) {
      var C, A, Se, te;
      const Te = In();
      return Te.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", Te.sourceId = (A = b.sourceId) !== null && A !== void 0 ? A : "", Te.updateMask = (Se = b.updateMask) !== null && Se !== void 0 ? Se : void 0, Te.metadata = (te = b.metadata) !== null && te !== void 0 ? te : void 0, Te.address = b.address !== void 0 && b.address !== null ? a.SourceAddress.fromPartial(b.address) : void 0, Te.preview = b.preview !== void 0 && b.preview !== null ? a.PreviewAddress.fromPartial(b.preview) : void 0, Te;
    }
  };
  function Rn() {
    return { source: void 0, broadcastUpdated: !1 };
  }
  a.UpdateSourceResponse = {
    encode(b, C = c.default.Writer.create()) {
      return b.source !== void 0 && a.Source.encode(b.source, C.uint32(10).fork()).ldelim(), b.broadcastUpdated === !0 && C.uint32(16).bool(b.broadcastUpdated), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Rn();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.source = a.Source.decode(A, A.uint32());
            break;
          case 2:
            te.broadcastUpdated = A.bool();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        source: Le(b.source) ? a.Source.fromJSON(b.source) : void 0,
        broadcastUpdated: Le(b.broadcastUpdated) ? !!b.broadcastUpdated : !1
      };
    },
    toJSON(b) {
      const C = {};
      return b.source !== void 0 && (C.source = b.source ? a.Source.toJSON(b.source) : void 0), b.broadcastUpdated !== void 0 && (C.broadcastUpdated = b.broadcastUpdated), C;
    },
    fromPartial(b) {
      var C;
      const A = Rn();
      return A.source = b.source !== void 0 && b.source !== null ? a.Source.fromPartial(b.source) : void 0, A.broadcastUpdated = (C = b.broadcastUpdated) !== null && C !== void 0 ? C : !1, A;
    }
  };
  function Cn() {
    return { collectionId: "", projectId: "", sourceId: "", force: void 0 };
  }
  a.RemoveSourceFromProjectRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.projectId !== "" && C.uint32(18).string(b.projectId), b.sourceId !== "" && C.uint32(26).string(b.sourceId), b.force !== void 0 && C.uint32(32).bool(b.force), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Cn();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.collectionId = A.string();
            break;
          case 2:
            te.projectId = A.string();
            break;
          case 3:
            te.sourceId = A.string();
            break;
          case 4:
            te.force = A.bool();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : "",
        sourceId: Le(b.sourceId) ? String(b.sourceId) : "",
        force: Le(b.force) ? !!b.force : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.projectId !== void 0 && (C.projectId = b.projectId), b.sourceId !== void 0 && (C.sourceId = b.sourceId), b.force !== void 0 && (C.force = b.force), C;
    },
    fromPartial(b) {
      var C, A, Se, te;
      const Te = Cn();
      return Te.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", Te.projectId = (A = b.projectId) !== null && A !== void 0 ? A : "", Te.sourceId = (Se = b.sourceId) !== null && Se !== void 0 ? Se : "", Te.force = (te = b.force) !== null && te !== void 0 ? te : void 0, Te;
    }
  };
  function Pn() {
    return { project: void 0, broadcastUpdated: !1 };
  }
  a.RemoveSourceFromProjectResponse = {
    encode(b, C = c.default.Writer.create()) {
      return b.project !== void 0 && a.Project.encode(b.project, C.uint32(10).fork()).ldelim(), b.broadcastUpdated === !0 && C.uint32(16).bool(b.broadcastUpdated), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Pn();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.project = a.Project.decode(A, A.uint32());
            break;
          case 2:
            te.broadcastUpdated = A.bool();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        project: Le(b.project) ? a.Project.fromJSON(b.project) : void 0,
        broadcastUpdated: Le(b.broadcastUpdated) ? !!b.broadcastUpdated : !1
      };
    },
    toJSON(b) {
      const C = {};
      return b.project !== void 0 && (C.project = b.project ? a.Project.toJSON(b.project) : void 0), b.broadcastUpdated !== void 0 && (C.broadcastUpdated = b.broadcastUpdated), C;
    },
    fromPartial(b) {
      var C;
      const A = Pn();
      return A.project = b.project !== void 0 && b.project !== null ? a.Project.fromPartial(b.project) : void 0, A.broadcastUpdated = (C = b.broadcastUpdated) !== null && C !== void 0 ? C : !1, A;
    }
  };
  function On() {
    return { collectionId: "", sourceId: "", accessToken: void 0 };
  }
  a.GetSourcePlaylistRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.sourceId !== "" && C.uint32(26).string(b.sourceId), b.accessToken !== void 0 && C.uint32(34).string(b.accessToken), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = On();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.collectionId = A.string();
            break;
          case 3:
            te.sourceId = A.string();
            break;
          case 4:
            te.accessToken = A.string();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        sourceId: Le(b.sourceId) ? String(b.sourceId) : "",
        accessToken: Le(b.accessToken) ? String(b.accessToken) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.sourceId !== void 0 && (C.sourceId = b.sourceId), b.accessToken !== void 0 && (C.accessToken = b.accessToken), C;
    },
    fromPartial(b) {
      var C, A, Se;
      const te = On();
      return te.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", te.sourceId = (A = b.sourceId) !== null && A !== void 0 ? A : "", te.accessToken = (Se = b.accessToken) !== null && Se !== void 0 ? Se : void 0, te;
    }
  };
  function Mn() {
    return { manifest: "" };
  }
  a.GetSourcePlaylistResponse = {
    encode(b, C = c.default.Writer.create()) {
      return b.manifest !== "" && C.uint32(10).string(b.manifest), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Mn();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.manifest = A.string();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return { manifest: Le(b.manifest) ? String(b.manifest) : "" };
    },
    toJSON(b) {
      const C = {};
      return b.manifest !== void 0 && (C.manifest = b.manifest), C;
    },
    fromPartial(b) {
      var C;
      const A = Mn();
      return A.manifest = (C = b.manifest) !== null && C !== void 0 ? C : "", A;
    }
  };
  function Nn() {
    return { serviceUserId: "", displayName: void 0, role: void 0, maxDuration: void 0 };
  }
  a.CreateAccessTokenRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.serviceUserId !== "" && C.uint32(10).string(b.serviceUserId), b.displayName !== void 0 && C.uint32(34).string(b.displayName), b.role !== void 0 && C.uint32(16).int32(Ue(b.role)), b.maxDuration !== void 0 && C.uint32(24).uint32(b.maxDuration), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Nn();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.serviceUserId = A.string();
            break;
          case 4:
            te.displayName = A.string();
            break;
          case 2:
            te.role = me(A.int32());
            break;
          case 3:
            te.maxDuration = A.uint32();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        serviceUserId: Le(b.serviceUserId) ? String(b.serviceUserId) : "",
        displayName: Le(b.displayName) ? String(b.displayName) : void 0,
        role: Le(b.role) ? me(b.role) : void 0,
        maxDuration: Le(b.maxDuration) ? Number(b.maxDuration) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.serviceUserId !== void 0 && (C.serviceUserId = b.serviceUserId), b.displayName !== void 0 && (C.displayName = b.displayName), b.role !== void 0 && (C.role = b.role !== void 0 ? Oe(b.role) : void 0), b.maxDuration !== void 0 && (C.maxDuration = Math.round(b.maxDuration)), C;
    },
    fromPartial(b) {
      var C, A, Se, te;
      const Te = Nn();
      return Te.serviceUserId = (C = b.serviceUserId) !== null && C !== void 0 ? C : "", Te.displayName = (A = b.displayName) !== null && A !== void 0 ? A : void 0, Te.role = (Se = b.role) !== null && Se !== void 0 ? Se : void 0, Te.maxDuration = (te = b.maxDuration) !== null && te !== void 0 ? te : void 0, Te;
    }
  };
  function An() {
    return { accessToken: "" };
  }
  a.CreateAccessTokenResponse = {
    encode(b, C = c.default.Writer.create()) {
      return b.accessToken !== "" && C.uint32(10).string(b.accessToken), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = An();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.accessToken = A.string();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return { accessToken: Le(b.accessToken) ? String(b.accessToken) : "" };
    },
    toJSON(b) {
      const C = {};
      return b.accessToken !== void 0 && (C.accessToken = b.accessToken), C;
    },
    fromPartial(b) {
      var C;
      const A = An();
      return A.accessToken = (C = b.accessToken) !== null && C !== void 0 ? C : "", A;
    }
  };
  function $n() {
    return { code: "" };
  }
  a.LookupGuestCodeRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.code !== "" && C.uint32(10).string(b.code), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = $n();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.code = A.string();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return { code: Le(b.code) ? String(b.code) : "" };
    },
    toJSON(b) {
      const C = {};
      return b.code !== void 0 && (C.code = b.code), C;
    },
    fromPartial(b) {
      var C;
      const A = $n();
      return A.code = (C = b.code) !== null && C !== void 0 ? C : "", A;
    }
  };
  function Dn() {
    return { url: "" };
  }
  a.LookupGuestCodeResponse = {
    encode(b, C = c.default.Writer.create()) {
      return b.url !== "" && C.uint32(10).string(b.url), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Dn();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.url = A.string();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return { url: Le(b.url) ? String(b.url) : "" };
    },
    toJSON(b) {
      const C = {};
      return b.url !== void 0 && (C.url = b.url), C;
    },
    fromPartial(b) {
      var C;
      const A = Dn();
      return A.url = (C = b.url) !== null && C !== void 0 ? C : "", A;
    }
  };
  function Ln() {
    return { displayName: "", serviceUserId: void 0 };
  }
  a.GuestAccessTokenDirect = {
    encode(b, C = c.default.Writer.create()) {
      return b.displayName !== "" && C.uint32(10).string(b.displayName), b.serviceUserId !== void 0 && C.uint32(18).string(b.serviceUserId), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Ln();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.displayName = A.string();
            break;
          case 2:
            te.serviceUserId = A.string();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        displayName: Le(b.displayName) ? String(b.displayName) : "",
        serviceUserId: Le(b.serviceUserId) ? String(b.serviceUserId) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.displayName !== void 0 && (C.displayName = b.displayName), b.serviceUserId !== void 0 && (C.serviceUserId = b.serviceUserId), C;
    },
    fromPartial(b) {
      var C, A;
      const Se = Ln();
      return Se.displayName = (C = b.displayName) !== null && C !== void 0 ? C : "", Se.serviceUserId = (A = b.serviceUserId) !== null && A !== void 0 ? A : void 0, Se;
    }
  };
  function Bn() {
    return { maxDuration: void 0 };
  }
  a.GuestAccessTokenExchange = {
    encode(b, C = c.default.Writer.create()) {
      return b.maxDuration !== void 0 && C.uint32(8).uint32(b.maxDuration), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Bn();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.maxDuration = A.uint32();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return { maxDuration: Le(b.maxDuration) ? Number(b.maxDuration) : void 0 };
    },
    toJSON(b) {
      const C = {};
      return b.maxDuration !== void 0 && (C.maxDuration = Math.round(b.maxDuration)), C;
    },
    fromPartial(b) {
      var C;
      const A = Bn();
      return A.maxDuration = (C = b.maxDuration) !== null && C !== void 0 ? C : void 0, A;
    }
  };
  function Un() {
    return { direct: void 0, exchange: void 0 };
  }
  a.GuestAccessToken = {
    encode(b, C = c.default.Writer.create()) {
      return b.direct !== void 0 && a.GuestAccessTokenDirect.encode(b.direct, C.uint32(10).fork()).ldelim(), b.exchange !== void 0 && a.GuestAccessTokenExchange.encode(b.exchange, C.uint32(18).fork()).ldelim(), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Un();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.direct = a.GuestAccessTokenDirect.decode(A, A.uint32());
            break;
          case 2:
            te.exchange = a.GuestAccessTokenExchange.decode(A, A.uint32());
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        direct: Le(b.direct) ? a.GuestAccessTokenDirect.fromJSON(b.direct) : void 0,
        exchange: Le(b.exchange) ? a.GuestAccessTokenExchange.fromJSON(b.exchange) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.direct !== void 0 && (C.direct = b.direct ? a.GuestAccessTokenDirect.toJSON(b.direct) : void 0), b.exchange !== void 0 && (C.exchange = b.exchange ? a.GuestAccessTokenExchange.toJSON(b.exchange) : void 0), C;
    },
    fromPartial(b) {
      const C = Un();
      return C.direct = b.direct !== void 0 && b.direct !== null ? a.GuestAccessTokenDirect.fromPartial(b.direct) : void 0, C.exchange = b.exchange !== void 0 && b.exchange !== null ? a.GuestAccessTokenExchange.fromPartial(b.exchange) : void 0, C;
    }
  };
  function xn() {
    return {
      collectionId: "",
      projectId: "",
      maxDuration: void 0,
      role: ue.ROLE_UNSPECIFIED,
      token: void 0,
      url: void 0
    };
  }
  a.CreateGuestAccessTokenRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.projectId !== "" && C.uint32(18).string(b.projectId), b.maxDuration !== void 0 && C.uint32(24).uint32(b.maxDuration), b.role !== ue.ROLE_UNSPECIFIED && C.uint32(32).int32(Ue(b.role)), b.token !== void 0 && a.GuestAccessToken.encode(b.token, C.uint32(42).fork()).ldelim(), b.url !== void 0 && C.uint32(50).string(b.url), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = xn();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.collectionId = A.string();
            break;
          case 2:
            te.projectId = A.string();
            break;
          case 3:
            te.maxDuration = A.uint32();
            break;
          case 4:
            te.role = me(A.int32());
            break;
          case 5:
            te.token = a.GuestAccessToken.decode(A, A.uint32());
            break;
          case 6:
            te.url = A.string();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : "",
        maxDuration: Le(b.maxDuration) ? Number(b.maxDuration) : void 0,
        role: Le(b.role) ? me(b.role) : ue.ROLE_UNSPECIFIED,
        token: Le(b.token) ? a.GuestAccessToken.fromJSON(b.token) : void 0,
        url: Le(b.url) ? String(b.url) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.projectId !== void 0 && (C.projectId = b.projectId), b.maxDuration !== void 0 && (C.maxDuration = Math.round(b.maxDuration)), b.role !== void 0 && (C.role = Oe(b.role)), b.token !== void 0 && (C.token = b.token ? a.GuestAccessToken.toJSON(b.token) : void 0), b.url !== void 0 && (C.url = b.url), C;
    },
    fromPartial(b) {
      var C, A, Se, te, Te;
      const vt = xn();
      return vt.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", vt.projectId = (A = b.projectId) !== null && A !== void 0 ? A : "", vt.maxDuration = (Se = b.maxDuration) !== null && Se !== void 0 ? Se : void 0, vt.role = (te = b.role) !== null && te !== void 0 ? te : ue.ROLE_UNSPECIFIED, vt.token = b.token !== void 0 && b.token !== null ? a.GuestAccessToken.fromPartial(b.token) : void 0, vt.url = (Te = b.url) !== null && Te !== void 0 ? Te : void 0, vt;
    }
  };
  function Fn() {
    return { accessToken: "", url: void 0 };
  }
  a.CreateGuestAccessTokenResponse = {
    encode(b, C = c.default.Writer.create()) {
      return b.accessToken !== "" && C.uint32(10).string(b.accessToken), b.url !== void 0 && C.uint32(18).string(b.url), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Fn();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.accessToken = A.string();
            break;
          case 2:
            te.url = A.string();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        accessToken: Le(b.accessToken) ? String(b.accessToken) : "",
        url: Le(b.url) ? String(b.url) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.accessToken !== void 0 && (C.accessToken = b.accessToken), b.url !== void 0 && (C.url = b.url), C;
    },
    fromPartial(b) {
      var C, A;
      const Se = Fn();
      return Se.accessToken = (C = b.accessToken) !== null && C !== void 0 ? C : "", Se.url = (A = b.url) !== null && A !== void 0 ? A : void 0, Se;
    }
  };
  function qn() {
    return { collectionId: "", projectId: "", displayName: "" };
  }
  a.CreateWebRtcAccessTokenRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.projectId !== "" && C.uint32(18).string(b.projectId), b.displayName !== "" && C.uint32(26).string(b.displayName), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = qn();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.collectionId = A.string();
            break;
          case 2:
            te.projectId = A.string();
            break;
          case 3:
            te.displayName = A.string();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : "",
        displayName: Le(b.displayName) ? String(b.displayName) : ""
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.projectId !== void 0 && (C.projectId = b.projectId), b.displayName !== void 0 && (C.displayName = b.displayName), C;
    },
    fromPartial(b) {
      var C, A, Se;
      const te = qn();
      return te.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", te.projectId = (A = b.projectId) !== null && A !== void 0 ? A : "", te.displayName = (Se = b.displayName) !== null && Se !== void 0 ? Se : "", te;
    }
  };
  function Jn() {
    return { webrtcAccess: void 0 };
  }
  a.CreateWebRtcAccessTokenResponse = {
    encode(b, C = c.default.Writer.create()) {
      return b.webrtcAccess !== void 0 && a.WebRtcAccess.encode(b.webrtcAccess, C.uint32(18).fork()).ldelim(), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Jn();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 2:
            te.webrtcAccess = a.WebRtcAccess.decode(A, A.uint32());
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return { webrtcAccess: Le(b.webrtcAccess) ? a.WebRtcAccess.fromJSON(b.webrtcAccess) : void 0 };
    },
    toJSON(b) {
      const C = {};
      return b.webrtcAccess !== void 0 && (C.webrtcAccess = b.webrtcAccess ? a.WebRtcAccess.toJSON(b.webrtcAccess) : void 0), C;
    },
    fromPartial(b) {
      const C = Jn();
      return C.webrtcAccess = b.webrtcAccess !== void 0 && b.webrtcAccess !== null ? a.WebRtcAccess.fromPartial(b.webrtcAccess) : void 0, C;
    }
  };
  function Vn() {
    return {};
  }
  a.RefreshAccessTokenRequest = {
    encode(b, C = c.default.Writer.create()) {
      return C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Vn();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {};
    },
    toJSON(b) {
      return {};
    },
    fromPartial(b) {
      return Vn();
    }
  };
  function Gn() {
    return {};
  }
  a.RefreshAccessTokenResponse = {
    encode(b, C = c.default.Writer.create()) {
      return C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Gn();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {};
    },
    toJSON(b) {
      return {};
    },
    fromPartial(b) {
      return Gn();
    }
  };
  function Wn() {
    return { collectionId: "", projectId: "", code: "", url: "", autoDelete: void 0 };
  }
  a.GuestCode = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.projectId !== "" && C.uint32(18).string(b.projectId), b.code !== "" && C.uint32(26).string(b.code), b.url !== "" && C.uint32(34).string(b.url), b.autoDelete !== void 0 && _.Timestamp.encode(Ht(b.autoDelete), C.uint32(42).fork()).ldelim(), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Wn();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.collectionId = A.string();
            break;
          case 2:
            te.projectId = A.string();
            break;
          case 3:
            te.code = A.string();
            break;
          case 4:
            te.url = A.string();
            break;
          case 5:
            te.autoDelete = zt(_.Timestamp.decode(A, A.uint32()));
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : "",
        code: Le(b.code) ? String(b.code) : "",
        url: Le(b.url) ? String(b.url) : "",
        autoDelete: Le(b.autoDelete) ? String(b.autoDelete) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.projectId !== void 0 && (C.projectId = b.projectId), b.code !== void 0 && (C.code = b.code), b.url !== void 0 && (C.url = b.url), b.autoDelete !== void 0 && (C.autoDelete = b.autoDelete), C;
    },
    fromPartial(b) {
      var C, A, Se, te, Te;
      const vt = Wn();
      return vt.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", vt.projectId = (A = b.projectId) !== null && A !== void 0 ? A : "", vt.code = (Se = b.code) !== null && Se !== void 0 ? Se : "", vt.url = (te = b.url) !== null && te !== void 0 ? te : "", vt.autoDelete = (Te = b.autoDelete) !== null && Te !== void 0 ? Te : void 0, vt;
    }
  };
  function Hn() {
    return { serviceId: "", code: "" };
  }
  a.GuestCodeRedirectRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.serviceId !== "" && C.uint32(10).string(b.serviceId), b.code !== "" && C.uint32(18).string(b.code), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Hn();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.serviceId = A.string();
            break;
          case 2:
            te.code = A.string();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        serviceId: Le(b.serviceId) ? String(b.serviceId) : "",
        code: Le(b.code) ? String(b.code) : ""
      };
    },
    toJSON(b) {
      const C = {};
      return b.serviceId !== void 0 && (C.serviceId = b.serviceId), b.code !== void 0 && (C.code = b.code), C;
    },
    fromPartial(b) {
      var C, A;
      const Se = Hn();
      return Se.serviceId = (C = b.serviceId) !== null && C !== void 0 ? C : "", Se.code = (A = b.code) !== null && A !== void 0 ? A : "", Se;
    }
  };
  function zn() {
    return {};
  }
  a.GuestCodeRedirectResponse = {
    encode(b, C = c.default.Writer.create()) {
      return C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = zn();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {};
    },
    toJSON(b) {
      return {};
    },
    fromPartial(b) {
      return zn();
    }
  };
  function Kn() {
    return {
      collectionId: "",
      projectId: "",
      maxDuration: void 0,
      role: ue.ROLE_UNSPECIFIED,
      token: void 0,
      targetUrl: "",
      code: "",
      linkUrl: ""
    };
  }
  a.IssuedGuestCode = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.projectId !== "" && C.uint32(18).string(b.projectId), b.maxDuration !== void 0 && C.uint32(24).uint32(b.maxDuration), b.role !== ue.ROLE_UNSPECIFIED && C.uint32(32).int32(Ue(b.role)), b.token !== void 0 && a.GuestAccessToken.encode(b.token, C.uint32(42).fork()).ldelim(), b.targetUrl !== "" && C.uint32(50).string(b.targetUrl), b.code !== "" && C.uint32(58).string(b.code), b.linkUrl !== "" && C.uint32(74).string(b.linkUrl), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Kn();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.collectionId = A.string();
            break;
          case 2:
            te.projectId = A.string();
            break;
          case 3:
            te.maxDuration = A.uint32();
            break;
          case 4:
            te.role = me(A.int32());
            break;
          case 5:
            te.token = a.GuestAccessToken.decode(A, A.uint32());
            break;
          case 6:
            te.targetUrl = A.string();
            break;
          case 7:
            te.code = A.string();
            break;
          case 9:
            te.linkUrl = A.string();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : "",
        maxDuration: Le(b.maxDuration) ? Number(b.maxDuration) : void 0,
        role: Le(b.role) ? me(b.role) : ue.ROLE_UNSPECIFIED,
        token: Le(b.token) ? a.GuestAccessToken.fromJSON(b.token) : void 0,
        targetUrl: Le(b.targetUrl) ? String(b.targetUrl) : "",
        code: Le(b.code) ? String(b.code) : "",
        linkUrl: Le(b.linkUrl) ? String(b.linkUrl) : ""
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.projectId !== void 0 && (C.projectId = b.projectId), b.maxDuration !== void 0 && (C.maxDuration = Math.round(b.maxDuration)), b.role !== void 0 && (C.role = Oe(b.role)), b.token !== void 0 && (C.token = b.token ? a.GuestAccessToken.toJSON(b.token) : void 0), b.targetUrl !== void 0 && (C.targetUrl = b.targetUrl), b.code !== void 0 && (C.code = b.code), b.linkUrl !== void 0 && (C.linkUrl = b.linkUrl), C;
    },
    fromPartial(b) {
      var C, A, Se, te, Te, vt, It;
      const Pt = Kn();
      return Pt.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", Pt.projectId = (A = b.projectId) !== null && A !== void 0 ? A : "", Pt.maxDuration = (Se = b.maxDuration) !== null && Se !== void 0 ? Se : void 0, Pt.role = (te = b.role) !== null && te !== void 0 ? te : ue.ROLE_UNSPECIFIED, Pt.token = b.token !== void 0 && b.token !== null ? a.GuestAccessToken.fromPartial(b.token) : void 0, Pt.targetUrl = (Te = b.targetUrl) !== null && Te !== void 0 ? Te : "", Pt.code = (vt = b.code) !== null && vt !== void 0 ? vt : "", Pt.linkUrl = (It = b.linkUrl) !== null && It !== void 0 ? It : "", Pt;
    }
  };
  function Yn() {
    return {
      collectionId: "",
      projectId: "",
      maxDuration: void 0,
      role: ue.ROLE_UNSPECIFIED,
      token: void 0,
      url: ""
    };
  }
  a.CreateGuestCodeRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.projectId !== "" && C.uint32(18).string(b.projectId), b.maxDuration !== void 0 && C.uint32(24).uint32(b.maxDuration), b.role !== ue.ROLE_UNSPECIFIED && C.uint32(32).int32(Ue(b.role)), b.token !== void 0 && a.GuestAccessToken.encode(b.token, C.uint32(42).fork()).ldelim(), b.url !== "" && C.uint32(50).string(b.url), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Yn();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.collectionId = A.string();
            break;
          case 2:
            te.projectId = A.string();
            break;
          case 3:
            te.maxDuration = A.uint32();
            break;
          case 4:
            te.role = me(A.int32());
            break;
          case 5:
            te.token = a.GuestAccessToken.decode(A, A.uint32());
            break;
          case 6:
            te.url = A.string();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : "",
        maxDuration: Le(b.maxDuration) ? Number(b.maxDuration) : void 0,
        role: Le(b.role) ? me(b.role) : ue.ROLE_UNSPECIFIED,
        token: Le(b.token) ? a.GuestAccessToken.fromJSON(b.token) : void 0,
        url: Le(b.url) ? String(b.url) : ""
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.projectId !== void 0 && (C.projectId = b.projectId), b.maxDuration !== void 0 && (C.maxDuration = Math.round(b.maxDuration)), b.role !== void 0 && (C.role = Oe(b.role)), b.token !== void 0 && (C.token = b.token ? a.GuestAccessToken.toJSON(b.token) : void 0), b.url !== void 0 && (C.url = b.url), C;
    },
    fromPartial(b) {
      var C, A, Se, te, Te;
      const vt = Yn();
      return vt.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", vt.projectId = (A = b.projectId) !== null && A !== void 0 ? A : "", vt.maxDuration = (Se = b.maxDuration) !== null && Se !== void 0 ? Se : void 0, vt.role = (te = b.role) !== null && te !== void 0 ? te : ue.ROLE_UNSPECIFIED, vt.token = b.token !== void 0 && b.token !== null ? a.GuestAccessToken.fromPartial(b.token) : void 0, vt.url = (Te = b.url) !== null && Te !== void 0 ? Te : "", vt;
    }
  };
  function Zn() {
    return { guestCode: void 0 };
  }
  a.CreateGuestCodeResponse = {
    encode(b, C = c.default.Writer.create()) {
      return b.guestCode !== void 0 && a.IssuedGuestCode.encode(b.guestCode, C.uint32(10).fork()).ldelim(), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Zn();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.guestCode = a.IssuedGuestCode.decode(A, A.uint32());
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return { guestCode: Le(b.guestCode) ? a.IssuedGuestCode.fromJSON(b.guestCode) : void 0 };
    },
    toJSON(b) {
      const C = {};
      return b.guestCode !== void 0 && (C.guestCode = b.guestCode ? a.IssuedGuestCode.toJSON(b.guestCode) : void 0), C;
    },
    fromPartial(b) {
      const C = Zn();
      return C.guestCode = b.guestCode !== void 0 && b.guestCode !== null ? a.IssuedGuestCode.fromPartial(b.guestCode) : void 0, C;
    }
  };
  function Qn() {
    return { code: "" };
  }
  a.GetGuestCodeRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.code !== "" && C.uint32(10).string(b.code), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Qn();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.code = A.string();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return { code: Le(b.code) ? String(b.code) : "" };
    },
    toJSON(b) {
      const C = {};
      return b.code !== void 0 && (C.code = b.code), C;
    },
    fromPartial(b) {
      var C;
      const A = Qn();
      return A.code = (C = b.code) !== null && C !== void 0 ? C : "", A;
    }
  };
  function Xn() {
    return { guestCode: void 0 };
  }
  a.GetGuestCodeResponse = {
    encode(b, C = c.default.Writer.create()) {
      return b.guestCode !== void 0 && a.IssuedGuestCode.encode(b.guestCode, C.uint32(10).fork()).ldelim(), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Xn();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.guestCode = a.IssuedGuestCode.decode(A, A.uint32());
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return { guestCode: Le(b.guestCode) ? a.IssuedGuestCode.fromJSON(b.guestCode) : void 0 };
    },
    toJSON(b) {
      const C = {};
      return b.guestCode !== void 0 && (C.guestCode = b.guestCode ? a.IssuedGuestCode.toJSON(b.guestCode) : void 0), C;
    },
    fromPartial(b) {
      const C = Xn();
      return C.guestCode = b.guestCode !== void 0 && b.guestCode !== null ? a.IssuedGuestCode.fromPartial(b.guestCode) : void 0, C;
    }
  };
  function jn() {
    return { collectionId: void 0, projectId: void 0, role: void 0 };
  }
  a.GetGuestCodesRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== void 0 && C.uint32(10).string(b.collectionId), b.projectId !== void 0 && C.uint32(18).string(b.projectId), b.role !== void 0 && C.uint32(24).int32(Ue(b.role)), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = jn();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.collectionId = A.string();
            break;
          case 2:
            te.projectId = A.string();
            break;
          case 3:
            te.role = me(A.int32());
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : void 0,
        projectId: Le(b.projectId) ? String(b.projectId) : void 0,
        role: Le(b.role) ? me(b.role) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.projectId !== void 0 && (C.projectId = b.projectId), b.role !== void 0 && (C.role = b.role !== void 0 ? Oe(b.role) : void 0), C;
    },
    fromPartial(b) {
      var C, A, Se;
      const te = jn();
      return te.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : void 0, te.projectId = (A = b.projectId) !== null && A !== void 0 ? A : void 0, te.role = (Se = b.role) !== null && Se !== void 0 ? Se : void 0, te;
    }
  };
  function ei() {
    return { guestCodes: [] };
  }
  a.GetGuestCodesResponse = {
    encode(b, C = c.default.Writer.create()) {
      for (const A of b.guestCodes)
        a.IssuedGuestCode.encode(A, C.uint32(10).fork()).ldelim();
      return C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = ei();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.guestCodes.push(a.IssuedGuestCode.decode(A, A.uint32()));
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        guestCodes: Array.isArray(b == null ? void 0 : b.guestCodes) ? b.guestCodes.map((C) => a.IssuedGuestCode.fromJSON(C)) : []
      };
    },
    toJSON(b) {
      const C = {};
      return b.guestCodes ? C.guestCodes = b.guestCodes.map((A) => A ? a.IssuedGuestCode.toJSON(A) : void 0) : C.guestCodes = [], C;
    },
    fromPartial(b) {
      var C;
      const A = ei();
      return A.guestCodes = ((C = b.guestCodes) === null || C === void 0 ? void 0 : C.map((Se) => a.IssuedGuestCode.fromPartial(Se))) || [], A;
    }
  };
  function ti() {
    return { code: "" };
  }
  a.DeleteGuestCodeRequest = {
    encode(b, C = c.default.Writer.create()) {
      return b.code !== "" && C.uint32(10).string(b.code), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = ti();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.code = A.string();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return { code: Le(b.code) ? String(b.code) : "" };
    },
    toJSON(b) {
      const C = {};
      return b.code !== void 0 && (C.code = b.code), C;
    },
    fromPartial(b) {
      var C;
      const A = ti();
      return A.code = (C = b.code) !== null && C !== void 0 ? C : "", A;
    }
  };
  function ri() {
    return {};
  }
  a.DeleteGuestCodeResponse = {
    encode(b, C = c.default.Writer.create()) {
      return C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = ri();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {};
    },
    toJSON(b) {
      return {};
    },
    fromPartial(b) {
      return ri();
    }
  };
  function ni() {
    return { alg: "", kty: "", use: "", kid: "", e: "", n: "" };
  }
  a.JsonWebKey = {
    encode(b, C = c.default.Writer.create()) {
      return b.alg !== "" && C.uint32(10).string(b.alg), b.kty !== "" && C.uint32(18).string(b.kty), b.use !== "" && C.uint32(26).string(b.use), b.kid !== "" && C.uint32(34).string(b.kid), b.e !== "" && C.uint32(42).string(b.e), b.n !== "" && C.uint32(50).string(b.n), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = ni();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.alg = A.string();
            break;
          case 2:
            te.kty = A.string();
            break;
          case 3:
            te.use = A.string();
            break;
          case 4:
            te.kid = A.string();
            break;
          case 5:
            te.e = A.string();
            break;
          case 6:
            te.n = A.string();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        alg: Le(b.alg) ? String(b.alg) : "",
        kty: Le(b.kty) ? String(b.kty) : "",
        use: Le(b.use) ? String(b.use) : "",
        kid: Le(b.kid) ? String(b.kid) : "",
        e: Le(b.e) ? String(b.e) : "",
        n: Le(b.n) ? String(b.n) : ""
      };
    },
    toJSON(b) {
      const C = {};
      return b.alg !== void 0 && (C.alg = b.alg), b.kty !== void 0 && (C.kty = b.kty), b.use !== void 0 && (C.use = b.use), b.kid !== void 0 && (C.kid = b.kid), b.e !== void 0 && (C.e = b.e), b.n !== void 0 && (C.n = b.n), C;
    },
    fromPartial(b) {
      var C, A, Se, te, Te, vt;
      const It = ni();
      return It.alg = (C = b.alg) !== null && C !== void 0 ? C : "", It.kty = (A = b.kty) !== null && A !== void 0 ? A : "", It.use = (Se = b.use) !== null && Se !== void 0 ? Se : "", It.kid = (te = b.kid) !== null && te !== void 0 ? te : "", It.e = (Te = b.e) !== null && Te !== void 0 ? Te : "", It.n = (vt = b.n) !== null && vt !== void 0 ? vt : "", It;
    }
  };
  function ii() {
    return {};
  }
  a.GetJsonWebKeySetRequest = {
    encode(b, C = c.default.Writer.create()) {
      return C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = ii();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {};
    },
    toJSON(b) {
      return {};
    },
    fromPartial(b) {
      return ii();
    }
  };
  function ai() {
    return { keys: [] };
  }
  a.GetJsonWebKeySetResponse = {
    encode(b, C = c.default.Writer.create()) {
      for (const A of b.keys)
        a.JsonWebKey.encode(A, C.uint32(10).fork()).ldelim();
      return C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = ai();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.keys.push(a.JsonWebKey.decode(A, A.uint32()));
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return { keys: Array.isArray(b == null ? void 0 : b.keys) ? b.keys.map((C) => a.JsonWebKey.fromJSON(C)) : [] };
    },
    toJSON(b) {
      const C = {};
      return b.keys ? C.keys = b.keys.map((A) => A ? a.JsonWebKey.toJSON(A) : void 0) : C.keys = [], C;
    },
    fromPartial(b) {
      var C;
      const A = ai();
      return A.keys = ((C = b.keys) === null || C === void 0 ? void 0 : C.map((Se) => a.JsonWebKey.fromPartial(Se))) || [], A;
    }
  };
  function oi() {
    return {};
  }
  a.GetTestTokenRequest = {
    encode(b, C = c.default.Writer.create()) {
      return C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = oi();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {};
    },
    toJSON(b) {
      return {};
    },
    fromPartial(b) {
      return oi();
    }
  };
  function si() {
    return { accessToken: "" };
  }
  a.GetTestTokenResponse = {
    encode(b, C = c.default.Writer.create()) {
      return b.accessToken !== "" && C.uint32(10).string(b.accessToken), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = si();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.accessToken = A.string();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return { accessToken: Le(b.accessToken) ? String(b.accessToken) : "" };
    },
    toJSON(b) {
      const C = {};
      return b.accessToken !== void 0 && (C.accessToken = b.accessToken), C;
    },
    fromPartial(b) {
      var C;
      const A = si();
      return A.accessToken = (C = b.accessToken) !== null && C !== void 0 ? C : "", A;
    }
  };
  function di() {
    return { collectionId: "", projectId: "", destinationId: "", destination: void 0 };
  }
  a.DestinationCreateEvent = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.projectId !== "" && C.uint32(18).string(b.projectId), b.destinationId !== "" && C.uint32(26).string(b.destinationId), b.destination !== void 0 && a.Destination.encode(b.destination, C.uint32(34).fork()).ldelim(), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = di();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.collectionId = A.string();
            break;
          case 2:
            te.projectId = A.string();
            break;
          case 3:
            te.destinationId = A.string();
            break;
          case 4:
            te.destination = a.Destination.decode(A, A.uint32());
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : "",
        destinationId: Le(b.destinationId) ? String(b.destinationId) : "",
        destination: Le(b.destination) ? a.Destination.fromJSON(b.destination) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.projectId !== void 0 && (C.projectId = b.projectId), b.destinationId !== void 0 && (C.destinationId = b.destinationId), b.destination !== void 0 && (C.destination = b.destination ? a.Destination.toJSON(b.destination) : void 0), C;
    },
    fromPartial(b) {
      var C, A, Se;
      const te = di();
      return te.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", te.projectId = (A = b.projectId) !== null && A !== void 0 ? A : "", te.destinationId = (Se = b.destinationId) !== null && Se !== void 0 ? Se : "", te.destination = b.destination !== void 0 && b.destination !== null ? a.Destination.fromPartial(b.destination) : void 0, te;
    }
  };
  function ui() {
    return { collectionId: "", projectId: "", destinationId: "" };
  }
  a.DestinationDeleteEvent = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.projectId !== "" && C.uint32(18).string(b.projectId), b.destinationId !== "" && C.uint32(26).string(b.destinationId), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = ui();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.collectionId = A.string();
            break;
          case 2:
            te.projectId = A.string();
            break;
          case 3:
            te.destinationId = A.string();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : "",
        destinationId: Le(b.destinationId) ? String(b.destinationId) : ""
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.projectId !== void 0 && (C.projectId = b.projectId), b.destinationId !== void 0 && (C.destinationId = b.destinationId), C;
    },
    fromPartial(b) {
      var C, A, Se;
      const te = ui();
      return te.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", te.projectId = (A = b.projectId) !== null && A !== void 0 ? A : "", te.destinationId = (Se = b.destinationId) !== null && Se !== void 0 ? Se : "", te;
    }
  };
  function ci() {
    return { collectionId: "", projectId: "", destinationId: "", updateMask: [], destination: void 0 };
  }
  a.DestinationUpdateEvent = {
    encode(b, C = c.default.Writer.create()) {
      b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.projectId !== "" && C.uint32(18).string(b.projectId), b.destinationId !== "" && C.uint32(26).string(b.destinationId);
      for (const A of b.updateMask)
        C.uint32(34).string(A);
      return b.destination !== void 0 && a.Destination.encode(b.destination, C.uint32(42).fork()).ldelim(), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = ci();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.collectionId = A.string();
            break;
          case 2:
            te.projectId = A.string();
            break;
          case 3:
            te.destinationId = A.string();
            break;
          case 4:
            te.updateMask.push(A.string());
            break;
          case 5:
            te.destination = a.Destination.decode(A, A.uint32());
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : "",
        destinationId: Le(b.destinationId) ? String(b.destinationId) : "",
        updateMask: Array.isArray(b == null ? void 0 : b.updateMask) ? b.updateMask.map((C) => String(C)) : [],
        destination: Le(b.destination) ? a.Destination.fromJSON(b.destination) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.projectId !== void 0 && (C.projectId = b.projectId), b.destinationId !== void 0 && (C.destinationId = b.destinationId), b.updateMask ? C.updateMask = b.updateMask.map((A) => A) : C.updateMask = [], b.destination !== void 0 && (C.destination = b.destination ? a.Destination.toJSON(b.destination) : void 0), C;
    },
    fromPartial(b) {
      var C, A, Se, te;
      const Te = ci();
      return Te.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", Te.projectId = (A = b.projectId) !== null && A !== void 0 ? A : "", Te.destinationId = (Se = b.destinationId) !== null && Se !== void 0 ? Se : "", Te.updateMask = ((te = b.updateMask) === null || te === void 0 ? void 0 : te.map((vt) => vt)) || [], Te.destination = b.destination !== void 0 && b.destination !== null ? a.Destination.fromPartial(b.destination) : void 0, Te;
    }
  };
  function li() {
    return { collectionId: "", projectId: "", destinationId: "", connect: void 0 };
  }
  a.DestinationStateEvent = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.projectId !== "" && C.uint32(18).string(b.projectId), b.destinationId !== "" && C.uint32(26).string(b.destinationId), b.connect !== void 0 && C.uint32(32).int32(xe(b.connect)), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = li();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.collectionId = A.string();
            break;
          case 2:
            te.projectId = A.string();
            break;
          case 3:
            te.destinationId = A.string();
            break;
          case 4:
            te.connect = se(A.int32());
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : "",
        destinationId: Le(b.destinationId) ? String(b.destinationId) : "",
        connect: Le(b.connect) ? se(b.connect) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.projectId !== void 0 && (C.projectId = b.projectId), b.destinationId !== void 0 && (C.destinationId = b.destinationId), b.connect !== void 0 && (C.connect = b.connect !== void 0 ? Ee(b.connect) : void 0), C;
    },
    fromPartial(b) {
      var C, A, Se, te;
      const Te = li();
      return Te.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", Te.projectId = (A = b.projectId) !== null && A !== void 0 ? A : "", Te.destinationId = (Se = b.destinationId) !== null && Se !== void 0 ? Se : "", Te.connect = (te = b.connect) !== null && te !== void 0 ? te : void 0, Te;
    }
  };
  function fi() {
    return { collectionId: "", projectId: "", project: void 0 };
  }
  a.ProjectCreateEvent = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.projectId !== "" && C.uint32(18).string(b.projectId), b.project !== void 0 && a.Project.encode(b.project, C.uint32(26).fork()).ldelim(), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = fi();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.collectionId = A.string();
            break;
          case 2:
            te.projectId = A.string();
            break;
          case 3:
            te.project = a.Project.decode(A, A.uint32());
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : "",
        project: Le(b.project) ? a.Project.fromJSON(b.project) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.projectId !== void 0 && (C.projectId = b.projectId), b.project !== void 0 && (C.project = b.project ? a.Project.toJSON(b.project) : void 0), C;
    },
    fromPartial(b) {
      var C, A;
      const Se = fi();
      return Se.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", Se.projectId = (A = b.projectId) !== null && A !== void 0 ? A : "", Se.project = b.project !== void 0 && b.project !== null ? a.Project.fromPartial(b.project) : void 0, Se;
    }
  };
  function hi() {
    return { collectionId: "", projectId: "" };
  }
  a.ProjectDeleteEvent = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.projectId !== "" && C.uint32(18).string(b.projectId), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = hi();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.collectionId = A.string();
            break;
          case 2:
            te.projectId = A.string();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : ""
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.projectId !== void 0 && (C.projectId = b.projectId), C;
    },
    fromPartial(b) {
      var C, A;
      const Se = hi();
      return Se.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", Se.projectId = (A = b.projectId) !== null && A !== void 0 ? A : "", Se;
    }
  };
  function pi() {
    return { collectionId: "", projectId: "", updateMask: [], project: void 0 };
  }
  a.ProjectUpdateEvent = {
    encode(b, C = c.default.Writer.create()) {
      b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.projectId !== "" && C.uint32(18).string(b.projectId);
      for (const A of b.updateMask)
        C.uint32(26).string(A);
      return b.project !== void 0 && a.Project.encode(b.project, C.uint32(34).fork()).ldelim(), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = pi();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.collectionId = A.string();
            break;
          case 2:
            te.projectId = A.string();
            break;
          case 3:
            te.updateMask.push(A.string());
            break;
          case 4:
            te.project = a.Project.decode(A, A.uint32());
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : "",
        updateMask: Array.isArray(b == null ? void 0 : b.updateMask) ? b.updateMask.map((C) => String(C)) : [],
        project: Le(b.project) ? a.Project.fromJSON(b.project) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.projectId !== void 0 && (C.projectId = b.projectId), b.updateMask ? C.updateMask = b.updateMask.map((A) => A) : C.updateMask = [], b.project !== void 0 && (C.project = b.project ? a.Project.toJSON(b.project) : void 0), C;
    },
    fromPartial(b) {
      var C, A, Se;
      const te = pi();
      return te.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", te.projectId = (A = b.projectId) !== null && A !== void 0 ? A : "", te.updateMask = ((Se = b.updateMask) === null || Se === void 0 ? void 0 : Se.map((Te) => Te)) || [], te.project = b.project !== void 0 && b.project !== null ? a.Project.fromPartial(b.project) : void 0, te;
    }
  };
  function mi() {
    return { collectionId: "", projectId: "", broadcastId: "", phase: void 0, error: void 0 };
  }
  a.ProjectBroadcastStateEvent = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.projectId !== "" && C.uint32(18).string(b.projectId), b.broadcastId !== "" && C.uint32(26).string(b.broadcastId), b.phase !== void 0 && C.uint32(32).int32(Ze(b.phase)), b.error !== void 0 && C.uint32(40).int32(Ke(b.error)), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = mi();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.collectionId = A.string();
            break;
          case 2:
            te.projectId = A.string();
            break;
          case 3:
            te.broadcastId = A.string();
            break;
          case 4:
            te.phase = Ne(A.int32());
            break;
          case 5:
            te.error = Ve(A.int32());
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : "",
        broadcastId: Le(b.broadcastId) ? String(b.broadcastId) : "",
        phase: Le(b.phase) ? Ne(b.phase) : void 0,
        error: Le(b.error) ? Ve(b.error) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.projectId !== void 0 && (C.projectId = b.projectId), b.broadcastId !== void 0 && (C.broadcastId = b.broadcastId), b.phase !== void 0 && (C.phase = b.phase !== void 0 ? Fe(b.phase) : void 0), b.error !== void 0 && (C.error = b.error !== void 0 ? Qe(b.error) : void 0), C;
    },
    fromPartial(b) {
      var C, A, Se, te, Te;
      const vt = mi();
      return vt.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", vt.projectId = (A = b.projectId) !== null && A !== void 0 ? A : "", vt.broadcastId = (Se = b.broadcastId) !== null && Se !== void 0 ? Se : "", vt.phase = (te = b.phase) !== null && te !== void 0 ? te : void 0, vt.error = (Te = b.error) !== null && Te !== void 0 ? Te : void 0, vt;
    }
  };
  function vi() {
    return { collectionId: "", collection: void 0 };
  }
  a.CollectionCreateEvent = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.collection !== void 0 && a.Collection.encode(b.collection, C.uint32(18).fork()).ldelim(), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = vi();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.collectionId = A.string();
            break;
          case 2:
            te.collection = a.Collection.decode(A, A.uint32());
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        collection: Le(b.collection) ? a.Collection.fromJSON(b.collection) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.collection !== void 0 && (C.collection = b.collection ? a.Collection.toJSON(b.collection) : void 0), C;
    },
    fromPartial(b) {
      var C;
      const A = vi();
      return A.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", A.collection = b.collection !== void 0 && b.collection !== null ? a.Collection.fromPartial(b.collection) : void 0, A;
    }
  };
  function yi() {
    return { collectionId: "" };
  }
  a.CollectionDeleteEvent = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = yi();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.collectionId = A.string();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return { collectionId: Le(b.collectionId) ? String(b.collectionId) : "" };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), C;
    },
    fromPartial(b) {
      var C;
      const A = yi();
      return A.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", A;
    }
  };
  function gi() {
    return { collectionId: "", updateMask: [], collection: void 0 };
  }
  a.CollectionUpdateEvent = {
    encode(b, C = c.default.Writer.create()) {
      b.collectionId !== "" && C.uint32(10).string(b.collectionId);
      for (const A of b.updateMask)
        C.uint32(18).string(A);
      return b.collection !== void 0 && a.Collection.encode(b.collection, C.uint32(26).fork()).ldelim(), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = gi();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.collectionId = A.string();
            break;
          case 2:
            te.updateMask.push(A.string());
            break;
          case 3:
            te.collection = a.Collection.decode(A, A.uint32());
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        updateMask: Array.isArray(b == null ? void 0 : b.updateMask) ? b.updateMask.map((C) => String(C)) : [],
        collection: Le(b.collection) ? a.Collection.fromJSON(b.collection) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.updateMask ? C.updateMask = b.updateMask.map((A) => A) : C.updateMask = [], b.collection !== void 0 && (C.collection = b.collection ? a.Collection.toJSON(b.collection) : void 0), C;
    },
    fromPartial(b) {
      var C, A;
      const Se = gi();
      return Se.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", Se.updateMask = ((A = b.updateMask) === null || A === void 0 ? void 0 : A.map((te) => te)) || [], Se.collection = b.collection !== void 0 && b.collection !== null ? a.Collection.fromPartial(b.collection) : void 0, Se;
    }
  };
  function bi() {
    return { collectionId: "", sourceId: "", source: void 0 };
  }
  a.SourceCreateEvent = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.sourceId !== "" && C.uint32(18).string(b.sourceId), b.source !== void 0 && a.Source.encode(b.source, C.uint32(26).fork()).ldelim(), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = bi();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.collectionId = A.string();
            break;
          case 2:
            te.sourceId = A.string();
            break;
          case 3:
            te.source = a.Source.decode(A, A.uint32());
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        sourceId: Le(b.sourceId) ? String(b.sourceId) : "",
        source: Le(b.source) ? a.Source.fromJSON(b.source) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.sourceId !== void 0 && (C.sourceId = b.sourceId), b.source !== void 0 && (C.source = b.source ? a.Source.toJSON(b.source) : void 0), C;
    },
    fromPartial(b) {
      var C, A;
      const Se = bi();
      return Se.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", Se.sourceId = (A = b.sourceId) !== null && A !== void 0 ? A : "", Se.source = b.source !== void 0 && b.source !== null ? a.Source.fromPartial(b.source) : void 0, Se;
    }
  };
  function Si() {
    return { collectionId: "", sourceId: "" };
  }
  a.SourceDeleteEvent = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.sourceId !== "" && C.uint32(18).string(b.sourceId), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Si();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.collectionId = A.string();
            break;
          case 2:
            te.sourceId = A.string();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        sourceId: Le(b.sourceId) ? String(b.sourceId) : ""
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.sourceId !== void 0 && (C.sourceId = b.sourceId), C;
    },
    fromPartial(b) {
      var C, A;
      const Se = Si();
      return Se.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", Se.sourceId = (A = b.sourceId) !== null && A !== void 0 ? A : "", Se;
    }
  };
  function _i() {
    return { collectionId: "", sourceId: "", updateMask: [], source: void 0 };
  }
  a.SourceUpdateEvent = {
    encode(b, C = c.default.Writer.create()) {
      b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.sourceId !== "" && C.uint32(18).string(b.sourceId);
      for (const A of b.updateMask)
        C.uint32(26).string(A);
      return b.source !== void 0 && a.Source.encode(b.source, C.uint32(34).fork()).ldelim(), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = _i();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.collectionId = A.string();
            break;
          case 2:
            te.sourceId = A.string();
            break;
          case 3:
            te.updateMask.push(A.string());
            break;
          case 4:
            te.source = a.Source.decode(A, A.uint32());
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        sourceId: Le(b.sourceId) ? String(b.sourceId) : "",
        updateMask: Array.isArray(b == null ? void 0 : b.updateMask) ? b.updateMask.map((C) => String(C)) : [],
        source: Le(b.source) ? a.Source.fromJSON(b.source) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.sourceId !== void 0 && (C.sourceId = b.sourceId), b.updateMask ? C.updateMask = b.updateMask.map((A) => A) : C.updateMask = [], b.source !== void 0 && (C.source = b.source ? a.Source.toJSON(b.source) : void 0), C;
    },
    fromPartial(b) {
      var C, A, Se;
      const te = _i();
      return te.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", te.sourceId = (A = b.sourceId) !== null && A !== void 0 ? A : "", te.updateMask = ((Se = b.updateMask) === null || Se === void 0 ? void 0 : Se.map((Te) => Te)) || [], te.source = b.source !== void 0 && b.source !== null ? a.Source.fromPartial(b.source) : void 0, te;
    }
  };
  function Ei() {
    return { collectionId: "", sourceId: "", projectId: "", source: void 0 };
  }
  a.SourceAddEvent = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.sourceId !== "" && C.uint32(18).string(b.sourceId), b.projectId !== "" && C.uint32(26).string(b.projectId), b.source !== void 0 && a.Source.encode(b.source, C.uint32(34).fork()).ldelim(), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Ei();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.collectionId = A.string();
            break;
          case 2:
            te.sourceId = A.string();
            break;
          case 3:
            te.projectId = A.string();
            break;
          case 4:
            te.source = a.Source.decode(A, A.uint32());
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        sourceId: Le(b.sourceId) ? String(b.sourceId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : "",
        source: Le(b.source) ? a.Source.fromJSON(b.source) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.sourceId !== void 0 && (C.sourceId = b.sourceId), b.projectId !== void 0 && (C.projectId = b.projectId), b.source !== void 0 && (C.source = b.source ? a.Source.toJSON(b.source) : void 0), C;
    },
    fromPartial(b) {
      var C, A, Se;
      const te = Ei();
      return te.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", te.sourceId = (A = b.sourceId) !== null && A !== void 0 ? A : "", te.projectId = (Se = b.projectId) !== null && Se !== void 0 ? Se : "", te.source = b.source !== void 0 && b.source !== null ? a.Source.fromPartial(b.source) : void 0, te;
    }
  };
  function Ti() {
    return { collectionId: "", sourceId: "", projectId: "" };
  }
  a.SourceRemoveEvent = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.sourceId !== "" && C.uint32(18).string(b.sourceId), b.projectId !== "" && C.uint32(26).string(b.projectId), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Ti();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.collectionId = A.string();
            break;
          case 2:
            te.sourceId = A.string();
            break;
          case 3:
            te.projectId = A.string();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        sourceId: Le(b.sourceId) ? String(b.sourceId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : ""
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.sourceId !== void 0 && (C.sourceId = b.sourceId), b.projectId !== void 0 && (C.projectId = b.projectId), C;
    },
    fromPartial(b) {
      var C, A, Se;
      const te = Ti();
      return te.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", te.sourceId = (A = b.sourceId) !== null && A !== void 0 ? A : "", te.projectId = (Se = b.projectId) !== null && Se !== void 0 ? Se : "", te;
    }
  };
  function ki() {
    return { collectionId: "", projectId: "", sourceId: "", connect: void 0 };
  }
  a.SourceStateEvent = {
    encode(b, C = c.default.Writer.create()) {
      return b.collectionId !== "" && C.uint32(10).string(b.collectionId), b.projectId !== "" && C.uint32(18).string(b.projectId), b.sourceId !== "" && C.uint32(26).string(b.sourceId), b.connect !== void 0 && C.uint32(32).int32(xe(b.connect)), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = ki();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.collectionId = A.string();
            break;
          case 2:
            te.projectId = A.string();
            break;
          case 3:
            te.sourceId = A.string();
            break;
          case 4:
            te.connect = se(A.int32());
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        collectionId: Le(b.collectionId) ? String(b.collectionId) : "",
        projectId: Le(b.projectId) ? String(b.projectId) : "",
        sourceId: Le(b.sourceId) ? String(b.sourceId) : "",
        connect: Le(b.connect) ? se(b.connect) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collectionId !== void 0 && (C.collectionId = b.collectionId), b.projectId !== void 0 && (C.projectId = b.projectId), b.sourceId !== void 0 && (C.sourceId = b.sourceId), b.connect !== void 0 && (C.connect = b.connect !== void 0 ? Ee(b.connect) : void 0), C;
    },
    fromPartial(b) {
      var C, A, Se, te;
      const Te = ki();
      return Te.collectionId = (C = b.collectionId) !== null && C !== void 0 ? C : "", Te.projectId = (A = b.projectId) !== null && A !== void 0 ? A : "", Te.sourceId = (Se = b.sourceId) !== null && Se !== void 0 ? Se : "", Te.connect = (te = b.connect) !== null && te !== void 0 ? te : void 0, Te;
    }
  };
  function wi() {
    return { create: void 0, update: void 0, delete: void 0 };
  }
  a.CollectionEvent = {
    encode(b, C = c.default.Writer.create()) {
      return b.create !== void 0 && a.CollectionCreateEvent.encode(b.create, C.uint32(10).fork()).ldelim(), b.update !== void 0 && a.CollectionUpdateEvent.encode(b.update, C.uint32(18).fork()).ldelim(), b.delete !== void 0 && a.CollectionDeleteEvent.encode(b.delete, C.uint32(26).fork()).ldelim(), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = wi();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.create = a.CollectionCreateEvent.decode(A, A.uint32());
            break;
          case 2:
            te.update = a.CollectionUpdateEvent.decode(A, A.uint32());
            break;
          case 3:
            te.delete = a.CollectionDeleteEvent.decode(A, A.uint32());
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        create: Le(b.create) ? a.CollectionCreateEvent.fromJSON(b.create) : void 0,
        update: Le(b.update) ? a.CollectionUpdateEvent.fromJSON(b.update) : void 0,
        delete: Le(b.delete) ? a.CollectionDeleteEvent.fromJSON(b.delete) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.create !== void 0 && (C.create = b.create ? a.CollectionCreateEvent.toJSON(b.create) : void 0), b.update !== void 0 && (C.update = b.update ? a.CollectionUpdateEvent.toJSON(b.update) : void 0), b.delete !== void 0 && (C.delete = b.delete ? a.CollectionDeleteEvent.toJSON(b.delete) : void 0), C;
    },
    fromPartial(b) {
      const C = wi();
      return C.create = b.create !== void 0 && b.create !== null ? a.CollectionCreateEvent.fromPartial(b.create) : void 0, C.update = b.update !== void 0 && b.update !== null ? a.CollectionUpdateEvent.fromPartial(b.update) : void 0, C.delete = b.delete !== void 0 && b.delete !== null ? a.CollectionDeleteEvent.fromPartial(b.delete) : void 0, C;
    }
  };
  function Ii() {
    return { create: void 0, update: void 0, delete: void 0, state: void 0 };
  }
  a.DestinationEvent = {
    encode(b, C = c.default.Writer.create()) {
      return b.create !== void 0 && a.DestinationCreateEvent.encode(b.create, C.uint32(10).fork()).ldelim(), b.update !== void 0 && a.DestinationUpdateEvent.encode(b.update, C.uint32(18).fork()).ldelim(), b.delete !== void 0 && a.DestinationDeleteEvent.encode(b.delete, C.uint32(26).fork()).ldelim(), b.state !== void 0 && a.DestinationStateEvent.encode(b.state, C.uint32(34).fork()).ldelim(), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Ii();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.create = a.DestinationCreateEvent.decode(A, A.uint32());
            break;
          case 2:
            te.update = a.DestinationUpdateEvent.decode(A, A.uint32());
            break;
          case 3:
            te.delete = a.DestinationDeleteEvent.decode(A, A.uint32());
            break;
          case 4:
            te.state = a.DestinationStateEvent.decode(A, A.uint32());
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        create: Le(b.create) ? a.DestinationCreateEvent.fromJSON(b.create) : void 0,
        update: Le(b.update) ? a.DestinationUpdateEvent.fromJSON(b.update) : void 0,
        delete: Le(b.delete) ? a.DestinationDeleteEvent.fromJSON(b.delete) : void 0,
        state: Le(b.state) ? a.DestinationStateEvent.fromJSON(b.state) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.create !== void 0 && (C.create = b.create ? a.DestinationCreateEvent.toJSON(b.create) : void 0), b.update !== void 0 && (C.update = b.update ? a.DestinationUpdateEvent.toJSON(b.update) : void 0), b.delete !== void 0 && (C.delete = b.delete ? a.DestinationDeleteEvent.toJSON(b.delete) : void 0), b.state !== void 0 && (C.state = b.state ? a.DestinationStateEvent.toJSON(b.state) : void 0), C;
    },
    fromPartial(b) {
      const C = Ii();
      return C.create = b.create !== void 0 && b.create !== null ? a.DestinationCreateEvent.fromPartial(b.create) : void 0, C.update = b.update !== void 0 && b.update !== null ? a.DestinationUpdateEvent.fromPartial(b.update) : void 0, C.delete = b.delete !== void 0 && b.delete !== null ? a.DestinationDeleteEvent.fromPartial(b.delete) : void 0, C.state = b.state !== void 0 && b.state !== null ? a.DestinationStateEvent.fromPartial(b.state) : void 0, C;
    }
  };
  function Ri() {
    return { create: void 0, update: void 0, delete: void 0, state: void 0 };
  }
  a.ProjectEvent = {
    encode(b, C = c.default.Writer.create()) {
      return b.create !== void 0 && a.ProjectCreateEvent.encode(b.create, C.uint32(10).fork()).ldelim(), b.update !== void 0 && a.ProjectUpdateEvent.encode(b.update, C.uint32(18).fork()).ldelim(), b.delete !== void 0 && a.ProjectDeleteEvent.encode(b.delete, C.uint32(26).fork()).ldelim(), b.state !== void 0 && a.ProjectBroadcastStateEvent.encode(b.state, C.uint32(34).fork()).ldelim(), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Ri();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.create = a.ProjectCreateEvent.decode(A, A.uint32());
            break;
          case 2:
            te.update = a.ProjectUpdateEvent.decode(A, A.uint32());
            break;
          case 3:
            te.delete = a.ProjectDeleteEvent.decode(A, A.uint32());
            break;
          case 4:
            te.state = a.ProjectBroadcastStateEvent.decode(A, A.uint32());
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        create: Le(b.create) ? a.ProjectCreateEvent.fromJSON(b.create) : void 0,
        update: Le(b.update) ? a.ProjectUpdateEvent.fromJSON(b.update) : void 0,
        delete: Le(b.delete) ? a.ProjectDeleteEvent.fromJSON(b.delete) : void 0,
        state: Le(b.state) ? a.ProjectBroadcastStateEvent.fromJSON(b.state) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.create !== void 0 && (C.create = b.create ? a.ProjectCreateEvent.toJSON(b.create) : void 0), b.update !== void 0 && (C.update = b.update ? a.ProjectUpdateEvent.toJSON(b.update) : void 0), b.delete !== void 0 && (C.delete = b.delete ? a.ProjectDeleteEvent.toJSON(b.delete) : void 0), b.state !== void 0 && (C.state = b.state ? a.ProjectBroadcastStateEvent.toJSON(b.state) : void 0), C;
    },
    fromPartial(b) {
      const C = Ri();
      return C.create = b.create !== void 0 && b.create !== null ? a.ProjectCreateEvent.fromPartial(b.create) : void 0, C.update = b.update !== void 0 && b.update !== null ? a.ProjectUpdateEvent.fromPartial(b.update) : void 0, C.delete = b.delete !== void 0 && b.delete !== null ? a.ProjectDeleteEvent.fromPartial(b.delete) : void 0, C.state = b.state !== void 0 && b.state !== null ? a.ProjectBroadcastStateEvent.fromPartial(b.state) : void 0, C;
    }
  };
  function Ci() {
    return {
      create: void 0,
      update: void 0,
      delete: void 0,
      add: void 0,
      remove: void 0,
      state: void 0
    };
  }
  a.SourceEvent = {
    encode(b, C = c.default.Writer.create()) {
      return b.create !== void 0 && a.SourceCreateEvent.encode(b.create, C.uint32(10).fork()).ldelim(), b.update !== void 0 && a.SourceUpdateEvent.encode(b.update, C.uint32(18).fork()).ldelim(), b.delete !== void 0 && a.SourceDeleteEvent.encode(b.delete, C.uint32(26).fork()).ldelim(), b.add !== void 0 && a.SourceAddEvent.encode(b.add, C.uint32(34).fork()).ldelim(), b.remove !== void 0 && a.SourceRemoveEvent.encode(b.remove, C.uint32(42).fork()).ldelim(), b.state !== void 0 && a.SourceStateEvent.encode(b.state, C.uint32(50).fork()).ldelim(), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Ci();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.create = a.SourceCreateEvent.decode(A, A.uint32());
            break;
          case 2:
            te.update = a.SourceUpdateEvent.decode(A, A.uint32());
            break;
          case 3:
            te.delete = a.SourceDeleteEvent.decode(A, A.uint32());
            break;
          case 4:
            te.add = a.SourceAddEvent.decode(A, A.uint32());
            break;
          case 5:
            te.remove = a.SourceRemoveEvent.decode(A, A.uint32());
            break;
          case 6:
            te.state = a.SourceStateEvent.decode(A, A.uint32());
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        create: Le(b.create) ? a.SourceCreateEvent.fromJSON(b.create) : void 0,
        update: Le(b.update) ? a.SourceUpdateEvent.fromJSON(b.update) : void 0,
        delete: Le(b.delete) ? a.SourceDeleteEvent.fromJSON(b.delete) : void 0,
        add: Le(b.add) ? a.SourceAddEvent.fromJSON(b.add) : void 0,
        remove: Le(b.remove) ? a.SourceRemoveEvent.fromJSON(b.remove) : void 0,
        state: Le(b.state) ? a.SourceStateEvent.fromJSON(b.state) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.create !== void 0 && (C.create = b.create ? a.SourceCreateEvent.toJSON(b.create) : void 0), b.update !== void 0 && (C.update = b.update ? a.SourceUpdateEvent.toJSON(b.update) : void 0), b.delete !== void 0 && (C.delete = b.delete ? a.SourceDeleteEvent.toJSON(b.delete) : void 0), b.add !== void 0 && (C.add = b.add ? a.SourceAddEvent.toJSON(b.add) : void 0), b.remove !== void 0 && (C.remove = b.remove ? a.SourceRemoveEvent.toJSON(b.remove) : void 0), b.state !== void 0 && (C.state = b.state ? a.SourceStateEvent.toJSON(b.state) : void 0), C;
    },
    fromPartial(b) {
      const C = Ci();
      return C.create = b.create !== void 0 && b.create !== null ? a.SourceCreateEvent.fromPartial(b.create) : void 0, C.update = b.update !== void 0 && b.update !== null ? a.SourceUpdateEvent.fromPartial(b.update) : void 0, C.delete = b.delete !== void 0 && b.delete !== null ? a.SourceDeleteEvent.fromPartial(b.delete) : void 0, C.add = b.add !== void 0 && b.add !== null ? a.SourceAddEvent.fromPartial(b.add) : void 0, C.remove = b.remove !== void 0 && b.remove !== null ? a.SourceRemoveEvent.fromPartial(b.remove) : void 0, C.state = b.state !== void 0 && b.state !== null ? a.SourceStateEvent.fromPartial(b.state) : void 0, C;
    }
  };
  function Pi() {
    return {
      collection: void 0,
      destination: void 0,
      project: void 0,
      source: void 0,
      unspecified: void 0
    };
  }
  a.LiveEvent = {
    encode(b, C = c.default.Writer.create()) {
      return b.collection !== void 0 && a.CollectionEvent.encode(b.collection, C.uint32(10).fork()).ldelim(), b.destination !== void 0 && a.DestinationEvent.encode(b.destination, C.uint32(18).fork()).ldelim(), b.project !== void 0 && a.ProjectEvent.encode(b.project, C.uint32(26).fork()).ldelim(), b.source !== void 0 && a.SourceEvent.encode(b.source, C.uint32(34).fork()).ldelim(), b.unspecified !== void 0 && C.uint32(40).int32((0, p.nullValueToNumber)(b.unspecified)), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Pi();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.collection = a.CollectionEvent.decode(A, A.uint32());
            break;
          case 2:
            te.destination = a.DestinationEvent.decode(A, A.uint32());
            break;
          case 3:
            te.project = a.ProjectEvent.decode(A, A.uint32());
            break;
          case 4:
            te.source = a.SourceEvent.decode(A, A.uint32());
            break;
          case 5:
            te.unspecified = (0, p.nullValueFromJSON)(A.int32());
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        collection: Le(b.collection) ? a.CollectionEvent.fromJSON(b.collection) : void 0,
        destination: Le(b.destination) ? a.DestinationEvent.fromJSON(b.destination) : void 0,
        project: Le(b.project) ? a.ProjectEvent.fromJSON(b.project) : void 0,
        source: Le(b.source) ? a.SourceEvent.fromJSON(b.source) : void 0,
        unspecified: Le(b.unspecified) ? (0, p.nullValueFromJSON)(b.unspecified) : void 0
      };
    },
    toJSON(b) {
      const C = {};
      return b.collection !== void 0 && (C.collection = b.collection ? a.CollectionEvent.toJSON(b.collection) : void 0), b.destination !== void 0 && (C.destination = b.destination ? a.DestinationEvent.toJSON(b.destination) : void 0), b.project !== void 0 && (C.project = b.project ? a.ProjectEvent.toJSON(b.project) : void 0), b.source !== void 0 && (C.source = b.source ? a.SourceEvent.toJSON(b.source) : void 0), b.unspecified !== void 0 && (C.unspecified = b.unspecified !== void 0 ? (0, p.nullValueToJSON)(b.unspecified) : void 0), C;
    },
    fromPartial(b) {
      var C;
      const A = Pi();
      return A.collection = b.collection !== void 0 && b.collection !== null ? a.CollectionEvent.fromPartial(b.collection) : void 0, A.destination = b.destination !== void 0 && b.destination !== null ? a.DestinationEvent.fromPartial(b.destination) : void 0, A.project = b.project !== void 0 && b.project !== null ? a.ProjectEvent.fromPartial(b.project) : void 0, A.source = b.source !== void 0 && b.source !== null ? a.SourceEvent.fromPartial(b.source) : void 0, A.unspecified = (C = b.unspecified) !== null && C !== void 0 ? C : void 0, A;
    }
  };
  function Oi() {
    return {};
  }
  a.GetServiceRequest = {
    encode(b, C = c.default.Writer.create()) {
      return C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Oi();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {};
    },
    toJSON(b) {
      return {};
    },
    fromPartial(b) {
      return Oi();
    }
  };
  function Mi() {
    return { serviceName: "", serviceId: "", enabled: !1, demo: !1 };
  }
  a.Service = {
    encode(b, C = c.default.Writer.create()) {
      return b.serviceName !== "" && C.uint32(18).string(b.serviceName), b.serviceId !== "" && C.uint32(26).string(b.serviceId), b.enabled === !0 && C.uint32(72).bool(b.enabled), b.demo === !0 && C.uint32(88).bool(b.demo), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Mi();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 2:
            te.serviceName = A.string();
            break;
          case 3:
            te.serviceId = A.string();
            break;
          case 9:
            te.enabled = A.bool();
            break;
          case 11:
            te.demo = A.bool();
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return {
        serviceName: Le(b.serviceName) ? String(b.serviceName) : "",
        serviceId: Le(b.serviceId) ? String(b.serviceId) : "",
        enabled: Le(b.enabled) ? !!b.enabled : !1,
        demo: Le(b.demo) ? !!b.demo : !1
      };
    },
    toJSON(b) {
      const C = {};
      return b.serviceName !== void 0 && (C.serviceName = b.serviceName), b.serviceId !== void 0 && (C.serviceId = b.serviceId), b.enabled !== void 0 && (C.enabled = b.enabled), b.demo !== void 0 && (C.demo = b.demo), C;
    },
    fromPartial(b) {
      var C, A, Se, te;
      const Te = Mi();
      return Te.serviceName = (C = b.serviceName) !== null && C !== void 0 ? C : "", Te.serviceId = (A = b.serviceId) !== null && A !== void 0 ? A : "", Te.enabled = (Se = b.enabled) !== null && Se !== void 0 ? Se : !1, Te.demo = (te = b.demo) !== null && te !== void 0 ? te : !1, Te;
    }
  };
  function Ni() {
    return { service: void 0 };
  }
  a.GetServiceResponse = {
    encode(b, C = c.default.Writer.create()) {
      return b.service !== void 0 && a.Service.encode(b.service, C.uint32(10).fork()).ldelim(), C;
    },
    decode(b, C) {
      const A = b instanceof c.default.Reader ? b : new c.default.Reader(b);
      let Se = C === void 0 ? A.len : A.pos + C;
      const te = Ni();
      for (; A.pos < Se; ) {
        const Te = A.uint32();
        switch (Te >>> 3) {
          case 1:
            te.service = a.Service.decode(A, A.uint32());
            break;
          default:
            A.skipType(Te & 7);
            break;
        }
      }
      return te;
    },
    fromJSON(b) {
      return { service: Le(b.service) ? a.Service.fromJSON(b.service) : void 0 };
    },
    toJSON(b) {
      const C = {};
      return b.service !== void 0 && (C.service = b.service ? a.Service.toJSON(b.service) : void 0), C;
    },
    fromPartial(b) {
      const C = Ni();
      return C.service = b.service !== void 0 && b.service !== null ? a.Service.fromPartial(b.service) : void 0, C;
    }
  };
  class $i {
    constructor(C, A) {
      this.service = (A == null ? void 0 : A.service) || "live.v21.AccountConfigurationService", this.rpc = C, this.GetAccountConfiguration = this.GetAccountConfiguration.bind(this), this.UpdateAccountConfiguration = this.UpdateAccountConfiguration.bind(this);
    }
    GetAccountConfiguration(C) {
      const A = a.GetAccountConfigurationRequest.encode(C).finish();
      return this.rpc.request(this.service, "GetAccountConfiguration", A).then((te) => a.GetAccountConfigurationResponse.decode(new c.default.Reader(te)));
    }
    UpdateAccountConfiguration(C) {
      const A = a.UpdateAccountConfigurationRequest.encode(C).finish();
      return this.rpc.request(this.service, "UpdateAccountConfiguration", A).then((te) => a.UpdateAccountConfigurationResponse.decode(new c.default.Reader(te)));
    }
  }
  a.AccountConfigurationServiceClientImpl = $i, a.AccountConfigurationServiceDefinition = {
    name: "AccountConfigurationService",
    fullName: "live.v21.AccountConfigurationService",
    methods: {
      /** get account configuration */
      getAccountConfiguration: {
        name: "GetAccountConfiguration",
        requestType: a.GetAccountConfigurationRequest,
        requestStream: !1,
        responseType: a.GetAccountConfigurationResponse,
        responseStream: !1,
        options: {}
      },
      /** update account configuration */
      updateAccountConfiguration: {
        name: "UpdateAccountConfiguration",
        requestType: a.UpdateAccountConfigurationRequest,
        requestStream: !1,
        responseType: a.UpdateAccountConfigurationResponse,
        responseStream: !1,
        options: {}
      }
    }
  };
  class Di {
    constructor(C, A) {
      this.service = (A == null ? void 0 : A.service) || "live.v21.CollectionService", this.rpc = C, this.CreateCollection = this.CreateCollection.bind(this), this.GetCollection = this.GetCollection.bind(this), this.GetCollections = this.GetCollections.bind(this), this.UpdateCollection = this.UpdateCollection.bind(this), this.DeleteCollection = this.DeleteCollection.bind(this);
    }
    CreateCollection(C) {
      const A = a.CreateCollectionRequest.encode(C).finish();
      return this.rpc.request(this.service, "CreateCollection", A).then((te) => a.CreateCollectionResponse.decode(new c.default.Reader(te)));
    }
    GetCollection(C) {
      const A = a.GetCollectionRequest.encode(C).finish();
      return this.rpc.request(this.service, "GetCollection", A).then((te) => a.GetCollectionResponse.decode(new c.default.Reader(te)));
    }
    GetCollections(C) {
      const A = a.GetCollectionsRequest.encode(C).finish();
      return this.rpc.request(this.service, "GetCollections", A).then((te) => a.GetCollectionsResponse.decode(new c.default.Reader(te)));
    }
    UpdateCollection(C) {
      const A = a.UpdateCollectionRequest.encode(C).finish();
      return this.rpc.request(this.service, "UpdateCollection", A).then((te) => a.UpdateCollectionResponse.decode(new c.default.Reader(te)));
    }
    DeleteCollection(C) {
      const A = a.DeleteCollectionRequest.encode(C).finish();
      return this.rpc.request(this.service, "DeleteCollection", A).then((te) => a.DeleteCollectionResponse.decode(new c.default.Reader(te)));
    }
  }
  a.CollectionServiceClientImpl = Di, a.CollectionServiceDefinition = {
    name: "CollectionService",
    fullName: "live.v21.CollectionService",
    methods: {
      /**
       * Create Collection
       *
       * Create a new collection of related projects and collection live sources
       */
      createCollection: {
        name: "CreateCollection",
        requestType: a.CreateCollectionRequest,
        requestStream: !1,
        responseType: a.CreateCollectionResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Get Collection
       *
       * Get an existing collection of related projects and collection live
       * sources
       */
      getCollection: {
        name: "GetCollection",
        requestType: a.GetCollectionRequest,
        requestStream: !1,
        responseType: a.GetCollectionResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Get Collections
       *
       * Get all collections owned by the user
       */
      getCollections: {
        name: "GetCollections",
        requestType: a.GetCollectionsRequest,
        requestStream: !1,
        responseType: a.GetCollectionsResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Update Collection
       *
       * Update select collection document data
       */
      updateCollection: {
        name: "UpdateCollection",
        requestType: a.UpdateCollectionRequest,
        requestStream: !1,
        responseType: a.UpdateCollectionResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Delete Collection
       *
       * Delete a collection of related projects and collection live sources
       */
      deleteCollection: {
        name: "DeleteCollection",
        requestType: a.DeleteCollectionRequest,
        requestStream: !1,
        responseType: a.DeleteCollectionResponse,
        responseStream: !1,
        options: {}
      }
    }
  };
  class Li {
    constructor(C, A) {
      this.service = (A == null ? void 0 : A.service) || "live.v21.ProjectService", this.rpc = C, this.CreateProject = this.CreateProject.bind(this), this.GetProject = this.GetProject.bind(this), this.DeleteProject = this.DeleteProject.bind(this), this.UpdateProject = this.UpdateProject.bind(this), this.StartProjectBroadcast = this.StartProjectBroadcast.bind(this), this.StopProjectBroadcast = this.StopProjectBroadcast.bind(this), this.StartProjectWebRtc = this.StartProjectWebRtc.bind(this), this.StopProjectWebRtc = this.StopProjectWebRtc.bind(this), this.GetProjectBroadcastSnapshot = this.GetProjectBroadcastSnapshot.bind(this), this.GetProjectBroadcastStatus = this.GetProjectBroadcastStatus.bind(this);
    }
    CreateProject(C) {
      const A = a.CreateProjectRequest.encode(C).finish();
      return this.rpc.request(this.service, "CreateProject", A).then((te) => a.CreateProjectResponse.decode(new c.default.Reader(te)));
    }
    GetProject(C) {
      const A = a.GetProjectRequest.encode(C).finish();
      return this.rpc.request(this.service, "GetProject", A).then((te) => a.GetProjectResponse.decode(new c.default.Reader(te)));
    }
    DeleteProject(C) {
      const A = a.DeleteProjectRequest.encode(C).finish();
      return this.rpc.request(this.service, "DeleteProject", A).then((te) => a.DeleteProjectResponse.decode(new c.default.Reader(te)));
    }
    UpdateProject(C) {
      const A = a.UpdateProjectRequest.encode(C).finish();
      return this.rpc.request(this.service, "UpdateProject", A).then((te) => a.UpdateProjectResponse.decode(new c.default.Reader(te)));
    }
    StartProjectBroadcast(C) {
      const A = a.StartProjectBroadcastRequest.encode(C).finish();
      return this.rpc.request(this.service, "StartProjectBroadcast", A).then((te) => a.StartProjectBroadcastResponse.decode(new c.default.Reader(te)));
    }
    StopProjectBroadcast(C) {
      const A = a.StopProjectBroadcastRequest.encode(C).finish();
      return this.rpc.request(this.service, "StopProjectBroadcast", A).then((te) => a.StopProjectBroadcastResponse.decode(new c.default.Reader(te)));
    }
    StartProjectWebRtc(C) {
      const A = a.StartProjectWebRtcRequest.encode(C).finish();
      return this.rpc.request(this.service, "StartProjectWebRtc", A).then((te) => a.StartProjectWebRtcResponse.decode(new c.default.Reader(te)));
    }
    StopProjectWebRtc(C) {
      const A = a.StopProjectWebRtcRequest.encode(C).finish();
      return this.rpc.request(this.service, "StopProjectWebRtc", A).then((te) => a.StopProjectWebRtcResponse.decode(new c.default.Reader(te)));
    }
    GetProjectBroadcastSnapshot(C) {
      const A = a.GetProjectBroadcastSnapshotRequest.encode(C).finish();
      return this.rpc.request(this.service, "GetProjectBroadcastSnapshot", A).then((te) => a.GetProjectBroadcastSnapshotResponse.decode(new c.default.Reader(te)));
    }
    GetProjectBroadcastStatus(C) {
      const A = a.GetProjectBroadcastStatusRequest.encode(C).finish();
      return this.rpc.request(this.service, "GetProjectBroadcastStatus", A).then((te) => a.GetProjectBroadcastStatusResponse.decode(new c.default.Reader(te)));
    }
  }
  a.ProjectServiceClientImpl = Li, a.ProjectServiceDefinition = {
    name: "ProjectService",
    fullName: "live.v21.ProjectService",
    methods: {
      /**
       * Create Project
       *
       * Create a new project
       */
      createProject: {
        name: "CreateProject",
        requestType: a.CreateProjectRequest,
        requestStream: !1,
        responseType: a.CreateProjectResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Get Project
       *
       * Get an existing project
       */
      getProject: {
        name: "GetProject",
        requestType: a.GetProjectRequest,
        requestStream: !1,
        responseType: a.GetProjectResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Delete Project
       *
       * Delete a project
       */
      deleteProject: {
        name: "DeleteProject",
        requestType: a.DeleteProjectRequest,
        requestStream: !1,
        responseType: a.DeleteProjectResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Update Project
       *
       * Updates a project
       */
      updateProject: {
        name: "UpdateProject",
        requestType: a.UpdateProjectRequest,
        requestStream: !1,
        responseType: a.UpdateProjectResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Start Broadcast
       *
       * Start broadcasting a project
       */
      startProjectBroadcast: {
        name: "StartProjectBroadcast",
        requestType: a.StartProjectBroadcastRequest,
        requestStream: !1,
        responseType: a.StartProjectBroadcastResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Stop Broadcast
       *
       * Stop broadcasting a project
       */
      stopProjectBroadcast: {
        name: "StopProjectBroadcast",
        requestType: a.StopProjectBroadcastRequest,
        requestStream: !1,
        responseType: a.StopProjectBroadcastResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Start WebRTC
       *
       * Start WebRTC services
       */
      startProjectWebRtc: {
        name: "StartProjectWebRtc",
        requestType: a.StartProjectWebRtcRequest,
        requestStream: !1,
        responseType: a.StartProjectWebRtcResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Stop WebRTC
       *
       * Stop WebRTC services
       */
      stopProjectWebRtc: {
        name: "StopProjectWebRtc",
        requestType: a.StopProjectWebRtcRequest,
        requestStream: !1,
        responseType: a.StopProjectWebRtcResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Get Snapshot
       *
       * Get a snapshot of the current output frame of the broadcast
       */
      getProjectBroadcastSnapshot: {
        name: "GetProjectBroadcastSnapshot",
        requestType: a.GetProjectBroadcastSnapshotRequest,
        requestStream: !1,
        responseType: a.GetProjectBroadcastSnapshotResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Get Broadcast Status
       *
       * Get the broadcast status of the project
       */
      getProjectBroadcastStatus: {
        name: "GetProjectBroadcastStatus",
        requestType: a.GetProjectBroadcastStatusRequest,
        requestStream: !1,
        responseType: a.GetProjectBroadcastStatusResponse,
        responseStream: !1,
        options: {}
      }
    }
  };
  class Bi {
    constructor(C, A) {
      this.service = (A == null ? void 0 : A.service) || "live.v21.DestinationService", this.rpc = C, this.CreateDestination = this.CreateDestination.bind(this), this.GetDestination = this.GetDestination.bind(this), this.UpdateDestination = this.UpdateDestination.bind(this), this.DeleteDestination = this.DeleteDestination.bind(this);
    }
    CreateDestination(C) {
      const A = a.CreateDestinationRequest.encode(C).finish();
      return this.rpc.request(this.service, "CreateDestination", A).then((te) => a.CreateDestinationResponse.decode(new c.default.Reader(te)));
    }
    GetDestination(C) {
      const A = a.GetDestinationRequest.encode(C).finish();
      return this.rpc.request(this.service, "GetDestination", A).then((te) => a.GetDestinationResponse.decode(new c.default.Reader(te)));
    }
    UpdateDestination(C) {
      const A = a.UpdateDestinationRequest.encode(C).finish();
      return this.rpc.request(this.service, "UpdateDestination", A).then((te) => a.UpdateDestinationResponse.decode(new c.default.Reader(te)));
    }
    DeleteDestination(C) {
      const A = a.DeleteDestinationRequest.encode(C).finish();
      return this.rpc.request(this.service, "DeleteDestination", A).then((te) => a.DeleteDestinationResponse.decode(new c.default.Reader(te)));
    }
  }
  a.DestinationServiceClientImpl = Bi, a.DestinationServiceDefinition = {
    name: "DestinationService",
    fullName: "live.v21.DestinationService",
    methods: {
      /**
       * Create Destination
       *
       * Create a new Destination
       */
      createDestination: {
        name: "CreateDestination",
        requestType: a.CreateDestinationRequest,
        requestStream: !1,
        responseType: a.CreateDestinationResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Get Destination
       *
       * Get an existing Destination.
       */
      getDestination: {
        name: "GetDestination",
        requestType: a.GetDestinationRequest,
        requestStream: !1,
        responseType: a.GetDestinationResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Update Destination
       *
       * Update a destination
       */
      updateDestination: {
        name: "UpdateDestination",
        requestType: a.UpdateDestinationRequest,
        requestStream: !1,
        responseType: a.UpdateDestinationResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Delete Destination
       *
       * Delete a destination
       */
      deleteDestination: {
        name: "DeleteDestination",
        requestType: a.DeleteDestinationRequest,
        requestStream: !1,
        responseType: a.DeleteDestinationResponse,
        responseStream: !1,
        options: {}
      }
    }
  };
  class Ui {
    constructor(C, A) {
      this.service = (A == null ? void 0 : A.service) || "live.v21.SourceService", this.rpc = C, this.CreateSource = this.CreateSource.bind(this), this.DeleteSource = this.DeleteSource.bind(this), this.UpdateSource = this.UpdateSource.bind(this), this.UpdateSourceInProject = this.UpdateSourceInProject.bind(this), this.GetSource = this.GetSource.bind(this), this.GetSources = this.GetSources.bind(this), this.AddSourceToProject = this.AddSourceToProject.bind(this), this.RemoveSourceFromProject = this.RemoveSourceFromProject.bind(this), this.GetSourcePlaylist = this.GetSourcePlaylist.bind(this);
    }
    CreateSource(C) {
      const A = a.CreateSourceRequest.encode(C).finish();
      return this.rpc.request(this.service, "CreateSource", A).then((te) => a.CreateSourceResponse.decode(new c.default.Reader(te)));
    }
    DeleteSource(C) {
      const A = a.DeleteSourceRequest.encode(C).finish();
      return this.rpc.request(this.service, "DeleteSource", A).then((te) => a.DeleteSourceResponse.decode(new c.default.Reader(te)));
    }
    UpdateSource(C) {
      const A = a.UpdateSourceRequest.encode(C).finish();
      return this.rpc.request(this.service, "UpdateSource", A).then((te) => a.UpdateSourceResponse.decode(new c.default.Reader(te)));
    }
    UpdateSourceInProject(C) {
      const A = a.UpdateSourceInProjectRequest.encode(C).finish();
      return this.rpc.request(this.service, "UpdateSourceInProject", A).then((te) => a.UpdateSourceInProjectResponse.decode(new c.default.Reader(te)));
    }
    GetSource(C) {
      const A = a.GetSourceRequest.encode(C).finish();
      return this.rpc.request(this.service, "GetSource", A).then((te) => a.GetSourceResponse.decode(new c.default.Reader(te)));
    }
    GetSources(C) {
      const A = a.GetSourcesRequest.encode(C).finish();
      return this.rpc.request(this.service, "GetSources", A).then((te) => a.GetSourcesResponse.decode(new c.default.Reader(te)));
    }
    AddSourceToProject(C) {
      const A = a.AddSourceToProjectRequest.encode(C).finish();
      return this.rpc.request(this.service, "AddSourceToProject", A).then((te) => a.AddSourceToProjectResponse.decode(new c.default.Reader(te)));
    }
    RemoveSourceFromProject(C) {
      const A = a.RemoveSourceFromProjectRequest.encode(C).finish();
      return this.rpc.request(this.service, "RemoveSourceFromProject", A).then((te) => a.RemoveSourceFromProjectResponse.decode(new c.default.Reader(te)));
    }
    GetSourcePlaylist(C) {
      const A = a.GetSourcePlaylistRequest.encode(C).finish();
      return this.rpc.request(this.service, "GetSourcePlaylist", A).then((te) => l.HttpBody.decode(new c.default.Reader(te)));
    }
  }
  a.SourceServiceClientImpl = Ui, a.SourceServiceDefinition = {
    name: "SourceService",
    fullName: "live.v21.SourceService",
    methods: {
      /**
       * Create Collection Live Source
       *
       * Create a new live source in a collection
       * ### Permissions
       * * scope: `SCOPE_VAPI_CREATE`
       */
      createSource: {
        name: "CreateSource",
        requestType: a.CreateSourceRequest,
        requestStream: !1,
        responseType: a.CreateSourceResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Delete Live Source
       *
       * Deletes a live source from a collection
       */
      deleteSource: {
        name: "DeleteSource",
        requestType: a.DeleteSourceRequest,
        requestStream: !1,
        responseType: a.DeleteSourceResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Update Source
       *
       * Update attributes of the Source.
       */
      updateSource: {
        name: "UpdateSource",
        requestType: a.UpdateSourceRequest,
        requestStream: !1,
        responseType: a.UpdateSourceResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Update Source
       *
       * Update attributes of the Source.
       */
      updateSourceInProject: {
        name: "UpdateSourceInProject",
        requestType: a.UpdateSourceInProjectRequest,
        requestStream: !1,
        responseType: a.UpdateSourceInProjectResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Get Source
       *
       * Get an existing source in a project
       */
      getSource: {
        name: "GetSource",
        requestType: a.GetSourceRequest,
        requestStream: !1,
        responseType: a.GetSourceResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Get Source
       *
       * Get existing sources in a collection
       */
      getSources: {
        name: "GetSources",
        requestType: a.GetSourcesRequest,
        requestStream: !1,
        responseType: a.GetSourcesResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Add Source to Project
       *
       * Add a source to a project
       */
      addSourceToProject: {
        name: "AddSourceToProject",
        requestType: a.AddSourceToProjectRequest,
        requestStream: !1,
        responseType: a.AddSourceToProjectResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Delete Source From Project
       *
       * Removes a source from a project.
       */
      removeSourceFromProject: {
        name: "RemoveSourceFromProject",
        requestType: a.RemoveSourceFromProjectRequest,
        requestStream: !1,
        responseType: a.RemoveSourceFromProjectResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Get the HLS playlist for a source.
       * buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
       */
      getSourcePlaylist: {
        name: "GetSourcePlaylist",
        requestType: a.GetSourcePlaylistRequest,
        requestStream: !1,
        responseType: l.HttpBody,
        responseStream: !1,
        options: {}
      }
    }
  };
  class xi {
    constructor(C, A) {
      this.service = (A == null ? void 0 : A.service) || "live.v21.BackendAuthenticationService", this.rpc = C, this.CreateAccessToken = this.CreateAccessToken.bind(this), this.LookupGuestCode = this.LookupGuestCode.bind(this);
    }
    CreateAccessToken(C) {
      const A = a.CreateAccessTokenRequest.encode(C).finish();
      return this.rpc.request(this.service, "CreateAccessToken", A).then((te) => a.CreateAccessTokenResponse.decode(new c.default.Reader(te)));
    }
    LookupGuestCode(C) {
      const A = a.LookupGuestCodeRequest.encode(C).finish();
      return this.rpc.request(this.service, "LookupGuestCode", A).then((te) => a.LookupGuestCodeResponse.decode(new c.default.Reader(te)));
    }
  }
  a.BackendAuthenticationServiceClientImpl = xi, a.BackendAuthenticationServiceDefinition = {
    name: "BackendAuthenticationService",
    fullName: "live.v21.BackendAuthenticationService",
    methods: {
      /**
       * Create Access Token
       *
       * Create an access token for a session host
       */
      createAccessToken: {
        name: "CreateAccessToken",
        requestType: a.CreateAccessTokenRequest,
        requestStream: !1,
        responseType: a.CreateAccessTokenResponse,
        responseStream: !1,
        options: {}
      },
      lookupGuestCode: {
        name: "LookupGuestCode",
        requestType: a.LookupGuestCodeRequest,
        requestStream: !1,
        responseType: a.LookupGuestCodeResponse,
        responseStream: !1,
        options: {}
      }
    }
  };
  class Fi {
    constructor(C, A) {
      this.service = (A == null ? void 0 : A.service) || "live.v21.AuthenticationService", this.rpc = C, this.CreateGuestAccessToken = this.CreateGuestAccessToken.bind(this), this.RefreshAccessToken = this.RefreshAccessToken.bind(this), this.CreateWebRtcAccessToken = this.CreateWebRtcAccessToken.bind(this), this.CreateGuestCode = this.CreateGuestCode.bind(this), this.GetGuestCode = this.GetGuestCode.bind(this), this.GetGuestCodes = this.GetGuestCodes.bind(this), this.DeleteGuestCode = this.DeleteGuestCode.bind(this);
    }
    CreateGuestAccessToken(C) {
      const A = a.CreateGuestAccessTokenRequest.encode(C).finish();
      return this.rpc.request(this.service, "CreateGuestAccessToken", A).then((te) => a.CreateGuestAccessTokenResponse.decode(new c.default.Reader(te)));
    }
    RefreshAccessToken(C) {
      const A = a.RefreshAccessTokenRequest.encode(C).finish();
      return this.rpc.request(this.service, "RefreshAccessToken", A).then((te) => a.RefreshAccessTokenResponse.decode(new c.default.Reader(te)));
    }
    CreateWebRtcAccessToken(C) {
      const A = a.CreateWebRtcAccessTokenRequest.encode(C).finish();
      return this.rpc.request(this.service, "CreateWebRtcAccessToken", A).then((te) => a.CreateWebRtcAccessTokenResponse.decode(new c.default.Reader(te)));
    }
    CreateGuestCode(C) {
      const A = a.CreateGuestCodeRequest.encode(C).finish();
      return this.rpc.request(this.service, "CreateGuestCode", A).then((te) => a.CreateGuestCodeResponse.decode(new c.default.Reader(te)));
    }
    GetGuestCode(C) {
      const A = a.GetGuestCodeRequest.encode(C).finish();
      return this.rpc.request(this.service, "GetGuestCode", A).then((te) => a.GetGuestCodeResponse.decode(new c.default.Reader(te)));
    }
    GetGuestCodes(C) {
      const A = a.GetGuestCodesRequest.encode(C).finish();
      return this.rpc.request(this.service, "GetGuestCodes", A).then((te) => a.GetGuestCodesResponse.decode(new c.default.Reader(te)));
    }
    DeleteGuestCode(C) {
      const A = a.DeleteGuestCodeRequest.encode(C).finish();
      return this.rpc.request(this.service, "DeleteGuestCode", A).then((te) => a.DeleteGuestCodeResponse.decode(new c.default.Reader(te)));
    }
  }
  a.AuthenticationServiceClientImpl = Fi, a.AuthenticationServiceDefinition = {
    name: "AuthenticationService",
    fullName: "live.v21.AuthenticationService",
    methods: {
      /**
       * Create Guest Access Token
       *
       * Create an access token for a guest
       */
      createGuestAccessToken: {
        name: "CreateGuestAccessToken",
        requestType: a.CreateGuestAccessTokenRequest,
        requestStream: !1,
        responseType: a.CreateGuestAccessTokenResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Refresh Access Token
       *
       * Forcibly refresh an access token prior to expiration
       */
      refreshAccessToken: {
        name: "RefreshAccessToken",
        requestType: a.RefreshAccessTokenRequest,
        requestStream: !1,
        responseType: a.RefreshAccessTokenResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Create WebRTC Access Token
       *
       * Create a WebRTC Access Token
       */
      createWebRtcAccessToken: {
        name: "CreateWebRtcAccessToken",
        requestType: a.CreateWebRtcAccessTokenRequest,
        requestStream: !1,
        responseType: a.CreateWebRtcAccessTokenResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Create a new guest code
       *
       * Create a new guest code
       */
      createGuestCode: {
        name: "CreateGuestCode",
        requestType: a.CreateGuestCodeRequest,
        requestStream: !1,
        responseType: a.CreateGuestCodeResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Get Guest code
       *
       * Get an existing guest code
       */
      getGuestCode: {
        name: "GetGuestCode",
        requestType: a.GetGuestCodeRequest,
        requestStream: !1,
        responseType: a.GetGuestCodeResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Get Guest Codes
       *
       * Get all guest codes owned by the user, optionally associated with a collection or project.
       */
      getGuestCodes: {
        name: "GetGuestCodes",
        requestType: a.GetGuestCodesRequest,
        requestStream: !1,
        responseType: a.GetGuestCodesResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Delete Guest Code
       *
       * Delete a guest code
       */
      deleteGuestCode: {
        name: "DeleteGuestCode",
        requestType: a.DeleteGuestCodeRequest,
        requestStream: !1,
        responseType: a.DeleteGuestCodeResponse,
        responseStream: !1,
        options: {}
      }
    }
  };
  class qi {
    constructor(C, A) {
      this.service = (A == null ? void 0 : A.service) || "live.v21.PublicAuthenticationService", this.rpc = C, this.GetJsonWebKeySet = this.GetJsonWebKeySet.bind(this), this.GuestCodeRedirect = this.GuestCodeRedirect.bind(this);
    }
    GetJsonWebKeySet(C) {
      const A = a.GetJsonWebKeySetRequest.encode(C).finish();
      return this.rpc.request(this.service, "GetJsonWebKeySet", A).then((te) => a.GetJsonWebKeySetResponse.decode(new c.default.Reader(te)));
    }
    GuestCodeRedirect(C) {
      const A = a.GuestCodeRedirectRequest.encode(C).finish();
      return this.rpc.request(this.service, "GuestCodeRedirect", A).then((te) => a.GuestCodeRedirectResponse.decode(new c.default.Reader(te)));
    }
  }
  a.PublicAuthenticationServiceClientImpl = qi, a.PublicAuthenticationServiceDefinition = {
    name: "PublicAuthenticationService",
    fullName: "live.v21.PublicAuthenticationService",
    methods: {
      /**
       * Get Public Keys
       *
       * Get public keys used to sign access tokens
       */
      getJsonWebKeySet: {
        name: "GetJsonWebKeySet",
        requestType: a.GetJsonWebKeySetRequest,
        requestStream: !1,
        responseType: a.GetJsonWebKeySetResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Exchange Guest Access Token
       *
       * Exchange a guest access token with updated user identifiers
       */
      guestCodeRedirect: {
        name: "GuestCodeRedirect",
        requestType: a.GuestCodeRedirectRequest,
        requestStream: !1,
        responseType: a.GuestCodeRedirectResponse,
        responseStream: !1,
        options: {}
      }
    }
  };
  class Ji {
    constructor(C, A) {
      this.service = (A == null ? void 0 : A.service) || "live.v21.AccountService", this.rpc = C, this.GetService = this.GetService.bind(this);
    }
    GetService(C) {
      const A = a.GetServiceRequest.encode(C).finish();
      return this.rpc.request(this.service, "GetService", A).then((te) => a.GetServiceResponse.decode(new c.default.Reader(te)));
    }
  }
  a.AccountServiceClientImpl = Ji, a.AccountServiceDefinition = {
    name: "AccountService",
    fullName: "live.v21.AccountService",
    methods: {
      /** get account configuration */
      getService: {
        name: "GetService",
        requestType: a.GetServiceRequest,
        requestStream: !1,
        responseType: a.GetServiceResponse,
        responseStream: !1,
        options: {}
      }
    }
  };
  var Tt = (() => {
    if (typeof globalThis < "u")
      return globalThis;
    if (typeof self < "u")
      return self;
    if (typeof window < "u")
      return window;
    if (typeof commonjsGlobal$1 < "u")
      return commonjsGlobal$1;
    throw "Unable to locate global object";
  })();
  function Vi(b) {
    if (Tt.Buffer)
      return Uint8Array.from(Tt.Buffer.from(b, "base64"));
    {
      const C = Tt.atob(b), A = new Uint8Array(C.length);
      for (let Se = 0; Se < C.length; ++Se)
        A[Se] = C.charCodeAt(Se);
      return A;
    }
  }
  function Gi(b) {
    if (Tt.Buffer)
      return Tt.Buffer.from(b).toString("base64");
    {
      const C = [];
      return b.forEach((A) => {
        C.push(String.fromCharCode(A));
      }), Tt.btoa(C.join(""));
    }
  }
  function Ht(b) {
    const C = new Date(b), A = C.getTime() / 1e3, Se = C.getTime() % 1e3 * 1e6;
    return { seconds: A, nanos: Se };
  }
  function zt(b) {
    let C = b.seconds * 1e3;
    return C += b.nanos / 1e6, new Date(C).toISOString();
  }
  function Wi(b) {
    return typeof b == "object" && b !== null;
  }
  function Le(b) {
    return b != null;
  }
})(api$2);
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(V, X, oe, Y) {
    Y === void 0 && (Y = oe);
    var ae = Object.getOwnPropertyDescriptor(X, oe);
    (!ae || ("get" in ae ? !X.__esModule : ae.writable || ae.configurable)) && (ae = { enumerable: !0, get: function() {
      return X[oe];
    } }), Object.defineProperty(V, Y, ae);
  } : function(V, X, oe, Y) {
    Y === void 0 && (Y = oe), V[Y] = X[oe];
  }), c = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(V, X) {
    Object.defineProperty(V, "default", { enumerable: !0, value: X });
  } : function(V, X) {
    V.default = X;
  }), l = commonjsGlobal$1 && commonjsGlobal$1.__decorate || function(V, X, oe, Y) {
    var ae = arguments.length, ne = ae < 3 ? X : Y === null ? Y = Object.getOwnPropertyDescriptor(X, oe) : Y, fe;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      ne = Reflect.decorate(V, X, oe, Y);
    else
      for (var ie = V.length - 1; ie >= 0; ie--)
        (fe = V[ie]) && (ne = (ae < 3 ? fe(ne) : ae > 3 ? fe(X, oe, ne) : fe(X, oe)) || ne);
    return ae > 3 && ne && Object.defineProperty(X, oe, ne), ne;
  }, v = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(V) {
    if (V && V.__esModule)
      return V;
    var X = {};
    if (V != null)
      for (var oe in V)
        oe !== "default" && Object.prototype.hasOwnProperty.call(V, oe) && u(X, V, oe);
    return c(X, V), X;
  }, p = commonjsGlobal$1 && commonjsGlobal$1.__metadata || function(V, X) {
    if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
      return Reflect.metadata(V, X);
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.LiveApi = void 0, v(lib$1);
  const _ = api$3, k = v(api$2), M = decorator, L = "LiveApi";
  class F extends _.ApiClient {
    constructor(X, oe, Y, ae, ne, fe, ie) {
      super(X, Y, fe, L, ie, void 0, ne), this.handlers = {}, this.eventApi = oe, this.accessTokenRefreshCallback = ae, this.publicAuthentication = this.clientFactory.create(k.PublicAuthenticationServiceDefinition, this.channel), ne != null && (this.backendAuthentication = this.clientFactory.create(k.BackendAuthenticationServiceDefinition, this.channel, {
        "*": { metadata: this.makeGrpcMetadataApikey() }
      }), this.accountConfiguration = this.clientFactory.create(k.AccountConfigurationServiceDefinition, this.channel, {
        "*": { metadata: this.makeGrpcMetadataApikey() }
      }), this.account = this.clientFactory.create(k.AccountServiceDefinition, this.channel, {
        "*": { metadata: this.makeGrpcMetadataApikey() }
      })), this.eventApi.on("event", { name: `${F.LIVEAPI_EVENT_PREFIX}:*`, ignoreSessionEvents: !0, allowedSessionEvents: [`${F.LIVEAPI_EVENT_PREFIX}:EVENT_TYPE_PROJECT:EVENT_SUB_TYPE_STATE`] }, this.eventCallback.bind(this));
    }
    /**
    * Register an event handler
    *
    * @param type Type of event
    * @param handler
    */
    on(X, oe) {
      var Y;
      this.handlers[X] = (Y = this.handlers[X]) !== null && Y !== void 0 ? Y : [], this.handlers[X].push(oe);
    }
    /**
     * Unregister an event handler
     *
     * @param type Type of event
     * @param handler
     */
    off(X, oe) {
      this.handlers[X] = this.handlers[X].filter((Y) => Y !== oe);
    }
    emitToHandlers(X, oe, Y) {
      var ae;
      for (const ne of (ae = this.handlers[X]) !== null && ae !== void 0 ? ae : [])
        ne(Object.values(Y).find((fe) => !!fe), oe);
    }
    async subscribeToCollection(X) {
      await this.eventApi.subscribe(`${F.LIVEAPI_EVENT_PREFIX}:*`, { target: { collectionId: X } });
    }
    async unsubscribeFromCollection(X) {
      await this.eventApi.unsubscribe(`${F.LIVEAPI_EVENT_PREFIX}:*`, { target: { collectionId: X } });
    }
    async subscribeToProject(X, oe) {
      await this.eventApi.subscribe(`${F.LIVEAPI_EVENT_PREFIX}:*`, { target: { collectionId: X, projectId: oe } });
    }
    async unsubscribeFromProject(X, oe) {
      await this.eventApi.unsubscribe(`${F.LIVEAPI_EVENT_PREFIX}:*`, { target: { collectionId: X, projectId: oe } });
    }
    eventCallback(X) {
      let Y = X.name.split(`${F.LIVEAPI_EVENT_PREFIX}:`)[1].split(":"), ae = k.eventTypeFromJSON(Y[0]), ne = k.eventSubTypeFromJSON(Y[1]);
      this.log.info("processing event: " + ae + "/" + ne), F.liveApiEventMap[ae] && this.emitToHandlers(ae, ne, X.payload);
    }
    _setup(X) {
      let oe = this;
      X.onHeader = function(Y) {
        let ae = Y.get("Authorization");
        if (ae != null) {
          const ne = ae.split(" ");
          if (ne.length == 2 && ne[0] == "Bearer") {
            let fe = ne[1];
            oe.log.info("received refresh token"), oe.accessTokenRefreshCallback(fe);
          }
        }
      }, this.collection = this.clientFactory.create(k.CollectionServiceDefinition, this.channel, {
        "*": X
      }), this.project = this.clientFactory.create(k.ProjectServiceDefinition, this.channel, {
        "*": X
      }), this.source = this.clientFactory.create(k.SourceServiceDefinition, this.channel, {
        "*": X
      }), this.destination = this.clientFactory.create(k.DestinationServiceDefinition, this.channel, {
        "*": X
      }), this.authentication = this.clientFactory.create(k.AuthenticationServiceDefinition, this.channel, {
        "*": X
      });
    }
  }
  F.LIVEAPI_EVENT_PREFIX = "apistream:live", l([
    (0, M.RequiresSdkAuthentication)(),
    p("design:type", Object)
  ], F.prototype, "collection", void 0), l([
    (0, M.RequiresSdkAuthentication)(),
    p("design:type", Object)
  ], F.prototype, "project", void 0), l([
    (0, M.RequiresSdkAuthentication)(),
    p("design:type", Object)
  ], F.prototype, "source", void 0), l([
    (0, M.RequiresSdkAuthentication)(),
    p("design:type", Object)
  ], F.prototype, "destination", void 0), l([
    (0, M.RequiresSdkAuthentication)(),
    p("design:type", Object)
  ], F.prototype, "authentication", void 0), a.LiveApi = F, function(V) {
    V.liveApiEventMap = {
      [k.EventType.EVENT_TYPE_COLLECTION]: "collection",
      [k.EventType.EVENT_TYPE_PROJECT]: "project",
      [k.EventType.EVENT_TYPE_SOURCE]: "source",
      [k.EventType.EVENT_TYPE_DESTINATION]: "destination",
      [k.EventType.EVENT_TYPE_UNSPECIFIED]: "unspecified"
    };
  }(F = a.LiveApi || (a.LiveApi = {}));
})(liveapi);
var eventapi = {}, dist$1 = {}, api$1 = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(a, u) {
  return extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(c, l) {
    c.__proto__ = l;
  } || function(c, l) {
    for (var v in l)
      l.hasOwnProperty(v) && (c[v] = l[v]);
  }, extendStatics(a, u);
};
function __extends(a, u) {
  extendStatics(a, u);
  function c() {
    this.constructor = a;
  }
  a.prototype = u === null ? Object.create(u) : (c.prototype = u.prototype, new c());
}
function isFunction$3(a) {
  return typeof a == "function";
}
var _enable_super_gross_mode_that_will_cause_bad_things = !1, config$3 = {
  Promise: void 0,
  set useDeprecatedSynchronousErrorHandling(a) {
    if (a) {
      var u = /* @__PURE__ */ new Error();
      "" + u.stack;
    }
    _enable_super_gross_mode_that_will_cause_bad_things = a;
  },
  get useDeprecatedSynchronousErrorHandling() {
    return _enable_super_gross_mode_that_will_cause_bad_things;
  }
};
function hostReportError(a) {
  setTimeout(function() {
    throw a;
  }, 0);
}
var empty$3 = {
  closed: !0,
  next: function(a) {
  },
  error: function(a) {
    if (config$3.useDeprecatedSynchronousErrorHandling)
      throw a;
    hostReportError(a);
  },
  complete: function() {
  }
}, isArray$5 = /* @__PURE__ */ function() {
  return Array.isArray || function(a) {
    return a && typeof a.length == "number";
  };
}();
function isObject$9(a) {
  return a !== null && typeof a == "object";
}
var UnsubscriptionErrorImpl = /* @__PURE__ */ function() {
  function a(u) {
    return Error.call(this), this.message = u ? u.length + ` errors occurred during unsubscription:
` + u.map(function(c, l) {
      return l + 1 + ") " + c.toString();
    }).join(`
  `) : "", this.name = "UnsubscriptionError", this.errors = u, this;
  }
  return a.prototype = /* @__PURE__ */ Object.create(Error.prototype), a;
}(), UnsubscriptionError = UnsubscriptionErrorImpl, Subscription = /* @__PURE__ */ function() {
  function a(u) {
    this.closed = !1, this._parentOrParents = null, this._subscriptions = null, u && (this._ctorUnsubscribe = !0, this._unsubscribe = u);
  }
  return a.prototype.unsubscribe = function() {
    var u;
    if (!this.closed) {
      var c = this, l = c._parentOrParents, v = c._ctorUnsubscribe, p = c._unsubscribe, _ = c._subscriptions;
      if (this.closed = !0, this._parentOrParents = null, this._subscriptions = null, l instanceof a)
        l.remove(this);
      else if (l !== null)
        for (var k = 0; k < l.length; ++k) {
          var M = l[k];
          M.remove(this);
        }
      if (isFunction$3(p)) {
        v && (this._unsubscribe = void 0);
        try {
          p.call(this);
        } catch (V) {
          u = V instanceof UnsubscriptionError ? flattenUnsubscriptionErrors(V.errors) : [V];
        }
      }
      if (isArray$5(_))
        for (var k = -1, L = _.length; ++k < L; ) {
          var F = _[k];
          if (isObject$9(F))
            try {
              F.unsubscribe();
            } catch (X) {
              u = u || [], X instanceof UnsubscriptionError ? u = u.concat(flattenUnsubscriptionErrors(X.errors)) : u.push(X);
            }
        }
      if (u)
        throw new UnsubscriptionError(u);
    }
  }, a.prototype.add = function(u) {
    var c = u;
    if (!u)
      return a.EMPTY;
    switch (typeof u) {
      case "function":
        c = new a(u);
      case "object":
        if (c === this || c.closed || typeof c.unsubscribe != "function")
          return c;
        if (this.closed)
          return c.unsubscribe(), c;
        if (!(c instanceof a)) {
          var l = c;
          c = new a(), c._subscriptions = [l];
        }
        break;
      default:
        throw new Error("unrecognized teardown " + u + " added to Subscription.");
    }
    var v = c._parentOrParents;
    if (v === null)
      c._parentOrParents = this;
    else if (v instanceof a) {
      if (v === this)
        return c;
      c._parentOrParents = [v, this];
    } else if (v.indexOf(this) === -1)
      v.push(this);
    else
      return c;
    var p = this._subscriptions;
    return p === null ? this._subscriptions = [c] : p.push(c), c;
  }, a.prototype.remove = function(u) {
    var c = this._subscriptions;
    if (c) {
      var l = c.indexOf(u);
      l !== -1 && c.splice(l, 1);
    }
  }, a.EMPTY = function(u) {
    return u.closed = !0, u;
  }(new a()), a;
}();
function flattenUnsubscriptionErrors(a) {
  return a.reduce(function(u, c) {
    return u.concat(c instanceof UnsubscriptionError ? c.errors : c);
  }, []);
}
var rxSubscriber = /* @__PURE__ */ function() {
  return typeof Symbol == "function" ? /* @__PURE__ */ Symbol("rxSubscriber") : "@@rxSubscriber_" + /* @__PURE__ */ Math.random();
}(), Subscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this) || this;
    switch (p.syncErrorValue = null, p.syncErrorThrown = !1, p.syncErrorThrowable = !1, p.isStopped = !1, arguments.length) {
      case 0:
        p.destination = empty$3;
        break;
      case 1:
        if (!c) {
          p.destination = empty$3;
          break;
        }
        if (typeof c == "object") {
          c instanceof u ? (p.syncErrorThrowable = c.syncErrorThrowable, p.destination = c, c.add(p)) : (p.syncErrorThrowable = !0, p.destination = new SafeSubscriber(p, c));
          break;
        }
      default:
        p.syncErrorThrowable = !0, p.destination = new SafeSubscriber(p, c, l, v);
        break;
    }
    return p;
  }
  return u.prototype[rxSubscriber] = function() {
    return this;
  }, u.create = function(c, l, v) {
    var p = new u(c, l, v);
    return p.syncErrorThrowable = !1, p;
  }, u.prototype.next = function(c) {
    this.isStopped || this._next(c);
  }, u.prototype.error = function(c) {
    this.isStopped || (this.isStopped = !0, this._error(c));
  }, u.prototype.complete = function() {
    this.isStopped || (this.isStopped = !0, this._complete());
  }, u.prototype.unsubscribe = function() {
    this.closed || (this.isStopped = !0, a.prototype.unsubscribe.call(this));
  }, u.prototype._next = function(c) {
    this.destination.next(c);
  }, u.prototype._error = function(c) {
    this.destination.error(c), this.unsubscribe();
  }, u.prototype._complete = function() {
    this.destination.complete(), this.unsubscribe();
  }, u.prototype._unsubscribeAndRecycle = function() {
    var c = this._parentOrParents;
    return this._parentOrParents = null, this.unsubscribe(), this.closed = !1, this.isStopped = !1, this._parentOrParents = c, this;
  }, u;
}(Subscription), SafeSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v, p) {
    var _ = a.call(this) || this;
    _._parentSubscriber = c;
    var k, M = _;
    return isFunction$3(l) ? k = l : l && (k = l.next, v = l.error, p = l.complete, l !== empty$3 && (M = Object.create(l), isFunction$3(M.unsubscribe) && _.add(M.unsubscribe.bind(M)), M.unsubscribe = _.unsubscribe.bind(_))), _._context = M, _._next = k, _._error = v, _._complete = p, _;
  }
  return u.prototype.next = function(c) {
    if (!this.isStopped && this._next) {
      var l = this._parentSubscriber;
      !config$3.useDeprecatedSynchronousErrorHandling || !l.syncErrorThrowable ? this.__tryOrUnsub(this._next, c) : this.__tryOrSetError(l, this._next, c) && this.unsubscribe();
    }
  }, u.prototype.error = function(c) {
    if (!this.isStopped) {
      var l = this._parentSubscriber, v = config$3.useDeprecatedSynchronousErrorHandling;
      if (this._error)
        !v || !l.syncErrorThrowable ? (this.__tryOrUnsub(this._error, c), this.unsubscribe()) : (this.__tryOrSetError(l, this._error, c), this.unsubscribe());
      else if (l.syncErrorThrowable)
        v ? (l.syncErrorValue = c, l.syncErrorThrown = !0) : hostReportError(c), this.unsubscribe();
      else {
        if (this.unsubscribe(), v)
          throw c;
        hostReportError(c);
      }
    }
  }, u.prototype.complete = function() {
    var c = this;
    if (!this.isStopped) {
      var l = this._parentSubscriber;
      if (this._complete) {
        var v = function() {
          return c._complete.call(c._context);
        };
        !config$3.useDeprecatedSynchronousErrorHandling || !l.syncErrorThrowable ? (this.__tryOrUnsub(v), this.unsubscribe()) : (this.__tryOrSetError(l, v), this.unsubscribe());
      } else
        this.unsubscribe();
    }
  }, u.prototype.__tryOrUnsub = function(c, l) {
    try {
      c.call(this._context, l);
    } catch (v) {
      if (this.unsubscribe(), config$3.useDeprecatedSynchronousErrorHandling)
        throw v;
      hostReportError(v);
    }
  }, u.prototype.__tryOrSetError = function(c, l, v) {
    if (!config$3.useDeprecatedSynchronousErrorHandling)
      throw new Error("bad call");
    try {
      l.call(this._context, v);
    } catch (p) {
      return config$3.useDeprecatedSynchronousErrorHandling ? (c.syncErrorValue = p, c.syncErrorThrown = !0, !0) : (hostReportError(p), !0);
    }
    return !1;
  }, u.prototype._unsubscribe = function() {
    var c = this._parentSubscriber;
    this._context = null, this._parentSubscriber = null, c.unsubscribe();
  }, u;
}(Subscriber);
function canReportError(a) {
  for (; a; ) {
    var u = a, c = u.closed, l = u.destination, v = u.isStopped;
    if (c || v)
      return !1;
    l && l instanceof Subscriber ? a = l : a = null;
  }
  return !0;
}
function toSubscriber(a, u, c) {
  if (a) {
    if (a instanceof Subscriber)
      return a;
    if (a[rxSubscriber])
      return a[rxSubscriber]();
  }
  return !a && !u && !c ? new Subscriber(empty$3) : new Subscriber(a, u, c);
}
var observable = /* @__PURE__ */ function() {
  return typeof Symbol == "function" && Symbol.observable || "@@observable";
}();
function identity$1(a) {
  return a;
}
function pipe$2() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  return pipeFromArray(a);
}
function pipeFromArray(a) {
  return a.length === 0 ? identity$1 : a.length === 1 ? a[0] : function(c) {
    return a.reduce(function(l, v) {
      return v(l);
    }, c);
  };
}
var Observable = /* @__PURE__ */ function() {
  function a(u) {
    this._isScalar = !1, u && (this._subscribe = u);
  }
  return a.prototype.lift = function(u) {
    var c = new a();
    return c.source = this, c.operator = u, c;
  }, a.prototype.subscribe = function(u, c, l) {
    var v = this.operator, p = toSubscriber(u, c, l);
    if (v ? p.add(v.call(p, this.source)) : p.add(this.source || config$3.useDeprecatedSynchronousErrorHandling && !p.syncErrorThrowable ? this._subscribe(p) : this._trySubscribe(p)), config$3.useDeprecatedSynchronousErrorHandling && p.syncErrorThrowable && (p.syncErrorThrowable = !1, p.syncErrorThrown))
      throw p.syncErrorValue;
    return p;
  }, a.prototype._trySubscribe = function(u) {
    try {
      return this._subscribe(u);
    } catch (c) {
      config$3.useDeprecatedSynchronousErrorHandling && (u.syncErrorThrown = !0, u.syncErrorValue = c), canReportError(u) ? u.error(c) : console.warn(c);
    }
  }, a.prototype.forEach = function(u, c) {
    var l = this;
    return c = getPromiseCtor(c), new c(function(v, p) {
      var _;
      _ = l.subscribe(function(k) {
        try {
          u(k);
        } catch (M) {
          p(M), _ && _.unsubscribe();
        }
      }, p, v);
    });
  }, a.prototype._subscribe = function(u) {
    var c = this.source;
    return c && c.subscribe(u);
  }, a.prototype[observable] = function() {
    return this;
  }, a.prototype.pipe = function() {
    for (var u = [], c = 0; c < arguments.length; c++)
      u[c] = arguments[c];
    return u.length === 0 ? this : pipeFromArray(u)(this);
  }, a.prototype.toPromise = function(u) {
    var c = this;
    return u = getPromiseCtor(u), new u(function(l, v) {
      var p;
      c.subscribe(function(_) {
        return p = _;
      }, function(_) {
        return v(_);
      }, function() {
        return l(p);
      });
    });
  }, a.create = function(u) {
    return new a(u);
  }, a;
}();
function getPromiseCtor(a) {
  if (a || (a = Promise), !a)
    throw new Error("no Promise impl found");
  return a;
}
var subscribeToArray = function(a) {
  return function(u) {
    for (var c = 0, l = a.length; c < l && !u.closed; c++)
      u.next(a[c]);
    u.complete();
  };
}, subscribeToPromise = function(a) {
  return function(u) {
    return a.then(function(c) {
      u.closed || (u.next(c), u.complete());
    }, function(c) {
      return u.error(c);
    }).then(null, hostReportError), u;
  };
};
function getSymbolIterator() {
  return typeof Symbol != "function" || !Symbol.iterator ? "@@iterator" : Symbol.iterator;
}
var iterator = /* @__PURE__ */ getSymbolIterator(), subscribeToIterable = function(a) {
  return function(u) {
    var c = a[iterator]();
    do {
      var l = void 0;
      try {
        l = c.next();
      } catch (v) {
        return u.error(v), u;
      }
      if (l.done) {
        u.complete();
        break;
      }
      if (u.next(l.value), u.closed)
        break;
    } while (!0);
    return typeof c.return == "function" && u.add(function() {
      c.return && c.return();
    }), u;
  };
}, subscribeToObservable = function(a) {
  return function(u) {
    var c = a[observable]();
    if (typeof c.subscribe != "function")
      throw new TypeError("Provided object does not correctly implement Symbol.observable");
    return c.subscribe(u);
  };
}, isArrayLike$2 = function(a) {
  return a && typeof a.length == "number" && typeof a != "function";
};
function isPromise(a) {
  return !!a && typeof a.subscribe != "function" && typeof a.then == "function";
}
var subscribeTo = function(a) {
  if (a && typeof a[observable] == "function")
    return subscribeToObservable(a);
  if (isArrayLike$2(a))
    return subscribeToArray(a);
  if (isPromise(a))
    return subscribeToPromise(a);
  if (a && typeof a[iterator] == "function")
    return subscribeToIterable(a);
  var u = isObject$9(a) ? "an invalid object" : "'" + a + "'", c = "You provided " + u + " where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.";
  throw new TypeError(c);
}, SimpleInnerSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c) {
    var l = a.call(this) || this;
    return l.parent = c, l;
  }
  return u.prototype._next = function(c) {
    this.parent.notifyNext(c);
  }, u.prototype._error = function(c) {
    this.parent.notifyError(c), this.unsubscribe();
  }, u.prototype._complete = function() {
    this.parent.notifyComplete(), this.unsubscribe();
  }, u;
}(Subscriber), SimpleOuterSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u() {
    return a !== null && a.apply(this, arguments) || this;
  }
  return u.prototype.notifyNext = function(c) {
    this.destination.next(c);
  }, u.prototype.notifyError = function(c) {
    this.destination.error(c);
  }, u.prototype.notifyComplete = function() {
    this.destination.complete();
  }, u;
}(Subscriber);
function innerSubscribe(a, u) {
  if (!u.closed) {
    if (a instanceof Observable)
      return a.subscribe(u);
    var c;
    try {
      c = subscribeTo(a)(u);
    } catch (l) {
      u.error(l);
    }
    return c;
  }
}
function audit(a) {
  return function(c) {
    return c.lift(new AuditOperator(a));
  };
}
var AuditOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.durationSelector = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new AuditSubscriber(u, this.durationSelector));
  }, a;
}(), AuditSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.durationSelector = l, v.hasValue = !1, v;
  }
  return u.prototype._next = function(c) {
    if (this.value = c, this.hasValue = !0, !this.throttled) {
      var l = void 0;
      try {
        var v = this.durationSelector;
        l = v(c);
      } catch (_) {
        return this.destination.error(_);
      }
      var p = innerSubscribe(l, new SimpleInnerSubscriber(this));
      !p || p.closed ? this.clearThrottle() : this.add(this.throttled = p);
    }
  }, u.prototype.clearThrottle = function() {
    var c = this, l = c.value, v = c.hasValue, p = c.throttled;
    p && (this.remove(p), this.throttled = void 0, p.unsubscribe()), v && (this.value = void 0, this.hasValue = !1, this.destination.next(l));
  }, u.prototype.notifyNext = function() {
    this.clearThrottle();
  }, u.prototype.notifyComplete = function() {
    this.clearThrottle();
  }, u;
}(SimpleOuterSubscriber), Action = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    return a.call(this) || this;
  }
  return u.prototype.schedule = function(c, l) {
    return this;
  }, u;
}(Subscription), AsyncAction = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c, l) || this;
    return v.scheduler = c, v.work = l, v.pending = !1, v;
  }
  return u.prototype.schedule = function(c, l) {
    if (l === void 0 && (l = 0), this.closed)
      return this;
    this.state = c;
    var v = this.id, p = this.scheduler;
    return v != null && (this.id = this.recycleAsyncId(p, v, l)), this.pending = !0, this.delay = l, this.id = this.id || this.requestAsyncId(p, this.id, l), this;
  }, u.prototype.requestAsyncId = function(c, l, v) {
    return v === void 0 && (v = 0), setInterval(c.flush.bind(c, this), v);
  }, u.prototype.recycleAsyncId = function(c, l, v) {
    if (v === void 0 && (v = 0), v !== null && this.delay === v && this.pending === !1)
      return l;
    clearInterval(l);
  }, u.prototype.execute = function(c, l) {
    if (this.closed)
      return new Error("executing a cancelled action");
    this.pending = !1;
    var v = this._execute(c, l);
    if (v)
      return v;
    this.pending === !1 && this.id != null && (this.id = this.recycleAsyncId(this.scheduler, this.id, null));
  }, u.prototype._execute = function(c, l) {
    var v = !1, p = void 0;
    try {
      this.work(c);
    } catch (_) {
      v = !0, p = !!_ && _ || new Error(_);
    }
    if (v)
      return this.unsubscribe(), p;
  }, u.prototype._unsubscribe = function() {
    var c = this.id, l = this.scheduler, v = l.actions, p = v.indexOf(this);
    this.work = null, this.state = null, this.pending = !1, this.scheduler = null, p !== -1 && v.splice(p, 1), c != null && (this.id = this.recycleAsyncId(l, c, null)), this.delay = null;
  }, u;
}(Action), Scheduler = /* @__PURE__ */ function() {
  function a(u, c) {
    c === void 0 && (c = a.now), this.SchedulerAction = u, this.now = c;
  }
  return a.prototype.schedule = function(u, c, l) {
    return c === void 0 && (c = 0), new this.SchedulerAction(this, u).schedule(l, c);
  }, a.now = function() {
    return Date.now();
  }, a;
}(), AsyncScheduler = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    l === void 0 && (l = Scheduler.now);
    var v = a.call(this, c, function() {
      return u.delegate && u.delegate !== v ? u.delegate.now() : l();
    }) || this;
    return v.actions = [], v.active = !1, v.scheduled = void 0, v;
  }
  return u.prototype.schedule = function(c, l, v) {
    return l === void 0 && (l = 0), u.delegate && u.delegate !== this ? u.delegate.schedule(c, l, v) : a.prototype.schedule.call(this, c, l, v);
  }, u.prototype.flush = function(c) {
    var l = this.actions;
    if (this.active) {
      l.push(c);
      return;
    }
    var v;
    this.active = !0;
    do
      if (v = c.execute(c.state, c.delay))
        break;
    while (c = l.shift());
    if (this.active = !1, v) {
      for (; c = l.shift(); )
        c.unsubscribe();
      throw v;
    }
  }, u;
}(Scheduler), asyncScheduler = /* @__PURE__ */ new AsyncScheduler(AsyncAction), async$1 = asyncScheduler;
function isNumeric(a) {
  return !isArray$5(a) && a - parseFloat(a) + 1 >= 0;
}
function isScheduler(a) {
  return a && typeof a.schedule == "function";
}
function timer(a, u, c) {
  a === void 0 && (a = 0);
  var l = -1;
  return isNumeric(u) ? l = Number(u) < 1 && 1 || Number(u) : isScheduler(u) && (c = u), isScheduler(c) || (c = async$1), new Observable(function(v) {
    var p = isNumeric(a) ? a : +a - c.now();
    return c.schedule(dispatch$1, p, {
      index: 0,
      period: l,
      subscriber: v
    });
  });
}
function dispatch$1(a) {
  var u = a.index, c = a.period, l = a.subscriber;
  if (l.next(u), !l.closed) {
    if (c === -1)
      return l.complete();
    a.index = u + 1, this.schedule(a, c);
  }
}
function auditTime(a, u) {
  return u === void 0 && (u = async$1), audit(function() {
    return timer(a, u);
  });
}
function buffer$2(a) {
  return function(c) {
    return c.lift(new BufferOperator(a));
  };
}
var BufferOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.closingNotifier = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new BufferSubscriber(u, this.closingNotifier));
  }, a;
}(), BufferSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.buffer = [], v.add(innerSubscribe(l, new SimpleInnerSubscriber(v))), v;
  }
  return u.prototype._next = function(c) {
    this.buffer.push(c);
  }, u.prototype.notifyNext = function() {
    var c = this.buffer;
    this.buffer = [], this.destination.next(c);
  }, u;
}(SimpleOuterSubscriber);
function bufferCount(a, u) {
  return u === void 0 && (u = null), function(l) {
    return l.lift(new BufferCountOperator(a, u));
  };
}
var BufferCountOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.bufferSize = u, this.startBufferEvery = c, !c || u === c ? this.subscriberClass = BufferCountSubscriber : this.subscriberClass = BufferSkipCountSubscriber;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new this.subscriberClass(u, this.bufferSize, this.startBufferEvery));
  }, a;
}(), BufferCountSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.bufferSize = l, v.buffer = [], v;
  }
  return u.prototype._next = function(c) {
    var l = this.buffer;
    l.push(c), l.length == this.bufferSize && (this.destination.next(l), this.buffer = []);
  }, u.prototype._complete = function() {
    var c = this.buffer;
    c.length > 0 && this.destination.next(c), a.prototype._complete.call(this);
  }, u;
}(Subscriber), BufferSkipCountSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.bufferSize = l, p.startBufferEvery = v, p.buffers = [], p.count = 0, p;
  }
  return u.prototype._next = function(c) {
    var l = this, v = l.bufferSize, p = l.startBufferEvery, _ = l.buffers, k = l.count;
    this.count++, k % p === 0 && _.push([]);
    for (var M = _.length; M--; ) {
      var L = _[M];
      L.push(c), L.length === v && (_.splice(M, 1), this.destination.next(L));
    }
  }, u.prototype._complete = function() {
    for (var c = this, l = c.buffers, v = c.destination; l.length > 0; ) {
      var p = l.shift();
      p.length > 0 && v.next(p);
    }
    a.prototype._complete.call(this);
  }, u;
}(Subscriber);
function bufferTime(a) {
  var u = arguments.length, c = async$1;
  isScheduler(arguments[arguments.length - 1]) && (c = arguments[arguments.length - 1], u--);
  var l = null;
  u >= 2 && (l = arguments[1]);
  var v = Number.POSITIVE_INFINITY;
  return u >= 3 && (v = arguments[2]), function(_) {
    return _.lift(new BufferTimeOperator(a, l, v, c));
  };
}
var BufferTimeOperator = /* @__PURE__ */ function() {
  function a(u, c, l, v) {
    this.bufferTimeSpan = u, this.bufferCreationInterval = c, this.maxBufferSize = l, this.scheduler = v;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new BufferTimeSubscriber(u, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));
  }, a;
}(), Context = /* @__PURE__ */ function() {
  function a() {
    this.buffer = [];
  }
  return a;
}(), BufferTimeSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v, p, _) {
    var k = a.call(this, c) || this;
    k.bufferTimeSpan = l, k.bufferCreationInterval = v, k.maxBufferSize = p, k.scheduler = _, k.contexts = [];
    var M = k.openContext();
    if (k.timespanOnly = v == null || v < 0, k.timespanOnly) {
      var L = { subscriber: k, context: M, bufferTimeSpan: l };
      k.add(M.closeAction = _.schedule(dispatchBufferTimeSpanOnly, l, L));
    } else {
      var F = { subscriber: k, context: M }, V = { bufferTimeSpan: l, bufferCreationInterval: v, subscriber: k, scheduler: _ };
      k.add(M.closeAction = _.schedule(dispatchBufferClose, l, F)), k.add(_.schedule(dispatchBufferCreation, v, V));
    }
    return k;
  }
  return u.prototype._next = function(c) {
    for (var l = this.contexts, v = l.length, p, _ = 0; _ < v; _++) {
      var k = l[_], M = k.buffer;
      M.push(c), M.length == this.maxBufferSize && (p = k);
    }
    p && this.onBufferFull(p);
  }, u.prototype._error = function(c) {
    this.contexts.length = 0, a.prototype._error.call(this, c);
  }, u.prototype._complete = function() {
    for (var c = this, l = c.contexts, v = c.destination; l.length > 0; ) {
      var p = l.shift();
      v.next(p.buffer);
    }
    a.prototype._complete.call(this);
  }, u.prototype._unsubscribe = function() {
    this.contexts = null;
  }, u.prototype.onBufferFull = function(c) {
    this.closeContext(c);
    var l = c.closeAction;
    if (l.unsubscribe(), this.remove(l), !this.closed && this.timespanOnly) {
      c = this.openContext();
      var v = this.bufferTimeSpan, p = { subscriber: this, context: c, bufferTimeSpan: v };
      this.add(c.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, v, p));
    }
  }, u.prototype.openContext = function() {
    var c = new Context();
    return this.contexts.push(c), c;
  }, u.prototype.closeContext = function(c) {
    this.destination.next(c.buffer);
    var l = this.contexts, v = l ? l.indexOf(c) : -1;
    v >= 0 && l.splice(l.indexOf(c), 1);
  }, u;
}(Subscriber);
function dispatchBufferTimeSpanOnly(a) {
  var u = a.subscriber, c = a.context;
  c && u.closeContext(c), u.closed || (a.context = u.openContext(), a.context.closeAction = this.schedule(a, a.bufferTimeSpan));
}
function dispatchBufferCreation(a) {
  var u = a.bufferCreationInterval, c = a.bufferTimeSpan, l = a.subscriber, v = a.scheduler, p = l.openContext(), _ = this;
  l.closed || (l.add(p.closeAction = v.schedule(dispatchBufferClose, c, { subscriber: l, context: p })), _.schedule(a, u));
}
function dispatchBufferClose(a) {
  var u = a.subscriber, c = a.context;
  u.closeContext(c);
}
var InnerSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this) || this;
    return p.parent = c, p.outerValue = l, p.outerIndex = v, p.index = 0, p;
  }
  return u.prototype._next = function(c) {
    this.parent.notifyNext(this.outerValue, c, this.outerIndex, this.index++, this);
  }, u.prototype._error = function(c) {
    this.parent.notifyError(c, this), this.unsubscribe();
  }, u.prototype._complete = function() {
    this.parent.notifyComplete(this), this.unsubscribe();
  }, u;
}(Subscriber);
function subscribeToResult(a, u, c, l, v) {
  if (v === void 0 && (v = new InnerSubscriber(a, c, l)), !v.closed)
    return u instanceof Observable ? u.subscribe(v) : subscribeTo(u)(v);
}
var OuterSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u() {
    return a !== null && a.apply(this, arguments) || this;
  }
  return u.prototype.notifyNext = function(c, l, v, p, _) {
    this.destination.next(l);
  }, u.prototype.notifyError = function(c, l) {
    this.destination.error(c);
  }, u.prototype.notifyComplete = function(c) {
    this.destination.complete();
  }, u;
}(Subscriber);
function bufferToggle(a, u) {
  return function(l) {
    return l.lift(new BufferToggleOperator(a, u));
  };
}
var BufferToggleOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.openings = u, this.closingSelector = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new BufferToggleSubscriber(u, this.openings, this.closingSelector));
  }, a;
}(), BufferToggleSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.closingSelector = v, p.contexts = [], p.add(subscribeToResult(p, l)), p;
  }
  return u.prototype._next = function(c) {
    for (var l = this.contexts, v = l.length, p = 0; p < v; p++)
      l[p].buffer.push(c);
  }, u.prototype._error = function(c) {
    for (var l = this.contexts; l.length > 0; ) {
      var v = l.shift();
      v.subscription.unsubscribe(), v.buffer = null, v.subscription = null;
    }
    this.contexts = null, a.prototype._error.call(this, c);
  }, u.prototype._complete = function() {
    for (var c = this.contexts; c.length > 0; ) {
      var l = c.shift();
      this.destination.next(l.buffer), l.subscription.unsubscribe(), l.buffer = null, l.subscription = null;
    }
    this.contexts = null, a.prototype._complete.call(this);
  }, u.prototype.notifyNext = function(c, l) {
    c ? this.closeBuffer(c) : this.openBuffer(l);
  }, u.prototype.notifyComplete = function(c) {
    this.closeBuffer(c.context);
  }, u.prototype.openBuffer = function(c) {
    try {
      var l = this.closingSelector, v = l.call(this, c);
      v && this.trySubscribe(v);
    } catch (p) {
      this._error(p);
    }
  }, u.prototype.closeBuffer = function(c) {
    var l = this.contexts;
    if (l && c) {
      var v = c.buffer, p = c.subscription;
      this.destination.next(v), l.splice(l.indexOf(c), 1), this.remove(p), p.unsubscribe();
    }
  }, u.prototype.trySubscribe = function(c) {
    var l = this.contexts, v = [], p = new Subscription(), _ = { buffer: v, subscription: p };
    l.push(_);
    var k = subscribeToResult(this, c, _);
    !k || k.closed ? this.closeBuffer(_) : (k.context = _, this.add(k), p.add(k));
  }, u;
}(OuterSubscriber);
function bufferWhen(a) {
  return function(u) {
    return u.lift(new BufferWhenOperator(a));
  };
}
var BufferWhenOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.closingSelector = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new BufferWhenSubscriber(u, this.closingSelector));
  }, a;
}(), BufferWhenSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.closingSelector = l, v.subscribing = !1, v.openBuffer(), v;
  }
  return u.prototype._next = function(c) {
    this.buffer.push(c);
  }, u.prototype._complete = function() {
    var c = this.buffer;
    c && this.destination.next(c), a.prototype._complete.call(this);
  }, u.prototype._unsubscribe = function() {
    this.buffer = void 0, this.subscribing = !1;
  }, u.prototype.notifyNext = function() {
    this.openBuffer();
  }, u.prototype.notifyComplete = function() {
    this.subscribing ? this.complete() : this.openBuffer();
  }, u.prototype.openBuffer = function() {
    var c = this.closingSubscription;
    c && (this.remove(c), c.unsubscribe());
    var l = this.buffer;
    this.buffer && this.destination.next(l), this.buffer = [];
    var v;
    try {
      var p = this.closingSelector;
      v = p();
    } catch (_) {
      return this.error(_);
    }
    c = new Subscription(), this.closingSubscription = c, this.add(c), this.subscribing = !0, c.add(innerSubscribe(v, new SimpleInnerSubscriber(this))), this.subscribing = !1;
  }, u;
}(SimpleOuterSubscriber);
function catchError(a) {
  return function(c) {
    var l = new CatchOperator(a), v = c.lift(l);
    return l.caught = v;
  };
}
var CatchOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.selector = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new CatchSubscriber(u, this.selector, this.caught));
  }, a;
}(), CatchSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.selector = l, p.caught = v, p;
  }
  return u.prototype.error = function(c) {
    if (!this.isStopped) {
      var l = void 0;
      try {
        l = this.selector(c, this.caught);
      } catch (_) {
        a.prototype.error.call(this, _);
        return;
      }
      this._unsubscribeAndRecycle();
      var v = new SimpleInnerSubscriber(this);
      this.add(v);
      var p = innerSubscribe(l, v);
      p !== v && this.add(p);
    }
  }, u;
}(SimpleOuterSubscriber);
function scheduleArray(a, u) {
  return new Observable(function(c) {
    var l = new Subscription(), v = 0;
    return l.add(u.schedule(function() {
      if (v === a.length) {
        c.complete();
        return;
      }
      c.next(a[v++]), c.closed || l.add(this.schedule());
    })), l;
  });
}
function fromArray$1(a, u) {
  return u ? scheduleArray(a, u) : new Observable(subscribeToArray(a));
}
var NONE = {}, CombineLatestOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.resultSelector = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new CombineLatestSubscriber(u, this.resultSelector));
  }, a;
}(), CombineLatestSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.resultSelector = l, v.active = 0, v.values = [], v.observables = [], v;
  }
  return u.prototype._next = function(c) {
    this.values.push(NONE), this.observables.push(c);
  }, u.prototype._complete = function() {
    var c = this.observables, l = c.length;
    if (l === 0)
      this.destination.complete();
    else {
      this.active = l, this.toRespond = l;
      for (var v = 0; v < l; v++) {
        var p = c[v];
        this.add(subscribeToResult(this, p, void 0, v));
      }
    }
  }, u.prototype.notifyComplete = function(c) {
    (this.active -= 1) === 0 && this.destination.complete();
  }, u.prototype.notifyNext = function(c, l, v) {
    var p = this.values, _ = p[v], k = this.toRespond ? _ === NONE ? --this.toRespond : this.toRespond : 0;
    p[v] = l, k === 0 && (this.resultSelector ? this._tryResultSelector(p) : this.destination.next(p.slice()));
  }, u.prototype._tryResultSelector = function(c) {
    var l;
    try {
      l = this.resultSelector.apply(this, c);
    } catch (v) {
      this.destination.error(v);
      return;
    }
    this.destination.next(l);
  }, u;
}(OuterSubscriber);
function combineAll(a) {
  return function(u) {
    return u.lift(new CombineLatestOperator(a));
  };
}
function scheduleObservable(a, u) {
  return new Observable(function(c) {
    var l = new Subscription();
    return l.add(u.schedule(function() {
      var v = a[observable]();
      l.add(v.subscribe({
        next: function(p) {
          l.add(u.schedule(function() {
            return c.next(p);
          }));
        },
        error: function(p) {
          l.add(u.schedule(function() {
            return c.error(p);
          }));
        },
        complete: function() {
          l.add(u.schedule(function() {
            return c.complete();
          }));
        }
      }));
    })), l;
  });
}
function schedulePromise(a, u) {
  return new Observable(function(c) {
    var l = new Subscription();
    return l.add(u.schedule(function() {
      return a.then(function(v) {
        l.add(u.schedule(function() {
          c.next(v), l.add(u.schedule(function() {
            return c.complete();
          }));
        }));
      }, function(v) {
        l.add(u.schedule(function() {
          return c.error(v);
        }));
      });
    })), l;
  });
}
function scheduleIterable(a, u) {
  if (!a)
    throw new Error("Iterable cannot be null");
  return new Observable(function(c) {
    var l = new Subscription(), v;
    return l.add(function() {
      v && typeof v.return == "function" && v.return();
    }), l.add(u.schedule(function() {
      v = a[iterator](), l.add(u.schedule(function() {
        if (!c.closed) {
          var p, _;
          try {
            var k = v.next();
            p = k.value, _ = k.done;
          } catch (M) {
            c.error(M);
            return;
          }
          _ ? c.complete() : (c.next(p), this.schedule());
        }
      }));
    })), l;
  });
}
function isInteropObservable(a) {
  return a && typeof a[observable] == "function";
}
function isIterable(a) {
  return a && typeof a[iterator] == "function";
}
function scheduled(a, u) {
  if (a != null) {
    if (isInteropObservable(a))
      return scheduleObservable(a, u);
    if (isPromise(a))
      return schedulePromise(a, u);
    if (isArrayLike$2(a))
      return scheduleArray(a, u);
    if (isIterable(a) || typeof a == "string")
      return scheduleIterable(a, u);
  }
  throw new TypeError((a !== null && typeof a || a) + " is not observable");
}
function from(a, u) {
  return u ? scheduled(a, u) : a instanceof Observable ? a : new Observable(subscribeTo(a));
}
function combineLatest() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  var c = null;
  return typeof a[a.length - 1] == "function" && (c = a.pop()), a.length === 1 && isArray$5(a[0]) && (a = a[0].slice()), function(l) {
    return l.lift.call(from([l].concat(a)), new CombineLatestOperator(c));
  };
}
function of$1() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  var c = a[a.length - 1];
  return isScheduler(c) ? (a.pop(), scheduleArray(a, c)) : fromArray$1(a);
}
function map(a, u) {
  return function(l) {
    if (typeof a != "function")
      throw new TypeError("argument is not a function. Are you looking for `mapTo()`?");
    return l.lift(new MapOperator(a, u));
  };
}
var MapOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.project = u, this.thisArg = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new MapSubscriber(u, this.project, this.thisArg));
  }, a;
}(), MapSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.project = l, p.count = 0, p.thisArg = v || p, p;
  }
  return u.prototype._next = function(c) {
    var l;
    try {
      l = this.project.call(this.thisArg, c, this.count++);
    } catch (v) {
      this.destination.error(v);
      return;
    }
    this.destination.next(l);
  }, u;
}(Subscriber);
function mergeMap(a, u, c) {
  return c === void 0 && (c = Number.POSITIVE_INFINITY), typeof u == "function" ? function(l) {
    return l.pipe(mergeMap(function(v, p) {
      return from(a(v, p)).pipe(map(function(_, k) {
        return u(v, _, p, k);
      }));
    }, c));
  } : (typeof u == "number" && (c = u), function(l) {
    return l.lift(new MergeMapOperator(a, c));
  });
}
var MergeMapOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    c === void 0 && (c = Number.POSITIVE_INFINITY), this.project = u, this.concurrent = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new MergeMapSubscriber(u, this.project, this.concurrent));
  }, a;
}(), MergeMapSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    v === void 0 && (v = Number.POSITIVE_INFINITY);
    var p = a.call(this, c) || this;
    return p.project = l, p.concurrent = v, p.hasCompleted = !1, p.buffer = [], p.active = 0, p.index = 0, p;
  }
  return u.prototype._next = function(c) {
    this.active < this.concurrent ? this._tryNext(c) : this.buffer.push(c);
  }, u.prototype._tryNext = function(c) {
    var l, v = this.index++;
    try {
      l = this.project(c, v);
    } catch (p) {
      this.destination.error(p);
      return;
    }
    this.active++, this._innerSub(l);
  }, u.prototype._innerSub = function(c) {
    var l = new SimpleInnerSubscriber(this), v = this.destination;
    v.add(l);
    var p = innerSubscribe(c, l);
    p !== l && v.add(p);
  }, u.prototype._complete = function() {
    this.hasCompleted = !0, this.active === 0 && this.buffer.length === 0 && this.destination.complete(), this.unsubscribe();
  }, u.prototype.notifyNext = function(c) {
    this.destination.next(c);
  }, u.prototype.notifyComplete = function() {
    var c = this.buffer;
    this.active--, c.length > 0 ? this._next(c.shift()) : this.active === 0 && this.hasCompleted && this.destination.complete();
  }, u;
}(SimpleOuterSubscriber), flatMap = mergeMap;
function mergeAll(a) {
  return a === void 0 && (a = Number.POSITIVE_INFINITY), mergeMap(identity$1, a);
}
function concatAll() {
  return mergeAll(1);
}
function concat$1() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  return concatAll()(of$1.apply(void 0, a));
}
function concat() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  return function(c) {
    return c.lift.call(concat$1.apply(void 0, [c].concat(a)));
  };
}
function concatMap(a, u) {
  return mergeMap(a, u, 1);
}
function concatMapTo(a, u) {
  return concatMap(function() {
    return a;
  }, u);
}
function count(a) {
  return function(u) {
    return u.lift(new CountOperator(a, u));
  };
}
var CountOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.predicate = u, this.source = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new CountSubscriber(u, this.predicate, this.source));
  }, a;
}(), CountSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.predicate = l, p.source = v, p.count = 0, p.index = 0, p;
  }
  return u.prototype._next = function(c) {
    this.predicate ? this._tryPredicate(c) : this.count++;
  }, u.prototype._tryPredicate = function(c) {
    var l;
    try {
      l = this.predicate(c, this.index++, this.source);
    } catch (v) {
      this.destination.error(v);
      return;
    }
    l && this.count++;
  }, u.prototype._complete = function() {
    this.destination.next(this.count), this.destination.complete();
  }, u;
}(Subscriber);
function debounce$1(a) {
  return function(u) {
    return u.lift(new DebounceOperator(a));
  };
}
var DebounceOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.durationSelector = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new DebounceSubscriber(u, this.durationSelector));
  }, a;
}(), DebounceSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.durationSelector = l, v.hasValue = !1, v;
  }
  return u.prototype._next = function(c) {
    try {
      var l = this.durationSelector.call(this, c);
      l && this._tryNext(c, l);
    } catch (v) {
      this.destination.error(v);
    }
  }, u.prototype._complete = function() {
    this.emitValue(), this.destination.complete();
  }, u.prototype._tryNext = function(c, l) {
    var v = this.durationSubscription;
    this.value = c, this.hasValue = !0, v && (v.unsubscribe(), this.remove(v)), v = innerSubscribe(l, new SimpleInnerSubscriber(this)), v && !v.closed && this.add(this.durationSubscription = v);
  }, u.prototype.notifyNext = function() {
    this.emitValue();
  }, u.prototype.notifyComplete = function() {
    this.emitValue();
  }, u.prototype.emitValue = function() {
    if (this.hasValue) {
      var c = this.value, l = this.durationSubscription;
      l && (this.durationSubscription = void 0, l.unsubscribe(), this.remove(l)), this.value = void 0, this.hasValue = !1, a.prototype._next.call(this, c);
    }
  }, u;
}(SimpleOuterSubscriber);
function debounceTime(a, u) {
  return u === void 0 && (u = async$1), function(c) {
    return c.lift(new DebounceTimeOperator(a, u));
  };
}
var DebounceTimeOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.dueTime = u, this.scheduler = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new DebounceTimeSubscriber(u, this.dueTime, this.scheduler));
  }, a;
}(), DebounceTimeSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.dueTime = l, p.scheduler = v, p.debouncedSubscription = null, p.lastValue = null, p.hasValue = !1, p;
  }
  return u.prototype._next = function(c) {
    this.clearDebounce(), this.lastValue = c, this.hasValue = !0, this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext$1, this.dueTime, this));
  }, u.prototype._complete = function() {
    this.debouncedNext(), this.destination.complete();
  }, u.prototype.debouncedNext = function() {
    if (this.clearDebounce(), this.hasValue) {
      var c = this.lastValue;
      this.lastValue = null, this.hasValue = !1, this.destination.next(c);
    }
  }, u.prototype.clearDebounce = function() {
    var c = this.debouncedSubscription;
    c !== null && (this.remove(c), c.unsubscribe(), this.debouncedSubscription = null);
  }, u;
}(Subscriber);
function dispatchNext$1(a) {
  a.debouncedNext();
}
function defaultIfEmpty(a) {
  return a === void 0 && (a = null), function(u) {
    return u.lift(new DefaultIfEmptyOperator(a));
  };
}
var DefaultIfEmptyOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.defaultValue = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new DefaultIfEmptySubscriber(u, this.defaultValue));
  }, a;
}(), DefaultIfEmptySubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.defaultValue = l, v.isEmpty = !0, v;
  }
  return u.prototype._next = function(c) {
    this.isEmpty = !1, this.destination.next(c);
  }, u.prototype._complete = function() {
    this.isEmpty && this.destination.next(this.defaultValue), this.destination.complete();
  }, u;
}(Subscriber);
function isDate$1(a) {
  return a instanceof Date && !isNaN(+a);
}
var EMPTY = /* @__PURE__ */ new Observable(function(a) {
  return a.complete();
});
function empty$2(a) {
  return a ? emptyScheduled(a) : EMPTY;
}
function emptyScheduled(a) {
  return new Observable(function(u) {
    return a.schedule(function() {
      return u.complete();
    });
  });
}
function throwError(a, u) {
  return u ? new Observable(function(c) {
    return u.schedule(dispatch, 0, { error: a, subscriber: c });
  }) : new Observable(function(c) {
    return c.error(a);
  });
}
function dispatch(a) {
  var u = a.error, c = a.subscriber;
  c.error(u);
}
var Notification = /* @__PURE__ */ function() {
  function a(u, c, l) {
    this.kind = u, this.value = c, this.error = l, this.hasValue = u === "N";
  }
  return a.prototype.observe = function(u) {
    switch (this.kind) {
      case "N":
        return u.next && u.next(this.value);
      case "E":
        return u.error && u.error(this.error);
      case "C":
        return u.complete && u.complete();
    }
  }, a.prototype.do = function(u, c, l) {
    var v = this.kind;
    switch (v) {
      case "N":
        return u && u(this.value);
      case "E":
        return c && c(this.error);
      case "C":
        return l && l();
    }
  }, a.prototype.accept = function(u, c, l) {
    return u && typeof u.next == "function" ? this.observe(u) : this.do(u, c, l);
  }, a.prototype.toObservable = function() {
    var u = this.kind;
    switch (u) {
      case "N":
        return of$1(this.value);
      case "E":
        return throwError(this.error);
      case "C":
        return empty$2();
    }
    throw new Error("unexpected notification kind value");
  }, a.createNext = function(u) {
    return typeof u < "u" ? new a("N", u) : a.undefinedValueNotification;
  }, a.createError = function(u) {
    return new a("E", void 0, u);
  }, a.createComplete = function() {
    return a.completeNotification;
  }, a.completeNotification = new a("C"), a.undefinedValueNotification = new a("N", void 0), a;
}();
function delay(a, u) {
  u === void 0 && (u = async$1);
  var c = isDate$1(a), l = c ? +a - u.now() : Math.abs(a);
  return function(v) {
    return v.lift(new DelayOperator(l, u));
  };
}
var DelayOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.delay = u, this.scheduler = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new DelaySubscriber(u, this.delay, this.scheduler));
  }, a;
}(), DelaySubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.delay = l, p.scheduler = v, p.queue = [], p.active = !1, p.errored = !1, p;
  }
  return u.dispatch = function(c) {
    for (var l = c.source, v = l.queue, p = c.scheduler, _ = c.destination; v.length > 0 && v[0].time - p.now() <= 0; )
      v.shift().notification.observe(_);
    if (v.length > 0) {
      var k = Math.max(0, v[0].time - p.now());
      this.schedule(c, k);
    } else
      this.unsubscribe(), l.active = !1;
  }, u.prototype._schedule = function(c) {
    this.active = !0;
    var l = this.destination;
    l.add(c.schedule(u.dispatch, this.delay, {
      source: this,
      destination: this.destination,
      scheduler: c
    }));
  }, u.prototype.scheduleNotification = function(c) {
    if (this.errored !== !0) {
      var l = this.scheduler, v = new DelayMessage(l.now() + this.delay, c);
      this.queue.push(v), this.active === !1 && this._schedule(l);
    }
  }, u.prototype._next = function(c) {
    this.scheduleNotification(Notification.createNext(c));
  }, u.prototype._error = function(c) {
    this.errored = !0, this.queue = [], this.destination.error(c), this.unsubscribe();
  }, u.prototype._complete = function() {
    this.scheduleNotification(Notification.createComplete()), this.unsubscribe();
  }, u;
}(Subscriber), DelayMessage = /* @__PURE__ */ function() {
  function a(u, c) {
    this.time = u, this.notification = c;
  }
  return a;
}();
function delayWhen(a, u) {
  return u ? function(c) {
    return new SubscriptionDelayObservable(c, u).lift(new DelayWhenOperator(a));
  } : function(c) {
    return c.lift(new DelayWhenOperator(a));
  };
}
var DelayWhenOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.delayDurationSelector = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new DelayWhenSubscriber(u, this.delayDurationSelector));
  }, a;
}(), DelayWhenSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.delayDurationSelector = l, v.completed = !1, v.delayNotifierSubscriptions = [], v.index = 0, v;
  }
  return u.prototype.notifyNext = function(c, l, v, p, _) {
    this.destination.next(c), this.removeSubscription(_), this.tryComplete();
  }, u.prototype.notifyError = function(c, l) {
    this._error(c);
  }, u.prototype.notifyComplete = function(c) {
    var l = this.removeSubscription(c);
    l && this.destination.next(l), this.tryComplete();
  }, u.prototype._next = function(c) {
    var l = this.index++;
    try {
      var v = this.delayDurationSelector(c, l);
      v && this.tryDelay(v, c);
    } catch (p) {
      this.destination.error(p);
    }
  }, u.prototype._complete = function() {
    this.completed = !0, this.tryComplete(), this.unsubscribe();
  }, u.prototype.removeSubscription = function(c) {
    c.unsubscribe();
    var l = this.delayNotifierSubscriptions.indexOf(c);
    return l !== -1 && this.delayNotifierSubscriptions.splice(l, 1), c.outerValue;
  }, u.prototype.tryDelay = function(c, l) {
    var v = subscribeToResult(this, c, l);
    if (v && !v.closed) {
      var p = this.destination;
      p.add(v), this.delayNotifierSubscriptions.push(v);
    }
  }, u.prototype.tryComplete = function() {
    this.completed && this.delayNotifierSubscriptions.length === 0 && this.destination.complete();
  }, u;
}(OuterSubscriber), SubscriptionDelayObservable = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this) || this;
    return v.source = c, v.subscriptionDelay = l, v;
  }
  return u.prototype._subscribe = function(c) {
    this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(c, this.source));
  }, u;
}(Observable), SubscriptionDelaySubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this) || this;
    return v.parent = c, v.source = l, v.sourceSubscribed = !1, v;
  }
  return u.prototype._next = function(c) {
    this.subscribeToSource();
  }, u.prototype._error = function(c) {
    this.unsubscribe(), this.parent.error(c);
  }, u.prototype._complete = function() {
    this.unsubscribe(), this.subscribeToSource();
  }, u.prototype.subscribeToSource = function() {
    this.sourceSubscribed || (this.sourceSubscribed = !0, this.unsubscribe(), this.source.subscribe(this.parent));
  }, u;
}(Subscriber);
function dematerialize() {
  return function(u) {
    return u.lift(new DeMaterializeOperator());
  };
}
var DeMaterializeOperator = /* @__PURE__ */ function() {
  function a() {
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new DeMaterializeSubscriber(u));
  }, a;
}(), DeMaterializeSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c) {
    return a.call(this, c) || this;
  }
  return u.prototype._next = function(c) {
    c.observe(this.destination);
  }, u;
}(Subscriber);
function distinct(a, u) {
  return function(c) {
    return c.lift(new DistinctOperator(a, u));
  };
}
var DistinctOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.keySelector = u, this.flushes = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new DistinctSubscriber(u, this.keySelector, this.flushes));
  }, a;
}(), DistinctSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.keySelector = l, p.values = /* @__PURE__ */ new Set(), v && p.add(innerSubscribe(v, new SimpleInnerSubscriber(p))), p;
  }
  return u.prototype.notifyNext = function() {
    this.values.clear();
  }, u.prototype.notifyError = function(c) {
    this._error(c);
  }, u.prototype._next = function(c) {
    this.keySelector ? this._useKeySelector(c) : this._finalizeNext(c, c);
  }, u.prototype._useKeySelector = function(c) {
    var l, v = this.destination;
    try {
      l = this.keySelector(c);
    } catch (p) {
      v.error(p);
      return;
    }
    this._finalizeNext(l, c);
  }, u.prototype._finalizeNext = function(c, l) {
    var v = this.values;
    v.has(c) || (v.add(c), this.destination.next(l));
  }, u;
}(SimpleOuterSubscriber);
function distinctUntilChanged(a, u) {
  return function(c) {
    return c.lift(new DistinctUntilChangedOperator(a, u));
  };
}
var DistinctUntilChangedOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.compare = u, this.keySelector = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new DistinctUntilChangedSubscriber(u, this.compare, this.keySelector));
  }, a;
}(), DistinctUntilChangedSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.keySelector = v, p.hasKey = !1, typeof l == "function" && (p.compare = l), p;
  }
  return u.prototype.compare = function(c, l) {
    return c === l;
  }, u.prototype._next = function(c) {
    var l;
    try {
      var v = this.keySelector;
      l = v ? v(c) : c;
    } catch (k) {
      return this.destination.error(k);
    }
    var p = !1;
    if (this.hasKey)
      try {
        var _ = this.compare;
        p = _(this.key, l);
      } catch (k) {
        return this.destination.error(k);
      }
    else
      this.hasKey = !0;
    p || (this.key = l, this.destination.next(c));
  }, u;
}(Subscriber);
function distinctUntilKeyChanged(a, u) {
  return distinctUntilChanged(function(c, l) {
    return u ? u(c[a], l[a]) : c[a] === l[a];
  });
}
var ArgumentOutOfRangeErrorImpl = /* @__PURE__ */ function() {
  function a() {
    return Error.call(this), this.message = "argument out of range", this.name = "ArgumentOutOfRangeError", this;
  }
  return a.prototype = /* @__PURE__ */ Object.create(Error.prototype), a;
}(), ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl;
function filter(a, u) {
  return function(l) {
    return l.lift(new FilterOperator(a, u));
  };
}
var FilterOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.predicate = u, this.thisArg = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new FilterSubscriber(u, this.predicate, this.thisArg));
  }, a;
}(), FilterSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.predicate = l, p.thisArg = v, p.count = 0, p;
  }
  return u.prototype._next = function(c) {
    var l;
    try {
      l = this.predicate.call(this.thisArg, c, this.count++);
    } catch (v) {
      this.destination.error(v);
      return;
    }
    l && this.destination.next(c);
  }, u;
}(Subscriber), EmptyErrorImpl = /* @__PURE__ */ function() {
  function a() {
    return Error.call(this), this.message = "no elements in sequence", this.name = "EmptyError", this;
  }
  return a.prototype = /* @__PURE__ */ Object.create(Error.prototype), a;
}(), EmptyError = EmptyErrorImpl;
function throwIfEmpty(a) {
  return a === void 0 && (a = defaultErrorFactory), function(u) {
    return u.lift(new ThrowIfEmptyOperator(a));
  };
}
var ThrowIfEmptyOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.errorFactory = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new ThrowIfEmptySubscriber(u, this.errorFactory));
  }, a;
}(), ThrowIfEmptySubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.errorFactory = l, v.hasValue = !1, v;
  }
  return u.prototype._next = function(c) {
    this.hasValue = !0, this.destination.next(c);
  }, u.prototype._complete = function() {
    if (this.hasValue)
      return this.destination.complete();
    var c = void 0;
    try {
      c = this.errorFactory();
    } catch (l) {
      c = l;
    }
    this.destination.error(c);
  }, u;
}(Subscriber);
function defaultErrorFactory() {
  return new EmptyError();
}
function take(a) {
  return function(u) {
    return a === 0 ? empty$2() : u.lift(new TakeOperator(a));
  };
}
var TakeOperator = /* @__PURE__ */ function() {
  function a(u) {
    if (this.total = u, this.total < 0)
      throw new ArgumentOutOfRangeError();
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new TakeSubscriber(u, this.total));
  }, a;
}(), TakeSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.total = l, v.count = 0, v;
  }
  return u.prototype._next = function(c) {
    var l = this.total, v = ++this.count;
    v <= l && (this.destination.next(c), v === l && (this.destination.complete(), this.unsubscribe()));
  }, u;
}(Subscriber);
function elementAt(a, u) {
  if (a < 0)
    throw new ArgumentOutOfRangeError();
  var c = arguments.length >= 2;
  return function(l) {
    return l.pipe(filter(function(v, p) {
      return p === a;
    }), take(1), c ? defaultIfEmpty(u) : throwIfEmpty(function() {
      return new ArgumentOutOfRangeError();
    }));
  };
}
function endWith() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  return function(c) {
    return concat$1(c, of$1.apply(void 0, a));
  };
}
function every$1(a, u) {
  return function(c) {
    return c.lift(new EveryOperator(a, u, c));
  };
}
var EveryOperator = /* @__PURE__ */ function() {
  function a(u, c, l) {
    this.predicate = u, this.thisArg = c, this.source = l;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new EverySubscriber(u, this.predicate, this.thisArg, this.source));
  }, a;
}(), EverySubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v, p) {
    var _ = a.call(this, c) || this;
    return _.predicate = l, _.thisArg = v, _.source = p, _.index = 0, _.thisArg = v || _, _;
  }
  return u.prototype.notifyComplete = function(c) {
    this.destination.next(c), this.destination.complete();
  }, u.prototype._next = function(c) {
    var l = !1;
    try {
      l = this.predicate.call(this.thisArg, c, this.index++, this.source);
    } catch (v) {
      this.destination.error(v);
      return;
    }
    l || this.notifyComplete(!1);
  }, u.prototype._complete = function() {
    this.notifyComplete(!0);
  }, u;
}(Subscriber);
function exhaust() {
  return function(a) {
    return a.lift(new SwitchFirstOperator());
  };
}
var SwitchFirstOperator = /* @__PURE__ */ function() {
  function a() {
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new SwitchFirstSubscriber(u));
  }, a;
}(), SwitchFirstSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c) {
    var l = a.call(this, c) || this;
    return l.hasCompleted = !1, l.hasSubscription = !1, l;
  }
  return u.prototype._next = function(c) {
    this.hasSubscription || (this.hasSubscription = !0, this.add(innerSubscribe(c, new SimpleInnerSubscriber(this))));
  }, u.prototype._complete = function() {
    this.hasCompleted = !0, this.hasSubscription || this.destination.complete();
  }, u.prototype.notifyComplete = function() {
    this.hasSubscription = !1, this.hasCompleted && this.destination.complete();
  }, u;
}(SimpleOuterSubscriber);
function exhaustMap(a, u) {
  return u ? function(c) {
    return c.pipe(exhaustMap(function(l, v) {
      return from(a(l, v)).pipe(map(function(p, _) {
        return u(l, p, v, _);
      }));
    }));
  } : function(c) {
    return c.lift(new ExhaustMapOperator(a));
  };
}
var ExhaustMapOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.project = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new ExhaustMapSubscriber(u, this.project));
  }, a;
}(), ExhaustMapSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.project = l, v.hasSubscription = !1, v.hasCompleted = !1, v.index = 0, v;
  }
  return u.prototype._next = function(c) {
    this.hasSubscription || this.tryNext(c);
  }, u.prototype.tryNext = function(c) {
    var l, v = this.index++;
    try {
      l = this.project(c, v);
    } catch (p) {
      this.destination.error(p);
      return;
    }
    this.hasSubscription = !0, this._innerSub(l);
  }, u.prototype._innerSub = function(c) {
    var l = new SimpleInnerSubscriber(this), v = this.destination;
    v.add(l);
    var p = innerSubscribe(c, l);
    p !== l && v.add(p);
  }, u.prototype._complete = function() {
    this.hasCompleted = !0, this.hasSubscription || this.destination.complete(), this.unsubscribe();
  }, u.prototype.notifyNext = function(c) {
    this.destination.next(c);
  }, u.prototype.notifyError = function(c) {
    this.destination.error(c);
  }, u.prototype.notifyComplete = function() {
    this.hasSubscription = !1, this.hasCompleted && this.destination.complete();
  }, u;
}(SimpleOuterSubscriber);
function expand(a, u, c) {
  return u === void 0 && (u = Number.POSITIVE_INFINITY), u = (u || 0) < 1 ? Number.POSITIVE_INFINITY : u, function(l) {
    return l.lift(new ExpandOperator(a, u, c));
  };
}
var ExpandOperator = /* @__PURE__ */ function() {
  function a(u, c, l) {
    this.project = u, this.concurrent = c, this.scheduler = l;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new ExpandSubscriber(u, this.project, this.concurrent, this.scheduler));
  }, a;
}(), ExpandSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v, p) {
    var _ = a.call(this, c) || this;
    return _.project = l, _.concurrent = v, _.scheduler = p, _.index = 0, _.active = 0, _.hasCompleted = !1, v < Number.POSITIVE_INFINITY && (_.buffer = []), _;
  }
  return u.dispatch = function(c) {
    var l = c.subscriber, v = c.result, p = c.value, _ = c.index;
    l.subscribeToProjection(v, p, _);
  }, u.prototype._next = function(c) {
    var l = this.destination;
    if (l.closed) {
      this._complete();
      return;
    }
    var v = this.index++;
    if (this.active < this.concurrent) {
      l.next(c);
      try {
        var p = this.project, _ = p(c, v);
        if (!this.scheduler)
          this.subscribeToProjection(_, c, v);
        else {
          var k = { subscriber: this, result: _, value: c, index: v }, M = this.destination;
          M.add(this.scheduler.schedule(u.dispatch, 0, k));
        }
      } catch (L) {
        l.error(L);
      }
    } else
      this.buffer.push(c);
  }, u.prototype.subscribeToProjection = function(c, l, v) {
    this.active++;
    var p = this.destination;
    p.add(innerSubscribe(c, new SimpleInnerSubscriber(this)));
  }, u.prototype._complete = function() {
    this.hasCompleted = !0, this.hasCompleted && this.active === 0 && this.destination.complete(), this.unsubscribe();
  }, u.prototype.notifyNext = function(c) {
    this._next(c);
  }, u.prototype.notifyComplete = function() {
    var c = this.buffer;
    this.active--, c && c.length > 0 && this._next(c.shift()), this.hasCompleted && this.active === 0 && this.destination.complete();
  }, u;
}(SimpleOuterSubscriber);
function finalize(a) {
  return function(u) {
    return u.lift(new FinallyOperator(a));
  };
}
var FinallyOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.callback = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new FinallySubscriber(u, this.callback));
  }, a;
}(), FinallySubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.add(new Subscription(l)), v;
  }
  return u;
}(Subscriber);
function find$2(a, u) {
  if (typeof a != "function")
    throw new TypeError("predicate is not a function");
  return function(c) {
    return c.lift(new FindValueOperator(a, c, !1, u));
  };
}
var FindValueOperator = /* @__PURE__ */ function() {
  function a(u, c, l, v) {
    this.predicate = u, this.source = c, this.yieldIndex = l, this.thisArg = v;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new FindValueSubscriber(u, this.predicate, this.source, this.yieldIndex, this.thisArg));
  }, a;
}(), FindValueSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v, p, _) {
    var k = a.call(this, c) || this;
    return k.predicate = l, k.source = v, k.yieldIndex = p, k.thisArg = _, k.index = 0, k;
  }
  return u.prototype.notifyComplete = function(c) {
    var l = this.destination;
    l.next(c), l.complete(), this.unsubscribe();
  }, u.prototype._next = function(c) {
    var l = this, v = l.predicate, p = l.thisArg, _ = this.index++;
    try {
      var k = v.call(p || this, c, _, this.source);
      k && this.notifyComplete(this.yieldIndex ? _ : c);
    } catch (M) {
      this.destination.error(M);
    }
  }, u.prototype._complete = function() {
    this.notifyComplete(this.yieldIndex ? -1 : void 0);
  }, u;
}(Subscriber);
function findIndex(a, u) {
  return function(c) {
    return c.lift(new FindValueOperator(a, c, !0, u));
  };
}
function first(a, u) {
  var c = arguments.length >= 2;
  return function(l) {
    return l.pipe(a ? filter(function(v, p) {
      return a(v, p, l);
    }) : identity$1, take(1), c ? defaultIfEmpty(u) : throwIfEmpty(function() {
      return new EmptyError();
    }));
  };
}
var ObjectUnsubscribedErrorImpl = /* @__PURE__ */ function() {
  function a() {
    return Error.call(this), this.message = "object unsubscribed", this.name = "ObjectUnsubscribedError", this;
  }
  return a.prototype = /* @__PURE__ */ Object.create(Error.prototype), a;
}(), ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl, SubjectSubscription = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this) || this;
    return v.subject = c, v.subscriber = l, v.closed = !1, v;
  }
  return u.prototype.unsubscribe = function() {
    if (!this.closed) {
      this.closed = !0;
      var c = this.subject, l = c.observers;
      if (this.subject = null, !(!l || l.length === 0 || c.isStopped || c.closed)) {
        var v = l.indexOf(this.subscriber);
        v !== -1 && l.splice(v, 1);
      }
    }
  }, u;
}(Subscription), SubjectSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c) {
    var l = a.call(this, c) || this;
    return l.destination = c, l;
  }
  return u;
}(Subscriber), Subject = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u() {
    var c = a.call(this) || this;
    return c.observers = [], c.closed = !1, c.isStopped = !1, c.hasError = !1, c.thrownError = null, c;
  }
  return u.prototype[rxSubscriber] = function() {
    return new SubjectSubscriber(this);
  }, u.prototype.lift = function(c) {
    var l = new AnonymousSubject(this, this);
    return l.operator = c, l;
  }, u.prototype.next = function(c) {
    if (this.closed)
      throw new ObjectUnsubscribedError();
    if (!this.isStopped)
      for (var l = this.observers, v = l.length, p = l.slice(), _ = 0; _ < v; _++)
        p[_].next(c);
  }, u.prototype.error = function(c) {
    if (this.closed)
      throw new ObjectUnsubscribedError();
    this.hasError = !0, this.thrownError = c, this.isStopped = !0;
    for (var l = this.observers, v = l.length, p = l.slice(), _ = 0; _ < v; _++)
      p[_].error(c);
    this.observers.length = 0;
  }, u.prototype.complete = function() {
    if (this.closed)
      throw new ObjectUnsubscribedError();
    this.isStopped = !0;
    for (var c = this.observers, l = c.length, v = c.slice(), p = 0; p < l; p++)
      v[p].complete();
    this.observers.length = 0;
  }, u.prototype.unsubscribe = function() {
    this.isStopped = !0, this.closed = !0, this.observers = null;
  }, u.prototype._trySubscribe = function(c) {
    if (this.closed)
      throw new ObjectUnsubscribedError();
    return a.prototype._trySubscribe.call(this, c);
  }, u.prototype._subscribe = function(c) {
    if (this.closed)
      throw new ObjectUnsubscribedError();
    return this.hasError ? (c.error(this.thrownError), Subscription.EMPTY) : this.isStopped ? (c.complete(), Subscription.EMPTY) : (this.observers.push(c), new SubjectSubscription(this, c));
  }, u.prototype.asObservable = function() {
    var c = new Observable();
    return c.source = this, c;
  }, u.create = function(c, l) {
    return new AnonymousSubject(c, l);
  }, u;
}(Observable), AnonymousSubject = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this) || this;
    return v.destination = c, v.source = l, v;
  }
  return u.prototype.next = function(c) {
    var l = this.destination;
    l && l.next && l.next(c);
  }, u.prototype.error = function(c) {
    var l = this.destination;
    l && l.error && this.destination.error(c);
  }, u.prototype.complete = function() {
    var c = this.destination;
    c && c.complete && this.destination.complete();
  }, u.prototype._subscribe = function(c) {
    var l = this.source;
    return l ? this.source.subscribe(c) : Subscription.EMPTY;
  }, u;
}(Subject);
function groupBy(a, u, c, l) {
  return function(v) {
    return v.lift(new GroupByOperator(a, u, c, l));
  };
}
var GroupByOperator = /* @__PURE__ */ function() {
  function a(u, c, l, v) {
    this.keySelector = u, this.elementSelector = c, this.durationSelector = l, this.subjectSelector = v;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new GroupBySubscriber(u, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));
  }, a;
}(), GroupBySubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v, p, _) {
    var k = a.call(this, c) || this;
    return k.keySelector = l, k.elementSelector = v, k.durationSelector = p, k.subjectSelector = _, k.groups = null, k.attemptedToUnsubscribe = !1, k.count = 0, k;
  }
  return u.prototype._next = function(c) {
    var l;
    try {
      l = this.keySelector(c);
    } catch (v) {
      this.error(v);
      return;
    }
    this._group(c, l);
  }, u.prototype._group = function(c, l) {
    var v = this.groups;
    v || (v = this.groups = /* @__PURE__ */ new Map());
    var p = v.get(l), _;
    if (this.elementSelector)
      try {
        _ = this.elementSelector(c);
      } catch (L) {
        this.error(L);
      }
    else
      _ = c;
    if (!p) {
      p = this.subjectSelector ? this.subjectSelector() : new Subject(), v.set(l, p);
      var k = new GroupedObservable(l, p, this);
      if (this.destination.next(k), this.durationSelector) {
        var M = void 0;
        try {
          M = this.durationSelector(new GroupedObservable(l, p));
        } catch (L) {
          this.error(L);
          return;
        }
        this.add(M.subscribe(new GroupDurationSubscriber(l, p, this)));
      }
    }
    p.closed || p.next(_);
  }, u.prototype._error = function(c) {
    var l = this.groups;
    l && (l.forEach(function(v, p) {
      v.error(c);
    }), l.clear()), this.destination.error(c);
  }, u.prototype._complete = function() {
    var c = this.groups;
    c && (c.forEach(function(l, v) {
      l.complete();
    }), c.clear()), this.destination.complete();
  }, u.prototype.removeGroup = function(c) {
    this.groups.delete(c);
  }, u.prototype.unsubscribe = function() {
    this.closed || (this.attemptedToUnsubscribe = !0, this.count === 0 && a.prototype.unsubscribe.call(this));
  }, u;
}(Subscriber), GroupDurationSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, l) || this;
    return p.key = c, p.group = l, p.parent = v, p;
  }
  return u.prototype._next = function(c) {
    this.complete();
  }, u.prototype._unsubscribe = function() {
    var c = this, l = c.parent, v = c.key;
    this.key = this.parent = null, l && l.removeGroup(v);
  }, u;
}(Subscriber), GroupedObservable = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this) || this;
    return p.key = c, p.groupSubject = l, p.refCountSubscription = v, p;
  }
  return u.prototype._subscribe = function(c) {
    var l = new Subscription(), v = this, p = v.refCountSubscription, _ = v.groupSubject;
    return p && !p.closed && l.add(new InnerRefCountSubscription(p)), l.add(_.subscribe(c)), l;
  }, u;
}(Observable), InnerRefCountSubscription = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c) {
    var l = a.call(this) || this;
    return l.parent = c, c.count++, l;
  }
  return u.prototype.unsubscribe = function() {
    var c = this.parent;
    !c.closed && !this.closed && (a.prototype.unsubscribe.call(this), c.count -= 1, c.count === 0 && c.attemptedToUnsubscribe && c.unsubscribe());
  }, u;
}(Subscription);
function ignoreElements() {
  return function(u) {
    return u.lift(new IgnoreElementsOperator());
  };
}
var IgnoreElementsOperator = /* @__PURE__ */ function() {
  function a() {
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new IgnoreElementsSubscriber(u));
  }, a;
}(), IgnoreElementsSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u() {
    return a !== null && a.apply(this, arguments) || this;
  }
  return u.prototype._next = function(c) {
  }, u;
}(Subscriber);
function isEmpty() {
  return function(a) {
    return a.lift(new IsEmptyOperator());
  };
}
var IsEmptyOperator = /* @__PURE__ */ function() {
  function a() {
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new IsEmptySubscriber(u));
  }, a;
}(), IsEmptySubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c) {
    return a.call(this, c) || this;
  }
  return u.prototype.notifyComplete = function(c) {
    var l = this.destination;
    l.next(c), l.complete();
  }, u.prototype._next = function(c) {
    this.notifyComplete(!1);
  }, u.prototype._complete = function() {
    this.notifyComplete(!0);
  }, u;
}(Subscriber);
function takeLast(a) {
  return function(c) {
    return a === 0 ? empty$2() : c.lift(new TakeLastOperator(a));
  };
}
var TakeLastOperator = /* @__PURE__ */ function() {
  function a(u) {
    if (this.total = u, this.total < 0)
      throw new ArgumentOutOfRangeError();
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new TakeLastSubscriber(u, this.total));
  }, a;
}(), TakeLastSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.total = l, v.ring = new Array(), v.count = 0, v;
  }
  return u.prototype._next = function(c) {
    var l = this.ring, v = this.total, p = this.count++;
    if (l.length < v)
      l.push(c);
    else {
      var _ = p % v;
      l[_] = c;
    }
  }, u.prototype._complete = function() {
    var c = this.destination, l = this.count;
    if (l > 0)
      for (var v = this.count >= this.total ? this.total : this.count, p = this.ring, _ = 0; _ < v; _++) {
        var k = l++ % v;
        c.next(p[k]);
      }
    c.complete();
  }, u;
}(Subscriber);
function last$1(a, u) {
  var c = arguments.length >= 2;
  return function(l) {
    return l.pipe(a ? filter(function(v, p) {
      return a(v, p, l);
    }) : identity$1, takeLast(1), c ? defaultIfEmpty(u) : throwIfEmpty(function() {
      return new EmptyError();
    }));
  };
}
function mapTo(a) {
  return function(u) {
    return u.lift(new MapToOperator(a));
  };
}
var MapToOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.value = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new MapToSubscriber(u, this.value));
  }, a;
}(), MapToSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.value = l, v;
  }
  return u.prototype._next = function(c) {
    this.destination.next(this.value);
  }, u;
}(Subscriber);
function materialize() {
  return function(u) {
    return u.lift(new MaterializeOperator());
  };
}
var MaterializeOperator = /* @__PURE__ */ function() {
  function a() {
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new MaterializeSubscriber(u));
  }, a;
}(), MaterializeSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c) {
    return a.call(this, c) || this;
  }
  return u.prototype._next = function(c) {
    this.destination.next(Notification.createNext(c));
  }, u.prototype._error = function(c) {
    var l = this.destination;
    l.next(Notification.createError(c)), l.complete();
  }, u.prototype._complete = function() {
    var c = this.destination;
    c.next(Notification.createComplete()), c.complete();
  }, u;
}(Subscriber);
function scan(a, u) {
  var c = !1;
  return arguments.length >= 2 && (c = !0), function(v) {
    return v.lift(new ScanOperator(a, u, c));
  };
}
var ScanOperator = /* @__PURE__ */ function() {
  function a(u, c, l) {
    l === void 0 && (l = !1), this.accumulator = u, this.seed = c, this.hasSeed = l;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new ScanSubscriber(u, this.accumulator, this.seed, this.hasSeed));
  }, a;
}(), ScanSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v, p) {
    var _ = a.call(this, c) || this;
    return _.accumulator = l, _._seed = v, _.hasSeed = p, _.index = 0, _;
  }
  return Object.defineProperty(u.prototype, "seed", {
    get: function() {
      return this._seed;
    },
    set: function(c) {
      this.hasSeed = !0, this._seed = c;
    },
    enumerable: !0,
    configurable: !0
  }), u.prototype._next = function(c) {
    if (!this.hasSeed)
      this.seed = c, this.destination.next(c);
    else
      return this._tryNext(c);
  }, u.prototype._tryNext = function(c) {
    var l = this.index++, v;
    try {
      v = this.accumulator(this.seed, c, l);
    } catch (p) {
      this.destination.error(p);
    }
    this.seed = v, this.destination.next(v);
  }, u;
}(Subscriber);
function reduce(a, u) {
  return arguments.length >= 2 ? function(l) {
    return pipe$2(scan(a, u), takeLast(1), defaultIfEmpty(u))(l);
  } : function(l) {
    return pipe$2(scan(function(v, p, _) {
      return a(v, p, _ + 1);
    }), takeLast(1))(l);
  };
}
function max$1(a) {
  var u = typeof a == "function" ? function(c, l) {
    return a(c, l) > 0 ? c : l;
  } : function(c, l) {
    return c > l ? c : l;
  };
  return reduce(u);
}
function merge$2() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  var c = Number.POSITIVE_INFINITY, l = null, v = a[a.length - 1];
  return isScheduler(v) ? (l = a.pop(), a.length > 1 && typeof a[a.length - 1] == "number" && (c = a.pop())) : typeof v == "number" && (c = a.pop()), l === null && a.length === 1 && a[0] instanceof Observable ? a[0] : mergeAll(c)(fromArray$1(a, l));
}
function merge$1() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  return function(c) {
    return c.lift.call(merge$2.apply(void 0, [c].concat(a)));
  };
}
function mergeMapTo(a, u, c) {
  return c === void 0 && (c = Number.POSITIVE_INFINITY), typeof u == "function" ? mergeMap(function() {
    return a;
  }, u, c) : (typeof u == "number" && (c = u), mergeMap(function() {
    return a;
  }, c));
}
function mergeScan(a, u, c) {
  return c === void 0 && (c = Number.POSITIVE_INFINITY), function(l) {
    return l.lift(new MergeScanOperator(a, u, c));
  };
}
var MergeScanOperator = /* @__PURE__ */ function() {
  function a(u, c, l) {
    this.accumulator = u, this.seed = c, this.concurrent = l;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new MergeScanSubscriber(u, this.accumulator, this.seed, this.concurrent));
  }, a;
}(), MergeScanSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v, p) {
    var _ = a.call(this, c) || this;
    return _.accumulator = l, _.acc = v, _.concurrent = p, _.hasValue = !1, _.hasCompleted = !1, _.buffer = [], _.active = 0, _.index = 0, _;
  }
  return u.prototype._next = function(c) {
    if (this.active < this.concurrent) {
      var l = this.index++, v = this.destination, p = void 0;
      try {
        var _ = this.accumulator;
        p = _(this.acc, c, l);
      } catch (k) {
        return v.error(k);
      }
      this.active++, this._innerSub(p);
    } else
      this.buffer.push(c);
  }, u.prototype._innerSub = function(c) {
    var l = new SimpleInnerSubscriber(this), v = this.destination;
    v.add(l);
    var p = innerSubscribe(c, l);
    p !== l && v.add(p);
  }, u.prototype._complete = function() {
    this.hasCompleted = !0, this.active === 0 && this.buffer.length === 0 && (this.hasValue === !1 && this.destination.next(this.acc), this.destination.complete()), this.unsubscribe();
  }, u.prototype.notifyNext = function(c) {
    var l = this.destination;
    this.acc = c, this.hasValue = !0, l.next(c);
  }, u.prototype.notifyComplete = function() {
    var c = this.buffer;
    this.active--, c.length > 0 ? this._next(c.shift()) : this.active === 0 && this.hasCompleted && (this.hasValue === !1 && this.destination.next(this.acc), this.destination.complete());
  }, u;
}(SimpleOuterSubscriber);
function min(a) {
  var u = typeof a == "function" ? function(c, l) {
    return a(c, l) < 0 ? c : l;
  } : function(c, l) {
    return c < l ? c : l;
  };
  return reduce(u);
}
function refCount() {
  return function(u) {
    return u.lift(new RefCountOperator(u));
  };
}
var RefCountOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.connectable = u;
  }
  return a.prototype.call = function(u, c) {
    var l = this.connectable;
    l._refCount++;
    var v = new RefCountSubscriber(u, l), p = c.subscribe(v);
    return v.closed || (v.connection = l.connect()), p;
  }, a;
}(), RefCountSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.connectable = l, v;
  }
  return u.prototype._unsubscribe = function() {
    var c = this.connectable;
    if (!c) {
      this.connection = null;
      return;
    }
    this.connectable = null;
    var l = c._refCount;
    if (l <= 0) {
      this.connection = null;
      return;
    }
    if (c._refCount = l - 1, l > 1) {
      this.connection = null;
      return;
    }
    var v = this.connection, p = c._connection;
    this.connection = null, p && (!v || p === v) && p.unsubscribe();
  }, u;
}(Subscriber), ConnectableObservable = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this) || this;
    return v.source = c, v.subjectFactory = l, v._refCount = 0, v._isComplete = !1, v;
  }
  return u.prototype._subscribe = function(c) {
    return this.getSubject().subscribe(c);
  }, u.prototype.getSubject = function() {
    var c = this._subject;
    return (!c || c.isStopped) && (this._subject = this.subjectFactory()), this._subject;
  }, u.prototype.connect = function() {
    var c = this._connection;
    return c || (this._isComplete = !1, c = this._connection = new Subscription(), c.add(this.source.subscribe(new ConnectableSubscriber(this.getSubject(), this))), c.closed && (this._connection = null, c = Subscription.EMPTY)), c;
  }, u.prototype.refCount = function() {
    return refCount()(this);
  }, u;
}(Observable), connectableObservableDescriptor = /* @__PURE__ */ function() {
  var a = ConnectableObservable.prototype;
  return {
    operator: { value: null },
    _refCount: { value: 0, writable: !0 },
    _subject: { value: null, writable: !0 },
    _connection: { value: null, writable: !0 },
    _subscribe: { value: a._subscribe },
    _isComplete: { value: a._isComplete, writable: !0 },
    getSubject: { value: a.getSubject },
    connect: { value: a.connect },
    refCount: { value: a.refCount }
  };
}(), ConnectableSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.connectable = l, v;
  }
  return u.prototype._error = function(c) {
    this._unsubscribe(), a.prototype._error.call(this, c);
  }, u.prototype._complete = function() {
    this.connectable._isComplete = !0, this._unsubscribe(), a.prototype._complete.call(this);
  }, u.prototype._unsubscribe = function() {
    var c = this.connectable;
    if (c) {
      this.connectable = null;
      var l = c._connection;
      c._refCount = 0, c._subject = null, c._connection = null, l && l.unsubscribe();
    }
  }, u;
}(SubjectSubscriber);
function multicast(a, u) {
  return function(l) {
    var v;
    if (typeof a == "function" ? v = a : v = function() {
      return a;
    }, typeof u == "function")
      return l.lift(new MulticastOperator(v, u));
    var p = Object.create(l, connectableObservableDescriptor);
    return p.source = l, p.subjectFactory = v, p;
  };
}
var MulticastOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.subjectFactory = u, this.selector = c;
  }
  return a.prototype.call = function(u, c) {
    var l = this.selector, v = this.subjectFactory(), p = l(v).subscribe(u);
    return p.add(c.subscribe(v)), p;
  }, a;
}();
function observeOn(a, u) {
  return u === void 0 && (u = 0), function(l) {
    return l.lift(new ObserveOnOperator(a, u));
  };
}
var ObserveOnOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    c === void 0 && (c = 0), this.scheduler = u, this.delay = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new ObserveOnSubscriber(u, this.scheduler, this.delay));
  }, a;
}(), ObserveOnSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    v === void 0 && (v = 0);
    var p = a.call(this, c) || this;
    return p.scheduler = l, p.delay = v, p;
  }
  return u.dispatch = function(c) {
    var l = c.notification, v = c.destination;
    l.observe(v), this.unsubscribe();
  }, u.prototype.scheduleMessage = function(c) {
    var l = this.destination;
    l.add(this.scheduler.schedule(u.dispatch, this.delay, new ObserveOnMessage(c, this.destination)));
  }, u.prototype._next = function(c) {
    this.scheduleMessage(Notification.createNext(c));
  }, u.prototype._error = function(c) {
    this.scheduleMessage(Notification.createError(c)), this.unsubscribe();
  }, u.prototype._complete = function() {
    this.scheduleMessage(Notification.createComplete()), this.unsubscribe();
  }, u;
}(Subscriber), ObserveOnMessage = /* @__PURE__ */ function() {
  function a(u, c) {
    this.notification = u, this.destination = c;
  }
  return a;
}();
function onErrorResumeNext() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  return a.length === 1 && isArray$5(a[0]) && (a = a[0]), function(c) {
    return c.lift(new OnErrorResumeNextOperator(a));
  };
}
var OnErrorResumeNextOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.nextSources = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new OnErrorResumeNextSubscriber(u, this.nextSources));
  }, a;
}(), OnErrorResumeNextSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.destination = c, v.nextSources = l, v;
  }
  return u.prototype.notifyError = function() {
    this.subscribeToNextSource();
  }, u.prototype.notifyComplete = function() {
    this.subscribeToNextSource();
  }, u.prototype._error = function(c) {
    this.subscribeToNextSource(), this.unsubscribe();
  }, u.prototype._complete = function() {
    this.subscribeToNextSource(), this.unsubscribe();
  }, u.prototype.subscribeToNextSource = function() {
    var c = this.nextSources.shift();
    if (c) {
      var l = new SimpleInnerSubscriber(this), v = this.destination;
      v.add(l);
      var p = innerSubscribe(c, l);
      p !== l && v.add(p);
    } else
      this.destination.complete();
  }, u;
}(SimpleOuterSubscriber);
function pairwise() {
  return function(a) {
    return a.lift(new PairwiseOperator());
  };
}
var PairwiseOperator = /* @__PURE__ */ function() {
  function a() {
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new PairwiseSubscriber(u));
  }, a;
}(), PairwiseSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c) {
    var l = a.call(this, c) || this;
    return l.hasPrev = !1, l;
  }
  return u.prototype._next = function(c) {
    var l;
    this.hasPrev ? l = [this.prev, c] : this.hasPrev = !0, this.prev = c, l && this.destination.next(l);
  }, u;
}(Subscriber);
function not(a, u) {
  function c() {
    return !c.pred.apply(c.thisArg, arguments);
  }
  return c.pred = a, c.thisArg = u, c;
}
function partition(a, u) {
  return function(c) {
    return [
      filter(a, u)(c),
      filter(not(a, u))(c)
    ];
  };
}
function pluck() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  var c = a.length;
  if (c === 0)
    throw new Error("list of properties cannot be empty.");
  return function(l) {
    return map(plucker(a, c))(l);
  };
}
function plucker(a, u) {
  var c = function(l) {
    for (var v = l, p = 0; p < u; p++) {
      var _ = v != null ? v[a[p]] : void 0;
      if (_ !== void 0)
        v = _;
      else
        return;
    }
    return v;
  };
  return c;
}
function publish(a) {
  return a ? multicast(function() {
    return new Subject();
  }, a) : multicast(new Subject());
}
var BehaviorSubject = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c) {
    var l = a.call(this) || this;
    return l._value = c, l;
  }
  return Object.defineProperty(u.prototype, "value", {
    get: function() {
      return this.getValue();
    },
    enumerable: !0,
    configurable: !0
  }), u.prototype._subscribe = function(c) {
    var l = a.prototype._subscribe.call(this, c);
    return l && !l.closed && c.next(this._value), l;
  }, u.prototype.getValue = function() {
    if (this.hasError)
      throw this.thrownError;
    if (this.closed)
      throw new ObjectUnsubscribedError();
    return this._value;
  }, u.prototype.next = function(c) {
    a.prototype.next.call(this, this._value = c);
  }, u;
}(Subject);
function publishBehavior(a) {
  return function(u) {
    return multicast(new BehaviorSubject(a))(u);
  };
}
var AsyncSubject = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u() {
    var c = a !== null && a.apply(this, arguments) || this;
    return c.value = null, c.hasNext = !1, c.hasCompleted = !1, c;
  }
  return u.prototype._subscribe = function(c) {
    return this.hasError ? (c.error(this.thrownError), Subscription.EMPTY) : this.hasCompleted && this.hasNext ? (c.next(this.value), c.complete(), Subscription.EMPTY) : a.prototype._subscribe.call(this, c);
  }, u.prototype.next = function(c) {
    this.hasCompleted || (this.value = c, this.hasNext = !0);
  }, u.prototype.error = function(c) {
    this.hasCompleted || a.prototype.error.call(this, c);
  }, u.prototype.complete = function() {
    this.hasCompleted = !0, this.hasNext && a.prototype.next.call(this, this.value), a.prototype.complete.call(this);
  }, u;
}(Subject);
function publishLast() {
  return function(a) {
    return multicast(new AsyncSubject())(a);
  };
}
var QueueAction = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c, l) || this;
    return v.scheduler = c, v.work = l, v;
  }
  return u.prototype.schedule = function(c, l) {
    return l === void 0 && (l = 0), l > 0 ? a.prototype.schedule.call(this, c, l) : (this.delay = l, this.state = c, this.scheduler.flush(this), this);
  }, u.prototype.execute = function(c, l) {
    return l > 0 || this.closed ? a.prototype.execute.call(this, c, l) : this._execute(c, l);
  }, u.prototype.requestAsyncId = function(c, l, v) {
    return v === void 0 && (v = 0), v !== null && v > 0 || v === null && this.delay > 0 ? a.prototype.requestAsyncId.call(this, c, l, v) : c.flush(this);
  }, u;
}(AsyncAction), QueueScheduler = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u() {
    return a !== null && a.apply(this, arguments) || this;
  }
  return u;
}(AsyncScheduler), queueScheduler = /* @__PURE__ */ new QueueScheduler(QueueAction), queue$1 = queueScheduler, ReplaySubject = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    c === void 0 && (c = Number.POSITIVE_INFINITY), l === void 0 && (l = Number.POSITIVE_INFINITY);
    var p = a.call(this) || this;
    return p.scheduler = v, p._events = [], p._infiniteTimeWindow = !1, p._bufferSize = c < 1 ? 1 : c, p._windowTime = l < 1 ? 1 : l, l === Number.POSITIVE_INFINITY ? (p._infiniteTimeWindow = !0, p.next = p.nextInfiniteTimeWindow) : p.next = p.nextTimeWindow, p;
  }
  return u.prototype.nextInfiniteTimeWindow = function(c) {
    if (!this.isStopped) {
      var l = this._events;
      l.push(c), l.length > this._bufferSize && l.shift();
    }
    a.prototype.next.call(this, c);
  }, u.prototype.nextTimeWindow = function(c) {
    this.isStopped || (this._events.push(new ReplayEvent(this._getNow(), c)), this._trimBufferThenGetEvents()), a.prototype.next.call(this, c);
  }, u.prototype._subscribe = function(c) {
    var l = this._infiniteTimeWindow, v = l ? this._events : this._trimBufferThenGetEvents(), p = this.scheduler, _ = v.length, k;
    if (this.closed)
      throw new ObjectUnsubscribedError();
    if (this.isStopped || this.hasError ? k = Subscription.EMPTY : (this.observers.push(c), k = new SubjectSubscription(this, c)), p && c.add(c = new ObserveOnSubscriber(c, p)), l)
      for (var M = 0; M < _ && !c.closed; M++)
        c.next(v[M]);
    else
      for (var M = 0; M < _ && !c.closed; M++)
        c.next(v[M].value);
    return this.hasError ? c.error(this.thrownError) : this.isStopped && c.complete(), k;
  }, u.prototype._getNow = function() {
    return (this.scheduler || queue$1).now();
  }, u.prototype._trimBufferThenGetEvents = function() {
    for (var c = this._getNow(), l = this._bufferSize, v = this._windowTime, p = this._events, _ = p.length, k = 0; k < _ && !(c - p[k].time < v); )
      k++;
    return _ > l && (k = Math.max(k, _ - l)), k > 0 && p.splice(0, k), p;
  }, u;
}(Subject), ReplayEvent = /* @__PURE__ */ function() {
  function a(u, c) {
    this.time = u, this.value = c;
  }
  return a;
}();
function publishReplay(a, u, c, l) {
  c && typeof c != "function" && (l = c);
  var v = typeof c == "function" ? c : void 0, p = new ReplaySubject(a, u, l);
  return function(_) {
    return multicast(function() {
      return p;
    }, v)(_);
  };
}
function race$1() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  if (a.length === 1)
    if (isArray$5(a[0]))
      a = a[0];
    else
      return a[0];
  return fromArray$1(a, void 0).lift(new RaceOperator());
}
var RaceOperator = /* @__PURE__ */ function() {
  function a() {
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new RaceSubscriber(u));
  }, a;
}(), RaceSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c) {
    var l = a.call(this, c) || this;
    return l.hasFirst = !1, l.observables = [], l.subscriptions = [], l;
  }
  return u.prototype._next = function(c) {
    this.observables.push(c);
  }, u.prototype._complete = function() {
    var c = this.observables, l = c.length;
    if (l === 0)
      this.destination.complete();
    else {
      for (var v = 0; v < l && !this.hasFirst; v++) {
        var p = c[v], _ = subscribeToResult(this, p, void 0, v);
        this.subscriptions && this.subscriptions.push(_), this.add(_);
      }
      this.observables = null;
    }
  }, u.prototype.notifyNext = function(c, l, v) {
    if (!this.hasFirst) {
      this.hasFirst = !0;
      for (var p = 0; p < this.subscriptions.length; p++)
        if (p !== v) {
          var _ = this.subscriptions[p];
          _.unsubscribe(), this.remove(_);
        }
      this.subscriptions = null;
    }
    this.destination.next(l);
  }, u;
}(OuterSubscriber);
function race() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  return function(l) {
    return a.length === 1 && isArray$5(a[0]) && (a = a[0]), l.lift.call(race$1.apply(void 0, [l].concat(a)));
  };
}
function repeat(a) {
  return a === void 0 && (a = -1), function(u) {
    return a === 0 ? empty$2() : a < 0 ? u.lift(new RepeatOperator(-1, u)) : u.lift(new RepeatOperator(a - 1, u));
  };
}
var RepeatOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.count = u, this.source = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new RepeatSubscriber(u, this.count, this.source));
  }, a;
}(), RepeatSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.count = l, p.source = v, p;
  }
  return u.prototype.complete = function() {
    if (!this.isStopped) {
      var c = this, l = c.source, v = c.count;
      if (v === 0)
        return a.prototype.complete.call(this);
      v > -1 && (this.count = v - 1), l.subscribe(this._unsubscribeAndRecycle());
    }
  }, u;
}(Subscriber);
function repeatWhen(a) {
  return function(u) {
    return u.lift(new RepeatWhenOperator(a));
  };
}
var RepeatWhenOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.notifier = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new RepeatWhenSubscriber(u, this.notifier, c));
  }, a;
}(), RepeatWhenSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.notifier = l, p.source = v, p.sourceIsBeingSubscribedTo = !0, p;
  }
  return u.prototype.notifyNext = function() {
    this.sourceIsBeingSubscribedTo = !0, this.source.subscribe(this);
  }, u.prototype.notifyComplete = function() {
    if (this.sourceIsBeingSubscribedTo === !1)
      return a.prototype.complete.call(this);
  }, u.prototype.complete = function() {
    if (this.sourceIsBeingSubscribedTo = !1, !this.isStopped) {
      if (this.retries || this.subscribeToRetries(), !this.retriesSubscription || this.retriesSubscription.closed)
        return a.prototype.complete.call(this);
      this._unsubscribeAndRecycle(), this.notifications.next(void 0);
    }
  }, u.prototype._unsubscribe = function() {
    var c = this, l = c.notifications, v = c.retriesSubscription;
    l && (l.unsubscribe(), this.notifications = void 0), v && (v.unsubscribe(), this.retriesSubscription = void 0), this.retries = void 0;
  }, u.prototype._unsubscribeAndRecycle = function() {
    var c = this._unsubscribe;
    return this._unsubscribe = null, a.prototype._unsubscribeAndRecycle.call(this), this._unsubscribe = c, this;
  }, u.prototype.subscribeToRetries = function() {
    this.notifications = new Subject();
    var c;
    try {
      var l = this.notifier;
      c = l(this.notifications);
    } catch {
      return a.prototype.complete.call(this);
    }
    this.retries = c, this.retriesSubscription = innerSubscribe(c, new SimpleInnerSubscriber(this));
  }, u;
}(SimpleOuterSubscriber);
function retry(a) {
  return a === void 0 && (a = -1), function(u) {
    return u.lift(new RetryOperator(a, u));
  };
}
var RetryOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.count = u, this.source = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new RetrySubscriber(u, this.count, this.source));
  }, a;
}(), RetrySubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.count = l, p.source = v, p;
  }
  return u.prototype.error = function(c) {
    if (!this.isStopped) {
      var l = this, v = l.source, p = l.count;
      if (p === 0)
        return a.prototype.error.call(this, c);
      p > -1 && (this.count = p - 1), v.subscribe(this._unsubscribeAndRecycle());
    }
  }, u;
}(Subscriber);
function retryWhen(a) {
  return function(u) {
    return u.lift(new RetryWhenOperator(a, u));
  };
}
var RetryWhenOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.notifier = u, this.source = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new RetryWhenSubscriber(u, this.notifier, this.source));
  }, a;
}(), RetryWhenSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.notifier = l, p.source = v, p;
  }
  return u.prototype.error = function(c) {
    if (!this.isStopped) {
      var l = this.errors, v = this.retries, p = this.retriesSubscription;
      if (v)
        this.errors = void 0, this.retriesSubscription = void 0;
      else {
        l = new Subject();
        try {
          var _ = this.notifier;
          v = _(l);
        } catch (k) {
          return a.prototype.error.call(this, k);
        }
        p = innerSubscribe(v, new SimpleInnerSubscriber(this));
      }
      this._unsubscribeAndRecycle(), this.errors = l, this.retries = v, this.retriesSubscription = p, l.next(c);
    }
  }, u.prototype._unsubscribe = function() {
    var c = this, l = c.errors, v = c.retriesSubscription;
    l && (l.unsubscribe(), this.errors = void 0), v && (v.unsubscribe(), this.retriesSubscription = void 0), this.retries = void 0;
  }, u.prototype.notifyNext = function() {
    var c = this._unsubscribe;
    this._unsubscribe = null, this._unsubscribeAndRecycle(), this._unsubscribe = c, this.source.subscribe(this);
  }, u;
}(SimpleOuterSubscriber);
function sample(a) {
  return function(u) {
    return u.lift(new SampleOperator(a));
  };
}
var SampleOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.notifier = u;
  }
  return a.prototype.call = function(u, c) {
    var l = new SampleSubscriber(u), v = c.subscribe(l);
    return v.add(innerSubscribe(this.notifier, new SimpleInnerSubscriber(l))), v;
  }, a;
}(), SampleSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u() {
    var c = a !== null && a.apply(this, arguments) || this;
    return c.hasValue = !1, c;
  }
  return u.prototype._next = function(c) {
    this.value = c, this.hasValue = !0;
  }, u.prototype.notifyNext = function() {
    this.emitValue();
  }, u.prototype.notifyComplete = function() {
    this.emitValue();
  }, u.prototype.emitValue = function() {
    this.hasValue && (this.hasValue = !1, this.destination.next(this.value));
  }, u;
}(SimpleOuterSubscriber);
function sampleTime(a, u) {
  return u === void 0 && (u = async$1), function(c) {
    return c.lift(new SampleTimeOperator(a, u));
  };
}
var SampleTimeOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.period = u, this.scheduler = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new SampleTimeSubscriber(u, this.period, this.scheduler));
  }, a;
}(), SampleTimeSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.period = l, p.scheduler = v, p.hasValue = !1, p.add(v.schedule(dispatchNotification, l, { subscriber: p, period: l })), p;
  }
  return u.prototype._next = function(c) {
    this.lastValue = c, this.hasValue = !0;
  }, u.prototype.notifyNext = function() {
    this.hasValue && (this.hasValue = !1, this.destination.next(this.lastValue));
  }, u;
}(Subscriber);
function dispatchNotification(a) {
  var u = a.subscriber, c = a.period;
  u.notifyNext(), this.schedule(a, c);
}
function sequenceEqual(a, u) {
  return function(c) {
    return c.lift(new SequenceEqualOperator(a, u));
  };
}
var SequenceEqualOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.compareTo = u, this.comparator = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new SequenceEqualSubscriber(u, this.compareTo, this.comparator));
  }, a;
}(), SequenceEqualSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.compareTo = l, p.comparator = v, p._a = [], p._b = [], p._oneComplete = !1, p.destination.add(l.subscribe(new SequenceEqualCompareToSubscriber(c, p))), p;
  }
  return u.prototype._next = function(c) {
    this._oneComplete && this._b.length === 0 ? this.emit(!1) : (this._a.push(c), this.checkValues());
  }, u.prototype._complete = function() {
    this._oneComplete ? this.emit(this._a.length === 0 && this._b.length === 0) : this._oneComplete = !0, this.unsubscribe();
  }, u.prototype.checkValues = function() {
    for (var c = this, l = c._a, v = c._b, p = c.comparator; l.length > 0 && v.length > 0; ) {
      var _ = l.shift(), k = v.shift(), M = !1;
      try {
        M = p ? p(_, k) : _ === k;
      } catch (L) {
        this.destination.error(L);
      }
      M || this.emit(!1);
    }
  }, u.prototype.emit = function(c) {
    var l = this.destination;
    l.next(c), l.complete();
  }, u.prototype.nextB = function(c) {
    this._oneComplete && this._a.length === 0 ? this.emit(!1) : (this._b.push(c), this.checkValues());
  }, u.prototype.completeB = function() {
    this._oneComplete ? this.emit(this._a.length === 0 && this._b.length === 0) : this._oneComplete = !0;
  }, u;
}(Subscriber), SequenceEqualCompareToSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.parent = l, v;
  }
  return u.prototype._next = function(c) {
    this.parent.nextB(c);
  }, u.prototype._error = function(c) {
    this.parent.error(c), this.unsubscribe();
  }, u.prototype._complete = function() {
    this.parent.completeB(), this.unsubscribe();
  }, u;
}(Subscriber);
function shareSubjectFactory() {
  return new Subject();
}
function share() {
  return function(a) {
    return refCount()(multicast(shareSubjectFactory)(a));
  };
}
function shareReplay(a, u, c) {
  var l;
  return a && typeof a == "object" ? l = a : l = {
    bufferSize: a,
    windowTime: u,
    refCount: !1,
    scheduler: c
  }, function(v) {
    return v.lift(shareReplayOperator(l));
  };
}
function shareReplayOperator(a) {
  var u = a.bufferSize, c = u === void 0 ? Number.POSITIVE_INFINITY : u, l = a.windowTime, v = l === void 0 ? Number.POSITIVE_INFINITY : l, p = a.refCount, _ = a.scheduler, k, M = 0, L, F = !1, V = !1;
  return function(oe) {
    M++;
    var Y;
    !k || F ? (F = !1, k = new ReplaySubject(c, v, _), Y = k.subscribe(this), L = oe.subscribe({
      next: function(ae) {
        k.next(ae);
      },
      error: function(ae) {
        F = !0, k.error(ae);
      },
      complete: function() {
        V = !0, L = void 0, k.complete();
      }
    }), V && (L = void 0)) : Y = k.subscribe(this), this.add(function() {
      M--, Y.unsubscribe(), Y = void 0, L && !V && p && M === 0 && (L.unsubscribe(), L = void 0, k = void 0);
    });
  };
}
function single(a) {
  return function(u) {
    return u.lift(new SingleOperator(a, u));
  };
}
var SingleOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.predicate = u, this.source = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new SingleSubscriber(u, this.predicate, this.source));
  }, a;
}(), SingleSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.predicate = l, p.source = v, p.seenValue = !1, p.index = 0, p;
  }
  return u.prototype.applySingleValue = function(c) {
    this.seenValue ? this.destination.error("Sequence contains more than one element") : (this.seenValue = !0, this.singleValue = c);
  }, u.prototype._next = function(c) {
    var l = this.index++;
    this.predicate ? this.tryNext(c, l) : this.applySingleValue(c);
  }, u.prototype.tryNext = function(c, l) {
    try {
      this.predicate(c, l, this.source) && this.applySingleValue(c);
    } catch (v) {
      this.destination.error(v);
    }
  }, u.prototype._complete = function() {
    var c = this.destination;
    this.index > 0 ? (c.next(this.seenValue ? this.singleValue : void 0), c.complete()) : c.error(new EmptyError());
  }, u;
}(Subscriber);
function skip(a) {
  return function(u) {
    return u.lift(new SkipOperator(a));
  };
}
var SkipOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.total = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new SkipSubscriber(u, this.total));
  }, a;
}(), SkipSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.total = l, v.count = 0, v;
  }
  return u.prototype._next = function(c) {
    ++this.count > this.total && this.destination.next(c);
  }, u;
}(Subscriber);
function skipLast(a) {
  return function(u) {
    return u.lift(new SkipLastOperator(a));
  };
}
var SkipLastOperator = /* @__PURE__ */ function() {
  function a(u) {
    if (this._skipCount = u, this._skipCount < 0)
      throw new ArgumentOutOfRangeError();
  }
  return a.prototype.call = function(u, c) {
    return this._skipCount === 0 ? c.subscribe(new Subscriber(u)) : c.subscribe(new SkipLastSubscriber(u, this._skipCount));
  }, a;
}(), SkipLastSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v._skipCount = l, v._count = 0, v._ring = new Array(l), v;
  }
  return u.prototype._next = function(c) {
    var l = this._skipCount, v = this._count++;
    if (v < l)
      this._ring[v] = c;
    else {
      var p = v % l, _ = this._ring, k = _[p];
      _[p] = c, this.destination.next(k);
    }
  }, u;
}(Subscriber);
function skipUntil(a) {
  return function(u) {
    return u.lift(new SkipUntilOperator(a));
  };
}
var SkipUntilOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.notifier = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new SkipUntilSubscriber(u, this.notifier));
  }, a;
}(), SkipUntilSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    v.hasValue = !1;
    var p = new SimpleInnerSubscriber(v);
    v.add(p), v.innerSubscription = p;
    var _ = innerSubscribe(l, p);
    return _ !== p && (v.add(_), v.innerSubscription = _), v;
  }
  return u.prototype._next = function(c) {
    this.hasValue && a.prototype._next.call(this, c);
  }, u.prototype.notifyNext = function() {
    this.hasValue = !0, this.innerSubscription && this.innerSubscription.unsubscribe();
  }, u.prototype.notifyComplete = function() {
  }, u;
}(SimpleOuterSubscriber);
function skipWhile(a) {
  return function(u) {
    return u.lift(new SkipWhileOperator(a));
  };
}
var SkipWhileOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.predicate = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new SkipWhileSubscriber(u, this.predicate));
  }, a;
}(), SkipWhileSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.predicate = l, v.skipping = !0, v.index = 0, v;
  }
  return u.prototype._next = function(c) {
    var l = this.destination;
    this.skipping && this.tryCallPredicate(c), this.skipping || l.next(c);
  }, u.prototype.tryCallPredicate = function(c) {
    try {
      var l = this.predicate(c, this.index++);
      this.skipping = !!l;
    } catch (v) {
      this.destination.error(v);
    }
  }, u;
}(Subscriber);
function startWith() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  var c = a[a.length - 1];
  return isScheduler(c) ? (a.pop(), function(l) {
    return concat$1(a, l, c);
  }) : function(l) {
    return concat$1(a, l);
  };
}
var nextHandle = 1, RESOLVED = /* @__PURE__ */ function() {
  return /* @__PURE__ */ Promise.resolve();
}(), activeHandles = {};
function findAndClearHandle(a) {
  return a in activeHandles ? (delete activeHandles[a], !0) : !1;
}
var Immediate = {
  setImmediate: function(a) {
    var u = nextHandle++;
    return activeHandles[u] = !0, RESOLVED.then(function() {
      return findAndClearHandle(u) && a();
    }), u;
  },
  clearImmediate: function(a) {
    findAndClearHandle(a);
  }
}, AsapAction = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c, l) || this;
    return v.scheduler = c, v.work = l, v;
  }
  return u.prototype.requestAsyncId = function(c, l, v) {
    return v === void 0 && (v = 0), v !== null && v > 0 ? a.prototype.requestAsyncId.call(this, c, l, v) : (c.actions.push(this), c.scheduled || (c.scheduled = Immediate.setImmediate(c.flush.bind(c, null))));
  }, u.prototype.recycleAsyncId = function(c, l, v) {
    if (v === void 0 && (v = 0), v !== null && v > 0 || v === null && this.delay > 0)
      return a.prototype.recycleAsyncId.call(this, c, l, v);
    c.actions.length === 0 && (Immediate.clearImmediate(l), c.scheduled = void 0);
  }, u;
}(AsyncAction), AsapScheduler = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u() {
    return a !== null && a.apply(this, arguments) || this;
  }
  return u.prototype.flush = function(c) {
    this.active = !0, this.scheduled = void 0;
    var l = this.actions, v, p = -1, _ = l.length;
    c = c || l.shift();
    do
      if (v = c.execute(c.state, c.delay))
        break;
    while (++p < _ && (c = l.shift()));
    if (this.active = !1, v) {
      for (; ++p < _ && (c = l.shift()); )
        c.unsubscribe();
      throw v;
    }
  }, u;
}(AsyncScheduler), asapScheduler = /* @__PURE__ */ new AsapScheduler(AsapAction), asap = asapScheduler, SubscribeOnObservable = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    l === void 0 && (l = 0), v === void 0 && (v = asap);
    var p = a.call(this) || this;
    return p.source = c, p.delayTime = l, p.scheduler = v, (!isNumeric(l) || l < 0) && (p.delayTime = 0), (!v || typeof v.schedule != "function") && (p.scheduler = asap), p;
  }
  return u.create = function(c, l, v) {
    return l === void 0 && (l = 0), v === void 0 && (v = asap), new u(c, l, v);
  }, u.dispatch = function(c) {
    var l = c.source, v = c.subscriber;
    return this.add(l.subscribe(v));
  }, u.prototype._subscribe = function(c) {
    var l = this.delayTime, v = this.source, p = this.scheduler;
    return p.schedule(u.dispatch, l, {
      source: v,
      subscriber: c
    });
  }, u;
}(Observable);
function subscribeOn(a, u) {
  return u === void 0 && (u = 0), function(l) {
    return l.lift(new SubscribeOnOperator(a, u));
  };
}
var SubscribeOnOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.scheduler = u, this.delay = c;
  }
  return a.prototype.call = function(u, c) {
    return new SubscribeOnObservable(c, this.delay, this.scheduler).subscribe(u);
  }, a;
}();
function switchMap(a, u) {
  return typeof u == "function" ? function(c) {
    return c.pipe(switchMap(function(l, v) {
      return from(a(l, v)).pipe(map(function(p, _) {
        return u(l, p, v, _);
      }));
    }));
  } : function(c) {
    return c.lift(new SwitchMapOperator(a));
  };
}
var SwitchMapOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.project = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new SwitchMapSubscriber(u, this.project));
  }, a;
}(), SwitchMapSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.project = l, v.index = 0, v;
  }
  return u.prototype._next = function(c) {
    var l, v = this.index++;
    try {
      l = this.project(c, v);
    } catch (p) {
      this.destination.error(p);
      return;
    }
    this._innerSub(l);
  }, u.prototype._innerSub = function(c) {
    var l = this.innerSubscription;
    l && l.unsubscribe();
    var v = new SimpleInnerSubscriber(this), p = this.destination;
    p.add(v), this.innerSubscription = innerSubscribe(c, v), this.innerSubscription !== v && p.add(this.innerSubscription);
  }, u.prototype._complete = function() {
    var c = this.innerSubscription;
    (!c || c.closed) && a.prototype._complete.call(this), this.unsubscribe();
  }, u.prototype._unsubscribe = function() {
    this.innerSubscription = void 0;
  }, u.prototype.notifyComplete = function() {
    this.innerSubscription = void 0, this.isStopped && a.prototype._complete.call(this);
  }, u.prototype.notifyNext = function(c) {
    this.destination.next(c);
  }, u;
}(SimpleOuterSubscriber);
function switchAll() {
  return switchMap(identity$1);
}
function switchMapTo(a, u) {
  return u ? switchMap(function() {
    return a;
  }, u) : switchMap(function() {
    return a;
  });
}
function takeUntil(a) {
  return function(u) {
    return u.lift(new TakeUntilOperator(a));
  };
}
var TakeUntilOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.notifier = u;
  }
  return a.prototype.call = function(u, c) {
    var l = new TakeUntilSubscriber(u), v = innerSubscribe(this.notifier, new SimpleInnerSubscriber(l));
    return v && !l.seenValue ? (l.add(v), c.subscribe(l)) : l;
  }, a;
}(), TakeUntilSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c) {
    var l = a.call(this, c) || this;
    return l.seenValue = !1, l;
  }
  return u.prototype.notifyNext = function() {
    this.seenValue = !0, this.complete();
  }, u.prototype.notifyComplete = function() {
  }, u;
}(SimpleOuterSubscriber);
function takeWhile(a, u) {
  return u === void 0 && (u = !1), function(c) {
    return c.lift(new TakeWhileOperator(a, u));
  };
}
var TakeWhileOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.predicate = u, this.inclusive = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new TakeWhileSubscriber(u, this.predicate, this.inclusive));
  }, a;
}(), TakeWhileSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.predicate = l, p.inclusive = v, p.index = 0, p;
  }
  return u.prototype._next = function(c) {
    var l = this.destination, v;
    try {
      v = this.predicate(c, this.index++);
    } catch (p) {
      l.error(p);
      return;
    }
    this.nextOrComplete(c, v);
  }, u.prototype.nextOrComplete = function(c, l) {
    var v = this.destination;
    l ? v.next(c) : (this.inclusive && v.next(c), v.complete());
  }, u;
}(Subscriber);
function noop$6() {
}
function tap(a, u, c) {
  return function(v) {
    return v.lift(new DoOperator(a, u, c));
  };
}
var DoOperator = /* @__PURE__ */ function() {
  function a(u, c, l) {
    this.nextOrObserver = u, this.error = c, this.complete = l;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new TapSubscriber(u, this.nextOrObserver, this.error, this.complete));
  }, a;
}(), TapSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v, p) {
    var _ = a.call(this, c) || this;
    return _._tapNext = noop$6, _._tapError = noop$6, _._tapComplete = noop$6, _._tapError = v || noop$6, _._tapComplete = p || noop$6, isFunction$3(l) ? (_._context = _, _._tapNext = l) : l && (_._context = l, _._tapNext = l.next || noop$6, _._tapError = l.error || noop$6, _._tapComplete = l.complete || noop$6), _;
  }
  return u.prototype._next = function(c) {
    try {
      this._tapNext.call(this._context, c);
    } catch (l) {
      this.destination.error(l);
      return;
    }
    this.destination.next(c);
  }, u.prototype._error = function(c) {
    try {
      this._tapError.call(this._context, c);
    } catch (l) {
      this.destination.error(l);
      return;
    }
    this.destination.error(c);
  }, u.prototype._complete = function() {
    try {
      this._tapComplete.call(this._context);
    } catch (c) {
      this.destination.error(c);
      return;
    }
    return this.destination.complete();
  }, u;
}(Subscriber), defaultThrottleConfig = {
  leading: !0,
  trailing: !1
};
function throttle(a, u) {
  return u === void 0 && (u = defaultThrottleConfig), function(c) {
    return c.lift(new ThrottleOperator(a, !!u.leading, !!u.trailing));
  };
}
var ThrottleOperator = /* @__PURE__ */ function() {
  function a(u, c, l) {
    this.durationSelector = u, this.leading = c, this.trailing = l;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new ThrottleSubscriber(u, this.durationSelector, this.leading, this.trailing));
  }, a;
}(), ThrottleSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v, p) {
    var _ = a.call(this, c) || this;
    return _.destination = c, _.durationSelector = l, _._leading = v, _._trailing = p, _._hasValue = !1, _;
  }
  return u.prototype._next = function(c) {
    this._hasValue = !0, this._sendValue = c, this._throttled || (this._leading ? this.send() : this.throttle(c));
  }, u.prototype.send = function() {
    var c = this, l = c._hasValue, v = c._sendValue;
    l && (this.destination.next(v), this.throttle(v)), this._hasValue = !1, this._sendValue = void 0;
  }, u.prototype.throttle = function(c) {
    var l = this.tryDurationSelector(c);
    l && this.add(this._throttled = innerSubscribe(l, new SimpleInnerSubscriber(this)));
  }, u.prototype.tryDurationSelector = function(c) {
    try {
      return this.durationSelector(c);
    } catch (l) {
      return this.destination.error(l), null;
    }
  }, u.prototype.throttlingDone = function() {
    var c = this, l = c._throttled, v = c._trailing;
    l && l.unsubscribe(), this._throttled = void 0, v && this.send();
  }, u.prototype.notifyNext = function() {
    this.throttlingDone();
  }, u.prototype.notifyComplete = function() {
    this.throttlingDone();
  }, u;
}(SimpleOuterSubscriber);
function throttleTime(a, u, c) {
  return u === void 0 && (u = async$1), c === void 0 && (c = defaultThrottleConfig), function(l) {
    return l.lift(new ThrottleTimeOperator(a, u, c.leading, c.trailing));
  };
}
var ThrottleTimeOperator = /* @__PURE__ */ function() {
  function a(u, c, l, v) {
    this.duration = u, this.scheduler = c, this.leading = l, this.trailing = v;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new ThrottleTimeSubscriber(u, this.duration, this.scheduler, this.leading, this.trailing));
  }, a;
}(), ThrottleTimeSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v, p, _) {
    var k = a.call(this, c) || this;
    return k.duration = l, k.scheduler = v, k.leading = p, k.trailing = _, k._hasTrailingValue = !1, k._trailingValue = null, k;
  }
  return u.prototype._next = function(c) {
    this.throttled ? this.trailing && (this._trailingValue = c, this._hasTrailingValue = !0) : (this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, { subscriber: this })), this.leading ? this.destination.next(c) : this.trailing && (this._trailingValue = c, this._hasTrailingValue = !0));
  }, u.prototype._complete = function() {
    this._hasTrailingValue ? (this.destination.next(this._trailingValue), this.destination.complete()) : this.destination.complete();
  }, u.prototype.clearThrottle = function() {
    var c = this.throttled;
    c && (this.trailing && this._hasTrailingValue && (this.destination.next(this._trailingValue), this._trailingValue = null, this._hasTrailingValue = !1), c.unsubscribe(), this.remove(c), this.throttled = null);
  }, u;
}(Subscriber);
function dispatchNext(a) {
  var u = a.subscriber;
  u.clearThrottle();
}
function defer(a) {
  return new Observable(function(u) {
    var c;
    try {
      c = a();
    } catch (v) {
      u.error(v);
      return;
    }
    var l = c ? from(c) : empty$2();
    return l.subscribe(u);
  });
}
function timeInterval(a) {
  return a === void 0 && (a = async$1), function(u) {
    return defer(function() {
      return u.pipe(scan(function(c, l) {
        var v = c.current;
        return { value: l, current: a.now(), last: v };
      }, { current: a.now(), value: void 0, last: void 0 }), map(function(c) {
        var l = c.current, v = c.last, p = c.value;
        return new TimeInterval(p, l - v);
      }));
    });
  };
}
var TimeInterval = /* @__PURE__ */ function() {
  function a(u, c) {
    this.value = u, this.interval = c;
  }
  return a;
}(), TimeoutErrorImpl = /* @__PURE__ */ function() {
  function a() {
    return Error.call(this), this.message = "Timeout has occurred", this.name = "TimeoutError", this;
  }
  return a.prototype = /* @__PURE__ */ Object.create(Error.prototype), a;
}(), TimeoutError = TimeoutErrorImpl;
function timeoutWith(a, u, c) {
  return c === void 0 && (c = async$1), function(l) {
    var v = isDate$1(a), p = v ? +a - c.now() : Math.abs(a);
    return l.lift(new TimeoutWithOperator(p, v, u, c));
  };
}
var TimeoutWithOperator = /* @__PURE__ */ function() {
  function a(u, c, l, v) {
    this.waitFor = u, this.absoluteTimeout = c, this.withObservable = l, this.scheduler = v;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new TimeoutWithSubscriber(u, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));
  }, a;
}(), TimeoutWithSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v, p, _) {
    var k = a.call(this, c) || this;
    return k.absoluteTimeout = l, k.waitFor = v, k.withObservable = p, k.scheduler = _, k.scheduleTimeout(), k;
  }
  return u.dispatchTimeout = function(c) {
    var l = c.withObservable;
    c._unsubscribeAndRecycle(), c.add(innerSubscribe(l, new SimpleInnerSubscriber(c)));
  }, u.prototype.scheduleTimeout = function() {
    var c = this.action;
    c ? this.action = c.schedule(this, this.waitFor) : this.add(this.action = this.scheduler.schedule(u.dispatchTimeout, this.waitFor, this));
  }, u.prototype._next = function(c) {
    this.absoluteTimeout || this.scheduleTimeout(), a.prototype._next.call(this, c);
  }, u.prototype._unsubscribe = function() {
    this.action = void 0, this.scheduler = null, this.withObservable = null;
  }, u;
}(SimpleOuterSubscriber);
function timeout(a, u) {
  return u === void 0 && (u = async$1), timeoutWith(a, throwError(new TimeoutError()), u);
}
function timestamp$2(a) {
  return a === void 0 && (a = async$1), map(function(u) {
    return new Timestamp$1(u, a.now());
  });
}
var Timestamp$1 = /* @__PURE__ */ function() {
  function a(u, c) {
    this.value = u, this.timestamp = c;
  }
  return a;
}();
function toArrayReducer(a, u, c) {
  return c === 0 ? [u] : (a.push(u), a);
}
function toArray$2() {
  return reduce(toArrayReducer, []);
}
function window$1(a) {
  return function(c) {
    return c.lift(new WindowOperator$1(a));
  };
}
var WindowOperator$1 = /* @__PURE__ */ function() {
  function a(u) {
    this.windowBoundaries = u;
  }
  return a.prototype.call = function(u, c) {
    var l = new WindowSubscriber$1(u), v = c.subscribe(l);
    return v.closed || l.add(innerSubscribe(this.windowBoundaries, new SimpleInnerSubscriber(l))), v;
  }, a;
}(), WindowSubscriber$1 = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c) {
    var l = a.call(this, c) || this;
    return l.window = new Subject(), c.next(l.window), l;
  }
  return u.prototype.notifyNext = function() {
    this.openWindow();
  }, u.prototype.notifyError = function(c) {
    this._error(c);
  }, u.prototype.notifyComplete = function() {
    this._complete();
  }, u.prototype._next = function(c) {
    this.window.next(c);
  }, u.prototype._error = function(c) {
    this.window.error(c), this.destination.error(c);
  }, u.prototype._complete = function() {
    this.window.complete(), this.destination.complete();
  }, u.prototype._unsubscribe = function() {
    this.window = null;
  }, u.prototype.openWindow = function() {
    var c = this.window;
    c && c.complete();
    var l = this.destination, v = this.window = new Subject();
    l.next(v);
  }, u;
}(SimpleOuterSubscriber);
function windowCount(a, u) {
  return u === void 0 && (u = 0), function(l) {
    return l.lift(new WindowCountOperator(a, u));
  };
}
var WindowCountOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.windowSize = u, this.startWindowEvery = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new WindowCountSubscriber(u, this.windowSize, this.startWindowEvery));
  }, a;
}(), WindowCountSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.destination = c, p.windowSize = l, p.startWindowEvery = v, p.windows = [new Subject()], p.count = 0, c.next(p.windows[0]), p;
  }
  return u.prototype._next = function(c) {
    for (var l = this.startWindowEvery > 0 ? this.startWindowEvery : this.windowSize, v = this.destination, p = this.windowSize, _ = this.windows, k = _.length, M = 0; M < k && !this.closed; M++)
      _[M].next(c);
    var L = this.count - p + 1;
    if (L >= 0 && L % l === 0 && !this.closed && _.shift().complete(), ++this.count % l === 0 && !this.closed) {
      var F = new Subject();
      _.push(F), v.next(F);
    }
  }, u.prototype._error = function(c) {
    var l = this.windows;
    if (l)
      for (; l.length > 0 && !this.closed; )
        l.shift().error(c);
    this.destination.error(c);
  }, u.prototype._complete = function() {
    var c = this.windows;
    if (c)
      for (; c.length > 0 && !this.closed; )
        c.shift().complete();
    this.destination.complete();
  }, u.prototype._unsubscribe = function() {
    this.count = 0, this.windows = null;
  }, u;
}(Subscriber);
function windowTime(a) {
  var u = async$1, c = null, l = Number.POSITIVE_INFINITY;
  return isScheduler(arguments[3]) && (u = arguments[3]), isScheduler(arguments[2]) ? u = arguments[2] : isNumeric(arguments[2]) && (l = Number(arguments[2])), isScheduler(arguments[1]) ? u = arguments[1] : isNumeric(arguments[1]) && (c = Number(arguments[1])), function(p) {
    return p.lift(new WindowTimeOperator(a, c, l, u));
  };
}
var WindowTimeOperator = /* @__PURE__ */ function() {
  function a(u, c, l, v) {
    this.windowTimeSpan = u, this.windowCreationInterval = c, this.maxWindowSize = l, this.scheduler = v;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new WindowTimeSubscriber(u, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));
  }, a;
}(), CountedSubject = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u() {
    var c = a !== null && a.apply(this, arguments) || this;
    return c._numberOfNextedValues = 0, c;
  }
  return u.prototype.next = function(c) {
    this._numberOfNextedValues++, a.prototype.next.call(this, c);
  }, Object.defineProperty(u.prototype, "numberOfNextedValues", {
    get: function() {
      return this._numberOfNextedValues;
    },
    enumerable: !0,
    configurable: !0
  }), u;
}(Subject), WindowTimeSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v, p, _) {
    var k = a.call(this, c) || this;
    k.destination = c, k.windowTimeSpan = l, k.windowCreationInterval = v, k.maxWindowSize = p, k.scheduler = _, k.windows = [];
    var M = k.openWindow();
    if (v !== null && v >= 0) {
      var L = { subscriber: k, window: M, context: null }, F = { windowTimeSpan: l, windowCreationInterval: v, subscriber: k, scheduler: _ };
      k.add(_.schedule(dispatchWindowClose, l, L)), k.add(_.schedule(dispatchWindowCreation, v, F));
    } else {
      var V = { subscriber: k, window: M, windowTimeSpan: l };
      k.add(_.schedule(dispatchWindowTimeSpanOnly, l, V));
    }
    return k;
  }
  return u.prototype._next = function(c) {
    for (var l = this.windows, v = l.length, p = 0; p < v; p++) {
      var _ = l[p];
      _.closed || (_.next(c), _.numberOfNextedValues >= this.maxWindowSize && this.closeWindow(_));
    }
  }, u.prototype._error = function(c) {
    for (var l = this.windows; l.length > 0; )
      l.shift().error(c);
    this.destination.error(c);
  }, u.prototype._complete = function() {
    for (var c = this.windows; c.length > 0; ) {
      var l = c.shift();
      l.closed || l.complete();
    }
    this.destination.complete();
  }, u.prototype.openWindow = function() {
    var c = new CountedSubject();
    this.windows.push(c);
    var l = this.destination;
    return l.next(c), c;
  }, u.prototype.closeWindow = function(c) {
    c.complete();
    var l = this.windows;
    l.splice(l.indexOf(c), 1);
  }, u;
}(Subscriber);
function dispatchWindowTimeSpanOnly(a) {
  var u = a.subscriber, c = a.windowTimeSpan, l = a.window;
  l && u.closeWindow(l), a.window = u.openWindow(), this.schedule(a, c);
}
function dispatchWindowCreation(a) {
  var u = a.windowTimeSpan, c = a.subscriber, l = a.scheduler, v = a.windowCreationInterval, p = c.openWindow(), _ = this, k = { action: _, subscription: null }, M = { subscriber: c, window: p, context: k };
  k.subscription = l.schedule(dispatchWindowClose, u, M), _.add(k.subscription), _.schedule(a, v);
}
function dispatchWindowClose(a) {
  var u = a.subscriber, c = a.window, l = a.context;
  l && l.action && l.subscription && l.action.remove(l.subscription), u.closeWindow(c);
}
function windowToggle(a, u) {
  return function(c) {
    return c.lift(new WindowToggleOperator(a, u));
  };
}
var WindowToggleOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.openings = u, this.closingSelector = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new WindowToggleSubscriber(u, this.openings, this.closingSelector));
  }, a;
}(), WindowToggleSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.openings = l, p.closingSelector = v, p.contexts = [], p.add(p.openSubscription = subscribeToResult(p, l, l)), p;
  }
  return u.prototype._next = function(c) {
    var l = this.contexts;
    if (l)
      for (var v = l.length, p = 0; p < v; p++)
        l[p].window.next(c);
  }, u.prototype._error = function(c) {
    var l = this.contexts;
    if (this.contexts = null, l)
      for (var v = l.length, p = -1; ++p < v; ) {
        var _ = l[p];
        _.window.error(c), _.subscription.unsubscribe();
      }
    a.prototype._error.call(this, c);
  }, u.prototype._complete = function() {
    var c = this.contexts;
    if (this.contexts = null, c)
      for (var l = c.length, v = -1; ++v < l; ) {
        var p = c[v];
        p.window.complete(), p.subscription.unsubscribe();
      }
    a.prototype._complete.call(this);
  }, u.prototype._unsubscribe = function() {
    var c = this.contexts;
    if (this.contexts = null, c)
      for (var l = c.length, v = -1; ++v < l; ) {
        var p = c[v];
        p.window.unsubscribe(), p.subscription.unsubscribe();
      }
  }, u.prototype.notifyNext = function(c, l, v, p, _) {
    if (c === this.openings) {
      var k = void 0;
      try {
        var M = this.closingSelector;
        k = M(l);
      } catch (oe) {
        return this.error(oe);
      }
      var L = new Subject(), F = new Subscription(), V = { window: L, subscription: F };
      this.contexts.push(V);
      var X = subscribeToResult(this, k, V);
      X.closed ? this.closeWindow(this.contexts.length - 1) : (X.context = V, F.add(X)), this.destination.next(L);
    } else
      this.closeWindow(this.contexts.indexOf(c));
  }, u.prototype.notifyError = function(c) {
    this.error(c);
  }, u.prototype.notifyComplete = function(c) {
    c !== this.openSubscription && this.closeWindow(this.contexts.indexOf(c.context));
  }, u.prototype.closeWindow = function(c) {
    if (c !== -1) {
      var l = this.contexts, v = l[c], p = v.window, _ = v.subscription;
      l.splice(c, 1), p.complete(), _.unsubscribe();
    }
  }, u;
}(OuterSubscriber);
function windowWhen(a) {
  return function(c) {
    return c.lift(new WindowOperator(a));
  };
}
var WindowOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.closingSelector = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new WindowSubscriber(u, this.closingSelector));
  }, a;
}(), WindowSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.destination = c, v.closingSelector = l, v.openWindow(), v;
  }
  return u.prototype.notifyNext = function(c, l, v, p, _) {
    this.openWindow(_);
  }, u.prototype.notifyError = function(c) {
    this._error(c);
  }, u.prototype.notifyComplete = function(c) {
    this.openWindow(c);
  }, u.prototype._next = function(c) {
    this.window.next(c);
  }, u.prototype._error = function(c) {
    this.window.error(c), this.destination.error(c), this.unsubscribeClosingNotification();
  }, u.prototype._complete = function() {
    this.window.complete(), this.destination.complete(), this.unsubscribeClosingNotification();
  }, u.prototype.unsubscribeClosingNotification = function() {
    this.closingNotification && this.closingNotification.unsubscribe();
  }, u.prototype.openWindow = function(c) {
    c === void 0 && (c = null), c && (this.remove(c), c.unsubscribe());
    var l = this.window;
    l && l.complete();
    var v = this.window = new Subject();
    this.destination.next(v);
    var p;
    try {
      var _ = this.closingSelector;
      p = _();
    } catch (k) {
      this.destination.error(k), this.window.error(k);
      return;
    }
    this.add(this.closingNotification = subscribeToResult(this, p));
  }, u;
}(OuterSubscriber);
function withLatestFrom() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  return function(c) {
    var l;
    typeof a[a.length - 1] == "function" && (l = a.pop());
    var v = a;
    return c.lift(new WithLatestFromOperator(v, l));
  };
}
var WithLatestFromOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.observables = u, this.project = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new WithLatestFromSubscriber(u, this.observables, this.project));
  }, a;
}(), WithLatestFromSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    p.observables = l, p.project = v, p.toRespond = [];
    var _ = l.length;
    p.values = new Array(_);
    for (var k = 0; k < _; k++)
      p.toRespond.push(k);
    for (var k = 0; k < _; k++) {
      var M = l[k];
      p.add(subscribeToResult(p, M, void 0, k));
    }
    return p;
  }
  return u.prototype.notifyNext = function(c, l, v) {
    this.values[v] = l;
    var p = this.toRespond;
    if (p.length > 0) {
      var _ = p.indexOf(v);
      _ !== -1 && p.splice(_, 1);
    }
  }, u.prototype.notifyComplete = function() {
  }, u.prototype._next = function(c) {
    if (this.toRespond.length === 0) {
      var l = [c].concat(this.values);
      this.project ? this._tryProject(l) : this.destination.next(l);
    }
  }, u.prototype._tryProject = function(c) {
    var l;
    try {
      l = this.project.apply(this, c);
    } catch (v) {
      this.destination.error(v);
      return;
    }
    this.destination.next(l);
  }, u;
}(OuterSubscriber);
function zip$1() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  var c = a[a.length - 1];
  return typeof c == "function" && a.pop(), fromArray$1(a, void 0).lift(new ZipOperator(c));
}
var ZipOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.resultSelector = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new ZipSubscriber(u, this.resultSelector));
  }, a;
}(), ZipSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.resultSelector = l, p.iterators = [], p.active = 0, p.resultSelector = typeof l == "function" ? l : void 0, p;
  }
  return u.prototype._next = function(c) {
    var l = this.iterators;
    isArray$5(c) ? l.push(new StaticArrayIterator(c)) : typeof c[iterator] == "function" ? l.push(new StaticIterator(c[iterator]())) : l.push(new ZipBufferIterator(this.destination, this, c));
  }, u.prototype._complete = function() {
    var c = this.iterators, l = c.length;
    if (this.unsubscribe(), l === 0) {
      this.destination.complete();
      return;
    }
    this.active = l;
    for (var v = 0; v < l; v++) {
      var p = c[v];
      if (p.stillUnsubscribed) {
        var _ = this.destination;
        _.add(p.subscribe());
      } else
        this.active--;
    }
  }, u.prototype.notifyInactive = function() {
    this.active--, this.active === 0 && this.destination.complete();
  }, u.prototype.checkIterators = function() {
    for (var c = this.iterators, l = c.length, v = this.destination, p = 0; p < l; p++) {
      var _ = c[p];
      if (typeof _.hasValue == "function" && !_.hasValue())
        return;
    }
    for (var k = !1, M = [], p = 0; p < l; p++) {
      var _ = c[p], L = _.next();
      if (_.hasCompleted() && (k = !0), L.done) {
        v.complete();
        return;
      }
      M.push(L.value);
    }
    this.resultSelector ? this._tryresultSelector(M) : v.next(M), k && v.complete();
  }, u.prototype._tryresultSelector = function(c) {
    var l;
    try {
      l = this.resultSelector.apply(this, c);
    } catch (v) {
      this.destination.error(v);
      return;
    }
    this.destination.next(l);
  }, u;
}(Subscriber), StaticIterator = /* @__PURE__ */ function() {
  function a(u) {
    this.iterator = u, this.nextResult = u.next();
  }
  return a.prototype.hasValue = function() {
    return !0;
  }, a.prototype.next = function() {
    var u = this.nextResult;
    return this.nextResult = this.iterator.next(), u;
  }, a.prototype.hasCompleted = function() {
    var u = this.nextResult;
    return !!(u && u.done);
  }, a;
}(), StaticArrayIterator = /* @__PURE__ */ function() {
  function a(u) {
    this.array = u, this.index = 0, this.length = 0, this.length = u.length;
  }
  return a.prototype[iterator] = function() {
    return this;
  }, a.prototype.next = function(u) {
    var c = this.index++, l = this.array;
    return c < this.length ? { value: l[c], done: !1 } : { value: null, done: !0 };
  }, a.prototype.hasValue = function() {
    return this.array.length > this.index;
  }, a.prototype.hasCompleted = function() {
    return this.array.length === this.index;
  }, a;
}(), ZipBufferIterator = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.parent = l, p.observable = v, p.stillUnsubscribed = !0, p.buffer = [], p.isComplete = !1, p;
  }
  return u.prototype[iterator] = function() {
    return this;
  }, u.prototype.next = function() {
    var c = this.buffer;
    return c.length === 0 && this.isComplete ? { value: null, done: !0 } : { value: c.shift(), done: !1 };
  }, u.prototype.hasValue = function() {
    return this.buffer.length > 0;
  }, u.prototype.hasCompleted = function() {
    return this.buffer.length === 0 && this.isComplete;
  }, u.prototype.notifyComplete = function() {
    this.buffer.length > 0 ? (this.isComplete = !0, this.parent.notifyInactive()) : this.destination.complete();
  }, u.prototype.notifyNext = function(c) {
    this.buffer.push(c), this.parent.checkIterators();
  }, u.prototype.subscribe = function() {
    return innerSubscribe(this.observable, new SimpleInnerSubscriber(this));
  }, u;
}(SimpleOuterSubscriber);
function zip() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  return function(l) {
    return l.lift.call(zip$1.apply(void 0, [l].concat(a)));
  };
}
function zipAll(a) {
  return function(u) {
    return u.lift(new ZipOperator(a));
  };
}
const operators = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  audit,
  auditTime,
  buffer: buffer$2,
  bufferCount,
  bufferTime,
  bufferToggle,
  bufferWhen,
  catchError,
  combineAll,
  combineLatest,
  concat,
  concatAll,
  concatMap,
  concatMapTo,
  count,
  debounce: debounce$1,
  debounceTime,
  defaultIfEmpty,
  delay,
  delayWhen,
  dematerialize,
  distinct,
  distinctUntilChanged,
  distinctUntilKeyChanged,
  elementAt,
  endWith,
  every: every$1,
  exhaust,
  exhaustMap,
  expand,
  filter,
  finalize,
  find: find$2,
  findIndex,
  first,
  flatMap,
  groupBy,
  ignoreElements,
  isEmpty,
  last: last$1,
  map,
  mapTo,
  materialize,
  max: max$1,
  merge: merge$1,
  mergeAll,
  mergeMap,
  mergeMapTo,
  mergeScan,
  min,
  multicast,
  observeOn,
  onErrorResumeNext,
  pairwise,
  partition,
  pluck,
  publish,
  publishBehavior,
  publishLast,
  publishReplay,
  race,
  reduce,
  refCount,
  repeat,
  repeatWhen,
  retry,
  retryWhen,
  sample,
  sampleTime,
  scan,
  sequenceEqual,
  share,
  shareReplay,
  single,
  skip,
  skipLast,
  skipUntil,
  skipWhile,
  startWith,
  subscribeOn,
  switchAll,
  switchMap,
  switchMapTo,
  take,
  takeLast,
  takeUntil,
  takeWhile,
  tap,
  throttle,
  throttleTime,
  throwIfEmpty,
  timeInterval,
  timeout,
  timeoutWith,
  timestamp: timestamp$2,
  toArray: toArray$2,
  window: window$1,
  windowCount,
  windowTime,
  windowToggle,
  windowWhen,
  withLatestFrom,
  zip,
  zipAll
}, Symbol.toStringTag, { value: "Module" })), require$$1$2 = /* @__PURE__ */ getAugmentedNamespace(operators);
var struct = {};
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(Y) {
    return Y && Y.__esModule ? Y : { default: Y };
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.ListValue = a.Value = a.Struct_FieldsEntry = a.Struct = a.nullValueToNumber = a.nullValueToJSON = a.nullValueFromJSON = a.NullValue = a.protobufPackage = void 0;
  const c = u(minimal);
  a.protobufPackage = "google.protobuf";
  var l;
  (function(Y) {
    Y.NULL_VALUE = "NULL_VALUE";
  })(l = a.NullValue || (a.NullValue = {}));
  function v(Y) {
    switch (Y) {
      case 0:
      case "NULL_VALUE":
        return l.NULL_VALUE;
      default:
        throw new V.Error("Unrecognized enum value " + Y + " for enum NullValue");
    }
  }
  a.nullValueFromJSON = v;
  function p(Y) {
    switch (Y) {
      case l.NULL_VALUE:
        return "NULL_VALUE";
      default:
        throw new V.Error("Unrecognized enum value " + Y + " for enum NullValue");
    }
  }
  a.nullValueToJSON = p;
  function _(Y) {
    switch (Y) {
      case l.NULL_VALUE:
        return 0;
      default:
        throw new V.Error("Unrecognized enum value " + Y + " for enum NullValue");
    }
  }
  a.nullValueToNumber = _;
  function k() {
    return { fields: {} };
  }
  a.Struct = {
    encode(Y, ae = c.default.Writer.create()) {
      return Object.entries(Y.fields).forEach(([ne, fe]) => {
        fe !== void 0 && a.Struct_FieldsEntry.encode({ key: ne, value: fe }, ae.uint32(10).fork()).ldelim();
      }), ae;
    },
    decode(Y, ae) {
      const ne = Y instanceof c.default.Reader ? Y : new c.default.Reader(Y);
      let fe = ae === void 0 ? ne.len : ne.pos + ae;
      const ie = k();
      for (; ne.pos < fe; ) {
        const ge = ne.uint32();
        switch (ge >>> 3) {
          case 1:
            const be = a.Struct_FieldsEntry.decode(ne, ne.uint32());
            be.value !== void 0 && (ie.fields[be.key] = be.value);
            break;
          default:
            ne.skipType(ge & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(Y) {
      return {
        fields: X(Y.fields) ? Object.entries(Y.fields).reduce((ae, [ne, fe]) => (ae[ne] = fe, ae), {}) : {}
      };
    },
    toJSON(Y) {
      const ae = {};
      return ae.fields = {}, Y.fields && Object.entries(Y.fields).forEach(([ne, fe]) => {
        ae.fields[ne] = fe;
      }), ae;
    },
    fromPartial(Y) {
      var ae;
      const ne = k();
      return ne.fields = Object.entries((ae = Y.fields) !== null && ae !== void 0 ? ae : {}).reduce((fe, [ie, ge]) => (ge !== void 0 && (fe[ie] = ge), fe), {}), ne;
    },
    wrap(Y) {
      const ae = k();
      return Y !== void 0 && Object.keys(Y).forEach((ne) => {
        ae.fields[ne] = Y[ne];
      }), ae;
    },
    unwrap(Y) {
      const ae = {};
      return Object.keys(Y.fields).forEach((ne) => {
        ae[ne] = Y.fields[ne];
      }), ae;
    }
  };
  function M() {
    return { key: "", value: void 0 };
  }
  a.Struct_FieldsEntry = {
    encode(Y, ae = c.default.Writer.create()) {
      return Y.key !== "" && ae.uint32(10).string(Y.key), Y.value !== void 0 && a.Value.encode(a.Value.wrap(Y.value), ae.uint32(18).fork()).ldelim(), ae;
    },
    decode(Y, ae) {
      const ne = Y instanceof c.default.Reader ? Y : new c.default.Reader(Y);
      let fe = ae === void 0 ? ne.len : ne.pos + ae;
      const ie = M();
      for (; ne.pos < fe; ) {
        const ge = ne.uint32();
        switch (ge >>> 3) {
          case 1:
            ie.key = ne.string();
            break;
          case 2:
            ie.value = a.Value.unwrap(a.Value.decode(ne, ne.uint32()));
            break;
          default:
            ne.skipType(ge & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(Y) {
      return { key: oe(Y.key) ? String(Y.key) : "", value: oe(Y == null ? void 0 : Y.value) ? Y.value : void 0 };
    },
    toJSON(Y) {
      const ae = {};
      return Y.key !== void 0 && (ae.key = Y.key), Y.value !== void 0 && (ae.value = Y.value), ae;
    },
    fromPartial(Y) {
      var ae, ne;
      const fe = M();
      return fe.key = (ae = Y.key) !== null && ae !== void 0 ? ae : "", fe.value = (ne = Y.value) !== null && ne !== void 0 ? ne : void 0, fe;
    }
  };
  function L() {
    return {
      nullValue: void 0,
      numberValue: void 0,
      stringValue: void 0,
      boolValue: void 0,
      structValue: void 0,
      listValue: void 0
    };
  }
  a.Value = {
    encode(Y, ae = c.default.Writer.create()) {
      return Y.nullValue !== void 0 && ae.uint32(8).int32(_(Y.nullValue)), Y.numberValue !== void 0 && ae.uint32(17).double(Y.numberValue), Y.stringValue !== void 0 && ae.uint32(26).string(Y.stringValue), Y.boolValue !== void 0 && ae.uint32(32).bool(Y.boolValue), Y.structValue !== void 0 && a.Struct.encode(a.Struct.wrap(Y.structValue), ae.uint32(42).fork()).ldelim(), Y.listValue !== void 0 && a.ListValue.encode(a.ListValue.wrap(Y.listValue), ae.uint32(50).fork()).ldelim(), ae;
    },
    decode(Y, ae) {
      const ne = Y instanceof c.default.Reader ? Y : new c.default.Reader(Y);
      let fe = ae === void 0 ? ne.len : ne.pos + ae;
      const ie = L();
      for (; ne.pos < fe; ) {
        const ge = ne.uint32();
        switch (ge >>> 3) {
          case 1:
            ie.nullValue = v(ne.int32());
            break;
          case 2:
            ie.numberValue = ne.double();
            break;
          case 3:
            ie.stringValue = ne.string();
            break;
          case 4:
            ie.boolValue = ne.bool();
            break;
          case 5:
            ie.structValue = a.Struct.unwrap(a.Struct.decode(ne, ne.uint32()));
            break;
          case 6:
            ie.listValue = a.ListValue.unwrap(a.ListValue.decode(ne, ne.uint32()));
            break;
          default:
            ne.skipType(ge & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(Y) {
      return {
        nullValue: oe(Y.nullValue) ? v(Y.nullValue) : void 0,
        numberValue: oe(Y.numberValue) ? Number(Y.numberValue) : void 0,
        stringValue: oe(Y.stringValue) ? String(Y.stringValue) : void 0,
        boolValue: oe(Y.boolValue) ? !!Y.boolValue : void 0,
        structValue: X(Y.structValue) ? Y.structValue : void 0,
        listValue: Array.isArray(Y.listValue) ? [...Y.listValue] : void 0
      };
    },
    toJSON(Y) {
      const ae = {};
      return Y.nullValue !== void 0 && (ae.nullValue = Y.nullValue !== void 0 ? p(Y.nullValue) : void 0), Y.numberValue !== void 0 && (ae.numberValue = Y.numberValue), Y.stringValue !== void 0 && (ae.stringValue = Y.stringValue), Y.boolValue !== void 0 && (ae.boolValue = Y.boolValue), Y.structValue !== void 0 && (ae.structValue = Y.structValue), Y.listValue !== void 0 && (ae.listValue = Y.listValue), ae;
    },
    fromPartial(Y) {
      var ae, ne, fe, ie, ge, be;
      const Ce = L();
      return Ce.nullValue = (ae = Y.nullValue) !== null && ae !== void 0 ? ae : void 0, Ce.numberValue = (ne = Y.numberValue) !== null && ne !== void 0 ? ne : void 0, Ce.stringValue = (fe = Y.stringValue) !== null && fe !== void 0 ? fe : void 0, Ce.boolValue = (ie = Y.boolValue) !== null && ie !== void 0 ? ie : void 0, Ce.structValue = (ge = Y.structValue) !== null && ge !== void 0 ? ge : void 0, Ce.listValue = (be = Y.listValue) !== null && be !== void 0 ? be : void 0, Ce;
    },
    wrap(Y) {
      const ae = L();
      if (Y === null)
        ae.nullValue = l.NULL_VALUE;
      else if (typeof Y == "boolean")
        ae.boolValue = Y;
      else if (typeof Y == "number")
        ae.numberValue = Y;
      else if (typeof Y == "string")
        ae.stringValue = Y;
      else if (Array.isArray(Y))
        ae.listValue = Y;
      else if (typeof Y == "object")
        ae.structValue = Y;
      else if (typeof Y < "u")
        throw new Error("Unsupported any value type: " + typeof Y);
      return ae;
    },
    unwrap(Y) {
      if ((Y == null ? void 0 : Y.stringValue) !== void 0)
        return Y.stringValue;
      if ((Y == null ? void 0 : Y.numberValue) !== void 0)
        return Y.numberValue;
      if ((Y == null ? void 0 : Y.boolValue) !== void 0)
        return Y.boolValue;
      if ((Y == null ? void 0 : Y.structValue) !== void 0)
        return Y.structValue;
      if ((Y == null ? void 0 : Y.listValue) !== void 0)
        return Y.listValue;
      if ((Y == null ? void 0 : Y.nullValue) !== void 0)
        return null;
    }
  };
  function F() {
    return { values: [] };
  }
  a.ListValue = {
    encode(Y, ae = c.default.Writer.create()) {
      for (const ne of Y.values)
        a.Value.encode(a.Value.wrap(ne), ae.uint32(10).fork()).ldelim();
      return ae;
    },
    decode(Y, ae) {
      const ne = Y instanceof c.default.Reader ? Y : new c.default.Reader(Y);
      let fe = ae === void 0 ? ne.len : ne.pos + ae;
      const ie = F();
      for (; ne.pos < fe; ) {
        const ge = ne.uint32();
        switch (ge >>> 3) {
          case 1:
            ie.values.push(a.Value.unwrap(a.Value.decode(ne, ne.uint32())));
            break;
          default:
            ne.skipType(ge & 7);
            break;
        }
      }
      return ie;
    },
    fromJSON(Y) {
      return { values: Array.isArray(Y == null ? void 0 : Y.values) ? [...Y.values] : [] };
    },
    toJSON(Y) {
      const ae = {};
      return Y.values ? ae.values = Y.values.map((ne) => ne) : ae.values = [], ae;
    },
    fromPartial(Y) {
      var ae;
      const ne = F();
      return ne.values = ((ae = Y.values) === null || ae === void 0 ? void 0 : ae.map((fe) => fe)) || [], ne;
    },
    wrap(Y) {
      const ae = F();
      return ae.values = Y ?? [], ae;
    },
    unwrap(Y) {
      return Y.values;
    }
  };
  var V = (() => {
    if (typeof globalThis < "u")
      return globalThis;
    if (typeof self < "u")
      return self;
    if (typeof window < "u")
      return window;
    if (typeof commonjsGlobal$1 < "u")
      return commonjsGlobal$1;
    throw "Unable to locate global object";
  })();
  function X(Y) {
    return typeof Y == "object" && Y !== null;
  }
  function oe(Y) {
    return Y != null;
  }
})(struct);
var timestamp$1 = {}, __importDefault$9 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(timestamp$1, "__esModule", { value: !0 });
timestamp$1.Timestamp = timestamp$1.protobufPackage = void 0;
const long_1$2 = __importDefault$9(umdExports), minimal_1$2 = __importDefault$9(minimal);
timestamp$1.protobufPackage = "google.protobuf";
function createBaseTimestamp$1() {
  return { seconds: 0, nanos: 0 };
}
timestamp$1.Timestamp = {
  encode(a, u = minimal_1$2.default.Writer.create()) {
    return a.seconds !== 0 && u.uint32(8).int64(a.seconds), a.nanos !== 0 && u.uint32(16).int32(a.nanos), u;
  },
  decode(a, u) {
    const c = a instanceof minimal_1$2.default.Reader ? a : new minimal_1$2.default.Reader(a);
    let l = u === void 0 ? c.len : c.pos + u;
    const v = createBaseTimestamp$1();
    for (; c.pos < l; ) {
      const p = c.uint32();
      switch (p >>> 3) {
        case 1:
          v.seconds = longToNumber$2(c.int64());
          break;
        case 2:
          v.nanos = c.int32();
          break;
        default:
          c.skipType(p & 7);
          break;
      }
    }
    return v;
  },
  fromJSON(a) {
    return {
      seconds: isSet$3(a.seconds) ? Number(a.seconds) : 0,
      nanos: isSet$3(a.nanos) ? Number(a.nanos) : 0
    };
  },
  toJSON(a) {
    const u = {};
    return a.seconds !== void 0 && (u.seconds = Math.round(a.seconds)), a.nanos !== void 0 && (u.nanos = Math.round(a.nanos)), u;
  },
  fromPartial(a) {
    var u, c;
    const l = createBaseTimestamp$1();
    return l.seconds = (u = a.seconds) !== null && u !== void 0 ? u : 0, l.nanos = (c = a.nanos) !== null && c !== void 0 ? c : 0, l;
  }
};
var tsProtoGlobalThis = (() => {
  if (typeof globalThis < "u")
    return globalThis;
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof commonjsGlobal$1 < "u")
    return commonjsGlobal$1;
  throw "Unable to locate global object";
})();
function longToNumber$2(a) {
  if (a.gt(Number.MAX_SAFE_INTEGER))
    throw new tsProtoGlobalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  return a.toNumber();
}
minimal_1$2.default.util.Long !== long_1$2.default && (minimal_1$2.default.util.Long = long_1$2.default, minimal_1$2.default.configure());
function isSet$3(a) {
  return a != null;
}
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(Q) {
    return Q && Q.__esModule ? Q : { default: Q };
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.HistoryServiceDefinition = a.HistoryServiceClientImpl = a.WebhookServiceDefinition = a.WebhookServiceClientImpl = a.EventServiceDefinition = a.EventServiceClientImpl = a.Event = a.GetEventsResponse = a.GetEventsRequest = a.GetEventsQuery_Target = a.GetEventsQuery_TargetValue = a.GetEventsQuery = a.EventsStreamResponse = a.EventsStreamRequest = a.EventsStreamReconnectRequest = a.EventsStreamError = a.SubscribePayload = a.DeleteWebhookSubscriptionResponse = a.DeleteWebhookSubscriptionRequest = a.CreateWebhookSubscriptionResponse = a.CreateWebhookSubscriptionRequest = a.ListWebhookSubscriptionsResponse = a.ListWebhookSubscriptionsRequest = a.WebhookSubscription = a.PublishEventResponse = a.PublishEventRequest = a.ServiceEventTarget = a.EventTarget = a.getEventsQuery_PaginationOrderToNumber = a.getEventsQuery_PaginationOrderToJSON = a.getEventsQuery_PaginationOrderFromJSON = a.GetEventsQuery_PaginationOrder = a.eventsStreamMessageTypeToNumber = a.eventsStreamMessageTypeToJSON = a.eventsStreamMessageTypeFromJSON = a.EventsStreamMessageType = a.protobufPackage = void 0;
  const c = u(minimal), l = require$$1$2, v = struct, p = timestamp$1;
  a.protobufPackage = "apis.event.v2";
  var _;
  (function(Q) {
    Q.EVENTS_STREAM_MESSAGE_TYPE_UNSPECIFIED = "EVENTS_STREAM_MESSAGE_TYPE_UNSPECIFIED", Q.EVENTS_STREAM_MESSAGE_TYPE_PING = "EVENTS_STREAM_MESSAGE_TYPE_PING", Q.EVENTS_STREAM_MESSAGE_TYPE_ERROR = "EVENTS_STREAM_MESSAGE_TYPE_ERROR", Q.EVENTS_STREAM_MESSAGE_TYPE_SUBSCRIBED = "EVENTS_STREAM_MESSAGE_TYPE_SUBSCRIBED", Q.EVENTS_STREAM_MESSAGE_TYPE_UNSUBSCRIBED = "EVENTS_STREAM_MESSAGE_TYPE_UNSUBSCRIBED", Q.EVENTS_STREAM_MESSAGE_TYPE_PUBLISHED = "EVENTS_STREAM_MESSAGE_TYPE_PUBLISHED";
  })(_ = a.EventsStreamMessageType || (a.EventsStreamMessageType = {}));
  function k(Q) {
    switch (Q) {
      case 0:
      case "EVENTS_STREAM_MESSAGE_TYPE_UNSPECIFIED":
        return _.EVENTS_STREAM_MESSAGE_TYPE_UNSPECIFIED;
      case 1:
      case "EVENTS_STREAM_MESSAGE_TYPE_PING":
        return _.EVENTS_STREAM_MESSAGE_TYPE_PING;
      case 2:
      case "EVENTS_STREAM_MESSAGE_TYPE_ERROR":
        return _.EVENTS_STREAM_MESSAGE_TYPE_ERROR;
      case 3:
      case "EVENTS_STREAM_MESSAGE_TYPE_SUBSCRIBED":
        return _.EVENTS_STREAM_MESSAGE_TYPE_SUBSCRIBED;
      case 4:
      case "EVENTS_STREAM_MESSAGE_TYPE_UNSUBSCRIBED":
        return _.EVENTS_STREAM_MESSAGE_TYPE_UNSUBSCRIBED;
      case 5:
      case "EVENTS_STREAM_MESSAGE_TYPE_PUBLISHED":
        return _.EVENTS_STREAM_MESSAGE_TYPE_PUBLISHED;
      default:
        throw new pe.Error("Unrecognized enum value " + Q + " for enum EventsStreamMessageType");
    }
  }
  a.eventsStreamMessageTypeFromJSON = k;
  function M(Q) {
    switch (Q) {
      case _.EVENTS_STREAM_MESSAGE_TYPE_UNSPECIFIED:
        return "EVENTS_STREAM_MESSAGE_TYPE_UNSPECIFIED";
      case _.EVENTS_STREAM_MESSAGE_TYPE_PING:
        return "EVENTS_STREAM_MESSAGE_TYPE_PING";
      case _.EVENTS_STREAM_MESSAGE_TYPE_ERROR:
        return "EVENTS_STREAM_MESSAGE_TYPE_ERROR";
      case _.EVENTS_STREAM_MESSAGE_TYPE_SUBSCRIBED:
        return "EVENTS_STREAM_MESSAGE_TYPE_SUBSCRIBED";
      case _.EVENTS_STREAM_MESSAGE_TYPE_UNSUBSCRIBED:
        return "EVENTS_STREAM_MESSAGE_TYPE_UNSUBSCRIBED";
      case _.EVENTS_STREAM_MESSAGE_TYPE_PUBLISHED:
        return "EVENTS_STREAM_MESSAGE_TYPE_PUBLISHED";
      default:
        throw new pe.Error("Unrecognized enum value " + Q + " for enum EventsStreamMessageType");
    }
  }
  a.eventsStreamMessageTypeToJSON = M;
  function L(Q) {
    switch (Q) {
      case _.EVENTS_STREAM_MESSAGE_TYPE_UNSPECIFIED:
        return 0;
      case _.EVENTS_STREAM_MESSAGE_TYPE_PING:
        return 1;
      case _.EVENTS_STREAM_MESSAGE_TYPE_ERROR:
        return 2;
      case _.EVENTS_STREAM_MESSAGE_TYPE_SUBSCRIBED:
        return 3;
      case _.EVENTS_STREAM_MESSAGE_TYPE_UNSUBSCRIBED:
        return 4;
      case _.EVENTS_STREAM_MESSAGE_TYPE_PUBLISHED:
        return 5;
      default:
        throw new pe.Error("Unrecognized enum value " + Q + " for enum EventsStreamMessageType");
    }
  }
  a.eventsStreamMessageTypeToNumber = L;
  var F;
  (function(Q) {
    Q.PAGINATION_ORDER_UNSPECIFIED = "PAGINATION_ORDER_UNSPECIFIED", Q.PAGINATION_ORDER_CREATED_AT_DESC = "PAGINATION_ORDER_CREATED_AT_DESC", Q.PAGINATION_ORDER_CREATED_AT_ASC = "PAGINATION_ORDER_CREATED_AT_ASC";
  })(F = a.GetEventsQuery_PaginationOrder || (a.GetEventsQuery_PaginationOrder = {}));
  function V(Q) {
    switch (Q) {
      case 0:
      case "PAGINATION_ORDER_UNSPECIFIED":
        return F.PAGINATION_ORDER_UNSPECIFIED;
      case 1:
      case "PAGINATION_ORDER_CREATED_AT_DESC":
        return F.PAGINATION_ORDER_CREATED_AT_DESC;
      case 2:
      case "PAGINATION_ORDER_CREATED_AT_ASC":
        return F.PAGINATION_ORDER_CREATED_AT_ASC;
      default:
        throw new pe.Error("Unrecognized enum value " + Q + " for enum GetEventsQuery_PaginationOrder");
    }
  }
  a.getEventsQuery_PaginationOrderFromJSON = V;
  function X(Q) {
    switch (Q) {
      case F.PAGINATION_ORDER_UNSPECIFIED:
        return "PAGINATION_ORDER_UNSPECIFIED";
      case F.PAGINATION_ORDER_CREATED_AT_DESC:
        return "PAGINATION_ORDER_CREATED_AT_DESC";
      case F.PAGINATION_ORDER_CREATED_AT_ASC:
        return "PAGINATION_ORDER_CREATED_AT_ASC";
      default:
        throw new pe.Error("Unrecognized enum value " + Q + " for enum GetEventsQuery_PaginationOrder");
    }
  }
  a.getEventsQuery_PaginationOrderToJSON = X;
  function oe(Q) {
    switch (Q) {
      case F.PAGINATION_ORDER_UNSPECIFIED:
        return 0;
      case F.PAGINATION_ORDER_CREATED_AT_DESC:
        return 1;
      case F.PAGINATION_ORDER_CREATED_AT_ASC:
        return 2;
      default:
        throw new pe.Error("Unrecognized enum value " + Q + " for enum GetEventsQuery_PaginationOrder");
    }
  }
  a.getEventsQuery_PaginationOrderToNumber = oe;
  function Y() {
    return { collectionId: void 0, projectId: void 0, layoutId: void 0 };
  }
  a.EventTarget = {
    encode(Q, le = c.default.Writer.create()) {
      return Q.collectionId !== void 0 && le.uint32(42).string(Q.collectionId), Q.projectId !== void 0 && le.uint32(34).string(Q.projectId), Q.layoutId !== void 0 && le.uint32(10).string(Q.layoutId), le;
    },
    decode(Q, le) {
      const _e = Q instanceof c.default.Reader ? Q : new c.default.Reader(Q);
      let re = le === void 0 ? _e.len : _e.pos + le;
      const O = Y();
      for (; _e.pos < re; ) {
        const j = _e.uint32();
        switch (j >>> 3) {
          case 5:
            O.collectionId = _e.string();
            break;
          case 4:
            O.projectId = _e.string();
            break;
          case 1:
            O.layoutId = _e.string();
            break;
          default:
            _e.skipType(j & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(Q) {
      return {
        collectionId: ve(Q.collectionId) ? String(Q.collectionId) : void 0,
        projectId: ve(Q.projectId) ? String(Q.projectId) : void 0,
        layoutId: ve(Q.layoutId) ? String(Q.layoutId) : void 0
      };
    },
    toJSON(Q) {
      const le = {};
      return Q.collectionId !== void 0 && (le.collectionId = Q.collectionId), Q.projectId !== void 0 && (le.projectId = Q.projectId), Q.layoutId !== void 0 && (le.layoutId = Q.layoutId), le;
    },
    fromPartial(Q) {
      var le, _e, re;
      const O = Y();
      return O.collectionId = (le = Q.collectionId) !== null && le !== void 0 ? le : void 0, O.projectId = (_e = Q.projectId) !== null && _e !== void 0 ? _e : void 0, O.layoutId = (re = Q.layoutId) !== null && re !== void 0 ? re : void 0, O;
    }
  };
  function ae() {
    return {
      userId: void 0,
      collectionId: void 0,
      projectId: void 0,
      layoutId: void 0,
      serviceUserId: void 0
    };
  }
  a.ServiceEventTarget = {
    encode(Q, le = c.default.Writer.create()) {
      return Q.userId !== void 0 && le.uint32(10).string(Q.userId), Q.collectionId !== void 0 && le.uint32(18).string(Q.collectionId), Q.projectId !== void 0 && le.uint32(26).string(Q.projectId), Q.layoutId !== void 0 && le.uint32(34).string(Q.layoutId), Q.serviceUserId !== void 0 && le.uint32(42).string(Q.serviceUserId), le;
    },
    decode(Q, le) {
      const _e = Q instanceof c.default.Reader ? Q : new c.default.Reader(Q);
      let re = le === void 0 ? _e.len : _e.pos + le;
      const O = ae();
      for (; _e.pos < re; ) {
        const j = _e.uint32();
        switch (j >>> 3) {
          case 1:
            O.userId = _e.string();
            break;
          case 2:
            O.collectionId = _e.string();
            break;
          case 3:
            O.projectId = _e.string();
            break;
          case 4:
            O.layoutId = _e.string();
            break;
          case 5:
            O.serviceUserId = _e.string();
            break;
          default:
            _e.skipType(j & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(Q) {
      return {
        userId: ve(Q.userId) ? String(Q.userId) : void 0,
        collectionId: ve(Q.collectionId) ? String(Q.collectionId) : void 0,
        projectId: ve(Q.projectId) ? String(Q.projectId) : void 0,
        layoutId: ve(Q.layoutId) ? String(Q.layoutId) : void 0,
        serviceUserId: ve(Q.serviceUserId) ? String(Q.serviceUserId) : void 0
      };
    },
    toJSON(Q) {
      const le = {};
      return Q.userId !== void 0 && (le.userId = Q.userId), Q.collectionId !== void 0 && (le.collectionId = Q.collectionId), Q.projectId !== void 0 && (le.projectId = Q.projectId), Q.layoutId !== void 0 && (le.layoutId = Q.layoutId), Q.serviceUserId !== void 0 && (le.serviceUserId = Q.serviceUserId), le;
    },
    fromPartial(Q) {
      var le, _e, re, O, j;
      const ce = ae();
      return ce.userId = (le = Q.userId) !== null && le !== void 0 ? le : void 0, ce.collectionId = (_e = Q.collectionId) !== null && _e !== void 0 ? _e : void 0, ce.projectId = (re = Q.projectId) !== null && re !== void 0 ? re : void 0, ce.layoutId = (O = Q.layoutId) !== null && O !== void 0 ? O : void 0, ce.serviceUserId = (j = Q.serviceUserId) !== null && j !== void 0 ? j : void 0, ce;
    }
  };
  function ne() {
    return { name: "", payload: void 0, requestMetadata: void 0, target: void 0 };
  }
  a.PublishEventRequest = {
    encode(Q, le = c.default.Writer.create()) {
      return Q.name !== "" && le.uint32(10).string(Q.name), Q.payload !== void 0 && v.Struct.encode(v.Struct.wrap(Q.payload), le.uint32(18).fork()).ldelim(), Q.requestMetadata !== void 0 && v.Value.encode(v.Value.wrap(Q.requestMetadata), le.uint32(34).fork()).ldelim(), Q.target !== void 0 && a.EventTarget.encode(Q.target, le.uint32(26).fork()).ldelim(), le;
    },
    decode(Q, le) {
      const _e = Q instanceof c.default.Reader ? Q : new c.default.Reader(Q);
      let re = le === void 0 ? _e.len : _e.pos + le;
      const O = ne();
      for (; _e.pos < re; ) {
        const j = _e.uint32();
        switch (j >>> 3) {
          case 1:
            O.name = _e.string();
            break;
          case 2:
            O.payload = v.Struct.unwrap(v.Struct.decode(_e, _e.uint32()));
            break;
          case 4:
            O.requestMetadata = v.Value.unwrap(v.Value.decode(_e, _e.uint32()));
            break;
          case 3:
            O.target = a.EventTarget.decode(_e, _e.uint32());
            break;
          default:
            _e.skipType(j & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(Q) {
      return {
        name: ve(Q.name) ? String(Q.name) : "",
        payload: he(Q.payload) ? Q.payload : void 0,
        requestMetadata: ve(Q == null ? void 0 : Q.requestMetadata) ? Q.requestMetadata : void 0,
        target: ve(Q.target) ? a.EventTarget.fromJSON(Q.target) : void 0
      };
    },
    toJSON(Q) {
      const le = {};
      return Q.name !== void 0 && (le.name = Q.name), Q.payload !== void 0 && (le.payload = Q.payload), Q.requestMetadata !== void 0 && (le.requestMetadata = Q.requestMetadata), Q.target !== void 0 && (le.target = Q.target ? a.EventTarget.toJSON(Q.target) : void 0), le;
    },
    fromPartial(Q) {
      var le, _e, re;
      const O = ne();
      return O.name = (le = Q.name) !== null && le !== void 0 ? le : "", O.payload = (_e = Q.payload) !== null && _e !== void 0 ? _e : void 0, O.requestMetadata = (re = Q.requestMetadata) !== null && re !== void 0 ? re : void 0, O.target = Q.target !== void 0 && Q.target !== null ? a.EventTarget.fromPartial(Q.target) : void 0, O;
    }
  };
  function fe() {
    return { name: "", payload: void 0, target: void 0, requestMetadata: void 0, id: "" };
  }
  a.PublishEventResponse = {
    encode(Q, le = c.default.Writer.create()) {
      return Q.name !== "" && le.uint32(10).string(Q.name), Q.payload !== void 0 && v.Struct.encode(v.Struct.wrap(Q.payload), le.uint32(18).fork()).ldelim(), Q.target !== void 0 && a.EventTarget.encode(Q.target, le.uint32(26).fork()).ldelim(), Q.requestMetadata !== void 0 && v.Value.encode(v.Value.wrap(Q.requestMetadata), le.uint32(34).fork()).ldelim(), Q.id !== "" && le.uint32(42).string(Q.id), le;
    },
    decode(Q, le) {
      const _e = Q instanceof c.default.Reader ? Q : new c.default.Reader(Q);
      let re = le === void 0 ? _e.len : _e.pos + le;
      const O = fe();
      for (; _e.pos < re; ) {
        const j = _e.uint32();
        switch (j >>> 3) {
          case 1:
            O.name = _e.string();
            break;
          case 2:
            O.payload = v.Struct.unwrap(v.Struct.decode(_e, _e.uint32()));
            break;
          case 3:
            O.target = a.EventTarget.decode(_e, _e.uint32());
            break;
          case 4:
            O.requestMetadata = v.Value.unwrap(v.Value.decode(_e, _e.uint32()));
            break;
          case 5:
            O.id = _e.string();
            break;
          default:
            _e.skipType(j & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(Q) {
      return {
        name: ve(Q.name) ? String(Q.name) : "",
        payload: he(Q.payload) ? Q.payload : void 0,
        target: ve(Q.target) ? a.EventTarget.fromJSON(Q.target) : void 0,
        requestMetadata: ve(Q == null ? void 0 : Q.requestMetadata) ? Q.requestMetadata : void 0,
        id: ve(Q.id) ? String(Q.id) : ""
      };
    },
    toJSON(Q) {
      const le = {};
      return Q.name !== void 0 && (le.name = Q.name), Q.payload !== void 0 && (le.payload = Q.payload), Q.target !== void 0 && (le.target = Q.target ? a.EventTarget.toJSON(Q.target) : void 0), Q.requestMetadata !== void 0 && (le.requestMetadata = Q.requestMetadata), Q.id !== void 0 && (le.id = Q.id), le;
    },
    fromPartial(Q) {
      var le, _e, re, O;
      const j = fe();
      return j.name = (le = Q.name) !== null && le !== void 0 ? le : "", j.payload = (_e = Q.payload) !== null && _e !== void 0 ? _e : void 0, j.target = Q.target !== void 0 && Q.target !== null ? a.EventTarget.fromPartial(Q.target) : void 0, j.requestMetadata = (re = Q.requestMetadata) !== null && re !== void 0 ? re : void 0, j.id = (O = Q.id) !== null && O !== void 0 ? O : "", j;
    }
  };
  function ie() {
    return { webhookId: "", events: [], target: void 0, url: "", timeoutMs: void 0 };
  }
  a.WebhookSubscription = {
    encode(Q, le = c.default.Writer.create()) {
      Q.webhookId !== "" && le.uint32(10).string(Q.webhookId);
      for (const _e of Q.events)
        le.uint32(18).string(_e);
      return Q.target !== void 0 && a.ServiceEventTarget.encode(Q.target, le.uint32(26).fork()).ldelim(), Q.url !== "" && le.uint32(34).string(Q.url), Q.timeoutMs !== void 0 && le.uint32(40).uint32(Q.timeoutMs), le;
    },
    decode(Q, le) {
      const _e = Q instanceof c.default.Reader ? Q : new c.default.Reader(Q);
      let re = le === void 0 ? _e.len : _e.pos + le;
      const O = ie();
      for (; _e.pos < re; ) {
        const j = _e.uint32();
        switch (j >>> 3) {
          case 1:
            O.webhookId = _e.string();
            break;
          case 2:
            O.events.push(_e.string());
            break;
          case 3:
            O.target = a.ServiceEventTarget.decode(_e, _e.uint32());
            break;
          case 4:
            O.url = _e.string();
            break;
          case 5:
            O.timeoutMs = _e.uint32();
            break;
          default:
            _e.skipType(j & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(Q) {
      return {
        webhookId: ve(Q.webhookId) ? String(Q.webhookId) : "",
        events: Array.isArray(Q == null ? void 0 : Q.events) ? Q.events.map((le) => String(le)) : [],
        target: ve(Q.target) ? a.ServiceEventTarget.fromJSON(Q.target) : void 0,
        url: ve(Q.url) ? String(Q.url) : "",
        timeoutMs: ve(Q.timeoutMs) ? Number(Q.timeoutMs) : void 0
      };
    },
    toJSON(Q) {
      const le = {};
      return Q.webhookId !== void 0 && (le.webhookId = Q.webhookId), Q.events ? le.events = Q.events.map((_e) => _e) : le.events = [], Q.target !== void 0 && (le.target = Q.target ? a.ServiceEventTarget.toJSON(Q.target) : void 0), Q.url !== void 0 && (le.url = Q.url), Q.timeoutMs !== void 0 && (le.timeoutMs = Math.round(Q.timeoutMs)), le;
    },
    fromPartial(Q) {
      var le, _e, re, O;
      const j = ie();
      return j.webhookId = (le = Q.webhookId) !== null && le !== void 0 ? le : "", j.events = ((_e = Q.events) === null || _e === void 0 ? void 0 : _e.map((ce) => ce)) || [], j.target = Q.target !== void 0 && Q.target !== null ? a.ServiceEventTarget.fromPartial(Q.target) : void 0, j.url = (re = Q.url) !== null && re !== void 0 ? re : "", j.timeoutMs = (O = Q.timeoutMs) !== null && O !== void 0 ? O : void 0, j;
    }
  };
  function ge() {
    return { target: void 0 };
  }
  a.ListWebhookSubscriptionsRequest = {
    encode(Q, le = c.default.Writer.create()) {
      return Q.target !== void 0 && a.ServiceEventTarget.encode(Q.target, le.uint32(10).fork()).ldelim(), le;
    },
    decode(Q, le) {
      const _e = Q instanceof c.default.Reader ? Q : new c.default.Reader(Q);
      let re = le === void 0 ? _e.len : _e.pos + le;
      const O = ge();
      for (; _e.pos < re; ) {
        const j = _e.uint32();
        switch (j >>> 3) {
          case 1:
            O.target = a.ServiceEventTarget.decode(_e, _e.uint32());
            break;
          default:
            _e.skipType(j & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(Q) {
      return { target: ve(Q.target) ? a.ServiceEventTarget.fromJSON(Q.target) : void 0 };
    },
    toJSON(Q) {
      const le = {};
      return Q.target !== void 0 && (le.target = Q.target ? a.ServiceEventTarget.toJSON(Q.target) : void 0), le;
    },
    fromPartial(Q) {
      const le = ge();
      return le.target = Q.target !== void 0 && Q.target !== null ? a.ServiceEventTarget.fromPartial(Q.target) : void 0, le;
    }
  };
  function be() {
    return { subscriptions: [] };
  }
  a.ListWebhookSubscriptionsResponse = {
    encode(Q, le = c.default.Writer.create()) {
      for (const _e of Q.subscriptions)
        a.WebhookSubscription.encode(_e, le.uint32(10).fork()).ldelim();
      return le;
    },
    decode(Q, le) {
      const _e = Q instanceof c.default.Reader ? Q : new c.default.Reader(Q);
      let re = le === void 0 ? _e.len : _e.pos + le;
      const O = be();
      for (; _e.pos < re; ) {
        const j = _e.uint32();
        switch (j >>> 3) {
          case 1:
            O.subscriptions.push(a.WebhookSubscription.decode(_e, _e.uint32()));
            break;
          default:
            _e.skipType(j & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(Q) {
      return {
        subscriptions: Array.isArray(Q == null ? void 0 : Q.subscriptions) ? Q.subscriptions.map((le) => a.WebhookSubscription.fromJSON(le)) : []
      };
    },
    toJSON(Q) {
      const le = {};
      return Q.subscriptions ? le.subscriptions = Q.subscriptions.map((_e) => _e ? a.WebhookSubscription.toJSON(_e) : void 0) : le.subscriptions = [], le;
    },
    fromPartial(Q) {
      var le;
      const _e = be();
      return _e.subscriptions = ((le = Q.subscriptions) === null || le === void 0 ? void 0 : le.map((re) => a.WebhookSubscription.fromPartial(re))) || [], _e;
    }
  };
  function Ce() {
    return { events: [], target: void 0, url: "", timeoutMs: void 0 };
  }
  a.CreateWebhookSubscriptionRequest = {
    encode(Q, le = c.default.Writer.create()) {
      for (const _e of Q.events)
        le.uint32(10).string(_e);
      return Q.target !== void 0 && a.ServiceEventTarget.encode(Q.target, le.uint32(18).fork()).ldelim(), Q.url !== "" && le.uint32(26).string(Q.url), Q.timeoutMs !== void 0 && le.uint32(32).uint32(Q.timeoutMs), le;
    },
    decode(Q, le) {
      const _e = Q instanceof c.default.Reader ? Q : new c.default.Reader(Q);
      let re = le === void 0 ? _e.len : _e.pos + le;
      const O = Ce();
      for (; _e.pos < re; ) {
        const j = _e.uint32();
        switch (j >>> 3) {
          case 1:
            O.events.push(_e.string());
            break;
          case 2:
            O.target = a.ServiceEventTarget.decode(_e, _e.uint32());
            break;
          case 3:
            O.url = _e.string();
            break;
          case 4:
            O.timeoutMs = _e.uint32();
            break;
          default:
            _e.skipType(j & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(Q) {
      return {
        events: Array.isArray(Q == null ? void 0 : Q.events) ? Q.events.map((le) => String(le)) : [],
        target: ve(Q.target) ? a.ServiceEventTarget.fromJSON(Q.target) : void 0,
        url: ve(Q.url) ? String(Q.url) : "",
        timeoutMs: ve(Q.timeoutMs) ? Number(Q.timeoutMs) : void 0
      };
    },
    toJSON(Q) {
      const le = {};
      return Q.events ? le.events = Q.events.map((_e) => _e) : le.events = [], Q.target !== void 0 && (le.target = Q.target ? a.ServiceEventTarget.toJSON(Q.target) : void 0), Q.url !== void 0 && (le.url = Q.url), Q.timeoutMs !== void 0 && (le.timeoutMs = Math.round(Q.timeoutMs)), le;
    },
    fromPartial(Q) {
      var le, _e, re;
      const O = Ce();
      return O.events = ((le = Q.events) === null || le === void 0 ? void 0 : le.map((j) => j)) || [], O.target = Q.target !== void 0 && Q.target !== null ? a.ServiceEventTarget.fromPartial(Q.target) : void 0, O.url = (_e = Q.url) !== null && _e !== void 0 ? _e : "", O.timeoutMs = (re = Q.timeoutMs) !== null && re !== void 0 ? re : void 0, O;
    }
  };
  function Me() {
    return { subscription: void 0 };
  }
  a.CreateWebhookSubscriptionResponse = {
    encode(Q, le = c.default.Writer.create()) {
      return Q.subscription !== void 0 && a.WebhookSubscription.encode(Q.subscription, le.uint32(10).fork()).ldelim(), le;
    },
    decode(Q, le) {
      const _e = Q instanceof c.default.Reader ? Q : new c.default.Reader(Q);
      let re = le === void 0 ? _e.len : _e.pos + le;
      const O = Me();
      for (; _e.pos < re; ) {
        const j = _e.uint32();
        switch (j >>> 3) {
          case 1:
            O.subscription = a.WebhookSubscription.decode(_e, _e.uint32());
            break;
          default:
            _e.skipType(j & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(Q) {
      return { subscription: ve(Q.subscription) ? a.WebhookSubscription.fromJSON(Q.subscription) : void 0 };
    },
    toJSON(Q) {
      const le = {};
      return Q.subscription !== void 0 && (le.subscription = Q.subscription ? a.WebhookSubscription.toJSON(Q.subscription) : void 0), le;
    },
    fromPartial(Q) {
      const le = Me();
      return le.subscription = Q.subscription !== void 0 && Q.subscription !== null ? a.WebhookSubscription.fromPartial(Q.subscription) : void 0, le;
    }
  };
  function Be() {
    return { webhookId: "" };
  }
  a.DeleteWebhookSubscriptionRequest = {
    encode(Q, le = c.default.Writer.create()) {
      return Q.webhookId !== "" && le.uint32(10).string(Q.webhookId), le;
    },
    decode(Q, le) {
      const _e = Q instanceof c.default.Reader ? Q : new c.default.Reader(Q);
      let re = le === void 0 ? _e.len : _e.pos + le;
      const O = Be();
      for (; _e.pos < re; ) {
        const j = _e.uint32();
        switch (j >>> 3) {
          case 1:
            O.webhookId = _e.string();
            break;
          default:
            _e.skipType(j & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(Q) {
      return { webhookId: ve(Q.webhookId) ? String(Q.webhookId) : "" };
    },
    toJSON(Q) {
      const le = {};
      return Q.webhookId !== void 0 && (le.webhookId = Q.webhookId), le;
    },
    fromPartial(Q) {
      var le;
      const _e = Be();
      return _e.webhookId = (le = Q.webhookId) !== null && le !== void 0 ? le : "", _e;
    }
  };
  function Ae() {
    return {};
  }
  a.DeleteWebhookSubscriptionResponse = {
    encode(Q, le = c.default.Writer.create()) {
      return le;
    },
    decode(Q, le) {
      const _e = Q instanceof c.default.Reader ? Q : new c.default.Reader(Q);
      let re = le === void 0 ? _e.len : _e.pos + le;
      const O = Ae();
      for (; _e.pos < re; ) {
        const j = _e.uint32();
        switch (j >>> 3) {
          default:
            _e.skipType(j & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(Q) {
      return {};
    },
    toJSON(Q) {
      return {};
    },
    fromPartial(Q) {
      return Ae();
    }
  };
  function Z() {
    return { name: "", events: [], target: void 0 };
  }
  a.SubscribePayload = {
    encode(Q, le = c.default.Writer.create()) {
      Q.name !== "" && le.uint32(10).string(Q.name);
      for (const _e of Q.events)
        le.uint32(26).string(_e);
      return Q.target !== void 0 && a.EventTarget.encode(Q.target, le.uint32(18).fork()).ldelim(), le;
    },
    decode(Q, le) {
      const _e = Q instanceof c.default.Reader ? Q : new c.default.Reader(Q);
      let re = le === void 0 ? _e.len : _e.pos + le;
      const O = Z();
      for (; _e.pos < re; ) {
        const j = _e.uint32();
        switch (j >>> 3) {
          case 1:
            O.name = _e.string();
            break;
          case 3:
            O.events.push(_e.string());
            break;
          case 2:
            O.target = a.EventTarget.decode(_e, _e.uint32());
            break;
          default:
            _e.skipType(j & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(Q) {
      return {
        name: ve(Q.name) ? String(Q.name) : "",
        events: Array.isArray(Q == null ? void 0 : Q.events) ? Q.events.map((le) => String(le)) : [],
        target: ve(Q.target) ? a.EventTarget.fromJSON(Q.target) : void 0
      };
    },
    toJSON(Q) {
      const le = {};
      return Q.name !== void 0 && (le.name = Q.name), Q.events ? le.events = Q.events.map((_e) => _e) : le.events = [], Q.target !== void 0 && (le.target = Q.target ? a.EventTarget.toJSON(Q.target) : void 0), le;
    },
    fromPartial(Q) {
      var le, _e;
      const re = Z();
      return re.name = (le = Q.name) !== null && le !== void 0 ? le : "", re.events = ((_e = Q.events) === null || _e === void 0 ? void 0 : _e.map((O) => O)) || [], re.target = Q.target !== void 0 && Q.target !== null ? a.EventTarget.fromPartial(Q.target) : void 0, re;
    }
  };
  function z() {
    return { code: 0, message: "" };
  }
  a.EventsStreamError = {
    encode(Q, le = c.default.Writer.create()) {
      return Q.code !== 0 && le.uint32(8).int32(Q.code), Q.message !== "" && le.uint32(18).string(Q.message), le;
    },
    decode(Q, le) {
      const _e = Q instanceof c.default.Reader ? Q : new c.default.Reader(Q);
      let re = le === void 0 ? _e.len : _e.pos + le;
      const O = z();
      for (; _e.pos < re; ) {
        const j = _e.uint32();
        switch (j >>> 3) {
          case 1:
            O.code = _e.int32();
            break;
          case 2:
            O.message = _e.string();
            break;
          default:
            _e.skipType(j & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(Q) {
      return {
        code: ve(Q.code) ? Number(Q.code) : 0,
        message: ve(Q.message) ? String(Q.message) : ""
      };
    },
    toJSON(Q) {
      const le = {};
      return Q.code !== void 0 && (le.code = Math.round(Q.code)), Q.message !== void 0 && (le.message = Q.message), le;
    },
    fromPartial(Q) {
      var le, _e;
      const re = z();
      return re.code = (le = Q.code) !== null && le !== void 0 ? le : 0, re.message = (_e = Q.message) !== null && _e !== void 0 ? _e : "", re;
    }
  };
  function P() {
    return { reauthenticate: !1, beforeTimestamp: "" };
  }
  a.EventsStreamReconnectRequest = {
    encode(Q, le = c.default.Writer.create()) {
      return Q.reauthenticate === !0 && le.uint32(8).bool(Q.reauthenticate), Q.beforeTimestamp !== "" && le.uint32(18).string(Q.beforeTimestamp), le;
    },
    decode(Q, le) {
      const _e = Q instanceof c.default.Reader ? Q : new c.default.Reader(Q);
      let re = le === void 0 ? _e.len : _e.pos + le;
      const O = P();
      for (; _e.pos < re; ) {
        const j = _e.uint32();
        switch (j >>> 3) {
          case 1:
            O.reauthenticate = _e.bool();
            break;
          case 2:
            O.beforeTimestamp = _e.string();
            break;
          default:
            _e.skipType(j & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(Q) {
      return {
        reauthenticate: ve(Q.reauthenticate) ? !!Q.reauthenticate : !1,
        beforeTimestamp: ve(Q.beforeTimestamp) ? String(Q.beforeTimestamp) : ""
      };
    },
    toJSON(Q) {
      const le = {};
      return Q.reauthenticate !== void 0 && (le.reauthenticate = Q.reauthenticate), Q.beforeTimestamp !== void 0 && (le.beforeTimestamp = Q.beforeTimestamp), le;
    },
    fromPartial(Q) {
      var le, _e;
      const re = P();
      return re.reauthenticate = (le = Q.reauthenticate) !== null && le !== void 0 ? le : !1, re.beforeTimestamp = (_e = Q.beforeTimestamp) !== null && _e !== void 0 ? _e : "", re;
    }
  };
  function S() {
    return {
      correlationId: void 0,
      subscribe: void 0,
      unsubscribe: void 0,
      publish: void 0,
      ping: void 0
    };
  }
  a.EventsStreamRequest = {
    encode(Q, le = c.default.Writer.create()) {
      return Q.correlationId !== void 0 && le.uint32(10).string(Q.correlationId), Q.subscribe !== void 0 && a.SubscribePayload.encode(Q.subscribe, le.uint32(802).fork()).ldelim(), Q.unsubscribe !== void 0 && a.SubscribePayload.encode(Q.unsubscribe, le.uint32(810).fork()).ldelim(), Q.publish !== void 0 && a.PublishEventRequest.encode(Q.publish, le.uint32(818).fork()).ldelim(), Q.ping !== void 0 && le.uint32(826).string(Q.ping), le;
    },
    decode(Q, le) {
      const _e = Q instanceof c.default.Reader ? Q : new c.default.Reader(Q);
      let re = le === void 0 ? _e.len : _e.pos + le;
      const O = S();
      for (; _e.pos < re; ) {
        const j = _e.uint32();
        switch (j >>> 3) {
          case 1:
            O.correlationId = _e.string();
            break;
          case 100:
            O.subscribe = a.SubscribePayload.decode(_e, _e.uint32());
            break;
          case 101:
            O.unsubscribe = a.SubscribePayload.decode(_e, _e.uint32());
            break;
          case 102:
            O.publish = a.PublishEventRequest.decode(_e, _e.uint32());
            break;
          case 103:
            O.ping = _e.string();
            break;
          default:
            _e.skipType(j & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(Q) {
      return {
        correlationId: ve(Q.correlationId) ? String(Q.correlationId) : void 0,
        subscribe: ve(Q.subscribe) ? a.SubscribePayload.fromJSON(Q.subscribe) : void 0,
        unsubscribe: ve(Q.unsubscribe) ? a.SubscribePayload.fromJSON(Q.unsubscribe) : void 0,
        publish: ve(Q.publish) ? a.PublishEventRequest.fromJSON(Q.publish) : void 0,
        ping: ve(Q.ping) ? String(Q.ping) : void 0
      };
    },
    toJSON(Q) {
      const le = {};
      return Q.correlationId !== void 0 && (le.correlationId = Q.correlationId), Q.subscribe !== void 0 && (le.subscribe = Q.subscribe ? a.SubscribePayload.toJSON(Q.subscribe) : void 0), Q.unsubscribe !== void 0 && (le.unsubscribe = Q.unsubscribe ? a.SubscribePayload.toJSON(Q.unsubscribe) : void 0), Q.publish !== void 0 && (le.publish = Q.publish ? a.PublishEventRequest.toJSON(Q.publish) : void 0), Q.ping !== void 0 && (le.ping = Q.ping), le;
    },
    fromPartial(Q) {
      var le, _e;
      const re = S();
      return re.correlationId = (le = Q.correlationId) !== null && le !== void 0 ? le : void 0, re.subscribe = Q.subscribe !== void 0 && Q.subscribe !== null ? a.SubscribePayload.fromPartial(Q.subscribe) : void 0, re.unsubscribe = Q.unsubscribe !== void 0 && Q.unsubscribe !== null ? a.SubscribePayload.fromPartial(Q.unsubscribe) : void 0, re.publish = Q.publish !== void 0 && Q.publish !== null ? a.PublishEventRequest.fromPartial(Q.publish) : void 0, re.ping = (_e = Q.ping) !== null && _e !== void 0 ? _e : void 0, re;
    }
  };
  function E() {
    return {
      correlationId: void 0,
      sessionId: void 0,
      event: void 0,
      pong: void 0,
      error: void 0,
      subscribed: void 0,
      unsubscribed: void 0,
      published: void 0,
      reconnectBefore: void 0
    };
  }
  a.EventsStreamResponse = {
    encode(Q, le = c.default.Writer.create()) {
      return Q.correlationId !== void 0 && le.uint32(18).string(Q.correlationId), Q.sessionId !== void 0 && le.uint32(26).string(Q.sessionId), Q.event !== void 0 && a.PublishEventResponse.encode(Q.event, le.uint32(802).fork()).ldelim(), Q.pong !== void 0 && le.uint32(1602).string(Q.pong), Q.error !== void 0 && a.EventsStreamError.encode(Q.error, le.uint32(1610).fork()).ldelim(), Q.subscribed !== void 0 && a.SubscribePayload.encode(Q.subscribed, le.uint32(1618).fork()).ldelim(), Q.unsubscribed !== void 0 && a.SubscribePayload.encode(Q.unsubscribed, le.uint32(1626).fork()).ldelim(), Q.published !== void 0 && a.PublishEventResponse.encode(Q.published, le.uint32(1634).fork()).ldelim(), Q.reconnectBefore !== void 0 && a.EventsStreamReconnectRequest.encode(Q.reconnectBefore, le.uint32(1642).fork()).ldelim(), le;
    },
    decode(Q, le) {
      const _e = Q instanceof c.default.Reader ? Q : new c.default.Reader(Q);
      let re = le === void 0 ? _e.len : _e.pos + le;
      const O = E();
      for (; _e.pos < re; ) {
        const j = _e.uint32();
        switch (j >>> 3) {
          case 2:
            O.correlationId = _e.string();
            break;
          case 3:
            O.sessionId = _e.string();
            break;
          case 100:
            O.event = a.PublishEventResponse.decode(_e, _e.uint32());
            break;
          case 200:
            O.pong = _e.string();
            break;
          case 201:
            O.error = a.EventsStreamError.decode(_e, _e.uint32());
            break;
          case 202:
            O.subscribed = a.SubscribePayload.decode(_e, _e.uint32());
            break;
          case 203:
            O.unsubscribed = a.SubscribePayload.decode(_e, _e.uint32());
            break;
          case 204:
            O.published = a.PublishEventResponse.decode(_e, _e.uint32());
            break;
          case 205:
            O.reconnectBefore = a.EventsStreamReconnectRequest.decode(_e, _e.uint32());
            break;
          default:
            _e.skipType(j & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(Q) {
      return {
        correlationId: ve(Q.correlationId) ? String(Q.correlationId) : void 0,
        sessionId: ve(Q.sessionId) ? String(Q.sessionId) : void 0,
        event: ve(Q.event) ? a.PublishEventResponse.fromJSON(Q.event) : void 0,
        pong: ve(Q.pong) ? String(Q.pong) : void 0,
        error: ve(Q.error) ? a.EventsStreamError.fromJSON(Q.error) : void 0,
        subscribed: ve(Q.subscribed) ? a.SubscribePayload.fromJSON(Q.subscribed) : void 0,
        unsubscribed: ve(Q.unsubscribed) ? a.SubscribePayload.fromJSON(Q.unsubscribed) : void 0,
        published: ve(Q.published) ? a.PublishEventResponse.fromJSON(Q.published) : void 0,
        reconnectBefore: ve(Q.reconnectBefore) ? a.EventsStreamReconnectRequest.fromJSON(Q.reconnectBefore) : void 0
      };
    },
    toJSON(Q) {
      const le = {};
      return Q.correlationId !== void 0 && (le.correlationId = Q.correlationId), Q.sessionId !== void 0 && (le.sessionId = Q.sessionId), Q.event !== void 0 && (le.event = Q.event ? a.PublishEventResponse.toJSON(Q.event) : void 0), Q.pong !== void 0 && (le.pong = Q.pong), Q.error !== void 0 && (le.error = Q.error ? a.EventsStreamError.toJSON(Q.error) : void 0), Q.subscribed !== void 0 && (le.subscribed = Q.subscribed ? a.SubscribePayload.toJSON(Q.subscribed) : void 0), Q.unsubscribed !== void 0 && (le.unsubscribed = Q.unsubscribed ? a.SubscribePayload.toJSON(Q.unsubscribed) : void 0), Q.published !== void 0 && (le.published = Q.published ? a.PublishEventResponse.toJSON(Q.published) : void 0), Q.reconnectBefore !== void 0 && (le.reconnectBefore = Q.reconnectBefore ? a.EventsStreamReconnectRequest.toJSON(Q.reconnectBefore) : void 0), le;
    },
    fromPartial(Q) {
      var le, _e, re;
      const O = E();
      return O.correlationId = (le = Q.correlationId) !== null && le !== void 0 ? le : void 0, O.sessionId = (_e = Q.sessionId) !== null && _e !== void 0 ? _e : void 0, O.event = Q.event !== void 0 && Q.event !== null ? a.PublishEventResponse.fromPartial(Q.event) : void 0, O.pong = (re = Q.pong) !== null && re !== void 0 ? re : void 0, O.error = Q.error !== void 0 && Q.error !== null ? a.EventsStreamError.fromPartial(Q.error) : void 0, O.subscribed = Q.subscribed !== void 0 && Q.subscribed !== null ? a.SubscribePayload.fromPartial(Q.subscribed) : void 0, O.unsubscribed = Q.unsubscribed !== void 0 && Q.unsubscribed !== null ? a.SubscribePayload.fromPartial(Q.unsubscribed) : void 0, O.published = Q.published !== void 0 && Q.published !== null ? a.PublishEventResponse.fromPartial(Q.published) : void 0, O.reconnectBefore = Q.reconnectBefore !== void 0 && Q.reconnectBefore !== null ? a.EventsStreamReconnectRequest.fromPartial(Q.reconnectBefore) : void 0, O;
    }
  };
  function I() {
    return {
      limit: 0,
      order: F.PAGINATION_ORDER_UNSPECIFIED,
      events: [],
      target: void 0,
      afterTimestamp: void 0,
      beforeTimestamp: void 0
    };
  }
  a.GetEventsQuery = {
    encode(Q, le = c.default.Writer.create()) {
      Q.limit !== 0 && le.uint32(8).int32(Q.limit), Q.order !== F.PAGINATION_ORDER_UNSPECIFIED && le.uint32(16).int32(oe(Q.order));
      for (const _e of Q.events)
        le.uint32(26).string(_e);
      return Q.target !== void 0 && a.GetEventsQuery_Target.encode(Q.target, le.uint32(34).fork()).ldelim(), Q.afterTimestamp !== void 0 && p.Timestamp.encode(Ie(Q.afterTimestamp), le.uint32(42).fork()).ldelim(), Q.beforeTimestamp !== void 0 && p.Timestamp.encode(Ie(Q.beforeTimestamp), le.uint32(50).fork()).ldelim(), le;
    },
    decode(Q, le) {
      const _e = Q instanceof c.default.Reader ? Q : new c.default.Reader(Q);
      let re = le === void 0 ? _e.len : _e.pos + le;
      const O = I();
      for (; _e.pos < re; ) {
        const j = _e.uint32();
        switch (j >>> 3) {
          case 1:
            O.limit = _e.int32();
            break;
          case 2:
            O.order = V(_e.int32());
            break;
          case 3:
            O.events.push(_e.string());
            break;
          case 4:
            O.target = a.GetEventsQuery_Target.decode(_e, _e.uint32());
            break;
          case 5:
            O.afterTimestamp = Pe(p.Timestamp.decode(_e, _e.uint32()));
            break;
          case 6:
            O.beforeTimestamp = Pe(p.Timestamp.decode(_e, _e.uint32()));
            break;
          default:
            _e.skipType(j & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(Q) {
      return {
        limit: ve(Q.limit) ? Number(Q.limit) : 0,
        order: ve(Q.order) ? V(Q.order) : F.PAGINATION_ORDER_UNSPECIFIED,
        events: Array.isArray(Q == null ? void 0 : Q.events) ? Q.events.map((le) => String(le)) : [],
        target: ve(Q.target) ? a.GetEventsQuery_Target.fromJSON(Q.target) : void 0,
        afterTimestamp: ve(Q.afterTimestamp) ? String(Q.afterTimestamp) : void 0,
        beforeTimestamp: ve(Q.beforeTimestamp) ? String(Q.beforeTimestamp) : void 0
      };
    },
    toJSON(Q) {
      const le = {};
      return Q.limit !== void 0 && (le.limit = Math.round(Q.limit)), Q.order !== void 0 && (le.order = X(Q.order)), Q.events ? le.events = Q.events.map((_e) => _e) : le.events = [], Q.target !== void 0 && (le.target = Q.target ? a.GetEventsQuery_Target.toJSON(Q.target) : void 0), Q.afterTimestamp !== void 0 && (le.afterTimestamp = Q.afterTimestamp), Q.beforeTimestamp !== void 0 && (le.beforeTimestamp = Q.beforeTimestamp), le;
    },
    fromPartial(Q) {
      var le, _e, re, O, j;
      const ce = I();
      return ce.limit = (le = Q.limit) !== null && le !== void 0 ? le : 0, ce.order = (_e = Q.order) !== null && _e !== void 0 ? _e : F.PAGINATION_ORDER_UNSPECIFIED, ce.events = ((re = Q.events) === null || re === void 0 ? void 0 : re.map((De) => De)) || [], ce.target = Q.target !== void 0 && Q.target !== null ? a.GetEventsQuery_Target.fromPartial(Q.target) : void 0, ce.afterTimestamp = (O = Q.afterTimestamp) !== null && O !== void 0 ? O : void 0, ce.beforeTimestamp = (j = Q.beforeTimestamp) !== null && j !== void 0 ? j : void 0, ce;
    }
  };
  function N() {
    return { value: "", explicitOnly: !1 };
  }
  a.GetEventsQuery_TargetValue = {
    encode(Q, le = c.default.Writer.create()) {
      return Q.value !== "" && le.uint32(10).string(Q.value), Q.explicitOnly === !0 && le.uint32(16).bool(Q.explicitOnly), le;
    },
    decode(Q, le) {
      const _e = Q instanceof c.default.Reader ? Q : new c.default.Reader(Q);
      let re = le === void 0 ? _e.len : _e.pos + le;
      const O = N();
      for (; _e.pos < re; ) {
        const j = _e.uint32();
        switch (j >>> 3) {
          case 1:
            O.value = _e.string();
            break;
          case 2:
            O.explicitOnly = _e.bool();
            break;
          default:
            _e.skipType(j & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(Q) {
      return {
        value: ve(Q.value) ? String(Q.value) : "",
        explicitOnly: ve(Q.explicitOnly) ? !!Q.explicitOnly : !1
      };
    },
    toJSON(Q) {
      const le = {};
      return Q.value !== void 0 && (le.value = Q.value), Q.explicitOnly !== void 0 && (le.explicitOnly = Q.explicitOnly), le;
    },
    fromPartial(Q) {
      var le, _e;
      const re = N();
      return re.value = (le = Q.value) !== null && le !== void 0 ? le : "", re.explicitOnly = (_e = Q.explicitOnly) !== null && _e !== void 0 ? _e : !1, re;
    }
  };
  function $() {
    return { serviceUserId: void 0, collectionId: void 0, projectId: void 0, layoutId: void 0 };
  }
  a.GetEventsQuery_Target = {
    encode(Q, le = c.default.Writer.create()) {
      return Q.serviceUserId !== void 0 && a.GetEventsQuery_TargetValue.encode(Q.serviceUserId, le.uint32(10).fork()).ldelim(), Q.collectionId !== void 0 && a.GetEventsQuery_TargetValue.encode(Q.collectionId, le.uint32(18).fork()).ldelim(), Q.projectId !== void 0 && a.GetEventsQuery_TargetValue.encode(Q.projectId, le.uint32(26).fork()).ldelim(), Q.layoutId !== void 0 && a.GetEventsQuery_TargetValue.encode(Q.layoutId, le.uint32(34).fork()).ldelim(), le;
    },
    decode(Q, le) {
      const _e = Q instanceof c.default.Reader ? Q : new c.default.Reader(Q);
      let re = le === void 0 ? _e.len : _e.pos + le;
      const O = $();
      for (; _e.pos < re; ) {
        const j = _e.uint32();
        switch (j >>> 3) {
          case 1:
            O.serviceUserId = a.GetEventsQuery_TargetValue.decode(_e, _e.uint32());
            break;
          case 2:
            O.collectionId = a.GetEventsQuery_TargetValue.decode(_e, _e.uint32());
            break;
          case 3:
            O.projectId = a.GetEventsQuery_TargetValue.decode(_e, _e.uint32());
            break;
          case 4:
            O.layoutId = a.GetEventsQuery_TargetValue.decode(_e, _e.uint32());
            break;
          default:
            _e.skipType(j & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(Q) {
      return {
        serviceUserId: ve(Q.serviceUserId) ? a.GetEventsQuery_TargetValue.fromJSON(Q.serviceUserId) : void 0,
        collectionId: ve(Q.collectionId) ? a.GetEventsQuery_TargetValue.fromJSON(Q.collectionId) : void 0,
        projectId: ve(Q.projectId) ? a.GetEventsQuery_TargetValue.fromJSON(Q.projectId) : void 0,
        layoutId: ve(Q.layoutId) ? a.GetEventsQuery_TargetValue.fromJSON(Q.layoutId) : void 0
      };
    },
    toJSON(Q) {
      const le = {};
      return Q.serviceUserId !== void 0 && (le.serviceUserId = Q.serviceUserId ? a.GetEventsQuery_TargetValue.toJSON(Q.serviceUserId) : void 0), Q.collectionId !== void 0 && (le.collectionId = Q.collectionId ? a.GetEventsQuery_TargetValue.toJSON(Q.collectionId) : void 0), Q.projectId !== void 0 && (le.projectId = Q.projectId ? a.GetEventsQuery_TargetValue.toJSON(Q.projectId) : void 0), Q.layoutId !== void 0 && (le.layoutId = Q.layoutId ? a.GetEventsQuery_TargetValue.toJSON(Q.layoutId) : void 0), le;
    },
    fromPartial(Q) {
      const le = $();
      return le.serviceUserId = Q.serviceUserId !== void 0 && Q.serviceUserId !== null ? a.GetEventsQuery_TargetValue.fromPartial(Q.serviceUserId) : void 0, le.collectionId = Q.collectionId !== void 0 && Q.collectionId !== null ? a.GetEventsQuery_TargetValue.fromPartial(Q.collectionId) : void 0, le.projectId = Q.projectId !== void 0 && Q.projectId !== null ? a.GetEventsQuery_TargetValue.fromPartial(Q.projectId) : void 0, le.layoutId = Q.layoutId !== void 0 && Q.layoutId !== null ? a.GetEventsQuery_TargetValue.fromPartial(Q.layoutId) : void 0, le;
    }
  };
  function U() {
    return { cursor: void 0, query: void 0 };
  }
  a.GetEventsRequest = {
    encode(Q, le = c.default.Writer.create()) {
      return Q.cursor !== void 0 && le.uint32(10).string(Q.cursor), Q.query !== void 0 && a.GetEventsQuery.encode(Q.query, le.uint32(18).fork()).ldelim(), le;
    },
    decode(Q, le) {
      const _e = Q instanceof c.default.Reader ? Q : new c.default.Reader(Q);
      let re = le === void 0 ? _e.len : _e.pos + le;
      const O = U();
      for (; _e.pos < re; ) {
        const j = _e.uint32();
        switch (j >>> 3) {
          case 1:
            O.cursor = _e.string();
            break;
          case 2:
            O.query = a.GetEventsQuery.decode(_e, _e.uint32());
            break;
          default:
            _e.skipType(j & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(Q) {
      return {
        cursor: ve(Q.cursor) ? String(Q.cursor) : void 0,
        query: ve(Q.query) ? a.GetEventsQuery.fromJSON(Q.query) : void 0
      };
    },
    toJSON(Q) {
      const le = {};
      return Q.cursor !== void 0 && (le.cursor = Q.cursor), Q.query !== void 0 && (le.query = Q.query ? a.GetEventsQuery.toJSON(Q.query) : void 0), le;
    },
    fromPartial(Q) {
      var le;
      const _e = U();
      return _e.cursor = (le = Q.cursor) !== null && le !== void 0 ? le : void 0, _e.query = Q.query !== void 0 && Q.query !== null ? a.GetEventsQuery.fromPartial(Q.query) : void 0, _e;
    }
  };
  function H() {
    return { events: [], nextCursor: void 0 };
  }
  a.GetEventsResponse = {
    encode(Q, le = c.default.Writer.create()) {
      for (const _e of Q.events)
        a.Event.encode(_e, le.uint32(10).fork()).ldelim();
      return Q.nextCursor !== void 0 && le.uint32(18).string(Q.nextCursor), le;
    },
    decode(Q, le) {
      const _e = Q instanceof c.default.Reader ? Q : new c.default.Reader(Q);
      let re = le === void 0 ? _e.len : _e.pos + le;
      const O = H();
      for (; _e.pos < re; ) {
        const j = _e.uint32();
        switch (j >>> 3) {
          case 1:
            O.events.push(a.Event.decode(_e, _e.uint32()));
            break;
          case 2:
            O.nextCursor = _e.string();
            break;
          default:
            _e.skipType(j & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(Q) {
      return {
        events: Array.isArray(Q == null ? void 0 : Q.events) ? Q.events.map((le) => a.Event.fromJSON(le)) : [],
        nextCursor: ve(Q.nextCursor) ? String(Q.nextCursor) : void 0
      };
    },
    toJSON(Q) {
      const le = {};
      return Q.events ? le.events = Q.events.map((_e) => _e ? a.Event.toJSON(_e) : void 0) : le.events = [], Q.nextCursor !== void 0 && (le.nextCursor = Q.nextCursor), le;
    },
    fromPartial(Q) {
      var le, _e;
      const re = H();
      return re.events = ((le = Q.events) === null || le === void 0 ? void 0 : le.map((O) => a.Event.fromPartial(O))) || [], re.nextCursor = (_e = Q.nextCursor) !== null && _e !== void 0 ? _e : void 0, re;
    }
  };
  function B() {
    return {
      name: "",
      payload: void 0,
      target: void 0,
      requestMetadata: void 0,
      id: "",
      publishedAt: void 0
    };
  }
  a.Event = {
    encode(Q, le = c.default.Writer.create()) {
      return Q.name !== "" && le.uint32(10).string(Q.name), Q.payload !== void 0 && v.Struct.encode(v.Struct.wrap(Q.payload), le.uint32(18).fork()).ldelim(), Q.target !== void 0 && a.ServiceEventTarget.encode(Q.target, le.uint32(26).fork()).ldelim(), Q.requestMetadata !== void 0 && v.Value.encode(v.Value.wrap(Q.requestMetadata), le.uint32(34).fork()).ldelim(), Q.id !== "" && le.uint32(42).string(Q.id), Q.publishedAt !== void 0 && p.Timestamp.encode(Ie(Q.publishedAt), le.uint32(50).fork()).ldelim(), le;
    },
    decode(Q, le) {
      const _e = Q instanceof c.default.Reader ? Q : new c.default.Reader(Q);
      let re = le === void 0 ? _e.len : _e.pos + le;
      const O = B();
      for (; _e.pos < re; ) {
        const j = _e.uint32();
        switch (j >>> 3) {
          case 1:
            O.name = _e.string();
            break;
          case 2:
            O.payload = v.Struct.unwrap(v.Struct.decode(_e, _e.uint32()));
            break;
          case 3:
            O.target = a.ServiceEventTarget.decode(_e, _e.uint32());
            break;
          case 4:
            O.requestMetadata = v.Value.unwrap(v.Value.decode(_e, _e.uint32()));
            break;
          case 5:
            O.id = _e.string();
            break;
          case 6:
            O.publishedAt = Pe(p.Timestamp.decode(_e, _e.uint32()));
            break;
          default:
            _e.skipType(j & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(Q) {
      return {
        name: ve(Q.name) ? String(Q.name) : "",
        payload: he(Q.payload) ? Q.payload : void 0,
        target: ve(Q.target) ? a.ServiceEventTarget.fromJSON(Q.target) : void 0,
        requestMetadata: ve(Q == null ? void 0 : Q.requestMetadata) ? Q.requestMetadata : void 0,
        id: ve(Q.id) ? String(Q.id) : "",
        publishedAt: ve(Q.publishedAt) ? String(Q.publishedAt) : void 0
      };
    },
    toJSON(Q) {
      const le = {};
      return Q.name !== void 0 && (le.name = Q.name), Q.payload !== void 0 && (le.payload = Q.payload), Q.target !== void 0 && (le.target = Q.target ? a.ServiceEventTarget.toJSON(Q.target) : void 0), Q.requestMetadata !== void 0 && (le.requestMetadata = Q.requestMetadata), Q.id !== void 0 && (le.id = Q.id), Q.publishedAt !== void 0 && (le.publishedAt = Q.publishedAt), le;
    },
    fromPartial(Q) {
      var le, _e, re, O, j;
      const ce = B();
      return ce.name = (le = Q.name) !== null && le !== void 0 ? le : "", ce.payload = (_e = Q.payload) !== null && _e !== void 0 ? _e : void 0, ce.target = Q.target !== void 0 && Q.target !== null ? a.ServiceEventTarget.fromPartial(Q.target) : void 0, ce.requestMetadata = (re = Q.requestMetadata) !== null && re !== void 0 ? re : void 0, ce.id = (O = Q.id) !== null && O !== void 0 ? O : "", ce.publishedAt = (j = Q.publishedAt) !== null && j !== void 0 ? j : void 0, ce;
    }
  };
  class T {
    constructor(le, _e) {
      this.service = (_e == null ? void 0 : _e.service) || "apis.event.v2.EventService", this.rpc = le, this.Stream = this.Stream.bind(this), this.Publish = this.Publish.bind(this);
    }
    Stream(le) {
      const _e = le.pipe(l.map((O) => a.EventsStreamRequest.encode(O).finish()));
      return this.rpc.bidirectionalStreamingRequest(this.service, "Stream", _e).pipe(l.map((O) => a.EventsStreamResponse.decode(new c.default.Reader(O))));
    }
    Publish(le) {
      const _e = a.PublishEventRequest.encode(le).finish();
      return this.rpc.request(this.service, "Publish", _e).then((O) => a.PublishEventResponse.decode(new c.default.Reader(O)));
    }
  }
  a.EventServiceClientImpl = T, a.EventServiceDefinition = {
    name: "EventService",
    fullName: "apis.event.v2.EventService",
    methods: {
      /**
       * Stream Events
       * buf:lint:ignore RPC_REQUEST_STANDARD_NAME
       * buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
       */
      stream: {
        name: "Stream",
        requestType: a.EventsStreamRequest,
        requestStream: !0,
        responseType: a.EventsStreamResponse,
        responseStream: !0,
        options: {}
      },
      /**
       * Publish Event
       * buf:lint:ignore RPC_REQUEST_STANDARD_NAME
       * buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
       */
      publish: {
        name: "Publish",
        requestType: a.PublishEventRequest,
        requestStream: !1,
        responseType: a.PublishEventResponse,
        responseStream: !1,
        options: {}
      }
    }
  };
  class D {
    constructor(le, _e) {
      this.service = (_e == null ? void 0 : _e.service) || "apis.event.v2.WebhookService", this.rpc = le, this.ListWebhookSubscriptions = this.ListWebhookSubscriptions.bind(this), this.CreateWebhookSubscription = this.CreateWebhookSubscription.bind(this), this.DeleteWebhookSubscription = this.DeleteWebhookSubscription.bind(this);
    }
    ListWebhookSubscriptions(le) {
      const _e = a.ListWebhookSubscriptionsRequest.encode(le).finish();
      return this.rpc.request(this.service, "ListWebhookSubscriptions", _e).then((O) => a.ListWebhookSubscriptionsResponse.decode(new c.default.Reader(O)));
    }
    CreateWebhookSubscription(le) {
      const _e = a.CreateWebhookSubscriptionRequest.encode(le).finish();
      return this.rpc.request(this.service, "CreateWebhookSubscription", _e).then((O) => a.CreateWebhookSubscriptionResponse.decode(new c.default.Reader(O)));
    }
    DeleteWebhookSubscription(le) {
      const _e = a.DeleteWebhookSubscriptionRequest.encode(le).finish();
      return this.rpc.request(this.service, "DeleteWebhookSubscription", _e).then((O) => a.DeleteWebhookSubscriptionResponse.decode(new c.default.Reader(O)));
    }
  }
  a.WebhookServiceClientImpl = D, a.WebhookServiceDefinition = {
    name: "WebhookService",
    fullName: "apis.event.v2.WebhookService",
    methods: {
      /** List all webhook subscriptions. */
      listWebhookSubscriptions: {
        name: "ListWebhookSubscriptions",
        requestType: a.ListWebhookSubscriptionsRequest,
        requestStream: !1,
        responseType: a.ListWebhookSubscriptionsResponse,
        responseStream: !1,
        options: {}
      },
      /** Create a new webhook subscription. */
      createWebhookSubscription: {
        name: "CreateWebhookSubscription",
        requestType: a.CreateWebhookSubscriptionRequest,
        requestStream: !1,
        responseType: a.CreateWebhookSubscriptionResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Delete a webhook subscription.
       * Existing events queued will be delivered before the subscription is removed.
       */
      deleteWebhookSubscription: {
        name: "DeleteWebhookSubscription",
        requestType: a.DeleteWebhookSubscriptionRequest,
        requestStream: !1,
        responseType: a.DeleteWebhookSubscriptionResponse,
        responseStream: !1,
        options: {}
      }
    }
  };
  class ee {
    constructor(le, _e) {
      this.service = (_e == null ? void 0 : _e.service) || "apis.event.v2.HistoryService", this.rpc = le, this.GetEvents = this.GetEvents.bind(this);
    }
    GetEvents(le) {
      const _e = a.GetEventsRequest.encode(le).finish();
      return this.rpc.request(this.service, "GetEvents", _e).then((O) => a.GetEventsResponse.decode(new c.default.Reader(O)));
    }
  }
  a.HistoryServiceClientImpl = ee, a.HistoryServiceDefinition = {
    name: "HistoryService",
    fullName: "apis.event.v2.HistoryService",
    methods: {
      getEvents: {
        name: "GetEvents",
        requestType: a.GetEventsRequest,
        requestStream: !1,
        responseType: a.GetEventsResponse,
        responseStream: !1,
        options: {}
      }
    }
  };
  var pe = (() => {
    if (typeof globalThis < "u")
      return globalThis;
    if (typeof self < "u")
      return self;
    if (typeof window < "u")
      return window;
    if (typeof commonjsGlobal$1 < "u")
      return commonjsGlobal$1;
    throw "Unable to locate global object";
  })();
  function Ie(Q) {
    const le = new Date(Q), _e = le.getTime() / 1e3, re = le.getTime() % 1e3 * 1e6;
    return { seconds: _e, nanos: re };
  }
  function Pe(Q) {
    let le = Q.seconds * 1e3;
    return le += Q.nanos / 1e6, new Date(le).toISOString();
  }
  function he(Q) {
    return typeof Q == "object" && Q !== null;
  }
  function ve(Q) {
    return Q != null;
  }
})(api$1);
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(l, v, p, _) {
    _ === void 0 && (_ = p), Object.defineProperty(l, _, { enumerable: !0, get: function() {
      return v[p];
    } });
  } : function(l, v, p, _) {
    _ === void 0 && (_ = p), l[_] = v[p];
  }), c = commonjsGlobal$1 && commonjsGlobal$1.__exportStar || function(l, v) {
    for (var p in l)
      p !== "default" && !v.hasOwnProperty(p) && u(v, l, p);
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.eventsApiSupportedEvents = a.eventsApiEventRpcCalls = void 0, c(api$1, a), a.eventsApiEventRpcCalls = {
    ping: "pong",
    publish: "published",
    subscribe: "subscribed",
    unsubscribe: "unsubscribed"
  }, a.eventsApiSupportedEvents = [...Object.values(a.eventsApiEventRpcCalls), "error", "event", "reconnectBefore"];
})(dist$1);
var ws = null;
typeof WebSocket < "u" ? ws = WebSocket : typeof MozWebSocket < "u" ? ws = MozWebSocket : typeof commonjsGlobal$1 < "u" ? ws = commonjsGlobal$1.WebSocket || commonjsGlobal$1.MozWebSocket : typeof window < "u" ? ws = window.WebSocket || window.MozWebSocket : typeof self < "u" && (ws = self.WebSocket || self.MozWebSocket);
var browser$e = ws, matcher = { exports: {} }, escapeStringRegexp$1 = (a) => {
  if (typeof a != "string")
    throw new TypeError("Expected a string");
  return a.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
};
const escapeStringRegexp = escapeStringRegexp$1, regexpCache = /* @__PURE__ */ new Map();
function sanitizeArray(a, u) {
  if (!Array.isArray(a))
    switch (typeof a) {
      case "string":
        a = [a];
        break;
      case "undefined":
        a = [];
        break;
      default:
        throw new TypeError(`Expected '${u}' to be a string or an array, but got a type of '${typeof a}'`);
    }
  return a.filter((c) => {
    if (typeof c != "string") {
      if (typeof c > "u")
        return !1;
      throw new TypeError(`Expected '${u}' to be an array of strings, but found a type of '${typeof c}' in the array`);
    }
    return !0;
  });
}
function makeRegexp(a, u) {
  u = {
    caseSensitive: !1,
    ...u
  };
  const c = a + JSON.stringify(u);
  if (regexpCache.has(c))
    return regexpCache.get(c);
  const l = a[0] === "!";
  l && (a = a.slice(1)), a = escapeStringRegexp(a).replace(/\\\*/g, "[\\s\\S]*");
  const v = new RegExp(`^${a}$`, u.caseSensitive ? "" : "i");
  return v.negated = l, regexpCache.set(c, v), v;
}
matcher.exports = (a, u, c) => {
  if (a = sanitizeArray(a, "inputs"), u = sanitizeArray(u, "patterns"), u.length === 0)
    return [];
  const l = u[0][0] === "!";
  u = u.map((p) => makeRegexp(p, c));
  const v = [];
  for (const p of a) {
    let _ = l;
    for (const k of u)
      k.test(p) && (_ = !k.negated);
    _ && v.push(p);
  }
  return v;
};
matcher.exports.isMatch = (a, u, c) => (a = sanitizeArray(a, "inputs"), u = sanitizeArray(u, "patterns"), u.length === 0 ? !1 : a.some((l) => u.every((v) => {
  const p = makeRegexp(v, c), _ = p.test(l);
  return p.negated ? !_ : _;
})));
var matcherExports = matcher.exports, __createBinding$1 = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(a, u, c, l) {
  l === void 0 && (l = c);
  var v = Object.getOwnPropertyDescriptor(u, c);
  (!v || ("get" in v ? !u.__esModule : v.writable || v.configurable)) && (v = { enumerable: !0, get: function() {
    return u[c];
  } }), Object.defineProperty(a, l, v);
} : function(a, u, c, l) {
  l === void 0 && (l = c), a[l] = u[c];
}), __setModuleDefault$1 = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(a, u) {
  Object.defineProperty(a, "default", { enumerable: !0, value: u });
} : function(a, u) {
  a.default = u;
}), __importStar$1 = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(a) {
  if (a && a.__esModule)
    return a;
  var u = {};
  if (a != null)
    for (var c in a)
      c !== "default" && Object.prototype.hasOwnProperty.call(a, c) && __createBinding$1(u, a, c);
  return __setModuleDefault$1(u, a), u;
}, __importDefault$8 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(eventapi, "__esModule", { value: !0 });
eventapi.EventApi = void 0;
const EventApiModel = __importStar$1(dist$1), isomorphic_ws_1 = __importDefault$8(browser$e), uuid_1 = require$$1$6, NiceGrpc = __importStar$1(lib$1), matcher_1 = matcherExports, api_1 = api$3, clientVersion = version$4, WS_PING_INTERVAL = 2e4, WS_PING_TIMEOUT = 1e4, WS_RECONNECT_DELAY = 2e3, WS_MAX_BADAUTH_ATTEMPTS = 3, LOG_CATEGORY = "EventApi";
class EventApi extends api_1.ApiClient {
  constructor(u, c, l, v, p, _, k) {
    super(u, c, v, LOG_CATEGORY, p, _, k), this.websocketServer = l, this.subscriptions = /* @__PURE__ */ new Set(), this.eventHandlers = {}, this.calls = {}, this.messageQueue = [], this.websocketReady = !1, this.reconnectionAttempts = 0, this.badAuthentication = !1, this.eventsClient = null, this.webhook = null, this.history = null, this.apikey !== void 0 && (this.webhook = this.clientFactory.create(EventApiModel.WebhookServiceDefinition, this.channel, {
      "*": { metadata: this.makeGrpcMetadataApikey() }
    }), this.history = this.clientFactory.create(EventApiModel.HistoryServiceDefinition, this.channel, {
      "*": { metadata: this.makeGrpcMetadataApikey() }
    }));
  }
  /**
   * Publish a custom event
   *
   * note: if this session has an established stream, all custom
   * events will use that transport.
   *
   * @param request
   * @returns
   */
  publish(...u) {
    return this.websocketReady ? this.call("publish", u[0]) : this.eventsClient.publish(...u);
  }
  /**
   * Open the connection
   */
  connect() {
    if (!this.ws) {
      this.cleanup();
      const u = this.accessToken, c = [`version=${clientVersion}`, `sessionid=${this.sessionId}`, "clienttype=nodejs"];
      this.sdkVersion && c.push(`sdkversion=${this.sdkVersion}`), this.ws = new isomorphic_ws_1.default(`${this.websocketServer}/stream?${c.join("&")}`, [
        "Bearer",
        this.accessToken
      ]);
      let l;
      this.ws.addEventListener("message", (v) => {
        const p = JSON.parse(v.data.toString()), _ = p.result;
        if (p.error && (l = p.error, this.handleEvent("error", {
          error: {
            code: p.code,
            message: p.message
          }
        }), ["You do not have permission to this resource", "You do not have permission to this resource"].includes(p.message) && (this.badAuthentication = !0)), !_)
          return;
        _.reconnectBefore && _.reconnectBefore.reauthenticate && this.accessToken === u && (this.badAuthentication = !0);
        const k = EventApiModel.eventsApiSupportedEvents.find((M) => !!_[M]);
        k && this.handleEvent(k, _);
      }), this.ws.addEventListener("open", () => {
        this.log.info("websocket connected"), this.call("ping", "hello", { timeout: WS_PING_TIMEOUT, skipQueue: !0 }).then(() => {
          this.ready();
        }).catch((v) => {
          !l && v.message !== "Stream connection closed" && this.disconnect("hello timeout");
        });
      }), this.ws.addEventListener("close", (v) => {
        var p;
        l ? this.reconnect(`${(p = l == null ? void 0 : l.message) !== null && p !== void 0 ? p : "unknown"}`) : this.reconnect(`closed - ${v.reason || v.code}`);
      }), this.ws.addEventListener("error", (v) => {
        l = v;
      });
    }
  }
  /**
   * Subscribe to an event
   *
   * note: if a connection does not exist, one will be established.
   *
   * @param type
   * @param payload
   */
  async subscribe(u, c = {}) {
    return this.call("subscribe", { name: u, ...c }).then(() => {
      this.subscriptions.add(JSON.stringify({ name: u, ...c }));
    });
  }
  /**
   * Unsubscribe from an event
   * @param type
   * @param payload
   */
  async unsubscribe(u, c = {}) {
    this.subscriptions.delete(JSON.stringify({ name: u, payload: c })), await this.call("unsubscribe", { name: u, ...c });
  }
  on(u, c, l) {
    const v = l || c, p = {
      ignoreSessionEvents: !1,
      allowedSessionEvents: [],
      ...l ? c : {}
    };
    this.eventHandlers[u] || (this.eventHandlers[u] = []), this.eventHandlers[u].push({
      ...p,
      handler: v
    });
  }
  off(u, c, l) {
    var v;
    const p = l || c, _ = {
      ignoreSessionEvents: !1,
      allowedSessionEvents: [],
      ...l ? c : {}
    };
    this.eventHandlers[u] = ((v = this.eventHandlers[u]) !== null && v !== void 0 ? v : []).filter((k) => !(k.ignoreSessionEvents === _.ignoreSessionEvents && k.allowedSessionEvents === _.allowedSessionEvents && k.handler === p && k.name === _.name));
  }
  /**
   * Disconnect the websocket connection
   */
  disconnect(u) {
    this.log.warn(`disconnected from events reason=${u}`), Object.values(this.calls).forEach((c) => {
      clearTimeout(c.timeout), c.reject(new Error("Stream connection closed"));
    }), this.calls = {}, this.cleanup();
  }
  _setup(u, c) {
    this.eventsClient = this.clientFactory.create(EventApiModel.EventServiceDefinition, this.channel, {
      "*": u
    }), this.badAuthentication && (this.badAuthentication = !1, this.reconnectionAttempts = 0, this.reconnect("updated token"));
  }
  /**
   * Called when the websocket is ready.
   */
  ready() {
    this.reconnectionAttempts = 0, this.badAuthentication = !1, this.websocketReady = !0, this.handleEvent("connected", { connected: void 0 });
    for (const u of this.subscriptions.values())
      this.send({ subscribe: JSON.parse(u), correlationId: (0, uuid_1.v4)() });
    for (const u of this.messageQueue)
      this.send(u);
    this.messageQueue = [], this.pingLoop = setInterval(() => {
      this.ping();
    }, WS_PING_INTERVAL);
  }
  ping() {
    this.call("ping", `${+/* @__PURE__ */ new Date()}`, { timeout: WS_PING_TIMEOUT }).catch(() => {
      this.reconnect("connection stalled");
    });
  }
  /**
   * Reconnect event stream
   *
   * @param reason Rec
   */
  reconnect(u) {
    this.disconnect(u), this.reconnectTimeout = setTimeout(() => {
      if (this.reconnectionAttempts++, this.badAuthentication && this.reconnectionAttempts >= WS_MAX_BADAUTH_ATTEMPTS) {
        this.log.warn("Maximum number of reconnection attempts reached with bad authentication, please re-authenticate the SDK");
        return;
      }
      this.connect();
    }, WS_RECONNECT_DELAY);
  }
  /**
   * Send a raw message to the websocket.
   *
   * @param data
   */
  send(u) {
    this.ws && this.ws.readyState === this.ws.OPEN ? this.ws.send(JSON.stringify(u)) : this.log.warn("Message sent to a disconnected stream");
  }
  /**
   * Process a stream event
   *
   * @param name the name of the event
   * @param payload the full event stream payload
   *
   * @returns void
   */
  handleEvent(u, c) {
    var l;
    if (this.calls[c.correlationId]) {
      const v = EventApiModel.eventsApiEventRpcCalls[this.calls[c.correlationId].method] === u, p = !!c.error;
      if (v || p) {
        this.resolveCall(u, c);
        return;
      }
    }
    for (const v of (l = this.eventHandlers[u]) !== null && l !== void 0 ? l : []) {
      if (u === "event" && c.event) {
        if (c.sessionId === this.sessionId && v.ignoreSessionEvents && !v.allowedSessionEvents.includes(c.event.name)) {
          this.log.trace("ignoring user event from self: " + c.event.name + ", payload.sessionId=" + c.sessionId + ", this.sessionId");
          continue;
        }
        if (v.name && !(0, matcher_1.isMatch)(c.event.name, v.name))
          continue;
        if (this.eventLogCallback) {
          let p, _ = c.event.name, k;
          if (c.event.name.startsWith(EventApi.APISTREAM_EVENT_PREFIX)) {
            let M = c.event.name.split(":");
            M.length == 4 && (p = M[1], _ = M[2], k = M[3]), this.eventLogCallback(p, _, k, c);
          }
        }
      } else if (c.sessionId === this.sessionId && v.ignoreSessionEvents) {
        this.log.trace("ignoring event from self: " + c.event.name + ", payload.sessionId=" + c.sessionId + ", this.sessionId");
        continue;
      }
      this.log.trace("processing event: payload.sessionId=" + c.sessionId + ", this.sessionId"), v.handler(c ? c[u] : void 0, { isFromCurrentSession: c.sessionId === this.sessionId });
    }
  }
  /**
   * Make an RPC call
   *
   * Initiates an async request via the stream. A correlationId is generated and used to track
   * responses and errors. A handler is registered
   *
   * @param method request method to call
   * @param payload payload to send
   * @param opts timeout
   * @returns
   */
  async call(u, c, l = { timeout: 2e4, skipQueue: !1 }) {
    this.ws || this.connect();
    const v = (0, uuid_1.v4)();
    return new Promise((p, _) => {
      const k = setTimeout(() => {
        delete this.calls[v], _(new Error("Request timed out"));
      }, l.timeout);
      this.calls[v] = { resolve: p, reject: _, timeout: k, method: u }, this.websocketReady || l.skipQueue ? this.send({ [u]: c, correlationId: v }) : this.messageQueue.push({ [u]: c, correlationId: v });
    });
  }
  /**
   * Handler for `.call()`
   *
   * Handle response events for a socket call.
   *
   * @param name name of responding event
   * @param payload payload of the event
   * @returns void
   */
  resolveCall(u, c) {
    const l = this.calls[c.correlationId];
    if (l) {
      if (clearTimeout(l.timeout), delete this.calls[c.correlationId], u === "error" && c.error) {
        l.reject(new NiceGrpc.ClientError("error", c.error.code, c.error.message));
        return;
      }
      l.resolve(c[u]);
    }
  }
  /**
   * Cleanup connection
   *
   * This cleans up the local state for a given websocket connection.
   */
  cleanup() {
    clearTimeout(this.pingLoop), clearTimeout(this.reconnectTimeout), this.websocketReady = !1, this.ws && (this.ws.onclose = function() {
    }, this.ws.close(), this.ws = null);
  }
}
eventapi.EventApi = EventApi;
EventApi.APISTREAM_EVENT_PREFIX = "apistream";
var livekit = {}, __importDefault$7 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(livekit, "__esModule", { value: !0 });
livekit.LiveKitUtils = void 0;
const jwt_decode_1 = __importDefault$7(require$$0$3);
class LiveKitUtils {
  static decodeJwt(u) {
    return (0, jwt_decode_1.default)(u, { header: !1 });
  }
  static isRoomAdmin(u) {
    return LiveKitUtils.decodeJwt(u).video.roomAdmin;
  }
  static getRoomName(u) {
    return LiveKitUtils.decodeJwt(u).video.room;
  }
}
livekit.LiveKitUtils = LiveKitUtils;
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(Ae, Z, z, P) {
    P === void 0 && (P = z);
    var S = Object.getOwnPropertyDescriptor(Z, z);
    (!S || ("get" in S ? !Z.__esModule : S.writable || S.configurable)) && (S = { enumerable: !0, get: function() {
      return Z[z];
    } }), Object.defineProperty(Ae, P, S);
  } : function(Ae, Z, z, P) {
    P === void 0 && (P = z), Ae[P] = Z[z];
  }), c = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(Ae, Z) {
    Object.defineProperty(Ae, "default", { enumerable: !0, value: Z });
  } : function(Ae, Z) {
    Ae.default = Z;
  }), l = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(Ae) {
    if (Ae && Ae.__esModule)
      return Ae;
    var Z = {};
    if (Ae != null)
      for (var z in Ae)
        z !== "default" && Object.prototype.hasOwnProperty.call(Ae, z) && u(Z, Ae, z);
    return c(Z, Ae), Z;
  }, v = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(Ae) {
    return Ae && Ae.__esModule ? Ae : { default: Ae };
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.ApiStream = a.LiveKitUtils = a.EventApiModel = a.LayoutApiModel = a.LiveApiModel = void 0;
  const p = v(require$$0$3), _ = require$$1$6, k = require$$2$1, M = layoutapi, L = liveapi, F = eventapi, V = l(api$2);
  a.LiveApiModel = V;
  const X = l(dist$2);
  a.LayoutApiModel = X;
  const oe = l(dist$1);
  a.EventApiModel = oe;
  const Y = livekit;
  Object.defineProperty(a, "LiveKitUtils", { enumerable: !0, get: function() {
    return Y.LiveKitUtils;
  } });
  const ae = logger, ne = version$4, fe = {
    dev: "http://127.0.0.1:8081",
    stage: "https://live.silly.horse/grpcweb/live/v2",
    prod: "https://live.api.stream/grpcweb/live/v2"
  }, ie = {
    dev: "https://live.silly.horse/grpcweb/layout/v2",
    stage: "https://live.silly.horse/grpcweb/layout/v2",
    prod: "https://live.api.stream/grpcweb/layout/v2"
  }, ge = {
    dev: "wss://live.silly.horse/event/v2",
    stage: "wss://live.silly.horse/event/v2",
    prod: "wss://live.api.stream/event/v2"
  }, be = {
    dev: "https://live.silly.horse/grpcweb/event/v2",
    stage: "https://live.silly.horse/grpcweb/event/v2",
    prod: "https://live.api.stream/grpcweb/event/v2"
  }, Ce = {
    dev: "wss://live.silly.horse/webrtc/v2",
    stage: "wss://live.silly.horse/webrtc/v2",
    prod: "wss://live.api.stream/webrtc/v2"
  }, Me = {
    dev: "https://live.silly.horse/webrtc/v2",
    stage: "https://live.silly.horse/webrtc/v2",
    prod: "https://live.api.stream/webrtc/v2"
  };
  class Be {
    /**
     * Create an ApiStream API Client
     */
    constructor(Z = {}) {
      var z;
      const P = {
        env: "prod",
        logLevel: "Warn",
        ...Z
      };
      this.env = P.env;
      let S = (0, _.v4)();
      P.sessionId != null && (S = P.sessionId), this.log = ae.logger.getCategory("ApiStream"), this.setLogLevel(P.env == "dev" ? "Trace" : P.logLevel);
      const E = (z = P.overrideEndpoints) !== null && z !== void 0 ? z : {};
      E.liveApiServer == null && (E.liveApiServer = fe[this.env]), E.layoutApiServer == null && (E.layoutApiServer = ie[this.env]), E.eventApiServer == null && (E.eventApiServer = be[this.env]), E.eventApiWebSocketServer == null && (E.eventApiWebSocketServer = ge[this.env]), this.eventApi = new F.EventApi(S, E.eventApiServer, E.eventApiWebSocketServer, P.sdkVersion, P.apiLogCallback, P.eventLogCallback, P.apiKey), this.layoutApi = new M.LayoutApi(S, this.eventApi, E.layoutApiServer, P.sdkVersion, P.apiLogCallback, P.apiKey), this.liveApi = new L.LiveApi(S, this.eventApi, E.liveApiServer, this.setAccessToken.bind(this), P.apiKey, P.sdkVersion, P.apiLogCallback), this.eventApi.on("reconnectBefore", (I) => {
        I.reauthenticate && this.liveApi.authentication.refreshAccessToken({}).catch(() => {
        });
      }), this.log.info("api.stream: sessionid=" + S + ", version=" + ne + ", sdkVersion=" + P.sdkVersion);
    }
    /**
     * Returns the live api client
     *
     * @returns the live api client
     */
    LiveApi() {
      return this.liveApi;
    }
    /**
     * Returns the layout api client
     *
     * @returns the layout api client
     */
    LayoutApi() {
      return this.layoutApi;
    }
    /**
     * Returns the layout api client
     *
     * @returns the layout api client
     */
    EventApi() {
      return this.eventApi;
    }
    setLogLevel(Z) {
      try {
        let z = k.LogLevel.toLogLevel(Z);
        ae.logger.updateRuntimeSettings({
          level: z
        });
      } catch {
        this.log.warn(`unknown logging level ${Z}`);
      }
    }
    setAccessToken(Z) {
      this.decodedAccessToken = Be.decodeAccessToken(Z), this.log.debug("setting accessToken", Z, this.decodedAccessToken), this.layoutApi.setAccessToken(Z), this.liveApi.setAccessToken(Z), this.eventApi.setAccessToken(Z);
    }
    getAccessToken() {
      return this.decodedAccessToken;
    }
    /**
     * Are we running as a guest role?
     *
     * @returns {(ApiStream.GuestProject | null)} return the active project if running as a guest role
     */
    getGuestProject() {
      return this.decodedAccessToken.guestControl;
    }
    /**
     * Initialize the api library and check if we are running inside of the rendering engine
     * @async
     * @param {string} accessToken - a valid ApiStream access token
     * @returns {(ApiStream.GuestProject | null)} if we are operating inside of the rendering engine, this is the active project
     */
    async load(Z) {
      if (Z == null && typeof window < "u") {
        let z = this.parseQuery();
        z.get(Be.ACCESS_TOKEN_QUERY_PARAM) != null && (Z = z.get(Be.ACCESS_TOKEN_QUERY_PARAM));
      }
      return Z != null && (this.setAccessToken(Z), this.decodedAccessToken.guestControl != null) ? (this.log.info("loading guest token and exchanging"), await this.LiveApi().authentication.refreshAccessToken({}), this.log.info("auto-loading project = " + JSON.stringify(this.decodedAccessToken.guestControl)), this.decodedAccessToken.guestControl) : null;
    }
    /**
     * get the signaling address of the appropriate livekit webrtc server
     *
     * @param {boolean} admin - if true, return the admin (vs. client) address
     * @returns {string} the address of the appropriate livekit webrtc server
     */
    getLiveKitServer(Z = !1) {
      return Z ? Me[this.env] : Ce[this.env];
    }
    parseQuery() {
      let Z = window.location.search, z = /* @__PURE__ */ new Map(), P = (Z[0] === "?" ? Z.substr(1) : Z).split("&");
      for (let S = 0; S < P.length; S++) {
        let E = P[S].split("=");
        E.length == 2 && (z.set(decodeURIComponent(E[0]), decodeURIComponent(E[1] || "")), this.log.debug(`found query param: ${decodeURIComponent(E[0])}=${decodeURIComponent(E[1] || "")}`));
      }
      return z;
    }
    static decodeAccessToken(Z) {
      let z = (0, p.default)(Z, { header: !1 }), P = {
        serviceUserId: z.user.serviceUserId,
        userId: z.user.userId,
        displayName: z.user.displayName,
        trial: z.user.trial,
        demo: z.user.demo
      };
      return z.guestControl != null && (P.guestControl = {
        collectionId: z.guestControl.collectionId,
        projectId: z.guestControl.projectId,
        role: V.roleFromJSON(z.guestControl.role)
      }), P;
    }
  }
  a.ApiStream = Be, Be.ACCESS_TOKEN_QUERY_PARAM = "at";
})(lib$2);
const config$2 = (a) => ({
  defaults: {
    previewTokenDuration: 1e3 * 60 * 60,
    guestTokenDuration: 1e3 * 60 * 60 * 12,
    transforms: {
      RoomParticipant: "LS-Room-Participant",
      Image: "LS-Image",
      Banner: "LS-Banner",
      Text: "LS-Text"
    }
  }
});
var fastDeepEqual = function a(u, c) {
  if (u === c)
    return !0;
  if (u && c && typeof u == "object" && typeof c == "object") {
    if (u.constructor !== c.constructor)
      return !1;
    var l, v, p;
    if (Array.isArray(u)) {
      if (l = u.length, l != c.length)
        return !1;
      for (v = l; v-- !== 0; )
        if (!a(u[v], c[v]))
          return !1;
      return !0;
    }
    if (u.constructor === RegExp)
      return u.source === c.source && u.flags === c.flags;
    if (u.valueOf !== Object.prototype.valueOf)
      return u.valueOf() === c.valueOf();
    if (u.toString !== Object.prototype.toString)
      return u.toString() === c.toString();
    if (p = Object.keys(u), l = p.length, l !== Object.keys(c).length)
      return !1;
    for (v = l; v-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(c, p[v]))
        return !1;
    for (v = l; v-- !== 0; ) {
      var _ = p[v];
      if (!a(u[_], c[_]))
        return !1;
    }
    return !0;
  }
  return u !== u && c !== c;
};
const deepEqual = /* @__PURE__ */ getDefaultExportFromCjs$2(fastDeepEqual);
var freeGlobal = typeof global$1 == "object" && global$1 && global$1.Object === Object && global$1, freeSelf = typeof self == "object" && self && self.Object === Object && self, root = freeGlobal || freeSelf || Function("return this")(), Symbol$1 = root.Symbol, objectProto$m = Object.prototype, hasOwnProperty$f = objectProto$m.hasOwnProperty, nativeObjectToString$1 = objectProto$m.toString, symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : void 0;
function getRawTag(a) {
  var u = hasOwnProperty$f.call(a, symToStringTag$1), c = a[symToStringTag$1];
  try {
    a[symToStringTag$1] = void 0;
    var l = !0;
  } catch {
  }
  var v = nativeObjectToString$1.call(a);
  return l && (u ? a[symToStringTag$1] = c : delete a[symToStringTag$1]), v;
}
var objectProto$l = Object.prototype, nativeObjectToString = objectProto$l.toString;
function objectToString$7(a) {
  return nativeObjectToString.call(a);
}
var nullTag = "[object Null]", undefinedTag = "[object Undefined]", symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
function baseGetTag(a) {
  return a == null ? a === void 0 ? undefinedTag : nullTag : symToStringTag && symToStringTag in Object(a) ? getRawTag(a) : objectToString$7(a);
}
function isObjectLike$7(a) {
  return a != null && typeof a == "object";
}
var symbolTag$6 = "[object Symbol]";
function isSymbol$3(a) {
  return typeof a == "symbol" || isObjectLike$7(a) && baseGetTag(a) == symbolTag$6;
}
function arrayMap$1(a, u) {
  for (var c = -1, l = a == null ? 0 : a.length, v = Array(l); ++c < l; )
    v[c] = u(a[c], c, a);
  return v;
}
var isArray$4 = Array.isArray, INFINITY$4 = 1 / 0, symbolProto$2 = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString = symbolProto$2 ? symbolProto$2.toString : void 0;
function baseToString(a) {
  if (typeof a == "string")
    return a;
  if (isArray$4(a))
    return arrayMap$1(a, baseToString) + "";
  if (isSymbol$3(a))
    return symbolToString ? symbolToString.call(a) : "";
  var u = a + "";
  return u == "0" && 1 / a == -INFINITY$4 ? "-0" : u;
}
var reWhitespace = /\s/;
function trimmedEndIndex(a) {
  for (var u = a.length; u-- && reWhitespace.test(a.charAt(u)); )
    ;
  return u;
}
var reTrimStart = /^\s+/;
function baseTrim(a) {
  return a && a.slice(0, trimmedEndIndex(a) + 1).replace(reTrimStart, "");
}
function isObject$8(a) {
  var u = typeof a;
  return a != null && (u == "object" || u == "function");
}
var NAN$3 = NaN, reIsBadHex$3 = /^[-+]0x[0-9a-f]+$/i, reIsBinary$3 = /^0b[01]+$/i, reIsOctal$3 = /^0o[0-7]+$/i, freeParseInt$3 = parseInt;
function toNumber$3(a) {
  if (typeof a == "number")
    return a;
  if (isSymbol$3(a))
    return NAN$3;
  if (isObject$8(a)) {
    var u = typeof a.valueOf == "function" ? a.valueOf() : a;
    a = isObject$8(u) ? u + "" : u;
  }
  if (typeof a != "string")
    return a === 0 ? a : +a;
  a = baseTrim(a);
  var c = reIsBinary$3.test(a);
  return c || reIsOctal$3.test(a) ? freeParseInt$3(a.slice(2), c ? 2 : 8) : reIsBadHex$3.test(a) ? NAN$3 : +a;
}
function identity(a) {
  return a;
}
var asyncTag = "[object AsyncFunction]", funcTag$3 = "[object Function]", genTag$2 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction$2(a) {
  if (!isObject$8(a))
    return !1;
  var u = baseGetTag(a);
  return u == funcTag$3 || u == genTag$2 || u == asyncTag || u == proxyTag;
}
var coreJsData = root["__core-js_shared__"], maskSrcKey = function() {
  var a = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return a ? "Symbol(src)_1." + a : "";
}();
function isMasked(a) {
  return !!maskSrcKey && maskSrcKey in a;
}
var funcProto$3 = Function.prototype, funcToString$3 = funcProto$3.toString;
function toSource(a) {
  if (a != null) {
    try {
      return funcToString$3.call(a);
    } catch {
    }
    try {
      return a + "";
    } catch {
    }
  }
  return "";
}
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reIsHostCtor = /^\[object .+?Constructor\]$/, funcProto$2 = Function.prototype, objectProto$k = Object.prototype, funcToString$2 = funcProto$2.toString, hasOwnProperty$e = objectProto$k.hasOwnProperty, reIsNative = RegExp(
  "^" + funcToString$2.call(hasOwnProperty$e).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative(a) {
  if (!isObject$8(a) || isMasked(a))
    return !1;
  var u = isFunction$2(a) ? reIsNative : reIsHostCtor;
  return u.test(toSource(a));
}
function getValue(a, u) {
  return a == null ? void 0 : a[u];
}
function getNative(a, u) {
  var c = getValue(a, u);
  return baseIsNative(c) ? c : void 0;
}
var WeakMap$2 = getNative(root, "WeakMap"), objectCreate = Object.create, baseCreate = /* @__PURE__ */ function() {
  function a() {
  }
  return function(u) {
    if (!isObject$8(u))
      return {};
    if (objectCreate)
      return objectCreate(u);
    a.prototype = u;
    var c = new a();
    return a.prototype = void 0, c;
  };
}();
function apply(a, u, c) {
  switch (c.length) {
    case 0:
      return a.call(u);
    case 1:
      return a.call(u, c[0]);
    case 2:
      return a.call(u, c[0], c[1]);
    case 3:
      return a.call(u, c[0], c[1], c[2]);
  }
  return a.apply(u, c);
}
function copyArray(a, u) {
  var c = -1, l = a.length;
  for (u || (u = Array(l)); ++c < l; )
    u[c] = a[c];
  return u;
}
var HOT_COUNT = 800, HOT_SPAN = 16, nativeNow = Date.now;
function shortOut(a) {
  var u = 0, c = 0;
  return function() {
    var l = nativeNow(), v = HOT_SPAN - (l - c);
    if (c = l, v > 0) {
      if (++u >= HOT_COUNT)
        return arguments[0];
    } else
      u = 0;
    return a.apply(void 0, arguments);
  };
}
function constant(a) {
  return function() {
    return a;
  };
}
var defineProperty = function() {
  try {
    var a = getNative(Object, "defineProperty");
    return a({}, "", {}), a;
  } catch {
  }
}(), baseSetToString = defineProperty ? function(a, u) {
  return defineProperty(a, "toString", {
    configurable: !0,
    enumerable: !1,
    value: constant(u),
    writable: !0
  });
} : identity;
const baseSetToString$1 = baseSetToString;
var setToString = shortOut(baseSetToString$1);
function arrayEach(a, u) {
  for (var c = -1, l = a == null ? 0 : a.length; ++c < l && u(a[c], c, a) !== !1; )
    ;
  return a;
}
function baseFindIndex$1(a, u, c, l) {
  for (var v = a.length, p = c + (l ? 1 : -1); l ? p-- : ++p < v; )
    if (u(a[p], p, a))
      return p;
  return -1;
}
function baseIsNaN$1(a) {
  return a !== a;
}
function strictIndexOf(a, u, c) {
  for (var l = c - 1, v = a.length; ++l < v; )
    if (a[l] === u)
      return l;
  return -1;
}
function baseIndexOf$1(a, u, c) {
  return u === u ? strictIndexOf(a, u, c) : baseFindIndex$1(a, baseIsNaN$1, c);
}
var MAX_SAFE_INTEGER$2 = 9007199254740991, reIsUint$1 = /^(?:0|[1-9]\d*)$/;
function isIndex$1(a, u) {
  var c = typeof a;
  return u = u ?? MAX_SAFE_INTEGER$2, !!u && (c == "number" || c != "symbol" && reIsUint$1.test(a)) && a > -1 && a % 1 == 0 && a < u;
}
function baseAssignValue(a, u, c) {
  u == "__proto__" && defineProperty ? defineProperty(a, u, {
    configurable: !0,
    enumerable: !0,
    value: c,
    writable: !0
  }) : a[u] = c;
}
function eq(a, u) {
  return a === u || a !== a && u !== u;
}
var objectProto$j = Object.prototype, hasOwnProperty$d = objectProto$j.hasOwnProperty;
function assignValue(a, u, c) {
  var l = a[u];
  (!(hasOwnProperty$d.call(a, u) && eq(l, c)) || c === void 0 && !(u in a)) && baseAssignValue(a, u, c);
}
function copyObject(a, u, c, l) {
  var v = !c;
  c || (c = {});
  for (var p = -1, _ = u.length; ++p < _; ) {
    var k = u[p], M = l ? l(c[k], a[k], k, c, a) : void 0;
    M === void 0 && (M = a[k]), v ? baseAssignValue(c, k, M) : assignValue(c, k, M);
  }
  return c;
}
var nativeMax$2 = Math.max;
function overRest(a, u, c) {
  return u = nativeMax$2(u === void 0 ? a.length - 1 : u, 0), function() {
    for (var l = arguments, v = -1, p = nativeMax$2(l.length - u, 0), _ = Array(p); ++v < p; )
      _[v] = l[u + v];
    v = -1;
    for (var k = Array(u + 1); ++v < u; )
      k[v] = l[v];
    return k[u] = c(_), apply(a, this, k);
  };
}
function baseRest(a, u) {
  return setToString(overRest(a, u, identity), a + "");
}
var MAX_SAFE_INTEGER$1 = 9007199254740991;
function isLength$1(a) {
  return typeof a == "number" && a > -1 && a % 1 == 0 && a <= MAX_SAFE_INTEGER$1;
}
function isArrayLike$1(a) {
  return a != null && isLength$1(a.length) && !isFunction$2(a);
}
function isIterateeCall(a, u, c) {
  if (!isObject$8(c))
    return !1;
  var l = typeof u;
  return (l == "number" ? isArrayLike$1(c) && isIndex$1(u, c.length) : l == "string" && u in c) ? eq(c[u], a) : !1;
}
var objectProto$i = Object.prototype;
function isPrototype$1(a) {
  var u = a && a.constructor, c = typeof u == "function" && u.prototype || objectProto$i;
  return a === c;
}
function baseTimes$1(a, u) {
  for (var c = -1, l = Array(a); ++c < a; )
    l[c] = u(c);
  return l;
}
var argsTag$4 = "[object Arguments]";
function baseIsArguments(a) {
  return isObjectLike$7(a) && baseGetTag(a) == argsTag$4;
}
var objectProto$h = Object.prototype, hasOwnProperty$c = objectProto$h.hasOwnProperty, propertyIsEnumerable$2 = objectProto$h.propertyIsEnumerable, isArguments$2 = baseIsArguments(/* @__PURE__ */ function() {
  return arguments;
}()) ? baseIsArguments : function(a) {
  return isObjectLike$7(a) && hasOwnProperty$c.call(a, "callee") && !propertyIsEnumerable$2.call(a, "callee");
};
function stubFalse() {
  return !1;
}
var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports, freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module, moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2, Buffer$N = moduleExports$2 ? root.Buffer : void 0, nativeIsBuffer = Buffer$N ? Buffer$N.isBuffer : void 0, isBuffer$1 = nativeIsBuffer || stubFalse, argsTag$3 = "[object Arguments]", arrayTag$2 = "[object Array]", boolTag$4 = "[object Boolean]", dateTag$3 = "[object Date]", errorTag$2 = "[object Error]", funcTag$2 = "[object Function]", mapTag$5 = "[object Map]", numberTag$4 = "[object Number]", objectTag$5 = "[object Object]", regexpTag$3 = "[object RegExp]", setTag$5 = "[object Set]", stringTag$5 = "[object String]", weakMapTag$2 = "[object WeakMap]", arrayBufferTag$3 = "[object ArrayBuffer]", dataViewTag$4 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]", typedArrayTags = {};
typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = !0;
typedArrayTags[argsTag$3] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$3] = typedArrayTags[boolTag$4] = typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$3] = typedArrayTags[errorTag$2] = typedArrayTags[funcTag$2] = typedArrayTags[mapTag$5] = typedArrayTags[numberTag$4] = typedArrayTags[objectTag$5] = typedArrayTags[regexpTag$3] = typedArrayTags[setTag$5] = typedArrayTags[stringTag$5] = typedArrayTags[weakMapTag$2] = !1;
function baseIsTypedArray(a) {
  return isObjectLike$7(a) && isLength$1(a.length) && !!typedArrayTags[baseGetTag(a)];
}
function baseUnary(a) {
  return function(u) {
    return a(u);
  };
}
var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports, freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module, moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1, freeProcess = moduleExports$1 && freeGlobal.process, nodeUtil = function() {
  try {
    var a = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
    return a || freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch {
  }
}(), nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray, isTypedArray$1 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray, objectProto$g = Object.prototype, hasOwnProperty$b = objectProto$g.hasOwnProperty;
function arrayLikeKeys$1(a, u) {
  var c = isArray$4(a), l = !c && isArguments$2(a), v = !c && !l && isBuffer$1(a), p = !c && !l && !v && isTypedArray$1(a), _ = c || l || v || p, k = _ ? baseTimes$1(a.length, String) : [], M = k.length;
  for (var L in a)
    (u || hasOwnProperty$b.call(a, L)) && !(_ && // Safari 9 has enumerable `arguments.length` in strict mode.
    (L == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    v && (L == "offset" || L == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    p && (L == "buffer" || L == "byteLength" || L == "byteOffset") || // Skip index properties.
    isIndex$1(L, M))) && k.push(L);
  return k;
}
function overArg$2(a, u) {
  return function(c) {
    return a(u(c));
  };
}
var nativeKeys$1 = overArg$2(Object.keys, Object), objectProto$f = Object.prototype, hasOwnProperty$a = objectProto$f.hasOwnProperty;
function baseKeys$1(a) {
  if (!isPrototype$1(a))
    return nativeKeys$1(a);
  var u = [];
  for (var c in Object(a))
    hasOwnProperty$a.call(a, c) && c != "constructor" && u.push(c);
  return u;
}
function keys$2(a) {
  return isArrayLike$1(a) ? arrayLikeKeys$1(a) : baseKeys$1(a);
}
function nativeKeysIn(a) {
  var u = [];
  if (a != null)
    for (var c in Object(a))
      u.push(c);
  return u;
}
var objectProto$e = Object.prototype, hasOwnProperty$9 = objectProto$e.hasOwnProperty;
function baseKeysIn(a) {
  if (!isObject$8(a))
    return nativeKeysIn(a);
  var u = isPrototype$1(a), c = [];
  for (var l in a)
    l == "constructor" && (u || !hasOwnProperty$9.call(a, l)) || c.push(l);
  return c;
}
function keysIn(a) {
  return isArrayLike$1(a) ? arrayLikeKeys$1(a, !0) : baseKeysIn(a);
}
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
function isKey(a, u) {
  if (isArray$4(a))
    return !1;
  var c = typeof a;
  return c == "number" || c == "symbol" || c == "boolean" || a == null || isSymbol$3(a) ? !0 : reIsPlainProp.test(a) || !reIsDeepProp.test(a) || u != null && a in Object(u);
}
var nativeCreate = getNative(Object, "create");
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {}, this.size = 0;
}
function hashDelete(a) {
  var u = this.has(a) && delete this.__data__[a];
  return this.size -= u ? 1 : 0, u;
}
var HASH_UNDEFINED$2 = "__lodash_hash_undefined__", objectProto$d = Object.prototype, hasOwnProperty$8 = objectProto$d.hasOwnProperty;
function hashGet(a) {
  var u = this.__data__;
  if (nativeCreate) {
    var c = u[a];
    return c === HASH_UNDEFINED$2 ? void 0 : c;
  }
  return hasOwnProperty$8.call(u, a) ? u[a] : void 0;
}
var objectProto$c = Object.prototype, hasOwnProperty$7 = objectProto$c.hasOwnProperty;
function hashHas(a) {
  var u = this.__data__;
  return nativeCreate ? u[a] !== void 0 : hasOwnProperty$7.call(u, a);
}
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
function hashSet(a, u) {
  var c = this.__data__;
  return this.size += this.has(a) ? 0 : 1, c[a] = nativeCreate && u === void 0 ? HASH_UNDEFINED$1 : u, this;
}
function Hash$8(a) {
  var u = -1, c = a == null ? 0 : a.length;
  for (this.clear(); ++u < c; ) {
    var l = a[u];
    this.set(l[0], l[1]);
  }
}
Hash$8.prototype.clear = hashClear;
Hash$8.prototype.delete = hashDelete;
Hash$8.prototype.get = hashGet;
Hash$8.prototype.has = hashHas;
Hash$8.prototype.set = hashSet;
function listCacheClear() {
  this.__data__ = [], this.size = 0;
}
function assocIndexOf(a, u) {
  for (var c = a.length; c--; )
    if (eq(a[c][0], u))
      return c;
  return -1;
}
var arrayProto$1 = Array.prototype, splice$1 = arrayProto$1.splice;
function listCacheDelete(a) {
  var u = this.__data__, c = assocIndexOf(u, a);
  if (c < 0)
    return !1;
  var l = u.length - 1;
  return c == l ? u.pop() : splice$1.call(u, c, 1), --this.size, !0;
}
function listCacheGet(a) {
  var u = this.__data__, c = assocIndexOf(u, a);
  return c < 0 ? void 0 : u[c][1];
}
function listCacheHas(a) {
  return assocIndexOf(this.__data__, a) > -1;
}
function listCacheSet(a, u) {
  var c = this.__data__, l = assocIndexOf(c, a);
  return l < 0 ? (++this.size, c.push([a, u])) : c[l][1] = u, this;
}
function ListCache(a) {
  var u = -1, c = a == null ? 0 : a.length;
  for (this.clear(); ++u < c; ) {
    var l = a[u];
    this.set(l[0], l[1]);
  }
}
ListCache.prototype.clear = listCacheClear;
ListCache.prototype.delete = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
var Map$1 = getNative(root, "Map");
function mapCacheClear() {
  this.size = 0, this.__data__ = {
    hash: new Hash$8(),
    map: new (Map$1 || ListCache)(),
    string: new Hash$8()
  };
}
function isKeyable(a) {
  var u = typeof a;
  return u == "string" || u == "number" || u == "symbol" || u == "boolean" ? a !== "__proto__" : a === null;
}
function getMapData(a, u) {
  var c = a.__data__;
  return isKeyable(u) ? c[typeof u == "string" ? "string" : "hash"] : c.map;
}
function mapCacheDelete(a) {
  var u = getMapData(this, a).delete(a);
  return this.size -= u ? 1 : 0, u;
}
function mapCacheGet(a) {
  return getMapData(this, a).get(a);
}
function mapCacheHas(a) {
  return getMapData(this, a).has(a);
}
function mapCacheSet(a, u) {
  var c = getMapData(this, a), l = c.size;
  return c.set(a, u), this.size += c.size == l ? 0 : 1, this;
}
function MapCache(a) {
  var u = -1, c = a == null ? 0 : a.length;
  for (this.clear(); ++u < c; ) {
    var l = a[u];
    this.set(l[0], l[1]);
  }
}
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype.delete = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
var FUNC_ERROR_TEXT$2 = "Expected a function";
function memoize(a, u) {
  if (typeof a != "function" || u != null && typeof u != "function")
    throw new TypeError(FUNC_ERROR_TEXT$2);
  var c = function() {
    var l = arguments, v = u ? u.apply(this, l) : l[0], p = c.cache;
    if (p.has(v))
      return p.get(v);
    var _ = a.apply(this, l);
    return c.cache = p.set(v, _) || p, _;
  };
  return c.cache = new (memoize.Cache || MapCache)(), c;
}
memoize.Cache = MapCache;
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(a) {
  var u = memoize(a, function(l) {
    return c.size === MAX_MEMOIZE_SIZE && c.clear(), l;
  }), c = u.cache;
  return u;
}
var rePropName$1 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, reEscapeChar$1 = /\\(\\)?/g, stringToPath$1 = memoizeCapped(function(a) {
  var u = [];
  return a.charCodeAt(0) === 46 && u.push(""), a.replace(rePropName$1, function(c, l, v, p) {
    u.push(v ? p.replace(reEscapeChar$1, "$1") : l || c);
  }), u;
});
function toString$3(a) {
  return a == null ? "" : baseToString(a);
}
function castPath(a, u) {
  return isArray$4(a) ? a : isKey(a, u) ? [a] : stringToPath$1(toString$3(a));
}
var INFINITY$3 = 1 / 0;
function toKey(a) {
  if (typeof a == "string" || isSymbol$3(a))
    return a;
  var u = a + "";
  return u == "0" && 1 / a == -INFINITY$3 ? "-0" : u;
}
function baseGet(a, u) {
  u = castPath(u, a);
  for (var c = 0, l = u.length; a != null && c < l; )
    a = a[toKey(u[c++])];
  return c && c == l ? a : void 0;
}
function get(a, u, c) {
  var l = a == null ? void 0 : baseGet(a, u);
  return l === void 0 ? c : l;
}
function arrayPush(a, u) {
  for (var c = -1, l = u.length, v = a.length; ++c < l; )
    a[v + c] = u[c];
  return a;
}
var spreadableSymbol = Symbol$1 ? Symbol$1.isConcatSpreadable : void 0;
function isFlattenable(a) {
  return isArray$4(a) || isArguments$2(a) || !!(spreadableSymbol && a && a[spreadableSymbol]);
}
function baseFlatten(a, u, c, l, v) {
  var p = -1, _ = a.length;
  for (c || (c = isFlattenable), v || (v = []); ++p < _; ) {
    var k = a[p];
    u > 0 && c(k) ? u > 1 ? baseFlatten(k, u - 1, c, l, v) : arrayPush(v, k) : l || (v[v.length] = k);
  }
  return v;
}
function flatten(a) {
  var u = a == null ? 0 : a.length;
  return u ? baseFlatten(a, 1) : [];
}
function flatRest(a) {
  return setToString(overRest(a, void 0, flatten), a + "");
}
var getPrototype$1 = overArg$2(Object.getPrototypeOf, Object);
const getPrototype$2 = getPrototype$1;
var objectTag$4 = "[object Object]", funcProto$1 = Function.prototype, objectProto$b = Object.prototype, funcToString$1 = funcProto$1.toString, hasOwnProperty$6 = objectProto$b.hasOwnProperty, objectCtorString$1 = funcToString$1.call(Object);
function isPlainObject$3(a) {
  if (!isObjectLike$7(a) || baseGetTag(a) != objectTag$4)
    return !1;
  var u = getPrototype$2(a);
  if (u === null)
    return !0;
  var c = hasOwnProperty$6.call(u, "constructor") && u.constructor;
  return typeof c == "function" && c instanceof c && funcToString$1.call(c) == objectCtorString$1;
}
function baseSlice(a, u, c) {
  var l = -1, v = a.length;
  u < 0 && (u = -u > v ? 0 : v + u), c = c > v ? v : c, c < 0 && (c += v), v = u > c ? 0 : c - u >>> 0, u >>>= 0;
  for (var p = Array(v); ++l < v; )
    p[l] = a[l + u];
  return p;
}
function castSlice(a, u, c) {
  var l = a.length;
  return c = c === void 0 ? l : c, !u && c >= l ? a : baseSlice(a, u, c);
}
var rsAstralRange$2 = "\\ud800-\\udfff", rsComboMarksRange$3 = "\\u0300-\\u036f", reComboHalfMarksRange$3 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$3 = "\\u20d0-\\u20ff", rsComboRange$3 = rsComboMarksRange$3 + reComboHalfMarksRange$3 + rsComboSymbolsRange$3, rsVarRange$2 = "\\ufe0e\\ufe0f", rsZWJ$2 = "\\u200d", reHasUnicode = RegExp("[" + rsZWJ$2 + rsAstralRange$2 + rsComboRange$3 + rsVarRange$2 + "]");
function hasUnicode(a) {
  return reHasUnicode.test(a);
}
function asciiToArray(a) {
  return a.split("");
}
var rsAstralRange$1 = "\\ud800-\\udfff", rsComboMarksRange$2 = "\\u0300-\\u036f", reComboHalfMarksRange$2 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$2 = "\\u20d0-\\u20ff", rsComboRange$2 = rsComboMarksRange$2 + reComboHalfMarksRange$2 + rsComboSymbolsRange$2, rsVarRange$1 = "\\ufe0e\\ufe0f", rsAstral = "[" + rsAstralRange$1 + "]", rsCombo$2 = "[" + rsComboRange$2 + "]", rsFitz$1 = "\\ud83c[\\udffb-\\udfff]", rsModifier$1 = "(?:" + rsCombo$2 + "|" + rsFitz$1 + ")", rsNonAstral$1 = "[^" + rsAstralRange$1 + "]", rsRegional$1 = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair$1 = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsZWJ$1 = "\\u200d", reOptMod$1 = rsModifier$1 + "?", rsOptVar$1 = "[" + rsVarRange$1 + "]?", rsOptJoin$1 = "(?:" + rsZWJ$1 + "(?:" + [rsNonAstral$1, rsRegional$1, rsSurrPair$1].join("|") + ")" + rsOptVar$1 + reOptMod$1 + ")*", rsSeq$1 = rsOptVar$1 + reOptMod$1 + rsOptJoin$1, rsSymbol = "(?:" + [rsNonAstral$1 + rsCombo$2 + "?", rsCombo$2, rsRegional$1, rsSurrPair$1, rsAstral].join("|") + ")", reUnicode = RegExp(rsFitz$1 + "(?=" + rsFitz$1 + ")|" + rsSymbol + rsSeq$1, "g");
function unicodeToArray(a) {
  return a.match(reUnicode) || [];
}
function stringToArray(a) {
  return hasUnicode(a) ? unicodeToArray(a) : asciiToArray(a);
}
function createCaseFirst(a) {
  return function(u) {
    u = toString$3(u);
    var c = hasUnicode(u) ? stringToArray(u) : void 0, l = c ? c[0] : u.charAt(0), v = c ? castSlice(c, 1).join("") : u.slice(1);
    return l[a]() + v;
  };
}
var upperFirst = createCaseFirst("toUpperCase");
function capitalize(a) {
  return upperFirst(toString$3(a).toLowerCase());
}
function arrayReduce(a, u, c, l) {
  var v = -1, p = a == null ? 0 : a.length;
  for (l && p && (c = a[++v]); ++v < p; )
    c = u(c, a[v], v, a);
  return c;
}
function basePropertyOf(a) {
  return function(u) {
    return a == null ? void 0 : a[u];
  };
}
var deburredLetters = {
  // Latin-1 Supplement block.
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "C",
  : "c",
  : "D",
  : "d",
  : "E",
  : "E",
  : "E",
  : "E",
  : "e",
  : "e",
  : "e",
  : "e",
  : "I",
  : "I",
  : "I",
  : "I",
  : "i",
  : "i",
  : "i",
  : "i",
  : "N",
  : "n",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "U",
  : "U",
  : "U",
  : "U",
  : "u",
  : "u",
  : "u",
  : "u",
  : "Y",
  : "y",
  : "y",
  : "Ae",
  : "ae",
  : "Th",
  : "th",
  : "ss",
  // Latin Extended-A block.
  : "A",
  : "A",
  : "A",
  : "a",
  : "a",
  : "a",
  : "C",
  : "C",
  : "C",
  : "C",
  : "c",
  : "c",
  : "c",
  : "c",
  : "D",
  : "D",
  : "d",
  : "d",
  : "E",
  : "E",
  : "E",
  : "E",
  : "E",
  : "e",
  : "e",
  : "e",
  : "e",
  : "e",
  : "G",
  : "G",
  : "G",
  : "G",
  : "g",
  : "g",
  : "g",
  : "g",
  : "H",
  : "H",
  : "h",
  : "h",
  : "I",
  : "I",
  : "I",
  : "I",
  : "I",
  : "i",
  : "i",
  : "i",
  : "i",
  : "i",
  : "J",
  : "j",
  : "K",
  : "k",
  : "k",
  : "L",
  : "L",
  : "L",
  : "L",
  : "L",
  : "l",
  : "l",
  : "l",
  : "l",
  : "l",
  : "N",
  : "N",
  : "N",
  : "N",
  : "n",
  : "n",
  : "n",
  : "n",
  : "O",
  : "O",
  : "O",
  : "o",
  : "o",
  : "o",
  : "R",
  : "R",
  : "R",
  : "r",
  : "r",
  : "r",
  : "S",
  : "S",
  : "S",
  : "S",
  : "s",
  : "s",
  : "s",
  : "s",
  : "T",
  : "T",
  : "T",
  : "t",
  : "t",
  : "t",
  : "U",
  : "U",
  : "U",
  : "U",
  : "U",
  : "U",
  : "u",
  : "u",
  : "u",
  : "u",
  : "u",
  : "u",
  : "W",
  : "w",
  : "Y",
  : "y",
  : "Y",
  : "Z",
  : "Z",
  : "Z",
  : "z",
  : "z",
  : "z",
  : "IJ",
  : "ij",
  : "Oe",
  : "oe",
  : "'n",
  : "s"
}, deburrLetter = basePropertyOf(deburredLetters);
const deburrLetter$1 = deburrLetter;
var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, rsComboMarksRange$1 = "\\u0300-\\u036f", reComboHalfMarksRange$1 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$1 = "\\u20d0-\\u20ff", rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1, rsCombo$1 = "[" + rsComboRange$1 + "]", reComboMark = RegExp(rsCombo$1, "g");
function deburr(a) {
  return a = toString$3(a), a && a.replace(reLatin, deburrLetter$1).replace(reComboMark, "");
}
var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
function asciiWords(a) {
  return a.match(reAsciiWord) || [];
}
var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
function hasUnicodeWord(a) {
  return reHasUnicodeWord.test(a);
}
var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange, rsApos$1 = "[']", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d", rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos$1 + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos$1 + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, reUnicodeWord = RegExp([
  rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
  rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
  rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
  rsUpper + "+" + rsOptContrUpper,
  rsOrdUpper,
  rsOrdLower,
  rsDigits,
  rsEmoji
].join("|"), "g");
function unicodeWords(a) {
  return a.match(reUnicodeWord) || [];
}
function words(a, u, c) {
  return a = toString$3(a), u = c ? void 0 : u, u === void 0 ? hasUnicodeWord(a) ? unicodeWords(a) : asciiWords(a) : a.match(u) || [];
}
var rsApos = "[']", reApos = RegExp(rsApos, "g");
function createCompounder(a) {
  return function(u) {
    return arrayReduce(words(deburr(u).replace(reApos, "")), a, "");
  };
}
var camelCase$2 = createCompounder(function(a, u, c) {
  return u = u.toLowerCase(), a + (c ? capitalize(u) : u);
});
const camelCase$3 = camelCase$2;
function stackClear() {
  this.__data__ = new ListCache(), this.size = 0;
}
function stackDelete(a) {
  var u = this.__data__, c = u.delete(a);
  return this.size = u.size, c;
}
function stackGet(a) {
  return this.__data__.get(a);
}
function stackHas(a) {
  return this.__data__.has(a);
}
var LARGE_ARRAY_SIZE = 200;
function stackSet(a, u) {
  var c = this.__data__;
  if (c instanceof ListCache) {
    var l = c.__data__;
    if (!Map$1 || l.length < LARGE_ARRAY_SIZE - 1)
      return l.push([a, u]), this.size = ++c.size, this;
    c = this.__data__ = new MapCache(l);
  }
  return c.set(a, u), this.size = c.size, this;
}
function Stack(a) {
  var u = this.__data__ = new ListCache(a);
  this.size = u.size;
}
Stack.prototype.clear = stackClear;
Stack.prototype.delete = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
function baseAssign(a, u) {
  return a && copyObject(u, keys$2(u), a);
}
function baseAssignIn(a, u) {
  return a && copyObject(u, keysIn(u), a);
}
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports, freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module, moduleExports = freeModule && freeModule.exports === freeExports, Buffer$M = moduleExports ? root.Buffer : void 0, allocUnsafe = Buffer$M ? Buffer$M.allocUnsafe : void 0;
function cloneBuffer(a, u) {
  if (u)
    return a.slice();
  var c = a.length, l = allocUnsafe ? allocUnsafe(c) : new a.constructor(c);
  return a.copy(l), l;
}
function arrayFilter(a, u) {
  for (var c = -1, l = a == null ? 0 : a.length, v = 0, p = []; ++c < l; ) {
    var _ = a[c];
    u(_, c, a) && (p[v++] = _);
  }
  return p;
}
function stubArray() {
  return [];
}
var objectProto$a = Object.prototype, propertyIsEnumerable$1 = objectProto$a.propertyIsEnumerable, nativeGetSymbols$1 = Object.getOwnPropertySymbols, getSymbols = nativeGetSymbols$1 ? function(a) {
  return a == null ? [] : (a = Object(a), arrayFilter(nativeGetSymbols$1(a), function(u) {
    return propertyIsEnumerable$1.call(a, u);
  }));
} : stubArray;
function copySymbols(a, u) {
  return copyObject(a, getSymbols(a), u);
}
var nativeGetSymbols = Object.getOwnPropertySymbols, getSymbolsIn = nativeGetSymbols ? function(a) {
  for (var u = []; a; )
    arrayPush(u, getSymbols(a)), a = getPrototype$2(a);
  return u;
} : stubArray;
function copySymbolsIn(a, u) {
  return copyObject(a, getSymbolsIn(a), u);
}
function baseGetAllKeys(a, u, c) {
  var l = u(a);
  return isArray$4(a) ? l : arrayPush(l, c(a));
}
function getAllKeys(a) {
  return baseGetAllKeys(a, keys$2, getSymbols);
}
function getAllKeysIn(a) {
  return baseGetAllKeys(a, keysIn, getSymbolsIn);
}
var DataView$1 = getNative(root, "DataView"), Promise$1 = getNative(root, "Promise"), Set$1 = getNative(root, "Set"), mapTag$4 = "[object Map]", objectTag$3 = "[object Object]", promiseTag = "[object Promise]", setTag$4 = "[object Set]", weakMapTag$1 = "[object WeakMap]", dataViewTag$3 = "[object DataView]", dataViewCtorString = toSource(DataView$1), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap$2), getTag = baseGetTag;
(DataView$1 && getTag(new DataView$1(new ArrayBuffer(1))) != dataViewTag$3 || Map$1 && getTag(new Map$1()) != mapTag$4 || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set$1 && getTag(new Set$1()) != setTag$4 || WeakMap$2 && getTag(new WeakMap$2()) != weakMapTag$1) && (getTag = function(a) {
  var u = baseGetTag(a), c = u == objectTag$3 ? a.constructor : void 0, l = c ? toSource(c) : "";
  if (l)
    switch (l) {
      case dataViewCtorString:
        return dataViewTag$3;
      case mapCtorString:
        return mapTag$4;
      case promiseCtorString:
        return promiseTag;
      case setCtorString:
        return setTag$4;
      case weakMapCtorString:
        return weakMapTag$1;
    }
  return u;
});
const getTag$1 = getTag;
var objectProto$9 = Object.prototype, hasOwnProperty$5 = objectProto$9.hasOwnProperty;
function initCloneArray(a) {
  var u = a.length, c = new a.constructor(u);
  return u && typeof a[0] == "string" && hasOwnProperty$5.call(a, "index") && (c.index = a.index, c.input = a.input), c;
}
var Uint8Array$1 = root.Uint8Array;
function cloneArrayBuffer(a) {
  var u = new a.constructor(a.byteLength);
  return new Uint8Array$1(u).set(new Uint8Array$1(a)), u;
}
function cloneDataView(a, u) {
  var c = u ? cloneArrayBuffer(a.buffer) : a.buffer;
  return new a.constructor(c, a.byteOffset, a.byteLength);
}
var reFlags = /\w*$/;
function cloneRegExp(a) {
  var u = new a.constructor(a.source, reFlags.exec(a));
  return u.lastIndex = a.lastIndex, u;
}
var symbolProto$1 = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : void 0;
function cloneSymbol(a) {
  return symbolValueOf$1 ? Object(symbolValueOf$1.call(a)) : {};
}
function cloneTypedArray(a, u) {
  var c = u ? cloneArrayBuffer(a.buffer) : a.buffer;
  return new a.constructor(c, a.byteOffset, a.length);
}
var boolTag$3 = "[object Boolean]", dateTag$2 = "[object Date]", mapTag$3 = "[object Map]", numberTag$3 = "[object Number]", regexpTag$2 = "[object RegExp]", setTag$3 = "[object Set]", stringTag$4 = "[object String]", symbolTag$5 = "[object Symbol]", arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
function initCloneByTag(a, u, c) {
  var l = a.constructor;
  switch (u) {
    case arrayBufferTag$2:
      return cloneArrayBuffer(a);
    case boolTag$3:
    case dateTag$2:
      return new l(+a);
    case dataViewTag$2:
      return cloneDataView(a, c);
    case float32Tag$1:
    case float64Tag$1:
    case int8Tag$1:
    case int16Tag$1:
    case int32Tag$1:
    case uint8Tag$1:
    case uint8ClampedTag$1:
    case uint16Tag$1:
    case uint32Tag$1:
      return cloneTypedArray(a, c);
    case mapTag$3:
      return new l();
    case numberTag$3:
    case stringTag$4:
      return new l(a);
    case regexpTag$2:
      return cloneRegExp(a);
    case setTag$3:
      return new l();
    case symbolTag$5:
      return cloneSymbol(a);
  }
}
function initCloneObject(a) {
  return typeof a.constructor == "function" && !isPrototype$1(a) ? baseCreate(getPrototype$2(a)) : {};
}
var mapTag$2 = "[object Map]";
function baseIsMap(a) {
  return isObjectLike$7(a) && getTag$1(a) == mapTag$2;
}
var nodeIsMap = nodeUtil && nodeUtil.isMap, isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap, setTag$2 = "[object Set]";
function baseIsSet(a) {
  return isObjectLike$7(a) && getTag$1(a) == setTag$2;
}
var nodeIsSet = nodeUtil && nodeUtil.isSet, isSet$2 = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet, CLONE_DEEP_FLAG$3 = 1, CLONE_FLAT_FLAG$1 = 2, CLONE_SYMBOLS_FLAG$2 = 4, argsTag$2 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$2 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", funcTag$1 = "[object Function]", genTag$1 = "[object GeneratorFunction]", mapTag$1 = "[object Map]", numberTag$2 = "[object Number]", objectTag$2 = "[object Object]", regexpTag$1 = "[object RegExp]", setTag$1 = "[object Set]", stringTag$3 = "[object String]", symbolTag$4 = "[object Symbol]", weakMapTag = "[object WeakMap]", arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]", cloneableTags = {};
cloneableTags[argsTag$2] = cloneableTags[arrayTag$1] = cloneableTags[arrayBufferTag$1] = cloneableTags[dataViewTag$1] = cloneableTags[boolTag$2] = cloneableTags[dateTag$1] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag$1] = cloneableTags[numberTag$2] = cloneableTags[objectTag$2] = cloneableTags[regexpTag$1] = cloneableTags[setTag$1] = cloneableTags[stringTag$3] = cloneableTags[symbolTag$4] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = !0;
cloneableTags[errorTag$1] = cloneableTags[funcTag$1] = cloneableTags[weakMapTag] = !1;
function baseClone(a, u, c, l, v, p) {
  var _, k = u & CLONE_DEEP_FLAG$3, M = u & CLONE_FLAT_FLAG$1, L = u & CLONE_SYMBOLS_FLAG$2;
  if (c && (_ = v ? c(a, l, v, p) : c(a)), _ !== void 0)
    return _;
  if (!isObject$8(a))
    return a;
  var F = isArray$4(a);
  if (F) {
    if (_ = initCloneArray(a), !k)
      return copyArray(a, _);
  } else {
    var V = getTag$1(a), X = V == funcTag$1 || V == genTag$1;
    if (isBuffer$1(a))
      return cloneBuffer(a, k);
    if (V == objectTag$2 || V == argsTag$2 || X && !v) {
      if (_ = M || X ? {} : initCloneObject(a), !k)
        return M ? copySymbolsIn(a, baseAssignIn(_, a)) : copySymbols(a, baseAssign(_, a));
    } else {
      if (!cloneableTags[V])
        return v ? a : {};
      _ = initCloneByTag(a, V, k);
    }
  }
  p || (p = new Stack());
  var oe = p.get(a);
  if (oe)
    return oe;
  p.set(a, _), isSet$2(a) ? a.forEach(function(ne) {
    _.add(baseClone(ne, u, c, ne, a, p));
  }) : isMap(a) && a.forEach(function(ne, fe) {
    _.set(fe, baseClone(ne, u, c, fe, a, p));
  });
  var Y = L ? M ? getAllKeysIn : getAllKeys : M ? keysIn : keys$2, ae = F ? void 0 : Y(a);
  return arrayEach(ae || a, function(ne, fe) {
    ae && (fe = ne, ne = a[fe]), assignValue(_, fe, baseClone(ne, u, c, fe, a, p));
  }), _;
}
var CLONE_DEEP_FLAG$2 = 1, CLONE_SYMBOLS_FLAG$1 = 4;
function cloneDeep$1(a) {
  return baseClone(a, CLONE_DEEP_FLAG$2 | CLONE_SYMBOLS_FLAG$1);
}
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function setCacheAdd(a) {
  return this.__data__.set(a, HASH_UNDEFINED), this;
}
function setCacheHas(a) {
  return this.__data__.has(a);
}
function SetCache(a) {
  var u = -1, c = a == null ? 0 : a.length;
  for (this.__data__ = new MapCache(); ++u < c; )
    this.add(a[u]);
}
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;
function arraySome(a, u) {
  for (var c = -1, l = a == null ? 0 : a.length; ++c < l; )
    if (u(a[c], c, a))
      return !0;
  return !1;
}
function cacheHas(a, u) {
  return a.has(u);
}
var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
function equalArrays(a, u, c, l, v, p) {
  var _ = c & COMPARE_PARTIAL_FLAG$5, k = a.length, M = u.length;
  if (k != M && !(_ && M > k))
    return !1;
  var L = p.get(a), F = p.get(u);
  if (L && F)
    return L == u && F == a;
  var V = -1, X = !0, oe = c & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : void 0;
  for (p.set(a, u), p.set(u, a); ++V < k; ) {
    var Y = a[V], ae = u[V];
    if (l)
      var ne = _ ? l(ae, Y, V, u, a, p) : l(Y, ae, V, a, u, p);
    if (ne !== void 0) {
      if (ne)
        continue;
      X = !1;
      break;
    }
    if (oe) {
      if (!arraySome(u, function(fe, ie) {
        if (!cacheHas(oe, ie) && (Y === fe || v(Y, fe, c, l, p)))
          return oe.push(ie);
      })) {
        X = !1;
        break;
      }
    } else if (!(Y === ae || v(Y, ae, c, l, p))) {
      X = !1;
      break;
    }
  }
  return p.delete(a), p.delete(u), X;
}
function mapToArray(a) {
  var u = -1, c = Array(a.size);
  return a.forEach(function(l, v) {
    c[++u] = [v, l];
  }), c;
}
function setToArray(a) {
  var u = -1, c = Array(a.size);
  return a.forEach(function(l) {
    c[++u] = l;
  }), c;
}
var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2, boolTag$1 = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag = "[object Map]", numberTag$1 = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag$2 = "[object String]", symbolTag$3 = "[object Symbol]", arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
function equalByTag(a, u, c, l, v, p, _) {
  switch (c) {
    case dataViewTag:
      if (a.byteLength != u.byteLength || a.byteOffset != u.byteOffset)
        return !1;
      a = a.buffer, u = u.buffer;
    case arrayBufferTag:
      return !(a.byteLength != u.byteLength || !p(new Uint8Array$1(a), new Uint8Array$1(u)));
    case boolTag$1:
    case dateTag:
    case numberTag$1:
      return eq(+a, +u);
    case errorTag:
      return a.name == u.name && a.message == u.message;
    case regexpTag:
    case stringTag$2:
      return a == u + "";
    case mapTag:
      var k = mapToArray;
    case setTag:
      var M = l & COMPARE_PARTIAL_FLAG$4;
      if (k || (k = setToArray), a.size != u.size && !M)
        return !1;
      var L = _.get(a);
      if (L)
        return L == u;
      l |= COMPARE_UNORDERED_FLAG$2, _.set(a, u);
      var F = equalArrays(k(a), k(u), l, v, p, _);
      return _.delete(a), F;
    case symbolTag$3:
      if (symbolValueOf)
        return symbolValueOf.call(a) == symbolValueOf.call(u);
  }
  return !1;
}
var COMPARE_PARTIAL_FLAG$3 = 1, objectProto$8 = Object.prototype, hasOwnProperty$4 = objectProto$8.hasOwnProperty;
function equalObjects(a, u, c, l, v, p) {
  var _ = c & COMPARE_PARTIAL_FLAG$3, k = getAllKeys(a), M = k.length, L = getAllKeys(u), F = L.length;
  if (M != F && !_)
    return !1;
  for (var V = M; V--; ) {
    var X = k[V];
    if (!(_ ? X in u : hasOwnProperty$4.call(u, X)))
      return !1;
  }
  var oe = p.get(a), Y = p.get(u);
  if (oe && Y)
    return oe == u && Y == a;
  var ae = !0;
  p.set(a, u), p.set(u, a);
  for (var ne = _; ++V < M; ) {
    X = k[V];
    var fe = a[X], ie = u[X];
    if (l)
      var ge = _ ? l(ie, fe, X, u, a, p) : l(fe, ie, X, a, u, p);
    if (!(ge === void 0 ? fe === ie || v(fe, ie, c, l, p) : ge)) {
      ae = !1;
      break;
    }
    ne || (ne = X == "constructor");
  }
  if (ae && !ne) {
    var be = a.constructor, Ce = u.constructor;
    be != Ce && "constructor" in a && "constructor" in u && !(typeof be == "function" && be instanceof be && typeof Ce == "function" && Ce instanceof Ce) && (ae = !1);
  }
  return p.delete(a), p.delete(u), ae;
}
var COMPARE_PARTIAL_FLAG$2 = 1, argsTag$1 = "[object Arguments]", arrayTag = "[object Array]", objectTag$1 = "[object Object]", objectProto$7 = Object.prototype, hasOwnProperty$3 = objectProto$7.hasOwnProperty;
function baseIsEqualDeep(a, u, c, l, v, p) {
  var _ = isArray$4(a), k = isArray$4(u), M = _ ? arrayTag : getTag$1(a), L = k ? arrayTag : getTag$1(u);
  M = M == argsTag$1 ? objectTag$1 : M, L = L == argsTag$1 ? objectTag$1 : L;
  var F = M == objectTag$1, V = L == objectTag$1, X = M == L;
  if (X && isBuffer$1(a)) {
    if (!isBuffer$1(u))
      return !1;
    _ = !0, F = !1;
  }
  if (X && !F)
    return p || (p = new Stack()), _ || isTypedArray$1(a) ? equalArrays(a, u, c, l, v, p) : equalByTag(a, u, M, c, l, v, p);
  if (!(c & COMPARE_PARTIAL_FLAG$2)) {
    var oe = F && hasOwnProperty$3.call(a, "__wrapped__"), Y = V && hasOwnProperty$3.call(u, "__wrapped__");
    if (oe || Y) {
      var ae = oe ? a.value() : a, ne = Y ? u.value() : u;
      return p || (p = new Stack()), v(ae, ne, c, l, p);
    }
  }
  return X ? (p || (p = new Stack()), equalObjects(a, u, c, l, v, p)) : !1;
}
function baseIsEqual(a, u, c, l, v) {
  return a === u ? !0 : a == null || u == null || !isObjectLike$7(a) && !isObjectLike$7(u) ? a !== a && u !== u : baseIsEqualDeep(a, u, c, l, baseIsEqual, v);
}
var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
function baseIsMatch(a, u, c, l) {
  var v = c.length, p = v, _ = !l;
  if (a == null)
    return !p;
  for (a = Object(a); v--; ) {
    var k = c[v];
    if (_ && k[2] ? k[1] !== a[k[0]] : !(k[0] in a))
      return !1;
  }
  for (; ++v < p; ) {
    k = c[v];
    var M = k[0], L = a[M], F = k[1];
    if (_ && k[2]) {
      if (L === void 0 && !(M in a))
        return !1;
    } else {
      var V = new Stack();
      if (l)
        var X = l(L, F, M, a, u, V);
      if (!(X === void 0 ? baseIsEqual(F, L, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, l, V) : X))
        return !1;
    }
  }
  return !0;
}
function isStrictComparable(a) {
  return a === a && !isObject$8(a);
}
function getMatchData(a) {
  for (var u = keys$2(a), c = u.length; c--; ) {
    var l = u[c], v = a[l];
    u[c] = [l, v, isStrictComparable(v)];
  }
  return u;
}
function matchesStrictComparable(a, u) {
  return function(c) {
    return c == null ? !1 : c[a] === u && (u !== void 0 || a in Object(c));
  };
}
function baseMatches(a) {
  var u = getMatchData(a);
  return u.length == 1 && u[0][2] ? matchesStrictComparable(u[0][0], u[0][1]) : function(c) {
    return c === a || baseIsMatch(c, a, u);
  };
}
function baseHasIn(a, u) {
  return a != null && u in Object(a);
}
function hasPath(a, u, c) {
  u = castPath(u, a);
  for (var l = -1, v = u.length, p = !1; ++l < v; ) {
    var _ = toKey(u[l]);
    if (!(p = a != null && c(a, _)))
      break;
    a = a[_];
  }
  return p || ++l != v ? p : (v = a == null ? 0 : a.length, !!v && isLength$1(v) && isIndex$1(_, v) && (isArray$4(a) || isArguments$2(a)));
}
function hasIn(a, u) {
  return a != null && hasPath(a, u, baseHasIn);
}
var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
function baseMatchesProperty(a, u) {
  return isKey(a) && isStrictComparable(u) ? matchesStrictComparable(toKey(a), u) : function(c) {
    var l = get(c, a);
    return l === void 0 && l === u ? hasIn(c, a) : baseIsEqual(u, l, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}
function baseProperty(a) {
  return function(u) {
    return u == null ? void 0 : u[a];
  };
}
function basePropertyDeep(a) {
  return function(u) {
    return baseGet(u, a);
  };
}
function property(a) {
  return isKey(a) ? baseProperty(toKey(a)) : basePropertyDeep(a);
}
function baseIteratee(a) {
  return typeof a == "function" ? a : a == null ? identity : typeof a == "object" ? isArray$4(a) ? baseMatchesProperty(a[0], a[1]) : baseMatches(a) : property(a);
}
function createBaseFor(a) {
  return function(u, c, l) {
    for (var v = -1, p = Object(u), _ = l(u), k = _.length; k--; ) {
      var M = _[a ? k : ++v];
      if (c(p[M], M, p) === !1)
        break;
    }
    return u;
  };
}
var baseFor = createBaseFor();
const baseFor$1 = baseFor;
function baseForOwn(a, u) {
  return a && baseFor$1(a, u, keys$2);
}
function createBaseEach(a, u) {
  return function(c, l) {
    if (c == null)
      return c;
    if (!isArrayLike$1(c))
      return a(c, l);
    for (var v = c.length, p = u ? v : -1, _ = Object(c); (u ? p-- : ++p < v) && l(_[p], p, _) !== !1; )
      ;
    return c;
  };
}
var baseEach = createBaseEach(baseForOwn), now = function() {
  return root.Date.now();
}, FUNC_ERROR_TEXT$1 = "Expected a function", nativeMax$1 = Math.max, nativeMin = Math.min;
function debounce(a, u, c) {
  var l, v, p, _, k, M, L = 0, F = !1, V = !1, X = !0;
  if (typeof a != "function")
    throw new TypeError(FUNC_ERROR_TEXT$1);
  u = toNumber$3(u) || 0, isObject$8(c) && (F = !!c.leading, V = "maxWait" in c, p = V ? nativeMax$1(toNumber$3(c.maxWait) || 0, u) : p, X = "trailing" in c ? !!c.trailing : X);
  function oe(Me) {
    var Be = l, Ae = v;
    return l = v = void 0, L = Me, _ = a.apply(Ae, Be), _;
  }
  function Y(Me) {
    return L = Me, k = setTimeout(fe, u), F ? oe(Me) : _;
  }
  function ae(Me) {
    var Be = Me - M, Ae = Me - L, Z = u - Be;
    return V ? nativeMin(Z, p - Ae) : Z;
  }
  function ne(Me) {
    var Be = Me - M, Ae = Me - L;
    return M === void 0 || Be >= u || Be < 0 || V && Ae >= p;
  }
  function fe() {
    var Me = now();
    if (ne(Me))
      return ie(Me);
    k = setTimeout(fe, ae(Me));
  }
  function ie(Me) {
    return k = void 0, X && l ? oe(Me) : (l = v = void 0, _);
  }
  function ge() {
    k !== void 0 && clearTimeout(k), L = 0, l = M = v = k = void 0;
  }
  function be() {
    return k === void 0 ? _ : ie(now());
  }
  function Ce() {
    var Me = now(), Be = ne(Me);
    if (l = arguments, v = this, M = Me, Be) {
      if (k === void 0)
        return Y(M);
      if (V)
        return clearTimeout(k), k = setTimeout(fe, u), oe(M);
    }
    return k === void 0 && (k = setTimeout(fe, u)), _;
  }
  return Ce.cancel = ge, Ce.flush = be, Ce;
}
function last(a) {
  var u = a == null ? 0 : a.length;
  return u ? a[u - 1] : void 0;
}
function arrayEvery(a, u) {
  for (var c = -1, l = a == null ? 0 : a.length; ++c < l; )
    if (!u(a[c], c, a))
      return !1;
  return !0;
}
function baseEvery(a, u) {
  var c = !0;
  return baseEach(a, function(l, v, p) {
    return c = !!u(l, v, p), c;
  }), c;
}
function every(a, u, c) {
  var l = isArray$4(a) ? arrayEvery : baseEvery;
  return c && isIterateeCall(a, u, c) && (u = void 0), l(a, baseIteratee(u));
}
function baseMap(a, u) {
  var c = -1, l = isArrayLike$1(a) ? Array(a.length) : [];
  return baseEach(a, function(v, p, _) {
    l[++c] = u(v, p, _);
  }), l;
}
function parent(a, u) {
  return u.length < 2 ? a : baseGet(a, baseSlice(u, 0, -1));
}
function isEqual(a, u) {
  return baseIsEqual(a, u);
}
function isMatch(a, u) {
  return a === u || baseIsMatch(a, u, getMatchData(u));
}
var CLONE_DEEP_FLAG$1 = 1;
function iteratee(a) {
  return baseIteratee(typeof a == "function" ? a : baseClone(a, CLONE_DEEP_FLAG$1));
}
var kebabCase = createCompounder(function(a, u, c) {
  return a + (c ? "-" : "") + u.toLowerCase();
});
const kebabCase$1 = kebabCase;
function baseUnset(a, u) {
  return u = castPath(u, a), a = parent(a, u), a == null || delete a[toKey(last(u))];
}
function customOmitClone(a) {
  return isPlainObject$3(a) ? void 0 : a;
}
var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4, omit = flatRest(function(a, u) {
  var c = {};
  if (a == null)
    return c;
  var l = !1;
  u = arrayMap$1(u, function(p) {
    return p = castPath(p, a), l || (l = p.length > 1), p;
  }), copyObject(a, getAllKeysIn(a), c), l && (c = baseClone(c, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone));
  for (var v = u.length; v--; )
    baseUnset(c, u[v]);
  return c;
});
function baseSet(a, u, c, l) {
  if (!isObject$8(a))
    return a;
  u = castPath(u, a);
  for (var v = -1, p = u.length, _ = p - 1, k = a; k != null && ++v < p; ) {
    var M = toKey(u[v]), L = c;
    if (M === "__proto__" || M === "constructor" || M === "prototype")
      return a;
    if (v != _) {
      var F = k[M];
      L = l ? l(F, M, k) : void 0, L === void 0 && (L = isObject$8(F) ? F : isIndex$1(u[v + 1]) ? [] : {});
    }
    assignValue(k, M, L), k = k[M];
  }
  return a;
}
function basePickBy(a, u, c) {
  for (var l = -1, v = u.length, p = {}; ++l < v; ) {
    var _ = u[l], k = baseGet(a, _);
    c(k, _) && baseSet(p, castPath(_, a), k);
  }
  return p;
}
function baseSortBy(a, u) {
  var c = a.length;
  for (a.sort(u); c--; )
    a[c] = a[c].value;
  return a;
}
function compareAscending(a, u) {
  if (a !== u) {
    var c = a !== void 0, l = a === null, v = a === a, p = isSymbol$3(a), _ = u !== void 0, k = u === null, M = u === u, L = isSymbol$3(u);
    if (!k && !L && !p && a > u || p && _ && M && !k && !L || l && _ && M || !c && M || !v)
      return 1;
    if (!l && !p && !L && a < u || L && c && v && !l && !p || k && c && v || !_ && v || !M)
      return -1;
  }
  return 0;
}
function compareMultiple(a, u, c) {
  for (var l = -1, v = a.criteria, p = u.criteria, _ = v.length, k = c.length; ++l < _; ) {
    var M = compareAscending(v[l], p[l]);
    if (M) {
      if (l >= k)
        return M;
      var L = c[l];
      return M * (L == "desc" ? -1 : 1);
    }
  }
  return a.index - u.index;
}
function baseOrderBy(a, u, c) {
  u.length ? u = arrayMap$1(u, function(p) {
    return isArray$4(p) ? function(_) {
      return baseGet(_, p.length === 1 ? p[0] : p);
    } : p;
  }) : u = [identity];
  var l = -1;
  u = arrayMap$1(u, baseUnary(baseIteratee));
  var v = baseMap(a, function(p, _, k) {
    var M = arrayMap$1(u, function(L) {
      return L(p);
    });
    return { criteria: M, index: ++l, value: p };
  });
  return baseSortBy(v, function(p, _) {
    return compareMultiple(p, _, c);
  });
}
function basePick(a, u) {
  return basePickBy(a, u, function(c, l) {
    return hasIn(a, l);
  });
}
var pick = flatRest(function(a, u) {
  return a == null ? {} : basePick(a, u);
});
const pick$1 = pick;
function baseIndexOfWith(a, u, c, l) {
  for (var v = c - 1, p = a.length; ++v < p; )
    if (l(a[v], u))
      return v;
  return -1;
}
var arrayProto = Array.prototype, splice = arrayProto.splice;
function basePullAll(a, u, c, l) {
  var v = l ? baseIndexOfWith : baseIndexOf$1, p = -1, _ = u.length, k = a;
  for (a === u && (u = copyArray(u)), c && (k = arrayMap$1(a, baseUnary(c))); ++p < _; )
    for (var M = 0, L = u[p], F = c ? c(L) : L; (M = v(k, F, M, l)) > -1; )
      k !== a && splice.call(k, M, 1), splice.call(a, M, 1);
  return a;
}
function pullAll(a, u) {
  return a && a.length && u && u.length ? basePullAll(a, u) : a;
}
var pull$1 = baseRest(pullAll), sortBy = baseRest(function(a, u) {
  if (a == null)
    return [];
  var c = u.length;
  return c > 1 && isIterateeCall(a, u[0], u[1]) ? u = [] : c > 2 && isIterateeCall(u[0], u[1], u[2]) && (u = [u[0]]), baseOrderBy(a, baseFlatten(u, 1), []);
});
const sortBy$1 = sortBy, convert = (
  // Note: overloads in JSDoc cant yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(a) {
    if (a == null)
      return ok;
    if (typeof a == "function")
      return castFactory(a);
    if (typeof a == "object")
      return Array.isArray(a) ? anyFactory(a) : propsFactory(a);
    if (typeof a == "string")
      return typeFactory(a);
    throw new Error("Expected function, string, or object as test");
  }
);
function anyFactory(a) {
  const u = [];
  let c = -1;
  for (; ++c < a.length; )
    u[c] = convert(a[c]);
  return castFactory(l);
  function l(...v) {
    let p = -1;
    for (; ++p < u.length; )
      if (u[p].apply(this, v))
        return !0;
    return !1;
  }
}
function propsFactory(a) {
  const u = (
    /** @type {Record<string, unknown>} */
    a
  );
  return castFactory(c);
  function c(l) {
    const v = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      l
    );
    let p;
    for (p in a)
      if (v[p] !== u[p])
        return !1;
    return !0;
  }
}
function typeFactory(a) {
  return castFactory(u);
  function u(c) {
    return c && c.type === a;
  }
}
function castFactory(a) {
  return u;
  function u(c, l, v) {
    return !!(looksLikeANode(c) && a.call(
      this,
      c,
      typeof l == "number" ? l : void 0,
      v || void 0
    ));
  }
}
function ok() {
  return !0;
}
function looksLikeANode(a) {
  return a !== null && typeof a == "object" && "type" in a;
}
function color$1(a) {
  return a;
}
const empty$1 = [], CONTINUE = !0, EXIT = !1, SKIP = "skip";
function visitParents(a, u, c, l) {
  let v;
  typeof u == "function" && typeof c != "function" ? (l = c, c = u) : v = u;
  const p = convert(v), _ = l ? -1 : 1;
  k(a, void 0, [])();
  function k(M, L, F) {
    const V = (
      /** @type {Record<string, unknown>} */
      M && typeof M == "object" ? M : {}
    );
    if (typeof V.type == "string") {
      const oe = (
        // `hast`
        typeof V.tagName == "string" ? V.tagName : (
          // `xast`
          typeof V.name == "string" ? V.name : void 0
        )
      );
      Object.defineProperty(X, "name", {
        value: "node (" + (M.type + (oe ? "<" + oe + ">" : "")) + ")"
      });
    }
    return X;
    function X() {
      let oe = empty$1, Y, ae, ne;
      if ((!u || p(M, L, F[F.length - 1] || void 0)) && (oe = toResult(c(M, F)), oe[0] === EXIT))
        return oe;
      if ("children" in M && M.children) {
        const fe = (
          /** @type {UnistParent} */
          M
        );
        if (fe.children && oe[0] !== SKIP)
          for (ae = (l ? fe.children.length : -1) + _, ne = F.concat(fe); ae > -1 && ae < fe.children.length; ) {
            const ie = fe.children[ae];
            if (Y = k(ie, ae, ne)(), Y[0] === EXIT)
              return Y;
            ae = typeof Y[1] == "number" ? Y[1] : ae + _;
          }
      }
      return oe;
    }
  }
}
function toResult(a) {
  return Array.isArray(a) ? a : typeof a == "number" ? [CONTINUE, a] : a == null ? empty$1 : [a];
}
function visit(a, u, c, l) {
  let v, p, _;
  typeof u == "function" && typeof c != "function" ? (p = void 0, _ = u, v = c) : (p = u, _ = c, v = l), visitParents(a, p, k, v);
  function k(M, L) {
    const F = L[L.length - 1], V = F ? F.children.indexOf(M) : void 0;
    return _(M, V, F);
  }
}
const generateId = () => (Math.random() * 1e20).toString(36), insertAt$1 = (a = 0, u, c, l = !1) => [...c.slice(0, a), ...[u].flat(), ...c.slice(l ? a + 1 : a)], replaceItem$1 = (a, u, c) => {
  a = typeof a == "function" ? a : (v) => v === a;
  const l = c.findIndex(a);
  return l < 0 ? c : insertAt$1(l, u, c, !0);
}, swapIndex = (a, u, c) => {
  if (!c[a] || !c[u])
    return c;
  c = [...c];
  const l = c[a];
  return c[a] = c[u], c[u] = l, c;
}, swapItems = (a, u, c) => {
  const l = c.findIndex((p) => p === a), v = c.findIndex((p) => p === u);
  return l < 0 || v < 0 ? c : swapIndex(l, v, c);
}, toDataNode$1 = (a) => a ? {
  id: a.id,
  props: a.props,
  childIds: (a.children || []).map((u) => u.id)
} : null, toSceneNode = (a) => ({
  id: a.id,
  props: a.props,
  children: []
}), toSceneTree = (a, u) => {
  const c = a.find((v) => v.id === u);
  if (!c)
    return null;
  const l = c.childIds;
  return {
    id: c.id,
    props: c.props,
    children: l.map((v) => toSceneTree(a, v)).filter(Boolean)
  };
}, forEachDown$1 = (a, u) => {
  u(a), (a.children || []).forEach((l) => forEachDown$1(l, (v, p) => {
    u(v, p || a);
  }));
}, mapDown = (a, u) => {
  const c = u(a);
  return {
    ...c,
    children: ((c == null ? void 0 : c.children) || (a == null ? void 0 : a.children) || []).map((l) => mapDown(l, u))
  };
}, mapDownAsync = async (a, u) => {
  const c = (a == null ? void 0 : a.children) ?? [];
  return {
    ...await u(a),
    children: await Promise.all(c.map((l) => mapDownAsync(l, u)))
  };
}, getElementAttributes = (a) => Object.values(a.attributes).reduce((u, c) => ({
  ...u,
  [c.name]: c.value
}), {}), asArray = (a) => isArray$4(a) ? a : [a], sizeToNum = (a, u) => typeof a == "number" ? a : typeof a == "string" ? a.indexOf("%") > -1 ? parseFloat(a) / 100 * u : parseFloat(a) : 0, asSize = (a) => typeof a == "number" ? a + "px" : typeof a == "string" ? a.indexOf("%") > -1 ? parseFloat(a) + "%" : a : "0px", asDuration = (a) => typeof a == "string" ? a : typeof a == "number" ? a + "ms" : "0ms", find$1 = (a, u) => {
  if (!a)
    throw new Error("requires a tree to search");
  if (!u)
    throw new Error("requires a condition");
  const c = iteratee(u);
  let l;
  return visit(a, function(v) {
    if (c(v))
      return l = v, !1;
  }), l;
}, findAll = (a, u) => {
  if (!a)
    throw new Error("requires a tree to search");
  if (!u)
    throw new Error("requires a condition");
  const c = iteratee(u);
  let l = [];
  return visit(a, function(v) {
    c(v) && l.push(v);
  }), l;
}, lookupDevice = (a, u) => {
  const c = a.find((v) => v.label === u && v.kind === "videoinput"), l = a.find((v) => v.label === `Monitor of ${u}` && v.kind === "audioinput");
  if (c && l)
    return {
      videoDevice: c,
      audioDevice: l
    };
  if (c) {
    if (c.label === "Logitech BRIO (046d:085e)") {
      const v = a.find((p) => (
        /*(device.groupId === videoDevice.groupId) &&*/
        p.kind === "audioinput" && p.label === "Loopback Audio 2 (Virtual)"
      ));
      return {
        videoDevice: c,
        audioDevice: v
      };
    }
    if (c.label === "OBS Virtual Camera (m-de:vice)") {
      const v = a.find((p) => (
        /*(device.groupId === videoDevice.groupId) &&*/
        p.kind === "audioinput" && p.label === "Loopback Audio (Virtual)"
      ));
      return {
        videoDevice: c,
        audioDevice: v
      };
    }
    return {
      videoDevice: c,
      audioDevice: null
    };
  }
  return null;
}, connectDevice = async (a) => {
  const u = await navigator.mediaDevices.enumerateDevices(), c = lookupDevice(u, a);
  if (c) {
    const l = {
      video: {
        width: 999999,
        height: 999999,
        deviceId: {
          exact: c.videoDevice.deviceId
        }
      }
    };
    c.audioDevice && (l.audio = {
      autoGainControl: !1,
      channelCount: 2,
      echoCancellation: !1,
      // @ts-ignore: https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints/latency
      latency: 0,
      noiseSuppression: !1,
      sampleRate: 128e3,
      sampleSize: 16,
      deviceId: {
        exact: c.audioDevice.deviceId
      }
    });
    const v = await navigator.mediaDevices.getUserMedia(l);
    if (v)
      return v;
    console.warn(`No stream found for source ${a}.`);
  } else
    console.warn(`No device found for source ${a}.`);
}, values$1 = (a) => Array.from(a.values()), Logic = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  asArray,
  asDuration,
  asSize,
  camelCase: camelCase$3,
  cloneDeep: cloneDeep$1,
  connectDevice,
  debounce,
  deepEqual,
  every,
  find: find$1,
  findAll,
  forEachDown: forEachDown$1,
  generateId,
  getElementAttributes,
  insertAt: insertAt$1,
  isArray: isArray$4,
  isEqual,
  kebabCase: kebabCase$1,
  lookupDevice,
  mapDown,
  mapDownAsync,
  omit,
  pick: pick$1,
  pull: pull$1,
  replaceItem: replaceItem$1,
  sizeToNum,
  sortBy: sortBy$1,
  swapIndex,
  swapItems,
  toDataNode: toDataNode$1,
  toSceneNode,
  toSceneTree,
  values: values$1
}, Symbol.toStringTag, { value: "Module" }));
function getDefaultExportFromCjs$1(a) {
  return a && a.__esModule && Object.prototype.hasOwnProperty.call(a, "default") ? a.default : a;
}
var browser$d = { exports: {} }, process = browser$d.exports = {}, cachedSetTimeout, cachedClearTimeout;
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? cachedSetTimeout = setTimeout : cachedSetTimeout = defaultSetTimout;
  } catch {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    typeof clearTimeout == "function" ? cachedClearTimeout = clearTimeout : cachedClearTimeout = defaultClearTimeout;
  } catch {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(a) {
  if (cachedSetTimeout === setTimeout)
    return setTimeout(a, 0);
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout)
    return cachedSetTimeout = setTimeout, setTimeout(a, 0);
  try {
    return cachedSetTimeout(a, 0);
  } catch {
    try {
      return cachedSetTimeout.call(null, a, 0);
    } catch {
      return cachedSetTimeout.call(this, a, 0);
    }
  }
}
function runClearTimeout(a) {
  if (cachedClearTimeout === clearTimeout)
    return clearTimeout(a);
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout)
    return cachedClearTimeout = clearTimeout, clearTimeout(a);
  try {
    return cachedClearTimeout(a);
  } catch {
    try {
      return cachedClearTimeout.call(null, a);
    } catch {
      return cachedClearTimeout.call(this, a);
    }
  }
}
var queue = [], draining = !1, currentQueue, queueIndex = -1;
function cleanUpNextTick() {
  !draining || !currentQueue || (draining = !1, currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1, queue.length && drainQueue());
}
function drainQueue() {
  if (!draining) {
    var a = runTimeout(cleanUpNextTick);
    draining = !0;
    for (var u = queue.length; u; ) {
      for (currentQueue = queue, queue = []; ++queueIndex < u; )
        currentQueue && currentQueue[queueIndex].run();
      queueIndex = -1, u = queue.length;
    }
    currentQueue = null, draining = !1, runClearTimeout(a);
  }
}
process.nextTick = function(a) {
  var u = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var c = 1; c < arguments.length; c++)
      u[c - 1] = arguments[c];
  queue.push(new Item(a, u)), queue.length === 1 && !draining && runTimeout(drainQueue);
};
function Item(a, u) {
  this.fun = a, this.array = u;
}
Item.prototype.run = function() {
  this.fun.apply(null, this.array);
};
process.title = "browser";
process.browser = !0;
process.env = {};
process.argv = [];
process.version = "";
process.versions = {};
function noop$5() {
}
process.on = noop$5;
process.addListener = noop$5;
process.once = noop$5;
process.off = noop$5;
process.removeListener = noop$5;
process.removeAllListeners = noop$5;
process.emit = noop$5;
process.prependListener = noop$5;
process.prependOnceListener = noop$5;
process.listeners = function(a) {
  return [];
};
process.binding = function(a) {
  throw new Error("process.binding is not supported");
};
process.cwd = function() {
  return "/";
};
process.chdir = function(a) {
  throw new Error("process.chdir is not supported");
};
process.umask = function() {
  return 0;
};
var browserExports$1 = browser$d.exports;
const process$1 = /* @__PURE__ */ getDefaultExportFromCjs$1(browserExports$1);
function _mergeNamespaces(a, u) {
  return u.forEach(function(c) {
    c && typeof c != "string" && !Array.isArray(c) && Object.keys(c).forEach(function(l) {
      if (l !== "default" && !(l in a)) {
        var v = Object.getOwnPropertyDescriptor(c, l);
        Object.defineProperty(a, l, v.get ? v : {
          enumerable: !0,
          get: function() {
            return c[l];
          }
        });
      }
    });
  }), Object.freeze(a);
}
function assert$k(a, u) {
  if (!a)
    throw new Error(u);
}
const FLOAT32_MAX = 34028234663852886e22, FLOAT32_MIN = -34028234663852886e22, UINT32_MAX = 4294967295, INT32_MAX = 2147483647, INT32_MIN = -2147483648;
function assertInt32(a) {
  if (typeof a != "number")
    throw new Error("invalid int 32: " + typeof a);
  if (!Number.isInteger(a) || a > INT32_MAX || a < INT32_MIN)
    throw new Error("invalid int 32: " + a);
}
function assertUInt32(a) {
  if (typeof a != "number")
    throw new Error("invalid uint 32: " + typeof a);
  if (!Number.isInteger(a) || a > UINT32_MAX || a < 0)
    throw new Error("invalid uint 32: " + a);
}
function assertFloat32(a) {
  if (typeof a != "number")
    throw new Error("invalid float 32: " + typeof a);
  if (Number.isFinite(a) && (a > FLOAT32_MAX || a < FLOAT32_MIN))
    throw new Error("invalid float 32: " + a);
}
const enumTypeSymbol = Symbol("@bufbuild/protobuf/enum-type");
function getEnumType(a) {
  const u = a[enumTypeSymbol];
  return assert$k(u, "missing enum type on enum object"), u;
}
function setEnumType(a, u, c, l) {
  a[enumTypeSymbol] = makeEnumType(u, c.map((v) => ({
    no: v.no,
    name: v.name,
    localName: a[v.no]
  })));
}
function makeEnumType(a, u, c) {
  const l = /* @__PURE__ */ Object.create(null), v = /* @__PURE__ */ Object.create(null), p = [];
  for (const _ of u) {
    const k = normalizeEnumValue(_);
    p.push(k), l[_.name] = k, v[_.no] = k;
  }
  return {
    typeName: a,
    values: p,
    // We do not surface options at this time
    // options: opt?.options ?? Object.create(null),
    findName(_) {
      return l[_];
    },
    findNumber(_) {
      return v[_];
    }
  };
}
function makeEnum(a, u, c) {
  const l = {};
  for (const v of u) {
    const p = normalizeEnumValue(v);
    l[p.localName] = p.no, l[p.no] = p.localName;
  }
  return setEnumType(l, a, u), l;
}
function normalizeEnumValue(a) {
  return "localName" in a ? a : Object.assign(Object.assign({}, a), {
    localName: a.name
  });
}
class Message {
  /**
   * Compare with a message of the same type.
   */
  equals(u) {
    return this.getType().runtime.util.equals(this.getType(), this, u);
  }
  /**
   * Create a deep copy.
   */
  clone() {
    return this.getType().runtime.util.clone(this);
  }
  /**
   * Parse from binary data, merging fields.
   *
   * Repeated fields are appended. Map entries are added, overwriting
   * existing keys.
   *
   * If a message field is already present, it will be merged with the
   * new data.
   */
  fromBinary(u, c) {
    const l = this.getType(), v = l.runtime.bin, p = v.makeReadOptions(c);
    return v.readMessage(this, p.readerFactory(u), u.byteLength, p), this;
  }
  /**
   * Parse a message from a JSON value.
   */
  fromJson(u, c) {
    const l = this.getType(), v = l.runtime.json, p = v.makeReadOptions(c);
    return v.readMessage(l, u, p, this), this;
  }
  /**
   * Parse a message from a JSON string.
   */
  fromJsonString(u, c) {
    let l;
    try {
      l = JSON.parse(u);
    } catch (v) {
      throw new Error("cannot decode ".concat(this.getType().typeName, " from JSON: ").concat(v instanceof Error ? v.message : String(v)));
    }
    return this.fromJson(l, c);
  }
  /**
   * Serialize the message to binary data.
   */
  toBinary(u) {
    const c = this.getType(), l = c.runtime.bin, v = l.makeWriteOptions(u), p = v.writerFactory();
    return l.writeMessage(this, p, v), p.finish();
  }
  /**
   * Serialize the message to a JSON value, a JavaScript value that can be
   * passed to JSON.stringify().
   */
  toJson(u) {
    const c = this.getType(), l = c.runtime.json, v = l.makeWriteOptions(u);
    return l.writeMessage(this, v);
  }
  /**
   * Serialize the message to a JSON string.
   */
  toJsonString(u) {
    var c;
    const l = this.toJson(u);
    return JSON.stringify(l, null, (c = u == null ? void 0 : u.prettySpaces) !== null && c !== void 0 ? c : 0);
  }
  /**
   * Override for serialization behavior. This will be invoked when calling
   * JSON.stringify on this message (i.e. JSON.stringify(msg)).
   *
   * Note that this will not serialize google.protobuf.Any with a packed
   * message because the protobuf JSON format specifies that it needs to be
   * unpacked, and this is only possible with a type registry to look up the
   * message type.  As a result, attempting to serialize a message with this
   * type will throw an Error.
   *
   * This method is protected because you should not need to invoke it
   * directly -- instead use JSON.stringify or toJsonString for
   * stringified JSON.  Alternatively, if actual JSON is desired, you should
   * use toJson.
   */
  toJSON() {
    return this.toJson({
      emitDefaultValues: !0
    });
  }
  /**
   * Retrieve the MessageType of this message - a singleton that represents
   * the protobuf message declaration and provides metadata for reflection-
   * based operations.
   */
  getType() {
    return Object.getPrototypeOf(this).constructor;
  }
}
function makeMessageType(a, u, c, l) {
  var v;
  const p = (v = l == null ? void 0 : l.localName) !== null && v !== void 0 ? v : u.substring(u.lastIndexOf(".") + 1), _ = {
    [p]: function(k) {
      a.util.initFields(this), a.util.initPartial(k, this);
    }
  }[p];
  return Object.setPrototypeOf(_.prototype, new Message()), Object.assign(_, {
    runtime: a,
    typeName: u,
    fields: a.util.newFieldList(c),
    fromBinary(k, M) {
      return new _().fromBinary(k, M);
    },
    fromJson(k, M) {
      return new _().fromJson(k, M);
    },
    fromJsonString(k, M) {
      return new _().fromJsonString(k, M);
    },
    equals(k, M) {
      return a.util.equals(_, k, M);
    }
  }), _;
}
var ScalarType;
(function(a) {
  a[a.DOUBLE = 1] = "DOUBLE", a[a.FLOAT = 2] = "FLOAT", a[a.INT64 = 3] = "INT64", a[a.UINT64 = 4] = "UINT64", a[a.INT32 = 5] = "INT32", a[a.FIXED64 = 6] = "FIXED64", a[a.FIXED32 = 7] = "FIXED32", a[a.BOOL = 8] = "BOOL", a[a.STRING = 9] = "STRING", a[a.BYTES = 12] = "BYTES", a[a.UINT32 = 13] = "UINT32", a[a.SFIXED32 = 15] = "SFIXED32", a[a.SFIXED64 = 16] = "SFIXED64", a[a.SINT32 = 17] = "SINT32", a[a.SINT64 = 18] = "SINT64";
})(ScalarType || (ScalarType = {}));
var LongType;
(function(a) {
  a[a.BIGINT = 0] = "BIGINT", a[a.STRING = 1] = "STRING";
})(LongType || (LongType = {}));
function varint64read() {
  let a = 0, u = 0;
  for (let l = 0; l < 28; l += 7) {
    let v = this.buf[this.pos++];
    if (a |= (v & 127) << l, !(v & 128))
      return this.assertBounds(), [a, u];
  }
  let c = this.buf[this.pos++];
  if (a |= (c & 15) << 28, u = (c & 112) >> 4, !(c & 128))
    return this.assertBounds(), [a, u];
  for (let l = 3; l <= 31; l += 7) {
    let v = this.buf[this.pos++];
    if (u |= (v & 127) << l, !(v & 128))
      return this.assertBounds(), [a, u];
  }
  throw new Error("invalid varint");
}
function varint64write(a, u, c) {
  for (let p = 0; p < 28; p = p + 7) {
    const _ = a >>> p, k = !(!(_ >>> 7) && u == 0), M = (k ? _ | 128 : _) & 255;
    if (c.push(M), !k)
      return;
  }
  const l = a >>> 28 & 15 | (u & 7) << 4, v = !!(u >> 3);
  if (c.push((v ? l | 128 : l) & 255), !!v) {
    for (let p = 3; p < 31; p = p + 7) {
      const _ = u >>> p, k = !!(_ >>> 7), M = (k ? _ | 128 : _) & 255;
      if (c.push(M), !k)
        return;
    }
    c.push(u >>> 31 & 1);
  }
}
const TWO_PWR_32_DBL = 4294967296;
function int64FromString(a) {
  const u = a[0] === "-";
  u && (a = a.slice(1));
  const c = 1e6;
  let l = 0, v = 0;
  function p(_, k) {
    const M = Number(a.slice(_, k));
    v *= c, l = l * c + M, l >= TWO_PWR_32_DBL && (v = v + (l / TWO_PWR_32_DBL | 0), l = l % TWO_PWR_32_DBL);
  }
  return p(-24, -18), p(-18, -12), p(-12, -6), p(-6), u ? negate(l, v) : newBits(l, v);
}
function int64ToString(a, u) {
  let c = newBits(a, u);
  const l = c.hi & 2147483648;
  l && (c = negate(c.lo, c.hi));
  const v = uInt64ToString(c.lo, c.hi);
  return l ? "-" + v : v;
}
function uInt64ToString(a, u) {
  if ({
    lo: a,
    hi: u
  } = toUnsigned(a, u), u <= 2097151)
    return String(TWO_PWR_32_DBL * u + a);
  const c = a & 16777215, l = (a >>> 24 | u << 8) & 16777215, v = u >> 16 & 65535;
  let p = c + l * 6777216 + v * 6710656, _ = l + v * 8147497, k = v * 2;
  const M = 1e7;
  return p >= M && (_ += Math.floor(p / M), p %= M), _ >= M && (k += Math.floor(_ / M), _ %= M), k.toString() + decimalFrom1e7WithLeadingZeros(_) + decimalFrom1e7WithLeadingZeros(p);
}
function toUnsigned(a, u) {
  return {
    lo: a >>> 0,
    hi: u >>> 0
  };
}
function newBits(a, u) {
  return {
    lo: a | 0,
    hi: u | 0
  };
}
function negate(a, u) {
  return u = ~u, a ? a = ~a + 1 : u += 1, newBits(a, u);
}
const decimalFrom1e7WithLeadingZeros = (a) => {
  const u = String(a);
  return "0000000".slice(u.length) + u;
};
function varint32write(a, u) {
  if (a >= 0) {
    for (; a > 127; )
      u.push(a & 127 | 128), a = a >>> 7;
    u.push(a);
  } else {
    for (let c = 0; c < 9; c++)
      u.push(a & 127 | 128), a = a >> 7;
    u.push(1);
  }
}
function varint32read() {
  let a = this.buf[this.pos++], u = a & 127;
  if (!(a & 128))
    return this.assertBounds(), u;
  if (a = this.buf[this.pos++], u |= (a & 127) << 7, !(a & 128))
    return this.assertBounds(), u;
  if (a = this.buf[this.pos++], u |= (a & 127) << 14, !(a & 128))
    return this.assertBounds(), u;
  if (a = this.buf[this.pos++], u |= (a & 127) << 21, !(a & 128))
    return this.assertBounds(), u;
  a = this.buf[this.pos++], u |= (a & 15) << 28;
  for (let c = 5; a & 128 && c < 10; c++)
    a = this.buf[this.pos++];
  if (a & 128)
    throw new Error("invalid varint");
  return this.assertBounds(), u >>> 0;
}
function makeInt64Support() {
  const a = new DataView(new ArrayBuffer(8));
  if (typeof BigInt == "function" && typeof a.getBigInt64 == "function" && typeof a.getBigUint64 == "function" && typeof a.setBigInt64 == "function" && typeof a.setBigUint64 == "function" && (typeof process$1 != "object" || typeof process$1.env != "object" || process$1.env.BUF_BIGINT_DISABLE !== "1")) {
    const v = BigInt("-9223372036854775808"), p = BigInt("9223372036854775807"), _ = BigInt("0"), k = BigInt("18446744073709551615");
    return {
      zero: BigInt(0),
      supported: !0,
      parse(M) {
        const L = typeof M == "bigint" ? M : BigInt(M);
        if (L > p || L < v)
          throw new Error("int64 invalid: ".concat(M));
        return L;
      },
      uParse(M) {
        const L = typeof M == "bigint" ? M : BigInt(M);
        if (L > k || L < _)
          throw new Error("uint64 invalid: ".concat(M));
        return L;
      },
      enc(M) {
        return a.setBigInt64(0, this.parse(M), !0), {
          lo: a.getInt32(0, !0),
          hi: a.getInt32(4, !0)
        };
      },
      uEnc(M) {
        return a.setBigInt64(0, this.uParse(M), !0), {
          lo: a.getInt32(0, !0),
          hi: a.getInt32(4, !0)
        };
      },
      dec(M, L) {
        return a.setInt32(0, M, !0), a.setInt32(4, L, !0), a.getBigInt64(0, !0);
      },
      uDec(M, L) {
        return a.setInt32(0, M, !0), a.setInt32(4, L, !0), a.getBigUint64(0, !0);
      }
    };
  }
  const c = (v) => assert$k(/^-?[0-9]+$/.test(v), "int64 invalid: ".concat(v)), l = (v) => assert$k(/^[0-9]+$/.test(v), "uint64 invalid: ".concat(v));
  return {
    zero: "0",
    supported: !1,
    parse(v) {
      return typeof v != "string" && (v = v.toString()), c(v), v;
    },
    uParse(v) {
      return typeof v != "string" && (v = v.toString()), l(v), v;
    },
    enc(v) {
      return typeof v != "string" && (v = v.toString()), c(v), int64FromString(v);
    },
    uEnc(v) {
      return typeof v != "string" && (v = v.toString()), l(v), int64FromString(v);
    },
    dec(v, p) {
      return int64ToString(v, p);
    },
    uDec(v, p) {
      return uInt64ToString(v, p);
    }
  };
}
const protoInt64 = makeInt64Support();
var WireType;
(function(a) {
  a[a.Varint = 0] = "Varint", a[a.Bit64 = 1] = "Bit64", a[a.LengthDelimited = 2] = "LengthDelimited", a[a.StartGroup = 3] = "StartGroup", a[a.EndGroup = 4] = "EndGroup", a[a.Bit32 = 5] = "Bit32";
})(WireType || (WireType = {}));
class BinaryWriter {
  constructor(u) {
    this.stack = [], this.textEncoder = u ?? new TextEncoder(), this.chunks = [], this.buf = [];
  }
  /**
   * Return all bytes written and reset this writer.
   */
  finish() {
    this.chunks.push(new Uint8Array(this.buf));
    let u = 0;
    for (let v = 0; v < this.chunks.length; v++)
      u += this.chunks[v].length;
    let c = new Uint8Array(u), l = 0;
    for (let v = 0; v < this.chunks.length; v++)
      c.set(this.chunks[v], l), l += this.chunks[v].length;
    return this.chunks = [], c;
  }
  /**
   * Start a new fork for length-delimited data like a message
   * or a packed repeated field.
   *
   * Must be joined later with `join()`.
   */
  fork() {
    return this.stack.push({
      chunks: this.chunks,
      buf: this.buf
    }), this.chunks = [], this.buf = [], this;
  }
  /**
   * Join the last fork. Write its length and bytes, then
   * return to the previous state.
   */
  join() {
    let u = this.finish(), c = this.stack.pop();
    if (!c)
      throw new Error("invalid state, fork stack empty");
    return this.chunks = c.chunks, this.buf = c.buf, this.uint32(u.byteLength), this.raw(u);
  }
  /**
   * Writes a tag (field number and wire type).
   *
   * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.
   *
   * Generated code should compute the tag ahead of time and call `uint32()`.
   */
  tag(u, c) {
    return this.uint32((u << 3 | c) >>> 0);
  }
  /**
   * Write a chunk of raw bytes.
   */
  raw(u) {
    return this.buf.length && (this.chunks.push(new Uint8Array(this.buf)), this.buf = []), this.chunks.push(u), this;
  }
  /**
   * Write a `uint32` value, an unsigned 32 bit varint.
   */
  uint32(u) {
    for (assertUInt32(u); u > 127; )
      this.buf.push(u & 127 | 128), u = u >>> 7;
    return this.buf.push(u), this;
  }
  /**
   * Write a `int32` value, a signed 32 bit varint.
   */
  int32(u) {
    return assertInt32(u), varint32write(u, this.buf), this;
  }
  /**
   * Write a `bool` value, a variant.
   */
  bool(u) {
    return this.buf.push(u ? 1 : 0), this;
  }
  /**
   * Write a `bytes` value, length-delimited arbitrary data.
   */
  bytes(u) {
    return this.uint32(u.byteLength), this.raw(u);
  }
  /**
   * Write a `string` value, length-delimited data converted to UTF-8 text.
   */
  string(u) {
    let c = this.textEncoder.encode(u);
    return this.uint32(c.byteLength), this.raw(c);
  }
  /**
   * Write a `float` value, 32-bit floating point number.
   */
  float(u) {
    assertFloat32(u);
    let c = new Uint8Array(4);
    return new DataView(c.buffer).setFloat32(0, u, !0), this.raw(c);
  }
  /**
   * Write a `double` value, a 64-bit floating point number.
   */
  double(u) {
    let c = new Uint8Array(8);
    return new DataView(c.buffer).setFloat64(0, u, !0), this.raw(c);
  }
  /**
   * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.
   */
  fixed32(u) {
    assertUInt32(u);
    let c = new Uint8Array(4);
    return new DataView(c.buffer).setUint32(0, u, !0), this.raw(c);
  }
  /**
   * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.
   */
  sfixed32(u) {
    assertInt32(u);
    let c = new Uint8Array(4);
    return new DataView(c.buffer).setInt32(0, u, !0), this.raw(c);
  }
  /**
   * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.
   */
  sint32(u) {
    return assertInt32(u), u = (u << 1 ^ u >> 31) >>> 0, varint32write(u, this.buf), this;
  }
  /**
   * Write a `fixed64` value, a signed, fixed-length 64-bit integer.
   */
  sfixed64(u) {
    let c = new Uint8Array(8), l = new DataView(c.buffer), v = protoInt64.enc(u);
    return l.setInt32(0, v.lo, !0), l.setInt32(4, v.hi, !0), this.raw(c);
  }
  /**
   * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.
   */
  fixed64(u) {
    let c = new Uint8Array(8), l = new DataView(c.buffer), v = protoInt64.uEnc(u);
    return l.setInt32(0, v.lo, !0), l.setInt32(4, v.hi, !0), this.raw(c);
  }
  /**
   * Write a `int64` value, a signed 64-bit varint.
   */
  int64(u) {
    let c = protoInt64.enc(u);
    return varint64write(c.lo, c.hi, this.buf), this;
  }
  /**
   * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64(u) {
    let c = protoInt64.enc(u), l = c.hi >> 31, v = c.lo << 1 ^ l, p = (c.hi << 1 | c.lo >>> 31) ^ l;
    return varint64write(v, p, this.buf), this;
  }
  /**
   * Write a `uint64` value, an unsigned 64-bit varint.
   */
  uint64(u) {
    let c = protoInt64.uEnc(u);
    return varint64write(c.lo, c.hi, this.buf), this;
  }
}
class BinaryReader {
  constructor(u, c) {
    this.varint64 = varint64read, this.uint32 = varint32read, this.buf = u, this.len = u.length, this.pos = 0, this.view = new DataView(u.buffer, u.byteOffset, u.byteLength), this.textDecoder = c ?? new TextDecoder();
  }
  /**
   * Reads a tag - field number and wire type.
   */
  tag() {
    let u = this.uint32(), c = u >>> 3, l = u & 7;
    if (c <= 0 || l < 0 || l > 5)
      throw new Error("illegal tag: field no " + c + " wire type " + l);
    return [c, l];
  }
  /**
   * Skip one element on the wire and return the skipped data.
   * Supports WireType.StartGroup since v2.0.0-alpha.23.
   */
  skip(u) {
    let c = this.pos;
    switch (u) {
      case WireType.Varint:
        for (; this.buf[this.pos++] & 128; )
          ;
        break;
      case WireType.Bit64:
        this.pos += 4;
      case WireType.Bit32:
        this.pos += 4;
        break;
      case WireType.LengthDelimited:
        let l = this.uint32();
        this.pos += l;
        break;
      case WireType.StartGroup:
        let v;
        for (; (v = this.tag()[1]) !== WireType.EndGroup; )
          this.skip(v);
        break;
      default:
        throw new Error("cant skip wire type " + u);
    }
    return this.assertBounds(), this.buf.subarray(c, this.pos);
  }
  /**
   * Throws error if position in byte array is out of range.
   */
  assertBounds() {
    if (this.pos > this.len)
      throw new RangeError("premature EOF");
  }
  /**
   * Read a `int32` field, a signed 32 bit varint.
   */
  int32() {
    return this.uint32() | 0;
  }
  /**
   * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.
   */
  sint32() {
    let u = this.uint32();
    return u >>> 1 ^ -(u & 1);
  }
  /**
   * Read a `int64` field, a signed 64-bit varint.
   */
  int64() {
    return protoInt64.dec(...this.varint64());
  }
  /**
   * Read a `uint64` field, an unsigned 64-bit varint.
   */
  uint64() {
    return protoInt64.uDec(...this.varint64());
  }
  /**
   * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64() {
    let [u, c] = this.varint64(), l = -(u & 1);
    return u = (u >>> 1 | (c & 1) << 31) ^ l, c = c >>> 1 ^ l, protoInt64.dec(u, c);
  }
  /**
   * Read a `bool` field, a variant.
   */
  bool() {
    let [u, c] = this.varint64();
    return u !== 0 || c !== 0;
  }
  /**
   * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.
   */
  fixed32() {
    return this.view.getUint32((this.pos += 4) - 4, !0);
  }
  /**
   * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.
   */
  sfixed32() {
    return this.view.getInt32((this.pos += 4) - 4, !0);
  }
  /**
   * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.
   */
  fixed64() {
    return protoInt64.uDec(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `fixed64` field, a signed, fixed-length 64-bit integer.
   */
  sfixed64() {
    return protoInt64.dec(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `float` field, 32-bit floating point number.
   */
  float() {
    return this.view.getFloat32((this.pos += 4) - 4, !0);
  }
  /**
   * Read a `double` field, a 64-bit floating point number.
   */
  double() {
    return this.view.getFloat64((this.pos += 8) - 8, !0);
  }
  /**
   * Read a `bytes` field, length-delimited arbitrary data.
   */
  bytes() {
    let u = this.uint32(), c = this.pos;
    return this.pos += u, this.assertBounds(), this.buf.subarray(c, c + u);
  }
  /**
   * Read a `string` field, length-delimited data converted to UTF-8 text.
   */
  string() {
    return this.textDecoder.decode(this.bytes());
  }
}
function scalarEquals(a, u, c) {
  if (u === c)
    return !0;
  if (a == ScalarType.BYTES) {
    if (!(u instanceof Uint8Array) || !(c instanceof Uint8Array) || u.length !== c.length)
      return !1;
    for (let l = 0; l < u.length; l++)
      if (u[l] !== c[l])
        return !1;
    return !0;
  }
  switch (a) {
    case ScalarType.UINT64:
    case ScalarType.FIXED64:
    case ScalarType.INT64:
    case ScalarType.SFIXED64:
    case ScalarType.SINT64:
      return u == c;
  }
  return !1;
}
function scalarDefaultValue(a, u) {
  switch (a) {
    case ScalarType.BOOL:
      return !1;
    case ScalarType.UINT64:
    case ScalarType.FIXED64:
    case ScalarType.INT64:
    case ScalarType.SFIXED64:
    case ScalarType.SINT64:
      return u == 0 ? protoInt64.zero : "0";
    case ScalarType.DOUBLE:
    case ScalarType.FLOAT:
      return 0;
    case ScalarType.BYTES:
      return new Uint8Array(0);
    case ScalarType.STRING:
      return "";
    default:
      return 0;
  }
}
function scalarTypeInfo(a, u) {
  const c = u === void 0;
  let l = WireType.Varint, v = u === 0;
  switch (a) {
    case ScalarType.STRING:
      v = c || !u.length, l = WireType.LengthDelimited;
      break;
    case ScalarType.BOOL:
      v = u === !1;
      break;
    case ScalarType.DOUBLE:
      l = WireType.Bit64;
      break;
    case ScalarType.FLOAT:
      l = WireType.Bit32;
      break;
    case ScalarType.INT64:
      v = c || u == 0;
      break;
    case ScalarType.UINT64:
      v = c || u == 0;
      break;
    case ScalarType.FIXED64:
      v = c || u == 0, l = WireType.Bit64;
      break;
    case ScalarType.BYTES:
      v = c || !u.byteLength, l = WireType.LengthDelimited;
      break;
    case ScalarType.FIXED32:
      l = WireType.Bit32;
      break;
    case ScalarType.SFIXED32:
      l = WireType.Bit32;
      break;
    case ScalarType.SFIXED64:
      v = c || u == 0, l = WireType.Bit64;
      break;
    case ScalarType.SINT64:
      v = c || u == 0;
      break;
  }
  const p = ScalarType[a].toLowerCase();
  return [l, p, c || v];
}
function makeExtension(a, u, c, l) {
  let v;
  return {
    typeName: u,
    extendee: c,
    get field() {
      if (!v) {
        const p = typeof l == "function" ? l() : l;
        p.name = u.split(".").pop(), p.jsonName = "[".concat(u, "]"), v = a.util.newFieldList([p]).list()[0];
      }
      return v;
    },
    runtime: a
  };
}
function createExtensionContainer(a) {
  const u = a.field.localName, c = /* @__PURE__ */ Object.create(null);
  return c[u] = initExtensionField(a), [c, () => c[u]];
}
function initExtensionField(a) {
  const u = a.field;
  if (u.repeated)
    return [];
  if (u.default !== void 0)
    return u.default;
  switch (u.kind) {
    case "enum":
      return u.T.values[0].no;
    case "scalar":
      return scalarDefaultValue(u.T, u.L);
    case "message":
      const c = u.T, l = new c();
      return c.fieldWrapper ? c.fieldWrapper.unwrapField(l) : l;
    case "map":
      throw "map fields are not allowed to be extensions";
  }
}
function filterUnknownFields(a, u) {
  if (!u.repeated && (u.kind == "enum" || u.kind == "scalar")) {
    for (let c = a.length - 1; c >= 0; --c)
      if (a[c].no == u.no)
        return [a[c]];
    return [];
  }
  return a.filter((c) => c.no === u.no);
}
function makeProtoRuntime(a, u, c, l) {
  return {
    syntax: a,
    json: u,
    bin: c,
    util: l,
    makeMessageType(v, p, _) {
      return makeMessageType(this, v, p, _);
    },
    makeEnum,
    makeEnumType,
    getEnumType,
    makeExtension(v, p, _) {
      return makeExtension(this, v, p, _);
    }
  };
}
function wrapField(a, u) {
  return u instanceof Message || !a.fieldWrapper ? u : a.fieldWrapper.wrapField(u);
}
ScalarType.DOUBLE, ScalarType.FLOAT, ScalarType.INT64, ScalarType.UINT64, ScalarType.INT32, ScalarType.UINT32, ScalarType.BOOL, ScalarType.STRING, ScalarType.BYTES;
const unknownFieldsSymbol = Symbol("@bufbuild/protobuf/unknown-fields"), readDefaults = {
  readUnknownFields: !0,
  readerFactory: (a) => new BinaryReader(a)
}, writeDefaults = {
  writeUnknownFields: !0,
  writerFactory: () => new BinaryWriter()
};
function makeReadOptions$1(a) {
  return a ? Object.assign(Object.assign({}, readDefaults), a) : readDefaults;
}
function makeWriteOptions$1(a) {
  return a ? Object.assign(Object.assign({}, writeDefaults), a) : writeDefaults;
}
function makeBinaryFormatCommon() {
  return {
    makeReadOptions: makeReadOptions$1,
    makeWriteOptions: makeWriteOptions$1,
    listUnknownFields(a) {
      var u;
      return (u = a[unknownFieldsSymbol]) !== null && u !== void 0 ? u : [];
    },
    discardUnknownFields(a) {
      delete a[unknownFieldsSymbol];
    },
    writeUnknownFields(a, u) {
      const l = a[unknownFieldsSymbol];
      if (l)
        for (const v of l)
          u.tag(v.no, v.wireType).raw(v.data);
    },
    onUnknownField(a, u, c, l) {
      const v = a;
      Array.isArray(v[unknownFieldsSymbol]) || (v[unknownFieldsSymbol] = []), v[unknownFieldsSymbol].push({
        no: u,
        wireType: c,
        data: l
      });
    },
    readMessage(a, u, c, l, v) {
      const p = a.getType(), _ = v ? u.len : u.pos + c;
      let k, M;
      for (; u.pos < _ && ([k, M] = u.tag(), M != WireType.EndGroup); ) {
        const L = p.fields.find(k);
        if (!L) {
          const F = u.skip(M);
          l.readUnknownFields && this.onUnknownField(a, k, M, F);
          continue;
        }
        readField$1(a, u, L, M, l);
      }
      if (v && // eslint-disable-line @typescript-eslint/strict-boolean-expressions
      (M != WireType.EndGroup || k !== c))
        throw new Error("invalid end group tag");
    },
    readField: readField$1
  };
}
function readField$1(a, u, c, l, v) {
  let {
    repeated: p,
    localName: _
  } = c;
  switch (c.oneof && (a = a[c.oneof.localName], a.case != _ && delete a.value, a.case = _, _ = "value"), c.kind) {
    case "scalar":
    case "enum":
      const k = c.kind == "enum" ? ScalarType.INT32 : c.T;
      let M = readScalar$1;
      if (c.kind == "scalar" && c.L > 0 && (M = readScalarLTString), p) {
        let X = a[_];
        if (l == WireType.LengthDelimited && k != ScalarType.STRING && k != ScalarType.BYTES) {
          let Y = u.uint32() + u.pos;
          for (; u.pos < Y; )
            X.push(M(u, k));
        } else
          X.push(M(u, k));
      } else
        a[_] = M(u, k);
      break;
    case "message":
      const L = c.T;
      p ? a[_].push(readMessageField(u, new L(), v, c)) : a[_] instanceof Message ? readMessageField(u, a[_], v, c) : (a[_] = readMessageField(u, new L(), v, c), L.fieldWrapper && !c.oneof && !c.repeated && (a[_] = L.fieldWrapper.unwrapField(a[_])));
      break;
    case "map":
      let [F, V] = readMapEntry(c, u, v);
      a[_][F] = V;
      break;
  }
}
function readMessageField(a, u, c, l) {
  const v = u.getType().runtime.bin, p = l == null ? void 0 : l.delimited;
  return v.readMessage(
    u,
    a,
    p ? l == null ? void 0 : l.no : a.uint32(),
    // eslint-disable-line @typescript-eslint/strict-boolean-expressions
    c,
    p
  ), u;
}
function readMapEntry(a, u, c) {
  const l = u.uint32(), v = u.pos + l;
  let p, _;
  for (; u.pos < v; ) {
    let [k] = u.tag();
    switch (k) {
      case 1:
        p = readScalar$1(u, a.K);
        break;
      case 2:
        switch (a.V.kind) {
          case "scalar":
            _ = readScalar$1(u, a.V.T);
            break;
          case "enum":
            _ = u.int32();
            break;
          case "message":
            _ = readMessageField(u, new a.V.T(), c, void 0);
            break;
        }
        break;
    }
  }
  if (p === void 0) {
    let k = scalarDefaultValue(a.K, LongType.BIGINT);
    p = a.K == ScalarType.BOOL ? k.toString() : k;
  }
  if (typeof p != "string" && typeof p != "number" && (p = p.toString()), _ === void 0)
    switch (a.V.kind) {
      case "scalar":
        _ = scalarDefaultValue(a.V.T, LongType.BIGINT);
        break;
      case "enum":
        _ = 0;
        break;
      case "message":
        _ = new a.V.T();
        break;
    }
  return [p, _];
}
function readScalarLTString(a, u) {
  const c = readScalar$1(a, u);
  return typeof c == "bigint" ? c.toString() : c;
}
function readScalar$1(a, u) {
  switch (u) {
    case ScalarType.STRING:
      return a.string();
    case ScalarType.BOOL:
      return a.bool();
    case ScalarType.DOUBLE:
      return a.double();
    case ScalarType.FLOAT:
      return a.float();
    case ScalarType.INT32:
      return a.int32();
    case ScalarType.INT64:
      return a.int64();
    case ScalarType.UINT64:
      return a.uint64();
    case ScalarType.FIXED64:
      return a.fixed64();
    case ScalarType.BYTES:
      return a.bytes();
    case ScalarType.FIXED32:
      return a.fixed32();
    case ScalarType.SFIXED32:
      return a.sfixed32();
    case ScalarType.SFIXED64:
      return a.sfixed64();
    case ScalarType.SINT64:
      return a.sint64();
    case ScalarType.UINT32:
      return a.uint32();
    case ScalarType.SINT32:
      return a.sint32();
  }
}
function writeMapEntry(a, u, c, l, v) {
  a.tag(c.no, WireType.LengthDelimited), a.fork();
  let p = l;
  switch (c.K) {
    case ScalarType.INT32:
    case ScalarType.FIXED32:
    case ScalarType.UINT32:
    case ScalarType.SFIXED32:
    case ScalarType.SINT32:
      p = Number.parseInt(l);
      break;
    case ScalarType.BOOL:
      assert$k(l == "true" || l == "false"), p = l == "true";
      break;
  }
  switch (writeScalar$1(a, c.K, 1, p, !0), c.V.kind) {
    case "scalar":
      writeScalar$1(a, c.V.T, 2, v, !0);
      break;
    case "enum":
      writeScalar$1(a, ScalarType.INT32, 2, v, !0);
      break;
    case "message":
      a.tag(2, WireType.LengthDelimited).bytes(v.toBinary(u));
      break;
  }
  a.join();
}
function writeMessageField(a, u, c, l) {
  const v = wrapField(c.T, l);
  c != null && c.delimited ? a.tag(c.no, WireType.StartGroup).raw(v.toBinary(u)).tag(c.no, WireType.EndGroup) : a.tag(c.no, WireType.LengthDelimited).bytes(v.toBinary(u));
}
function writeScalar$1(a, u, c, l, v) {
  let [p, _, k] = scalarTypeInfo(u, l);
  (!k || v) && a.tag(c, p)[_](l);
}
function writePacked(a, u, c, l) {
  if (!l.length)
    return;
  a.tag(c, WireType.LengthDelimited).fork();
  let [, v] = scalarTypeInfo(u);
  for (let p = 0; p < l.length; p++)
    a[v](l[p]);
  a.join();
}
function makeBinaryFormatProto3() {
  return Object.assign(Object.assign({}, makeBinaryFormatCommon()), {
    writeField,
    writeMessage(a, u, c) {
      const l = a.getType();
      for (const v of l.fields.byNumber()) {
        let p, _ = v.localName;
        if (v.oneof) {
          const k = a[v.oneof.localName];
          if (k.case !== _)
            continue;
          p = k.value;
        } else
          p = a[_];
        writeField(v, p, u, c);
      }
      return c.writeUnknownFields && this.writeUnknownFields(a, u), u;
    }
  });
}
function writeField(a, u, c, l) {
  const v = a.repeated;
  switch (a.kind) {
    case "scalar":
    case "enum":
      let p = a.kind == "enum" ? ScalarType.INT32 : a.T;
      if (v)
        if (a.packed)
          writePacked(c, p, a.no, u);
        else
          for (const _ of u)
            writeScalar$1(c, p, a.no, _, !0);
      else
        u !== void 0 && writeScalar$1(c, p, a.no, u, !!a.oneof || a.opt);
      break;
    case "message":
      if (v)
        for (const _ of u)
          writeMessageField(c, l, a, _);
      else
        u !== void 0 && writeMessageField(c, l, a, u);
      break;
    case "map":
      for (const [_, k] of Object.entries(u))
        writeMapEntry(c, l, a, _, k);
      break;
  }
}
let encTable = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split(""), decTable = [];
for (let a = 0; a < encTable.length; a++)
  decTable[encTable[a].charCodeAt(0)] = a;
decTable[45] = encTable.indexOf("+");
decTable[95] = encTable.indexOf("/");
const protoBase64 = {
  /**
   * Decodes a base64 string to a byte array.
   *
   * - ignores white-space, including line breaks and tabs
   * - allows inner padding (can decode concatenated base64 strings)
   * - does not require padding
   * - understands base64url encoding:
   *   "-" instead of "+",
   *   "_" instead of "/",
   *   no padding
   */
  dec(a) {
    let u = a.length * 3 / 4;
    a[a.length - 2] == "=" ? u -= 2 : a[a.length - 1] == "=" && (u -= 1);
    let c = new Uint8Array(u), l = 0, v = 0, p, _ = 0;
    for (let k = 0; k < a.length; k++) {
      if (p = decTable[a.charCodeAt(k)], p === void 0)
        switch (a[k]) {
          case "=":
            v = 0;
          case `
`:
          case "\r":
          case "	":
          case " ":
            continue;
          default:
            throw Error("invalid base64 string.");
        }
      switch (v) {
        case 0:
          _ = p, v = 1;
          break;
        case 1:
          c[l++] = _ << 2 | (p & 48) >> 4, _ = p, v = 2;
          break;
        case 2:
          c[l++] = (_ & 15) << 4 | (p & 60) >> 2, _ = p, v = 3;
          break;
        case 3:
          c[l++] = (_ & 3) << 6 | p, v = 0;
          break;
      }
    }
    if (v == 1)
      throw Error("invalid base64 string.");
    return c.subarray(0, l);
  },
  /**
   * Encode a byte array to a base64 string.
   */
  enc(a) {
    let u = "", c = 0, l, v = 0;
    for (let p = 0; p < a.length; p++)
      switch (l = a[p], c) {
        case 0:
          u += encTable[l >> 2], v = (l & 3) << 4, c = 1;
          break;
        case 1:
          u += encTable[v | l >> 4], v = (l & 15) << 2, c = 2;
          break;
        case 2:
          u += encTable[v | l >> 6], u += encTable[l & 63], c = 0;
          break;
      }
    return c && (u += encTable[v], u += "=", c == 1 && (u += "=")), u;
  }
};
function getExtension(a, u, c) {
  assertExtendee(u, a);
  const l = u.runtime.bin.makeReadOptions(c), v = filterUnknownFields(a.getType().runtime.bin.listUnknownFields(a), u.field), [p, _] = createExtensionContainer(u);
  for (const k of v)
    u.runtime.bin.readField(p, l.readerFactory(k.data), u.field, k.wireType, l);
  return _();
}
function setExtension(a, u, c, l) {
  assertExtendee(u, a);
  const v = u.runtime.bin.makeReadOptions(l), p = u.runtime.bin.makeWriteOptions(l);
  if (hasExtension(a, u)) {
    const L = a.getType().runtime.bin.listUnknownFields(a).filter((F) => F.no != u.field.no);
    a.getType().runtime.bin.discardUnknownFields(a);
    for (const F of L)
      a.getType().runtime.bin.onUnknownField(a, F.no, F.wireType, F.data);
  }
  const _ = p.writerFactory();
  let k = u.field;
  !k.opt && !k.repeated && (k.kind == "enum" || k.kind == "scalar") && (k = Object.assign(Object.assign({}, u.field), {
    opt: !0
  })), u.runtime.bin.writeField(k, c, _, p);
  const M = v.readerFactory(_.finish());
  for (; M.pos < M.len; ) {
    const [L, F] = M.tag(), V = M.skip(F);
    a.getType().runtime.bin.onUnknownField(a, L, F, V);
  }
}
function hasExtension(a, u) {
  const c = a.getType();
  return u.extendee.typeName === c.typeName && !!c.runtime.bin.listUnknownFields(a).find((l) => l.no == u.field.no);
}
function assertExtendee(a, u) {
  assert$k(a.extendee.typeName == u.getType().typeName, "extension ".concat(a.typeName, " can only be applied to message ").concat(a.extendee.typeName));
}
const jsonReadDefaults = {
  ignoreUnknownFields: !1
}, jsonWriteDefaults = {
  emitDefaultValues: !1,
  enumAsInteger: !1,
  useProtoFieldName: !1,
  prettySpaces: 0
};
function makeReadOptions(a) {
  return a ? Object.assign(Object.assign({}, jsonReadDefaults), a) : jsonReadDefaults;
}
function makeWriteOptions(a) {
  return a ? Object.assign(Object.assign({}, jsonWriteDefaults), a) : jsonWriteDefaults;
}
function makeJsonFormatCommon(a, u) {
  const c = u(writeEnum, writeScalar);
  return {
    makeReadOptions,
    makeWriteOptions,
    readMessage(l, v, p, _) {
      if (v == null || Array.isArray(v) || typeof v != "object")
        throw new Error("cannot decode message ".concat(l.typeName, " from JSON: ").concat(debugJsonValue(v)));
      _ = _ ?? new l();
      const k = /* @__PURE__ */ new Map(), M = p.typeRegistry;
      for (const [L, F] of Object.entries(v)) {
        const V = l.fields.findJsonName(L);
        if (V) {
          if (V.oneof) {
            if (F === null && V.kind == "scalar")
              continue;
            const X = k.get(V.oneof);
            if (X !== void 0)
              throw new Error("cannot decode message ".concat(l.typeName, ' from JSON: multiple keys for oneof "').concat(V.oneof.name, '" present: "').concat(X, '", "').concat(L, '"'));
            k.set(V.oneof, L);
          }
          readField(_, F, V, p, l, a);
        } else {
          let X = !1;
          if (M != null && M.findExtension && L.startsWith("[") && L.endsWith("]")) {
            const oe = M.findExtension(L.substring(1, L.length - 1));
            if (oe && oe.extendee.typeName == l.typeName) {
              X = !0;
              const [Y, ae] = createExtensionContainer(oe);
              readField(Y, F, oe.field, p, oe, !0), setExtension(_, oe, ae(), p);
            }
          }
          if (!X && !p.ignoreUnknownFields)
            throw new Error("cannot decode message ".concat(l.typeName, ' from JSON: key "').concat(L, '" is unknown'));
        }
      }
      return _;
    },
    writeMessage(l, v) {
      const p = l.getType(), _ = {};
      let k;
      try {
        for (const L of p.fields.byMember()) {
          let F;
          if (L.kind == "oneof") {
            const V = l[L.localName];
            if (V.value === void 0)
              continue;
            if (k = L.findField(V.case), !k)
              throw "oneof case not found: " + V.case;
            F = c(k, V.value, v);
          } else
            k = L, F = c(k, l[k.localName], v);
          F !== void 0 && (_[v.useProtoFieldName ? k.name : k.jsonName] = F);
        }
        const M = v.typeRegistry;
        if (M != null && M.findExtensionFor)
          for (const L of p.runtime.bin.listUnknownFields(l)) {
            const F = M.findExtensionFor(p.typeName, L.no);
            if (F && hasExtension(l, F)) {
              const V = getExtension(l, F, v), X = c(F.field, V, v);
              X !== void 0 && (_[F.field.jsonName] = X);
            }
          }
      } catch (M) {
        const L = k ? "cannot encode field ".concat(p.typeName, ".").concat(k.name, " to JSON") : "cannot encode message ".concat(p.typeName, " to JSON"), F = M instanceof Error ? M.message : String(M);
        throw new Error(L + (F.length > 0 ? ": ".concat(F) : ""));
      }
      return _;
    },
    readScalar: (l, v, p) => readScalar(l, v, p, a),
    // eslint-disable-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-return
    writeScalar,
    debug: debugJsonValue
  };
}
function debugJsonValue(a) {
  if (a === null)
    return "null";
  switch (typeof a) {
    case "object":
      return Array.isArray(a) ? "array" : "object";
    case "string":
      return a.length > 100 ? "string" : '"'.concat(a.split('"').join('\\"'), '"');
    default:
      return String(a);
  }
}
function readField(a, u, c, l, v, p) {
  let _ = c.localName;
  if (c.oneof) {
    if (u === null && c.kind == "scalar")
      return;
    a = a[c.oneof.localName] = {
      case: _
    }, _ = "value";
  }
  if (c.repeated) {
    if (u === null)
      return;
    if (!Array.isArray(u))
      throw new Error("cannot decode field ".concat(v.typeName, ".").concat(c.name, " from JSON: ").concat(debugJsonValue(u)));
    const k = a[_];
    for (const M of u) {
      if (M === null)
        throw new Error("cannot decode field ".concat(v.typeName, ".").concat(c.name, " from JSON: ").concat(debugJsonValue(M)));
      let L;
      switch (c.kind) {
        case "message":
          L = c.T.fromJson(M, l);
          break;
        case "enum":
          if (L = readEnum(c.T, M, l.ignoreUnknownFields, !0), L === void 0)
            continue;
          break;
        case "scalar":
          try {
            L = readScalar(c.T, M, c.L, !0);
          } catch (F) {
            let V = "cannot decode field ".concat(v.typeName, ".").concat(c.name, " from JSON: ").concat(debugJsonValue(M));
            throw F instanceof Error && F.message.length > 0 && (V += ": ".concat(F.message)), new Error(V);
          }
          break;
      }
      k.push(L);
    }
  } else if (c.kind == "map") {
    if (u === null)
      return;
    if (typeof u != "object" || Array.isArray(u))
      throw new Error("cannot decode field ".concat(v.typeName, ".").concat(c.name, " from JSON: ").concat(debugJsonValue(u)));
    const k = a[_];
    for (const [M, L] of Object.entries(u)) {
      if (L === null)
        throw new Error("cannot decode field ".concat(v.typeName, ".").concat(c.name, " from JSON: map value null"));
      let F;
      switch (c.V.kind) {
        case "message":
          F = c.V.T.fromJson(L, l);
          break;
        case "enum":
          if (F = readEnum(c.V.T, L, l.ignoreUnknownFields, !0), F === void 0)
            continue;
          break;
        case "scalar":
          try {
            F = readScalar(c.V.T, L, LongType.BIGINT, !0);
          } catch (V) {
            let X = "cannot decode map value for field ".concat(v.typeName, ".").concat(c.name, " from JSON: ").concat(debugJsonValue(u));
            throw V instanceof Error && V.message.length > 0 && (X += ": ".concat(V.message)), new Error(X);
          }
          break;
      }
      try {
        k[readScalar(c.K, c.K == ScalarType.BOOL ? M == "true" ? !0 : M == "false" ? !1 : M : M, LongType.BIGINT, !0).toString()] = F;
      } catch (V) {
        let X = "cannot decode map key for field ".concat(v.typeName, ".").concat(c.name, " from JSON: ").concat(debugJsonValue(u));
        throw V instanceof Error && V.message.length > 0 && (X += ": ".concat(V.message)), new Error(X);
      }
    }
  } else
    switch (c.kind) {
      case "message":
        const k = c.T;
        if (u === null && k.typeName != "google.protobuf.Value") {
          if (c.oneof)
            throw new Error("cannot decode field ".concat(v.typeName, ".").concat(c.name, " from JSON: null is invalid for oneof field"));
          return;
        }
        a[_] instanceof Message ? a[_].fromJson(u, l) : (a[_] = k.fromJson(u, l), k.fieldWrapper && !c.oneof && (a[_] = k.fieldWrapper.unwrapField(a[_])));
        break;
      case "enum":
        const M = readEnum(c.T, u, l.ignoreUnknownFields, p);
        M !== void 0 && (a[_] = M);
        break;
      case "scalar":
        try {
          a[_] = readScalar(c.T, u, c.L, p);
        } catch (L) {
          let F = "cannot decode field ".concat(v.typeName, ".").concat(c.name, " from JSON: ").concat(debugJsonValue(u));
          throw L instanceof Error && L.message.length > 0 && (F += ": ".concat(L.message)), new Error(F);
        }
        break;
    }
}
function readScalar(a, u, c, l) {
  switch (a) {
    case ScalarType.DOUBLE:
    case ScalarType.FLOAT:
      if (u === null)
        return l ? 0 : void 0;
      if (u === "NaN")
        return Number.NaN;
      if (u === "Infinity")
        return Number.POSITIVE_INFINITY;
      if (u === "-Infinity")
        return Number.NEGATIVE_INFINITY;
      if (u === "" || typeof u == "string" && u.trim().length !== u.length || typeof u != "string" && typeof u != "number")
        break;
      const v = Number(u);
      if (Number.isNaN(v) || !Number.isFinite(v))
        break;
      return a == ScalarType.FLOAT && assertFloat32(v), v;
    case ScalarType.INT32:
    case ScalarType.FIXED32:
    case ScalarType.SFIXED32:
    case ScalarType.SINT32:
    case ScalarType.UINT32:
      if (u === null)
        return l ? 0 : void 0;
      let p;
      if (typeof u == "number" ? p = u : typeof u == "string" && u.length > 0 && u.trim().length === u.length && (p = Number(u)), p === void 0)
        break;
      return a == ScalarType.UINT32 ? assertUInt32(p) : assertInt32(p), p;
    case ScalarType.INT64:
    case ScalarType.SFIXED64:
    case ScalarType.SINT64:
      if (u === null)
        return l ? protoInt64.zero : void 0;
      if (typeof u != "number" && typeof u != "string")
        break;
      const _ = protoInt64.parse(u);
      return c ? _.toString() : _;
    case ScalarType.FIXED64:
    case ScalarType.UINT64:
      if (u === null)
        return l ? protoInt64.zero : void 0;
      if (typeof u != "number" && typeof u != "string")
        break;
      const k = protoInt64.uParse(u);
      return c ? k.toString() : k;
    case ScalarType.BOOL:
      if (u === null)
        return l ? !1 : void 0;
      if (typeof u != "boolean")
        break;
      return u;
    case ScalarType.STRING:
      if (u === null)
        return l ? "" : void 0;
      if (typeof u != "string")
        break;
      try {
        encodeURIComponent(u);
      } catch {
        throw new Error("invalid UTF8");
      }
      return u;
    case ScalarType.BYTES:
      if (u === null)
        return l ? new Uint8Array(0) : void 0;
      if (u === "")
        return new Uint8Array(0);
      if (typeof u != "string")
        break;
      return protoBase64.dec(u);
  }
  throw new Error();
}
function readEnum(a, u, c, l) {
  if (u === null)
    return l ? a.values[0].no : void 0;
  switch (typeof u) {
    case "number":
      if (Number.isInteger(u))
        return u;
      break;
    case "string":
      const v = a.findName(u);
      if (v || c)
        return v == null ? void 0 : v.no;
      break;
  }
  throw new Error("cannot decode enum ".concat(a.typeName, " from JSON: ").concat(debugJsonValue(u)));
}
function writeEnum(a, u, c, l) {
  var v;
  if (u === void 0)
    return u;
  if (!c && a.values[0].no === u)
    return;
  if (l)
    return u;
  if (a.typeName == "google.protobuf.NullValue")
    return null;
  const p = a.findNumber(u);
  return (v = p == null ? void 0 : p.name) !== null && v !== void 0 ? v : u;
}
function writeScalar(a, u, c) {
  if (u !== void 0)
    switch (a) {
      case ScalarType.INT32:
      case ScalarType.SFIXED32:
      case ScalarType.SINT32:
      case ScalarType.FIXED32:
      case ScalarType.UINT32:
        return assert$k(typeof u == "number"), u != 0 || c ? u : void 0;
      case ScalarType.FLOAT:
      case ScalarType.DOUBLE:
        return assert$k(typeof u == "number"), Number.isNaN(u) ? "NaN" : u === Number.POSITIVE_INFINITY ? "Infinity" : u === Number.NEGATIVE_INFINITY ? "-Infinity" : u !== 0 || c ? u : void 0;
      case ScalarType.STRING:
        return assert$k(typeof u == "string"), u.length > 0 || c ? u : void 0;
      case ScalarType.BOOL:
        return assert$k(typeof u == "boolean"), u || c ? u : void 0;
      case ScalarType.UINT64:
      case ScalarType.FIXED64:
      case ScalarType.INT64:
      case ScalarType.SFIXED64:
      case ScalarType.SINT64:
        return assert$k(typeof u == "bigint" || typeof u == "string" || typeof u == "number"), c || u != 0 ? u.toString(10) : void 0;
      case ScalarType.BYTES:
        return assert$k(u instanceof Uint8Array), c || u.byteLength > 0 ? protoBase64.enc(u) : void 0;
    }
}
function makeJsonFormatProto3() {
  return makeJsonFormatCommon(!0, (a, u) => function(l, v, p) {
    if (l.kind == "map") {
      const _ = {};
      switch (l.V.kind) {
        case "scalar":
          for (const [M, L] of Object.entries(v)) {
            const F = u(l.V.T, L, !0);
            assert$k(F !== void 0), _[M.toString()] = F;
          }
          break;
        case "message":
          for (const [M, L] of Object.entries(v))
            _[M.toString()] = L.toJson(p);
          break;
        case "enum":
          const k = l.V.T;
          for (const [M, L] of Object.entries(v)) {
            assert$k(L === void 0 || typeof L == "number");
            const F = a(k, L, !0, p.enumAsInteger);
            assert$k(F !== void 0), _[M.toString()] = F;
          }
          break;
      }
      return p.emitDefaultValues || Object.keys(_).length > 0 ? _ : void 0;
    } else if (l.repeated) {
      const _ = [];
      switch (l.kind) {
        case "scalar":
          for (let k = 0; k < v.length; k++)
            _.push(u(l.T, v[k], !0));
          break;
        case "enum":
          for (let k = 0; k < v.length; k++)
            _.push(a(l.T, v[k], !0, p.enumAsInteger));
          break;
        case "message":
          for (let k = 0; k < v.length; k++)
            _.push(v[k].toJson(p));
          break;
      }
      return p.emitDefaultValues || _.length > 0 ? _ : void 0;
    } else {
      if (v === void 0)
        return;
      switch (l.kind) {
        case "scalar":
          return u(l.T, v, !!l.oneof || l.opt || p.emitDefaultValues);
        case "enum":
          return a(l.T, v, !!l.oneof || l.opt || p.emitDefaultValues, p.enumAsInteger);
        case "message":
          return wrapField(l.T, v).toJson(p);
      }
    }
  });
}
function makeUtilCommon() {
  return {
    setEnumType,
    initPartial(a, u) {
      if (a === void 0)
        return;
      const c = u.getType();
      for (const l of c.fields.byMember()) {
        const v = l.localName, p = u, _ = a;
        if (_[v] !== void 0)
          switch (l.kind) {
            case "oneof":
              const k = _[v].case;
              if (k === void 0)
                continue;
              const M = l.findField(k);
              let L = _[v].value;
              M && M.kind == "message" && !(L instanceof M.T) ? L = new M.T(L) : M && M.kind === "scalar" && M.T === ScalarType.BYTES && (L = toU8Arr(L)), p[v] = {
                case: k,
                value: L
              };
              break;
            case "scalar":
            case "enum":
              let F = _[v];
              l.T === ScalarType.BYTES && (F = l.repeated ? F.map(toU8Arr) : toU8Arr(F)), p[v] = F;
              break;
            case "map":
              switch (l.V.kind) {
                case "scalar":
                case "enum":
                  if (l.V.T === ScalarType.BYTES)
                    for (const [oe, Y] of Object.entries(_[v]))
                      p[v][oe] = toU8Arr(Y);
                  else
                    Object.assign(p[v], _[v]);
                  break;
                case "message":
                  const X = l.V.T;
                  for (const oe of Object.keys(_[v])) {
                    let Y = _[v][oe];
                    X.fieldWrapper || (Y = new X(Y)), p[v][oe] = Y;
                  }
                  break;
              }
              break;
            case "message":
              const V = l.T;
              if (l.repeated)
                p[v] = _[v].map((X) => X instanceof V ? X : new V(X));
              else if (_[v] !== void 0) {
                const X = _[v];
                V.fieldWrapper ? /* We can't use BytesValue.typeName as that will create a circular import */ V.typeName === "google.protobuf.BytesValue" ? p[v] = toU8Arr(X) : p[v] = X : p[v] = X instanceof V ? X : new V(X);
              }
              break;
          }
      }
    },
    equals(a, u, c) {
      return u === c ? !0 : !u || !c ? !1 : a.fields.byMember().every((l) => {
        const v = u[l.localName], p = c[l.localName];
        if (l.repeated) {
          if (v.length !== p.length)
            return !1;
          switch (l.kind) {
            case "message":
              return v.every((_, k) => l.T.equals(_, p[k]));
            case "scalar":
              return v.every((_, k) => scalarEquals(l.T, _, p[k]));
            case "enum":
              return v.every((_, k) => scalarEquals(ScalarType.INT32, _, p[k]));
          }
          throw new Error("repeated cannot contain ".concat(l.kind));
        }
        switch (l.kind) {
          case "message":
            return l.T.equals(v, p);
          case "enum":
            return scalarEquals(ScalarType.INT32, v, p);
          case "scalar":
            return scalarEquals(l.T, v, p);
          case "oneof":
            if (v.case !== p.case)
              return !1;
            const _ = l.findField(v.case);
            if (_ === void 0)
              return !0;
            switch (_.kind) {
              case "message":
                return _.T.equals(v.value, p.value);
              case "enum":
                return scalarEquals(ScalarType.INT32, v.value, p.value);
              case "scalar":
                return scalarEquals(_.T, v.value, p.value);
            }
            throw new Error("oneof cannot contain ".concat(_.kind));
          case "map":
            const k = Object.keys(v).concat(Object.keys(p));
            switch (l.V.kind) {
              case "message":
                const M = l.V.T;
                return k.every((F) => M.equals(v[F], p[F]));
              case "enum":
                return k.every((F) => scalarEquals(ScalarType.INT32, v[F], p[F]));
              case "scalar":
                const L = l.V.T;
                return k.every((F) => scalarEquals(L, v[F], p[F]));
            }
            break;
        }
      });
    },
    clone(a) {
      const u = a.getType(), c = new u(), l = c;
      for (const v of u.fields.byMember()) {
        const p = a[v.localName];
        let _;
        if (v.repeated)
          _ = p.map(cloneSingularField);
        else if (v.kind == "map") {
          _ = l[v.localName];
          for (const [k, M] of Object.entries(p))
            _[k] = cloneSingularField(M);
        } else
          v.kind == "oneof" ? _ = v.findField(p.case) ? {
            case: p.case,
            value: cloneSingularField(p.value)
          } : {
            case: void 0
          } : _ = cloneSingularField(p);
        l[v.localName] = _;
      }
      return c;
    }
  };
}
function cloneSingularField(a) {
  if (a === void 0)
    return a;
  if (a instanceof Message)
    return a.clone();
  if (a instanceof Uint8Array) {
    const u = new Uint8Array(a.byteLength);
    return u.set(a), u;
  }
  return a;
}
function toU8Arr(a) {
  return a instanceof Uint8Array ? a : new Uint8Array(a);
}
class InternalFieldList {
  constructor(u, c) {
    this._fields = u, this._normalizer = c;
  }
  findJsonName(u) {
    if (!this.jsonNames) {
      const c = {};
      for (const l of this.list())
        c[l.jsonName] = c[l.name] = l;
      this.jsonNames = c;
    }
    return this.jsonNames[u];
  }
  find(u) {
    if (!this.numbers) {
      const c = {};
      for (const l of this.list())
        c[l.no] = l;
      this.numbers = c;
    }
    return this.numbers[u];
  }
  list() {
    return this.all || (this.all = this._normalizer(this._fields)), this.all;
  }
  byNumber() {
    return this.numbersAsc || (this.numbersAsc = this.list().concat().sort((u, c) => u.no - c.no)), this.numbersAsc;
  }
  byMember() {
    if (!this.members) {
      this.members = [];
      const u = this.members;
      let c;
      for (const l of this.list())
        l.oneof ? l.oneof !== c && (c = l.oneof, u.push(c)) : u.push(l);
    }
    return this.members;
  }
}
function localFieldName(a, u) {
  const c = protoCamelCase(a);
  return u ? c : safeObjectProperty(safeMessageProperty(c));
}
function localOneofName(a) {
  return localFieldName(a, !1);
}
const fieldJsonName = protoCamelCase;
function protoCamelCase(a) {
  let u = !1;
  const c = [];
  for (let l = 0; l < a.length; l++) {
    let v = a.charAt(l);
    switch (v) {
      case "_":
        u = !0;
        break;
      case "0":
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        c.push(v), u = !1;
        break;
      default:
        u && (u = !1, v = v.toUpperCase()), c.push(v);
        break;
    }
  }
  return c.join("");
}
const reservedObjectProperties = /* @__PURE__ */ new Set([
  // names reserved by JavaScript
  "constructor",
  "toString",
  "toJSON",
  "valueOf"
]), reservedMessageProperties = /* @__PURE__ */ new Set([
  // names reserved by the runtime
  "getType",
  "clone",
  "equals",
  "fromBinary",
  "fromJson",
  "fromJsonString",
  "toBinary",
  "toJson",
  "toJsonString",
  // names reserved by the runtime for the future
  "toObject"
]), fallback = (a) => "".concat(a, "$"), safeMessageProperty = (a) => reservedMessageProperties.has(a) ? fallback(a) : a, safeObjectProperty = (a) => reservedObjectProperties.has(a) ? fallback(a) : a;
class InternalOneofInfo {
  constructor(u) {
    this.kind = "oneof", this.repeated = !1, this.packed = !1, this.opt = !1, this.default = void 0, this.fields = [], this.name = u, this.localName = localOneofName(u);
  }
  addField(u) {
    assert$k(u.oneof === this, "field ".concat(u.name, " not one of ").concat(this.name)), this.fields.push(u);
  }
  findField(u) {
    if (!this._lookup) {
      this._lookup = /* @__PURE__ */ Object.create(null);
      for (let c = 0; c < this.fields.length; c++)
        this._lookup[this.fields[c].localName] = this.fields[c];
    }
    return this._lookup[u];
  }
}
const proto3 = makeProtoRuntime("proto3", makeJsonFormatProto3(), makeBinaryFormatProto3(), Object.assign(Object.assign({}, makeUtilCommon()), {
  newFieldList(a) {
    return new InternalFieldList(a, normalizeFieldInfosProto3);
  },
  initFields(a) {
    for (const u of a.getType().fields.byMember()) {
      if (u.opt)
        continue;
      const c = u.localName, l = a;
      if (u.repeated) {
        l[c] = [];
        continue;
      }
      switch (u.kind) {
        case "oneof":
          l[c] = {
            case: void 0
          };
          break;
        case "enum":
          l[c] = 0;
          break;
        case "map":
          l[c] = {};
          break;
        case "scalar":
          l[c] = scalarDefaultValue(u.T, u.L);
          break;
      }
    }
  }
}));
function normalizeFieldInfosProto3(a) {
  var u, c, l, v;
  const p = [];
  let _;
  for (const k of typeof a == "function" ? a() : a) {
    const M = k;
    if (M.localName = localFieldName(k.name, k.oneof !== void 0), M.jsonName = (u = k.jsonName) !== null && u !== void 0 ? u : fieldJsonName(k.name), M.repeated = (c = k.repeated) !== null && c !== void 0 ? c : !1, k.kind == "scalar" && (M.L = (l = k.L) !== null && l !== void 0 ? l : LongType.BIGINT), k.oneof !== void 0) {
      const L = typeof k.oneof == "string" ? k.oneof : k.oneof.name;
      (!_ || _.name != L) && (_ = new InternalOneofInfo(L)), M.oneof = _, _.addField(M);
    }
    k.kind == "message" && (M.delimited = !1), M.packed = (v = k.packed) !== null && v !== void 0 ? v : k.kind == "enum" || k.kind == "scalar" && k.T != ScalarType.BYTES && k.T != ScalarType.STRING, p.push(M);
  }
  return p;
}
class Timestamp extends Message {
  constructor(u) {
    super(), this.seconds = protoInt64.zero, this.nanos = 0, proto3.util.initPartial(u, this);
  }
  fromJson(u, c) {
    if (typeof u != "string")
      throw new Error("cannot decode google.protobuf.Timestamp from JSON: ".concat(proto3.json.debug(u)));
    const l = u.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:Z|\.([0-9]{3,9})Z|([+-][0-9][0-9]:[0-9][0-9]))$/);
    if (!l)
      throw new Error("cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string");
    const v = Date.parse(l[1] + "-" + l[2] + "-" + l[3] + "T" + l[4] + ":" + l[5] + ":" + l[6] + (l[8] ? l[8] : "Z"));
    if (Number.isNaN(v))
      throw new Error("cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string");
    if (v < Date.parse("0001-01-01T00:00:00Z") || v > Date.parse("9999-12-31T23:59:59Z"))
      throw new Error("cannot decode message google.protobuf.Timestamp from JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive");
    return this.seconds = protoInt64.parse(v / 1e3), this.nanos = 0, l[7] && (this.nanos = parseInt("1" + l[7] + "0".repeat(9 - l[7].length)) - 1e9), this;
  }
  toJson(u) {
    const c = Number(this.seconds) * 1e3;
    if (c < Date.parse("0001-01-01T00:00:00Z") || c > Date.parse("9999-12-31T23:59:59Z"))
      throw new Error("cannot encode google.protobuf.Timestamp to JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive");
    if (this.nanos < 0)
      throw new Error("cannot encode google.protobuf.Timestamp to JSON: nanos must not be negative");
    let l = "Z";
    if (this.nanos > 0) {
      const v = (this.nanos + 1e9).toString().substring(1);
      v.substring(3) === "000000" ? l = "." + v.substring(0, 3) + "Z" : v.substring(6) === "000" ? l = "." + v.substring(0, 6) + "Z" : l = "." + v + "Z";
    }
    return new Date(c).toISOString().replace(".000Z", l);
  }
  toDate() {
    return new Date(Number(this.seconds) * 1e3 + Math.ceil(this.nanos / 1e6));
  }
  static now() {
    return Timestamp.fromDate(/* @__PURE__ */ new Date());
  }
  static fromDate(u) {
    const c = u.getTime();
    return new Timestamp({
      seconds: protoInt64.parse(Math.floor(c / 1e3)),
      nanos: c % 1e3 * 1e6
    });
  }
  static fromBinary(u, c) {
    return new Timestamp().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new Timestamp().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new Timestamp().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(Timestamp, u, c);
  }
}
Timestamp.runtime = proto3;
Timestamp.typeName = "google.protobuf.Timestamp";
Timestamp.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "seconds",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 2,
  name: "nanos",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}]);
const AudioCodec$1 = proto3.makeEnum("livekit.AudioCodec", [{
  no: 0,
  name: "DEFAULT_AC"
}, {
  no: 1,
  name: "OPUS"
}, {
  no: 2,
  name: "AAC"
}]), VideoCodec$1 = proto3.makeEnum("livekit.VideoCodec", [{
  no: 0,
  name: "DEFAULT_VC"
}, {
  no: 1,
  name: "H264_BASELINE"
}, {
  no: 2,
  name: "H264_MAIN"
}, {
  no: 3,
  name: "H264_HIGH"
}, {
  no: 4,
  name: "VP8"
}]), ImageCodec = proto3.makeEnum("livekit.ImageCodec", [{
  no: 0,
  name: "IC_DEFAULT"
}, {
  no: 1,
  name: "IC_JPEG"
}]), TrackType = proto3.makeEnum("livekit.TrackType", [{
  no: 0,
  name: "AUDIO"
}, {
  no: 1,
  name: "VIDEO"
}, {
  no: 2,
  name: "DATA"
}]), TrackSource = proto3.makeEnum("livekit.TrackSource", [{
  no: 0,
  name: "UNKNOWN"
}, {
  no: 1,
  name: "CAMERA"
}, {
  no: 2,
  name: "MICROPHONE"
}, {
  no: 3,
  name: "SCREEN_SHARE"
}, {
  no: 4,
  name: "SCREEN_SHARE_AUDIO"
}]), VideoQuality$1 = proto3.makeEnum("livekit.VideoQuality", [{
  no: 0,
  name: "LOW"
}, {
  no: 1,
  name: "MEDIUM"
}, {
  no: 2,
  name: "HIGH"
}, {
  no: 3,
  name: "OFF"
}]), ConnectionQuality$1 = proto3.makeEnum("livekit.ConnectionQuality", [{
  no: 0,
  name: "POOR"
}, {
  no: 1,
  name: "GOOD"
}, {
  no: 2,
  name: "EXCELLENT"
}, {
  no: 3,
  name: "LOST"
}]), ClientConfigSetting = proto3.makeEnum("livekit.ClientConfigSetting", [{
  no: 0,
  name: "UNSET"
}, {
  no: 1,
  name: "DISABLED"
}, {
  no: 2,
  name: "ENABLED"
}]), DisconnectReason = proto3.makeEnum("livekit.DisconnectReason", [{
  no: 0,
  name: "UNKNOWN_REASON"
}, {
  no: 1,
  name: "CLIENT_INITIATED"
}, {
  no: 2,
  name: "DUPLICATE_IDENTITY"
}, {
  no: 3,
  name: "SERVER_SHUTDOWN"
}, {
  no: 4,
  name: "PARTICIPANT_REMOVED"
}, {
  no: 5,
  name: "ROOM_DELETED"
}, {
  no: 6,
  name: "STATE_MISMATCH"
}, {
  no: 7,
  name: "JOIN_FAILURE"
}, {
  no: 8,
  name: "MIGRATION"
}, {
  no: 9,
  name: "SIGNAL_CLOSE"
}]), ReconnectReason = proto3.makeEnum("livekit.ReconnectReason", [{
  no: 0,
  name: "RR_UNKNOWN"
}, {
  no: 1,
  name: "RR_SIGNAL_DISCONNECTED"
}, {
  no: 2,
  name: "RR_PUBLISHER_FAILED"
}, {
  no: 3,
  name: "RR_SUBSCRIBER_FAILED"
}, {
  no: 4,
  name: "RR_SWITCH_CANDIDATE"
}]), SubscriptionError = proto3.makeEnum("livekit.SubscriptionError", [{
  no: 0,
  name: "SE_UNKNOWN"
}, {
  no: 1,
  name: "SE_CODEC_UNSUPPORTED"
}, {
  no: 2,
  name: "SE_TRACK_NOTFOUND"
}]), Room$1 = proto3.makeMessageType("livekit.Room", () => [{
  no: 1,
  name: "sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "empty_timeout",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 14,
  name: "departure_timeout",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 4,
  name: "max_participants",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 5,
  name: "creation_time",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 6,
  name: "turn_password",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 7,
  name: "enabled_codecs",
  kind: "message",
  T: Codec,
  repeated: !0
}, {
  no: 8,
  name: "metadata",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 9,
  name: "num_participants",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 11,
  name: "num_publishers",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 10,
  name: "active_recording",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 13,
  name: "version",
  kind: "message",
  T: TimedVersion
}]), Codec = proto3.makeMessageType("livekit.Codec", () => [{
  no: 1,
  name: "mime",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "fmtp_line",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
proto3.makeMessageType("livekit.PlayoutDelay", () => [{
  no: 1,
  name: "enabled",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 2,
  name: "min",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 3,
  name: "max",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}]);
const ParticipantPermission = proto3.makeMessageType("livekit.ParticipantPermission", () => [{
  no: 1,
  name: "can_subscribe",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 2,
  name: "can_publish",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 3,
  name: "can_publish_data",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 9,
  name: "can_publish_sources",
  kind: "enum",
  T: proto3.getEnumType(TrackSource),
  repeated: !0
}, {
  no: 7,
  name: "hidden",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 8,
  name: "recorder",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 10,
  name: "can_update_metadata",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 11,
  name: "agent",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}]), ParticipantInfo = proto3.makeMessageType("livekit.ParticipantInfo", () => [{
  no: 1,
  name: "sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "identity",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "state",
  kind: "enum",
  T: proto3.getEnumType(ParticipantInfo_State)
}, {
  no: 4,
  name: "tracks",
  kind: "message",
  T: TrackInfo,
  repeated: !0
}, {
  no: 5,
  name: "metadata",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 6,
  name: "joined_at",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 9,
  name: "name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 10,
  name: "version",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 11,
  name: "permission",
  kind: "message",
  T: ParticipantPermission
}, {
  no: 12,
  name: "region",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 13,
  name: "is_publisher",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 14,
  name: "kind",
  kind: "enum",
  T: proto3.getEnumType(ParticipantInfo_Kind)
}]), ParticipantInfo_State = proto3.makeEnum("livekit.ParticipantInfo.State", [{
  no: 0,
  name: "JOINING"
}, {
  no: 1,
  name: "JOINED"
}, {
  no: 2,
  name: "ACTIVE"
}, {
  no: 3,
  name: "DISCONNECTED"
}]), ParticipantInfo_Kind = proto3.makeEnum("livekit.ParticipantInfo.Kind", [{
  no: 0,
  name: "STANDARD"
}, {
  no: 1,
  name: "INGRESS"
}, {
  no: 2,
  name: "EGRESS"
}, {
  no: 3,
  name: "SIP"
}, {
  no: 4,
  name: "AGENT"
}]);
proto3.makeMessageType("livekit.Encryption", []);
const Encryption_Type = proto3.makeEnum("livekit.Encryption.Type", [{
  no: 0,
  name: "NONE"
}, {
  no: 1,
  name: "GCM"
}, {
  no: 2,
  name: "CUSTOM"
}]), SimulcastCodecInfo = proto3.makeMessageType("livekit.SimulcastCodecInfo", () => [{
  no: 1,
  name: "mime_type",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "mid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "cid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 4,
  name: "layers",
  kind: "message",
  T: VideoLayer,
  repeated: !0
}]), TrackInfo = proto3.makeMessageType("livekit.TrackInfo", () => [{
  no: 1,
  name: "sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "type",
  kind: "enum",
  T: proto3.getEnumType(TrackType)
}, {
  no: 3,
  name: "name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 4,
  name: "muted",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 5,
  name: "width",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 6,
  name: "height",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 7,
  name: "simulcast",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 8,
  name: "disable_dtx",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 9,
  name: "source",
  kind: "enum",
  T: proto3.getEnumType(TrackSource)
}, {
  no: 10,
  name: "layers",
  kind: "message",
  T: VideoLayer,
  repeated: !0
}, {
  no: 11,
  name: "mime_type",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 12,
  name: "mid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 13,
  name: "codecs",
  kind: "message",
  T: SimulcastCodecInfo,
  repeated: !0
}, {
  no: 14,
  name: "stereo",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 15,
  name: "disable_red",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 16,
  name: "encryption",
  kind: "enum",
  T: proto3.getEnumType(Encryption_Type)
}, {
  no: 17,
  name: "stream",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 18,
  name: "version",
  kind: "message",
  T: TimedVersion
}]), VideoLayer = proto3.makeMessageType("livekit.VideoLayer", () => [{
  no: 1,
  name: "quality",
  kind: "enum",
  T: proto3.getEnumType(VideoQuality$1)
}, {
  no: 2,
  name: "width",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 3,
  name: "height",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 4,
  name: "bitrate",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 5,
  name: "ssrc",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}]), DataPacket = proto3.makeMessageType("livekit.DataPacket", () => [{
  no: 1,
  name: "kind",
  kind: "enum",
  T: proto3.getEnumType(DataPacket_Kind)
}, {
  no: 4,
  name: "participant_identity",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "destination_identities",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 2,
  name: "user",
  kind: "message",
  T: UserPacket,
  oneof: "value"
}, {
  no: 3,
  name: "speaker",
  kind: "message",
  T: ActiveSpeakerUpdate,
  oneof: "value"
}, {
  no: 6,
  name: "sip_dtmf",
  kind: "message",
  T: SipDTMF,
  oneof: "value"
}]), DataPacket_Kind = proto3.makeEnum("livekit.DataPacket.Kind", [{
  no: 0,
  name: "RELIABLE"
}, {
  no: 1,
  name: "LOSSY"
}]), ActiveSpeakerUpdate = proto3.makeMessageType("livekit.ActiveSpeakerUpdate", () => [{
  no: 1,
  name: "speakers",
  kind: "message",
  T: SpeakerInfo,
  repeated: !0
}]), SpeakerInfo = proto3.makeMessageType("livekit.SpeakerInfo", () => [{
  no: 1,
  name: "sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "level",
  kind: "scalar",
  T: 2
  /* ScalarType.FLOAT */
}, {
  no: 3,
  name: "active",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}]), UserPacket = proto3.makeMessageType("livekit.UserPacket", () => [{
  no: 1,
  name: "participant_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "participant_identity",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "payload",
  kind: "scalar",
  T: 12
  /* ScalarType.BYTES */
}, {
  no: 3,
  name: "destination_sids",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 6,
  name: "destination_identities",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 4,
  name: "topic",
  kind: "scalar",
  T: 9,
  opt: !0
}]), SipDTMF = proto3.makeMessageType("livekit.SipDTMF", () => [{
  no: 3,
  name: "code",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 4,
  name: "digit",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), ParticipantTracks = proto3.makeMessageType("livekit.ParticipantTracks", () => [{
  no: 1,
  name: "participant_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "track_sids",
  kind: "scalar",
  T: 9,
  repeated: !0
}]), ServerInfo = proto3.makeMessageType("livekit.ServerInfo", () => [{
  no: 1,
  name: "edition",
  kind: "enum",
  T: proto3.getEnumType(ServerInfo_Edition)
}, {
  no: 2,
  name: "version",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "protocol",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}, {
  no: 4,
  name: "region",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "node_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 6,
  name: "debug_info",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), ServerInfo_Edition = proto3.makeEnum("livekit.ServerInfo.Edition", [{
  no: 0,
  name: "Standard"
}, {
  no: 1,
  name: "Cloud"
}]), ClientInfo = proto3.makeMessageType("livekit.ClientInfo", () => [{
  no: 1,
  name: "sdk",
  kind: "enum",
  T: proto3.getEnumType(ClientInfo_SDK)
}, {
  no: 2,
  name: "version",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "protocol",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}, {
  no: 4,
  name: "os",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "os_version",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 6,
  name: "device_model",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 7,
  name: "browser",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 8,
  name: "browser_version",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 9,
  name: "address",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 10,
  name: "network",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), ClientInfo_SDK = proto3.makeEnum("livekit.ClientInfo.SDK", [{
  no: 0,
  name: "UNKNOWN"
}, {
  no: 1,
  name: "JS"
}, {
  no: 2,
  name: "SWIFT"
}, {
  no: 3,
  name: "ANDROID"
}, {
  no: 4,
  name: "FLUTTER"
}, {
  no: 5,
  name: "GO"
}, {
  no: 6,
  name: "UNITY"
}, {
  no: 7,
  name: "REACT_NATIVE"
}, {
  no: 8,
  name: "RUST"
}, {
  no: 9,
  name: "PYTHON"
}, {
  no: 10,
  name: "CPP"
}]), ClientConfiguration = proto3.makeMessageType("livekit.ClientConfiguration", () => [{
  no: 1,
  name: "video",
  kind: "message",
  T: VideoConfiguration
}, {
  no: 2,
  name: "screen",
  kind: "message",
  T: VideoConfiguration
}, {
  no: 3,
  name: "resume_connection",
  kind: "enum",
  T: proto3.getEnumType(ClientConfigSetting)
}, {
  no: 4,
  name: "disabled_codecs",
  kind: "message",
  T: DisabledCodecs
}, {
  no: 5,
  name: "force_relay",
  kind: "enum",
  T: proto3.getEnumType(ClientConfigSetting)
}]), VideoConfiguration = proto3.makeMessageType("livekit.VideoConfiguration", () => [{
  no: 1,
  name: "hardware_encoder",
  kind: "enum",
  T: proto3.getEnumType(ClientConfigSetting)
}]), DisabledCodecs = proto3.makeMessageType("livekit.DisabledCodecs", () => [{
  no: 1,
  name: "codecs",
  kind: "message",
  T: Codec,
  repeated: !0
}, {
  no: 2,
  name: "publish",
  kind: "message",
  T: Codec,
  repeated: !0
}]), RTPDrift = proto3.makeMessageType("livekit.RTPDrift", () => [{
  no: 1,
  name: "start_time",
  kind: "message",
  T: Timestamp
}, {
  no: 2,
  name: "end_time",
  kind: "message",
  T: Timestamp
}, {
  no: 3,
  name: "duration",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}, {
  no: 4,
  name: "start_timestamp",
  kind: "scalar",
  T: 4
  /* ScalarType.UINT64 */
}, {
  no: 5,
  name: "end_timestamp",
  kind: "scalar",
  T: 4
  /* ScalarType.UINT64 */
}, {
  no: 6,
  name: "rtp_clock_ticks",
  kind: "scalar",
  T: 4
  /* ScalarType.UINT64 */
}, {
  no: 7,
  name: "drift_samples",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 8,
  name: "drift_ms",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}, {
  no: 9,
  name: "clock_rate",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}]);
proto3.makeMessageType("livekit.RTPStats", () => [{
  no: 1,
  name: "start_time",
  kind: "message",
  T: Timestamp
}, {
  no: 2,
  name: "end_time",
  kind: "message",
  T: Timestamp
}, {
  no: 3,
  name: "duration",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}, {
  no: 4,
  name: "packets",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 5,
  name: "packet_rate",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}, {
  no: 6,
  name: "bytes",
  kind: "scalar",
  T: 4
  /* ScalarType.UINT64 */
}, {
  no: 39,
  name: "header_bytes",
  kind: "scalar",
  T: 4
  /* ScalarType.UINT64 */
}, {
  no: 7,
  name: "bitrate",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}, {
  no: 8,
  name: "packets_lost",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 9,
  name: "packet_loss_rate",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}, {
  no: 10,
  name: "packet_loss_percentage",
  kind: "scalar",
  T: 2
  /* ScalarType.FLOAT */
}, {
  no: 11,
  name: "packets_duplicate",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 12,
  name: "packet_duplicate_rate",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}, {
  no: 13,
  name: "bytes_duplicate",
  kind: "scalar",
  T: 4
  /* ScalarType.UINT64 */
}, {
  no: 40,
  name: "header_bytes_duplicate",
  kind: "scalar",
  T: 4
  /* ScalarType.UINT64 */
}, {
  no: 14,
  name: "bitrate_duplicate",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}, {
  no: 15,
  name: "packets_padding",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 16,
  name: "packet_padding_rate",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}, {
  no: 17,
  name: "bytes_padding",
  kind: "scalar",
  T: 4
  /* ScalarType.UINT64 */
}, {
  no: 41,
  name: "header_bytes_padding",
  kind: "scalar",
  T: 4
  /* ScalarType.UINT64 */
}, {
  no: 18,
  name: "bitrate_padding",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}, {
  no: 19,
  name: "packets_out_of_order",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 20,
  name: "frames",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 21,
  name: "frame_rate",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}, {
  no: 22,
  name: "jitter_current",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}, {
  no: 23,
  name: "jitter_max",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}, {
  no: 24,
  name: "gap_histogram",
  kind: "map",
  K: 5,
  V: {
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }
}, {
  no: 25,
  name: "nacks",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 37,
  name: "nack_acks",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 26,
  name: "nack_misses",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 38,
  name: "nack_repeated",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 27,
  name: "plis",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 28,
  name: "last_pli",
  kind: "message",
  T: Timestamp
}, {
  no: 29,
  name: "firs",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 30,
  name: "last_fir",
  kind: "message",
  T: Timestamp
}, {
  no: 31,
  name: "rtt_current",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 32,
  name: "rtt_max",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 33,
  name: "key_frames",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 34,
  name: "last_key_frame",
  kind: "message",
  T: Timestamp
}, {
  no: 35,
  name: "layer_lock_plis",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 36,
  name: "last_layer_lock_pli",
  kind: "message",
  T: Timestamp
}, {
  no: 44,
  name: "packet_drift",
  kind: "message",
  T: RTPDrift
}, {
  no: 45,
  name: "report_drift",
  kind: "message",
  T: RTPDrift
}]);
const TimedVersion = proto3.makeMessageType("livekit.TimedVersion", () => [{
  no: 1,
  name: "unix_micro",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 2,
  name: "ticks",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}]), EncodedFileType = proto3.makeEnum("livekit.EncodedFileType", [{
  no: 0,
  name: "DEFAULT_FILETYPE"
}, {
  no: 1,
  name: "MP4"
}, {
  no: 2,
  name: "OGG"
}]), SegmentedFileProtocol = proto3.makeEnum("livekit.SegmentedFileProtocol", [{
  no: 0,
  name: "DEFAULT_SEGMENTED_FILE_PROTOCOL"
}, {
  no: 1,
  name: "HLS_PROTOCOL"
}]), SegmentedFileSuffix = proto3.makeEnum("livekit.SegmentedFileSuffix", [{
  no: 0,
  name: "INDEX"
}, {
  no: 1,
  name: "TIMESTAMP"
}]), ImageFileSuffix = proto3.makeEnum("livekit.ImageFileSuffix", [{
  no: 0,
  name: "IMAGE_SUFFIX_INDEX"
}, {
  no: 1,
  name: "IMAGE_SUFFIX_TIMESTAMP"
}]), StreamProtocol = proto3.makeEnum("livekit.StreamProtocol", [{
  no: 0,
  name: "DEFAULT_PROTOCOL"
}, {
  no: 1,
  name: "RTMP"
}]), EncodingOptionsPreset = proto3.makeEnum("livekit.EncodingOptionsPreset", [{
  no: 0,
  name: "H264_720P_30"
}, {
  no: 1,
  name: "H264_720P_60"
}, {
  no: 2,
  name: "H264_1080P_30"
}, {
  no: 3,
  name: "H264_1080P_60"
}, {
  no: 4,
  name: "PORTRAIT_H264_720P_30"
}, {
  no: 5,
  name: "PORTRAIT_H264_720P_60"
}, {
  no: 6,
  name: "PORTRAIT_H264_1080P_30"
}, {
  no: 7,
  name: "PORTRAIT_H264_1080P_60"
}]), EgressStatus = proto3.makeEnum("livekit.EgressStatus", [{
  no: 0,
  name: "EGRESS_STARTING"
}, {
  no: 1,
  name: "EGRESS_ACTIVE"
}, {
  no: 2,
  name: "EGRESS_ENDING"
}, {
  no: 3,
  name: "EGRESS_COMPLETE"
}, {
  no: 4,
  name: "EGRESS_FAILED"
}, {
  no: 5,
  name: "EGRESS_ABORTED"
}, {
  no: 6,
  name: "EGRESS_LIMIT_REACHED"
}]), RoomCompositeEgressRequest = proto3.makeMessageType("livekit.RoomCompositeEgressRequest", () => [{
  no: 1,
  name: "room_name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "layout",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "audio_only",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 4,
  name: "video_only",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 5,
  name: "custom_base_url",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 6,
  name: "file",
  kind: "message",
  T: EncodedFileOutput,
  oneof: "output"
}, {
  no: 7,
  name: "stream",
  kind: "message",
  T: StreamOutput,
  oneof: "output"
}, {
  no: 10,
  name: "segments",
  kind: "message",
  T: SegmentedFileOutput,
  oneof: "output"
}, {
  no: 8,
  name: "preset",
  kind: "enum",
  T: proto3.getEnumType(EncodingOptionsPreset),
  oneof: "options"
}, {
  no: 9,
  name: "advanced",
  kind: "message",
  T: EncodingOptions,
  oneof: "options"
}, {
  no: 11,
  name: "file_outputs",
  kind: "message",
  T: EncodedFileOutput,
  repeated: !0
}, {
  no: 12,
  name: "stream_outputs",
  kind: "message",
  T: StreamOutput,
  repeated: !0
}, {
  no: 13,
  name: "segment_outputs",
  kind: "message",
  T: SegmentedFileOutput,
  repeated: !0
}, {
  no: 14,
  name: "image_outputs",
  kind: "message",
  T: ImageOutput,
  repeated: !0
}]), WebEgressRequest = proto3.makeMessageType("livekit.WebEgressRequest", () => [{
  no: 1,
  name: "url",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "audio_only",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 3,
  name: "video_only",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 12,
  name: "await_start_signal",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 4,
  name: "file",
  kind: "message",
  T: EncodedFileOutput,
  oneof: "output"
}, {
  no: 5,
  name: "stream",
  kind: "message",
  T: StreamOutput,
  oneof: "output"
}, {
  no: 6,
  name: "segments",
  kind: "message",
  T: SegmentedFileOutput,
  oneof: "output"
}, {
  no: 7,
  name: "preset",
  kind: "enum",
  T: proto3.getEnumType(EncodingOptionsPreset),
  oneof: "options"
}, {
  no: 8,
  name: "advanced",
  kind: "message",
  T: EncodingOptions,
  oneof: "options"
}, {
  no: 9,
  name: "file_outputs",
  kind: "message",
  T: EncodedFileOutput,
  repeated: !0
}, {
  no: 10,
  name: "stream_outputs",
  kind: "message",
  T: StreamOutput,
  repeated: !0
}, {
  no: 11,
  name: "segment_outputs",
  kind: "message",
  T: SegmentedFileOutput,
  repeated: !0
}, {
  no: 13,
  name: "image_outputs",
  kind: "message",
  T: ImageOutput,
  repeated: !0
}]), ParticipantEgressRequest = proto3.makeMessageType("livekit.ParticipantEgressRequest", () => [{
  no: 1,
  name: "room_name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "identity",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "screen_share",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 4,
  name: "preset",
  kind: "enum",
  T: proto3.getEnumType(EncodingOptionsPreset),
  oneof: "options"
}, {
  no: 5,
  name: "advanced",
  kind: "message",
  T: EncodingOptions,
  oneof: "options"
}, {
  no: 6,
  name: "file_outputs",
  kind: "message",
  T: EncodedFileOutput,
  repeated: !0
}, {
  no: 7,
  name: "stream_outputs",
  kind: "message",
  T: StreamOutput,
  repeated: !0
}, {
  no: 8,
  name: "segment_outputs",
  kind: "message",
  T: SegmentedFileOutput,
  repeated: !0
}, {
  no: 9,
  name: "image_outputs",
  kind: "message",
  T: ImageOutput,
  repeated: !0
}]), TrackCompositeEgressRequest = proto3.makeMessageType("livekit.TrackCompositeEgressRequest", () => [{
  no: 1,
  name: "room_name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "audio_track_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "video_track_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 4,
  name: "file",
  kind: "message",
  T: EncodedFileOutput,
  oneof: "output"
}, {
  no: 5,
  name: "stream",
  kind: "message",
  T: StreamOutput,
  oneof: "output"
}, {
  no: 8,
  name: "segments",
  kind: "message",
  T: SegmentedFileOutput,
  oneof: "output"
}, {
  no: 6,
  name: "preset",
  kind: "enum",
  T: proto3.getEnumType(EncodingOptionsPreset),
  oneof: "options"
}, {
  no: 7,
  name: "advanced",
  kind: "message",
  T: EncodingOptions,
  oneof: "options"
}, {
  no: 11,
  name: "file_outputs",
  kind: "message",
  T: EncodedFileOutput,
  repeated: !0
}, {
  no: 12,
  name: "stream_outputs",
  kind: "message",
  T: StreamOutput,
  repeated: !0
}, {
  no: 13,
  name: "segment_outputs",
  kind: "message",
  T: SegmentedFileOutput,
  repeated: !0
}, {
  no: 14,
  name: "image_outputs",
  kind: "message",
  T: ImageOutput,
  repeated: !0
}]), TrackEgressRequest = proto3.makeMessageType("livekit.TrackEgressRequest", () => [{
  no: 1,
  name: "room_name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "track_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "file",
  kind: "message",
  T: DirectFileOutput,
  oneof: "output"
}, {
  no: 4,
  name: "websocket_url",
  kind: "scalar",
  T: 9,
  oneof: "output"
}]), EncodedFileOutput = proto3.makeMessageType("livekit.EncodedFileOutput", () => [{
  no: 1,
  name: "file_type",
  kind: "enum",
  T: proto3.getEnumType(EncodedFileType)
}, {
  no: 2,
  name: "filepath",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 6,
  name: "disable_manifest",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 3,
  name: "s3",
  kind: "message",
  T: S3Upload,
  oneof: "output"
}, {
  no: 4,
  name: "gcp",
  kind: "message",
  T: GCPUpload,
  oneof: "output"
}, {
  no: 5,
  name: "azure",
  kind: "message",
  T: AzureBlobUpload,
  oneof: "output"
}, {
  no: 7,
  name: "aliOSS",
  kind: "message",
  T: AliOSSUpload,
  oneof: "output"
}]), SegmentedFileOutput = proto3.makeMessageType("livekit.SegmentedFileOutput", () => [{
  no: 1,
  name: "protocol",
  kind: "enum",
  T: proto3.getEnumType(SegmentedFileProtocol)
}, {
  no: 2,
  name: "filename_prefix",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "playlist_name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 11,
  name: "live_playlist_name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 4,
  name: "segment_duration",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 10,
  name: "filename_suffix",
  kind: "enum",
  T: proto3.getEnumType(SegmentedFileSuffix)
}, {
  no: 8,
  name: "disable_manifest",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 5,
  name: "s3",
  kind: "message",
  T: S3Upload,
  oneof: "output"
}, {
  no: 6,
  name: "gcp",
  kind: "message",
  T: GCPUpload,
  oneof: "output"
}, {
  no: 7,
  name: "azure",
  kind: "message",
  T: AzureBlobUpload,
  oneof: "output"
}, {
  no: 9,
  name: "aliOSS",
  kind: "message",
  T: AliOSSUpload,
  oneof: "output"
}]), DirectFileOutput = proto3.makeMessageType("livekit.DirectFileOutput", () => [{
  no: 1,
  name: "filepath",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "disable_manifest",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 2,
  name: "s3",
  kind: "message",
  T: S3Upload,
  oneof: "output"
}, {
  no: 3,
  name: "gcp",
  kind: "message",
  T: GCPUpload,
  oneof: "output"
}, {
  no: 4,
  name: "azure",
  kind: "message",
  T: AzureBlobUpload,
  oneof: "output"
}, {
  no: 6,
  name: "aliOSS",
  kind: "message",
  T: AliOSSUpload,
  oneof: "output"
}]), ImageOutput = proto3.makeMessageType("livekit.ImageOutput", () => [{
  no: 1,
  name: "capture_interval",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 2,
  name: "width",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}, {
  no: 3,
  name: "height",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}, {
  no: 4,
  name: "filename_prefix",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "filename_suffix",
  kind: "enum",
  T: proto3.getEnumType(ImageFileSuffix)
}, {
  no: 6,
  name: "image_codec",
  kind: "enum",
  T: proto3.getEnumType(ImageCodec)
}, {
  no: 7,
  name: "disable_manifest",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 8,
  name: "s3",
  kind: "message",
  T: S3Upload,
  oneof: "output"
}, {
  no: 9,
  name: "gcp",
  kind: "message",
  T: GCPUpload,
  oneof: "output"
}, {
  no: 10,
  name: "azure",
  kind: "message",
  T: AzureBlobUpload,
  oneof: "output"
}, {
  no: 11,
  name: "aliOSS",
  kind: "message",
  T: AliOSSUpload,
  oneof: "output"
}]), S3Upload = proto3.makeMessageType("livekit.S3Upload", () => [{
  no: 1,
  name: "access_key",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "secret",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "region",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 4,
  name: "endpoint",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "bucket",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 6,
  name: "force_path_style",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 7,
  name: "metadata",
  kind: "map",
  K: 9,
  V: {
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
}, {
  no: 8,
  name: "tagging",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 9,
  name: "content_disposition",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), GCPUpload = proto3.makeMessageType("livekit.GCPUpload", () => [{
  no: 1,
  name: "credentials",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "bucket",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "endpoint",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), AzureBlobUpload = proto3.makeMessageType("livekit.AzureBlobUpload", () => [{
  no: 1,
  name: "account_name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "account_key",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "container_name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), AliOSSUpload = proto3.makeMessageType("livekit.AliOSSUpload", () => [{
  no: 1,
  name: "access_key",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "secret",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "region",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 4,
  name: "endpoint",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "bucket",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), StreamOutput = proto3.makeMessageType("livekit.StreamOutput", () => [{
  no: 1,
  name: "protocol",
  kind: "enum",
  T: proto3.getEnumType(StreamProtocol)
}, {
  no: 2,
  name: "urls",
  kind: "scalar",
  T: 9,
  repeated: !0
}]), EncodingOptions = proto3.makeMessageType("livekit.EncodingOptions", () => [{
  no: 1,
  name: "width",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}, {
  no: 2,
  name: "height",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}, {
  no: 3,
  name: "depth",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}, {
  no: 4,
  name: "framerate",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}, {
  no: 5,
  name: "audio_codec",
  kind: "enum",
  T: proto3.getEnumType(AudioCodec$1)
}, {
  no: 6,
  name: "audio_bitrate",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}, {
  no: 11,
  name: "audio_quality",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}, {
  no: 7,
  name: "audio_frequency",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}, {
  no: 8,
  name: "video_codec",
  kind: "enum",
  T: proto3.getEnumType(VideoCodec$1)
}, {
  no: 9,
  name: "video_bitrate",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}, {
  no: 12,
  name: "video_quality",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}, {
  no: 10,
  name: "key_frame_interval",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}]);
proto3.makeMessageType("livekit.UpdateLayoutRequest", () => [{
  no: 1,
  name: "egress_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "layout",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
proto3.makeMessageType("livekit.UpdateStreamRequest", () => [{
  no: 1,
  name: "egress_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "add_output_urls",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 3,
  name: "remove_output_urls",
  kind: "scalar",
  T: 9,
  repeated: !0
}]);
proto3.makeMessageType("livekit.ListEgressRequest", () => [{
  no: 1,
  name: "room_name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "egress_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "active",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}]);
proto3.makeMessageType("livekit.ListEgressResponse", () => [{
  no: 1,
  name: "items",
  kind: "message",
  T: EgressInfo,
  repeated: !0
}]);
proto3.makeMessageType("livekit.StopEgressRequest", () => [{
  no: 1,
  name: "egress_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
const EgressInfo = proto3.makeMessageType("livekit.EgressInfo", () => [{
  no: 1,
  name: "egress_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "room_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 13,
  name: "room_name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "status",
  kind: "enum",
  T: proto3.getEnumType(EgressStatus)
}, {
  no: 10,
  name: "started_at",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 11,
  name: "ended_at",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 18,
  name: "updated_at",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 21,
  name: "details",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 9,
  name: "error",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 4,
  name: "room_composite",
  kind: "message",
  T: RoomCompositeEgressRequest,
  oneof: "request"
}, {
  no: 14,
  name: "web",
  kind: "message",
  T: WebEgressRequest,
  oneof: "request"
}, {
  no: 19,
  name: "participant",
  kind: "message",
  T: ParticipantEgressRequest,
  oneof: "request"
}, {
  no: 5,
  name: "track_composite",
  kind: "message",
  T: TrackCompositeEgressRequest,
  oneof: "request"
}, {
  no: 6,
  name: "track",
  kind: "message",
  T: TrackEgressRequest,
  oneof: "request"
}, {
  no: 7,
  name: "stream",
  kind: "message",
  T: StreamInfoList,
  oneof: "result"
}, {
  no: 8,
  name: "file",
  kind: "message",
  T: FileInfo,
  oneof: "result"
}, {
  no: 12,
  name: "segments",
  kind: "message",
  T: SegmentsInfo,
  oneof: "result"
}, {
  no: 15,
  name: "stream_results",
  kind: "message",
  T: StreamInfo,
  repeated: !0
}, {
  no: 16,
  name: "file_results",
  kind: "message",
  T: FileInfo,
  repeated: !0
}, {
  no: 17,
  name: "segment_results",
  kind: "message",
  T: SegmentsInfo,
  repeated: !0
}, {
  no: 20,
  name: "image_results",
  kind: "message",
  T: ImagesInfo,
  repeated: !0
}]), StreamInfoList = proto3.makeMessageType("livekit.StreamInfoList", () => [{
  no: 1,
  name: "info",
  kind: "message",
  T: StreamInfo,
  repeated: !0
}]), StreamInfo = proto3.makeMessageType("livekit.StreamInfo", () => [{
  no: 1,
  name: "url",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "started_at",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 3,
  name: "ended_at",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 4,
  name: "duration",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 5,
  name: "status",
  kind: "enum",
  T: proto3.getEnumType(StreamInfo_Status)
}, {
  no: 6,
  name: "error",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), StreamInfo_Status = proto3.makeEnum("livekit.StreamInfo.Status", [{
  no: 0,
  name: "ACTIVE"
}, {
  no: 1,
  name: "FINISHED"
}, {
  no: 2,
  name: "FAILED"
}]), FileInfo = proto3.makeMessageType("livekit.FileInfo", () => [{
  no: 1,
  name: "filename",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "started_at",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 3,
  name: "ended_at",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 6,
  name: "duration",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 4,
  name: "size",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 5,
  name: "location",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), SegmentsInfo = proto3.makeMessageType("livekit.SegmentsInfo", () => [{
  no: 1,
  name: "playlist_name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 8,
  name: "live_playlist_name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "duration",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 3,
  name: "size",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 4,
  name: "playlist_location",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 9,
  name: "live_playlist_location",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "segment_count",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 6,
  name: "started_at",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 7,
  name: "ended_at",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}]), ImagesInfo = proto3.makeMessageType("livekit.ImagesInfo", () => [{
  no: 1,
  name: "image_count",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 2,
  name: "started_at",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 3,
  name: "ended_at",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}]), AutoParticipantEgress = proto3.makeMessageType("livekit.AutoParticipantEgress", () => [{
  no: 1,
  name: "preset",
  kind: "enum",
  T: proto3.getEnumType(EncodingOptionsPreset),
  oneof: "options"
}, {
  no: 2,
  name: "advanced",
  kind: "message",
  T: EncodingOptions,
  oneof: "options"
}, {
  no: 3,
  name: "file_outputs",
  kind: "message",
  T: EncodedFileOutput,
  repeated: !0
}, {
  no: 4,
  name: "segment_outputs",
  kind: "message",
  T: SegmentedFileOutput,
  repeated: !0
}]), AutoTrackEgress = proto3.makeMessageType("livekit.AutoTrackEgress", () => [{
  no: 1,
  name: "filepath",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "disable_manifest",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 2,
  name: "s3",
  kind: "message",
  T: S3Upload,
  oneof: "output"
}, {
  no: 3,
  name: "gcp",
  kind: "message",
  T: GCPUpload,
  oneof: "output"
}, {
  no: 4,
  name: "azure",
  kind: "message",
  T: AzureBlobUpload,
  oneof: "output"
}]);
proto3.makeMessageType("livekit.CreateRoomRequest", () => [{
  no: 1,
  name: "name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "empty_timeout",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 10,
  name: "departure_timeout",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 3,
  name: "max_participants",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 4,
  name: "node_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "metadata",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 6,
  name: "egress",
  kind: "message",
  T: RoomEgress
}, {
  no: 7,
  name: "min_playout_delay",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 8,
  name: "max_playout_delay",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 9,
  name: "sync_streams",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}]);
const RoomEgress = proto3.makeMessageType("livekit.RoomEgress", () => [{
  no: 1,
  name: "room",
  kind: "message",
  T: RoomCompositeEgressRequest
}, {
  no: 3,
  name: "participant",
  kind: "message",
  T: AutoParticipantEgress
}, {
  no: 2,
  name: "tracks",
  kind: "message",
  T: AutoTrackEgress
}]);
proto3.makeMessageType("livekit.ListRoomsRequest", () => [{
  no: 1,
  name: "names",
  kind: "scalar",
  T: 9,
  repeated: !0
}]);
proto3.makeMessageType("livekit.ListRoomsResponse", () => [{
  no: 1,
  name: "rooms",
  kind: "message",
  T: Room$1,
  repeated: !0
}]);
proto3.makeMessageType("livekit.DeleteRoomRequest", () => [{
  no: 1,
  name: "room",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
proto3.makeMessageType("livekit.DeleteRoomResponse", []);
proto3.makeMessageType("livekit.ListParticipantsRequest", () => [{
  no: 1,
  name: "room",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
proto3.makeMessageType("livekit.ListParticipantsResponse", () => [{
  no: 1,
  name: "participants",
  kind: "message",
  T: ParticipantInfo,
  repeated: !0
}]);
proto3.makeMessageType("livekit.RoomParticipantIdentity", () => [{
  no: 1,
  name: "room",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "identity",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
proto3.makeMessageType("livekit.RemoveParticipantResponse", []);
proto3.makeMessageType("livekit.MuteRoomTrackRequest", () => [{
  no: 1,
  name: "room",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "identity",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "track_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 4,
  name: "muted",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}]);
proto3.makeMessageType("livekit.MuteRoomTrackResponse", () => [{
  no: 1,
  name: "track",
  kind: "message",
  T: TrackInfo
}]);
proto3.makeMessageType("livekit.UpdateParticipantRequest", () => [{
  no: 1,
  name: "room",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "identity",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "metadata",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 4,
  name: "permission",
  kind: "message",
  T: ParticipantPermission
}, {
  no: 5,
  name: "name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
proto3.makeMessageType("livekit.UpdateSubscriptionsRequest", () => [{
  no: 1,
  name: "room",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "identity",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "track_sids",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 4,
  name: "subscribe",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 5,
  name: "participant_tracks",
  kind: "message",
  T: ParticipantTracks,
  repeated: !0
}]);
proto3.makeMessageType("livekit.UpdateSubscriptionsResponse", []);
proto3.makeMessageType("livekit.SendDataRequest", () => [{
  no: 1,
  name: "room",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "data",
  kind: "scalar",
  T: 12
  /* ScalarType.BYTES */
}, {
  no: 3,
  name: "kind",
  kind: "enum",
  T: proto3.getEnumType(DataPacket_Kind)
}, {
  no: 4,
  name: "destination_sids",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 6,
  name: "destination_identities",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 5,
  name: "topic",
  kind: "scalar",
  T: 9,
  opt: !0
}]);
proto3.makeMessageType("livekit.SendDataResponse", []);
proto3.makeMessageType("livekit.UpdateRoomMetadataRequest", () => [{
  no: 1,
  name: "room",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "metadata",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
const JobType = proto3.makeEnum("livekit.JobType", [{
  no: 0,
  name: "JT_ROOM"
}, {
  no: 1,
  name: "JT_PUBLISHER"
}]), WorkerStatus = proto3.makeEnum("livekit.WorkerStatus", [{
  no: 0,
  name: "WS_AVAILABLE"
}, {
  no: 1,
  name: "WS_FULL"
}]), JobStatus = proto3.makeEnum("livekit.JobStatus", [{
  no: 0,
  name: "JS_UNKNOWN"
}, {
  no: 1,
  name: "JS_SUCCESS"
}, {
  no: 2,
  name: "JS_FAILED"
}]);
proto3.makeMessageType("livekit.AgentInfo", () => [{
  no: 1,
  name: "id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "version",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
const Job = proto3.makeMessageType("livekit.Job", () => [{
  no: 1,
  name: "id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "type",
  kind: "enum",
  T: proto3.getEnumType(JobType)
}, {
  no: 3,
  name: "room",
  kind: "message",
  T: Room$1
}, {
  no: 4,
  name: "participant",
  kind: "message",
  T: ParticipantInfo,
  opt: !0
}]);
proto3.makeMessageType("livekit.WorkerMessage", () => [{
  no: 1,
  name: "register",
  kind: "message",
  T: RegisterWorkerRequest,
  oneof: "message"
}, {
  no: 2,
  name: "availability",
  kind: "message",
  T: AvailabilityResponse,
  oneof: "message"
}, {
  no: 3,
  name: "status",
  kind: "message",
  T: UpdateWorkerStatus,
  oneof: "message"
}, {
  no: 4,
  name: "job_update",
  kind: "message",
  T: JobStatusUpdate,
  oneof: "message"
}]);
proto3.makeMessageType("livekit.ServerMessage", () => [{
  no: 1,
  name: "register",
  kind: "message",
  T: RegisterWorkerResponse,
  oneof: "message"
}, {
  no: 2,
  name: "availability",
  kind: "message",
  T: AvailabilityRequest,
  oneof: "message"
}, {
  no: 3,
  name: "assignment",
  kind: "message",
  T: JobAssignment,
  oneof: "message"
}]);
const RegisterWorkerRequest = proto3.makeMessageType("livekit.RegisterWorkerRequest", () => [{
  no: 1,
  name: "type",
  kind: "enum",
  T: proto3.getEnumType(JobType)
}, {
  no: 2,
  name: "worker_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "version",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 4,
  name: "name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), RegisterWorkerResponse = proto3.makeMessageType("livekit.RegisterWorkerResponse", () => [{
  no: 1,
  name: "worker_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "server_version",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), AvailabilityRequest = proto3.makeMessageType("livekit.AvailabilityRequest", () => [{
  no: 1,
  name: "job",
  kind: "message",
  T: Job
}]), AvailabilityResponse = proto3.makeMessageType("livekit.AvailabilityResponse", () => [{
  no: 1,
  name: "job_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "available",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}]), JobStatusUpdate = proto3.makeMessageType("livekit.JobStatusUpdate", () => [{
  no: 1,
  name: "job_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "status",
  kind: "enum",
  T: proto3.getEnumType(JobStatus)
}, {
  no: 3,
  name: "error",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 4,
  name: "user_data",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), JobAssignment = proto3.makeMessageType("livekit.JobAssignment", () => [{
  no: 1,
  name: "job",
  kind: "message",
  T: Job
}]), UpdateWorkerStatus = proto3.makeMessageType("livekit.UpdateWorkerStatus", () => [{
  no: 1,
  name: "status",
  kind: "enum",
  T: proto3.getEnumType(WorkerStatus)
}]), SignalTarget = proto3.makeEnum("livekit.SignalTarget", [{
  no: 0,
  name: "PUBLISHER"
}, {
  no: 1,
  name: "SUBSCRIBER"
}]), StreamState = proto3.makeEnum("livekit.StreamState", [{
  no: 0,
  name: "ACTIVE"
}, {
  no: 1,
  name: "PAUSED"
}]), CandidateProtocol = proto3.makeEnum("livekit.CandidateProtocol", [{
  no: 0,
  name: "UDP"
}, {
  no: 1,
  name: "TCP"
}, {
  no: 2,
  name: "TLS"
}]), SignalRequest = proto3.makeMessageType("livekit.SignalRequest", () => [{
  no: 1,
  name: "offer",
  kind: "message",
  T: SessionDescription,
  oneof: "message"
}, {
  no: 2,
  name: "answer",
  kind: "message",
  T: SessionDescription,
  oneof: "message"
}, {
  no: 3,
  name: "trickle",
  kind: "message",
  T: TrickleRequest,
  oneof: "message"
}, {
  no: 4,
  name: "add_track",
  kind: "message",
  T: AddTrackRequest,
  oneof: "message"
}, {
  no: 5,
  name: "mute",
  kind: "message",
  T: MuteTrackRequest,
  oneof: "message"
}, {
  no: 6,
  name: "subscription",
  kind: "message",
  T: UpdateSubscription,
  oneof: "message"
}, {
  no: 7,
  name: "track_setting",
  kind: "message",
  T: UpdateTrackSettings,
  oneof: "message"
}, {
  no: 8,
  name: "leave",
  kind: "message",
  T: LeaveRequest,
  oneof: "message"
}, {
  no: 10,
  name: "update_layers",
  kind: "message",
  T: UpdateVideoLayers,
  oneof: "message"
}, {
  no: 11,
  name: "subscription_permission",
  kind: "message",
  T: SubscriptionPermission,
  oneof: "message"
}, {
  no: 12,
  name: "sync_state",
  kind: "message",
  T: SyncState,
  oneof: "message"
}, {
  no: 13,
  name: "simulate",
  kind: "message",
  T: SimulateScenario,
  oneof: "message"
}, {
  no: 14,
  name: "ping",
  kind: "scalar",
  T: 3,
  oneof: "message"
}, {
  no: 15,
  name: "update_metadata",
  kind: "message",
  T: UpdateParticipantMetadata,
  oneof: "message"
}, {
  no: 16,
  name: "ping_req",
  kind: "message",
  T: Ping,
  oneof: "message"
}]), SignalResponse = proto3.makeMessageType("livekit.SignalResponse", () => [{
  no: 1,
  name: "join",
  kind: "message",
  T: JoinResponse,
  oneof: "message"
}, {
  no: 2,
  name: "answer",
  kind: "message",
  T: SessionDescription,
  oneof: "message"
}, {
  no: 3,
  name: "offer",
  kind: "message",
  T: SessionDescription,
  oneof: "message"
}, {
  no: 4,
  name: "trickle",
  kind: "message",
  T: TrickleRequest,
  oneof: "message"
}, {
  no: 5,
  name: "update",
  kind: "message",
  T: ParticipantUpdate,
  oneof: "message"
}, {
  no: 6,
  name: "track_published",
  kind: "message",
  T: TrackPublishedResponse,
  oneof: "message"
}, {
  no: 8,
  name: "leave",
  kind: "message",
  T: LeaveRequest,
  oneof: "message"
}, {
  no: 9,
  name: "mute",
  kind: "message",
  T: MuteTrackRequest,
  oneof: "message"
}, {
  no: 10,
  name: "speakers_changed",
  kind: "message",
  T: SpeakersChanged,
  oneof: "message"
}, {
  no: 11,
  name: "room_update",
  kind: "message",
  T: RoomUpdate,
  oneof: "message"
}, {
  no: 12,
  name: "connection_quality",
  kind: "message",
  T: ConnectionQualityUpdate,
  oneof: "message"
}, {
  no: 13,
  name: "stream_state_update",
  kind: "message",
  T: StreamStateUpdate,
  oneof: "message"
}, {
  no: 14,
  name: "subscribed_quality_update",
  kind: "message",
  T: SubscribedQualityUpdate,
  oneof: "message"
}, {
  no: 15,
  name: "subscription_permission_update",
  kind: "message",
  T: SubscriptionPermissionUpdate,
  oneof: "message"
}, {
  no: 16,
  name: "refresh_token",
  kind: "scalar",
  T: 9,
  oneof: "message"
}, {
  no: 17,
  name: "track_unpublished",
  kind: "message",
  T: TrackUnpublishedResponse,
  oneof: "message"
}, {
  no: 18,
  name: "pong",
  kind: "scalar",
  T: 3,
  oneof: "message"
}, {
  no: 19,
  name: "reconnect",
  kind: "message",
  T: ReconnectResponse,
  oneof: "message"
}, {
  no: 20,
  name: "pong_resp",
  kind: "message",
  T: Pong,
  oneof: "message"
}, {
  no: 21,
  name: "subscription_response",
  kind: "message",
  T: SubscriptionResponse,
  oneof: "message"
}]), SimulcastCodec = proto3.makeMessageType("livekit.SimulcastCodec", () => [{
  no: 1,
  name: "codec",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "cid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), AddTrackRequest = proto3.makeMessageType("livekit.AddTrackRequest", () => [{
  no: 1,
  name: "cid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "type",
  kind: "enum",
  T: proto3.getEnumType(TrackType)
}, {
  no: 4,
  name: "width",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 5,
  name: "height",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 6,
  name: "muted",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 7,
  name: "disable_dtx",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 8,
  name: "source",
  kind: "enum",
  T: proto3.getEnumType(TrackSource)
}, {
  no: 9,
  name: "layers",
  kind: "message",
  T: VideoLayer,
  repeated: !0
}, {
  no: 10,
  name: "simulcast_codecs",
  kind: "message",
  T: SimulcastCodec,
  repeated: !0
}, {
  no: 11,
  name: "sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 12,
  name: "stereo",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 13,
  name: "disable_red",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 14,
  name: "encryption",
  kind: "enum",
  T: proto3.getEnumType(Encryption_Type)
}, {
  no: 15,
  name: "stream",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), TrickleRequest = proto3.makeMessageType("livekit.TrickleRequest", () => [{
  no: 1,
  name: "candidateInit",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "target",
  kind: "enum",
  T: proto3.getEnumType(SignalTarget)
}]), MuteTrackRequest = proto3.makeMessageType("livekit.MuteTrackRequest", () => [{
  no: 1,
  name: "sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "muted",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}]), JoinResponse = proto3.makeMessageType("livekit.JoinResponse", () => [{
  no: 1,
  name: "room",
  kind: "message",
  T: Room$1
}, {
  no: 2,
  name: "participant",
  kind: "message",
  T: ParticipantInfo
}, {
  no: 3,
  name: "other_participants",
  kind: "message",
  T: ParticipantInfo,
  repeated: !0
}, {
  no: 4,
  name: "server_version",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "ice_servers",
  kind: "message",
  T: ICEServer,
  repeated: !0
}, {
  no: 6,
  name: "subscriber_primary",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 7,
  name: "alternative_url",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 8,
  name: "client_configuration",
  kind: "message",
  T: ClientConfiguration
}, {
  no: 9,
  name: "server_region",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 10,
  name: "ping_timeout",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}, {
  no: 11,
  name: "ping_interval",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}, {
  no: 12,
  name: "server_info",
  kind: "message",
  T: ServerInfo
}, {
  no: 13,
  name: "sif_trailer",
  kind: "scalar",
  T: 12
  /* ScalarType.BYTES */
}]), ReconnectResponse = proto3.makeMessageType("livekit.ReconnectResponse", () => [{
  no: 1,
  name: "ice_servers",
  kind: "message",
  T: ICEServer,
  repeated: !0
}, {
  no: 2,
  name: "client_configuration",
  kind: "message",
  T: ClientConfiguration
}]), TrackPublishedResponse = proto3.makeMessageType("livekit.TrackPublishedResponse", () => [{
  no: 1,
  name: "cid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "track",
  kind: "message",
  T: TrackInfo
}]), TrackUnpublishedResponse = proto3.makeMessageType("livekit.TrackUnpublishedResponse", () => [{
  no: 1,
  name: "track_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), SessionDescription = proto3.makeMessageType("livekit.SessionDescription", () => [{
  no: 1,
  name: "type",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "sdp",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), ParticipantUpdate = proto3.makeMessageType("livekit.ParticipantUpdate", () => [{
  no: 1,
  name: "participants",
  kind: "message",
  T: ParticipantInfo,
  repeated: !0
}]), UpdateSubscription = proto3.makeMessageType("livekit.UpdateSubscription", () => [{
  no: 1,
  name: "track_sids",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 2,
  name: "subscribe",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 3,
  name: "participant_tracks",
  kind: "message",
  T: ParticipantTracks,
  repeated: !0
}]), UpdateTrackSettings = proto3.makeMessageType("livekit.UpdateTrackSettings", () => [{
  no: 1,
  name: "track_sids",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 3,
  name: "disabled",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 4,
  name: "quality",
  kind: "enum",
  T: proto3.getEnumType(VideoQuality$1)
}, {
  no: 5,
  name: "width",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 6,
  name: "height",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 7,
  name: "fps",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 8,
  name: "priority",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}]), LeaveRequest = proto3.makeMessageType("livekit.LeaveRequest", () => [{
  no: 1,
  name: "can_reconnect",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 2,
  name: "reason",
  kind: "enum",
  T: proto3.getEnumType(DisconnectReason)
}, {
  no: 3,
  name: "action",
  kind: "enum",
  T: proto3.getEnumType(LeaveRequest_Action)
}, {
  no: 4,
  name: "regions",
  kind: "message",
  T: RegionSettings
}]), LeaveRequest_Action = proto3.makeEnum("livekit.LeaveRequest.Action", [{
  no: 0,
  name: "DISCONNECT"
}, {
  no: 1,
  name: "RESUME"
}, {
  no: 2,
  name: "RECONNECT"
}]), UpdateVideoLayers = proto3.makeMessageType("livekit.UpdateVideoLayers", () => [{
  no: 1,
  name: "track_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "layers",
  kind: "message",
  T: VideoLayer,
  repeated: !0
}]), UpdateParticipantMetadata = proto3.makeMessageType("livekit.UpdateParticipantMetadata", () => [{
  no: 1,
  name: "metadata",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), ICEServer = proto3.makeMessageType("livekit.ICEServer", () => [{
  no: 1,
  name: "urls",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 2,
  name: "username",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "credential",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), SpeakersChanged = proto3.makeMessageType("livekit.SpeakersChanged", () => [{
  no: 1,
  name: "speakers",
  kind: "message",
  T: SpeakerInfo,
  repeated: !0
}]), RoomUpdate = proto3.makeMessageType("livekit.RoomUpdate", () => [{
  no: 1,
  name: "room",
  kind: "message",
  T: Room$1
}]), ConnectionQualityInfo = proto3.makeMessageType("livekit.ConnectionQualityInfo", () => [{
  no: 1,
  name: "participant_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "quality",
  kind: "enum",
  T: proto3.getEnumType(ConnectionQuality$1)
}, {
  no: 3,
  name: "score",
  kind: "scalar",
  T: 2
  /* ScalarType.FLOAT */
}]), ConnectionQualityUpdate = proto3.makeMessageType("livekit.ConnectionQualityUpdate", () => [{
  no: 1,
  name: "updates",
  kind: "message",
  T: ConnectionQualityInfo,
  repeated: !0
}]), StreamStateInfo = proto3.makeMessageType("livekit.StreamStateInfo", () => [{
  no: 1,
  name: "participant_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "track_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "state",
  kind: "enum",
  T: proto3.getEnumType(StreamState)
}]), StreamStateUpdate = proto3.makeMessageType("livekit.StreamStateUpdate", () => [{
  no: 1,
  name: "stream_states",
  kind: "message",
  T: StreamStateInfo,
  repeated: !0
}]), SubscribedQuality = proto3.makeMessageType("livekit.SubscribedQuality", () => [{
  no: 1,
  name: "quality",
  kind: "enum",
  T: proto3.getEnumType(VideoQuality$1)
}, {
  no: 2,
  name: "enabled",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}]), SubscribedCodec = proto3.makeMessageType("livekit.SubscribedCodec", () => [{
  no: 1,
  name: "codec",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "qualities",
  kind: "message",
  T: SubscribedQuality,
  repeated: !0
}]), SubscribedQualityUpdate = proto3.makeMessageType("livekit.SubscribedQualityUpdate", () => [{
  no: 1,
  name: "track_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "subscribed_qualities",
  kind: "message",
  T: SubscribedQuality,
  repeated: !0
}, {
  no: 3,
  name: "subscribed_codecs",
  kind: "message",
  T: SubscribedCodec,
  repeated: !0
}]), TrackPermission = proto3.makeMessageType("livekit.TrackPermission", () => [{
  no: 1,
  name: "participant_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "all_tracks",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 3,
  name: "track_sids",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 4,
  name: "participant_identity",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), SubscriptionPermission = proto3.makeMessageType("livekit.SubscriptionPermission", () => [{
  no: 1,
  name: "all_participants",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 2,
  name: "track_permissions",
  kind: "message",
  T: TrackPermission,
  repeated: !0
}]), SubscriptionPermissionUpdate = proto3.makeMessageType("livekit.SubscriptionPermissionUpdate", () => [{
  no: 1,
  name: "participant_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "track_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "allowed",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}]), SyncState = proto3.makeMessageType("livekit.SyncState", () => [{
  no: 1,
  name: "answer",
  kind: "message",
  T: SessionDescription
}, {
  no: 2,
  name: "subscription",
  kind: "message",
  T: UpdateSubscription
}, {
  no: 3,
  name: "publish_tracks",
  kind: "message",
  T: TrackPublishedResponse,
  repeated: !0
}, {
  no: 4,
  name: "data_channels",
  kind: "message",
  T: DataChannelInfo,
  repeated: !0
}, {
  no: 5,
  name: "offer",
  kind: "message",
  T: SessionDescription
}, {
  no: 6,
  name: "track_sids_disabled",
  kind: "scalar",
  T: 9,
  repeated: !0
}]), DataChannelInfo = proto3.makeMessageType("livekit.DataChannelInfo", () => [{
  no: 1,
  name: "label",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "id",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 3,
  name: "target",
  kind: "enum",
  T: proto3.getEnumType(SignalTarget)
}]), SimulateScenario = proto3.makeMessageType("livekit.SimulateScenario", () => [{
  no: 1,
  name: "speaker_update",
  kind: "scalar",
  T: 5,
  oneof: "scenario"
}, {
  no: 2,
  name: "node_failure",
  kind: "scalar",
  T: 8,
  oneof: "scenario"
}, {
  no: 3,
  name: "migration",
  kind: "scalar",
  T: 8,
  oneof: "scenario"
}, {
  no: 4,
  name: "server_leave",
  kind: "scalar",
  T: 8,
  oneof: "scenario"
}, {
  no: 5,
  name: "switch_candidate_protocol",
  kind: "enum",
  T: proto3.getEnumType(CandidateProtocol),
  oneof: "scenario"
}, {
  no: 6,
  name: "subscriber_bandwidth",
  kind: "scalar",
  T: 3,
  oneof: "scenario"
}, {
  no: 7,
  name: "disconnect_signal_on_resume",
  kind: "scalar",
  T: 8,
  oneof: "scenario"
}, {
  no: 8,
  name: "disconnect_signal_on_resume_no_messages",
  kind: "scalar",
  T: 8,
  oneof: "scenario"
}]), Ping = proto3.makeMessageType("livekit.Ping", () => [{
  no: 1,
  name: "timestamp",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 2,
  name: "rtt",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}]), Pong = proto3.makeMessageType("livekit.Pong", () => [{
  no: 1,
  name: "last_ping_timestamp",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 2,
  name: "timestamp",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}]), RegionSettings = proto3.makeMessageType("livekit.RegionSettings", () => [{
  no: 1,
  name: "regions",
  kind: "message",
  T: RegionInfo,
  repeated: !0
}]), RegionInfo = proto3.makeMessageType("livekit.RegionInfo", () => [{
  no: 1,
  name: "region",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "url",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "distance",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}]), SubscriptionResponse = proto3.makeMessageType("livekit.SubscriptionResponse", () => [{
  no: 1,
  name: "track_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "err",
  kind: "enum",
  T: proto3.getEnumType(SubscriptionError)
}]), IngressInput = proto3.makeEnum("livekit.IngressInput", [{
  no: 0,
  name: "RTMP_INPUT"
}, {
  no: 1,
  name: "WHIP_INPUT"
}, {
  no: 2,
  name: "URL_INPUT"
}]), IngressAudioEncodingPreset = proto3.makeEnum("livekit.IngressAudioEncodingPreset", [{
  no: 0,
  name: "OPUS_STEREO_96KBPS"
}, {
  no: 1,
  name: "OPUS_MONO_64KBS"
}]), IngressVideoEncodingPreset = proto3.makeEnum("livekit.IngressVideoEncodingPreset", [{
  no: 0,
  name: "H264_720P_30FPS_3_LAYERS"
}, {
  no: 1,
  name: "H264_1080P_30FPS_3_LAYERS"
}, {
  no: 2,
  name: "H264_540P_25FPS_2_LAYERS"
}, {
  no: 3,
  name: "H264_720P_30FPS_1_LAYER"
}, {
  no: 4,
  name: "H264_1080P_30FPS_1_LAYER"
}, {
  no: 5,
  name: "H264_720P_30FPS_3_LAYERS_HIGH_MOTION"
}, {
  no: 6,
  name: "H264_1080P_30FPS_3_LAYERS_HIGH_MOTION"
}, {
  no: 7,
  name: "H264_540P_25FPS_2_LAYERS_HIGH_MOTION"
}, {
  no: 8,
  name: "H264_720P_30FPS_1_LAYER_HIGH_MOTION"
}, {
  no: 9,
  name: "H264_1080P_30FPS_1_LAYER_HIGH_MOTION"
}]);
proto3.makeMessageType("livekit.CreateIngressRequest", () => [{
  no: 1,
  name: "input_type",
  kind: "enum",
  T: proto3.getEnumType(IngressInput)
}, {
  no: 9,
  name: "url",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "room_name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 4,
  name: "participant_identity",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "participant_name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 10,
  name: "participant_metadata",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 8,
  name: "bypass_transcoding",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 6,
  name: "audio",
  kind: "message",
  T: IngressAudioOptions
}, {
  no: 7,
  name: "video",
  kind: "message",
  T: IngressVideoOptions
}]);
const IngressAudioOptions = proto3.makeMessageType("livekit.IngressAudioOptions", () => [{
  no: 1,
  name: "name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "source",
  kind: "enum",
  T: proto3.getEnumType(TrackSource)
}, {
  no: 3,
  name: "preset",
  kind: "enum",
  T: proto3.getEnumType(IngressAudioEncodingPreset),
  oneof: "encoding_options"
}, {
  no: 4,
  name: "options",
  kind: "message",
  T: IngressAudioEncodingOptions,
  oneof: "encoding_options"
}]), IngressVideoOptions = proto3.makeMessageType("livekit.IngressVideoOptions", () => [{
  no: 1,
  name: "name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "source",
  kind: "enum",
  T: proto3.getEnumType(TrackSource)
}, {
  no: 3,
  name: "preset",
  kind: "enum",
  T: proto3.getEnumType(IngressVideoEncodingPreset),
  oneof: "encoding_options"
}, {
  no: 4,
  name: "options",
  kind: "message",
  T: IngressVideoEncodingOptions,
  oneof: "encoding_options"
}]), IngressAudioEncodingOptions = proto3.makeMessageType("livekit.IngressAudioEncodingOptions", () => [{
  no: 1,
  name: "audio_codec",
  kind: "enum",
  T: proto3.getEnumType(AudioCodec$1)
}, {
  no: 2,
  name: "bitrate",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 3,
  name: "disable_dtx",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 4,
  name: "channels",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}]), IngressVideoEncodingOptions = proto3.makeMessageType("livekit.IngressVideoEncodingOptions", () => [{
  no: 1,
  name: "video_codec",
  kind: "enum",
  T: proto3.getEnumType(VideoCodec$1)
}, {
  no: 2,
  name: "frame_rate",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}, {
  no: 3,
  name: "layers",
  kind: "message",
  T: VideoLayer,
  repeated: !0
}]), IngressInfo = proto3.makeMessageType("livekit.IngressInfo", () => [{
  no: 1,
  name: "ingress_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "stream_key",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 4,
  name: "url",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "input_type",
  kind: "enum",
  T: proto3.getEnumType(IngressInput)
}, {
  no: 13,
  name: "bypass_transcoding",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 6,
  name: "audio",
  kind: "message",
  T: IngressAudioOptions
}, {
  no: 7,
  name: "video",
  kind: "message",
  T: IngressVideoOptions
}, {
  no: 8,
  name: "room_name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 9,
  name: "participant_identity",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 10,
  name: "participant_name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 14,
  name: "participant_metadata",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 11,
  name: "reusable",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 12,
  name: "state",
  kind: "message",
  T: IngressState
}]), IngressState = proto3.makeMessageType("livekit.IngressState", () => [{
  no: 1,
  name: "status",
  kind: "enum",
  T: proto3.getEnumType(IngressState_Status)
}, {
  no: 2,
  name: "error",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "video",
  kind: "message",
  T: InputVideoState
}, {
  no: 4,
  name: "audio",
  kind: "message",
  T: InputAudioState
}, {
  no: 5,
  name: "room_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 7,
  name: "started_at",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 8,
  name: "ended_at",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 9,
  name: "resource_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 6,
  name: "tracks",
  kind: "message",
  T: TrackInfo,
  repeated: !0
}]), IngressState_Status = proto3.makeEnum("livekit.IngressState.Status", [{
  no: 0,
  name: "ENDPOINT_INACTIVE"
}, {
  no: 1,
  name: "ENDPOINT_BUFFERING"
}, {
  no: 2,
  name: "ENDPOINT_PUBLISHING"
}, {
  no: 3,
  name: "ENDPOINT_ERROR"
}, {
  no: 4,
  name: "ENDPOINT_COMPLETE"
}]), InputVideoState = proto3.makeMessageType("livekit.InputVideoState", () => [{
  no: 1,
  name: "mime_type",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "average_bitrate",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 3,
  name: "width",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 4,
  name: "height",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 5,
  name: "framerate",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}]), InputAudioState = proto3.makeMessageType("livekit.InputAudioState", () => [{
  no: 1,
  name: "mime_type",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "average_bitrate",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 3,
  name: "channels",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 4,
  name: "sample_rate",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}]);
proto3.makeMessageType("livekit.UpdateIngressRequest", () => [{
  no: 1,
  name: "ingress_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "room_name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 4,
  name: "participant_identity",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "participant_name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 9,
  name: "participant_metadata",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 8,
  name: "bypass_transcoding",
  kind: "scalar",
  T: 8,
  opt: !0
}, {
  no: 6,
  name: "audio",
  kind: "message",
  T: IngressAudioOptions
}, {
  no: 7,
  name: "video",
  kind: "message",
  T: IngressVideoOptions
}]);
proto3.makeMessageType("livekit.ListIngressRequest", () => [{
  no: 1,
  name: "room_name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "ingress_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
proto3.makeMessageType("livekit.ListIngressResponse", () => [{
  no: 1,
  name: "items",
  kind: "message",
  T: IngressInfo,
  repeated: !0
}]);
proto3.makeMessageType("livekit.DeleteIngressRequest", () => [{
  no: 1,
  name: "ingress_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
proto3.makeMessageType("livekit.WebhookEvent", () => [{
  no: 1,
  name: "event",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "room",
  kind: "message",
  T: Room$1
}, {
  no: 3,
  name: "participant",
  kind: "message",
  T: ParticipantInfo
}, {
  no: 9,
  name: "egress_info",
  kind: "message",
  T: EgressInfo
}, {
  no: 10,
  name: "ingress_info",
  kind: "message",
  T: IngressInfo
}, {
  no: 8,
  name: "track",
  kind: "message",
  T: TrackInfo
}, {
  no: 6,
  name: "id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 7,
  name: "created_at",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 11,
  name: "num_dropped",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}]);
proto3.makeMessageType("livekit.CreateSIPTrunkRequest", () => [{
  no: 1,
  name: "inbound_addresses",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 2,
  name: "outbound_address",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "outbound_number",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 4,
  name: "inbound_numbers_regex",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 9,
  name: "inbound_numbers",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 5,
  name: "inbound_username",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 6,
  name: "inbound_password",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 7,
  name: "outbound_username",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 8,
  name: "outbound_password",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
const SIPTrunkInfo = proto3.makeMessageType("livekit.SIPTrunkInfo", () => [{
  no: 1,
  name: "sip_trunk_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "inbound_addresses",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 3,
  name: "outbound_address",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 4,
  name: "outbound_number",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "inbound_numbers_regex",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 10,
  name: "inbound_numbers",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 6,
  name: "inbound_username",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 7,
  name: "inbound_password",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 8,
  name: "outbound_username",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 9,
  name: "outbound_password",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
proto3.makeMessageType("livekit.ListSIPTrunkRequest", []);
proto3.makeMessageType("livekit.ListSIPTrunkResponse", () => [{
  no: 1,
  name: "items",
  kind: "message",
  T: SIPTrunkInfo,
  repeated: !0
}]);
proto3.makeMessageType("livekit.DeleteSIPTrunkRequest", () => [{
  no: 1,
  name: "sip_trunk_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
const SIPDispatchRuleDirect = proto3.makeMessageType("livekit.SIPDispatchRuleDirect", () => [{
  no: 1,
  name: "room_name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "pin",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), SIPDispatchRuleIndividual = proto3.makeMessageType("livekit.SIPDispatchRuleIndividual", () => [{
  no: 1,
  name: "room_prefix",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "pin",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), SIPDispatchRule = proto3.makeMessageType("livekit.SIPDispatchRule", () => [{
  no: 1,
  name: "dispatch_rule_direct",
  kind: "message",
  T: SIPDispatchRuleDirect,
  oneof: "rule"
}, {
  no: 2,
  name: "dispatch_rule_individual",
  kind: "message",
  T: SIPDispatchRuleIndividual,
  oneof: "rule"
}]);
proto3.makeMessageType("livekit.CreateSIPDispatchRuleRequest", () => [{
  no: 1,
  name: "rule",
  kind: "message",
  T: SIPDispatchRule
}, {
  no: 2,
  name: "trunk_ids",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 3,
  name: "hide_phone_number",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}]);
const SIPDispatchRuleInfo = proto3.makeMessageType("livekit.SIPDispatchRuleInfo", () => [{
  no: 1,
  name: "sip_dispatch_rule_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "rule",
  kind: "message",
  T: SIPDispatchRule
}, {
  no: 3,
  name: "trunk_ids",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 4,
  name: "hide_phone_number",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}]);
proto3.makeMessageType("livekit.ListSIPDispatchRuleRequest", []);
proto3.makeMessageType("livekit.ListSIPDispatchRuleResponse", () => [{
  no: 1,
  name: "items",
  kind: "message",
  T: SIPDispatchRuleInfo,
  repeated: !0
}]);
proto3.makeMessageType("livekit.DeleteSIPDispatchRuleRequest", () => [{
  no: 1,
  name: "sip_dispatch_rule_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
proto3.makeMessageType("livekit.CreateSIPParticipantRequest", () => [{
  no: 1,
  name: "sip_trunk_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "sip_call_to",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "room_name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 4,
  name: "participant_identity",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
proto3.makeMessageType("livekit.SIPParticipantInfo", () => [{
  no: 1,
  name: "participant_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "participant_identity",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "room_name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global$1 < "u" ? global$1 : typeof self < "u" ? self : {};
function getDefaultExportFromCjs(a) {
  return a && a.__esModule && Object.prototype.hasOwnProperty.call(a, "default") ? a.default : a;
}
var loglevel$1 = { exports: {} };
(function(a) {
  (function(u, c) {
    a.exports ? a.exports = c() : u.log = c();
  })(commonjsGlobal, function() {
    var u = function() {
    }, c = "undefined", l = typeof window !== c && typeof window.navigator !== c && /Trident\/|MSIE /.test(window.navigator.userAgent), v = ["trace", "debug", "info", "warn", "error"];
    function p(ae, ne) {
      var fe = ae[ne];
      if (typeof fe.bind == "function")
        return fe.bind(ae);
      try {
        return Function.prototype.bind.call(fe, ae);
      } catch {
        return function() {
          return Function.prototype.apply.apply(fe, [ae, arguments]);
        };
      }
    }
    function _() {
      console.log && (console.log.apply ? console.log.apply(console, arguments) : Function.prototype.apply.apply(console.log, [console, arguments])), console.trace && console.trace();
    }
    function k(ae) {
      return ae === "debug" && (ae = "log"), typeof console === c ? !1 : ae === "trace" && l ? _ : console[ae] !== void 0 ? p(console, ae) : console.log !== void 0 ? p(console, "log") : u;
    }
    function M(ae, ne) {
      for (var fe = 0; fe < v.length; fe++) {
        var ie = v[fe];
        this[ie] = fe < ae ? u : this.methodFactory(ie, ae, ne);
      }
      this.log = this.debug;
    }
    function L(ae, ne, fe) {
      return function() {
        typeof console !== c && (M.call(this, ne, fe), this[ae].apply(this, arguments));
      };
    }
    function F(ae, ne, fe) {
      return k(ae) || L.apply(this, arguments);
    }
    function V(ae, ne, fe) {
      var ie = this, ge;
      ne = ne ?? "WARN";
      var be = "loglevel";
      typeof ae == "string" ? be += ":" + ae : typeof ae == "symbol" && (be = void 0);
      function Ce(Z) {
        var z = (v[Z] || "silent").toUpperCase();
        if (!(typeof window === c || !be)) {
          try {
            window.localStorage[be] = z;
            return;
          } catch {
          }
          try {
            window.document.cookie = encodeURIComponent(be) + "=" + z + ";";
          } catch {
          }
        }
      }
      function Me() {
        var Z;
        if (!(typeof window === c || !be)) {
          try {
            Z = window.localStorage[be];
          } catch {
          }
          if (typeof Z === c)
            try {
              var z = window.document.cookie, P = z.indexOf(encodeURIComponent(be) + "=");
              P !== -1 && (Z = /^([^;]+)/.exec(z.slice(P))[1]);
            } catch {
            }
          return ie.levels[Z] === void 0 && (Z = void 0), Z;
        }
      }
      function Be() {
        if (!(typeof window === c || !be)) {
          try {
            window.localStorage.removeItem(be);
            return;
          } catch {
          }
          try {
            window.document.cookie = encodeURIComponent(be) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
          } catch {
          }
        }
      }
      ie.name = ae, ie.levels = {
        TRACE: 0,
        DEBUG: 1,
        INFO: 2,
        WARN: 3,
        ERROR: 4,
        SILENT: 5
      }, ie.methodFactory = fe || F, ie.getLevel = function() {
        return ge;
      }, ie.setLevel = function(Z, z) {
        if (typeof Z == "string" && ie.levels[Z.toUpperCase()] !== void 0 && (Z = ie.levels[Z.toUpperCase()]), typeof Z == "number" && Z >= 0 && Z <= ie.levels.SILENT) {
          if (ge = Z, z !== !1 && Ce(Z), M.call(ie, Z, ae), typeof console === c && Z < ie.levels.SILENT)
            return "No console available for logging";
        } else
          throw "log.setLevel() called with invalid level: " + Z;
      }, ie.setDefaultLevel = function(Z) {
        ne = Z, Me() || ie.setLevel(Z, !1);
      }, ie.resetLevel = function() {
        ie.setLevel(ne, !1), Be();
      }, ie.enableAll = function(Z) {
        ie.setLevel(ie.levels.TRACE, Z);
      }, ie.disableAll = function(Z) {
        ie.setLevel(ie.levels.SILENT, Z);
      };
      var Ae = Me();
      Ae == null && (Ae = ne), ie.setLevel(Ae, !1);
    }
    var X = new V(), oe = {};
    X.getLogger = function(ne) {
      if (typeof ne != "symbol" && typeof ne != "string" || ne === "")
        throw new TypeError("You must supply a name when creating a logger.");
      var fe = oe[ne];
      return fe || (fe = oe[ne] = new V(ne, X.getLevel(), X.methodFactory)), fe;
    };
    var Y = typeof window !== c ? window.log : void 0;
    return X.noConflict = function() {
      return typeof window !== c && window.log === X && (window.log = Y), X;
    }, X.getLoggers = function() {
      return oe;
    }, X.default = X, X;
  });
})(loglevel$1);
var loglevelExports$1 = loglevel$1.exports, LogLevel;
(function(a) {
  a[a.trace = 0] = "trace", a[a.debug = 1] = "debug", a[a.info = 2] = "info", a[a.warn = 3] = "warn", a[a.error = 4] = "error", a[a.silent = 5] = "silent";
})(LogLevel || (LogLevel = {}));
var LoggerNames;
(function(a) {
  a.Default = "livekit", a.Room = "livekit-room", a.Participant = "livekit-participant", a.Track = "livekit-track", a.Publication = "livekit-track-publication", a.Engine = "livekit-engine", a.Signal = "livekit-signal", a.PCManager = "livekit-pc-manager", a.PCTransport = "livekit-pc-transport", a.E2EE = "lk-e2ee";
})(LoggerNames || (LoggerNames = {}));
let livekitLogger = loglevelExports$1.getLogger("livekit");
const livekitLoggers = Object.values(LoggerNames).map((a) => loglevelExports$1.getLogger(a));
livekitLogger.setDefaultLevel(LogLevel.info);
function getLogger(a) {
  const u = loglevelExports$1.getLogger(a);
  return u.setDefaultLevel(livekitLogger.getLevel()), u;
}
function setLogLevel(a, u) {
  u && loglevelExports$1.getLogger(u).setLevel(a);
  for (const c of livekitLoggers)
    c.setLevel(a);
}
const workerLogger = loglevelExports$1.getLogger("lk-e2ee"), maxRetryDelay = 7e3, DEFAULT_RETRY_DELAYS_IN_MS = [0, 300, 2 * 2 * 300, 3 * 3 * 300, 4 * 4 * 300, maxRetryDelay, maxRetryDelay, maxRetryDelay, maxRetryDelay, maxRetryDelay];
class DefaultReconnectPolicy {
  constructor(u) {
    this._retryDelays = u !== void 0 ? [...u] : DEFAULT_RETRY_DELAYS_IN_MS;
  }
  nextRetryDelayInMs(u) {
    if (u.retryCount >= this._retryDelays.length)
      return null;
    const c = this._retryDelays[u.retryCount];
    return u.retryCount <= 1 ? c : c + Math.random() * 1e3;
  }
}
function __awaiter$3(a, u, c, l) {
  function v(p) {
    return p instanceof c ? p : new c(function(_) {
      _(p);
    });
  }
  return new (c || (c = Promise))(function(p, _) {
    function k(F) {
      try {
        L(l.next(F));
      } catch (V) {
        _(V);
      }
    }
    function M(F) {
      try {
        L(l.throw(F));
      } catch (V) {
        _(V);
      }
    }
    function L(F) {
      F.done ? p(F.value) : v(F.value).then(k, M);
    }
    L((l = l.apply(a, u || [])).next());
  });
}
function __values(a) {
  var u = typeof Symbol == "function" && Symbol.iterator, c = u && a[u], l = 0;
  if (c)
    return c.call(a);
  if (a && typeof a.length == "number")
    return {
      next: function() {
        return a && l >= a.length && (a = void 0), { value: a && a[l++], done: !a };
      }
    };
  throw new TypeError(u ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __asyncValues(a) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var u = a[Symbol.asyncIterator], c;
  return u ? u.call(a) : (a = typeof __values == "function" ? __values(a) : a[Symbol.iterator](), c = {}, l("next"), l("throw"), l("return"), c[Symbol.asyncIterator] = function() {
    return this;
  }, c);
  function l(p) {
    c[p] = a[p] && function(_) {
      return new Promise(function(k, M) {
        _ = a[p](_), v(k, M, _.done, _.value);
      });
    };
  }
  function v(p, _, k, M) {
    Promise.resolve(M).then(function(L) {
      p({ value: L, done: k });
    }, _);
  }
}
typeof SuppressedError == "function" && SuppressedError;
var events$2 = { exports: {} }, R$1 = typeof Reflect == "object" ? Reflect : null, ReflectApply$1 = R$1 && typeof R$1.apply == "function" ? R$1.apply : function a(u, c, l) {
  return Function.prototype.apply.call(u, c, l);
}, ReflectOwnKeys$1;
R$1 && typeof R$1.ownKeys == "function" ? ReflectOwnKeys$1 = R$1.ownKeys : Object.getOwnPropertySymbols ? ReflectOwnKeys$1 = function(u) {
  return Object.getOwnPropertyNames(u).concat(Object.getOwnPropertySymbols(u));
} : ReflectOwnKeys$1 = function(u) {
  return Object.getOwnPropertyNames(u);
};
function ProcessEmitWarning$1(a) {
  console && console.warn && console.warn(a);
}
var NumberIsNaN$1 = Number.isNaN || function a(u) {
  return u !== u;
};
function EventEmitter$1() {
  EventEmitter$1.init.call(this);
}
events$2.exports = EventEmitter$1;
events$2.exports.once = once$7;
EventEmitter$1.EventEmitter = EventEmitter$1;
EventEmitter$1.prototype._events = void 0;
EventEmitter$1.prototype._eventsCount = 0;
EventEmitter$1.prototype._maxListeners = void 0;
var defaultMaxListeners$1 = 10;
function checkListener$1(a) {
  if (typeof a != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof a);
}
Object.defineProperty(EventEmitter$1, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return defaultMaxListeners$1;
  },
  set: function(a) {
    if (typeof a != "number" || a < 0 || NumberIsNaN$1(a))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + a + ".");
    defaultMaxListeners$1 = a;
  }
});
EventEmitter$1.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
EventEmitter$1.prototype.setMaxListeners = function a(u) {
  if (typeof u != "number" || u < 0 || NumberIsNaN$1(u))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + u + ".");
  return this._maxListeners = u, this;
};
function _getMaxListeners$1(a) {
  return a._maxListeners === void 0 ? EventEmitter$1.defaultMaxListeners : a._maxListeners;
}
EventEmitter$1.prototype.getMaxListeners = function a() {
  return _getMaxListeners$1(this);
};
EventEmitter$1.prototype.emit = function a(u) {
  for (var c = [], l = 1; l < arguments.length; l++)
    c.push(arguments[l]);
  var v = u === "error", p = this._events;
  if (p !== void 0)
    v = v && p.error === void 0;
  else if (!v)
    return !1;
  if (v) {
    var _;
    if (c.length > 0 && (_ = c[0]), _ instanceof Error)
      throw _;
    var k = new Error("Unhandled error." + (_ ? " (" + _.message + ")" : ""));
    throw k.context = _, k;
  }
  var M = p[u];
  if (M === void 0)
    return !1;
  if (typeof M == "function")
    ReflectApply$1(M, this, c);
  else
    for (var L = M.length, F = arrayClone$1(M, L), l = 0; l < L; ++l)
      ReflectApply$1(F[l], this, c);
  return !0;
};
function _addListener$1(a, u, c, l) {
  var v, p, _;
  if (checkListener$1(c), p = a._events, p === void 0 ? (p = a._events = /* @__PURE__ */ Object.create(null), a._eventsCount = 0) : (p.newListener !== void 0 && (a.emit("newListener", u, c.listener ? c.listener : c), p = a._events), _ = p[u]), _ === void 0)
    _ = p[u] = c, ++a._eventsCount;
  else if (typeof _ == "function" ? _ = p[u] = l ? [c, _] : [_, c] : l ? _.unshift(c) : _.push(c), v = _getMaxListeners$1(a), v > 0 && _.length > v && !_.warned) {
    _.warned = !0;
    var k = new Error("Possible EventEmitter memory leak detected. " + _.length + " " + String(u) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    k.name = "MaxListenersExceededWarning", k.emitter = a, k.type = u, k.count = _.length, ProcessEmitWarning$1(k);
  }
  return a;
}
EventEmitter$1.prototype.addListener = function a(u, c) {
  return _addListener$1(this, u, c, !1);
};
EventEmitter$1.prototype.on = EventEmitter$1.prototype.addListener;
EventEmitter$1.prototype.prependListener = function a(u, c) {
  return _addListener$1(this, u, c, !0);
};
function onceWrapper$1() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function _onceWrap$1(a, u, c) {
  var l = {
    fired: !1,
    wrapFn: void 0,
    target: a,
    type: u,
    listener: c
  }, v = onceWrapper$1.bind(l);
  return v.listener = c, l.wrapFn = v, v;
}
EventEmitter$1.prototype.once = function a(u, c) {
  return checkListener$1(c), this.on(u, _onceWrap$1(this, u, c)), this;
};
EventEmitter$1.prototype.prependOnceListener = function a(u, c) {
  return checkListener$1(c), this.prependListener(u, _onceWrap$1(this, u, c)), this;
};
EventEmitter$1.prototype.removeListener = function a(u, c) {
  var l, v, p, _, k;
  if (checkListener$1(c), v = this._events, v === void 0)
    return this;
  if (l = v[u], l === void 0)
    return this;
  if (l === c || l.listener === c)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete v[u], v.removeListener && this.emit("removeListener", u, l.listener || c));
  else if (typeof l != "function") {
    for (p = -1, _ = l.length - 1; _ >= 0; _--)
      if (l[_] === c || l[_].listener === c) {
        k = l[_].listener, p = _;
        break;
      }
    if (p < 0)
      return this;
    p === 0 ? l.shift() : spliceOne$1(l, p), l.length === 1 && (v[u] = l[0]), v.removeListener !== void 0 && this.emit("removeListener", u, k || c);
  }
  return this;
};
EventEmitter$1.prototype.off = EventEmitter$1.prototype.removeListener;
EventEmitter$1.prototype.removeAllListeners = function a(u) {
  var c, l, v;
  if (l = this._events, l === void 0)
    return this;
  if (l.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : l[u] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete l[u]), this;
  if (arguments.length === 0) {
    var p = Object.keys(l), _;
    for (v = 0; v < p.length; ++v)
      _ = p[v], _ !== "removeListener" && this.removeAllListeners(_);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (c = l[u], typeof c == "function")
    this.removeListener(u, c);
  else if (c !== void 0)
    for (v = c.length - 1; v >= 0; v--)
      this.removeListener(u, c[v]);
  return this;
};
function _listeners$1(a, u, c) {
  var l = a._events;
  if (l === void 0)
    return [];
  var v = l[u];
  return v === void 0 ? [] : typeof v == "function" ? c ? [v.listener || v] : [v] : c ? unwrapListeners$1(v) : arrayClone$1(v, v.length);
}
EventEmitter$1.prototype.listeners = function a(u) {
  return _listeners$1(this, u, !0);
};
EventEmitter$1.prototype.rawListeners = function a(u) {
  return _listeners$1(this, u, !1);
};
EventEmitter$1.listenerCount = function(a, u) {
  return typeof a.listenerCount == "function" ? a.listenerCount(u) : listenerCount$1.call(a, u);
};
EventEmitter$1.prototype.listenerCount = listenerCount$1;
function listenerCount$1(a) {
  var u = this._events;
  if (u !== void 0) {
    var c = u[a];
    if (typeof c == "function")
      return 1;
    if (c !== void 0)
      return c.length;
  }
  return 0;
}
EventEmitter$1.prototype.eventNames = function a() {
  return this._eventsCount > 0 ? ReflectOwnKeys$1(this._events) : [];
};
function arrayClone$1(a, u) {
  for (var c = new Array(u), l = 0; l < u; ++l)
    c[l] = a[l];
  return c;
}
function spliceOne$1(a, u) {
  for (; u + 1 < a.length; u++)
    a[u] = a[u + 1];
  a.pop();
}
function unwrapListeners$1(a) {
  for (var u = new Array(a.length), c = 0; c < u.length; ++c)
    u[c] = a[c].listener || a[c];
  return u;
}
function once$7(a, u) {
  return new Promise(function(c, l) {
    function v(_) {
      a.removeListener(u, p), l(_);
    }
    function p() {
      typeof a.removeListener == "function" && a.removeListener("error", v), c([].slice.call(arguments));
    }
    eventTargetAgnosticAddListener$1(a, u, p, {
      once: !0
    }), u !== "error" && addErrorHandlerIfEventEmitter$1(a, v, {
      once: !0
    });
  });
}
function addErrorHandlerIfEventEmitter$1(a, u, c) {
  typeof a.on == "function" && eventTargetAgnosticAddListener$1(a, "error", u, c);
}
function eventTargetAgnosticAddListener$1(a, u, c, l) {
  if (typeof a.on == "function")
    l.once ? a.once(u, c) : a.on(u, c);
  else if (typeof a.addEventListener == "function")
    a.addEventListener(u, function v(p) {
      l.once && a.removeEventListener(u, v), c(p);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof a);
}
var eventsExports$1 = events$2.exports;
let logDisabled_ = !0, deprecationWarnings_ = !0;
function extractVersion(a, u, c) {
  const l = a.match(u);
  return l && l.length >= c && parseInt(l[c], 10);
}
function wrapPeerConnectionEvent(a, u, c) {
  if (!a.RTCPeerConnection)
    return;
  const l = a.RTCPeerConnection.prototype, v = l.addEventListener;
  l.addEventListener = function(_, k) {
    if (_ !== u)
      return v.apply(this, arguments);
    const M = (L) => {
      const F = c(L);
      F && (k.handleEvent ? k.handleEvent(F) : k(F));
    };
    return this._eventMap = this._eventMap || {}, this._eventMap[u] || (this._eventMap[u] = /* @__PURE__ */ new Map()), this._eventMap[u].set(k, M), v.apply(this, [_, M]);
  };
  const p = l.removeEventListener;
  l.removeEventListener = function(_, k) {
    if (_ !== u || !this._eventMap || !this._eventMap[u])
      return p.apply(this, arguments);
    if (!this._eventMap[u].has(k))
      return p.apply(this, arguments);
    const M = this._eventMap[u].get(k);
    return this._eventMap[u].delete(k), this._eventMap[u].size === 0 && delete this._eventMap[u], Object.keys(this._eventMap).length === 0 && delete this._eventMap, p.apply(this, [_, M]);
  }, Object.defineProperty(l, "on" + u, {
    get() {
      return this["_on" + u];
    },
    set(_) {
      this["_on" + u] && (this.removeEventListener(u, this["_on" + u]), delete this["_on" + u]), _ && this.addEventListener(u, this["_on" + u] = _);
    },
    enumerable: !0,
    configurable: !0
  });
}
function disableLog(a) {
  return typeof a != "boolean" ? new Error("Argument type: " + typeof a + ". Please use a boolean.") : (logDisabled_ = a, a ? "adapter.js logging disabled" : "adapter.js logging enabled");
}
function disableWarnings(a) {
  return typeof a != "boolean" ? new Error("Argument type: " + typeof a + ". Please use a boolean.") : (deprecationWarnings_ = !a, "adapter.js deprecation warnings " + (a ? "disabled" : "enabled"));
}
function log$1() {
  if (typeof window == "object") {
    if (logDisabled_)
      return;
    typeof console < "u" && typeof console.log == "function" && console.log.apply(console, arguments);
  }
}
function deprecated(a, u) {
  deprecationWarnings_ && console.warn(a + " is deprecated, please use " + u + " instead.");
}
function detectBrowser(a) {
  const u = {
    browser: null,
    version: null
  };
  if (typeof a > "u" || !a.navigator || !a.navigator.userAgent)
    return u.browser = "Not a browser.", u;
  const {
    navigator: c
  } = a;
  if (c.mozGetUserMedia)
    u.browser = "firefox", u.version = extractVersion(c.userAgent, /Firefox\/(\d+)\./, 1);
  else if (c.webkitGetUserMedia || a.isSecureContext === !1 && a.webkitRTCPeerConnection)
    u.browser = "chrome", u.version = extractVersion(c.userAgent, /Chrom(e|ium)\/(\d+)\./, 2);
  else if (a.RTCPeerConnection && c.userAgent.match(/AppleWebKit\/(\d+)\./))
    u.browser = "safari", u.version = extractVersion(c.userAgent, /AppleWebKit\/(\d+)\./, 1), u.supportsUnifiedPlan = a.RTCRtpTransceiver && "currentDirection" in a.RTCRtpTransceiver.prototype;
  else
    return u.browser = "Not a supported browser.", u;
  return u;
}
function isObject$7(a) {
  return Object.prototype.toString.call(a) === "[object Object]";
}
function compactObject(a) {
  return isObject$7(a) ? Object.keys(a).reduce(function(u, c) {
    const l = isObject$7(a[c]), v = l ? compactObject(a[c]) : a[c], p = l && !Object.keys(v).length;
    return v === void 0 || p ? u : Object.assign(u, {
      [c]: v
    });
  }, {}) : a;
}
function walkStats(a, u, c) {
  !u || c.has(u.id) || (c.set(u.id, u), Object.keys(u).forEach((l) => {
    l.endsWith("Id") ? walkStats(a, a.get(u[l]), c) : l.endsWith("Ids") && u[l].forEach((v) => {
      walkStats(a, a.get(v), c);
    });
  }));
}
function filterStats(a, u, c) {
  const l = c ? "outbound-rtp" : "inbound-rtp", v = /* @__PURE__ */ new Map();
  if (u === null)
    return v;
  const p = [];
  return a.forEach((_) => {
    _.type === "track" && _.trackIdentifier === u.id && p.push(_);
  }), p.forEach((_) => {
    a.forEach((k) => {
      k.type === l && k.trackId === _.id && walkStats(a, k, v);
    });
  }), v;
}
const logging = log$1;
function shimGetUserMedia$2(a, u) {
  const c = a && a.navigator;
  if (!c.mediaDevices)
    return;
  const l = function(k) {
    if (typeof k != "object" || k.mandatory || k.optional)
      return k;
    const M = {};
    return Object.keys(k).forEach((L) => {
      if (L === "require" || L === "advanced" || L === "mediaSource")
        return;
      const F = typeof k[L] == "object" ? k[L] : {
        ideal: k[L]
      };
      F.exact !== void 0 && typeof F.exact == "number" && (F.min = F.max = F.exact);
      const V = function(X, oe) {
        return X ? X + oe.charAt(0).toUpperCase() + oe.slice(1) : oe === "deviceId" ? "sourceId" : oe;
      };
      if (F.ideal !== void 0) {
        M.optional = M.optional || [];
        let X = {};
        typeof F.ideal == "number" ? (X[V("min", L)] = F.ideal, M.optional.push(X), X = {}, X[V("max", L)] = F.ideal, M.optional.push(X)) : (X[V("", L)] = F.ideal, M.optional.push(X));
      }
      F.exact !== void 0 && typeof F.exact != "number" ? (M.mandatory = M.mandatory || {}, M.mandatory[V("", L)] = F.exact) : ["min", "max"].forEach((X) => {
        F[X] !== void 0 && (M.mandatory = M.mandatory || {}, M.mandatory[V(X, L)] = F[X]);
      });
    }), k.advanced && (M.optional = (M.optional || []).concat(k.advanced)), M;
  }, v = function(k, M) {
    if (u.version >= 61)
      return M(k);
    if (k = JSON.parse(JSON.stringify(k)), k && typeof k.audio == "object") {
      const L = function(F, V, X) {
        V in F && !(X in F) && (F[X] = F[V], delete F[V]);
      };
      k = JSON.parse(JSON.stringify(k)), L(k.audio, "autoGainControl", "googAutoGainControl"), L(k.audio, "noiseSuppression", "googNoiseSuppression"), k.audio = l(k.audio);
    }
    if (k && typeof k.video == "object") {
      let L = k.video.facingMode;
      L = L && (typeof L == "object" ? L : {
        ideal: L
      });
      const F = u.version < 66;
      if (L && (L.exact === "user" || L.exact === "environment" || L.ideal === "user" || L.ideal === "environment") && !(c.mediaDevices.getSupportedConstraints && c.mediaDevices.getSupportedConstraints().facingMode && !F)) {
        delete k.video.facingMode;
        let V;
        if (L.exact === "environment" || L.ideal === "environment" ? V = ["back", "rear"] : (L.exact === "user" || L.ideal === "user") && (V = ["front"]), V)
          return c.mediaDevices.enumerateDevices().then((X) => {
            X = X.filter((Y) => Y.kind === "videoinput");
            let oe = X.find((Y) => V.some((ae) => Y.label.toLowerCase().includes(ae)));
            return !oe && X.length && V.includes("back") && (oe = X[X.length - 1]), oe && (k.video.deviceId = L.exact ? {
              exact: oe.deviceId
            } : {
              ideal: oe.deviceId
            }), k.video = l(k.video), logging("chrome: " + JSON.stringify(k)), M(k);
          });
      }
      k.video = l(k.video);
    }
    return logging("chrome: " + JSON.stringify(k)), M(k);
  }, p = function(k) {
    return u.version >= 64 ? k : {
      name: {
        PermissionDeniedError: "NotAllowedError",
        PermissionDismissedError: "NotAllowedError",
        InvalidStateError: "NotAllowedError",
        DevicesNotFoundError: "NotFoundError",
        ConstraintNotSatisfiedError: "OverconstrainedError",
        TrackStartError: "NotReadableError",
        MediaDeviceFailedDueToShutdown: "NotAllowedError",
        MediaDeviceKillSwitchOn: "NotAllowedError",
        TabCaptureError: "AbortError",
        ScreenCaptureError: "AbortError",
        DeviceCaptureError: "AbortError"
      }[k.name] || k.name,
      message: k.message,
      constraint: k.constraint || k.constraintName,
      toString() {
        return this.name + (this.message && ": ") + this.message;
      }
    };
  }, _ = function(k, M, L) {
    v(k, (F) => {
      c.webkitGetUserMedia(F, M, (V) => {
        L && L(p(V));
      });
    });
  };
  if (c.getUserMedia = _.bind(c), c.mediaDevices.getUserMedia) {
    const k = c.mediaDevices.getUserMedia.bind(c.mediaDevices);
    c.mediaDevices.getUserMedia = function(M) {
      return v(M, (L) => k(L).then((F) => {
        if (L.audio && !F.getAudioTracks().length || L.video && !F.getVideoTracks().length)
          throw F.getTracks().forEach((V) => {
            V.stop();
          }), new DOMException("", "NotFoundError");
        return F;
      }, (F) => Promise.reject(p(F))));
    };
  }
}
function shimGetDisplayMedia$1(a, u) {
  if (!(a.navigator.mediaDevices && "getDisplayMedia" in a.navigator.mediaDevices) && a.navigator.mediaDevices) {
    if (typeof u != "function") {
      console.error("shimGetDisplayMedia: getSourceId argument is not a function");
      return;
    }
    a.navigator.mediaDevices.getDisplayMedia = function(l) {
      return u(l).then((v) => {
        const p = l.video && l.video.width, _ = l.video && l.video.height, k = l.video && l.video.frameRate;
        return l.video = {
          mandatory: {
            chromeMediaSource: "desktop",
            chromeMediaSourceId: v,
            maxFrameRate: k || 3
          }
        }, p && (l.video.mandatory.maxWidth = p), _ && (l.video.mandatory.maxHeight = _), a.navigator.mediaDevices.getUserMedia(l);
      });
    };
  }
}
function shimMediaStream(a) {
  a.MediaStream = a.MediaStream || a.webkitMediaStream;
}
function shimOnTrack$1(a) {
  if (typeof a == "object" && a.RTCPeerConnection && !("ontrack" in a.RTCPeerConnection.prototype)) {
    Object.defineProperty(a.RTCPeerConnection.prototype, "ontrack", {
      get() {
        return this._ontrack;
      },
      set(c) {
        this._ontrack && this.removeEventListener("track", this._ontrack), this.addEventListener("track", this._ontrack = c);
      },
      enumerable: !0,
      configurable: !0
    });
    const u = a.RTCPeerConnection.prototype.setRemoteDescription;
    a.RTCPeerConnection.prototype.setRemoteDescription = function() {
      return this._ontrackpoly || (this._ontrackpoly = (l) => {
        l.stream.addEventListener("addtrack", (v) => {
          let p;
          a.RTCPeerConnection.prototype.getReceivers ? p = this.getReceivers().find((k) => k.track && k.track.id === v.track.id) : p = {
            track: v.track
          };
          const _ = new Event("track");
          _.track = v.track, _.receiver = p, _.transceiver = {
            receiver: p
          }, _.streams = [l.stream], this.dispatchEvent(_);
        }), l.stream.getTracks().forEach((v) => {
          let p;
          a.RTCPeerConnection.prototype.getReceivers ? p = this.getReceivers().find((k) => k.track && k.track.id === v.id) : p = {
            track: v
          };
          const _ = new Event("track");
          _.track = v, _.receiver = p, _.transceiver = {
            receiver: p
          }, _.streams = [l.stream], this.dispatchEvent(_);
        });
      }, this.addEventListener("addstream", this._ontrackpoly)), u.apply(this, arguments);
    };
  } else
    wrapPeerConnectionEvent(a, "track", (u) => (u.transceiver || Object.defineProperty(u, "transceiver", {
      value: {
        receiver: u.receiver
      }
    }), u));
}
function shimGetSendersWithDtmf(a) {
  if (typeof a == "object" && a.RTCPeerConnection && !("getSenders" in a.RTCPeerConnection.prototype) && "createDTMFSender" in a.RTCPeerConnection.prototype) {
    const u = function(v, p) {
      return {
        track: p,
        get dtmf() {
          return this._dtmf === void 0 && (p.kind === "audio" ? this._dtmf = v.createDTMFSender(p) : this._dtmf = null), this._dtmf;
        },
        _pc: v
      };
    };
    if (!a.RTCPeerConnection.prototype.getSenders) {
      a.RTCPeerConnection.prototype.getSenders = function() {
        return this._senders = this._senders || [], this._senders.slice();
      };
      const v = a.RTCPeerConnection.prototype.addTrack;
      a.RTCPeerConnection.prototype.addTrack = function(k, M) {
        let L = v.apply(this, arguments);
        return L || (L = u(this, k), this._senders.push(L)), L;
      };
      const p = a.RTCPeerConnection.prototype.removeTrack;
      a.RTCPeerConnection.prototype.removeTrack = function(k) {
        p.apply(this, arguments);
        const M = this._senders.indexOf(k);
        M !== -1 && this._senders.splice(M, 1);
      };
    }
    const c = a.RTCPeerConnection.prototype.addStream;
    a.RTCPeerConnection.prototype.addStream = function(p) {
      this._senders = this._senders || [], c.apply(this, [p]), p.getTracks().forEach((_) => {
        this._senders.push(u(this, _));
      });
    };
    const l = a.RTCPeerConnection.prototype.removeStream;
    a.RTCPeerConnection.prototype.removeStream = function(p) {
      this._senders = this._senders || [], l.apply(this, [p]), p.getTracks().forEach((_) => {
        const k = this._senders.find((M) => M.track === _);
        k && this._senders.splice(this._senders.indexOf(k), 1);
      });
    };
  } else if (typeof a == "object" && a.RTCPeerConnection && "getSenders" in a.RTCPeerConnection.prototype && "createDTMFSender" in a.RTCPeerConnection.prototype && a.RTCRtpSender && !("dtmf" in a.RTCRtpSender.prototype)) {
    const u = a.RTCPeerConnection.prototype.getSenders;
    a.RTCPeerConnection.prototype.getSenders = function() {
      const l = u.apply(this, []);
      return l.forEach((v) => v._pc = this), l;
    }, Object.defineProperty(a.RTCRtpSender.prototype, "dtmf", {
      get() {
        return this._dtmf === void 0 && (this.track.kind === "audio" ? this._dtmf = this._pc.createDTMFSender(this.track) : this._dtmf = null), this._dtmf;
      }
    });
  }
}
function shimGetStats(a) {
  if (!a.RTCPeerConnection)
    return;
  const u = a.RTCPeerConnection.prototype.getStats;
  a.RTCPeerConnection.prototype.getStats = function() {
    const [l, v, p] = arguments;
    if (arguments.length > 0 && typeof l == "function")
      return u.apply(this, arguments);
    if (u.length === 0 && (arguments.length === 0 || typeof l != "function"))
      return u.apply(this, []);
    const _ = function(M) {
      const L = {};
      return M.result().forEach((V) => {
        const X = {
          id: V.id,
          timestamp: V.timestamp,
          type: {
            localcandidate: "local-candidate",
            remotecandidate: "remote-candidate"
          }[V.type] || V.type
        };
        V.names().forEach((oe) => {
          X[oe] = V.stat(oe);
        }), L[X.id] = X;
      }), L;
    }, k = function(M) {
      return new Map(Object.keys(M).map((L) => [L, M[L]]));
    };
    if (arguments.length >= 2) {
      const M = function(L) {
        v(k(_(L)));
      };
      return u.apply(this, [M, l]);
    }
    return new Promise((M, L) => {
      u.apply(this, [function(F) {
        M(k(_(F)));
      }, L]);
    }).then(v, p);
  };
}
function shimSenderReceiverGetStats(a) {
  if (!(typeof a == "object" && a.RTCPeerConnection && a.RTCRtpSender && a.RTCRtpReceiver))
    return;
  if (!("getStats" in a.RTCRtpSender.prototype)) {
    const c = a.RTCPeerConnection.prototype.getSenders;
    c && (a.RTCPeerConnection.prototype.getSenders = function() {
      const p = c.apply(this, []);
      return p.forEach((_) => _._pc = this), p;
    });
    const l = a.RTCPeerConnection.prototype.addTrack;
    l && (a.RTCPeerConnection.prototype.addTrack = function() {
      const p = l.apply(this, arguments);
      return p._pc = this, p;
    }), a.RTCRtpSender.prototype.getStats = function() {
      const p = this;
      return this._pc.getStats().then((_) => (
        /* Note: this will include stats of all senders that
         *   send a track with the same id as sender.track as
         *   it is not possible to identify the RTCRtpSender.
         */
        filterStats(_, p.track, !0)
      ));
    };
  }
  if (!("getStats" in a.RTCRtpReceiver.prototype)) {
    const c = a.RTCPeerConnection.prototype.getReceivers;
    c && (a.RTCPeerConnection.prototype.getReceivers = function() {
      const v = c.apply(this, []);
      return v.forEach((p) => p._pc = this), v;
    }), wrapPeerConnectionEvent(a, "track", (l) => (l.receiver._pc = l.srcElement, l)), a.RTCRtpReceiver.prototype.getStats = function() {
      const v = this;
      return this._pc.getStats().then((p) => filterStats(p, v.track, !1));
    };
  }
  if (!("getStats" in a.RTCRtpSender.prototype && "getStats" in a.RTCRtpReceiver.prototype))
    return;
  const u = a.RTCPeerConnection.prototype.getStats;
  a.RTCPeerConnection.prototype.getStats = function() {
    if (arguments.length > 0 && arguments[0] instanceof a.MediaStreamTrack) {
      const l = arguments[0];
      let v, p, _;
      return this.getSenders().forEach((k) => {
        k.track === l && (v ? _ = !0 : v = k);
      }), this.getReceivers().forEach((k) => (k.track === l && (p ? _ = !0 : p = k), k.track === l)), _ || v && p ? Promise.reject(new DOMException("There are more than one sender or receiver for the track.", "InvalidAccessError")) : v ? v.getStats() : p ? p.getStats() : Promise.reject(new DOMException("There is no sender or receiver for the track.", "InvalidAccessError"));
    }
    return u.apply(this, arguments);
  };
}
function shimAddTrackRemoveTrackWithNative(a) {
  a.RTCPeerConnection.prototype.getLocalStreams = function() {
    return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, Object.keys(this._shimmedLocalStreams).map((_) => this._shimmedLocalStreams[_][0]);
  };
  const u = a.RTCPeerConnection.prototype.addTrack;
  a.RTCPeerConnection.prototype.addTrack = function(_, k) {
    if (!k)
      return u.apply(this, arguments);
    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
    const M = u.apply(this, arguments);
    return this._shimmedLocalStreams[k.id] ? this._shimmedLocalStreams[k.id].indexOf(M) === -1 && this._shimmedLocalStreams[k.id].push(M) : this._shimmedLocalStreams[k.id] = [k, M], M;
  };
  const c = a.RTCPeerConnection.prototype.addStream;
  a.RTCPeerConnection.prototype.addStream = function(_) {
    this._shimmedLocalStreams = this._shimmedLocalStreams || {}, _.getTracks().forEach((L) => {
      if (this.getSenders().find((V) => V.track === L))
        throw new DOMException("Track already exists.", "InvalidAccessError");
    });
    const k = this.getSenders();
    c.apply(this, arguments);
    const M = this.getSenders().filter((L) => k.indexOf(L) === -1);
    this._shimmedLocalStreams[_.id] = [_].concat(M);
  };
  const l = a.RTCPeerConnection.prototype.removeStream;
  a.RTCPeerConnection.prototype.removeStream = function(_) {
    return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, delete this._shimmedLocalStreams[_.id], l.apply(this, arguments);
  };
  const v = a.RTCPeerConnection.prototype.removeTrack;
  a.RTCPeerConnection.prototype.removeTrack = function(_) {
    return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, _ && Object.keys(this._shimmedLocalStreams).forEach((k) => {
      const M = this._shimmedLocalStreams[k].indexOf(_);
      M !== -1 && this._shimmedLocalStreams[k].splice(M, 1), this._shimmedLocalStreams[k].length === 1 && delete this._shimmedLocalStreams[k];
    }), v.apply(this, arguments);
  };
}
function shimAddTrackRemoveTrack(a, u) {
  if (!a.RTCPeerConnection)
    return;
  if (a.RTCPeerConnection.prototype.addTrack && u.version >= 65)
    return shimAddTrackRemoveTrackWithNative(a);
  const c = a.RTCPeerConnection.prototype.getLocalStreams;
  a.RTCPeerConnection.prototype.getLocalStreams = function() {
    const F = c.apply(this);
    return this._reverseStreams = this._reverseStreams || {}, F.map((V) => this._reverseStreams[V.id]);
  };
  const l = a.RTCPeerConnection.prototype.addStream;
  a.RTCPeerConnection.prototype.addStream = function(F) {
    if (this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, F.getTracks().forEach((V) => {
      if (this.getSenders().find((oe) => oe.track === V))
        throw new DOMException("Track already exists.", "InvalidAccessError");
    }), !this._reverseStreams[F.id]) {
      const V = new a.MediaStream(F.getTracks());
      this._streams[F.id] = V, this._reverseStreams[V.id] = F, F = V;
    }
    l.apply(this, [F]);
  };
  const v = a.RTCPeerConnection.prototype.removeStream;
  a.RTCPeerConnection.prototype.removeStream = function(F) {
    this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, v.apply(this, [this._streams[F.id] || F]), delete this._reverseStreams[this._streams[F.id] ? this._streams[F.id].id : F.id], delete this._streams[F.id];
  }, a.RTCPeerConnection.prototype.addTrack = function(F, V) {
    if (this.signalingState === "closed")
      throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
    const X = [].slice.call(arguments, 1);
    if (X.length !== 1 || !X[0].getTracks().find((ae) => ae === F))
      throw new DOMException("The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.", "NotSupportedError");
    if (this.getSenders().find((ae) => ae.track === F))
      throw new DOMException("Track already exists.", "InvalidAccessError");
    this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {};
    const Y = this._streams[V.id];
    if (Y)
      Y.addTrack(F), Promise.resolve().then(() => {
        this.dispatchEvent(new Event("negotiationneeded"));
      });
    else {
      const ae = new a.MediaStream([F]);
      this._streams[V.id] = ae, this._reverseStreams[ae.id] = V, this.addStream(ae);
    }
    return this.getSenders().find((ae) => ae.track === F);
  };
  function p(L, F) {
    let V = F.sdp;
    return Object.keys(L._reverseStreams || []).forEach((X) => {
      const oe = L._reverseStreams[X], Y = L._streams[oe.id];
      V = V.replace(new RegExp(Y.id, "g"), oe.id);
    }), new RTCSessionDescription({
      type: F.type,
      sdp: V
    });
  }
  function _(L, F) {
    let V = F.sdp;
    return Object.keys(L._reverseStreams || []).forEach((X) => {
      const oe = L._reverseStreams[X], Y = L._streams[oe.id];
      V = V.replace(new RegExp(oe.id, "g"), Y.id);
    }), new RTCSessionDescription({
      type: F.type,
      sdp: V
    });
  }
  ["createOffer", "createAnswer"].forEach(function(L) {
    const F = a.RTCPeerConnection.prototype[L], V = {
      [L]() {
        const X = arguments;
        return arguments.length && typeof arguments[0] == "function" ? F.apply(this, [(Y) => {
          const ae = p(this, Y);
          X[0].apply(null, [ae]);
        }, (Y) => {
          X[1] && X[1].apply(null, Y);
        }, arguments[2]]) : F.apply(this, arguments).then((Y) => p(this, Y));
      }
    };
    a.RTCPeerConnection.prototype[L] = V[L];
  });
  const k = a.RTCPeerConnection.prototype.setLocalDescription;
  a.RTCPeerConnection.prototype.setLocalDescription = function() {
    return !arguments.length || !arguments[0].type ? k.apply(this, arguments) : (arguments[0] = _(this, arguments[0]), k.apply(this, arguments));
  };
  const M = Object.getOwnPropertyDescriptor(a.RTCPeerConnection.prototype, "localDescription");
  Object.defineProperty(a.RTCPeerConnection.prototype, "localDescription", {
    get() {
      const L = M.get.apply(this);
      return L.type === "" ? L : p(this, L);
    }
  }), a.RTCPeerConnection.prototype.removeTrack = function(F) {
    if (this.signalingState === "closed")
      throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
    if (!F._pc)
      throw new DOMException("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.", "TypeError");
    if (!(F._pc === this))
      throw new DOMException("Sender was not created by this connection.", "InvalidAccessError");
    this._streams = this._streams || {};
    let X;
    Object.keys(this._streams).forEach((oe) => {
      this._streams[oe].getTracks().find((ae) => F.track === ae) && (X = this._streams[oe]);
    }), X && (X.getTracks().length === 1 ? this.removeStream(this._reverseStreams[X.id]) : X.removeTrack(F.track), this.dispatchEvent(new Event("negotiationneeded")));
  };
}
function shimPeerConnection$1(a, u) {
  !a.RTCPeerConnection && a.webkitRTCPeerConnection && (a.RTCPeerConnection = a.webkitRTCPeerConnection), a.RTCPeerConnection && u.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(c) {
    const l = a.RTCPeerConnection.prototype[c], v = {
      [c]() {
        return arguments[0] = new (c === "addIceCandidate" ? a.RTCIceCandidate : a.RTCSessionDescription)(arguments[0]), l.apply(this, arguments);
      }
    };
    a.RTCPeerConnection.prototype[c] = v[c];
  });
}
function fixNegotiationNeeded(a, u) {
  wrapPeerConnectionEvent(a, "negotiationneeded", (c) => {
    const l = c.target;
    if (!((u.version < 72 || l.getConfiguration && l.getConfiguration().sdpSemantics === "plan-b") && l.signalingState !== "stable"))
      return c;
  });
}
var chromeShim = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  fixNegotiationNeeded,
  shimAddTrackRemoveTrack,
  shimAddTrackRemoveTrackWithNative,
  shimGetDisplayMedia: shimGetDisplayMedia$1,
  shimGetSendersWithDtmf,
  shimGetStats,
  shimGetUserMedia: shimGetUserMedia$2,
  shimMediaStream,
  shimOnTrack: shimOnTrack$1,
  shimPeerConnection: shimPeerConnection$1,
  shimSenderReceiverGetStats
});
function shimGetUserMedia$1(a, u) {
  const c = a && a.navigator, l = a && a.MediaStreamTrack;
  if (c.getUserMedia = function(v, p, _) {
    deprecated("navigator.getUserMedia", "navigator.mediaDevices.getUserMedia"), c.mediaDevices.getUserMedia(v).then(p, _);
  }, !(u.version > 55 && "autoGainControl" in c.mediaDevices.getSupportedConstraints())) {
    const v = function(_, k, M) {
      k in _ && !(M in _) && (_[M] = _[k], delete _[k]);
    }, p = c.mediaDevices.getUserMedia.bind(c.mediaDevices);
    if (c.mediaDevices.getUserMedia = function(_) {
      return typeof _ == "object" && typeof _.audio == "object" && (_ = JSON.parse(JSON.stringify(_)), v(_.audio, "autoGainControl", "mozAutoGainControl"), v(_.audio, "noiseSuppression", "mozNoiseSuppression")), p(_);
    }, l && l.prototype.getSettings) {
      const _ = l.prototype.getSettings;
      l.prototype.getSettings = function() {
        const k = _.apply(this, arguments);
        return v(k, "mozAutoGainControl", "autoGainControl"), v(k, "mozNoiseSuppression", "noiseSuppression"), k;
      };
    }
    if (l && l.prototype.applyConstraints) {
      const _ = l.prototype.applyConstraints;
      l.prototype.applyConstraints = function(k) {
        return this.kind === "audio" && typeof k == "object" && (k = JSON.parse(JSON.stringify(k)), v(k, "autoGainControl", "mozAutoGainControl"), v(k, "noiseSuppression", "mozNoiseSuppression")), _.apply(this, [k]);
      };
    }
  }
}
function shimGetDisplayMedia(a, u) {
  a.navigator.mediaDevices && "getDisplayMedia" in a.navigator.mediaDevices || a.navigator.mediaDevices && (a.navigator.mediaDevices.getDisplayMedia = function(l) {
    if (!(l && l.video)) {
      const v = new DOMException("getDisplayMedia without video constraints is undefined");
      return v.name = "NotFoundError", v.code = 8, Promise.reject(v);
    }
    return l.video === !0 ? l.video = {
      mediaSource: u
    } : l.video.mediaSource = u, a.navigator.mediaDevices.getUserMedia(l);
  });
}
function shimOnTrack(a) {
  typeof a == "object" && a.RTCTrackEvent && "receiver" in a.RTCTrackEvent.prototype && !("transceiver" in a.RTCTrackEvent.prototype) && Object.defineProperty(a.RTCTrackEvent.prototype, "transceiver", {
    get() {
      return {
        receiver: this.receiver
      };
    }
  });
}
function shimPeerConnection(a, u) {
  if (typeof a != "object" || !(a.RTCPeerConnection || a.mozRTCPeerConnection))
    return;
  !a.RTCPeerConnection && a.mozRTCPeerConnection && (a.RTCPeerConnection = a.mozRTCPeerConnection), u.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(v) {
    const p = a.RTCPeerConnection.prototype[v], _ = {
      [v]() {
        return arguments[0] = new (v === "addIceCandidate" ? a.RTCIceCandidate : a.RTCSessionDescription)(arguments[0]), p.apply(this, arguments);
      }
    };
    a.RTCPeerConnection.prototype[v] = _[v];
  });
  const c = {
    inboundrtp: "inbound-rtp",
    outboundrtp: "outbound-rtp",
    candidatepair: "candidate-pair",
    localcandidate: "local-candidate",
    remotecandidate: "remote-candidate"
  }, l = a.RTCPeerConnection.prototype.getStats;
  a.RTCPeerConnection.prototype.getStats = function() {
    const [p, _, k] = arguments;
    return l.apply(this, [p || null]).then((M) => {
      if (u.version < 53 && !_)
        try {
          M.forEach((L) => {
            L.type = c[L.type] || L.type;
          });
        } catch (L) {
          if (L.name !== "TypeError")
            throw L;
          M.forEach((F, V) => {
            M.set(V, Object.assign({}, F, {
              type: c[F.type] || F.type
            }));
          });
        }
      return M;
    }).then(_, k);
  };
}
function shimSenderGetStats(a) {
  if (!(typeof a == "object" && a.RTCPeerConnection && a.RTCRtpSender) || a.RTCRtpSender && "getStats" in a.RTCRtpSender.prototype)
    return;
  const u = a.RTCPeerConnection.prototype.getSenders;
  u && (a.RTCPeerConnection.prototype.getSenders = function() {
    const v = u.apply(this, []);
    return v.forEach((p) => p._pc = this), v;
  });
  const c = a.RTCPeerConnection.prototype.addTrack;
  c && (a.RTCPeerConnection.prototype.addTrack = function() {
    const v = c.apply(this, arguments);
    return v._pc = this, v;
  }), a.RTCRtpSender.prototype.getStats = function() {
    return this.track ? this._pc.getStats(this.track) : Promise.resolve(/* @__PURE__ */ new Map());
  };
}
function shimReceiverGetStats(a) {
  if (!(typeof a == "object" && a.RTCPeerConnection && a.RTCRtpSender) || a.RTCRtpSender && "getStats" in a.RTCRtpReceiver.prototype)
    return;
  const u = a.RTCPeerConnection.prototype.getReceivers;
  u && (a.RTCPeerConnection.prototype.getReceivers = function() {
    const l = u.apply(this, []);
    return l.forEach((v) => v._pc = this), l;
  }), wrapPeerConnectionEvent(a, "track", (c) => (c.receiver._pc = c.srcElement, c)), a.RTCRtpReceiver.prototype.getStats = function() {
    return this._pc.getStats(this.track);
  };
}
function shimRemoveStream(a) {
  !a.RTCPeerConnection || "removeStream" in a.RTCPeerConnection.prototype || (a.RTCPeerConnection.prototype.removeStream = function(c) {
    deprecated("removeStream", "removeTrack"), this.getSenders().forEach((l) => {
      l.track && c.getTracks().includes(l.track) && this.removeTrack(l);
    });
  });
}
function shimRTCDataChannel(a) {
  a.DataChannel && !a.RTCDataChannel && (a.RTCDataChannel = a.DataChannel);
}
function shimAddTransceiver(a) {
  if (!(typeof a == "object" && a.RTCPeerConnection))
    return;
  const u = a.RTCPeerConnection.prototype.addTransceiver;
  u && (a.RTCPeerConnection.prototype.addTransceiver = function() {
    this.setParametersPromises = [];
    let l = arguments[1] && arguments[1].sendEncodings;
    l === void 0 && (l = []), l = [...l];
    const v = l.length > 0;
    v && l.forEach((_) => {
      if ("rid" in _ && !/^[a-z0-9]{0,16}$/i.test(_.rid))
        throw new TypeError("Invalid RID value provided.");
      if ("scaleResolutionDownBy" in _ && !(parseFloat(_.scaleResolutionDownBy) >= 1))
        throw new RangeError("scale_resolution_down_by must be >= 1.0");
      if ("maxFramerate" in _ && !(parseFloat(_.maxFramerate) >= 0))
        throw new RangeError("max_framerate must be >= 0.0");
    });
    const p = u.apply(this, arguments);
    if (v) {
      const {
        sender: _
      } = p, k = _.getParameters();
      (!("encodings" in k) || // Avoid being fooled by patched getParameters() below.
      k.encodings.length === 1 && Object.keys(k.encodings[0]).length === 0) && (k.encodings = l, _.sendEncodings = l, this.setParametersPromises.push(_.setParameters(k).then(() => {
        delete _.sendEncodings;
      }).catch(() => {
        delete _.sendEncodings;
      })));
    }
    return p;
  });
}
function shimGetParameters(a) {
  if (!(typeof a == "object" && a.RTCRtpSender))
    return;
  const u = a.RTCRtpSender.prototype.getParameters;
  u && (a.RTCRtpSender.prototype.getParameters = function() {
    const l = u.apply(this, arguments);
    return "encodings" in l || (l.encodings = [].concat(this.sendEncodings || [{}])), l;
  });
}
function shimCreateOffer(a) {
  if (!(typeof a == "object" && a.RTCPeerConnection))
    return;
  const u = a.RTCPeerConnection.prototype.createOffer;
  a.RTCPeerConnection.prototype.createOffer = function() {
    return this.setParametersPromises && this.setParametersPromises.length ? Promise.all(this.setParametersPromises).then(() => u.apply(this, arguments)).finally(() => {
      this.setParametersPromises = [];
    }) : u.apply(this, arguments);
  };
}
function shimCreateAnswer(a) {
  if (!(typeof a == "object" && a.RTCPeerConnection))
    return;
  const u = a.RTCPeerConnection.prototype.createAnswer;
  a.RTCPeerConnection.prototype.createAnswer = function() {
    return this.setParametersPromises && this.setParametersPromises.length ? Promise.all(this.setParametersPromises).then(() => u.apply(this, arguments)).finally(() => {
      this.setParametersPromises = [];
    }) : u.apply(this, arguments);
  };
}
var firefoxShim = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  shimAddTransceiver,
  shimCreateAnswer,
  shimCreateOffer,
  shimGetDisplayMedia,
  shimGetParameters,
  shimGetUserMedia: shimGetUserMedia$1,
  shimOnTrack,
  shimPeerConnection,
  shimRTCDataChannel,
  shimReceiverGetStats,
  shimRemoveStream,
  shimSenderGetStats
});
function shimLocalStreamsAPI(a) {
  if (!(typeof a != "object" || !a.RTCPeerConnection)) {
    if ("getLocalStreams" in a.RTCPeerConnection.prototype || (a.RTCPeerConnection.prototype.getLocalStreams = function() {
      return this._localStreams || (this._localStreams = []), this._localStreams;
    }), !("addStream" in a.RTCPeerConnection.prototype)) {
      const u = a.RTCPeerConnection.prototype.addTrack;
      a.RTCPeerConnection.prototype.addStream = function(l) {
        this._localStreams || (this._localStreams = []), this._localStreams.includes(l) || this._localStreams.push(l), l.getAudioTracks().forEach((v) => u.call(this, v, l)), l.getVideoTracks().forEach((v) => u.call(this, v, l));
      }, a.RTCPeerConnection.prototype.addTrack = function(l) {
        for (var v = arguments.length, p = new Array(v > 1 ? v - 1 : 0), _ = 1; _ < v; _++)
          p[_ - 1] = arguments[_];
        return p && p.forEach((k) => {
          this._localStreams ? this._localStreams.includes(k) || this._localStreams.push(k) : this._localStreams = [k];
        }), u.apply(this, arguments);
      };
    }
    "removeStream" in a.RTCPeerConnection.prototype || (a.RTCPeerConnection.prototype.removeStream = function(c) {
      this._localStreams || (this._localStreams = []);
      const l = this._localStreams.indexOf(c);
      if (l === -1)
        return;
      this._localStreams.splice(l, 1);
      const v = c.getTracks();
      this.getSenders().forEach((p) => {
        v.includes(p.track) && this.removeTrack(p);
      });
    });
  }
}
function shimRemoteStreamsAPI(a) {
  if (!(typeof a != "object" || !a.RTCPeerConnection) && ("getRemoteStreams" in a.RTCPeerConnection.prototype || (a.RTCPeerConnection.prototype.getRemoteStreams = function() {
    return this._remoteStreams ? this._remoteStreams : [];
  }), !("onaddstream" in a.RTCPeerConnection.prototype))) {
    Object.defineProperty(a.RTCPeerConnection.prototype, "onaddstream", {
      get() {
        return this._onaddstream;
      },
      set(c) {
        this._onaddstream && (this.removeEventListener("addstream", this._onaddstream), this.removeEventListener("track", this._onaddstreampoly)), this.addEventListener("addstream", this._onaddstream = c), this.addEventListener("track", this._onaddstreampoly = (l) => {
          l.streams.forEach((v) => {
            if (this._remoteStreams || (this._remoteStreams = []), this._remoteStreams.includes(v))
              return;
            this._remoteStreams.push(v);
            const p = new Event("addstream");
            p.stream = v, this.dispatchEvent(p);
          });
        });
      }
    });
    const u = a.RTCPeerConnection.prototype.setRemoteDescription;
    a.RTCPeerConnection.prototype.setRemoteDescription = function() {
      const l = this;
      return this._onaddstreampoly || this.addEventListener("track", this._onaddstreampoly = function(v) {
        v.streams.forEach((p) => {
          if (l._remoteStreams || (l._remoteStreams = []), l._remoteStreams.indexOf(p) >= 0)
            return;
          l._remoteStreams.push(p);
          const _ = new Event("addstream");
          _.stream = p, l.dispatchEvent(_);
        });
      }), u.apply(l, arguments);
    };
  }
}
function shimCallbacksAPI(a) {
  if (typeof a != "object" || !a.RTCPeerConnection)
    return;
  const u = a.RTCPeerConnection.prototype, c = u.createOffer, l = u.createAnswer, v = u.setLocalDescription, p = u.setRemoteDescription, _ = u.addIceCandidate;
  u.createOffer = function(L, F) {
    const V = arguments.length >= 2 ? arguments[2] : arguments[0], X = c.apply(this, [V]);
    return F ? (X.then(L, F), Promise.resolve()) : X;
  }, u.createAnswer = function(L, F) {
    const V = arguments.length >= 2 ? arguments[2] : arguments[0], X = l.apply(this, [V]);
    return F ? (X.then(L, F), Promise.resolve()) : X;
  };
  let k = function(M, L, F) {
    const V = v.apply(this, [M]);
    return F ? (V.then(L, F), Promise.resolve()) : V;
  };
  u.setLocalDescription = k, k = function(M, L, F) {
    const V = p.apply(this, [M]);
    return F ? (V.then(L, F), Promise.resolve()) : V;
  }, u.setRemoteDescription = k, k = function(M, L, F) {
    const V = _.apply(this, [M]);
    return F ? (V.then(L, F), Promise.resolve()) : V;
  }, u.addIceCandidate = k;
}
function shimGetUserMedia(a) {
  const u = a && a.navigator;
  if (u.mediaDevices && u.mediaDevices.getUserMedia) {
    const c = u.mediaDevices, l = c.getUserMedia.bind(c);
    u.mediaDevices.getUserMedia = (v) => l(shimConstraints(v));
  }
  !u.getUserMedia && u.mediaDevices && u.mediaDevices.getUserMedia && (u.getUserMedia = (function(l, v, p) {
    u.mediaDevices.getUserMedia(l).then(v, p);
  }).bind(u));
}
function shimConstraints(a) {
  return a && a.video !== void 0 ? Object.assign({}, a, {
    video: compactObject(a.video)
  }) : a;
}
function shimRTCIceServerUrls(a) {
  if (!a.RTCPeerConnection)
    return;
  const u = a.RTCPeerConnection;
  a.RTCPeerConnection = function(l, v) {
    if (l && l.iceServers) {
      const p = [];
      for (let _ = 0; _ < l.iceServers.length; _++) {
        let k = l.iceServers[_];
        k.urls === void 0 && k.url ? (deprecated("RTCIceServer.url", "RTCIceServer.urls"), k = JSON.parse(JSON.stringify(k)), k.urls = k.url, delete k.url, p.push(k)) : p.push(l.iceServers[_]);
      }
      l.iceServers = p;
    }
    return new u(l, v);
  }, a.RTCPeerConnection.prototype = u.prototype, "generateCertificate" in u && Object.defineProperty(a.RTCPeerConnection, "generateCertificate", {
    get() {
      return u.generateCertificate;
    }
  });
}
function shimTrackEventTransceiver(a) {
  typeof a == "object" && a.RTCTrackEvent && "receiver" in a.RTCTrackEvent.prototype && !("transceiver" in a.RTCTrackEvent.prototype) && Object.defineProperty(a.RTCTrackEvent.prototype, "transceiver", {
    get() {
      return {
        receiver: this.receiver
      };
    }
  });
}
function shimCreateOfferLegacy(a) {
  const u = a.RTCPeerConnection.prototype.createOffer;
  a.RTCPeerConnection.prototype.createOffer = function(l) {
    if (l) {
      typeof l.offerToReceiveAudio < "u" && (l.offerToReceiveAudio = !!l.offerToReceiveAudio);
      const v = this.getTransceivers().find((_) => _.receiver.track.kind === "audio");
      l.offerToReceiveAudio === !1 && v ? v.direction === "sendrecv" ? v.setDirection ? v.setDirection("sendonly") : v.direction = "sendonly" : v.direction === "recvonly" && (v.setDirection ? v.setDirection("inactive") : v.direction = "inactive") : l.offerToReceiveAudio === !0 && !v && this.addTransceiver("audio", {
        direction: "recvonly"
      }), typeof l.offerToReceiveVideo < "u" && (l.offerToReceiveVideo = !!l.offerToReceiveVideo);
      const p = this.getTransceivers().find((_) => _.receiver.track.kind === "video");
      l.offerToReceiveVideo === !1 && p ? p.direction === "sendrecv" ? p.setDirection ? p.setDirection("sendonly") : p.direction = "sendonly" : p.direction === "recvonly" && (p.setDirection ? p.setDirection("inactive") : p.direction = "inactive") : l.offerToReceiveVideo === !0 && !p && this.addTransceiver("video", {
        direction: "recvonly"
      });
    }
    return u.apply(this, arguments);
  };
}
function shimAudioContext(a) {
  typeof a != "object" || a.AudioContext || (a.AudioContext = a.webkitAudioContext);
}
var safariShim = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  shimAudioContext,
  shimCallbacksAPI,
  shimConstraints,
  shimCreateOfferLegacy,
  shimGetUserMedia,
  shimLocalStreamsAPI,
  shimRTCIceServerUrls,
  shimRemoteStreamsAPI,
  shimTrackEventTransceiver
}), sdp$1 = { exports: {} };
(function(a) {
  const u = {};
  u.generateIdentifier = function() {
    return Math.random().toString(36).substring(2, 12);
  }, u.localCName = u.generateIdentifier(), u.splitLines = function(c) {
    return c.trim().split(`
`).map((l) => l.trim());
  }, u.splitSections = function(c) {
    return c.split(`
m=`).map((v, p) => (p > 0 ? "m=" + v : v).trim() + `\r
`);
  }, u.getDescription = function(c) {
    const l = u.splitSections(c);
    return l && l[0];
  }, u.getMediaSections = function(c) {
    const l = u.splitSections(c);
    return l.shift(), l;
  }, u.matchPrefix = function(c, l) {
    return u.splitLines(c).filter((v) => v.indexOf(l) === 0);
  }, u.parseCandidate = function(c) {
    let l;
    c.indexOf("a=candidate:") === 0 ? l = c.substring(12).split(" ") : l = c.substring(10).split(" ");
    const v = {
      foundation: l[0],
      component: {
        1: "rtp",
        2: "rtcp"
      }[l[1]] || l[1],
      protocol: l[2].toLowerCase(),
      priority: parseInt(l[3], 10),
      ip: l[4],
      address: l[4],
      // address is an alias for ip.
      port: parseInt(l[5], 10),
      // skip parts[6] == 'typ'
      type: l[7]
    };
    for (let p = 8; p < l.length; p += 2)
      switch (l[p]) {
        case "raddr":
          v.relatedAddress = l[p + 1];
          break;
        case "rport":
          v.relatedPort = parseInt(l[p + 1], 10);
          break;
        case "tcptype":
          v.tcpType = l[p + 1];
          break;
        case "ufrag":
          v.ufrag = l[p + 1], v.usernameFragment = l[p + 1];
          break;
        default:
          v[l[p]] === void 0 && (v[l[p]] = l[p + 1]);
          break;
      }
    return v;
  }, u.writeCandidate = function(c) {
    const l = [];
    l.push(c.foundation);
    const v = c.component;
    v === "rtp" ? l.push(1) : v === "rtcp" ? l.push(2) : l.push(v), l.push(c.protocol.toUpperCase()), l.push(c.priority), l.push(c.address || c.ip), l.push(c.port);
    const p = c.type;
    return l.push("typ"), l.push(p), p !== "host" && c.relatedAddress && c.relatedPort && (l.push("raddr"), l.push(c.relatedAddress), l.push("rport"), l.push(c.relatedPort)), c.tcpType && c.protocol.toLowerCase() === "tcp" && (l.push("tcptype"), l.push(c.tcpType)), (c.usernameFragment || c.ufrag) && (l.push("ufrag"), l.push(c.usernameFragment || c.ufrag)), "candidate:" + l.join(" ");
  }, u.parseIceOptions = function(c) {
    return c.substring(14).split(" ");
  }, u.parseRtpMap = function(c) {
    let l = c.substring(9).split(" ");
    const v = {
      payloadType: parseInt(l.shift(), 10)
      // was: id
    };
    return l = l[0].split("/"), v.name = l[0], v.clockRate = parseInt(l[1], 10), v.channels = l.length === 3 ? parseInt(l[2], 10) : 1, v.numChannels = v.channels, v;
  }, u.writeRtpMap = function(c) {
    let l = c.payloadType;
    c.preferredPayloadType !== void 0 && (l = c.preferredPayloadType);
    const v = c.channels || c.numChannels || 1;
    return "a=rtpmap:" + l + " " + c.name + "/" + c.clockRate + (v !== 1 ? "/" + v : "") + `\r
`;
  }, u.parseExtmap = function(c) {
    const l = c.substring(9).split(" ");
    return {
      id: parseInt(l[0], 10),
      direction: l[0].indexOf("/") > 0 ? l[0].split("/")[1] : "sendrecv",
      uri: l[1],
      attributes: l.slice(2).join(" ")
    };
  }, u.writeExtmap = function(c) {
    return "a=extmap:" + (c.id || c.preferredId) + (c.direction && c.direction !== "sendrecv" ? "/" + c.direction : "") + " " + c.uri + (c.attributes ? " " + c.attributes : "") + `\r
`;
  }, u.parseFmtp = function(c) {
    const l = {};
    let v;
    const p = c.substring(c.indexOf(" ") + 1).split(";");
    for (let _ = 0; _ < p.length; _++)
      v = p[_].trim().split("="), l[v[0].trim()] = v[1];
    return l;
  }, u.writeFmtp = function(c) {
    let l = "", v = c.payloadType;
    if (c.preferredPayloadType !== void 0 && (v = c.preferredPayloadType), c.parameters && Object.keys(c.parameters).length) {
      const p = [];
      Object.keys(c.parameters).forEach((_) => {
        c.parameters[_] !== void 0 ? p.push(_ + "=" + c.parameters[_]) : p.push(_);
      }), l += "a=fmtp:" + v + " " + p.join(";") + `\r
`;
    }
    return l;
  }, u.parseRtcpFb = function(c) {
    const l = c.substring(c.indexOf(" ") + 1).split(" ");
    return {
      type: l.shift(),
      parameter: l.join(" ")
    };
  }, u.writeRtcpFb = function(c) {
    let l = "", v = c.payloadType;
    return c.preferredPayloadType !== void 0 && (v = c.preferredPayloadType), c.rtcpFeedback && c.rtcpFeedback.length && c.rtcpFeedback.forEach((p) => {
      l += "a=rtcp-fb:" + v + " " + p.type + (p.parameter && p.parameter.length ? " " + p.parameter : "") + `\r
`;
    }), l;
  }, u.parseSsrcMedia = function(c) {
    const l = c.indexOf(" "), v = {
      ssrc: parseInt(c.substring(7, l), 10)
    }, p = c.indexOf(":", l);
    return p > -1 ? (v.attribute = c.substring(l + 1, p), v.value = c.substring(p + 1)) : v.attribute = c.substring(l + 1), v;
  }, u.parseSsrcGroup = function(c) {
    const l = c.substring(13).split(" ");
    return {
      semantics: l.shift(),
      ssrcs: l.map((v) => parseInt(v, 10))
    };
  }, u.getMid = function(c) {
    const l = u.matchPrefix(c, "a=mid:")[0];
    if (l)
      return l.substring(6);
  }, u.parseFingerprint = function(c) {
    const l = c.substring(14).split(" ");
    return {
      algorithm: l[0].toLowerCase(),
      // algorithm is case-sensitive in Edge.
      value: l[1].toUpperCase()
      // the definition is upper-case in RFC 4572.
    };
  }, u.getDtlsParameters = function(c, l) {
    return {
      role: "auto",
      fingerprints: u.matchPrefix(c + l, "a=fingerprint:").map(u.parseFingerprint)
    };
  }, u.writeDtlsParameters = function(c, l) {
    let v = "a=setup:" + l + `\r
`;
    return c.fingerprints.forEach((p) => {
      v += "a=fingerprint:" + p.algorithm + " " + p.value + `\r
`;
    }), v;
  }, u.parseCryptoLine = function(c) {
    const l = c.substring(9).split(" ");
    return {
      tag: parseInt(l[0], 10),
      cryptoSuite: l[1],
      keyParams: l[2],
      sessionParams: l.slice(3)
    };
  }, u.writeCryptoLine = function(c) {
    return "a=crypto:" + c.tag + " " + c.cryptoSuite + " " + (typeof c.keyParams == "object" ? u.writeCryptoKeyParams(c.keyParams) : c.keyParams) + (c.sessionParams ? " " + c.sessionParams.join(" ") : "") + `\r
`;
  }, u.parseCryptoKeyParams = function(c) {
    if (c.indexOf("inline:") !== 0)
      return null;
    const l = c.substring(7).split("|");
    return {
      keyMethod: "inline",
      keySalt: l[0],
      lifeTime: l[1],
      mkiValue: l[2] ? l[2].split(":")[0] : void 0,
      mkiLength: l[2] ? l[2].split(":")[1] : void 0
    };
  }, u.writeCryptoKeyParams = function(c) {
    return c.keyMethod + ":" + c.keySalt + (c.lifeTime ? "|" + c.lifeTime : "") + (c.mkiValue && c.mkiLength ? "|" + c.mkiValue + ":" + c.mkiLength : "");
  }, u.getCryptoParameters = function(c, l) {
    return u.matchPrefix(c + l, "a=crypto:").map(u.parseCryptoLine);
  }, u.getIceParameters = function(c, l) {
    const v = u.matchPrefix(c + l, "a=ice-ufrag:")[0], p = u.matchPrefix(c + l, "a=ice-pwd:")[0];
    return v && p ? {
      usernameFragment: v.substring(12),
      password: p.substring(10)
    } : null;
  }, u.writeIceParameters = function(c) {
    let l = "a=ice-ufrag:" + c.usernameFragment + `\r
a=ice-pwd:` + c.password + `\r
`;
    return c.iceLite && (l += `a=ice-lite\r
`), l;
  }, u.parseRtpParameters = function(c) {
    const l = {
      codecs: [],
      headerExtensions: [],
      fecMechanisms: [],
      rtcp: []
    }, p = u.splitLines(c)[0].split(" ");
    l.profile = p[2];
    for (let k = 3; k < p.length; k++) {
      const M = p[k], L = u.matchPrefix(c, "a=rtpmap:" + M + " ")[0];
      if (L) {
        const F = u.parseRtpMap(L), V = u.matchPrefix(c, "a=fmtp:" + M + " ");
        switch (F.parameters = V.length ? u.parseFmtp(V[0]) : {}, F.rtcpFeedback = u.matchPrefix(c, "a=rtcp-fb:" + M + " ").map(u.parseRtcpFb), l.codecs.push(F), F.name.toUpperCase()) {
          case "RED":
          case "ULPFEC":
            l.fecMechanisms.push(F.name.toUpperCase());
            break;
        }
      }
    }
    u.matchPrefix(c, "a=extmap:").forEach((k) => {
      l.headerExtensions.push(u.parseExtmap(k));
    });
    const _ = u.matchPrefix(c, "a=rtcp-fb:* ").map(u.parseRtcpFb);
    return l.codecs.forEach((k) => {
      _.forEach((M) => {
        k.rtcpFeedback.find((F) => F.type === M.type && F.parameter === M.parameter) || k.rtcpFeedback.push(M);
      });
    }), l;
  }, u.writeRtpDescription = function(c, l) {
    let v = "";
    v += "m=" + c + " ", v += l.codecs.length > 0 ? "9" : "0", v += " " + (l.profile || "UDP/TLS/RTP/SAVPF") + " ", v += l.codecs.map((_) => _.preferredPayloadType !== void 0 ? _.preferredPayloadType : _.payloadType).join(" ") + `\r
`, v += `c=IN IP4 0.0.0.0\r
`, v += `a=rtcp:9 IN IP4 0.0.0.0\r
`, l.codecs.forEach((_) => {
      v += u.writeRtpMap(_), v += u.writeFmtp(_), v += u.writeRtcpFb(_);
    });
    let p = 0;
    return l.codecs.forEach((_) => {
      _.maxptime > p && (p = _.maxptime);
    }), p > 0 && (v += "a=maxptime:" + p + `\r
`), l.headerExtensions && l.headerExtensions.forEach((_) => {
      v += u.writeExtmap(_);
    }), v;
  }, u.parseRtpEncodingParameters = function(c) {
    const l = [], v = u.parseRtpParameters(c), p = v.fecMechanisms.indexOf("RED") !== -1, _ = v.fecMechanisms.indexOf("ULPFEC") !== -1, k = u.matchPrefix(c, "a=ssrc:").map((X) => u.parseSsrcMedia(X)).filter((X) => X.attribute === "cname"), M = k.length > 0 && k[0].ssrc;
    let L;
    const F = u.matchPrefix(c, "a=ssrc-group:FID").map((X) => X.substring(17).split(" ").map((Y) => parseInt(Y, 10)));
    F.length > 0 && F[0].length > 1 && F[0][0] === M && (L = F[0][1]), v.codecs.forEach((X) => {
      if (X.name.toUpperCase() === "RTX" && X.parameters.apt) {
        let oe = {
          ssrc: M,
          codecPayloadType: parseInt(X.parameters.apt, 10)
        };
        M && L && (oe.rtx = {
          ssrc: L
        }), l.push(oe), p && (oe = JSON.parse(JSON.stringify(oe)), oe.fec = {
          ssrc: M,
          mechanism: _ ? "red+ulpfec" : "red"
        }, l.push(oe));
      }
    }), l.length === 0 && M && l.push({
      ssrc: M
    });
    let V = u.matchPrefix(c, "b=");
    return V.length && (V[0].indexOf("b=TIAS:") === 0 ? V = parseInt(V[0].substring(7), 10) : V[0].indexOf("b=AS:") === 0 ? V = parseInt(V[0].substring(5), 10) * 1e3 * 0.95 - 50 * 40 * 8 : V = void 0, l.forEach((X) => {
      X.maxBitrate = V;
    })), l;
  }, u.parseRtcpParameters = function(c) {
    const l = {}, v = u.matchPrefix(c, "a=ssrc:").map((k) => u.parseSsrcMedia(k)).filter((k) => k.attribute === "cname")[0];
    v && (l.cname = v.value, l.ssrc = v.ssrc);
    const p = u.matchPrefix(c, "a=rtcp-rsize");
    l.reducedSize = p.length > 0, l.compound = p.length === 0;
    const _ = u.matchPrefix(c, "a=rtcp-mux");
    return l.mux = _.length > 0, l;
  }, u.writeRtcpParameters = function(c) {
    let l = "";
    return c.reducedSize && (l += `a=rtcp-rsize\r
`), c.mux && (l += `a=rtcp-mux\r
`), c.ssrc !== void 0 && c.cname && (l += "a=ssrc:" + c.ssrc + " cname:" + c.cname + `\r
`), l;
  }, u.parseMsid = function(c) {
    let l;
    const v = u.matchPrefix(c, "a=msid:");
    if (v.length === 1)
      return l = v[0].substring(7).split(" "), {
        stream: l[0],
        track: l[1]
      };
    const p = u.matchPrefix(c, "a=ssrc:").map((_) => u.parseSsrcMedia(_)).filter((_) => _.attribute === "msid");
    if (p.length > 0)
      return l = p[0].value.split(" "), {
        stream: l[0],
        track: l[1]
      };
  }, u.parseSctpDescription = function(c) {
    const l = u.parseMLine(c), v = u.matchPrefix(c, "a=max-message-size:");
    let p;
    v.length > 0 && (p = parseInt(v[0].substring(19), 10)), isNaN(p) && (p = 65536);
    const _ = u.matchPrefix(c, "a=sctp-port:");
    if (_.length > 0)
      return {
        port: parseInt(_[0].substring(12), 10),
        protocol: l.fmt,
        maxMessageSize: p
      };
    const k = u.matchPrefix(c, "a=sctpmap:");
    if (k.length > 0) {
      const M = k[0].substring(10).split(" ");
      return {
        port: parseInt(M[0], 10),
        protocol: M[1],
        maxMessageSize: p
      };
    }
  }, u.writeSctpDescription = function(c, l) {
    let v = [];
    return c.protocol !== "DTLS/SCTP" ? v = ["m=" + c.kind + " 9 " + c.protocol + " " + l.protocol + `\r
`, `c=IN IP4 0.0.0.0\r
`, "a=sctp-port:" + l.port + `\r
`] : v = ["m=" + c.kind + " 9 " + c.protocol + " " + l.port + `\r
`, `c=IN IP4 0.0.0.0\r
`, "a=sctpmap:" + l.port + " " + l.protocol + ` 65535\r
`], l.maxMessageSize !== void 0 && v.push("a=max-message-size:" + l.maxMessageSize + `\r
`), v.join("");
  }, u.generateSessionId = function() {
    return Math.random().toString().substr(2, 22);
  }, u.writeSessionBoilerplate = function(c, l, v) {
    let p;
    const _ = l !== void 0 ? l : 2;
    return c ? p = c : p = u.generateSessionId(), `v=0\r
o=` + (v || "thisisadapterortc") + " " + p + " " + _ + ` IN IP4 127.0.0.1\r
s=-\r
t=0 0\r
`;
  }, u.getDirection = function(c, l) {
    const v = u.splitLines(c);
    for (let p = 0; p < v.length; p++)
      switch (v[p]) {
        case "a=sendrecv":
        case "a=sendonly":
        case "a=recvonly":
        case "a=inactive":
          return v[p].substring(2);
      }
    return l ? u.getDirection(l) : "sendrecv";
  }, u.getKind = function(c) {
    return u.splitLines(c)[0].split(" ")[0].substring(2);
  }, u.isRejected = function(c) {
    return c.split(" ", 2)[1] === "0";
  }, u.parseMLine = function(c) {
    const v = u.splitLines(c)[0].substring(2).split(" ");
    return {
      kind: v[0],
      port: parseInt(v[1], 10),
      protocol: v[2],
      fmt: v.slice(3).join(" ")
    };
  }, u.parseOLine = function(c) {
    const v = u.matchPrefix(c, "o=")[0].substring(2).split(" ");
    return {
      username: v[0],
      sessionId: v[1],
      sessionVersion: parseInt(v[2], 10),
      netType: v[3],
      addressType: v[4],
      address: v[5]
    };
  }, u.isValidSDP = function(c) {
    if (typeof c != "string" || c.length === 0)
      return !1;
    const l = u.splitLines(c);
    for (let v = 0; v < l.length; v++)
      if (l[v].length < 2 || l[v].charAt(1) !== "=")
        return !1;
    return !0;
  }, a.exports = u;
})(sdp$1);
var sdpExports = sdp$1.exports, SDPUtils = /* @__PURE__ */ getDefaultExportFromCjs(sdpExports), sdp = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: SDPUtils
}, [sdpExports]);
function shimRTCIceCandidate(a) {
  if (!a.RTCIceCandidate || a.RTCIceCandidate && "foundation" in a.RTCIceCandidate.prototype)
    return;
  const u = a.RTCIceCandidate;
  a.RTCIceCandidate = function(l) {
    if (typeof l == "object" && l.candidate && l.candidate.indexOf("a=") === 0 && (l = JSON.parse(JSON.stringify(l)), l.candidate = l.candidate.substring(2)), l.candidate && l.candidate.length) {
      const v = new u(l), p = SDPUtils.parseCandidate(l.candidate);
      for (const _ in p)
        _ in v || Object.defineProperty(v, _, {
          value: p[_]
        });
      return v.toJSON = function() {
        return {
          candidate: v.candidate,
          sdpMid: v.sdpMid,
          sdpMLineIndex: v.sdpMLineIndex,
          usernameFragment: v.usernameFragment
        };
      }, v;
    }
    return new u(l);
  }, a.RTCIceCandidate.prototype = u.prototype, wrapPeerConnectionEvent(a, "icecandidate", (c) => (c.candidate && Object.defineProperty(c, "candidate", {
    value: new a.RTCIceCandidate(c.candidate),
    writable: "false"
  }), c));
}
function shimRTCIceCandidateRelayProtocol(a) {
  !a.RTCIceCandidate || a.RTCIceCandidate && "relayProtocol" in a.RTCIceCandidate.prototype || wrapPeerConnectionEvent(a, "icecandidate", (u) => {
    if (u.candidate) {
      const c = SDPUtils.parseCandidate(u.candidate.candidate);
      c.type === "relay" && (u.candidate.relayProtocol = {
        0: "tls",
        1: "tcp",
        2: "udp"
      }[c.priority >> 24]);
    }
    return u;
  });
}
function shimMaxMessageSize(a, u) {
  if (!a.RTCPeerConnection)
    return;
  "sctp" in a.RTCPeerConnection.prototype || Object.defineProperty(a.RTCPeerConnection.prototype, "sctp", {
    get() {
      return typeof this._sctp > "u" ? null : this._sctp;
    }
  });
  const c = function(k) {
    if (!k || !k.sdp)
      return !1;
    const M = SDPUtils.splitSections(k.sdp);
    return M.shift(), M.some((L) => {
      const F = SDPUtils.parseMLine(L);
      return F && F.kind === "application" && F.protocol.indexOf("SCTP") !== -1;
    });
  }, l = function(k) {
    const M = k.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
    if (M === null || M.length < 2)
      return -1;
    const L = parseInt(M[1], 10);
    return L !== L ? -1 : L;
  }, v = function(k) {
    let M = 65536;
    return u.browser === "firefox" && (u.version < 57 ? k === -1 ? M = 16384 : M = 2147483637 : u.version < 60 ? M = u.version === 57 ? 65535 : 65536 : M = 2147483637), M;
  }, p = function(k, M) {
    let L = 65536;
    u.browser === "firefox" && u.version === 57 && (L = 65535);
    const F = SDPUtils.matchPrefix(k.sdp, "a=max-message-size:");
    return F.length > 0 ? L = parseInt(F[0].substring(19), 10) : u.browser === "firefox" && M !== -1 && (L = 2147483637), L;
  }, _ = a.RTCPeerConnection.prototype.setRemoteDescription;
  a.RTCPeerConnection.prototype.setRemoteDescription = function() {
    if (this._sctp = null, u.browser === "chrome" && u.version >= 76) {
      const {
        sdpSemantics: M
      } = this.getConfiguration();
      M === "plan-b" && Object.defineProperty(this, "sctp", {
        get() {
          return typeof this._sctp > "u" ? null : this._sctp;
        },
        enumerable: !0,
        configurable: !0
      });
    }
    if (c(arguments[0])) {
      const M = l(arguments[0]), L = v(M), F = p(arguments[0], M);
      let V;
      L === 0 && F === 0 ? V = Number.POSITIVE_INFINITY : L === 0 || F === 0 ? V = Math.max(L, F) : V = Math.min(L, F);
      const X = {};
      Object.defineProperty(X, "maxMessageSize", {
        get() {
          return V;
        }
      }), this._sctp = X;
    }
    return _.apply(this, arguments);
  };
}
function shimSendThrowTypeError(a) {
  if (!(a.RTCPeerConnection && "createDataChannel" in a.RTCPeerConnection.prototype))
    return;
  function u(l, v) {
    const p = l.send;
    l.send = function() {
      const k = arguments[0], M = k.length || k.size || k.byteLength;
      if (l.readyState === "open" && v.sctp && M > v.sctp.maxMessageSize)
        throw new TypeError("Message too large (can send a maximum of " + v.sctp.maxMessageSize + " bytes)");
      return p.apply(l, arguments);
    };
  }
  const c = a.RTCPeerConnection.prototype.createDataChannel;
  a.RTCPeerConnection.prototype.createDataChannel = function() {
    const v = c.apply(this, arguments);
    return u(v, this), v;
  }, wrapPeerConnectionEvent(a, "datachannel", (l) => (u(l.channel, l.target), l));
}
function shimConnectionState(a) {
  if (!a.RTCPeerConnection || "connectionState" in a.RTCPeerConnection.prototype)
    return;
  const u = a.RTCPeerConnection.prototype;
  Object.defineProperty(u, "connectionState", {
    get() {
      return {
        completed: "connected",
        checking: "connecting"
      }[this.iceConnectionState] || this.iceConnectionState;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(u, "onconnectionstatechange", {
    get() {
      return this._onconnectionstatechange || null;
    },
    set(c) {
      this._onconnectionstatechange && (this.removeEventListener("connectionstatechange", this._onconnectionstatechange), delete this._onconnectionstatechange), c && this.addEventListener("connectionstatechange", this._onconnectionstatechange = c);
    },
    enumerable: !0,
    configurable: !0
  }), ["setLocalDescription", "setRemoteDescription"].forEach((c) => {
    const l = u[c];
    u[c] = function() {
      return this._connectionstatechangepoly || (this._connectionstatechangepoly = (v) => {
        const p = v.target;
        if (p._lastConnectionState !== p.connectionState) {
          p._lastConnectionState = p.connectionState;
          const _ = new Event("connectionstatechange", v);
          p.dispatchEvent(_);
        }
        return v;
      }, this.addEventListener("iceconnectionstatechange", this._connectionstatechangepoly)), l.apply(this, arguments);
    };
  });
}
function removeExtmapAllowMixed(a, u) {
  if (!a.RTCPeerConnection || u.browser === "chrome" && u.version >= 71 || u.browser === "safari" && u.version >= 605)
    return;
  const c = a.RTCPeerConnection.prototype.setRemoteDescription;
  a.RTCPeerConnection.prototype.setRemoteDescription = function(v) {
    if (v && v.sdp && v.sdp.indexOf(`
a=extmap-allow-mixed`) !== -1) {
      const p = v.sdp.split(`
`).filter((_) => _.trim() !== "a=extmap-allow-mixed").join(`
`);
      a.RTCSessionDescription && v instanceof a.RTCSessionDescription ? arguments[0] = new a.RTCSessionDescription({
        type: v.type,
        sdp: p
      }) : v.sdp = p;
    }
    return c.apply(this, arguments);
  };
}
function shimAddIceCandidateNullOrEmpty(a, u) {
  if (!(a.RTCPeerConnection && a.RTCPeerConnection.prototype))
    return;
  const c = a.RTCPeerConnection.prototype.addIceCandidate;
  !c || c.length === 0 || (a.RTCPeerConnection.prototype.addIceCandidate = function() {
    return arguments[0] ? (u.browser === "chrome" && u.version < 78 || u.browser === "firefox" && u.version < 68 || u.browser === "safari") && arguments[0] && arguments[0].candidate === "" ? Promise.resolve() : c.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), Promise.resolve());
  });
}
function shimParameterlessSetLocalDescription(a, u) {
  if (!(a.RTCPeerConnection && a.RTCPeerConnection.prototype))
    return;
  const c = a.RTCPeerConnection.prototype.setLocalDescription;
  !c || c.length === 0 || (a.RTCPeerConnection.prototype.setLocalDescription = function() {
    let v = arguments[0] || {};
    if (typeof v != "object" || v.type && v.sdp)
      return c.apply(this, arguments);
    if (v = {
      type: v.type,
      sdp: v.sdp
    }, !v.type)
      switch (this.signalingState) {
        case "stable":
        case "have-local-offer":
        case "have-remote-pranswer":
          v.type = "offer";
          break;
        default:
          v.type = "answer";
          break;
      }
    return v.sdp || v.type !== "offer" && v.type !== "answer" ? c.apply(this, [v]) : (v.type === "offer" ? this.createOffer : this.createAnswer).apply(this).then((_) => c.apply(this, [_]));
  });
}
var commonShim = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  removeExtmapAllowMixed,
  shimAddIceCandidateNullOrEmpty,
  shimConnectionState,
  shimMaxMessageSize,
  shimParameterlessSetLocalDescription,
  shimRTCIceCandidate,
  shimRTCIceCandidateRelayProtocol,
  shimSendThrowTypeError
});
function adapterFactory() {
  let {
    window: a
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    shimChrome: !0,
    shimFirefox: !0,
    shimSafari: !0
  };
  const c = log$1, l = detectBrowser(a), v = {
    browserDetails: l,
    commonShim,
    extractVersion,
    disableLog,
    disableWarnings,
    // Expose sdp as a convenience. For production apps include directly.
    sdp
  };
  switch (l.browser) {
    case "chrome":
      if (!chromeShim || !shimPeerConnection$1 || !u.shimChrome)
        return c("Chrome shim is not included in this adapter release."), v;
      if (l.version === null)
        return c("Chrome shim can not determine version, not shimming."), v;
      c("adapter.js shimming chrome."), v.browserShim = chromeShim, shimAddIceCandidateNullOrEmpty(a, l), shimParameterlessSetLocalDescription(a), shimGetUserMedia$2(a, l), shimMediaStream(a), shimPeerConnection$1(a, l), shimOnTrack$1(a), shimAddTrackRemoveTrack(a, l), shimGetSendersWithDtmf(a), shimGetStats(a), shimSenderReceiverGetStats(a), fixNegotiationNeeded(a, l), shimRTCIceCandidate(a), shimRTCIceCandidateRelayProtocol(a), shimConnectionState(a), shimMaxMessageSize(a, l), shimSendThrowTypeError(a), removeExtmapAllowMixed(a, l);
      break;
    case "firefox":
      if (!firefoxShim || !shimPeerConnection || !u.shimFirefox)
        return c("Firefox shim is not included in this adapter release."), v;
      c("adapter.js shimming firefox."), v.browserShim = firefoxShim, shimAddIceCandidateNullOrEmpty(a, l), shimParameterlessSetLocalDescription(a), shimGetUserMedia$1(a, l), shimPeerConnection(a, l), shimOnTrack(a), shimRemoveStream(a), shimSenderGetStats(a), shimReceiverGetStats(a), shimRTCDataChannel(a), shimAddTransceiver(a), shimGetParameters(a), shimCreateOffer(a), shimCreateAnswer(a), shimRTCIceCandidate(a), shimConnectionState(a), shimMaxMessageSize(a, l), shimSendThrowTypeError(a);
      break;
    case "safari":
      if (!safariShim || !u.shimSafari)
        return c("Safari shim is not included in this adapter release."), v;
      c("adapter.js shimming safari."), v.browserShim = safariShim, shimAddIceCandidateNullOrEmpty(a, l), shimParameterlessSetLocalDescription(a), shimRTCIceServerUrls(a), shimCreateOfferLegacy(a), shimCallbacksAPI(a), shimLocalStreamsAPI(a), shimRemoteStreamsAPI(a), shimTrackEventTransceiver(a), shimGetUserMedia(a), shimAudioContext(a), shimRTCIceCandidate(a), shimRTCIceCandidateRelayProtocol(a), shimMaxMessageSize(a, l), shimSendThrowTypeError(a), removeExtmapAllowMixed(a, l);
      break;
    default:
      c("Unsupported browser!");
      break;
  }
  return v;
}
adapterFactory({
  window: typeof window > "u" ? void 0 : window
});
const DECRYPTION_FAILURE_TOLERANCE = 10, E2EE_FLAG = "lk_e2ee", SALT = "LKFrameEncryptionKey", KEY_PROVIDER_DEFAULTS = {
  sharedKey: !1,
  ratchetSalt: SALT,
  ratchetWindowSize: 8,
  failureTolerance: DECRYPTION_FAILURE_TOLERANCE,
  keyringSize: 16
};
var KeyProviderEvent;
(function(a) {
  a.SetKey = "setKey", a.RatchetRequest = "ratchetRequest", a.KeyRatcheted = "keyRatcheted";
})(KeyProviderEvent || (KeyProviderEvent = {}));
var KeyHandlerEvent;
(function(a) {
  a.KeyRatcheted = "keyRatcheted";
})(KeyHandlerEvent || (KeyHandlerEvent = {}));
var EncryptionEvent;
(function(a) {
  a.ParticipantEncryptionStatusChanged = "participantEncryptionStatusChanged", a.EncryptionError = "encryptionError";
})(EncryptionEvent || (EncryptionEvent = {}));
var CryptorEvent;
(function(a) {
  a.Error = "cryptorError";
})(CryptorEvent || (CryptorEvent = {}));
function isE2EESupported() {
  return isInsertableStreamSupported() || isScriptTransformSupported();
}
function isScriptTransformSupported() {
  return typeof window.RTCRtpScriptTransform < "u";
}
function isInsertableStreamSupported() {
  return typeof window.RTCRtpSender < "u" && // @ts-ignore
  typeof window.RTCRtpSender.prototype.createEncodedStreams < "u";
}
class BaseKeyProvider extends eventsExports$1.EventEmitter {
  constructor() {
    let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    super(), this.onKeyRatcheted = (c, l) => {
      livekitLogger.debug("key ratcheted event received", {
        material: c,
        keyIndex: l
      });
    }, this.keyInfoMap = /* @__PURE__ */ new Map(), this.options = Object.assign(Object.assign({}, KEY_PROVIDER_DEFAULTS), u), this.on(KeyProviderEvent.KeyRatcheted, this.onKeyRatcheted);
  }
  /**
   * callback to invoke once a key has been set for a participant
   * @param key
   * @param participantIdentity
   * @param keyIndex
   */
  onSetEncryptionKey(u, c, l) {
    const v = {
      key: u,
      participantIdentity: c,
      keyIndex: l
    };
    if (!this.options.sharedKey && !c)
      throw new Error("participant identity needs to be passed for encryption key if sharedKey option is false");
    this.keyInfoMap.set("".concat(c ?? "shared", "-").concat(l ?? 0), v), this.emit(KeyProviderEvent.SetKey, v);
  }
  getKeys() {
    return Array.from(this.keyInfoMap.values());
  }
  getOptions() {
    return this.options;
  }
  ratchetKey(u, c) {
    this.emit(KeyProviderEvent.RatchetRequest, u, c);
  }
}
class LivekitError extends Error {
  constructor(u, c) {
    super(c || "an error has occured"), this.code = u;
  }
}
class ConnectionError extends LivekitError {
  constructor(u, c, l) {
    super(1, u), this.status = l, this.reason = c;
  }
}
class DeviceUnsupportedError extends LivekitError {
  constructor(u) {
    super(21, u ?? "device is unsupported");
  }
}
class TrackInvalidError extends LivekitError {
  constructor(u) {
    super(20, u ?? "track is invalid");
  }
}
class UnsupportedServer extends LivekitError {
  constructor(u) {
    super(10, u ?? "unsupported server");
  }
}
class UnexpectedConnectionState extends LivekitError {
  constructor(u) {
    super(12, u ?? "unexpected connection state");
  }
}
class NegotiationError extends LivekitError {
  constructor(u) {
    super(13, u ?? "unable to negotiate");
  }
}
var MediaDeviceFailure;
(function(a) {
  a.PermissionDenied = "PermissionDenied", a.NotFound = "NotFound", a.DeviceInUse = "DeviceInUse", a.Other = "Other";
})(MediaDeviceFailure || (MediaDeviceFailure = {}));
(function(a) {
  function u(c) {
    if (c && "name" in c)
      return c.name === "NotFoundError" || c.name === "DevicesNotFoundError" ? a.NotFound : c.name === "NotAllowedError" || c.name === "PermissionDeniedError" ? a.PermissionDenied : c.name === "NotReadableError" || c.name === "TrackStartError" ? a.DeviceInUse : a.Other;
  }
  a.getFailure = u;
})(MediaDeviceFailure || (MediaDeviceFailure = {}));
var RoomEvent;
(function(a) {
  a.Connected = "connected", a.Reconnecting = "reconnecting", a.Reconnected = "reconnected", a.Disconnected = "disconnected", a.ConnectionStateChanged = "connectionStateChanged", a.MediaDevicesChanged = "mediaDevicesChanged", a.ParticipantConnected = "participantConnected", a.ParticipantDisconnected = "participantDisconnected", a.TrackPublished = "trackPublished", a.TrackSubscribed = "trackSubscribed", a.TrackSubscriptionFailed = "trackSubscriptionFailed", a.TrackUnpublished = "trackUnpublished", a.TrackUnsubscribed = "trackUnsubscribed", a.TrackMuted = "trackMuted", a.TrackUnmuted = "trackUnmuted", a.LocalTrackPublished = "localTrackPublished", a.LocalTrackUnpublished = "localTrackUnpublished", a.LocalAudioSilenceDetected = "localAudioSilenceDetected", a.ActiveSpeakersChanged = "activeSpeakersChanged", a.ParticipantMetadataChanged = "participantMetadataChanged", a.ParticipantNameChanged = "participantNameChanged", a.RoomMetadataChanged = "roomMetadataChanged", a.DataReceived = "dataReceived", a.ConnectionQualityChanged = "connectionQualityChanged", a.TrackStreamStateChanged = "trackStreamStateChanged", a.TrackSubscriptionPermissionChanged = "trackSubscriptionPermissionChanged", a.TrackSubscriptionStatusChanged = "trackSubscriptionStatusChanged", a.AudioPlaybackStatusChanged = "audioPlaybackChanged", a.VideoPlaybackStatusChanged = "videoPlaybackChanged", a.MediaDevicesError = "mediaDevicesError", a.ParticipantPermissionsChanged = "participantPermissionsChanged", a.SignalConnected = "signalConnected", a.RecordingStatusChanged = "recordingStatusChanged", a.ParticipantEncryptionStatusChanged = "participantEncryptionStatusChanged", a.EncryptionError = "encryptionError", a.DCBufferStatusChanged = "dcBufferStatusChanged", a.ActiveDeviceChanged = "activeDeviceChanged";
})(RoomEvent || (RoomEvent = {}));
var ParticipantEvent;
(function(a) {
  a.TrackPublished = "trackPublished", a.TrackSubscribed = "trackSubscribed", a.TrackSubscriptionFailed = "trackSubscriptionFailed", a.TrackUnpublished = "trackUnpublished", a.TrackUnsubscribed = "trackUnsubscribed", a.TrackMuted = "trackMuted", a.TrackUnmuted = "trackUnmuted", a.LocalTrackPublished = "localTrackPublished", a.LocalTrackUnpublished = "localTrackUnpublished", a.ParticipantMetadataChanged = "participantMetadataChanged", a.ParticipantNameChanged = "participantNameChanged", a.DataReceived = "dataReceived", a.IsSpeakingChanged = "isSpeakingChanged", a.ConnectionQualityChanged = "connectionQualityChanged", a.TrackStreamStateChanged = "trackStreamStateChanged", a.TrackSubscriptionPermissionChanged = "trackSubscriptionPermissionChanged", a.TrackSubscriptionStatusChanged = "trackSubscriptionStatusChanged", a.MediaDevicesError = "mediaDevicesError", a.AudioStreamAcquired = "audioStreamAcquired", a.ParticipantPermissionsChanged = "participantPermissionsChanged", a.PCTrackAdded = "pcTrackAdded";
})(ParticipantEvent || (ParticipantEvent = {}));
var EngineEvent;
(function(a) {
  a.TransportsCreated = "transportsCreated", a.Connected = "connected", a.Disconnected = "disconnected", a.Resuming = "resuming", a.Resumed = "resumed", a.Restarting = "restarting", a.Restarted = "restarted", a.SignalResumed = "signalResumed", a.SignalRestarted = "signalRestarted", a.Closing = "closing", a.MediaTrackAdded = "mediaTrackAdded", a.ActiveSpeakersUpdate = "activeSpeakersUpdate", a.DataPacketReceived = "dataPacketReceived", a.RTPVideoMapUpdate = "rtpVideoMapUpdate", a.DCBufferStatusChanged = "dcBufferStatusChanged", a.ParticipantUpdate = "participantUpdate", a.RoomUpdate = "roomUpdate", a.SpeakersChanged = "speakersChanged", a.StreamStateChanged = "streamStateChanged", a.ConnectionQualityUpdate = "connectionQualityUpdate", a.SubscriptionError = "subscriptionError", a.SubscriptionPermissionUpdate = "subscriptionPermissionUpdate", a.RemoteMute = "remoteMute", a.SubscribedQualityUpdate = "subscribedQualityUpdate", a.LocalTrackUnpublished = "localTrackUnpublished", a.Offline = "offline";
})(EngineEvent || (EngineEvent = {}));
var TrackEvent;
(function(a) {
  a.Message = "message", a.Muted = "muted", a.Unmuted = "unmuted", a.Restarted = "restarted", a.Ended = "ended", a.Subscribed = "subscribed", a.Unsubscribed = "unsubscribed", a.UpdateSettings = "updateSettings", a.UpdateSubscription = "updateSubscription", a.AudioPlaybackStarted = "audioPlaybackStarted", a.AudioPlaybackFailed = "audioPlaybackFailed", a.AudioSilenceDetected = "audioSilenceDetected", a.VisibilityChanged = "visibilityChanged", a.VideoDimensionsChanged = "videoDimensionsChanged", a.VideoPlaybackStarted = "videoPlaybackStarted", a.VideoPlaybackFailed = "videoPlaybackFailed", a.ElementAttached = "elementAttached", a.ElementDetached = "elementDetached", a.UpstreamPaused = "upstreamPaused", a.UpstreamResumed = "upstreamResumed", a.SubscriptionPermissionChanged = "subscriptionPermissionChanged", a.SubscriptionStatusChanged = "subscriptionStatusChanged", a.SubscriptionFailed = "subscriptionFailed", a.TrackProcessorUpdate = "trackProcessorUpdate";
})(TrackEvent || (TrackEvent = {}));
function r$1(a, u, c) {
  var l, v, p;
  u === void 0 && (u = 50), c === void 0 && (c = {});
  var _ = (l = c.isImmediate) != null && l, k = (v = c.callback) != null && v, M = c.maxWait, L = Date.now(), F = [];
  function V() {
    if (M !== void 0) {
      var oe = Date.now() - L;
      if (oe + u >= M)
        return M - oe;
    }
    return u;
  }
  var X = function() {
    var oe = [].slice.call(arguments), Y = this;
    return new Promise(function(ae, ne) {
      var fe = _ && p === void 0;
      if (p !== void 0 && clearTimeout(p), p = setTimeout(function() {
        if (p = void 0, L = Date.now(), !_) {
          var ge = a.apply(Y, oe);
          k && k(ge), F.forEach(function(be) {
            return (0, be.resolve)(ge);
          }), F = [];
        }
      }, V()), fe) {
        var ie = a.apply(Y, oe);
        return k && k(ie), ae(ie);
      }
      F.push({
        resolve: ae,
        reject: ne
      });
    });
  };
  return X.cancel = function(oe) {
    p !== void 0 && clearTimeout(p), F.forEach(function(Y) {
      return (0, Y.reject)(oe);
    }), F = [];
  }, X;
}
const commonVersionIdentifier = /version\/(\d+(\.?_?\d+)+)/i;
let browserDetails;
function getBrowser(a) {
  let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
  if (typeof a > "u" && typeof navigator > "u")
    return;
  const c = (a ?? navigator.userAgent).toLowerCase();
  if (browserDetails === void 0 || u) {
    const l = browsersList.find((v) => {
      let {
        test: p
      } = v;
      return p.test(c);
    });
    browserDetails = l == null ? void 0 : l.describe(c);
  }
  return browserDetails;
}
const browsersList = [
  {
    test: /firefox|iceweasel|fxios/i,
    describe(a) {
      return {
        name: "Firefox",
        version: getMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, a),
        os: a.toLowerCase().includes("fxios") ? "iOS" : void 0
      };
    }
  },
  {
    test: /chrom|crios|crmo/i,
    describe(a) {
      return {
        name: "Chrome",
        version: getMatch(/(?:chrome|chromium|crios|crmo)\/(\d+(\.?_?\d+)+)/i, a),
        os: a.toLowerCase().includes("crios") ? "iOS" : void 0
      };
    }
  },
  /* Safari */
  {
    test: /safari|applewebkit/i,
    describe(a) {
      return {
        name: "Safari",
        version: getMatch(commonVersionIdentifier, a),
        os: a.includes("mobile/") ? "iOS" : "macOS"
      };
    }
  }
];
function getMatch(a, u) {
  let c = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
  const l = u.match(a);
  return l && l.length >= c && l[c] || "";
}
var version$1$1 = "2.0.10";
const version$3 = version$1$1, protocolVersion = 12;
class CriticalTimers {
}
CriticalTimers.setTimeout = function() {
  return setTimeout(...arguments);
};
CriticalTimers.setInterval = function() {
  return setInterval(...arguments);
};
CriticalTimers.clearTimeout = function() {
  return clearTimeout(...arguments);
};
CriticalTimers.clearInterval = function() {
  return clearInterval(...arguments);
};
class VideoPreset {
  constructor(u, c, l, v, p) {
    if (typeof u == "object")
      this.width = u.width, this.height = u.height, this.aspectRatio = u.aspectRatio, this.encoding = {
        maxBitrate: u.maxBitrate,
        maxFramerate: u.maxFramerate,
        priority: u.priority
      };
    else if (c !== void 0 && l !== void 0)
      this.width = u, this.height = c, this.aspectRatio = u / c, this.encoding = {
        maxBitrate: l,
        maxFramerate: v,
        priority: p
      };
    else
      throw new TypeError("Unsupported options: provide at least width, height and maxBitrate");
  }
  get resolution() {
    return {
      width: this.width,
      height: this.height,
      frameRate: this.encoding.maxFramerate,
      aspectRatio: this.aspectRatio
    };
  }
}
const backupCodecs = ["vp8", "h264"], videoCodecs = ["vp8", "h264", "vp9", "av1"];
function isBackupCodec(a) {
  return !!backupCodecs.find((u) => u === a);
}
var AudioPresets;
(function(a) {
  a.telephone = {
    maxBitrate: 12e3
  }, a.speech = {
    maxBitrate: 2e4
  }, a.music = {
    maxBitrate: 32e3
  }, a.musicStereo = {
    maxBitrate: 48e3
  }, a.musicHighQuality = {
    maxBitrate: 64e3
  }, a.musicHighQualityStereo = {
    maxBitrate: 96e3
  };
})(AudioPresets || (AudioPresets = {}));
const VideoPresets = {
  h90: new VideoPreset(160, 90, 9e4, 20),
  h180: new VideoPreset(320, 180, 16e4, 20),
  h216: new VideoPreset(384, 216, 18e4, 20),
  h360: new VideoPreset(640, 360, 45e4, 20),
  h540: new VideoPreset(960, 540, 8e5, 25),
  h720: new VideoPreset(1280, 720, 17e5, 30),
  h1080: new VideoPreset(1920, 1080, 3e6, 30),
  h1440: new VideoPreset(2560, 1440, 5e6, 30),
  h2160: new VideoPreset(3840, 2160, 8e6, 30)
}, VideoPresets43 = {
  h120: new VideoPreset(160, 120, 7e4, 20),
  h180: new VideoPreset(240, 180, 125e3, 20),
  h240: new VideoPreset(320, 240, 14e4, 20),
  h360: new VideoPreset(480, 360, 33e4, 20),
  h480: new VideoPreset(640, 480, 5e5, 20),
  h540: new VideoPreset(720, 540, 6e5, 25),
  h720: new VideoPreset(960, 720, 13e5, 30),
  h1080: new VideoPreset(1440, 1080, 23e5, 30),
  h1440: new VideoPreset(1920, 1440, 38e5, 30)
}, ScreenSharePresets = {
  h360fps3: new VideoPreset(640, 360, 2e5, 3, "medium"),
  h360fps15: new VideoPreset(640, 360, 4e5, 15, "medium"),
  h720fps5: new VideoPreset(1280, 720, 8e5, 5, "medium"),
  h720fps15: new VideoPreset(1280, 720, 15e5, 15, "medium"),
  h720fps30: new VideoPreset(1280, 720, 2e6, 30, "medium"),
  h1080fps15: new VideoPreset(1920, 1080, 25e5, 15, "medium"),
  h1080fps30: new VideoPreset(1920, 1080, 5e6, 30, "medium"),
  // original resolution, without resizing
  original: new VideoPreset(0, 0, 7e6, 30, "medium")
};
function cloneDeep(a) {
  if (!(typeof a > "u"))
    return typeof structuredClone == "function" ? structuredClone(a) : JSON.parse(JSON.stringify(a));
}
const BACKGROUND_REACTION_DELAY = 5e3, recycledElements = [];
var VideoQuality;
(function(a) {
  a[a.LOW = 0] = "LOW", a[a.MEDIUM = 1] = "MEDIUM", a[a.HIGH = 2] = "HIGH";
})(VideoQuality || (VideoQuality = {}));
class Track extends eventsExports$1.EventEmitter {
  constructor(u, c) {
    let l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var v;
    super(), this.attachedElements = [], this.isMuted = !1, this.streamState = Track.StreamState.Active, this.isInBackground = !1, this._currentBitrate = 0, this.log = livekitLogger, this.appVisibilityChangedListener = () => {
      this.backgroundTimeout && clearTimeout(this.backgroundTimeout), document.visibilityState === "hidden" ? this.backgroundTimeout = setTimeout(() => this.handleAppVisibilityChanged(), BACKGROUND_REACTION_DELAY) : this.handleAppVisibilityChanged();
    }, this.log = getLogger((v = l.loggerName) !== null && v !== void 0 ? v : LoggerNames.Track), this.loggerContextCb = l.loggerContextCb, this.setMaxListeners(100), this.kind = c, this._mediaStreamTrack = u, this._mediaStreamID = u.id, this.source = Track.Source.Unknown;
  }
  get logContext() {
    var u;
    return Object.assign(Object.assign({}, (u = this.loggerContextCb) === null || u === void 0 ? void 0 : u.call(this)), getLogContextFromTrack(this));
  }
  /** current receive bits per second */
  get currentBitrate() {
    return this._currentBitrate;
  }
  get mediaStreamTrack() {
    return this._mediaStreamTrack;
  }
  /**
   * @internal
   * used for keep mediaStream's first id, since it's id might change
   * if we disable/enable a track
   */
  get mediaStreamID() {
    return this._mediaStreamID;
  }
  attach(u) {
    let c = "audio";
    this.kind === Track.Kind.Video && (c = "video"), this.attachedElements.length === 0 && Track.Kind.Video && this.addAppVisibilityListener(), u || (c === "audio" && (recycledElements.forEach((p) => {
      p.parentElement === null && !u && (u = p);
    }), u && recycledElements.splice(recycledElements.indexOf(u), 1)), u || (u = document.createElement(c))), this.attachedElements.includes(u) || this.attachedElements.push(u), attachToElement(this.mediaStreamTrack, u);
    const l = u.srcObject.getTracks(), v = l.some((p) => p.kind === "audio");
    return u.play().then(() => {
      this.emit(v ? TrackEvent.AudioPlaybackStarted : TrackEvent.VideoPlaybackStarted);
    }).catch((p) => {
      p.name === "NotAllowedError" ? this.emit(v ? TrackEvent.AudioPlaybackFailed : TrackEvent.VideoPlaybackFailed, p) : p.name === "AbortError" ? livekitLogger.debug("".concat(v ? "audio" : "video", " playback aborted, likely due to new play request")) : livekitLogger.warn("could not playback ".concat(v ? "audio" : "video"), p), v && u && l.some((_) => _.kind === "video") && p.name === "NotAllowedError" && (u.muted = !0, u.play().catch(() => {
      }));
    }), this.emit(TrackEvent.ElementAttached, u), u;
  }
  detach(u) {
    try {
      if (u) {
        detachTrack(this.mediaStreamTrack, u);
        const l = this.attachedElements.indexOf(u);
        return l >= 0 && (this.attachedElements.splice(l, 1), this.recycleElement(u), this.emit(TrackEvent.ElementDetached, u)), u;
      }
      const c = [];
      return this.attachedElements.forEach((l) => {
        detachTrack(this.mediaStreamTrack, l), c.push(l), this.recycleElement(l), this.emit(TrackEvent.ElementDetached, l);
      }), this.attachedElements = [], c;
    } finally {
      this.attachedElements.length === 0 && this.removeAppVisibilityListener();
    }
  }
  stop() {
    this.stopMonitor(), this._mediaStreamTrack.stop();
  }
  enable() {
    this._mediaStreamTrack.enabled = !0;
  }
  disable() {
    this._mediaStreamTrack.enabled = !1;
  }
  /* @internal */
  stopMonitor() {
    this.monitorInterval && clearInterval(this.monitorInterval);
  }
  /** @internal */
  updateLoggerOptions(u) {
    u.loggerName && (this.log = getLogger(u.loggerName)), u.loggerContextCb && (this.loggerContextCb = u.loggerContextCb);
  }
  recycleElement(u) {
    if (u instanceof HTMLAudioElement) {
      let c = !0;
      u.pause(), recycledElements.forEach((l) => {
        l.parentElement || (c = !1);
      }), c && recycledElements.push(u);
    }
  }
  handleAppVisibilityChanged() {
    return __awaiter$3(this, void 0, void 0, function* () {
      this.isInBackground = document.visibilityState === "hidden";
    });
  }
  addAppVisibilityListener() {
    isWeb() ? (this.isInBackground = document.visibilityState === "hidden", document.addEventListener("visibilitychange", this.appVisibilityChangedListener)) : this.isInBackground = !1;
  }
  removeAppVisibilityListener() {
    isWeb() && document.removeEventListener("visibilitychange", this.appVisibilityChangedListener);
  }
}
function attachToElement(a, u) {
  let c;
  u.srcObject instanceof MediaStream ? c = u.srcObject : c = new MediaStream();
  let l;
  a.kind === "audio" ? l = c.getAudioTracks() : l = c.getVideoTracks(), l.includes(a) || (l.forEach((v) => {
    c.removeTrack(v);
  }), c.addTrack(a)), (!isSafari() || !(u instanceof HTMLVideoElement)) && (u.autoplay = !0), u.muted = c.getAudioTracks().length === 0, u instanceof HTMLVideoElement && (u.playsInline = !0), u.srcObject !== c && (u.srcObject = c, (isSafari() || isFireFox()) && u instanceof HTMLVideoElement && setTimeout(() => {
    u.srcObject = c, u.play().catch(() => {
    });
  }, 0));
}
function detachTrack(a, u) {
  if (u.srcObject instanceof MediaStream) {
    const c = u.srcObject;
    c.removeTrack(a), c.getTracks().length > 0 ? u.srcObject = c : u.srcObject = null;
  }
}
(function(a) {
  let u;
  (function(L) {
    L.Audio = "audio", L.Video = "video", L.Unknown = "unknown";
  })(u = a.Kind || (a.Kind = {}));
  let c;
  (function(L) {
    L.Camera = "camera", L.Microphone = "microphone", L.ScreenShare = "screen_share", L.ScreenShareAudio = "screen_share_audio", L.Unknown = "unknown";
  })(c = a.Source || (a.Source = {}));
  let l;
  (function(L) {
    L.Active = "active", L.Paused = "paused", L.Unknown = "unknown";
  })(l = a.StreamState || (a.StreamState = {}));
  function v(L) {
    switch (L) {
      case u.Audio:
        return TrackType.AUDIO;
      case u.Video:
        return TrackType.VIDEO;
      default:
        return TrackType.DATA;
    }
  }
  a.kindToProto = v;
  function p(L) {
    switch (L) {
      case TrackType.AUDIO:
        return u.Audio;
      case TrackType.VIDEO:
        return u.Video;
      default:
        return u.Unknown;
    }
  }
  a.kindFromProto = p;
  function _(L) {
    switch (L) {
      case c.Camera:
        return TrackSource.CAMERA;
      case c.Microphone:
        return TrackSource.MICROPHONE;
      case c.ScreenShare:
        return TrackSource.SCREEN_SHARE;
      case c.ScreenShareAudio:
        return TrackSource.SCREEN_SHARE_AUDIO;
      default:
        return TrackSource.UNKNOWN;
    }
  }
  a.sourceToProto = _;
  function k(L) {
    switch (L) {
      case TrackSource.CAMERA:
        return c.Camera;
      case TrackSource.MICROPHONE:
        return c.Microphone;
      case TrackSource.SCREEN_SHARE:
        return c.ScreenShare;
      case TrackSource.SCREEN_SHARE_AUDIO:
        return c.ScreenShareAudio;
      default:
        return c.Unknown;
    }
  }
  a.sourceFromProto = k;
  function M(L) {
    switch (L) {
      case StreamState.ACTIVE:
        return l.Active;
      case StreamState.PAUSED:
        return l.Paused;
      default:
        return l.Unknown;
    }
  }
  a.streamStateFromProto = M;
})(Track || (Track = {}));
function mergeDefaultOptions(a, u, c) {
  var l;
  const v = (l = cloneDeep(a)) !== null && l !== void 0 ? l : {};
  return v.audio === !0 && (v.audio = {}), v.video === !0 && (v.video = {}), v.audio && mergeObjectWithoutOverwriting(v.audio, u), v.video && mergeObjectWithoutOverwriting(v.video, c), v;
}
function mergeObjectWithoutOverwriting(a, u) {
  return Object.keys(u).forEach((c) => {
    a[c] === void 0 && (a[c] = u[c]);
  }), a;
}
function constraintsForOptions(a) {
  const u = {};
  if (a.video)
    if (typeof a.video == "object") {
      const c = {}, l = c, v = a.video;
      Object.keys(v).forEach((p) => {
        switch (p) {
          case "resolution":
            mergeObjectWithoutOverwriting(l, v.resolution);
            break;
          default:
            l[p] = v[p];
        }
      }), u.video = c;
    } else
      u.video = a.video;
  else
    u.video = !1;
  return a.audio ? typeof a.audio == "object" ? u.audio = a.audio : u.audio = !0 : u.audio = !1, u;
}
function detectSilence(a) {
  let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 200;
  return __awaiter$3(this, void 0, void 0, function* () {
    const c = getNewAudioContext();
    if (c) {
      const l = c.createAnalyser();
      l.fftSize = 2048;
      const v = l.frequencyBinCount, p = new Uint8Array(v);
      c.createMediaStreamSource(new MediaStream([a.mediaStreamTrack])).connect(l), yield sleep(u), l.getByteTimeDomainData(p);
      const k = p.some((M) => M !== 128 && M !== 0);
      return c.close(), !k;
    }
    return !1;
  });
}
function getNewAudioContext() {
  const a = (
    // @ts-ignore
    typeof window < "u" && (window.AudioContext || window.webkitAudioContext)
  );
  if (a)
    return new a({
      latencyHint: "interactive"
    });
}
function sourceToKind(a) {
  return a === Track.Source.Microphone ? "audioinput" : a === Track.Source.Camera ? "videoinput" : void 0;
}
function screenCaptureToDisplayMediaStreamOptions(a) {
  var u, c;
  let l = (u = a.video) !== null && u !== void 0 ? u : !0;
  return a.resolution && a.resolution.width > 0 && a.resolution.height > 0 && (l = typeof l == "boolean" ? {} : l, isSafari() ? l = Object.assign(Object.assign({}, l), {
    width: {
      max: a.resolution.width
    },
    height: {
      max: a.resolution.height
    },
    frameRate: a.resolution.frameRate
  }) : l = Object.assign(Object.assign({}, l), {
    width: {
      ideal: a.resolution.width
    },
    height: {
      ideal: a.resolution.height
    },
    frameRate: a.resolution.frameRate
  })), {
    audio: (c = a.audio) !== null && c !== void 0 ? c : !1,
    video: l,
    // @ts-expect-error support for experimental display media features
    controller: a.controller,
    selfBrowserSurface: a.selfBrowserSurface,
    surfaceSwitching: a.surfaceSwitching,
    systemAudio: a.systemAudio,
    preferCurrentTab: a.preferCurrentTab
  };
}
function mimeTypeToVideoCodecString(a) {
  const u = a.split("/")[1].toLowerCase();
  if (!videoCodecs.includes(u))
    throw Error("Video codec not supported: ".concat(u));
  return u;
}
function getTrackPublicationInfo(a) {
  const u = [];
  return a.forEach((c) => {
    c.track !== void 0 && u.push(new TrackPublishedResponse({
      cid: c.track.mediaStreamID,
      track: c.trackInfo
    }));
  }), u;
}
function getLogContextFromTrack(a) {
  return a instanceof Track ? {
    trackID: a.sid,
    source: a.source,
    muted: a.isMuted,
    enabled: a.mediaStreamTrack.enabled,
    kind: a.kind,
    streamID: a.mediaStreamID,
    streamTrackID: a.mediaStreamTrack.id
  } : {
    trackID: a.trackSid,
    enabled: a.isEnabled,
    muted: a.isMuted,
    trackInfo: Object.assign({
      mimeType: a.mimeType,
      name: a.trackName,
      encrypted: a.isEncrypted,
      kind: a.kind,
      source: a.source
    }, a.track ? getLogContextFromTrack(a.track) : {})
  };
}
const separator = "|", ddExtensionURI = "https://aomediacodec.github.io/av1-rtp-spec/#dependency-descriptor-rtp-header-extension";
function unpackStreamId(a) {
  const u = a.split(separator);
  return u.length > 1 ? [u[0], a.substr(u[0].length + 1)] : [a, ""];
}
function sleep(a) {
  return __awaiter$3(this, void 0, void 0, function* () {
    return new Promise((u) => CriticalTimers.setTimeout(u, a));
  });
}
function supportsTransceiver() {
  return "addTransceiver" in RTCPeerConnection.prototype;
}
function supportsAddTrack() {
  return "addTrack" in RTCPeerConnection.prototype;
}
function supportsAV1() {
  if (!("getCapabilities" in RTCRtpSender) || isSafari())
    return !1;
  const a = RTCRtpSender.getCapabilities("video");
  let u = !1;
  if (a) {
    for (const c of a.codecs)
      if (c.mimeType === "video/AV1") {
        u = !0;
        break;
      }
  }
  return u;
}
function supportsVP9() {
  if (!("getCapabilities" in RTCRtpSender) || isFireFox())
    return !1;
  if (isSafari()) {
    const c = getBrowser();
    if (c != null && c.version && compareVersions(c.version, "16") < 0)
      return !1;
  }
  const a = RTCRtpSender.getCapabilities("video");
  let u = !1;
  if (a) {
    for (const c of a.codecs)
      if (c.mimeType === "video/VP9") {
        u = !0;
        break;
      }
  }
  return u;
}
function isSVCCodec(a) {
  return a === "av1" || a === "vp9";
}
function supportsSetSinkId(a) {
  return document ? (a || (a = document.createElement("audio")), "setSinkId" in a) : !1;
}
const setCodecPreferencesVersions = {
  Chrome: "100",
  Safari: "15",
  Firefox: "100"
};
function supportsSetCodecPreferences(a) {
  if (!isWeb() || !("setCodecPreferences" in a))
    return !1;
  const u = getBrowser();
  if (!(u != null && u.name) || !u.version)
    return !1;
  const c = setCodecPreferencesVersions[u.name];
  return c ? compareVersions(u.version, c) >= 0 : !1;
}
function isBrowserSupported() {
  return typeof RTCPeerConnection > "u" ? !1 : supportsTransceiver() || supportsAddTrack();
}
function isFireFox() {
  var a;
  return ((a = getBrowser()) === null || a === void 0 ? void 0 : a.name) === "Firefox";
}
function isSafari() {
  var a;
  return ((a = getBrowser()) === null || a === void 0 ? void 0 : a.name) === "Safari";
}
function isSafari17() {
  const a = getBrowser();
  return (a == null ? void 0 : a.name) === "Safari" && a.version.startsWith("17.");
}
function isMobile() {
  return isWeb() ? /Tablet|iPad|Mobile|Android|BlackBerry/.test(navigator.userAgent) : !1;
}
function isWeb() {
  return typeof document < "u";
}
function isReactNative() {
  return navigator.product == "ReactNative";
}
function isCloud(a) {
  return a.hostname.endsWith(".livekit.cloud") || a.hostname.endsWith(".livekit.run");
}
function getLKReactNativeInfo() {
  if (global$1 && global$1.LiveKitReactNativeGlobal)
    return global$1.LiveKitReactNativeGlobal;
}
function getReactNativeOs() {
  if (!isReactNative())
    return;
  let a = getLKReactNativeInfo();
  if (a)
    return a.platform;
}
function getDevicePixelRatio() {
  if (isWeb())
    return window.devicePixelRatio;
  if (isReactNative()) {
    let a = getLKReactNativeInfo();
    if (a)
      return a.devicePixelRatio;
  }
  return 1;
}
function compareVersions(a, u) {
  const c = a.split("."), l = u.split("."), v = Math.min(c.length, l.length);
  for (let p = 0; p < v; ++p) {
    const _ = parseInt(c[p], 10), k = parseInt(l[p], 10);
    if (_ > k)
      return 1;
    if (_ < k)
      return -1;
    if (p === v - 1 && _ === k)
      return 0;
  }
  return a === "" && u !== "" ? -1 : u === "" ? 1 : c.length == l.length ? 0 : c.length < l.length ? -1 : 1;
}
function roDispatchCallback(a) {
  for (const u of a)
    u.target.handleResize(u);
}
function ioDispatchCallback(a) {
  for (const u of a)
    u.target.handleVisibilityChanged(u);
}
let resizeObserver = null;
const getResizeObserver = () => (resizeObserver || (resizeObserver = new ResizeObserver(roDispatchCallback)), resizeObserver);
let intersectionObserver = null;
const getIntersectionObserver = () => (intersectionObserver || (intersectionObserver = new IntersectionObserver(ioDispatchCallback, {
  root: null,
  rootMargin: "0px"
})), intersectionObserver);
function getClientInfo() {
  var a;
  const u = new ClientInfo({
    sdk: ClientInfo_SDK.JS,
    protocol: protocolVersion,
    version: version$3
  });
  return isReactNative() && (u.os = (a = getReactNativeOs()) !== null && a !== void 0 ? a : ""), u;
}
function createDummyVideoStreamTrack() {
  let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 16, u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 16, c = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, l = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
  const v = document.createElement("canvas");
  v.width = a, v.height = u;
  const p = v.getContext("2d");
  p == null || p.fillRect(0, 0, v.width, v.height), l && p && (p.beginPath(), p.arc(a / 2, u / 2, 50, 0, Math.PI * 2, !0), p.closePath(), p.fillStyle = "grey", p.fill());
  const _ = v.captureStream(), [k] = _.getTracks();
  if (!k)
    throw Error("Could not get empty media stream video track");
  return k.enabled = c, k;
}
let emptyAudioStreamTrack;
function getEmptyAudioStreamTrack() {
  if (!emptyAudioStreamTrack) {
    const a = new AudioContext(), u = a.createOscillator(), c = a.createGain();
    c.gain.setValueAtTime(0, 0);
    const l = a.createMediaStreamDestination();
    if (u.connect(c), c.connect(l), u.start(), [emptyAudioStreamTrack] = l.stream.getAudioTracks(), !emptyAudioStreamTrack)
      throw Error("Could not get empty media stream audio track");
    emptyAudioStreamTrack.enabled = !1;
  }
  return emptyAudioStreamTrack.clone();
}
class Future {
  constructor(u, c) {
    this.onFinally = c, this.promise = new Promise((l, v) => __awaiter$3(this, void 0, void 0, function* () {
      this.resolve = l, this.reject = v, u && (yield u(l, v));
    })).finally(() => {
      var l;
      return (l = this.onFinally) === null || l === void 0 ? void 0 : l.call(this);
    });
  }
}
class Mutex {
  constructor() {
    this._locking = Promise.resolve(), this._locks = 0;
  }
  isLocked() {
    return this._locks > 0;
  }
  lock() {
    this._locks += 1;
    let u;
    const c = new Promise((v) => u = () => {
      this._locks -= 1, v();
    }), l = this._locking.then(() => u);
    return this._locking = this._locking.then(() => c), l;
  }
}
function isVideoCodec(a) {
  return videoCodecs.includes(a);
}
function unwrapConstraint(a) {
  if (typeof a == "string")
    return a;
  if (Array.isArray(a))
    return a[0];
  if (a.exact)
    return Array.isArray(a.exact) ? a.exact[0] : a.exact;
  if (a.ideal)
    return Array.isArray(a.ideal) ? a.ideal[0] : a.ideal;
  throw Error("could not unwrap constraint");
}
function toWebsocketUrl(a) {
  return a.startsWith("http") ? a.replace(/^(http)/, "ws") : a;
}
function toHttpUrl(a) {
  return a.startsWith("ws") ? a.replace(/^(ws)/, "http") : a;
}
const defaultId = "default";
class DeviceManager {
  static getInstance() {
    return this.instance === void 0 && (this.instance = new DeviceManager()), this.instance;
  }
  getDevices(u) {
    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
    var l;
    return __awaiter$3(this, void 0, void 0, function* () {
      if (((l = DeviceManager.userMediaPromiseMap) === null || l === void 0 ? void 0 : l.size) > 0) {
        livekitLogger.debug("awaiting getUserMedia promise");
        try {
          u ? yield DeviceManager.userMediaPromiseMap.get(u) : yield Promise.all(DeviceManager.userMediaPromiseMap.values());
        } catch {
          livekitLogger.warn("error waiting for media permissons");
        }
      }
      let v = yield navigator.mediaDevices.enumerateDevices();
      if (c && // for safari we need to skip this check, as otherwise it will re-acquire user media and fail on iOS https://bugs.webkit.org/show_bug.cgi?id=179363
      !(isSafari() && this.hasDeviceInUse(u)) && (v.length === 0 || v.some((_) => {
        const k = _.label === "", M = u ? _.kind === u : !0;
        return k && M;
      }))) {
        const _ = {
          video: u !== "audioinput" && u !== "audiooutput",
          audio: u !== "videoinput"
        }, k = yield navigator.mediaDevices.getUserMedia(_);
        v = yield navigator.mediaDevices.enumerateDevices(), k.getTracks().forEach((M) => {
          M.stop();
        });
      }
      return u && (v = v.filter((p) => p.kind === u)), v;
    });
  }
  normalizeDeviceId(u, c, l) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (c !== defaultId)
        return c;
      const v = yield this.getDevices(u), p = new Map(v.map((k) => [k.groupId, 0]));
      v.forEach((k) => {
        var M;
        return p.set(k.groupId, ((M = p.get(k.groupId)) !== null && M !== void 0 ? M : 0) + 1);
      });
      const _ = v.find((k) => {
        var M;
        return (l === k.groupId || ((M = p.get(k.groupId)) !== null && M !== void 0 ? M : 0) > 1) && k.deviceId !== defaultId;
      });
      return _ == null ? void 0 : _.deviceId;
    });
  }
  hasDeviceInUse(u) {
    return u ? DeviceManager.userMediaPromiseMap.has(u) : DeviceManager.userMediaPromiseMap.size > 0;
  }
}
DeviceManager.mediaDeviceKinds = ["audioinput", "audiooutput", "videoinput"];
DeviceManager.userMediaPromiseMap = /* @__PURE__ */ new Map();
const defaultDimensionsTimeout = 1e3;
class LocalTrack extends Track {
  get constraints() {
    return this._constraints;
  }
  /**
   *
   * @param mediaTrack
   * @param kind
   * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks
   * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK
   */
  constructor(u, c, l) {
    let v = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1, p = arguments.length > 4 ? arguments[4] : void 0;
    super(u, c, p), this._isUpstreamPaused = !1, this.handleTrackMuteEvent = () => this.debouncedTrackMuteHandler().catch(() => this.log.debug("track mute bounce got cancelled by an unmute event", this.logContext)), this.debouncedTrackMuteHandler = r$1(() => __awaiter$3(this, void 0, void 0, function* () {
      yield this.pauseUpstream();
    }), 5e3), this.handleTrackUnmuteEvent = () => __awaiter$3(this, void 0, void 0, function* () {
      this.debouncedTrackMuteHandler.cancel("unmute"), yield this.resumeUpstream();
    }), this.handleEnded = () => {
      this.isInBackground && (this.reacquireTrack = !0), this._mediaStreamTrack.removeEventListener("mute", this.handleTrackMuteEvent), this._mediaStreamTrack.removeEventListener("unmute", this.handleTrackUnmuteEvent), this.emit(TrackEvent.Ended, this);
    }, this.reacquireTrack = !1, this.providedByUser = v, this.muteLock = new Mutex(), this.pauseUpstreamLock = new Mutex(), this.processorLock = new Mutex(), this.restartLock = new Mutex(), this.setMediaStreamTrack(u, !0), this._constraints = u.getConstraints(), l && (this._constraints = l);
  }
  get id() {
    return this._mediaStreamTrack.id;
  }
  get dimensions() {
    if (this.kind !== Track.Kind.Video)
      return;
    const {
      width: u,
      height: c
    } = this._mediaStreamTrack.getSettings();
    if (u && c)
      return {
        width: u,
        height: c
      };
  }
  get isUpstreamPaused() {
    return this._isUpstreamPaused;
  }
  get isUserProvided() {
    return this.providedByUser;
  }
  get mediaStreamTrack() {
    var u, c;
    return (c = (u = this.processor) === null || u === void 0 ? void 0 : u.processedTrack) !== null && c !== void 0 ? c : this._mediaStreamTrack;
  }
  setMediaStreamTrack(u, c) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (u === this._mediaStreamTrack && !c)
        return;
      this._mediaStreamTrack && (this.attachedElements.forEach((v) => {
        detachTrack(this._mediaStreamTrack, v);
      }), this.debouncedTrackMuteHandler.cancel("new-track"), this._mediaStreamTrack.removeEventListener("ended", this.handleEnded), this._mediaStreamTrack.removeEventListener("mute", this.handleTrackMuteEvent), this._mediaStreamTrack.removeEventListener("unmute", this.handleTrackUnmuteEvent)), this.mediaStream = new MediaStream([u]), u && (u.addEventListener("ended", this.handleEnded), u.addEventListener("mute", this.handleTrackMuteEvent), u.addEventListener("unmute", this.handleTrackUnmuteEvent), this._constraints = u.getConstraints());
      let l;
      if (this.processor && u) {
        const v = yield this.processorLock.lock();
        try {
          if (this.log.debug("restarting processor", this.logContext), this.kind === "unknown")
            throw TypeError("cannot set processor on track of unknown kind");
          this.processorElement && (attachToElement(u, this.processorElement), this.processorElement.muted = !0), yield this.processor.restart({
            track: u,
            kind: this.kind,
            element: this.processorElement
          }), l = this.processor.processedTrack;
        } finally {
          v();
        }
      }
      this.sender && (yield this.sender.replaceTrack(l ?? u)), !this.providedByUser && this._mediaStreamTrack !== u && this._mediaStreamTrack.stop(), this._mediaStreamTrack = u, u && (this._mediaStreamTrack.enabled = !this.isMuted, yield this.resumeUpstream(), this.attachedElements.forEach((v) => {
        attachToElement(l ?? u, v);
      }));
    });
  }
  waitForDimensions() {
    let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : defaultDimensionsTimeout;
    var c;
    return __awaiter$3(this, void 0, void 0, function* () {
      if (this.kind === Track.Kind.Audio)
        throw new Error("cannot get dimensions for audio tracks");
      ((c = getBrowser()) === null || c === void 0 ? void 0 : c.os) === "iOS" && (yield sleep(10));
      const l = Date.now();
      for (; Date.now() - l < u; ) {
        const v = this.dimensions;
        if (v)
          return v;
        yield sleep(50);
      }
      throw new TrackInvalidError("unable to get track dimensions after timeout");
    });
  }
  /**
   * @returns DeviceID of the device that is currently being used for this track
   */
  getDeviceId() {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (this.source === Track.Source.ScreenShare)
        return;
      const {
        deviceId: u,
        groupId: c
      } = this._mediaStreamTrack.getSettings(), l = this.kind === Track.Kind.Audio ? "audioinput" : "videoinput";
      return DeviceManager.getInstance().normalizeDeviceId(l, u, c);
    });
  }
  mute() {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this.setTrackMuted(!0), this;
    });
  }
  unmute() {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this.setTrackMuted(!1), this;
    });
  }
  replaceTrack(u, c) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!this.sender)
        throw new TrackInvalidError("unable to replace an unpublished track");
      let l, v;
      return typeof c == "boolean" ? l = c : c !== void 0 && (l = c.userProvidedTrack, v = c.stopProcessor), this.providedByUser = l ?? !0, this.log.debug("replace MediaStreamTrack", this.logContext), yield this.setMediaStreamTrack(u), v && this.processor && (yield this.stopProcessor()), this;
    });
  }
  restart(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      const c = yield this.restartLock.lock();
      try {
        u || (u = this._constraints), this.log.debug("restarting track with constraints", Object.assign(Object.assign({}, this.logContext), {
          constraints: u
        }));
        const l = {
          audio: !1,
          video: !1
        };
        this.kind === Track.Kind.Video ? l.video = u : l.audio = u, this.attachedElements.forEach((_) => {
          detachTrack(this.mediaStreamTrack, _);
        }), this._mediaStreamTrack.removeEventListener("ended", this.handleEnded), this._mediaStreamTrack.stop();
        const p = (yield navigator.mediaDevices.getUserMedia(l)).getTracks()[0];
        return p.addEventListener("ended", this.handleEnded), this.log.debug("re-acquired MediaStreamTrack", this.logContext), yield this.setMediaStreamTrack(p), this._constraints = u, this.emit(TrackEvent.Restarted, this), this;
      } finally {
        c();
      }
    });
  }
  setTrackMuted(u) {
    this.log.debug("setting ".concat(this.kind, " track ").concat(u ? "muted" : "unmuted"), this.logContext), !(this.isMuted === u && this._mediaStreamTrack.enabled !== u) && (this.isMuted = u, this._mediaStreamTrack.enabled = !u, this.emit(u ? TrackEvent.Muted : TrackEvent.Unmuted, this));
  }
  get needsReAcquisition() {
    return this._mediaStreamTrack.readyState !== "live" || this._mediaStreamTrack.muted || !this._mediaStreamTrack.enabled || this.reacquireTrack;
  }
  handleAppVisibilityChanged() {
    const u = Object.create(null, {
      handleAppVisibilityChanged: {
        get: () => super.handleAppVisibilityChanged
      }
    });
    return __awaiter$3(this, void 0, void 0, function* () {
      yield u.handleAppVisibilityChanged.call(this), isMobile() && (this.log.debug("visibility changed, is in Background: ".concat(this.isInBackground), this.logContext), !this.isInBackground && this.needsReAcquisition && !this.isUserProvided && !this.isMuted && (this.log.debug("track needs to be reacquired, restarting ".concat(this.source), this.logContext), yield this.restart(), this.reacquireTrack = !1));
    });
  }
  stop() {
    var u;
    super.stop(), this._mediaStreamTrack.removeEventListener("ended", this.handleEnded), this._mediaStreamTrack.removeEventListener("mute", this.handleTrackMuteEvent), this._mediaStreamTrack.removeEventListener("unmute", this.handleTrackUnmuteEvent), (u = this.processor) === null || u === void 0 || u.destroy(), this.processor = void 0;
  }
  /**
   * pauses publishing to the server without disabling the local MediaStreamTrack
   * this is used to display a user's own video locally while pausing publishing to
   * the server.
   * this API is unsupported on Safari < 12 due to a bug
   **/
  pauseUpstream() {
    return __awaiter$3(this, void 0, void 0, function* () {
      const u = yield this.pauseUpstreamLock.lock();
      try {
        if (this._isUpstreamPaused === !0)
          return;
        if (!this.sender) {
          this.log.warn("unable to pause upstream for an unpublished track", this.logContext);
          return;
        }
        this._isUpstreamPaused = !0, this.emit(TrackEvent.UpstreamPaused, this);
        const c = getBrowser();
        if ((c == null ? void 0 : c.name) === "Safari" && compareVersions(c.version, "12.0") < 0)
          throw new DeviceUnsupportedError("pauseUpstream is not supported on Safari < 12.");
        yield this.sender.replaceTrack(null);
      } finally {
        u();
      }
    });
  }
  resumeUpstream() {
    return __awaiter$3(this, void 0, void 0, function* () {
      const u = yield this.pauseUpstreamLock.lock();
      try {
        if (this._isUpstreamPaused === !1)
          return;
        if (!this.sender) {
          this.log.warn("unable to resume upstream for an unpublished track", this.logContext);
          return;
        }
        this._isUpstreamPaused = !1, this.emit(TrackEvent.UpstreamResumed, this), yield this.sender.replaceTrack(this._mediaStreamTrack);
      } finally {
        u();
      }
    });
  }
  /**
   * Gets the RTCStatsReport for the LocalTrack's underlying RTCRtpSender
   * See https://developer.mozilla.org/en-US/docs/Web/API/RTCStatsReport
   *
   * @returns Promise<RTCStatsReport> | undefined
   */
  getRTCStatsReport() {
    var u;
    return __awaiter$3(this, void 0, void 0, function* () {
      return !((u = this.sender) === null || u === void 0) && u.getStats ? yield this.sender.getStats() : void 0;
    });
  }
  /**
   * Sets a processor on this track.
   * See https://github.com/livekit/track-processors-js for example usage
   *
   * @experimental
   *
   * @param processor
   * @param showProcessedStreamLocally
   * @returns
   */
  setProcessor(u) {
    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
    var l, v;
    return __awaiter$3(this, void 0, void 0, function* () {
      const p = yield this.processorLock.lock();
      try {
        this.log.debug("setting up processor", this.logContext), this.processorElement = (l = this.processorElement) !== null && l !== void 0 ? l : document.createElement(this.kind);
        const _ = {
          kind: this.kind,
          track: this._mediaStreamTrack,
          element: this.processorElement,
          audioContext: this.audioContext
        };
        if (yield u.init(_), this.processor && (yield this.stopProcessor()), this.kind === "unknown")
          throw TypeError("cannot set processor on track of unknown kind");
        if (attachToElement(this._mediaStreamTrack, this.processorElement), this.processorElement.muted = !0, this.processorElement.play().catch((k) => this.log.error("failed to play processor element", Object.assign(Object.assign({}, this.logContext), {
          error: k
        }))), this.processor = u, this.processor.processedTrack) {
          for (const k of this.attachedElements)
            k !== this.processorElement && c && (detachTrack(this._mediaStreamTrack, k), attachToElement(this.processor.processedTrack, k));
          yield (v = this.sender) === null || v === void 0 ? void 0 : v.replaceTrack(this.processor.processedTrack);
        }
        this.emit(TrackEvent.TrackProcessorUpdate, this.processor);
      } finally {
        p();
      }
    });
  }
  getProcessor() {
    return this.processor;
  }
  /**
   * Stops the track processor
   * See https://github.com/livekit/track-processors-js for example usage
   *
   * @experimental
   * @returns
   */
  stopProcessor() {
    var u, c;
    return __awaiter$3(this, void 0, void 0, function* () {
      this.processor && (this.log.debug("stopping processor", this.logContext), (u = this.processor.processedTrack) === null || u === void 0 || u.stop(), yield this.processor.destroy(), this.processor = void 0, (c = this.processorElement) === null || c === void 0 || c.remove(), this.processorElement = void 0, yield this._mediaStreamTrack.applyConstraints(this._constraints), yield this.setMediaStreamTrack(this._mediaStreamTrack, !0), this.emit(TrackEvent.TrackProcessorUpdate));
    });
  }
}
class E2EEManager extends eventsExports$1.EventEmitter {
  constructor(u) {
    super(), this.onWorkerMessage = (c) => {
      var l, v;
      const {
        kind: p,
        data: _
      } = c.data;
      switch (p) {
        case "error":
          livekitLogger.error(_.error.message), this.emit(EncryptionEvent.EncryptionError, _.error);
          break;
        case "initAck":
          _.enabled && this.keyProvider.getKeys().forEach((k) => {
            this.postKey(k);
          });
          break;
        case "enable":
          if (this.encryptionEnabled !== _.enabled && _.participantIdentity === ((l = this.room) === null || l === void 0 ? void 0 : l.localParticipant.identity))
            this.emit(EncryptionEvent.ParticipantEncryptionStatusChanged, _.enabled, this.room.localParticipant), this.encryptionEnabled = _.enabled;
          else if (_.participantIdentity) {
            const k = (v = this.room) === null || v === void 0 ? void 0 : v.getParticipantByIdentity(_.participantIdentity);
            if (!k)
              throw TypeError("couldn't set encryption status, participant not found".concat(_.participantIdentity));
            this.emit(EncryptionEvent.ParticipantEncryptionStatusChanged, _.enabled, k);
          }
          this.encryptionEnabled && this.keyProvider.getKeys().forEach((k) => {
            this.postKey(k);
          });
          break;
        case "ratchetKey":
          this.keyProvider.emit(KeyProviderEvent.KeyRatcheted, _.material, _.keyIndex);
          break;
      }
    }, this.onWorkerError = (c) => {
      livekitLogger.error("e2ee worker encountered an error:", {
        error: c.error
      }), this.emit(EncryptionEvent.EncryptionError, c.error);
    }, this.keyProvider = u.keyProvider, this.worker = u.worker, this.encryptionEnabled = !1;
  }
  /**
   * @internal
   */
  setup(u) {
    if (!isE2EESupported())
      throw new DeviceUnsupportedError("tried to setup end-to-end encryption on an unsupported browser");
    if (livekitLogger.info("setting up e2ee"), u !== this.room) {
      this.room = u, this.setupEventListeners(u, this.keyProvider);
      const c = {
        kind: "init",
        data: {
          keyProviderOptions: this.keyProvider.getOptions(),
          loglevel: workerLogger.getLevel()
        }
      };
      this.worker && (livekitLogger.info("initializing worker", {
        worker: this.worker
      }), this.worker.onmessage = this.onWorkerMessage, this.worker.onerror = this.onWorkerError, this.worker.postMessage(c));
    }
  }
  /**
   * @internal
   */
  setParticipantCryptorEnabled(u, c) {
    livekitLogger.debug("set e2ee to ".concat(u, " for participant ").concat(c)), this.postEnable(u, c);
  }
  /**
   * @internal
   */
  setSifTrailer(u) {
    !u || u.length === 0 ? livekitLogger.warn("ignoring server sent trailer as it's empty") : this.postSifTrailer(u);
  }
  setupEngine(u) {
    u.on(EngineEvent.RTPVideoMapUpdate, (c) => {
      this.postRTPMap(c);
    });
  }
  setupEventListeners(u, c) {
    u.on(RoomEvent.TrackPublished, (l, v) => this.setParticipantCryptorEnabled(l.trackInfo.encryption !== Encryption_Type.NONE, v.identity)), u.on(RoomEvent.ConnectionStateChanged, (l) => {
      l === ConnectionState.Connected && u.remoteParticipants.forEach((v) => {
        v.trackPublications.forEach((p) => {
          this.setParticipantCryptorEnabled(p.trackInfo.encryption !== Encryption_Type.NONE, v.identity);
        });
      });
    }).on(RoomEvent.TrackUnsubscribed, (l, v, p) => {
      var _;
      const k = {
        kind: "removeTransform",
        data: {
          participantIdentity: p.identity,
          trackId: l.mediaStreamID
        }
      };
      (_ = this.worker) === null || _ === void 0 || _.postMessage(k);
    }).on(RoomEvent.TrackSubscribed, (l, v, p) => {
      this.setupE2EEReceiver(l, p.identity, v.trackInfo);
    }).on(RoomEvent.SignalConnected, () => {
      if (!this.room)
        throw new TypeError("expected room to be present on signal connect");
      this.setParticipantCryptorEnabled(this.room.localParticipant.isE2EEEnabled, this.room.localParticipant.identity), c.getKeys().forEach((l) => {
        this.postKey(l);
      });
    }), u.localParticipant.on(ParticipantEvent.LocalTrackPublished, (l) => __awaiter$3(this, void 0, void 0, function* () {
      this.setupE2EESender(l.track, l.track.sender);
    })), c.on(KeyProviderEvent.SetKey, (l) => this.postKey(l)).on(KeyProviderEvent.RatchetRequest, (l, v) => this.postRatchetRequest(l, v));
  }
  postRatchetRequest(u, c) {
    if (!this.worker)
      throw Error("could not ratchet key, worker is missing");
    const l = {
      kind: "ratchetRequest",
      data: {
        participantIdentity: u,
        keyIndex: c
      }
    };
    this.worker.postMessage(l);
  }
  postKey(u) {
    let {
      key: c,
      participantIdentity: l,
      keyIndex: v
    } = u;
    var p;
    if (!this.worker)
      throw Error("could not set key, worker is missing");
    const _ = {
      kind: "setKey",
      data: {
        participantIdentity: l,
        isPublisher: l === ((p = this.room) === null || p === void 0 ? void 0 : p.localParticipant.identity),
        key: c,
        keyIndex: v
      }
    };
    this.worker.postMessage(_);
  }
  postEnable(u, c) {
    if (this.worker) {
      const l = {
        kind: "enable",
        data: {
          enabled: u,
          participantIdentity: c
        }
      };
      this.worker.postMessage(l);
    } else
      throw new ReferenceError("failed to enable e2ee, worker is not ready");
  }
  postRTPMap(u) {
    var c;
    if (!this.worker)
      throw TypeError("could not post rtp map, worker is missing");
    if (!(!((c = this.room) === null || c === void 0) && c.localParticipant.identity))
      throw TypeError("could not post rtp map, local participant identity is missing");
    const l = {
      kind: "setRTPMap",
      data: {
        map: u,
        participantIdentity: this.room.localParticipant.identity
      }
    };
    this.worker.postMessage(l);
  }
  postSifTrailer(u) {
    if (!this.worker)
      throw Error("could not post SIF trailer, worker is missing");
    const c = {
      kind: "setSifTrailer",
      data: {
        trailer: u
      }
    };
    this.worker.postMessage(c);
  }
  setupE2EEReceiver(u, c, l) {
    if (u.receiver) {
      if (!(l != null && l.mimeType) || l.mimeType === "")
        throw new TypeError("MimeType missing from trackInfo, cannot set up E2EE cryptor");
      this.handleReceiver(u.receiver, u.mediaStreamID, c, u.kind === "video" ? mimeTypeToVideoCodecString(l.mimeType) : void 0);
    }
  }
  setupE2EESender(u, c) {
    if (!(u instanceof LocalTrack) || !c) {
      c || livekitLogger.warn("early return because sender is not ready");
      return;
    }
    this.handleSender(c, u.mediaStreamID, void 0);
  }
  /**
   * Handles the given {@code RTCRtpReceiver} by creating a {@code TransformStream} which will inject
   * a frame decoder.
   *
   */
  handleReceiver(u, c, l, v) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (this.worker) {
        if (isScriptTransformSupported()) {
          const p = {
            kind: "decode",
            participantIdentity: l,
            trackId: c,
            codec: v
          };
          u.transform = new RTCRtpScriptTransform(this.worker, p);
        } else {
          if (E2EE_FLAG in u && v) {
            const M = {
              kind: "updateCodec",
              data: {
                trackId: c,
                codec: v,
                participantIdentity: l
              }
            };
            this.worker.postMessage(M);
            return;
          }
          let p = u.writableStream, _ = u.readableStream;
          if (!p || !_) {
            const M = u.createEncodedStreams();
            u.writableStream = M.writable, p = M.writable, u.readableStream = M.readable, _ = M.readable;
          }
          const k = {
            kind: "decode",
            data: {
              readableStream: _,
              writableStream: p,
              trackId: c,
              codec: v,
              participantIdentity: l
            }
          };
          this.worker.postMessage(k, [_, p]);
        }
        u[E2EE_FLAG] = !0;
      }
    });
  }
  /**
   * Handles the given {@code RTCRtpSender} by creating a {@code TransformStream} which will inject
   * a frame encoder.
   *
   */
  handleSender(u, c, l) {
    var v;
    if (!(E2EE_FLAG in u || !this.worker)) {
      if (!(!((v = this.room) === null || v === void 0) && v.localParticipant.identity) || this.room.localParticipant.identity === "")
        throw TypeError("local identity needs to be known in order to set up encrypted sender");
      if (isScriptTransformSupported()) {
        livekitLogger.info("initialize script transform");
        const p = {
          kind: "encode",
          participantIdentity: this.room.localParticipant.identity,
          trackId: c,
          codec: l
        };
        u.transform = new RTCRtpScriptTransform(this.worker, p);
      } else {
        livekitLogger.info("initialize encoded streams");
        const p = u.createEncodedStreams(), _ = {
          kind: "encode",
          data: {
            readableStream: p.readable,
            writableStream: p.writable,
            codec: l,
            trackId: c,
            participantIdentity: this.room.localParticipant.identity
          }
        };
        this.worker.postMessage(_, [p.readable, p.writable]);
      }
      u[E2EE_FLAG] = !0;
    }
  }
}
var QueueTaskStatus;
(function(a) {
  a[a.WAITING = 0] = "WAITING", a[a.RUNNING = 1] = "RUNNING", a[a.COMPLETED = 2] = "COMPLETED";
})(QueueTaskStatus || (QueueTaskStatus = {}));
class AsyncQueue {
  constructor() {
    this.pendingTasks = /* @__PURE__ */ new Map(), this.taskMutex = new Mutex(), this.nextTaskIndex = 0;
  }
  run(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      const c = {
        id: this.nextTaskIndex++,
        enqueuedAt: Date.now(),
        status: QueueTaskStatus.WAITING
      };
      this.pendingTasks.set(c.id, c);
      const l = yield this.taskMutex.lock();
      try {
        return c.executedAt = Date.now(), c.status = QueueTaskStatus.RUNNING, yield u();
      } finally {
        c.status = QueueTaskStatus.COMPLETED, this.pendingTasks.delete(c.id), l();
      }
    });
  }
  flush() {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this.run(() => __awaiter$3(this, void 0, void 0, function* () {
      }));
    });
  }
  snapshot() {
    return Array.from(this.pendingTasks.values());
  }
}
const passThroughQueueSignals = ["syncState", "trickle", "offer", "answer", "simulate", "leave"];
function canPassThroughQueue(a) {
  const u = passThroughQueueSignals.indexOf(a.case) >= 0;
  return livekitLogger.trace("request allowed to bypass queue:", {
    canPass: u,
    req: a
  }), u;
}
var SignalConnectionState;
(function(a) {
  a[a.CONNECTING = 0] = "CONNECTING", a[a.CONNECTED = 1] = "CONNECTED", a[a.RECONNECTING = 2] = "RECONNECTING", a[a.DISCONNECTING = 3] = "DISCONNECTING", a[a.DISCONNECTED = 4] = "DISCONNECTED";
})(SignalConnectionState || (SignalConnectionState = {}));
class SignalClient {
  get currentState() {
    return this.state;
  }
  get isDisconnected() {
    return this.state === SignalConnectionState.DISCONNECTING || this.state === SignalConnectionState.DISCONNECTED;
  }
  get isEstablishingConnection() {
    return this.state === SignalConnectionState.CONNECTING || this.state === SignalConnectionState.RECONNECTING;
  }
  constructor() {
    let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1, c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var l;
    this.rtt = 0, this.state = SignalConnectionState.DISCONNECTED, this.log = livekitLogger, this.resetCallbacks = () => {
      this.onAnswer = void 0, this.onLeave = void 0, this.onLocalTrackPublished = void 0, this.onLocalTrackUnpublished = void 0, this.onNegotiateRequested = void 0, this.onOffer = void 0, this.onRemoteMuteChanged = void 0, this.onSubscribedQualityUpdate = void 0, this.onTokenRefresh = void 0, this.onTrickle = void 0, this.onClose = void 0;
    }, this.log = getLogger((l = c.loggerName) !== null && l !== void 0 ? l : LoggerNames.Signal), this.loggerContextCb = c.loggerContextCb, this.useJSON = u, this.requestQueue = new AsyncQueue(), this.queuedRequests = [], this.closingLock = new Mutex(), this.connectionLock = new Mutex(), this.state = SignalConnectionState.DISCONNECTED;
  }
  get logContext() {
    var u, c;
    return (c = (u = this.loggerContextCb) === null || u === void 0 ? void 0 : u.call(this)) !== null && c !== void 0 ? c : {};
  }
  join(u, c, l, v) {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this.state = SignalConnectionState.CONNECTING, this.options = l, yield this.connect(u, c, l, v);
    });
  }
  reconnect(u, c, l, v) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!this.options) {
        this.log.warn("attempted to reconnect without signal options being set, ignoring", this.logContext);
        return;
      }
      return this.state = SignalConnectionState.RECONNECTING, this.clearPingInterval(), yield this.connect(u, c, Object.assign(Object.assign({}, this.options), {
        reconnect: !0,
        sid: l,
        reconnectReason: v
      }));
    });
  }
  connect(u, c, l, v) {
    this.connectOptions = l, u = toWebsocketUrl(u), u = u.replace(/\/$/, ""), u += "/rtc";
    const p = getClientInfo(), _ = createConnectionParams(c, p, l);
    return new Promise((k, M) => __awaiter$3(this, void 0, void 0, function* () {
      const L = yield this.connectionLock.lock();
      try {
        const F = () => __awaiter$3(this, void 0, void 0, function* () {
          this.close(), clearTimeout(V), M(new ConnectionError("room connection has been cancelled (signal)"));
        }), V = setTimeout(() => {
          this.close(), M(new ConnectionError("room connection has timed out (signal)"));
        }, l.websocketTimeout);
        v != null && v.aborted && F(), v == null || v.addEventListener("abort", F), this.log.debug("connecting to ".concat(u + _), this.logContext), this.ws && (yield this.close(!1)), this.ws = new WebSocket(u + _), this.ws.binaryType = "arraybuffer", this.ws.onopen = () => {
          clearTimeout(V);
        }, this.ws.onerror = (X) => __awaiter$3(this, void 0, void 0, function* () {
          if (this.state !== SignalConnectionState.CONNECTED) {
            this.state = SignalConnectionState.DISCONNECTED, clearTimeout(V);
            try {
              const oe = yield fetch("http".concat(u.substring(2), "/validate").concat(_));
              if (oe.status.toFixed(0).startsWith("4")) {
                const Y = yield oe.text();
                M(new ConnectionError(Y, 0, oe.status));
              } else
                M(new ConnectionError("Internal error", 2, oe.status));
            } catch {
              M(new ConnectionError(
                "server was not reachable",
                1
                /* ConnectionErrorReason.ServerUnreachable */
              ));
            }
            return;
          }
          this.handleWSError(X);
        }), this.ws.onmessage = (X) => __awaiter$3(this, void 0, void 0, function* () {
          var oe, Y, ae;
          let ne;
          if (typeof X.data == "string") {
            const fe = JSON.parse(X.data);
            ne = SignalResponse.fromJson(fe, {
              ignoreUnknownFields: !0
            });
          } else if (X.data instanceof ArrayBuffer)
            ne = SignalResponse.fromBinary(new Uint8Array(X.data));
          else {
            this.log.error("could not decode websocket message: ".concat(typeof X.data), this.logContext);
            return;
          }
          if (this.state !== SignalConnectionState.CONNECTED) {
            let fe = !1;
            if (((oe = ne.message) === null || oe === void 0 ? void 0 : oe.case) === "join" ? (this.state = SignalConnectionState.CONNECTED, v == null || v.removeEventListener("abort", F), this.pingTimeoutDuration = ne.message.value.pingTimeout, this.pingIntervalDuration = ne.message.value.pingInterval, this.pingTimeoutDuration && this.pingTimeoutDuration > 0 && (this.log.debug("ping config", Object.assign(Object.assign({}, this.logContext), {
              timeout: this.pingTimeoutDuration,
              interval: this.pingIntervalDuration
            })), this.startPingInterval()), k(ne.message.value)) : this.state === SignalConnectionState.RECONNECTING && ne.message.case !== "leave" ? (this.state = SignalConnectionState.CONNECTED, v == null || v.removeEventListener("abort", F), this.startPingInterval(), ((Y = ne.message) === null || Y === void 0 ? void 0 : Y.case) === "reconnect" ? k(ne.message.value) : (this.log.debug("declaring signal reconnected without reconnect response received", this.logContext), k(void 0), fe = !0)) : this.isEstablishingConnection && ne.message.case === "leave" ? M(new ConnectionError(
              "Received leave request while trying to (re)connect",
              4
              /* ConnectionErrorReason.LeaveRequest */
            )) : l.reconnect || M(new ConnectionError("did not receive join response, got ".concat((ae = ne.message) === null || ae === void 0 ? void 0 : ae.case, " instead"))), !fe)
              return;
          }
          this.signalLatency && (yield sleep(this.signalLatency)), this.handleSignalResponse(ne);
        }), this.ws.onclose = (X) => {
          this.isEstablishingConnection && M(new ConnectionError("Websocket got closed during a (re)connection attempt")), this.log.warn("websocket closed", Object.assign(Object.assign({}, this.logContext), {
            reason: X.reason,
            code: X.code,
            wasClean: X.wasClean,
            state: this.state
          })), this.handleOnClose(X.reason);
        };
      } finally {
        L();
      }
    }));
  }
  close() {
    let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
    return __awaiter$3(this, void 0, void 0, function* () {
      const c = yield this.closingLock.lock();
      try {
        if (u && (this.state = SignalConnectionState.DISCONNECTING), this.ws) {
          this.ws.onmessage = null, this.ws.onopen = null, this.ws.onclose = null;
          const l = new Promise((v) => {
            this.ws ? this.ws.onclose = () => {
              v();
            } : v();
          });
          this.ws.readyState < this.ws.CLOSING && (this.ws.close(), yield Promise.race([l, sleep(250)])), this.ws = void 0;
        }
      } finally {
        u && (this.state = SignalConnectionState.DISCONNECTED), this.clearPingInterval(), c();
      }
    });
  }
  // initial offer after joining
  sendOffer(u) {
    this.log.debug("sending offer", Object.assign(Object.assign({}, this.logContext), {
      offerSdp: u.sdp
    })), this.sendRequest({
      case: "offer",
      value: toProtoSessionDescription(u)
    });
  }
  // answer a server-initiated offer
  sendAnswer(u) {
    return this.log.debug("sending answer", Object.assign(Object.assign({}, this.logContext), {
      answerSdp: u.sdp
    })), this.sendRequest({
      case: "answer",
      value: toProtoSessionDescription(u)
    });
  }
  sendIceCandidate(u, c) {
    return this.log.trace("sending ice candidate", Object.assign(Object.assign({}, this.logContext), {
      candidate: u
    })), this.sendRequest({
      case: "trickle",
      value: new TrickleRequest({
        candidateInit: JSON.stringify(u),
        target: c
      })
    });
  }
  sendMuteTrack(u, c) {
    return this.sendRequest({
      case: "mute",
      value: new MuteTrackRequest({
        sid: u,
        muted: c
      })
    });
  }
  sendAddTrack(u) {
    return this.sendRequest({
      case: "addTrack",
      value: u
    });
  }
  sendUpdateLocalMetadata(u, c) {
    return this.sendRequest({
      case: "updateMetadata",
      value: new UpdateParticipantMetadata({
        metadata: u,
        name: c
      })
    });
  }
  sendUpdateTrackSettings(u) {
    this.sendRequest({
      case: "trackSetting",
      value: u
    });
  }
  sendUpdateSubscription(u) {
    return this.sendRequest({
      case: "subscription",
      value: u
    });
  }
  sendSyncState(u) {
    return this.sendRequest({
      case: "syncState",
      value: u
    });
  }
  sendUpdateVideoLayers(u, c) {
    return this.sendRequest({
      case: "updateLayers",
      value: new UpdateVideoLayers({
        trackSid: u,
        layers: c
      })
    });
  }
  sendUpdateSubscriptionPermissions(u, c) {
    return this.sendRequest({
      case: "subscriptionPermission",
      value: new SubscriptionPermission({
        allParticipants: u,
        trackPermissions: c
      })
    });
  }
  sendSimulateScenario(u) {
    return this.sendRequest({
      case: "simulate",
      value: u
    });
  }
  sendPing() {
    return Promise.all([this.sendRequest({
      case: "ping",
      value: protoInt64.parse(Date.now())
    }), this.sendRequest({
      case: "pingReq",
      value: new Ping({
        timestamp: protoInt64.parse(Date.now()),
        rtt: protoInt64.parse(this.rtt)
      })
    })]);
  }
  sendLeave() {
    return this.sendRequest({
      case: "leave",
      value: new LeaveRequest({
        canReconnect: !1,
        reason: DisconnectReason.CLIENT_INITIATED
      })
    });
  }
  sendRequest(u) {
    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!c && !canPassThroughQueue(u) && this.state === SignalConnectionState.RECONNECTING) {
        this.queuedRequests.push(() => __awaiter$3(this, void 0, void 0, function* () {
          yield this.sendRequest(u, !0);
        }));
        return;
      }
      if (c || (yield this.requestQueue.flush()), this.signalLatency && (yield sleep(this.signalLatency)), !this.ws || this.ws.readyState !== this.ws.OPEN) {
        this.log.error("cannot send signal request before connected, type: ".concat(u == null ? void 0 : u.case), this.logContext);
        return;
      }
      const v = new SignalRequest({
        message: u
      });
      try {
        this.useJSON ? this.ws.send(v.toJsonString()) : this.ws.send(v.toBinary());
      } catch (p) {
        this.log.error("error sending signal message", Object.assign(Object.assign({}, this.logContext), {
          error: p
        }));
      }
    });
  }
  handleSignalResponse(u) {
    var c, l;
    const v = u.message;
    if (v == null) {
      this.log.debug("received unsupported message", this.logContext);
      return;
    }
    let p = !1;
    if (v.case === "answer") {
      const _ = fromProtoSessionDescription(v.value);
      this.onAnswer && this.onAnswer(_);
    } else if (v.case === "offer") {
      const _ = fromProtoSessionDescription(v.value);
      this.onOffer && this.onOffer(_);
    } else if (v.case === "trickle") {
      const _ = JSON.parse(v.value.candidateInit);
      this.onTrickle && this.onTrickle(_, v.value.target);
    } else
      v.case === "update" ? this.onParticipantUpdate && this.onParticipantUpdate((c = v.value.participants) !== null && c !== void 0 ? c : []) : v.case === "trackPublished" ? this.onLocalTrackPublished && this.onLocalTrackPublished(v.value) : v.case === "speakersChanged" ? this.onSpeakersChanged && this.onSpeakersChanged((l = v.value.speakers) !== null && l !== void 0 ? l : []) : v.case === "leave" ? this.onLeave && this.onLeave(v.value) : v.case === "mute" ? this.onRemoteMuteChanged && this.onRemoteMuteChanged(v.value.sid, v.value.muted) : v.case === "roomUpdate" ? this.onRoomUpdate && v.value.room && this.onRoomUpdate(v.value.room) : v.case === "connectionQuality" ? this.onConnectionQuality && this.onConnectionQuality(v.value) : v.case === "streamStateUpdate" ? this.onStreamStateUpdate && this.onStreamStateUpdate(v.value) : v.case === "subscribedQualityUpdate" ? this.onSubscribedQualityUpdate && this.onSubscribedQualityUpdate(v.value) : v.case === "subscriptionPermissionUpdate" ? this.onSubscriptionPermissionUpdate && this.onSubscriptionPermissionUpdate(v.value) : v.case === "refreshToken" ? this.onTokenRefresh && this.onTokenRefresh(v.value) : v.case === "trackUnpublished" ? this.onLocalTrackUnpublished && this.onLocalTrackUnpublished(v.value) : v.case === "subscriptionResponse" ? this.onSubscriptionError && this.onSubscriptionError(v.value) : v.case === "pong" || (v.case === "pongResp" ? (this.rtt = Date.now() - Number.parseInt(v.value.lastPingTimestamp.toString()), this.resetPingTimeout(), p = !0) : this.log.debug("unsupported message", Object.assign(Object.assign({}, this.logContext), {
        msgCase: v.case
      })));
    p || this.resetPingTimeout();
  }
  setReconnected() {
    for (; this.queuedRequests.length > 0; ) {
      const u = this.queuedRequests.shift();
      u && this.requestQueue.run(u);
    }
  }
  handleOnClose(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (this.state === SignalConnectionState.DISCONNECTED)
        return;
      const c = this.onClose;
      yield this.close(), this.log.debug("websocket connection closed: ".concat(u), Object.assign(Object.assign({}, this.logContext), {
        reason: u
      })), c && c(u);
    });
  }
  handleWSError(u) {
    this.log.error("websocket error", Object.assign(Object.assign({}, this.logContext), {
      error: u
    }));
  }
  /**
   * Resets the ping timeout and starts a new timeout.
   * Call this after receiving a pong message
   */
  resetPingTimeout() {
    if (this.clearPingTimeout(), !this.pingTimeoutDuration) {
      this.log.warn("ping timeout duration not set", this.logContext);
      return;
    }
    this.pingTimeout = CriticalTimers.setTimeout(() => {
      this.log.warn("ping timeout triggered. last pong received at: ".concat(new Date(Date.now() - this.pingTimeoutDuration * 1e3).toUTCString()), this.logContext), this.handleOnClose("ping timeout");
    }, this.pingTimeoutDuration * 1e3);
  }
  /**
   * Clears ping timeout (does not start a new timeout)
   */
  clearPingTimeout() {
    this.pingTimeout && CriticalTimers.clearTimeout(this.pingTimeout);
  }
  startPingInterval() {
    if (this.clearPingInterval(), this.resetPingTimeout(), !this.pingIntervalDuration) {
      this.log.warn("ping interval duration not set", this.logContext);
      return;
    }
    this.log.debug("start ping interval", this.logContext), this.pingInterval = CriticalTimers.setInterval(() => {
      this.sendPing();
    }, this.pingIntervalDuration * 1e3);
  }
  clearPingInterval() {
    this.log.debug("clearing ping interval", this.logContext), this.clearPingTimeout(), this.pingInterval && CriticalTimers.clearInterval(this.pingInterval);
  }
}
function fromProtoSessionDescription(a) {
  const u = {
    type: "offer",
    sdp: a.sdp
  };
  switch (a.type) {
    case "answer":
    case "offer":
    case "pranswer":
    case "rollback":
      u.type = a.type;
      break;
  }
  return u;
}
function toProtoSessionDescription(a) {
  return new SessionDescription({
    sdp: a.sdp,
    type: a.type
  });
}
function createConnectionParams(a, u, c) {
  var l;
  const v = new URLSearchParams();
  return v.set("access_token", a), c.reconnect && (v.set("reconnect", "1"), c.sid && v.set("sid", c.sid)), v.set("auto_subscribe", c.autoSubscribe ? "1" : "0"), v.set("sdk", isReactNative() ? "reactnative" : "js"), v.set("version", u.version), v.set("protocol", u.protocol.toString()), u.deviceModel && v.set("device_model", u.deviceModel), u.os && v.set("os", u.os), u.osVersion && v.set("os_version", u.osVersion), u.browser && v.set("browser", u.browser), u.browserVersion && v.set("browser_version", u.browserVersion), c.adaptiveStream && v.set("adaptive_stream", "1"), c.reconnectReason && v.set("reconnect_reason", c.reconnectReason.toString()), !((l = navigator.connection) === null || l === void 0) && l.type && v.set("network", navigator.connection.type), "?".concat(v.toString());
}
var parser$1 = {}, grammar$2 = { exports: {} }, grammar$1 = grammar$2.exports = {
  v: [{
    name: "version",
    reg: /^(\d*)$/
  }],
  o: [{
    // o=- 20518 0 IN IP4 203.0.113.1
    // NB: sessionId will be a String in most cases because it is huge
    name: "origin",
    reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,
    names: ["username", "sessionId", "sessionVersion", "netType", "ipVer", "address"],
    format: "%s %s %d %s IP%d %s"
  }],
  // default parsing of these only (though some of these feel outdated)
  s: [{
    name: "name"
  }],
  i: [{
    name: "description"
  }],
  u: [{
    name: "uri"
  }],
  e: [{
    name: "email"
  }],
  p: [{
    name: "phone"
  }],
  z: [{
    name: "timezones"
  }],
  // TODO: this one can actually be parsed properly...
  r: [{
    name: "repeats"
  }],
  // TODO: this one can also be parsed properly
  // k: [{}], // outdated thing ignored
  t: [{
    // t=0 0
    name: "timing",
    reg: /^(\d*) (\d*)/,
    names: ["start", "stop"],
    format: "%d %d"
  }],
  c: [{
    // c=IN IP4 10.47.197.26
    name: "connection",
    reg: /^IN IP(\d) (\S*)/,
    names: ["version", "ip"],
    format: "IN IP%d %s"
  }],
  b: [{
    // b=AS:4000
    push: "bandwidth",
    reg: /^(TIAS|AS|CT|RR|RS):(\d*)/,
    names: ["type", "limit"],
    format: "%s:%s"
  }],
  m: [{
    // m=video 51744 RTP/AVP 126 97 98 34 31
    // NB: special - pushes to session
    // TODO: rtp/fmtp should be filtered by the payloads found here?
    reg: /^(\w*) (\d*) ([\w/]*)(?: (.*))?/,
    names: ["type", "port", "protocol", "payloads"],
    format: "%s %d %s %s"
  }],
  a: [
    {
      // a=rtpmap:110 opus/48000/2
      push: "rtp",
      reg: /^rtpmap:(\d*) ([\w\-.]*)(?:\s*\/(\d*)(?:\s*\/(\S*))?)?/,
      names: ["payload", "codec", "rate", "encoding"],
      format: function(a) {
        return a.encoding ? "rtpmap:%d %s/%s/%s" : a.rate ? "rtpmap:%d %s/%s" : "rtpmap:%d %s";
      }
    },
    {
      // a=fmtp:108 profile-level-id=24;object=23;bitrate=64000
      // a=fmtp:111 minptime=10; useinbandfec=1
      push: "fmtp",
      reg: /^fmtp:(\d*) ([\S| ]*)/,
      names: ["payload", "config"],
      format: "fmtp:%d %s"
    },
    {
      // a=control:streamid=0
      name: "control",
      reg: /^control:(.*)/,
      format: "control:%s"
    },
    {
      // a=rtcp:65179 IN IP4 193.84.77.194
      name: "rtcp",
      reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,
      names: ["port", "netType", "ipVer", "address"],
      format: function(a) {
        return a.address != null ? "rtcp:%d %s IP%d %s" : "rtcp:%d";
      }
    },
    {
      // a=rtcp-fb:98 trr-int 100
      push: "rtcpFbTrrInt",
      reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/,
      names: ["payload", "value"],
      format: "rtcp-fb:%s trr-int %d"
    },
    {
      // a=rtcp-fb:98 nack rpsi
      push: "rtcpFb",
      reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,
      names: ["payload", "type", "subtype"],
      format: function(a) {
        return a.subtype != null ? "rtcp-fb:%s %s %s" : "rtcp-fb:%s %s";
      }
    },
    {
      // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
      // a=extmap:1/recvonly URI-gps-string
      // a=extmap:3 urn:ietf:params:rtp-hdrext:encrypt urn:ietf:params:rtp-hdrext:smpte-tc 25@600/24
      push: "ext",
      reg: /^extmap:(\d+)(?:\/(\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\S*)(?: (\S*))?/,
      names: ["value", "direction", "encrypt-uri", "uri", "config"],
      format: function(a) {
        return "extmap:%d" + (a.direction ? "/%s" : "%v") + (a["encrypt-uri"] ? " %s" : "%v") + " %s" + (a.config ? " %s" : "");
      }
    },
    {
      // a=extmap-allow-mixed
      name: "extmapAllowMixed",
      reg: /^(extmap-allow-mixed)/
    },
    {
      // a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32
      push: "crypto",
      reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,
      names: ["id", "suite", "config", "sessionConfig"],
      format: function(a) {
        return a.sessionConfig != null ? "crypto:%d %s %s %s" : "crypto:%d %s %s";
      }
    },
    {
      // a=setup:actpass
      name: "setup",
      reg: /^setup:(\w*)/,
      format: "setup:%s"
    },
    {
      // a=connection:new
      name: "connectionType",
      reg: /^connection:(new|existing)/,
      format: "connection:%s"
    },
    {
      // a=mid:1
      name: "mid",
      reg: /^mid:([^\s]*)/,
      format: "mid:%s"
    },
    {
      // a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a
      name: "msid",
      reg: /^msid:(.*)/,
      format: "msid:%s"
    },
    {
      // a=ptime:20
      name: "ptime",
      reg: /^ptime:(\d*(?:\.\d*)*)/,
      format: "ptime:%d"
    },
    {
      // a=maxptime:60
      name: "maxptime",
      reg: /^maxptime:(\d*(?:\.\d*)*)/,
      format: "maxptime:%d"
    },
    {
      // a=sendrecv
      name: "direction",
      reg: /^(sendrecv|recvonly|sendonly|inactive)/
    },
    {
      // a=ice-lite
      name: "icelite",
      reg: /^(ice-lite)/
    },
    {
      // a=ice-ufrag:F7gI
      name: "iceUfrag",
      reg: /^ice-ufrag:(\S*)/,
      format: "ice-ufrag:%s"
    },
    {
      // a=ice-pwd:x9cml/YzichV2+XlhiMu8g
      name: "icePwd",
      reg: /^ice-pwd:(\S*)/,
      format: "ice-pwd:%s"
    },
    {
      // a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33
      name: "fingerprint",
      reg: /^fingerprint:(\S*) (\S*)/,
      names: ["type", "hash"],
      format: "fingerprint:%s %s"
    },
    {
      // a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host
      // a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10
      // a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10
      // a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10
      // a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10
      push: "candidates",
      reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?(?: network-id (\d*))?(?: network-cost (\d*))?/,
      names: ["foundation", "component", "transport", "priority", "ip", "port", "type", "raddr", "rport", "tcptype", "generation", "network-id", "network-cost"],
      format: function(a) {
        var u = "candidate:%s %d %s %d %s %d typ %s";
        return u += a.raddr != null ? " raddr %s rport %d" : "%v%v", u += a.tcptype != null ? " tcptype %s" : "%v", a.generation != null && (u += " generation %d"), u += a["network-id"] != null ? " network-id %d" : "%v", u += a["network-cost"] != null ? " network-cost %d" : "%v", u;
      }
    },
    {
      // a=end-of-candidates (keep after the candidates line for readability)
      name: "endOfCandidates",
      reg: /^(end-of-candidates)/
    },
    {
      // a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...
      name: "remoteCandidates",
      reg: /^remote-candidates:(.*)/,
      format: "remote-candidates:%s"
    },
    {
      // a=ice-options:google-ice
      name: "iceOptions",
      reg: /^ice-options:(\S*)/,
      format: "ice-options:%s"
    },
    {
      // a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1
      push: "ssrcs",
      reg: /^ssrc:(\d*) ([\w_-]*)(?::(.*))?/,
      names: ["id", "attribute", "value"],
      format: function(a) {
        var u = "ssrc:%d";
        return a.attribute != null && (u += " %s", a.value != null && (u += ":%s")), u;
      }
    },
    {
      // a=ssrc-group:FEC 1 2
      // a=ssrc-group:FEC-FR 3004364195 1080772241
      push: "ssrcGroups",
      // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E
      reg: /^ssrc-group:([\x21\x23\x24\x25\x26\x27\x2A\x2B\x2D\x2E\w]*) (.*)/,
      names: ["semantics", "ssrcs"],
      format: "ssrc-group:%s %s"
    },
    {
      // a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV
      name: "msidSemantic",
      reg: /^msid-semantic:\s?(\w*) (\S*)/,
      names: ["semantic", "token"],
      format: "msid-semantic: %s %s"
      // space after ':' is not accidental
    },
    {
      // a=group:BUNDLE audio video
      push: "groups",
      reg: /^group:(\w*) (.*)/,
      names: ["type", "mids"],
      format: "group:%s %s"
    },
    {
      // a=rtcp-mux
      name: "rtcpMux",
      reg: /^(rtcp-mux)/
    },
    {
      // a=rtcp-rsize
      name: "rtcpRsize",
      reg: /^(rtcp-rsize)/
    },
    {
      // a=sctpmap:5000 webrtc-datachannel 1024
      name: "sctpmap",
      reg: /^sctpmap:([\w_/]*) (\S*)(?: (\S*))?/,
      names: ["sctpmapNumber", "app", "maxMessageSize"],
      format: function(a) {
        return a.maxMessageSize != null ? "sctpmap:%s %s %s" : "sctpmap:%s %s";
      }
    },
    {
      // a=x-google-flag:conference
      name: "xGoogleFlag",
      reg: /^x-google-flag:([^\s]*)/,
      format: "x-google-flag:%s"
    },
    {
      // a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0
      push: "rids",
      reg: /^rid:([\d\w]+) (\w+)(?: ([\S| ]*))?/,
      names: ["id", "direction", "params"],
      format: function(a) {
        return a.params ? "rid:%s %s %s" : "rid:%s %s";
      }
    },
    {
      // a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]
      // a=imageattr:* send [x=800,y=640] recv *
      // a=imageattr:100 recv [x=320,y=240]
      push: "imageattrs",
      reg: new RegExp(
        // a=imageattr:97
        "^imageattr:(\\d+|\\*)[\\s\\t]+(send|recv)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*)(?:[\\s\\t]+(recv|send)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*))?"
      ),
      names: ["pt", "dir1", "attrs1", "dir2", "attrs2"],
      format: function(a) {
        return "imageattr:%s %s %s" + (a.dir2 ? " %s %s" : "");
      }
    },
    {
      // a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8
      // a=simulcast:recv 1;4,5 send 6;7
      name: "simulcast",
      reg: new RegExp(
        // a=simulcast:
        "^simulcast:(send|recv) ([a-zA-Z0-9\\-_~;,]+)(?:\\s?(send|recv) ([a-zA-Z0-9\\-_~;,]+))?$"
      ),
      names: ["dir1", "list1", "dir2", "list2"],
      format: function(a) {
        return "simulcast:%s %s" + (a.dir2 ? " %s %s" : "");
      }
    },
    {
      // old simulcast draft 03 (implemented by Firefox)
      //   https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03
      // a=simulcast: recv pt=97;98 send pt=97
      // a=simulcast: send rid=5;6;7 paused=6,7
      name: "simulcast_03",
      reg: /^simulcast:[\s\t]+([\S+\s\t]+)$/,
      names: ["value"],
      format: "simulcast: %s"
    },
    {
      // a=framerate:25
      // a=framerate:29.97
      name: "framerate",
      reg: /^framerate:(\d+(?:$|\.\d+))/,
      format: "framerate:%s"
    },
    {
      // RFC4570
      // a=source-filter: incl IN IP4 239.5.2.31 10.1.15.5
      name: "sourceFilter",
      reg: /^source-filter: *(excl|incl) (\S*) (IP4|IP6|\*) (\S*) (.*)/,
      names: ["filterMode", "netType", "addressTypes", "destAddress", "srcList"],
      format: "source-filter: %s %s %s %s %s"
    },
    {
      // a=bundle-only
      name: "bundleOnly",
      reg: /^(bundle-only)/
    },
    {
      // a=label:1
      name: "label",
      reg: /^label:(.+)/,
      format: "label:%s"
    },
    {
      // RFC version 26 for SCTP over DTLS
      // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-5
      name: "sctpPort",
      reg: /^sctp-port:(\d+)$/,
      format: "sctp-port:%s"
    },
    {
      // RFC version 26 for SCTP over DTLS
      // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-6
      name: "maxMessageSize",
      reg: /^max-message-size:(\d+)$/,
      format: "max-message-size:%s"
    },
    {
      // RFC7273
      // a=ts-refclk:ptp=IEEE1588-2008:39-A7-94-FF-FE-07-CB-D0:37
      push: "tsRefClocks",
      reg: /^ts-refclk:([^\s=]*)(?:=(\S*))?/,
      names: ["clksrc", "clksrcExt"],
      format: function(a) {
        return "ts-refclk:%s" + (a.clksrcExt != null ? "=%s" : "");
      }
    },
    {
      // RFC7273
      // a=mediaclk:direct=963214424
      name: "mediaClk",
      reg: /^mediaclk:(?:id=(\S*))? *([^\s=]*)(?:=(\S*))?(?: *rate=(\d+)\/(\d+))?/,
      names: ["id", "mediaClockName", "mediaClockValue", "rateNumerator", "rateDenominator"],
      format: function(a) {
        var u = "mediaclk:";
        return u += a.id != null ? "id=%s %s" : "%v%s", u += a.mediaClockValue != null ? "=%s" : "", u += a.rateNumerator != null ? " rate=%s" : "", u += a.rateDenominator != null ? "/%s" : "", u;
      }
    },
    {
      // a=keywds:keywords
      name: "keywords",
      reg: /^keywds:(.+)$/,
      format: "keywds:%s"
    },
    {
      // a=content:main
      name: "content",
      reg: /^content:(.+)/,
      format: "content:%s"
    },
    // BFCP https://tools.ietf.org/html/rfc4583
    {
      // a=floorctrl:c-s
      name: "bfcpFloorCtrl",
      reg: /^floorctrl:(c-only|s-only|c-s)/,
      format: "floorctrl:%s"
    },
    {
      // a=confid:1
      name: "bfcpConfId",
      reg: /^confid:(\d+)/,
      format: "confid:%s"
    },
    {
      // a=userid:1
      name: "bfcpUserId",
      reg: /^userid:(\d+)/,
      format: "userid:%s"
    },
    {
      // a=floorid:1
      name: "bfcpFloorId",
      reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/,
      names: ["id", "mStream"],
      format: "floorid:%s mstrm:%s"
    },
    {
      // any a= that we don't understand is kept verbatim on media.invalid
      push: "invalid",
      names: ["value"]
    }
  ]
};
Object.keys(grammar$1).forEach(function(a) {
  var u = grammar$1[a];
  u.forEach(function(c) {
    c.reg || (c.reg = /(.*)/), c.format || (c.format = "%s");
  });
});
var grammarExports = grammar$2.exports;
(function(a) {
  var u = function(k) {
    return String(Number(k)) === k ? Number(k) : k;
  }, c = function(k, M, L, F) {
    if (F && !L)
      M[F] = u(k[1]);
    else
      for (var V = 0; V < L.length; V += 1)
        k[V + 1] != null && (M[L[V]] = u(k[V + 1]));
  }, l = function(k, M, L) {
    var F = k.name && k.names;
    k.push && !M[k.push] ? M[k.push] = [] : F && !M[k.name] && (M[k.name] = {});
    var V = k.push ? {} : (
      // blank object that will be pushed
      F ? M[k.name] : M
    );
    c(L.match(k.reg), V, k.names, k.name), k.push && M[k.push].push(V);
  }, v = grammarExports, p = RegExp.prototype.test.bind(/^([a-z])=(.*)/);
  a.parse = function(k) {
    var M = {}, L = [], F = M;
    return k.split(/(\r\n|\r|\n)/).filter(p).forEach(function(V) {
      var X = V[0], oe = V.slice(2);
      X === "m" && (L.push({
        rtp: [],
        fmtp: []
      }), F = L[L.length - 1]);
      for (var Y = 0; Y < (v[X] || []).length; Y += 1) {
        var ae = v[X][Y];
        if (ae.reg.test(oe))
          return l(ae, F, oe);
      }
    }), M.media = L, M;
  };
  var _ = function(k, M) {
    var L = M.split(/=(.+)/, 2);
    return L.length === 2 ? k[L[0]] = u(L[1]) : L.length === 1 && M.length > 1 && (k[L[0]] = void 0), k;
  };
  a.parseParams = function(k) {
    return k.split(/;\s?/).reduce(_, {});
  }, a.parseFmtpConfig = a.parseParams, a.parsePayloads = function(k) {
    return k.toString().split(" ").map(Number);
  }, a.parseRemoteCandidates = function(k) {
    for (var M = [], L = k.split(" ").map(u), F = 0; F < L.length; F += 3)
      M.push({
        component: L[F],
        ip: L[F + 1],
        port: L[F + 2]
      });
    return M;
  }, a.parseImageAttributes = function(k) {
    return k.split(" ").map(function(M) {
      return M.substring(1, M.length - 1).split(",").reduce(_, {});
    });
  }, a.parseSimulcastStreamList = function(k) {
    return k.split(";").map(function(M) {
      return M.split(",").map(function(L) {
        var F, V = !1;
        return L[0] !== "~" ? F = u(L) : (F = u(L.substring(1, L.length)), V = !0), {
          scid: F,
          paused: V
        };
      });
    });
  };
})(parser$1);
var grammar = grammarExports, formatRegExp = /%[sdv%]/g, format = function(a) {
  var u = 1, c = arguments, l = c.length;
  return a.replace(formatRegExp, function(v) {
    if (u >= l)
      return v;
    var p = c[u];
    switch (u += 1, v) {
      case "%%":
        return "%";
      case "%s":
        return String(p);
      case "%d":
        return Number(p);
      case "%v":
        return "";
    }
  });
}, makeLine = function(a, u, c) {
  var l = u.format instanceof Function ? u.format(u.push ? c : c[u.name]) : u.format, v = [a + "=" + l];
  if (u.names)
    for (var p = 0; p < u.names.length; p += 1) {
      var _ = u.names[p];
      u.name ? v.push(c[u.name][_]) : v.push(c[u.names[p]]);
    }
  else
    v.push(c[u.name]);
  return format.apply(null, v);
}, defaultOuterOrder = ["v", "o", "s", "i", "u", "e", "p", "c", "b", "t", "r", "z", "a"], defaultInnerOrder = ["i", "c", "b", "a"], writer$1 = function(a, u) {
  u = u || {}, a.version == null && (a.version = 0), a.name == null && (a.name = " "), a.media.forEach(function(p) {
    p.payloads == null && (p.payloads = "");
  });
  var c = u.outerOrder || defaultOuterOrder, l = u.innerOrder || defaultInnerOrder, v = [];
  return c.forEach(function(p) {
    grammar[p].forEach(function(_) {
      _.name in a && a[_.name] != null ? v.push(makeLine(p, _, a)) : _.push in a && a[_.push] != null && a[_.push].forEach(function(k) {
        v.push(makeLine(p, _, k));
      });
    });
  }), a.media.forEach(function(p) {
    v.push(makeLine("m", grammar.m[0], p)), l.forEach(function(_) {
      grammar[_].forEach(function(k) {
        k.name in p && p[k.name] != null ? v.push(makeLine(_, k, p)) : k.push in p && p[k.push] != null && p[k.push].forEach(function(M) {
          v.push(makeLine(_, k, M));
        });
      });
    });
  }), v.join(`\r
`) + `\r
`;
}, parser = parser$1, writer = writer$1, write = writer, parse$2 = parser.parse;
const startBitrateForSVC = 0.7, PCEvents = {
  NegotiationStarted: "negotiationStarted",
  NegotiationComplete: "negotiationComplete",
  RTPVideoPayloadTypes: "rtpVideoPayloadTypes"
};
class PCTransport extends eventsExports$1.EventEmitter {
  get pc() {
    return this._pc || (this._pc = this.createPC()), this._pc;
  }
  constructor(u) {
    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var l;
    super(), this.log = livekitLogger, this.pendingCandidates = [], this.restartingIce = !1, this.renegotiate = !1, this.trackBitrates = [], this.remoteStereoMids = [], this.remoteNackMids = [], this.negotiate = r$1((v) => __awaiter$3(this, void 0, void 0, function* () {
      this.emit(PCEvents.NegotiationStarted);
      try {
        yield this.createAndSendOffer();
      } catch (p) {
        if (v)
          v(p);
        else
          throw p;
      }
    }), 100), this.close = () => {
      this._pc && (this._pc.close(), this._pc.onconnectionstatechange = null, this._pc.oniceconnectionstatechange = null, this._pc.onicegatheringstatechange = null, this._pc.ondatachannel = null, this._pc.onnegotiationneeded = null, this._pc.onsignalingstatechange = null, this._pc.onicecandidate = null, this._pc.ondatachannel = null, this._pc.ontrack = null, this._pc.onconnectionstatechange = null, this._pc.oniceconnectionstatechange = null, this._pc = null);
    }, this.log = getLogger((l = c.loggerName) !== null && l !== void 0 ? l : LoggerNames.PCTransport), this.loggerOptions = c, this.config = u, this._pc = this.createPC();
  }
  createPC() {
    const u = new RTCPeerConnection(this.config);
    return u.onicecandidate = (c) => {
      var l;
      c.candidate && ((l = this.onIceCandidate) === null || l === void 0 || l.call(this, c.candidate));
    }, u.onicecandidateerror = (c) => {
      var l;
      (l = this.onIceCandidateError) === null || l === void 0 || l.call(this, c);
    }, u.oniceconnectionstatechange = () => {
      var c;
      (c = this.onIceConnectionStateChange) === null || c === void 0 || c.call(this, u.iceConnectionState);
    }, u.onsignalingstatechange = () => {
      var c;
      (c = this.onSignalingStatechange) === null || c === void 0 || c.call(this, u.signalingState);
    }, u.onconnectionstatechange = () => {
      var c;
      (c = this.onConnectionStateChange) === null || c === void 0 || c.call(this, u.connectionState);
    }, u.ondatachannel = (c) => {
      var l;
      (l = this.onDataChannel) === null || l === void 0 || l.call(this, c);
    }, u.ontrack = (c) => {
      var l;
      (l = this.onTrack) === null || l === void 0 || l.call(this, c);
    }, u;
  }
  get logContext() {
    var u, c;
    return Object.assign({}, (c = (u = this.loggerOptions).loggerContextCb) === null || c === void 0 ? void 0 : c.call(u));
  }
  get isICEConnected() {
    return this._pc !== null && (this.pc.iceConnectionState === "connected" || this.pc.iceConnectionState === "completed");
  }
  addIceCandidate(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (this.pc.remoteDescription && !this.restartingIce)
        return this.pc.addIceCandidate(u);
      this.pendingCandidates.push(u);
    });
  }
  setRemoteDescription(u) {
    var c;
    return __awaiter$3(this, void 0, void 0, function* () {
      let l;
      if (u.type === "offer") {
        let {
          stereoMids: v,
          nackMids: p
        } = extractStereoAndNackAudioFromOffer(u);
        this.remoteStereoMids = v, this.remoteNackMids = p;
      } else if (u.type === "answer") {
        const v = parse$2((c = u.sdp) !== null && c !== void 0 ? c : "");
        v.media.forEach((p) => {
          p.type === "audio" && this.trackBitrates.some((_) => {
            if (!_.transceiver || p.mid != _.transceiver.mid)
              return !1;
            let k = 0;
            if (p.rtp.some((L) => L.codec.toUpperCase() === _.codec.toUpperCase() ? (k = L.payload, !0) : !1), k === 0)
              return !0;
            let M = !1;
            for (const L of p.fmtp)
              if (L.payload === k) {
                L.config = L.config.split(";").filter((F) => !F.includes("maxaveragebitrate")).join(";"), _.maxbr > 0 && (L.config += ";maxaveragebitrate=".concat(_.maxbr * 1e3)), M = !0;
                break;
              }
            return M || _.maxbr > 0 && p.fmtp.push({
              payload: k,
              config: "maxaveragebitrate=".concat(_.maxbr * 1e3)
            }), !0;
          });
        }), l = write(v);
      }
      yield this.setMungedSDP(u, l, !0), this.pendingCandidates.forEach((v) => {
        this.pc.addIceCandidate(v);
      }), this.pendingCandidates = [], this.restartingIce = !1, this.renegotiate ? (this.renegotiate = !1, yield this.createAndSendOffer()) : u.type === "answer" && (this.emit(PCEvents.NegotiationComplete), u.sdp && parse$2(u.sdp).media.forEach((p) => {
        p.type === "video" && this.emit(PCEvents.RTPVideoPayloadTypes, p.rtp);
      }));
    });
  }
  createAndSendOffer(u) {
    var c;
    return __awaiter$3(this, void 0, void 0, function* () {
      if (this.onOffer === void 0)
        return;
      if (u != null && u.iceRestart && (this.log.debug("restarting ICE", this.logContext), this.restartingIce = !0), this._pc && this._pc.signalingState === "have-local-offer") {
        const p = this._pc.remoteDescription;
        if (u != null && u.iceRestart && p)
          yield this._pc.setRemoteDescription(p);
        else {
          this.renegotiate = !0;
          return;
        }
      } else if (!this._pc || this._pc.signalingState === "closed") {
        this.log.warn("could not createOffer with closed peer connection", this.logContext);
        return;
      }
      this.log.debug("starting to negotiate", this.logContext);
      const l = yield this.pc.createOffer(u), v = parse$2((c = l.sdp) !== null && c !== void 0 ? c : "");
      v.media.forEach((p) => {
        p.type === "audio" ? ensureAudioNackAndStereo(p, [], []) : p.type === "video" && (ensureVideoDDExtensionForSVC(p), this.trackBitrates.some((_) => {
          if (!p.msid || !_.cid || !p.msid.includes(_.cid))
            return !1;
          let k = 0;
          if (p.rtp.some((L) => L.codec.toUpperCase() === _.codec.toUpperCase() ? (k = L.payload, !0) : !1), k === 0)
            return !0;
          const M = Math.round(_.maxbr * startBitrateForSVC);
          for (const L of p.fmtp)
            if (L.payload === k) {
              L.config.includes("x-google-start-bitrate") || (L.config += ";x-google-start-bitrate=".concat(M));
              break;
            }
          return !0;
        }));
      }), yield this.setMungedSDP(l, write(v)), this.onOffer(l);
    });
  }
  createAndSetAnswer() {
    var u;
    return __awaiter$3(this, void 0, void 0, function* () {
      const c = yield this.pc.createAnswer(), l = parse$2((u = c.sdp) !== null && u !== void 0 ? u : "");
      return l.media.forEach((v) => {
        v.type === "audio" && ensureAudioNackAndStereo(v, this.remoteStereoMids, this.remoteNackMids);
      }), yield this.setMungedSDP(c, write(l)), c;
    });
  }
  createDataChannel(u, c) {
    return this.pc.createDataChannel(u, c);
  }
  addTransceiver(u, c) {
    return this.pc.addTransceiver(u, c);
  }
  addTrack(u) {
    if (!this._pc)
      throw new UnexpectedConnectionState("PC closed, cannot add track");
    return this._pc.addTrack(u);
  }
  setTrackCodecBitrate(u) {
    this.trackBitrates.push(u);
  }
  setConfiguration(u) {
    var c;
    if (!this._pc)
      throw new UnexpectedConnectionState("PC closed, cannot configure");
    return (c = this._pc) === null || c === void 0 ? void 0 : c.setConfiguration(u);
  }
  canRemoveTrack() {
    var u;
    return !!(!((u = this._pc) === null || u === void 0) && u.removeTrack);
  }
  removeTrack(u) {
    var c;
    return (c = this._pc) === null || c === void 0 ? void 0 : c.removeTrack(u);
  }
  getConnectionState() {
    var u, c;
    return (c = (u = this._pc) === null || u === void 0 ? void 0 : u.connectionState) !== null && c !== void 0 ? c : "closed";
  }
  getICEConnectionState() {
    var u, c;
    return (c = (u = this._pc) === null || u === void 0 ? void 0 : u.iceConnectionState) !== null && c !== void 0 ? c : "closed";
  }
  getSignallingState() {
    var u, c;
    return (c = (u = this._pc) === null || u === void 0 ? void 0 : u.signalingState) !== null && c !== void 0 ? c : "closed";
  }
  getTransceivers() {
    var u, c;
    return (c = (u = this._pc) === null || u === void 0 ? void 0 : u.getTransceivers()) !== null && c !== void 0 ? c : [];
  }
  getSenders() {
    var u, c;
    return (c = (u = this._pc) === null || u === void 0 ? void 0 : u.getSenders()) !== null && c !== void 0 ? c : [];
  }
  getLocalDescription() {
    var u;
    return (u = this._pc) === null || u === void 0 ? void 0 : u.localDescription;
  }
  getRemoteDescription() {
    var u;
    return (u = this.pc) === null || u === void 0 ? void 0 : u.remoteDescription;
  }
  getStats() {
    return this.pc.getStats();
  }
  getConnectedAddress() {
    var u;
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!this._pc)
        return;
      let c = "";
      const l = /* @__PURE__ */ new Map(), v = /* @__PURE__ */ new Map();
      if ((yield this._pc.getStats()).forEach((k) => {
        switch (k.type) {
          case "transport":
            c = k.selectedCandidatePairId;
            break;
          case "candidate-pair":
            c === "" && k.selected && (c = k.id), l.set(k.id, k);
            break;
          case "remote-candidate":
            v.set(k.id, "".concat(k.address, ":").concat(k.port));
            break;
        }
      }), c === "")
        return;
      const _ = (u = l.get(c)) === null || u === void 0 ? void 0 : u.remoteCandidateId;
      if (_ !== void 0)
        return v.get(_);
    });
  }
  setMungedSDP(u, c, l) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (c) {
        const v = u.sdp;
        u.sdp = c;
        try {
          this.log.debug("setting munged ".concat(l ? "remote" : "local", " description"), this.logContext), l ? yield this.pc.setRemoteDescription(u) : yield this.pc.setLocalDescription(u);
          return;
        } catch (p) {
          this.log.warn("not able to set ".concat(u.type, ", falling back to unmodified sdp"), Object.assign(Object.assign({}, this.logContext), {
            error: p,
            sdp: c
          })), u.sdp = v;
        }
      }
      try {
        l ? yield this.pc.setRemoteDescription(u) : yield this.pc.setLocalDescription(u);
      } catch (v) {
        let p = "unknown error";
        v instanceof Error ? p = v.message : typeof v == "string" && (p = v);
        const _ = {
          error: p,
          sdp: u.sdp
        };
        throw !l && this.pc.remoteDescription && (_.remoteSdp = this.pc.remoteDescription), this.log.error("unable to set ".concat(u.type), Object.assign(Object.assign({}, this.logContext), {
          fields: _
        })), new NegotiationError(p);
      }
    });
  }
}
function ensureAudioNackAndStereo(a, u, c) {
  let l = 0;
  a.rtp.some((v) => v.codec === "opus" ? (l = v.payload, !0) : !1), l > 0 && (a.rtcpFb || (a.rtcpFb = []), c.includes(a.mid) && !a.rtcpFb.some((v) => v.payload === l && v.type === "nack") && a.rtcpFb.push({
    payload: l,
    type: "nack"
  }), u.includes(a.mid) && a.fmtp.some((v) => v.payload === l ? (v.config.includes("stereo=1") || (v.config += ";stereo=1"), !0) : !1));
}
function ensureVideoDDExtensionForSVC(a) {
  var u, c, l, v;
  const p = (c = (u = a.rtp[0]) === null || u === void 0 ? void 0 : u.codec) === null || c === void 0 ? void 0 : c.toLowerCase();
  if (!isSVCCodec(p))
    return;
  let _ = 0;
  ((l = a.ext) === null || l === void 0 ? void 0 : l.some((M) => M.uri === ddExtensionURI ? !0 : (M.value > _ && (_ = M.value), !1))) || (v = a.ext) === null || v === void 0 || v.push({
    value: _ + 1,
    uri: ddExtensionURI
  });
}
function extractStereoAndNackAudioFromOffer(a) {
  var u;
  const c = [], l = [], v = parse$2((u = a.sdp) !== null && u !== void 0 ? u : "");
  let p = 0;
  return v.media.forEach((_) => {
    var k;
    _.type === "audio" && (_.rtp.some((M) => M.codec === "opus" ? (p = M.payload, !0) : !1), !((k = _.rtcpFb) === null || k === void 0) && k.some((M) => M.payload === p && M.type === "nack") && l.push(_.mid), _.fmtp.some((M) => M.payload === p ? (M.config.includes("sprop-stereo=1") && c.push(_.mid), !0) : !1));
  }), {
    stereoMids: c,
    nackMids: l
  };
}
const defaultVideoCodec = "vp8", publishDefaults = {
  audioPreset: AudioPresets.music,
  dtx: !0,
  red: !0,
  forceStereo: !1,
  simulcast: !0,
  screenShareEncoding: ScreenSharePresets.h1080fps15.encoding,
  stopMicTrackOnMute: !1,
  videoCodec: defaultVideoCodec,
  backupCodec: !0
}, audioDefaults = {
  autoGainControl: !0,
  echoCancellation: !0,
  noiseSuppression: !0
}, videoDefaults = {
  resolution: VideoPresets.h720.resolution
}, roomOptionDefaults = {
  adaptiveStream: !1,
  dynacast: !1,
  stopLocalTrackOnUnpublish: !0,
  reconnectPolicy: new DefaultReconnectPolicy(),
  disconnectOnPageLeave: !0,
  webAudioMix: !0
}, roomConnectOptionDefaults = {
  autoSubscribe: !0,
  maxRetries: 1,
  peerConnectionTimeout: 15e3,
  websocketTimeout: 15e3
};
var PCTransportState;
(function(a) {
  a[a.NEW = 0] = "NEW", a[a.CONNECTING = 1] = "CONNECTING", a[a.CONNECTED = 2] = "CONNECTED", a[a.FAILED = 3] = "FAILED", a[a.CLOSING = 4] = "CLOSING", a[a.CLOSED = 5] = "CLOSED";
})(PCTransportState || (PCTransportState = {}));
class PCTransportManager {
  get needsPublisher() {
    return this.isPublisherConnectionRequired;
  }
  get needsSubscriber() {
    return this.isSubscriberConnectionRequired;
  }
  get currentState() {
    return this.state;
  }
  constructor(u, c, l) {
    var v;
    this.peerConnectionTimeout = roomConnectOptionDefaults.peerConnectionTimeout, this.log = livekitLogger, this.updateState = () => {
      var p;
      const _ = this.state, k = this.requiredTransports.map((M) => M.getConnectionState());
      k.every((M) => M === "connected") ? this.state = PCTransportState.CONNECTED : k.some((M) => M === "failed") ? this.state = PCTransportState.FAILED : k.some((M) => M === "connecting") ? this.state = PCTransportState.CONNECTING : k.every((M) => M === "closed") ? this.state = PCTransportState.CLOSED : k.some((M) => M === "closed") ? this.state = PCTransportState.CLOSING : k.every((M) => M === "new") && (this.state = PCTransportState.NEW), _ !== this.state && (this.log.debug("pc state change: from ".concat(PCTransportState[_], " to ").concat(PCTransportState[this.state]), this.logContext), (p = this.onStateChange) === null || p === void 0 || p.call(this, this.state, this.publisher.getConnectionState(), this.subscriber.getConnectionState()));
    }, this.log = getLogger((v = l.loggerName) !== null && v !== void 0 ? v : LoggerNames.PCManager), this.loggerOptions = l, this.isPublisherConnectionRequired = !c, this.isSubscriberConnectionRequired = c, this.publisher = new PCTransport(u, l), this.subscriber = new PCTransport(u, l), this.publisher.onConnectionStateChange = this.updateState, this.subscriber.onConnectionStateChange = this.updateState, this.publisher.onIceConnectionStateChange = this.updateState, this.subscriber.onIceConnectionStateChange = this.updateState, this.publisher.onSignalingStatechange = this.updateState, this.subscriber.onSignalingStatechange = this.updateState, this.publisher.onIceCandidate = (p) => {
      var _;
      (_ = this.onIceCandidate) === null || _ === void 0 || _.call(this, p, SignalTarget.PUBLISHER);
    }, this.subscriber.onIceCandidate = (p) => {
      var _;
      (_ = this.onIceCandidate) === null || _ === void 0 || _.call(this, p, SignalTarget.SUBSCRIBER);
    }, this.subscriber.onDataChannel = (p) => {
      var _;
      (_ = this.onDataChannel) === null || _ === void 0 || _.call(this, p);
    }, this.subscriber.onTrack = (p) => {
      var _;
      (_ = this.onTrack) === null || _ === void 0 || _.call(this, p);
    }, this.publisher.onOffer = (p) => {
      var _;
      (_ = this.onPublisherOffer) === null || _ === void 0 || _.call(this, p);
    }, this.state = PCTransportState.NEW, this.connectionLock = new Mutex();
  }
  get logContext() {
    var u, c;
    return Object.assign({}, (c = (u = this.loggerOptions).loggerContextCb) === null || c === void 0 ? void 0 : c.call(u));
  }
  requirePublisher() {
    let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
    this.isPublisherConnectionRequired = u, this.updateState();
  }
  requireSubscriber() {
    let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
    this.isSubscriberConnectionRequired = u, this.updateState();
  }
  createAndSendPublisherOffer(u) {
    return this.publisher.createAndSendOffer(u);
  }
  setPublisherAnswer(u) {
    return this.publisher.setRemoteDescription(u);
  }
  removeTrack(u) {
    return this.publisher.removeTrack(u);
  }
  close() {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (this.publisher && this.publisher.getSignallingState() !== "closed") {
        const u = this.publisher;
        for (const c of u.getSenders())
          try {
            u.canRemoveTrack() && u.removeTrack(c);
          } catch (l) {
            this.log.warn("could not removeTrack", Object.assign(Object.assign({}, this.logContext), {
              error: l
            }));
          }
      }
      yield Promise.all([this.publisher.close(), this.subscriber.close()]), this.updateState();
    });
  }
  triggerIceRestart() {
    return __awaiter$3(this, void 0, void 0, function* () {
      this.subscriber.restartingIce = !0, this.needsPublisher && (yield this.createAndSendPublisherOffer({
        iceRestart: !0
      }));
    });
  }
  addIceCandidate(u, c) {
    return __awaiter$3(this, void 0, void 0, function* () {
      c === SignalTarget.PUBLISHER ? yield this.publisher.addIceCandidate(u) : yield this.subscriber.addIceCandidate(u);
    });
  }
  createSubscriberAnswerFromOffer(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this.log.debug("received server offer", Object.assign(Object.assign({}, this.logContext), {
        RTCSdpType: u.type,
        sdp: u.sdp,
        signalingState: this.subscriber.getSignallingState().toString()
      })), yield this.subscriber.setRemoteDescription(u), yield this.subscriber.createAndSetAnswer();
    });
  }
  updateConfiguration(u, c) {
    this.publisher.setConfiguration(u), this.subscriber.setConfiguration(u), c && this.triggerIceRestart();
  }
  ensurePCTransportConnection(u, c) {
    var l;
    return __awaiter$3(this, void 0, void 0, function* () {
      const v = yield this.connectionLock.lock();
      try {
        this.isPublisherConnectionRequired && this.publisher.getConnectionState() !== "connected" && this.publisher.getConnectionState() !== "connecting" && (this.log.debug("negotiation required, start negotiating", this.logContext), this.publisher.negotiate()), yield Promise.all((l = this.requiredTransports) === null || l === void 0 ? void 0 : l.map((p) => this.ensureTransportConnected(p, u, c)));
      } finally {
        v();
      }
    });
  }
  negotiate(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      return new Promise((c, l) => __awaiter$3(this, void 0, void 0, function* () {
        const v = setTimeout(() => {
          l("negotiation timed out");
        }, this.peerConnectionTimeout), p = () => {
          clearTimeout(v), l("negotiation aborted");
        };
        u.signal.addEventListener("abort", p), this.publisher.once(PCEvents.NegotiationStarted, () => {
          u.signal.aborted || this.publisher.once(PCEvents.NegotiationComplete, () => {
            clearTimeout(v), c();
          });
        }), yield this.publisher.negotiate((_) => {
          clearTimeout(v), l(_);
        });
      }));
    });
  }
  addPublisherTransceiver(u, c) {
    return this.publisher.addTransceiver(u, c);
  }
  addPublisherTrack(u) {
    return this.publisher.addTrack(u);
  }
  createPublisherDataChannel(u, c) {
    return this.publisher.createDataChannel(u, c);
  }
  /**
   * Returns the first required transport's address if no explicit target is specified
   */
  getConnectedAddress(u) {
    return u === SignalTarget.PUBLISHER ? this.publisher.getConnectedAddress() : u === SignalTarget.SUBSCRIBER ? this.publisher.getConnectedAddress() : this.requiredTransports[0].getConnectedAddress();
  }
  get requiredTransports() {
    const u = [];
    return this.isPublisherConnectionRequired && u.push(this.publisher), this.isSubscriberConnectionRequired && u.push(this.subscriber), u;
  }
  ensureTransportConnected(u, c) {
    let l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.peerConnectionTimeout;
    return __awaiter$3(this, void 0, void 0, function* () {
      if (u.getConnectionState() !== "connected")
        return new Promise((p, _) => __awaiter$3(this, void 0, void 0, function* () {
          const k = () => {
            this.log.warn("abort transport connection", this.logContext), CriticalTimers.clearTimeout(M), _(new ConnectionError(
              "room connection has been cancelled",
              3
              /* ConnectionErrorReason.Cancelled */
            ));
          };
          c != null && c.signal.aborted && k(), c == null || c.signal.addEventListener("abort", k);
          const M = CriticalTimers.setTimeout(() => {
            c == null || c.signal.removeEventListener("abort", k), _(new ConnectionError("could not establish pc connection"));
          }, l);
          for (; this.state !== PCTransportState.CONNECTED; )
            if (yield sleep(50), c != null && c.signal.aborted) {
              _(new ConnectionError(
                "room connection has been cancelled",
                3
                /* ConnectionErrorReason.Cancelled */
              ));
              return;
            }
          CriticalTimers.clearTimeout(M), c == null || c.signal.removeEventListener("abort", k), p();
        }));
    });
  }
}
const lossyDataChannel = "_lossy", reliableDataChannel = "_reliable", minReconnectWait = 2 * 1e3, leaveReconnect = "leave-reconnect";
var PCState;
(function(a) {
  a[a.New = 0] = "New", a[a.Connected = 1] = "Connected", a[a.Disconnected = 2] = "Disconnected", a[a.Reconnecting = 3] = "Reconnecting", a[a.Closed = 4] = "Closed";
})(PCState || (PCState = {}));
class RTCEngine extends eventsExports$1.EventEmitter {
  get isClosed() {
    return this._isClosed;
  }
  get pendingReconnect() {
    return !!this.reconnectTimeout;
  }
  constructor(u) {
    var c;
    super(), this.options = u, this.rtcConfig = {}, this.peerConnectionTimeout = roomConnectOptionDefaults.peerConnectionTimeout, this.fullReconnectOnNext = !1, this.subscriberPrimary = !1, this.pcState = PCState.New, this._isClosed = !0, this.pendingTrackResolvers = {}, this.reconnectAttempts = 0, this.reconnectStart = 0, this.attemptingReconnect = !1, this.joinAttempts = 0, this.maxJoinAttempts = 1, this.shouldFailNext = !1, this.log = livekitLogger, this.handleDataChannel = (l) => {
      let {
        channel: v
      } = l;
      return __awaiter$3(this, void 0, void 0, function* () {
        if (v) {
          if (v.label === reliableDataChannel)
            this.reliableDCSub = v;
          else if (v.label === lossyDataChannel)
            this.lossyDCSub = v;
          else
            return;
          this.log.debug("on data channel ".concat(v.id, ", ").concat(v.label), this.logContext), v.onmessage = this.handleDataMessage;
        }
      });
    }, this.handleDataMessage = (l) => __awaiter$3(this, void 0, void 0, function* () {
      var v, p;
      const _ = yield this.dataProcessLock.lock();
      try {
        let k;
        if (l.data instanceof ArrayBuffer)
          k = l.data;
        else if (l.data instanceof Blob)
          k = yield l.data.arrayBuffer();
        else {
          this.log.error("unsupported data type", Object.assign(Object.assign({}, this.logContext), {
            data: l.data
          }));
          return;
        }
        const M = DataPacket.fromBinary(new Uint8Array(k));
        ((v = M.value) === null || v === void 0 ? void 0 : v.case) === "speaker" ? this.emit(EngineEvent.ActiveSpeakersUpdate, M.value.value.speakers) : ((p = M.value) === null || p === void 0 ? void 0 : p.case) === "user" && this.emit(EngineEvent.DataPacketReceived, M.value.value, M.kind);
      } finally {
        _();
      }
    }), this.handleDataError = (l) => {
      const p = l.currentTarget.maxRetransmits === 0 ? "lossy" : "reliable";
      if (l instanceof ErrorEvent && l.error) {
        const {
          error: _
        } = l.error;
        this.log.error("DataChannel error on ".concat(p, ": ").concat(l.message), Object.assign(Object.assign({}, this.logContext), {
          error: _
        }));
      } else
        this.log.error("Unknown DataChannel error on ".concat(p), Object.assign(Object.assign({}, this.logContext), {
          event: l
        }));
    }, this.handleBufferedAmountLow = (l) => {
      const p = l.currentTarget.maxRetransmits === 0 ? DataPacket_Kind.LOSSY : DataPacket_Kind.RELIABLE;
      this.updateAndEmitDCBufferStatus(p);
    }, this.handleDisconnect = (l, v) => {
      if (this._isClosed)
        return;
      this.log.warn("".concat(l, " disconnected"), this.logContext), this.reconnectAttempts === 0 && (this.reconnectStart = Date.now());
      const p = (M) => {
        this.log.warn("could not recover connection after ".concat(this.reconnectAttempts, " attempts, ").concat(M, "ms. giving up"), this.logContext), this.emit(EngineEvent.Disconnected), this.close();
      }, _ = Date.now() - this.reconnectStart;
      let k = this.getNextRetryDelay({
        elapsedMs: _,
        retryCount: this.reconnectAttempts
      });
      if (k === null) {
        p(_);
        return;
      }
      l === leaveReconnect && (k = 0), this.log.debug("reconnecting in ".concat(k, "ms"), this.logContext), this.clearReconnectTimeout(), this.token && this.regionUrlProvider && this.regionUrlProvider.updateToken(this.token), this.reconnectTimeout = CriticalTimers.setTimeout(() => this.attemptReconnect(v).finally(() => this.reconnectTimeout = void 0), k);
    }, this.waitForRestarted = () => new Promise((l, v) => {
      this.pcState === PCState.Connected && l();
      const p = () => {
        this.off(EngineEvent.Disconnected, _), l();
      }, _ = () => {
        this.off(EngineEvent.Restarted, p), v();
      };
      this.once(EngineEvent.Restarted, p), this.once(EngineEvent.Disconnected, _);
    }), this.updateAndEmitDCBufferStatus = (l) => {
      const v = this.isBufferStatusLow(l);
      typeof v < "u" && v !== this.dcBufferStatus.get(l) && (this.dcBufferStatus.set(l, v), this.emit(EngineEvent.DCBufferStatusChanged, v, l));
    }, this.isBufferStatusLow = (l) => {
      const v = this.dataChannelForKind(l);
      if (v)
        return v.bufferedAmount <= v.bufferedAmountLowThreshold;
    }, this.handleBrowserOnLine = () => {
      this.client.currentState === SignalConnectionState.RECONNECTING && (this.clearReconnectTimeout(), this.attemptReconnect(ReconnectReason.RR_SIGNAL_DISCONNECTED));
    }, this.log = getLogger((c = u.loggerName) !== null && c !== void 0 ? c : LoggerNames.Engine), this.loggerOptions = {
      loggerName: u.loggerName,
      loggerContextCb: () => this.logContext
    }, this.client = new SignalClient(void 0, this.loggerOptions), this.client.signalLatency = this.options.expSignalLatency, this.reconnectPolicy = this.options.reconnectPolicy, this.registerOnLineListener(), this.closingLock = new Mutex(), this.dataProcessLock = new Mutex(), this.dcBufferStatus = /* @__PURE__ */ new Map([[DataPacket_Kind.LOSSY, !0], [DataPacket_Kind.RELIABLE, !0]]), this.client.onParticipantUpdate = (l) => this.emit(EngineEvent.ParticipantUpdate, l), this.client.onConnectionQuality = (l) => this.emit(EngineEvent.ConnectionQualityUpdate, l), this.client.onRoomUpdate = (l) => this.emit(EngineEvent.RoomUpdate, l), this.client.onSubscriptionError = (l) => this.emit(EngineEvent.SubscriptionError, l), this.client.onSubscriptionPermissionUpdate = (l) => this.emit(EngineEvent.SubscriptionPermissionUpdate, l), this.client.onSpeakersChanged = (l) => this.emit(EngineEvent.SpeakersChanged, l), this.client.onStreamStateUpdate = (l) => this.emit(EngineEvent.StreamStateChanged, l);
  }
  /** @internal */
  get logContext() {
    var u, c, l, v, p, _, k, M;
    return {
      room: (c = (u = this.latestJoinResponse) === null || u === void 0 ? void 0 : u.room) === null || c === void 0 ? void 0 : c.name,
      roomID: (v = (l = this.latestJoinResponse) === null || l === void 0 ? void 0 : l.room) === null || v === void 0 ? void 0 : v.sid,
      participant: (_ = (p = this.latestJoinResponse) === null || p === void 0 ? void 0 : p.participant) === null || _ === void 0 ? void 0 : _.identity,
      pID: (M = (k = this.latestJoinResponse) === null || k === void 0 ? void 0 : k.participant) === null || M === void 0 ? void 0 : M.sid
    };
  }
  join(u, c, l, v) {
    return __awaiter$3(this, void 0, void 0, function* () {
      this.url = u, this.token = c, this.signalOpts = l, this.maxJoinAttempts = l.maxRetries;
      try {
        this.joinAttempts += 1, this.setupSignalClientCallbacks();
        const p = yield this.client.join(u, c, l, v);
        return this._isClosed = !1, this.latestJoinResponse = p, this.subscriberPrimary = p.subscriberPrimary, this.pcManager || (yield this.configure(p)), this.subscriberPrimary || this.negotiate(), this.clientConfiguration = p.clientConfiguration, p;
      } catch (p) {
        if (p instanceof ConnectionError && p.reason === 1 && (this.log.warn("Couldn't connect to server, attempt ".concat(this.joinAttempts, " of ").concat(this.maxJoinAttempts), this.logContext), this.joinAttempts < this.maxJoinAttempts))
          return this.join(u, c, l, v);
        throw p;
      }
    });
  }
  close() {
    return __awaiter$3(this, void 0, void 0, function* () {
      const u = yield this.closingLock.lock();
      if (this.isClosed) {
        u();
        return;
      }
      try {
        this._isClosed = !0, this.emit(EngineEvent.Closing), this.removeAllListeners(), this.deregisterOnLineListener(), this.clearPendingReconnect(), yield this.cleanupPeerConnections(), yield this.cleanupClient();
      } finally {
        u();
      }
    });
  }
  cleanupPeerConnections() {
    var u;
    return __awaiter$3(this, void 0, void 0, function* () {
      yield (u = this.pcManager) === null || u === void 0 ? void 0 : u.close(), this.pcManager = void 0;
      const c = (l) => {
        l && (l.close(), l.onbufferedamountlow = null, l.onclose = null, l.onclosing = null, l.onerror = null, l.onmessage = null, l.onopen = null);
      };
      c(this.lossyDC), c(this.lossyDCSub), c(this.reliableDC), c(this.reliableDCSub), this.lossyDC = void 0, this.lossyDCSub = void 0, this.reliableDC = void 0, this.reliableDCSub = void 0;
    });
  }
  cleanupClient() {
    return __awaiter$3(this, void 0, void 0, function* () {
      yield this.client.close(), this.client.resetCallbacks();
    });
  }
  addTrack(u) {
    if (this.pendingTrackResolvers[u.cid])
      throw new TrackInvalidError("a track with the same ID has already been published");
    return new Promise((c, l) => {
      const v = setTimeout(() => {
        delete this.pendingTrackResolvers[u.cid], l(new ConnectionError("publication of local track timed out, no response from server"));
      }, 1e4);
      this.pendingTrackResolvers[u.cid] = {
        resolve: (p) => {
          clearTimeout(v), c(p);
        },
        reject: () => {
          clearTimeout(v), l(new Error("Cancelled publication by calling unpublish"));
        }
      }, this.client.sendAddTrack(u);
    });
  }
  /**
   * Removes sender from PeerConnection, returning true if it was removed successfully
   * and a negotiation is necessary
   * @param sender
   * @returns
   */
  removeTrack(u) {
    if (u.track && this.pendingTrackResolvers[u.track.id]) {
      const {
        reject: c
      } = this.pendingTrackResolvers[u.track.id];
      c && c(), delete this.pendingTrackResolvers[u.track.id];
    }
    try {
      return this.pcManager.removeTrack(u), !0;
    } catch (c) {
      this.log.warn("failed to remove track", Object.assign(Object.assign({}, this.logContext), {
        error: c
      }));
    }
    return !1;
  }
  updateMuteStatus(u, c) {
    this.client.sendMuteTrack(u, c);
  }
  get dataSubscriberReadyState() {
    var u;
    return (u = this.reliableDCSub) === null || u === void 0 ? void 0 : u.readyState;
  }
  getConnectedServerAddress() {
    var u;
    return __awaiter$3(this, void 0, void 0, function* () {
      return (u = this.pcManager) === null || u === void 0 ? void 0 : u.getConnectedAddress();
    });
  }
  /* @internal */
  setRegionUrlProvider(u) {
    this.regionUrlProvider = u;
  }
  configure(u) {
    var c;
    return __awaiter$3(this, void 0, void 0, function* () {
      if (this.pcManager && this.pcManager.currentState !== PCTransportState.NEW)
        return;
      this.participantSid = (c = u.participant) === null || c === void 0 ? void 0 : c.sid;
      const l = this.makeRTCConfiguration(u);
      this.pcManager = new PCTransportManager(l, u.subscriberPrimary, this.loggerOptions), this.emit(EngineEvent.TransportsCreated, this.pcManager.publisher, this.pcManager.subscriber), this.pcManager.onIceCandidate = (v, p) => {
        this.client.sendIceCandidate(v, p);
      }, this.pcManager.onPublisherOffer = (v) => {
        this.client.sendOffer(v);
      }, this.pcManager.onDataChannel = this.handleDataChannel, this.pcManager.onStateChange = (v, p, _) => __awaiter$3(this, void 0, void 0, function* () {
        if (this.log.debug("primary PC state changed ".concat(v), this.logContext), v === PCTransportState.CONNECTED) {
          const L = this.pcState === PCState.New;
          this.pcState = PCState.Connected, L && this.emit(EngineEvent.Connected, u);
        } else
          v === PCTransportState.FAILED && this.pcState === PCState.Connected && (this.pcState = PCState.Disconnected, this.handleDisconnect("peerconnection failed", _ === "failed" ? ReconnectReason.RR_SUBSCRIBER_FAILED : ReconnectReason.RR_PUBLISHER_FAILED));
        const k = this.client.isDisconnected || this.client.currentState === SignalConnectionState.RECONNECTING, M = [PCTransportState.FAILED, PCTransportState.CLOSING, PCTransportState.CLOSED].includes(v);
        k && M && !this._isClosed && this.emit(EngineEvent.Offline);
      }), this.pcManager.onTrack = (v) => {
        this.emit(EngineEvent.MediaTrackAdded, v.track, v.streams[0], v.receiver);
      }, this.createDataChannels();
    });
  }
  setupSignalClientCallbacks() {
    this.client.onAnswer = (u) => __awaiter$3(this, void 0, void 0, function* () {
      this.pcManager && (this.log.debug("received server answer", Object.assign(Object.assign({}, this.logContext), {
        RTCSdpType: u.type
      })), yield this.pcManager.setPublisherAnswer(u));
    }), this.client.onTrickle = (u, c) => {
      this.pcManager && (this.log.trace("got ICE candidate from peer", Object.assign(Object.assign({}, this.logContext), {
        candidate: u,
        target: c
      })), this.pcManager.addIceCandidate(u, c));
    }, this.client.onOffer = (u) => __awaiter$3(this, void 0, void 0, function* () {
      if (!this.pcManager)
        return;
      const c = yield this.pcManager.createSubscriberAnswerFromOffer(u);
      this.client.sendAnswer(c);
    }), this.client.onLocalTrackPublished = (u) => {
      var c;
      if (this.log.debug("received trackPublishedResponse", Object.assign(Object.assign({}, this.logContext), {
        cid: u.cid,
        track: (c = u.track) === null || c === void 0 ? void 0 : c.sid
      })), !this.pendingTrackResolvers[u.cid]) {
        this.log.error("missing track resolver for ".concat(u.cid), Object.assign(Object.assign({}, this.logContext), {
          cid: u.cid
        }));
        return;
      }
      const {
        resolve: l
      } = this.pendingTrackResolvers[u.cid];
      delete this.pendingTrackResolvers[u.cid], l(u.track);
    }, this.client.onLocalTrackUnpublished = (u) => {
      this.emit(EngineEvent.LocalTrackUnpublished, u);
    }, this.client.onTokenRefresh = (u) => {
      this.token = u;
    }, this.client.onRemoteMuteChanged = (u, c) => {
      this.emit(EngineEvent.RemoteMute, u, c);
    }, this.client.onSubscribedQualityUpdate = (u) => {
      this.emit(EngineEvent.SubscribedQualityUpdate, u);
    }, this.client.onClose = () => {
      this.handleDisconnect("signal", ReconnectReason.RR_SIGNAL_DISCONNECTED);
    }, this.client.onLeave = (u) => {
      u != null && u.canReconnect ? (this.fullReconnectOnNext = !0, this.handleDisconnect(leaveReconnect)) : (this.emit(EngineEvent.Disconnected, u == null ? void 0 : u.reason), this.close()), this.log.debug("client leave request", Object.assign(Object.assign({}, this.logContext), {
        reason: u == null ? void 0 : u.reason
      }));
    };
  }
  makeRTCConfiguration(u) {
    var c;
    const l = Object.assign({}, this.rtcConfig);
    if (!((c = this.signalOpts) === null || c === void 0) && c.e2eeEnabled && (this.log.debug("E2EE - setting up transports with insertable streams", this.logContext), l.encodedInsertableStreams = !0), u.iceServers && !l.iceServers) {
      const v = [];
      u.iceServers.forEach((p) => {
        const _ = {
          urls: p.urls
        };
        p.username && (_.username = p.username), p.credential && (_.credential = p.credential), v.push(_);
      }), l.iceServers = v;
    }
    return u.clientConfiguration && u.clientConfiguration.forceRelay === ClientConfigSetting.ENABLED && (l.iceTransportPolicy = "relay"), l.sdpSemantics = "unified-plan", l.continualGatheringPolicy = "gather_continually", l;
  }
  createDataChannels() {
    this.pcManager && (this.lossyDC && (this.lossyDC.onmessage = null, this.lossyDC.onerror = null), this.reliableDC && (this.reliableDC.onmessage = null, this.reliableDC.onerror = null), this.lossyDC = this.pcManager.createPublisherDataChannel(lossyDataChannel, {
      // will drop older packets that arrive
      ordered: !0,
      maxRetransmits: 0
    }), this.reliableDC = this.pcManager.createPublisherDataChannel(reliableDataChannel, {
      ordered: !0
    }), this.lossyDC.onmessage = this.handleDataMessage, this.reliableDC.onmessage = this.handleDataMessage, this.lossyDC.onerror = this.handleDataError, this.reliableDC.onerror = this.handleDataError, this.lossyDC.bufferedAmountLowThreshold = 65535, this.reliableDC.bufferedAmountLowThreshold = 65535, this.lossyDC.onbufferedamountlow = this.handleBufferedAmountLow, this.reliableDC.onbufferedamountlow = this.handleBufferedAmountLow);
  }
  setPreferredCodec(u, c, l) {
    if (!("getCapabilities" in RTCRtpReceiver))
      return;
    const v = RTCRtpReceiver.getCapabilities(c);
    if (!v)
      return;
    this.log.debug("get receiver capabilities", Object.assign(Object.assign({}, this.logContext), {
      cap: v
    }));
    const p = [], _ = [], k = [];
    v.codecs.forEach((M) => {
      const L = M.mimeType.toLowerCase();
      if (L === "audio/opus") {
        p.push(M);
        return;
      }
      if (!(L === "video/".concat(l))) {
        k.push(M);
        return;
      }
      if (l === "h264") {
        M.sdpFmtpLine && M.sdpFmtpLine.includes("profile-level-id=42e01f") ? p.push(M) : _.push(M);
        return;
      }
      p.push(M);
    }), supportsSetCodecPreferences(u) && u.setCodecPreferences(p.concat(_, k));
  }
  createSender(u, c, l) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (supportsTransceiver())
        return yield this.createTransceiverRTCRtpSender(u, c, l);
      if (supportsAddTrack())
        return this.log.warn("using add-track fallback", this.logContext), yield this.createRTCRtpSender(u.mediaStreamTrack);
      throw new UnexpectedConnectionState("Required webRTC APIs not supported on this device");
    });
  }
  createSimulcastSender(u, c, l, v) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (supportsTransceiver())
        return this.createSimulcastTransceiverSender(u, c, l, v);
      if (supportsAddTrack())
        return this.log.debug("using add-track fallback", this.logContext), this.createRTCRtpSender(u.mediaStreamTrack);
      throw new UnexpectedConnectionState("Cannot stream on this device");
    });
  }
  createTransceiverRTCRtpSender(u, c, l) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!this.pcManager)
        throw new UnexpectedConnectionState("publisher is closed");
      const v = [];
      u.mediaStream && v.push(u.mediaStream);
      const p = {
        direction: "sendonly",
        streams: v
      };
      l && (p.sendEncodings = l);
      const _ = yield this.pcManager.addPublisherTransceiver(u.mediaStreamTrack, p);
      return u.kind === Track.Kind.Video && c.videoCodec && (this.setPreferredCodec(_, u.kind, c.videoCodec), u.codec = c.videoCodec), _.sender;
    });
  }
  createSimulcastTransceiverSender(u, c, l, v) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!this.pcManager)
        throw new UnexpectedConnectionState("publisher is closed");
      const p = {
        direction: "sendonly"
      };
      v && (p.sendEncodings = v);
      const _ = yield this.pcManager.addPublisherTransceiver(c.mediaStreamTrack, p);
      if (l.videoCodec)
        return this.setPreferredCodec(_, u.kind, l.videoCodec), u.setSimulcastTrackSender(l.videoCodec, _.sender), _.sender;
    });
  }
  createRTCRtpSender(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!this.pcManager)
        throw new UnexpectedConnectionState("publisher is closed");
      return this.pcManager.addPublisherTrack(u);
    });
  }
  attemptReconnect(u) {
    var c, l, v;
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!this._isClosed) {
        if (this.attemptingReconnect) {
          livekitLogger.warn("already attempting reconnect, returning early", this.logContext);
          return;
        }
        (((c = this.clientConfiguration) === null || c === void 0 ? void 0 : c.resumeConnection) === ClientConfigSetting.DISABLED || // signaling state could change to closed due to hardware sleep
        // those connections cannot be resumed
        ((v = (l = this.pcManager) === null || l === void 0 ? void 0 : l.currentState) !== null && v !== void 0 ? v : PCTransportState.NEW) === PCTransportState.NEW) && (this.fullReconnectOnNext = !0);
        try {
          this.attemptingReconnect = !0, this.fullReconnectOnNext ? yield this.restartConnection() : yield this.resumeConnection(u), this.clearPendingReconnect(), this.fullReconnectOnNext = !1;
        } catch (p) {
          this.reconnectAttempts += 1;
          let _ = !0;
          p instanceof UnexpectedConnectionState ? (this.log.debug("received unrecoverable error", Object.assign(Object.assign({}, this.logContext), {
            error: p
          })), _ = !1) : p instanceof SignalReconnectError || (this.fullReconnectOnNext = !0), _ ? this.handleDisconnect("reconnect", ReconnectReason.RR_UNKNOWN) : (this.log.info("could not recover connection after ".concat(this.reconnectAttempts, " attempts, ").concat(Date.now() - this.reconnectStart, "ms. giving up"), this.logContext), this.emit(EngineEvent.Disconnected), yield this.close());
        } finally {
          this.attemptingReconnect = !1;
        }
      }
    });
  }
  getNextRetryDelay(u) {
    try {
      return this.reconnectPolicy.nextRetryDelayInMs(u);
    } catch (c) {
      this.log.warn("encountered error in reconnect policy", Object.assign(Object.assign({}, this.logContext), {
        error: c
      }));
    }
    return null;
  }
  restartConnection(u) {
    var c, l, v;
    return __awaiter$3(this, void 0, void 0, function* () {
      try {
        if (!this.url || !this.token)
          throw new UnexpectedConnectionState("could not reconnect, url or token not saved");
        this.log.info("reconnecting, attempt: ".concat(this.reconnectAttempts), this.logContext), this.emit(EngineEvent.Restarting), this.client.isDisconnected || (yield this.client.sendLeave()), yield this.cleanupPeerConnections(), yield this.cleanupClient();
        let p;
        try {
          if (!this.signalOpts)
            throw this.log.warn("attempted connection restart, without signal options present", this.logContext), new SignalReconnectError();
          p = yield this.join(u ?? this.url, this.token, this.signalOpts);
        } catch (_) {
          throw _ instanceof ConnectionError && _.reason === 0 ? new UnexpectedConnectionState("could not reconnect, token might be expired") : new SignalReconnectError();
        }
        if (this.shouldFailNext)
          throw this.shouldFailNext = !1, new Error("simulated failure");
        if (this.client.setReconnected(), this.emit(EngineEvent.SignalRestarted, p), yield this.waitForPCReconnected(), this.client.currentState !== SignalConnectionState.CONNECTED)
          throw new SignalReconnectError("Signal connection got severed during reconnect");
        (c = this.regionUrlProvider) === null || c === void 0 || c.resetAttempts(), this.emit(EngineEvent.Restarted);
      } catch (p) {
        const _ = yield (l = this.regionUrlProvider) === null || l === void 0 ? void 0 : l.getNextBestRegionUrl();
        if (_) {
          yield this.restartConnection(_);
          return;
        } else
          throw (v = this.regionUrlProvider) === null || v === void 0 || v.resetAttempts(), p;
      }
    });
  }
  resumeConnection(u) {
    var c;
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!this.url || !this.token)
        throw new UnexpectedConnectionState("could not reconnect, url or token not saved");
      if (!this.pcManager)
        throw new UnexpectedConnectionState("publisher and subscriber connections unset");
      this.log.info("resuming signal connection, attempt ".concat(this.reconnectAttempts), this.logContext), this.emit(EngineEvent.Resuming);
      let l;
      try {
        this.setupSignalClientCallbacks(), l = yield this.client.reconnect(this.url, this.token, this.participantSid, u);
      } catch (v) {
        let p = "";
        throw v instanceof Error && (p = v.message, this.log.error(v.message, Object.assign(Object.assign({}, this.logContext), {
          error: v
        }))), v instanceof ConnectionError && v.reason === 0 ? new UnexpectedConnectionState("could not reconnect, token might be expired") : v instanceof ConnectionError && v.reason === 4 ? v : new SignalReconnectError(p);
      }
      if (this.emit(EngineEvent.SignalResumed), l) {
        const v = this.makeRTCConfiguration(l);
        this.pcManager.updateConfiguration(v);
      } else
        this.log.warn("Did not receive reconnect response", this.logContext);
      if (this.shouldFailNext)
        throw this.shouldFailNext = !1, new Error("simulated failure");
      if (yield this.pcManager.triggerIceRestart(), yield this.waitForPCReconnected(), this.client.currentState !== SignalConnectionState.CONNECTED)
        throw new SignalReconnectError("Signal connection got severed during reconnect");
      this.client.setReconnected(), ((c = this.reliableDC) === null || c === void 0 ? void 0 : c.readyState) === "open" && this.reliableDC.id === null && this.createDataChannels(), this.emit(EngineEvent.Resumed);
    });
  }
  waitForPCInitialConnection(u, c) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!this.pcManager)
        throw new UnexpectedConnectionState("PC manager is closed");
      yield this.pcManager.ensurePCTransportConnection(c, u);
    });
  }
  waitForPCReconnected() {
    return __awaiter$3(this, void 0, void 0, function* () {
      this.pcState = PCState.Reconnecting, this.log.debug("waiting for peer connection to reconnect", this.logContext);
      try {
        if (yield sleep(minReconnectWait), !this.pcManager)
          throw new UnexpectedConnectionState("PC manager is closed");
        yield this.pcManager.ensurePCTransportConnection(void 0, this.peerConnectionTimeout), this.pcState = PCState.Connected;
      } catch (u) {
        throw this.pcState = PCState.Disconnected, new ConnectionError("could not establish PC connection, ".concat(u.message));
      }
    });
  }
  /* @internal */
  sendDataPacket(u, c) {
    return __awaiter$3(this, void 0, void 0, function* () {
      const l = u.toBinary();
      yield this.ensurePublisherConnected(c);
      const v = this.dataChannelForKind(c);
      v && v.send(l), this.updateAndEmitDCBufferStatus(c);
    });
  }
  /**
   * @internal
   */
  ensureDataTransportConnected(u) {
    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.subscriberPrimary;
    var l;
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!this.pcManager)
        throw new UnexpectedConnectionState("PC manager is closed");
      const v = c ? this.pcManager.subscriber : this.pcManager.publisher, p = c ? "Subscriber" : "Publisher";
      if (!v)
        throw new ConnectionError("".concat(p, " connection not set"));
      !c && !this.pcManager.publisher.isICEConnected && this.pcManager.publisher.getICEConnectionState() !== "checking" && this.negotiate();
      const _ = this.dataChannelForKind(u, c);
      if ((_ == null ? void 0 : _.readyState) === "open")
        return;
      const k = (/* @__PURE__ */ new Date()).getTime() + this.peerConnectionTimeout;
      for (; (/* @__PURE__ */ new Date()).getTime() < k; ) {
        if (v.isICEConnected && ((l = this.dataChannelForKind(u, c)) === null || l === void 0 ? void 0 : l.readyState) === "open")
          return;
        yield sleep(50);
      }
      throw new ConnectionError("could not establish ".concat(p, " connection, state: ").concat(v.getICEConnectionState()));
    });
  }
  ensurePublisherConnected(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      yield this.ensureDataTransportConnected(u, !1);
    });
  }
  /* @internal */
  verifyTransport() {
    return !(!this.pcManager || this.pcManager.currentState !== PCTransportState.CONNECTED || !this.client.ws || this.client.ws.readyState === WebSocket.CLOSED);
  }
  /** @internal */
  negotiate() {
    return __awaiter$3(this, void 0, void 0, function* () {
      return new Promise((u, c) => __awaiter$3(this, void 0, void 0, function* () {
        if (!this.pcManager) {
          c(new NegotiationError("PC manager is closed"));
          return;
        }
        this.pcManager.requirePublisher();
        const l = new AbortController(), v = () => {
          l.abort(), this.log.debug("engine disconnected while negotiation was ongoing", this.logContext), u();
        };
        this.isClosed && c("cannot negotiate on closed engine"), this.on(EngineEvent.Closing, v), this.pcManager.publisher.once(PCEvents.RTPVideoPayloadTypes, (p) => {
          const _ = /* @__PURE__ */ new Map();
          p.forEach((k) => {
            const M = k.codec.toLowerCase();
            isVideoCodec(M) && _.set(k.payload, M);
          }), this.emit(EngineEvent.RTPVideoMapUpdate, _);
        });
        try {
          yield this.pcManager.negotiate(l), u();
        } catch (p) {
          p instanceof NegotiationError && (this.fullReconnectOnNext = !0), this.handleDisconnect("negotiation", ReconnectReason.RR_UNKNOWN), c(p);
        } finally {
          this.off(EngineEvent.Closing, v);
        }
      }));
    });
  }
  dataChannelForKind(u, c) {
    if (c) {
      if (u === DataPacket_Kind.LOSSY)
        return this.lossyDCSub;
      if (u === DataPacket_Kind.RELIABLE)
        return this.reliableDCSub;
    } else {
      if (u === DataPacket_Kind.LOSSY)
        return this.lossyDC;
      if (u === DataPacket_Kind.RELIABLE)
        return this.reliableDC;
    }
  }
  /** @internal */
  sendSyncState(u, c) {
    var l, v;
    if (!this.pcManager) {
      this.log.warn("sync state cannot be sent without peer connection setup", this.logContext);
      return;
    }
    const p = this.pcManager.subscriber.getLocalDescription(), _ = this.pcManager.subscriber.getRemoteDescription(), k = (v = (l = this.signalOpts) === null || l === void 0 ? void 0 : l.autoSubscribe) !== null && v !== void 0 ? v : !0, M = new Array(), L = new Array();
    u.forEach((F) => {
      F.isDesired !== k && M.push(F.trackSid), F.isEnabled || L.push(F.trackSid);
    }), this.client.sendSyncState(new SyncState({
      answer: p ? toProtoSessionDescription({
        sdp: p.sdp,
        type: p.type
      }) : void 0,
      offer: _ ? toProtoSessionDescription({
        sdp: _.sdp,
        type: _.type
      }) : void 0,
      subscription: new UpdateSubscription({
        trackSids: M,
        subscribe: !k,
        participantTracks: []
      }),
      publishTracks: getTrackPublicationInfo(c),
      dataChannels: this.dataChannelsInfo(),
      trackSidsDisabled: L
    }));
  }
  /* @internal */
  failNext() {
    this.shouldFailNext = !0;
  }
  dataChannelsInfo() {
    const u = [], c = (l, v) => {
      (l == null ? void 0 : l.id) !== void 0 && l.id !== null && u.push(new DataChannelInfo({
        label: l.label,
        id: l.id,
        target: v
      }));
    };
    return c(this.dataChannelForKind(DataPacket_Kind.LOSSY), SignalTarget.PUBLISHER), c(this.dataChannelForKind(DataPacket_Kind.RELIABLE), SignalTarget.PUBLISHER), c(this.dataChannelForKind(DataPacket_Kind.LOSSY, !0), SignalTarget.SUBSCRIBER), c(this.dataChannelForKind(DataPacket_Kind.RELIABLE, !0), SignalTarget.SUBSCRIBER), u;
  }
  clearReconnectTimeout() {
    this.reconnectTimeout && CriticalTimers.clearTimeout(this.reconnectTimeout);
  }
  clearPendingReconnect() {
    this.clearReconnectTimeout(), this.reconnectAttempts = 0;
  }
  registerOnLineListener() {
    isWeb() && window.addEventListener("online", this.handleBrowserOnLine);
  }
  deregisterOnLineListener() {
    isWeb() && window.removeEventListener("online", this.handleBrowserOnLine);
  }
}
class SignalReconnectError extends Error {
}
class RegionUrlProvider {
  constructor(u, c) {
    this.lastUpdateAt = 0, this.settingsCacheTime = 3e3, this.attemptedRegions = [], this.serverUrl = new URL(u), this.token = c;
  }
  updateToken(u) {
    this.token = u;
  }
  isCloud() {
    return isCloud(this.serverUrl);
  }
  getServerUrl() {
    return this.serverUrl;
  }
  getNextBestRegionUrl(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!this.isCloud())
        throw Error("region availability is only supported for LiveKit Cloud domains");
      (!this.regionSettings || Date.now() - this.lastUpdateAt > this.settingsCacheTime) && (this.regionSettings = yield this.fetchRegionSettings(u));
      const c = this.regionSettings.regions.filter((l) => !this.attemptedRegions.find((v) => v.url === l.url));
      if (c.length > 0) {
        const l = c[0];
        return this.attemptedRegions.push(l), livekitLogger.debug("next region: ".concat(l.region)), l.url;
      } else
        return null;
    });
  }
  resetAttempts() {
    this.attemptedRegions = [];
  }
  /* @internal */
  fetchRegionSettings(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      const c = yield fetch("".concat(getCloudConfigUrl(this.serverUrl), "/regions"), {
        headers: {
          authorization: "Bearer ".concat(this.token)
        },
        signal: u
      });
      if (c.ok) {
        const l = yield c.json();
        return this.lastUpdateAt = Date.now(), l;
      } else
        throw new ConnectionError("Could not fetch region settings: ".concat(c.statusText), c.status === 401 ? 0 : void 0, c.status);
    });
  }
}
function getCloudConfigUrl(a) {
  return "".concat(a.protocol.replace("ws", "http"), "//").concat(a.host, "/settings");
}
const monitorFrequency = 2e3;
function computeBitrate(a, u) {
  if (!u)
    return 0;
  let c, l;
  return "bytesReceived" in a ? (c = a.bytesReceived, l = u.bytesReceived) : "bytesSent" in a && (c = a.bytesSent, l = u.bytesSent), c === void 0 || l === void 0 || a.timestamp === void 0 || u.timestamp === void 0 ? 0 : (c - l) * 8 * 1e3 / (a.timestamp - u.timestamp);
}
class LocalAudioTrack extends LocalTrack {
  /**
   *
   * @param mediaTrack
   * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks
   * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK
   */
  constructor(u, c) {
    let l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0, v = arguments.length > 3 ? arguments[3] : void 0, p = arguments.length > 4 ? arguments[4] : void 0;
    super(u, Track.Kind.Audio, c, l, p), this.stopOnMute = !1, this.monitorSender = () => __awaiter$3(this, void 0, void 0, function* () {
      if (!this.sender) {
        this._currentBitrate = 0;
        return;
      }
      let _;
      try {
        _ = yield this.getSenderStats();
      } catch (k) {
        this.log.error("could not get audio sender stats", Object.assign(Object.assign({}, this.logContext), {
          error: k
        }));
        return;
      }
      _ && this.prevStats && (this._currentBitrate = computeBitrate(_, this.prevStats)), this.prevStats = _;
    }), this.audioContext = v, this.checkForSilence();
  }
  setDeviceId(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this._constraints.deviceId === u && this._mediaStreamTrack.getSettings().deviceId === unwrapConstraint(u) ? !0 : (this._constraints.deviceId = u, this.isMuted || (yield this.restartTrack()), this.isMuted || unwrapConstraint(u) === this._mediaStreamTrack.getSettings().deviceId);
    });
  }
  mute() {
    const u = Object.create(null, {
      mute: {
        get: () => super.mute
      }
    });
    return __awaiter$3(this, void 0, void 0, function* () {
      const c = yield this.muteLock.lock();
      try {
        return this.isMuted ? (this.log.debug("Track already muted", this.logContext), this) : (this.source === Track.Source.Microphone && this.stopOnMute && !this.isUserProvided && (this.log.debug("stopping mic track", this.logContext), this._mediaStreamTrack.stop()), yield u.mute.call(this), this);
      } finally {
        c();
      }
    });
  }
  unmute() {
    const u = Object.create(null, {
      unmute: {
        get: () => super.unmute
      }
    });
    return __awaiter$3(this, void 0, void 0, function* () {
      const c = yield this.muteLock.lock();
      try {
        if (!this.isMuted)
          return this.log.debug("Track already unmuted", this.logContext), this;
        const l = this._constraints.deviceId && this._mediaStreamTrack.getSettings().deviceId !== unwrapConstraint(this._constraints.deviceId);
        return this.source === Track.Source.Microphone && (this.stopOnMute || this._mediaStreamTrack.readyState === "ended" || l) && !this.isUserProvided && (this.log.debug("reacquiring mic track", this.logContext), yield this.restartTrack()), yield u.unmute.call(this), this;
      } finally {
        c();
      }
    });
  }
  restartTrack(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      let c;
      if (u) {
        const l = constraintsForOptions({
          audio: u
        });
        typeof l.audio != "boolean" && (c = l.audio);
      }
      yield this.restart(c);
    });
  }
  restart(u) {
    const c = Object.create(null, {
      restart: {
        get: () => super.restart
      }
    });
    return __awaiter$3(this, void 0, void 0, function* () {
      const l = yield c.restart.call(this, u);
      return this.checkForSilence(), l;
    });
  }
  /* @internal */
  startMonitor() {
    isWeb() && (this.monitorInterval || (this.monitorInterval = setInterval(() => {
      this.monitorSender();
    }, monitorFrequency)));
  }
  setProcessor(u) {
    var c;
    return __awaiter$3(this, void 0, void 0, function* () {
      const l = yield this.processorLock.lock();
      try {
        if (!this.audioContext)
          throw Error("Audio context needs to be set on LocalAudioTrack in order to enable processors");
        this.processor && (yield this.stopProcessor());
        const v = {
          kind: this.kind,
          track: this._mediaStreamTrack,
          audioContext: this.audioContext
        };
        this.log.debug("setting up audio processor ".concat(u.name), this.logContext), yield u.init(v), this.processor = u, this.processor.processedTrack && (yield (c = this.sender) === null || c === void 0 ? void 0 : c.replaceTrack(this.processor.processedTrack)), this.emit(TrackEvent.TrackProcessorUpdate, this.processor);
      } finally {
        l();
      }
    });
  }
  /**
   * @internal
   * @experimental
   */
  setAudioContext(u) {
    this.audioContext = u;
  }
  getSenderStats() {
    var u;
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!(!((u = this.sender) === null || u === void 0) && u.getStats))
        return;
      const c = yield this.sender.getStats();
      let l;
      return c.forEach((v) => {
        v.type === "outbound-rtp" && (l = {
          type: "audio",
          streamId: v.id,
          packetsSent: v.packetsSent,
          packetsLost: v.packetsLost,
          bytesSent: v.bytesSent,
          timestamp: v.timestamp,
          roundTripTime: v.roundTripTime,
          jitter: v.jitter
        });
      }), l;
    });
  }
  checkForSilence() {
    return __awaiter$3(this, void 0, void 0, function* () {
      const u = yield detectSilence(this);
      return u && (this.isMuted || this.log.warn("silence detected on local audio track", this.logContext), this.emit(TrackEvent.AudioSilenceDetected)), u;
    });
  }
}
function mediaTrackToLocalTrack(a, u, c) {
  switch (a.kind) {
    case "audio":
      return new LocalAudioTrack(a, u, !1, void 0, c);
    case "video":
      return new LocalVideoTrack(a, u, !1, c);
    default:
      throw new TrackInvalidError("unsupported track type: ".concat(a.kind));
  }
}
const presets169 = Object.values(VideoPresets), presets43 = Object.values(VideoPresets43), presetsScreenShare = Object.values(ScreenSharePresets), defaultSimulcastPresets169 = [VideoPresets.h180, VideoPresets.h360], defaultSimulcastPresets43 = [VideoPresets43.h180, VideoPresets43.h360], computeDefaultScreenShareSimulcastPresets = (a) => [{
  scaleResolutionDownBy: 2,
  fps: a.encoding.maxFramerate
}].map((c) => {
  var l, v;
  return new VideoPreset(Math.floor(a.width / c.scaleResolutionDownBy), Math.floor(a.height / c.scaleResolutionDownBy), Math.max(15e4, Math.floor(a.encoding.maxBitrate / (Math.pow(c.scaleResolutionDownBy, 2) * (((l = a.encoding.maxFramerate) !== null && l !== void 0 ? l : 30) / ((v = c.fps) !== null && v !== void 0 ? v : 30))))), c.fps, a.encoding.priority);
}), videoRids = ["q", "h", "f"];
function computeVideoEncodings(a, u, c, l) {
  var v, p;
  let _ = l == null ? void 0 : l.videoEncoding;
  a && (_ = l == null ? void 0 : l.screenShareEncoding);
  const k = l == null ? void 0 : l.simulcast, M = l == null ? void 0 : l.scalabilityMode, L = l == null ? void 0 : l.videoCodec;
  if (!_ && !k && !M || !u || !c)
    return [{}];
  _ || (_ = determineAppropriateEncoding(a, u, c, L), livekitLogger.debug("using video encoding", _));
  const F = new VideoPreset(u, c, _.maxBitrate, _.maxFramerate, _.priority);
  if (M && isSVCCodec(L)) {
    const oe = new ScalabilityMode(M), Y = [];
    if (oe.spatial > 3)
      throw new Error("unsupported scalabilityMode: ".concat(M));
    const ae = getBrowser();
    if (isSafari() || (ae == null ? void 0 : ae.name) === "Chrome" && compareVersions(ae == null ? void 0 : ae.version, "113") < 0) {
      for (let ne = 0; ne < oe.spatial; ne += 1)
        Y.push({
          rid: videoRids[2 - ne],
          maxBitrate: _.maxBitrate / Math.pow(3, ne),
          maxFramerate: F.encoding.maxFramerate
        });
      Y[0].scalabilityMode = M;
    } else
      Y.push({
        maxBitrate: _.maxBitrate,
        maxFramerate: F.encoding.maxFramerate,
        /* @ts-ignore */
        scalabilityMode: M
      });
    return livekitLogger.debug("using svc encoding", {
      encodings: Y
    }), Y;
  }
  if (!k)
    return [_];
  let V = [];
  a ? V = (v = sortPresets(l == null ? void 0 : l.screenShareSimulcastLayers)) !== null && v !== void 0 ? v : defaultSimulcastLayers(a, F) : V = (p = sortPresets(l == null ? void 0 : l.videoSimulcastLayers)) !== null && p !== void 0 ? p : defaultSimulcastLayers(a, F);
  let X;
  if (V.length > 0) {
    const oe = V[0];
    V.length > 1 && ([, X] = V);
    const Y = Math.max(u, c);
    if (Y >= 960 && X)
      return encodingsFromPresets(u, c, [oe, X, F]);
    if (Y >= 480)
      return encodingsFromPresets(u, c, [oe, F]);
  }
  return encodingsFromPresets(u, c, [F]);
}
function computeTrackBackupEncodings(a, u, c) {
  var l, v, p, _;
  if (!c.backupCodec || c.backupCodec === !0 || c.backupCodec.codec === c.videoCodec)
    return;
  u !== c.backupCodec.codec && livekitLogger.warn("requested a different codec than specified as backup", {
    serverRequested: u,
    backup: c.backupCodec.codec
  }), c.videoCodec = u, c.videoEncoding = c.backupCodec.encoding;
  const k = a.mediaStreamTrack.getSettings(), M = (l = k.width) !== null && l !== void 0 ? l : (v = a.dimensions) === null || v === void 0 ? void 0 : v.width, L = (p = k.height) !== null && p !== void 0 ? p : (_ = a.dimensions) === null || _ === void 0 ? void 0 : _.height;
  return computeVideoEncodings(a.source === Track.Source.ScreenShare, M, L, c);
}
function determineAppropriateEncoding(a, u, c, l) {
  const v = presetsForResolution(a, u, c);
  let {
    encoding: p
  } = v[0];
  const _ = Math.max(u, c);
  for (let k = 0; k < v.length; k += 1) {
    const M = v[k];
    if (p = M.encoding, M.width >= _)
      break;
  }
  if (l)
    switch (l) {
      case "av1":
        p = Object.assign({}, p), p.maxBitrate = p.maxBitrate * 0.7;
        break;
      case "vp9":
        p = Object.assign({}, p), p.maxBitrate = p.maxBitrate * 0.85;
        break;
    }
  return p;
}
function presetsForResolution(a, u, c) {
  if (a)
    return presetsScreenShare;
  const l = u > c ? u / c : c / u;
  return Math.abs(l - 16 / 9) < Math.abs(l - 4 / 3) ? presets169 : presets43;
}
function defaultSimulcastLayers(a, u) {
  if (a)
    return computeDefaultScreenShareSimulcastPresets(u);
  const {
    width: c,
    height: l
  } = u, v = c > l ? c / l : l / c;
  return Math.abs(v - 16 / 9) < Math.abs(v - 4 / 3) ? defaultSimulcastPresets169 : defaultSimulcastPresets43;
}
function encodingsFromPresets(a, u, c) {
  const l = [];
  if (c.forEach((v, p) => {
    if (p >= videoRids.length)
      return;
    const _ = Math.min(a, u), M = {
      rid: videoRids[p],
      scaleResolutionDownBy: Math.max(1, _ / Math.min(v.width, v.height)),
      maxBitrate: v.encoding.maxBitrate
    };
    v.encoding.maxFramerate && (M.maxFramerate = v.encoding.maxFramerate);
    const L = isFireFox() || p === 0;
    v.encoding.priority && L && (M.priority = v.encoding.priority, M.networkPriority = v.encoding.priority), l.push(M);
  }), isReactNative() && getReactNativeOs() === "ios") {
    let v;
    l.forEach((_) => {
      v ? _.maxFramerate && _.maxFramerate > v && (v = _.maxFramerate) : v = _.maxFramerate;
    });
    let p = !0;
    l.forEach((_) => {
      var k;
      _.maxFramerate != v && (p && (p = !1, livekitLogger.info("Simulcast on iOS React-Native requires all encodings to share the same framerate.")), livekitLogger.info('Setting framerate of encoding "'.concat((k = _.rid) !== null && k !== void 0 ? k : "", '" to ').concat(v)), _.maxFramerate = v);
    });
  }
  return l;
}
function sortPresets(a) {
  if (a)
    return a.sort((u, c) => {
      const {
        encoding: l
      } = u, {
        encoding: v
      } = c;
      return l.maxBitrate > v.maxBitrate ? 1 : l.maxBitrate < v.maxBitrate ? -1 : l.maxBitrate === v.maxBitrate && l.maxFramerate && v.maxFramerate ? l.maxFramerate > v.maxFramerate ? 1 : -1 : 0;
    });
}
class ScalabilityMode {
  constructor(u) {
    const c = u.match(/^L(\d)T(\d)(h|_KEY|_KEY_SHIFT){0,1}$/);
    if (!c)
      throw new Error("invalid scalability mode");
    if (this.spatial = parseInt(c[1]), this.temporal = parseInt(c[2]), c.length > 3)
      switch (c[3]) {
        case "h":
        case "_KEY":
        case "_KEY_SHIFT":
          this.suffix = c[3];
      }
  }
  toString() {
    var u;
    return "L".concat(this.spatial, "T").concat(this.temporal).concat((u = this.suffix) !== null && u !== void 0 ? u : "");
  }
}
const refreshSubscribedCodecAfterNewCodec = 5e3;
class LocalVideoTrack extends LocalTrack {
  /**
   *
   * @param mediaTrack
   * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks
   * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK
   */
  constructor(u, c) {
    let l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0, v = arguments.length > 3 ? arguments[3] : void 0;
    super(u, Track.Kind.Video, c, l, v), this.simulcastCodecs = /* @__PURE__ */ new Map(), this.monitorSender = () => __awaiter$3(this, void 0, void 0, function* () {
      if (!this.sender) {
        this._currentBitrate = 0;
        return;
      }
      let p;
      try {
        p = yield this.getSenderStats();
      } catch (k) {
        this.log.error("could not get audio sender stats", Object.assign(Object.assign({}, this.logContext), {
          error: k
        }));
        return;
      }
      const _ = new Map(p.map((k) => [k.rid, k]));
      if (this.prevStats) {
        let k = 0;
        _.forEach((M, L) => {
          var F;
          const V = (F = this.prevStats) === null || F === void 0 ? void 0 : F.get(L);
          k += computeBitrate(M, V);
        }), this._currentBitrate = k;
      }
      this.prevStats = _;
    }), this.senderLock = new Mutex();
  }
  get isSimulcast() {
    return !!(this.sender && this.sender.getParameters().encodings.length > 1);
  }
  /* @internal */
  startMonitor(u) {
    var c;
    if (this.signalClient = u, !isWeb())
      return;
    const l = (c = this.sender) === null || c === void 0 ? void 0 : c.getParameters();
    l && (this.encodings = l.encodings), !this.monitorInterval && (this.monitorInterval = setInterval(() => {
      this.monitorSender();
    }, monitorFrequency));
  }
  stop() {
    this._mediaStreamTrack.getConstraints(), this.simulcastCodecs.forEach((u) => {
      u.mediaStreamTrack.stop();
    }), super.stop();
  }
  pauseUpstream() {
    const u = Object.create(null, {
      pauseUpstream: {
        get: () => super.pauseUpstream
      }
    });
    var c, l, v, p, _;
    return __awaiter$3(this, void 0, void 0, function* () {
      yield u.pauseUpstream.call(this);
      try {
        for (var k = !0, M = __asyncValues(this.simulcastCodecs.values()), L; L = yield M.next(), c = L.done, !c; k = !0)
          p = L.value, k = !1, yield (_ = p.sender) === null || _ === void 0 ? void 0 : _.replaceTrack(null);
      } catch (F) {
        l = {
          error: F
        };
      } finally {
        try {
          !k && !c && (v = M.return) && (yield v.call(M));
        } finally {
          if (l)
            throw l.error;
        }
      }
    });
  }
  resumeUpstream() {
    const u = Object.create(null, {
      resumeUpstream: {
        get: () => super.resumeUpstream
      }
    });
    var c, l, v, p, _;
    return __awaiter$3(this, void 0, void 0, function* () {
      yield u.resumeUpstream.call(this);
      try {
        for (var k = !0, M = __asyncValues(this.simulcastCodecs.values()), L; L = yield M.next(), c = L.done, !c; k = !0) {
          p = L.value, k = !1;
          const F = p;
          yield (_ = F.sender) === null || _ === void 0 ? void 0 : _.replaceTrack(F.mediaStreamTrack);
        }
      } catch (F) {
        l = {
          error: F
        };
      } finally {
        try {
          !k && !c && (v = M.return) && (yield v.call(M));
        } finally {
          if (l)
            throw l.error;
        }
      }
    });
  }
  mute() {
    const u = Object.create(null, {
      mute: {
        get: () => super.mute
      }
    });
    return __awaiter$3(this, void 0, void 0, function* () {
      const c = yield this.muteLock.lock();
      try {
        return this.isMuted ? (this.log.debug("Track already muted", this.logContext), this) : (this.source === Track.Source.Camera && !this.isUserProvided && (this.log.debug("stopping camera track", this.logContext), this._mediaStreamTrack.stop()), yield u.mute.call(this), this);
      } finally {
        c();
      }
    });
  }
  unmute() {
    const u = Object.create(null, {
      unmute: {
        get: () => super.unmute
      }
    });
    return __awaiter$3(this, void 0, void 0, function* () {
      const c = yield this.muteLock.lock();
      try {
        return this.isMuted ? (this.source === Track.Source.Camera && !this.isUserProvided && (this.log.debug("reacquiring camera track", this.logContext), yield this.restartTrack()), yield u.unmute.call(this), this) : (this.log.debug("Track already unmuted", this.logContext), this);
      } finally {
        c();
      }
    });
  }
  setTrackMuted(u) {
    super.setTrackMuted(u);
    for (const c of this.simulcastCodecs.values())
      c.mediaStreamTrack.enabled = !u;
  }
  getSenderStats() {
    var u;
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!(!((u = this.sender) === null || u === void 0) && u.getStats))
        return [];
      const c = [], l = yield this.sender.getStats();
      return l.forEach((v) => {
        var p;
        if (v.type === "outbound-rtp") {
          const _ = {
            type: "video",
            streamId: v.id,
            frameHeight: v.frameHeight,
            frameWidth: v.frameWidth,
            framesPerSecond: v.framesPerSecond,
            framesSent: v.framesSent,
            firCount: v.firCount,
            pliCount: v.pliCount,
            nackCount: v.nackCount,
            packetsSent: v.packetsSent,
            bytesSent: v.bytesSent,
            qualityLimitationReason: v.qualityLimitationReason,
            qualityLimitationDurations: v.qualityLimitationDurations,
            qualityLimitationResolutionChanges: v.qualityLimitationResolutionChanges,
            rid: (p = v.rid) !== null && p !== void 0 ? p : v.id,
            retransmittedPacketsSent: v.retransmittedPacketsSent,
            targetBitrate: v.targetBitrate,
            timestamp: v.timestamp
          }, k = l.get(v.remoteId);
          k && (_.jitter = k.jitter, _.packetsLost = k.packetsLost, _.roundTripTime = k.roundTripTime), c.push(_);
        }
      }), c.sort((v, p) => {
        var _, k;
        return ((_ = p.frameWidth) !== null && _ !== void 0 ? _ : 0) - ((k = v.frameWidth) !== null && k !== void 0 ? k : 0);
      }), c;
    });
  }
  setPublishingQuality(u) {
    const c = [];
    for (let l = VideoQuality.LOW; l <= VideoQuality.HIGH; l += 1)
      c.push(new SubscribedQuality({
        quality: l,
        enabled: l <= u
      }));
    this.log.debug("setting publishing quality. max quality ".concat(u), this.logContext), this.setPublishingLayers(c);
  }
  setDeviceId(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this._constraints.deviceId === u && this._mediaStreamTrack.getSettings().deviceId === unwrapConstraint(u) ? !0 : (this._constraints.deviceId = u, this.isMuted || (yield this.restartTrack()), this.isMuted || unwrapConstraint(u) === this._mediaStreamTrack.getSettings().deviceId);
    });
  }
  restartTrack(u) {
    var c, l, v, p;
    return __awaiter$3(this, void 0, void 0, function* () {
      let _;
      if (u) {
        const F = constraintsForOptions({
          video: u
        });
        typeof F.video != "boolean" && (_ = F.video);
      }
      yield this.restart(_);
      try {
        for (var k = !0, M = __asyncValues(this.simulcastCodecs.values()), L; L = yield M.next(), c = L.done, !c; k = !0) {
          p = L.value, k = !1;
          const F = p;
          F.sender && (F.mediaStreamTrack = this.mediaStreamTrack.clone(), yield F.sender.replaceTrack(F.mediaStreamTrack));
        }
      } catch (F) {
        l = {
          error: F
        };
      } finally {
        try {
          !k && !c && (v = M.return) && (yield v.call(M));
        } finally {
          if (l)
            throw l.error;
        }
      }
    });
  }
  setProcessor(u) {
    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
    const l = Object.create(null, {
      setProcessor: {
        get: () => super.setProcessor
      }
    });
    var v, p, _, k, M, L;
    return __awaiter$3(this, void 0, void 0, function* () {
      if (yield l.setProcessor.call(this, u, c), !((M = this.processor) === null || M === void 0) && M.processedTrack)
        try {
          for (var F = !0, V = __asyncValues(this.simulcastCodecs.values()), X; X = yield V.next(), v = X.done, !v; F = !0)
            k = X.value, F = !1, yield (L = k.sender) === null || L === void 0 ? void 0 : L.replaceTrack(this.processor.processedTrack);
        } catch (oe) {
          p = {
            error: oe
          };
        } finally {
          try {
            !F && !v && (_ = V.return) && (yield _.call(V));
          } finally {
            if (p)
              throw p.error;
          }
        }
    });
  }
  addSimulcastTrack(u, c) {
    if (this.simulcastCodecs.has(u)) {
      this.log.error("".concat(u, " already added, skipping adding simulcast codec"), this.logContext);
      return;
    }
    const l = {
      codec: u,
      mediaStreamTrack: this.mediaStreamTrack.clone(),
      sender: void 0,
      encodings: c
    };
    return this.simulcastCodecs.set(u, l), l;
  }
  setSimulcastTrackSender(u, c) {
    const l = this.simulcastCodecs.get(u);
    l && (l.sender = c, setTimeout(() => {
      this.subscribedCodecs && this.setPublishingCodecs(this.subscribedCodecs);
    }, refreshSubscribedCodecAfterNewCodec));
  }
  /**
   * @internal
   * Sets codecs that should be publishing, returns new codecs that have not yet
   * been published
   */
  setPublishingCodecs(u) {
    var c, l, v, p, _, k, M;
    return __awaiter$3(this, void 0, void 0, function* () {
      if (this.log.debug("setting publishing codecs", Object.assign(Object.assign({}, this.logContext), {
        codecs: u,
        currentCodec: this.codec
      })), !this.codec && u.length > 0)
        return yield this.setPublishingLayers(u[0].qualities), [];
      this.subscribedCodecs = u;
      const L = [];
      try {
        for (c = !0, l = __asyncValues(u); v = yield l.next(), p = v.done, !p; c = !0) {
          M = v.value, c = !1;
          const F = M;
          if (!this.codec || this.codec === F.codec)
            yield this.setPublishingLayers(F.qualities);
          else {
            const V = this.simulcastCodecs.get(F.codec);
            if (this.log.debug("try setPublishingCodec for ".concat(F.codec), Object.assign(Object.assign({}, this.logContext), {
              simulcastCodecInfo: V
            })), !V || !V.sender) {
              for (const X of F.qualities)
                if (X.enabled) {
                  L.push(F.codec);
                  break;
                }
            } else
              V.encodings && (this.log.debug("try setPublishingLayersForSender ".concat(F.codec), this.logContext), yield setPublishingLayersForSender(V.sender, V.encodings, F.qualities, this.senderLock, this.log, this.logContext));
          }
        }
      } catch (F) {
        _ = {
          error: F
        };
      } finally {
        try {
          !c && !p && (k = l.return) && (yield k.call(l));
        } finally {
          if (_)
            throw _.error;
        }
      }
      return L;
    });
  }
  /**
   * @internal
   * Sets layers that should be publishing
   */
  setPublishingLayers(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      this.log.debug("setting publishing layers", Object.assign(Object.assign({}, this.logContext), {
        qualities: u
      })), !(!this.sender || !this.encodings) && (yield setPublishingLayersForSender(this.sender, this.encodings, u, this.senderLock, this.log, this.logContext));
    });
  }
  handleAppVisibilityChanged() {
    const u = Object.create(null, {
      handleAppVisibilityChanged: {
        get: () => super.handleAppVisibilityChanged
      }
    });
    return __awaiter$3(this, void 0, void 0, function* () {
      yield u.handleAppVisibilityChanged.call(this), isMobile() && this.isInBackground && this.source === Track.Source.Camera && (this._mediaStreamTrack.enabled = !1);
    });
  }
}
function setPublishingLayersForSender(a, u, c, l, v, p) {
  return __awaiter$3(this, void 0, void 0, function* () {
    const _ = yield l.lock();
    v.debug("setPublishingLayersForSender", Object.assign(Object.assign({}, p), {
      sender: a,
      qualities: c,
      senderEncodings: u
    }));
    try {
      const k = a.getParameters(), {
        encodings: M
      } = k;
      if (!M)
        return;
      if (M.length !== u.length) {
        v.warn("cannot set publishing layers, encodings mismatch", Object.assign(Object.assign({}, p), {
          encodings: M,
          senderEncodings: u
        }));
        return;
      }
      let L = !1;
      !1 && M[0].scalabilityMode || M.forEach((V, X) => {
        var oe;
        let Y = (oe = V.rid) !== null && oe !== void 0 ? oe : "";
        Y === "" && (Y = "q");
        const ae = videoQualityForRid(Y), ne = c.find((fe) => fe.quality === ae);
        ne && V.active !== ne.enabled && (L = !0, V.active = ne.enabled, v.debug("setting layer ".concat(ne.quality, " to ").concat(V.active ? "enabled" : "disabled"), p), isFireFox() && (ne.enabled ? (V.scaleResolutionDownBy = u[X].scaleResolutionDownBy, V.maxBitrate = u[X].maxBitrate, V.maxFrameRate = u[X].maxFrameRate) : (V.scaleResolutionDownBy = 4, V.maxBitrate = 10, V.maxFrameRate = 2)));
      }), L && (k.encodings = M, v.debug("setting encodings", Object.assign(Object.assign({}, p), {
        encodings: k.encodings
      })), yield a.setParameters(k));
    } finally {
      _();
    }
  });
}
function videoQualityForRid(a) {
  switch (a) {
    case "f":
      return VideoQuality.HIGH;
    case "h":
      return VideoQuality.MEDIUM;
    case "q":
      return VideoQuality.LOW;
    default:
      return VideoQuality.HIGH;
  }
}
function videoLayersFromEncodings(a, u, c, l) {
  if (!c)
    return [new VideoLayer({
      quality: VideoQuality.HIGH,
      width: a,
      height: u,
      bitrate: 0,
      ssrc: 0
    })];
  if (l) {
    const v = c[0].scalabilityMode, p = new ScalabilityMode(v), _ = [];
    for (let k = 0; k < p.spatial; k += 1)
      _.push(new VideoLayer({
        quality: VideoQuality.HIGH - k,
        width: Math.ceil(a / Math.pow(2, k)),
        height: Math.ceil(u / Math.pow(2, k)),
        bitrate: c[0].maxBitrate ? Math.ceil(c[0].maxBitrate / Math.pow(3, k)) : 0,
        ssrc: 0
      }));
    return _;
  }
  return c.map((v) => {
    var p, _, k;
    const M = (p = v.scaleResolutionDownBy) !== null && p !== void 0 ? p : 1;
    let L = videoQualityForRid((_ = v.rid) !== null && _ !== void 0 ? _ : "");
    return new VideoLayer({
      quality: L,
      width: Math.ceil(a / M),
      height: Math.ceil(u / M),
      bitrate: (k = v.maxBitrate) !== null && k !== void 0 ? k : 0,
      ssrc: 0
    });
  });
}
class RemoteTrack extends Track {
  constructor(u, c, l, v, p) {
    super(u, l, p), this.sid = c, this.receiver = v;
  }
  /** @internal */
  setMuted(u) {
    this.isMuted !== u && (this.isMuted = u, this._mediaStreamTrack.enabled = !u, this.emit(u ? TrackEvent.Muted : TrackEvent.Unmuted, this));
  }
  /** @internal */
  setMediaStream(u) {
    this.mediaStream = u;
    const c = (l) => {
      l.track === this._mediaStreamTrack && (u.removeEventListener("removetrack", c), this.receiver = void 0, this._currentBitrate = 0, this.emit(TrackEvent.Ended, this));
    };
    u.addEventListener("removetrack", c);
  }
  start() {
    this.startMonitor(), super.enable();
  }
  stop() {
    this.stopMonitor(), super.disable();
  }
  /**
   * Gets the RTCStatsReport for the RemoteTrack's underlying RTCRtpReceiver
   * See https://developer.mozilla.org/en-US/docs/Web/API/RTCStatsReport
   *
   * @returns Promise<RTCStatsReport> | undefined
   */
  getRTCStatsReport() {
    var u;
    return __awaiter$3(this, void 0, void 0, function* () {
      return !((u = this.receiver) === null || u === void 0) && u.getStats ? yield this.receiver.getStats() : void 0;
    });
  }
  /* @internal */
  startMonitor() {
    this.monitorInterval || (this.monitorInterval = setInterval(() => this.monitorReceiver(), monitorFrequency));
  }
}
class RemoteAudioTrack extends RemoteTrack {
  constructor(u, c, l, v, p, _) {
    super(u, c, Track.Kind.Audio, l, _), this.monitorReceiver = () => __awaiter$3(this, void 0, void 0, function* () {
      if (!this.receiver) {
        this._currentBitrate = 0;
        return;
      }
      const k = yield this.getReceiverStats();
      k && this.prevStats && this.receiver && (this._currentBitrate = computeBitrate(k, this.prevStats)), this.prevStats = k;
    }), this.audioContext = v, this.webAudioPluginNodes = [], p && (this.sinkId = p.deviceId);
  }
  /**
   * sets the volume for all attached audio elements
   */
  setVolume(u) {
    var c;
    for (const l of this.attachedElements)
      this.audioContext ? (c = this.gainNode) === null || c === void 0 || c.gain.setTargetAtTime(u, 0, 0.1) : l.volume = u;
    isReactNative() && this._mediaStreamTrack._setVolume(u), this.elementVolume = u;
  }
  /**
   * gets the volume of attached audio elements (loudest)
   */
  getVolume() {
    if (this.elementVolume)
      return this.elementVolume;
    if (isReactNative())
      return 1;
    let u = 0;
    return this.attachedElements.forEach((c) => {
      c.volume > u && (u = c.volume);
    }), u;
  }
  /**
   * calls setSinkId on all attached elements, if supported
   * @param deviceId audio output device
   */
  setSinkId(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      this.sinkId = u, yield Promise.all(this.attachedElements.map((c) => {
        if (supportsSetSinkId(c))
          return c.setSinkId(u);
      }));
    });
  }
  attach(u) {
    const c = this.attachedElements.length === 0;
    return u ? super.attach(u) : u = super.attach(), this.sinkId && supportsSetSinkId(u) && u.setSinkId(this.sinkId), this.audioContext && c && (this.log.debug("using audio context mapping", this.logContext), this.connectWebAudio(this.audioContext, u), u.volume = 0, u.muted = !0), this.elementVolume && this.setVolume(this.elementVolume), u;
  }
  detach(u) {
    let c;
    return u ? (c = super.detach(u), this.audioContext && (this.attachedElements.length > 0 ? this.connectWebAudio(this.audioContext, this.attachedElements[0]) : this.disconnectWebAudio())) : (c = super.detach(), this.disconnectWebAudio()), c;
  }
  /**
   * @internal
   * @experimental
   */
  setAudioContext(u) {
    this.audioContext = u, u && this.attachedElements.length > 0 ? this.connectWebAudio(u, this.attachedElements[0]) : u || this.disconnectWebAudio();
  }
  /**
   * @internal
   * @experimental
   * @param {AudioNode[]} nodes - An array of WebAudio nodes. These nodes should not be connected to each other when passed, as the sdk will take care of connecting them in the order of the array.
   */
  setWebAudioPlugins(u) {
    this.webAudioPluginNodes = u, this.attachedElements.length > 0 && this.audioContext && this.connectWebAudio(this.audioContext, this.attachedElements[0]);
  }
  connectWebAudio(u, c) {
    this.disconnectWebAudio(), this.sourceNode = u.createMediaStreamSource(c.srcObject);
    let l = this.sourceNode;
    this.webAudioPluginNodes.forEach((v) => {
      l.connect(v), l = v;
    }), this.gainNode = u.createGain(), l.connect(this.gainNode), this.gainNode.connect(u.destination), this.elementVolume && this.gainNode.gain.setTargetAtTime(this.elementVolume, 0, 0.1), u.state !== "running" && u.resume().then(() => {
      u.state !== "running" && this.emit(TrackEvent.AudioPlaybackFailed, new Error("Audio Context couldn't be started automatically"));
    }).catch((v) => {
      this.emit(TrackEvent.AudioPlaybackFailed, v);
    });
  }
  disconnectWebAudio() {
    var u, c;
    (u = this.gainNode) === null || u === void 0 || u.disconnect(), (c = this.sourceNode) === null || c === void 0 || c.disconnect(), this.gainNode = void 0, this.sourceNode = void 0;
  }
  getReceiverStats() {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!this.receiver || !this.receiver.getStats)
        return;
      const u = yield this.receiver.getStats();
      let c;
      return u.forEach((l) => {
        l.type === "inbound-rtp" && (c = {
          type: "audio",
          timestamp: l.timestamp,
          jitter: l.jitter,
          bytesReceived: l.bytesReceived,
          concealedSamples: l.concealedSamples,
          concealmentEvents: l.concealmentEvents,
          silentConcealedSamples: l.silentConcealedSamples,
          silentConcealmentEvents: l.silentConcealmentEvents,
          totalAudioEnergy: l.totalAudioEnergy,
          totalSamplesDuration: l.totalSamplesDuration
        });
      }), c;
    });
  }
}
const REACTION_DELAY = 100;
class RemoteVideoTrack extends RemoteTrack {
  constructor(u, c, l, v, p) {
    super(u, c, Track.Kind.Video, l, p), this.elementInfos = [], this.monitorReceiver = () => __awaiter$3(this, void 0, void 0, function* () {
      if (!this.receiver) {
        this._currentBitrate = 0;
        return;
      }
      const _ = yield this.getReceiverStats();
      _ && this.prevStats && this.receiver && (this._currentBitrate = computeBitrate(_, this.prevStats)), this.prevStats = _;
    }), this.debouncedHandleResize = r$1(() => {
      this.updateDimensions();
    }, REACTION_DELAY), this.adaptiveStreamSettings = v;
  }
  get isAdaptiveStream() {
    return this.adaptiveStreamSettings !== void 0;
  }
  /**
   * Note: When using adaptiveStream, you need to use remoteVideoTrack.attach() to add the track to a HTMLVideoElement, otherwise your video tracks might never start
   */
  get mediaStreamTrack() {
    return this._mediaStreamTrack;
  }
  /** @internal */
  setMuted(u) {
    super.setMuted(u), this.attachedElements.forEach((c) => {
      u ? detachTrack(this._mediaStreamTrack, c) : attachToElement(this._mediaStreamTrack, c);
    });
  }
  attach(u) {
    if (u ? super.attach(u) : u = super.attach(), this.adaptiveStreamSettings && this.elementInfos.find((c) => c.element === u) === void 0) {
      const c = new HTMLElementInfo(u);
      this.observeElementInfo(c);
    }
    return u;
  }
  /**
   * Observe an ElementInfo for changes when adaptive streaming.
   * @param elementInfo
   * @internal
   */
  observeElementInfo(u) {
    this.adaptiveStreamSettings && this.elementInfos.find((c) => c === u) === void 0 ? (u.handleResize = () => {
      this.debouncedHandleResize();
    }, u.handleVisibilityChanged = () => {
      this.updateVisibility();
    }, this.elementInfos.push(u), u.observe(), this.debouncedHandleResize(), this.updateVisibility()) : this.log.warn("visibility resize observer not triggered", this.logContext);
  }
  /**
   * Stop observing an ElementInfo for changes.
   * @param elementInfo
   * @internal
   */
  stopObservingElementInfo(u) {
    if (!this.isAdaptiveStream) {
      this.log.warn("stopObservingElementInfo ignored", this.logContext);
      return;
    }
    const c = this.elementInfos.filter((l) => l === u);
    for (const l of c)
      l.stopObserving();
    this.elementInfos = this.elementInfos.filter((l) => l !== u), this.updateVisibility(), this.debouncedHandleResize();
  }
  detach(u) {
    let c = [];
    if (u)
      return this.stopObservingElement(u), super.detach(u);
    c = super.detach();
    for (const l of c)
      this.stopObservingElement(l);
    return c;
  }
  /** @internal */
  getDecoderImplementation() {
    var u;
    return (u = this.prevStats) === null || u === void 0 ? void 0 : u.decoderImplementation;
  }
  getReceiverStats() {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!this.receiver || !this.receiver.getStats)
        return;
      const u = yield this.receiver.getStats();
      let c, l = "", v = /* @__PURE__ */ new Map();
      return u.forEach((p) => {
        p.type === "inbound-rtp" ? (l = p.codecId, c = {
          type: "video",
          framesDecoded: p.framesDecoded,
          framesDropped: p.framesDropped,
          framesReceived: p.framesReceived,
          packetsReceived: p.packetsReceived,
          packetsLost: p.packetsLost,
          frameWidth: p.frameWidth,
          frameHeight: p.frameHeight,
          pliCount: p.pliCount,
          firCount: p.firCount,
          nackCount: p.nackCount,
          jitter: p.jitter,
          timestamp: p.timestamp,
          bytesReceived: p.bytesReceived,
          decoderImplementation: p.decoderImplementation
        }) : p.type === "codec" && v.set(p.id, p);
      }), c && l !== "" && v.get(l) && (c.mimeType = v.get(l).mimeType), c;
    });
  }
  stopObservingElement(u) {
    const c = this.elementInfos.filter((l) => l.element === u);
    for (const l of c)
      this.stopObservingElementInfo(l);
  }
  handleAppVisibilityChanged() {
    const u = Object.create(null, {
      handleAppVisibilityChanged: {
        get: () => super.handleAppVisibilityChanged
      }
    });
    return __awaiter$3(this, void 0, void 0, function* () {
      yield u.handleAppVisibilityChanged.call(this), this.isAdaptiveStream && this.updateVisibility();
    });
  }
  updateVisibility() {
    var u, c;
    const l = this.elementInfos.reduce((k, M) => Math.max(k, M.visibilityChangedAt || 0), 0), v = !((c = (u = this.adaptiveStreamSettings) === null || u === void 0 ? void 0 : u.pauseVideoInBackground) !== null && c !== void 0) || c ? this.isInBackground : !1, p = this.elementInfos.some((k) => k.pictureInPicture), _ = this.elementInfos.some((k) => k.visible) && !v || p;
    if (this.lastVisible !== _) {
      if (!_ && Date.now() - l < REACTION_DELAY) {
        CriticalTimers.setTimeout(() => {
          this.updateVisibility();
        }, REACTION_DELAY);
        return;
      }
      this.lastVisible = _, this.emit(TrackEvent.VisibilityChanged, _, this);
    }
  }
  updateDimensions() {
    var u, c;
    let l = 0, v = 0;
    const p = this.getPixelDensity();
    for (const _ of this.elementInfos) {
      const k = _.width() * p, M = _.height() * p;
      k + M > l + v && (l = k, v = M);
    }
    ((u = this.lastDimensions) === null || u === void 0 ? void 0 : u.width) === l && ((c = this.lastDimensions) === null || c === void 0 ? void 0 : c.height) === v || (this.lastDimensions = {
      width: l,
      height: v
    }, this.emit(TrackEvent.VideoDimensionsChanged, this.lastDimensions, this));
  }
  getPixelDensity() {
    var u;
    const c = (u = this.adaptiveStreamSettings) === null || u === void 0 ? void 0 : u.pixelDensity;
    return c === "screen" ? getDevicePixelRatio() : c || (getDevicePixelRatio() > 2 ? 2 : 1);
  }
}
class HTMLElementInfo {
  get visible() {
    return this.isPiP || this.isIntersecting;
  }
  get pictureInPicture() {
    return this.isPiP;
  }
  constructor(u, c) {
    this.onVisibilityChanged = (l) => {
      var v;
      const {
        target: p,
        isIntersecting: _
      } = l;
      p === this.element && (this.isIntersecting = _, this.visibilityChangedAt = Date.now(), (v = this.handleVisibilityChanged) === null || v === void 0 || v.call(this));
    }, this.onEnterPiP = () => {
      var l;
      this.isPiP = !0, (l = this.handleVisibilityChanged) === null || l === void 0 || l.call(this);
    }, this.onLeavePiP = () => {
      var l;
      this.isPiP = !1, (l = this.handleVisibilityChanged) === null || l === void 0 || l.call(this);
    }, this.element = u, this.isIntersecting = c ?? isElementInViewport(u), this.isPiP = isWeb() && document.pictureInPictureElement === u, this.visibilityChangedAt = 0;
  }
  width() {
    return this.element.clientWidth;
  }
  height() {
    return this.element.clientHeight;
  }
  observe() {
    this.isIntersecting = isElementInViewport(this.element), this.isPiP = document.pictureInPictureElement === this.element, this.element.handleResize = () => {
      var u;
      (u = this.handleResize) === null || u === void 0 || u.call(this);
    }, this.element.handleVisibilityChanged = this.onVisibilityChanged, getIntersectionObserver().observe(this.element), getResizeObserver().observe(this.element), this.element.addEventListener("enterpictureinpicture", this.onEnterPiP), this.element.addEventListener("leavepictureinpicture", this.onLeavePiP);
  }
  stopObserving() {
    var u, c;
    (u = getIntersectionObserver()) === null || u === void 0 || u.unobserve(this.element), (c = getResizeObserver()) === null || c === void 0 || c.unobserve(this.element), this.element.removeEventListener("enterpictureinpicture", this.onEnterPiP), this.element.removeEventListener("leavepictureinpicture", this.onLeavePiP);
  }
}
function isElementInViewport(a) {
  let u = a.offsetTop, c = a.offsetLeft;
  const l = a.offsetWidth, v = a.offsetHeight, {
    hidden: p
  } = a, {
    opacity: _,
    display: k
  } = getComputedStyle(a);
  for (; a.offsetParent; )
    a = a.offsetParent, u += a.offsetTop, c += a.offsetLeft;
  return u < window.pageYOffset + window.innerHeight && c < window.pageXOffset + window.innerWidth && u + v > window.pageYOffset && c + l > window.pageXOffset && !p && (_ !== "" ? parseFloat(_) > 0 : !0) && k !== "none";
}
class TrackPublication extends eventsExports$1.EventEmitter {
  constructor(u, c, l, v) {
    var p;
    super(), this.metadataMuted = !1, this.encryption = Encryption_Type.NONE, this.log = livekitLogger, this.handleMuted = () => {
      this.emit(TrackEvent.Muted);
    }, this.handleUnmuted = () => {
      this.emit(TrackEvent.Unmuted);
    }, this.log = getLogger((p = v == null ? void 0 : v.loggerName) !== null && p !== void 0 ? p : LoggerNames.Publication), this.loggerContextCb = this.loggerContextCb, this.setMaxListeners(100), this.kind = u, this.trackSid = c, this.trackName = l, this.source = Track.Source.Unknown;
  }
  /** @internal */
  setTrack(u) {
    this.track && (this.track.off(TrackEvent.Muted, this.handleMuted), this.track.off(TrackEvent.Unmuted, this.handleUnmuted)), this.track = u, u && (u.on(TrackEvent.Muted, this.handleMuted), u.on(TrackEvent.Unmuted, this.handleUnmuted));
  }
  get logContext() {
    var u;
    return Object.assign(Object.assign({}, (u = this.loggerContextCb) === null || u === void 0 ? void 0 : u.call(this)), getLogContextFromTrack(this));
  }
  get isMuted() {
    return this.metadataMuted;
  }
  get isEnabled() {
    return !0;
  }
  get isSubscribed() {
    return this.track !== void 0;
  }
  get isEncrypted() {
    return this.encryption !== Encryption_Type.NONE;
  }
  /**
   * an [AudioTrack] if this publication holds an audio track
   */
  get audioTrack() {
    if (this.track instanceof LocalAudioTrack || this.track instanceof RemoteAudioTrack)
      return this.track;
  }
  /**
   * an [VideoTrack] if this publication holds a video track
   */
  get videoTrack() {
    if (this.track instanceof LocalVideoTrack || this.track instanceof RemoteVideoTrack)
      return this.track;
  }
  /** @internal */
  updateInfo(u) {
    this.trackSid = u.sid, this.trackName = u.name, this.source = Track.sourceFromProto(u.source), this.mimeType = u.mimeType, this.kind === Track.Kind.Video && u.width > 0 && (this.dimensions = {
      width: u.width,
      height: u.height
    }, this.simulcasted = u.simulcast), this.encryption = u.encryption, this.trackInfo = u, this.log.debug("update publication info", Object.assign(Object.assign({}, this.logContext), {
      info: u
    }));
  }
}
(function(a) {
  (function(u) {
    u.Desired = "desired", u.Subscribed = "subscribed", u.Unsubscribed = "unsubscribed";
  })(a.SubscriptionStatus || (a.SubscriptionStatus = {})), function(u) {
    u.Allowed = "allowed", u.NotAllowed = "not_allowed";
  }(a.PermissionStatus || (a.PermissionStatus = {}));
})(TrackPublication || (TrackPublication = {}));
class LocalTrackPublication extends TrackPublication {
  get isUpstreamPaused() {
    var u;
    return (u = this.track) === null || u === void 0 ? void 0 : u.isUpstreamPaused;
  }
  constructor(u, c, l, v) {
    super(u, c.sid, c.name, v), this.track = void 0, this.handleTrackEnded = () => {
      this.emit(TrackEvent.Ended);
    }, this.updateInfo(c), this.setTrack(l);
  }
  setTrack(u) {
    this.track && this.track.off(TrackEvent.Ended, this.handleTrackEnded), super.setTrack(u), u && u.on(TrackEvent.Ended, this.handleTrackEnded);
  }
  get isMuted() {
    return this.track ? this.track.isMuted : super.isMuted;
  }
  get audioTrack() {
    return super.audioTrack;
  }
  get videoTrack() {
    return super.videoTrack;
  }
  /**
   * Mute the track associated with this publication
   */
  mute() {
    var u;
    return __awaiter$3(this, void 0, void 0, function* () {
      return (u = this.track) === null || u === void 0 ? void 0 : u.mute();
    });
  }
  /**
   * Unmute track associated with this publication
   */
  unmute() {
    var u;
    return __awaiter$3(this, void 0, void 0, function* () {
      return (u = this.track) === null || u === void 0 ? void 0 : u.unmute();
    });
  }
  /**
   * Pauses the media stream track associated with this publication from being sent to the server
   * and signals "muted" event to other participants
   * Useful if you want to pause the stream without pausing the local media stream track
   */
  pauseUpstream() {
    var u;
    return __awaiter$3(this, void 0, void 0, function* () {
      yield (u = this.track) === null || u === void 0 ? void 0 : u.pauseUpstream();
    });
  }
  /**
   * Resumes sending the media stream track associated with this publication to the server after a call to [[pauseUpstream()]]
   * and signals "unmuted" event to other participants (unless the track is explicitly muted)
   */
  resumeUpstream() {
    var u;
    return __awaiter$3(this, void 0, void 0, function* () {
      yield (u = this.track) === null || u === void 0 ? void 0 : u.resumeUpstream();
    });
  }
}
var ConnectionQuality;
(function(a) {
  a.Excellent = "excellent", a.Good = "good", a.Poor = "poor", a.Lost = "lost", a.Unknown = "unknown";
})(ConnectionQuality || (ConnectionQuality = {}));
function qualityFromProto(a) {
  switch (a) {
    case ConnectionQuality$1.EXCELLENT:
      return ConnectionQuality.Excellent;
    case ConnectionQuality$1.GOOD:
      return ConnectionQuality.Good;
    case ConnectionQuality$1.POOR:
      return ConnectionQuality.Poor;
    case ConnectionQuality$1.LOST:
      return ConnectionQuality.Lost;
    default:
      return ConnectionQuality.Unknown;
  }
}
class Participant extends eventsExports$1.EventEmitter {
  get logContext() {
    var u, c;
    return Object.assign({}, (c = (u = this.loggerOptions) === null || u === void 0 ? void 0 : u.loggerContextCb) === null || c === void 0 ? void 0 : c.call(u));
  }
  get isEncrypted() {
    return this.trackPublications.size > 0 && Array.from(this.trackPublications.values()).every((u) => u.isEncrypted);
  }
  get isAgent() {
    var u, c;
    return (c = (u = this.permissions) === null || u === void 0 ? void 0 : u.agent) !== null && c !== void 0 ? c : !1;
  }
  /** @internal */
  constructor(u, c, l, v, p) {
    var _;
    super(), this.audioLevel = 0, this.isSpeaking = !1, this._connectionQuality = ConnectionQuality.Unknown, this.log = livekitLogger, this.log = getLogger((_ = p == null ? void 0 : p.loggerName) !== null && _ !== void 0 ? _ : LoggerNames.Participant), this.loggerOptions = p, this.setMaxListeners(100), this.sid = u, this.identity = c, this.name = l, this.metadata = v, this.audioTrackPublications = /* @__PURE__ */ new Map(), this.videoTrackPublications = /* @__PURE__ */ new Map(), this.trackPublications = /* @__PURE__ */ new Map();
  }
  getTrackPublications() {
    return Array.from(this.trackPublications.values());
  }
  /**
   * Finds the first track that matches the source filter, for example, getting
   * the user's camera track with getTrackBySource(Track.Source.Camera).
   */
  getTrackPublication(u) {
    for (const [, c] of this.trackPublications)
      if (c.source === u)
        return c;
  }
  /**
   * Finds the first track that matches the track's name.
   */
  getTrackPublicationByName(u) {
    for (const [, c] of this.trackPublications)
      if (c.trackName === u)
        return c;
  }
  get connectionQuality() {
    return this._connectionQuality;
  }
  get isCameraEnabled() {
    var u;
    const c = this.getTrackPublication(Track.Source.Camera);
    return !(!((u = c == null ? void 0 : c.isMuted) !== null && u !== void 0) || u);
  }
  get isMicrophoneEnabled() {
    var u;
    const c = this.getTrackPublication(Track.Source.Microphone);
    return !(!((u = c == null ? void 0 : c.isMuted) !== null && u !== void 0) || u);
  }
  get isScreenShareEnabled() {
    return !!this.getTrackPublication(Track.Source.ScreenShare);
  }
  get isLocal() {
    return !1;
  }
  /** when participant joined the room */
  get joinedAt() {
    return this.participantInfo ? new Date(Number.parseInt(this.participantInfo.joinedAt.toString()) * 1e3) : /* @__PURE__ */ new Date();
  }
  /** @internal */
  updateInfo(u) {
    return this.participantInfo && this.participantInfo.sid === u.sid && this.participantInfo.version > u.version ? !1 : (this.identity = u.identity, this.sid = u.sid, this._setName(u.name), this._setMetadata(u.metadata), u.permission && this.setPermissions(u.permission), this.participantInfo = u, this.log.trace("update participant info", Object.assign(Object.assign({}, this.logContext), {
      info: u
    })), !0);
  }
  /**
   * Updates metadata from server
   **/
  _setMetadata(u) {
    const c = this.metadata !== u, l = this.metadata;
    this.metadata = u, c && this.emit(ParticipantEvent.ParticipantMetadataChanged, l);
  }
  _setName(u) {
    const c = this.name !== u;
    this.name = u, c && this.emit(ParticipantEvent.ParticipantNameChanged, u);
  }
  /** @internal */
  setPermissions(u) {
    var c, l, v, p, _;
    const k = this.permissions, M = u.canPublish !== ((c = this.permissions) === null || c === void 0 ? void 0 : c.canPublish) || u.canSubscribe !== ((l = this.permissions) === null || l === void 0 ? void 0 : l.canSubscribe) || u.canPublishData !== ((v = this.permissions) === null || v === void 0 ? void 0 : v.canPublishData) || u.hidden !== ((p = this.permissions) === null || p === void 0 ? void 0 : p.hidden) || u.recorder !== ((_ = this.permissions) === null || _ === void 0 ? void 0 : _.recorder) || u.canPublishSources.length !== this.permissions.canPublishSources.length || u.canPublishSources.some((L, F) => {
      var V;
      return L !== ((V = this.permissions) === null || V === void 0 ? void 0 : V.canPublishSources[F]);
    });
    return this.permissions = u, M && this.emit(ParticipantEvent.ParticipantPermissionsChanged, k), M;
  }
  /** @internal */
  setIsSpeaking(u) {
    u !== this.isSpeaking && (this.isSpeaking = u, u && (this.lastSpokeAt = /* @__PURE__ */ new Date()), this.emit(ParticipantEvent.IsSpeakingChanged, u));
  }
  /** @internal */
  setConnectionQuality(u) {
    const c = this._connectionQuality;
    this._connectionQuality = qualityFromProto(u), c !== this._connectionQuality && this.emit(ParticipantEvent.ConnectionQualityChanged, this._connectionQuality);
  }
  /**
   * @internal
   */
  setAudioContext(u) {
    this.audioContext = u, this.audioTrackPublications.forEach((c) => (c.track instanceof RemoteAudioTrack || c.track instanceof LocalAudioTrack) && c.track.setAudioContext(u));
  }
  addTrackPublication(u) {
    u.on(TrackEvent.Muted, () => {
      this.emit(ParticipantEvent.TrackMuted, u);
    }), u.on(TrackEvent.Unmuted, () => {
      this.emit(ParticipantEvent.TrackUnmuted, u);
    });
    const c = u;
    switch (c.track && (c.track.sid = u.trackSid), this.trackPublications.set(u.trackSid, u), u.kind) {
      case Track.Kind.Audio:
        this.audioTrackPublications.set(u.trackSid, u);
        break;
      case Track.Kind.Video:
        this.videoTrackPublications.set(u.trackSid, u);
        break;
    }
  }
}
function trackPermissionToProto(a) {
  var u, c, l;
  if (!a.participantSid && !a.participantIdentity)
    throw new Error("Invalid track permission, must provide at least one of participantIdentity and participantSid");
  return new TrackPermission({
    participantIdentity: (u = a.participantIdentity) !== null && u !== void 0 ? u : "",
    participantSid: (c = a.participantSid) !== null && c !== void 0 ? c : "",
    allTracks: (l = a.allowAll) !== null && l !== void 0 ? l : !1,
    trackSids: a.allowedTrackSids || []
  });
}
class LocalParticipant extends Participant {
  /** @internal */
  constructor(u, c, l, v) {
    super(u, c, void 0, void 0, {
      loggerName: v.loggerName,
      loggerContextCb: () => this.engine.logContext
    }), this.pendingPublishing = /* @__PURE__ */ new Set(), this.pendingPublishPromises = /* @__PURE__ */ new Map(), this.participantTrackPermissions = [], this.allParticipantsAllowedToSubscribe = !0, this.encryptionType = Encryption_Type.NONE, this.handleReconnecting = () => {
      this.reconnectFuture || (this.reconnectFuture = new Future());
    }, this.handleReconnected = () => {
      var p, _;
      (_ = (p = this.reconnectFuture) === null || p === void 0 ? void 0 : p.resolve) === null || _ === void 0 || _.call(p), this.reconnectFuture = void 0, this.updateTrackSubscriptionPermissions();
    }, this.handleDisconnected = () => {
      var p, _;
      this.reconnectFuture && (this.reconnectFuture.promise.catch((k) => this.log.warn(k.message, this.logContext)), (_ = (p = this.reconnectFuture) === null || p === void 0 ? void 0 : p.reject) === null || _ === void 0 || _.call(p, "Got disconnected during reconnection attempt"), this.reconnectFuture = void 0);
    }, this.updateTrackSubscriptionPermissions = () => {
      this.log.debug("updating track subscription permissions", Object.assign(Object.assign({}, this.logContext), {
        allParticipantsAllowed: this.allParticipantsAllowedToSubscribe,
        participantTrackPermissions: this.participantTrackPermissions
      })), this.engine.client.sendUpdateSubscriptionPermissions(this.allParticipantsAllowedToSubscribe, this.participantTrackPermissions.map((p) => trackPermissionToProto(p)));
    }, this.onTrackUnmuted = (p) => {
      this.onTrackMuted(p, p.isUpstreamPaused);
    }, this.onTrackMuted = (p, _) => {
      if (_ === void 0 && (_ = !0), !p.sid) {
        this.log.error("could not update mute status for unpublished track", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(p)));
        return;
      }
      this.engine.updateMuteStatus(p.sid, _);
    }, this.onTrackUpstreamPaused = (p) => {
      this.log.debug("upstream paused", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(p))), this.onTrackMuted(p, !0);
    }, this.onTrackUpstreamResumed = (p) => {
      this.log.debug("upstream resumed", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(p))), this.onTrackMuted(p, p.isMuted);
    }, this.handleSubscribedQualityUpdate = (p) => __awaiter$3(this, void 0, void 0, function* () {
      var _, k, M, L, F, V;
      if (!(!((F = this.roomOptions) === null || F === void 0) && F.dynacast))
        return;
      const X = this.videoTrackPublications.get(p.trackSid);
      if (!X) {
        this.log.warn("received subscribed quality update for unknown track", Object.assign(Object.assign({}, this.logContext), {
          trackSid: p.trackSid
        }));
        return;
      }
      if (p.subscribedCodecs.length > 0) {
        if (!X.videoTrack)
          return;
        const ne = yield X.videoTrack.setPublishingCodecs(p.subscribedCodecs);
        try {
          for (var oe = !0, Y = __asyncValues(ne), ae; ae = yield Y.next(), _ = ae.done, !_; oe = !0) {
            L = ae.value, oe = !1;
            const fe = L;
            isBackupCodec(fe) && (this.log.debug("publish ".concat(fe, " for ").concat(X.videoTrack.sid), Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(X))), yield this.publishAdditionalCodecForTrack(X.videoTrack, fe, X.options));
          }
        } catch (fe) {
          k = {
            error: fe
          };
        } finally {
          try {
            !oe && !_ && (M = Y.return) && (yield M.call(Y));
          } finally {
            if (k)
              throw k.error;
          }
        }
      } else
        p.subscribedQualities.length > 0 && (yield (V = X.videoTrack) === null || V === void 0 ? void 0 : V.setPublishingLayers(p.subscribedQualities));
    }), this.handleLocalTrackUnpublished = (p) => {
      const _ = this.trackPublications.get(p.trackSid);
      if (!_) {
        this.log.warn("received unpublished event for unknown track", Object.assign(Object.assign({}, this.logContext), {
          trackSid: p.trackSid
        }));
        return;
      }
      this.unpublishTrack(_.track);
    }, this.handleTrackEnded = (p) => __awaiter$3(this, void 0, void 0, function* () {
      if (p.source === Track.Source.ScreenShare || p.source === Track.Source.ScreenShareAudio)
        this.log.debug("unpublishing local track due to TrackEnded", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(p))), this.unpublishTrack(p);
      else if (p.isUserProvided)
        yield p.mute();
      else if (p instanceof LocalAudioTrack || p instanceof LocalVideoTrack)
        try {
          if (isWeb())
            try {
              const _ = yield navigator == null ? void 0 : navigator.permissions.query({
                // the permission query for camera and microphone currently not supported in Safari and Firefox
                // @ts-ignore
                name: p.source === Track.Source.Camera ? "camera" : "microphone"
              });
              if (_ && _.state === "denied")
                throw this.log.warn("user has revoked access to ".concat(p.source), Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(p))), _.onchange = () => {
                  _.state !== "denied" && (p.isMuted || p.restartTrack(), _.onchange = null);
                }, new Error("GetUserMedia Permission denied");
            } catch {
            }
          p.isMuted || (this.log.debug("track ended, attempting to use a different device", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(p))), yield p.restartTrack());
        } catch {
          this.log.warn("could not restart track, muting instead", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(p))), yield p.mute();
        }
    }), this.audioTrackPublications = /* @__PURE__ */ new Map(), this.videoTrackPublications = /* @__PURE__ */ new Map(), this.trackPublications = /* @__PURE__ */ new Map(), this.engine = l, this.roomOptions = v, this.setupEngine(l), this.activeDeviceMap = /* @__PURE__ */ new Map();
  }
  get lastCameraError() {
    return this.cameraError;
  }
  get lastMicrophoneError() {
    return this.microphoneError;
  }
  get isE2EEEnabled() {
    return this.encryptionType !== Encryption_Type.NONE;
  }
  getTrackPublication(u) {
    const c = super.getTrackPublication(u);
    if (c)
      return c;
  }
  getTrackPublicationByName(u) {
    const c = super.getTrackPublicationByName(u);
    if (c)
      return c;
  }
  /**
   * @internal
   */
  setupEngine(u) {
    this.engine = u, this.engine.on(EngineEvent.RemoteMute, (c, l) => {
      const v = this.trackPublications.get(c);
      !v || !v.track || (l ? v.mute() : v.unmute());
    }), this.engine.on(EngineEvent.Connected, this.handleReconnected).on(EngineEvent.SignalRestarted, this.handleReconnected).on(EngineEvent.SignalResumed, this.handleReconnected).on(EngineEvent.Restarting, this.handleReconnecting).on(EngineEvent.Resuming, this.handleReconnecting).on(EngineEvent.LocalTrackUnpublished, this.handleLocalTrackUnpublished).on(EngineEvent.SubscribedQualityUpdate, this.handleSubscribedQualityUpdate).on(EngineEvent.Disconnected, this.handleDisconnected);
  }
  /**
   * Sets and updates the metadata of the local participant.
   * The change does not take immediate effect.
   * If successful, a `ParticipantEvent.MetadataChanged` event will be emitted on the local participant.
   * Note: this requires `canUpdateOwnMetadata` permission.
   * @param metadata
   */
  setMetadata(u) {
    var c;
    this.engine.client.sendUpdateLocalMetadata(u, (c = this.name) !== null && c !== void 0 ? c : "");
  }
  /**
   * Sets and updates the name of the local participant.
   * The change does not take immediate effect.
   * If successful, a `ParticipantEvent.ParticipantNameChanged` event will be emitted on the local participant.
   * Note: this requires `canUpdateOwnMetadata` permission.
   * @param metadata
   */
  setName(u) {
    var c;
    this.engine.client.sendUpdateLocalMetadata((c = this.metadata) !== null && c !== void 0 ? c : "", u);
  }
  /**
   * Enable or disable a participant's camera track.
   *
   * If a track has already published, it'll mute or unmute the track.
   * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise
   */
  setCameraEnabled(u, c, l) {
    return this.setTrackEnabled(Track.Source.Camera, u, c, l);
  }
  /**
   * Enable or disable a participant's microphone track.
   *
   * If a track has already published, it'll mute or unmute the track.
   * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise
   */
  setMicrophoneEnabled(u, c, l) {
    return this.setTrackEnabled(Track.Source.Microphone, u, c, l);
  }
  /**
   * Start or stop sharing a participant's screen
   * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise
   */
  setScreenShareEnabled(u, c, l) {
    return this.setTrackEnabled(Track.Source.ScreenShare, u, c, l);
  }
  /** @internal */
  setPermissions(u) {
    const c = this.permissions, l = super.setPermissions(u);
    return l && c && this.emit(ParticipantEvent.ParticipantPermissionsChanged, c), l;
  }
  /** @internal */
  setE2EEEnabled(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      this.encryptionType = u ? Encryption_Type.GCM : Encryption_Type.NONE, yield this.republishAllTracks(void 0, !1);
    });
  }
  setTrackEnabled(u, c, l, v) {
    var p, _;
    return __awaiter$3(this, void 0, void 0, function* () {
      this.log.debug("setTrackEnabled", Object.assign(Object.assign({}, this.logContext), {
        source: u,
        enabled: c
      }));
      let k = this.getTrackPublication(u);
      if (c)
        if (k)
          yield k.unmute();
        else {
          let M;
          if (this.pendingPublishing.has(u)) {
            this.log.info("skipping duplicate published source", Object.assign(Object.assign({}, this.logContext), {
              source: u
            }));
            return;
          }
          this.pendingPublishing.add(u);
          try {
            switch (u) {
              case Track.Source.Camera:
                M = yield this.createTracks({
                  video: (p = l) !== null && p !== void 0 ? p : !0
                });
                break;
              case Track.Source.Microphone:
                M = yield this.createTracks({
                  audio: (_ = l) !== null && _ !== void 0 ? _ : !0
                });
                break;
              case Track.Source.ScreenShare:
                M = yield this.createScreenTracks(Object.assign({}, l));
                break;
              default:
                throw new TrackInvalidError(u);
            }
            const L = [];
            for (const V of M)
              this.log.info("publishing track", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(V))), L.push(this.publishTrack(V, v));
            [k] = yield Promise.all(L);
          } catch (L) {
            throw M == null || M.forEach((F) => {
              F.stop();
            }), L instanceof Error && !(L instanceof TrackInvalidError) && this.emit(ParticipantEvent.MediaDevicesError, L), L;
          } finally {
            this.pendingPublishing.delete(u);
          }
        }
      else if (k && k.track)
        if (u === Track.Source.ScreenShare) {
          k = yield this.unpublishTrack(k.track);
          const M = this.getTrackPublication(Track.Source.ScreenShareAudio);
          M && M.track && this.unpublishTrack(M.track);
        } else
          yield k.mute();
      return k;
    });
  }
  /**
   * Publish both camera and microphone at the same time. This is useful for
   * displaying a single Permission Dialog box to the end user.
   */
  enableCameraAndMicrophone() {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!(this.pendingPublishing.has(Track.Source.Camera) || this.pendingPublishing.has(Track.Source.Microphone))) {
        this.pendingPublishing.add(Track.Source.Camera), this.pendingPublishing.add(Track.Source.Microphone);
        try {
          const u = yield this.createTracks({
            audio: !0,
            video: !0
          });
          yield Promise.all(u.map((c) => this.publishTrack(c)));
        } finally {
          this.pendingPublishing.delete(Track.Source.Camera), this.pendingPublishing.delete(Track.Source.Microphone);
        }
      }
    });
  }
  /**
   * Create local camera and/or microphone tracks
   * @param options
   * @returns
   */
  createTracks(u) {
    var c, l;
    return __awaiter$3(this, void 0, void 0, function* () {
      const v = mergeDefaultOptions(u, (c = this.roomOptions) === null || c === void 0 ? void 0 : c.audioCaptureDefaults, (l = this.roomOptions) === null || l === void 0 ? void 0 : l.videoCaptureDefaults), p = constraintsForOptions(v);
      let _;
      try {
        _ = yield navigator.mediaDevices.getUserMedia(p);
      } catch (k) {
        throw k instanceof Error && (p.audio && (this.microphoneError = k), p.video && (this.cameraError = k)), k;
      }
      return p.audio && (this.microphoneError = void 0, this.emit(ParticipantEvent.AudioStreamAcquired)), p.video && (this.cameraError = void 0), _.getTracks().map((k) => {
        const M = k.kind === "audio";
        M ? u.audio : u.video;
        let L;
        const F = M ? p.audio : p.video;
        typeof F != "boolean" && (L = F);
        const V = mediaTrackToLocalTrack(k, L, {
          loggerName: this.roomOptions.loggerName,
          loggerContextCb: () => this.logContext
        });
        return V.kind === Track.Kind.Video ? V.source = Track.Source.Camera : V.kind === Track.Kind.Audio && (V.source = Track.Source.Microphone), V.mediaStream = _, V;
      });
    });
  }
  /**
   * Creates a screen capture tracks with getDisplayMedia().
   * A LocalVideoTrack is always created and returned.
   * If { audio: true }, and the browser supports audio capture, a LocalAudioTrack is also created.
   */
  createScreenTracks(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (u === void 0 && (u = {}), navigator.mediaDevices.getDisplayMedia === void 0)
        throw new DeviceUnsupportedError("getDisplayMedia not supported");
      u.resolution === void 0 && !isSafari17() && (u.resolution = ScreenSharePresets.h1080fps30.resolution);
      const c = screenCaptureToDisplayMediaStreamOptions(u), l = yield navigator.mediaDevices.getDisplayMedia(c), v = l.getVideoTracks();
      if (v.length === 0)
        throw new TrackInvalidError("no video track found");
      const p = new LocalVideoTrack(v[0], void 0, !1, {
        loggerName: this.roomOptions.loggerName,
        loggerContextCb: () => this.logContext
      });
      p.source = Track.Source.ScreenShare, u.contentHint && (p.mediaStreamTrack.contentHint = u.contentHint);
      const _ = [p];
      if (l.getAudioTracks().length > 0) {
        this.emit(ParticipantEvent.AudioStreamAcquired);
        const k = new LocalAudioTrack(l.getAudioTracks()[0], void 0, !1, this.audioContext, {
          loggerName: this.roomOptions.loggerName,
          loggerContextCb: () => this.logContext
        });
        k.source = Track.Source.ScreenShareAudio, _.push(k);
      }
      return _;
    });
  }
  /**
   * Publish a new track to the room
   * @param track
   * @param options
   */
  publishTrack(u, c) {
    var l, v, p, _;
    return __awaiter$3(this, void 0, void 0, function* () {
      u instanceof LocalAudioTrack && u.setAudioContext(this.audioContext), yield (l = this.reconnectFuture) === null || l === void 0 ? void 0 : l.promise, u instanceof LocalTrack && this.pendingPublishPromises.has(u) && (yield this.pendingPublishPromises.get(u));
      let k;
      if (u instanceof MediaStreamTrack)
        k = u.getConstraints();
      else {
        k = u.constraints;
        let oe;
        switch (u.source) {
          case Track.Source.Microphone:
            oe = "audioinput";
            break;
          case Track.Source.Camera:
            oe = "videoinput";
        }
        oe && this.activeDeviceMap.has(oe) && (k = Object.assign(Object.assign({}, k), {
          deviceId: this.activeDeviceMap.get(oe)
        }));
      }
      if (u instanceof MediaStreamTrack)
        switch (u.kind) {
          case "audio":
            u = new LocalAudioTrack(u, k, !0, this.audioContext, {
              loggerName: this.roomOptions.loggerName,
              loggerContextCb: () => this.logContext
            });
            break;
          case "video":
            u = new LocalVideoTrack(u, k, !0, {
              loggerName: this.roomOptions.loggerName,
              loggerContextCb: () => this.logContext
            });
            break;
          default:
            throw new TrackInvalidError("unsupported MediaStreamTrack kind ".concat(u.kind));
        }
      else
        u.updateLoggerOptions({
          loggerName: this.roomOptions.loggerName,
          loggerContextCb: () => this.logContext
        });
      let M;
      if (this.trackPublications.forEach((oe) => {
        oe.track && oe.track === u && (M = oe);
      }), M)
        return this.log.warn("track has already been published, skipping", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(M))), M;
      const L = "channelCount" in u.mediaStreamTrack.getSettings() && // @ts-ignore `channelCount` on getSettings() is currently only available for Safari, but is generally the best way to determine a stereo track https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackSettings/channelCount
      u.mediaStreamTrack.getSettings().channelCount === 2 || u.mediaStreamTrack.getConstraints().channelCount === 2, F = (v = c == null ? void 0 : c.forceStereo) !== null && v !== void 0 ? v : L;
      F && (c || (c = {}), c.dtx === void 0 && this.log.info("Opus DTX will be disabled for stereo tracks by default. Enable them explicitly to make it work.", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(u))), c.red === void 0 && this.log.info("Opus RED will be disabled for stereo tracks by default. Enable them explicitly to make it work."), (p = c.dtx) !== null && p !== void 0 || (c.dtx = !1), (_ = c.red) !== null && _ !== void 0 || (c.red = !1));
      const V = Object.assign(Object.assign({}, this.roomOptions.publishDefaults), c);
      isSafari() && this.roomOptions.e2ee && (this.log.info("End-to-end encryption is set up, simulcast publishing will be disabled on Safari", Object.assign({}, this.logContext)), V.simulcast = !1), V.source && (u.source = V.source);
      const X = this.publish(u, V, F);
      this.pendingPublishPromises.set(u, X);
      try {
        return yield X;
      } catch (oe) {
        throw oe;
      } finally {
        this.pendingPublishPromises.delete(u);
      }
    });
  }
  publish(u, c, l) {
    var v, p, _, k, M, L, F, V, X, oe, Y, ae;
    return __awaiter$3(this, void 0, void 0, function* () {
      Array.from(this.trackPublications.values()).find((Be) => u instanceof LocalTrack && Be.source === u.source) && u.source !== Track.Source.Unknown && this.log.info("publishing a second track with the same source: ".concat(u.source), Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(u))), c.stopMicTrackOnMute && u instanceof LocalAudioTrack && (u.stopOnMute = !0), u.source === Track.Source.ScreenShare && isFireFox() && (c.simulcast = !1), c.videoCodec === "av1" && !supportsAV1() && (c.videoCodec = void 0), c.videoCodec === "vp9" && !supportsVP9() && (c.videoCodec = void 0), c.videoCodec === void 0 && (c.videoCodec = defaultVideoCodec);
      const fe = c.videoCodec;
      u.on(TrackEvent.Muted, this.onTrackMuted), u.on(TrackEvent.Unmuted, this.onTrackUnmuted), u.on(TrackEvent.Ended, this.handleTrackEnded), u.on(TrackEvent.UpstreamPaused, this.onTrackUpstreamPaused), u.on(TrackEvent.UpstreamResumed, this.onTrackUpstreamResumed);
      const ie = new AddTrackRequest({
        // get local track id for use during publishing
        cid: u.mediaStreamTrack.id,
        name: c.name,
        type: Track.kindToProto(u.kind),
        muted: u.isMuted,
        source: Track.sourceToProto(u.source),
        disableDtx: !(!((v = c.dtx) !== null && v !== void 0) || v),
        encryption: this.encryptionType,
        stereo: l,
        disableRed: this.isE2EEEnabled || !(!((p = c.red) !== null && p !== void 0) || p),
        stream: c == null ? void 0 : c.stream
      });
      let ge;
      if (u.kind === Track.Kind.Video) {
        let Be = {
          width: 0,
          height: 0
        };
        try {
          Be = yield u.waitForDimensions();
        } catch {
          const Z = (k = (_ = this.roomOptions.videoCaptureDefaults) === null || _ === void 0 ? void 0 : _.resolution) !== null && k !== void 0 ? k : VideoPresets.h720.resolution;
          Be = {
            width: Z.width,
            height: Z.height
          }, this.log.error("could not determine track dimensions, using defaults", Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(u)), {
            dims: Be
          }));
        }
        ie.width = Be.width, ie.height = Be.height, u instanceof LocalVideoTrack && (isSVCCodec(fe) && (u.source === Track.Source.ScreenShare && (c.scalabilityMode = "L1T3", "contentHint" in u.mediaStreamTrack && (u.mediaStreamTrack.contentHint = "motion", this.log.info("forcing contentHint to motion for screenshare with SVC codecs", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(u))))), c.scalabilityMode = (M = c.scalabilityMode) !== null && M !== void 0 ? M : "L3T3_KEY"), ie.simulcastCodecs = [new SimulcastCodec({
          codec: fe,
          cid: u.mediaStreamTrack.id
        })], c.backupCodec === !0 && (c.backupCodec = {
          codec: defaultVideoCodec
        }), c.backupCodec && fe !== c.backupCodec.codec && // TODO remove this once e2ee is supported for backup codecs
        ie.encryption === Encryption_Type.NONE && (this.roomOptions.dynacast || (this.roomOptions.dynacast = !0), ie.simulcastCodecs.push(new SimulcastCodec({
          codec: c.backupCodec.codec,
          cid: ""
        })))), ge = computeVideoEncodings(u.source === Track.Source.ScreenShare, ie.width, ie.height, c), ie.layers = videoLayersFromEncodings(ie.width, ie.height, ge, isSVCCodec(c.videoCodec));
      } else
        u.kind === Track.Kind.Audio && (ge = [{
          maxBitrate: (L = c.audioPreset) === null || L === void 0 ? void 0 : L.maxBitrate,
          priority: (V = (F = c.audioPreset) === null || F === void 0 ? void 0 : F.priority) !== null && V !== void 0 ? V : "high",
          networkPriority: (oe = (X = c.audioPreset) === null || X === void 0 ? void 0 : X.priority) !== null && oe !== void 0 ? oe : "high"
        }]);
      if (!this.engine || this.engine.isClosed)
        throw new UnexpectedConnectionState("cannot publish track when not connected");
      const be = yield this.engine.addTrack(ie);
      let Ce;
      if (be.codecs.forEach((Be) => {
        Ce === void 0 && (Ce = Be.mimeType);
      }), Ce && u.kind === Track.Kind.Video) {
        const Be = mimeTypeToVideoCodecString(Ce);
        Be !== fe && (this.log.debug("falling back to server selected codec", Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(u)), {
          codec: Be
        })), c.videoCodec = Be, ge = computeVideoEncodings(u.source === Track.Source.ScreenShare, ie.width, ie.height, c));
      }
      const Me = new LocalTrackPublication(u.kind, be, u, {
        loggerName: this.roomOptions.loggerName,
        loggerContextCb: () => this.logContext
      });
      if (Me.options = c, u.sid = be.sid, !this.engine.pcManager)
        throw new UnexpectedConnectionState("pcManager is not ready");
      if (this.log.debug("publishing ".concat(u.kind, " with encodings"), Object.assign(Object.assign({}, this.logContext), {
        encodings: ge,
        trackInfo: be
      })), u.sender = yield this.engine.createSender(u, c, ge), ge)
        if (isFireFox() && u.kind === Track.Kind.Audio) {
          let Be;
          for (const Ae of this.engine.pcManager.publisher.getTransceivers())
            if (Ae.sender === u.sender) {
              Be = Ae;
              break;
            }
          Be && this.engine.pcManager.publisher.setTrackCodecBitrate({
            transceiver: Be,
            codec: "opus",
            maxbr: !((Y = ge[0]) === null || Y === void 0) && Y.maxBitrate ? ge[0].maxBitrate / 1e3 : 0
          });
        } else
          u.codec && u.codec == "av1" && (!((ae = ge[0]) === null || ae === void 0) && ae.maxBitrate) && this.engine.pcManager.publisher.setTrackCodecBitrate({
            cid: ie.cid,
            codec: u.codec,
            maxbr: ge[0].maxBitrate / 1e3
          });
      if (u.kind === Track.Kind.Video && u.source === Track.Source.ScreenShare)
        try {
          this.log.debug("setting degradationPreference to maintain-resolution");
          const Be = u.sender.getParameters();
          Be.degradationPreference = "maintain-resolution", yield u.sender.setParameters(Be);
        } catch (Be) {
          this.log.warn("failed to set degradationPreference: ".concat(Be));
        }
      return yield this.engine.negotiate(), u instanceof LocalVideoTrack ? u.startMonitor(this.engine.client) : u instanceof LocalAudioTrack && u.startMonitor(), this.addTrackPublication(Me), this.emit(ParticipantEvent.LocalTrackPublished, Me), Me;
    });
  }
  get isLocal() {
    return !0;
  }
  /** @internal
   * publish additional codec to existing track
   */
  publishAdditionalCodecForTrack(u, c, l) {
    var v;
    return __awaiter$3(this, void 0, void 0, function* () {
      if (this.encryptionType !== Encryption_Type.NONE)
        return;
      let p;
      if (this.trackPublications.forEach((V) => {
        V.track && V.track === u && (p = V);
      }), !p)
        throw new TrackInvalidError("track is not published");
      if (!(u instanceof LocalVideoTrack))
        throw new TrackInvalidError("track is not a video track");
      const _ = Object.assign(Object.assign({}, (v = this.roomOptions) === null || v === void 0 ? void 0 : v.publishDefaults), l), k = computeTrackBackupEncodings(u, c, _);
      if (!k) {
        this.log.info("backup codec has been disabled, ignoring request to add additional codec for track", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(u)));
        return;
      }
      const M = u.addSimulcastTrack(c, k);
      if (!M)
        return;
      const L = new AddTrackRequest({
        cid: M.mediaStreamTrack.id,
        type: Track.kindToProto(u.kind),
        muted: u.isMuted,
        source: Track.sourceToProto(u.source),
        sid: u.sid,
        simulcastCodecs: [{
          codec: _.videoCodec,
          cid: M.mediaStreamTrack.id
        }]
      });
      if (L.layers = videoLayersFromEncodings(L.width, L.height, k), !this.engine || this.engine.isClosed)
        throw new UnexpectedConnectionState("cannot publish track when not connected");
      const F = yield this.engine.addTrack(L);
      yield this.engine.createSimulcastSender(u, M, _, k), yield this.engine.negotiate(), this.log.debug("published ".concat(c, " for track ").concat(u.sid), Object.assign(Object.assign({}, this.logContext), {
        encodings: k,
        trackInfo: F
      }));
    });
  }
  unpublishTrack(u, c) {
    var l, v;
    return __awaiter$3(this, void 0, void 0, function* () {
      const p = this.getPublicationForTrack(u), _ = p ? getLogContextFromTrack(p) : void 0;
      if (this.log.debug("unpublishing track", Object.assign(Object.assign({}, this.logContext), _)), !p || !p.track) {
        this.log.warn("track was not unpublished because no publication was found", Object.assign(Object.assign({}, this.logContext), _));
        return;
      }
      u = p.track, u.off(TrackEvent.Muted, this.onTrackMuted), u.off(TrackEvent.Unmuted, this.onTrackUnmuted), u.off(TrackEvent.Ended, this.handleTrackEnded), u.off(TrackEvent.UpstreamPaused, this.onTrackUpstreamPaused), u.off(TrackEvent.UpstreamResumed, this.onTrackUpstreamResumed), c === void 0 && (c = (v = (l = this.roomOptions) === null || l === void 0 ? void 0 : l.stopLocalTrackOnUnpublish) !== null && v !== void 0 ? v : !0), c && u.stop();
      let k = !1;
      const M = u.sender;
      if (u.sender = void 0, this.engine.pcManager && this.engine.pcManager.currentState < PCTransportState.FAILED && M)
        try {
          for (const L of this.engine.pcManager.publisher.getTransceivers())
            L.sender === M && (L.direction = "inactive", k = !0);
          if (this.engine.removeTrack(M) && (k = !0), u instanceof LocalVideoTrack) {
            for (const [, L] of u.simulcastCodecs)
              L.sender && (this.engine.removeTrack(L.sender) && (k = !0), L.sender = void 0);
            u.simulcastCodecs.clear();
          }
        } catch (L) {
          this.log.warn("failed to unpublish track", Object.assign(Object.assign(Object.assign({}, this.logContext), _), {
            error: L
          }));
        }
      switch (this.trackPublications.delete(p.trackSid), p.kind) {
        case Track.Kind.Audio:
          this.audioTrackPublications.delete(p.trackSid);
          break;
        case Track.Kind.Video:
          this.videoTrackPublications.delete(p.trackSid);
          break;
      }
      return this.emit(ParticipantEvent.LocalTrackUnpublished, p), p.setTrack(void 0), k && (yield this.engine.negotiate()), p;
    });
  }
  unpublishTracks(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      return (yield Promise.all(u.map((l) => this.unpublishTrack(l)))).filter((l) => l instanceof LocalTrackPublication);
    });
  }
  republishAllTracks(u) {
    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
    return __awaiter$3(this, void 0, void 0, function* () {
      const l = [];
      this.trackPublications.forEach((v) => {
        v.track && (u && (v.options = Object.assign(Object.assign({}, v.options), u)), l.push(v));
      }), yield Promise.all(l.map((v) => __awaiter$3(this, void 0, void 0, function* () {
        const p = v.track;
        yield this.unpublishTrack(p, !1), c && !p.isMuted && p.source !== Track.Source.ScreenShare && p.source !== Track.Source.ScreenShareAudio && (p instanceof LocalAudioTrack || p instanceof LocalVideoTrack) && !p.isUserProvided && (this.log.debug("restarting existing track", Object.assign(Object.assign({}, this.logContext), {
          track: v.trackSid
        })), yield p.restartTrack()), yield this.publishTrack(p, v.options);
      })));
    });
  }
  /**
   * Publish a new data payload to the room. Data will be forwarded to each
   * participant in the room if the destination field in publishOptions is empty
   *
   * @param data Uint8Array of the payload. To send string data, use TextEncoder.encode
   * @param options optionally specify a `reliable`, `topic` and `destination`
   */
  publishData(u) {
    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return __awaiter$3(this, void 0, void 0, function* () {
      const l = c.reliable ? DataPacket_Kind.RELIABLE : DataPacket_Kind.LOSSY, v = c.destinationIdentities, p = c.topic, _ = new DataPacket({
        kind: l,
        value: {
          case: "user",
          value: new UserPacket({
            participantIdentity: this.identity,
            payload: u,
            destinationIdentities: v,
            topic: p
          })
        }
      });
      yield this.engine.sendDataPacket(_, l);
    });
  }
  /**
   * Control who can subscribe to LocalParticipant's published tracks.
   *
   * By default, all participants can subscribe. This allows fine-grained control over
   * who is able to subscribe at a participant and track level.
   *
   * Note: if access is given at a track-level (i.e. both [allParticipantsAllowed] and
   * [ParticipantTrackPermission.allTracksAllowed] are false), any newer published tracks
   * will not grant permissions to any participants and will require a subsequent
   * permissions update to allow subscription.
   *
   * @param allParticipantsAllowed Allows all participants to subscribe all tracks.
   *  Takes precedence over [[participantTrackPermissions]] if set to true.
   *  By default this is set to true.
   * @param participantTrackPermissions Full list of individual permissions per
   *  participant/track. Any omitted participants will not receive any permissions.
   */
  setTrackSubscriptionPermissions(u) {
    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    this.participantTrackPermissions = c, this.allParticipantsAllowedToSubscribe = u, this.engine.client.isDisconnected || this.updateTrackSubscriptionPermissions();
  }
  /** @internal */
  updateInfo(u) {
    return u.sid !== this.sid || !super.updateInfo(u) ? !1 : (u.tracks.forEach((c) => {
      var l, v;
      const p = this.trackPublications.get(c.sid);
      if (p) {
        const _ = p.isMuted || ((v = (l = p.track) === null || l === void 0 ? void 0 : l.isUpstreamPaused) !== null && v !== void 0 ? v : !1);
        _ !== c.muted && (this.log.debug("updating server mute state after reconcile", Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(p)), {
          mutedOnServer: _
        })), this.engine.client.sendMuteTrack(c.sid, _));
      }
    }), !0);
  }
  getPublicationForTrack(u) {
    let c;
    return this.trackPublications.forEach((l) => {
      const v = l.track;
      v && (u instanceof MediaStreamTrack ? (v instanceof LocalAudioTrack || v instanceof LocalVideoTrack) && v.mediaStreamTrack === u && (c = l) : u === v && (c = l));
    }), c;
  }
}
class RemoteTrackPublication extends TrackPublication {
  constructor(u, c, l, v) {
    super(u, c.sid, c.name, v), this.track = void 0, this.allowed = !0, this.disabled = !1, this.currentVideoQuality = VideoQuality.HIGH, this.handleEnded = (p) => {
      this.setTrack(void 0), this.emit(TrackEvent.Ended, p);
    }, this.handleVisibilityChange = (p) => {
      this.log.debug("adaptivestream video visibility ".concat(this.trackSid, ", visible=").concat(p), this.logContext), this.disabled = !p, this.emitTrackUpdate();
    }, this.handleVideoDimensionsChange = (p) => {
      this.log.debug("adaptivestream video dimensions ".concat(p.width, "x").concat(p.height), this.logContext), this.videoDimensions = p, this.emitTrackUpdate();
    }, this.subscribed = l, this.updateInfo(c);
  }
  /**
   * Subscribe or unsubscribe to this remote track
   * @param subscribed true to subscribe to a track, false to unsubscribe
   */
  setSubscribed(u) {
    const c = this.subscriptionStatus, l = this.permissionStatus;
    this.subscribed = u, u && (this.allowed = !0);
    const v = new UpdateSubscription({
      trackSids: [this.trackSid],
      subscribe: this.subscribed,
      participantTracks: [new ParticipantTracks({
        // sending an empty participant id since TrackPublication doesn't keep it
        // this is filled in by the participant that receives this message
        participantSid: "",
        trackSids: [this.trackSid]
      })]
    });
    this.emit(TrackEvent.UpdateSubscription, v), this.emitSubscriptionUpdateIfChanged(c), this.emitPermissionUpdateIfChanged(l);
  }
  get subscriptionStatus() {
    return this.subscribed === !1 ? TrackPublication.SubscriptionStatus.Unsubscribed : super.isSubscribed ? TrackPublication.SubscriptionStatus.Subscribed : TrackPublication.SubscriptionStatus.Desired;
  }
  get permissionStatus() {
    return this.allowed ? TrackPublication.PermissionStatus.Allowed : TrackPublication.PermissionStatus.NotAllowed;
  }
  /**
   * Returns true if track is subscribed, and ready for playback
   */
  get isSubscribed() {
    return this.subscribed === !1 ? !1 : super.isSubscribed;
  }
  // returns client's desire to subscribe to a track, also true if autoSubscribe is enabled
  get isDesired() {
    return this.subscribed !== !1;
  }
  get isEnabled() {
    return !this.disabled;
  }
  /**
   * disable server from sending down data for this track. this is useful when
   * the participant is off screen, you may disable streaming down their video
   * to reduce bandwidth requirements
   * @param enabled
   */
  setEnabled(u) {
    !this.isManualOperationAllowed() || this.disabled === !u || (this.disabled = !u, this.emitTrackUpdate());
  }
  /**
   * for tracks that support simulcasting, adjust subscribed quality
   *
   * This indicates the highest quality the client can accept. if network
   * bandwidth does not allow, server will automatically reduce quality to
   * optimize for uninterrupted video
   */
  setVideoQuality(u) {
    !this.isManualOperationAllowed() || this.currentVideoQuality === u || (this.currentVideoQuality = u, this.videoDimensions = void 0, this.emitTrackUpdate());
  }
  setVideoDimensions(u) {
    var c, l;
    this.isManualOperationAllowed() && (((c = this.videoDimensions) === null || c === void 0 ? void 0 : c.width) === u.width && ((l = this.videoDimensions) === null || l === void 0 ? void 0 : l.height) === u.height || (this.track instanceof RemoteVideoTrack && (this.videoDimensions = u), this.currentVideoQuality = void 0, this.emitTrackUpdate()));
  }
  setVideoFPS(u) {
    this.isManualOperationAllowed() && this.track instanceof RemoteVideoTrack && this.fps !== u && (this.fps = u, this.emitTrackUpdate());
  }
  get videoQuality() {
    return this.currentVideoQuality;
  }
  /** @internal */
  setTrack(u) {
    const c = this.subscriptionStatus, l = this.permissionStatus, v = this.track;
    v !== u && (v && (v.off(TrackEvent.VideoDimensionsChanged, this.handleVideoDimensionsChange), v.off(TrackEvent.VisibilityChanged, this.handleVisibilityChange), v.off(TrackEvent.Ended, this.handleEnded), v.detach(), v.stopMonitor(), this.emit(TrackEvent.Unsubscribed, v)), super.setTrack(u), u && (u.sid = this.trackSid, u.on(TrackEvent.VideoDimensionsChanged, this.handleVideoDimensionsChange), u.on(TrackEvent.VisibilityChanged, this.handleVisibilityChange), u.on(TrackEvent.Ended, this.handleEnded), this.emit(TrackEvent.Subscribed, u)), this.emitPermissionUpdateIfChanged(l), this.emitSubscriptionUpdateIfChanged(c));
  }
  /** @internal */
  setAllowed(u) {
    const c = this.subscriptionStatus, l = this.permissionStatus;
    this.allowed = u, this.emitPermissionUpdateIfChanged(l), this.emitSubscriptionUpdateIfChanged(c);
  }
  /** @internal */
  setSubscriptionError(u) {
    this.emit(TrackEvent.SubscriptionFailed, u);
  }
  /** @internal */
  updateInfo(u) {
    super.updateInfo(u);
    const c = this.metadataMuted;
    this.metadataMuted = u.muted, this.track ? this.track.setMuted(u.muted) : c !== u.muted && this.emit(u.muted ? TrackEvent.Muted : TrackEvent.Unmuted);
  }
  emitSubscriptionUpdateIfChanged(u) {
    const c = this.subscriptionStatus;
    u !== c && this.emit(TrackEvent.SubscriptionStatusChanged, c, u);
  }
  emitPermissionUpdateIfChanged(u) {
    this.permissionStatus !== u && this.emit(TrackEvent.SubscriptionPermissionChanged, this.permissionStatus, u);
  }
  isManualOperationAllowed() {
    return this.kind === Track.Kind.Video && this.isAdaptiveStream ? (this.log.warn("adaptive stream is enabled, cannot change video track settings", this.logContext), !1) : this.isDesired ? !0 : (this.log.warn("cannot update track settings when not subscribed", this.logContext), !1);
  }
  get isAdaptiveStream() {
    return this.track instanceof RemoteVideoTrack && this.track.isAdaptiveStream;
  }
  /* @internal */
  emitTrackUpdate() {
    const u = new UpdateTrackSettings({
      trackSids: [this.trackSid],
      disabled: this.disabled,
      fps: this.fps
    });
    this.videoDimensions ? (u.width = Math.ceil(this.videoDimensions.width), u.height = Math.ceil(this.videoDimensions.height)) : this.currentVideoQuality !== void 0 ? u.quality = this.currentVideoQuality : u.quality = VideoQuality.HIGH, this.emit(TrackEvent.UpdateSettings, u);
  }
}
class RemoteParticipant extends Participant {
  /** @internal */
  static fromParticipantInfo(u, c) {
    return new RemoteParticipant(u, c.sid, c.identity, c.name, c.metadata);
  }
  get logContext() {
    return Object.assign(Object.assign({}, super.logContext), {
      rpID: this.sid,
      remoteParticipant: this.identity
    });
  }
  /** @internal */
  constructor(u, c, l, v, p, _) {
    super(c, l || "", v, p, _), this.signalClient = u, this.trackPublications = /* @__PURE__ */ new Map(), this.audioTrackPublications = /* @__PURE__ */ new Map(), this.videoTrackPublications = /* @__PURE__ */ new Map(), this.volumeMap = /* @__PURE__ */ new Map();
  }
  addTrackPublication(u) {
    super.addTrackPublication(u), u.on(TrackEvent.UpdateSettings, (c) => {
      this.log.debug("send update settings", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(u))), this.signalClient.sendUpdateTrackSettings(c);
    }), u.on(TrackEvent.UpdateSubscription, (c) => {
      c.participantTracks.forEach((l) => {
        l.participantSid = this.sid;
      }), this.signalClient.sendUpdateSubscription(c);
    }), u.on(TrackEvent.SubscriptionPermissionChanged, (c) => {
      this.emit(ParticipantEvent.TrackSubscriptionPermissionChanged, u, c);
    }), u.on(TrackEvent.SubscriptionStatusChanged, (c) => {
      this.emit(ParticipantEvent.TrackSubscriptionStatusChanged, u, c);
    }), u.on(TrackEvent.Subscribed, (c) => {
      this.emit(ParticipantEvent.TrackSubscribed, c, u);
    }), u.on(TrackEvent.Unsubscribed, (c) => {
      this.emit(ParticipantEvent.TrackUnsubscribed, c, u);
    }), u.on(TrackEvent.SubscriptionFailed, (c) => {
      this.emit(ParticipantEvent.TrackSubscriptionFailed, u.trackSid, c);
    });
  }
  getTrackPublication(u) {
    const c = super.getTrackPublication(u);
    if (c)
      return c;
  }
  getTrackPublicationByName(u) {
    const c = super.getTrackPublicationByName(u);
    if (c)
      return c;
  }
  /**
   * sets the volume on the participant's audio track
   * by default, this affects the microphone publication
   * a different source can be passed in as a second argument
   * if no track exists the volume will be applied when the microphone track is added
   */
  setVolume(u) {
    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Track.Source.Microphone;
    this.volumeMap.set(c, u);
    const l = this.getTrackPublication(c);
    l && l.track && l.track.setVolume(u);
  }
  /**
   * gets the volume on the participant's microphone track
   */
  getVolume() {
    let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Track.Source.Microphone;
    const c = this.getTrackPublication(u);
    return c && c.track ? c.track.getVolume() : this.volumeMap.get(u);
  }
  /** @internal */
  addSubscribedMediaTrack(u, c, l, v, p, _) {
    let k = this.getTrackPublicationBySid(c);
    if (k || c.startsWith("TR") || this.trackPublications.forEach((F) => {
      !k && u.kind === F.kind.toString() && (k = F);
    }), !k) {
      if (_ === 0) {
        this.log.error("could not find published track", Object.assign(Object.assign({}, this.logContext), {
          trackSid: c
        })), this.emit(ParticipantEvent.TrackSubscriptionFailed, c);
        return;
      }
      _ === void 0 && (_ = 20), setTimeout(() => {
        this.addSubscribedMediaTrack(u, c, l, v, p, _ - 1);
      }, 150);
      return;
    }
    if (u.readyState === "ended") {
      this.log.error("unable to subscribe because MediaStreamTrack is ended. Do not call MediaStreamTrack.stop()", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(k))), this.emit(ParticipantEvent.TrackSubscriptionFailed, c);
      return;
    }
    const M = u.kind === "video";
    let L;
    return M ? L = new RemoteVideoTrack(u, c, v, p) : L = new RemoteAudioTrack(u, c, v, this.audioContext, this.audioOutput), L.source = k.source, L.isMuted = k.isMuted, L.setMediaStream(l), L.start(), k.setTrack(L), this.volumeMap.has(k.source) && L instanceof RemoteAudioTrack && L.setVolume(this.volumeMap.get(k.source)), k;
  }
  /** @internal */
  get hasMetadata() {
    return !!this.participantInfo;
  }
  /**
   * @internal
   */
  getTrackPublicationBySid(u) {
    return this.trackPublications.get(u);
  }
  /** @internal */
  updateInfo(u) {
    if (!super.updateInfo(u))
      return !1;
    const c = /* @__PURE__ */ new Map(), l = /* @__PURE__ */ new Map();
    return u.tracks.forEach((v) => {
      var p, _;
      let k = this.getTrackPublicationBySid(v.sid);
      if (k)
        k.updateInfo(v);
      else {
        const M = Track.kindFromProto(v.type);
        if (!M)
          return;
        k = new RemoteTrackPublication(M, v, (p = this.signalClient.connectOptions) === null || p === void 0 ? void 0 : p.autoSubscribe, {
          loggerContextCb: () => this.logContext,
          loggerName: (_ = this.loggerOptions) === null || _ === void 0 ? void 0 : _.loggerName
        }), k.updateInfo(v), l.set(v.sid, k);
        const L = Array.from(this.trackPublications.values()).find((F) => F.source === (k == null ? void 0 : k.source));
        L && k.source !== Track.Source.Unknown && this.log.debug("received a second track publication for ".concat(this.identity, " with the same source: ").concat(k.source), Object.assign(Object.assign({}, this.logContext), {
          oldTrack: getLogContextFromTrack(L),
          newTrack: getLogContextFromTrack(k)
        })), this.addTrackPublication(k);
      }
      c.set(v.sid, k);
    }), this.trackPublications.forEach((v) => {
      c.has(v.trackSid) || (this.log.trace("detected removed track on remote participant, unpublishing", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(v))), this.unpublishTrack(v.trackSid, !0));
    }), l.forEach((v) => {
      this.emit(ParticipantEvent.TrackPublished, v);
    }), !0;
  }
  /** @internal */
  unpublishTrack(u, c) {
    const l = this.trackPublications.get(u);
    if (!l)
      return;
    const {
      track: v
    } = l;
    switch (v && (v.stop(), l.setTrack(void 0)), this.trackPublications.delete(u), l.kind) {
      case Track.Kind.Audio:
        this.audioTrackPublications.delete(u);
        break;
      case Track.Kind.Video:
        this.videoTrackPublications.delete(u);
        break;
    }
    c && this.emit(ParticipantEvent.TrackUnpublished, l);
  }
  /**
   * @internal
   */
  setAudioOutput(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      this.audioOutput = u;
      const c = [];
      this.audioTrackPublications.forEach((l) => {
        var v;
        l.track instanceof RemoteAudioTrack && c.push(l.track.setSinkId((v = u.deviceId) !== null && v !== void 0 ? v : "default"));
      }), yield Promise.all(c);
    });
  }
  /** @internal */
  emit(u) {
    for (var c = arguments.length, l = new Array(c > 1 ? c - 1 : 0), v = 1; v < c; v++)
      l[v - 1] = arguments[v];
    return this.log.trace("participant event", Object.assign(Object.assign({}, this.logContext), {
      event: u,
      args: l
    })), super.emit(u, ...l);
  }
}
var ConnectionState;
(function(a) {
  a.Disconnected = "disconnected", a.Connecting = "connecting", a.Connected = "connected", a.Reconnecting = "reconnecting";
})(ConnectionState || (ConnectionState = {}));
const connectionReconcileFrequency = 2 * 1e3;
class Room extends eventsExports$1.EventEmitter {
  /**
   * Creates a new Room, the primary construct for a LiveKit session.
   * @param options
   */
  constructor(u) {
    var c, l, v;
    super(), c = this, this.state = ConnectionState.Disconnected, this.activeSpeakers = [], this.isE2EEEnabled = !1, this.audioEnabled = !0, this.isVideoPlaybackBlocked = !1, this.log = livekitLogger, this.bufferedEvents = [], this.isResuming = !1, this.connect = (p, _, k) => __awaiter$3(this, void 0, void 0, function* () {
      var M;
      if (!isBrowserSupported())
        throw isReactNative() ? Error("WebRTC isn't detected, have you called registerGlobals?") : Error("LiveKit doesn't seem to be supported on this browser. Try to update your browser and make sure no browser extensions are disabling webRTC.");
      const L = yield this.disconnectLock.lock();
      if (this.state === ConnectionState.Connected)
        return this.log.info("already connected to room ".concat(this.name), this.logContext), L(), Promise.resolve();
      if (this.connectFuture)
        return L(), this.connectFuture.promise;
      this.setAndEmitConnectionState(ConnectionState.Connecting), ((M = this.regionUrlProvider) === null || M === void 0 ? void 0 : M.getServerUrl().toString()) !== p && (this.regionUrl = void 0, this.regionUrlProvider = void 0), isCloud(new URL(p)) && (this.regionUrlProvider === void 0 ? this.regionUrlProvider = new RegionUrlProvider(p, _) : this.regionUrlProvider.updateToken(_), this.regionUrlProvider.fetchRegionSettings().catch((X) => {
        this.log.warn("could not fetch region settings", Object.assign(Object.assign({}, this.logContext), {
          error: X
        }));
      }));
      const F = (X, oe, Y) => __awaiter$3(this, void 0, void 0, function* () {
        var ae;
        this.abortController && this.abortController.abort();
        const ne = new AbortController();
        this.abortController = ne, L == null || L();
        try {
          yield this.attemptConnection(Y ?? p, _, k, ne), this.abortController = void 0, X();
        } catch (fe) {
          if (this.regionUrlProvider && fe instanceof ConnectionError && fe.reason !== 3 && fe.reason !== 0) {
            let ie = null;
            try {
              ie = yield this.regionUrlProvider.getNextBestRegionUrl((ae = this.abortController) === null || ae === void 0 ? void 0 : ae.signal);
            } catch (ge) {
              if (ge instanceof ConnectionError && (ge.status === 401 || ge.reason === 3)) {
                this.handleDisconnect(this.options.stopLocalTrackOnUnpublish), oe(ge);
                return;
              }
            }
            ie ? (this.log.info("Initial connection failed with ConnectionError: ".concat(fe.message, ". Retrying with another region: ").concat(ie), this.logContext), this.recreateEngine(), yield F(X, oe, ie)) : (this.handleDisconnect(this.options.stopLocalTrackOnUnpublish), oe(fe));
          } else
            this.handleDisconnect(this.options.stopLocalTrackOnUnpublish), oe(fe);
        }
      }), V = this.regionUrl;
      return this.regionUrl = void 0, this.connectFuture = new Future((X, oe) => {
        F(X, oe, V);
      }, () => {
        this.clearConnectionFutures();
      }), this.connectFuture.promise;
    }), this.connectSignal = (p, _, k, M, L, F) => __awaiter$3(this, void 0, void 0, function* () {
      var V, X, oe;
      const Y = yield k.join(p, _, {
        autoSubscribe: M.autoSubscribe,
        adaptiveStream: typeof L.adaptiveStream == "object" ? !0 : L.adaptiveStream,
        maxRetries: M.maxRetries,
        e2eeEnabled: !!this.e2eeManager,
        websocketTimeout: M.websocketTimeout
      }, F.signal);
      let ae = Y.serverInfo;
      if (ae || (ae = {
        version: Y.serverVersion,
        region: Y.serverRegion
      }), this.log.debug("connected to Livekit Server ".concat(Object.entries(ae).map((ne) => {
        let [fe, ie] = ne;
        return "".concat(fe, ": ").concat(ie);
      }).join(", ")), {
        room: (V = Y.room) === null || V === void 0 ? void 0 : V.name,
        roomSid: (X = Y.room) === null || X === void 0 ? void 0 : X.sid,
        identity: (oe = Y.participant) === null || oe === void 0 ? void 0 : oe.identity
      }), !Y.serverVersion)
        throw new UnsupportedServer("unknown server version");
      return Y.serverVersion === "0.15.1" && this.options.dynacast && (this.log.debug("disabling dynacast due to server version", this.logContext), L.dynacast = !1), Y;
    }), this.applyJoinResponse = (p) => {
      const _ = p.participant;
      if (this.localParticipant.sid = _.sid, this.localParticipant.identity = _.identity, this.options.e2ee && this.e2eeManager)
        try {
          this.e2eeManager.setSifTrailer(p.sifTrailer);
        } catch (k) {
          this.log.error(k instanceof Error ? k.message : "Could not set SifTrailer", Object.assign(Object.assign({}, this.logContext), {
            error: k
          }));
        }
      this.handleParticipantUpdates([_, ...p.otherParticipants]), p.room && this.handleRoomUpdate(p.room);
    }, this.attemptConnection = (p, _, k, M) => __awaiter$3(this, void 0, void 0, function* () {
      var L, F, V;
      this.state === ConnectionState.Reconnecting || this.isResuming || !((L = this.engine) === null || L === void 0) && L.pendingReconnect ? (this.log.info("Reconnection attempt replaced by new connection attempt", this.logContext), this.recreateEngine()) : this.maybeCreateEngine(), !((F = this.regionUrlProvider) === null || F === void 0) && F.isCloud() && this.engine.setRegionUrlProvider(this.regionUrlProvider), this.acquireAudioContext(), this.connOptions = Object.assign(Object.assign({}, roomConnectOptionDefaults), k), this.connOptions.rtcConfig && (this.engine.rtcConfig = this.connOptions.rtcConfig), this.connOptions.peerConnectionTimeout && (this.engine.peerConnectionTimeout = this.connOptions.peerConnectionTimeout);
      try {
        const X = yield this.connectSignal(p, _, this.engine, this.connOptions, this.options, M);
        this.applyJoinResponse(X), this.setupLocalParticipantEvents(), this.emit(RoomEvent.SignalConnected);
      } catch (X) {
        yield this.engine.close(), this.recreateEngine();
        const oe = new ConnectionError("could not establish signal connection");
        throw X instanceof Error && (oe.message = "".concat(oe.message, ": ").concat(X.message)), X instanceof ConnectionError && (oe.reason = X.reason, oe.status = X.status), this.log.debug("error trying to establish signal connection", Object.assign(Object.assign({}, this.logContext), {
          error: X
        })), oe;
      }
      if (M.signal.aborted)
        throw yield this.engine.close(), this.recreateEngine(), new ConnectionError("Connection attempt aborted");
      try {
        yield this.engine.waitForPCInitialConnection(this.connOptions.peerConnectionTimeout, M);
      } catch (X) {
        throw yield this.engine.close(), this.recreateEngine(), X;
      }
      isWeb() && this.options.disconnectOnPageLeave && (window.addEventListener("pagehide", this.onPageLeave), window.addEventListener("beforeunload", this.onPageLeave)), isWeb() && (document.addEventListener("freeze", this.onPageLeave), (V = navigator.mediaDevices) === null || V === void 0 || V.addEventListener("devicechange", this.handleDeviceChange)), this.setAndEmitConnectionState(ConnectionState.Connected), this.emit(RoomEvent.Connected), this.registerConnectionReconcile();
    }), this.disconnect = function() {
      let p = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
      return __awaiter$3(c, void 0, void 0, function* () {
        var _, k, M, L;
        const F = yield this.disconnectLock.lock();
        try {
          if (this.state === ConnectionState.Disconnected) {
            this.log.debug("already disconnected", this.logContext);
            return;
          }
          this.log.info("disconnect from room", Object.assign({}, this.logContext)), (this.state === ConnectionState.Connecting || this.state === ConnectionState.Reconnecting || this.isResuming) && (this.log.warn("abort connection attempt", this.logContext), (_ = this.abortController) === null || _ === void 0 || _.abort(), (M = (k = this.connectFuture) === null || k === void 0 ? void 0 : k.reject) === null || M === void 0 || M.call(k, new ConnectionError("Client initiated disconnect")), this.connectFuture = void 0), !((L = this.engine) === null || L === void 0) && L.client.isDisconnected || (yield this.engine.client.sendLeave()), this.engine && (yield this.engine.close()), this.handleDisconnect(p, DisconnectReason.CLIENT_INITIATED), this.engine = void 0;
        } finally {
          F();
        }
      });
    }, this.onPageLeave = () => __awaiter$3(this, void 0, void 0, function* () {
      this.log.info("Page leave detected, disconnecting", this.logContext), yield this.disconnect();
    }), this.startAudio = () => __awaiter$3(this, void 0, void 0, function* () {
      const p = [], _ = getBrowser();
      if (_ && _.os === "iOS") {
        const k = "livekit-dummy-audio-el";
        let M = document.getElementById(k);
        if (!M) {
          M = document.createElement("audio"), M.id = k, M.autoplay = !0, M.hidden = !0;
          const L = getEmptyAudioStreamTrack();
          L.enabled = !0;
          const F = new MediaStream([L]);
          M.srcObject = F, document.addEventListener("visibilitychange", () => {
            M && (M.srcObject = document.hidden ? null : F, document.hidden || (this.log.debug("page visible again, triggering startAudio to resume playback and update playback status", this.logContext), this.startAudio()));
          }), document.body.append(M), this.once(RoomEvent.Disconnected, () => {
            M == null || M.remove(), M = null;
          });
        }
        p.push(M);
      }
      this.remoteParticipants.forEach((k) => {
        k.audioTrackPublications.forEach((M) => {
          M.track && M.track.attachedElements.forEach((L) => {
            p.push(L);
          });
        });
      });
      try {
        yield Promise.all([this.acquireAudioContext(), ...p.map((k) => (k.muted = !1, k.play()))]), this.handleAudioPlaybackStarted();
      } catch (k) {
        throw this.handleAudioPlaybackFailed(k), k;
      }
    }), this.startVideo = () => __awaiter$3(this, void 0, void 0, function* () {
      const p = [];
      for (const _ of this.remoteParticipants.values())
        _.videoTrackPublications.forEach((k) => {
          var M;
          (M = k.track) === null || M === void 0 || M.attachedElements.forEach((L) => {
            p.includes(L) || p.push(L);
          });
        });
      yield Promise.all(p.map((_) => _.play())).then(() => {
        this.handleVideoPlaybackStarted();
      }).catch((_) => {
        _.name === "NotAllowedError" ? this.handleVideoPlaybackFailed() : this.log.warn("Resuming video playback failed, make sure you call `startVideo` directly in a user gesture handler", this.logContext);
      });
    }), this.handleRestarting = () => {
      this.clearConnectionReconcile(), this.isResuming = !1;
      for (const p of this.remoteParticipants.values())
        this.handleParticipantDisconnected(p.identity, p);
      this.setAndEmitConnectionState(ConnectionState.Reconnecting) && this.emit(RoomEvent.Reconnecting);
    }, this.handleSignalRestarted = (p) => __awaiter$3(this, void 0, void 0, function* () {
      this.log.debug("signal reconnected to server, region ".concat(p.serverRegion), Object.assign(Object.assign({}, this.logContext), {
        region: p.serverRegion
      })), this.bufferedEvents = [], this.applyJoinResponse(p);
      try {
        yield this.localParticipant.republishAllTracks(void 0, !0);
      } catch (_) {
        this.log.error("error trying to re-publish tracks after reconnection", Object.assign(Object.assign({}, this.logContext), {
          error: _
        }));
      }
      try {
        yield this.engine.waitForRestarted(), this.log.debug("fully reconnected to server", Object.assign(Object.assign({}, this.logContext), {
          region: p.serverRegion
        }));
      } catch {
        return;
      }
      this.setAndEmitConnectionState(ConnectionState.Connected), this.emit(RoomEvent.Reconnected), this.registerConnectionReconcile(), this.emitBufferedEvents();
    }), this.handleParticipantUpdates = (p) => {
      p.forEach((_) => {
        var k;
        if (_.identity === this.localParticipant.identity) {
          this.localParticipant.updateInfo(_);
          return;
        }
        _.identity === "" && (_.identity = (k = this.sidToIdentity.get(_.sid)) !== null && k !== void 0 ? k : "");
        let M = this.remoteParticipants.get(_.identity);
        _.state === ParticipantInfo_State.DISCONNECTED ? this.handleParticipantDisconnected(_.identity, M) : M = this.getOrCreateParticipant(_.identity, _);
      });
    }, this.handleActiveSpeakersUpdate = (p) => {
      const _ = [], k = {};
      p.forEach((M) => {
        if (k[M.sid] = !0, M.sid === this.localParticipant.sid)
          this.localParticipant.audioLevel = M.level, this.localParticipant.setIsSpeaking(!0), _.push(this.localParticipant);
        else {
          const L = this.getRemoteParticipantBySid(M.sid);
          L && (L.audioLevel = M.level, L.setIsSpeaking(!0), _.push(L));
        }
      }), k[this.localParticipant.sid] || (this.localParticipant.audioLevel = 0, this.localParticipant.setIsSpeaking(!1)), this.remoteParticipants.forEach((M) => {
        k[M.sid] || (M.audioLevel = 0, M.setIsSpeaking(!1));
      }), this.activeSpeakers = _, this.emitWhenConnected(RoomEvent.ActiveSpeakersChanged, _);
    }, this.handleSpeakersChanged = (p) => {
      const _ = /* @__PURE__ */ new Map();
      this.activeSpeakers.forEach((M) => {
        _.set(M.sid, M);
      }), p.forEach((M) => {
        let L = this.getRemoteParticipantBySid(M.sid);
        M.sid === this.localParticipant.sid && (L = this.localParticipant), L && (L.audioLevel = M.level, L.setIsSpeaking(M.active), M.active ? _.set(M.sid, L) : _.delete(M.sid));
      });
      const k = Array.from(_.values());
      k.sort((M, L) => L.audioLevel - M.audioLevel), this.activeSpeakers = k, this.emitWhenConnected(RoomEvent.ActiveSpeakersChanged, k);
    }, this.handleStreamStateUpdate = (p) => {
      p.streamStates.forEach((_) => {
        const k = this.getRemoteParticipantBySid(_.participantSid);
        if (!k)
          return;
        const M = k.getTrackPublicationBySid(_.trackSid);
        !M || !M.track || (M.track.streamState = Track.streamStateFromProto(_.state), k.emit(ParticipantEvent.TrackStreamStateChanged, M, M.track.streamState), this.emitWhenConnected(RoomEvent.TrackStreamStateChanged, M, M.track.streamState, k));
      });
    }, this.handleSubscriptionPermissionUpdate = (p) => {
      const _ = this.getRemoteParticipantBySid(p.participantSid);
      if (!_)
        return;
      const k = _.getTrackPublicationBySid(p.trackSid);
      k && k.setAllowed(p.allowed);
    }, this.handleSubscriptionError = (p) => {
      const _ = Array.from(this.remoteParticipants.values()).find((M) => M.trackPublications.has(p.trackSid));
      if (!_)
        return;
      const k = _.getTrackPublicationBySid(p.trackSid);
      k && k.setSubscriptionError(p.err);
    }, this.handleDataPacket = (p, _) => {
      const k = this.remoteParticipants.get(p.participantIdentity);
      this.emit(RoomEvent.DataReceived, p.payload, k, _, p.topic), k == null || k.emit(ParticipantEvent.DataReceived, p.payload, _);
    }, this.handleAudioPlaybackStarted = () => {
      this.canPlaybackAudio || (this.audioEnabled = !0, this.emit(RoomEvent.AudioPlaybackStatusChanged, !0));
    }, this.handleAudioPlaybackFailed = (p) => {
      this.log.warn("could not playback audio", Object.assign(Object.assign({}, this.logContext), {
        error: p
      })), this.canPlaybackAudio && (this.audioEnabled = !1, this.emit(RoomEvent.AudioPlaybackStatusChanged, !1));
    }, this.handleVideoPlaybackStarted = () => {
      this.isVideoPlaybackBlocked && (this.isVideoPlaybackBlocked = !1, this.emit(RoomEvent.VideoPlaybackStatusChanged, !0));
    }, this.handleVideoPlaybackFailed = () => {
      this.isVideoPlaybackBlocked || (this.isVideoPlaybackBlocked = !0, this.emit(RoomEvent.VideoPlaybackStatusChanged, !1));
    }, this.handleDeviceChange = () => __awaiter$3(this, void 0, void 0, function* () {
      this.emit(RoomEvent.MediaDevicesChanged);
    }), this.handleRoomUpdate = (p) => {
      const _ = this.roomInfo;
      this.roomInfo = p, _ && _.metadata !== p.metadata && this.emitWhenConnected(RoomEvent.RoomMetadataChanged, p.metadata), (_ == null ? void 0 : _.activeRecording) !== p.activeRecording && this.emitWhenConnected(RoomEvent.RecordingStatusChanged, p.activeRecording);
    }, this.handleConnectionQualityUpdate = (p) => {
      p.updates.forEach((_) => {
        if (_.participantSid === this.localParticipant.sid) {
          this.localParticipant.setConnectionQuality(_.quality);
          return;
        }
        const k = this.getRemoteParticipantBySid(_.participantSid);
        k && k.setConnectionQuality(_.quality);
      });
    }, this.onLocalParticipantMetadataChanged = (p) => {
      this.emit(RoomEvent.ParticipantMetadataChanged, p, this.localParticipant);
    }, this.onLocalParticipantNameChanged = (p) => {
      this.emit(RoomEvent.ParticipantNameChanged, p, this.localParticipant);
    }, this.onLocalTrackMuted = (p) => {
      this.emit(RoomEvent.TrackMuted, p, this.localParticipant);
    }, this.onLocalTrackUnmuted = (p) => {
      this.emit(RoomEvent.TrackUnmuted, p, this.localParticipant);
    }, this.onTrackProcessorUpdate = (p) => {
      var _;
      (_ = p == null ? void 0 : p.onPublish) === null || _ === void 0 || _.call(p, this);
    }, this.onLocalTrackPublished = (p) => __awaiter$3(this, void 0, void 0, function* () {
      var _, k, M, L, F;
      (_ = p.track) === null || _ === void 0 || _.on(TrackEvent.TrackProcessorUpdate, this.onTrackProcessorUpdate), (L = (M = (k = p.track) === null || k === void 0 ? void 0 : k.getProcessor()) === null || M === void 0 ? void 0 : M.onPublish) === null || L === void 0 || L.call(M, this), this.emit(RoomEvent.LocalTrackPublished, p, this.localParticipant), p.track instanceof LocalAudioTrack && (yield p.track.checkForSilence()) && this.emit(RoomEvent.LocalAudioSilenceDetected, p);
      const V = yield (F = p.track) === null || F === void 0 ? void 0 : F.getDeviceId(), X = sourceToKind(p.source);
      X && V && V !== this.localParticipant.activeDeviceMap.get(X) && (this.localParticipant.activeDeviceMap.set(X, V), this.emit(RoomEvent.ActiveDeviceChanged, X, V));
    }), this.onLocalTrackUnpublished = (p) => {
      var _;
      (_ = p.track) === null || _ === void 0 || _.off(TrackEvent.TrackProcessorUpdate, this.onTrackProcessorUpdate), this.emit(RoomEvent.LocalTrackUnpublished, p, this.localParticipant);
    }, this.onLocalConnectionQualityChanged = (p) => {
      this.emit(RoomEvent.ConnectionQualityChanged, p, this.localParticipant);
    }, this.onMediaDevicesError = (p) => {
      this.emit(RoomEvent.MediaDevicesError, p);
    }, this.onLocalParticipantPermissionsChanged = (p) => {
      this.emit(RoomEvent.ParticipantPermissionsChanged, p, this.localParticipant);
    }, this.setMaxListeners(100), this.remoteParticipants = /* @__PURE__ */ new Map(), this.sidToIdentity = /* @__PURE__ */ new Map(), this.options = Object.assign(Object.assign({}, roomOptionDefaults), u), this.log = getLogger((l = this.options.loggerName) !== null && l !== void 0 ? l : LoggerNames.Room), this.options.audioCaptureDefaults = Object.assign(Object.assign({}, audioDefaults), u == null ? void 0 : u.audioCaptureDefaults), this.options.videoCaptureDefaults = Object.assign(Object.assign({}, videoDefaults), u == null ? void 0 : u.videoCaptureDefaults), this.options.publishDefaults = Object.assign(Object.assign({}, publishDefaults), u == null ? void 0 : u.publishDefaults), this.maybeCreateEngine(), this.disconnectLock = new Mutex(), this.localParticipant = new LocalParticipant("", "", this.engine, this.options), this.options.videoCaptureDefaults.deviceId && this.localParticipant.activeDeviceMap.set("videoinput", unwrapConstraint(this.options.videoCaptureDefaults.deviceId)), this.options.audioCaptureDefaults.deviceId && this.localParticipant.activeDeviceMap.set("audioinput", unwrapConstraint(this.options.audioCaptureDefaults.deviceId)), !((v = this.options.audioOutput) === null || v === void 0) && v.deviceId && this.switchActiveDevice("audiooutput", unwrapConstraint(this.options.audioOutput.deviceId)).catch((p) => this.log.warn("Could not set audio output: ".concat(p.message), this.logContext)), this.options.e2ee && this.setupE2EE();
  }
  /**
   * @experimental
   */
  setE2EEEnabled(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (this.e2eeManager)
        yield Promise.all([this.localParticipant.setE2EEEnabled(u)]), this.localParticipant.identity !== "" && this.e2eeManager.setParticipantCryptorEnabled(u, this.localParticipant.identity);
      else
        throw Error("e2ee not configured, please set e2ee settings within the room options");
    });
  }
  setupE2EE() {
    var u;
    this.options.e2ee && (this.e2eeManager = new E2EEManager(this.options.e2ee), this.e2eeManager.on(EncryptionEvent.ParticipantEncryptionStatusChanged, (c, l) => {
      l instanceof LocalParticipant && (this.isE2EEEnabled = c), this.emit(RoomEvent.ParticipantEncryptionStatusChanged, c, l);
    }), this.e2eeManager.on(EncryptionEvent.EncryptionError, (c) => this.emit(RoomEvent.EncryptionError, c)), (u = this.e2eeManager) === null || u === void 0 || u.setup(this));
  }
  get logContext() {
    var u;
    return {
      room: this.name,
      roomID: (u = this.roomInfo) === null || u === void 0 ? void 0 : u.sid,
      participant: this.localParticipant.identity,
      pID: this.localParticipant.sid
    };
  }
  /**
   * if the current room has a participant with `recorder: true` in its JWT grant
   **/
  get isRecording() {
    var u, c;
    return (c = (u = this.roomInfo) === null || u === void 0 ? void 0 : u.activeRecording) !== null && c !== void 0 ? c : !1;
  }
  /**
   * server assigned unique room id.
   * returns once a sid has been issued by the server.
   */
  getSid() {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this.state === ConnectionState.Disconnected ? "" : this.roomInfo && this.roomInfo.sid !== "" ? this.roomInfo.sid : new Promise((u, c) => {
        const l = (v) => {
          v.sid !== "" && (this.engine.off(EngineEvent.RoomUpdate, l), u(v.sid));
        };
        this.engine.on(EngineEvent.RoomUpdate, l), this.once(RoomEvent.Disconnected, () => {
          this.engine.off(EngineEvent.RoomUpdate, l), c("Room disconnected before room server id was available");
        });
      });
    });
  }
  /** user assigned name, derived from JWT token */
  get name() {
    var u, c;
    return (c = (u = this.roomInfo) === null || u === void 0 ? void 0 : u.name) !== null && c !== void 0 ? c : "";
  }
  /** room metadata */
  get metadata() {
    var u;
    return (u = this.roomInfo) === null || u === void 0 ? void 0 : u.metadata;
  }
  get numParticipants() {
    var u, c;
    return (c = (u = this.roomInfo) === null || u === void 0 ? void 0 : u.numParticipants) !== null && c !== void 0 ? c : 0;
  }
  get numPublishers() {
    var u, c;
    return (c = (u = this.roomInfo) === null || u === void 0 ? void 0 : u.numPublishers) !== null && c !== void 0 ? c : 0;
  }
  maybeCreateEngine() {
    this.engine && !this.engine.isClosed || (this.engine = new RTCEngine(this.options), this.engine.on(EngineEvent.ParticipantUpdate, this.handleParticipantUpdates).on(EngineEvent.RoomUpdate, this.handleRoomUpdate).on(EngineEvent.SpeakersChanged, this.handleSpeakersChanged).on(EngineEvent.StreamStateChanged, this.handleStreamStateUpdate).on(EngineEvent.ConnectionQualityUpdate, this.handleConnectionQualityUpdate).on(EngineEvent.SubscriptionError, this.handleSubscriptionError).on(EngineEvent.SubscriptionPermissionUpdate, this.handleSubscriptionPermissionUpdate).on(EngineEvent.MediaTrackAdded, (u, c, l) => {
      this.onTrackAdded(u, c, l);
    }).on(EngineEvent.Disconnected, (u) => {
      this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, u);
    }).on(EngineEvent.ActiveSpeakersUpdate, this.handleActiveSpeakersUpdate).on(EngineEvent.DataPacketReceived, this.handleDataPacket).on(EngineEvent.Resuming, () => {
      this.clearConnectionReconcile(), this.isResuming = !0, this.log.info("Resuming signal connection", this.logContext);
    }).on(EngineEvent.Resumed, () => {
      this.registerConnectionReconcile(), this.isResuming = !1, this.log.info("Resumed signal connection", this.logContext), this.updateSubscriptions(), this.emitBufferedEvents();
    }).on(EngineEvent.SignalResumed, () => {
      this.bufferedEvents = [], (this.state === ConnectionState.Reconnecting || this.isResuming) && this.sendSyncState();
    }).on(EngineEvent.Restarting, this.handleRestarting).on(EngineEvent.SignalRestarted, this.handleSignalRestarted).on(EngineEvent.Offline, () => {
      this.setAndEmitConnectionState(ConnectionState.Reconnecting) && this.emit(RoomEvent.Reconnecting);
    }).on(EngineEvent.DCBufferStatusChanged, (u, c) => {
      this.emit(RoomEvent.DCBufferStatusChanged, u, c);
    }), this.localParticipant && this.localParticipant.setupEngine(this.engine), this.e2eeManager && this.e2eeManager.setupEngine(this.engine));
  }
  /**
   * getLocalDevices abstracts navigator.mediaDevices.enumerateDevices.
   * In particular, it handles Chrome's unique behavior of creating `default`
   * devices. When encountered, it'll be removed from the list of devices.
   * The actual default device will be placed at top.
   * @param kind
   * @returns a list of available local devices
   */
  static getLocalDevices(u) {
    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
    return DeviceManager.getInstance().getDevices(u, c);
  }
  /**
   * prepareConnection should be called as soon as the page is loaded, in order
   * to speed up the connection attempt. This function will
   * - perform DNS resolution and pre-warm the DNS cache
   * - establish TLS connection and cache TLS keys
   *
   * With LiveKit Cloud, it will also determine the best edge data center for
   * the current client to connect to if a token is provided.
   */
  prepareConnection(u, c) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (this.state === ConnectionState.Disconnected) {
        this.log.debug("prepareConnection to ".concat(u), this.logContext);
        try {
          if (isCloud(new URL(u)) && c) {
            this.regionUrlProvider = new RegionUrlProvider(u, c);
            const l = yield this.regionUrlProvider.getNextBestRegionUrl();
            l && this.state === ConnectionState.Disconnected && (this.regionUrl = l, yield fetch(toHttpUrl(l), {
              method: "HEAD"
            }), this.log.debug("prepared connection to ".concat(l), this.logContext));
          } else
            yield fetch(toHttpUrl(u), {
              method: "HEAD"
            });
        } catch (l) {
          this.log.warn("could not prepare connection", Object.assign(Object.assign({}, this.logContext), {
            error: l
          }));
        }
      }
    });
  }
  /**
   * retrieves a participant by identity
   * @param identity
   * @returns
   */
  getParticipantByIdentity(u) {
    return this.localParticipant.identity === u ? this.localParticipant : this.remoteParticipants.get(u);
  }
  clearConnectionFutures() {
    this.connectFuture = void 0;
  }
  /**
   * @internal for testing
   */
  simulateScenario(u, c) {
    return __awaiter$3(this, void 0, void 0, function* () {
      let l = () => {
      }, v;
      switch (u) {
        case "signal-reconnect":
          yield this.engine.client.handleOnClose("simulate disconnect");
          break;
        case "speaker":
          v = new SimulateScenario({
            scenario: {
              case: "speakerUpdate",
              value: 3
            }
          });
          break;
        case "node-failure":
          v = new SimulateScenario({
            scenario: {
              case: "nodeFailure",
              value: !0
            }
          });
          break;
        case "server-leave":
          v = new SimulateScenario({
            scenario: {
              case: "serverLeave",
              value: !0
            }
          });
          break;
        case "migration":
          v = new SimulateScenario({
            scenario: {
              case: "migration",
              value: !0
            }
          });
          break;
        case "resume-reconnect":
          this.engine.failNext(), yield this.engine.client.handleOnClose("simulate resume-disconnect");
          break;
        case "disconnect-signal-on-resume":
          l = () => __awaiter$3(this, void 0, void 0, function* () {
            yield this.engine.client.handleOnClose("simulate resume-disconnect");
          }), v = new SimulateScenario({
            scenario: {
              case: "disconnectSignalOnResume",
              value: !0
            }
          });
          break;
        case "disconnect-signal-on-resume-no-messages":
          l = () => __awaiter$3(this, void 0, void 0, function* () {
            yield this.engine.client.handleOnClose("simulate resume-disconnect");
          }), v = new SimulateScenario({
            scenario: {
              case: "disconnectSignalOnResumeNoMessages",
              value: !0
            }
          });
          break;
        case "full-reconnect":
          this.engine.fullReconnectOnNext = !0, yield this.engine.client.handleOnClose("simulate full-reconnect");
          break;
        case "force-tcp":
        case "force-tls":
          v = new SimulateScenario({
            scenario: {
              case: "switchCandidateProtocol",
              value: u === "force-tls" ? 2 : 1
            }
          }), l = () => __awaiter$3(this, void 0, void 0, function* () {
            const p = this.engine.client.onLeave;
            p && p(new LeaveRequest({
              reason: DisconnectReason.CLIENT_INITIATED,
              canReconnect: !0
            }));
          });
          break;
        case "subscriber-bandwidth":
          if (c === void 0 || typeof c != "number")
            throw new Error("subscriber-bandwidth requires a number as argument");
          v = new SimulateScenario({
            scenario: {
              case: "subscriberBandwidth",
              value: BigInt(c)
            }
          });
          break;
      }
      v && (yield this.engine.client.sendSimulateScenario(v), yield l());
    });
  }
  /**
   * Returns true if audio playback is enabled
   */
  get canPlaybackAudio() {
    return this.audioEnabled;
  }
  /**
   * Returns true if video playback is enabled
   */
  get canPlaybackVideo() {
    return !this.isVideoPlaybackBlocked;
  }
  getActiveDevice(u) {
    return this.localParticipant.activeDeviceMap.get(u);
  }
  /**
   * Switches all active devices used in this room to the given device.
   *
   * Note: setting AudioOutput is not supported on some browsers. See [setSinkId](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/setSinkId#browser_compatibility)
   *
   * @param kind use `videoinput` for camera track,
   *  `audioinput` for microphone track,
   *  `audiooutput` to set speaker for all incoming audio tracks
   * @param deviceId
   */
  switchActiveDevice(u, c) {
    let l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
    var v, p, _, k;
    return __awaiter$3(this, void 0, void 0, function* () {
      let M = !1, L = !0;
      const F = l ? {
        exact: c
      } : c;
      if (u === "audioinput") {
        const V = this.options.audioCaptureDefaults.deviceId;
        this.options.audioCaptureDefaults.deviceId = F, M = V !== F;
        const X = Array.from(this.localParticipant.audioTrackPublications.values()).filter((oe) => oe.source === Track.Source.Microphone);
        try {
          L = (yield Promise.all(X.map((oe) => {
            var Y;
            return (Y = oe.audioTrack) === null || Y === void 0 ? void 0 : Y.setDeviceId(F);
          }))).every((oe) => oe === !0);
        } catch (oe) {
          throw this.options.audioCaptureDefaults.deviceId = V, oe;
        }
      } else if (u === "videoinput") {
        const V = this.options.videoCaptureDefaults.deviceId;
        this.options.videoCaptureDefaults.deviceId = F, M = V !== F;
        const X = Array.from(this.localParticipant.videoTrackPublications.values()).filter((oe) => oe.source === Track.Source.Camera);
        try {
          L = (yield Promise.all(X.map((oe) => {
            var Y;
            return (Y = oe.videoTrack) === null || Y === void 0 ? void 0 : Y.setDeviceId(F);
          }))).every((oe) => oe === !0);
        } catch (oe) {
          throw this.options.videoCaptureDefaults.deviceId = V, oe;
        }
      } else if (u === "audiooutput") {
        if (!supportsSetSinkId() && !this.options.webAudioMix || this.options.webAudioMix && this.audioContext && !("setSinkId" in this.audioContext))
          throw new Error("cannot switch audio output, setSinkId not supported");
        this.options.webAudioMix && (c = (v = yield DeviceManager.getInstance().normalizeDeviceId("audiooutput", c)) !== null && v !== void 0 ? v : ""), (p = (k = this.options).audioOutput) !== null && p !== void 0 || (k.audioOutput = {});
        const V = this.options.audioOutput.deviceId;
        this.options.audioOutput.deviceId = c, M = V !== F;
        try {
          this.options.webAudioMix ? (_ = this.audioContext) === null || _ === void 0 || _.setSinkId(c) : yield Promise.all(Array.from(this.remoteParticipants.values()).map((X) => X.setAudioOutput({
            deviceId: c
          })));
        } catch (X) {
          throw this.options.audioOutput.deviceId = V, X;
        }
      }
      return M && L && (this.localParticipant.activeDeviceMap.set(u, c), this.emit(RoomEvent.ActiveDeviceChanged, u, c)), L;
    });
  }
  setupLocalParticipantEvents() {
    this.localParticipant.on(ParticipantEvent.ParticipantMetadataChanged, this.onLocalParticipantMetadataChanged).on(ParticipantEvent.ParticipantNameChanged, this.onLocalParticipantNameChanged).on(ParticipantEvent.TrackMuted, this.onLocalTrackMuted).on(ParticipantEvent.TrackUnmuted, this.onLocalTrackUnmuted).on(ParticipantEvent.LocalTrackPublished, this.onLocalTrackPublished).on(ParticipantEvent.LocalTrackUnpublished, this.onLocalTrackUnpublished).on(ParticipantEvent.ConnectionQualityChanged, this.onLocalConnectionQualityChanged).on(ParticipantEvent.MediaDevicesError, this.onMediaDevicesError).on(ParticipantEvent.AudioStreamAcquired, this.startAudio).on(ParticipantEvent.ParticipantPermissionsChanged, this.onLocalParticipantPermissionsChanged);
  }
  recreateEngine() {
    var u;
    (u = this.engine) === null || u === void 0 || u.close(), this.engine = void 0, this.isResuming = !1, this.remoteParticipants.clear(), this.sidToIdentity.clear(), this.bufferedEvents = [], this.maybeCreateEngine();
  }
  onTrackAdded(u, c, l) {
    if (this.state === ConnectionState.Connecting || this.state === ConnectionState.Reconnecting) {
      const F = () => {
        this.onTrackAdded(u, c, l), V();
      }, V = () => {
        this.off(RoomEvent.Reconnected, F), this.off(RoomEvent.Connected, F), this.off(RoomEvent.Disconnected, V);
      };
      this.once(RoomEvent.Reconnected, F), this.once(RoomEvent.Connected, F), this.once(RoomEvent.Disconnected, V);
      return;
    }
    if (this.state === ConnectionState.Disconnected) {
      this.log.warn("skipping incoming track after Room disconnected", this.logContext);
      return;
    }
    const v = unpackStreamId(c.id), p = v[0];
    let _ = v[1], k = u.id;
    if (_ && _.startsWith("TR") && (k = _), p === this.localParticipant.sid) {
      this.log.warn("tried to create RemoteParticipant for local participant", this.logContext);
      return;
    }
    const M = Array.from(this.remoteParticipants.values()).find((F) => F.sid === p);
    if (!M) {
      this.log.error("Tried to add a track for a participant, that's not present. Sid: ".concat(p), this.logContext);
      return;
    }
    let L;
    this.options.adaptiveStream && (typeof this.options.adaptiveStream == "object" ? L = this.options.adaptiveStream : L = {}), M.addSubscribedMediaTrack(u, k, c, l, L);
  }
  handleDisconnect() {
    let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0, c = arguments.length > 1 ? arguments[1] : void 0;
    var l;
    if (this.clearConnectionReconcile(), this.isResuming = !1, this.bufferedEvents = [], this.state !== ConnectionState.Disconnected) {
      this.regionUrl = void 0;
      try {
        this.remoteParticipants.forEach((v) => {
          v.trackPublications.forEach((p) => {
            v.unpublishTrack(p.trackSid);
          });
        }), this.localParticipant.trackPublications.forEach((v) => {
          var p, _;
          v.track && this.localParticipant.unpublishTrack(v.track, u), u && ((p = v.track) === null || p === void 0 || p.detach(), (_ = v.track) === null || _ === void 0 || _.stop());
        }), this.localParticipant.off(ParticipantEvent.ParticipantMetadataChanged, this.onLocalParticipantMetadataChanged).off(ParticipantEvent.ParticipantNameChanged, this.onLocalParticipantNameChanged).off(ParticipantEvent.TrackMuted, this.onLocalTrackMuted).off(ParticipantEvent.TrackUnmuted, this.onLocalTrackUnmuted).off(ParticipantEvent.LocalTrackPublished, this.onLocalTrackPublished).off(ParticipantEvent.LocalTrackUnpublished, this.onLocalTrackUnpublished).off(ParticipantEvent.ConnectionQualityChanged, this.onLocalConnectionQualityChanged).off(ParticipantEvent.MediaDevicesError, this.onMediaDevicesError).off(ParticipantEvent.AudioStreamAcquired, this.startAudio).off(ParticipantEvent.ParticipantPermissionsChanged, this.onLocalParticipantPermissionsChanged), this.localParticipant.trackPublications.clear(), this.localParticipant.videoTrackPublications.clear(), this.localParticipant.audioTrackPublications.clear(), this.remoteParticipants.clear(), this.sidToIdentity.clear(), this.activeSpeakers = [], this.audioContext && typeof this.options.webAudioMix == "boolean" && (this.audioContext.close(), this.audioContext = void 0), isWeb() && (window.removeEventListener("beforeunload", this.onPageLeave), window.removeEventListener("pagehide", this.onPageLeave), window.removeEventListener("freeze", this.onPageLeave), (l = navigator.mediaDevices) === null || l === void 0 || l.removeEventListener("devicechange", this.handleDeviceChange));
      } finally {
        this.setAndEmitConnectionState(ConnectionState.Disconnected), this.emit(RoomEvent.Disconnected, c);
      }
    }
  }
  handleParticipantDisconnected(u, c) {
    this.remoteParticipants.delete(u), c && (c.trackPublications.forEach((l) => {
      c.unpublishTrack(l.trackSid, !0);
    }), this.emit(RoomEvent.ParticipantDisconnected, c));
  }
  acquireAudioContext() {
    var u, c;
    return __awaiter$3(this, void 0, void 0, function* () {
      if (typeof this.options.webAudioMix != "boolean" && this.options.webAudioMix.audioContext ? this.audioContext = this.options.webAudioMix.audioContext : (!this.audioContext || this.audioContext.state === "closed") && (this.audioContext = (u = getNewAudioContext()) !== null && u !== void 0 ? u : void 0), this.audioContext && this.audioContext.state === "suspended")
        try {
          yield this.audioContext.resume();
        } catch (v) {
          this.log.warn("Could not resume audio context", Object.assign(Object.assign({}, this.logContext), {
            error: v
          }));
        }
      this.options.webAudioMix && this.remoteParticipants.forEach((v) => v.setAudioContext(this.audioContext)), this.localParticipant.setAudioContext(this.audioContext);
      const l = ((c = this.audioContext) === null || c === void 0 ? void 0 : c.state) === "running";
      l !== this.canPlaybackAudio && (this.audioEnabled = l, this.emit(RoomEvent.AudioPlaybackStatusChanged, l));
    });
  }
  createParticipant(u, c) {
    var l;
    let v;
    return c ? v = RemoteParticipant.fromParticipantInfo(this.engine.client, c) : v = new RemoteParticipant(this.engine.client, "", u, void 0, void 0, {
      loggerContextCb: () => this.logContext,
      loggerName: this.options.loggerName
    }), this.options.webAudioMix && v.setAudioContext(this.audioContext), !((l = this.options.audioOutput) === null || l === void 0) && l.deviceId && v.setAudioOutput(this.options.audioOutput).catch((p) => this.log.warn("Could not set audio output: ".concat(p.message), this.logContext)), v;
  }
  getOrCreateParticipant(u, c) {
    if (this.remoteParticipants.has(u)) {
      const v = this.remoteParticipants.get(u);
      return c && v.updateInfo(c) && this.sidToIdentity.set(c.sid, c.identity), v;
    }
    const l = this.createParticipant(u, c);
    return this.remoteParticipants.set(u, l), this.sidToIdentity.set(c.sid, c.identity), this.emitWhenConnected(RoomEvent.ParticipantConnected, l), l.on(ParticipantEvent.TrackPublished, (v) => {
      this.emitWhenConnected(RoomEvent.TrackPublished, v, l);
    }).on(ParticipantEvent.TrackSubscribed, (v, p) => {
      v.kind === Track.Kind.Audio ? (v.on(TrackEvent.AudioPlaybackStarted, this.handleAudioPlaybackStarted), v.on(TrackEvent.AudioPlaybackFailed, this.handleAudioPlaybackFailed)) : v.kind === Track.Kind.Video && (v.on(TrackEvent.VideoPlaybackFailed, this.handleVideoPlaybackFailed), v.on(TrackEvent.VideoPlaybackStarted, this.handleVideoPlaybackStarted)), this.emit(RoomEvent.TrackSubscribed, v, p, l);
    }).on(ParticipantEvent.TrackUnpublished, (v) => {
      this.emit(RoomEvent.TrackUnpublished, v, l);
    }).on(ParticipantEvent.TrackUnsubscribed, (v, p) => {
      this.emit(RoomEvent.TrackUnsubscribed, v, p, l);
    }).on(ParticipantEvent.TrackSubscriptionFailed, (v) => {
      this.emit(RoomEvent.TrackSubscriptionFailed, v, l);
    }).on(ParticipantEvent.TrackMuted, (v) => {
      this.emitWhenConnected(RoomEvent.TrackMuted, v, l);
    }).on(ParticipantEvent.TrackUnmuted, (v) => {
      this.emitWhenConnected(RoomEvent.TrackUnmuted, v, l);
    }).on(ParticipantEvent.ParticipantMetadataChanged, (v) => {
      this.emitWhenConnected(RoomEvent.ParticipantMetadataChanged, v, l);
    }).on(ParticipantEvent.ParticipantNameChanged, (v) => {
      this.emitWhenConnected(RoomEvent.ParticipantNameChanged, v, l);
    }).on(ParticipantEvent.ConnectionQualityChanged, (v) => {
      this.emitWhenConnected(RoomEvent.ConnectionQualityChanged, v, l);
    }).on(ParticipantEvent.ParticipantPermissionsChanged, (v) => {
      this.emitWhenConnected(RoomEvent.ParticipantPermissionsChanged, v, l);
    }).on(ParticipantEvent.TrackSubscriptionStatusChanged, (v, p) => {
      this.emitWhenConnected(RoomEvent.TrackSubscriptionStatusChanged, v, p, l);
    }).on(ParticipantEvent.TrackSubscriptionFailed, (v, p) => {
      this.emit(RoomEvent.TrackSubscriptionFailed, v, l, p);
    }).on(ParticipantEvent.TrackSubscriptionPermissionChanged, (v, p) => {
      this.emitWhenConnected(RoomEvent.TrackSubscriptionPermissionChanged, v, p, l);
    }), c && l.updateInfo(c), l;
  }
  sendSyncState() {
    const u = Array.from(this.remoteParticipants.values()).reduce((l, v) => (l.push(...v.getTrackPublications()), l), []), c = this.localParticipant.getTrackPublications();
    this.engine.sendSyncState(u, c);
  }
  /**
   * After resuming, we'll need to notify the server of the current
   * subscription settings.
   */
  updateSubscriptions() {
    for (const u of this.remoteParticipants.values())
      for (const c of u.videoTrackPublications.values())
        c.isSubscribed && c instanceof RemoteTrackPublication && c.emitTrackUpdate();
  }
  getRemoteParticipantBySid(u) {
    const c = this.sidToIdentity.get(u);
    if (c)
      return this.remoteParticipants.get(c);
  }
  registerConnectionReconcile() {
    this.clearConnectionReconcile();
    let u = 0;
    this.connectionReconcileInterval = CriticalTimers.setInterval(() => {
      // ensure we didn't tear it down
      !this.engine || // engine detected close, but Room missed it
      this.engine.isClosed || // transports failed without notifying engine
      !this.engine.verifyTransport() ? (u++, this.log.warn("detected connection state mismatch", Object.assign(Object.assign({}, this.logContext), {
        numFailures: u,
        engine: {
          closed: this.engine.isClosed,
          transportsConnected: this.engine.verifyTransport()
        }
      })), u >= 3 && (this.recreateEngine(), this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, DisconnectReason.STATE_MISMATCH))) : u = 0;
    }, connectionReconcileFrequency);
  }
  clearConnectionReconcile() {
    this.connectionReconcileInterval && CriticalTimers.clearInterval(this.connectionReconcileInterval);
  }
  setAndEmitConnectionState(u) {
    return u === this.state ? !1 : (this.state = u, this.emit(RoomEvent.ConnectionStateChanged, this.state), !0);
  }
  emitBufferedEvents() {
    this.bufferedEvents.forEach((u) => {
      let [c, l] = u;
      this.emit(c, ...l);
    }), this.bufferedEvents = [];
  }
  emitWhenConnected(u) {
    for (var c = arguments.length, l = new Array(c > 1 ? c - 1 : 0), v = 1; v < c; v++)
      l[v - 1] = arguments[v];
    if (this.state === ConnectionState.Reconnecting || this.isResuming || !this.engine || this.engine.pendingReconnect)
      this.bufferedEvents.push([u, l]);
    else if (this.state === ConnectionState.Connected)
      return this.emit(u, ...l);
    return !1;
  }
  /**
   * Allows to populate a room with simulated participants.
   * No actual connection to a server will be established, all state is
   * @experimental
   */
  simulateParticipants(u) {
    var c, l;
    return __awaiter$3(this, void 0, void 0, function* () {
      const v = Object.assign({
        audio: !0,
        video: !0,
        useRealTracks: !1
      }, u.publish), p = Object.assign({
        count: 9,
        audio: !1,
        video: !0,
        aspectRatios: [1.66, 1.7, 1.3]
      }, u.participants);
      if (this.handleDisconnect(), this.roomInfo = new Room$1({
        sid: "RM_SIMULATED",
        name: "simulated-room",
        emptyTimeout: 0,
        maxParticipants: 0,
        creationTime: protoInt64.parse((/* @__PURE__ */ new Date()).getTime()),
        metadata: "",
        numParticipants: 1,
        numPublishers: 1,
        turnPassword: "",
        enabledCodecs: [],
        activeRecording: !1
      }), this.localParticipant.updateInfo(new ParticipantInfo({
        identity: "simulated-local",
        name: "local-name"
      })), this.setupLocalParticipantEvents(), this.emit(RoomEvent.SignalConnected), this.emit(RoomEvent.Connected), this.setAndEmitConnectionState(ConnectionState.Connected), v.video) {
        const _ = new LocalTrackPublication(Track.Kind.Video, new TrackInfo({
          source: TrackSource.CAMERA,
          sid: Math.floor(Math.random() * 1e4).toString(),
          type: TrackType.AUDIO,
          name: "video-dummy"
        }), new LocalVideoTrack(v.useRealTracks ? (yield window.navigator.mediaDevices.getUserMedia({
          video: !0
        })).getVideoTracks()[0] : createDummyVideoStreamTrack(160 * ((c = p.aspectRatios[0]) !== null && c !== void 0 ? c : 1), 160, !0, !0), void 0, !1, {
          loggerName: this.options.loggerName,
          loggerContextCb: () => this.logContext
        }), {
          loggerName: this.options.loggerName,
          loggerContextCb: () => this.logContext
        });
        this.localParticipant.addTrackPublication(_), this.localParticipant.emit(ParticipantEvent.LocalTrackPublished, _);
      }
      if (v.audio) {
        const _ = new LocalTrackPublication(Track.Kind.Audio, new TrackInfo({
          source: TrackSource.MICROPHONE,
          sid: Math.floor(Math.random() * 1e4).toString(),
          type: TrackType.AUDIO
        }), new LocalAudioTrack(v.useRealTracks ? (yield navigator.mediaDevices.getUserMedia({
          audio: !0
        })).getAudioTracks()[0] : getEmptyAudioStreamTrack(), void 0, !1, this.audioContext, {
          loggerName: this.options.loggerName,
          loggerContextCb: () => this.logContext
        }), {
          loggerName: this.options.loggerName,
          loggerContextCb: () => this.logContext
        });
        this.localParticipant.addTrackPublication(_), this.localParticipant.emit(ParticipantEvent.LocalTrackPublished, _);
      }
      for (let _ = 0; _ < p.count - 1; _ += 1) {
        let k = new ParticipantInfo({
          sid: Math.floor(Math.random() * 1e4).toString(),
          identity: "simulated-".concat(_),
          state: ParticipantInfo_State.ACTIVE,
          tracks: [],
          joinedAt: protoInt64.parse(Date.now())
        });
        const M = this.getOrCreateParticipant(k.identity, k);
        if (p.video) {
          const L = createDummyVideoStreamTrack(160 * ((l = p.aspectRatios[_ % p.aspectRatios.length]) !== null && l !== void 0 ? l : 1), 160, !1, !0), F = new TrackInfo({
            source: TrackSource.CAMERA,
            sid: Math.floor(Math.random() * 1e4).toString(),
            type: TrackType.AUDIO
          });
          M.addSubscribedMediaTrack(L, F.sid, new MediaStream([L])), k.tracks = [...k.tracks, F];
        }
        if (p.audio) {
          const L = getEmptyAudioStreamTrack(), F = new TrackInfo({
            source: TrackSource.MICROPHONE,
            sid: Math.floor(Math.random() * 1e4).toString(),
            type: TrackType.AUDIO
          });
          M.addSubscribedMediaTrack(L, F.sid, new MediaStream([L])), k.tracks = [...k.tracks, F];
        }
        M.updateInfo(k);
      }
    });
  }
  // /** @internal */
  emit(u) {
    for (var c = arguments.length, l = new Array(c > 1 ? c - 1 : 0), v = 1; v < c; v++)
      l[v - 1] = arguments[v];
    if (u !== RoomEvent.ActiveSpeakersChanged) {
      const p = mapArgs(l).filter((_) => _ !== void 0);
      this.log.debug("room event ".concat(u), Object.assign(Object.assign({}, this.logContext), {
        event: u,
        args: p
      }));
    }
    return super.emit(u, ...l);
  }
}
function mapArgs(a) {
  return a.map((u) => {
    if (u)
      return Array.isArray(u) ? mapArgs(u) : typeof u == "object" ? "logContext" in u && u.logContext : u;
  });
}
var CheckStatus;
(function(a) {
  a[a.IDLE = 0] = "IDLE", a[a.RUNNING = 1] = "RUNNING", a[a.SKIPPED = 2] = "SKIPPED", a[a.SUCCESS = 3] = "SUCCESS", a[a.FAILED = 4] = "FAILED";
})(CheckStatus || (CheckStatus = {}));
class Checker extends eventsExports$1.EventEmitter {
  constructor(u, c) {
    let l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    super(), this.status = CheckStatus.IDLE, this.logs = [], this.errorsAsWarnings = !1, this.url = u, this.token = c, this.name = this.constructor.name, this.room = new Room(l.roomOptions), this.connectOptions = l.connectOptions, l.errorsAsWarnings && (this.errorsAsWarnings = l.errorsAsWarnings);
  }
  run(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (this.status !== CheckStatus.IDLE)
        throw Error("check is running already");
      this.setStatus(CheckStatus.RUNNING);
      try {
        yield this.perform();
      } catch (c) {
        c instanceof Error && (this.errorsAsWarnings ? this.appendWarning(c.message) : this.appendError(c.message));
      }
      return yield this.disconnect(), yield new Promise((c) => setTimeout(c, 500)), this.status !== CheckStatus.SKIPPED && this.setStatus(this.isSuccess() ? CheckStatus.SUCCESS : CheckStatus.FAILED), u && u(), this.getInfo();
    });
  }
  isSuccess() {
    return !this.logs.some((u) => u.level === "error");
  }
  connect() {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this.room.state === ConnectionState.Connected ? this.room : (yield this.room.connect(this.url, this.token), this.room);
    });
  }
  disconnect() {
    return __awaiter$3(this, void 0, void 0, function* () {
      this.room && this.room.state !== ConnectionState.Disconnected && (yield this.room.disconnect(), yield new Promise((u) => setTimeout(u, 500)));
    });
  }
  skip() {
    this.setStatus(CheckStatus.SKIPPED);
  }
  appendMessage(u) {
    this.logs.push({
      level: "info",
      message: u
    }), this.emit("update", this.getInfo());
  }
  appendWarning(u) {
    this.logs.push({
      level: "warning",
      message: u
    }), this.emit("update", this.getInfo());
  }
  appendError(u) {
    this.logs.push({
      level: "error",
      message: u
    }), this.emit("update", this.getInfo());
  }
  setStatus(u) {
    this.status = u, this.emit("update", this.getInfo());
  }
  get engine() {
    var u;
    return (u = this.room) === null || u === void 0 ? void 0 : u.engine;
  }
  getInfo() {
    return {
      logs: this.logs,
      name: this.name,
      status: this.status,
      description: this.description
    };
  }
}
function createLocalTracks(a) {
  var u, c;
  return __awaiter$3(this, void 0, void 0, function* () {
    a ?? (a = {}), (u = a.audio) !== null && u !== void 0 || (a.audio = !0), (c = a.video) !== null && c !== void 0 || (a.video = !0);
    const l = mergeDefaultOptions(a, audioDefaults, videoDefaults), v = constraintsForOptions(l), p = navigator.mediaDevices.getUserMedia(v);
    a.audio && (DeviceManager.userMediaPromiseMap.set("audioinput", p), p.catch(() => DeviceManager.userMediaPromiseMap.delete("audioinput"))), a.video && (DeviceManager.userMediaPromiseMap.set("videoinput", p), p.catch(() => DeviceManager.userMediaPromiseMap.delete("videoinput")));
    const _ = yield p;
    return _.getTracks().map((k) => {
      const M = k.kind === "audio";
      M ? a.audio : a.video;
      let L;
      const F = M ? v.audio : v.video;
      typeof F != "boolean" && (L = F), L ? L.deviceId = k.getSettings().deviceId : L = {
        deviceId: k.getSettings().deviceId
      };
      const V = mediaTrackToLocalTrack(k, L);
      return V.kind === Track.Kind.Video ? V.source = Track.Source.Camera : V.kind === Track.Kind.Audio && (V.source = Track.Source.Microphone), V.mediaStream = _, V;
    });
  });
}
function createLocalVideoTrack(a) {
  return __awaiter$3(this, void 0, void 0, function* () {
    return (yield createLocalTracks({
      audio: !1,
      video: a
    }))[0];
  });
}
function createLocalAudioTrack(a) {
  return __awaiter$3(this, void 0, void 0, function* () {
    return (yield createLocalTracks({
      audio: a,
      video: !1
    }))[0];
  });
}
class PublishAudioCheck extends Checker {
  get description() {
    return "Can publish audio";
  }
  perform() {
    var u;
    return __awaiter$3(this, void 0, void 0, function* () {
      const c = yield this.connect(), l = yield createLocalAudioTrack();
      c.localParticipant.publishTrack(l), yield new Promise((_) => setTimeout(_, 3e3));
      const v = yield (u = l.sender) === null || u === void 0 ? void 0 : u.getStats();
      if (!v)
        throw new Error("Could not get RTCStats");
      let p = 0;
      if (v.forEach((_) => {
        _.type === "outbound-rtp" && _.mediaType === "audio" && (p = _.packetsSent);
      }), p === 0)
        throw new Error("Could not determine packets are sent");
      this.appendMessage("published ".concat(p, " audio packets"));
    });
  }
}
class PublishVideoCheck extends Checker {
  get description() {
    return "Can publish video";
  }
  perform() {
    var u;
    return __awaiter$3(this, void 0, void 0, function* () {
      const c = yield this.connect(), l = yield createLocalVideoTrack();
      c.localParticipant.publishTrack(l), yield new Promise((_) => setTimeout(_, 3e3));
      const v = yield (u = l.sender) === null || u === void 0 ? void 0 : u.getStats();
      if (!v)
        throw new Error("Could not get RTCStats");
      let p = 0;
      if (v.forEach((_) => {
        _.type === "outbound-rtp" && _.mediaType === "video" && (p = _.packetsSent);
      }), p === 0)
        throw new Error("Could not determine packets are sent");
      this.appendMessage("published ".concat(p, " video packets"));
    });
  }
}
class ReconnectCheck extends Checker {
  get description() {
    return "Resuming connection after interruption";
  }
  perform() {
    var u;
    return __awaiter$3(this, void 0, void 0, function* () {
      const c = yield this.connect();
      let l = !1, v = !1, p;
      const _ = new Promise((M) => {
        setTimeout(M, 5e3), p = M;
      });
      c.on(RoomEvent.Reconnecting, () => {
        l = !0;
      }).on(RoomEvent.Reconnected, () => {
        v = !0, p(!0);
      }), (u = c.engine.client.ws) === null || u === void 0 || u.close();
      const k = c.engine.client.onClose;
      if (k && k(""), yield _, l) {
        if (!v || c.state !== ConnectionState.Connected)
          throw this.appendWarning("reconnection is only possible in Redis-based configurations"), new Error("Not able to reconnect");
      } else
        throw new Error("Did not attempt to reconnect");
    });
  }
}
class TURNCheck extends Checker {
  get description() {
    return "Can connect via TURN";
  }
  perform() {
    var u, c;
    return __awaiter$3(this, void 0, void 0, function* () {
      const l = new SignalClient(), v = yield l.join(this.url, this.token, {
        autoSubscribe: !0,
        maxRetries: 0,
        e2eeEnabled: !1,
        websocketTimeout: 15e3
      });
      let p = !1, _ = !1, k = !1;
      for (let M of v.iceServers)
        for (let L of M.urls)
          L.startsWith("turn:") ? (_ = !0, k = !0) : L.startsWith("turns:") && (_ = !0, k = !0, p = !0), L.startsWith("stun:") && (k = !0);
      k ? _ && !p && this.appendWarning("TURN is configured server side, but TURN/TLS is unavailable.") : this.appendWarning("No STUN servers configured on server side."), yield l.close(), !((c = (u = this.connectOptions) === null || u === void 0 ? void 0 : u.rtcConfig) === null || c === void 0) && c.iceServers || _ ? yield this.room.connect(this.url, this.token, {
        rtcConfig: {
          iceTransportPolicy: "relay"
        }
      }) : (this.appendWarning("No TURN servers configured."), this.skip(), yield new Promise((M) => setTimeout(M, 0)));
    });
  }
}
class WebRTCCheck extends Checker {
  get description() {
    return "Establishing WebRTC connection";
  }
  perform() {
    return __awaiter$3(this, void 0, void 0, function* () {
      let u = !1, c = !1;
      this.room.on(RoomEvent.SignalConnected, () => {
        const l = this.room.engine.client.onTrickle;
        this.room.engine.client.onTrickle = (v, p) => {
          if (v.candidate) {
            const _ = new RTCIceCandidate(v);
            let k = "".concat(_.protocol, " ").concat(_.address, ":").concat(_.port, " ").concat(_.type);
            _.address && (isIPPrivate(_.address) ? k += " (private)" : _.protocol === "tcp" && _.tcpType === "passive" ? (u = !0, k += " (passive)") : _.protocol === "udp" && (c = !0)), this.appendMessage(k);
          }
          l && l(v, p);
        }, this.room.engine.pcManager && (this.room.engine.pcManager.subscriber.onIceCandidateError = (v) => {
          v instanceof RTCPeerConnectionIceErrorEvent && this.appendWarning("error with ICE candidate: ".concat(v.errorCode, " ").concat(v.errorText, " ").concat(v.url));
        });
      });
      try {
        yield this.connect(), livekitLogger.info("now the room is connected");
      } catch (l) {
        throw this.appendWarning("ports need to be open on firewall in order to connect."), l;
      }
      u || this.appendWarning("Server is not configured for ICE/TCP"), c || this.appendWarning("No public IPv4 UDP candidates were found. Your server is likely not configured correctly");
    });
  }
}
function isIPPrivate(a) {
  const u = a.split(".");
  if (u.length === 4) {
    if (u[0] === "10")
      return !0;
    if (u[0] === "192" && u[1] === "168")
      return !0;
    if (u[0] === "172") {
      const c = parseInt(u[1], 10);
      if (c >= 16 && c <= 31)
        return !0;
    }
  }
  return !1;
}
class WebSocketCheck extends Checker {
  get description() {
    return "Connecting to signal connection via WebSocket";
  }
  perform() {
    var u, c, l;
    return __awaiter$3(this, void 0, void 0, function* () {
      (this.url.startsWith("ws:") || this.url.startsWith("http:")) && this.appendWarning("Server is insecure, clients may block connections to it");
      let v = new SignalClient();
      const p = yield v.join(this.url, this.token, {
        autoSubscribe: !0,
        maxRetries: 0,
        e2eeEnabled: !1,
        websocketTimeout: 15e3
      });
      this.appendMessage("Connected to server, version ".concat(p.serverVersion, ".")), ((u = p.serverInfo) === null || u === void 0 ? void 0 : u.edition) === ServerInfo_Edition.Cloud && (!((c = p.serverInfo) === null || c === void 0) && c.region) && this.appendMessage("LiveKit Cloud: ".concat((l = p.serverInfo) === null || l === void 0 ? void 0 : l.region)), yield v.close();
    });
  }
}
class ConnectionCheck extends eventsExports$1.EventEmitter {
  constructor(u, c) {
    super(), this.checkResults = /* @__PURE__ */ new Map(), this.url = u, this.token = c;
  }
  getNextCheckId() {
    const u = this.checkResults.size;
    return this.checkResults.set(u, {
      logs: [],
      status: CheckStatus.IDLE,
      name: "",
      description: ""
    }), u;
  }
  updateCheck(u, c) {
    this.checkResults.set(u, c), this.emit("checkUpdate", u, c);
  }
  isSuccess() {
    return Array.from(this.checkResults.values()).every((u) => u.status !== CheckStatus.FAILED);
  }
  getResults() {
    return Array.from(this.checkResults.values());
  }
  createAndRunCheck(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      const c = this.getNextCheckId(), l = new u(this.url, this.token), v = (_) => {
        this.updateCheck(c, _);
      };
      l.on("update", v);
      const p = yield l.run();
      return l.off("update", v), p;
    });
  }
  checkWebsocket() {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this.createAndRunCheck(WebSocketCheck);
    });
  }
  checkWebRTC() {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this.createAndRunCheck(WebRTCCheck);
    });
  }
  checkTURN() {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this.createAndRunCheck(TURNCheck);
    });
  }
  checkReconnect() {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this.createAndRunCheck(ReconnectCheck);
    });
  }
  checkPublishAudio() {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this.createAndRunCheck(PublishAudioCheck);
    });
  }
  checkPublishVideo() {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this.createAndRunCheck(PublishVideoCheck);
    });
  }
}
const Rendering = lib$2.LiveApiModel.Rendering, VideoRendering = lib$2.LiveApiModel.VideoRendering, AudioRendering = lib$2.LiveApiModel.AudioRendering, RenderingQuality = lib$2.LiveApiModel.RenderingQuality, Encoding = lib$2.LiveApiModel.Encoding, VideoEncoding = lib$2.LiveApiModel.VideoEncoding, AudioEncoding = lib$2.LiveApiModel.AudioEncoding, ProjectBroadcastPhase = lib$2.LiveApiModel.ProjectBroadcastPhase, Role = lib$2.LiveApiModel.Role, DestinationAddress = lib$2.LiveApiModel.DestinationAddress, VideoCodec = lib$2.LiveApiModel.VideoCodec, AudioCodec = lib$2.LiveApiModel.AudioCodec, VideoCodecRateControl = lib$2.LiveApiModel.VideoCodecRateControl, VideoCodecProfile = lib$2.LiveApiModel.VideoCodecProfile, types$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AudioCodec,
  AudioEncoding,
  AudioRendering,
  DestinationAddress,
  Encoding,
  ProjectBroadcastPhase,
  Rendering,
  RenderingQuality,
  Role,
  VideoCodec,
  VideoCodecProfile,
  VideoCodecRateControl,
  VideoEncoding,
  VideoRendering
}, Symbol.toStringTag, { value: "Module" }));
var Permission = /* @__PURE__ */ ((a) => (a[a.ReadProject = 0] = "ReadProject", a[a.UpdateProject = 1] = "UpdateProject", a[a.JoinRoom = 2] = "JoinRoom", a[a.InviteGuests = 3] = "InviteGuests", a[a.ManageGuests = 4] = "ManageGuests", a[a.ManageBroadcast = 5] = "ManageBroadcast", a[a.ManageSelf = 6] = "ManageSelf", a))(Permission || {});
const permissions = {
  [Role.ROLE_HOST]: [
    0,
    1,
    2,
    3,
    4,
    5
    /* ManageBroadcast */
  ],
  [Role.ROLE_COHOST]: [
    0,
    1,
    2,
    3,
    4,
    5
    /* ManageBroadcast */
  ],
  [Role.ROLE_CONTRIBUTOR]: [
    0,
    1,
    2,
    3
    /* InviteGuests */
  ],
  [Role.ROLE_GUEST]: [
    0,
    2,
    6
    /* ManageSelf */
  ],
  [Role.ROLE_VIEWER]: [
    0,
    2
    /* JoinRoom */
  ],
  [Role.ROLE_IMPERSONATE]: [
    0,
    1,
    3,
    4,
    5
    /* ManageBroadcast */
  ]
}, hasPermission = (a, u) => {
  var c;
  return a ? !!((c = permissions[a]) != null && c.find((l) => l === u)) : !1;
};
let currentSubId = 0;
const subscribers = /* @__PURE__ */ new Map(), subscribersInternal = /* @__PURE__ */ new Map();
function createSubscribe(a = {}) {
  return function(u) {
    if (typeof u != "function")
      return;
    const c = a.internal ? subscribersInternal : subscribers, l = ++currentSubId;
    return c.set(l, u), () => {
      c.delete(l);
    };
  };
}
function createOn(a = {}) {
  return function(u, c) {
    return (a.internal ? subscribeInternal : subscribe)((v, p) => {
      if (u === v)
        return c(p);
    });
  };
}
function createTrigger(a = {}) {
  const u = a.internal ? subscribersInternal : subscribers;
  return async function(c, ...l) {
    let v = {
      type: c,
      payload: l[0]
    };
    const p = a.internal ? "Internal" : "External";
    log.info(`${p} Event:`, v), await Promise.all(Array.from(u.values()).map((_) => _(v.type, v.payload)));
  };
}
const trigger$1 = createTrigger(), subscribe = createSubscribe(), on = createOn(), triggerInternal$1 = createTrigger({
  internal: !0
}), subscribeInternal = createSubscribe({
  internal: !0
}), onInternal = createOn({
  internal: !0
}), events$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  on,
  onInternal,
  subscribe,
  subscribeInternal,
  trigger: trigger$1,
  triggerInternal: triggerInternal$1
}, Symbol.toStringTag, { value: "Module" }));
var loglevel = { exports: {} };
(function(a) {
  (function(u, c) {
    a.exports ? a.exports = c() : u.log = c();
  })(commonjsGlobal$1, function() {
    var u = function() {
    }, c = "undefined", l = typeof window !== c && typeof window.navigator !== c && /Trident\/|MSIE /.test(window.navigator.userAgent), v = [
      "trace",
      "debug",
      "info",
      "warn",
      "error"
    ], p = {}, _ = null;
    function k(ae, ne) {
      var fe = ae[ne];
      if (typeof fe.bind == "function")
        return fe.bind(ae);
      try {
        return Function.prototype.bind.call(fe, ae);
      } catch {
        return function() {
          return Function.prototype.apply.apply(fe, [ae, arguments]);
        };
      }
    }
    function M() {
      console.log && (console.log.apply ? console.log.apply(console, arguments) : Function.prototype.apply.apply(console.log, [console, arguments])), console.trace && console.trace();
    }
    function L(ae) {
      return ae === "debug" && (ae = "log"), typeof console === c ? !1 : ae === "trace" && l ? M : console[ae] !== void 0 ? k(console, ae) : console.log !== void 0 ? k(console, "log") : u;
    }
    function F() {
      for (var ae = this.getLevel(), ne = 0; ne < v.length; ne++) {
        var fe = v[ne];
        this[fe] = ne < ae ? u : this.methodFactory(fe, ae, this.name);
      }
      if (this.log = this.debug, typeof console === c && ae < this.levels.SILENT)
        return "No console available for logging";
    }
    function V(ae) {
      return function() {
        typeof console !== c && (F.call(this), this[ae].apply(this, arguments));
      };
    }
    function X(ae, ne, fe) {
      return L(ae) || V.apply(this, arguments);
    }
    function oe(ae, ne) {
      var fe = this, ie, ge, be, Ce = "loglevel";
      typeof ae == "string" ? Ce += ":" + ae : typeof ae == "symbol" && (Ce = void 0);
      function Me(P) {
        var S = (v[P] || "silent").toUpperCase();
        if (!(typeof window === c || !Ce)) {
          try {
            window.localStorage[Ce] = S;
            return;
          } catch {
          }
          try {
            window.document.cookie = encodeURIComponent(Ce) + "=" + S + ";";
          } catch {
          }
        }
      }
      function Be() {
        var P;
        if (!(typeof window === c || !Ce)) {
          try {
            P = window.localStorage[Ce];
          } catch {
          }
          if (typeof P === c)
            try {
              var S = window.document.cookie, E = encodeURIComponent(Ce), I = S.indexOf(E + "=");
              I !== -1 && (P = /^([^;]+)/.exec(
                S.slice(I + E.length + 1)
              )[1]);
            } catch {
            }
          return fe.levels[P] === void 0 && (P = void 0), P;
        }
      }
      function Ae() {
        if (!(typeof window === c || !Ce)) {
          try {
            window.localStorage.removeItem(Ce);
          } catch {
          }
          try {
            window.document.cookie = encodeURIComponent(Ce) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
          } catch {
          }
        }
      }
      function Z(P) {
        var S = P;
        if (typeof S == "string" && fe.levels[S.toUpperCase()] !== void 0 && (S = fe.levels[S.toUpperCase()]), typeof S == "number" && S >= 0 && S <= fe.levels.SILENT)
          return S;
        throw new TypeError("log.setLevel() called with invalid level: " + P);
      }
      fe.name = ae, fe.levels = {
        TRACE: 0,
        DEBUG: 1,
        INFO: 2,
        WARN: 3,
        ERROR: 4,
        SILENT: 5
      }, fe.methodFactory = ne || X, fe.getLevel = function() {
        return be ?? ge ?? ie;
      }, fe.setLevel = function(P, S) {
        return be = Z(P), S !== !1 && Me(be), F.call(fe);
      }, fe.setDefaultLevel = function(P) {
        ge = Z(P), Be() || fe.setLevel(P, !1);
      }, fe.resetLevel = function() {
        be = null, Ae(), F.call(fe);
      }, fe.enableAll = function(P) {
        fe.setLevel(fe.levels.TRACE, P);
      }, fe.disableAll = function(P) {
        fe.setLevel(fe.levels.SILENT, P);
      }, fe.rebuild = function() {
        if (_ !== fe && (ie = Z(_.getLevel())), F.call(fe), _ === fe)
          for (var P in p)
            p[P].rebuild();
      }, ie = Z(
        _ ? _.getLevel() : "WARN"
      );
      var z = Be();
      z != null && (be = Z(z)), F.call(fe);
    }
    _ = new oe(), _.getLogger = function(ne) {
      if (typeof ne != "symbol" && typeof ne != "string" || ne === "")
        throw new TypeError("You must supply a name when creating a logger.");
      var fe = p[ne];
      return fe || (fe = p[ne] = new oe(
        ne,
        _.methodFactory
      )), fe;
    };
    var Y = typeof window !== c ? window.log : void 0;
    return _.noConflict = function() {
      return typeof window !== c && window.log === _ && (window.log = Y), _;
    }, _.getLoggers = function() {
      return p;
    }, _.default = _, _;
  });
})(loglevel);
var loglevelExports = loglevel.exports;
const log = /* @__PURE__ */ getDefaultExportFromCjs$2(loglevelExports), connectionId$1 = (Math.random() * 1e20).toString(36), version$2 = "3.0.35", CoreContext = {
  config: null,
  // TODO: Rename to client
  clients: null,
  Request: {},
  Command: {},
  on,
  subscribe,
  /** @private @internal */
  onInternal,
  /** @private @internal */
  subscribeInternal,
  /** @private @internal */
  trigger: trigger$1,
  /** @private @internal */
  triggerInternal: triggerInternal$1,
  /** @private @internal */
  state: {},
  compositor: {},
  connectionId: connectionId$1,
  version: version$2,
  /** @private @internal */
  rendererVersion: version$2,
  log,
  logLevel: null
}, setAppState = (a) => {
  Object.keys(a).forEach((u) => {
    CoreContext.state[u] = a[u];
  });
}, context = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CoreContext,
  default: CoreContext,
  log,
  setAppState
}, Symbol.toStringTag, { value: "Module" }));
var dist = {}, AccessToken$1 = {}, jws$3 = {}, safeBuffer$4 = { exports: {} };
const require$$0$2 = /* @__PURE__ */ getAugmentedNamespace(dist$3);
(function(a, u) {
  var c = require$$0$2, l = c.Buffer;
  function v(_, k) {
    for (var M in _)
      k[M] = _[M];
  }
  l.from && l.alloc && l.allocUnsafe && l.allocUnsafeSlow ? a.exports = c : (v(c, u), u.Buffer = p);
  function p(_, k, M) {
    return l(_, k, M);
  }
  v(l, p), p.from = function(_, k, M) {
    if (typeof _ == "number")
      throw new TypeError("Argument must not be a number");
    return l(_, k, M);
  }, p.alloc = function(_, k, M) {
    if (typeof _ != "number")
      throw new TypeError("Argument must be a number");
    var L = l(_);
    return k !== void 0 ? typeof M == "string" ? L.fill(k, M) : L.fill(k) : L.fill(0), L;
  }, p.allocUnsafe = function(_) {
    if (typeof _ != "number")
      throw new TypeError("Argument must be a number");
    return l(_);
  }, p.allocUnsafeSlow = function(_) {
    if (typeof _ != "number")
      throw new TypeError("Argument must be a number");
    return c.SlowBuffer(_);
  };
})(safeBuffer$4, safeBuffer$4.exports);
var safeBufferExports$3 = safeBuffer$4.exports, events = { exports: {} }, R = typeof Reflect == "object" ? Reflect : null, ReflectApply = R && typeof R.apply == "function" ? R.apply : function a(u, c, l) {
  return Function.prototype.apply.call(u, c, l);
}, ReflectOwnKeys;
R && typeof R.ownKeys == "function" ? ReflectOwnKeys = R.ownKeys : Object.getOwnPropertySymbols ? ReflectOwnKeys = function(u) {
  return Object.getOwnPropertyNames(u).concat(Object.getOwnPropertySymbols(u));
} : ReflectOwnKeys = function(u) {
  return Object.getOwnPropertyNames(u);
};
function ProcessEmitWarning(a) {
  console && console.warn && console.warn(a);
}
var NumberIsNaN = Number.isNaN || function a(u) {
  return u !== u;
};
function EventEmitter() {
  EventEmitter.init.call(this);
}
events.exports = EventEmitter;
events.exports.once = once$6;
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = void 0;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = void 0;
var defaultMaxListeners = 10;
function checkListener(a) {
  if (typeof a != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof a);
}
Object.defineProperty(EventEmitter, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(a) {
    if (typeof a != "number" || a < 0 || NumberIsNaN(a))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + a + ".");
    defaultMaxListeners = a;
  }
});
EventEmitter.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
EventEmitter.prototype.setMaxListeners = function a(u) {
  if (typeof u != "number" || u < 0 || NumberIsNaN(u))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + u + ".");
  return this._maxListeners = u, this;
};
function _getMaxListeners(a) {
  return a._maxListeners === void 0 ? EventEmitter.defaultMaxListeners : a._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function a() {
  return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function a(u) {
  for (var c = [], l = 1; l < arguments.length; l++)
    c.push(arguments[l]);
  var v = u === "error", p = this._events;
  if (p !== void 0)
    v = v && p.error === void 0;
  else if (!v)
    return !1;
  if (v) {
    var _;
    if (c.length > 0 && (_ = c[0]), _ instanceof Error)
      throw _;
    var k = new Error("Unhandled error." + (_ ? " (" + _.message + ")" : ""));
    throw k.context = _, k;
  }
  var M = p[u];
  if (M === void 0)
    return !1;
  if (typeof M == "function")
    ReflectApply(M, this, c);
  else
    for (var L = M.length, F = arrayClone(M, L), l = 0; l < L; ++l)
      ReflectApply(F[l], this, c);
  return !0;
};
function _addListener(a, u, c, l) {
  var v, p, _;
  if (checkListener(c), p = a._events, p === void 0 ? (p = a._events = /* @__PURE__ */ Object.create(null), a._eventsCount = 0) : (p.newListener !== void 0 && (a.emit(
    "newListener",
    u,
    c.listener ? c.listener : c
  ), p = a._events), _ = p[u]), _ === void 0)
    _ = p[u] = c, ++a._eventsCount;
  else if (typeof _ == "function" ? _ = p[u] = l ? [c, _] : [_, c] : l ? _.unshift(c) : _.push(c), v = _getMaxListeners(a), v > 0 && _.length > v && !_.warned) {
    _.warned = !0;
    var k = new Error("Possible EventEmitter memory leak detected. " + _.length + " " + String(u) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    k.name = "MaxListenersExceededWarning", k.emitter = a, k.type = u, k.count = _.length, ProcessEmitWarning(k);
  }
  return a;
}
EventEmitter.prototype.addListener = function a(u, c) {
  return _addListener(this, u, c, !1);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function a(u, c) {
  return _addListener(this, u, c, !0);
};
function onceWrapper() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function _onceWrap(a, u, c) {
  var l = { fired: !1, wrapFn: void 0, target: a, type: u, listener: c }, v = onceWrapper.bind(l);
  return v.listener = c, l.wrapFn = v, v;
}
EventEmitter.prototype.once = function a(u, c) {
  return checkListener(c), this.on(u, _onceWrap(this, u, c)), this;
};
EventEmitter.prototype.prependOnceListener = function a(u, c) {
  return checkListener(c), this.prependListener(u, _onceWrap(this, u, c)), this;
};
EventEmitter.prototype.removeListener = function a(u, c) {
  var l, v, p, _, k;
  if (checkListener(c), v = this._events, v === void 0)
    return this;
  if (l = v[u], l === void 0)
    return this;
  if (l === c || l.listener === c)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete v[u], v.removeListener && this.emit("removeListener", u, l.listener || c));
  else if (typeof l != "function") {
    for (p = -1, _ = l.length - 1; _ >= 0; _--)
      if (l[_] === c || l[_].listener === c) {
        k = l[_].listener, p = _;
        break;
      }
    if (p < 0)
      return this;
    p === 0 ? l.shift() : spliceOne(l, p), l.length === 1 && (v[u] = l[0]), v.removeListener !== void 0 && this.emit("removeListener", u, k || c);
  }
  return this;
};
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function a(u) {
  var c, l, v;
  if (l = this._events, l === void 0)
    return this;
  if (l.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : l[u] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete l[u]), this;
  if (arguments.length === 0) {
    var p = Object.keys(l), _;
    for (v = 0; v < p.length; ++v)
      _ = p[v], _ !== "removeListener" && this.removeAllListeners(_);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (c = l[u], typeof c == "function")
    this.removeListener(u, c);
  else if (c !== void 0)
    for (v = c.length - 1; v >= 0; v--)
      this.removeListener(u, c[v]);
  return this;
};
function _listeners(a, u, c) {
  var l = a._events;
  if (l === void 0)
    return [];
  var v = l[u];
  return v === void 0 ? [] : typeof v == "function" ? c ? [v.listener || v] : [v] : c ? unwrapListeners(v) : arrayClone(v, v.length);
}
EventEmitter.prototype.listeners = function a(u) {
  return _listeners(this, u, !0);
};
EventEmitter.prototype.rawListeners = function a(u) {
  return _listeners(this, u, !1);
};
EventEmitter.listenerCount = function(a, u) {
  return typeof a.listenerCount == "function" ? a.listenerCount(u) : listenerCount.call(a, u);
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(a) {
  var u = this._events;
  if (u !== void 0) {
    var c = u[a];
    if (typeof c == "function")
      return 1;
    if (c !== void 0)
      return c.length;
  }
  return 0;
}
EventEmitter.prototype.eventNames = function a() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone(a, u) {
  for (var c = new Array(u), l = 0; l < u; ++l)
    c[l] = a[l];
  return c;
}
function spliceOne(a, u) {
  for (; u + 1 < a.length; u++)
    a[u] = a[u + 1];
  a.pop();
}
function unwrapListeners(a) {
  for (var u = new Array(a.length), c = 0; c < u.length; ++c)
    u[c] = a[c].listener || a[c];
  return u;
}
function once$6(a, u) {
  return new Promise(function(c, l) {
    function v(_) {
      a.removeListener(u, p), l(_);
    }
    function p() {
      typeof a.removeListener == "function" && a.removeListener("error", v), c([].slice.call(arguments));
    }
    eventTargetAgnosticAddListener(a, u, p, { once: !0 }), u !== "error" && addErrorHandlerIfEventEmitter(a, v, { once: !0 });
  });
}
function addErrorHandlerIfEventEmitter(a, u, c) {
  typeof a.on == "function" && eventTargetAgnosticAddListener(a, "error", u, c);
}
function eventTargetAgnosticAddListener(a, u, c, l) {
  if (typeof a.on == "function")
    l.once ? a.once(u, c) : a.on(u, c);
  else if (typeof a.addEventListener == "function")
    a.addEventListener(u, function v(p) {
      l.once && a.removeEventListener(u, v), c(p);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof a);
}
var eventsExports = events.exports, inherits_browser = { exports: {} };
typeof Object.create == "function" ? inherits_browser.exports = function(u, c) {
  c && (u.super_ = c, u.prototype = Object.create(c.prototype, {
    constructor: {
      value: u,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }));
} : inherits_browser.exports = function(u, c) {
  if (c) {
    u.super_ = c;
    var l = function() {
    };
    l.prototype = c.prototype, u.prototype = new l(), u.prototype.constructor = u;
  }
};
var inherits_browserExports = inherits_browser.exports, streamBrowser$2, hasRequiredStreamBrowser;
function requireStreamBrowser() {
  return hasRequiredStreamBrowser || (hasRequiredStreamBrowser = 1, streamBrowser$2 = eventsExports.EventEmitter), streamBrowser$2;
}
var util$4 = {}, types$1 = {}, shams$1 = function a() {
  if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
    return !1;
  if (typeof Symbol.iterator == "symbol")
    return !0;
  var u = {}, c = Symbol("test"), l = Object(c);
  if (typeof c == "string" || Object.prototype.toString.call(c) !== "[object Symbol]" || Object.prototype.toString.call(l) !== "[object Symbol]")
    return !1;
  var v = 42;
  u[c] = v;
  for (c in u)
    return !1;
  if (typeof Object.keys == "function" && Object.keys(u).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(u).length !== 0)
    return !1;
  var p = Object.getOwnPropertySymbols(u);
  if (p.length !== 1 || p[0] !== c || !Object.prototype.propertyIsEnumerable.call(u, c))
    return !1;
  if (typeof Object.getOwnPropertyDescriptor == "function") {
    var _ = Object.getOwnPropertyDescriptor(u, c);
    if (_.value !== v || _.enumerable !== !0)
      return !1;
  }
  return !0;
}, hasSymbols$2 = shams$1, shams = function a() {
  return hasSymbols$2() && !!Symbol.toStringTag;
}, esErrors = Error, _eval = EvalError, range = RangeError, ref$1 = ReferenceError, syntax = SyntaxError, type = TypeError, uri = URIError, origSymbol = typeof Symbol < "u" && Symbol, hasSymbolSham = shams$1, hasSymbols$1 = function a() {
  return typeof origSymbol != "function" || typeof Symbol != "function" || typeof origSymbol("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : hasSymbolSham();
}, test = {
  foo: {}
}, $Object = Object, hasProto$1 = function a() {
  return { __proto__: test }.foo === test.foo && !({ __proto__: null } instanceof $Object);
}, ERROR_MESSAGE = "Function.prototype.bind called on incompatible ", toStr$3 = Object.prototype.toString, max = Math.max, funcType = "[object Function]", concatty = function a(u, c) {
  for (var l = [], v = 0; v < u.length; v += 1)
    l[v] = u[v];
  for (var p = 0; p < c.length; p += 1)
    l[p + u.length] = c[p];
  return l;
}, slicy = function a(u, c) {
  for (var l = [], v = c || 0, p = 0; v < u.length; v += 1, p += 1)
    l[p] = u[v];
  return l;
}, joiny = function(a, u) {
  for (var c = "", l = 0; l < a.length; l += 1)
    c += a[l], l + 1 < a.length && (c += u);
  return c;
}, implementation$1 = function a(u) {
  var c = this;
  if (typeof c != "function" || toStr$3.apply(c) !== funcType)
    throw new TypeError(ERROR_MESSAGE + c);
  for (var l = slicy(arguments, 1), v, p = function() {
    if (this instanceof v) {
      var F = c.apply(
        this,
        concatty(l, arguments)
      );
      return Object(F) === F ? F : this;
    }
    return c.apply(
      u,
      concatty(l, arguments)
    );
  }, _ = max(0, c.length - l.length), k = [], M = 0; M < _; M++)
    k[M] = "$" + M;
  if (v = Function("binder", "return function (" + joiny(k, ",") + "){ return binder.apply(this,arguments); }")(p), c.prototype) {
    var L = function() {
    };
    L.prototype = c.prototype, v.prototype = new L(), L.prototype = null;
  }
  return v;
}, implementation = implementation$1, functionBind = Function.prototype.bind || implementation, call$2 = Function.prototype.call, $hasOwn = Object.prototype.hasOwnProperty, bind$4 = functionBind, hasown = bind$4.call(call$2, $hasOwn), undefined$1, $Error = esErrors, $EvalError = _eval, $RangeError = range, $ReferenceError = ref$1, $SyntaxError$1 = syntax, $TypeError$2 = type, $URIError = uri, $Function = Function, getEvalledConstructor = function(a) {
  try {
    return $Function('"use strict"; return (' + a + ").constructor;")();
  } catch {
  }
}, $gOPD$1 = Object.getOwnPropertyDescriptor;
if ($gOPD$1)
  try {
    $gOPD$1({}, "");
  } catch {
    $gOPD$1 = null;
  }
var throwTypeError = function() {
  throw new $TypeError$2();
}, ThrowTypeError = $gOPD$1 ? function() {
  try {
    return arguments.callee, throwTypeError;
  } catch {
    try {
      return $gOPD$1(arguments, "callee").get;
    } catch {
      return throwTypeError;
    }
  }
}() : throwTypeError, hasSymbols = hasSymbols$1(), hasProto = hasProto$1(), getProto$1 = Object.getPrototypeOf || (hasProto ? function(a) {
  return a.__proto__;
} : null), needsEval = {}, TypedArray = typeof Uint8Array > "u" || !getProto$1 ? undefined$1 : getProto$1(Uint8Array), INTRINSICS = {
  __proto__: null,
  "%AggregateError%": typeof AggregateError > "u" ? undefined$1 : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer > "u" ? undefined$1 : ArrayBuffer,
  "%ArrayIteratorPrototype%": hasSymbols && getProto$1 ? getProto$1([][Symbol.iterator]()) : undefined$1,
  "%AsyncFromSyncIteratorPrototype%": undefined$1,
  "%AsyncFunction%": needsEval,
  "%AsyncGenerator%": needsEval,
  "%AsyncGeneratorFunction%": needsEval,
  "%AsyncIteratorPrototype%": needsEval,
  "%Atomics%": typeof Atomics > "u" ? undefined$1 : Atomics,
  "%BigInt%": typeof BigInt > "u" ? undefined$1 : BigInt,
  "%BigInt64Array%": typeof BigInt64Array > "u" ? undefined$1 : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array > "u" ? undefined$1 : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView > "u" ? undefined$1 : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": $Error,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": $EvalError,
  "%Float32Array%": typeof Float32Array > "u" ? undefined$1 : Float32Array,
  "%Float64Array%": typeof Float64Array > "u" ? undefined$1 : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? undefined$1 : FinalizationRegistry,
  "%Function%": $Function,
  "%GeneratorFunction%": needsEval,
  "%Int8Array%": typeof Int8Array > "u" ? undefined$1 : Int8Array,
  "%Int16Array%": typeof Int16Array > "u" ? undefined$1 : Int16Array,
  "%Int32Array%": typeof Int32Array > "u" ? undefined$1 : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": hasSymbols && getProto$1 ? getProto$1(getProto$1([][Symbol.iterator]())) : undefined$1,
  "%JSON%": typeof JSON == "object" ? JSON : undefined$1,
  "%Map%": typeof Map > "u" ? undefined$1 : Map,
  "%MapIteratorPrototype%": typeof Map > "u" || !hasSymbols || !getProto$1 ? undefined$1 : getProto$1((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Object,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise > "u" ? undefined$1 : Promise,
  "%Proxy%": typeof Proxy > "u" ? undefined$1 : Proxy,
  "%RangeError%": $RangeError,
  "%ReferenceError%": $ReferenceError,
  "%Reflect%": typeof Reflect > "u" ? undefined$1 : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set > "u" ? undefined$1 : Set,
  "%SetIteratorPrototype%": typeof Set > "u" || !hasSymbols || !getProto$1 ? undefined$1 : getProto$1((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? undefined$1 : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": hasSymbols && getProto$1 ? getProto$1(""[Symbol.iterator]()) : undefined$1,
  "%Symbol%": hasSymbols ? Symbol : undefined$1,
  "%SyntaxError%": $SyntaxError$1,
  "%ThrowTypeError%": ThrowTypeError,
  "%TypedArray%": TypedArray,
  "%TypeError%": $TypeError$2,
  "%Uint8Array%": typeof Uint8Array > "u" ? undefined$1 : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? undefined$1 : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array > "u" ? undefined$1 : Uint16Array,
  "%Uint32Array%": typeof Uint32Array > "u" ? undefined$1 : Uint32Array,
  "%URIError%": $URIError,
  "%WeakMap%": typeof WeakMap > "u" ? undefined$1 : WeakMap,
  "%WeakRef%": typeof WeakRef > "u" ? undefined$1 : WeakRef,
  "%WeakSet%": typeof WeakSet > "u" ? undefined$1 : WeakSet
};
if (getProto$1)
  try {
    null.error;
  } catch (a) {
    var errorProto = getProto$1(getProto$1(a));
    INTRINSICS["%Error.prototype%"] = errorProto;
  }
var doEval = function a(u) {
  var c;
  if (u === "%AsyncFunction%")
    c = getEvalledConstructor("async function () {}");
  else if (u === "%GeneratorFunction%")
    c = getEvalledConstructor("function* () {}");
  else if (u === "%AsyncGeneratorFunction%")
    c = getEvalledConstructor("async function* () {}");
  else if (u === "%AsyncGenerator%") {
    var l = a("%AsyncGeneratorFunction%");
    l && (c = l.prototype);
  } else if (u === "%AsyncIteratorPrototype%") {
    var v = a("%AsyncGenerator%");
    v && getProto$1 && (c = getProto$1(v.prototype));
  }
  return INTRINSICS[u] = c, c;
}, LEGACY_ALIASES = {
  __proto__: null,
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
}, bind$3 = functionBind, hasOwn = hasown, $concat = bind$3.call(Function.call, Array.prototype.concat), $spliceApply = bind$3.call(Function.apply, Array.prototype.splice), $replace = bind$3.call(Function.call, String.prototype.replace), $strSlice = bind$3.call(Function.call, String.prototype.slice), $exec = bind$3.call(Function.call, RegExp.prototype.exec), rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, reEscapeChar = /\\(\\)?/g, stringToPath = function a(u) {
  var c = $strSlice(u, 0, 1), l = $strSlice(u, -1);
  if (c === "%" && l !== "%")
    throw new $SyntaxError$1("invalid intrinsic syntax, expected closing `%`");
  if (l === "%" && c !== "%")
    throw new $SyntaxError$1("invalid intrinsic syntax, expected opening `%`");
  var v = [];
  return $replace(u, rePropName, function(p, _, k, M) {
    v[v.length] = k ? $replace(M, reEscapeChar, "$1") : _ || p;
  }), v;
}, getBaseIntrinsic = function a(u, c) {
  var l = u, v;
  if (hasOwn(LEGACY_ALIASES, l) && (v = LEGACY_ALIASES[l], l = "%" + v[0] + "%"), hasOwn(INTRINSICS, l)) {
    var p = INTRINSICS[l];
    if (p === needsEval && (p = doEval(l)), typeof p > "u" && !c)
      throw new $TypeError$2("intrinsic " + u + " exists, but is not available. Please file an issue!");
    return {
      alias: v,
      name: l,
      value: p
    };
  }
  throw new $SyntaxError$1("intrinsic " + u + " does not exist!");
}, getIntrinsic = function a(u, c) {
  if (typeof u != "string" || u.length === 0)
    throw new $TypeError$2("intrinsic name must be a non-empty string");
  if (arguments.length > 1 && typeof c != "boolean")
    throw new $TypeError$2('"allowMissing" argument must be a boolean');
  if ($exec(/^%?[^%]*%?$/, u) === null)
    throw new $SyntaxError$1("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  var l = stringToPath(u), v = l.length > 0 ? l[0] : "", p = getBaseIntrinsic("%" + v + "%", c), _ = p.name, k = p.value, M = !1, L = p.alias;
  L && (v = L[0], $spliceApply(l, $concat([0, 1], L)));
  for (var F = 1, V = !0; F < l.length; F += 1) {
    var X = l[F], oe = $strSlice(X, 0, 1), Y = $strSlice(X, -1);
    if ((oe === '"' || oe === "'" || oe === "`" || Y === '"' || Y === "'" || Y === "`") && oe !== Y)
      throw new $SyntaxError$1("property names with quotes must have matching quotes");
    if ((X === "constructor" || !V) && (M = !0), v += "." + X, _ = "%" + v + "%", hasOwn(INTRINSICS, _))
      k = INTRINSICS[_];
    else if (k != null) {
      if (!(X in k)) {
        if (!c)
          throw new $TypeError$2("base intrinsic for " + u + " exists, but the property is not available.");
        return;
      }
      if ($gOPD$1 && F + 1 >= l.length) {
        var ae = $gOPD$1(k, X);
        V = !!ae, V && "get" in ae && !("originalValue" in ae.get) ? k = ae.get : k = k[X];
      } else
        V = hasOwn(k, X), k = k[X];
      V && !M && (INTRINSICS[_] = k);
    }
  }
  return k;
}, callBind$2 = { exports: {} }, esDefineProperty, hasRequiredEsDefineProperty;
function requireEsDefineProperty() {
  if (hasRequiredEsDefineProperty)
    return esDefineProperty;
  hasRequiredEsDefineProperty = 1;
  var a = getIntrinsic, u = a("%Object.defineProperty%", !0) || !1;
  if (u)
    try {
      u({}, "a", { value: 1 });
    } catch {
      u = !1;
    }
  return esDefineProperty = u, esDefineProperty;
}
var GetIntrinsic$2 = getIntrinsic, $gOPD = GetIntrinsic$2("%Object.getOwnPropertyDescriptor%", !0);
if ($gOPD)
  try {
    $gOPD([], "length");
  } catch {
    $gOPD = null;
  }
var gopd$1 = $gOPD, $defineProperty$1 = requireEsDefineProperty(), $SyntaxError = syntax, $TypeError$1 = type, gopd = gopd$1, defineDataProperty = function a(u, c, l) {
  if (!u || typeof u != "object" && typeof u != "function")
    throw new $TypeError$1("`obj` must be an object or a function`");
  if (typeof c != "string" && typeof c != "symbol")
    throw new $TypeError$1("`property` must be a string or a symbol`");
  if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
    throw new $TypeError$1("`nonEnumerable`, if provided, must be a boolean or null");
  if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
    throw new $TypeError$1("`nonWritable`, if provided, must be a boolean or null");
  if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
    throw new $TypeError$1("`nonConfigurable`, if provided, must be a boolean or null");
  if (arguments.length > 6 && typeof arguments[6] != "boolean")
    throw new $TypeError$1("`loose`, if provided, must be a boolean");
  var v = arguments.length > 3 ? arguments[3] : null, p = arguments.length > 4 ? arguments[4] : null, _ = arguments.length > 5 ? arguments[5] : null, k = arguments.length > 6 ? arguments[6] : !1, M = !!gopd && gopd(u, c);
  if ($defineProperty$1)
    $defineProperty$1(u, c, {
      configurable: _ === null && M ? M.configurable : !_,
      enumerable: v === null && M ? M.enumerable : !v,
      value: l,
      writable: p === null && M ? M.writable : !p
    });
  else if (k || !v && !p && !_)
    u[c] = l;
  else
    throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
}, $defineProperty = requireEsDefineProperty(), hasPropertyDescriptors = function a() {
  return !!$defineProperty;
};
hasPropertyDescriptors.hasArrayLengthDefineBug = function a() {
  if (!$defineProperty)
    return null;
  try {
    return $defineProperty([], "length", { value: 1 }).length !== 1;
  } catch {
    return !0;
  }
};
var hasPropertyDescriptors_1 = hasPropertyDescriptors, GetIntrinsic$1 = getIntrinsic, define = defineDataProperty, hasDescriptors = hasPropertyDescriptors_1(), gOPD$1 = gopd$1, $TypeError = type, $floor = GetIntrinsic$1("%Math.floor%"), setFunctionLength = function a(u, c) {
  if (typeof u != "function")
    throw new $TypeError("`fn` is not a function");
  if (typeof c != "number" || c < 0 || c > 4294967295 || $floor(c) !== c)
    throw new $TypeError("`length` must be a positive 32-bit integer");
  var l = arguments.length > 2 && !!arguments[2], v = !0, p = !0;
  if ("length" in u && gOPD$1) {
    var _ = gOPD$1(u, "length");
    _ && !_.configurable && (v = !1), _ && !_.writable && (p = !1);
  }
  return (v || p || !l) && (hasDescriptors ? define(
    /** @type {Parameters<define>[0]} */
    u,
    "length",
    c,
    !0,
    !0
  ) : define(
    /** @type {Parameters<define>[0]} */
    u,
    "length",
    c
  )), u;
};
(function(a) {
  var u = functionBind, c = getIntrinsic, l = setFunctionLength, v = type, p = c("%Function.prototype.apply%"), _ = c("%Function.prototype.call%"), k = c("%Reflect.apply%", !0) || u.call(_, p), M = requireEsDefineProperty(), L = c("%Math.max%");
  a.exports = function(X) {
    if (typeof X != "function")
      throw new v("a function is required");
    var oe = k(u, _, arguments);
    return l(
      oe,
      1 + L(0, X.length - (arguments.length - 1)),
      !0
    );
  };
  var F = function() {
    return k(u, p, arguments);
  };
  M ? M(a.exports, "apply", { value: F }) : a.exports.apply = F;
})(callBind$2);
var callBindExports = callBind$2.exports, GetIntrinsic = getIntrinsic, callBind$1 = callBindExports, $indexOf$1 = callBind$1(GetIntrinsic("String.prototype.indexOf")), callBound$2 = function a(u, c) {
  var l = GetIntrinsic(u, !!c);
  return typeof l == "function" && $indexOf$1(u, ".prototype.") > -1 ? callBind$1(l) : l;
}, hasToStringTag$3 = shams(), callBound$1 = callBound$2, $toString$1 = callBound$1("Object.prototype.toString"), isStandardArguments = function a(u) {
  return hasToStringTag$3 && u && typeof u == "object" && Symbol.toStringTag in u ? !1 : $toString$1(u) === "[object Arguments]";
}, isLegacyArguments = function a(u) {
  return isStandardArguments(u) ? !0 : u !== null && typeof u == "object" && typeof u.length == "number" && u.length >= 0 && $toString$1(u) !== "[object Array]" && $toString$1(u.callee) === "[object Function]";
}, supportsStandardArguments = function() {
  return isStandardArguments(arguments);
}();
isStandardArguments.isLegacyArguments = isLegacyArguments;
var isArguments$1 = supportsStandardArguments ? isStandardArguments : isLegacyArguments, toStr$2 = Object.prototype.toString, fnToStr$1 = Function.prototype.toString, isFnRegex = /^\s*(?:function)?\*/, hasToStringTag$2 = shams(), getProto = Object.getPrototypeOf, getGeneratorFunc = function() {
  if (!hasToStringTag$2)
    return !1;
  try {
    return Function("return function*() {}")();
  } catch {
  }
}, GeneratorFunction, isGeneratorFunction = function a(u) {
  if (typeof u != "function")
    return !1;
  if (isFnRegex.test(fnToStr$1.call(u)))
    return !0;
  if (!hasToStringTag$2) {
    var c = toStr$2.call(u);
    return c === "[object GeneratorFunction]";
  }
  if (!getProto)
    return !1;
  if (typeof GeneratorFunction > "u") {
    var l = getGeneratorFunc();
    GeneratorFunction = l ? getProto(l) : !1;
  }
  return getProto(u) === GeneratorFunction;
}, fnToStr = Function.prototype.toString, reflectApply = typeof Reflect == "object" && Reflect !== null && Reflect.apply, badArrayLike, isCallableMarker;
if (typeof reflectApply == "function" && typeof Object.defineProperty == "function")
  try {
    badArrayLike = Object.defineProperty({}, "length", {
      get: function() {
        throw isCallableMarker;
      }
    }), isCallableMarker = {}, reflectApply(function() {
      throw 42;
    }, null, badArrayLike);
  } catch (a) {
    a !== isCallableMarker && (reflectApply = null);
  }
else
  reflectApply = null;
var constructorRegex = /^\s*class\b/, isES6ClassFn = function a(u) {
  try {
    var c = fnToStr.call(u);
    return constructorRegex.test(c);
  } catch {
    return !1;
  }
}, tryFunctionObject = function a(u) {
  try {
    return isES6ClassFn(u) ? !1 : (fnToStr.call(u), !0);
  } catch {
    return !1;
  }
}, toStr$1 = Object.prototype.toString, fnClass = "[object Function]", genClass = "[object GeneratorFunction]", hasToStringTag$1 = typeof Symbol == "function" && !!Symbol.toStringTag, documentDotAll = typeof document == "object" && typeof document.all > "u" && document.all !== void 0 ? document.all : {}, isCallable$1 = reflectApply ? function a(u) {
  if (u === documentDotAll)
    return !0;
  if (!u || typeof u != "function" && typeof u != "object")
    return !1;
  if (typeof u == "function" && !u.prototype)
    return !0;
  try {
    reflectApply(u, null, badArrayLike);
  } catch (c) {
    if (c !== isCallableMarker)
      return !1;
  }
  return !isES6ClassFn(u);
} : function a(u) {
  if (u === documentDotAll)
    return !0;
  if (!u || typeof u != "function" && typeof u != "object")
    return !1;
  if (typeof u == "function" && !u.prototype)
    return !0;
  if (hasToStringTag$1)
    return tryFunctionObject(u);
  if (isES6ClassFn(u))
    return !1;
  var c = toStr$1.call(u);
  return c === fnClass || c === genClass;
}, isCallable = isCallable$1, toStr = Object.prototype.toString, hasOwnProperty$2 = Object.prototype.hasOwnProperty, forEachArray = function a(u, c, l) {
  for (var v = 0, p = u.length; v < p; v++)
    hasOwnProperty$2.call(u, v) && (l == null ? c(u[v], v, u) : c.call(l, u[v], v, u));
}, forEachString = function a(u, c, l) {
  for (var v = 0, p = u.length; v < p; v++)
    l == null ? c(u.charAt(v), v, u) : c.call(l, u.charAt(v), v, u);
}, forEachObject = function a(u, c, l) {
  for (var v in u)
    hasOwnProperty$2.call(u, v) && (l == null ? c(u[v], v, u) : c.call(l, u[v], v, u));
}, forEach$2 = function a(u, c, l) {
  if (!isCallable(c))
    throw new TypeError("iterator must be a function");
  var v;
  arguments.length >= 3 && (v = l), toStr.call(u) === "[object Array]" ? forEachArray(u, c, v) : typeof u == "string" ? forEachString(u, c, v) : forEachObject(u, c, v);
}, forEach_1 = forEach$2, possibleNames = [
  "BigInt64Array",
  "BigUint64Array",
  "Float32Array",
  "Float64Array",
  "Int16Array",
  "Int32Array",
  "Int8Array",
  "Uint16Array",
  "Uint32Array",
  "Uint8Array",
  "Uint8ClampedArray"
], g$1 = typeof globalThis > "u" ? commonjsGlobal$1 : globalThis, availableTypedArrays$1 = function a() {
  for (var u = [], c = 0; c < possibleNames.length; c++)
    typeof g$1[possibleNames[c]] == "function" && (u[u.length] = possibleNames[c]);
  return u;
}, forEach$1 = forEach_1, availableTypedArrays = availableTypedArrays$1, callBind = callBindExports, callBound = callBound$2, gOPD = gopd$1, $toString = callBound("Object.prototype.toString"), hasToStringTag = shams(), g = typeof globalThis > "u" ? commonjsGlobal$1 : globalThis, typedArrays = availableTypedArrays(), $slice = callBound("String.prototype.slice"), getPrototypeOf = Object.getPrototypeOf, $indexOf = callBound("Array.prototype.indexOf", !0) || /** @type {(array: readonly unknown[], value: unknown) => keyof array} */
function a(u, c) {
  for (var l = 0; l < u.length; l += 1)
    if (u[l] === c)
      return l;
  return -1;
}, cache$2 = { __proto__: null };
hasToStringTag && gOPD && getPrototypeOf ? forEach$1(typedArrays, function(a) {
  var u = new g[a]();
  if (Symbol.toStringTag in u) {
    var c = getPrototypeOf(u), l = gOPD(c, Symbol.toStringTag);
    if (!l) {
      var v = getPrototypeOf(c);
      l = gOPD(v, Symbol.toStringTag);
    }
    cache$2["$" + a] = callBind(l.get);
  }
}) : forEach$1(typedArrays, function(a) {
  var u = new g[a](), c = u.slice || u.set;
  c && (cache$2["$" + a] = callBind(c));
});
var tryTypedArrays = function a(u) {
  var c = !1;
  return forEach$1(
    // eslint-disable-next-line no-extra-parens
    /** @type {Record<`\$${TypedArrayName}`, typeof cache>} */
    /** @type {any} */
    cache$2,
    /** @type {(getter: typeof cache, name: `\$${TypedArrayName}`) => void} */
    function(l, v) {
      if (!c)
        try {
          "$" + l(u) === v && (c = $slice(v, 1));
        } catch {
        }
    }
  ), c;
}, trySlices = function a(u) {
  var c = !1;
  return forEach$1(
    // eslint-disable-next-line no-extra-parens
    /** @type {any} */
    cache$2,
    /** @type {(getter: typeof cache, name: `\$${TypedArrayName}`) => void} */
    function(l, v) {
      if (!c)
        try {
          l(u), c = $slice(v, 1);
        } catch {
        }
    }
  ), c;
}, whichTypedArray$1 = function a(u) {
  if (!u || typeof u != "object")
    return !1;
  if (!hasToStringTag) {
    var c = $slice($toString(u), 8, -1);
    return $indexOf(typedArrays, c) > -1 ? c : c !== "Object" ? !1 : trySlices(u);
  }
  return gOPD ? tryTypedArrays(u) : null;
}, whichTypedArray = whichTypedArray$1, isTypedArray = function a(u) {
  return !!whichTypedArray(u);
};
(function(a) {
  var u = isArguments$1, c = isGeneratorFunction, l = whichTypedArray$1, v = isTypedArray;
  function p(qe) {
    return qe.call.bind(qe);
  }
  var _ = typeof BigInt < "u", k = typeof Symbol < "u", M = p(Object.prototype.toString), L = p(Number.prototype.valueOf), F = p(String.prototype.valueOf), V = p(Boolean.prototype.valueOf);
  if (_)
    var X = p(BigInt.prototype.valueOf);
  if (k)
    var oe = p(Symbol.prototype.valueOf);
  function Y(qe, gt) {
    if (typeof qe != "object")
      return !1;
    try {
      return gt(qe), !0;
    } catch {
      return !1;
    }
  }
  a.isArgumentsObject = u, a.isGeneratorFunction = c, a.isTypedArray = v;
  function ae(qe) {
    return typeof Promise < "u" && qe instanceof Promise || qe !== null && typeof qe == "object" && typeof qe.then == "function" && typeof qe.catch == "function";
  }
  a.isPromise = ae;
  function ne(qe) {
    return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(qe) : v(qe) || pe(qe);
  }
  a.isArrayBufferView = ne;
  function fe(qe) {
    return l(qe) === "Uint8Array";
  }
  a.isUint8Array = fe;
  function ie(qe) {
    return l(qe) === "Uint8ClampedArray";
  }
  a.isUint8ClampedArray = ie;
  function ge(qe) {
    return l(qe) === "Uint16Array";
  }
  a.isUint16Array = ge;
  function be(qe) {
    return l(qe) === "Uint32Array";
  }
  a.isUint32Array = be;
  function Ce(qe) {
    return l(qe) === "Int8Array";
  }
  a.isInt8Array = Ce;
  function Me(qe) {
    return l(qe) === "Int16Array";
  }
  a.isInt16Array = Me;
  function Be(qe) {
    return l(qe) === "Int32Array";
  }
  a.isInt32Array = Be;
  function Ae(qe) {
    return l(qe) === "Float32Array";
  }
  a.isFloat32Array = Ae;
  function Z(qe) {
    return l(qe) === "Float64Array";
  }
  a.isFloat64Array = Z;
  function z(qe) {
    return l(qe) === "BigInt64Array";
  }
  a.isBigInt64Array = z;
  function P(qe) {
    return l(qe) === "BigUint64Array";
  }
  a.isBigUint64Array = P;
  function S(qe) {
    return M(qe) === "[object Map]";
  }
  S.working = typeof Map < "u" && S(/* @__PURE__ */ new Map());
  function E(qe) {
    return typeof Map > "u" ? !1 : S.working ? S(qe) : qe instanceof Map;
  }
  a.isMap = E;
  function I(qe) {
    return M(qe) === "[object Set]";
  }
  I.working = typeof Set < "u" && I(/* @__PURE__ */ new Set());
  function N(qe) {
    return typeof Set > "u" ? !1 : I.working ? I(qe) : qe instanceof Set;
  }
  a.isSet = N;
  function $(qe) {
    return M(qe) === "[object WeakMap]";
  }
  $.working = typeof WeakMap < "u" && $(/* @__PURE__ */ new WeakMap());
  function U(qe) {
    return typeof WeakMap > "u" ? !1 : $.working ? $(qe) : qe instanceof WeakMap;
  }
  a.isWeakMap = U;
  function H(qe) {
    return M(qe) === "[object WeakSet]";
  }
  H.working = typeof WeakSet < "u" && H(/* @__PURE__ */ new WeakSet());
  function B(qe) {
    return H(qe);
  }
  a.isWeakSet = B;
  function T(qe) {
    return M(qe) === "[object ArrayBuffer]";
  }
  T.working = typeof ArrayBuffer < "u" && T(new ArrayBuffer());
  function D(qe) {
    return typeof ArrayBuffer > "u" ? !1 : T.working ? T(qe) : qe instanceof ArrayBuffer;
  }
  a.isArrayBuffer = D;
  function ee(qe) {
    return M(qe) === "[object DataView]";
  }
  ee.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && ee(new DataView(new ArrayBuffer(1), 0, 1));
  function pe(qe) {
    return typeof DataView > "u" ? !1 : ee.working ? ee(qe) : qe instanceof DataView;
  }
  a.isDataView = pe;
  var Ie = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
  function Pe(qe) {
    return M(qe) === "[object SharedArrayBuffer]";
  }
  function he(qe) {
    return typeof Ie > "u" ? !1 : (typeof Pe.working > "u" && (Pe.working = Pe(new Ie())), Pe.working ? Pe(qe) : qe instanceof Ie);
  }
  a.isSharedArrayBuffer = he;
  function ve(qe) {
    return M(qe) === "[object AsyncFunction]";
  }
  a.isAsyncFunction = ve;
  function Q(qe) {
    return M(qe) === "[object Map Iterator]";
  }
  a.isMapIterator = Q;
  function le(qe) {
    return M(qe) === "[object Set Iterator]";
  }
  a.isSetIterator = le;
  function _e(qe) {
    return M(qe) === "[object Generator]";
  }
  a.isGeneratorObject = _e;
  function re(qe) {
    return M(qe) === "[object WebAssembly.Module]";
  }
  a.isWebAssemblyCompiledModule = re;
  function O(qe) {
    return Y(qe, L);
  }
  a.isNumberObject = O;
  function j(qe) {
    return Y(qe, F);
  }
  a.isStringObject = j;
  function ce(qe) {
    return Y(qe, V);
  }
  a.isBooleanObject = ce;
  function De(qe) {
    return _ && Y(qe, X);
  }
  a.isBigIntObject = De;
  function Ne(qe) {
    return k && Y(qe, oe);
  }
  a.isSymbolObject = Ne;
  function Fe(qe) {
    return O(qe) || j(qe) || ce(qe) || De(qe) || Ne(qe);
  }
  a.isBoxedPrimitive = Fe;
  function Ze(qe) {
    return typeof Uint8Array < "u" && (D(qe) || he(qe));
  }
  a.isAnyArrayBuffer = Ze, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(qe) {
    Object.defineProperty(a, qe, {
      enumerable: !1,
      value: function() {
        throw new Error(qe + " is not supported in userland");
      }
    });
  });
})(types$1);
var isBufferBrowser = function a(u) {
  return u && typeof u == "object" && typeof u.copy == "function" && typeof u.fill == "function" && typeof u.readUInt8 == "function";
};
(function(a) {
  var u = Object.getOwnPropertyDescriptors || function(pe) {
    for (var Ie = Object.keys(pe), Pe = {}, he = 0; he < Ie.length; he++)
      Pe[Ie[he]] = Object.getOwnPropertyDescriptor(pe, Ie[he]);
    return Pe;
  }, c = /%[sdj%]/g;
  a.format = function(ee) {
    if (!Ce(ee)) {
      for (var pe = [], Ie = 0; Ie < arguments.length; Ie++)
        pe.push(_(arguments[Ie]));
      return pe.join(" ");
    }
    for (var Ie = 1, Pe = arguments, he = Pe.length, ve = String(ee).replace(c, function(le) {
      if (le === "%%")
        return "%";
      if (Ie >= he)
        return le;
      switch (le) {
        case "%s":
          return String(Pe[Ie++]);
        case "%d":
          return Number(Pe[Ie++]);
        case "%j":
          try {
            return JSON.stringify(Pe[Ie++]);
          } catch {
            return "[Circular]";
          }
        default:
          return le;
      }
    }), Q = Pe[Ie]; Ie < he; Q = Pe[++Ie])
      ie(Q) || !Z(Q) ? ve += " " + Q : ve += " " + _(Q);
    return ve;
  }, a.deprecate = function(ee, pe) {
    if (typeof process$1 < "u" && process$1.noDeprecation === !0)
      return ee;
    if (typeof process$1 > "u")
      return function() {
        return a.deprecate(ee, pe).apply(this, arguments);
      };
    var Ie = !1;
    function Pe() {
      if (!Ie) {
        if (process$1.throwDeprecation)
          throw new Error(pe);
        process$1.traceDeprecation ? console.trace(pe) : console.error(pe), Ie = !0;
      }
      return ee.apply(this, arguments);
    }
    return Pe;
  };
  var l = {}, v = /^$/;
  if (process$1.env.NODE_DEBUG) {
    var p = process$1.env.NODE_DEBUG;
    p = p.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), v = new RegExp("^" + p + "$", "i");
  }
  a.debuglog = function(ee) {
    if (ee = ee.toUpperCase(), !l[ee])
      if (v.test(ee)) {
        var pe = process$1.pid;
        l[ee] = function() {
          var Ie = a.format.apply(a, arguments);
          console.error("%s %d: %s", ee, pe, Ie);
        };
      } else
        l[ee] = function() {
        };
    return l[ee];
  };
  function _(ee, pe) {
    var Ie = {
      seen: [],
      stylize: M
    };
    return arguments.length >= 3 && (Ie.depth = arguments[2]), arguments.length >= 4 && (Ie.colors = arguments[3]), fe(pe) ? Ie.showHidden = pe : pe && a._extend(Ie, pe), Be(Ie.showHidden) && (Ie.showHidden = !1), Be(Ie.depth) && (Ie.depth = 2), Be(Ie.colors) && (Ie.colors = !1), Be(Ie.customInspect) && (Ie.customInspect = !0), Ie.colors && (Ie.stylize = k), F(Ie, ee, Ie.depth);
  }
  a.inspect = _, _.colors = {
    bold: [1, 22],
    italic: [3, 23],
    underline: [4, 24],
    inverse: [7, 27],
    white: [37, 39],
    grey: [90, 39],
    black: [30, 39],
    blue: [34, 39],
    cyan: [36, 39],
    green: [32, 39],
    magenta: [35, 39],
    red: [31, 39],
    yellow: [33, 39]
  }, _.styles = {
    special: "cyan",
    number: "yellow",
    boolean: "yellow",
    undefined: "grey",
    null: "bold",
    string: "green",
    date: "magenta",
    // "name": intentionally not styling
    regexp: "red"
  };
  function k(ee, pe) {
    var Ie = _.styles[pe];
    return Ie ? "\x1B[" + _.colors[Ie][0] + "m" + ee + "\x1B[" + _.colors[Ie][1] + "m" : ee;
  }
  function M(ee, pe) {
    return ee;
  }
  function L(ee) {
    var pe = {};
    return ee.forEach(function(Ie, Pe) {
      pe[Ie] = !0;
    }), pe;
  }
  function F(ee, pe, Ie) {
    if (ee.customInspect && pe && S(pe.inspect) && // Filter out the util module, it's inspect function is special
    pe.inspect !== a.inspect && // Also filter out any prototype objects using the circular check.
    !(pe.constructor && pe.constructor.prototype === pe)) {
      var Pe = pe.inspect(Ie, ee);
      return Ce(Pe) || (Pe = F(ee, Pe, Ie)), Pe;
    }
    var he = V(ee, pe);
    if (he)
      return he;
    var ve = Object.keys(pe), Q = L(ve);
    if (ee.showHidden && (ve = Object.getOwnPropertyNames(pe)), P(pe) && (ve.indexOf("message") >= 0 || ve.indexOf("description") >= 0))
      return X(pe);
    if (ve.length === 0) {
      if (S(pe)) {
        var le = pe.name ? ": " + pe.name : "";
        return ee.stylize("[Function" + le + "]", "special");
      }
      if (Ae(pe))
        return ee.stylize(RegExp.prototype.toString.call(pe), "regexp");
      if (z(pe))
        return ee.stylize(Date.prototype.toString.call(pe), "date");
      if (P(pe))
        return X(pe);
    }
    var _e = "", re = !1, O = ["{", "}"];
    if (ne(pe) && (re = !0, O = ["[", "]"]), S(pe)) {
      var j = pe.name ? ": " + pe.name : "";
      _e = " [Function" + j + "]";
    }
    if (Ae(pe) && (_e = " " + RegExp.prototype.toString.call(pe)), z(pe) && (_e = " " + Date.prototype.toUTCString.call(pe)), P(pe) && (_e = " " + X(pe)), ve.length === 0 && (!re || pe.length == 0))
      return O[0] + _e + O[1];
    if (Ie < 0)
      return Ae(pe) ? ee.stylize(RegExp.prototype.toString.call(pe), "regexp") : ee.stylize("[Object]", "special");
    ee.seen.push(pe);
    var ce;
    return re ? ce = oe(ee, pe, Ie, Q, ve) : ce = ve.map(function(De) {
      return Y(ee, pe, Ie, Q, De, re);
    }), ee.seen.pop(), ae(ce, _e, O);
  }
  function V(ee, pe) {
    if (Be(pe))
      return ee.stylize("undefined", "undefined");
    if (Ce(pe)) {
      var Ie = "'" + JSON.stringify(pe).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return ee.stylize(Ie, "string");
    }
    if (be(pe))
      return ee.stylize("" + pe, "number");
    if (fe(pe))
      return ee.stylize("" + pe, "boolean");
    if (ie(pe))
      return ee.stylize("null", "null");
  }
  function X(ee) {
    return "[" + Error.prototype.toString.call(ee) + "]";
  }
  function oe(ee, pe, Ie, Pe, he) {
    for (var ve = [], Q = 0, le = pe.length; Q < le; ++Q)
      H(pe, String(Q)) ? ve.push(Y(
        ee,
        pe,
        Ie,
        Pe,
        String(Q),
        !0
      )) : ve.push("");
    return he.forEach(function(_e) {
      _e.match(/^\d+$/) || ve.push(Y(
        ee,
        pe,
        Ie,
        Pe,
        _e,
        !0
      ));
    }), ve;
  }
  function Y(ee, pe, Ie, Pe, he, ve) {
    var Q, le, _e;
    if (_e = Object.getOwnPropertyDescriptor(pe, he) || { value: pe[he] }, _e.get ? _e.set ? le = ee.stylize("[Getter/Setter]", "special") : le = ee.stylize("[Getter]", "special") : _e.set && (le = ee.stylize("[Setter]", "special")), H(Pe, he) || (Q = "[" + he + "]"), le || (ee.seen.indexOf(_e.value) < 0 ? (ie(Ie) ? le = F(ee, _e.value, null) : le = F(ee, _e.value, Ie - 1), le.indexOf(`
`) > -1 && (ve ? le = le.split(`
`).map(function(re) {
      return "  " + re;
    }).join(`
`).slice(2) : le = `
` + le.split(`
`).map(function(re) {
      return "   " + re;
    }).join(`
`))) : le = ee.stylize("[Circular]", "special")), Be(Q)) {
      if (ve && he.match(/^\d+$/))
        return le;
      Q = JSON.stringify("" + he), Q.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (Q = Q.slice(1, -1), Q = ee.stylize(Q, "name")) : (Q = Q.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), Q = ee.stylize(Q, "string"));
    }
    return Q + ": " + le;
  }
  function ae(ee, pe, Ie) {
    var Pe = ee.reduce(function(he, ve) {
      return ve.indexOf(`
`) >= 0, he + ve.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0);
    return Pe > 60 ? Ie[0] + (pe === "" ? "" : pe + `
 `) + " " + ee.join(`,
  `) + " " + Ie[1] : Ie[0] + pe + " " + ee.join(", ") + " " + Ie[1];
  }
  a.types = types$1;
  function ne(ee) {
    return Array.isArray(ee);
  }
  a.isArray = ne;
  function fe(ee) {
    return typeof ee == "boolean";
  }
  a.isBoolean = fe;
  function ie(ee) {
    return ee === null;
  }
  a.isNull = ie;
  function ge(ee) {
    return ee == null;
  }
  a.isNullOrUndefined = ge;
  function be(ee) {
    return typeof ee == "number";
  }
  a.isNumber = be;
  function Ce(ee) {
    return typeof ee == "string";
  }
  a.isString = Ce;
  function Me(ee) {
    return typeof ee == "symbol";
  }
  a.isSymbol = Me;
  function Be(ee) {
    return ee === void 0;
  }
  a.isUndefined = Be;
  function Ae(ee) {
    return Z(ee) && I(ee) === "[object RegExp]";
  }
  a.isRegExp = Ae, a.types.isRegExp = Ae;
  function Z(ee) {
    return typeof ee == "object" && ee !== null;
  }
  a.isObject = Z;
  function z(ee) {
    return Z(ee) && I(ee) === "[object Date]";
  }
  a.isDate = z, a.types.isDate = z;
  function P(ee) {
    return Z(ee) && (I(ee) === "[object Error]" || ee instanceof Error);
  }
  a.isError = P, a.types.isNativeError = P;
  function S(ee) {
    return typeof ee == "function";
  }
  a.isFunction = S;
  function E(ee) {
    return ee === null || typeof ee == "boolean" || typeof ee == "number" || typeof ee == "string" || typeof ee == "symbol" || // ES6 symbol
    typeof ee > "u";
  }
  a.isPrimitive = E, a.isBuffer = isBufferBrowser;
  function I(ee) {
    return Object.prototype.toString.call(ee);
  }
  function N(ee) {
    return ee < 10 ? "0" + ee.toString(10) : ee.toString(10);
  }
  var $ = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ];
  function U() {
    var ee = /* @__PURE__ */ new Date(), pe = [
      N(ee.getHours()),
      N(ee.getMinutes()),
      N(ee.getSeconds())
    ].join(":");
    return [ee.getDate(), $[ee.getMonth()], pe].join(" ");
  }
  a.log = function() {
    console.log("%s - %s", U(), a.format.apply(a, arguments));
  }, a.inherits = inherits_browserExports, a._extend = function(ee, pe) {
    if (!pe || !Z(pe))
      return ee;
    for (var Ie = Object.keys(pe), Pe = Ie.length; Pe--; )
      ee[Ie[Pe]] = pe[Ie[Pe]];
    return ee;
  };
  function H(ee, pe) {
    return Object.prototype.hasOwnProperty.call(ee, pe);
  }
  var B = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
  a.promisify = function(pe) {
    if (typeof pe != "function")
      throw new TypeError('The "original" argument must be of type Function');
    if (B && pe[B]) {
      var Ie = pe[B];
      if (typeof Ie != "function")
        throw new TypeError('The "util.promisify.custom" argument must be of type Function');
      return Object.defineProperty(Ie, B, {
        value: Ie,
        enumerable: !1,
        writable: !1,
        configurable: !0
      }), Ie;
    }
    function Ie() {
      for (var Pe, he, ve = new Promise(function(_e, re) {
        Pe = _e, he = re;
      }), Q = [], le = 0; le < arguments.length; le++)
        Q.push(arguments[le]);
      Q.push(function(_e, re) {
        _e ? he(_e) : Pe(re);
      });
      try {
        pe.apply(this, Q);
      } catch (_e) {
        he(_e);
      }
      return ve;
    }
    return Object.setPrototypeOf(Ie, Object.getPrototypeOf(pe)), B && Object.defineProperty(Ie, B, {
      value: Ie,
      enumerable: !1,
      writable: !1,
      configurable: !0
    }), Object.defineProperties(
      Ie,
      u(pe)
    );
  }, a.promisify.custom = B;
  function T(ee, pe) {
    if (!ee) {
      var Ie = new Error("Promise was rejected with a falsy value");
      Ie.reason = ee, ee = Ie;
    }
    return pe(ee);
  }
  function D(ee) {
    if (typeof ee != "function")
      throw new TypeError('The "original" argument must be of type Function');
    function pe() {
      for (var Ie = [], Pe = 0; Pe < arguments.length; Pe++)
        Ie.push(arguments[Pe]);
      var he = Ie.pop();
      if (typeof he != "function")
        throw new TypeError("The last argument must be of type Function");
      var ve = this, Q = function() {
        return he.apply(ve, arguments);
      };
      ee.apply(this, Ie).then(
        function(le) {
          process$1.nextTick(Q.bind(null, null, le));
        },
        function(le) {
          process$1.nextTick(T.bind(null, le, Q));
        }
      );
    }
    return Object.setPrototypeOf(pe, Object.getPrototypeOf(ee)), Object.defineProperties(
      pe,
      u(ee)
    ), pe;
  }
  a.callbackify = D;
})(util$4);
var buffer_list$2, hasRequiredBuffer_list$2;
function requireBuffer_list$2() {
  if (hasRequiredBuffer_list$2)
    return buffer_list$2;
  hasRequiredBuffer_list$2 = 1;
  function a(Y, ae) {
    var ne = Object.keys(Y);
    if (Object.getOwnPropertySymbols) {
      var fe = Object.getOwnPropertySymbols(Y);
      ae && (fe = fe.filter(function(ie) {
        return Object.getOwnPropertyDescriptor(Y, ie).enumerable;
      })), ne.push.apply(ne, fe);
    }
    return ne;
  }
  function u(Y) {
    for (var ae = 1; ae < arguments.length; ae++) {
      var ne = arguments[ae] != null ? arguments[ae] : {};
      ae % 2 ? a(Object(ne), !0).forEach(function(fe) {
        c(Y, fe, ne[fe]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(Y, Object.getOwnPropertyDescriptors(ne)) : a(Object(ne)).forEach(function(fe) {
        Object.defineProperty(Y, fe, Object.getOwnPropertyDescriptor(ne, fe));
      });
    }
    return Y;
  }
  function c(Y, ae, ne) {
    return ae = _(ae), ae in Y ? Object.defineProperty(Y, ae, { value: ne, enumerable: !0, configurable: !0, writable: !0 }) : Y[ae] = ne, Y;
  }
  function l(Y, ae) {
    if (!(Y instanceof ae))
      throw new TypeError("Cannot call a class as a function");
  }
  function v(Y, ae) {
    for (var ne = 0; ne < ae.length; ne++) {
      var fe = ae[ne];
      fe.enumerable = fe.enumerable || !1, fe.configurable = !0, "value" in fe && (fe.writable = !0), Object.defineProperty(Y, _(fe.key), fe);
    }
  }
  function p(Y, ae, ne) {
    return ae && v(Y.prototype, ae), ne && v(Y, ne), Object.defineProperty(Y, "prototype", { writable: !1 }), Y;
  }
  function _(Y) {
    var ae = k(Y, "string");
    return typeof ae == "symbol" ? ae : String(ae);
  }
  function k(Y, ae) {
    if (typeof Y != "object" || Y === null)
      return Y;
    var ne = Y[Symbol.toPrimitive];
    if (ne !== void 0) {
      var fe = ne.call(Y, ae || "default");
      if (typeof fe != "object")
        return fe;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (ae === "string" ? String : Number)(Y);
  }
  var M = require$$0$2, L = M.Buffer, F = util$4, V = F.inspect, X = V && V.custom || "inspect";
  function oe(Y, ae, ne) {
    L.prototype.copy.call(Y, ae, ne);
  }
  return buffer_list$2 = /* @__PURE__ */ function() {
    function Y() {
      l(this, Y), this.head = null, this.tail = null, this.length = 0;
    }
    return p(Y, [{
      key: "push",
      value: function(ne) {
        var fe = {
          data: ne,
          next: null
        };
        this.length > 0 ? this.tail.next = fe : this.head = fe, this.tail = fe, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(ne) {
        var fe = {
          data: ne,
          next: this.head
        };
        this.length === 0 && (this.tail = fe), this.head = fe, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var ne = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, ne;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(ne) {
        if (this.length === 0)
          return "";
        for (var fe = this.head, ie = "" + fe.data; fe = fe.next; )
          ie += ne + fe.data;
        return ie;
      }
    }, {
      key: "concat",
      value: function(ne) {
        if (this.length === 0)
          return L.alloc(0);
        for (var fe = L.allocUnsafe(ne >>> 0), ie = this.head, ge = 0; ie; )
          oe(ie.data, fe, ge), ge += ie.data.length, ie = ie.next;
        return fe;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(ne, fe) {
        var ie;
        return ne < this.head.data.length ? (ie = this.head.data.slice(0, ne), this.head.data = this.head.data.slice(ne)) : ne === this.head.data.length ? ie = this.shift() : ie = fe ? this._getString(ne) : this._getBuffer(ne), ie;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(ne) {
        var fe = this.head, ie = 1, ge = fe.data;
        for (ne -= ge.length; fe = fe.next; ) {
          var be = fe.data, Ce = ne > be.length ? be.length : ne;
          if (Ce === be.length ? ge += be : ge += be.slice(0, ne), ne -= Ce, ne === 0) {
            Ce === be.length ? (++ie, fe.next ? this.head = fe.next : this.head = this.tail = null) : (this.head = fe, fe.data = be.slice(Ce));
            break;
          }
          ++ie;
        }
        return this.length -= ie, ge;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(ne) {
        var fe = L.allocUnsafe(ne), ie = this.head, ge = 1;
        for (ie.data.copy(fe), ne -= ie.data.length; ie = ie.next; ) {
          var be = ie.data, Ce = ne > be.length ? be.length : ne;
          if (be.copy(fe, fe.length - ne, 0, Ce), ne -= Ce, ne === 0) {
            Ce === be.length ? (++ge, ie.next ? this.head = ie.next : this.head = this.tail = null) : (this.head = ie, ie.data = be.slice(Ce));
            break;
          }
          ++ge;
        }
        return this.length -= ge, fe;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: X,
      value: function(ne, fe) {
        return V(this, u(u({}, fe), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), Y;
  }(), buffer_list$2;
}
var destroy_1$2, hasRequiredDestroy;
function requireDestroy() {
  if (hasRequiredDestroy)
    return destroy_1$2;
  hasRequiredDestroy = 1;
  function a(_, k) {
    var M = this, L = this._readableState && this._readableState.destroyed, F = this._writableState && this._writableState.destroyed;
    return L || F ? (k ? k(_) : _ && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process$1.nextTick(v, this, _)) : process$1.nextTick(v, this, _)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(_ || null, function(V) {
      !k && V ? M._writableState ? M._writableState.errorEmitted ? process$1.nextTick(c, M) : (M._writableState.errorEmitted = !0, process$1.nextTick(u, M, V)) : process$1.nextTick(u, M, V) : k ? (process$1.nextTick(c, M), k(V)) : process$1.nextTick(c, M);
    }), this);
  }
  function u(_, k) {
    v(_, k), c(_);
  }
  function c(_) {
    _._writableState && !_._writableState.emitClose || _._readableState && !_._readableState.emitClose || _.emit("close");
  }
  function l() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function v(_, k) {
    _.emit("error", k);
  }
  function p(_, k) {
    var M = _._readableState, L = _._writableState;
    M && M.autoDestroy || L && L.autoDestroy ? _.destroy(k) : _.emit("error", k);
  }
  return destroy_1$2 = {
    destroy: a,
    undestroy: l,
    errorOrDestroy: p
  }, destroy_1$2;
}
var errorsBrowser$2 = {}, hasRequiredErrorsBrowser;
function requireErrorsBrowser() {
  if (hasRequiredErrorsBrowser)
    return errorsBrowser$2;
  hasRequiredErrorsBrowser = 1;
  function a(k, M) {
    k.prototype = Object.create(M.prototype), k.prototype.constructor = k, k.__proto__ = M;
  }
  var u = {};
  function c(k, M, L) {
    L || (L = Error);
    function F(X, oe, Y) {
      return typeof M == "string" ? M : M(X, oe, Y);
    }
    var V = /* @__PURE__ */ function(X) {
      a(oe, X);
      function oe(Y, ae, ne) {
        return X.call(this, F(Y, ae, ne)) || this;
      }
      return oe;
    }(L);
    V.prototype.name = L.name, V.prototype.code = k, u[k] = V;
  }
  function l(k, M) {
    if (Array.isArray(k)) {
      var L = k.length;
      return k = k.map(function(F) {
        return String(F);
      }), L > 2 ? "one of ".concat(M, " ").concat(k.slice(0, L - 1).join(", "), ", or ") + k[L - 1] : L === 2 ? "one of ".concat(M, " ").concat(k[0], " or ").concat(k[1]) : "of ".concat(M, " ").concat(k[0]);
    } else
      return "of ".concat(M, " ").concat(String(k));
  }
  function v(k, M, L) {
    return k.substr(!L || L < 0 ? 0 : +L, M.length) === M;
  }
  function p(k, M, L) {
    return (L === void 0 || L > k.length) && (L = k.length), k.substring(L - M.length, L) === M;
  }
  function _(k, M, L) {
    return typeof L != "number" && (L = 0), L + M.length > k.length ? !1 : k.indexOf(M, L) !== -1;
  }
  return c("ERR_INVALID_OPT_VALUE", function(k, M) {
    return 'The value "' + M + '" is invalid for option "' + k + '"';
  }, TypeError), c("ERR_INVALID_ARG_TYPE", function(k, M, L) {
    var F;
    typeof M == "string" && v(M, "not ") ? (F = "must not be", M = M.replace(/^not /, "")) : F = "must be";
    var V;
    if (p(k, " argument"))
      V = "The ".concat(k, " ").concat(F, " ").concat(l(M, "type"));
    else {
      var X = _(k, ".") ? "property" : "argument";
      V = 'The "'.concat(k, '" ').concat(X, " ").concat(F, " ").concat(l(M, "type"));
    }
    return V += ". Received type ".concat(typeof L), V;
  }, TypeError), c("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), c("ERR_METHOD_NOT_IMPLEMENTED", function(k) {
    return "The " + k + " method is not implemented";
  }), c("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), c("ERR_STREAM_DESTROYED", function(k) {
    return "Cannot call " + k + " after a stream was destroyed";
  }), c("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), c("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), c("ERR_STREAM_WRITE_AFTER_END", "write after end"), c("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), c("ERR_UNKNOWN_ENCODING", function(k) {
    return "Unknown encoding: " + k;
  }, TypeError), c("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), errorsBrowser$2.codes = u, errorsBrowser$2;
}
var state$5, hasRequiredState;
function requireState() {
  if (hasRequiredState)
    return state$5;
  hasRequiredState = 1;
  var a = requireErrorsBrowser().codes.ERR_INVALID_OPT_VALUE;
  function u(l, v, p) {
    return l.highWaterMark != null ? l.highWaterMark : v ? l[p] : null;
  }
  function c(l, v, p, _) {
    var k = u(v, _, p);
    if (k != null) {
      if (!(isFinite(k) && Math.floor(k) === k) || k < 0) {
        var M = _ ? p : "highWaterMark";
        throw new a(M, k);
      }
      return Math.floor(k);
    }
    return l.objectMode ? 16 : 16 * 1024;
  }
  return state$5 = {
    getHighWaterMark: c
  }, state$5;
}
var browser$c = deprecate;
function deprecate(a, u) {
  if (config$1("noDeprecation"))
    return a;
  var c = !1;
  function l() {
    if (!c) {
      if (config$1("throwDeprecation"))
        throw new Error(u);
      config$1("traceDeprecation") ? console.trace(u) : console.warn(u), c = !0;
    }
    return a.apply(this, arguments);
  }
  return l;
}
function config$1(a) {
  try {
    if (!commonjsGlobal$1.localStorage)
      return !1;
  } catch {
    return !1;
  }
  var u = commonjsGlobal$1.localStorage[a];
  return u == null ? !1 : String(u).toLowerCase() === "true";
}
var _stream_writable$2, hasRequired_stream_writable$2;
function require_stream_writable$2() {
  if (hasRequired_stream_writable$2)
    return _stream_writable$2;
  hasRequired_stream_writable$2 = 1, _stream_writable$2 = Ae;
  function a(he) {
    var ve = this;
    this.next = null, this.entry = null, this.finish = function() {
      Pe(ve, he);
    };
  }
  var u;
  Ae.WritableState = Me;
  var c = {
    deprecate: browser$c
  }, l = requireStreamBrowser(), v = require$$0$2.Buffer, p = (typeof commonjsGlobal$1 < "u" ? commonjsGlobal$1 : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function _(he) {
    return v.from(he);
  }
  function k(he) {
    return v.isBuffer(he) || he instanceof p;
  }
  var M = requireDestroy(), L = requireState(), F = L.getHighWaterMark, V = requireErrorsBrowser().codes, X = V.ERR_INVALID_ARG_TYPE, oe = V.ERR_METHOD_NOT_IMPLEMENTED, Y = V.ERR_MULTIPLE_CALLBACK, ae = V.ERR_STREAM_CANNOT_PIPE, ne = V.ERR_STREAM_DESTROYED, fe = V.ERR_STREAM_NULL_VALUES, ie = V.ERR_STREAM_WRITE_AFTER_END, ge = V.ERR_UNKNOWN_ENCODING, be = M.errorOrDestroy;
  inherits_browserExports(Ae, l);
  function Ce() {
  }
  function Me(he, ve, Q) {
    u = u || require_stream_duplex$2(), he = he || {}, typeof Q != "boolean" && (Q = ve instanceof u), this.objectMode = !!he.objectMode, Q && (this.objectMode = this.objectMode || !!he.writableObjectMode), this.highWaterMark = F(this, he, "writableHighWaterMark", Q), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var le = he.decodeStrings === !1;
    this.decodeStrings = !le, this.defaultEncoding = he.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(_e) {
      $(ve, _e);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = he.emitClose !== !1, this.autoDestroy = !!he.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new a(this);
  }
  Me.prototype.getBuffer = function() {
    for (var ve = this.bufferedRequest, Q = []; ve; )
      Q.push(ve), ve = ve.next;
    return Q;
  }, function() {
    try {
      Object.defineProperty(Me.prototype, "buffer", {
        get: c.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var Be;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (Be = Function.prototype[Symbol.hasInstance], Object.defineProperty(Ae, Symbol.hasInstance, {
    value: function(ve) {
      return Be.call(this, ve) ? !0 : this !== Ae ? !1 : ve && ve._writableState instanceof Me;
    }
  })) : Be = function(ve) {
    return ve instanceof this;
  };
  function Ae(he) {
    u = u || require_stream_duplex$2();
    var ve = this instanceof u;
    if (!ve && !Be.call(Ae, this))
      return new Ae(he);
    this._writableState = new Me(he, this, ve), this.writable = !0, he && (typeof he.write == "function" && (this._write = he.write), typeof he.writev == "function" && (this._writev = he.writev), typeof he.destroy == "function" && (this._destroy = he.destroy), typeof he.final == "function" && (this._final = he.final)), l.call(this);
  }
  Ae.prototype.pipe = function() {
    be(this, new ae());
  };
  function Z(he, ve) {
    var Q = new ie();
    be(he, Q), process$1.nextTick(ve, Q);
  }
  function z(he, ve, Q, le) {
    var _e;
    return Q === null ? _e = new fe() : typeof Q != "string" && !ve.objectMode && (_e = new X("chunk", ["string", "Buffer"], Q)), _e ? (be(he, _e), process$1.nextTick(le, _e), !1) : !0;
  }
  Ae.prototype.write = function(he, ve, Q) {
    var le = this._writableState, _e = !1, re = !le.objectMode && k(he);
    return re && !v.isBuffer(he) && (he = _(he)), typeof ve == "function" && (Q = ve, ve = null), re ? ve = "buffer" : ve || (ve = le.defaultEncoding), typeof Q != "function" && (Q = Ce), le.ending ? Z(this, Q) : (re || z(this, le, he, Q)) && (le.pendingcb++, _e = S(this, le, re, he, ve, Q)), _e;
  }, Ae.prototype.cork = function() {
    this._writableState.corked++;
  }, Ae.prototype.uncork = function() {
    var he = this._writableState;
    he.corked && (he.corked--, !he.writing && !he.corked && !he.bufferProcessing && he.bufferedRequest && B(this, he));
  }, Ae.prototype.setDefaultEncoding = function(ve) {
    if (typeof ve == "string" && (ve = ve.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((ve + "").toLowerCase()) > -1))
      throw new ge(ve);
    return this._writableState.defaultEncoding = ve, this;
  }, Object.defineProperty(Ae.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function P(he, ve, Q) {
    return !he.objectMode && he.decodeStrings !== !1 && typeof ve == "string" && (ve = v.from(ve, Q)), ve;
  }
  Object.defineProperty(Ae.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function S(he, ve, Q, le, _e, re) {
    if (!Q) {
      var O = P(ve, le, _e);
      le !== O && (Q = !0, _e = "buffer", le = O);
    }
    var j = ve.objectMode ? 1 : le.length;
    ve.length += j;
    var ce = ve.length < ve.highWaterMark;
    if (ce || (ve.needDrain = !0), ve.writing || ve.corked) {
      var De = ve.lastBufferedRequest;
      ve.lastBufferedRequest = {
        chunk: le,
        encoding: _e,
        isBuf: Q,
        callback: re,
        next: null
      }, De ? De.next = ve.lastBufferedRequest : ve.bufferedRequest = ve.lastBufferedRequest, ve.bufferedRequestCount += 1;
    } else
      E(he, ve, !1, j, le, _e, re);
    return ce;
  }
  function E(he, ve, Q, le, _e, re, O) {
    ve.writelen = le, ve.writecb = O, ve.writing = !0, ve.sync = !0, ve.destroyed ? ve.onwrite(new ne("write")) : Q ? he._writev(_e, ve.onwrite) : he._write(_e, re, ve.onwrite), ve.sync = !1;
  }
  function I(he, ve, Q, le, _e) {
    --ve.pendingcb, Q ? (process$1.nextTick(_e, le), process$1.nextTick(pe, he, ve), he._writableState.errorEmitted = !0, be(he, le)) : (_e(le), he._writableState.errorEmitted = !0, be(he, le), pe(he, ve));
  }
  function N(he) {
    he.writing = !1, he.writecb = null, he.length -= he.writelen, he.writelen = 0;
  }
  function $(he, ve) {
    var Q = he._writableState, le = Q.sync, _e = Q.writecb;
    if (typeof _e != "function")
      throw new Y();
    if (N(Q), ve)
      I(he, Q, le, ve, _e);
    else {
      var re = T(Q) || he.destroyed;
      !re && !Q.corked && !Q.bufferProcessing && Q.bufferedRequest && B(he, Q), le ? process$1.nextTick(U, he, Q, re, _e) : U(he, Q, re, _e);
    }
  }
  function U(he, ve, Q, le) {
    Q || H(he, ve), ve.pendingcb--, le(), pe(he, ve);
  }
  function H(he, ve) {
    ve.length === 0 && ve.needDrain && (ve.needDrain = !1, he.emit("drain"));
  }
  function B(he, ve) {
    ve.bufferProcessing = !0;
    var Q = ve.bufferedRequest;
    if (he._writev && Q && Q.next) {
      var le = ve.bufferedRequestCount, _e = new Array(le), re = ve.corkedRequestsFree;
      re.entry = Q;
      for (var O = 0, j = !0; Q; )
        _e[O] = Q, Q.isBuf || (j = !1), Q = Q.next, O += 1;
      _e.allBuffers = j, E(he, ve, !0, ve.length, _e, "", re.finish), ve.pendingcb++, ve.lastBufferedRequest = null, re.next ? (ve.corkedRequestsFree = re.next, re.next = null) : ve.corkedRequestsFree = new a(ve), ve.bufferedRequestCount = 0;
    } else {
      for (; Q; ) {
        var ce = Q.chunk, De = Q.encoding, Ne = Q.callback, Fe = ve.objectMode ? 1 : ce.length;
        if (E(he, ve, !1, Fe, ce, De, Ne), Q = Q.next, ve.bufferedRequestCount--, ve.writing)
          break;
      }
      Q === null && (ve.lastBufferedRequest = null);
    }
    ve.bufferedRequest = Q, ve.bufferProcessing = !1;
  }
  Ae.prototype._write = function(he, ve, Q) {
    Q(new oe("_write()"));
  }, Ae.prototype._writev = null, Ae.prototype.end = function(he, ve, Q) {
    var le = this._writableState;
    return typeof he == "function" ? (Q = he, he = null, ve = null) : typeof ve == "function" && (Q = ve, ve = null), he != null && this.write(he, ve), le.corked && (le.corked = 1, this.uncork()), le.ending || Ie(this, le, Q), this;
  }, Object.defineProperty(Ae.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function T(he) {
    return he.ending && he.length === 0 && he.bufferedRequest === null && !he.finished && !he.writing;
  }
  function D(he, ve) {
    he._final(function(Q) {
      ve.pendingcb--, Q && be(he, Q), ve.prefinished = !0, he.emit("prefinish"), pe(he, ve);
    });
  }
  function ee(he, ve) {
    !ve.prefinished && !ve.finalCalled && (typeof he._final == "function" && !ve.destroyed ? (ve.pendingcb++, ve.finalCalled = !0, process$1.nextTick(D, he, ve)) : (ve.prefinished = !0, he.emit("prefinish")));
  }
  function pe(he, ve) {
    var Q = T(ve);
    if (Q && (ee(he, ve), ve.pendingcb === 0 && (ve.finished = !0, he.emit("finish"), ve.autoDestroy))) {
      var le = he._readableState;
      (!le || le.autoDestroy && le.endEmitted) && he.destroy();
    }
    return Q;
  }
  function Ie(he, ve, Q) {
    ve.ending = !0, pe(he, ve), Q && (ve.finished ? process$1.nextTick(Q) : he.once("finish", Q)), ve.ended = !0, he.writable = !1;
  }
  function Pe(he, ve, Q) {
    var le = he.entry;
    for (he.entry = null; le; ) {
      var _e = le.callback;
      ve.pendingcb--, _e(Q), le = le.next;
    }
    ve.corkedRequestsFree.next = he;
  }
  return Object.defineProperty(Ae.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(ve) {
      this._writableState && (this._writableState.destroyed = ve);
    }
  }), Ae.prototype.destroy = M.destroy, Ae.prototype._undestroy = M.undestroy, Ae.prototype._destroy = function(he, ve) {
    ve(he);
  }, _stream_writable$2;
}
var _stream_duplex$2, hasRequired_stream_duplex$2;
function require_stream_duplex$2() {
  if (hasRequired_stream_duplex$2)
    return _stream_duplex$2;
  hasRequired_stream_duplex$2 = 1;
  var a = Object.keys || function(L) {
    var F = [];
    for (var V in L)
      F.push(V);
    return F;
  };
  _stream_duplex$2 = _;
  var u = require_stream_readable$2(), c = require_stream_writable$2();
  inherits_browserExports(_, u);
  for (var l = a(c.prototype), v = 0; v < l.length; v++) {
    var p = l[v];
    _.prototype[p] || (_.prototype[p] = c.prototype[p]);
  }
  function _(L) {
    if (!(this instanceof _))
      return new _(L);
    u.call(this, L), c.call(this, L), this.allowHalfOpen = !0, L && (L.readable === !1 && (this.readable = !1), L.writable === !1 && (this.writable = !1), L.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", k)));
  }
  Object.defineProperty(_.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(_.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(_.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function k() {
    this._writableState.ended || process$1.nextTick(M, this);
  }
  function M(L) {
    L.end();
  }
  return Object.defineProperty(_.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(F) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = F, this._writableState.destroyed = F);
    }
  }), _stream_duplex$2;
}
var string_decoder = {}, safeBuffer$3 = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(a, u) {
  var c = require$$0$2, l = c.Buffer;
  function v(_, k) {
    for (var M in _)
      k[M] = _[M];
  }
  l.from && l.alloc && l.allocUnsafe && l.allocUnsafeSlow ? a.exports = c : (v(c, u), u.Buffer = p);
  function p(_, k, M) {
    return l(_, k, M);
  }
  p.prototype = Object.create(l.prototype), v(l, p), p.from = function(_, k, M) {
    if (typeof _ == "number")
      throw new TypeError("Argument must not be a number");
    return l(_, k, M);
  }, p.alloc = function(_, k, M) {
    if (typeof _ != "number")
      throw new TypeError("Argument must be a number");
    var L = l(_);
    return k !== void 0 ? typeof M == "string" ? L.fill(k, M) : L.fill(k) : L.fill(0), L;
  }, p.allocUnsafe = function(_) {
    if (typeof _ != "number")
      throw new TypeError("Argument must be a number");
    return l(_);
  }, p.allocUnsafeSlow = function(_) {
    if (typeof _ != "number")
      throw new TypeError("Argument must be a number");
    return c.SlowBuffer(_);
  };
})(safeBuffer$3, safeBuffer$3.exports);
var safeBufferExports$2 = safeBuffer$3.exports, Buffer$L = safeBufferExports$2.Buffer, isEncoding = Buffer$L.isEncoding || function(a) {
  switch (a = "" + a, a && a.toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
    case "raw":
      return !0;
    default:
      return !1;
  }
};
function _normalizeEncoding(a) {
  if (!a)
    return "utf8";
  for (var u; ; )
    switch (a) {
      case "utf8":
      case "utf-8":
        return "utf8";
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return "utf16le";
      case "latin1":
      case "binary":
        return "latin1";
      case "base64":
      case "ascii":
      case "hex":
        return a;
      default:
        if (u)
          return;
        a = ("" + a).toLowerCase(), u = !0;
    }
}
function normalizeEncoding(a) {
  var u = _normalizeEncoding(a);
  if (typeof u != "string" && (Buffer$L.isEncoding === isEncoding || !isEncoding(a)))
    throw new Error("Unknown encoding: " + a);
  return u || a;
}
string_decoder.StringDecoder = StringDecoder$1;
function StringDecoder$1(a) {
  this.encoding = normalizeEncoding(a);
  var u;
  switch (this.encoding) {
    case "utf16le":
      this.text = utf16Text, this.end = utf16End, u = 4;
      break;
    case "utf8":
      this.fillLast = utf8FillLast, u = 4;
      break;
    case "base64":
      this.text = base64Text, this.end = base64End, u = 3;
      break;
    default:
      this.write = simpleWrite, this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0, this.lastTotal = 0, this.lastChar = Buffer$L.allocUnsafe(u);
}
StringDecoder$1.prototype.write = function(a) {
  if (a.length === 0)
    return "";
  var u, c;
  if (this.lastNeed) {
    if (u = this.fillLast(a), u === void 0)
      return "";
    c = this.lastNeed, this.lastNeed = 0;
  } else
    c = 0;
  return c < a.length ? u ? u + this.text(a, c) : this.text(a, c) : u || "";
};
StringDecoder$1.prototype.end = utf8End;
StringDecoder$1.prototype.text = utf8Text;
StringDecoder$1.prototype.fillLast = function(a) {
  if (this.lastNeed <= a.length)
    return a.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
  a.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, a.length), this.lastNeed -= a.length;
};
function utf8CheckByte(a) {
  return a <= 127 ? 0 : a >> 5 === 6 ? 2 : a >> 4 === 14 ? 3 : a >> 3 === 30 ? 4 : a >> 6 === 2 ? -1 : -2;
}
function utf8CheckIncomplete(a, u, c) {
  var l = u.length - 1;
  if (l < c)
    return 0;
  var v = utf8CheckByte(u[l]);
  return v >= 0 ? (v > 0 && (a.lastNeed = v - 1), v) : --l < c || v === -2 ? 0 : (v = utf8CheckByte(u[l]), v >= 0 ? (v > 0 && (a.lastNeed = v - 2), v) : --l < c || v === -2 ? 0 : (v = utf8CheckByte(u[l]), v >= 0 ? (v > 0 && (v === 2 ? v = 0 : a.lastNeed = v - 3), v) : 0));
}
function utf8CheckExtraBytes(a, u, c) {
  if ((u[0] & 192) !== 128)
    return a.lastNeed = 0, "";
  if (a.lastNeed > 1 && u.length > 1) {
    if ((u[1] & 192) !== 128)
      return a.lastNeed = 1, "";
    if (a.lastNeed > 2 && u.length > 2 && (u[2] & 192) !== 128)
      return a.lastNeed = 2, "";
  }
}
function utf8FillLast(a) {
  var u = this.lastTotal - this.lastNeed, c = utf8CheckExtraBytes(this, a);
  if (c !== void 0)
    return c;
  if (this.lastNeed <= a.length)
    return a.copy(this.lastChar, u, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
  a.copy(this.lastChar, u, 0, a.length), this.lastNeed -= a.length;
}
function utf8Text(a, u) {
  var c = utf8CheckIncomplete(this, a, u);
  if (!this.lastNeed)
    return a.toString("utf8", u);
  this.lastTotal = c;
  var l = a.length - (c - this.lastNeed);
  return a.copy(this.lastChar, 0, l), a.toString("utf8", u, l);
}
function utf8End(a) {
  var u = a && a.length ? this.write(a) : "";
  return this.lastNeed ? u + "" : u;
}
function utf16Text(a, u) {
  if ((a.length - u) % 2 === 0) {
    var c = a.toString("utf16le", u);
    if (c) {
      var l = c.charCodeAt(c.length - 1);
      if (l >= 55296 && l <= 56319)
        return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = a[a.length - 2], this.lastChar[1] = a[a.length - 1], c.slice(0, -1);
    }
    return c;
  }
  return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = a[a.length - 1], a.toString("utf16le", u, a.length - 1);
}
function utf16End(a) {
  var u = a && a.length ? this.write(a) : "";
  if (this.lastNeed) {
    var c = this.lastTotal - this.lastNeed;
    return u + this.lastChar.toString("utf16le", 0, c);
  }
  return u;
}
function base64Text(a, u) {
  var c = (a.length - u) % 3;
  return c === 0 ? a.toString("base64", u) : (this.lastNeed = 3 - c, this.lastTotal = 3, c === 1 ? this.lastChar[0] = a[a.length - 1] : (this.lastChar[0] = a[a.length - 2], this.lastChar[1] = a[a.length - 1]), a.toString("base64", u, a.length - c));
}
function base64End(a) {
  var u = a && a.length ? this.write(a) : "";
  return this.lastNeed ? u + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : u;
}
function simpleWrite(a) {
  return a.toString(this.encoding);
}
function simpleEnd(a) {
  return a && a.length ? this.write(a) : "";
}
var endOfStream$2, hasRequiredEndOfStream;
function requireEndOfStream() {
  if (hasRequiredEndOfStream)
    return endOfStream$2;
  hasRequiredEndOfStream = 1;
  var a = requireErrorsBrowser().codes.ERR_STREAM_PREMATURE_CLOSE;
  function u(p) {
    var _ = !1;
    return function() {
      if (!_) {
        _ = !0;
        for (var k = arguments.length, M = new Array(k), L = 0; L < k; L++)
          M[L] = arguments[L];
        p.apply(this, M);
      }
    };
  }
  function c() {
  }
  function l(p) {
    return p.setHeader && typeof p.abort == "function";
  }
  function v(p, _, k) {
    if (typeof _ == "function")
      return v(p, null, _);
    _ || (_ = {}), k = u(k || c);
    var M = _.readable || _.readable !== !1 && p.readable, L = _.writable || _.writable !== !1 && p.writable, F = function() {
      p.writable || X();
    }, V = p._writableState && p._writableState.finished, X = function() {
      L = !1, V = !0, M || k.call(p);
    }, oe = p._readableState && p._readableState.endEmitted, Y = function() {
      M = !1, oe = !0, L || k.call(p);
    }, ae = function(ge) {
      k.call(p, ge);
    }, ne = function() {
      var ge;
      if (M && !oe)
        return (!p._readableState || !p._readableState.ended) && (ge = new a()), k.call(p, ge);
      if (L && !V)
        return (!p._writableState || !p._writableState.ended) && (ge = new a()), k.call(p, ge);
    }, fe = function() {
      p.req.on("finish", X);
    };
    return l(p) ? (p.on("complete", X), p.on("abort", ne), p.req ? fe() : p.on("request", fe)) : L && !p._writableState && (p.on("end", F), p.on("close", F)), p.on("end", Y), p.on("finish", X), _.error !== !1 && p.on("error", ae), p.on("close", ne), function() {
      p.removeListener("complete", X), p.removeListener("abort", ne), p.removeListener("request", fe), p.req && p.req.removeListener("finish", X), p.removeListener("end", F), p.removeListener("close", F), p.removeListener("finish", X), p.removeListener("end", Y), p.removeListener("error", ae), p.removeListener("close", ne);
    };
  }
  return endOfStream$2 = v, endOfStream$2;
}
var async_iterator$2, hasRequiredAsync_iterator$2;
function requireAsync_iterator$2() {
  if (hasRequiredAsync_iterator$2)
    return async_iterator$2;
  hasRequiredAsync_iterator$2 = 1;
  var a;
  function u(ge, be, Ce) {
    return be = c(be), be in ge ? Object.defineProperty(ge, be, { value: Ce, enumerable: !0, configurable: !0, writable: !0 }) : ge[be] = Ce, ge;
  }
  function c(ge) {
    var be = l(ge, "string");
    return typeof be == "symbol" ? be : String(be);
  }
  function l(ge, be) {
    if (typeof ge != "object" || ge === null)
      return ge;
    var Ce = ge[Symbol.toPrimitive];
    if (Ce !== void 0) {
      var Me = Ce.call(ge, be || "default");
      if (typeof Me != "object")
        return Me;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (be === "string" ? String : Number)(ge);
  }
  var v = requireEndOfStream(), p = Symbol("lastResolve"), _ = Symbol("lastReject"), k = Symbol("error"), M = Symbol("ended"), L = Symbol("lastPromise"), F = Symbol("handlePromise"), V = Symbol("stream");
  function X(ge, be) {
    return {
      value: ge,
      done: be
    };
  }
  function oe(ge) {
    var be = ge[p];
    if (be !== null) {
      var Ce = ge[V].read();
      Ce !== null && (ge[L] = null, ge[p] = null, ge[_] = null, be(X(Ce, !1)));
    }
  }
  function Y(ge) {
    process$1.nextTick(oe, ge);
  }
  function ae(ge, be) {
    return function(Ce, Me) {
      ge.then(function() {
        if (be[M]) {
          Ce(X(void 0, !0));
          return;
        }
        be[F](Ce, Me);
      }, Me);
    };
  }
  var ne = Object.getPrototypeOf(function() {
  }), fe = Object.setPrototypeOf((a = {
    get stream() {
      return this[V];
    },
    next: function() {
      var be = this, Ce = this[k];
      if (Ce !== null)
        return Promise.reject(Ce);
      if (this[M])
        return Promise.resolve(X(void 0, !0));
      if (this[V].destroyed)
        return new Promise(function(Z, z) {
          process$1.nextTick(function() {
            be[k] ? z(be[k]) : Z(X(void 0, !0));
          });
        });
      var Me = this[L], Be;
      if (Me)
        Be = new Promise(ae(Me, this));
      else {
        var Ae = this[V].read();
        if (Ae !== null)
          return Promise.resolve(X(Ae, !1));
        Be = new Promise(this[F]);
      }
      return this[L] = Be, Be;
    }
  }, u(a, Symbol.asyncIterator, function() {
    return this;
  }), u(a, "return", function() {
    var be = this;
    return new Promise(function(Ce, Me) {
      be[V].destroy(null, function(Be) {
        if (Be) {
          Me(Be);
          return;
        }
        Ce(X(void 0, !0));
      });
    });
  }), a), ne), ie = function(be) {
    var Ce, Me = Object.create(fe, (Ce = {}, u(Ce, V, {
      value: be,
      writable: !0
    }), u(Ce, p, {
      value: null,
      writable: !0
    }), u(Ce, _, {
      value: null,
      writable: !0
    }), u(Ce, k, {
      value: null,
      writable: !0
    }), u(Ce, M, {
      value: be._readableState.endEmitted,
      writable: !0
    }), u(Ce, F, {
      value: function(Ae, Z) {
        var z = Me[V].read();
        z ? (Me[L] = null, Me[p] = null, Me[_] = null, Ae(X(z, !1))) : (Me[p] = Ae, Me[_] = Z);
      },
      writable: !0
    }), Ce));
    return Me[L] = null, v(be, function(Be) {
      if (Be && Be.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var Ae = Me[_];
        Ae !== null && (Me[L] = null, Me[p] = null, Me[_] = null, Ae(Be)), Me[k] = Be;
        return;
      }
      var Z = Me[p];
      Z !== null && (Me[L] = null, Me[p] = null, Me[_] = null, Z(X(void 0, !0))), Me[M] = !0;
    }), be.on("readable", Y.bind(null, Me)), Me;
  };
  return async_iterator$2 = ie, async_iterator$2;
}
var fromBrowser$2, hasRequiredFromBrowser$2;
function requireFromBrowser$2() {
  return hasRequiredFromBrowser$2 || (hasRequiredFromBrowser$2 = 1, fromBrowser$2 = function() {
    throw new Error("Readable.from is not available in the browser");
  }), fromBrowser$2;
}
var _stream_readable$2, hasRequired_stream_readable$2;
function require_stream_readable$2() {
  if (hasRequired_stream_readable$2)
    return _stream_readable$2;
  hasRequired_stream_readable$2 = 1, _stream_readable$2 = Z;
  var a;
  Z.ReadableState = Ae, eventsExports.EventEmitter;
  var u = function(O, j) {
    return O.listeners(j).length;
  }, c = requireStreamBrowser(), l = require$$0$2.Buffer, v = (typeof commonjsGlobal$1 < "u" ? commonjsGlobal$1 : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function p(re) {
    return l.from(re);
  }
  function _(re) {
    return l.isBuffer(re) || re instanceof v;
  }
  var k = util$4, M;
  k && k.debuglog ? M = k.debuglog("stream") : M = function() {
  };
  var L = requireBuffer_list$2(), F = requireDestroy(), V = requireState(), X = V.getHighWaterMark, oe = requireErrorsBrowser().codes, Y = oe.ERR_INVALID_ARG_TYPE, ae = oe.ERR_STREAM_PUSH_AFTER_EOF, ne = oe.ERR_METHOD_NOT_IMPLEMENTED, fe = oe.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, ie, ge, be;
  inherits_browserExports(Z, c);
  var Ce = F.errorOrDestroy, Me = ["error", "close", "destroy", "pause", "resume"];
  function Be(re, O, j) {
    if (typeof re.prependListener == "function")
      return re.prependListener(O, j);
    !re._events || !re._events[O] ? re.on(O, j) : Array.isArray(re._events[O]) ? re._events[O].unshift(j) : re._events[O] = [j, re._events[O]];
  }
  function Ae(re, O, j) {
    a = a || require_stream_duplex$2(), re = re || {}, typeof j != "boolean" && (j = O instanceof a), this.objectMode = !!re.objectMode, j && (this.objectMode = this.objectMode || !!re.readableObjectMode), this.highWaterMark = X(this, re, "readableHighWaterMark", j), this.buffer = new L(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = re.emitClose !== !1, this.autoDestroy = !!re.autoDestroy, this.destroyed = !1, this.defaultEncoding = re.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, re.encoding && (ie || (ie = string_decoder.StringDecoder), this.decoder = new ie(re.encoding), this.encoding = re.encoding);
  }
  function Z(re) {
    if (a = a || require_stream_duplex$2(), !(this instanceof Z))
      return new Z(re);
    var O = this instanceof a;
    this._readableState = new Ae(re, this, O), this.readable = !0, re && (typeof re.read == "function" && (this._read = re.read), typeof re.destroy == "function" && (this._destroy = re.destroy)), c.call(this);
  }
  Object.defineProperty(Z.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(O) {
      this._readableState && (this._readableState.destroyed = O);
    }
  }), Z.prototype.destroy = F.destroy, Z.prototype._undestroy = F.undestroy, Z.prototype._destroy = function(re, O) {
    O(re);
  }, Z.prototype.push = function(re, O) {
    var j = this._readableState, ce;
    return j.objectMode ? ce = !0 : typeof re == "string" && (O = O || j.defaultEncoding, O !== j.encoding && (re = l.from(re, O), O = ""), ce = !0), z(this, re, O, !1, ce);
  }, Z.prototype.unshift = function(re) {
    return z(this, re, null, !0, !1);
  };
  function z(re, O, j, ce, De) {
    M("readableAddChunk", O);
    var Ne = re._readableState;
    if (O === null)
      Ne.reading = !1, $(re, Ne);
    else {
      var Fe;
      if (De || (Fe = S(Ne, O)), Fe)
        Ce(re, Fe);
      else if (Ne.objectMode || O && O.length > 0)
        if (typeof O != "string" && !Ne.objectMode && Object.getPrototypeOf(O) !== l.prototype && (O = p(O)), ce)
          Ne.endEmitted ? Ce(re, new fe()) : P(re, Ne, O, !0);
        else if (Ne.ended)
          Ce(re, new ae());
        else {
          if (Ne.destroyed)
            return !1;
          Ne.reading = !1, Ne.decoder && !j ? (O = Ne.decoder.write(O), Ne.objectMode || O.length !== 0 ? P(re, Ne, O, !1) : B(re, Ne)) : P(re, Ne, O, !1);
        }
      else
        ce || (Ne.reading = !1, B(re, Ne));
    }
    return !Ne.ended && (Ne.length < Ne.highWaterMark || Ne.length === 0);
  }
  function P(re, O, j, ce) {
    O.flowing && O.length === 0 && !O.sync ? (O.awaitDrain = 0, re.emit("data", j)) : (O.length += O.objectMode ? 1 : j.length, ce ? O.buffer.unshift(j) : O.buffer.push(j), O.needReadable && U(re)), B(re, O);
  }
  function S(re, O) {
    var j;
    return !_(O) && typeof O != "string" && O !== void 0 && !re.objectMode && (j = new Y("chunk", ["string", "Buffer", "Uint8Array"], O)), j;
  }
  Z.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, Z.prototype.setEncoding = function(re) {
    ie || (ie = string_decoder.StringDecoder);
    var O = new ie(re);
    this._readableState.decoder = O, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var j = this._readableState.buffer.head, ce = ""; j !== null; )
      ce += O.write(j.data), j = j.next;
    return this._readableState.buffer.clear(), ce !== "" && this._readableState.buffer.push(ce), this._readableState.length = ce.length, this;
  };
  var E = 1073741824;
  function I(re) {
    return re >= E ? re = E : (re--, re |= re >>> 1, re |= re >>> 2, re |= re >>> 4, re |= re >>> 8, re |= re >>> 16, re++), re;
  }
  function N(re, O) {
    return re <= 0 || O.length === 0 && O.ended ? 0 : O.objectMode ? 1 : re !== re ? O.flowing && O.length ? O.buffer.head.data.length : O.length : (re > O.highWaterMark && (O.highWaterMark = I(re)), re <= O.length ? re : O.ended ? O.length : (O.needReadable = !0, 0));
  }
  Z.prototype.read = function(re) {
    M("read", re), re = parseInt(re, 10);
    var O = this._readableState, j = re;
    if (re !== 0 && (O.emittedReadable = !1), re === 0 && O.needReadable && ((O.highWaterMark !== 0 ? O.length >= O.highWaterMark : O.length > 0) || O.ended))
      return M("read: emitReadable", O.length, O.ended), O.length === 0 && O.ended ? Q(this) : U(this), null;
    if (re = N(re, O), re === 0 && O.ended)
      return O.length === 0 && Q(this), null;
    var ce = O.needReadable;
    M("need readable", ce), (O.length === 0 || O.length - re < O.highWaterMark) && (ce = !0, M("length less than watermark", ce)), O.ended || O.reading ? (ce = !1, M("reading or ended", ce)) : ce && (M("do read"), O.reading = !0, O.sync = !0, O.length === 0 && (O.needReadable = !0), this._read(O.highWaterMark), O.sync = !1, O.reading || (re = N(j, O)));
    var De;
    return re > 0 ? De = ve(re, O) : De = null, De === null ? (O.needReadable = O.length <= O.highWaterMark, re = 0) : (O.length -= re, O.awaitDrain = 0), O.length === 0 && (O.ended || (O.needReadable = !0), j !== re && O.ended && Q(this)), De !== null && this.emit("data", De), De;
  };
  function $(re, O) {
    if (M("onEofChunk"), !O.ended) {
      if (O.decoder) {
        var j = O.decoder.end();
        j && j.length && (O.buffer.push(j), O.length += O.objectMode ? 1 : j.length);
      }
      O.ended = !0, O.sync ? U(re) : (O.needReadable = !1, O.emittedReadable || (O.emittedReadable = !0, H(re)));
    }
  }
  function U(re) {
    var O = re._readableState;
    M("emitReadable", O.needReadable, O.emittedReadable), O.needReadable = !1, O.emittedReadable || (M("emitReadable", O.flowing), O.emittedReadable = !0, process$1.nextTick(H, re));
  }
  function H(re) {
    var O = re._readableState;
    M("emitReadable_", O.destroyed, O.length, O.ended), !O.destroyed && (O.length || O.ended) && (re.emit("readable"), O.emittedReadable = !1), O.needReadable = !O.flowing && !O.ended && O.length <= O.highWaterMark, he(re);
  }
  function B(re, O) {
    O.readingMore || (O.readingMore = !0, process$1.nextTick(T, re, O));
  }
  function T(re, O) {
    for (; !O.reading && !O.ended && (O.length < O.highWaterMark || O.flowing && O.length === 0); ) {
      var j = O.length;
      if (M("maybeReadMore read 0"), re.read(0), j === O.length)
        break;
    }
    O.readingMore = !1;
  }
  Z.prototype._read = function(re) {
    Ce(this, new ne("_read()"));
  }, Z.prototype.pipe = function(re, O) {
    var j = this, ce = this._readableState;
    switch (ce.pipesCount) {
      case 0:
        ce.pipes = re;
        break;
      case 1:
        ce.pipes = [ce.pipes, re];
        break;
      default:
        ce.pipes.push(re);
        break;
    }
    ce.pipesCount += 1, M("pipe count=%d opts=%j", ce.pipesCount, O);
    var De = (!O || O.end !== !1) && re !== process$1.stdout && re !== process$1.stderr, Ne = De ? Ze : We;
    ce.endEmitted ? process$1.nextTick(Ne) : j.once("end", Ne), re.on("unpipe", Fe);
    function Fe(Re, q) {
      M("onunpipe"), Re === j && q && q.hasUnpiped === !1 && (q.hasUnpiped = !0, Xe());
    }
    function Ze() {
      M("onend"), re.end();
    }
    var qe = D(j);
    re.on("drain", qe);
    var gt = !1;
    function Xe() {
      M("cleanup"), re.removeListener("close", ye), re.removeListener("finish", we), re.removeListener("drain", qe), re.removeListener("error", J), re.removeListener("unpipe", Fe), j.removeListener("end", Ze), j.removeListener("end", We), j.removeListener("data", Ge), gt = !0, ce.awaitDrain && (!re._writableState || re._writableState.needDrain) && qe();
    }
    j.on("data", Ge);
    function Ge(Re) {
      M("ondata");
      var q = re.write(Re);
      M("dest.write", q), q === !1 && ((ce.pipesCount === 1 && ce.pipes === re || ce.pipesCount > 1 && _e(ce.pipes, re) !== -1) && !gt && (M("false write response, pause", ce.awaitDrain), ce.awaitDrain++), j.pause());
    }
    function J(Re) {
      M("onerror", Re), We(), re.removeListener("error", J), u(re, "error") === 0 && Ce(re, Re);
    }
    Be(re, "error", J);
    function ye() {
      re.removeListener("finish", we), We();
    }
    re.once("close", ye);
    function we() {
      M("onfinish"), re.removeListener("close", ye), We();
    }
    re.once("finish", we);
    function We() {
      M("unpipe"), j.unpipe(re);
    }
    return re.emit("pipe", j), ce.flowing || (M("pipe resume"), j.resume()), re;
  };
  function D(re) {
    return function() {
      var j = re._readableState;
      M("pipeOnDrain", j.awaitDrain), j.awaitDrain && j.awaitDrain--, j.awaitDrain === 0 && u(re, "data") && (j.flowing = !0, he(re));
    };
  }
  Z.prototype.unpipe = function(re) {
    var O = this._readableState, j = {
      hasUnpiped: !1
    };
    if (O.pipesCount === 0)
      return this;
    if (O.pipesCount === 1)
      return re && re !== O.pipes ? this : (re || (re = O.pipes), O.pipes = null, O.pipesCount = 0, O.flowing = !1, re && re.emit("unpipe", this, j), this);
    if (!re) {
      var ce = O.pipes, De = O.pipesCount;
      O.pipes = null, O.pipesCount = 0, O.flowing = !1;
      for (var Ne = 0; Ne < De; Ne++)
        ce[Ne].emit("unpipe", this, {
          hasUnpiped: !1
        });
      return this;
    }
    var Fe = _e(O.pipes, re);
    return Fe === -1 ? this : (O.pipes.splice(Fe, 1), O.pipesCount -= 1, O.pipesCount === 1 && (O.pipes = O.pipes[0]), re.emit("unpipe", this, j), this);
  }, Z.prototype.on = function(re, O) {
    var j = c.prototype.on.call(this, re, O), ce = this._readableState;
    return re === "data" ? (ce.readableListening = this.listenerCount("readable") > 0, ce.flowing !== !1 && this.resume()) : re === "readable" && !ce.endEmitted && !ce.readableListening && (ce.readableListening = ce.needReadable = !0, ce.flowing = !1, ce.emittedReadable = !1, M("on readable", ce.length, ce.reading), ce.length ? U(this) : ce.reading || process$1.nextTick(pe, this)), j;
  }, Z.prototype.addListener = Z.prototype.on, Z.prototype.removeListener = function(re, O) {
    var j = c.prototype.removeListener.call(this, re, O);
    return re === "readable" && process$1.nextTick(ee, this), j;
  }, Z.prototype.removeAllListeners = function(re) {
    var O = c.prototype.removeAllListeners.apply(this, arguments);
    return (re === "readable" || re === void 0) && process$1.nextTick(ee, this), O;
  };
  function ee(re) {
    var O = re._readableState;
    O.readableListening = re.listenerCount("readable") > 0, O.resumeScheduled && !O.paused ? O.flowing = !0 : re.listenerCount("data") > 0 && re.resume();
  }
  function pe(re) {
    M("readable nexttick read 0"), re.read(0);
  }
  Z.prototype.resume = function() {
    var re = this._readableState;
    return re.flowing || (M("resume"), re.flowing = !re.readableListening, Ie(this, re)), re.paused = !1, this;
  };
  function Ie(re, O) {
    O.resumeScheduled || (O.resumeScheduled = !0, process$1.nextTick(Pe, re, O));
  }
  function Pe(re, O) {
    M("resume", O.reading), O.reading || re.read(0), O.resumeScheduled = !1, re.emit("resume"), he(re), O.flowing && !O.reading && re.read(0);
  }
  Z.prototype.pause = function() {
    return M("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (M("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function he(re) {
    var O = re._readableState;
    for (M("flow", O.flowing); O.flowing && re.read() !== null; )
      ;
  }
  Z.prototype.wrap = function(re) {
    var O = this, j = this._readableState, ce = !1;
    re.on("end", function() {
      if (M("wrapped end"), j.decoder && !j.ended) {
        var Fe = j.decoder.end();
        Fe && Fe.length && O.push(Fe);
      }
      O.push(null);
    }), re.on("data", function(Fe) {
      if (M("wrapped data"), j.decoder && (Fe = j.decoder.write(Fe)), !(j.objectMode && Fe == null) && !(!j.objectMode && (!Fe || !Fe.length))) {
        var Ze = O.push(Fe);
        Ze || (ce = !0, re.pause());
      }
    });
    for (var De in re)
      this[De] === void 0 && typeof re[De] == "function" && (this[De] = /* @__PURE__ */ function(Ze) {
        return function() {
          return re[Ze].apply(re, arguments);
        };
      }(De));
    for (var Ne = 0; Ne < Me.length; Ne++)
      re.on(Me[Ne], this.emit.bind(this, Me[Ne]));
    return this._read = function(Fe) {
      M("wrapped _read", Fe), ce && (ce = !1, re.resume());
    }, this;
  }, typeof Symbol == "function" && (Z.prototype[Symbol.asyncIterator] = function() {
    return ge === void 0 && (ge = requireAsync_iterator$2()), ge(this);
  }), Object.defineProperty(Z.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(Z.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(Z.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(O) {
      this._readableState && (this._readableState.flowing = O);
    }
  }), Z._fromList = ve, Object.defineProperty(Z.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function ve(re, O) {
    if (O.length === 0)
      return null;
    var j;
    return O.objectMode ? j = O.buffer.shift() : !re || re >= O.length ? (O.decoder ? j = O.buffer.join("") : O.buffer.length === 1 ? j = O.buffer.first() : j = O.buffer.concat(O.length), O.buffer.clear()) : j = O.buffer.consume(re, O.decoder), j;
  }
  function Q(re) {
    var O = re._readableState;
    M("endReadable", O.endEmitted), O.endEmitted || (O.ended = !0, process$1.nextTick(le, O, re));
  }
  function le(re, O) {
    if (M("endReadableNT", re.endEmitted, re.length), !re.endEmitted && re.length === 0 && (re.endEmitted = !0, O.readable = !1, O.emit("end"), re.autoDestroy)) {
      var j = O._writableState;
      (!j || j.autoDestroy && j.finished) && O.destroy();
    }
  }
  typeof Symbol == "function" && (Z.from = function(re, O) {
    return be === void 0 && (be = requireFromBrowser$2()), be(Z, re, O);
  });
  function _e(re, O) {
    for (var j = 0, ce = re.length; j < ce; j++)
      if (re[j] === O)
        return j;
    return -1;
  }
  return _stream_readable$2;
}
var _stream_transform$2, hasRequired_stream_transform;
function require_stream_transform() {
  if (hasRequired_stream_transform)
    return _stream_transform$2;
  hasRequired_stream_transform = 1, _stream_transform$2 = k;
  var a = requireErrorsBrowser().codes, u = a.ERR_METHOD_NOT_IMPLEMENTED, c = a.ERR_MULTIPLE_CALLBACK, l = a.ERR_TRANSFORM_ALREADY_TRANSFORMING, v = a.ERR_TRANSFORM_WITH_LENGTH_0, p = require_stream_duplex$2();
  inherits_browserExports(k, p);
  function _(F, V) {
    var X = this._transformState;
    X.transforming = !1;
    var oe = X.writecb;
    if (oe === null)
      return this.emit("error", new c());
    X.writechunk = null, X.writecb = null, V != null && this.push(V), oe(F);
    var Y = this._readableState;
    Y.reading = !1, (Y.needReadable || Y.length < Y.highWaterMark) && this._read(Y.highWaterMark);
  }
  function k(F) {
    if (!(this instanceof k))
      return new k(F);
    p.call(this, F), this._transformState = {
      afterTransform: _.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, F && (typeof F.transform == "function" && (this._transform = F.transform), typeof F.flush == "function" && (this._flush = F.flush)), this.on("prefinish", M);
  }
  function M() {
    var F = this;
    typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(V, X) {
      L(F, V, X);
    }) : L(this, null, null);
  }
  k.prototype.push = function(F, V) {
    return this._transformState.needTransform = !1, p.prototype.push.call(this, F, V);
  }, k.prototype._transform = function(F, V, X) {
    X(new u("_transform()"));
  }, k.prototype._write = function(F, V, X) {
    var oe = this._transformState;
    if (oe.writecb = X, oe.writechunk = F, oe.writeencoding = V, !oe.transforming) {
      var Y = this._readableState;
      (oe.needTransform || Y.needReadable || Y.length < Y.highWaterMark) && this._read(Y.highWaterMark);
    }
  }, k.prototype._read = function(F) {
    var V = this._transformState;
    V.writechunk !== null && !V.transforming ? (V.transforming = !0, this._transform(V.writechunk, V.writeencoding, V.afterTransform)) : V.needTransform = !0;
  }, k.prototype._destroy = function(F, V) {
    p.prototype._destroy.call(this, F, function(X) {
      V(X);
    });
  };
  function L(F, V, X) {
    if (V)
      return F.emit("error", V);
    if (X != null && F.push(X), F._writableState.length)
      throw new v();
    if (F._transformState.transforming)
      throw new l();
    return F.push(null);
  }
  return _stream_transform$2;
}
var _stream_passthrough$2, hasRequired_stream_passthrough;
function require_stream_passthrough() {
  if (hasRequired_stream_passthrough)
    return _stream_passthrough$2;
  hasRequired_stream_passthrough = 1, _stream_passthrough$2 = u;
  var a = require_stream_transform();
  inherits_browserExports(u, a);
  function u(c) {
    if (!(this instanceof u))
      return new u(c);
    a.call(this, c);
  }
  return u.prototype._transform = function(c, l, v) {
    v(null, c);
  }, _stream_passthrough$2;
}
var pipeline_1$2, hasRequiredPipeline;
function requirePipeline() {
  if (hasRequiredPipeline)
    return pipeline_1$2;
  hasRequiredPipeline = 1;
  var a;
  function u(X) {
    var oe = !1;
    return function() {
      oe || (oe = !0, X.apply(void 0, arguments));
    };
  }
  var c = requireErrorsBrowser().codes, l = c.ERR_MISSING_ARGS, v = c.ERR_STREAM_DESTROYED;
  function p(X) {
    if (X)
      throw X;
  }
  function _(X) {
    return X.setHeader && typeof X.abort == "function";
  }
  function k(X, oe, Y, ae) {
    ae = u(ae);
    var ne = !1;
    X.on("close", function() {
      ne = !0;
    }), a === void 0 && (a = requireEndOfStream()), a(X, {
      readable: oe,
      writable: Y
    }, function(ie) {
      if (ie)
        return ae(ie);
      ne = !0, ae();
    });
    var fe = !1;
    return function(ie) {
      if (!ne && !fe) {
        if (fe = !0, _(X))
          return X.abort();
        if (typeof X.destroy == "function")
          return X.destroy();
        ae(ie || new v("pipe"));
      }
    };
  }
  function M(X) {
    X();
  }
  function L(X, oe) {
    return X.pipe(oe);
  }
  function F(X) {
    return !X.length || typeof X[X.length - 1] != "function" ? p : X.pop();
  }
  function V() {
    for (var X = arguments.length, oe = new Array(X), Y = 0; Y < X; Y++)
      oe[Y] = arguments[Y];
    var ae = F(oe);
    if (Array.isArray(oe[0]) && (oe = oe[0]), oe.length < 2)
      throw new l("streams");
    var ne, fe = oe.map(function(ie, ge) {
      var be = ge < oe.length - 1, Ce = ge > 0;
      return k(ie, be, Ce, function(Me) {
        ne || (ne = Me), Me && fe.forEach(M), !be && (fe.forEach(M), ae(ne));
      });
    });
    return oe.reduce(L);
  }
  return pipeline_1$2 = V, pipeline_1$2;
}
var streamBrowserify = Stream$3, EE = eventsExports.EventEmitter, inherits$v = inherits_browserExports;
inherits$v(Stream$3, EE);
Stream$3.Readable = require_stream_readable$2();
Stream$3.Writable = require_stream_writable$2();
Stream$3.Duplex = require_stream_duplex$2();
Stream$3.Transform = require_stream_transform();
Stream$3.PassThrough = require_stream_passthrough();
Stream$3.finished = requireEndOfStream();
Stream$3.pipeline = requirePipeline();
Stream$3.Stream = Stream$3;
function Stream$3() {
  EE.call(this);
}
Stream$3.prototype.pipe = function(a, u) {
  var c = this;
  function l(F) {
    a.writable && a.write(F) === !1 && c.pause && c.pause();
  }
  c.on("data", l);
  function v() {
    c.readable && c.resume && c.resume();
  }
  a.on("drain", v), !a._isStdio && (!u || u.end !== !1) && (c.on("end", _), c.on("close", k));
  var p = !1;
  function _() {
    p || (p = !0, a.end());
  }
  function k() {
    p || (p = !0, typeof a.destroy == "function" && a.destroy());
  }
  function M(F) {
    if (L(), EE.listenerCount(this, "error") === 0)
      throw F;
  }
  c.on("error", M), a.on("error", M);
  function L() {
    c.removeListener("data", l), a.removeListener("drain", v), c.removeListener("end", _), c.removeListener("close", k), c.removeListener("error", M), a.removeListener("error", M), c.removeListener("end", L), c.removeListener("close", L), a.removeListener("close", L);
  }
  return c.on("end", L), c.on("close", L), a.on("close", L), a.emit("pipe", c), a;
};
var Buffer$K = safeBufferExports$3.Buffer, Stream$2 = streamBrowserify, util$3 = util$4;
function DataStream$2(a) {
  if (this.buffer = null, this.writable = !0, this.readable = !0, !a)
    return this.buffer = Buffer$K.alloc(0), this;
  if (typeof a.pipe == "function")
    return this.buffer = Buffer$K.alloc(0), a.pipe(this), this;
  if (a.length || typeof a == "object")
    return this.buffer = a, this.writable = !1, process$1.nextTick((function() {
      this.emit("end", a), this.readable = !1, this.emit("close");
    }).bind(this)), this;
  throw new TypeError("Unexpected data type (" + typeof a + ")");
}
util$3.inherits(DataStream$2, Stream$2);
DataStream$2.prototype.write = function a(u) {
  this.buffer = Buffer$K.concat([this.buffer, Buffer$K.from(u)]), this.emit("data", u);
};
DataStream$2.prototype.end = function a(u) {
  u && this.write(u), this.emit("end", u), this.emit("close"), this.writable = !1, this.readable = !1;
};
var dataStream = DataStream$2, Buffer$J = require$$0$2.Buffer, SlowBuffer = require$$0$2.SlowBuffer, bufferEqualConstantTime = bufferEq;
function bufferEq(a, u) {
  if (!Buffer$J.isBuffer(a) || !Buffer$J.isBuffer(u) || a.length !== u.length)
    return !1;
  for (var c = 0, l = 0; l < a.length; l++)
    c |= a[l] ^ u[l];
  return c === 0;
}
bufferEq.install = function() {
  Buffer$J.prototype.equal = SlowBuffer.prototype.equal = function(u) {
    return bufferEq(this, u);
  };
};
var origBufEqual = Buffer$J.prototype.equal, origSlowBufEqual = SlowBuffer.prototype.equal;
bufferEq.restore = function() {
  Buffer$J.prototype.equal = origBufEqual, SlowBuffer.prototype.equal = origSlowBufEqual;
};
var cryptoBrowserify = {}, browser$b = { exports: {} }, MAX_BYTES = 65536, MAX_UINT32 = 4294967295;
function oldBrowser$1() {
  throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
}
var Buffer$I = safeBufferExports$3.Buffer, crypto$3 = commonjsGlobal$1.crypto || commonjsGlobal$1.msCrypto;
crypto$3 && crypto$3.getRandomValues ? browser$b.exports = randomBytes$2 : browser$b.exports = oldBrowser$1;
function randomBytes$2(a, u) {
  if (a > MAX_UINT32)
    throw new RangeError("requested too many random bytes");
  var c = Buffer$I.allocUnsafe(a);
  if (a > 0)
    if (a > MAX_BYTES)
      for (var l = 0; l < a; l += MAX_BYTES)
        crypto$3.getRandomValues(c.slice(l, l + MAX_BYTES));
    else
      crypto$3.getRandomValues(c);
  return typeof u == "function" ? process$1.nextTick(function() {
    u(null, c);
  }) : c;
}
var browserExports = browser$b.exports, safeBuffer$2 = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(a, u) {
  var c = require$$0$2, l = c.Buffer;
  function v(_, k) {
    for (var M in _)
      k[M] = _[M];
  }
  l.from && l.alloc && l.allocUnsafe && l.allocUnsafeSlow ? a.exports = c : (v(c, u), u.Buffer = p);
  function p(_, k, M) {
    return l(_, k, M);
  }
  p.prototype = Object.create(l.prototype), v(l, p), p.from = function(_, k, M) {
    if (typeof _ == "number")
      throw new TypeError("Argument must not be a number");
    return l(_, k, M);
  }, p.alloc = function(_, k, M) {
    if (typeof _ != "number")
      throw new TypeError("Argument must be a number");
    var L = l(_);
    return k !== void 0 ? typeof M == "string" ? L.fill(k, M) : L.fill(k) : L.fill(0), L;
  }, p.allocUnsafe = function(_) {
    if (typeof _ != "number")
      throw new TypeError("Argument must be a number");
    return l(_);
  }, p.allocUnsafeSlow = function(_) {
    if (typeof _ != "number")
      throw new TypeError("Argument must be a number");
    return c.SlowBuffer(_);
  };
})(safeBuffer$2, safeBuffer$2.exports);
var safeBufferExports$1 = safeBuffer$2.exports, readableBrowser$1 = { exports: {} }, streamBrowser$1 = eventsExports.EventEmitter, buffer_list$1, hasRequiredBuffer_list$1;
function requireBuffer_list$1() {
  if (hasRequiredBuffer_list$1)
    return buffer_list$1;
  hasRequiredBuffer_list$1 = 1;
  function a(Y, ae) {
    var ne = Object.keys(Y);
    if (Object.getOwnPropertySymbols) {
      var fe = Object.getOwnPropertySymbols(Y);
      ae && (fe = fe.filter(function(ie) {
        return Object.getOwnPropertyDescriptor(Y, ie).enumerable;
      })), ne.push.apply(ne, fe);
    }
    return ne;
  }
  function u(Y) {
    for (var ae = 1; ae < arguments.length; ae++) {
      var ne = arguments[ae] != null ? arguments[ae] : {};
      ae % 2 ? a(Object(ne), !0).forEach(function(fe) {
        c(Y, fe, ne[fe]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(Y, Object.getOwnPropertyDescriptors(ne)) : a(Object(ne)).forEach(function(fe) {
        Object.defineProperty(Y, fe, Object.getOwnPropertyDescriptor(ne, fe));
      });
    }
    return Y;
  }
  function c(Y, ae, ne) {
    return ae = _(ae), ae in Y ? Object.defineProperty(Y, ae, { value: ne, enumerable: !0, configurable: !0, writable: !0 }) : Y[ae] = ne, Y;
  }
  function l(Y, ae) {
    if (!(Y instanceof ae))
      throw new TypeError("Cannot call a class as a function");
  }
  function v(Y, ae) {
    for (var ne = 0; ne < ae.length; ne++) {
      var fe = ae[ne];
      fe.enumerable = fe.enumerable || !1, fe.configurable = !0, "value" in fe && (fe.writable = !0), Object.defineProperty(Y, _(fe.key), fe);
    }
  }
  function p(Y, ae, ne) {
    return ae && v(Y.prototype, ae), ne && v(Y, ne), Object.defineProperty(Y, "prototype", { writable: !1 }), Y;
  }
  function _(Y) {
    var ae = k(Y, "string");
    return typeof ae == "symbol" ? ae : String(ae);
  }
  function k(Y, ae) {
    if (typeof Y != "object" || Y === null)
      return Y;
    var ne = Y[Symbol.toPrimitive];
    if (ne !== void 0) {
      var fe = ne.call(Y, ae || "default");
      if (typeof fe != "object")
        return fe;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (ae === "string" ? String : Number)(Y);
  }
  var M = require$$0$2, L = M.Buffer, F = util$4, V = F.inspect, X = V && V.custom || "inspect";
  function oe(Y, ae, ne) {
    L.prototype.copy.call(Y, ae, ne);
  }
  return buffer_list$1 = /* @__PURE__ */ function() {
    function Y() {
      l(this, Y), this.head = null, this.tail = null, this.length = 0;
    }
    return p(Y, [{
      key: "push",
      value: function(ne) {
        var fe = {
          data: ne,
          next: null
        };
        this.length > 0 ? this.tail.next = fe : this.head = fe, this.tail = fe, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(ne) {
        var fe = {
          data: ne,
          next: this.head
        };
        this.length === 0 && (this.tail = fe), this.head = fe, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var ne = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, ne;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(ne) {
        if (this.length === 0)
          return "";
        for (var fe = this.head, ie = "" + fe.data; fe = fe.next; )
          ie += ne + fe.data;
        return ie;
      }
    }, {
      key: "concat",
      value: function(ne) {
        if (this.length === 0)
          return L.alloc(0);
        for (var fe = L.allocUnsafe(ne >>> 0), ie = this.head, ge = 0; ie; )
          oe(ie.data, fe, ge), ge += ie.data.length, ie = ie.next;
        return fe;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(ne, fe) {
        var ie;
        return ne < this.head.data.length ? (ie = this.head.data.slice(0, ne), this.head.data = this.head.data.slice(ne)) : ne === this.head.data.length ? ie = this.shift() : ie = fe ? this._getString(ne) : this._getBuffer(ne), ie;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(ne) {
        var fe = this.head, ie = 1, ge = fe.data;
        for (ne -= ge.length; fe = fe.next; ) {
          var be = fe.data, Ce = ne > be.length ? be.length : ne;
          if (Ce === be.length ? ge += be : ge += be.slice(0, ne), ne -= Ce, ne === 0) {
            Ce === be.length ? (++ie, fe.next ? this.head = fe.next : this.head = this.tail = null) : (this.head = fe, fe.data = be.slice(Ce));
            break;
          }
          ++ie;
        }
        return this.length -= ie, ge;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(ne) {
        var fe = L.allocUnsafe(ne), ie = this.head, ge = 1;
        for (ie.data.copy(fe), ne -= ie.data.length; ie = ie.next; ) {
          var be = ie.data, Ce = ne > be.length ? be.length : ne;
          if (be.copy(fe, fe.length - ne, 0, Ce), ne -= Ce, ne === 0) {
            Ce === be.length ? (++ge, ie.next ? this.head = ie.next : this.head = this.tail = null) : (this.head = ie, ie.data = be.slice(Ce));
            break;
          }
          ++ge;
        }
        return this.length -= ge, fe;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: X,
      value: function(ne, fe) {
        return V(this, u(u({}, fe), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), Y;
  }(), buffer_list$1;
}
function destroy$1(a, u) {
  var c = this, l = this._readableState && this._readableState.destroyed, v = this._writableState && this._writableState.destroyed;
  return l || v ? (u ? u(a) : a && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process$1.nextTick(emitErrorNT$1, this, a)) : process$1.nextTick(emitErrorNT$1, this, a)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(a || null, function(p) {
    !u && p ? c._writableState ? c._writableState.errorEmitted ? process$1.nextTick(emitCloseNT$1, c) : (c._writableState.errorEmitted = !0, process$1.nextTick(emitErrorAndCloseNT$1, c, p)) : process$1.nextTick(emitErrorAndCloseNT$1, c, p) : u ? (process$1.nextTick(emitCloseNT$1, c), u(p)) : process$1.nextTick(emitCloseNT$1, c);
  }), this);
}
function emitErrorAndCloseNT$1(a, u) {
  emitErrorNT$1(a, u), emitCloseNT$1(a);
}
function emitCloseNT$1(a) {
  a._writableState && !a._writableState.emitClose || a._readableState && !a._readableState.emitClose || a.emit("close");
}
function undestroy$1() {
  this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
}
function emitErrorNT$1(a, u) {
  a.emit("error", u);
}
function errorOrDestroy$1(a, u) {
  var c = a._readableState, l = a._writableState;
  c && c.autoDestroy || l && l.autoDestroy ? a.destroy(u) : a.emit("error", u);
}
var destroy_1$1 = {
  destroy: destroy$1,
  undestroy: undestroy$1,
  errorOrDestroy: errorOrDestroy$1
}, errorsBrowser$1 = {};
function _inheritsLoose$2(a, u) {
  a.prototype = Object.create(u.prototype), a.prototype.constructor = a, a.__proto__ = u;
}
var codes$1 = {};
function createErrorType$1(a, u, c) {
  c || (c = Error);
  function l(p, _, k) {
    return typeof u == "string" ? u : u(p, _, k);
  }
  var v = /* @__PURE__ */ function(p) {
    _inheritsLoose$2(_, p);
    function _(k, M, L) {
      return p.call(this, l(k, M, L)) || this;
    }
    return _;
  }(c);
  v.prototype.name = c.name, v.prototype.code = a, codes$1[a] = v;
}
function oneOf$1(a, u) {
  if (Array.isArray(a)) {
    var c = a.length;
    return a = a.map(function(l) {
      return String(l);
    }), c > 2 ? "one of ".concat(u, " ").concat(a.slice(0, c - 1).join(", "), ", or ") + a[c - 1] : c === 2 ? "one of ".concat(u, " ").concat(a[0], " or ").concat(a[1]) : "of ".concat(u, " ").concat(a[0]);
  } else
    return "of ".concat(u, " ").concat(String(a));
}
function startsWith$1(a, u, c) {
  return a.substr(!c || c < 0 ? 0 : +c, u.length) === u;
}
function endsWith$1(a, u, c) {
  return (c === void 0 || c > a.length) && (c = a.length), a.substring(c - u.length, c) === u;
}
function includes$3(a, u, c) {
  return typeof c != "number" && (c = 0), c + u.length > a.length ? !1 : a.indexOf(u, c) !== -1;
}
createErrorType$1("ERR_INVALID_OPT_VALUE", function(a, u) {
  return 'The value "' + u + '" is invalid for option "' + a + '"';
}, TypeError);
createErrorType$1("ERR_INVALID_ARG_TYPE", function(a, u, c) {
  var l;
  typeof u == "string" && startsWith$1(u, "not ") ? (l = "must not be", u = u.replace(/^not /, "")) : l = "must be";
  var v;
  if (endsWith$1(a, " argument"))
    v = "The ".concat(a, " ").concat(l, " ").concat(oneOf$1(u, "type"));
  else {
    var p = includes$3(a, ".") ? "property" : "argument";
    v = 'The "'.concat(a, '" ').concat(p, " ").concat(l, " ").concat(oneOf$1(u, "type"));
  }
  return v += ". Received type ".concat(typeof c), v;
}, TypeError);
createErrorType$1("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
createErrorType$1("ERR_METHOD_NOT_IMPLEMENTED", function(a) {
  return "The " + a + " method is not implemented";
});
createErrorType$1("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
createErrorType$1("ERR_STREAM_DESTROYED", function(a) {
  return "Cannot call " + a + " after a stream was destroyed";
});
createErrorType$1("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
createErrorType$1("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
createErrorType$1("ERR_STREAM_WRITE_AFTER_END", "write after end");
createErrorType$1("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
createErrorType$1("ERR_UNKNOWN_ENCODING", function(a) {
  return "Unknown encoding: " + a;
}, TypeError);
createErrorType$1("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
errorsBrowser$1.codes = codes$1;
var ERR_INVALID_OPT_VALUE$1 = errorsBrowser$1.codes.ERR_INVALID_OPT_VALUE;
function highWaterMarkFrom$1(a, u, c) {
  return a.highWaterMark != null ? a.highWaterMark : u ? a[c] : null;
}
function getHighWaterMark$1(a, u, c, l) {
  var v = highWaterMarkFrom$1(u, l, c);
  if (v != null) {
    if (!(isFinite(v) && Math.floor(v) === v) || v < 0) {
      var p = l ? c : "highWaterMark";
      throw new ERR_INVALID_OPT_VALUE$1(p, v);
    }
    return Math.floor(v);
  }
  return a.objectMode ? 16 : 16 * 1024;
}
var state$4 = {
  getHighWaterMark: getHighWaterMark$1
}, _stream_writable$1, hasRequired_stream_writable$1;
function require_stream_writable$1() {
  if (hasRequired_stream_writable$1)
    return _stream_writable$1;
  hasRequired_stream_writable$1 = 1, _stream_writable$1 = Ae;
  function a(he) {
    var ve = this;
    this.next = null, this.entry = null, this.finish = function() {
      Pe(ve, he);
    };
  }
  var u;
  Ae.WritableState = Me;
  var c = {
    deprecate: browser$c
  }, l = streamBrowser$1, v = require$$0$2.Buffer, p = (typeof commonjsGlobal$1 < "u" ? commonjsGlobal$1 : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function _(he) {
    return v.from(he);
  }
  function k(he) {
    return v.isBuffer(he) || he instanceof p;
  }
  var M = destroy_1$1, L = state$4, F = L.getHighWaterMark, V = errorsBrowser$1.codes, X = V.ERR_INVALID_ARG_TYPE, oe = V.ERR_METHOD_NOT_IMPLEMENTED, Y = V.ERR_MULTIPLE_CALLBACK, ae = V.ERR_STREAM_CANNOT_PIPE, ne = V.ERR_STREAM_DESTROYED, fe = V.ERR_STREAM_NULL_VALUES, ie = V.ERR_STREAM_WRITE_AFTER_END, ge = V.ERR_UNKNOWN_ENCODING, be = M.errorOrDestroy;
  inherits_browserExports(Ae, l);
  function Ce() {
  }
  function Me(he, ve, Q) {
    u = u || require_stream_duplex$1(), he = he || {}, typeof Q != "boolean" && (Q = ve instanceof u), this.objectMode = !!he.objectMode, Q && (this.objectMode = this.objectMode || !!he.writableObjectMode), this.highWaterMark = F(this, he, "writableHighWaterMark", Q), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var le = he.decodeStrings === !1;
    this.decodeStrings = !le, this.defaultEncoding = he.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(_e) {
      $(ve, _e);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = he.emitClose !== !1, this.autoDestroy = !!he.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new a(this);
  }
  Me.prototype.getBuffer = function() {
    for (var ve = this.bufferedRequest, Q = []; ve; )
      Q.push(ve), ve = ve.next;
    return Q;
  }, function() {
    try {
      Object.defineProperty(Me.prototype, "buffer", {
        get: c.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var Be;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (Be = Function.prototype[Symbol.hasInstance], Object.defineProperty(Ae, Symbol.hasInstance, {
    value: function(ve) {
      return Be.call(this, ve) ? !0 : this !== Ae ? !1 : ve && ve._writableState instanceof Me;
    }
  })) : Be = function(ve) {
    return ve instanceof this;
  };
  function Ae(he) {
    u = u || require_stream_duplex$1();
    var ve = this instanceof u;
    if (!ve && !Be.call(Ae, this))
      return new Ae(he);
    this._writableState = new Me(he, this, ve), this.writable = !0, he && (typeof he.write == "function" && (this._write = he.write), typeof he.writev == "function" && (this._writev = he.writev), typeof he.destroy == "function" && (this._destroy = he.destroy), typeof he.final == "function" && (this._final = he.final)), l.call(this);
  }
  Ae.prototype.pipe = function() {
    be(this, new ae());
  };
  function Z(he, ve) {
    var Q = new ie();
    be(he, Q), process$1.nextTick(ve, Q);
  }
  function z(he, ve, Q, le) {
    var _e;
    return Q === null ? _e = new fe() : typeof Q != "string" && !ve.objectMode && (_e = new X("chunk", ["string", "Buffer"], Q)), _e ? (be(he, _e), process$1.nextTick(le, _e), !1) : !0;
  }
  Ae.prototype.write = function(he, ve, Q) {
    var le = this._writableState, _e = !1, re = !le.objectMode && k(he);
    return re && !v.isBuffer(he) && (he = _(he)), typeof ve == "function" && (Q = ve, ve = null), re ? ve = "buffer" : ve || (ve = le.defaultEncoding), typeof Q != "function" && (Q = Ce), le.ending ? Z(this, Q) : (re || z(this, le, he, Q)) && (le.pendingcb++, _e = S(this, le, re, he, ve, Q)), _e;
  }, Ae.prototype.cork = function() {
    this._writableState.corked++;
  }, Ae.prototype.uncork = function() {
    var he = this._writableState;
    he.corked && (he.corked--, !he.writing && !he.corked && !he.bufferProcessing && he.bufferedRequest && B(this, he));
  }, Ae.prototype.setDefaultEncoding = function(ve) {
    if (typeof ve == "string" && (ve = ve.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((ve + "").toLowerCase()) > -1))
      throw new ge(ve);
    return this._writableState.defaultEncoding = ve, this;
  }, Object.defineProperty(Ae.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function P(he, ve, Q) {
    return !he.objectMode && he.decodeStrings !== !1 && typeof ve == "string" && (ve = v.from(ve, Q)), ve;
  }
  Object.defineProperty(Ae.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function S(he, ve, Q, le, _e, re) {
    if (!Q) {
      var O = P(ve, le, _e);
      le !== O && (Q = !0, _e = "buffer", le = O);
    }
    var j = ve.objectMode ? 1 : le.length;
    ve.length += j;
    var ce = ve.length < ve.highWaterMark;
    if (ce || (ve.needDrain = !0), ve.writing || ve.corked) {
      var De = ve.lastBufferedRequest;
      ve.lastBufferedRequest = {
        chunk: le,
        encoding: _e,
        isBuf: Q,
        callback: re,
        next: null
      }, De ? De.next = ve.lastBufferedRequest : ve.bufferedRequest = ve.lastBufferedRequest, ve.bufferedRequestCount += 1;
    } else
      E(he, ve, !1, j, le, _e, re);
    return ce;
  }
  function E(he, ve, Q, le, _e, re, O) {
    ve.writelen = le, ve.writecb = O, ve.writing = !0, ve.sync = !0, ve.destroyed ? ve.onwrite(new ne("write")) : Q ? he._writev(_e, ve.onwrite) : he._write(_e, re, ve.onwrite), ve.sync = !1;
  }
  function I(he, ve, Q, le, _e) {
    --ve.pendingcb, Q ? (process$1.nextTick(_e, le), process$1.nextTick(pe, he, ve), he._writableState.errorEmitted = !0, be(he, le)) : (_e(le), he._writableState.errorEmitted = !0, be(he, le), pe(he, ve));
  }
  function N(he) {
    he.writing = !1, he.writecb = null, he.length -= he.writelen, he.writelen = 0;
  }
  function $(he, ve) {
    var Q = he._writableState, le = Q.sync, _e = Q.writecb;
    if (typeof _e != "function")
      throw new Y();
    if (N(Q), ve)
      I(he, Q, le, ve, _e);
    else {
      var re = T(Q) || he.destroyed;
      !re && !Q.corked && !Q.bufferProcessing && Q.bufferedRequest && B(he, Q), le ? process$1.nextTick(U, he, Q, re, _e) : U(he, Q, re, _e);
    }
  }
  function U(he, ve, Q, le) {
    Q || H(he, ve), ve.pendingcb--, le(), pe(he, ve);
  }
  function H(he, ve) {
    ve.length === 0 && ve.needDrain && (ve.needDrain = !1, he.emit("drain"));
  }
  function B(he, ve) {
    ve.bufferProcessing = !0;
    var Q = ve.bufferedRequest;
    if (he._writev && Q && Q.next) {
      var le = ve.bufferedRequestCount, _e = new Array(le), re = ve.corkedRequestsFree;
      re.entry = Q;
      for (var O = 0, j = !0; Q; )
        _e[O] = Q, Q.isBuf || (j = !1), Q = Q.next, O += 1;
      _e.allBuffers = j, E(he, ve, !0, ve.length, _e, "", re.finish), ve.pendingcb++, ve.lastBufferedRequest = null, re.next ? (ve.corkedRequestsFree = re.next, re.next = null) : ve.corkedRequestsFree = new a(ve), ve.bufferedRequestCount = 0;
    } else {
      for (; Q; ) {
        var ce = Q.chunk, De = Q.encoding, Ne = Q.callback, Fe = ve.objectMode ? 1 : ce.length;
        if (E(he, ve, !1, Fe, ce, De, Ne), Q = Q.next, ve.bufferedRequestCount--, ve.writing)
          break;
      }
      Q === null && (ve.lastBufferedRequest = null);
    }
    ve.bufferedRequest = Q, ve.bufferProcessing = !1;
  }
  Ae.prototype._write = function(he, ve, Q) {
    Q(new oe("_write()"));
  }, Ae.prototype._writev = null, Ae.prototype.end = function(he, ve, Q) {
    var le = this._writableState;
    return typeof he == "function" ? (Q = he, he = null, ve = null) : typeof ve == "function" && (Q = ve, ve = null), he != null && this.write(he, ve), le.corked && (le.corked = 1, this.uncork()), le.ending || Ie(this, le, Q), this;
  }, Object.defineProperty(Ae.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function T(he) {
    return he.ending && he.length === 0 && he.bufferedRequest === null && !he.finished && !he.writing;
  }
  function D(he, ve) {
    he._final(function(Q) {
      ve.pendingcb--, Q && be(he, Q), ve.prefinished = !0, he.emit("prefinish"), pe(he, ve);
    });
  }
  function ee(he, ve) {
    !ve.prefinished && !ve.finalCalled && (typeof he._final == "function" && !ve.destroyed ? (ve.pendingcb++, ve.finalCalled = !0, process$1.nextTick(D, he, ve)) : (ve.prefinished = !0, he.emit("prefinish")));
  }
  function pe(he, ve) {
    var Q = T(ve);
    if (Q && (ee(he, ve), ve.pendingcb === 0 && (ve.finished = !0, he.emit("finish"), ve.autoDestroy))) {
      var le = he._readableState;
      (!le || le.autoDestroy && le.endEmitted) && he.destroy();
    }
    return Q;
  }
  function Ie(he, ve, Q) {
    ve.ending = !0, pe(he, ve), Q && (ve.finished ? process$1.nextTick(Q) : he.once("finish", Q)), ve.ended = !0, he.writable = !1;
  }
  function Pe(he, ve, Q) {
    var le = he.entry;
    for (he.entry = null; le; ) {
      var _e = le.callback;
      ve.pendingcb--, _e(Q), le = le.next;
    }
    ve.corkedRequestsFree.next = he;
  }
  return Object.defineProperty(Ae.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(ve) {
      this._writableState && (this._writableState.destroyed = ve);
    }
  }), Ae.prototype.destroy = M.destroy, Ae.prototype._undestroy = M.undestroy, Ae.prototype._destroy = function(he, ve) {
    ve(he);
  }, _stream_writable$1;
}
var _stream_duplex$1, hasRequired_stream_duplex$1;
function require_stream_duplex$1() {
  if (hasRequired_stream_duplex$1)
    return _stream_duplex$1;
  hasRequired_stream_duplex$1 = 1;
  var a = Object.keys || function(L) {
    var F = [];
    for (var V in L)
      F.push(V);
    return F;
  };
  _stream_duplex$1 = _;
  var u = require_stream_readable$1(), c = require_stream_writable$1();
  inherits_browserExports(_, u);
  for (var l = a(c.prototype), v = 0; v < l.length; v++) {
    var p = l[v];
    _.prototype[p] || (_.prototype[p] = c.prototype[p]);
  }
  function _(L) {
    if (!(this instanceof _))
      return new _(L);
    u.call(this, L), c.call(this, L), this.allowHalfOpen = !0, L && (L.readable === !1 && (this.readable = !1), L.writable === !1 && (this.writable = !1), L.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", k)));
  }
  Object.defineProperty(_.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(_.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(_.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function k() {
    this._writableState.ended || process$1.nextTick(M, this);
  }
  function M(L) {
    L.end();
  }
  return Object.defineProperty(_.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(F) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = F, this._writableState.destroyed = F);
    }
  }), _stream_duplex$1;
}
var ERR_STREAM_PREMATURE_CLOSE$1 = errorsBrowser$1.codes.ERR_STREAM_PREMATURE_CLOSE;
function once$5(a) {
  var u = !1;
  return function() {
    if (!u) {
      u = !0;
      for (var c = arguments.length, l = new Array(c), v = 0; v < c; v++)
        l[v] = arguments[v];
      a.apply(this, l);
    }
  };
}
function noop$4() {
}
function isRequest$3(a) {
  return a.setHeader && typeof a.abort == "function";
}
function eos$3(a, u, c) {
  if (typeof u == "function")
    return eos$3(a, null, u);
  u || (u = {}), c = once$5(c || noop$4);
  var l = u.readable || u.readable !== !1 && a.readable, v = u.writable || u.writable !== !1 && a.writable, p = function() {
    a.writable || k();
  }, _ = a._writableState && a._writableState.finished, k = function() {
    v = !1, _ = !0, l || c.call(a);
  }, M = a._readableState && a._readableState.endEmitted, L = function() {
    l = !1, M = !0, v || c.call(a);
  }, F = function(Y) {
    c.call(a, Y);
  }, V = function() {
    var Y;
    if (l && !M)
      return (!a._readableState || !a._readableState.ended) && (Y = new ERR_STREAM_PREMATURE_CLOSE$1()), c.call(a, Y);
    if (v && !_)
      return (!a._writableState || !a._writableState.ended) && (Y = new ERR_STREAM_PREMATURE_CLOSE$1()), c.call(a, Y);
  }, X = function() {
    a.req.on("finish", k);
  };
  return isRequest$3(a) ? (a.on("complete", k), a.on("abort", V), a.req ? X() : a.on("request", X)) : v && !a._writableState && (a.on("end", p), a.on("close", p)), a.on("end", L), a.on("finish", k), u.error !== !1 && a.on("error", F), a.on("close", V), function() {
    a.removeListener("complete", k), a.removeListener("abort", V), a.removeListener("request", X), a.req && a.req.removeListener("finish", k), a.removeListener("end", p), a.removeListener("close", p), a.removeListener("finish", k), a.removeListener("end", L), a.removeListener("error", F), a.removeListener("close", V);
  };
}
var endOfStream$1 = eos$3, async_iterator$1, hasRequiredAsync_iterator$1;
function requireAsync_iterator$1() {
  if (hasRequiredAsync_iterator$1)
    return async_iterator$1;
  hasRequiredAsync_iterator$1 = 1;
  var a;
  function u(ge, be, Ce) {
    return be = c(be), be in ge ? Object.defineProperty(ge, be, { value: Ce, enumerable: !0, configurable: !0, writable: !0 }) : ge[be] = Ce, ge;
  }
  function c(ge) {
    var be = l(ge, "string");
    return typeof be == "symbol" ? be : String(be);
  }
  function l(ge, be) {
    if (typeof ge != "object" || ge === null)
      return ge;
    var Ce = ge[Symbol.toPrimitive];
    if (Ce !== void 0) {
      var Me = Ce.call(ge, be || "default");
      if (typeof Me != "object")
        return Me;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (be === "string" ? String : Number)(ge);
  }
  var v = endOfStream$1, p = Symbol("lastResolve"), _ = Symbol("lastReject"), k = Symbol("error"), M = Symbol("ended"), L = Symbol("lastPromise"), F = Symbol("handlePromise"), V = Symbol("stream");
  function X(ge, be) {
    return {
      value: ge,
      done: be
    };
  }
  function oe(ge) {
    var be = ge[p];
    if (be !== null) {
      var Ce = ge[V].read();
      Ce !== null && (ge[L] = null, ge[p] = null, ge[_] = null, be(X(Ce, !1)));
    }
  }
  function Y(ge) {
    process$1.nextTick(oe, ge);
  }
  function ae(ge, be) {
    return function(Ce, Me) {
      ge.then(function() {
        if (be[M]) {
          Ce(X(void 0, !0));
          return;
        }
        be[F](Ce, Me);
      }, Me);
    };
  }
  var ne = Object.getPrototypeOf(function() {
  }), fe = Object.setPrototypeOf((a = {
    get stream() {
      return this[V];
    },
    next: function() {
      var be = this, Ce = this[k];
      if (Ce !== null)
        return Promise.reject(Ce);
      if (this[M])
        return Promise.resolve(X(void 0, !0));
      if (this[V].destroyed)
        return new Promise(function(Z, z) {
          process$1.nextTick(function() {
            be[k] ? z(be[k]) : Z(X(void 0, !0));
          });
        });
      var Me = this[L], Be;
      if (Me)
        Be = new Promise(ae(Me, this));
      else {
        var Ae = this[V].read();
        if (Ae !== null)
          return Promise.resolve(X(Ae, !1));
        Be = new Promise(this[F]);
      }
      return this[L] = Be, Be;
    }
  }, u(a, Symbol.asyncIterator, function() {
    return this;
  }), u(a, "return", function() {
    var be = this;
    return new Promise(function(Ce, Me) {
      be[V].destroy(null, function(Be) {
        if (Be) {
          Me(Be);
          return;
        }
        Ce(X(void 0, !0));
      });
    });
  }), a), ne), ie = function(be) {
    var Ce, Me = Object.create(fe, (Ce = {}, u(Ce, V, {
      value: be,
      writable: !0
    }), u(Ce, p, {
      value: null,
      writable: !0
    }), u(Ce, _, {
      value: null,
      writable: !0
    }), u(Ce, k, {
      value: null,
      writable: !0
    }), u(Ce, M, {
      value: be._readableState.endEmitted,
      writable: !0
    }), u(Ce, F, {
      value: function(Ae, Z) {
        var z = Me[V].read();
        z ? (Me[L] = null, Me[p] = null, Me[_] = null, Ae(X(z, !1))) : (Me[p] = Ae, Me[_] = Z);
      },
      writable: !0
    }), Ce));
    return Me[L] = null, v(be, function(Be) {
      if (Be && Be.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var Ae = Me[_];
        Ae !== null && (Me[L] = null, Me[p] = null, Me[_] = null, Ae(Be)), Me[k] = Be;
        return;
      }
      var Z = Me[p];
      Z !== null && (Me[L] = null, Me[p] = null, Me[_] = null, Z(X(void 0, !0))), Me[M] = !0;
    }), be.on("readable", Y.bind(null, Me)), Me;
  };
  return async_iterator$1 = ie, async_iterator$1;
}
var fromBrowser$1, hasRequiredFromBrowser$1;
function requireFromBrowser$1() {
  return hasRequiredFromBrowser$1 || (hasRequiredFromBrowser$1 = 1, fromBrowser$1 = function() {
    throw new Error("Readable.from is not available in the browser");
  }), fromBrowser$1;
}
var _stream_readable$1, hasRequired_stream_readable$1;
function require_stream_readable$1() {
  if (hasRequired_stream_readable$1)
    return _stream_readable$1;
  hasRequired_stream_readable$1 = 1, _stream_readable$1 = Z;
  var a;
  Z.ReadableState = Ae, eventsExports.EventEmitter;
  var u = function(O, j) {
    return O.listeners(j).length;
  }, c = streamBrowser$1, l = require$$0$2.Buffer, v = (typeof commonjsGlobal$1 < "u" ? commonjsGlobal$1 : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function p(re) {
    return l.from(re);
  }
  function _(re) {
    return l.isBuffer(re) || re instanceof v;
  }
  var k = util$4, M;
  k && k.debuglog ? M = k.debuglog("stream") : M = function() {
  };
  var L = requireBuffer_list$1(), F = destroy_1$1, V = state$4, X = V.getHighWaterMark, oe = errorsBrowser$1.codes, Y = oe.ERR_INVALID_ARG_TYPE, ae = oe.ERR_STREAM_PUSH_AFTER_EOF, ne = oe.ERR_METHOD_NOT_IMPLEMENTED, fe = oe.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, ie, ge, be;
  inherits_browserExports(Z, c);
  var Ce = F.errorOrDestroy, Me = ["error", "close", "destroy", "pause", "resume"];
  function Be(re, O, j) {
    if (typeof re.prependListener == "function")
      return re.prependListener(O, j);
    !re._events || !re._events[O] ? re.on(O, j) : Array.isArray(re._events[O]) ? re._events[O].unshift(j) : re._events[O] = [j, re._events[O]];
  }
  function Ae(re, O, j) {
    a = a || require_stream_duplex$1(), re = re || {}, typeof j != "boolean" && (j = O instanceof a), this.objectMode = !!re.objectMode, j && (this.objectMode = this.objectMode || !!re.readableObjectMode), this.highWaterMark = X(this, re, "readableHighWaterMark", j), this.buffer = new L(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = re.emitClose !== !1, this.autoDestroy = !!re.autoDestroy, this.destroyed = !1, this.defaultEncoding = re.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, re.encoding && (ie || (ie = string_decoder.StringDecoder), this.decoder = new ie(re.encoding), this.encoding = re.encoding);
  }
  function Z(re) {
    if (a = a || require_stream_duplex$1(), !(this instanceof Z))
      return new Z(re);
    var O = this instanceof a;
    this._readableState = new Ae(re, this, O), this.readable = !0, re && (typeof re.read == "function" && (this._read = re.read), typeof re.destroy == "function" && (this._destroy = re.destroy)), c.call(this);
  }
  Object.defineProperty(Z.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(O) {
      this._readableState && (this._readableState.destroyed = O);
    }
  }), Z.prototype.destroy = F.destroy, Z.prototype._undestroy = F.undestroy, Z.prototype._destroy = function(re, O) {
    O(re);
  }, Z.prototype.push = function(re, O) {
    var j = this._readableState, ce;
    return j.objectMode ? ce = !0 : typeof re == "string" && (O = O || j.defaultEncoding, O !== j.encoding && (re = l.from(re, O), O = ""), ce = !0), z(this, re, O, !1, ce);
  }, Z.prototype.unshift = function(re) {
    return z(this, re, null, !0, !1);
  };
  function z(re, O, j, ce, De) {
    M("readableAddChunk", O);
    var Ne = re._readableState;
    if (O === null)
      Ne.reading = !1, $(re, Ne);
    else {
      var Fe;
      if (De || (Fe = S(Ne, O)), Fe)
        Ce(re, Fe);
      else if (Ne.objectMode || O && O.length > 0)
        if (typeof O != "string" && !Ne.objectMode && Object.getPrototypeOf(O) !== l.prototype && (O = p(O)), ce)
          Ne.endEmitted ? Ce(re, new fe()) : P(re, Ne, O, !0);
        else if (Ne.ended)
          Ce(re, new ae());
        else {
          if (Ne.destroyed)
            return !1;
          Ne.reading = !1, Ne.decoder && !j ? (O = Ne.decoder.write(O), Ne.objectMode || O.length !== 0 ? P(re, Ne, O, !1) : B(re, Ne)) : P(re, Ne, O, !1);
        }
      else
        ce || (Ne.reading = !1, B(re, Ne));
    }
    return !Ne.ended && (Ne.length < Ne.highWaterMark || Ne.length === 0);
  }
  function P(re, O, j, ce) {
    O.flowing && O.length === 0 && !O.sync ? (O.awaitDrain = 0, re.emit("data", j)) : (O.length += O.objectMode ? 1 : j.length, ce ? O.buffer.unshift(j) : O.buffer.push(j), O.needReadable && U(re)), B(re, O);
  }
  function S(re, O) {
    var j;
    return !_(O) && typeof O != "string" && O !== void 0 && !re.objectMode && (j = new Y("chunk", ["string", "Buffer", "Uint8Array"], O)), j;
  }
  Z.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, Z.prototype.setEncoding = function(re) {
    ie || (ie = string_decoder.StringDecoder);
    var O = new ie(re);
    this._readableState.decoder = O, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var j = this._readableState.buffer.head, ce = ""; j !== null; )
      ce += O.write(j.data), j = j.next;
    return this._readableState.buffer.clear(), ce !== "" && this._readableState.buffer.push(ce), this._readableState.length = ce.length, this;
  };
  var E = 1073741824;
  function I(re) {
    return re >= E ? re = E : (re--, re |= re >>> 1, re |= re >>> 2, re |= re >>> 4, re |= re >>> 8, re |= re >>> 16, re++), re;
  }
  function N(re, O) {
    return re <= 0 || O.length === 0 && O.ended ? 0 : O.objectMode ? 1 : re !== re ? O.flowing && O.length ? O.buffer.head.data.length : O.length : (re > O.highWaterMark && (O.highWaterMark = I(re)), re <= O.length ? re : O.ended ? O.length : (O.needReadable = !0, 0));
  }
  Z.prototype.read = function(re) {
    M("read", re), re = parseInt(re, 10);
    var O = this._readableState, j = re;
    if (re !== 0 && (O.emittedReadable = !1), re === 0 && O.needReadable && ((O.highWaterMark !== 0 ? O.length >= O.highWaterMark : O.length > 0) || O.ended))
      return M("read: emitReadable", O.length, O.ended), O.length === 0 && O.ended ? Q(this) : U(this), null;
    if (re = N(re, O), re === 0 && O.ended)
      return O.length === 0 && Q(this), null;
    var ce = O.needReadable;
    M("need readable", ce), (O.length === 0 || O.length - re < O.highWaterMark) && (ce = !0, M("length less than watermark", ce)), O.ended || O.reading ? (ce = !1, M("reading or ended", ce)) : ce && (M("do read"), O.reading = !0, O.sync = !0, O.length === 0 && (O.needReadable = !0), this._read(O.highWaterMark), O.sync = !1, O.reading || (re = N(j, O)));
    var De;
    return re > 0 ? De = ve(re, O) : De = null, De === null ? (O.needReadable = O.length <= O.highWaterMark, re = 0) : (O.length -= re, O.awaitDrain = 0), O.length === 0 && (O.ended || (O.needReadable = !0), j !== re && O.ended && Q(this)), De !== null && this.emit("data", De), De;
  };
  function $(re, O) {
    if (M("onEofChunk"), !O.ended) {
      if (O.decoder) {
        var j = O.decoder.end();
        j && j.length && (O.buffer.push(j), O.length += O.objectMode ? 1 : j.length);
      }
      O.ended = !0, O.sync ? U(re) : (O.needReadable = !1, O.emittedReadable || (O.emittedReadable = !0, H(re)));
    }
  }
  function U(re) {
    var O = re._readableState;
    M("emitReadable", O.needReadable, O.emittedReadable), O.needReadable = !1, O.emittedReadable || (M("emitReadable", O.flowing), O.emittedReadable = !0, process$1.nextTick(H, re));
  }
  function H(re) {
    var O = re._readableState;
    M("emitReadable_", O.destroyed, O.length, O.ended), !O.destroyed && (O.length || O.ended) && (re.emit("readable"), O.emittedReadable = !1), O.needReadable = !O.flowing && !O.ended && O.length <= O.highWaterMark, he(re);
  }
  function B(re, O) {
    O.readingMore || (O.readingMore = !0, process$1.nextTick(T, re, O));
  }
  function T(re, O) {
    for (; !O.reading && !O.ended && (O.length < O.highWaterMark || O.flowing && O.length === 0); ) {
      var j = O.length;
      if (M("maybeReadMore read 0"), re.read(0), j === O.length)
        break;
    }
    O.readingMore = !1;
  }
  Z.prototype._read = function(re) {
    Ce(this, new ne("_read()"));
  }, Z.prototype.pipe = function(re, O) {
    var j = this, ce = this._readableState;
    switch (ce.pipesCount) {
      case 0:
        ce.pipes = re;
        break;
      case 1:
        ce.pipes = [ce.pipes, re];
        break;
      default:
        ce.pipes.push(re);
        break;
    }
    ce.pipesCount += 1, M("pipe count=%d opts=%j", ce.pipesCount, O);
    var De = (!O || O.end !== !1) && re !== process$1.stdout && re !== process$1.stderr, Ne = De ? Ze : We;
    ce.endEmitted ? process$1.nextTick(Ne) : j.once("end", Ne), re.on("unpipe", Fe);
    function Fe(Re, q) {
      M("onunpipe"), Re === j && q && q.hasUnpiped === !1 && (q.hasUnpiped = !0, Xe());
    }
    function Ze() {
      M("onend"), re.end();
    }
    var qe = D(j);
    re.on("drain", qe);
    var gt = !1;
    function Xe() {
      M("cleanup"), re.removeListener("close", ye), re.removeListener("finish", we), re.removeListener("drain", qe), re.removeListener("error", J), re.removeListener("unpipe", Fe), j.removeListener("end", Ze), j.removeListener("end", We), j.removeListener("data", Ge), gt = !0, ce.awaitDrain && (!re._writableState || re._writableState.needDrain) && qe();
    }
    j.on("data", Ge);
    function Ge(Re) {
      M("ondata");
      var q = re.write(Re);
      M("dest.write", q), q === !1 && ((ce.pipesCount === 1 && ce.pipes === re || ce.pipesCount > 1 && _e(ce.pipes, re) !== -1) && !gt && (M("false write response, pause", ce.awaitDrain), ce.awaitDrain++), j.pause());
    }
    function J(Re) {
      M("onerror", Re), We(), re.removeListener("error", J), u(re, "error") === 0 && Ce(re, Re);
    }
    Be(re, "error", J);
    function ye() {
      re.removeListener("finish", we), We();
    }
    re.once("close", ye);
    function we() {
      M("onfinish"), re.removeListener("close", ye), We();
    }
    re.once("finish", we);
    function We() {
      M("unpipe"), j.unpipe(re);
    }
    return re.emit("pipe", j), ce.flowing || (M("pipe resume"), j.resume()), re;
  };
  function D(re) {
    return function() {
      var j = re._readableState;
      M("pipeOnDrain", j.awaitDrain), j.awaitDrain && j.awaitDrain--, j.awaitDrain === 0 && u(re, "data") && (j.flowing = !0, he(re));
    };
  }
  Z.prototype.unpipe = function(re) {
    var O = this._readableState, j = {
      hasUnpiped: !1
    };
    if (O.pipesCount === 0)
      return this;
    if (O.pipesCount === 1)
      return re && re !== O.pipes ? this : (re || (re = O.pipes), O.pipes = null, O.pipesCount = 0, O.flowing = !1, re && re.emit("unpipe", this, j), this);
    if (!re) {
      var ce = O.pipes, De = O.pipesCount;
      O.pipes = null, O.pipesCount = 0, O.flowing = !1;
      for (var Ne = 0; Ne < De; Ne++)
        ce[Ne].emit("unpipe", this, {
          hasUnpiped: !1
        });
      return this;
    }
    var Fe = _e(O.pipes, re);
    return Fe === -1 ? this : (O.pipes.splice(Fe, 1), O.pipesCount -= 1, O.pipesCount === 1 && (O.pipes = O.pipes[0]), re.emit("unpipe", this, j), this);
  }, Z.prototype.on = function(re, O) {
    var j = c.prototype.on.call(this, re, O), ce = this._readableState;
    return re === "data" ? (ce.readableListening = this.listenerCount("readable") > 0, ce.flowing !== !1 && this.resume()) : re === "readable" && !ce.endEmitted && !ce.readableListening && (ce.readableListening = ce.needReadable = !0, ce.flowing = !1, ce.emittedReadable = !1, M("on readable", ce.length, ce.reading), ce.length ? U(this) : ce.reading || process$1.nextTick(pe, this)), j;
  }, Z.prototype.addListener = Z.prototype.on, Z.prototype.removeListener = function(re, O) {
    var j = c.prototype.removeListener.call(this, re, O);
    return re === "readable" && process$1.nextTick(ee, this), j;
  }, Z.prototype.removeAllListeners = function(re) {
    var O = c.prototype.removeAllListeners.apply(this, arguments);
    return (re === "readable" || re === void 0) && process$1.nextTick(ee, this), O;
  };
  function ee(re) {
    var O = re._readableState;
    O.readableListening = re.listenerCount("readable") > 0, O.resumeScheduled && !O.paused ? O.flowing = !0 : re.listenerCount("data") > 0 && re.resume();
  }
  function pe(re) {
    M("readable nexttick read 0"), re.read(0);
  }
  Z.prototype.resume = function() {
    var re = this._readableState;
    return re.flowing || (M("resume"), re.flowing = !re.readableListening, Ie(this, re)), re.paused = !1, this;
  };
  function Ie(re, O) {
    O.resumeScheduled || (O.resumeScheduled = !0, process$1.nextTick(Pe, re, O));
  }
  function Pe(re, O) {
    M("resume", O.reading), O.reading || re.read(0), O.resumeScheduled = !1, re.emit("resume"), he(re), O.flowing && !O.reading && re.read(0);
  }
  Z.prototype.pause = function() {
    return M("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (M("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function he(re) {
    var O = re._readableState;
    for (M("flow", O.flowing); O.flowing && re.read() !== null; )
      ;
  }
  Z.prototype.wrap = function(re) {
    var O = this, j = this._readableState, ce = !1;
    re.on("end", function() {
      if (M("wrapped end"), j.decoder && !j.ended) {
        var Fe = j.decoder.end();
        Fe && Fe.length && O.push(Fe);
      }
      O.push(null);
    }), re.on("data", function(Fe) {
      if (M("wrapped data"), j.decoder && (Fe = j.decoder.write(Fe)), !(j.objectMode && Fe == null) && !(!j.objectMode && (!Fe || !Fe.length))) {
        var Ze = O.push(Fe);
        Ze || (ce = !0, re.pause());
      }
    });
    for (var De in re)
      this[De] === void 0 && typeof re[De] == "function" && (this[De] = /* @__PURE__ */ function(Ze) {
        return function() {
          return re[Ze].apply(re, arguments);
        };
      }(De));
    for (var Ne = 0; Ne < Me.length; Ne++)
      re.on(Me[Ne], this.emit.bind(this, Me[Ne]));
    return this._read = function(Fe) {
      M("wrapped _read", Fe), ce && (ce = !1, re.resume());
    }, this;
  }, typeof Symbol == "function" && (Z.prototype[Symbol.asyncIterator] = function() {
    return ge === void 0 && (ge = requireAsync_iterator$1()), ge(this);
  }), Object.defineProperty(Z.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(Z.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(Z.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(O) {
      this._readableState && (this._readableState.flowing = O);
    }
  }), Z._fromList = ve, Object.defineProperty(Z.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function ve(re, O) {
    if (O.length === 0)
      return null;
    var j;
    return O.objectMode ? j = O.buffer.shift() : !re || re >= O.length ? (O.decoder ? j = O.buffer.join("") : O.buffer.length === 1 ? j = O.buffer.first() : j = O.buffer.concat(O.length), O.buffer.clear()) : j = O.buffer.consume(re, O.decoder), j;
  }
  function Q(re) {
    var O = re._readableState;
    M("endReadable", O.endEmitted), O.endEmitted || (O.ended = !0, process$1.nextTick(le, O, re));
  }
  function le(re, O) {
    if (M("endReadableNT", re.endEmitted, re.length), !re.endEmitted && re.length === 0 && (re.endEmitted = !0, O.readable = !1, O.emit("end"), re.autoDestroy)) {
      var j = O._writableState;
      (!j || j.autoDestroy && j.finished) && O.destroy();
    }
  }
  typeof Symbol == "function" && (Z.from = function(re, O) {
    return be === void 0 && (be = requireFromBrowser$1()), be(Z, re, O);
  });
  function _e(re, O) {
    for (var j = 0, ce = re.length; j < ce; j++)
      if (re[j] === O)
        return j;
    return -1;
  }
  return _stream_readable$1;
}
var _stream_transform$1 = Transform$9, _require$codes$3 = errorsBrowser$1.codes, ERR_METHOD_NOT_IMPLEMENTED$1 = _require$codes$3.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK$1 = _require$codes$3.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING$1 = _require$codes$3.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0$1 = _require$codes$3.ERR_TRANSFORM_WITH_LENGTH_0, Duplex$1 = require_stream_duplex$1();
inherits_browserExports(Transform$9, Duplex$1);
function afterTransform$1(a, u) {
  var c = this._transformState;
  c.transforming = !1;
  var l = c.writecb;
  if (l === null)
    return this.emit("error", new ERR_MULTIPLE_CALLBACK$1());
  c.writechunk = null, c.writecb = null, u != null && this.push(u), l(a);
  var v = this._readableState;
  v.reading = !1, (v.needReadable || v.length < v.highWaterMark) && this._read(v.highWaterMark);
}
function Transform$9(a) {
  if (!(this instanceof Transform$9))
    return new Transform$9(a);
  Duplex$1.call(this, a), this._transformState = {
    afterTransform: afterTransform$1.bind(this),
    needTransform: !1,
    transforming: !1,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }, this._readableState.needReadable = !0, this._readableState.sync = !1, a && (typeof a.transform == "function" && (this._transform = a.transform), typeof a.flush == "function" && (this._flush = a.flush)), this.on("prefinish", prefinish$1);
}
function prefinish$1() {
  var a = this;
  typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(u, c) {
    done$1(a, u, c);
  }) : done$1(this, null, null);
}
Transform$9.prototype.push = function(a, u) {
  return this._transformState.needTransform = !1, Duplex$1.prototype.push.call(this, a, u);
};
Transform$9.prototype._transform = function(a, u, c) {
  c(new ERR_METHOD_NOT_IMPLEMENTED$1("_transform()"));
};
Transform$9.prototype._write = function(a, u, c) {
  var l = this._transformState;
  if (l.writecb = c, l.writechunk = a, l.writeencoding = u, !l.transforming) {
    var v = this._readableState;
    (l.needTransform || v.needReadable || v.length < v.highWaterMark) && this._read(v.highWaterMark);
  }
};
Transform$9.prototype._read = function(a) {
  var u = this._transformState;
  u.writechunk !== null && !u.transforming ? (u.transforming = !0, this._transform(u.writechunk, u.writeencoding, u.afterTransform)) : u.needTransform = !0;
};
Transform$9.prototype._destroy = function(a, u) {
  Duplex$1.prototype._destroy.call(this, a, function(c) {
    u(c);
  });
};
function done$1(a, u, c) {
  if (u)
    return a.emit("error", u);
  if (c != null && a.push(c), a._writableState.length)
    throw new ERR_TRANSFORM_WITH_LENGTH_0$1();
  if (a._transformState.transforming)
    throw new ERR_TRANSFORM_ALREADY_TRANSFORMING$1();
  return a.push(null);
}
var _stream_passthrough$1 = PassThrough$1, Transform$8 = _stream_transform$1;
inherits_browserExports(PassThrough$1, Transform$8);
function PassThrough$1(a) {
  if (!(this instanceof PassThrough$1))
    return new PassThrough$1(a);
  Transform$8.call(this, a);
}
PassThrough$1.prototype._transform = function(a, u, c) {
  c(null, a);
};
var eos$2;
function once$4(a) {
  var u = !1;
  return function() {
    u || (u = !0, a.apply(void 0, arguments));
  };
}
var _require$codes$2 = errorsBrowser$1.codes, ERR_MISSING_ARGS$1 = _require$codes$2.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED$1 = _require$codes$2.ERR_STREAM_DESTROYED;
function noop$3(a) {
  if (a)
    throw a;
}
function isRequest$2(a) {
  return a.setHeader && typeof a.abort == "function";
}
function destroyer$1(a, u, c, l) {
  l = once$4(l);
  var v = !1;
  a.on("close", function() {
    v = !0;
  }), eos$2 === void 0 && (eos$2 = endOfStream$1), eos$2(a, {
    readable: u,
    writable: c
  }, function(_) {
    if (_)
      return l(_);
    v = !0, l();
  });
  var p = !1;
  return function(_) {
    if (!v && !p) {
      if (p = !0, isRequest$2(a))
        return a.abort();
      if (typeof a.destroy == "function")
        return a.destroy();
      l(_ || new ERR_STREAM_DESTROYED$1("pipe"));
    }
  };
}
function call$1(a) {
  a();
}
function pipe$1(a, u) {
  return a.pipe(u);
}
function popCallback$1(a) {
  return !a.length || typeof a[a.length - 1] != "function" ? noop$3 : a.pop();
}
function pipeline$1() {
  for (var a = arguments.length, u = new Array(a), c = 0; c < a; c++)
    u[c] = arguments[c];
  var l = popCallback$1(u);
  if (Array.isArray(u[0]) && (u = u[0]), u.length < 2)
    throw new ERR_MISSING_ARGS$1("streams");
  var v, p = u.map(function(_, k) {
    var M = k < u.length - 1, L = k > 0;
    return destroyer$1(_, M, L, function(F) {
      v || (v = F), F && p.forEach(call$1), !M && (p.forEach(call$1), l(v));
    });
  });
  return u.reduce(pipe$1);
}
var pipeline_1$1 = pipeline$1;
(function(a, u) {
  u = a.exports = require_stream_readable$1(), u.Stream = u, u.Readable = u, u.Writable = require_stream_writable$1(), u.Duplex = require_stream_duplex$1(), u.Transform = _stream_transform$1, u.PassThrough = _stream_passthrough$1, u.finished = endOfStream$1, u.pipeline = pipeline_1$1;
})(readableBrowser$1, readableBrowser$1.exports);
var readableBrowserExports$1 = readableBrowser$1.exports, Buffer$H = safeBufferExports$1.Buffer, Transform$7 = readableBrowserExports$1.Transform, inherits$u = inherits_browserExports;
function throwIfNotStringOrBuffer(a, u) {
  if (!Buffer$H.isBuffer(a) && typeof a != "string")
    throw new TypeError(u + " must be a string or a buffer");
}
function HashBase$2(a) {
  Transform$7.call(this), this._block = Buffer$H.allocUnsafe(a), this._blockSize = a, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = !1;
}
inherits$u(HashBase$2, Transform$7);
HashBase$2.prototype._transform = function(a, u, c) {
  var l = null;
  try {
    this.update(a, u);
  } catch (v) {
    l = v;
  }
  c(l);
};
HashBase$2.prototype._flush = function(a) {
  var u = null;
  try {
    this.push(this.digest());
  } catch (c) {
    u = c;
  }
  a(u);
};
HashBase$2.prototype.update = function(a, u) {
  if (throwIfNotStringOrBuffer(a, "Data"), this._finalized)
    throw new Error("Digest already called");
  Buffer$H.isBuffer(a) || (a = Buffer$H.from(a, u));
  for (var c = this._block, l = 0; this._blockOffset + a.length - l >= this._blockSize; ) {
    for (var v = this._blockOffset; v < this._blockSize; )
      c[v++] = a[l++];
    this._update(), this._blockOffset = 0;
  }
  for (; l < a.length; )
    c[this._blockOffset++] = a[l++];
  for (var p = 0, _ = a.length * 8; _ > 0; ++p)
    this._length[p] += _, _ = this._length[p] / 4294967296 | 0, _ > 0 && (this._length[p] -= 4294967296 * _);
  return this;
};
HashBase$2.prototype._update = function() {
  throw new Error("_update is not implemented");
};
HashBase$2.prototype.digest = function(a) {
  if (this._finalized)
    throw new Error("Digest already called");
  this._finalized = !0;
  var u = this._digest();
  a !== void 0 && (u = u.toString(a)), this._block.fill(0), this._blockOffset = 0;
  for (var c = 0; c < 4; ++c)
    this._length[c] = 0;
  return u;
};
HashBase$2.prototype._digest = function() {
  throw new Error("_digest is not implemented");
};
var hashBase = HashBase$2, inherits$t = inherits_browserExports, HashBase$1 = hashBase, Buffer$G = safeBufferExports$3.Buffer, ARRAY16$1 = new Array(16);
function MD5$3() {
  HashBase$1.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
}
inherits$t(MD5$3, HashBase$1);
MD5$3.prototype._update = function() {
  for (var a = ARRAY16$1, u = 0; u < 16; ++u)
    a[u] = this._block.readInt32LE(u * 4);
  var c = this._a, l = this._b, v = this._c, p = this._d;
  c = fnF(c, l, v, p, a[0], 3614090360, 7), p = fnF(p, c, l, v, a[1], 3905402710, 12), v = fnF(v, p, c, l, a[2], 606105819, 17), l = fnF(l, v, p, c, a[3], 3250441966, 22), c = fnF(c, l, v, p, a[4], 4118548399, 7), p = fnF(p, c, l, v, a[5], 1200080426, 12), v = fnF(v, p, c, l, a[6], 2821735955, 17), l = fnF(l, v, p, c, a[7], 4249261313, 22), c = fnF(c, l, v, p, a[8], 1770035416, 7), p = fnF(p, c, l, v, a[9], 2336552879, 12), v = fnF(v, p, c, l, a[10], 4294925233, 17), l = fnF(l, v, p, c, a[11], 2304563134, 22), c = fnF(c, l, v, p, a[12], 1804603682, 7), p = fnF(p, c, l, v, a[13], 4254626195, 12), v = fnF(v, p, c, l, a[14], 2792965006, 17), l = fnF(l, v, p, c, a[15], 1236535329, 22), c = fnG(c, l, v, p, a[1], 4129170786, 5), p = fnG(p, c, l, v, a[6], 3225465664, 9), v = fnG(v, p, c, l, a[11], 643717713, 14), l = fnG(l, v, p, c, a[0], 3921069994, 20), c = fnG(c, l, v, p, a[5], 3593408605, 5), p = fnG(p, c, l, v, a[10], 38016083, 9), v = fnG(v, p, c, l, a[15], 3634488961, 14), l = fnG(l, v, p, c, a[4], 3889429448, 20), c = fnG(c, l, v, p, a[9], 568446438, 5), p = fnG(p, c, l, v, a[14], 3275163606, 9), v = fnG(v, p, c, l, a[3], 4107603335, 14), l = fnG(l, v, p, c, a[8], 1163531501, 20), c = fnG(c, l, v, p, a[13], 2850285829, 5), p = fnG(p, c, l, v, a[2], 4243563512, 9), v = fnG(v, p, c, l, a[7], 1735328473, 14), l = fnG(l, v, p, c, a[12], 2368359562, 20), c = fnH(c, l, v, p, a[5], 4294588738, 4), p = fnH(p, c, l, v, a[8], 2272392833, 11), v = fnH(v, p, c, l, a[11], 1839030562, 16), l = fnH(l, v, p, c, a[14], 4259657740, 23), c = fnH(c, l, v, p, a[1], 2763975236, 4), p = fnH(p, c, l, v, a[4], 1272893353, 11), v = fnH(v, p, c, l, a[7], 4139469664, 16), l = fnH(l, v, p, c, a[10], 3200236656, 23), c = fnH(c, l, v, p, a[13], 681279174, 4), p = fnH(p, c, l, v, a[0], 3936430074, 11), v = fnH(v, p, c, l, a[3], 3572445317, 16), l = fnH(l, v, p, c, a[6], 76029189, 23), c = fnH(c, l, v, p, a[9], 3654602809, 4), p = fnH(p, c, l, v, a[12], 3873151461, 11), v = fnH(v, p, c, l, a[15], 530742520, 16), l = fnH(l, v, p, c, a[2], 3299628645, 23), c = fnI(c, l, v, p, a[0], 4096336452, 6), p = fnI(p, c, l, v, a[7], 1126891415, 10), v = fnI(v, p, c, l, a[14], 2878612391, 15), l = fnI(l, v, p, c, a[5], 4237533241, 21), c = fnI(c, l, v, p, a[12], 1700485571, 6), p = fnI(p, c, l, v, a[3], 2399980690, 10), v = fnI(v, p, c, l, a[10], 4293915773, 15), l = fnI(l, v, p, c, a[1], 2240044497, 21), c = fnI(c, l, v, p, a[8], 1873313359, 6), p = fnI(p, c, l, v, a[15], 4264355552, 10), v = fnI(v, p, c, l, a[6], 2734768916, 15), l = fnI(l, v, p, c, a[13], 1309151649, 21), c = fnI(c, l, v, p, a[4], 4149444226, 6), p = fnI(p, c, l, v, a[11], 3174756917, 10), v = fnI(v, p, c, l, a[2], 718787259, 15), l = fnI(l, v, p, c, a[9], 3951481745, 21), this._a = this._a + c | 0, this._b = this._b + l | 0, this._c = this._c + v | 0, this._d = this._d + p | 0;
};
MD5$3.prototype._digest = function() {
  this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
  var a = Buffer$G.allocUnsafe(16);
  return a.writeInt32LE(this._a, 0), a.writeInt32LE(this._b, 4), a.writeInt32LE(this._c, 8), a.writeInt32LE(this._d, 12), a;
};
function rotl$1(a, u) {
  return a << u | a >>> 32 - u;
}
function fnF(a, u, c, l, v, p, _) {
  return rotl$1(a + (u & c | ~u & l) + v + p | 0, _) + u | 0;
}
function fnG(a, u, c, l, v, p, _) {
  return rotl$1(a + (u & l | c & ~l) + v + p | 0, _) + u | 0;
}
function fnH(a, u, c, l, v, p, _) {
  return rotl$1(a + (u ^ c ^ l) + v + p | 0, _) + u | 0;
}
function fnI(a, u, c, l, v, p, _) {
  return rotl$1(a + (c ^ (u | ~l)) + v + p | 0, _) + u | 0;
}
var md5_js = MD5$3, Buffer$F = require$$0$2.Buffer, inherits$s = inherits_browserExports, HashBase = hashBase, ARRAY16 = new Array(16), zl = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
], zr = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
], sl = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
], sr = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
], hl = [0, 1518500249, 1859775393, 2400959708, 2840853838], hr = [1352829926, 1548603684, 1836072691, 2053994217, 0];
function RIPEMD160$4() {
  HashBase.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
}
inherits$s(RIPEMD160$4, HashBase);
RIPEMD160$4.prototype._update = function() {
  for (var a = ARRAY16, u = 0; u < 16; ++u)
    a[u] = this._block.readInt32LE(u * 4);
  for (var c = this._a | 0, l = this._b | 0, v = this._c | 0, p = this._d | 0, _ = this._e | 0, k = this._a | 0, M = this._b | 0, L = this._c | 0, F = this._d | 0, V = this._e | 0, X = 0; X < 80; X += 1) {
    var oe, Y;
    X < 16 ? (oe = fn1(c, l, v, p, _, a[zl[X]], hl[0], sl[X]), Y = fn5(k, M, L, F, V, a[zr[X]], hr[0], sr[X])) : X < 32 ? (oe = fn2(c, l, v, p, _, a[zl[X]], hl[1], sl[X]), Y = fn4(k, M, L, F, V, a[zr[X]], hr[1], sr[X])) : X < 48 ? (oe = fn3(c, l, v, p, _, a[zl[X]], hl[2], sl[X]), Y = fn3(k, M, L, F, V, a[zr[X]], hr[2], sr[X])) : X < 64 ? (oe = fn4(c, l, v, p, _, a[zl[X]], hl[3], sl[X]), Y = fn2(k, M, L, F, V, a[zr[X]], hr[3], sr[X])) : (oe = fn5(c, l, v, p, _, a[zl[X]], hl[4], sl[X]), Y = fn1(k, M, L, F, V, a[zr[X]], hr[4], sr[X])), c = _, _ = p, p = rotl(v, 10), v = l, l = oe, k = V, V = F, F = rotl(L, 10), L = M, M = Y;
  }
  var ae = this._b + v + F | 0;
  this._b = this._c + p + V | 0, this._c = this._d + _ + k | 0, this._d = this._e + c + M | 0, this._e = this._a + l + L | 0, this._a = ae;
};
RIPEMD160$4.prototype._digest = function() {
  this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
  var a = Buffer$F.alloc ? Buffer$F.alloc(20) : new Buffer$F(20);
  return a.writeInt32LE(this._a, 0), a.writeInt32LE(this._b, 4), a.writeInt32LE(this._c, 8), a.writeInt32LE(this._d, 12), a.writeInt32LE(this._e, 16), a;
};
function rotl(a, u) {
  return a << u | a >>> 32 - u;
}
function fn1(a, u, c, l, v, p, _, k) {
  return rotl(a + (u ^ c ^ l) + p + _ | 0, k) + v | 0;
}
function fn2(a, u, c, l, v, p, _, k) {
  return rotl(a + (u & c | ~u & l) + p + _ | 0, k) + v | 0;
}
function fn3(a, u, c, l, v, p, _, k) {
  return rotl(a + ((u | ~c) ^ l) + p + _ | 0, k) + v | 0;
}
function fn4(a, u, c, l, v, p, _, k) {
  return rotl(a + (u & l | c & ~l) + p + _ | 0, k) + v | 0;
}
function fn5(a, u, c, l, v, p, _, k) {
  return rotl(a + (u ^ (c | ~l)) + p + _ | 0, k) + v | 0;
}
var ripemd160 = RIPEMD160$4, sha_js = { exports: {} }, Buffer$E = safeBufferExports$3.Buffer;
function Hash$7(a, u) {
  this._block = Buffer$E.alloc(a), this._finalSize = u, this._blockSize = a, this._len = 0;
}
Hash$7.prototype.update = function(a, u) {
  typeof a == "string" && (u = u || "utf8", a = Buffer$E.from(a, u));
  for (var c = this._block, l = this._blockSize, v = a.length, p = this._len, _ = 0; _ < v; ) {
    for (var k = p % l, M = Math.min(v - _, l - k), L = 0; L < M; L++)
      c[k + L] = a[_ + L];
    p += M, _ += M, p % l === 0 && this._update(c);
  }
  return this._len += v, this;
};
Hash$7.prototype.digest = function(a) {
  var u = this._len % this._blockSize;
  this._block[u] = 128, this._block.fill(0, u + 1), u >= this._finalSize && (this._update(this._block), this._block.fill(0));
  var c = this._len * 8;
  if (c <= 4294967295)
    this._block.writeUInt32BE(c, this._blockSize - 4);
  else {
    var l = (c & 4294967295) >>> 0, v = (c - l) / 4294967296;
    this._block.writeUInt32BE(v, this._blockSize - 8), this._block.writeUInt32BE(l, this._blockSize - 4);
  }
  this._update(this._block);
  var p = this._hash();
  return a ? p.toString(a) : p;
};
Hash$7.prototype._update = function() {
  throw new Error("_update must be implemented by subclass");
};
var hash$3 = Hash$7, inherits$r = inherits_browserExports, Hash$6 = hash$3, Buffer$D = safeBufferExports$3.Buffer, K$4 = [
  1518500249,
  1859775393,
  -1894007588,
  -899497514
], W$5 = new Array(80);
function Sha() {
  this.init(), this._w = W$5, Hash$6.call(this, 64, 56);
}
inherits$r(Sha, Hash$6);
Sha.prototype.init = function() {
  return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
};
function rotl5$1(a) {
  return a << 5 | a >>> 27;
}
function rotl30$1(a) {
  return a << 30 | a >>> 2;
}
function ft$1(a, u, c, l) {
  return a === 0 ? u & c | ~u & l : a === 2 ? u & c | u & l | c & l : u ^ c ^ l;
}
Sha.prototype._update = function(a) {
  for (var u = this._w, c = this._a | 0, l = this._b | 0, v = this._c | 0, p = this._d | 0, _ = this._e | 0, k = 0; k < 16; ++k)
    u[k] = a.readInt32BE(k * 4);
  for (; k < 80; ++k)
    u[k] = u[k - 3] ^ u[k - 8] ^ u[k - 14] ^ u[k - 16];
  for (var M = 0; M < 80; ++M) {
    var L = ~~(M / 20), F = rotl5$1(c) + ft$1(L, l, v, p) + _ + u[M] + K$4[L] | 0;
    _ = p, p = v, v = rotl30$1(l), l = c, c = F;
  }
  this._a = c + this._a | 0, this._b = l + this._b | 0, this._c = v + this._c | 0, this._d = p + this._d | 0, this._e = _ + this._e | 0;
};
Sha.prototype._hash = function() {
  var a = Buffer$D.allocUnsafe(20);
  return a.writeInt32BE(this._a | 0, 0), a.writeInt32BE(this._b | 0, 4), a.writeInt32BE(this._c | 0, 8), a.writeInt32BE(this._d | 0, 12), a.writeInt32BE(this._e | 0, 16), a;
};
var sha$4 = Sha, inherits$q = inherits_browserExports, Hash$5 = hash$3, Buffer$C = safeBufferExports$3.Buffer, K$3 = [
  1518500249,
  1859775393,
  -1894007588,
  -899497514
], W$4 = new Array(80);
function Sha1() {
  this.init(), this._w = W$4, Hash$5.call(this, 64, 56);
}
inherits$q(Sha1, Hash$5);
Sha1.prototype.init = function() {
  return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
};
function rotl1(a) {
  return a << 1 | a >>> 31;
}
function rotl5(a) {
  return a << 5 | a >>> 27;
}
function rotl30(a) {
  return a << 30 | a >>> 2;
}
function ft(a, u, c, l) {
  return a === 0 ? u & c | ~u & l : a === 2 ? u & c | u & l | c & l : u ^ c ^ l;
}
Sha1.prototype._update = function(a) {
  for (var u = this._w, c = this._a | 0, l = this._b | 0, v = this._c | 0, p = this._d | 0, _ = this._e | 0, k = 0; k < 16; ++k)
    u[k] = a.readInt32BE(k * 4);
  for (; k < 80; ++k)
    u[k] = rotl1(u[k - 3] ^ u[k - 8] ^ u[k - 14] ^ u[k - 16]);
  for (var M = 0; M < 80; ++M) {
    var L = ~~(M / 20), F = rotl5(c) + ft(L, l, v, p) + _ + u[M] + K$3[L] | 0;
    _ = p, p = v, v = rotl30(l), l = c, c = F;
  }
  this._a = c + this._a | 0, this._b = l + this._b | 0, this._c = v + this._c | 0, this._d = p + this._d | 0, this._e = _ + this._e | 0;
};
Sha1.prototype._hash = function() {
  var a = Buffer$C.allocUnsafe(20);
  return a.writeInt32BE(this._a | 0, 0), a.writeInt32BE(this._b | 0, 4), a.writeInt32BE(this._c | 0, 8), a.writeInt32BE(this._d | 0, 12), a.writeInt32BE(this._e | 0, 16), a;
};
var sha1 = Sha1, inherits$p = inherits_browserExports, Hash$4 = hash$3, Buffer$B = safeBufferExports$3.Buffer, K$2 = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
], W$3 = new Array(64);
function Sha256$1() {
  this.init(), this._w = W$3, Hash$4.call(this, 64, 56);
}
inherits$p(Sha256$1, Hash$4);
Sha256$1.prototype.init = function() {
  return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
};
function ch(a, u, c) {
  return c ^ a & (u ^ c);
}
function maj$1(a, u, c) {
  return a & u | c & (a | u);
}
function sigma0$1(a) {
  return (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10);
}
function sigma1$1(a) {
  return (a >>> 6 | a << 26) ^ (a >>> 11 | a << 21) ^ (a >>> 25 | a << 7);
}
function gamma0(a) {
  return (a >>> 7 | a << 25) ^ (a >>> 18 | a << 14) ^ a >>> 3;
}
function gamma1(a) {
  return (a >>> 17 | a << 15) ^ (a >>> 19 | a << 13) ^ a >>> 10;
}
Sha256$1.prototype._update = function(a) {
  for (var u = this._w, c = this._a | 0, l = this._b | 0, v = this._c | 0, p = this._d | 0, _ = this._e | 0, k = this._f | 0, M = this._g | 0, L = this._h | 0, F = 0; F < 16; ++F)
    u[F] = a.readInt32BE(F * 4);
  for (; F < 64; ++F)
    u[F] = gamma1(u[F - 2]) + u[F - 7] + gamma0(u[F - 15]) + u[F - 16] | 0;
  for (var V = 0; V < 64; ++V) {
    var X = L + sigma1$1(_) + ch(_, k, M) + K$2[V] + u[V] | 0, oe = sigma0$1(c) + maj$1(c, l, v) | 0;
    L = M, M = k, k = _, _ = p + X | 0, p = v, v = l, l = c, c = X + oe | 0;
  }
  this._a = c + this._a | 0, this._b = l + this._b | 0, this._c = v + this._c | 0, this._d = p + this._d | 0, this._e = _ + this._e | 0, this._f = k + this._f | 0, this._g = M + this._g | 0, this._h = L + this._h | 0;
};
Sha256$1.prototype._hash = function() {
  var a = Buffer$B.allocUnsafe(32);
  return a.writeInt32BE(this._a, 0), a.writeInt32BE(this._b, 4), a.writeInt32BE(this._c, 8), a.writeInt32BE(this._d, 12), a.writeInt32BE(this._e, 16), a.writeInt32BE(this._f, 20), a.writeInt32BE(this._g, 24), a.writeInt32BE(this._h, 28), a;
};
var sha256$1 = Sha256$1, inherits$o = inherits_browserExports, Sha256 = sha256$1, Hash$3 = hash$3, Buffer$A = safeBufferExports$3.Buffer, W$2 = new Array(64);
function Sha224() {
  this.init(), this._w = W$2, Hash$3.call(this, 64, 56);
}
inherits$o(Sha224, Sha256);
Sha224.prototype.init = function() {
  return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
};
Sha224.prototype._hash = function() {
  var a = Buffer$A.allocUnsafe(28);
  return a.writeInt32BE(this._a, 0), a.writeInt32BE(this._b, 4), a.writeInt32BE(this._c, 8), a.writeInt32BE(this._d, 12), a.writeInt32BE(this._e, 16), a.writeInt32BE(this._f, 20), a.writeInt32BE(this._g, 24), a;
};
var sha224$1 = Sha224, inherits$n = inherits_browserExports, Hash$2 = hash$3, Buffer$z = safeBufferExports$3.Buffer, K$1 = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
], W$1 = new Array(160);
function Sha512() {
  this.init(), this._w = W$1, Hash$2.call(this, 128, 112);
}
inherits$n(Sha512, Hash$2);
Sha512.prototype.init = function() {
  return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
};
function Ch(a, u, c) {
  return c ^ a & (u ^ c);
}
function maj(a, u, c) {
  return a & u | c & (a | u);
}
function sigma0(a, u) {
  return (a >>> 28 | u << 4) ^ (u >>> 2 | a << 30) ^ (u >>> 7 | a << 25);
}
function sigma1(a, u) {
  return (a >>> 14 | u << 18) ^ (a >>> 18 | u << 14) ^ (u >>> 9 | a << 23);
}
function Gamma0(a, u) {
  return (a >>> 1 | u << 31) ^ (a >>> 8 | u << 24) ^ a >>> 7;
}
function Gamma0l(a, u) {
  return (a >>> 1 | u << 31) ^ (a >>> 8 | u << 24) ^ (a >>> 7 | u << 25);
}
function Gamma1(a, u) {
  return (a >>> 19 | u << 13) ^ (u >>> 29 | a << 3) ^ a >>> 6;
}
function Gamma1l(a, u) {
  return (a >>> 19 | u << 13) ^ (u >>> 29 | a << 3) ^ (a >>> 6 | u << 26);
}
function getCarry(a, u) {
  return a >>> 0 < u >>> 0 ? 1 : 0;
}
Sha512.prototype._update = function(a) {
  for (var u = this._w, c = this._ah | 0, l = this._bh | 0, v = this._ch | 0, p = this._dh | 0, _ = this._eh | 0, k = this._fh | 0, M = this._gh | 0, L = this._hh | 0, F = this._al | 0, V = this._bl | 0, X = this._cl | 0, oe = this._dl | 0, Y = this._el | 0, ae = this._fl | 0, ne = this._gl | 0, fe = this._hl | 0, ie = 0; ie < 32; ie += 2)
    u[ie] = a.readInt32BE(ie * 4), u[ie + 1] = a.readInt32BE(ie * 4 + 4);
  for (; ie < 160; ie += 2) {
    var ge = u[ie - 30], be = u[ie - 15 * 2 + 1], Ce = Gamma0(ge, be), Me = Gamma0l(be, ge);
    ge = u[ie - 2 * 2], be = u[ie - 2 * 2 + 1];
    var Be = Gamma1(ge, be), Ae = Gamma1l(be, ge), Z = u[ie - 7 * 2], z = u[ie - 7 * 2 + 1], P = u[ie - 16 * 2], S = u[ie - 16 * 2 + 1], E = Me + z | 0, I = Ce + Z + getCarry(E, Me) | 0;
    E = E + Ae | 0, I = I + Be + getCarry(E, Ae) | 0, E = E + S | 0, I = I + P + getCarry(E, S) | 0, u[ie] = I, u[ie + 1] = E;
  }
  for (var N = 0; N < 160; N += 2) {
    I = u[N], E = u[N + 1];
    var $ = maj(c, l, v), U = maj(F, V, X), H = sigma0(c, F), B = sigma0(F, c), T = sigma1(_, Y), D = sigma1(Y, _), ee = K$1[N], pe = K$1[N + 1], Ie = Ch(_, k, M), Pe = Ch(Y, ae, ne), he = fe + D | 0, ve = L + T + getCarry(he, fe) | 0;
    he = he + Pe | 0, ve = ve + Ie + getCarry(he, Pe) | 0, he = he + pe | 0, ve = ve + ee + getCarry(he, pe) | 0, he = he + E | 0, ve = ve + I + getCarry(he, E) | 0;
    var Q = B + U | 0, le = H + $ + getCarry(Q, B) | 0;
    L = M, fe = ne, M = k, ne = ae, k = _, ae = Y, Y = oe + he | 0, _ = p + ve + getCarry(Y, oe) | 0, p = v, oe = X, v = l, X = V, l = c, V = F, F = he + Q | 0, c = ve + le + getCarry(F, he) | 0;
  }
  this._al = this._al + F | 0, this._bl = this._bl + V | 0, this._cl = this._cl + X | 0, this._dl = this._dl + oe | 0, this._el = this._el + Y | 0, this._fl = this._fl + ae | 0, this._gl = this._gl + ne | 0, this._hl = this._hl + fe | 0, this._ah = this._ah + c + getCarry(this._al, F) | 0, this._bh = this._bh + l + getCarry(this._bl, V) | 0, this._ch = this._ch + v + getCarry(this._cl, X) | 0, this._dh = this._dh + p + getCarry(this._dl, oe) | 0, this._eh = this._eh + _ + getCarry(this._el, Y) | 0, this._fh = this._fh + k + getCarry(this._fl, ae) | 0, this._gh = this._gh + M + getCarry(this._gl, ne) | 0, this._hh = this._hh + L + getCarry(this._hl, fe) | 0;
};
Sha512.prototype._hash = function() {
  var a = Buffer$z.allocUnsafe(64);
  function u(c, l, v) {
    a.writeInt32BE(c, v), a.writeInt32BE(l, v + 4);
  }
  return u(this._ah, this._al, 0), u(this._bh, this._bl, 8), u(this._ch, this._cl, 16), u(this._dh, this._dl, 24), u(this._eh, this._el, 32), u(this._fh, this._fl, 40), u(this._gh, this._gl, 48), u(this._hh, this._hl, 56), a;
};
var sha512$1 = Sha512, inherits$m = inherits_browserExports, SHA512$2 = sha512$1, Hash$1 = hash$3, Buffer$y = safeBufferExports$3.Buffer, W = new Array(160);
function Sha384() {
  this.init(), this._w = W, Hash$1.call(this, 128, 112);
}
inherits$m(Sha384, SHA512$2);
Sha384.prototype.init = function() {
  return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
};
Sha384.prototype._hash = function() {
  var a = Buffer$y.allocUnsafe(48);
  function u(c, l, v) {
    a.writeInt32BE(c, v), a.writeInt32BE(l, v + 4);
  }
  return u(this._ah, this._al, 0), u(this._bh, this._bl, 8), u(this._ch, this._cl, 16), u(this._dh, this._dl, 24), u(this._eh, this._el, 32), u(this._fh, this._fl, 40), a;
};
var sha384$1 = Sha384, exports$1 = sha_js.exports = function a(u) {
  u = u.toLowerCase();
  var c = exports$1[u];
  if (!c)
    throw new Error(u + " is not supported (we accept pull requests)");
  return new c();
};
exports$1.sha = sha$4;
exports$1.sha1 = sha1;
exports$1.sha224 = sha224$1;
exports$1.sha256 = sha256$1;
exports$1.sha384 = sha384$1;
exports$1.sha512 = sha512$1;
var sha_jsExports = sha_js.exports, Buffer$x = safeBufferExports$3.Buffer, Transform$6 = streamBrowserify.Transform, StringDecoder = string_decoder.StringDecoder, inherits$l = inherits_browserExports;
function CipherBase$1(a) {
  Transform$6.call(this), this.hashMode = typeof a == "string", this.hashMode ? this[a] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;
}
inherits$l(CipherBase$1, Transform$6);
CipherBase$1.prototype.update = function(a, u, c) {
  typeof a == "string" && (a = Buffer$x.from(a, u));
  var l = this._update(a);
  return this.hashMode ? this : (c && (l = this._toString(l, c)), l);
};
CipherBase$1.prototype.setAutoPadding = function() {
};
CipherBase$1.prototype.getAuthTag = function() {
  throw new Error("trying to get auth tag in unsupported state");
};
CipherBase$1.prototype.setAuthTag = function() {
  throw new Error("trying to set auth tag in unsupported state");
};
CipherBase$1.prototype.setAAD = function() {
  throw new Error("trying to set aad in unsupported state");
};
CipherBase$1.prototype._transform = function(a, u, c) {
  var l;
  try {
    this.hashMode ? this._update(a) : this.push(this._update(a));
  } catch (v) {
    l = v;
  } finally {
    c(l);
  }
};
CipherBase$1.prototype._flush = function(a) {
  var u;
  try {
    this.push(this.__final());
  } catch (c) {
    u = c;
  }
  a(u);
};
CipherBase$1.prototype._finalOrDigest = function(a) {
  var u = this.__final() || Buffer$x.alloc(0);
  return a && (u = this._toString(u, a, !0)), u;
};
CipherBase$1.prototype._toString = function(a, u, c) {
  if (this._decoder || (this._decoder = new StringDecoder(u), this._encoding = u), this._encoding !== u)
    throw new Error("can't switch encodings");
  var l = this._decoder.write(a);
  return c && (l += this._decoder.end()), l;
};
var cipherBase = CipherBase$1, inherits$k = inherits_browserExports, MD5$2 = md5_js, RIPEMD160$3 = ripemd160, sha$3 = sha_jsExports, Base$5 = cipherBase;
function Hash(a) {
  Base$5.call(this, "digest"), this._hash = a;
}
inherits$k(Hash, Base$5);
Hash.prototype._update = function(a) {
  this._hash.update(a);
};
Hash.prototype._final = function() {
  return this._hash.digest();
};
var browser$a = function a(u) {
  return u = u.toLowerCase(), u === "md5" ? new MD5$2() : u === "rmd160" || u === "ripemd160" ? new RIPEMD160$3() : new Hash(sha$3(u));
}, inherits$j = inherits_browserExports, Buffer$w = safeBufferExports$3.Buffer, Base$4 = cipherBase, ZEROS$2 = Buffer$w.alloc(128), blocksize = 64;
function Hmac$3(a, u) {
  Base$4.call(this, "digest"), typeof u == "string" && (u = Buffer$w.from(u)), this._alg = a, this._key = u, u.length > blocksize ? u = a(u) : u.length < blocksize && (u = Buffer$w.concat([u, ZEROS$2], blocksize));
  for (var c = this._ipad = Buffer$w.allocUnsafe(blocksize), l = this._opad = Buffer$w.allocUnsafe(blocksize), v = 0; v < blocksize; v++)
    c[v] = u[v] ^ 54, l[v] = u[v] ^ 92;
  this._hash = [c];
}
inherits$j(Hmac$3, Base$4);
Hmac$3.prototype._update = function(a) {
  this._hash.push(a);
};
Hmac$3.prototype._final = function() {
  var a = this._alg(Buffer$w.concat(this._hash));
  return this._alg(Buffer$w.concat([this._opad, a]));
};
var legacy = Hmac$3, MD5$1 = md5_js, md5$2 = function(a) {
  return new MD5$1().update(a).digest();
}, inherits$i = inherits_browserExports, Legacy = legacy, Base$3 = cipherBase, Buffer$v = safeBufferExports$3.Buffer, md5$1 = md5$2, RIPEMD160$2 = ripemd160, sha$2 = sha_jsExports, ZEROS$1 = Buffer$v.alloc(128);
function Hmac$2(a, u) {
  Base$3.call(this, "digest"), typeof u == "string" && (u = Buffer$v.from(u));
  var c = a === "sha512" || a === "sha384" ? 128 : 64;
  if (this._alg = a, this._key = u, u.length > c) {
    var l = a === "rmd160" ? new RIPEMD160$2() : sha$2(a);
    u = l.update(u).digest();
  } else
    u.length < c && (u = Buffer$v.concat([u, ZEROS$1], c));
  for (var v = this._ipad = Buffer$v.allocUnsafe(c), p = this._opad = Buffer$v.allocUnsafe(c), _ = 0; _ < c; _++)
    v[_] = u[_] ^ 54, p[_] = u[_] ^ 92;
  this._hash = a === "rmd160" ? new RIPEMD160$2() : sha$2(a), this._hash.update(v);
}
inherits$i(Hmac$2, Base$3);
Hmac$2.prototype._update = function(a) {
  this._hash.update(a);
};
Hmac$2.prototype._final = function() {
  var a = this._hash.digest(), u = this._alg === "rmd160" ? new RIPEMD160$2() : sha$2(this._alg);
  return u.update(this._opad).update(a).digest();
};
var browser$9 = function a(u, c) {
  return u = u.toLowerCase(), u === "rmd160" || u === "ripemd160" ? new Hmac$2("rmd160", c) : u === "md5" ? new Legacy(md5$1, c) : new Hmac$2(u, c);
};
const sha224WithRSAEncryption = {
  sign: "rsa",
  hash: "sha224",
  id: "302d300d06096086480165030402040500041c"
}, sha256WithRSAEncryption = {
  sign: "rsa",
  hash: "sha256",
  id: "3031300d060960864801650304020105000420"
}, sha384WithRSAEncryption = {
  sign: "rsa",
  hash: "sha384",
  id: "3041300d060960864801650304020205000430"
}, sha512WithRSAEncryption = {
  sign: "rsa",
  hash: "sha512",
  id: "3051300d060960864801650304020305000440"
}, sha256 = {
  sign: "ecdsa",
  hash: "sha256",
  id: ""
}, sha224 = {
  sign: "ecdsa",
  hash: "sha224",
  id: ""
}, sha384 = {
  sign: "ecdsa",
  hash: "sha384",
  id: ""
}, sha512 = {
  sign: "ecdsa",
  hash: "sha512",
  id: ""
}, DSA = {
  sign: "dsa",
  hash: "sha1",
  id: ""
}, ripemd160WithRSA = {
  sign: "rsa",
  hash: "rmd160",
  id: "3021300906052b2403020105000414"
}, md5WithRSAEncryption = {
  sign: "rsa",
  hash: "md5",
  id: "3020300c06082a864886f70d020505000410"
}, require$$6 = {
  sha224WithRSAEncryption,
  "RSA-SHA224": {
    sign: "ecdsa/rsa",
    hash: "sha224",
    id: "302d300d06096086480165030402040500041c"
  },
  sha256WithRSAEncryption,
  "RSA-SHA256": {
    sign: "ecdsa/rsa",
    hash: "sha256",
    id: "3031300d060960864801650304020105000420"
  },
  sha384WithRSAEncryption,
  "RSA-SHA384": {
    sign: "ecdsa/rsa",
    hash: "sha384",
    id: "3041300d060960864801650304020205000430"
  },
  sha512WithRSAEncryption,
  "RSA-SHA512": {
    sign: "ecdsa/rsa",
    hash: "sha512",
    id: "3051300d060960864801650304020305000440"
  },
  "RSA-SHA1": {
    sign: "rsa",
    hash: "sha1",
    id: "3021300906052b0e03021a05000414"
  },
  "ecdsa-with-SHA1": {
    sign: "ecdsa",
    hash: "sha1",
    id: ""
  },
  sha256,
  sha224,
  sha384,
  sha512,
  "DSA-SHA": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  "DSA-SHA1": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  DSA,
  "DSA-WITH-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-WITH-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-WITH-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-WITH-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-RIPEMD160": {
    sign: "dsa",
    hash: "rmd160",
    id: ""
  },
  ripemd160WithRSA,
  "RSA-RIPEMD160": {
    sign: "rsa",
    hash: "rmd160",
    id: "3021300906052b2403020105000414"
  },
  md5WithRSAEncryption,
  "RSA-MD5": {
    sign: "rsa",
    hash: "md5",
    id: "3020300c06082a864886f70d020505000410"
  }
};
var algos = require$$6, browser$8 = {}, MAX_ALLOC = Math.pow(2, 30) - 1, precondition = function(a, u) {
  if (typeof a != "number")
    throw new TypeError("Iterations not a number");
  if (a < 0)
    throw new TypeError("Bad iterations");
  if (typeof u != "number")
    throw new TypeError("Key length not a number");
  if (u < 0 || u > MAX_ALLOC || u !== u)
    throw new TypeError("Bad key length");
}, defaultEncoding$2;
if (commonjsGlobal$1.process && commonjsGlobal$1.process.browser)
  defaultEncoding$2 = "utf-8";
else if (commonjsGlobal$1.process && commonjsGlobal$1.process.version) {
  var pVersionMajor = parseInt(process$1.version.split(".")[0].slice(1), 10);
  defaultEncoding$2 = pVersionMajor >= 6 ? "utf-8" : "binary";
} else
  defaultEncoding$2 = "utf-8";
var defaultEncoding_1 = defaultEncoding$2, Buffer$u = safeBufferExports$3.Buffer, toBuffer$2 = function(a, u, c) {
  if (Buffer$u.isBuffer(a))
    return a;
  if (typeof a == "string")
    return Buffer$u.from(a, u);
  if (ArrayBuffer.isView(a))
    return Buffer$u.from(a.buffer);
  throw new TypeError(c + " must be a string, a Buffer, a typed array or a DataView");
}, md5 = md5$2, RIPEMD160$1 = ripemd160, sha$1 = sha_jsExports, Buffer$t = safeBufferExports$3.Buffer, checkParameters$1 = precondition, defaultEncoding$1 = defaultEncoding_1, toBuffer$1 = toBuffer$2, ZEROS = Buffer$t.alloc(128), sizes = {
  md5: 16,
  sha1: 20,
  sha224: 28,
  sha256: 32,
  sha384: 48,
  sha512: 64,
  rmd160: 20,
  ripemd160: 20
};
function Hmac$1(a, u, c) {
  var l = getDigest(a), v = a === "sha512" || a === "sha384" ? 128 : 64;
  u.length > v ? u = l(u) : u.length < v && (u = Buffer$t.concat([u, ZEROS], v));
  for (var p = Buffer$t.allocUnsafe(v + sizes[a]), _ = Buffer$t.allocUnsafe(v + sizes[a]), k = 0; k < v; k++)
    p[k] = u[k] ^ 54, _[k] = u[k] ^ 92;
  var M = Buffer$t.allocUnsafe(v + c + 4);
  p.copy(M, 0, 0, v), this.ipad1 = M, this.ipad2 = p, this.opad = _, this.alg = a, this.blocksize = v, this.hash = l, this.size = sizes[a];
}
Hmac$1.prototype.run = function(a, u) {
  a.copy(u, this.blocksize);
  var c = this.hash(u);
  return c.copy(this.opad, this.blocksize), this.hash(this.opad);
};
function getDigest(a) {
  function u(l) {
    return sha$1(a).update(l).digest();
  }
  function c(l) {
    return new RIPEMD160$1().update(l).digest();
  }
  return a === "rmd160" || a === "ripemd160" ? c : a === "md5" ? md5 : u;
}
function pbkdf2(a, u, c, l, v) {
  checkParameters$1(c, l), a = toBuffer$1(a, defaultEncoding$1, "Password"), u = toBuffer$1(u, defaultEncoding$1, "Salt"), v = v || "sha1";
  var p = new Hmac$1(v, a, u.length), _ = Buffer$t.allocUnsafe(l), k = Buffer$t.allocUnsafe(u.length + 4);
  u.copy(k, 0, 0, u.length);
  for (var M = 0, L = sizes[v], F = Math.ceil(l / L), V = 1; V <= F; V++) {
    k.writeUInt32BE(V, u.length);
    for (var X = p.run(k, p.ipad1), oe = X, Y = 1; Y < c; Y++) {
      oe = p.run(oe, p.ipad2);
      for (var ae = 0; ae < L; ae++)
        X[ae] ^= oe[ae];
    }
    X.copy(_, M), M += L;
  }
  return _;
}
var syncBrowser = pbkdf2, Buffer$s = safeBufferExports$3.Buffer, checkParameters = precondition, defaultEncoding = defaultEncoding_1, sync = syncBrowser, toBuffer = toBuffer$2, ZERO_BUF, subtle = commonjsGlobal$1.crypto && commonjsGlobal$1.crypto.subtle, toBrowser = {
  sha: "SHA-1",
  "sha-1": "SHA-1",
  sha1: "SHA-1",
  sha256: "SHA-256",
  "sha-256": "SHA-256",
  sha384: "SHA-384",
  "sha-384": "SHA-384",
  "sha-512": "SHA-512",
  sha512: "SHA-512"
}, checks = [];
function checkNative(a) {
  if (commonjsGlobal$1.process && !commonjsGlobal$1.process.browser || !subtle || !subtle.importKey || !subtle.deriveBits)
    return Promise.resolve(!1);
  if (checks[a] !== void 0)
    return checks[a];
  ZERO_BUF = ZERO_BUF || Buffer$s.alloc(8);
  var u = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, a).then(function() {
    return !0;
  }).catch(function() {
    return !1;
  });
  return checks[a] = u, u;
}
var nextTick$1;
function getNextTick() {
  return nextTick$1 || (commonjsGlobal$1.process && commonjsGlobal$1.process.nextTick ? nextTick$1 = commonjsGlobal$1.process.nextTick : commonjsGlobal$1.queueMicrotask ? nextTick$1 = commonjsGlobal$1.queueMicrotask : commonjsGlobal$1.setImmediate ? nextTick$1 = commonjsGlobal$1.setImmediate : nextTick$1 = commonjsGlobal$1.setTimeout, nextTick$1);
}
function browserPbkdf2(a, u, c, l, v) {
  return subtle.importKey(
    "raw",
    a,
    { name: "PBKDF2" },
    !1,
    ["deriveBits"]
  ).then(function(p) {
    return subtle.deriveBits({
      name: "PBKDF2",
      salt: u,
      iterations: c,
      hash: {
        name: v
      }
    }, p, l << 3);
  }).then(function(p) {
    return Buffer$s.from(p);
  });
}
function resolvePromise(a, u) {
  a.then(function(c) {
    getNextTick()(function() {
      u(null, c);
    });
  }, function(c) {
    getNextTick()(function() {
      u(c);
    });
  });
}
var async = function(a, u, c, l, v, p) {
  typeof v == "function" && (p = v, v = void 0), v = v || "sha1";
  var _ = toBrowser[v.toLowerCase()];
  if (!_ || typeof commonjsGlobal$1.Promise != "function") {
    getNextTick()(function() {
      var k;
      try {
        k = sync(a, u, c, l, v);
      } catch (M) {
        return p(M);
      }
      p(null, k);
    });
    return;
  }
  if (checkParameters(c, l), a = toBuffer(a, defaultEncoding, "Password"), u = toBuffer(u, defaultEncoding, "Salt"), typeof p != "function")
    throw new Error("No callback provided to pbkdf2");
  resolvePromise(checkNative(_).then(function(k) {
    return k ? browserPbkdf2(a, u, c, l, _) : sync(a, u, c, l, v);
  }), p);
};
browser$8.pbkdf2 = async;
browser$8.pbkdf2Sync = syncBrowser;
var browser$7 = {}, des$2 = {}, utils$x = {};
utils$x.readUInt32BE = function a(u, c) {
  var l = u[0 + c] << 24 | u[1 + c] << 16 | u[2 + c] << 8 | u[3 + c];
  return l >>> 0;
};
utils$x.writeUInt32BE = function a(u, c, l) {
  u[0 + l] = c >>> 24, u[1 + l] = c >>> 16 & 255, u[2 + l] = c >>> 8 & 255, u[3 + l] = c & 255;
};
utils$x.ip = function a(u, c, l, v) {
  for (var p = 0, _ = 0, k = 6; k >= 0; k -= 2) {
    for (var M = 0; M <= 24; M += 8)
      p <<= 1, p |= c >>> M + k & 1;
    for (var M = 0; M <= 24; M += 8)
      p <<= 1, p |= u >>> M + k & 1;
  }
  for (var k = 6; k >= 0; k -= 2) {
    for (var M = 1; M <= 25; M += 8)
      _ <<= 1, _ |= c >>> M + k & 1;
    for (var M = 1; M <= 25; M += 8)
      _ <<= 1, _ |= u >>> M + k & 1;
  }
  l[v + 0] = p >>> 0, l[v + 1] = _ >>> 0;
};
utils$x.rip = function a(u, c, l, v) {
  for (var p = 0, _ = 0, k = 0; k < 4; k++)
    for (var M = 24; M >= 0; M -= 8)
      p <<= 1, p |= c >>> M + k & 1, p <<= 1, p |= u >>> M + k & 1;
  for (var k = 4; k < 8; k++)
    for (var M = 24; M >= 0; M -= 8)
      _ <<= 1, _ |= c >>> M + k & 1, _ <<= 1, _ |= u >>> M + k & 1;
  l[v + 0] = p >>> 0, l[v + 1] = _ >>> 0;
};
utils$x.pc1 = function a(u, c, l, v) {
  for (var p = 0, _ = 0, k = 7; k >= 5; k--) {
    for (var M = 0; M <= 24; M += 8)
      p <<= 1, p |= c >> M + k & 1;
    for (var M = 0; M <= 24; M += 8)
      p <<= 1, p |= u >> M + k & 1;
  }
  for (var M = 0; M <= 24; M += 8)
    p <<= 1, p |= c >> M + k & 1;
  for (var k = 1; k <= 3; k++) {
    for (var M = 0; M <= 24; M += 8)
      _ <<= 1, _ |= c >> M + k & 1;
    for (var M = 0; M <= 24; M += 8)
      _ <<= 1, _ |= u >> M + k & 1;
  }
  for (var M = 0; M <= 24; M += 8)
    _ <<= 1, _ |= u >> M + k & 1;
  l[v + 0] = p >>> 0, l[v + 1] = _ >>> 0;
};
utils$x.r28shl = function a(u, c) {
  return u << c & 268435455 | u >>> 28 - c;
};
var pc2table = [
  // inL => outL
  14,
  11,
  17,
  4,
  27,
  23,
  25,
  0,
  13,
  22,
  7,
  18,
  5,
  9,
  16,
  24,
  2,
  20,
  12,
  21,
  1,
  8,
  15,
  26,
  // inR => outR
  15,
  4,
  25,
  19,
  9,
  1,
  26,
  16,
  5,
  11,
  23,
  8,
  12,
  7,
  17,
  0,
  22,
  3,
  10,
  14,
  6,
  20,
  27,
  24
];
utils$x.pc2 = function a(u, c, l, v) {
  for (var p = 0, _ = 0, k = pc2table.length >>> 1, M = 0; M < k; M++)
    p <<= 1, p |= u >>> pc2table[M] & 1;
  for (var M = k; M < pc2table.length; M++)
    _ <<= 1, _ |= c >>> pc2table[M] & 1;
  l[v + 0] = p >>> 0, l[v + 1] = _ >>> 0;
};
utils$x.expand = function a(u, c, l) {
  var v = 0, p = 0;
  v = (u & 1) << 5 | u >>> 27;
  for (var _ = 23; _ >= 15; _ -= 4)
    v <<= 6, v |= u >>> _ & 63;
  for (var _ = 11; _ >= 3; _ -= 4)
    p |= u >>> _ & 63, p <<= 6;
  p |= (u & 31) << 1 | u >>> 31, c[l + 0] = v >>> 0, c[l + 1] = p >>> 0;
};
var sTable = [
  14,
  0,
  4,
  15,
  13,
  7,
  1,
  4,
  2,
  14,
  15,
  2,
  11,
  13,
  8,
  1,
  3,
  10,
  10,
  6,
  6,
  12,
  12,
  11,
  5,
  9,
  9,
  5,
  0,
  3,
  7,
  8,
  4,
  15,
  1,
  12,
  14,
  8,
  8,
  2,
  13,
  4,
  6,
  9,
  2,
  1,
  11,
  7,
  15,
  5,
  12,
  11,
  9,
  3,
  7,
  14,
  3,
  10,
  10,
  0,
  5,
  6,
  0,
  13,
  15,
  3,
  1,
  13,
  8,
  4,
  14,
  7,
  6,
  15,
  11,
  2,
  3,
  8,
  4,
  14,
  9,
  12,
  7,
  0,
  2,
  1,
  13,
  10,
  12,
  6,
  0,
  9,
  5,
  11,
  10,
  5,
  0,
  13,
  14,
  8,
  7,
  10,
  11,
  1,
  10,
  3,
  4,
  15,
  13,
  4,
  1,
  2,
  5,
  11,
  8,
  6,
  12,
  7,
  6,
  12,
  9,
  0,
  3,
  5,
  2,
  14,
  15,
  9,
  10,
  13,
  0,
  7,
  9,
  0,
  14,
  9,
  6,
  3,
  3,
  4,
  15,
  6,
  5,
  10,
  1,
  2,
  13,
  8,
  12,
  5,
  7,
  14,
  11,
  12,
  4,
  11,
  2,
  15,
  8,
  1,
  13,
  1,
  6,
  10,
  4,
  13,
  9,
  0,
  8,
  6,
  15,
  9,
  3,
  8,
  0,
  7,
  11,
  4,
  1,
  15,
  2,
  14,
  12,
  3,
  5,
  11,
  10,
  5,
  14,
  2,
  7,
  12,
  7,
  13,
  13,
  8,
  14,
  11,
  3,
  5,
  0,
  6,
  6,
  15,
  9,
  0,
  10,
  3,
  1,
  4,
  2,
  7,
  8,
  2,
  5,
  12,
  11,
  1,
  12,
  10,
  4,
  14,
  15,
  9,
  10,
  3,
  6,
  15,
  9,
  0,
  0,
  6,
  12,
  10,
  11,
  1,
  7,
  13,
  13,
  8,
  15,
  9,
  1,
  4,
  3,
  5,
  14,
  11,
  5,
  12,
  2,
  7,
  8,
  2,
  4,
  14,
  2,
  14,
  12,
  11,
  4,
  2,
  1,
  12,
  7,
  4,
  10,
  7,
  11,
  13,
  6,
  1,
  8,
  5,
  5,
  0,
  3,
  15,
  15,
  10,
  13,
  3,
  0,
  9,
  14,
  8,
  9,
  6,
  4,
  11,
  2,
  8,
  1,
  12,
  11,
  7,
  10,
  1,
  13,
  14,
  7,
  2,
  8,
  13,
  15,
  6,
  9,
  15,
  12,
  0,
  5,
  9,
  6,
  10,
  3,
  4,
  0,
  5,
  14,
  3,
  12,
  10,
  1,
  15,
  10,
  4,
  15,
  2,
  9,
  7,
  2,
  12,
  6,
  9,
  8,
  5,
  0,
  6,
  13,
  1,
  3,
  13,
  4,
  14,
  14,
  0,
  7,
  11,
  5,
  3,
  11,
  8,
  9,
  4,
  14,
  3,
  15,
  2,
  5,
  12,
  2,
  9,
  8,
  5,
  12,
  15,
  3,
  10,
  7,
  11,
  0,
  14,
  4,
  1,
  10,
  7,
  1,
  6,
  13,
  0,
  11,
  8,
  6,
  13,
  4,
  13,
  11,
  0,
  2,
  11,
  14,
  7,
  15,
  4,
  0,
  9,
  8,
  1,
  13,
  10,
  3,
  14,
  12,
  3,
  9,
  5,
  7,
  12,
  5,
  2,
  10,
  15,
  6,
  8,
  1,
  6,
  1,
  6,
  4,
  11,
  11,
  13,
  13,
  8,
  12,
  1,
  3,
  4,
  7,
  10,
  14,
  7,
  10,
  9,
  15,
  5,
  6,
  0,
  8,
  15,
  0,
  14,
  5,
  2,
  9,
  3,
  2,
  12,
  13,
  1,
  2,
  15,
  8,
  13,
  4,
  8,
  6,
  10,
  15,
  3,
  11,
  7,
  1,
  4,
  10,
  12,
  9,
  5,
  3,
  6,
  14,
  11,
  5,
  0,
  0,
  14,
  12,
  9,
  7,
  2,
  7,
  2,
  11,
  1,
  4,
  14,
  1,
  7,
  9,
  4,
  12,
  10,
  14,
  8,
  2,
  13,
  0,
  15,
  6,
  12,
  10,
  9,
  13,
  0,
  15,
  3,
  3,
  5,
  5,
  6,
  8,
  11
];
utils$x.substitute = function a(u, c) {
  for (var l = 0, v = 0; v < 4; v++) {
    var p = u >>> 18 - v * 6 & 63, _ = sTable[v * 64 + p];
    l <<= 4, l |= _;
  }
  for (var v = 0; v < 4; v++) {
    var p = c >>> 18 - v * 6 & 63, _ = sTable[4 * 64 + v * 64 + p];
    l <<= 4, l |= _;
  }
  return l >>> 0;
};
var permuteTable = [
  16,
  25,
  12,
  11,
  3,
  20,
  4,
  15,
  31,
  17,
  9,
  6,
  27,
  14,
  1,
  22,
  30,
  24,
  8,
  18,
  0,
  5,
  29,
  23,
  13,
  19,
  2,
  26,
  10,
  21,
  28,
  7
];
utils$x.permute = function a(u) {
  for (var c = 0, l = 0; l < permuteTable.length; l++)
    c <<= 1, c |= u >>> permuteTable[l] & 1;
  return c >>> 0;
};
utils$x.padSplit = function a(u, c, l) {
  for (var v = u.toString(2); v.length < c; )
    v = "0" + v;
  for (var p = [], _ = 0; _ < c; _ += l)
    p.push(v.slice(_, _ + l));
  return p.join(" ");
};
var minimalisticAssert = assert$j;
function assert$j(a, u) {
  if (!a)
    throw new Error(u || "Assertion failed");
}
assert$j.equal = function a(u, c, l) {
  if (u != c)
    throw new Error(l || "Assertion failed: " + u + " != " + c);
};
var assert$i = minimalisticAssert;
function Cipher$3(a) {
  this.options = a, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0, this.padding = a.padding !== !1;
}
var cipher = Cipher$3;
Cipher$3.prototype._init = function a() {
};
Cipher$3.prototype.update = function a(u) {
  return u.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(u) : this._updateEncrypt(u);
};
Cipher$3.prototype._buffer = function a(u, c) {
  for (var l = Math.min(this.buffer.length - this.bufferOff, u.length - c), v = 0; v < l; v++)
    this.buffer[this.bufferOff + v] = u[c + v];
  return this.bufferOff += l, l;
};
Cipher$3.prototype._flushBuffer = function a(u, c) {
  return this._update(this.buffer, 0, u, c), this.bufferOff = 0, this.blockSize;
};
Cipher$3.prototype._updateEncrypt = function a(u) {
  var c = 0, l = 0, v = (this.bufferOff + u.length) / this.blockSize | 0, p = new Array(v * this.blockSize);
  this.bufferOff !== 0 && (c += this._buffer(u, c), this.bufferOff === this.buffer.length && (l += this._flushBuffer(p, l)));
  for (var _ = u.length - (u.length - c) % this.blockSize; c < _; c += this.blockSize)
    this._update(u, c, p, l), l += this.blockSize;
  for (; c < u.length; c++, this.bufferOff++)
    this.buffer[this.bufferOff] = u[c];
  return p;
};
Cipher$3.prototype._updateDecrypt = function a(u) {
  for (var c = 0, l = 0, v = Math.ceil((this.bufferOff + u.length) / this.blockSize) - 1, p = new Array(v * this.blockSize); v > 0; v--)
    c += this._buffer(u, c), l += this._flushBuffer(p, l);
  return c += this._buffer(u, c), p;
};
Cipher$3.prototype.final = function a(u) {
  var c;
  u && (c = this.update(u));
  var l;
  return this.type === "encrypt" ? l = this._finalEncrypt() : l = this._finalDecrypt(), c ? c.concat(l) : l;
};
Cipher$3.prototype._pad = function a(u, c) {
  if (c === 0)
    return !1;
  for (; c < u.length; )
    u[c++] = 0;
  return !0;
};
Cipher$3.prototype._finalEncrypt = function a() {
  if (!this._pad(this.buffer, this.bufferOff))
    return [];
  var u = new Array(this.blockSize);
  return this._update(this.buffer, 0, u, 0), u;
};
Cipher$3.prototype._unpad = function a(u) {
  return u;
};
Cipher$3.prototype._finalDecrypt = function a() {
  assert$i.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
  var u = new Array(this.blockSize);
  return this._flushBuffer(u, 0), this._unpad(u);
};
var assert$h = minimalisticAssert, inherits$h = inherits_browserExports, utils$w = utils$x, Cipher$2 = cipher;
function DESState() {
  this.tmp = new Array(2), this.keys = null;
}
function DES$3(a) {
  Cipher$2.call(this, a);
  var u = new DESState();
  this._desState = u, this.deriveKeys(u, a.key);
}
inherits$h(DES$3, Cipher$2);
var des$1 = DES$3;
DES$3.create = function a(u) {
  return new DES$3(u);
};
var shiftTable = [
  1,
  1,
  2,
  2,
  2,
  2,
  2,
  2,
  1,
  2,
  2,
  2,
  2,
  2,
  2,
  1
];
DES$3.prototype.deriveKeys = function a(u, c) {
  u.keys = new Array(16 * 2), assert$h.equal(c.length, this.blockSize, "Invalid key length");
  var l = utils$w.readUInt32BE(c, 0), v = utils$w.readUInt32BE(c, 4);
  utils$w.pc1(l, v, u.tmp, 0), l = u.tmp[0], v = u.tmp[1];
  for (var p = 0; p < u.keys.length; p += 2) {
    var _ = shiftTable[p >>> 1];
    l = utils$w.r28shl(l, _), v = utils$w.r28shl(v, _), utils$w.pc2(l, v, u.keys, p);
  }
};
DES$3.prototype._update = function a(u, c, l, v) {
  var p = this._desState, _ = utils$w.readUInt32BE(u, c), k = utils$w.readUInt32BE(u, c + 4);
  utils$w.ip(_, k, p.tmp, 0), _ = p.tmp[0], k = p.tmp[1], this.type === "encrypt" ? this._encrypt(p, _, k, p.tmp, 0) : this._decrypt(p, _, k, p.tmp, 0), _ = p.tmp[0], k = p.tmp[1], utils$w.writeUInt32BE(l, _, v), utils$w.writeUInt32BE(l, k, v + 4);
};
DES$3.prototype._pad = function a(u, c) {
  if (this.padding === !1)
    return !1;
  for (var l = u.length - c, v = c; v < u.length; v++)
    u[v] = l;
  return !0;
};
DES$3.prototype._unpad = function a(u) {
  if (this.padding === !1)
    return u;
  for (var c = u[u.length - 1], l = u.length - c; l < u.length; l++)
    assert$h.equal(u[l], c);
  return u.slice(0, u.length - c);
};
DES$3.prototype._encrypt = function a(u, c, l, v, p) {
  for (var _ = c, k = l, M = 0; M < u.keys.length; M += 2) {
    var L = u.keys[M], F = u.keys[M + 1];
    utils$w.expand(k, u.tmp, 0), L ^= u.tmp[0], F ^= u.tmp[1];
    var V = utils$w.substitute(L, F), X = utils$w.permute(V), oe = k;
    k = (_ ^ X) >>> 0, _ = oe;
  }
  utils$w.rip(k, _, v, p);
};
DES$3.prototype._decrypt = function a(u, c, l, v, p) {
  for (var _ = l, k = c, M = u.keys.length - 2; M >= 0; M -= 2) {
    var L = u.keys[M], F = u.keys[M + 1];
    utils$w.expand(_, u.tmp, 0), L ^= u.tmp[0], F ^= u.tmp[1];
    var V = utils$w.substitute(L, F), X = utils$w.permute(V), oe = _;
    _ = (k ^ X) >>> 0, k = oe;
  }
  utils$w.rip(_, k, v, p);
};
var cbc$1 = {}, assert$g = minimalisticAssert, inherits$g = inherits_browserExports, proto = {};
function CBCState(a) {
  assert$g.equal(a.length, 8, "Invalid IV length"), this.iv = new Array(8);
  for (var u = 0; u < this.iv.length; u++)
    this.iv[u] = a[u];
}
function instantiate(a) {
  function u(p) {
    a.call(this, p), this._cbcInit();
  }
  inherits$g(u, a);
  for (var c = Object.keys(proto), l = 0; l < c.length; l++) {
    var v = c[l];
    u.prototype[v] = proto[v];
  }
  return u.create = function(_) {
    return new u(_);
  }, u;
}
cbc$1.instantiate = instantiate;
proto._cbcInit = function a() {
  var u = new CBCState(this.options.iv);
  this._cbcState = u;
};
proto._update = function a(u, c, l, v) {
  var p = this._cbcState, _ = this.constructor.super_.prototype, k = p.iv;
  if (this.type === "encrypt") {
    for (var M = 0; M < this.blockSize; M++)
      k[M] ^= u[c + M];
    _._update.call(this, k, 0, l, v);
    for (var M = 0; M < this.blockSize; M++)
      k[M] = l[v + M];
  } else {
    _._update.call(this, u, c, l, v);
    for (var M = 0; M < this.blockSize; M++)
      l[v + M] ^= k[M];
    for (var M = 0; M < this.blockSize; M++)
      k[M] = u[c + M];
  }
};
var assert$f = minimalisticAssert, inherits$f = inherits_browserExports, Cipher$1 = cipher, DES$2 = des$1;
function EDEState(a, u) {
  assert$f.equal(u.length, 24, "Invalid key length");
  var c = u.slice(0, 8), l = u.slice(8, 16), v = u.slice(16, 24);
  a === "encrypt" ? this.ciphers = [
    DES$2.create({ type: "encrypt", key: c }),
    DES$2.create({ type: "decrypt", key: l }),
    DES$2.create({ type: "encrypt", key: v })
  ] : this.ciphers = [
    DES$2.create({ type: "decrypt", key: v }),
    DES$2.create({ type: "encrypt", key: l }),
    DES$2.create({ type: "decrypt", key: c })
  ];
}
function EDE(a) {
  Cipher$1.call(this, a);
  var u = new EDEState(this.type, this.options.key);
  this._edeState = u;
}
inherits$f(EDE, Cipher$1);
var ede = EDE;
EDE.create = function a(u) {
  return new EDE(u);
};
EDE.prototype._update = function a(u, c, l, v) {
  var p = this._edeState;
  p.ciphers[0]._update(u, c, l, v), p.ciphers[1]._update(l, v, l, v), p.ciphers[2]._update(l, v, l, v);
};
EDE.prototype._pad = DES$2.prototype._pad;
EDE.prototype._unpad = DES$2.prototype._unpad;
des$2.utils = utils$x;
des$2.Cipher = cipher;
des$2.DES = des$1;
des$2.CBC = cbc$1;
des$2.EDE = ede;
var CipherBase = cipherBase, des = des$2, inherits$e = inherits_browserExports, Buffer$r = safeBufferExports$3.Buffer, modes$4 = {
  "des-ede3-cbc": des.CBC.instantiate(des.EDE),
  "des-ede3": des.EDE,
  "des-ede-cbc": des.CBC.instantiate(des.EDE),
  "des-ede": des.EDE,
  "des-cbc": des.CBC.instantiate(des.DES),
  "des-ecb": des.DES
};
modes$4.des = modes$4["des-cbc"];
modes$4.des3 = modes$4["des-ede3-cbc"];
var browserifyDes = DES$1;
inherits$e(DES$1, CipherBase);
function DES$1(a) {
  CipherBase.call(this);
  var u = a.mode.toLowerCase(), c = modes$4[u], l;
  a.decrypt ? l = "decrypt" : l = "encrypt";
  var v = a.key;
  Buffer$r.isBuffer(v) || (v = Buffer$r.from(v)), (u === "des-ede" || u === "des-ede-cbc") && (v = Buffer$r.concat([v, v.slice(0, 8)]));
  var p = a.iv;
  Buffer$r.isBuffer(p) || (p = Buffer$r.from(p)), this._des = c.create({
    key: v,
    iv: p,
    type: l
  });
}
DES$1.prototype._update = function(a) {
  return Buffer$r.from(this._des.update(a));
};
DES$1.prototype._final = function() {
  return Buffer$r.from(this._des.final());
};
var browser$6 = {}, encrypter = {}, ecb = {};
ecb.encrypt = function(a, u) {
  return a._cipher.encryptBlock(u);
};
ecb.decrypt = function(a, u) {
  return a._cipher.decryptBlock(u);
};
var cbc = {}, bufferXor = function a(u, c) {
  for (var l = Math.min(u.length, c.length), v = new Buffer$O(l), p = 0; p < l; ++p)
    v[p] = u[p] ^ c[p];
  return v;
}, xor$7 = bufferXor;
cbc.encrypt = function(a, u) {
  var c = xor$7(u, a._prev);
  return a._prev = a._cipher.encryptBlock(c), a._prev;
};
cbc.decrypt = function(a, u) {
  var c = a._prev;
  a._prev = u;
  var l = a._cipher.decryptBlock(u);
  return xor$7(l, c);
};
var cfb = {}, Buffer$q = safeBufferExports$3.Buffer, xor$6 = bufferXor;
function encryptStart(a, u, c) {
  var l = u.length, v = xor$6(u, a._cache);
  return a._cache = a._cache.slice(l), a._prev = Buffer$q.concat([a._prev, c ? u : v]), v;
}
cfb.encrypt = function(a, u, c) {
  for (var l = Buffer$q.allocUnsafe(0), v; u.length; )
    if (a._cache.length === 0 && (a._cache = a._cipher.encryptBlock(a._prev), a._prev = Buffer$q.allocUnsafe(0)), a._cache.length <= u.length)
      v = a._cache.length, l = Buffer$q.concat([l, encryptStart(a, u.slice(0, v), c)]), u = u.slice(v);
    else {
      l = Buffer$q.concat([l, encryptStart(a, u, c)]);
      break;
    }
  return l;
};
var cfb8 = {}, Buffer$p = safeBufferExports$3.Buffer;
function encryptByte$1(a, u, c) {
  var l = a._cipher.encryptBlock(a._prev), v = l[0] ^ u;
  return a._prev = Buffer$p.concat([
    a._prev.slice(1),
    Buffer$p.from([c ? u : v])
  ]), v;
}
cfb8.encrypt = function(a, u, c) {
  for (var l = u.length, v = Buffer$p.allocUnsafe(l), p = -1; ++p < l; )
    v[p] = encryptByte$1(a, u[p], c);
  return v;
};
var cfb1 = {}, Buffer$o = safeBufferExports$3.Buffer;
function encryptByte(a, u, c) {
  for (var l, v = -1, p = 8, _ = 0, k, M; ++v < p; )
    l = a._cipher.encryptBlock(a._prev), k = u & 1 << 7 - v ? 128 : 0, M = l[0] ^ k, _ += (M & 128) >> v % 8, a._prev = shiftIn(a._prev, c ? k : M);
  return _;
}
function shiftIn(a, u) {
  var c = a.length, l = -1, v = Buffer$o.allocUnsafe(a.length);
  for (a = Buffer$o.concat([a, Buffer$o.from([u])]); ++l < c; )
    v[l] = a[l] << 1 | a[l + 1] >> 7;
  return v;
}
cfb1.encrypt = function(a, u, c) {
  for (var l = u.length, v = Buffer$o.allocUnsafe(l), p = -1; ++p < l; )
    v[p] = encryptByte(a, u[p], c);
  return v;
};
var ofb = {}, xor$5 = bufferXor;
function getBlock$1(a) {
  return a._prev = a._cipher.encryptBlock(a._prev), a._prev;
}
ofb.encrypt = function(a, u) {
  for (; a._cache.length < u.length; )
    a._cache = Buffer$O.concat([a._cache, getBlock$1(a)]);
  var c = a._cache.slice(0, u.length);
  return a._cache = a._cache.slice(u.length), xor$5(u, c);
};
var ctr = {};
function incr32$2(a) {
  for (var u = a.length, c; u--; )
    if (c = a.readUInt8(u), c === 255)
      a.writeUInt8(0, u);
    else {
      c++, a.writeUInt8(c, u);
      break;
    }
}
var incr32_1 = incr32$2, xor$4 = bufferXor, Buffer$n = safeBufferExports$3.Buffer, incr32$1 = incr32_1;
function getBlock(a) {
  var u = a._cipher.encryptBlockRaw(a._prev);
  return incr32$1(a._prev), u;
}
var blockSize = 16;
ctr.encrypt = function(a, u) {
  var c = Math.ceil(u.length / blockSize), l = a._cache.length;
  a._cache = Buffer$n.concat([
    a._cache,
    Buffer$n.allocUnsafe(c * blockSize)
  ]);
  for (var v = 0; v < c; v++) {
    var p = getBlock(a), _ = l + v * blockSize;
    a._cache.writeUInt32BE(p[0], _ + 0), a._cache.writeUInt32BE(p[1], _ + 4), a._cache.writeUInt32BE(p[2], _ + 8), a._cache.writeUInt32BE(p[3], _ + 12);
  }
  var k = a._cache.slice(0, u.length);
  return a._cache = a._cache.slice(u.length), xor$4(u, k);
};
const aes128 = {
  cipher: "AES",
  key: 128,
  iv: 16,
  mode: "CBC",
  type: "block"
}, aes192 = {
  cipher: "AES",
  key: 192,
  iv: 16,
  mode: "CBC",
  type: "block"
}, aes256 = {
  cipher: "AES",
  key: 256,
  iv: 16,
  mode: "CBC",
  type: "block"
}, require$$2 = {
  "aes-128-ecb": {
    cipher: "AES",
    key: 128,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-192-ecb": {
    cipher: "AES",
    key: 192,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-256-ecb": {
    cipher: "AES",
    key: 256,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-128-cbc": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-192-cbc": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-256-cbc": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  aes128,
  aes192,
  aes256,
  "aes-128-cfb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-192-cfb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-256-cfb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-128-cfb8": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-192-cfb8": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-256-cfb8": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-128-cfb1": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-192-cfb1": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-256-cfb1": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-128-ofb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-192-ofb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-256-ofb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-128-ctr": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-192-ctr": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-256-ctr": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-128-gcm": {
    cipher: "AES",
    key: 128,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-192-gcm": {
    cipher: "AES",
    key: 192,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-256-gcm": {
    cipher: "AES",
    key: 256,
    iv: 12,
    mode: "GCM",
    type: "auth"
  }
};
var modeModules = {
  ECB: ecb,
  CBC: cbc,
  CFB: cfb,
  CFB8: cfb8,
  CFB1: cfb1,
  OFB: ofb,
  CTR: ctr,
  GCM: ctr
}, modes$3 = require$$2;
for (var key$3 in modes$3)
  modes$3[key$3].module = modeModules[modes$3[key$3].mode];
var modes_1 = modes$3, aes$5 = {}, Buffer$m = safeBufferExports$3.Buffer;
function asUInt32Array(a) {
  Buffer$m.isBuffer(a) || (a = Buffer$m.from(a));
  for (var u = a.length / 4 | 0, c = new Array(u), l = 0; l < u; l++)
    c[l] = a.readUInt32BE(l * 4);
  return c;
}
function scrubVec(a) {
  for (var u = 0; u < a.length; a++)
    a[u] = 0;
}
function cryptBlock(a, u, c, l, v) {
  for (var p = c[0], _ = c[1], k = c[2], M = c[3], L = a[0] ^ u[0], F = a[1] ^ u[1], V = a[2] ^ u[2], X = a[3] ^ u[3], oe, Y, ae, ne, fe = 4, ie = 1; ie < v; ie++)
    oe = p[L >>> 24] ^ _[F >>> 16 & 255] ^ k[V >>> 8 & 255] ^ M[X & 255] ^ u[fe++], Y = p[F >>> 24] ^ _[V >>> 16 & 255] ^ k[X >>> 8 & 255] ^ M[L & 255] ^ u[fe++], ae = p[V >>> 24] ^ _[X >>> 16 & 255] ^ k[L >>> 8 & 255] ^ M[F & 255] ^ u[fe++], ne = p[X >>> 24] ^ _[L >>> 16 & 255] ^ k[F >>> 8 & 255] ^ M[V & 255] ^ u[fe++], L = oe, F = Y, V = ae, X = ne;
  return oe = (l[L >>> 24] << 24 | l[F >>> 16 & 255] << 16 | l[V >>> 8 & 255] << 8 | l[X & 255]) ^ u[fe++], Y = (l[F >>> 24] << 24 | l[V >>> 16 & 255] << 16 | l[X >>> 8 & 255] << 8 | l[L & 255]) ^ u[fe++], ae = (l[V >>> 24] << 24 | l[X >>> 16 & 255] << 16 | l[L >>> 8 & 255] << 8 | l[F & 255]) ^ u[fe++], ne = (l[X >>> 24] << 24 | l[L >>> 16 & 255] << 16 | l[F >>> 8 & 255] << 8 | l[V & 255]) ^ u[fe++], oe = oe >>> 0, Y = Y >>> 0, ae = ae >>> 0, ne = ne >>> 0, [oe, Y, ae, ne];
}
var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], G = function() {
  for (var a = new Array(256), u = 0; u < 256; u++)
    u < 128 ? a[u] = u << 1 : a[u] = u << 1 ^ 283;
  for (var c = [], l = [], v = [[], [], [], []], p = [[], [], [], []], _ = 0, k = 0, M = 0; M < 256; ++M) {
    var L = k ^ k << 1 ^ k << 2 ^ k << 3 ^ k << 4;
    L = L >>> 8 ^ L & 255 ^ 99, c[_] = L, l[L] = _;
    var F = a[_], V = a[F], X = a[V], oe = a[L] * 257 ^ L * 16843008;
    v[0][_] = oe << 24 | oe >>> 8, v[1][_] = oe << 16 | oe >>> 16, v[2][_] = oe << 8 | oe >>> 24, v[3][_] = oe, oe = X * 16843009 ^ V * 65537 ^ F * 257 ^ _ * 16843008, p[0][L] = oe << 24 | oe >>> 8, p[1][L] = oe << 16 | oe >>> 16, p[2][L] = oe << 8 | oe >>> 24, p[3][L] = oe, _ === 0 ? _ = k = 1 : (_ = F ^ a[a[a[X ^ F]]], k ^= a[a[k]]);
  }
  return {
    SBOX: c,
    INV_SBOX: l,
    SUB_MIX: v,
    INV_SUB_MIX: p
  };
}();
function AES(a) {
  this._key = asUInt32Array(a), this._reset();
}
AES.blockSize = 4 * 4;
AES.keySize = 256 / 8;
AES.prototype.blockSize = AES.blockSize;
AES.prototype.keySize = AES.keySize;
AES.prototype._reset = function() {
  for (var a = this._key, u = a.length, c = u + 6, l = (c + 1) * 4, v = [], p = 0; p < u; p++)
    v[p] = a[p];
  for (p = u; p < l; p++) {
    var _ = v[p - 1];
    p % u === 0 ? (_ = _ << 8 | _ >>> 24, _ = G.SBOX[_ >>> 24] << 24 | G.SBOX[_ >>> 16 & 255] << 16 | G.SBOX[_ >>> 8 & 255] << 8 | G.SBOX[_ & 255], _ ^= RCON[p / u | 0] << 24) : u > 6 && p % u === 4 && (_ = G.SBOX[_ >>> 24] << 24 | G.SBOX[_ >>> 16 & 255] << 16 | G.SBOX[_ >>> 8 & 255] << 8 | G.SBOX[_ & 255]), v[p] = v[p - u] ^ _;
  }
  for (var k = [], M = 0; M < l; M++) {
    var L = l - M, F = v[L - (M % 4 ? 0 : 4)];
    M < 4 || L <= 4 ? k[M] = F : k[M] = G.INV_SUB_MIX[0][G.SBOX[F >>> 24]] ^ G.INV_SUB_MIX[1][G.SBOX[F >>> 16 & 255]] ^ G.INV_SUB_MIX[2][G.SBOX[F >>> 8 & 255]] ^ G.INV_SUB_MIX[3][G.SBOX[F & 255]];
  }
  this._nRounds = c, this._keySchedule = v, this._invKeySchedule = k;
};
AES.prototype.encryptBlockRaw = function(a) {
  return a = asUInt32Array(a), cryptBlock(a, this._keySchedule, G.SUB_MIX, G.SBOX, this._nRounds);
};
AES.prototype.encryptBlock = function(a) {
  var u = this.encryptBlockRaw(a), c = Buffer$m.allocUnsafe(16);
  return c.writeUInt32BE(u[0], 0), c.writeUInt32BE(u[1], 4), c.writeUInt32BE(u[2], 8), c.writeUInt32BE(u[3], 12), c;
};
AES.prototype.decryptBlock = function(a) {
  a = asUInt32Array(a);
  var u = a[1];
  a[1] = a[3], a[3] = u;
  var c = cryptBlock(a, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX, this._nRounds), l = Buffer$m.allocUnsafe(16);
  return l.writeUInt32BE(c[0], 0), l.writeUInt32BE(c[3], 4), l.writeUInt32BE(c[2], 8), l.writeUInt32BE(c[1], 12), l;
};
AES.prototype.scrub = function() {
  scrubVec(this._keySchedule), scrubVec(this._invKeySchedule), scrubVec(this._key);
};
aes$5.AES = AES;
var Buffer$l = safeBufferExports$3.Buffer, ZEROES = Buffer$l.alloc(16, 0);
function toArray$1(a) {
  return [
    a.readUInt32BE(0),
    a.readUInt32BE(4),
    a.readUInt32BE(8),
    a.readUInt32BE(12)
  ];
}
function fromArray(a) {
  var u = Buffer$l.allocUnsafe(16);
  return u.writeUInt32BE(a[0] >>> 0, 0), u.writeUInt32BE(a[1] >>> 0, 4), u.writeUInt32BE(a[2] >>> 0, 8), u.writeUInt32BE(a[3] >>> 0, 12), u;
}
function GHASH$1(a) {
  this.h = a, this.state = Buffer$l.alloc(16, 0), this.cache = Buffer$l.allocUnsafe(0);
}
GHASH$1.prototype.ghash = function(a) {
  for (var u = -1; ++u < a.length; )
    this.state[u] ^= a[u];
  this._multiply();
};
GHASH$1.prototype._multiply = function() {
  for (var a = toArray$1(this.h), u = [0, 0, 0, 0], c, l, v, p = -1; ++p < 128; ) {
    for (l = (this.state[~~(p / 8)] & 1 << 7 - p % 8) !== 0, l && (u[0] ^= a[0], u[1] ^= a[1], u[2] ^= a[2], u[3] ^= a[3]), v = (a[3] & 1) !== 0, c = 3; c > 0; c--)
      a[c] = a[c] >>> 1 | (a[c - 1] & 1) << 31;
    a[0] = a[0] >>> 1, v && (a[0] = a[0] ^ 225 << 24);
  }
  this.state = fromArray(u);
};
GHASH$1.prototype.update = function(a) {
  this.cache = Buffer$l.concat([this.cache, a]);
  for (var u; this.cache.length >= 16; )
    u = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(u);
};
GHASH$1.prototype.final = function(a, u) {
  return this.cache.length && this.ghash(Buffer$l.concat([this.cache, ZEROES], 16)), this.ghash(fromArray([0, a, 0, u])), this.state;
};
var ghash = GHASH$1, aes$4 = aes$5, Buffer$k = safeBufferExports$3.Buffer, Transform$5 = cipherBase, inherits$d = inherits_browserExports, GHASH = ghash, xor$3 = bufferXor, incr32 = incr32_1;
function xorTest(a, u) {
  var c = 0;
  a.length !== u.length && c++;
  for (var l = Math.min(a.length, u.length), v = 0; v < l; ++v)
    c += a[v] ^ u[v];
  return c;
}
function calcIv(a, u, c) {
  if (u.length === 12)
    return a._finID = Buffer$k.concat([u, Buffer$k.from([0, 0, 0, 1])]), Buffer$k.concat([u, Buffer$k.from([0, 0, 0, 2])]);
  var l = new GHASH(c), v = u.length, p = v % 16;
  l.update(u), p && (p = 16 - p, l.update(Buffer$k.alloc(p, 0))), l.update(Buffer$k.alloc(8, 0));
  var _ = v * 8, k = Buffer$k.alloc(8);
  k.writeUIntBE(_, 0, 8), l.update(k), a._finID = l.state;
  var M = Buffer$k.from(a._finID);
  return incr32(M), M;
}
function StreamCipher$3(a, u, c, l) {
  Transform$5.call(this);
  var v = Buffer$k.alloc(4, 0);
  this._cipher = new aes$4.AES(u);
  var p = this._cipher.encryptBlock(v);
  this._ghash = new GHASH(p), c = calcIv(this, c, p), this._prev = Buffer$k.from(c), this._cache = Buffer$k.allocUnsafe(0), this._secCache = Buffer$k.allocUnsafe(0), this._decrypt = l, this._alen = 0, this._len = 0, this._mode = a, this._authTag = null, this._called = !1;
}
inherits$d(StreamCipher$3, Transform$5);
StreamCipher$3.prototype._update = function(a) {
  if (!this._called && this._alen) {
    var u = 16 - this._alen % 16;
    u < 16 && (u = Buffer$k.alloc(u, 0), this._ghash.update(u));
  }
  this._called = !0;
  var c = this._mode.encrypt(this, a);
  return this._decrypt ? this._ghash.update(a) : this._ghash.update(c), this._len += a.length, c;
};
StreamCipher$3.prototype._final = function() {
  if (this._decrypt && !this._authTag)
    throw new Error("Unsupported state or unable to authenticate data");
  var a = xor$3(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
  if (this._decrypt && xorTest(a, this._authTag))
    throw new Error("Unsupported state or unable to authenticate data");
  this._authTag = a, this._cipher.scrub();
};
StreamCipher$3.prototype.getAuthTag = function a() {
  if (this._decrypt || !Buffer$k.isBuffer(this._authTag))
    throw new Error("Attempting to get auth tag in unsupported state");
  return this._authTag;
};
StreamCipher$3.prototype.setAuthTag = function a(u) {
  if (!this._decrypt)
    throw new Error("Attempting to set auth tag in unsupported state");
  this._authTag = u;
};
StreamCipher$3.prototype.setAAD = function a(u) {
  if (this._called)
    throw new Error("Attempting to set AAD in unsupported state");
  this._ghash.update(u), this._alen += u.length;
};
var authCipher = StreamCipher$3, aes$3 = aes$5, Buffer$j = safeBufferExports$3.Buffer, Transform$4 = cipherBase, inherits$c = inherits_browserExports;
function StreamCipher$2(a, u, c, l) {
  Transform$4.call(this), this._cipher = new aes$3.AES(u), this._prev = Buffer$j.from(c), this._cache = Buffer$j.allocUnsafe(0), this._secCache = Buffer$j.allocUnsafe(0), this._decrypt = l, this._mode = a;
}
inherits$c(StreamCipher$2, Transform$4);
StreamCipher$2.prototype._update = function(a) {
  return this._mode.encrypt(this, a, this._decrypt);
};
StreamCipher$2.prototype._final = function() {
  this._cipher.scrub();
};
var streamCipher = StreamCipher$2, Buffer$i = safeBufferExports$3.Buffer, MD5 = md5_js;
function EVP_BytesToKey(a, u, c, l) {
  if (Buffer$i.isBuffer(a) || (a = Buffer$i.from(a, "binary")), u && (Buffer$i.isBuffer(u) || (u = Buffer$i.from(u, "binary")), u.length !== 8))
    throw new RangeError("salt should be Buffer with 8 byte length");
  for (var v = c / 8, p = Buffer$i.alloc(v), _ = Buffer$i.alloc(l || 0), k = Buffer$i.alloc(0); v > 0 || l > 0; ) {
    var M = new MD5();
    M.update(k), M.update(a), u && M.update(u), k = M.digest();
    var L = 0;
    if (v > 0) {
      var F = p.length - v;
      L = Math.min(v, k.length), k.copy(p, F, 0, L), v -= L;
    }
    if (L < k.length && l > 0) {
      var V = _.length - l, X = Math.min(l, k.length - L);
      k.copy(_, V, L, L + X), l -= X;
    }
  }
  return k.fill(0), { key: p, iv: _ };
}
var evp_bytestokey = EVP_BytesToKey, MODES$1 = modes_1, AuthCipher$1 = authCipher, Buffer$h = safeBufferExports$3.Buffer, StreamCipher$1 = streamCipher, Transform$3 = cipherBase, aes$2 = aes$5, ebtk$2 = evp_bytestokey, inherits$b = inherits_browserExports;
function Cipher(a, u, c) {
  Transform$3.call(this), this._cache = new Splitter$1(), this._cipher = new aes$2.AES(u), this._prev = Buffer$h.from(c), this._mode = a, this._autopadding = !0;
}
inherits$b(Cipher, Transform$3);
Cipher.prototype._update = function(a) {
  this._cache.add(a);
  for (var u, c, l = []; u = this._cache.get(); )
    c = this._mode.encrypt(this, u), l.push(c);
  return Buffer$h.concat(l);
};
var PADDING$1 = Buffer$h.alloc(16, 16);
Cipher.prototype._final = function() {
  var a = this._cache.flush();
  if (this._autopadding)
    return a = this._mode.encrypt(this, a), this._cipher.scrub(), a;
  if (!a.equals(PADDING$1))
    throw this._cipher.scrub(), new Error("data not multiple of block length");
};
Cipher.prototype.setAutoPadding = function(a) {
  return this._autopadding = !!a, this;
};
function Splitter$1() {
  this.cache = Buffer$h.allocUnsafe(0);
}
Splitter$1.prototype.add = function(a) {
  this.cache = Buffer$h.concat([this.cache, a]);
};
Splitter$1.prototype.get = function() {
  if (this.cache.length > 15) {
    var a = this.cache.slice(0, 16);
    return this.cache = this.cache.slice(16), a;
  }
  return null;
};
Splitter$1.prototype.flush = function() {
  for (var a = 16 - this.cache.length, u = Buffer$h.allocUnsafe(a), c = -1; ++c < a; )
    u.writeUInt8(a, c);
  return Buffer$h.concat([this.cache, u]);
};
function createCipheriv$1(a, u, c) {
  var l = MODES$1[a.toLowerCase()];
  if (!l)
    throw new TypeError("invalid suite type");
  if (typeof u == "string" && (u = Buffer$h.from(u)), u.length !== l.key / 8)
    throw new TypeError("invalid key length " + u.length);
  if (typeof c == "string" && (c = Buffer$h.from(c)), l.mode !== "GCM" && c.length !== l.iv)
    throw new TypeError("invalid iv length " + c.length);
  return l.type === "stream" ? new StreamCipher$1(l.module, u, c) : l.type === "auth" ? new AuthCipher$1(l.module, u, c) : new Cipher(l.module, u, c);
}
function createCipher$1(a, u) {
  var c = MODES$1[a.toLowerCase()];
  if (!c)
    throw new TypeError("invalid suite type");
  var l = ebtk$2(u, !1, c.key, c.iv);
  return createCipheriv$1(a, l.key, l.iv);
}
encrypter.createCipheriv = createCipheriv$1;
encrypter.createCipher = createCipher$1;
var decrypter = {}, AuthCipher = authCipher, Buffer$g = safeBufferExports$3.Buffer, MODES = modes_1, StreamCipher = streamCipher, Transform$2 = cipherBase, aes$1 = aes$5, ebtk$1 = evp_bytestokey, inherits$a = inherits_browserExports;
function Decipher(a, u, c) {
  Transform$2.call(this), this._cache = new Splitter(), this._last = void 0, this._cipher = new aes$1.AES(u), this._prev = Buffer$g.from(c), this._mode = a, this._autopadding = !0;
}
inherits$a(Decipher, Transform$2);
Decipher.prototype._update = function(a) {
  this._cache.add(a);
  for (var u, c, l = []; u = this._cache.get(this._autopadding); )
    c = this._mode.decrypt(this, u), l.push(c);
  return Buffer$g.concat(l);
};
Decipher.prototype._final = function() {
  var a = this._cache.flush();
  if (this._autopadding)
    return unpad(this._mode.decrypt(this, a));
  if (a)
    throw new Error("data not multiple of block length");
};
Decipher.prototype.setAutoPadding = function(a) {
  return this._autopadding = !!a, this;
};
function Splitter() {
  this.cache = Buffer$g.allocUnsafe(0);
}
Splitter.prototype.add = function(a) {
  this.cache = Buffer$g.concat([this.cache, a]);
};
Splitter.prototype.get = function(a) {
  var u;
  if (a) {
    if (this.cache.length > 16)
      return u = this.cache.slice(0, 16), this.cache = this.cache.slice(16), u;
  } else if (this.cache.length >= 16)
    return u = this.cache.slice(0, 16), this.cache = this.cache.slice(16), u;
  return null;
};
Splitter.prototype.flush = function() {
  if (this.cache.length)
    return this.cache;
};
function unpad(a) {
  var u = a[15];
  if (u < 1 || u > 16)
    throw new Error("unable to decrypt data");
  for (var c = -1; ++c < u; )
    if (a[c + (16 - u)] !== u)
      throw new Error("unable to decrypt data");
  if (u !== 16)
    return a.slice(0, 16 - u);
}
function createDecipheriv$1(a, u, c) {
  var l = MODES[a.toLowerCase()];
  if (!l)
    throw new TypeError("invalid suite type");
  if (typeof c == "string" && (c = Buffer$g.from(c)), l.mode !== "GCM" && c.length !== l.iv)
    throw new TypeError("invalid iv length " + c.length);
  if (typeof u == "string" && (u = Buffer$g.from(u)), u.length !== l.key / 8)
    throw new TypeError("invalid key length " + u.length);
  return l.type === "stream" ? new StreamCipher(l.module, u, c, !0) : l.type === "auth" ? new AuthCipher(l.module, u, c, !0) : new Decipher(l.module, u, c);
}
function createDecipher$1(a, u) {
  var c = MODES[a.toLowerCase()];
  if (!c)
    throw new TypeError("invalid suite type");
  var l = ebtk$1(u, !1, c.key, c.iv);
  return createDecipheriv$1(a, l.key, l.iv);
}
decrypter.createDecipher = createDecipher$1;
decrypter.createDecipheriv = createDecipheriv$1;
var ciphers$2 = encrypter, deciphers = decrypter, modes$2 = require$$2;
function getCiphers$1() {
  return Object.keys(modes$2);
}
browser$6.createCipher = browser$6.Cipher = ciphers$2.createCipher;
browser$6.createCipheriv = browser$6.Cipheriv = ciphers$2.createCipheriv;
browser$6.createDecipher = browser$6.Decipher = deciphers.createDecipher;
browser$6.createDecipheriv = browser$6.Decipheriv = deciphers.createDecipheriv;
browser$6.listCiphers = browser$6.getCiphers = getCiphers$1;
var modes$1 = {};
(function(a) {
  a["des-ecb"] = {
    key: 8,
    iv: 0
  }, a["des-cbc"] = a.des = {
    key: 8,
    iv: 8
  }, a["des-ede3-cbc"] = a.des3 = {
    key: 24,
    iv: 8
  }, a["des-ede3"] = {
    key: 24,
    iv: 0
  }, a["des-ede-cbc"] = {
    key: 16,
    iv: 8
  }, a["des-ede"] = {
    key: 16,
    iv: 0
  };
})(modes$1);
var DES = browserifyDes, aes = browser$6, aesModes = modes_1, desModes = modes$1, ebtk = evp_bytestokey;
function createCipher(a, u) {
  a = a.toLowerCase();
  var c, l;
  if (aesModes[a])
    c = aesModes[a].key, l = aesModes[a].iv;
  else if (desModes[a])
    c = desModes[a].key * 8, l = desModes[a].iv;
  else
    throw new TypeError("invalid suite type");
  var v = ebtk(u, !1, c, l);
  return createCipheriv(a, v.key, v.iv);
}
function createDecipher(a, u) {
  a = a.toLowerCase();
  var c, l;
  if (aesModes[a])
    c = aesModes[a].key, l = aesModes[a].iv;
  else if (desModes[a])
    c = desModes[a].key * 8, l = desModes[a].iv;
  else
    throw new TypeError("invalid suite type");
  var v = ebtk(u, !1, c, l);
  return createDecipheriv(a, v.key, v.iv);
}
function createCipheriv(a, u, c) {
  if (a = a.toLowerCase(), aesModes[a])
    return aes.createCipheriv(a, u, c);
  if (desModes[a])
    return new DES({ key: u, iv: c, mode: a });
  throw new TypeError("invalid suite type");
}
function createDecipheriv(a, u, c) {
  if (a = a.toLowerCase(), aesModes[a])
    return aes.createDecipheriv(a, u, c);
  if (desModes[a])
    return new DES({ key: u, iv: c, mode: a, decrypt: !0 });
  throw new TypeError("invalid suite type");
}
function getCiphers() {
  return Object.keys(desModes).concat(aes.getCiphers());
}
browser$7.createCipher = browser$7.Cipher = createCipher;
browser$7.createCipheriv = browser$7.Cipheriv = createCipheriv;
browser$7.createDecipher = browser$7.Decipher = createDecipher;
browser$7.createDecipheriv = browser$7.Decipheriv = createDecipheriv;
browser$7.listCiphers = browser$7.getCiphers = getCiphers;
var browser$5 = {}, bn$6 = { exports: {} };
bn$6.exports;
(function(a) {
  (function(u, c) {
    function l(P, S) {
      if (!P)
        throw new Error(S || "Assertion failed");
    }
    function v(P, S) {
      P.super_ = S;
      var E = function() {
      };
      E.prototype = S.prototype, P.prototype = new E(), P.prototype.constructor = P;
    }
    function p(P, S, E) {
      if (p.isBN(P))
        return P;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, P !== null && ((S === "le" || S === "be") && (E = S, S = 10), this._init(P || 0, S || 10, E || "be"));
    }
    typeof u == "object" ? u.exports = p : c.BN = p, p.BN = p, p.wordSize = 26;
    var _;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? _ = window.Buffer : _ = require$$0$2.Buffer;
    } catch {
    }
    p.isBN = function(S) {
      return S instanceof p ? !0 : S !== null && typeof S == "object" && S.constructor.wordSize === p.wordSize && Array.isArray(S.words);
    }, p.max = function(S, E) {
      return S.cmp(E) > 0 ? S : E;
    }, p.min = function(S, E) {
      return S.cmp(E) < 0 ? S : E;
    }, p.prototype._init = function(S, E, I) {
      if (typeof S == "number")
        return this._initNumber(S, E, I);
      if (typeof S == "object")
        return this._initArray(S, E, I);
      E === "hex" && (E = 16), l(E === (E | 0) && E >= 2 && E <= 36), S = S.toString().replace(/\s+/g, "");
      var N = 0;
      S[0] === "-" && (N++, this.negative = 1), N < S.length && (E === 16 ? this._parseHex(S, N, I) : (this._parseBase(S, E, N), I === "le" && this._initArray(this.toArray(), E, I)));
    }, p.prototype._initNumber = function(S, E, I) {
      S < 0 && (this.negative = 1, S = -S), S < 67108864 ? (this.words = [S & 67108863], this.length = 1) : S < 4503599627370496 ? (this.words = [
        S & 67108863,
        S / 67108864 & 67108863
      ], this.length = 2) : (l(S < 9007199254740992), this.words = [
        S & 67108863,
        S / 67108864 & 67108863,
        1
      ], this.length = 3), I === "le" && this._initArray(this.toArray(), E, I);
    }, p.prototype._initArray = function(S, E, I) {
      if (l(typeof S.length == "number"), S.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(S.length / 3), this.words = new Array(this.length);
      for (var N = 0; N < this.length; N++)
        this.words[N] = 0;
      var $, U, H = 0;
      if (I === "be")
        for (N = S.length - 1, $ = 0; N >= 0; N -= 3)
          U = S[N] | S[N - 1] << 8 | S[N - 2] << 16, this.words[$] |= U << H & 67108863, this.words[$ + 1] = U >>> 26 - H & 67108863, H += 24, H >= 26 && (H -= 26, $++);
      else if (I === "le")
        for (N = 0, $ = 0; N < S.length; N += 3)
          U = S[N] | S[N + 1] << 8 | S[N + 2] << 16, this.words[$] |= U << H & 67108863, this.words[$ + 1] = U >>> 26 - H & 67108863, H += 24, H >= 26 && (H -= 26, $++);
      return this.strip();
    };
    function k(P, S) {
      var E = P.charCodeAt(S);
      return E >= 65 && E <= 70 ? E - 55 : E >= 97 && E <= 102 ? E - 87 : E - 48 & 15;
    }
    function M(P, S, E) {
      var I = k(P, E);
      return E - 1 >= S && (I |= k(P, E - 1) << 4), I;
    }
    p.prototype._parseHex = function(S, E, I) {
      this.length = Math.ceil((S.length - E) / 6), this.words = new Array(this.length);
      for (var N = 0; N < this.length; N++)
        this.words[N] = 0;
      var $ = 0, U = 0, H;
      if (I === "be")
        for (N = S.length - 1; N >= E; N -= 2)
          H = M(S, E, N) << $, this.words[U] |= H & 67108863, $ >= 18 ? ($ -= 18, U += 1, this.words[U] |= H >>> 26) : $ += 8;
      else {
        var B = S.length - E;
        for (N = B % 2 === 0 ? E + 1 : E; N < S.length; N += 2)
          H = M(S, E, N) << $, this.words[U] |= H & 67108863, $ >= 18 ? ($ -= 18, U += 1, this.words[U] |= H >>> 26) : $ += 8;
      }
      this.strip();
    };
    function L(P, S, E, I) {
      for (var N = 0, $ = Math.min(P.length, E), U = S; U < $; U++) {
        var H = P.charCodeAt(U) - 48;
        N *= I, H >= 49 ? N += H - 49 + 10 : H >= 17 ? N += H - 17 + 10 : N += H;
      }
      return N;
    }
    p.prototype._parseBase = function(S, E, I) {
      this.words = [0], this.length = 1;
      for (var N = 0, $ = 1; $ <= 67108863; $ *= E)
        N++;
      N--, $ = $ / E | 0;
      for (var U = S.length - I, H = U % N, B = Math.min(U, U - H) + I, T = 0, D = I; D < B; D += N)
        T = L(S, D, D + N, E), this.imuln($), this.words[0] + T < 67108864 ? this.words[0] += T : this._iaddn(T);
      if (H !== 0) {
        var ee = 1;
        for (T = L(S, D, S.length, E), D = 0; D < H; D++)
          ee *= E;
        this.imuln(ee), this.words[0] + T < 67108864 ? this.words[0] += T : this._iaddn(T);
      }
      this.strip();
    }, p.prototype.copy = function(S) {
      S.words = new Array(this.length);
      for (var E = 0; E < this.length; E++)
        S.words[E] = this.words[E];
      S.length = this.length, S.negative = this.negative, S.red = this.red;
    }, p.prototype.clone = function() {
      var S = new p(null);
      return this.copy(S), S;
    }, p.prototype._expand = function(S) {
      for (; this.length < S; )
        this.words[this.length++] = 0;
      return this;
    }, p.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, p.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, p.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var F = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], V = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], X = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    p.prototype.toString = function(S, E) {
      S = S || 10, E = E | 0 || 1;
      var I;
      if (S === 16 || S === "hex") {
        I = "";
        for (var N = 0, $ = 0, U = 0; U < this.length; U++) {
          var H = this.words[U], B = ((H << N | $) & 16777215).toString(16);
          $ = H >>> 24 - N & 16777215, $ !== 0 || U !== this.length - 1 ? I = F[6 - B.length] + B + I : I = B + I, N += 2, N >= 26 && (N -= 26, U--);
        }
        for ($ !== 0 && (I = $.toString(16) + I); I.length % E !== 0; )
          I = "0" + I;
        return this.negative !== 0 && (I = "-" + I), I;
      }
      if (S === (S | 0) && S >= 2 && S <= 36) {
        var T = V[S], D = X[S];
        I = "";
        var ee = this.clone();
        for (ee.negative = 0; !ee.isZero(); ) {
          var pe = ee.modn(D).toString(S);
          ee = ee.idivn(D), ee.isZero() ? I = pe + I : I = F[T - pe.length] + pe + I;
        }
        for (this.isZero() && (I = "0" + I); I.length % E !== 0; )
          I = "0" + I;
        return this.negative !== 0 && (I = "-" + I), I;
      }
      l(!1, "Base should be between 2 and 36");
    }, p.prototype.toNumber = function() {
      var S = this.words[0];
      return this.length === 2 ? S += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? S += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && l(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -S : S;
    }, p.prototype.toJSON = function() {
      return this.toString(16);
    }, p.prototype.toBuffer = function(S, E) {
      return l(typeof _ < "u"), this.toArrayLike(_, S, E);
    }, p.prototype.toArray = function(S, E) {
      return this.toArrayLike(Array, S, E);
    }, p.prototype.toArrayLike = function(S, E, I) {
      var N = this.byteLength(), $ = I || Math.max(1, N);
      l(N <= $, "byte array longer than desired length"), l($ > 0, "Requested array length <= 0"), this.strip();
      var U = E === "le", H = new S($), B, T, D = this.clone();
      if (U) {
        for (T = 0; !D.isZero(); T++)
          B = D.andln(255), D.iushrn(8), H[T] = B;
        for (; T < $; T++)
          H[T] = 0;
      } else {
        for (T = 0; T < $ - N; T++)
          H[T] = 0;
        for (T = 0; !D.isZero(); T++)
          B = D.andln(255), D.iushrn(8), H[$ - T - 1] = B;
      }
      return H;
    }, Math.clz32 ? p.prototype._countBits = function(S) {
      return 32 - Math.clz32(S);
    } : p.prototype._countBits = function(S) {
      var E = S, I = 0;
      return E >= 4096 && (I += 13, E >>>= 13), E >= 64 && (I += 7, E >>>= 7), E >= 8 && (I += 4, E >>>= 4), E >= 2 && (I += 2, E >>>= 2), I + E;
    }, p.prototype._zeroBits = function(S) {
      if (S === 0)
        return 26;
      var E = S, I = 0;
      return E & 8191 || (I += 13, E >>>= 13), E & 127 || (I += 7, E >>>= 7), E & 15 || (I += 4, E >>>= 4), E & 3 || (I += 2, E >>>= 2), E & 1 || I++, I;
    }, p.prototype.bitLength = function() {
      var S = this.words[this.length - 1], E = this._countBits(S);
      return (this.length - 1) * 26 + E;
    };
    function oe(P) {
      for (var S = new Array(P.bitLength()), E = 0; E < S.length; E++) {
        var I = E / 26 | 0, N = E % 26;
        S[E] = (P.words[I] & 1 << N) >>> N;
      }
      return S;
    }
    p.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var S = 0, E = 0; E < this.length; E++) {
        var I = this._zeroBits(this.words[E]);
        if (S += I, I !== 26)
          break;
      }
      return S;
    }, p.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, p.prototype.toTwos = function(S) {
      return this.negative !== 0 ? this.abs().inotn(S).iaddn(1) : this.clone();
    }, p.prototype.fromTwos = function(S) {
      return this.testn(S - 1) ? this.notn(S).iaddn(1).ineg() : this.clone();
    }, p.prototype.isNeg = function() {
      return this.negative !== 0;
    }, p.prototype.neg = function() {
      return this.clone().ineg();
    }, p.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, p.prototype.iuor = function(S) {
      for (; this.length < S.length; )
        this.words[this.length++] = 0;
      for (var E = 0; E < S.length; E++)
        this.words[E] = this.words[E] | S.words[E];
      return this.strip();
    }, p.prototype.ior = function(S) {
      return l((this.negative | S.negative) === 0), this.iuor(S);
    }, p.prototype.or = function(S) {
      return this.length > S.length ? this.clone().ior(S) : S.clone().ior(this);
    }, p.prototype.uor = function(S) {
      return this.length > S.length ? this.clone().iuor(S) : S.clone().iuor(this);
    }, p.prototype.iuand = function(S) {
      var E;
      this.length > S.length ? E = S : E = this;
      for (var I = 0; I < E.length; I++)
        this.words[I] = this.words[I] & S.words[I];
      return this.length = E.length, this.strip();
    }, p.prototype.iand = function(S) {
      return l((this.negative | S.negative) === 0), this.iuand(S);
    }, p.prototype.and = function(S) {
      return this.length > S.length ? this.clone().iand(S) : S.clone().iand(this);
    }, p.prototype.uand = function(S) {
      return this.length > S.length ? this.clone().iuand(S) : S.clone().iuand(this);
    }, p.prototype.iuxor = function(S) {
      var E, I;
      this.length > S.length ? (E = this, I = S) : (E = S, I = this);
      for (var N = 0; N < I.length; N++)
        this.words[N] = E.words[N] ^ I.words[N];
      if (this !== E)
        for (; N < E.length; N++)
          this.words[N] = E.words[N];
      return this.length = E.length, this.strip();
    }, p.prototype.ixor = function(S) {
      return l((this.negative | S.negative) === 0), this.iuxor(S);
    }, p.prototype.xor = function(S) {
      return this.length > S.length ? this.clone().ixor(S) : S.clone().ixor(this);
    }, p.prototype.uxor = function(S) {
      return this.length > S.length ? this.clone().iuxor(S) : S.clone().iuxor(this);
    }, p.prototype.inotn = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = Math.ceil(S / 26) | 0, I = S % 26;
      this._expand(E), I > 0 && E--;
      for (var N = 0; N < E; N++)
        this.words[N] = ~this.words[N] & 67108863;
      return I > 0 && (this.words[N] = ~this.words[N] & 67108863 >> 26 - I), this.strip();
    }, p.prototype.notn = function(S) {
      return this.clone().inotn(S);
    }, p.prototype.setn = function(S, E) {
      l(typeof S == "number" && S >= 0);
      var I = S / 26 | 0, N = S % 26;
      return this._expand(I + 1), E ? this.words[I] = this.words[I] | 1 << N : this.words[I] = this.words[I] & ~(1 << N), this.strip();
    }, p.prototype.iadd = function(S) {
      var E;
      if (this.negative !== 0 && S.negative === 0)
        return this.negative = 0, E = this.isub(S), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && S.negative !== 0)
        return S.negative = 0, E = this.isub(S), S.negative = 1, E._normSign();
      var I, N;
      this.length > S.length ? (I = this, N = S) : (I = S, N = this);
      for (var $ = 0, U = 0; U < N.length; U++)
        E = (I.words[U] | 0) + (N.words[U] | 0) + $, this.words[U] = E & 67108863, $ = E >>> 26;
      for (; $ !== 0 && U < I.length; U++)
        E = (I.words[U] | 0) + $, this.words[U] = E & 67108863, $ = E >>> 26;
      if (this.length = I.length, $ !== 0)
        this.words[this.length] = $, this.length++;
      else if (I !== this)
        for (; U < I.length; U++)
          this.words[U] = I.words[U];
      return this;
    }, p.prototype.add = function(S) {
      var E;
      return S.negative !== 0 && this.negative === 0 ? (S.negative = 0, E = this.sub(S), S.negative ^= 1, E) : S.negative === 0 && this.negative !== 0 ? (this.negative = 0, E = S.sub(this), this.negative = 1, E) : this.length > S.length ? this.clone().iadd(S) : S.clone().iadd(this);
    }, p.prototype.isub = function(S) {
      if (S.negative !== 0) {
        S.negative = 0;
        var E = this.iadd(S);
        return S.negative = 1, E._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(S), this.negative = 1, this._normSign();
      var I = this.cmp(S);
      if (I === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var N, $;
      I > 0 ? (N = this, $ = S) : (N = S, $ = this);
      for (var U = 0, H = 0; H < $.length; H++)
        E = (N.words[H] | 0) - ($.words[H] | 0) + U, U = E >> 26, this.words[H] = E & 67108863;
      for (; U !== 0 && H < N.length; H++)
        E = (N.words[H] | 0) + U, U = E >> 26, this.words[H] = E & 67108863;
      if (U === 0 && H < N.length && N !== this)
        for (; H < N.length; H++)
          this.words[H] = N.words[H];
      return this.length = Math.max(this.length, H), N !== this && (this.negative = 1), this.strip();
    }, p.prototype.sub = function(S) {
      return this.clone().isub(S);
    };
    function Y(P, S, E) {
      E.negative = S.negative ^ P.negative;
      var I = P.length + S.length | 0;
      E.length = I, I = I - 1 | 0;
      var N = P.words[0] | 0, $ = S.words[0] | 0, U = N * $, H = U & 67108863, B = U / 67108864 | 0;
      E.words[0] = H;
      for (var T = 1; T < I; T++) {
        for (var D = B >>> 26, ee = B & 67108863, pe = Math.min(T, S.length - 1), Ie = Math.max(0, T - P.length + 1); Ie <= pe; Ie++) {
          var Pe = T - Ie | 0;
          N = P.words[Pe] | 0, $ = S.words[Ie] | 0, U = N * $ + ee, D += U / 67108864 | 0, ee = U & 67108863;
        }
        E.words[T] = ee | 0, B = D | 0;
      }
      return B !== 0 ? E.words[T] = B | 0 : E.length--, E.strip();
    }
    var ae = function(S, E, I) {
      var N = S.words, $ = E.words, U = I.words, H = 0, B, T, D, ee = N[0] | 0, pe = ee & 8191, Ie = ee >>> 13, Pe = N[1] | 0, he = Pe & 8191, ve = Pe >>> 13, Q = N[2] | 0, le = Q & 8191, _e = Q >>> 13, re = N[3] | 0, O = re & 8191, j = re >>> 13, ce = N[4] | 0, De = ce & 8191, Ne = ce >>> 13, Fe = N[5] | 0, Ze = Fe & 8191, qe = Fe >>> 13, gt = N[6] | 0, Xe = gt & 8191, Ge = gt >>> 13, J = N[7] | 0, ye = J & 8191, we = J >>> 13, We = N[8] | 0, Re = We & 8191, q = We >>> 13, ke = N[9] | 0, de = ke & 8191, ue = ke >>> 13, me = $[0] | 0, Oe = me & 8191, Ue = me >>> 13, ze = $[1] | 0, Ve = ze & 8191, Qe = ze >>> 13, Ke = $[2] | 0, x = Ke & 8191, se = Ke >>> 13, Ee = $[3] | 0, xe = Ee & 8191, $e = Ee >>> 13, Ye = $[4] | 0, et = Ye & 8191, dt = Ye >>> 13, St = $[5] | 0, tt = St & 8191, at = St >>> 13, wt = $[6] | 0, rt = wt & 8191, ut = wt >>> 13, kt = $[7] | 0, nt = kt & 8191, it = kt >>> 13, bt = $[8] | 0, ot = bt & 8191, ct = bt >>> 13, Ot = $[9] | 0, st = Ot & 8191, lt = Ot >>> 13;
      I.negative = S.negative ^ E.negative, I.length = 19, B = Math.imul(pe, Oe), T = Math.imul(pe, Ue), T = T + Math.imul(Ie, Oe) | 0, D = Math.imul(Ie, Ue);
      var Rt = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (Rt >>> 26) | 0, Rt &= 67108863, B = Math.imul(he, Oe), T = Math.imul(he, Ue), T = T + Math.imul(ve, Oe) | 0, D = Math.imul(ve, Ue), B = B + Math.imul(pe, Ve) | 0, T = T + Math.imul(pe, Qe) | 0, T = T + Math.imul(Ie, Ve) | 0, D = D + Math.imul(Ie, Qe) | 0;
      var Ct = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (Ct >>> 26) | 0, Ct &= 67108863, B = Math.imul(le, Oe), T = Math.imul(le, Ue), T = T + Math.imul(_e, Oe) | 0, D = Math.imul(_e, Ue), B = B + Math.imul(he, Ve) | 0, T = T + Math.imul(he, Qe) | 0, T = T + Math.imul(ve, Ve) | 0, D = D + Math.imul(ve, Qe) | 0, B = B + Math.imul(pe, x) | 0, T = T + Math.imul(pe, se) | 0, T = T + Math.imul(Ie, x) | 0, D = D + Math.imul(Ie, se) | 0;
      var Je = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, B = Math.imul(O, Oe), T = Math.imul(O, Ue), T = T + Math.imul(j, Oe) | 0, D = Math.imul(j, Ue), B = B + Math.imul(le, Ve) | 0, T = T + Math.imul(le, Qe) | 0, T = T + Math.imul(_e, Ve) | 0, D = D + Math.imul(_e, Qe) | 0, B = B + Math.imul(he, x) | 0, T = T + Math.imul(he, se) | 0, T = T + Math.imul(ve, x) | 0, D = D + Math.imul(ve, se) | 0, B = B + Math.imul(pe, xe) | 0, T = T + Math.imul(pe, $e) | 0, T = T + Math.imul(Ie, xe) | 0, D = D + Math.imul(Ie, $e) | 0;
      var He = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, B = Math.imul(De, Oe), T = Math.imul(De, Ue), T = T + Math.imul(Ne, Oe) | 0, D = Math.imul(Ne, Ue), B = B + Math.imul(O, Ve) | 0, T = T + Math.imul(O, Qe) | 0, T = T + Math.imul(j, Ve) | 0, D = D + Math.imul(j, Qe) | 0, B = B + Math.imul(le, x) | 0, T = T + Math.imul(le, se) | 0, T = T + Math.imul(_e, x) | 0, D = D + Math.imul(_e, se) | 0, B = B + Math.imul(he, xe) | 0, T = T + Math.imul(he, $e) | 0, T = T + Math.imul(ve, xe) | 0, D = D + Math.imul(ve, $e) | 0, B = B + Math.imul(pe, et) | 0, T = T + Math.imul(pe, dt) | 0, T = T + Math.imul(Ie, et) | 0, D = D + Math.imul(Ie, dt) | 0;
      var je = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, B = Math.imul(Ze, Oe), T = Math.imul(Ze, Ue), T = T + Math.imul(qe, Oe) | 0, D = Math.imul(qe, Ue), B = B + Math.imul(De, Ve) | 0, T = T + Math.imul(De, Qe) | 0, T = T + Math.imul(Ne, Ve) | 0, D = D + Math.imul(Ne, Qe) | 0, B = B + Math.imul(O, x) | 0, T = T + Math.imul(O, se) | 0, T = T + Math.imul(j, x) | 0, D = D + Math.imul(j, se) | 0, B = B + Math.imul(le, xe) | 0, T = T + Math.imul(le, $e) | 0, T = T + Math.imul(_e, xe) | 0, D = D + Math.imul(_e, $e) | 0, B = B + Math.imul(he, et) | 0, T = T + Math.imul(he, dt) | 0, T = T + Math.imul(ve, et) | 0, D = D + Math.imul(ve, dt) | 0, B = B + Math.imul(pe, tt) | 0, T = T + Math.imul(pe, at) | 0, T = T + Math.imul(Ie, tt) | 0, D = D + Math.imul(Ie, at) | 0;
      var pt = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (pt >>> 26) | 0, pt &= 67108863, B = Math.imul(Xe, Oe), T = Math.imul(Xe, Ue), T = T + Math.imul(Ge, Oe) | 0, D = Math.imul(Ge, Ue), B = B + Math.imul(Ze, Ve) | 0, T = T + Math.imul(Ze, Qe) | 0, T = T + Math.imul(qe, Ve) | 0, D = D + Math.imul(qe, Qe) | 0, B = B + Math.imul(De, x) | 0, T = T + Math.imul(De, se) | 0, T = T + Math.imul(Ne, x) | 0, D = D + Math.imul(Ne, se) | 0, B = B + Math.imul(O, xe) | 0, T = T + Math.imul(O, $e) | 0, T = T + Math.imul(j, xe) | 0, D = D + Math.imul(j, $e) | 0, B = B + Math.imul(le, et) | 0, T = T + Math.imul(le, dt) | 0, T = T + Math.imul(_e, et) | 0, D = D + Math.imul(_e, dt) | 0, B = B + Math.imul(he, tt) | 0, T = T + Math.imul(he, at) | 0, T = T + Math.imul(ve, tt) | 0, D = D + Math.imul(ve, at) | 0, B = B + Math.imul(pe, rt) | 0, T = T + Math.imul(pe, ut) | 0, T = T + Math.imul(Ie, rt) | 0, D = D + Math.imul(Ie, ut) | 0;
      var mt = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (mt >>> 26) | 0, mt &= 67108863, B = Math.imul(ye, Oe), T = Math.imul(ye, Ue), T = T + Math.imul(we, Oe) | 0, D = Math.imul(we, Ue), B = B + Math.imul(Xe, Ve) | 0, T = T + Math.imul(Xe, Qe) | 0, T = T + Math.imul(Ge, Ve) | 0, D = D + Math.imul(Ge, Qe) | 0, B = B + Math.imul(Ze, x) | 0, T = T + Math.imul(Ze, se) | 0, T = T + Math.imul(qe, x) | 0, D = D + Math.imul(qe, se) | 0, B = B + Math.imul(De, xe) | 0, T = T + Math.imul(De, $e) | 0, T = T + Math.imul(Ne, xe) | 0, D = D + Math.imul(Ne, $e) | 0, B = B + Math.imul(O, et) | 0, T = T + Math.imul(O, dt) | 0, T = T + Math.imul(j, et) | 0, D = D + Math.imul(j, dt) | 0, B = B + Math.imul(le, tt) | 0, T = T + Math.imul(le, at) | 0, T = T + Math.imul(_e, tt) | 0, D = D + Math.imul(_e, at) | 0, B = B + Math.imul(he, rt) | 0, T = T + Math.imul(he, ut) | 0, T = T + Math.imul(ve, rt) | 0, D = D + Math.imul(ve, ut) | 0, B = B + Math.imul(pe, nt) | 0, T = T + Math.imul(pe, it) | 0, T = T + Math.imul(Ie, nt) | 0, D = D + Math.imul(Ie, it) | 0;
      var yt = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (yt >>> 26) | 0, yt &= 67108863, B = Math.imul(Re, Oe), T = Math.imul(Re, Ue), T = T + Math.imul(q, Oe) | 0, D = Math.imul(q, Ue), B = B + Math.imul(ye, Ve) | 0, T = T + Math.imul(ye, Qe) | 0, T = T + Math.imul(we, Ve) | 0, D = D + Math.imul(we, Qe) | 0, B = B + Math.imul(Xe, x) | 0, T = T + Math.imul(Xe, se) | 0, T = T + Math.imul(Ge, x) | 0, D = D + Math.imul(Ge, se) | 0, B = B + Math.imul(Ze, xe) | 0, T = T + Math.imul(Ze, $e) | 0, T = T + Math.imul(qe, xe) | 0, D = D + Math.imul(qe, $e) | 0, B = B + Math.imul(De, et) | 0, T = T + Math.imul(De, dt) | 0, T = T + Math.imul(Ne, et) | 0, D = D + Math.imul(Ne, dt) | 0, B = B + Math.imul(O, tt) | 0, T = T + Math.imul(O, at) | 0, T = T + Math.imul(j, tt) | 0, D = D + Math.imul(j, at) | 0, B = B + Math.imul(le, rt) | 0, T = T + Math.imul(le, ut) | 0, T = T + Math.imul(_e, rt) | 0, D = D + Math.imul(_e, ut) | 0, B = B + Math.imul(he, nt) | 0, T = T + Math.imul(he, it) | 0, T = T + Math.imul(ve, nt) | 0, D = D + Math.imul(ve, it) | 0, B = B + Math.imul(pe, ot) | 0, T = T + Math.imul(pe, ct) | 0, T = T + Math.imul(Ie, ot) | 0, D = D + Math.imul(Ie, ct) | 0;
      var ht = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (ht >>> 26) | 0, ht &= 67108863, B = Math.imul(de, Oe), T = Math.imul(de, Ue), T = T + Math.imul(ue, Oe) | 0, D = Math.imul(ue, Ue), B = B + Math.imul(Re, Ve) | 0, T = T + Math.imul(Re, Qe) | 0, T = T + Math.imul(q, Ve) | 0, D = D + Math.imul(q, Qe) | 0, B = B + Math.imul(ye, x) | 0, T = T + Math.imul(ye, se) | 0, T = T + Math.imul(we, x) | 0, D = D + Math.imul(we, se) | 0, B = B + Math.imul(Xe, xe) | 0, T = T + Math.imul(Xe, $e) | 0, T = T + Math.imul(Ge, xe) | 0, D = D + Math.imul(Ge, $e) | 0, B = B + Math.imul(Ze, et) | 0, T = T + Math.imul(Ze, dt) | 0, T = T + Math.imul(qe, et) | 0, D = D + Math.imul(qe, dt) | 0, B = B + Math.imul(De, tt) | 0, T = T + Math.imul(De, at) | 0, T = T + Math.imul(Ne, tt) | 0, D = D + Math.imul(Ne, at) | 0, B = B + Math.imul(O, rt) | 0, T = T + Math.imul(O, ut) | 0, T = T + Math.imul(j, rt) | 0, D = D + Math.imul(j, ut) | 0, B = B + Math.imul(le, nt) | 0, T = T + Math.imul(le, it) | 0, T = T + Math.imul(_e, nt) | 0, D = D + Math.imul(_e, it) | 0, B = B + Math.imul(he, ot) | 0, T = T + Math.imul(he, ct) | 0, T = T + Math.imul(ve, ot) | 0, D = D + Math.imul(ve, ct) | 0, B = B + Math.imul(pe, st) | 0, T = T + Math.imul(pe, lt) | 0, T = T + Math.imul(Ie, st) | 0, D = D + Math.imul(Ie, lt) | 0;
      var _t = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (_t >>> 26) | 0, _t &= 67108863, B = Math.imul(de, Ve), T = Math.imul(de, Qe), T = T + Math.imul(ue, Ve) | 0, D = Math.imul(ue, Qe), B = B + Math.imul(Re, x) | 0, T = T + Math.imul(Re, se) | 0, T = T + Math.imul(q, x) | 0, D = D + Math.imul(q, se) | 0, B = B + Math.imul(ye, xe) | 0, T = T + Math.imul(ye, $e) | 0, T = T + Math.imul(we, xe) | 0, D = D + Math.imul(we, $e) | 0, B = B + Math.imul(Xe, et) | 0, T = T + Math.imul(Xe, dt) | 0, T = T + Math.imul(Ge, et) | 0, D = D + Math.imul(Ge, dt) | 0, B = B + Math.imul(Ze, tt) | 0, T = T + Math.imul(Ze, at) | 0, T = T + Math.imul(qe, tt) | 0, D = D + Math.imul(qe, at) | 0, B = B + Math.imul(De, rt) | 0, T = T + Math.imul(De, ut) | 0, T = T + Math.imul(Ne, rt) | 0, D = D + Math.imul(Ne, ut) | 0, B = B + Math.imul(O, nt) | 0, T = T + Math.imul(O, it) | 0, T = T + Math.imul(j, nt) | 0, D = D + Math.imul(j, it) | 0, B = B + Math.imul(le, ot) | 0, T = T + Math.imul(le, ct) | 0, T = T + Math.imul(_e, ot) | 0, D = D + Math.imul(_e, ct) | 0, B = B + Math.imul(he, st) | 0, T = T + Math.imul(he, lt) | 0, T = T + Math.imul(ve, st) | 0, D = D + Math.imul(ve, lt) | 0;
      var Et = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, B = Math.imul(de, x), T = Math.imul(de, se), T = T + Math.imul(ue, x) | 0, D = Math.imul(ue, se), B = B + Math.imul(Re, xe) | 0, T = T + Math.imul(Re, $e) | 0, T = T + Math.imul(q, xe) | 0, D = D + Math.imul(q, $e) | 0, B = B + Math.imul(ye, et) | 0, T = T + Math.imul(ye, dt) | 0, T = T + Math.imul(we, et) | 0, D = D + Math.imul(we, dt) | 0, B = B + Math.imul(Xe, tt) | 0, T = T + Math.imul(Xe, at) | 0, T = T + Math.imul(Ge, tt) | 0, D = D + Math.imul(Ge, at) | 0, B = B + Math.imul(Ze, rt) | 0, T = T + Math.imul(Ze, ut) | 0, T = T + Math.imul(qe, rt) | 0, D = D + Math.imul(qe, ut) | 0, B = B + Math.imul(De, nt) | 0, T = T + Math.imul(De, it) | 0, T = T + Math.imul(Ne, nt) | 0, D = D + Math.imul(Ne, it) | 0, B = B + Math.imul(O, ot) | 0, T = T + Math.imul(O, ct) | 0, T = T + Math.imul(j, ot) | 0, D = D + Math.imul(j, ct) | 0, B = B + Math.imul(le, st) | 0, T = T + Math.imul(le, lt) | 0, T = T + Math.imul(_e, st) | 0, D = D + Math.imul(_e, lt) | 0;
      var Nt = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, B = Math.imul(de, xe), T = Math.imul(de, $e), T = T + Math.imul(ue, xe) | 0, D = Math.imul(ue, $e), B = B + Math.imul(Re, et) | 0, T = T + Math.imul(Re, dt) | 0, T = T + Math.imul(q, et) | 0, D = D + Math.imul(q, dt) | 0, B = B + Math.imul(ye, tt) | 0, T = T + Math.imul(ye, at) | 0, T = T + Math.imul(we, tt) | 0, D = D + Math.imul(we, at) | 0, B = B + Math.imul(Xe, rt) | 0, T = T + Math.imul(Xe, ut) | 0, T = T + Math.imul(Ge, rt) | 0, D = D + Math.imul(Ge, ut) | 0, B = B + Math.imul(Ze, nt) | 0, T = T + Math.imul(Ze, it) | 0, T = T + Math.imul(qe, nt) | 0, D = D + Math.imul(qe, it) | 0, B = B + Math.imul(De, ot) | 0, T = T + Math.imul(De, ct) | 0, T = T + Math.imul(Ne, ot) | 0, D = D + Math.imul(Ne, ct) | 0, B = B + Math.imul(O, st) | 0, T = T + Math.imul(O, lt) | 0, T = T + Math.imul(j, st) | 0, D = D + Math.imul(j, lt) | 0;
      var Dt = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (Dt >>> 26) | 0, Dt &= 67108863, B = Math.imul(de, et), T = Math.imul(de, dt), T = T + Math.imul(ue, et) | 0, D = Math.imul(ue, dt), B = B + Math.imul(Re, tt) | 0, T = T + Math.imul(Re, at) | 0, T = T + Math.imul(q, tt) | 0, D = D + Math.imul(q, at) | 0, B = B + Math.imul(ye, rt) | 0, T = T + Math.imul(ye, ut) | 0, T = T + Math.imul(we, rt) | 0, D = D + Math.imul(we, ut) | 0, B = B + Math.imul(Xe, nt) | 0, T = T + Math.imul(Xe, it) | 0, T = T + Math.imul(Ge, nt) | 0, D = D + Math.imul(Ge, it) | 0, B = B + Math.imul(Ze, ot) | 0, T = T + Math.imul(Ze, ct) | 0, T = T + Math.imul(qe, ot) | 0, D = D + Math.imul(qe, ct) | 0, B = B + Math.imul(De, st) | 0, T = T + Math.imul(De, lt) | 0, T = T + Math.imul(Ne, st) | 0, D = D + Math.imul(Ne, lt) | 0;
      var $t = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + ($t >>> 26) | 0, $t &= 67108863, B = Math.imul(de, tt), T = Math.imul(de, at), T = T + Math.imul(ue, tt) | 0, D = Math.imul(ue, at), B = B + Math.imul(Re, rt) | 0, T = T + Math.imul(Re, ut) | 0, T = T + Math.imul(q, rt) | 0, D = D + Math.imul(q, ut) | 0, B = B + Math.imul(ye, nt) | 0, T = T + Math.imul(ye, it) | 0, T = T + Math.imul(we, nt) | 0, D = D + Math.imul(we, it) | 0, B = B + Math.imul(Xe, ot) | 0, T = T + Math.imul(Xe, ct) | 0, T = T + Math.imul(Ge, ot) | 0, D = D + Math.imul(Ge, ct) | 0, B = B + Math.imul(Ze, st) | 0, T = T + Math.imul(Ze, lt) | 0, T = T + Math.imul(qe, st) | 0, D = D + Math.imul(qe, lt) | 0;
      var At = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, B = Math.imul(de, rt), T = Math.imul(de, ut), T = T + Math.imul(ue, rt) | 0, D = Math.imul(ue, ut), B = B + Math.imul(Re, nt) | 0, T = T + Math.imul(Re, it) | 0, T = T + Math.imul(q, nt) | 0, D = D + Math.imul(q, it) | 0, B = B + Math.imul(ye, ot) | 0, T = T + Math.imul(ye, ct) | 0, T = T + Math.imul(we, ot) | 0, D = D + Math.imul(we, ct) | 0, B = B + Math.imul(Xe, st) | 0, T = T + Math.imul(Xe, lt) | 0, T = T + Math.imul(Ge, st) | 0, D = D + Math.imul(Ge, lt) | 0;
      var Lt = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (Lt >>> 26) | 0, Lt &= 67108863, B = Math.imul(de, nt), T = Math.imul(de, it), T = T + Math.imul(ue, nt) | 0, D = Math.imul(ue, it), B = B + Math.imul(Re, ot) | 0, T = T + Math.imul(Re, ct) | 0, T = T + Math.imul(q, ot) | 0, D = D + Math.imul(q, ct) | 0, B = B + Math.imul(ye, st) | 0, T = T + Math.imul(ye, lt) | 0, T = T + Math.imul(we, st) | 0, D = D + Math.imul(we, lt) | 0;
      var Bt = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, B = Math.imul(de, ot), T = Math.imul(de, ct), T = T + Math.imul(ue, ot) | 0, D = Math.imul(ue, ct), B = B + Math.imul(Re, st) | 0, T = T + Math.imul(Re, lt) | 0, T = T + Math.imul(q, st) | 0, D = D + Math.imul(q, lt) | 0;
      var Ut = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (Ut >>> 26) | 0, Ut &= 67108863, B = Math.imul(de, st), T = Math.imul(de, lt), T = T + Math.imul(ue, st) | 0, D = Math.imul(ue, lt);
      var xt = (H + B | 0) + ((T & 8191) << 13) | 0;
      return H = (D + (T >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, U[0] = Rt, U[1] = Ct, U[2] = Je, U[3] = He, U[4] = je, U[5] = pt, U[6] = mt, U[7] = yt, U[8] = ht, U[9] = _t, U[10] = Et, U[11] = Nt, U[12] = Dt, U[13] = $t, U[14] = At, U[15] = Lt, U[16] = Bt, U[17] = Ut, U[18] = xt, H !== 0 && (U[19] = H, I.length++), I;
    };
    Math.imul || (ae = Y);
    function ne(P, S, E) {
      E.negative = S.negative ^ P.negative, E.length = P.length + S.length;
      for (var I = 0, N = 0, $ = 0; $ < E.length - 1; $++) {
        var U = N;
        N = 0;
        for (var H = I & 67108863, B = Math.min($, S.length - 1), T = Math.max(0, $ - P.length + 1); T <= B; T++) {
          var D = $ - T, ee = P.words[D] | 0, pe = S.words[T] | 0, Ie = ee * pe, Pe = Ie & 67108863;
          U = U + (Ie / 67108864 | 0) | 0, Pe = Pe + H | 0, H = Pe & 67108863, U = U + (Pe >>> 26) | 0, N += U >>> 26, U &= 67108863;
        }
        E.words[$] = H, I = U, U = N;
      }
      return I !== 0 ? E.words[$] = I : E.length--, E.strip();
    }
    function fe(P, S, E) {
      var I = new ie();
      return I.mulp(P, S, E);
    }
    p.prototype.mulTo = function(S, E) {
      var I, N = this.length + S.length;
      return this.length === 10 && S.length === 10 ? I = ae(this, S, E) : N < 63 ? I = Y(this, S, E) : N < 1024 ? I = ne(this, S, E) : I = fe(this, S, E), I;
    };
    function ie(P, S) {
      this.x = P, this.y = S;
    }
    ie.prototype.makeRBT = function(S) {
      for (var E = new Array(S), I = p.prototype._countBits(S) - 1, N = 0; N < S; N++)
        E[N] = this.revBin(N, I, S);
      return E;
    }, ie.prototype.revBin = function(S, E, I) {
      if (S === 0 || S === I - 1)
        return S;
      for (var N = 0, $ = 0; $ < E; $++)
        N |= (S & 1) << E - $ - 1, S >>= 1;
      return N;
    }, ie.prototype.permute = function(S, E, I, N, $, U) {
      for (var H = 0; H < U; H++)
        N[H] = E[S[H]], $[H] = I[S[H]];
    }, ie.prototype.transform = function(S, E, I, N, $, U) {
      this.permute(U, S, E, I, N, $);
      for (var H = 1; H < $; H <<= 1)
        for (var B = H << 1, T = Math.cos(2 * Math.PI / B), D = Math.sin(2 * Math.PI / B), ee = 0; ee < $; ee += B)
          for (var pe = T, Ie = D, Pe = 0; Pe < H; Pe++) {
            var he = I[ee + Pe], ve = N[ee + Pe], Q = I[ee + Pe + H], le = N[ee + Pe + H], _e = pe * Q - Ie * le;
            le = pe * le + Ie * Q, Q = _e, I[ee + Pe] = he + Q, N[ee + Pe] = ve + le, I[ee + Pe + H] = he - Q, N[ee + Pe + H] = ve - le, Pe !== B && (_e = T * pe - D * Ie, Ie = T * Ie + D * pe, pe = _e);
          }
    }, ie.prototype.guessLen13b = function(S, E) {
      var I = Math.max(E, S) | 1, N = I & 1, $ = 0;
      for (I = I / 2 | 0; I; I = I >>> 1)
        $++;
      return 1 << $ + 1 + N;
    }, ie.prototype.conjugate = function(S, E, I) {
      if (!(I <= 1))
        for (var N = 0; N < I / 2; N++) {
          var $ = S[N];
          S[N] = S[I - N - 1], S[I - N - 1] = $, $ = E[N], E[N] = -E[I - N - 1], E[I - N - 1] = -$;
        }
    }, ie.prototype.normalize13b = function(S, E) {
      for (var I = 0, N = 0; N < E / 2; N++) {
        var $ = Math.round(S[2 * N + 1] / E) * 8192 + Math.round(S[2 * N] / E) + I;
        S[N] = $ & 67108863, $ < 67108864 ? I = 0 : I = $ / 67108864 | 0;
      }
      return S;
    }, ie.prototype.convert13b = function(S, E, I, N) {
      for (var $ = 0, U = 0; U < E; U++)
        $ = $ + (S[U] | 0), I[2 * U] = $ & 8191, $ = $ >>> 13, I[2 * U + 1] = $ & 8191, $ = $ >>> 13;
      for (U = 2 * E; U < N; ++U)
        I[U] = 0;
      l($ === 0), l(($ & -8192) === 0);
    }, ie.prototype.stub = function(S) {
      for (var E = new Array(S), I = 0; I < S; I++)
        E[I] = 0;
      return E;
    }, ie.prototype.mulp = function(S, E, I) {
      var N = 2 * this.guessLen13b(S.length, E.length), $ = this.makeRBT(N), U = this.stub(N), H = new Array(N), B = new Array(N), T = new Array(N), D = new Array(N), ee = new Array(N), pe = new Array(N), Ie = I.words;
      Ie.length = N, this.convert13b(S.words, S.length, H, N), this.convert13b(E.words, E.length, D, N), this.transform(H, U, B, T, N, $), this.transform(D, U, ee, pe, N, $);
      for (var Pe = 0; Pe < N; Pe++) {
        var he = B[Pe] * ee[Pe] - T[Pe] * pe[Pe];
        T[Pe] = B[Pe] * pe[Pe] + T[Pe] * ee[Pe], B[Pe] = he;
      }
      return this.conjugate(B, T, N), this.transform(B, T, Ie, U, N, $), this.conjugate(Ie, U, N), this.normalize13b(Ie, N), I.negative = S.negative ^ E.negative, I.length = S.length + E.length, I.strip();
    }, p.prototype.mul = function(S) {
      var E = new p(null);
      return E.words = new Array(this.length + S.length), this.mulTo(S, E);
    }, p.prototype.mulf = function(S) {
      var E = new p(null);
      return E.words = new Array(this.length + S.length), fe(this, S, E);
    }, p.prototype.imul = function(S) {
      return this.clone().mulTo(S, this);
    }, p.prototype.imuln = function(S) {
      l(typeof S == "number"), l(S < 67108864);
      for (var E = 0, I = 0; I < this.length; I++) {
        var N = (this.words[I] | 0) * S, $ = (N & 67108863) + (E & 67108863);
        E >>= 26, E += N / 67108864 | 0, E += $ >>> 26, this.words[I] = $ & 67108863;
      }
      return E !== 0 && (this.words[I] = E, this.length++), this;
    }, p.prototype.muln = function(S) {
      return this.clone().imuln(S);
    }, p.prototype.sqr = function() {
      return this.mul(this);
    }, p.prototype.isqr = function() {
      return this.imul(this.clone());
    }, p.prototype.pow = function(S) {
      var E = oe(S);
      if (E.length === 0)
        return new p(1);
      for (var I = this, N = 0; N < E.length && E[N] === 0; N++, I = I.sqr())
        ;
      if (++N < E.length)
        for (var $ = I.sqr(); N < E.length; N++, $ = $.sqr())
          E[N] !== 0 && (I = I.mul($));
      return I;
    }, p.prototype.iushln = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = S % 26, I = (S - E) / 26, N = 67108863 >>> 26 - E << 26 - E, $;
      if (E !== 0) {
        var U = 0;
        for ($ = 0; $ < this.length; $++) {
          var H = this.words[$] & N, B = (this.words[$] | 0) - H << E;
          this.words[$] = B | U, U = H >>> 26 - E;
        }
        U && (this.words[$] = U, this.length++);
      }
      if (I !== 0) {
        for ($ = this.length - 1; $ >= 0; $--)
          this.words[$ + I] = this.words[$];
        for ($ = 0; $ < I; $++)
          this.words[$] = 0;
        this.length += I;
      }
      return this.strip();
    }, p.prototype.ishln = function(S) {
      return l(this.negative === 0), this.iushln(S);
    }, p.prototype.iushrn = function(S, E, I) {
      l(typeof S == "number" && S >= 0);
      var N;
      E ? N = (E - E % 26) / 26 : N = 0;
      var $ = S % 26, U = Math.min((S - $) / 26, this.length), H = 67108863 ^ 67108863 >>> $ << $, B = I;
      if (N -= U, N = Math.max(0, N), B) {
        for (var T = 0; T < U; T++)
          B.words[T] = this.words[T];
        B.length = U;
      }
      if (U !== 0)
        if (this.length > U)
          for (this.length -= U, T = 0; T < this.length; T++)
            this.words[T] = this.words[T + U];
        else
          this.words[0] = 0, this.length = 1;
      var D = 0;
      for (T = this.length - 1; T >= 0 && (D !== 0 || T >= N); T--) {
        var ee = this.words[T] | 0;
        this.words[T] = D << 26 - $ | ee >>> $, D = ee & H;
      }
      return B && D !== 0 && (B.words[B.length++] = D), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, p.prototype.ishrn = function(S, E, I) {
      return l(this.negative === 0), this.iushrn(S, E, I);
    }, p.prototype.shln = function(S) {
      return this.clone().ishln(S);
    }, p.prototype.ushln = function(S) {
      return this.clone().iushln(S);
    }, p.prototype.shrn = function(S) {
      return this.clone().ishrn(S);
    }, p.prototype.ushrn = function(S) {
      return this.clone().iushrn(S);
    }, p.prototype.testn = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = S % 26, I = (S - E) / 26, N = 1 << E;
      if (this.length <= I)
        return !1;
      var $ = this.words[I];
      return !!($ & N);
    }, p.prototype.imaskn = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = S % 26, I = (S - E) / 26;
      if (l(this.negative === 0, "imaskn works only with positive numbers"), this.length <= I)
        return this;
      if (E !== 0 && I++, this.length = Math.min(I, this.length), E !== 0) {
        var N = 67108863 ^ 67108863 >>> E << E;
        this.words[this.length - 1] &= N;
      }
      return this.strip();
    }, p.prototype.maskn = function(S) {
      return this.clone().imaskn(S);
    }, p.prototype.iaddn = function(S) {
      return l(typeof S == "number"), l(S < 67108864), S < 0 ? this.isubn(-S) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < S ? (this.words[0] = S - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(S), this.negative = 1, this) : this._iaddn(S);
    }, p.prototype._iaddn = function(S) {
      this.words[0] += S;
      for (var E = 0; E < this.length && this.words[E] >= 67108864; E++)
        this.words[E] -= 67108864, E === this.length - 1 ? this.words[E + 1] = 1 : this.words[E + 1]++;
      return this.length = Math.max(this.length, E + 1), this;
    }, p.prototype.isubn = function(S) {
      if (l(typeof S == "number"), l(S < 67108864), S < 0)
        return this.iaddn(-S);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(S), this.negative = 1, this;
      if (this.words[0] -= S, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var E = 0; E < this.length && this.words[E] < 0; E++)
          this.words[E] += 67108864, this.words[E + 1] -= 1;
      return this.strip();
    }, p.prototype.addn = function(S) {
      return this.clone().iaddn(S);
    }, p.prototype.subn = function(S) {
      return this.clone().isubn(S);
    }, p.prototype.iabs = function() {
      return this.negative = 0, this;
    }, p.prototype.abs = function() {
      return this.clone().iabs();
    }, p.prototype._ishlnsubmul = function(S, E, I) {
      var N = S.length + I, $;
      this._expand(N);
      var U, H = 0;
      for ($ = 0; $ < S.length; $++) {
        U = (this.words[$ + I] | 0) + H;
        var B = (S.words[$] | 0) * E;
        U -= B & 67108863, H = (U >> 26) - (B / 67108864 | 0), this.words[$ + I] = U & 67108863;
      }
      for (; $ < this.length - I; $++)
        U = (this.words[$ + I] | 0) + H, H = U >> 26, this.words[$ + I] = U & 67108863;
      if (H === 0)
        return this.strip();
      for (l(H === -1), H = 0, $ = 0; $ < this.length; $++)
        U = -(this.words[$] | 0) + H, H = U >> 26, this.words[$] = U & 67108863;
      return this.negative = 1, this.strip();
    }, p.prototype._wordDiv = function(S, E) {
      var I = this.length - S.length, N = this.clone(), $ = S, U = $.words[$.length - 1] | 0, H = this._countBits(U);
      I = 26 - H, I !== 0 && ($ = $.ushln(I), N.iushln(I), U = $.words[$.length - 1] | 0);
      var B = N.length - $.length, T;
      if (E !== "mod") {
        T = new p(null), T.length = B + 1, T.words = new Array(T.length);
        for (var D = 0; D < T.length; D++)
          T.words[D] = 0;
      }
      var ee = N.clone()._ishlnsubmul($, 1, B);
      ee.negative === 0 && (N = ee, T && (T.words[B] = 1));
      for (var pe = B - 1; pe >= 0; pe--) {
        var Ie = (N.words[$.length + pe] | 0) * 67108864 + (N.words[$.length + pe - 1] | 0);
        for (Ie = Math.min(Ie / U | 0, 67108863), N._ishlnsubmul($, Ie, pe); N.negative !== 0; )
          Ie--, N.negative = 0, N._ishlnsubmul($, 1, pe), N.isZero() || (N.negative ^= 1);
        T && (T.words[pe] = Ie);
      }
      return T && T.strip(), N.strip(), E !== "div" && I !== 0 && N.iushrn(I), {
        div: T || null,
        mod: N
      };
    }, p.prototype.divmod = function(S, E, I) {
      if (l(!S.isZero()), this.isZero())
        return {
          div: new p(0),
          mod: new p(0)
        };
      var N, $, U;
      return this.negative !== 0 && S.negative === 0 ? (U = this.neg().divmod(S, E), E !== "mod" && (N = U.div.neg()), E !== "div" && ($ = U.mod.neg(), I && $.negative !== 0 && $.iadd(S)), {
        div: N,
        mod: $
      }) : this.negative === 0 && S.negative !== 0 ? (U = this.divmod(S.neg(), E), E !== "mod" && (N = U.div.neg()), {
        div: N,
        mod: U.mod
      }) : this.negative & S.negative ? (U = this.neg().divmod(S.neg(), E), E !== "div" && ($ = U.mod.neg(), I && $.negative !== 0 && $.isub(S)), {
        div: U.div,
        mod: $
      }) : S.length > this.length || this.cmp(S) < 0 ? {
        div: new p(0),
        mod: this
      } : S.length === 1 ? E === "div" ? {
        div: this.divn(S.words[0]),
        mod: null
      } : E === "mod" ? {
        div: null,
        mod: new p(this.modn(S.words[0]))
      } : {
        div: this.divn(S.words[0]),
        mod: new p(this.modn(S.words[0]))
      } : this._wordDiv(S, E);
    }, p.prototype.div = function(S) {
      return this.divmod(S, "div", !1).div;
    }, p.prototype.mod = function(S) {
      return this.divmod(S, "mod", !1).mod;
    }, p.prototype.umod = function(S) {
      return this.divmod(S, "mod", !0).mod;
    }, p.prototype.divRound = function(S) {
      var E = this.divmod(S);
      if (E.mod.isZero())
        return E.div;
      var I = E.div.negative !== 0 ? E.mod.isub(S) : E.mod, N = S.ushrn(1), $ = S.andln(1), U = I.cmp(N);
      return U < 0 || $ === 1 && U === 0 ? E.div : E.div.negative !== 0 ? E.div.isubn(1) : E.div.iaddn(1);
    }, p.prototype.modn = function(S) {
      l(S <= 67108863);
      for (var E = (1 << 26) % S, I = 0, N = this.length - 1; N >= 0; N--)
        I = (E * I + (this.words[N] | 0)) % S;
      return I;
    }, p.prototype.idivn = function(S) {
      l(S <= 67108863);
      for (var E = 0, I = this.length - 1; I >= 0; I--) {
        var N = (this.words[I] | 0) + E * 67108864;
        this.words[I] = N / S | 0, E = N % S;
      }
      return this.strip();
    }, p.prototype.divn = function(S) {
      return this.clone().idivn(S);
    }, p.prototype.egcd = function(S) {
      l(S.negative === 0), l(!S.isZero());
      var E = this, I = S.clone();
      E.negative !== 0 ? E = E.umod(S) : E = E.clone();
      for (var N = new p(1), $ = new p(0), U = new p(0), H = new p(1), B = 0; E.isEven() && I.isEven(); )
        E.iushrn(1), I.iushrn(1), ++B;
      for (var T = I.clone(), D = E.clone(); !E.isZero(); ) {
        for (var ee = 0, pe = 1; !(E.words[0] & pe) && ee < 26; ++ee, pe <<= 1)
          ;
        if (ee > 0)
          for (E.iushrn(ee); ee-- > 0; )
            (N.isOdd() || $.isOdd()) && (N.iadd(T), $.isub(D)), N.iushrn(1), $.iushrn(1);
        for (var Ie = 0, Pe = 1; !(I.words[0] & Pe) && Ie < 26; ++Ie, Pe <<= 1)
          ;
        if (Ie > 0)
          for (I.iushrn(Ie); Ie-- > 0; )
            (U.isOdd() || H.isOdd()) && (U.iadd(T), H.isub(D)), U.iushrn(1), H.iushrn(1);
        E.cmp(I) >= 0 ? (E.isub(I), N.isub(U), $.isub(H)) : (I.isub(E), U.isub(N), H.isub($));
      }
      return {
        a: U,
        b: H,
        gcd: I.iushln(B)
      };
    }, p.prototype._invmp = function(S) {
      l(S.negative === 0), l(!S.isZero());
      var E = this, I = S.clone();
      E.negative !== 0 ? E = E.umod(S) : E = E.clone();
      for (var N = new p(1), $ = new p(0), U = I.clone(); E.cmpn(1) > 0 && I.cmpn(1) > 0; ) {
        for (var H = 0, B = 1; !(E.words[0] & B) && H < 26; ++H, B <<= 1)
          ;
        if (H > 0)
          for (E.iushrn(H); H-- > 0; )
            N.isOdd() && N.iadd(U), N.iushrn(1);
        for (var T = 0, D = 1; !(I.words[0] & D) && T < 26; ++T, D <<= 1)
          ;
        if (T > 0)
          for (I.iushrn(T); T-- > 0; )
            $.isOdd() && $.iadd(U), $.iushrn(1);
        E.cmp(I) >= 0 ? (E.isub(I), N.isub($)) : (I.isub(E), $.isub(N));
      }
      var ee;
      return E.cmpn(1) === 0 ? ee = N : ee = $, ee.cmpn(0) < 0 && ee.iadd(S), ee;
    }, p.prototype.gcd = function(S) {
      if (this.isZero())
        return S.abs();
      if (S.isZero())
        return this.abs();
      var E = this.clone(), I = S.clone();
      E.negative = 0, I.negative = 0;
      for (var N = 0; E.isEven() && I.isEven(); N++)
        E.iushrn(1), I.iushrn(1);
      do {
        for (; E.isEven(); )
          E.iushrn(1);
        for (; I.isEven(); )
          I.iushrn(1);
        var $ = E.cmp(I);
        if ($ < 0) {
          var U = E;
          E = I, I = U;
        } else if ($ === 0 || I.cmpn(1) === 0)
          break;
        E.isub(I);
      } while (!0);
      return I.iushln(N);
    }, p.prototype.invm = function(S) {
      return this.egcd(S).a.umod(S);
    }, p.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, p.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, p.prototype.andln = function(S) {
      return this.words[0] & S;
    }, p.prototype.bincn = function(S) {
      l(typeof S == "number");
      var E = S % 26, I = (S - E) / 26, N = 1 << E;
      if (this.length <= I)
        return this._expand(I + 1), this.words[I] |= N, this;
      for (var $ = N, U = I; $ !== 0 && U < this.length; U++) {
        var H = this.words[U] | 0;
        H += $, $ = H >>> 26, H &= 67108863, this.words[U] = H;
      }
      return $ !== 0 && (this.words[U] = $, this.length++), this;
    }, p.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, p.prototype.cmpn = function(S) {
      var E = S < 0;
      if (this.negative !== 0 && !E)
        return -1;
      if (this.negative === 0 && E)
        return 1;
      this.strip();
      var I;
      if (this.length > 1)
        I = 1;
      else {
        E && (S = -S), l(S <= 67108863, "Number is too big");
        var N = this.words[0] | 0;
        I = N === S ? 0 : N < S ? -1 : 1;
      }
      return this.negative !== 0 ? -I | 0 : I;
    }, p.prototype.cmp = function(S) {
      if (this.negative !== 0 && S.negative === 0)
        return -1;
      if (this.negative === 0 && S.negative !== 0)
        return 1;
      var E = this.ucmp(S);
      return this.negative !== 0 ? -E | 0 : E;
    }, p.prototype.ucmp = function(S) {
      if (this.length > S.length)
        return 1;
      if (this.length < S.length)
        return -1;
      for (var E = 0, I = this.length - 1; I >= 0; I--) {
        var N = this.words[I] | 0, $ = S.words[I] | 0;
        if (N !== $) {
          N < $ ? E = -1 : N > $ && (E = 1);
          break;
        }
      }
      return E;
    }, p.prototype.gtn = function(S) {
      return this.cmpn(S) === 1;
    }, p.prototype.gt = function(S) {
      return this.cmp(S) === 1;
    }, p.prototype.gten = function(S) {
      return this.cmpn(S) >= 0;
    }, p.prototype.gte = function(S) {
      return this.cmp(S) >= 0;
    }, p.prototype.ltn = function(S) {
      return this.cmpn(S) === -1;
    }, p.prototype.lt = function(S) {
      return this.cmp(S) === -1;
    }, p.prototype.lten = function(S) {
      return this.cmpn(S) <= 0;
    }, p.prototype.lte = function(S) {
      return this.cmp(S) <= 0;
    }, p.prototype.eqn = function(S) {
      return this.cmpn(S) === 0;
    }, p.prototype.eq = function(S) {
      return this.cmp(S) === 0;
    }, p.red = function(S) {
      return new Z(S);
    }, p.prototype.toRed = function(S) {
      return l(!this.red, "Already a number in reduction context"), l(this.negative === 0, "red works only with positives"), S.convertTo(this)._forceRed(S);
    }, p.prototype.fromRed = function() {
      return l(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, p.prototype._forceRed = function(S) {
      return this.red = S, this;
    }, p.prototype.forceRed = function(S) {
      return l(!this.red, "Already a number in reduction context"), this._forceRed(S);
    }, p.prototype.redAdd = function(S) {
      return l(this.red, "redAdd works only with red numbers"), this.red.add(this, S);
    }, p.prototype.redIAdd = function(S) {
      return l(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, S);
    }, p.prototype.redSub = function(S) {
      return l(this.red, "redSub works only with red numbers"), this.red.sub(this, S);
    }, p.prototype.redISub = function(S) {
      return l(this.red, "redISub works only with red numbers"), this.red.isub(this, S);
    }, p.prototype.redShl = function(S) {
      return l(this.red, "redShl works only with red numbers"), this.red.shl(this, S);
    }, p.prototype.redMul = function(S) {
      return l(this.red, "redMul works only with red numbers"), this.red._verify2(this, S), this.red.mul(this, S);
    }, p.prototype.redIMul = function(S) {
      return l(this.red, "redMul works only with red numbers"), this.red._verify2(this, S), this.red.imul(this, S);
    }, p.prototype.redSqr = function() {
      return l(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, p.prototype.redISqr = function() {
      return l(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, p.prototype.redSqrt = function() {
      return l(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, p.prototype.redInvm = function() {
      return l(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, p.prototype.redNeg = function() {
      return l(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, p.prototype.redPow = function(S) {
      return l(this.red && !S.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, S);
    };
    var ge = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function be(P, S) {
      this.name = P, this.p = new p(S, 16), this.n = this.p.bitLength(), this.k = new p(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    be.prototype._tmp = function() {
      var S = new p(null);
      return S.words = new Array(Math.ceil(this.n / 13)), S;
    }, be.prototype.ireduce = function(S) {
      var E = S, I;
      do
        this.split(E, this.tmp), E = this.imulK(E), E = E.iadd(this.tmp), I = E.bitLength();
      while (I > this.n);
      var N = I < this.n ? -1 : E.ucmp(this.p);
      return N === 0 ? (E.words[0] = 0, E.length = 1) : N > 0 ? E.isub(this.p) : E.strip !== void 0 ? E.strip() : E._strip(), E;
    }, be.prototype.split = function(S, E) {
      S.iushrn(this.n, 0, E);
    }, be.prototype.imulK = function(S) {
      return S.imul(this.k);
    };
    function Ce() {
      be.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    v(Ce, be), Ce.prototype.split = function(S, E) {
      for (var I = 4194303, N = Math.min(S.length, 9), $ = 0; $ < N; $++)
        E.words[$] = S.words[$];
      if (E.length = N, S.length <= 9) {
        S.words[0] = 0, S.length = 1;
        return;
      }
      var U = S.words[9];
      for (E.words[E.length++] = U & I, $ = 10; $ < S.length; $++) {
        var H = S.words[$] | 0;
        S.words[$ - 10] = (H & I) << 4 | U >>> 22, U = H;
      }
      U >>>= 22, S.words[$ - 10] = U, U === 0 && S.length > 10 ? S.length -= 10 : S.length -= 9;
    }, Ce.prototype.imulK = function(S) {
      S.words[S.length] = 0, S.words[S.length + 1] = 0, S.length += 2;
      for (var E = 0, I = 0; I < S.length; I++) {
        var N = S.words[I] | 0;
        E += N * 977, S.words[I] = E & 67108863, E = N * 64 + (E / 67108864 | 0);
      }
      return S.words[S.length - 1] === 0 && (S.length--, S.words[S.length - 1] === 0 && S.length--), S;
    };
    function Me() {
      be.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    v(Me, be);
    function Be() {
      be.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    v(Be, be);
    function Ae() {
      be.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    v(Ae, be), Ae.prototype.imulK = function(S) {
      for (var E = 0, I = 0; I < S.length; I++) {
        var N = (S.words[I] | 0) * 19 + E, $ = N & 67108863;
        N >>>= 26, S.words[I] = $, E = N;
      }
      return E !== 0 && (S.words[S.length++] = E), S;
    }, p._prime = function(S) {
      if (ge[S])
        return ge[S];
      var E;
      if (S === "k256")
        E = new Ce();
      else if (S === "p224")
        E = new Me();
      else if (S === "p192")
        E = new Be();
      else if (S === "p25519")
        E = new Ae();
      else
        throw new Error("Unknown prime " + S);
      return ge[S] = E, E;
    };
    function Z(P) {
      if (typeof P == "string") {
        var S = p._prime(P);
        this.m = S.p, this.prime = S;
      } else
        l(P.gtn(1), "modulus must be greater than 1"), this.m = P, this.prime = null;
    }
    Z.prototype._verify1 = function(S) {
      l(S.negative === 0, "red works only with positives"), l(S.red, "red works only with red numbers");
    }, Z.prototype._verify2 = function(S, E) {
      l((S.negative | E.negative) === 0, "red works only with positives"), l(
        S.red && S.red === E.red,
        "red works only with red numbers"
      );
    }, Z.prototype.imod = function(S) {
      return this.prime ? this.prime.ireduce(S)._forceRed(this) : S.umod(this.m)._forceRed(this);
    }, Z.prototype.neg = function(S) {
      return S.isZero() ? S.clone() : this.m.sub(S)._forceRed(this);
    }, Z.prototype.add = function(S, E) {
      this._verify2(S, E);
      var I = S.add(E);
      return I.cmp(this.m) >= 0 && I.isub(this.m), I._forceRed(this);
    }, Z.prototype.iadd = function(S, E) {
      this._verify2(S, E);
      var I = S.iadd(E);
      return I.cmp(this.m) >= 0 && I.isub(this.m), I;
    }, Z.prototype.sub = function(S, E) {
      this._verify2(S, E);
      var I = S.sub(E);
      return I.cmpn(0) < 0 && I.iadd(this.m), I._forceRed(this);
    }, Z.prototype.isub = function(S, E) {
      this._verify2(S, E);
      var I = S.isub(E);
      return I.cmpn(0) < 0 && I.iadd(this.m), I;
    }, Z.prototype.shl = function(S, E) {
      return this._verify1(S), this.imod(S.ushln(E));
    }, Z.prototype.imul = function(S, E) {
      return this._verify2(S, E), this.imod(S.imul(E));
    }, Z.prototype.mul = function(S, E) {
      return this._verify2(S, E), this.imod(S.mul(E));
    }, Z.prototype.isqr = function(S) {
      return this.imul(S, S.clone());
    }, Z.prototype.sqr = function(S) {
      return this.mul(S, S);
    }, Z.prototype.sqrt = function(S) {
      if (S.isZero())
        return S.clone();
      var E = this.m.andln(3);
      if (l(E % 2 === 1), E === 3) {
        var I = this.m.add(new p(1)).iushrn(2);
        return this.pow(S, I);
      }
      for (var N = this.m.subn(1), $ = 0; !N.isZero() && N.andln(1) === 0; )
        $++, N.iushrn(1);
      l(!N.isZero());
      var U = new p(1).toRed(this), H = U.redNeg(), B = this.m.subn(1).iushrn(1), T = this.m.bitLength();
      for (T = new p(2 * T * T).toRed(this); this.pow(T, B).cmp(H) !== 0; )
        T.redIAdd(H);
      for (var D = this.pow(T, N), ee = this.pow(S, N.addn(1).iushrn(1)), pe = this.pow(S, N), Ie = $; pe.cmp(U) !== 0; ) {
        for (var Pe = pe, he = 0; Pe.cmp(U) !== 0; he++)
          Pe = Pe.redSqr();
        l(he < Ie);
        var ve = this.pow(D, new p(1).iushln(Ie - he - 1));
        ee = ee.redMul(ve), D = ve.redSqr(), pe = pe.redMul(D), Ie = he;
      }
      return ee;
    }, Z.prototype.invm = function(S) {
      var E = S._invmp(this.m);
      return E.negative !== 0 ? (E.negative = 0, this.imod(E).redNeg()) : this.imod(E);
    }, Z.prototype.pow = function(S, E) {
      if (E.isZero())
        return new p(1).toRed(this);
      if (E.cmpn(1) === 0)
        return S.clone();
      var I = 4, N = new Array(1 << I);
      N[0] = new p(1).toRed(this), N[1] = S;
      for (var $ = 2; $ < N.length; $++)
        N[$] = this.mul(N[$ - 1], S);
      var U = N[0], H = 0, B = 0, T = E.bitLength() % 26;
      for (T === 0 && (T = 26), $ = E.length - 1; $ >= 0; $--) {
        for (var D = E.words[$], ee = T - 1; ee >= 0; ee--) {
          var pe = D >> ee & 1;
          if (U !== N[0] && (U = this.sqr(U)), pe === 0 && H === 0) {
            B = 0;
            continue;
          }
          H <<= 1, H |= pe, B++, !(B !== I && ($ !== 0 || ee !== 0)) && (U = this.mul(U, N[H]), B = 0, H = 0);
        }
        T = 26;
      }
      return U;
    }, Z.prototype.convertTo = function(S) {
      var E = S.umod(this.m);
      return E === S ? E.clone() : E;
    }, Z.prototype.convertFrom = function(S) {
      var E = S.clone();
      return E.red = null, E;
    }, p.mont = function(S) {
      return new z(S);
    };
    function z(P) {
      Z.call(this, P), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new p(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    v(z, Z), z.prototype.convertTo = function(S) {
      return this.imod(S.ushln(this.shift));
    }, z.prototype.convertFrom = function(S) {
      var E = this.imod(S.mul(this.rinv));
      return E.red = null, E;
    }, z.prototype.imul = function(S, E) {
      if (S.isZero() || E.isZero())
        return S.words[0] = 0, S.length = 1, S;
      var I = S.imul(E), N = I.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), $ = I.isub(N).iushrn(this.shift), U = $;
      return $.cmp(this.m) >= 0 ? U = $.isub(this.m) : $.cmpn(0) < 0 && (U = $.iadd(this.m)), U._forceRed(this);
    }, z.prototype.mul = function(S, E) {
      if (S.isZero() || E.isZero())
        return new p(0)._forceRed(this);
      var I = S.mul(E), N = I.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), $ = I.isub(N).iushrn(this.shift), U = $;
      return $.cmp(this.m) >= 0 ? U = $.isub(this.m) : $.cmpn(0) < 0 && (U = $.iadd(this.m)), U._forceRed(this);
    }, z.prototype.invm = function(S) {
      var E = this.imod(S._invmp(this.m).mul(this.r2));
      return E._forceRed(this);
    };
  })(a, commonjsGlobal$1);
})(bn$6);
var bnExports$6 = bn$6.exports, bn$5 = { exports: {} };
bn$5.exports;
(function(a) {
  (function(u, c) {
    function l(P, S) {
      if (!P)
        throw new Error(S || "Assertion failed");
    }
    function v(P, S) {
      P.super_ = S;
      var E = function() {
      };
      E.prototype = S.prototype, P.prototype = new E(), P.prototype.constructor = P;
    }
    function p(P, S, E) {
      if (p.isBN(P))
        return P;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, P !== null && ((S === "le" || S === "be") && (E = S, S = 10), this._init(P || 0, S || 10, E || "be"));
    }
    typeof u == "object" ? u.exports = p : c.BN = p, p.BN = p, p.wordSize = 26;
    var _;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? _ = window.Buffer : _ = require$$0$2.Buffer;
    } catch {
    }
    p.isBN = function(S) {
      return S instanceof p ? !0 : S !== null && typeof S == "object" && S.constructor.wordSize === p.wordSize && Array.isArray(S.words);
    }, p.max = function(S, E) {
      return S.cmp(E) > 0 ? S : E;
    }, p.min = function(S, E) {
      return S.cmp(E) < 0 ? S : E;
    }, p.prototype._init = function(S, E, I) {
      if (typeof S == "number")
        return this._initNumber(S, E, I);
      if (typeof S == "object")
        return this._initArray(S, E, I);
      E === "hex" && (E = 16), l(E === (E | 0) && E >= 2 && E <= 36), S = S.toString().replace(/\s+/g, "");
      var N = 0;
      S[0] === "-" && (N++, this.negative = 1), N < S.length && (E === 16 ? this._parseHex(S, N, I) : (this._parseBase(S, E, N), I === "le" && this._initArray(this.toArray(), E, I)));
    }, p.prototype._initNumber = function(S, E, I) {
      S < 0 && (this.negative = 1, S = -S), S < 67108864 ? (this.words = [S & 67108863], this.length = 1) : S < 4503599627370496 ? (this.words = [
        S & 67108863,
        S / 67108864 & 67108863
      ], this.length = 2) : (l(S < 9007199254740992), this.words = [
        S & 67108863,
        S / 67108864 & 67108863,
        1
      ], this.length = 3), I === "le" && this._initArray(this.toArray(), E, I);
    }, p.prototype._initArray = function(S, E, I) {
      if (l(typeof S.length == "number"), S.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(S.length / 3), this.words = new Array(this.length);
      for (var N = 0; N < this.length; N++)
        this.words[N] = 0;
      var $, U, H = 0;
      if (I === "be")
        for (N = S.length - 1, $ = 0; N >= 0; N -= 3)
          U = S[N] | S[N - 1] << 8 | S[N - 2] << 16, this.words[$] |= U << H & 67108863, this.words[$ + 1] = U >>> 26 - H & 67108863, H += 24, H >= 26 && (H -= 26, $++);
      else if (I === "le")
        for (N = 0, $ = 0; N < S.length; N += 3)
          U = S[N] | S[N + 1] << 8 | S[N + 2] << 16, this.words[$] |= U << H & 67108863, this.words[$ + 1] = U >>> 26 - H & 67108863, H += 24, H >= 26 && (H -= 26, $++);
      return this.strip();
    };
    function k(P, S) {
      var E = P.charCodeAt(S);
      return E >= 65 && E <= 70 ? E - 55 : E >= 97 && E <= 102 ? E - 87 : E - 48 & 15;
    }
    function M(P, S, E) {
      var I = k(P, E);
      return E - 1 >= S && (I |= k(P, E - 1) << 4), I;
    }
    p.prototype._parseHex = function(S, E, I) {
      this.length = Math.ceil((S.length - E) / 6), this.words = new Array(this.length);
      for (var N = 0; N < this.length; N++)
        this.words[N] = 0;
      var $ = 0, U = 0, H;
      if (I === "be")
        for (N = S.length - 1; N >= E; N -= 2)
          H = M(S, E, N) << $, this.words[U] |= H & 67108863, $ >= 18 ? ($ -= 18, U += 1, this.words[U] |= H >>> 26) : $ += 8;
      else {
        var B = S.length - E;
        for (N = B % 2 === 0 ? E + 1 : E; N < S.length; N += 2)
          H = M(S, E, N) << $, this.words[U] |= H & 67108863, $ >= 18 ? ($ -= 18, U += 1, this.words[U] |= H >>> 26) : $ += 8;
      }
      this.strip();
    };
    function L(P, S, E, I) {
      for (var N = 0, $ = Math.min(P.length, E), U = S; U < $; U++) {
        var H = P.charCodeAt(U) - 48;
        N *= I, H >= 49 ? N += H - 49 + 10 : H >= 17 ? N += H - 17 + 10 : N += H;
      }
      return N;
    }
    p.prototype._parseBase = function(S, E, I) {
      this.words = [0], this.length = 1;
      for (var N = 0, $ = 1; $ <= 67108863; $ *= E)
        N++;
      N--, $ = $ / E | 0;
      for (var U = S.length - I, H = U % N, B = Math.min(U, U - H) + I, T = 0, D = I; D < B; D += N)
        T = L(S, D, D + N, E), this.imuln($), this.words[0] + T < 67108864 ? this.words[0] += T : this._iaddn(T);
      if (H !== 0) {
        var ee = 1;
        for (T = L(S, D, S.length, E), D = 0; D < H; D++)
          ee *= E;
        this.imuln(ee), this.words[0] + T < 67108864 ? this.words[0] += T : this._iaddn(T);
      }
      this.strip();
    }, p.prototype.copy = function(S) {
      S.words = new Array(this.length);
      for (var E = 0; E < this.length; E++)
        S.words[E] = this.words[E];
      S.length = this.length, S.negative = this.negative, S.red = this.red;
    }, p.prototype.clone = function() {
      var S = new p(null);
      return this.copy(S), S;
    }, p.prototype._expand = function(S) {
      for (; this.length < S; )
        this.words[this.length++] = 0;
      return this;
    }, p.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, p.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, p.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var F = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], V = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], X = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    p.prototype.toString = function(S, E) {
      S = S || 10, E = E | 0 || 1;
      var I;
      if (S === 16 || S === "hex") {
        I = "";
        for (var N = 0, $ = 0, U = 0; U < this.length; U++) {
          var H = this.words[U], B = ((H << N | $) & 16777215).toString(16);
          $ = H >>> 24 - N & 16777215, $ !== 0 || U !== this.length - 1 ? I = F[6 - B.length] + B + I : I = B + I, N += 2, N >= 26 && (N -= 26, U--);
        }
        for ($ !== 0 && (I = $.toString(16) + I); I.length % E !== 0; )
          I = "0" + I;
        return this.negative !== 0 && (I = "-" + I), I;
      }
      if (S === (S | 0) && S >= 2 && S <= 36) {
        var T = V[S], D = X[S];
        I = "";
        var ee = this.clone();
        for (ee.negative = 0; !ee.isZero(); ) {
          var pe = ee.modn(D).toString(S);
          ee = ee.idivn(D), ee.isZero() ? I = pe + I : I = F[T - pe.length] + pe + I;
        }
        for (this.isZero() && (I = "0" + I); I.length % E !== 0; )
          I = "0" + I;
        return this.negative !== 0 && (I = "-" + I), I;
      }
      l(!1, "Base should be between 2 and 36");
    }, p.prototype.toNumber = function() {
      var S = this.words[0];
      return this.length === 2 ? S += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? S += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && l(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -S : S;
    }, p.prototype.toJSON = function() {
      return this.toString(16);
    }, p.prototype.toBuffer = function(S, E) {
      return l(typeof _ < "u"), this.toArrayLike(_, S, E);
    }, p.prototype.toArray = function(S, E) {
      return this.toArrayLike(Array, S, E);
    }, p.prototype.toArrayLike = function(S, E, I) {
      var N = this.byteLength(), $ = I || Math.max(1, N);
      l(N <= $, "byte array longer than desired length"), l($ > 0, "Requested array length <= 0"), this.strip();
      var U = E === "le", H = new S($), B, T, D = this.clone();
      if (U) {
        for (T = 0; !D.isZero(); T++)
          B = D.andln(255), D.iushrn(8), H[T] = B;
        for (; T < $; T++)
          H[T] = 0;
      } else {
        for (T = 0; T < $ - N; T++)
          H[T] = 0;
        for (T = 0; !D.isZero(); T++)
          B = D.andln(255), D.iushrn(8), H[$ - T - 1] = B;
      }
      return H;
    }, Math.clz32 ? p.prototype._countBits = function(S) {
      return 32 - Math.clz32(S);
    } : p.prototype._countBits = function(S) {
      var E = S, I = 0;
      return E >= 4096 && (I += 13, E >>>= 13), E >= 64 && (I += 7, E >>>= 7), E >= 8 && (I += 4, E >>>= 4), E >= 2 && (I += 2, E >>>= 2), I + E;
    }, p.prototype._zeroBits = function(S) {
      if (S === 0)
        return 26;
      var E = S, I = 0;
      return E & 8191 || (I += 13, E >>>= 13), E & 127 || (I += 7, E >>>= 7), E & 15 || (I += 4, E >>>= 4), E & 3 || (I += 2, E >>>= 2), E & 1 || I++, I;
    }, p.prototype.bitLength = function() {
      var S = this.words[this.length - 1], E = this._countBits(S);
      return (this.length - 1) * 26 + E;
    };
    function oe(P) {
      for (var S = new Array(P.bitLength()), E = 0; E < S.length; E++) {
        var I = E / 26 | 0, N = E % 26;
        S[E] = (P.words[I] & 1 << N) >>> N;
      }
      return S;
    }
    p.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var S = 0, E = 0; E < this.length; E++) {
        var I = this._zeroBits(this.words[E]);
        if (S += I, I !== 26)
          break;
      }
      return S;
    }, p.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, p.prototype.toTwos = function(S) {
      return this.negative !== 0 ? this.abs().inotn(S).iaddn(1) : this.clone();
    }, p.prototype.fromTwos = function(S) {
      return this.testn(S - 1) ? this.notn(S).iaddn(1).ineg() : this.clone();
    }, p.prototype.isNeg = function() {
      return this.negative !== 0;
    }, p.prototype.neg = function() {
      return this.clone().ineg();
    }, p.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, p.prototype.iuor = function(S) {
      for (; this.length < S.length; )
        this.words[this.length++] = 0;
      for (var E = 0; E < S.length; E++)
        this.words[E] = this.words[E] | S.words[E];
      return this.strip();
    }, p.prototype.ior = function(S) {
      return l((this.negative | S.negative) === 0), this.iuor(S);
    }, p.prototype.or = function(S) {
      return this.length > S.length ? this.clone().ior(S) : S.clone().ior(this);
    }, p.prototype.uor = function(S) {
      return this.length > S.length ? this.clone().iuor(S) : S.clone().iuor(this);
    }, p.prototype.iuand = function(S) {
      var E;
      this.length > S.length ? E = S : E = this;
      for (var I = 0; I < E.length; I++)
        this.words[I] = this.words[I] & S.words[I];
      return this.length = E.length, this.strip();
    }, p.prototype.iand = function(S) {
      return l((this.negative | S.negative) === 0), this.iuand(S);
    }, p.prototype.and = function(S) {
      return this.length > S.length ? this.clone().iand(S) : S.clone().iand(this);
    }, p.prototype.uand = function(S) {
      return this.length > S.length ? this.clone().iuand(S) : S.clone().iuand(this);
    }, p.prototype.iuxor = function(S) {
      var E, I;
      this.length > S.length ? (E = this, I = S) : (E = S, I = this);
      for (var N = 0; N < I.length; N++)
        this.words[N] = E.words[N] ^ I.words[N];
      if (this !== E)
        for (; N < E.length; N++)
          this.words[N] = E.words[N];
      return this.length = E.length, this.strip();
    }, p.prototype.ixor = function(S) {
      return l((this.negative | S.negative) === 0), this.iuxor(S);
    }, p.prototype.xor = function(S) {
      return this.length > S.length ? this.clone().ixor(S) : S.clone().ixor(this);
    }, p.prototype.uxor = function(S) {
      return this.length > S.length ? this.clone().iuxor(S) : S.clone().iuxor(this);
    }, p.prototype.inotn = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = Math.ceil(S / 26) | 0, I = S % 26;
      this._expand(E), I > 0 && E--;
      for (var N = 0; N < E; N++)
        this.words[N] = ~this.words[N] & 67108863;
      return I > 0 && (this.words[N] = ~this.words[N] & 67108863 >> 26 - I), this.strip();
    }, p.prototype.notn = function(S) {
      return this.clone().inotn(S);
    }, p.prototype.setn = function(S, E) {
      l(typeof S == "number" && S >= 0);
      var I = S / 26 | 0, N = S % 26;
      return this._expand(I + 1), E ? this.words[I] = this.words[I] | 1 << N : this.words[I] = this.words[I] & ~(1 << N), this.strip();
    }, p.prototype.iadd = function(S) {
      var E;
      if (this.negative !== 0 && S.negative === 0)
        return this.negative = 0, E = this.isub(S), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && S.negative !== 0)
        return S.negative = 0, E = this.isub(S), S.negative = 1, E._normSign();
      var I, N;
      this.length > S.length ? (I = this, N = S) : (I = S, N = this);
      for (var $ = 0, U = 0; U < N.length; U++)
        E = (I.words[U] | 0) + (N.words[U] | 0) + $, this.words[U] = E & 67108863, $ = E >>> 26;
      for (; $ !== 0 && U < I.length; U++)
        E = (I.words[U] | 0) + $, this.words[U] = E & 67108863, $ = E >>> 26;
      if (this.length = I.length, $ !== 0)
        this.words[this.length] = $, this.length++;
      else if (I !== this)
        for (; U < I.length; U++)
          this.words[U] = I.words[U];
      return this;
    }, p.prototype.add = function(S) {
      var E;
      return S.negative !== 0 && this.negative === 0 ? (S.negative = 0, E = this.sub(S), S.negative ^= 1, E) : S.negative === 0 && this.negative !== 0 ? (this.negative = 0, E = S.sub(this), this.negative = 1, E) : this.length > S.length ? this.clone().iadd(S) : S.clone().iadd(this);
    }, p.prototype.isub = function(S) {
      if (S.negative !== 0) {
        S.negative = 0;
        var E = this.iadd(S);
        return S.negative = 1, E._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(S), this.negative = 1, this._normSign();
      var I = this.cmp(S);
      if (I === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var N, $;
      I > 0 ? (N = this, $ = S) : (N = S, $ = this);
      for (var U = 0, H = 0; H < $.length; H++)
        E = (N.words[H] | 0) - ($.words[H] | 0) + U, U = E >> 26, this.words[H] = E & 67108863;
      for (; U !== 0 && H < N.length; H++)
        E = (N.words[H] | 0) + U, U = E >> 26, this.words[H] = E & 67108863;
      if (U === 0 && H < N.length && N !== this)
        for (; H < N.length; H++)
          this.words[H] = N.words[H];
      return this.length = Math.max(this.length, H), N !== this && (this.negative = 1), this.strip();
    }, p.prototype.sub = function(S) {
      return this.clone().isub(S);
    };
    function Y(P, S, E) {
      E.negative = S.negative ^ P.negative;
      var I = P.length + S.length | 0;
      E.length = I, I = I - 1 | 0;
      var N = P.words[0] | 0, $ = S.words[0] | 0, U = N * $, H = U & 67108863, B = U / 67108864 | 0;
      E.words[0] = H;
      for (var T = 1; T < I; T++) {
        for (var D = B >>> 26, ee = B & 67108863, pe = Math.min(T, S.length - 1), Ie = Math.max(0, T - P.length + 1); Ie <= pe; Ie++) {
          var Pe = T - Ie | 0;
          N = P.words[Pe] | 0, $ = S.words[Ie] | 0, U = N * $ + ee, D += U / 67108864 | 0, ee = U & 67108863;
        }
        E.words[T] = ee | 0, B = D | 0;
      }
      return B !== 0 ? E.words[T] = B | 0 : E.length--, E.strip();
    }
    var ae = function(S, E, I) {
      var N = S.words, $ = E.words, U = I.words, H = 0, B, T, D, ee = N[0] | 0, pe = ee & 8191, Ie = ee >>> 13, Pe = N[1] | 0, he = Pe & 8191, ve = Pe >>> 13, Q = N[2] | 0, le = Q & 8191, _e = Q >>> 13, re = N[3] | 0, O = re & 8191, j = re >>> 13, ce = N[4] | 0, De = ce & 8191, Ne = ce >>> 13, Fe = N[5] | 0, Ze = Fe & 8191, qe = Fe >>> 13, gt = N[6] | 0, Xe = gt & 8191, Ge = gt >>> 13, J = N[7] | 0, ye = J & 8191, we = J >>> 13, We = N[8] | 0, Re = We & 8191, q = We >>> 13, ke = N[9] | 0, de = ke & 8191, ue = ke >>> 13, me = $[0] | 0, Oe = me & 8191, Ue = me >>> 13, ze = $[1] | 0, Ve = ze & 8191, Qe = ze >>> 13, Ke = $[2] | 0, x = Ke & 8191, se = Ke >>> 13, Ee = $[3] | 0, xe = Ee & 8191, $e = Ee >>> 13, Ye = $[4] | 0, et = Ye & 8191, dt = Ye >>> 13, St = $[5] | 0, tt = St & 8191, at = St >>> 13, wt = $[6] | 0, rt = wt & 8191, ut = wt >>> 13, kt = $[7] | 0, nt = kt & 8191, it = kt >>> 13, bt = $[8] | 0, ot = bt & 8191, ct = bt >>> 13, Ot = $[9] | 0, st = Ot & 8191, lt = Ot >>> 13;
      I.negative = S.negative ^ E.negative, I.length = 19, B = Math.imul(pe, Oe), T = Math.imul(pe, Ue), T = T + Math.imul(Ie, Oe) | 0, D = Math.imul(Ie, Ue);
      var Rt = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (Rt >>> 26) | 0, Rt &= 67108863, B = Math.imul(he, Oe), T = Math.imul(he, Ue), T = T + Math.imul(ve, Oe) | 0, D = Math.imul(ve, Ue), B = B + Math.imul(pe, Ve) | 0, T = T + Math.imul(pe, Qe) | 0, T = T + Math.imul(Ie, Ve) | 0, D = D + Math.imul(Ie, Qe) | 0;
      var Ct = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (Ct >>> 26) | 0, Ct &= 67108863, B = Math.imul(le, Oe), T = Math.imul(le, Ue), T = T + Math.imul(_e, Oe) | 0, D = Math.imul(_e, Ue), B = B + Math.imul(he, Ve) | 0, T = T + Math.imul(he, Qe) | 0, T = T + Math.imul(ve, Ve) | 0, D = D + Math.imul(ve, Qe) | 0, B = B + Math.imul(pe, x) | 0, T = T + Math.imul(pe, se) | 0, T = T + Math.imul(Ie, x) | 0, D = D + Math.imul(Ie, se) | 0;
      var Je = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, B = Math.imul(O, Oe), T = Math.imul(O, Ue), T = T + Math.imul(j, Oe) | 0, D = Math.imul(j, Ue), B = B + Math.imul(le, Ve) | 0, T = T + Math.imul(le, Qe) | 0, T = T + Math.imul(_e, Ve) | 0, D = D + Math.imul(_e, Qe) | 0, B = B + Math.imul(he, x) | 0, T = T + Math.imul(he, se) | 0, T = T + Math.imul(ve, x) | 0, D = D + Math.imul(ve, se) | 0, B = B + Math.imul(pe, xe) | 0, T = T + Math.imul(pe, $e) | 0, T = T + Math.imul(Ie, xe) | 0, D = D + Math.imul(Ie, $e) | 0;
      var He = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, B = Math.imul(De, Oe), T = Math.imul(De, Ue), T = T + Math.imul(Ne, Oe) | 0, D = Math.imul(Ne, Ue), B = B + Math.imul(O, Ve) | 0, T = T + Math.imul(O, Qe) | 0, T = T + Math.imul(j, Ve) | 0, D = D + Math.imul(j, Qe) | 0, B = B + Math.imul(le, x) | 0, T = T + Math.imul(le, se) | 0, T = T + Math.imul(_e, x) | 0, D = D + Math.imul(_e, se) | 0, B = B + Math.imul(he, xe) | 0, T = T + Math.imul(he, $e) | 0, T = T + Math.imul(ve, xe) | 0, D = D + Math.imul(ve, $e) | 0, B = B + Math.imul(pe, et) | 0, T = T + Math.imul(pe, dt) | 0, T = T + Math.imul(Ie, et) | 0, D = D + Math.imul(Ie, dt) | 0;
      var je = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, B = Math.imul(Ze, Oe), T = Math.imul(Ze, Ue), T = T + Math.imul(qe, Oe) | 0, D = Math.imul(qe, Ue), B = B + Math.imul(De, Ve) | 0, T = T + Math.imul(De, Qe) | 0, T = T + Math.imul(Ne, Ve) | 0, D = D + Math.imul(Ne, Qe) | 0, B = B + Math.imul(O, x) | 0, T = T + Math.imul(O, se) | 0, T = T + Math.imul(j, x) | 0, D = D + Math.imul(j, se) | 0, B = B + Math.imul(le, xe) | 0, T = T + Math.imul(le, $e) | 0, T = T + Math.imul(_e, xe) | 0, D = D + Math.imul(_e, $e) | 0, B = B + Math.imul(he, et) | 0, T = T + Math.imul(he, dt) | 0, T = T + Math.imul(ve, et) | 0, D = D + Math.imul(ve, dt) | 0, B = B + Math.imul(pe, tt) | 0, T = T + Math.imul(pe, at) | 0, T = T + Math.imul(Ie, tt) | 0, D = D + Math.imul(Ie, at) | 0;
      var pt = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (pt >>> 26) | 0, pt &= 67108863, B = Math.imul(Xe, Oe), T = Math.imul(Xe, Ue), T = T + Math.imul(Ge, Oe) | 0, D = Math.imul(Ge, Ue), B = B + Math.imul(Ze, Ve) | 0, T = T + Math.imul(Ze, Qe) | 0, T = T + Math.imul(qe, Ve) | 0, D = D + Math.imul(qe, Qe) | 0, B = B + Math.imul(De, x) | 0, T = T + Math.imul(De, se) | 0, T = T + Math.imul(Ne, x) | 0, D = D + Math.imul(Ne, se) | 0, B = B + Math.imul(O, xe) | 0, T = T + Math.imul(O, $e) | 0, T = T + Math.imul(j, xe) | 0, D = D + Math.imul(j, $e) | 0, B = B + Math.imul(le, et) | 0, T = T + Math.imul(le, dt) | 0, T = T + Math.imul(_e, et) | 0, D = D + Math.imul(_e, dt) | 0, B = B + Math.imul(he, tt) | 0, T = T + Math.imul(he, at) | 0, T = T + Math.imul(ve, tt) | 0, D = D + Math.imul(ve, at) | 0, B = B + Math.imul(pe, rt) | 0, T = T + Math.imul(pe, ut) | 0, T = T + Math.imul(Ie, rt) | 0, D = D + Math.imul(Ie, ut) | 0;
      var mt = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (mt >>> 26) | 0, mt &= 67108863, B = Math.imul(ye, Oe), T = Math.imul(ye, Ue), T = T + Math.imul(we, Oe) | 0, D = Math.imul(we, Ue), B = B + Math.imul(Xe, Ve) | 0, T = T + Math.imul(Xe, Qe) | 0, T = T + Math.imul(Ge, Ve) | 0, D = D + Math.imul(Ge, Qe) | 0, B = B + Math.imul(Ze, x) | 0, T = T + Math.imul(Ze, se) | 0, T = T + Math.imul(qe, x) | 0, D = D + Math.imul(qe, se) | 0, B = B + Math.imul(De, xe) | 0, T = T + Math.imul(De, $e) | 0, T = T + Math.imul(Ne, xe) | 0, D = D + Math.imul(Ne, $e) | 0, B = B + Math.imul(O, et) | 0, T = T + Math.imul(O, dt) | 0, T = T + Math.imul(j, et) | 0, D = D + Math.imul(j, dt) | 0, B = B + Math.imul(le, tt) | 0, T = T + Math.imul(le, at) | 0, T = T + Math.imul(_e, tt) | 0, D = D + Math.imul(_e, at) | 0, B = B + Math.imul(he, rt) | 0, T = T + Math.imul(he, ut) | 0, T = T + Math.imul(ve, rt) | 0, D = D + Math.imul(ve, ut) | 0, B = B + Math.imul(pe, nt) | 0, T = T + Math.imul(pe, it) | 0, T = T + Math.imul(Ie, nt) | 0, D = D + Math.imul(Ie, it) | 0;
      var yt = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (yt >>> 26) | 0, yt &= 67108863, B = Math.imul(Re, Oe), T = Math.imul(Re, Ue), T = T + Math.imul(q, Oe) | 0, D = Math.imul(q, Ue), B = B + Math.imul(ye, Ve) | 0, T = T + Math.imul(ye, Qe) | 0, T = T + Math.imul(we, Ve) | 0, D = D + Math.imul(we, Qe) | 0, B = B + Math.imul(Xe, x) | 0, T = T + Math.imul(Xe, se) | 0, T = T + Math.imul(Ge, x) | 0, D = D + Math.imul(Ge, se) | 0, B = B + Math.imul(Ze, xe) | 0, T = T + Math.imul(Ze, $e) | 0, T = T + Math.imul(qe, xe) | 0, D = D + Math.imul(qe, $e) | 0, B = B + Math.imul(De, et) | 0, T = T + Math.imul(De, dt) | 0, T = T + Math.imul(Ne, et) | 0, D = D + Math.imul(Ne, dt) | 0, B = B + Math.imul(O, tt) | 0, T = T + Math.imul(O, at) | 0, T = T + Math.imul(j, tt) | 0, D = D + Math.imul(j, at) | 0, B = B + Math.imul(le, rt) | 0, T = T + Math.imul(le, ut) | 0, T = T + Math.imul(_e, rt) | 0, D = D + Math.imul(_e, ut) | 0, B = B + Math.imul(he, nt) | 0, T = T + Math.imul(he, it) | 0, T = T + Math.imul(ve, nt) | 0, D = D + Math.imul(ve, it) | 0, B = B + Math.imul(pe, ot) | 0, T = T + Math.imul(pe, ct) | 0, T = T + Math.imul(Ie, ot) | 0, D = D + Math.imul(Ie, ct) | 0;
      var ht = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (ht >>> 26) | 0, ht &= 67108863, B = Math.imul(de, Oe), T = Math.imul(de, Ue), T = T + Math.imul(ue, Oe) | 0, D = Math.imul(ue, Ue), B = B + Math.imul(Re, Ve) | 0, T = T + Math.imul(Re, Qe) | 0, T = T + Math.imul(q, Ve) | 0, D = D + Math.imul(q, Qe) | 0, B = B + Math.imul(ye, x) | 0, T = T + Math.imul(ye, se) | 0, T = T + Math.imul(we, x) | 0, D = D + Math.imul(we, se) | 0, B = B + Math.imul(Xe, xe) | 0, T = T + Math.imul(Xe, $e) | 0, T = T + Math.imul(Ge, xe) | 0, D = D + Math.imul(Ge, $e) | 0, B = B + Math.imul(Ze, et) | 0, T = T + Math.imul(Ze, dt) | 0, T = T + Math.imul(qe, et) | 0, D = D + Math.imul(qe, dt) | 0, B = B + Math.imul(De, tt) | 0, T = T + Math.imul(De, at) | 0, T = T + Math.imul(Ne, tt) | 0, D = D + Math.imul(Ne, at) | 0, B = B + Math.imul(O, rt) | 0, T = T + Math.imul(O, ut) | 0, T = T + Math.imul(j, rt) | 0, D = D + Math.imul(j, ut) | 0, B = B + Math.imul(le, nt) | 0, T = T + Math.imul(le, it) | 0, T = T + Math.imul(_e, nt) | 0, D = D + Math.imul(_e, it) | 0, B = B + Math.imul(he, ot) | 0, T = T + Math.imul(he, ct) | 0, T = T + Math.imul(ve, ot) | 0, D = D + Math.imul(ve, ct) | 0, B = B + Math.imul(pe, st) | 0, T = T + Math.imul(pe, lt) | 0, T = T + Math.imul(Ie, st) | 0, D = D + Math.imul(Ie, lt) | 0;
      var _t = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (_t >>> 26) | 0, _t &= 67108863, B = Math.imul(de, Ve), T = Math.imul(de, Qe), T = T + Math.imul(ue, Ve) | 0, D = Math.imul(ue, Qe), B = B + Math.imul(Re, x) | 0, T = T + Math.imul(Re, se) | 0, T = T + Math.imul(q, x) | 0, D = D + Math.imul(q, se) | 0, B = B + Math.imul(ye, xe) | 0, T = T + Math.imul(ye, $e) | 0, T = T + Math.imul(we, xe) | 0, D = D + Math.imul(we, $e) | 0, B = B + Math.imul(Xe, et) | 0, T = T + Math.imul(Xe, dt) | 0, T = T + Math.imul(Ge, et) | 0, D = D + Math.imul(Ge, dt) | 0, B = B + Math.imul(Ze, tt) | 0, T = T + Math.imul(Ze, at) | 0, T = T + Math.imul(qe, tt) | 0, D = D + Math.imul(qe, at) | 0, B = B + Math.imul(De, rt) | 0, T = T + Math.imul(De, ut) | 0, T = T + Math.imul(Ne, rt) | 0, D = D + Math.imul(Ne, ut) | 0, B = B + Math.imul(O, nt) | 0, T = T + Math.imul(O, it) | 0, T = T + Math.imul(j, nt) | 0, D = D + Math.imul(j, it) | 0, B = B + Math.imul(le, ot) | 0, T = T + Math.imul(le, ct) | 0, T = T + Math.imul(_e, ot) | 0, D = D + Math.imul(_e, ct) | 0, B = B + Math.imul(he, st) | 0, T = T + Math.imul(he, lt) | 0, T = T + Math.imul(ve, st) | 0, D = D + Math.imul(ve, lt) | 0;
      var Et = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, B = Math.imul(de, x), T = Math.imul(de, se), T = T + Math.imul(ue, x) | 0, D = Math.imul(ue, se), B = B + Math.imul(Re, xe) | 0, T = T + Math.imul(Re, $e) | 0, T = T + Math.imul(q, xe) | 0, D = D + Math.imul(q, $e) | 0, B = B + Math.imul(ye, et) | 0, T = T + Math.imul(ye, dt) | 0, T = T + Math.imul(we, et) | 0, D = D + Math.imul(we, dt) | 0, B = B + Math.imul(Xe, tt) | 0, T = T + Math.imul(Xe, at) | 0, T = T + Math.imul(Ge, tt) | 0, D = D + Math.imul(Ge, at) | 0, B = B + Math.imul(Ze, rt) | 0, T = T + Math.imul(Ze, ut) | 0, T = T + Math.imul(qe, rt) | 0, D = D + Math.imul(qe, ut) | 0, B = B + Math.imul(De, nt) | 0, T = T + Math.imul(De, it) | 0, T = T + Math.imul(Ne, nt) | 0, D = D + Math.imul(Ne, it) | 0, B = B + Math.imul(O, ot) | 0, T = T + Math.imul(O, ct) | 0, T = T + Math.imul(j, ot) | 0, D = D + Math.imul(j, ct) | 0, B = B + Math.imul(le, st) | 0, T = T + Math.imul(le, lt) | 0, T = T + Math.imul(_e, st) | 0, D = D + Math.imul(_e, lt) | 0;
      var Nt = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, B = Math.imul(de, xe), T = Math.imul(de, $e), T = T + Math.imul(ue, xe) | 0, D = Math.imul(ue, $e), B = B + Math.imul(Re, et) | 0, T = T + Math.imul(Re, dt) | 0, T = T + Math.imul(q, et) | 0, D = D + Math.imul(q, dt) | 0, B = B + Math.imul(ye, tt) | 0, T = T + Math.imul(ye, at) | 0, T = T + Math.imul(we, tt) | 0, D = D + Math.imul(we, at) | 0, B = B + Math.imul(Xe, rt) | 0, T = T + Math.imul(Xe, ut) | 0, T = T + Math.imul(Ge, rt) | 0, D = D + Math.imul(Ge, ut) | 0, B = B + Math.imul(Ze, nt) | 0, T = T + Math.imul(Ze, it) | 0, T = T + Math.imul(qe, nt) | 0, D = D + Math.imul(qe, it) | 0, B = B + Math.imul(De, ot) | 0, T = T + Math.imul(De, ct) | 0, T = T + Math.imul(Ne, ot) | 0, D = D + Math.imul(Ne, ct) | 0, B = B + Math.imul(O, st) | 0, T = T + Math.imul(O, lt) | 0, T = T + Math.imul(j, st) | 0, D = D + Math.imul(j, lt) | 0;
      var Dt = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (Dt >>> 26) | 0, Dt &= 67108863, B = Math.imul(de, et), T = Math.imul(de, dt), T = T + Math.imul(ue, et) | 0, D = Math.imul(ue, dt), B = B + Math.imul(Re, tt) | 0, T = T + Math.imul(Re, at) | 0, T = T + Math.imul(q, tt) | 0, D = D + Math.imul(q, at) | 0, B = B + Math.imul(ye, rt) | 0, T = T + Math.imul(ye, ut) | 0, T = T + Math.imul(we, rt) | 0, D = D + Math.imul(we, ut) | 0, B = B + Math.imul(Xe, nt) | 0, T = T + Math.imul(Xe, it) | 0, T = T + Math.imul(Ge, nt) | 0, D = D + Math.imul(Ge, it) | 0, B = B + Math.imul(Ze, ot) | 0, T = T + Math.imul(Ze, ct) | 0, T = T + Math.imul(qe, ot) | 0, D = D + Math.imul(qe, ct) | 0, B = B + Math.imul(De, st) | 0, T = T + Math.imul(De, lt) | 0, T = T + Math.imul(Ne, st) | 0, D = D + Math.imul(Ne, lt) | 0;
      var $t = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + ($t >>> 26) | 0, $t &= 67108863, B = Math.imul(de, tt), T = Math.imul(de, at), T = T + Math.imul(ue, tt) | 0, D = Math.imul(ue, at), B = B + Math.imul(Re, rt) | 0, T = T + Math.imul(Re, ut) | 0, T = T + Math.imul(q, rt) | 0, D = D + Math.imul(q, ut) | 0, B = B + Math.imul(ye, nt) | 0, T = T + Math.imul(ye, it) | 0, T = T + Math.imul(we, nt) | 0, D = D + Math.imul(we, it) | 0, B = B + Math.imul(Xe, ot) | 0, T = T + Math.imul(Xe, ct) | 0, T = T + Math.imul(Ge, ot) | 0, D = D + Math.imul(Ge, ct) | 0, B = B + Math.imul(Ze, st) | 0, T = T + Math.imul(Ze, lt) | 0, T = T + Math.imul(qe, st) | 0, D = D + Math.imul(qe, lt) | 0;
      var At = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, B = Math.imul(de, rt), T = Math.imul(de, ut), T = T + Math.imul(ue, rt) | 0, D = Math.imul(ue, ut), B = B + Math.imul(Re, nt) | 0, T = T + Math.imul(Re, it) | 0, T = T + Math.imul(q, nt) | 0, D = D + Math.imul(q, it) | 0, B = B + Math.imul(ye, ot) | 0, T = T + Math.imul(ye, ct) | 0, T = T + Math.imul(we, ot) | 0, D = D + Math.imul(we, ct) | 0, B = B + Math.imul(Xe, st) | 0, T = T + Math.imul(Xe, lt) | 0, T = T + Math.imul(Ge, st) | 0, D = D + Math.imul(Ge, lt) | 0;
      var Lt = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (Lt >>> 26) | 0, Lt &= 67108863, B = Math.imul(de, nt), T = Math.imul(de, it), T = T + Math.imul(ue, nt) | 0, D = Math.imul(ue, it), B = B + Math.imul(Re, ot) | 0, T = T + Math.imul(Re, ct) | 0, T = T + Math.imul(q, ot) | 0, D = D + Math.imul(q, ct) | 0, B = B + Math.imul(ye, st) | 0, T = T + Math.imul(ye, lt) | 0, T = T + Math.imul(we, st) | 0, D = D + Math.imul(we, lt) | 0;
      var Bt = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, B = Math.imul(de, ot), T = Math.imul(de, ct), T = T + Math.imul(ue, ot) | 0, D = Math.imul(ue, ct), B = B + Math.imul(Re, st) | 0, T = T + Math.imul(Re, lt) | 0, T = T + Math.imul(q, st) | 0, D = D + Math.imul(q, lt) | 0;
      var Ut = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (Ut >>> 26) | 0, Ut &= 67108863, B = Math.imul(de, st), T = Math.imul(de, lt), T = T + Math.imul(ue, st) | 0, D = Math.imul(ue, lt);
      var xt = (H + B | 0) + ((T & 8191) << 13) | 0;
      return H = (D + (T >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, U[0] = Rt, U[1] = Ct, U[2] = Je, U[3] = He, U[4] = je, U[5] = pt, U[6] = mt, U[7] = yt, U[8] = ht, U[9] = _t, U[10] = Et, U[11] = Nt, U[12] = Dt, U[13] = $t, U[14] = At, U[15] = Lt, U[16] = Bt, U[17] = Ut, U[18] = xt, H !== 0 && (U[19] = H, I.length++), I;
    };
    Math.imul || (ae = Y);
    function ne(P, S, E) {
      E.negative = S.negative ^ P.negative, E.length = P.length + S.length;
      for (var I = 0, N = 0, $ = 0; $ < E.length - 1; $++) {
        var U = N;
        N = 0;
        for (var H = I & 67108863, B = Math.min($, S.length - 1), T = Math.max(0, $ - P.length + 1); T <= B; T++) {
          var D = $ - T, ee = P.words[D] | 0, pe = S.words[T] | 0, Ie = ee * pe, Pe = Ie & 67108863;
          U = U + (Ie / 67108864 | 0) | 0, Pe = Pe + H | 0, H = Pe & 67108863, U = U + (Pe >>> 26) | 0, N += U >>> 26, U &= 67108863;
        }
        E.words[$] = H, I = U, U = N;
      }
      return I !== 0 ? E.words[$] = I : E.length--, E.strip();
    }
    function fe(P, S, E) {
      var I = new ie();
      return I.mulp(P, S, E);
    }
    p.prototype.mulTo = function(S, E) {
      var I, N = this.length + S.length;
      return this.length === 10 && S.length === 10 ? I = ae(this, S, E) : N < 63 ? I = Y(this, S, E) : N < 1024 ? I = ne(this, S, E) : I = fe(this, S, E), I;
    };
    function ie(P, S) {
      this.x = P, this.y = S;
    }
    ie.prototype.makeRBT = function(S) {
      for (var E = new Array(S), I = p.prototype._countBits(S) - 1, N = 0; N < S; N++)
        E[N] = this.revBin(N, I, S);
      return E;
    }, ie.prototype.revBin = function(S, E, I) {
      if (S === 0 || S === I - 1)
        return S;
      for (var N = 0, $ = 0; $ < E; $++)
        N |= (S & 1) << E - $ - 1, S >>= 1;
      return N;
    }, ie.prototype.permute = function(S, E, I, N, $, U) {
      for (var H = 0; H < U; H++)
        N[H] = E[S[H]], $[H] = I[S[H]];
    }, ie.prototype.transform = function(S, E, I, N, $, U) {
      this.permute(U, S, E, I, N, $);
      for (var H = 1; H < $; H <<= 1)
        for (var B = H << 1, T = Math.cos(2 * Math.PI / B), D = Math.sin(2 * Math.PI / B), ee = 0; ee < $; ee += B)
          for (var pe = T, Ie = D, Pe = 0; Pe < H; Pe++) {
            var he = I[ee + Pe], ve = N[ee + Pe], Q = I[ee + Pe + H], le = N[ee + Pe + H], _e = pe * Q - Ie * le;
            le = pe * le + Ie * Q, Q = _e, I[ee + Pe] = he + Q, N[ee + Pe] = ve + le, I[ee + Pe + H] = he - Q, N[ee + Pe + H] = ve - le, Pe !== B && (_e = T * pe - D * Ie, Ie = T * Ie + D * pe, pe = _e);
          }
    }, ie.prototype.guessLen13b = function(S, E) {
      var I = Math.max(E, S) | 1, N = I & 1, $ = 0;
      for (I = I / 2 | 0; I; I = I >>> 1)
        $++;
      return 1 << $ + 1 + N;
    }, ie.prototype.conjugate = function(S, E, I) {
      if (!(I <= 1))
        for (var N = 0; N < I / 2; N++) {
          var $ = S[N];
          S[N] = S[I - N - 1], S[I - N - 1] = $, $ = E[N], E[N] = -E[I - N - 1], E[I - N - 1] = -$;
        }
    }, ie.prototype.normalize13b = function(S, E) {
      for (var I = 0, N = 0; N < E / 2; N++) {
        var $ = Math.round(S[2 * N + 1] / E) * 8192 + Math.round(S[2 * N] / E) + I;
        S[N] = $ & 67108863, $ < 67108864 ? I = 0 : I = $ / 67108864 | 0;
      }
      return S;
    }, ie.prototype.convert13b = function(S, E, I, N) {
      for (var $ = 0, U = 0; U < E; U++)
        $ = $ + (S[U] | 0), I[2 * U] = $ & 8191, $ = $ >>> 13, I[2 * U + 1] = $ & 8191, $ = $ >>> 13;
      for (U = 2 * E; U < N; ++U)
        I[U] = 0;
      l($ === 0), l(($ & -8192) === 0);
    }, ie.prototype.stub = function(S) {
      for (var E = new Array(S), I = 0; I < S; I++)
        E[I] = 0;
      return E;
    }, ie.prototype.mulp = function(S, E, I) {
      var N = 2 * this.guessLen13b(S.length, E.length), $ = this.makeRBT(N), U = this.stub(N), H = new Array(N), B = new Array(N), T = new Array(N), D = new Array(N), ee = new Array(N), pe = new Array(N), Ie = I.words;
      Ie.length = N, this.convert13b(S.words, S.length, H, N), this.convert13b(E.words, E.length, D, N), this.transform(H, U, B, T, N, $), this.transform(D, U, ee, pe, N, $);
      for (var Pe = 0; Pe < N; Pe++) {
        var he = B[Pe] * ee[Pe] - T[Pe] * pe[Pe];
        T[Pe] = B[Pe] * pe[Pe] + T[Pe] * ee[Pe], B[Pe] = he;
      }
      return this.conjugate(B, T, N), this.transform(B, T, Ie, U, N, $), this.conjugate(Ie, U, N), this.normalize13b(Ie, N), I.negative = S.negative ^ E.negative, I.length = S.length + E.length, I.strip();
    }, p.prototype.mul = function(S) {
      var E = new p(null);
      return E.words = new Array(this.length + S.length), this.mulTo(S, E);
    }, p.prototype.mulf = function(S) {
      var E = new p(null);
      return E.words = new Array(this.length + S.length), fe(this, S, E);
    }, p.prototype.imul = function(S) {
      return this.clone().mulTo(S, this);
    }, p.prototype.imuln = function(S) {
      l(typeof S == "number"), l(S < 67108864);
      for (var E = 0, I = 0; I < this.length; I++) {
        var N = (this.words[I] | 0) * S, $ = (N & 67108863) + (E & 67108863);
        E >>= 26, E += N / 67108864 | 0, E += $ >>> 26, this.words[I] = $ & 67108863;
      }
      return E !== 0 && (this.words[I] = E, this.length++), this;
    }, p.prototype.muln = function(S) {
      return this.clone().imuln(S);
    }, p.prototype.sqr = function() {
      return this.mul(this);
    }, p.prototype.isqr = function() {
      return this.imul(this.clone());
    }, p.prototype.pow = function(S) {
      var E = oe(S);
      if (E.length === 0)
        return new p(1);
      for (var I = this, N = 0; N < E.length && E[N] === 0; N++, I = I.sqr())
        ;
      if (++N < E.length)
        for (var $ = I.sqr(); N < E.length; N++, $ = $.sqr())
          E[N] !== 0 && (I = I.mul($));
      return I;
    }, p.prototype.iushln = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = S % 26, I = (S - E) / 26, N = 67108863 >>> 26 - E << 26 - E, $;
      if (E !== 0) {
        var U = 0;
        for ($ = 0; $ < this.length; $++) {
          var H = this.words[$] & N, B = (this.words[$] | 0) - H << E;
          this.words[$] = B | U, U = H >>> 26 - E;
        }
        U && (this.words[$] = U, this.length++);
      }
      if (I !== 0) {
        for ($ = this.length - 1; $ >= 0; $--)
          this.words[$ + I] = this.words[$];
        for ($ = 0; $ < I; $++)
          this.words[$] = 0;
        this.length += I;
      }
      return this.strip();
    }, p.prototype.ishln = function(S) {
      return l(this.negative === 0), this.iushln(S);
    }, p.prototype.iushrn = function(S, E, I) {
      l(typeof S == "number" && S >= 0);
      var N;
      E ? N = (E - E % 26) / 26 : N = 0;
      var $ = S % 26, U = Math.min((S - $) / 26, this.length), H = 67108863 ^ 67108863 >>> $ << $, B = I;
      if (N -= U, N = Math.max(0, N), B) {
        for (var T = 0; T < U; T++)
          B.words[T] = this.words[T];
        B.length = U;
      }
      if (U !== 0)
        if (this.length > U)
          for (this.length -= U, T = 0; T < this.length; T++)
            this.words[T] = this.words[T + U];
        else
          this.words[0] = 0, this.length = 1;
      var D = 0;
      for (T = this.length - 1; T >= 0 && (D !== 0 || T >= N); T--) {
        var ee = this.words[T] | 0;
        this.words[T] = D << 26 - $ | ee >>> $, D = ee & H;
      }
      return B && D !== 0 && (B.words[B.length++] = D), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, p.prototype.ishrn = function(S, E, I) {
      return l(this.negative === 0), this.iushrn(S, E, I);
    }, p.prototype.shln = function(S) {
      return this.clone().ishln(S);
    }, p.prototype.ushln = function(S) {
      return this.clone().iushln(S);
    }, p.prototype.shrn = function(S) {
      return this.clone().ishrn(S);
    }, p.prototype.ushrn = function(S) {
      return this.clone().iushrn(S);
    }, p.prototype.testn = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = S % 26, I = (S - E) / 26, N = 1 << E;
      if (this.length <= I)
        return !1;
      var $ = this.words[I];
      return !!($ & N);
    }, p.prototype.imaskn = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = S % 26, I = (S - E) / 26;
      if (l(this.negative === 0, "imaskn works only with positive numbers"), this.length <= I)
        return this;
      if (E !== 0 && I++, this.length = Math.min(I, this.length), E !== 0) {
        var N = 67108863 ^ 67108863 >>> E << E;
        this.words[this.length - 1] &= N;
      }
      return this.strip();
    }, p.prototype.maskn = function(S) {
      return this.clone().imaskn(S);
    }, p.prototype.iaddn = function(S) {
      return l(typeof S == "number"), l(S < 67108864), S < 0 ? this.isubn(-S) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < S ? (this.words[0] = S - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(S), this.negative = 1, this) : this._iaddn(S);
    }, p.prototype._iaddn = function(S) {
      this.words[0] += S;
      for (var E = 0; E < this.length && this.words[E] >= 67108864; E++)
        this.words[E] -= 67108864, E === this.length - 1 ? this.words[E + 1] = 1 : this.words[E + 1]++;
      return this.length = Math.max(this.length, E + 1), this;
    }, p.prototype.isubn = function(S) {
      if (l(typeof S == "number"), l(S < 67108864), S < 0)
        return this.iaddn(-S);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(S), this.negative = 1, this;
      if (this.words[0] -= S, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var E = 0; E < this.length && this.words[E] < 0; E++)
          this.words[E] += 67108864, this.words[E + 1] -= 1;
      return this.strip();
    }, p.prototype.addn = function(S) {
      return this.clone().iaddn(S);
    }, p.prototype.subn = function(S) {
      return this.clone().isubn(S);
    }, p.prototype.iabs = function() {
      return this.negative = 0, this;
    }, p.prototype.abs = function() {
      return this.clone().iabs();
    }, p.prototype._ishlnsubmul = function(S, E, I) {
      var N = S.length + I, $;
      this._expand(N);
      var U, H = 0;
      for ($ = 0; $ < S.length; $++) {
        U = (this.words[$ + I] | 0) + H;
        var B = (S.words[$] | 0) * E;
        U -= B & 67108863, H = (U >> 26) - (B / 67108864 | 0), this.words[$ + I] = U & 67108863;
      }
      for (; $ < this.length - I; $++)
        U = (this.words[$ + I] | 0) + H, H = U >> 26, this.words[$ + I] = U & 67108863;
      if (H === 0)
        return this.strip();
      for (l(H === -1), H = 0, $ = 0; $ < this.length; $++)
        U = -(this.words[$] | 0) + H, H = U >> 26, this.words[$] = U & 67108863;
      return this.negative = 1, this.strip();
    }, p.prototype._wordDiv = function(S, E) {
      var I = this.length - S.length, N = this.clone(), $ = S, U = $.words[$.length - 1] | 0, H = this._countBits(U);
      I = 26 - H, I !== 0 && ($ = $.ushln(I), N.iushln(I), U = $.words[$.length - 1] | 0);
      var B = N.length - $.length, T;
      if (E !== "mod") {
        T = new p(null), T.length = B + 1, T.words = new Array(T.length);
        for (var D = 0; D < T.length; D++)
          T.words[D] = 0;
      }
      var ee = N.clone()._ishlnsubmul($, 1, B);
      ee.negative === 0 && (N = ee, T && (T.words[B] = 1));
      for (var pe = B - 1; pe >= 0; pe--) {
        var Ie = (N.words[$.length + pe] | 0) * 67108864 + (N.words[$.length + pe - 1] | 0);
        for (Ie = Math.min(Ie / U | 0, 67108863), N._ishlnsubmul($, Ie, pe); N.negative !== 0; )
          Ie--, N.negative = 0, N._ishlnsubmul($, 1, pe), N.isZero() || (N.negative ^= 1);
        T && (T.words[pe] = Ie);
      }
      return T && T.strip(), N.strip(), E !== "div" && I !== 0 && N.iushrn(I), {
        div: T || null,
        mod: N
      };
    }, p.prototype.divmod = function(S, E, I) {
      if (l(!S.isZero()), this.isZero())
        return {
          div: new p(0),
          mod: new p(0)
        };
      var N, $, U;
      return this.negative !== 0 && S.negative === 0 ? (U = this.neg().divmod(S, E), E !== "mod" && (N = U.div.neg()), E !== "div" && ($ = U.mod.neg(), I && $.negative !== 0 && $.iadd(S)), {
        div: N,
        mod: $
      }) : this.negative === 0 && S.negative !== 0 ? (U = this.divmod(S.neg(), E), E !== "mod" && (N = U.div.neg()), {
        div: N,
        mod: U.mod
      }) : this.negative & S.negative ? (U = this.neg().divmod(S.neg(), E), E !== "div" && ($ = U.mod.neg(), I && $.negative !== 0 && $.isub(S)), {
        div: U.div,
        mod: $
      }) : S.length > this.length || this.cmp(S) < 0 ? {
        div: new p(0),
        mod: this
      } : S.length === 1 ? E === "div" ? {
        div: this.divn(S.words[0]),
        mod: null
      } : E === "mod" ? {
        div: null,
        mod: new p(this.modn(S.words[0]))
      } : {
        div: this.divn(S.words[0]),
        mod: new p(this.modn(S.words[0]))
      } : this._wordDiv(S, E);
    }, p.prototype.div = function(S) {
      return this.divmod(S, "div", !1).div;
    }, p.prototype.mod = function(S) {
      return this.divmod(S, "mod", !1).mod;
    }, p.prototype.umod = function(S) {
      return this.divmod(S, "mod", !0).mod;
    }, p.prototype.divRound = function(S) {
      var E = this.divmod(S);
      if (E.mod.isZero())
        return E.div;
      var I = E.div.negative !== 0 ? E.mod.isub(S) : E.mod, N = S.ushrn(1), $ = S.andln(1), U = I.cmp(N);
      return U < 0 || $ === 1 && U === 0 ? E.div : E.div.negative !== 0 ? E.div.isubn(1) : E.div.iaddn(1);
    }, p.prototype.modn = function(S) {
      l(S <= 67108863);
      for (var E = (1 << 26) % S, I = 0, N = this.length - 1; N >= 0; N--)
        I = (E * I + (this.words[N] | 0)) % S;
      return I;
    }, p.prototype.idivn = function(S) {
      l(S <= 67108863);
      for (var E = 0, I = this.length - 1; I >= 0; I--) {
        var N = (this.words[I] | 0) + E * 67108864;
        this.words[I] = N / S | 0, E = N % S;
      }
      return this.strip();
    }, p.prototype.divn = function(S) {
      return this.clone().idivn(S);
    }, p.prototype.egcd = function(S) {
      l(S.negative === 0), l(!S.isZero());
      var E = this, I = S.clone();
      E.negative !== 0 ? E = E.umod(S) : E = E.clone();
      for (var N = new p(1), $ = new p(0), U = new p(0), H = new p(1), B = 0; E.isEven() && I.isEven(); )
        E.iushrn(1), I.iushrn(1), ++B;
      for (var T = I.clone(), D = E.clone(); !E.isZero(); ) {
        for (var ee = 0, pe = 1; !(E.words[0] & pe) && ee < 26; ++ee, pe <<= 1)
          ;
        if (ee > 0)
          for (E.iushrn(ee); ee-- > 0; )
            (N.isOdd() || $.isOdd()) && (N.iadd(T), $.isub(D)), N.iushrn(1), $.iushrn(1);
        for (var Ie = 0, Pe = 1; !(I.words[0] & Pe) && Ie < 26; ++Ie, Pe <<= 1)
          ;
        if (Ie > 0)
          for (I.iushrn(Ie); Ie-- > 0; )
            (U.isOdd() || H.isOdd()) && (U.iadd(T), H.isub(D)), U.iushrn(1), H.iushrn(1);
        E.cmp(I) >= 0 ? (E.isub(I), N.isub(U), $.isub(H)) : (I.isub(E), U.isub(N), H.isub($));
      }
      return {
        a: U,
        b: H,
        gcd: I.iushln(B)
      };
    }, p.prototype._invmp = function(S) {
      l(S.negative === 0), l(!S.isZero());
      var E = this, I = S.clone();
      E.negative !== 0 ? E = E.umod(S) : E = E.clone();
      for (var N = new p(1), $ = new p(0), U = I.clone(); E.cmpn(1) > 0 && I.cmpn(1) > 0; ) {
        for (var H = 0, B = 1; !(E.words[0] & B) && H < 26; ++H, B <<= 1)
          ;
        if (H > 0)
          for (E.iushrn(H); H-- > 0; )
            N.isOdd() && N.iadd(U), N.iushrn(1);
        for (var T = 0, D = 1; !(I.words[0] & D) && T < 26; ++T, D <<= 1)
          ;
        if (T > 0)
          for (I.iushrn(T); T-- > 0; )
            $.isOdd() && $.iadd(U), $.iushrn(1);
        E.cmp(I) >= 0 ? (E.isub(I), N.isub($)) : (I.isub(E), $.isub(N));
      }
      var ee;
      return E.cmpn(1) === 0 ? ee = N : ee = $, ee.cmpn(0) < 0 && ee.iadd(S), ee;
    }, p.prototype.gcd = function(S) {
      if (this.isZero())
        return S.abs();
      if (S.isZero())
        return this.abs();
      var E = this.clone(), I = S.clone();
      E.negative = 0, I.negative = 0;
      for (var N = 0; E.isEven() && I.isEven(); N++)
        E.iushrn(1), I.iushrn(1);
      do {
        for (; E.isEven(); )
          E.iushrn(1);
        for (; I.isEven(); )
          I.iushrn(1);
        var $ = E.cmp(I);
        if ($ < 0) {
          var U = E;
          E = I, I = U;
        } else if ($ === 0 || I.cmpn(1) === 0)
          break;
        E.isub(I);
      } while (!0);
      return I.iushln(N);
    }, p.prototype.invm = function(S) {
      return this.egcd(S).a.umod(S);
    }, p.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, p.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, p.prototype.andln = function(S) {
      return this.words[0] & S;
    }, p.prototype.bincn = function(S) {
      l(typeof S == "number");
      var E = S % 26, I = (S - E) / 26, N = 1 << E;
      if (this.length <= I)
        return this._expand(I + 1), this.words[I] |= N, this;
      for (var $ = N, U = I; $ !== 0 && U < this.length; U++) {
        var H = this.words[U] | 0;
        H += $, $ = H >>> 26, H &= 67108863, this.words[U] = H;
      }
      return $ !== 0 && (this.words[U] = $, this.length++), this;
    }, p.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, p.prototype.cmpn = function(S) {
      var E = S < 0;
      if (this.negative !== 0 && !E)
        return -1;
      if (this.negative === 0 && E)
        return 1;
      this.strip();
      var I;
      if (this.length > 1)
        I = 1;
      else {
        E && (S = -S), l(S <= 67108863, "Number is too big");
        var N = this.words[0] | 0;
        I = N === S ? 0 : N < S ? -1 : 1;
      }
      return this.negative !== 0 ? -I | 0 : I;
    }, p.prototype.cmp = function(S) {
      if (this.negative !== 0 && S.negative === 0)
        return -1;
      if (this.negative === 0 && S.negative !== 0)
        return 1;
      var E = this.ucmp(S);
      return this.negative !== 0 ? -E | 0 : E;
    }, p.prototype.ucmp = function(S) {
      if (this.length > S.length)
        return 1;
      if (this.length < S.length)
        return -1;
      for (var E = 0, I = this.length - 1; I >= 0; I--) {
        var N = this.words[I] | 0, $ = S.words[I] | 0;
        if (N !== $) {
          N < $ ? E = -1 : N > $ && (E = 1);
          break;
        }
      }
      return E;
    }, p.prototype.gtn = function(S) {
      return this.cmpn(S) === 1;
    }, p.prototype.gt = function(S) {
      return this.cmp(S) === 1;
    }, p.prototype.gten = function(S) {
      return this.cmpn(S) >= 0;
    }, p.prototype.gte = function(S) {
      return this.cmp(S) >= 0;
    }, p.prototype.ltn = function(S) {
      return this.cmpn(S) === -1;
    }, p.prototype.lt = function(S) {
      return this.cmp(S) === -1;
    }, p.prototype.lten = function(S) {
      return this.cmpn(S) <= 0;
    }, p.prototype.lte = function(S) {
      return this.cmp(S) <= 0;
    }, p.prototype.eqn = function(S) {
      return this.cmpn(S) === 0;
    }, p.prototype.eq = function(S) {
      return this.cmp(S) === 0;
    }, p.red = function(S) {
      return new Z(S);
    }, p.prototype.toRed = function(S) {
      return l(!this.red, "Already a number in reduction context"), l(this.negative === 0, "red works only with positives"), S.convertTo(this)._forceRed(S);
    }, p.prototype.fromRed = function() {
      return l(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, p.prototype._forceRed = function(S) {
      return this.red = S, this;
    }, p.prototype.forceRed = function(S) {
      return l(!this.red, "Already a number in reduction context"), this._forceRed(S);
    }, p.prototype.redAdd = function(S) {
      return l(this.red, "redAdd works only with red numbers"), this.red.add(this, S);
    }, p.prototype.redIAdd = function(S) {
      return l(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, S);
    }, p.prototype.redSub = function(S) {
      return l(this.red, "redSub works only with red numbers"), this.red.sub(this, S);
    }, p.prototype.redISub = function(S) {
      return l(this.red, "redISub works only with red numbers"), this.red.isub(this, S);
    }, p.prototype.redShl = function(S) {
      return l(this.red, "redShl works only with red numbers"), this.red.shl(this, S);
    }, p.prototype.redMul = function(S) {
      return l(this.red, "redMul works only with red numbers"), this.red._verify2(this, S), this.red.mul(this, S);
    }, p.prototype.redIMul = function(S) {
      return l(this.red, "redMul works only with red numbers"), this.red._verify2(this, S), this.red.imul(this, S);
    }, p.prototype.redSqr = function() {
      return l(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, p.prototype.redISqr = function() {
      return l(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, p.prototype.redSqrt = function() {
      return l(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, p.prototype.redInvm = function() {
      return l(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, p.prototype.redNeg = function() {
      return l(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, p.prototype.redPow = function(S) {
      return l(this.red && !S.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, S);
    };
    var ge = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function be(P, S) {
      this.name = P, this.p = new p(S, 16), this.n = this.p.bitLength(), this.k = new p(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    be.prototype._tmp = function() {
      var S = new p(null);
      return S.words = new Array(Math.ceil(this.n / 13)), S;
    }, be.prototype.ireduce = function(S) {
      var E = S, I;
      do
        this.split(E, this.tmp), E = this.imulK(E), E = E.iadd(this.tmp), I = E.bitLength();
      while (I > this.n);
      var N = I < this.n ? -1 : E.ucmp(this.p);
      return N === 0 ? (E.words[0] = 0, E.length = 1) : N > 0 ? E.isub(this.p) : E.strip !== void 0 ? E.strip() : E._strip(), E;
    }, be.prototype.split = function(S, E) {
      S.iushrn(this.n, 0, E);
    }, be.prototype.imulK = function(S) {
      return S.imul(this.k);
    };
    function Ce() {
      be.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    v(Ce, be), Ce.prototype.split = function(S, E) {
      for (var I = 4194303, N = Math.min(S.length, 9), $ = 0; $ < N; $++)
        E.words[$] = S.words[$];
      if (E.length = N, S.length <= 9) {
        S.words[0] = 0, S.length = 1;
        return;
      }
      var U = S.words[9];
      for (E.words[E.length++] = U & I, $ = 10; $ < S.length; $++) {
        var H = S.words[$] | 0;
        S.words[$ - 10] = (H & I) << 4 | U >>> 22, U = H;
      }
      U >>>= 22, S.words[$ - 10] = U, U === 0 && S.length > 10 ? S.length -= 10 : S.length -= 9;
    }, Ce.prototype.imulK = function(S) {
      S.words[S.length] = 0, S.words[S.length + 1] = 0, S.length += 2;
      for (var E = 0, I = 0; I < S.length; I++) {
        var N = S.words[I] | 0;
        E += N * 977, S.words[I] = E & 67108863, E = N * 64 + (E / 67108864 | 0);
      }
      return S.words[S.length - 1] === 0 && (S.length--, S.words[S.length - 1] === 0 && S.length--), S;
    };
    function Me() {
      be.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    v(Me, be);
    function Be() {
      be.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    v(Be, be);
    function Ae() {
      be.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    v(Ae, be), Ae.prototype.imulK = function(S) {
      for (var E = 0, I = 0; I < S.length; I++) {
        var N = (S.words[I] | 0) * 19 + E, $ = N & 67108863;
        N >>>= 26, S.words[I] = $, E = N;
      }
      return E !== 0 && (S.words[S.length++] = E), S;
    }, p._prime = function(S) {
      if (ge[S])
        return ge[S];
      var E;
      if (S === "k256")
        E = new Ce();
      else if (S === "p224")
        E = new Me();
      else if (S === "p192")
        E = new Be();
      else if (S === "p25519")
        E = new Ae();
      else
        throw new Error("Unknown prime " + S);
      return ge[S] = E, E;
    };
    function Z(P) {
      if (typeof P == "string") {
        var S = p._prime(P);
        this.m = S.p, this.prime = S;
      } else
        l(P.gtn(1), "modulus must be greater than 1"), this.m = P, this.prime = null;
    }
    Z.prototype._verify1 = function(S) {
      l(S.negative === 0, "red works only with positives"), l(S.red, "red works only with red numbers");
    }, Z.prototype._verify2 = function(S, E) {
      l((S.negative | E.negative) === 0, "red works only with positives"), l(
        S.red && S.red === E.red,
        "red works only with red numbers"
      );
    }, Z.prototype.imod = function(S) {
      return this.prime ? this.prime.ireduce(S)._forceRed(this) : S.umod(this.m)._forceRed(this);
    }, Z.prototype.neg = function(S) {
      return S.isZero() ? S.clone() : this.m.sub(S)._forceRed(this);
    }, Z.prototype.add = function(S, E) {
      this._verify2(S, E);
      var I = S.add(E);
      return I.cmp(this.m) >= 0 && I.isub(this.m), I._forceRed(this);
    }, Z.prototype.iadd = function(S, E) {
      this._verify2(S, E);
      var I = S.iadd(E);
      return I.cmp(this.m) >= 0 && I.isub(this.m), I;
    }, Z.prototype.sub = function(S, E) {
      this._verify2(S, E);
      var I = S.sub(E);
      return I.cmpn(0) < 0 && I.iadd(this.m), I._forceRed(this);
    }, Z.prototype.isub = function(S, E) {
      this._verify2(S, E);
      var I = S.isub(E);
      return I.cmpn(0) < 0 && I.iadd(this.m), I;
    }, Z.prototype.shl = function(S, E) {
      return this._verify1(S), this.imod(S.ushln(E));
    }, Z.prototype.imul = function(S, E) {
      return this._verify2(S, E), this.imod(S.imul(E));
    }, Z.prototype.mul = function(S, E) {
      return this._verify2(S, E), this.imod(S.mul(E));
    }, Z.prototype.isqr = function(S) {
      return this.imul(S, S.clone());
    }, Z.prototype.sqr = function(S) {
      return this.mul(S, S);
    }, Z.prototype.sqrt = function(S) {
      if (S.isZero())
        return S.clone();
      var E = this.m.andln(3);
      if (l(E % 2 === 1), E === 3) {
        var I = this.m.add(new p(1)).iushrn(2);
        return this.pow(S, I);
      }
      for (var N = this.m.subn(1), $ = 0; !N.isZero() && N.andln(1) === 0; )
        $++, N.iushrn(1);
      l(!N.isZero());
      var U = new p(1).toRed(this), H = U.redNeg(), B = this.m.subn(1).iushrn(1), T = this.m.bitLength();
      for (T = new p(2 * T * T).toRed(this); this.pow(T, B).cmp(H) !== 0; )
        T.redIAdd(H);
      for (var D = this.pow(T, N), ee = this.pow(S, N.addn(1).iushrn(1)), pe = this.pow(S, N), Ie = $; pe.cmp(U) !== 0; ) {
        for (var Pe = pe, he = 0; Pe.cmp(U) !== 0; he++)
          Pe = Pe.redSqr();
        l(he < Ie);
        var ve = this.pow(D, new p(1).iushln(Ie - he - 1));
        ee = ee.redMul(ve), D = ve.redSqr(), pe = pe.redMul(D), Ie = he;
      }
      return ee;
    }, Z.prototype.invm = function(S) {
      var E = S._invmp(this.m);
      return E.negative !== 0 ? (E.negative = 0, this.imod(E).redNeg()) : this.imod(E);
    }, Z.prototype.pow = function(S, E) {
      if (E.isZero())
        return new p(1).toRed(this);
      if (E.cmpn(1) === 0)
        return S.clone();
      var I = 4, N = new Array(1 << I);
      N[0] = new p(1).toRed(this), N[1] = S;
      for (var $ = 2; $ < N.length; $++)
        N[$] = this.mul(N[$ - 1], S);
      var U = N[0], H = 0, B = 0, T = E.bitLength() % 26;
      for (T === 0 && (T = 26), $ = E.length - 1; $ >= 0; $--) {
        for (var D = E.words[$], ee = T - 1; ee >= 0; ee--) {
          var pe = D >> ee & 1;
          if (U !== N[0] && (U = this.sqr(U)), pe === 0 && H === 0) {
            B = 0;
            continue;
          }
          H <<= 1, H |= pe, B++, !(B !== I && ($ !== 0 || ee !== 0)) && (U = this.mul(U, N[H]), B = 0, H = 0);
        }
        T = 26;
      }
      return U;
    }, Z.prototype.convertTo = function(S) {
      var E = S.umod(this.m);
      return E === S ? E.clone() : E;
    }, Z.prototype.convertFrom = function(S) {
      var E = S.clone();
      return E.red = null, E;
    }, p.mont = function(S) {
      return new z(S);
    };
    function z(P) {
      Z.call(this, P), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new p(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    v(z, Z), z.prototype.convertTo = function(S) {
      return this.imod(S.ushln(this.shift));
    }, z.prototype.convertFrom = function(S) {
      var E = this.imod(S.mul(this.rinv));
      return E.red = null, E;
    }, z.prototype.imul = function(S, E) {
      if (S.isZero() || E.isZero())
        return S.words[0] = 0, S.length = 1, S;
      var I = S.imul(E), N = I.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), $ = I.isub(N).iushrn(this.shift), U = $;
      return $.cmp(this.m) >= 0 ? U = $.isub(this.m) : $.cmpn(0) < 0 && (U = $.iadd(this.m)), U._forceRed(this);
    }, z.prototype.mul = function(S, E) {
      if (S.isZero() || E.isZero())
        return new p(0)._forceRed(this);
      var I = S.mul(E), N = I.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), $ = I.isub(N).iushrn(this.shift), U = $;
      return $.cmp(this.m) >= 0 ? U = $.isub(this.m) : $.cmpn(0) < 0 && (U = $.iadd(this.m)), U._forceRed(this);
    }, z.prototype.invm = function(S) {
      var E = this.imod(S._invmp(this.m).mul(this.r2));
      return E._forceRed(this);
    };
  })(a, commonjsGlobal$1);
})(bn$5);
var bnExports$5 = bn$5.exports, brorand = { exports: {} }, hasRequiredBrorand;
function requireBrorand() {
  if (hasRequiredBrorand)
    return brorand.exports;
  hasRequiredBrorand = 1;
  var a;
  brorand.exports = function(v) {
    return a || (a = new u(null)), a.generate(v);
  };
  function u(l) {
    this.rand = l;
  }
  if (brorand.exports.Rand = u, u.prototype.generate = function(v) {
    return this._rand(v);
  }, u.prototype._rand = function(v) {
    if (this.rand.getBytes)
      return this.rand.getBytes(v);
    for (var p = new Uint8Array(v), _ = 0; _ < p.length; _++)
      p[_] = this.rand.getByte();
    return p;
  }, typeof self == "object")
    self.crypto && self.crypto.getRandomValues ? u.prototype._rand = function(v) {
      var p = new Uint8Array(v);
      return self.crypto.getRandomValues(p), p;
    } : self.msCrypto && self.msCrypto.getRandomValues ? u.prototype._rand = function(v) {
      var p = new Uint8Array(v);
      return self.msCrypto.getRandomValues(p), p;
    } : typeof window == "object" && (u.prototype._rand = function() {
      throw new Error("Not implemented yet");
    });
  else
    try {
      var c = requireCryptoBrowserify();
      if (typeof c.randomBytes != "function")
        throw new Error("Not supported");
      u.prototype._rand = function(v) {
        return c.randomBytes(v);
      };
    } catch {
    }
  return brorand.exports;
}
var mr, hasRequiredMr;
function requireMr() {
  if (hasRequiredMr)
    return mr;
  hasRequiredMr = 1;
  var a = bnExports$5, u = requireBrorand();
  function c(l) {
    this.rand = l || new u.Rand();
  }
  return mr = c, c.create = function(v) {
    return new c(v);
  }, c.prototype._randbelow = function(v) {
    var p = v.bitLength(), _ = Math.ceil(p / 8);
    do
      var k = new a(this.rand.generate(_));
    while (k.cmp(v) >= 0);
    return k;
  }, c.prototype._randrange = function(v, p) {
    var _ = p.sub(v);
    return v.add(this._randbelow(_));
  }, c.prototype.test = function(v, p, _) {
    var k = v.bitLength(), M = a.mont(v), L = new a(1).toRed(M);
    p || (p = Math.max(1, k / 48 | 0));
    for (var F = v.subn(1), V = 0; !F.testn(V); V++)
      ;
    for (var X = v.shrn(V), oe = F.toRed(M), Y = !0; p > 0; p--) {
      var ae = this._randrange(new a(2), F);
      _ && _(ae);
      var ne = ae.toRed(M).redPow(X);
      if (!(ne.cmp(L) === 0 || ne.cmp(oe) === 0)) {
        for (var fe = 1; fe < V; fe++) {
          if (ne = ne.redSqr(), ne.cmp(L) === 0)
            return !1;
          if (ne.cmp(oe) === 0)
            break;
        }
        if (fe === V)
          return !1;
      }
    }
    return Y;
  }, c.prototype.getDivisor = function(v, p) {
    var _ = v.bitLength(), k = a.mont(v), M = new a(1).toRed(k);
    p || (p = Math.max(1, _ / 48 | 0));
    for (var L = v.subn(1), F = 0; !L.testn(F); F++)
      ;
    for (var V = v.shrn(F), X = L.toRed(k); p > 0; p--) {
      var oe = this._randrange(new a(2), L), Y = v.gcd(oe);
      if (Y.cmpn(1) !== 0)
        return Y;
      var ae = oe.toRed(k).redPow(V);
      if (!(ae.cmp(M) === 0 || ae.cmp(X) === 0)) {
        for (var ne = 1; ne < F; ne++) {
          if (ae = ae.redSqr(), ae.cmp(M) === 0)
            return ae.fromRed().subn(1).gcd(v);
          if (ae.cmp(X) === 0)
            break;
        }
        if (ne === F)
          return ae = ae.redSqr(), ae.fromRed().subn(1).gcd(v);
      }
    }
    return !1;
  }, mr;
}
var generatePrime, hasRequiredGeneratePrime;
function requireGeneratePrime() {
  if (hasRequiredGeneratePrime)
    return generatePrime;
  hasRequiredGeneratePrime = 1;
  var a = browserExports;
  generatePrime = ne, ne.simpleSieve = Y, ne.fermatTest = ae;
  var u = bnExports$6, c = new u(24), l = requireMr(), v = new l(), p = new u(1), _ = new u(2), k = new u(5);
  new u(16), new u(8);
  var M = new u(10), L = new u(3);
  new u(7);
  var F = new u(11), V = new u(4);
  new u(12);
  var X = null;
  function oe() {
    if (X !== null)
      return X;
    var fe = 1048576, ie = [];
    ie[0] = 2;
    for (var ge = 1, be = 3; be < fe; be += 2) {
      for (var Ce = Math.ceil(Math.sqrt(be)), Me = 0; Me < ge && ie[Me] <= Ce && be % ie[Me] !== 0; Me++)
        ;
      ge !== Me && ie[Me] <= Ce || (ie[ge++] = be);
    }
    return X = ie, ie;
  }
  function Y(fe) {
    for (var ie = oe(), ge = 0; ge < ie.length; ge++)
      if (fe.modn(ie[ge]) === 0)
        return fe.cmpn(ie[ge]) === 0;
    return !0;
  }
  function ae(fe) {
    var ie = u.mont(fe);
    return _.toRed(ie).redPow(fe.subn(1)).fromRed().cmpn(1) === 0;
  }
  function ne(fe, ie) {
    if (fe < 16)
      return ie === 2 || ie === 5 ? new u([140, 123]) : new u([140, 39]);
    ie = new u(ie);
    for (var ge, be; ; ) {
      for (ge = new u(a(Math.ceil(fe / 8))); ge.bitLength() > fe; )
        ge.ishrn(1);
      if (ge.isEven() && ge.iadd(p), ge.testn(1) || ge.iadd(_), ie.cmp(_)) {
        if (!ie.cmp(k))
          for (; ge.mod(M).cmp(L); )
            ge.iadd(V);
      } else
        for (; ge.mod(c).cmp(F); )
          ge.iadd(V);
      if (be = ge.shrn(1), Y(be) && Y(ge) && ae(be) && ae(ge) && v.test(be) && v.test(ge))
        return ge;
    }
  }
  return generatePrime;
}
const modp1 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
}, modp2 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
}, modp5 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
}, modp14 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
}, modp15 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
}, modp16 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
}, modp17 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
}, modp18 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
}, require$$1$1 = {
  modp1,
  modp2,
  modp5,
  modp14,
  modp15,
  modp16,
  modp17,
  modp18
};
var dh, hasRequiredDh;
function requireDh() {
  if (hasRequiredDh)
    return dh;
  hasRequiredDh = 1;
  var a = bnExports$6, u = requireMr(), c = new u(), l = new a(24), v = new a(11), p = new a(10), _ = new a(3), k = new a(7), M = requireGeneratePrime(), L = browserExports;
  dh = Y;
  function F(ne, fe) {
    return fe = fe || "utf8", Buffer$O.isBuffer(ne) || (ne = new Buffer$O(ne, fe)), this._pub = new a(ne), this;
  }
  function V(ne, fe) {
    return fe = fe || "utf8", Buffer$O.isBuffer(ne) || (ne = new Buffer$O(ne, fe)), this._priv = new a(ne), this;
  }
  var X = {};
  function oe(ne, fe) {
    var ie = fe.toString("hex"), ge = [ie, ne.toString(16)].join("_");
    if (ge in X)
      return X[ge];
    var be = 0;
    if (ne.isEven() || !M.simpleSieve || !M.fermatTest(ne) || !c.test(ne))
      return be += 1, ie === "02" || ie === "05" ? be += 8 : be += 4, X[ge] = be, be;
    c.test(ne.shrn(1)) || (be += 2);
    var Ce;
    switch (ie) {
      case "02":
        ne.mod(l).cmp(v) && (be += 8);
        break;
      case "05":
        Ce = ne.mod(p), Ce.cmp(_) && Ce.cmp(k) && (be += 8);
        break;
      default:
        be += 4;
    }
    return X[ge] = be, be;
  }
  function Y(ne, fe, ie) {
    this.setGenerator(fe), this.__prime = new a(ne), this._prime = a.mont(this.__prime), this._primeLen = ne.length, this._pub = void 0, this._priv = void 0, this._primeCode = void 0, ie ? (this.setPublicKey = F, this.setPrivateKey = V) : this._primeCode = 8;
  }
  Object.defineProperty(Y.prototype, "verifyError", {
    enumerable: !0,
    get: function() {
      return typeof this._primeCode != "number" && (this._primeCode = oe(this.__prime, this.__gen)), this._primeCode;
    }
  }), Y.prototype.generateKeys = function() {
    return this._priv || (this._priv = new a(L(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey();
  }, Y.prototype.computeSecret = function(ne) {
    ne = new a(ne), ne = ne.toRed(this._prime);
    var fe = ne.redPow(this._priv).fromRed(), ie = new Buffer$O(fe.toArray()), ge = this.getPrime();
    if (ie.length < ge.length) {
      var be = new Buffer$O(ge.length - ie.length);
      be.fill(0), ie = Buffer$O.concat([be, ie]);
    }
    return ie;
  }, Y.prototype.getPublicKey = function(fe) {
    return ae(this._pub, fe);
  }, Y.prototype.getPrivateKey = function(fe) {
    return ae(this._priv, fe);
  }, Y.prototype.getPrime = function(ne) {
    return ae(this.__prime, ne);
  }, Y.prototype.getGenerator = function(ne) {
    return ae(this._gen, ne);
  }, Y.prototype.setGenerator = function(ne, fe) {
    return fe = fe || "utf8", Buffer$O.isBuffer(ne) || (ne = new Buffer$O(ne, fe)), this.__gen = ne, this._gen = new a(ne), this;
  };
  function ae(ne, fe) {
    var ie = new Buffer$O(ne.toArray());
    return fe ? ie.toString(fe) : ie;
  }
  return dh;
}
var hasRequiredBrowser$2;
function requireBrowser$2() {
  if (hasRequiredBrowser$2)
    return browser$5;
  hasRequiredBrowser$2 = 1;
  var a = requireGeneratePrime(), u = require$$1$1, c = requireDh();
  function l(_) {
    var k = new Buffer$O(u[_].prime, "hex"), M = new Buffer$O(u[_].gen, "hex");
    return new c(k, M);
  }
  var v = {
    binary: !0,
    hex: !0,
    base64: !0
  };
  function p(_, k, M, L) {
    return Buffer$O.isBuffer(k) || v[k] === void 0 ? p(_, "binary", k, M) : (k = k || "binary", L = L || "binary", M = M || new Buffer$O([2]), Buffer$O.isBuffer(M) || (M = new Buffer$O(M, L)), typeof _ == "number" ? new c(a(_, M), M, !0) : (Buffer$O.isBuffer(_) || (_ = new Buffer$O(_, k)), new c(_, M, !0)));
  }
  return browser$5.DiffieHellmanGroup = browser$5.createDiffieHellmanGroup = browser$5.getDiffieHellman = l, browser$5.createDiffieHellman = browser$5.DiffieHellman = p, browser$5;
}
var safeBuffer$1 = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(a, u) {
  var c = require$$0$2, l = c.Buffer;
  function v(_, k) {
    for (var M in _)
      k[M] = _[M];
  }
  l.from && l.alloc && l.allocUnsafe && l.allocUnsafeSlow ? a.exports = c : (v(c, u), u.Buffer = p);
  function p(_, k, M) {
    return l(_, k, M);
  }
  p.prototype = Object.create(l.prototype), v(l, p), p.from = function(_, k, M) {
    if (typeof _ == "number")
      throw new TypeError("Argument must not be a number");
    return l(_, k, M);
  }, p.alloc = function(_, k, M) {
    if (typeof _ != "number")
      throw new TypeError("Argument must be a number");
    var L = l(_);
    return k !== void 0 ? typeof M == "string" ? L.fill(k, M) : L.fill(k) : L.fill(0), L;
  }, p.allocUnsafe = function(_) {
    if (typeof _ != "number")
      throw new TypeError("Argument must be a number");
    return l(_);
  }, p.allocUnsafeSlow = function(_) {
    if (typeof _ != "number")
      throw new TypeError("Argument must be a number");
    return c.SlowBuffer(_);
  };
})(safeBuffer$1, safeBuffer$1.exports);
var safeBufferExports = safeBuffer$1.exports, readableBrowser = { exports: {} }, streamBrowser = eventsExports.EventEmitter, buffer_list, hasRequiredBuffer_list;
function requireBuffer_list() {
  if (hasRequiredBuffer_list)
    return buffer_list;
  hasRequiredBuffer_list = 1;
  function a(Y, ae) {
    var ne = Object.keys(Y);
    if (Object.getOwnPropertySymbols) {
      var fe = Object.getOwnPropertySymbols(Y);
      ae && (fe = fe.filter(function(ie) {
        return Object.getOwnPropertyDescriptor(Y, ie).enumerable;
      })), ne.push.apply(ne, fe);
    }
    return ne;
  }
  function u(Y) {
    for (var ae = 1; ae < arguments.length; ae++) {
      var ne = arguments[ae] != null ? arguments[ae] : {};
      ae % 2 ? a(Object(ne), !0).forEach(function(fe) {
        c(Y, fe, ne[fe]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(Y, Object.getOwnPropertyDescriptors(ne)) : a(Object(ne)).forEach(function(fe) {
        Object.defineProperty(Y, fe, Object.getOwnPropertyDescriptor(ne, fe));
      });
    }
    return Y;
  }
  function c(Y, ae, ne) {
    return ae = _(ae), ae in Y ? Object.defineProperty(Y, ae, { value: ne, enumerable: !0, configurable: !0, writable: !0 }) : Y[ae] = ne, Y;
  }
  function l(Y, ae) {
    if (!(Y instanceof ae))
      throw new TypeError("Cannot call a class as a function");
  }
  function v(Y, ae) {
    for (var ne = 0; ne < ae.length; ne++) {
      var fe = ae[ne];
      fe.enumerable = fe.enumerable || !1, fe.configurable = !0, "value" in fe && (fe.writable = !0), Object.defineProperty(Y, _(fe.key), fe);
    }
  }
  function p(Y, ae, ne) {
    return ae && v(Y.prototype, ae), ne && v(Y, ne), Object.defineProperty(Y, "prototype", { writable: !1 }), Y;
  }
  function _(Y) {
    var ae = k(Y, "string");
    return typeof ae == "symbol" ? ae : String(ae);
  }
  function k(Y, ae) {
    if (typeof Y != "object" || Y === null)
      return Y;
    var ne = Y[Symbol.toPrimitive];
    if (ne !== void 0) {
      var fe = ne.call(Y, ae || "default");
      if (typeof fe != "object")
        return fe;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (ae === "string" ? String : Number)(Y);
  }
  var M = require$$0$2, L = M.Buffer, F = util$4, V = F.inspect, X = V && V.custom || "inspect";
  function oe(Y, ae, ne) {
    L.prototype.copy.call(Y, ae, ne);
  }
  return buffer_list = /* @__PURE__ */ function() {
    function Y() {
      l(this, Y), this.head = null, this.tail = null, this.length = 0;
    }
    return p(Y, [{
      key: "push",
      value: function(ne) {
        var fe = {
          data: ne,
          next: null
        };
        this.length > 0 ? this.tail.next = fe : this.head = fe, this.tail = fe, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(ne) {
        var fe = {
          data: ne,
          next: this.head
        };
        this.length === 0 && (this.tail = fe), this.head = fe, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var ne = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, ne;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(ne) {
        if (this.length === 0)
          return "";
        for (var fe = this.head, ie = "" + fe.data; fe = fe.next; )
          ie += ne + fe.data;
        return ie;
      }
    }, {
      key: "concat",
      value: function(ne) {
        if (this.length === 0)
          return L.alloc(0);
        for (var fe = L.allocUnsafe(ne >>> 0), ie = this.head, ge = 0; ie; )
          oe(ie.data, fe, ge), ge += ie.data.length, ie = ie.next;
        return fe;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(ne, fe) {
        var ie;
        return ne < this.head.data.length ? (ie = this.head.data.slice(0, ne), this.head.data = this.head.data.slice(ne)) : ne === this.head.data.length ? ie = this.shift() : ie = fe ? this._getString(ne) : this._getBuffer(ne), ie;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(ne) {
        var fe = this.head, ie = 1, ge = fe.data;
        for (ne -= ge.length; fe = fe.next; ) {
          var be = fe.data, Ce = ne > be.length ? be.length : ne;
          if (Ce === be.length ? ge += be : ge += be.slice(0, ne), ne -= Ce, ne === 0) {
            Ce === be.length ? (++ie, fe.next ? this.head = fe.next : this.head = this.tail = null) : (this.head = fe, fe.data = be.slice(Ce));
            break;
          }
          ++ie;
        }
        return this.length -= ie, ge;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(ne) {
        var fe = L.allocUnsafe(ne), ie = this.head, ge = 1;
        for (ie.data.copy(fe), ne -= ie.data.length; ie = ie.next; ) {
          var be = ie.data, Ce = ne > be.length ? be.length : ne;
          if (be.copy(fe, fe.length - ne, 0, Ce), ne -= Ce, ne === 0) {
            Ce === be.length ? (++ge, ie.next ? this.head = ie.next : this.head = this.tail = null) : (this.head = ie, ie.data = be.slice(Ce));
            break;
          }
          ++ge;
        }
        return this.length -= ge, fe;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: X,
      value: function(ne, fe) {
        return V(this, u(u({}, fe), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), Y;
  }(), buffer_list;
}
function destroy(a, u) {
  var c = this, l = this._readableState && this._readableState.destroyed, v = this._writableState && this._writableState.destroyed;
  return l || v ? (u ? u(a) : a && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process$1.nextTick(emitErrorNT, this, a)) : process$1.nextTick(emitErrorNT, this, a)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(a || null, function(p) {
    !u && p ? c._writableState ? c._writableState.errorEmitted ? process$1.nextTick(emitCloseNT, c) : (c._writableState.errorEmitted = !0, process$1.nextTick(emitErrorAndCloseNT, c, p)) : process$1.nextTick(emitErrorAndCloseNT, c, p) : u ? (process$1.nextTick(emitCloseNT, c), u(p)) : process$1.nextTick(emitCloseNT, c);
  }), this);
}
function emitErrorAndCloseNT(a, u) {
  emitErrorNT(a, u), emitCloseNT(a);
}
function emitCloseNT(a) {
  a._writableState && !a._writableState.emitClose || a._readableState && !a._readableState.emitClose || a.emit("close");
}
function undestroy() {
  this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
}
function emitErrorNT(a, u) {
  a.emit("error", u);
}
function errorOrDestroy(a, u) {
  var c = a._readableState, l = a._writableState;
  c && c.autoDestroy || l && l.autoDestroy ? a.destroy(u) : a.emit("error", u);
}
var destroy_1 = {
  destroy,
  undestroy,
  errorOrDestroy
}, errorsBrowser = {};
function _inheritsLoose$1(a, u) {
  a.prototype = Object.create(u.prototype), a.prototype.constructor = a, a.__proto__ = u;
}
var codes = {};
function createErrorType(a, u, c) {
  c || (c = Error);
  function l(p, _, k) {
    return typeof u == "string" ? u : u(p, _, k);
  }
  var v = /* @__PURE__ */ function(p) {
    _inheritsLoose$1(_, p);
    function _(k, M, L) {
      return p.call(this, l(k, M, L)) || this;
    }
    return _;
  }(c);
  v.prototype.name = c.name, v.prototype.code = a, codes[a] = v;
}
function oneOf(a, u) {
  if (Array.isArray(a)) {
    var c = a.length;
    return a = a.map(function(l) {
      return String(l);
    }), c > 2 ? "one of ".concat(u, " ").concat(a.slice(0, c - 1).join(", "), ", or ") + a[c - 1] : c === 2 ? "one of ".concat(u, " ").concat(a[0], " or ").concat(a[1]) : "of ".concat(u, " ").concat(a[0]);
  } else
    return "of ".concat(u, " ").concat(String(a));
}
function startsWith(a, u, c) {
  return a.substr(!c || c < 0 ? 0 : +c, u.length) === u;
}
function endsWith(a, u, c) {
  return (c === void 0 || c > a.length) && (c = a.length), a.substring(c - u.length, c) === u;
}
function includes$2(a, u, c) {
  return typeof c != "number" && (c = 0), c + u.length > a.length ? !1 : a.indexOf(u, c) !== -1;
}
createErrorType("ERR_INVALID_OPT_VALUE", function(a, u) {
  return 'The value "' + u + '" is invalid for option "' + a + '"';
}, TypeError);
createErrorType("ERR_INVALID_ARG_TYPE", function(a, u, c) {
  var l;
  typeof u == "string" && startsWith(u, "not ") ? (l = "must not be", u = u.replace(/^not /, "")) : l = "must be";
  var v;
  if (endsWith(a, " argument"))
    v = "The ".concat(a, " ").concat(l, " ").concat(oneOf(u, "type"));
  else {
    var p = includes$2(a, ".") ? "property" : "argument";
    v = 'The "'.concat(a, '" ').concat(p, " ").concat(l, " ").concat(oneOf(u, "type"));
  }
  return v += ". Received type ".concat(typeof c), v;
}, TypeError);
createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(a) {
  return "The " + a + " method is not implemented";
});
createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
createErrorType("ERR_STREAM_DESTROYED", function(a) {
  return "Cannot call " + a + " after a stream was destroyed";
});
createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
createErrorType("ERR_UNKNOWN_ENCODING", function(a) {
  return "Unknown encoding: " + a;
}, TypeError);
createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
errorsBrowser.codes = codes;
var ERR_INVALID_OPT_VALUE = errorsBrowser.codes.ERR_INVALID_OPT_VALUE;
function highWaterMarkFrom(a, u, c) {
  return a.highWaterMark != null ? a.highWaterMark : u ? a[c] : null;
}
function getHighWaterMark(a, u, c, l) {
  var v = highWaterMarkFrom(u, l, c);
  if (v != null) {
    if (!(isFinite(v) && Math.floor(v) === v) || v < 0) {
      var p = l ? c : "highWaterMark";
      throw new ERR_INVALID_OPT_VALUE(p, v);
    }
    return Math.floor(v);
  }
  return a.objectMode ? 16 : 16 * 1024;
}
var state$3 = {
  getHighWaterMark
}, _stream_writable, hasRequired_stream_writable;
function require_stream_writable() {
  if (hasRequired_stream_writable)
    return _stream_writable;
  hasRequired_stream_writable = 1, _stream_writable = Ae;
  function a(he) {
    var ve = this;
    this.next = null, this.entry = null, this.finish = function() {
      Pe(ve, he);
    };
  }
  var u;
  Ae.WritableState = Me;
  var c = {
    deprecate: browser$c
  }, l = streamBrowser, v = require$$0$2.Buffer, p = (typeof commonjsGlobal$1 < "u" ? commonjsGlobal$1 : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function _(he) {
    return v.from(he);
  }
  function k(he) {
    return v.isBuffer(he) || he instanceof p;
  }
  var M = destroy_1, L = state$3, F = L.getHighWaterMark, V = errorsBrowser.codes, X = V.ERR_INVALID_ARG_TYPE, oe = V.ERR_METHOD_NOT_IMPLEMENTED, Y = V.ERR_MULTIPLE_CALLBACK, ae = V.ERR_STREAM_CANNOT_PIPE, ne = V.ERR_STREAM_DESTROYED, fe = V.ERR_STREAM_NULL_VALUES, ie = V.ERR_STREAM_WRITE_AFTER_END, ge = V.ERR_UNKNOWN_ENCODING, be = M.errorOrDestroy;
  inherits_browserExports(Ae, l);
  function Ce() {
  }
  function Me(he, ve, Q) {
    u = u || require_stream_duplex(), he = he || {}, typeof Q != "boolean" && (Q = ve instanceof u), this.objectMode = !!he.objectMode, Q && (this.objectMode = this.objectMode || !!he.writableObjectMode), this.highWaterMark = F(this, he, "writableHighWaterMark", Q), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var le = he.decodeStrings === !1;
    this.decodeStrings = !le, this.defaultEncoding = he.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(_e) {
      $(ve, _e);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = he.emitClose !== !1, this.autoDestroy = !!he.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new a(this);
  }
  Me.prototype.getBuffer = function() {
    for (var ve = this.bufferedRequest, Q = []; ve; )
      Q.push(ve), ve = ve.next;
    return Q;
  }, function() {
    try {
      Object.defineProperty(Me.prototype, "buffer", {
        get: c.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var Be;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (Be = Function.prototype[Symbol.hasInstance], Object.defineProperty(Ae, Symbol.hasInstance, {
    value: function(ve) {
      return Be.call(this, ve) ? !0 : this !== Ae ? !1 : ve && ve._writableState instanceof Me;
    }
  })) : Be = function(ve) {
    return ve instanceof this;
  };
  function Ae(he) {
    u = u || require_stream_duplex();
    var ve = this instanceof u;
    if (!ve && !Be.call(Ae, this))
      return new Ae(he);
    this._writableState = new Me(he, this, ve), this.writable = !0, he && (typeof he.write == "function" && (this._write = he.write), typeof he.writev == "function" && (this._writev = he.writev), typeof he.destroy == "function" && (this._destroy = he.destroy), typeof he.final == "function" && (this._final = he.final)), l.call(this);
  }
  Ae.prototype.pipe = function() {
    be(this, new ae());
  };
  function Z(he, ve) {
    var Q = new ie();
    be(he, Q), process$1.nextTick(ve, Q);
  }
  function z(he, ve, Q, le) {
    var _e;
    return Q === null ? _e = new fe() : typeof Q != "string" && !ve.objectMode && (_e = new X("chunk", ["string", "Buffer"], Q)), _e ? (be(he, _e), process$1.nextTick(le, _e), !1) : !0;
  }
  Ae.prototype.write = function(he, ve, Q) {
    var le = this._writableState, _e = !1, re = !le.objectMode && k(he);
    return re && !v.isBuffer(he) && (he = _(he)), typeof ve == "function" && (Q = ve, ve = null), re ? ve = "buffer" : ve || (ve = le.defaultEncoding), typeof Q != "function" && (Q = Ce), le.ending ? Z(this, Q) : (re || z(this, le, he, Q)) && (le.pendingcb++, _e = S(this, le, re, he, ve, Q)), _e;
  }, Ae.prototype.cork = function() {
    this._writableState.corked++;
  }, Ae.prototype.uncork = function() {
    var he = this._writableState;
    he.corked && (he.corked--, !he.writing && !he.corked && !he.bufferProcessing && he.bufferedRequest && B(this, he));
  }, Ae.prototype.setDefaultEncoding = function(ve) {
    if (typeof ve == "string" && (ve = ve.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((ve + "").toLowerCase()) > -1))
      throw new ge(ve);
    return this._writableState.defaultEncoding = ve, this;
  }, Object.defineProperty(Ae.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function P(he, ve, Q) {
    return !he.objectMode && he.decodeStrings !== !1 && typeof ve == "string" && (ve = v.from(ve, Q)), ve;
  }
  Object.defineProperty(Ae.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function S(he, ve, Q, le, _e, re) {
    if (!Q) {
      var O = P(ve, le, _e);
      le !== O && (Q = !0, _e = "buffer", le = O);
    }
    var j = ve.objectMode ? 1 : le.length;
    ve.length += j;
    var ce = ve.length < ve.highWaterMark;
    if (ce || (ve.needDrain = !0), ve.writing || ve.corked) {
      var De = ve.lastBufferedRequest;
      ve.lastBufferedRequest = {
        chunk: le,
        encoding: _e,
        isBuf: Q,
        callback: re,
        next: null
      }, De ? De.next = ve.lastBufferedRequest : ve.bufferedRequest = ve.lastBufferedRequest, ve.bufferedRequestCount += 1;
    } else
      E(he, ve, !1, j, le, _e, re);
    return ce;
  }
  function E(he, ve, Q, le, _e, re, O) {
    ve.writelen = le, ve.writecb = O, ve.writing = !0, ve.sync = !0, ve.destroyed ? ve.onwrite(new ne("write")) : Q ? he._writev(_e, ve.onwrite) : he._write(_e, re, ve.onwrite), ve.sync = !1;
  }
  function I(he, ve, Q, le, _e) {
    --ve.pendingcb, Q ? (process$1.nextTick(_e, le), process$1.nextTick(pe, he, ve), he._writableState.errorEmitted = !0, be(he, le)) : (_e(le), he._writableState.errorEmitted = !0, be(he, le), pe(he, ve));
  }
  function N(he) {
    he.writing = !1, he.writecb = null, he.length -= he.writelen, he.writelen = 0;
  }
  function $(he, ve) {
    var Q = he._writableState, le = Q.sync, _e = Q.writecb;
    if (typeof _e != "function")
      throw new Y();
    if (N(Q), ve)
      I(he, Q, le, ve, _e);
    else {
      var re = T(Q) || he.destroyed;
      !re && !Q.corked && !Q.bufferProcessing && Q.bufferedRequest && B(he, Q), le ? process$1.nextTick(U, he, Q, re, _e) : U(he, Q, re, _e);
    }
  }
  function U(he, ve, Q, le) {
    Q || H(he, ve), ve.pendingcb--, le(), pe(he, ve);
  }
  function H(he, ve) {
    ve.length === 0 && ve.needDrain && (ve.needDrain = !1, he.emit("drain"));
  }
  function B(he, ve) {
    ve.bufferProcessing = !0;
    var Q = ve.bufferedRequest;
    if (he._writev && Q && Q.next) {
      var le = ve.bufferedRequestCount, _e = new Array(le), re = ve.corkedRequestsFree;
      re.entry = Q;
      for (var O = 0, j = !0; Q; )
        _e[O] = Q, Q.isBuf || (j = !1), Q = Q.next, O += 1;
      _e.allBuffers = j, E(he, ve, !0, ve.length, _e, "", re.finish), ve.pendingcb++, ve.lastBufferedRequest = null, re.next ? (ve.corkedRequestsFree = re.next, re.next = null) : ve.corkedRequestsFree = new a(ve), ve.bufferedRequestCount = 0;
    } else {
      for (; Q; ) {
        var ce = Q.chunk, De = Q.encoding, Ne = Q.callback, Fe = ve.objectMode ? 1 : ce.length;
        if (E(he, ve, !1, Fe, ce, De, Ne), Q = Q.next, ve.bufferedRequestCount--, ve.writing)
          break;
      }
      Q === null && (ve.lastBufferedRequest = null);
    }
    ve.bufferedRequest = Q, ve.bufferProcessing = !1;
  }
  Ae.prototype._write = function(he, ve, Q) {
    Q(new oe("_write()"));
  }, Ae.prototype._writev = null, Ae.prototype.end = function(he, ve, Q) {
    var le = this._writableState;
    return typeof he == "function" ? (Q = he, he = null, ve = null) : typeof ve == "function" && (Q = ve, ve = null), he != null && this.write(he, ve), le.corked && (le.corked = 1, this.uncork()), le.ending || Ie(this, le, Q), this;
  }, Object.defineProperty(Ae.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function T(he) {
    return he.ending && he.length === 0 && he.bufferedRequest === null && !he.finished && !he.writing;
  }
  function D(he, ve) {
    he._final(function(Q) {
      ve.pendingcb--, Q && be(he, Q), ve.prefinished = !0, he.emit("prefinish"), pe(he, ve);
    });
  }
  function ee(he, ve) {
    !ve.prefinished && !ve.finalCalled && (typeof he._final == "function" && !ve.destroyed ? (ve.pendingcb++, ve.finalCalled = !0, process$1.nextTick(D, he, ve)) : (ve.prefinished = !0, he.emit("prefinish")));
  }
  function pe(he, ve) {
    var Q = T(ve);
    if (Q && (ee(he, ve), ve.pendingcb === 0 && (ve.finished = !0, he.emit("finish"), ve.autoDestroy))) {
      var le = he._readableState;
      (!le || le.autoDestroy && le.endEmitted) && he.destroy();
    }
    return Q;
  }
  function Ie(he, ve, Q) {
    ve.ending = !0, pe(he, ve), Q && (ve.finished ? process$1.nextTick(Q) : he.once("finish", Q)), ve.ended = !0, he.writable = !1;
  }
  function Pe(he, ve, Q) {
    var le = he.entry;
    for (he.entry = null; le; ) {
      var _e = le.callback;
      ve.pendingcb--, _e(Q), le = le.next;
    }
    ve.corkedRequestsFree.next = he;
  }
  return Object.defineProperty(Ae.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(ve) {
      this._writableState && (this._writableState.destroyed = ve);
    }
  }), Ae.prototype.destroy = M.destroy, Ae.prototype._undestroy = M.undestroy, Ae.prototype._destroy = function(he, ve) {
    ve(he);
  }, _stream_writable;
}
var _stream_duplex, hasRequired_stream_duplex;
function require_stream_duplex() {
  if (hasRequired_stream_duplex)
    return _stream_duplex;
  hasRequired_stream_duplex = 1;
  var a = Object.keys || function(L) {
    var F = [];
    for (var V in L)
      F.push(V);
    return F;
  };
  _stream_duplex = _;
  var u = require_stream_readable(), c = require_stream_writable();
  inherits_browserExports(_, u);
  for (var l = a(c.prototype), v = 0; v < l.length; v++) {
    var p = l[v];
    _.prototype[p] || (_.prototype[p] = c.prototype[p]);
  }
  function _(L) {
    if (!(this instanceof _))
      return new _(L);
    u.call(this, L), c.call(this, L), this.allowHalfOpen = !0, L && (L.readable === !1 && (this.readable = !1), L.writable === !1 && (this.writable = !1), L.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", k)));
  }
  Object.defineProperty(_.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(_.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(_.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function k() {
    this._writableState.ended || process$1.nextTick(M, this);
  }
  function M(L) {
    L.end();
  }
  return Object.defineProperty(_.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(F) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = F, this._writableState.destroyed = F);
    }
  }), _stream_duplex;
}
var ERR_STREAM_PREMATURE_CLOSE = errorsBrowser.codes.ERR_STREAM_PREMATURE_CLOSE;
function once$3(a) {
  var u = !1;
  return function() {
    if (!u) {
      u = !0;
      for (var c = arguments.length, l = new Array(c), v = 0; v < c; v++)
        l[v] = arguments[v];
      a.apply(this, l);
    }
  };
}
function noop$2() {
}
function isRequest$1(a) {
  return a.setHeader && typeof a.abort == "function";
}
function eos$1(a, u, c) {
  if (typeof u == "function")
    return eos$1(a, null, u);
  u || (u = {}), c = once$3(c || noop$2);
  var l = u.readable || u.readable !== !1 && a.readable, v = u.writable || u.writable !== !1 && a.writable, p = function() {
    a.writable || k();
  }, _ = a._writableState && a._writableState.finished, k = function() {
    v = !1, _ = !0, l || c.call(a);
  }, M = a._readableState && a._readableState.endEmitted, L = function() {
    l = !1, M = !0, v || c.call(a);
  }, F = function(Y) {
    c.call(a, Y);
  }, V = function() {
    var Y;
    if (l && !M)
      return (!a._readableState || !a._readableState.ended) && (Y = new ERR_STREAM_PREMATURE_CLOSE()), c.call(a, Y);
    if (v && !_)
      return (!a._writableState || !a._writableState.ended) && (Y = new ERR_STREAM_PREMATURE_CLOSE()), c.call(a, Y);
  }, X = function() {
    a.req.on("finish", k);
  };
  return isRequest$1(a) ? (a.on("complete", k), a.on("abort", V), a.req ? X() : a.on("request", X)) : v && !a._writableState && (a.on("end", p), a.on("close", p)), a.on("end", L), a.on("finish", k), u.error !== !1 && a.on("error", F), a.on("close", V), function() {
    a.removeListener("complete", k), a.removeListener("abort", V), a.removeListener("request", X), a.req && a.req.removeListener("finish", k), a.removeListener("end", p), a.removeListener("close", p), a.removeListener("finish", k), a.removeListener("end", L), a.removeListener("error", F), a.removeListener("close", V);
  };
}
var endOfStream = eos$1, async_iterator, hasRequiredAsync_iterator;
function requireAsync_iterator() {
  if (hasRequiredAsync_iterator)
    return async_iterator;
  hasRequiredAsync_iterator = 1;
  var a;
  function u(ge, be, Ce) {
    return be = c(be), be in ge ? Object.defineProperty(ge, be, { value: Ce, enumerable: !0, configurable: !0, writable: !0 }) : ge[be] = Ce, ge;
  }
  function c(ge) {
    var be = l(ge, "string");
    return typeof be == "symbol" ? be : String(be);
  }
  function l(ge, be) {
    if (typeof ge != "object" || ge === null)
      return ge;
    var Ce = ge[Symbol.toPrimitive];
    if (Ce !== void 0) {
      var Me = Ce.call(ge, be || "default");
      if (typeof Me != "object")
        return Me;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (be === "string" ? String : Number)(ge);
  }
  var v = endOfStream, p = Symbol("lastResolve"), _ = Symbol("lastReject"), k = Symbol("error"), M = Symbol("ended"), L = Symbol("lastPromise"), F = Symbol("handlePromise"), V = Symbol("stream");
  function X(ge, be) {
    return {
      value: ge,
      done: be
    };
  }
  function oe(ge) {
    var be = ge[p];
    if (be !== null) {
      var Ce = ge[V].read();
      Ce !== null && (ge[L] = null, ge[p] = null, ge[_] = null, be(X(Ce, !1)));
    }
  }
  function Y(ge) {
    process$1.nextTick(oe, ge);
  }
  function ae(ge, be) {
    return function(Ce, Me) {
      ge.then(function() {
        if (be[M]) {
          Ce(X(void 0, !0));
          return;
        }
        be[F](Ce, Me);
      }, Me);
    };
  }
  var ne = Object.getPrototypeOf(function() {
  }), fe = Object.setPrototypeOf((a = {
    get stream() {
      return this[V];
    },
    next: function() {
      var be = this, Ce = this[k];
      if (Ce !== null)
        return Promise.reject(Ce);
      if (this[M])
        return Promise.resolve(X(void 0, !0));
      if (this[V].destroyed)
        return new Promise(function(Z, z) {
          process$1.nextTick(function() {
            be[k] ? z(be[k]) : Z(X(void 0, !0));
          });
        });
      var Me = this[L], Be;
      if (Me)
        Be = new Promise(ae(Me, this));
      else {
        var Ae = this[V].read();
        if (Ae !== null)
          return Promise.resolve(X(Ae, !1));
        Be = new Promise(this[F]);
      }
      return this[L] = Be, Be;
    }
  }, u(a, Symbol.asyncIterator, function() {
    return this;
  }), u(a, "return", function() {
    var be = this;
    return new Promise(function(Ce, Me) {
      be[V].destroy(null, function(Be) {
        if (Be) {
          Me(Be);
          return;
        }
        Ce(X(void 0, !0));
      });
    });
  }), a), ne), ie = function(be) {
    var Ce, Me = Object.create(fe, (Ce = {}, u(Ce, V, {
      value: be,
      writable: !0
    }), u(Ce, p, {
      value: null,
      writable: !0
    }), u(Ce, _, {
      value: null,
      writable: !0
    }), u(Ce, k, {
      value: null,
      writable: !0
    }), u(Ce, M, {
      value: be._readableState.endEmitted,
      writable: !0
    }), u(Ce, F, {
      value: function(Ae, Z) {
        var z = Me[V].read();
        z ? (Me[L] = null, Me[p] = null, Me[_] = null, Ae(X(z, !1))) : (Me[p] = Ae, Me[_] = Z);
      },
      writable: !0
    }), Ce));
    return Me[L] = null, v(be, function(Be) {
      if (Be && Be.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var Ae = Me[_];
        Ae !== null && (Me[L] = null, Me[p] = null, Me[_] = null, Ae(Be)), Me[k] = Be;
        return;
      }
      var Z = Me[p];
      Z !== null && (Me[L] = null, Me[p] = null, Me[_] = null, Z(X(void 0, !0))), Me[M] = !0;
    }), be.on("readable", Y.bind(null, Me)), Me;
  };
  return async_iterator = ie, async_iterator;
}
var fromBrowser, hasRequiredFromBrowser;
function requireFromBrowser() {
  return hasRequiredFromBrowser || (hasRequiredFromBrowser = 1, fromBrowser = function() {
    throw new Error("Readable.from is not available in the browser");
  }), fromBrowser;
}
var _stream_readable, hasRequired_stream_readable;
function require_stream_readable() {
  if (hasRequired_stream_readable)
    return _stream_readable;
  hasRequired_stream_readable = 1, _stream_readable = Z;
  var a;
  Z.ReadableState = Ae, eventsExports.EventEmitter;
  var u = function(O, j) {
    return O.listeners(j).length;
  }, c = streamBrowser, l = require$$0$2.Buffer, v = (typeof commonjsGlobal$1 < "u" ? commonjsGlobal$1 : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function p(re) {
    return l.from(re);
  }
  function _(re) {
    return l.isBuffer(re) || re instanceof v;
  }
  var k = util$4, M;
  k && k.debuglog ? M = k.debuglog("stream") : M = function() {
  };
  var L = requireBuffer_list(), F = destroy_1, V = state$3, X = V.getHighWaterMark, oe = errorsBrowser.codes, Y = oe.ERR_INVALID_ARG_TYPE, ae = oe.ERR_STREAM_PUSH_AFTER_EOF, ne = oe.ERR_METHOD_NOT_IMPLEMENTED, fe = oe.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, ie, ge, be;
  inherits_browserExports(Z, c);
  var Ce = F.errorOrDestroy, Me = ["error", "close", "destroy", "pause", "resume"];
  function Be(re, O, j) {
    if (typeof re.prependListener == "function")
      return re.prependListener(O, j);
    !re._events || !re._events[O] ? re.on(O, j) : Array.isArray(re._events[O]) ? re._events[O].unshift(j) : re._events[O] = [j, re._events[O]];
  }
  function Ae(re, O, j) {
    a = a || require_stream_duplex(), re = re || {}, typeof j != "boolean" && (j = O instanceof a), this.objectMode = !!re.objectMode, j && (this.objectMode = this.objectMode || !!re.readableObjectMode), this.highWaterMark = X(this, re, "readableHighWaterMark", j), this.buffer = new L(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = re.emitClose !== !1, this.autoDestroy = !!re.autoDestroy, this.destroyed = !1, this.defaultEncoding = re.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, re.encoding && (ie || (ie = string_decoder.StringDecoder), this.decoder = new ie(re.encoding), this.encoding = re.encoding);
  }
  function Z(re) {
    if (a = a || require_stream_duplex(), !(this instanceof Z))
      return new Z(re);
    var O = this instanceof a;
    this._readableState = new Ae(re, this, O), this.readable = !0, re && (typeof re.read == "function" && (this._read = re.read), typeof re.destroy == "function" && (this._destroy = re.destroy)), c.call(this);
  }
  Object.defineProperty(Z.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(O) {
      this._readableState && (this._readableState.destroyed = O);
    }
  }), Z.prototype.destroy = F.destroy, Z.prototype._undestroy = F.undestroy, Z.prototype._destroy = function(re, O) {
    O(re);
  }, Z.prototype.push = function(re, O) {
    var j = this._readableState, ce;
    return j.objectMode ? ce = !0 : typeof re == "string" && (O = O || j.defaultEncoding, O !== j.encoding && (re = l.from(re, O), O = ""), ce = !0), z(this, re, O, !1, ce);
  }, Z.prototype.unshift = function(re) {
    return z(this, re, null, !0, !1);
  };
  function z(re, O, j, ce, De) {
    M("readableAddChunk", O);
    var Ne = re._readableState;
    if (O === null)
      Ne.reading = !1, $(re, Ne);
    else {
      var Fe;
      if (De || (Fe = S(Ne, O)), Fe)
        Ce(re, Fe);
      else if (Ne.objectMode || O && O.length > 0)
        if (typeof O != "string" && !Ne.objectMode && Object.getPrototypeOf(O) !== l.prototype && (O = p(O)), ce)
          Ne.endEmitted ? Ce(re, new fe()) : P(re, Ne, O, !0);
        else if (Ne.ended)
          Ce(re, new ae());
        else {
          if (Ne.destroyed)
            return !1;
          Ne.reading = !1, Ne.decoder && !j ? (O = Ne.decoder.write(O), Ne.objectMode || O.length !== 0 ? P(re, Ne, O, !1) : B(re, Ne)) : P(re, Ne, O, !1);
        }
      else
        ce || (Ne.reading = !1, B(re, Ne));
    }
    return !Ne.ended && (Ne.length < Ne.highWaterMark || Ne.length === 0);
  }
  function P(re, O, j, ce) {
    O.flowing && O.length === 0 && !O.sync ? (O.awaitDrain = 0, re.emit("data", j)) : (O.length += O.objectMode ? 1 : j.length, ce ? O.buffer.unshift(j) : O.buffer.push(j), O.needReadable && U(re)), B(re, O);
  }
  function S(re, O) {
    var j;
    return !_(O) && typeof O != "string" && O !== void 0 && !re.objectMode && (j = new Y("chunk", ["string", "Buffer", "Uint8Array"], O)), j;
  }
  Z.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, Z.prototype.setEncoding = function(re) {
    ie || (ie = string_decoder.StringDecoder);
    var O = new ie(re);
    this._readableState.decoder = O, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var j = this._readableState.buffer.head, ce = ""; j !== null; )
      ce += O.write(j.data), j = j.next;
    return this._readableState.buffer.clear(), ce !== "" && this._readableState.buffer.push(ce), this._readableState.length = ce.length, this;
  };
  var E = 1073741824;
  function I(re) {
    return re >= E ? re = E : (re--, re |= re >>> 1, re |= re >>> 2, re |= re >>> 4, re |= re >>> 8, re |= re >>> 16, re++), re;
  }
  function N(re, O) {
    return re <= 0 || O.length === 0 && O.ended ? 0 : O.objectMode ? 1 : re !== re ? O.flowing && O.length ? O.buffer.head.data.length : O.length : (re > O.highWaterMark && (O.highWaterMark = I(re)), re <= O.length ? re : O.ended ? O.length : (O.needReadable = !0, 0));
  }
  Z.prototype.read = function(re) {
    M("read", re), re = parseInt(re, 10);
    var O = this._readableState, j = re;
    if (re !== 0 && (O.emittedReadable = !1), re === 0 && O.needReadable && ((O.highWaterMark !== 0 ? O.length >= O.highWaterMark : O.length > 0) || O.ended))
      return M("read: emitReadable", O.length, O.ended), O.length === 0 && O.ended ? Q(this) : U(this), null;
    if (re = N(re, O), re === 0 && O.ended)
      return O.length === 0 && Q(this), null;
    var ce = O.needReadable;
    M("need readable", ce), (O.length === 0 || O.length - re < O.highWaterMark) && (ce = !0, M("length less than watermark", ce)), O.ended || O.reading ? (ce = !1, M("reading or ended", ce)) : ce && (M("do read"), O.reading = !0, O.sync = !0, O.length === 0 && (O.needReadable = !0), this._read(O.highWaterMark), O.sync = !1, O.reading || (re = N(j, O)));
    var De;
    return re > 0 ? De = ve(re, O) : De = null, De === null ? (O.needReadable = O.length <= O.highWaterMark, re = 0) : (O.length -= re, O.awaitDrain = 0), O.length === 0 && (O.ended || (O.needReadable = !0), j !== re && O.ended && Q(this)), De !== null && this.emit("data", De), De;
  };
  function $(re, O) {
    if (M("onEofChunk"), !O.ended) {
      if (O.decoder) {
        var j = O.decoder.end();
        j && j.length && (O.buffer.push(j), O.length += O.objectMode ? 1 : j.length);
      }
      O.ended = !0, O.sync ? U(re) : (O.needReadable = !1, O.emittedReadable || (O.emittedReadable = !0, H(re)));
    }
  }
  function U(re) {
    var O = re._readableState;
    M("emitReadable", O.needReadable, O.emittedReadable), O.needReadable = !1, O.emittedReadable || (M("emitReadable", O.flowing), O.emittedReadable = !0, process$1.nextTick(H, re));
  }
  function H(re) {
    var O = re._readableState;
    M("emitReadable_", O.destroyed, O.length, O.ended), !O.destroyed && (O.length || O.ended) && (re.emit("readable"), O.emittedReadable = !1), O.needReadable = !O.flowing && !O.ended && O.length <= O.highWaterMark, he(re);
  }
  function B(re, O) {
    O.readingMore || (O.readingMore = !0, process$1.nextTick(T, re, O));
  }
  function T(re, O) {
    for (; !O.reading && !O.ended && (O.length < O.highWaterMark || O.flowing && O.length === 0); ) {
      var j = O.length;
      if (M("maybeReadMore read 0"), re.read(0), j === O.length)
        break;
    }
    O.readingMore = !1;
  }
  Z.prototype._read = function(re) {
    Ce(this, new ne("_read()"));
  }, Z.prototype.pipe = function(re, O) {
    var j = this, ce = this._readableState;
    switch (ce.pipesCount) {
      case 0:
        ce.pipes = re;
        break;
      case 1:
        ce.pipes = [ce.pipes, re];
        break;
      default:
        ce.pipes.push(re);
        break;
    }
    ce.pipesCount += 1, M("pipe count=%d opts=%j", ce.pipesCount, O);
    var De = (!O || O.end !== !1) && re !== process$1.stdout && re !== process$1.stderr, Ne = De ? Ze : We;
    ce.endEmitted ? process$1.nextTick(Ne) : j.once("end", Ne), re.on("unpipe", Fe);
    function Fe(Re, q) {
      M("onunpipe"), Re === j && q && q.hasUnpiped === !1 && (q.hasUnpiped = !0, Xe());
    }
    function Ze() {
      M("onend"), re.end();
    }
    var qe = D(j);
    re.on("drain", qe);
    var gt = !1;
    function Xe() {
      M("cleanup"), re.removeListener("close", ye), re.removeListener("finish", we), re.removeListener("drain", qe), re.removeListener("error", J), re.removeListener("unpipe", Fe), j.removeListener("end", Ze), j.removeListener("end", We), j.removeListener("data", Ge), gt = !0, ce.awaitDrain && (!re._writableState || re._writableState.needDrain) && qe();
    }
    j.on("data", Ge);
    function Ge(Re) {
      M("ondata");
      var q = re.write(Re);
      M("dest.write", q), q === !1 && ((ce.pipesCount === 1 && ce.pipes === re || ce.pipesCount > 1 && _e(ce.pipes, re) !== -1) && !gt && (M("false write response, pause", ce.awaitDrain), ce.awaitDrain++), j.pause());
    }
    function J(Re) {
      M("onerror", Re), We(), re.removeListener("error", J), u(re, "error") === 0 && Ce(re, Re);
    }
    Be(re, "error", J);
    function ye() {
      re.removeListener("finish", we), We();
    }
    re.once("close", ye);
    function we() {
      M("onfinish"), re.removeListener("close", ye), We();
    }
    re.once("finish", we);
    function We() {
      M("unpipe"), j.unpipe(re);
    }
    return re.emit("pipe", j), ce.flowing || (M("pipe resume"), j.resume()), re;
  };
  function D(re) {
    return function() {
      var j = re._readableState;
      M("pipeOnDrain", j.awaitDrain), j.awaitDrain && j.awaitDrain--, j.awaitDrain === 0 && u(re, "data") && (j.flowing = !0, he(re));
    };
  }
  Z.prototype.unpipe = function(re) {
    var O = this._readableState, j = {
      hasUnpiped: !1
    };
    if (O.pipesCount === 0)
      return this;
    if (O.pipesCount === 1)
      return re && re !== O.pipes ? this : (re || (re = O.pipes), O.pipes = null, O.pipesCount = 0, O.flowing = !1, re && re.emit("unpipe", this, j), this);
    if (!re) {
      var ce = O.pipes, De = O.pipesCount;
      O.pipes = null, O.pipesCount = 0, O.flowing = !1;
      for (var Ne = 0; Ne < De; Ne++)
        ce[Ne].emit("unpipe", this, {
          hasUnpiped: !1
        });
      return this;
    }
    var Fe = _e(O.pipes, re);
    return Fe === -1 ? this : (O.pipes.splice(Fe, 1), O.pipesCount -= 1, O.pipesCount === 1 && (O.pipes = O.pipes[0]), re.emit("unpipe", this, j), this);
  }, Z.prototype.on = function(re, O) {
    var j = c.prototype.on.call(this, re, O), ce = this._readableState;
    return re === "data" ? (ce.readableListening = this.listenerCount("readable") > 0, ce.flowing !== !1 && this.resume()) : re === "readable" && !ce.endEmitted && !ce.readableListening && (ce.readableListening = ce.needReadable = !0, ce.flowing = !1, ce.emittedReadable = !1, M("on readable", ce.length, ce.reading), ce.length ? U(this) : ce.reading || process$1.nextTick(pe, this)), j;
  }, Z.prototype.addListener = Z.prototype.on, Z.prototype.removeListener = function(re, O) {
    var j = c.prototype.removeListener.call(this, re, O);
    return re === "readable" && process$1.nextTick(ee, this), j;
  }, Z.prototype.removeAllListeners = function(re) {
    var O = c.prototype.removeAllListeners.apply(this, arguments);
    return (re === "readable" || re === void 0) && process$1.nextTick(ee, this), O;
  };
  function ee(re) {
    var O = re._readableState;
    O.readableListening = re.listenerCount("readable") > 0, O.resumeScheduled && !O.paused ? O.flowing = !0 : re.listenerCount("data") > 0 && re.resume();
  }
  function pe(re) {
    M("readable nexttick read 0"), re.read(0);
  }
  Z.prototype.resume = function() {
    var re = this._readableState;
    return re.flowing || (M("resume"), re.flowing = !re.readableListening, Ie(this, re)), re.paused = !1, this;
  };
  function Ie(re, O) {
    O.resumeScheduled || (O.resumeScheduled = !0, process$1.nextTick(Pe, re, O));
  }
  function Pe(re, O) {
    M("resume", O.reading), O.reading || re.read(0), O.resumeScheduled = !1, re.emit("resume"), he(re), O.flowing && !O.reading && re.read(0);
  }
  Z.prototype.pause = function() {
    return M("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (M("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function he(re) {
    var O = re._readableState;
    for (M("flow", O.flowing); O.flowing && re.read() !== null; )
      ;
  }
  Z.prototype.wrap = function(re) {
    var O = this, j = this._readableState, ce = !1;
    re.on("end", function() {
      if (M("wrapped end"), j.decoder && !j.ended) {
        var Fe = j.decoder.end();
        Fe && Fe.length && O.push(Fe);
      }
      O.push(null);
    }), re.on("data", function(Fe) {
      if (M("wrapped data"), j.decoder && (Fe = j.decoder.write(Fe)), !(j.objectMode && Fe == null) && !(!j.objectMode && (!Fe || !Fe.length))) {
        var Ze = O.push(Fe);
        Ze || (ce = !0, re.pause());
      }
    });
    for (var De in re)
      this[De] === void 0 && typeof re[De] == "function" && (this[De] = /* @__PURE__ */ function(Ze) {
        return function() {
          return re[Ze].apply(re, arguments);
        };
      }(De));
    for (var Ne = 0; Ne < Me.length; Ne++)
      re.on(Me[Ne], this.emit.bind(this, Me[Ne]));
    return this._read = function(Fe) {
      M("wrapped _read", Fe), ce && (ce = !1, re.resume());
    }, this;
  }, typeof Symbol == "function" && (Z.prototype[Symbol.asyncIterator] = function() {
    return ge === void 0 && (ge = requireAsync_iterator()), ge(this);
  }), Object.defineProperty(Z.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(Z.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(Z.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(O) {
      this._readableState && (this._readableState.flowing = O);
    }
  }), Z._fromList = ve, Object.defineProperty(Z.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function ve(re, O) {
    if (O.length === 0)
      return null;
    var j;
    return O.objectMode ? j = O.buffer.shift() : !re || re >= O.length ? (O.decoder ? j = O.buffer.join("") : O.buffer.length === 1 ? j = O.buffer.first() : j = O.buffer.concat(O.length), O.buffer.clear()) : j = O.buffer.consume(re, O.decoder), j;
  }
  function Q(re) {
    var O = re._readableState;
    M("endReadable", O.endEmitted), O.endEmitted || (O.ended = !0, process$1.nextTick(le, O, re));
  }
  function le(re, O) {
    if (M("endReadableNT", re.endEmitted, re.length), !re.endEmitted && re.length === 0 && (re.endEmitted = !0, O.readable = !1, O.emit("end"), re.autoDestroy)) {
      var j = O._writableState;
      (!j || j.autoDestroy && j.finished) && O.destroy();
    }
  }
  typeof Symbol == "function" && (Z.from = function(re, O) {
    return be === void 0 && (be = requireFromBrowser()), be(Z, re, O);
  });
  function _e(re, O) {
    for (var j = 0, ce = re.length; j < ce; j++)
      if (re[j] === O)
        return j;
    return -1;
  }
  return _stream_readable;
}
var _stream_transform = Transform$1, _require$codes$1 = errorsBrowser.codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes$1.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes$1.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes$1.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes$1.ERR_TRANSFORM_WITH_LENGTH_0, Duplex = require_stream_duplex();
inherits_browserExports(Transform$1, Duplex);
function afterTransform(a, u) {
  var c = this._transformState;
  c.transforming = !1;
  var l = c.writecb;
  if (l === null)
    return this.emit("error", new ERR_MULTIPLE_CALLBACK());
  c.writechunk = null, c.writecb = null, u != null && this.push(u), l(a);
  var v = this._readableState;
  v.reading = !1, (v.needReadable || v.length < v.highWaterMark) && this._read(v.highWaterMark);
}
function Transform$1(a) {
  if (!(this instanceof Transform$1))
    return new Transform$1(a);
  Duplex.call(this, a), this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: !1,
    transforming: !1,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }, this._readableState.needReadable = !0, this._readableState.sync = !1, a && (typeof a.transform == "function" && (this._transform = a.transform), typeof a.flush == "function" && (this._flush = a.flush)), this.on("prefinish", prefinish);
}
function prefinish() {
  var a = this;
  typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(u, c) {
    done(a, u, c);
  }) : done(this, null, null);
}
Transform$1.prototype.push = function(a, u) {
  return this._transformState.needTransform = !1, Duplex.prototype.push.call(this, a, u);
};
Transform$1.prototype._transform = function(a, u, c) {
  c(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
};
Transform$1.prototype._write = function(a, u, c) {
  var l = this._transformState;
  if (l.writecb = c, l.writechunk = a, l.writeencoding = u, !l.transforming) {
    var v = this._readableState;
    (l.needTransform || v.needReadable || v.length < v.highWaterMark) && this._read(v.highWaterMark);
  }
};
Transform$1.prototype._read = function(a) {
  var u = this._transformState;
  u.writechunk !== null && !u.transforming ? (u.transforming = !0, this._transform(u.writechunk, u.writeencoding, u.afterTransform)) : u.needTransform = !0;
};
Transform$1.prototype._destroy = function(a, u) {
  Duplex.prototype._destroy.call(this, a, function(c) {
    u(c);
  });
};
function done(a, u, c) {
  if (u)
    return a.emit("error", u);
  if (c != null && a.push(c), a._writableState.length)
    throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (a._transformState.transforming)
    throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return a.push(null);
}
var _stream_passthrough = PassThrough, Transform = _stream_transform;
inherits_browserExports(PassThrough, Transform);
function PassThrough(a) {
  if (!(this instanceof PassThrough))
    return new PassThrough(a);
  Transform.call(this, a);
}
PassThrough.prototype._transform = function(a, u, c) {
  c(null, a);
};
var eos;
function once$2(a) {
  var u = !1;
  return function() {
    u || (u = !0, a.apply(void 0, arguments));
  };
}
var _require$codes = errorsBrowser.codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
function noop$1(a) {
  if (a)
    throw a;
}
function isRequest(a) {
  return a.setHeader && typeof a.abort == "function";
}
function destroyer(a, u, c, l) {
  l = once$2(l);
  var v = !1;
  a.on("close", function() {
    v = !0;
  }), eos === void 0 && (eos = endOfStream), eos(a, {
    readable: u,
    writable: c
  }, function(_) {
    if (_)
      return l(_);
    v = !0, l();
  });
  var p = !1;
  return function(_) {
    if (!v && !p) {
      if (p = !0, isRequest(a))
        return a.abort();
      if (typeof a.destroy == "function")
        return a.destroy();
      l(_ || new ERR_STREAM_DESTROYED("pipe"));
    }
  };
}
function call(a) {
  a();
}
function pipe(a, u) {
  return a.pipe(u);
}
function popCallback(a) {
  return !a.length || typeof a[a.length - 1] != "function" ? noop$1 : a.pop();
}
function pipeline() {
  for (var a = arguments.length, u = new Array(a), c = 0; c < a; c++)
    u[c] = arguments[c];
  var l = popCallback(u);
  if (Array.isArray(u[0]) && (u = u[0]), u.length < 2)
    throw new ERR_MISSING_ARGS("streams");
  var v, p = u.map(function(_, k) {
    var M = k < u.length - 1, L = k > 0;
    return destroyer(_, M, L, function(F) {
      v || (v = F), F && p.forEach(call), !M && (p.forEach(call), l(v));
    });
  });
  return u.reduce(pipe);
}
var pipeline_1 = pipeline;
(function(a, u) {
  u = a.exports = require_stream_readable(), u.Stream = u, u.Readable = u, u.Writable = require_stream_writable(), u.Duplex = require_stream_duplex(), u.Transform = _stream_transform, u.PassThrough = _stream_passthrough, u.finished = endOfStream, u.pipeline = pipeline_1;
})(readableBrowser, readableBrowser.exports);
var readableBrowserExports = readableBrowser.exports, sign$1 = { exports: {} }, bn$4 = { exports: {} };
bn$4.exports;
(function(a) {
  (function(u, c) {
    function l(E, I) {
      if (!E)
        throw new Error(I || "Assertion failed");
    }
    function v(E, I) {
      E.super_ = I;
      var N = function() {
      };
      N.prototype = I.prototype, E.prototype = new N(), E.prototype.constructor = E;
    }
    function p(E, I, N) {
      if (p.isBN(E))
        return E;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, E !== null && ((I === "le" || I === "be") && (N = I, I = 10), this._init(E || 0, I || 10, N || "be"));
    }
    typeof u == "object" ? u.exports = p : c.BN = p, p.BN = p, p.wordSize = 26;
    var _;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? _ = window.Buffer : _ = require$$0$2.Buffer;
    } catch {
    }
    p.isBN = function(I) {
      return I instanceof p ? !0 : I !== null && typeof I == "object" && I.constructor.wordSize === p.wordSize && Array.isArray(I.words);
    }, p.max = function(I, N) {
      return I.cmp(N) > 0 ? I : N;
    }, p.min = function(I, N) {
      return I.cmp(N) < 0 ? I : N;
    }, p.prototype._init = function(I, N, $) {
      if (typeof I == "number")
        return this._initNumber(I, N, $);
      if (typeof I == "object")
        return this._initArray(I, N, $);
      N === "hex" && (N = 16), l(N === (N | 0) && N >= 2 && N <= 36), I = I.toString().replace(/\s+/g, "");
      var U = 0;
      I[0] === "-" && (U++, this.negative = 1), U < I.length && (N === 16 ? this._parseHex(I, U, $) : (this._parseBase(I, N, U), $ === "le" && this._initArray(this.toArray(), N, $)));
    }, p.prototype._initNumber = function(I, N, $) {
      I < 0 && (this.negative = 1, I = -I), I < 67108864 ? (this.words = [I & 67108863], this.length = 1) : I < 4503599627370496 ? (this.words = [
        I & 67108863,
        I / 67108864 & 67108863
      ], this.length = 2) : (l(I < 9007199254740992), this.words = [
        I & 67108863,
        I / 67108864 & 67108863,
        1
      ], this.length = 3), $ === "le" && this._initArray(this.toArray(), N, $);
    }, p.prototype._initArray = function(I, N, $) {
      if (l(typeof I.length == "number"), I.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(I.length / 3), this.words = new Array(this.length);
      for (var U = 0; U < this.length; U++)
        this.words[U] = 0;
      var H, B, T = 0;
      if ($ === "be")
        for (U = I.length - 1, H = 0; U >= 0; U -= 3)
          B = I[U] | I[U - 1] << 8 | I[U - 2] << 16, this.words[H] |= B << T & 67108863, this.words[H + 1] = B >>> 26 - T & 67108863, T += 24, T >= 26 && (T -= 26, H++);
      else if ($ === "le")
        for (U = 0, H = 0; U < I.length; U += 3)
          B = I[U] | I[U + 1] << 8 | I[U + 2] << 16, this.words[H] |= B << T & 67108863, this.words[H + 1] = B >>> 26 - T & 67108863, T += 24, T >= 26 && (T -= 26, H++);
      return this._strip();
    };
    function k(E, I) {
      var N = E.charCodeAt(I);
      if (N >= 48 && N <= 57)
        return N - 48;
      if (N >= 65 && N <= 70)
        return N - 55;
      if (N >= 97 && N <= 102)
        return N - 87;
      l(!1, "Invalid character in " + E);
    }
    function M(E, I, N) {
      var $ = k(E, N);
      return N - 1 >= I && ($ |= k(E, N - 1) << 4), $;
    }
    p.prototype._parseHex = function(I, N, $) {
      this.length = Math.ceil((I.length - N) / 6), this.words = new Array(this.length);
      for (var U = 0; U < this.length; U++)
        this.words[U] = 0;
      var H = 0, B = 0, T;
      if ($ === "be")
        for (U = I.length - 1; U >= N; U -= 2)
          T = M(I, N, U) << H, this.words[B] |= T & 67108863, H >= 18 ? (H -= 18, B += 1, this.words[B] |= T >>> 26) : H += 8;
      else {
        var D = I.length - N;
        for (U = D % 2 === 0 ? N + 1 : N; U < I.length; U += 2)
          T = M(I, N, U) << H, this.words[B] |= T & 67108863, H >= 18 ? (H -= 18, B += 1, this.words[B] |= T >>> 26) : H += 8;
      }
      this._strip();
    };
    function L(E, I, N, $) {
      for (var U = 0, H = 0, B = Math.min(E.length, N), T = I; T < B; T++) {
        var D = E.charCodeAt(T) - 48;
        U *= $, D >= 49 ? H = D - 49 + 10 : D >= 17 ? H = D - 17 + 10 : H = D, l(D >= 0 && H < $, "Invalid character"), U += H;
      }
      return U;
    }
    p.prototype._parseBase = function(I, N, $) {
      this.words = [0], this.length = 1;
      for (var U = 0, H = 1; H <= 67108863; H *= N)
        U++;
      U--, H = H / N | 0;
      for (var B = I.length - $, T = B % U, D = Math.min(B, B - T) + $, ee = 0, pe = $; pe < D; pe += U)
        ee = L(I, pe, pe + U, N), this.imuln(H), this.words[0] + ee < 67108864 ? this.words[0] += ee : this._iaddn(ee);
      if (T !== 0) {
        var Ie = 1;
        for (ee = L(I, pe, I.length, N), pe = 0; pe < T; pe++)
          Ie *= N;
        this.imuln(Ie), this.words[0] + ee < 67108864 ? this.words[0] += ee : this._iaddn(ee);
      }
      this._strip();
    }, p.prototype.copy = function(I) {
      I.words = new Array(this.length);
      for (var N = 0; N < this.length; N++)
        I.words[N] = this.words[N];
      I.length = this.length, I.negative = this.negative, I.red = this.red;
    };
    function F(E, I) {
      E.words = I.words, E.length = I.length, E.negative = I.negative, E.red = I.red;
    }
    if (p.prototype._move = function(I) {
      F(I, this);
    }, p.prototype.clone = function() {
      var I = new p(null);
      return this.copy(I), I;
    }, p.prototype._expand = function(I) {
      for (; this.length < I; )
        this.words[this.length++] = 0;
      return this;
    }, p.prototype._strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, p.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol < "u" && typeof Symbol.for == "function")
      try {
        p.prototype[Symbol.for("nodejs.util.inspect.custom")] = V;
      } catch {
        p.prototype.inspect = V;
      }
    else
      p.prototype.inspect = V;
    function V() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var X = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], oe = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], Y = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    p.prototype.toString = function(I, N) {
      I = I || 10, N = N | 0 || 1;
      var $;
      if (I === 16 || I === "hex") {
        $ = "";
        for (var U = 0, H = 0, B = 0; B < this.length; B++) {
          var T = this.words[B], D = ((T << U | H) & 16777215).toString(16);
          H = T >>> 24 - U & 16777215, U += 2, U >= 26 && (U -= 26, B--), H !== 0 || B !== this.length - 1 ? $ = X[6 - D.length] + D + $ : $ = D + $;
        }
        for (H !== 0 && ($ = H.toString(16) + $); $.length % N !== 0; )
          $ = "0" + $;
        return this.negative !== 0 && ($ = "-" + $), $;
      }
      if (I === (I | 0) && I >= 2 && I <= 36) {
        var ee = oe[I], pe = Y[I];
        $ = "";
        var Ie = this.clone();
        for (Ie.negative = 0; !Ie.isZero(); ) {
          var Pe = Ie.modrn(pe).toString(I);
          Ie = Ie.idivn(pe), Ie.isZero() ? $ = Pe + $ : $ = X[ee - Pe.length] + Pe + $;
        }
        for (this.isZero() && ($ = "0" + $); $.length % N !== 0; )
          $ = "0" + $;
        return this.negative !== 0 && ($ = "-" + $), $;
      }
      l(!1, "Base should be between 2 and 36");
    }, p.prototype.toNumber = function() {
      var I = this.words[0];
      return this.length === 2 ? I += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? I += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && l(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -I : I;
    }, p.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, _ && (p.prototype.toBuffer = function(I, N) {
      return this.toArrayLike(_, I, N);
    }), p.prototype.toArray = function(I, N) {
      return this.toArrayLike(Array, I, N);
    };
    var ae = function(I, N) {
      return I.allocUnsafe ? I.allocUnsafe(N) : new I(N);
    };
    p.prototype.toArrayLike = function(I, N, $) {
      this._strip();
      var U = this.byteLength(), H = $ || Math.max(1, U);
      l(U <= H, "byte array longer than desired length"), l(H > 0, "Requested array length <= 0");
      var B = ae(I, H), T = N === "le" ? "LE" : "BE";
      return this["_toArrayLike" + T](B, U), B;
    }, p.prototype._toArrayLikeLE = function(I, N) {
      for (var $ = 0, U = 0, H = 0, B = 0; H < this.length; H++) {
        var T = this.words[H] << B | U;
        I[$++] = T & 255, $ < I.length && (I[$++] = T >> 8 & 255), $ < I.length && (I[$++] = T >> 16 & 255), B === 6 ? ($ < I.length && (I[$++] = T >> 24 & 255), U = 0, B = 0) : (U = T >>> 24, B += 2);
      }
      if ($ < I.length)
        for (I[$++] = U; $ < I.length; )
          I[$++] = 0;
    }, p.prototype._toArrayLikeBE = function(I, N) {
      for (var $ = I.length - 1, U = 0, H = 0, B = 0; H < this.length; H++) {
        var T = this.words[H] << B | U;
        I[$--] = T & 255, $ >= 0 && (I[$--] = T >> 8 & 255), $ >= 0 && (I[$--] = T >> 16 & 255), B === 6 ? ($ >= 0 && (I[$--] = T >> 24 & 255), U = 0, B = 0) : (U = T >>> 24, B += 2);
      }
      if ($ >= 0)
        for (I[$--] = U; $ >= 0; )
          I[$--] = 0;
    }, Math.clz32 ? p.prototype._countBits = function(I) {
      return 32 - Math.clz32(I);
    } : p.prototype._countBits = function(I) {
      var N = I, $ = 0;
      return N >= 4096 && ($ += 13, N >>>= 13), N >= 64 && ($ += 7, N >>>= 7), N >= 8 && ($ += 4, N >>>= 4), N >= 2 && ($ += 2, N >>>= 2), $ + N;
    }, p.prototype._zeroBits = function(I) {
      if (I === 0)
        return 26;
      var N = I, $ = 0;
      return N & 8191 || ($ += 13, N >>>= 13), N & 127 || ($ += 7, N >>>= 7), N & 15 || ($ += 4, N >>>= 4), N & 3 || ($ += 2, N >>>= 2), N & 1 || $++, $;
    }, p.prototype.bitLength = function() {
      var I = this.words[this.length - 1], N = this._countBits(I);
      return (this.length - 1) * 26 + N;
    };
    function ne(E) {
      for (var I = new Array(E.bitLength()), N = 0; N < I.length; N++) {
        var $ = N / 26 | 0, U = N % 26;
        I[N] = E.words[$] >>> U & 1;
      }
      return I;
    }
    p.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var I = 0, N = 0; N < this.length; N++) {
        var $ = this._zeroBits(this.words[N]);
        if (I += $, $ !== 26)
          break;
      }
      return I;
    }, p.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, p.prototype.toTwos = function(I) {
      return this.negative !== 0 ? this.abs().inotn(I).iaddn(1) : this.clone();
    }, p.prototype.fromTwos = function(I) {
      return this.testn(I - 1) ? this.notn(I).iaddn(1).ineg() : this.clone();
    }, p.prototype.isNeg = function() {
      return this.negative !== 0;
    }, p.prototype.neg = function() {
      return this.clone().ineg();
    }, p.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, p.prototype.iuor = function(I) {
      for (; this.length < I.length; )
        this.words[this.length++] = 0;
      for (var N = 0; N < I.length; N++)
        this.words[N] = this.words[N] | I.words[N];
      return this._strip();
    }, p.prototype.ior = function(I) {
      return l((this.negative | I.negative) === 0), this.iuor(I);
    }, p.prototype.or = function(I) {
      return this.length > I.length ? this.clone().ior(I) : I.clone().ior(this);
    }, p.prototype.uor = function(I) {
      return this.length > I.length ? this.clone().iuor(I) : I.clone().iuor(this);
    }, p.prototype.iuand = function(I) {
      var N;
      this.length > I.length ? N = I : N = this;
      for (var $ = 0; $ < N.length; $++)
        this.words[$] = this.words[$] & I.words[$];
      return this.length = N.length, this._strip();
    }, p.prototype.iand = function(I) {
      return l((this.negative | I.negative) === 0), this.iuand(I);
    }, p.prototype.and = function(I) {
      return this.length > I.length ? this.clone().iand(I) : I.clone().iand(this);
    }, p.prototype.uand = function(I) {
      return this.length > I.length ? this.clone().iuand(I) : I.clone().iuand(this);
    }, p.prototype.iuxor = function(I) {
      var N, $;
      this.length > I.length ? (N = this, $ = I) : (N = I, $ = this);
      for (var U = 0; U < $.length; U++)
        this.words[U] = N.words[U] ^ $.words[U];
      if (this !== N)
        for (; U < N.length; U++)
          this.words[U] = N.words[U];
      return this.length = N.length, this._strip();
    }, p.prototype.ixor = function(I) {
      return l((this.negative | I.negative) === 0), this.iuxor(I);
    }, p.prototype.xor = function(I) {
      return this.length > I.length ? this.clone().ixor(I) : I.clone().ixor(this);
    }, p.prototype.uxor = function(I) {
      return this.length > I.length ? this.clone().iuxor(I) : I.clone().iuxor(this);
    }, p.prototype.inotn = function(I) {
      l(typeof I == "number" && I >= 0);
      var N = Math.ceil(I / 26) | 0, $ = I % 26;
      this._expand(N), $ > 0 && N--;
      for (var U = 0; U < N; U++)
        this.words[U] = ~this.words[U] & 67108863;
      return $ > 0 && (this.words[U] = ~this.words[U] & 67108863 >> 26 - $), this._strip();
    }, p.prototype.notn = function(I) {
      return this.clone().inotn(I);
    }, p.prototype.setn = function(I, N) {
      l(typeof I == "number" && I >= 0);
      var $ = I / 26 | 0, U = I % 26;
      return this._expand($ + 1), N ? this.words[$] = this.words[$] | 1 << U : this.words[$] = this.words[$] & ~(1 << U), this._strip();
    }, p.prototype.iadd = function(I) {
      var N;
      if (this.negative !== 0 && I.negative === 0)
        return this.negative = 0, N = this.isub(I), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && I.negative !== 0)
        return I.negative = 0, N = this.isub(I), I.negative = 1, N._normSign();
      var $, U;
      this.length > I.length ? ($ = this, U = I) : ($ = I, U = this);
      for (var H = 0, B = 0; B < U.length; B++)
        N = ($.words[B] | 0) + (U.words[B] | 0) + H, this.words[B] = N & 67108863, H = N >>> 26;
      for (; H !== 0 && B < $.length; B++)
        N = ($.words[B] | 0) + H, this.words[B] = N & 67108863, H = N >>> 26;
      if (this.length = $.length, H !== 0)
        this.words[this.length] = H, this.length++;
      else if ($ !== this)
        for (; B < $.length; B++)
          this.words[B] = $.words[B];
      return this;
    }, p.prototype.add = function(I) {
      var N;
      return I.negative !== 0 && this.negative === 0 ? (I.negative = 0, N = this.sub(I), I.negative ^= 1, N) : I.negative === 0 && this.negative !== 0 ? (this.negative = 0, N = I.sub(this), this.negative = 1, N) : this.length > I.length ? this.clone().iadd(I) : I.clone().iadd(this);
    }, p.prototype.isub = function(I) {
      if (I.negative !== 0) {
        I.negative = 0;
        var N = this.iadd(I);
        return I.negative = 1, N._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(I), this.negative = 1, this._normSign();
      var $ = this.cmp(I);
      if ($ === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var U, H;
      $ > 0 ? (U = this, H = I) : (U = I, H = this);
      for (var B = 0, T = 0; T < H.length; T++)
        N = (U.words[T] | 0) - (H.words[T] | 0) + B, B = N >> 26, this.words[T] = N & 67108863;
      for (; B !== 0 && T < U.length; T++)
        N = (U.words[T] | 0) + B, B = N >> 26, this.words[T] = N & 67108863;
      if (B === 0 && T < U.length && U !== this)
        for (; T < U.length; T++)
          this.words[T] = U.words[T];
      return this.length = Math.max(this.length, T), U !== this && (this.negative = 1), this._strip();
    }, p.prototype.sub = function(I) {
      return this.clone().isub(I);
    };
    function fe(E, I, N) {
      N.negative = I.negative ^ E.negative;
      var $ = E.length + I.length | 0;
      N.length = $, $ = $ - 1 | 0;
      var U = E.words[0] | 0, H = I.words[0] | 0, B = U * H, T = B & 67108863, D = B / 67108864 | 0;
      N.words[0] = T;
      for (var ee = 1; ee < $; ee++) {
        for (var pe = D >>> 26, Ie = D & 67108863, Pe = Math.min(ee, I.length - 1), he = Math.max(0, ee - E.length + 1); he <= Pe; he++) {
          var ve = ee - he | 0;
          U = E.words[ve] | 0, H = I.words[he] | 0, B = U * H + Ie, pe += B / 67108864 | 0, Ie = B & 67108863;
        }
        N.words[ee] = Ie | 0, D = pe | 0;
      }
      return D !== 0 ? N.words[ee] = D | 0 : N.length--, N._strip();
    }
    var ie = function(I, N, $) {
      var U = I.words, H = N.words, B = $.words, T = 0, D, ee, pe, Ie = U[0] | 0, Pe = Ie & 8191, he = Ie >>> 13, ve = U[1] | 0, Q = ve & 8191, le = ve >>> 13, _e = U[2] | 0, re = _e & 8191, O = _e >>> 13, j = U[3] | 0, ce = j & 8191, De = j >>> 13, Ne = U[4] | 0, Fe = Ne & 8191, Ze = Ne >>> 13, qe = U[5] | 0, gt = qe & 8191, Xe = qe >>> 13, Ge = U[6] | 0, J = Ge & 8191, ye = Ge >>> 13, we = U[7] | 0, We = we & 8191, Re = we >>> 13, q = U[8] | 0, ke = q & 8191, de = q >>> 13, ue = U[9] | 0, me = ue & 8191, Oe = ue >>> 13, Ue = H[0] | 0, ze = Ue & 8191, Ve = Ue >>> 13, Qe = H[1] | 0, Ke = Qe & 8191, x = Qe >>> 13, se = H[2] | 0, Ee = se & 8191, xe = se >>> 13, $e = H[3] | 0, Ye = $e & 8191, et = $e >>> 13, dt = H[4] | 0, St = dt & 8191, tt = dt >>> 13, at = H[5] | 0, wt = at & 8191, rt = at >>> 13, ut = H[6] | 0, kt = ut & 8191, nt = ut >>> 13, it = H[7] | 0, bt = it & 8191, ot = it >>> 13, ct = H[8] | 0, Ot = ct & 8191, st = ct >>> 13, lt = H[9] | 0, Rt = lt & 8191, Ct = lt >>> 13;
      $.negative = I.negative ^ N.negative, $.length = 19, D = Math.imul(Pe, ze), ee = Math.imul(Pe, Ve), ee = ee + Math.imul(he, ze) | 0, pe = Math.imul(he, Ve);
      var Je = (T + D | 0) + ((ee & 8191) << 13) | 0;
      T = (pe + (ee >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, D = Math.imul(Q, ze), ee = Math.imul(Q, Ve), ee = ee + Math.imul(le, ze) | 0, pe = Math.imul(le, Ve), D = D + Math.imul(Pe, Ke) | 0, ee = ee + Math.imul(Pe, x) | 0, ee = ee + Math.imul(he, Ke) | 0, pe = pe + Math.imul(he, x) | 0;
      var He = (T + D | 0) + ((ee & 8191) << 13) | 0;
      T = (pe + (ee >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, D = Math.imul(re, ze), ee = Math.imul(re, Ve), ee = ee + Math.imul(O, ze) | 0, pe = Math.imul(O, Ve), D = D + Math.imul(Q, Ke) | 0, ee = ee + Math.imul(Q, x) | 0, ee = ee + Math.imul(le, Ke) | 0, pe = pe + Math.imul(le, x) | 0, D = D + Math.imul(Pe, Ee) | 0, ee = ee + Math.imul(Pe, xe) | 0, ee = ee + Math.imul(he, Ee) | 0, pe = pe + Math.imul(he, xe) | 0;
      var je = (T + D | 0) + ((ee & 8191) << 13) | 0;
      T = (pe + (ee >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, D = Math.imul(ce, ze), ee = Math.imul(ce, Ve), ee = ee + Math.imul(De, ze) | 0, pe = Math.imul(De, Ve), D = D + Math.imul(re, Ke) | 0, ee = ee + Math.imul(re, x) | 0, ee = ee + Math.imul(O, Ke) | 0, pe = pe + Math.imul(O, x) | 0, D = D + Math.imul(Q, Ee) | 0, ee = ee + Math.imul(Q, xe) | 0, ee = ee + Math.imul(le, Ee) | 0, pe = pe + Math.imul(le, xe) | 0, D = D + Math.imul(Pe, Ye) | 0, ee = ee + Math.imul(Pe, et) | 0, ee = ee + Math.imul(he, Ye) | 0, pe = pe + Math.imul(he, et) | 0;
      var pt = (T + D | 0) + ((ee & 8191) << 13) | 0;
      T = (pe + (ee >>> 13) | 0) + (pt >>> 26) | 0, pt &= 67108863, D = Math.imul(Fe, ze), ee = Math.imul(Fe, Ve), ee = ee + Math.imul(Ze, ze) | 0, pe = Math.imul(Ze, Ve), D = D + Math.imul(ce, Ke) | 0, ee = ee + Math.imul(ce, x) | 0, ee = ee + Math.imul(De, Ke) | 0, pe = pe + Math.imul(De, x) | 0, D = D + Math.imul(re, Ee) | 0, ee = ee + Math.imul(re, xe) | 0, ee = ee + Math.imul(O, Ee) | 0, pe = pe + Math.imul(O, xe) | 0, D = D + Math.imul(Q, Ye) | 0, ee = ee + Math.imul(Q, et) | 0, ee = ee + Math.imul(le, Ye) | 0, pe = pe + Math.imul(le, et) | 0, D = D + Math.imul(Pe, St) | 0, ee = ee + Math.imul(Pe, tt) | 0, ee = ee + Math.imul(he, St) | 0, pe = pe + Math.imul(he, tt) | 0;
      var mt = (T + D | 0) + ((ee & 8191) << 13) | 0;
      T = (pe + (ee >>> 13) | 0) + (mt >>> 26) | 0, mt &= 67108863, D = Math.imul(gt, ze), ee = Math.imul(gt, Ve), ee = ee + Math.imul(Xe, ze) | 0, pe = Math.imul(Xe, Ve), D = D + Math.imul(Fe, Ke) | 0, ee = ee + Math.imul(Fe, x) | 0, ee = ee + Math.imul(Ze, Ke) | 0, pe = pe + Math.imul(Ze, x) | 0, D = D + Math.imul(ce, Ee) | 0, ee = ee + Math.imul(ce, xe) | 0, ee = ee + Math.imul(De, Ee) | 0, pe = pe + Math.imul(De, xe) | 0, D = D + Math.imul(re, Ye) | 0, ee = ee + Math.imul(re, et) | 0, ee = ee + Math.imul(O, Ye) | 0, pe = pe + Math.imul(O, et) | 0, D = D + Math.imul(Q, St) | 0, ee = ee + Math.imul(Q, tt) | 0, ee = ee + Math.imul(le, St) | 0, pe = pe + Math.imul(le, tt) | 0, D = D + Math.imul(Pe, wt) | 0, ee = ee + Math.imul(Pe, rt) | 0, ee = ee + Math.imul(he, wt) | 0, pe = pe + Math.imul(he, rt) | 0;
      var yt = (T + D | 0) + ((ee & 8191) << 13) | 0;
      T = (pe + (ee >>> 13) | 0) + (yt >>> 26) | 0, yt &= 67108863, D = Math.imul(J, ze), ee = Math.imul(J, Ve), ee = ee + Math.imul(ye, ze) | 0, pe = Math.imul(ye, Ve), D = D + Math.imul(gt, Ke) | 0, ee = ee + Math.imul(gt, x) | 0, ee = ee + Math.imul(Xe, Ke) | 0, pe = pe + Math.imul(Xe, x) | 0, D = D + Math.imul(Fe, Ee) | 0, ee = ee + Math.imul(Fe, xe) | 0, ee = ee + Math.imul(Ze, Ee) | 0, pe = pe + Math.imul(Ze, xe) | 0, D = D + Math.imul(ce, Ye) | 0, ee = ee + Math.imul(ce, et) | 0, ee = ee + Math.imul(De, Ye) | 0, pe = pe + Math.imul(De, et) | 0, D = D + Math.imul(re, St) | 0, ee = ee + Math.imul(re, tt) | 0, ee = ee + Math.imul(O, St) | 0, pe = pe + Math.imul(O, tt) | 0, D = D + Math.imul(Q, wt) | 0, ee = ee + Math.imul(Q, rt) | 0, ee = ee + Math.imul(le, wt) | 0, pe = pe + Math.imul(le, rt) | 0, D = D + Math.imul(Pe, kt) | 0, ee = ee + Math.imul(Pe, nt) | 0, ee = ee + Math.imul(he, kt) | 0, pe = pe + Math.imul(he, nt) | 0;
      var ht = (T + D | 0) + ((ee & 8191) << 13) | 0;
      T = (pe + (ee >>> 13) | 0) + (ht >>> 26) | 0, ht &= 67108863, D = Math.imul(We, ze), ee = Math.imul(We, Ve), ee = ee + Math.imul(Re, ze) | 0, pe = Math.imul(Re, Ve), D = D + Math.imul(J, Ke) | 0, ee = ee + Math.imul(J, x) | 0, ee = ee + Math.imul(ye, Ke) | 0, pe = pe + Math.imul(ye, x) | 0, D = D + Math.imul(gt, Ee) | 0, ee = ee + Math.imul(gt, xe) | 0, ee = ee + Math.imul(Xe, Ee) | 0, pe = pe + Math.imul(Xe, xe) | 0, D = D + Math.imul(Fe, Ye) | 0, ee = ee + Math.imul(Fe, et) | 0, ee = ee + Math.imul(Ze, Ye) | 0, pe = pe + Math.imul(Ze, et) | 0, D = D + Math.imul(ce, St) | 0, ee = ee + Math.imul(ce, tt) | 0, ee = ee + Math.imul(De, St) | 0, pe = pe + Math.imul(De, tt) | 0, D = D + Math.imul(re, wt) | 0, ee = ee + Math.imul(re, rt) | 0, ee = ee + Math.imul(O, wt) | 0, pe = pe + Math.imul(O, rt) | 0, D = D + Math.imul(Q, kt) | 0, ee = ee + Math.imul(Q, nt) | 0, ee = ee + Math.imul(le, kt) | 0, pe = pe + Math.imul(le, nt) | 0, D = D + Math.imul(Pe, bt) | 0, ee = ee + Math.imul(Pe, ot) | 0, ee = ee + Math.imul(he, bt) | 0, pe = pe + Math.imul(he, ot) | 0;
      var _t = (T + D | 0) + ((ee & 8191) << 13) | 0;
      T = (pe + (ee >>> 13) | 0) + (_t >>> 26) | 0, _t &= 67108863, D = Math.imul(ke, ze), ee = Math.imul(ke, Ve), ee = ee + Math.imul(de, ze) | 0, pe = Math.imul(de, Ve), D = D + Math.imul(We, Ke) | 0, ee = ee + Math.imul(We, x) | 0, ee = ee + Math.imul(Re, Ke) | 0, pe = pe + Math.imul(Re, x) | 0, D = D + Math.imul(J, Ee) | 0, ee = ee + Math.imul(J, xe) | 0, ee = ee + Math.imul(ye, Ee) | 0, pe = pe + Math.imul(ye, xe) | 0, D = D + Math.imul(gt, Ye) | 0, ee = ee + Math.imul(gt, et) | 0, ee = ee + Math.imul(Xe, Ye) | 0, pe = pe + Math.imul(Xe, et) | 0, D = D + Math.imul(Fe, St) | 0, ee = ee + Math.imul(Fe, tt) | 0, ee = ee + Math.imul(Ze, St) | 0, pe = pe + Math.imul(Ze, tt) | 0, D = D + Math.imul(ce, wt) | 0, ee = ee + Math.imul(ce, rt) | 0, ee = ee + Math.imul(De, wt) | 0, pe = pe + Math.imul(De, rt) | 0, D = D + Math.imul(re, kt) | 0, ee = ee + Math.imul(re, nt) | 0, ee = ee + Math.imul(O, kt) | 0, pe = pe + Math.imul(O, nt) | 0, D = D + Math.imul(Q, bt) | 0, ee = ee + Math.imul(Q, ot) | 0, ee = ee + Math.imul(le, bt) | 0, pe = pe + Math.imul(le, ot) | 0, D = D + Math.imul(Pe, Ot) | 0, ee = ee + Math.imul(Pe, st) | 0, ee = ee + Math.imul(he, Ot) | 0, pe = pe + Math.imul(he, st) | 0;
      var Et = (T + D | 0) + ((ee & 8191) << 13) | 0;
      T = (pe + (ee >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, D = Math.imul(me, ze), ee = Math.imul(me, Ve), ee = ee + Math.imul(Oe, ze) | 0, pe = Math.imul(Oe, Ve), D = D + Math.imul(ke, Ke) | 0, ee = ee + Math.imul(ke, x) | 0, ee = ee + Math.imul(de, Ke) | 0, pe = pe + Math.imul(de, x) | 0, D = D + Math.imul(We, Ee) | 0, ee = ee + Math.imul(We, xe) | 0, ee = ee + Math.imul(Re, Ee) | 0, pe = pe + Math.imul(Re, xe) | 0, D = D + Math.imul(J, Ye) | 0, ee = ee + Math.imul(J, et) | 0, ee = ee + Math.imul(ye, Ye) | 0, pe = pe + Math.imul(ye, et) | 0, D = D + Math.imul(gt, St) | 0, ee = ee + Math.imul(gt, tt) | 0, ee = ee + Math.imul(Xe, St) | 0, pe = pe + Math.imul(Xe, tt) | 0, D = D + Math.imul(Fe, wt) | 0, ee = ee + Math.imul(Fe, rt) | 0, ee = ee + Math.imul(Ze, wt) | 0, pe = pe + Math.imul(Ze, rt) | 0, D = D + Math.imul(ce, kt) | 0, ee = ee + Math.imul(ce, nt) | 0, ee = ee + Math.imul(De, kt) | 0, pe = pe + Math.imul(De, nt) | 0, D = D + Math.imul(re, bt) | 0, ee = ee + Math.imul(re, ot) | 0, ee = ee + Math.imul(O, bt) | 0, pe = pe + Math.imul(O, ot) | 0, D = D + Math.imul(Q, Ot) | 0, ee = ee + Math.imul(Q, st) | 0, ee = ee + Math.imul(le, Ot) | 0, pe = pe + Math.imul(le, st) | 0, D = D + Math.imul(Pe, Rt) | 0, ee = ee + Math.imul(Pe, Ct) | 0, ee = ee + Math.imul(he, Rt) | 0, pe = pe + Math.imul(he, Ct) | 0;
      var Nt = (T + D | 0) + ((ee & 8191) << 13) | 0;
      T = (pe + (ee >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, D = Math.imul(me, Ke), ee = Math.imul(me, x), ee = ee + Math.imul(Oe, Ke) | 0, pe = Math.imul(Oe, x), D = D + Math.imul(ke, Ee) | 0, ee = ee + Math.imul(ke, xe) | 0, ee = ee + Math.imul(de, Ee) | 0, pe = pe + Math.imul(de, xe) | 0, D = D + Math.imul(We, Ye) | 0, ee = ee + Math.imul(We, et) | 0, ee = ee + Math.imul(Re, Ye) | 0, pe = pe + Math.imul(Re, et) | 0, D = D + Math.imul(J, St) | 0, ee = ee + Math.imul(J, tt) | 0, ee = ee + Math.imul(ye, St) | 0, pe = pe + Math.imul(ye, tt) | 0, D = D + Math.imul(gt, wt) | 0, ee = ee + Math.imul(gt, rt) | 0, ee = ee + Math.imul(Xe, wt) | 0, pe = pe + Math.imul(Xe, rt) | 0, D = D + Math.imul(Fe, kt) | 0, ee = ee + Math.imul(Fe, nt) | 0, ee = ee + Math.imul(Ze, kt) | 0, pe = pe + Math.imul(Ze, nt) | 0, D = D + Math.imul(ce, bt) | 0, ee = ee + Math.imul(ce, ot) | 0, ee = ee + Math.imul(De, bt) | 0, pe = pe + Math.imul(De, ot) | 0, D = D + Math.imul(re, Ot) | 0, ee = ee + Math.imul(re, st) | 0, ee = ee + Math.imul(O, Ot) | 0, pe = pe + Math.imul(O, st) | 0, D = D + Math.imul(Q, Rt) | 0, ee = ee + Math.imul(Q, Ct) | 0, ee = ee + Math.imul(le, Rt) | 0, pe = pe + Math.imul(le, Ct) | 0;
      var Dt = (T + D | 0) + ((ee & 8191) << 13) | 0;
      T = (pe + (ee >>> 13) | 0) + (Dt >>> 26) | 0, Dt &= 67108863, D = Math.imul(me, Ee), ee = Math.imul(me, xe), ee = ee + Math.imul(Oe, Ee) | 0, pe = Math.imul(Oe, xe), D = D + Math.imul(ke, Ye) | 0, ee = ee + Math.imul(ke, et) | 0, ee = ee + Math.imul(de, Ye) | 0, pe = pe + Math.imul(de, et) | 0, D = D + Math.imul(We, St) | 0, ee = ee + Math.imul(We, tt) | 0, ee = ee + Math.imul(Re, St) | 0, pe = pe + Math.imul(Re, tt) | 0, D = D + Math.imul(J, wt) | 0, ee = ee + Math.imul(J, rt) | 0, ee = ee + Math.imul(ye, wt) | 0, pe = pe + Math.imul(ye, rt) | 0, D = D + Math.imul(gt, kt) | 0, ee = ee + Math.imul(gt, nt) | 0, ee = ee + Math.imul(Xe, kt) | 0, pe = pe + Math.imul(Xe, nt) | 0, D = D + Math.imul(Fe, bt) | 0, ee = ee + Math.imul(Fe, ot) | 0, ee = ee + Math.imul(Ze, bt) | 0, pe = pe + Math.imul(Ze, ot) | 0, D = D + Math.imul(ce, Ot) | 0, ee = ee + Math.imul(ce, st) | 0, ee = ee + Math.imul(De, Ot) | 0, pe = pe + Math.imul(De, st) | 0, D = D + Math.imul(re, Rt) | 0, ee = ee + Math.imul(re, Ct) | 0, ee = ee + Math.imul(O, Rt) | 0, pe = pe + Math.imul(O, Ct) | 0;
      var $t = (T + D | 0) + ((ee & 8191) << 13) | 0;
      T = (pe + (ee >>> 13) | 0) + ($t >>> 26) | 0, $t &= 67108863, D = Math.imul(me, Ye), ee = Math.imul(me, et), ee = ee + Math.imul(Oe, Ye) | 0, pe = Math.imul(Oe, et), D = D + Math.imul(ke, St) | 0, ee = ee + Math.imul(ke, tt) | 0, ee = ee + Math.imul(de, St) | 0, pe = pe + Math.imul(de, tt) | 0, D = D + Math.imul(We, wt) | 0, ee = ee + Math.imul(We, rt) | 0, ee = ee + Math.imul(Re, wt) | 0, pe = pe + Math.imul(Re, rt) | 0, D = D + Math.imul(J, kt) | 0, ee = ee + Math.imul(J, nt) | 0, ee = ee + Math.imul(ye, kt) | 0, pe = pe + Math.imul(ye, nt) | 0, D = D + Math.imul(gt, bt) | 0, ee = ee + Math.imul(gt, ot) | 0, ee = ee + Math.imul(Xe, bt) | 0, pe = pe + Math.imul(Xe, ot) | 0, D = D + Math.imul(Fe, Ot) | 0, ee = ee + Math.imul(Fe, st) | 0, ee = ee + Math.imul(Ze, Ot) | 0, pe = pe + Math.imul(Ze, st) | 0, D = D + Math.imul(ce, Rt) | 0, ee = ee + Math.imul(ce, Ct) | 0, ee = ee + Math.imul(De, Rt) | 0, pe = pe + Math.imul(De, Ct) | 0;
      var At = (T + D | 0) + ((ee & 8191) << 13) | 0;
      T = (pe + (ee >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, D = Math.imul(me, St), ee = Math.imul(me, tt), ee = ee + Math.imul(Oe, St) | 0, pe = Math.imul(Oe, tt), D = D + Math.imul(ke, wt) | 0, ee = ee + Math.imul(ke, rt) | 0, ee = ee + Math.imul(de, wt) | 0, pe = pe + Math.imul(de, rt) | 0, D = D + Math.imul(We, kt) | 0, ee = ee + Math.imul(We, nt) | 0, ee = ee + Math.imul(Re, kt) | 0, pe = pe + Math.imul(Re, nt) | 0, D = D + Math.imul(J, bt) | 0, ee = ee + Math.imul(J, ot) | 0, ee = ee + Math.imul(ye, bt) | 0, pe = pe + Math.imul(ye, ot) | 0, D = D + Math.imul(gt, Ot) | 0, ee = ee + Math.imul(gt, st) | 0, ee = ee + Math.imul(Xe, Ot) | 0, pe = pe + Math.imul(Xe, st) | 0, D = D + Math.imul(Fe, Rt) | 0, ee = ee + Math.imul(Fe, Ct) | 0, ee = ee + Math.imul(Ze, Rt) | 0, pe = pe + Math.imul(Ze, Ct) | 0;
      var Lt = (T + D | 0) + ((ee & 8191) << 13) | 0;
      T = (pe + (ee >>> 13) | 0) + (Lt >>> 26) | 0, Lt &= 67108863, D = Math.imul(me, wt), ee = Math.imul(me, rt), ee = ee + Math.imul(Oe, wt) | 0, pe = Math.imul(Oe, rt), D = D + Math.imul(ke, kt) | 0, ee = ee + Math.imul(ke, nt) | 0, ee = ee + Math.imul(de, kt) | 0, pe = pe + Math.imul(de, nt) | 0, D = D + Math.imul(We, bt) | 0, ee = ee + Math.imul(We, ot) | 0, ee = ee + Math.imul(Re, bt) | 0, pe = pe + Math.imul(Re, ot) | 0, D = D + Math.imul(J, Ot) | 0, ee = ee + Math.imul(J, st) | 0, ee = ee + Math.imul(ye, Ot) | 0, pe = pe + Math.imul(ye, st) | 0, D = D + Math.imul(gt, Rt) | 0, ee = ee + Math.imul(gt, Ct) | 0, ee = ee + Math.imul(Xe, Rt) | 0, pe = pe + Math.imul(Xe, Ct) | 0;
      var Bt = (T + D | 0) + ((ee & 8191) << 13) | 0;
      T = (pe + (ee >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, D = Math.imul(me, kt), ee = Math.imul(me, nt), ee = ee + Math.imul(Oe, kt) | 0, pe = Math.imul(Oe, nt), D = D + Math.imul(ke, bt) | 0, ee = ee + Math.imul(ke, ot) | 0, ee = ee + Math.imul(de, bt) | 0, pe = pe + Math.imul(de, ot) | 0, D = D + Math.imul(We, Ot) | 0, ee = ee + Math.imul(We, st) | 0, ee = ee + Math.imul(Re, Ot) | 0, pe = pe + Math.imul(Re, st) | 0, D = D + Math.imul(J, Rt) | 0, ee = ee + Math.imul(J, Ct) | 0, ee = ee + Math.imul(ye, Rt) | 0, pe = pe + Math.imul(ye, Ct) | 0;
      var Ut = (T + D | 0) + ((ee & 8191) << 13) | 0;
      T = (pe + (ee >>> 13) | 0) + (Ut >>> 26) | 0, Ut &= 67108863, D = Math.imul(me, bt), ee = Math.imul(me, ot), ee = ee + Math.imul(Oe, bt) | 0, pe = Math.imul(Oe, ot), D = D + Math.imul(ke, Ot) | 0, ee = ee + Math.imul(ke, st) | 0, ee = ee + Math.imul(de, Ot) | 0, pe = pe + Math.imul(de, st) | 0, D = D + Math.imul(We, Rt) | 0, ee = ee + Math.imul(We, Ct) | 0, ee = ee + Math.imul(Re, Rt) | 0, pe = pe + Math.imul(Re, Ct) | 0;
      var xt = (T + D | 0) + ((ee & 8191) << 13) | 0;
      T = (pe + (ee >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, D = Math.imul(me, Ot), ee = Math.imul(me, st), ee = ee + Math.imul(Oe, Ot) | 0, pe = Math.imul(Oe, st), D = D + Math.imul(ke, Rt) | 0, ee = ee + Math.imul(ke, Ct) | 0, ee = ee + Math.imul(de, Rt) | 0, pe = pe + Math.imul(de, Ct) | 0;
      var Vt = (T + D | 0) + ((ee & 8191) << 13) | 0;
      T = (pe + (ee >>> 13) | 0) + (Vt >>> 26) | 0, Vt &= 67108863, D = Math.imul(me, Rt), ee = Math.imul(me, Ct), ee = ee + Math.imul(Oe, Rt) | 0, pe = Math.imul(Oe, Ct);
      var Gt = (T + D | 0) + ((ee & 8191) << 13) | 0;
      return T = (pe + (ee >>> 13) | 0) + (Gt >>> 26) | 0, Gt &= 67108863, B[0] = Je, B[1] = He, B[2] = je, B[3] = pt, B[4] = mt, B[5] = yt, B[6] = ht, B[7] = _t, B[8] = Et, B[9] = Nt, B[10] = Dt, B[11] = $t, B[12] = At, B[13] = Lt, B[14] = Bt, B[15] = Ut, B[16] = xt, B[17] = Vt, B[18] = Gt, T !== 0 && (B[19] = T, $.length++), $;
    };
    Math.imul || (ie = fe);
    function ge(E, I, N) {
      N.negative = I.negative ^ E.negative, N.length = E.length + I.length;
      for (var $ = 0, U = 0, H = 0; H < N.length - 1; H++) {
        var B = U;
        U = 0;
        for (var T = $ & 67108863, D = Math.min(H, I.length - 1), ee = Math.max(0, H - E.length + 1); ee <= D; ee++) {
          var pe = H - ee, Ie = E.words[pe] | 0, Pe = I.words[ee] | 0, he = Ie * Pe, ve = he & 67108863;
          B = B + (he / 67108864 | 0) | 0, ve = ve + T | 0, T = ve & 67108863, B = B + (ve >>> 26) | 0, U += B >>> 26, B &= 67108863;
        }
        N.words[H] = T, $ = B, B = U;
      }
      return $ !== 0 ? N.words[H] = $ : N.length--, N._strip();
    }
    function be(E, I, N) {
      return ge(E, I, N);
    }
    p.prototype.mulTo = function(I, N) {
      var $, U = this.length + I.length;
      return this.length === 10 && I.length === 10 ? $ = ie(this, I, N) : U < 63 ? $ = fe(this, I, N) : U < 1024 ? $ = ge(this, I, N) : $ = be(this, I, N), $;
    }, p.prototype.mul = function(I) {
      var N = new p(null);
      return N.words = new Array(this.length + I.length), this.mulTo(I, N);
    }, p.prototype.mulf = function(I) {
      var N = new p(null);
      return N.words = new Array(this.length + I.length), be(this, I, N);
    }, p.prototype.imul = function(I) {
      return this.clone().mulTo(I, this);
    }, p.prototype.imuln = function(I) {
      var N = I < 0;
      N && (I = -I), l(typeof I == "number"), l(I < 67108864);
      for (var $ = 0, U = 0; U < this.length; U++) {
        var H = (this.words[U] | 0) * I, B = (H & 67108863) + ($ & 67108863);
        $ >>= 26, $ += H / 67108864 | 0, $ += B >>> 26, this.words[U] = B & 67108863;
      }
      return $ !== 0 && (this.words[U] = $, this.length++), N ? this.ineg() : this;
    }, p.prototype.muln = function(I) {
      return this.clone().imuln(I);
    }, p.prototype.sqr = function() {
      return this.mul(this);
    }, p.prototype.isqr = function() {
      return this.imul(this.clone());
    }, p.prototype.pow = function(I) {
      var N = ne(I);
      if (N.length === 0)
        return new p(1);
      for (var $ = this, U = 0; U < N.length && N[U] === 0; U++, $ = $.sqr())
        ;
      if (++U < N.length)
        for (var H = $.sqr(); U < N.length; U++, H = H.sqr())
          N[U] !== 0 && ($ = $.mul(H));
      return $;
    }, p.prototype.iushln = function(I) {
      l(typeof I == "number" && I >= 0);
      var N = I % 26, $ = (I - N) / 26, U = 67108863 >>> 26 - N << 26 - N, H;
      if (N !== 0) {
        var B = 0;
        for (H = 0; H < this.length; H++) {
          var T = this.words[H] & U, D = (this.words[H] | 0) - T << N;
          this.words[H] = D | B, B = T >>> 26 - N;
        }
        B && (this.words[H] = B, this.length++);
      }
      if ($ !== 0) {
        for (H = this.length - 1; H >= 0; H--)
          this.words[H + $] = this.words[H];
        for (H = 0; H < $; H++)
          this.words[H] = 0;
        this.length += $;
      }
      return this._strip();
    }, p.prototype.ishln = function(I) {
      return l(this.negative === 0), this.iushln(I);
    }, p.prototype.iushrn = function(I, N, $) {
      l(typeof I == "number" && I >= 0);
      var U;
      N ? U = (N - N % 26) / 26 : U = 0;
      var H = I % 26, B = Math.min((I - H) / 26, this.length), T = 67108863 ^ 67108863 >>> H << H, D = $;
      if (U -= B, U = Math.max(0, U), D) {
        for (var ee = 0; ee < B; ee++)
          D.words[ee] = this.words[ee];
        D.length = B;
      }
      if (B !== 0)
        if (this.length > B)
          for (this.length -= B, ee = 0; ee < this.length; ee++)
            this.words[ee] = this.words[ee + B];
        else
          this.words[0] = 0, this.length = 1;
      var pe = 0;
      for (ee = this.length - 1; ee >= 0 && (pe !== 0 || ee >= U); ee--) {
        var Ie = this.words[ee] | 0;
        this.words[ee] = pe << 26 - H | Ie >>> H, pe = Ie & T;
      }
      return D && pe !== 0 && (D.words[D.length++] = pe), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, p.prototype.ishrn = function(I, N, $) {
      return l(this.negative === 0), this.iushrn(I, N, $);
    }, p.prototype.shln = function(I) {
      return this.clone().ishln(I);
    }, p.prototype.ushln = function(I) {
      return this.clone().iushln(I);
    }, p.prototype.shrn = function(I) {
      return this.clone().ishrn(I);
    }, p.prototype.ushrn = function(I) {
      return this.clone().iushrn(I);
    }, p.prototype.testn = function(I) {
      l(typeof I == "number" && I >= 0);
      var N = I % 26, $ = (I - N) / 26, U = 1 << N;
      if (this.length <= $)
        return !1;
      var H = this.words[$];
      return !!(H & U);
    }, p.prototype.imaskn = function(I) {
      l(typeof I == "number" && I >= 0);
      var N = I % 26, $ = (I - N) / 26;
      if (l(this.negative === 0, "imaskn works only with positive numbers"), this.length <= $)
        return this;
      if (N !== 0 && $++, this.length = Math.min($, this.length), N !== 0) {
        var U = 67108863 ^ 67108863 >>> N << N;
        this.words[this.length - 1] &= U;
      }
      return this._strip();
    }, p.prototype.maskn = function(I) {
      return this.clone().imaskn(I);
    }, p.prototype.iaddn = function(I) {
      return l(typeof I == "number"), l(I < 67108864), I < 0 ? this.isubn(-I) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= I ? (this.words[0] = I - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(I), this.negative = 1, this) : this._iaddn(I);
    }, p.prototype._iaddn = function(I) {
      this.words[0] += I;
      for (var N = 0; N < this.length && this.words[N] >= 67108864; N++)
        this.words[N] -= 67108864, N === this.length - 1 ? this.words[N + 1] = 1 : this.words[N + 1]++;
      return this.length = Math.max(this.length, N + 1), this;
    }, p.prototype.isubn = function(I) {
      if (l(typeof I == "number"), l(I < 67108864), I < 0)
        return this.iaddn(-I);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(I), this.negative = 1, this;
      if (this.words[0] -= I, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var N = 0; N < this.length && this.words[N] < 0; N++)
          this.words[N] += 67108864, this.words[N + 1] -= 1;
      return this._strip();
    }, p.prototype.addn = function(I) {
      return this.clone().iaddn(I);
    }, p.prototype.subn = function(I) {
      return this.clone().isubn(I);
    }, p.prototype.iabs = function() {
      return this.negative = 0, this;
    }, p.prototype.abs = function() {
      return this.clone().iabs();
    }, p.prototype._ishlnsubmul = function(I, N, $) {
      var U = I.length + $, H;
      this._expand(U);
      var B, T = 0;
      for (H = 0; H < I.length; H++) {
        B = (this.words[H + $] | 0) + T;
        var D = (I.words[H] | 0) * N;
        B -= D & 67108863, T = (B >> 26) - (D / 67108864 | 0), this.words[H + $] = B & 67108863;
      }
      for (; H < this.length - $; H++)
        B = (this.words[H + $] | 0) + T, T = B >> 26, this.words[H + $] = B & 67108863;
      if (T === 0)
        return this._strip();
      for (l(T === -1), T = 0, H = 0; H < this.length; H++)
        B = -(this.words[H] | 0) + T, T = B >> 26, this.words[H] = B & 67108863;
      return this.negative = 1, this._strip();
    }, p.prototype._wordDiv = function(I, N) {
      var $ = this.length - I.length, U = this.clone(), H = I, B = H.words[H.length - 1] | 0, T = this._countBits(B);
      $ = 26 - T, $ !== 0 && (H = H.ushln($), U.iushln($), B = H.words[H.length - 1] | 0);
      var D = U.length - H.length, ee;
      if (N !== "mod") {
        ee = new p(null), ee.length = D + 1, ee.words = new Array(ee.length);
        for (var pe = 0; pe < ee.length; pe++)
          ee.words[pe] = 0;
      }
      var Ie = U.clone()._ishlnsubmul(H, 1, D);
      Ie.negative === 0 && (U = Ie, ee && (ee.words[D] = 1));
      for (var Pe = D - 1; Pe >= 0; Pe--) {
        var he = (U.words[H.length + Pe] | 0) * 67108864 + (U.words[H.length + Pe - 1] | 0);
        for (he = Math.min(he / B | 0, 67108863), U._ishlnsubmul(H, he, Pe); U.negative !== 0; )
          he--, U.negative = 0, U._ishlnsubmul(H, 1, Pe), U.isZero() || (U.negative ^= 1);
        ee && (ee.words[Pe] = he);
      }
      return ee && ee._strip(), U._strip(), N !== "div" && $ !== 0 && U.iushrn($), {
        div: ee || null,
        mod: U
      };
    }, p.prototype.divmod = function(I, N, $) {
      if (l(!I.isZero()), this.isZero())
        return {
          div: new p(0),
          mod: new p(0)
        };
      var U, H, B;
      return this.negative !== 0 && I.negative === 0 ? (B = this.neg().divmod(I, N), N !== "mod" && (U = B.div.neg()), N !== "div" && (H = B.mod.neg(), $ && H.negative !== 0 && H.iadd(I)), {
        div: U,
        mod: H
      }) : this.negative === 0 && I.negative !== 0 ? (B = this.divmod(I.neg(), N), N !== "mod" && (U = B.div.neg()), {
        div: U,
        mod: B.mod
      }) : this.negative & I.negative ? (B = this.neg().divmod(I.neg(), N), N !== "div" && (H = B.mod.neg(), $ && H.negative !== 0 && H.isub(I)), {
        div: B.div,
        mod: H
      }) : I.length > this.length || this.cmp(I) < 0 ? {
        div: new p(0),
        mod: this
      } : I.length === 1 ? N === "div" ? {
        div: this.divn(I.words[0]),
        mod: null
      } : N === "mod" ? {
        div: null,
        mod: new p(this.modrn(I.words[0]))
      } : {
        div: this.divn(I.words[0]),
        mod: new p(this.modrn(I.words[0]))
      } : this._wordDiv(I, N);
    }, p.prototype.div = function(I) {
      return this.divmod(I, "div", !1).div;
    }, p.prototype.mod = function(I) {
      return this.divmod(I, "mod", !1).mod;
    }, p.prototype.umod = function(I) {
      return this.divmod(I, "mod", !0).mod;
    }, p.prototype.divRound = function(I) {
      var N = this.divmod(I);
      if (N.mod.isZero())
        return N.div;
      var $ = N.div.negative !== 0 ? N.mod.isub(I) : N.mod, U = I.ushrn(1), H = I.andln(1), B = $.cmp(U);
      return B < 0 || H === 1 && B === 0 ? N.div : N.div.negative !== 0 ? N.div.isubn(1) : N.div.iaddn(1);
    }, p.prototype.modrn = function(I) {
      var N = I < 0;
      N && (I = -I), l(I <= 67108863);
      for (var $ = (1 << 26) % I, U = 0, H = this.length - 1; H >= 0; H--)
        U = ($ * U + (this.words[H] | 0)) % I;
      return N ? -U : U;
    }, p.prototype.modn = function(I) {
      return this.modrn(I);
    }, p.prototype.idivn = function(I) {
      var N = I < 0;
      N && (I = -I), l(I <= 67108863);
      for (var $ = 0, U = this.length - 1; U >= 0; U--) {
        var H = (this.words[U] | 0) + $ * 67108864;
        this.words[U] = H / I | 0, $ = H % I;
      }
      return this._strip(), N ? this.ineg() : this;
    }, p.prototype.divn = function(I) {
      return this.clone().idivn(I);
    }, p.prototype.egcd = function(I) {
      l(I.negative === 0), l(!I.isZero());
      var N = this, $ = I.clone();
      N.negative !== 0 ? N = N.umod(I) : N = N.clone();
      for (var U = new p(1), H = new p(0), B = new p(0), T = new p(1), D = 0; N.isEven() && $.isEven(); )
        N.iushrn(1), $.iushrn(1), ++D;
      for (var ee = $.clone(), pe = N.clone(); !N.isZero(); ) {
        for (var Ie = 0, Pe = 1; !(N.words[0] & Pe) && Ie < 26; ++Ie, Pe <<= 1)
          ;
        if (Ie > 0)
          for (N.iushrn(Ie); Ie-- > 0; )
            (U.isOdd() || H.isOdd()) && (U.iadd(ee), H.isub(pe)), U.iushrn(1), H.iushrn(1);
        for (var he = 0, ve = 1; !($.words[0] & ve) && he < 26; ++he, ve <<= 1)
          ;
        if (he > 0)
          for ($.iushrn(he); he-- > 0; )
            (B.isOdd() || T.isOdd()) && (B.iadd(ee), T.isub(pe)), B.iushrn(1), T.iushrn(1);
        N.cmp($) >= 0 ? (N.isub($), U.isub(B), H.isub(T)) : ($.isub(N), B.isub(U), T.isub(H));
      }
      return {
        a: B,
        b: T,
        gcd: $.iushln(D)
      };
    }, p.prototype._invmp = function(I) {
      l(I.negative === 0), l(!I.isZero());
      var N = this, $ = I.clone();
      N.negative !== 0 ? N = N.umod(I) : N = N.clone();
      for (var U = new p(1), H = new p(0), B = $.clone(); N.cmpn(1) > 0 && $.cmpn(1) > 0; ) {
        for (var T = 0, D = 1; !(N.words[0] & D) && T < 26; ++T, D <<= 1)
          ;
        if (T > 0)
          for (N.iushrn(T); T-- > 0; )
            U.isOdd() && U.iadd(B), U.iushrn(1);
        for (var ee = 0, pe = 1; !($.words[0] & pe) && ee < 26; ++ee, pe <<= 1)
          ;
        if (ee > 0)
          for ($.iushrn(ee); ee-- > 0; )
            H.isOdd() && H.iadd(B), H.iushrn(1);
        N.cmp($) >= 0 ? (N.isub($), U.isub(H)) : ($.isub(N), H.isub(U));
      }
      var Ie;
      return N.cmpn(1) === 0 ? Ie = U : Ie = H, Ie.cmpn(0) < 0 && Ie.iadd(I), Ie;
    }, p.prototype.gcd = function(I) {
      if (this.isZero())
        return I.abs();
      if (I.isZero())
        return this.abs();
      var N = this.clone(), $ = I.clone();
      N.negative = 0, $.negative = 0;
      for (var U = 0; N.isEven() && $.isEven(); U++)
        N.iushrn(1), $.iushrn(1);
      do {
        for (; N.isEven(); )
          N.iushrn(1);
        for (; $.isEven(); )
          $.iushrn(1);
        var H = N.cmp($);
        if (H < 0) {
          var B = N;
          N = $, $ = B;
        } else if (H === 0 || $.cmpn(1) === 0)
          break;
        N.isub($);
      } while (!0);
      return $.iushln(U);
    }, p.prototype.invm = function(I) {
      return this.egcd(I).a.umod(I);
    }, p.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, p.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, p.prototype.andln = function(I) {
      return this.words[0] & I;
    }, p.prototype.bincn = function(I) {
      l(typeof I == "number");
      var N = I % 26, $ = (I - N) / 26, U = 1 << N;
      if (this.length <= $)
        return this._expand($ + 1), this.words[$] |= U, this;
      for (var H = U, B = $; H !== 0 && B < this.length; B++) {
        var T = this.words[B] | 0;
        T += H, H = T >>> 26, T &= 67108863, this.words[B] = T;
      }
      return H !== 0 && (this.words[B] = H, this.length++), this;
    }, p.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, p.prototype.cmpn = function(I) {
      var N = I < 0;
      if (this.negative !== 0 && !N)
        return -1;
      if (this.negative === 0 && N)
        return 1;
      this._strip();
      var $;
      if (this.length > 1)
        $ = 1;
      else {
        N && (I = -I), l(I <= 67108863, "Number is too big");
        var U = this.words[0] | 0;
        $ = U === I ? 0 : U < I ? -1 : 1;
      }
      return this.negative !== 0 ? -$ | 0 : $;
    }, p.prototype.cmp = function(I) {
      if (this.negative !== 0 && I.negative === 0)
        return -1;
      if (this.negative === 0 && I.negative !== 0)
        return 1;
      var N = this.ucmp(I);
      return this.negative !== 0 ? -N | 0 : N;
    }, p.prototype.ucmp = function(I) {
      if (this.length > I.length)
        return 1;
      if (this.length < I.length)
        return -1;
      for (var N = 0, $ = this.length - 1; $ >= 0; $--) {
        var U = this.words[$] | 0, H = I.words[$] | 0;
        if (U !== H) {
          U < H ? N = -1 : U > H && (N = 1);
          break;
        }
      }
      return N;
    }, p.prototype.gtn = function(I) {
      return this.cmpn(I) === 1;
    }, p.prototype.gt = function(I) {
      return this.cmp(I) === 1;
    }, p.prototype.gten = function(I) {
      return this.cmpn(I) >= 0;
    }, p.prototype.gte = function(I) {
      return this.cmp(I) >= 0;
    }, p.prototype.ltn = function(I) {
      return this.cmpn(I) === -1;
    }, p.prototype.lt = function(I) {
      return this.cmp(I) === -1;
    }, p.prototype.lten = function(I) {
      return this.cmpn(I) <= 0;
    }, p.prototype.lte = function(I) {
      return this.cmp(I) <= 0;
    }, p.prototype.eqn = function(I) {
      return this.cmpn(I) === 0;
    }, p.prototype.eq = function(I) {
      return this.cmp(I) === 0;
    }, p.red = function(I) {
      return new P(I);
    }, p.prototype.toRed = function(I) {
      return l(!this.red, "Already a number in reduction context"), l(this.negative === 0, "red works only with positives"), I.convertTo(this)._forceRed(I);
    }, p.prototype.fromRed = function() {
      return l(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, p.prototype._forceRed = function(I) {
      return this.red = I, this;
    }, p.prototype.forceRed = function(I) {
      return l(!this.red, "Already a number in reduction context"), this._forceRed(I);
    }, p.prototype.redAdd = function(I) {
      return l(this.red, "redAdd works only with red numbers"), this.red.add(this, I);
    }, p.prototype.redIAdd = function(I) {
      return l(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, I);
    }, p.prototype.redSub = function(I) {
      return l(this.red, "redSub works only with red numbers"), this.red.sub(this, I);
    }, p.prototype.redISub = function(I) {
      return l(this.red, "redISub works only with red numbers"), this.red.isub(this, I);
    }, p.prototype.redShl = function(I) {
      return l(this.red, "redShl works only with red numbers"), this.red.shl(this, I);
    }, p.prototype.redMul = function(I) {
      return l(this.red, "redMul works only with red numbers"), this.red._verify2(this, I), this.red.mul(this, I);
    }, p.prototype.redIMul = function(I) {
      return l(this.red, "redMul works only with red numbers"), this.red._verify2(this, I), this.red.imul(this, I);
    }, p.prototype.redSqr = function() {
      return l(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, p.prototype.redISqr = function() {
      return l(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, p.prototype.redSqrt = function() {
      return l(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, p.prototype.redInvm = function() {
      return l(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, p.prototype.redNeg = function() {
      return l(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, p.prototype.redPow = function(I) {
      return l(this.red && !I.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, I);
    };
    var Ce = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function Me(E, I) {
      this.name = E, this.p = new p(I, 16), this.n = this.p.bitLength(), this.k = new p(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    Me.prototype._tmp = function() {
      var I = new p(null);
      return I.words = new Array(Math.ceil(this.n / 13)), I;
    }, Me.prototype.ireduce = function(I) {
      var N = I, $;
      do
        this.split(N, this.tmp), N = this.imulK(N), N = N.iadd(this.tmp), $ = N.bitLength();
      while ($ > this.n);
      var U = $ < this.n ? -1 : N.ucmp(this.p);
      return U === 0 ? (N.words[0] = 0, N.length = 1) : U > 0 ? N.isub(this.p) : N.strip !== void 0 ? N.strip() : N._strip(), N;
    }, Me.prototype.split = function(I, N) {
      I.iushrn(this.n, 0, N);
    }, Me.prototype.imulK = function(I) {
      return I.imul(this.k);
    };
    function Be() {
      Me.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    v(Be, Me), Be.prototype.split = function(I, N) {
      for (var $ = 4194303, U = Math.min(I.length, 9), H = 0; H < U; H++)
        N.words[H] = I.words[H];
      if (N.length = U, I.length <= 9) {
        I.words[0] = 0, I.length = 1;
        return;
      }
      var B = I.words[9];
      for (N.words[N.length++] = B & $, H = 10; H < I.length; H++) {
        var T = I.words[H] | 0;
        I.words[H - 10] = (T & $) << 4 | B >>> 22, B = T;
      }
      B >>>= 22, I.words[H - 10] = B, B === 0 && I.length > 10 ? I.length -= 10 : I.length -= 9;
    }, Be.prototype.imulK = function(I) {
      I.words[I.length] = 0, I.words[I.length + 1] = 0, I.length += 2;
      for (var N = 0, $ = 0; $ < I.length; $++) {
        var U = I.words[$] | 0;
        N += U * 977, I.words[$] = N & 67108863, N = U * 64 + (N / 67108864 | 0);
      }
      return I.words[I.length - 1] === 0 && (I.length--, I.words[I.length - 1] === 0 && I.length--), I;
    };
    function Ae() {
      Me.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    v(Ae, Me);
    function Z() {
      Me.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    v(Z, Me);
    function z() {
      Me.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    v(z, Me), z.prototype.imulK = function(I) {
      for (var N = 0, $ = 0; $ < I.length; $++) {
        var U = (I.words[$] | 0) * 19 + N, H = U & 67108863;
        U >>>= 26, I.words[$] = H, N = U;
      }
      return N !== 0 && (I.words[I.length++] = N), I;
    }, p._prime = function(I) {
      if (Ce[I])
        return Ce[I];
      var N;
      if (I === "k256")
        N = new Be();
      else if (I === "p224")
        N = new Ae();
      else if (I === "p192")
        N = new Z();
      else if (I === "p25519")
        N = new z();
      else
        throw new Error("Unknown prime " + I);
      return Ce[I] = N, N;
    };
    function P(E) {
      if (typeof E == "string") {
        var I = p._prime(E);
        this.m = I.p, this.prime = I;
      } else
        l(E.gtn(1), "modulus must be greater than 1"), this.m = E, this.prime = null;
    }
    P.prototype._verify1 = function(I) {
      l(I.negative === 0, "red works only with positives"), l(I.red, "red works only with red numbers");
    }, P.prototype._verify2 = function(I, N) {
      l((I.negative | N.negative) === 0, "red works only with positives"), l(
        I.red && I.red === N.red,
        "red works only with red numbers"
      );
    }, P.prototype.imod = function(I) {
      return this.prime ? this.prime.ireduce(I)._forceRed(this) : (F(I, I.umod(this.m)._forceRed(this)), I);
    }, P.prototype.neg = function(I) {
      return I.isZero() ? I.clone() : this.m.sub(I)._forceRed(this);
    }, P.prototype.add = function(I, N) {
      this._verify2(I, N);
      var $ = I.add(N);
      return $.cmp(this.m) >= 0 && $.isub(this.m), $._forceRed(this);
    }, P.prototype.iadd = function(I, N) {
      this._verify2(I, N);
      var $ = I.iadd(N);
      return $.cmp(this.m) >= 0 && $.isub(this.m), $;
    }, P.prototype.sub = function(I, N) {
      this._verify2(I, N);
      var $ = I.sub(N);
      return $.cmpn(0) < 0 && $.iadd(this.m), $._forceRed(this);
    }, P.prototype.isub = function(I, N) {
      this._verify2(I, N);
      var $ = I.isub(N);
      return $.cmpn(0) < 0 && $.iadd(this.m), $;
    }, P.prototype.shl = function(I, N) {
      return this._verify1(I), this.imod(I.ushln(N));
    }, P.prototype.imul = function(I, N) {
      return this._verify2(I, N), this.imod(I.imul(N));
    }, P.prototype.mul = function(I, N) {
      return this._verify2(I, N), this.imod(I.mul(N));
    }, P.prototype.isqr = function(I) {
      return this.imul(I, I.clone());
    }, P.prototype.sqr = function(I) {
      return this.mul(I, I);
    }, P.prototype.sqrt = function(I) {
      if (I.isZero())
        return I.clone();
      var N = this.m.andln(3);
      if (l(N % 2 === 1), N === 3) {
        var $ = this.m.add(new p(1)).iushrn(2);
        return this.pow(I, $);
      }
      for (var U = this.m.subn(1), H = 0; !U.isZero() && U.andln(1) === 0; )
        H++, U.iushrn(1);
      l(!U.isZero());
      var B = new p(1).toRed(this), T = B.redNeg(), D = this.m.subn(1).iushrn(1), ee = this.m.bitLength();
      for (ee = new p(2 * ee * ee).toRed(this); this.pow(ee, D).cmp(T) !== 0; )
        ee.redIAdd(T);
      for (var pe = this.pow(ee, U), Ie = this.pow(I, U.addn(1).iushrn(1)), Pe = this.pow(I, U), he = H; Pe.cmp(B) !== 0; ) {
        for (var ve = Pe, Q = 0; ve.cmp(B) !== 0; Q++)
          ve = ve.redSqr();
        l(Q < he);
        var le = this.pow(pe, new p(1).iushln(he - Q - 1));
        Ie = Ie.redMul(le), pe = le.redSqr(), Pe = Pe.redMul(pe), he = Q;
      }
      return Ie;
    }, P.prototype.invm = function(I) {
      var N = I._invmp(this.m);
      return N.negative !== 0 ? (N.negative = 0, this.imod(N).redNeg()) : this.imod(N);
    }, P.prototype.pow = function(I, N) {
      if (N.isZero())
        return new p(1).toRed(this);
      if (N.cmpn(1) === 0)
        return I.clone();
      var $ = 4, U = new Array(1 << $);
      U[0] = new p(1).toRed(this), U[1] = I;
      for (var H = 2; H < U.length; H++)
        U[H] = this.mul(U[H - 1], I);
      var B = U[0], T = 0, D = 0, ee = N.bitLength() % 26;
      for (ee === 0 && (ee = 26), H = N.length - 1; H >= 0; H--) {
        for (var pe = N.words[H], Ie = ee - 1; Ie >= 0; Ie--) {
          var Pe = pe >> Ie & 1;
          if (B !== U[0] && (B = this.sqr(B)), Pe === 0 && T === 0) {
            D = 0;
            continue;
          }
          T <<= 1, T |= Pe, D++, !(D !== $ && (H !== 0 || Ie !== 0)) && (B = this.mul(B, U[T]), D = 0, T = 0);
        }
        ee = 26;
      }
      return B;
    }, P.prototype.convertTo = function(I) {
      var N = I.umod(this.m);
      return N === I ? N.clone() : N;
    }, P.prototype.convertFrom = function(I) {
      var N = I.clone();
      return N.red = null, N;
    }, p.mont = function(I) {
      return new S(I);
    };
    function S(E) {
      P.call(this, E), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new p(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    v(S, P), S.prototype.convertTo = function(I) {
      return this.imod(I.ushln(this.shift));
    }, S.prototype.convertFrom = function(I) {
      var N = this.imod(I.mul(this.rinv));
      return N.red = null, N;
    }, S.prototype.imul = function(I, N) {
      if (I.isZero() || N.isZero())
        return I.words[0] = 0, I.length = 1, I;
      var $ = I.imul(N), U = $.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), H = $.isub(U).iushrn(this.shift), B = H;
      return H.cmp(this.m) >= 0 ? B = H.isub(this.m) : H.cmpn(0) < 0 && (B = H.iadd(this.m)), B._forceRed(this);
    }, S.prototype.mul = function(I, N) {
      if (I.isZero() || N.isZero())
        return new p(0)._forceRed(this);
      var $ = I.mul(N), U = $.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), H = $.isub(U).iushrn(this.shift), B = H;
      return H.cmp(this.m) >= 0 ? B = H.isub(this.m) : H.cmpn(0) < 0 && (B = H.iadd(this.m)), B._forceRed(this);
    }, S.prototype.invm = function(I) {
      var N = this.imod(I._invmp(this.m).mul(this.r2));
      return N._forceRed(this);
    };
  })(a, commonjsGlobal$1);
})(bn$4);
var bnExports$4 = bn$4.exports, BN$a = bnExports$4, randomBytes$1 = browserExports;
function blind(a) {
  var u = getr(a), c = u.toRed(BN$a.mont(a.modulus)).redPow(new BN$a(a.publicExponent)).fromRed();
  return { blinder: c, unblinder: u.invm(a.modulus) };
}
function getr(a) {
  var u = a.modulus.byteLength(), c;
  do
    c = new BN$a(randomBytes$1(u));
  while (c.cmp(a.modulus) >= 0 || !c.umod(a.prime1) || !c.umod(a.prime2));
  return c;
}
function crt$2(a, u) {
  var c = blind(u), l = u.modulus.byteLength(), v = new BN$a(a).mul(c.blinder).umod(u.modulus), p = v.toRed(BN$a.mont(u.prime1)), _ = v.toRed(BN$a.mont(u.prime2)), k = u.coefficient, M = u.prime1, L = u.prime2, F = p.redPow(u.exponent1).fromRed(), V = _.redPow(u.exponent2).fromRed(), X = F.isub(V).imul(k).umod(M).imul(L);
  return V.iadd(X).imul(c.unblinder).umod(u.modulus).toArrayLike(Buffer$O, "be", l);
}
crt$2.getr = getr;
var browserifyRsa = crt$2, elliptic = {};
const name$1 = "elliptic", version$1 = "6.5.4", description$1 = "EC cryptography", main$1 = "lib/elliptic.js", files = [
  "lib"
], scripts$1 = {
  lint: "eslint lib test",
  "lint:fix": "npm run lint -- --fix",
  unit: "istanbul test _mocha --reporter=spec test/index.js",
  test: "npm run lint && npm run unit",
  version: "grunt dist && git add dist/"
}, repository$1 = {
  type: "git",
  url: "git@github.com:indutny/elliptic"
}, keywords$1 = [
  "EC",
  "Elliptic",
  "curve",
  "Cryptography"
], author$1 = "Fedor Indutny <fedor@indutny.com>", license$1 = "MIT", bugs$1 = {
  url: "https://github.com/indutny/elliptic/issues"
}, homepage$1 = "https://github.com/indutny/elliptic", devDependencies$1 = {
  brfs: "^2.0.2",
  coveralls: "^3.1.0",
  eslint: "^7.6.0",
  grunt: "^1.2.1",
  "grunt-browserify": "^5.3.0",
  "grunt-cli": "^1.3.2",
  "grunt-contrib-connect": "^3.0.0",
  "grunt-contrib-copy": "^1.0.0",
  "grunt-contrib-uglify": "^5.0.0",
  "grunt-mocha-istanbul": "^5.0.2",
  "grunt-saucelabs": "^9.0.1",
  istanbul: "^0.4.5",
  mocha: "^8.0.1"
}, dependencies$1 = {
  "bn.js": "^4.11.9",
  brorand: "^1.1.0",
  "hash.js": "^1.0.0",
  "hmac-drbg": "^1.0.1",
  inherits: "^2.0.4",
  "minimalistic-assert": "^1.0.1",
  "minimalistic-crypto-utils": "^1.0.1"
}, require$$0$1 = {
  name: name$1,
  version: version$1,
  description: description$1,
  main: main$1,
  files,
  scripts: scripts$1,
  repository: repository$1,
  keywords: keywords$1,
  author: author$1,
  license: license$1,
  bugs: bugs$1,
  homepage: homepage$1,
  devDependencies: devDependencies$1,
  dependencies: dependencies$1
};
var utils$v = {}, bn$3 = { exports: {} };
bn$3.exports;
(function(a) {
  (function(u, c) {
    function l(P, S) {
      if (!P)
        throw new Error(S || "Assertion failed");
    }
    function v(P, S) {
      P.super_ = S;
      var E = function() {
      };
      E.prototype = S.prototype, P.prototype = new E(), P.prototype.constructor = P;
    }
    function p(P, S, E) {
      if (p.isBN(P))
        return P;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, P !== null && ((S === "le" || S === "be") && (E = S, S = 10), this._init(P || 0, S || 10, E || "be"));
    }
    typeof u == "object" ? u.exports = p : c.BN = p, p.BN = p, p.wordSize = 26;
    var _;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? _ = window.Buffer : _ = require$$0$2.Buffer;
    } catch {
    }
    p.isBN = function(S) {
      return S instanceof p ? !0 : S !== null && typeof S == "object" && S.constructor.wordSize === p.wordSize && Array.isArray(S.words);
    }, p.max = function(S, E) {
      return S.cmp(E) > 0 ? S : E;
    }, p.min = function(S, E) {
      return S.cmp(E) < 0 ? S : E;
    }, p.prototype._init = function(S, E, I) {
      if (typeof S == "number")
        return this._initNumber(S, E, I);
      if (typeof S == "object")
        return this._initArray(S, E, I);
      E === "hex" && (E = 16), l(E === (E | 0) && E >= 2 && E <= 36), S = S.toString().replace(/\s+/g, "");
      var N = 0;
      S[0] === "-" && (N++, this.negative = 1), N < S.length && (E === 16 ? this._parseHex(S, N, I) : (this._parseBase(S, E, N), I === "le" && this._initArray(this.toArray(), E, I)));
    }, p.prototype._initNumber = function(S, E, I) {
      S < 0 && (this.negative = 1, S = -S), S < 67108864 ? (this.words = [S & 67108863], this.length = 1) : S < 4503599627370496 ? (this.words = [
        S & 67108863,
        S / 67108864 & 67108863
      ], this.length = 2) : (l(S < 9007199254740992), this.words = [
        S & 67108863,
        S / 67108864 & 67108863,
        1
      ], this.length = 3), I === "le" && this._initArray(this.toArray(), E, I);
    }, p.prototype._initArray = function(S, E, I) {
      if (l(typeof S.length == "number"), S.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(S.length / 3), this.words = new Array(this.length);
      for (var N = 0; N < this.length; N++)
        this.words[N] = 0;
      var $, U, H = 0;
      if (I === "be")
        for (N = S.length - 1, $ = 0; N >= 0; N -= 3)
          U = S[N] | S[N - 1] << 8 | S[N - 2] << 16, this.words[$] |= U << H & 67108863, this.words[$ + 1] = U >>> 26 - H & 67108863, H += 24, H >= 26 && (H -= 26, $++);
      else if (I === "le")
        for (N = 0, $ = 0; N < S.length; N += 3)
          U = S[N] | S[N + 1] << 8 | S[N + 2] << 16, this.words[$] |= U << H & 67108863, this.words[$ + 1] = U >>> 26 - H & 67108863, H += 24, H >= 26 && (H -= 26, $++);
      return this.strip();
    };
    function k(P, S) {
      var E = P.charCodeAt(S);
      return E >= 65 && E <= 70 ? E - 55 : E >= 97 && E <= 102 ? E - 87 : E - 48 & 15;
    }
    function M(P, S, E) {
      var I = k(P, E);
      return E - 1 >= S && (I |= k(P, E - 1) << 4), I;
    }
    p.prototype._parseHex = function(S, E, I) {
      this.length = Math.ceil((S.length - E) / 6), this.words = new Array(this.length);
      for (var N = 0; N < this.length; N++)
        this.words[N] = 0;
      var $ = 0, U = 0, H;
      if (I === "be")
        for (N = S.length - 1; N >= E; N -= 2)
          H = M(S, E, N) << $, this.words[U] |= H & 67108863, $ >= 18 ? ($ -= 18, U += 1, this.words[U] |= H >>> 26) : $ += 8;
      else {
        var B = S.length - E;
        for (N = B % 2 === 0 ? E + 1 : E; N < S.length; N += 2)
          H = M(S, E, N) << $, this.words[U] |= H & 67108863, $ >= 18 ? ($ -= 18, U += 1, this.words[U] |= H >>> 26) : $ += 8;
      }
      this.strip();
    };
    function L(P, S, E, I) {
      for (var N = 0, $ = Math.min(P.length, E), U = S; U < $; U++) {
        var H = P.charCodeAt(U) - 48;
        N *= I, H >= 49 ? N += H - 49 + 10 : H >= 17 ? N += H - 17 + 10 : N += H;
      }
      return N;
    }
    p.prototype._parseBase = function(S, E, I) {
      this.words = [0], this.length = 1;
      for (var N = 0, $ = 1; $ <= 67108863; $ *= E)
        N++;
      N--, $ = $ / E | 0;
      for (var U = S.length - I, H = U % N, B = Math.min(U, U - H) + I, T = 0, D = I; D < B; D += N)
        T = L(S, D, D + N, E), this.imuln($), this.words[0] + T < 67108864 ? this.words[0] += T : this._iaddn(T);
      if (H !== 0) {
        var ee = 1;
        for (T = L(S, D, S.length, E), D = 0; D < H; D++)
          ee *= E;
        this.imuln(ee), this.words[0] + T < 67108864 ? this.words[0] += T : this._iaddn(T);
      }
      this.strip();
    }, p.prototype.copy = function(S) {
      S.words = new Array(this.length);
      for (var E = 0; E < this.length; E++)
        S.words[E] = this.words[E];
      S.length = this.length, S.negative = this.negative, S.red = this.red;
    }, p.prototype.clone = function() {
      var S = new p(null);
      return this.copy(S), S;
    }, p.prototype._expand = function(S) {
      for (; this.length < S; )
        this.words[this.length++] = 0;
      return this;
    }, p.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, p.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, p.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var F = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], V = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], X = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    p.prototype.toString = function(S, E) {
      S = S || 10, E = E | 0 || 1;
      var I;
      if (S === 16 || S === "hex") {
        I = "";
        for (var N = 0, $ = 0, U = 0; U < this.length; U++) {
          var H = this.words[U], B = ((H << N | $) & 16777215).toString(16);
          $ = H >>> 24 - N & 16777215, $ !== 0 || U !== this.length - 1 ? I = F[6 - B.length] + B + I : I = B + I, N += 2, N >= 26 && (N -= 26, U--);
        }
        for ($ !== 0 && (I = $.toString(16) + I); I.length % E !== 0; )
          I = "0" + I;
        return this.negative !== 0 && (I = "-" + I), I;
      }
      if (S === (S | 0) && S >= 2 && S <= 36) {
        var T = V[S], D = X[S];
        I = "";
        var ee = this.clone();
        for (ee.negative = 0; !ee.isZero(); ) {
          var pe = ee.modn(D).toString(S);
          ee = ee.idivn(D), ee.isZero() ? I = pe + I : I = F[T - pe.length] + pe + I;
        }
        for (this.isZero() && (I = "0" + I); I.length % E !== 0; )
          I = "0" + I;
        return this.negative !== 0 && (I = "-" + I), I;
      }
      l(!1, "Base should be between 2 and 36");
    }, p.prototype.toNumber = function() {
      var S = this.words[0];
      return this.length === 2 ? S += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? S += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && l(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -S : S;
    }, p.prototype.toJSON = function() {
      return this.toString(16);
    }, p.prototype.toBuffer = function(S, E) {
      return l(typeof _ < "u"), this.toArrayLike(_, S, E);
    }, p.prototype.toArray = function(S, E) {
      return this.toArrayLike(Array, S, E);
    }, p.prototype.toArrayLike = function(S, E, I) {
      var N = this.byteLength(), $ = I || Math.max(1, N);
      l(N <= $, "byte array longer than desired length"), l($ > 0, "Requested array length <= 0"), this.strip();
      var U = E === "le", H = new S($), B, T, D = this.clone();
      if (U) {
        for (T = 0; !D.isZero(); T++)
          B = D.andln(255), D.iushrn(8), H[T] = B;
        for (; T < $; T++)
          H[T] = 0;
      } else {
        for (T = 0; T < $ - N; T++)
          H[T] = 0;
        for (T = 0; !D.isZero(); T++)
          B = D.andln(255), D.iushrn(8), H[$ - T - 1] = B;
      }
      return H;
    }, Math.clz32 ? p.prototype._countBits = function(S) {
      return 32 - Math.clz32(S);
    } : p.prototype._countBits = function(S) {
      var E = S, I = 0;
      return E >= 4096 && (I += 13, E >>>= 13), E >= 64 && (I += 7, E >>>= 7), E >= 8 && (I += 4, E >>>= 4), E >= 2 && (I += 2, E >>>= 2), I + E;
    }, p.prototype._zeroBits = function(S) {
      if (S === 0)
        return 26;
      var E = S, I = 0;
      return E & 8191 || (I += 13, E >>>= 13), E & 127 || (I += 7, E >>>= 7), E & 15 || (I += 4, E >>>= 4), E & 3 || (I += 2, E >>>= 2), E & 1 || I++, I;
    }, p.prototype.bitLength = function() {
      var S = this.words[this.length - 1], E = this._countBits(S);
      return (this.length - 1) * 26 + E;
    };
    function oe(P) {
      for (var S = new Array(P.bitLength()), E = 0; E < S.length; E++) {
        var I = E / 26 | 0, N = E % 26;
        S[E] = (P.words[I] & 1 << N) >>> N;
      }
      return S;
    }
    p.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var S = 0, E = 0; E < this.length; E++) {
        var I = this._zeroBits(this.words[E]);
        if (S += I, I !== 26)
          break;
      }
      return S;
    }, p.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, p.prototype.toTwos = function(S) {
      return this.negative !== 0 ? this.abs().inotn(S).iaddn(1) : this.clone();
    }, p.prototype.fromTwos = function(S) {
      return this.testn(S - 1) ? this.notn(S).iaddn(1).ineg() : this.clone();
    }, p.prototype.isNeg = function() {
      return this.negative !== 0;
    }, p.prototype.neg = function() {
      return this.clone().ineg();
    }, p.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, p.prototype.iuor = function(S) {
      for (; this.length < S.length; )
        this.words[this.length++] = 0;
      for (var E = 0; E < S.length; E++)
        this.words[E] = this.words[E] | S.words[E];
      return this.strip();
    }, p.prototype.ior = function(S) {
      return l((this.negative | S.negative) === 0), this.iuor(S);
    }, p.prototype.or = function(S) {
      return this.length > S.length ? this.clone().ior(S) : S.clone().ior(this);
    }, p.prototype.uor = function(S) {
      return this.length > S.length ? this.clone().iuor(S) : S.clone().iuor(this);
    }, p.prototype.iuand = function(S) {
      var E;
      this.length > S.length ? E = S : E = this;
      for (var I = 0; I < E.length; I++)
        this.words[I] = this.words[I] & S.words[I];
      return this.length = E.length, this.strip();
    }, p.prototype.iand = function(S) {
      return l((this.negative | S.negative) === 0), this.iuand(S);
    }, p.prototype.and = function(S) {
      return this.length > S.length ? this.clone().iand(S) : S.clone().iand(this);
    }, p.prototype.uand = function(S) {
      return this.length > S.length ? this.clone().iuand(S) : S.clone().iuand(this);
    }, p.prototype.iuxor = function(S) {
      var E, I;
      this.length > S.length ? (E = this, I = S) : (E = S, I = this);
      for (var N = 0; N < I.length; N++)
        this.words[N] = E.words[N] ^ I.words[N];
      if (this !== E)
        for (; N < E.length; N++)
          this.words[N] = E.words[N];
      return this.length = E.length, this.strip();
    }, p.prototype.ixor = function(S) {
      return l((this.negative | S.negative) === 0), this.iuxor(S);
    }, p.prototype.xor = function(S) {
      return this.length > S.length ? this.clone().ixor(S) : S.clone().ixor(this);
    }, p.prototype.uxor = function(S) {
      return this.length > S.length ? this.clone().iuxor(S) : S.clone().iuxor(this);
    }, p.prototype.inotn = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = Math.ceil(S / 26) | 0, I = S % 26;
      this._expand(E), I > 0 && E--;
      for (var N = 0; N < E; N++)
        this.words[N] = ~this.words[N] & 67108863;
      return I > 0 && (this.words[N] = ~this.words[N] & 67108863 >> 26 - I), this.strip();
    }, p.prototype.notn = function(S) {
      return this.clone().inotn(S);
    }, p.prototype.setn = function(S, E) {
      l(typeof S == "number" && S >= 0);
      var I = S / 26 | 0, N = S % 26;
      return this._expand(I + 1), E ? this.words[I] = this.words[I] | 1 << N : this.words[I] = this.words[I] & ~(1 << N), this.strip();
    }, p.prototype.iadd = function(S) {
      var E;
      if (this.negative !== 0 && S.negative === 0)
        return this.negative = 0, E = this.isub(S), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && S.negative !== 0)
        return S.negative = 0, E = this.isub(S), S.negative = 1, E._normSign();
      var I, N;
      this.length > S.length ? (I = this, N = S) : (I = S, N = this);
      for (var $ = 0, U = 0; U < N.length; U++)
        E = (I.words[U] | 0) + (N.words[U] | 0) + $, this.words[U] = E & 67108863, $ = E >>> 26;
      for (; $ !== 0 && U < I.length; U++)
        E = (I.words[U] | 0) + $, this.words[U] = E & 67108863, $ = E >>> 26;
      if (this.length = I.length, $ !== 0)
        this.words[this.length] = $, this.length++;
      else if (I !== this)
        for (; U < I.length; U++)
          this.words[U] = I.words[U];
      return this;
    }, p.prototype.add = function(S) {
      var E;
      return S.negative !== 0 && this.negative === 0 ? (S.negative = 0, E = this.sub(S), S.negative ^= 1, E) : S.negative === 0 && this.negative !== 0 ? (this.negative = 0, E = S.sub(this), this.negative = 1, E) : this.length > S.length ? this.clone().iadd(S) : S.clone().iadd(this);
    }, p.prototype.isub = function(S) {
      if (S.negative !== 0) {
        S.negative = 0;
        var E = this.iadd(S);
        return S.negative = 1, E._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(S), this.negative = 1, this._normSign();
      var I = this.cmp(S);
      if (I === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var N, $;
      I > 0 ? (N = this, $ = S) : (N = S, $ = this);
      for (var U = 0, H = 0; H < $.length; H++)
        E = (N.words[H] | 0) - ($.words[H] | 0) + U, U = E >> 26, this.words[H] = E & 67108863;
      for (; U !== 0 && H < N.length; H++)
        E = (N.words[H] | 0) + U, U = E >> 26, this.words[H] = E & 67108863;
      if (U === 0 && H < N.length && N !== this)
        for (; H < N.length; H++)
          this.words[H] = N.words[H];
      return this.length = Math.max(this.length, H), N !== this && (this.negative = 1), this.strip();
    }, p.prototype.sub = function(S) {
      return this.clone().isub(S);
    };
    function Y(P, S, E) {
      E.negative = S.negative ^ P.negative;
      var I = P.length + S.length | 0;
      E.length = I, I = I - 1 | 0;
      var N = P.words[0] | 0, $ = S.words[0] | 0, U = N * $, H = U & 67108863, B = U / 67108864 | 0;
      E.words[0] = H;
      for (var T = 1; T < I; T++) {
        for (var D = B >>> 26, ee = B & 67108863, pe = Math.min(T, S.length - 1), Ie = Math.max(0, T - P.length + 1); Ie <= pe; Ie++) {
          var Pe = T - Ie | 0;
          N = P.words[Pe] | 0, $ = S.words[Ie] | 0, U = N * $ + ee, D += U / 67108864 | 0, ee = U & 67108863;
        }
        E.words[T] = ee | 0, B = D | 0;
      }
      return B !== 0 ? E.words[T] = B | 0 : E.length--, E.strip();
    }
    var ae = function(S, E, I) {
      var N = S.words, $ = E.words, U = I.words, H = 0, B, T, D, ee = N[0] | 0, pe = ee & 8191, Ie = ee >>> 13, Pe = N[1] | 0, he = Pe & 8191, ve = Pe >>> 13, Q = N[2] | 0, le = Q & 8191, _e = Q >>> 13, re = N[3] | 0, O = re & 8191, j = re >>> 13, ce = N[4] | 0, De = ce & 8191, Ne = ce >>> 13, Fe = N[5] | 0, Ze = Fe & 8191, qe = Fe >>> 13, gt = N[6] | 0, Xe = gt & 8191, Ge = gt >>> 13, J = N[7] | 0, ye = J & 8191, we = J >>> 13, We = N[8] | 0, Re = We & 8191, q = We >>> 13, ke = N[9] | 0, de = ke & 8191, ue = ke >>> 13, me = $[0] | 0, Oe = me & 8191, Ue = me >>> 13, ze = $[1] | 0, Ve = ze & 8191, Qe = ze >>> 13, Ke = $[2] | 0, x = Ke & 8191, se = Ke >>> 13, Ee = $[3] | 0, xe = Ee & 8191, $e = Ee >>> 13, Ye = $[4] | 0, et = Ye & 8191, dt = Ye >>> 13, St = $[5] | 0, tt = St & 8191, at = St >>> 13, wt = $[6] | 0, rt = wt & 8191, ut = wt >>> 13, kt = $[7] | 0, nt = kt & 8191, it = kt >>> 13, bt = $[8] | 0, ot = bt & 8191, ct = bt >>> 13, Ot = $[9] | 0, st = Ot & 8191, lt = Ot >>> 13;
      I.negative = S.negative ^ E.negative, I.length = 19, B = Math.imul(pe, Oe), T = Math.imul(pe, Ue), T = T + Math.imul(Ie, Oe) | 0, D = Math.imul(Ie, Ue);
      var Rt = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (Rt >>> 26) | 0, Rt &= 67108863, B = Math.imul(he, Oe), T = Math.imul(he, Ue), T = T + Math.imul(ve, Oe) | 0, D = Math.imul(ve, Ue), B = B + Math.imul(pe, Ve) | 0, T = T + Math.imul(pe, Qe) | 0, T = T + Math.imul(Ie, Ve) | 0, D = D + Math.imul(Ie, Qe) | 0;
      var Ct = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (Ct >>> 26) | 0, Ct &= 67108863, B = Math.imul(le, Oe), T = Math.imul(le, Ue), T = T + Math.imul(_e, Oe) | 0, D = Math.imul(_e, Ue), B = B + Math.imul(he, Ve) | 0, T = T + Math.imul(he, Qe) | 0, T = T + Math.imul(ve, Ve) | 0, D = D + Math.imul(ve, Qe) | 0, B = B + Math.imul(pe, x) | 0, T = T + Math.imul(pe, se) | 0, T = T + Math.imul(Ie, x) | 0, D = D + Math.imul(Ie, se) | 0;
      var Je = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, B = Math.imul(O, Oe), T = Math.imul(O, Ue), T = T + Math.imul(j, Oe) | 0, D = Math.imul(j, Ue), B = B + Math.imul(le, Ve) | 0, T = T + Math.imul(le, Qe) | 0, T = T + Math.imul(_e, Ve) | 0, D = D + Math.imul(_e, Qe) | 0, B = B + Math.imul(he, x) | 0, T = T + Math.imul(he, se) | 0, T = T + Math.imul(ve, x) | 0, D = D + Math.imul(ve, se) | 0, B = B + Math.imul(pe, xe) | 0, T = T + Math.imul(pe, $e) | 0, T = T + Math.imul(Ie, xe) | 0, D = D + Math.imul(Ie, $e) | 0;
      var He = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, B = Math.imul(De, Oe), T = Math.imul(De, Ue), T = T + Math.imul(Ne, Oe) | 0, D = Math.imul(Ne, Ue), B = B + Math.imul(O, Ve) | 0, T = T + Math.imul(O, Qe) | 0, T = T + Math.imul(j, Ve) | 0, D = D + Math.imul(j, Qe) | 0, B = B + Math.imul(le, x) | 0, T = T + Math.imul(le, se) | 0, T = T + Math.imul(_e, x) | 0, D = D + Math.imul(_e, se) | 0, B = B + Math.imul(he, xe) | 0, T = T + Math.imul(he, $e) | 0, T = T + Math.imul(ve, xe) | 0, D = D + Math.imul(ve, $e) | 0, B = B + Math.imul(pe, et) | 0, T = T + Math.imul(pe, dt) | 0, T = T + Math.imul(Ie, et) | 0, D = D + Math.imul(Ie, dt) | 0;
      var je = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, B = Math.imul(Ze, Oe), T = Math.imul(Ze, Ue), T = T + Math.imul(qe, Oe) | 0, D = Math.imul(qe, Ue), B = B + Math.imul(De, Ve) | 0, T = T + Math.imul(De, Qe) | 0, T = T + Math.imul(Ne, Ve) | 0, D = D + Math.imul(Ne, Qe) | 0, B = B + Math.imul(O, x) | 0, T = T + Math.imul(O, se) | 0, T = T + Math.imul(j, x) | 0, D = D + Math.imul(j, se) | 0, B = B + Math.imul(le, xe) | 0, T = T + Math.imul(le, $e) | 0, T = T + Math.imul(_e, xe) | 0, D = D + Math.imul(_e, $e) | 0, B = B + Math.imul(he, et) | 0, T = T + Math.imul(he, dt) | 0, T = T + Math.imul(ve, et) | 0, D = D + Math.imul(ve, dt) | 0, B = B + Math.imul(pe, tt) | 0, T = T + Math.imul(pe, at) | 0, T = T + Math.imul(Ie, tt) | 0, D = D + Math.imul(Ie, at) | 0;
      var pt = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (pt >>> 26) | 0, pt &= 67108863, B = Math.imul(Xe, Oe), T = Math.imul(Xe, Ue), T = T + Math.imul(Ge, Oe) | 0, D = Math.imul(Ge, Ue), B = B + Math.imul(Ze, Ve) | 0, T = T + Math.imul(Ze, Qe) | 0, T = T + Math.imul(qe, Ve) | 0, D = D + Math.imul(qe, Qe) | 0, B = B + Math.imul(De, x) | 0, T = T + Math.imul(De, se) | 0, T = T + Math.imul(Ne, x) | 0, D = D + Math.imul(Ne, se) | 0, B = B + Math.imul(O, xe) | 0, T = T + Math.imul(O, $e) | 0, T = T + Math.imul(j, xe) | 0, D = D + Math.imul(j, $e) | 0, B = B + Math.imul(le, et) | 0, T = T + Math.imul(le, dt) | 0, T = T + Math.imul(_e, et) | 0, D = D + Math.imul(_e, dt) | 0, B = B + Math.imul(he, tt) | 0, T = T + Math.imul(he, at) | 0, T = T + Math.imul(ve, tt) | 0, D = D + Math.imul(ve, at) | 0, B = B + Math.imul(pe, rt) | 0, T = T + Math.imul(pe, ut) | 0, T = T + Math.imul(Ie, rt) | 0, D = D + Math.imul(Ie, ut) | 0;
      var mt = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (mt >>> 26) | 0, mt &= 67108863, B = Math.imul(ye, Oe), T = Math.imul(ye, Ue), T = T + Math.imul(we, Oe) | 0, D = Math.imul(we, Ue), B = B + Math.imul(Xe, Ve) | 0, T = T + Math.imul(Xe, Qe) | 0, T = T + Math.imul(Ge, Ve) | 0, D = D + Math.imul(Ge, Qe) | 0, B = B + Math.imul(Ze, x) | 0, T = T + Math.imul(Ze, se) | 0, T = T + Math.imul(qe, x) | 0, D = D + Math.imul(qe, se) | 0, B = B + Math.imul(De, xe) | 0, T = T + Math.imul(De, $e) | 0, T = T + Math.imul(Ne, xe) | 0, D = D + Math.imul(Ne, $e) | 0, B = B + Math.imul(O, et) | 0, T = T + Math.imul(O, dt) | 0, T = T + Math.imul(j, et) | 0, D = D + Math.imul(j, dt) | 0, B = B + Math.imul(le, tt) | 0, T = T + Math.imul(le, at) | 0, T = T + Math.imul(_e, tt) | 0, D = D + Math.imul(_e, at) | 0, B = B + Math.imul(he, rt) | 0, T = T + Math.imul(he, ut) | 0, T = T + Math.imul(ve, rt) | 0, D = D + Math.imul(ve, ut) | 0, B = B + Math.imul(pe, nt) | 0, T = T + Math.imul(pe, it) | 0, T = T + Math.imul(Ie, nt) | 0, D = D + Math.imul(Ie, it) | 0;
      var yt = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (yt >>> 26) | 0, yt &= 67108863, B = Math.imul(Re, Oe), T = Math.imul(Re, Ue), T = T + Math.imul(q, Oe) | 0, D = Math.imul(q, Ue), B = B + Math.imul(ye, Ve) | 0, T = T + Math.imul(ye, Qe) | 0, T = T + Math.imul(we, Ve) | 0, D = D + Math.imul(we, Qe) | 0, B = B + Math.imul(Xe, x) | 0, T = T + Math.imul(Xe, se) | 0, T = T + Math.imul(Ge, x) | 0, D = D + Math.imul(Ge, se) | 0, B = B + Math.imul(Ze, xe) | 0, T = T + Math.imul(Ze, $e) | 0, T = T + Math.imul(qe, xe) | 0, D = D + Math.imul(qe, $e) | 0, B = B + Math.imul(De, et) | 0, T = T + Math.imul(De, dt) | 0, T = T + Math.imul(Ne, et) | 0, D = D + Math.imul(Ne, dt) | 0, B = B + Math.imul(O, tt) | 0, T = T + Math.imul(O, at) | 0, T = T + Math.imul(j, tt) | 0, D = D + Math.imul(j, at) | 0, B = B + Math.imul(le, rt) | 0, T = T + Math.imul(le, ut) | 0, T = T + Math.imul(_e, rt) | 0, D = D + Math.imul(_e, ut) | 0, B = B + Math.imul(he, nt) | 0, T = T + Math.imul(he, it) | 0, T = T + Math.imul(ve, nt) | 0, D = D + Math.imul(ve, it) | 0, B = B + Math.imul(pe, ot) | 0, T = T + Math.imul(pe, ct) | 0, T = T + Math.imul(Ie, ot) | 0, D = D + Math.imul(Ie, ct) | 0;
      var ht = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (ht >>> 26) | 0, ht &= 67108863, B = Math.imul(de, Oe), T = Math.imul(de, Ue), T = T + Math.imul(ue, Oe) | 0, D = Math.imul(ue, Ue), B = B + Math.imul(Re, Ve) | 0, T = T + Math.imul(Re, Qe) | 0, T = T + Math.imul(q, Ve) | 0, D = D + Math.imul(q, Qe) | 0, B = B + Math.imul(ye, x) | 0, T = T + Math.imul(ye, se) | 0, T = T + Math.imul(we, x) | 0, D = D + Math.imul(we, se) | 0, B = B + Math.imul(Xe, xe) | 0, T = T + Math.imul(Xe, $e) | 0, T = T + Math.imul(Ge, xe) | 0, D = D + Math.imul(Ge, $e) | 0, B = B + Math.imul(Ze, et) | 0, T = T + Math.imul(Ze, dt) | 0, T = T + Math.imul(qe, et) | 0, D = D + Math.imul(qe, dt) | 0, B = B + Math.imul(De, tt) | 0, T = T + Math.imul(De, at) | 0, T = T + Math.imul(Ne, tt) | 0, D = D + Math.imul(Ne, at) | 0, B = B + Math.imul(O, rt) | 0, T = T + Math.imul(O, ut) | 0, T = T + Math.imul(j, rt) | 0, D = D + Math.imul(j, ut) | 0, B = B + Math.imul(le, nt) | 0, T = T + Math.imul(le, it) | 0, T = T + Math.imul(_e, nt) | 0, D = D + Math.imul(_e, it) | 0, B = B + Math.imul(he, ot) | 0, T = T + Math.imul(he, ct) | 0, T = T + Math.imul(ve, ot) | 0, D = D + Math.imul(ve, ct) | 0, B = B + Math.imul(pe, st) | 0, T = T + Math.imul(pe, lt) | 0, T = T + Math.imul(Ie, st) | 0, D = D + Math.imul(Ie, lt) | 0;
      var _t = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (_t >>> 26) | 0, _t &= 67108863, B = Math.imul(de, Ve), T = Math.imul(de, Qe), T = T + Math.imul(ue, Ve) | 0, D = Math.imul(ue, Qe), B = B + Math.imul(Re, x) | 0, T = T + Math.imul(Re, se) | 0, T = T + Math.imul(q, x) | 0, D = D + Math.imul(q, se) | 0, B = B + Math.imul(ye, xe) | 0, T = T + Math.imul(ye, $e) | 0, T = T + Math.imul(we, xe) | 0, D = D + Math.imul(we, $e) | 0, B = B + Math.imul(Xe, et) | 0, T = T + Math.imul(Xe, dt) | 0, T = T + Math.imul(Ge, et) | 0, D = D + Math.imul(Ge, dt) | 0, B = B + Math.imul(Ze, tt) | 0, T = T + Math.imul(Ze, at) | 0, T = T + Math.imul(qe, tt) | 0, D = D + Math.imul(qe, at) | 0, B = B + Math.imul(De, rt) | 0, T = T + Math.imul(De, ut) | 0, T = T + Math.imul(Ne, rt) | 0, D = D + Math.imul(Ne, ut) | 0, B = B + Math.imul(O, nt) | 0, T = T + Math.imul(O, it) | 0, T = T + Math.imul(j, nt) | 0, D = D + Math.imul(j, it) | 0, B = B + Math.imul(le, ot) | 0, T = T + Math.imul(le, ct) | 0, T = T + Math.imul(_e, ot) | 0, D = D + Math.imul(_e, ct) | 0, B = B + Math.imul(he, st) | 0, T = T + Math.imul(he, lt) | 0, T = T + Math.imul(ve, st) | 0, D = D + Math.imul(ve, lt) | 0;
      var Et = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, B = Math.imul(de, x), T = Math.imul(de, se), T = T + Math.imul(ue, x) | 0, D = Math.imul(ue, se), B = B + Math.imul(Re, xe) | 0, T = T + Math.imul(Re, $e) | 0, T = T + Math.imul(q, xe) | 0, D = D + Math.imul(q, $e) | 0, B = B + Math.imul(ye, et) | 0, T = T + Math.imul(ye, dt) | 0, T = T + Math.imul(we, et) | 0, D = D + Math.imul(we, dt) | 0, B = B + Math.imul(Xe, tt) | 0, T = T + Math.imul(Xe, at) | 0, T = T + Math.imul(Ge, tt) | 0, D = D + Math.imul(Ge, at) | 0, B = B + Math.imul(Ze, rt) | 0, T = T + Math.imul(Ze, ut) | 0, T = T + Math.imul(qe, rt) | 0, D = D + Math.imul(qe, ut) | 0, B = B + Math.imul(De, nt) | 0, T = T + Math.imul(De, it) | 0, T = T + Math.imul(Ne, nt) | 0, D = D + Math.imul(Ne, it) | 0, B = B + Math.imul(O, ot) | 0, T = T + Math.imul(O, ct) | 0, T = T + Math.imul(j, ot) | 0, D = D + Math.imul(j, ct) | 0, B = B + Math.imul(le, st) | 0, T = T + Math.imul(le, lt) | 0, T = T + Math.imul(_e, st) | 0, D = D + Math.imul(_e, lt) | 0;
      var Nt = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, B = Math.imul(de, xe), T = Math.imul(de, $e), T = T + Math.imul(ue, xe) | 0, D = Math.imul(ue, $e), B = B + Math.imul(Re, et) | 0, T = T + Math.imul(Re, dt) | 0, T = T + Math.imul(q, et) | 0, D = D + Math.imul(q, dt) | 0, B = B + Math.imul(ye, tt) | 0, T = T + Math.imul(ye, at) | 0, T = T + Math.imul(we, tt) | 0, D = D + Math.imul(we, at) | 0, B = B + Math.imul(Xe, rt) | 0, T = T + Math.imul(Xe, ut) | 0, T = T + Math.imul(Ge, rt) | 0, D = D + Math.imul(Ge, ut) | 0, B = B + Math.imul(Ze, nt) | 0, T = T + Math.imul(Ze, it) | 0, T = T + Math.imul(qe, nt) | 0, D = D + Math.imul(qe, it) | 0, B = B + Math.imul(De, ot) | 0, T = T + Math.imul(De, ct) | 0, T = T + Math.imul(Ne, ot) | 0, D = D + Math.imul(Ne, ct) | 0, B = B + Math.imul(O, st) | 0, T = T + Math.imul(O, lt) | 0, T = T + Math.imul(j, st) | 0, D = D + Math.imul(j, lt) | 0;
      var Dt = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (Dt >>> 26) | 0, Dt &= 67108863, B = Math.imul(de, et), T = Math.imul(de, dt), T = T + Math.imul(ue, et) | 0, D = Math.imul(ue, dt), B = B + Math.imul(Re, tt) | 0, T = T + Math.imul(Re, at) | 0, T = T + Math.imul(q, tt) | 0, D = D + Math.imul(q, at) | 0, B = B + Math.imul(ye, rt) | 0, T = T + Math.imul(ye, ut) | 0, T = T + Math.imul(we, rt) | 0, D = D + Math.imul(we, ut) | 0, B = B + Math.imul(Xe, nt) | 0, T = T + Math.imul(Xe, it) | 0, T = T + Math.imul(Ge, nt) | 0, D = D + Math.imul(Ge, it) | 0, B = B + Math.imul(Ze, ot) | 0, T = T + Math.imul(Ze, ct) | 0, T = T + Math.imul(qe, ot) | 0, D = D + Math.imul(qe, ct) | 0, B = B + Math.imul(De, st) | 0, T = T + Math.imul(De, lt) | 0, T = T + Math.imul(Ne, st) | 0, D = D + Math.imul(Ne, lt) | 0;
      var $t = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + ($t >>> 26) | 0, $t &= 67108863, B = Math.imul(de, tt), T = Math.imul(de, at), T = T + Math.imul(ue, tt) | 0, D = Math.imul(ue, at), B = B + Math.imul(Re, rt) | 0, T = T + Math.imul(Re, ut) | 0, T = T + Math.imul(q, rt) | 0, D = D + Math.imul(q, ut) | 0, B = B + Math.imul(ye, nt) | 0, T = T + Math.imul(ye, it) | 0, T = T + Math.imul(we, nt) | 0, D = D + Math.imul(we, it) | 0, B = B + Math.imul(Xe, ot) | 0, T = T + Math.imul(Xe, ct) | 0, T = T + Math.imul(Ge, ot) | 0, D = D + Math.imul(Ge, ct) | 0, B = B + Math.imul(Ze, st) | 0, T = T + Math.imul(Ze, lt) | 0, T = T + Math.imul(qe, st) | 0, D = D + Math.imul(qe, lt) | 0;
      var At = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, B = Math.imul(de, rt), T = Math.imul(de, ut), T = T + Math.imul(ue, rt) | 0, D = Math.imul(ue, ut), B = B + Math.imul(Re, nt) | 0, T = T + Math.imul(Re, it) | 0, T = T + Math.imul(q, nt) | 0, D = D + Math.imul(q, it) | 0, B = B + Math.imul(ye, ot) | 0, T = T + Math.imul(ye, ct) | 0, T = T + Math.imul(we, ot) | 0, D = D + Math.imul(we, ct) | 0, B = B + Math.imul(Xe, st) | 0, T = T + Math.imul(Xe, lt) | 0, T = T + Math.imul(Ge, st) | 0, D = D + Math.imul(Ge, lt) | 0;
      var Lt = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (Lt >>> 26) | 0, Lt &= 67108863, B = Math.imul(de, nt), T = Math.imul(de, it), T = T + Math.imul(ue, nt) | 0, D = Math.imul(ue, it), B = B + Math.imul(Re, ot) | 0, T = T + Math.imul(Re, ct) | 0, T = T + Math.imul(q, ot) | 0, D = D + Math.imul(q, ct) | 0, B = B + Math.imul(ye, st) | 0, T = T + Math.imul(ye, lt) | 0, T = T + Math.imul(we, st) | 0, D = D + Math.imul(we, lt) | 0;
      var Bt = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, B = Math.imul(de, ot), T = Math.imul(de, ct), T = T + Math.imul(ue, ot) | 0, D = Math.imul(ue, ct), B = B + Math.imul(Re, st) | 0, T = T + Math.imul(Re, lt) | 0, T = T + Math.imul(q, st) | 0, D = D + Math.imul(q, lt) | 0;
      var Ut = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (Ut >>> 26) | 0, Ut &= 67108863, B = Math.imul(de, st), T = Math.imul(de, lt), T = T + Math.imul(ue, st) | 0, D = Math.imul(ue, lt);
      var xt = (H + B | 0) + ((T & 8191) << 13) | 0;
      return H = (D + (T >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, U[0] = Rt, U[1] = Ct, U[2] = Je, U[3] = He, U[4] = je, U[5] = pt, U[6] = mt, U[7] = yt, U[8] = ht, U[9] = _t, U[10] = Et, U[11] = Nt, U[12] = Dt, U[13] = $t, U[14] = At, U[15] = Lt, U[16] = Bt, U[17] = Ut, U[18] = xt, H !== 0 && (U[19] = H, I.length++), I;
    };
    Math.imul || (ae = Y);
    function ne(P, S, E) {
      E.negative = S.negative ^ P.negative, E.length = P.length + S.length;
      for (var I = 0, N = 0, $ = 0; $ < E.length - 1; $++) {
        var U = N;
        N = 0;
        for (var H = I & 67108863, B = Math.min($, S.length - 1), T = Math.max(0, $ - P.length + 1); T <= B; T++) {
          var D = $ - T, ee = P.words[D] | 0, pe = S.words[T] | 0, Ie = ee * pe, Pe = Ie & 67108863;
          U = U + (Ie / 67108864 | 0) | 0, Pe = Pe + H | 0, H = Pe & 67108863, U = U + (Pe >>> 26) | 0, N += U >>> 26, U &= 67108863;
        }
        E.words[$] = H, I = U, U = N;
      }
      return I !== 0 ? E.words[$] = I : E.length--, E.strip();
    }
    function fe(P, S, E) {
      var I = new ie();
      return I.mulp(P, S, E);
    }
    p.prototype.mulTo = function(S, E) {
      var I, N = this.length + S.length;
      return this.length === 10 && S.length === 10 ? I = ae(this, S, E) : N < 63 ? I = Y(this, S, E) : N < 1024 ? I = ne(this, S, E) : I = fe(this, S, E), I;
    };
    function ie(P, S) {
      this.x = P, this.y = S;
    }
    ie.prototype.makeRBT = function(S) {
      for (var E = new Array(S), I = p.prototype._countBits(S) - 1, N = 0; N < S; N++)
        E[N] = this.revBin(N, I, S);
      return E;
    }, ie.prototype.revBin = function(S, E, I) {
      if (S === 0 || S === I - 1)
        return S;
      for (var N = 0, $ = 0; $ < E; $++)
        N |= (S & 1) << E - $ - 1, S >>= 1;
      return N;
    }, ie.prototype.permute = function(S, E, I, N, $, U) {
      for (var H = 0; H < U; H++)
        N[H] = E[S[H]], $[H] = I[S[H]];
    }, ie.prototype.transform = function(S, E, I, N, $, U) {
      this.permute(U, S, E, I, N, $);
      for (var H = 1; H < $; H <<= 1)
        for (var B = H << 1, T = Math.cos(2 * Math.PI / B), D = Math.sin(2 * Math.PI / B), ee = 0; ee < $; ee += B)
          for (var pe = T, Ie = D, Pe = 0; Pe < H; Pe++) {
            var he = I[ee + Pe], ve = N[ee + Pe], Q = I[ee + Pe + H], le = N[ee + Pe + H], _e = pe * Q - Ie * le;
            le = pe * le + Ie * Q, Q = _e, I[ee + Pe] = he + Q, N[ee + Pe] = ve + le, I[ee + Pe + H] = he - Q, N[ee + Pe + H] = ve - le, Pe !== B && (_e = T * pe - D * Ie, Ie = T * Ie + D * pe, pe = _e);
          }
    }, ie.prototype.guessLen13b = function(S, E) {
      var I = Math.max(E, S) | 1, N = I & 1, $ = 0;
      for (I = I / 2 | 0; I; I = I >>> 1)
        $++;
      return 1 << $ + 1 + N;
    }, ie.prototype.conjugate = function(S, E, I) {
      if (!(I <= 1))
        for (var N = 0; N < I / 2; N++) {
          var $ = S[N];
          S[N] = S[I - N - 1], S[I - N - 1] = $, $ = E[N], E[N] = -E[I - N - 1], E[I - N - 1] = -$;
        }
    }, ie.prototype.normalize13b = function(S, E) {
      for (var I = 0, N = 0; N < E / 2; N++) {
        var $ = Math.round(S[2 * N + 1] / E) * 8192 + Math.round(S[2 * N] / E) + I;
        S[N] = $ & 67108863, $ < 67108864 ? I = 0 : I = $ / 67108864 | 0;
      }
      return S;
    }, ie.prototype.convert13b = function(S, E, I, N) {
      for (var $ = 0, U = 0; U < E; U++)
        $ = $ + (S[U] | 0), I[2 * U] = $ & 8191, $ = $ >>> 13, I[2 * U + 1] = $ & 8191, $ = $ >>> 13;
      for (U = 2 * E; U < N; ++U)
        I[U] = 0;
      l($ === 0), l(($ & -8192) === 0);
    }, ie.prototype.stub = function(S) {
      for (var E = new Array(S), I = 0; I < S; I++)
        E[I] = 0;
      return E;
    }, ie.prototype.mulp = function(S, E, I) {
      var N = 2 * this.guessLen13b(S.length, E.length), $ = this.makeRBT(N), U = this.stub(N), H = new Array(N), B = new Array(N), T = new Array(N), D = new Array(N), ee = new Array(N), pe = new Array(N), Ie = I.words;
      Ie.length = N, this.convert13b(S.words, S.length, H, N), this.convert13b(E.words, E.length, D, N), this.transform(H, U, B, T, N, $), this.transform(D, U, ee, pe, N, $);
      for (var Pe = 0; Pe < N; Pe++) {
        var he = B[Pe] * ee[Pe] - T[Pe] * pe[Pe];
        T[Pe] = B[Pe] * pe[Pe] + T[Pe] * ee[Pe], B[Pe] = he;
      }
      return this.conjugate(B, T, N), this.transform(B, T, Ie, U, N, $), this.conjugate(Ie, U, N), this.normalize13b(Ie, N), I.negative = S.negative ^ E.negative, I.length = S.length + E.length, I.strip();
    }, p.prototype.mul = function(S) {
      var E = new p(null);
      return E.words = new Array(this.length + S.length), this.mulTo(S, E);
    }, p.prototype.mulf = function(S) {
      var E = new p(null);
      return E.words = new Array(this.length + S.length), fe(this, S, E);
    }, p.prototype.imul = function(S) {
      return this.clone().mulTo(S, this);
    }, p.prototype.imuln = function(S) {
      l(typeof S == "number"), l(S < 67108864);
      for (var E = 0, I = 0; I < this.length; I++) {
        var N = (this.words[I] | 0) * S, $ = (N & 67108863) + (E & 67108863);
        E >>= 26, E += N / 67108864 | 0, E += $ >>> 26, this.words[I] = $ & 67108863;
      }
      return E !== 0 && (this.words[I] = E, this.length++), this;
    }, p.prototype.muln = function(S) {
      return this.clone().imuln(S);
    }, p.prototype.sqr = function() {
      return this.mul(this);
    }, p.prototype.isqr = function() {
      return this.imul(this.clone());
    }, p.prototype.pow = function(S) {
      var E = oe(S);
      if (E.length === 0)
        return new p(1);
      for (var I = this, N = 0; N < E.length && E[N] === 0; N++, I = I.sqr())
        ;
      if (++N < E.length)
        for (var $ = I.sqr(); N < E.length; N++, $ = $.sqr())
          E[N] !== 0 && (I = I.mul($));
      return I;
    }, p.prototype.iushln = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = S % 26, I = (S - E) / 26, N = 67108863 >>> 26 - E << 26 - E, $;
      if (E !== 0) {
        var U = 0;
        for ($ = 0; $ < this.length; $++) {
          var H = this.words[$] & N, B = (this.words[$] | 0) - H << E;
          this.words[$] = B | U, U = H >>> 26 - E;
        }
        U && (this.words[$] = U, this.length++);
      }
      if (I !== 0) {
        for ($ = this.length - 1; $ >= 0; $--)
          this.words[$ + I] = this.words[$];
        for ($ = 0; $ < I; $++)
          this.words[$] = 0;
        this.length += I;
      }
      return this.strip();
    }, p.prototype.ishln = function(S) {
      return l(this.negative === 0), this.iushln(S);
    }, p.prototype.iushrn = function(S, E, I) {
      l(typeof S == "number" && S >= 0);
      var N;
      E ? N = (E - E % 26) / 26 : N = 0;
      var $ = S % 26, U = Math.min((S - $) / 26, this.length), H = 67108863 ^ 67108863 >>> $ << $, B = I;
      if (N -= U, N = Math.max(0, N), B) {
        for (var T = 0; T < U; T++)
          B.words[T] = this.words[T];
        B.length = U;
      }
      if (U !== 0)
        if (this.length > U)
          for (this.length -= U, T = 0; T < this.length; T++)
            this.words[T] = this.words[T + U];
        else
          this.words[0] = 0, this.length = 1;
      var D = 0;
      for (T = this.length - 1; T >= 0 && (D !== 0 || T >= N); T--) {
        var ee = this.words[T] | 0;
        this.words[T] = D << 26 - $ | ee >>> $, D = ee & H;
      }
      return B && D !== 0 && (B.words[B.length++] = D), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, p.prototype.ishrn = function(S, E, I) {
      return l(this.negative === 0), this.iushrn(S, E, I);
    }, p.prototype.shln = function(S) {
      return this.clone().ishln(S);
    }, p.prototype.ushln = function(S) {
      return this.clone().iushln(S);
    }, p.prototype.shrn = function(S) {
      return this.clone().ishrn(S);
    }, p.prototype.ushrn = function(S) {
      return this.clone().iushrn(S);
    }, p.prototype.testn = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = S % 26, I = (S - E) / 26, N = 1 << E;
      if (this.length <= I)
        return !1;
      var $ = this.words[I];
      return !!($ & N);
    }, p.prototype.imaskn = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = S % 26, I = (S - E) / 26;
      if (l(this.negative === 0, "imaskn works only with positive numbers"), this.length <= I)
        return this;
      if (E !== 0 && I++, this.length = Math.min(I, this.length), E !== 0) {
        var N = 67108863 ^ 67108863 >>> E << E;
        this.words[this.length - 1] &= N;
      }
      return this.strip();
    }, p.prototype.maskn = function(S) {
      return this.clone().imaskn(S);
    }, p.prototype.iaddn = function(S) {
      return l(typeof S == "number"), l(S < 67108864), S < 0 ? this.isubn(-S) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < S ? (this.words[0] = S - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(S), this.negative = 1, this) : this._iaddn(S);
    }, p.prototype._iaddn = function(S) {
      this.words[0] += S;
      for (var E = 0; E < this.length && this.words[E] >= 67108864; E++)
        this.words[E] -= 67108864, E === this.length - 1 ? this.words[E + 1] = 1 : this.words[E + 1]++;
      return this.length = Math.max(this.length, E + 1), this;
    }, p.prototype.isubn = function(S) {
      if (l(typeof S == "number"), l(S < 67108864), S < 0)
        return this.iaddn(-S);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(S), this.negative = 1, this;
      if (this.words[0] -= S, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var E = 0; E < this.length && this.words[E] < 0; E++)
          this.words[E] += 67108864, this.words[E + 1] -= 1;
      return this.strip();
    }, p.prototype.addn = function(S) {
      return this.clone().iaddn(S);
    }, p.prototype.subn = function(S) {
      return this.clone().isubn(S);
    }, p.prototype.iabs = function() {
      return this.negative = 0, this;
    }, p.prototype.abs = function() {
      return this.clone().iabs();
    }, p.prototype._ishlnsubmul = function(S, E, I) {
      var N = S.length + I, $;
      this._expand(N);
      var U, H = 0;
      for ($ = 0; $ < S.length; $++) {
        U = (this.words[$ + I] | 0) + H;
        var B = (S.words[$] | 0) * E;
        U -= B & 67108863, H = (U >> 26) - (B / 67108864 | 0), this.words[$ + I] = U & 67108863;
      }
      for (; $ < this.length - I; $++)
        U = (this.words[$ + I] | 0) + H, H = U >> 26, this.words[$ + I] = U & 67108863;
      if (H === 0)
        return this.strip();
      for (l(H === -1), H = 0, $ = 0; $ < this.length; $++)
        U = -(this.words[$] | 0) + H, H = U >> 26, this.words[$] = U & 67108863;
      return this.negative = 1, this.strip();
    }, p.prototype._wordDiv = function(S, E) {
      var I = this.length - S.length, N = this.clone(), $ = S, U = $.words[$.length - 1] | 0, H = this._countBits(U);
      I = 26 - H, I !== 0 && ($ = $.ushln(I), N.iushln(I), U = $.words[$.length - 1] | 0);
      var B = N.length - $.length, T;
      if (E !== "mod") {
        T = new p(null), T.length = B + 1, T.words = new Array(T.length);
        for (var D = 0; D < T.length; D++)
          T.words[D] = 0;
      }
      var ee = N.clone()._ishlnsubmul($, 1, B);
      ee.negative === 0 && (N = ee, T && (T.words[B] = 1));
      for (var pe = B - 1; pe >= 0; pe--) {
        var Ie = (N.words[$.length + pe] | 0) * 67108864 + (N.words[$.length + pe - 1] | 0);
        for (Ie = Math.min(Ie / U | 0, 67108863), N._ishlnsubmul($, Ie, pe); N.negative !== 0; )
          Ie--, N.negative = 0, N._ishlnsubmul($, 1, pe), N.isZero() || (N.negative ^= 1);
        T && (T.words[pe] = Ie);
      }
      return T && T.strip(), N.strip(), E !== "div" && I !== 0 && N.iushrn(I), {
        div: T || null,
        mod: N
      };
    }, p.prototype.divmod = function(S, E, I) {
      if (l(!S.isZero()), this.isZero())
        return {
          div: new p(0),
          mod: new p(0)
        };
      var N, $, U;
      return this.negative !== 0 && S.negative === 0 ? (U = this.neg().divmod(S, E), E !== "mod" && (N = U.div.neg()), E !== "div" && ($ = U.mod.neg(), I && $.negative !== 0 && $.iadd(S)), {
        div: N,
        mod: $
      }) : this.negative === 0 && S.negative !== 0 ? (U = this.divmod(S.neg(), E), E !== "mod" && (N = U.div.neg()), {
        div: N,
        mod: U.mod
      }) : this.negative & S.negative ? (U = this.neg().divmod(S.neg(), E), E !== "div" && ($ = U.mod.neg(), I && $.negative !== 0 && $.isub(S)), {
        div: U.div,
        mod: $
      }) : S.length > this.length || this.cmp(S) < 0 ? {
        div: new p(0),
        mod: this
      } : S.length === 1 ? E === "div" ? {
        div: this.divn(S.words[0]),
        mod: null
      } : E === "mod" ? {
        div: null,
        mod: new p(this.modn(S.words[0]))
      } : {
        div: this.divn(S.words[0]),
        mod: new p(this.modn(S.words[0]))
      } : this._wordDiv(S, E);
    }, p.prototype.div = function(S) {
      return this.divmod(S, "div", !1).div;
    }, p.prototype.mod = function(S) {
      return this.divmod(S, "mod", !1).mod;
    }, p.prototype.umod = function(S) {
      return this.divmod(S, "mod", !0).mod;
    }, p.prototype.divRound = function(S) {
      var E = this.divmod(S);
      if (E.mod.isZero())
        return E.div;
      var I = E.div.negative !== 0 ? E.mod.isub(S) : E.mod, N = S.ushrn(1), $ = S.andln(1), U = I.cmp(N);
      return U < 0 || $ === 1 && U === 0 ? E.div : E.div.negative !== 0 ? E.div.isubn(1) : E.div.iaddn(1);
    }, p.prototype.modn = function(S) {
      l(S <= 67108863);
      for (var E = (1 << 26) % S, I = 0, N = this.length - 1; N >= 0; N--)
        I = (E * I + (this.words[N] | 0)) % S;
      return I;
    }, p.prototype.idivn = function(S) {
      l(S <= 67108863);
      for (var E = 0, I = this.length - 1; I >= 0; I--) {
        var N = (this.words[I] | 0) + E * 67108864;
        this.words[I] = N / S | 0, E = N % S;
      }
      return this.strip();
    }, p.prototype.divn = function(S) {
      return this.clone().idivn(S);
    }, p.prototype.egcd = function(S) {
      l(S.negative === 0), l(!S.isZero());
      var E = this, I = S.clone();
      E.negative !== 0 ? E = E.umod(S) : E = E.clone();
      for (var N = new p(1), $ = new p(0), U = new p(0), H = new p(1), B = 0; E.isEven() && I.isEven(); )
        E.iushrn(1), I.iushrn(1), ++B;
      for (var T = I.clone(), D = E.clone(); !E.isZero(); ) {
        for (var ee = 0, pe = 1; !(E.words[0] & pe) && ee < 26; ++ee, pe <<= 1)
          ;
        if (ee > 0)
          for (E.iushrn(ee); ee-- > 0; )
            (N.isOdd() || $.isOdd()) && (N.iadd(T), $.isub(D)), N.iushrn(1), $.iushrn(1);
        for (var Ie = 0, Pe = 1; !(I.words[0] & Pe) && Ie < 26; ++Ie, Pe <<= 1)
          ;
        if (Ie > 0)
          for (I.iushrn(Ie); Ie-- > 0; )
            (U.isOdd() || H.isOdd()) && (U.iadd(T), H.isub(D)), U.iushrn(1), H.iushrn(1);
        E.cmp(I) >= 0 ? (E.isub(I), N.isub(U), $.isub(H)) : (I.isub(E), U.isub(N), H.isub($));
      }
      return {
        a: U,
        b: H,
        gcd: I.iushln(B)
      };
    }, p.prototype._invmp = function(S) {
      l(S.negative === 0), l(!S.isZero());
      var E = this, I = S.clone();
      E.negative !== 0 ? E = E.umod(S) : E = E.clone();
      for (var N = new p(1), $ = new p(0), U = I.clone(); E.cmpn(1) > 0 && I.cmpn(1) > 0; ) {
        for (var H = 0, B = 1; !(E.words[0] & B) && H < 26; ++H, B <<= 1)
          ;
        if (H > 0)
          for (E.iushrn(H); H-- > 0; )
            N.isOdd() && N.iadd(U), N.iushrn(1);
        for (var T = 0, D = 1; !(I.words[0] & D) && T < 26; ++T, D <<= 1)
          ;
        if (T > 0)
          for (I.iushrn(T); T-- > 0; )
            $.isOdd() && $.iadd(U), $.iushrn(1);
        E.cmp(I) >= 0 ? (E.isub(I), N.isub($)) : (I.isub(E), $.isub(N));
      }
      var ee;
      return E.cmpn(1) === 0 ? ee = N : ee = $, ee.cmpn(0) < 0 && ee.iadd(S), ee;
    }, p.prototype.gcd = function(S) {
      if (this.isZero())
        return S.abs();
      if (S.isZero())
        return this.abs();
      var E = this.clone(), I = S.clone();
      E.negative = 0, I.negative = 0;
      for (var N = 0; E.isEven() && I.isEven(); N++)
        E.iushrn(1), I.iushrn(1);
      do {
        for (; E.isEven(); )
          E.iushrn(1);
        for (; I.isEven(); )
          I.iushrn(1);
        var $ = E.cmp(I);
        if ($ < 0) {
          var U = E;
          E = I, I = U;
        } else if ($ === 0 || I.cmpn(1) === 0)
          break;
        E.isub(I);
      } while (!0);
      return I.iushln(N);
    }, p.prototype.invm = function(S) {
      return this.egcd(S).a.umod(S);
    }, p.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, p.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, p.prototype.andln = function(S) {
      return this.words[0] & S;
    }, p.prototype.bincn = function(S) {
      l(typeof S == "number");
      var E = S % 26, I = (S - E) / 26, N = 1 << E;
      if (this.length <= I)
        return this._expand(I + 1), this.words[I] |= N, this;
      for (var $ = N, U = I; $ !== 0 && U < this.length; U++) {
        var H = this.words[U] | 0;
        H += $, $ = H >>> 26, H &= 67108863, this.words[U] = H;
      }
      return $ !== 0 && (this.words[U] = $, this.length++), this;
    }, p.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, p.prototype.cmpn = function(S) {
      var E = S < 0;
      if (this.negative !== 0 && !E)
        return -1;
      if (this.negative === 0 && E)
        return 1;
      this.strip();
      var I;
      if (this.length > 1)
        I = 1;
      else {
        E && (S = -S), l(S <= 67108863, "Number is too big");
        var N = this.words[0] | 0;
        I = N === S ? 0 : N < S ? -1 : 1;
      }
      return this.negative !== 0 ? -I | 0 : I;
    }, p.prototype.cmp = function(S) {
      if (this.negative !== 0 && S.negative === 0)
        return -1;
      if (this.negative === 0 && S.negative !== 0)
        return 1;
      var E = this.ucmp(S);
      return this.negative !== 0 ? -E | 0 : E;
    }, p.prototype.ucmp = function(S) {
      if (this.length > S.length)
        return 1;
      if (this.length < S.length)
        return -1;
      for (var E = 0, I = this.length - 1; I >= 0; I--) {
        var N = this.words[I] | 0, $ = S.words[I] | 0;
        if (N !== $) {
          N < $ ? E = -1 : N > $ && (E = 1);
          break;
        }
      }
      return E;
    }, p.prototype.gtn = function(S) {
      return this.cmpn(S) === 1;
    }, p.prototype.gt = function(S) {
      return this.cmp(S) === 1;
    }, p.prototype.gten = function(S) {
      return this.cmpn(S) >= 0;
    }, p.prototype.gte = function(S) {
      return this.cmp(S) >= 0;
    }, p.prototype.ltn = function(S) {
      return this.cmpn(S) === -1;
    }, p.prototype.lt = function(S) {
      return this.cmp(S) === -1;
    }, p.prototype.lten = function(S) {
      return this.cmpn(S) <= 0;
    }, p.prototype.lte = function(S) {
      return this.cmp(S) <= 0;
    }, p.prototype.eqn = function(S) {
      return this.cmpn(S) === 0;
    }, p.prototype.eq = function(S) {
      return this.cmp(S) === 0;
    }, p.red = function(S) {
      return new Z(S);
    }, p.prototype.toRed = function(S) {
      return l(!this.red, "Already a number in reduction context"), l(this.negative === 0, "red works only with positives"), S.convertTo(this)._forceRed(S);
    }, p.prototype.fromRed = function() {
      return l(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, p.prototype._forceRed = function(S) {
      return this.red = S, this;
    }, p.prototype.forceRed = function(S) {
      return l(!this.red, "Already a number in reduction context"), this._forceRed(S);
    }, p.prototype.redAdd = function(S) {
      return l(this.red, "redAdd works only with red numbers"), this.red.add(this, S);
    }, p.prototype.redIAdd = function(S) {
      return l(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, S);
    }, p.prototype.redSub = function(S) {
      return l(this.red, "redSub works only with red numbers"), this.red.sub(this, S);
    }, p.prototype.redISub = function(S) {
      return l(this.red, "redISub works only with red numbers"), this.red.isub(this, S);
    }, p.prototype.redShl = function(S) {
      return l(this.red, "redShl works only with red numbers"), this.red.shl(this, S);
    }, p.prototype.redMul = function(S) {
      return l(this.red, "redMul works only with red numbers"), this.red._verify2(this, S), this.red.mul(this, S);
    }, p.prototype.redIMul = function(S) {
      return l(this.red, "redMul works only with red numbers"), this.red._verify2(this, S), this.red.imul(this, S);
    }, p.prototype.redSqr = function() {
      return l(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, p.prototype.redISqr = function() {
      return l(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, p.prototype.redSqrt = function() {
      return l(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, p.prototype.redInvm = function() {
      return l(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, p.prototype.redNeg = function() {
      return l(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, p.prototype.redPow = function(S) {
      return l(this.red && !S.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, S);
    };
    var ge = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function be(P, S) {
      this.name = P, this.p = new p(S, 16), this.n = this.p.bitLength(), this.k = new p(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    be.prototype._tmp = function() {
      var S = new p(null);
      return S.words = new Array(Math.ceil(this.n / 13)), S;
    }, be.prototype.ireduce = function(S) {
      var E = S, I;
      do
        this.split(E, this.tmp), E = this.imulK(E), E = E.iadd(this.tmp), I = E.bitLength();
      while (I > this.n);
      var N = I < this.n ? -1 : E.ucmp(this.p);
      return N === 0 ? (E.words[0] = 0, E.length = 1) : N > 0 ? E.isub(this.p) : E.strip !== void 0 ? E.strip() : E._strip(), E;
    }, be.prototype.split = function(S, E) {
      S.iushrn(this.n, 0, E);
    }, be.prototype.imulK = function(S) {
      return S.imul(this.k);
    };
    function Ce() {
      be.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    v(Ce, be), Ce.prototype.split = function(S, E) {
      for (var I = 4194303, N = Math.min(S.length, 9), $ = 0; $ < N; $++)
        E.words[$] = S.words[$];
      if (E.length = N, S.length <= 9) {
        S.words[0] = 0, S.length = 1;
        return;
      }
      var U = S.words[9];
      for (E.words[E.length++] = U & I, $ = 10; $ < S.length; $++) {
        var H = S.words[$] | 0;
        S.words[$ - 10] = (H & I) << 4 | U >>> 22, U = H;
      }
      U >>>= 22, S.words[$ - 10] = U, U === 0 && S.length > 10 ? S.length -= 10 : S.length -= 9;
    }, Ce.prototype.imulK = function(S) {
      S.words[S.length] = 0, S.words[S.length + 1] = 0, S.length += 2;
      for (var E = 0, I = 0; I < S.length; I++) {
        var N = S.words[I] | 0;
        E += N * 977, S.words[I] = E & 67108863, E = N * 64 + (E / 67108864 | 0);
      }
      return S.words[S.length - 1] === 0 && (S.length--, S.words[S.length - 1] === 0 && S.length--), S;
    };
    function Me() {
      be.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    v(Me, be);
    function Be() {
      be.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    v(Be, be);
    function Ae() {
      be.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    v(Ae, be), Ae.prototype.imulK = function(S) {
      for (var E = 0, I = 0; I < S.length; I++) {
        var N = (S.words[I] | 0) * 19 + E, $ = N & 67108863;
        N >>>= 26, S.words[I] = $, E = N;
      }
      return E !== 0 && (S.words[S.length++] = E), S;
    }, p._prime = function(S) {
      if (ge[S])
        return ge[S];
      var E;
      if (S === "k256")
        E = new Ce();
      else if (S === "p224")
        E = new Me();
      else if (S === "p192")
        E = new Be();
      else if (S === "p25519")
        E = new Ae();
      else
        throw new Error("Unknown prime " + S);
      return ge[S] = E, E;
    };
    function Z(P) {
      if (typeof P == "string") {
        var S = p._prime(P);
        this.m = S.p, this.prime = S;
      } else
        l(P.gtn(1), "modulus must be greater than 1"), this.m = P, this.prime = null;
    }
    Z.prototype._verify1 = function(S) {
      l(S.negative === 0, "red works only with positives"), l(S.red, "red works only with red numbers");
    }, Z.prototype._verify2 = function(S, E) {
      l((S.negative | E.negative) === 0, "red works only with positives"), l(
        S.red && S.red === E.red,
        "red works only with red numbers"
      );
    }, Z.prototype.imod = function(S) {
      return this.prime ? this.prime.ireduce(S)._forceRed(this) : S.umod(this.m)._forceRed(this);
    }, Z.prototype.neg = function(S) {
      return S.isZero() ? S.clone() : this.m.sub(S)._forceRed(this);
    }, Z.prototype.add = function(S, E) {
      this._verify2(S, E);
      var I = S.add(E);
      return I.cmp(this.m) >= 0 && I.isub(this.m), I._forceRed(this);
    }, Z.prototype.iadd = function(S, E) {
      this._verify2(S, E);
      var I = S.iadd(E);
      return I.cmp(this.m) >= 0 && I.isub(this.m), I;
    }, Z.prototype.sub = function(S, E) {
      this._verify2(S, E);
      var I = S.sub(E);
      return I.cmpn(0) < 0 && I.iadd(this.m), I._forceRed(this);
    }, Z.prototype.isub = function(S, E) {
      this._verify2(S, E);
      var I = S.isub(E);
      return I.cmpn(0) < 0 && I.iadd(this.m), I;
    }, Z.prototype.shl = function(S, E) {
      return this._verify1(S), this.imod(S.ushln(E));
    }, Z.prototype.imul = function(S, E) {
      return this._verify2(S, E), this.imod(S.imul(E));
    }, Z.prototype.mul = function(S, E) {
      return this._verify2(S, E), this.imod(S.mul(E));
    }, Z.prototype.isqr = function(S) {
      return this.imul(S, S.clone());
    }, Z.prototype.sqr = function(S) {
      return this.mul(S, S);
    }, Z.prototype.sqrt = function(S) {
      if (S.isZero())
        return S.clone();
      var E = this.m.andln(3);
      if (l(E % 2 === 1), E === 3) {
        var I = this.m.add(new p(1)).iushrn(2);
        return this.pow(S, I);
      }
      for (var N = this.m.subn(1), $ = 0; !N.isZero() && N.andln(1) === 0; )
        $++, N.iushrn(1);
      l(!N.isZero());
      var U = new p(1).toRed(this), H = U.redNeg(), B = this.m.subn(1).iushrn(1), T = this.m.bitLength();
      for (T = new p(2 * T * T).toRed(this); this.pow(T, B).cmp(H) !== 0; )
        T.redIAdd(H);
      for (var D = this.pow(T, N), ee = this.pow(S, N.addn(1).iushrn(1)), pe = this.pow(S, N), Ie = $; pe.cmp(U) !== 0; ) {
        for (var Pe = pe, he = 0; Pe.cmp(U) !== 0; he++)
          Pe = Pe.redSqr();
        l(he < Ie);
        var ve = this.pow(D, new p(1).iushln(Ie - he - 1));
        ee = ee.redMul(ve), D = ve.redSqr(), pe = pe.redMul(D), Ie = he;
      }
      return ee;
    }, Z.prototype.invm = function(S) {
      var E = S._invmp(this.m);
      return E.negative !== 0 ? (E.negative = 0, this.imod(E).redNeg()) : this.imod(E);
    }, Z.prototype.pow = function(S, E) {
      if (E.isZero())
        return new p(1).toRed(this);
      if (E.cmpn(1) === 0)
        return S.clone();
      var I = 4, N = new Array(1 << I);
      N[0] = new p(1).toRed(this), N[1] = S;
      for (var $ = 2; $ < N.length; $++)
        N[$] = this.mul(N[$ - 1], S);
      var U = N[0], H = 0, B = 0, T = E.bitLength() % 26;
      for (T === 0 && (T = 26), $ = E.length - 1; $ >= 0; $--) {
        for (var D = E.words[$], ee = T - 1; ee >= 0; ee--) {
          var pe = D >> ee & 1;
          if (U !== N[0] && (U = this.sqr(U)), pe === 0 && H === 0) {
            B = 0;
            continue;
          }
          H <<= 1, H |= pe, B++, !(B !== I && ($ !== 0 || ee !== 0)) && (U = this.mul(U, N[H]), B = 0, H = 0);
        }
        T = 26;
      }
      return U;
    }, Z.prototype.convertTo = function(S) {
      var E = S.umod(this.m);
      return E === S ? E.clone() : E;
    }, Z.prototype.convertFrom = function(S) {
      var E = S.clone();
      return E.red = null, E;
    }, p.mont = function(S) {
      return new z(S);
    };
    function z(P) {
      Z.call(this, P), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new p(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    v(z, Z), z.prototype.convertTo = function(S) {
      return this.imod(S.ushln(this.shift));
    }, z.prototype.convertFrom = function(S) {
      var E = this.imod(S.mul(this.rinv));
      return E.red = null, E;
    }, z.prototype.imul = function(S, E) {
      if (S.isZero() || E.isZero())
        return S.words[0] = 0, S.length = 1, S;
      var I = S.imul(E), N = I.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), $ = I.isub(N).iushrn(this.shift), U = $;
      return $.cmp(this.m) >= 0 ? U = $.isub(this.m) : $.cmpn(0) < 0 && (U = $.iadd(this.m)), U._forceRed(this);
    }, z.prototype.mul = function(S, E) {
      if (S.isZero() || E.isZero())
        return new p(0)._forceRed(this);
      var I = S.mul(E), N = I.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), $ = I.isub(N).iushrn(this.shift), U = $;
      return $.cmp(this.m) >= 0 ? U = $.isub(this.m) : $.cmpn(0) < 0 && (U = $.iadd(this.m)), U._forceRed(this);
    }, z.prototype.invm = function(S) {
      var E = this.imod(S._invmp(this.m).mul(this.r2));
      return E._forceRed(this);
    };
  })(a, commonjsGlobal$1);
})(bn$3);
var bnExports$3 = bn$3.exports, utils$u = {};
(function(a) {
  var u = a;
  function c(p, _) {
    if (Array.isArray(p))
      return p.slice();
    if (!p)
      return [];
    var k = [];
    if (typeof p != "string") {
      for (var M = 0; M < p.length; M++)
        k[M] = p[M] | 0;
      return k;
    }
    if (_ === "hex") {
      p = p.replace(/[^a-z0-9]+/ig, ""), p.length % 2 !== 0 && (p = "0" + p);
      for (var M = 0; M < p.length; M += 2)
        k.push(parseInt(p[M] + p[M + 1], 16));
    } else
      for (var M = 0; M < p.length; M++) {
        var L = p.charCodeAt(M), F = L >> 8, V = L & 255;
        F ? k.push(F, V) : k.push(V);
      }
    return k;
  }
  u.toArray = c;
  function l(p) {
    return p.length === 1 ? "0" + p : p;
  }
  u.zero2 = l;
  function v(p) {
    for (var _ = "", k = 0; k < p.length; k++)
      _ += l(p[k].toString(16));
    return _;
  }
  u.toHex = v, u.encode = function(_, k) {
    return k === "hex" ? v(_) : _;
  };
})(utils$u);
(function(a) {
  var u = a, c = bnExports$3, l = minimalisticAssert, v = utils$u;
  u.assert = l, u.toArray = v.toArray, u.zero2 = v.zero2, u.toHex = v.toHex, u.encode = v.encode;
  function p(F, V, X) {
    var oe = new Array(Math.max(F.bitLength(), X) + 1);
    oe.fill(0);
    for (var Y = 1 << V + 1, ae = F.clone(), ne = 0; ne < oe.length; ne++) {
      var fe, ie = ae.andln(Y - 1);
      ae.isOdd() ? (ie > (Y >> 1) - 1 ? fe = (Y >> 1) - ie : fe = ie, ae.isubn(fe)) : fe = 0, oe[ne] = fe, ae.iushrn(1);
    }
    return oe;
  }
  u.getNAF = p;
  function _(F, V) {
    var X = [
      [],
      []
    ];
    F = F.clone(), V = V.clone();
    for (var oe = 0, Y = 0, ae; F.cmpn(-oe) > 0 || V.cmpn(-Y) > 0; ) {
      var ne = F.andln(3) + oe & 3, fe = V.andln(3) + Y & 3;
      ne === 3 && (ne = -1), fe === 3 && (fe = -1);
      var ie;
      ne & 1 ? (ae = F.andln(7) + oe & 7, (ae === 3 || ae === 5) && fe === 2 ? ie = -ne : ie = ne) : ie = 0, X[0].push(ie);
      var ge;
      fe & 1 ? (ae = V.andln(7) + Y & 7, (ae === 3 || ae === 5) && ne === 2 ? ge = -fe : ge = fe) : ge = 0, X[1].push(ge), 2 * oe === ie + 1 && (oe = 1 - oe), 2 * Y === ge + 1 && (Y = 1 - Y), F.iushrn(1), V.iushrn(1);
    }
    return X;
  }
  u.getJSF = _;
  function k(F, V, X) {
    var oe = "_" + V;
    F.prototype[V] = function() {
      return this[oe] !== void 0 ? this[oe] : this[oe] = X.call(this);
    };
  }
  u.cachedProperty = k;
  function M(F) {
    return typeof F == "string" ? u.toArray(F, "hex") : F;
  }
  u.parseBytes = M;
  function L(F) {
    return new c(F, "hex", "le");
  }
  u.intFromLE = L;
})(utils$v);
var curve = {}, BN$9 = bnExports$3, utils$t = utils$v, getNAF = utils$t.getNAF, getJSF = utils$t.getJSF, assert$e = utils$t.assert;
function BaseCurve(a, u) {
  this.type = a, this.p = new BN$9(u.p, 16), this.red = u.prime ? BN$9.red(u.prime) : BN$9.mont(this.p), this.zero = new BN$9(0).toRed(this.red), this.one = new BN$9(1).toRed(this.red), this.two = new BN$9(2).toRed(this.red), this.n = u.n && new BN$9(u.n, 16), this.g = u.g && this.pointFromJSON(u.g, u.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
  var c = this.n && this.p.div(this.n);
  !c || c.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
}
var base$1 = BaseCurve;
BaseCurve.prototype.point = function a() {
  throw new Error("Not implemented");
};
BaseCurve.prototype.validate = function a() {
  throw new Error("Not implemented");
};
BaseCurve.prototype._fixedNafMul = function a(u, c) {
  assert$e(u.precomputed);
  var l = u._getDoubles(), v = getNAF(c, 1, this._bitLength), p = (1 << l.step + 1) - (l.step % 2 === 0 ? 2 : 1);
  p /= 3;
  var _ = [], k, M;
  for (k = 0; k < v.length; k += l.step) {
    M = 0;
    for (var L = k + l.step - 1; L >= k; L--)
      M = (M << 1) + v[L];
    _.push(M);
  }
  for (var F = this.jpoint(null, null, null), V = this.jpoint(null, null, null), X = p; X > 0; X--) {
    for (k = 0; k < _.length; k++)
      M = _[k], M === X ? V = V.mixedAdd(l.points[k]) : M === -X && (V = V.mixedAdd(l.points[k].neg()));
    F = F.add(V);
  }
  return F.toP();
};
BaseCurve.prototype._wnafMul = function a(u, c) {
  var l = 4, v = u._getNAFPoints(l);
  l = v.wnd;
  for (var p = v.points, _ = getNAF(c, l, this._bitLength), k = this.jpoint(null, null, null), M = _.length - 1; M >= 0; M--) {
    for (var L = 0; M >= 0 && _[M] === 0; M--)
      L++;
    if (M >= 0 && L++, k = k.dblp(L), M < 0)
      break;
    var F = _[M];
    assert$e(F !== 0), u.type === "affine" ? F > 0 ? k = k.mixedAdd(p[F - 1 >> 1]) : k = k.mixedAdd(p[-F - 1 >> 1].neg()) : F > 0 ? k = k.add(p[F - 1 >> 1]) : k = k.add(p[-F - 1 >> 1].neg());
  }
  return u.type === "affine" ? k.toP() : k;
};
BaseCurve.prototype._wnafMulAdd = function a(u, c, l, v, p) {
  var _ = this._wnafT1, k = this._wnafT2, M = this._wnafT3, L = 0, F, V, X;
  for (F = 0; F < v; F++) {
    X = c[F];
    var oe = X._getNAFPoints(u);
    _[F] = oe.wnd, k[F] = oe.points;
  }
  for (F = v - 1; F >= 1; F -= 2) {
    var Y = F - 1, ae = F;
    if (_[Y] !== 1 || _[ae] !== 1) {
      M[Y] = getNAF(l[Y], _[Y], this._bitLength), M[ae] = getNAF(l[ae], _[ae], this._bitLength), L = Math.max(M[Y].length, L), L = Math.max(M[ae].length, L);
      continue;
    }
    var ne = [
      c[Y],
      /* 1 */
      null,
      /* 3 */
      null,
      /* 5 */
      c[ae]
      /* 7 */
    ];
    c[Y].y.cmp(c[ae].y) === 0 ? (ne[1] = c[Y].add(c[ae]), ne[2] = c[Y].toJ().mixedAdd(c[ae].neg())) : c[Y].y.cmp(c[ae].y.redNeg()) === 0 ? (ne[1] = c[Y].toJ().mixedAdd(c[ae]), ne[2] = c[Y].add(c[ae].neg())) : (ne[1] = c[Y].toJ().mixedAdd(c[ae]), ne[2] = c[Y].toJ().mixedAdd(c[ae].neg()));
    var fe = [
      -3,
      /* -1 -1 */
      -1,
      /* -1 0 */
      -5,
      /* -1 1 */
      -7,
      /* 0 -1 */
      0,
      /* 0 0 */
      7,
      /* 0 1 */
      5,
      /* 1 -1 */
      1,
      /* 1 0 */
      3
      /* 1 1 */
    ], ie = getJSF(l[Y], l[ae]);
    for (L = Math.max(ie[0].length, L), M[Y] = new Array(L), M[ae] = new Array(L), V = 0; V < L; V++) {
      var ge = ie[0][V] | 0, be = ie[1][V] | 0;
      M[Y][V] = fe[(ge + 1) * 3 + (be + 1)], M[ae][V] = 0, k[Y] = ne;
    }
  }
  var Ce = this.jpoint(null, null, null), Me = this._wnafT4;
  for (F = L; F >= 0; F--) {
    for (var Be = 0; F >= 0; ) {
      var Ae = !0;
      for (V = 0; V < v; V++)
        Me[V] = M[V][F] | 0, Me[V] !== 0 && (Ae = !1);
      if (!Ae)
        break;
      Be++, F--;
    }
    if (F >= 0 && Be++, Ce = Ce.dblp(Be), F < 0)
      break;
    for (V = 0; V < v; V++) {
      var Z = Me[V];
      Z !== 0 && (Z > 0 ? X = k[V][Z - 1 >> 1] : Z < 0 && (X = k[V][-Z - 1 >> 1].neg()), X.type === "affine" ? Ce = Ce.mixedAdd(X) : Ce = Ce.add(X));
    }
  }
  for (F = 0; F < v; F++)
    k[F] = null;
  return p ? Ce : Ce.toP();
};
function BasePoint(a, u) {
  this.curve = a, this.type = u, this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;
BasePoint.prototype.eq = function a() {
  throw new Error("Not implemented");
};
BasePoint.prototype.validate = function a() {
  return this.curve.validate(this);
};
BaseCurve.prototype.decodePoint = function a(u, c) {
  u = utils$t.toArray(u, c);
  var l = this.p.byteLength();
  if ((u[0] === 4 || u[0] === 6 || u[0] === 7) && u.length - 1 === 2 * l) {
    u[0] === 6 ? assert$e(u[u.length - 1] % 2 === 0) : u[0] === 7 && assert$e(u[u.length - 1] % 2 === 1);
    var v = this.point(
      u.slice(1, 1 + l),
      u.slice(1 + l, 1 + 2 * l)
    );
    return v;
  } else if ((u[0] === 2 || u[0] === 3) && u.length - 1 === l)
    return this.pointFromX(u.slice(1, 1 + l), u[0] === 3);
  throw new Error("Unknown point format");
};
BasePoint.prototype.encodeCompressed = function a(u) {
  return this.encode(u, !0);
};
BasePoint.prototype._encode = function a(u) {
  var c = this.curve.p.byteLength(), l = this.getX().toArray("be", c);
  return u ? [this.getY().isEven() ? 2 : 3].concat(l) : [4].concat(l, this.getY().toArray("be", c));
};
BasePoint.prototype.encode = function a(u, c) {
  return utils$t.encode(this._encode(c), u);
};
BasePoint.prototype.precompute = function a(u) {
  if (this.precomputed)
    return this;
  var c = {
    doubles: null,
    naf: null,
    beta: null
  };
  return c.naf = this._getNAFPoints(8), c.doubles = this._getDoubles(4, u), c.beta = this._getBeta(), this.precomputed = c, this;
};
BasePoint.prototype._hasDoubles = function a(u) {
  if (!this.precomputed)
    return !1;
  var c = this.precomputed.doubles;
  return c ? c.points.length >= Math.ceil((u.bitLength() + 1) / c.step) : !1;
};
BasePoint.prototype._getDoubles = function a(u, c) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  for (var l = [this], v = this, p = 0; p < c; p += u) {
    for (var _ = 0; _ < u; _++)
      v = v.dbl();
    l.push(v);
  }
  return {
    step: u,
    points: l
  };
};
BasePoint.prototype._getNAFPoints = function a(u) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  for (var c = [this], l = (1 << u) - 1, v = l === 1 ? null : this.dbl(), p = 1; p < l; p++)
    c[p] = c[p - 1].add(v);
  return {
    wnd: u,
    points: c
  };
};
BasePoint.prototype._getBeta = function a() {
  return null;
};
BasePoint.prototype.dblp = function a(u) {
  for (var c = this, l = 0; l < u; l++)
    c = c.dbl();
  return c;
};
var utils$s = utils$v, BN$8 = bnExports$3, inherits$9 = inherits_browserExports, Base$2 = base$1, assert$d = utils$s.assert;
function ShortCurve(a) {
  Base$2.call(this, "short", a), this.a = new BN$8(a.a, 16).toRed(this.red), this.b = new BN$8(a.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(a), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
}
inherits$9(ShortCurve, Base$2);
var short = ShortCurve;
ShortCurve.prototype._getEndomorphism = function a(u) {
  if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
    var c, l;
    if (u.beta)
      c = new BN$8(u.beta, 16).toRed(this.red);
    else {
      var v = this._getEndoRoots(this.p);
      c = v[0].cmp(v[1]) < 0 ? v[0] : v[1], c = c.toRed(this.red);
    }
    if (u.lambda)
      l = new BN$8(u.lambda, 16);
    else {
      var p = this._getEndoRoots(this.n);
      this.g.mul(p[0]).x.cmp(this.g.x.redMul(c)) === 0 ? l = p[0] : (l = p[1], assert$d(this.g.mul(l).x.cmp(this.g.x.redMul(c)) === 0));
    }
    var _;
    return u.basis ? _ = u.basis.map(function(k) {
      return {
        a: new BN$8(k.a, 16),
        b: new BN$8(k.b, 16)
      };
    }) : _ = this._getEndoBasis(l), {
      beta: c,
      lambda: l,
      basis: _
    };
  }
};
ShortCurve.prototype._getEndoRoots = function a(u) {
  var c = u === this.p ? this.red : BN$8.mont(u), l = new BN$8(2).toRed(c).redInvm(), v = l.redNeg(), p = new BN$8(3).toRed(c).redNeg().redSqrt().redMul(l), _ = v.redAdd(p).fromRed(), k = v.redSub(p).fromRed();
  return [_, k];
};
ShortCurve.prototype._getEndoBasis = function a(u) {
  for (var c = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), l = u, v = this.n.clone(), p = new BN$8(1), _ = new BN$8(0), k = new BN$8(0), M = new BN$8(1), L, F, V, X, oe, Y, ae, ne = 0, fe, ie; l.cmpn(0) !== 0; ) {
    var ge = v.div(l);
    fe = v.sub(ge.mul(l)), ie = k.sub(ge.mul(p));
    var be = M.sub(ge.mul(_));
    if (!V && fe.cmp(c) < 0)
      L = ae.neg(), F = p, V = fe.neg(), X = ie;
    else if (V && ++ne === 2)
      break;
    ae = fe, v = l, l = fe, k = p, p = ie, M = _, _ = be;
  }
  oe = fe.neg(), Y = ie;
  var Ce = V.sqr().add(X.sqr()), Me = oe.sqr().add(Y.sqr());
  return Me.cmp(Ce) >= 0 && (oe = L, Y = F), V.negative && (V = V.neg(), X = X.neg()), oe.negative && (oe = oe.neg(), Y = Y.neg()), [
    { a: V, b: X },
    { a: oe, b: Y }
  ];
};
ShortCurve.prototype._endoSplit = function a(u) {
  var c = this.endo.basis, l = c[0], v = c[1], p = v.b.mul(u).divRound(this.n), _ = l.b.neg().mul(u).divRound(this.n), k = p.mul(l.a), M = _.mul(v.a), L = p.mul(l.b), F = _.mul(v.b), V = u.sub(k).sub(M), X = L.add(F).neg();
  return { k1: V, k2: X };
};
ShortCurve.prototype.pointFromX = function a(u, c) {
  u = new BN$8(u, 16), u.red || (u = u.toRed(this.red));
  var l = u.redSqr().redMul(u).redIAdd(u.redMul(this.a)).redIAdd(this.b), v = l.redSqrt();
  if (v.redSqr().redSub(l).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var p = v.fromRed().isOdd();
  return (c && !p || !c && p) && (v = v.redNeg()), this.point(u, v);
};
ShortCurve.prototype.validate = function a(u) {
  if (u.inf)
    return !0;
  var c = u.x, l = u.y, v = this.a.redMul(c), p = c.redSqr().redMul(c).redIAdd(v).redIAdd(this.b);
  return l.redSqr().redISub(p).cmpn(0) === 0;
};
ShortCurve.prototype._endoWnafMulAdd = function a(u, c, l) {
  for (var v = this._endoWnafT1, p = this._endoWnafT2, _ = 0; _ < u.length; _++) {
    var k = this._endoSplit(c[_]), M = u[_], L = M._getBeta();
    k.k1.negative && (k.k1.ineg(), M = M.neg(!0)), k.k2.negative && (k.k2.ineg(), L = L.neg(!0)), v[_ * 2] = M, v[_ * 2 + 1] = L, p[_ * 2] = k.k1, p[_ * 2 + 1] = k.k2;
  }
  for (var F = this._wnafMulAdd(1, v, p, _ * 2, l), V = 0; V < _ * 2; V++)
    v[V] = null, p[V] = null;
  return F;
};
function Point$2(a, u, c, l) {
  Base$2.BasePoint.call(this, a, "affine"), u === null && c === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new BN$8(u, 16), this.y = new BN$8(c, 16), l && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
}
inherits$9(Point$2, Base$2.BasePoint);
ShortCurve.prototype.point = function a(u, c, l) {
  return new Point$2(this, u, c, l);
};
ShortCurve.prototype.pointFromJSON = function a(u, c) {
  return Point$2.fromJSON(this, u, c);
};
Point$2.prototype._getBeta = function a() {
  if (this.curve.endo) {
    var u = this.precomputed;
    if (u && u.beta)
      return u.beta;
    var c = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (u) {
      var l = this.curve, v = function(p) {
        return l.point(p.x.redMul(l.endo.beta), p.y);
      };
      u.beta = c, c.precomputed = {
        beta: null,
        naf: u.naf && {
          wnd: u.naf.wnd,
          points: u.naf.points.map(v)
        },
        doubles: u.doubles && {
          step: u.doubles.step,
          points: u.doubles.points.map(v)
        }
      };
    }
    return c;
  }
};
Point$2.prototype.toJSON = function a() {
  return this.precomputed ? [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }] : [this.x, this.y];
};
Point$2.fromJSON = function a(u, c, l) {
  typeof c == "string" && (c = JSON.parse(c));
  var v = u.point(c[0], c[1], l);
  if (!c[2])
    return v;
  function p(k) {
    return u.point(k[0], k[1], l);
  }
  var _ = c[2];
  return v.precomputed = {
    beta: null,
    doubles: _.doubles && {
      step: _.doubles.step,
      points: [v].concat(_.doubles.points.map(p))
    },
    naf: _.naf && {
      wnd: _.naf.wnd,
      points: [v].concat(_.naf.points.map(p))
    }
  }, v;
};
Point$2.prototype.inspect = function a() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
Point$2.prototype.isInfinity = function a() {
  return this.inf;
};
Point$2.prototype.add = function a(u) {
  if (this.inf)
    return u;
  if (u.inf)
    return this;
  if (this.eq(u))
    return this.dbl();
  if (this.neg().eq(u))
    return this.curve.point(null, null);
  if (this.x.cmp(u.x) === 0)
    return this.curve.point(null, null);
  var c = this.y.redSub(u.y);
  c.cmpn(0) !== 0 && (c = c.redMul(this.x.redSub(u.x).redInvm()));
  var l = c.redSqr().redISub(this.x).redISub(u.x), v = c.redMul(this.x.redSub(l)).redISub(this.y);
  return this.curve.point(l, v);
};
Point$2.prototype.dbl = function a() {
  if (this.inf)
    return this;
  var u = this.y.redAdd(this.y);
  if (u.cmpn(0) === 0)
    return this.curve.point(null, null);
  var c = this.curve.a, l = this.x.redSqr(), v = u.redInvm(), p = l.redAdd(l).redIAdd(l).redIAdd(c).redMul(v), _ = p.redSqr().redISub(this.x.redAdd(this.x)), k = p.redMul(this.x.redSub(_)).redISub(this.y);
  return this.curve.point(_, k);
};
Point$2.prototype.getX = function a() {
  return this.x.fromRed();
};
Point$2.prototype.getY = function a() {
  return this.y.fromRed();
};
Point$2.prototype.mul = function a(u) {
  return u = new BN$8(u, 16), this.isInfinity() ? this : this._hasDoubles(u) ? this.curve._fixedNafMul(this, u) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [u]) : this.curve._wnafMul(this, u);
};
Point$2.prototype.mulAdd = function a(u, c, l) {
  var v = [this, c], p = [u, l];
  return this.curve.endo ? this.curve._endoWnafMulAdd(v, p) : this.curve._wnafMulAdd(1, v, p, 2);
};
Point$2.prototype.jmulAdd = function a(u, c, l) {
  var v = [this, c], p = [u, l];
  return this.curve.endo ? this.curve._endoWnafMulAdd(v, p, !0) : this.curve._wnafMulAdd(1, v, p, 2, !0);
};
Point$2.prototype.eq = function a(u) {
  return this === u || this.inf === u.inf && (this.inf || this.x.cmp(u.x) === 0 && this.y.cmp(u.y) === 0);
};
Point$2.prototype.neg = function a(u) {
  if (this.inf)
    return this;
  var c = this.curve.point(this.x, this.y.redNeg());
  if (u && this.precomputed) {
    var l = this.precomputed, v = function(p) {
      return p.neg();
    };
    c.precomputed = {
      naf: l.naf && {
        wnd: l.naf.wnd,
        points: l.naf.points.map(v)
      },
      doubles: l.doubles && {
        step: l.doubles.step,
        points: l.doubles.points.map(v)
      }
    };
  }
  return c;
};
Point$2.prototype.toJ = function a() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var u = this.curve.jpoint(this.x, this.y, this.curve.one);
  return u;
};
function JPoint(a, u, c, l) {
  Base$2.BasePoint.call(this, a, "jacobian"), u === null && c === null && l === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new BN$8(0)) : (this.x = new BN$8(u, 16), this.y = new BN$8(c, 16), this.z = new BN$8(l, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
}
inherits$9(JPoint, Base$2.BasePoint);
ShortCurve.prototype.jpoint = function a(u, c, l) {
  return new JPoint(this, u, c, l);
};
JPoint.prototype.toP = function a() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var u = this.z.redInvm(), c = u.redSqr(), l = this.x.redMul(c), v = this.y.redMul(c).redMul(u);
  return this.curve.point(l, v);
};
JPoint.prototype.neg = function a() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
JPoint.prototype.add = function a(u) {
  if (this.isInfinity())
    return u;
  if (u.isInfinity())
    return this;
  var c = u.z.redSqr(), l = this.z.redSqr(), v = this.x.redMul(c), p = u.x.redMul(l), _ = this.y.redMul(c.redMul(u.z)), k = u.y.redMul(l.redMul(this.z)), M = v.redSub(p), L = _.redSub(k);
  if (M.cmpn(0) === 0)
    return L.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var F = M.redSqr(), V = F.redMul(M), X = v.redMul(F), oe = L.redSqr().redIAdd(V).redISub(X).redISub(X), Y = L.redMul(X.redISub(oe)).redISub(_.redMul(V)), ae = this.z.redMul(u.z).redMul(M);
  return this.curve.jpoint(oe, Y, ae);
};
JPoint.prototype.mixedAdd = function a(u) {
  if (this.isInfinity())
    return u.toJ();
  if (u.isInfinity())
    return this;
  var c = this.z.redSqr(), l = this.x, v = u.x.redMul(c), p = this.y, _ = u.y.redMul(c).redMul(this.z), k = l.redSub(v), M = p.redSub(_);
  if (k.cmpn(0) === 0)
    return M.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var L = k.redSqr(), F = L.redMul(k), V = l.redMul(L), X = M.redSqr().redIAdd(F).redISub(V).redISub(V), oe = M.redMul(V.redISub(X)).redISub(p.redMul(F)), Y = this.z.redMul(k);
  return this.curve.jpoint(X, oe, Y);
};
JPoint.prototype.dblp = function a(u) {
  if (u === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!u)
    return this.dbl();
  var c;
  if (this.curve.zeroA || this.curve.threeA) {
    var l = this;
    for (c = 0; c < u; c++)
      l = l.dbl();
    return l;
  }
  var v = this.curve.a, p = this.curve.tinv, _ = this.x, k = this.y, M = this.z, L = M.redSqr().redSqr(), F = k.redAdd(k);
  for (c = 0; c < u; c++) {
    var V = _.redSqr(), X = F.redSqr(), oe = X.redSqr(), Y = V.redAdd(V).redIAdd(V).redIAdd(v.redMul(L)), ae = _.redMul(X), ne = Y.redSqr().redISub(ae.redAdd(ae)), fe = ae.redISub(ne), ie = Y.redMul(fe);
    ie = ie.redIAdd(ie).redISub(oe);
    var ge = F.redMul(M);
    c + 1 < u && (L = L.redMul(oe)), _ = ne, M = ge, F = ie;
  }
  return this.curve.jpoint(_, F.redMul(p), M);
};
JPoint.prototype.dbl = function a() {
  return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
};
JPoint.prototype._zeroDbl = function a() {
  var u, c, l;
  if (this.zOne) {
    var v = this.x.redSqr(), p = this.y.redSqr(), _ = p.redSqr(), k = this.x.redAdd(p).redSqr().redISub(v).redISub(_);
    k = k.redIAdd(k);
    var M = v.redAdd(v).redIAdd(v), L = M.redSqr().redISub(k).redISub(k), F = _.redIAdd(_);
    F = F.redIAdd(F), F = F.redIAdd(F), u = L, c = M.redMul(k.redISub(L)).redISub(F), l = this.y.redAdd(this.y);
  } else {
    var V = this.x.redSqr(), X = this.y.redSqr(), oe = X.redSqr(), Y = this.x.redAdd(X).redSqr().redISub(V).redISub(oe);
    Y = Y.redIAdd(Y);
    var ae = V.redAdd(V).redIAdd(V), ne = ae.redSqr(), fe = oe.redIAdd(oe);
    fe = fe.redIAdd(fe), fe = fe.redIAdd(fe), u = ne.redISub(Y).redISub(Y), c = ae.redMul(Y.redISub(u)).redISub(fe), l = this.y.redMul(this.z), l = l.redIAdd(l);
  }
  return this.curve.jpoint(u, c, l);
};
JPoint.prototype._threeDbl = function a() {
  var u, c, l;
  if (this.zOne) {
    var v = this.x.redSqr(), p = this.y.redSqr(), _ = p.redSqr(), k = this.x.redAdd(p).redSqr().redISub(v).redISub(_);
    k = k.redIAdd(k);
    var M = v.redAdd(v).redIAdd(v).redIAdd(this.curve.a), L = M.redSqr().redISub(k).redISub(k);
    u = L;
    var F = _.redIAdd(_);
    F = F.redIAdd(F), F = F.redIAdd(F), c = M.redMul(k.redISub(L)).redISub(F), l = this.y.redAdd(this.y);
  } else {
    var V = this.z.redSqr(), X = this.y.redSqr(), oe = this.x.redMul(X), Y = this.x.redSub(V).redMul(this.x.redAdd(V));
    Y = Y.redAdd(Y).redIAdd(Y);
    var ae = oe.redIAdd(oe);
    ae = ae.redIAdd(ae);
    var ne = ae.redAdd(ae);
    u = Y.redSqr().redISub(ne), l = this.y.redAdd(this.z).redSqr().redISub(X).redISub(V);
    var fe = X.redSqr();
    fe = fe.redIAdd(fe), fe = fe.redIAdd(fe), fe = fe.redIAdd(fe), c = Y.redMul(ae.redISub(u)).redISub(fe);
  }
  return this.curve.jpoint(u, c, l);
};
JPoint.prototype._dbl = function a() {
  var u = this.curve.a, c = this.x, l = this.y, v = this.z, p = v.redSqr().redSqr(), _ = c.redSqr(), k = l.redSqr(), M = _.redAdd(_).redIAdd(_).redIAdd(u.redMul(p)), L = c.redAdd(c);
  L = L.redIAdd(L);
  var F = L.redMul(k), V = M.redSqr().redISub(F.redAdd(F)), X = F.redISub(V), oe = k.redSqr();
  oe = oe.redIAdd(oe), oe = oe.redIAdd(oe), oe = oe.redIAdd(oe);
  var Y = M.redMul(X).redISub(oe), ae = l.redAdd(l).redMul(v);
  return this.curve.jpoint(V, Y, ae);
};
JPoint.prototype.trpl = function a() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var u = this.x.redSqr(), c = this.y.redSqr(), l = this.z.redSqr(), v = c.redSqr(), p = u.redAdd(u).redIAdd(u), _ = p.redSqr(), k = this.x.redAdd(c).redSqr().redISub(u).redISub(v);
  k = k.redIAdd(k), k = k.redAdd(k).redIAdd(k), k = k.redISub(_);
  var M = k.redSqr(), L = v.redIAdd(v);
  L = L.redIAdd(L), L = L.redIAdd(L), L = L.redIAdd(L);
  var F = p.redIAdd(k).redSqr().redISub(_).redISub(M).redISub(L), V = c.redMul(F);
  V = V.redIAdd(V), V = V.redIAdd(V);
  var X = this.x.redMul(M).redISub(V);
  X = X.redIAdd(X), X = X.redIAdd(X);
  var oe = this.y.redMul(F.redMul(L.redISub(F)).redISub(k.redMul(M)));
  oe = oe.redIAdd(oe), oe = oe.redIAdd(oe), oe = oe.redIAdd(oe);
  var Y = this.z.redAdd(k).redSqr().redISub(l).redISub(M);
  return this.curve.jpoint(X, oe, Y);
};
JPoint.prototype.mul = function a(u, c) {
  return u = new BN$8(u, c), this.curve._wnafMul(this, u);
};
JPoint.prototype.eq = function a(u) {
  if (u.type === "affine")
    return this.eq(u.toJ());
  if (this === u)
    return !0;
  var c = this.z.redSqr(), l = u.z.redSqr();
  if (this.x.redMul(l).redISub(u.x.redMul(c)).cmpn(0) !== 0)
    return !1;
  var v = c.redMul(this.z), p = l.redMul(u.z);
  return this.y.redMul(p).redISub(u.y.redMul(v)).cmpn(0) === 0;
};
JPoint.prototype.eqXToP = function a(u) {
  var c = this.z.redSqr(), l = u.toRed(this.curve.red).redMul(c);
  if (this.x.cmp(l) === 0)
    return !0;
  for (var v = u.clone(), p = this.curve.redN.redMul(c); ; ) {
    if (v.iadd(this.curve.n), v.cmp(this.curve.p) >= 0)
      return !1;
    if (l.redIAdd(p), this.x.cmp(l) === 0)
      return !0;
  }
};
JPoint.prototype.inspect = function a() {
  return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
JPoint.prototype.isInfinity = function a() {
  return this.z.cmpn(0) === 0;
};
var BN$7 = bnExports$3, inherits$8 = inherits_browserExports, Base$1 = base$1, utils$r = utils$v;
function MontCurve(a) {
  Base$1.call(this, "mont", a), this.a = new BN$7(a.a, 16).toRed(this.red), this.b = new BN$7(a.b, 16).toRed(this.red), this.i4 = new BN$7(4).toRed(this.red).redInvm(), this.two = new BN$7(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
inherits$8(MontCurve, Base$1);
var mont = MontCurve;
MontCurve.prototype.validate = function a(u) {
  var c = u.normalize().x, l = c.redSqr(), v = l.redMul(c).redAdd(l.redMul(this.a)).redAdd(c), p = v.redSqrt();
  return p.redSqr().cmp(v) === 0;
};
function Point$1(a, u, c) {
  Base$1.BasePoint.call(this, a, "projective"), u === null && c === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new BN$7(u, 16), this.z = new BN$7(c, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
}
inherits$8(Point$1, Base$1.BasePoint);
MontCurve.prototype.decodePoint = function a(u, c) {
  return this.point(utils$r.toArray(u, c), 1);
};
MontCurve.prototype.point = function a(u, c) {
  return new Point$1(this, u, c);
};
MontCurve.prototype.pointFromJSON = function a(u) {
  return Point$1.fromJSON(this, u);
};
Point$1.prototype.precompute = function a() {
};
Point$1.prototype._encode = function a() {
  return this.getX().toArray("be", this.curve.p.byteLength());
};
Point$1.fromJSON = function a(u, c) {
  return new Point$1(u, c[0], c[1] || u.one);
};
Point$1.prototype.inspect = function a() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
Point$1.prototype.isInfinity = function a() {
  return this.z.cmpn(0) === 0;
};
Point$1.prototype.dbl = function a() {
  var u = this.x.redAdd(this.z), c = u.redSqr(), l = this.x.redSub(this.z), v = l.redSqr(), p = c.redSub(v), _ = c.redMul(v), k = p.redMul(v.redAdd(this.curve.a24.redMul(p)));
  return this.curve.point(_, k);
};
Point$1.prototype.add = function a() {
  throw new Error("Not supported on Montgomery curve");
};
Point$1.prototype.diffAdd = function a(u, c) {
  var l = this.x.redAdd(this.z), v = this.x.redSub(this.z), p = u.x.redAdd(u.z), _ = u.x.redSub(u.z), k = _.redMul(l), M = p.redMul(v), L = c.z.redMul(k.redAdd(M).redSqr()), F = c.x.redMul(k.redISub(M).redSqr());
  return this.curve.point(L, F);
};
Point$1.prototype.mul = function a(u) {
  for (var c = u.clone(), l = this, v = this.curve.point(null, null), p = this, _ = []; c.cmpn(0) !== 0; c.iushrn(1))
    _.push(c.andln(1));
  for (var k = _.length - 1; k >= 0; k--)
    _[k] === 0 ? (l = l.diffAdd(v, p), v = v.dbl()) : (v = l.diffAdd(v, p), l = l.dbl());
  return v;
};
Point$1.prototype.mulAdd = function a() {
  throw new Error("Not supported on Montgomery curve");
};
Point$1.prototype.jumlAdd = function a() {
  throw new Error("Not supported on Montgomery curve");
};
Point$1.prototype.eq = function a(u) {
  return this.getX().cmp(u.getX()) === 0;
};
Point$1.prototype.normalize = function a() {
  return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
};
Point$1.prototype.getX = function a() {
  return this.normalize(), this.x.fromRed();
};
var utils$q = utils$v, BN$6 = bnExports$3, inherits$7 = inherits_browserExports, Base = base$1, assert$c = utils$q.assert;
function EdwardsCurve(a) {
  this.twisted = (a.a | 0) !== 1, this.mOneA = this.twisted && (a.a | 0) === -1, this.extended = this.mOneA, Base.call(this, "edwards", a), this.a = new BN$6(a.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new BN$6(a.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new BN$6(a.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), assert$c(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (a.c | 0) === 1;
}
inherits$7(EdwardsCurve, Base);
var edwards = EdwardsCurve;
EdwardsCurve.prototype._mulA = function a(u) {
  return this.mOneA ? u.redNeg() : this.a.redMul(u);
};
EdwardsCurve.prototype._mulC = function a(u) {
  return this.oneC ? u : this.c.redMul(u);
};
EdwardsCurve.prototype.jpoint = function a(u, c, l, v) {
  return this.point(u, c, l, v);
};
EdwardsCurve.prototype.pointFromX = function a(u, c) {
  u = new BN$6(u, 16), u.red || (u = u.toRed(this.red));
  var l = u.redSqr(), v = this.c2.redSub(this.a.redMul(l)), p = this.one.redSub(this.c2.redMul(this.d).redMul(l)), _ = v.redMul(p.redInvm()), k = _.redSqrt();
  if (k.redSqr().redSub(_).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var M = k.fromRed().isOdd();
  return (c && !M || !c && M) && (k = k.redNeg()), this.point(u, k);
};
EdwardsCurve.prototype.pointFromY = function a(u, c) {
  u = new BN$6(u, 16), u.red || (u = u.toRed(this.red));
  var l = u.redSqr(), v = l.redSub(this.c2), p = l.redMul(this.d).redMul(this.c2).redSub(this.a), _ = v.redMul(p.redInvm());
  if (_.cmp(this.zero) === 0) {
    if (c)
      throw new Error("invalid point");
    return this.point(this.zero, u);
  }
  var k = _.redSqrt();
  if (k.redSqr().redSub(_).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  return k.fromRed().isOdd() !== c && (k = k.redNeg()), this.point(k, u);
};
EdwardsCurve.prototype.validate = function a(u) {
  if (u.isInfinity())
    return !0;
  u.normalize();
  var c = u.x.redSqr(), l = u.y.redSqr(), v = c.redMul(this.a).redAdd(l), p = this.c2.redMul(this.one.redAdd(this.d.redMul(c).redMul(l)));
  return v.cmp(p) === 0;
};
function Point(a, u, c, l, v) {
  Base.BasePoint.call(this, a, "projective"), u === null && c === null && l === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new BN$6(u, 16), this.y = new BN$6(c, 16), this.z = l ? new BN$6(l, 16) : this.curve.one, this.t = v && new BN$6(v, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
}
inherits$7(Point, Base.BasePoint);
EdwardsCurve.prototype.pointFromJSON = function a(u) {
  return Point.fromJSON(this, u);
};
EdwardsCurve.prototype.point = function a(u, c, l, v) {
  return new Point(this, u, c, l, v);
};
Point.fromJSON = function a(u, c) {
  return new Point(u, c[0], c[1], c[2]);
};
Point.prototype.inspect = function a() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
Point.prototype.isInfinity = function a() {
  return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
};
Point.prototype._extDbl = function a() {
  var u = this.x.redSqr(), c = this.y.redSqr(), l = this.z.redSqr();
  l = l.redIAdd(l);
  var v = this.curve._mulA(u), p = this.x.redAdd(this.y).redSqr().redISub(u).redISub(c), _ = v.redAdd(c), k = _.redSub(l), M = v.redSub(c), L = p.redMul(k), F = _.redMul(M), V = p.redMul(M), X = k.redMul(_);
  return this.curve.point(L, F, X, V);
};
Point.prototype._projDbl = function a() {
  var u = this.x.redAdd(this.y).redSqr(), c = this.x.redSqr(), l = this.y.redSqr(), v, p, _, k, M, L;
  if (this.curve.twisted) {
    k = this.curve._mulA(c);
    var F = k.redAdd(l);
    this.zOne ? (v = u.redSub(c).redSub(l).redMul(F.redSub(this.curve.two)), p = F.redMul(k.redSub(l)), _ = F.redSqr().redSub(F).redSub(F)) : (M = this.z.redSqr(), L = F.redSub(M).redISub(M), v = u.redSub(c).redISub(l).redMul(L), p = F.redMul(k.redSub(l)), _ = F.redMul(L));
  } else
    k = c.redAdd(l), M = this.curve._mulC(this.z).redSqr(), L = k.redSub(M).redSub(M), v = this.curve._mulC(u.redISub(k)).redMul(L), p = this.curve._mulC(k).redMul(c.redISub(l)), _ = k.redMul(L);
  return this.curve.point(v, p, _);
};
Point.prototype.dbl = function a() {
  return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
};
Point.prototype._extAdd = function a(u) {
  var c = this.y.redSub(this.x).redMul(u.y.redSub(u.x)), l = this.y.redAdd(this.x).redMul(u.y.redAdd(u.x)), v = this.t.redMul(this.curve.dd).redMul(u.t), p = this.z.redMul(u.z.redAdd(u.z)), _ = l.redSub(c), k = p.redSub(v), M = p.redAdd(v), L = l.redAdd(c), F = _.redMul(k), V = M.redMul(L), X = _.redMul(L), oe = k.redMul(M);
  return this.curve.point(F, V, oe, X);
};
Point.prototype._projAdd = function a(u) {
  var c = this.z.redMul(u.z), l = c.redSqr(), v = this.x.redMul(u.x), p = this.y.redMul(u.y), _ = this.curve.d.redMul(v).redMul(p), k = l.redSub(_), M = l.redAdd(_), L = this.x.redAdd(this.y).redMul(u.x.redAdd(u.y)).redISub(v).redISub(p), F = c.redMul(k).redMul(L), V, X;
  return this.curve.twisted ? (V = c.redMul(M).redMul(p.redSub(this.curve._mulA(v))), X = k.redMul(M)) : (V = c.redMul(M).redMul(p.redSub(v)), X = this.curve._mulC(k).redMul(M)), this.curve.point(F, V, X);
};
Point.prototype.add = function a(u) {
  return this.isInfinity() ? u : u.isInfinity() ? this : this.curve.extended ? this._extAdd(u) : this._projAdd(u);
};
Point.prototype.mul = function a(u) {
  return this._hasDoubles(u) ? this.curve._fixedNafMul(this, u) : this.curve._wnafMul(this, u);
};
Point.prototype.mulAdd = function a(u, c, l) {
  return this.curve._wnafMulAdd(1, [this, c], [u, l], 2, !1);
};
Point.prototype.jmulAdd = function a(u, c, l) {
  return this.curve._wnafMulAdd(1, [this, c], [u, l], 2, !0);
};
Point.prototype.normalize = function a() {
  if (this.zOne)
    return this;
  var u = this.z.redInvm();
  return this.x = this.x.redMul(u), this.y = this.y.redMul(u), this.t && (this.t = this.t.redMul(u)), this.z = this.curve.one, this.zOne = !0, this;
};
Point.prototype.neg = function a() {
  return this.curve.point(
    this.x.redNeg(),
    this.y,
    this.z,
    this.t && this.t.redNeg()
  );
};
Point.prototype.getX = function a() {
  return this.normalize(), this.x.fromRed();
};
Point.prototype.getY = function a() {
  return this.normalize(), this.y.fromRed();
};
Point.prototype.eq = function a(u) {
  return this === u || this.getX().cmp(u.getX()) === 0 && this.getY().cmp(u.getY()) === 0;
};
Point.prototype.eqXToP = function a(u) {
  var c = u.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(c) === 0)
    return !0;
  for (var l = u.clone(), v = this.curve.redN.redMul(this.z); ; ) {
    if (l.iadd(this.curve.n), l.cmp(this.curve.p) >= 0)
      return !1;
    if (c.redIAdd(v), this.x.cmp(c) === 0)
      return !0;
  }
};
Point.prototype.toP = Point.prototype.normalize;
Point.prototype.mixedAdd = Point.prototype.add;
(function(a) {
  var u = a;
  u.base = base$1, u.short = short, u.mont = mont, u.edwards = edwards;
})(curve);
var curves$1 = {}, hash$2 = {}, utils$p = {}, assert$b = minimalisticAssert, inherits$6 = inherits_browserExports;
utils$p.inherits = inherits$6;
function isSurrogatePair(a, u) {
  return (a.charCodeAt(u) & 64512) !== 55296 || u < 0 || u + 1 >= a.length ? !1 : (a.charCodeAt(u + 1) & 64512) === 56320;
}
function toArray(a, u) {
  if (Array.isArray(a))
    return a.slice();
  if (!a)
    return [];
  var c = [];
  if (typeof a == "string")
    if (u) {
      if (u === "hex")
        for (a = a.replace(/[^a-z0-9]+/ig, ""), a.length % 2 !== 0 && (a = "0" + a), v = 0; v < a.length; v += 2)
          c.push(parseInt(a[v] + a[v + 1], 16));
    } else
      for (var l = 0, v = 0; v < a.length; v++) {
        var p = a.charCodeAt(v);
        p < 128 ? c[l++] = p : p < 2048 ? (c[l++] = p >> 6 | 192, c[l++] = p & 63 | 128) : isSurrogatePair(a, v) ? (p = 65536 + ((p & 1023) << 10) + (a.charCodeAt(++v) & 1023), c[l++] = p >> 18 | 240, c[l++] = p >> 12 & 63 | 128, c[l++] = p >> 6 & 63 | 128, c[l++] = p & 63 | 128) : (c[l++] = p >> 12 | 224, c[l++] = p >> 6 & 63 | 128, c[l++] = p & 63 | 128);
      }
  else
    for (v = 0; v < a.length; v++)
      c[v] = a[v] | 0;
  return c;
}
utils$p.toArray = toArray;
function toHex$1(a) {
  for (var u = "", c = 0; c < a.length; c++)
    u += zero2(a[c].toString(16));
  return u;
}
utils$p.toHex = toHex$1;
function htonl(a) {
  var u = a >>> 24 | a >>> 8 & 65280 | a << 8 & 16711680 | (a & 255) << 24;
  return u >>> 0;
}
utils$p.htonl = htonl;
function toHex32(a, u) {
  for (var c = "", l = 0; l < a.length; l++) {
    var v = a[l];
    u === "little" && (v = htonl(v)), c += zero8(v.toString(16));
  }
  return c;
}
utils$p.toHex32 = toHex32;
function zero2(a) {
  return a.length === 1 ? "0" + a : a;
}
utils$p.zero2 = zero2;
function zero8(a) {
  return a.length === 7 ? "0" + a : a.length === 6 ? "00" + a : a.length === 5 ? "000" + a : a.length === 4 ? "0000" + a : a.length === 3 ? "00000" + a : a.length === 2 ? "000000" + a : a.length === 1 ? "0000000" + a : a;
}
utils$p.zero8 = zero8;
function join32(a, u, c, l) {
  var v = c - u;
  assert$b(v % 4 === 0);
  for (var p = new Array(v / 4), _ = 0, k = u; _ < p.length; _++, k += 4) {
    var M;
    l === "big" ? M = a[k] << 24 | a[k + 1] << 16 | a[k + 2] << 8 | a[k + 3] : M = a[k + 3] << 24 | a[k + 2] << 16 | a[k + 1] << 8 | a[k], p[_] = M >>> 0;
  }
  return p;
}
utils$p.join32 = join32;
function split32(a, u) {
  for (var c = new Array(a.length * 4), l = 0, v = 0; l < a.length; l++, v += 4) {
    var p = a[l];
    u === "big" ? (c[v] = p >>> 24, c[v + 1] = p >>> 16 & 255, c[v + 2] = p >>> 8 & 255, c[v + 3] = p & 255) : (c[v + 3] = p >>> 24, c[v + 2] = p >>> 16 & 255, c[v + 1] = p >>> 8 & 255, c[v] = p & 255);
  }
  return c;
}
utils$p.split32 = split32;
function rotr32$1(a, u) {
  return a >>> u | a << 32 - u;
}
utils$p.rotr32 = rotr32$1;
function rotl32$2(a, u) {
  return a << u | a >>> 32 - u;
}
utils$p.rotl32 = rotl32$2;
function sum32$3(a, u) {
  return a + u >>> 0;
}
utils$p.sum32 = sum32$3;
function sum32_3$1(a, u, c) {
  return a + u + c >>> 0;
}
utils$p.sum32_3 = sum32_3$1;
function sum32_4$2(a, u, c, l) {
  return a + u + c + l >>> 0;
}
utils$p.sum32_4 = sum32_4$2;
function sum32_5$2(a, u, c, l, v) {
  return a + u + c + l + v >>> 0;
}
utils$p.sum32_5 = sum32_5$2;
function sum64$1(a, u, c, l) {
  var v = a[u], p = a[u + 1], _ = l + p >>> 0, k = (_ < l ? 1 : 0) + c + v;
  a[u] = k >>> 0, a[u + 1] = _;
}
utils$p.sum64 = sum64$1;
function sum64_hi$1(a, u, c, l) {
  var v = u + l >>> 0, p = (v < u ? 1 : 0) + a + c;
  return p >>> 0;
}
utils$p.sum64_hi = sum64_hi$1;
function sum64_lo$1(a, u, c, l) {
  var v = u + l;
  return v >>> 0;
}
utils$p.sum64_lo = sum64_lo$1;
function sum64_4_hi$1(a, u, c, l, v, p, _, k) {
  var M = 0, L = u;
  L = L + l >>> 0, M += L < u ? 1 : 0, L = L + p >>> 0, M += L < p ? 1 : 0, L = L + k >>> 0, M += L < k ? 1 : 0;
  var F = a + c + v + _ + M;
  return F >>> 0;
}
utils$p.sum64_4_hi = sum64_4_hi$1;
function sum64_4_lo$1(a, u, c, l, v, p, _, k) {
  var M = u + l + p + k;
  return M >>> 0;
}
utils$p.sum64_4_lo = sum64_4_lo$1;
function sum64_5_hi$1(a, u, c, l, v, p, _, k, M, L) {
  var F = 0, V = u;
  V = V + l >>> 0, F += V < u ? 1 : 0, V = V + p >>> 0, F += V < p ? 1 : 0, V = V + k >>> 0, F += V < k ? 1 : 0, V = V + L >>> 0, F += V < L ? 1 : 0;
  var X = a + c + v + _ + M + F;
  return X >>> 0;
}
utils$p.sum64_5_hi = sum64_5_hi$1;
function sum64_5_lo$1(a, u, c, l, v, p, _, k, M, L) {
  var F = u + l + p + k + L;
  return F >>> 0;
}
utils$p.sum64_5_lo = sum64_5_lo$1;
function rotr64_hi$1(a, u, c) {
  var l = u << 32 - c | a >>> c;
  return l >>> 0;
}
utils$p.rotr64_hi = rotr64_hi$1;
function rotr64_lo$1(a, u, c) {
  var l = a << 32 - c | u >>> c;
  return l >>> 0;
}
utils$p.rotr64_lo = rotr64_lo$1;
function shr64_hi$1(a, u, c) {
  return a >>> c;
}
utils$p.shr64_hi = shr64_hi$1;
function shr64_lo$1(a, u, c) {
  var l = a << 32 - c | u >>> c;
  return l >>> 0;
}
utils$p.shr64_lo = shr64_lo$1;
var common$5 = {}, utils$o = utils$p, assert$a = minimalisticAssert;
function BlockHash$4() {
  this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
}
common$5.BlockHash = BlockHash$4;
BlockHash$4.prototype.update = function a(u, c) {
  if (u = utils$o.toArray(u, c), this.pending ? this.pending = this.pending.concat(u) : this.pending = u, this.pendingTotal += u.length, this.pending.length >= this._delta8) {
    u = this.pending;
    var l = u.length % this._delta8;
    this.pending = u.slice(u.length - l, u.length), this.pending.length === 0 && (this.pending = null), u = utils$o.join32(u, 0, u.length - l, this.endian);
    for (var v = 0; v < u.length; v += this._delta32)
      this._update(u, v, v + this._delta32);
  }
  return this;
};
BlockHash$4.prototype.digest = function a(u) {
  return this.update(this._pad()), assert$a(this.pending === null), this._digest(u);
};
BlockHash$4.prototype._pad = function a() {
  var u = this.pendingTotal, c = this._delta8, l = c - (u + this.padLength) % c, v = new Array(l + this.padLength);
  v[0] = 128;
  for (var p = 1; p < l; p++)
    v[p] = 0;
  if (u <<= 3, this.endian === "big") {
    for (var _ = 8; _ < this.padLength; _++)
      v[p++] = 0;
    v[p++] = 0, v[p++] = 0, v[p++] = 0, v[p++] = 0, v[p++] = u >>> 24 & 255, v[p++] = u >>> 16 & 255, v[p++] = u >>> 8 & 255, v[p++] = u & 255;
  } else
    for (v[p++] = u & 255, v[p++] = u >>> 8 & 255, v[p++] = u >>> 16 & 255, v[p++] = u >>> 24 & 255, v[p++] = 0, v[p++] = 0, v[p++] = 0, v[p++] = 0, _ = 8; _ < this.padLength; _++)
      v[p++] = 0;
  return v;
};
var sha = {}, common$4 = {}, utils$n = utils$p, rotr32 = utils$n.rotr32;
function ft_1$1(a, u, c, l) {
  if (a === 0)
    return ch32$1(u, c, l);
  if (a === 1 || a === 3)
    return p32(u, c, l);
  if (a === 2)
    return maj32$1(u, c, l);
}
common$4.ft_1 = ft_1$1;
function ch32$1(a, u, c) {
  return a & u ^ ~a & c;
}
common$4.ch32 = ch32$1;
function maj32$1(a, u, c) {
  return a & u ^ a & c ^ u & c;
}
common$4.maj32 = maj32$1;
function p32(a, u, c) {
  return a ^ u ^ c;
}
common$4.p32 = p32;
function s0_256$1(a) {
  return rotr32(a, 2) ^ rotr32(a, 13) ^ rotr32(a, 22);
}
common$4.s0_256 = s0_256$1;
function s1_256$1(a) {
  return rotr32(a, 6) ^ rotr32(a, 11) ^ rotr32(a, 25);
}
common$4.s1_256 = s1_256$1;
function g0_256$1(a) {
  return rotr32(a, 7) ^ rotr32(a, 18) ^ a >>> 3;
}
common$4.g0_256 = g0_256$1;
function g1_256$1(a) {
  return rotr32(a, 17) ^ rotr32(a, 19) ^ a >>> 10;
}
common$4.g1_256 = g1_256$1;
var utils$m = utils$p, common$3 = common$5, shaCommon$1 = common$4, rotl32$1 = utils$m.rotl32, sum32$2 = utils$m.sum32, sum32_5$1 = utils$m.sum32_5, ft_1 = shaCommon$1.ft_1, BlockHash$3 = common$3.BlockHash, sha1_K = [
  1518500249,
  1859775393,
  2400959708,
  3395469782
];
function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();
  BlockHash$3.call(this), this.h = [
    1732584193,
    4023233417,
    2562383102,
    271733878,
    3285377520
  ], this.W = new Array(80);
}
utils$m.inherits(SHA1, BlockHash$3);
var _1 = SHA1;
SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;
SHA1.prototype._update = function a(u, c) {
  for (var l = this.W, v = 0; v < 16; v++)
    l[v] = u[c + v];
  for (; v < l.length; v++)
    l[v] = rotl32$1(l[v - 3] ^ l[v - 8] ^ l[v - 14] ^ l[v - 16], 1);
  var p = this.h[0], _ = this.h[1], k = this.h[2], M = this.h[3], L = this.h[4];
  for (v = 0; v < l.length; v++) {
    var F = ~~(v / 20), V = sum32_5$1(rotl32$1(p, 5), ft_1(F, _, k, M), L, l[v], sha1_K[F]);
    L = M, M = k, k = rotl32$1(_, 30), _ = p, p = V;
  }
  this.h[0] = sum32$2(this.h[0], p), this.h[1] = sum32$2(this.h[1], _), this.h[2] = sum32$2(this.h[2], k), this.h[3] = sum32$2(this.h[3], M), this.h[4] = sum32$2(this.h[4], L);
};
SHA1.prototype._digest = function a(u) {
  return u === "hex" ? utils$m.toHex32(this.h, "big") : utils$m.split32(this.h, "big");
};
var utils$l = utils$p, common$2 = common$5, shaCommon = common$4, assert$9 = minimalisticAssert, sum32$1 = utils$l.sum32, sum32_4$1 = utils$l.sum32_4, sum32_5 = utils$l.sum32_5, ch32 = shaCommon.ch32, maj32 = shaCommon.maj32, s0_256 = shaCommon.s0_256, s1_256 = shaCommon.s1_256, g0_256 = shaCommon.g0_256, g1_256 = shaCommon.g1_256, BlockHash$2 = common$2.BlockHash, sha256_K = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
];
function SHA256$1() {
  if (!(this instanceof SHA256$1))
    return new SHA256$1();
  BlockHash$2.call(this), this.h = [
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ], this.k = sha256_K, this.W = new Array(64);
}
utils$l.inherits(SHA256$1, BlockHash$2);
var _256 = SHA256$1;
SHA256$1.blockSize = 512;
SHA256$1.outSize = 256;
SHA256$1.hmacStrength = 192;
SHA256$1.padLength = 64;
SHA256$1.prototype._update = function a(u, c) {
  for (var l = this.W, v = 0; v < 16; v++)
    l[v] = u[c + v];
  for (; v < l.length; v++)
    l[v] = sum32_4$1(g1_256(l[v - 2]), l[v - 7], g0_256(l[v - 15]), l[v - 16]);
  var p = this.h[0], _ = this.h[1], k = this.h[2], M = this.h[3], L = this.h[4], F = this.h[5], V = this.h[6], X = this.h[7];
  for (assert$9(this.k.length === l.length), v = 0; v < l.length; v++) {
    var oe = sum32_5(X, s1_256(L), ch32(L, F, V), this.k[v], l[v]), Y = sum32$1(s0_256(p), maj32(p, _, k));
    X = V, V = F, F = L, L = sum32$1(M, oe), M = k, k = _, _ = p, p = sum32$1(oe, Y);
  }
  this.h[0] = sum32$1(this.h[0], p), this.h[1] = sum32$1(this.h[1], _), this.h[2] = sum32$1(this.h[2], k), this.h[3] = sum32$1(this.h[3], M), this.h[4] = sum32$1(this.h[4], L), this.h[5] = sum32$1(this.h[5], F), this.h[6] = sum32$1(this.h[6], V), this.h[7] = sum32$1(this.h[7], X);
};
SHA256$1.prototype._digest = function a(u) {
  return u === "hex" ? utils$l.toHex32(this.h, "big") : utils$l.split32(this.h, "big");
};
var utils$k = utils$p, SHA256 = _256;
function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();
  SHA256.call(this), this.h = [
    3238371032,
    914150663,
    812702999,
    4144912697,
    4290775857,
    1750603025,
    1694076839,
    3204075428
  ];
}
utils$k.inherits(SHA224, SHA256);
var _224 = SHA224;
SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;
SHA224.prototype._digest = function a(u) {
  return u === "hex" ? utils$k.toHex32(this.h.slice(0, 7), "big") : utils$k.split32(this.h.slice(0, 7), "big");
};
var utils$j = utils$p, common$1 = common$5, assert$8 = minimalisticAssert, rotr64_hi = utils$j.rotr64_hi, rotr64_lo = utils$j.rotr64_lo, shr64_hi = utils$j.shr64_hi, shr64_lo = utils$j.shr64_lo, sum64 = utils$j.sum64, sum64_hi = utils$j.sum64_hi, sum64_lo = utils$j.sum64_lo, sum64_4_hi = utils$j.sum64_4_hi, sum64_4_lo = utils$j.sum64_4_lo, sum64_5_hi = utils$j.sum64_5_hi, sum64_5_lo = utils$j.sum64_5_lo, BlockHash$1 = common$1.BlockHash, sha512_K = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
];
function SHA512$1() {
  if (!(this instanceof SHA512$1))
    return new SHA512$1();
  BlockHash$1.call(this), this.h = [
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
  ], this.k = sha512_K, this.W = new Array(160);
}
utils$j.inherits(SHA512$1, BlockHash$1);
var _512 = SHA512$1;
SHA512$1.blockSize = 1024;
SHA512$1.outSize = 512;
SHA512$1.hmacStrength = 192;
SHA512$1.padLength = 128;
SHA512$1.prototype._prepareBlock = function a(u, c) {
  for (var l = this.W, v = 0; v < 32; v++)
    l[v] = u[c + v];
  for (; v < l.length; v += 2) {
    var p = g1_512_hi(l[v - 4], l[v - 3]), _ = g1_512_lo(l[v - 4], l[v - 3]), k = l[v - 14], M = l[v - 13], L = g0_512_hi(l[v - 30], l[v - 29]), F = g0_512_lo(l[v - 30], l[v - 29]), V = l[v - 32], X = l[v - 31];
    l[v] = sum64_4_hi(
      p,
      _,
      k,
      M,
      L,
      F,
      V,
      X
    ), l[v + 1] = sum64_4_lo(
      p,
      _,
      k,
      M,
      L,
      F,
      V,
      X
    );
  }
};
SHA512$1.prototype._update = function a(u, c) {
  this._prepareBlock(u, c);
  var l = this.W, v = this.h[0], p = this.h[1], _ = this.h[2], k = this.h[3], M = this.h[4], L = this.h[5], F = this.h[6], V = this.h[7], X = this.h[8], oe = this.h[9], Y = this.h[10], ae = this.h[11], ne = this.h[12], fe = this.h[13], ie = this.h[14], ge = this.h[15];
  assert$8(this.k.length === l.length);
  for (var be = 0; be < l.length; be += 2) {
    var Ce = ie, Me = ge, Be = s1_512_hi(X, oe), Ae = s1_512_lo(X, oe), Z = ch64_hi(X, oe, Y, ae, ne), z = ch64_lo(X, oe, Y, ae, ne, fe), P = this.k[be], S = this.k[be + 1], E = l[be], I = l[be + 1], N = sum64_5_hi(
      Ce,
      Me,
      Be,
      Ae,
      Z,
      z,
      P,
      S,
      E,
      I
    ), $ = sum64_5_lo(
      Ce,
      Me,
      Be,
      Ae,
      Z,
      z,
      P,
      S,
      E,
      I
    );
    Ce = s0_512_hi(v, p), Me = s0_512_lo(v, p), Be = maj64_hi(v, p, _, k, M), Ae = maj64_lo(v, p, _, k, M, L);
    var U = sum64_hi(Ce, Me, Be, Ae), H = sum64_lo(Ce, Me, Be, Ae);
    ie = ne, ge = fe, ne = Y, fe = ae, Y = X, ae = oe, X = sum64_hi(F, V, N, $), oe = sum64_lo(V, V, N, $), F = M, V = L, M = _, L = k, _ = v, k = p, v = sum64_hi(N, $, U, H), p = sum64_lo(N, $, U, H);
  }
  sum64(this.h, 0, v, p), sum64(this.h, 2, _, k), sum64(this.h, 4, M, L), sum64(this.h, 6, F, V), sum64(this.h, 8, X, oe), sum64(this.h, 10, Y, ae), sum64(this.h, 12, ne, fe), sum64(this.h, 14, ie, ge);
};
SHA512$1.prototype._digest = function a(u) {
  return u === "hex" ? utils$j.toHex32(this.h, "big") : utils$j.split32(this.h, "big");
};
function ch64_hi(a, u, c, l, v) {
  var p = a & c ^ ~a & v;
  return p < 0 && (p += 4294967296), p;
}
function ch64_lo(a, u, c, l, v, p) {
  var _ = u & l ^ ~u & p;
  return _ < 0 && (_ += 4294967296), _;
}
function maj64_hi(a, u, c, l, v) {
  var p = a & c ^ a & v ^ c & v;
  return p < 0 && (p += 4294967296), p;
}
function maj64_lo(a, u, c, l, v, p) {
  var _ = u & l ^ u & p ^ l & p;
  return _ < 0 && (_ += 4294967296), _;
}
function s0_512_hi(a, u) {
  var c = rotr64_hi(a, u, 28), l = rotr64_hi(u, a, 2), v = rotr64_hi(u, a, 7), p = c ^ l ^ v;
  return p < 0 && (p += 4294967296), p;
}
function s0_512_lo(a, u) {
  var c = rotr64_lo(a, u, 28), l = rotr64_lo(u, a, 2), v = rotr64_lo(u, a, 7), p = c ^ l ^ v;
  return p < 0 && (p += 4294967296), p;
}
function s1_512_hi(a, u) {
  var c = rotr64_hi(a, u, 14), l = rotr64_hi(a, u, 18), v = rotr64_hi(u, a, 9), p = c ^ l ^ v;
  return p < 0 && (p += 4294967296), p;
}
function s1_512_lo(a, u) {
  var c = rotr64_lo(a, u, 14), l = rotr64_lo(a, u, 18), v = rotr64_lo(u, a, 9), p = c ^ l ^ v;
  return p < 0 && (p += 4294967296), p;
}
function g0_512_hi(a, u) {
  var c = rotr64_hi(a, u, 1), l = rotr64_hi(a, u, 8), v = shr64_hi(a, u, 7), p = c ^ l ^ v;
  return p < 0 && (p += 4294967296), p;
}
function g0_512_lo(a, u) {
  var c = rotr64_lo(a, u, 1), l = rotr64_lo(a, u, 8), v = shr64_lo(a, u, 7), p = c ^ l ^ v;
  return p < 0 && (p += 4294967296), p;
}
function g1_512_hi(a, u) {
  var c = rotr64_hi(a, u, 19), l = rotr64_hi(u, a, 29), v = shr64_hi(a, u, 6), p = c ^ l ^ v;
  return p < 0 && (p += 4294967296), p;
}
function g1_512_lo(a, u) {
  var c = rotr64_lo(a, u, 19), l = rotr64_lo(u, a, 29), v = shr64_lo(a, u, 6), p = c ^ l ^ v;
  return p < 0 && (p += 4294967296), p;
}
var utils$i = utils$p, SHA512 = _512;
function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();
  SHA512.call(this), this.h = [
    3418070365,
    3238371032,
    1654270250,
    914150663,
    2438529370,
    812702999,
    355462360,
    4144912697,
    1731405415,
    4290775857,
    2394180231,
    1750603025,
    3675008525,
    1694076839,
    1203062813,
    3204075428
  ];
}
utils$i.inherits(SHA384, SHA512);
var _384 = SHA384;
SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;
SHA384.prototype._digest = function a(u) {
  return u === "hex" ? utils$i.toHex32(this.h.slice(0, 12), "big") : utils$i.split32(this.h.slice(0, 12), "big");
};
sha.sha1 = _1;
sha.sha224 = _224;
sha.sha256 = _256;
sha.sha384 = _384;
sha.sha512 = _512;
var ripemd = {}, utils$h = utils$p, common = common$5, rotl32 = utils$h.rotl32, sum32 = utils$h.sum32, sum32_3 = utils$h.sum32_3, sum32_4 = utils$h.sum32_4, BlockHash = common.BlockHash;
function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();
  BlockHash.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
}
utils$h.inherits(RIPEMD160, BlockHash);
ripemd.ripemd160 = RIPEMD160;
RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;
RIPEMD160.prototype._update = function a(u, c) {
  for (var l = this.h[0], v = this.h[1], p = this.h[2], _ = this.h[3], k = this.h[4], M = l, L = v, F = p, V = _, X = k, oe = 0; oe < 80; oe++) {
    var Y = sum32(
      rotl32(
        sum32_4(l, f(oe, v, p, _), u[r[oe] + c], K(oe)),
        s$1[oe]
      ),
      k
    );
    l = k, k = _, _ = rotl32(p, 10), p = v, v = Y, Y = sum32(
      rotl32(
        sum32_4(M, f(79 - oe, L, F, V), u[rh[oe] + c], Kh(oe)),
        sh[oe]
      ),
      X
    ), M = X, X = V, V = rotl32(F, 10), F = L, L = Y;
  }
  Y = sum32_3(this.h[1], p, V), this.h[1] = sum32_3(this.h[2], _, X), this.h[2] = sum32_3(this.h[3], k, M), this.h[3] = sum32_3(this.h[4], l, L), this.h[4] = sum32_3(this.h[0], v, F), this.h[0] = Y;
};
RIPEMD160.prototype._digest = function a(u) {
  return u === "hex" ? utils$h.toHex32(this.h, "little") : utils$h.split32(this.h, "little");
};
function f(a, u, c, l) {
  return a <= 15 ? u ^ c ^ l : a <= 31 ? u & c | ~u & l : a <= 47 ? (u | ~c) ^ l : a <= 63 ? u & l | c & ~l : u ^ (c | ~l);
}
function K(a) {
  return a <= 15 ? 0 : a <= 31 ? 1518500249 : a <= 47 ? 1859775393 : a <= 63 ? 2400959708 : 2840853838;
}
function Kh(a) {
  return a <= 15 ? 1352829926 : a <= 31 ? 1548603684 : a <= 47 ? 1836072691 : a <= 63 ? 2053994217 : 0;
}
var r = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
], rh = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
], s$1 = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
], sh = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
], utils$g = utils$p, assert$7 = minimalisticAssert;
function Hmac(a, u, c) {
  if (!(this instanceof Hmac))
    return new Hmac(a, u, c);
  this.Hash = a, this.blockSize = a.blockSize / 8, this.outSize = a.outSize / 8, this.inner = null, this.outer = null, this._init(utils$g.toArray(u, c));
}
var hmac = Hmac;
Hmac.prototype._init = function a(u) {
  u.length > this.blockSize && (u = new this.Hash().update(u).digest()), assert$7(u.length <= this.blockSize);
  for (var c = u.length; c < this.blockSize; c++)
    u.push(0);
  for (c = 0; c < u.length; c++)
    u[c] ^= 54;
  for (this.inner = new this.Hash().update(u), c = 0; c < u.length; c++)
    u[c] ^= 106;
  this.outer = new this.Hash().update(u);
};
Hmac.prototype.update = function a(u, c) {
  return this.inner.update(u, c), this;
};
Hmac.prototype.digest = function a(u) {
  return this.outer.update(this.inner.digest()), this.outer.digest(u);
};
(function(a) {
  var u = a;
  u.utils = utils$p, u.common = common$5, u.sha = sha, u.ripemd = ripemd, u.hmac = hmac, u.sha1 = u.sha.sha1, u.sha256 = u.sha.sha256, u.sha224 = u.sha.sha224, u.sha384 = u.sha.sha384, u.sha512 = u.sha.sha512, u.ripemd160 = u.ripemd.ripemd160;
})(hash$2);
var secp256k1, hasRequiredSecp256k1;
function requireSecp256k1() {
  return hasRequiredSecp256k1 || (hasRequiredSecp256k1 = 1, secp256k1 = {
    doubles: {
      step: 4,
      points: [
        [
          "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
          "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
        ],
        [
          "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
          "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
        ],
        [
          "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
          "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
        ],
        [
          "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
          "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
        ],
        [
          "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
          "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
        ],
        [
          "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
          "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
        ],
        [
          "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
          "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
        ],
        [
          "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
          "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
        ],
        [
          "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
          "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
        ],
        [
          "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
          "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
        ],
        [
          "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
          "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
        ],
        [
          "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
          "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
        ],
        [
          "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
          "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
        ],
        [
          "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
          "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
        ],
        [
          "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
          "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
        ],
        [
          "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
          "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
        ],
        [
          "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
          "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
        ],
        [
          "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
          "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
        ],
        [
          "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
          "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
        ],
        [
          "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
          "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
        ],
        [
          "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
          "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
        ],
        [
          "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
          "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
        ],
        [
          "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
          "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
        ],
        [
          "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
          "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
        ],
        [
          "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
          "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
        ],
        [
          "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
          "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
        ],
        [
          "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
          "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
        ],
        [
          "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
          "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
        ],
        [
          "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
          "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
        ],
        [
          "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
          "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
        ],
        [
          "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
          "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
        ],
        [
          "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
          "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
        ],
        [
          "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
          "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
        ],
        [
          "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
          "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
        ],
        [
          "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
          "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
        ],
        [
          "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
          "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
        ],
        [
          "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
          "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
        ],
        [
          "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
          "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
        ],
        [
          "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
          "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
        ],
        [
          "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
          "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
        ],
        [
          "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
          "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
        ],
        [
          "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
          "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
        ],
        [
          "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
          "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
        ],
        [
          "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
          "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
        ],
        [
          "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
          "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
        ],
        [
          "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
          "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
        ],
        [
          "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
          "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
        ],
        [
          "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
          "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
        ],
        [
          "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
          "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
        ],
        [
          "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
          "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
        ],
        [
          "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
          "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
        ],
        [
          "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
          "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
        ],
        [
          "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
          "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
        ],
        [
          "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
          "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
        ],
        [
          "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
          "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
        ],
        [
          "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
          "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
        ],
        [
          "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
          "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
        ],
        [
          "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
          "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
        ],
        [
          "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
          "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
        ],
        [
          "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
          "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
        ],
        [
          "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
          "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
        ],
        [
          "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
          "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
        ],
        [
          "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
          "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
        ],
        [
          "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
          "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
        ],
        [
          "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
          "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
        ]
      ]
    },
    naf: {
      wnd: 7,
      points: [
        [
          "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
          "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
        ],
        [
          "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
          "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
        ],
        [
          "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
          "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
        ],
        [
          "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
          "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
        ],
        [
          "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
          "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
        ],
        [
          "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
          "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
        ],
        [
          "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
          "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
        ],
        [
          "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
          "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
        ],
        [
          "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
          "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
        ],
        [
          "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
          "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
        ],
        [
          "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
          "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
        ],
        [
          "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
          "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
        ],
        [
          "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
          "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
        ],
        [
          "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
          "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
        ],
        [
          "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
          "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
        ],
        [
          "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
          "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
        ],
        [
          "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
          "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
        ],
        [
          "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
          "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
        ],
        [
          "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
          "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
        ],
        [
          "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
          "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
        ],
        [
          "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
          "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
        ],
        [
          "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
          "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
        ],
        [
          "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
          "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
        ],
        [
          "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
          "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
        ],
        [
          "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
          "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
        ],
        [
          "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
          "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
        ],
        [
          "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
          "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
        ],
        [
          "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
          "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
        ],
        [
          "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
          "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
        ],
        [
          "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
          "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
        ],
        [
          "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
          "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
        ],
        [
          "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
          "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
        ],
        [
          "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
          "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
        ],
        [
          "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
          "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
        ],
        [
          "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
          "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
        ],
        [
          "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
          "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
        ],
        [
          "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
          "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
        ],
        [
          "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
          "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
        ],
        [
          "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
          "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
        ],
        [
          "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
          "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
        ],
        [
          "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
          "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
        ],
        [
          "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
          "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
        ],
        [
          "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
          "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
        ],
        [
          "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
          "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
        ],
        [
          "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
          "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
        ],
        [
          "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
          "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
        ],
        [
          "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
          "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
        ],
        [
          "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
          "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
        ],
        [
          "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
          "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
        ],
        [
          "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
          "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
        ],
        [
          "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
          "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
        ],
        [
          "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
          "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
        ],
        [
          "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
          "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
        ],
        [
          "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
          "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
        ],
        [
          "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
          "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
        ],
        [
          "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
          "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
        ],
        [
          "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
          "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
        ],
        [
          "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
          "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
        ],
        [
          "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
          "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
        ],
        [
          "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
          "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
        ],
        [
          "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
          "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
        ],
        [
          "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
          "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
        ],
        [
          "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
          "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
        ],
        [
          "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
          "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
        ],
        [
          "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
          "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
        ],
        [
          "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
          "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
        ],
        [
          "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
          "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
        ],
        [
          "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
          "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
        ],
        [
          "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
          "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
        ],
        [
          "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
          "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
        ],
        [
          "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
          "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
        ],
        [
          "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
          "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
        ],
        [
          "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
          "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
        ],
        [
          "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
          "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
        ],
        [
          "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
          "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
        ],
        [
          "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
          "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
        ],
        [
          "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
          "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
        ],
        [
          "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
          "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
        ],
        [
          "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
          "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
        ],
        [
          "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
          "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
        ],
        [
          "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
          "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
        ],
        [
          "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
          "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
        ],
        [
          "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
          "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
        ],
        [
          "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
          "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
        ],
        [
          "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
          "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
        ],
        [
          "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
          "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
        ],
        [
          "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
          "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
        ],
        [
          "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
          "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
        ],
        [
          "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
          "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
        ],
        [
          "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
          "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
        ],
        [
          "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
          "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
        ],
        [
          "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
          "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
        ],
        [
          "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
          "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
        ],
        [
          "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
          "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
        ],
        [
          "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
          "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
        ],
        [
          "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
          "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
        ],
        [
          "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
          "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
        ],
        [
          "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
          "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
        ],
        [
          "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
          "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
        ],
        [
          "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
          "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
        ],
        [
          "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
          "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
        ],
        [
          "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
          "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
        ],
        [
          "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
          "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
        ],
        [
          "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
          "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
        ],
        [
          "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
          "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
        ],
        [
          "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
          "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
        ],
        [
          "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
          "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
        ],
        [
          "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
          "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
        ],
        [
          "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
          "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
        ],
        [
          "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
          "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
        ],
        [
          "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
          "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
        ],
        [
          "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
          "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
        ],
        [
          "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
          "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
        ],
        [
          "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
          "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
        ],
        [
          "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
          "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
        ],
        [
          "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
          "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
        ],
        [
          "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
          "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
        ],
        [
          "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
          "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
        ],
        [
          "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
          "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
        ],
        [
          "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
          "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
        ],
        [
          "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
          "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
        ],
        [
          "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
          "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
        ],
        [
          "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
          "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
        ],
        [
          "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
          "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
        ],
        [
          "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
          "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
        ],
        [
          "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
          "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
        ],
        [
          "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
          "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
        ]
      ]
    }
  }), secp256k1;
}
(function(a) {
  var u = a, c = hash$2, l = curve, v = utils$v, p = v.assert;
  function _(L) {
    L.type === "short" ? this.curve = new l.short(L) : L.type === "edwards" ? this.curve = new l.edwards(L) : this.curve = new l.mont(L), this.g = this.curve.g, this.n = this.curve.n, this.hash = L.hash, p(this.g.validate(), "Invalid curve"), p(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  u.PresetCurve = _;
  function k(L, F) {
    Object.defineProperty(u, L, {
      configurable: !0,
      enumerable: !0,
      get: function() {
        var V = new _(F);
        return Object.defineProperty(u, L, {
          configurable: !0,
          enumerable: !0,
          value: V
        }), V;
      }
    });
  }
  k("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: c.sha256,
    gRed: !1,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  }), k("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: c.sha256,
    gRed: !1,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  }), k("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: c.sha256,
    gRed: !1,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  }), k("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: c.sha384,
    gRed: !1,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  }), k("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: c.sha512,
    gRed: !1,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  }), k("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: c.sha256,
    gRed: !1,
    g: [
      "9"
    ]
  }), k("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    // -121665 * (121666^(-1)) (mod P)
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: c.sha256,
    gRed: !1,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      // 4/5
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var M;
  try {
    M = requireSecp256k1();
  } catch {
    M = void 0;
  }
  k("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: c.sha256,
    // Precomputed endomorphism
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: !1,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      M
    ]
  });
})(curves$1);
var hash$1 = hash$2, utils$f = utils$u, assert$6 = minimalisticAssert;
function HmacDRBG(a) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(a);
  this.hash = a.hash, this.predResist = !!a.predResist, this.outLen = this.hash.outSize, this.minEntropy = a.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
  var u = utils$f.toArray(a.entropy, a.entropyEnc || "hex"), c = utils$f.toArray(a.nonce, a.nonceEnc || "hex"), l = utils$f.toArray(a.pers, a.persEnc || "hex");
  assert$6(
    u.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._init(u, c, l);
}
var hmacDrbg = HmacDRBG;
HmacDRBG.prototype._init = function a(u, c, l) {
  var v = u.concat(c).concat(l);
  this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
  for (var p = 0; p < this.V.length; p++)
    this.K[p] = 0, this.V[p] = 1;
  this._update(v), this._reseed = 1, this.reseedInterval = 281474976710656;
};
HmacDRBG.prototype._hmac = function a() {
  return new hash$1.hmac(this.hash, this.K);
};
HmacDRBG.prototype._update = function a(u) {
  var c = this._hmac().update(this.V).update([0]);
  u && (c = c.update(u)), this.K = c.digest(), this.V = this._hmac().update(this.V).digest(), u && (this.K = this._hmac().update(this.V).update([1]).update(u).digest(), this.V = this._hmac().update(this.V).digest());
};
HmacDRBG.prototype.reseed = function a(u, c, l, v) {
  typeof c != "string" && (v = l, l = c, c = null), u = utils$f.toArray(u, c), l = utils$f.toArray(l, v), assert$6(
    u.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._update(u.concat(l || [])), this._reseed = 1;
};
HmacDRBG.prototype.generate = function a(u, c, l, v) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  typeof c != "string" && (v = l, l = c, c = null), l && (l = utils$f.toArray(l, v || "hex"), this._update(l));
  for (var p = []; p.length < u; )
    this.V = this._hmac().update(this.V).digest(), p = p.concat(this.V);
  var _ = p.slice(0, u);
  return this._update(l), this._reseed++, utils$f.encode(_, c);
};
var BN$5 = bnExports$3, utils$e = utils$v, assert$5 = utils$e.assert;
function KeyPair$2(a, u) {
  this.ec = a, this.priv = null, this.pub = null, u.priv && this._importPrivate(u.priv, u.privEnc), u.pub && this._importPublic(u.pub, u.pubEnc);
}
var key$2 = KeyPair$2;
KeyPair$2.fromPublic = function a(u, c, l) {
  return c instanceof KeyPair$2 ? c : new KeyPair$2(u, {
    pub: c,
    pubEnc: l
  });
};
KeyPair$2.fromPrivate = function a(u, c, l) {
  return c instanceof KeyPair$2 ? c : new KeyPair$2(u, {
    priv: c,
    privEnc: l
  });
};
KeyPair$2.prototype.validate = function a() {
  var u = this.getPublic();
  return u.isInfinity() ? { result: !1, reason: "Invalid public key" } : u.validate() ? u.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" };
};
KeyPair$2.prototype.getPublic = function a(u, c) {
  return typeof u == "string" && (c = u, u = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), c ? this.pub.encode(c, u) : this.pub;
};
KeyPair$2.prototype.getPrivate = function a(u) {
  return u === "hex" ? this.priv.toString(16, 2) : this.priv;
};
KeyPair$2.prototype._importPrivate = function a(u, c) {
  this.priv = new BN$5(u, c || 16), this.priv = this.priv.umod(this.ec.curve.n);
};
KeyPair$2.prototype._importPublic = function a(u, c) {
  if (u.x || u.y) {
    this.ec.curve.type === "mont" ? assert$5(u.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && assert$5(u.x && u.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(u.x, u.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(u, c);
};
KeyPair$2.prototype.derive = function a(u) {
  return u.validate() || assert$5(u.validate(), "public point not validated"), u.mul(this.priv).getX();
};
KeyPair$2.prototype.sign = function a(u, c, l) {
  return this.ec.sign(u, this, c, l);
};
KeyPair$2.prototype.verify = function a(u, c) {
  return this.ec.verify(u, c, this);
};
KeyPair$2.prototype.inspect = function a() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var BN$4 = bnExports$3, utils$d = utils$v, assert$4 = utils$d.assert;
function Signature$2(a, u) {
  if (a instanceof Signature$2)
    return a;
  this._importDER(a, u) || (assert$4(a.r && a.s, "Signature without r or s"), this.r = new BN$4(a.r, 16), this.s = new BN$4(a.s, 16), a.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = a.recoveryParam);
}
var signature$1 = Signature$2;
function Position() {
  this.place = 0;
}
function getLength(a, u) {
  var c = a[u.place++];
  if (!(c & 128))
    return c;
  var l = c & 15;
  if (l === 0 || l > 4)
    return !1;
  for (var v = 0, p = 0, _ = u.place; p < l; p++, _++)
    v <<= 8, v |= a[_], v >>>= 0;
  return v <= 127 ? !1 : (u.place = _, v);
}
function rmPadding(a) {
  for (var u = 0, c = a.length - 1; !a[u] && !(a[u + 1] & 128) && u < c; )
    u++;
  return u === 0 ? a : a.slice(u);
}
Signature$2.prototype._importDER = function a(u, c) {
  u = utils$d.toArray(u, c);
  var l = new Position();
  if (u[l.place++] !== 48)
    return !1;
  var v = getLength(u, l);
  if (v === !1 || v + l.place !== u.length || u[l.place++] !== 2)
    return !1;
  var p = getLength(u, l);
  if (p === !1)
    return !1;
  var _ = u.slice(l.place, p + l.place);
  if (l.place += p, u[l.place++] !== 2)
    return !1;
  var k = getLength(u, l);
  if (k === !1 || u.length !== k + l.place)
    return !1;
  var M = u.slice(l.place, k + l.place);
  if (_[0] === 0)
    if (_[1] & 128)
      _ = _.slice(1);
    else
      return !1;
  if (M[0] === 0)
    if (M[1] & 128)
      M = M.slice(1);
    else
      return !1;
  return this.r = new BN$4(_), this.s = new BN$4(M), this.recoveryParam = null, !0;
};
function constructLength(a, u) {
  if (u < 128) {
    a.push(u);
    return;
  }
  var c = 1 + (Math.log(u) / Math.LN2 >>> 3);
  for (a.push(c | 128); --c; )
    a.push(u >>> (c << 3) & 255);
  a.push(u);
}
Signature$2.prototype.toDER = function a(u) {
  var c = this.r.toArray(), l = this.s.toArray();
  for (c[0] & 128 && (c = [0].concat(c)), l[0] & 128 && (l = [0].concat(l)), c = rmPadding(c), l = rmPadding(l); !l[0] && !(l[1] & 128); )
    l = l.slice(1);
  var v = [2];
  constructLength(v, c.length), v = v.concat(c), v.push(2), constructLength(v, l.length);
  var p = v.concat(l), _ = [48];
  return constructLength(_, p.length), _ = _.concat(p), utils$d.encode(_, u);
};
var ec, hasRequiredEc;
function requireEc() {
  if (hasRequiredEc)
    return ec;
  hasRequiredEc = 1;
  var a = bnExports$3, u = hmacDrbg, c = utils$v, l = curves$1, v = requireBrorand(), p = c.assert, _ = key$2, k = signature$1;
  function M(L) {
    if (!(this instanceof M))
      return new M(L);
    typeof L == "string" && (p(
      Object.prototype.hasOwnProperty.call(l, L),
      "Unknown curve " + L
    ), L = l[L]), L instanceof l.PresetCurve && (L = { curve: L }), this.curve = L.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = L.curve.g, this.g.precompute(L.curve.n.bitLength() + 1), this.hash = L.hash || L.curve.hash;
  }
  return ec = M, M.prototype.keyPair = function(F) {
    return new _(this, F);
  }, M.prototype.keyFromPrivate = function(F, V) {
    return _.fromPrivate(this, F, V);
  }, M.prototype.keyFromPublic = function(F, V) {
    return _.fromPublic(this, F, V);
  }, M.prototype.genKeyPair = function(F) {
    F || (F = {});
    for (var V = new u({
      hash: this.hash,
      pers: F.pers,
      persEnc: F.persEnc || "utf8",
      entropy: F.entropy || v(this.hash.hmacStrength),
      entropyEnc: F.entropy && F.entropyEnc || "utf8",
      nonce: this.n.toArray()
    }), X = this.n.byteLength(), oe = this.n.sub(new a(2)); ; ) {
      var Y = new a(V.generate(X));
      if (!(Y.cmp(oe) > 0))
        return Y.iaddn(1), this.keyFromPrivate(Y);
    }
  }, M.prototype._truncateToN = function(F, V) {
    var X = F.byteLength() * 8 - this.n.bitLength();
    return X > 0 && (F = F.ushrn(X)), !V && F.cmp(this.n) >= 0 ? F.sub(this.n) : F;
  }, M.prototype.sign = function(F, V, X, oe) {
    typeof X == "object" && (oe = X, X = null), oe || (oe = {}), V = this.keyFromPrivate(V, X), F = this._truncateToN(new a(F, 16));
    for (var Y = this.n.byteLength(), ae = V.getPrivate().toArray("be", Y), ne = F.toArray("be", Y), fe = new u({
      hash: this.hash,
      entropy: ae,
      nonce: ne,
      pers: oe.pers,
      persEnc: oe.persEnc || "utf8"
    }), ie = this.n.sub(new a(1)), ge = 0; ; ge++) {
      var be = oe.k ? oe.k(ge) : new a(fe.generate(this.n.byteLength()));
      if (be = this._truncateToN(be, !0), !(be.cmpn(1) <= 0 || be.cmp(ie) >= 0)) {
        var Ce = this.g.mul(be);
        if (!Ce.isInfinity()) {
          var Me = Ce.getX(), Be = Me.umod(this.n);
          if (Be.cmpn(0) !== 0) {
            var Ae = be.invm(this.n).mul(Be.mul(V.getPrivate()).iadd(F));
            if (Ae = Ae.umod(this.n), Ae.cmpn(0) !== 0) {
              var Z = (Ce.getY().isOdd() ? 1 : 0) | (Me.cmp(Be) !== 0 ? 2 : 0);
              return oe.canonical && Ae.cmp(this.nh) > 0 && (Ae = this.n.sub(Ae), Z ^= 1), new k({ r: Be, s: Ae, recoveryParam: Z });
            }
          }
        }
      }
    }
  }, M.prototype.verify = function(F, V, X, oe) {
    F = this._truncateToN(new a(F, 16)), X = this.keyFromPublic(X, oe), V = new k(V, "hex");
    var Y = V.r, ae = V.s;
    if (Y.cmpn(1) < 0 || Y.cmp(this.n) >= 0 || ae.cmpn(1) < 0 || ae.cmp(this.n) >= 0)
      return !1;
    var ne = ae.invm(this.n), fe = ne.mul(F).umod(this.n), ie = ne.mul(Y).umod(this.n), ge;
    return this.curve._maxwellTrick ? (ge = this.g.jmulAdd(fe, X.getPublic(), ie), ge.isInfinity() ? !1 : ge.eqXToP(Y)) : (ge = this.g.mulAdd(fe, X.getPublic(), ie), ge.isInfinity() ? !1 : ge.getX().umod(this.n).cmp(Y) === 0);
  }, M.prototype.recoverPubKey = function(L, F, V, X) {
    p((3 & V) === V, "The recovery param is more than two bits"), F = new k(F, X);
    var oe = this.n, Y = new a(L), ae = F.r, ne = F.s, fe = V & 1, ie = V >> 1;
    if (ae.cmp(this.curve.p.umod(this.curve.n)) >= 0 && ie)
      throw new Error("Unable to find sencond key candinate");
    ie ? ae = this.curve.pointFromX(ae.add(this.curve.n), fe) : ae = this.curve.pointFromX(ae, fe);
    var ge = F.r.invm(oe), be = oe.sub(Y).mul(ge).umod(oe), Ce = ne.mul(ge).umod(oe);
    return this.g.mulAdd(be, ae, Ce);
  }, M.prototype.getKeyRecoveryParam = function(L, F, V, X) {
    if (F = new k(F, X), F.recoveryParam !== null)
      return F.recoveryParam;
    for (var oe = 0; oe < 4; oe++) {
      var Y;
      try {
        Y = this.recoverPubKey(L, F, oe);
      } catch {
        continue;
      }
      if (Y.eq(V))
        return oe;
    }
    throw new Error("Unable to find valid recovery factor");
  }, ec;
}
var utils$c = utils$v, assert$3 = utils$c.assert, parseBytes$2 = utils$c.parseBytes, cachedProperty$1 = utils$c.cachedProperty;
function KeyPair$1(a, u) {
  this.eddsa = a, this._secret = parseBytes$2(u.secret), a.isPoint(u.pub) ? this._pub = u.pub : this._pubBytes = parseBytes$2(u.pub);
}
KeyPair$1.fromPublic = function a(u, c) {
  return c instanceof KeyPair$1 ? c : new KeyPair$1(u, { pub: c });
};
KeyPair$1.fromSecret = function a(u, c) {
  return c instanceof KeyPair$1 ? c : new KeyPair$1(u, { secret: c });
};
KeyPair$1.prototype.secret = function a() {
  return this._secret;
};
cachedProperty$1(KeyPair$1, "pubBytes", function a() {
  return this.eddsa.encodePoint(this.pub());
});
cachedProperty$1(KeyPair$1, "pub", function a() {
  return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
});
cachedProperty$1(KeyPair$1, "privBytes", function a() {
  var u = this.eddsa, c = this.hash(), l = u.encodingLength - 1, v = c.slice(0, u.encodingLength);
  return v[0] &= 248, v[l] &= 127, v[l] |= 64, v;
});
cachedProperty$1(KeyPair$1, "priv", function a() {
  return this.eddsa.decodeInt(this.privBytes());
});
cachedProperty$1(KeyPair$1, "hash", function a() {
  return this.eddsa.hash().update(this.secret()).digest();
});
cachedProperty$1(KeyPair$1, "messagePrefix", function a() {
  return this.hash().slice(this.eddsa.encodingLength);
});
KeyPair$1.prototype.sign = function a(u) {
  return assert$3(this._secret, "KeyPair can only verify"), this.eddsa.sign(u, this);
};
KeyPair$1.prototype.verify = function a(u, c) {
  return this.eddsa.verify(u, c, this);
};
KeyPair$1.prototype.getSecret = function a(u) {
  return assert$3(this._secret, "KeyPair is public only"), utils$c.encode(this.secret(), u);
};
KeyPair$1.prototype.getPublic = function a(u) {
  return utils$c.encode(this.pubBytes(), u);
};
var key$1 = KeyPair$1, BN$3 = bnExports$3, utils$b = utils$v, assert$2 = utils$b.assert, cachedProperty = utils$b.cachedProperty, parseBytes$1 = utils$b.parseBytes;
function Signature$1(a, u) {
  this.eddsa = a, typeof u != "object" && (u = parseBytes$1(u)), Array.isArray(u) && (u = {
    R: u.slice(0, a.encodingLength),
    S: u.slice(a.encodingLength)
  }), assert$2(u.R && u.S, "Signature without R or S"), a.isPoint(u.R) && (this._R = u.R), u.S instanceof BN$3 && (this._S = u.S), this._Rencoded = Array.isArray(u.R) ? u.R : u.Rencoded, this._Sencoded = Array.isArray(u.S) ? u.S : u.Sencoded;
}
cachedProperty(Signature$1, "S", function a() {
  return this.eddsa.decodeInt(this.Sencoded());
});
cachedProperty(Signature$1, "R", function a() {
  return this.eddsa.decodePoint(this.Rencoded());
});
cachedProperty(Signature$1, "Rencoded", function a() {
  return this.eddsa.encodePoint(this.R());
});
cachedProperty(Signature$1, "Sencoded", function a() {
  return this.eddsa.encodeInt(this.S());
});
Signature$1.prototype.toBytes = function a() {
  return this.Rencoded().concat(this.Sencoded());
};
Signature$1.prototype.toHex = function a() {
  return utils$b.encode(this.toBytes(), "hex").toUpperCase();
};
var signature = Signature$1, hash = hash$2, curves = curves$1, utils$a = utils$v, assert$1 = utils$a.assert, parseBytes = utils$a.parseBytes, KeyPair = key$1, Signature = signature;
function EDDSA(a) {
  if (assert$1(a === "ed25519", "only tested with ed25519 so far"), !(this instanceof EDDSA))
    return new EDDSA(a);
  a = curves[a].curve, this.curve = a, this.g = a.g, this.g.precompute(a.n.bitLength() + 1), this.pointClass = a.point().constructor, this.encodingLength = Math.ceil(a.n.bitLength() / 8), this.hash = hash.sha512;
}
var eddsa = EDDSA;
EDDSA.prototype.sign = function a(u, c) {
  u = parseBytes(u);
  var l = this.keyFromSecret(c), v = this.hashInt(l.messagePrefix(), u), p = this.g.mul(v), _ = this.encodePoint(p), k = this.hashInt(_, l.pubBytes(), u).mul(l.priv()), M = v.add(k).umod(this.curve.n);
  return this.makeSignature({ R: p, S: M, Rencoded: _ });
};
EDDSA.prototype.verify = function a(u, c, l) {
  u = parseBytes(u), c = this.makeSignature(c);
  var v = this.keyFromPublic(l), p = this.hashInt(c.Rencoded(), v.pubBytes(), u), _ = this.g.mul(c.S()), k = c.R().add(v.pub().mul(p));
  return k.eq(_);
};
EDDSA.prototype.hashInt = function a() {
  for (var u = this.hash(), c = 0; c < arguments.length; c++)
    u.update(arguments[c]);
  return utils$a.intFromLE(u.digest()).umod(this.curve.n);
};
EDDSA.prototype.keyFromPublic = function a(u) {
  return KeyPair.fromPublic(this, u);
};
EDDSA.prototype.keyFromSecret = function a(u) {
  return KeyPair.fromSecret(this, u);
};
EDDSA.prototype.makeSignature = function a(u) {
  return u instanceof Signature ? u : new Signature(this, u);
};
EDDSA.prototype.encodePoint = function a(u) {
  var c = u.getY().toArray("le", this.encodingLength);
  return c[this.encodingLength - 1] |= u.getX().isOdd() ? 128 : 0, c;
};
EDDSA.prototype.decodePoint = function a(u) {
  u = utils$a.parseBytes(u);
  var c = u.length - 1, l = u.slice(0, c).concat(u[c] & -129), v = (u[c] & 128) !== 0, p = utils$a.intFromLE(l);
  return this.curve.pointFromY(p, v);
};
EDDSA.prototype.encodeInt = function a(u) {
  return u.toArray("le", this.encodingLength);
};
EDDSA.prototype.decodeInt = function a(u) {
  return utils$a.intFromLE(u);
};
EDDSA.prototype.isPoint = function a(u) {
  return u instanceof this.pointClass;
};
var hasRequiredElliptic;
function requireElliptic() {
  return hasRequiredElliptic || (hasRequiredElliptic = 1, function(a) {
    var u = a;
    u.version = require$$0$1.version, u.utils = utils$v, u.rand = requireBrorand(), u.curve = curve, u.curves = curves$1, u.ec = requireEc(), u.eddsa = eddsa;
  }(elliptic)), elliptic;
}
var asn1$3 = {}, asn1$2 = {}, bn$2 = { exports: {} };
bn$2.exports;
(function(a) {
  (function(u, c) {
    function l(P, S) {
      if (!P)
        throw new Error(S || "Assertion failed");
    }
    function v(P, S) {
      P.super_ = S;
      var E = function() {
      };
      E.prototype = S.prototype, P.prototype = new E(), P.prototype.constructor = P;
    }
    function p(P, S, E) {
      if (p.isBN(P))
        return P;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, P !== null && ((S === "le" || S === "be") && (E = S, S = 10), this._init(P || 0, S || 10, E || "be"));
    }
    typeof u == "object" ? u.exports = p : c.BN = p, p.BN = p, p.wordSize = 26;
    var _;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? _ = window.Buffer : _ = require$$0$2.Buffer;
    } catch {
    }
    p.isBN = function(S) {
      return S instanceof p ? !0 : S !== null && typeof S == "object" && S.constructor.wordSize === p.wordSize && Array.isArray(S.words);
    }, p.max = function(S, E) {
      return S.cmp(E) > 0 ? S : E;
    }, p.min = function(S, E) {
      return S.cmp(E) < 0 ? S : E;
    }, p.prototype._init = function(S, E, I) {
      if (typeof S == "number")
        return this._initNumber(S, E, I);
      if (typeof S == "object")
        return this._initArray(S, E, I);
      E === "hex" && (E = 16), l(E === (E | 0) && E >= 2 && E <= 36), S = S.toString().replace(/\s+/g, "");
      var N = 0;
      S[0] === "-" && (N++, this.negative = 1), N < S.length && (E === 16 ? this._parseHex(S, N, I) : (this._parseBase(S, E, N), I === "le" && this._initArray(this.toArray(), E, I)));
    }, p.prototype._initNumber = function(S, E, I) {
      S < 0 && (this.negative = 1, S = -S), S < 67108864 ? (this.words = [S & 67108863], this.length = 1) : S < 4503599627370496 ? (this.words = [
        S & 67108863,
        S / 67108864 & 67108863
      ], this.length = 2) : (l(S < 9007199254740992), this.words = [
        S & 67108863,
        S / 67108864 & 67108863,
        1
      ], this.length = 3), I === "le" && this._initArray(this.toArray(), E, I);
    }, p.prototype._initArray = function(S, E, I) {
      if (l(typeof S.length == "number"), S.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(S.length / 3), this.words = new Array(this.length);
      for (var N = 0; N < this.length; N++)
        this.words[N] = 0;
      var $, U, H = 0;
      if (I === "be")
        for (N = S.length - 1, $ = 0; N >= 0; N -= 3)
          U = S[N] | S[N - 1] << 8 | S[N - 2] << 16, this.words[$] |= U << H & 67108863, this.words[$ + 1] = U >>> 26 - H & 67108863, H += 24, H >= 26 && (H -= 26, $++);
      else if (I === "le")
        for (N = 0, $ = 0; N < S.length; N += 3)
          U = S[N] | S[N + 1] << 8 | S[N + 2] << 16, this.words[$] |= U << H & 67108863, this.words[$ + 1] = U >>> 26 - H & 67108863, H += 24, H >= 26 && (H -= 26, $++);
      return this.strip();
    };
    function k(P, S) {
      var E = P.charCodeAt(S);
      return E >= 65 && E <= 70 ? E - 55 : E >= 97 && E <= 102 ? E - 87 : E - 48 & 15;
    }
    function M(P, S, E) {
      var I = k(P, E);
      return E - 1 >= S && (I |= k(P, E - 1) << 4), I;
    }
    p.prototype._parseHex = function(S, E, I) {
      this.length = Math.ceil((S.length - E) / 6), this.words = new Array(this.length);
      for (var N = 0; N < this.length; N++)
        this.words[N] = 0;
      var $ = 0, U = 0, H;
      if (I === "be")
        for (N = S.length - 1; N >= E; N -= 2)
          H = M(S, E, N) << $, this.words[U] |= H & 67108863, $ >= 18 ? ($ -= 18, U += 1, this.words[U] |= H >>> 26) : $ += 8;
      else {
        var B = S.length - E;
        for (N = B % 2 === 0 ? E + 1 : E; N < S.length; N += 2)
          H = M(S, E, N) << $, this.words[U] |= H & 67108863, $ >= 18 ? ($ -= 18, U += 1, this.words[U] |= H >>> 26) : $ += 8;
      }
      this.strip();
    };
    function L(P, S, E, I) {
      for (var N = 0, $ = Math.min(P.length, E), U = S; U < $; U++) {
        var H = P.charCodeAt(U) - 48;
        N *= I, H >= 49 ? N += H - 49 + 10 : H >= 17 ? N += H - 17 + 10 : N += H;
      }
      return N;
    }
    p.prototype._parseBase = function(S, E, I) {
      this.words = [0], this.length = 1;
      for (var N = 0, $ = 1; $ <= 67108863; $ *= E)
        N++;
      N--, $ = $ / E | 0;
      for (var U = S.length - I, H = U % N, B = Math.min(U, U - H) + I, T = 0, D = I; D < B; D += N)
        T = L(S, D, D + N, E), this.imuln($), this.words[0] + T < 67108864 ? this.words[0] += T : this._iaddn(T);
      if (H !== 0) {
        var ee = 1;
        for (T = L(S, D, S.length, E), D = 0; D < H; D++)
          ee *= E;
        this.imuln(ee), this.words[0] + T < 67108864 ? this.words[0] += T : this._iaddn(T);
      }
      this.strip();
    }, p.prototype.copy = function(S) {
      S.words = new Array(this.length);
      for (var E = 0; E < this.length; E++)
        S.words[E] = this.words[E];
      S.length = this.length, S.negative = this.negative, S.red = this.red;
    }, p.prototype.clone = function() {
      var S = new p(null);
      return this.copy(S), S;
    }, p.prototype._expand = function(S) {
      for (; this.length < S; )
        this.words[this.length++] = 0;
      return this;
    }, p.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, p.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, p.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var F = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], V = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], X = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    p.prototype.toString = function(S, E) {
      S = S || 10, E = E | 0 || 1;
      var I;
      if (S === 16 || S === "hex") {
        I = "";
        for (var N = 0, $ = 0, U = 0; U < this.length; U++) {
          var H = this.words[U], B = ((H << N | $) & 16777215).toString(16);
          $ = H >>> 24 - N & 16777215, $ !== 0 || U !== this.length - 1 ? I = F[6 - B.length] + B + I : I = B + I, N += 2, N >= 26 && (N -= 26, U--);
        }
        for ($ !== 0 && (I = $.toString(16) + I); I.length % E !== 0; )
          I = "0" + I;
        return this.negative !== 0 && (I = "-" + I), I;
      }
      if (S === (S | 0) && S >= 2 && S <= 36) {
        var T = V[S], D = X[S];
        I = "";
        var ee = this.clone();
        for (ee.negative = 0; !ee.isZero(); ) {
          var pe = ee.modn(D).toString(S);
          ee = ee.idivn(D), ee.isZero() ? I = pe + I : I = F[T - pe.length] + pe + I;
        }
        for (this.isZero() && (I = "0" + I); I.length % E !== 0; )
          I = "0" + I;
        return this.negative !== 0 && (I = "-" + I), I;
      }
      l(!1, "Base should be between 2 and 36");
    }, p.prototype.toNumber = function() {
      var S = this.words[0];
      return this.length === 2 ? S += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? S += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && l(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -S : S;
    }, p.prototype.toJSON = function() {
      return this.toString(16);
    }, p.prototype.toBuffer = function(S, E) {
      return l(typeof _ < "u"), this.toArrayLike(_, S, E);
    }, p.prototype.toArray = function(S, E) {
      return this.toArrayLike(Array, S, E);
    }, p.prototype.toArrayLike = function(S, E, I) {
      var N = this.byteLength(), $ = I || Math.max(1, N);
      l(N <= $, "byte array longer than desired length"), l($ > 0, "Requested array length <= 0"), this.strip();
      var U = E === "le", H = new S($), B, T, D = this.clone();
      if (U) {
        for (T = 0; !D.isZero(); T++)
          B = D.andln(255), D.iushrn(8), H[T] = B;
        for (; T < $; T++)
          H[T] = 0;
      } else {
        for (T = 0; T < $ - N; T++)
          H[T] = 0;
        for (T = 0; !D.isZero(); T++)
          B = D.andln(255), D.iushrn(8), H[$ - T - 1] = B;
      }
      return H;
    }, Math.clz32 ? p.prototype._countBits = function(S) {
      return 32 - Math.clz32(S);
    } : p.prototype._countBits = function(S) {
      var E = S, I = 0;
      return E >= 4096 && (I += 13, E >>>= 13), E >= 64 && (I += 7, E >>>= 7), E >= 8 && (I += 4, E >>>= 4), E >= 2 && (I += 2, E >>>= 2), I + E;
    }, p.prototype._zeroBits = function(S) {
      if (S === 0)
        return 26;
      var E = S, I = 0;
      return E & 8191 || (I += 13, E >>>= 13), E & 127 || (I += 7, E >>>= 7), E & 15 || (I += 4, E >>>= 4), E & 3 || (I += 2, E >>>= 2), E & 1 || I++, I;
    }, p.prototype.bitLength = function() {
      var S = this.words[this.length - 1], E = this._countBits(S);
      return (this.length - 1) * 26 + E;
    };
    function oe(P) {
      for (var S = new Array(P.bitLength()), E = 0; E < S.length; E++) {
        var I = E / 26 | 0, N = E % 26;
        S[E] = (P.words[I] & 1 << N) >>> N;
      }
      return S;
    }
    p.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var S = 0, E = 0; E < this.length; E++) {
        var I = this._zeroBits(this.words[E]);
        if (S += I, I !== 26)
          break;
      }
      return S;
    }, p.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, p.prototype.toTwos = function(S) {
      return this.negative !== 0 ? this.abs().inotn(S).iaddn(1) : this.clone();
    }, p.prototype.fromTwos = function(S) {
      return this.testn(S - 1) ? this.notn(S).iaddn(1).ineg() : this.clone();
    }, p.prototype.isNeg = function() {
      return this.negative !== 0;
    }, p.prototype.neg = function() {
      return this.clone().ineg();
    }, p.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, p.prototype.iuor = function(S) {
      for (; this.length < S.length; )
        this.words[this.length++] = 0;
      for (var E = 0; E < S.length; E++)
        this.words[E] = this.words[E] | S.words[E];
      return this.strip();
    }, p.prototype.ior = function(S) {
      return l((this.negative | S.negative) === 0), this.iuor(S);
    }, p.prototype.or = function(S) {
      return this.length > S.length ? this.clone().ior(S) : S.clone().ior(this);
    }, p.prototype.uor = function(S) {
      return this.length > S.length ? this.clone().iuor(S) : S.clone().iuor(this);
    }, p.prototype.iuand = function(S) {
      var E;
      this.length > S.length ? E = S : E = this;
      for (var I = 0; I < E.length; I++)
        this.words[I] = this.words[I] & S.words[I];
      return this.length = E.length, this.strip();
    }, p.prototype.iand = function(S) {
      return l((this.negative | S.negative) === 0), this.iuand(S);
    }, p.prototype.and = function(S) {
      return this.length > S.length ? this.clone().iand(S) : S.clone().iand(this);
    }, p.prototype.uand = function(S) {
      return this.length > S.length ? this.clone().iuand(S) : S.clone().iuand(this);
    }, p.prototype.iuxor = function(S) {
      var E, I;
      this.length > S.length ? (E = this, I = S) : (E = S, I = this);
      for (var N = 0; N < I.length; N++)
        this.words[N] = E.words[N] ^ I.words[N];
      if (this !== E)
        for (; N < E.length; N++)
          this.words[N] = E.words[N];
      return this.length = E.length, this.strip();
    }, p.prototype.ixor = function(S) {
      return l((this.negative | S.negative) === 0), this.iuxor(S);
    }, p.prototype.xor = function(S) {
      return this.length > S.length ? this.clone().ixor(S) : S.clone().ixor(this);
    }, p.prototype.uxor = function(S) {
      return this.length > S.length ? this.clone().iuxor(S) : S.clone().iuxor(this);
    }, p.prototype.inotn = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = Math.ceil(S / 26) | 0, I = S % 26;
      this._expand(E), I > 0 && E--;
      for (var N = 0; N < E; N++)
        this.words[N] = ~this.words[N] & 67108863;
      return I > 0 && (this.words[N] = ~this.words[N] & 67108863 >> 26 - I), this.strip();
    }, p.prototype.notn = function(S) {
      return this.clone().inotn(S);
    }, p.prototype.setn = function(S, E) {
      l(typeof S == "number" && S >= 0);
      var I = S / 26 | 0, N = S % 26;
      return this._expand(I + 1), E ? this.words[I] = this.words[I] | 1 << N : this.words[I] = this.words[I] & ~(1 << N), this.strip();
    }, p.prototype.iadd = function(S) {
      var E;
      if (this.negative !== 0 && S.negative === 0)
        return this.negative = 0, E = this.isub(S), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && S.negative !== 0)
        return S.negative = 0, E = this.isub(S), S.negative = 1, E._normSign();
      var I, N;
      this.length > S.length ? (I = this, N = S) : (I = S, N = this);
      for (var $ = 0, U = 0; U < N.length; U++)
        E = (I.words[U] | 0) + (N.words[U] | 0) + $, this.words[U] = E & 67108863, $ = E >>> 26;
      for (; $ !== 0 && U < I.length; U++)
        E = (I.words[U] | 0) + $, this.words[U] = E & 67108863, $ = E >>> 26;
      if (this.length = I.length, $ !== 0)
        this.words[this.length] = $, this.length++;
      else if (I !== this)
        for (; U < I.length; U++)
          this.words[U] = I.words[U];
      return this;
    }, p.prototype.add = function(S) {
      var E;
      return S.negative !== 0 && this.negative === 0 ? (S.negative = 0, E = this.sub(S), S.negative ^= 1, E) : S.negative === 0 && this.negative !== 0 ? (this.negative = 0, E = S.sub(this), this.negative = 1, E) : this.length > S.length ? this.clone().iadd(S) : S.clone().iadd(this);
    }, p.prototype.isub = function(S) {
      if (S.negative !== 0) {
        S.negative = 0;
        var E = this.iadd(S);
        return S.negative = 1, E._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(S), this.negative = 1, this._normSign();
      var I = this.cmp(S);
      if (I === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var N, $;
      I > 0 ? (N = this, $ = S) : (N = S, $ = this);
      for (var U = 0, H = 0; H < $.length; H++)
        E = (N.words[H] | 0) - ($.words[H] | 0) + U, U = E >> 26, this.words[H] = E & 67108863;
      for (; U !== 0 && H < N.length; H++)
        E = (N.words[H] | 0) + U, U = E >> 26, this.words[H] = E & 67108863;
      if (U === 0 && H < N.length && N !== this)
        for (; H < N.length; H++)
          this.words[H] = N.words[H];
      return this.length = Math.max(this.length, H), N !== this && (this.negative = 1), this.strip();
    }, p.prototype.sub = function(S) {
      return this.clone().isub(S);
    };
    function Y(P, S, E) {
      E.negative = S.negative ^ P.negative;
      var I = P.length + S.length | 0;
      E.length = I, I = I - 1 | 0;
      var N = P.words[0] | 0, $ = S.words[0] | 0, U = N * $, H = U & 67108863, B = U / 67108864 | 0;
      E.words[0] = H;
      for (var T = 1; T < I; T++) {
        for (var D = B >>> 26, ee = B & 67108863, pe = Math.min(T, S.length - 1), Ie = Math.max(0, T - P.length + 1); Ie <= pe; Ie++) {
          var Pe = T - Ie | 0;
          N = P.words[Pe] | 0, $ = S.words[Ie] | 0, U = N * $ + ee, D += U / 67108864 | 0, ee = U & 67108863;
        }
        E.words[T] = ee | 0, B = D | 0;
      }
      return B !== 0 ? E.words[T] = B | 0 : E.length--, E.strip();
    }
    var ae = function(S, E, I) {
      var N = S.words, $ = E.words, U = I.words, H = 0, B, T, D, ee = N[0] | 0, pe = ee & 8191, Ie = ee >>> 13, Pe = N[1] | 0, he = Pe & 8191, ve = Pe >>> 13, Q = N[2] | 0, le = Q & 8191, _e = Q >>> 13, re = N[3] | 0, O = re & 8191, j = re >>> 13, ce = N[4] | 0, De = ce & 8191, Ne = ce >>> 13, Fe = N[5] | 0, Ze = Fe & 8191, qe = Fe >>> 13, gt = N[6] | 0, Xe = gt & 8191, Ge = gt >>> 13, J = N[7] | 0, ye = J & 8191, we = J >>> 13, We = N[8] | 0, Re = We & 8191, q = We >>> 13, ke = N[9] | 0, de = ke & 8191, ue = ke >>> 13, me = $[0] | 0, Oe = me & 8191, Ue = me >>> 13, ze = $[1] | 0, Ve = ze & 8191, Qe = ze >>> 13, Ke = $[2] | 0, x = Ke & 8191, se = Ke >>> 13, Ee = $[3] | 0, xe = Ee & 8191, $e = Ee >>> 13, Ye = $[4] | 0, et = Ye & 8191, dt = Ye >>> 13, St = $[5] | 0, tt = St & 8191, at = St >>> 13, wt = $[6] | 0, rt = wt & 8191, ut = wt >>> 13, kt = $[7] | 0, nt = kt & 8191, it = kt >>> 13, bt = $[8] | 0, ot = bt & 8191, ct = bt >>> 13, Ot = $[9] | 0, st = Ot & 8191, lt = Ot >>> 13;
      I.negative = S.negative ^ E.negative, I.length = 19, B = Math.imul(pe, Oe), T = Math.imul(pe, Ue), T = T + Math.imul(Ie, Oe) | 0, D = Math.imul(Ie, Ue);
      var Rt = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (Rt >>> 26) | 0, Rt &= 67108863, B = Math.imul(he, Oe), T = Math.imul(he, Ue), T = T + Math.imul(ve, Oe) | 0, D = Math.imul(ve, Ue), B = B + Math.imul(pe, Ve) | 0, T = T + Math.imul(pe, Qe) | 0, T = T + Math.imul(Ie, Ve) | 0, D = D + Math.imul(Ie, Qe) | 0;
      var Ct = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (Ct >>> 26) | 0, Ct &= 67108863, B = Math.imul(le, Oe), T = Math.imul(le, Ue), T = T + Math.imul(_e, Oe) | 0, D = Math.imul(_e, Ue), B = B + Math.imul(he, Ve) | 0, T = T + Math.imul(he, Qe) | 0, T = T + Math.imul(ve, Ve) | 0, D = D + Math.imul(ve, Qe) | 0, B = B + Math.imul(pe, x) | 0, T = T + Math.imul(pe, se) | 0, T = T + Math.imul(Ie, x) | 0, D = D + Math.imul(Ie, se) | 0;
      var Je = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, B = Math.imul(O, Oe), T = Math.imul(O, Ue), T = T + Math.imul(j, Oe) | 0, D = Math.imul(j, Ue), B = B + Math.imul(le, Ve) | 0, T = T + Math.imul(le, Qe) | 0, T = T + Math.imul(_e, Ve) | 0, D = D + Math.imul(_e, Qe) | 0, B = B + Math.imul(he, x) | 0, T = T + Math.imul(he, se) | 0, T = T + Math.imul(ve, x) | 0, D = D + Math.imul(ve, se) | 0, B = B + Math.imul(pe, xe) | 0, T = T + Math.imul(pe, $e) | 0, T = T + Math.imul(Ie, xe) | 0, D = D + Math.imul(Ie, $e) | 0;
      var He = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, B = Math.imul(De, Oe), T = Math.imul(De, Ue), T = T + Math.imul(Ne, Oe) | 0, D = Math.imul(Ne, Ue), B = B + Math.imul(O, Ve) | 0, T = T + Math.imul(O, Qe) | 0, T = T + Math.imul(j, Ve) | 0, D = D + Math.imul(j, Qe) | 0, B = B + Math.imul(le, x) | 0, T = T + Math.imul(le, se) | 0, T = T + Math.imul(_e, x) | 0, D = D + Math.imul(_e, se) | 0, B = B + Math.imul(he, xe) | 0, T = T + Math.imul(he, $e) | 0, T = T + Math.imul(ve, xe) | 0, D = D + Math.imul(ve, $e) | 0, B = B + Math.imul(pe, et) | 0, T = T + Math.imul(pe, dt) | 0, T = T + Math.imul(Ie, et) | 0, D = D + Math.imul(Ie, dt) | 0;
      var je = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, B = Math.imul(Ze, Oe), T = Math.imul(Ze, Ue), T = T + Math.imul(qe, Oe) | 0, D = Math.imul(qe, Ue), B = B + Math.imul(De, Ve) | 0, T = T + Math.imul(De, Qe) | 0, T = T + Math.imul(Ne, Ve) | 0, D = D + Math.imul(Ne, Qe) | 0, B = B + Math.imul(O, x) | 0, T = T + Math.imul(O, se) | 0, T = T + Math.imul(j, x) | 0, D = D + Math.imul(j, se) | 0, B = B + Math.imul(le, xe) | 0, T = T + Math.imul(le, $e) | 0, T = T + Math.imul(_e, xe) | 0, D = D + Math.imul(_e, $e) | 0, B = B + Math.imul(he, et) | 0, T = T + Math.imul(he, dt) | 0, T = T + Math.imul(ve, et) | 0, D = D + Math.imul(ve, dt) | 0, B = B + Math.imul(pe, tt) | 0, T = T + Math.imul(pe, at) | 0, T = T + Math.imul(Ie, tt) | 0, D = D + Math.imul(Ie, at) | 0;
      var pt = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (pt >>> 26) | 0, pt &= 67108863, B = Math.imul(Xe, Oe), T = Math.imul(Xe, Ue), T = T + Math.imul(Ge, Oe) | 0, D = Math.imul(Ge, Ue), B = B + Math.imul(Ze, Ve) | 0, T = T + Math.imul(Ze, Qe) | 0, T = T + Math.imul(qe, Ve) | 0, D = D + Math.imul(qe, Qe) | 0, B = B + Math.imul(De, x) | 0, T = T + Math.imul(De, se) | 0, T = T + Math.imul(Ne, x) | 0, D = D + Math.imul(Ne, se) | 0, B = B + Math.imul(O, xe) | 0, T = T + Math.imul(O, $e) | 0, T = T + Math.imul(j, xe) | 0, D = D + Math.imul(j, $e) | 0, B = B + Math.imul(le, et) | 0, T = T + Math.imul(le, dt) | 0, T = T + Math.imul(_e, et) | 0, D = D + Math.imul(_e, dt) | 0, B = B + Math.imul(he, tt) | 0, T = T + Math.imul(he, at) | 0, T = T + Math.imul(ve, tt) | 0, D = D + Math.imul(ve, at) | 0, B = B + Math.imul(pe, rt) | 0, T = T + Math.imul(pe, ut) | 0, T = T + Math.imul(Ie, rt) | 0, D = D + Math.imul(Ie, ut) | 0;
      var mt = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (mt >>> 26) | 0, mt &= 67108863, B = Math.imul(ye, Oe), T = Math.imul(ye, Ue), T = T + Math.imul(we, Oe) | 0, D = Math.imul(we, Ue), B = B + Math.imul(Xe, Ve) | 0, T = T + Math.imul(Xe, Qe) | 0, T = T + Math.imul(Ge, Ve) | 0, D = D + Math.imul(Ge, Qe) | 0, B = B + Math.imul(Ze, x) | 0, T = T + Math.imul(Ze, se) | 0, T = T + Math.imul(qe, x) | 0, D = D + Math.imul(qe, se) | 0, B = B + Math.imul(De, xe) | 0, T = T + Math.imul(De, $e) | 0, T = T + Math.imul(Ne, xe) | 0, D = D + Math.imul(Ne, $e) | 0, B = B + Math.imul(O, et) | 0, T = T + Math.imul(O, dt) | 0, T = T + Math.imul(j, et) | 0, D = D + Math.imul(j, dt) | 0, B = B + Math.imul(le, tt) | 0, T = T + Math.imul(le, at) | 0, T = T + Math.imul(_e, tt) | 0, D = D + Math.imul(_e, at) | 0, B = B + Math.imul(he, rt) | 0, T = T + Math.imul(he, ut) | 0, T = T + Math.imul(ve, rt) | 0, D = D + Math.imul(ve, ut) | 0, B = B + Math.imul(pe, nt) | 0, T = T + Math.imul(pe, it) | 0, T = T + Math.imul(Ie, nt) | 0, D = D + Math.imul(Ie, it) | 0;
      var yt = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (yt >>> 26) | 0, yt &= 67108863, B = Math.imul(Re, Oe), T = Math.imul(Re, Ue), T = T + Math.imul(q, Oe) | 0, D = Math.imul(q, Ue), B = B + Math.imul(ye, Ve) | 0, T = T + Math.imul(ye, Qe) | 0, T = T + Math.imul(we, Ve) | 0, D = D + Math.imul(we, Qe) | 0, B = B + Math.imul(Xe, x) | 0, T = T + Math.imul(Xe, se) | 0, T = T + Math.imul(Ge, x) | 0, D = D + Math.imul(Ge, se) | 0, B = B + Math.imul(Ze, xe) | 0, T = T + Math.imul(Ze, $e) | 0, T = T + Math.imul(qe, xe) | 0, D = D + Math.imul(qe, $e) | 0, B = B + Math.imul(De, et) | 0, T = T + Math.imul(De, dt) | 0, T = T + Math.imul(Ne, et) | 0, D = D + Math.imul(Ne, dt) | 0, B = B + Math.imul(O, tt) | 0, T = T + Math.imul(O, at) | 0, T = T + Math.imul(j, tt) | 0, D = D + Math.imul(j, at) | 0, B = B + Math.imul(le, rt) | 0, T = T + Math.imul(le, ut) | 0, T = T + Math.imul(_e, rt) | 0, D = D + Math.imul(_e, ut) | 0, B = B + Math.imul(he, nt) | 0, T = T + Math.imul(he, it) | 0, T = T + Math.imul(ve, nt) | 0, D = D + Math.imul(ve, it) | 0, B = B + Math.imul(pe, ot) | 0, T = T + Math.imul(pe, ct) | 0, T = T + Math.imul(Ie, ot) | 0, D = D + Math.imul(Ie, ct) | 0;
      var ht = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (ht >>> 26) | 0, ht &= 67108863, B = Math.imul(de, Oe), T = Math.imul(de, Ue), T = T + Math.imul(ue, Oe) | 0, D = Math.imul(ue, Ue), B = B + Math.imul(Re, Ve) | 0, T = T + Math.imul(Re, Qe) | 0, T = T + Math.imul(q, Ve) | 0, D = D + Math.imul(q, Qe) | 0, B = B + Math.imul(ye, x) | 0, T = T + Math.imul(ye, se) | 0, T = T + Math.imul(we, x) | 0, D = D + Math.imul(we, se) | 0, B = B + Math.imul(Xe, xe) | 0, T = T + Math.imul(Xe, $e) | 0, T = T + Math.imul(Ge, xe) | 0, D = D + Math.imul(Ge, $e) | 0, B = B + Math.imul(Ze, et) | 0, T = T + Math.imul(Ze, dt) | 0, T = T + Math.imul(qe, et) | 0, D = D + Math.imul(qe, dt) | 0, B = B + Math.imul(De, tt) | 0, T = T + Math.imul(De, at) | 0, T = T + Math.imul(Ne, tt) | 0, D = D + Math.imul(Ne, at) | 0, B = B + Math.imul(O, rt) | 0, T = T + Math.imul(O, ut) | 0, T = T + Math.imul(j, rt) | 0, D = D + Math.imul(j, ut) | 0, B = B + Math.imul(le, nt) | 0, T = T + Math.imul(le, it) | 0, T = T + Math.imul(_e, nt) | 0, D = D + Math.imul(_e, it) | 0, B = B + Math.imul(he, ot) | 0, T = T + Math.imul(he, ct) | 0, T = T + Math.imul(ve, ot) | 0, D = D + Math.imul(ve, ct) | 0, B = B + Math.imul(pe, st) | 0, T = T + Math.imul(pe, lt) | 0, T = T + Math.imul(Ie, st) | 0, D = D + Math.imul(Ie, lt) | 0;
      var _t = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (_t >>> 26) | 0, _t &= 67108863, B = Math.imul(de, Ve), T = Math.imul(de, Qe), T = T + Math.imul(ue, Ve) | 0, D = Math.imul(ue, Qe), B = B + Math.imul(Re, x) | 0, T = T + Math.imul(Re, se) | 0, T = T + Math.imul(q, x) | 0, D = D + Math.imul(q, se) | 0, B = B + Math.imul(ye, xe) | 0, T = T + Math.imul(ye, $e) | 0, T = T + Math.imul(we, xe) | 0, D = D + Math.imul(we, $e) | 0, B = B + Math.imul(Xe, et) | 0, T = T + Math.imul(Xe, dt) | 0, T = T + Math.imul(Ge, et) | 0, D = D + Math.imul(Ge, dt) | 0, B = B + Math.imul(Ze, tt) | 0, T = T + Math.imul(Ze, at) | 0, T = T + Math.imul(qe, tt) | 0, D = D + Math.imul(qe, at) | 0, B = B + Math.imul(De, rt) | 0, T = T + Math.imul(De, ut) | 0, T = T + Math.imul(Ne, rt) | 0, D = D + Math.imul(Ne, ut) | 0, B = B + Math.imul(O, nt) | 0, T = T + Math.imul(O, it) | 0, T = T + Math.imul(j, nt) | 0, D = D + Math.imul(j, it) | 0, B = B + Math.imul(le, ot) | 0, T = T + Math.imul(le, ct) | 0, T = T + Math.imul(_e, ot) | 0, D = D + Math.imul(_e, ct) | 0, B = B + Math.imul(he, st) | 0, T = T + Math.imul(he, lt) | 0, T = T + Math.imul(ve, st) | 0, D = D + Math.imul(ve, lt) | 0;
      var Et = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, B = Math.imul(de, x), T = Math.imul(de, se), T = T + Math.imul(ue, x) | 0, D = Math.imul(ue, se), B = B + Math.imul(Re, xe) | 0, T = T + Math.imul(Re, $e) | 0, T = T + Math.imul(q, xe) | 0, D = D + Math.imul(q, $e) | 0, B = B + Math.imul(ye, et) | 0, T = T + Math.imul(ye, dt) | 0, T = T + Math.imul(we, et) | 0, D = D + Math.imul(we, dt) | 0, B = B + Math.imul(Xe, tt) | 0, T = T + Math.imul(Xe, at) | 0, T = T + Math.imul(Ge, tt) | 0, D = D + Math.imul(Ge, at) | 0, B = B + Math.imul(Ze, rt) | 0, T = T + Math.imul(Ze, ut) | 0, T = T + Math.imul(qe, rt) | 0, D = D + Math.imul(qe, ut) | 0, B = B + Math.imul(De, nt) | 0, T = T + Math.imul(De, it) | 0, T = T + Math.imul(Ne, nt) | 0, D = D + Math.imul(Ne, it) | 0, B = B + Math.imul(O, ot) | 0, T = T + Math.imul(O, ct) | 0, T = T + Math.imul(j, ot) | 0, D = D + Math.imul(j, ct) | 0, B = B + Math.imul(le, st) | 0, T = T + Math.imul(le, lt) | 0, T = T + Math.imul(_e, st) | 0, D = D + Math.imul(_e, lt) | 0;
      var Nt = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, B = Math.imul(de, xe), T = Math.imul(de, $e), T = T + Math.imul(ue, xe) | 0, D = Math.imul(ue, $e), B = B + Math.imul(Re, et) | 0, T = T + Math.imul(Re, dt) | 0, T = T + Math.imul(q, et) | 0, D = D + Math.imul(q, dt) | 0, B = B + Math.imul(ye, tt) | 0, T = T + Math.imul(ye, at) | 0, T = T + Math.imul(we, tt) | 0, D = D + Math.imul(we, at) | 0, B = B + Math.imul(Xe, rt) | 0, T = T + Math.imul(Xe, ut) | 0, T = T + Math.imul(Ge, rt) | 0, D = D + Math.imul(Ge, ut) | 0, B = B + Math.imul(Ze, nt) | 0, T = T + Math.imul(Ze, it) | 0, T = T + Math.imul(qe, nt) | 0, D = D + Math.imul(qe, it) | 0, B = B + Math.imul(De, ot) | 0, T = T + Math.imul(De, ct) | 0, T = T + Math.imul(Ne, ot) | 0, D = D + Math.imul(Ne, ct) | 0, B = B + Math.imul(O, st) | 0, T = T + Math.imul(O, lt) | 0, T = T + Math.imul(j, st) | 0, D = D + Math.imul(j, lt) | 0;
      var Dt = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (Dt >>> 26) | 0, Dt &= 67108863, B = Math.imul(de, et), T = Math.imul(de, dt), T = T + Math.imul(ue, et) | 0, D = Math.imul(ue, dt), B = B + Math.imul(Re, tt) | 0, T = T + Math.imul(Re, at) | 0, T = T + Math.imul(q, tt) | 0, D = D + Math.imul(q, at) | 0, B = B + Math.imul(ye, rt) | 0, T = T + Math.imul(ye, ut) | 0, T = T + Math.imul(we, rt) | 0, D = D + Math.imul(we, ut) | 0, B = B + Math.imul(Xe, nt) | 0, T = T + Math.imul(Xe, it) | 0, T = T + Math.imul(Ge, nt) | 0, D = D + Math.imul(Ge, it) | 0, B = B + Math.imul(Ze, ot) | 0, T = T + Math.imul(Ze, ct) | 0, T = T + Math.imul(qe, ot) | 0, D = D + Math.imul(qe, ct) | 0, B = B + Math.imul(De, st) | 0, T = T + Math.imul(De, lt) | 0, T = T + Math.imul(Ne, st) | 0, D = D + Math.imul(Ne, lt) | 0;
      var $t = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + ($t >>> 26) | 0, $t &= 67108863, B = Math.imul(de, tt), T = Math.imul(de, at), T = T + Math.imul(ue, tt) | 0, D = Math.imul(ue, at), B = B + Math.imul(Re, rt) | 0, T = T + Math.imul(Re, ut) | 0, T = T + Math.imul(q, rt) | 0, D = D + Math.imul(q, ut) | 0, B = B + Math.imul(ye, nt) | 0, T = T + Math.imul(ye, it) | 0, T = T + Math.imul(we, nt) | 0, D = D + Math.imul(we, it) | 0, B = B + Math.imul(Xe, ot) | 0, T = T + Math.imul(Xe, ct) | 0, T = T + Math.imul(Ge, ot) | 0, D = D + Math.imul(Ge, ct) | 0, B = B + Math.imul(Ze, st) | 0, T = T + Math.imul(Ze, lt) | 0, T = T + Math.imul(qe, st) | 0, D = D + Math.imul(qe, lt) | 0;
      var At = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, B = Math.imul(de, rt), T = Math.imul(de, ut), T = T + Math.imul(ue, rt) | 0, D = Math.imul(ue, ut), B = B + Math.imul(Re, nt) | 0, T = T + Math.imul(Re, it) | 0, T = T + Math.imul(q, nt) | 0, D = D + Math.imul(q, it) | 0, B = B + Math.imul(ye, ot) | 0, T = T + Math.imul(ye, ct) | 0, T = T + Math.imul(we, ot) | 0, D = D + Math.imul(we, ct) | 0, B = B + Math.imul(Xe, st) | 0, T = T + Math.imul(Xe, lt) | 0, T = T + Math.imul(Ge, st) | 0, D = D + Math.imul(Ge, lt) | 0;
      var Lt = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (Lt >>> 26) | 0, Lt &= 67108863, B = Math.imul(de, nt), T = Math.imul(de, it), T = T + Math.imul(ue, nt) | 0, D = Math.imul(ue, it), B = B + Math.imul(Re, ot) | 0, T = T + Math.imul(Re, ct) | 0, T = T + Math.imul(q, ot) | 0, D = D + Math.imul(q, ct) | 0, B = B + Math.imul(ye, st) | 0, T = T + Math.imul(ye, lt) | 0, T = T + Math.imul(we, st) | 0, D = D + Math.imul(we, lt) | 0;
      var Bt = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, B = Math.imul(de, ot), T = Math.imul(de, ct), T = T + Math.imul(ue, ot) | 0, D = Math.imul(ue, ct), B = B + Math.imul(Re, st) | 0, T = T + Math.imul(Re, lt) | 0, T = T + Math.imul(q, st) | 0, D = D + Math.imul(q, lt) | 0;
      var Ut = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (Ut >>> 26) | 0, Ut &= 67108863, B = Math.imul(de, st), T = Math.imul(de, lt), T = T + Math.imul(ue, st) | 0, D = Math.imul(ue, lt);
      var xt = (H + B | 0) + ((T & 8191) << 13) | 0;
      return H = (D + (T >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, U[0] = Rt, U[1] = Ct, U[2] = Je, U[3] = He, U[4] = je, U[5] = pt, U[6] = mt, U[7] = yt, U[8] = ht, U[9] = _t, U[10] = Et, U[11] = Nt, U[12] = Dt, U[13] = $t, U[14] = At, U[15] = Lt, U[16] = Bt, U[17] = Ut, U[18] = xt, H !== 0 && (U[19] = H, I.length++), I;
    };
    Math.imul || (ae = Y);
    function ne(P, S, E) {
      E.negative = S.negative ^ P.negative, E.length = P.length + S.length;
      for (var I = 0, N = 0, $ = 0; $ < E.length - 1; $++) {
        var U = N;
        N = 0;
        for (var H = I & 67108863, B = Math.min($, S.length - 1), T = Math.max(0, $ - P.length + 1); T <= B; T++) {
          var D = $ - T, ee = P.words[D] | 0, pe = S.words[T] | 0, Ie = ee * pe, Pe = Ie & 67108863;
          U = U + (Ie / 67108864 | 0) | 0, Pe = Pe + H | 0, H = Pe & 67108863, U = U + (Pe >>> 26) | 0, N += U >>> 26, U &= 67108863;
        }
        E.words[$] = H, I = U, U = N;
      }
      return I !== 0 ? E.words[$] = I : E.length--, E.strip();
    }
    function fe(P, S, E) {
      var I = new ie();
      return I.mulp(P, S, E);
    }
    p.prototype.mulTo = function(S, E) {
      var I, N = this.length + S.length;
      return this.length === 10 && S.length === 10 ? I = ae(this, S, E) : N < 63 ? I = Y(this, S, E) : N < 1024 ? I = ne(this, S, E) : I = fe(this, S, E), I;
    };
    function ie(P, S) {
      this.x = P, this.y = S;
    }
    ie.prototype.makeRBT = function(S) {
      for (var E = new Array(S), I = p.prototype._countBits(S) - 1, N = 0; N < S; N++)
        E[N] = this.revBin(N, I, S);
      return E;
    }, ie.prototype.revBin = function(S, E, I) {
      if (S === 0 || S === I - 1)
        return S;
      for (var N = 0, $ = 0; $ < E; $++)
        N |= (S & 1) << E - $ - 1, S >>= 1;
      return N;
    }, ie.prototype.permute = function(S, E, I, N, $, U) {
      for (var H = 0; H < U; H++)
        N[H] = E[S[H]], $[H] = I[S[H]];
    }, ie.prototype.transform = function(S, E, I, N, $, U) {
      this.permute(U, S, E, I, N, $);
      for (var H = 1; H < $; H <<= 1)
        for (var B = H << 1, T = Math.cos(2 * Math.PI / B), D = Math.sin(2 * Math.PI / B), ee = 0; ee < $; ee += B)
          for (var pe = T, Ie = D, Pe = 0; Pe < H; Pe++) {
            var he = I[ee + Pe], ve = N[ee + Pe], Q = I[ee + Pe + H], le = N[ee + Pe + H], _e = pe * Q - Ie * le;
            le = pe * le + Ie * Q, Q = _e, I[ee + Pe] = he + Q, N[ee + Pe] = ve + le, I[ee + Pe + H] = he - Q, N[ee + Pe + H] = ve - le, Pe !== B && (_e = T * pe - D * Ie, Ie = T * Ie + D * pe, pe = _e);
          }
    }, ie.prototype.guessLen13b = function(S, E) {
      var I = Math.max(E, S) | 1, N = I & 1, $ = 0;
      for (I = I / 2 | 0; I; I = I >>> 1)
        $++;
      return 1 << $ + 1 + N;
    }, ie.prototype.conjugate = function(S, E, I) {
      if (!(I <= 1))
        for (var N = 0; N < I / 2; N++) {
          var $ = S[N];
          S[N] = S[I - N - 1], S[I - N - 1] = $, $ = E[N], E[N] = -E[I - N - 1], E[I - N - 1] = -$;
        }
    }, ie.prototype.normalize13b = function(S, E) {
      for (var I = 0, N = 0; N < E / 2; N++) {
        var $ = Math.round(S[2 * N + 1] / E) * 8192 + Math.round(S[2 * N] / E) + I;
        S[N] = $ & 67108863, $ < 67108864 ? I = 0 : I = $ / 67108864 | 0;
      }
      return S;
    }, ie.prototype.convert13b = function(S, E, I, N) {
      for (var $ = 0, U = 0; U < E; U++)
        $ = $ + (S[U] | 0), I[2 * U] = $ & 8191, $ = $ >>> 13, I[2 * U + 1] = $ & 8191, $ = $ >>> 13;
      for (U = 2 * E; U < N; ++U)
        I[U] = 0;
      l($ === 0), l(($ & -8192) === 0);
    }, ie.prototype.stub = function(S) {
      for (var E = new Array(S), I = 0; I < S; I++)
        E[I] = 0;
      return E;
    }, ie.prototype.mulp = function(S, E, I) {
      var N = 2 * this.guessLen13b(S.length, E.length), $ = this.makeRBT(N), U = this.stub(N), H = new Array(N), B = new Array(N), T = new Array(N), D = new Array(N), ee = new Array(N), pe = new Array(N), Ie = I.words;
      Ie.length = N, this.convert13b(S.words, S.length, H, N), this.convert13b(E.words, E.length, D, N), this.transform(H, U, B, T, N, $), this.transform(D, U, ee, pe, N, $);
      for (var Pe = 0; Pe < N; Pe++) {
        var he = B[Pe] * ee[Pe] - T[Pe] * pe[Pe];
        T[Pe] = B[Pe] * pe[Pe] + T[Pe] * ee[Pe], B[Pe] = he;
      }
      return this.conjugate(B, T, N), this.transform(B, T, Ie, U, N, $), this.conjugate(Ie, U, N), this.normalize13b(Ie, N), I.negative = S.negative ^ E.negative, I.length = S.length + E.length, I.strip();
    }, p.prototype.mul = function(S) {
      var E = new p(null);
      return E.words = new Array(this.length + S.length), this.mulTo(S, E);
    }, p.prototype.mulf = function(S) {
      var E = new p(null);
      return E.words = new Array(this.length + S.length), fe(this, S, E);
    }, p.prototype.imul = function(S) {
      return this.clone().mulTo(S, this);
    }, p.prototype.imuln = function(S) {
      l(typeof S == "number"), l(S < 67108864);
      for (var E = 0, I = 0; I < this.length; I++) {
        var N = (this.words[I] | 0) * S, $ = (N & 67108863) + (E & 67108863);
        E >>= 26, E += N / 67108864 | 0, E += $ >>> 26, this.words[I] = $ & 67108863;
      }
      return E !== 0 && (this.words[I] = E, this.length++), this;
    }, p.prototype.muln = function(S) {
      return this.clone().imuln(S);
    }, p.prototype.sqr = function() {
      return this.mul(this);
    }, p.prototype.isqr = function() {
      return this.imul(this.clone());
    }, p.prototype.pow = function(S) {
      var E = oe(S);
      if (E.length === 0)
        return new p(1);
      for (var I = this, N = 0; N < E.length && E[N] === 0; N++, I = I.sqr())
        ;
      if (++N < E.length)
        for (var $ = I.sqr(); N < E.length; N++, $ = $.sqr())
          E[N] !== 0 && (I = I.mul($));
      return I;
    }, p.prototype.iushln = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = S % 26, I = (S - E) / 26, N = 67108863 >>> 26 - E << 26 - E, $;
      if (E !== 0) {
        var U = 0;
        for ($ = 0; $ < this.length; $++) {
          var H = this.words[$] & N, B = (this.words[$] | 0) - H << E;
          this.words[$] = B | U, U = H >>> 26 - E;
        }
        U && (this.words[$] = U, this.length++);
      }
      if (I !== 0) {
        for ($ = this.length - 1; $ >= 0; $--)
          this.words[$ + I] = this.words[$];
        for ($ = 0; $ < I; $++)
          this.words[$] = 0;
        this.length += I;
      }
      return this.strip();
    }, p.prototype.ishln = function(S) {
      return l(this.negative === 0), this.iushln(S);
    }, p.prototype.iushrn = function(S, E, I) {
      l(typeof S == "number" && S >= 0);
      var N;
      E ? N = (E - E % 26) / 26 : N = 0;
      var $ = S % 26, U = Math.min((S - $) / 26, this.length), H = 67108863 ^ 67108863 >>> $ << $, B = I;
      if (N -= U, N = Math.max(0, N), B) {
        for (var T = 0; T < U; T++)
          B.words[T] = this.words[T];
        B.length = U;
      }
      if (U !== 0)
        if (this.length > U)
          for (this.length -= U, T = 0; T < this.length; T++)
            this.words[T] = this.words[T + U];
        else
          this.words[0] = 0, this.length = 1;
      var D = 0;
      for (T = this.length - 1; T >= 0 && (D !== 0 || T >= N); T--) {
        var ee = this.words[T] | 0;
        this.words[T] = D << 26 - $ | ee >>> $, D = ee & H;
      }
      return B && D !== 0 && (B.words[B.length++] = D), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, p.prototype.ishrn = function(S, E, I) {
      return l(this.negative === 0), this.iushrn(S, E, I);
    }, p.prototype.shln = function(S) {
      return this.clone().ishln(S);
    }, p.prototype.ushln = function(S) {
      return this.clone().iushln(S);
    }, p.prototype.shrn = function(S) {
      return this.clone().ishrn(S);
    }, p.prototype.ushrn = function(S) {
      return this.clone().iushrn(S);
    }, p.prototype.testn = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = S % 26, I = (S - E) / 26, N = 1 << E;
      if (this.length <= I)
        return !1;
      var $ = this.words[I];
      return !!($ & N);
    }, p.prototype.imaskn = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = S % 26, I = (S - E) / 26;
      if (l(this.negative === 0, "imaskn works only with positive numbers"), this.length <= I)
        return this;
      if (E !== 0 && I++, this.length = Math.min(I, this.length), E !== 0) {
        var N = 67108863 ^ 67108863 >>> E << E;
        this.words[this.length - 1] &= N;
      }
      return this.strip();
    }, p.prototype.maskn = function(S) {
      return this.clone().imaskn(S);
    }, p.prototype.iaddn = function(S) {
      return l(typeof S == "number"), l(S < 67108864), S < 0 ? this.isubn(-S) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < S ? (this.words[0] = S - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(S), this.negative = 1, this) : this._iaddn(S);
    }, p.prototype._iaddn = function(S) {
      this.words[0] += S;
      for (var E = 0; E < this.length && this.words[E] >= 67108864; E++)
        this.words[E] -= 67108864, E === this.length - 1 ? this.words[E + 1] = 1 : this.words[E + 1]++;
      return this.length = Math.max(this.length, E + 1), this;
    }, p.prototype.isubn = function(S) {
      if (l(typeof S == "number"), l(S < 67108864), S < 0)
        return this.iaddn(-S);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(S), this.negative = 1, this;
      if (this.words[0] -= S, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var E = 0; E < this.length && this.words[E] < 0; E++)
          this.words[E] += 67108864, this.words[E + 1] -= 1;
      return this.strip();
    }, p.prototype.addn = function(S) {
      return this.clone().iaddn(S);
    }, p.prototype.subn = function(S) {
      return this.clone().isubn(S);
    }, p.prototype.iabs = function() {
      return this.negative = 0, this;
    }, p.prototype.abs = function() {
      return this.clone().iabs();
    }, p.prototype._ishlnsubmul = function(S, E, I) {
      var N = S.length + I, $;
      this._expand(N);
      var U, H = 0;
      for ($ = 0; $ < S.length; $++) {
        U = (this.words[$ + I] | 0) + H;
        var B = (S.words[$] | 0) * E;
        U -= B & 67108863, H = (U >> 26) - (B / 67108864 | 0), this.words[$ + I] = U & 67108863;
      }
      for (; $ < this.length - I; $++)
        U = (this.words[$ + I] | 0) + H, H = U >> 26, this.words[$ + I] = U & 67108863;
      if (H === 0)
        return this.strip();
      for (l(H === -1), H = 0, $ = 0; $ < this.length; $++)
        U = -(this.words[$] | 0) + H, H = U >> 26, this.words[$] = U & 67108863;
      return this.negative = 1, this.strip();
    }, p.prototype._wordDiv = function(S, E) {
      var I = this.length - S.length, N = this.clone(), $ = S, U = $.words[$.length - 1] | 0, H = this._countBits(U);
      I = 26 - H, I !== 0 && ($ = $.ushln(I), N.iushln(I), U = $.words[$.length - 1] | 0);
      var B = N.length - $.length, T;
      if (E !== "mod") {
        T = new p(null), T.length = B + 1, T.words = new Array(T.length);
        for (var D = 0; D < T.length; D++)
          T.words[D] = 0;
      }
      var ee = N.clone()._ishlnsubmul($, 1, B);
      ee.negative === 0 && (N = ee, T && (T.words[B] = 1));
      for (var pe = B - 1; pe >= 0; pe--) {
        var Ie = (N.words[$.length + pe] | 0) * 67108864 + (N.words[$.length + pe - 1] | 0);
        for (Ie = Math.min(Ie / U | 0, 67108863), N._ishlnsubmul($, Ie, pe); N.negative !== 0; )
          Ie--, N.negative = 0, N._ishlnsubmul($, 1, pe), N.isZero() || (N.negative ^= 1);
        T && (T.words[pe] = Ie);
      }
      return T && T.strip(), N.strip(), E !== "div" && I !== 0 && N.iushrn(I), {
        div: T || null,
        mod: N
      };
    }, p.prototype.divmod = function(S, E, I) {
      if (l(!S.isZero()), this.isZero())
        return {
          div: new p(0),
          mod: new p(0)
        };
      var N, $, U;
      return this.negative !== 0 && S.negative === 0 ? (U = this.neg().divmod(S, E), E !== "mod" && (N = U.div.neg()), E !== "div" && ($ = U.mod.neg(), I && $.negative !== 0 && $.iadd(S)), {
        div: N,
        mod: $
      }) : this.negative === 0 && S.negative !== 0 ? (U = this.divmod(S.neg(), E), E !== "mod" && (N = U.div.neg()), {
        div: N,
        mod: U.mod
      }) : this.negative & S.negative ? (U = this.neg().divmod(S.neg(), E), E !== "div" && ($ = U.mod.neg(), I && $.negative !== 0 && $.isub(S)), {
        div: U.div,
        mod: $
      }) : S.length > this.length || this.cmp(S) < 0 ? {
        div: new p(0),
        mod: this
      } : S.length === 1 ? E === "div" ? {
        div: this.divn(S.words[0]),
        mod: null
      } : E === "mod" ? {
        div: null,
        mod: new p(this.modn(S.words[0]))
      } : {
        div: this.divn(S.words[0]),
        mod: new p(this.modn(S.words[0]))
      } : this._wordDiv(S, E);
    }, p.prototype.div = function(S) {
      return this.divmod(S, "div", !1).div;
    }, p.prototype.mod = function(S) {
      return this.divmod(S, "mod", !1).mod;
    }, p.prototype.umod = function(S) {
      return this.divmod(S, "mod", !0).mod;
    }, p.prototype.divRound = function(S) {
      var E = this.divmod(S);
      if (E.mod.isZero())
        return E.div;
      var I = E.div.negative !== 0 ? E.mod.isub(S) : E.mod, N = S.ushrn(1), $ = S.andln(1), U = I.cmp(N);
      return U < 0 || $ === 1 && U === 0 ? E.div : E.div.negative !== 0 ? E.div.isubn(1) : E.div.iaddn(1);
    }, p.prototype.modn = function(S) {
      l(S <= 67108863);
      for (var E = (1 << 26) % S, I = 0, N = this.length - 1; N >= 0; N--)
        I = (E * I + (this.words[N] | 0)) % S;
      return I;
    }, p.prototype.idivn = function(S) {
      l(S <= 67108863);
      for (var E = 0, I = this.length - 1; I >= 0; I--) {
        var N = (this.words[I] | 0) + E * 67108864;
        this.words[I] = N / S | 0, E = N % S;
      }
      return this.strip();
    }, p.prototype.divn = function(S) {
      return this.clone().idivn(S);
    }, p.prototype.egcd = function(S) {
      l(S.negative === 0), l(!S.isZero());
      var E = this, I = S.clone();
      E.negative !== 0 ? E = E.umod(S) : E = E.clone();
      for (var N = new p(1), $ = new p(0), U = new p(0), H = new p(1), B = 0; E.isEven() && I.isEven(); )
        E.iushrn(1), I.iushrn(1), ++B;
      for (var T = I.clone(), D = E.clone(); !E.isZero(); ) {
        for (var ee = 0, pe = 1; !(E.words[0] & pe) && ee < 26; ++ee, pe <<= 1)
          ;
        if (ee > 0)
          for (E.iushrn(ee); ee-- > 0; )
            (N.isOdd() || $.isOdd()) && (N.iadd(T), $.isub(D)), N.iushrn(1), $.iushrn(1);
        for (var Ie = 0, Pe = 1; !(I.words[0] & Pe) && Ie < 26; ++Ie, Pe <<= 1)
          ;
        if (Ie > 0)
          for (I.iushrn(Ie); Ie-- > 0; )
            (U.isOdd() || H.isOdd()) && (U.iadd(T), H.isub(D)), U.iushrn(1), H.iushrn(1);
        E.cmp(I) >= 0 ? (E.isub(I), N.isub(U), $.isub(H)) : (I.isub(E), U.isub(N), H.isub($));
      }
      return {
        a: U,
        b: H,
        gcd: I.iushln(B)
      };
    }, p.prototype._invmp = function(S) {
      l(S.negative === 0), l(!S.isZero());
      var E = this, I = S.clone();
      E.negative !== 0 ? E = E.umod(S) : E = E.clone();
      for (var N = new p(1), $ = new p(0), U = I.clone(); E.cmpn(1) > 0 && I.cmpn(1) > 0; ) {
        for (var H = 0, B = 1; !(E.words[0] & B) && H < 26; ++H, B <<= 1)
          ;
        if (H > 0)
          for (E.iushrn(H); H-- > 0; )
            N.isOdd() && N.iadd(U), N.iushrn(1);
        for (var T = 0, D = 1; !(I.words[0] & D) && T < 26; ++T, D <<= 1)
          ;
        if (T > 0)
          for (I.iushrn(T); T-- > 0; )
            $.isOdd() && $.iadd(U), $.iushrn(1);
        E.cmp(I) >= 0 ? (E.isub(I), N.isub($)) : (I.isub(E), $.isub(N));
      }
      var ee;
      return E.cmpn(1) === 0 ? ee = N : ee = $, ee.cmpn(0) < 0 && ee.iadd(S), ee;
    }, p.prototype.gcd = function(S) {
      if (this.isZero())
        return S.abs();
      if (S.isZero())
        return this.abs();
      var E = this.clone(), I = S.clone();
      E.negative = 0, I.negative = 0;
      for (var N = 0; E.isEven() && I.isEven(); N++)
        E.iushrn(1), I.iushrn(1);
      do {
        for (; E.isEven(); )
          E.iushrn(1);
        for (; I.isEven(); )
          I.iushrn(1);
        var $ = E.cmp(I);
        if ($ < 0) {
          var U = E;
          E = I, I = U;
        } else if ($ === 0 || I.cmpn(1) === 0)
          break;
        E.isub(I);
      } while (!0);
      return I.iushln(N);
    }, p.prototype.invm = function(S) {
      return this.egcd(S).a.umod(S);
    }, p.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, p.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, p.prototype.andln = function(S) {
      return this.words[0] & S;
    }, p.prototype.bincn = function(S) {
      l(typeof S == "number");
      var E = S % 26, I = (S - E) / 26, N = 1 << E;
      if (this.length <= I)
        return this._expand(I + 1), this.words[I] |= N, this;
      for (var $ = N, U = I; $ !== 0 && U < this.length; U++) {
        var H = this.words[U] | 0;
        H += $, $ = H >>> 26, H &= 67108863, this.words[U] = H;
      }
      return $ !== 0 && (this.words[U] = $, this.length++), this;
    }, p.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, p.prototype.cmpn = function(S) {
      var E = S < 0;
      if (this.negative !== 0 && !E)
        return -1;
      if (this.negative === 0 && E)
        return 1;
      this.strip();
      var I;
      if (this.length > 1)
        I = 1;
      else {
        E && (S = -S), l(S <= 67108863, "Number is too big");
        var N = this.words[0] | 0;
        I = N === S ? 0 : N < S ? -1 : 1;
      }
      return this.negative !== 0 ? -I | 0 : I;
    }, p.prototype.cmp = function(S) {
      if (this.negative !== 0 && S.negative === 0)
        return -1;
      if (this.negative === 0 && S.negative !== 0)
        return 1;
      var E = this.ucmp(S);
      return this.negative !== 0 ? -E | 0 : E;
    }, p.prototype.ucmp = function(S) {
      if (this.length > S.length)
        return 1;
      if (this.length < S.length)
        return -1;
      for (var E = 0, I = this.length - 1; I >= 0; I--) {
        var N = this.words[I] | 0, $ = S.words[I] | 0;
        if (N !== $) {
          N < $ ? E = -1 : N > $ && (E = 1);
          break;
        }
      }
      return E;
    }, p.prototype.gtn = function(S) {
      return this.cmpn(S) === 1;
    }, p.prototype.gt = function(S) {
      return this.cmp(S) === 1;
    }, p.prototype.gten = function(S) {
      return this.cmpn(S) >= 0;
    }, p.prototype.gte = function(S) {
      return this.cmp(S) >= 0;
    }, p.prototype.ltn = function(S) {
      return this.cmpn(S) === -1;
    }, p.prototype.lt = function(S) {
      return this.cmp(S) === -1;
    }, p.prototype.lten = function(S) {
      return this.cmpn(S) <= 0;
    }, p.prototype.lte = function(S) {
      return this.cmp(S) <= 0;
    }, p.prototype.eqn = function(S) {
      return this.cmpn(S) === 0;
    }, p.prototype.eq = function(S) {
      return this.cmp(S) === 0;
    }, p.red = function(S) {
      return new Z(S);
    }, p.prototype.toRed = function(S) {
      return l(!this.red, "Already a number in reduction context"), l(this.negative === 0, "red works only with positives"), S.convertTo(this)._forceRed(S);
    }, p.prototype.fromRed = function() {
      return l(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, p.prototype._forceRed = function(S) {
      return this.red = S, this;
    }, p.prototype.forceRed = function(S) {
      return l(!this.red, "Already a number in reduction context"), this._forceRed(S);
    }, p.prototype.redAdd = function(S) {
      return l(this.red, "redAdd works only with red numbers"), this.red.add(this, S);
    }, p.prototype.redIAdd = function(S) {
      return l(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, S);
    }, p.prototype.redSub = function(S) {
      return l(this.red, "redSub works only with red numbers"), this.red.sub(this, S);
    }, p.prototype.redISub = function(S) {
      return l(this.red, "redISub works only with red numbers"), this.red.isub(this, S);
    }, p.prototype.redShl = function(S) {
      return l(this.red, "redShl works only with red numbers"), this.red.shl(this, S);
    }, p.prototype.redMul = function(S) {
      return l(this.red, "redMul works only with red numbers"), this.red._verify2(this, S), this.red.mul(this, S);
    }, p.prototype.redIMul = function(S) {
      return l(this.red, "redMul works only with red numbers"), this.red._verify2(this, S), this.red.imul(this, S);
    }, p.prototype.redSqr = function() {
      return l(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, p.prototype.redISqr = function() {
      return l(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, p.prototype.redSqrt = function() {
      return l(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, p.prototype.redInvm = function() {
      return l(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, p.prototype.redNeg = function() {
      return l(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, p.prototype.redPow = function(S) {
      return l(this.red && !S.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, S);
    };
    var ge = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function be(P, S) {
      this.name = P, this.p = new p(S, 16), this.n = this.p.bitLength(), this.k = new p(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    be.prototype._tmp = function() {
      var S = new p(null);
      return S.words = new Array(Math.ceil(this.n / 13)), S;
    }, be.prototype.ireduce = function(S) {
      var E = S, I;
      do
        this.split(E, this.tmp), E = this.imulK(E), E = E.iadd(this.tmp), I = E.bitLength();
      while (I > this.n);
      var N = I < this.n ? -1 : E.ucmp(this.p);
      return N === 0 ? (E.words[0] = 0, E.length = 1) : N > 0 ? E.isub(this.p) : E.strip !== void 0 ? E.strip() : E._strip(), E;
    }, be.prototype.split = function(S, E) {
      S.iushrn(this.n, 0, E);
    }, be.prototype.imulK = function(S) {
      return S.imul(this.k);
    };
    function Ce() {
      be.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    v(Ce, be), Ce.prototype.split = function(S, E) {
      for (var I = 4194303, N = Math.min(S.length, 9), $ = 0; $ < N; $++)
        E.words[$] = S.words[$];
      if (E.length = N, S.length <= 9) {
        S.words[0] = 0, S.length = 1;
        return;
      }
      var U = S.words[9];
      for (E.words[E.length++] = U & I, $ = 10; $ < S.length; $++) {
        var H = S.words[$] | 0;
        S.words[$ - 10] = (H & I) << 4 | U >>> 22, U = H;
      }
      U >>>= 22, S.words[$ - 10] = U, U === 0 && S.length > 10 ? S.length -= 10 : S.length -= 9;
    }, Ce.prototype.imulK = function(S) {
      S.words[S.length] = 0, S.words[S.length + 1] = 0, S.length += 2;
      for (var E = 0, I = 0; I < S.length; I++) {
        var N = S.words[I] | 0;
        E += N * 977, S.words[I] = E & 67108863, E = N * 64 + (E / 67108864 | 0);
      }
      return S.words[S.length - 1] === 0 && (S.length--, S.words[S.length - 1] === 0 && S.length--), S;
    };
    function Me() {
      be.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    v(Me, be);
    function Be() {
      be.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    v(Be, be);
    function Ae() {
      be.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    v(Ae, be), Ae.prototype.imulK = function(S) {
      for (var E = 0, I = 0; I < S.length; I++) {
        var N = (S.words[I] | 0) * 19 + E, $ = N & 67108863;
        N >>>= 26, S.words[I] = $, E = N;
      }
      return E !== 0 && (S.words[S.length++] = E), S;
    }, p._prime = function(S) {
      if (ge[S])
        return ge[S];
      var E;
      if (S === "k256")
        E = new Ce();
      else if (S === "p224")
        E = new Me();
      else if (S === "p192")
        E = new Be();
      else if (S === "p25519")
        E = new Ae();
      else
        throw new Error("Unknown prime " + S);
      return ge[S] = E, E;
    };
    function Z(P) {
      if (typeof P == "string") {
        var S = p._prime(P);
        this.m = S.p, this.prime = S;
      } else
        l(P.gtn(1), "modulus must be greater than 1"), this.m = P, this.prime = null;
    }
    Z.prototype._verify1 = function(S) {
      l(S.negative === 0, "red works only with positives"), l(S.red, "red works only with red numbers");
    }, Z.prototype._verify2 = function(S, E) {
      l((S.negative | E.negative) === 0, "red works only with positives"), l(
        S.red && S.red === E.red,
        "red works only with red numbers"
      );
    }, Z.prototype.imod = function(S) {
      return this.prime ? this.prime.ireduce(S)._forceRed(this) : S.umod(this.m)._forceRed(this);
    }, Z.prototype.neg = function(S) {
      return S.isZero() ? S.clone() : this.m.sub(S)._forceRed(this);
    }, Z.prototype.add = function(S, E) {
      this._verify2(S, E);
      var I = S.add(E);
      return I.cmp(this.m) >= 0 && I.isub(this.m), I._forceRed(this);
    }, Z.prototype.iadd = function(S, E) {
      this._verify2(S, E);
      var I = S.iadd(E);
      return I.cmp(this.m) >= 0 && I.isub(this.m), I;
    }, Z.prototype.sub = function(S, E) {
      this._verify2(S, E);
      var I = S.sub(E);
      return I.cmpn(0) < 0 && I.iadd(this.m), I._forceRed(this);
    }, Z.prototype.isub = function(S, E) {
      this._verify2(S, E);
      var I = S.isub(E);
      return I.cmpn(0) < 0 && I.iadd(this.m), I;
    }, Z.prototype.shl = function(S, E) {
      return this._verify1(S), this.imod(S.ushln(E));
    }, Z.prototype.imul = function(S, E) {
      return this._verify2(S, E), this.imod(S.imul(E));
    }, Z.prototype.mul = function(S, E) {
      return this._verify2(S, E), this.imod(S.mul(E));
    }, Z.prototype.isqr = function(S) {
      return this.imul(S, S.clone());
    }, Z.prototype.sqr = function(S) {
      return this.mul(S, S);
    }, Z.prototype.sqrt = function(S) {
      if (S.isZero())
        return S.clone();
      var E = this.m.andln(3);
      if (l(E % 2 === 1), E === 3) {
        var I = this.m.add(new p(1)).iushrn(2);
        return this.pow(S, I);
      }
      for (var N = this.m.subn(1), $ = 0; !N.isZero() && N.andln(1) === 0; )
        $++, N.iushrn(1);
      l(!N.isZero());
      var U = new p(1).toRed(this), H = U.redNeg(), B = this.m.subn(1).iushrn(1), T = this.m.bitLength();
      for (T = new p(2 * T * T).toRed(this); this.pow(T, B).cmp(H) !== 0; )
        T.redIAdd(H);
      for (var D = this.pow(T, N), ee = this.pow(S, N.addn(1).iushrn(1)), pe = this.pow(S, N), Ie = $; pe.cmp(U) !== 0; ) {
        for (var Pe = pe, he = 0; Pe.cmp(U) !== 0; he++)
          Pe = Pe.redSqr();
        l(he < Ie);
        var ve = this.pow(D, new p(1).iushln(Ie - he - 1));
        ee = ee.redMul(ve), D = ve.redSqr(), pe = pe.redMul(D), Ie = he;
      }
      return ee;
    }, Z.prototype.invm = function(S) {
      var E = S._invmp(this.m);
      return E.negative !== 0 ? (E.negative = 0, this.imod(E).redNeg()) : this.imod(E);
    }, Z.prototype.pow = function(S, E) {
      if (E.isZero())
        return new p(1).toRed(this);
      if (E.cmpn(1) === 0)
        return S.clone();
      var I = 4, N = new Array(1 << I);
      N[0] = new p(1).toRed(this), N[1] = S;
      for (var $ = 2; $ < N.length; $++)
        N[$] = this.mul(N[$ - 1], S);
      var U = N[0], H = 0, B = 0, T = E.bitLength() % 26;
      for (T === 0 && (T = 26), $ = E.length - 1; $ >= 0; $--) {
        for (var D = E.words[$], ee = T - 1; ee >= 0; ee--) {
          var pe = D >> ee & 1;
          if (U !== N[0] && (U = this.sqr(U)), pe === 0 && H === 0) {
            B = 0;
            continue;
          }
          H <<= 1, H |= pe, B++, !(B !== I && ($ !== 0 || ee !== 0)) && (U = this.mul(U, N[H]), B = 0, H = 0);
        }
        T = 26;
      }
      return U;
    }, Z.prototype.convertTo = function(S) {
      var E = S.umod(this.m);
      return E === S ? E.clone() : E;
    }, Z.prototype.convertFrom = function(S) {
      var E = S.clone();
      return E.red = null, E;
    }, p.mont = function(S) {
      return new z(S);
    };
    function z(P) {
      Z.call(this, P), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new p(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    v(z, Z), z.prototype.convertTo = function(S) {
      return this.imod(S.ushln(this.shift));
    }, z.prototype.convertFrom = function(S) {
      var E = this.imod(S.mul(this.rinv));
      return E.red = null, E;
    }, z.prototype.imul = function(S, E) {
      if (S.isZero() || E.isZero())
        return S.words[0] = 0, S.length = 1, S;
      var I = S.imul(E), N = I.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), $ = I.isub(N).iushrn(this.shift), U = $;
      return $.cmp(this.m) >= 0 ? U = $.isub(this.m) : $.cmpn(0) < 0 && (U = $.iadd(this.m)), U._forceRed(this);
    }, z.prototype.mul = function(S, E) {
      if (S.isZero() || E.isZero())
        return new p(0)._forceRed(this);
      var I = S.mul(E), N = I.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), $ = I.isub(N).iushrn(this.shift), U = $;
      return $.cmp(this.m) >= 0 ? U = $.isub(this.m) : $.cmpn(0) < 0 && (U = $.iadd(this.m)), U._forceRed(this);
    }, z.prototype.invm = function(S) {
      var E = this.imod(S._invmp(this.m).mul(this.r2));
      return E._forceRed(this);
    };
  })(a, commonjsGlobal$1);
})(bn$2);
var bnExports$2 = bn$2.exports, api = {}, encoders = {}, buffer$1 = require$$0$2, Buffer$f = buffer$1.Buffer, safer = {}, key;
for (key in buffer$1)
  buffer$1.hasOwnProperty(key) && (key === "SlowBuffer" || key === "Buffer" || (safer[key] = buffer$1[key]));
var Safer = safer.Buffer = {};
for (key in Buffer$f)
  Buffer$f.hasOwnProperty(key) && (key === "allocUnsafe" || key === "allocUnsafeSlow" || (Safer[key] = Buffer$f[key]));
safer.Buffer.prototype = Buffer$f.prototype;
(!Safer.from || Safer.from === Uint8Array.from) && (Safer.from = function(a, u, c) {
  if (typeof a == "number")
    throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof a);
  if (a && typeof a.length > "u")
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof a);
  return Buffer$f(a, u, c);
});
Safer.alloc || (Safer.alloc = function(a, u, c) {
  if (typeof a != "number")
    throw new TypeError('The "size" argument must be of type number. Received type ' + typeof a);
  if (a < 0 || a >= 2 * (1 << 30))
    throw new RangeError('The value "' + a + '" is invalid for option "size"');
  var l = Buffer$f(a);
  return !u || u.length === 0 ? l.fill(0) : typeof c == "string" ? l.fill(u, c) : l.fill(u), l;
});
if (!safer.kStringMaxLength)
  try {
    safer.kStringMaxLength = process$1.binding("buffer").kStringMaxLength;
  } catch {
  }
safer.constants || (safer.constants = {
  MAX_LENGTH: safer.kMaxLength
}, safer.kStringMaxLength && (safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength));
var safer_1 = safer, reporter = {};
const inherits$5 = inherits_browserExports;
function Reporter$2(a) {
  this._reporterState = {
    obj: null,
    path: [],
    options: a || {},
    errors: []
  };
}
reporter.Reporter = Reporter$2;
Reporter$2.prototype.isError = function a(u) {
  return u instanceof ReporterError;
};
Reporter$2.prototype.save = function a() {
  const u = this._reporterState;
  return { obj: u.obj, pathLen: u.path.length };
};
Reporter$2.prototype.restore = function a(u) {
  const c = this._reporterState;
  c.obj = u.obj, c.path = c.path.slice(0, u.pathLen);
};
Reporter$2.prototype.enterKey = function a(u) {
  return this._reporterState.path.push(u);
};
Reporter$2.prototype.exitKey = function a(u) {
  const c = this._reporterState;
  c.path = c.path.slice(0, u - 1);
};
Reporter$2.prototype.leaveKey = function a(u, c, l) {
  const v = this._reporterState;
  this.exitKey(u), v.obj !== null && (v.obj[c] = l);
};
Reporter$2.prototype.path = function a() {
  return this._reporterState.path.join("/");
};
Reporter$2.prototype.enterObject = function a() {
  const u = this._reporterState, c = u.obj;
  return u.obj = {}, c;
};
Reporter$2.prototype.leaveObject = function a(u) {
  const c = this._reporterState, l = c.obj;
  return c.obj = u, l;
};
Reporter$2.prototype.error = function a(u) {
  let c;
  const l = this._reporterState, v = u instanceof ReporterError;
  if (v ? c = u : c = new ReporterError(l.path.map(function(p) {
    return "[" + JSON.stringify(p) + "]";
  }).join(""), u.message || u, u.stack), !l.options.partial)
    throw c;
  return v || l.errors.push(c), c;
};
Reporter$2.prototype.wrapResult = function a(u) {
  const c = this._reporterState;
  return c.options.partial ? {
    result: this.isError(u) ? null : u,
    errors: c.errors
  } : u;
};
function ReporterError(a, u) {
  this.path = a, this.rethrow(u);
}
inherits$5(ReporterError, Error);
ReporterError.prototype.rethrow = function a(u) {
  if (this.message = u + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, ReporterError), !this.stack)
    try {
      throw new Error(this.message);
    } catch (c) {
      this.stack = c.stack;
    }
  return this;
};
var buffer = {};
const inherits$4 = inherits_browserExports, Reporter$1 = reporter.Reporter, Buffer$e = safer_1.Buffer;
function DecoderBuffer$2(a, u) {
  if (Reporter$1.call(this, u), !Buffer$e.isBuffer(a)) {
    this.error("Input not Buffer");
    return;
  }
  this.base = a, this.offset = 0, this.length = a.length;
}
inherits$4(DecoderBuffer$2, Reporter$1);
buffer.DecoderBuffer = DecoderBuffer$2;
DecoderBuffer$2.isDecoderBuffer = function a(u) {
  return u instanceof DecoderBuffer$2 ? !0 : typeof u == "object" && Buffer$e.isBuffer(u.base) && u.constructor.name === "DecoderBuffer" && typeof u.offset == "number" && typeof u.length == "number" && typeof u.save == "function" && typeof u.restore == "function" && typeof u.isEmpty == "function" && typeof u.readUInt8 == "function" && typeof u.skip == "function" && typeof u.raw == "function";
};
DecoderBuffer$2.prototype.save = function a() {
  return { offset: this.offset, reporter: Reporter$1.prototype.save.call(this) };
};
DecoderBuffer$2.prototype.restore = function a(u) {
  const c = new DecoderBuffer$2(this.base);
  return c.offset = u.offset, c.length = this.offset, this.offset = u.offset, Reporter$1.prototype.restore.call(this, u.reporter), c;
};
DecoderBuffer$2.prototype.isEmpty = function a() {
  return this.offset === this.length;
};
DecoderBuffer$2.prototype.readUInt8 = function a(u) {
  return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, !0) : this.error(u || "DecoderBuffer overrun");
};
DecoderBuffer$2.prototype.skip = function a(u, c) {
  if (!(this.offset + u <= this.length))
    return this.error(c || "DecoderBuffer overrun");
  const l = new DecoderBuffer$2(this.base);
  return l._reporterState = this._reporterState, l.offset = this.offset, l.length = this.offset + u, this.offset += u, l;
};
DecoderBuffer$2.prototype.raw = function a(u) {
  return this.base.slice(u ? u.offset : this.offset, this.length);
};
function EncoderBuffer$1(a, u) {
  if (Array.isArray(a))
    this.length = 0, this.value = a.map(function(c) {
      return EncoderBuffer$1.isEncoderBuffer(c) || (c = new EncoderBuffer$1(c, u)), this.length += c.length, c;
    }, this);
  else if (typeof a == "number") {
    if (!(0 <= a && a <= 255))
      return u.error("non-byte EncoderBuffer value");
    this.value = a, this.length = 1;
  } else if (typeof a == "string")
    this.value = a, this.length = Buffer$e.byteLength(a);
  else if (Buffer$e.isBuffer(a))
    this.value = a, this.length = a.length;
  else
    return u.error("Unsupported type: " + typeof a);
}
buffer.EncoderBuffer = EncoderBuffer$1;
EncoderBuffer$1.isEncoderBuffer = function a(u) {
  return u instanceof EncoderBuffer$1 ? !0 : typeof u == "object" && u.constructor.name === "EncoderBuffer" && typeof u.length == "number" && typeof u.join == "function";
};
EncoderBuffer$1.prototype.join = function a(u, c) {
  return u || (u = Buffer$e.alloc(this.length)), c || (c = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(l) {
    l.join(u, c), c += l.length;
  }) : (typeof this.value == "number" ? u[c] = this.value : typeof this.value == "string" ? u.write(this.value, c) : Buffer$e.isBuffer(this.value) && this.value.copy(u, c), c += this.length)), u;
};
const Reporter = reporter.Reporter, EncoderBuffer = buffer.EncoderBuffer, DecoderBuffer$1 = buffer.DecoderBuffer, assert = minimalisticAssert, tags = [
  "seq",
  "seqof",
  "set",
  "setof",
  "objid",
  "bool",
  "gentime",
  "utctime",
  "null_",
  "enum",
  "int",
  "objDesc",
  "bitstr",
  "bmpstr",
  "charstr",
  "genstr",
  "graphstr",
  "ia5str",
  "iso646str",
  "numstr",
  "octstr",
  "printstr",
  "t61str",
  "unistr",
  "utf8str",
  "videostr"
], methods = [
  "key",
  "obj",
  "use",
  "optional",
  "explicit",
  "implicit",
  "def",
  "choice",
  "any",
  "contains"
].concat(tags), overrided = [
  "_peekTag",
  "_decodeTag",
  "_use",
  "_decodeStr",
  "_decodeObjid",
  "_decodeTime",
  "_decodeNull",
  "_decodeInt",
  "_decodeBool",
  "_decodeList",
  "_encodeComposite",
  "_encodeStr",
  "_encodeObjid",
  "_encodeTime",
  "_encodeNull",
  "_encodeInt",
  "_encodeBool"
];
function Node$2(a, u, c) {
  const l = {};
  this._baseState = l, l.name = c, l.enc = a, l.parent = u || null, l.children = null, l.tag = null, l.args = null, l.reverseArgs = null, l.choice = null, l.optional = !1, l.any = !1, l.obj = !1, l.use = null, l.useDecoder = null, l.key = null, l.default = null, l.explicit = null, l.implicit = null, l.contains = null, l.parent || (l.children = [], this._wrap());
}
var node = Node$2;
const stateProps = [
  "enc",
  "parent",
  "children",
  "tag",
  "args",
  "reverseArgs",
  "choice",
  "optional",
  "any",
  "obj",
  "use",
  "alteredUse",
  "key",
  "default",
  "explicit",
  "implicit",
  "contains"
];
Node$2.prototype.clone = function a() {
  const u = this._baseState, c = {};
  stateProps.forEach(function(v) {
    c[v] = u[v];
  });
  const l = new this.constructor(c.parent);
  return l._baseState = c, l;
};
Node$2.prototype._wrap = function a() {
  const u = this._baseState;
  methods.forEach(function(c) {
    this[c] = function() {
      const v = new this.constructor(this);
      return u.children.push(v), v[c].apply(v, arguments);
    };
  }, this);
};
Node$2.prototype._init = function a(u) {
  const c = this._baseState;
  assert(c.parent === null), u.call(this), c.children = c.children.filter(function(l) {
    return l._baseState.parent === this;
  }, this), assert.equal(c.children.length, 1, "Root node can have only one child");
};
Node$2.prototype._useArgs = function a(u) {
  const c = this._baseState, l = u.filter(function(v) {
    return v instanceof this.constructor;
  }, this);
  u = u.filter(function(v) {
    return !(v instanceof this.constructor);
  }, this), l.length !== 0 && (assert(c.children === null), c.children = l, l.forEach(function(v) {
    v._baseState.parent = this;
  }, this)), u.length !== 0 && (assert(c.args === null), c.args = u, c.reverseArgs = u.map(function(v) {
    if (typeof v != "object" || v.constructor !== Object)
      return v;
    const p = {};
    return Object.keys(v).forEach(function(_) {
      _ == (_ | 0) && (_ |= 0);
      const k = v[_];
      p[k] = _;
    }), p;
  }));
};
overrided.forEach(function(a) {
  Node$2.prototype[a] = function() {
    const c = this._baseState;
    throw new Error(a + " not implemented for encoding: " + c.enc);
  };
});
tags.forEach(function(a) {
  Node$2.prototype[a] = function() {
    const c = this._baseState, l = Array.prototype.slice.call(arguments);
    return assert(c.tag === null), c.tag = a, this._useArgs(l), this;
  };
});
Node$2.prototype.use = function a(u) {
  assert(u);
  const c = this._baseState;
  return assert(c.use === null), c.use = u, this;
};
Node$2.prototype.optional = function a() {
  const u = this._baseState;
  return u.optional = !0, this;
};
Node$2.prototype.def = function a(u) {
  const c = this._baseState;
  return assert(c.default === null), c.default = u, c.optional = !0, this;
};
Node$2.prototype.explicit = function a(u) {
  const c = this._baseState;
  return assert(c.explicit === null && c.implicit === null), c.explicit = u, this;
};
Node$2.prototype.implicit = function a(u) {
  const c = this._baseState;
  return assert(c.explicit === null && c.implicit === null), c.implicit = u, this;
};
Node$2.prototype.obj = function a() {
  const u = this._baseState, c = Array.prototype.slice.call(arguments);
  return u.obj = !0, c.length !== 0 && this._useArgs(c), this;
};
Node$2.prototype.key = function a(u) {
  const c = this._baseState;
  return assert(c.key === null), c.key = u, this;
};
Node$2.prototype.any = function a() {
  const u = this._baseState;
  return u.any = !0, this;
};
Node$2.prototype.choice = function a(u) {
  const c = this._baseState;
  return assert(c.choice === null), c.choice = u, this._useArgs(Object.keys(u).map(function(l) {
    return u[l];
  })), this;
};
Node$2.prototype.contains = function a(u) {
  const c = this._baseState;
  return assert(c.use === null), c.contains = u, this;
};
Node$2.prototype._decode = function a(u, c) {
  const l = this._baseState;
  if (l.parent === null)
    return u.wrapResult(l.children[0]._decode(u, c));
  let v = l.default, p = !0, _ = null;
  if (l.key !== null && (_ = u.enterKey(l.key)), l.optional) {
    let M = null;
    if (l.explicit !== null ? M = l.explicit : l.implicit !== null ? M = l.implicit : l.tag !== null && (M = l.tag), M === null && !l.any) {
      const L = u.save();
      try {
        l.choice === null ? this._decodeGeneric(l.tag, u, c) : this._decodeChoice(u, c), p = !0;
      } catch {
        p = !1;
      }
      u.restore(L);
    } else if (p = this._peekTag(u, M, l.any), u.isError(p))
      return p;
  }
  let k;
  if (l.obj && p && (k = u.enterObject()), p) {
    if (l.explicit !== null) {
      const L = this._decodeTag(u, l.explicit);
      if (u.isError(L))
        return L;
      u = L;
    }
    const M = u.offset;
    if (l.use === null && l.choice === null) {
      let L;
      l.any && (L = u.save());
      const F = this._decodeTag(
        u,
        l.implicit !== null ? l.implicit : l.tag,
        l.any
      );
      if (u.isError(F))
        return F;
      l.any ? v = u.raw(L) : u = F;
    }
    if (c && c.track && l.tag !== null && c.track(u.path(), M, u.length, "tagged"), c && c.track && l.tag !== null && c.track(u.path(), u.offset, u.length, "content"), l.any || (l.choice === null ? v = this._decodeGeneric(l.tag, u, c) : v = this._decodeChoice(u, c)), u.isError(v))
      return v;
    if (!l.any && l.choice === null && l.children !== null && l.children.forEach(function(F) {
      F._decode(u, c);
    }), l.contains && (l.tag === "octstr" || l.tag === "bitstr")) {
      const L = new DecoderBuffer$1(v);
      v = this._getUse(l.contains, u._reporterState.obj)._decode(L, c);
    }
  }
  return l.obj && p && (v = u.leaveObject(k)), l.key !== null && (v !== null || p === !0) ? u.leaveKey(_, l.key, v) : _ !== null && u.exitKey(_), v;
};
Node$2.prototype._decodeGeneric = function a(u, c, l) {
  const v = this._baseState;
  return u === "seq" || u === "set" ? null : u === "seqof" || u === "setof" ? this._decodeList(c, u, v.args[0], l) : /str$/.test(u) ? this._decodeStr(c, u, l) : u === "objid" && v.args ? this._decodeObjid(c, v.args[0], v.args[1], l) : u === "objid" ? this._decodeObjid(c, null, null, l) : u === "gentime" || u === "utctime" ? this._decodeTime(c, u, l) : u === "null_" ? this._decodeNull(c, l) : u === "bool" ? this._decodeBool(c, l) : u === "objDesc" ? this._decodeStr(c, u, l) : u === "int" || u === "enum" ? this._decodeInt(c, v.args && v.args[0], l) : v.use !== null ? this._getUse(v.use, c._reporterState.obj)._decode(c, l) : c.error("unknown tag: " + u);
};
Node$2.prototype._getUse = function a(u, c) {
  const l = this._baseState;
  return l.useDecoder = this._use(u, c), assert(l.useDecoder._baseState.parent === null), l.useDecoder = l.useDecoder._baseState.children[0], l.implicit !== l.useDecoder._baseState.implicit && (l.useDecoder = l.useDecoder.clone(), l.useDecoder._baseState.implicit = l.implicit), l.useDecoder;
};
Node$2.prototype._decodeChoice = function a(u, c) {
  const l = this._baseState;
  let v = null, p = !1;
  return Object.keys(l.choice).some(function(_) {
    const k = u.save(), M = l.choice[_];
    try {
      const L = M._decode(u, c);
      if (u.isError(L))
        return !1;
      v = { type: _, value: L }, p = !0;
    } catch {
      return u.restore(k), !1;
    }
    return !0;
  }, this), p ? v : u.error("Choice not matched");
};
Node$2.prototype._createEncoderBuffer = function a(u) {
  return new EncoderBuffer(u, this.reporter);
};
Node$2.prototype._encode = function a(u, c, l) {
  const v = this._baseState;
  if (v.default !== null && v.default === u)
    return;
  const p = this._encodeValue(u, c, l);
  if (p !== void 0 && !this._skipDefault(p, c, l))
    return p;
};
Node$2.prototype._encodeValue = function a(u, c, l) {
  const v = this._baseState;
  if (v.parent === null)
    return v.children[0]._encode(u, c || new Reporter());
  let p = null;
  if (this.reporter = c, v.optional && u === void 0)
    if (v.default !== null)
      u = v.default;
    else
      return;
  let _ = null, k = !1;
  if (v.any)
    p = this._createEncoderBuffer(u);
  else if (v.choice)
    p = this._encodeChoice(u, c);
  else if (v.contains)
    _ = this._getUse(v.contains, l)._encode(u, c), k = !0;
  else if (v.children)
    _ = v.children.map(function(M) {
      if (M._baseState.tag === "null_")
        return M._encode(null, c, u);
      if (M._baseState.key === null)
        return c.error("Child should have a key");
      const L = c.enterKey(M._baseState.key);
      if (typeof u != "object")
        return c.error("Child expected, but input is not object");
      const F = M._encode(u[M._baseState.key], c, u);
      return c.leaveKey(L), F;
    }, this).filter(function(M) {
      return M;
    }), _ = this._createEncoderBuffer(_);
  else if (v.tag === "seqof" || v.tag === "setof") {
    if (!(v.args && v.args.length === 1))
      return c.error("Too many args for : " + v.tag);
    if (!Array.isArray(u))
      return c.error("seqof/setof, but data is not Array");
    const M = this.clone();
    M._baseState.implicit = null, _ = this._createEncoderBuffer(u.map(function(L) {
      const F = this._baseState;
      return this._getUse(F.args[0], u)._encode(L, c);
    }, M));
  } else
    v.use !== null ? p = this._getUse(v.use, l)._encode(u, c) : (_ = this._encodePrimitive(v.tag, u), k = !0);
  if (!v.any && v.choice === null) {
    const M = v.implicit !== null ? v.implicit : v.tag, L = v.implicit === null ? "universal" : "context";
    M === null ? v.use === null && c.error("Tag could be omitted only for .use()") : v.use === null && (p = this._encodeComposite(M, k, L, _));
  }
  return v.explicit !== null && (p = this._encodeComposite(v.explicit, !1, "context", p)), p;
};
Node$2.prototype._encodeChoice = function a(u, c) {
  const l = this._baseState, v = l.choice[u.type];
  return v || assert(
    !1,
    u.type + " not found in " + JSON.stringify(Object.keys(l.choice))
  ), v._encode(u.value, c);
};
Node$2.prototype._encodePrimitive = function a(u, c) {
  const l = this._baseState;
  if (/str$/.test(u))
    return this._encodeStr(c, u);
  if (u === "objid" && l.args)
    return this._encodeObjid(c, l.reverseArgs[0], l.args[1]);
  if (u === "objid")
    return this._encodeObjid(c, null, null);
  if (u === "gentime" || u === "utctime")
    return this._encodeTime(c, u);
  if (u === "null_")
    return this._encodeNull();
  if (u === "int" || u === "enum")
    return this._encodeInt(c, l.args && l.reverseArgs[0]);
  if (u === "bool")
    return this._encodeBool(c);
  if (u === "objDesc")
    return this._encodeStr(c, u);
  throw new Error("Unsupported tag: " + u);
};
Node$2.prototype._isNumstr = function a(u) {
  return /^[0-9 ]*$/.test(u);
};
Node$2.prototype._isPrintstr = function a(u) {
  return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(u);
};
var der$2 = {};
(function(a) {
  function u(c) {
    const l = {};
    return Object.keys(c).forEach(function(v) {
      (v | 0) == v && (v = v | 0);
      const p = c[v];
      l[p] = v;
    }), l;
  }
  a.tagClass = {
    0: "universal",
    1: "application",
    2: "context",
    3: "private"
  }, a.tagClassByName = u(a.tagClass), a.tag = {
    0: "end",
    1: "bool",
    2: "int",
    3: "bitstr",
    4: "octstr",
    5: "null_",
    6: "objid",
    7: "objDesc",
    8: "external",
    9: "real",
    10: "enum",
    11: "embed",
    12: "utf8str",
    13: "relativeOid",
    16: "seq",
    17: "set",
    18: "numstr",
    19: "printstr",
    20: "t61str",
    21: "videostr",
    22: "ia5str",
    23: "utctime",
    24: "gentime",
    25: "graphstr",
    26: "iso646str",
    27: "genstr",
    28: "unistr",
    29: "charstr",
    30: "bmpstr"
  }, a.tagByName = u(a.tag);
})(der$2);
const inherits$3 = inherits_browserExports, Buffer$d = safer_1.Buffer, Node$1 = node, der$1 = der$2;
function DEREncoder$1(a) {
  this.enc = "der", this.name = a.name, this.entity = a, this.tree = new DERNode$1(), this.tree._init(a.body);
}
var der_1$1 = DEREncoder$1;
DEREncoder$1.prototype.encode = function a(u, c) {
  return this.tree._encode(u, c).join();
};
function DERNode$1(a) {
  Node$1.call(this, "der", a);
}
inherits$3(DERNode$1, Node$1);
DERNode$1.prototype._encodeComposite = function a(u, c, l, v) {
  const p = encodeTag(u, c, l, this.reporter);
  if (v.length < 128) {
    const M = Buffer$d.alloc(2);
    return M[0] = p, M[1] = v.length, this._createEncoderBuffer([M, v]);
  }
  let _ = 1;
  for (let M = v.length; M >= 256; M >>= 8)
    _++;
  const k = Buffer$d.alloc(2 + _);
  k[0] = p, k[1] = 128 | _;
  for (let M = 1 + _, L = v.length; L > 0; M--, L >>= 8)
    k[M] = L & 255;
  return this._createEncoderBuffer([k, v]);
};
DERNode$1.prototype._encodeStr = function a(u, c) {
  if (c === "bitstr")
    return this._createEncoderBuffer([u.unused | 0, u.data]);
  if (c === "bmpstr") {
    const l = Buffer$d.alloc(u.length * 2);
    for (let v = 0; v < u.length; v++)
      l.writeUInt16BE(u.charCodeAt(v), v * 2);
    return this._createEncoderBuffer(l);
  } else
    return c === "numstr" ? this._isNumstr(u) ? this._createEncoderBuffer(u) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : c === "printstr" ? this._isPrintstr(u) ? this._createEncoderBuffer(u) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(c) ? this._createEncoderBuffer(u) : c === "objDesc" ? this._createEncoderBuffer(u) : this.reporter.error("Encoding of string type: " + c + " unsupported");
};
DERNode$1.prototype._encodeObjid = function a(u, c, l) {
  if (typeof u == "string") {
    if (!c)
      return this.reporter.error("string objid given, but no values map found");
    if (!c.hasOwnProperty(u))
      return this.reporter.error("objid not found in values map");
    u = c[u].split(/[\s.]+/g);
    for (let k = 0; k < u.length; k++)
      u[k] |= 0;
  } else if (Array.isArray(u)) {
    u = u.slice();
    for (let k = 0; k < u.length; k++)
      u[k] |= 0;
  }
  if (!Array.isArray(u))
    return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(u));
  if (!l) {
    if (u[1] >= 40)
      return this.reporter.error("Second objid identifier OOB");
    u.splice(0, 2, u[0] * 40 + u[1]);
  }
  let v = 0;
  for (let k = 0; k < u.length; k++) {
    let M = u[k];
    for (v++; M >= 128; M >>= 7)
      v++;
  }
  const p = Buffer$d.alloc(v);
  let _ = p.length - 1;
  for (let k = u.length - 1; k >= 0; k--) {
    let M = u[k];
    for (p[_--] = M & 127; (M >>= 7) > 0; )
      p[_--] = 128 | M & 127;
  }
  return this._createEncoderBuffer(p);
};
function two(a) {
  return a < 10 ? "0" + a : a;
}
DERNode$1.prototype._encodeTime = function a(u, c) {
  let l;
  const v = new Date(u);
  return c === "gentime" ? l = [
    two(v.getUTCFullYear()),
    two(v.getUTCMonth() + 1),
    two(v.getUTCDate()),
    two(v.getUTCHours()),
    two(v.getUTCMinutes()),
    two(v.getUTCSeconds()),
    "Z"
  ].join("") : c === "utctime" ? l = [
    two(v.getUTCFullYear() % 100),
    two(v.getUTCMonth() + 1),
    two(v.getUTCDate()),
    two(v.getUTCHours()),
    two(v.getUTCMinutes()),
    two(v.getUTCSeconds()),
    "Z"
  ].join("") : this.reporter.error("Encoding " + c + " time is not supported yet"), this._encodeStr(l, "octstr");
};
DERNode$1.prototype._encodeNull = function a() {
  return this._createEncoderBuffer("");
};
DERNode$1.prototype._encodeInt = function a(u, c) {
  if (typeof u == "string") {
    if (!c)
      return this.reporter.error("String int or enum given, but no values map");
    if (!c.hasOwnProperty(u))
      return this.reporter.error("Values map doesn't contain: " + JSON.stringify(u));
    u = c[u];
  }
  if (typeof u != "number" && !Buffer$d.isBuffer(u)) {
    const p = u.toArray();
    !u.sign && p[0] & 128 && p.unshift(0), u = Buffer$d.from(p);
  }
  if (Buffer$d.isBuffer(u)) {
    let p = u.length;
    u.length === 0 && p++;
    const _ = Buffer$d.alloc(p);
    return u.copy(_), u.length === 0 && (_[0] = 0), this._createEncoderBuffer(_);
  }
  if (u < 128)
    return this._createEncoderBuffer(u);
  if (u < 256)
    return this._createEncoderBuffer([0, u]);
  let l = 1;
  for (let p = u; p >= 256; p >>= 8)
    l++;
  const v = new Array(l);
  for (let p = v.length - 1; p >= 0; p--)
    v[p] = u & 255, u >>= 8;
  return v[0] & 128 && v.unshift(0), this._createEncoderBuffer(Buffer$d.from(v));
};
DERNode$1.prototype._encodeBool = function a(u) {
  return this._createEncoderBuffer(u ? 255 : 0);
};
DERNode$1.prototype._use = function a(u, c) {
  return typeof u == "function" && (u = u(c)), u._getEncoder("der").tree;
};
DERNode$1.prototype._skipDefault = function a(u, c, l) {
  const v = this._baseState;
  let p;
  if (v.default === null)
    return !1;
  const _ = u.join();
  if (v.defaultBuffer === void 0 && (v.defaultBuffer = this._encodeValue(v.default, c, l).join()), _.length !== v.defaultBuffer.length)
    return !1;
  for (p = 0; p < _.length; p++)
    if (_[p] !== v.defaultBuffer[p])
      return !1;
  return !0;
};
function encodeTag(a, u, c, l) {
  let v;
  if (a === "seqof" ? a = "seq" : a === "setof" && (a = "set"), der$1.tagByName.hasOwnProperty(a))
    v = der$1.tagByName[a];
  else if (typeof a == "number" && (a | 0) === a)
    v = a;
  else
    return l.error("Unknown tag: " + a);
  return v >= 31 ? l.error("Multi-octet tag encoding unsupported") : (u || (v |= 32), v |= der$1.tagClassByName[c || "universal"] << 6, v);
}
const inherits$2 = inherits_browserExports, DEREncoder = der_1$1;
function PEMEncoder(a) {
  DEREncoder.call(this, a), this.enc = "pem";
}
inherits$2(PEMEncoder, DEREncoder);
var pem$1 = PEMEncoder;
PEMEncoder.prototype.encode = function a(u, c) {
  const v = DEREncoder.prototype.encode.call(this, u).toString("base64"), p = ["-----BEGIN " + c.label + "-----"];
  for (let _ = 0; _ < v.length; _ += 64)
    p.push(v.slice(_, _ + 64));
  return p.push("-----END " + c.label + "-----"), p.join(`
`);
};
(function(a) {
  const u = a;
  u.der = der_1$1, u.pem = pem$1;
})(encoders);
var decoders = {};
const inherits$1 = inherits_browserExports, bignum = bnExports$2, DecoderBuffer = buffer.DecoderBuffer, Node = node, der = der$2;
function DERDecoder$1(a) {
  this.enc = "der", this.name = a.name, this.entity = a, this.tree = new DERNode(), this.tree._init(a.body);
}
var der_1 = DERDecoder$1;
DERDecoder$1.prototype.decode = function a(u, c) {
  return DecoderBuffer.isDecoderBuffer(u) || (u = new DecoderBuffer(u, c)), this.tree._decode(u, c);
};
function DERNode(a) {
  Node.call(this, "der", a);
}
inherits$1(DERNode, Node);
DERNode.prototype._peekTag = function a(u, c, l) {
  if (u.isEmpty())
    return !1;
  const v = u.save(), p = derDecodeTag(u, 'Failed to peek tag: "' + c + '"');
  return u.isError(p) ? p : (u.restore(v), p.tag === c || p.tagStr === c || p.tagStr + "of" === c || l);
};
DERNode.prototype._decodeTag = function a(u, c, l) {
  const v = derDecodeTag(
    u,
    'Failed to decode tag of "' + c + '"'
  );
  if (u.isError(v))
    return v;
  let p = derDecodeLen(
    u,
    v.primitive,
    'Failed to get length of "' + c + '"'
  );
  if (u.isError(p))
    return p;
  if (!l && v.tag !== c && v.tagStr !== c && v.tagStr + "of" !== c)
    return u.error('Failed to match tag: "' + c + '"');
  if (v.primitive || p !== null)
    return u.skip(p, 'Failed to match body of: "' + c + '"');
  const _ = u.save(), k = this._skipUntilEnd(
    u,
    'Failed to skip indefinite length body: "' + this.tag + '"'
  );
  return u.isError(k) ? k : (p = u.offset - _.offset, u.restore(_), u.skip(p, 'Failed to match body of: "' + c + '"'));
};
DERNode.prototype._skipUntilEnd = function a(u, c) {
  for (; ; ) {
    const l = derDecodeTag(u, c);
    if (u.isError(l))
      return l;
    const v = derDecodeLen(u, l.primitive, c);
    if (u.isError(v))
      return v;
    let p;
    if (l.primitive || v !== null ? p = u.skip(v) : p = this._skipUntilEnd(u, c), u.isError(p))
      return p;
    if (l.tagStr === "end")
      break;
  }
};
DERNode.prototype._decodeList = function a(u, c, l, v) {
  const p = [];
  for (; !u.isEmpty(); ) {
    const _ = this._peekTag(u, "end");
    if (u.isError(_))
      return _;
    const k = l.decode(u, "der", v);
    if (u.isError(k) && _)
      break;
    p.push(k);
  }
  return p;
};
DERNode.prototype._decodeStr = function a(u, c) {
  if (c === "bitstr") {
    const l = u.readUInt8();
    return u.isError(l) ? l : { unused: l, data: u.raw() };
  } else if (c === "bmpstr") {
    const l = u.raw();
    if (l.length % 2 === 1)
      return u.error("Decoding of string type: bmpstr length mismatch");
    let v = "";
    for (let p = 0; p < l.length / 2; p++)
      v += String.fromCharCode(l.readUInt16BE(p * 2));
    return v;
  } else if (c === "numstr") {
    const l = u.raw().toString("ascii");
    return this._isNumstr(l) ? l : u.error("Decoding of string type: numstr unsupported characters");
  } else {
    if (c === "octstr")
      return u.raw();
    if (c === "objDesc")
      return u.raw();
    if (c === "printstr") {
      const l = u.raw().toString("ascii");
      return this._isPrintstr(l) ? l : u.error("Decoding of string type: printstr unsupported characters");
    } else
      return /str$/.test(c) ? u.raw().toString() : u.error("Decoding of string type: " + c + " unsupported");
  }
};
DERNode.prototype._decodeObjid = function a(u, c, l) {
  let v;
  const p = [];
  let _ = 0, k = 0;
  for (; !u.isEmpty(); )
    k = u.readUInt8(), _ <<= 7, _ |= k & 127, k & 128 || (p.push(_), _ = 0);
  k & 128 && p.push(_);
  const M = p[0] / 40 | 0, L = p[0] % 40;
  if (l ? v = p : v = [M, L].concat(p.slice(1)), c) {
    let F = c[v.join(" ")];
    F === void 0 && (F = c[v.join(".")]), F !== void 0 && (v = F);
  }
  return v;
};
DERNode.prototype._decodeTime = function a(u, c) {
  const l = u.raw().toString();
  let v, p, _, k, M, L;
  if (c === "gentime")
    v = l.slice(0, 4) | 0, p = l.slice(4, 6) | 0, _ = l.slice(6, 8) | 0, k = l.slice(8, 10) | 0, M = l.slice(10, 12) | 0, L = l.slice(12, 14) | 0;
  else if (c === "utctime")
    v = l.slice(0, 2) | 0, p = l.slice(2, 4) | 0, _ = l.slice(4, 6) | 0, k = l.slice(6, 8) | 0, M = l.slice(8, 10) | 0, L = l.slice(10, 12) | 0, v < 70 ? v = 2e3 + v : v = 1900 + v;
  else
    return u.error("Decoding " + c + " time is not supported yet");
  return Date.UTC(v, p - 1, _, k, M, L, 0);
};
DERNode.prototype._decodeNull = function a() {
  return null;
};
DERNode.prototype._decodeBool = function a(u) {
  const c = u.readUInt8();
  return u.isError(c) ? c : c !== 0;
};
DERNode.prototype._decodeInt = function a(u, c) {
  const l = u.raw();
  let v = new bignum(l);
  return c && (v = c[v.toString(10)] || v), v;
};
DERNode.prototype._use = function a(u, c) {
  return typeof u == "function" && (u = u(c)), u._getDecoder("der").tree;
};
function derDecodeTag(a, u) {
  let c = a.readUInt8(u);
  if (a.isError(c))
    return c;
  const l = der.tagClass[c >> 6], v = (c & 32) === 0;
  if ((c & 31) === 31) {
    let _ = c;
    for (c = 0; (_ & 128) === 128; ) {
      if (_ = a.readUInt8(u), a.isError(_))
        return _;
      c <<= 7, c |= _ & 127;
    }
  } else
    c &= 31;
  const p = der.tag[c];
  return {
    cls: l,
    primitive: v,
    tag: c,
    tagStr: p
  };
}
function derDecodeLen(a, u, c) {
  let l = a.readUInt8(c);
  if (a.isError(l))
    return l;
  if (!u && l === 128)
    return null;
  if (!(l & 128))
    return l;
  const v = l & 127;
  if (v > 4)
    return a.error("length octect is too long");
  l = 0;
  for (let p = 0; p < v; p++) {
    l <<= 8;
    const _ = a.readUInt8(c);
    if (a.isError(_))
      return _;
    l |= _;
  }
  return l;
}
const inherits = inherits_browserExports, Buffer$c = safer_1.Buffer, DERDecoder = der_1;
function PEMDecoder(a) {
  DERDecoder.call(this, a), this.enc = "pem";
}
inherits(PEMDecoder, DERDecoder);
var pem = PEMDecoder;
PEMDecoder.prototype.decode = function a(u, c) {
  const l = u.toString().split(/[\r\n]+/g), v = c.label.toUpperCase(), p = /^-----(BEGIN|END) ([^-]+)-----$/;
  let _ = -1, k = -1;
  for (let F = 0; F < l.length; F++) {
    const V = l[F].match(p);
    if (V !== null && V[2] === v)
      if (_ === -1) {
        if (V[1] !== "BEGIN")
          break;
        _ = F;
      } else {
        if (V[1] !== "END")
          break;
        k = F;
        break;
      }
  }
  if (_ === -1 || k === -1)
    throw new Error("PEM section not found for: " + v);
  const M = l.slice(_ + 1, k).join("");
  M.replace(/[^a-z0-9+/=]+/gi, "");
  const L = Buffer$c.from(M, "base64");
  return DERDecoder.prototype.decode.call(this, L, c);
};
(function(a) {
  const u = a;
  u.der = der_1, u.pem = pem;
})(decoders);
(function(a) {
  const u = encoders, c = decoders, l = inherits_browserExports, v = a;
  v.define = function(k, M) {
    return new p(k, M);
  };
  function p(_, k) {
    this.name = _, this.body = k, this.decoders = {}, this.encoders = {};
  }
  p.prototype._createNamed = function(k) {
    const M = this.name;
    function L(F) {
      this._initNamed(F, M);
    }
    return l(L, k), L.prototype._initNamed = function(V, X) {
      k.call(this, V, X);
    }, new L(this);
  }, p.prototype._getDecoder = function(k) {
    return k = k || "der", this.decoders.hasOwnProperty(k) || (this.decoders[k] = this._createNamed(c[k])), this.decoders[k];
  }, p.prototype.decode = function(k, M, L) {
    return this._getDecoder(M).decode(k, L);
  }, p.prototype._getEncoder = function(k) {
    return k = k || "der", this.encoders.hasOwnProperty(k) || (this.encoders[k] = this._createNamed(u[k])), this.encoders[k];
  }, p.prototype.encode = function(k, M, L) {
    return this._getEncoder(M).encode(k, L);
  };
})(api);
var base = {};
(function(a) {
  const u = a;
  u.Reporter = reporter.Reporter, u.DecoderBuffer = buffer.DecoderBuffer, u.EncoderBuffer = buffer.EncoderBuffer, u.Node = node;
})(base);
var constants = {};
(function(a) {
  const u = a;
  u._reverse = function(l) {
    const v = {};
    return Object.keys(l).forEach(function(p) {
      (p | 0) == p && (p = p | 0);
      const _ = l[p];
      v[_] = p;
    }), v;
  }, u.der = der$2;
})(constants);
(function(a) {
  const u = a;
  u.bignum = bnExports$2, u.define = api.define, u.base = base, u.constants = constants, u.decoders = decoders, u.encoders = encoders;
})(asn1$2);
var asn = asn1$2, Time = asn.define("Time", function() {
  this.choice({
    utcTime: this.utctime(),
    generalTime: this.gentime()
  });
}), AttributeTypeValue = asn.define("AttributeTypeValue", function() {
  this.seq().obj(
    this.key("type").objid(),
    this.key("value").any()
  );
}), AlgorithmIdentifier$1 = asn.define("AlgorithmIdentifier", function() {
  this.seq().obj(
    this.key("algorithm").objid(),
    this.key("parameters").optional(),
    this.key("curve").objid().optional()
  );
}), SubjectPublicKeyInfo = asn.define("SubjectPublicKeyInfo", function() {
  this.seq().obj(
    this.key("algorithm").use(AlgorithmIdentifier$1),
    this.key("subjectPublicKey").bitstr()
  );
}), RelativeDistinguishedName = asn.define("RelativeDistinguishedName", function() {
  this.setof(AttributeTypeValue);
}), RDNSequence = asn.define("RDNSequence", function() {
  this.seqof(RelativeDistinguishedName);
}), Name = asn.define("Name", function() {
  this.choice({
    rdnSequence: this.use(RDNSequence)
  });
}), Validity = asn.define("Validity", function() {
  this.seq().obj(
    this.key("notBefore").use(Time),
    this.key("notAfter").use(Time)
  );
}), Extension = asn.define("Extension", function() {
  this.seq().obj(
    this.key("extnID").objid(),
    this.key("critical").bool().def(!1),
    this.key("extnValue").octstr()
  );
}), TBSCertificate = asn.define("TBSCertificate", function() {
  this.seq().obj(
    this.key("version").explicit(0).int().optional(),
    this.key("serialNumber").int(),
    this.key("signature").use(AlgorithmIdentifier$1),
    this.key("issuer").use(Name),
    this.key("validity").use(Validity),
    this.key("subject").use(Name),
    this.key("subjectPublicKeyInfo").use(SubjectPublicKeyInfo),
    this.key("issuerUniqueID").implicit(1).bitstr().optional(),
    this.key("subjectUniqueID").implicit(2).bitstr().optional(),
    this.key("extensions").explicit(3).seqof(Extension).optional()
  );
}), X509Certificate = asn.define("X509Certificate", function() {
  this.seq().obj(
    this.key("tbsCertificate").use(TBSCertificate),
    this.key("signatureAlgorithm").use(AlgorithmIdentifier$1),
    this.key("signatureValue").bitstr()
  );
}), certificate = X509Certificate, asn1$1 = asn1$2;
asn1$3.certificate = certificate;
var RSAPrivateKey = asn1$1.define("RSAPrivateKey", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("modulus").int(),
    this.key("publicExponent").int(),
    this.key("privateExponent").int(),
    this.key("prime1").int(),
    this.key("prime2").int(),
    this.key("exponent1").int(),
    this.key("exponent2").int(),
    this.key("coefficient").int()
  );
});
asn1$3.RSAPrivateKey = RSAPrivateKey;
var RSAPublicKey = asn1$1.define("RSAPublicKey", function() {
  this.seq().obj(
    this.key("modulus").int(),
    this.key("publicExponent").int()
  );
});
asn1$3.RSAPublicKey = RSAPublicKey;
var PublicKey = asn1$1.define("SubjectPublicKeyInfo", function() {
  this.seq().obj(
    this.key("algorithm").use(AlgorithmIdentifier),
    this.key("subjectPublicKey").bitstr()
  );
});
asn1$3.PublicKey = PublicKey;
var AlgorithmIdentifier = asn1$1.define("AlgorithmIdentifier", function() {
  this.seq().obj(
    this.key("algorithm").objid(),
    this.key("none").null_().optional(),
    this.key("curve").objid().optional(),
    this.key("params").seq().obj(
      this.key("p").int(),
      this.key("q").int(),
      this.key("g").int()
    ).optional()
  );
}), PrivateKeyInfo = asn1$1.define("PrivateKeyInfo", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("algorithm").use(AlgorithmIdentifier),
    this.key("subjectPrivateKey").octstr()
  );
});
asn1$3.PrivateKey = PrivateKeyInfo;
var EncryptedPrivateKeyInfo = asn1$1.define("EncryptedPrivateKeyInfo", function() {
  this.seq().obj(
    this.key("algorithm").seq().obj(
      this.key("id").objid(),
      this.key("decrypt").seq().obj(
        this.key("kde").seq().obj(
          this.key("id").objid(),
          this.key("kdeparams").seq().obj(
            this.key("salt").octstr(),
            this.key("iters").int()
          )
        ),
        this.key("cipher").seq().obj(
          this.key("algo").objid(),
          this.key("iv").octstr()
        )
      )
    ),
    this.key("subjectPrivateKey").octstr()
  );
});
asn1$3.EncryptedPrivateKey = EncryptedPrivateKeyInfo;
var DSAPrivateKey = asn1$1.define("DSAPrivateKey", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("p").int(),
    this.key("q").int(),
    this.key("g").int(),
    this.key("pub_key").int(),
    this.key("priv_key").int()
  );
});
asn1$3.DSAPrivateKey = DSAPrivateKey;
asn1$3.DSAparam = asn1$1.define("DSAparam", function() {
  this.int();
});
var ECPrivateKey = asn1$1.define("ECPrivateKey", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("privateKey").octstr(),
    this.key("parameters").optional().explicit(0).use(ECParameters),
    this.key("publicKey").optional().explicit(1).bitstr()
  );
});
asn1$3.ECPrivateKey = ECPrivateKey;
var ECParameters = asn1$1.define("ECParameters", function() {
  this.choice({
    namedCurve: this.objid()
  });
});
asn1$3.signature = asn1$1.define("signature", function() {
  this.seq().obj(
    this.key("r").int(),
    this.key("s").int()
  );
});
const require$$1 = {
  "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
  "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
  "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
  "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
  "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
  "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
  "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
  "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
  "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
  "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
  "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
  "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
};
var findProc = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, startRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, fullRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, evp = evp_bytestokey, ciphers$1 = browser$6, Buffer$b = safeBufferExports$3.Buffer, fixProc$1 = function(a, u) {
  var c = a.toString(), l = c.match(findProc), v;
  if (l) {
    var _ = "aes" + l[1], k = Buffer$b.from(l[2], "hex"), M = Buffer$b.from(l[3].replace(/[\r\n]/g, ""), "base64"), L = evp(u, k.slice(0, 8), parseInt(l[1], 10)).key, F = [], V = ciphers$1.createDecipheriv(_, L, k);
    F.push(V.update(M)), F.push(V.final()), v = Buffer$b.concat(F);
  } else {
    var p = c.match(fullRegex);
    v = Buffer$b.from(p[2].replace(/[\r\n]/g, ""), "base64");
  }
  var X = c.match(startRegex)[1];
  return {
    tag: X,
    data: v
  };
}, asn1 = asn1$3, aesid = require$$1, fixProc = fixProc$1, ciphers = browser$6, compat = browser$8, Buffer$a = safeBufferExports$3.Buffer, parseAsn1 = parseKeys$2;
function parseKeys$2(a) {
  var u;
  typeof a == "object" && !Buffer$a.isBuffer(a) && (u = a.passphrase, a = a.key), typeof a == "string" && (a = Buffer$a.from(a));
  var c = fixProc(a, u), l = c.tag, v = c.data, p, _;
  switch (l) {
    case "CERTIFICATE":
      _ = asn1.certificate.decode(v, "der").tbsCertificate.subjectPublicKeyInfo;
    case "PUBLIC KEY":
      switch (_ || (_ = asn1.PublicKey.decode(v, "der")), p = _.algorithm.algorithm.join("."), p) {
        case "1.2.840.113549.1.1.1":
          return asn1.RSAPublicKey.decode(_.subjectPublicKey.data, "der");
        case "1.2.840.10045.2.1":
          return _.subjectPrivateKey = _.subjectPublicKey, {
            type: "ec",
            data: _
          };
        case "1.2.840.10040.4.1":
          return _.algorithm.params.pub_key = asn1.DSAparam.decode(_.subjectPublicKey.data, "der"), {
            type: "dsa",
            data: _.algorithm.params
          };
        default:
          throw new Error("unknown key id " + p);
      }
    case "ENCRYPTED PRIVATE KEY":
      v = asn1.EncryptedPrivateKey.decode(v, "der"), v = decrypt(v, u);
    case "PRIVATE KEY":
      switch (_ = asn1.PrivateKey.decode(v, "der"), p = _.algorithm.algorithm.join("."), p) {
        case "1.2.840.113549.1.1.1":
          return asn1.RSAPrivateKey.decode(_.subjectPrivateKey, "der");
        case "1.2.840.10045.2.1":
          return {
            curve: _.algorithm.curve,
            privateKey: asn1.ECPrivateKey.decode(_.subjectPrivateKey, "der").privateKey
          };
        case "1.2.840.10040.4.1":
          return _.algorithm.params.priv_key = asn1.DSAparam.decode(_.subjectPrivateKey, "der"), {
            type: "dsa",
            params: _.algorithm.params
          };
        default:
          throw new Error("unknown key id " + p);
      }
    case "RSA PUBLIC KEY":
      return asn1.RSAPublicKey.decode(v, "der");
    case "RSA PRIVATE KEY":
      return asn1.RSAPrivateKey.decode(v, "der");
    case "DSA PRIVATE KEY":
      return {
        type: "dsa",
        params: asn1.DSAPrivateKey.decode(v, "der")
      };
    case "EC PRIVATE KEY":
      return v = asn1.ECPrivateKey.decode(v, "der"), {
        curve: v.parameters.value,
        privateKey: v.privateKey
      };
    default:
      throw new Error("unknown key type " + l);
  }
}
parseKeys$2.signature = asn1.signature;
function decrypt(a, u) {
  var c = a.algorithm.decrypt.kde.kdeparams.salt, l = parseInt(a.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), v = aesid[a.algorithm.decrypt.cipher.algo.join(".")], p = a.algorithm.decrypt.cipher.iv, _ = a.subjectPrivateKey, k = parseInt(v.split("-")[1], 10) / 8, M = compat.pbkdf2Sync(u, c, l, k, "sha1"), L = ciphers.createDecipheriv(v, M, p), F = [];
  return F.push(L.update(_)), F.push(L.final()), Buffer$a.concat(F);
}
const require$$4 = {
  "1.3.132.0.10": "secp256k1",
  "1.3.132.0.33": "p224",
  "1.2.840.10045.3.1.1": "p192",
  "1.2.840.10045.3.1.7": "p256",
  "1.3.132.0.34": "p384",
  "1.3.132.0.35": "p521"
};
var hasRequiredSign;
function requireSign() {
  if (hasRequiredSign)
    return sign$1.exports;
  hasRequiredSign = 1;
  var a = safeBufferExports.Buffer, u = browser$9, c = browserifyRsa, l = requireElliptic().ec, v = bnExports$4, p = parseAsn1, _ = require$$4, k = 1;
  function M(fe, ie, ge, be, Ce) {
    var Me = p(ie);
    if (Me.curve) {
      if (be !== "ecdsa" && be !== "ecdsa/rsa")
        throw new Error("wrong private key type");
      return L(fe, Me);
    } else if (Me.type === "dsa") {
      if (be !== "dsa")
        throw new Error("wrong private key type");
      return F(fe, Me, ge);
    }
    if (be !== "rsa" && be !== "ecdsa/rsa")
      throw new Error("wrong private key type");
    if (ie.padding !== void 0 && ie.padding !== k)
      throw new Error("illegal or unsupported padding mode");
    fe = a.concat([Ce, fe]);
    for (var Be = Me.modulus.byteLength(), Ae = [0, 1]; fe.length + Ae.length + 1 < Be; )
      Ae.push(255);
    Ae.push(0);
    for (var Z = -1; ++Z < fe.length; )
      Ae.push(fe[Z]);
    var z = c(Ae, Me);
    return z;
  }
  function L(fe, ie) {
    var ge = _[ie.curve.join(".")];
    if (!ge)
      throw new Error("unknown curve " + ie.curve.join("."));
    var be = new l(ge), Ce = be.keyFromPrivate(ie.privateKey), Me = Ce.sign(fe);
    return a.from(Me.toDER());
  }
  function F(fe, ie, ge) {
    for (var be = ie.params.priv_key, Ce = ie.params.p, Me = ie.params.q, Be = ie.params.g, Ae = new v(0), Z, z = oe(fe, Me).mod(Me), P = !1, S = X(be, Me, fe, ge); P === !1; )
      Z = ae(Me, S, ge), Ae = ne(Be, Z, Ce, Me), P = Z.invm(Me).imul(z.add(be.mul(Ae))).mod(Me), P.cmpn(0) === 0 && (P = !1, Ae = new v(0));
    return V(Ae, P);
  }
  function V(fe, ie) {
    fe = fe.toArray(), ie = ie.toArray(), fe[0] & 128 && (fe = [0].concat(fe)), ie[0] & 128 && (ie = [0].concat(ie));
    var ge = fe.length + ie.length + 4, be = [
      48,
      ge,
      2,
      fe.length
    ];
    return be = be.concat(fe, [2, ie.length], ie), a.from(be);
  }
  function X(fe, ie, ge, be) {
    if (fe = a.from(fe.toArray()), fe.length < ie.byteLength()) {
      var Ce = a.alloc(ie.byteLength() - fe.length);
      fe = a.concat([Ce, fe]);
    }
    var Me = ge.length, Be = Y(ge, ie), Ae = a.alloc(Me);
    Ae.fill(1);
    var Z = a.alloc(Me);
    return Z = u(be, Z).update(Ae).update(a.from([0])).update(fe).update(Be).digest(), Ae = u(be, Z).update(Ae).digest(), Z = u(be, Z).update(Ae).update(a.from([1])).update(fe).update(Be).digest(), Ae = u(be, Z).update(Ae).digest(), { k: Z, v: Ae };
  }
  function oe(fe, ie) {
    var ge = new v(fe), be = (fe.length << 3) - ie.bitLength();
    return be > 0 && ge.ishrn(be), ge;
  }
  function Y(fe, ie) {
    fe = oe(fe, ie), fe = fe.mod(ie);
    var ge = a.from(fe.toArray());
    if (ge.length < ie.byteLength()) {
      var be = a.alloc(ie.byteLength() - ge.length);
      ge = a.concat([be, ge]);
    }
    return ge;
  }
  function ae(fe, ie, ge) {
    var be, Ce;
    do {
      for (be = a.alloc(0); be.length * 8 < fe.bitLength(); )
        ie.v = u(ge, ie.k).update(ie.v).digest(), be = a.concat([be, ie.v]);
      Ce = oe(be, fe), ie.k = u(ge, ie.k).update(ie.v).update(a.from([0])).digest(), ie.v = u(ge, ie.k).update(ie.v).digest();
    } while (Ce.cmp(fe) !== -1);
    return Ce;
  }
  function ne(fe, ie, ge, be) {
    return fe.toRed(v.mont(ge)).redPow(ie).fromRed().mod(be);
  }
  return sign$1.exports = M, sign$1.exports.getKey = X, sign$1.exports.makeKey = ae, sign$1.exports;
}
var verify_1, hasRequiredVerify;
function requireVerify() {
  if (hasRequiredVerify)
    return verify_1;
  hasRequiredVerify = 1;
  var a = safeBufferExports.Buffer, u = bnExports$4, c = requireElliptic().ec, l = parseAsn1, v = require$$4;
  function p(L, F, V, X, oe) {
    var Y = l(V);
    if (Y.type === "ec") {
      if (X !== "ecdsa" && X !== "ecdsa/rsa")
        throw new Error("wrong public key type");
      return _(L, F, Y);
    } else if (Y.type === "dsa") {
      if (X !== "dsa")
        throw new Error("wrong public key type");
      return k(L, F, Y);
    }
    if (X !== "rsa" && X !== "ecdsa/rsa")
      throw new Error("wrong public key type");
    F = a.concat([oe, F]);
    for (var ae = Y.modulus.byteLength(), ne = [1], fe = 0; F.length + ne.length + 2 < ae; )
      ne.push(255), fe += 1;
    ne.push(0);
    for (var ie = -1; ++ie < F.length; )
      ne.push(F[ie]);
    ne = a.from(ne);
    var ge = u.mont(Y.modulus);
    L = new u(L).toRed(ge), L = L.redPow(new u(Y.publicExponent)), L = a.from(L.fromRed().toArray());
    var be = fe < 8 ? 1 : 0;
    for (ae = Math.min(L.length, ne.length), L.length !== ne.length && (be = 1), ie = -1; ++ie < ae; )
      be |= L[ie] ^ ne[ie];
    return be === 0;
  }
  function _(L, F, V) {
    var X = v[V.data.algorithm.curve.join(".")];
    if (!X)
      throw new Error("unknown curve " + V.data.algorithm.curve.join("."));
    var oe = new c(X), Y = V.data.subjectPrivateKey.data;
    return oe.verify(F, L, Y);
  }
  function k(L, F, V) {
    var X = V.data.p, oe = V.data.q, Y = V.data.g, ae = V.data.pub_key, ne = l.signature.decode(L, "der"), fe = ne.s, ie = ne.r;
    M(fe, oe), M(ie, oe);
    var ge = u.mont(X), be = fe.invm(oe), Ce = Y.toRed(ge).redPow(new u(F).mul(be).mod(oe)).fromRed().mul(ae.toRed(ge).redPow(ie.mul(be).mod(oe)).fromRed()).mod(X).mod(oe);
    return Ce.cmp(ie) === 0;
  }
  function M(L, F) {
    if (L.cmpn(0) <= 0)
      throw new Error("invalid sig");
    if (L.cmp(F) >= 0)
      throw new Error("invalid sig");
  }
  return verify_1 = p, verify_1;
}
var browser$4, hasRequiredBrowser$1;
function requireBrowser$1() {
  if (hasRequiredBrowser$1)
    return browser$4;
  hasRequiredBrowser$1 = 1;
  var a = safeBufferExports.Buffer, u = browser$a, c = readableBrowserExports, l = inherits_browserExports, v = requireSign(), p = requireVerify(), _ = require$$6;
  Object.keys(_).forEach(function(V) {
    _[V].id = a.from(_[V].id, "hex"), _[V.toLowerCase()] = _[V];
  });
  function k(V) {
    c.Writable.call(this);
    var X = _[V];
    if (!X)
      throw new Error("Unknown message digest");
    this._hashType = X.hash, this._hash = u(X.hash), this._tag = X.id, this._signType = X.sign;
  }
  l(k, c.Writable), k.prototype._write = function(X, oe, Y) {
    this._hash.update(X), Y();
  }, k.prototype.update = function(X, oe) {
    return this._hash.update(typeof X == "string" ? a.from(X, oe) : X), this;
  }, k.prototype.sign = function(X, oe) {
    this.end();
    var Y = this._hash.digest(), ae = v(Y, X, this._hashType, this._signType, this._tag);
    return oe ? ae.toString(oe) : ae;
  };
  function M(V) {
    c.Writable.call(this);
    var X = _[V];
    if (!X)
      throw new Error("Unknown message digest");
    this._hash = u(X.hash), this._tag = X.id, this._signType = X.sign;
  }
  l(M, c.Writable), M.prototype._write = function(X, oe, Y) {
    this._hash.update(X), Y();
  }, M.prototype.update = function(X, oe) {
    return this._hash.update(typeof X == "string" ? a.from(X, oe) : X), this;
  }, M.prototype.verify = function(X, oe, Y) {
    var ae = typeof oe == "string" ? a.from(oe, Y) : oe;
    this.end();
    var ne = this._hash.digest();
    return p(ae, ne, X, this._signType, this._tag);
  };
  function L(V) {
    return new k(V);
  }
  function F(V) {
    return new M(V);
  }
  return browser$4 = {
    Sign: L,
    Verify: F,
    createSign: L,
    createVerify: F
  }, browser$4;
}
var bn$1 = { exports: {} };
bn$1.exports;
(function(a) {
  (function(u, c) {
    function l(P, S) {
      if (!P)
        throw new Error(S || "Assertion failed");
    }
    function v(P, S) {
      P.super_ = S;
      var E = function() {
      };
      E.prototype = S.prototype, P.prototype = new E(), P.prototype.constructor = P;
    }
    function p(P, S, E) {
      if (p.isBN(P))
        return P;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, P !== null && ((S === "le" || S === "be") && (E = S, S = 10), this._init(P || 0, S || 10, E || "be"));
    }
    typeof u == "object" ? u.exports = p : c.BN = p, p.BN = p, p.wordSize = 26;
    var _;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? _ = window.Buffer : _ = require$$0$2.Buffer;
    } catch {
    }
    p.isBN = function(S) {
      return S instanceof p ? !0 : S !== null && typeof S == "object" && S.constructor.wordSize === p.wordSize && Array.isArray(S.words);
    }, p.max = function(S, E) {
      return S.cmp(E) > 0 ? S : E;
    }, p.min = function(S, E) {
      return S.cmp(E) < 0 ? S : E;
    }, p.prototype._init = function(S, E, I) {
      if (typeof S == "number")
        return this._initNumber(S, E, I);
      if (typeof S == "object")
        return this._initArray(S, E, I);
      E === "hex" && (E = 16), l(E === (E | 0) && E >= 2 && E <= 36), S = S.toString().replace(/\s+/g, "");
      var N = 0;
      S[0] === "-" && (N++, this.negative = 1), N < S.length && (E === 16 ? this._parseHex(S, N, I) : (this._parseBase(S, E, N), I === "le" && this._initArray(this.toArray(), E, I)));
    }, p.prototype._initNumber = function(S, E, I) {
      S < 0 && (this.negative = 1, S = -S), S < 67108864 ? (this.words = [S & 67108863], this.length = 1) : S < 4503599627370496 ? (this.words = [
        S & 67108863,
        S / 67108864 & 67108863
      ], this.length = 2) : (l(S < 9007199254740992), this.words = [
        S & 67108863,
        S / 67108864 & 67108863,
        1
      ], this.length = 3), I === "le" && this._initArray(this.toArray(), E, I);
    }, p.prototype._initArray = function(S, E, I) {
      if (l(typeof S.length == "number"), S.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(S.length / 3), this.words = new Array(this.length);
      for (var N = 0; N < this.length; N++)
        this.words[N] = 0;
      var $, U, H = 0;
      if (I === "be")
        for (N = S.length - 1, $ = 0; N >= 0; N -= 3)
          U = S[N] | S[N - 1] << 8 | S[N - 2] << 16, this.words[$] |= U << H & 67108863, this.words[$ + 1] = U >>> 26 - H & 67108863, H += 24, H >= 26 && (H -= 26, $++);
      else if (I === "le")
        for (N = 0, $ = 0; N < S.length; N += 3)
          U = S[N] | S[N + 1] << 8 | S[N + 2] << 16, this.words[$] |= U << H & 67108863, this.words[$ + 1] = U >>> 26 - H & 67108863, H += 24, H >= 26 && (H -= 26, $++);
      return this.strip();
    };
    function k(P, S) {
      var E = P.charCodeAt(S);
      return E >= 65 && E <= 70 ? E - 55 : E >= 97 && E <= 102 ? E - 87 : E - 48 & 15;
    }
    function M(P, S, E) {
      var I = k(P, E);
      return E - 1 >= S && (I |= k(P, E - 1) << 4), I;
    }
    p.prototype._parseHex = function(S, E, I) {
      this.length = Math.ceil((S.length - E) / 6), this.words = new Array(this.length);
      for (var N = 0; N < this.length; N++)
        this.words[N] = 0;
      var $ = 0, U = 0, H;
      if (I === "be")
        for (N = S.length - 1; N >= E; N -= 2)
          H = M(S, E, N) << $, this.words[U] |= H & 67108863, $ >= 18 ? ($ -= 18, U += 1, this.words[U] |= H >>> 26) : $ += 8;
      else {
        var B = S.length - E;
        for (N = B % 2 === 0 ? E + 1 : E; N < S.length; N += 2)
          H = M(S, E, N) << $, this.words[U] |= H & 67108863, $ >= 18 ? ($ -= 18, U += 1, this.words[U] |= H >>> 26) : $ += 8;
      }
      this.strip();
    };
    function L(P, S, E, I) {
      for (var N = 0, $ = Math.min(P.length, E), U = S; U < $; U++) {
        var H = P.charCodeAt(U) - 48;
        N *= I, H >= 49 ? N += H - 49 + 10 : H >= 17 ? N += H - 17 + 10 : N += H;
      }
      return N;
    }
    p.prototype._parseBase = function(S, E, I) {
      this.words = [0], this.length = 1;
      for (var N = 0, $ = 1; $ <= 67108863; $ *= E)
        N++;
      N--, $ = $ / E | 0;
      for (var U = S.length - I, H = U % N, B = Math.min(U, U - H) + I, T = 0, D = I; D < B; D += N)
        T = L(S, D, D + N, E), this.imuln($), this.words[0] + T < 67108864 ? this.words[0] += T : this._iaddn(T);
      if (H !== 0) {
        var ee = 1;
        for (T = L(S, D, S.length, E), D = 0; D < H; D++)
          ee *= E;
        this.imuln(ee), this.words[0] + T < 67108864 ? this.words[0] += T : this._iaddn(T);
      }
      this.strip();
    }, p.prototype.copy = function(S) {
      S.words = new Array(this.length);
      for (var E = 0; E < this.length; E++)
        S.words[E] = this.words[E];
      S.length = this.length, S.negative = this.negative, S.red = this.red;
    }, p.prototype.clone = function() {
      var S = new p(null);
      return this.copy(S), S;
    }, p.prototype._expand = function(S) {
      for (; this.length < S; )
        this.words[this.length++] = 0;
      return this;
    }, p.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, p.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, p.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var F = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], V = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], X = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    p.prototype.toString = function(S, E) {
      S = S || 10, E = E | 0 || 1;
      var I;
      if (S === 16 || S === "hex") {
        I = "";
        for (var N = 0, $ = 0, U = 0; U < this.length; U++) {
          var H = this.words[U], B = ((H << N | $) & 16777215).toString(16);
          $ = H >>> 24 - N & 16777215, $ !== 0 || U !== this.length - 1 ? I = F[6 - B.length] + B + I : I = B + I, N += 2, N >= 26 && (N -= 26, U--);
        }
        for ($ !== 0 && (I = $.toString(16) + I); I.length % E !== 0; )
          I = "0" + I;
        return this.negative !== 0 && (I = "-" + I), I;
      }
      if (S === (S | 0) && S >= 2 && S <= 36) {
        var T = V[S], D = X[S];
        I = "";
        var ee = this.clone();
        for (ee.negative = 0; !ee.isZero(); ) {
          var pe = ee.modn(D).toString(S);
          ee = ee.idivn(D), ee.isZero() ? I = pe + I : I = F[T - pe.length] + pe + I;
        }
        for (this.isZero() && (I = "0" + I); I.length % E !== 0; )
          I = "0" + I;
        return this.negative !== 0 && (I = "-" + I), I;
      }
      l(!1, "Base should be between 2 and 36");
    }, p.prototype.toNumber = function() {
      var S = this.words[0];
      return this.length === 2 ? S += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? S += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && l(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -S : S;
    }, p.prototype.toJSON = function() {
      return this.toString(16);
    }, p.prototype.toBuffer = function(S, E) {
      return l(typeof _ < "u"), this.toArrayLike(_, S, E);
    }, p.prototype.toArray = function(S, E) {
      return this.toArrayLike(Array, S, E);
    }, p.prototype.toArrayLike = function(S, E, I) {
      var N = this.byteLength(), $ = I || Math.max(1, N);
      l(N <= $, "byte array longer than desired length"), l($ > 0, "Requested array length <= 0"), this.strip();
      var U = E === "le", H = new S($), B, T, D = this.clone();
      if (U) {
        for (T = 0; !D.isZero(); T++)
          B = D.andln(255), D.iushrn(8), H[T] = B;
        for (; T < $; T++)
          H[T] = 0;
      } else {
        for (T = 0; T < $ - N; T++)
          H[T] = 0;
        for (T = 0; !D.isZero(); T++)
          B = D.andln(255), D.iushrn(8), H[$ - T - 1] = B;
      }
      return H;
    }, Math.clz32 ? p.prototype._countBits = function(S) {
      return 32 - Math.clz32(S);
    } : p.prototype._countBits = function(S) {
      var E = S, I = 0;
      return E >= 4096 && (I += 13, E >>>= 13), E >= 64 && (I += 7, E >>>= 7), E >= 8 && (I += 4, E >>>= 4), E >= 2 && (I += 2, E >>>= 2), I + E;
    }, p.prototype._zeroBits = function(S) {
      if (S === 0)
        return 26;
      var E = S, I = 0;
      return E & 8191 || (I += 13, E >>>= 13), E & 127 || (I += 7, E >>>= 7), E & 15 || (I += 4, E >>>= 4), E & 3 || (I += 2, E >>>= 2), E & 1 || I++, I;
    }, p.prototype.bitLength = function() {
      var S = this.words[this.length - 1], E = this._countBits(S);
      return (this.length - 1) * 26 + E;
    };
    function oe(P) {
      for (var S = new Array(P.bitLength()), E = 0; E < S.length; E++) {
        var I = E / 26 | 0, N = E % 26;
        S[E] = (P.words[I] & 1 << N) >>> N;
      }
      return S;
    }
    p.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var S = 0, E = 0; E < this.length; E++) {
        var I = this._zeroBits(this.words[E]);
        if (S += I, I !== 26)
          break;
      }
      return S;
    }, p.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, p.prototype.toTwos = function(S) {
      return this.negative !== 0 ? this.abs().inotn(S).iaddn(1) : this.clone();
    }, p.prototype.fromTwos = function(S) {
      return this.testn(S - 1) ? this.notn(S).iaddn(1).ineg() : this.clone();
    }, p.prototype.isNeg = function() {
      return this.negative !== 0;
    }, p.prototype.neg = function() {
      return this.clone().ineg();
    }, p.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, p.prototype.iuor = function(S) {
      for (; this.length < S.length; )
        this.words[this.length++] = 0;
      for (var E = 0; E < S.length; E++)
        this.words[E] = this.words[E] | S.words[E];
      return this.strip();
    }, p.prototype.ior = function(S) {
      return l((this.negative | S.negative) === 0), this.iuor(S);
    }, p.prototype.or = function(S) {
      return this.length > S.length ? this.clone().ior(S) : S.clone().ior(this);
    }, p.prototype.uor = function(S) {
      return this.length > S.length ? this.clone().iuor(S) : S.clone().iuor(this);
    }, p.prototype.iuand = function(S) {
      var E;
      this.length > S.length ? E = S : E = this;
      for (var I = 0; I < E.length; I++)
        this.words[I] = this.words[I] & S.words[I];
      return this.length = E.length, this.strip();
    }, p.prototype.iand = function(S) {
      return l((this.negative | S.negative) === 0), this.iuand(S);
    }, p.prototype.and = function(S) {
      return this.length > S.length ? this.clone().iand(S) : S.clone().iand(this);
    }, p.prototype.uand = function(S) {
      return this.length > S.length ? this.clone().iuand(S) : S.clone().iuand(this);
    }, p.prototype.iuxor = function(S) {
      var E, I;
      this.length > S.length ? (E = this, I = S) : (E = S, I = this);
      for (var N = 0; N < I.length; N++)
        this.words[N] = E.words[N] ^ I.words[N];
      if (this !== E)
        for (; N < E.length; N++)
          this.words[N] = E.words[N];
      return this.length = E.length, this.strip();
    }, p.prototype.ixor = function(S) {
      return l((this.negative | S.negative) === 0), this.iuxor(S);
    }, p.prototype.xor = function(S) {
      return this.length > S.length ? this.clone().ixor(S) : S.clone().ixor(this);
    }, p.prototype.uxor = function(S) {
      return this.length > S.length ? this.clone().iuxor(S) : S.clone().iuxor(this);
    }, p.prototype.inotn = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = Math.ceil(S / 26) | 0, I = S % 26;
      this._expand(E), I > 0 && E--;
      for (var N = 0; N < E; N++)
        this.words[N] = ~this.words[N] & 67108863;
      return I > 0 && (this.words[N] = ~this.words[N] & 67108863 >> 26 - I), this.strip();
    }, p.prototype.notn = function(S) {
      return this.clone().inotn(S);
    }, p.prototype.setn = function(S, E) {
      l(typeof S == "number" && S >= 0);
      var I = S / 26 | 0, N = S % 26;
      return this._expand(I + 1), E ? this.words[I] = this.words[I] | 1 << N : this.words[I] = this.words[I] & ~(1 << N), this.strip();
    }, p.prototype.iadd = function(S) {
      var E;
      if (this.negative !== 0 && S.negative === 0)
        return this.negative = 0, E = this.isub(S), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && S.negative !== 0)
        return S.negative = 0, E = this.isub(S), S.negative = 1, E._normSign();
      var I, N;
      this.length > S.length ? (I = this, N = S) : (I = S, N = this);
      for (var $ = 0, U = 0; U < N.length; U++)
        E = (I.words[U] | 0) + (N.words[U] | 0) + $, this.words[U] = E & 67108863, $ = E >>> 26;
      for (; $ !== 0 && U < I.length; U++)
        E = (I.words[U] | 0) + $, this.words[U] = E & 67108863, $ = E >>> 26;
      if (this.length = I.length, $ !== 0)
        this.words[this.length] = $, this.length++;
      else if (I !== this)
        for (; U < I.length; U++)
          this.words[U] = I.words[U];
      return this;
    }, p.prototype.add = function(S) {
      var E;
      return S.negative !== 0 && this.negative === 0 ? (S.negative = 0, E = this.sub(S), S.negative ^= 1, E) : S.negative === 0 && this.negative !== 0 ? (this.negative = 0, E = S.sub(this), this.negative = 1, E) : this.length > S.length ? this.clone().iadd(S) : S.clone().iadd(this);
    }, p.prototype.isub = function(S) {
      if (S.negative !== 0) {
        S.negative = 0;
        var E = this.iadd(S);
        return S.negative = 1, E._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(S), this.negative = 1, this._normSign();
      var I = this.cmp(S);
      if (I === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var N, $;
      I > 0 ? (N = this, $ = S) : (N = S, $ = this);
      for (var U = 0, H = 0; H < $.length; H++)
        E = (N.words[H] | 0) - ($.words[H] | 0) + U, U = E >> 26, this.words[H] = E & 67108863;
      for (; U !== 0 && H < N.length; H++)
        E = (N.words[H] | 0) + U, U = E >> 26, this.words[H] = E & 67108863;
      if (U === 0 && H < N.length && N !== this)
        for (; H < N.length; H++)
          this.words[H] = N.words[H];
      return this.length = Math.max(this.length, H), N !== this && (this.negative = 1), this.strip();
    }, p.prototype.sub = function(S) {
      return this.clone().isub(S);
    };
    function Y(P, S, E) {
      E.negative = S.negative ^ P.negative;
      var I = P.length + S.length | 0;
      E.length = I, I = I - 1 | 0;
      var N = P.words[0] | 0, $ = S.words[0] | 0, U = N * $, H = U & 67108863, B = U / 67108864 | 0;
      E.words[0] = H;
      for (var T = 1; T < I; T++) {
        for (var D = B >>> 26, ee = B & 67108863, pe = Math.min(T, S.length - 1), Ie = Math.max(0, T - P.length + 1); Ie <= pe; Ie++) {
          var Pe = T - Ie | 0;
          N = P.words[Pe] | 0, $ = S.words[Ie] | 0, U = N * $ + ee, D += U / 67108864 | 0, ee = U & 67108863;
        }
        E.words[T] = ee | 0, B = D | 0;
      }
      return B !== 0 ? E.words[T] = B | 0 : E.length--, E.strip();
    }
    var ae = function(S, E, I) {
      var N = S.words, $ = E.words, U = I.words, H = 0, B, T, D, ee = N[0] | 0, pe = ee & 8191, Ie = ee >>> 13, Pe = N[1] | 0, he = Pe & 8191, ve = Pe >>> 13, Q = N[2] | 0, le = Q & 8191, _e = Q >>> 13, re = N[3] | 0, O = re & 8191, j = re >>> 13, ce = N[4] | 0, De = ce & 8191, Ne = ce >>> 13, Fe = N[5] | 0, Ze = Fe & 8191, qe = Fe >>> 13, gt = N[6] | 0, Xe = gt & 8191, Ge = gt >>> 13, J = N[7] | 0, ye = J & 8191, we = J >>> 13, We = N[8] | 0, Re = We & 8191, q = We >>> 13, ke = N[9] | 0, de = ke & 8191, ue = ke >>> 13, me = $[0] | 0, Oe = me & 8191, Ue = me >>> 13, ze = $[1] | 0, Ve = ze & 8191, Qe = ze >>> 13, Ke = $[2] | 0, x = Ke & 8191, se = Ke >>> 13, Ee = $[3] | 0, xe = Ee & 8191, $e = Ee >>> 13, Ye = $[4] | 0, et = Ye & 8191, dt = Ye >>> 13, St = $[5] | 0, tt = St & 8191, at = St >>> 13, wt = $[6] | 0, rt = wt & 8191, ut = wt >>> 13, kt = $[7] | 0, nt = kt & 8191, it = kt >>> 13, bt = $[8] | 0, ot = bt & 8191, ct = bt >>> 13, Ot = $[9] | 0, st = Ot & 8191, lt = Ot >>> 13;
      I.negative = S.negative ^ E.negative, I.length = 19, B = Math.imul(pe, Oe), T = Math.imul(pe, Ue), T = T + Math.imul(Ie, Oe) | 0, D = Math.imul(Ie, Ue);
      var Rt = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (Rt >>> 26) | 0, Rt &= 67108863, B = Math.imul(he, Oe), T = Math.imul(he, Ue), T = T + Math.imul(ve, Oe) | 0, D = Math.imul(ve, Ue), B = B + Math.imul(pe, Ve) | 0, T = T + Math.imul(pe, Qe) | 0, T = T + Math.imul(Ie, Ve) | 0, D = D + Math.imul(Ie, Qe) | 0;
      var Ct = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (Ct >>> 26) | 0, Ct &= 67108863, B = Math.imul(le, Oe), T = Math.imul(le, Ue), T = T + Math.imul(_e, Oe) | 0, D = Math.imul(_e, Ue), B = B + Math.imul(he, Ve) | 0, T = T + Math.imul(he, Qe) | 0, T = T + Math.imul(ve, Ve) | 0, D = D + Math.imul(ve, Qe) | 0, B = B + Math.imul(pe, x) | 0, T = T + Math.imul(pe, se) | 0, T = T + Math.imul(Ie, x) | 0, D = D + Math.imul(Ie, se) | 0;
      var Je = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, B = Math.imul(O, Oe), T = Math.imul(O, Ue), T = T + Math.imul(j, Oe) | 0, D = Math.imul(j, Ue), B = B + Math.imul(le, Ve) | 0, T = T + Math.imul(le, Qe) | 0, T = T + Math.imul(_e, Ve) | 0, D = D + Math.imul(_e, Qe) | 0, B = B + Math.imul(he, x) | 0, T = T + Math.imul(he, se) | 0, T = T + Math.imul(ve, x) | 0, D = D + Math.imul(ve, se) | 0, B = B + Math.imul(pe, xe) | 0, T = T + Math.imul(pe, $e) | 0, T = T + Math.imul(Ie, xe) | 0, D = D + Math.imul(Ie, $e) | 0;
      var He = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, B = Math.imul(De, Oe), T = Math.imul(De, Ue), T = T + Math.imul(Ne, Oe) | 0, D = Math.imul(Ne, Ue), B = B + Math.imul(O, Ve) | 0, T = T + Math.imul(O, Qe) | 0, T = T + Math.imul(j, Ve) | 0, D = D + Math.imul(j, Qe) | 0, B = B + Math.imul(le, x) | 0, T = T + Math.imul(le, se) | 0, T = T + Math.imul(_e, x) | 0, D = D + Math.imul(_e, se) | 0, B = B + Math.imul(he, xe) | 0, T = T + Math.imul(he, $e) | 0, T = T + Math.imul(ve, xe) | 0, D = D + Math.imul(ve, $e) | 0, B = B + Math.imul(pe, et) | 0, T = T + Math.imul(pe, dt) | 0, T = T + Math.imul(Ie, et) | 0, D = D + Math.imul(Ie, dt) | 0;
      var je = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, B = Math.imul(Ze, Oe), T = Math.imul(Ze, Ue), T = T + Math.imul(qe, Oe) | 0, D = Math.imul(qe, Ue), B = B + Math.imul(De, Ve) | 0, T = T + Math.imul(De, Qe) | 0, T = T + Math.imul(Ne, Ve) | 0, D = D + Math.imul(Ne, Qe) | 0, B = B + Math.imul(O, x) | 0, T = T + Math.imul(O, se) | 0, T = T + Math.imul(j, x) | 0, D = D + Math.imul(j, se) | 0, B = B + Math.imul(le, xe) | 0, T = T + Math.imul(le, $e) | 0, T = T + Math.imul(_e, xe) | 0, D = D + Math.imul(_e, $e) | 0, B = B + Math.imul(he, et) | 0, T = T + Math.imul(he, dt) | 0, T = T + Math.imul(ve, et) | 0, D = D + Math.imul(ve, dt) | 0, B = B + Math.imul(pe, tt) | 0, T = T + Math.imul(pe, at) | 0, T = T + Math.imul(Ie, tt) | 0, D = D + Math.imul(Ie, at) | 0;
      var pt = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (pt >>> 26) | 0, pt &= 67108863, B = Math.imul(Xe, Oe), T = Math.imul(Xe, Ue), T = T + Math.imul(Ge, Oe) | 0, D = Math.imul(Ge, Ue), B = B + Math.imul(Ze, Ve) | 0, T = T + Math.imul(Ze, Qe) | 0, T = T + Math.imul(qe, Ve) | 0, D = D + Math.imul(qe, Qe) | 0, B = B + Math.imul(De, x) | 0, T = T + Math.imul(De, se) | 0, T = T + Math.imul(Ne, x) | 0, D = D + Math.imul(Ne, se) | 0, B = B + Math.imul(O, xe) | 0, T = T + Math.imul(O, $e) | 0, T = T + Math.imul(j, xe) | 0, D = D + Math.imul(j, $e) | 0, B = B + Math.imul(le, et) | 0, T = T + Math.imul(le, dt) | 0, T = T + Math.imul(_e, et) | 0, D = D + Math.imul(_e, dt) | 0, B = B + Math.imul(he, tt) | 0, T = T + Math.imul(he, at) | 0, T = T + Math.imul(ve, tt) | 0, D = D + Math.imul(ve, at) | 0, B = B + Math.imul(pe, rt) | 0, T = T + Math.imul(pe, ut) | 0, T = T + Math.imul(Ie, rt) | 0, D = D + Math.imul(Ie, ut) | 0;
      var mt = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (mt >>> 26) | 0, mt &= 67108863, B = Math.imul(ye, Oe), T = Math.imul(ye, Ue), T = T + Math.imul(we, Oe) | 0, D = Math.imul(we, Ue), B = B + Math.imul(Xe, Ve) | 0, T = T + Math.imul(Xe, Qe) | 0, T = T + Math.imul(Ge, Ve) | 0, D = D + Math.imul(Ge, Qe) | 0, B = B + Math.imul(Ze, x) | 0, T = T + Math.imul(Ze, se) | 0, T = T + Math.imul(qe, x) | 0, D = D + Math.imul(qe, se) | 0, B = B + Math.imul(De, xe) | 0, T = T + Math.imul(De, $e) | 0, T = T + Math.imul(Ne, xe) | 0, D = D + Math.imul(Ne, $e) | 0, B = B + Math.imul(O, et) | 0, T = T + Math.imul(O, dt) | 0, T = T + Math.imul(j, et) | 0, D = D + Math.imul(j, dt) | 0, B = B + Math.imul(le, tt) | 0, T = T + Math.imul(le, at) | 0, T = T + Math.imul(_e, tt) | 0, D = D + Math.imul(_e, at) | 0, B = B + Math.imul(he, rt) | 0, T = T + Math.imul(he, ut) | 0, T = T + Math.imul(ve, rt) | 0, D = D + Math.imul(ve, ut) | 0, B = B + Math.imul(pe, nt) | 0, T = T + Math.imul(pe, it) | 0, T = T + Math.imul(Ie, nt) | 0, D = D + Math.imul(Ie, it) | 0;
      var yt = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (yt >>> 26) | 0, yt &= 67108863, B = Math.imul(Re, Oe), T = Math.imul(Re, Ue), T = T + Math.imul(q, Oe) | 0, D = Math.imul(q, Ue), B = B + Math.imul(ye, Ve) | 0, T = T + Math.imul(ye, Qe) | 0, T = T + Math.imul(we, Ve) | 0, D = D + Math.imul(we, Qe) | 0, B = B + Math.imul(Xe, x) | 0, T = T + Math.imul(Xe, se) | 0, T = T + Math.imul(Ge, x) | 0, D = D + Math.imul(Ge, se) | 0, B = B + Math.imul(Ze, xe) | 0, T = T + Math.imul(Ze, $e) | 0, T = T + Math.imul(qe, xe) | 0, D = D + Math.imul(qe, $e) | 0, B = B + Math.imul(De, et) | 0, T = T + Math.imul(De, dt) | 0, T = T + Math.imul(Ne, et) | 0, D = D + Math.imul(Ne, dt) | 0, B = B + Math.imul(O, tt) | 0, T = T + Math.imul(O, at) | 0, T = T + Math.imul(j, tt) | 0, D = D + Math.imul(j, at) | 0, B = B + Math.imul(le, rt) | 0, T = T + Math.imul(le, ut) | 0, T = T + Math.imul(_e, rt) | 0, D = D + Math.imul(_e, ut) | 0, B = B + Math.imul(he, nt) | 0, T = T + Math.imul(he, it) | 0, T = T + Math.imul(ve, nt) | 0, D = D + Math.imul(ve, it) | 0, B = B + Math.imul(pe, ot) | 0, T = T + Math.imul(pe, ct) | 0, T = T + Math.imul(Ie, ot) | 0, D = D + Math.imul(Ie, ct) | 0;
      var ht = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (ht >>> 26) | 0, ht &= 67108863, B = Math.imul(de, Oe), T = Math.imul(de, Ue), T = T + Math.imul(ue, Oe) | 0, D = Math.imul(ue, Ue), B = B + Math.imul(Re, Ve) | 0, T = T + Math.imul(Re, Qe) | 0, T = T + Math.imul(q, Ve) | 0, D = D + Math.imul(q, Qe) | 0, B = B + Math.imul(ye, x) | 0, T = T + Math.imul(ye, se) | 0, T = T + Math.imul(we, x) | 0, D = D + Math.imul(we, se) | 0, B = B + Math.imul(Xe, xe) | 0, T = T + Math.imul(Xe, $e) | 0, T = T + Math.imul(Ge, xe) | 0, D = D + Math.imul(Ge, $e) | 0, B = B + Math.imul(Ze, et) | 0, T = T + Math.imul(Ze, dt) | 0, T = T + Math.imul(qe, et) | 0, D = D + Math.imul(qe, dt) | 0, B = B + Math.imul(De, tt) | 0, T = T + Math.imul(De, at) | 0, T = T + Math.imul(Ne, tt) | 0, D = D + Math.imul(Ne, at) | 0, B = B + Math.imul(O, rt) | 0, T = T + Math.imul(O, ut) | 0, T = T + Math.imul(j, rt) | 0, D = D + Math.imul(j, ut) | 0, B = B + Math.imul(le, nt) | 0, T = T + Math.imul(le, it) | 0, T = T + Math.imul(_e, nt) | 0, D = D + Math.imul(_e, it) | 0, B = B + Math.imul(he, ot) | 0, T = T + Math.imul(he, ct) | 0, T = T + Math.imul(ve, ot) | 0, D = D + Math.imul(ve, ct) | 0, B = B + Math.imul(pe, st) | 0, T = T + Math.imul(pe, lt) | 0, T = T + Math.imul(Ie, st) | 0, D = D + Math.imul(Ie, lt) | 0;
      var _t = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (_t >>> 26) | 0, _t &= 67108863, B = Math.imul(de, Ve), T = Math.imul(de, Qe), T = T + Math.imul(ue, Ve) | 0, D = Math.imul(ue, Qe), B = B + Math.imul(Re, x) | 0, T = T + Math.imul(Re, se) | 0, T = T + Math.imul(q, x) | 0, D = D + Math.imul(q, se) | 0, B = B + Math.imul(ye, xe) | 0, T = T + Math.imul(ye, $e) | 0, T = T + Math.imul(we, xe) | 0, D = D + Math.imul(we, $e) | 0, B = B + Math.imul(Xe, et) | 0, T = T + Math.imul(Xe, dt) | 0, T = T + Math.imul(Ge, et) | 0, D = D + Math.imul(Ge, dt) | 0, B = B + Math.imul(Ze, tt) | 0, T = T + Math.imul(Ze, at) | 0, T = T + Math.imul(qe, tt) | 0, D = D + Math.imul(qe, at) | 0, B = B + Math.imul(De, rt) | 0, T = T + Math.imul(De, ut) | 0, T = T + Math.imul(Ne, rt) | 0, D = D + Math.imul(Ne, ut) | 0, B = B + Math.imul(O, nt) | 0, T = T + Math.imul(O, it) | 0, T = T + Math.imul(j, nt) | 0, D = D + Math.imul(j, it) | 0, B = B + Math.imul(le, ot) | 0, T = T + Math.imul(le, ct) | 0, T = T + Math.imul(_e, ot) | 0, D = D + Math.imul(_e, ct) | 0, B = B + Math.imul(he, st) | 0, T = T + Math.imul(he, lt) | 0, T = T + Math.imul(ve, st) | 0, D = D + Math.imul(ve, lt) | 0;
      var Et = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, B = Math.imul(de, x), T = Math.imul(de, se), T = T + Math.imul(ue, x) | 0, D = Math.imul(ue, se), B = B + Math.imul(Re, xe) | 0, T = T + Math.imul(Re, $e) | 0, T = T + Math.imul(q, xe) | 0, D = D + Math.imul(q, $e) | 0, B = B + Math.imul(ye, et) | 0, T = T + Math.imul(ye, dt) | 0, T = T + Math.imul(we, et) | 0, D = D + Math.imul(we, dt) | 0, B = B + Math.imul(Xe, tt) | 0, T = T + Math.imul(Xe, at) | 0, T = T + Math.imul(Ge, tt) | 0, D = D + Math.imul(Ge, at) | 0, B = B + Math.imul(Ze, rt) | 0, T = T + Math.imul(Ze, ut) | 0, T = T + Math.imul(qe, rt) | 0, D = D + Math.imul(qe, ut) | 0, B = B + Math.imul(De, nt) | 0, T = T + Math.imul(De, it) | 0, T = T + Math.imul(Ne, nt) | 0, D = D + Math.imul(Ne, it) | 0, B = B + Math.imul(O, ot) | 0, T = T + Math.imul(O, ct) | 0, T = T + Math.imul(j, ot) | 0, D = D + Math.imul(j, ct) | 0, B = B + Math.imul(le, st) | 0, T = T + Math.imul(le, lt) | 0, T = T + Math.imul(_e, st) | 0, D = D + Math.imul(_e, lt) | 0;
      var Nt = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, B = Math.imul(de, xe), T = Math.imul(de, $e), T = T + Math.imul(ue, xe) | 0, D = Math.imul(ue, $e), B = B + Math.imul(Re, et) | 0, T = T + Math.imul(Re, dt) | 0, T = T + Math.imul(q, et) | 0, D = D + Math.imul(q, dt) | 0, B = B + Math.imul(ye, tt) | 0, T = T + Math.imul(ye, at) | 0, T = T + Math.imul(we, tt) | 0, D = D + Math.imul(we, at) | 0, B = B + Math.imul(Xe, rt) | 0, T = T + Math.imul(Xe, ut) | 0, T = T + Math.imul(Ge, rt) | 0, D = D + Math.imul(Ge, ut) | 0, B = B + Math.imul(Ze, nt) | 0, T = T + Math.imul(Ze, it) | 0, T = T + Math.imul(qe, nt) | 0, D = D + Math.imul(qe, it) | 0, B = B + Math.imul(De, ot) | 0, T = T + Math.imul(De, ct) | 0, T = T + Math.imul(Ne, ot) | 0, D = D + Math.imul(Ne, ct) | 0, B = B + Math.imul(O, st) | 0, T = T + Math.imul(O, lt) | 0, T = T + Math.imul(j, st) | 0, D = D + Math.imul(j, lt) | 0;
      var Dt = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (Dt >>> 26) | 0, Dt &= 67108863, B = Math.imul(de, et), T = Math.imul(de, dt), T = T + Math.imul(ue, et) | 0, D = Math.imul(ue, dt), B = B + Math.imul(Re, tt) | 0, T = T + Math.imul(Re, at) | 0, T = T + Math.imul(q, tt) | 0, D = D + Math.imul(q, at) | 0, B = B + Math.imul(ye, rt) | 0, T = T + Math.imul(ye, ut) | 0, T = T + Math.imul(we, rt) | 0, D = D + Math.imul(we, ut) | 0, B = B + Math.imul(Xe, nt) | 0, T = T + Math.imul(Xe, it) | 0, T = T + Math.imul(Ge, nt) | 0, D = D + Math.imul(Ge, it) | 0, B = B + Math.imul(Ze, ot) | 0, T = T + Math.imul(Ze, ct) | 0, T = T + Math.imul(qe, ot) | 0, D = D + Math.imul(qe, ct) | 0, B = B + Math.imul(De, st) | 0, T = T + Math.imul(De, lt) | 0, T = T + Math.imul(Ne, st) | 0, D = D + Math.imul(Ne, lt) | 0;
      var $t = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + ($t >>> 26) | 0, $t &= 67108863, B = Math.imul(de, tt), T = Math.imul(de, at), T = T + Math.imul(ue, tt) | 0, D = Math.imul(ue, at), B = B + Math.imul(Re, rt) | 0, T = T + Math.imul(Re, ut) | 0, T = T + Math.imul(q, rt) | 0, D = D + Math.imul(q, ut) | 0, B = B + Math.imul(ye, nt) | 0, T = T + Math.imul(ye, it) | 0, T = T + Math.imul(we, nt) | 0, D = D + Math.imul(we, it) | 0, B = B + Math.imul(Xe, ot) | 0, T = T + Math.imul(Xe, ct) | 0, T = T + Math.imul(Ge, ot) | 0, D = D + Math.imul(Ge, ct) | 0, B = B + Math.imul(Ze, st) | 0, T = T + Math.imul(Ze, lt) | 0, T = T + Math.imul(qe, st) | 0, D = D + Math.imul(qe, lt) | 0;
      var At = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, B = Math.imul(de, rt), T = Math.imul(de, ut), T = T + Math.imul(ue, rt) | 0, D = Math.imul(ue, ut), B = B + Math.imul(Re, nt) | 0, T = T + Math.imul(Re, it) | 0, T = T + Math.imul(q, nt) | 0, D = D + Math.imul(q, it) | 0, B = B + Math.imul(ye, ot) | 0, T = T + Math.imul(ye, ct) | 0, T = T + Math.imul(we, ot) | 0, D = D + Math.imul(we, ct) | 0, B = B + Math.imul(Xe, st) | 0, T = T + Math.imul(Xe, lt) | 0, T = T + Math.imul(Ge, st) | 0, D = D + Math.imul(Ge, lt) | 0;
      var Lt = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (Lt >>> 26) | 0, Lt &= 67108863, B = Math.imul(de, nt), T = Math.imul(de, it), T = T + Math.imul(ue, nt) | 0, D = Math.imul(ue, it), B = B + Math.imul(Re, ot) | 0, T = T + Math.imul(Re, ct) | 0, T = T + Math.imul(q, ot) | 0, D = D + Math.imul(q, ct) | 0, B = B + Math.imul(ye, st) | 0, T = T + Math.imul(ye, lt) | 0, T = T + Math.imul(we, st) | 0, D = D + Math.imul(we, lt) | 0;
      var Bt = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, B = Math.imul(de, ot), T = Math.imul(de, ct), T = T + Math.imul(ue, ot) | 0, D = Math.imul(ue, ct), B = B + Math.imul(Re, st) | 0, T = T + Math.imul(Re, lt) | 0, T = T + Math.imul(q, st) | 0, D = D + Math.imul(q, lt) | 0;
      var Ut = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (Ut >>> 26) | 0, Ut &= 67108863, B = Math.imul(de, st), T = Math.imul(de, lt), T = T + Math.imul(ue, st) | 0, D = Math.imul(ue, lt);
      var xt = (H + B | 0) + ((T & 8191) << 13) | 0;
      return H = (D + (T >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, U[0] = Rt, U[1] = Ct, U[2] = Je, U[3] = He, U[4] = je, U[5] = pt, U[6] = mt, U[7] = yt, U[8] = ht, U[9] = _t, U[10] = Et, U[11] = Nt, U[12] = Dt, U[13] = $t, U[14] = At, U[15] = Lt, U[16] = Bt, U[17] = Ut, U[18] = xt, H !== 0 && (U[19] = H, I.length++), I;
    };
    Math.imul || (ae = Y);
    function ne(P, S, E) {
      E.negative = S.negative ^ P.negative, E.length = P.length + S.length;
      for (var I = 0, N = 0, $ = 0; $ < E.length - 1; $++) {
        var U = N;
        N = 0;
        for (var H = I & 67108863, B = Math.min($, S.length - 1), T = Math.max(0, $ - P.length + 1); T <= B; T++) {
          var D = $ - T, ee = P.words[D] | 0, pe = S.words[T] | 0, Ie = ee * pe, Pe = Ie & 67108863;
          U = U + (Ie / 67108864 | 0) | 0, Pe = Pe + H | 0, H = Pe & 67108863, U = U + (Pe >>> 26) | 0, N += U >>> 26, U &= 67108863;
        }
        E.words[$] = H, I = U, U = N;
      }
      return I !== 0 ? E.words[$] = I : E.length--, E.strip();
    }
    function fe(P, S, E) {
      var I = new ie();
      return I.mulp(P, S, E);
    }
    p.prototype.mulTo = function(S, E) {
      var I, N = this.length + S.length;
      return this.length === 10 && S.length === 10 ? I = ae(this, S, E) : N < 63 ? I = Y(this, S, E) : N < 1024 ? I = ne(this, S, E) : I = fe(this, S, E), I;
    };
    function ie(P, S) {
      this.x = P, this.y = S;
    }
    ie.prototype.makeRBT = function(S) {
      for (var E = new Array(S), I = p.prototype._countBits(S) - 1, N = 0; N < S; N++)
        E[N] = this.revBin(N, I, S);
      return E;
    }, ie.prototype.revBin = function(S, E, I) {
      if (S === 0 || S === I - 1)
        return S;
      for (var N = 0, $ = 0; $ < E; $++)
        N |= (S & 1) << E - $ - 1, S >>= 1;
      return N;
    }, ie.prototype.permute = function(S, E, I, N, $, U) {
      for (var H = 0; H < U; H++)
        N[H] = E[S[H]], $[H] = I[S[H]];
    }, ie.prototype.transform = function(S, E, I, N, $, U) {
      this.permute(U, S, E, I, N, $);
      for (var H = 1; H < $; H <<= 1)
        for (var B = H << 1, T = Math.cos(2 * Math.PI / B), D = Math.sin(2 * Math.PI / B), ee = 0; ee < $; ee += B)
          for (var pe = T, Ie = D, Pe = 0; Pe < H; Pe++) {
            var he = I[ee + Pe], ve = N[ee + Pe], Q = I[ee + Pe + H], le = N[ee + Pe + H], _e = pe * Q - Ie * le;
            le = pe * le + Ie * Q, Q = _e, I[ee + Pe] = he + Q, N[ee + Pe] = ve + le, I[ee + Pe + H] = he - Q, N[ee + Pe + H] = ve - le, Pe !== B && (_e = T * pe - D * Ie, Ie = T * Ie + D * pe, pe = _e);
          }
    }, ie.prototype.guessLen13b = function(S, E) {
      var I = Math.max(E, S) | 1, N = I & 1, $ = 0;
      for (I = I / 2 | 0; I; I = I >>> 1)
        $++;
      return 1 << $ + 1 + N;
    }, ie.prototype.conjugate = function(S, E, I) {
      if (!(I <= 1))
        for (var N = 0; N < I / 2; N++) {
          var $ = S[N];
          S[N] = S[I - N - 1], S[I - N - 1] = $, $ = E[N], E[N] = -E[I - N - 1], E[I - N - 1] = -$;
        }
    }, ie.prototype.normalize13b = function(S, E) {
      for (var I = 0, N = 0; N < E / 2; N++) {
        var $ = Math.round(S[2 * N + 1] / E) * 8192 + Math.round(S[2 * N] / E) + I;
        S[N] = $ & 67108863, $ < 67108864 ? I = 0 : I = $ / 67108864 | 0;
      }
      return S;
    }, ie.prototype.convert13b = function(S, E, I, N) {
      for (var $ = 0, U = 0; U < E; U++)
        $ = $ + (S[U] | 0), I[2 * U] = $ & 8191, $ = $ >>> 13, I[2 * U + 1] = $ & 8191, $ = $ >>> 13;
      for (U = 2 * E; U < N; ++U)
        I[U] = 0;
      l($ === 0), l(($ & -8192) === 0);
    }, ie.prototype.stub = function(S) {
      for (var E = new Array(S), I = 0; I < S; I++)
        E[I] = 0;
      return E;
    }, ie.prototype.mulp = function(S, E, I) {
      var N = 2 * this.guessLen13b(S.length, E.length), $ = this.makeRBT(N), U = this.stub(N), H = new Array(N), B = new Array(N), T = new Array(N), D = new Array(N), ee = new Array(N), pe = new Array(N), Ie = I.words;
      Ie.length = N, this.convert13b(S.words, S.length, H, N), this.convert13b(E.words, E.length, D, N), this.transform(H, U, B, T, N, $), this.transform(D, U, ee, pe, N, $);
      for (var Pe = 0; Pe < N; Pe++) {
        var he = B[Pe] * ee[Pe] - T[Pe] * pe[Pe];
        T[Pe] = B[Pe] * pe[Pe] + T[Pe] * ee[Pe], B[Pe] = he;
      }
      return this.conjugate(B, T, N), this.transform(B, T, Ie, U, N, $), this.conjugate(Ie, U, N), this.normalize13b(Ie, N), I.negative = S.negative ^ E.negative, I.length = S.length + E.length, I.strip();
    }, p.prototype.mul = function(S) {
      var E = new p(null);
      return E.words = new Array(this.length + S.length), this.mulTo(S, E);
    }, p.prototype.mulf = function(S) {
      var E = new p(null);
      return E.words = new Array(this.length + S.length), fe(this, S, E);
    }, p.prototype.imul = function(S) {
      return this.clone().mulTo(S, this);
    }, p.prototype.imuln = function(S) {
      l(typeof S == "number"), l(S < 67108864);
      for (var E = 0, I = 0; I < this.length; I++) {
        var N = (this.words[I] | 0) * S, $ = (N & 67108863) + (E & 67108863);
        E >>= 26, E += N / 67108864 | 0, E += $ >>> 26, this.words[I] = $ & 67108863;
      }
      return E !== 0 && (this.words[I] = E, this.length++), this;
    }, p.prototype.muln = function(S) {
      return this.clone().imuln(S);
    }, p.prototype.sqr = function() {
      return this.mul(this);
    }, p.prototype.isqr = function() {
      return this.imul(this.clone());
    }, p.prototype.pow = function(S) {
      var E = oe(S);
      if (E.length === 0)
        return new p(1);
      for (var I = this, N = 0; N < E.length && E[N] === 0; N++, I = I.sqr())
        ;
      if (++N < E.length)
        for (var $ = I.sqr(); N < E.length; N++, $ = $.sqr())
          E[N] !== 0 && (I = I.mul($));
      return I;
    }, p.prototype.iushln = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = S % 26, I = (S - E) / 26, N = 67108863 >>> 26 - E << 26 - E, $;
      if (E !== 0) {
        var U = 0;
        for ($ = 0; $ < this.length; $++) {
          var H = this.words[$] & N, B = (this.words[$] | 0) - H << E;
          this.words[$] = B | U, U = H >>> 26 - E;
        }
        U && (this.words[$] = U, this.length++);
      }
      if (I !== 0) {
        for ($ = this.length - 1; $ >= 0; $--)
          this.words[$ + I] = this.words[$];
        for ($ = 0; $ < I; $++)
          this.words[$] = 0;
        this.length += I;
      }
      return this.strip();
    }, p.prototype.ishln = function(S) {
      return l(this.negative === 0), this.iushln(S);
    }, p.prototype.iushrn = function(S, E, I) {
      l(typeof S == "number" && S >= 0);
      var N;
      E ? N = (E - E % 26) / 26 : N = 0;
      var $ = S % 26, U = Math.min((S - $) / 26, this.length), H = 67108863 ^ 67108863 >>> $ << $, B = I;
      if (N -= U, N = Math.max(0, N), B) {
        for (var T = 0; T < U; T++)
          B.words[T] = this.words[T];
        B.length = U;
      }
      if (U !== 0)
        if (this.length > U)
          for (this.length -= U, T = 0; T < this.length; T++)
            this.words[T] = this.words[T + U];
        else
          this.words[0] = 0, this.length = 1;
      var D = 0;
      for (T = this.length - 1; T >= 0 && (D !== 0 || T >= N); T--) {
        var ee = this.words[T] | 0;
        this.words[T] = D << 26 - $ | ee >>> $, D = ee & H;
      }
      return B && D !== 0 && (B.words[B.length++] = D), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, p.prototype.ishrn = function(S, E, I) {
      return l(this.negative === 0), this.iushrn(S, E, I);
    }, p.prototype.shln = function(S) {
      return this.clone().ishln(S);
    }, p.prototype.ushln = function(S) {
      return this.clone().iushln(S);
    }, p.prototype.shrn = function(S) {
      return this.clone().ishrn(S);
    }, p.prototype.ushrn = function(S) {
      return this.clone().iushrn(S);
    }, p.prototype.testn = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = S % 26, I = (S - E) / 26, N = 1 << E;
      if (this.length <= I)
        return !1;
      var $ = this.words[I];
      return !!($ & N);
    }, p.prototype.imaskn = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = S % 26, I = (S - E) / 26;
      if (l(this.negative === 0, "imaskn works only with positive numbers"), this.length <= I)
        return this;
      if (E !== 0 && I++, this.length = Math.min(I, this.length), E !== 0) {
        var N = 67108863 ^ 67108863 >>> E << E;
        this.words[this.length - 1] &= N;
      }
      return this.strip();
    }, p.prototype.maskn = function(S) {
      return this.clone().imaskn(S);
    }, p.prototype.iaddn = function(S) {
      return l(typeof S == "number"), l(S < 67108864), S < 0 ? this.isubn(-S) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < S ? (this.words[0] = S - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(S), this.negative = 1, this) : this._iaddn(S);
    }, p.prototype._iaddn = function(S) {
      this.words[0] += S;
      for (var E = 0; E < this.length && this.words[E] >= 67108864; E++)
        this.words[E] -= 67108864, E === this.length - 1 ? this.words[E + 1] = 1 : this.words[E + 1]++;
      return this.length = Math.max(this.length, E + 1), this;
    }, p.prototype.isubn = function(S) {
      if (l(typeof S == "number"), l(S < 67108864), S < 0)
        return this.iaddn(-S);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(S), this.negative = 1, this;
      if (this.words[0] -= S, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var E = 0; E < this.length && this.words[E] < 0; E++)
          this.words[E] += 67108864, this.words[E + 1] -= 1;
      return this.strip();
    }, p.prototype.addn = function(S) {
      return this.clone().iaddn(S);
    }, p.prototype.subn = function(S) {
      return this.clone().isubn(S);
    }, p.prototype.iabs = function() {
      return this.negative = 0, this;
    }, p.prototype.abs = function() {
      return this.clone().iabs();
    }, p.prototype._ishlnsubmul = function(S, E, I) {
      var N = S.length + I, $;
      this._expand(N);
      var U, H = 0;
      for ($ = 0; $ < S.length; $++) {
        U = (this.words[$ + I] | 0) + H;
        var B = (S.words[$] | 0) * E;
        U -= B & 67108863, H = (U >> 26) - (B / 67108864 | 0), this.words[$ + I] = U & 67108863;
      }
      for (; $ < this.length - I; $++)
        U = (this.words[$ + I] | 0) + H, H = U >> 26, this.words[$ + I] = U & 67108863;
      if (H === 0)
        return this.strip();
      for (l(H === -1), H = 0, $ = 0; $ < this.length; $++)
        U = -(this.words[$] | 0) + H, H = U >> 26, this.words[$] = U & 67108863;
      return this.negative = 1, this.strip();
    }, p.prototype._wordDiv = function(S, E) {
      var I = this.length - S.length, N = this.clone(), $ = S, U = $.words[$.length - 1] | 0, H = this._countBits(U);
      I = 26 - H, I !== 0 && ($ = $.ushln(I), N.iushln(I), U = $.words[$.length - 1] | 0);
      var B = N.length - $.length, T;
      if (E !== "mod") {
        T = new p(null), T.length = B + 1, T.words = new Array(T.length);
        for (var D = 0; D < T.length; D++)
          T.words[D] = 0;
      }
      var ee = N.clone()._ishlnsubmul($, 1, B);
      ee.negative === 0 && (N = ee, T && (T.words[B] = 1));
      for (var pe = B - 1; pe >= 0; pe--) {
        var Ie = (N.words[$.length + pe] | 0) * 67108864 + (N.words[$.length + pe - 1] | 0);
        for (Ie = Math.min(Ie / U | 0, 67108863), N._ishlnsubmul($, Ie, pe); N.negative !== 0; )
          Ie--, N.negative = 0, N._ishlnsubmul($, 1, pe), N.isZero() || (N.negative ^= 1);
        T && (T.words[pe] = Ie);
      }
      return T && T.strip(), N.strip(), E !== "div" && I !== 0 && N.iushrn(I), {
        div: T || null,
        mod: N
      };
    }, p.prototype.divmod = function(S, E, I) {
      if (l(!S.isZero()), this.isZero())
        return {
          div: new p(0),
          mod: new p(0)
        };
      var N, $, U;
      return this.negative !== 0 && S.negative === 0 ? (U = this.neg().divmod(S, E), E !== "mod" && (N = U.div.neg()), E !== "div" && ($ = U.mod.neg(), I && $.negative !== 0 && $.iadd(S)), {
        div: N,
        mod: $
      }) : this.negative === 0 && S.negative !== 0 ? (U = this.divmod(S.neg(), E), E !== "mod" && (N = U.div.neg()), {
        div: N,
        mod: U.mod
      }) : this.negative & S.negative ? (U = this.neg().divmod(S.neg(), E), E !== "div" && ($ = U.mod.neg(), I && $.negative !== 0 && $.isub(S)), {
        div: U.div,
        mod: $
      }) : S.length > this.length || this.cmp(S) < 0 ? {
        div: new p(0),
        mod: this
      } : S.length === 1 ? E === "div" ? {
        div: this.divn(S.words[0]),
        mod: null
      } : E === "mod" ? {
        div: null,
        mod: new p(this.modn(S.words[0]))
      } : {
        div: this.divn(S.words[0]),
        mod: new p(this.modn(S.words[0]))
      } : this._wordDiv(S, E);
    }, p.prototype.div = function(S) {
      return this.divmod(S, "div", !1).div;
    }, p.prototype.mod = function(S) {
      return this.divmod(S, "mod", !1).mod;
    }, p.prototype.umod = function(S) {
      return this.divmod(S, "mod", !0).mod;
    }, p.prototype.divRound = function(S) {
      var E = this.divmod(S);
      if (E.mod.isZero())
        return E.div;
      var I = E.div.negative !== 0 ? E.mod.isub(S) : E.mod, N = S.ushrn(1), $ = S.andln(1), U = I.cmp(N);
      return U < 0 || $ === 1 && U === 0 ? E.div : E.div.negative !== 0 ? E.div.isubn(1) : E.div.iaddn(1);
    }, p.prototype.modn = function(S) {
      l(S <= 67108863);
      for (var E = (1 << 26) % S, I = 0, N = this.length - 1; N >= 0; N--)
        I = (E * I + (this.words[N] | 0)) % S;
      return I;
    }, p.prototype.idivn = function(S) {
      l(S <= 67108863);
      for (var E = 0, I = this.length - 1; I >= 0; I--) {
        var N = (this.words[I] | 0) + E * 67108864;
        this.words[I] = N / S | 0, E = N % S;
      }
      return this.strip();
    }, p.prototype.divn = function(S) {
      return this.clone().idivn(S);
    }, p.prototype.egcd = function(S) {
      l(S.negative === 0), l(!S.isZero());
      var E = this, I = S.clone();
      E.negative !== 0 ? E = E.umod(S) : E = E.clone();
      for (var N = new p(1), $ = new p(0), U = new p(0), H = new p(1), B = 0; E.isEven() && I.isEven(); )
        E.iushrn(1), I.iushrn(1), ++B;
      for (var T = I.clone(), D = E.clone(); !E.isZero(); ) {
        for (var ee = 0, pe = 1; !(E.words[0] & pe) && ee < 26; ++ee, pe <<= 1)
          ;
        if (ee > 0)
          for (E.iushrn(ee); ee-- > 0; )
            (N.isOdd() || $.isOdd()) && (N.iadd(T), $.isub(D)), N.iushrn(1), $.iushrn(1);
        for (var Ie = 0, Pe = 1; !(I.words[0] & Pe) && Ie < 26; ++Ie, Pe <<= 1)
          ;
        if (Ie > 0)
          for (I.iushrn(Ie); Ie-- > 0; )
            (U.isOdd() || H.isOdd()) && (U.iadd(T), H.isub(D)), U.iushrn(1), H.iushrn(1);
        E.cmp(I) >= 0 ? (E.isub(I), N.isub(U), $.isub(H)) : (I.isub(E), U.isub(N), H.isub($));
      }
      return {
        a: U,
        b: H,
        gcd: I.iushln(B)
      };
    }, p.prototype._invmp = function(S) {
      l(S.negative === 0), l(!S.isZero());
      var E = this, I = S.clone();
      E.negative !== 0 ? E = E.umod(S) : E = E.clone();
      for (var N = new p(1), $ = new p(0), U = I.clone(); E.cmpn(1) > 0 && I.cmpn(1) > 0; ) {
        for (var H = 0, B = 1; !(E.words[0] & B) && H < 26; ++H, B <<= 1)
          ;
        if (H > 0)
          for (E.iushrn(H); H-- > 0; )
            N.isOdd() && N.iadd(U), N.iushrn(1);
        for (var T = 0, D = 1; !(I.words[0] & D) && T < 26; ++T, D <<= 1)
          ;
        if (T > 0)
          for (I.iushrn(T); T-- > 0; )
            $.isOdd() && $.iadd(U), $.iushrn(1);
        E.cmp(I) >= 0 ? (E.isub(I), N.isub($)) : (I.isub(E), $.isub(N));
      }
      var ee;
      return E.cmpn(1) === 0 ? ee = N : ee = $, ee.cmpn(0) < 0 && ee.iadd(S), ee;
    }, p.prototype.gcd = function(S) {
      if (this.isZero())
        return S.abs();
      if (S.isZero())
        return this.abs();
      var E = this.clone(), I = S.clone();
      E.negative = 0, I.negative = 0;
      for (var N = 0; E.isEven() && I.isEven(); N++)
        E.iushrn(1), I.iushrn(1);
      do {
        for (; E.isEven(); )
          E.iushrn(1);
        for (; I.isEven(); )
          I.iushrn(1);
        var $ = E.cmp(I);
        if ($ < 0) {
          var U = E;
          E = I, I = U;
        } else if ($ === 0 || I.cmpn(1) === 0)
          break;
        E.isub(I);
      } while (!0);
      return I.iushln(N);
    }, p.prototype.invm = function(S) {
      return this.egcd(S).a.umod(S);
    }, p.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, p.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, p.prototype.andln = function(S) {
      return this.words[0] & S;
    }, p.prototype.bincn = function(S) {
      l(typeof S == "number");
      var E = S % 26, I = (S - E) / 26, N = 1 << E;
      if (this.length <= I)
        return this._expand(I + 1), this.words[I] |= N, this;
      for (var $ = N, U = I; $ !== 0 && U < this.length; U++) {
        var H = this.words[U] | 0;
        H += $, $ = H >>> 26, H &= 67108863, this.words[U] = H;
      }
      return $ !== 0 && (this.words[U] = $, this.length++), this;
    }, p.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, p.prototype.cmpn = function(S) {
      var E = S < 0;
      if (this.negative !== 0 && !E)
        return -1;
      if (this.negative === 0 && E)
        return 1;
      this.strip();
      var I;
      if (this.length > 1)
        I = 1;
      else {
        E && (S = -S), l(S <= 67108863, "Number is too big");
        var N = this.words[0] | 0;
        I = N === S ? 0 : N < S ? -1 : 1;
      }
      return this.negative !== 0 ? -I | 0 : I;
    }, p.prototype.cmp = function(S) {
      if (this.negative !== 0 && S.negative === 0)
        return -1;
      if (this.negative === 0 && S.negative !== 0)
        return 1;
      var E = this.ucmp(S);
      return this.negative !== 0 ? -E | 0 : E;
    }, p.prototype.ucmp = function(S) {
      if (this.length > S.length)
        return 1;
      if (this.length < S.length)
        return -1;
      for (var E = 0, I = this.length - 1; I >= 0; I--) {
        var N = this.words[I] | 0, $ = S.words[I] | 0;
        if (N !== $) {
          N < $ ? E = -1 : N > $ && (E = 1);
          break;
        }
      }
      return E;
    }, p.prototype.gtn = function(S) {
      return this.cmpn(S) === 1;
    }, p.prototype.gt = function(S) {
      return this.cmp(S) === 1;
    }, p.prototype.gten = function(S) {
      return this.cmpn(S) >= 0;
    }, p.prototype.gte = function(S) {
      return this.cmp(S) >= 0;
    }, p.prototype.ltn = function(S) {
      return this.cmpn(S) === -1;
    }, p.prototype.lt = function(S) {
      return this.cmp(S) === -1;
    }, p.prototype.lten = function(S) {
      return this.cmpn(S) <= 0;
    }, p.prototype.lte = function(S) {
      return this.cmp(S) <= 0;
    }, p.prototype.eqn = function(S) {
      return this.cmpn(S) === 0;
    }, p.prototype.eq = function(S) {
      return this.cmp(S) === 0;
    }, p.red = function(S) {
      return new Z(S);
    }, p.prototype.toRed = function(S) {
      return l(!this.red, "Already a number in reduction context"), l(this.negative === 0, "red works only with positives"), S.convertTo(this)._forceRed(S);
    }, p.prototype.fromRed = function() {
      return l(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, p.prototype._forceRed = function(S) {
      return this.red = S, this;
    }, p.prototype.forceRed = function(S) {
      return l(!this.red, "Already a number in reduction context"), this._forceRed(S);
    }, p.prototype.redAdd = function(S) {
      return l(this.red, "redAdd works only with red numbers"), this.red.add(this, S);
    }, p.prototype.redIAdd = function(S) {
      return l(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, S);
    }, p.prototype.redSub = function(S) {
      return l(this.red, "redSub works only with red numbers"), this.red.sub(this, S);
    }, p.prototype.redISub = function(S) {
      return l(this.red, "redISub works only with red numbers"), this.red.isub(this, S);
    }, p.prototype.redShl = function(S) {
      return l(this.red, "redShl works only with red numbers"), this.red.shl(this, S);
    }, p.prototype.redMul = function(S) {
      return l(this.red, "redMul works only with red numbers"), this.red._verify2(this, S), this.red.mul(this, S);
    }, p.prototype.redIMul = function(S) {
      return l(this.red, "redMul works only with red numbers"), this.red._verify2(this, S), this.red.imul(this, S);
    }, p.prototype.redSqr = function() {
      return l(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, p.prototype.redISqr = function() {
      return l(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, p.prototype.redSqrt = function() {
      return l(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, p.prototype.redInvm = function() {
      return l(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, p.prototype.redNeg = function() {
      return l(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, p.prototype.redPow = function(S) {
      return l(this.red && !S.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, S);
    };
    var ge = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function be(P, S) {
      this.name = P, this.p = new p(S, 16), this.n = this.p.bitLength(), this.k = new p(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    be.prototype._tmp = function() {
      var S = new p(null);
      return S.words = new Array(Math.ceil(this.n / 13)), S;
    }, be.prototype.ireduce = function(S) {
      var E = S, I;
      do
        this.split(E, this.tmp), E = this.imulK(E), E = E.iadd(this.tmp), I = E.bitLength();
      while (I > this.n);
      var N = I < this.n ? -1 : E.ucmp(this.p);
      return N === 0 ? (E.words[0] = 0, E.length = 1) : N > 0 ? E.isub(this.p) : E.strip !== void 0 ? E.strip() : E._strip(), E;
    }, be.prototype.split = function(S, E) {
      S.iushrn(this.n, 0, E);
    }, be.prototype.imulK = function(S) {
      return S.imul(this.k);
    };
    function Ce() {
      be.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    v(Ce, be), Ce.prototype.split = function(S, E) {
      for (var I = 4194303, N = Math.min(S.length, 9), $ = 0; $ < N; $++)
        E.words[$] = S.words[$];
      if (E.length = N, S.length <= 9) {
        S.words[0] = 0, S.length = 1;
        return;
      }
      var U = S.words[9];
      for (E.words[E.length++] = U & I, $ = 10; $ < S.length; $++) {
        var H = S.words[$] | 0;
        S.words[$ - 10] = (H & I) << 4 | U >>> 22, U = H;
      }
      U >>>= 22, S.words[$ - 10] = U, U === 0 && S.length > 10 ? S.length -= 10 : S.length -= 9;
    }, Ce.prototype.imulK = function(S) {
      S.words[S.length] = 0, S.words[S.length + 1] = 0, S.length += 2;
      for (var E = 0, I = 0; I < S.length; I++) {
        var N = S.words[I] | 0;
        E += N * 977, S.words[I] = E & 67108863, E = N * 64 + (E / 67108864 | 0);
      }
      return S.words[S.length - 1] === 0 && (S.length--, S.words[S.length - 1] === 0 && S.length--), S;
    };
    function Me() {
      be.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    v(Me, be);
    function Be() {
      be.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    v(Be, be);
    function Ae() {
      be.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    v(Ae, be), Ae.prototype.imulK = function(S) {
      for (var E = 0, I = 0; I < S.length; I++) {
        var N = (S.words[I] | 0) * 19 + E, $ = N & 67108863;
        N >>>= 26, S.words[I] = $, E = N;
      }
      return E !== 0 && (S.words[S.length++] = E), S;
    }, p._prime = function(S) {
      if (ge[S])
        return ge[S];
      var E;
      if (S === "k256")
        E = new Ce();
      else if (S === "p224")
        E = new Me();
      else if (S === "p192")
        E = new Be();
      else if (S === "p25519")
        E = new Ae();
      else
        throw new Error("Unknown prime " + S);
      return ge[S] = E, E;
    };
    function Z(P) {
      if (typeof P == "string") {
        var S = p._prime(P);
        this.m = S.p, this.prime = S;
      } else
        l(P.gtn(1), "modulus must be greater than 1"), this.m = P, this.prime = null;
    }
    Z.prototype._verify1 = function(S) {
      l(S.negative === 0, "red works only with positives"), l(S.red, "red works only with red numbers");
    }, Z.prototype._verify2 = function(S, E) {
      l((S.negative | E.negative) === 0, "red works only with positives"), l(
        S.red && S.red === E.red,
        "red works only with red numbers"
      );
    }, Z.prototype.imod = function(S) {
      return this.prime ? this.prime.ireduce(S)._forceRed(this) : S.umod(this.m)._forceRed(this);
    }, Z.prototype.neg = function(S) {
      return S.isZero() ? S.clone() : this.m.sub(S)._forceRed(this);
    }, Z.prototype.add = function(S, E) {
      this._verify2(S, E);
      var I = S.add(E);
      return I.cmp(this.m) >= 0 && I.isub(this.m), I._forceRed(this);
    }, Z.prototype.iadd = function(S, E) {
      this._verify2(S, E);
      var I = S.iadd(E);
      return I.cmp(this.m) >= 0 && I.isub(this.m), I;
    }, Z.prototype.sub = function(S, E) {
      this._verify2(S, E);
      var I = S.sub(E);
      return I.cmpn(0) < 0 && I.iadd(this.m), I._forceRed(this);
    }, Z.prototype.isub = function(S, E) {
      this._verify2(S, E);
      var I = S.isub(E);
      return I.cmpn(0) < 0 && I.iadd(this.m), I;
    }, Z.prototype.shl = function(S, E) {
      return this._verify1(S), this.imod(S.ushln(E));
    }, Z.prototype.imul = function(S, E) {
      return this._verify2(S, E), this.imod(S.imul(E));
    }, Z.prototype.mul = function(S, E) {
      return this._verify2(S, E), this.imod(S.mul(E));
    }, Z.prototype.isqr = function(S) {
      return this.imul(S, S.clone());
    }, Z.prototype.sqr = function(S) {
      return this.mul(S, S);
    }, Z.prototype.sqrt = function(S) {
      if (S.isZero())
        return S.clone();
      var E = this.m.andln(3);
      if (l(E % 2 === 1), E === 3) {
        var I = this.m.add(new p(1)).iushrn(2);
        return this.pow(S, I);
      }
      for (var N = this.m.subn(1), $ = 0; !N.isZero() && N.andln(1) === 0; )
        $++, N.iushrn(1);
      l(!N.isZero());
      var U = new p(1).toRed(this), H = U.redNeg(), B = this.m.subn(1).iushrn(1), T = this.m.bitLength();
      for (T = new p(2 * T * T).toRed(this); this.pow(T, B).cmp(H) !== 0; )
        T.redIAdd(H);
      for (var D = this.pow(T, N), ee = this.pow(S, N.addn(1).iushrn(1)), pe = this.pow(S, N), Ie = $; pe.cmp(U) !== 0; ) {
        for (var Pe = pe, he = 0; Pe.cmp(U) !== 0; he++)
          Pe = Pe.redSqr();
        l(he < Ie);
        var ve = this.pow(D, new p(1).iushln(Ie - he - 1));
        ee = ee.redMul(ve), D = ve.redSqr(), pe = pe.redMul(D), Ie = he;
      }
      return ee;
    }, Z.prototype.invm = function(S) {
      var E = S._invmp(this.m);
      return E.negative !== 0 ? (E.negative = 0, this.imod(E).redNeg()) : this.imod(E);
    }, Z.prototype.pow = function(S, E) {
      if (E.isZero())
        return new p(1).toRed(this);
      if (E.cmpn(1) === 0)
        return S.clone();
      var I = 4, N = new Array(1 << I);
      N[0] = new p(1).toRed(this), N[1] = S;
      for (var $ = 2; $ < N.length; $++)
        N[$] = this.mul(N[$ - 1], S);
      var U = N[0], H = 0, B = 0, T = E.bitLength() % 26;
      for (T === 0 && (T = 26), $ = E.length - 1; $ >= 0; $--) {
        for (var D = E.words[$], ee = T - 1; ee >= 0; ee--) {
          var pe = D >> ee & 1;
          if (U !== N[0] && (U = this.sqr(U)), pe === 0 && H === 0) {
            B = 0;
            continue;
          }
          H <<= 1, H |= pe, B++, !(B !== I && ($ !== 0 || ee !== 0)) && (U = this.mul(U, N[H]), B = 0, H = 0);
        }
        T = 26;
      }
      return U;
    }, Z.prototype.convertTo = function(S) {
      var E = S.umod(this.m);
      return E === S ? E.clone() : E;
    }, Z.prototype.convertFrom = function(S) {
      var E = S.clone();
      return E.red = null, E;
    }, p.mont = function(S) {
      return new z(S);
    };
    function z(P) {
      Z.call(this, P), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new p(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    v(z, Z), z.prototype.convertTo = function(S) {
      return this.imod(S.ushln(this.shift));
    }, z.prototype.convertFrom = function(S) {
      var E = this.imod(S.mul(this.rinv));
      return E.red = null, E;
    }, z.prototype.imul = function(S, E) {
      if (S.isZero() || E.isZero())
        return S.words[0] = 0, S.length = 1, S;
      var I = S.imul(E), N = I.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), $ = I.isub(N).iushrn(this.shift), U = $;
      return $.cmp(this.m) >= 0 ? U = $.isub(this.m) : $.cmpn(0) < 0 && (U = $.iadd(this.m)), U._forceRed(this);
    }, z.prototype.mul = function(S, E) {
      if (S.isZero() || E.isZero())
        return new p(0)._forceRed(this);
      var I = S.mul(E), N = I.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), $ = I.isub(N).iushrn(this.shift), U = $;
      return $.cmp(this.m) >= 0 ? U = $.isub(this.m) : $.cmpn(0) < 0 && (U = $.iadd(this.m)), U._forceRed(this);
    }, z.prototype.invm = function(S) {
      var E = this.imod(S._invmp(this.m).mul(this.r2));
      return E._forceRed(this);
    };
  })(a, commonjsGlobal$1);
})(bn$1);
var bnExports$1 = bn$1.exports, browser$3, hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser)
    return browser$3;
  hasRequiredBrowser = 1;
  var a = requireElliptic(), u = bnExports$1;
  browser$3 = function(_) {
    return new l(_);
  };
  var c = {
    secp256k1: {
      name: "secp256k1",
      byteLength: 32
    },
    secp224r1: {
      name: "p224",
      byteLength: 28
    },
    prime256v1: {
      name: "p256",
      byteLength: 32
    },
    prime192v1: {
      name: "p192",
      byteLength: 24
    },
    ed25519: {
      name: "ed25519",
      byteLength: 32
    },
    secp384r1: {
      name: "p384",
      byteLength: 48
    },
    secp521r1: {
      name: "p521",
      byteLength: 66
    }
  };
  c.p224 = c.secp224r1, c.p256 = c.secp256r1 = c.prime256v1, c.p192 = c.secp192r1 = c.prime192v1, c.p384 = c.secp384r1, c.p521 = c.secp521r1;
  function l(p) {
    this.curveType = c[p], this.curveType || (this.curveType = {
      name: p
    }), this.curve = new a.ec(this.curveType.name), this.keys = void 0;
  }
  l.prototype.generateKeys = function(p, _) {
    return this.keys = this.curve.genKeyPair(), this.getPublicKey(p, _);
  }, l.prototype.computeSecret = function(p, _, k) {
    _ = _ || "utf8", Buffer$O.isBuffer(p) || (p = new Buffer$O(p, _));
    var M = this.curve.keyFromPublic(p).getPublic(), L = M.mul(this.keys.getPrivate()).getX();
    return v(L, k, this.curveType.byteLength);
  }, l.prototype.getPublicKey = function(p, _) {
    var k = this.keys.getPublic(_ === "compressed", !0);
    return _ === "hybrid" && (k[k.length - 1] % 2 ? k[0] = 7 : k[0] = 6), v(k, p);
  }, l.prototype.getPrivateKey = function(p) {
    return v(this.keys.getPrivate(), p);
  }, l.prototype.setPublicKey = function(p, _) {
    return _ = _ || "utf8", Buffer$O.isBuffer(p) || (p = new Buffer$O(p, _)), this.keys._importPublic(p), this;
  }, l.prototype.setPrivateKey = function(p, _) {
    _ = _ || "utf8", Buffer$O.isBuffer(p) || (p = new Buffer$O(p, _));
    var k = new u(p);
    return k = k.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(k), this;
  };
  function v(p, _, k) {
    Array.isArray(p) || (p = p.toArray());
    var M = new Buffer$O(p);
    if (k && M.length < k) {
      var L = new Buffer$O(k - M.length);
      L.fill(0), M = Buffer$O.concat([L, M]);
    }
    return _ ? M.toString(_) : M;
  }
  return browser$3;
}
var browser$2 = {}, createHash$2 = browser$a, Buffer$9 = safeBufferExports$3.Buffer, mgf$2 = function(a, u) {
  for (var c = Buffer$9.alloc(0), l = 0, v; c.length < u; )
    v = i2ops(l++), c = Buffer$9.concat([c, createHash$2("sha1").update(a).update(v).digest()]);
  return c.slice(0, u);
};
function i2ops(a) {
  var u = Buffer$9.allocUnsafe(4);
  return u.writeUInt32BE(a, 0), u;
}
var xor$2 = function a(u, c) {
  for (var l = u.length, v = -1; ++v < l; )
    u[v] ^= c[v];
  return u;
}, bn = { exports: {} };
bn.exports;
(function(a) {
  (function(u, c) {
    function l(P, S) {
      if (!P)
        throw new Error(S || "Assertion failed");
    }
    function v(P, S) {
      P.super_ = S;
      var E = function() {
      };
      E.prototype = S.prototype, P.prototype = new E(), P.prototype.constructor = P;
    }
    function p(P, S, E) {
      if (p.isBN(P))
        return P;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, P !== null && ((S === "le" || S === "be") && (E = S, S = 10), this._init(P || 0, S || 10, E || "be"));
    }
    typeof u == "object" ? u.exports = p : c.BN = p, p.BN = p, p.wordSize = 26;
    var _;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? _ = window.Buffer : _ = require$$0$2.Buffer;
    } catch {
    }
    p.isBN = function(S) {
      return S instanceof p ? !0 : S !== null && typeof S == "object" && S.constructor.wordSize === p.wordSize && Array.isArray(S.words);
    }, p.max = function(S, E) {
      return S.cmp(E) > 0 ? S : E;
    }, p.min = function(S, E) {
      return S.cmp(E) < 0 ? S : E;
    }, p.prototype._init = function(S, E, I) {
      if (typeof S == "number")
        return this._initNumber(S, E, I);
      if (typeof S == "object")
        return this._initArray(S, E, I);
      E === "hex" && (E = 16), l(E === (E | 0) && E >= 2 && E <= 36), S = S.toString().replace(/\s+/g, "");
      var N = 0;
      S[0] === "-" && (N++, this.negative = 1), N < S.length && (E === 16 ? this._parseHex(S, N, I) : (this._parseBase(S, E, N), I === "le" && this._initArray(this.toArray(), E, I)));
    }, p.prototype._initNumber = function(S, E, I) {
      S < 0 && (this.negative = 1, S = -S), S < 67108864 ? (this.words = [S & 67108863], this.length = 1) : S < 4503599627370496 ? (this.words = [
        S & 67108863,
        S / 67108864 & 67108863
      ], this.length = 2) : (l(S < 9007199254740992), this.words = [
        S & 67108863,
        S / 67108864 & 67108863,
        1
      ], this.length = 3), I === "le" && this._initArray(this.toArray(), E, I);
    }, p.prototype._initArray = function(S, E, I) {
      if (l(typeof S.length == "number"), S.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(S.length / 3), this.words = new Array(this.length);
      for (var N = 0; N < this.length; N++)
        this.words[N] = 0;
      var $, U, H = 0;
      if (I === "be")
        for (N = S.length - 1, $ = 0; N >= 0; N -= 3)
          U = S[N] | S[N - 1] << 8 | S[N - 2] << 16, this.words[$] |= U << H & 67108863, this.words[$ + 1] = U >>> 26 - H & 67108863, H += 24, H >= 26 && (H -= 26, $++);
      else if (I === "le")
        for (N = 0, $ = 0; N < S.length; N += 3)
          U = S[N] | S[N + 1] << 8 | S[N + 2] << 16, this.words[$] |= U << H & 67108863, this.words[$ + 1] = U >>> 26 - H & 67108863, H += 24, H >= 26 && (H -= 26, $++);
      return this.strip();
    };
    function k(P, S) {
      var E = P.charCodeAt(S);
      return E >= 65 && E <= 70 ? E - 55 : E >= 97 && E <= 102 ? E - 87 : E - 48 & 15;
    }
    function M(P, S, E) {
      var I = k(P, E);
      return E - 1 >= S && (I |= k(P, E - 1) << 4), I;
    }
    p.prototype._parseHex = function(S, E, I) {
      this.length = Math.ceil((S.length - E) / 6), this.words = new Array(this.length);
      for (var N = 0; N < this.length; N++)
        this.words[N] = 0;
      var $ = 0, U = 0, H;
      if (I === "be")
        for (N = S.length - 1; N >= E; N -= 2)
          H = M(S, E, N) << $, this.words[U] |= H & 67108863, $ >= 18 ? ($ -= 18, U += 1, this.words[U] |= H >>> 26) : $ += 8;
      else {
        var B = S.length - E;
        for (N = B % 2 === 0 ? E + 1 : E; N < S.length; N += 2)
          H = M(S, E, N) << $, this.words[U] |= H & 67108863, $ >= 18 ? ($ -= 18, U += 1, this.words[U] |= H >>> 26) : $ += 8;
      }
      this.strip();
    };
    function L(P, S, E, I) {
      for (var N = 0, $ = Math.min(P.length, E), U = S; U < $; U++) {
        var H = P.charCodeAt(U) - 48;
        N *= I, H >= 49 ? N += H - 49 + 10 : H >= 17 ? N += H - 17 + 10 : N += H;
      }
      return N;
    }
    p.prototype._parseBase = function(S, E, I) {
      this.words = [0], this.length = 1;
      for (var N = 0, $ = 1; $ <= 67108863; $ *= E)
        N++;
      N--, $ = $ / E | 0;
      for (var U = S.length - I, H = U % N, B = Math.min(U, U - H) + I, T = 0, D = I; D < B; D += N)
        T = L(S, D, D + N, E), this.imuln($), this.words[0] + T < 67108864 ? this.words[0] += T : this._iaddn(T);
      if (H !== 0) {
        var ee = 1;
        for (T = L(S, D, S.length, E), D = 0; D < H; D++)
          ee *= E;
        this.imuln(ee), this.words[0] + T < 67108864 ? this.words[0] += T : this._iaddn(T);
      }
      this.strip();
    }, p.prototype.copy = function(S) {
      S.words = new Array(this.length);
      for (var E = 0; E < this.length; E++)
        S.words[E] = this.words[E];
      S.length = this.length, S.negative = this.negative, S.red = this.red;
    }, p.prototype.clone = function() {
      var S = new p(null);
      return this.copy(S), S;
    }, p.prototype._expand = function(S) {
      for (; this.length < S; )
        this.words[this.length++] = 0;
      return this;
    }, p.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, p.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, p.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var F = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], V = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], X = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    p.prototype.toString = function(S, E) {
      S = S || 10, E = E | 0 || 1;
      var I;
      if (S === 16 || S === "hex") {
        I = "";
        for (var N = 0, $ = 0, U = 0; U < this.length; U++) {
          var H = this.words[U], B = ((H << N | $) & 16777215).toString(16);
          $ = H >>> 24 - N & 16777215, $ !== 0 || U !== this.length - 1 ? I = F[6 - B.length] + B + I : I = B + I, N += 2, N >= 26 && (N -= 26, U--);
        }
        for ($ !== 0 && (I = $.toString(16) + I); I.length % E !== 0; )
          I = "0" + I;
        return this.negative !== 0 && (I = "-" + I), I;
      }
      if (S === (S | 0) && S >= 2 && S <= 36) {
        var T = V[S], D = X[S];
        I = "";
        var ee = this.clone();
        for (ee.negative = 0; !ee.isZero(); ) {
          var pe = ee.modn(D).toString(S);
          ee = ee.idivn(D), ee.isZero() ? I = pe + I : I = F[T - pe.length] + pe + I;
        }
        for (this.isZero() && (I = "0" + I); I.length % E !== 0; )
          I = "0" + I;
        return this.negative !== 0 && (I = "-" + I), I;
      }
      l(!1, "Base should be between 2 and 36");
    }, p.prototype.toNumber = function() {
      var S = this.words[0];
      return this.length === 2 ? S += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? S += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && l(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -S : S;
    }, p.prototype.toJSON = function() {
      return this.toString(16);
    }, p.prototype.toBuffer = function(S, E) {
      return l(typeof _ < "u"), this.toArrayLike(_, S, E);
    }, p.prototype.toArray = function(S, E) {
      return this.toArrayLike(Array, S, E);
    }, p.prototype.toArrayLike = function(S, E, I) {
      var N = this.byteLength(), $ = I || Math.max(1, N);
      l(N <= $, "byte array longer than desired length"), l($ > 0, "Requested array length <= 0"), this.strip();
      var U = E === "le", H = new S($), B, T, D = this.clone();
      if (U) {
        for (T = 0; !D.isZero(); T++)
          B = D.andln(255), D.iushrn(8), H[T] = B;
        for (; T < $; T++)
          H[T] = 0;
      } else {
        for (T = 0; T < $ - N; T++)
          H[T] = 0;
        for (T = 0; !D.isZero(); T++)
          B = D.andln(255), D.iushrn(8), H[$ - T - 1] = B;
      }
      return H;
    }, Math.clz32 ? p.prototype._countBits = function(S) {
      return 32 - Math.clz32(S);
    } : p.prototype._countBits = function(S) {
      var E = S, I = 0;
      return E >= 4096 && (I += 13, E >>>= 13), E >= 64 && (I += 7, E >>>= 7), E >= 8 && (I += 4, E >>>= 4), E >= 2 && (I += 2, E >>>= 2), I + E;
    }, p.prototype._zeroBits = function(S) {
      if (S === 0)
        return 26;
      var E = S, I = 0;
      return E & 8191 || (I += 13, E >>>= 13), E & 127 || (I += 7, E >>>= 7), E & 15 || (I += 4, E >>>= 4), E & 3 || (I += 2, E >>>= 2), E & 1 || I++, I;
    }, p.prototype.bitLength = function() {
      var S = this.words[this.length - 1], E = this._countBits(S);
      return (this.length - 1) * 26 + E;
    };
    function oe(P) {
      for (var S = new Array(P.bitLength()), E = 0; E < S.length; E++) {
        var I = E / 26 | 0, N = E % 26;
        S[E] = (P.words[I] & 1 << N) >>> N;
      }
      return S;
    }
    p.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var S = 0, E = 0; E < this.length; E++) {
        var I = this._zeroBits(this.words[E]);
        if (S += I, I !== 26)
          break;
      }
      return S;
    }, p.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, p.prototype.toTwos = function(S) {
      return this.negative !== 0 ? this.abs().inotn(S).iaddn(1) : this.clone();
    }, p.prototype.fromTwos = function(S) {
      return this.testn(S - 1) ? this.notn(S).iaddn(1).ineg() : this.clone();
    }, p.prototype.isNeg = function() {
      return this.negative !== 0;
    }, p.prototype.neg = function() {
      return this.clone().ineg();
    }, p.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, p.prototype.iuor = function(S) {
      for (; this.length < S.length; )
        this.words[this.length++] = 0;
      for (var E = 0; E < S.length; E++)
        this.words[E] = this.words[E] | S.words[E];
      return this.strip();
    }, p.prototype.ior = function(S) {
      return l((this.negative | S.negative) === 0), this.iuor(S);
    }, p.prototype.or = function(S) {
      return this.length > S.length ? this.clone().ior(S) : S.clone().ior(this);
    }, p.prototype.uor = function(S) {
      return this.length > S.length ? this.clone().iuor(S) : S.clone().iuor(this);
    }, p.prototype.iuand = function(S) {
      var E;
      this.length > S.length ? E = S : E = this;
      for (var I = 0; I < E.length; I++)
        this.words[I] = this.words[I] & S.words[I];
      return this.length = E.length, this.strip();
    }, p.prototype.iand = function(S) {
      return l((this.negative | S.negative) === 0), this.iuand(S);
    }, p.prototype.and = function(S) {
      return this.length > S.length ? this.clone().iand(S) : S.clone().iand(this);
    }, p.prototype.uand = function(S) {
      return this.length > S.length ? this.clone().iuand(S) : S.clone().iuand(this);
    }, p.prototype.iuxor = function(S) {
      var E, I;
      this.length > S.length ? (E = this, I = S) : (E = S, I = this);
      for (var N = 0; N < I.length; N++)
        this.words[N] = E.words[N] ^ I.words[N];
      if (this !== E)
        for (; N < E.length; N++)
          this.words[N] = E.words[N];
      return this.length = E.length, this.strip();
    }, p.prototype.ixor = function(S) {
      return l((this.negative | S.negative) === 0), this.iuxor(S);
    }, p.prototype.xor = function(S) {
      return this.length > S.length ? this.clone().ixor(S) : S.clone().ixor(this);
    }, p.prototype.uxor = function(S) {
      return this.length > S.length ? this.clone().iuxor(S) : S.clone().iuxor(this);
    }, p.prototype.inotn = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = Math.ceil(S / 26) | 0, I = S % 26;
      this._expand(E), I > 0 && E--;
      for (var N = 0; N < E; N++)
        this.words[N] = ~this.words[N] & 67108863;
      return I > 0 && (this.words[N] = ~this.words[N] & 67108863 >> 26 - I), this.strip();
    }, p.prototype.notn = function(S) {
      return this.clone().inotn(S);
    }, p.prototype.setn = function(S, E) {
      l(typeof S == "number" && S >= 0);
      var I = S / 26 | 0, N = S % 26;
      return this._expand(I + 1), E ? this.words[I] = this.words[I] | 1 << N : this.words[I] = this.words[I] & ~(1 << N), this.strip();
    }, p.prototype.iadd = function(S) {
      var E;
      if (this.negative !== 0 && S.negative === 0)
        return this.negative = 0, E = this.isub(S), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && S.negative !== 0)
        return S.negative = 0, E = this.isub(S), S.negative = 1, E._normSign();
      var I, N;
      this.length > S.length ? (I = this, N = S) : (I = S, N = this);
      for (var $ = 0, U = 0; U < N.length; U++)
        E = (I.words[U] | 0) + (N.words[U] | 0) + $, this.words[U] = E & 67108863, $ = E >>> 26;
      for (; $ !== 0 && U < I.length; U++)
        E = (I.words[U] | 0) + $, this.words[U] = E & 67108863, $ = E >>> 26;
      if (this.length = I.length, $ !== 0)
        this.words[this.length] = $, this.length++;
      else if (I !== this)
        for (; U < I.length; U++)
          this.words[U] = I.words[U];
      return this;
    }, p.prototype.add = function(S) {
      var E;
      return S.negative !== 0 && this.negative === 0 ? (S.negative = 0, E = this.sub(S), S.negative ^= 1, E) : S.negative === 0 && this.negative !== 0 ? (this.negative = 0, E = S.sub(this), this.negative = 1, E) : this.length > S.length ? this.clone().iadd(S) : S.clone().iadd(this);
    }, p.prototype.isub = function(S) {
      if (S.negative !== 0) {
        S.negative = 0;
        var E = this.iadd(S);
        return S.negative = 1, E._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(S), this.negative = 1, this._normSign();
      var I = this.cmp(S);
      if (I === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var N, $;
      I > 0 ? (N = this, $ = S) : (N = S, $ = this);
      for (var U = 0, H = 0; H < $.length; H++)
        E = (N.words[H] | 0) - ($.words[H] | 0) + U, U = E >> 26, this.words[H] = E & 67108863;
      for (; U !== 0 && H < N.length; H++)
        E = (N.words[H] | 0) + U, U = E >> 26, this.words[H] = E & 67108863;
      if (U === 0 && H < N.length && N !== this)
        for (; H < N.length; H++)
          this.words[H] = N.words[H];
      return this.length = Math.max(this.length, H), N !== this && (this.negative = 1), this.strip();
    }, p.prototype.sub = function(S) {
      return this.clone().isub(S);
    };
    function Y(P, S, E) {
      E.negative = S.negative ^ P.negative;
      var I = P.length + S.length | 0;
      E.length = I, I = I - 1 | 0;
      var N = P.words[0] | 0, $ = S.words[0] | 0, U = N * $, H = U & 67108863, B = U / 67108864 | 0;
      E.words[0] = H;
      for (var T = 1; T < I; T++) {
        for (var D = B >>> 26, ee = B & 67108863, pe = Math.min(T, S.length - 1), Ie = Math.max(0, T - P.length + 1); Ie <= pe; Ie++) {
          var Pe = T - Ie | 0;
          N = P.words[Pe] | 0, $ = S.words[Ie] | 0, U = N * $ + ee, D += U / 67108864 | 0, ee = U & 67108863;
        }
        E.words[T] = ee | 0, B = D | 0;
      }
      return B !== 0 ? E.words[T] = B | 0 : E.length--, E.strip();
    }
    var ae = function(S, E, I) {
      var N = S.words, $ = E.words, U = I.words, H = 0, B, T, D, ee = N[0] | 0, pe = ee & 8191, Ie = ee >>> 13, Pe = N[1] | 0, he = Pe & 8191, ve = Pe >>> 13, Q = N[2] | 0, le = Q & 8191, _e = Q >>> 13, re = N[3] | 0, O = re & 8191, j = re >>> 13, ce = N[4] | 0, De = ce & 8191, Ne = ce >>> 13, Fe = N[5] | 0, Ze = Fe & 8191, qe = Fe >>> 13, gt = N[6] | 0, Xe = gt & 8191, Ge = gt >>> 13, J = N[7] | 0, ye = J & 8191, we = J >>> 13, We = N[8] | 0, Re = We & 8191, q = We >>> 13, ke = N[9] | 0, de = ke & 8191, ue = ke >>> 13, me = $[0] | 0, Oe = me & 8191, Ue = me >>> 13, ze = $[1] | 0, Ve = ze & 8191, Qe = ze >>> 13, Ke = $[2] | 0, x = Ke & 8191, se = Ke >>> 13, Ee = $[3] | 0, xe = Ee & 8191, $e = Ee >>> 13, Ye = $[4] | 0, et = Ye & 8191, dt = Ye >>> 13, St = $[5] | 0, tt = St & 8191, at = St >>> 13, wt = $[6] | 0, rt = wt & 8191, ut = wt >>> 13, kt = $[7] | 0, nt = kt & 8191, it = kt >>> 13, bt = $[8] | 0, ot = bt & 8191, ct = bt >>> 13, Ot = $[9] | 0, st = Ot & 8191, lt = Ot >>> 13;
      I.negative = S.negative ^ E.negative, I.length = 19, B = Math.imul(pe, Oe), T = Math.imul(pe, Ue), T = T + Math.imul(Ie, Oe) | 0, D = Math.imul(Ie, Ue);
      var Rt = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (Rt >>> 26) | 0, Rt &= 67108863, B = Math.imul(he, Oe), T = Math.imul(he, Ue), T = T + Math.imul(ve, Oe) | 0, D = Math.imul(ve, Ue), B = B + Math.imul(pe, Ve) | 0, T = T + Math.imul(pe, Qe) | 0, T = T + Math.imul(Ie, Ve) | 0, D = D + Math.imul(Ie, Qe) | 0;
      var Ct = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (Ct >>> 26) | 0, Ct &= 67108863, B = Math.imul(le, Oe), T = Math.imul(le, Ue), T = T + Math.imul(_e, Oe) | 0, D = Math.imul(_e, Ue), B = B + Math.imul(he, Ve) | 0, T = T + Math.imul(he, Qe) | 0, T = T + Math.imul(ve, Ve) | 0, D = D + Math.imul(ve, Qe) | 0, B = B + Math.imul(pe, x) | 0, T = T + Math.imul(pe, se) | 0, T = T + Math.imul(Ie, x) | 0, D = D + Math.imul(Ie, se) | 0;
      var Je = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, B = Math.imul(O, Oe), T = Math.imul(O, Ue), T = T + Math.imul(j, Oe) | 0, D = Math.imul(j, Ue), B = B + Math.imul(le, Ve) | 0, T = T + Math.imul(le, Qe) | 0, T = T + Math.imul(_e, Ve) | 0, D = D + Math.imul(_e, Qe) | 0, B = B + Math.imul(he, x) | 0, T = T + Math.imul(he, se) | 0, T = T + Math.imul(ve, x) | 0, D = D + Math.imul(ve, se) | 0, B = B + Math.imul(pe, xe) | 0, T = T + Math.imul(pe, $e) | 0, T = T + Math.imul(Ie, xe) | 0, D = D + Math.imul(Ie, $e) | 0;
      var He = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, B = Math.imul(De, Oe), T = Math.imul(De, Ue), T = T + Math.imul(Ne, Oe) | 0, D = Math.imul(Ne, Ue), B = B + Math.imul(O, Ve) | 0, T = T + Math.imul(O, Qe) | 0, T = T + Math.imul(j, Ve) | 0, D = D + Math.imul(j, Qe) | 0, B = B + Math.imul(le, x) | 0, T = T + Math.imul(le, se) | 0, T = T + Math.imul(_e, x) | 0, D = D + Math.imul(_e, se) | 0, B = B + Math.imul(he, xe) | 0, T = T + Math.imul(he, $e) | 0, T = T + Math.imul(ve, xe) | 0, D = D + Math.imul(ve, $e) | 0, B = B + Math.imul(pe, et) | 0, T = T + Math.imul(pe, dt) | 0, T = T + Math.imul(Ie, et) | 0, D = D + Math.imul(Ie, dt) | 0;
      var je = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, B = Math.imul(Ze, Oe), T = Math.imul(Ze, Ue), T = T + Math.imul(qe, Oe) | 0, D = Math.imul(qe, Ue), B = B + Math.imul(De, Ve) | 0, T = T + Math.imul(De, Qe) | 0, T = T + Math.imul(Ne, Ve) | 0, D = D + Math.imul(Ne, Qe) | 0, B = B + Math.imul(O, x) | 0, T = T + Math.imul(O, se) | 0, T = T + Math.imul(j, x) | 0, D = D + Math.imul(j, se) | 0, B = B + Math.imul(le, xe) | 0, T = T + Math.imul(le, $e) | 0, T = T + Math.imul(_e, xe) | 0, D = D + Math.imul(_e, $e) | 0, B = B + Math.imul(he, et) | 0, T = T + Math.imul(he, dt) | 0, T = T + Math.imul(ve, et) | 0, D = D + Math.imul(ve, dt) | 0, B = B + Math.imul(pe, tt) | 0, T = T + Math.imul(pe, at) | 0, T = T + Math.imul(Ie, tt) | 0, D = D + Math.imul(Ie, at) | 0;
      var pt = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (pt >>> 26) | 0, pt &= 67108863, B = Math.imul(Xe, Oe), T = Math.imul(Xe, Ue), T = T + Math.imul(Ge, Oe) | 0, D = Math.imul(Ge, Ue), B = B + Math.imul(Ze, Ve) | 0, T = T + Math.imul(Ze, Qe) | 0, T = T + Math.imul(qe, Ve) | 0, D = D + Math.imul(qe, Qe) | 0, B = B + Math.imul(De, x) | 0, T = T + Math.imul(De, se) | 0, T = T + Math.imul(Ne, x) | 0, D = D + Math.imul(Ne, se) | 0, B = B + Math.imul(O, xe) | 0, T = T + Math.imul(O, $e) | 0, T = T + Math.imul(j, xe) | 0, D = D + Math.imul(j, $e) | 0, B = B + Math.imul(le, et) | 0, T = T + Math.imul(le, dt) | 0, T = T + Math.imul(_e, et) | 0, D = D + Math.imul(_e, dt) | 0, B = B + Math.imul(he, tt) | 0, T = T + Math.imul(he, at) | 0, T = T + Math.imul(ve, tt) | 0, D = D + Math.imul(ve, at) | 0, B = B + Math.imul(pe, rt) | 0, T = T + Math.imul(pe, ut) | 0, T = T + Math.imul(Ie, rt) | 0, D = D + Math.imul(Ie, ut) | 0;
      var mt = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (mt >>> 26) | 0, mt &= 67108863, B = Math.imul(ye, Oe), T = Math.imul(ye, Ue), T = T + Math.imul(we, Oe) | 0, D = Math.imul(we, Ue), B = B + Math.imul(Xe, Ve) | 0, T = T + Math.imul(Xe, Qe) | 0, T = T + Math.imul(Ge, Ve) | 0, D = D + Math.imul(Ge, Qe) | 0, B = B + Math.imul(Ze, x) | 0, T = T + Math.imul(Ze, se) | 0, T = T + Math.imul(qe, x) | 0, D = D + Math.imul(qe, se) | 0, B = B + Math.imul(De, xe) | 0, T = T + Math.imul(De, $e) | 0, T = T + Math.imul(Ne, xe) | 0, D = D + Math.imul(Ne, $e) | 0, B = B + Math.imul(O, et) | 0, T = T + Math.imul(O, dt) | 0, T = T + Math.imul(j, et) | 0, D = D + Math.imul(j, dt) | 0, B = B + Math.imul(le, tt) | 0, T = T + Math.imul(le, at) | 0, T = T + Math.imul(_e, tt) | 0, D = D + Math.imul(_e, at) | 0, B = B + Math.imul(he, rt) | 0, T = T + Math.imul(he, ut) | 0, T = T + Math.imul(ve, rt) | 0, D = D + Math.imul(ve, ut) | 0, B = B + Math.imul(pe, nt) | 0, T = T + Math.imul(pe, it) | 0, T = T + Math.imul(Ie, nt) | 0, D = D + Math.imul(Ie, it) | 0;
      var yt = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (yt >>> 26) | 0, yt &= 67108863, B = Math.imul(Re, Oe), T = Math.imul(Re, Ue), T = T + Math.imul(q, Oe) | 0, D = Math.imul(q, Ue), B = B + Math.imul(ye, Ve) | 0, T = T + Math.imul(ye, Qe) | 0, T = T + Math.imul(we, Ve) | 0, D = D + Math.imul(we, Qe) | 0, B = B + Math.imul(Xe, x) | 0, T = T + Math.imul(Xe, se) | 0, T = T + Math.imul(Ge, x) | 0, D = D + Math.imul(Ge, se) | 0, B = B + Math.imul(Ze, xe) | 0, T = T + Math.imul(Ze, $e) | 0, T = T + Math.imul(qe, xe) | 0, D = D + Math.imul(qe, $e) | 0, B = B + Math.imul(De, et) | 0, T = T + Math.imul(De, dt) | 0, T = T + Math.imul(Ne, et) | 0, D = D + Math.imul(Ne, dt) | 0, B = B + Math.imul(O, tt) | 0, T = T + Math.imul(O, at) | 0, T = T + Math.imul(j, tt) | 0, D = D + Math.imul(j, at) | 0, B = B + Math.imul(le, rt) | 0, T = T + Math.imul(le, ut) | 0, T = T + Math.imul(_e, rt) | 0, D = D + Math.imul(_e, ut) | 0, B = B + Math.imul(he, nt) | 0, T = T + Math.imul(he, it) | 0, T = T + Math.imul(ve, nt) | 0, D = D + Math.imul(ve, it) | 0, B = B + Math.imul(pe, ot) | 0, T = T + Math.imul(pe, ct) | 0, T = T + Math.imul(Ie, ot) | 0, D = D + Math.imul(Ie, ct) | 0;
      var ht = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (ht >>> 26) | 0, ht &= 67108863, B = Math.imul(de, Oe), T = Math.imul(de, Ue), T = T + Math.imul(ue, Oe) | 0, D = Math.imul(ue, Ue), B = B + Math.imul(Re, Ve) | 0, T = T + Math.imul(Re, Qe) | 0, T = T + Math.imul(q, Ve) | 0, D = D + Math.imul(q, Qe) | 0, B = B + Math.imul(ye, x) | 0, T = T + Math.imul(ye, se) | 0, T = T + Math.imul(we, x) | 0, D = D + Math.imul(we, se) | 0, B = B + Math.imul(Xe, xe) | 0, T = T + Math.imul(Xe, $e) | 0, T = T + Math.imul(Ge, xe) | 0, D = D + Math.imul(Ge, $e) | 0, B = B + Math.imul(Ze, et) | 0, T = T + Math.imul(Ze, dt) | 0, T = T + Math.imul(qe, et) | 0, D = D + Math.imul(qe, dt) | 0, B = B + Math.imul(De, tt) | 0, T = T + Math.imul(De, at) | 0, T = T + Math.imul(Ne, tt) | 0, D = D + Math.imul(Ne, at) | 0, B = B + Math.imul(O, rt) | 0, T = T + Math.imul(O, ut) | 0, T = T + Math.imul(j, rt) | 0, D = D + Math.imul(j, ut) | 0, B = B + Math.imul(le, nt) | 0, T = T + Math.imul(le, it) | 0, T = T + Math.imul(_e, nt) | 0, D = D + Math.imul(_e, it) | 0, B = B + Math.imul(he, ot) | 0, T = T + Math.imul(he, ct) | 0, T = T + Math.imul(ve, ot) | 0, D = D + Math.imul(ve, ct) | 0, B = B + Math.imul(pe, st) | 0, T = T + Math.imul(pe, lt) | 0, T = T + Math.imul(Ie, st) | 0, D = D + Math.imul(Ie, lt) | 0;
      var _t = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (_t >>> 26) | 0, _t &= 67108863, B = Math.imul(de, Ve), T = Math.imul(de, Qe), T = T + Math.imul(ue, Ve) | 0, D = Math.imul(ue, Qe), B = B + Math.imul(Re, x) | 0, T = T + Math.imul(Re, se) | 0, T = T + Math.imul(q, x) | 0, D = D + Math.imul(q, se) | 0, B = B + Math.imul(ye, xe) | 0, T = T + Math.imul(ye, $e) | 0, T = T + Math.imul(we, xe) | 0, D = D + Math.imul(we, $e) | 0, B = B + Math.imul(Xe, et) | 0, T = T + Math.imul(Xe, dt) | 0, T = T + Math.imul(Ge, et) | 0, D = D + Math.imul(Ge, dt) | 0, B = B + Math.imul(Ze, tt) | 0, T = T + Math.imul(Ze, at) | 0, T = T + Math.imul(qe, tt) | 0, D = D + Math.imul(qe, at) | 0, B = B + Math.imul(De, rt) | 0, T = T + Math.imul(De, ut) | 0, T = T + Math.imul(Ne, rt) | 0, D = D + Math.imul(Ne, ut) | 0, B = B + Math.imul(O, nt) | 0, T = T + Math.imul(O, it) | 0, T = T + Math.imul(j, nt) | 0, D = D + Math.imul(j, it) | 0, B = B + Math.imul(le, ot) | 0, T = T + Math.imul(le, ct) | 0, T = T + Math.imul(_e, ot) | 0, D = D + Math.imul(_e, ct) | 0, B = B + Math.imul(he, st) | 0, T = T + Math.imul(he, lt) | 0, T = T + Math.imul(ve, st) | 0, D = D + Math.imul(ve, lt) | 0;
      var Et = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, B = Math.imul(de, x), T = Math.imul(de, se), T = T + Math.imul(ue, x) | 0, D = Math.imul(ue, se), B = B + Math.imul(Re, xe) | 0, T = T + Math.imul(Re, $e) | 0, T = T + Math.imul(q, xe) | 0, D = D + Math.imul(q, $e) | 0, B = B + Math.imul(ye, et) | 0, T = T + Math.imul(ye, dt) | 0, T = T + Math.imul(we, et) | 0, D = D + Math.imul(we, dt) | 0, B = B + Math.imul(Xe, tt) | 0, T = T + Math.imul(Xe, at) | 0, T = T + Math.imul(Ge, tt) | 0, D = D + Math.imul(Ge, at) | 0, B = B + Math.imul(Ze, rt) | 0, T = T + Math.imul(Ze, ut) | 0, T = T + Math.imul(qe, rt) | 0, D = D + Math.imul(qe, ut) | 0, B = B + Math.imul(De, nt) | 0, T = T + Math.imul(De, it) | 0, T = T + Math.imul(Ne, nt) | 0, D = D + Math.imul(Ne, it) | 0, B = B + Math.imul(O, ot) | 0, T = T + Math.imul(O, ct) | 0, T = T + Math.imul(j, ot) | 0, D = D + Math.imul(j, ct) | 0, B = B + Math.imul(le, st) | 0, T = T + Math.imul(le, lt) | 0, T = T + Math.imul(_e, st) | 0, D = D + Math.imul(_e, lt) | 0;
      var Nt = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, B = Math.imul(de, xe), T = Math.imul(de, $e), T = T + Math.imul(ue, xe) | 0, D = Math.imul(ue, $e), B = B + Math.imul(Re, et) | 0, T = T + Math.imul(Re, dt) | 0, T = T + Math.imul(q, et) | 0, D = D + Math.imul(q, dt) | 0, B = B + Math.imul(ye, tt) | 0, T = T + Math.imul(ye, at) | 0, T = T + Math.imul(we, tt) | 0, D = D + Math.imul(we, at) | 0, B = B + Math.imul(Xe, rt) | 0, T = T + Math.imul(Xe, ut) | 0, T = T + Math.imul(Ge, rt) | 0, D = D + Math.imul(Ge, ut) | 0, B = B + Math.imul(Ze, nt) | 0, T = T + Math.imul(Ze, it) | 0, T = T + Math.imul(qe, nt) | 0, D = D + Math.imul(qe, it) | 0, B = B + Math.imul(De, ot) | 0, T = T + Math.imul(De, ct) | 0, T = T + Math.imul(Ne, ot) | 0, D = D + Math.imul(Ne, ct) | 0, B = B + Math.imul(O, st) | 0, T = T + Math.imul(O, lt) | 0, T = T + Math.imul(j, st) | 0, D = D + Math.imul(j, lt) | 0;
      var Dt = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (Dt >>> 26) | 0, Dt &= 67108863, B = Math.imul(de, et), T = Math.imul(de, dt), T = T + Math.imul(ue, et) | 0, D = Math.imul(ue, dt), B = B + Math.imul(Re, tt) | 0, T = T + Math.imul(Re, at) | 0, T = T + Math.imul(q, tt) | 0, D = D + Math.imul(q, at) | 0, B = B + Math.imul(ye, rt) | 0, T = T + Math.imul(ye, ut) | 0, T = T + Math.imul(we, rt) | 0, D = D + Math.imul(we, ut) | 0, B = B + Math.imul(Xe, nt) | 0, T = T + Math.imul(Xe, it) | 0, T = T + Math.imul(Ge, nt) | 0, D = D + Math.imul(Ge, it) | 0, B = B + Math.imul(Ze, ot) | 0, T = T + Math.imul(Ze, ct) | 0, T = T + Math.imul(qe, ot) | 0, D = D + Math.imul(qe, ct) | 0, B = B + Math.imul(De, st) | 0, T = T + Math.imul(De, lt) | 0, T = T + Math.imul(Ne, st) | 0, D = D + Math.imul(Ne, lt) | 0;
      var $t = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + ($t >>> 26) | 0, $t &= 67108863, B = Math.imul(de, tt), T = Math.imul(de, at), T = T + Math.imul(ue, tt) | 0, D = Math.imul(ue, at), B = B + Math.imul(Re, rt) | 0, T = T + Math.imul(Re, ut) | 0, T = T + Math.imul(q, rt) | 0, D = D + Math.imul(q, ut) | 0, B = B + Math.imul(ye, nt) | 0, T = T + Math.imul(ye, it) | 0, T = T + Math.imul(we, nt) | 0, D = D + Math.imul(we, it) | 0, B = B + Math.imul(Xe, ot) | 0, T = T + Math.imul(Xe, ct) | 0, T = T + Math.imul(Ge, ot) | 0, D = D + Math.imul(Ge, ct) | 0, B = B + Math.imul(Ze, st) | 0, T = T + Math.imul(Ze, lt) | 0, T = T + Math.imul(qe, st) | 0, D = D + Math.imul(qe, lt) | 0;
      var At = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, B = Math.imul(de, rt), T = Math.imul(de, ut), T = T + Math.imul(ue, rt) | 0, D = Math.imul(ue, ut), B = B + Math.imul(Re, nt) | 0, T = T + Math.imul(Re, it) | 0, T = T + Math.imul(q, nt) | 0, D = D + Math.imul(q, it) | 0, B = B + Math.imul(ye, ot) | 0, T = T + Math.imul(ye, ct) | 0, T = T + Math.imul(we, ot) | 0, D = D + Math.imul(we, ct) | 0, B = B + Math.imul(Xe, st) | 0, T = T + Math.imul(Xe, lt) | 0, T = T + Math.imul(Ge, st) | 0, D = D + Math.imul(Ge, lt) | 0;
      var Lt = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (Lt >>> 26) | 0, Lt &= 67108863, B = Math.imul(de, nt), T = Math.imul(de, it), T = T + Math.imul(ue, nt) | 0, D = Math.imul(ue, it), B = B + Math.imul(Re, ot) | 0, T = T + Math.imul(Re, ct) | 0, T = T + Math.imul(q, ot) | 0, D = D + Math.imul(q, ct) | 0, B = B + Math.imul(ye, st) | 0, T = T + Math.imul(ye, lt) | 0, T = T + Math.imul(we, st) | 0, D = D + Math.imul(we, lt) | 0;
      var Bt = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, B = Math.imul(de, ot), T = Math.imul(de, ct), T = T + Math.imul(ue, ot) | 0, D = Math.imul(ue, ct), B = B + Math.imul(Re, st) | 0, T = T + Math.imul(Re, lt) | 0, T = T + Math.imul(q, st) | 0, D = D + Math.imul(q, lt) | 0;
      var Ut = (H + B | 0) + ((T & 8191) << 13) | 0;
      H = (D + (T >>> 13) | 0) + (Ut >>> 26) | 0, Ut &= 67108863, B = Math.imul(de, st), T = Math.imul(de, lt), T = T + Math.imul(ue, st) | 0, D = Math.imul(ue, lt);
      var xt = (H + B | 0) + ((T & 8191) << 13) | 0;
      return H = (D + (T >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, U[0] = Rt, U[1] = Ct, U[2] = Je, U[3] = He, U[4] = je, U[5] = pt, U[6] = mt, U[7] = yt, U[8] = ht, U[9] = _t, U[10] = Et, U[11] = Nt, U[12] = Dt, U[13] = $t, U[14] = At, U[15] = Lt, U[16] = Bt, U[17] = Ut, U[18] = xt, H !== 0 && (U[19] = H, I.length++), I;
    };
    Math.imul || (ae = Y);
    function ne(P, S, E) {
      E.negative = S.negative ^ P.negative, E.length = P.length + S.length;
      for (var I = 0, N = 0, $ = 0; $ < E.length - 1; $++) {
        var U = N;
        N = 0;
        for (var H = I & 67108863, B = Math.min($, S.length - 1), T = Math.max(0, $ - P.length + 1); T <= B; T++) {
          var D = $ - T, ee = P.words[D] | 0, pe = S.words[T] | 0, Ie = ee * pe, Pe = Ie & 67108863;
          U = U + (Ie / 67108864 | 0) | 0, Pe = Pe + H | 0, H = Pe & 67108863, U = U + (Pe >>> 26) | 0, N += U >>> 26, U &= 67108863;
        }
        E.words[$] = H, I = U, U = N;
      }
      return I !== 0 ? E.words[$] = I : E.length--, E.strip();
    }
    function fe(P, S, E) {
      var I = new ie();
      return I.mulp(P, S, E);
    }
    p.prototype.mulTo = function(S, E) {
      var I, N = this.length + S.length;
      return this.length === 10 && S.length === 10 ? I = ae(this, S, E) : N < 63 ? I = Y(this, S, E) : N < 1024 ? I = ne(this, S, E) : I = fe(this, S, E), I;
    };
    function ie(P, S) {
      this.x = P, this.y = S;
    }
    ie.prototype.makeRBT = function(S) {
      for (var E = new Array(S), I = p.prototype._countBits(S) - 1, N = 0; N < S; N++)
        E[N] = this.revBin(N, I, S);
      return E;
    }, ie.prototype.revBin = function(S, E, I) {
      if (S === 0 || S === I - 1)
        return S;
      for (var N = 0, $ = 0; $ < E; $++)
        N |= (S & 1) << E - $ - 1, S >>= 1;
      return N;
    }, ie.prototype.permute = function(S, E, I, N, $, U) {
      for (var H = 0; H < U; H++)
        N[H] = E[S[H]], $[H] = I[S[H]];
    }, ie.prototype.transform = function(S, E, I, N, $, U) {
      this.permute(U, S, E, I, N, $);
      for (var H = 1; H < $; H <<= 1)
        for (var B = H << 1, T = Math.cos(2 * Math.PI / B), D = Math.sin(2 * Math.PI / B), ee = 0; ee < $; ee += B)
          for (var pe = T, Ie = D, Pe = 0; Pe < H; Pe++) {
            var he = I[ee + Pe], ve = N[ee + Pe], Q = I[ee + Pe + H], le = N[ee + Pe + H], _e = pe * Q - Ie * le;
            le = pe * le + Ie * Q, Q = _e, I[ee + Pe] = he + Q, N[ee + Pe] = ve + le, I[ee + Pe + H] = he - Q, N[ee + Pe + H] = ve - le, Pe !== B && (_e = T * pe - D * Ie, Ie = T * Ie + D * pe, pe = _e);
          }
    }, ie.prototype.guessLen13b = function(S, E) {
      var I = Math.max(E, S) | 1, N = I & 1, $ = 0;
      for (I = I / 2 | 0; I; I = I >>> 1)
        $++;
      return 1 << $ + 1 + N;
    }, ie.prototype.conjugate = function(S, E, I) {
      if (!(I <= 1))
        for (var N = 0; N < I / 2; N++) {
          var $ = S[N];
          S[N] = S[I - N - 1], S[I - N - 1] = $, $ = E[N], E[N] = -E[I - N - 1], E[I - N - 1] = -$;
        }
    }, ie.prototype.normalize13b = function(S, E) {
      for (var I = 0, N = 0; N < E / 2; N++) {
        var $ = Math.round(S[2 * N + 1] / E) * 8192 + Math.round(S[2 * N] / E) + I;
        S[N] = $ & 67108863, $ < 67108864 ? I = 0 : I = $ / 67108864 | 0;
      }
      return S;
    }, ie.prototype.convert13b = function(S, E, I, N) {
      for (var $ = 0, U = 0; U < E; U++)
        $ = $ + (S[U] | 0), I[2 * U] = $ & 8191, $ = $ >>> 13, I[2 * U + 1] = $ & 8191, $ = $ >>> 13;
      for (U = 2 * E; U < N; ++U)
        I[U] = 0;
      l($ === 0), l(($ & -8192) === 0);
    }, ie.prototype.stub = function(S) {
      for (var E = new Array(S), I = 0; I < S; I++)
        E[I] = 0;
      return E;
    }, ie.prototype.mulp = function(S, E, I) {
      var N = 2 * this.guessLen13b(S.length, E.length), $ = this.makeRBT(N), U = this.stub(N), H = new Array(N), B = new Array(N), T = new Array(N), D = new Array(N), ee = new Array(N), pe = new Array(N), Ie = I.words;
      Ie.length = N, this.convert13b(S.words, S.length, H, N), this.convert13b(E.words, E.length, D, N), this.transform(H, U, B, T, N, $), this.transform(D, U, ee, pe, N, $);
      for (var Pe = 0; Pe < N; Pe++) {
        var he = B[Pe] * ee[Pe] - T[Pe] * pe[Pe];
        T[Pe] = B[Pe] * pe[Pe] + T[Pe] * ee[Pe], B[Pe] = he;
      }
      return this.conjugate(B, T, N), this.transform(B, T, Ie, U, N, $), this.conjugate(Ie, U, N), this.normalize13b(Ie, N), I.negative = S.negative ^ E.negative, I.length = S.length + E.length, I.strip();
    }, p.prototype.mul = function(S) {
      var E = new p(null);
      return E.words = new Array(this.length + S.length), this.mulTo(S, E);
    }, p.prototype.mulf = function(S) {
      var E = new p(null);
      return E.words = new Array(this.length + S.length), fe(this, S, E);
    }, p.prototype.imul = function(S) {
      return this.clone().mulTo(S, this);
    }, p.prototype.imuln = function(S) {
      l(typeof S == "number"), l(S < 67108864);
      for (var E = 0, I = 0; I < this.length; I++) {
        var N = (this.words[I] | 0) * S, $ = (N & 67108863) + (E & 67108863);
        E >>= 26, E += N / 67108864 | 0, E += $ >>> 26, this.words[I] = $ & 67108863;
      }
      return E !== 0 && (this.words[I] = E, this.length++), this;
    }, p.prototype.muln = function(S) {
      return this.clone().imuln(S);
    }, p.prototype.sqr = function() {
      return this.mul(this);
    }, p.prototype.isqr = function() {
      return this.imul(this.clone());
    }, p.prototype.pow = function(S) {
      var E = oe(S);
      if (E.length === 0)
        return new p(1);
      for (var I = this, N = 0; N < E.length && E[N] === 0; N++, I = I.sqr())
        ;
      if (++N < E.length)
        for (var $ = I.sqr(); N < E.length; N++, $ = $.sqr())
          E[N] !== 0 && (I = I.mul($));
      return I;
    }, p.prototype.iushln = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = S % 26, I = (S - E) / 26, N = 67108863 >>> 26 - E << 26 - E, $;
      if (E !== 0) {
        var U = 0;
        for ($ = 0; $ < this.length; $++) {
          var H = this.words[$] & N, B = (this.words[$] | 0) - H << E;
          this.words[$] = B | U, U = H >>> 26 - E;
        }
        U && (this.words[$] = U, this.length++);
      }
      if (I !== 0) {
        for ($ = this.length - 1; $ >= 0; $--)
          this.words[$ + I] = this.words[$];
        for ($ = 0; $ < I; $++)
          this.words[$] = 0;
        this.length += I;
      }
      return this.strip();
    }, p.prototype.ishln = function(S) {
      return l(this.negative === 0), this.iushln(S);
    }, p.prototype.iushrn = function(S, E, I) {
      l(typeof S == "number" && S >= 0);
      var N;
      E ? N = (E - E % 26) / 26 : N = 0;
      var $ = S % 26, U = Math.min((S - $) / 26, this.length), H = 67108863 ^ 67108863 >>> $ << $, B = I;
      if (N -= U, N = Math.max(0, N), B) {
        for (var T = 0; T < U; T++)
          B.words[T] = this.words[T];
        B.length = U;
      }
      if (U !== 0)
        if (this.length > U)
          for (this.length -= U, T = 0; T < this.length; T++)
            this.words[T] = this.words[T + U];
        else
          this.words[0] = 0, this.length = 1;
      var D = 0;
      for (T = this.length - 1; T >= 0 && (D !== 0 || T >= N); T--) {
        var ee = this.words[T] | 0;
        this.words[T] = D << 26 - $ | ee >>> $, D = ee & H;
      }
      return B && D !== 0 && (B.words[B.length++] = D), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, p.prototype.ishrn = function(S, E, I) {
      return l(this.negative === 0), this.iushrn(S, E, I);
    }, p.prototype.shln = function(S) {
      return this.clone().ishln(S);
    }, p.prototype.ushln = function(S) {
      return this.clone().iushln(S);
    }, p.prototype.shrn = function(S) {
      return this.clone().ishrn(S);
    }, p.prototype.ushrn = function(S) {
      return this.clone().iushrn(S);
    }, p.prototype.testn = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = S % 26, I = (S - E) / 26, N = 1 << E;
      if (this.length <= I)
        return !1;
      var $ = this.words[I];
      return !!($ & N);
    }, p.prototype.imaskn = function(S) {
      l(typeof S == "number" && S >= 0);
      var E = S % 26, I = (S - E) / 26;
      if (l(this.negative === 0, "imaskn works only with positive numbers"), this.length <= I)
        return this;
      if (E !== 0 && I++, this.length = Math.min(I, this.length), E !== 0) {
        var N = 67108863 ^ 67108863 >>> E << E;
        this.words[this.length - 1] &= N;
      }
      return this.strip();
    }, p.prototype.maskn = function(S) {
      return this.clone().imaskn(S);
    }, p.prototype.iaddn = function(S) {
      return l(typeof S == "number"), l(S < 67108864), S < 0 ? this.isubn(-S) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < S ? (this.words[0] = S - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(S), this.negative = 1, this) : this._iaddn(S);
    }, p.prototype._iaddn = function(S) {
      this.words[0] += S;
      for (var E = 0; E < this.length && this.words[E] >= 67108864; E++)
        this.words[E] -= 67108864, E === this.length - 1 ? this.words[E + 1] = 1 : this.words[E + 1]++;
      return this.length = Math.max(this.length, E + 1), this;
    }, p.prototype.isubn = function(S) {
      if (l(typeof S == "number"), l(S < 67108864), S < 0)
        return this.iaddn(-S);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(S), this.negative = 1, this;
      if (this.words[0] -= S, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var E = 0; E < this.length && this.words[E] < 0; E++)
          this.words[E] += 67108864, this.words[E + 1] -= 1;
      return this.strip();
    }, p.prototype.addn = function(S) {
      return this.clone().iaddn(S);
    }, p.prototype.subn = function(S) {
      return this.clone().isubn(S);
    }, p.prototype.iabs = function() {
      return this.negative = 0, this;
    }, p.prototype.abs = function() {
      return this.clone().iabs();
    }, p.prototype._ishlnsubmul = function(S, E, I) {
      var N = S.length + I, $;
      this._expand(N);
      var U, H = 0;
      for ($ = 0; $ < S.length; $++) {
        U = (this.words[$ + I] | 0) + H;
        var B = (S.words[$] | 0) * E;
        U -= B & 67108863, H = (U >> 26) - (B / 67108864 | 0), this.words[$ + I] = U & 67108863;
      }
      for (; $ < this.length - I; $++)
        U = (this.words[$ + I] | 0) + H, H = U >> 26, this.words[$ + I] = U & 67108863;
      if (H === 0)
        return this.strip();
      for (l(H === -1), H = 0, $ = 0; $ < this.length; $++)
        U = -(this.words[$] | 0) + H, H = U >> 26, this.words[$] = U & 67108863;
      return this.negative = 1, this.strip();
    }, p.prototype._wordDiv = function(S, E) {
      var I = this.length - S.length, N = this.clone(), $ = S, U = $.words[$.length - 1] | 0, H = this._countBits(U);
      I = 26 - H, I !== 0 && ($ = $.ushln(I), N.iushln(I), U = $.words[$.length - 1] | 0);
      var B = N.length - $.length, T;
      if (E !== "mod") {
        T = new p(null), T.length = B + 1, T.words = new Array(T.length);
        for (var D = 0; D < T.length; D++)
          T.words[D] = 0;
      }
      var ee = N.clone()._ishlnsubmul($, 1, B);
      ee.negative === 0 && (N = ee, T && (T.words[B] = 1));
      for (var pe = B - 1; pe >= 0; pe--) {
        var Ie = (N.words[$.length + pe] | 0) * 67108864 + (N.words[$.length + pe - 1] | 0);
        for (Ie = Math.min(Ie / U | 0, 67108863), N._ishlnsubmul($, Ie, pe); N.negative !== 0; )
          Ie--, N.negative = 0, N._ishlnsubmul($, 1, pe), N.isZero() || (N.negative ^= 1);
        T && (T.words[pe] = Ie);
      }
      return T && T.strip(), N.strip(), E !== "div" && I !== 0 && N.iushrn(I), {
        div: T || null,
        mod: N
      };
    }, p.prototype.divmod = function(S, E, I) {
      if (l(!S.isZero()), this.isZero())
        return {
          div: new p(0),
          mod: new p(0)
        };
      var N, $, U;
      return this.negative !== 0 && S.negative === 0 ? (U = this.neg().divmod(S, E), E !== "mod" && (N = U.div.neg()), E !== "div" && ($ = U.mod.neg(), I && $.negative !== 0 && $.iadd(S)), {
        div: N,
        mod: $
      }) : this.negative === 0 && S.negative !== 0 ? (U = this.divmod(S.neg(), E), E !== "mod" && (N = U.div.neg()), {
        div: N,
        mod: U.mod
      }) : this.negative & S.negative ? (U = this.neg().divmod(S.neg(), E), E !== "div" && ($ = U.mod.neg(), I && $.negative !== 0 && $.isub(S)), {
        div: U.div,
        mod: $
      }) : S.length > this.length || this.cmp(S) < 0 ? {
        div: new p(0),
        mod: this
      } : S.length === 1 ? E === "div" ? {
        div: this.divn(S.words[0]),
        mod: null
      } : E === "mod" ? {
        div: null,
        mod: new p(this.modn(S.words[0]))
      } : {
        div: this.divn(S.words[0]),
        mod: new p(this.modn(S.words[0]))
      } : this._wordDiv(S, E);
    }, p.prototype.div = function(S) {
      return this.divmod(S, "div", !1).div;
    }, p.prototype.mod = function(S) {
      return this.divmod(S, "mod", !1).mod;
    }, p.prototype.umod = function(S) {
      return this.divmod(S, "mod", !0).mod;
    }, p.prototype.divRound = function(S) {
      var E = this.divmod(S);
      if (E.mod.isZero())
        return E.div;
      var I = E.div.negative !== 0 ? E.mod.isub(S) : E.mod, N = S.ushrn(1), $ = S.andln(1), U = I.cmp(N);
      return U < 0 || $ === 1 && U === 0 ? E.div : E.div.negative !== 0 ? E.div.isubn(1) : E.div.iaddn(1);
    }, p.prototype.modn = function(S) {
      l(S <= 67108863);
      for (var E = (1 << 26) % S, I = 0, N = this.length - 1; N >= 0; N--)
        I = (E * I + (this.words[N] | 0)) % S;
      return I;
    }, p.prototype.idivn = function(S) {
      l(S <= 67108863);
      for (var E = 0, I = this.length - 1; I >= 0; I--) {
        var N = (this.words[I] | 0) + E * 67108864;
        this.words[I] = N / S | 0, E = N % S;
      }
      return this.strip();
    }, p.prototype.divn = function(S) {
      return this.clone().idivn(S);
    }, p.prototype.egcd = function(S) {
      l(S.negative === 0), l(!S.isZero());
      var E = this, I = S.clone();
      E.negative !== 0 ? E = E.umod(S) : E = E.clone();
      for (var N = new p(1), $ = new p(0), U = new p(0), H = new p(1), B = 0; E.isEven() && I.isEven(); )
        E.iushrn(1), I.iushrn(1), ++B;
      for (var T = I.clone(), D = E.clone(); !E.isZero(); ) {
        for (var ee = 0, pe = 1; !(E.words[0] & pe) && ee < 26; ++ee, pe <<= 1)
          ;
        if (ee > 0)
          for (E.iushrn(ee); ee-- > 0; )
            (N.isOdd() || $.isOdd()) && (N.iadd(T), $.isub(D)), N.iushrn(1), $.iushrn(1);
        for (var Ie = 0, Pe = 1; !(I.words[0] & Pe) && Ie < 26; ++Ie, Pe <<= 1)
          ;
        if (Ie > 0)
          for (I.iushrn(Ie); Ie-- > 0; )
            (U.isOdd() || H.isOdd()) && (U.iadd(T), H.isub(D)), U.iushrn(1), H.iushrn(1);
        E.cmp(I) >= 0 ? (E.isub(I), N.isub(U), $.isub(H)) : (I.isub(E), U.isub(N), H.isub($));
      }
      return {
        a: U,
        b: H,
        gcd: I.iushln(B)
      };
    }, p.prototype._invmp = function(S) {
      l(S.negative === 0), l(!S.isZero());
      var E = this, I = S.clone();
      E.negative !== 0 ? E = E.umod(S) : E = E.clone();
      for (var N = new p(1), $ = new p(0), U = I.clone(); E.cmpn(1) > 0 && I.cmpn(1) > 0; ) {
        for (var H = 0, B = 1; !(E.words[0] & B) && H < 26; ++H, B <<= 1)
          ;
        if (H > 0)
          for (E.iushrn(H); H-- > 0; )
            N.isOdd() && N.iadd(U), N.iushrn(1);
        for (var T = 0, D = 1; !(I.words[0] & D) && T < 26; ++T, D <<= 1)
          ;
        if (T > 0)
          for (I.iushrn(T); T-- > 0; )
            $.isOdd() && $.iadd(U), $.iushrn(1);
        E.cmp(I) >= 0 ? (E.isub(I), N.isub($)) : (I.isub(E), $.isub(N));
      }
      var ee;
      return E.cmpn(1) === 0 ? ee = N : ee = $, ee.cmpn(0) < 0 && ee.iadd(S), ee;
    }, p.prototype.gcd = function(S) {
      if (this.isZero())
        return S.abs();
      if (S.isZero())
        return this.abs();
      var E = this.clone(), I = S.clone();
      E.negative = 0, I.negative = 0;
      for (var N = 0; E.isEven() && I.isEven(); N++)
        E.iushrn(1), I.iushrn(1);
      do {
        for (; E.isEven(); )
          E.iushrn(1);
        for (; I.isEven(); )
          I.iushrn(1);
        var $ = E.cmp(I);
        if ($ < 0) {
          var U = E;
          E = I, I = U;
        } else if ($ === 0 || I.cmpn(1) === 0)
          break;
        E.isub(I);
      } while (!0);
      return I.iushln(N);
    }, p.prototype.invm = function(S) {
      return this.egcd(S).a.umod(S);
    }, p.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, p.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, p.prototype.andln = function(S) {
      return this.words[0] & S;
    }, p.prototype.bincn = function(S) {
      l(typeof S == "number");
      var E = S % 26, I = (S - E) / 26, N = 1 << E;
      if (this.length <= I)
        return this._expand(I + 1), this.words[I] |= N, this;
      for (var $ = N, U = I; $ !== 0 && U < this.length; U++) {
        var H = this.words[U] | 0;
        H += $, $ = H >>> 26, H &= 67108863, this.words[U] = H;
      }
      return $ !== 0 && (this.words[U] = $, this.length++), this;
    }, p.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, p.prototype.cmpn = function(S) {
      var E = S < 0;
      if (this.negative !== 0 && !E)
        return -1;
      if (this.negative === 0 && E)
        return 1;
      this.strip();
      var I;
      if (this.length > 1)
        I = 1;
      else {
        E && (S = -S), l(S <= 67108863, "Number is too big");
        var N = this.words[0] | 0;
        I = N === S ? 0 : N < S ? -1 : 1;
      }
      return this.negative !== 0 ? -I | 0 : I;
    }, p.prototype.cmp = function(S) {
      if (this.negative !== 0 && S.negative === 0)
        return -1;
      if (this.negative === 0 && S.negative !== 0)
        return 1;
      var E = this.ucmp(S);
      return this.negative !== 0 ? -E | 0 : E;
    }, p.prototype.ucmp = function(S) {
      if (this.length > S.length)
        return 1;
      if (this.length < S.length)
        return -1;
      for (var E = 0, I = this.length - 1; I >= 0; I--) {
        var N = this.words[I] | 0, $ = S.words[I] | 0;
        if (N !== $) {
          N < $ ? E = -1 : N > $ && (E = 1);
          break;
        }
      }
      return E;
    }, p.prototype.gtn = function(S) {
      return this.cmpn(S) === 1;
    }, p.prototype.gt = function(S) {
      return this.cmp(S) === 1;
    }, p.prototype.gten = function(S) {
      return this.cmpn(S) >= 0;
    }, p.prototype.gte = function(S) {
      return this.cmp(S) >= 0;
    }, p.prototype.ltn = function(S) {
      return this.cmpn(S) === -1;
    }, p.prototype.lt = function(S) {
      return this.cmp(S) === -1;
    }, p.prototype.lten = function(S) {
      return this.cmpn(S) <= 0;
    }, p.prototype.lte = function(S) {
      return this.cmp(S) <= 0;
    }, p.prototype.eqn = function(S) {
      return this.cmpn(S) === 0;
    }, p.prototype.eq = function(S) {
      return this.cmp(S) === 0;
    }, p.red = function(S) {
      return new Z(S);
    }, p.prototype.toRed = function(S) {
      return l(!this.red, "Already a number in reduction context"), l(this.negative === 0, "red works only with positives"), S.convertTo(this)._forceRed(S);
    }, p.prototype.fromRed = function() {
      return l(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, p.prototype._forceRed = function(S) {
      return this.red = S, this;
    }, p.prototype.forceRed = function(S) {
      return l(!this.red, "Already a number in reduction context"), this._forceRed(S);
    }, p.prototype.redAdd = function(S) {
      return l(this.red, "redAdd works only with red numbers"), this.red.add(this, S);
    }, p.prototype.redIAdd = function(S) {
      return l(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, S);
    }, p.prototype.redSub = function(S) {
      return l(this.red, "redSub works only with red numbers"), this.red.sub(this, S);
    }, p.prototype.redISub = function(S) {
      return l(this.red, "redISub works only with red numbers"), this.red.isub(this, S);
    }, p.prototype.redShl = function(S) {
      return l(this.red, "redShl works only with red numbers"), this.red.shl(this, S);
    }, p.prototype.redMul = function(S) {
      return l(this.red, "redMul works only with red numbers"), this.red._verify2(this, S), this.red.mul(this, S);
    }, p.prototype.redIMul = function(S) {
      return l(this.red, "redMul works only with red numbers"), this.red._verify2(this, S), this.red.imul(this, S);
    }, p.prototype.redSqr = function() {
      return l(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, p.prototype.redISqr = function() {
      return l(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, p.prototype.redSqrt = function() {
      return l(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, p.prototype.redInvm = function() {
      return l(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, p.prototype.redNeg = function() {
      return l(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, p.prototype.redPow = function(S) {
      return l(this.red && !S.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, S);
    };
    var ge = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function be(P, S) {
      this.name = P, this.p = new p(S, 16), this.n = this.p.bitLength(), this.k = new p(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    be.prototype._tmp = function() {
      var S = new p(null);
      return S.words = new Array(Math.ceil(this.n / 13)), S;
    }, be.prototype.ireduce = function(S) {
      var E = S, I;
      do
        this.split(E, this.tmp), E = this.imulK(E), E = E.iadd(this.tmp), I = E.bitLength();
      while (I > this.n);
      var N = I < this.n ? -1 : E.ucmp(this.p);
      return N === 0 ? (E.words[0] = 0, E.length = 1) : N > 0 ? E.isub(this.p) : E.strip !== void 0 ? E.strip() : E._strip(), E;
    }, be.prototype.split = function(S, E) {
      S.iushrn(this.n, 0, E);
    }, be.prototype.imulK = function(S) {
      return S.imul(this.k);
    };
    function Ce() {
      be.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    v(Ce, be), Ce.prototype.split = function(S, E) {
      for (var I = 4194303, N = Math.min(S.length, 9), $ = 0; $ < N; $++)
        E.words[$] = S.words[$];
      if (E.length = N, S.length <= 9) {
        S.words[0] = 0, S.length = 1;
        return;
      }
      var U = S.words[9];
      for (E.words[E.length++] = U & I, $ = 10; $ < S.length; $++) {
        var H = S.words[$] | 0;
        S.words[$ - 10] = (H & I) << 4 | U >>> 22, U = H;
      }
      U >>>= 22, S.words[$ - 10] = U, U === 0 && S.length > 10 ? S.length -= 10 : S.length -= 9;
    }, Ce.prototype.imulK = function(S) {
      S.words[S.length] = 0, S.words[S.length + 1] = 0, S.length += 2;
      for (var E = 0, I = 0; I < S.length; I++) {
        var N = S.words[I] | 0;
        E += N * 977, S.words[I] = E & 67108863, E = N * 64 + (E / 67108864 | 0);
      }
      return S.words[S.length - 1] === 0 && (S.length--, S.words[S.length - 1] === 0 && S.length--), S;
    };
    function Me() {
      be.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    v(Me, be);
    function Be() {
      be.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    v(Be, be);
    function Ae() {
      be.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    v(Ae, be), Ae.prototype.imulK = function(S) {
      for (var E = 0, I = 0; I < S.length; I++) {
        var N = (S.words[I] | 0) * 19 + E, $ = N & 67108863;
        N >>>= 26, S.words[I] = $, E = N;
      }
      return E !== 0 && (S.words[S.length++] = E), S;
    }, p._prime = function(S) {
      if (ge[S])
        return ge[S];
      var E;
      if (S === "k256")
        E = new Ce();
      else if (S === "p224")
        E = new Me();
      else if (S === "p192")
        E = new Be();
      else if (S === "p25519")
        E = new Ae();
      else
        throw new Error("Unknown prime " + S);
      return ge[S] = E, E;
    };
    function Z(P) {
      if (typeof P == "string") {
        var S = p._prime(P);
        this.m = S.p, this.prime = S;
      } else
        l(P.gtn(1), "modulus must be greater than 1"), this.m = P, this.prime = null;
    }
    Z.prototype._verify1 = function(S) {
      l(S.negative === 0, "red works only with positives"), l(S.red, "red works only with red numbers");
    }, Z.prototype._verify2 = function(S, E) {
      l((S.negative | E.negative) === 0, "red works only with positives"), l(
        S.red && S.red === E.red,
        "red works only with red numbers"
      );
    }, Z.prototype.imod = function(S) {
      return this.prime ? this.prime.ireduce(S)._forceRed(this) : S.umod(this.m)._forceRed(this);
    }, Z.prototype.neg = function(S) {
      return S.isZero() ? S.clone() : this.m.sub(S)._forceRed(this);
    }, Z.prototype.add = function(S, E) {
      this._verify2(S, E);
      var I = S.add(E);
      return I.cmp(this.m) >= 0 && I.isub(this.m), I._forceRed(this);
    }, Z.prototype.iadd = function(S, E) {
      this._verify2(S, E);
      var I = S.iadd(E);
      return I.cmp(this.m) >= 0 && I.isub(this.m), I;
    }, Z.prototype.sub = function(S, E) {
      this._verify2(S, E);
      var I = S.sub(E);
      return I.cmpn(0) < 0 && I.iadd(this.m), I._forceRed(this);
    }, Z.prototype.isub = function(S, E) {
      this._verify2(S, E);
      var I = S.isub(E);
      return I.cmpn(0) < 0 && I.iadd(this.m), I;
    }, Z.prototype.shl = function(S, E) {
      return this._verify1(S), this.imod(S.ushln(E));
    }, Z.prototype.imul = function(S, E) {
      return this._verify2(S, E), this.imod(S.imul(E));
    }, Z.prototype.mul = function(S, E) {
      return this._verify2(S, E), this.imod(S.mul(E));
    }, Z.prototype.isqr = function(S) {
      return this.imul(S, S.clone());
    }, Z.prototype.sqr = function(S) {
      return this.mul(S, S);
    }, Z.prototype.sqrt = function(S) {
      if (S.isZero())
        return S.clone();
      var E = this.m.andln(3);
      if (l(E % 2 === 1), E === 3) {
        var I = this.m.add(new p(1)).iushrn(2);
        return this.pow(S, I);
      }
      for (var N = this.m.subn(1), $ = 0; !N.isZero() && N.andln(1) === 0; )
        $++, N.iushrn(1);
      l(!N.isZero());
      var U = new p(1).toRed(this), H = U.redNeg(), B = this.m.subn(1).iushrn(1), T = this.m.bitLength();
      for (T = new p(2 * T * T).toRed(this); this.pow(T, B).cmp(H) !== 0; )
        T.redIAdd(H);
      for (var D = this.pow(T, N), ee = this.pow(S, N.addn(1).iushrn(1)), pe = this.pow(S, N), Ie = $; pe.cmp(U) !== 0; ) {
        for (var Pe = pe, he = 0; Pe.cmp(U) !== 0; he++)
          Pe = Pe.redSqr();
        l(he < Ie);
        var ve = this.pow(D, new p(1).iushln(Ie - he - 1));
        ee = ee.redMul(ve), D = ve.redSqr(), pe = pe.redMul(D), Ie = he;
      }
      return ee;
    }, Z.prototype.invm = function(S) {
      var E = S._invmp(this.m);
      return E.negative !== 0 ? (E.negative = 0, this.imod(E).redNeg()) : this.imod(E);
    }, Z.prototype.pow = function(S, E) {
      if (E.isZero())
        return new p(1).toRed(this);
      if (E.cmpn(1) === 0)
        return S.clone();
      var I = 4, N = new Array(1 << I);
      N[0] = new p(1).toRed(this), N[1] = S;
      for (var $ = 2; $ < N.length; $++)
        N[$] = this.mul(N[$ - 1], S);
      var U = N[0], H = 0, B = 0, T = E.bitLength() % 26;
      for (T === 0 && (T = 26), $ = E.length - 1; $ >= 0; $--) {
        for (var D = E.words[$], ee = T - 1; ee >= 0; ee--) {
          var pe = D >> ee & 1;
          if (U !== N[0] && (U = this.sqr(U)), pe === 0 && H === 0) {
            B = 0;
            continue;
          }
          H <<= 1, H |= pe, B++, !(B !== I && ($ !== 0 || ee !== 0)) && (U = this.mul(U, N[H]), B = 0, H = 0);
        }
        T = 26;
      }
      return U;
    }, Z.prototype.convertTo = function(S) {
      var E = S.umod(this.m);
      return E === S ? E.clone() : E;
    }, Z.prototype.convertFrom = function(S) {
      var E = S.clone();
      return E.red = null, E;
    }, p.mont = function(S) {
      return new z(S);
    };
    function z(P) {
      Z.call(this, P), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new p(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    v(z, Z), z.prototype.convertTo = function(S) {
      return this.imod(S.ushln(this.shift));
    }, z.prototype.convertFrom = function(S) {
      var E = this.imod(S.mul(this.rinv));
      return E.red = null, E;
    }, z.prototype.imul = function(S, E) {
      if (S.isZero() || E.isZero())
        return S.words[0] = 0, S.length = 1, S;
      var I = S.imul(E), N = I.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), $ = I.isub(N).iushrn(this.shift), U = $;
      return $.cmp(this.m) >= 0 ? U = $.isub(this.m) : $.cmpn(0) < 0 && (U = $.iadd(this.m)), U._forceRed(this);
    }, z.prototype.mul = function(S, E) {
      if (S.isZero() || E.isZero())
        return new p(0)._forceRed(this);
      var I = S.mul(E), N = I.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), $ = I.isub(N).iushrn(this.shift), U = $;
      return $.cmp(this.m) >= 0 ? U = $.isub(this.m) : $.cmpn(0) < 0 && (U = $.iadd(this.m)), U._forceRed(this);
    }, z.prototype.invm = function(S) {
      var E = this.imod(S._invmp(this.m).mul(this.r2));
      return E._forceRed(this);
    };
  })(a, commonjsGlobal$1);
})(bn);
var bnExports = bn.exports, BN$2 = bnExports, Buffer$8 = safeBufferExports$3.Buffer;
function withPublic$2(a, u) {
  return Buffer$8.from(a.toRed(BN$2.mont(u.modulus)).redPow(new BN$2(u.publicExponent)).fromRed().toArray());
}
var withPublic_1 = withPublic$2, parseKeys$1 = parseAsn1, randomBytes = browserExports, createHash$1 = browser$a, mgf$1 = mgf$2, xor$1 = xor$2, BN$1 = bnExports, withPublic$1 = withPublic_1, crt$1 = browserifyRsa, Buffer$7 = safeBufferExports$3.Buffer, publicEncrypt = function a(u, c, l) {
  var v;
  u.padding ? v = u.padding : l ? v = 1 : v = 4;
  var p = parseKeys$1(u), _;
  if (v === 4)
    _ = oaep$1(p, c);
  else if (v === 1)
    _ = pkcs1$1(p, c, l);
  else if (v === 3) {
    if (_ = new BN$1(c), _.cmp(p.modulus) >= 0)
      throw new Error("data too long for modulus");
  } else
    throw new Error("unknown padding");
  return l ? crt$1(_, p) : withPublic$1(_, p);
};
function oaep$1(a, u) {
  var c = a.modulus.byteLength(), l = u.length, v = createHash$1("sha1").update(Buffer$7.alloc(0)).digest(), p = v.length, _ = 2 * p;
  if (l > c - _ - 2)
    throw new Error("message too long");
  var k = Buffer$7.alloc(c - l - _ - 2), M = c - p - 1, L = randomBytes(p), F = xor$1(Buffer$7.concat([v, k, Buffer$7.alloc(1, 1), u], M), mgf$1(L, M)), V = xor$1(L, mgf$1(F, p));
  return new BN$1(Buffer$7.concat([Buffer$7.alloc(1), V, F], c));
}
function pkcs1$1(a, u, c) {
  var l = u.length, v = a.modulus.byteLength();
  if (l > v - 11)
    throw new Error("message too long");
  var p;
  return c ? p = Buffer$7.alloc(v - l - 3, 255) : p = nonZero(v - l - 3), new BN$1(Buffer$7.concat([Buffer$7.from([0, c ? 1 : 2]), p, Buffer$7.alloc(1), u], v));
}
function nonZero(a) {
  for (var u = Buffer$7.allocUnsafe(a), c = 0, l = randomBytes(a * 2), v = 0, p; c < a; )
    v === l.length && (l = randomBytes(a * 2), v = 0), p = l[v++], p && (u[c++] = p);
  return u;
}
var parseKeys = parseAsn1, mgf = mgf$2, xor = xor$2, BN = bnExports, crt = browserifyRsa, createHash = browser$a, withPublic = withPublic_1, Buffer$6 = safeBufferExports$3.Buffer, privateDecrypt = function a(u, c, l) {
  var v;
  u.padding ? v = u.padding : l ? v = 1 : v = 4;
  var p = parseKeys(u), _ = p.modulus.byteLength();
  if (c.length > _ || new BN(c).cmp(p.modulus) >= 0)
    throw new Error("decryption error");
  var k;
  l ? k = withPublic(new BN(c), p) : k = crt(c, p);
  var M = Buffer$6.alloc(_ - k.length);
  if (k = Buffer$6.concat([M, k], _), v === 4)
    return oaep(p, k);
  if (v === 1)
    return pkcs1(p, k, l);
  if (v === 3)
    return k;
  throw new Error("unknown padding");
};
function oaep(a, u) {
  var c = a.modulus.byteLength(), l = createHash("sha1").update(Buffer$6.alloc(0)).digest(), v = l.length;
  if (u[0] !== 0)
    throw new Error("decryption error");
  var p = u.slice(1, v + 1), _ = u.slice(v + 1), k = xor(p, mgf(_, v)), M = xor(_, mgf(k, c - v - 1));
  if (compare(l, M.slice(0, v)))
    throw new Error("decryption error");
  for (var L = v; M[L] === 0; )
    L++;
  if (M[L++] !== 1)
    throw new Error("decryption error");
  return M.slice(L);
}
function pkcs1(a, u, c) {
  for (var l = u.slice(0, 2), v = 2, p = 0; u[v++] !== 0; )
    if (v >= u.length) {
      p++;
      break;
    }
  var _ = u.slice(2, v - 1);
  if ((l.toString("hex") !== "0002" && !c || l.toString("hex") !== "0001" && c) && p++, _.length < 8 && p++, p)
    throw new Error("decryption error");
  return u.slice(v);
}
function compare(a, u) {
  a = Buffer$6.from(a), u = Buffer$6.from(u);
  var c = 0, l = a.length;
  a.length !== u.length && (c++, l = Math.min(a.length, u.length));
  for (var v = -1; ++v < l; )
    c += a[v] ^ u[v];
  return c;
}
(function(a) {
  a.publicEncrypt = publicEncrypt, a.privateDecrypt = privateDecrypt, a.privateEncrypt = function(c, l) {
    return a.publicEncrypt(c, l, !0);
  }, a.publicDecrypt = function(c, l) {
    return a.privateDecrypt(c, l, !0);
  };
})(browser$2);
var browser$1 = {};
function oldBrowser() {
  throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`);
}
var safeBuffer = safeBufferExports$3, randombytes = browserExports, Buffer$5 = safeBuffer.Buffer, kBufferMaxLength = safeBuffer.kMaxLength, crypto$2 = commonjsGlobal$1.crypto || commonjsGlobal$1.msCrypto, kMaxUint32 = Math.pow(2, 32) - 1;
function assertOffset(a, u) {
  if (typeof a != "number" || a !== a)
    throw new TypeError("offset must be a number");
  if (a > kMaxUint32 || a < 0)
    throw new TypeError("offset must be a uint32");
  if (a > kBufferMaxLength || a > u)
    throw new RangeError("offset out of range");
}
function assertSize(a, u, c) {
  if (typeof a != "number" || a !== a)
    throw new TypeError("size must be a number");
  if (a > kMaxUint32 || a < 0)
    throw new TypeError("size must be a uint32");
  if (a + u > c || a > kBufferMaxLength)
    throw new RangeError("buffer too small");
}
crypto$2 && crypto$2.getRandomValues || !process$1.browser ? (browser$1.randomFill = randomFill, browser$1.randomFillSync = randomFillSync) : (browser$1.randomFill = oldBrowser, browser$1.randomFillSync = oldBrowser);
function randomFill(a, u, c, l) {
  if (!Buffer$5.isBuffer(a) && !(a instanceof commonjsGlobal$1.Uint8Array))
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
  if (typeof u == "function")
    l = u, u = 0, c = a.length;
  else if (typeof c == "function")
    l = c, c = a.length - u;
  else if (typeof l != "function")
    throw new TypeError('"cb" argument must be a function');
  return assertOffset(u, a.length), assertSize(c, u, a.length), actualFill(a, u, c, l);
}
function actualFill(a, u, c, l) {
  if (process$1.browser) {
    var v = a.buffer, p = new Uint8Array(v, u, c);
    if (crypto$2.getRandomValues(p), l) {
      process$1.nextTick(function() {
        l(null, a);
      });
      return;
    }
    return a;
  }
  if (l) {
    randombytes(c, function(k, M) {
      if (k)
        return l(k);
      M.copy(a, u), l(null, a);
    });
    return;
  }
  var _ = randombytes(c);
  return _.copy(a, u), a;
}
function randomFillSync(a, u, c) {
  if (typeof u > "u" && (u = 0), !Buffer$5.isBuffer(a) && !(a instanceof commonjsGlobal$1.Uint8Array))
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
  return assertOffset(u, a.length), c === void 0 && (c = a.length - u), assertSize(c, u, a.length), actualFill(a, u, c);
}
var hasRequiredCryptoBrowserify;
function requireCryptoBrowserify() {
  if (hasRequiredCryptoBrowserify)
    return cryptoBrowserify;
  hasRequiredCryptoBrowserify = 1, cryptoBrowserify.randomBytes = cryptoBrowserify.rng = cryptoBrowserify.pseudoRandomBytes = cryptoBrowserify.prng = browserExports, cryptoBrowserify.createHash = cryptoBrowserify.Hash = browser$a, cryptoBrowserify.createHmac = cryptoBrowserify.Hmac = browser$9;
  var a = algos, u = Object.keys(a), c = ["sha1", "sha224", "sha256", "sha384", "sha512", "md5", "rmd160"].concat(u);
  cryptoBrowserify.getHashes = function() {
    return c;
  };
  var l = browser$8;
  cryptoBrowserify.pbkdf2 = l.pbkdf2, cryptoBrowserify.pbkdf2Sync = l.pbkdf2Sync;
  var v = browser$7;
  cryptoBrowserify.Cipher = v.Cipher, cryptoBrowserify.createCipher = v.createCipher, cryptoBrowserify.Cipheriv = v.Cipheriv, cryptoBrowserify.createCipheriv = v.createCipheriv, cryptoBrowserify.Decipher = v.Decipher, cryptoBrowserify.createDecipher = v.createDecipher, cryptoBrowserify.Decipheriv = v.Decipheriv, cryptoBrowserify.createDecipheriv = v.createDecipheriv, cryptoBrowserify.getCiphers = v.getCiphers, cryptoBrowserify.listCiphers = v.listCiphers;
  var p = requireBrowser$2();
  cryptoBrowserify.DiffieHellmanGroup = p.DiffieHellmanGroup, cryptoBrowserify.createDiffieHellmanGroup = p.createDiffieHellmanGroup, cryptoBrowserify.getDiffieHellman = p.getDiffieHellman, cryptoBrowserify.createDiffieHellman = p.createDiffieHellman, cryptoBrowserify.DiffieHellman = p.DiffieHellman;
  var _ = requireBrowser$1();
  cryptoBrowserify.createSign = _.createSign, cryptoBrowserify.Sign = _.Sign, cryptoBrowserify.createVerify = _.createVerify, cryptoBrowserify.Verify = _.Verify, cryptoBrowserify.createECDH = requireBrowser();
  var k = browser$2;
  cryptoBrowserify.publicEncrypt = k.publicEncrypt, cryptoBrowserify.privateEncrypt = k.privateEncrypt, cryptoBrowserify.publicDecrypt = k.publicDecrypt, cryptoBrowserify.privateDecrypt = k.privateDecrypt;
  var M = browser$1;
  return cryptoBrowserify.randomFill = M.randomFill, cryptoBrowserify.randomFillSync = M.randomFillSync, cryptoBrowserify.createCredentials = function() {
    throw new Error([
      "sorry, createCredentials is not implemented yet",
      "we accept pull requests",
      "https://github.com/crypto-browserify/crypto-browserify"
    ].join(`
`));
  }, cryptoBrowserify.constants = {
    DH_CHECK_P_NOT_SAFE_PRIME: 2,
    DH_CHECK_P_NOT_PRIME: 1,
    DH_UNABLE_TO_CHECK_GENERATOR: 4,
    DH_NOT_SUITABLE_GENERATOR: 8,
    NPN_ENABLED: 1,
    ALPN_ENABLED: 1,
    RSA_PKCS1_PADDING: 1,
    RSA_SSLV23_PADDING: 2,
    RSA_NO_PADDING: 3,
    RSA_PKCS1_OAEP_PADDING: 4,
    RSA_X931_PADDING: 5,
    RSA_PKCS1_PSS_PADDING: 6,
    POINT_CONVERSION_COMPRESSED: 2,
    POINT_CONVERSION_UNCOMPRESSED: 4,
    POINT_CONVERSION_HYBRID: 6
  }, cryptoBrowserify;
}
function getParamSize(a) {
  var u = (a / 8 | 0) + (a % 8 === 0 ? 0 : 1);
  return u;
}
var paramBytesForAlg = {
  ES256: getParamSize(256),
  ES384: getParamSize(384),
  ES512: getParamSize(521)
};
function getParamBytesForAlg$1(a) {
  var u = paramBytesForAlg[a];
  if (u)
    return u;
  throw new Error('Unknown algorithm "' + a + '"');
}
var paramBytesForAlg_1 = getParamBytesForAlg$1, Buffer$4 = safeBufferExports$3.Buffer, getParamBytesForAlg = paramBytesForAlg_1, MAX_OCTET = 128, CLASS_UNIVERSAL = 0, PRIMITIVE_BIT = 32, TAG_SEQ = 16, TAG_INT = 2, ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | CLASS_UNIVERSAL << 6, ENCODED_TAG_INT = TAG_INT | CLASS_UNIVERSAL << 6;
function base64Url(a) {
  return a.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function signatureAsBuffer(a) {
  if (Buffer$4.isBuffer(a))
    return a;
  if (typeof a == "string")
    return Buffer$4.from(a, "base64");
  throw new TypeError("ECDSA signature must be a Base64 string or a Buffer");
}
function derToJose(a, u) {
  a = signatureAsBuffer(a);
  var c = getParamBytesForAlg(u), l = c + 1, v = a.length, p = 0;
  if (a[p++] !== ENCODED_TAG_SEQ)
    throw new Error('Could not find expected "seq"');
  var _ = a[p++];
  if (_ === (MAX_OCTET | 1) && (_ = a[p++]), v - p < _)
    throw new Error('"seq" specified length of "' + _ + '", only "' + (v - p) + '" remaining');
  if (a[p++] !== ENCODED_TAG_INT)
    throw new Error('Could not find expected "int" for "r"');
  var k = a[p++];
  if (v - p - 2 < k)
    throw new Error('"r" specified length of "' + k + '", only "' + (v - p - 2) + '" available');
  if (l < k)
    throw new Error('"r" specified length of "' + k + '", max of "' + l + '" is acceptable');
  var M = p;
  if (p += k, a[p++] !== ENCODED_TAG_INT)
    throw new Error('Could not find expected "int" for "s"');
  var L = a[p++];
  if (v - p !== L)
    throw new Error('"s" specified length of "' + L + '", expected "' + (v - p) + '"');
  if (l < L)
    throw new Error('"s" specified length of "' + L + '", max of "' + l + '" is acceptable');
  var F = p;
  if (p += L, p !== v)
    throw new Error('Expected to consume entire buffer, but "' + (v - p) + '" bytes remain');
  var V = c - k, X = c - L, oe = Buffer$4.allocUnsafe(V + k + X + L);
  for (p = 0; p < V; ++p)
    oe[p] = 0;
  a.copy(oe, p, M + Math.max(-V, 0), M + k), p = c;
  for (var Y = p; p < Y + X; ++p)
    oe[p] = 0;
  return a.copy(oe, p, F + Math.max(-X, 0), F + L), oe = oe.toString("base64"), oe = base64Url(oe), oe;
}
function countPadding(a, u, c) {
  for (var l = 0; u + l < c && a[u + l] === 0; )
    ++l;
  var v = a[u + l] >= MAX_OCTET;
  return v && --l, l;
}
function joseToDer(a, u) {
  a = signatureAsBuffer(a);
  var c = getParamBytesForAlg(u), l = a.length;
  if (l !== c * 2)
    throw new TypeError('"' + u + '" signatures must be "' + c * 2 + '" bytes, saw "' + l + '"');
  var v = countPadding(a, 0, c), p = countPadding(a, c, a.length), _ = c - v, k = c - p, M = 2 + _ + 1 + 1 + k, L = M < MAX_OCTET, F = Buffer$4.allocUnsafe((L ? 2 : 3) + M), V = 0;
  return F[V++] = ENCODED_TAG_SEQ, L ? F[V++] = M : (F[V++] = MAX_OCTET | 1, F[V++] = M & 255), F[V++] = ENCODED_TAG_INT, F[V++] = _, v < 0 ? (F[V++] = 0, V += a.copy(F, V, 0, c)) : V += a.copy(F, V, v, c), F[V++] = ENCODED_TAG_INT, F[V++] = k, p < 0 ? (F[V++] = 0, a.copy(F, V, c)) : a.copy(F, V, c + p), F;
}
var ecdsaSigFormatter = {
  derToJose,
  joseToDer
}, bufferEqual = bufferEqualConstantTime, Buffer$3 = safeBufferExports$3.Buffer, crypto$1 = requireCryptoBrowserify(), formatEcdsa = ecdsaSigFormatter, util$2 = util$4, MSG_INVALID_ALGORITHM = `"%s" is not a valid algorithm.
  Supported algorithms are:
  "HS256", "HS384", "HS512", "RS256", "RS384", "RS512", "PS256", "PS384", "PS512", "ES256", "ES384", "ES512" and "none".`, MSG_INVALID_SECRET = "secret must be a string or buffer", MSG_INVALID_VERIFIER_KEY = "key must be a string or a buffer", MSG_INVALID_SIGNER_KEY = "key must be a string, a buffer or an object", supportsKeyObjects = typeof crypto$1.createPublicKey == "function";
supportsKeyObjects && (MSG_INVALID_VERIFIER_KEY += " or a KeyObject", MSG_INVALID_SECRET += "or a KeyObject");
function checkIsPublicKey(a) {
  if (!Buffer$3.isBuffer(a) && typeof a != "string" && (!supportsKeyObjects || typeof a != "object" || typeof a.type != "string" || typeof a.asymmetricKeyType != "string" || typeof a.export != "function"))
    throw typeError(MSG_INVALID_VERIFIER_KEY);
}
function checkIsPrivateKey(a) {
  if (!Buffer$3.isBuffer(a) && typeof a != "string" && typeof a != "object")
    throw typeError(MSG_INVALID_SIGNER_KEY);
}
function checkIsSecretKey(a) {
  if (!Buffer$3.isBuffer(a)) {
    if (typeof a == "string")
      return a;
    if (!supportsKeyObjects || typeof a != "object" || a.type !== "secret" || typeof a.export != "function")
      throw typeError(MSG_INVALID_SECRET);
  }
}
function fromBase64(a) {
  return a.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function toBase64(a) {
  a = a.toString();
  var u = 4 - a.length % 4;
  if (u !== 4)
    for (var c = 0; c < u; ++c)
      a += "=";
  return a.replace(/\-/g, "+").replace(/_/g, "/");
}
function typeError(a) {
  var u = [].slice.call(arguments, 1), c = util$2.format.bind(util$2, a).apply(null, u);
  return new TypeError(c);
}
function bufferOrString(a) {
  return Buffer$3.isBuffer(a) || typeof a == "string";
}
function normalizeInput(a) {
  return bufferOrString(a) || (a = JSON.stringify(a)), a;
}
function createHmacSigner(a) {
  return function(c, l) {
    checkIsSecretKey(l), c = normalizeInput(c);
    var v = crypto$1.createHmac("sha" + a, l), p = (v.update(c), v.digest("base64"));
    return fromBase64(p);
  };
}
function createHmacVerifier(a) {
  return function(c, l, v) {
    var p = createHmacSigner(a)(c, v);
    return bufferEqual(Buffer$3.from(l), Buffer$3.from(p));
  };
}
function createKeySigner(a) {
  return function(c, l) {
    checkIsPrivateKey(l), c = normalizeInput(c);
    var v = crypto$1.createSign("RSA-SHA" + a), p = (v.update(c), v.sign(l, "base64"));
    return fromBase64(p);
  };
}
function createKeyVerifier(a) {
  return function(c, l, v) {
    checkIsPublicKey(v), c = normalizeInput(c), l = toBase64(l);
    var p = crypto$1.createVerify("RSA-SHA" + a);
    return p.update(c), p.verify(v, l, "base64");
  };
}
function createPSSKeySigner(a) {
  return function(c, l) {
    checkIsPrivateKey(l), c = normalizeInput(c);
    var v = crypto$1.createSign("RSA-SHA" + a), p = (v.update(c), v.sign({
      key: l,
      padding: crypto$1.constants.RSA_PKCS1_PSS_PADDING,
      saltLength: crypto$1.constants.RSA_PSS_SALTLEN_DIGEST
    }, "base64"));
    return fromBase64(p);
  };
}
function createPSSKeyVerifier(a) {
  return function(c, l, v) {
    checkIsPublicKey(v), c = normalizeInput(c), l = toBase64(l);
    var p = crypto$1.createVerify("RSA-SHA" + a);
    return p.update(c), p.verify({
      key: v,
      padding: crypto$1.constants.RSA_PKCS1_PSS_PADDING,
      saltLength: crypto$1.constants.RSA_PSS_SALTLEN_DIGEST
    }, l, "base64");
  };
}
function createECDSASigner(a) {
  var u = createKeySigner(a);
  return function() {
    var l = u.apply(null, arguments);
    return l = formatEcdsa.derToJose(l, "ES" + a), l;
  };
}
function createECDSAVerifer(a) {
  var u = createKeyVerifier(a);
  return function(l, v, p) {
    v = formatEcdsa.joseToDer(v, "ES" + a).toString("base64");
    var _ = u(l, v, p);
    return _;
  };
}
function createNoneSigner() {
  return function() {
    return "";
  };
}
function createNoneVerifier() {
  return function(u, c) {
    return c === "";
  };
}
var jwa$2 = function a(u) {
  var c = {
    hs: createHmacSigner,
    rs: createKeySigner,
    ps: createPSSKeySigner,
    es: createECDSASigner,
    none: createNoneSigner
  }, l = {
    hs: createHmacVerifier,
    rs: createKeyVerifier,
    ps: createPSSKeyVerifier,
    es: createECDSAVerifer,
    none: createNoneVerifier
  }, v = u.match(/^(RS|PS|ES|HS)(256|384|512)$|^(none)$/i);
  if (!v)
    throw typeError(MSG_INVALID_ALGORITHM, u);
  var p = (v[1] || v[3]).toLowerCase(), _ = v[2];
  return {
    sign: c[p](_),
    verify: l[p](_)
  };
}, Buffer$2 = require$$0$2.Buffer, tostring = function a(u) {
  return typeof u == "string" ? u : typeof u == "number" || Buffer$2.isBuffer(u) ? u.toString() : JSON.stringify(u);
}, Buffer$1 = safeBufferExports$3.Buffer, DataStream$1 = dataStream, jwa$1 = jwa$2, Stream$1 = streamBrowserify, toString$2 = tostring, util$1 = util$4;
function base64url(a, u) {
  return Buffer$1.from(a, u).toString("base64").replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function jwsSecuredInput(a, u, c) {
  c = c || "utf8";
  var l = base64url(toString$2(a), "binary"), v = base64url(toString$2(u), c);
  return util$1.format("%s.%s", l, v);
}
function jwsSign(a) {
  var u = a.header, c = a.payload, l = a.secret || a.privateKey, v = a.encoding, p = jwa$1(u.alg), _ = jwsSecuredInput(u, c, v), k = p.sign(_, l);
  return util$1.format("%s.%s", _, k);
}
function SignStream$1(a) {
  var u = a.secret || a.privateKey || a.key, c = new DataStream$1(u);
  this.readable = !0, this.header = a.header, this.encoding = a.encoding, this.secret = this.privateKey = this.key = c, this.payload = new DataStream$1(a.payload), this.secret.once("close", (function() {
    !this.payload.writable && this.readable && this.sign();
  }).bind(this)), this.payload.once("close", (function() {
    !this.secret.writable && this.readable && this.sign();
  }).bind(this));
}
util$1.inherits(SignStream$1, Stream$1);
SignStream$1.prototype.sign = function a() {
  try {
    var u = jwsSign({
      header: this.header,
      payload: this.payload.buffer,
      secret: this.secret.buffer,
      encoding: this.encoding
    });
    return this.emit("done", u), this.emit("data", u), this.emit("end"), this.readable = !1, u;
  } catch (c) {
    this.readable = !1, this.emit("error", c), this.emit("close");
  }
};
SignStream$1.sign = jwsSign;
var signStream = SignStream$1, Buffer = safeBufferExports$3.Buffer, DataStream = dataStream, jwa = jwa$2, Stream = streamBrowserify, toString$1 = tostring, util = util$4, JWS_REGEX = /^[a-zA-Z0-9\-_]+?\.[a-zA-Z0-9\-_]+?\.([a-zA-Z0-9\-_]+)?$/;
function isObject$6(a) {
  return Object.prototype.toString.call(a) === "[object Object]";
}
function safeJsonParse(a) {
  if (isObject$6(a))
    return a;
  try {
    return JSON.parse(a);
  } catch {
    return;
  }
}
function headerFromJWS(a) {
  var u = a.split(".", 1)[0];
  return safeJsonParse(Buffer.from(u, "base64").toString("binary"));
}
function securedInputFromJWS(a) {
  return a.split(".", 2).join(".");
}
function signatureFromJWS(a) {
  return a.split(".")[2];
}
function payloadFromJWS(a, u) {
  u = u || "utf8";
  var c = a.split(".")[1];
  return Buffer.from(c, "base64").toString(u);
}
function isValidJws(a) {
  return JWS_REGEX.test(a) && !!headerFromJWS(a);
}
function jwsVerify(a, u, c) {
  if (!u) {
    var l = new Error("Missing algorithm parameter for jws.verify");
    throw l.code = "MISSING_ALGORITHM", l;
  }
  a = toString$1(a);
  var v = signatureFromJWS(a), p = securedInputFromJWS(a), _ = jwa(u);
  return _.verify(p, v, c);
}
function jwsDecode(a, u) {
  if (u = u || {}, a = toString$1(a), !isValidJws(a))
    return null;
  var c = headerFromJWS(a);
  if (!c)
    return null;
  var l = payloadFromJWS(a);
  return (c.typ === "JWT" || u.json) && (l = JSON.parse(l, u.encoding)), {
    header: c,
    payload: l,
    signature: signatureFromJWS(a)
  };
}
function VerifyStream$1(a) {
  a = a || {};
  var u = a.secret || a.publicKey || a.key, c = new DataStream(u);
  this.readable = !0, this.algorithm = a.algorithm, this.encoding = a.encoding, this.secret = this.publicKey = this.key = c, this.signature = new DataStream(a.signature), this.secret.once("close", (function() {
    !this.signature.writable && this.readable && this.verify();
  }).bind(this)), this.signature.once("close", (function() {
    !this.secret.writable && this.readable && this.verify();
  }).bind(this));
}
util.inherits(VerifyStream$1, Stream);
VerifyStream$1.prototype.verify = function a() {
  try {
    var u = jwsVerify(this.signature.buffer, this.algorithm, this.key.buffer), c = jwsDecode(this.signature.buffer, this.encoding);
    return this.emit("done", u, c), this.emit("data", u), this.emit("end"), this.readable = !1, u;
  } catch (l) {
    this.readable = !1, this.emit("error", l), this.emit("close");
  }
};
VerifyStream$1.decode = jwsDecode;
VerifyStream$1.isValid = isValidJws;
VerifyStream$1.verify = jwsVerify;
var verifyStream = VerifyStream$1, SignStream = signStream, VerifyStream = verifyStream, ALGORITHMS = [
  "HS256",
  "HS384",
  "HS512",
  "RS256",
  "RS384",
  "RS512",
  "PS256",
  "PS384",
  "PS512",
  "ES256",
  "ES384",
  "ES512"
];
jws$3.ALGORITHMS = ALGORITHMS;
jws$3.sign = SignStream.sign;
jws$3.verify = VerifyStream.verify;
jws$3.decode = VerifyStream.decode;
jws$3.isValid = VerifyStream.isValid;
jws$3.createSign = function a(u) {
  return new SignStream(u);
};
jws$3.createVerify = function a(u) {
  return new VerifyStream(u);
};
var jws$2 = jws$3, decode$1 = function(a, u) {
  u = u || {};
  var c = jws$2.decode(a, u);
  if (!c)
    return null;
  var l = c.payload;
  if (typeof l == "string")
    try {
      var v = JSON.parse(l);
      v !== null && typeof v == "object" && (l = v);
    } catch {
    }
  return u.complete === !0 ? {
    header: c.header,
    payload: l,
    signature: c.signature
  } : l;
}, JsonWebTokenError$3 = function(a, u) {
  Error.call(this, a), Error.captureStackTrace && Error.captureStackTrace(this, this.constructor), this.name = "JsonWebTokenError", this.message = a, u && (this.inner = u);
};
JsonWebTokenError$3.prototype = Object.create(Error.prototype);
JsonWebTokenError$3.prototype.constructor = JsonWebTokenError$3;
var JsonWebTokenError_1 = JsonWebTokenError$3, JsonWebTokenError$2 = JsonWebTokenError_1, NotBeforeError$1 = function(a, u) {
  JsonWebTokenError$2.call(this, a), this.name = "NotBeforeError", this.date = u;
};
NotBeforeError$1.prototype = Object.create(JsonWebTokenError$2.prototype);
NotBeforeError$1.prototype.constructor = NotBeforeError$1;
var NotBeforeError_1 = NotBeforeError$1, JsonWebTokenError$1 = JsonWebTokenError_1, TokenExpiredError$1 = function(a, u) {
  JsonWebTokenError$1.call(this, a), this.name = "TokenExpiredError", this.expiredAt = u;
};
TokenExpiredError$1.prototype = Object.create(JsonWebTokenError$1.prototype);
TokenExpiredError$1.prototype.constructor = TokenExpiredError$1;
var TokenExpiredError_1 = TokenExpiredError$1, s = 1e3, m$1 = s * 60, h = m$1 * 60, d = h * 24, w = d * 7, y = d * 365.25, ms$1 = function(a, u) {
  u = u || {};
  var c = typeof a;
  if (c === "string" && a.length > 0)
    return parse$1(a);
  if (c === "number" && isFinite(a))
    return u.long ? fmtLong(a) : fmtShort(a);
  throw new Error(
    "val is not a non-empty string or a valid number. val=" + JSON.stringify(a)
  );
};
function parse$1(a) {
  if (a = String(a), !(a.length > 100)) {
    var u = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      a
    );
    if (u) {
      var c = parseFloat(u[1]), l = (u[2] || "ms").toLowerCase();
      switch (l) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return c * y;
        case "weeks":
        case "week":
        case "w":
          return c * w;
        case "days":
        case "day":
        case "d":
          return c * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return c * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return c * m$1;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return c * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return c;
        default:
          return;
      }
    }
  }
}
function fmtShort(a) {
  var u = Math.abs(a);
  return u >= d ? Math.round(a / d) + "d" : u >= h ? Math.round(a / h) + "h" : u >= m$1 ? Math.round(a / m$1) + "m" : u >= s ? Math.round(a / s) + "s" : a + "ms";
}
function fmtLong(a) {
  var u = Math.abs(a);
  return u >= d ? plural(a, u, d, "day") : u >= h ? plural(a, u, h, "hour") : u >= m$1 ? plural(a, u, m$1, "minute") : u >= s ? plural(a, u, s, "second") : a + " ms";
}
function plural(a, u, c, l) {
  var v = u >= c * 1.5;
  return Math.round(a / c) + " " + l + (v ? "s" : "");
}
var ms = ms$1, timespan$2 = function(a, u) {
  var c = u || Math.floor(Date.now() / 1e3);
  if (typeof a == "string") {
    var l = ms(a);
    return typeof l > "u" ? void 0 : Math.floor(c + l / 1e3);
  } else
    return typeof a == "number" ? c + a : void 0;
}, semver$1 = { exports: {} };
(function(a, u) {
  u = a.exports = Fe;
  var c;
  typeof process$1 == "object" && process$1.env && process$1.env.NODE_DEBUG && /\bsemver\b/i.test(process$1.env.NODE_DEBUG) ? c = function() {
    var Je = Array.prototype.slice.call(arguments, 0);
    Je.unshift("SEMVER"), console.log.apply(console, Je);
  } : c = function() {
  }, u.SEMVER_SPEC_VERSION = "2.0.0";
  var l = 256, v = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
  9007199254740991, p = 16, _ = u.re = [], k = u.src = [], M = 0, L = M++;
  k[L] = "0|[1-9]\\d*";
  var F = M++;
  k[F] = "[0-9]+";
  var V = M++;
  k[V] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
  var X = M++;
  k[X] = "(" + k[L] + ")\\.(" + k[L] + ")\\.(" + k[L] + ")";
  var oe = M++;
  k[oe] = "(" + k[F] + ")\\.(" + k[F] + ")\\.(" + k[F] + ")";
  var Y = M++;
  k[Y] = "(?:" + k[L] + "|" + k[V] + ")";
  var ae = M++;
  k[ae] = "(?:" + k[F] + "|" + k[V] + ")";
  var ne = M++;
  k[ne] = "(?:-(" + k[Y] + "(?:\\." + k[Y] + ")*))";
  var fe = M++;
  k[fe] = "(?:-?(" + k[ae] + "(?:\\." + k[ae] + ")*))";
  var ie = M++;
  k[ie] = "[0-9A-Za-z-]+";
  var ge = M++;
  k[ge] = "(?:\\+(" + k[ie] + "(?:\\." + k[ie] + ")*))";
  var be = M++, Ce = "v?" + k[X] + k[ne] + "?" + k[ge] + "?";
  k[be] = "^" + Ce + "$";
  var Me = "[v=\\s]*" + k[oe] + k[fe] + "?" + k[ge] + "?", Be = M++;
  k[Be] = "^" + Me + "$";
  var Ae = M++;
  k[Ae] = "((?:<|>)?=?)";
  var Z = M++;
  k[Z] = k[F] + "|x|X|\\*";
  var z = M++;
  k[z] = k[L] + "|x|X|\\*";
  var P = M++;
  k[P] = "[v=\\s]*(" + k[z] + ")(?:\\.(" + k[z] + ")(?:\\.(" + k[z] + ")(?:" + k[ne] + ")?" + k[ge] + "?)?)?";
  var S = M++;
  k[S] = "[v=\\s]*(" + k[Z] + ")(?:\\.(" + k[Z] + ")(?:\\.(" + k[Z] + ")(?:" + k[fe] + ")?" + k[ge] + "?)?)?";
  var E = M++;
  k[E] = "^" + k[Ae] + "\\s*" + k[P] + "$";
  var I = M++;
  k[I] = "^" + k[Ae] + "\\s*" + k[S] + "$";
  var N = M++;
  k[N] = "(?:^|[^\\d])(\\d{1," + p + "})(?:\\.(\\d{1," + p + "}))?(?:\\.(\\d{1," + p + "}))?(?:$|[^\\d])";
  var $ = M++;
  k[$] = "(?:~>?)";
  var U = M++;
  k[U] = "(\\s*)" + k[$] + "\\s+", _[U] = new RegExp(k[U], "g");
  var H = "$1~", B = M++;
  k[B] = "^" + k[$] + k[P] + "$";
  var T = M++;
  k[T] = "^" + k[$] + k[S] + "$";
  var D = M++;
  k[D] = "(?:\\^)";
  var ee = M++;
  k[ee] = "(\\s*)" + k[D] + "\\s+", _[ee] = new RegExp(k[ee], "g");
  var pe = "$1^", Ie = M++;
  k[Ie] = "^" + k[D] + k[P] + "$";
  var Pe = M++;
  k[Pe] = "^" + k[D] + k[S] + "$";
  var he = M++;
  k[he] = "^" + k[Ae] + "\\s*(" + Me + ")$|^$";
  var ve = M++;
  k[ve] = "^" + k[Ae] + "\\s*(" + Ce + ")$|^$";
  var Q = M++;
  k[Q] = "(\\s*)" + k[Ae] + "\\s*(" + Me + "|" + k[P] + ")", _[Q] = new RegExp(k[Q], "g");
  var le = "$1$2$3", _e = M++;
  k[_e] = "^\\s*(" + k[P] + ")\\s+-\\s+(" + k[P] + ")\\s*$";
  var re = M++;
  k[re] = "^\\s*(" + k[S] + ")\\s+-\\s+(" + k[S] + ")\\s*$";
  var O = M++;
  k[O] = "(<|>)?=?\\s*\\*";
  for (var j = 0; j < M; j++)
    c(j, k[j]), _[j] || (_[j] = new RegExp(k[j]));
  u.parse = ce;
  function ce(Je, He) {
    if ((!He || typeof He != "object") && (He = {
      loose: !!He,
      includePrerelease: !1
    }), Je instanceof Fe)
      return Je;
    if (typeof Je != "string" || Je.length > l)
      return null;
    var je = He.loose ? _[Be] : _[be];
    if (!je.test(Je))
      return null;
    try {
      return new Fe(Je, He);
    } catch {
      return null;
    }
  }
  u.valid = De;
  function De(Je, He) {
    var je = ce(Je, He);
    return je ? je.version : null;
  }
  u.clean = Ne;
  function Ne(Je, He) {
    var je = ce(Je.trim().replace(/^[=v]+/, ""), He);
    return je ? je.version : null;
  }
  u.SemVer = Fe;
  function Fe(Je, He) {
    if ((!He || typeof He != "object") && (He = {
      loose: !!He,
      includePrerelease: !1
    }), Je instanceof Fe) {
      if (Je.loose === He.loose)
        return Je;
      Je = Je.version;
    } else if (typeof Je != "string")
      throw new TypeError("Invalid Version: " + Je);
    if (Je.length > l)
      throw new TypeError("version is longer than " + l + " characters");
    if (!(this instanceof Fe))
      return new Fe(Je, He);
    c("SemVer", Je, He), this.options = He, this.loose = !!He.loose;
    var je = Je.trim().match(He.loose ? _[Be] : _[be]);
    if (!je)
      throw new TypeError("Invalid Version: " + Je);
    if (this.raw = Je, this.major = +je[1], this.minor = +je[2], this.patch = +je[3], this.major > v || this.major < 0)
      throw new TypeError("Invalid major version");
    if (this.minor > v || this.minor < 0)
      throw new TypeError("Invalid minor version");
    if (this.patch > v || this.patch < 0)
      throw new TypeError("Invalid patch version");
    je[4] ? this.prerelease = je[4].split(".").map(function(pt) {
      if (/^[0-9]+$/.test(pt)) {
        var mt = +pt;
        if (mt >= 0 && mt < v)
          return mt;
      }
      return pt;
    }) : this.prerelease = [], this.build = je[5] ? je[5].split(".") : [], this.format();
  }
  Fe.prototype.format = function() {
    return this.version = this.major + "." + this.minor + "." + this.patch, this.prerelease.length && (this.version += "-" + this.prerelease.join(".")), this.version;
  }, Fe.prototype.toString = function() {
    return this.version;
  }, Fe.prototype.compare = function(Je) {
    return c("SemVer.compare", this.version, this.options, Je), Je instanceof Fe || (Je = new Fe(Je, this.options)), this.compareMain(Je) || this.comparePre(Je);
  }, Fe.prototype.compareMain = function(Je) {
    return Je instanceof Fe || (Je = new Fe(Je, this.options)), Xe(this.major, Je.major) || Xe(this.minor, Je.minor) || Xe(this.patch, Je.patch);
  }, Fe.prototype.comparePre = function(Je) {
    if (Je instanceof Fe || (Je = new Fe(Je, this.options)), this.prerelease.length && !Je.prerelease.length)
      return -1;
    if (!this.prerelease.length && Je.prerelease.length)
      return 1;
    if (!this.prerelease.length && !Je.prerelease.length)
      return 0;
    var He = 0;
    do {
      var je = this.prerelease[He], pt = Je.prerelease[He];
      if (c("prerelease compare", He, je, pt), je === void 0 && pt === void 0)
        return 0;
      if (pt === void 0)
        return 1;
      if (je === void 0)
        return -1;
      if (je === pt)
        continue;
      return Xe(je, pt);
    } while (++He);
  }, Fe.prototype.inc = function(Je, He) {
    switch (Je) {
      case "premajor":
        this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", He);
        break;
      case "preminor":
        this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", He);
        break;
      case "prepatch":
        this.prerelease.length = 0, this.inc("patch", He), this.inc("pre", He);
        break;
      case "prerelease":
        this.prerelease.length === 0 && this.inc("patch", He), this.inc("pre", He);
        break;
      case "major":
        (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
        break;
      case "minor":
        (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
        break;
      case "patch":
        this.prerelease.length === 0 && this.patch++, this.prerelease = [];
        break;
      case "pre":
        if (this.prerelease.length === 0)
          this.prerelease = [0];
        else {
          for (var je = this.prerelease.length; --je >= 0; )
            typeof this.prerelease[je] == "number" && (this.prerelease[je]++, je = -2);
          je === -1 && this.prerelease.push(0);
        }
        He && (this.prerelease[0] === He ? isNaN(this.prerelease[1]) && (this.prerelease = [He, 0]) : this.prerelease = [He, 0]);
        break;
      default:
        throw new Error("invalid increment argument: " + Je);
    }
    return this.format(), this.raw = this.version, this;
  }, u.inc = Ze;
  function Ze(Je, He, je, pt) {
    typeof je == "string" && (pt = je, je = void 0);
    try {
      return new Fe(Je, je).inc(He, pt).version;
    } catch {
      return null;
    }
  }
  u.diff = qe;
  function qe(Je, He) {
    if (Oe(Je, He))
      return null;
    var je = ce(Je), pt = ce(He), mt = "";
    if (je.prerelease.length || pt.prerelease.length) {
      mt = "pre";
      var yt = "prerelease";
    }
    for (var ht in je)
      if ((ht === "major" || ht === "minor" || ht === "patch") && je[ht] !== pt[ht])
        return mt + ht;
    return yt;
  }
  u.compareIdentifiers = Xe;
  var gt = /^[0-9]+$/;
  function Xe(Je, He) {
    var je = gt.test(Je), pt = gt.test(He);
    return je && pt && (Je = +Je, He = +He), Je === He ? 0 : je && !pt ? -1 : pt && !je ? 1 : Je < He ? -1 : 1;
  }
  u.rcompareIdentifiers = Ge;
  function Ge(Je, He) {
    return Xe(He, Je);
  }
  u.major = J;
  function J(Je, He) {
    return new Fe(Je, He).major;
  }
  u.minor = ye;
  function ye(Je, He) {
    return new Fe(Je, He).minor;
  }
  u.patch = we;
  function we(Je, He) {
    return new Fe(Je, He).patch;
  }
  u.compare = We;
  function We(Je, He, je) {
    return new Fe(Je, je).compare(new Fe(He, je));
  }
  u.compareLoose = Re;
  function Re(Je, He) {
    return We(Je, He, !0);
  }
  u.rcompare = q;
  function q(Je, He, je) {
    return We(He, Je, je);
  }
  u.sort = ke;
  function ke(Je, He) {
    return Je.sort(function(je, pt) {
      return u.compare(je, pt, He);
    });
  }
  u.rsort = de;
  function de(Je, He) {
    return Je.sort(function(je, pt) {
      return u.rcompare(je, pt, He);
    });
  }
  u.gt = ue;
  function ue(Je, He, je) {
    return We(Je, He, je) > 0;
  }
  u.lt = me;
  function me(Je, He, je) {
    return We(Je, He, je) < 0;
  }
  u.eq = Oe;
  function Oe(Je, He, je) {
    return We(Je, He, je) === 0;
  }
  u.neq = Ue;
  function Ue(Je, He, je) {
    return We(Je, He, je) !== 0;
  }
  u.gte = ze;
  function ze(Je, He, je) {
    return We(Je, He, je) >= 0;
  }
  u.lte = Ve;
  function Ve(Je, He, je) {
    return We(Je, He, je) <= 0;
  }
  u.cmp = Qe;
  function Qe(Je, He, je, pt) {
    switch (He) {
      case "===":
        return typeof Je == "object" && (Je = Je.version), typeof je == "object" && (je = je.version), Je === je;
      case "!==":
        return typeof Je == "object" && (Je = Je.version), typeof je == "object" && (je = je.version), Je !== je;
      case "":
      case "=":
      case "==":
        return Oe(Je, je, pt);
      case "!=":
        return Ue(Je, je, pt);
      case ">":
        return ue(Je, je, pt);
      case ">=":
        return ze(Je, je, pt);
      case "<":
        return me(Je, je, pt);
      case "<=":
        return Ve(Je, je, pt);
      default:
        throw new TypeError("Invalid operator: " + He);
    }
  }
  u.Comparator = Ke;
  function Ke(Je, He) {
    if ((!He || typeof He != "object") && (He = {
      loose: !!He,
      includePrerelease: !1
    }), Je instanceof Ke) {
      if (Je.loose === !!He.loose)
        return Je;
      Je = Je.value;
    }
    if (!(this instanceof Ke))
      return new Ke(Je, He);
    c("comparator", Je, He), this.options = He, this.loose = !!He.loose, this.parse(Je), this.semver === x ? this.value = "" : this.value = this.operator + this.semver.version, c("comp", this);
  }
  var x = {};
  Ke.prototype.parse = function(Je) {
    var He = this.options.loose ? _[he] : _[ve], je = Je.match(He);
    if (!je)
      throw new TypeError("Invalid comparator: " + Je);
    this.operator = je[1], this.operator === "=" && (this.operator = ""), je[2] ? this.semver = new Fe(je[2], this.options.loose) : this.semver = x;
  }, Ke.prototype.toString = function() {
    return this.value;
  }, Ke.prototype.test = function(Je) {
    return c("Comparator.test", Je, this.options.loose), this.semver === x ? !0 : (typeof Je == "string" && (Je = new Fe(Je, this.options)), Qe(Je, this.operator, this.semver, this.options));
  }, Ke.prototype.intersects = function(Je, He) {
    if (!(Je instanceof Ke))
      throw new TypeError("a Comparator is required");
    (!He || typeof He != "object") && (He = {
      loose: !!He,
      includePrerelease: !1
    });
    var je;
    if (this.operator === "")
      return je = new se(Je.value, He), kt(this.value, je, He);
    if (Je.operator === "")
      return je = new se(this.value, He), kt(Je.semver, je, He);
    var pt = (this.operator === ">=" || this.operator === ">") && (Je.operator === ">=" || Je.operator === ">"), mt = (this.operator === "<=" || this.operator === "<") && (Je.operator === "<=" || Je.operator === "<"), yt = this.semver.version === Je.semver.version, ht = (this.operator === ">=" || this.operator === "<=") && (Je.operator === ">=" || Je.operator === "<="), _t = Qe(this.semver, "<", Je.semver, He) && (this.operator === ">=" || this.operator === ">") && (Je.operator === "<=" || Je.operator === "<"), Et = Qe(this.semver, ">", Je.semver, He) && (this.operator === "<=" || this.operator === "<") && (Je.operator === ">=" || Je.operator === ">");
    return pt || mt || yt && ht || _t || Et;
  }, u.Range = se;
  function se(Je, He) {
    if ((!He || typeof He != "object") && (He = {
      loose: !!He,
      includePrerelease: !1
    }), Je instanceof se)
      return Je.loose === !!He.loose && Je.includePrerelease === !!He.includePrerelease ? Je : new se(Je.raw, He);
    if (Je instanceof Ke)
      return new se(Je.value, He);
    if (!(this instanceof se))
      return new se(Je, He);
    if (this.options = He, this.loose = !!He.loose, this.includePrerelease = !!He.includePrerelease, this.raw = Je, this.set = Je.split(/\s*\|\|\s*/).map(function(je) {
      return this.parseRange(je.trim());
    }, this).filter(function(je) {
      return je.length;
    }), !this.set.length)
      throw new TypeError("Invalid SemVer Range: " + Je);
    this.format();
  }
  se.prototype.format = function() {
    return this.range = this.set.map(function(Je) {
      return Je.join(" ").trim();
    }).join("||").trim(), this.range;
  }, se.prototype.toString = function() {
    return this.range;
  }, se.prototype.parseRange = function(Je) {
    var He = this.options.loose;
    Je = Je.trim();
    var je = He ? _[re] : _[_e];
    Je = Je.replace(je, rt), c("hyphen replace", Je), Je = Je.replace(_[Q], le), c("comparator trim", Je, _[Q]), Je = Je.replace(_[U], H), Je = Je.replace(_[ee], pe), Je = Je.split(/\s+/).join(" ");
    var pt = He ? _[he] : _[ve], mt = Je.split(" ").map(function(yt) {
      return xe(yt, this.options);
    }, this).join(" ").split(/\s+/);
    return this.options.loose && (mt = mt.filter(function(yt) {
      return !!yt.match(pt);
    })), mt = mt.map(function(yt) {
      return new Ke(yt, this.options);
    }, this), mt;
  }, se.prototype.intersects = function(Je, He) {
    if (!(Je instanceof se))
      throw new TypeError("a Range is required");
    return this.set.some(function(je) {
      return je.every(function(pt) {
        return Je.set.some(function(mt) {
          return mt.every(function(yt) {
            return pt.intersects(yt, He);
          });
        });
      });
    });
  }, u.toComparators = Ee;
  function Ee(Je, He) {
    return new se(Je, He).set.map(function(je) {
      return je.map(function(pt) {
        return pt.value;
      }).join(" ").trim().split(" ");
    });
  }
  function xe(Je, He) {
    return c("comp", Je, He), Je = dt(Je, He), c("caret", Je), Je = Ye(Je, He), c("tildes", Je), Je = tt(Je, He), c("xrange", Je), Je = wt(Je, He), c("stars", Je), Je;
  }
  function $e(Je) {
    return !Je || Je.toLowerCase() === "x" || Je === "*";
  }
  function Ye(Je, He) {
    return Je.trim().split(/\s+/).map(function(je) {
      return et(je, He);
    }).join(" ");
  }
  function et(Je, He) {
    var je = He.loose ? _[T] : _[B];
    return Je.replace(je, function(pt, mt, yt, ht, _t) {
      c("tilde", Je, pt, mt, yt, ht, _t);
      var Et;
      return $e(mt) ? Et = "" : $e(yt) ? Et = ">=" + mt + ".0.0 <" + (+mt + 1) + ".0.0" : $e(ht) ? Et = ">=" + mt + "." + yt + ".0 <" + mt + "." + (+yt + 1) + ".0" : _t ? (c("replaceTilde pr", _t), Et = ">=" + mt + "." + yt + "." + ht + "-" + _t + " <" + mt + "." + (+yt + 1) + ".0") : Et = ">=" + mt + "." + yt + "." + ht + " <" + mt + "." + (+yt + 1) + ".0", c("tilde return", Et), Et;
    });
  }
  function dt(Je, He) {
    return Je.trim().split(/\s+/).map(function(je) {
      return St(je, He);
    }).join(" ");
  }
  function St(Je, He) {
    c("caret", Je, He);
    var je = He.loose ? _[Pe] : _[Ie];
    return Je.replace(je, function(pt, mt, yt, ht, _t) {
      c("caret", Je, pt, mt, yt, ht, _t);
      var Et;
      return $e(mt) ? Et = "" : $e(yt) ? Et = ">=" + mt + ".0.0 <" + (+mt + 1) + ".0.0" : $e(ht) ? mt === "0" ? Et = ">=" + mt + "." + yt + ".0 <" + mt + "." + (+yt + 1) + ".0" : Et = ">=" + mt + "." + yt + ".0 <" + (+mt + 1) + ".0.0" : _t ? (c("replaceCaret pr", _t), mt === "0" ? yt === "0" ? Et = ">=" + mt + "." + yt + "." + ht + "-" + _t + " <" + mt + "." + yt + "." + (+ht + 1) : Et = ">=" + mt + "." + yt + "." + ht + "-" + _t + " <" + mt + "." + (+yt + 1) + ".0" : Et = ">=" + mt + "." + yt + "." + ht + "-" + _t + " <" + (+mt + 1) + ".0.0") : (c("no pr"), mt === "0" ? yt === "0" ? Et = ">=" + mt + "." + yt + "." + ht + " <" + mt + "." + yt + "." + (+ht + 1) : Et = ">=" + mt + "." + yt + "." + ht + " <" + mt + "." + (+yt + 1) + ".0" : Et = ">=" + mt + "." + yt + "." + ht + " <" + (+mt + 1) + ".0.0"), c("caret return", Et), Et;
    });
  }
  function tt(Je, He) {
    return c("replaceXRanges", Je, He), Je.split(/\s+/).map(function(je) {
      return at(je, He);
    }).join(" ");
  }
  function at(Je, He) {
    Je = Je.trim();
    var je = He.loose ? _[I] : _[E];
    return Je.replace(je, function(pt, mt, yt, ht, _t, Et) {
      c("xRange", Je, pt, mt, yt, ht, _t, Et);
      var Nt = $e(yt), Dt = Nt || $e(ht), $t = Dt || $e(_t), At = $t;
      return mt === "=" && At && (mt = ""), Nt ? mt === ">" || mt === "<" ? pt = "<0.0.0" : pt = "*" : mt && At ? (Dt && (ht = 0), _t = 0, mt === ">" ? (mt = ">=", Dt ? (yt = +yt + 1, ht = 0, _t = 0) : (ht = +ht + 1, _t = 0)) : mt === "<=" && (mt = "<", Dt ? yt = +yt + 1 : ht = +ht + 1), pt = mt + yt + "." + ht + "." + _t) : Dt ? pt = ">=" + yt + ".0.0 <" + (+yt + 1) + ".0.0" : $t && (pt = ">=" + yt + "." + ht + ".0 <" + yt + "." + (+ht + 1) + ".0"), c("xRange return", pt), pt;
    });
  }
  function wt(Je, He) {
    return c("replaceStars", Je, He), Je.trim().replace(_[O], "");
  }
  function rt(Je, He, je, pt, mt, yt, ht, _t, Et, Nt, Dt, $t, At) {
    return $e(je) ? He = "" : $e(pt) ? He = ">=" + je + ".0.0" : $e(mt) ? He = ">=" + je + "." + pt + ".0" : He = ">=" + He, $e(Et) ? _t = "" : $e(Nt) ? _t = "<" + (+Et + 1) + ".0.0" : $e(Dt) ? _t = "<" + Et + "." + (+Nt + 1) + ".0" : $t ? _t = "<=" + Et + "." + Nt + "." + Dt + "-" + $t : _t = "<=" + _t, (He + " " + _t).trim();
  }
  se.prototype.test = function(Je) {
    if (!Je)
      return !1;
    typeof Je == "string" && (Je = new Fe(Je, this.options));
    for (var He = 0; He < this.set.length; He++)
      if (ut(this.set[He], Je, this.options))
        return !0;
    return !1;
  };
  function ut(Je, He, je) {
    for (var pt = 0; pt < Je.length; pt++)
      if (!Je[pt].test(He))
        return !1;
    if (He.prerelease.length && !je.includePrerelease) {
      for (pt = 0; pt < Je.length; pt++)
        if (c(Je[pt].semver), Je[pt].semver !== x && Je[pt].semver.prerelease.length > 0) {
          var mt = Je[pt].semver;
          if (mt.major === He.major && mt.minor === He.minor && mt.patch === He.patch)
            return !0;
        }
      return !1;
    }
    return !0;
  }
  u.satisfies = kt;
  function kt(Je, He, je) {
    try {
      He = new se(He, je);
    } catch {
      return !1;
    }
    return He.test(Je);
  }
  u.maxSatisfying = nt;
  function nt(Je, He, je) {
    var pt = null, mt = null;
    try {
      var yt = new se(He, je);
    } catch {
      return null;
    }
    return Je.forEach(function(ht) {
      yt.test(ht) && (!pt || mt.compare(ht) === -1) && (pt = ht, mt = new Fe(pt, je));
    }), pt;
  }
  u.minSatisfying = it;
  function it(Je, He, je) {
    var pt = null, mt = null;
    try {
      var yt = new se(He, je);
    } catch {
      return null;
    }
    return Je.forEach(function(ht) {
      yt.test(ht) && (!pt || mt.compare(ht) === 1) && (pt = ht, mt = new Fe(pt, je));
    }), pt;
  }
  u.minVersion = bt;
  function bt(Je, He) {
    Je = new se(Je, He);
    var je = new Fe("0.0.0");
    if (Je.test(je) || (je = new Fe("0.0.0-0"), Je.test(je)))
      return je;
    je = null;
    for (var pt = 0; pt < Je.set.length; ++pt) {
      var mt = Je.set[pt];
      mt.forEach(function(yt) {
        var ht = new Fe(yt.semver.version);
        switch (yt.operator) {
          case ">":
            ht.prerelease.length === 0 ? ht.patch++ : ht.prerelease.push(0), ht.raw = ht.format();
          case "":
          case ">=":
            (!je || ue(je, ht)) && (je = ht);
            break;
          case "<":
          case "<=":
            break;
          default:
            throw new Error("Unexpected operation: " + yt.operator);
        }
      });
    }
    return je && Je.test(je) ? je : null;
  }
  u.validRange = ot;
  function ot(Je, He) {
    try {
      return new se(Je, He).range || "*";
    } catch {
      return null;
    }
  }
  u.ltr = ct;
  function ct(Je, He, je) {
    return st(Je, He, "<", je);
  }
  u.gtr = Ot;
  function Ot(Je, He, je) {
    return st(Je, He, ">", je);
  }
  u.outside = st;
  function st(Je, He, je, pt) {
    Je = new Fe(Je, pt), He = new se(He, pt);
    var mt, yt, ht, _t, Et;
    switch (je) {
      case ">":
        mt = ue, yt = Ve, ht = me, _t = ">", Et = ">=";
        break;
      case "<":
        mt = me, yt = ze, ht = ue, _t = "<", Et = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (kt(Je, He, pt))
      return !1;
    for (var Nt = 0; Nt < He.set.length; ++Nt) {
      var Dt = He.set[Nt], $t = null, At = null;
      if (Dt.forEach(function(Lt) {
        Lt.semver === x && (Lt = new Ke(">=0.0.0")), $t = $t || Lt, At = At || Lt, mt(Lt.semver, $t.semver, pt) ? $t = Lt : ht(Lt.semver, At.semver, pt) && (At = Lt);
      }), $t.operator === _t || $t.operator === Et || (!At.operator || At.operator === _t) && yt(Je, At.semver))
        return !1;
      if (At.operator === Et && ht(Je, At.semver))
        return !1;
    }
    return !0;
  }
  u.prerelease = lt;
  function lt(Je, He) {
    var je = ce(Je, He);
    return je && je.prerelease.length ? je.prerelease : null;
  }
  u.intersects = Rt;
  function Rt(Je, He, je) {
    return Je = new se(Je, je), He = new se(He, je), Je.intersects(He);
  }
  u.coerce = Ct;
  function Ct(Je) {
    if (Je instanceof Fe)
      return Je;
    if (typeof Je != "string")
      return null;
    var He = Je.match(_[N]);
    return He == null ? null : ce(He[1] + "." + (He[2] || "0") + "." + (He[3] || "0"));
  }
})(semver$1, semver$1.exports);
var semverExports = semver$1.exports, semver = semverExports, psSupported = semver.satisfies(process$1.version, "^6.12.0 || >=8.0.0"), JsonWebTokenError = JsonWebTokenError_1, NotBeforeError = NotBeforeError_1, TokenExpiredError = TokenExpiredError_1, decode = decode$1, timespan$1 = timespan$2, PS_SUPPORTED$1 = psSupported, jws$1 = jws$3, PUB_KEY_ALGS = ["RS256", "RS384", "RS512", "ES256", "ES384", "ES512"], RSA_KEY_ALGS = ["RS256", "RS384", "RS512"], HS_ALGS = ["HS256", "HS384", "HS512"];
PS_SUPPORTED$1 && (PUB_KEY_ALGS.splice(3, 0, "PS256", "PS384", "PS512"), RSA_KEY_ALGS.splice(3, 0, "PS256", "PS384", "PS512"));
var verify = function(a, u, c, l) {
  typeof c == "function" && !l && (l = c, c = {}), c || (c = {}), c = Object.assign({}, c);
  var v;
  if (l ? v = l : v = function(F, V) {
    if (F)
      throw F;
    return V;
  }, c.clockTimestamp && typeof c.clockTimestamp != "number")
    return v(new JsonWebTokenError("clockTimestamp must be a number"));
  if (c.nonce !== void 0 && (typeof c.nonce != "string" || c.nonce.trim() === ""))
    return v(new JsonWebTokenError("nonce must be a non-empty string"));
  var p = c.clockTimestamp || Math.floor(Date.now() / 1e3);
  if (!a)
    return v(new JsonWebTokenError("jwt must be provided"));
  if (typeof a != "string")
    return v(new JsonWebTokenError("jwt must be a string"));
  var _ = a.split(".");
  if (_.length !== 3)
    return v(new JsonWebTokenError("jwt malformed"));
  var k;
  try {
    k = decode(a, { complete: !0 });
  } catch (F) {
    return v(F);
  }
  if (!k)
    return v(new JsonWebTokenError("invalid token"));
  var M = k.header, L;
  if (typeof u == "function") {
    if (!l)
      return v(new JsonWebTokenError("verify must be called asynchronous if secret or public key is provided as a callback"));
    L = u;
  } else
    L = function(F, V) {
      return V(null, u);
    };
  return L(M, function(F, V) {
    if (F)
      return v(new JsonWebTokenError("error in secret or public key callback: " + F.message));
    var X = _[2].trim() !== "";
    if (!X && V)
      return v(new JsonWebTokenError("jwt signature is required"));
    if (X && !V)
      return v(new JsonWebTokenError("secret or public key must be provided"));
    if (!X && !c.algorithms && (c.algorithms = ["none"]), c.algorithms || (c.algorithms = ~V.toString().indexOf("BEGIN CERTIFICATE") || ~V.toString().indexOf("BEGIN PUBLIC KEY") ? PUB_KEY_ALGS : ~V.toString().indexOf("BEGIN RSA PUBLIC KEY") ? RSA_KEY_ALGS : HS_ALGS), !~c.algorithms.indexOf(k.header.alg))
      return v(new JsonWebTokenError("invalid algorithm"));
    var oe;
    try {
      oe = jws$1.verify(a, k.header.alg, V);
    } catch (Ce) {
      return v(Ce);
    }
    if (!oe)
      return v(new JsonWebTokenError("invalid signature"));
    var Y = k.payload;
    if (typeof Y.nbf < "u" && !c.ignoreNotBefore) {
      if (typeof Y.nbf != "number")
        return v(new JsonWebTokenError("invalid nbf value"));
      if (Y.nbf > p + (c.clockTolerance || 0))
        return v(new NotBeforeError("jwt not active", new Date(Y.nbf * 1e3)));
    }
    if (typeof Y.exp < "u" && !c.ignoreExpiration) {
      if (typeof Y.exp != "number")
        return v(new JsonWebTokenError("invalid exp value"));
      if (p >= Y.exp + (c.clockTolerance || 0))
        return v(new TokenExpiredError("jwt expired", new Date(Y.exp * 1e3)));
    }
    if (c.audience) {
      var ae = Array.isArray(c.audience) ? c.audience : [c.audience], ne = Array.isArray(Y.aud) ? Y.aud : [Y.aud], fe = ne.some(function(Ce) {
        return ae.some(function(Me) {
          return Me instanceof RegExp ? Me.test(Ce) : Me === Ce;
        });
      });
      if (!fe)
        return v(new JsonWebTokenError("jwt audience invalid. expected: " + ae.join(" or ")));
    }
    if (c.issuer) {
      var ie = typeof c.issuer == "string" && Y.iss !== c.issuer || Array.isArray(c.issuer) && c.issuer.indexOf(Y.iss) === -1;
      if (ie)
        return v(new JsonWebTokenError("jwt issuer invalid. expected: " + c.issuer));
    }
    if (c.subject && Y.sub !== c.subject)
      return v(new JsonWebTokenError("jwt subject invalid. expected: " + c.subject));
    if (c.jwtid && Y.jti !== c.jwtid)
      return v(new JsonWebTokenError("jwt jwtid invalid. expected: " + c.jwtid));
    if (c.nonce && Y.nonce !== c.nonce)
      return v(new JsonWebTokenError("jwt nonce invalid. expected: " + c.nonce));
    if (c.maxAge) {
      if (typeof Y.iat != "number")
        return v(new JsonWebTokenError("iat required when maxAge is specified"));
      var ge = timespan$1(c.maxAge, Y.iat);
      if (typeof ge > "u")
        return v(new JsonWebTokenError('"maxAge" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
      if (p >= ge + (c.clockTolerance || 0))
        return v(new TokenExpiredError("maxAge exceeded", new Date(ge * 1e3)));
    }
    if (c.complete === !0) {
      var be = k.signature;
      return v(null, {
        header: M,
        payload: Y,
        signature: be
      });
    }
    return v(null, Y);
  });
}, INFINITY$2 = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER$2 = 17976931348623157e292, NAN$2 = NaN, argsTag = "[object Arguments]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", stringTag$1 = "[object String]", symbolTag$2 = "[object Symbol]", reTrim$2 = /^\s+|\s+$/g, reIsBadHex$2 = /^[-+]0x[0-9a-f]+$/i, reIsBinary$2 = /^0b[01]+$/i, reIsOctal$2 = /^0o[0-7]+$/i, reIsUint = /^(?:0|[1-9]\d*)$/, freeParseInt$2 = parseInt;
function arrayMap(a, u) {
  for (var c = -1, l = a ? a.length : 0, v = Array(l); ++c < l; )
    v[c] = u(a[c], c, a);
  return v;
}
function baseFindIndex(a, u, c, l) {
  for (var v = a.length, p = c + (l ? 1 : -1); l ? p-- : ++p < v; )
    if (u(a[p], p, a))
      return p;
  return -1;
}
function baseIndexOf(a, u, c) {
  if (u !== u)
    return baseFindIndex(a, baseIsNaN, c);
  for (var l = c - 1, v = a.length; ++l < v; )
    if (a[l] === u)
      return l;
  return -1;
}
function baseIsNaN(a) {
  return a !== a;
}
function baseTimes(a, u) {
  for (var c = -1, l = Array(a); ++c < a; )
    l[c] = u(c);
  return l;
}
function baseValues(a, u) {
  return arrayMap(u, function(c) {
    return a[c];
  });
}
function overArg$1(a, u) {
  return function(c) {
    return a(u(c));
  };
}
var objectProto$6 = Object.prototype, hasOwnProperty$1 = objectProto$6.hasOwnProperty, objectToString$6 = objectProto$6.toString, propertyIsEnumerable = objectProto$6.propertyIsEnumerable, nativeKeys = overArg$1(Object.keys, Object), nativeMax = Math.max;
function arrayLikeKeys(a, u) {
  var c = isArray$3(a) || isArguments(a) ? baseTimes(a.length, String) : [], l = c.length, v = !!l;
  for (var p in a)
    (u || hasOwnProperty$1.call(a, p)) && !(v && (p == "length" || isIndex(p, l))) && c.push(p);
  return c;
}
function baseKeys(a) {
  if (!isPrototype(a))
    return nativeKeys(a);
  var u = [];
  for (var c in Object(a))
    hasOwnProperty$1.call(a, c) && c != "constructor" && u.push(c);
  return u;
}
function isIndex(a, u) {
  return u = u ?? MAX_SAFE_INTEGER, !!u && (typeof a == "number" || reIsUint.test(a)) && a > -1 && a % 1 == 0 && a < u;
}
function isPrototype(a) {
  var u = a && a.constructor, c = typeof u == "function" && u.prototype || objectProto$6;
  return a === c;
}
function includes$1(a, u, c, l) {
  a = isArrayLike(a) ? a : values(a), c = c && !l ? toInteger$2(c) : 0;
  var v = a.length;
  return c < 0 && (c = nativeMax(v + c, 0)), isString$3(a) ? c <= v && a.indexOf(u, c) > -1 : !!v && baseIndexOf(a, u, c) > -1;
}
function isArguments(a) {
  return isArrayLikeObject(a) && hasOwnProperty$1.call(a, "callee") && (!propertyIsEnumerable.call(a, "callee") || objectToString$6.call(a) == argsTag);
}
var isArray$3 = Array.isArray;
function isArrayLike(a) {
  return a != null && isLength(a.length) && !isFunction$1(a);
}
function isArrayLikeObject(a) {
  return isObjectLike$6(a) && isArrayLike(a);
}
function isFunction$1(a) {
  var u = isObject$5(a) ? objectToString$6.call(a) : "";
  return u == funcTag || u == genTag;
}
function isLength(a) {
  return typeof a == "number" && a > -1 && a % 1 == 0 && a <= MAX_SAFE_INTEGER;
}
function isObject$5(a) {
  var u = typeof a;
  return !!a && (u == "object" || u == "function");
}
function isObjectLike$6(a) {
  return !!a && typeof a == "object";
}
function isString$3(a) {
  return typeof a == "string" || !isArray$3(a) && isObjectLike$6(a) && objectToString$6.call(a) == stringTag$1;
}
function isSymbol$2(a) {
  return typeof a == "symbol" || isObjectLike$6(a) && objectToString$6.call(a) == symbolTag$2;
}
function toFinite$2(a) {
  if (!a)
    return a === 0 ? a : 0;
  if (a = toNumber$2(a), a === INFINITY$2 || a === -INFINITY$2) {
    var u = a < 0 ? -1 : 1;
    return u * MAX_INTEGER$2;
  }
  return a === a ? a : 0;
}
function toInteger$2(a) {
  var u = toFinite$2(a), c = u % 1;
  return u === u ? c ? u - c : u : 0;
}
function toNumber$2(a) {
  if (typeof a == "number")
    return a;
  if (isSymbol$2(a))
    return NAN$2;
  if (isObject$5(a)) {
    var u = typeof a.valueOf == "function" ? a.valueOf() : a;
    a = isObject$5(u) ? u + "" : u;
  }
  if (typeof a != "string")
    return a === 0 ? a : +a;
  a = a.replace(reTrim$2, "");
  var c = reIsBinary$2.test(a);
  return c || reIsOctal$2.test(a) ? freeParseInt$2(a.slice(2), c ? 2 : 8) : reIsBadHex$2.test(a) ? NAN$2 : +a;
}
function keys$1(a) {
  return isArrayLike(a) ? arrayLikeKeys(a) : baseKeys(a);
}
function values(a) {
  return a ? baseValues(a, keys$1(a)) : [];
}
var lodash_includes = includes$1, boolTag = "[object Boolean]", objectProto$5 = Object.prototype, objectToString$5 = objectProto$5.toString;
function isBoolean$1(a) {
  return a === !0 || a === !1 || isObjectLike$5(a) && objectToString$5.call(a) == boolTag;
}
function isObjectLike$5(a) {
  return !!a && typeof a == "object";
}
var lodash_isboolean = isBoolean$1, INFINITY$1 = 1 / 0, MAX_INTEGER$1 = 17976931348623157e292, NAN$1 = NaN, symbolTag$1 = "[object Symbol]", reTrim$1 = /^\s+|\s+$/g, reIsBadHex$1 = /^[-+]0x[0-9a-f]+$/i, reIsBinary$1 = /^0b[01]+$/i, reIsOctal$1 = /^0o[0-7]+$/i, freeParseInt$1 = parseInt, objectProto$4 = Object.prototype, objectToString$4 = objectProto$4.toString;
function isInteger$1(a) {
  return typeof a == "number" && a == toInteger$1(a);
}
function isObject$4(a) {
  var u = typeof a;
  return !!a && (u == "object" || u == "function");
}
function isObjectLike$4(a) {
  return !!a && typeof a == "object";
}
function isSymbol$1(a) {
  return typeof a == "symbol" || isObjectLike$4(a) && objectToString$4.call(a) == symbolTag$1;
}
function toFinite$1(a) {
  if (!a)
    return a === 0 ? a : 0;
  if (a = toNumber$1(a), a === INFINITY$1 || a === -INFINITY$1) {
    var u = a < 0 ? -1 : 1;
    return u * MAX_INTEGER$1;
  }
  return a === a ? a : 0;
}
function toInteger$1(a) {
  var u = toFinite$1(a), c = u % 1;
  return u === u ? c ? u - c : u : 0;
}
function toNumber$1(a) {
  if (typeof a == "number")
    return a;
  if (isSymbol$1(a))
    return NAN$1;
  if (isObject$4(a)) {
    var u = typeof a.valueOf == "function" ? a.valueOf() : a;
    a = isObject$4(u) ? u + "" : u;
  }
  if (typeof a != "string")
    return a === 0 ? a : +a;
  a = a.replace(reTrim$1, "");
  var c = reIsBinary$1.test(a);
  return c || reIsOctal$1.test(a) ? freeParseInt$1(a.slice(2), c ? 2 : 8) : reIsBadHex$1.test(a) ? NAN$1 : +a;
}
var lodash_isinteger = isInteger$1, numberTag = "[object Number]", objectProto$3 = Object.prototype, objectToString$3 = objectProto$3.toString;
function isObjectLike$3(a) {
  return !!a && typeof a == "object";
}
function isNumber$2(a) {
  return typeof a == "number" || isObjectLike$3(a) && objectToString$3.call(a) == numberTag;
}
var lodash_isnumber = isNumber$2, objectTag = "[object Object]";
function isHostObject(a) {
  var u = !1;
  if (a != null && typeof a.toString != "function")
    try {
      u = !!(a + "");
    } catch {
    }
  return u;
}
function overArg(a, u) {
  return function(c) {
    return a(u(c));
  };
}
var funcProto = Function.prototype, objectProto$2 = Object.prototype, funcToString = funcProto.toString, hasOwnProperty = objectProto$2.hasOwnProperty, objectCtorString = funcToString.call(Object), objectToString$2 = objectProto$2.toString, getPrototype = overArg(Object.getPrototypeOf, Object);
function isObjectLike$2(a) {
  return !!a && typeof a == "object";
}
function isPlainObject$2(a) {
  if (!isObjectLike$2(a) || objectToString$2.call(a) != objectTag || isHostObject(a))
    return !1;
  var u = getPrototype(a);
  if (u === null)
    return !0;
  var c = hasOwnProperty.call(u, "constructor") && u.constructor;
  return typeof c == "function" && c instanceof c && funcToString.call(c) == objectCtorString;
}
var lodash_isplainobject = isPlainObject$2, stringTag = "[object String]", objectProto$1 = Object.prototype, objectToString$1 = objectProto$1.toString, isArray$2 = Array.isArray;
function isObjectLike$1(a) {
  return !!a && typeof a == "object";
}
function isString$2(a) {
  return typeof a == "string" || !isArray$2(a) && isObjectLike$1(a) && objectToString$1.call(a) == stringTag;
}
var lodash_isstring = isString$2, FUNC_ERROR_TEXT = "Expected a function", INFINITY = 1 / 0, MAX_INTEGER = 17976931348623157e292, NAN = NaN, symbolTag = "[object Symbol]", reTrim = /^\s+|\s+$/g, reIsBadHex = /^[-+]0x[0-9a-f]+$/i, reIsBinary = /^0b[01]+$/i, reIsOctal = /^0o[0-7]+$/i, freeParseInt = parseInt, objectProto = Object.prototype, objectToString = objectProto.toString;
function before(a, u) {
  var c;
  if (typeof u != "function")
    throw new TypeError(FUNC_ERROR_TEXT);
  return a = toInteger(a), function() {
    return --a > 0 && (c = u.apply(this, arguments)), a <= 1 && (u = void 0), c;
  };
}
function once$1(a) {
  return before(2, a);
}
function isObject$3(a) {
  var u = typeof a;
  return !!a && (u == "object" || u == "function");
}
function isObjectLike(a) {
  return !!a && typeof a == "object";
}
function isSymbol(a) {
  return typeof a == "symbol" || isObjectLike(a) && objectToString.call(a) == symbolTag;
}
function toFinite(a) {
  if (!a)
    return a === 0 ? a : 0;
  if (a = toNumber(a), a === INFINITY || a === -INFINITY) {
    var u = a < 0 ? -1 : 1;
    return u * MAX_INTEGER;
  }
  return a === a ? a : 0;
}
function toInteger(a) {
  var u = toFinite(a), c = u % 1;
  return u === u ? c ? u - c : u : 0;
}
function toNumber(a) {
  if (typeof a == "number")
    return a;
  if (isSymbol(a))
    return NAN;
  if (isObject$3(a)) {
    var u = typeof a.valueOf == "function" ? a.valueOf() : a;
    a = isObject$3(u) ? u + "" : u;
  }
  if (typeof a != "string")
    return a === 0 ? a : +a;
  a = a.replace(reTrim, "");
  var c = reIsBinary.test(a);
  return c || reIsOctal.test(a) ? freeParseInt(a.slice(2), c ? 2 : 8) : reIsBadHex.test(a) ? NAN : +a;
}
var lodash_once = once$1, timespan = timespan$2, PS_SUPPORTED = psSupported, jws = jws$3, includes = lodash_includes, isBoolean = lodash_isboolean, isInteger = lodash_isinteger, isNumber$1 = lodash_isnumber, isPlainObject$1 = lodash_isplainobject, isString$1 = lodash_isstring, once = lodash_once, SUPPORTED_ALGS = ["RS256", "RS384", "RS512", "ES256", "ES384", "ES512", "HS256", "HS384", "HS512", "none"];
PS_SUPPORTED && SUPPORTED_ALGS.splice(3, 0, "PS256", "PS384", "PS512");
var sign_options_schema = {
  expiresIn: { isValid: function(a) {
    return isInteger(a) || isString$1(a) && a;
  }, message: '"expiresIn" should be a number of seconds or string representing a timespan' },
  notBefore: { isValid: function(a) {
    return isInteger(a) || isString$1(a) && a;
  }, message: '"notBefore" should be a number of seconds or string representing a timespan' },
  audience: { isValid: function(a) {
    return isString$1(a) || Array.isArray(a);
  }, message: '"audience" must be a string or array' },
  algorithm: { isValid: includes.bind(null, SUPPORTED_ALGS), message: '"algorithm" must be a valid string enum value' },
  header: { isValid: isPlainObject$1, message: '"header" must be an object' },
  encoding: { isValid: isString$1, message: '"encoding" must be a string' },
  issuer: { isValid: isString$1, message: '"issuer" must be a string' },
  subject: { isValid: isString$1, message: '"subject" must be a string' },
  jwtid: { isValid: isString$1, message: '"jwtid" must be a string' },
  noTimestamp: { isValid: isBoolean, message: '"noTimestamp" must be a boolean' },
  keyid: { isValid: isString$1, message: '"keyid" must be a string' },
  mutatePayload: { isValid: isBoolean, message: '"mutatePayload" must be a boolean' }
}, registered_claims_schema = {
  iat: { isValid: isNumber$1, message: '"iat" should be a number of seconds' },
  exp: { isValid: isNumber$1, message: '"exp" should be a number of seconds' },
  nbf: { isValid: isNumber$1, message: '"nbf" should be a number of seconds' }
};
function validate(a, u, c, l) {
  if (!isPlainObject$1(c))
    throw new Error('Expected "' + l + '" to be a plain object.');
  Object.keys(c).forEach(function(v) {
    var p = a[v];
    if (!p) {
      if (!u)
        throw new Error('"' + v + '" is not allowed in "' + l + '"');
      return;
    }
    if (!p.isValid(c[v]))
      throw new Error(p.message);
  });
}
function validateOptions(a) {
  return validate(sign_options_schema, !1, a, "options");
}
function validatePayload(a) {
  return validate(registered_claims_schema, !0, a, "payload");
}
var options_to_payload = {
  audience: "aud",
  issuer: "iss",
  subject: "sub",
  jwtid: "jti"
}, options_for_objects = [
  "expiresIn",
  "notBefore",
  "noTimestamp",
  "audience",
  "issuer",
  "subject",
  "jwtid"
], sign = function(a, u, c, l) {
  typeof c == "function" ? (l = c, c = {}) : c = c || {};
  var v = typeof a == "object" && !Buffer$O.isBuffer(a), p = Object.assign({
    alg: c.algorithm || "HS256",
    typ: v ? "JWT" : void 0,
    kid: c.keyid
  }, c.header);
  function _(F) {
    if (l)
      return l(F);
    throw F;
  }
  if (!u && c.algorithm !== "none")
    return _(new Error("secretOrPrivateKey must have a value"));
  if (typeof a > "u")
    return _(new Error("payload is required"));
  if (v) {
    try {
      validatePayload(a);
    } catch (F) {
      return _(F);
    }
    c.mutatePayload || (a = Object.assign({}, a));
  } else {
    var k = options_for_objects.filter(function(F) {
      return typeof c[F] < "u";
    });
    if (k.length > 0)
      return _(new Error("invalid " + k.join(",") + " option for " + typeof a + " payload"));
  }
  if (typeof a.exp < "u" && typeof c.expiresIn < "u")
    return _(new Error('Bad "options.expiresIn" option the payload already has an "exp" property.'));
  if (typeof a.nbf < "u" && typeof c.notBefore < "u")
    return _(new Error('Bad "options.notBefore" option the payload already has an "nbf" property.'));
  try {
    validateOptions(c);
  } catch (F) {
    return _(F);
  }
  var M = a.iat || Math.floor(Date.now() / 1e3);
  if (c.noTimestamp ? delete a.iat : v && (a.iat = M), typeof c.notBefore < "u") {
    try {
      a.nbf = timespan(c.notBefore, M);
    } catch (F) {
      return _(F);
    }
    if (typeof a.nbf > "u")
      return _(new Error('"notBefore" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
  }
  if (typeof c.expiresIn < "u" && typeof a == "object") {
    try {
      a.exp = timespan(c.expiresIn, M);
    } catch (F) {
      return _(F);
    }
    if (typeof a.exp > "u")
      return _(new Error('"expiresIn" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
  }
  Object.keys(options_to_payload).forEach(function(F) {
    var V = options_to_payload[F];
    if (typeof c[F] < "u") {
      if (typeof a[V] < "u")
        return _(new Error('Bad "options.' + F + '" option. The payload already has an "' + V + '" property.'));
      a[V] = c[F];
    }
  });
  var L = c.encoding || "utf8";
  if (typeof l == "function")
    l = l && once(l), jws.createSign({
      header: p,
      privateKey: u,
      payload: a,
      encoding: L
    }).once("error", l).once("done", function(F) {
      l(null, F);
    });
  else
    return jws.sign({ header: p, payload: a, secret: u, encoding: L });
}, jsonwebtoken = {
  decode: decode$1,
  verify,
  sign,
  JsonWebTokenError: JsonWebTokenError_1,
  NotBeforeError: NotBeforeError_1,
  TokenExpiredError: TokenExpiredError_1
}, __createBinding = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(a, u, c, l) {
  l === void 0 && (l = c), Object.defineProperty(a, l, { enumerable: !0, get: function() {
    return u[c];
  } });
} : function(a, u, c, l) {
  l === void 0 && (l = c), a[l] = u[c];
}), __setModuleDefault = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(a, u) {
  Object.defineProperty(a, "default", { enumerable: !0, value: u });
} : function(a, u) {
  a.default = u;
}), __importStar = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(a) {
  if (a && a.__esModule)
    return a;
  var u = {};
  if (a != null)
    for (var c in a)
      c !== "default" && Object.prototype.hasOwnProperty.call(a, c) && __createBinding(u, a, c);
  return __setModuleDefault(u, a), u;
};
Object.defineProperty(AccessToken$1, "__esModule", { value: !0 });
AccessToken$1.TokenVerifier = AccessToken$1.AccessToken = void 0;
const jwt = __importStar(jsonwebtoken), defaultTTL = 6 * 60 * 60;
class AccessToken {
  /**
   * Creates a new AccessToken
   * @param apiKey API Key, can be set in env LIVEKIT_API_KEY
   * @param apiSecret Secret, can be set in env LIVEKIT_API_SECRET
   */
  constructor(u, c, l) {
    if (u || (u = process$1.env.LIVEKIT_API_KEY), c || (c = process$1.env.LIVEKIT_API_SECRET), !u || !c)
      throw Error("api-key and api-secret must be set");
    this.apiKey = u, this.apiSecret = c, this.grants = {}, this.identity = l == null ? void 0 : l.identity, this.ttl = (l == null ? void 0 : l.ttl) || defaultTTL, l != null && l.metadata && (this.metadata = l.metadata), l != null && l.name && (this.name = l.name);
  }
  /**
   * Adds a video grant to this token.
   * @param grant
   */
  addGrant(u) {
    this.grants.video = u;
  }
  /**
   * Set metadata to be passed to the Participant, used only when joining the room
   */
  set metadata(u) {
    this.grants.metadata = u;
  }
  set name(u) {
    this.grants.name = u;
  }
  get sha256() {
    return this.grants.sha256;
  }
  set sha256(u) {
    this.grants.sha256 = u;
  }
  /**
   * @returns JWT encoded token
   */
  toJwt() {
    var u;
    const c = {
      issuer: this.apiKey,
      expiresIn: this.ttl,
      notBefore: 0
    };
    if (this.identity)
      c.subject = this.identity, c.jwtid = this.identity;
    else if (!((u = this.grants.video) === null || u === void 0) && u.roomJoin)
      throw Error("identity is required for join but not set");
    return jwt.sign(this.grants, this.apiSecret, c);
  }
}
AccessToken$1.AccessToken = AccessToken;
class TokenVerifier {
  constructor(u, c) {
    this.apiKey = u, this.apiSecret = c;
  }
  verify(u) {
    const c = jwt.verify(u, this.apiSecret, { issuer: this.apiKey });
    if (!c)
      throw Error("invalid token");
    return c;
  }
}
AccessToken$1.TokenVerifier = TokenVerifier;
var EgressClient$1 = {}, livekit_egress = {};
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(J) {
    return J && J.__esModule ? J : { default: J };
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.AutoTrackEgress = a.SegmentsInfo = a.FileInfo = a.StreamInfo = a.StreamInfoList = a.EgressInfo = a.StopEgressRequest = a.ListEgressResponse = a.ListEgressRequest = a.UpdateStreamRequest = a.UpdateLayoutRequest = a.EncodingOptions = a.StreamOutput = a.AliOSSUpload = a.AzureBlobUpload = a.GCPUpload = a.S3Upload_MetadataEntry = a.S3Upload = a.DirectFileOutput = a.SegmentedFileOutput = a.EncodedFileOutput = a.WebEgressRequest = a.TrackEgressRequest = a.TrackCompositeEgressRequest = a.RoomCompositeEgressRequest = a.streamInfo_StatusToJSON = a.streamInfo_StatusFromJSON = a.StreamInfo_Status = a.egressStatusToJSON = a.egressStatusFromJSON = a.EgressStatus = a.encodingOptionsPresetToJSON = a.encodingOptionsPresetFromJSON = a.EncodingOptionsPreset = a.videoCodecToJSON = a.videoCodecFromJSON = a.VideoCodec = a.audioCodecToJSON = a.audioCodecFromJSON = a.AudioCodec = a.segmentedFileProtocolToJSON = a.segmentedFileProtocolFromJSON = a.SegmentedFileProtocol = a.streamProtocolToJSON = a.streamProtocolFromJSON = a.StreamProtocol = a.encodedFileTypeToJSON = a.encodedFileTypeFromJSON = a.EncodedFileType = a.protobufPackage = void 0;
  const c = u(umdExports), l = u(minimal);
  a.protobufPackage = "livekit";
  var v;
  (function(J) {
    J[J.DEFAULT_FILETYPE = 0] = "DEFAULT_FILETYPE", J[J.MP4 = 1] = "MP4", J[J.OGG = 2] = "OGG", J[J.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(v = a.EncodedFileType || (a.EncodedFileType = {}));
  function p(J) {
    switch (J) {
      case 0:
      case "DEFAULT_FILETYPE":
        return v.DEFAULT_FILETYPE;
      case 1:
      case "MP4":
        return v.MP4;
      case 2:
      case "OGG":
        return v.OGG;
      case -1:
      case "UNRECOGNIZED":
      default:
        return v.UNRECOGNIZED;
    }
  }
  a.encodedFileTypeFromJSON = p;
  function _(J) {
    switch (J) {
      case v.DEFAULT_FILETYPE:
        return "DEFAULT_FILETYPE";
      case v.MP4:
        return "MP4";
      case v.OGG:
        return "OGG";
      case v.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.encodedFileTypeToJSON = _;
  var k;
  (function(J) {
    J[J.DEFAULT_PROTOCOL = 0] = "DEFAULT_PROTOCOL", J[J.RTMP = 1] = "RTMP", J[J.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(k = a.StreamProtocol || (a.StreamProtocol = {}));
  function M(J) {
    switch (J) {
      case 0:
      case "DEFAULT_PROTOCOL":
        return k.DEFAULT_PROTOCOL;
      case 1:
      case "RTMP":
        return k.RTMP;
      case -1:
      case "UNRECOGNIZED":
      default:
        return k.UNRECOGNIZED;
    }
  }
  a.streamProtocolFromJSON = M;
  function L(J) {
    switch (J) {
      case k.DEFAULT_PROTOCOL:
        return "DEFAULT_PROTOCOL";
      case k.RTMP:
        return "RTMP";
      case k.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.streamProtocolToJSON = L;
  var F;
  (function(J) {
    J[J.DEFAULT_SEGMENTED_FILE_PROTOCOL = 0] = "DEFAULT_SEGMENTED_FILE_PROTOCOL", J[J.HLS_PROTOCOL = 1] = "HLS_PROTOCOL", J[J.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(F = a.SegmentedFileProtocol || (a.SegmentedFileProtocol = {}));
  function V(J) {
    switch (J) {
      case 0:
      case "DEFAULT_SEGMENTED_FILE_PROTOCOL":
        return F.DEFAULT_SEGMENTED_FILE_PROTOCOL;
      case 1:
      case "HLS_PROTOCOL":
        return F.HLS_PROTOCOL;
      case -1:
      case "UNRECOGNIZED":
      default:
        return F.UNRECOGNIZED;
    }
  }
  a.segmentedFileProtocolFromJSON = V;
  function X(J) {
    switch (J) {
      case F.DEFAULT_SEGMENTED_FILE_PROTOCOL:
        return "DEFAULT_SEGMENTED_FILE_PROTOCOL";
      case F.HLS_PROTOCOL:
        return "HLS_PROTOCOL";
      case F.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.segmentedFileProtocolToJSON = X;
  var oe;
  (function(J) {
    J[J.DEFAULT_AC = 0] = "DEFAULT_AC", J[J.OPUS = 1] = "OPUS", J[J.AAC = 2] = "AAC", J[J.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(oe = a.AudioCodec || (a.AudioCodec = {}));
  function Y(J) {
    switch (J) {
      case 0:
      case "DEFAULT_AC":
        return oe.DEFAULT_AC;
      case 1:
      case "OPUS":
        return oe.OPUS;
      case 2:
      case "AAC":
        return oe.AAC;
      case -1:
      case "UNRECOGNIZED":
      default:
        return oe.UNRECOGNIZED;
    }
  }
  a.audioCodecFromJSON = Y;
  function ae(J) {
    switch (J) {
      case oe.DEFAULT_AC:
        return "DEFAULT_AC";
      case oe.OPUS:
        return "OPUS";
      case oe.AAC:
        return "AAC";
      case oe.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.audioCodecToJSON = ae;
  var ne;
  (function(J) {
    J[J.DEFAULT_VC = 0] = "DEFAULT_VC", J[J.H264_BASELINE = 1] = "H264_BASELINE", J[J.H264_MAIN = 2] = "H264_MAIN", J[J.H264_HIGH = 3] = "H264_HIGH", J[J.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(ne = a.VideoCodec || (a.VideoCodec = {}));
  function fe(J) {
    switch (J) {
      case 0:
      case "DEFAULT_VC":
        return ne.DEFAULT_VC;
      case 1:
      case "H264_BASELINE":
        return ne.H264_BASELINE;
      case 2:
      case "H264_MAIN":
        return ne.H264_MAIN;
      case 3:
      case "H264_HIGH":
        return ne.H264_HIGH;
      case -1:
      case "UNRECOGNIZED":
      default:
        return ne.UNRECOGNIZED;
    }
  }
  a.videoCodecFromJSON = fe;
  function ie(J) {
    switch (J) {
      case ne.DEFAULT_VC:
        return "DEFAULT_VC";
      case ne.H264_BASELINE:
        return "H264_BASELINE";
      case ne.H264_MAIN:
        return "H264_MAIN";
      case ne.H264_HIGH:
        return "H264_HIGH";
      case ne.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.videoCodecToJSON = ie;
  var ge;
  (function(J) {
    J[J.H264_720P_30 = 0] = "H264_720P_30", J[J.H264_720P_60 = 1] = "H264_720P_60", J[J.H264_1080P_30 = 2] = "H264_1080P_30", J[J.H264_1080P_60 = 3] = "H264_1080P_60", J[J.PORTRAIT_H264_720P_30 = 4] = "PORTRAIT_H264_720P_30", J[J.PORTRAIT_H264_720P_60 = 5] = "PORTRAIT_H264_720P_60", J[J.PORTRAIT_H264_1080P_30 = 6] = "PORTRAIT_H264_1080P_30", J[J.PORTRAIT_H264_1080P_60 = 7] = "PORTRAIT_H264_1080P_60", J[J.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(ge = a.EncodingOptionsPreset || (a.EncodingOptionsPreset = {}));
  function be(J) {
    switch (J) {
      case 0:
      case "H264_720P_30":
        return ge.H264_720P_30;
      case 1:
      case "H264_720P_60":
        return ge.H264_720P_60;
      case 2:
      case "H264_1080P_30":
        return ge.H264_1080P_30;
      case 3:
      case "H264_1080P_60":
        return ge.H264_1080P_60;
      case 4:
      case "PORTRAIT_H264_720P_30":
        return ge.PORTRAIT_H264_720P_30;
      case 5:
      case "PORTRAIT_H264_720P_60":
        return ge.PORTRAIT_H264_720P_60;
      case 6:
      case "PORTRAIT_H264_1080P_30":
        return ge.PORTRAIT_H264_1080P_30;
      case 7:
      case "PORTRAIT_H264_1080P_60":
        return ge.PORTRAIT_H264_1080P_60;
      case -1:
      case "UNRECOGNIZED":
      default:
        return ge.UNRECOGNIZED;
    }
  }
  a.encodingOptionsPresetFromJSON = be;
  function Ce(J) {
    switch (J) {
      case ge.H264_720P_30:
        return "H264_720P_30";
      case ge.H264_720P_60:
        return "H264_720P_60";
      case ge.H264_1080P_30:
        return "H264_1080P_30";
      case ge.H264_1080P_60:
        return "H264_1080P_60";
      case ge.PORTRAIT_H264_720P_30:
        return "PORTRAIT_H264_720P_30";
      case ge.PORTRAIT_H264_720P_60:
        return "PORTRAIT_H264_720P_60";
      case ge.PORTRAIT_H264_1080P_30:
        return "PORTRAIT_H264_1080P_30";
      case ge.PORTRAIT_H264_1080P_60:
        return "PORTRAIT_H264_1080P_60";
      case ge.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.encodingOptionsPresetToJSON = Ce;
  var Me;
  (function(J) {
    J[J.EGRESS_STARTING = 0] = "EGRESS_STARTING", J[J.EGRESS_ACTIVE = 1] = "EGRESS_ACTIVE", J[J.EGRESS_ENDING = 2] = "EGRESS_ENDING", J[J.EGRESS_COMPLETE = 3] = "EGRESS_COMPLETE", J[J.EGRESS_FAILED = 4] = "EGRESS_FAILED", J[J.EGRESS_ABORTED = 5] = "EGRESS_ABORTED", J[J.EGRESS_LIMIT_REACHED = 6] = "EGRESS_LIMIT_REACHED", J[J.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(Me = a.EgressStatus || (a.EgressStatus = {}));
  function Be(J) {
    switch (J) {
      case 0:
      case "EGRESS_STARTING":
        return Me.EGRESS_STARTING;
      case 1:
      case "EGRESS_ACTIVE":
        return Me.EGRESS_ACTIVE;
      case 2:
      case "EGRESS_ENDING":
        return Me.EGRESS_ENDING;
      case 3:
      case "EGRESS_COMPLETE":
        return Me.EGRESS_COMPLETE;
      case 4:
      case "EGRESS_FAILED":
        return Me.EGRESS_FAILED;
      case 5:
      case "EGRESS_ABORTED":
        return Me.EGRESS_ABORTED;
      case 6:
      case "EGRESS_LIMIT_REACHED":
        return Me.EGRESS_LIMIT_REACHED;
      case -1:
      case "UNRECOGNIZED":
      default:
        return Me.UNRECOGNIZED;
    }
  }
  a.egressStatusFromJSON = Be;
  function Ae(J) {
    switch (J) {
      case Me.EGRESS_STARTING:
        return "EGRESS_STARTING";
      case Me.EGRESS_ACTIVE:
        return "EGRESS_ACTIVE";
      case Me.EGRESS_ENDING:
        return "EGRESS_ENDING";
      case Me.EGRESS_COMPLETE:
        return "EGRESS_COMPLETE";
      case Me.EGRESS_FAILED:
        return "EGRESS_FAILED";
      case Me.EGRESS_ABORTED:
        return "EGRESS_ABORTED";
      case Me.EGRESS_LIMIT_REACHED:
        return "EGRESS_LIMIT_REACHED";
      case Me.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.egressStatusToJSON = Ae;
  var Z;
  (function(J) {
    J[J.ACTIVE = 0] = "ACTIVE", J[J.FINISHED = 1] = "FINISHED", J[J.FAILED = 2] = "FAILED", J[J.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(Z = a.StreamInfo_Status || (a.StreamInfo_Status = {}));
  function z(J) {
    switch (J) {
      case 0:
      case "ACTIVE":
        return Z.ACTIVE;
      case 1:
      case "FINISHED":
        return Z.FINISHED;
      case 2:
      case "FAILED":
        return Z.FAILED;
      case -1:
      case "UNRECOGNIZED":
      default:
        return Z.UNRECOGNIZED;
    }
  }
  a.streamInfo_StatusFromJSON = z;
  function P(J) {
    switch (J) {
      case Z.ACTIVE:
        return "ACTIVE";
      case Z.FINISHED:
        return "FINISHED";
      case Z.FAILED:
        return "FAILED";
      case Z.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.streamInfo_StatusToJSON = P;
  function S() {
    return {
      roomName: "",
      layout: "",
      audioOnly: !1,
      videoOnly: !1,
      customBaseUrl: "",
      file: void 0,
      stream: void 0,
      segments: void 0,
      preset: void 0,
      advanced: void 0
    };
  }
  a.RoomCompositeEgressRequest = {
    encode(J, ye = l.default.Writer.create()) {
      return J.roomName !== void 0 && J.roomName !== "" && ye.uint32(10).string(J.roomName), J.layout !== void 0 && J.layout !== "" && ye.uint32(18).string(J.layout), J.audioOnly === !0 && ye.uint32(24).bool(J.audioOnly), J.videoOnly === !0 && ye.uint32(32).bool(J.videoOnly), J.customBaseUrl !== void 0 && J.customBaseUrl !== "" && ye.uint32(42).string(J.customBaseUrl), J.file !== void 0 && a.EncodedFileOutput.encode(J.file, ye.uint32(50).fork()).ldelim(), J.stream !== void 0 && a.StreamOutput.encode(J.stream, ye.uint32(58).fork()).ldelim(), J.segments !== void 0 && a.SegmentedFileOutput.encode(J.segments, ye.uint32(82).fork()).ldelim(), J.preset !== void 0 && ye.uint32(64).int32(J.preset), J.advanced !== void 0 && a.EncodingOptions.encode(J.advanced, ye.uint32(74).fork()).ldelim(), ye;
    },
    decode(J, ye) {
      const we = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let We = ye === void 0 ? we.len : we.pos + ye;
      const Re = S();
      for (; we.pos < We; ) {
        const q = we.uint32();
        switch (q >>> 3) {
          case 1:
            Re.roomName = we.string();
            break;
          case 2:
            Re.layout = we.string();
            break;
          case 3:
            Re.audioOnly = we.bool();
            break;
          case 4:
            Re.videoOnly = we.bool();
            break;
          case 5:
            Re.customBaseUrl = we.string();
            break;
          case 6:
            Re.file = a.EncodedFileOutput.decode(we, we.uint32());
            break;
          case 7:
            Re.stream = a.StreamOutput.decode(we, we.uint32());
            break;
          case 10:
            Re.segments = a.SegmentedFileOutput.decode(we, we.uint32());
            break;
          case 8:
            Re.preset = we.int32();
            break;
          case 9:
            Re.advanced = a.EncodingOptions.decode(we, we.uint32());
            break;
          default:
            we.skipType(q & 7);
            break;
        }
      }
      return Re;
    },
    fromJSON(J) {
      return {
        roomName: Ge(J.roomName) ? String(J.roomName) : "",
        layout: Ge(J.layout) ? String(J.layout) : "",
        audioOnly: Ge(J.audioOnly) ? !!J.audioOnly : !1,
        videoOnly: Ge(J.videoOnly) ? !!J.videoOnly : !1,
        customBaseUrl: Ge(J.customBaseUrl) ? String(J.customBaseUrl) : "",
        file: Ge(J.file) ? a.EncodedFileOutput.fromJSON(J.file) : void 0,
        stream: Ge(J.stream) ? a.StreamOutput.fromJSON(J.stream) : void 0,
        segments: Ge(J.segments) ? a.SegmentedFileOutput.fromJSON(J.segments) : void 0,
        preset: Ge(J.preset) ? be(J.preset) : void 0,
        advanced: Ge(J.advanced) ? a.EncodingOptions.fromJSON(J.advanced) : void 0
      };
    },
    toJSON(J) {
      const ye = {};
      return J.roomName !== void 0 && (ye.roomName = J.roomName), J.layout !== void 0 && (ye.layout = J.layout), J.audioOnly !== void 0 && (ye.audioOnly = J.audioOnly), J.videoOnly !== void 0 && (ye.videoOnly = J.videoOnly), J.customBaseUrl !== void 0 && (ye.customBaseUrl = J.customBaseUrl), J.file !== void 0 && (ye.file = J.file ? a.EncodedFileOutput.toJSON(J.file) : void 0), J.stream !== void 0 && (ye.stream = J.stream ? a.StreamOutput.toJSON(J.stream) : void 0), J.segments !== void 0 && (ye.segments = J.segments ? a.SegmentedFileOutput.toJSON(J.segments) : void 0), J.preset !== void 0 && (ye.preset = J.preset !== void 0 ? Ce(J.preset) : void 0), J.advanced !== void 0 && (ye.advanced = J.advanced ? a.EncodingOptions.toJSON(J.advanced) : void 0), ye;
    },
    fromPartial(J) {
      var ye, we, We, Re, q, ke;
      const de = S();
      return de.roomName = (ye = J.roomName) !== null && ye !== void 0 ? ye : "", de.layout = (we = J.layout) !== null && we !== void 0 ? we : "", de.audioOnly = (We = J.audioOnly) !== null && We !== void 0 ? We : !1, de.videoOnly = (Re = J.videoOnly) !== null && Re !== void 0 ? Re : !1, de.customBaseUrl = (q = J.customBaseUrl) !== null && q !== void 0 ? q : "", de.file = J.file !== void 0 && J.file !== null ? a.EncodedFileOutput.fromPartial(J.file) : void 0, de.stream = J.stream !== void 0 && J.stream !== null ? a.StreamOutput.fromPartial(J.stream) : void 0, de.segments = J.segments !== void 0 && J.segments !== null ? a.SegmentedFileOutput.fromPartial(J.segments) : void 0, de.preset = (ke = J.preset) !== null && ke !== void 0 ? ke : void 0, de.advanced = J.advanced !== void 0 && J.advanced !== null ? a.EncodingOptions.fromPartial(J.advanced) : void 0, de;
    }
  };
  function E() {
    return {
      roomName: "",
      audioTrackId: "",
      videoTrackId: "",
      file: void 0,
      stream: void 0,
      segments: void 0,
      preset: void 0,
      advanced: void 0
    };
  }
  a.TrackCompositeEgressRequest = {
    encode(J, ye = l.default.Writer.create()) {
      return J.roomName !== void 0 && J.roomName !== "" && ye.uint32(10).string(J.roomName), J.audioTrackId !== void 0 && J.audioTrackId !== "" && ye.uint32(18).string(J.audioTrackId), J.videoTrackId !== void 0 && J.videoTrackId !== "" && ye.uint32(26).string(J.videoTrackId), J.file !== void 0 && a.EncodedFileOutput.encode(J.file, ye.uint32(34).fork()).ldelim(), J.stream !== void 0 && a.StreamOutput.encode(J.stream, ye.uint32(42).fork()).ldelim(), J.segments !== void 0 && a.SegmentedFileOutput.encode(J.segments, ye.uint32(66).fork()).ldelim(), J.preset !== void 0 && ye.uint32(48).int32(J.preset), J.advanced !== void 0 && a.EncodingOptions.encode(J.advanced, ye.uint32(58).fork()).ldelim(), ye;
    },
    decode(J, ye) {
      const we = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let We = ye === void 0 ? we.len : we.pos + ye;
      const Re = E();
      for (; we.pos < We; ) {
        const q = we.uint32();
        switch (q >>> 3) {
          case 1:
            Re.roomName = we.string();
            break;
          case 2:
            Re.audioTrackId = we.string();
            break;
          case 3:
            Re.videoTrackId = we.string();
            break;
          case 4:
            Re.file = a.EncodedFileOutput.decode(we, we.uint32());
            break;
          case 5:
            Re.stream = a.StreamOutput.decode(we, we.uint32());
            break;
          case 8:
            Re.segments = a.SegmentedFileOutput.decode(we, we.uint32());
            break;
          case 6:
            Re.preset = we.int32();
            break;
          case 7:
            Re.advanced = a.EncodingOptions.decode(we, we.uint32());
            break;
          default:
            we.skipType(q & 7);
            break;
        }
      }
      return Re;
    },
    fromJSON(J) {
      return {
        roomName: Ge(J.roomName) ? String(J.roomName) : "",
        audioTrackId: Ge(J.audioTrackId) ? String(J.audioTrackId) : "",
        videoTrackId: Ge(J.videoTrackId) ? String(J.videoTrackId) : "",
        file: Ge(J.file) ? a.EncodedFileOutput.fromJSON(J.file) : void 0,
        stream: Ge(J.stream) ? a.StreamOutput.fromJSON(J.stream) : void 0,
        segments: Ge(J.segments) ? a.SegmentedFileOutput.fromJSON(J.segments) : void 0,
        preset: Ge(J.preset) ? be(J.preset) : void 0,
        advanced: Ge(J.advanced) ? a.EncodingOptions.fromJSON(J.advanced) : void 0
      };
    },
    toJSON(J) {
      const ye = {};
      return J.roomName !== void 0 && (ye.roomName = J.roomName), J.audioTrackId !== void 0 && (ye.audioTrackId = J.audioTrackId), J.videoTrackId !== void 0 && (ye.videoTrackId = J.videoTrackId), J.file !== void 0 && (ye.file = J.file ? a.EncodedFileOutput.toJSON(J.file) : void 0), J.stream !== void 0 && (ye.stream = J.stream ? a.StreamOutput.toJSON(J.stream) : void 0), J.segments !== void 0 && (ye.segments = J.segments ? a.SegmentedFileOutput.toJSON(J.segments) : void 0), J.preset !== void 0 && (ye.preset = J.preset !== void 0 ? Ce(J.preset) : void 0), J.advanced !== void 0 && (ye.advanced = J.advanced ? a.EncodingOptions.toJSON(J.advanced) : void 0), ye;
    },
    fromPartial(J) {
      var ye, we, We, Re;
      const q = E();
      return q.roomName = (ye = J.roomName) !== null && ye !== void 0 ? ye : "", q.audioTrackId = (we = J.audioTrackId) !== null && we !== void 0 ? we : "", q.videoTrackId = (We = J.videoTrackId) !== null && We !== void 0 ? We : "", q.file = J.file !== void 0 && J.file !== null ? a.EncodedFileOutput.fromPartial(J.file) : void 0, q.stream = J.stream !== void 0 && J.stream !== null ? a.StreamOutput.fromPartial(J.stream) : void 0, q.segments = J.segments !== void 0 && J.segments !== null ? a.SegmentedFileOutput.fromPartial(J.segments) : void 0, q.preset = (Re = J.preset) !== null && Re !== void 0 ? Re : void 0, q.advanced = J.advanced !== void 0 && J.advanced !== null ? a.EncodingOptions.fromPartial(J.advanced) : void 0, q;
    }
  };
  function I() {
    return { roomName: "", trackId: "", file: void 0, websocketUrl: void 0 };
  }
  a.TrackEgressRequest = {
    encode(J, ye = l.default.Writer.create()) {
      return J.roomName !== void 0 && J.roomName !== "" && ye.uint32(10).string(J.roomName), J.trackId !== void 0 && J.trackId !== "" && ye.uint32(18).string(J.trackId), J.file !== void 0 && a.DirectFileOutput.encode(J.file, ye.uint32(26).fork()).ldelim(), J.websocketUrl !== void 0 && ye.uint32(34).string(J.websocketUrl), ye;
    },
    decode(J, ye) {
      const we = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let We = ye === void 0 ? we.len : we.pos + ye;
      const Re = I();
      for (; we.pos < We; ) {
        const q = we.uint32();
        switch (q >>> 3) {
          case 1:
            Re.roomName = we.string();
            break;
          case 2:
            Re.trackId = we.string();
            break;
          case 3:
            Re.file = a.DirectFileOutput.decode(we, we.uint32());
            break;
          case 4:
            Re.websocketUrl = we.string();
            break;
          default:
            we.skipType(q & 7);
            break;
        }
      }
      return Re;
    },
    fromJSON(J) {
      return {
        roomName: Ge(J.roomName) ? String(J.roomName) : "",
        trackId: Ge(J.trackId) ? String(J.trackId) : "",
        file: Ge(J.file) ? a.DirectFileOutput.fromJSON(J.file) : void 0,
        websocketUrl: Ge(J.websocketUrl) ? String(J.websocketUrl) : void 0
      };
    },
    toJSON(J) {
      const ye = {};
      return J.roomName !== void 0 && (ye.roomName = J.roomName), J.trackId !== void 0 && (ye.trackId = J.trackId), J.file !== void 0 && (ye.file = J.file ? a.DirectFileOutput.toJSON(J.file) : void 0), J.websocketUrl !== void 0 && (ye.websocketUrl = J.websocketUrl), ye;
    },
    fromPartial(J) {
      var ye, we, We;
      const Re = I();
      return Re.roomName = (ye = J.roomName) !== null && ye !== void 0 ? ye : "", Re.trackId = (we = J.trackId) !== null && we !== void 0 ? we : "", Re.file = J.file !== void 0 && J.file !== null ? a.DirectFileOutput.fromPartial(J.file) : void 0, Re.websocketUrl = (We = J.websocketUrl) !== null && We !== void 0 ? We : void 0, Re;
    }
  };
  function N() {
    return {
      url: "",
      audioOnly: !1,
      videoOnly: !1,
      file: void 0,
      stream: void 0,
      segments: void 0,
      preset: void 0,
      advanced: void 0
    };
  }
  a.WebEgressRequest = {
    encode(J, ye = l.default.Writer.create()) {
      return J.url !== void 0 && J.url !== "" && ye.uint32(10).string(J.url), J.audioOnly === !0 && ye.uint32(16).bool(J.audioOnly), J.videoOnly === !0 && ye.uint32(24).bool(J.videoOnly), J.file !== void 0 && a.EncodedFileOutput.encode(J.file, ye.uint32(34).fork()).ldelim(), J.stream !== void 0 && a.StreamOutput.encode(J.stream, ye.uint32(42).fork()).ldelim(), J.segments !== void 0 && a.SegmentedFileOutput.encode(J.segments, ye.uint32(50).fork()).ldelim(), J.preset !== void 0 && ye.uint32(56).int32(J.preset), J.advanced !== void 0 && a.EncodingOptions.encode(J.advanced, ye.uint32(66).fork()).ldelim(), ye;
    },
    decode(J, ye) {
      const we = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let We = ye === void 0 ? we.len : we.pos + ye;
      const Re = N();
      for (; we.pos < We; ) {
        const q = we.uint32();
        switch (q >>> 3) {
          case 1:
            Re.url = we.string();
            break;
          case 2:
            Re.audioOnly = we.bool();
            break;
          case 3:
            Re.videoOnly = we.bool();
            break;
          case 4:
            Re.file = a.EncodedFileOutput.decode(we, we.uint32());
            break;
          case 5:
            Re.stream = a.StreamOutput.decode(we, we.uint32());
            break;
          case 6:
            Re.segments = a.SegmentedFileOutput.decode(we, we.uint32());
            break;
          case 7:
            Re.preset = we.int32();
            break;
          case 8:
            Re.advanced = a.EncodingOptions.decode(we, we.uint32());
            break;
          default:
            we.skipType(q & 7);
            break;
        }
      }
      return Re;
    },
    fromJSON(J) {
      return {
        url: Ge(J.url) ? String(J.url) : "",
        audioOnly: Ge(J.audioOnly) ? !!J.audioOnly : !1,
        videoOnly: Ge(J.videoOnly) ? !!J.videoOnly : !1,
        file: Ge(J.file) ? a.EncodedFileOutput.fromJSON(J.file) : void 0,
        stream: Ge(J.stream) ? a.StreamOutput.fromJSON(J.stream) : void 0,
        segments: Ge(J.segments) ? a.SegmentedFileOutput.fromJSON(J.segments) : void 0,
        preset: Ge(J.preset) ? be(J.preset) : void 0,
        advanced: Ge(J.advanced) ? a.EncodingOptions.fromJSON(J.advanced) : void 0
      };
    },
    toJSON(J) {
      const ye = {};
      return J.url !== void 0 && (ye.url = J.url), J.audioOnly !== void 0 && (ye.audioOnly = J.audioOnly), J.videoOnly !== void 0 && (ye.videoOnly = J.videoOnly), J.file !== void 0 && (ye.file = J.file ? a.EncodedFileOutput.toJSON(J.file) : void 0), J.stream !== void 0 && (ye.stream = J.stream ? a.StreamOutput.toJSON(J.stream) : void 0), J.segments !== void 0 && (ye.segments = J.segments ? a.SegmentedFileOutput.toJSON(J.segments) : void 0), J.preset !== void 0 && (ye.preset = J.preset !== void 0 ? Ce(J.preset) : void 0), J.advanced !== void 0 && (ye.advanced = J.advanced ? a.EncodingOptions.toJSON(J.advanced) : void 0), ye;
    },
    fromPartial(J) {
      var ye, we, We, Re;
      const q = N();
      return q.url = (ye = J.url) !== null && ye !== void 0 ? ye : "", q.audioOnly = (we = J.audioOnly) !== null && we !== void 0 ? we : !1, q.videoOnly = (We = J.videoOnly) !== null && We !== void 0 ? We : !1, q.file = J.file !== void 0 && J.file !== null ? a.EncodedFileOutput.fromPartial(J.file) : void 0, q.stream = J.stream !== void 0 && J.stream !== null ? a.StreamOutput.fromPartial(J.stream) : void 0, q.segments = J.segments !== void 0 && J.segments !== null ? a.SegmentedFileOutput.fromPartial(J.segments) : void 0, q.preset = (Re = J.preset) !== null && Re !== void 0 ? Re : void 0, q.advanced = J.advanced !== void 0 && J.advanced !== null ? a.EncodingOptions.fromPartial(J.advanced) : void 0, q;
    }
  };
  function $() {
    return {
      fileType: 0,
      filepath: "",
      disableManifest: !1,
      s3: void 0,
      gcp: void 0,
      azure: void 0,
      aliOSS: void 0
    };
  }
  a.EncodedFileOutput = {
    encode(J, ye = l.default.Writer.create()) {
      return J.fileType !== void 0 && J.fileType !== 0 && ye.uint32(8).int32(J.fileType), J.filepath !== void 0 && J.filepath !== "" && ye.uint32(18).string(J.filepath), J.disableManifest === !0 && ye.uint32(48).bool(J.disableManifest), J.s3 !== void 0 && a.S3Upload.encode(J.s3, ye.uint32(26).fork()).ldelim(), J.gcp !== void 0 && a.GCPUpload.encode(J.gcp, ye.uint32(34).fork()).ldelim(), J.azure !== void 0 && a.AzureBlobUpload.encode(J.azure, ye.uint32(42).fork()).ldelim(), J.aliOSS !== void 0 && a.AliOSSUpload.encode(J.aliOSS, ye.uint32(58).fork()).ldelim(), ye;
    },
    decode(J, ye) {
      const we = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let We = ye === void 0 ? we.len : we.pos + ye;
      const Re = $();
      for (; we.pos < We; ) {
        const q = we.uint32();
        switch (q >>> 3) {
          case 1:
            Re.fileType = we.int32();
            break;
          case 2:
            Re.filepath = we.string();
            break;
          case 6:
            Re.disableManifest = we.bool();
            break;
          case 3:
            Re.s3 = a.S3Upload.decode(we, we.uint32());
            break;
          case 4:
            Re.gcp = a.GCPUpload.decode(we, we.uint32());
            break;
          case 5:
            Re.azure = a.AzureBlobUpload.decode(we, we.uint32());
            break;
          case 7:
            Re.aliOSS = a.AliOSSUpload.decode(we, we.uint32());
            break;
          default:
            we.skipType(q & 7);
            break;
        }
      }
      return Re;
    },
    fromJSON(J) {
      return {
        fileType: Ge(J.fileType) ? p(J.fileType) : 0,
        filepath: Ge(J.filepath) ? String(J.filepath) : "",
        disableManifest: Ge(J.disableManifest) ? !!J.disableManifest : !1,
        s3: Ge(J.s3) ? a.S3Upload.fromJSON(J.s3) : void 0,
        gcp: Ge(J.gcp) ? a.GCPUpload.fromJSON(J.gcp) : void 0,
        azure: Ge(J.azure) ? a.AzureBlobUpload.fromJSON(J.azure) : void 0,
        aliOSS: Ge(J.aliOSS) ? a.AliOSSUpload.fromJSON(J.aliOSS) : void 0
      };
    },
    toJSON(J) {
      const ye = {};
      return J.fileType !== void 0 && (ye.fileType = _(J.fileType)), J.filepath !== void 0 && (ye.filepath = J.filepath), J.disableManifest !== void 0 && (ye.disableManifest = J.disableManifest), J.s3 !== void 0 && (ye.s3 = J.s3 ? a.S3Upload.toJSON(J.s3) : void 0), J.gcp !== void 0 && (ye.gcp = J.gcp ? a.GCPUpload.toJSON(J.gcp) : void 0), J.azure !== void 0 && (ye.azure = J.azure ? a.AzureBlobUpload.toJSON(J.azure) : void 0), J.aliOSS !== void 0 && (ye.aliOSS = J.aliOSS ? a.AliOSSUpload.toJSON(J.aliOSS) : void 0), ye;
    },
    fromPartial(J) {
      var ye, we, We;
      const Re = $();
      return Re.fileType = (ye = J.fileType) !== null && ye !== void 0 ? ye : 0, Re.filepath = (we = J.filepath) !== null && we !== void 0 ? we : "", Re.disableManifest = (We = J.disableManifest) !== null && We !== void 0 ? We : !1, Re.s3 = J.s3 !== void 0 && J.s3 !== null ? a.S3Upload.fromPartial(J.s3) : void 0, Re.gcp = J.gcp !== void 0 && J.gcp !== null ? a.GCPUpload.fromPartial(J.gcp) : void 0, Re.azure = J.azure !== void 0 && J.azure !== null ? a.AzureBlobUpload.fromPartial(J.azure) : void 0, Re.aliOSS = J.aliOSS !== void 0 && J.aliOSS !== null ? a.AliOSSUpload.fromPartial(J.aliOSS) : void 0, Re;
    }
  };
  function U() {
    return {
      protocol: 0,
      filenamePrefix: "",
      playlistName: "",
      segmentDuration: 0,
      disableManifest: !1,
      s3: void 0,
      gcp: void 0,
      azure: void 0,
      aliOSS: void 0
    };
  }
  a.SegmentedFileOutput = {
    encode(J, ye = l.default.Writer.create()) {
      return J.protocol !== void 0 && J.protocol !== 0 && ye.uint32(8).int32(J.protocol), J.filenamePrefix !== void 0 && J.filenamePrefix !== "" && ye.uint32(18).string(J.filenamePrefix), J.playlistName !== void 0 && J.playlistName !== "" && ye.uint32(26).string(J.playlistName), J.segmentDuration !== void 0 && J.segmentDuration !== 0 && ye.uint32(32).uint32(J.segmentDuration), J.disableManifest === !0 && ye.uint32(64).bool(J.disableManifest), J.s3 !== void 0 && a.S3Upload.encode(J.s3, ye.uint32(42).fork()).ldelim(), J.gcp !== void 0 && a.GCPUpload.encode(J.gcp, ye.uint32(50).fork()).ldelim(), J.azure !== void 0 && a.AzureBlobUpload.encode(J.azure, ye.uint32(58).fork()).ldelim(), J.aliOSS !== void 0 && a.AliOSSUpload.encode(J.aliOSS, ye.uint32(74).fork()).ldelim(), ye;
    },
    decode(J, ye) {
      const we = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let We = ye === void 0 ? we.len : we.pos + ye;
      const Re = U();
      for (; we.pos < We; ) {
        const q = we.uint32();
        switch (q >>> 3) {
          case 1:
            Re.protocol = we.int32();
            break;
          case 2:
            Re.filenamePrefix = we.string();
            break;
          case 3:
            Re.playlistName = we.string();
            break;
          case 4:
            Re.segmentDuration = we.uint32();
            break;
          case 8:
            Re.disableManifest = we.bool();
            break;
          case 5:
            Re.s3 = a.S3Upload.decode(we, we.uint32());
            break;
          case 6:
            Re.gcp = a.GCPUpload.decode(we, we.uint32());
            break;
          case 7:
            Re.azure = a.AzureBlobUpload.decode(we, we.uint32());
            break;
          case 9:
            Re.aliOSS = a.AliOSSUpload.decode(we, we.uint32());
            break;
          default:
            we.skipType(q & 7);
            break;
        }
      }
      return Re;
    },
    fromJSON(J) {
      return {
        protocol: Ge(J.protocol) ? V(J.protocol) : 0,
        filenamePrefix: Ge(J.filenamePrefix) ? String(J.filenamePrefix) : "",
        playlistName: Ge(J.playlistName) ? String(J.playlistName) : "",
        segmentDuration: Ge(J.segmentDuration) ? Number(J.segmentDuration) : 0,
        disableManifest: Ge(J.disableManifest) ? !!J.disableManifest : !1,
        s3: Ge(J.s3) ? a.S3Upload.fromJSON(J.s3) : void 0,
        gcp: Ge(J.gcp) ? a.GCPUpload.fromJSON(J.gcp) : void 0,
        azure: Ge(J.azure) ? a.AzureBlobUpload.fromJSON(J.azure) : void 0,
        aliOSS: Ge(J.aliOSS) ? a.AliOSSUpload.fromJSON(J.aliOSS) : void 0
      };
    },
    toJSON(J) {
      const ye = {};
      return J.protocol !== void 0 && (ye.protocol = X(J.protocol)), J.filenamePrefix !== void 0 && (ye.filenamePrefix = J.filenamePrefix), J.playlistName !== void 0 && (ye.playlistName = J.playlistName), J.segmentDuration !== void 0 && (ye.segmentDuration = Math.round(J.segmentDuration)), J.disableManifest !== void 0 && (ye.disableManifest = J.disableManifest), J.s3 !== void 0 && (ye.s3 = J.s3 ? a.S3Upload.toJSON(J.s3) : void 0), J.gcp !== void 0 && (ye.gcp = J.gcp ? a.GCPUpload.toJSON(J.gcp) : void 0), J.azure !== void 0 && (ye.azure = J.azure ? a.AzureBlobUpload.toJSON(J.azure) : void 0), J.aliOSS !== void 0 && (ye.aliOSS = J.aliOSS ? a.AliOSSUpload.toJSON(J.aliOSS) : void 0), ye;
    },
    fromPartial(J) {
      var ye, we, We, Re, q;
      const ke = U();
      return ke.protocol = (ye = J.protocol) !== null && ye !== void 0 ? ye : 0, ke.filenamePrefix = (we = J.filenamePrefix) !== null && we !== void 0 ? we : "", ke.playlistName = (We = J.playlistName) !== null && We !== void 0 ? We : "", ke.segmentDuration = (Re = J.segmentDuration) !== null && Re !== void 0 ? Re : 0, ke.disableManifest = (q = J.disableManifest) !== null && q !== void 0 ? q : !1, ke.s3 = J.s3 !== void 0 && J.s3 !== null ? a.S3Upload.fromPartial(J.s3) : void 0, ke.gcp = J.gcp !== void 0 && J.gcp !== null ? a.GCPUpload.fromPartial(J.gcp) : void 0, ke.azure = J.azure !== void 0 && J.azure !== null ? a.AzureBlobUpload.fromPartial(J.azure) : void 0, ke.aliOSS = J.aliOSS !== void 0 && J.aliOSS !== null ? a.AliOSSUpload.fromPartial(J.aliOSS) : void 0, ke;
    }
  };
  function H() {
    return { filepath: "", disableManifest: !1, s3: void 0, gcp: void 0, azure: void 0, aliOSS: void 0 };
  }
  a.DirectFileOutput = {
    encode(J, ye = l.default.Writer.create()) {
      return J.filepath !== void 0 && J.filepath !== "" && ye.uint32(10).string(J.filepath), J.disableManifest === !0 && ye.uint32(40).bool(J.disableManifest), J.s3 !== void 0 && a.S3Upload.encode(J.s3, ye.uint32(18).fork()).ldelim(), J.gcp !== void 0 && a.GCPUpload.encode(J.gcp, ye.uint32(26).fork()).ldelim(), J.azure !== void 0 && a.AzureBlobUpload.encode(J.azure, ye.uint32(34).fork()).ldelim(), J.aliOSS !== void 0 && a.AliOSSUpload.encode(J.aliOSS, ye.uint32(50).fork()).ldelim(), ye;
    },
    decode(J, ye) {
      const we = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let We = ye === void 0 ? we.len : we.pos + ye;
      const Re = H();
      for (; we.pos < We; ) {
        const q = we.uint32();
        switch (q >>> 3) {
          case 1:
            Re.filepath = we.string();
            break;
          case 5:
            Re.disableManifest = we.bool();
            break;
          case 2:
            Re.s3 = a.S3Upload.decode(we, we.uint32());
            break;
          case 3:
            Re.gcp = a.GCPUpload.decode(we, we.uint32());
            break;
          case 4:
            Re.azure = a.AzureBlobUpload.decode(we, we.uint32());
            break;
          case 6:
            Re.aliOSS = a.AliOSSUpload.decode(we, we.uint32());
            break;
          default:
            we.skipType(q & 7);
            break;
        }
      }
      return Re;
    },
    fromJSON(J) {
      return {
        filepath: Ge(J.filepath) ? String(J.filepath) : "",
        disableManifest: Ge(J.disableManifest) ? !!J.disableManifest : !1,
        s3: Ge(J.s3) ? a.S3Upload.fromJSON(J.s3) : void 0,
        gcp: Ge(J.gcp) ? a.GCPUpload.fromJSON(J.gcp) : void 0,
        azure: Ge(J.azure) ? a.AzureBlobUpload.fromJSON(J.azure) : void 0,
        aliOSS: Ge(J.aliOSS) ? a.AliOSSUpload.fromJSON(J.aliOSS) : void 0
      };
    },
    toJSON(J) {
      const ye = {};
      return J.filepath !== void 0 && (ye.filepath = J.filepath), J.disableManifest !== void 0 && (ye.disableManifest = J.disableManifest), J.s3 !== void 0 && (ye.s3 = J.s3 ? a.S3Upload.toJSON(J.s3) : void 0), J.gcp !== void 0 && (ye.gcp = J.gcp ? a.GCPUpload.toJSON(J.gcp) : void 0), J.azure !== void 0 && (ye.azure = J.azure ? a.AzureBlobUpload.toJSON(J.azure) : void 0), J.aliOSS !== void 0 && (ye.aliOSS = J.aliOSS ? a.AliOSSUpload.toJSON(J.aliOSS) : void 0), ye;
    },
    fromPartial(J) {
      var ye, we;
      const We = H();
      return We.filepath = (ye = J.filepath) !== null && ye !== void 0 ? ye : "", We.disableManifest = (we = J.disableManifest) !== null && we !== void 0 ? we : !1, We.s3 = J.s3 !== void 0 && J.s3 !== null ? a.S3Upload.fromPartial(J.s3) : void 0, We.gcp = J.gcp !== void 0 && J.gcp !== null ? a.GCPUpload.fromPartial(J.gcp) : void 0, We.azure = J.azure !== void 0 && J.azure !== null ? a.AzureBlobUpload.fromPartial(J.azure) : void 0, We.aliOSS = J.aliOSS !== void 0 && J.aliOSS !== null ? a.AliOSSUpload.fromPartial(J.aliOSS) : void 0, We;
    }
  };
  function B() {
    return {
      accessKey: "",
      secret: "",
      region: "",
      endpoint: "",
      bucket: "",
      forcePathStyle: !1,
      metadata: {},
      tagging: ""
    };
  }
  a.S3Upload = {
    encode(J, ye = l.default.Writer.create()) {
      return J.accessKey !== void 0 && J.accessKey !== "" && ye.uint32(10).string(J.accessKey), J.secret !== void 0 && J.secret !== "" && ye.uint32(18).string(J.secret), J.region !== void 0 && J.region !== "" && ye.uint32(26).string(J.region), J.endpoint !== void 0 && J.endpoint !== "" && ye.uint32(34).string(J.endpoint), J.bucket !== void 0 && J.bucket !== "" && ye.uint32(42).string(J.bucket), J.forcePathStyle === !0 && ye.uint32(48).bool(J.forcePathStyle), Object.entries(J.metadata || {}).forEach(([we, We]) => {
        a.S3Upload_MetadataEntry.encode({ key: we, value: We }, ye.uint32(58).fork()).ldelim();
      }), J.tagging !== void 0 && J.tagging !== "" && ye.uint32(66).string(J.tagging), ye;
    },
    decode(J, ye) {
      const we = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let We = ye === void 0 ? we.len : we.pos + ye;
      const Re = B();
      for (; we.pos < We; ) {
        const q = we.uint32();
        switch (q >>> 3) {
          case 1:
            Re.accessKey = we.string();
            break;
          case 2:
            Re.secret = we.string();
            break;
          case 3:
            Re.region = we.string();
            break;
          case 4:
            Re.endpoint = we.string();
            break;
          case 5:
            Re.bucket = we.string();
            break;
          case 6:
            Re.forcePathStyle = we.bool();
            break;
          case 7:
            const ke = a.S3Upload_MetadataEntry.decode(we, we.uint32());
            ke.value !== void 0 && (Re.metadata[ke.key] = ke.value);
            break;
          case 8:
            Re.tagging = we.string();
            break;
          default:
            we.skipType(q & 7);
            break;
        }
      }
      return Re;
    },
    fromJSON(J) {
      return {
        accessKey: Ge(J.accessKey) ? String(J.accessKey) : "",
        secret: Ge(J.secret) ? String(J.secret) : "",
        region: Ge(J.region) ? String(J.region) : "",
        endpoint: Ge(J.endpoint) ? String(J.endpoint) : "",
        bucket: Ge(J.bucket) ? String(J.bucket) : "",
        forcePathStyle: Ge(J.forcePathStyle) ? !!J.forcePathStyle : !1,
        metadata: Xe(J.metadata) ? Object.entries(J.metadata).reduce((ye, [we, We]) => (ye[we] = String(We), ye), {}) : {},
        tagging: Ge(J.tagging) ? String(J.tagging) : ""
      };
    },
    toJSON(J) {
      const ye = {};
      return J.accessKey !== void 0 && (ye.accessKey = J.accessKey), J.secret !== void 0 && (ye.secret = J.secret), J.region !== void 0 && (ye.region = J.region), J.endpoint !== void 0 && (ye.endpoint = J.endpoint), J.bucket !== void 0 && (ye.bucket = J.bucket), J.forcePathStyle !== void 0 && (ye.forcePathStyle = J.forcePathStyle), ye.metadata = {}, J.metadata && Object.entries(J.metadata).forEach(([we, We]) => {
        ye.metadata[we] = We;
      }), J.tagging !== void 0 && (ye.tagging = J.tagging), ye;
    },
    fromPartial(J) {
      var ye, we, We, Re, q, ke, de, ue;
      const me = B();
      return me.accessKey = (ye = J.accessKey) !== null && ye !== void 0 ? ye : "", me.secret = (we = J.secret) !== null && we !== void 0 ? we : "", me.region = (We = J.region) !== null && We !== void 0 ? We : "", me.endpoint = (Re = J.endpoint) !== null && Re !== void 0 ? Re : "", me.bucket = (q = J.bucket) !== null && q !== void 0 ? q : "", me.forcePathStyle = (ke = J.forcePathStyle) !== null && ke !== void 0 ? ke : !1, me.metadata = Object.entries((de = J.metadata) !== null && de !== void 0 ? de : {}).reduce((Oe, [Ue, ze]) => (ze !== void 0 && (Oe[Ue] = String(ze)), Oe), {}), me.tagging = (ue = J.tagging) !== null && ue !== void 0 ? ue : "", me;
    }
  };
  function T() {
    return { key: "", value: "" };
  }
  a.S3Upload_MetadataEntry = {
    encode(J, ye = l.default.Writer.create()) {
      return J.key !== "" && ye.uint32(10).string(J.key), J.value !== "" && ye.uint32(18).string(J.value), ye;
    },
    decode(J, ye) {
      const we = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let We = ye === void 0 ? we.len : we.pos + ye;
      const Re = T();
      for (; we.pos < We; ) {
        const q = we.uint32();
        switch (q >>> 3) {
          case 1:
            Re.key = we.string();
            break;
          case 2:
            Re.value = we.string();
            break;
          default:
            we.skipType(q & 7);
            break;
        }
      }
      return Re;
    },
    fromJSON(J) {
      return { key: Ge(J.key) ? String(J.key) : "", value: Ge(J.value) ? String(J.value) : "" };
    },
    toJSON(J) {
      const ye = {};
      return J.key !== void 0 && (ye.key = J.key), J.value !== void 0 && (ye.value = J.value), ye;
    },
    fromPartial(J) {
      var ye, we;
      const We = T();
      return We.key = (ye = J.key) !== null && ye !== void 0 ? ye : "", We.value = (we = J.value) !== null && we !== void 0 ? we : "", We;
    }
  };
  function D() {
    return { credentials: new Uint8Array(), bucket: "" };
  }
  a.GCPUpload = {
    encode(J, ye = l.default.Writer.create()) {
      return J.credentials !== void 0 && J.credentials.length !== 0 && ye.uint32(10).bytes(J.credentials), J.bucket !== void 0 && J.bucket !== "" && ye.uint32(18).string(J.bucket), ye;
    },
    decode(J, ye) {
      const we = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let We = ye === void 0 ? we.len : we.pos + ye;
      const Re = D();
      for (; we.pos < We; ) {
        const q = we.uint32();
        switch (q >>> 3) {
          case 1:
            Re.credentials = we.bytes();
            break;
          case 2:
            Re.bucket = we.string();
            break;
          default:
            we.skipType(q & 7);
            break;
        }
      }
      return Re;
    },
    fromJSON(J) {
      return {
        credentials: Ge(J.credentials) ? Ze(J.credentials) : new Uint8Array(),
        bucket: Ge(J.bucket) ? String(J.bucket) : ""
      };
    },
    toJSON(J) {
      const ye = {};
      return J.credentials !== void 0 && (ye.credentials = qe(J.credentials !== void 0 ? J.credentials : new Uint8Array())), J.bucket !== void 0 && (ye.bucket = J.bucket), ye;
    },
    fromPartial(J) {
      var ye, we;
      const We = D();
      return We.credentials = (ye = J.credentials) !== null && ye !== void 0 ? ye : new Uint8Array(), We.bucket = (we = J.bucket) !== null && we !== void 0 ? we : "", We;
    }
  };
  function ee() {
    return { accountName: "", accountKey: "", containerName: "" };
  }
  a.AzureBlobUpload = {
    encode(J, ye = l.default.Writer.create()) {
      return J.accountName !== void 0 && J.accountName !== "" && ye.uint32(10).string(J.accountName), J.accountKey !== void 0 && J.accountKey !== "" && ye.uint32(18).string(J.accountKey), J.containerName !== void 0 && J.containerName !== "" && ye.uint32(26).string(J.containerName), ye;
    },
    decode(J, ye) {
      const we = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let We = ye === void 0 ? we.len : we.pos + ye;
      const Re = ee();
      for (; we.pos < We; ) {
        const q = we.uint32();
        switch (q >>> 3) {
          case 1:
            Re.accountName = we.string();
            break;
          case 2:
            Re.accountKey = we.string();
            break;
          case 3:
            Re.containerName = we.string();
            break;
          default:
            we.skipType(q & 7);
            break;
        }
      }
      return Re;
    },
    fromJSON(J) {
      return {
        accountName: Ge(J.accountName) ? String(J.accountName) : "",
        accountKey: Ge(J.accountKey) ? String(J.accountKey) : "",
        containerName: Ge(J.containerName) ? String(J.containerName) : ""
      };
    },
    toJSON(J) {
      const ye = {};
      return J.accountName !== void 0 && (ye.accountName = J.accountName), J.accountKey !== void 0 && (ye.accountKey = J.accountKey), J.containerName !== void 0 && (ye.containerName = J.containerName), ye;
    },
    fromPartial(J) {
      var ye, we, We;
      const Re = ee();
      return Re.accountName = (ye = J.accountName) !== null && ye !== void 0 ? ye : "", Re.accountKey = (we = J.accountKey) !== null && we !== void 0 ? we : "", Re.containerName = (We = J.containerName) !== null && We !== void 0 ? We : "", Re;
    }
  };
  function pe() {
    return { accessKey: "", secret: "", region: "", endpoint: "", bucket: "" };
  }
  a.AliOSSUpload = {
    encode(J, ye = l.default.Writer.create()) {
      return J.accessKey !== void 0 && J.accessKey !== "" && ye.uint32(10).string(J.accessKey), J.secret !== void 0 && J.secret !== "" && ye.uint32(18).string(J.secret), J.region !== void 0 && J.region !== "" && ye.uint32(26).string(J.region), J.endpoint !== void 0 && J.endpoint !== "" && ye.uint32(34).string(J.endpoint), J.bucket !== void 0 && J.bucket !== "" && ye.uint32(42).string(J.bucket), ye;
    },
    decode(J, ye) {
      const we = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let We = ye === void 0 ? we.len : we.pos + ye;
      const Re = pe();
      for (; we.pos < We; ) {
        const q = we.uint32();
        switch (q >>> 3) {
          case 1:
            Re.accessKey = we.string();
            break;
          case 2:
            Re.secret = we.string();
            break;
          case 3:
            Re.region = we.string();
            break;
          case 4:
            Re.endpoint = we.string();
            break;
          case 5:
            Re.bucket = we.string();
            break;
          default:
            we.skipType(q & 7);
            break;
        }
      }
      return Re;
    },
    fromJSON(J) {
      return {
        accessKey: Ge(J.accessKey) ? String(J.accessKey) : "",
        secret: Ge(J.secret) ? String(J.secret) : "",
        region: Ge(J.region) ? String(J.region) : "",
        endpoint: Ge(J.endpoint) ? String(J.endpoint) : "",
        bucket: Ge(J.bucket) ? String(J.bucket) : ""
      };
    },
    toJSON(J) {
      const ye = {};
      return J.accessKey !== void 0 && (ye.accessKey = J.accessKey), J.secret !== void 0 && (ye.secret = J.secret), J.region !== void 0 && (ye.region = J.region), J.endpoint !== void 0 && (ye.endpoint = J.endpoint), J.bucket !== void 0 && (ye.bucket = J.bucket), ye;
    },
    fromPartial(J) {
      var ye, we, We, Re, q;
      const ke = pe();
      return ke.accessKey = (ye = J.accessKey) !== null && ye !== void 0 ? ye : "", ke.secret = (we = J.secret) !== null && we !== void 0 ? we : "", ke.region = (We = J.region) !== null && We !== void 0 ? We : "", ke.endpoint = (Re = J.endpoint) !== null && Re !== void 0 ? Re : "", ke.bucket = (q = J.bucket) !== null && q !== void 0 ? q : "", ke;
    }
  };
  function Ie() {
    return { protocol: 0, urls: [] };
  }
  a.StreamOutput = {
    encode(J, ye = l.default.Writer.create()) {
      if (J.protocol !== void 0 && J.protocol !== 0 && ye.uint32(8).int32(J.protocol), J.urls !== void 0 && J.urls.length !== 0)
        for (const we of J.urls)
          ye.uint32(18).string(we);
      return ye;
    },
    decode(J, ye) {
      const we = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let We = ye === void 0 ? we.len : we.pos + ye;
      const Re = Ie();
      for (; we.pos < We; ) {
        const q = we.uint32();
        switch (q >>> 3) {
          case 1:
            Re.protocol = we.int32();
            break;
          case 2:
            Re.urls.push(we.string());
            break;
          default:
            we.skipType(q & 7);
            break;
        }
      }
      return Re;
    },
    fromJSON(J) {
      return {
        protocol: Ge(J.protocol) ? M(J.protocol) : 0,
        urls: Array.isArray(J == null ? void 0 : J.urls) ? J.urls.map((ye) => String(ye)) : []
      };
    },
    toJSON(J) {
      const ye = {};
      return J.protocol !== void 0 && (ye.protocol = L(J.protocol)), J.urls ? ye.urls = J.urls.map((we) => we) : ye.urls = [], ye;
    },
    fromPartial(J) {
      var ye, we;
      const We = Ie();
      return We.protocol = (ye = J.protocol) !== null && ye !== void 0 ? ye : 0, We.urls = ((we = J.urls) === null || we === void 0 ? void 0 : we.map((Re) => Re)) || [], We;
    }
  };
  function Pe() {
    return {
      width: 0,
      height: 0,
      depth: 0,
      framerate: 0,
      audioCodec: 0,
      audioBitrate: 0,
      audioFrequency: 0,
      videoCodec: 0,
      videoBitrate: 0
    };
  }
  a.EncodingOptions = {
    encode(J, ye = l.default.Writer.create()) {
      return J.width !== void 0 && J.width !== 0 && ye.uint32(8).int32(J.width), J.height !== void 0 && J.height !== 0 && ye.uint32(16).int32(J.height), J.depth !== void 0 && J.depth !== 0 && ye.uint32(24).int32(J.depth), J.framerate !== void 0 && J.framerate !== 0 && ye.uint32(32).int32(J.framerate), J.audioCodec !== void 0 && J.audioCodec !== 0 && ye.uint32(40).int32(J.audioCodec), J.audioBitrate !== void 0 && J.audioBitrate !== 0 && ye.uint32(48).int32(J.audioBitrate), J.audioFrequency !== void 0 && J.audioFrequency !== 0 && ye.uint32(56).int32(J.audioFrequency), J.videoCodec !== void 0 && J.videoCodec !== 0 && ye.uint32(64).int32(J.videoCodec), J.videoBitrate !== void 0 && J.videoBitrate !== 0 && ye.uint32(72).int32(J.videoBitrate), ye;
    },
    decode(J, ye) {
      const we = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let We = ye === void 0 ? we.len : we.pos + ye;
      const Re = Pe();
      for (; we.pos < We; ) {
        const q = we.uint32();
        switch (q >>> 3) {
          case 1:
            Re.width = we.int32();
            break;
          case 2:
            Re.height = we.int32();
            break;
          case 3:
            Re.depth = we.int32();
            break;
          case 4:
            Re.framerate = we.int32();
            break;
          case 5:
            Re.audioCodec = we.int32();
            break;
          case 6:
            Re.audioBitrate = we.int32();
            break;
          case 7:
            Re.audioFrequency = we.int32();
            break;
          case 8:
            Re.videoCodec = we.int32();
            break;
          case 9:
            Re.videoBitrate = we.int32();
            break;
          default:
            we.skipType(q & 7);
            break;
        }
      }
      return Re;
    },
    fromJSON(J) {
      return {
        width: Ge(J.width) ? Number(J.width) : 0,
        height: Ge(J.height) ? Number(J.height) : 0,
        depth: Ge(J.depth) ? Number(J.depth) : 0,
        framerate: Ge(J.framerate) ? Number(J.framerate) : 0,
        audioCodec: Ge(J.audioCodec) ? Y(J.audioCodec) : 0,
        audioBitrate: Ge(J.audioBitrate) ? Number(J.audioBitrate) : 0,
        audioFrequency: Ge(J.audioFrequency) ? Number(J.audioFrequency) : 0,
        videoCodec: Ge(J.videoCodec) ? fe(J.videoCodec) : 0,
        videoBitrate: Ge(J.videoBitrate) ? Number(J.videoBitrate) : 0
      };
    },
    toJSON(J) {
      const ye = {};
      return J.width !== void 0 && (ye.width = Math.round(J.width)), J.height !== void 0 && (ye.height = Math.round(J.height)), J.depth !== void 0 && (ye.depth = Math.round(J.depth)), J.framerate !== void 0 && (ye.framerate = Math.round(J.framerate)), J.audioCodec !== void 0 && (ye.audioCodec = ae(J.audioCodec)), J.audioBitrate !== void 0 && (ye.audioBitrate = Math.round(J.audioBitrate)), J.audioFrequency !== void 0 && (ye.audioFrequency = Math.round(J.audioFrequency)), J.videoCodec !== void 0 && (ye.videoCodec = ie(J.videoCodec)), J.videoBitrate !== void 0 && (ye.videoBitrate = Math.round(J.videoBitrate)), ye;
    },
    fromPartial(J) {
      var ye, we, We, Re, q, ke, de, ue, me;
      const Oe = Pe();
      return Oe.width = (ye = J.width) !== null && ye !== void 0 ? ye : 0, Oe.height = (we = J.height) !== null && we !== void 0 ? we : 0, Oe.depth = (We = J.depth) !== null && We !== void 0 ? We : 0, Oe.framerate = (Re = J.framerate) !== null && Re !== void 0 ? Re : 0, Oe.audioCodec = (q = J.audioCodec) !== null && q !== void 0 ? q : 0, Oe.audioBitrate = (ke = J.audioBitrate) !== null && ke !== void 0 ? ke : 0, Oe.audioFrequency = (de = J.audioFrequency) !== null && de !== void 0 ? de : 0, Oe.videoCodec = (ue = J.videoCodec) !== null && ue !== void 0 ? ue : 0, Oe.videoBitrate = (me = J.videoBitrate) !== null && me !== void 0 ? me : 0, Oe;
    }
  };
  function he() {
    return { egressId: "", layout: "" };
  }
  a.UpdateLayoutRequest = {
    encode(J, ye = l.default.Writer.create()) {
      return J.egressId !== void 0 && J.egressId !== "" && ye.uint32(10).string(J.egressId), J.layout !== void 0 && J.layout !== "" && ye.uint32(18).string(J.layout), ye;
    },
    decode(J, ye) {
      const we = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let We = ye === void 0 ? we.len : we.pos + ye;
      const Re = he();
      for (; we.pos < We; ) {
        const q = we.uint32();
        switch (q >>> 3) {
          case 1:
            Re.egressId = we.string();
            break;
          case 2:
            Re.layout = we.string();
            break;
          default:
            we.skipType(q & 7);
            break;
        }
      }
      return Re;
    },
    fromJSON(J) {
      return {
        egressId: Ge(J.egressId) ? String(J.egressId) : "",
        layout: Ge(J.layout) ? String(J.layout) : ""
      };
    },
    toJSON(J) {
      const ye = {};
      return J.egressId !== void 0 && (ye.egressId = J.egressId), J.layout !== void 0 && (ye.layout = J.layout), ye;
    },
    fromPartial(J) {
      var ye, we;
      const We = he();
      return We.egressId = (ye = J.egressId) !== null && ye !== void 0 ? ye : "", We.layout = (we = J.layout) !== null && we !== void 0 ? we : "", We;
    }
  };
  function ve() {
    return { egressId: "", addOutputUrls: [], removeOutputUrls: [] };
  }
  a.UpdateStreamRequest = {
    encode(J, ye = l.default.Writer.create()) {
      if (J.egressId !== void 0 && J.egressId !== "" && ye.uint32(10).string(J.egressId), J.addOutputUrls !== void 0 && J.addOutputUrls.length !== 0)
        for (const we of J.addOutputUrls)
          ye.uint32(18).string(we);
      if (J.removeOutputUrls !== void 0 && J.removeOutputUrls.length !== 0)
        for (const we of J.removeOutputUrls)
          ye.uint32(26).string(we);
      return ye;
    },
    decode(J, ye) {
      const we = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let We = ye === void 0 ? we.len : we.pos + ye;
      const Re = ve();
      for (; we.pos < We; ) {
        const q = we.uint32();
        switch (q >>> 3) {
          case 1:
            Re.egressId = we.string();
            break;
          case 2:
            Re.addOutputUrls.push(we.string());
            break;
          case 3:
            Re.removeOutputUrls.push(we.string());
            break;
          default:
            we.skipType(q & 7);
            break;
        }
      }
      return Re;
    },
    fromJSON(J) {
      return {
        egressId: Ge(J.egressId) ? String(J.egressId) : "",
        addOutputUrls: Array.isArray(J == null ? void 0 : J.addOutputUrls) ? J.addOutputUrls.map((ye) => String(ye)) : [],
        removeOutputUrls: Array.isArray(J == null ? void 0 : J.removeOutputUrls) ? J.removeOutputUrls.map((ye) => String(ye)) : []
      };
    },
    toJSON(J) {
      const ye = {};
      return J.egressId !== void 0 && (ye.egressId = J.egressId), J.addOutputUrls ? ye.addOutputUrls = J.addOutputUrls.map((we) => we) : ye.addOutputUrls = [], J.removeOutputUrls ? ye.removeOutputUrls = J.removeOutputUrls.map((we) => we) : ye.removeOutputUrls = [], ye;
    },
    fromPartial(J) {
      var ye, we, We;
      const Re = ve();
      return Re.egressId = (ye = J.egressId) !== null && ye !== void 0 ? ye : "", Re.addOutputUrls = ((we = J.addOutputUrls) === null || we === void 0 ? void 0 : we.map((q) => q)) || [], Re.removeOutputUrls = ((We = J.removeOutputUrls) === null || We === void 0 ? void 0 : We.map((q) => q)) || [], Re;
    }
  };
  function Q() {
    return { roomName: "" };
  }
  a.ListEgressRequest = {
    encode(J, ye = l.default.Writer.create()) {
      return J.roomName !== void 0 && J.roomName !== "" && ye.uint32(10).string(J.roomName), ye;
    },
    decode(J, ye) {
      const we = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let We = ye === void 0 ? we.len : we.pos + ye;
      const Re = Q();
      for (; we.pos < We; ) {
        const q = we.uint32();
        switch (q >>> 3) {
          case 1:
            Re.roomName = we.string();
            break;
          default:
            we.skipType(q & 7);
            break;
        }
      }
      return Re;
    },
    fromJSON(J) {
      return { roomName: Ge(J.roomName) ? String(J.roomName) : "" };
    },
    toJSON(J) {
      const ye = {};
      return J.roomName !== void 0 && (ye.roomName = J.roomName), ye;
    },
    fromPartial(J) {
      var ye;
      const we = Q();
      return we.roomName = (ye = J.roomName) !== null && ye !== void 0 ? ye : "", we;
    }
  };
  function le() {
    return { items: [] };
  }
  a.ListEgressResponse = {
    encode(J, ye = l.default.Writer.create()) {
      if (J.items !== void 0 && J.items.length !== 0)
        for (const we of J.items)
          a.EgressInfo.encode(we, ye.uint32(10).fork()).ldelim();
      return ye;
    },
    decode(J, ye) {
      const we = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let We = ye === void 0 ? we.len : we.pos + ye;
      const Re = le();
      for (; we.pos < We; ) {
        const q = we.uint32();
        switch (q >>> 3) {
          case 1:
            Re.items.push(a.EgressInfo.decode(we, we.uint32()));
            break;
          default:
            we.skipType(q & 7);
            break;
        }
      }
      return Re;
    },
    fromJSON(J) {
      return { items: Array.isArray(J == null ? void 0 : J.items) ? J.items.map((ye) => a.EgressInfo.fromJSON(ye)) : [] };
    },
    toJSON(J) {
      const ye = {};
      return J.items ? ye.items = J.items.map((we) => we ? a.EgressInfo.toJSON(we) : void 0) : ye.items = [], ye;
    },
    fromPartial(J) {
      var ye;
      const we = le();
      return we.items = ((ye = J.items) === null || ye === void 0 ? void 0 : ye.map((We) => a.EgressInfo.fromPartial(We))) || [], we;
    }
  };
  function _e() {
    return { egressId: "" };
  }
  a.StopEgressRequest = {
    encode(J, ye = l.default.Writer.create()) {
      return J.egressId !== void 0 && J.egressId !== "" && ye.uint32(10).string(J.egressId), ye;
    },
    decode(J, ye) {
      const we = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let We = ye === void 0 ? we.len : we.pos + ye;
      const Re = _e();
      for (; we.pos < We; ) {
        const q = we.uint32();
        switch (q >>> 3) {
          case 1:
            Re.egressId = we.string();
            break;
          default:
            we.skipType(q & 7);
            break;
        }
      }
      return Re;
    },
    fromJSON(J) {
      return { egressId: Ge(J.egressId) ? String(J.egressId) : "" };
    },
    toJSON(J) {
      const ye = {};
      return J.egressId !== void 0 && (ye.egressId = J.egressId), ye;
    },
    fromPartial(J) {
      var ye;
      const we = _e();
      return we.egressId = (ye = J.egressId) !== null && ye !== void 0 ? ye : "", we;
    }
  };
  function re() {
    return {
      egressId: "",
      roomId: "",
      roomName: "",
      status: 0,
      startedAt: 0,
      endedAt: 0,
      error: "",
      roomComposite: void 0,
      trackComposite: void 0,
      track: void 0,
      web: void 0,
      stream: void 0,
      file: void 0,
      segments: void 0
    };
  }
  a.EgressInfo = {
    encode(J, ye = l.default.Writer.create()) {
      return J.egressId !== void 0 && J.egressId !== "" && ye.uint32(10).string(J.egressId), J.roomId !== void 0 && J.roomId !== "" && ye.uint32(18).string(J.roomId), J.roomName !== void 0 && J.roomName !== "" && ye.uint32(106).string(J.roomName), J.status !== void 0 && J.status !== 0 && ye.uint32(24).int32(J.status), J.startedAt !== void 0 && J.startedAt !== 0 && ye.uint32(80).int64(J.startedAt), J.endedAt !== void 0 && J.endedAt !== 0 && ye.uint32(88).int64(J.endedAt), J.error !== void 0 && J.error !== "" && ye.uint32(74).string(J.error), J.roomComposite !== void 0 && a.RoomCompositeEgressRequest.encode(J.roomComposite, ye.uint32(34).fork()).ldelim(), J.trackComposite !== void 0 && a.TrackCompositeEgressRequest.encode(J.trackComposite, ye.uint32(42).fork()).ldelim(), J.track !== void 0 && a.TrackEgressRequest.encode(J.track, ye.uint32(50).fork()).ldelim(), J.web !== void 0 && a.WebEgressRequest.encode(J.web, ye.uint32(114).fork()).ldelim(), J.stream !== void 0 && a.StreamInfoList.encode(J.stream, ye.uint32(58).fork()).ldelim(), J.file !== void 0 && a.FileInfo.encode(J.file, ye.uint32(66).fork()).ldelim(), J.segments !== void 0 && a.SegmentsInfo.encode(J.segments, ye.uint32(98).fork()).ldelim(), ye;
    },
    decode(J, ye) {
      const we = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let We = ye === void 0 ? we.len : we.pos + ye;
      const Re = re();
      for (; we.pos < We; ) {
        const q = we.uint32();
        switch (q >>> 3) {
          case 1:
            Re.egressId = we.string();
            break;
          case 2:
            Re.roomId = we.string();
            break;
          case 13:
            Re.roomName = we.string();
            break;
          case 3:
            Re.status = we.int32();
            break;
          case 10:
            Re.startedAt = gt(we.int64());
            break;
          case 11:
            Re.endedAt = gt(we.int64());
            break;
          case 9:
            Re.error = we.string();
            break;
          case 4:
            Re.roomComposite = a.RoomCompositeEgressRequest.decode(we, we.uint32());
            break;
          case 5:
            Re.trackComposite = a.TrackCompositeEgressRequest.decode(we, we.uint32());
            break;
          case 6:
            Re.track = a.TrackEgressRequest.decode(we, we.uint32());
            break;
          case 14:
            Re.web = a.WebEgressRequest.decode(we, we.uint32());
            break;
          case 7:
            Re.stream = a.StreamInfoList.decode(we, we.uint32());
            break;
          case 8:
            Re.file = a.FileInfo.decode(we, we.uint32());
            break;
          case 12:
            Re.segments = a.SegmentsInfo.decode(we, we.uint32());
            break;
          default:
            we.skipType(q & 7);
            break;
        }
      }
      return Re;
    },
    fromJSON(J) {
      return {
        egressId: Ge(J.egressId) ? String(J.egressId) : "",
        roomId: Ge(J.roomId) ? String(J.roomId) : "",
        roomName: Ge(J.roomName) ? String(J.roomName) : "",
        status: Ge(J.status) ? Be(J.status) : 0,
        startedAt: Ge(J.startedAt) ? Number(J.startedAt) : 0,
        endedAt: Ge(J.endedAt) ? Number(J.endedAt) : 0,
        error: Ge(J.error) ? String(J.error) : "",
        roomComposite: Ge(J.roomComposite) ? a.RoomCompositeEgressRequest.fromJSON(J.roomComposite) : void 0,
        trackComposite: Ge(J.trackComposite) ? a.TrackCompositeEgressRequest.fromJSON(J.trackComposite) : void 0,
        track: Ge(J.track) ? a.TrackEgressRequest.fromJSON(J.track) : void 0,
        web: Ge(J.web) ? a.WebEgressRequest.fromJSON(J.web) : void 0,
        stream: Ge(J.stream) ? a.StreamInfoList.fromJSON(J.stream) : void 0,
        file: Ge(J.file) ? a.FileInfo.fromJSON(J.file) : void 0,
        segments: Ge(J.segments) ? a.SegmentsInfo.fromJSON(J.segments) : void 0
      };
    },
    toJSON(J) {
      const ye = {};
      return J.egressId !== void 0 && (ye.egressId = J.egressId), J.roomId !== void 0 && (ye.roomId = J.roomId), J.roomName !== void 0 && (ye.roomName = J.roomName), J.status !== void 0 && (ye.status = Ae(J.status)), J.startedAt !== void 0 && (ye.startedAt = Math.round(J.startedAt)), J.endedAt !== void 0 && (ye.endedAt = Math.round(J.endedAt)), J.error !== void 0 && (ye.error = J.error), J.roomComposite !== void 0 && (ye.roomComposite = J.roomComposite ? a.RoomCompositeEgressRequest.toJSON(J.roomComposite) : void 0), J.trackComposite !== void 0 && (ye.trackComposite = J.trackComposite ? a.TrackCompositeEgressRequest.toJSON(J.trackComposite) : void 0), J.track !== void 0 && (ye.track = J.track ? a.TrackEgressRequest.toJSON(J.track) : void 0), J.web !== void 0 && (ye.web = J.web ? a.WebEgressRequest.toJSON(J.web) : void 0), J.stream !== void 0 && (ye.stream = J.stream ? a.StreamInfoList.toJSON(J.stream) : void 0), J.file !== void 0 && (ye.file = J.file ? a.FileInfo.toJSON(J.file) : void 0), J.segments !== void 0 && (ye.segments = J.segments ? a.SegmentsInfo.toJSON(J.segments) : void 0), ye;
    },
    fromPartial(J) {
      var ye, we, We, Re, q, ke, de;
      const ue = re();
      return ue.egressId = (ye = J.egressId) !== null && ye !== void 0 ? ye : "", ue.roomId = (we = J.roomId) !== null && we !== void 0 ? we : "", ue.roomName = (We = J.roomName) !== null && We !== void 0 ? We : "", ue.status = (Re = J.status) !== null && Re !== void 0 ? Re : 0, ue.startedAt = (q = J.startedAt) !== null && q !== void 0 ? q : 0, ue.endedAt = (ke = J.endedAt) !== null && ke !== void 0 ? ke : 0, ue.error = (de = J.error) !== null && de !== void 0 ? de : "", ue.roomComposite = J.roomComposite !== void 0 && J.roomComposite !== null ? a.RoomCompositeEgressRequest.fromPartial(J.roomComposite) : void 0, ue.trackComposite = J.trackComposite !== void 0 && J.trackComposite !== null ? a.TrackCompositeEgressRequest.fromPartial(J.trackComposite) : void 0, ue.track = J.track !== void 0 && J.track !== null ? a.TrackEgressRequest.fromPartial(J.track) : void 0, ue.web = J.web !== void 0 && J.web !== null ? a.WebEgressRequest.fromPartial(J.web) : void 0, ue.stream = J.stream !== void 0 && J.stream !== null ? a.StreamInfoList.fromPartial(J.stream) : void 0, ue.file = J.file !== void 0 && J.file !== null ? a.FileInfo.fromPartial(J.file) : void 0, ue.segments = J.segments !== void 0 && J.segments !== null ? a.SegmentsInfo.fromPartial(J.segments) : void 0, ue;
    }
  };
  function O() {
    return { info: [] };
  }
  a.StreamInfoList = {
    encode(J, ye = l.default.Writer.create()) {
      if (J.info !== void 0 && J.info.length !== 0)
        for (const we of J.info)
          a.StreamInfo.encode(we, ye.uint32(10).fork()).ldelim();
      return ye;
    },
    decode(J, ye) {
      const we = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let We = ye === void 0 ? we.len : we.pos + ye;
      const Re = O();
      for (; we.pos < We; ) {
        const q = we.uint32();
        switch (q >>> 3) {
          case 1:
            Re.info.push(a.StreamInfo.decode(we, we.uint32()));
            break;
          default:
            we.skipType(q & 7);
            break;
        }
      }
      return Re;
    },
    fromJSON(J) {
      return { info: Array.isArray(J == null ? void 0 : J.info) ? J.info.map((ye) => a.StreamInfo.fromJSON(ye)) : [] };
    },
    toJSON(J) {
      const ye = {};
      return J.info ? ye.info = J.info.map((we) => we ? a.StreamInfo.toJSON(we) : void 0) : ye.info = [], ye;
    },
    fromPartial(J) {
      var ye;
      const we = O();
      return we.info = ((ye = J.info) === null || ye === void 0 ? void 0 : ye.map((We) => a.StreamInfo.fromPartial(We))) || [], we;
    }
  };
  function j() {
    return { url: "", startedAt: 0, endedAt: 0, duration: 0, status: 0 };
  }
  a.StreamInfo = {
    encode(J, ye = l.default.Writer.create()) {
      return J.url !== void 0 && J.url !== "" && ye.uint32(10).string(J.url), J.startedAt !== void 0 && J.startedAt !== 0 && ye.uint32(16).int64(J.startedAt), J.endedAt !== void 0 && J.endedAt !== 0 && ye.uint32(24).int64(J.endedAt), J.duration !== void 0 && J.duration !== 0 && ye.uint32(32).int64(J.duration), J.status !== void 0 && J.status !== 0 && ye.uint32(40).int32(J.status), ye;
    },
    decode(J, ye) {
      const we = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let We = ye === void 0 ? we.len : we.pos + ye;
      const Re = j();
      for (; we.pos < We; ) {
        const q = we.uint32();
        switch (q >>> 3) {
          case 1:
            Re.url = we.string();
            break;
          case 2:
            Re.startedAt = gt(we.int64());
            break;
          case 3:
            Re.endedAt = gt(we.int64());
            break;
          case 4:
            Re.duration = gt(we.int64());
            break;
          case 5:
            Re.status = we.int32();
            break;
          default:
            we.skipType(q & 7);
            break;
        }
      }
      return Re;
    },
    fromJSON(J) {
      return {
        url: Ge(J.url) ? String(J.url) : "",
        startedAt: Ge(J.startedAt) ? Number(J.startedAt) : 0,
        endedAt: Ge(J.endedAt) ? Number(J.endedAt) : 0,
        duration: Ge(J.duration) ? Number(J.duration) : 0,
        status: Ge(J.status) ? z(J.status) : 0
      };
    },
    toJSON(J) {
      const ye = {};
      return J.url !== void 0 && (ye.url = J.url), J.startedAt !== void 0 && (ye.startedAt = Math.round(J.startedAt)), J.endedAt !== void 0 && (ye.endedAt = Math.round(J.endedAt)), J.duration !== void 0 && (ye.duration = Math.round(J.duration)), J.status !== void 0 && (ye.status = P(J.status)), ye;
    },
    fromPartial(J) {
      var ye, we, We, Re, q;
      const ke = j();
      return ke.url = (ye = J.url) !== null && ye !== void 0 ? ye : "", ke.startedAt = (we = J.startedAt) !== null && we !== void 0 ? we : 0, ke.endedAt = (We = J.endedAt) !== null && We !== void 0 ? We : 0, ke.duration = (Re = J.duration) !== null && Re !== void 0 ? Re : 0, ke.status = (q = J.status) !== null && q !== void 0 ? q : 0, ke;
    }
  };
  function ce() {
    return { filename: "", startedAt: 0, endedAt: 0, duration: 0, size: 0, location: "" };
  }
  a.FileInfo = {
    encode(J, ye = l.default.Writer.create()) {
      return J.filename !== void 0 && J.filename !== "" && ye.uint32(10).string(J.filename), J.startedAt !== void 0 && J.startedAt !== 0 && ye.uint32(16).int64(J.startedAt), J.endedAt !== void 0 && J.endedAt !== 0 && ye.uint32(24).int64(J.endedAt), J.duration !== void 0 && J.duration !== 0 && ye.uint32(48).int64(J.duration), J.size !== void 0 && J.size !== 0 && ye.uint32(32).int64(J.size), J.location !== void 0 && J.location !== "" && ye.uint32(42).string(J.location), ye;
    },
    decode(J, ye) {
      const we = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let We = ye === void 0 ? we.len : we.pos + ye;
      const Re = ce();
      for (; we.pos < We; ) {
        const q = we.uint32();
        switch (q >>> 3) {
          case 1:
            Re.filename = we.string();
            break;
          case 2:
            Re.startedAt = gt(we.int64());
            break;
          case 3:
            Re.endedAt = gt(we.int64());
            break;
          case 6:
            Re.duration = gt(we.int64());
            break;
          case 4:
            Re.size = gt(we.int64());
            break;
          case 5:
            Re.location = we.string();
            break;
          default:
            we.skipType(q & 7);
            break;
        }
      }
      return Re;
    },
    fromJSON(J) {
      return {
        filename: Ge(J.filename) ? String(J.filename) : "",
        startedAt: Ge(J.startedAt) ? Number(J.startedAt) : 0,
        endedAt: Ge(J.endedAt) ? Number(J.endedAt) : 0,
        duration: Ge(J.duration) ? Number(J.duration) : 0,
        size: Ge(J.size) ? Number(J.size) : 0,
        location: Ge(J.location) ? String(J.location) : ""
      };
    },
    toJSON(J) {
      const ye = {};
      return J.filename !== void 0 && (ye.filename = J.filename), J.startedAt !== void 0 && (ye.startedAt = Math.round(J.startedAt)), J.endedAt !== void 0 && (ye.endedAt = Math.round(J.endedAt)), J.duration !== void 0 && (ye.duration = Math.round(J.duration)), J.size !== void 0 && (ye.size = Math.round(J.size)), J.location !== void 0 && (ye.location = J.location), ye;
    },
    fromPartial(J) {
      var ye, we, We, Re, q, ke;
      const de = ce();
      return de.filename = (ye = J.filename) !== null && ye !== void 0 ? ye : "", de.startedAt = (we = J.startedAt) !== null && we !== void 0 ? we : 0, de.endedAt = (We = J.endedAt) !== null && We !== void 0 ? We : 0, de.duration = (Re = J.duration) !== null && Re !== void 0 ? Re : 0, de.size = (q = J.size) !== null && q !== void 0 ? q : 0, de.location = (ke = J.location) !== null && ke !== void 0 ? ke : "", de;
    }
  };
  function De() {
    return { playlistName: "", duration: 0, size: 0, playlistLocation: "", segmentCount: 0, startedAt: 0, endedAt: 0 };
  }
  a.SegmentsInfo = {
    encode(J, ye = l.default.Writer.create()) {
      return J.playlistName !== void 0 && J.playlistName !== "" && ye.uint32(10).string(J.playlistName), J.duration !== void 0 && J.duration !== 0 && ye.uint32(16).int64(J.duration), J.size !== void 0 && J.size !== 0 && ye.uint32(24).int64(J.size), J.playlistLocation !== void 0 && J.playlistLocation !== "" && ye.uint32(34).string(J.playlistLocation), J.segmentCount !== void 0 && J.segmentCount !== 0 && ye.uint32(40).int64(J.segmentCount), J.startedAt !== void 0 && J.startedAt !== 0 && ye.uint32(48).int64(J.startedAt), J.endedAt !== void 0 && J.endedAt !== 0 && ye.uint32(56).int64(J.endedAt), ye;
    },
    decode(J, ye) {
      const we = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let We = ye === void 0 ? we.len : we.pos + ye;
      const Re = De();
      for (; we.pos < We; ) {
        const q = we.uint32();
        switch (q >>> 3) {
          case 1:
            Re.playlistName = we.string();
            break;
          case 2:
            Re.duration = gt(we.int64());
            break;
          case 3:
            Re.size = gt(we.int64());
            break;
          case 4:
            Re.playlistLocation = we.string();
            break;
          case 5:
            Re.segmentCount = gt(we.int64());
            break;
          case 6:
            Re.startedAt = gt(we.int64());
            break;
          case 7:
            Re.endedAt = gt(we.int64());
            break;
          default:
            we.skipType(q & 7);
            break;
        }
      }
      return Re;
    },
    fromJSON(J) {
      return {
        playlistName: Ge(J.playlistName) ? String(J.playlistName) : "",
        duration: Ge(J.duration) ? Number(J.duration) : 0,
        size: Ge(J.size) ? Number(J.size) : 0,
        playlistLocation: Ge(J.playlistLocation) ? String(J.playlistLocation) : "",
        segmentCount: Ge(J.segmentCount) ? Number(J.segmentCount) : 0,
        startedAt: Ge(J.startedAt) ? Number(J.startedAt) : 0,
        endedAt: Ge(J.endedAt) ? Number(J.endedAt) : 0
      };
    },
    toJSON(J) {
      const ye = {};
      return J.playlistName !== void 0 && (ye.playlistName = J.playlistName), J.duration !== void 0 && (ye.duration = Math.round(J.duration)), J.size !== void 0 && (ye.size = Math.round(J.size)), J.playlistLocation !== void 0 && (ye.playlistLocation = J.playlistLocation), J.segmentCount !== void 0 && (ye.segmentCount = Math.round(J.segmentCount)), J.startedAt !== void 0 && (ye.startedAt = Math.round(J.startedAt)), J.endedAt !== void 0 && (ye.endedAt = Math.round(J.endedAt)), ye;
    },
    fromPartial(J) {
      var ye, we, We, Re, q, ke, de;
      const ue = De();
      return ue.playlistName = (ye = J.playlistName) !== null && ye !== void 0 ? ye : "", ue.duration = (we = J.duration) !== null && we !== void 0 ? we : 0, ue.size = (We = J.size) !== null && We !== void 0 ? We : 0, ue.playlistLocation = (Re = J.playlistLocation) !== null && Re !== void 0 ? Re : "", ue.segmentCount = (q = J.segmentCount) !== null && q !== void 0 ? q : 0, ue.startedAt = (ke = J.startedAt) !== null && ke !== void 0 ? ke : 0, ue.endedAt = (de = J.endedAt) !== null && de !== void 0 ? de : 0, ue;
    }
  };
  function Ne() {
    return { filepath: "", disableManifest: !1, s3: void 0, gcp: void 0, azure: void 0 };
  }
  a.AutoTrackEgress = {
    encode(J, ye = l.default.Writer.create()) {
      return J.filepath !== void 0 && J.filepath !== "" && ye.uint32(10).string(J.filepath), J.disableManifest === !0 && ye.uint32(40).bool(J.disableManifest), J.s3 !== void 0 && a.S3Upload.encode(J.s3, ye.uint32(18).fork()).ldelim(), J.gcp !== void 0 && a.GCPUpload.encode(J.gcp, ye.uint32(26).fork()).ldelim(), J.azure !== void 0 && a.AzureBlobUpload.encode(J.azure, ye.uint32(34).fork()).ldelim(), ye;
    },
    decode(J, ye) {
      const we = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let We = ye === void 0 ? we.len : we.pos + ye;
      const Re = Ne();
      for (; we.pos < We; ) {
        const q = we.uint32();
        switch (q >>> 3) {
          case 1:
            Re.filepath = we.string();
            break;
          case 5:
            Re.disableManifest = we.bool();
            break;
          case 2:
            Re.s3 = a.S3Upload.decode(we, we.uint32());
            break;
          case 3:
            Re.gcp = a.GCPUpload.decode(we, we.uint32());
            break;
          case 4:
            Re.azure = a.AzureBlobUpload.decode(we, we.uint32());
            break;
          default:
            we.skipType(q & 7);
            break;
        }
      }
      return Re;
    },
    fromJSON(J) {
      return {
        filepath: Ge(J.filepath) ? String(J.filepath) : "",
        disableManifest: Ge(J.disableManifest) ? !!J.disableManifest : !1,
        s3: Ge(J.s3) ? a.S3Upload.fromJSON(J.s3) : void 0,
        gcp: Ge(J.gcp) ? a.GCPUpload.fromJSON(J.gcp) : void 0,
        azure: Ge(J.azure) ? a.AzureBlobUpload.fromJSON(J.azure) : void 0
      };
    },
    toJSON(J) {
      const ye = {};
      return J.filepath !== void 0 && (ye.filepath = J.filepath), J.disableManifest !== void 0 && (ye.disableManifest = J.disableManifest), J.s3 !== void 0 && (ye.s3 = J.s3 ? a.S3Upload.toJSON(J.s3) : void 0), J.gcp !== void 0 && (ye.gcp = J.gcp ? a.GCPUpload.toJSON(J.gcp) : void 0), J.azure !== void 0 && (ye.azure = J.azure ? a.AzureBlobUpload.toJSON(J.azure) : void 0), ye;
    },
    fromPartial(J) {
      var ye, we;
      const We = Ne();
      return We.filepath = (ye = J.filepath) !== null && ye !== void 0 ? ye : "", We.disableManifest = (we = J.disableManifest) !== null && we !== void 0 ? we : !1, We.s3 = J.s3 !== void 0 && J.s3 !== null ? a.S3Upload.fromPartial(J.s3) : void 0, We.gcp = J.gcp !== void 0 && J.gcp !== null ? a.GCPUpload.fromPartial(J.gcp) : void 0, We.azure = J.azure !== void 0 && J.azure !== null ? a.AzureBlobUpload.fromPartial(J.azure) : void 0, We;
    }
  };
  var Fe = (() => {
    if (typeof Fe < "u")
      return Fe;
    if (typeof self < "u")
      return self;
    if (typeof window < "u")
      return window;
    if (typeof commonjsGlobal$1 < "u")
      return commonjsGlobal$1;
    throw "Unable to locate global object";
  })();
  function Ze(J) {
    if (Fe.Buffer)
      return Uint8Array.from(Fe.Buffer.from(J, "base64"));
    {
      const ye = Fe.atob(J), we = new Uint8Array(ye.length);
      for (let We = 0; We < ye.length; ++We)
        we[We] = ye.charCodeAt(We);
      return we;
    }
  }
  function qe(J) {
    if (Fe.Buffer)
      return Fe.Buffer.from(J).toString("base64");
    {
      const ye = [];
      return J.forEach((we) => {
        ye.push(String.fromCharCode(we));
      }), Fe.btoa(ye.join(""));
    }
  }
  function gt(J) {
    if (J.gt(Number.MAX_SAFE_INTEGER))
      throw new Fe.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    return J.toNumber();
  }
  l.default.util.Long !== c.default && (l.default.util.Long = c.default, l.default.configure());
  function Xe(J) {
    return typeof J == "object" && J !== null;
  }
  function Ge(J) {
    return J != null;
  }
})(livekit_egress);
var ServiceBase$1 = {};
Object.defineProperty(ServiceBase$1, "__esModule", { value: !0 });
const AccessToken_1$1 = AccessToken$1;
class ServiceBase {
  /**
   * @param apiKey API Key.
   * @param secret API Secret.
   * @param ttl token TTL
   */
  constructor(u, c, l) {
    this.apiKey = u, this.secret = c, this.ttl = l || "10m";
  }
  authHeader(u) {
    const c = new AccessToken_1$1.AccessToken(this.apiKey, this.secret, { ttl: this.ttl });
    return c.addGrant(u), {
      Authorization: `Bearer ${c.toJwt()}`
    };
  }
}
ServiceBase$1.default = ServiceBase;
var TwirpRPC = {}, axios$2 = { exports: {} }, bind$2 = function a(u, c) {
  return function() {
    for (var v = new Array(arguments.length), p = 0; p < v.length; p++)
      v[p] = arguments[p];
    return u.apply(c, v);
  };
}, bind$1 = bind$2, toString = Object.prototype.toString;
function isArray$1(a) {
  return toString.call(a) === "[object Array]";
}
function isUndefined(a) {
  return typeof a > "u";
}
function isBuffer(a) {
  return a !== null && !isUndefined(a) && a.constructor !== null && !isUndefined(a.constructor) && typeof a.constructor.isBuffer == "function" && a.constructor.isBuffer(a);
}
function isArrayBuffer(a) {
  return toString.call(a) === "[object ArrayBuffer]";
}
function isFormData(a) {
  return typeof FormData < "u" && a instanceof FormData;
}
function isArrayBufferView(a) {
  var u;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? u = ArrayBuffer.isView(a) : u = a && a.buffer && a.buffer instanceof ArrayBuffer, u;
}
function isString(a) {
  return typeof a == "string";
}
function isNumber(a) {
  return typeof a == "number";
}
function isObject$2(a) {
  return a !== null && typeof a == "object";
}
function isPlainObject(a) {
  if (toString.call(a) !== "[object Object]")
    return !1;
  var u = Object.getPrototypeOf(a);
  return u === null || u === Object.prototype;
}
function isDate(a) {
  return toString.call(a) === "[object Date]";
}
function isFile(a) {
  return toString.call(a) === "[object File]";
}
function isBlob(a) {
  return toString.call(a) === "[object Blob]";
}
function isFunction(a) {
  return toString.call(a) === "[object Function]";
}
function isStream(a) {
  return isObject$2(a) && isFunction(a.pipe);
}
function isURLSearchParams(a) {
  return typeof URLSearchParams < "u" && a instanceof URLSearchParams;
}
function trim$1(a) {
  return a.trim ? a.trim() : a.replace(/^\s+|\s+$/g, "");
}
function isStandardBrowserEnv() {
  return typeof navigator < "u" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS") ? !1 : typeof window < "u" && typeof document < "u";
}
function forEach(a, u) {
  if (!(a === null || typeof a > "u"))
    if (typeof a != "object" && (a = [a]), isArray$1(a))
      for (var c = 0, l = a.length; c < l; c++)
        u.call(null, a[c], c, a);
    else
      for (var v in a)
        Object.prototype.hasOwnProperty.call(a, v) && u.call(null, a[v], v, a);
}
function merge() {
  var a = {};
  function u(v, p) {
    isPlainObject(a[p]) && isPlainObject(v) ? a[p] = merge(a[p], v) : isPlainObject(v) ? a[p] = merge({}, v) : isArray$1(v) ? a[p] = v.slice() : a[p] = v;
  }
  for (var c = 0, l = arguments.length; c < l; c++)
    forEach(arguments[c], u);
  return a;
}
function extend(a, u, c) {
  return forEach(u, function(v, p) {
    c && typeof v == "function" ? a[p] = bind$1(v, c) : a[p] = v;
  }), a;
}
function stripBOM(a) {
  return a.charCodeAt(0) === 65279 && (a = a.slice(1)), a;
}
var utils$9 = {
  isArray: isArray$1,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isObject: isObject$2,
  isPlainObject,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isFunction,
  isStream,
  isURLSearchParams,
  isStandardBrowserEnv,
  forEach,
  merge,
  extend,
  trim: trim$1,
  stripBOM
}, utils$8 = utils$9;
function encode(a) {
  return encodeURIComponent(a).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
var buildURL$1 = function a(u, c, l) {
  if (!c)
    return u;
  var v;
  if (l)
    v = l(c);
  else if (utils$8.isURLSearchParams(c))
    v = c.toString();
  else {
    var p = [];
    utils$8.forEach(c, function(M, L) {
      M === null || typeof M > "u" || (utils$8.isArray(M) ? L = L + "[]" : M = [M], utils$8.forEach(M, function(V) {
        utils$8.isDate(V) ? V = V.toISOString() : utils$8.isObject(V) && (V = JSON.stringify(V)), p.push(encode(L) + "=" + encode(V));
      }));
    }), v = p.join("&");
  }
  if (v) {
    var _ = u.indexOf("#");
    _ !== -1 && (u = u.slice(0, _)), u += (u.indexOf("?") === -1 ? "?" : "&") + v;
  }
  return u;
}, utils$7 = utils$9;
function InterceptorManager$1() {
  this.handlers = [];
}
InterceptorManager$1.prototype.use = function a(u, c, l) {
  return this.handlers.push({
    fulfilled: u,
    rejected: c,
    synchronous: l ? l.synchronous : !1,
    runWhen: l ? l.runWhen : null
  }), this.handlers.length - 1;
};
InterceptorManager$1.prototype.eject = function a(u) {
  this.handlers[u] && (this.handlers[u] = null);
};
InterceptorManager$1.prototype.forEach = function a(u) {
  utils$7.forEach(this.handlers, function(l) {
    l !== null && u(l);
  });
};
var InterceptorManager_1 = InterceptorManager$1, utils$6 = utils$9, normalizeHeaderName$1 = function a(u, c) {
  utils$6.forEach(u, function(v, p) {
    p !== c && p.toUpperCase() === c.toUpperCase() && (u[c] = v, delete u[p]);
  });
}, enhanceError$1 = function a(u, c, l, v, p) {
  return u.config = c, l && (u.code = l), u.request = v, u.response = p, u.isAxiosError = !0, u.toJSON = function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code
    };
  }, u;
}, createError, hasRequiredCreateError;
function requireCreateError() {
  if (hasRequiredCreateError)
    return createError;
  hasRequiredCreateError = 1;
  var a = enhanceError$1;
  return createError = function(c, l, v, p, _) {
    var k = new Error(c);
    return a(k, l, v, p, _);
  }, createError;
}
var settle, hasRequiredSettle;
function requireSettle() {
  if (hasRequiredSettle)
    return settle;
  hasRequiredSettle = 1;
  var a = requireCreateError();
  return settle = function(c, l, v) {
    var p = v.config.validateStatus;
    !v.status || !p || p(v.status) ? c(v) : l(a(
      "Request failed with status code " + v.status,
      v.config,
      null,
      v.request,
      v
    ));
  }, settle;
}
var cookies, hasRequiredCookies;
function requireCookies() {
  if (hasRequiredCookies)
    return cookies;
  hasRequiredCookies = 1;
  var a = utils$9;
  return cookies = a.isStandardBrowserEnv() ? (
    // Standard browser envs support document.cookie
    /* @__PURE__ */ function() {
      return {
        write: function(l, v, p, _, k, M) {
          var L = [];
          L.push(l + "=" + encodeURIComponent(v)), a.isNumber(p) && L.push("expires=" + new Date(p).toGMTString()), a.isString(_) && L.push("path=" + _), a.isString(k) && L.push("domain=" + k), M === !0 && L.push("secure"), document.cookie = L.join("; ");
        },
        read: function(l) {
          var v = document.cookie.match(new RegExp("(^|;\\s*)(" + l + ")=([^;]*)"));
          return v ? decodeURIComponent(v[3]) : null;
        },
        remove: function(l) {
          this.write(l, "", Date.now() - 864e5);
        }
      };
    }()
  ) : (
    // Non standard browser env (web workers, react-native) lack needed support.
    /* @__PURE__ */ function() {
      return {
        write: function() {
        },
        read: function() {
          return null;
        },
        remove: function() {
        }
      };
    }()
  ), cookies;
}
var isAbsoluteURL, hasRequiredIsAbsoluteURL;
function requireIsAbsoluteURL() {
  return hasRequiredIsAbsoluteURL || (hasRequiredIsAbsoluteURL = 1, isAbsoluteURL = function(u) {
    return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(u);
  }), isAbsoluteURL;
}
var combineURLs, hasRequiredCombineURLs;
function requireCombineURLs() {
  return hasRequiredCombineURLs || (hasRequiredCombineURLs = 1, combineURLs = function(u, c) {
    return c ? u.replace(/\/+$/, "") + "/" + c.replace(/^\/+/, "") : u;
  }), combineURLs;
}
var buildFullPath, hasRequiredBuildFullPath;
function requireBuildFullPath() {
  if (hasRequiredBuildFullPath)
    return buildFullPath;
  hasRequiredBuildFullPath = 1;
  var a = requireIsAbsoluteURL(), u = requireCombineURLs();
  return buildFullPath = function(l, v) {
    return l && !a(v) ? u(l, v) : v;
  }, buildFullPath;
}
var parseHeaders, hasRequiredParseHeaders;
function requireParseHeaders() {
  if (hasRequiredParseHeaders)
    return parseHeaders;
  hasRequiredParseHeaders = 1;
  var a = utils$9, u = [
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ];
  return parseHeaders = function(l) {
    var v = {}, p, _, k;
    return l && a.forEach(l.split(`
`), function(L) {
      if (k = L.indexOf(":"), p = a.trim(L.substr(0, k)).toLowerCase(), _ = a.trim(L.substr(k + 1)), p) {
        if (v[p] && u.indexOf(p) >= 0)
          return;
        p === "set-cookie" ? v[p] = (v[p] ? v[p] : []).concat([_]) : v[p] = v[p] ? v[p] + ", " + _ : _;
      }
    }), v;
  }, parseHeaders;
}
var isURLSameOrigin, hasRequiredIsURLSameOrigin;
function requireIsURLSameOrigin() {
  if (hasRequiredIsURLSameOrigin)
    return isURLSameOrigin;
  hasRequiredIsURLSameOrigin = 1;
  var a = utils$9;
  return isURLSameOrigin = a.isStandardBrowserEnv() ? (
    // Standard browser envs have full support of the APIs needed to test
    // whether the request URL is of the same origin as current location.
    function() {
      var c = /(msie|trident)/i.test(navigator.userAgent), l = document.createElement("a"), v;
      function p(_) {
        var k = _;
        return c && (l.setAttribute("href", k), k = l.href), l.setAttribute("href", k), {
          href: l.href,
          protocol: l.protocol ? l.protocol.replace(/:$/, "") : "",
          host: l.host,
          search: l.search ? l.search.replace(/^\?/, "") : "",
          hash: l.hash ? l.hash.replace(/^#/, "") : "",
          hostname: l.hostname,
          port: l.port,
          pathname: l.pathname.charAt(0) === "/" ? l.pathname : "/" + l.pathname
        };
      }
      return v = p(window.location.href), function(k) {
        var M = a.isString(k) ? p(k) : k;
        return M.protocol === v.protocol && M.host === v.host;
      };
    }()
  ) : (
    // Non standard browser envs (web workers, react-native) lack needed support.
    /* @__PURE__ */ function() {
      return function() {
        return !0;
      };
    }()
  ), isURLSameOrigin;
}
var xhr, hasRequiredXhr;
function requireXhr() {
  if (hasRequiredXhr)
    return xhr;
  hasRequiredXhr = 1;
  var a = utils$9, u = requireSettle(), c = requireCookies(), l = buildURL$1, v = requireBuildFullPath(), p = requireParseHeaders(), _ = requireIsURLSameOrigin(), k = requireCreateError();
  return xhr = function(L) {
    return new Promise(function(V, X) {
      var oe = L.data, Y = L.headers, ae = L.responseType;
      a.isFormData(oe) && delete Y["Content-Type"];
      var ne = new XMLHttpRequest();
      if (L.auth) {
        var fe = L.auth.username || "", ie = L.auth.password ? unescape(encodeURIComponent(L.auth.password)) : "";
        Y.Authorization = "Basic " + btoa(fe + ":" + ie);
      }
      var ge = v(L.baseURL, L.url);
      ne.open(L.method.toUpperCase(), l(ge, L.params, L.paramsSerializer), !0), ne.timeout = L.timeout;
      function be() {
        if (ne) {
          var Me = "getAllResponseHeaders" in ne ? p(ne.getAllResponseHeaders()) : null, Be = !ae || ae === "text" || ae === "json" ? ne.responseText : ne.response, Ae = {
            data: Be,
            status: ne.status,
            statusText: ne.statusText,
            headers: Me,
            config: L,
            request: ne
          };
          u(V, X, Ae), ne = null;
        }
      }
      if ("onloadend" in ne ? ne.onloadend = be : ne.onreadystatechange = function() {
        !ne || ne.readyState !== 4 || ne.status === 0 && !(ne.responseURL && ne.responseURL.indexOf("file:") === 0) || setTimeout(be);
      }, ne.onabort = function() {
        ne && (X(k("Request aborted", L, "ECONNABORTED", ne)), ne = null);
      }, ne.onerror = function() {
        X(k("Network Error", L, null, ne)), ne = null;
      }, ne.ontimeout = function() {
        var Be = "timeout of " + L.timeout + "ms exceeded";
        L.timeoutErrorMessage && (Be = L.timeoutErrorMessage), X(k(
          Be,
          L,
          L.transitional && L.transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED",
          ne
        )), ne = null;
      }, a.isStandardBrowserEnv()) {
        var Ce = (L.withCredentials || _(ge)) && L.xsrfCookieName ? c.read(L.xsrfCookieName) : void 0;
        Ce && (Y[L.xsrfHeaderName] = Ce);
      }
      "setRequestHeader" in ne && a.forEach(Y, function(Be, Ae) {
        typeof oe > "u" && Ae.toLowerCase() === "content-type" ? delete Y[Ae] : ne.setRequestHeader(Ae, Be);
      }), a.isUndefined(L.withCredentials) || (ne.withCredentials = !!L.withCredentials), ae && ae !== "json" && (ne.responseType = L.responseType), typeof L.onDownloadProgress == "function" && ne.addEventListener("progress", L.onDownloadProgress), typeof L.onUploadProgress == "function" && ne.upload && ne.upload.addEventListener("progress", L.onUploadProgress), L.cancelToken && L.cancelToken.promise.then(function(Be) {
        ne && (ne.abort(), X(Be), ne = null);
      }), oe || (oe = null), ne.send(oe);
    });
  }, xhr;
}
var utils$5 = utils$9, normalizeHeaderName = normalizeHeaderName$1, enhanceError = enhanceError$1, DEFAULT_CONTENT_TYPE = {
  "Content-Type": "application/x-www-form-urlencoded"
};
function setContentTypeIfUnset(a, u) {
  !utils$5.isUndefined(a) && utils$5.isUndefined(a["Content-Type"]) && (a["Content-Type"] = u);
}
function getDefaultAdapter() {
  var a;
  return (typeof XMLHttpRequest < "u" || typeof process$1 < "u" && Object.prototype.toString.call(process$1) === "[object process]") && (a = requireXhr()), a;
}
function stringifySafely(a, u, c) {
  if (utils$5.isString(a))
    try {
      return (u || JSON.parse)(a), utils$5.trim(a);
    } catch (l) {
      if (l.name !== "SyntaxError")
        throw l;
    }
  return (c || JSON.stringify)(a);
}
var defaults$3 = {
  transitional: {
    silentJSONParsing: !0,
    forcedJSONParsing: !0,
    clarifyTimeoutError: !1
  },
  adapter: getDefaultAdapter(),
  transformRequest: [function a(u, c) {
    return normalizeHeaderName(c, "Accept"), normalizeHeaderName(c, "Content-Type"), utils$5.isFormData(u) || utils$5.isArrayBuffer(u) || utils$5.isBuffer(u) || utils$5.isStream(u) || utils$5.isFile(u) || utils$5.isBlob(u) ? u : utils$5.isArrayBufferView(u) ? u.buffer : utils$5.isURLSearchParams(u) ? (setContentTypeIfUnset(c, "application/x-www-form-urlencoded;charset=utf-8"), u.toString()) : utils$5.isObject(u) || c && c["Content-Type"] === "application/json" ? (setContentTypeIfUnset(c, "application/json"), stringifySafely(u)) : u;
  }],
  transformResponse: [function a(u) {
    var c = this.transitional, l = c && c.silentJSONParsing, v = c && c.forcedJSONParsing, p = !l && this.responseType === "json";
    if (p || v && utils$5.isString(u) && u.length)
      try {
        return JSON.parse(u);
      } catch (_) {
        if (p)
          throw _.name === "SyntaxError" ? enhanceError(_, this, "E_JSON_PARSE") : _;
      }
    return u;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  validateStatus: function a(u) {
    return u >= 200 && u < 300;
  }
};
defaults$3.headers = {
  common: {
    Accept: "application/json, text/plain, */*"
  }
};
utils$5.forEach(["delete", "get", "head"], function a(u) {
  defaults$3.headers[u] = {};
});
utils$5.forEach(["post", "put", "patch"], function a(u) {
  defaults$3.headers[u] = utils$5.merge(DEFAULT_CONTENT_TYPE);
});
var defaults_1 = defaults$3, utils$4 = utils$9, defaults$2 = defaults_1, transformData$1 = function a(u, c, l) {
  var v = this || defaults$2;
  return utils$4.forEach(l, function(_) {
    u = _.call(v, u, c);
  }), u;
}, isCancel$1, hasRequiredIsCancel;
function requireIsCancel() {
  return hasRequiredIsCancel || (hasRequiredIsCancel = 1, isCancel$1 = function(u) {
    return !!(u && u.__CANCEL__);
  }), isCancel$1;
}
var utils$3 = utils$9, transformData = transformData$1, isCancel = requireIsCancel(), defaults$1 = defaults_1;
function throwIfCancellationRequested(a) {
  a.cancelToken && a.cancelToken.throwIfRequested();
}
var dispatchRequest$1 = function a(u) {
  throwIfCancellationRequested(u), u.headers = u.headers || {}, u.data = transformData.call(
    u,
    u.data,
    u.headers,
    u.transformRequest
  ), u.headers = utils$3.merge(
    u.headers.common || {},
    u.headers[u.method] || {},
    u.headers
  ), utils$3.forEach(
    ["delete", "get", "head", "post", "put", "patch", "common"],
    function(v) {
      delete u.headers[v];
    }
  );
  var c = u.adapter || defaults$1.adapter;
  return c(u).then(function(v) {
    return throwIfCancellationRequested(u), v.data = transformData.call(
      u,
      v.data,
      v.headers,
      u.transformResponse
    ), v;
  }, function(v) {
    return isCancel(v) || (throwIfCancellationRequested(u), v && v.response && (v.response.data = transformData.call(
      u,
      v.response.data,
      v.response.headers,
      u.transformResponse
    ))), Promise.reject(v);
  });
}, utils$2 = utils$9, mergeConfig$2 = function a(u, c) {
  c = c || {};
  var l = {}, v = ["url", "method", "data"], p = ["headers", "auth", "proxy", "params"], _ = [
    "baseURL",
    "transformRequest",
    "transformResponse",
    "paramsSerializer",
    "timeout",
    "timeoutMessage",
    "withCredentials",
    "adapter",
    "responseType",
    "xsrfCookieName",
    "xsrfHeaderName",
    "onUploadProgress",
    "onDownloadProgress",
    "decompress",
    "maxContentLength",
    "maxBodyLength",
    "maxRedirects",
    "transport",
    "httpAgent",
    "httpsAgent",
    "cancelToken",
    "socketPath",
    "responseEncoding"
  ], k = ["validateStatus"];
  function M(X, oe) {
    return utils$2.isPlainObject(X) && utils$2.isPlainObject(oe) ? utils$2.merge(X, oe) : utils$2.isPlainObject(oe) ? utils$2.merge({}, oe) : utils$2.isArray(oe) ? oe.slice() : oe;
  }
  function L(X) {
    utils$2.isUndefined(c[X]) ? utils$2.isUndefined(u[X]) || (l[X] = M(void 0, u[X])) : l[X] = M(u[X], c[X]);
  }
  utils$2.forEach(v, function(oe) {
    utils$2.isUndefined(c[oe]) || (l[oe] = M(void 0, c[oe]));
  }), utils$2.forEach(p, L), utils$2.forEach(_, function(oe) {
    utils$2.isUndefined(c[oe]) ? utils$2.isUndefined(u[oe]) || (l[oe] = M(void 0, u[oe])) : l[oe] = M(void 0, c[oe]);
  }), utils$2.forEach(k, function(oe) {
    oe in c ? l[oe] = M(u[oe], c[oe]) : oe in u && (l[oe] = M(void 0, u[oe]));
  });
  var F = v.concat(p).concat(_).concat(k), V = Object.keys(u).concat(Object.keys(c)).filter(function(oe) {
    return F.indexOf(oe) === -1;
  });
  return utils$2.forEach(V, L), l;
};
const name = "axios", version = "0.21.4", description = "Promise based HTTP client for the browser and node.js", main = "index.js", scripts = {
  test: "grunt test",
  start: "node ./sandbox/server.js",
  build: "NODE_ENV=production grunt build",
  preversion: "npm test",
  version: "npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json",
  postversion: "git push && git push --tags",
  examples: "node ./examples/server.js",
  coveralls: "cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js",
  fix: "eslint --fix lib/**/*.js"
}, repository = {
  type: "git",
  url: "https://github.com/axios/axios.git"
}, keywords = [
  "xhr",
  "http",
  "ajax",
  "promise",
  "node"
], author = "Matt Zabriskie", license = "MIT", bugs = {
  url: "https://github.com/axios/axios/issues"
}, homepage = "https://axios-http.com", devDependencies = {
  coveralls: "^3.0.0",
  "es6-promise": "^4.2.4",
  grunt: "^1.3.0",
  "grunt-banner": "^0.6.0",
  "grunt-cli": "^1.2.0",
  "grunt-contrib-clean": "^1.1.0",
  "grunt-contrib-watch": "^1.0.0",
  "grunt-eslint": "^23.0.0",
  "grunt-karma": "^4.0.0",
  "grunt-mocha-test": "^0.13.3",
  "grunt-ts": "^6.0.0-beta.19",
  "grunt-webpack": "^4.0.2",
  "istanbul-instrumenter-loader": "^1.0.0",
  "jasmine-core": "^2.4.1",
  karma: "^6.3.2",
  "karma-chrome-launcher": "^3.1.0",
  "karma-firefox-launcher": "^2.1.0",
  "karma-jasmine": "^1.1.1",
  "karma-jasmine-ajax": "^0.1.13",
  "karma-safari-launcher": "^1.0.0",
  "karma-sauce-launcher": "^4.3.6",
  "karma-sinon": "^1.0.5",
  "karma-sourcemap-loader": "^0.3.8",
  "karma-webpack": "^4.0.2",
  "load-grunt-tasks": "^3.5.2",
  minimist: "^1.2.0",
  mocha: "^8.2.1",
  sinon: "^4.5.0",
  "terser-webpack-plugin": "^4.2.3",
  typescript: "^4.0.5",
  "url-search-params": "^0.10.0",
  webpack: "^4.44.2",
  "webpack-dev-server": "^3.11.0"
}, browser = {
  "./lib/adapters/http.js": "./lib/adapters/xhr.js"
}, jsdelivr = "dist/axios.min.js", unpkg = "dist/axios.min.js", typings = "./index.d.ts", dependencies = {
  "follow-redirects": "^1.14.0"
}, bundlesize = [
  {
    path: "./dist/axios.min.js",
    threshold: "5kB"
  }
], require$$0 = {
  name,
  version,
  description,
  main,
  scripts,
  repository,
  keywords,
  author,
  license,
  bugs,
  homepage,
  devDependencies,
  browser,
  jsdelivr,
  unpkg,
  typings,
  dependencies,
  bundlesize
};
var pkg = require$$0, validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach(function(a, u) {
  validators$1[a] = function(l) {
    return typeof l === a || "a" + (u < 1 ? "n " : " ") + a;
  };
});
var deprecatedWarnings = {}, currentVerArr = pkg.version.split(".");
function isOlderVersion(a, u) {
  for (var c = u ? u.split(".") : currentVerArr, l = a.split("."), v = 0; v < 3; v++) {
    if (c[v] > l[v])
      return !0;
    if (c[v] < l[v])
      return !1;
  }
  return !1;
}
validators$1.transitional = function a(u, c, l) {
  var v = c && isOlderVersion(c);
  function p(_, k) {
    return "[Axios v" + pkg.version + "] Transitional option '" + _ + "'" + k + (l ? ". " + l : "");
  }
  return function(_, k, M) {
    if (u === !1)
      throw new Error(p(k, " has been removed in " + c));
    return v && !deprecatedWarnings[k] && (deprecatedWarnings[k] = !0, console.warn(
      p(
        k,
        " has been deprecated since v" + c + " and will be removed in the near future"
      )
    )), u ? u(_, k, M) : !0;
  };
};
function assertOptions(a, u, c) {
  if (typeof a != "object")
    throw new TypeError("options must be an object");
  for (var l = Object.keys(a), v = l.length; v-- > 0; ) {
    var p = l[v], _ = u[p];
    if (_) {
      var k = a[p], M = k === void 0 || _(k, p, a);
      if (M !== !0)
        throw new TypeError("option " + p + " must be " + M);
      continue;
    }
    if (c !== !0)
      throw Error("Unknown option " + p);
  }
}
var validator$1 = {
  isOlderVersion,
  assertOptions,
  validators: validators$1
}, utils$1 = utils$9, buildURL = buildURL$1, InterceptorManager = InterceptorManager_1, dispatchRequest = dispatchRequest$1, mergeConfig$1 = mergeConfig$2, validator = validator$1, validators = validator.validators;
function Axios$1(a) {
  this.defaults = a, this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}
Axios$1.prototype.request = function a(u) {
  typeof u == "string" ? (u = arguments[1] || {}, u.url = arguments[0]) : u = u || {}, u = mergeConfig$1(this.defaults, u), u.method ? u.method = u.method.toLowerCase() : this.defaults.method ? u.method = this.defaults.method.toLowerCase() : u.method = "get";
  var c = u.transitional;
  c !== void 0 && validator.assertOptions(c, {
    silentJSONParsing: validators.transitional(validators.boolean, "1.0.0"),
    forcedJSONParsing: validators.transitional(validators.boolean, "1.0.0"),
    clarifyTimeoutError: validators.transitional(validators.boolean, "1.0.0")
  }, !1);
  var l = [], v = !0;
  this.interceptors.request.forEach(function(X) {
    typeof X.runWhen == "function" && X.runWhen(u) === !1 || (v = v && X.synchronous, l.unshift(X.fulfilled, X.rejected));
  });
  var p = [];
  this.interceptors.response.forEach(function(X) {
    p.push(X.fulfilled, X.rejected);
  });
  var _;
  if (!v) {
    var k = [dispatchRequest, void 0];
    for (Array.prototype.unshift.apply(k, l), k = k.concat(p), _ = Promise.resolve(u); k.length; )
      _ = _.then(k.shift(), k.shift());
    return _;
  }
  for (var M = u; l.length; ) {
    var L = l.shift(), F = l.shift();
    try {
      M = L(M);
    } catch (V) {
      F(V);
      break;
    }
  }
  try {
    _ = dispatchRequest(M);
  } catch (V) {
    return Promise.reject(V);
  }
  for (; p.length; )
    _ = _.then(p.shift(), p.shift());
  return _;
};
Axios$1.prototype.getUri = function a(u) {
  return u = mergeConfig$1(this.defaults, u), buildURL(u.url, u.params, u.paramsSerializer).replace(/^\?/, "");
};
utils$1.forEach(["delete", "get", "head", "options"], function a(u) {
  Axios$1.prototype[u] = function(c, l) {
    return this.request(mergeConfig$1(l || {}, {
      method: u,
      url: c,
      data: (l || {}).data
    }));
  };
});
utils$1.forEach(["post", "put", "patch"], function a(u) {
  Axios$1.prototype[u] = function(c, l, v) {
    return this.request(mergeConfig$1(v || {}, {
      method: u,
      url: c,
      data: l
    }));
  };
});
var Axios_1 = Axios$1, Cancel_1, hasRequiredCancel;
function requireCancel() {
  if (hasRequiredCancel)
    return Cancel_1;
  hasRequiredCancel = 1;
  function a(u) {
    this.message = u;
  }
  return a.prototype.toString = function() {
    return "Cancel" + (this.message ? ": " + this.message : "");
  }, a.prototype.__CANCEL__ = !0, Cancel_1 = a, Cancel_1;
}
var CancelToken_1, hasRequiredCancelToken;
function requireCancelToken() {
  if (hasRequiredCancelToken)
    return CancelToken_1;
  hasRequiredCancelToken = 1;
  var a = requireCancel();
  function u(c) {
    if (typeof c != "function")
      throw new TypeError("executor must be a function.");
    var l;
    this.promise = new Promise(function(_) {
      l = _;
    });
    var v = this;
    c(function(_) {
      v.reason || (v.reason = new a(_), l(v.reason));
    });
  }
  return u.prototype.throwIfRequested = function() {
    if (this.reason)
      throw this.reason;
  }, u.source = function() {
    var l, v = new u(function(_) {
      l = _;
    });
    return {
      token: v,
      cancel: l
    };
  }, CancelToken_1 = u, CancelToken_1;
}
var spread, hasRequiredSpread;
function requireSpread() {
  return hasRequiredSpread || (hasRequiredSpread = 1, spread = function(u) {
    return function(l) {
      return u.apply(null, l);
    };
  }), spread;
}
var isAxiosError, hasRequiredIsAxiosError;
function requireIsAxiosError() {
  return hasRequiredIsAxiosError || (hasRequiredIsAxiosError = 1, isAxiosError = function(u) {
    return typeof u == "object" && u.isAxiosError === !0;
  }), isAxiosError;
}
var utils = utils$9, bind = bind$2, Axios = Axios_1, mergeConfig = mergeConfig$2, defaults = defaults_1;
function createInstance(a) {
  var u = new Axios(a), c = bind(Axios.prototype.request, u);
  return utils.extend(c, Axios.prototype, u), utils.extend(c, u), c;
}
var axios$1 = createInstance(defaults);
axios$1.Axios = Axios;
axios$1.create = function a(u) {
  return createInstance(mergeConfig(axios$1.defaults, u));
};
axios$1.Cancel = requireCancel();
axios$1.CancelToken = requireCancelToken();
axios$1.isCancel = requireIsCancel();
axios$1.all = function a(u) {
  return Promise.all(u);
};
axios$1.spread = requireSpread();
axios$1.isAxiosError = requireIsAxiosError();
axios$2.exports = axios$1;
axios$2.exports.default = axios$1;
var axiosExports = axios$2.exports, axios = axiosExports, mapObj$1 = { exports: {} };
const isObject$1 = (a) => typeof a == "object" && a !== null, mapObjectSkip = Symbol("skip"), isObjectCustom = (a) => isObject$1(a) && !(a instanceof RegExp) && !(a instanceof Error) && !(a instanceof Date), mapObject = (a, u, c, l = /* @__PURE__ */ new WeakMap()) => {
  if (c = {
    deep: !1,
    target: {},
    ...c
  }, l.has(a))
    return l.get(a);
  l.set(a, c.target);
  const { target: v } = c;
  delete c.target;
  const p = (_) => _.map((k) => isObjectCustom(k) ? mapObject(k, u, c, l) : k);
  if (Array.isArray(a))
    return p(a);
  for (const [_, k] of Object.entries(a)) {
    const M = u(_, k, a);
    if (M === mapObjectSkip)
      continue;
    let [L, F, { shouldRecurse: V = !0 } = {}] = M;
    L !== "__proto__" && (c.deep && V && isObjectCustom(F) && (F = Array.isArray(F) ? p(F) : mapObject(F, u, c, l)), v[L] = F);
  }
  return v;
};
mapObj$1.exports = (a, u, c) => {
  if (!isObject$1(a))
    throw new TypeError(`Expected an object, got \`${a}\` (${typeof a})`);
  return mapObject(a, u, c);
};
mapObj$1.exports.mapObjectSkip = mapObjectSkip;
var mapObjExports = mapObj$1.exports, camelcase = { exports: {} };
const UPPERCASE = /[\p{Lu}]/u, LOWERCASE = /[\p{Ll}]/u, LEADING_CAPITAL = /^[\p{Lu}](?![\p{Lu}])/gu, IDENTIFIER = /([\p{Alpha}\p{N}_]|$)/u, SEPARATORS = /[_.\- ]+/, LEADING_SEPARATORS = new RegExp("^" + SEPARATORS.source), SEPARATORS_AND_IDENTIFIER = new RegExp(SEPARATORS.source + IDENTIFIER.source, "gu"), NUMBERS_AND_IDENTIFIER = new RegExp("\\d+" + IDENTIFIER.source, "gu"), preserveCamelCase = (a, u, c) => {
  let l = !1, v = !1, p = !1;
  for (let _ = 0; _ < a.length; _++) {
    const k = a[_];
    l && UPPERCASE.test(k) ? (a = a.slice(0, _) + "-" + a.slice(_), l = !1, p = v, v = !0, _++) : v && p && LOWERCASE.test(k) ? (a = a.slice(0, _ - 1) + "-" + a.slice(_ - 1), p = v, v = !1, l = !0) : (l = u(k) === k && c(k) !== k, p = v, v = c(k) === k && u(k) !== k);
  }
  return a;
}, preserveConsecutiveUppercase = (a, u) => (LEADING_CAPITAL.lastIndex = 0, a.replace(LEADING_CAPITAL, (c) => u(c))), postProcess = (a, u) => (SEPARATORS_AND_IDENTIFIER.lastIndex = 0, NUMBERS_AND_IDENTIFIER.lastIndex = 0, a.replace(SEPARATORS_AND_IDENTIFIER, (c, l) => u(l)).replace(NUMBERS_AND_IDENTIFIER, (c) => u(c))), camelCase$1 = (a, u) => {
  if (!(typeof a == "string" || Array.isArray(a)))
    throw new TypeError("Expected the input to be `string | string[]`");
  if (u = {
    pascalCase: !1,
    preserveConsecutiveUppercase: !1,
    ...u
  }, Array.isArray(a) ? a = a.map((p) => p.trim()).filter((p) => p.length).join("-") : a = a.trim(), a.length === 0)
    return "";
  const c = u.locale === !1 ? (p) => p.toLowerCase() : (p) => p.toLocaleLowerCase(u.locale), l = u.locale === !1 ? (p) => p.toUpperCase() : (p) => p.toLocaleUpperCase(u.locale);
  return a.length === 1 ? u.pascalCase ? l(a) : c(a) : (a !== c(a) && (a = preserveCamelCase(a, c, l)), a = a.replace(LEADING_SEPARATORS, ""), u.preserveConsecutiveUppercase ? a = preserveConsecutiveUppercase(a, c) : a = c(a), u.pascalCase && (a = l(a.charAt(0)) + a.slice(1)), postProcess(a, l));
};
camelcase.exports = camelCase$1;
camelcase.exports.default = camelCase$1;
var camelcaseExports = camelcase.exports;
class QuickLRU {
  constructor(u = {}) {
    if (!(u.maxSize && u.maxSize > 0))
      throw new TypeError("`maxSize` must be a number greater than 0");
    this.maxSize = u.maxSize, this.onEviction = u.onEviction, this.cache = /* @__PURE__ */ new Map(), this.oldCache = /* @__PURE__ */ new Map(), this._size = 0;
  }
  _set(u, c) {
    if (this.cache.set(u, c), this._size++, this._size >= this.maxSize) {
      if (this._size = 0, typeof this.onEviction == "function")
        for (const [l, v] of this.oldCache.entries())
          this.onEviction(l, v);
      this.oldCache = this.cache, this.cache = /* @__PURE__ */ new Map();
    }
  }
  get(u) {
    if (this.cache.has(u))
      return this.cache.get(u);
    if (this.oldCache.has(u)) {
      const c = this.oldCache.get(u);
      return this.oldCache.delete(u), this._set(u, c), c;
    }
  }
  set(u, c) {
    return this.cache.has(u) ? this.cache.set(u, c) : this._set(u, c), this;
  }
  has(u) {
    return this.cache.has(u) || this.oldCache.has(u);
  }
  peek(u) {
    if (this.cache.has(u))
      return this.cache.get(u);
    if (this.oldCache.has(u))
      return this.oldCache.get(u);
  }
  delete(u) {
    const c = this.cache.delete(u);
    return c && this._size--, this.oldCache.delete(u) || c;
  }
  clear() {
    this.cache.clear(), this.oldCache.clear(), this._size = 0;
  }
  *keys() {
    for (const [u] of this)
      yield u;
  }
  *values() {
    for (const [, u] of this)
      yield u;
  }
  *[Symbol.iterator]() {
    for (const u of this.cache)
      yield u;
    for (const u of this.oldCache) {
      const [c] = u;
      this.cache.has(c) || (yield u);
    }
  }
  get size() {
    let u = 0;
    for (const c of this.oldCache.keys())
      this.cache.has(c) || u++;
    return Math.min(this._size + u, this.maxSize);
  }
}
var quickLru = QuickLRU;
const mapObj = mapObjExports, camelCase = camelcaseExports, QuickLru = quickLru, has$1 = (a, u) => a.some((c) => typeof c == "string" ? c === u : (c.lastIndex = 0, c.test(u))), cache$1 = new QuickLru({ maxSize: 1e5 }), isObject = (a) => typeof a == "object" && a !== null && !(a instanceof RegExp) && !(a instanceof Error) && !(a instanceof Date), camelCaseConvert = (a, u) => {
  if (!isObject(a))
    return a;
  u = {
    deep: !1,
    pascalCase: !1,
    ...u
  };
  const { exclude: c, pascalCase: l, stopPaths: v, deep: p } = u, _ = new Set(v), k = (M) => (L, F) => {
    if (p && isObject(F)) {
      const V = M === void 0 ? L : `${M}.${L}`;
      _.has(V) || (F = mapObj(F, k(V)));
    }
    if (!(c && has$1(c, L))) {
      const V = l ? `${L}_` : L;
      if (cache$1.has(V))
        L = cache$1.get(V);
      else {
        const X = camelCase(L, { pascalCase: l, locale: !1 });
        L.length < 100 && cache$1.set(V, X), L = X;
      }
    }
    return [L, F];
  };
  return mapObj(a, k(void 0));
};
var camelcaseKeys = (a, u) => Array.isArray(a) ? Object.keys(a).map((c) => camelCaseConvert(a[c], u)) : camelCaseConvert(a, u), __importDefault$6 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(TwirpRPC, "__esModule", { value: !0 });
TwirpRPC.TwirpRpc = TwirpRPC.livekitPackage = void 0;
const axios_1 = __importDefault$6(axios), camelcase_keys_1 = __importDefault$6(camelcaseKeys), defaultPrefix = "/twirp";
TwirpRPC.livekitPackage = "livekit";
class TwirpRpc {
  constructor(u, c, l, v) {
    this.host = u, this.pkg = c, this.prefix = l || defaultPrefix, this.instance = axios_1.default.create({
      baseURL: u,
      headers: Object.assign({}, v ? { Host: v } : {})
    });
  }
  request(u, c, l, v) {
    return new Promise((p, _) => {
      const k = `${this.prefix}/${this.pkg}.${u}/${c}`;
      this.instance.post(k, l, { headers: v }).then((M) => {
        p(camelcase_keys_1.default(M.data, { deep: !0 }));
      }).catch(_);
    });
  }
}
TwirpRPC.TwirpRpc = TwirpRpc;
var __awaiter$2 = commonjsGlobal$1 && commonjsGlobal$1.__awaiter || function(a, u, c, l) {
  function v(p) {
    return p instanceof c ? p : new c(function(_) {
      _(p);
    });
  }
  return new (c || (c = Promise))(function(p, _) {
    function k(F) {
      try {
        L(l.next(F));
      } catch (V) {
        _(V);
      }
    }
    function M(F) {
      try {
        L(l.throw(F));
      } catch (V) {
        _(V);
      }
    }
    function L(F) {
      F.done ? p(F.value) : v(F.value).then(k, M);
    }
    L((l = l.apply(a, u || [])).next());
  });
}, __importDefault$5 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(EgressClient$1, "__esModule", { value: !0 });
EgressClient$1.EgressClient = void 0;
const livekit_egress_1$1 = livekit_egress, ServiceBase_1$2 = __importDefault$5(ServiceBase$1), TwirpRPC_1$2 = TwirpRPC, svc$2 = "Egress";
class EgressClient extends ServiceBase_1$2.default {
  /**
   * @param host hostname including protocol. i.e. 'https://cluster.livekit.io'
   * @param apiKey API Key, can be set in env var LIVEKIT_API_KEY
   * @param secret API Secret, can be set in env var LIVEKIT_API_SECRET
   */
  constructor(u, c, l) {
    super(c, l), this.rpc = new TwirpRPC_1$2.TwirpRpc(u, TwirpRPC_1$2.livekitPackage);
  }
  startRoomCompositeEgress(u, c, l, v, p, _, k) {
    return __awaiter$2(this, void 0, void 0, function* () {
      let M;
      if (l !== void 0)
        if (typeof l == "string")
          M = l;
        else {
          const ne = l;
          M = ne.layout, v = ne.encodingOptions, p = ne.audioOnly, _ = ne.videoOnly, k = ne.customBaseUrl;
        }
      M ?? (M = ""), p ?? (p = !1), _ ?? (_ = !1), k ?? (k = "");
      const { file: L, segments: F, stream: V, preset: X, advanced: oe } = this.getOutputParams(c, v), Y = livekit_egress_1$1.RoomCompositeEgressRequest.toJSON({
        roomName: u,
        layout: M,
        audioOnly: p,
        videoOnly: _,
        customBaseUrl: k,
        file: L,
        stream: V,
        segments: F,
        preset: X,
        advanced: oe
      }), ae = yield this.rpc.request(svc$2, "StartRoomCompositeEgress", Y, this.authHeader({ roomRecord: !0 }));
      return livekit_egress_1$1.EgressInfo.fromJSON(ae);
    });
  }
  /**
   * @param url url
   * @param output file or stream output
   * @param opts WebOptions
   */
  startWebEgress(u, c, l) {
    return __awaiter$2(this, void 0, void 0, function* () {
      const v = (l == null ? void 0 : l.audioOnly) || !1, p = (l == null ? void 0 : l.videoOnly) || !1, { file: _, segments: k, stream: M, preset: L, advanced: F } = this.getOutputParams(c, l == null ? void 0 : l.encodingOptions), V = livekit_egress_1$1.WebEgressRequest.toJSON({
        url: u,
        audioOnly: v,
        videoOnly: p,
        file: _,
        stream: M,
        segments: k,
        preset: L,
        advanced: F
      }), X = yield this.rpc.request(svc$2, "StartWebEgress", V, this.authHeader({ roomRecord: !0 }));
      return livekit_egress_1$1.EgressInfo.fromJSON(X);
    });
  }
  startTrackCompositeEgress(u, c, l, v, p) {
    return __awaiter$2(this, void 0, void 0, function* () {
      let _;
      if (l !== void 0)
        if (typeof l == "string")
          _ = l;
        else {
          const Y = l;
          _ = Y.audioTrackId, v = Y.videoTrackId, p = Y.encodingOptions;
        }
      _ ?? (_ = ""), v ?? (v = "");
      const { file: k, segments: M, stream: L, preset: F, advanced: V } = this.getOutputParams(c, p), X = livekit_egress_1$1.TrackCompositeEgressRequest.toJSON({
        roomName: u,
        audioTrackId: _,
        videoTrackId: v,
        file: k,
        stream: L,
        segments: M,
        preset: F,
        advanced: V
      }), oe = yield this.rpc.request(svc$2, "StartTrackCompositeEgress", X, this.authHeader({ roomRecord: !0 }));
      return livekit_egress_1$1.EgressInfo.fromJSON(oe);
    });
  }
  getOutputParams(u, c) {
    let l, v, p, _, k;
    return u.filepath !== void 0 ? l = u : u.filenamePrefix !== void 0 ? p = u : v = u, c && (typeof c == "number" ? _ = c : k = c), { file: l, segments: p, stream: v, preset: _, advanced: k };
  }
  /**
   * @param roomName room name
   * @param output file or websocket output
   * @param trackId track Id
   */
  startTrackEgress(u, c, l) {
    return __awaiter$2(this, void 0, void 0, function* () {
      let v, p;
      c.filepath !== void 0 ? v = c : p = c;
      const _ = livekit_egress_1$1.TrackEgressRequest.toJSON({
        roomName: u,
        trackId: l,
        file: v,
        websocketUrl: p
      }), k = yield this.rpc.request(svc$2, "StartTrackEgress", _, this.authHeader({ roomRecord: !0 }));
      return livekit_egress_1$1.EgressInfo.fromJSON(k);
    });
  }
  /**
   * @param egressId
   * @param layout
   */
  updateLayout(u, c) {
    return __awaiter$2(this, void 0, void 0, function* () {
      const l = yield this.rpc.request(svc$2, "UpdateLayout", livekit_egress_1$1.UpdateLayoutRequest.toJSON({ egressId: u, layout: c }), this.authHeader({ roomRecord: !0 }));
      return livekit_egress_1$1.EgressInfo.fromJSON(l);
    });
  }
  /**
   * @param egressId
   * @param addOutputUrls
   * @param removeOutputUrls
   */
  updateStream(u, c, l) {
    return __awaiter$2(this, void 0, void 0, function* () {
      c ?? (c = []), l ?? (l = []);
      const v = yield this.rpc.request(svc$2, "UpdateStream", livekit_egress_1$1.UpdateStreamRequest.toJSON({ egressId: u, addOutputUrls: c, removeOutputUrls: l }), this.authHeader({ roomRecord: !0 }));
      return livekit_egress_1$1.EgressInfo.fromJSON(v);
    });
  }
  /**
   * @param roomName list egress for one room only
   */
  listEgress(u) {
    var c;
    return __awaiter$2(this, void 0, void 0, function* () {
      u ?? (u = "");
      const l = yield this.rpc.request(svc$2, "ListEgress", livekit_egress_1$1.ListEgressRequest.toJSON({ roomName: u }), this.authHeader({ roomRecord: !0 }));
      return (c = livekit_egress_1$1.ListEgressResponse.fromJSON(l).items) !== null && c !== void 0 ? c : [];
    });
  }
  /**
   * @param egressId
   */
  stopEgress(u) {
    return __awaiter$2(this, void 0, void 0, function* () {
      const c = yield this.rpc.request(svc$2, "StopEgress", livekit_egress_1$1.StopEgressRequest.toJSON({ egressId: u }), this.authHeader({ roomRecord: !0 }));
      return livekit_egress_1$1.EgressInfo.fromJSON(c);
    });
  }
}
EgressClient$1.EgressClient = EgressClient;
var grants = {};
Object.defineProperty(grants, "__esModule", { value: !0 });
var IngressClient$1 = {}, livekit_ingress = {}, livekit_models = {}, timestamp = {}, __importDefault$4 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(timestamp, "__esModule", { value: !0 });
timestamp.Timestamp = timestamp.protobufPackage = void 0;
const long_1$1 = __importDefault$4(umdExports), minimal_1$1 = __importDefault$4(minimal);
timestamp.protobufPackage = "google.protobuf";
function createBaseTimestamp() {
  return { seconds: 0, nanos: 0 };
}
timestamp.Timestamp = {
  encode(a, u = minimal_1$1.default.Writer.create()) {
    return a.seconds !== 0 && u.uint32(8).int64(a.seconds), a.nanos !== 0 && u.uint32(16).int32(a.nanos), u;
  },
  decode(a, u) {
    const c = a instanceof minimal_1$1.default.Reader ? a : new minimal_1$1.default.Reader(a);
    let l = u === void 0 ? c.len : c.pos + u;
    const v = createBaseTimestamp();
    for (; c.pos < l; ) {
      const p = c.uint32();
      switch (p >>> 3) {
        case 1:
          v.seconds = longToNumber$1(c.int64());
          break;
        case 2:
          v.nanos = c.int32();
          break;
        default:
          c.skipType(p & 7);
          break;
      }
    }
    return v;
  },
  fromJSON(a) {
    return {
      seconds: isSet$1(a.seconds) ? Number(a.seconds) : 0,
      nanos: isSet$1(a.nanos) ? Number(a.nanos) : 0
    };
  },
  toJSON(a) {
    const u = {};
    return a.seconds !== void 0 && (u.seconds = Math.round(a.seconds)), a.nanos !== void 0 && (u.nanos = Math.round(a.nanos)), u;
  },
  fromPartial(a) {
    var u, c;
    const l = createBaseTimestamp();
    return l.seconds = (u = a.seconds) !== null && u !== void 0 ? u : 0, l.nanos = (c = a.nanos) !== null && c !== void 0 ? c : 0, l;
  }
};
var globalThis$2 = (() => {
  if (typeof globalThis$2 < "u")
    return globalThis$2;
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof commonjsGlobal$1 < "u")
    return commonjsGlobal$1;
  throw "Unable to locate global object";
})();
function longToNumber$1(a) {
  if (a.gt(Number.MAX_SAFE_INTEGER))
    throw new globalThis$2.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  return a.toNumber();
}
minimal_1$1.default.util.Long !== long_1$1.default && (minimal_1$1.default.util.Long = long_1$1.default, minimal_1$1.default.configure());
function isSet$1(a) {
  return a != null;
}
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(q) {
    return q && q.__esModule ? q : { default: q };
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.RTPStats_GapHistogramEntry = a.RTPStats = a.DisabledCodecs = a.VideoConfiguration = a.ClientConfiguration = a.ClientInfo = a.ServerInfo = a.ParticipantTracks = a.UserPacket = a.SpeakerInfo = a.ActiveSpeakerUpdate = a.DataPacket = a.VideoLayer = a.TrackInfo = a.SimulcastCodecInfo = a.ParticipantInfo = a.ParticipantPermission = a.Codec = a.Room = a.clientInfo_SDKToJSON = a.clientInfo_SDKFromJSON = a.ClientInfo_SDK = a.serverInfo_EditionToJSON = a.serverInfo_EditionFromJSON = a.ServerInfo_Edition = a.dataPacket_KindToJSON = a.dataPacket_KindFromJSON = a.DataPacket_Kind = a.participantInfo_StateToJSON = a.participantInfo_StateFromJSON = a.ParticipantInfo_State = a.disconnectReasonToJSON = a.disconnectReasonFromJSON = a.DisconnectReason = a.clientConfigSettingToJSON = a.clientConfigSettingFromJSON = a.ClientConfigSetting = a.connectionQualityToJSON = a.connectionQualityFromJSON = a.ConnectionQuality = a.videoQualityToJSON = a.videoQualityFromJSON = a.VideoQuality = a.trackSourceToJSON = a.trackSourceFromJSON = a.TrackSource = a.trackTypeToJSON = a.trackTypeFromJSON = a.TrackType = a.protobufPackage = void 0, a.TimedVersion = void 0;
  const c = u(umdExports), l = u(minimal), v = timestamp;
  a.protobufPackage = "livekit";
  var p;
  (function(q) {
    q[q.AUDIO = 0] = "AUDIO", q[q.VIDEO = 1] = "VIDEO", q[q.DATA = 2] = "DATA", q[q.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(p = a.TrackType || (a.TrackType = {}));
  function _(q) {
    switch (q) {
      case 0:
      case "AUDIO":
        return p.AUDIO;
      case 1:
      case "VIDEO":
        return p.VIDEO;
      case 2:
      case "DATA":
        return p.DATA;
      case -1:
      case "UNRECOGNIZED":
      default:
        return p.UNRECOGNIZED;
    }
  }
  a.trackTypeFromJSON = _;
  function k(q) {
    switch (q) {
      case p.AUDIO:
        return "AUDIO";
      case p.VIDEO:
        return "VIDEO";
      case p.DATA:
        return "DATA";
      case p.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.trackTypeToJSON = k;
  var M;
  (function(q) {
    q[q.UNKNOWN = 0] = "UNKNOWN", q[q.CAMERA = 1] = "CAMERA", q[q.MICROPHONE = 2] = "MICROPHONE", q[q.SCREEN_SHARE = 3] = "SCREEN_SHARE", q[q.SCREEN_SHARE_AUDIO = 4] = "SCREEN_SHARE_AUDIO", q[q.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(M = a.TrackSource || (a.TrackSource = {}));
  function L(q) {
    switch (q) {
      case 0:
      case "UNKNOWN":
        return M.UNKNOWN;
      case 1:
      case "CAMERA":
        return M.CAMERA;
      case 2:
      case "MICROPHONE":
        return M.MICROPHONE;
      case 3:
      case "SCREEN_SHARE":
        return M.SCREEN_SHARE;
      case 4:
      case "SCREEN_SHARE_AUDIO":
        return M.SCREEN_SHARE_AUDIO;
      case -1:
      case "UNRECOGNIZED":
      default:
        return M.UNRECOGNIZED;
    }
  }
  a.trackSourceFromJSON = L;
  function F(q) {
    switch (q) {
      case M.UNKNOWN:
        return "UNKNOWN";
      case M.CAMERA:
        return "CAMERA";
      case M.MICROPHONE:
        return "MICROPHONE";
      case M.SCREEN_SHARE:
        return "SCREEN_SHARE";
      case M.SCREEN_SHARE_AUDIO:
        return "SCREEN_SHARE_AUDIO";
      case M.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.trackSourceToJSON = F;
  var V;
  (function(q) {
    q[q.LOW = 0] = "LOW", q[q.MEDIUM = 1] = "MEDIUM", q[q.HIGH = 2] = "HIGH", q[q.OFF = 3] = "OFF", q[q.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(V = a.VideoQuality || (a.VideoQuality = {}));
  function X(q) {
    switch (q) {
      case 0:
      case "LOW":
        return V.LOW;
      case 1:
      case "MEDIUM":
        return V.MEDIUM;
      case 2:
      case "HIGH":
        return V.HIGH;
      case 3:
      case "OFF":
        return V.OFF;
      case -1:
      case "UNRECOGNIZED":
      default:
        return V.UNRECOGNIZED;
    }
  }
  a.videoQualityFromJSON = X;
  function oe(q) {
    switch (q) {
      case V.LOW:
        return "LOW";
      case V.MEDIUM:
        return "MEDIUM";
      case V.HIGH:
        return "HIGH";
      case V.OFF:
        return "OFF";
      case V.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.videoQualityToJSON = oe;
  var Y;
  (function(q) {
    q[q.POOR = 0] = "POOR", q[q.GOOD = 1] = "GOOD", q[q.EXCELLENT = 2] = "EXCELLENT", q[q.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(Y = a.ConnectionQuality || (a.ConnectionQuality = {}));
  function ae(q) {
    switch (q) {
      case 0:
      case "POOR":
        return Y.POOR;
      case 1:
      case "GOOD":
        return Y.GOOD;
      case 2:
      case "EXCELLENT":
        return Y.EXCELLENT;
      case -1:
      case "UNRECOGNIZED":
      default:
        return Y.UNRECOGNIZED;
    }
  }
  a.connectionQualityFromJSON = ae;
  function ne(q) {
    switch (q) {
      case Y.POOR:
        return "POOR";
      case Y.GOOD:
        return "GOOD";
      case Y.EXCELLENT:
        return "EXCELLENT";
      case Y.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.connectionQualityToJSON = ne;
  var fe;
  (function(q) {
    q[q.UNSET = 0] = "UNSET", q[q.DISABLED = 1] = "DISABLED", q[q.ENABLED = 2] = "ENABLED", q[q.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(fe = a.ClientConfigSetting || (a.ClientConfigSetting = {}));
  function ie(q) {
    switch (q) {
      case 0:
      case "UNSET":
        return fe.UNSET;
      case 1:
      case "DISABLED":
        return fe.DISABLED;
      case 2:
      case "ENABLED":
        return fe.ENABLED;
      case -1:
      case "UNRECOGNIZED":
      default:
        return fe.UNRECOGNIZED;
    }
  }
  a.clientConfigSettingFromJSON = ie;
  function ge(q) {
    switch (q) {
      case fe.UNSET:
        return "UNSET";
      case fe.DISABLED:
        return "DISABLED";
      case fe.ENABLED:
        return "ENABLED";
      case fe.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.clientConfigSettingToJSON = ge;
  var be;
  (function(q) {
    q[q.UNKNOWN_REASON = 0] = "UNKNOWN_REASON", q[q.CLIENT_INITIATED = 1] = "CLIENT_INITIATED", q[q.DUPLICATE_IDENTITY = 2] = "DUPLICATE_IDENTITY", q[q.SERVER_SHUTDOWN = 3] = "SERVER_SHUTDOWN", q[q.PARTICIPANT_REMOVED = 4] = "PARTICIPANT_REMOVED", q[q.ROOM_DELETED = 5] = "ROOM_DELETED", q[q.STATE_MISMATCH = 6] = "STATE_MISMATCH", q[q.JOIN_FAILURE = 7] = "JOIN_FAILURE", q[q.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(be = a.DisconnectReason || (a.DisconnectReason = {}));
  function Ce(q) {
    switch (q) {
      case 0:
      case "UNKNOWN_REASON":
        return be.UNKNOWN_REASON;
      case 1:
      case "CLIENT_INITIATED":
        return be.CLIENT_INITIATED;
      case 2:
      case "DUPLICATE_IDENTITY":
        return be.DUPLICATE_IDENTITY;
      case 3:
      case "SERVER_SHUTDOWN":
        return be.SERVER_SHUTDOWN;
      case 4:
      case "PARTICIPANT_REMOVED":
        return be.PARTICIPANT_REMOVED;
      case 5:
      case "ROOM_DELETED":
        return be.ROOM_DELETED;
      case 6:
      case "STATE_MISMATCH":
        return be.STATE_MISMATCH;
      case 7:
      case "JOIN_FAILURE":
        return be.JOIN_FAILURE;
      case -1:
      case "UNRECOGNIZED":
      default:
        return be.UNRECOGNIZED;
    }
  }
  a.disconnectReasonFromJSON = Ce;
  function Me(q) {
    switch (q) {
      case be.UNKNOWN_REASON:
        return "UNKNOWN_REASON";
      case be.CLIENT_INITIATED:
        return "CLIENT_INITIATED";
      case be.DUPLICATE_IDENTITY:
        return "DUPLICATE_IDENTITY";
      case be.SERVER_SHUTDOWN:
        return "SERVER_SHUTDOWN";
      case be.PARTICIPANT_REMOVED:
        return "PARTICIPANT_REMOVED";
      case be.ROOM_DELETED:
        return "ROOM_DELETED";
      case be.STATE_MISMATCH:
        return "STATE_MISMATCH";
      case be.JOIN_FAILURE:
        return "JOIN_FAILURE";
      case be.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.disconnectReasonToJSON = Me;
  var Be;
  (function(q) {
    q[q.JOINING = 0] = "JOINING", q[q.JOINED = 1] = "JOINED", q[q.ACTIVE = 2] = "ACTIVE", q[q.DISCONNECTED = 3] = "DISCONNECTED", q[q.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(Be = a.ParticipantInfo_State || (a.ParticipantInfo_State = {}));
  function Ae(q) {
    switch (q) {
      case 0:
      case "JOINING":
        return Be.JOINING;
      case 1:
      case "JOINED":
        return Be.JOINED;
      case 2:
      case "ACTIVE":
        return Be.ACTIVE;
      case 3:
      case "DISCONNECTED":
        return Be.DISCONNECTED;
      case -1:
      case "UNRECOGNIZED":
      default:
        return Be.UNRECOGNIZED;
    }
  }
  a.participantInfo_StateFromJSON = Ae;
  function Z(q) {
    switch (q) {
      case Be.JOINING:
        return "JOINING";
      case Be.JOINED:
        return "JOINED";
      case Be.ACTIVE:
        return "ACTIVE";
      case Be.DISCONNECTED:
        return "DISCONNECTED";
      case Be.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.participantInfo_StateToJSON = Z;
  var z;
  (function(q) {
    q[q.RELIABLE = 0] = "RELIABLE", q[q.LOSSY = 1] = "LOSSY", q[q.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(z = a.DataPacket_Kind || (a.DataPacket_Kind = {}));
  function P(q) {
    switch (q) {
      case 0:
      case "RELIABLE":
        return z.RELIABLE;
      case 1:
      case "LOSSY":
        return z.LOSSY;
      case -1:
      case "UNRECOGNIZED":
      default:
        return z.UNRECOGNIZED;
    }
  }
  a.dataPacket_KindFromJSON = P;
  function S(q) {
    switch (q) {
      case z.RELIABLE:
        return "RELIABLE";
      case z.LOSSY:
        return "LOSSY";
      case z.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.dataPacket_KindToJSON = S;
  var E;
  (function(q) {
    q[q.Standard = 0] = "Standard", q[q.Cloud = 1] = "Cloud", q[q.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(E = a.ServerInfo_Edition || (a.ServerInfo_Edition = {}));
  function I(q) {
    switch (q) {
      case 0:
      case "Standard":
        return E.Standard;
      case 1:
      case "Cloud":
        return E.Cloud;
      case -1:
      case "UNRECOGNIZED":
      default:
        return E.UNRECOGNIZED;
    }
  }
  a.serverInfo_EditionFromJSON = I;
  function N(q) {
    switch (q) {
      case E.Standard:
        return "Standard";
      case E.Cloud:
        return "Cloud";
      case E.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.serverInfo_EditionToJSON = N;
  var $;
  (function(q) {
    q[q.UNKNOWN = 0] = "UNKNOWN", q[q.JS = 1] = "JS", q[q.SWIFT = 2] = "SWIFT", q[q.ANDROID = 3] = "ANDROID", q[q.FLUTTER = 4] = "FLUTTER", q[q.GO = 5] = "GO", q[q.UNITY = 6] = "UNITY", q[q.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })($ = a.ClientInfo_SDK || (a.ClientInfo_SDK = {}));
  function U(q) {
    switch (q) {
      case 0:
      case "UNKNOWN":
        return $.UNKNOWN;
      case 1:
      case "JS":
        return $.JS;
      case 2:
      case "SWIFT":
        return $.SWIFT;
      case 3:
      case "ANDROID":
        return $.ANDROID;
      case 4:
      case "FLUTTER":
        return $.FLUTTER;
      case 5:
      case "GO":
        return $.GO;
      case 6:
      case "UNITY":
        return $.UNITY;
      case -1:
      case "UNRECOGNIZED":
      default:
        return $.UNRECOGNIZED;
    }
  }
  a.clientInfo_SDKFromJSON = U;
  function H(q) {
    switch (q) {
      case $.UNKNOWN:
        return "UNKNOWN";
      case $.JS:
        return "JS";
      case $.SWIFT:
        return "SWIFT";
      case $.ANDROID:
        return "ANDROID";
      case $.FLUTTER:
        return "FLUTTER";
      case $.GO:
        return "GO";
      case $.UNITY:
        return "UNITY";
      case $.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.clientInfo_SDKToJSON = H;
  function B() {
    return {
      sid: "",
      name: "",
      emptyTimeout: 0,
      maxParticipants: 0,
      creationTime: 0,
      turnPassword: "",
      enabledCodecs: [],
      metadata: "",
      numParticipants: 0,
      activeRecording: !1
    };
  }
  a.Room = {
    encode(q, ke = l.default.Writer.create()) {
      q.sid !== "" && ke.uint32(10).string(q.sid), q.name !== "" && ke.uint32(18).string(q.name), q.emptyTimeout !== 0 && ke.uint32(24).uint32(q.emptyTimeout), q.maxParticipants !== 0 && ke.uint32(32).uint32(q.maxParticipants), q.creationTime !== 0 && ke.uint32(40).int64(q.creationTime), q.turnPassword !== "" && ke.uint32(50).string(q.turnPassword);
      for (const de of q.enabledCodecs)
        a.Codec.encode(de, ke.uint32(58).fork()).ldelim();
      return q.metadata !== "" && ke.uint32(66).string(q.metadata), q.numParticipants !== 0 && ke.uint32(72).uint32(q.numParticipants), q.activeRecording === !0 && ke.uint32(80).bool(q.activeRecording), ke;
    },
    decode(q, ke) {
      const de = q instanceof l.default.Reader ? q : new l.default.Reader(q);
      let ue = ke === void 0 ? de.len : de.pos + ke;
      const me = B();
      for (; de.pos < ue; ) {
        const Oe = de.uint32();
        switch (Oe >>> 3) {
          case 1:
            me.sid = de.string();
            break;
          case 2:
            me.name = de.string();
            break;
          case 3:
            me.emptyTimeout = de.uint32();
            break;
          case 4:
            me.maxParticipants = de.uint32();
            break;
          case 5:
            me.creationTime = we(de.int64());
            break;
          case 6:
            me.turnPassword = de.string();
            break;
          case 7:
            me.enabledCodecs.push(a.Codec.decode(de, de.uint32()));
            break;
          case 8:
            me.metadata = de.string();
            break;
          case 9:
            me.numParticipants = de.uint32();
            break;
          case 10:
            me.activeRecording = de.bool();
            break;
          default:
            de.skipType(Oe & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(q) {
      return {
        sid: Re(q.sid) ? String(q.sid) : "",
        name: Re(q.name) ? String(q.name) : "",
        emptyTimeout: Re(q.emptyTimeout) ? Number(q.emptyTimeout) : 0,
        maxParticipants: Re(q.maxParticipants) ? Number(q.maxParticipants) : 0,
        creationTime: Re(q.creationTime) ? Number(q.creationTime) : 0,
        turnPassword: Re(q.turnPassword) ? String(q.turnPassword) : "",
        enabledCodecs: Array.isArray(q == null ? void 0 : q.enabledCodecs) ? q.enabledCodecs.map((ke) => a.Codec.fromJSON(ke)) : [],
        metadata: Re(q.metadata) ? String(q.metadata) : "",
        numParticipants: Re(q.numParticipants) ? Number(q.numParticipants) : 0,
        activeRecording: Re(q.activeRecording) ? !!q.activeRecording : !1
      };
    },
    toJSON(q) {
      const ke = {};
      return q.sid !== void 0 && (ke.sid = q.sid), q.name !== void 0 && (ke.name = q.name), q.emptyTimeout !== void 0 && (ke.emptyTimeout = Math.round(q.emptyTimeout)), q.maxParticipants !== void 0 && (ke.maxParticipants = Math.round(q.maxParticipants)), q.creationTime !== void 0 && (ke.creationTime = Math.round(q.creationTime)), q.turnPassword !== void 0 && (ke.turnPassword = q.turnPassword), q.enabledCodecs ? ke.enabledCodecs = q.enabledCodecs.map((de) => de ? a.Codec.toJSON(de) : void 0) : ke.enabledCodecs = [], q.metadata !== void 0 && (ke.metadata = q.metadata), q.numParticipants !== void 0 && (ke.numParticipants = Math.round(q.numParticipants)), q.activeRecording !== void 0 && (ke.activeRecording = q.activeRecording), ke;
    },
    fromPartial(q) {
      var ke, de, ue, me, Oe, Ue, ze, Ve, Qe, Ke;
      const x = B();
      return x.sid = (ke = q.sid) !== null && ke !== void 0 ? ke : "", x.name = (de = q.name) !== null && de !== void 0 ? de : "", x.emptyTimeout = (ue = q.emptyTimeout) !== null && ue !== void 0 ? ue : 0, x.maxParticipants = (me = q.maxParticipants) !== null && me !== void 0 ? me : 0, x.creationTime = (Oe = q.creationTime) !== null && Oe !== void 0 ? Oe : 0, x.turnPassword = (Ue = q.turnPassword) !== null && Ue !== void 0 ? Ue : "", x.enabledCodecs = ((ze = q.enabledCodecs) === null || ze === void 0 ? void 0 : ze.map((se) => a.Codec.fromPartial(se))) || [], x.metadata = (Ve = q.metadata) !== null && Ve !== void 0 ? Ve : "", x.numParticipants = (Qe = q.numParticipants) !== null && Qe !== void 0 ? Qe : 0, x.activeRecording = (Ke = q.activeRecording) !== null && Ke !== void 0 ? Ke : !1, x;
    }
  };
  function T() {
    return { mime: "", fmtpLine: "" };
  }
  a.Codec = {
    encode(q, ke = l.default.Writer.create()) {
      return q.mime !== "" && ke.uint32(10).string(q.mime), q.fmtpLine !== "" && ke.uint32(18).string(q.fmtpLine), ke;
    },
    decode(q, ke) {
      const de = q instanceof l.default.Reader ? q : new l.default.Reader(q);
      let ue = ke === void 0 ? de.len : de.pos + ke;
      const me = T();
      for (; de.pos < ue; ) {
        const Oe = de.uint32();
        switch (Oe >>> 3) {
          case 1:
            me.mime = de.string();
            break;
          case 2:
            me.fmtpLine = de.string();
            break;
          default:
            de.skipType(Oe & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(q) {
      return {
        mime: Re(q.mime) ? String(q.mime) : "",
        fmtpLine: Re(q.fmtpLine) ? String(q.fmtpLine) : ""
      };
    },
    toJSON(q) {
      const ke = {};
      return q.mime !== void 0 && (ke.mime = q.mime), q.fmtpLine !== void 0 && (ke.fmtpLine = q.fmtpLine), ke;
    },
    fromPartial(q) {
      var ke, de;
      const ue = T();
      return ue.mime = (ke = q.mime) !== null && ke !== void 0 ? ke : "", ue.fmtpLine = (de = q.fmtpLine) !== null && de !== void 0 ? de : "", ue;
    }
  };
  function D() {
    return { canSubscribe: !1, canPublish: !1, canPublishData: !1, hidden: !1, recorder: !1 };
  }
  a.ParticipantPermission = {
    encode(q, ke = l.default.Writer.create()) {
      return q.canSubscribe === !0 && ke.uint32(8).bool(q.canSubscribe), q.canPublish === !0 && ke.uint32(16).bool(q.canPublish), q.canPublishData === !0 && ke.uint32(24).bool(q.canPublishData), q.hidden === !0 && ke.uint32(56).bool(q.hidden), q.recorder === !0 && ke.uint32(64).bool(q.recorder), ke;
    },
    decode(q, ke) {
      const de = q instanceof l.default.Reader ? q : new l.default.Reader(q);
      let ue = ke === void 0 ? de.len : de.pos + ke;
      const me = D();
      for (; de.pos < ue; ) {
        const Oe = de.uint32();
        switch (Oe >>> 3) {
          case 1:
            me.canSubscribe = de.bool();
            break;
          case 2:
            me.canPublish = de.bool();
            break;
          case 3:
            me.canPublishData = de.bool();
            break;
          case 7:
            me.hidden = de.bool();
            break;
          case 8:
            me.recorder = de.bool();
            break;
          default:
            de.skipType(Oe & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(q) {
      return {
        canSubscribe: Re(q.canSubscribe) ? !!q.canSubscribe : !1,
        canPublish: Re(q.canPublish) ? !!q.canPublish : !1,
        canPublishData: Re(q.canPublishData) ? !!q.canPublishData : !1,
        hidden: Re(q.hidden) ? !!q.hidden : !1,
        recorder: Re(q.recorder) ? !!q.recorder : !1
      };
    },
    toJSON(q) {
      const ke = {};
      return q.canSubscribe !== void 0 && (ke.canSubscribe = q.canSubscribe), q.canPublish !== void 0 && (ke.canPublish = q.canPublish), q.canPublishData !== void 0 && (ke.canPublishData = q.canPublishData), q.hidden !== void 0 && (ke.hidden = q.hidden), q.recorder !== void 0 && (ke.recorder = q.recorder), ke;
    },
    fromPartial(q) {
      var ke, de, ue, me, Oe;
      const Ue = D();
      return Ue.canSubscribe = (ke = q.canSubscribe) !== null && ke !== void 0 ? ke : !1, Ue.canPublish = (de = q.canPublish) !== null && de !== void 0 ? de : !1, Ue.canPublishData = (ue = q.canPublishData) !== null && ue !== void 0 ? ue : !1, Ue.hidden = (me = q.hidden) !== null && me !== void 0 ? me : !1, Ue.recorder = (Oe = q.recorder) !== null && Oe !== void 0 ? Oe : !1, Ue;
    }
  };
  function ee() {
    return {
      sid: "",
      identity: "",
      state: 0,
      tracks: [],
      metadata: "",
      joinedAt: 0,
      name: "",
      version: 0,
      permission: void 0,
      region: "",
      isPublisher: !1
    };
  }
  a.ParticipantInfo = {
    encode(q, ke = l.default.Writer.create()) {
      q.sid !== "" && ke.uint32(10).string(q.sid), q.identity !== "" && ke.uint32(18).string(q.identity), q.state !== 0 && ke.uint32(24).int32(q.state);
      for (const de of q.tracks)
        a.TrackInfo.encode(de, ke.uint32(34).fork()).ldelim();
      return q.metadata !== "" && ke.uint32(42).string(q.metadata), q.joinedAt !== 0 && ke.uint32(48).int64(q.joinedAt), q.name !== "" && ke.uint32(74).string(q.name), q.version !== 0 && ke.uint32(80).uint32(q.version), q.permission !== void 0 && a.ParticipantPermission.encode(q.permission, ke.uint32(90).fork()).ldelim(), q.region !== "" && ke.uint32(98).string(q.region), q.isPublisher === !0 && ke.uint32(104).bool(q.isPublisher), ke;
    },
    decode(q, ke) {
      const de = q instanceof l.default.Reader ? q : new l.default.Reader(q);
      let ue = ke === void 0 ? de.len : de.pos + ke;
      const me = ee();
      for (; de.pos < ue; ) {
        const Oe = de.uint32();
        switch (Oe >>> 3) {
          case 1:
            me.sid = de.string();
            break;
          case 2:
            me.identity = de.string();
            break;
          case 3:
            me.state = de.int32();
            break;
          case 4:
            me.tracks.push(a.TrackInfo.decode(de, de.uint32()));
            break;
          case 5:
            me.metadata = de.string();
            break;
          case 6:
            me.joinedAt = we(de.int64());
            break;
          case 9:
            me.name = de.string();
            break;
          case 10:
            me.version = de.uint32();
            break;
          case 11:
            me.permission = a.ParticipantPermission.decode(de, de.uint32());
            break;
          case 12:
            me.region = de.string();
            break;
          case 13:
            me.isPublisher = de.bool();
            break;
          default:
            de.skipType(Oe & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(q) {
      return {
        sid: Re(q.sid) ? String(q.sid) : "",
        identity: Re(q.identity) ? String(q.identity) : "",
        state: Re(q.state) ? Ae(q.state) : 0,
        tracks: Array.isArray(q == null ? void 0 : q.tracks) ? q.tracks.map((ke) => a.TrackInfo.fromJSON(ke)) : [],
        metadata: Re(q.metadata) ? String(q.metadata) : "",
        joinedAt: Re(q.joinedAt) ? Number(q.joinedAt) : 0,
        name: Re(q.name) ? String(q.name) : "",
        version: Re(q.version) ? Number(q.version) : 0,
        permission: Re(q.permission) ? a.ParticipantPermission.fromJSON(q.permission) : void 0,
        region: Re(q.region) ? String(q.region) : "",
        isPublisher: Re(q.isPublisher) ? !!q.isPublisher : !1
      };
    },
    toJSON(q) {
      const ke = {};
      return q.sid !== void 0 && (ke.sid = q.sid), q.identity !== void 0 && (ke.identity = q.identity), q.state !== void 0 && (ke.state = Z(q.state)), q.tracks ? ke.tracks = q.tracks.map((de) => de ? a.TrackInfo.toJSON(de) : void 0) : ke.tracks = [], q.metadata !== void 0 && (ke.metadata = q.metadata), q.joinedAt !== void 0 && (ke.joinedAt = Math.round(q.joinedAt)), q.name !== void 0 && (ke.name = q.name), q.version !== void 0 && (ke.version = Math.round(q.version)), q.permission !== void 0 && (ke.permission = q.permission ? a.ParticipantPermission.toJSON(q.permission) : void 0), q.region !== void 0 && (ke.region = q.region), q.isPublisher !== void 0 && (ke.isPublisher = q.isPublisher), ke;
    },
    fromPartial(q) {
      var ke, de, ue, me, Oe, Ue, ze, Ve, Qe, Ke;
      const x = ee();
      return x.sid = (ke = q.sid) !== null && ke !== void 0 ? ke : "", x.identity = (de = q.identity) !== null && de !== void 0 ? de : "", x.state = (ue = q.state) !== null && ue !== void 0 ? ue : 0, x.tracks = ((me = q.tracks) === null || me === void 0 ? void 0 : me.map((se) => a.TrackInfo.fromPartial(se))) || [], x.metadata = (Oe = q.metadata) !== null && Oe !== void 0 ? Oe : "", x.joinedAt = (Ue = q.joinedAt) !== null && Ue !== void 0 ? Ue : 0, x.name = (ze = q.name) !== null && ze !== void 0 ? ze : "", x.version = (Ve = q.version) !== null && Ve !== void 0 ? Ve : 0, x.permission = q.permission !== void 0 && q.permission !== null ? a.ParticipantPermission.fromPartial(q.permission) : void 0, x.region = (Qe = q.region) !== null && Qe !== void 0 ? Qe : "", x.isPublisher = (Ke = q.isPublisher) !== null && Ke !== void 0 ? Ke : !1, x;
    }
  };
  function pe() {
    return { mimeType: "", mid: "", cid: "", layers: [] };
  }
  a.SimulcastCodecInfo = {
    encode(q, ke = l.default.Writer.create()) {
      q.mimeType !== "" && ke.uint32(10).string(q.mimeType), q.mid !== "" && ke.uint32(18).string(q.mid), q.cid !== "" && ke.uint32(26).string(q.cid);
      for (const de of q.layers)
        a.VideoLayer.encode(de, ke.uint32(34).fork()).ldelim();
      return ke;
    },
    decode(q, ke) {
      const de = q instanceof l.default.Reader ? q : new l.default.Reader(q);
      let ue = ke === void 0 ? de.len : de.pos + ke;
      const me = pe();
      for (; de.pos < ue; ) {
        const Oe = de.uint32();
        switch (Oe >>> 3) {
          case 1:
            me.mimeType = de.string();
            break;
          case 2:
            me.mid = de.string();
            break;
          case 3:
            me.cid = de.string();
            break;
          case 4:
            me.layers.push(a.VideoLayer.decode(de, de.uint32()));
            break;
          default:
            de.skipType(Oe & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(q) {
      return {
        mimeType: Re(q.mimeType) ? String(q.mimeType) : "",
        mid: Re(q.mid) ? String(q.mid) : "",
        cid: Re(q.cid) ? String(q.cid) : "",
        layers: Array.isArray(q == null ? void 0 : q.layers) ? q.layers.map((ke) => a.VideoLayer.fromJSON(ke)) : []
      };
    },
    toJSON(q) {
      const ke = {};
      return q.mimeType !== void 0 && (ke.mimeType = q.mimeType), q.mid !== void 0 && (ke.mid = q.mid), q.cid !== void 0 && (ke.cid = q.cid), q.layers ? ke.layers = q.layers.map((de) => de ? a.VideoLayer.toJSON(de) : void 0) : ke.layers = [], ke;
    },
    fromPartial(q) {
      var ke, de, ue, me;
      const Oe = pe();
      return Oe.mimeType = (ke = q.mimeType) !== null && ke !== void 0 ? ke : "", Oe.mid = (de = q.mid) !== null && de !== void 0 ? de : "", Oe.cid = (ue = q.cid) !== null && ue !== void 0 ? ue : "", Oe.layers = ((me = q.layers) === null || me === void 0 ? void 0 : me.map((Ue) => a.VideoLayer.fromPartial(Ue))) || [], Oe;
    }
  };
  function Ie() {
    return {
      sid: "",
      type: 0,
      name: "",
      muted: !1,
      width: 0,
      height: 0,
      simulcast: !1,
      disableDtx: !1,
      source: 0,
      layers: [],
      mimeType: "",
      mid: "",
      codecs: [],
      stereo: !1,
      disableRed: !1
    };
  }
  a.TrackInfo = {
    encode(q, ke = l.default.Writer.create()) {
      q.sid !== "" && ke.uint32(10).string(q.sid), q.type !== 0 && ke.uint32(16).int32(q.type), q.name !== "" && ke.uint32(26).string(q.name), q.muted === !0 && ke.uint32(32).bool(q.muted), q.width !== 0 && ke.uint32(40).uint32(q.width), q.height !== 0 && ke.uint32(48).uint32(q.height), q.simulcast === !0 && ke.uint32(56).bool(q.simulcast), q.disableDtx === !0 && ke.uint32(64).bool(q.disableDtx), q.source !== 0 && ke.uint32(72).int32(q.source);
      for (const de of q.layers)
        a.VideoLayer.encode(de, ke.uint32(82).fork()).ldelim();
      q.mimeType !== "" && ke.uint32(90).string(q.mimeType), q.mid !== "" && ke.uint32(98).string(q.mid);
      for (const de of q.codecs)
        a.SimulcastCodecInfo.encode(de, ke.uint32(106).fork()).ldelim();
      return q.stereo === !0 && ke.uint32(112).bool(q.stereo), q.disableRed === !0 && ke.uint32(120).bool(q.disableRed), ke;
    },
    decode(q, ke) {
      const de = q instanceof l.default.Reader ? q : new l.default.Reader(q);
      let ue = ke === void 0 ? de.len : de.pos + ke;
      const me = Ie();
      for (; de.pos < ue; ) {
        const Oe = de.uint32();
        switch (Oe >>> 3) {
          case 1:
            me.sid = de.string();
            break;
          case 2:
            me.type = de.int32();
            break;
          case 3:
            me.name = de.string();
            break;
          case 4:
            me.muted = de.bool();
            break;
          case 5:
            me.width = de.uint32();
            break;
          case 6:
            me.height = de.uint32();
            break;
          case 7:
            me.simulcast = de.bool();
            break;
          case 8:
            me.disableDtx = de.bool();
            break;
          case 9:
            me.source = de.int32();
            break;
          case 10:
            me.layers.push(a.VideoLayer.decode(de, de.uint32()));
            break;
          case 11:
            me.mimeType = de.string();
            break;
          case 12:
            me.mid = de.string();
            break;
          case 13:
            me.codecs.push(a.SimulcastCodecInfo.decode(de, de.uint32()));
            break;
          case 14:
            me.stereo = de.bool();
            break;
          case 15:
            me.disableRed = de.bool();
            break;
          default:
            de.skipType(Oe & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(q) {
      return {
        sid: Re(q.sid) ? String(q.sid) : "",
        type: Re(q.type) ? _(q.type) : 0,
        name: Re(q.name) ? String(q.name) : "",
        muted: Re(q.muted) ? !!q.muted : !1,
        width: Re(q.width) ? Number(q.width) : 0,
        height: Re(q.height) ? Number(q.height) : 0,
        simulcast: Re(q.simulcast) ? !!q.simulcast : !1,
        disableDtx: Re(q.disableDtx) ? !!q.disableDtx : !1,
        source: Re(q.source) ? L(q.source) : 0,
        layers: Array.isArray(q == null ? void 0 : q.layers) ? q.layers.map((ke) => a.VideoLayer.fromJSON(ke)) : [],
        mimeType: Re(q.mimeType) ? String(q.mimeType) : "",
        mid: Re(q.mid) ? String(q.mid) : "",
        codecs: Array.isArray(q == null ? void 0 : q.codecs) ? q.codecs.map((ke) => a.SimulcastCodecInfo.fromJSON(ke)) : [],
        stereo: Re(q.stereo) ? !!q.stereo : !1,
        disableRed: Re(q.disableRed) ? !!q.disableRed : !1
      };
    },
    toJSON(q) {
      const ke = {};
      return q.sid !== void 0 && (ke.sid = q.sid), q.type !== void 0 && (ke.type = k(q.type)), q.name !== void 0 && (ke.name = q.name), q.muted !== void 0 && (ke.muted = q.muted), q.width !== void 0 && (ke.width = Math.round(q.width)), q.height !== void 0 && (ke.height = Math.round(q.height)), q.simulcast !== void 0 && (ke.simulcast = q.simulcast), q.disableDtx !== void 0 && (ke.disableDtx = q.disableDtx), q.source !== void 0 && (ke.source = F(q.source)), q.layers ? ke.layers = q.layers.map((de) => de ? a.VideoLayer.toJSON(de) : void 0) : ke.layers = [], q.mimeType !== void 0 && (ke.mimeType = q.mimeType), q.mid !== void 0 && (ke.mid = q.mid), q.codecs ? ke.codecs = q.codecs.map((de) => de ? a.SimulcastCodecInfo.toJSON(de) : void 0) : ke.codecs = [], q.stereo !== void 0 && (ke.stereo = q.stereo), q.disableRed !== void 0 && (ke.disableRed = q.disableRed), ke;
    },
    fromPartial(q) {
      var ke, de, ue, me, Oe, Ue, ze, Ve, Qe, Ke, x, se, Ee, xe, $e;
      const Ye = Ie();
      return Ye.sid = (ke = q.sid) !== null && ke !== void 0 ? ke : "", Ye.type = (de = q.type) !== null && de !== void 0 ? de : 0, Ye.name = (ue = q.name) !== null && ue !== void 0 ? ue : "", Ye.muted = (me = q.muted) !== null && me !== void 0 ? me : !1, Ye.width = (Oe = q.width) !== null && Oe !== void 0 ? Oe : 0, Ye.height = (Ue = q.height) !== null && Ue !== void 0 ? Ue : 0, Ye.simulcast = (ze = q.simulcast) !== null && ze !== void 0 ? ze : !1, Ye.disableDtx = (Ve = q.disableDtx) !== null && Ve !== void 0 ? Ve : !1, Ye.source = (Qe = q.source) !== null && Qe !== void 0 ? Qe : 0, Ye.layers = ((Ke = q.layers) === null || Ke === void 0 ? void 0 : Ke.map((et) => a.VideoLayer.fromPartial(et))) || [], Ye.mimeType = (x = q.mimeType) !== null && x !== void 0 ? x : "", Ye.mid = (se = q.mid) !== null && se !== void 0 ? se : "", Ye.codecs = ((Ee = q.codecs) === null || Ee === void 0 ? void 0 : Ee.map((et) => a.SimulcastCodecInfo.fromPartial(et))) || [], Ye.stereo = (xe = q.stereo) !== null && xe !== void 0 ? xe : !1, Ye.disableRed = ($e = q.disableRed) !== null && $e !== void 0 ? $e : !1, Ye;
    }
  };
  function Pe() {
    return { quality: 0, width: 0, height: 0, bitrate: 0, ssrc: 0 };
  }
  a.VideoLayer = {
    encode(q, ke = l.default.Writer.create()) {
      return q.quality !== 0 && ke.uint32(8).int32(q.quality), q.width !== 0 && ke.uint32(16).uint32(q.width), q.height !== 0 && ke.uint32(24).uint32(q.height), q.bitrate !== 0 && ke.uint32(32).uint32(q.bitrate), q.ssrc !== 0 && ke.uint32(40).uint32(q.ssrc), ke;
    },
    decode(q, ke) {
      const de = q instanceof l.default.Reader ? q : new l.default.Reader(q);
      let ue = ke === void 0 ? de.len : de.pos + ke;
      const me = Pe();
      for (; de.pos < ue; ) {
        const Oe = de.uint32();
        switch (Oe >>> 3) {
          case 1:
            me.quality = de.int32();
            break;
          case 2:
            me.width = de.uint32();
            break;
          case 3:
            me.height = de.uint32();
            break;
          case 4:
            me.bitrate = de.uint32();
            break;
          case 5:
            me.ssrc = de.uint32();
            break;
          default:
            de.skipType(Oe & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(q) {
      return {
        quality: Re(q.quality) ? X(q.quality) : 0,
        width: Re(q.width) ? Number(q.width) : 0,
        height: Re(q.height) ? Number(q.height) : 0,
        bitrate: Re(q.bitrate) ? Number(q.bitrate) : 0,
        ssrc: Re(q.ssrc) ? Number(q.ssrc) : 0
      };
    },
    toJSON(q) {
      const ke = {};
      return q.quality !== void 0 && (ke.quality = oe(q.quality)), q.width !== void 0 && (ke.width = Math.round(q.width)), q.height !== void 0 && (ke.height = Math.round(q.height)), q.bitrate !== void 0 && (ke.bitrate = Math.round(q.bitrate)), q.ssrc !== void 0 && (ke.ssrc = Math.round(q.ssrc)), ke;
    },
    fromPartial(q) {
      var ke, de, ue, me, Oe;
      const Ue = Pe();
      return Ue.quality = (ke = q.quality) !== null && ke !== void 0 ? ke : 0, Ue.width = (de = q.width) !== null && de !== void 0 ? de : 0, Ue.height = (ue = q.height) !== null && ue !== void 0 ? ue : 0, Ue.bitrate = (me = q.bitrate) !== null && me !== void 0 ? me : 0, Ue.ssrc = (Oe = q.ssrc) !== null && Oe !== void 0 ? Oe : 0, Ue;
    }
  };
  function he() {
    return { kind: 0, user: void 0, speaker: void 0 };
  }
  a.DataPacket = {
    encode(q, ke = l.default.Writer.create()) {
      return q.kind !== 0 && ke.uint32(8).int32(q.kind), q.user !== void 0 && a.UserPacket.encode(q.user, ke.uint32(18).fork()).ldelim(), q.speaker !== void 0 && a.ActiveSpeakerUpdate.encode(q.speaker, ke.uint32(26).fork()).ldelim(), ke;
    },
    decode(q, ke) {
      const de = q instanceof l.default.Reader ? q : new l.default.Reader(q);
      let ue = ke === void 0 ? de.len : de.pos + ke;
      const me = he();
      for (; de.pos < ue; ) {
        const Oe = de.uint32();
        switch (Oe >>> 3) {
          case 1:
            me.kind = de.int32();
            break;
          case 2:
            me.user = a.UserPacket.decode(de, de.uint32());
            break;
          case 3:
            me.speaker = a.ActiveSpeakerUpdate.decode(de, de.uint32());
            break;
          default:
            de.skipType(Oe & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(q) {
      return {
        kind: Re(q.kind) ? P(q.kind) : 0,
        user: Re(q.user) ? a.UserPacket.fromJSON(q.user) : void 0,
        speaker: Re(q.speaker) ? a.ActiveSpeakerUpdate.fromJSON(q.speaker) : void 0
      };
    },
    toJSON(q) {
      const ke = {};
      return q.kind !== void 0 && (ke.kind = S(q.kind)), q.user !== void 0 && (ke.user = q.user ? a.UserPacket.toJSON(q.user) : void 0), q.speaker !== void 0 && (ke.speaker = q.speaker ? a.ActiveSpeakerUpdate.toJSON(q.speaker) : void 0), ke;
    },
    fromPartial(q) {
      var ke;
      const de = he();
      return de.kind = (ke = q.kind) !== null && ke !== void 0 ? ke : 0, de.user = q.user !== void 0 && q.user !== null ? a.UserPacket.fromPartial(q.user) : void 0, de.speaker = q.speaker !== void 0 && q.speaker !== null ? a.ActiveSpeakerUpdate.fromPartial(q.speaker) : void 0, de;
    }
  };
  function ve() {
    return { speakers: [] };
  }
  a.ActiveSpeakerUpdate = {
    encode(q, ke = l.default.Writer.create()) {
      for (const de of q.speakers)
        a.SpeakerInfo.encode(de, ke.uint32(10).fork()).ldelim();
      return ke;
    },
    decode(q, ke) {
      const de = q instanceof l.default.Reader ? q : new l.default.Reader(q);
      let ue = ke === void 0 ? de.len : de.pos + ke;
      const me = ve();
      for (; de.pos < ue; ) {
        const Oe = de.uint32();
        switch (Oe >>> 3) {
          case 1:
            me.speakers.push(a.SpeakerInfo.decode(de, de.uint32()));
            break;
          default:
            de.skipType(Oe & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(q) {
      return {
        speakers: Array.isArray(q == null ? void 0 : q.speakers) ? q.speakers.map((ke) => a.SpeakerInfo.fromJSON(ke)) : []
      };
    },
    toJSON(q) {
      const ke = {};
      return q.speakers ? ke.speakers = q.speakers.map((de) => de ? a.SpeakerInfo.toJSON(de) : void 0) : ke.speakers = [], ke;
    },
    fromPartial(q) {
      var ke;
      const de = ve();
      return de.speakers = ((ke = q.speakers) === null || ke === void 0 ? void 0 : ke.map((ue) => a.SpeakerInfo.fromPartial(ue))) || [], de;
    }
  };
  function Q() {
    return { sid: "", level: 0, active: !1 };
  }
  a.SpeakerInfo = {
    encode(q, ke = l.default.Writer.create()) {
      return q.sid !== "" && ke.uint32(10).string(q.sid), q.level !== 0 && ke.uint32(21).float(q.level), q.active === !0 && ke.uint32(24).bool(q.active), ke;
    },
    decode(q, ke) {
      const de = q instanceof l.default.Reader ? q : new l.default.Reader(q);
      let ue = ke === void 0 ? de.len : de.pos + ke;
      const me = Q();
      for (; de.pos < ue; ) {
        const Oe = de.uint32();
        switch (Oe >>> 3) {
          case 1:
            me.sid = de.string();
            break;
          case 2:
            me.level = de.float();
            break;
          case 3:
            me.active = de.bool();
            break;
          default:
            de.skipType(Oe & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(q) {
      return {
        sid: Re(q.sid) ? String(q.sid) : "",
        level: Re(q.level) ? Number(q.level) : 0,
        active: Re(q.active) ? !!q.active : !1
      };
    },
    toJSON(q) {
      const ke = {};
      return q.sid !== void 0 && (ke.sid = q.sid), q.level !== void 0 && (ke.level = q.level), q.active !== void 0 && (ke.active = q.active), ke;
    },
    fromPartial(q) {
      var ke, de, ue;
      const me = Q();
      return me.sid = (ke = q.sid) !== null && ke !== void 0 ? ke : "", me.level = (de = q.level) !== null && de !== void 0 ? de : 0, me.active = (ue = q.active) !== null && ue !== void 0 ? ue : !1, me;
    }
  };
  function le() {
    return { participantSid: "", payload: new Uint8Array(), destinationSids: [] };
  }
  a.UserPacket = {
    encode(q, ke = l.default.Writer.create()) {
      q.participantSid !== "" && ke.uint32(10).string(q.participantSid), q.payload.length !== 0 && ke.uint32(18).bytes(q.payload);
      for (const de of q.destinationSids)
        ke.uint32(26).string(de);
      return ke;
    },
    decode(q, ke) {
      const de = q instanceof l.default.Reader ? q : new l.default.Reader(q);
      let ue = ke === void 0 ? de.len : de.pos + ke;
      const me = le();
      for (; de.pos < ue; ) {
        const Oe = de.uint32();
        switch (Oe >>> 3) {
          case 1:
            me.participantSid = de.string();
            break;
          case 2:
            me.payload = de.bytes();
            break;
          case 3:
            me.destinationSids.push(de.string());
            break;
          default:
            de.skipType(Oe & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(q) {
      return {
        participantSid: Re(q.participantSid) ? String(q.participantSid) : "",
        payload: Re(q.payload) ? gt(q.payload) : new Uint8Array(),
        destinationSids: Array.isArray(q == null ? void 0 : q.destinationSids) ? q.destinationSids.map((ke) => String(ke)) : []
      };
    },
    toJSON(q) {
      const ke = {};
      return q.participantSid !== void 0 && (ke.participantSid = q.participantSid), q.payload !== void 0 && (ke.payload = Xe(q.payload !== void 0 ? q.payload : new Uint8Array())), q.destinationSids ? ke.destinationSids = q.destinationSids.map((de) => de) : ke.destinationSids = [], ke;
    },
    fromPartial(q) {
      var ke, de, ue;
      const me = le();
      return me.participantSid = (ke = q.participantSid) !== null && ke !== void 0 ? ke : "", me.payload = (de = q.payload) !== null && de !== void 0 ? de : new Uint8Array(), me.destinationSids = ((ue = q.destinationSids) === null || ue === void 0 ? void 0 : ue.map((Oe) => Oe)) || [], me;
    }
  };
  function _e() {
    return { participantSid: "", trackSids: [] };
  }
  a.ParticipantTracks = {
    encode(q, ke = l.default.Writer.create()) {
      q.participantSid !== "" && ke.uint32(10).string(q.participantSid);
      for (const de of q.trackSids)
        ke.uint32(18).string(de);
      return ke;
    },
    decode(q, ke) {
      const de = q instanceof l.default.Reader ? q : new l.default.Reader(q);
      let ue = ke === void 0 ? de.len : de.pos + ke;
      const me = _e();
      for (; de.pos < ue; ) {
        const Oe = de.uint32();
        switch (Oe >>> 3) {
          case 1:
            me.participantSid = de.string();
            break;
          case 2:
            me.trackSids.push(de.string());
            break;
          default:
            de.skipType(Oe & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(q) {
      return {
        participantSid: Re(q.participantSid) ? String(q.participantSid) : "",
        trackSids: Array.isArray(q == null ? void 0 : q.trackSids) ? q.trackSids.map((ke) => String(ke)) : []
      };
    },
    toJSON(q) {
      const ke = {};
      return q.participantSid !== void 0 && (ke.participantSid = q.participantSid), q.trackSids ? ke.trackSids = q.trackSids.map((de) => de) : ke.trackSids = [], ke;
    },
    fromPartial(q) {
      var ke, de;
      const ue = _e();
      return ue.participantSid = (ke = q.participantSid) !== null && ke !== void 0 ? ke : "", ue.trackSids = ((de = q.trackSids) === null || de === void 0 ? void 0 : de.map((me) => me)) || [], ue;
    }
  };
  function re() {
    return { edition: 0, version: "", protocol: 0, region: "", nodeId: "", debugInfo: "" };
  }
  a.ServerInfo = {
    encode(q, ke = l.default.Writer.create()) {
      return q.edition !== 0 && ke.uint32(8).int32(q.edition), q.version !== "" && ke.uint32(18).string(q.version), q.protocol !== 0 && ke.uint32(24).int32(q.protocol), q.region !== "" && ke.uint32(34).string(q.region), q.nodeId !== "" && ke.uint32(42).string(q.nodeId), q.debugInfo !== "" && ke.uint32(50).string(q.debugInfo), ke;
    },
    decode(q, ke) {
      const de = q instanceof l.default.Reader ? q : new l.default.Reader(q);
      let ue = ke === void 0 ? de.len : de.pos + ke;
      const me = re();
      for (; de.pos < ue; ) {
        const Oe = de.uint32();
        switch (Oe >>> 3) {
          case 1:
            me.edition = de.int32();
            break;
          case 2:
            me.version = de.string();
            break;
          case 3:
            me.protocol = de.int32();
            break;
          case 4:
            me.region = de.string();
            break;
          case 5:
            me.nodeId = de.string();
            break;
          case 6:
            me.debugInfo = de.string();
            break;
          default:
            de.skipType(Oe & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(q) {
      return {
        edition: Re(q.edition) ? I(q.edition) : 0,
        version: Re(q.version) ? String(q.version) : "",
        protocol: Re(q.protocol) ? Number(q.protocol) : 0,
        region: Re(q.region) ? String(q.region) : "",
        nodeId: Re(q.nodeId) ? String(q.nodeId) : "",
        debugInfo: Re(q.debugInfo) ? String(q.debugInfo) : ""
      };
    },
    toJSON(q) {
      const ke = {};
      return q.edition !== void 0 && (ke.edition = N(q.edition)), q.version !== void 0 && (ke.version = q.version), q.protocol !== void 0 && (ke.protocol = Math.round(q.protocol)), q.region !== void 0 && (ke.region = q.region), q.nodeId !== void 0 && (ke.nodeId = q.nodeId), q.debugInfo !== void 0 && (ke.debugInfo = q.debugInfo), ke;
    },
    fromPartial(q) {
      var ke, de, ue, me, Oe, Ue;
      const ze = re();
      return ze.edition = (ke = q.edition) !== null && ke !== void 0 ? ke : 0, ze.version = (de = q.version) !== null && de !== void 0 ? de : "", ze.protocol = (ue = q.protocol) !== null && ue !== void 0 ? ue : 0, ze.region = (me = q.region) !== null && me !== void 0 ? me : "", ze.nodeId = (Oe = q.nodeId) !== null && Oe !== void 0 ? Oe : "", ze.debugInfo = (Ue = q.debugInfo) !== null && Ue !== void 0 ? Ue : "", ze;
    }
  };
  function O() {
    return {
      sdk: 0,
      version: "",
      protocol: 0,
      os: "",
      osVersion: "",
      deviceModel: "",
      browser: "",
      browserVersion: "",
      address: "",
      network: ""
    };
  }
  a.ClientInfo = {
    encode(q, ke = l.default.Writer.create()) {
      return q.sdk !== 0 && ke.uint32(8).int32(q.sdk), q.version !== "" && ke.uint32(18).string(q.version), q.protocol !== 0 && ke.uint32(24).int32(q.protocol), q.os !== "" && ke.uint32(34).string(q.os), q.osVersion !== "" && ke.uint32(42).string(q.osVersion), q.deviceModel !== "" && ke.uint32(50).string(q.deviceModel), q.browser !== "" && ke.uint32(58).string(q.browser), q.browserVersion !== "" && ke.uint32(66).string(q.browserVersion), q.address !== "" && ke.uint32(74).string(q.address), q.network !== "" && ke.uint32(82).string(q.network), ke;
    },
    decode(q, ke) {
      const de = q instanceof l.default.Reader ? q : new l.default.Reader(q);
      let ue = ke === void 0 ? de.len : de.pos + ke;
      const me = O();
      for (; de.pos < ue; ) {
        const Oe = de.uint32();
        switch (Oe >>> 3) {
          case 1:
            me.sdk = de.int32();
            break;
          case 2:
            me.version = de.string();
            break;
          case 3:
            me.protocol = de.int32();
            break;
          case 4:
            me.os = de.string();
            break;
          case 5:
            me.osVersion = de.string();
            break;
          case 6:
            me.deviceModel = de.string();
            break;
          case 7:
            me.browser = de.string();
            break;
          case 8:
            me.browserVersion = de.string();
            break;
          case 9:
            me.address = de.string();
            break;
          case 10:
            me.network = de.string();
            break;
          default:
            de.skipType(Oe & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(q) {
      return {
        sdk: Re(q.sdk) ? U(q.sdk) : 0,
        version: Re(q.version) ? String(q.version) : "",
        protocol: Re(q.protocol) ? Number(q.protocol) : 0,
        os: Re(q.os) ? String(q.os) : "",
        osVersion: Re(q.osVersion) ? String(q.osVersion) : "",
        deviceModel: Re(q.deviceModel) ? String(q.deviceModel) : "",
        browser: Re(q.browser) ? String(q.browser) : "",
        browserVersion: Re(q.browserVersion) ? String(q.browserVersion) : "",
        address: Re(q.address) ? String(q.address) : "",
        network: Re(q.network) ? String(q.network) : ""
      };
    },
    toJSON(q) {
      const ke = {};
      return q.sdk !== void 0 && (ke.sdk = H(q.sdk)), q.version !== void 0 && (ke.version = q.version), q.protocol !== void 0 && (ke.protocol = Math.round(q.protocol)), q.os !== void 0 && (ke.os = q.os), q.osVersion !== void 0 && (ke.osVersion = q.osVersion), q.deviceModel !== void 0 && (ke.deviceModel = q.deviceModel), q.browser !== void 0 && (ke.browser = q.browser), q.browserVersion !== void 0 && (ke.browserVersion = q.browserVersion), q.address !== void 0 && (ke.address = q.address), q.network !== void 0 && (ke.network = q.network), ke;
    },
    fromPartial(q) {
      var ke, de, ue, me, Oe, Ue, ze, Ve, Qe, Ke;
      const x = O();
      return x.sdk = (ke = q.sdk) !== null && ke !== void 0 ? ke : 0, x.version = (de = q.version) !== null && de !== void 0 ? de : "", x.protocol = (ue = q.protocol) !== null && ue !== void 0 ? ue : 0, x.os = (me = q.os) !== null && me !== void 0 ? me : "", x.osVersion = (Oe = q.osVersion) !== null && Oe !== void 0 ? Oe : "", x.deviceModel = (Ue = q.deviceModel) !== null && Ue !== void 0 ? Ue : "", x.browser = (ze = q.browser) !== null && ze !== void 0 ? ze : "", x.browserVersion = (Ve = q.browserVersion) !== null && Ve !== void 0 ? Ve : "", x.address = (Qe = q.address) !== null && Qe !== void 0 ? Qe : "", x.network = (Ke = q.network) !== null && Ke !== void 0 ? Ke : "", x;
    }
  };
  function j() {
    return { video: void 0, screen: void 0, resumeConnection: 0, disabledCodecs: void 0, forceRelay: 0 };
  }
  a.ClientConfiguration = {
    encode(q, ke = l.default.Writer.create()) {
      return q.video !== void 0 && a.VideoConfiguration.encode(q.video, ke.uint32(10).fork()).ldelim(), q.screen !== void 0 && a.VideoConfiguration.encode(q.screen, ke.uint32(18).fork()).ldelim(), q.resumeConnection !== 0 && ke.uint32(24).int32(q.resumeConnection), q.disabledCodecs !== void 0 && a.DisabledCodecs.encode(q.disabledCodecs, ke.uint32(34).fork()).ldelim(), q.forceRelay !== 0 && ke.uint32(40).int32(q.forceRelay), ke;
    },
    decode(q, ke) {
      const de = q instanceof l.default.Reader ? q : new l.default.Reader(q);
      let ue = ke === void 0 ? de.len : de.pos + ke;
      const me = j();
      for (; de.pos < ue; ) {
        const Oe = de.uint32();
        switch (Oe >>> 3) {
          case 1:
            me.video = a.VideoConfiguration.decode(de, de.uint32());
            break;
          case 2:
            me.screen = a.VideoConfiguration.decode(de, de.uint32());
            break;
          case 3:
            me.resumeConnection = de.int32();
            break;
          case 4:
            me.disabledCodecs = a.DisabledCodecs.decode(de, de.uint32());
            break;
          case 5:
            me.forceRelay = de.int32();
            break;
          default:
            de.skipType(Oe & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(q) {
      return {
        video: Re(q.video) ? a.VideoConfiguration.fromJSON(q.video) : void 0,
        screen: Re(q.screen) ? a.VideoConfiguration.fromJSON(q.screen) : void 0,
        resumeConnection: Re(q.resumeConnection) ? ie(q.resumeConnection) : 0,
        disabledCodecs: Re(q.disabledCodecs) ? a.DisabledCodecs.fromJSON(q.disabledCodecs) : void 0,
        forceRelay: Re(q.forceRelay) ? ie(q.forceRelay) : 0
      };
    },
    toJSON(q) {
      const ke = {};
      return q.video !== void 0 && (ke.video = q.video ? a.VideoConfiguration.toJSON(q.video) : void 0), q.screen !== void 0 && (ke.screen = q.screen ? a.VideoConfiguration.toJSON(q.screen) : void 0), q.resumeConnection !== void 0 && (ke.resumeConnection = ge(q.resumeConnection)), q.disabledCodecs !== void 0 && (ke.disabledCodecs = q.disabledCodecs ? a.DisabledCodecs.toJSON(q.disabledCodecs) : void 0), q.forceRelay !== void 0 && (ke.forceRelay = ge(q.forceRelay)), ke;
    },
    fromPartial(q) {
      var ke, de;
      const ue = j();
      return ue.video = q.video !== void 0 && q.video !== null ? a.VideoConfiguration.fromPartial(q.video) : void 0, ue.screen = q.screen !== void 0 && q.screen !== null ? a.VideoConfiguration.fromPartial(q.screen) : void 0, ue.resumeConnection = (ke = q.resumeConnection) !== null && ke !== void 0 ? ke : 0, ue.disabledCodecs = q.disabledCodecs !== void 0 && q.disabledCodecs !== null ? a.DisabledCodecs.fromPartial(q.disabledCodecs) : void 0, ue.forceRelay = (de = q.forceRelay) !== null && de !== void 0 ? de : 0, ue;
    }
  };
  function ce() {
    return { hardwareEncoder: 0 };
  }
  a.VideoConfiguration = {
    encode(q, ke = l.default.Writer.create()) {
      return q.hardwareEncoder !== 0 && ke.uint32(8).int32(q.hardwareEncoder), ke;
    },
    decode(q, ke) {
      const de = q instanceof l.default.Reader ? q : new l.default.Reader(q);
      let ue = ke === void 0 ? de.len : de.pos + ke;
      const me = ce();
      for (; de.pos < ue; ) {
        const Oe = de.uint32();
        switch (Oe >>> 3) {
          case 1:
            me.hardwareEncoder = de.int32();
            break;
          default:
            de.skipType(Oe & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(q) {
      return { hardwareEncoder: Re(q.hardwareEncoder) ? ie(q.hardwareEncoder) : 0 };
    },
    toJSON(q) {
      const ke = {};
      return q.hardwareEncoder !== void 0 && (ke.hardwareEncoder = ge(q.hardwareEncoder)), ke;
    },
    fromPartial(q) {
      var ke;
      const de = ce();
      return de.hardwareEncoder = (ke = q.hardwareEncoder) !== null && ke !== void 0 ? ke : 0, de;
    }
  };
  function De() {
    return { codecs: [] };
  }
  a.DisabledCodecs = {
    encode(q, ke = l.default.Writer.create()) {
      for (const de of q.codecs)
        a.Codec.encode(de, ke.uint32(10).fork()).ldelim();
      return ke;
    },
    decode(q, ke) {
      const de = q instanceof l.default.Reader ? q : new l.default.Reader(q);
      let ue = ke === void 0 ? de.len : de.pos + ke;
      const me = De();
      for (; de.pos < ue; ) {
        const Oe = de.uint32();
        switch (Oe >>> 3) {
          case 1:
            me.codecs.push(a.Codec.decode(de, de.uint32()));
            break;
          default:
            de.skipType(Oe & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(q) {
      return { codecs: Array.isArray(q == null ? void 0 : q.codecs) ? q.codecs.map((ke) => a.Codec.fromJSON(ke)) : [] };
    },
    toJSON(q) {
      const ke = {};
      return q.codecs ? ke.codecs = q.codecs.map((de) => de ? a.Codec.toJSON(de) : void 0) : ke.codecs = [], ke;
    },
    fromPartial(q) {
      var ke;
      const de = De();
      return de.codecs = ((ke = q.codecs) === null || ke === void 0 ? void 0 : ke.map((ue) => a.Codec.fromPartial(ue))) || [], de;
    }
  };
  function Ne() {
    return {
      startTime: void 0,
      endTime: void 0,
      duration: 0,
      packets: 0,
      packetRate: 0,
      bytes: 0,
      headerBytes: 0,
      bitrate: 0,
      packetsLost: 0,
      packetLossRate: 0,
      packetLossPercentage: 0,
      packetsDuplicate: 0,
      packetDuplicateRate: 0,
      bytesDuplicate: 0,
      headerBytesDuplicate: 0,
      bitrateDuplicate: 0,
      packetsPadding: 0,
      packetPaddingRate: 0,
      bytesPadding: 0,
      headerBytesPadding: 0,
      bitratePadding: 0,
      packetsOutOfOrder: 0,
      frames: 0,
      frameRate: 0,
      jitterCurrent: 0,
      jitterMax: 0,
      gapHistogram: {},
      nacks: 0,
      nackAcks: 0,
      nackMisses: 0,
      nackRepeated: 0,
      plis: 0,
      lastPli: void 0,
      firs: 0,
      lastFir: void 0,
      rttCurrent: 0,
      rttMax: 0,
      keyFrames: 0,
      lastKeyFrame: void 0,
      layerLockPlis: 0,
      lastLayerLockPli: void 0
    };
  }
  a.RTPStats = {
    encode(q, ke = l.default.Writer.create()) {
      return q.startTime !== void 0 && v.Timestamp.encode(Ge(q.startTime), ke.uint32(10).fork()).ldelim(), q.endTime !== void 0 && v.Timestamp.encode(Ge(q.endTime), ke.uint32(18).fork()).ldelim(), q.duration !== 0 && ke.uint32(25).double(q.duration), q.packets !== 0 && ke.uint32(32).uint32(q.packets), q.packetRate !== 0 && ke.uint32(41).double(q.packetRate), q.bytes !== 0 && ke.uint32(48).uint64(q.bytes), q.headerBytes !== 0 && ke.uint32(312).uint64(q.headerBytes), q.bitrate !== 0 && ke.uint32(57).double(q.bitrate), q.packetsLost !== 0 && ke.uint32(64).uint32(q.packetsLost), q.packetLossRate !== 0 && ke.uint32(73).double(q.packetLossRate), q.packetLossPercentage !== 0 && ke.uint32(85).float(q.packetLossPercentage), q.packetsDuplicate !== 0 && ke.uint32(88).uint32(q.packetsDuplicate), q.packetDuplicateRate !== 0 && ke.uint32(97).double(q.packetDuplicateRate), q.bytesDuplicate !== 0 && ke.uint32(104).uint64(q.bytesDuplicate), q.headerBytesDuplicate !== 0 && ke.uint32(320).uint64(q.headerBytesDuplicate), q.bitrateDuplicate !== 0 && ke.uint32(113).double(q.bitrateDuplicate), q.packetsPadding !== 0 && ke.uint32(120).uint32(q.packetsPadding), q.packetPaddingRate !== 0 && ke.uint32(129).double(q.packetPaddingRate), q.bytesPadding !== 0 && ke.uint32(136).uint64(q.bytesPadding), q.headerBytesPadding !== 0 && ke.uint32(328).uint64(q.headerBytesPadding), q.bitratePadding !== 0 && ke.uint32(145).double(q.bitratePadding), q.packetsOutOfOrder !== 0 && ke.uint32(152).uint32(q.packetsOutOfOrder), q.frames !== 0 && ke.uint32(160).uint32(q.frames), q.frameRate !== 0 && ke.uint32(169).double(q.frameRate), q.jitterCurrent !== 0 && ke.uint32(177).double(q.jitterCurrent), q.jitterMax !== 0 && ke.uint32(185).double(q.jitterMax), Object.entries(q.gapHistogram).forEach(([de, ue]) => {
        a.RTPStats_GapHistogramEntry.encode({ key: de, value: ue }, ke.uint32(194).fork()).ldelim();
      }), q.nacks !== 0 && ke.uint32(200).uint32(q.nacks), q.nackAcks !== 0 && ke.uint32(296).uint32(q.nackAcks), q.nackMisses !== 0 && ke.uint32(208).uint32(q.nackMisses), q.nackRepeated !== 0 && ke.uint32(304).uint32(q.nackRepeated), q.plis !== 0 && ke.uint32(216).uint32(q.plis), q.lastPli !== void 0 && v.Timestamp.encode(Ge(q.lastPli), ke.uint32(226).fork()).ldelim(), q.firs !== 0 && ke.uint32(232).uint32(q.firs), q.lastFir !== void 0 && v.Timestamp.encode(Ge(q.lastFir), ke.uint32(242).fork()).ldelim(), q.rttCurrent !== 0 && ke.uint32(248).uint32(q.rttCurrent), q.rttMax !== 0 && ke.uint32(256).uint32(q.rttMax), q.keyFrames !== 0 && ke.uint32(264).uint32(q.keyFrames), q.lastKeyFrame !== void 0 && v.Timestamp.encode(Ge(q.lastKeyFrame), ke.uint32(274).fork()).ldelim(), q.layerLockPlis !== 0 && ke.uint32(280).uint32(q.layerLockPlis), q.lastLayerLockPli !== void 0 && v.Timestamp.encode(Ge(q.lastLayerLockPli), ke.uint32(290).fork()).ldelim(), ke;
    },
    decode(q, ke) {
      const de = q instanceof l.default.Reader ? q : new l.default.Reader(q);
      let ue = ke === void 0 ? de.len : de.pos + ke;
      const me = Ne();
      for (; de.pos < ue; ) {
        const Oe = de.uint32();
        switch (Oe >>> 3) {
          case 1:
            me.startTime = J(v.Timestamp.decode(de, de.uint32()));
            break;
          case 2:
            me.endTime = J(v.Timestamp.decode(de, de.uint32()));
            break;
          case 3:
            me.duration = de.double();
            break;
          case 4:
            me.packets = de.uint32();
            break;
          case 5:
            me.packetRate = de.double();
            break;
          case 6:
            me.bytes = we(de.uint64());
            break;
          case 39:
            me.headerBytes = we(de.uint64());
            break;
          case 7:
            me.bitrate = de.double();
            break;
          case 8:
            me.packetsLost = de.uint32();
            break;
          case 9:
            me.packetLossRate = de.double();
            break;
          case 10:
            me.packetLossPercentage = de.float();
            break;
          case 11:
            me.packetsDuplicate = de.uint32();
            break;
          case 12:
            me.packetDuplicateRate = de.double();
            break;
          case 13:
            me.bytesDuplicate = we(de.uint64());
            break;
          case 40:
            me.headerBytesDuplicate = we(de.uint64());
            break;
          case 14:
            me.bitrateDuplicate = de.double();
            break;
          case 15:
            me.packetsPadding = de.uint32();
            break;
          case 16:
            me.packetPaddingRate = de.double();
            break;
          case 17:
            me.bytesPadding = we(de.uint64());
            break;
          case 41:
            me.headerBytesPadding = we(de.uint64());
            break;
          case 18:
            me.bitratePadding = de.double();
            break;
          case 19:
            me.packetsOutOfOrder = de.uint32();
            break;
          case 20:
            me.frames = de.uint32();
            break;
          case 21:
            me.frameRate = de.double();
            break;
          case 22:
            me.jitterCurrent = de.double();
            break;
          case 23:
            me.jitterMax = de.double();
            break;
          case 24:
            const Ue = a.RTPStats_GapHistogramEntry.decode(de, de.uint32());
            Ue.value !== void 0 && (me.gapHistogram[Ue.key] = Ue.value);
            break;
          case 25:
            me.nacks = de.uint32();
            break;
          case 37:
            me.nackAcks = de.uint32();
            break;
          case 26:
            me.nackMisses = de.uint32();
            break;
          case 38:
            me.nackRepeated = de.uint32();
            break;
          case 27:
            me.plis = de.uint32();
            break;
          case 28:
            me.lastPli = J(v.Timestamp.decode(de, de.uint32()));
            break;
          case 29:
            me.firs = de.uint32();
            break;
          case 30:
            me.lastFir = J(v.Timestamp.decode(de, de.uint32()));
            break;
          case 31:
            me.rttCurrent = de.uint32();
            break;
          case 32:
            me.rttMax = de.uint32();
            break;
          case 33:
            me.keyFrames = de.uint32();
            break;
          case 34:
            me.lastKeyFrame = J(v.Timestamp.decode(de, de.uint32()));
            break;
          case 35:
            me.layerLockPlis = de.uint32();
            break;
          case 36:
            me.lastLayerLockPli = J(v.Timestamp.decode(de, de.uint32()));
            break;
          default:
            de.skipType(Oe & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(q) {
      return {
        startTime: Re(q.startTime) ? ye(q.startTime) : void 0,
        endTime: Re(q.endTime) ? ye(q.endTime) : void 0,
        duration: Re(q.duration) ? Number(q.duration) : 0,
        packets: Re(q.packets) ? Number(q.packets) : 0,
        packetRate: Re(q.packetRate) ? Number(q.packetRate) : 0,
        bytes: Re(q.bytes) ? Number(q.bytes) : 0,
        headerBytes: Re(q.headerBytes) ? Number(q.headerBytes) : 0,
        bitrate: Re(q.bitrate) ? Number(q.bitrate) : 0,
        packetsLost: Re(q.packetsLost) ? Number(q.packetsLost) : 0,
        packetLossRate: Re(q.packetLossRate) ? Number(q.packetLossRate) : 0,
        packetLossPercentage: Re(q.packetLossPercentage) ? Number(q.packetLossPercentage) : 0,
        packetsDuplicate: Re(q.packetsDuplicate) ? Number(q.packetsDuplicate) : 0,
        packetDuplicateRate: Re(q.packetDuplicateRate) ? Number(q.packetDuplicateRate) : 0,
        bytesDuplicate: Re(q.bytesDuplicate) ? Number(q.bytesDuplicate) : 0,
        headerBytesDuplicate: Re(q.headerBytesDuplicate) ? Number(q.headerBytesDuplicate) : 0,
        bitrateDuplicate: Re(q.bitrateDuplicate) ? Number(q.bitrateDuplicate) : 0,
        packetsPadding: Re(q.packetsPadding) ? Number(q.packetsPadding) : 0,
        packetPaddingRate: Re(q.packetPaddingRate) ? Number(q.packetPaddingRate) : 0,
        bytesPadding: Re(q.bytesPadding) ? Number(q.bytesPadding) : 0,
        headerBytesPadding: Re(q.headerBytesPadding) ? Number(q.headerBytesPadding) : 0,
        bitratePadding: Re(q.bitratePadding) ? Number(q.bitratePadding) : 0,
        packetsOutOfOrder: Re(q.packetsOutOfOrder) ? Number(q.packetsOutOfOrder) : 0,
        frames: Re(q.frames) ? Number(q.frames) : 0,
        frameRate: Re(q.frameRate) ? Number(q.frameRate) : 0,
        jitterCurrent: Re(q.jitterCurrent) ? Number(q.jitterCurrent) : 0,
        jitterMax: Re(q.jitterMax) ? Number(q.jitterMax) : 0,
        gapHistogram: We(q.gapHistogram) ? Object.entries(q.gapHistogram).reduce((ke, [de, ue]) => (ke[Number(de)] = Number(ue), ke), {}) : {},
        nacks: Re(q.nacks) ? Number(q.nacks) : 0,
        nackAcks: Re(q.nackAcks) ? Number(q.nackAcks) : 0,
        nackMisses: Re(q.nackMisses) ? Number(q.nackMisses) : 0,
        nackRepeated: Re(q.nackRepeated) ? Number(q.nackRepeated) : 0,
        plis: Re(q.plis) ? Number(q.plis) : 0,
        lastPli: Re(q.lastPli) ? ye(q.lastPli) : void 0,
        firs: Re(q.firs) ? Number(q.firs) : 0,
        lastFir: Re(q.lastFir) ? ye(q.lastFir) : void 0,
        rttCurrent: Re(q.rttCurrent) ? Number(q.rttCurrent) : 0,
        rttMax: Re(q.rttMax) ? Number(q.rttMax) : 0,
        keyFrames: Re(q.keyFrames) ? Number(q.keyFrames) : 0,
        lastKeyFrame: Re(q.lastKeyFrame) ? ye(q.lastKeyFrame) : void 0,
        layerLockPlis: Re(q.layerLockPlis) ? Number(q.layerLockPlis) : 0,
        lastLayerLockPli: Re(q.lastLayerLockPli) ? ye(q.lastLayerLockPli) : void 0
      };
    },
    toJSON(q) {
      const ke = {};
      return q.startTime !== void 0 && (ke.startTime = q.startTime.toISOString()), q.endTime !== void 0 && (ke.endTime = q.endTime.toISOString()), q.duration !== void 0 && (ke.duration = q.duration), q.packets !== void 0 && (ke.packets = Math.round(q.packets)), q.packetRate !== void 0 && (ke.packetRate = q.packetRate), q.bytes !== void 0 && (ke.bytes = Math.round(q.bytes)), q.headerBytes !== void 0 && (ke.headerBytes = Math.round(q.headerBytes)), q.bitrate !== void 0 && (ke.bitrate = q.bitrate), q.packetsLost !== void 0 && (ke.packetsLost = Math.round(q.packetsLost)), q.packetLossRate !== void 0 && (ke.packetLossRate = q.packetLossRate), q.packetLossPercentage !== void 0 && (ke.packetLossPercentage = q.packetLossPercentage), q.packetsDuplicate !== void 0 && (ke.packetsDuplicate = Math.round(q.packetsDuplicate)), q.packetDuplicateRate !== void 0 && (ke.packetDuplicateRate = q.packetDuplicateRate), q.bytesDuplicate !== void 0 && (ke.bytesDuplicate = Math.round(q.bytesDuplicate)), q.headerBytesDuplicate !== void 0 && (ke.headerBytesDuplicate = Math.round(q.headerBytesDuplicate)), q.bitrateDuplicate !== void 0 && (ke.bitrateDuplicate = q.bitrateDuplicate), q.packetsPadding !== void 0 && (ke.packetsPadding = Math.round(q.packetsPadding)), q.packetPaddingRate !== void 0 && (ke.packetPaddingRate = q.packetPaddingRate), q.bytesPadding !== void 0 && (ke.bytesPadding = Math.round(q.bytesPadding)), q.headerBytesPadding !== void 0 && (ke.headerBytesPadding = Math.round(q.headerBytesPadding)), q.bitratePadding !== void 0 && (ke.bitratePadding = q.bitratePadding), q.packetsOutOfOrder !== void 0 && (ke.packetsOutOfOrder = Math.round(q.packetsOutOfOrder)), q.frames !== void 0 && (ke.frames = Math.round(q.frames)), q.frameRate !== void 0 && (ke.frameRate = q.frameRate), q.jitterCurrent !== void 0 && (ke.jitterCurrent = q.jitterCurrent), q.jitterMax !== void 0 && (ke.jitterMax = q.jitterMax), ke.gapHistogram = {}, q.gapHistogram && Object.entries(q.gapHistogram).forEach(([de, ue]) => {
        ke.gapHistogram[de] = Math.round(ue);
      }), q.nacks !== void 0 && (ke.nacks = Math.round(q.nacks)), q.nackAcks !== void 0 && (ke.nackAcks = Math.round(q.nackAcks)), q.nackMisses !== void 0 && (ke.nackMisses = Math.round(q.nackMisses)), q.nackRepeated !== void 0 && (ke.nackRepeated = Math.round(q.nackRepeated)), q.plis !== void 0 && (ke.plis = Math.round(q.plis)), q.lastPli !== void 0 && (ke.lastPli = q.lastPli.toISOString()), q.firs !== void 0 && (ke.firs = Math.round(q.firs)), q.lastFir !== void 0 && (ke.lastFir = q.lastFir.toISOString()), q.rttCurrent !== void 0 && (ke.rttCurrent = Math.round(q.rttCurrent)), q.rttMax !== void 0 && (ke.rttMax = Math.round(q.rttMax)), q.keyFrames !== void 0 && (ke.keyFrames = Math.round(q.keyFrames)), q.lastKeyFrame !== void 0 && (ke.lastKeyFrame = q.lastKeyFrame.toISOString()), q.layerLockPlis !== void 0 && (ke.layerLockPlis = Math.round(q.layerLockPlis)), q.lastLayerLockPli !== void 0 && (ke.lastLayerLockPli = q.lastLayerLockPli.toISOString()), ke;
    },
    fromPartial(q) {
      var ke, de, ue, me, Oe, Ue, ze, Ve, Qe, Ke, x, se, Ee, xe, $e, Ye, et, dt, St, tt, at, wt, rt, ut, kt, nt, it, bt, ot, ct, Ot, st, lt, Rt, Ct, Je, He, je, pt, mt, yt;
      const ht = Ne();
      return ht.startTime = (ke = q.startTime) !== null && ke !== void 0 ? ke : void 0, ht.endTime = (de = q.endTime) !== null && de !== void 0 ? de : void 0, ht.duration = (ue = q.duration) !== null && ue !== void 0 ? ue : 0, ht.packets = (me = q.packets) !== null && me !== void 0 ? me : 0, ht.packetRate = (Oe = q.packetRate) !== null && Oe !== void 0 ? Oe : 0, ht.bytes = (Ue = q.bytes) !== null && Ue !== void 0 ? Ue : 0, ht.headerBytes = (ze = q.headerBytes) !== null && ze !== void 0 ? ze : 0, ht.bitrate = (Ve = q.bitrate) !== null && Ve !== void 0 ? Ve : 0, ht.packetsLost = (Qe = q.packetsLost) !== null && Qe !== void 0 ? Qe : 0, ht.packetLossRate = (Ke = q.packetLossRate) !== null && Ke !== void 0 ? Ke : 0, ht.packetLossPercentage = (x = q.packetLossPercentage) !== null && x !== void 0 ? x : 0, ht.packetsDuplicate = (se = q.packetsDuplicate) !== null && se !== void 0 ? se : 0, ht.packetDuplicateRate = (Ee = q.packetDuplicateRate) !== null && Ee !== void 0 ? Ee : 0, ht.bytesDuplicate = (xe = q.bytesDuplicate) !== null && xe !== void 0 ? xe : 0, ht.headerBytesDuplicate = ($e = q.headerBytesDuplicate) !== null && $e !== void 0 ? $e : 0, ht.bitrateDuplicate = (Ye = q.bitrateDuplicate) !== null && Ye !== void 0 ? Ye : 0, ht.packetsPadding = (et = q.packetsPadding) !== null && et !== void 0 ? et : 0, ht.packetPaddingRate = (dt = q.packetPaddingRate) !== null && dt !== void 0 ? dt : 0, ht.bytesPadding = (St = q.bytesPadding) !== null && St !== void 0 ? St : 0, ht.headerBytesPadding = (tt = q.headerBytesPadding) !== null && tt !== void 0 ? tt : 0, ht.bitratePadding = (at = q.bitratePadding) !== null && at !== void 0 ? at : 0, ht.packetsOutOfOrder = (wt = q.packetsOutOfOrder) !== null && wt !== void 0 ? wt : 0, ht.frames = (rt = q.frames) !== null && rt !== void 0 ? rt : 0, ht.frameRate = (ut = q.frameRate) !== null && ut !== void 0 ? ut : 0, ht.jitterCurrent = (kt = q.jitterCurrent) !== null && kt !== void 0 ? kt : 0, ht.jitterMax = (nt = q.jitterMax) !== null && nt !== void 0 ? nt : 0, ht.gapHistogram = Object.entries((it = q.gapHistogram) !== null && it !== void 0 ? it : {}).reduce((_t, [Et, Nt]) => (Nt !== void 0 && (_t[Number(Et)] = Number(Nt)), _t), {}), ht.nacks = (bt = q.nacks) !== null && bt !== void 0 ? bt : 0, ht.nackAcks = (ot = q.nackAcks) !== null && ot !== void 0 ? ot : 0, ht.nackMisses = (ct = q.nackMisses) !== null && ct !== void 0 ? ct : 0, ht.nackRepeated = (Ot = q.nackRepeated) !== null && Ot !== void 0 ? Ot : 0, ht.plis = (st = q.plis) !== null && st !== void 0 ? st : 0, ht.lastPli = (lt = q.lastPli) !== null && lt !== void 0 ? lt : void 0, ht.firs = (Rt = q.firs) !== null && Rt !== void 0 ? Rt : 0, ht.lastFir = (Ct = q.lastFir) !== null && Ct !== void 0 ? Ct : void 0, ht.rttCurrent = (Je = q.rttCurrent) !== null && Je !== void 0 ? Je : 0, ht.rttMax = (He = q.rttMax) !== null && He !== void 0 ? He : 0, ht.keyFrames = (je = q.keyFrames) !== null && je !== void 0 ? je : 0, ht.lastKeyFrame = (pt = q.lastKeyFrame) !== null && pt !== void 0 ? pt : void 0, ht.layerLockPlis = (mt = q.layerLockPlis) !== null && mt !== void 0 ? mt : 0, ht.lastLayerLockPli = (yt = q.lastLayerLockPli) !== null && yt !== void 0 ? yt : void 0, ht;
    }
  };
  function Fe() {
    return { key: 0, value: 0 };
  }
  a.RTPStats_GapHistogramEntry = {
    encode(q, ke = l.default.Writer.create()) {
      return q.key !== 0 && ke.uint32(8).int32(q.key), q.value !== 0 && ke.uint32(16).uint32(q.value), ke;
    },
    decode(q, ke) {
      const de = q instanceof l.default.Reader ? q : new l.default.Reader(q);
      let ue = ke === void 0 ? de.len : de.pos + ke;
      const me = Fe();
      for (; de.pos < ue; ) {
        const Oe = de.uint32();
        switch (Oe >>> 3) {
          case 1:
            me.key = de.int32();
            break;
          case 2:
            me.value = de.uint32();
            break;
          default:
            de.skipType(Oe & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(q) {
      return { key: Re(q.key) ? Number(q.key) : 0, value: Re(q.value) ? Number(q.value) : 0 };
    },
    toJSON(q) {
      const ke = {};
      return q.key !== void 0 && (ke.key = Math.round(q.key)), q.value !== void 0 && (ke.value = Math.round(q.value)), ke;
    },
    fromPartial(q) {
      var ke, de;
      const ue = Fe();
      return ue.key = (ke = q.key) !== null && ke !== void 0 ? ke : 0, ue.value = (de = q.value) !== null && de !== void 0 ? de : 0, ue;
    }
  };
  function Ze() {
    return { unixMicro: 0, ticks: 0 };
  }
  a.TimedVersion = {
    encode(q, ke = l.default.Writer.create()) {
      return q.unixMicro !== 0 && ke.uint32(8).int64(q.unixMicro), q.ticks !== 0 && ke.uint32(16).int32(q.ticks), ke;
    },
    decode(q, ke) {
      const de = q instanceof l.default.Reader ? q : new l.default.Reader(q);
      let ue = ke === void 0 ? de.len : de.pos + ke;
      const me = Ze();
      for (; de.pos < ue; ) {
        const Oe = de.uint32();
        switch (Oe >>> 3) {
          case 1:
            me.unixMicro = we(de.int64());
            break;
          case 2:
            me.ticks = de.int32();
            break;
          default:
            de.skipType(Oe & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(q) {
      return {
        unixMicro: Re(q.unixMicro) ? Number(q.unixMicro) : 0,
        ticks: Re(q.ticks) ? Number(q.ticks) : 0
      };
    },
    toJSON(q) {
      const ke = {};
      return q.unixMicro !== void 0 && (ke.unixMicro = Math.round(q.unixMicro)), q.ticks !== void 0 && (ke.ticks = Math.round(q.ticks)), ke;
    },
    fromPartial(q) {
      var ke, de;
      const ue = Ze();
      return ue.unixMicro = (ke = q.unixMicro) !== null && ke !== void 0 ? ke : 0, ue.ticks = (de = q.ticks) !== null && de !== void 0 ? de : 0, ue;
    }
  };
  var qe = (() => {
    if (typeof qe < "u")
      return qe;
    if (typeof self < "u")
      return self;
    if (typeof window < "u")
      return window;
    if (typeof commonjsGlobal$1 < "u")
      return commonjsGlobal$1;
    throw "Unable to locate global object";
  })();
  function gt(q) {
    if (qe.Buffer)
      return Uint8Array.from(qe.Buffer.from(q, "base64"));
    {
      const ke = qe.atob(q), de = new Uint8Array(ke.length);
      for (let ue = 0; ue < ke.length; ++ue)
        de[ue] = ke.charCodeAt(ue);
      return de;
    }
  }
  function Xe(q) {
    if (qe.Buffer)
      return qe.Buffer.from(q).toString("base64");
    {
      const ke = [];
      return q.forEach((de) => {
        ke.push(String.fromCharCode(de));
      }), qe.btoa(ke.join(""));
    }
  }
  function Ge(q) {
    const ke = q.getTime() / 1e3, de = q.getTime() % 1e3 * 1e6;
    return { seconds: ke, nanos: de };
  }
  function J(q) {
    let ke = q.seconds * 1e3;
    return ke += q.nanos / 1e6, new Date(ke);
  }
  function ye(q) {
    return q instanceof Date ? q : typeof q == "string" ? new Date(q) : J(v.Timestamp.fromJSON(q));
  }
  function we(q) {
    if (q.gt(Number.MAX_SAFE_INTEGER))
      throw new qe.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    return q.toNumber();
  }
  l.default.util.Long !== c.default && (l.default.util.Long = c.default, l.default.configure());
  function We(q) {
    return typeof q == "object" && q !== null;
  }
  function Re(q) {
    return q != null;
  }
})(livekit_models);
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(Z) {
    return Z && Z.__esModule ? Z : { default: Z };
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.DeleteIngressRequest = a.ListIngressResponse = a.ListIngressRequest = a.UpdateIngressRequest = a.InputAudioState = a.InputVideoState = a.IngressState = a.IngressInfo = a.IngressVideoOptions = a.IngressAudioOptions = a.CreateIngressRequest = a.ingressState_StatusToJSON = a.ingressState_StatusFromJSON = a.IngressState_Status = a.ingressInputToJSON = a.ingressInputFromJSON = a.IngressInput = a.protobufPackage = void 0;
  const c = u(umdExports), l = u(minimal), v = livekit_models;
  a.protobufPackage = "livekit";
  var p;
  (function(Z) {
    Z[Z.RTMP_INPUT = 0] = "RTMP_INPUT", Z[Z.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(p = a.IngressInput || (a.IngressInput = {}));
  function _(Z) {
    switch (Z) {
      case 0:
      case "RTMP_INPUT":
        return p.RTMP_INPUT;
      case -1:
      case "UNRECOGNIZED":
      default:
        return p.UNRECOGNIZED;
    }
  }
  a.ingressInputFromJSON = _;
  function k(Z) {
    switch (Z) {
      case p.RTMP_INPUT:
        return "RTMP_INPUT";
      case p.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.ingressInputToJSON = k;
  var M;
  (function(Z) {
    Z[Z.ENDPOINT_INACTIVE = 0] = "ENDPOINT_INACTIVE", Z[Z.ENDPOINT_BUFFERING = 1] = "ENDPOINT_BUFFERING", Z[Z.ENDPOINT_PUBLISHING = 2] = "ENDPOINT_PUBLISHING", Z[Z.ENDPOINT_ERROR = 3] = "ENDPOINT_ERROR", Z[Z.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(M = a.IngressState_Status || (a.IngressState_Status = {}));
  function L(Z) {
    switch (Z) {
      case 0:
      case "ENDPOINT_INACTIVE":
        return M.ENDPOINT_INACTIVE;
      case 1:
      case "ENDPOINT_BUFFERING":
        return M.ENDPOINT_BUFFERING;
      case 2:
      case "ENDPOINT_PUBLISHING":
        return M.ENDPOINT_PUBLISHING;
      case 3:
      case "ENDPOINT_ERROR":
        return M.ENDPOINT_ERROR;
      case -1:
      case "UNRECOGNIZED":
      default:
        return M.UNRECOGNIZED;
    }
  }
  a.ingressState_StatusFromJSON = L;
  function F(Z) {
    switch (Z) {
      case M.ENDPOINT_INACTIVE:
        return "ENDPOINT_INACTIVE";
      case M.ENDPOINT_BUFFERING:
        return "ENDPOINT_BUFFERING";
      case M.ENDPOINT_PUBLISHING:
        return "ENDPOINT_PUBLISHING";
      case M.ENDPOINT_ERROR:
        return "ENDPOINT_ERROR";
      case M.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.ingressState_StatusToJSON = F;
  function V() {
    return {
      inputType: 0,
      name: "",
      roomName: "",
      participantIdentity: "",
      participantName: "",
      audio: void 0,
      video: void 0
    };
  }
  a.CreateIngressRequest = {
    encode(Z, z = l.default.Writer.create()) {
      return Z.inputType !== void 0 && Z.inputType !== 0 && z.uint32(8).int32(Z.inputType), Z.name !== void 0 && Z.name !== "" && z.uint32(18).string(Z.name), Z.roomName !== void 0 && Z.roomName !== "" && z.uint32(26).string(Z.roomName), Z.participantIdentity !== void 0 && Z.participantIdentity !== "" && z.uint32(34).string(Z.participantIdentity), Z.participantName !== void 0 && Z.participantName !== "" && z.uint32(42).string(Z.participantName), Z.audio !== void 0 && a.IngressAudioOptions.encode(Z.audio, z.uint32(50).fork()).ldelim(), Z.video !== void 0 && a.IngressVideoOptions.encode(Z.video, z.uint32(58).fork()).ldelim(), z;
    },
    decode(Z, z) {
      const P = Z instanceof l.default.Reader ? Z : new l.default.Reader(Z);
      let S = z === void 0 ? P.len : P.pos + z;
      const E = V();
      for (; P.pos < S; ) {
        const I = P.uint32();
        switch (I >>> 3) {
          case 1:
            E.inputType = P.int32();
            break;
          case 2:
            E.name = P.string();
            break;
          case 3:
            E.roomName = P.string();
            break;
          case 4:
            E.participantIdentity = P.string();
            break;
          case 5:
            E.participantName = P.string();
            break;
          case 6:
            E.audio = a.IngressAudioOptions.decode(P, P.uint32());
            break;
          case 7:
            E.video = a.IngressVideoOptions.decode(P, P.uint32());
            break;
          default:
            P.skipType(I & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(Z) {
      return {
        inputType: Ae(Z.inputType) ? _(Z.inputType) : 0,
        name: Ae(Z.name) ? String(Z.name) : "",
        roomName: Ae(Z.roomName) ? String(Z.roomName) : "",
        participantIdentity: Ae(Z.participantIdentity) ? String(Z.participantIdentity) : "",
        participantName: Ae(Z.participantName) ? String(Z.participantName) : "",
        audio: Ae(Z.audio) ? a.IngressAudioOptions.fromJSON(Z.audio) : void 0,
        video: Ae(Z.video) ? a.IngressVideoOptions.fromJSON(Z.video) : void 0
      };
    },
    toJSON(Z) {
      const z = {};
      return Z.inputType !== void 0 && (z.inputType = k(Z.inputType)), Z.name !== void 0 && (z.name = Z.name), Z.roomName !== void 0 && (z.roomName = Z.roomName), Z.participantIdentity !== void 0 && (z.participantIdentity = Z.participantIdentity), Z.participantName !== void 0 && (z.participantName = Z.participantName), Z.audio !== void 0 && (z.audio = Z.audio ? a.IngressAudioOptions.toJSON(Z.audio) : void 0), Z.video !== void 0 && (z.video = Z.video ? a.IngressVideoOptions.toJSON(Z.video) : void 0), z;
    },
    fromPartial(Z) {
      var z, P, S, E, I;
      const N = V();
      return N.inputType = (z = Z.inputType) !== null && z !== void 0 ? z : 0, N.name = (P = Z.name) !== null && P !== void 0 ? P : "", N.roomName = (S = Z.roomName) !== null && S !== void 0 ? S : "", N.participantIdentity = (E = Z.participantIdentity) !== null && E !== void 0 ? E : "", N.participantName = (I = Z.participantName) !== null && I !== void 0 ? I : "", N.audio = Z.audio !== void 0 && Z.audio !== null ? a.IngressAudioOptions.fromPartial(Z.audio) : void 0, N.video = Z.video !== void 0 && Z.video !== null ? a.IngressVideoOptions.fromPartial(Z.video) : void 0, N;
    }
  };
  function X() {
    return { name: "", source: 0, mimeType: "", bitrate: 0, disableDtx: !1, channels: 0 };
  }
  a.IngressAudioOptions = {
    encode(Z, z = l.default.Writer.create()) {
      return Z.name !== void 0 && Z.name !== "" && z.uint32(10).string(Z.name), Z.source !== void 0 && Z.source !== 0 && z.uint32(16).int32(Z.source), Z.mimeType !== void 0 && Z.mimeType !== "" && z.uint32(26).string(Z.mimeType), Z.bitrate !== void 0 && Z.bitrate !== 0 && z.uint32(32).uint32(Z.bitrate), Z.disableDtx === !0 && z.uint32(40).bool(Z.disableDtx), Z.channels !== void 0 && Z.channels !== 0 && z.uint32(48).uint32(Z.channels), z;
    },
    decode(Z, z) {
      const P = Z instanceof l.default.Reader ? Z : new l.default.Reader(Z);
      let S = z === void 0 ? P.len : P.pos + z;
      const E = X();
      for (; P.pos < S; ) {
        const I = P.uint32();
        switch (I >>> 3) {
          case 1:
            E.name = P.string();
            break;
          case 2:
            E.source = P.int32();
            break;
          case 3:
            E.mimeType = P.string();
            break;
          case 4:
            E.bitrate = P.uint32();
            break;
          case 5:
            E.disableDtx = P.bool();
            break;
          case 6:
            E.channels = P.uint32();
            break;
          default:
            P.skipType(I & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(Z) {
      return {
        name: Ae(Z.name) ? String(Z.name) : "",
        source: Ae(Z.source) ? v.trackSourceFromJSON(Z.source) : 0,
        mimeType: Ae(Z.mimeType) ? String(Z.mimeType) : "",
        bitrate: Ae(Z.bitrate) ? Number(Z.bitrate) : 0,
        disableDtx: Ae(Z.disableDtx) ? !!Z.disableDtx : !1,
        channels: Ae(Z.channels) ? Number(Z.channels) : 0
      };
    },
    toJSON(Z) {
      const z = {};
      return Z.name !== void 0 && (z.name = Z.name), Z.source !== void 0 && (z.source = v.trackSourceToJSON(Z.source)), Z.mimeType !== void 0 && (z.mimeType = Z.mimeType), Z.bitrate !== void 0 && (z.bitrate = Math.round(Z.bitrate)), Z.disableDtx !== void 0 && (z.disableDtx = Z.disableDtx), Z.channels !== void 0 && (z.channels = Math.round(Z.channels)), z;
    },
    fromPartial(Z) {
      var z, P, S, E, I, N;
      const $ = X();
      return $.name = (z = Z.name) !== null && z !== void 0 ? z : "", $.source = (P = Z.source) !== null && P !== void 0 ? P : 0, $.mimeType = (S = Z.mimeType) !== null && S !== void 0 ? S : "", $.bitrate = (E = Z.bitrate) !== null && E !== void 0 ? E : 0, $.disableDtx = (I = Z.disableDtx) !== null && I !== void 0 ? I : !1, $.channels = (N = Z.channels) !== null && N !== void 0 ? N : 0, $;
    }
  };
  function oe() {
    return { name: "", source: 0, mimeType: "", layers: [] };
  }
  a.IngressVideoOptions = {
    encode(Z, z = l.default.Writer.create()) {
      if (Z.name !== void 0 && Z.name !== "" && z.uint32(10).string(Z.name), Z.source !== void 0 && Z.source !== 0 && z.uint32(16).int32(Z.source), Z.mimeType !== void 0 && Z.mimeType !== "" && z.uint32(26).string(Z.mimeType), Z.layers !== void 0 && Z.layers.length !== 0)
        for (const P of Z.layers)
          v.VideoLayer.encode(P, z.uint32(34).fork()).ldelim();
      return z;
    },
    decode(Z, z) {
      const P = Z instanceof l.default.Reader ? Z : new l.default.Reader(Z);
      let S = z === void 0 ? P.len : P.pos + z;
      const E = oe();
      for (; P.pos < S; ) {
        const I = P.uint32();
        switch (I >>> 3) {
          case 1:
            E.name = P.string();
            break;
          case 2:
            E.source = P.int32();
            break;
          case 3:
            E.mimeType = P.string();
            break;
          case 4:
            E.layers.push(v.VideoLayer.decode(P, P.uint32()));
            break;
          default:
            P.skipType(I & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(Z) {
      return {
        name: Ae(Z.name) ? String(Z.name) : "",
        source: Ae(Z.source) ? v.trackSourceFromJSON(Z.source) : 0,
        mimeType: Ae(Z.mimeType) ? String(Z.mimeType) : "",
        layers: Array.isArray(Z == null ? void 0 : Z.layers) ? Z.layers.map((z) => v.VideoLayer.fromJSON(z)) : []
      };
    },
    toJSON(Z) {
      const z = {};
      return Z.name !== void 0 && (z.name = Z.name), Z.source !== void 0 && (z.source = v.trackSourceToJSON(Z.source)), Z.mimeType !== void 0 && (z.mimeType = Z.mimeType), Z.layers ? z.layers = Z.layers.map((P) => P ? v.VideoLayer.toJSON(P) : void 0) : z.layers = [], z;
    },
    fromPartial(Z) {
      var z, P, S, E;
      const I = oe();
      return I.name = (z = Z.name) !== null && z !== void 0 ? z : "", I.source = (P = Z.source) !== null && P !== void 0 ? P : 0, I.mimeType = (S = Z.mimeType) !== null && S !== void 0 ? S : "", I.layers = ((E = Z.layers) === null || E === void 0 ? void 0 : E.map((N) => v.VideoLayer.fromPartial(N))) || [], I;
    }
  };
  function Y() {
    return {
      ingressId: "",
      name: "",
      streamKey: "",
      url: "",
      inputType: 0,
      audio: void 0,
      video: void 0,
      roomName: "",
      participantIdentity: "",
      participantName: "",
      reusable: !1,
      state: void 0
    };
  }
  a.IngressInfo = {
    encode(Z, z = l.default.Writer.create()) {
      return Z.ingressId !== void 0 && Z.ingressId !== "" && z.uint32(10).string(Z.ingressId), Z.name !== void 0 && Z.name !== "" && z.uint32(18).string(Z.name), Z.streamKey !== void 0 && Z.streamKey !== "" && z.uint32(26).string(Z.streamKey), Z.url !== void 0 && Z.url !== "" && z.uint32(34).string(Z.url), Z.inputType !== void 0 && Z.inputType !== 0 && z.uint32(40).int32(Z.inputType), Z.audio !== void 0 && a.IngressAudioOptions.encode(Z.audio, z.uint32(50).fork()).ldelim(), Z.video !== void 0 && a.IngressVideoOptions.encode(Z.video, z.uint32(58).fork()).ldelim(), Z.roomName !== void 0 && Z.roomName !== "" && z.uint32(66).string(Z.roomName), Z.participantIdentity !== void 0 && Z.participantIdentity !== "" && z.uint32(74).string(Z.participantIdentity), Z.participantName !== void 0 && Z.participantName !== "" && z.uint32(82).string(Z.participantName), Z.reusable === !0 && z.uint32(88).bool(Z.reusable), Z.state !== void 0 && a.IngressState.encode(Z.state, z.uint32(98).fork()).ldelim(), z;
    },
    decode(Z, z) {
      const P = Z instanceof l.default.Reader ? Z : new l.default.Reader(Z);
      let S = z === void 0 ? P.len : P.pos + z;
      const E = Y();
      for (; P.pos < S; ) {
        const I = P.uint32();
        switch (I >>> 3) {
          case 1:
            E.ingressId = P.string();
            break;
          case 2:
            E.name = P.string();
            break;
          case 3:
            E.streamKey = P.string();
            break;
          case 4:
            E.url = P.string();
            break;
          case 5:
            E.inputType = P.int32();
            break;
          case 6:
            E.audio = a.IngressAudioOptions.decode(P, P.uint32());
            break;
          case 7:
            E.video = a.IngressVideoOptions.decode(P, P.uint32());
            break;
          case 8:
            E.roomName = P.string();
            break;
          case 9:
            E.participantIdentity = P.string();
            break;
          case 10:
            E.participantName = P.string();
            break;
          case 11:
            E.reusable = P.bool();
            break;
          case 12:
            E.state = a.IngressState.decode(P, P.uint32());
            break;
          default:
            P.skipType(I & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(Z) {
      return {
        ingressId: Ae(Z.ingressId) ? String(Z.ingressId) : "",
        name: Ae(Z.name) ? String(Z.name) : "",
        streamKey: Ae(Z.streamKey) ? String(Z.streamKey) : "",
        url: Ae(Z.url) ? String(Z.url) : "",
        inputType: Ae(Z.inputType) ? _(Z.inputType) : 0,
        audio: Ae(Z.audio) ? a.IngressAudioOptions.fromJSON(Z.audio) : void 0,
        video: Ae(Z.video) ? a.IngressVideoOptions.fromJSON(Z.video) : void 0,
        roomName: Ae(Z.roomName) ? String(Z.roomName) : "",
        participantIdentity: Ae(Z.participantIdentity) ? String(Z.participantIdentity) : "",
        participantName: Ae(Z.participantName) ? String(Z.participantName) : "",
        reusable: Ae(Z.reusable) ? !!Z.reusable : !1,
        state: Ae(Z.state) ? a.IngressState.fromJSON(Z.state) : void 0
      };
    },
    toJSON(Z) {
      const z = {};
      return Z.ingressId !== void 0 && (z.ingressId = Z.ingressId), Z.name !== void 0 && (z.name = Z.name), Z.streamKey !== void 0 && (z.streamKey = Z.streamKey), Z.url !== void 0 && (z.url = Z.url), Z.inputType !== void 0 && (z.inputType = k(Z.inputType)), Z.audio !== void 0 && (z.audio = Z.audio ? a.IngressAudioOptions.toJSON(Z.audio) : void 0), Z.video !== void 0 && (z.video = Z.video ? a.IngressVideoOptions.toJSON(Z.video) : void 0), Z.roomName !== void 0 && (z.roomName = Z.roomName), Z.participantIdentity !== void 0 && (z.participantIdentity = Z.participantIdentity), Z.participantName !== void 0 && (z.participantName = Z.participantName), Z.reusable !== void 0 && (z.reusable = Z.reusable), Z.state !== void 0 && (z.state = Z.state ? a.IngressState.toJSON(Z.state) : void 0), z;
    },
    fromPartial(Z) {
      var z, P, S, E, I, N, $, U, H;
      const B = Y();
      return B.ingressId = (z = Z.ingressId) !== null && z !== void 0 ? z : "", B.name = (P = Z.name) !== null && P !== void 0 ? P : "", B.streamKey = (S = Z.streamKey) !== null && S !== void 0 ? S : "", B.url = (E = Z.url) !== null && E !== void 0 ? E : "", B.inputType = (I = Z.inputType) !== null && I !== void 0 ? I : 0, B.audio = Z.audio !== void 0 && Z.audio !== null ? a.IngressAudioOptions.fromPartial(Z.audio) : void 0, B.video = Z.video !== void 0 && Z.video !== null ? a.IngressVideoOptions.fromPartial(Z.video) : void 0, B.roomName = (N = Z.roomName) !== null && N !== void 0 ? N : "", B.participantIdentity = ($ = Z.participantIdentity) !== null && $ !== void 0 ? $ : "", B.participantName = (U = Z.participantName) !== null && U !== void 0 ? U : "", B.reusable = (H = Z.reusable) !== null && H !== void 0 ? H : !1, B.state = Z.state !== void 0 && Z.state !== null ? a.IngressState.fromPartial(Z.state) : void 0, B;
    }
  };
  function ae() {
    return { status: 0, error: "", video: void 0, audio: void 0, roomId: "", startedAt: 0, tracks: [] };
  }
  a.IngressState = {
    encode(Z, z = l.default.Writer.create()) {
      if (Z.status !== void 0 && Z.status !== 0 && z.uint32(8).int32(Z.status), Z.error !== void 0 && Z.error !== "" && z.uint32(18).string(Z.error), Z.video !== void 0 && a.InputVideoState.encode(Z.video, z.uint32(26).fork()).ldelim(), Z.audio !== void 0 && a.InputAudioState.encode(Z.audio, z.uint32(34).fork()).ldelim(), Z.roomId !== void 0 && Z.roomId !== "" && z.uint32(42).string(Z.roomId), Z.startedAt !== void 0 && Z.startedAt !== 0 && z.uint32(56).int64(Z.startedAt), Z.tracks !== void 0 && Z.tracks.length !== 0)
        for (const P of Z.tracks)
          v.TrackInfo.encode(P, z.uint32(50).fork()).ldelim();
      return z;
    },
    decode(Z, z) {
      const P = Z instanceof l.default.Reader ? Z : new l.default.Reader(Z);
      let S = z === void 0 ? P.len : P.pos + z;
      const E = ae();
      for (; P.pos < S; ) {
        const I = P.uint32();
        switch (I >>> 3) {
          case 1:
            E.status = P.int32();
            break;
          case 2:
            E.error = P.string();
            break;
          case 3:
            E.video = a.InputVideoState.decode(P, P.uint32());
            break;
          case 4:
            E.audio = a.InputAudioState.decode(P, P.uint32());
            break;
          case 5:
            E.roomId = P.string();
            break;
          case 7:
            E.startedAt = Be(P.int64());
            break;
          case 6:
            E.tracks.push(v.TrackInfo.decode(P, P.uint32()));
            break;
          default:
            P.skipType(I & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(Z) {
      return {
        status: Ae(Z.status) ? L(Z.status) : 0,
        error: Ae(Z.error) ? String(Z.error) : "",
        video: Ae(Z.video) ? a.InputVideoState.fromJSON(Z.video) : void 0,
        audio: Ae(Z.audio) ? a.InputAudioState.fromJSON(Z.audio) : void 0,
        roomId: Ae(Z.roomId) ? String(Z.roomId) : "",
        startedAt: Ae(Z.startedAt) ? Number(Z.startedAt) : 0,
        tracks: Array.isArray(Z == null ? void 0 : Z.tracks) ? Z.tracks.map((z) => v.TrackInfo.fromJSON(z)) : []
      };
    },
    toJSON(Z) {
      const z = {};
      return Z.status !== void 0 && (z.status = F(Z.status)), Z.error !== void 0 && (z.error = Z.error), Z.video !== void 0 && (z.video = Z.video ? a.InputVideoState.toJSON(Z.video) : void 0), Z.audio !== void 0 && (z.audio = Z.audio ? a.InputAudioState.toJSON(Z.audio) : void 0), Z.roomId !== void 0 && (z.roomId = Z.roomId), Z.startedAt !== void 0 && (z.startedAt = Math.round(Z.startedAt)), Z.tracks ? z.tracks = Z.tracks.map((P) => P ? v.TrackInfo.toJSON(P) : void 0) : z.tracks = [], z;
    },
    fromPartial(Z) {
      var z, P, S, E, I;
      const N = ae();
      return N.status = (z = Z.status) !== null && z !== void 0 ? z : 0, N.error = (P = Z.error) !== null && P !== void 0 ? P : "", N.video = Z.video !== void 0 && Z.video !== null ? a.InputVideoState.fromPartial(Z.video) : void 0, N.audio = Z.audio !== void 0 && Z.audio !== null ? a.InputAudioState.fromPartial(Z.audio) : void 0, N.roomId = (S = Z.roomId) !== null && S !== void 0 ? S : "", N.startedAt = (E = Z.startedAt) !== null && E !== void 0 ? E : 0, N.tracks = ((I = Z.tracks) === null || I === void 0 ? void 0 : I.map(($) => v.TrackInfo.fromPartial($))) || [], N;
    }
  };
  function ne() {
    return { mimeType: 0, width: 0, height: 0, framerate: 0 };
  }
  a.InputVideoState = {
    encode(Z, z = l.default.Writer.create()) {
      return Z.mimeType !== void 0 && Z.mimeType !== 0 && z.uint32(8).uint32(Z.mimeType), Z.width !== void 0 && Z.width !== 0 && z.uint32(24).uint32(Z.width), Z.height !== void 0 && Z.height !== 0 && z.uint32(32).uint32(Z.height), Z.framerate !== void 0 && Z.framerate !== 0 && z.uint32(40).uint32(Z.framerate), z;
    },
    decode(Z, z) {
      const P = Z instanceof l.default.Reader ? Z : new l.default.Reader(Z);
      let S = z === void 0 ? P.len : P.pos + z;
      const E = ne();
      for (; P.pos < S; ) {
        const I = P.uint32();
        switch (I >>> 3) {
          case 1:
            E.mimeType = P.uint32();
            break;
          case 3:
            E.width = P.uint32();
            break;
          case 4:
            E.height = P.uint32();
            break;
          case 5:
            E.framerate = P.uint32();
            break;
          default:
            P.skipType(I & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(Z) {
      return {
        mimeType: Ae(Z.mimeType) ? Number(Z.mimeType) : 0,
        width: Ae(Z.width) ? Number(Z.width) : 0,
        height: Ae(Z.height) ? Number(Z.height) : 0,
        framerate: Ae(Z.framerate) ? Number(Z.framerate) : 0
      };
    },
    toJSON(Z) {
      const z = {};
      return Z.mimeType !== void 0 && (z.mimeType = Math.round(Z.mimeType)), Z.width !== void 0 && (z.width = Math.round(Z.width)), Z.height !== void 0 && (z.height = Math.round(Z.height)), Z.framerate !== void 0 && (z.framerate = Math.round(Z.framerate)), z;
    },
    fromPartial(Z) {
      var z, P, S, E;
      const I = ne();
      return I.mimeType = (z = Z.mimeType) !== null && z !== void 0 ? z : 0, I.width = (P = Z.width) !== null && P !== void 0 ? P : 0, I.height = (S = Z.height) !== null && S !== void 0 ? S : 0, I.framerate = (E = Z.framerate) !== null && E !== void 0 ? E : 0, I;
    }
  };
  function fe() {
    return { mimeType: 0, channels: 0, sampleRate: 0 };
  }
  a.InputAudioState = {
    encode(Z, z = l.default.Writer.create()) {
      return Z.mimeType !== void 0 && Z.mimeType !== 0 && z.uint32(8).uint32(Z.mimeType), Z.channels !== void 0 && Z.channels !== 0 && z.uint32(24).uint32(Z.channels), Z.sampleRate !== void 0 && Z.sampleRate !== 0 && z.uint32(32).uint32(Z.sampleRate), z;
    },
    decode(Z, z) {
      const P = Z instanceof l.default.Reader ? Z : new l.default.Reader(Z);
      let S = z === void 0 ? P.len : P.pos + z;
      const E = fe();
      for (; P.pos < S; ) {
        const I = P.uint32();
        switch (I >>> 3) {
          case 1:
            E.mimeType = P.uint32();
            break;
          case 3:
            E.channels = P.uint32();
            break;
          case 4:
            E.sampleRate = P.uint32();
            break;
          default:
            P.skipType(I & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(Z) {
      return {
        mimeType: Ae(Z.mimeType) ? Number(Z.mimeType) : 0,
        channels: Ae(Z.channels) ? Number(Z.channels) : 0,
        sampleRate: Ae(Z.sampleRate) ? Number(Z.sampleRate) : 0
      };
    },
    toJSON(Z) {
      const z = {};
      return Z.mimeType !== void 0 && (z.mimeType = Math.round(Z.mimeType)), Z.channels !== void 0 && (z.channels = Math.round(Z.channels)), Z.sampleRate !== void 0 && (z.sampleRate = Math.round(Z.sampleRate)), z;
    },
    fromPartial(Z) {
      var z, P, S;
      const E = fe();
      return E.mimeType = (z = Z.mimeType) !== null && z !== void 0 ? z : 0, E.channels = (P = Z.channels) !== null && P !== void 0 ? P : 0, E.sampleRate = (S = Z.sampleRate) !== null && S !== void 0 ? S : 0, E;
    }
  };
  function ie() {
    return {
      ingressId: "",
      name: "",
      roomName: "",
      participantIdentity: "",
      participantName: "",
      audio: void 0,
      video: void 0
    };
  }
  a.UpdateIngressRequest = {
    encode(Z, z = l.default.Writer.create()) {
      return Z.ingressId !== void 0 && Z.ingressId !== "" && z.uint32(10).string(Z.ingressId), Z.name !== void 0 && Z.name !== "" && z.uint32(18).string(Z.name), Z.roomName !== void 0 && Z.roomName !== "" && z.uint32(26).string(Z.roomName), Z.participantIdentity !== void 0 && Z.participantIdentity !== "" && z.uint32(34).string(Z.participantIdentity), Z.participantName !== void 0 && Z.participantName !== "" && z.uint32(42).string(Z.participantName), Z.audio !== void 0 && a.IngressAudioOptions.encode(Z.audio, z.uint32(50).fork()).ldelim(), Z.video !== void 0 && a.IngressVideoOptions.encode(Z.video, z.uint32(58).fork()).ldelim(), z;
    },
    decode(Z, z) {
      const P = Z instanceof l.default.Reader ? Z : new l.default.Reader(Z);
      let S = z === void 0 ? P.len : P.pos + z;
      const E = ie();
      for (; P.pos < S; ) {
        const I = P.uint32();
        switch (I >>> 3) {
          case 1:
            E.ingressId = P.string();
            break;
          case 2:
            E.name = P.string();
            break;
          case 3:
            E.roomName = P.string();
            break;
          case 4:
            E.participantIdentity = P.string();
            break;
          case 5:
            E.participantName = P.string();
            break;
          case 6:
            E.audio = a.IngressAudioOptions.decode(P, P.uint32());
            break;
          case 7:
            E.video = a.IngressVideoOptions.decode(P, P.uint32());
            break;
          default:
            P.skipType(I & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(Z) {
      return {
        ingressId: Ae(Z.ingressId) ? String(Z.ingressId) : "",
        name: Ae(Z.name) ? String(Z.name) : "",
        roomName: Ae(Z.roomName) ? String(Z.roomName) : "",
        participantIdentity: Ae(Z.participantIdentity) ? String(Z.participantIdentity) : "",
        participantName: Ae(Z.participantName) ? String(Z.participantName) : "",
        audio: Ae(Z.audio) ? a.IngressAudioOptions.fromJSON(Z.audio) : void 0,
        video: Ae(Z.video) ? a.IngressVideoOptions.fromJSON(Z.video) : void 0
      };
    },
    toJSON(Z) {
      const z = {};
      return Z.ingressId !== void 0 && (z.ingressId = Z.ingressId), Z.name !== void 0 && (z.name = Z.name), Z.roomName !== void 0 && (z.roomName = Z.roomName), Z.participantIdentity !== void 0 && (z.participantIdentity = Z.participantIdentity), Z.participantName !== void 0 && (z.participantName = Z.participantName), Z.audio !== void 0 && (z.audio = Z.audio ? a.IngressAudioOptions.toJSON(Z.audio) : void 0), Z.video !== void 0 && (z.video = Z.video ? a.IngressVideoOptions.toJSON(Z.video) : void 0), z;
    },
    fromPartial(Z) {
      var z, P, S, E, I;
      const N = ie();
      return N.ingressId = (z = Z.ingressId) !== null && z !== void 0 ? z : "", N.name = (P = Z.name) !== null && P !== void 0 ? P : "", N.roomName = (S = Z.roomName) !== null && S !== void 0 ? S : "", N.participantIdentity = (E = Z.participantIdentity) !== null && E !== void 0 ? E : "", N.participantName = (I = Z.participantName) !== null && I !== void 0 ? I : "", N.audio = Z.audio !== void 0 && Z.audio !== null ? a.IngressAudioOptions.fromPartial(Z.audio) : void 0, N.video = Z.video !== void 0 && Z.video !== null ? a.IngressVideoOptions.fromPartial(Z.video) : void 0, N;
    }
  };
  function ge() {
    return { roomName: "" };
  }
  a.ListIngressRequest = {
    encode(Z, z = l.default.Writer.create()) {
      return Z.roomName !== void 0 && Z.roomName !== "" && z.uint32(10).string(Z.roomName), z;
    },
    decode(Z, z) {
      const P = Z instanceof l.default.Reader ? Z : new l.default.Reader(Z);
      let S = z === void 0 ? P.len : P.pos + z;
      const E = ge();
      for (; P.pos < S; ) {
        const I = P.uint32();
        switch (I >>> 3) {
          case 1:
            E.roomName = P.string();
            break;
          default:
            P.skipType(I & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(Z) {
      return { roomName: Ae(Z.roomName) ? String(Z.roomName) : "" };
    },
    toJSON(Z) {
      const z = {};
      return Z.roomName !== void 0 && (z.roomName = Z.roomName), z;
    },
    fromPartial(Z) {
      var z;
      const P = ge();
      return P.roomName = (z = Z.roomName) !== null && z !== void 0 ? z : "", P;
    }
  };
  function be() {
    return { items: [] };
  }
  a.ListIngressResponse = {
    encode(Z, z = l.default.Writer.create()) {
      if (Z.items !== void 0 && Z.items.length !== 0)
        for (const P of Z.items)
          a.IngressInfo.encode(P, z.uint32(10).fork()).ldelim();
      return z;
    },
    decode(Z, z) {
      const P = Z instanceof l.default.Reader ? Z : new l.default.Reader(Z);
      let S = z === void 0 ? P.len : P.pos + z;
      const E = be();
      for (; P.pos < S; ) {
        const I = P.uint32();
        switch (I >>> 3) {
          case 1:
            E.items.push(a.IngressInfo.decode(P, P.uint32()));
            break;
          default:
            P.skipType(I & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(Z) {
      return { items: Array.isArray(Z == null ? void 0 : Z.items) ? Z.items.map((z) => a.IngressInfo.fromJSON(z)) : [] };
    },
    toJSON(Z) {
      const z = {};
      return Z.items ? z.items = Z.items.map((P) => P ? a.IngressInfo.toJSON(P) : void 0) : z.items = [], z;
    },
    fromPartial(Z) {
      var z;
      const P = be();
      return P.items = ((z = Z.items) === null || z === void 0 ? void 0 : z.map((S) => a.IngressInfo.fromPartial(S))) || [], P;
    }
  };
  function Ce() {
    return { ingressId: "" };
  }
  a.DeleteIngressRequest = {
    encode(Z, z = l.default.Writer.create()) {
      return Z.ingressId !== void 0 && Z.ingressId !== "" && z.uint32(10).string(Z.ingressId), z;
    },
    decode(Z, z) {
      const P = Z instanceof l.default.Reader ? Z : new l.default.Reader(Z);
      let S = z === void 0 ? P.len : P.pos + z;
      const E = Ce();
      for (; P.pos < S; ) {
        const I = P.uint32();
        switch (I >>> 3) {
          case 1:
            E.ingressId = P.string();
            break;
          default:
            P.skipType(I & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(Z) {
      return { ingressId: Ae(Z.ingressId) ? String(Z.ingressId) : "" };
    },
    toJSON(Z) {
      const z = {};
      return Z.ingressId !== void 0 && (z.ingressId = Z.ingressId), z;
    },
    fromPartial(Z) {
      var z;
      const P = Ce();
      return P.ingressId = (z = Z.ingressId) !== null && z !== void 0 ? z : "", P;
    }
  };
  var Me = (() => {
    if (typeof Me < "u")
      return Me;
    if (typeof self < "u")
      return self;
    if (typeof window < "u")
      return window;
    if (typeof commonjsGlobal$1 < "u")
      return commonjsGlobal$1;
    throw "Unable to locate global object";
  })();
  function Be(Z) {
    if (Z.gt(Number.MAX_SAFE_INTEGER))
      throw new Me.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    return Z.toNumber();
  }
  l.default.util.Long !== c.default && (l.default.util.Long = c.default, l.default.configure());
  function Ae(Z) {
    return Z != null;
  }
})(livekit_ingress);
var __awaiter$1 = commonjsGlobal$1 && commonjsGlobal$1.__awaiter || function(a, u, c, l) {
  function v(p) {
    return p instanceof c ? p : new c(function(_) {
      _(p);
    });
  }
  return new (c || (c = Promise))(function(p, _) {
    function k(F) {
      try {
        L(l.next(F));
      } catch (V) {
        _(V);
      }
    }
    function M(F) {
      try {
        L(l.throw(F));
      } catch (V) {
        _(V);
      }
    }
    function L(F) {
      F.done ? p(F.value) : v(F.value).then(k, M);
    }
    L((l = l.apply(a, u || [])).next());
  });
}, __importDefault$3 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(IngressClient$1, "__esModule", { value: !0 });
IngressClient$1.IngressClient = void 0;
const livekit_ingress_1$1 = livekit_ingress, ServiceBase_1$1 = __importDefault$3(ServiceBase$1), TwirpRPC_1$1 = TwirpRPC, svc$1 = "Ingress";
class IngressClient extends ServiceBase_1$1.default {
  /**
   * @param host hostname including protocol. i.e. 'https://cluster.livekit.io'
   * @param apiKey API Key, can be set in env var LIVEKIT_API_KEY
   * @param secret API Secret, can be set in env var LIVEKIT_API_SECRET
   */
  constructor(u, c, l) {
    super(c, l), this.rpc = new TwirpRPC_1$1.TwirpRpc(u, TwirpRPC_1$1.livekitPackage);
  }
  /**
   * @param inputType protocol for the ingress
   * @param opts CreateIngressOptions
   */
  createIngress(u, c) {
    return __awaiter$1(this, void 0, void 0, function* () {
      let l = "", v = "", p = "", _ = "", k, M;
      c !== void 0 && (l = c.name || "", v = c.roomName || "", p = c.participantName || "", _ = c.participantIdentity || "", k = c.audioParams, M = c.videoParams);
      const L = livekit_ingress_1$1.CreateIngressRequest.toJSON({
        inputType: u,
        name: l,
        roomName: v,
        participantIdentity: _,
        participantName: p,
        audio: k,
        video: M
      }), F = yield this.rpc.request(svc$1, "CreateIngress", L, this.authHeader({ ingressAdmin: !0 }));
      return livekit_ingress_1$1.IngressInfo.fromJSON(F);
    });
  }
  /**
   * @param ingressId ID of the ingress to update
   * @param opts UpdateIngressOptions
   */
  updateIngress(u, c) {
    return __awaiter$1(this, void 0, void 0, function* () {
      const l = c.name || "", v = c.roomName || "", p = c.participantName || "", _ = c.participantIdentity || "", k = c.audioParams, M = c.videoParams, L = livekit_ingress_1$1.UpdateIngressRequest.toJSON({
        ingressId: u,
        name: l,
        roomName: v,
        participantIdentity: _,
        participantName: p,
        audio: k,
        video: M
      }), F = yield this.rpc.request(svc$1, "UpdateIngress", L, this.authHeader({ ingressAdmin: !0 }));
      return livekit_ingress_1$1.IngressInfo.fromJSON(F);
    });
  }
  /**
   * @param roomName list ingress for one room only
   */
  listIngress(u) {
    var c;
    return __awaiter$1(this, void 0, void 0, function* () {
      u ?? (u = "");
      const l = yield this.rpc.request(svc$1, "ListIngress", livekit_ingress_1$1.ListIngressRequest.toJSON({ roomName: u }), this.authHeader({ ingressAdmin: !0 }));
      return (c = livekit_ingress_1$1.ListIngressResponse.fromJSON(l).items) !== null && c !== void 0 ? c : [];
    });
  }
  /**
   * @param ingressId ingress to delete
   */
  deleteIngress(u) {
    return __awaiter$1(this, void 0, void 0, function* () {
      const c = yield this.rpc.request(svc$1, "DeleteIngress", livekit_ingress_1$1.DeleteIngressRequest.toJSON({ ingressId: u }), this.authHeader({ ingressAdmin: !0 }));
      return livekit_ingress_1$1.IngressInfo.fromJSON(c);
    });
  }
}
IngressClient$1.IngressClient = IngressClient;
var RoomServiceClient$1 = {}, livekit_room = {};
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(P) {
    return P && P.__esModule ? P : { default: P };
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.UpdateRoomMetadataRequest = a.SendDataResponse = a.SendDataRequest = a.UpdateSubscriptionsResponse = a.UpdateSubscriptionsRequest = a.UpdateParticipantRequest = a.MuteRoomTrackResponse = a.MuteRoomTrackRequest = a.RemoveParticipantResponse = a.RoomParticipantIdentity = a.ListParticipantsResponse = a.ListParticipantsRequest = a.DeleteRoomResponse = a.DeleteRoomRequest = a.ListRoomsResponse = a.ListRoomsRequest = a.RoomEgress = a.CreateRoomRequest = a.protobufPackage = void 0;
  const c = u(minimal), l = livekit_egress, v = livekit_models;
  a.protobufPackage = "livekit";
  function p() {
    return { name: "", emptyTimeout: 0, maxParticipants: 0, nodeId: "", metadata: "", egress: void 0 };
  }
  a.CreateRoomRequest = {
    encode(P, S = c.default.Writer.create()) {
      return P.name !== void 0 && P.name !== "" && S.uint32(10).string(P.name), P.emptyTimeout !== void 0 && P.emptyTimeout !== 0 && S.uint32(16).uint32(P.emptyTimeout), P.maxParticipants !== void 0 && P.maxParticipants !== 0 && S.uint32(24).uint32(P.maxParticipants), P.nodeId !== void 0 && P.nodeId !== "" && S.uint32(34).string(P.nodeId), P.metadata !== void 0 && P.metadata !== "" && S.uint32(42).string(P.metadata), P.egress !== void 0 && a.RoomEgress.encode(P.egress, S.uint32(50).fork()).ldelim(), S;
    },
    decode(P, S) {
      const E = P instanceof c.default.Reader ? P : new c.default.Reader(P);
      let I = S === void 0 ? E.len : E.pos + S;
      const N = p();
      for (; E.pos < I; ) {
        const $ = E.uint32();
        switch ($ >>> 3) {
          case 1:
            N.name = E.string();
            break;
          case 2:
            N.emptyTimeout = E.uint32();
            break;
          case 3:
            N.maxParticipants = E.uint32();
            break;
          case 4:
            N.nodeId = E.string();
            break;
          case 5:
            N.metadata = E.string();
            break;
          case 6:
            N.egress = a.RoomEgress.decode(E, E.uint32());
            break;
          default:
            E.skipType($ & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(P) {
      return {
        name: z(P.name) ? String(P.name) : "",
        emptyTimeout: z(P.emptyTimeout) ? Number(P.emptyTimeout) : 0,
        maxParticipants: z(P.maxParticipants) ? Number(P.maxParticipants) : 0,
        nodeId: z(P.nodeId) ? String(P.nodeId) : "",
        metadata: z(P.metadata) ? String(P.metadata) : "",
        egress: z(P.egress) ? a.RoomEgress.fromJSON(P.egress) : void 0
      };
    },
    toJSON(P) {
      const S = {};
      return P.name !== void 0 && (S.name = P.name), P.emptyTimeout !== void 0 && (S.emptyTimeout = Math.round(P.emptyTimeout)), P.maxParticipants !== void 0 && (S.maxParticipants = Math.round(P.maxParticipants)), P.nodeId !== void 0 && (S.nodeId = P.nodeId), P.metadata !== void 0 && (S.metadata = P.metadata), P.egress !== void 0 && (S.egress = P.egress ? a.RoomEgress.toJSON(P.egress) : void 0), S;
    },
    fromPartial(P) {
      var S, E, I, N, $;
      const U = p();
      return U.name = (S = P.name) !== null && S !== void 0 ? S : "", U.emptyTimeout = (E = P.emptyTimeout) !== null && E !== void 0 ? E : 0, U.maxParticipants = (I = P.maxParticipants) !== null && I !== void 0 ? I : 0, U.nodeId = (N = P.nodeId) !== null && N !== void 0 ? N : "", U.metadata = ($ = P.metadata) !== null && $ !== void 0 ? $ : "", U.egress = P.egress !== void 0 && P.egress !== null ? a.RoomEgress.fromPartial(P.egress) : void 0, U;
    }
  };
  function _() {
    return { room: void 0, tracks: void 0 };
  }
  a.RoomEgress = {
    encode(P, S = c.default.Writer.create()) {
      return P.room !== void 0 && l.RoomCompositeEgressRequest.encode(P.room, S.uint32(10).fork()).ldelim(), P.tracks !== void 0 && l.AutoTrackEgress.encode(P.tracks, S.uint32(18).fork()).ldelim(), S;
    },
    decode(P, S) {
      const E = P instanceof c.default.Reader ? P : new c.default.Reader(P);
      let I = S === void 0 ? E.len : E.pos + S;
      const N = _();
      for (; E.pos < I; ) {
        const $ = E.uint32();
        switch ($ >>> 3) {
          case 1:
            N.room = l.RoomCompositeEgressRequest.decode(E, E.uint32());
            break;
          case 2:
            N.tracks = l.AutoTrackEgress.decode(E, E.uint32());
            break;
          default:
            E.skipType($ & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(P) {
      return {
        room: z(P.room) ? l.RoomCompositeEgressRequest.fromJSON(P.room) : void 0,
        tracks: z(P.tracks) ? l.AutoTrackEgress.fromJSON(P.tracks) : void 0
      };
    },
    toJSON(P) {
      const S = {};
      return P.room !== void 0 && (S.room = P.room ? l.RoomCompositeEgressRequest.toJSON(P.room) : void 0), P.tracks !== void 0 && (S.tracks = P.tracks ? l.AutoTrackEgress.toJSON(P.tracks) : void 0), S;
    },
    fromPartial(P) {
      const S = _();
      return S.room = P.room !== void 0 && P.room !== null ? l.RoomCompositeEgressRequest.fromPartial(P.room) : void 0, S.tracks = P.tracks !== void 0 && P.tracks !== null ? l.AutoTrackEgress.fromPartial(P.tracks) : void 0, S;
    }
  };
  function k() {
    return { names: [] };
  }
  a.ListRoomsRequest = {
    encode(P, S = c.default.Writer.create()) {
      if (P.names !== void 0 && P.names.length !== 0)
        for (const E of P.names)
          S.uint32(10).string(E);
      return S;
    },
    decode(P, S) {
      const E = P instanceof c.default.Reader ? P : new c.default.Reader(P);
      let I = S === void 0 ? E.len : E.pos + S;
      const N = k();
      for (; E.pos < I; ) {
        const $ = E.uint32();
        switch ($ >>> 3) {
          case 1:
            N.names.push(E.string());
            break;
          default:
            E.skipType($ & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(P) {
      return { names: Array.isArray(P == null ? void 0 : P.names) ? P.names.map((S) => String(S)) : [] };
    },
    toJSON(P) {
      const S = {};
      return P.names ? S.names = P.names.map((E) => E) : S.names = [], S;
    },
    fromPartial(P) {
      var S;
      const E = k();
      return E.names = ((S = P.names) === null || S === void 0 ? void 0 : S.map((I) => I)) || [], E;
    }
  };
  function M() {
    return { rooms: [] };
  }
  a.ListRoomsResponse = {
    encode(P, S = c.default.Writer.create()) {
      if (P.rooms !== void 0 && P.rooms.length !== 0)
        for (const E of P.rooms)
          v.Room.encode(E, S.uint32(10).fork()).ldelim();
      return S;
    },
    decode(P, S) {
      const E = P instanceof c.default.Reader ? P : new c.default.Reader(P);
      let I = S === void 0 ? E.len : E.pos + S;
      const N = M();
      for (; E.pos < I; ) {
        const $ = E.uint32();
        switch ($ >>> 3) {
          case 1:
            N.rooms.push(v.Room.decode(E, E.uint32()));
            break;
          default:
            E.skipType($ & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(P) {
      return { rooms: Array.isArray(P == null ? void 0 : P.rooms) ? P.rooms.map((S) => v.Room.fromJSON(S)) : [] };
    },
    toJSON(P) {
      const S = {};
      return P.rooms ? S.rooms = P.rooms.map((E) => E ? v.Room.toJSON(E) : void 0) : S.rooms = [], S;
    },
    fromPartial(P) {
      var S;
      const E = M();
      return E.rooms = ((S = P.rooms) === null || S === void 0 ? void 0 : S.map((I) => v.Room.fromPartial(I))) || [], E;
    }
  };
  function L() {
    return { room: "" };
  }
  a.DeleteRoomRequest = {
    encode(P, S = c.default.Writer.create()) {
      return P.room !== void 0 && P.room !== "" && S.uint32(10).string(P.room), S;
    },
    decode(P, S) {
      const E = P instanceof c.default.Reader ? P : new c.default.Reader(P);
      let I = S === void 0 ? E.len : E.pos + S;
      const N = L();
      for (; E.pos < I; ) {
        const $ = E.uint32();
        switch ($ >>> 3) {
          case 1:
            N.room = E.string();
            break;
          default:
            E.skipType($ & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(P) {
      return { room: z(P.room) ? String(P.room) : "" };
    },
    toJSON(P) {
      const S = {};
      return P.room !== void 0 && (S.room = P.room), S;
    },
    fromPartial(P) {
      var S;
      const E = L();
      return E.room = (S = P.room) !== null && S !== void 0 ? S : "", E;
    }
  };
  function F() {
    return {};
  }
  a.DeleteRoomResponse = {
    encode(P, S = c.default.Writer.create()) {
      return S;
    },
    decode(P, S) {
      const E = P instanceof c.default.Reader ? P : new c.default.Reader(P);
      let I = S === void 0 ? E.len : E.pos + S;
      const N = F();
      for (; E.pos < I; ) {
        const $ = E.uint32();
        switch ($ >>> 3) {
          default:
            E.skipType($ & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(P) {
      return {};
    },
    toJSON(P) {
      return {};
    },
    fromPartial(P) {
      return F();
    }
  };
  function V() {
    return { room: "" };
  }
  a.ListParticipantsRequest = {
    encode(P, S = c.default.Writer.create()) {
      return P.room !== void 0 && P.room !== "" && S.uint32(10).string(P.room), S;
    },
    decode(P, S) {
      const E = P instanceof c.default.Reader ? P : new c.default.Reader(P);
      let I = S === void 0 ? E.len : E.pos + S;
      const N = V();
      for (; E.pos < I; ) {
        const $ = E.uint32();
        switch ($ >>> 3) {
          case 1:
            N.room = E.string();
            break;
          default:
            E.skipType($ & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(P) {
      return { room: z(P.room) ? String(P.room) : "" };
    },
    toJSON(P) {
      const S = {};
      return P.room !== void 0 && (S.room = P.room), S;
    },
    fromPartial(P) {
      var S;
      const E = V();
      return E.room = (S = P.room) !== null && S !== void 0 ? S : "", E;
    }
  };
  function X() {
    return { participants: [] };
  }
  a.ListParticipantsResponse = {
    encode(P, S = c.default.Writer.create()) {
      if (P.participants !== void 0 && P.participants.length !== 0)
        for (const E of P.participants)
          v.ParticipantInfo.encode(E, S.uint32(10).fork()).ldelim();
      return S;
    },
    decode(P, S) {
      const E = P instanceof c.default.Reader ? P : new c.default.Reader(P);
      let I = S === void 0 ? E.len : E.pos + S;
      const N = X();
      for (; E.pos < I; ) {
        const $ = E.uint32();
        switch ($ >>> 3) {
          case 1:
            N.participants.push(v.ParticipantInfo.decode(E, E.uint32()));
            break;
          default:
            E.skipType($ & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(P) {
      return {
        participants: Array.isArray(P == null ? void 0 : P.participants) ? P.participants.map((S) => v.ParticipantInfo.fromJSON(S)) : []
      };
    },
    toJSON(P) {
      const S = {};
      return P.participants ? S.participants = P.participants.map((E) => E ? v.ParticipantInfo.toJSON(E) : void 0) : S.participants = [], S;
    },
    fromPartial(P) {
      var S;
      const E = X();
      return E.participants = ((S = P.participants) === null || S === void 0 ? void 0 : S.map((I) => v.ParticipantInfo.fromPartial(I))) || [], E;
    }
  };
  function oe() {
    return { room: "", identity: "" };
  }
  a.RoomParticipantIdentity = {
    encode(P, S = c.default.Writer.create()) {
      return P.room !== void 0 && P.room !== "" && S.uint32(10).string(P.room), P.identity !== void 0 && P.identity !== "" && S.uint32(18).string(P.identity), S;
    },
    decode(P, S) {
      const E = P instanceof c.default.Reader ? P : new c.default.Reader(P);
      let I = S === void 0 ? E.len : E.pos + S;
      const N = oe();
      for (; E.pos < I; ) {
        const $ = E.uint32();
        switch ($ >>> 3) {
          case 1:
            N.room = E.string();
            break;
          case 2:
            N.identity = E.string();
            break;
          default:
            E.skipType($ & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(P) {
      return {
        room: z(P.room) ? String(P.room) : "",
        identity: z(P.identity) ? String(P.identity) : ""
      };
    },
    toJSON(P) {
      const S = {};
      return P.room !== void 0 && (S.room = P.room), P.identity !== void 0 && (S.identity = P.identity), S;
    },
    fromPartial(P) {
      var S, E;
      const I = oe();
      return I.room = (S = P.room) !== null && S !== void 0 ? S : "", I.identity = (E = P.identity) !== null && E !== void 0 ? E : "", I;
    }
  };
  function Y() {
    return {};
  }
  a.RemoveParticipantResponse = {
    encode(P, S = c.default.Writer.create()) {
      return S;
    },
    decode(P, S) {
      const E = P instanceof c.default.Reader ? P : new c.default.Reader(P);
      let I = S === void 0 ? E.len : E.pos + S;
      const N = Y();
      for (; E.pos < I; ) {
        const $ = E.uint32();
        switch ($ >>> 3) {
          default:
            E.skipType($ & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(P) {
      return {};
    },
    toJSON(P) {
      return {};
    },
    fromPartial(P) {
      return Y();
    }
  };
  function ae() {
    return { room: "", identity: "", trackSid: "", muted: !1 };
  }
  a.MuteRoomTrackRequest = {
    encode(P, S = c.default.Writer.create()) {
      return P.room !== void 0 && P.room !== "" && S.uint32(10).string(P.room), P.identity !== void 0 && P.identity !== "" && S.uint32(18).string(P.identity), P.trackSid !== void 0 && P.trackSid !== "" && S.uint32(26).string(P.trackSid), P.muted === !0 && S.uint32(32).bool(P.muted), S;
    },
    decode(P, S) {
      const E = P instanceof c.default.Reader ? P : new c.default.Reader(P);
      let I = S === void 0 ? E.len : E.pos + S;
      const N = ae();
      for (; E.pos < I; ) {
        const $ = E.uint32();
        switch ($ >>> 3) {
          case 1:
            N.room = E.string();
            break;
          case 2:
            N.identity = E.string();
            break;
          case 3:
            N.trackSid = E.string();
            break;
          case 4:
            N.muted = E.bool();
            break;
          default:
            E.skipType($ & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(P) {
      return {
        room: z(P.room) ? String(P.room) : "",
        identity: z(P.identity) ? String(P.identity) : "",
        trackSid: z(P.trackSid) ? String(P.trackSid) : "",
        muted: z(P.muted) ? !!P.muted : !1
      };
    },
    toJSON(P) {
      const S = {};
      return P.room !== void 0 && (S.room = P.room), P.identity !== void 0 && (S.identity = P.identity), P.trackSid !== void 0 && (S.trackSid = P.trackSid), P.muted !== void 0 && (S.muted = P.muted), S;
    },
    fromPartial(P) {
      var S, E, I, N;
      const $ = ae();
      return $.room = (S = P.room) !== null && S !== void 0 ? S : "", $.identity = (E = P.identity) !== null && E !== void 0 ? E : "", $.trackSid = (I = P.trackSid) !== null && I !== void 0 ? I : "", $.muted = (N = P.muted) !== null && N !== void 0 ? N : !1, $;
    }
  };
  function ne() {
    return { track: void 0 };
  }
  a.MuteRoomTrackResponse = {
    encode(P, S = c.default.Writer.create()) {
      return P.track !== void 0 && v.TrackInfo.encode(P.track, S.uint32(10).fork()).ldelim(), S;
    },
    decode(P, S) {
      const E = P instanceof c.default.Reader ? P : new c.default.Reader(P);
      let I = S === void 0 ? E.len : E.pos + S;
      const N = ne();
      for (; E.pos < I; ) {
        const $ = E.uint32();
        switch ($ >>> 3) {
          case 1:
            N.track = v.TrackInfo.decode(E, E.uint32());
            break;
          default:
            E.skipType($ & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(P) {
      return { track: z(P.track) ? v.TrackInfo.fromJSON(P.track) : void 0 };
    },
    toJSON(P) {
      const S = {};
      return P.track !== void 0 && (S.track = P.track ? v.TrackInfo.toJSON(P.track) : void 0), S;
    },
    fromPartial(P) {
      const S = ne();
      return S.track = P.track !== void 0 && P.track !== null ? v.TrackInfo.fromPartial(P.track) : void 0, S;
    }
  };
  function fe() {
    return { room: "", identity: "", metadata: "", permission: void 0, name: "" };
  }
  a.UpdateParticipantRequest = {
    encode(P, S = c.default.Writer.create()) {
      return P.room !== void 0 && P.room !== "" && S.uint32(10).string(P.room), P.identity !== void 0 && P.identity !== "" && S.uint32(18).string(P.identity), P.metadata !== void 0 && P.metadata !== "" && S.uint32(26).string(P.metadata), P.permission !== void 0 && v.ParticipantPermission.encode(P.permission, S.uint32(34).fork()).ldelim(), P.name !== void 0 && P.name !== "" && S.uint32(42).string(P.name), S;
    },
    decode(P, S) {
      const E = P instanceof c.default.Reader ? P : new c.default.Reader(P);
      let I = S === void 0 ? E.len : E.pos + S;
      const N = fe();
      for (; E.pos < I; ) {
        const $ = E.uint32();
        switch ($ >>> 3) {
          case 1:
            N.room = E.string();
            break;
          case 2:
            N.identity = E.string();
            break;
          case 3:
            N.metadata = E.string();
            break;
          case 4:
            N.permission = v.ParticipantPermission.decode(E, E.uint32());
            break;
          case 5:
            N.name = E.string();
            break;
          default:
            E.skipType($ & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(P) {
      return {
        room: z(P.room) ? String(P.room) : "",
        identity: z(P.identity) ? String(P.identity) : "",
        metadata: z(P.metadata) ? String(P.metadata) : "",
        permission: z(P.permission) ? v.ParticipantPermission.fromJSON(P.permission) : void 0,
        name: z(P.name) ? String(P.name) : ""
      };
    },
    toJSON(P) {
      const S = {};
      return P.room !== void 0 && (S.room = P.room), P.identity !== void 0 && (S.identity = P.identity), P.metadata !== void 0 && (S.metadata = P.metadata), P.permission !== void 0 && (S.permission = P.permission ? v.ParticipantPermission.toJSON(P.permission) : void 0), P.name !== void 0 && (S.name = P.name), S;
    },
    fromPartial(P) {
      var S, E, I, N;
      const $ = fe();
      return $.room = (S = P.room) !== null && S !== void 0 ? S : "", $.identity = (E = P.identity) !== null && E !== void 0 ? E : "", $.metadata = (I = P.metadata) !== null && I !== void 0 ? I : "", $.permission = P.permission !== void 0 && P.permission !== null ? v.ParticipantPermission.fromPartial(P.permission) : void 0, $.name = (N = P.name) !== null && N !== void 0 ? N : "", $;
    }
  };
  function ie() {
    return { room: "", identity: "", trackSids: [], subscribe: !1, participantTracks: [] };
  }
  a.UpdateSubscriptionsRequest = {
    encode(P, S = c.default.Writer.create()) {
      if (P.room !== void 0 && P.room !== "" && S.uint32(10).string(P.room), P.identity !== void 0 && P.identity !== "" && S.uint32(18).string(P.identity), P.trackSids !== void 0 && P.trackSids.length !== 0)
        for (const E of P.trackSids)
          S.uint32(26).string(E);
      if (P.subscribe === !0 && S.uint32(32).bool(P.subscribe), P.participantTracks !== void 0 && P.participantTracks.length !== 0)
        for (const E of P.participantTracks)
          v.ParticipantTracks.encode(E, S.uint32(42).fork()).ldelim();
      return S;
    },
    decode(P, S) {
      const E = P instanceof c.default.Reader ? P : new c.default.Reader(P);
      let I = S === void 0 ? E.len : E.pos + S;
      const N = ie();
      for (; E.pos < I; ) {
        const $ = E.uint32();
        switch ($ >>> 3) {
          case 1:
            N.room = E.string();
            break;
          case 2:
            N.identity = E.string();
            break;
          case 3:
            N.trackSids.push(E.string());
            break;
          case 4:
            N.subscribe = E.bool();
            break;
          case 5:
            N.participantTracks.push(v.ParticipantTracks.decode(E, E.uint32()));
            break;
          default:
            E.skipType($ & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(P) {
      return {
        room: z(P.room) ? String(P.room) : "",
        identity: z(P.identity) ? String(P.identity) : "",
        trackSids: Array.isArray(P == null ? void 0 : P.trackSids) ? P.trackSids.map((S) => String(S)) : [],
        subscribe: z(P.subscribe) ? !!P.subscribe : !1,
        participantTracks: Array.isArray(P == null ? void 0 : P.participantTracks) ? P.participantTracks.map((S) => v.ParticipantTracks.fromJSON(S)) : []
      };
    },
    toJSON(P) {
      const S = {};
      return P.room !== void 0 && (S.room = P.room), P.identity !== void 0 && (S.identity = P.identity), P.trackSids ? S.trackSids = P.trackSids.map((E) => E) : S.trackSids = [], P.subscribe !== void 0 && (S.subscribe = P.subscribe), P.participantTracks ? S.participantTracks = P.participantTracks.map((E) => E ? v.ParticipantTracks.toJSON(E) : void 0) : S.participantTracks = [], S;
    },
    fromPartial(P) {
      var S, E, I, N, $;
      const U = ie();
      return U.room = (S = P.room) !== null && S !== void 0 ? S : "", U.identity = (E = P.identity) !== null && E !== void 0 ? E : "", U.trackSids = ((I = P.trackSids) === null || I === void 0 ? void 0 : I.map((H) => H)) || [], U.subscribe = (N = P.subscribe) !== null && N !== void 0 ? N : !1, U.participantTracks = (($ = P.participantTracks) === null || $ === void 0 ? void 0 : $.map((H) => v.ParticipantTracks.fromPartial(H))) || [], U;
    }
  };
  function ge() {
    return {};
  }
  a.UpdateSubscriptionsResponse = {
    encode(P, S = c.default.Writer.create()) {
      return S;
    },
    decode(P, S) {
      const E = P instanceof c.default.Reader ? P : new c.default.Reader(P);
      let I = S === void 0 ? E.len : E.pos + S;
      const N = ge();
      for (; E.pos < I; ) {
        const $ = E.uint32();
        switch ($ >>> 3) {
          default:
            E.skipType($ & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(P) {
      return {};
    },
    toJSON(P) {
      return {};
    },
    fromPartial(P) {
      return ge();
    }
  };
  function be() {
    return { room: "", data: new Uint8Array(), kind: 0, destinationSids: [] };
  }
  a.SendDataRequest = {
    encode(P, S = c.default.Writer.create()) {
      if (P.room !== void 0 && P.room !== "" && S.uint32(10).string(P.room), P.data !== void 0 && P.data.length !== 0 && S.uint32(18).bytes(P.data), P.kind !== void 0 && P.kind !== 0 && S.uint32(24).int32(P.kind), P.destinationSids !== void 0 && P.destinationSids.length !== 0)
        for (const E of P.destinationSids)
          S.uint32(34).string(E);
      return S;
    },
    decode(P, S) {
      const E = P instanceof c.default.Reader ? P : new c.default.Reader(P);
      let I = S === void 0 ? E.len : E.pos + S;
      const N = be();
      for (; E.pos < I; ) {
        const $ = E.uint32();
        switch ($ >>> 3) {
          case 1:
            N.room = E.string();
            break;
          case 2:
            N.data = E.bytes();
            break;
          case 3:
            N.kind = E.int32();
            break;
          case 4:
            N.destinationSids.push(E.string());
            break;
          default:
            E.skipType($ & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(P) {
      return {
        room: z(P.room) ? String(P.room) : "",
        data: z(P.data) ? Ae(P.data) : new Uint8Array(),
        kind: z(P.kind) ? v.dataPacket_KindFromJSON(P.kind) : 0,
        destinationSids: Array.isArray(P == null ? void 0 : P.destinationSids) ? P.destinationSids.map((S) => String(S)) : []
      };
    },
    toJSON(P) {
      const S = {};
      return P.room !== void 0 && (S.room = P.room), P.data !== void 0 && (S.data = Z(P.data !== void 0 ? P.data : new Uint8Array())), P.kind !== void 0 && (S.kind = v.dataPacket_KindToJSON(P.kind)), P.destinationSids ? S.destinationSids = P.destinationSids.map((E) => E) : S.destinationSids = [], S;
    },
    fromPartial(P) {
      var S, E, I, N;
      const $ = be();
      return $.room = (S = P.room) !== null && S !== void 0 ? S : "", $.data = (E = P.data) !== null && E !== void 0 ? E : new Uint8Array(), $.kind = (I = P.kind) !== null && I !== void 0 ? I : 0, $.destinationSids = ((N = P.destinationSids) === null || N === void 0 ? void 0 : N.map((U) => U)) || [], $;
    }
  };
  function Ce() {
    return {};
  }
  a.SendDataResponse = {
    encode(P, S = c.default.Writer.create()) {
      return S;
    },
    decode(P, S) {
      const E = P instanceof c.default.Reader ? P : new c.default.Reader(P);
      let I = S === void 0 ? E.len : E.pos + S;
      const N = Ce();
      for (; E.pos < I; ) {
        const $ = E.uint32();
        switch ($ >>> 3) {
          default:
            E.skipType($ & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(P) {
      return {};
    },
    toJSON(P) {
      return {};
    },
    fromPartial(P) {
      return Ce();
    }
  };
  function Me() {
    return { room: "", metadata: "" };
  }
  a.UpdateRoomMetadataRequest = {
    encode(P, S = c.default.Writer.create()) {
      return P.room !== void 0 && P.room !== "" && S.uint32(10).string(P.room), P.metadata !== void 0 && P.metadata !== "" && S.uint32(18).string(P.metadata), S;
    },
    decode(P, S) {
      const E = P instanceof c.default.Reader ? P : new c.default.Reader(P);
      let I = S === void 0 ? E.len : E.pos + S;
      const N = Me();
      for (; E.pos < I; ) {
        const $ = E.uint32();
        switch ($ >>> 3) {
          case 1:
            N.room = E.string();
            break;
          case 2:
            N.metadata = E.string();
            break;
          default:
            E.skipType($ & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(P) {
      return {
        room: z(P.room) ? String(P.room) : "",
        metadata: z(P.metadata) ? String(P.metadata) : ""
      };
    },
    toJSON(P) {
      const S = {};
      return P.room !== void 0 && (S.room = P.room), P.metadata !== void 0 && (S.metadata = P.metadata), S;
    },
    fromPartial(P) {
      var S, E;
      const I = Me();
      return I.room = (S = P.room) !== null && S !== void 0 ? S : "", I.metadata = (E = P.metadata) !== null && E !== void 0 ? E : "", I;
    }
  };
  var Be = (() => {
    if (typeof Be < "u")
      return Be;
    if (typeof self < "u")
      return self;
    if (typeof window < "u")
      return window;
    if (typeof commonjsGlobal$1 < "u")
      return commonjsGlobal$1;
    throw "Unable to locate global object";
  })();
  function Ae(P) {
    if (Be.Buffer)
      return Uint8Array.from(Be.Buffer.from(P, "base64"));
    {
      const S = Be.atob(P), E = new Uint8Array(S.length);
      for (let I = 0; I < S.length; ++I)
        E[I] = S.charCodeAt(I);
      return E;
    }
  }
  function Z(P) {
    if (Be.Buffer)
      return Be.Buffer.from(P).toString("base64");
    {
      const S = [];
      return P.forEach((E) => {
        S.push(String.fromCharCode(E));
      }), Be.btoa(S.join(""));
    }
  }
  function z(P) {
    return P != null;
  }
})(livekit_room);
var __awaiter = commonjsGlobal$1 && commonjsGlobal$1.__awaiter || function(a, u, c, l) {
  function v(p) {
    return p instanceof c ? p : new c(function(_) {
      _(p);
    });
  }
  return new (c || (c = Promise))(function(p, _) {
    function k(F) {
      try {
        L(l.next(F));
      } catch (V) {
        _(V);
      }
    }
    function M(F) {
      try {
        L(l.throw(F));
      } catch (V) {
        _(V);
      }
    }
    function L(F) {
      F.done ? p(F.value) : v(F.value).then(k, M);
    }
    L((l = l.apply(a, u || [])).next());
  });
}, __importDefault$2 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(RoomServiceClient$1, "__esModule", { value: !0 });
RoomServiceClient$1.RoomServiceClient = void 0;
const livekit_models_1$1 = livekit_models, livekit_room_1 = livekit_room, ServiceBase_1 = __importDefault$2(ServiceBase$1), TwirpRPC_1 = TwirpRPC, svc = "RoomService";
class RoomServiceClient extends ServiceBase_1.default {
  /**
   *
   * @param host hostname including protocol. i.e. 'https://cluster.livekit.io'
   * @param apiKey API Key, can be set in env var LIVEKIT_API_KEY
   * @param secret API Secret, can be set in env var LIVEKIT_API_SECRET
   * @param jwt JWT Token, a pregenerated JWT token for authentication.
   * @param hostHeader A host header to send with the request.
   *
   */
  constructor(u, c, l, v, p) {
    super(c, l), this.jwt = v, this.rpc = new TwirpRPC_1.TwirpRpc(u, TwirpRPC_1.livekitPackage, void 0, p);
  }
  /**
   * Creates a new room. Explicit room creation is not required, since rooms will
   * be automatically created when the first participant joins. This method can be
   * used to customize room settings.
   * @param options
   */
  createRoom(u) {
    return __awaiter(this, void 0, void 0, function* () {
      const c = yield this.rpc.request(svc, "CreateRoom", livekit_room_1.CreateRoomRequest.toJSON(livekit_room_1.CreateRoomRequest.fromPartial(u)), this.authHeader({ roomCreate: !0 }));
      return livekit_models_1$1.Room.fromJSON(c);
    });
  }
  /**
   * List active rooms
   * @param names when undefined or empty, list all rooms.
   *              otherwise returns rooms with matching names
   * @returns
   */
  listRooms(u) {
    var c;
    return __awaiter(this, void 0, void 0, function* () {
      const l = yield this.rpc.request(svc, "ListRooms", livekit_room_1.ListRoomsRequest.toJSON({ names: u ?? [] }), this.authHeader({ roomList: !0 }));
      return (c = livekit_room_1.ListRoomsResponse.fromJSON(l).rooms) !== null && c !== void 0 ? c : [];
    });
  }
  deleteRoom(u) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.rpc.request(svc, "DeleteRoom", livekit_room_1.DeleteRoomRequest.toJSON({ room: u }), this.authHeader({ roomCreate: !0 }));
    });
  }
  /**
   * Update metadata of a room
   * @param room name of the room
   * @param metadata the new metadata for the room
   */
  updateRoomMetadata(u, c) {
    return __awaiter(this, void 0, void 0, function* () {
      const l = yield this.rpc.request(svc, "UpdateRoomMetadata", livekit_room_1.UpdateRoomMetadataRequest.toJSON({ room: u, metadata: c }), this.authHeader({ roomAdmin: !0, room: u }));
      return livekit_models_1$1.Room.fromJSON(l);
    });
  }
  /**
   * List participants in a room
   * @param room name of the room
   */
  listParticipants(u) {
    var c;
    return __awaiter(this, void 0, void 0, function* () {
      const l = yield this.rpc.request(svc, "ListParticipants", livekit_room_1.ListParticipantsRequest.toJSON({ room: u }), this.authHeader({ roomAdmin: !0, room: u }));
      return (c = livekit_room_1.ListParticipantsResponse.fromJSON(l).participants) !== null && c !== void 0 ? c : [];
    });
  }
  /**
   * Get information on a specific participant, including the tracks that participant
   * has published
   * @param room name of the room
   * @param identity identity of the participant to return
   */
  getParticipant(u, c) {
    return __awaiter(this, void 0, void 0, function* () {
      const l = yield this.rpc.request(svc, "GetParticipant", livekit_room_1.RoomParticipantIdentity.toJSON({ room: u, identity: c }), this.authHeader({ roomAdmin: !0, room: u }));
      return livekit_models_1$1.ParticipantInfo.fromJSON(l);
    });
  }
  /**
   * Removes a participant in the room. This will disconnect the participant
   * and will emit a Disconnected event for that participant.
   * Even after being removed, the participant can still re-join the room.
   * @param room
   * @param identity
   */
  removeParticipant(u, c) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.rpc.request(svc, "RemoveParticipant", livekit_room_1.RoomParticipantIdentity.toJSON({ room: u, identity: c }), this.authHeader({ roomAdmin: !0, room: u }));
    });
  }
  /**
   * Mutes a track that the participant has published.
   * @param room
   * @param identity
   * @param trackSid sid of the track to be muted
   * @param muted true to mute, false to unmute
   */
  mutePublishedTrack(u, c, l, v) {
    return __awaiter(this, void 0, void 0, function* () {
      const p = livekit_room_1.MuteRoomTrackRequest.toJSON({
        room: u,
        identity: c,
        trackSid: l,
        muted: v
      }), _ = yield this.rpc.request(svc, "MutePublishedTrack", p, this.authHeader({ roomAdmin: !0, room: u }));
      return livekit_room_1.MuteRoomTrackResponse.fromJSON(_).track;
    });
  }
  /**
   * Updates a participant's metadata or permissions
   * @param room
   * @param identity
   * @param metadata optional, metadata to update
   * @param permission optional, new permissions to assign to participant
   * @param name optional, new name for participant
   */
  updateParticipant(u, c, l, v, p) {
    return __awaiter(this, void 0, void 0, function* () {
      const _ = {
        room: u,
        identity: c,
        metadata: l || "",
        permission: v,
        name: p || ""
      }, k = yield this.rpc.request(svc, "UpdateParticipant", livekit_room_1.UpdateParticipantRequest.toJSON(_), this.authHeader({ roomAdmin: !0, room: u }));
      return livekit_models_1$1.ParticipantInfo.fromJSON(k);
    });
  }
  /**
   * Updates a participant's subscription to tracks
   * @param room
   * @param identity
   * @param trackSids
   * @param subscribe true to subscribe, false to unsubscribe
   */
  updateSubscriptions(u, c, l, v) {
    return __awaiter(this, void 0, void 0, function* () {
      const p = livekit_room_1.UpdateSubscriptionsRequest.toJSON({
        room: u,
        identity: c,
        trackSids: l,
        subscribe: v,
        participantTracks: []
      });
      yield this.rpc.request(svc, "UpdateSubscriptions", p, this.authHeader({ roomAdmin: !0, room: u }));
    });
  }
  /**
   * Sends data message to participants in the room
   * @param room
   * @param data opaque payload to send
   * @param kind delivery reliability
   * @param destinationSids optional. when empty, message is sent to everyone
   */
  sendData(u, c, l, v = []) {
    return __awaiter(this, void 0, void 0, function* () {
      const p = livekit_room_1.SendDataRequest.toJSON({
        room: u,
        data: c,
        kind: l,
        destinationSids: v
      });
      yield this.rpc.request(svc, "SendData", p, this.authHeader({ roomAdmin: !0, room: u }));
    });
  }
  authHeader(u) {
    return this.jwt ? { Authorization: `Bearer ${this.jwt}` } : super.authHeader(u);
  }
}
RoomServiceClient$1.RoomServiceClient = RoomServiceClient;
var WebhookReceiver$1 = {}, livekit_webhook = {}, __importDefault$1 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(livekit_webhook, "__esModule", { value: !0 });
livekit_webhook.WebhookEvent = livekit_webhook.protobufPackage = void 0;
const long_1 = __importDefault$1(umdExports), minimal_1 = __importDefault$1(minimal), livekit_egress_1 = livekit_egress, livekit_ingress_1 = livekit_ingress, livekit_models_1 = livekit_models;
livekit_webhook.protobufPackage = "livekit";
function createBaseWebhookEvent() {
  return {
    event: "",
    room: void 0,
    participant: void 0,
    egressInfo: void 0,
    ingressInfo: void 0,
    track: void 0,
    id: "",
    createdAt: 0
  };
}
livekit_webhook.WebhookEvent = {
  encode(a, u = minimal_1.default.Writer.create()) {
    return a.event !== void 0 && a.event !== "" && u.uint32(10).string(a.event), a.room !== void 0 && livekit_models_1.Room.encode(a.room, u.uint32(18).fork()).ldelim(), a.participant !== void 0 && livekit_models_1.ParticipantInfo.encode(a.participant, u.uint32(26).fork()).ldelim(), a.egressInfo !== void 0 && livekit_egress_1.EgressInfo.encode(a.egressInfo, u.uint32(74).fork()).ldelim(), a.ingressInfo !== void 0 && livekit_ingress_1.IngressInfo.encode(a.ingressInfo, u.uint32(82).fork()).ldelim(), a.track !== void 0 && livekit_models_1.TrackInfo.encode(a.track, u.uint32(66).fork()).ldelim(), a.id !== void 0 && a.id !== "" && u.uint32(50).string(a.id), a.createdAt !== void 0 && a.createdAt !== 0 && u.uint32(56).int64(a.createdAt), u;
  },
  decode(a, u) {
    const c = a instanceof minimal_1.default.Reader ? a : new minimal_1.default.Reader(a);
    let l = u === void 0 ? c.len : c.pos + u;
    const v = createBaseWebhookEvent();
    for (; c.pos < l; ) {
      const p = c.uint32();
      switch (p >>> 3) {
        case 1:
          v.event = c.string();
          break;
        case 2:
          v.room = livekit_models_1.Room.decode(c, c.uint32());
          break;
        case 3:
          v.participant = livekit_models_1.ParticipantInfo.decode(c, c.uint32());
          break;
        case 9:
          v.egressInfo = livekit_egress_1.EgressInfo.decode(c, c.uint32());
          break;
        case 10:
          v.ingressInfo = livekit_ingress_1.IngressInfo.decode(c, c.uint32());
          break;
        case 8:
          v.track = livekit_models_1.TrackInfo.decode(c, c.uint32());
          break;
        case 6:
          v.id = c.string();
          break;
        case 7:
          v.createdAt = longToNumber(c.int64());
          break;
        default:
          c.skipType(p & 7);
          break;
      }
    }
    return v;
  },
  fromJSON(a) {
    return {
      event: isSet(a.event) ? String(a.event) : "",
      room: isSet(a.room) ? livekit_models_1.Room.fromJSON(a.room) : void 0,
      participant: isSet(a.participant) ? livekit_models_1.ParticipantInfo.fromJSON(a.participant) : void 0,
      egressInfo: isSet(a.egressInfo) ? livekit_egress_1.EgressInfo.fromJSON(a.egressInfo) : void 0,
      ingressInfo: isSet(a.ingressInfo) ? livekit_ingress_1.IngressInfo.fromJSON(a.ingressInfo) : void 0,
      track: isSet(a.track) ? livekit_models_1.TrackInfo.fromJSON(a.track) : void 0,
      id: isSet(a.id) ? String(a.id) : "",
      createdAt: isSet(a.createdAt) ? Number(a.createdAt) : 0
    };
  },
  toJSON(a) {
    const u = {};
    return a.event !== void 0 && (u.event = a.event), a.room !== void 0 && (u.room = a.room ? livekit_models_1.Room.toJSON(a.room) : void 0), a.participant !== void 0 && (u.participant = a.participant ? livekit_models_1.ParticipantInfo.toJSON(a.participant) : void 0), a.egressInfo !== void 0 && (u.egressInfo = a.egressInfo ? livekit_egress_1.EgressInfo.toJSON(a.egressInfo) : void 0), a.ingressInfo !== void 0 && (u.ingressInfo = a.ingressInfo ? livekit_ingress_1.IngressInfo.toJSON(a.ingressInfo) : void 0), a.track !== void 0 && (u.track = a.track ? livekit_models_1.TrackInfo.toJSON(a.track) : void 0), a.id !== void 0 && (u.id = a.id), a.createdAt !== void 0 && (u.createdAt = Math.round(a.createdAt)), u;
  },
  fromPartial(a) {
    var u, c, l;
    const v = createBaseWebhookEvent();
    return v.event = (u = a.event) !== null && u !== void 0 ? u : "", v.room = a.room !== void 0 && a.room !== null ? livekit_models_1.Room.fromPartial(a.room) : void 0, v.participant = a.participant !== void 0 && a.participant !== null ? livekit_models_1.ParticipantInfo.fromPartial(a.participant) : void 0, v.egressInfo = a.egressInfo !== void 0 && a.egressInfo !== null ? livekit_egress_1.EgressInfo.fromPartial(a.egressInfo) : void 0, v.ingressInfo = a.ingressInfo !== void 0 && a.ingressInfo !== null ? livekit_ingress_1.IngressInfo.fromPartial(a.ingressInfo) : void 0, v.track = a.track !== void 0 && a.track !== null ? livekit_models_1.TrackInfo.fromPartial(a.track) : void 0, v.id = (c = a.id) !== null && c !== void 0 ? c : "", v.createdAt = (l = a.createdAt) !== null && l !== void 0 ? l : 0, v;
  }
};
var globalThis$1 = (() => {
  if (typeof globalThis$1 < "u")
    return globalThis$1;
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof commonjsGlobal$1 < "u")
    return commonjsGlobal$1;
  throw "Unable to locate global object";
})();
function longToNumber(a) {
  if (a.gt(Number.MAX_SAFE_INTEGER))
    throw new globalThis$1.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  return a.toNumber();
}
minimal_1.default.util.Long !== long_1.default && (minimal_1.default.util.Long = long_1.default, minimal_1.default.configure());
function isSet(a) {
  return a != null;
}
var __importDefault = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(WebhookReceiver$1, "__esModule", { value: !0 });
WebhookReceiver$1.WebhookReceiver = WebhookReceiver$1.authorizeHeader = void 0;
const crypto_1 = __importDefault(requireCryptoBrowserify()), AccessToken_1 = AccessToken$1, livekit_webhook_1 = livekit_webhook;
WebhookReceiver$1.authorizeHeader = "Authorize";
class WebhookReceiver {
  constructor(u, c) {
    this.verifier = new AccessToken_1.TokenVerifier(u, c);
  }
  /**
   *
   * @param body string of the posted body
   * @param authHeader `Authorization` header from the request
   * @param skipAuth true to skip auth validation
   * @returns
   */
  receive(u, c, l = !1) {
    if (!l) {
      if (!c)
        throw new Error("authorization header is empty");
      const v = this.verifier.verify(c), p = crypto_1.default.createHash("sha256");
      if (p.update(u), v.sha256 !== p.digest("base64"))
        throw new Error("sha256 checksum of body does not match");
    }
    return livekit_webhook_1.WebhookEvent.fromJSON(JSON.parse(u));
  }
}
WebhookReceiver$1.WebhookReceiver = WebhookReceiver;
var livekit_internal = {}, livekit_rtc = {};
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(O) {
    return O && O.__esModule ? O : { default: O };
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.SimulateScenario = a.DataChannelInfo = a.SyncState = a.SubscriptionPermissionUpdate = a.SubscriptionPermission = a.TrackPermission = a.SubscribedQualityUpdate = a.SubscribedCodec = a.SubscribedQuality = a.StreamStateUpdate = a.StreamStateInfo = a.ConnectionQualityUpdate = a.ConnectionQualityInfo = a.RoomUpdate = a.SpeakersChanged = a.ICEServer = a.UpdateVideoLayers = a.LeaveRequest = a.UpdateTrackSettings = a.UpdateSubscription = a.ParticipantUpdate = a.SessionDescription = a.TrackUnpublishedResponse = a.TrackPublishedResponse = a.JoinResponse = a.MuteTrackRequest = a.TrickleRequest = a.AddTrackRequest = a.SimulcastCodec = a.SignalResponse = a.SignalRequest = a.candidateProtocolToJSON = a.candidateProtocolFromJSON = a.CandidateProtocol = a.streamStateToJSON = a.streamStateFromJSON = a.StreamState = a.signalTargetToJSON = a.signalTargetFromJSON = a.SignalTarget = a.protobufPackage = void 0;
  const c = u(umdExports), l = u(minimal), v = livekit_models;
  a.protobufPackage = "livekit";
  var p;
  (function(O) {
    O[O.PUBLISHER = 0] = "PUBLISHER", O[O.SUBSCRIBER = 1] = "SUBSCRIBER", O[O.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(p = a.SignalTarget || (a.SignalTarget = {}));
  function _(O) {
    switch (O) {
      case 0:
      case "PUBLISHER":
        return p.PUBLISHER;
      case 1:
      case "SUBSCRIBER":
        return p.SUBSCRIBER;
      case -1:
      case "UNRECOGNIZED":
      default:
        return p.UNRECOGNIZED;
    }
  }
  a.signalTargetFromJSON = _;
  function k(O) {
    switch (O) {
      case p.PUBLISHER:
        return "PUBLISHER";
      case p.SUBSCRIBER:
        return "SUBSCRIBER";
      case p.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.signalTargetToJSON = k;
  var M;
  (function(O) {
    O[O.ACTIVE = 0] = "ACTIVE", O[O.PAUSED = 1] = "PAUSED", O[O.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(M = a.StreamState || (a.StreamState = {}));
  function L(O) {
    switch (O) {
      case 0:
      case "ACTIVE":
        return M.ACTIVE;
      case 1:
      case "PAUSED":
        return M.PAUSED;
      case -1:
      case "UNRECOGNIZED":
      default:
        return M.UNRECOGNIZED;
    }
  }
  a.streamStateFromJSON = L;
  function F(O) {
    switch (O) {
      case M.ACTIVE:
        return "ACTIVE";
      case M.PAUSED:
        return "PAUSED";
      case M.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.streamStateToJSON = F;
  var V;
  (function(O) {
    O[O.UDP = 0] = "UDP", O[O.TCP = 1] = "TCP", O[O.TLS = 2] = "TLS", O[O.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(V = a.CandidateProtocol || (a.CandidateProtocol = {}));
  function X(O) {
    switch (O) {
      case 0:
      case "UDP":
        return V.UDP;
      case 1:
      case "TCP":
        return V.TCP;
      case 2:
      case "TLS":
        return V.TLS;
      case -1:
      case "UNRECOGNIZED":
      default:
        return V.UNRECOGNIZED;
    }
  }
  a.candidateProtocolFromJSON = X;
  function oe(O) {
    switch (O) {
      case V.UDP:
        return "UDP";
      case V.TCP:
        return "TCP";
      case V.TLS:
        return "TLS";
      case V.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.candidateProtocolToJSON = oe;
  function Y() {
    return {
      offer: void 0,
      answer: void 0,
      trickle: void 0,
      addTrack: void 0,
      mute: void 0,
      subscription: void 0,
      trackSetting: void 0,
      leave: void 0,
      updateLayers: void 0,
      subscriptionPermission: void 0,
      syncState: void 0,
      simulate: void 0,
      ping: void 0
    };
  }
  a.SignalRequest = {
    encode(O, j = l.default.Writer.create()) {
      return O.offer !== void 0 && a.SessionDescription.encode(O.offer, j.uint32(10).fork()).ldelim(), O.answer !== void 0 && a.SessionDescription.encode(O.answer, j.uint32(18).fork()).ldelim(), O.trickle !== void 0 && a.TrickleRequest.encode(O.trickle, j.uint32(26).fork()).ldelim(), O.addTrack !== void 0 && a.AddTrackRequest.encode(O.addTrack, j.uint32(34).fork()).ldelim(), O.mute !== void 0 && a.MuteTrackRequest.encode(O.mute, j.uint32(42).fork()).ldelim(), O.subscription !== void 0 && a.UpdateSubscription.encode(O.subscription, j.uint32(50).fork()).ldelim(), O.trackSetting !== void 0 && a.UpdateTrackSettings.encode(O.trackSetting, j.uint32(58).fork()).ldelim(), O.leave !== void 0 && a.LeaveRequest.encode(O.leave, j.uint32(66).fork()).ldelim(), O.updateLayers !== void 0 && a.UpdateVideoLayers.encode(O.updateLayers, j.uint32(82).fork()).ldelim(), O.subscriptionPermission !== void 0 && a.SubscriptionPermission.encode(O.subscriptionPermission, j.uint32(90).fork()).ldelim(), O.syncState !== void 0 && a.SyncState.encode(O.syncState, j.uint32(98).fork()).ldelim(), O.simulate !== void 0 && a.SimulateScenario.encode(O.simulate, j.uint32(106).fork()).ldelim(), O.ping !== void 0 && j.uint32(112).int64(O.ping), j;
    },
    decode(O, j) {
      const ce = O instanceof l.default.Reader ? O : new l.default.Reader(O);
      let De = j === void 0 ? ce.len : ce.pos + j;
      const Ne = Y();
      for (; ce.pos < De; ) {
        const Fe = ce.uint32();
        switch (Fe >>> 3) {
          case 1:
            Ne.offer = a.SessionDescription.decode(ce, ce.uint32());
            break;
          case 2:
            Ne.answer = a.SessionDescription.decode(ce, ce.uint32());
            break;
          case 3:
            Ne.trickle = a.TrickleRequest.decode(ce, ce.uint32());
            break;
          case 4:
            Ne.addTrack = a.AddTrackRequest.decode(ce, ce.uint32());
            break;
          case 5:
            Ne.mute = a.MuteTrackRequest.decode(ce, ce.uint32());
            break;
          case 6:
            Ne.subscription = a.UpdateSubscription.decode(ce, ce.uint32());
            break;
          case 7:
            Ne.trackSetting = a.UpdateTrackSettings.decode(ce, ce.uint32());
            break;
          case 8:
            Ne.leave = a.LeaveRequest.decode(ce, ce.uint32());
            break;
          case 10:
            Ne.updateLayers = a.UpdateVideoLayers.decode(ce, ce.uint32());
            break;
          case 11:
            Ne.subscriptionPermission = a.SubscriptionPermission.decode(ce, ce.uint32());
            break;
          case 12:
            Ne.syncState = a.SyncState.decode(ce, ce.uint32());
            break;
          case 13:
            Ne.simulate = a.SimulateScenario.decode(ce, ce.uint32());
            break;
          case 14:
            Ne.ping = _e(ce.int64());
            break;
          default:
            ce.skipType(Fe & 7);
            break;
        }
      }
      return Ne;
    },
    fromJSON(O) {
      return {
        offer: re(O.offer) ? a.SessionDescription.fromJSON(O.offer) : void 0,
        answer: re(O.answer) ? a.SessionDescription.fromJSON(O.answer) : void 0,
        trickle: re(O.trickle) ? a.TrickleRequest.fromJSON(O.trickle) : void 0,
        addTrack: re(O.addTrack) ? a.AddTrackRequest.fromJSON(O.addTrack) : void 0,
        mute: re(O.mute) ? a.MuteTrackRequest.fromJSON(O.mute) : void 0,
        subscription: re(O.subscription) ? a.UpdateSubscription.fromJSON(O.subscription) : void 0,
        trackSetting: re(O.trackSetting) ? a.UpdateTrackSettings.fromJSON(O.trackSetting) : void 0,
        leave: re(O.leave) ? a.LeaveRequest.fromJSON(O.leave) : void 0,
        updateLayers: re(O.updateLayers) ? a.UpdateVideoLayers.fromJSON(O.updateLayers) : void 0,
        subscriptionPermission: re(O.subscriptionPermission) ? a.SubscriptionPermission.fromJSON(O.subscriptionPermission) : void 0,
        syncState: re(O.syncState) ? a.SyncState.fromJSON(O.syncState) : void 0,
        simulate: re(O.simulate) ? a.SimulateScenario.fromJSON(O.simulate) : void 0,
        ping: re(O.ping) ? Number(O.ping) : void 0
      };
    },
    toJSON(O) {
      const j = {};
      return O.offer !== void 0 && (j.offer = O.offer ? a.SessionDescription.toJSON(O.offer) : void 0), O.answer !== void 0 && (j.answer = O.answer ? a.SessionDescription.toJSON(O.answer) : void 0), O.trickle !== void 0 && (j.trickle = O.trickle ? a.TrickleRequest.toJSON(O.trickle) : void 0), O.addTrack !== void 0 && (j.addTrack = O.addTrack ? a.AddTrackRequest.toJSON(O.addTrack) : void 0), O.mute !== void 0 && (j.mute = O.mute ? a.MuteTrackRequest.toJSON(O.mute) : void 0), O.subscription !== void 0 && (j.subscription = O.subscription ? a.UpdateSubscription.toJSON(O.subscription) : void 0), O.trackSetting !== void 0 && (j.trackSetting = O.trackSetting ? a.UpdateTrackSettings.toJSON(O.trackSetting) : void 0), O.leave !== void 0 && (j.leave = O.leave ? a.LeaveRequest.toJSON(O.leave) : void 0), O.updateLayers !== void 0 && (j.updateLayers = O.updateLayers ? a.UpdateVideoLayers.toJSON(O.updateLayers) : void 0), O.subscriptionPermission !== void 0 && (j.subscriptionPermission = O.subscriptionPermission ? a.SubscriptionPermission.toJSON(O.subscriptionPermission) : void 0), O.syncState !== void 0 && (j.syncState = O.syncState ? a.SyncState.toJSON(O.syncState) : void 0), O.simulate !== void 0 && (j.simulate = O.simulate ? a.SimulateScenario.toJSON(O.simulate) : void 0), O.ping !== void 0 && (j.ping = Math.round(O.ping)), j;
    },
    fromPartial(O) {
      var j;
      const ce = Y();
      return ce.offer = O.offer !== void 0 && O.offer !== null ? a.SessionDescription.fromPartial(O.offer) : void 0, ce.answer = O.answer !== void 0 && O.answer !== null ? a.SessionDescription.fromPartial(O.answer) : void 0, ce.trickle = O.trickle !== void 0 && O.trickle !== null ? a.TrickleRequest.fromPartial(O.trickle) : void 0, ce.addTrack = O.addTrack !== void 0 && O.addTrack !== null ? a.AddTrackRequest.fromPartial(O.addTrack) : void 0, ce.mute = O.mute !== void 0 && O.mute !== null ? a.MuteTrackRequest.fromPartial(O.mute) : void 0, ce.subscription = O.subscription !== void 0 && O.subscription !== null ? a.UpdateSubscription.fromPartial(O.subscription) : void 0, ce.trackSetting = O.trackSetting !== void 0 && O.trackSetting !== null ? a.UpdateTrackSettings.fromPartial(O.trackSetting) : void 0, ce.leave = O.leave !== void 0 && O.leave !== null ? a.LeaveRequest.fromPartial(O.leave) : void 0, ce.updateLayers = O.updateLayers !== void 0 && O.updateLayers !== null ? a.UpdateVideoLayers.fromPartial(O.updateLayers) : void 0, ce.subscriptionPermission = O.subscriptionPermission !== void 0 && O.subscriptionPermission !== null ? a.SubscriptionPermission.fromPartial(O.subscriptionPermission) : void 0, ce.syncState = O.syncState !== void 0 && O.syncState !== null ? a.SyncState.fromPartial(O.syncState) : void 0, ce.simulate = O.simulate !== void 0 && O.simulate !== null ? a.SimulateScenario.fromPartial(O.simulate) : void 0, ce.ping = (j = O.ping) !== null && j !== void 0 ? j : void 0, ce;
    }
  };
  function ae() {
    return {
      join: void 0,
      answer: void 0,
      offer: void 0,
      trickle: void 0,
      update: void 0,
      trackPublished: void 0,
      leave: void 0,
      mute: void 0,
      speakersChanged: void 0,
      roomUpdate: void 0,
      connectionQuality: void 0,
      streamStateUpdate: void 0,
      subscribedQualityUpdate: void 0,
      subscriptionPermissionUpdate: void 0,
      refreshToken: void 0,
      trackUnpublished: void 0,
      pong: void 0
    };
  }
  a.SignalResponse = {
    encode(O, j = l.default.Writer.create()) {
      return O.join !== void 0 && a.JoinResponse.encode(O.join, j.uint32(10).fork()).ldelim(), O.answer !== void 0 && a.SessionDescription.encode(O.answer, j.uint32(18).fork()).ldelim(), O.offer !== void 0 && a.SessionDescription.encode(O.offer, j.uint32(26).fork()).ldelim(), O.trickle !== void 0 && a.TrickleRequest.encode(O.trickle, j.uint32(34).fork()).ldelim(), O.update !== void 0 && a.ParticipantUpdate.encode(O.update, j.uint32(42).fork()).ldelim(), O.trackPublished !== void 0 && a.TrackPublishedResponse.encode(O.trackPublished, j.uint32(50).fork()).ldelim(), O.leave !== void 0 && a.LeaveRequest.encode(O.leave, j.uint32(66).fork()).ldelim(), O.mute !== void 0 && a.MuteTrackRequest.encode(O.mute, j.uint32(74).fork()).ldelim(), O.speakersChanged !== void 0 && a.SpeakersChanged.encode(O.speakersChanged, j.uint32(82).fork()).ldelim(), O.roomUpdate !== void 0 && a.RoomUpdate.encode(O.roomUpdate, j.uint32(90).fork()).ldelim(), O.connectionQuality !== void 0 && a.ConnectionQualityUpdate.encode(O.connectionQuality, j.uint32(98).fork()).ldelim(), O.streamStateUpdate !== void 0 && a.StreamStateUpdate.encode(O.streamStateUpdate, j.uint32(106).fork()).ldelim(), O.subscribedQualityUpdate !== void 0 && a.SubscribedQualityUpdate.encode(O.subscribedQualityUpdate, j.uint32(114).fork()).ldelim(), O.subscriptionPermissionUpdate !== void 0 && a.SubscriptionPermissionUpdate.encode(O.subscriptionPermissionUpdate, j.uint32(122).fork()).ldelim(), O.refreshToken !== void 0 && j.uint32(130).string(O.refreshToken), O.trackUnpublished !== void 0 && a.TrackUnpublishedResponse.encode(O.trackUnpublished, j.uint32(138).fork()).ldelim(), O.pong !== void 0 && j.uint32(144).int64(O.pong), j;
    },
    decode(O, j) {
      const ce = O instanceof l.default.Reader ? O : new l.default.Reader(O);
      let De = j === void 0 ? ce.len : ce.pos + j;
      const Ne = ae();
      for (; ce.pos < De; ) {
        const Fe = ce.uint32();
        switch (Fe >>> 3) {
          case 1:
            Ne.join = a.JoinResponse.decode(ce, ce.uint32());
            break;
          case 2:
            Ne.answer = a.SessionDescription.decode(ce, ce.uint32());
            break;
          case 3:
            Ne.offer = a.SessionDescription.decode(ce, ce.uint32());
            break;
          case 4:
            Ne.trickle = a.TrickleRequest.decode(ce, ce.uint32());
            break;
          case 5:
            Ne.update = a.ParticipantUpdate.decode(ce, ce.uint32());
            break;
          case 6:
            Ne.trackPublished = a.TrackPublishedResponse.decode(ce, ce.uint32());
            break;
          case 8:
            Ne.leave = a.LeaveRequest.decode(ce, ce.uint32());
            break;
          case 9:
            Ne.mute = a.MuteTrackRequest.decode(ce, ce.uint32());
            break;
          case 10:
            Ne.speakersChanged = a.SpeakersChanged.decode(ce, ce.uint32());
            break;
          case 11:
            Ne.roomUpdate = a.RoomUpdate.decode(ce, ce.uint32());
            break;
          case 12:
            Ne.connectionQuality = a.ConnectionQualityUpdate.decode(ce, ce.uint32());
            break;
          case 13:
            Ne.streamStateUpdate = a.StreamStateUpdate.decode(ce, ce.uint32());
            break;
          case 14:
            Ne.subscribedQualityUpdate = a.SubscribedQualityUpdate.decode(ce, ce.uint32());
            break;
          case 15:
            Ne.subscriptionPermissionUpdate = a.SubscriptionPermissionUpdate.decode(ce, ce.uint32());
            break;
          case 16:
            Ne.refreshToken = ce.string();
            break;
          case 17:
            Ne.trackUnpublished = a.TrackUnpublishedResponse.decode(ce, ce.uint32());
            break;
          case 18:
            Ne.pong = _e(ce.int64());
            break;
          default:
            ce.skipType(Fe & 7);
            break;
        }
      }
      return Ne;
    },
    fromJSON(O) {
      return {
        join: re(O.join) ? a.JoinResponse.fromJSON(O.join) : void 0,
        answer: re(O.answer) ? a.SessionDescription.fromJSON(O.answer) : void 0,
        offer: re(O.offer) ? a.SessionDescription.fromJSON(O.offer) : void 0,
        trickle: re(O.trickle) ? a.TrickleRequest.fromJSON(O.trickle) : void 0,
        update: re(O.update) ? a.ParticipantUpdate.fromJSON(O.update) : void 0,
        trackPublished: re(O.trackPublished) ? a.TrackPublishedResponse.fromJSON(O.trackPublished) : void 0,
        leave: re(O.leave) ? a.LeaveRequest.fromJSON(O.leave) : void 0,
        mute: re(O.mute) ? a.MuteTrackRequest.fromJSON(O.mute) : void 0,
        speakersChanged: re(O.speakersChanged) ? a.SpeakersChanged.fromJSON(O.speakersChanged) : void 0,
        roomUpdate: re(O.roomUpdate) ? a.RoomUpdate.fromJSON(O.roomUpdate) : void 0,
        connectionQuality: re(O.connectionQuality) ? a.ConnectionQualityUpdate.fromJSON(O.connectionQuality) : void 0,
        streamStateUpdate: re(O.streamStateUpdate) ? a.StreamStateUpdate.fromJSON(O.streamStateUpdate) : void 0,
        subscribedQualityUpdate: re(O.subscribedQualityUpdate) ? a.SubscribedQualityUpdate.fromJSON(O.subscribedQualityUpdate) : void 0,
        subscriptionPermissionUpdate: re(O.subscriptionPermissionUpdate) ? a.SubscriptionPermissionUpdate.fromJSON(O.subscriptionPermissionUpdate) : void 0,
        refreshToken: re(O.refreshToken) ? String(O.refreshToken) : void 0,
        trackUnpublished: re(O.trackUnpublished) ? a.TrackUnpublishedResponse.fromJSON(O.trackUnpublished) : void 0,
        pong: re(O.pong) ? Number(O.pong) : void 0
      };
    },
    toJSON(O) {
      const j = {};
      return O.join !== void 0 && (j.join = O.join ? a.JoinResponse.toJSON(O.join) : void 0), O.answer !== void 0 && (j.answer = O.answer ? a.SessionDescription.toJSON(O.answer) : void 0), O.offer !== void 0 && (j.offer = O.offer ? a.SessionDescription.toJSON(O.offer) : void 0), O.trickle !== void 0 && (j.trickle = O.trickle ? a.TrickleRequest.toJSON(O.trickle) : void 0), O.update !== void 0 && (j.update = O.update ? a.ParticipantUpdate.toJSON(O.update) : void 0), O.trackPublished !== void 0 && (j.trackPublished = O.trackPublished ? a.TrackPublishedResponse.toJSON(O.trackPublished) : void 0), O.leave !== void 0 && (j.leave = O.leave ? a.LeaveRequest.toJSON(O.leave) : void 0), O.mute !== void 0 && (j.mute = O.mute ? a.MuteTrackRequest.toJSON(O.mute) : void 0), O.speakersChanged !== void 0 && (j.speakersChanged = O.speakersChanged ? a.SpeakersChanged.toJSON(O.speakersChanged) : void 0), O.roomUpdate !== void 0 && (j.roomUpdate = O.roomUpdate ? a.RoomUpdate.toJSON(O.roomUpdate) : void 0), O.connectionQuality !== void 0 && (j.connectionQuality = O.connectionQuality ? a.ConnectionQualityUpdate.toJSON(O.connectionQuality) : void 0), O.streamStateUpdate !== void 0 && (j.streamStateUpdate = O.streamStateUpdate ? a.StreamStateUpdate.toJSON(O.streamStateUpdate) : void 0), O.subscribedQualityUpdate !== void 0 && (j.subscribedQualityUpdate = O.subscribedQualityUpdate ? a.SubscribedQualityUpdate.toJSON(O.subscribedQualityUpdate) : void 0), O.subscriptionPermissionUpdate !== void 0 && (j.subscriptionPermissionUpdate = O.subscriptionPermissionUpdate ? a.SubscriptionPermissionUpdate.toJSON(O.subscriptionPermissionUpdate) : void 0), O.refreshToken !== void 0 && (j.refreshToken = O.refreshToken), O.trackUnpublished !== void 0 && (j.trackUnpublished = O.trackUnpublished ? a.TrackUnpublishedResponse.toJSON(O.trackUnpublished) : void 0), O.pong !== void 0 && (j.pong = Math.round(O.pong)), j;
    },
    fromPartial(O) {
      var j, ce;
      const De = ae();
      return De.join = O.join !== void 0 && O.join !== null ? a.JoinResponse.fromPartial(O.join) : void 0, De.answer = O.answer !== void 0 && O.answer !== null ? a.SessionDescription.fromPartial(O.answer) : void 0, De.offer = O.offer !== void 0 && O.offer !== null ? a.SessionDescription.fromPartial(O.offer) : void 0, De.trickle = O.trickle !== void 0 && O.trickle !== null ? a.TrickleRequest.fromPartial(O.trickle) : void 0, De.update = O.update !== void 0 && O.update !== null ? a.ParticipantUpdate.fromPartial(O.update) : void 0, De.trackPublished = O.trackPublished !== void 0 && O.trackPublished !== null ? a.TrackPublishedResponse.fromPartial(O.trackPublished) : void 0, De.leave = O.leave !== void 0 && O.leave !== null ? a.LeaveRequest.fromPartial(O.leave) : void 0, De.mute = O.mute !== void 0 && O.mute !== null ? a.MuteTrackRequest.fromPartial(O.mute) : void 0, De.speakersChanged = O.speakersChanged !== void 0 && O.speakersChanged !== null ? a.SpeakersChanged.fromPartial(O.speakersChanged) : void 0, De.roomUpdate = O.roomUpdate !== void 0 && O.roomUpdate !== null ? a.RoomUpdate.fromPartial(O.roomUpdate) : void 0, De.connectionQuality = O.connectionQuality !== void 0 && O.connectionQuality !== null ? a.ConnectionQualityUpdate.fromPartial(O.connectionQuality) : void 0, De.streamStateUpdate = O.streamStateUpdate !== void 0 && O.streamStateUpdate !== null ? a.StreamStateUpdate.fromPartial(O.streamStateUpdate) : void 0, De.subscribedQualityUpdate = O.subscribedQualityUpdate !== void 0 && O.subscribedQualityUpdate !== null ? a.SubscribedQualityUpdate.fromPartial(O.subscribedQualityUpdate) : void 0, De.subscriptionPermissionUpdate = O.subscriptionPermissionUpdate !== void 0 && O.subscriptionPermissionUpdate !== null ? a.SubscriptionPermissionUpdate.fromPartial(O.subscriptionPermissionUpdate) : void 0, De.refreshToken = (j = O.refreshToken) !== null && j !== void 0 ? j : void 0, De.trackUnpublished = O.trackUnpublished !== void 0 && O.trackUnpublished !== null ? a.TrackUnpublishedResponse.fromPartial(O.trackUnpublished) : void 0, De.pong = (ce = O.pong) !== null && ce !== void 0 ? ce : void 0, De;
    }
  };
  function ne() {
    return { codec: "", cid: "", enableSimulcastLayers: !1 };
  }
  a.SimulcastCodec = {
    encode(O, j = l.default.Writer.create()) {
      return O.codec !== void 0 && O.codec !== "" && j.uint32(10).string(O.codec), O.cid !== void 0 && O.cid !== "" && j.uint32(18).string(O.cid), O.enableSimulcastLayers === !0 && j.uint32(24).bool(O.enableSimulcastLayers), j;
    },
    decode(O, j) {
      const ce = O instanceof l.default.Reader ? O : new l.default.Reader(O);
      let De = j === void 0 ? ce.len : ce.pos + j;
      const Ne = ne();
      for (; ce.pos < De; ) {
        const Fe = ce.uint32();
        switch (Fe >>> 3) {
          case 1:
            Ne.codec = ce.string();
            break;
          case 2:
            Ne.cid = ce.string();
            break;
          case 3:
            Ne.enableSimulcastLayers = ce.bool();
            break;
          default:
            ce.skipType(Fe & 7);
            break;
        }
      }
      return Ne;
    },
    fromJSON(O) {
      return {
        codec: re(O.codec) ? String(O.codec) : "",
        cid: re(O.cid) ? String(O.cid) : "",
        enableSimulcastLayers: re(O.enableSimulcastLayers) ? !!O.enableSimulcastLayers : !1
      };
    },
    toJSON(O) {
      const j = {};
      return O.codec !== void 0 && (j.codec = O.codec), O.cid !== void 0 && (j.cid = O.cid), O.enableSimulcastLayers !== void 0 && (j.enableSimulcastLayers = O.enableSimulcastLayers), j;
    },
    fromPartial(O) {
      var j, ce, De;
      const Ne = ne();
      return Ne.codec = (j = O.codec) !== null && j !== void 0 ? j : "", Ne.cid = (ce = O.cid) !== null && ce !== void 0 ? ce : "", Ne.enableSimulcastLayers = (De = O.enableSimulcastLayers) !== null && De !== void 0 ? De : !1, Ne;
    }
  };
  function fe() {
    return {
      cid: "",
      name: "",
      type: 0,
      width: 0,
      height: 0,
      muted: !1,
      disableDtx: !1,
      source: 0,
      layers: [],
      simulcastCodecs: [],
      sid: "",
      stereo: !1,
      disableRed: !1
    };
  }
  a.AddTrackRequest = {
    encode(O, j = l.default.Writer.create()) {
      if (O.cid !== void 0 && O.cid !== "" && j.uint32(10).string(O.cid), O.name !== void 0 && O.name !== "" && j.uint32(18).string(O.name), O.type !== void 0 && O.type !== 0 && j.uint32(24).int32(O.type), O.width !== void 0 && O.width !== 0 && j.uint32(32).uint32(O.width), O.height !== void 0 && O.height !== 0 && j.uint32(40).uint32(O.height), O.muted === !0 && j.uint32(48).bool(O.muted), O.disableDtx === !0 && j.uint32(56).bool(O.disableDtx), O.source !== void 0 && O.source !== 0 && j.uint32(64).int32(O.source), O.layers !== void 0 && O.layers.length !== 0)
        for (const ce of O.layers)
          v.VideoLayer.encode(ce, j.uint32(74).fork()).ldelim();
      if (O.simulcastCodecs !== void 0 && O.simulcastCodecs.length !== 0)
        for (const ce of O.simulcastCodecs)
          a.SimulcastCodec.encode(ce, j.uint32(82).fork()).ldelim();
      return O.sid !== void 0 && O.sid !== "" && j.uint32(90).string(O.sid), O.stereo === !0 && j.uint32(96).bool(O.stereo), O.disableRed === !0 && j.uint32(104).bool(O.disableRed), j;
    },
    decode(O, j) {
      const ce = O instanceof l.default.Reader ? O : new l.default.Reader(O);
      let De = j === void 0 ? ce.len : ce.pos + j;
      const Ne = fe();
      for (; ce.pos < De; ) {
        const Fe = ce.uint32();
        switch (Fe >>> 3) {
          case 1:
            Ne.cid = ce.string();
            break;
          case 2:
            Ne.name = ce.string();
            break;
          case 3:
            Ne.type = ce.int32();
            break;
          case 4:
            Ne.width = ce.uint32();
            break;
          case 5:
            Ne.height = ce.uint32();
            break;
          case 6:
            Ne.muted = ce.bool();
            break;
          case 7:
            Ne.disableDtx = ce.bool();
            break;
          case 8:
            Ne.source = ce.int32();
            break;
          case 9:
            Ne.layers.push(v.VideoLayer.decode(ce, ce.uint32()));
            break;
          case 10:
            Ne.simulcastCodecs.push(a.SimulcastCodec.decode(ce, ce.uint32()));
            break;
          case 11:
            Ne.sid = ce.string();
            break;
          case 12:
            Ne.stereo = ce.bool();
            break;
          case 13:
            Ne.disableRed = ce.bool();
            break;
          default:
            ce.skipType(Fe & 7);
            break;
        }
      }
      return Ne;
    },
    fromJSON(O) {
      return {
        cid: re(O.cid) ? String(O.cid) : "",
        name: re(O.name) ? String(O.name) : "",
        type: re(O.type) ? v.trackTypeFromJSON(O.type) : 0,
        width: re(O.width) ? Number(O.width) : 0,
        height: re(O.height) ? Number(O.height) : 0,
        muted: re(O.muted) ? !!O.muted : !1,
        disableDtx: re(O.disableDtx) ? !!O.disableDtx : !1,
        source: re(O.source) ? v.trackSourceFromJSON(O.source) : 0,
        layers: Array.isArray(O == null ? void 0 : O.layers) ? O.layers.map((j) => v.VideoLayer.fromJSON(j)) : [],
        simulcastCodecs: Array.isArray(O == null ? void 0 : O.simulcastCodecs) ? O.simulcastCodecs.map((j) => a.SimulcastCodec.fromJSON(j)) : [],
        sid: re(O.sid) ? String(O.sid) : "",
        stereo: re(O.stereo) ? !!O.stereo : !1,
        disableRed: re(O.disableRed) ? !!O.disableRed : !1
      };
    },
    toJSON(O) {
      const j = {};
      return O.cid !== void 0 && (j.cid = O.cid), O.name !== void 0 && (j.name = O.name), O.type !== void 0 && (j.type = v.trackTypeToJSON(O.type)), O.width !== void 0 && (j.width = Math.round(O.width)), O.height !== void 0 && (j.height = Math.round(O.height)), O.muted !== void 0 && (j.muted = O.muted), O.disableDtx !== void 0 && (j.disableDtx = O.disableDtx), O.source !== void 0 && (j.source = v.trackSourceToJSON(O.source)), O.layers ? j.layers = O.layers.map((ce) => ce ? v.VideoLayer.toJSON(ce) : void 0) : j.layers = [], O.simulcastCodecs ? j.simulcastCodecs = O.simulcastCodecs.map((ce) => ce ? a.SimulcastCodec.toJSON(ce) : void 0) : j.simulcastCodecs = [], O.sid !== void 0 && (j.sid = O.sid), O.stereo !== void 0 && (j.stereo = O.stereo), O.disableRed !== void 0 && (j.disableRed = O.disableRed), j;
    },
    fromPartial(O) {
      var j, ce, De, Ne, Fe, Ze, qe, gt, Xe, Ge, J, ye, we;
      const We = fe();
      return We.cid = (j = O.cid) !== null && j !== void 0 ? j : "", We.name = (ce = O.name) !== null && ce !== void 0 ? ce : "", We.type = (De = O.type) !== null && De !== void 0 ? De : 0, We.width = (Ne = O.width) !== null && Ne !== void 0 ? Ne : 0, We.height = (Fe = O.height) !== null && Fe !== void 0 ? Fe : 0, We.muted = (Ze = O.muted) !== null && Ze !== void 0 ? Ze : !1, We.disableDtx = (qe = O.disableDtx) !== null && qe !== void 0 ? qe : !1, We.source = (gt = O.source) !== null && gt !== void 0 ? gt : 0, We.layers = ((Xe = O.layers) === null || Xe === void 0 ? void 0 : Xe.map((Re) => v.VideoLayer.fromPartial(Re))) || [], We.simulcastCodecs = ((Ge = O.simulcastCodecs) === null || Ge === void 0 ? void 0 : Ge.map((Re) => a.SimulcastCodec.fromPartial(Re))) || [], We.sid = (J = O.sid) !== null && J !== void 0 ? J : "", We.stereo = (ye = O.stereo) !== null && ye !== void 0 ? ye : !1, We.disableRed = (we = O.disableRed) !== null && we !== void 0 ? we : !1, We;
    }
  };
  function ie() {
    return { candidateInit: "", target: 0 };
  }
  a.TrickleRequest = {
    encode(O, j = l.default.Writer.create()) {
      return O.candidateInit !== void 0 && O.candidateInit !== "" && j.uint32(10).string(O.candidateInit), O.target !== void 0 && O.target !== 0 && j.uint32(16).int32(O.target), j;
    },
    decode(O, j) {
      const ce = O instanceof l.default.Reader ? O : new l.default.Reader(O);
      let De = j === void 0 ? ce.len : ce.pos + j;
      const Ne = ie();
      for (; ce.pos < De; ) {
        const Fe = ce.uint32();
        switch (Fe >>> 3) {
          case 1:
            Ne.candidateInit = ce.string();
            break;
          case 2:
            Ne.target = ce.int32();
            break;
          default:
            ce.skipType(Fe & 7);
            break;
        }
      }
      return Ne;
    },
    fromJSON(O) {
      return {
        candidateInit: re(O.candidateInit) ? String(O.candidateInit) : "",
        target: re(O.target) ? _(O.target) : 0
      };
    },
    toJSON(O) {
      const j = {};
      return O.candidateInit !== void 0 && (j.candidateInit = O.candidateInit), O.target !== void 0 && (j.target = k(O.target)), j;
    },
    fromPartial(O) {
      var j, ce;
      const De = ie();
      return De.candidateInit = (j = O.candidateInit) !== null && j !== void 0 ? j : "", De.target = (ce = O.target) !== null && ce !== void 0 ? ce : 0, De;
    }
  };
  function ge() {
    return { sid: "", muted: !1 };
  }
  a.MuteTrackRequest = {
    encode(O, j = l.default.Writer.create()) {
      return O.sid !== void 0 && O.sid !== "" && j.uint32(10).string(O.sid), O.muted === !0 && j.uint32(16).bool(O.muted), j;
    },
    decode(O, j) {
      const ce = O instanceof l.default.Reader ? O : new l.default.Reader(O);
      let De = j === void 0 ? ce.len : ce.pos + j;
      const Ne = ge();
      for (; ce.pos < De; ) {
        const Fe = ce.uint32();
        switch (Fe >>> 3) {
          case 1:
            Ne.sid = ce.string();
            break;
          case 2:
            Ne.muted = ce.bool();
            break;
          default:
            ce.skipType(Fe & 7);
            break;
        }
      }
      return Ne;
    },
    fromJSON(O) {
      return {
        sid: re(O.sid) ? String(O.sid) : "",
        muted: re(O.muted) ? !!O.muted : !1
      };
    },
    toJSON(O) {
      const j = {};
      return O.sid !== void 0 && (j.sid = O.sid), O.muted !== void 0 && (j.muted = O.muted), j;
    },
    fromPartial(O) {
      var j, ce;
      const De = ge();
      return De.sid = (j = O.sid) !== null && j !== void 0 ? j : "", De.muted = (ce = O.muted) !== null && ce !== void 0 ? ce : !1, De;
    }
  };
  function be() {
    return {
      room: void 0,
      participant: void 0,
      otherParticipants: [],
      serverVersion: "",
      iceServers: [],
      subscriberPrimary: !1,
      alternativeUrl: "",
      clientConfiguration: void 0,
      serverRegion: "",
      pingTimeout: 0,
      pingInterval: 0,
      serverInfo: void 0
    };
  }
  a.JoinResponse = {
    encode(O, j = l.default.Writer.create()) {
      if (O.room !== void 0 && v.Room.encode(O.room, j.uint32(10).fork()).ldelim(), O.participant !== void 0 && v.ParticipantInfo.encode(O.participant, j.uint32(18).fork()).ldelim(), O.otherParticipants !== void 0 && O.otherParticipants.length !== 0)
        for (const ce of O.otherParticipants)
          v.ParticipantInfo.encode(ce, j.uint32(26).fork()).ldelim();
      if (O.serverVersion !== void 0 && O.serverVersion !== "" && j.uint32(34).string(O.serverVersion), O.iceServers !== void 0 && O.iceServers.length !== 0)
        for (const ce of O.iceServers)
          a.ICEServer.encode(ce, j.uint32(42).fork()).ldelim();
      return O.subscriberPrimary === !0 && j.uint32(48).bool(O.subscriberPrimary), O.alternativeUrl !== void 0 && O.alternativeUrl !== "" && j.uint32(58).string(O.alternativeUrl), O.clientConfiguration !== void 0 && v.ClientConfiguration.encode(O.clientConfiguration, j.uint32(66).fork()).ldelim(), O.serverRegion !== void 0 && O.serverRegion !== "" && j.uint32(74).string(O.serverRegion), O.pingTimeout !== void 0 && O.pingTimeout !== 0 && j.uint32(80).int32(O.pingTimeout), O.pingInterval !== void 0 && O.pingInterval !== 0 && j.uint32(88).int32(O.pingInterval), O.serverInfo !== void 0 && v.ServerInfo.encode(O.serverInfo, j.uint32(98).fork()).ldelim(), j;
    },
    decode(O, j) {
      const ce = O instanceof l.default.Reader ? O : new l.default.Reader(O);
      let De = j === void 0 ? ce.len : ce.pos + j;
      const Ne = be();
      for (; ce.pos < De; ) {
        const Fe = ce.uint32();
        switch (Fe >>> 3) {
          case 1:
            Ne.room = v.Room.decode(ce, ce.uint32());
            break;
          case 2:
            Ne.participant = v.ParticipantInfo.decode(ce, ce.uint32());
            break;
          case 3:
            Ne.otherParticipants.push(v.ParticipantInfo.decode(ce, ce.uint32()));
            break;
          case 4:
            Ne.serverVersion = ce.string();
            break;
          case 5:
            Ne.iceServers.push(a.ICEServer.decode(ce, ce.uint32()));
            break;
          case 6:
            Ne.subscriberPrimary = ce.bool();
            break;
          case 7:
            Ne.alternativeUrl = ce.string();
            break;
          case 8:
            Ne.clientConfiguration = v.ClientConfiguration.decode(ce, ce.uint32());
            break;
          case 9:
            Ne.serverRegion = ce.string();
            break;
          case 10:
            Ne.pingTimeout = ce.int32();
            break;
          case 11:
            Ne.pingInterval = ce.int32();
            break;
          case 12:
            Ne.serverInfo = v.ServerInfo.decode(ce, ce.uint32());
            break;
          default:
            ce.skipType(Fe & 7);
            break;
        }
      }
      return Ne;
    },
    fromJSON(O) {
      return {
        room: re(O.room) ? v.Room.fromJSON(O.room) : void 0,
        participant: re(O.participant) ? v.ParticipantInfo.fromJSON(O.participant) : void 0,
        otherParticipants: Array.isArray(O == null ? void 0 : O.otherParticipants) ? O.otherParticipants.map((j) => v.ParticipantInfo.fromJSON(j)) : [],
        serverVersion: re(O.serverVersion) ? String(O.serverVersion) : "",
        iceServers: Array.isArray(O == null ? void 0 : O.iceServers) ? O.iceServers.map((j) => a.ICEServer.fromJSON(j)) : [],
        subscriberPrimary: re(O.subscriberPrimary) ? !!O.subscriberPrimary : !1,
        alternativeUrl: re(O.alternativeUrl) ? String(O.alternativeUrl) : "",
        clientConfiguration: re(O.clientConfiguration) ? v.ClientConfiguration.fromJSON(O.clientConfiguration) : void 0,
        serverRegion: re(O.serverRegion) ? String(O.serverRegion) : "",
        pingTimeout: re(O.pingTimeout) ? Number(O.pingTimeout) : 0,
        pingInterval: re(O.pingInterval) ? Number(O.pingInterval) : 0,
        serverInfo: re(O.serverInfo) ? v.ServerInfo.fromJSON(O.serverInfo) : void 0
      };
    },
    toJSON(O) {
      const j = {};
      return O.room !== void 0 && (j.room = O.room ? v.Room.toJSON(O.room) : void 0), O.participant !== void 0 && (j.participant = O.participant ? v.ParticipantInfo.toJSON(O.participant) : void 0), O.otherParticipants ? j.otherParticipants = O.otherParticipants.map((ce) => ce ? v.ParticipantInfo.toJSON(ce) : void 0) : j.otherParticipants = [], O.serverVersion !== void 0 && (j.serverVersion = O.serverVersion), O.iceServers ? j.iceServers = O.iceServers.map((ce) => ce ? a.ICEServer.toJSON(ce) : void 0) : j.iceServers = [], O.subscriberPrimary !== void 0 && (j.subscriberPrimary = O.subscriberPrimary), O.alternativeUrl !== void 0 && (j.alternativeUrl = O.alternativeUrl), O.clientConfiguration !== void 0 && (j.clientConfiguration = O.clientConfiguration ? v.ClientConfiguration.toJSON(O.clientConfiguration) : void 0), O.serverRegion !== void 0 && (j.serverRegion = O.serverRegion), O.pingTimeout !== void 0 && (j.pingTimeout = Math.round(O.pingTimeout)), O.pingInterval !== void 0 && (j.pingInterval = Math.round(O.pingInterval)), O.serverInfo !== void 0 && (j.serverInfo = O.serverInfo ? v.ServerInfo.toJSON(O.serverInfo) : void 0), j;
    },
    fromPartial(O) {
      var j, ce, De, Ne, Fe, Ze, qe, gt;
      const Xe = be();
      return Xe.room = O.room !== void 0 && O.room !== null ? v.Room.fromPartial(O.room) : void 0, Xe.participant = O.participant !== void 0 && O.participant !== null ? v.ParticipantInfo.fromPartial(O.participant) : void 0, Xe.otherParticipants = ((j = O.otherParticipants) === null || j === void 0 ? void 0 : j.map((Ge) => v.ParticipantInfo.fromPartial(Ge))) || [], Xe.serverVersion = (ce = O.serverVersion) !== null && ce !== void 0 ? ce : "", Xe.iceServers = ((De = O.iceServers) === null || De === void 0 ? void 0 : De.map((Ge) => a.ICEServer.fromPartial(Ge))) || [], Xe.subscriberPrimary = (Ne = O.subscriberPrimary) !== null && Ne !== void 0 ? Ne : !1, Xe.alternativeUrl = (Fe = O.alternativeUrl) !== null && Fe !== void 0 ? Fe : "", Xe.clientConfiguration = O.clientConfiguration !== void 0 && O.clientConfiguration !== null ? v.ClientConfiguration.fromPartial(O.clientConfiguration) : void 0, Xe.serverRegion = (Ze = O.serverRegion) !== null && Ze !== void 0 ? Ze : "", Xe.pingTimeout = (qe = O.pingTimeout) !== null && qe !== void 0 ? qe : 0, Xe.pingInterval = (gt = O.pingInterval) !== null && gt !== void 0 ? gt : 0, Xe.serverInfo = O.serverInfo !== void 0 && O.serverInfo !== null ? v.ServerInfo.fromPartial(O.serverInfo) : void 0, Xe;
    }
  };
  function Ce() {
    return { cid: "", track: void 0 };
  }
  a.TrackPublishedResponse = {
    encode(O, j = l.default.Writer.create()) {
      return O.cid !== void 0 && O.cid !== "" && j.uint32(10).string(O.cid), O.track !== void 0 && v.TrackInfo.encode(O.track, j.uint32(18).fork()).ldelim(), j;
    },
    decode(O, j) {
      const ce = O instanceof l.default.Reader ? O : new l.default.Reader(O);
      let De = j === void 0 ? ce.len : ce.pos + j;
      const Ne = Ce();
      for (; ce.pos < De; ) {
        const Fe = ce.uint32();
        switch (Fe >>> 3) {
          case 1:
            Ne.cid = ce.string();
            break;
          case 2:
            Ne.track = v.TrackInfo.decode(ce, ce.uint32());
            break;
          default:
            ce.skipType(Fe & 7);
            break;
        }
      }
      return Ne;
    },
    fromJSON(O) {
      return {
        cid: re(O.cid) ? String(O.cid) : "",
        track: re(O.track) ? v.TrackInfo.fromJSON(O.track) : void 0
      };
    },
    toJSON(O) {
      const j = {};
      return O.cid !== void 0 && (j.cid = O.cid), O.track !== void 0 && (j.track = O.track ? v.TrackInfo.toJSON(O.track) : void 0), j;
    },
    fromPartial(O) {
      var j;
      const ce = Ce();
      return ce.cid = (j = O.cid) !== null && j !== void 0 ? j : "", ce.track = O.track !== void 0 && O.track !== null ? v.TrackInfo.fromPartial(O.track) : void 0, ce;
    }
  };
  function Me() {
    return { trackSid: "" };
  }
  a.TrackUnpublishedResponse = {
    encode(O, j = l.default.Writer.create()) {
      return O.trackSid !== void 0 && O.trackSid !== "" && j.uint32(10).string(O.trackSid), j;
    },
    decode(O, j) {
      const ce = O instanceof l.default.Reader ? O : new l.default.Reader(O);
      let De = j === void 0 ? ce.len : ce.pos + j;
      const Ne = Me();
      for (; ce.pos < De; ) {
        const Fe = ce.uint32();
        switch (Fe >>> 3) {
          case 1:
            Ne.trackSid = ce.string();
            break;
          default:
            ce.skipType(Fe & 7);
            break;
        }
      }
      return Ne;
    },
    fromJSON(O) {
      return { trackSid: re(O.trackSid) ? String(O.trackSid) : "" };
    },
    toJSON(O) {
      const j = {};
      return O.trackSid !== void 0 && (j.trackSid = O.trackSid), j;
    },
    fromPartial(O) {
      var j;
      const ce = Me();
      return ce.trackSid = (j = O.trackSid) !== null && j !== void 0 ? j : "", ce;
    }
  };
  function Be() {
    return { type: "", sdp: "" };
  }
  a.SessionDescription = {
    encode(O, j = l.default.Writer.create()) {
      return O.type !== void 0 && O.type !== "" && j.uint32(10).string(O.type), O.sdp !== void 0 && O.sdp !== "" && j.uint32(18).string(O.sdp), j;
    },
    decode(O, j) {
      const ce = O instanceof l.default.Reader ? O : new l.default.Reader(O);
      let De = j === void 0 ? ce.len : ce.pos + j;
      const Ne = Be();
      for (; ce.pos < De; ) {
        const Fe = ce.uint32();
        switch (Fe >>> 3) {
          case 1:
            Ne.type = ce.string();
            break;
          case 2:
            Ne.sdp = ce.string();
            break;
          default:
            ce.skipType(Fe & 7);
            break;
        }
      }
      return Ne;
    },
    fromJSON(O) {
      return { type: re(O.type) ? String(O.type) : "", sdp: re(O.sdp) ? String(O.sdp) : "" };
    },
    toJSON(O) {
      const j = {};
      return O.type !== void 0 && (j.type = O.type), O.sdp !== void 0 && (j.sdp = O.sdp), j;
    },
    fromPartial(O) {
      var j, ce;
      const De = Be();
      return De.type = (j = O.type) !== null && j !== void 0 ? j : "", De.sdp = (ce = O.sdp) !== null && ce !== void 0 ? ce : "", De;
    }
  };
  function Ae() {
    return { participants: [] };
  }
  a.ParticipantUpdate = {
    encode(O, j = l.default.Writer.create()) {
      if (O.participants !== void 0 && O.participants.length !== 0)
        for (const ce of O.participants)
          v.ParticipantInfo.encode(ce, j.uint32(10).fork()).ldelim();
      return j;
    },
    decode(O, j) {
      const ce = O instanceof l.default.Reader ? O : new l.default.Reader(O);
      let De = j === void 0 ? ce.len : ce.pos + j;
      const Ne = Ae();
      for (; ce.pos < De; ) {
        const Fe = ce.uint32();
        switch (Fe >>> 3) {
          case 1:
            Ne.participants.push(v.ParticipantInfo.decode(ce, ce.uint32()));
            break;
          default:
            ce.skipType(Fe & 7);
            break;
        }
      }
      return Ne;
    },
    fromJSON(O) {
      return {
        participants: Array.isArray(O == null ? void 0 : O.participants) ? O.participants.map((j) => v.ParticipantInfo.fromJSON(j)) : []
      };
    },
    toJSON(O) {
      const j = {};
      return O.participants ? j.participants = O.participants.map((ce) => ce ? v.ParticipantInfo.toJSON(ce) : void 0) : j.participants = [], j;
    },
    fromPartial(O) {
      var j;
      const ce = Ae();
      return ce.participants = ((j = O.participants) === null || j === void 0 ? void 0 : j.map((De) => v.ParticipantInfo.fromPartial(De))) || [], ce;
    }
  };
  function Z() {
    return { trackSids: [], subscribe: !1, participantTracks: [] };
  }
  a.UpdateSubscription = {
    encode(O, j = l.default.Writer.create()) {
      if (O.trackSids !== void 0 && O.trackSids.length !== 0)
        for (const ce of O.trackSids)
          j.uint32(10).string(ce);
      if (O.subscribe === !0 && j.uint32(16).bool(O.subscribe), O.participantTracks !== void 0 && O.participantTracks.length !== 0)
        for (const ce of O.participantTracks)
          v.ParticipantTracks.encode(ce, j.uint32(26).fork()).ldelim();
      return j;
    },
    decode(O, j) {
      const ce = O instanceof l.default.Reader ? O : new l.default.Reader(O);
      let De = j === void 0 ? ce.len : ce.pos + j;
      const Ne = Z();
      for (; ce.pos < De; ) {
        const Fe = ce.uint32();
        switch (Fe >>> 3) {
          case 1:
            Ne.trackSids.push(ce.string());
            break;
          case 2:
            Ne.subscribe = ce.bool();
            break;
          case 3:
            Ne.participantTracks.push(v.ParticipantTracks.decode(ce, ce.uint32()));
            break;
          default:
            ce.skipType(Fe & 7);
            break;
        }
      }
      return Ne;
    },
    fromJSON(O) {
      return {
        trackSids: Array.isArray(O == null ? void 0 : O.trackSids) ? O.trackSids.map((j) => String(j)) : [],
        subscribe: re(O.subscribe) ? !!O.subscribe : !1,
        participantTracks: Array.isArray(O == null ? void 0 : O.participantTracks) ? O.participantTracks.map((j) => v.ParticipantTracks.fromJSON(j)) : []
      };
    },
    toJSON(O) {
      const j = {};
      return O.trackSids ? j.trackSids = O.trackSids.map((ce) => ce) : j.trackSids = [], O.subscribe !== void 0 && (j.subscribe = O.subscribe), O.participantTracks ? j.participantTracks = O.participantTracks.map((ce) => ce ? v.ParticipantTracks.toJSON(ce) : void 0) : j.participantTracks = [], j;
    },
    fromPartial(O) {
      var j, ce, De;
      const Ne = Z();
      return Ne.trackSids = ((j = O.trackSids) === null || j === void 0 ? void 0 : j.map((Fe) => Fe)) || [], Ne.subscribe = (ce = O.subscribe) !== null && ce !== void 0 ? ce : !1, Ne.participantTracks = ((De = O.participantTracks) === null || De === void 0 ? void 0 : De.map((Fe) => v.ParticipantTracks.fromPartial(Fe))) || [], Ne;
    }
  };
  function z() {
    return { trackSids: [], disabled: !1, quality: 0, width: 0, height: 0, fps: 0 };
  }
  a.UpdateTrackSettings = {
    encode(O, j = l.default.Writer.create()) {
      if (O.trackSids !== void 0 && O.trackSids.length !== 0)
        for (const ce of O.trackSids)
          j.uint32(10).string(ce);
      return O.disabled === !0 && j.uint32(24).bool(O.disabled), O.quality !== void 0 && O.quality !== 0 && j.uint32(32).int32(O.quality), O.width !== void 0 && O.width !== 0 && j.uint32(40).uint32(O.width), O.height !== void 0 && O.height !== 0 && j.uint32(48).uint32(O.height), O.fps !== void 0 && O.fps !== 0 && j.uint32(56).uint32(O.fps), j;
    },
    decode(O, j) {
      const ce = O instanceof l.default.Reader ? O : new l.default.Reader(O);
      let De = j === void 0 ? ce.len : ce.pos + j;
      const Ne = z();
      for (; ce.pos < De; ) {
        const Fe = ce.uint32();
        switch (Fe >>> 3) {
          case 1:
            Ne.trackSids.push(ce.string());
            break;
          case 3:
            Ne.disabled = ce.bool();
            break;
          case 4:
            Ne.quality = ce.int32();
            break;
          case 5:
            Ne.width = ce.uint32();
            break;
          case 6:
            Ne.height = ce.uint32();
            break;
          case 7:
            Ne.fps = ce.uint32();
            break;
          default:
            ce.skipType(Fe & 7);
            break;
        }
      }
      return Ne;
    },
    fromJSON(O) {
      return {
        trackSids: Array.isArray(O == null ? void 0 : O.trackSids) ? O.trackSids.map((j) => String(j)) : [],
        disabled: re(O.disabled) ? !!O.disabled : !1,
        quality: re(O.quality) ? v.videoQualityFromJSON(O.quality) : 0,
        width: re(O.width) ? Number(O.width) : 0,
        height: re(O.height) ? Number(O.height) : 0,
        fps: re(O.fps) ? Number(O.fps) : 0
      };
    },
    toJSON(O) {
      const j = {};
      return O.trackSids ? j.trackSids = O.trackSids.map((ce) => ce) : j.trackSids = [], O.disabled !== void 0 && (j.disabled = O.disabled), O.quality !== void 0 && (j.quality = v.videoQualityToJSON(O.quality)), O.width !== void 0 && (j.width = Math.round(O.width)), O.height !== void 0 && (j.height = Math.round(O.height)), O.fps !== void 0 && (j.fps = Math.round(O.fps)), j;
    },
    fromPartial(O) {
      var j, ce, De, Ne, Fe, Ze;
      const qe = z();
      return qe.trackSids = ((j = O.trackSids) === null || j === void 0 ? void 0 : j.map((gt) => gt)) || [], qe.disabled = (ce = O.disabled) !== null && ce !== void 0 ? ce : !1, qe.quality = (De = O.quality) !== null && De !== void 0 ? De : 0, qe.width = (Ne = O.width) !== null && Ne !== void 0 ? Ne : 0, qe.height = (Fe = O.height) !== null && Fe !== void 0 ? Fe : 0, qe.fps = (Ze = O.fps) !== null && Ze !== void 0 ? Ze : 0, qe;
    }
  };
  function P() {
    return { canReconnect: !1, reason: 0 };
  }
  a.LeaveRequest = {
    encode(O, j = l.default.Writer.create()) {
      return O.canReconnect === !0 && j.uint32(8).bool(O.canReconnect), O.reason !== void 0 && O.reason !== 0 && j.uint32(16).int32(O.reason), j;
    },
    decode(O, j) {
      const ce = O instanceof l.default.Reader ? O : new l.default.Reader(O);
      let De = j === void 0 ? ce.len : ce.pos + j;
      const Ne = P();
      for (; ce.pos < De; ) {
        const Fe = ce.uint32();
        switch (Fe >>> 3) {
          case 1:
            Ne.canReconnect = ce.bool();
            break;
          case 2:
            Ne.reason = ce.int32();
            break;
          default:
            ce.skipType(Fe & 7);
            break;
        }
      }
      return Ne;
    },
    fromJSON(O) {
      return {
        canReconnect: re(O.canReconnect) ? !!O.canReconnect : !1,
        reason: re(O.reason) ? v.disconnectReasonFromJSON(O.reason) : 0
      };
    },
    toJSON(O) {
      const j = {};
      return O.canReconnect !== void 0 && (j.canReconnect = O.canReconnect), O.reason !== void 0 && (j.reason = v.disconnectReasonToJSON(O.reason)), j;
    },
    fromPartial(O) {
      var j, ce;
      const De = P();
      return De.canReconnect = (j = O.canReconnect) !== null && j !== void 0 ? j : !1, De.reason = (ce = O.reason) !== null && ce !== void 0 ? ce : 0, De;
    }
  };
  function S() {
    return { trackSid: "", layers: [] };
  }
  a.UpdateVideoLayers = {
    encode(O, j = l.default.Writer.create()) {
      if (O.trackSid !== void 0 && O.trackSid !== "" && j.uint32(10).string(O.trackSid), O.layers !== void 0 && O.layers.length !== 0)
        for (const ce of O.layers)
          v.VideoLayer.encode(ce, j.uint32(18).fork()).ldelim();
      return j;
    },
    decode(O, j) {
      const ce = O instanceof l.default.Reader ? O : new l.default.Reader(O);
      let De = j === void 0 ? ce.len : ce.pos + j;
      const Ne = S();
      for (; ce.pos < De; ) {
        const Fe = ce.uint32();
        switch (Fe >>> 3) {
          case 1:
            Ne.trackSid = ce.string();
            break;
          case 2:
            Ne.layers.push(v.VideoLayer.decode(ce, ce.uint32()));
            break;
          default:
            ce.skipType(Fe & 7);
            break;
        }
      }
      return Ne;
    },
    fromJSON(O) {
      return {
        trackSid: re(O.trackSid) ? String(O.trackSid) : "",
        layers: Array.isArray(O == null ? void 0 : O.layers) ? O.layers.map((j) => v.VideoLayer.fromJSON(j)) : []
      };
    },
    toJSON(O) {
      const j = {};
      return O.trackSid !== void 0 && (j.trackSid = O.trackSid), O.layers ? j.layers = O.layers.map((ce) => ce ? v.VideoLayer.toJSON(ce) : void 0) : j.layers = [], j;
    },
    fromPartial(O) {
      var j, ce;
      const De = S();
      return De.trackSid = (j = O.trackSid) !== null && j !== void 0 ? j : "", De.layers = ((ce = O.layers) === null || ce === void 0 ? void 0 : ce.map((Ne) => v.VideoLayer.fromPartial(Ne))) || [], De;
    }
  };
  function E() {
    return { urls: [], username: "", credential: "" };
  }
  a.ICEServer = {
    encode(O, j = l.default.Writer.create()) {
      if (O.urls !== void 0 && O.urls.length !== 0)
        for (const ce of O.urls)
          j.uint32(10).string(ce);
      return O.username !== void 0 && O.username !== "" && j.uint32(18).string(O.username), O.credential !== void 0 && O.credential !== "" && j.uint32(26).string(O.credential), j;
    },
    decode(O, j) {
      const ce = O instanceof l.default.Reader ? O : new l.default.Reader(O);
      let De = j === void 0 ? ce.len : ce.pos + j;
      const Ne = E();
      for (; ce.pos < De; ) {
        const Fe = ce.uint32();
        switch (Fe >>> 3) {
          case 1:
            Ne.urls.push(ce.string());
            break;
          case 2:
            Ne.username = ce.string();
            break;
          case 3:
            Ne.credential = ce.string();
            break;
          default:
            ce.skipType(Fe & 7);
            break;
        }
      }
      return Ne;
    },
    fromJSON(O) {
      return {
        urls: Array.isArray(O == null ? void 0 : O.urls) ? O.urls.map((j) => String(j)) : [],
        username: re(O.username) ? String(O.username) : "",
        credential: re(O.credential) ? String(O.credential) : ""
      };
    },
    toJSON(O) {
      const j = {};
      return O.urls ? j.urls = O.urls.map((ce) => ce) : j.urls = [], O.username !== void 0 && (j.username = O.username), O.credential !== void 0 && (j.credential = O.credential), j;
    },
    fromPartial(O) {
      var j, ce, De;
      const Ne = E();
      return Ne.urls = ((j = O.urls) === null || j === void 0 ? void 0 : j.map((Fe) => Fe)) || [], Ne.username = (ce = O.username) !== null && ce !== void 0 ? ce : "", Ne.credential = (De = O.credential) !== null && De !== void 0 ? De : "", Ne;
    }
  };
  function I() {
    return { speakers: [] };
  }
  a.SpeakersChanged = {
    encode(O, j = l.default.Writer.create()) {
      if (O.speakers !== void 0 && O.speakers.length !== 0)
        for (const ce of O.speakers)
          v.SpeakerInfo.encode(ce, j.uint32(10).fork()).ldelim();
      return j;
    },
    decode(O, j) {
      const ce = O instanceof l.default.Reader ? O : new l.default.Reader(O);
      let De = j === void 0 ? ce.len : ce.pos + j;
      const Ne = I();
      for (; ce.pos < De; ) {
        const Fe = ce.uint32();
        switch (Fe >>> 3) {
          case 1:
            Ne.speakers.push(v.SpeakerInfo.decode(ce, ce.uint32()));
            break;
          default:
            ce.skipType(Fe & 7);
            break;
        }
      }
      return Ne;
    },
    fromJSON(O) {
      return {
        speakers: Array.isArray(O == null ? void 0 : O.speakers) ? O.speakers.map((j) => v.SpeakerInfo.fromJSON(j)) : []
      };
    },
    toJSON(O) {
      const j = {};
      return O.speakers ? j.speakers = O.speakers.map((ce) => ce ? v.SpeakerInfo.toJSON(ce) : void 0) : j.speakers = [], j;
    },
    fromPartial(O) {
      var j;
      const ce = I();
      return ce.speakers = ((j = O.speakers) === null || j === void 0 ? void 0 : j.map((De) => v.SpeakerInfo.fromPartial(De))) || [], ce;
    }
  };
  function N() {
    return { room: void 0 };
  }
  a.RoomUpdate = {
    encode(O, j = l.default.Writer.create()) {
      return O.room !== void 0 && v.Room.encode(O.room, j.uint32(10).fork()).ldelim(), j;
    },
    decode(O, j) {
      const ce = O instanceof l.default.Reader ? O : new l.default.Reader(O);
      let De = j === void 0 ? ce.len : ce.pos + j;
      const Ne = N();
      for (; ce.pos < De; ) {
        const Fe = ce.uint32();
        switch (Fe >>> 3) {
          case 1:
            Ne.room = v.Room.decode(ce, ce.uint32());
            break;
          default:
            ce.skipType(Fe & 7);
            break;
        }
      }
      return Ne;
    },
    fromJSON(O) {
      return { room: re(O.room) ? v.Room.fromJSON(O.room) : void 0 };
    },
    toJSON(O) {
      const j = {};
      return O.room !== void 0 && (j.room = O.room ? v.Room.toJSON(O.room) : void 0), j;
    },
    fromPartial(O) {
      const j = N();
      return j.room = O.room !== void 0 && O.room !== null ? v.Room.fromPartial(O.room) : void 0, j;
    }
  };
  function $() {
    return { participantSid: "", quality: 0, score: 0 };
  }
  a.ConnectionQualityInfo = {
    encode(O, j = l.default.Writer.create()) {
      return O.participantSid !== void 0 && O.participantSid !== "" && j.uint32(10).string(O.participantSid), O.quality !== void 0 && O.quality !== 0 && j.uint32(16).int32(O.quality), O.score !== void 0 && O.score !== 0 && j.uint32(29).float(O.score), j;
    },
    decode(O, j) {
      const ce = O instanceof l.default.Reader ? O : new l.default.Reader(O);
      let De = j === void 0 ? ce.len : ce.pos + j;
      const Ne = $();
      for (; ce.pos < De; ) {
        const Fe = ce.uint32();
        switch (Fe >>> 3) {
          case 1:
            Ne.participantSid = ce.string();
            break;
          case 2:
            Ne.quality = ce.int32();
            break;
          case 3:
            Ne.score = ce.float();
            break;
          default:
            ce.skipType(Fe & 7);
            break;
        }
      }
      return Ne;
    },
    fromJSON(O) {
      return {
        participantSid: re(O.participantSid) ? String(O.participantSid) : "",
        quality: re(O.quality) ? v.connectionQualityFromJSON(O.quality) : 0,
        score: re(O.score) ? Number(O.score) : 0
      };
    },
    toJSON(O) {
      const j = {};
      return O.participantSid !== void 0 && (j.participantSid = O.participantSid), O.quality !== void 0 && (j.quality = v.connectionQualityToJSON(O.quality)), O.score !== void 0 && (j.score = O.score), j;
    },
    fromPartial(O) {
      var j, ce, De;
      const Ne = $();
      return Ne.participantSid = (j = O.participantSid) !== null && j !== void 0 ? j : "", Ne.quality = (ce = O.quality) !== null && ce !== void 0 ? ce : 0, Ne.score = (De = O.score) !== null && De !== void 0 ? De : 0, Ne;
    }
  };
  function U() {
    return { updates: [] };
  }
  a.ConnectionQualityUpdate = {
    encode(O, j = l.default.Writer.create()) {
      if (O.updates !== void 0 && O.updates.length !== 0)
        for (const ce of O.updates)
          a.ConnectionQualityInfo.encode(ce, j.uint32(10).fork()).ldelim();
      return j;
    },
    decode(O, j) {
      const ce = O instanceof l.default.Reader ? O : new l.default.Reader(O);
      let De = j === void 0 ? ce.len : ce.pos + j;
      const Ne = U();
      for (; ce.pos < De; ) {
        const Fe = ce.uint32();
        switch (Fe >>> 3) {
          case 1:
            Ne.updates.push(a.ConnectionQualityInfo.decode(ce, ce.uint32()));
            break;
          default:
            ce.skipType(Fe & 7);
            break;
        }
      }
      return Ne;
    },
    fromJSON(O) {
      return {
        updates: Array.isArray(O == null ? void 0 : O.updates) ? O.updates.map((j) => a.ConnectionQualityInfo.fromJSON(j)) : []
      };
    },
    toJSON(O) {
      const j = {};
      return O.updates ? j.updates = O.updates.map((ce) => ce ? a.ConnectionQualityInfo.toJSON(ce) : void 0) : j.updates = [], j;
    },
    fromPartial(O) {
      var j;
      const ce = U();
      return ce.updates = ((j = O.updates) === null || j === void 0 ? void 0 : j.map((De) => a.ConnectionQualityInfo.fromPartial(De))) || [], ce;
    }
  };
  function H() {
    return { participantSid: "", trackSid: "", state: 0 };
  }
  a.StreamStateInfo = {
    encode(O, j = l.default.Writer.create()) {
      return O.participantSid !== void 0 && O.participantSid !== "" && j.uint32(10).string(O.participantSid), O.trackSid !== void 0 && O.trackSid !== "" && j.uint32(18).string(O.trackSid), O.state !== void 0 && O.state !== 0 && j.uint32(24).int32(O.state), j;
    },
    decode(O, j) {
      const ce = O instanceof l.default.Reader ? O : new l.default.Reader(O);
      let De = j === void 0 ? ce.len : ce.pos + j;
      const Ne = H();
      for (; ce.pos < De; ) {
        const Fe = ce.uint32();
        switch (Fe >>> 3) {
          case 1:
            Ne.participantSid = ce.string();
            break;
          case 2:
            Ne.trackSid = ce.string();
            break;
          case 3:
            Ne.state = ce.int32();
            break;
          default:
            ce.skipType(Fe & 7);
            break;
        }
      }
      return Ne;
    },
    fromJSON(O) {
      return {
        participantSid: re(O.participantSid) ? String(O.participantSid) : "",
        trackSid: re(O.trackSid) ? String(O.trackSid) : "",
        state: re(O.state) ? L(O.state) : 0
      };
    },
    toJSON(O) {
      const j = {};
      return O.participantSid !== void 0 && (j.participantSid = O.participantSid), O.trackSid !== void 0 && (j.trackSid = O.trackSid), O.state !== void 0 && (j.state = F(O.state)), j;
    },
    fromPartial(O) {
      var j, ce, De;
      const Ne = H();
      return Ne.participantSid = (j = O.participantSid) !== null && j !== void 0 ? j : "", Ne.trackSid = (ce = O.trackSid) !== null && ce !== void 0 ? ce : "", Ne.state = (De = O.state) !== null && De !== void 0 ? De : 0, Ne;
    }
  };
  function B() {
    return { streamStates: [] };
  }
  a.StreamStateUpdate = {
    encode(O, j = l.default.Writer.create()) {
      if (O.streamStates !== void 0 && O.streamStates.length !== 0)
        for (const ce of O.streamStates)
          a.StreamStateInfo.encode(ce, j.uint32(10).fork()).ldelim();
      return j;
    },
    decode(O, j) {
      const ce = O instanceof l.default.Reader ? O : new l.default.Reader(O);
      let De = j === void 0 ? ce.len : ce.pos + j;
      const Ne = B();
      for (; ce.pos < De; ) {
        const Fe = ce.uint32();
        switch (Fe >>> 3) {
          case 1:
            Ne.streamStates.push(a.StreamStateInfo.decode(ce, ce.uint32()));
            break;
          default:
            ce.skipType(Fe & 7);
            break;
        }
      }
      return Ne;
    },
    fromJSON(O) {
      return {
        streamStates: Array.isArray(O == null ? void 0 : O.streamStates) ? O.streamStates.map((j) => a.StreamStateInfo.fromJSON(j)) : []
      };
    },
    toJSON(O) {
      const j = {};
      return O.streamStates ? j.streamStates = O.streamStates.map((ce) => ce ? a.StreamStateInfo.toJSON(ce) : void 0) : j.streamStates = [], j;
    },
    fromPartial(O) {
      var j;
      const ce = B();
      return ce.streamStates = ((j = O.streamStates) === null || j === void 0 ? void 0 : j.map((De) => a.StreamStateInfo.fromPartial(De))) || [], ce;
    }
  };
  function T() {
    return { quality: 0, enabled: !1 };
  }
  a.SubscribedQuality = {
    encode(O, j = l.default.Writer.create()) {
      return O.quality !== void 0 && O.quality !== 0 && j.uint32(8).int32(O.quality), O.enabled === !0 && j.uint32(16).bool(O.enabled), j;
    },
    decode(O, j) {
      const ce = O instanceof l.default.Reader ? O : new l.default.Reader(O);
      let De = j === void 0 ? ce.len : ce.pos + j;
      const Ne = T();
      for (; ce.pos < De; ) {
        const Fe = ce.uint32();
        switch (Fe >>> 3) {
          case 1:
            Ne.quality = ce.int32();
            break;
          case 2:
            Ne.enabled = ce.bool();
            break;
          default:
            ce.skipType(Fe & 7);
            break;
        }
      }
      return Ne;
    },
    fromJSON(O) {
      return {
        quality: re(O.quality) ? v.videoQualityFromJSON(O.quality) : 0,
        enabled: re(O.enabled) ? !!O.enabled : !1
      };
    },
    toJSON(O) {
      const j = {};
      return O.quality !== void 0 && (j.quality = v.videoQualityToJSON(O.quality)), O.enabled !== void 0 && (j.enabled = O.enabled), j;
    },
    fromPartial(O) {
      var j, ce;
      const De = T();
      return De.quality = (j = O.quality) !== null && j !== void 0 ? j : 0, De.enabled = (ce = O.enabled) !== null && ce !== void 0 ? ce : !1, De;
    }
  };
  function D() {
    return { codec: "", qualities: [] };
  }
  a.SubscribedCodec = {
    encode(O, j = l.default.Writer.create()) {
      if (O.codec !== void 0 && O.codec !== "" && j.uint32(10).string(O.codec), O.qualities !== void 0 && O.qualities.length !== 0)
        for (const ce of O.qualities)
          a.SubscribedQuality.encode(ce, j.uint32(18).fork()).ldelim();
      return j;
    },
    decode(O, j) {
      const ce = O instanceof l.default.Reader ? O : new l.default.Reader(O);
      let De = j === void 0 ? ce.len : ce.pos + j;
      const Ne = D();
      for (; ce.pos < De; ) {
        const Fe = ce.uint32();
        switch (Fe >>> 3) {
          case 1:
            Ne.codec = ce.string();
            break;
          case 2:
            Ne.qualities.push(a.SubscribedQuality.decode(ce, ce.uint32()));
            break;
          default:
            ce.skipType(Fe & 7);
            break;
        }
      }
      return Ne;
    },
    fromJSON(O) {
      return {
        codec: re(O.codec) ? String(O.codec) : "",
        qualities: Array.isArray(O == null ? void 0 : O.qualities) ? O.qualities.map((j) => a.SubscribedQuality.fromJSON(j)) : []
      };
    },
    toJSON(O) {
      const j = {};
      return O.codec !== void 0 && (j.codec = O.codec), O.qualities ? j.qualities = O.qualities.map((ce) => ce ? a.SubscribedQuality.toJSON(ce) : void 0) : j.qualities = [], j;
    },
    fromPartial(O) {
      var j, ce;
      const De = D();
      return De.codec = (j = O.codec) !== null && j !== void 0 ? j : "", De.qualities = ((ce = O.qualities) === null || ce === void 0 ? void 0 : ce.map((Ne) => a.SubscribedQuality.fromPartial(Ne))) || [], De;
    }
  };
  function ee() {
    return { trackSid: "", subscribedQualities: [], subscribedCodecs: [] };
  }
  a.SubscribedQualityUpdate = {
    encode(O, j = l.default.Writer.create()) {
      if (O.trackSid !== void 0 && O.trackSid !== "" && j.uint32(10).string(O.trackSid), O.subscribedQualities !== void 0 && O.subscribedQualities.length !== 0)
        for (const ce of O.subscribedQualities)
          a.SubscribedQuality.encode(ce, j.uint32(18).fork()).ldelim();
      if (O.subscribedCodecs !== void 0 && O.subscribedCodecs.length !== 0)
        for (const ce of O.subscribedCodecs)
          a.SubscribedCodec.encode(ce, j.uint32(26).fork()).ldelim();
      return j;
    },
    decode(O, j) {
      const ce = O instanceof l.default.Reader ? O : new l.default.Reader(O);
      let De = j === void 0 ? ce.len : ce.pos + j;
      const Ne = ee();
      for (; ce.pos < De; ) {
        const Fe = ce.uint32();
        switch (Fe >>> 3) {
          case 1:
            Ne.trackSid = ce.string();
            break;
          case 2:
            Ne.subscribedQualities.push(a.SubscribedQuality.decode(ce, ce.uint32()));
            break;
          case 3:
            Ne.subscribedCodecs.push(a.SubscribedCodec.decode(ce, ce.uint32()));
            break;
          default:
            ce.skipType(Fe & 7);
            break;
        }
      }
      return Ne;
    },
    fromJSON(O) {
      return {
        trackSid: re(O.trackSid) ? String(O.trackSid) : "",
        subscribedQualities: Array.isArray(O == null ? void 0 : O.subscribedQualities) ? O.subscribedQualities.map((j) => a.SubscribedQuality.fromJSON(j)) : [],
        subscribedCodecs: Array.isArray(O == null ? void 0 : O.subscribedCodecs) ? O.subscribedCodecs.map((j) => a.SubscribedCodec.fromJSON(j)) : []
      };
    },
    toJSON(O) {
      const j = {};
      return O.trackSid !== void 0 && (j.trackSid = O.trackSid), O.subscribedQualities ? j.subscribedQualities = O.subscribedQualities.map((ce) => ce ? a.SubscribedQuality.toJSON(ce) : void 0) : j.subscribedQualities = [], O.subscribedCodecs ? j.subscribedCodecs = O.subscribedCodecs.map((ce) => ce ? a.SubscribedCodec.toJSON(ce) : void 0) : j.subscribedCodecs = [], j;
    },
    fromPartial(O) {
      var j, ce, De;
      const Ne = ee();
      return Ne.trackSid = (j = O.trackSid) !== null && j !== void 0 ? j : "", Ne.subscribedQualities = ((ce = O.subscribedQualities) === null || ce === void 0 ? void 0 : ce.map((Fe) => a.SubscribedQuality.fromPartial(Fe))) || [], Ne.subscribedCodecs = ((De = O.subscribedCodecs) === null || De === void 0 ? void 0 : De.map((Fe) => a.SubscribedCodec.fromPartial(Fe))) || [], Ne;
    }
  };
  function pe() {
    return { participantSid: "", allTracks: !1, trackSids: [], participantIdentity: "" };
  }
  a.TrackPermission = {
    encode(O, j = l.default.Writer.create()) {
      if (O.participantSid !== void 0 && O.participantSid !== "" && j.uint32(10).string(O.participantSid), O.allTracks === !0 && j.uint32(16).bool(O.allTracks), O.trackSids !== void 0 && O.trackSids.length !== 0)
        for (const ce of O.trackSids)
          j.uint32(26).string(ce);
      return O.participantIdentity !== void 0 && O.participantIdentity !== "" && j.uint32(34).string(O.participantIdentity), j;
    },
    decode(O, j) {
      const ce = O instanceof l.default.Reader ? O : new l.default.Reader(O);
      let De = j === void 0 ? ce.len : ce.pos + j;
      const Ne = pe();
      for (; ce.pos < De; ) {
        const Fe = ce.uint32();
        switch (Fe >>> 3) {
          case 1:
            Ne.participantSid = ce.string();
            break;
          case 2:
            Ne.allTracks = ce.bool();
            break;
          case 3:
            Ne.trackSids.push(ce.string());
            break;
          case 4:
            Ne.participantIdentity = ce.string();
            break;
          default:
            ce.skipType(Fe & 7);
            break;
        }
      }
      return Ne;
    },
    fromJSON(O) {
      return {
        participantSid: re(O.participantSid) ? String(O.participantSid) : "",
        allTracks: re(O.allTracks) ? !!O.allTracks : !1,
        trackSids: Array.isArray(O == null ? void 0 : O.trackSids) ? O.trackSids.map((j) => String(j)) : [],
        participantIdentity: re(O.participantIdentity) ? String(O.participantIdentity) : ""
      };
    },
    toJSON(O) {
      const j = {};
      return O.participantSid !== void 0 && (j.participantSid = O.participantSid), O.allTracks !== void 0 && (j.allTracks = O.allTracks), O.trackSids ? j.trackSids = O.trackSids.map((ce) => ce) : j.trackSids = [], O.participantIdentity !== void 0 && (j.participantIdentity = O.participantIdentity), j;
    },
    fromPartial(O) {
      var j, ce, De, Ne;
      const Fe = pe();
      return Fe.participantSid = (j = O.participantSid) !== null && j !== void 0 ? j : "", Fe.allTracks = (ce = O.allTracks) !== null && ce !== void 0 ? ce : !1, Fe.trackSids = ((De = O.trackSids) === null || De === void 0 ? void 0 : De.map((Ze) => Ze)) || [], Fe.participantIdentity = (Ne = O.participantIdentity) !== null && Ne !== void 0 ? Ne : "", Fe;
    }
  };
  function Ie() {
    return { allParticipants: !1, trackPermissions: [] };
  }
  a.SubscriptionPermission = {
    encode(O, j = l.default.Writer.create()) {
      if (O.allParticipants === !0 && j.uint32(8).bool(O.allParticipants), O.trackPermissions !== void 0 && O.trackPermissions.length !== 0)
        for (const ce of O.trackPermissions)
          a.TrackPermission.encode(ce, j.uint32(18).fork()).ldelim();
      return j;
    },
    decode(O, j) {
      const ce = O instanceof l.default.Reader ? O : new l.default.Reader(O);
      let De = j === void 0 ? ce.len : ce.pos + j;
      const Ne = Ie();
      for (; ce.pos < De; ) {
        const Fe = ce.uint32();
        switch (Fe >>> 3) {
          case 1:
            Ne.allParticipants = ce.bool();
            break;
          case 2:
            Ne.trackPermissions.push(a.TrackPermission.decode(ce, ce.uint32()));
            break;
          default:
            ce.skipType(Fe & 7);
            break;
        }
      }
      return Ne;
    },
    fromJSON(O) {
      return {
        allParticipants: re(O.allParticipants) ? !!O.allParticipants : !1,
        trackPermissions: Array.isArray(O == null ? void 0 : O.trackPermissions) ? O.trackPermissions.map((j) => a.TrackPermission.fromJSON(j)) : []
      };
    },
    toJSON(O) {
      const j = {};
      return O.allParticipants !== void 0 && (j.allParticipants = O.allParticipants), O.trackPermissions ? j.trackPermissions = O.trackPermissions.map((ce) => ce ? a.TrackPermission.toJSON(ce) : void 0) : j.trackPermissions = [], j;
    },
    fromPartial(O) {
      var j, ce;
      const De = Ie();
      return De.allParticipants = (j = O.allParticipants) !== null && j !== void 0 ? j : !1, De.trackPermissions = ((ce = O.trackPermissions) === null || ce === void 0 ? void 0 : ce.map((Ne) => a.TrackPermission.fromPartial(Ne))) || [], De;
    }
  };
  function Pe() {
    return { participantSid: "", trackSid: "", allowed: !1 };
  }
  a.SubscriptionPermissionUpdate = {
    encode(O, j = l.default.Writer.create()) {
      return O.participantSid !== void 0 && O.participantSid !== "" && j.uint32(10).string(O.participantSid), O.trackSid !== void 0 && O.trackSid !== "" && j.uint32(18).string(O.trackSid), O.allowed === !0 && j.uint32(24).bool(O.allowed), j;
    },
    decode(O, j) {
      const ce = O instanceof l.default.Reader ? O : new l.default.Reader(O);
      let De = j === void 0 ? ce.len : ce.pos + j;
      const Ne = Pe();
      for (; ce.pos < De; ) {
        const Fe = ce.uint32();
        switch (Fe >>> 3) {
          case 1:
            Ne.participantSid = ce.string();
            break;
          case 2:
            Ne.trackSid = ce.string();
            break;
          case 3:
            Ne.allowed = ce.bool();
            break;
          default:
            ce.skipType(Fe & 7);
            break;
        }
      }
      return Ne;
    },
    fromJSON(O) {
      return {
        participantSid: re(O.participantSid) ? String(O.participantSid) : "",
        trackSid: re(O.trackSid) ? String(O.trackSid) : "",
        allowed: re(O.allowed) ? !!O.allowed : !1
      };
    },
    toJSON(O) {
      const j = {};
      return O.participantSid !== void 0 && (j.participantSid = O.participantSid), O.trackSid !== void 0 && (j.trackSid = O.trackSid), O.allowed !== void 0 && (j.allowed = O.allowed), j;
    },
    fromPartial(O) {
      var j, ce, De;
      const Ne = Pe();
      return Ne.participantSid = (j = O.participantSid) !== null && j !== void 0 ? j : "", Ne.trackSid = (ce = O.trackSid) !== null && ce !== void 0 ? ce : "", Ne.allowed = (De = O.allowed) !== null && De !== void 0 ? De : !1, Ne;
    }
  };
  function he() {
    return { answer: void 0, subscription: void 0, publishTracks: [], dataChannels: [], offer: void 0 };
  }
  a.SyncState = {
    encode(O, j = l.default.Writer.create()) {
      if (O.answer !== void 0 && a.SessionDescription.encode(O.answer, j.uint32(10).fork()).ldelim(), O.subscription !== void 0 && a.UpdateSubscription.encode(O.subscription, j.uint32(18).fork()).ldelim(), O.publishTracks !== void 0 && O.publishTracks.length !== 0)
        for (const ce of O.publishTracks)
          a.TrackPublishedResponse.encode(ce, j.uint32(26).fork()).ldelim();
      if (O.dataChannels !== void 0 && O.dataChannels.length !== 0)
        for (const ce of O.dataChannels)
          a.DataChannelInfo.encode(ce, j.uint32(34).fork()).ldelim();
      return O.offer !== void 0 && a.SessionDescription.encode(O.offer, j.uint32(42).fork()).ldelim(), j;
    },
    decode(O, j) {
      const ce = O instanceof l.default.Reader ? O : new l.default.Reader(O);
      let De = j === void 0 ? ce.len : ce.pos + j;
      const Ne = he();
      for (; ce.pos < De; ) {
        const Fe = ce.uint32();
        switch (Fe >>> 3) {
          case 1:
            Ne.answer = a.SessionDescription.decode(ce, ce.uint32());
            break;
          case 2:
            Ne.subscription = a.UpdateSubscription.decode(ce, ce.uint32());
            break;
          case 3:
            Ne.publishTracks.push(a.TrackPublishedResponse.decode(ce, ce.uint32()));
            break;
          case 4:
            Ne.dataChannels.push(a.DataChannelInfo.decode(ce, ce.uint32()));
            break;
          case 5:
            Ne.offer = a.SessionDescription.decode(ce, ce.uint32());
            break;
          default:
            ce.skipType(Fe & 7);
            break;
        }
      }
      return Ne;
    },
    fromJSON(O) {
      return {
        answer: re(O.answer) ? a.SessionDescription.fromJSON(O.answer) : void 0,
        subscription: re(O.subscription) ? a.UpdateSubscription.fromJSON(O.subscription) : void 0,
        publishTracks: Array.isArray(O == null ? void 0 : O.publishTracks) ? O.publishTracks.map((j) => a.TrackPublishedResponse.fromJSON(j)) : [],
        dataChannels: Array.isArray(O == null ? void 0 : O.dataChannels) ? O.dataChannels.map((j) => a.DataChannelInfo.fromJSON(j)) : [],
        offer: re(O.offer) ? a.SessionDescription.fromJSON(O.offer) : void 0
      };
    },
    toJSON(O) {
      const j = {};
      return O.answer !== void 0 && (j.answer = O.answer ? a.SessionDescription.toJSON(O.answer) : void 0), O.subscription !== void 0 && (j.subscription = O.subscription ? a.UpdateSubscription.toJSON(O.subscription) : void 0), O.publishTracks ? j.publishTracks = O.publishTracks.map((ce) => ce ? a.TrackPublishedResponse.toJSON(ce) : void 0) : j.publishTracks = [], O.dataChannels ? j.dataChannels = O.dataChannels.map((ce) => ce ? a.DataChannelInfo.toJSON(ce) : void 0) : j.dataChannels = [], O.offer !== void 0 && (j.offer = O.offer ? a.SessionDescription.toJSON(O.offer) : void 0), j;
    },
    fromPartial(O) {
      var j, ce;
      const De = he();
      return De.answer = O.answer !== void 0 && O.answer !== null ? a.SessionDescription.fromPartial(O.answer) : void 0, De.subscription = O.subscription !== void 0 && O.subscription !== null ? a.UpdateSubscription.fromPartial(O.subscription) : void 0, De.publishTracks = ((j = O.publishTracks) === null || j === void 0 ? void 0 : j.map((Ne) => a.TrackPublishedResponse.fromPartial(Ne))) || [], De.dataChannels = ((ce = O.dataChannels) === null || ce === void 0 ? void 0 : ce.map((Ne) => a.DataChannelInfo.fromPartial(Ne))) || [], De.offer = O.offer !== void 0 && O.offer !== null ? a.SessionDescription.fromPartial(O.offer) : void 0, De;
    }
  };
  function ve() {
    return { label: "", id: 0, target: 0 };
  }
  a.DataChannelInfo = {
    encode(O, j = l.default.Writer.create()) {
      return O.label !== void 0 && O.label !== "" && j.uint32(10).string(O.label), O.id !== void 0 && O.id !== 0 && j.uint32(16).uint32(O.id), O.target !== void 0 && O.target !== 0 && j.uint32(24).int32(O.target), j;
    },
    decode(O, j) {
      const ce = O instanceof l.default.Reader ? O : new l.default.Reader(O);
      let De = j === void 0 ? ce.len : ce.pos + j;
      const Ne = ve();
      for (; ce.pos < De; ) {
        const Fe = ce.uint32();
        switch (Fe >>> 3) {
          case 1:
            Ne.label = ce.string();
            break;
          case 2:
            Ne.id = ce.uint32();
            break;
          case 3:
            Ne.target = ce.int32();
            break;
          default:
            ce.skipType(Fe & 7);
            break;
        }
      }
      return Ne;
    },
    fromJSON(O) {
      return {
        label: re(O.label) ? String(O.label) : "",
        id: re(O.id) ? Number(O.id) : 0,
        target: re(O.target) ? _(O.target) : 0
      };
    },
    toJSON(O) {
      const j = {};
      return O.label !== void 0 && (j.label = O.label), O.id !== void 0 && (j.id = Math.round(O.id)), O.target !== void 0 && (j.target = k(O.target)), j;
    },
    fromPartial(O) {
      var j, ce, De;
      const Ne = ve();
      return Ne.label = (j = O.label) !== null && j !== void 0 ? j : "", Ne.id = (ce = O.id) !== null && ce !== void 0 ? ce : 0, Ne.target = (De = O.target) !== null && De !== void 0 ? De : 0, Ne;
    }
  };
  function Q() {
    return {
      speakerUpdate: void 0,
      nodeFailure: void 0,
      migration: void 0,
      serverLeave: void 0,
      switchCandidateProtocol: void 0
    };
  }
  a.SimulateScenario = {
    encode(O, j = l.default.Writer.create()) {
      return O.speakerUpdate !== void 0 && j.uint32(8).int32(O.speakerUpdate), O.nodeFailure !== void 0 && j.uint32(16).bool(O.nodeFailure), O.migration !== void 0 && j.uint32(24).bool(O.migration), O.serverLeave !== void 0 && j.uint32(32).bool(O.serverLeave), O.switchCandidateProtocol !== void 0 && j.uint32(40).int32(O.switchCandidateProtocol), j;
    },
    decode(O, j) {
      const ce = O instanceof l.default.Reader ? O : new l.default.Reader(O);
      let De = j === void 0 ? ce.len : ce.pos + j;
      const Ne = Q();
      for (; ce.pos < De; ) {
        const Fe = ce.uint32();
        switch (Fe >>> 3) {
          case 1:
            Ne.speakerUpdate = ce.int32();
            break;
          case 2:
            Ne.nodeFailure = ce.bool();
            break;
          case 3:
            Ne.migration = ce.bool();
            break;
          case 4:
            Ne.serverLeave = ce.bool();
            break;
          case 5:
            Ne.switchCandidateProtocol = ce.int32();
            break;
          default:
            ce.skipType(Fe & 7);
            break;
        }
      }
      return Ne;
    },
    fromJSON(O) {
      return {
        speakerUpdate: re(O.speakerUpdate) ? Number(O.speakerUpdate) : void 0,
        nodeFailure: re(O.nodeFailure) ? !!O.nodeFailure : void 0,
        migration: re(O.migration) ? !!O.migration : void 0,
        serverLeave: re(O.serverLeave) ? !!O.serverLeave : void 0,
        switchCandidateProtocol: re(O.switchCandidateProtocol) ? X(O.switchCandidateProtocol) : void 0
      };
    },
    toJSON(O) {
      const j = {};
      return O.speakerUpdate !== void 0 && (j.speakerUpdate = Math.round(O.speakerUpdate)), O.nodeFailure !== void 0 && (j.nodeFailure = O.nodeFailure), O.migration !== void 0 && (j.migration = O.migration), O.serverLeave !== void 0 && (j.serverLeave = O.serverLeave), O.switchCandidateProtocol !== void 0 && (j.switchCandidateProtocol = O.switchCandidateProtocol !== void 0 ? oe(O.switchCandidateProtocol) : void 0), j;
    },
    fromPartial(O) {
      var j, ce, De, Ne, Fe;
      const Ze = Q();
      return Ze.speakerUpdate = (j = O.speakerUpdate) !== null && j !== void 0 ? j : void 0, Ze.nodeFailure = (ce = O.nodeFailure) !== null && ce !== void 0 ? ce : void 0, Ze.migration = (De = O.migration) !== null && De !== void 0 ? De : void 0, Ze.serverLeave = (Ne = O.serverLeave) !== null && Ne !== void 0 ? Ne : void 0, Ze.switchCandidateProtocol = (Fe = O.switchCandidateProtocol) !== null && Fe !== void 0 ? Fe : void 0, Ze;
    }
  };
  var le = (() => {
    if (typeof le < "u")
      return le;
    if (typeof self < "u")
      return self;
    if (typeof window < "u")
      return window;
    if (typeof commonjsGlobal$1 < "u")
      return commonjsGlobal$1;
    throw "Unable to locate global object";
  })();
  function _e(O) {
    if (O.gt(Number.MAX_SAFE_INTEGER))
      throw new le.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    return O.toNumber();
  }
  l.default.util.Long !== c.default && (l.default.util.Long = c.default, l.default.configure());
  function re(O) {
    return O != null;
  }
})(livekit_rtc);
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(z) {
    return z && z.__esModule ? z : { default: z };
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.RoomInternal = a.KeepAlive = a.RemoveParticipant = a.EndSession = a.StartSession = a.SignalNodeMessage = a.RTCNodeMessage = a.NodeStats = a.Node = a.nodeStateToJSON = a.nodeStateFromJSON = a.NodeState = a.nodeTypeToJSON = a.nodeTypeFromJSON = a.NodeType = a.protobufPackage = void 0;
  const c = u(umdExports), l = u(minimal), v = livekit_egress, p = livekit_models, _ = livekit_room, k = livekit_rtc;
  a.protobufPackage = "livekit";
  var M;
  (function(z) {
    z[z.SERVER = 0] = "SERVER", z[z.CONTROLLER = 1] = "CONTROLLER", z[z.MEDIA = 2] = "MEDIA", z[z.TURN = 4] = "TURN", z[z.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(M = a.NodeType || (a.NodeType = {}));
  function L(z) {
    switch (z) {
      case 0:
      case "SERVER":
        return M.SERVER;
      case 1:
      case "CONTROLLER":
        return M.CONTROLLER;
      case 2:
      case "MEDIA":
        return M.MEDIA;
      case 4:
      case "TURN":
        return M.TURN;
      case -1:
      case "UNRECOGNIZED":
      default:
        return M.UNRECOGNIZED;
    }
  }
  a.nodeTypeFromJSON = L;
  function F(z) {
    switch (z) {
      case M.SERVER:
        return "SERVER";
      case M.CONTROLLER:
        return "CONTROLLER";
      case M.MEDIA:
        return "MEDIA";
      case M.TURN:
        return "TURN";
      case M.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.nodeTypeToJSON = F;
  var V;
  (function(z) {
    z[z.STARTING_UP = 0] = "STARTING_UP", z[z.SERVING = 1] = "SERVING", z[z.SHUTTING_DOWN = 2] = "SHUTTING_DOWN", z[z.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(V = a.NodeState || (a.NodeState = {}));
  function X(z) {
    switch (z) {
      case 0:
      case "STARTING_UP":
        return V.STARTING_UP;
      case 1:
      case "SERVING":
        return V.SERVING;
      case 2:
      case "SHUTTING_DOWN":
        return V.SHUTTING_DOWN;
      case -1:
      case "UNRECOGNIZED":
      default:
        return V.UNRECOGNIZED;
    }
  }
  a.nodeStateFromJSON = X;
  function oe(z) {
    switch (z) {
      case V.STARTING_UP:
        return "STARTING_UP";
      case V.SERVING:
        return "SERVING";
      case V.SHUTTING_DOWN:
        return "SHUTTING_DOWN";
      case V.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.nodeStateToJSON = oe;
  function Y() {
    return { id: "", ip: "", numCpus: 0, stats: void 0, type: 0, state: 0, region: "" };
  }
  a.Node = {
    encode(z, P = l.default.Writer.create()) {
      return z.id !== void 0 && z.id !== "" && P.uint32(10).string(z.id), z.ip !== void 0 && z.ip !== "" && P.uint32(18).string(z.ip), z.numCpus !== void 0 && z.numCpus !== 0 && P.uint32(24).uint32(z.numCpus), z.stats !== void 0 && a.NodeStats.encode(z.stats, P.uint32(34).fork()).ldelim(), z.type !== void 0 && z.type !== 0 && P.uint32(40).int32(z.type), z.state !== void 0 && z.state !== 0 && P.uint32(48).int32(z.state), z.region !== void 0 && z.region !== "" && P.uint32(58).string(z.region), P;
    },
    decode(z, P) {
      const S = z instanceof l.default.Reader ? z : new l.default.Reader(z);
      let E = P === void 0 ? S.len : S.pos + P;
      const I = Y();
      for (; S.pos < E; ) {
        const N = S.uint32();
        switch (N >>> 3) {
          case 1:
            I.id = S.string();
            break;
          case 2:
            I.ip = S.string();
            break;
          case 3:
            I.numCpus = S.uint32();
            break;
          case 4:
            I.stats = a.NodeStats.decode(S, S.uint32());
            break;
          case 5:
            I.type = S.int32();
            break;
          case 6:
            I.state = S.int32();
            break;
          case 7:
            I.region = S.string();
            break;
          default:
            S.skipType(N & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(z) {
      return {
        id: Z(z.id) ? String(z.id) : "",
        ip: Z(z.ip) ? String(z.ip) : "",
        numCpus: Z(z.numCpus) ? Number(z.numCpus) : 0,
        stats: Z(z.stats) ? a.NodeStats.fromJSON(z.stats) : void 0,
        type: Z(z.type) ? L(z.type) : 0,
        state: Z(z.state) ? X(z.state) : 0,
        region: Z(z.region) ? String(z.region) : ""
      };
    },
    toJSON(z) {
      const P = {};
      return z.id !== void 0 && (P.id = z.id), z.ip !== void 0 && (P.ip = z.ip), z.numCpus !== void 0 && (P.numCpus = Math.round(z.numCpus)), z.stats !== void 0 && (P.stats = z.stats ? a.NodeStats.toJSON(z.stats) : void 0), z.type !== void 0 && (P.type = F(z.type)), z.state !== void 0 && (P.state = oe(z.state)), z.region !== void 0 && (P.region = z.region), P;
    },
    fromPartial(z) {
      var P, S, E, I, N, $;
      const U = Y();
      return U.id = (P = z.id) !== null && P !== void 0 ? P : "", U.ip = (S = z.ip) !== null && S !== void 0 ? S : "", U.numCpus = (E = z.numCpus) !== null && E !== void 0 ? E : 0, U.stats = z.stats !== void 0 && z.stats !== null ? a.NodeStats.fromPartial(z.stats) : void 0, U.type = (I = z.type) !== null && I !== void 0 ? I : 0, U.state = (N = z.state) !== null && N !== void 0 ? N : 0, U.region = ($ = z.region) !== null && $ !== void 0 ? $ : "", U;
    }
  };
  function ae() {
    return {
      startedAt: 0,
      updatedAt: 0,
      numRooms: 0,
      numClients: 0,
      numTracksIn: 0,
      numTracksOut: 0,
      bytesIn: 0,
      bytesOut: 0,
      packetsIn: 0,
      packetsOut: 0,
      nackTotal: 0,
      bytesInPerSec: 0,
      bytesOutPerSec: 0,
      packetsInPerSec: 0,
      packetsOutPerSec: 0,
      nackPerSec: 0,
      numCpus: 0,
      loadAvgLast1min: 0,
      loadAvgLast5min: 0,
      loadAvgLast15min: 0,
      cpuLoad: 0,
      memoryLoad: 0,
      sysPacketsOut: 0,
      sysPacketsDropped: 0,
      sysPacketsOutPerSec: 0,
      sysPacketsDroppedPerSec: 0,
      sysPacketsDroppedPctPerSec: 0,
      retransmitBytesOut: 0,
      retransmitPacketsOut: 0,
      retransmitBytesOutPerSec: 0,
      retransmitPacketsOutPerSec: 0,
      participantJoin: 0,
      participantJoinPerSec: 0
    };
  }
  a.NodeStats = {
    encode(z, P = l.default.Writer.create()) {
      return z.startedAt !== void 0 && z.startedAt !== 0 && P.uint32(8).int64(z.startedAt), z.updatedAt !== void 0 && z.updatedAt !== 0 && P.uint32(16).int64(z.updatedAt), z.numRooms !== void 0 && z.numRooms !== 0 && P.uint32(24).int32(z.numRooms), z.numClients !== void 0 && z.numClients !== 0 && P.uint32(32).int32(z.numClients), z.numTracksIn !== void 0 && z.numTracksIn !== 0 && P.uint32(40).int32(z.numTracksIn), z.numTracksOut !== void 0 && z.numTracksOut !== 0 && P.uint32(48).int32(z.numTracksOut), z.bytesIn !== void 0 && z.bytesIn !== 0 && P.uint32(56).uint64(z.bytesIn), z.bytesOut !== void 0 && z.bytesOut !== 0 && P.uint32(64).uint64(z.bytesOut), z.packetsIn !== void 0 && z.packetsIn !== 0 && P.uint32(72).uint64(z.packetsIn), z.packetsOut !== void 0 && z.packetsOut !== 0 && P.uint32(80).uint64(z.packetsOut), z.nackTotal !== void 0 && z.nackTotal !== 0 && P.uint32(88).uint64(z.nackTotal), z.bytesInPerSec !== void 0 && z.bytesInPerSec !== 0 && P.uint32(101).float(z.bytesInPerSec), z.bytesOutPerSec !== void 0 && z.bytesOutPerSec !== 0 && P.uint32(109).float(z.bytesOutPerSec), z.packetsInPerSec !== void 0 && z.packetsInPerSec !== 0 && P.uint32(117).float(z.packetsInPerSec), z.packetsOutPerSec !== void 0 && z.packetsOutPerSec !== 0 && P.uint32(125).float(z.packetsOutPerSec), z.nackPerSec !== void 0 && z.nackPerSec !== 0 && P.uint32(133).float(z.nackPerSec), z.numCpus !== void 0 && z.numCpus !== 0 && P.uint32(136).uint32(z.numCpus), z.loadAvgLast1min !== void 0 && z.loadAvgLast1min !== 0 && P.uint32(149).float(z.loadAvgLast1min), z.loadAvgLast5min !== void 0 && z.loadAvgLast5min !== 0 && P.uint32(157).float(z.loadAvgLast5min), z.loadAvgLast15min !== void 0 && z.loadAvgLast15min !== 0 && P.uint32(165).float(z.loadAvgLast15min), z.cpuLoad !== void 0 && z.cpuLoad !== 0 && P.uint32(173).float(z.cpuLoad), z.memoryLoad !== void 0 && z.memoryLoad !== 0 && P.uint32(269).float(z.memoryLoad), z.sysPacketsOut !== void 0 && z.sysPacketsOut !== 0 && P.uint32(224).uint32(z.sysPacketsOut), z.sysPacketsDropped !== void 0 && z.sysPacketsDropped !== 0 && P.uint32(232).uint32(z.sysPacketsDropped), z.sysPacketsOutPerSec !== void 0 && z.sysPacketsOutPerSec !== 0 && P.uint32(245).float(z.sysPacketsOutPerSec), z.sysPacketsDroppedPerSec !== void 0 && z.sysPacketsDroppedPerSec !== 0 && P.uint32(253).float(z.sysPacketsDroppedPerSec), z.sysPacketsDroppedPctPerSec !== void 0 && z.sysPacketsDroppedPctPerSec !== 0 && P.uint32(261).float(z.sysPacketsDroppedPctPerSec), z.retransmitBytesOut !== void 0 && z.retransmitBytesOut !== 0 && P.uint32(176).uint64(z.retransmitBytesOut), z.retransmitPacketsOut !== void 0 && z.retransmitPacketsOut !== 0 && P.uint32(184).uint64(z.retransmitPacketsOut), z.retransmitBytesOutPerSec !== void 0 && z.retransmitBytesOutPerSec !== 0 && P.uint32(197).float(z.retransmitBytesOutPerSec), z.retransmitPacketsOutPerSec !== void 0 && z.retransmitPacketsOutPerSec !== 0 && P.uint32(205).float(z.retransmitPacketsOutPerSec), z.participantJoin !== void 0 && z.participantJoin !== 0 && P.uint32(208).uint64(z.participantJoin), z.participantJoinPerSec !== void 0 && z.participantJoinPerSec !== 0 && P.uint32(221).float(z.participantJoinPerSec), P;
    },
    decode(z, P) {
      const S = z instanceof l.default.Reader ? z : new l.default.Reader(z);
      let E = P === void 0 ? S.len : S.pos + P;
      const I = ae();
      for (; S.pos < E; ) {
        const N = S.uint32();
        switch (N >>> 3) {
          case 1:
            I.startedAt = Ae(S.int64());
            break;
          case 2:
            I.updatedAt = Ae(S.int64());
            break;
          case 3:
            I.numRooms = S.int32();
            break;
          case 4:
            I.numClients = S.int32();
            break;
          case 5:
            I.numTracksIn = S.int32();
            break;
          case 6:
            I.numTracksOut = S.int32();
            break;
          case 7:
            I.bytesIn = Ae(S.uint64());
            break;
          case 8:
            I.bytesOut = Ae(S.uint64());
            break;
          case 9:
            I.packetsIn = Ae(S.uint64());
            break;
          case 10:
            I.packetsOut = Ae(S.uint64());
            break;
          case 11:
            I.nackTotal = Ae(S.uint64());
            break;
          case 12:
            I.bytesInPerSec = S.float();
            break;
          case 13:
            I.bytesOutPerSec = S.float();
            break;
          case 14:
            I.packetsInPerSec = S.float();
            break;
          case 15:
            I.packetsOutPerSec = S.float();
            break;
          case 16:
            I.nackPerSec = S.float();
            break;
          case 17:
            I.numCpus = S.uint32();
            break;
          case 18:
            I.loadAvgLast1min = S.float();
            break;
          case 19:
            I.loadAvgLast5min = S.float();
            break;
          case 20:
            I.loadAvgLast15min = S.float();
            break;
          case 21:
            I.cpuLoad = S.float();
            break;
          case 33:
            I.memoryLoad = S.float();
            break;
          case 28:
            I.sysPacketsOut = S.uint32();
            break;
          case 29:
            I.sysPacketsDropped = S.uint32();
            break;
          case 30:
            I.sysPacketsOutPerSec = S.float();
            break;
          case 31:
            I.sysPacketsDroppedPerSec = S.float();
            break;
          case 32:
            I.sysPacketsDroppedPctPerSec = S.float();
            break;
          case 22:
            I.retransmitBytesOut = Ae(S.uint64());
            break;
          case 23:
            I.retransmitPacketsOut = Ae(S.uint64());
            break;
          case 24:
            I.retransmitBytesOutPerSec = S.float();
            break;
          case 25:
            I.retransmitPacketsOutPerSec = S.float();
            break;
          case 26:
            I.participantJoin = Ae(S.uint64());
            break;
          case 27:
            I.participantJoinPerSec = S.float();
            break;
          default:
            S.skipType(N & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(z) {
      return {
        startedAt: Z(z.startedAt) ? Number(z.startedAt) : 0,
        updatedAt: Z(z.updatedAt) ? Number(z.updatedAt) : 0,
        numRooms: Z(z.numRooms) ? Number(z.numRooms) : 0,
        numClients: Z(z.numClients) ? Number(z.numClients) : 0,
        numTracksIn: Z(z.numTracksIn) ? Number(z.numTracksIn) : 0,
        numTracksOut: Z(z.numTracksOut) ? Number(z.numTracksOut) : 0,
        bytesIn: Z(z.bytesIn) ? Number(z.bytesIn) : 0,
        bytesOut: Z(z.bytesOut) ? Number(z.bytesOut) : 0,
        packetsIn: Z(z.packetsIn) ? Number(z.packetsIn) : 0,
        packetsOut: Z(z.packetsOut) ? Number(z.packetsOut) : 0,
        nackTotal: Z(z.nackTotal) ? Number(z.nackTotal) : 0,
        bytesInPerSec: Z(z.bytesInPerSec) ? Number(z.bytesInPerSec) : 0,
        bytesOutPerSec: Z(z.bytesOutPerSec) ? Number(z.bytesOutPerSec) : 0,
        packetsInPerSec: Z(z.packetsInPerSec) ? Number(z.packetsInPerSec) : 0,
        packetsOutPerSec: Z(z.packetsOutPerSec) ? Number(z.packetsOutPerSec) : 0,
        nackPerSec: Z(z.nackPerSec) ? Number(z.nackPerSec) : 0,
        numCpus: Z(z.numCpus) ? Number(z.numCpus) : 0,
        loadAvgLast1min: Z(z.loadAvgLast1min) ? Number(z.loadAvgLast1min) : 0,
        loadAvgLast5min: Z(z.loadAvgLast5min) ? Number(z.loadAvgLast5min) : 0,
        loadAvgLast15min: Z(z.loadAvgLast15min) ? Number(z.loadAvgLast15min) : 0,
        cpuLoad: Z(z.cpuLoad) ? Number(z.cpuLoad) : 0,
        memoryLoad: Z(z.memoryLoad) ? Number(z.memoryLoad) : 0,
        sysPacketsOut: Z(z.sysPacketsOut) ? Number(z.sysPacketsOut) : 0,
        sysPacketsDropped: Z(z.sysPacketsDropped) ? Number(z.sysPacketsDropped) : 0,
        sysPacketsOutPerSec: Z(z.sysPacketsOutPerSec) ? Number(z.sysPacketsOutPerSec) : 0,
        sysPacketsDroppedPerSec: Z(z.sysPacketsDroppedPerSec) ? Number(z.sysPacketsDroppedPerSec) : 0,
        sysPacketsDroppedPctPerSec: Z(z.sysPacketsDroppedPctPerSec) ? Number(z.sysPacketsDroppedPctPerSec) : 0,
        retransmitBytesOut: Z(z.retransmitBytesOut) ? Number(z.retransmitBytesOut) : 0,
        retransmitPacketsOut: Z(z.retransmitPacketsOut) ? Number(z.retransmitPacketsOut) : 0,
        retransmitBytesOutPerSec: Z(z.retransmitBytesOutPerSec) ? Number(z.retransmitBytesOutPerSec) : 0,
        retransmitPacketsOutPerSec: Z(z.retransmitPacketsOutPerSec) ? Number(z.retransmitPacketsOutPerSec) : 0,
        participantJoin: Z(z.participantJoin) ? Number(z.participantJoin) : 0,
        participantJoinPerSec: Z(z.participantJoinPerSec) ? Number(z.participantJoinPerSec) : 0
      };
    },
    toJSON(z) {
      const P = {};
      return z.startedAt !== void 0 && (P.startedAt = Math.round(z.startedAt)), z.updatedAt !== void 0 && (P.updatedAt = Math.round(z.updatedAt)), z.numRooms !== void 0 && (P.numRooms = Math.round(z.numRooms)), z.numClients !== void 0 && (P.numClients = Math.round(z.numClients)), z.numTracksIn !== void 0 && (P.numTracksIn = Math.round(z.numTracksIn)), z.numTracksOut !== void 0 && (P.numTracksOut = Math.round(z.numTracksOut)), z.bytesIn !== void 0 && (P.bytesIn = Math.round(z.bytesIn)), z.bytesOut !== void 0 && (P.bytesOut = Math.round(z.bytesOut)), z.packetsIn !== void 0 && (P.packetsIn = Math.round(z.packetsIn)), z.packetsOut !== void 0 && (P.packetsOut = Math.round(z.packetsOut)), z.nackTotal !== void 0 && (P.nackTotal = Math.round(z.nackTotal)), z.bytesInPerSec !== void 0 && (P.bytesInPerSec = z.bytesInPerSec), z.bytesOutPerSec !== void 0 && (P.bytesOutPerSec = z.bytesOutPerSec), z.packetsInPerSec !== void 0 && (P.packetsInPerSec = z.packetsInPerSec), z.packetsOutPerSec !== void 0 && (P.packetsOutPerSec = z.packetsOutPerSec), z.nackPerSec !== void 0 && (P.nackPerSec = z.nackPerSec), z.numCpus !== void 0 && (P.numCpus = Math.round(z.numCpus)), z.loadAvgLast1min !== void 0 && (P.loadAvgLast1min = z.loadAvgLast1min), z.loadAvgLast5min !== void 0 && (P.loadAvgLast5min = z.loadAvgLast5min), z.loadAvgLast15min !== void 0 && (P.loadAvgLast15min = z.loadAvgLast15min), z.cpuLoad !== void 0 && (P.cpuLoad = z.cpuLoad), z.memoryLoad !== void 0 && (P.memoryLoad = z.memoryLoad), z.sysPacketsOut !== void 0 && (P.sysPacketsOut = Math.round(z.sysPacketsOut)), z.sysPacketsDropped !== void 0 && (P.sysPacketsDropped = Math.round(z.sysPacketsDropped)), z.sysPacketsOutPerSec !== void 0 && (P.sysPacketsOutPerSec = z.sysPacketsOutPerSec), z.sysPacketsDroppedPerSec !== void 0 && (P.sysPacketsDroppedPerSec = z.sysPacketsDroppedPerSec), z.sysPacketsDroppedPctPerSec !== void 0 && (P.sysPacketsDroppedPctPerSec = z.sysPacketsDroppedPctPerSec), z.retransmitBytesOut !== void 0 && (P.retransmitBytesOut = Math.round(z.retransmitBytesOut)), z.retransmitPacketsOut !== void 0 && (P.retransmitPacketsOut = Math.round(z.retransmitPacketsOut)), z.retransmitBytesOutPerSec !== void 0 && (P.retransmitBytesOutPerSec = z.retransmitBytesOutPerSec), z.retransmitPacketsOutPerSec !== void 0 && (P.retransmitPacketsOutPerSec = z.retransmitPacketsOutPerSec), z.participantJoin !== void 0 && (P.participantJoin = Math.round(z.participantJoin)), z.participantJoinPerSec !== void 0 && (P.participantJoinPerSec = z.participantJoinPerSec), P;
    },
    fromPartial(z) {
      var P, S, E, I, N, $, U, H, B, T, D, ee, pe, Ie, Pe, he, ve, Q, le, _e, re, O, j, ce, De, Ne, Fe, Ze, qe, gt, Xe, Ge, J;
      const ye = ae();
      return ye.startedAt = (P = z.startedAt) !== null && P !== void 0 ? P : 0, ye.updatedAt = (S = z.updatedAt) !== null && S !== void 0 ? S : 0, ye.numRooms = (E = z.numRooms) !== null && E !== void 0 ? E : 0, ye.numClients = (I = z.numClients) !== null && I !== void 0 ? I : 0, ye.numTracksIn = (N = z.numTracksIn) !== null && N !== void 0 ? N : 0, ye.numTracksOut = ($ = z.numTracksOut) !== null && $ !== void 0 ? $ : 0, ye.bytesIn = (U = z.bytesIn) !== null && U !== void 0 ? U : 0, ye.bytesOut = (H = z.bytesOut) !== null && H !== void 0 ? H : 0, ye.packetsIn = (B = z.packetsIn) !== null && B !== void 0 ? B : 0, ye.packetsOut = (T = z.packetsOut) !== null && T !== void 0 ? T : 0, ye.nackTotal = (D = z.nackTotal) !== null && D !== void 0 ? D : 0, ye.bytesInPerSec = (ee = z.bytesInPerSec) !== null && ee !== void 0 ? ee : 0, ye.bytesOutPerSec = (pe = z.bytesOutPerSec) !== null && pe !== void 0 ? pe : 0, ye.packetsInPerSec = (Ie = z.packetsInPerSec) !== null && Ie !== void 0 ? Ie : 0, ye.packetsOutPerSec = (Pe = z.packetsOutPerSec) !== null && Pe !== void 0 ? Pe : 0, ye.nackPerSec = (he = z.nackPerSec) !== null && he !== void 0 ? he : 0, ye.numCpus = (ve = z.numCpus) !== null && ve !== void 0 ? ve : 0, ye.loadAvgLast1min = (Q = z.loadAvgLast1min) !== null && Q !== void 0 ? Q : 0, ye.loadAvgLast5min = (le = z.loadAvgLast5min) !== null && le !== void 0 ? le : 0, ye.loadAvgLast15min = (_e = z.loadAvgLast15min) !== null && _e !== void 0 ? _e : 0, ye.cpuLoad = (re = z.cpuLoad) !== null && re !== void 0 ? re : 0, ye.memoryLoad = (O = z.memoryLoad) !== null && O !== void 0 ? O : 0, ye.sysPacketsOut = (j = z.sysPacketsOut) !== null && j !== void 0 ? j : 0, ye.sysPacketsDropped = (ce = z.sysPacketsDropped) !== null && ce !== void 0 ? ce : 0, ye.sysPacketsOutPerSec = (De = z.sysPacketsOutPerSec) !== null && De !== void 0 ? De : 0, ye.sysPacketsDroppedPerSec = (Ne = z.sysPacketsDroppedPerSec) !== null && Ne !== void 0 ? Ne : 0, ye.sysPacketsDroppedPctPerSec = (Fe = z.sysPacketsDroppedPctPerSec) !== null && Fe !== void 0 ? Fe : 0, ye.retransmitBytesOut = (Ze = z.retransmitBytesOut) !== null && Ze !== void 0 ? Ze : 0, ye.retransmitPacketsOut = (qe = z.retransmitPacketsOut) !== null && qe !== void 0 ? qe : 0, ye.retransmitBytesOutPerSec = (gt = z.retransmitBytesOutPerSec) !== null && gt !== void 0 ? gt : 0, ye.retransmitPacketsOutPerSec = (Xe = z.retransmitPacketsOutPerSec) !== null && Xe !== void 0 ? Xe : 0, ye.participantJoin = (Ge = z.participantJoin) !== null && Ge !== void 0 ? Ge : 0, ye.participantJoinPerSec = (J = z.participantJoinPerSec) !== null && J !== void 0 ? J : 0, ye;
    }
  };
  function ne() {
    return {
      participantKey: "",
      senderTime: 0,
      connectionId: "",
      startSession: void 0,
      request: void 0,
      removeParticipant: void 0,
      muteTrack: void 0,
      updateParticipant: void 0,
      deleteRoom: void 0,
      updateSubscriptions: void 0,
      sendData: void 0,
      updateRoomMetadata: void 0,
      keepAlive: void 0
    };
  }
  a.RTCNodeMessage = {
    encode(z, P = l.default.Writer.create()) {
      return z.participantKey !== void 0 && z.participantKey !== "" && P.uint32(10).string(z.participantKey), z.senderTime !== void 0 && z.senderTime !== 0 && P.uint32(88).int64(z.senderTime), z.connectionId !== void 0 && z.connectionId !== "" && P.uint32(106).string(z.connectionId), z.startSession !== void 0 && a.StartSession.encode(z.startSession, P.uint32(18).fork()).ldelim(), z.request !== void 0 && k.SignalRequest.encode(z.request, P.uint32(26).fork()).ldelim(), z.removeParticipant !== void 0 && _.RoomParticipantIdentity.encode(z.removeParticipant, P.uint32(34).fork()).ldelim(), z.muteTrack !== void 0 && _.MuteRoomTrackRequest.encode(z.muteTrack, P.uint32(42).fork()).ldelim(), z.updateParticipant !== void 0 && _.UpdateParticipantRequest.encode(z.updateParticipant, P.uint32(50).fork()).ldelim(), z.deleteRoom !== void 0 && _.DeleteRoomRequest.encode(z.deleteRoom, P.uint32(58).fork()).ldelim(), z.updateSubscriptions !== void 0 && _.UpdateSubscriptionsRequest.encode(z.updateSubscriptions, P.uint32(66).fork()).ldelim(), z.sendData !== void 0 && _.SendDataRequest.encode(z.sendData, P.uint32(74).fork()).ldelim(), z.updateRoomMetadata !== void 0 && _.UpdateRoomMetadataRequest.encode(z.updateRoomMetadata, P.uint32(82).fork()).ldelim(), z.keepAlive !== void 0 && a.KeepAlive.encode(z.keepAlive, P.uint32(98).fork()).ldelim(), P;
    },
    decode(z, P) {
      const S = z instanceof l.default.Reader ? z : new l.default.Reader(z);
      let E = P === void 0 ? S.len : S.pos + P;
      const I = ne();
      for (; S.pos < E; ) {
        const N = S.uint32();
        switch (N >>> 3) {
          case 1:
            I.participantKey = S.string();
            break;
          case 11:
            I.senderTime = Ae(S.int64());
            break;
          case 13:
            I.connectionId = S.string();
            break;
          case 2:
            I.startSession = a.StartSession.decode(S, S.uint32());
            break;
          case 3:
            I.request = k.SignalRequest.decode(S, S.uint32());
            break;
          case 4:
            I.removeParticipant = _.RoomParticipantIdentity.decode(S, S.uint32());
            break;
          case 5:
            I.muteTrack = _.MuteRoomTrackRequest.decode(S, S.uint32());
            break;
          case 6:
            I.updateParticipant = _.UpdateParticipantRequest.decode(S, S.uint32());
            break;
          case 7:
            I.deleteRoom = _.DeleteRoomRequest.decode(S, S.uint32());
            break;
          case 8:
            I.updateSubscriptions = _.UpdateSubscriptionsRequest.decode(S, S.uint32());
            break;
          case 9:
            I.sendData = _.SendDataRequest.decode(S, S.uint32());
            break;
          case 10:
            I.updateRoomMetadata = _.UpdateRoomMetadataRequest.decode(S, S.uint32());
            break;
          case 12:
            I.keepAlive = a.KeepAlive.decode(S, S.uint32());
            break;
          default:
            S.skipType(N & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(z) {
      return {
        participantKey: Z(z.participantKey) ? String(z.participantKey) : "",
        senderTime: Z(z.senderTime) ? Number(z.senderTime) : 0,
        connectionId: Z(z.connectionId) ? String(z.connectionId) : "",
        startSession: Z(z.startSession) ? a.StartSession.fromJSON(z.startSession) : void 0,
        request: Z(z.request) ? k.SignalRequest.fromJSON(z.request) : void 0,
        removeParticipant: Z(z.removeParticipant) ? _.RoomParticipantIdentity.fromJSON(z.removeParticipant) : void 0,
        muteTrack: Z(z.muteTrack) ? _.MuteRoomTrackRequest.fromJSON(z.muteTrack) : void 0,
        updateParticipant: Z(z.updateParticipant) ? _.UpdateParticipantRequest.fromJSON(z.updateParticipant) : void 0,
        deleteRoom: Z(z.deleteRoom) ? _.DeleteRoomRequest.fromJSON(z.deleteRoom) : void 0,
        updateSubscriptions: Z(z.updateSubscriptions) ? _.UpdateSubscriptionsRequest.fromJSON(z.updateSubscriptions) : void 0,
        sendData: Z(z.sendData) ? _.SendDataRequest.fromJSON(z.sendData) : void 0,
        updateRoomMetadata: Z(z.updateRoomMetadata) ? _.UpdateRoomMetadataRequest.fromJSON(z.updateRoomMetadata) : void 0,
        keepAlive: Z(z.keepAlive) ? a.KeepAlive.fromJSON(z.keepAlive) : void 0
      };
    },
    toJSON(z) {
      const P = {};
      return z.participantKey !== void 0 && (P.participantKey = z.participantKey), z.senderTime !== void 0 && (P.senderTime = Math.round(z.senderTime)), z.connectionId !== void 0 && (P.connectionId = z.connectionId), z.startSession !== void 0 && (P.startSession = z.startSession ? a.StartSession.toJSON(z.startSession) : void 0), z.request !== void 0 && (P.request = z.request ? k.SignalRequest.toJSON(z.request) : void 0), z.removeParticipant !== void 0 && (P.removeParticipant = z.removeParticipant ? _.RoomParticipantIdentity.toJSON(z.removeParticipant) : void 0), z.muteTrack !== void 0 && (P.muteTrack = z.muteTrack ? _.MuteRoomTrackRequest.toJSON(z.muteTrack) : void 0), z.updateParticipant !== void 0 && (P.updateParticipant = z.updateParticipant ? _.UpdateParticipantRequest.toJSON(z.updateParticipant) : void 0), z.deleteRoom !== void 0 && (P.deleteRoom = z.deleteRoom ? _.DeleteRoomRequest.toJSON(z.deleteRoom) : void 0), z.updateSubscriptions !== void 0 && (P.updateSubscriptions = z.updateSubscriptions ? _.UpdateSubscriptionsRequest.toJSON(z.updateSubscriptions) : void 0), z.sendData !== void 0 && (P.sendData = z.sendData ? _.SendDataRequest.toJSON(z.sendData) : void 0), z.updateRoomMetadata !== void 0 && (P.updateRoomMetadata = z.updateRoomMetadata ? _.UpdateRoomMetadataRequest.toJSON(z.updateRoomMetadata) : void 0), z.keepAlive !== void 0 && (P.keepAlive = z.keepAlive ? a.KeepAlive.toJSON(z.keepAlive) : void 0), P;
    },
    fromPartial(z) {
      var P, S, E;
      const I = ne();
      return I.participantKey = (P = z.participantKey) !== null && P !== void 0 ? P : "", I.senderTime = (S = z.senderTime) !== null && S !== void 0 ? S : 0, I.connectionId = (E = z.connectionId) !== null && E !== void 0 ? E : "", I.startSession = z.startSession !== void 0 && z.startSession !== null ? a.StartSession.fromPartial(z.startSession) : void 0, I.request = z.request !== void 0 && z.request !== null ? k.SignalRequest.fromPartial(z.request) : void 0, I.removeParticipant = z.removeParticipant !== void 0 && z.removeParticipant !== null ? _.RoomParticipantIdentity.fromPartial(z.removeParticipant) : void 0, I.muteTrack = z.muteTrack !== void 0 && z.muteTrack !== null ? _.MuteRoomTrackRequest.fromPartial(z.muteTrack) : void 0, I.updateParticipant = z.updateParticipant !== void 0 && z.updateParticipant !== null ? _.UpdateParticipantRequest.fromPartial(z.updateParticipant) : void 0, I.deleteRoom = z.deleteRoom !== void 0 && z.deleteRoom !== null ? _.DeleteRoomRequest.fromPartial(z.deleteRoom) : void 0, I.updateSubscriptions = z.updateSubscriptions !== void 0 && z.updateSubscriptions !== null ? _.UpdateSubscriptionsRequest.fromPartial(z.updateSubscriptions) : void 0, I.sendData = z.sendData !== void 0 && z.sendData !== null ? _.SendDataRequest.fromPartial(z.sendData) : void 0, I.updateRoomMetadata = z.updateRoomMetadata !== void 0 && z.updateRoomMetadata !== null ? _.UpdateRoomMetadataRequest.fromPartial(z.updateRoomMetadata) : void 0, I.keepAlive = z.keepAlive !== void 0 && z.keepAlive !== null ? a.KeepAlive.fromPartial(z.keepAlive) : void 0, I;
    }
  };
  function fe() {
    return { connectionId: "", response: void 0, endSession: void 0 };
  }
  a.SignalNodeMessage = {
    encode(z, P = l.default.Writer.create()) {
      return z.connectionId !== void 0 && z.connectionId !== "" && P.uint32(10).string(z.connectionId), z.response !== void 0 && k.SignalResponse.encode(z.response, P.uint32(18).fork()).ldelim(), z.endSession !== void 0 && a.EndSession.encode(z.endSession, P.uint32(26).fork()).ldelim(), P;
    },
    decode(z, P) {
      const S = z instanceof l.default.Reader ? z : new l.default.Reader(z);
      let E = P === void 0 ? S.len : S.pos + P;
      const I = fe();
      for (; S.pos < E; ) {
        const N = S.uint32();
        switch (N >>> 3) {
          case 1:
            I.connectionId = S.string();
            break;
          case 2:
            I.response = k.SignalResponse.decode(S, S.uint32());
            break;
          case 3:
            I.endSession = a.EndSession.decode(S, S.uint32());
            break;
          default:
            S.skipType(N & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(z) {
      return {
        connectionId: Z(z.connectionId) ? String(z.connectionId) : "",
        response: Z(z.response) ? k.SignalResponse.fromJSON(z.response) : void 0,
        endSession: Z(z.endSession) ? a.EndSession.fromJSON(z.endSession) : void 0
      };
    },
    toJSON(z) {
      const P = {};
      return z.connectionId !== void 0 && (P.connectionId = z.connectionId), z.response !== void 0 && (P.response = z.response ? k.SignalResponse.toJSON(z.response) : void 0), z.endSession !== void 0 && (P.endSession = z.endSession ? a.EndSession.toJSON(z.endSession) : void 0), P;
    },
    fromPartial(z) {
      var P;
      const S = fe();
      return S.connectionId = (P = z.connectionId) !== null && P !== void 0 ? P : "", S.response = z.response !== void 0 && z.response !== null ? k.SignalResponse.fromPartial(z.response) : void 0, S.endSession = z.endSession !== void 0 && z.endSession !== null ? a.EndSession.fromPartial(z.endSession) : void 0, S;
    }
  };
  function ie() {
    return {
      roomName: "",
      identity: "",
      connectionId: "",
      reconnect: !1,
      autoSubscribe: !1,
      hidden: !1,
      client: void 0,
      recorder: !1,
      name: "",
      grantsJson: "",
      adaptiveStream: !1,
      participantId: ""
    };
  }
  a.StartSession = {
    encode(z, P = l.default.Writer.create()) {
      return z.roomName !== void 0 && z.roomName !== "" && P.uint32(10).string(z.roomName), z.identity !== void 0 && z.identity !== "" && P.uint32(18).string(z.identity), z.connectionId !== void 0 && z.connectionId !== "" && P.uint32(26).string(z.connectionId), z.reconnect === !0 && P.uint32(32).bool(z.reconnect), z.autoSubscribe === !0 && P.uint32(72).bool(z.autoSubscribe), z.hidden === !0 && P.uint32(80).bool(z.hidden), z.client !== void 0 && p.ClientInfo.encode(z.client, P.uint32(90).fork()).ldelim(), z.recorder === !0 && P.uint32(96).bool(z.recorder), z.name !== void 0 && z.name !== "" && P.uint32(106).string(z.name), z.grantsJson !== void 0 && z.grantsJson !== "" && P.uint32(114).string(z.grantsJson), z.adaptiveStream === !0 && P.uint32(120).bool(z.adaptiveStream), z.participantId !== void 0 && z.participantId !== "" && P.uint32(130).string(z.participantId), P;
    },
    decode(z, P) {
      const S = z instanceof l.default.Reader ? z : new l.default.Reader(z);
      let E = P === void 0 ? S.len : S.pos + P;
      const I = ie();
      for (; S.pos < E; ) {
        const N = S.uint32();
        switch (N >>> 3) {
          case 1:
            I.roomName = S.string();
            break;
          case 2:
            I.identity = S.string();
            break;
          case 3:
            I.connectionId = S.string();
            break;
          case 4:
            I.reconnect = S.bool();
            break;
          case 9:
            I.autoSubscribe = S.bool();
            break;
          case 10:
            I.hidden = S.bool();
            break;
          case 11:
            I.client = p.ClientInfo.decode(S, S.uint32());
            break;
          case 12:
            I.recorder = S.bool();
            break;
          case 13:
            I.name = S.string();
            break;
          case 14:
            I.grantsJson = S.string();
            break;
          case 15:
            I.adaptiveStream = S.bool();
            break;
          case 16:
            I.participantId = S.string();
            break;
          default:
            S.skipType(N & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(z) {
      return {
        roomName: Z(z.roomName) ? String(z.roomName) : "",
        identity: Z(z.identity) ? String(z.identity) : "",
        connectionId: Z(z.connectionId) ? String(z.connectionId) : "",
        reconnect: Z(z.reconnect) ? !!z.reconnect : !1,
        autoSubscribe: Z(z.autoSubscribe) ? !!z.autoSubscribe : !1,
        hidden: Z(z.hidden) ? !!z.hidden : !1,
        client: Z(z.client) ? p.ClientInfo.fromJSON(z.client) : void 0,
        recorder: Z(z.recorder) ? !!z.recorder : !1,
        name: Z(z.name) ? String(z.name) : "",
        grantsJson: Z(z.grantsJson) ? String(z.grantsJson) : "",
        adaptiveStream: Z(z.adaptiveStream) ? !!z.adaptiveStream : !1,
        participantId: Z(z.participantId) ? String(z.participantId) : ""
      };
    },
    toJSON(z) {
      const P = {};
      return z.roomName !== void 0 && (P.roomName = z.roomName), z.identity !== void 0 && (P.identity = z.identity), z.connectionId !== void 0 && (P.connectionId = z.connectionId), z.reconnect !== void 0 && (P.reconnect = z.reconnect), z.autoSubscribe !== void 0 && (P.autoSubscribe = z.autoSubscribe), z.hidden !== void 0 && (P.hidden = z.hidden), z.client !== void 0 && (P.client = z.client ? p.ClientInfo.toJSON(z.client) : void 0), z.recorder !== void 0 && (P.recorder = z.recorder), z.name !== void 0 && (P.name = z.name), z.grantsJson !== void 0 && (P.grantsJson = z.grantsJson), z.adaptiveStream !== void 0 && (P.adaptiveStream = z.adaptiveStream), z.participantId !== void 0 && (P.participantId = z.participantId), P;
    },
    fromPartial(z) {
      var P, S, E, I, N, $, U, H, B, T, D;
      const ee = ie();
      return ee.roomName = (P = z.roomName) !== null && P !== void 0 ? P : "", ee.identity = (S = z.identity) !== null && S !== void 0 ? S : "", ee.connectionId = (E = z.connectionId) !== null && E !== void 0 ? E : "", ee.reconnect = (I = z.reconnect) !== null && I !== void 0 ? I : !1, ee.autoSubscribe = (N = z.autoSubscribe) !== null && N !== void 0 ? N : !1, ee.hidden = ($ = z.hidden) !== null && $ !== void 0 ? $ : !1, ee.client = z.client !== void 0 && z.client !== null ? p.ClientInfo.fromPartial(z.client) : void 0, ee.recorder = (U = z.recorder) !== null && U !== void 0 ? U : !1, ee.name = (H = z.name) !== null && H !== void 0 ? H : "", ee.grantsJson = (B = z.grantsJson) !== null && B !== void 0 ? B : "", ee.adaptiveStream = (T = z.adaptiveStream) !== null && T !== void 0 ? T : !1, ee.participantId = (D = z.participantId) !== null && D !== void 0 ? D : "", ee;
    }
  };
  function ge() {
    return {};
  }
  a.EndSession = {
    encode(z, P = l.default.Writer.create()) {
      return P;
    },
    decode(z, P) {
      const S = z instanceof l.default.Reader ? z : new l.default.Reader(z);
      let E = P === void 0 ? S.len : S.pos + P;
      const I = ge();
      for (; S.pos < E; ) {
        const N = S.uint32();
        switch (N >>> 3) {
          default:
            S.skipType(N & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(z) {
      return {};
    },
    toJSON(z) {
      return {};
    },
    fromPartial(z) {
      return ge();
    }
  };
  function be() {
    return { participantId: "" };
  }
  a.RemoveParticipant = {
    encode(z, P = l.default.Writer.create()) {
      return z.participantId !== void 0 && z.participantId !== "" && P.uint32(10).string(z.participantId), P;
    },
    decode(z, P) {
      const S = z instanceof l.default.Reader ? z : new l.default.Reader(z);
      let E = P === void 0 ? S.len : S.pos + P;
      const I = be();
      for (; S.pos < E; ) {
        const N = S.uint32();
        switch (N >>> 3) {
          case 1:
            I.participantId = S.string();
            break;
          default:
            S.skipType(N & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(z) {
      return { participantId: Z(z.participantId) ? String(z.participantId) : "" };
    },
    toJSON(z) {
      const P = {};
      return z.participantId !== void 0 && (P.participantId = z.participantId), P;
    },
    fromPartial(z) {
      var P;
      const S = be();
      return S.participantId = (P = z.participantId) !== null && P !== void 0 ? P : "", S;
    }
  };
  function Ce() {
    return {};
  }
  a.KeepAlive = {
    encode(z, P = l.default.Writer.create()) {
      return P;
    },
    decode(z, P) {
      const S = z instanceof l.default.Reader ? z : new l.default.Reader(z);
      let E = P === void 0 ? S.len : S.pos + P;
      const I = Ce();
      for (; S.pos < E; ) {
        const N = S.uint32();
        switch (N >>> 3) {
          default:
            S.skipType(N & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(z) {
      return {};
    },
    toJSON(z) {
      return {};
    },
    fromPartial(z) {
      return Ce();
    }
  };
  function Me() {
    return { trackEgress: void 0 };
  }
  a.RoomInternal = {
    encode(z, P = l.default.Writer.create()) {
      return z.trackEgress !== void 0 && v.AutoTrackEgress.encode(z.trackEgress, P.uint32(10).fork()).ldelim(), P;
    },
    decode(z, P) {
      const S = z instanceof l.default.Reader ? z : new l.default.Reader(z);
      let E = P === void 0 ? S.len : S.pos + P;
      const I = Me();
      for (; S.pos < E; ) {
        const N = S.uint32();
        switch (N >>> 3) {
          case 1:
            I.trackEgress = v.AutoTrackEgress.decode(S, S.uint32());
            break;
          default:
            S.skipType(N & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(z) {
      return { trackEgress: Z(z.trackEgress) ? v.AutoTrackEgress.fromJSON(z.trackEgress) : void 0 };
    },
    toJSON(z) {
      const P = {};
      return z.trackEgress !== void 0 && (P.trackEgress = z.trackEgress ? v.AutoTrackEgress.toJSON(z.trackEgress) : void 0), P;
    },
    fromPartial(z) {
      const P = Me();
      return P.trackEgress = z.trackEgress !== void 0 && z.trackEgress !== null ? v.AutoTrackEgress.fromPartial(z.trackEgress) : void 0, P;
    }
  };
  var Be = (() => {
    if (typeof Be < "u")
      return Be;
    if (typeof self < "u")
      return self;
    if (typeof window < "u")
      return window;
    if (typeof commonjsGlobal$1 < "u")
      return commonjsGlobal$1;
    throw "Unable to locate global object";
  })();
  function Ae(z) {
    if (z.gt(Number.MAX_SAFE_INTEGER))
      throw new Be.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    return z.toNumber();
  }
  l.default.util.Long !== c.default && (l.default.util.Long = c.default, l.default.configure());
  function Z(z) {
    return z != null;
  }
})(livekit_internal);
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(M, L, F, V) {
    V === void 0 && (V = F), Object.defineProperty(M, V, { enumerable: !0, get: function() {
      return L[F];
    } });
  } : function(M, L, F, V) {
    V === void 0 && (V = F), M[V] = L[F];
  }), c = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(M, L) {
    Object.defineProperty(M, "default", { enumerable: !0, value: L });
  } : function(M, L) {
    M.default = L;
  }), l = commonjsGlobal$1 && commonjsGlobal$1.__exportStar || function(M, L) {
    for (var F in M)
      F !== "default" && !Object.prototype.hasOwnProperty.call(L, F) && u(L, M, F);
  }, v = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(M) {
    if (M && M.__esModule)
      return M;
    var L = {};
    if (M != null)
      for (var F in M)
        F !== "default" && Object.prototype.hasOwnProperty.call(M, F) && u(L, M, F);
    return c(L, M), L;
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.LivekitInternal = a.TrackType = a.TrackInfo = a.Room = a.ParticipantPermission = a.ParticipantInfo_State = a.ParticipantInfo = a.DataPacket_Kind = a.IngressVideoOptions = a.IngressState = a.IngressInput = a.IngressInfo = a.IngressAudioOptions = a.StreamProtocol = a.StreamOutput = a.SegmentedFileProtocol = a.SegmentedFileOutput = a.EncodingOptionsPreset = a.EncodingOptions = a.EncodedFileType = a.EncodedFileOutput = a.EgressInfo = a.DirectFileOutput = void 0, l(AccessToken$1, a), l(EgressClient$1, a), l(grants, a), l(IngressClient$1, a);
  var p = livekit_egress;
  Object.defineProperty(a, "DirectFileOutput", { enumerable: !0, get: function() {
    return p.DirectFileOutput;
  } }), Object.defineProperty(a, "EgressInfo", { enumerable: !0, get: function() {
    return p.EgressInfo;
  } }), Object.defineProperty(a, "EncodedFileOutput", { enumerable: !0, get: function() {
    return p.EncodedFileOutput;
  } }), Object.defineProperty(a, "EncodedFileType", { enumerable: !0, get: function() {
    return p.EncodedFileType;
  } }), Object.defineProperty(a, "EncodingOptions", { enumerable: !0, get: function() {
    return p.EncodingOptions;
  } }), Object.defineProperty(a, "EncodingOptionsPreset", { enumerable: !0, get: function() {
    return p.EncodingOptionsPreset;
  } }), Object.defineProperty(a, "SegmentedFileOutput", { enumerable: !0, get: function() {
    return p.SegmentedFileOutput;
  } }), Object.defineProperty(a, "SegmentedFileProtocol", { enumerable: !0, get: function() {
    return p.SegmentedFileProtocol;
  } }), Object.defineProperty(a, "StreamOutput", { enumerable: !0, get: function() {
    return p.StreamOutput;
  } }), Object.defineProperty(a, "StreamProtocol", { enumerable: !0, get: function() {
    return p.StreamProtocol;
  } });
  var _ = livekit_ingress;
  Object.defineProperty(a, "IngressAudioOptions", { enumerable: !0, get: function() {
    return _.IngressAudioOptions;
  } }), Object.defineProperty(a, "IngressInfo", { enumerable: !0, get: function() {
    return _.IngressInfo;
  } }), Object.defineProperty(a, "IngressInput", { enumerable: !0, get: function() {
    return _.IngressInput;
  } }), Object.defineProperty(a, "IngressState", { enumerable: !0, get: function() {
    return _.IngressState;
  } }), Object.defineProperty(a, "IngressVideoOptions", { enumerable: !0, get: function() {
    return _.IngressVideoOptions;
  } });
  var k = livekit_models;
  Object.defineProperty(a, "DataPacket_Kind", { enumerable: !0, get: function() {
    return k.DataPacket_Kind;
  } }), Object.defineProperty(a, "ParticipantInfo", { enumerable: !0, get: function() {
    return k.ParticipantInfo;
  } }), Object.defineProperty(a, "ParticipantInfo_State", { enumerable: !0, get: function() {
    return k.ParticipantInfo_State;
  } }), Object.defineProperty(a, "ParticipantPermission", { enumerable: !0, get: function() {
    return k.ParticipantPermission;
  } }), Object.defineProperty(a, "Room", { enumerable: !0, get: function() {
    return k.Room;
  } }), Object.defineProperty(a, "TrackInfo", { enumerable: !0, get: function() {
    return k.TrackInfo;
  } }), Object.defineProperty(a, "TrackType", { enumerable: !0, get: function() {
    return k.TrackType;
  } }), l(RoomServiceClient$1, a), l(WebhookReceiver$1, a), a.LivekitInternal = v(livekit_internal);
})(dist);
class InvalidTokenError extends Error {
}
InvalidTokenError.prototype.name = "InvalidTokenError";
function b64DecodeUnicode(a) {
  return decodeURIComponent(atob(a).replace(/(.)/g, (u, c) => {
    let l = c.charCodeAt(0).toString(16).toUpperCase();
    return l.length < 2 && (l = "0" + l), "%" + l;
  }));
}
function base64UrlDecode(a) {
  let u = a.replace(/-/g, "+").replace(/_/g, "/");
  switch (u.length % 4) {
    case 0:
      break;
    case 2:
      u += "==";
      break;
    case 3:
      u += "=";
      break;
    default:
      throw new Error("base64 string is not of the correct length");
  }
  try {
    return b64DecodeUnicode(u);
  } catch {
    return atob(u);
  }
}
function jwtDecode(a, u) {
  if (typeof a != "string")
    throw new InvalidTokenError("Invalid token specified: must be a string");
  u || (u = {});
  const c = u.header === !0 ? 0 : 1, l = a.split(".")[c];
  if (typeof l != "string")
    throw new InvalidTokenError(`Invalid token specified: missing part #${c + 1}`);
  let v;
  try {
    v = base64UrlDecode(l);
  } catch (p) {
    throw new InvalidTokenError(`Invalid token specified: invalid base64 for part #${c + 1} (${p.message})`);
  }
  try {
    return JSON.parse(v);
  } catch (p) {
    throw new InvalidTokenError(`Invalid token specified: invalid json for part #${c + 1} (${p.message})`);
  }
}
var DataType = /* @__PURE__ */ ((a) => (a.ChatMessage = "ChatMessage", a.ParticipantMetadataUpdate = "ParticipantMetadataUpdate", a))(DataType || {}), SpecialEvent = /* @__PURE__ */ ((a) => (a.Chat = "Chat", a))(SpecialEvent || {});
const decoder$1 = new TextDecoder(), encoder$1 = new TextEncoder();
class RoomsManager {
  constructor() {
    Ft(this, "rooms");
    this.rooms = /* @__PURE__ */ new Map(), this.addRoom = this.addRoom.bind(this), this.ensureRoom = this.ensureRoom.bind(this), this.removeRoom = this.removeRoom.bind(this);
  }
  addRoom(u, c, l) {
    const v = new RoomContext(u, c, l, this);
    return this.rooms.set(c, v), v;
  }
  ensureRoom(u, c, l) {
    return this.rooms.get(c) ? (this.rooms.get(c).token = l, this.rooms.get(c)) : this.addRoom(u, c, l);
  }
  async removeRoom(u) {
    const c = this.rooms.get(u);
    if (!Room)
      throw new Error("room not found!");
    if (c.isConnecting)
      throw new Error("Cannot remove room: Room is in connecting state");
    c.livekitRoom && await c.livekitRoom.disconnect(!0), this.rooms.delete(u);
  }
}
class RoomContext {
  /**
   * @param baseUrl base url for the webrtc server
   * @param token get
   */
  constructor(u, c, l, v) {
    /**
     * base URL for the webrtc server
     */
    Ft(this, "_baseUrl");
    Ft(this, "_chatHistory");
    /**
     * event listeners just for livekit room connect
     */
    Ft(this, "_connectListeners");
    /**
     * Event listeners that are registered OR to be registered upon connection
     * Keys are of type RoomEvent
     */
    Ft(this, "_roomEventListenerRegistry");
    /**
     * Event listeners that are registered OR to be registered on the localParticipant upon connection
     * Keys are of type ParticipantEvent
     */
    Ft(this, "_localParticipantEventListenerRegistry");
    /**
     * Registry for special/custom events such as chat events
     */
    Ft(this, "_specialEventListenerRegistry");
    /**
     * access token for our connection
     * Should be acquired from vapi
     */
    Ft(this, "_jwt");
    /**
     * reference to the rooms manager that contains it
     */
    Ft(this, "_manager");
    Ft(this, "_apiClient");
    Ft(this, "audioTracks");
    Ft(this, "isConnecting");
    Ft(this, "livekitRoom");
    Ft(this, "participants");
    Ft(this, "guestParticipantMetadata");
    Ft(this, "roomName");
    /**
     * Livekit Room Service client, for performing admin functions
     * Should only be defined if user is room admin
     */
    Ft(this, "_admin");
    let p = CoreContext.logLevel.toLowerCase();
    setLogLevel(p), this.livekitRoom = new Room({
      // automatically manage subscribed video quality
      // adaptiveStream: true,
      // optimize publishing bandwidth and CPU for published tracks
      dynacast: !0,
      // default capture settings
      videoCaptureDefaults: {
        resolution: VideoPresets.h720.resolution
      }
    }), this._baseUrl = u, this._connectListeners = [], this._roomEventListenerRegistry = {}, this._jwt = l, Object.values(RoomEvent).forEach((_) => {
      this._roomEventListenerRegistry[_] = /* @__PURE__ */ new Set();
    }), this._localParticipantEventListenerRegistry = {}, Object.values(ParticipantEvent).forEach((_) => {
      this._localParticipantEventListenerRegistry[_] = /* @__PURE__ */ new Set();
    }), this._specialEventListenerRegistry = {}, this._manager = v, this._chatHistory = [], this.roomName = c, this.audioTracks = [], this.participants = [], this.guestParticipantMetadata = [], this.isConnecting = !1, this.subscribeToRoomEvent(RoomEvent.DataReceived, (_, k) => {
      var F;
      const M = decoder$1.decode(_);
      switch (JSON.parse(M).type) {
        case "ChatMessage":
          return this._appendChat(_, k);
        case "ParticipantMetadataUpdate": {
          const V = decoder$1.decode(_), X = JSON.parse(V);
          hasPermission((F = X == null ? void 0 : X.metadata) == null ? void 0 : F.participantRole, Permission.ManageSelf) && this._updateGuestParticipantsStore(X);
          return;
        }
        default:
          return;
      }
    }), this.connect = this.connect.bind(this), this.subscribeToRoomEvent = this.subscribeToRoomEvent.bind(this), this.subscribeToConnect = this.subscribeToConnect.bind(this), this.subscribeToLocalParticipantEvent = this.subscribeToLocalParticipantEvent.bind(this), this.subscribeToSpecialEvent = this.subscribeToSpecialEvent.bind(this), this.unsubscribeFromRoomEvent = this.unsubscribeFromRoomEvent.bind(this), this.unsubscribeFromSpecialEvent = this.unsubscribeFromSpecialEvent.bind(this), this.unsubscribeFromConnect = this.unsubscribeFromConnect.bind(this), this.unsubscribeFromLocalParticipantEvent = this.unsubscribeFromLocalParticipantEvent.bind(this), this.sendChatMessage = this.sendChatMessage.bind(this), this.kickParticipant = this.kickParticipant.bind(this), this.updateParticipant = this.updateParticipant.bind(this), this.muteTrackAsAdmin = this.muteTrackAsAdmin.bind(this), this._updateParticipants = this._updateParticipants.bind(this), this.subscribeToRoomEvent(RoomEvent.ParticipantConnected, this._updateParticipants), this.subscribeToRoomEvent(RoomEvent.ParticipantDisconnected, this._updateParticipants), this.subscribeToRoomEvent(RoomEvent.TrackSubscribed, this._updateParticipants), this.subscribeToRoomEvent(RoomEvent.TrackUnsubscribed, this._updateParticipants), this.subscribeToRoomEvent(RoomEvent.LocalTrackPublished, this._updateParticipants), this.subscribeToRoomEvent(RoomEvent.LocalTrackUnpublished, this._updateParticipants), this.subscribeToRoomEvent(RoomEvent.Disconnected, () => {
      this._updateParticipants();
    }), this.subscribeToRoomEvent(RoomEvent.ParticipantMetadataChanged, (_, k) => {
      if (_ !== (k == null ? void 0 : k.metadata)) {
        const M = JSON.parse(k == null ? void 0 : k.metadata);
        if (hasPermission(M == null ? void 0 : M.participantRole, Permission.ManageSelf)) {
          if (M.hasOwnProperty("isMirrored")) {
            const L = {
              participantId: k == null ? void 0 : k.identity,
              metadata: M,
              type: "ParticipantMetadataUpdate"
              /* ParticipantMetadataUpdate */
            };
            this._updateGuestParticipantsStore(L);
          }
          return;
        }
      }
    });
  }
  bindApiClient(u) {
    this._apiClient = u;
  }
  get isAdmin() {
    return jwtDecode(this._jwt).video.roomAdmin;
  }
  set isAdmin(u) {
    log.warn("isAdmin cannot be set");
  }
  get token() {
    return this._jwt;
  }
  set token(u) {
    this._jwt = u;
  }
  get url() {
    return this._baseUrl;
  }
  set url(u) {
  }
  get chatHistory() {
    return this._chatHistory;
  }
  set chatHistory(u) {
    this._chatHistory = u;
  }
  _updateGuestParticipantsStore(u) {
    if (!this.guestParticipantMetadata.length)
      this.guestParticipantMetadata.push(u);
    else {
      const c = this.guestParticipantMetadata.findIndex((l) => l.participantId === (u == null ? void 0 : u.participantId));
      c > -1 ? this.guestParticipantMetadata[c] = u : this.guestParticipantMetadata.push(u);
    }
  }
  _updateParticipants() {
    if (!this.livekitRoom || this.livekitRoom.state === ConnectionState.Disconnected) {
      this.participants = [];
      return;
    } else {
      const u = Array.from(this.livekitRoom.remoteParticipants.values()), c = [this.livekitRoom.localParticipant];
      c.push(...u), this.guestParticipantMetadata = this.guestParticipantMetadata.filter((l) => c.find((v) => (v == null ? void 0 : v.identity) === (l == null ? void 0 : l.participantId))), this.participants = c;
    }
  }
  /**
   * @param identity Identity of the user that you wish to kick
   */
  async kickParticipant(u) {
    if (this._admin)
      this._admin.removeParticipant(this.roomName, u);
    else
      throw new Error("no admin permissions");
  }
  updateParticipant(u, c) {
    if (this._admin) {
      const l = JSON.stringify(c);
      this._admin.updateParticipant(this.roomName, u, l);
    } else
      throw new Error("no admin permissions");
  }
  muteTrackAsAdmin(u, c = !0) {
    if (this._admin) {
      const l = this.participants.find((v) => [...v.audioTrackPublications.values(), ...v.videoTrackPublications.values()].find((p) => p.trackSid === u));
      if (!l) {
        log.warn("Could not find participant for track:", {
          trackSid: u
        });
        return;
      }
      this._admin.mutePublishedTrack(this.roomName, l == null ? void 0 : l.identity, u, c);
    } else
      throw new Error("no admin permissions");
  }
  _appendChat(u, c) {
    const l = decoder$1.decode(u), v = JSON.parse(l), p = c.identity, _ = c.name, k = {
      ...v,
      displayName: _,
      sender: p
    };
    this.chatHistory = [...this.chatHistory, k], this._triggerSpecialEvents("Chat", k);
  }
  subscribeToConnect(u) {
    return this._connectListeners.push(u), () => this.unsubscribeFromConnect(u);
  }
  unsubscribeFromConnect(u) {
    this._connectListeners = this._connectListeners.filter((c) => c !== u);
  }
  subscribeToSpecialEvent(u, c) {
    return this._specialEventListenerRegistry[u] || (this._specialEventListenerRegistry[u] = /* @__PURE__ */ new Set()), this._specialEventListenerRegistry[u].add(c), () => {
      this.unsubscribeFromSpecialEvent(u, c);
    };
  }
  unsubscribeFromSpecialEvent(u, c) {
    this._specialEventListenerRegistry[u] || (this._specialEventListenerRegistry[u] = /* @__PURE__ */ new Set()), this._specialEventListenerRegistry[u].delete(c);
  }
  _triggerSpecialEvents(u, ...c) {
    this._specialEventListenerRegistry[u] || (this._specialEventListenerRegistry[u] = /* @__PURE__ */ new Set()), this._specialEventListenerRegistry[u].forEach((l) => {
      l(...c);
    });
  }
  /**
   * connect to livekit webrtc room
   * @param {string} identity unique user name to be displayed to other users
   */
  async connect(u = {}) {
    var c, l;
    try {
      if (this.livekitRoom.state === "connected" || this.isConnecting)
        return;
      this.isConnecting = !0, await this.livekitRoom.connect(`wss://${this._baseUrl}`, this._jwt, {
        ...u
      }), this.isConnecting = !1, Object.values(RoomEvent).forEach((v) => {
        this.livekitRoom.on(v, (...p) => {
          this._roomEventListenerRegistry[v].forEach((_) => {
            _(...p);
          });
        });
      }), Object.values(ParticipantEvent).forEach((v) => {
        this.livekitRoom.localParticipant.on(v, (...p) => {
          this._localParticipantEventListenerRegistry[v].forEach((_) => {
            _(...p);
          });
        });
      }), this._updateParticipants(), this._connectListeners.forEach((v) => v(this.livekitRoom)), lib$2.LiveKitUtils.isRoomAdmin(this._jwt) ? (log.info("Room: Granting admin permissions"), log.debug("Livekit server: ", (c = this._apiClient) == null ? void 0 : c.getLiveKitServer(!0)), this._admin = new dist.RoomServiceClient((l = this._apiClient) == null ? void 0 : l.getLiveKitServer(!0), void 0, void 0, this._jwt)) : log.debug("Room: Not an admin");
    } catch (v) {
      this.isConnecting = !1, log.error(v);
    }
  }
  subscribeToLocalParticipantEvent(u, c) {
    return this._localParticipantEventListenerRegistry[u] || (this._localParticipantEventListenerRegistry[u] = /* @__PURE__ */ new Set()), this._localParticipantEventListenerRegistry[u].add(c), () => {
      this.unsubscribeFromLocalParticipantEvent(u, c);
    };
  }
  unsubscribeFromLocalParticipantEvent(u, c) {
    this._localParticipantEventListenerRegistry[u] || (this._localParticipantEventListenerRegistry[u] = /* @__PURE__ */ new Set()), this._localParticipantEventListenerRegistry[u].delete(c);
  }
  subscribeToRoomEvent(u, c) {
    return this._roomEventListenerRegistry[u] || (this._roomEventListenerRegistry[u] = /* @__PURE__ */ new Set()), this._roomEventListenerRegistry[u].add(c), () => {
      this.unsubscribeFromRoomEvent(u, c);
    };
  }
  unsubscribeFromRoomEvent(u, c) {
    this._roomEventListenerRegistry[u] || (this._roomEventListenerRegistry[u] = /* @__PURE__ */ new Set()), this._roomEventListenerRegistry[u].delete(c);
  }
  /**
   * Sends chat message to entire livekit room, or a private message (if specified) from local participant
   * @param {string[]} [recipients] The identities of the recipient participants. If undefined, will send message to all participants in the chat.
   * Only specify for private messages.
   * Do not include the local participant's identity in this.
   */
  sendChatMessage(u) {
    const {
      message: c,
      recipients: l,
      metadata: v
    } = u;
    if (!this.livekitRoom || this.livekitRoom.state !== "connected")
      return;
    const p = {
      type: "ChatMessage",
      recipients: l,
      metadata: v,
      content: c,
      timestamp: Date.now()
    }, _ = JSON.stringify(p), k = encoder$1.encode(_);
    if ({
      ...p,
      sender: this.livekitRoom.localParticipant.identity,
      displayName: this.livekitRoom.localParticipant.identity
    }, l) {
      const M = l.map(this.livekitRoom.getParticipantByIdentity);
      return this.livekitRoom.localParticipant.publishData(k, {
        reliable: !0,
        destinationIdentities: M.map((L) => L.identity)
      }).then(() => {
        this._appendChat(k, this.livekitRoom.localParticipant);
      });
    } else
      return this.livekitRoom.localParticipant.publishData(k, {
        reliable: !0
      }).then(() => {
        this._appendChat(k, this.livekitRoom.localParticipant);
      });
  }
}
const webrtcManager = new RoomsManager(), index$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  webrtcManager
}, Symbol.toStringTag, { value: "Module" })), encoder = new TextEncoder(), decoder = new TextDecoder(), simpleRooms = /* @__PURE__ */ new Map(), getRoom = (a) => {
  if (!a)
    return null;
  if (simpleRooms.get(a))
    return simpleRooms.get(a);
  const u = webrtcManager.rooms.get(a);
  if (!u)
    return null;
  const c = u.livekitRoom, l = c == null ? void 0 : c.localParticipant;
  window.__StudioRoom = c, l || log.warn("No local participant!");
  const v = {
    useTracks: /* @__PURE__ */ new Set(),
    useTrack: /* @__PURE__ */ new Map(),
    useParticipants: /* @__PURE__ */ new Set(),
    useParticipant: /* @__PURE__ */ new Map(),
    useChatHistory: /* @__PURE__ */ new Set()
  };
  let p = {
    tracks: [],
    participants: [],
    result: {
      participants: [],
      tracks: []
    },
    chat: u.chatHistory
  };
  const _ = () => {
    const ae = u.participants, ne = u.guestParticipantMetadata, fe = ae.flatMap((ge) => ge.getTrackPublications().map((be) => ({
      ...be,
      participant: ge
    }))), ie = {
      participants: ae.map((ge) => {
        const be = ne.find((Me) => Me.participantId === ge.identity);
        if (be) {
          let Me = JSON.parse(ge.metadata);
          Me = {
            ...Me,
            ...be.metadata
          }, ge.metadata = JSON.stringify(Me);
        }
        const Ce = JSON.parse(ge.metadata);
        return {
          id: ge.identity,
          isSelf: ge === l,
          connectionQuality: ge.connectionQuality,
          displayName: Ce.displayName || ge.name,
          joinedAt: ge.joinedAt,
          role: Ce.participantRole,
          meta: Ce,
          trackIds: fe.filter((Me) => Me.participant.sid === ge.sid).map((Me) => Me.trackSid)
        };
      }),
      tracks: fe.map((ge) => {
        var Ce, Me, Be, Ae;
        const be = JSON.parse((Ce = ge == null ? void 0 : ge.participant) == null ? void 0 : Ce.metadata);
        return {
          mediaStreamTrack: (Me = ge.track) == null ? void 0 : Me.mediaStreamTrack,
          id: ge.trackSid,
          participantId: (Be = ge.participant) == null ? void 0 : Be.identity,
          isMuted: (Ae = ge.track) == null ? void 0 : Ae.isMuted,
          type: ge.source,
          isExternal: !!(be != null && be[ge.trackSid])
        };
      })
    };
    p = {
      tracks: fe,
      participants: ae,
      result: ie,
      chat: u.chatHistory
    }, v.useTracks.forEach((ge) => ge(ie.tracks)), v.useTrack.forEach((ge, be) => {
      be(L(ge));
    }), v.useParticipants.forEach((ge) => ge(ie.participants)), v.useParticipant.forEach((ge, be) => {
      be(F(ge));
    }), v.useChatHistory.forEach((ge) => {
      ge(p.chat);
    });
  }, k = [RoomEvent.ParticipantConnected, RoomEvent.ParticipantDisconnected, RoomEvent.ParticipantMetadataChanged, RoomEvent.Disconnected, RoomEvent.TrackSubscribed, RoomEvent.TrackUnsubscribed, RoomEvent.LocalTrackPublished, RoomEvent.LocalTrackUnpublished, RoomEvent.ConnectionQualityChanged, RoomEvent.TrackMuted, RoomEvent.TrackUnmuted, RoomEvent.TrackStreamStateChanged];
  u.subscribeToRoomEvent(RoomEvent.DataReceived, (ae, ne, fe) => {
    const ie = decoder.decode(ae);
    JSON.parse(ie).type === DataType.ParticipantMetadataUpdate && _();
  }), k.map((ae) => u.subscribeToRoomEvent(ae, () => _())).push(u.subscribeToSpecialEvent(SpecialEvent.Chat, _));
  const L = (ae) => p.result.tracks.find((ne) => ne.id === ae), F = (ae) => p.result.participants.find((ne) => ne.id === ae), V = (ae, ne) => {
    const fe = l.getTrackPublications().find((ie) => ie.trackSid === ae);
    fe && (ne ? fe.mute() : fe.unmute());
  };
  let X, oe;
  const Y = {
    id: u.roomName,
    participantId: l.identity,
    setTrackEnabled: V,
    setCameraEnabled: (ae = !0) => l.setCameraEnabled(ae),
    setMicrophoneEnabled: (ae = !0) => l.setMicrophoneEnabled(ae),
    setCamera: async (ae = {}) => {
      var fe, ie;
      if (X) {
        log.warn("Cannot set camera until previous has resolved");
        return;
      }
      X = !0;
      let ne;
      try {
        const be = l.getTrackPublications().filter((Me) => (Me == null ? void 0 : Me.source) === Track.Source.Camera).find((Me) => !L(Me == null ? void 0 : Me.trackSid).isExternal), Ce = await l.createTracks({
          video: {
            deviceId: {
              exact: (fe = ae.deviceId) == null ? void 0 : fe.toString()
            },
            resolution: ae.resolution || {
              width: 1280,
              height: 720,
              frameRate: 30,
              aspectRatio: 16 / 9
            }
          }
        });
        be != null && be.isMuted && Ce.forEach((Me) => {
          Me.mute();
        }), ne = await Promise.all(Ce.map((Me) => l.publishTrack(Me))), be && l.unpublishTrack(be.track);
      } catch (ge) {
        throw ge;
      } finally {
        return X = !1, L((ie = ne[0]) == null ? void 0 : ie.trackSid);
      }
    },
    setMicrophone: async (ae) => {
      var fe;
      if (oe) {
        log.warn("Cannot set microphone until previous has resolved");
        return;
      }
      oe = !0;
      let ne;
      try {
        const ge = l.getTrackPublications().filter((Ce) => Ce.source === Track.Source.Microphone).find((Ce) => !L(Ce == null ? void 0 : Ce.trackSid).isExternal), be = await l.createTracks({
          audio: ae || !0
        });
        ge != null && ge.isMuted && be.forEach((Ce) => {
          Ce.mute();
        }), ne = await Promise.all(be.map((Ce) => l.publishTrack(Ce))), ge && l.unpublishTrack(ge.track);
      } catch (ie) {
        throw ie;
      } finally {
        return oe = !1, L((fe = ne[0]) == null ? void 0 : fe.trackSid);
      }
    },
    addMicrophone: async (ae) => {
      var be;
      if (oe) {
        log.warn("Cannot set microphone until previous has resolved");
        return;
      }
      oe = !0;
      const ne = await l.createTracks({
        audio: ae || !0
      }), ie = l.getTrackPublications().filter((Ce) => Ce.source === Track.Source.Microphone).find((Ce) => {
        var Be, Ae;
        const Me = L(Ce == null ? void 0 : Ce.trackSid);
        ((Ae = (Be = Me == null ? void 0 : Me.mediaStreamTrack) == null ? void 0 : Be.getSettings()) == null ? void 0 : Ae.deviceId) === ae.deviceId && (Me == null || Me.isExternal);
      });
      ie != null && ie.isMuted && ne.forEach((Ce) => {
        Ce.mute();
      });
      const ge = await Promise.all(ne.map((Ce) => l.publishTrack(Ce)));
      return ie && l.unpublishTrack(ie.track), oe = !1, L((be = ge[0]) == null ? void 0 : be.trackSid);
    },
    addCamera: async (ae = {}) => {
      var ge, be;
      const ne = await l.createTracks({
        video: {
          deviceId: {
            exact: (ge = ae.deviceId) == null ? void 0 : ge.toString()
          },
          resolution: ae.resolution || {
            width: 1280,
            height: 720,
            frameRate: 30,
            aspectRatio: 1.7777777777777777
          }
        }
      }), fe = l.getTrackPublications().find((Ce) => {
        var Me, Be, Ae;
        return (Ce == null ? void 0 : Ce.source) === Track.Source.Camera && ((Ae = (Be = (Me = Ce == null ? void 0 : Ce.track) == null ? void 0 : Me.mediaStreamTrack) == null ? void 0 : Be.getSettings()) == null ? void 0 : Ae.deviceId) === ae.deviceId;
      });
      fe != null && fe.isMuted && ne.forEach((Ce) => {
        Ce.mute();
      });
      const ie = await Promise.all(ne.map((Ce) => l.publishTrack(Ce)));
      return fe && l.unpublishTrack(fe.track), oe = !1, L((be = ie[0]) == null ? void 0 : be.trackSid);
    },
    addScreen: async (ae = {
      audio: !1
    }) => {
      const ne = await l.createScreenTracks(ae), fe = await Promise.all(ne.map((be) => l.publishTrack(be))), ie = fe.find((be) => be.kind === "video"), ge = fe.find((be) => be.kind === "audio");
      return {
        screen: L(ie == null ? void 0 : ie.trackSid),
        audio: L(ge == null ? void 0 : ge.trackSid)
      };
    },
    removeTrack: async (ae) => {
      const ne = p.tracks.find((fe) => fe.trackSid === ae);
      l.unpublishTrack(ne.track);
    },
    /* Setting the local participant metadata. */
    setLocalParticipantMetadata: async (ae, ne) => {
      const fe = JSON.stringify(ne), ie = encoder.encode(JSON.stringify({
        metadata: ne,
        type: DataType.ParticipantMetadataUpdate,
        participantId: ae
      }));
      return l.setMetadata(fe), await l.publishData(ie, {
        reliable: !0
      });
    },
    setParticipantMetadata: (ae, ne) => u.updateParticipant(ae, ne),
    kickParticipant: u.kickParticipant,
    muteTrackAsAdmin: u.muteTrackAsAdmin,
    sendChatMessage: u.sendChatMessage,
    // Callbacks
    getTracks: () => p.result.tracks,
    useTracks: (ae) => (v.useTracks.add(ae), ae(p.result.tracks), () => {
      v.useTracks.delete(ae);
    }),
    getTrack: L,
    useTrack: (ae, ne) => (v.useTrack.set(ne, ae), ne(L(ae)), () => {
      v.useTrack.delete(ne);
    }),
    getParticipant: F,
    getParticipants: () => p.result.participants,
    useParticipants: (ae) => (v.useParticipants.add(ae), ae(p.result.participants), () => {
      v.useParticipants.delete(ae);
    }),
    useParticipant: (ae, ne) => (v.useParticipant.set(ne, ae), ne(F(ae)), () => {
      v.useTrack.delete(ne);
    }),
    useChatHistory: (ae) => (v.useChatHistory.add(ae), ae(p.chat), () => {
      v.useChatHistory.delete(ae);
    }),
    useActiveSpeakers: (ae) => {
      var fe, ie;
      const ne = (ge) => {
        ae(ge.map((be) => be.identity));
      };
      return (fe = u.livekitRoom) == null || fe.on(RoomEvent.ActiveSpeakersChanged, ne), ne((ie = u.livekitRoom) == null ? void 0 : ie.activeSpeakers), () => {
        var ge;
        (ge = u.livekitRoom) == null || ge.off(RoomEvent.ActiveSpeakersChanged, ne);
      };
    },
    sendData: (ae, ne = []) => {
      const fe = encoder.encode(JSON.stringify(ae)), ie = ne == null ? void 0 : ne.map((ge) => {
        var be;
        return (be = u.livekitRoom) == null ? void 0 : be.getParticipantByIdentity(ge);
      }).filter(Boolean);
      return l.publishData(fe, {
        reliable: !0,
        destinationIdentities: ie.map((ge) => ge.identity)
      });
    },
    onData: (ae) => {
      var fe;
      const ne = (ie, ge) => {
        const be = JSON.parse(decoder.decode(ie));
        ae(be, ge == null ? void 0 : ge.identity);
      };
      return (fe = u.livekitRoom) == null || fe.on(RoomEvent.DataReceived, ne), () => {
        var ie;
        (ie = u.livekitRoom) == null || ie.off(RoomEvent.DataReceived, ne);
      };
    },
    connect: () => u.connect(),
    disconnect: () => {
      var ae;
      return (ae = u.livekitRoom) == null ? void 0 : ae.disconnect();
    },
    onDisconnected: (ae) => {
      var ne;
      return (ne = u.livekitRoom) == null || ne.on(RoomEvent.Disconnected, ae), () => {
        var fe;
        (fe = u.livekitRoom) == null || fe.off(RoomEvent.DataReceived, ae);
      };
    },
    setAudioOutput: (ae) => {
      var ne;
      return (ne = u.livekitRoom) == null ? void 0 : ne.switchActiveDevice("audiooutput", ae);
    }
  };
  return _(), simpleRooms.set(a, Y), Y;
}, {
  state: state$2
} = CoreContext, getAccessTokenData = () => {
  var a;
  return ((a = CoreContext.clients.accessTokenClaims) == null ? void 0 : a.user) || {};
}, getBaseUser = () => state$2.user ? {
  id: state$2.user.id,
  props: state$2.user.props,
  name: state$2.user.name,
  projects: state$2.projects.map(toBaseProject),
  sources: state$2.sources.map(toBaseSource)
} : null, toBaseProject = (a) => {
  const {
    compositor: u,
    videoApi: c,
    props: l = {},
    role: v
  } = a, {
    destinations: p,
    encoding: _,
    rendering: k,
    sources: M
  } = c.project, L = {
    get: u.get,
    getRoot: u.getRoot,
    getParent: u.getParent
  };
  Object.defineProperty(L, "nodes", {
    get() {
      return u.nodes.filter((X) => !X._deleted);
    }
  });
  const F = a.videoApi.phase, V = a.videoApi.broadcastId || null;
  return {
    broadcastPhase: F,
    role: v,
    broadcastId: V,
    layoutId: a.layoutApi.layoutId,
    isLive: [ProjectBroadcastPhase.PROJECT_BROADCAST_PHASE_RUNNING, ProjectBroadcastPhase.PROJECT_BROADCAST_PHASE_STOPPING].includes(F),
    scene: L,
    joinRoom: async (X = {}) => CoreContext.Command.joinRoom({
      projectId: a.id,
      ...X
    }),
    subscribe: (X) => CoreContext.subscribe((oe, Y) => {
      Y.projectId && (Y == null ? void 0 : Y.projectId) === a.id && X(oe, Y);
    }),
    destinations: p.map(toBaseDestination),
    sources: M.map(toBaseSource),
    encoding: _,
    rendering: k,
    id: a.id,
    hostDisplayName: a.props.hostDisplayName,
    props: l
  };
}, toBaseDestination = (a) => {
  var u;
  return {
    id: a.destinationId,
    enabled: a.enabled,
    address: a.address,
    // For backward compatibility, fall back to "metadata" as props.
    //  All new projects have a dedicated "props" field
    props: ((u = a.metadata) == null ? void 0 : u.props) || (a == null ? void 0 : a.metadata) || {}
  };
}, toBaseSource = (a) => {
  var u;
  return {
    id: a.sourceId,
    address: a.address,
    preview: a.preview,
    props: ((u = a.metadata) == null ? void 0 : u.props) || {}
  };
}, hydrateProject = async (a, u, c) => {
  const l = a.metadata || {}, v = {
    collectionId: a.collectionId,
    projectId: a.projectId,
    updateMask: []
  };
  hasPermission(u, Permission.ManageBroadcast) && a.composition.studioSdk.version !== CoreContext.rendererVersion && (v.composition = {
    studioSdk: {
      version: CoreContext.rendererVersion
    }
  }, v.updateMask.push("composition.studioSdk.version")), c && (v.rendering = {
    video: {
      width: c.x,
      height: c.y,
      framerate: 30
    }
  }, v.updateMask.push("rendering")), v.updateMask.length && await CoreContext.clients.LiveApi().project.updateProject(v);
  const _ = await layoutToProject(l.layoutId, c);
  return {
    id: a.projectId,
    compositor: _,
    role: u,
    videoApi: {
      project: a,
      phase: ProjectBroadcastPhase.PROJECT_BROADCAST_PHASE_UNSPECIFIED
    },
    layoutApi: {
      layoutId: l.layoutId
    },
    // For backward compatibility, fall back to "metadata" as props.
    //  All new projects have a dedicated "props" field
    props: (l == null ? void 0 : l.props) || l
  };
}, sceneNodeToLayer = (a) => {
  const {
    id: u,
    props: c = {},
    children: l = []
  } = a;
  return {
    ...u ? {
      id: u
    } : {},
    type: c.type,
    data: {
      ...c
    },
    children: l.map((v) => v.id)
  };
}, nodeToLayer = (a) => ({
  id: a.id,
  type: a.props.type,
  data: {
    ...a.props
  },
  children: a.childIds.map((u) => u)
}), layerToNode = (a) => ({
  id: String(a.id),
  props: {
    type: a.type,
    ...a.data
  },
  childIds: a.children.map((u) => String(u))
}), layoutToProject = async (a, u) => {
  const {
    layers: c
  } = await CoreContext.clients.LayoutApi().layer.listLayers({
    layoutId: a
  });
  if (u && c) {
    const {
      x: _,
      y: k
    } = u, M = c == null ? void 0 : c.reduce((L, F) => L ? L.data.isRoot ? L : F.data.isRoot || !c.some((V) => V.children.includes(F.id)) ? F : L : F, null);
    if (M) {
      const L = await CoreContext.clients.LayoutApi().layer.updateLayer({
        layoutId: M.layoutId,
        layerId: M.id,
        layer: {
          x: _,
          y: k,
          data: {
            ...M.data,
            size: {
              x: _,
              y: k
            }
          }
        }
      }), F = c.findIndex((V) => V.id === L.id);
      c[F] = L;
    }
  }
  const l = c.map(layerToNode), v = l.reduce((_, k) => _ ? _.props.isRoot ? _ : k.props.isRoot || !l.some((M) => M.childIds.includes(k.id)) ? k : _ : k, null), p = v ? toSceneTree(l, v.id) : null;
  return CoreContext.compositor.loadProject(p, a);
}, getUser = () => {
  const a = state$2.user;
  if (!a)
    throw new Error("User not loaded");
  return a;
}, getProject = (a) => state$2.projects.find((u) => u.id === a), getProjectByLayoutId = (a) => state$2.projects.find((u) => u.compositor.id === a), getProjectRoom = (a) => {
  var u;
  return getRoom((u = getProject(a)) == null ? void 0 : u.roomId);
}, {
  connectionId
} = CoreContext, latestUpdateVersion = {}, getNextNodeVersion = (a) => (latestUpdateVersion[a] || (latestUpdateVersion[a] = 0), ++latestUpdateVersion[a]), request = (a, u) => {
  const c = u.map((l) => {
    const [v, p] = l;
    return {
      [v]: p
    };
  });
  return log.debug("Batch request", c), CoreContext.clients.LayoutApi().layer.batch({
    layoutId: a,
    layers: c,
    requestMetadata: {
      connectionId,
      layoutId: a,
      updateVersions: u.filter(([l]) => l === "update").map(([l, v]) => ({
        [v.id]: getNextNodeVersion(v.id)
      })).reduce((l, v) => ({
        ...v,
        ...l
      }), {})
    }
  });
}, compositorAdapter = (a, u) => ({
  async insert(c = {}, l, v) {
    const p = nodeToLayer({
      id: null,
      props: c,
      childIds: []
    });
    l ? p.type = "child" : p.type = "root", log.debug("Insert layer", p);
    const _ = await CoreContext.clients.LayoutApi().layer.createLayer({
      layoutId: a,
      layer: {
        ...p,
        requestMetadata: {
          connectionId,
          layoutId: a
        }
      }
    });
    if (_.code)
      throw new Error(_.message);
    const k = await u.get(l);
    if (l && !k)
      throw Error("Parent not found with ID");
    if (k) {
      const M = nodeToLayer(k), L = insertAt$1(v, _.id, M.children), F = {
        layoutId: a,
        layerId: M.id,
        layer: {
          children: L,
          requestMetadata: {
            connectionId,
            layoutId: a,
            updateVersion: {
              [p.id]: getNextNodeVersion(p.id)
            }
          }
        }
      };
      await CoreContext.clients.LayoutApi().layer.updateLayer(F);
    }
    return String(_.id);
  },
  async update(c, l = {}) {
    const v = u.get(c), p = nodeToLayer({
      ...v,
      props: {
        ...v.props,
        ...l
      }
    }), _ = {
      layoutId: a,
      layerId: p.id,
      layer: {
        ...p,
        requestMetadata: {
          connectionId,
          layoutId: a,
          updateVersions: {
            [p.id]: getNextNodeVersion(p.id)
          }
        }
      }
    };
    log.debug("Update layer", _), await CoreContext.clients.LayoutApi().layer.updateLayer(_);
  },
  async remove(c) {
    const l = await u.getParent(c);
    if (l) {
      const v = nodeToLayer(l), p = v.children.filter((k) => k !== c), _ = {
        layoutId: a,
        layerId: v.id,
        layer: {
          children: p,
          requestMetadata: {
            connectionId,
            layoutId: a,
            updateVersions: {
              [v.id]: getNextNodeVersion(v.id)
            }
          }
        }
      };
      await CoreContext.clients.LayoutApi().layer.updateLayer(_);
    }
    await CoreContext.clients.LayoutApi().layer.deleteLayer({
      layoutId: a,
      layerId: c,
      payload: {
        requestMetadata: {
          connectionId,
          layoutId: a
        }
      }
    });
  },
  // @ts-ignore
  async reorder(c, l) {
    const v = u.get(c), p = nodeToLayer({
      ...v,
      childIds: l
    });
    log.debug("Reorder layer children", p), await CoreContext.clients.LayoutApi().layer.updateLayer({
      layoutId: a,
      layerId: p.id,
      layer: {
        children: p.children,
        requestMetadata: {
          connectionId,
          layoutId: a,
          updateVersions: {
            [p.id]: getNextNodeVersion(p.id)
          }
        }
      }
    });
  },
  // @ts-ignore
  async move(c, l, v) {
    const p = u.get(c), _ = u.get(u.getParent(c).id), k = nodeToLayer({
      ..._,
      childIds: pull$1(_.childIds, p.id)
    }), M = u.get(l), L = nodeToLayer({
      ...M,
      childIds: insertAt$1(v, p.id, M.childIds)
    });
    log.debug("Move layers"), await Promise.all([CoreContext.clients.LayoutApi().layer.updateLayer({
      layoutId: a,
      layerId: k.id,
      layer: {
        children: k.children,
        requestMetadata: {
          connectionId,
          layoutId: a,
          updateVersions: {
            [k.id]: getNextNodeVersion(k.id)
          }
        }
      }
    }), CoreContext.clients.LayoutApi().layer.updateLayer({
      layoutId: a,
      layerId: L.id,
      layer: {
        children: L.children,
        requestMetadata: {
          connectionId,
          layoutId: a,
          updateVersions: {
            [L.id]: getNextNodeVersion(L.id)
          }
        }
      }
    })]);
  },
  async batch(c) {
    const l = c.map(([p, _]) => [p, sceneNodeToLayer(_)]), v = await request(a, l);
    return log.debug("Batch response", v), v;
  }
}), {
  state: state$1
} = CoreContext, prepareInternalEvents = () => {
  subscribeInternal(async (a, u) => {
    var c, l, v;
    switch (a) {
      case "UserChanged": {
        const {
          metadata: p
        } = u;
        state$1.user.metadata = p || {}, state$1.user.props = (p == null ? void 0 : p.props) || {}, trigger$1("UserChanged", {
          user: getBaseUser()
        });
        return;
      }
      case "ActiveProjectChanged": {
        const {
          projectId: p
        } = u;
        state$1.activeProjectId = p, trigger$1("ActiveProjectChanged", {
          projectId: p
        });
        return;
      }
      case "ProjectAdded": {
        const _ = await hydrateProject(u, "ROLE_HOST"), k = toBaseProject(_);
        state$1.projects = [...state$1.projects, _], trigger$1("ProjectAdded", {
          project: k
        });
        return;
      }
      case "ProjectRemoved": {
        const {
          projectId: p
        } = u;
        state$1.projects = state$1.projects.filter((_) => _.id !== p), trigger$1("ProjectRemoved", {
          projectId: p
        });
        return;
      }
      case "ProjectChanged": {
        const {
          project: p,
          phase: _,
          broadcastId: k
        } = u, M = getProject(p.projectId);
        if (!M)
          return;
        _ && (M.videoApi.phase = _), typeof k < "u" && (M.videoApi.broadcastId = k);
        const L = (c = p.metadata) == null ? void 0 : c.layoutId;
        L !== M.layoutApi.layoutId && (M.layoutApi.layoutId = (l = p.metadata) == null ? void 0 : l.layoutId, M.compositor = await layoutToProject(L)), M.videoApi.project = p, M.props = ((v = p.metadata) == null ? void 0 : v.props) ?? {}, trigger$1("ProjectChanged", {
          project: toBaseProject(M)
        });
        return;
      }
      case "DestinationAdded": {
        const {
          projectId: p
        } = u, _ = getProject(p);
        if (!_)
          return;
        _.videoApi.project.destinations.push(u), trigger$1("DestinationAdded", {
          projectId: p,
          destination: toBaseDestination(u)
        });
        return;
      }
      case "DestinationRemoved": {
        const {
          projectId: p,
          destinationId: _
        } = u, k = getProject(p);
        if (!k)
          return;
        k.videoApi.project.destinations = k.videoApi.project.destinations.filter((M) => M.destinationId !== _), trigger$1("DestinationRemoved", {
          projectId: p,
          destinationId: _
        });
        return;
      }
      case "DestinationChanged": {
        const p = u, {
          projectId: _,
          destinationId: k
        } = p, M = getProject(_);
        if (!M)
          return;
        const L = M.videoApi.project.destinations.find((F) => F.destinationId === k);
        if (!L)
          return;
        Object.assign(L, p), trigger$1("DestinationChanged", {
          projectId: _,
          destination: toBaseDestination(L)
        });
        return;
      }
      case "SourceAdded": {
        trigger$1("SourceAdded", {
          source: toBaseSource(u)
        });
        return;
      }
      case "SourceRemoved":
        return;
      case "SourceChanged":
        return;
      case "ProjectSourceAdded": {
        const {
          projectId: p,
          source: _
        } = u, k = getProject(p);
        if (!k)
          return;
        k.videoApi.project.sources.push(_), trigger$1("ProjectSourceAdded", {
          source: toBaseSource(_),
          projectId: p
        });
        return;
      }
      case "ProjectSourceRemoved": {
        const {
          projectId: p,
          sourceId: _
        } = u, k = getProject(p);
        if (!k)
          return;
        k.videoApi.project.sources = k.videoApi.project.sources.filter((M) => M.sourceId !== _), trigger$1("ProjectSourceRemoved", {
          sourceId: _,
          projectId: p
        });
      }
      case "NodeAdded":
        return;
      case "NodeRemoved":
        return;
      case "NodeChanged":
        return;
    }
  }), subscribeInternal(() => log.debug({
    nextState: {
      ...state$1
    }
  }));
};
/*! (c) Andrea Giammarchi - ISC */
var self$1 = {};
try {
  self$1.WeakMap = WeakMap;
} catch (a) {
  self$1.WeakMap = function(u, c) {
    var l = c.defineProperty, v = c.hasOwnProperty, p = _.prototype;
    return p.delete = function(M) {
      return this.has(M) && delete M[this._];
    }, p.get = function(M) {
      return this.has(M) ? M[this._] : void 0;
    }, p.has = function(M) {
      return v.call(M, this._);
    }, p.set = function(M, L) {
      return l(M, this._, { configurable: !0, value: L }), this;
    }, _;
    function _(M) {
      l(this, "_", { value: "_@ungap/weakmap" + u++ }), M && M.forEach(k, this);
    }
    function k(M) {
      this.set(M[0], M[1]);
    }
  }(Math.random(), Object);
}
const WeakMap$1 = self$1.WeakMap;
/*! (c) Andrea Giammarchi - ISC */
var UID = "-" + Math.random().toFixed(6) + "%", UID_IE = !1;
try {
  (function(a, u, c) {
    return u in a && (a.innerHTML = "<p " + c + '="' + UID + '"></p>', a[u].childNodes[0].getAttribute(c) == UID);
  })(document.createElement("template"), "content", "tabindex") || (UID = "_dt: " + UID.slice(1, -1) + ";", UID_IE = !0);
} catch (a) {
}
var UIDC = "<!--" + UID + "-->", COMMENT_NODE = 8, ELEMENT_NODE$1 = 1, TEXT_NODE = 3, SHOULD_USE_TEXT_CONTENT = /^(?:plaintext|script|style|textarea|title|xmp)$/i, VOID_ELEMENTS = /^(?:area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)$/i;
/*! (c) Andrea Giammarchi - ISC */
function domsanitizer(a) {
  return a.join(UIDC).replace(selfClosing, fullClosing).replace(attrSeeker, attrReplacer);
}
var spaces = " \\f\\n\\r\\t", almostEverything = "[^" + spaces + `\\/>"'=]+`, attrName = "[" + spaces + "]+" + almostEverything, tagName = "<([A-Za-z]+[A-Za-z0-9:._-]*)((?:", attrPartials = `(?:\\s*=\\s*(?:'[^']*?'|"[^"]*?"|<[^>]*?>|` + almostEverything.replace("\\/", "") + "))?)", attrSeeker = new RegExp(tagName + attrName + attrPartials + "+)([" + spaces + "]*/?>)", "g"), selfClosing = new RegExp(tagName + attrName + attrPartials + "*)([" + spaces + "]*/>)", "g"), findAttributes = new RegExp("(" + attrName + `\\s*=\\s*)(['"]?)` + UIDC + "\\2", "gi");
function attrReplacer(a, u, c, l) {
  return "<" + u + c.replace(findAttributes, replaceAttributes) + l;
}
function replaceAttributes(a, u, c) {
  return u + (c || '"') + UID + (c || '"');
}
function fullClosing(a, u, c) {
  return VOID_ELEMENTS.test(u) ? a : "<" + u + c + "></" + u + ">";
}
const { isArray } = Array, { indexOf, slice } = [], umap = (a) => ({
  // About: get: _.get.bind(_)
  // It looks like WebKit/Safari didn't optimize bind at all,
  // so that using bind slows it down by 60%.
  // Firefox and Chrome are just fine in both cases,
  // so let's use the approach that works fast everywhere 
  get: (u) => a.get(u),
  set: (u, c) => (a.set(u, c), c)
}), ELEMENT_NODE = 1, nodeType = 111, remove = ({ firstChild: a, lastChild: u }) => {
  const c = document.createRange();
  return c.setStartAfter(a), c.setEndAfter(u), c.deleteContents(), a;
}, diffable = (a, u) => a.nodeType === nodeType ? 1 / u < 0 ? u ? remove(a) : a.lastChild : u ? a.valueOf() : a.firstChild : a, persistent = (a) => {
  const { childNodes: u } = a, { length: c } = u;
  if (c < 2)
    return c ? u[0] : a;
  const l = slice.call(u, 0), v = l[0], p = l[c - 1];
  return {
    ELEMENT_NODE,
    nodeType,
    firstChild: v,
    lastChild: p,
    valueOf() {
      if (u.length !== c) {
        let _ = 0;
        for (; _ < c; )
          a.appendChild(l[_++]);
      }
      return a;
    }
  };
};
/*! (c) Andrea Giammarchi - ISC */
var createContent = function(a) {
  var u = "fragment", c = "template", l = "content" in _(c), v = l ? function(M) {
    var L = _(c);
    return L.innerHTML = M, L.content;
  } : function(M) {
    var L = _(u), F = _(c), V = null;
    if (/^[^\S]*?<(col(?:group)?|t(?:head|body|foot|r|d|h))/i.test(M)) {
      var X = RegExp.$1;
      F.innerHTML = "<table>" + M + "</table>", V = F.querySelectorAll(X);
    } else
      F.innerHTML = M, V = F.childNodes;
    return p(L, V), L;
  };
  return function(L, F) {
    return (F === "svg" ? k : v)(L);
  };
  function p(M, L) {
    for (var F = L.length; F--; )
      M.appendChild(L[0]);
  }
  function _(M) {
    return M === u ? a.createDocumentFragment() : a.createElementNS("http://www.w3.org/1999/xhtml", M);
  }
  function k(M) {
    var L = _(u), F = _("div");
    return F.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg">' + M + "</svg>", p(L, F.firstChild.childNodes), L;
  }
}(document);
const udomdiff = (a, u, c, l, v) => {
  const p = c.length;
  let _ = u.length, k = p, M = 0, L = 0, F = null;
  for (; M < _ || L < k; )
    if (_ === M) {
      const V = k < p ? L ? l(c[L - 1], -0).nextSibling : l(c[k - L], 0) : v;
      for (; L < k; )
        a.insertBefore(l(c[L++], 1), V);
    } else if (k === L)
      for (; M < _; )
        (!F || !F.has(u[M])) && a.removeChild(l(u[M], -1)), M++;
    else if (u[M] === c[L])
      M++, L++;
    else if (u[_ - 1] === c[k - 1])
      _--, k--;
    else if (u[M] === c[k - 1] && c[L] === u[_ - 1]) {
      const V = l(u[--_], -1).nextSibling;
      a.insertBefore(
        l(c[L++], 1),
        l(u[M++], -1).nextSibling
      ), a.insertBefore(l(c[--k], 1), V), u[_] = c[k];
    } else {
      if (!F) {
        F = /* @__PURE__ */ new Map();
        let V = L;
        for (; V < k; )
          F.set(c[V], V++);
      }
      if (F.has(u[M])) {
        const V = F.get(u[M]);
        if (L < V && V < k) {
          let X = M, oe = 1;
          for (; ++X < _ && X < k && F.get(u[X]) === V + oe; )
            oe++;
          if (oe > V - L) {
            const Y = l(u[M], 0);
            for (; L < V; )
              a.insertBefore(l(c[L++], 1), Y);
          } else
            a.replaceChild(
              l(c[L++], 1),
              l(u[M++], -1)
            );
        } else
          M++;
      } else
        a.removeChild(l(u[M++], -1));
    }
  return c;
};
/*! (c) Andrea Giammarchi - ISC */
var importNode = function(a, u, c, l, v) {
  var p = v in a, _ = a.createDocumentFragment();
  _[u](a[l]("g")), _[u](a[l](""));
  var k = p ? a[v](_, !0) : _[c](!0);
  return k.childNodes.length < 2 ? function M(L, F) {
    for (var V = L[c](), X = L.childNodes || [], oe = X.length, Y = 0; F && Y < oe; Y++)
      V[u](M(X[Y], F));
    return V;
  } : (
    /* istanbul ignore next */
    p ? a[v] : function(M, L) {
      return M[c](!!L);
    }
  );
}(
  document,
  "appendChild",
  "cloneNode",
  "createTextNode",
  "importNode"
), trim = "".trim || /* istanbul ignore next */
function() {
  return String(this).replace(/^\s+|\s+/g, "");
}, normalizeAttributes = UID_IE ? function(a, u) {
  var c = u.join(" ");
  return u.slice.call(a, 0).sort(function(l, v) {
    return c.indexOf(l.name) <= c.indexOf(v.name) ? -1 : 1;
  });
} : function(a, u) {
  return u.slice.call(a, 0);
};
function find(a, u) {
  for (var c = u.length, l = 0; l < c; )
    a = a.childNodes[u[l++]];
  return a;
}
function parse(a, u, c, l) {
  for (var v = a.childNodes, p = v.length, _ = 0; _ < p; ) {
    var k = v[_];
    switch (k.nodeType) {
      case ELEMENT_NODE$1:
        var M = l.concat(_);
        parseAttributes(k, u, c, M), parse(k, u, c, M);
        break;
      case COMMENT_NODE:
        var L = k.textContent;
        if (L === UID)
          c.shift(), u.push(
            // basicHTML or other non standard engines
            // might end up having comments in nodes
            // where they shouldn't, hence this check.
            SHOULD_USE_TEXT_CONTENT.test(a.nodeName) ? Text(a, l) : Any(k, l.concat(_))
          );
        else
          switch (L.slice(0, 2)) {
            case "/*":
              if (L.slice(-2) !== "*/")
                break;
            case "":
              a.removeChild(k), _--, p--;
          }
        break;
      case TEXT_NODE:
        SHOULD_USE_TEXT_CONTENT.test(a.nodeName) && trim.call(k.textContent) === UIDC && (c.shift(), u.push(Text(a, l)));
        break;
    }
    _++;
  }
}
function parseAttributes(a, u, c, l) {
  for (var v = a.attributes, p = [], _ = [], k = normalizeAttributes(v, c), M = k.length, L = 0; L < M; ) {
    var F = k[L++], V = F.value === UID, X;
    if (V || 1 < (X = F.value.split(UIDC)).length) {
      var oe = F.name;
      if (p.indexOf(oe) < 0) {
        p.push(oe);
        var Y = c.shift().replace(
          V ? /^(?:|[\S\s]*?\s)(\S+?)\s*=\s*('|")?$/ : new RegExp(
            "^(?:|[\\S\\s]*?\\s)(" + oe + `)\\s*=\\s*('|")[\\S\\s]*`,
            "i"
          ),
          "$1"
        ), ae = v[Y] || // the following ignore is covered by browsers
        // while basicHTML is already case-sensitive
        /* istanbul ignore next */
        v[Y.toLowerCase()];
        if (V)
          u.push(Attr(ae, l, Y, null));
        else {
          for (var ne = X.length - 2; ne--; )
            c.shift();
          u.push(Attr(ae, l, Y, X));
        }
      }
      _.push(F);
    }
  }
  M = _.length, L = 0;
  for (var fe = 0 < M && UID_IE && !("ownerSVGElement" in a); L < M; ) {
    var ie = _[L++];
    fe && (ie.value = ""), a.removeAttribute(ie.name);
  }
  var ge = a.nodeName;
  if (/^script$/i.test(ge)) {
    var be = document.createElement(ge);
    for (M = v.length, L = 0; L < M; )
      be.setAttributeNode(v[L++].cloneNode(!0));
    be.textContent = a.textContent, a.parentNode.replaceChild(be, a);
  }
}
function Any(a, u) {
  return {
    type: "any",
    node: a,
    path: u
  };
}
function Attr(a, u, c, l) {
  return {
    type: "attr",
    node: a,
    path: u,
    name: c,
    sparse: l
  };
}
function Text(a, u) {
  return {
    type: "text",
    node: a,
    path: u
  };
}
var parsed = umap(new WeakMap$1());
function createInfo(a, u) {
  var c = (a.convert || domsanitizer)(u), l = a.transform;
  l && (c = l(c));
  var v = createContent(c, a.type);
  cleanContent(v);
  var p = [];
  return parse(v, p, u.slice(0), []), {
    content: v,
    updates: function(_) {
      for (var k = [], M = p.length, L = 0, F = 0; L < M; ) {
        var V = p[L++], X = find(_, V.path);
        switch (V.type) {
          case "any":
            k.push({ fn: a.any(X, []), sparse: !1 });
            break;
          case "attr":
            var oe = V.sparse, Y = a.attribute(X, V.name, V.node);
            oe === null ? k.push({ fn: Y, sparse: !1 }) : (F += oe.length - 2, k.push({ fn: Y, sparse: !0, values: oe }));
            break;
          case "text":
            k.push({ fn: a.text(X), sparse: !1 }), X.textContent = "";
            break;
        }
      }
      return M += F, function() {
        var ae = arguments.length;
        if (M !== ae - 1)
          throw new Error(
            ae - 1 + " values instead of " + M + `
` + u.join("${value}")
          );
        for (var ne = 1, fe = 1; ne < ae; ) {
          var ie = k[ne - fe];
          if (ie.sparse) {
            var ge = ie.values, be = ge[0], Ce = 1, Me = ge.length;
            for (fe += Me - 2; Ce < Me; )
              be += arguments[ne++] + ge[Ce++];
            ie.fn(be);
          } else
            ie.fn(arguments[ne++]);
        }
        return _;
      };
    }
  };
}
function createDetails(a, u) {
  var c = parsed.get(u) || parsed.set(u, createInfo(a, u));
  return c.updates(importNode.call(document, c.content, !0));
}
var empty = [];
function domtagger(a) {
  var u = empty, c = cleanContent;
  return function(l) {
    return u !== l && (c = createDetails(a, u = l)), c.apply(null, arguments);
  };
}
function cleanContent(a) {
  for (var u = a.childNodes, c = u.length; c--; ) {
    var l = u[c];
    l.nodeType !== 1 && trim.call(l.textContent).length === 0 && a.removeChild(l);
  }
}
/*! (c) Andrea Giammarchi - ISC */
var hyperStyle = /* @__PURE__ */ function() {
  var a = /acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i, u = /([^A-Z])([A-Z]+)/g;
  return function(k, M) {
    return "ownerSVGElement" in k ? l(k, M) : p(k.style, !1);
  };
  function c(_, k, M) {
    return k + "-" + M.toLowerCase();
  }
  function l(_, k) {
    var M;
    return k ? M = k.cloneNode(!0) : (_.setAttribute("style", "--hyper:style;"), M = _.getAttributeNode("style")), M.value = "", _.setAttributeNode(M), p(M, !0);
  }
  function v(_) {
    var k, M = [];
    for (k in _)
      M.push(k.replace(u, c), ":", _[k], ";");
    return M.join("");
  }
  function p(_, k) {
    var M, L;
    return function(F) {
      var V, X, oe, Y;
      switch (typeof F) {
        case "object":
          if (F) {
            if (M === "object") {
              if (!k && L !== F)
                for (X in L)
                  X in F || (_[X] = "");
            } else
              k ? _.value = "" : _.cssText = "";
            V = k ? {} : _;
            for (X in F)
              Y = F[X], oe = typeof Y == "number" && !a.test(X) ? Y + "px" : Y, !k && /^--/.test(X) ? V.setProperty(X, oe) : V[X] = oe;
            M = "object", k ? _.value = v(L = V) : L = F;
            break;
          }
        default:
          L != F && (M = "string", L = F, k ? _.value = F || "" : _.cssText = F || "");
          break;
      }
    };
  }
}();
const aria = (a) => (u) => {
  for (const c in u) {
    const l = c === "role" ? c : `aria-${c}`, v = u[c];
    v == null ? a.removeAttribute(l) : a.setAttribute(l, v);
  }
}, attribute = (a, u) => {
  let c, l = !0;
  const v = document.createAttributeNS(null, u);
  return (p) => {
    c !== p && (c = p, c == null ? l || (a.removeAttributeNode(v), l = !0) : (v.value = p, l && (a.setAttributeNodeNS(v), l = !1)));
  };
}, boolean = (a, u, c) => (l) => {
  c !== !!l && ((c = !!l) ? a.setAttribute(u, "") : a.removeAttribute(u));
}, data = ({ dataset: a }) => (u) => {
  for (const c in u) {
    const l = u[c];
    l == null ? delete a[c] : a[c] = l;
  }
}, event = (a, u) => {
  let c, l = u.slice(2);
  return !(u in a) && u.toLowerCase() in a && (l = l.toLowerCase()), (v) => {
    const p = isArray(v) ? v : [v, !1];
    c !== p[0] && (c && a.removeEventListener(l, c, p[1]), (c = p[0]) && a.addEventListener(l, c, p[1]));
  };
}, ref = (a) => (u) => {
  typeof u == "function" ? u(a) : u.current = a;
}, setter = (a, u) => u === "dataset" ? data(a) : (c) => {
  a[u] = c;
}, hyperProperty = (a, u) => {
  let c;
  return (l) => {
    c !== l && (c = l, a[u] !== l && (l == null ? (a[u] = "", a.removeAttribute(u)) : a[u] = l));
  };
}, readOnly = /^(?:form|list)$/i, text = (a, u) => a.ownerDocument.createTextNode(u);
function Tagger(a) {
  return this.type = a, domtagger(this);
}
Tagger.prototype = {
  // there are four kind of attributes, and related behavior:
  //  * events, with a name starting with `on`, to add/remove event listeners
  //  * special, with a name present in their inherited prototype, accessed directly
  //  * regular, accessed through get/setAttribute standard DOM methods
  //  * style, the only regular attribute that also accepts an object as value
  //    so that you can style=${{width: 120}}. In this case, the behavior has been
  //    fully inspired by Preact library and its simplicity.
  attribute(a, u, c) {
    const l = this.type === "svg";
    switch (u) {
      case "class":
        if (l)
          return attribute(a, u);
        u = "className";
      case "props":
        return setter(a, u);
      case "aria":
        return aria(a);
      case "style":
        return hyperStyle(a, c, l);
      case "ref":
        return ref(a);
      case ".dataset":
        return data(a);
      default:
        return u.slice(0, 1) === "." ? setter(a, u.slice(1)) : u.slice(0, 1) === "?" ? boolean(a, u.slice(1)) : u.slice(0, 2) === "on" ? event(a, u) : u in a && !(l || readOnly.test(u)) ? hyperProperty(a, u) : attribute(a, u);
    }
  },
  // in a hyper(node)`<div>${content}</div>` case
  // everything could happen:
  //  * it's a JS primitive, stored as text
  //  * it's null or undefined, the node should be cleaned
  //  * it's a promise, update the content once resolved
  //  * it's an explicit intent, perform the desired operation
  //  * it's an Array, resolve all values if Promises and/or
  //    update the node with the resulting list of content
  any(a, u) {
    const { type: c } = this;
    let l = !1, v;
    const p = (_) => {
      switch (typeof _) {
        case "string":
        case "number":
        case "boolean":
          l ? v !== _ && (v = _, u[0].textContent = _) : (l = !0, v = _, u = udomdiff(
            a.parentNode,
            u,
            [text(a, _)],
            diffable,
            a
          ));
          break;
        case "function":
          p(_(a));
          break;
        case "object":
        case "undefined":
          if (_ == null) {
            l = !1, u = udomdiff(
              a.parentNode,
              u,
              [],
              diffable,
              a
            );
            break;
          }
        default:
          if (l = !1, v = _, isArray(_))
            if (_.length === 0)
              u.length && (u = udomdiff(
                a.parentNode,
                u,
                [],
                diffable,
                a
              ));
            else
              switch (typeof _[0]) {
                case "string":
                case "number":
                case "boolean":
                  p(String(_));
                  break;
                case "function":
                  p(_.map(invoke, a));
                  break;
                case "object":
                  isArray(_[0]) && (_ = _.concat.apply([], _));
                default:
                  u = udomdiff(
                    a.parentNode,
                    u,
                    _,
                    diffable,
                    a
                  );
                  break;
              }
          else
            "ELEMENT_NODE" in _ ? u = udomdiff(
              a.parentNode,
              u,
              _.nodeType === 11 ? slice.call(_.childNodes) : [_],
              diffable,
              a
            ) : "text" in _ ? p(String(_.text)) : "any" in _ ? p(_.any) : "html" in _ ? u = udomdiff(
              a.parentNode,
              u,
              slice.call(
                createContent(
                  [].concat(_.html).join(""),
                  c
                ).childNodes
              ),
              diffable,
              a
            ) : "length" in _ && p(slice.call(_));
          break;
      }
    };
    return p;
  },
  // style or textareas don't accept HTML as content
  // it's pointless to transform or analyze anything
  // different from text there but it's worth checking
  // for possible defined intents.
  text(a) {
    let u;
    const c = (l) => {
      if (u !== l) {
        u = l;
        const v = typeof l;
        v === "object" && l ? "text" in l ? c(String(l.text)) : "any" in l ? c(l.any) : "html" in l ? c([].concat(l.html).join("")) : "length" in l && c(slice.call(l).join("")) : v === "function" ? c(l(a)) : a.textContent = l ?? "";
      }
    };
    return c;
  }
};
function invoke(a) {
  return a(this);
}
const { create: create$1, freeze, keys } = Object, cache = umap(new WeakMap$1()), createRender = (a) => ({
  html: outer("html", a),
  svg: outer("svg", a),
  render(u, c) {
    const l = typeof c == "function" ? c() : c, v = cache.get(u) || cache.set(u, createCache()), p = l instanceof LighterHole ? unroll(a, v, l) : l;
    return p !== v.wire && (v.wire = p, u.textContent = "", u.appendChild(p.valueOf())), u;
  }
}), createCache = () => ({ stack: [], entry: null, wire: null }), outer = (a, u) => {
  const c = umap(new WeakMap$1()), l = (p) => function() {
    return unroll(u, p, v.apply(null, arguments));
  };
  return v.for = (p, _) => {
    const k = c.get(p) || c.set(p, create$1(null));
    return k[_] || (k[_] = l(createCache()));
  }, v.node = function() {
    return unroll(
      u,
      createCache(),
      v.apply(null, arguments)
    ).valueOf();
  }, v;
  function v() {
    return new LighterHole(a, tta.apply(null, arguments));
  }
}, unroll = (a, u, { type: c, template: l, values: v }) => {
  const { length: p } = v;
  unrollValues(a, u, v, p);
  let { entry: _ } = u;
  if (!_ || _.template !== l || _.type !== c) {
    const k = new a(c);
    u.entry = _ = {
      type: c,
      template: l,
      tag: k,
      wire: persistent(k(l, ...v))
    };
  } else
    _.tag(l, ...v);
  return _.wire;
}, unrollValues = (a, { stack: u }, c, l) => {
  for (let v = 0; v < l; v++) {
    const p = c[v];
    p instanceof Hole ? c[v] = unroll(
      a,
      u[v] || (u[v] = createCache()),
      p
    ) : isArray(p) ? unrollValues(
      a,
      u[v] || (u[v] = createCache()),
      p,
      p.length
    ) : u[v] = null;
  }
  l < u.length && u.splice(l);
};
freeze(LighterHole);
function LighterHole(a, u) {
  this.type = a, this.template = u.shift(), this.values = u;
}
const Hole = LighterHole, { render: render$1, html, svg } = createRender(Tagger);
function tta() {
  let a = [], u = 0, { length: c } = arguments;
  for (; u < c; )
    a.push(arguments[u++]);
  return a;
}
const getPresetStyle = (a) => {
  const c = getProject(CoreContext.state.activeProjectId).compositor.getRoot(), {
    x: l,
    y: v
  } = c.props.size, p = 1, _ = 507 * p / l * 100, k = 153 * p / v * 100, M = {
    position: "absolute",
    width: `${_}%`,
    height: `${k}%`
  };
  switch (a) {
    case "center":
      return {
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        margin: "auto",
        ...M
      };
    case "top-left":
      return {
        top: 0,
        left: 0,
        ...M
      };
    case "top-right":
      return {
        top: 0,
        right: 0,
        ...M
      };
    case "top-center":
      return {
        top: 0,
        left: "50%",
        transform: "translateX(-50%)",
        ...M
      };
    case "bottom-left":
      return {
        bottom: 0,
        left: 0,
        ...M
      };
    case "bottom-right":
      return {
        bottom: 0,
        right: 0,
        ...M
      };
    case "bottom-center":
      return {
        bottom: 0,
        left: "50%",
        transform: "translateX(-50%)",
        ...M
      };
    case "center-left":
      return {
        top: "50%",
        left: 0,
        transform: "translateY(-50%)",
        ...M
      };
    case "center-right":
      return {
        top: "50%",
        right: 0,
        transform: "translateY(-50%)",
        ...M
      };
  }
}, Free = {
  name: "Free",
  layout: ({
    props: a,
    children: u,
    size: c
  }) => u.reduce((l, v) => {
    const {
      size: p = {
        x: "100%",
        y: "100%"
      },
      position: _ = {
        x: 0,
        y: 0
      },
      opacity: k = 1
    } = v.props;
    return {
      ...l,
      [v.id]: {
        position: {
          x: _.x,
          y: _.y
        },
        size: {
          x: p.x,
          y: p.y
        },
        opacity: k
      }
    };
  }, {})
}, Column = {
  name: "Column",
  layout: ({
    props: a = {},
    children: u,
    size: c
  }) => {
    let {
      justify: l = "center",
      align: v = "center",
      cover: p = !1,
      margin: _ = {},
      dimensions: k = 16 / 9,
      reverse: M = !1,
      entryTransition: L = () => ({}),
      exitTransition: F = () => ({})
    } = a;
    const V = p ? 0 : Math.min(c.y / 6, 12);
    _ = {
      left: V,
      right: V,
      top: V,
      bottom: V,
      between: V,
      ..._
    };
    const X = c.y - _.top - _.bottom, oe = c.x - _.left - _.right, Y = _.between * ((u.length || 1) - 1), ae = Math.min(oe, (X - Y) / (u.length || 1) * k), ne = ae / k;
    return html.node`
      <div style=${{
      height: "100%",
      width: p ? c.x + "px" : "auto",
      display: "flex",
      flexDirection: M ? "column-reverse" : "column",
      justifyContent: l,
      alignItems: v,
      paddingLeft: _.left + "px",
      paddingTop: _.top + "px",
      paddingBottom: _.bottom + "px",
      paddingRight: _.right + "px"
    }}>
      ${u.map((fe, ie) => html.node`<div data-node-id=${fe.id} .data=${{
      entryTransition: {
        delay: 400 + ie * 100,
        offset: {
          x: 0,
          y: "100%"
        },
        scale: {
          x: 0.8,
          y: 0.8
        },
        opacity: 0,
        ...L(ie)
      },
      exitTransition: {
        offset: {
          x: 0,
          y: 1e3
        },
        scale: {
          x: 0.8,
          y: 0.8
        },
        opacity: 0,
        ...F(ie)
      },
      borderRadius: p ? 0 : 5
    }} style=${{
      display: "flex",
      width: p ? "100%" : ae + "px",
      height: p ? ne + "px" : "auto",
      aspectRatio: k,
      marginBottom: ie === u.length - 1 ? 0 : _.between + "px",
      flexGrow: 0,
      flexShrink: 1,
      flexBasis: ne + "px"
    }}></div>`)}
      </div>
    `;
  }
}, Row = {
  name: "Row",
  layout: ({
    props: a = {},
    children: u,
    size: c
  }) => {
    let {
      justify: l = "center",
      align: v = "center",
      cover: p = !1,
      margin: _ = {},
      dimensions: k,
      maxWidth: M = 1,
      reverse: L = !1,
      entryTransition: F = () => ({}),
      exitTransition: V = () => ({})
    } = a;
    const X = p ? 0 : Math.min(c.y / 6, 12);
    _ = {
      left: X,
      right: X,
      top: X,
      bottom: X,
      between: X,
      ..._
    };
    const oe = c.y - _.top - _.bottom, Y = c.x - _.left - _.right, ae = _.between * ((u.length || 1) - 1);
    let ne = oe, fe = Math.min((Y - ae) / (u.length || 1), k ? oe * k : Y, M * c.x);
    return k && (ne = fe / k), html.node`
      <div style=${{
      height: p ? c.y + "px" : "auto",
      width: "100%",
      display: "flex",
      flexDirection: L ? "row-reverse" : "row",
      justifyContent: l,
      alignItems: v,
      paddingLeft: _.left + "px",
      paddingTop: _.top + "px",
      paddingBottom: _.bottom + "px",
      paddingRight: _.right + "px"
    }}>
          ${u.map((ie, ge) => html.node`<div data-node-id=${ie.id} .data=${{
      entryTransition: {
        delay: 400 + ge * 100,
        offset: {
          x: 0,
          y: "100%"
        },
        scale: {
          x: 0.8,
          y: 0.8
        },
        opacity: 0,
        ...F(ge)
      },
      exitTransition: {
        offset: {
          x: 0,
          y: 1e3
        },
        scale: {
          x: 0.8,
          y: 0.8
        },
        opacity: 0,
        ...V(ge)
      },
      borderRadius: p ? 0 : 5
    }} style=${{
      display: "flex",
      height: p ? "100%" : ne + "px",
      width: fe + "px",
      marginRight: ge === u.length - 1 ? 0 : _.between + "px",
      flexGrow: 0,
      flexShrink: 1,
      flexBasis: fe + "px"
    }}></div>`)}
      </div>
    `;
  }
}, toMatrix = (a, u) => a.reduce((c, l, v) => (v % u == 0 ? c.push([v]) : c[c.length - 1].push(v)) && c, []), Grid = {
  name: "Grid",
  layout: ({
    props: a = {},
    children: u,
    size: c
  }) => {
    let {
      dimensions: l,
      numPerRow: v,
      margin: p,
      cover: _ = !1,
      maxWidth: k,
      between: M
    } = a;
    const L = u.length === 0 || _ ? 0 : M || Math.min(c.y / u.length / 10, 30);
    p = p ?? L;
    const F = c.x < c.y;
    M = typeof M == "number" ? M : p;
    let V = [];
    v ? V = toMatrix(u, v) : V = F ? getTallGrid(u.length) : getWideGrid(u.length);
    const X = (c.y - (p * 2 + M * (V.length - 1))) / V.length, oe = c.x - p * 2;
    return html.node`
    <div style=${{
      display: "flex",
      width: "100%",
      height: "100%",
      flexDirection: "column",
      justifyContent: "center",
      padding: p + "px",
      gap: M + "px",
      flexGrow: 0
    }}>${V.map((Y, ae) => Row.layout({
      props: {
        justify: "center",
        dimensions: l,
        cover: _,
        maxWidth: k || 1 / (V[0].length || 1),
        margin: {
          top: 0,
          right: 0,
          left: 0,
          bottom: 0,
          between: M
        }
      },
      children: Y.map((ne) => u[ne]),
      size: {
        y: X,
        x: oe
      }
    }))}</div>`;
  }
}, Presentation = {
  name: "Presentation",
  layout: ({
    props: a = {},
    children: u,
    size: c
  }) => {
    let {
      margin: l,
      cover: v = !1,
      barWidth: p = 0.2,
      barOrientation: _ = "vertical",
      presentationDimensions: k = 16 / 9,
      viewerDimensions: M = 16 / 9,
      justifyViewers: L = "center",
      useGrid: F = !1,
      reverse: V = !1
    } = a;
    const X = _ === "vertical" ? c.x * p : c.y * p, oe = u[0], Y = u.filter((Ce) => Ce !== oe), ae = u.length <= 1 ? 0 : Math.min(c.x / 80, 30);
    if (l = l ?? ae, !oe)
      return Grid.layout({
        props: a,
        children: u,
        size: c
      });
    const ne = u[1], fe = {
      ...c
    };
    ne && (_ === "vertical" ? (fe.x = c.x - X, fe.y = fe.x / k) : (fe.y = c.y - X, fe.x = fe.y * k));
    let ie, ge = {};
    F ? (ie = Grid.layout, ge = {
      cover: v,
      ...v ? {
        maxWidth: 1
      } : {
        margin: l
      }
    }) : (ie = _ === "vertical" ? Column.layout : Row.layout, ge = {
      margin: {
        top: l,
        left: l,
        bottom: l,
        right: l,
        between: l
      },
      dimensions: M,
      justify: L,
      align: "flex-end",
      entryTransition: () => ({
        offset: _ === "vertical" ? {
          x: V ? "-100%" : "100%",
          y: 0
        } : {
          x: 0,
          y: V ? "-100%" : "100%"
        }
      }),
      exitTransition: () => ({
        offset: _ === "vertical" ? {
          x: V ? -1e3 : 1e3,
          y: 0
        } : {
          x: 0,
          y: V ? -1e3 : 1e3
        }
      })
    });
    const be = _ === "vertical" ? V ? "left" : "right" : V ? "top" : "bottom";
    return html.node`
      <div style=${{
      display: "flex",
      flexDirection: (_ === "vertical" ? "row" : "column") + (V ? "-reverse" : ""),
      justifyContent: "space-around",
      alignItems: "center",
      position: "relative",
      padding: v ? 0 : l,
      [`padding-${be}`]: 0
    }}>
        ${u[0] && html.node`<div style=${{
      // aspectRatio: String(presentationDimensions),
      width: fe.x,
      height: fe.y,
      display: "flex",
      flexGrow: 1
    }}>
            <div data-node-id=${oe.id} .data=${{
      dimensions: k,
      borderRadius: v ? 0 : 5,
      entryTransition: {
        delay: 0,
        offset: {
          x: 0,
          y: 1e3
        },
        scale: {
          x: 0.5,
          y: 0.5
        },
        opacity: 0
      },
      exitTransition: {
        offset: {
          x: 0,
          y: 1e3
        },
        scale: {
          x: 2,
          y: 2
        },
        opacity: 0
      }
    }} style=${{
      width: "100%",
      height: "100%",
      ...v ? {
        position: "absolute",
        top: 0,
        left: 0,
        width: F && ne ? 100 - p * 100 + "%" : "100%",
        height: "100%"
      } : {}
    }} />
          </div>`}
        ${html.node`<div style=${{
      ..._ === "vertical" ? {
        maxWidth: p * 100 + "%",
        height: "100%"
      } : {
        maxHeight: p * 100 + "%",
        width: "100%"
      }
    }}>${ne && ie({
      props: ge,
      children: Y,
      size: _ === "vertical" ? {
        x: X,
        y: c.y
      } : {
        x: c.x,
        y: X
      }
    })}</div>`}
      </div>
    `;
  }
}, Layered = {
  name: "Layered",
  layout: ({
    props: a = {},
    children: u,
    size: c
  }) => html.node`<div style=${{
    width: "100%",
    height: "100%",
    position: "relative"
  }}>
      ${u.map((l, v) => html.node`<div data-node-id=${l.id} .data=${{
    zIndex: v + 1
  }} style=${{
    position: "absolute",
    ...a.type !== "alert" ? {
      inset: "0px"
    } : {},
    ...a.type === "alert" ? getPresetStyle(a.preset) : {}
  }}></div>`)}
    </div>`
}, getWideGrid = (a = 0) => {
  switch (a) {
    case 0:
      return [[]];
    case 1:
      return [[0]];
    case 2:
      return [[0, 1]];
    case 3:
      return [[0, 1], [2]];
    case 4:
      return [[0, 1], [2, 3]];
    case 5:
      return [[0, 1, 2], [3, 4]];
    case 6:
      return [[0, 1, 2], [3, 4, 5]];
    case 7:
      return [[0, 1, 2], [3, 4, 5], [6]];
    case 8:
      return [[0, 1, 2], [3, 4, 5], [6, 7]];
  }
  const u = Array(a).fill(null).map((c, l) => l);
  return toMatrix(u, Math.round(Math.sqrt(a)));
}, getTallGrid = (a = 0) => {
  switch (a) {
    case 0:
      return [[]];
    case 1:
      return [[0]];
    case 2:
      return [[0], [1]];
    case 3:
      return [[0, 1], [2]];
    case 4:
      return [[0, 1], [2, 3]];
    case 5:
      return [[0, 1], [2, 3], [4]];
    case 6:
      return [[0, 1], [2, 3], [4, 5]];
    case 7:
      return [[0, 1], [2, 3], [4, 5], [6]];
    case 8:
      return [[0, 1], [2, 3], [4, 5], [6, 7]];
  }
  const u = Array(a).fill(null).map((c, l) => l);
  return toMatrix(u, Math.ceil(Math.sqrt(u.length)) - 1);
}, Layouts = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Column,
  Free,
  Grid,
  Layered,
  Presentation,
  Row
}, Symbol.toStringTag, { value: "Module" })), deviceWatchers = /* @__PURE__ */ new Set(), updateMediaStreamTracks = (a, u) => {
  const c = {
    audio: a.getAudioTracks()[0],
    video: a.getVideoTracks()[0]
  };
  c.audio !== u.audio && (c.audio && a.removeTrack(c.audio), u.audio && a.addTrack(u.audio)), c.video !== u.video && (c.video && a.removeTrack(c.video), u.video && a.addTrack(u.video));
}, getDevicePermissions = async () => {
  const a = {
    audio: !0,
    video: !0
  };
  return Promise.all([navigator.mediaDevices.getUserMedia({
    video: !0
  }).then((u) => {
    u.getTracks().forEach((c) => c.stop());
  }).catch((u) => {
    u.name === "NotAllowedError" && (a.video = !1);
  }), navigator.mediaDevices.getUserMedia({
    audio: !0
  }).then((u) => {
    u.getTracks().forEach((c) => c.stop());
  }).catch((u) => {
    u.name === "NotAllowedError" && (a.audio = !1);
  })]).then(() => a);
}, ensureDevicePermissions = async () => getDevicePermissions(), watchDevices = (a) => (deviceWatchers.size === 0 && navigator.mediaDevices.addEventListener("devicechange", reportDevices), deviceWatchers.add(a), reportDevices().catch(() => {
}), () => {
  deviceWatchers.delete(a), deviceWatchers.size === 0 && navigator.mediaDevices.removeEventListener("devicechange", reportDevices);
}), getUserMedia = async (...a) => {
  const u = await navigator.mediaDevices.getUserMedia(...a);
  return reportDevices(), u;
}, deviceWithDefaultLabel = (a, u) => ({
  deviceId: a.deviceId,
  groupId: a.groupId,
  kind: a.kind,
  label: a.label || u
}), reportDevices = async () => {
  const a = await navigator.mediaDevices.enumerateDevices(), u = a.filter((v) => v.kind === "videoinput").map((v, p) => deviceWithDefaultLabel(v, "Camera " + (p + 1))), c = a.filter((v) => v.kind === "audioinput").map((v, p) => deviceWithDefaultLabel(v, "Microphone " + (p + 1))), l = a.filter((v) => v.kind === "audiooutput").map((v, p) => deviceWithDefaultLabel(v, "Speaker " + (p + 1)));
  deviceWatchers.forEach((v) => v({
    webcams: u,
    microphones: c,
    speakers: l
  }));
}, webrtc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ensureDevicePermissions,
  getDevicePermissions,
  getUserMedia,
  updateMediaStreamTracks,
  watchDevices
}, Symbol.toStringTag, { value: "Module" })), RoomParticipant$1 = {
  type: "RoomParticipant",
  valueType: MediaStream,
  props: {
    id: {},
    type: {},
    // 'screen' | 'camera'
    videoEnabled: {},
    audioEnabled: {}
  },
  init({
    addSource: a,
    removeSource: u,
    updateSource: c,
    getSource: l
  }) {
    CoreContext.on("RoomJoined", ({
      room: v
    }) => {
      let p = {}, _ = [], k = [], M = {};
      const L = () => {
        _.filter((F) => (F == null ? void 0 : F.type) === "camera" && (F == null ? void 0 : F.isExternal) === !0).forEach((F) => {
          var V, X, oe;
          if (F.type === "camera") {
            const Y = M[F.id], ae = v.getParticipant(F.participantId), ne = v.getTrack(F.id);
            if (l(F == null ? void 0 : F.id)) {
              const ie = v.getTrack((V = ae == null ? void 0 : ae.meta[F.id]) == null ? void 0 : V.microphone);
              updateMediaStreamTracks(Y, {
                video: ne == null ? void 0 : ne.mediaStreamTrack,
                audio: ie == null ? void 0 : ie.mediaStreamTrack
              }), c(F.id, {
                videoEnabled: !!(ne && !ne.isMuted),
                audioEnabled: !!(ie && !ie.isMuted),
                displayName: ((X = ae == null ? void 0 : ae.meta[F.id]) == null ? void 0 : X.displayName) || "External Track",
                mirrored: (oe = ae == null ? void 0 : ae.meta[F.id]) == null ? void 0 : oe.isMirrored,
                microphone: ie,
                external: F == null ? void 0 : F.isExternal
              });
            }
          }
        }), k.forEach((F) => {
          var Ce;
          const V = M[F.id], X = M[F.id + "-screen"], oe = F.trackIds.find((Me) => {
            const Be = v.getTrack(Me);
            return (Be == null ? void 0 : Be.type) === "camera" && !(Be != null && Be.isExternal);
          }), Y = F.trackIds.find((Me) => {
            const Be = v.getTrack(Me);
            return (Be == null ? void 0 : Be.type) === "microphone" && !(Be != null && Be.isExternal);
          }), ae = F.trackIds.find((Me) => {
            const Be = v.getTrack(Me);
            return (Be == null ? void 0 : Be.type) === "screen_share";
          }), ne = F.trackIds.find((Me) => {
            const Be = v.getTrack(Me);
            return (Be == null ? void 0 : Be.type) === "screen_share_audio";
          }), fe = v.getTrack(oe), ie = v.getTrack(Y), ge = v.getTrack(ae), be = v.getTrack(ne);
          updateMediaStreamTracks(V, {
            video: fe == null ? void 0 : fe.mediaStreamTrack,
            audio: ie == null ? void 0 : ie.mediaStreamTrack
          }), updateMediaStreamTracks(X, {
            video: ge == null ? void 0 : ge.mediaStreamTrack,
            audio: be == null ? void 0 : be.mediaStreamTrack
          }), c(F.id, {
            videoEnabled: !!(fe && !fe.isMuted),
            audioEnabled: !!(ie && !ie.isMuted),
            displayName: F.displayName,
            mirrored: (Ce = F == null ? void 0 : F.meta) == null ? void 0 : Ce.isMirrored,
            external: fe == null ? void 0 : fe.isExternal
          }), c(F.id + "-screen", {
            videoEnabled: !!(ge && !ge.isMuted),
            audioEnabled: !!(be && !be.isMuted),
            displayName: F.meta.screenDisplayName || `${F.displayName}'s Screen`,
            external: ge == null ? void 0 : ge.isExternal
          });
        });
      };
      v.useTracks((F) => {
        const V = F.filter((oe) => !_.some((Y) => Y.id === oe.id) && !!(oe != null && oe.mediaStreamTrack)), X = _.filter((oe) => !F.some((Y) => Y.id === oe.id));
        _ = F.filter((oe) => !!(oe != null && oe.mediaStreamTrack)), V.forEach((oe) => {
          const Y = new MediaStream([]);
          M[oe.id] = Y;
          const {
            id: ae,
            participantId: ne,
            type: fe,
            mediaStreamTrack: ie
          } = v.getTrack(oe.id);
          ie && a({
            id: ae,
            isActive: !0,
            value: Y,
            props: {
              id: ae,
              trackId: ae,
              participantId: ne,
              isMuted: oe.isMuted,
              type: fe
            }
          });
        }), X.forEach((oe) => {
          var Y;
          u(oe.id), (Y = p[oe.id]) == null || Y.call(p);
        }), L();
      }), v.useParticipants((F) => {
        const V = F.filter((Y) => !Y.id.startsWith("source")), X = V.filter((Y) => !k.some((ae) => ae.id === Y.id)), oe = k.filter((Y) => !V.some((ae) => ae.id === Y.id));
        k = V, X.forEach((Y) => {
          var ie;
          const {
            id: ae
          } = Y, ne = new MediaStream([]), fe = new MediaStream([]);
          M[ae] = ne, M[ae + "-screen"] = fe, a({
            id: ae,
            isActive: !0,
            value: ne,
            props: {
              id: ae,
              type: "camera",
              displayName: Y.displayName || Y.id,
              audioEnabled: !1,
              videoEnabled: !1,
              mirrored: (ie = Y == null ? void 0 : Y.meta) == null ? void 0 : ie.isMirrored
            }
          }), a({
            id: ae + "-screen",
            isActive: !0,
            value: fe,
            props: {
              id: ae,
              type: "screen",
              displayName: Y.displayName || Y.id,
              audioEnabled: !1,
              videoEnabled: !1
            }
          });
        }), L(), oe.forEach((Y) => {
          var ae;
          u(Y.id), (ae = p[Y.id]) == null || ae.call(p);
        });
      });
    });
  }
}, Banner$1 = {
  type: "Banner",
  valueType: Object,
  props: {},
  init({
    addSource: a,
    removeSource: u,
    updateSource: c,
    getSource: l,
    modifySourceValue: v
  }) {
    let p = [];
    const _ = (k = []) => {
      const M = k.filter((V) => !p.some((X) => X.id === V.id)), L = p.filter((V) => !k.some((X) => X.id === V.id)), F = k.filter((V) => {
        const X = p.find((oe) => oe.id === V.id);
        return !deepEqual(V, X);
      });
      M.forEach((V) => a({
        id: V.id,
        value: {
          headerText: V.props.headerText,
          bodyText: V.props.bodyText
        },
        // TODO: It feels odd to have "props" match "value" exactly.
        //  They probably shouldn't be necessary here.
        props: V.props
      })), L.forEach((V) => u(V.id)), F.forEach((V) => {
        c(V.id, V.props), v(V.id, (X) => {
          X.headerText = V.props.headerText, X.bodyText = V.props.bodyText;
        });
      }), p = k;
    };
    CoreContext.on("ActiveProjectChanged", ({
      projectId: k
    }) => {
      var L;
      if (p = [], !k)
        return;
      const M = getProject(k);
      _(((L = M.props) == null ? void 0 : L.banners) ?? []);
    }), CoreContext.on("ProjectChanged", ({
      project: k
    }) => {
      var M;
      _(((M = k.props) == null ? void 0 : M.banners) ?? []);
    });
  }
}, {
  state
} = CoreContext, updateUserProps = async (a) => {
  const u = getUser();
  if (!u)
    return;
  const c = {
    ...u.props,
    ...a.props
  }, l = await CoreContext.clients.LiveApi().collection.updateCollection({
    collectionId: u.id,
    updateMask: ["metadata"],
    metadata: {
      ...u.metadata,
      props: c
    }
  });
  await triggerInternal$1("UserChanged", l.collection);
}, createSource = async (a) => {
  const u = getUser().id, {
    source: c
  } = await CoreContext.clients.LiveApi().source.createSource({
    metadata: {
      props: a.props || {}
    },
    collectionId: u,
    address: a.address,
    preview: {
      webrtc: {
        enabled: !0,
        displayName: a.displayName || "RTMP Source"
      }
    }
  });
  await triggerInternal$1("SourceAdded", c);
  const l = await CoreContext.clients.LiveApi().source.addSourceToProject({
    collectionId: u,
    projectId: a.projectId,
    sourceId: c.sourceId
  });
  return await triggerInternal$1("ProjectSourceAdded", {
    projectId: l.project.projectId,
    source: c
  }), c;
}, updateSource = async (a) => {
  const u = getUser().id;
  let c = [], l = {};
  a.metadata && (c.push("metadata"), l.metadata = a.metadata), a.displayName && (c.push("preview.webrtc.displayName"), l = {
    ...l,
    preview: {
      webrtc: {
        displayName: a.displayName
      }
    }
  });
  const {
    source: v
  } = await CoreContext.clients.LiveApi().source.updateSource({
    collectionId: u,
    updateMask: c,
    sourceId: a.sourceId,
    ...l
  });
  return await triggerInternal$1("SourceChanged", v), v;
}, deleteSource = async (a) => {
  const u = getUser().id;
  await CoreContext.clients.LiveApi().source.removeSourceFromProject({
    collectionId: u,
    projectId: a.projectId,
    sourceId: a.sourceId
  }), await triggerInternal$1("ProjectSourceRemoved", {
    projectId: a.projectId,
    sourceId: a.sourceId
  });
  const c = await CoreContext.clients.LiveApi().source.deleteSource({
    sourceId: a.sourceId,
    collectionId: u
  });
  return await triggerInternal$1("SourceRemoved", a.sourceId), c;
}, createProject$1 = async (a = {}) => {
  const {
    props: u = {},
    size: c,
    settings: l = {},
    type: v
  } = a, p = await CoreContext.Request.createProject({
    settings: l,
    props: u,
    size: c,
    type: v
  });
  await triggerInternal$1("ProjectAdded", p.project);
  const _ = await hydrateProject(p.project, "ROLE_HOST");
  return toBaseProject(_);
}, recreateLayout = async (a) => {
  const {
    projectId: u,
    props: c = {}
  } = a, l = getUser().id, v = await CoreContext.clients.LiveApi().project.getProject({
    collectionId: l,
    projectId: u,
    status: !0
  });
  if ([ProjectBroadcastPhase.PROJECT_BROADCAST_PHASE_RUNNING, ProjectBroadcastPhase.PROJECT_BROADCAST_PHASE_STARTING].includes(v.status.phase))
    return;
  const p = v.project.metadata || {}, {
    layoutId: _
  } = p, {
    video: k
  } = v.project.rendering, {
    type: M
  } = v.project.metadata.props || {}, L = await CoreContext.Request.createLayout({
    collectionId: l,
    projectId: u,
    type: M || "sceneless",
    settings: {},
    size: {
      x: k.width,
      y: k.height
    }
  }), F = await CoreContext.clients.LiveApi().project.updateProject({
    collectionId: l,
    projectId: u,
    updateMask: ["metadata"],
    metadata: {
      ...p,
      layoutId: L.id
    }
  });
  CoreContext.log.debug("New layout assigned to project:", {
    layout: L
  }), await triggerInternal$1("ProjectChanged", {
    project: F.project
  }), await CoreContext.clients.LayoutApi().layout.deleteLayout({
    layoutId: _
  }), CoreContext.log.debug("Previous layout deleted:", {
    layoutId: _
  });
  const V = await hydrateProject(F.project, "ROLE_HOST");
  return await V.compositor.update(V.compositor.getRoot().id, c), {
    project: toBaseProject(V),
    internalProject: V
  };
}, deleteProject$1 = async (a) => {
  const {
    projectId: u
  } = a;
  await CoreContext.Request.deleteProject({
    projectId: u
  }), await triggerInternal$1("ProjectRemoved", {
    projectId: u
  });
}, updateProjectProps = async (a) => {
  const {
    projectId: u
  } = a, c = getUser().id, l = getProject(u), v = {
    ...l.props,
    ...a.props
  }, p = await CoreContext.clients.LiveApi().project.updateProject({
    collectionId: c,
    projectId: u,
    updateMask: ["metadata"],
    metadata: {
      ...l.videoApi.project.metadata,
      props: v
    }
  });
  await triggerInternal$1("ProjectChanged", {
    project: p.project
  });
}, updateProjectVideoRendering = async (a) => {
  var _;
  const {
    projectId: u,
    videoRendering: c
  } = a, l = getUser().id, v = getProject(u), p = await CoreContext.clients.LiveApi().project.updateProject({
    collectionId: l,
    projectId: u,
    updateMask: ["rendering.video"],
    rendering: {
      video: {
        ...((_ = v.videoApi.project.rendering) == null ? void 0 : _.video) ?? {},
        ...c
      }
    }
  });
  await triggerInternal$1("ProjectChanged", {
    project: p.project
  });
}, updateProjectPropsWithoutTrigger = async (a) => {
  const {
    projectId: u
  } = a, c = getUser().id, l = getProject(u), v = {
    ...l.props,
    ...a.props
  };
  await CoreContext.clients.LiveApi().project.updateProject({
    collectionId: c,
    projectId: u,
    updateMask: ["metadata"],
    metadata: {
      ...l.videoApi.project.metadata,
      props: v
    }
  });
}, setActiveProject = async (a) => {
  const u = state.projects.find((l) => l.id === a.projectId);
  if (!u) {
    state.activeProjectId = null, triggerInternal$1("ActiveProjectChanged", {
      projectId: null
    });
    return;
  }
  const c = state.projects.find((l) => l.id === state.activeProjectId);
  if (u !== c)
    return c && (Array.from(webrtcManager.rooms.keys()).map(webrtcManager.removeRoom), await CoreContext.clients.LayoutApi().unsubscribeFromLayout(c.layoutApi.layoutId), await CoreContext.clients.LiveApi().unsubscribeFromProject(c.videoApi.project.collectionId, c.videoApi.project.projectId), await CoreContext.clients.LiveApi().unsubscribeFromCollection(c.videoApi.project.collectionId)), await CoreContext.clients.LayoutApi().subscribeToLayout(u.layoutApi.layoutId), await CoreContext.clients.LiveApi().subscribeToProject(u.videoApi.project.collectionId, u.videoApi.project.projectId), await CoreContext.clients.LiveApi().subscribeToCollection(u.videoApi.project.collectionId), CoreContext.clients.LiveApi().project.getProject({
      collectionId: u.videoApi.project.collectionId,
      projectId: u.videoApi.project.projectId,
      status: !0
    }).then((l) => {
      var v, p;
      triggerInternal$1("ProjectChanged", {
        project: l.project,
        phase: (v = l.status) == null ? void 0 : v.phase,
        broadcastId: (p = l.status) == null ? void 0 : p.broadcastId
      });
    }), triggerInternal$1("ActiveProjectChanged", {
      projectId: u.id
    }), toBaseProject(u);
}, joinRoom = async (a) => {
  const {
    projectId: u,
    displayName: c = "Guest"
  } = a, l = state.projects.find((V) => V.id === u);
  let v = l.sfuToken;
  if (!v) {
    let {
      webrtcAccess: V
    } = await CoreContext.clients.LiveApi().authentication.createWebRtcAccessToken({
      collectionId: l.videoApi.project.collectionId,
      projectId: l.videoApi.project.projectId,
      displayName: c
    });
    v = V.accessToken;
  }
  const _ = jwtDecode(v).video.room, k = new URL(CoreContext.clients.getLiveKitServer()), M = k.host + k.pathname, L = webrtcManager.ensureRoom(M, _, v);
  L.bindApiClient(CoreContext.clients), await L.connect(), l.sfuToken = v, l.roomId = _;
  const F = getRoom(_);
  return trigger$1("RoomJoined", {
    projectId: l.id,
    room: F
  }), F;
}, createNode = async (a) => {
  let {
    props: u = {},
    parentId: c,
    index: l,
    projectId: v = state.activeProjectId
  } = a;
  const p = getProject(v), _ = await p.compositor.insert(u, c, l);
  return triggerInternal$1("NodeAdded", {
    projectId: v,
    nodeId: _
  }), triggerInternal$1("NodeChanged", {
    projectId: v,
    nodeId: c
  }), p.compositor.get(_);
}, deleteNode = async (a) => {
  var p;
  let {
    nodeId: u,
    projectId: c = state.activeProjectId
  } = a;
  const l = getProject(c), v = (p = l.compositor.getParent(u)) == null ? void 0 : p.id;
  l.compositor.remove(u), triggerInternal$1("NodeRemoved", {
    projectId: c,
    nodeId: u
  }), triggerInternal$1("NodeChanged", {
    projectId: c,
    nodeId: v
  });
}, updateNode = async (a) => {
  let {
    nodeId: u,
    props: c = {},
    projectId: l = state.activeProjectId
  } = a;
  const v = getProject(l);
  return delete c.type, delete c.sourceType, v.compositor.update(u, c), triggerInternal$1("NodeChanged", {
    projectId: l,
    nodeId: u
  }), v.compositor.get(u);
}, setNodeLayout = async (a) => {
  let {
    nodeId: u,
    layout: c,
    projectId: l = state.activeProjectId,
    layoutProps: v = {}
  } = a;
  getProject(l).compositor.update(u, {
    layout: c,
    layoutProps: v
  }), triggerInternal$1("NodeChanged", {
    projectId: l,
    nodeId: u
  });
}, moveNode = async (a) => {
  const {
    nodeId: u,
    parentId: c,
    projectId: l = state.activeProjectId,
    index: v
  } = a;
  getProject(l).compositor.move(u, c, v), triggerInternal$1("NodeChanged", {
    projectId: l,
    nodeId: u
  });
}, swapNodes = async (a) => {
  var k, M;
  const {
    nodeAId: u,
    nodeBId: c,
    projectId: l = state.activeProjectId
  } = a, v = getProject(l), p = (k = v.compositor.getParent(u)) == null ? void 0 : k.id, _ = (M = v.compositor.getParent(c)) == null ? void 0 : M.id;
  v.compositor.swap(u, c), triggerInternal$1("NodeChanged", {
    projectId: l,
    nodeId: p
  }), triggerInternal$1("NodeChanged", {
    projectId: l,
    nodeId: _
  });
}, reorderNodes = async (a) => {
  const {
    parentId: u,
    childIds: c,
    projectId: l = state.activeProjectId
  } = a;
  getProject(l).compositor.reorder(u, c), triggerInternal$1("NodeChanged", {
    projectId: l,
    nodeId: u
  });
}, startBroadcast = async (a) => {
  const {
    projectId: u = state.activeProjectId,
    dynamicSources: c,
    props: l
  } = a, v = getProject(u);
  await CoreContext.clients.LiveApi().project.startProjectBroadcast({
    collectionId: v.videoApi.project.collectionId,
    projectId: v.videoApi.project.projectId,
    ...c && {
      dynamicSources: c
    },
    ...l && {
      triggerMetadata: {
        ...l
      }
    }
  });
}, stopBroadcast = async (a) => {
  const {
    projectId: u = state.activeProjectId
  } = a, c = getProject(u);
  await CoreContext.clients.LiveApi().project.stopProjectBroadcast({
    collectionId: c.videoApi.project.collectionId,
    projectId: c.videoApi.project.projectId
  });
}, getBroadcastState = async (a) => {
  const {
    projectId: u
  } = a, c = getProject(u);
  return (await CoreContext.clients.LiveApi().project.getProjectBroadcastStatus({
    collectionId: c.videoApi.project.collectionId,
    projectId: c.videoApi.project.projectId
  })).status;
}, addDestination = async (a) => {
  var L;
  const {
    rtmpUrl: u,
    rtmpKey: c,
    enabled: l,
    projectId: v = state.activeProjectId,
    props: p = {}
  } = a, _ = getProject(v), k = {
    rtmpPush: {
      key: c,
      url: u
    }
  }, M = await ((L = CoreContext.clients.LiveApi().destination) == null ? void 0 : L.createDestination({
    collectionId: _.videoApi.project.collectionId,
    projectId: _.videoApi.project.projectId,
    address: k,
    enabled: l,
    metadata: {
      props: p
    }
  }));
  return await triggerInternal$1("DestinationAdded", M.destination), toBaseDestination(M.destination);
}, removeDestination = async (a) => {
  var v;
  const {
    destinationId: u,
    projectId: c = state.activeProjectId
  } = a, l = getProject(c);
  await ((v = CoreContext.clients.LiveApi().destination) == null ? void 0 : v.deleteDestination({
    collectionId: l.videoApi.project.collectionId,
    projectId: l.videoApi.project.projectId,
    destinationId: u
  })), await triggerInternal$1("DestinationRemoved", {
    projectId: c,
    destinationId: u
  });
}, updateDestination = async (a) => {
  var M;
  const {
    rtmpUrl: u,
    rtmpKey: c,
    destinationId: l,
    projectId: v = state.activeProjectId
  } = a, p = getProject(v), _ = {
    key: c,
    url: u
  }, k = await ((M = CoreContext.clients.LiveApi().destination) == null ? void 0 : M.updateDestination({
    collectionId: p.videoApi.project.collectionId,
    projectId: p.videoApi.project.projectId,
    destinationId: l,
    updateMask: ["address.rtmpPush"],
    address: {
      rtmpPush: _
    }
  }));
  await triggerInternal$1("DestinationChanged", k.destination);
}, updateDestinationProps = async (a) => {
  var k, M;
  const {
    projectId: u = state.activeProjectId,
    destinationId: c,
    props: l = {}
  } = a, v = getProject(u), p = v.videoApi.project.destinations.find((L) => L.destinationId === c);
  if (!p)
    return;
  const _ = await ((M = CoreContext.clients.LiveApi().destination) == null ? void 0 : M.updateDestination({
    collectionId: v.videoApi.project.collectionId,
    projectId: v.videoApi.project.projectId,
    destinationId: c,
    updateMask: ["metadata"],
    metadata: {
      ...p.metadata || {},
      props: {
        ...((k = p.metadata) == null ? void 0 : k.props) || {},
        ...l
      }
    }
  }));
  await triggerInternal$1("DestinationChanged", _.destination);
}, setDestinationEnabled = async (a) => {
  var k;
  const {
    enabled: u,
    destinationId: c,
    projectId: l = state.activeProjectId
  } = a, v = getProject(l);
  if (v.videoApi.project.destinations.find((M) => c === M.destinationId).enabled === u)
    return;
  const _ = await ((k = CoreContext.clients.LiveApi().destination) == null ? void 0 : k.updateDestination({
    collectionId: v.videoApi.project.collectionId,
    projectId: v.videoApi.project.projectId,
    destinationId: c,
    updateMask: ["enabled"],
    enabled: u
  }));
  await triggerInternal$1("DestinationChanged", _.destination);
}, setDestination = async (a) => {
  var k, M;
  const {
    rtmpUrl: u,
    rtmpKey: c,
    projectId: l = state.activeProjectId
  } = a, v = getProject(l), p = {
    key: c,
    url: u
  }, _ = !0;
  if (v.videoApi.project.destinations.length > 0) {
    const L = await ((k = CoreContext.clients.LiveApi().destination) == null ? void 0 : k.updateDestination({
      collectionId: v.videoApi.project.collectionId,
      projectId: v.videoApi.project.projectId,
      destinationId: v.videoApi.project.destinations[0].destinationId,
      updateMask: ["address.rtmpPush"],
      address: {
        rtmpPush: p
      }
    }));
    await triggerInternal$1("DestinationChanged", L.destination);
  } else {
    const L = await ((M = CoreContext.clients.LiveApi().destination) == null ? void 0 : M.createDestination({
      collectionId: v.videoApi.project.collectionId,
      projectId: v.videoApi.project.projectId,
      address: {
        rtmpPush: p
      },
      enabled: _
    }));
    await triggerInternal$1("DestinationAdded", L.destination);
  }
}, commands$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  addDestination,
  createNode,
  createProject: createProject$1,
  createSource,
  deleteNode,
  deleteProject: deleteProject$1,
  deleteSource,
  getBroadcastState,
  joinRoom,
  moveNode,
  recreateLayout,
  removeDestination,
  reorderNodes,
  setActiveProject,
  setDestination,
  setDestinationEnabled,
  setNodeLayout,
  startBroadcast,
  stopBroadcast,
  swapNodes,
  updateDestination,
  updateDestinationProps,
  updateNode,
  updateProjectProps,
  updateProjectPropsWithoutTrigger,
  updateProjectVideoRendering,
  updateSource,
  updateUserProps
}, Symbol.toStringTag, { value: "Module" })), useActiveProjectRoom$1 = () => {
  const [a, u] = useState(null);
  return useEffect(() => useActiveProjectRoom(u), []), a;
}, useDevices = () => {
  const [a, u] = useState({
    webcams: [],
    microphones: [],
    speakers: []
  });
  return useEffect(() => watchDevices(u), []), a;
}, StudioContext = React.createContext({
  studio: null,
  project: null,
  room: null,
  webcamId: null,
  microphoneId: null,
  setStudio: () => {
  },
  setProject: () => {
  },
  setRoom: () => {
  },
  setWebcamId: () => {
  },
  setMicrophoneId: () => {
  },
  projectCommands: {}
}), useStudio = () => useContext(StudioContext);
let stored = {
  webcamId: null,
  microphoneId: null
};
try {
  stored.webcamId = localStorage == null ? void 0 : localStorage.getItem("__LS_webcam"), stored.microphoneId = localStorage == null ? void 0 : localStorage.getItem("__LS_microphone");
} catch {
}
const StudioProvider = ({
  children: a
}) => {
  const [u, c] = useState(), [l, v] = useState(), [p, _] = useState(), [k, M] = useState(stored.webcamId), [L, F] = useState(stored.microphoneId), V = useMemo(() => l ? commands(l) : null, [l]);
  return useEffect(() => {
  }, [l]), useEffect(() => {
    u && (k && u.setCamera({
      deviceId: k
    }).catch((X) => {
      console.warn(X);
    }), L && u.setMicrophone({
      deviceId: L
    }).catch((X) => {
      console.warn(X);
    }));
  }, [u, k, L]), /* @__PURE__ */ React.createElement(StudioContext.Provider, {
    value: {
      studio: p,
      project: l,
      room: u,
      webcamId: k,
      microphoneId: L,
      setStudio: _,
      setProject: v,
      setRoom: c,
      setWebcamId: (X) => {
        try {
          localStorage == null || localStorage.setItem("__LS_webcam", X);
        } catch {
        }
        M(X);
      },
      setMicrophoneId: (X) => {
        try {
          localStorage == null || localStorage.setItem("__LS_microphone", X);
        } catch {
        }
        F(X);
      },
      projectCommands: V
    }
  }, a);
}, react = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  StudioContext,
  StudioProvider,
  useActiveProjectRoom: useActiveProjectRoom$1,
  useDevices,
  useStudio
}, Symbol.toStringTag, { value: "Module" })), ForegroundLayers = [{
  name: "ImageIframeOverlayContainer",
  id: "fg-image-iframe",
  layout: "Free"
}, {
  name: "BannerContainer",
  id: "fg-banners",
  layout: "Column",
  layoutProps: {
    cover: !0
  }
}, {
  name: "AlertContainer",
  id: "alert",
  layout: "Layered",
  layoutProps: {
    type: "alert",
    preset: "center"
  }
}, {
  name: "VideoOverlayContainer",
  id: "fg-video",
  layout: "Free"
}, {
  name: "LogoContainer",
  layout: "Free",
  id: "logo"
}], defaultStyles = {
  custom: {
    display: "block"
  },
  alert: {
    display: "block",
    position: "absolute",
    top: 0,
    left: 0,
    bottom: 0,
    right: 0,
    margin: "auto",
    pointerEvents: "none"
  },
  video: {
    height: "100%",
    width: "100%"
  },
  image: {
    height: "100%",
    width: "100%"
  },
  logo: {
    objectFit: "contain",
    position: "unset"
  }
}, validateEachChildren = (a, u) => {
  let c = !0;
  return a.forEach((l) => {
    var v, p;
    (v = l.props) != null && v.sourceType && !u.includes((p = l.props) == null ? void 0 : p.sourceType) ? c = !1 : l.children.length > 0 && (c = c && validateEachChildren(l.children, u));
  }), c;
}, addingCache = {
  camera: /* @__PURE__ */ new Set(),
  screen: /* @__PURE__ */ new Set(),
  rtmp: /* @__PURE__ */ new Set(),
  game: /* @__PURE__ */ new Set()
}, ExternalSourceTypeMap = {
  rtmp: "RTMP",
  game: "Game"
}, commands = (a) => {
  var be, Ce, Me, Be, Ae;
  const u = a.id, c = a.scene.getRoot(), {
    Command: l
  } = CoreContext, v = c.children.find((Z) => Z.props.id === "bg"), p = c.children.find((Z) => Z.props.id === "content"), _ = c.children.find((Z) => Z.props.id === "foreground"), k = c.children.find((Z) => Z.props.id === "audio"), M = a.rendering.video;
  let L = (be = _ == null ? void 0 : _.children) == null ? void 0 : be.find((Z) => Z.props.id === "fg-image-iframe"), F = (Ce = _ == null ? void 0 : _.children) == null ? void 0 : Ce.find((Z) => Z.props.id === "logo"), V = (Me = _ == null ? void 0 : _.children) == null ? void 0 : Me.find((Z) => Z.props.id === "alert"), X = (Be = _ == null ? void 0 : _.children) == null ? void 0 : Be.find((Z) => Z.props.id === "fg-video");
  const oe = getProject(a.id);
  let Y = (Ae = _ == null ? void 0 : _.children) == null ? void 0 : Ae.find((Z) => Z.props.id === "fg-banners");
  const ae = async () => {
    var Z, z;
    ((Z = v == null ? void 0 : v.props) == null ? void 0 : Z.layout) !== "Layered" && await oe.compositor.update(v.id, {
      name: "Background",
      id: "bg",
      layout: "Layered"
    }), ((z = _ == null ? void 0 : _.props) == null ? void 0 : z.layout) !== "Layered" && await oe.compositor.update(_.id, {
      id: "foreground",
      name: "Overlays",
      layout: "Layered"
    });
  }, ne = async () => {
    validateEachChildren(v.children, ["Background"]) || v.children.forEach(async (Z) => {
      await CoreContext.Command.deleteNode({
        nodeId: Z.id
      });
    });
  }, fe = async () => {
    const Z = async () => {
      var I;
      if (Y)
        return Y.id;
      {
        const N = await oe.compositor.insert({
          name: "BannerContainer",
          id: "fg-banners",
          layout: "Column",
          layoutProps: {
            cover: !0
          }
        }, _.id);
        return Y = (I = _ == null ? void 0 : _.children) == null ? void 0 : I.find(($) => $.id === N), N;
      }
    }, z = async () => {
      var I;
      if (L)
        return L.id;
      {
        const N = await oe.compositor.insert({
          name: "ImageIframeOverlay",
          id: "fg-image-iframe",
          layout: "Free"
        }, _.id);
        return L = (I = _ == null ? void 0 : _.children) == null ? void 0 : I.find(($) => $.id === N), N;
      }
    }, P = async () => {
      var I;
      if (V)
        return V.id;
      {
        const N = await oe.compositor.insert({
          name: "AlertContainer",
          id: "alert",
          layout: "Layered",
          layoutProps: {
            type: "alert",
            preset: "center"
          }
        }, _.id);
        return V = (I = _ == null ? void 0 : _.children) == null ? void 0 : I.find(($) => $.id === N), N;
      }
    }, S = async () => {
      var I;
      if (X)
        return X.id;
      {
        const N = await oe.compositor.insert({
          name: "VideoOverlay",
          id: "fg-video",
          layout: "Free"
        }, _.id);
        return X = (I = _ == null ? void 0 : _.children) == null ? void 0 : I.find(($) => $.id === N), N;
      }
    }, E = async () => {
      var I;
      if (F)
        return F.id;
      {
        const N = await oe.compositor.insert({
          name: "LogoContainer",
          layout: "Free",
          id: "logo"
        }, _.id);
        return F = (I = _ == null ? void 0 : _.children) == null ? void 0 : I.find(($) => $.id === N), N;
      }
    };
    try {
      const I = await Promise.all([Z(), z(), P(), S(), E()]);
      await oe.compositor.reorder(_.id, I);
    } catch {
    }
  }, ie = {
    getBackground() {
      return v;
    },
    getContent() {
      return p;
    },
    getForeground() {
      return _;
    },
    getLayout() {
      return p.props.layout;
    },
    getBanners() {
      var Z;
      return ((Z = getProject(a.id).props) == null ? void 0 : Z.banners) || [];
    },
    getParticipants() {
      return p.children.concat(k.children).filter((Z) => Z.props.sourceType === "RoomParticipant");
    },
    getLogo() {
      var Z, z;
      return (z = (Z = F == null ? void 0 : F.children[0]) == null ? void 0 : Z.props) == null ? void 0 : z.id;
    },
    async updateLayoutProps(Z, z, P) {
      l.setNodeLayout({
        nodeId: Z,
        layout: z,
        layoutProps: {
          ...P
        }
      });
    },
    getVideoRendering() {
      return M;
    },
    async updateVideoRendering(Z) {
      l.updateProjectVideoRendering({
        projectId: u,
        videoRendering: Z
      });
    },
    async removeLogo() {
      const [Z, ...z] = (F == null ? void 0 : F.children) || [];
      z.forEach((P) => {
        CoreContext.Command.deleteNode({
          nodeId: P.id
        });
      }), Z && await CoreContext.Command.deleteNode({
        nodeId: Z.id
      });
    },
    getImageOverlay() {
      var z, P;
      const Z = (z = L == null ? void 0 : L.children) == null ? void 0 : z.find((S) => {
        var E, I;
        return ((I = (E = S == null ? void 0 : S.props) == null ? void 0 : E.sourceProps) == null ? void 0 : I.type) === "image";
      });
      return (P = Z == null ? void 0 : Z.props) == null ? void 0 : P.id;
    },
    getVideoOverlay() {
      var z, P;
      const Z = (z = X == null ? void 0 : X.children) == null ? void 0 : z.find((S) => {
        var E, I;
        return ((I = (E = S == null ? void 0 : S.props) == null ? void 0 : E.sourceProps) == null ? void 0 : I.type) === "video";
      });
      return (P = Z == null ? void 0 : Z.props) == null ? void 0 : P.id;
    },
    autoPlayBackgroundVideo(Z = {
      muted: !0,
      autoplay: !0
    }) {
      const z = v.children.find((P) => P.props.id === "bg-video");
      z && CoreContext.Command.updateNode({
        nodeId: z.id,
        props: {
          ...z.props,
          attributes: {
            ...z.props.attributes,
            ...Z
          }
        }
      });
    },
    autoPlayVideoOverlay(Z, z = {
      muted: !0,
      autoplay: !0
    }) {
      var S;
      const P = (S = X == null ? void 0 : X.children) == null ? void 0 : S.find((E) => {
        var I, N;
        return ((N = (I = E.props) == null ? void 0 : I.sourceProps) == null ? void 0 : N.id) === Z;
      });
      P && P.props.sourceProps.type === "video" && CoreContext.Command.updateNode({
        nodeId: P.id,
        props: {
          ...P.props,
          attributes: {
            ...P.props.attributes,
            ...z
          }
        }
      });
    },
    getBackgroundMedia() {
      var z, P;
      return (P = (z = v.children.filter((S) => S)[0]) == null ? void 0 : z.props) == null ? void 0 : P.id;
    },
    getBackgroundImage() {
      var z;
      const Z = v.children.find((P) => {
        var S, E;
        return ((E = (S = P.props) == null ? void 0 : S.sourceProps) == null ? void 0 : E.type) === "image";
      });
      return (z = Z == null ? void 0 : Z.props) == null ? void 0 : z.id;
    },
    getBackgroundVideo() {
      var z;
      const Z = v.children.find((P) => {
        var S, E;
        return ((E = (S = P.props) == null ? void 0 : S.sourceProps) == null ? void 0 : E.type) === "video";
      });
      return (z = Z == null ? void 0 : Z.props) == null ? void 0 : z.id;
    },
    async addLogo(Z, z) {
      const [P, ...S] = (F == null ? void 0 : F.children) || [];
      S.forEach((E) => {
        CoreContext.Command.deleteNode({
          nodeId: E.id
        });
      }), P ? await CoreContext.Command.updateNode({
        nodeId: P.id,
        props: {
          sourceType: "Logo",
          id: Z,
          sourceProps: {
            ...z,
            meta: {
              style: {
                ...defaultStyles.logo
              },
              ...z.meta
            }
          }
        }
      }) : await CoreContext.Command.createNode({
        parentId: F == null ? void 0 : F.id,
        props: {
          sourceType: "Logo",
          id: Z,
          sourceProps: {
            ...z,
            meta: {
              style: {
                ...defaultStyles.logo
              },
              ...z.meta
            }
          }
        }
      });
    },
    addBanner(Z = {}) {
      var E;
      const z = Z.meta || {}, P = {
        id: generateId(),
        props: {
          ...Z,
          meta: z
        }
      }, S = ((E = getProject(u).props) == null ? void 0 : E.banners) || [];
      return l.updateProjectProps({
        projectId: u,
        props: {
          banners: [...S, P]
        }
      });
    },
    editBanner(Z, z = {}) {
      const S = ie.getBanners().map((E) => E.id !== Z ? E : {
        ...E,
        props: z
      });
      return l.updateProjectProps({
        projectId: u,
        props: {
          banners: S
        }
      });
    },
    removeBanner(Z) {
      var P;
      const z = ie.getBanners();
      return (P = Y == null ? void 0 : Y.children) == null || P.forEach((S) => {
        S.props.bannerId === Z && CoreContext.Command.deleteNode({
          nodeId: S.id
        });
      }), l.updateProjectProps({
        projectId: u,
        props: {
          banners: z.filter((S) => S.id !== Z)
        }
      });
    },
    async setActiveBanner(Z) {
      var E, I;
      const [z, ...{}] = (Y == null ? void 0 : Y.children) || [];
      ((I = (E = z == null ? void 0 : z.props) == null ? void 0 : E.sourceType) == null ? void 0 : I.toLowerCase()) === "chatoverlay" && await CoreContext.Command.deleteNode({
        nodeId: z.id
      });
      const [P, ...S] = (Y == null ? void 0 : Y.children) || [];
      if (S.forEach((N) => {
        CoreContext.Command.deleteNode({
          nodeId: N.id
        });
      }), P)
        CoreContext.Command.updateNode({
          nodeId: P.id,
          props: {
            sourceType: "Banner",
            bannerId: Z
          }
        });
      else
        return CoreContext.Command.createNode({
          parentId: Y == null ? void 0 : Y.id,
          props: {
            sourceType: "Banner",
            bannerId: Z
          }
        });
    },
    getActiveBanner() {
      var Z, z, P;
      return ((P = (z = (Z = Y.children) == null ? void 0 : Z[0]) == null ? void 0 : z.props) == null ? void 0 : P.bannerId) ?? null;
    },
    async addChatOverlay(Z, z) {
      var I, N;
      const [P, ...{}] = (Y == null ? void 0 : Y.children) || [];
      ((N = (I = P == null ? void 0 : P.props) == null ? void 0 : I.sourceType) == null ? void 0 : N.toLowerCase()) === "banner" && await CoreContext.Command.deleteNode({
        nodeId: P.id
      });
      const [S, ...E] = (Y == null ? void 0 : Y.children) || [];
      E.forEach(($) => {
        CoreContext.Command.deleteNode({
          nodeId: $.id
        });
      }), S ? await CoreContext.Command.updateNode({
        nodeId: S.id,
        props: {
          sourceType: "ChatOverlay",
          chatOverlayId: Z,
          id: Z,
          ...z
        }
      }) : await CoreContext.Command.createNode({
        parentId: Y == null ? void 0 : Y.id,
        props: {
          sourceType: "ChatOverlay",
          chatOverlayId: Z,
          id: Z,
          ...z
        }
      });
    },
    async removeChatOverlay(Z) {
      var z;
      (z = Y == null ? void 0 : Y.children) == null || z.forEach(async (P) => {
        P.props.chatOverlayId === Z && await CoreContext.Command.deleteNode({
          nodeId: P.id
        });
      });
    },
    getChatOverlay() {
      var Z, z, P, S, E;
      return (P = (z = (Z = Y.children) == null ? void 0 : Z[0]) == null ? void 0 : z.props) != null && P.chatOverlayId && ((E = (S = Y.children) == null ? void 0 : S[0]) == null ? void 0 : E.props) || null;
    },
    getCustomOverlay() {
      var z, P;
      const Z = (z = L == null ? void 0 : L.children) == null ? void 0 : z.find((S) => {
        var E, I;
        return ((I = (E = S == null ? void 0 : S.props) == null ? void 0 : E.sourceProps) == null ? void 0 : I.type) === "custom";
      });
      return (P = Z == null ? void 0 : Z.props) == null ? void 0 : P.id;
    },
    async addImageOverlay(Z, z) {
      const [P, ...S] = (L == null ? void 0 : L.children) || [];
      S.forEach((I) => {
        CoreContext.Command.deleteNode({
          nodeId: I.id
        });
      });
      const E = {
        ...defaultStyles.image,
        ...(X == null ? void 0 : X.children.length) && {
          opacity: 0
        }
      };
      P ? await CoreContext.Command.updateNode({
        nodeId: P == null ? void 0 : P.id,
        props: {
          sourceType: "Overlay",
          id: Z,
          sourceProps: {
            ...z,
            type: "image",
            meta: {
              style: {
                ...E
              }
            }
          }
        }
      }) : await CoreContext.Command.createNode({
        parentId: L == null ? void 0 : L.id,
        props: {
          sourceType: "Overlay",
          id: Z,
          sourceProps: {
            ...z,
            type: "image",
            meta: {
              style: {
                ...E
              }
            }
          }
        }
      });
    },
    async addVideoOverlay(Z, z) {
      const [P, ...S] = (X == null ? void 0 : X.children) || [];
      S.forEach((E) => {
        CoreContext.Command.deleteNode({
          nodeId: E.id
        });
      }), L.children.forEach(({
        id: E,
        props: I
      }) => {
        var N, $;
        if ((($ = (N = I.sourceProps.meta) == null ? void 0 : N.style) == null ? void 0 : $.opacity) !== 0) {
          const U = I.sourceProps.type, H = {
            ...defaultStyles[U],
            opacity: 0
          };
          CoreContext.Command.updateNode({
            nodeId: E,
            props: {
              ...I,
              sourceProps: {
                ...I.sourceProps,
                meta: {
                  style: {
                    ...H
                  }
                }
              }
            }
          });
        }
      }), P ? await CoreContext.Command.updateNode({
        nodeId: P == null ? void 0 : P.id,
        props: {
          sourceType: "Overlay",
          id: Z,
          sourceProps: {
            ...z,
            type: "video",
            meta: {
              style: {
                ...defaultStyles.video
              },
              ...z.meta
            }
          }
        }
      }) : await CoreContext.Command.createNode({
        parentId: X == null ? void 0 : X.id,
        props: {
          sourceType: "Overlay",
          id: Z,
          sourceProps: {
            ...z,
            type: "video",
            meta: {
              style: {
                ...defaultStyles.video
              },
              ...z.meta
            }
          }
        }
      });
    },
    async updateVideoOverlayProps(Z, z) {
      var S, E;
      const P = ((S = X == null ? void 0 : X.children) == null ? void 0 : S.find((I) => {
        var N;
        return ((N = I == null ? void 0 : I.props) == null ? void 0 : N.id) === Z;
      })) || null;
      P && await CoreContext.Command.updateNode({
        nodeId: P == null ? void 0 : P.id,
        props: {
          sourceType: "Overlay",
          id: Z,
          sourceProps: {
            ...(E = P == null ? void 0 : P.props) == null ? void 0 : E.sourceProps,
            ...z,
            meta: {
              style: {
                ...defaultStyles.video
              },
              ...z.meta
            }
          }
        }
      });
    },
    async addAlertOverlay(Z, z) {
      const [P, ...S] = (V == null ? void 0 : V.children) || [];
      S.forEach(($) => {
        CoreContext.Command.deleteNode({
          nodeId: $.id
        });
      });
      const E = {
        ...defaultStyles.alert,
        ...(X == null ? void 0 : X.children.length) && {
          opacity: 0
        }
      }, {
        x: I
      } = c.props.size, N = (I ?? 1920) / 1920;
      P ? await CoreContext.Command.updateNode({
        nodeId: P == null ? void 0 : P.id,
        props: {
          sourceType: "Alert",
          id: Z,
          sourceProps: {
            ...z,
            meta: {
              style: {
                ...E,
                transform: `scale(${N})`
              }
            }
          }
        }
      }) : await CoreContext.Command.createNode({
        parentId: V == null ? void 0 : V.id,
        props: {
          sourceType: "Alert",
          id: Z,
          sourceProps: {
            ...z,
            meta: {
              style: {
                ...E,
                transform: `scale(${N})`
              }
            }
          }
        }
      });
    },
    async removeAlertOverlay() {
      var P;
      const [Z, ...z] = (V == null ? void 0 : V.children) || [];
      z.forEach((S) => {
        CoreContext.Command.deleteNode({
          nodeId: S.id
        });
      }), Z && ((P = Z == null ? void 0 : Z.props) == null ? void 0 : P.sourceType) === "Alert" && await CoreContext.Command.deleteNode({
        nodeId: Z.id
      });
    },
    async addCustomOverlay(Z, z) {
      const [P, ...S] = (L == null ? void 0 : L.children) || [];
      S.forEach((I) => {
        CoreContext.Command.deleteNode({
          nodeId: I.id
        });
      });
      const E = {
        ...defaultStyles.custom,
        ...(X == null ? void 0 : X.children.length) && {
          opacity: 0
        }
      };
      P ? await CoreContext.Command.updateNode({
        nodeId: P == null ? void 0 : P.id,
        props: {
          sourceType: "Overlay",
          id: Z,
          sourceProps: {
            ...z,
            type: "custom",
            meta: {
              style: {
                ...E
              }
            }
          }
        }
      }) : await CoreContext.Command.createNode({
        parentId: L == null ? void 0 : L.id,
        props: {
          sourceType: "Overlay",
          id: Z,
          sourceProps: {
            ...z,
            type: "custom",
            meta: {
              style: {
                ...E
              }
            }
          }
        }
      });
    },
    async removeCustomOverlay() {
      var P, S;
      const [Z, ...z] = (L == null ? void 0 : L.children) || [];
      z.forEach((E) => {
        CoreContext.Command.deleteNode({
          nodeId: E.id
        });
      }), Z && ((S = (P = Z == null ? void 0 : Z.props) == null ? void 0 : P.sourceProps) == null ? void 0 : S.type) === "custom" && await CoreContext.Command.deleteNode({
        nodeId: Z.id
      });
    },
    async removeImageOverlay() {
      var P, S;
      const [Z, ...z] = (L == null ? void 0 : L.children) || [];
      z.forEach((E) => {
        CoreContext.Command.deleteNode({
          nodeId: E.id
        });
      }), Z && ((S = (P = Z == null ? void 0 : Z.props) == null ? void 0 : P.sourceProps) == null ? void 0 : S.type) === "image" && await CoreContext.Command.deleteNode({
        nodeId: Z.id
      });
    },
    async removeVideoOverlay() {
      const [Z, ...z] = (X == null ? void 0 : X.children) || [];
      z.forEach((P) => {
        CoreContext.Command.deleteNode({
          nodeId: P.id
        });
      }), Z && await CoreContext.Command.deleteNode({
        nodeId: Z.id
      }), L == null || L.children.forEach(({
        id: P,
        props: S
      }) => {
        var E, I;
        if (((I = (E = S.sourceProps.meta) == null ? void 0 : E.style) == null ? void 0 : I.opacity) === 0) {
          const N = S.sourceProps.type, $ = {
            ...defaultStyles[N],
            opacity: 1
          };
          CoreContext.Command.updateNode({
            nodeId: P,
            props: {
              ...S,
              sourceProps: {
                ...S.sourceProps,
                meta: {
                  style: {
                    ...$
                  }
                }
              }
            }
          });
        }
      });
    },
    setLayout(Z, z = {}) {
      const P = p.props.layoutProps.showcase;
      l.setNodeLayout({
        nodeId: p.id,
        layout: Z,
        layoutProps: {
          showcase: P,
          ...z
        }
      });
    },
    async setBackgroundImage(Z, z) {
      const [P, ...S] = (v == null ? void 0 : v.children) || [];
      S.forEach((E) => {
        CoreContext.Command.deleteNode({
          nodeId: E.id
        });
      }), P ? await CoreContext.Command.updateNode({
        nodeId: P.id,
        props: {
          id: Z,
          sourceType: "Background",
          sourceProps: {
            ...z,
            type: "image",
            meta: {
              style: {
                ...defaultStyles.image
              },
              ...z == null ? void 0 : z.meta
            }
          }
        }
      }) : await CoreContext.Command.createNode({
        parentId: v == null ? void 0 : v.id,
        props: {
          id: Z,
          sourceType: "Background",
          sourceProps: {
            ...z,
            type: "image",
            meta: {
              style: {
                ...defaultStyles.image
              },
              ...z == null ? void 0 : z.meta
            }
          }
        }
      });
    },
    async setBackgroundVideo(Z, z) {
      const [P, ...S] = (v == null ? void 0 : v.children) || [];
      S.forEach((E) => {
        CoreContext.Command.deleteNode({
          nodeId: E.id
        });
      }), P ? await CoreContext.Command.updateNode({
        nodeId: P.id,
        props: {
          id: Z,
          sourceType: "Background",
          sourceProps: {
            ...z,
            type: "video",
            meta: {
              style: {
                ...defaultStyles.video
              },
              ...z == null ? void 0 : z.meta
            }
          }
        }
      }) : await CoreContext.Command.createNode({
        parentId: v == null ? void 0 : v.id,
        props: {
          id: Z,
          sourceType: "Background",
          sourceProps: {
            ...z,
            type: "video",
            meta: {
              style: {
                ...defaultStyles.video
              },
              ...z == null ? void 0 : z.meta
            }
          }
        }
      });
    },
    async updateBackgroundVideoProps(Z, z) {
      var S, E;
      const P = ((S = v == null ? void 0 : v.children) == null ? void 0 : S.find((I) => {
        var N;
        return ((N = I == null ? void 0 : I.props) == null ? void 0 : N.id) === Z;
      })) || null;
      P && await CoreContext.Command.updateNode({
        nodeId: P == null ? void 0 : P.id,
        props: {
          sourceType: "Background",
          id: Z,
          sourceProps: {
            ...(E = P == null ? void 0 : P.props) == null ? void 0 : E.sourceProps,
            ...z,
            meta: {
              style: {
                ...defaultStyles.video
              },
              ...z.meta
            }
          }
        }
      });
    },
    async removeBackgroundImage() {
      const [Z, ...z] = (v == null ? void 0 : v.children) || [];
      z.forEach((P) => {
        CoreContext.Command.deleteNode({
          nodeId: P.id
        });
      }), Z && Z.props.sourceProps.type === "image" && await CoreContext.Command.deleteNode({
        nodeId: Z.id
      });
    },
    async removeBackgroundVideo() {
      const [Z, ...z] = (v == null ? void 0 : v.children) || [];
      z.forEach((P) => {
        CoreContext.Command.deleteNode({
          nodeId: P.id
        });
      }), Z && Z.props.sourceProps.type === "video" && await CoreContext.Command.deleteNode({
        nodeId: Z.id
      });
    },
    /* A function that takes in a sourceType and a callback function. It then creates a shallow copy of
      the root node and finds all the nodes that have the same sourceType as the one passed in. It then
      creates a listener for when the node changes, is added, or is removed. When any of these events
      happen, it will call the callback function with the new state. */
    useLayerState(Z, z) {
      const P = cloneDeep$1(c);
      let S = findAll(P, (U) => U.props.sourceType === Z);
      const E = () => {
        z((S == null ? void 0 : S.map((U) => U.props)) || {});
      }, I = CoreContext.onInternal("NodeChanged", (U) => {
        const H = S == null ? void 0 : S.find((D) => D.id === U.nodeId);
        if (S != null && S.length && !H)
          return;
        const B = S, T = cloneDeep$1(c);
        S = findAll(T, (D) => {
          var ee;
          return ((ee = D == null ? void 0 : D.props) == null ? void 0 : ee.sourceType) === Z;
        }), deepEqual(B, S) || E();
      }), N = CoreContext.onInternal("NodeAdded", (U) => {
        var D;
        if (S == null ? void 0 : S.find((ee) => ee.id === U.nodeId))
          return;
        const B = cloneDeep$1(c);
        S = findAll(B, (ee) => {
          var pe;
          return ((pe = ee == null ? void 0 : ee.props) == null ? void 0 : pe.sourceType) === Z;
        });
        const T = S == null ? void 0 : S.find((ee) => ee.id === U.nodeId);
        ((D = T == null ? void 0 : T.props) == null ? void 0 : D.sourceType) === Z && E();
      }), $ = CoreContext.onInternal("NodeRemoved", (U) => {
        var B;
        const H = S == null ? void 0 : S.find((T) => T.id === U.nodeId);
        H && (S = S == null ? void 0 : S.filter((T) => T.id !== U.nodeId), ((B = H == null ? void 0 : H.props) == null ? void 0 : B.sourceType) === Z && E());
      });
      return E(), () => {
        I(), N(), $();
      };
    },
    setShowcase(Z, z = "camera") {
      const P = ie.getParticipantNode(Z, z);
      return CoreContext.Command.updateNode({
        nodeId: p.id,
        props: {
          layoutProps: {
            ...p.props.layoutProps,
            showcase: (P == null ? void 0 : P.id) ?? null
          }
        }
      });
    },
    useShowcase(Z) {
      const z = () => {
        const P = p.props.layoutProps.showcase, S = p.children.find((I) => I.id === P);
        if (!S)
          return Z({
            participantId: null,
            type: null
          });
        const {
          sourceProps: E
        } = S.props;
        return Z({
          participantId: E.id,
          type: E.type
        });
      };
      return z(), CoreContext.onInternal("NodeChanged", (P) => {
        P.nodeId === p.id && z();
      });
    },
    async addSourceNode(Z, z = {
      isMuted: !0,
      isHidden: !1,
      volume: 0,
      isAudioOnly: !1
    }, P = "rtmp") {
      if (addingCache[P].has(Z))
        return;
      const {
        isMuted: S = !1,
        isHidden: E = !1,
        volume: I = 1,
        isAudioOnly: N = !1
      } = z, $ = N ? k : p;
      $.children.find((H) => {
        var B;
        return ((B = H.props.sourceProps) == null ? void 0 : B.id) === Z;
      }) || (addingCache[P].add(Z), await CoreContext.Command.createNode({
        props: {
          name: ExternalSourceTypeMap[P],
          sourceType: ExternalSourceTypeMap[P],
          sourceProps: {
            type: P,
            id: Z
          },
          volume: I,
          isMuted: S,
          isHidden: E,
          isAudioOnly: N
        },
        parentId: $.id
      }).finally(() => {
        addingCache[P].delete(Z);
      }));
    },
    async removeSourceNode(Z) {
      const P = getProject(u).videoApi.project.sources.find((E) => E.preview.webrtc.participantId === Z);
      if (!P)
        return;
      const S = P.address.dynamic.id === "integration" ? ExternalSourceTypeMap.game : ExternalSourceTypeMap.rtmp;
      p.children.concat(k.children).filter((E) => {
        var I;
        return ((I = E.props.sourceProps) == null ? void 0 : I.id) === Z && E.props.sourceType === S;
      }).forEach((E) => {
        CoreContext.Command.deleteNode({
          nodeId: E.id
        });
      });
    },
    getSourceNode(Z) {
      return p.children.concat(k.children).find((z) => {
        var P;
        return ((P = z.props.sourceProps) == null ? void 0 : P.id) === Z;
      });
    },
    useSourceNodes(Z, z = "rtmp") {
      let P = [];
      const S = () => {
        const N = p.children.concat(k.children).filter(($) => {
          var U, H;
          return ((H = (U = $.props) == null ? void 0 : U.sourceProps) == null ? void 0 : H.type) === z;
        });
        return P = N.map(($) => $.id), Z(N);
      };
      S();
      const E = CoreContext.onInternal("NodeChanged", (N) => {
        N.nodeId !== p.id && N.nodeId !== k.id || S();
      }), I = CoreContext.onInternal("NodeRemoved", (N) => {
        P.indexOf(N.nodeId) !== -1 && S();
      });
      return () => {
        E(), I();
      };
    },
    setSourceNodeVolume(Z, z) {
      const P = ie.getSourceNode(Z);
      P && CoreContext.Command.updateNode({
        nodeId: P.id,
        props: {
          volume: z
        }
      });
    },
    setSourceNodeMuted(Z, z) {
      const P = ie.getSourceNode(Z);
      P && CoreContext.Command.updateNode({
        nodeId: P.id,
        props: {
          isMuted: z
        }
      });
    },
    async addParticipantTrack(Z, z = {
      isMuted: !0,
      isHidden: !1,
      isAudioOnly: !1,
      volume: 0
    }, P = "camera") {
      if (addingCache[P].has(Z))
        return;
      const {
        isMuted: S = !1,
        isHidden: E = !1,
        volume: I = 1,
        isAudioOnly: N = !1
      } = z;
      if (p.children.concat(k.children).find((B) => {
        var T, D;
        return ((T = B.props.sourceProps) == null ? void 0 : T.id) === Z && ((D = B.props.sourceProps) == null ? void 0 : D.type) === P;
      }))
        return;
      addingCache[P].add(Z);
      const U = p.children[0];
      let H = p.children.length;
      P === "screen" && (U == null ? void 0 : U.props.sourceProps.type) !== "screen" && (H = 0), await CoreContext.Command.createNode({
        props: {
          name: "Participant",
          sourceType: "RoomParticipant",
          sourceProps: {
            type: P,
            id: Z
          },
          volume: I,
          isMuted: S,
          isHidden: E,
          isAudioOnly: N
        },
        parentId: p.id,
        index: H
      }).finally(() => {
        addingCache[P].delete(Z);
      });
    },
    removeParticipantTrack(Z, z = "camera") {
      p.children.filter((P) => {
        var S, E;
        return ((S = P.props.sourceProps) == null ? void 0 : S.id) === Z && ((E = P.props.sourceProps) == null ? void 0 : E.type) === z && P.props.sourceType === "RoomParticipant";
      }).forEach((P) => {
        CoreContext.Command.deleteNode({
          nodeId: P.id
        });
      });
    },
    async addParticipant(Z, z = {}, P = "camera") {
      if (addingCache[P].has(Z))
        return;
      const {
        isMuted: S = !1,
        isHidden: E = !1,
        volume: I = 1,
        isAudioOnly: N = !1
      } = z;
      if (p.children.find((T) => {
        var D, ee;
        return ((D = T.props.sourceProps) == null ? void 0 : D.id) === Z && ((ee = T.props.sourceProps) == null ? void 0 : ee.type) === P;
      }))
        return;
      let U = N ? k : p;
      addingCache[P].add(Z);
      const H = U.children[0];
      let B = U.children.length;
      P === "screen" && (H == null ? void 0 : H.props.sourceProps.type) !== "screen" && (B = 0), await CoreContext.Command.createNode({
        props: {
          name: "Participant",
          sourceType: "RoomParticipant",
          sourceProps: {
            type: P,
            id: Z
          },
          volume: I,
          isMuted: S,
          isHidden: E,
          isAudioOnly: N
        },
        parentId: U.id,
        index: B
      }).finally(() => {
        addingCache[P].delete(Z);
      });
    },
    removeParticipant(Z, z = "camera") {
      p.children.concat(k.children).filter((P) => {
        var S, E;
        return ((S = P.props.sourceProps) == null ? void 0 : S.id) === Z && ((E = P.props.sourceProps) == null ? void 0 : E.type) === z && P.props.sourceType === "RoomParticipant";
      }).forEach((P) => {
        CoreContext.Command.deleteNode({
          nodeId: P.id
        });
      });
    },
    getParticipantNode(Z, z = "camera") {
      return p.children.concat(k.children).find((P) => {
        var S, E;
        return ((S = P.props.sourceProps) == null ? void 0 : S.id) === Z && ((E = P.props.sourceProps) == null ? void 0 : E.type) === z;
      });
    },
    getParticipantState(Z, z = "camera") {
      var P;
      return (P = ie.getParticipantNode(Z, z)) == null ? void 0 : P.props;
    },
    useParticipantState(Z, z, P = "camera") {
      let S = ie.getParticipantNode(Z, P);
      const E = () => {
        z(S == null ? void 0 : S.props);
      }, I = CoreContext.onInternal("NodeChanged", ($) => {
        if (![p.id, k.id].includes($.nodeId))
          return;
        const U = S;
        S = ie.getParticipantNode(Z, P), U !== S && E();
      }), N = CoreContext.onInternal("NodeChanged", ($) => {
        !S || $.nodeId !== S.id || E();
      });
      return E(), () => {
        I(), N();
      };
    },
    setParticipantVolume(Z, z, P = "camera") {
      const S = ie.getParticipantNode(Z, P);
      S && CoreContext.Command.updateNode({
        nodeId: S.id,
        props: {
          volume: z
        }
      });
    },
    setParticipantMuted(Z, z, P = "camera") {
      const S = ie.getParticipantNode(Z, P);
      S && CoreContext.Command.updateNode({
        nodeId: S.id,
        props: {
          isMuted: z
        }
      });
    },
    setParticipantHidden(Z, z, P = "camera") {
      const S = ie.getParticipantNode(Z, P);
      S && CoreContext.Command.updateNode({
        nodeId: S.id,
        props: {
          isHidden: z
        }
      });
    },
    setParticipantAudioOnly(Z, z, P = "camera") {
      const S = ie.getParticipantNode(Z, P);
      if (!S)
        return;
      CoreContext.Command.updateNode({
        nodeId: S.id,
        props: {
          isAudioOnly: z
        }
      });
      let E = z ? k : p;
      CoreContext.Command.moveNode({
        nodeId: S.id,
        parentId: E.id,
        index: E.children.length
      });
    },
    pruneParticipants() {
      const Z = getProjectRoom(u);
      Z && p.children.concat((k == null ? void 0 : k.children) ?? []).filter((z) => {
        var $, U, H;
        if (z.props.sourceType !== "RoomParticipant")
          return !1;
        const P = ($ = z.props.sourceProps) == null ? void 0 : $.type, S = Z.getParticipant((U = z.props.sourceProps) == null ? void 0 : U.id), E = Z.getTrack((H = z.props.sourceProps) == null ? void 0 : H.id);
        return !S && !E ? !0 : P === "camera" ? !1 : !S.trackIds.map((B) => Z.getTrack(B)).filter(Boolean).some((B) => (B.type === Track.Source.Camera || B.type === Track.Source.Microphone ? "camera" : "screen") === P);
      }).forEach((z) => {
        CoreContext.Command.deleteNode({
          nodeId: z.id
        });
      });
    },
    getProp(Z) {
      return getProject(a.id).props[Z];
    },
    setProp(Z, z) {
      return l.updateProjectProps({
        projectId: u,
        props: {
          [Z]: z
        }
      });
    },
    useProp(Z, z) {
      return CoreContext.on("ProjectChanged", (P) => {
        u === P.project.id && z(P.project.props[Z]);
      });
    },
    createSource(Z) {
      return CoreContext.Command.createSource({
        projectId: u,
        ...Z
      });
    },
    deleteSource(Z) {
      return CoreContext.Command.deleteSource({
        projectId: u,
        sourceId: Z
      });
    },
    createGameSource(Z) {
      if (!getProject(a.id).videoApi.project.sources.find((P) => {
        var S, E;
        return ((E = (S = P.address) == null ? void 0 : S.dynamic) == null ? void 0 : E.id) === "integration";
      }))
        return CoreContext.Command.createSource({
          projectId: u,
          ...Z
        });
    }
  };
  return (async () => {
    await ae(), await ne(), await fe();
  })(), ie;
}, create = async (a = {}, u = {}, c) => CoreContext.Command.createProject({
  settings: a,
  props: u,
  size: c
}), createCompositor = async (a, u, c) => {
  const {
    layout: l,
    layoutProps: v = {}
  } = c, p = await CoreContext.compositor.createProject({
    props: {
      name: "Root",
      type: "sceneless-project",
      sourceType: "Element",
      layout: "Layered",
      size: u,
      isRoot: !0,
      tagName: "div",
      version: "beta",
      fields: {
        style: {
          background: "black"
        }
      }
    }
  }, a), _ = p.getRoot(), k = await Promise.all([p.insert({
    id: "audio",
    name: "AudioContainer",
    layout: "Free",
    size: {
      x: 0,
      y: 0
    },
    position: {
      x: 0,
      y: 0
    },
    opacity: 0
  }, _.id), p.insert({
    name: "Background",
    id: "bg",
    layout: "Layered"
  }, _.id), p.insert({
    id: "content",
    name: "Content",
    layout: l,
    layoutProps: v
  }, _.id), p.insert({
    id: "foreground",
    name: "Overlays",
    layout: "Layered"
  }, _.id)]);
  await p.reorder(_.id, k);
  const M = _.children.find((V) => V.props.id === "foreground"), L = ForegroundLayers.map((V) => p.insert(V, M.id)), F = await Promise.all(L);
  return await p.reorder(M.id, F), p;
}, scenelessProject = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  commands,
  create,
  createCompositor
}, Symbol.toStringTag, { value: "Module" })), useActiveProjectRoom = (a) => {
  const u = getProject(CoreContext.state.activeProjectId);
  return a(u ? getRoom(u.roomId) : null), CoreContext.on("RoomJoined", () => {
    const c = getProject(CoreContext.state.activeProjectId);
    a(c ? getRoom(c.roomId) : null);
  });
}, callbacks = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  useActiveProjectRoom
}, Symbol.toStringTag, { value: "Module" })), index$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Callback: callbacks,
  React: react,
  Room: webrtc,
  ScenelessProject: scenelessProject
}, Symbol.toStringTag, { value: "Module" })), runFilters = (a, u = []) => u.reduce((c, l) => l(c), a), transforms = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  runFilters
}, Symbol.toStringTag, { value: "Module" })), createDefault = () => ({
  root: document.createElement("div")
}), init$2 = (a = {}, u, c) => {
  const l = {}, v = a.defaultTransforms || {}, p = (ne) => {
    asArray(ne).forEach((fe) => {
      l[fe.name] = fe;
    });
  }, _ = {}, k = {}, M = {}, L = (ne) => M[ne] || [], F = (ne) => k[ne] || [], V = (ne) => _[ne], X = (ne) => l[ne];
  u.on("SourceChanged", (ne) => {
    F(ne.id).forEach((ie) => {
      const ge = u.getNode(ie.nodeId);
      ie._onUpdateHandlers.forEach((be) => be(ge.props || {}));
    });
  }), u.on("AvailableSourcesChanged", ({
    type: ne,
    sources: fe
  }) => {
    L(ne).forEach((ge) => {
      oe(ge.nodeId);
    });
  });
  const oe = (ne) => {
    var Z, z, P;
    const fe = V(ne);
    if (!fe)
      return;
    const ie = X(fe.transformName);
    if (!ie.useSource)
      return;
    const ge = u.getNode(ne), be = fe.sourceType, Ce = c.getSources(be), Me = ie.useSource(Ce, ge.props), Be = fe.sourceValue, Ae = Me == null ? void 0 : Me.value;
    fe.source !== Me && (k[(Z = fe.source) == null ? void 0 : Z.id] && (k[(z = fe.source) == null ? void 0 : z.id] = k[(P = fe.source) == null ? void 0 : P.id].filter((S) => S.nodeId !== ne)), k[Me == null ? void 0 : Me.id] = [...k[Me == null ? void 0 : Me.id] || [], fe]), fe.source = Me, fe.sourceValue = Ae, Object.is(Be, Ae) || fe._onNewSourceHandlers.forEach((S) => S(Me));
  }, Y = (ne) => {
    const fe = ae(ne), ge = runFilters(ne, []);
    return oe(ne.id), fe == null || fe._onUpdateHandlers.forEach((be) => be(ne.props || {})), {
      ...ge,
      children: ge.children.map(Y)
    };
  }, ae = (ne) => {
    if (_[ne.id])
      return _[ne.id];
    const {
      props: fe = {}
    } = ne, {
      sourceType: ie
    } = fe;
    if (!ie)
      return null;
    let ge = v[ie], be;
    if (ge ? be = l[ge] : be = Object.values(l).find((E) => E.sourceType === ie), !be)
      throw new Error("Could not find matching transform for sourceType: " + ie);
    const Ce = [], Me = [], Be = [], Ae = [], z = {
      ...(be.create || createDefault)({
        onEvent: (E, I, ...N) => {
          const $ = u.on(E, I, ...N);
          return Ae.push($), $;
        },
        onNewSource: (E) => Ce.push(E),
        onUpdate: (E) => Me.push(E),
        onRemove: (E) => Be.push(E)
      }, ne.props),
      sourceType: ie,
      nodeId: ne.id,
      transformName: be.name,
      _onNewSourceHandlers: Ce,
      _onUpdateHandlers: Me,
      _disposables: Ae
    };
    _[ne.id] = z;
    const P = ie;
    M[P] = [...M[P] || [], z], be.useSource && oe(ne.id);
    const S = [
      // Dispose when node is removed
      u.on("NodeRemoved", ({
        nodeId: E
      }) => {
        if (E === ne.id) {
          const I = u.getNode(E), {
            sourceType: N = "Element"
          } = I.props;
          S.forEach((U) => U == null ? void 0 : U()), Ae.forEach((U) => U == null ? void 0 : U()), Be.forEach((U) => U == null ? void 0 : U()), delete _[I.id];
          const $ = N;
          M[$] = M[$].filter((U) => U !== _[I.id]);
        }
      })
    ];
    return z;
  };
  return {
    transforms: l,
    nodeElementIndex: _,
    elementSourceTypeIndex: M,
    registerTransform: p,
    getElementsBySourceType: L,
    getElementByNodeId: V,
    getTransformByName: X,
    updateSourceForNode: oe,
    renderTree: Y,
    getElement: ae
  };
}, TRANSITION_DURATION = 300, findLayoutUp = (a, u, c = 0) => {
  const v = a.parentElement;
  return v instanceof Layout && (c = 0, !u || u(v)) ? v : v ? c > 4 ? null : findLayoutUp(v, u, c + 1) : null;
}, TRANSITION_FIELDS = "opacity, transform, width, height, left, right, top, bottom, inset", layoutIndex = {}, parentIdIndex = {}, childIndex = {};
let rootLayout, _cid = 1;
const ignoredAttributes = ["style", "id", "className"];
let tickOps = {};
const tick = () => {
  nextTick = null;
  const a = /* @__PURE__ */ new Set(), u = /* @__PURE__ */ new Set(), c = /* @__PURE__ */ new Set();
  Object.entries(tickOps).forEach(([l, v]) => {
    v.forEach(([p, _, k]) => {
      switch (p) {
        case "childInserted": {
          u.has(k) ? u.delete(k) : a.add(k);
          break;
        }
        case "childRemoved": {
          a.has(k) ? a.delete(k) : u.add(k);
          break;
        }
        case "childRemoveFinished": {
          c.add(k);
          break;
        }
      }
    });
  });
  try {
    u.forEach((v) => {
      var k, M, L;
      const p = childIndex[v], _ = Array.from(((k = p.parentEl) == null ? void 0 : k.children) || []);
      p.nextSiblingEl && _.includes(p.nextSiblingEl) ? (M = p.parentEl) == null || M.insertBefore(p, p.nextSiblingEl) : (p.nextSiblingEl = null, (L = p.parentEl) == null || L.append(p)), p.runRemove();
    }), c.forEach((v) => {
      const p = childIndex[v];
      if (p.removed) {
        p.previousSiblingEl && (p.previousSiblingEl.nextSiblingEl = p.nextSiblingEl), p.nextSiblingEl && (p.nextSiblingEl.previousSiblingEl = p.previousSiblingEl);
        return;
      }
    });
    const l = window.__scale;
    Object.entries(tickOps).forEach(([v, p]) => {
      const _ = layoutIndex[v], k = _.getBoundingClientRect(), M = {
        x: k.width / l,
        y: k.height / l
      };
      _.updatePositions({
        size: M,
        inserted: a,
        removed: u
      });
    });
  } catch (l) {
    log.warn("Failed to run Layout ops", l);
  }
  tickOps = {};
};
let nextTick;
const queueOp = (a) => {
  const [u, c] = a, l = tickOps[c] || [];
  tickOps[c] = [...l, a], nextTick = nextTick || requestAnimationFrame(tick);
};
class Layout extends HTMLElement {
  constructor() {
    super();
    Ft(this, "parentEl");
    Ft(this, "slotEl");
    Ft(this, "parentLayout");
    Ft(this, "nodes");
    Ft(this, "mutationObserver");
    Ft(this, "latestSize");
    Ft(this, "isFirst", !0);
    Ft(this, "isUpdating", !1);
    Ft(this, "cid");
    this.cid = ++_cid;
  }
  log(...c) {
    var l;
    log.debug(...c, {
      id: this.dataset.id,
      parent: (l = this.parentLayout) == null ? void 0 : l.dataset.id
    }, this);
  }
  connectedCallback() {
    var c;
    this.parentEl = this.parentElement, this.parentLayout = findLayoutUp(this), this.slotEl = this.closest("[data-layout-child]"), Array.from(this.children).forEach((l) => this.initializeChild(l)), rootLayout || (rootLayout = this), layoutIndex[this.dataset.id] = this, parentIdIndex[this.dataset.id] = (c = this.parentLayout) == null ? void 0 : c.id, Object.assign(this.style, {
      width: "100%",
      height: "100%",
      position: "absolute",
      top: "0px",
      left: "0px",
      pointerEvents: "none",
      boxSizing: "border-box"
    }), this.mutationObserver && this.mutationObserver.disconnect(), this.mutationObserver = new MutationObserver((l) => {
      this.isConnected && l.forEach((v) => {
        v.type === "attributes" && !ignoredAttributes.includes(v.attributeName) ? queueOp(["attributesChanged", this.dataset.id]) : v.type === "childList" && (v.addedNodes.forEach((p) => {
          const _ = childIndex[p.dataset.id];
          p.removed || (_ ? _ !== p && (this.initializeChild(p), p.setAttribute("style", _.getAttribute("style")), p.data = _.data) : this.initializeChild(p), queueOp(["childInserted", this.dataset.id, p.dataset.id]));
        }), v.removedNodes.forEach((p) => {
          p.removed || queueOp(["childRemoved", this.dataset.id, p.dataset.id]);
        }));
      });
    }), this.mutationObserver.observe(this, {
      childList: !0,
      attributes: !0
    }), this.latestSize || queueOp(["attributesChanged", this.dataset.id]);
  }
  disconnectedCallback() {
  }
  adoptedCallback() {
  }
  updatePositions(c) {
    if (this.isUpdating)
      return;
    this.isUpdating = !0;
    const {
      size: l,
      inserted: v = /* @__PURE__ */ new Set(),
      removed: p = /* @__PURE__ */ new Set()
    } = c;
    this.nodes = Array.from(this.children || []).filter((L) => !L.removed).map((L, F) => {
      const V = getElementAttributes(L);
      return {
        // TODO: Does this work well enough? Think through keying
        id: L.dataset.id,
        props: V,
        children: []
      };
    });
    const _ = JSON.parse(this.getAttribute("props") || "{}");
    this.latestSize = l;
    const k = {
      id: this.dataset.id,
      props: _,
      children: this.nodes,
      size: l
    };
    let M = layoutChildren(k);
    Promise.all(Object.entries(M).map(async ([L, F]) => {
      var be, Ce, Me, Be;
      let V = childIndex[L] || this.querySelector(`[data-layout-child][data-id="${L}"]`);
      const X = {
        ...V.data,
        ...F
      };
      V.data = X;
      const {
        size: oe,
        position: Y,
        zIndex: ae = 1,
        opacity: ne = 1,
        borderRadius: fe = 0,
        entryTransition: ie = {},
        exitTransition: ge = {}
      } = X;
      if (V) {
        if (V.removed)
          return;
        ge && (V.data.exitTransition = ge), ie && (V.data.entryTransition = ie), V.data.size = oe, V.data.position = Y;
        const Ae = window.__scale, Z = this.getBoundingClientRect(), z = Z.width / Ae, P = z - sizeToNum(Y.x, z) - sizeToNum(oe.x, z), S = Z.height / Ae, E = S - sizeToNum(Y.y, S) - sizeToNum(oe.y, S);
        Object.assign(V.style, {
          position: "absolute",
          transformOrigin: "50% 50%",
          transitionDuration: "0ms",
          transitionDelay: "0ms",
          transform: "translate3d(0, 0, 0) scaleX(1) scaleY(1)",
          visibility: "visible",
          boxSizing: "border-box",
          overflow: "hidden",
          borderRadius: fe + "px",
          width: "auto",
          height: "auto"
        });
        let I = "0ms", N = this.isFirst ? asDuration(0) : asDuration(TRANSITION_DURATION);
        if (v.has(L))
          Object.assign(V.style, {
            transitionProperty: TRANSITION_FIELDS,
            transitionDuration: "0ms",
            transitionTimingFunction: ie.timingFn ?? "ease",
            transform: `translate3d(calc(${asSize(((be = ie.offset) == null ? void 0 : be.x) ?? 0)}), calc(${asSize(((Ce = ie.offset) == null ? void 0 : Ce.y) ?? 0)}), 0) scaleX(${((Me = ie.scale) == null ? void 0 : Me.x) ?? 1}) scaleY(${((Be = ie.scale) == null ? void 0 : Be.y) ?? 1})`,
            opacity: ie.opacity ?? ne,
            left: asSize(Y.x) || 0,
            right: asSize(P) || 0,
            top: asSize(Y.y) || 0,
            bottom: asSize(E) || 0
          }), I = asDuration(ie.delay ?? 0);
        else if (V.data.rootOffset) {
          const H = rootLayout.getBoundingClientRect(), B = this.getBoundingClientRect(), T = {
            x: B.x / Ae - H.x / Ae,
            y: B.y / Ae - H.y / Ae
          }, D = T.x + B.width / Ae, ee = V.data.rootOffset.x + Number(V.data.size.x), pe = T.y + B.height / Ae, Ie = V.data.rootOffset.y + Number(V.data.size.y);
          V.data.rootOffset.x - T.x, V.data.rootOffset.y - T.y, D - ee, pe - Ie;
        }
        V.addEventListener("transitionstart", () => {
          V.style.zIndex = String(ae + 1);
        }), await new Promise((H) => window.setTimeout(H)), Object.assign(V.style, {
          transitionProperty: TRANSITION_FIELDS,
          transitionDuration: N,
          transitionDelay: I,
          transform: "translate3d(0, 0, 0) scaleX(1) scaleY(1)",
          opacity: ne,
          left: asSize(Y.x) || 0,
          top: asSize(Y.y) || 0,
          width: z ? "auto" : oe.x,
          right: z ? asSize(P) || 0 : "auto",
          height: S ? "auto" : oe.y,
          bottom: S ? asSize(E) || 0 : "auto",
          zIndex: ae
        });
        const U = () => {
          const H = rootLayout.getBoundingClientRect(), B = V.getBoundingClientRect();
          V.data.rootOffset = {
            x: B.x / Ae - H.x / Ae,
            y: B.y / Ae - H.y / Ae
          };
        };
        U(), V.addEventListener("transitionend", () => {
          V.style.zIndex = String(ae), U();
        });
      }
    })).then(() => {
      this.isUpdating = !1;
    }), this.isFirst = !1, Array.from(this.querySelectorAll("ls-layout")).forEach((L) => {
      if (!M[L.dataset.id])
        return;
      const F = M[L.dataset.id].size;
      L.updatePositions({
        size: {
          x: sizeToNum(F.x, l.x),
          y: sizeToNum(F.y, l.y)
        }
      });
    });
  }
  initializeChild(c) {
    var v;
    if (!((v = c.dataset) != null && v.id))
      return log.warn("Layout: Child requires `data-id` at the time it is added to a Layout");
    c._remove = c.remove, c.remove = () => {
      this.removeChild(c);
    }, c.mutationObserver || (c.mutationObserver = new MutationObserver((p) => {
      p.forEach((_) => {
        if (_.type === "attributes") {
          if (_.attributeName === "style")
            return;
          queueOp(["childAttributesChanged", this.dataset.id, c.dataset.id]);
        }
      });
    }), c.mutationObserver.observe(c, {
      childList: !0,
      attributes: !0
    }));
    const l = {
      entryTransition: {
        delay: 0,
        opacity: 0,
        scale: {
          x: 1,
          y: 1
        },
        offset: {
          x: 0,
          y: 0
        }
      },
      exitTransition: {
        delay: 0,
        opacity: 0,
        scale: {
          x: 1,
          y: 1
        },
        offset: {
          x: 0,
          y: 0
        }
      },
      position: {
        x: 0,
        y: 0
      },
      size: {
        x: 0,
        y: 0
      },
      opacity: 0,
      fit: "cover",
      borderRadius: 0,
      zIndex: 1
    };
    c.data = l, c.parentEl = c.parentElement, c.nextSiblingEl = c.nextSibling, c.previousSiblingEl = c.previousSibling, c.previousSiblingEl && (c.previousSiblingEl.nextSiblingEl = c), c.toggleAttribute("data-layout-child", !0), childIndex[c.dataset.id] = c, c.runRemove = async () => {
      var _, k, M, L;
      c.removed = !0;
      const p = TRANSITION_DURATION;
      return await new Promise((F) => window.setTimeout(F)), Object.assign(c.style, {
        zIndex: 0,
        transitionDelay: asDuration(0),
        transitionDuration: asDuration(p),
        transitionProperty: TRANSITION_FIELDS,
        transitionTimingFunction: c.data.exitTransition.timingFn ?? "ease",
        transform: `translate3d(calc(${asSize(((_ = c.data.exitTransition.offset) == null ? void 0 : _.x) ?? 0)}), calc( ${asSize(((k = c.data.exitTransition.offset) == null ? void 0 : k.y) ?? 0)}), 0) scaleX(${((M = c.data.exitTransition.scale) == null ? void 0 : M.x) ?? 1}) scaleY(${((L = c.data.exitTransition.scale) == null ? void 0 : L.y) ?? 1})`,
        opacity: c.data.exitTransition.opacity ?? 0
      }), c.removed = !0, c.transition = new Promise((F) => {
        const V = () => {
          c.transition = null, c._remove(), queueOp(["childRemoveFinished", this.dataset.id, c.dataset.id]), clearTimeout(X), F();
        }, X = window.setTimeout(V, parseInt(String(p)) + 600);
        c.addEventListener("transitionend", V, {
          once: !0
        });
      }), c.transition;
    };
  }
}
const ensureLayoutContainer = (a) => {
  const u = document.getElementById("__ls-layout-container");
  if (u)
    return Object.assign(u.style, {
      width: a.x + "px",
      height: a.y + "px"
    }), u;
  const c = document.createElement("div");
  return c.id = "__ls-layout-container", Object.assign(c.style, {
    position: "fixed",
    // pointerEvents: 'none',
    visibility: "hidden",
    top: "0px",
    left: "0px",
    zIndex: -1,
    width: a.x + "px",
    height: a.y + "px"
  }), document.body.append(c), c;
}, layoutChildren = ({
  id: a,
  props: u = {},
  children: c,
  size: l
}) => {
  const v = {
    props: u,
    children: c,
    size: l
  }, p = htmlLayouts[u.layout] ? htmlLayouts[u.layout].layout(v) : htmlLayouts.Free.layout(v);
  if (!(p instanceof HTMLElement))
    return p;
  const _ = Array.from(p.querySelectorAll("[data-node-id]")), k = document.createElement("div");
  k.style.height = p.style.height = l.y + "px", k.style.width = p.style.width = l.x + "px", k.style.position = "absolute", k.style.top = "0px", k.style.left = "0px", k.style.boxSizing = "border-box", k.setAttribute("data-wrapper-id", a), k.append(p);
  const M = ensureLayoutContainer(l), L = M.querySelector(`[data-wrapper-id="${a}"]`);
  L ? L.replaceWith(k) : M.append(k);
  const F = p.getBoundingClientRect(), V = {};
  return _.forEach((X) => {
    var fe, ie, ge, be;
    const oe = X.dataset.nodeId;
    if (!oe)
      return;
    const Y = Number(X.dataset.opacity ?? (X.style.opacity || 1)), ae = X.getBoundingClientRect();
    let ne = {
      position: {
        x: ae.x - F.x + "px",
        y: ae.y - F.y + "px"
      },
      size: {
        x: ae.width + "px",
        y: ae.height + "px"
      },
      opacity: Y,
      zIndex: (fe = X.data) == null ? void 0 : fe.zIndex,
      entryTransition: ((ie = X.data) == null ? void 0 : ie.entryTransition) ?? {},
      exitTransition: ((ge = X.data) == null ? void 0 : ge.exitTransition) ?? {},
      borderRadius: ((be = X.data) == null ? void 0 : be.borderRadius) ?? 0
    };
    `${u.showcase}-x` === oe && (ne.position = {
      x: F.x + "px",
      y: F.y + "px"
    }, ne.size = {
      x: F.width + "px",
      y: F.height + "px"
    }, ne.zIndex = 10), V[oe] = ne, positionIndex[X.dataset.nodeId] = ne;
  }), V;
}, positionIndex = {}, htmlLayouts = {}, registerLayout = (a) => {
  asArray(a).forEach((u) => {
    htmlLayouts[u.name] = u;
  });
}, sourceTypes = {}, init$1 = (a = {}, u) => {
  const c = {}, l = {}, v = (M) => {
    u.triggerEvent("SourceChanged", M);
  }, p = (M) => {
    u.triggerEvent("AvailableSourcesChanged", {
      type: M,
      sources: l[M]
    });
  }, k = {
    sourceIndex: c,
    sourceTypeIndex: l,
    registerSource: (M) => {
      asArray(M).forEach((L) => {
        var V;
        const F = (X) => {
          const oe = c[X];
          if (oe && oe.type !== L.type)
            throw new Error(`Attempted to modify source of type ${oe.type} from ${L.type}`);
        };
        (V = L.init) == null || V.call(L, {
          getSource: (X) => k.getSource(X),
          removeSource: (X) => (F(X), k.removeSource(X)),
          setSourceActive: (X, oe) => (F(X), k.setSourceActive(X, oe)),
          updateSource: (X, oe) => (F(X), k.updateSource(X, oe)),
          modifySourceValue(X, oe) {
            return F(X), k.modifySourceValue(X, oe);
          },
          addSource: (X) => k.addSource(L.type, X)
        }), sourceTypes[L.type] = L;
      });
    },
    getSource: (M) => c[M],
    getSources: (M) => l[M] || [],
    useSource: (M, L) => (L(c[M]), u.on("SourceChanged", (F) => {
      F.id === M && L(F);
    })),
    useSources: (M, L) => (L(l[M] || []), u.on("AvailableSourcesChanged", (F) => {
      F.type === M && L(F.sources);
    })),
    addSource: (M, L) => {
      if (!L.id)
        throw new Error('Cannot add source without field "id"');
      if (c[L.id])
        return;
      if (!L.value)
        throw new Error('Cannot add source with an empty field "value"');
      if (!sourceTypes[M])
        throw new Error("Could not find definition for source type: " + M);
      const {
        id: V,
        value: X = null,
        props: oe = {},
        isActive: Y = !0
      } = L;
      c[V] = {
        id: V,
        type: M,
        props: oe,
        value: X,
        isActive: Y
      }, l[M] = [...l[M] || [], c[V]], v(c[V]), p(M);
    },
    removeSource: (M) => {
      const L = c[M];
      L && (delete c[M], l[L.type] = l[L.type].filter((F) => F.id !== M), p(L.type));
    },
    updateSource: (M, L) => {
      const F = c[M];
      F.props = {
        ...F.props,
        ...L
      }, v(F), p(F.type);
    },
    /**
     * Imperatively update a Source's value.
     * Triggers an event to inform elements to re-render.
     */
    modifySourceValue: async (M, L) => {
      const F = c[M];
      await L(F.value), v(F);
    },
    setSourceActive: (M, L = !0) => {
      const F = c[M];
      F.isActive = L, p(F.type);
    }
  };
  return k;
}, sources = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  init: init$1,
  sourceTypes
}, Symbol.toStringTag, { value: "Module" })), layouts = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), {
  forEachDown,
  insertAt,
  toDataNode,
  pull,
  replaceItem
} = Logic;
let compositor;
const start = (a) => {
  if (compositor)
    return compositor;
  const {
    dbAdapter: u,
    transformSettings: c = {},
    sourceSettings: l = {}
  } = a, v = {}, p = {};
  try {
    customElements.define("ls-layout", Layout);
  } catch (fe) {
    log.warn(fe);
  }
  const _ = {}, k = {}, M = {};
  let L = 0;
  const F = /* @__PURE__ */ new Map(), V = (fe, ie) => {
    if (typeof fe != "function")
      return;
    const ge = ++L;
    return F.set(ge, fe), fe.nodeId = ie, () => {
      F.delete(ge);
    };
  }, X = (fe, ie, ge) => V((be, Ce) => {
    be === fe && ie(Ce);
  }, ge), oe = (fe, ie) => {
    F.forEach((ge) => {
      ge.nodeId ? ie != null && ie.nodeId && (ie == null ? void 0 : ie.nodeId) === ge.nodeId && ge(fe, ie) : ge(fe, ie);
    });
  }, Y = {
    projects: p,
    subscribe: V,
    on: X,
    triggerEvent: oe,
    getProject: (fe) => p[fe],
    getNodeProject: (fe) => p[_[fe]],
    getNodeParent: (fe) => M[k[fe]],
    getNode: (fe) => M[fe],
    createProject: async (fe = {}, ie) => {
      const {
        id: ge,
        props: be = {},
        children: Ce = []
      } = fe, Me = await u(ie, {
        get: () => null,
        getParent: () => null
      }).insert(be), Be = {
        id: Me,
        props: be,
        children: Ce
      };
      return forEachDown(fe, (Ae) => {
      }), M[Me] = Be, compositor.loadProject(Be, ie);
    },
    loadProject: (fe, ie) => {
      if (!fe)
        return;
      if (ie = ie || fe.id, p[ie])
        return p[ie];
      forEachDown(fe, (Me, Be) => {
        M[Me.id] = Me, k[Me.id] = Be == null ? void 0 : Be.id, _[Me.id] = ie;
      });
      const ge = {
        insert: async (Me, Be, Ae = 0) => {
          if (Me.id && M[Me.id])
            return M[Me.id];
          if (Me.children || (Me.children = []), Me.props || (Me.props = {}), Be) {
            const Z = M[Be];
            if (!Z)
              throw "Parent node not found with ID";
            Z.children = insertAt(Ae, Me, Z.children || []), k[Me.id] = Be;
          }
          return M[Me.id] = Me, _[Me.id] = ie, Me.id;
        },
        update: async (Me, Be = {}, Ae) => {
          const Z = M[Me];
          if (Ae) {
            const z = Ae.map((P) => {
              const S = M[P];
              return k[S.id] = Me, S;
            });
            Z.children = z;
          }
          Z.props = {
            ...Z.props,
            ...Be
          };
        },
        remove: async (Me) => {
          const Be = M[k[Me]];
          Be && (Be.children = Be.children.filter((Z) => Z.id !== Me));
          const Ae = M[Me];
          forEachDown(Ae, (Z) => {
            M[Z.id] && (M[Z.id]._deleted = !0), oe("NodeRemoved", {
              projectId: be.id,
              nodeId: Z.id
            });
          });
        }
      }, be = {
        id: ie,
        getRoot: () => fe,
        get(Me) {
          return M[Me];
        },
        getParent(Me) {
          return M[k[Me]];
        },
        renderTree() {
          return ne.renderTree(fe);
        },
        local: ge,
        insert: async (Me = {}, Be, Ae = 0) => {
          const z = {
            id: await Ce.insert(Me, Be, Ae),
            props: Me,
            children: []
          };
          return ge.insert(z, Be, Ae);
        },
        update: async (Me, Be) => (await ge.update(Me, Be), Ce.update(Me, Be)),
        remove: async (Me) => {
          await ge.remove(Me);
          const Be = M[k[Me]], Ae = Be.children.filter((Z) => Z.id !== Me);
          return Ce.batch([["delete", {
            id: Me
          }], ["update", {
            ...Be,
            children: Ae
          }]]);
        },
        reorder: async (Me, Be) => {
          const Ae = M[Me];
          return Ae.children = Be.map((Z) => Ae.children.find((z) => z.id === Z)), Ce.batch([["update", Ae]]);
        },
        move: async (Me, Be, Ae = 0) => {
          const Z = M[Me], z = M[k[Me]], P = M[Be];
          z.children = pull(z.children, Z), P.children = insertAt(Ae, Z, P.children), Ce.batch([["update", P], ["update", z]]), k[Me] = Be;
        },
        swap: async (Me, Be) => {
          const Ae = M[Me], Z = M[Be], z = M[k[Me]], P = M[k[Be]];
          z.children = replaceItem((S) => S.id === Me, Z, z.children), P.children = replaceItem((S) => S.id === Be, Ae, P.children), k[Me] = P.id, k[Be] = z.id, Ce.batch([["update", z], ["update", P]]);
        }
      };
      Object.defineProperty(be, "nodes", {
        get() {
          return Object.values(M).filter((Me) => _[Me.id] === be.id);
        }
      });
      const Ce = v[ie] || u(ie, {
        get: (Me) => toDataNode(be.get(Me)),
        getParent: (Me) => toDataNode(be.getParent(Me))
      });
      return v[ie] = Ce, p[ie] = be, be;
    }
  }, ae = init$1(l, Y), ne = init$2(c, Y, ae);
  return compositor = {
    registerLayout,
    registerTransform: ne.registerTransform,
    registerSource: ae.registerSource,
    getElement: ne.getElement,
    getSource: ae.getSource,
    getSources: ae.getSources,
    useSource: ae.useSource,
    useSources: ae.useSources,
    ...Y
  }, compositor;
}, index = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Layout: layouts,
  Source: sources,
  Transform: transforms,
  start
}, Symbol.toStringTag, { value: "Module" })), createProject = async (a) => {
  const u = getUser().id, c = a.type || "sceneless", l = a.size || {
    x: 1280,
    y: 720
  }, v = a.settings || {};
  let p = await CoreContext.clients.LiveApi().project.createProject({
    collectionId: u,
    rendering: {
      video: {
        width: l.x,
        height: l.y,
        framerate: 30
      }
    },
    composition: {
      studioSdk: {
        version: CoreContext.rendererVersion
      }
    },
    metadata: {},
    webrtc: {
      hosted: {}
    }
  });
  const _ = await createLayout({
    projectId: p.project.projectId,
    collectionId: p.project.collectionId,
    settings: v,
    size: l,
    type: c
  }), {
    displayName: k
  } = getAccessTokenData(), M = {
    type: c,
    layoutId: _.id,
    hostDisplayName: k,
    props: a.props || {}
  };
  let L = await CoreContext.clients.LiveApi().project.updateProject({
    collectionId: u,
    projectId: p.project.projectId,
    updateMask: ["metadata"],
    metadata: M
  });
  return p.project = L.project, p.project.metadata = M, {
    project: p.project,
    layout: _
  };
}, deleteProject = async (a) => {
  const {
    projectId: u
  } = a, c = getProject(u), l = getUser().id;
  await Promise.all([CoreContext.clients.LiveApi().project.deleteProject({
    collectionId: l,
    projectId: u
  }), CoreContext.clients.LayoutApi().layout.deleteLayout({
    layoutId: c.layoutApi.layoutId
  })]);
}, loadUser = async (a) => {
  var _;
  const u = await loadCollections();
  let c;
  const {
    displayName: l,
    serviceUserId: v
  } = getAccessTokenData();
  u.length === 0 ? c = (await CoreContext.clients.LiveApi().collection.createCollection({
    metadata: {
      serviceUserId: v,
      displayName: l,
      props: {}
    }
  })).collection : c = u[0], await CoreContext.clients.LiveApi().subscribeToCollection(c.collectionId);
  const p = await Promise.all(c.projects.filter((k) => {
    var M;
    return !!((M = k.metadata) != null && M.layoutId);
  }).map((k) => hydrateProject(k, "ROLE_HOST", a)));
  return {
    user: {
      id: c.collectionId,
      metadata: c.metadata,
      props: ((_ = c.metadata) == null ? void 0 : _.props) || {},
      name: l
    },
    projects: p,
    sources: c.sources
  };
}, loadCollections = async () => (await CoreContext.clients.LiveApi().collection.getCollections({})).collections, createLayout = async (a) => {
  const {
    settings: u,
    size: c,
    type: l,
    projectId: v,
    collectionId: p
  } = a, _ = await CoreContext.clients.LayoutApi().layout.createLayout({
    layout: {
      projectId: v,
      collectionId: p
    }
  });
  return l === "sceneless" ? await createCompositor(_.id, c, u) : await CoreContext.compositor.createProject({
    props: {
      name: "Root",
      layout: "Free",
      ...u,
      isRoot: !0,
      size: c
    }
  }, _.id), _;
}, requests = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createLayout,
  createProject,
  deleteProject,
  loadCollections,
  loadUser
}, Symbol.toStringTag, { value: "Module" })), RTMP = {
  type: "RTMP",
  valueType: MediaStream,
  props: {
    id: {},
    type: {},
    videoEnabled: {},
    audioEnabled: {}
  },
  init({
    addSource: a,
    removeSource: u,
    updateSource: c,
    getSource: l
  }) {
    let v = {}, p = [], _ = [];
    const k = (M) => {
      const L = M.filter((V) => !_.some((X) => X.id === V.id)), F = _.filter((V) => !M.some((X) => X.id === V.id));
      _ = M, L.forEach(async (V) => {
        const X = new MediaStream([]);
        v[V.id] = X;
        const oe = X.getVideoTracks();
        a({
          id: `rtmp-${V.id}`,
          isActive: !0,
          value: X,
          props: {
            id: V.id,
            isMuted: !1,
            participantId: V.id,
            type: "rtmp",
            videoEnabled: !!oe.length,
            audioEnabled: !0
          }
        });
      }), F.forEach((V) => {
        u(`rtmp-${V.id}`);
      });
    };
    CoreContext.on("ActiveProjectChanged", ({
      projectId: M
    }) => {
      const F = toBaseProject(getProject(M)).sources.filter((V) => {
        var X, oe;
        return !((oe = (X = V.address) == null ? void 0 : X.dynamic) != null && oe.id);
      });
      k(F);
    }), CoreContext.on("RoomJoined", ({
      projectId: M,
      room: L
    }) => {
      if (toBaseProject(getProject(M)).role !== Role.ROLE_RENDERER) {
        const V = () => {
          p.filter((X) => (X == null ? void 0 : X.type) === "screen_share" && (X == null ? void 0 : X.isExternal) === !0).forEach((X) => {
            if (X.type === "screen_share") {
              const oe = v[X.participantId], Y = L.getParticipant(X.participantId);
              if (_.some((ae) => ae.id === Y.id)) {
                const ae = L.getTrack(X.id);
                if (l(`rtmp-${Y == null ? void 0 : Y.id}`)) {
                  const fe = L.getTracks().find((ie) => ie.participantId === Y.id && ie.mediaStreamTrack.kind === "audio");
                  updateMediaStreamTracks(oe, {
                    video: ae == null ? void 0 : ae.mediaStreamTrack,
                    audio: fe == null ? void 0 : fe.mediaStreamTrack
                  }), c(`rtmp-${Y == null ? void 0 : Y.id}`, {
                    videoEnabled: !!(ae != null && ae.mediaStreamTrack && !ae.isMuted),
                    audioEnabled: !!(fe && !fe.isMuted)
                  });
                }
              }
            }
          });
        };
        L.useTracks((X) => {
          const oe = X.filter((ne) => _.some((fe) => fe.id === ne.participantId)).filter((ne) => ["screen_share"].includes(ne.type)), Y = oe.filter((ne) => !p.some((fe) => fe.id === ne.id) && !!(ne != null && ne.mediaStreamTrack)), ae = p.filter((ne) => !oe.some((fe) => fe.id === ne.id));
          p = oe.filter((ne) => !!(ne != null && ne.mediaStreamTrack)), ae.forEach((ne) => {
            const fe = v[ne.participantId];
            ne.mediaStreamTrack.kind === "video" && (updateMediaStreamTracks(fe, {
              video: null
            }), c(`rtmp-${ne.participantId}`, {
              videoEnabled: !1
            })), ne.mediaStreamTrack.kind === "audio" && (updateMediaStreamTracks(fe, {
              audio: null
            }), c(`rtmp-${ne.participantId}`, {
              audioEnabled: !1
            }));
          }), Y.forEach((ne) => {
            if (ne.type === "screen_share" && ne.mediaStreamTrack.kind === "video") {
              const fe = v[ne.participantId], ie = p.find((ge) => {
                var be;
                return ge.participantId === ne.participantId && ((be = ge.mediaStreamTrack) == null ? void 0 : be.kind) === "audio";
              });
              updateMediaStreamTracks(fe, {
                video: ne == null ? void 0 : ne.mediaStreamTrack,
                audio: ie == null ? void 0 : ie.mediaStreamTrack
              }), c(`rtmp-${ne.participantId}`, {
                videoEnabled: !!(ne && !(ne != null && ne.isMuted)),
                audioEnabled: !!(ie && !(ie != null && ie.isMuted))
              });
            }
          }), V();
        });
      }
    }), CoreContext.onInternal("SourceConnected", async (M) => {
      const L = v[M];
      if (L) {
        const F = await connectDevice(M);
        if (l(`rtmp-${M}`) && F) {
          const X = F.getAudioTracks()[0], oe = F.getVideoTracks()[0];
          updateMediaStreamTracks(L, {
            video: oe,
            audio: X
          }), c(`rtmp-${M}`, {
            videoEnabled: !!oe,
            audioEnabled: !!X
          });
        }
      }
    }), CoreContext.onInternal("SourceDisconnected", async (M) => {
      const L = v[M];
      L && ((L == null ? void 0 : L.getTracks()).forEach((V) => {
        var X;
        (X = v[M]) == null || X.removeTrack(V);
      }), c(`rtmp-${M}`, {
        videoEnabled: !1,
        audioEnabled: !1
      }));
    }), CoreContext.on("ProjectSourceAdded", ({
      source: M,
      projectId: L
    }) => {
      const V = toBaseProject(getProject(L)).sources.filter((X) => {
        var oe, Y;
        return !((Y = (oe = X.address) == null ? void 0 : oe.dynamic) != null && Y.id);
      });
      k(V);
    }), CoreContext.on("ProjectSourceRemoved", ({
      sourceId: M,
      projectId: L
    }) => {
      const V = toBaseProject(getProject(L)).sources.filter((X) => {
        var oe, Y;
        return !((Y = (oe = X.address) == null ? void 0 : oe.dynamic) != null && Y.id);
      });
      k(V);
    });
  }
}, Game = {
  type: "Game",
  valueType: MediaStream,
  props: {
    id: {},
    type: {},
    videoEnabled: {},
    audioEnabled: {}
  },
  init({
    addSource: a,
    removeSource: u,
    updateSource: c,
    getSource: l,
    modifySourceValue: v
  }) {
    let p = [], _ = [];
    const k = (M) => {
      const L = M.filter((V) => !_.some((X) => X.id === V.id)), F = _.filter((V) => !M.some((X) => X.id === V.id));
      _ = M, L.forEach(async (V) => {
        var Y, ae, ne, fe, ie, ge, be, Ce;
        const X = new MediaStream([]), oe = X.getVideoTracks();
        a({
          id: `game-${(ae = (Y = V.preview) == null ? void 0 : Y.webrtc) == null ? void 0 : ae.participantId}`,
          isActive: !0,
          value: X,
          props: {
            displayName: ((fe = (ne = V.preview) == null ? void 0 : ne.webrtc) == null ? void 0 : fe.displayName) || V.id,
            id: (ge = (ie = V.preview) == null ? void 0 : ie.webrtc) == null ? void 0 : ge.participantId,
            isMuted: !1,
            participantId: (Ce = (be = V.preview) == null ? void 0 : be.webrtc) == null ? void 0 : Ce.participantId,
            type: "game",
            videoEnabled: !!oe.length,
            audioEnabled: !0
          }
        });
      }), F.forEach((V) => {
        var X, oe;
        u(`game-${(oe = (X = V.preview) == null ? void 0 : X.webrtc) == null ? void 0 : oe.participantId}`);
      });
    };
    CoreContext.on("RoomJoined", ({
      projectId: M,
      room: L
    }) => {
      if (toBaseProject(getProject(M)).role !== Role.ROLE_RENDERER) {
        const V = () => {
          p.filter((X) => (X == null ? void 0 : X.type) === "camera" && (X == null ? void 0 : X.isExternal) === !0).forEach((X) => {
            var oe;
            if (X.type === "camera") {
              const Y = L.getParticipant(X.participantId);
              if (_.some((ne) => {
                var fe, ie;
                return ((ie = (fe = ne.preview) == null ? void 0 : fe.webrtc) == null ? void 0 : ie.participantId) === Y.id;
              })) {
                const ne = L.getTrack(X.id);
                if (l(`game-${Y == null ? void 0 : Y.id}`)) {
                  const ie = L.getTracks().find((ge) => ge.participantId === Y.id && ge.mediaStreamTrack.kind === "audio");
                  v(`game-${Y == null ? void 0 : Y.id}`, (ge) => {
                    updateMediaStreamTracks(ge, {
                      video: ne == null ? void 0 : ne.mediaStreamTrack,
                      audio: ie == null ? void 0 : ie.mediaStreamTrack
                    });
                  }), c(`game-${Y == null ? void 0 : Y.id}`, {
                    videoEnabled: !!(ne != null && ne.mediaStreamTrack && !ne.isMuted),
                    audioEnabled: !!(ie && !ie.isMuted),
                    displayName: ((oe = Y.meta) == null ? void 0 : oe.screenDisplayName) || (Y == null ? void 0 : Y.displayName) || "Game Source"
                  });
                }
              }
            }
          });
        };
        L.useTracks((X) => {
          const oe = X.filter((ne) => _.some((fe) => {
            var ie, ge;
            return ((ge = (ie = fe.preview) == null ? void 0 : ie.webrtc) == null ? void 0 : ge.participantId) === ne.participantId;
          })).filter((ne) => ["camera"].includes(ne.type)), Y = oe.filter((ne) => !p.some((fe) => fe.id === ne.id) && !!(ne != null && ne.mediaStreamTrack)), ae = p.filter((ne) => !oe.some((fe) => fe.id === ne.id));
          p = oe.filter((ne) => !!(ne != null && ne.mediaStreamTrack)), ae.forEach((ne) => {
            const {
              participantId: fe
            } = ne;
            ne.mediaStreamTrack.kind === "video" && (v(`game-${fe}`, (ie) => {
              updateMediaStreamTracks(ie, {
                video: null
              });
            }), c(`game-${fe}`, {
              videoEnabled: !1
            })), ne.mediaStreamTrack.kind === "audio" && (v(`game-${fe}`, (ie) => {
              updateMediaStreamTracks(ie, {
                audio: null
              });
            }), c(`game-${fe}`, {
              audioEnabled: !1
            }));
          }), Y.forEach((ne) => {
            if (ne.type === "camera" && ne.mediaStreamTrack.kind === "video") {
              const fe = p.find((ie) => {
                var ge;
                return ie.participantId === ne.participantId && ((ge = ie.mediaStreamTrack) == null ? void 0 : ge.kind) === "audio";
              });
              v(`game-${ne.participantId}`, (ie) => {
                updateMediaStreamTracks(ie, {
                  video: ne == null ? void 0 : ne.mediaStreamTrack,
                  audio: fe == null ? void 0 : fe.mediaStreamTrack
                });
              }), c(`game-${ne.participantId}`, {
                videoEnabled: !!(ne && !(ne != null && ne.isMuted)),
                audioEnabled: !!(fe && !(fe != null && fe.isMuted))
              });
            }
          }), V();
        });
      }
      L.useParticipants((V) => {
        V.filter((oe) => oe.id.startsWith("source")).forEach((oe) => {
          var ae;
          l(`game-${oe.id}`) && c(`game-${oe.id}`, {
            displayName: ((ae = oe.meta) == null ? void 0 : ae.screenDisplayName) || (oe == null ? void 0 : oe.displayName) || "Game Source"
          });
        });
      });
    }), CoreContext.on("ActiveProjectChanged", ({
      projectId: M
    }) => {
      const F = toBaseProject(getProject(M)).sources.filter((V) => {
        var X, oe;
        return (oe = (X = V.address) == null ? void 0 : X.dynamic) == null ? void 0 : oe.id;
      });
      k(F);
    }), CoreContext.onInternal("SourceConnected", async (M) => {
      const L = await connectDevice(M);
      if (l(`game-source-${M}`) && L) {
        const V = L.getAudioTracks()[0], X = L.getVideoTracks()[0];
        v(`game-source-${M}`, (oe) => {
          updateMediaStreamTracks(oe, {
            video: X,
            audio: V
          });
        }), c(`game-source-${M}`, {
          videoEnabled: !!X,
          audioEnabled: !!V
        });
      }
    }), CoreContext.onInternal("SourceDisconnected", (M) => {
      var F;
      const L = (F = l(`game-source-${M}`)) == null ? void 0 : F.value;
      L && ((L == null ? void 0 : L.getTracks()).forEach((X) => {
        L == null || L.removeTrack(X);
      }), c(`game-source-${M}`, {
        videoEnabled: !1,
        audioEnabled: !1
      }));
    }), CoreContext.on("ProjectSourceAdded", ({
      source: M,
      projectId: L
    }) => {
      const F = toBaseProject(getProject(L));
      k(F.sources.filter((V) => {
        var X, oe;
        return (oe = (X = V.address) == null ? void 0 : X.dynamic) == null ? void 0 : oe.id;
      }));
    }), CoreContext.on("ProjectSourceRemoved", ({
      sourceId: M,
      projectId: L
    }) => {
      const F = toBaseProject(getProject(L));
      k(F.sources.filter((V) => {
        var X, oe;
        return (oe = (X = V.address) == null ? void 0 : X.dynamic) == null ? void 0 : oe.id;
      }));
    });
  }
}, Sources = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Banner: Banner$1,
  Game,
  RTMP,
  RoomParticipant: RoomParticipant$1
}, Symbol.toStringTag, { value: "Module" }));
var createRoot, m = ReactDOM;
if (process$1.env.NODE_ENV === "production")
  createRoot = m.createRoot, m.hydrateRoot;
else {
  var i = m.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  createRoot = function(a, u) {
    i.usingClientEntryPoint = !0;
    try {
      return m.createRoot(a, u);
    } finally {
      i.usingClientEntryPoint = !1;
    }
  };
}
var APIKitAnimationTypes = /* @__PURE__ */ ((a) => (a.FADE_IN = "fade-in", a.FADE_OUT = "fade-out", a.SLIDE_IN_BLURRED_TOP = "slide-in-blurred-top", a.SLIDE_IN_LEFT = "slide-in-left", a.SLIDE_OUT_LEFT = "slide-out-left", a))(APIKitAnimationTypes || {});
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(a) {
    for (var u = 1; u < arguments.length; u++) {
      var c = arguments[u];
      for (var l in c)
        Object.prototype.hasOwnProperty.call(c, l) && (a[l] = c[l]);
    }
    return a;
  }, _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(a, u) {
  if (a == null)
    return {};
  var c = {}, l = Object.keys(a), v, p;
  for (p = 0; p < l.length; p++)
    v = l[p], !(u.indexOf(v) >= 0) && (c[v] = a[v]);
  return c;
}
function _setPrototypeOf(a, u) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(l, v) {
    return l.__proto__ = v, l;
  }, _setPrototypeOf(a, u);
}
function _inheritsLoose(a, u) {
  a.prototype = Object.create(u.prototype), a.prototype.constructor = a, _setPrototypeOf(a, u);
}
var propTypes = { exports: {} }, reactIs = { exports: {} }, reactIs_production_min = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactIs_production_min;
function requireReactIs_production_min() {
  if (hasRequiredReactIs_production_min)
    return reactIs_production_min;
  hasRequiredReactIs_production_min = 1;
  var a = typeof Symbol == "function" && Symbol.for, u = a ? Symbol.for("react.element") : 60103, c = a ? Symbol.for("react.portal") : 60106, l = a ? Symbol.for("react.fragment") : 60107, v = a ? Symbol.for("react.strict_mode") : 60108, p = a ? Symbol.for("react.profiler") : 60114, _ = a ? Symbol.for("react.provider") : 60109, k = a ? Symbol.for("react.context") : 60110, M = a ? Symbol.for("react.async_mode") : 60111, L = a ? Symbol.for("react.concurrent_mode") : 60111, F = a ? Symbol.for("react.forward_ref") : 60112, V = a ? Symbol.for("react.suspense") : 60113, X = a ? Symbol.for("react.suspense_list") : 60120, oe = a ? Symbol.for("react.memo") : 60115, Y = a ? Symbol.for("react.lazy") : 60116, ae = a ? Symbol.for("react.block") : 60121, ne = a ? Symbol.for("react.fundamental") : 60117, fe = a ? Symbol.for("react.responder") : 60118, ie = a ? Symbol.for("react.scope") : 60119;
  function ge(Ce) {
    if (typeof Ce == "object" && Ce !== null) {
      var Me = Ce.$$typeof;
      switch (Me) {
        case u:
          switch (Ce = Ce.type, Ce) {
            case M:
            case L:
            case l:
            case p:
            case v:
            case V:
              return Ce;
            default:
              switch (Ce = Ce && Ce.$$typeof, Ce) {
                case k:
                case F:
                case Y:
                case oe:
                case _:
                  return Ce;
                default:
                  return Me;
              }
          }
        case c:
          return Me;
      }
    }
  }
  function be(Ce) {
    return ge(Ce) === L;
  }
  return reactIs_production_min.AsyncMode = M, reactIs_production_min.ConcurrentMode = L, reactIs_production_min.ContextConsumer = k, reactIs_production_min.ContextProvider = _, reactIs_production_min.Element = u, reactIs_production_min.ForwardRef = F, reactIs_production_min.Fragment = l, reactIs_production_min.Lazy = Y, reactIs_production_min.Memo = oe, reactIs_production_min.Portal = c, reactIs_production_min.Profiler = p, reactIs_production_min.StrictMode = v, reactIs_production_min.Suspense = V, reactIs_production_min.isAsyncMode = function(Ce) {
    return be(Ce) || ge(Ce) === M;
  }, reactIs_production_min.isConcurrentMode = be, reactIs_production_min.isContextConsumer = function(Ce) {
    return ge(Ce) === k;
  }, reactIs_production_min.isContextProvider = function(Ce) {
    return ge(Ce) === _;
  }, reactIs_production_min.isElement = function(Ce) {
    return typeof Ce == "object" && Ce !== null && Ce.$$typeof === u;
  }, reactIs_production_min.isForwardRef = function(Ce) {
    return ge(Ce) === F;
  }, reactIs_production_min.isFragment = function(Ce) {
    return ge(Ce) === l;
  }, reactIs_production_min.isLazy = function(Ce) {
    return ge(Ce) === Y;
  }, reactIs_production_min.isMemo = function(Ce) {
    return ge(Ce) === oe;
  }, reactIs_production_min.isPortal = function(Ce) {
    return ge(Ce) === c;
  }, reactIs_production_min.isProfiler = function(Ce) {
    return ge(Ce) === p;
  }, reactIs_production_min.isStrictMode = function(Ce) {
    return ge(Ce) === v;
  }, reactIs_production_min.isSuspense = function(Ce) {
    return ge(Ce) === V;
  }, reactIs_production_min.isValidElementType = function(Ce) {
    return typeof Ce == "string" || typeof Ce == "function" || Ce === l || Ce === L || Ce === p || Ce === v || Ce === V || Ce === X || typeof Ce == "object" && Ce !== null && (Ce.$$typeof === Y || Ce.$$typeof === oe || Ce.$$typeof === _ || Ce.$$typeof === k || Ce.$$typeof === F || Ce.$$typeof === ne || Ce.$$typeof === fe || Ce.$$typeof === ie || Ce.$$typeof === ae);
  }, reactIs_production_min.typeOf = ge, reactIs_production_min;
}
var reactIs_development = {}, hasRequiredReactIs_development;
function requireReactIs_development() {
  return hasRequiredReactIs_development || (hasRequiredReactIs_development = 1, process$1.env.NODE_ENV !== "production" && function() {
    var a = typeof Symbol == "function" && Symbol.for, u = a ? Symbol.for("react.element") : 60103, c = a ? Symbol.for("react.portal") : 60106, l = a ? Symbol.for("react.fragment") : 60107, v = a ? Symbol.for("react.strict_mode") : 60108, p = a ? Symbol.for("react.profiler") : 60114, _ = a ? Symbol.for("react.provider") : 60109, k = a ? Symbol.for("react.context") : 60110, M = a ? Symbol.for("react.async_mode") : 60111, L = a ? Symbol.for("react.concurrent_mode") : 60111, F = a ? Symbol.for("react.forward_ref") : 60112, V = a ? Symbol.for("react.suspense") : 60113, X = a ? Symbol.for("react.suspense_list") : 60120, oe = a ? Symbol.for("react.memo") : 60115, Y = a ? Symbol.for("react.lazy") : 60116, ae = a ? Symbol.for("react.block") : 60121, ne = a ? Symbol.for("react.fundamental") : 60117, fe = a ? Symbol.for("react.responder") : 60118, ie = a ? Symbol.for("react.scope") : 60119;
    function ge(O) {
      return typeof O == "string" || typeof O == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      O === l || O === L || O === p || O === v || O === V || O === X || typeof O == "object" && O !== null && (O.$$typeof === Y || O.$$typeof === oe || O.$$typeof === _ || O.$$typeof === k || O.$$typeof === F || O.$$typeof === ne || O.$$typeof === fe || O.$$typeof === ie || O.$$typeof === ae);
    }
    function be(O) {
      if (typeof O == "object" && O !== null) {
        var j = O.$$typeof;
        switch (j) {
          case u:
            var ce = O.type;
            switch (ce) {
              case M:
              case L:
              case l:
              case p:
              case v:
              case V:
                return ce;
              default:
                var De = ce && ce.$$typeof;
                switch (De) {
                  case k:
                  case F:
                  case Y:
                  case oe:
                  case _:
                    return De;
                  default:
                    return j;
                }
            }
          case c:
            return j;
        }
      }
    }
    var Ce = M, Me = L, Be = k, Ae = _, Z = u, z = F, P = l, S = Y, E = oe, I = c, N = p, $ = v, U = V, H = !1;
    function B(O) {
      return H || (H = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), T(O) || be(O) === M;
    }
    function T(O) {
      return be(O) === L;
    }
    function D(O) {
      return be(O) === k;
    }
    function ee(O) {
      return be(O) === _;
    }
    function pe(O) {
      return typeof O == "object" && O !== null && O.$$typeof === u;
    }
    function Ie(O) {
      return be(O) === F;
    }
    function Pe(O) {
      return be(O) === l;
    }
    function he(O) {
      return be(O) === Y;
    }
    function ve(O) {
      return be(O) === oe;
    }
    function Q(O) {
      return be(O) === c;
    }
    function le(O) {
      return be(O) === p;
    }
    function _e(O) {
      return be(O) === v;
    }
    function re(O) {
      return be(O) === V;
    }
    reactIs_development.AsyncMode = Ce, reactIs_development.ConcurrentMode = Me, reactIs_development.ContextConsumer = Be, reactIs_development.ContextProvider = Ae, reactIs_development.Element = Z, reactIs_development.ForwardRef = z, reactIs_development.Fragment = P, reactIs_development.Lazy = S, reactIs_development.Memo = E, reactIs_development.Portal = I, reactIs_development.Profiler = N, reactIs_development.StrictMode = $, reactIs_development.Suspense = U, reactIs_development.isAsyncMode = B, reactIs_development.isConcurrentMode = T, reactIs_development.isContextConsumer = D, reactIs_development.isContextProvider = ee, reactIs_development.isElement = pe, reactIs_development.isForwardRef = Ie, reactIs_development.isFragment = Pe, reactIs_development.isLazy = he, reactIs_development.isMemo = ve, reactIs_development.isPortal = Q, reactIs_development.isProfiler = le, reactIs_development.isStrictMode = _e, reactIs_development.isSuspense = re, reactIs_development.isValidElementType = ge, reactIs_development.typeOf = be;
  }()), reactIs_development;
}
var hasRequiredReactIs;
function requireReactIs() {
  return hasRequiredReactIs || (hasRequiredReactIs = 1, process$1.env.NODE_ENV === "production" ? reactIs.exports = requireReactIs_production_min() : reactIs.exports = requireReactIs_development()), reactIs.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var objectAssign, hasRequiredObjectAssign;
function requireObjectAssign() {
  if (hasRequiredObjectAssign)
    return objectAssign;
  hasRequiredObjectAssign = 1;
  var a = Object.getOwnPropertySymbols, u = Object.prototype.hasOwnProperty, c = Object.prototype.propertyIsEnumerable;
  function l(p) {
    if (p == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(p);
  }
  function v() {
    try {
      if (!Object.assign)
        return !1;
      var p = new String("abc");
      if (p[5] = "de", Object.getOwnPropertyNames(p)[0] === "5")
        return !1;
      for (var _ = {}, k = 0; k < 10; k++)
        _["_" + String.fromCharCode(k)] = k;
      var M = Object.getOwnPropertyNames(_).map(function(F) {
        return _[F];
      });
      if (M.join("") !== "0123456789")
        return !1;
      var L = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(F) {
        L[F] = F;
      }), Object.keys(Object.assign({}, L)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return objectAssign = v() ? Object.assign : function(p, _) {
    for (var k, M = l(p), L, F = 1; F < arguments.length; F++) {
      k = Object(arguments[F]);
      for (var V in k)
        u.call(k, V) && (M[V] = k[V]);
      if (a) {
        L = a(k);
        for (var X = 0; X < L.length; X++)
          c.call(k, L[X]) && (M[L[X]] = k[L[X]]);
      }
    }
    return M;
  }, objectAssign;
}
var ReactPropTypesSecret_1, hasRequiredReactPropTypesSecret;
function requireReactPropTypesSecret() {
  if (hasRequiredReactPropTypesSecret)
    return ReactPropTypesSecret_1;
  hasRequiredReactPropTypesSecret = 1;
  var a = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return ReactPropTypesSecret_1 = a, ReactPropTypesSecret_1;
}
var has, hasRequiredHas;
function requireHas() {
  return hasRequiredHas || (hasRequiredHas = 1, has = Function.call.bind(Object.prototype.hasOwnProperty)), has;
}
var checkPropTypes_1, hasRequiredCheckPropTypes;
function requireCheckPropTypes() {
  if (hasRequiredCheckPropTypes)
    return checkPropTypes_1;
  hasRequiredCheckPropTypes = 1;
  var a = function() {
  };
  if (process$1.env.NODE_ENV !== "production") {
    var u = requireReactPropTypesSecret(), c = {}, l = requireHas();
    a = function(p) {
      var _ = "Warning: " + p;
      typeof console < "u" && console.error(_);
      try {
        throw new Error(_);
      } catch {
      }
    };
  }
  function v(p, _, k, M, L) {
    if (process$1.env.NODE_ENV !== "production") {
      for (var F in p)
        if (l(p, F)) {
          var V;
          try {
            if (typeof p[F] != "function") {
              var X = Error(
                (M || "React class") + ": " + k + " type `" + F + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof p[F] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw X.name = "Invariant Violation", X;
            }
            V = p[F](_, F, M, k, null, u);
          } catch (Y) {
            V = Y;
          }
          if (V && !(V instanceof Error) && a(
            (M || "React class") + ": type specification of " + k + " `" + F + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof V + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), V instanceof Error && !(V.message in c)) {
            c[V.message] = !0;
            var oe = L ? L() : "";
            a(
              "Failed " + k + " type: " + V.message + (oe ?? "")
            );
          }
        }
    }
  }
  return v.resetWarningCache = function() {
    process$1.env.NODE_ENV !== "production" && (c = {});
  }, checkPropTypes_1 = v, checkPropTypes_1;
}
var factoryWithTypeCheckers, hasRequiredFactoryWithTypeCheckers;
function requireFactoryWithTypeCheckers() {
  if (hasRequiredFactoryWithTypeCheckers)
    return factoryWithTypeCheckers;
  hasRequiredFactoryWithTypeCheckers = 1;
  var a = requireReactIs(), u = requireObjectAssign(), c = requireReactPropTypesSecret(), l = requireHas(), v = requireCheckPropTypes(), p = function() {
  };
  process$1.env.NODE_ENV !== "production" && (p = function(k) {
    var M = "Warning: " + k;
    typeof console < "u" && console.error(M);
    try {
      throw new Error(M);
    } catch {
    }
  });
  function _() {
    return null;
  }
  return factoryWithTypeCheckers = function(k, M) {
    var L = typeof Symbol == "function" && Symbol.iterator, F = "@@iterator";
    function V(T) {
      var D = T && (L && T[L] || T[F]);
      if (typeof D == "function")
        return D;
    }
    var X = "<<anonymous>>", oe = {
      array: fe("array"),
      bigint: fe("bigint"),
      bool: fe("boolean"),
      func: fe("function"),
      number: fe("number"),
      object: fe("object"),
      string: fe("string"),
      symbol: fe("symbol"),
      any: ie(),
      arrayOf: ge,
      element: be(),
      elementType: Ce(),
      instanceOf: Me,
      node: z(),
      objectOf: Ae,
      oneOf: Be,
      oneOfType: Z,
      shape: S,
      exact: E
    };
    function Y(T, D) {
      return T === D ? T !== 0 || 1 / T === 1 / D : T !== T && D !== D;
    }
    function ae(T, D) {
      this.message = T, this.data = D && typeof D == "object" ? D : {}, this.stack = "";
    }
    ae.prototype = Error.prototype;
    function ne(T) {
      if (process$1.env.NODE_ENV !== "production")
        var D = {}, ee = 0;
      function pe(Pe, he, ve, Q, le, _e, re) {
        if (Q = Q || X, _e = _e || ve, re !== c) {
          if (M) {
            var O = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw O.name = "Invariant Violation", O;
          } else if (process$1.env.NODE_ENV !== "production" && typeof console < "u") {
            var j = Q + ":" + ve;
            !D[j] && // Avoid spamming the console because they are often not actionable except for lib authors
            ee < 3 && (p(
              "You are manually calling a React.PropTypes validation function for the `" + _e + "` prop on `" + Q + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), D[j] = !0, ee++);
          }
        }
        return he[ve] == null ? Pe ? he[ve] === null ? new ae("The " + le + " `" + _e + "` is marked as required " + ("in `" + Q + "`, but its value is `null`.")) : new ae("The " + le + " `" + _e + "` is marked as required in " + ("`" + Q + "`, but its value is `undefined`.")) : null : T(he, ve, Q, le, _e);
      }
      var Ie = pe.bind(null, !1);
      return Ie.isRequired = pe.bind(null, !0), Ie;
    }
    function fe(T) {
      function D(ee, pe, Ie, Pe, he, ve) {
        var Q = ee[pe], le = $(Q);
        if (le !== T) {
          var _e = U(Q);
          return new ae(
            "Invalid " + Pe + " `" + he + "` of type " + ("`" + _e + "` supplied to `" + Ie + "`, expected ") + ("`" + T + "`."),
            { expectedType: T }
          );
        }
        return null;
      }
      return ne(D);
    }
    function ie() {
      return ne(_);
    }
    function ge(T) {
      function D(ee, pe, Ie, Pe, he) {
        if (typeof T != "function")
          return new ae("Property `" + he + "` of component `" + Ie + "` has invalid PropType notation inside arrayOf.");
        var ve = ee[pe];
        if (!Array.isArray(ve)) {
          var Q = $(ve);
          return new ae("Invalid " + Pe + " `" + he + "` of type " + ("`" + Q + "` supplied to `" + Ie + "`, expected an array."));
        }
        for (var le = 0; le < ve.length; le++) {
          var _e = T(ve, le, Ie, Pe, he + "[" + le + "]", c);
          if (_e instanceof Error)
            return _e;
        }
        return null;
      }
      return ne(D);
    }
    function be() {
      function T(D, ee, pe, Ie, Pe) {
        var he = D[ee];
        if (!k(he)) {
          var ve = $(he);
          return new ae("Invalid " + Ie + " `" + Pe + "` of type " + ("`" + ve + "` supplied to `" + pe + "`, expected a single ReactElement."));
        }
        return null;
      }
      return ne(T);
    }
    function Ce() {
      function T(D, ee, pe, Ie, Pe) {
        var he = D[ee];
        if (!a.isValidElementType(he)) {
          var ve = $(he);
          return new ae("Invalid " + Ie + " `" + Pe + "` of type " + ("`" + ve + "` supplied to `" + pe + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return ne(T);
    }
    function Me(T) {
      function D(ee, pe, Ie, Pe, he) {
        if (!(ee[pe] instanceof T)) {
          var ve = T.name || X, Q = B(ee[pe]);
          return new ae("Invalid " + Pe + " `" + he + "` of type " + ("`" + Q + "` supplied to `" + Ie + "`, expected ") + ("instance of `" + ve + "`."));
        }
        return null;
      }
      return ne(D);
    }
    function Be(T) {
      if (!Array.isArray(T))
        return process$1.env.NODE_ENV !== "production" && (arguments.length > 1 ? p(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : p("Invalid argument supplied to oneOf, expected an array.")), _;
      function D(ee, pe, Ie, Pe, he) {
        for (var ve = ee[pe], Q = 0; Q < T.length; Q++)
          if (Y(ve, T[Q]))
            return null;
        var le = JSON.stringify(T, function(re, O) {
          var j = U(O);
          return j === "symbol" ? String(O) : O;
        });
        return new ae("Invalid " + Pe + " `" + he + "` of value `" + String(ve) + "` " + ("supplied to `" + Ie + "`, expected one of " + le + "."));
      }
      return ne(D);
    }
    function Ae(T) {
      function D(ee, pe, Ie, Pe, he) {
        if (typeof T != "function")
          return new ae("Property `" + he + "` of component `" + Ie + "` has invalid PropType notation inside objectOf.");
        var ve = ee[pe], Q = $(ve);
        if (Q !== "object")
          return new ae("Invalid " + Pe + " `" + he + "` of type " + ("`" + Q + "` supplied to `" + Ie + "`, expected an object."));
        for (var le in ve)
          if (l(ve, le)) {
            var _e = T(ve, le, Ie, Pe, he + "." + le, c);
            if (_e instanceof Error)
              return _e;
          }
        return null;
      }
      return ne(D);
    }
    function Z(T) {
      if (!Array.isArray(T))
        return process$1.env.NODE_ENV !== "production" && p("Invalid argument supplied to oneOfType, expected an instance of array."), _;
      for (var D = 0; D < T.length; D++) {
        var ee = T[D];
        if (typeof ee != "function")
          return p(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + H(ee) + " at index " + D + "."
          ), _;
      }
      function pe(Ie, Pe, he, ve, Q) {
        for (var le = [], _e = 0; _e < T.length; _e++) {
          var re = T[_e], O = re(Ie, Pe, he, ve, Q, c);
          if (O == null)
            return null;
          O.data && l(O.data, "expectedType") && le.push(O.data.expectedType);
        }
        var j = le.length > 0 ? ", expected one of type [" + le.join(", ") + "]" : "";
        return new ae("Invalid " + ve + " `" + Q + "` supplied to " + ("`" + he + "`" + j + "."));
      }
      return ne(pe);
    }
    function z() {
      function T(D, ee, pe, Ie, Pe) {
        return I(D[ee]) ? null : new ae("Invalid " + Ie + " `" + Pe + "` supplied to " + ("`" + pe + "`, expected a ReactNode."));
      }
      return ne(T);
    }
    function P(T, D, ee, pe, Ie) {
      return new ae(
        (T || "React class") + ": " + D + " type `" + ee + "." + pe + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + Ie + "`."
      );
    }
    function S(T) {
      function D(ee, pe, Ie, Pe, he) {
        var ve = ee[pe], Q = $(ve);
        if (Q !== "object")
          return new ae("Invalid " + Pe + " `" + he + "` of type `" + Q + "` " + ("supplied to `" + Ie + "`, expected `object`."));
        for (var le in T) {
          var _e = T[le];
          if (typeof _e != "function")
            return P(Ie, Pe, he, le, U(_e));
          var re = _e(ve, le, Ie, Pe, he + "." + le, c);
          if (re)
            return re;
        }
        return null;
      }
      return ne(D);
    }
    function E(T) {
      function D(ee, pe, Ie, Pe, he) {
        var ve = ee[pe], Q = $(ve);
        if (Q !== "object")
          return new ae("Invalid " + Pe + " `" + he + "` of type `" + Q + "` " + ("supplied to `" + Ie + "`, expected `object`."));
        var le = u({}, ee[pe], T);
        for (var _e in le) {
          var re = T[_e];
          if (l(T, _e) && typeof re != "function")
            return P(Ie, Pe, he, _e, U(re));
          if (!re)
            return new ae(
              "Invalid " + Pe + " `" + he + "` key `" + _e + "` supplied to `" + Ie + "`.\nBad object: " + JSON.stringify(ee[pe], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(T), null, "  ")
            );
          var O = re(ve, _e, Ie, Pe, he + "." + _e, c);
          if (O)
            return O;
        }
        return null;
      }
      return ne(D);
    }
    function I(T) {
      switch (typeof T) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !T;
        case "object":
          if (Array.isArray(T))
            return T.every(I);
          if (T === null || k(T))
            return !0;
          var D = V(T);
          if (D) {
            var ee = D.call(T), pe;
            if (D !== T.entries) {
              for (; !(pe = ee.next()).done; )
                if (!I(pe.value))
                  return !1;
            } else
              for (; !(pe = ee.next()).done; ) {
                var Ie = pe.value;
                if (Ie && !I(Ie[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function N(T, D) {
      return T === "symbol" ? !0 : D ? D["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && D instanceof Symbol : !1;
    }
    function $(T) {
      var D = typeof T;
      return Array.isArray(T) ? "array" : T instanceof RegExp ? "object" : N(D, T) ? "symbol" : D;
    }
    function U(T) {
      if (typeof T > "u" || T === null)
        return "" + T;
      var D = $(T);
      if (D === "object") {
        if (T instanceof Date)
          return "date";
        if (T instanceof RegExp)
          return "regexp";
      }
      return D;
    }
    function H(T) {
      var D = U(T);
      switch (D) {
        case "array":
        case "object":
          return "an " + D;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + D;
        default:
          return D;
      }
    }
    function B(T) {
      return !T.constructor || !T.constructor.name ? X : T.constructor.name;
    }
    return oe.checkPropTypes = v, oe.resetWarningCache = v.resetWarningCache, oe.PropTypes = oe, oe;
  }, factoryWithTypeCheckers;
}
var factoryWithThrowingShims, hasRequiredFactoryWithThrowingShims;
function requireFactoryWithThrowingShims() {
  if (hasRequiredFactoryWithThrowingShims)
    return factoryWithThrowingShims;
  hasRequiredFactoryWithThrowingShims = 1;
  var a = requireReactPropTypesSecret();
  function u() {
  }
  function c() {
  }
  return c.resetWarningCache = u, factoryWithThrowingShims = function() {
    function l(_, k, M, L, F, V) {
      if (V !== a) {
        var X = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw X.name = "Invariant Violation", X;
      }
    }
    l.isRequired = l;
    function v() {
      return l;
    }
    var p = {
      array: l,
      bigint: l,
      bool: l,
      func: l,
      number: l,
      object: l,
      string: l,
      symbol: l,
      any: l,
      arrayOf: v,
      element: l,
      elementType: l,
      instanceOf: v,
      node: l,
      objectOf: v,
      oneOf: v,
      oneOfType: v,
      shape: v,
      exact: v,
      checkPropTypes: c,
      resetWarningCache: u
    };
    return p.PropTypes = p, p;
  }, factoryWithThrowingShims;
}
if (process$1.env.NODE_ENV !== "production") {
  var ReactIs = requireReactIs(), throwOnDirectAccess = !0;
  propTypes.exports = requireFactoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
} else
  propTypes.exports = requireFactoryWithThrowingShims()();
var propTypesExports = propTypes.exports;
const PropTypes = /* @__PURE__ */ getDefaultExportFromCjs$2(propTypesExports);
function hasClass(a, u) {
  return a.classList ? !!u && a.classList.contains(u) : (" " + (a.className.baseVal || a.className) + " ").indexOf(" " + u + " ") !== -1;
}
function addClass(a, u) {
  a.classList ? a.classList.add(u) : hasClass(a, u) || (typeof a.className == "string" ? a.className = a.className + " " + u : a.setAttribute("class", (a.className && a.className.baseVal || "") + " " + u));
}
function replaceClassName(a, u) {
  return a.replace(new RegExp("(^|\\s)" + u + "(?:\\s|$)", "g"), "$1").replace(/\s+/g, " ").replace(/^\s*|\s*$/g, "");
}
function removeClass$1(a, u) {
  a.classList ? a.classList.remove(u) : typeof a.className == "string" ? a.className = replaceClassName(a.className, u) : a.setAttribute("class", replaceClassName(a.className && a.className.baseVal || "", u));
}
const config = {
  disabled: !1
};
var timeoutsShape = process$1.env.NODE_ENV !== "production" ? PropTypes.oneOfType([PropTypes.number, PropTypes.shape({
  enter: PropTypes.number,
  exit: PropTypes.number,
  appear: PropTypes.number
}).isRequired]) : null, classNamesShape = process$1.env.NODE_ENV !== "production" ? PropTypes.oneOfType([PropTypes.string, PropTypes.shape({
  enter: PropTypes.string,
  exit: PropTypes.string,
  active: PropTypes.string
}), PropTypes.shape({
  enter: PropTypes.string,
  enterDone: PropTypes.string,
  enterActive: PropTypes.string,
  exit: PropTypes.string,
  exitDone: PropTypes.string,
  exitActive: PropTypes.string
})]) : null;
const TransitionGroupContext = React.createContext(null);
var forceReflow = function a(u) {
  return u.scrollTop;
}, UNMOUNTED = "unmounted", EXITED = "exited", ENTERING = "entering", ENTERED = "entered", EXITING = "exiting", Transition = /* @__PURE__ */ function(a) {
  _inheritsLoose(u, a);
  function u(l, v) {
    var p;
    p = a.call(this, l, v) || this;
    var _ = v, k = _ && !_.isMounting ? l.enter : l.appear, M;
    return p.appearStatus = null, l.in ? k ? (M = EXITED, p.appearStatus = ENTERING) : M = ENTERED : l.unmountOnExit || l.mountOnEnter ? M = UNMOUNTED : M = EXITED, p.state = {
      status: M
    }, p.nextCallback = null, p;
  }
  u.getDerivedStateFromProps = function(v, p) {
    var _ = v.in;
    return _ && p.status === UNMOUNTED ? {
      status: EXITED
    } : null;
  };
  var c = u.prototype;
  return c.componentDidMount = function() {
    this.updateStatus(!0, this.appearStatus);
  }, c.componentDidUpdate = function(v) {
    var p = null;
    if (v !== this.props) {
      var _ = this.state.status;
      this.props.in ? _ !== ENTERING && _ !== ENTERED && (p = ENTERING) : (_ === ENTERING || _ === ENTERED) && (p = EXITING);
    }
    this.updateStatus(!1, p);
  }, c.componentWillUnmount = function() {
    this.cancelNextCallback();
  }, c.getTimeouts = function() {
    var v = this.props.timeout, p, _, k;
    return p = _ = k = v, v != null && typeof v != "number" && (p = v.exit, _ = v.enter, k = v.appear !== void 0 ? v.appear : _), {
      exit: p,
      enter: _,
      appear: k
    };
  }, c.updateStatus = function(v, p) {
    if (v === void 0 && (v = !1), p !== null)
      if (this.cancelNextCallback(), p === ENTERING) {
        if (this.props.unmountOnExit || this.props.mountOnEnter) {
          var _ = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
          _ && forceReflow(_);
        }
        this.performEnter(v);
      } else
        this.performExit();
    else
      this.props.unmountOnExit && this.state.status === EXITED && this.setState({
        status: UNMOUNTED
      });
  }, c.performEnter = function(v) {
    var p = this, _ = this.props.enter, k = this.context ? this.context.isMounting : v, M = this.props.nodeRef ? [k] : [ReactDOM.findDOMNode(this), k], L = M[0], F = M[1], V = this.getTimeouts(), X = k ? V.appear : V.enter;
    if (!v && !_ || config.disabled) {
      this.safeSetState({
        status: ENTERED
      }, function() {
        p.props.onEntered(L);
      });
      return;
    }
    this.props.onEnter(L, F), this.safeSetState({
      status: ENTERING
    }, function() {
      p.props.onEntering(L, F), p.onTransitionEnd(X, function() {
        p.safeSetState({
          status: ENTERED
        }, function() {
          p.props.onEntered(L, F);
        });
      });
    });
  }, c.performExit = function() {
    var v = this, p = this.props.exit, _ = this.getTimeouts(), k = this.props.nodeRef ? void 0 : ReactDOM.findDOMNode(this);
    if (!p || config.disabled) {
      this.safeSetState({
        status: EXITED
      }, function() {
        v.props.onExited(k);
      });
      return;
    }
    this.props.onExit(k), this.safeSetState({
      status: EXITING
    }, function() {
      v.props.onExiting(k), v.onTransitionEnd(_.exit, function() {
        v.safeSetState({
          status: EXITED
        }, function() {
          v.props.onExited(k);
        });
      });
    });
  }, c.cancelNextCallback = function() {
    this.nextCallback !== null && (this.nextCallback.cancel(), this.nextCallback = null);
  }, c.safeSetState = function(v, p) {
    p = this.setNextCallback(p), this.setState(v, p);
  }, c.setNextCallback = function(v) {
    var p = this, _ = !0;
    return this.nextCallback = function(k) {
      _ && (_ = !1, p.nextCallback = null, v(k));
    }, this.nextCallback.cancel = function() {
      _ = !1;
    }, this.nextCallback;
  }, c.onTransitionEnd = function(v, p) {
    this.setNextCallback(p);
    var _ = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this), k = v == null && !this.props.addEndListener;
    if (!_ || k) {
      setTimeout(this.nextCallback, 0);
      return;
    }
    if (this.props.addEndListener) {
      var M = this.props.nodeRef ? [this.nextCallback] : [_, this.nextCallback], L = M[0], F = M[1];
      this.props.addEndListener(L, F);
    }
    v != null && setTimeout(this.nextCallback, v);
  }, c.render = function() {
    var v = this.state.status;
    if (v === UNMOUNTED)
      return null;
    var p = this.props, _ = p.children;
    p.in, p.mountOnEnter, p.unmountOnExit, p.appear, p.enter, p.exit, p.timeout, p.addEndListener, p.onEnter, p.onEntering, p.onEntered, p.onExit, p.onExiting, p.onExited, p.nodeRef;
    var k = _objectWithoutPropertiesLoose(p, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
    return (
      // allows for nested Transitions
      /* @__PURE__ */ React.createElement(TransitionGroupContext.Provider, {
        value: null
      }, typeof _ == "function" ? _(v, k) : React.cloneElement(React.Children.only(_), k))
    );
  }, u;
}(React.Component);
Transition.contextType = TransitionGroupContext;
Transition.propTypes = process$1.env.NODE_ENV !== "production" ? {
  /**
   * A React reference to DOM element that need to transition:
   * https://stackoverflow.com/a/51127130/4671932
   *
   *   - When `nodeRef` prop is used, `node` is not passed to callback functions
   *      (e.g. `onEnter`) because user already has direct access to the node.
   *   - When changing `key` prop of `Transition` in a `TransitionGroup` a new
   *     `nodeRef` need to be provided to `Transition` with changed `key` prop
   *     (see
   *     [test/CSSTransition-test.js](https://github.com/reactjs/react-transition-group/blob/13435f897b3ab71f6e19d724f145596f5910581c/test/CSSTransition-test.js#L362-L437)).
   */
  nodeRef: PropTypes.shape({
    current: typeof Element > "u" ? PropTypes.any : function(a, u, c, l, v, p) {
      var _ = a[u];
      return PropTypes.instanceOf(_ && "ownerDocument" in _ ? _.ownerDocument.defaultView.Element : Element)(a, u, c, l, v, p);
    }
  }),
  /**
   * A `function` child can be used instead of a React element. This function is
   * called with the current transition status (`'entering'`, `'entered'`,
   * `'exiting'`, `'exited'`), which can be used to apply context
   * specific props to a component.
   *
   * ```jsx
   * <Transition in={this.state.in} timeout={150}>
   *   {state => (
   *     <MyComponent className={`fade fade-${state}`} />
   *   )}
   * </Transition>
   * ```
   */
  children: PropTypes.oneOfType([PropTypes.func.isRequired, PropTypes.element.isRequired]).isRequired,
  /**
   * Show the component; triggers the enter or exit states
   */
  in: PropTypes.bool,
  /**
   * By default the child component is mounted immediately along with
   * the parent `Transition` component. If you want to "lazy mount" the component on the
   * first `in={true}` you can set `mountOnEnter`. After the first enter transition the component will stay
   * mounted, even on "exited", unless you also specify `unmountOnExit`.
   */
  mountOnEnter: PropTypes.bool,
  /**
   * By default the child component stays mounted after it reaches the `'exited'` state.
   * Set `unmountOnExit` if you'd prefer to unmount the component after it finishes exiting.
   */
  unmountOnExit: PropTypes.bool,
  /**
   * By default the child component does not perform the enter transition when
   * it first mounts, regardless of the value of `in`. If you want this
   * behavior, set both `appear` and `in` to `true`.
   *
   * > **Note**: there are no special appear states like `appearing`/`appeared`, this prop
   * > only adds an additional enter transition. However, in the
   * > `<CSSTransition>` component that first enter transition does result in
   * > additional `.appear-*` classes, that way you can choose to style it
   * > differently.
   */
  appear: PropTypes.bool,
  /**
   * Enable or disable enter transitions.
   */
  enter: PropTypes.bool,
  /**
   * Enable or disable exit transitions.
   */
  exit: PropTypes.bool,
  /**
   * The duration of the transition, in milliseconds.
   * Required unless `addEndListener` is provided.
   *
   * You may specify a single timeout for all transitions:
   *
   * ```jsx
   * timeout={500}
   * ```
   *
   * or individually:
   *
   * ```jsx
   * timeout={{
   *  appear: 500,
   *  enter: 300,
   *  exit: 500,
   * }}
   * ```
   *
   * - `appear` defaults to the value of `enter`
   * - `enter` defaults to `0`
   * - `exit` defaults to `0`
   *
   * @type {number | { enter?: number, exit?: number, appear?: number }}
   */
  timeout: function a(u) {
    var c = timeoutsShape;
    u.addEndListener || (c = c.isRequired);
    for (var l = arguments.length, v = new Array(l > 1 ? l - 1 : 0), p = 1; p < l; p++)
      v[p - 1] = arguments[p];
    return c.apply(void 0, [u].concat(v));
  },
  /**
   * Add a custom transition end trigger. Called with the transitioning
   * DOM node and a `done` callback. Allows for more fine grained transition end
   * logic. Timeouts are still used as a fallback if provided.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * ```jsx
   * addEndListener={(node, done) => {
   *   // use the css transitionend event to mark the finish of a transition
   *   node.addEventListener('transitionend', done, false);
   * }}
   * ```
   */
  addEndListener: PropTypes.func,
  /**
   * Callback fired before the "entering" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool) -> void
   */
  onEnter: PropTypes.func,
  /**
   * Callback fired after the "entering" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEntering: PropTypes.func,
  /**
   * Callback fired after the "entered" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool) -> void
   */
  onEntered: PropTypes.func,
  /**
   * Callback fired before the "exiting" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExit: PropTypes.func,
  /**
   * Callback fired after the "exiting" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExiting: PropTypes.func,
  /**
   * Callback fired after the "exited" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExited: PropTypes.func
} : {};
function noop() {
}
Transition.defaultProps = {
  in: !1,
  mountOnEnter: !1,
  unmountOnExit: !1,
  appear: !1,
  enter: !0,
  exit: !0,
  onEnter: noop,
  onEntering: noop,
  onEntered: noop,
  onExit: noop,
  onExiting: noop,
  onExited: noop
};
Transition.UNMOUNTED = UNMOUNTED;
Transition.EXITED = EXITED;
Transition.ENTERING = ENTERING;
Transition.ENTERED = ENTERED;
Transition.EXITING = EXITING;
const Transition$1 = Transition;
var _addClass = function a(u, c) {
  return u && c && c.split(" ").forEach(function(l) {
    return addClass(u, l);
  });
}, removeClass = function a(u, c) {
  return u && c && c.split(" ").forEach(function(l) {
    return removeClass$1(u, l);
  });
}, CSSTransition = /* @__PURE__ */ function(a) {
  _inheritsLoose(u, a);
  function u() {
    for (var l, v = arguments.length, p = new Array(v), _ = 0; _ < v; _++)
      p[_] = arguments[_];
    return l = a.call.apply(a, [this].concat(p)) || this, l.appliedClasses = {
      appear: {},
      enter: {},
      exit: {}
    }, l.onEnter = function(k, M) {
      var L = l.resolveArguments(k, M), F = L[0], V = L[1];
      l.removeClasses(F, "exit"), l.addClass(F, V ? "appear" : "enter", "base"), l.props.onEnter && l.props.onEnter(k, M);
    }, l.onEntering = function(k, M) {
      var L = l.resolveArguments(k, M), F = L[0], V = L[1], X = V ? "appear" : "enter";
      l.addClass(F, X, "active"), l.props.onEntering && l.props.onEntering(k, M);
    }, l.onEntered = function(k, M) {
      var L = l.resolveArguments(k, M), F = L[0], V = L[1], X = V ? "appear" : "enter";
      l.removeClasses(F, X), l.addClass(F, X, "done"), l.props.onEntered && l.props.onEntered(k, M);
    }, l.onExit = function(k) {
      var M = l.resolveArguments(k), L = M[0];
      l.removeClasses(L, "appear"), l.removeClasses(L, "enter"), l.addClass(L, "exit", "base"), l.props.onExit && l.props.onExit(k);
    }, l.onExiting = function(k) {
      var M = l.resolveArguments(k), L = M[0];
      l.addClass(L, "exit", "active"), l.props.onExiting && l.props.onExiting(k);
    }, l.onExited = function(k) {
      var M = l.resolveArguments(k), L = M[0];
      l.removeClasses(L, "exit"), l.addClass(L, "exit", "done"), l.props.onExited && l.props.onExited(k);
    }, l.resolveArguments = function(k, M) {
      return l.props.nodeRef ? [l.props.nodeRef.current, k] : [k, M];
    }, l.getClassNames = function(k) {
      var M = l.props.classNames, L = typeof M == "string", F = L && M ? M + "-" : "", V = L ? "" + F + k : M[k], X = L ? V + "-active" : M[k + "Active"], oe = L ? V + "-done" : M[k + "Done"];
      return {
        baseClassName: V,
        activeClassName: X,
        doneClassName: oe
      };
    }, l;
  }
  var c = u.prototype;
  return c.addClass = function(v, p, _) {
    var k = this.getClassNames(p)[_ + "ClassName"], M = this.getClassNames("enter"), L = M.doneClassName;
    p === "appear" && _ === "done" && L && (k += " " + L), _ === "active" && v && forceReflow(v), k && (this.appliedClasses[p][_] = k, _addClass(v, k));
  }, c.removeClasses = function(v, p) {
    var _ = this.appliedClasses[p], k = _.base, M = _.active, L = _.done;
    this.appliedClasses[p] = {}, k && removeClass(v, k), M && removeClass(v, M), L && removeClass(v, L);
  }, c.render = function() {
    var v = this.props;
    v.classNames;
    var p = _objectWithoutPropertiesLoose(v, ["classNames"]);
    return /* @__PURE__ */ React.createElement(Transition$1, _extends({}, p, {
      onEnter: this.onEnter,
      onEntered: this.onEntered,
      onEntering: this.onEntering,
      onExit: this.onExit,
      onExiting: this.onExiting,
      onExited: this.onExited
    }));
  }, u;
}(React.Component);
CSSTransition.defaultProps = {
  classNames: ""
};
CSSTransition.propTypes = process$1.env.NODE_ENV !== "production" ? _extends({}, Transition$1.propTypes, {
  /**
   * The animation classNames applied to the component as it appears, enters,
   * exits or has finished the transition. A single name can be provided, which
   * will be suffixed for each stage, e.g. `classNames="fade"` applies:
   *
   * - `fade-appear`, `fade-appear-active`, `fade-appear-done`
   * - `fade-enter`, `fade-enter-active`, `fade-enter-done`
   * - `fade-exit`, `fade-exit-active`, `fade-exit-done`
   *
   * A few details to note about how these classes are applied:
   *
   * 1. They are _joined_ with the ones that are already defined on the child
   *    component, so if you want to add some base styles, you can use
   *    `className` without worrying that it will be overridden.
   *
   * 2. If the transition component mounts with `in={false}`, no classes are
   *    applied yet. You might be expecting `*-exit-done`, but if you think
   *    about it, a component cannot finish exiting if it hasn't entered yet.
   *
   * 2. `fade-appear-done` and `fade-enter-done` will _both_ be applied. This
   *    allows you to define different behavior for when appearing is done and
   *    when regular entering is done, using selectors like
   *    `.fade-enter-done:not(.fade-appear-done)`. For example, you could apply
   *    an epic entrance animation when element first appears in the DOM using
   *    [Animate.css](https://daneden.github.io/animate.css/). Otherwise you can
   *    simply use `fade-enter-done` for defining both cases.
   *
   * Each individual classNames can also be specified independently like:
   *
   * ```js
   * classNames={{
   *  appear: 'my-appear',
   *  appearActive: 'my-active-appear',
   *  appearDone: 'my-done-appear',
   *  enter: 'my-enter',
   *  enterActive: 'my-active-enter',
   *  enterDone: 'my-done-enter',
   *  exit: 'my-exit',
   *  exitActive: 'my-active-exit',
   *  exitDone: 'my-done-exit',
   * }}
   * ```
   *
   * If you want to set these classes using CSS Modules:
   *
   * ```js
   * import styles from './styles.css';
   * ```
   *
   * you might want to use camelCase in your CSS file, that way could simply
   * spread them instead of listing them one by one:
   *
   * ```js
   * classNames={{ ...styles }}
   * ```
   *
   * @type {string | {
   *  appear?: string,
   *  appearActive?: string,
   *  appearDone?: string,
   *  enter?: string,
   *  enterActive?: string,
   *  enterDone?: string,
   *  exit?: string,
   *  exitActive?: string,
   *  exitDone?: string,
   * }}
   */
  classNames: classNamesShape,
  /**
   * A `<Transition>` callback fired immediately after the 'enter' or 'appear' class is
   * applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEnter: PropTypes.func,
  /**
   * A `<Transition>` callback fired immediately after the 'enter-active' or
   * 'appear-active' class is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEntering: PropTypes.func,
  /**
   * A `<Transition>` callback fired immediately after the 'enter' or
   * 'appear' classes are **removed** and the `done` class is added to the DOM node.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEntered: PropTypes.func,
  /**
   * A `<Transition>` callback fired immediately after the 'exit' class is
   * applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement)
   */
  onExit: PropTypes.func,
  /**
   * A `<Transition>` callback fired immediately after the 'exit-active' is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement)
   */
  onExiting: PropTypes.func,
  /**
   * A `<Transition>` callback fired immediately after the 'exit' classes
   * are **removed** and the `exit-done` class is added to the DOM node.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement)
   */
  onExited: PropTypes.func
}) : {};
const CSSTransition$1 = CSSTransition;
var _leaveRenders, _enterRenders;
function areChildrenDifferent(a, u) {
  return !(a === u || React.isValidElement(a) && React.isValidElement(u) && a.key != null && a.key === u.key);
}
var modes = {
  out: "out-in",
  in: "in-out"
}, callHook = function a(u, c, l) {
  return function() {
    var v;
    u.props[c] && (v = u.props)[c].apply(v, arguments), l();
  };
}, leaveRenders = (_leaveRenders = {}, _leaveRenders[modes.out] = function(a) {
  var u = a.current, c = a.changeState;
  return React.cloneElement(u, {
    in: !1,
    onExited: callHook(u, "onExited", function() {
      c(ENTERING, null);
    })
  });
}, _leaveRenders[modes.in] = function(a) {
  var u = a.current, c = a.changeState, l = a.children;
  return [u, React.cloneElement(l, {
    in: !0,
    onEntered: callHook(l, "onEntered", function() {
      c(ENTERING);
    })
  })];
}, _leaveRenders), enterRenders = (_enterRenders = {}, _enterRenders[modes.out] = function(a) {
  var u = a.children, c = a.changeState;
  return React.cloneElement(u, {
    in: !0,
    onEntered: callHook(u, "onEntered", function() {
      c(ENTERED, React.cloneElement(u, {
        in: !0
      }));
    })
  });
}, _enterRenders[modes.in] = function(a) {
  var u = a.current, c = a.children, l = a.changeState;
  return [React.cloneElement(u, {
    in: !1,
    onExited: callHook(u, "onExited", function() {
      l(ENTERED, React.cloneElement(c, {
        in: !0
      }));
    })
  }), React.cloneElement(c, {
    in: !0
  })];
}, _enterRenders), SwitchTransition = /* @__PURE__ */ function(a) {
  _inheritsLoose(u, a);
  function u() {
    for (var l, v = arguments.length, p = new Array(v), _ = 0; _ < v; _++)
      p[_] = arguments[_];
    return l = a.call.apply(a, [this].concat(p)) || this, l.state = {
      status: ENTERED,
      current: null
    }, l.appeared = !1, l.changeState = function(k, M) {
      M === void 0 && (M = l.state.current), l.setState({
        status: k,
        current: M
      });
    }, l;
  }
  var c = u.prototype;
  return c.componentDidMount = function() {
    this.appeared = !0;
  }, u.getDerivedStateFromProps = function(v, p) {
    return v.children == null ? {
      current: null
    } : p.status === ENTERING && v.mode === modes.in ? {
      status: ENTERING
    } : p.current && areChildrenDifferent(p.current, v.children) ? {
      status: EXITING
    } : {
      current: React.cloneElement(v.children, {
        in: !0
      })
    };
  }, c.render = function() {
    var v = this.props, p = v.children, _ = v.mode, k = this.state, M = k.status, L = k.current, F = {
      children: p,
      current: L,
      changeState: this.changeState,
      status: M
    }, V;
    switch (M) {
      case ENTERING:
        V = enterRenders[_](F);
        break;
      case EXITING:
        V = leaveRenders[_](F);
        break;
      case ENTERED:
        V = L;
    }
    return /* @__PURE__ */ React.createElement(TransitionGroupContext.Provider, {
      value: {
        isMounting: !this.appeared
      }
    }, V);
  }, u;
}(React.Component);
SwitchTransition.propTypes = process$1.env.NODE_ENV !== "production" ? {
  /**
   * Transition modes.
   * `out-in`: Current element transitions out first, then when complete, the new element transitions in.
   * `in-out`: New element transitions in first, then when complete, the current element transitions out.
   *
   * @type {'out-in'|'in-out'}
   */
  mode: PropTypes.oneOf([modes.in, modes.out]),
  /**
   * Any `Transition` or `CSSTransition` component.
   */
  children: PropTypes.oneOfType([PropTypes.element.isRequired])
} : {};
SwitchTransition.defaultProps = {
  mode: modes.out
};
const SwitchTransition$1 = SwitchTransition, Animations = {
  "fade-in": ".fade-in{-webkit-animation:fade-in;animation:fade-in}@-webkit-keyframes fade-in{0%{opacity:0}100%{opacity:1}}@keyframes fade-in{0%{opacity:0}100%{opacity:1}}",
  "fade-out": ".fade-out{-webkit-animation:fade-out;animation:fade-out}@-webkit-keyframes fade-out{0%{opacity:1}100%{opacity:0}}@keyframes fade-out{0%{opacity:1}100%{opacity:0}}",
  "slide-in-blurred-top": ".slide-in-blurred-top{-webkit-animation:slide-in-blurred-top .6s cubic-bezier(.23,1.000,.32,1.000) both;animation:slide-in-blurred-top .6s cubic-bezier(.23,1.000,.32,1.000) both}@-webkit-keyframes slide-in-blurred-top{0%{-webkit-transform:translateY(-1000px) scaleY(2.5) scaleX(.2);transform:translateY(-1000px) scaleY(2.5) scaleX(.2);-webkit-transform-origin:50% 0;transform-origin:50% 0;-webkit-filter:blur(40px);filter:blur(40px);opacity:0}100%{-webkit-transform:translateY(0) scaleY(1) scaleX(1);transform:translateY(0) scaleY(1) scaleX(1);-webkit-transform-origin:50% 50%;transform-origin:50% 50%;-webkit-filter:blur(0);filter:blur(0);opacity:1}}@keyframes slide-in-blurred-top{0%{-webkit-transform:translateY(-1000px) scaleY(2.5) scaleX(.2);transform:translateY(-1000px) scaleY(2.5) scaleX(.2);-webkit-transform-origin:50% 0;transform-origin:50% 0;-webkit-filter:blur(40px);filter:blur(40px);opacity:0}100%{-webkit-transform:translateY(0) scaleY(1) scaleX(1);transform:translateY(0) scaleY(1) scaleX(1);-webkit-transform-origin:50% 50%;transform-origin:50% 50%;-webkit-filter:blur(0);filter:blur(0);opacity:1}}",
  "slide-in-left": ".slide-in-left{-webkit-animation:slide-in-left .5s cubic-bezier(.25,.46,.45,.94) both;animation:slide-in-left .5s cubic-bezier(.25,.46,.45,.94) both}@-webkit-keyframes slide-in-left{0%{-webkit-transform:translateX(-1000px);transform:translateX(-1000px);opacity:0}100%{-webkit-transform:translateX(0);transform:translateX(0);opacity:1}}@keyframes slide-in-left{0%{-webkit-transform:translateX(-1000px);transform:translateX(-1000px);opacity:0}100%{-webkit-transform:translateX(0);transform:translateX(0);opacity:1}}",
  "slide-out-left": ".slide-out-left{-webkit-animation:slide-out-left .5s cubic-bezier(.55,.085,.68,.53) both;animation:slide-out-left .5s cubic-bezier(.55,.085,.68,.53) both}@-webkit-keyframes slide-out-left{0%{-webkit-transform:translateX(0);transform:translateX(0);opacity:1}100%{-webkit-transform:translateX(-1000px);transform:translateX(-1000px);opacity:0}}@keyframes slide-out-left{0%{-webkit-transform:translateX(0);transform:translateX(0);opacity:1}100%{-webkit-transform:translateX(-1000px);transform:translateX(-1000px);opacity:0}}"
}, APIKitAnimation = (a) => {
  const {
    enter: u,
    exit: c,
    children: l,
    tag: v = "div",
    direction: p = "normal",
    duration: _ = 500,
    id: k,
    type: M
  } = a, L = k ? `${M}-${k}` : `${M}-api-kit-animation`;
  return /* @__PURE__ */ React.createElement("div", {
    style: {
      height: "100%",
      width: "100%"
    }
  }, /* @__PURE__ */ React.createElement("style", {
    dangerouslySetInnerHTML: {
      __html: renderStyle(M, u, c, _, p)
    }
  }), /* @__PURE__ */ React.createElement(SwitchTransition$1, {
    mode: "out-in"
  }, /* @__PURE__ */ React.createElement(CSSTransition$1, {
    key: L,
    addEndListener: (F, V) => {
      F.addEventListener("transitionend", V, !1);
    },
    classNames: {
      enter: `${M}-default-enter`,
      enterActive: u,
      exit: `${M}-default-leave`,
      exitActive: c
    },
    timeout: _
  }, /* @__PURE__ */ React.createElement("div", {
    style: {
      height: "100%",
      width: "100%"
    }
  }, l))));
}, renderStyle = (a, u, c, l, v) => `
        body {
          margin: 0;
          padding: 0;
        }
        
        ${Animations[u]}
        
        ${Animations[c]}

        .${a}-transition {
          transition: opacity ${l}ms ease-out};
        }

        .${a}-default-enter {
          opacity: 0;
        }

        .${a}-default-enter.${u} {
          animation-direction: ${v};
          animation-duration: ${l / 1e3}s;
          animation-fill-mode: both;
          animation-timing-function: ease-out;
        }

        .${a}-default-leave {
          opacity: 1;
        }

        .${a}-default-leave.${c} {
          animation-direction: ${v};
          animation-duration: ${l / 1e3}s;
          animation-timing-function: ease-out;
          animation-fill-mode: both;
        }
        `, APIKitAnimation$1 = APIKitAnimation, Background = {
  name: "LS-Background",
  sourceType: "Background",
  create({
    onUpdate: a,
    onRemove: u
  }, {
    sourceProps: c
  }) {
    u(() => {
      clearInterval(p);
    });
    const l = document.createElement("div"), v = getProject(CoreContext.state.activeProjectId).role;
    let p;
    const _ = ({
      source: V,
      setStartAnimation: X
    }) => {
      var Z, z;
      const {
        src: oe,
        type: Y,
        meta: ae,
        loop: ne
      } = (V == null ? void 0 : V.sourceProps) || {}, {
        id: fe,
        sourceType: ie
      } = V || {}, [ge, be] = React.useState(null), Ce = React.useRef(null);
      console.log("Updated current time", (Z = Ce == null ? void 0 : Ce.current) == null ? void 0 : Z.currentTime);
      const Me = React.useCallback((P) => {
        Ce.current = P, be(P ? P.id : null);
      }, []), Be = React.useCallback(() => {
        Ce != null && Ce.current && Ce.current.play().catch(() => {
          var P;
          Ce.current.muted = !0, (P = Ce.current) == null || P.play();
        });
      }, [oe]), Ae = React.useCallback(() => {
        p && clearInterval(p), hasPermission(v, Permission.UpdateProject) && trigger$1("VideoEnded", {
          id: fe,
          category: Y
        });
      }, [oe]);
      return React.useEffect(() => {
        ae && (Ce != null && Ce.current) && ge && hasPermission(v, Permission.ManageSelf) && ae != null && ae.time && (Ce.current.currentTime = Number(ae == null ? void 0 : ae.time));
      }, [ae == null ? void 0 : ae.time, ge]), React.useEffect(() => () => {
        p && clearInterval(p);
      }, [fe]), React.useEffect(() => {
        ge ? Ce.current && (Ce.current.src = oe, Ce.current.play().catch(() => {
          Ce.current.muted = !0, Ce.current.play();
        }), hasPermission(v, Permission.UpdateProject) && (p = setInterval(() => {
          if (Ce.current.duration) {
            const P = Ce.current.duration - Ce.current.currentTime;
            trigger$1("VideoTimeUpdate", {
              category: ie,
              id: fe,
              time: Math.floor(P)
            });
          }
        }, 1e3))) : p && clearInterval(p);
      }, [ge]), /* @__PURE__ */ React.createElement(React.Fragment, {
        key: fe
      }, oe && /* @__PURE__ */ React.createElement("video", {
        loop: ne,
        id: fe,
        ref: Me,
        style: {
          ...(z = c == null ? void 0 : c.meta) == null ? void 0 : z.style,
          ...ae.style
        },
        onLoadedData: Be,
        onEnded: Ae,
        onCanPlay: () => X(!0)
      }));
    }, k = ({
      source: V,
      setStartAnimation: X
    }) => {
      var fe;
      const {
        src: oe,
        meta: Y,
        type: ae
      } = (V == null ? void 0 : V.sourceProps) || {}, {
        id: ne
      } = V || {};
      return /* @__PURE__ */ React.createElement(React.Fragment, {
        key: ne
      }, oe && /* @__PURE__ */ React.createElement("img", {
        style: {
          ...(fe = c == null ? void 0 : c.meta) == null ? void 0 : fe.style,
          ...Y == null ? void 0 : Y.style
        },
        src: oe,
        onLoad: () => X(!0)
      }));
    }, M = ({
      source: V
    }) => {
      const {
        type: X
      } = V.sourceProps, {
        id: oe
      } = V || {}, [Y, ae] = React.useState(!1);
      return useEffect(() => {
        ae(!1);
      }, [oe]), /* @__PURE__ */ React.createElement(APIKitAnimation$1, {
        id: oe,
        type: "background",
        enter: APIKitAnimationTypes.FADE_IN,
        exit: APIKitAnimationTypes.FADE_OUT,
        duration: 400
      }, /* @__PURE__ */ React.createElement("div", {
        style: {
          opacity: Y ? 1 : 0
        },
        className: "backgroundContainer background-transition"
      }, oe && X === "image" && /* @__PURE__ */ React.createElement(k, {
        source: V,
        setStartAnimation: ae
      }), oe && X === "video" && /* @__PURE__ */ React.createElement(_, {
        source: V,
        setStartAnimation: ae
      })));
    }, L = createRoot(l), F = (V) => L.render(/* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(M, {
      source: V
    })));
    return a((V) => {
      F({
        ...V
      });
    }), {
      root: l
    };
  }
}, Banner = {
  name: "LS-Banner",
  sourceType: "Banner",
  props: {
    bannerId: {
      type: String,
      required: !0
    }
  },
  useSource(a, u) {
    return a.find((c) => c.id === u.bannerId);
  },
  create({
    onUpdate: a,
    onNewSource: u
  }, c) {
    const l = document.createElement("div");
    let v, p, _;
    const k = ({
      currentSource: F,
      latestSource: V
    }) => {
      const [X, oe] = useState(!1), {
        headerText: Y,
        bodyText: ae
      } = (V == null ? void 0 : V.value) || {};
      return useEffect(() => {
        window.setTimeout(() => {
          oe(!!F);
        }), F || oe(!1);
      }, [F]), /* @__PURE__ */ React.createElement("div", {
        className: "BannerContainer",
        style: {
          position: "absolute",
          top: 0,
          left: 0,
          width: "100%",
          height: "100%",
          display: "flex",
          flexDirection: "row",
          justifyContent: "flex-start",
          alignItems: "flex-end",
          transition: "200ms ease all",
          ...X ? {
            zIndex: 2,
            opacity: 1,
            transform: "translateX(0)"
          } : {
            zIndex: 1,
            opacity: 0,
            transform: "translateX(-200px)"
          }
        }
      }, /* @__PURE__ */ React.createElement("div", {
        className: "Banner",
        style: {
          padding: 10,
          background: "orange",
          width: "fit-content",
          height: "fit-content",
          maxWidth: "84%",
          position: "relative"
        }
      }, Y && /* @__PURE__ */ React.createElement("div", {
        className: "Banner-header",
        style: {
          marginBottom: 6
        }
      }, Y), ae && /* @__PURE__ */ React.createElement("div", {
        className: "Banner-body"
      }, ae)));
    }, M = createRoot(l), L = () => M.render(/* @__PURE__ */ React.createElement(React.Fragment, null, _ && _.id !== p.id && /* @__PURE__ */ React.createElement(k, {
      key: _ == null ? void 0 : _.id,
      currentSource: null,
      latestSource: _
    }), /* @__PURE__ */ React.createElement(k, {
      key: p == null ? void 0 : p.id,
      currentSource: v,
      latestSource: p
    })));
    return a(() => {
      L();
    }), u((F) => {
      _ = v, v = F, v && (p = v), L();
    }), {
      root: l
    };
  }
};
var functionExpression = /[\s]*([a-z-]+)[\s]*\([\s]*([^\)]+)[\s]*\)[\s]*/i, floatExpression = /^(\-?\d+\.?\d{0,5})/, toFloat = parseFloat;
function ensurePercent(a) {
  return typeof a == "number" ? a : toFloat(a) * 0.01;
}
function formatPercent(a) {
  return formatFloat(a * 100) + "%";
}
function formatFloat(a) {
  return floatExpression.exec(a.toString())[1];
}
function parseCSSFunction(a) {
  var u = functionExpression.exec(a);
  if (!(!u || !u.length))
    return [u[1]].concat(u[2].split(","));
}
function cssFunction(a, u) {
  var c = Array.prototype.join.call(u, ", ");
  return a + "(" + c + ")";
}
var math = Math, round = math.round;
function roundFloat(a, u) {
  return round(a * u) / u;
}
var _a, RGB = "rgb", HSL = "hsl", converters = (_a = {}, _a[RGB + HSL] = RGBtoHSL, _a[HSL + RGB] = HSLtoRGB, _a), maxChannelValues = {
  r: 255,
  g: 255,
  b: 255,
  h: 360,
  s: 1,
  l: 1,
  a: 1
};
function color(a) {
  return parseHexCode(a) || parseColorFunction(a) || rgb(255, 0, 0);
}
function rgb(a, u, c, l) {
  return new ColorHelper(
    RGB,
    a,
    u,
    c,
    l === void 0 ? 1 : ensurePercent(l),
    l !== void 0
    /* hasAlpha*/
  );
}
function convertHelper(a, u, c) {
  var l = u.f, v = u.r, p = u.g, _ = u.b, k = u.a, M = c === void 0 ? u.o : c;
  return l !== a ? converters[l + a](v, p, _, k, M) : c === void 0 ? u : new ColorHelper(l, v, p, _, k, M);
}
var ColorHelper = (
  /** @class */
  function() {
    function a(u, c, l, v, p, _) {
      var k = this;
      k.f = u, k.o = _;
      var M = u === HSL;
      k.r = clampColor(M ? "h" : "r", c), k.g = clampColor(M ? "s" : "g", l), k.b = clampColor(M ? "l" : "b", v), k.a = clampColor("a", p);
    }
    return a.prototype.toString = function() {
      var u = this, c = u.o, l = u.f, v = u.r, p = u.g, _ = u.b, k = u.a, M, L;
      if (l === RGB)
        M = c ? "rgba" : RGB, L = [round(v), round(p), round(_)];
      else if (l === HSL)
        M = c ? "hsla" : HSL, L = [round(v), formatPercent(roundFloat(p, 100)), formatPercent(roundFloat(_, 100))];
      else
        throw new Error("Invalid color format");
      return c && L.push(formatFloat(roundFloat(k, 1e5))), cssFunction(M, L);
    }, a.prototype.toHexString = function() {
      var u = convertHelper(RGB, this);
      return "#" + (toHex(u.r) + toHex(u.g) + toHex(u.b)).toUpperCase();
    }, a.prototype.toHSL = function() {
      return convertHelper(HSL, this, !1);
    }, a.prototype.toHSLA = function() {
      return convertHelper(HSL, this, !0);
    }, a.prototype.toRGB = function() {
      return convertHelper(RGB, this, !1);
    }, a.prototype.toRGBA = function() {
      return convertHelper(RGB, this, !0);
    }, a.prototype.red = function() {
      var u = this;
      return (u.f === RGB ? u : u.toRGB()).r;
    }, a.prototype.green = function() {
      var u = this;
      return (u.f === RGB ? u : u.toRGB()).g;
    }, a.prototype.blue = function() {
      var u = this;
      return (u.f === RGB ? u : u.toRGB()).b;
    }, a.prototype.hue = function() {
      var u = this;
      return (u.f === HSL ? u : u.toHSL()).r;
    }, a.prototype.saturation = function() {
      var u = this;
      return (u.f === HSL ? u : u.toHSL()).g;
    }, a.prototype.lightness = function() {
      var u = this;
      return (u.f === HSL ? u : u.toHSL()).b;
    }, a.prototype.alpha = function() {
      return this.a;
    }, a.prototype.opacity = function() {
      return this.a;
    }, a.prototype.invert = function() {
      var u = this, c = convertHelper(RGB, u);
      return convertHelper(u.f, new a(RGB, 255 - c.r, 255 - c.g, 255 - c.b, u.a, u.o));
    }, a.prototype.lighten = function(u, c) {
      var l = this, v = convertHelper(HSL, l), p = maxChannelValues.l, _ = v.b + (c ? p - v.b : p) * ensurePercent(u);
      return convertHelper(l.f, new a(HSL, v.r, v.g, _, l.a, l.o));
    }, a.prototype.darken = function(u, c) {
      var l = this, v = convertHelper(HSL, l), p = v.b - (c ? v.b : maxChannelValues.l) * ensurePercent(u);
      return convertHelper(l.f, new a(HSL, v.r, v.g, p, l.a, l.o));
    }, a.prototype.saturate = function(u, c) {
      var l = this, v = convertHelper(HSL, l), p = maxChannelValues.s, _ = v.g + (c ? p - v.g : p) * ensurePercent(u);
      return convertHelper(l.f, new a(HSL, v.r, _, v.b, l.a, l.o));
    }, a.prototype.desaturate = function(u, c) {
      var l = this, v = convertHelper(HSL, l), p = maxChannelValues.s, _ = v.g - (c ? v.g : p) * ensurePercent(u);
      return convertHelper(l.f, new a(HSL, v.r, _, v.b, l.a, l.o));
    }, a.prototype.grayscale = function() {
      return this.desaturate(1);
    }, a.prototype.fade = function(u) {
      var c = this, l = clampColor("a", ensurePercent(u));
      return convertHelper(c.f, new a(c.f, c.r, c.g, c.b, l, !0));
    }, a.prototype.fadeOut = function(u, c) {
      var l = this, v = 1, p = clampColor("a", l.a - (c ? l.a : v) * ensurePercent(u));
      return convertHelper(l.f, new a(l.f, l.r, l.g, l.b, p, !0));
    }, a.prototype.fadeIn = function(u, c) {
      var l = this, v = 1, p = clampColor("a", l.a + (c ? l.a : v) * ensurePercent(u));
      return convertHelper(l.f, new a(l.f, l.r, l.g, l.b, p, !0));
    }, a.prototype.mix = function(u, c) {
      var l = this, v = ensureColor(u), p = convertHelper(RGB, l), _ = convertHelper(RGB, v), k = c === void 0 ? 0.5 : c, M = 2 * k - 1, L = Math.abs(p.a - _.a), F = ((M * L === -1 ? M : (M + L) / (1 + M * L)) + 1) / 2, V = 1 - F, X = new a(RGB, round(p.r * F + _.r * V), round(p.g * F + _.g * V), round(p.b * F + _.b * V), p.a * k + _.a * (1 - k), l.o || v.o);
      return convertHelper(this.f, X);
    }, a.prototype.tint = function(u) {
      return rgb(255, 255, 255).mix(this, u);
    }, a.prototype.shade = function(u) {
      return rgb(0, 0, 0).mix(this, u);
    }, a.prototype.spin = function(u) {
      var c = this, l = convertHelper(HSL, c);
      return convertHelper(c.f, new a(HSL, modDegrees(l.r + u), l.g, l.b, c.a, c.o));
    }, a;
  }()
);
function toHex(a) {
  var u = round(a);
  return (u < 16 ? "0" : "") + u.toString(16);
}
function modDegrees(a) {
  return ((a < 0 ? 360 : 0) + a % 360) % 360;
}
function RGBtoHSL(a, u, c, l, v) {
  var p = a / 255, _ = u / 255, k = c / 255, M = Math.min(p, _, k), L = Math.max(p, _, k), F = (M + L) / 2, V = L - M, X;
  L === M ? X = 0 : p === L ? X = (_ - k) / V : _ === L ? X = 2 + (k - p) / V : k === L ? X = 4 + (p - _) / V : X = 0, X = Math.min(X * 60, 360), X < 0 && (X += 360);
  var oe;
  return L === M ? oe = 0 : F <= 0.5 ? oe = V / (L + M) : oe = V / (2 - L - M), new ColorHelper(HSL, X, oe, F, l, v);
}
function HSLtoRGB(a, u, c, l, v) {
  var p = a / 360, _ = u, k = c;
  if (_ === 0) {
    var M = k * 255;
    return new ColorHelper(RGB, M, M, M, l, v);
  }
  for (var L = k < 0.5 ? k * (1 + _) : k + _ - k * _, F = 2 * k - L, V = 0, X = 0, oe = 0, Y = 0; Y < 3; Y++) {
    var ae = p + 0.3333333333333333 * -(Y - 1);
    ae < 0 && ae++, ae > 1 && ae--;
    var M = void 0;
    6 * ae < 1 ? M = F + (L - F) * 6 * ae : 2 * ae < 1 ? M = L : 3 * ae < 2 ? M = F + (L - F) * (2 / 3 - ae) * 6 : M = F, M *= 255, Y === 0 ? V = M : Y === 1 ? X = M : oe = M;
  }
  return new ColorHelper(RGB, V, X, oe, l, v);
}
function clampColor(a, u) {
  var c = 0, l = maxChannelValues[a];
  return u < c ? c : u > l ? l : u;
}
function ensureColor(a) {
  return a instanceof ColorHelper ? a : color(a);
}
function parseHexCode(a) {
  var u = a.match(/#(([a-f0-9]{6})|([a-f0-9]{3}))$/i);
  if (u) {
    var c = u[1], l = parseInt(c.length === 3 ? c[0] + c[0] + c[1] + c[1] + c[2] + c[2] : c, 16), v = l >> 16 & 255, p = l >> 8 & 255, _ = l & 255;
    return new ColorHelper(RGB, v, p, _, 1, !1);
  }
}
function parseColorFunction(a) {
  var u = parseCSSFunction(a);
  if (!(!u || !(u.length === 4 || u.length === 5))) {
    var c = u[0], l = c === "rgba", v = c === "hsla", p = c === RGB, _ = c === HSL, k = v || l, M;
    if (p || l)
      M = RGB;
    else if (_ || v)
      M = HSL;
    else
      throw new Error("unsupported color string");
    var L = toFloat(u[1]), F = p || l ? toFloat(u[2]) : ensurePercent(u[2]), V = p || l ? toFloat(u[3]) : ensurePercent(u[3]), X = k ? toFloat(u[4]) : 1;
    return new ColorHelper(M, L, F, V, X, k);
  }
}
const of = color, transparent = color("rgba(0,0,0,0)"), white = color("#ffffff"), black = color("#000000"), weights = {
  primary: {
    50: "#EAFAF5",
    100: "#D5F6EB",
    200: "#ABEDD7",
    300: "#82E3C3",
    400: "#58DAAF",
    500: "#26AD80",
    600: "#25A77C",
    700: "#1C7D5D",
    800: "#12543E"
  },
  secondary: {
    50: "#FBEAEA",
    100: "#F7D4D4",
    200: "#EFA9A9",
    300: "#E77E7E",
    400: "#FF6F64",
    500: "#E9554A",
    600: "#CB362B",
    700: "#811818",
    800: "#561010"
  },
  neutral: {
    0: "#ffffff",
    10: "#f5f5f5",
    200: "#d9d9d9",
    300: "#bababa",
    350: "#999999",
    400: "#9e9e9e",
    500: "#808080",
    600: "#666666",
    700: "#4d4d4d",
    800: "#303030",
    900: "#141414",
    1e3: "#000000"
  },
  warning: {
    400: "#FFC28A",
    500: "#FFAE64",
    600: "#F29540"
  }
}, types = Object.keys(weights), weight = (a) => (u) => {
  const c = weights[a];
  if (c[u])
    return c[u];
  const l = Object.keys(weights.primary).map(Number), v = l.find((p) => u <= p);
  return v ? c[v] : c[l.slice(l.length - 1)[0]];
}, primary = weight("primary"), neutral = weight("neutral"), secondary = weight("secondary"), warning = weight("warning"), lightstream = color("#26ad80"), twitch = color("#9156ff"), linkedin = color("#2867b2"), youtube = color("#ff0000"), facebook = color("#1877f2"), twitter = color("#1da1f2"), Color = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  black,
  color,
  facebook,
  lightstream,
  linkedin,
  neutral,
  of,
  primary,
  secondary,
  transparent,
  twitch,
  twitter,
  types,
  warning,
  white,
  youtube
}, Symbol.toStringTag, { value: "Module" })), YouTube = /* @__PURE__ */ React.createElement("svg", {
  style: {
    flex: "0 0 100%"
  },
  viewBox: "0 0 24 24"
}, /* @__PURE__ */ React.createElement("path", {
  d: "M19.6465 8.53711C19.4707 7.83398 18.9141 7.27734 18.2402 7.10156C16.9805 6.75 12 6.75 12 6.75C12 6.75 6.99023 6.75 5.73047 7.10156C5.05664 7.27734 4.5 7.83398 4.32422 8.53711C3.97266 9.76758 3.97266 12.4043 3.97266 12.4043C3.97266 12.4043 3.97266 15.0117 4.32422 16.2715C4.5 16.9746 5.05664 17.502 5.73047 17.6777C6.99023 18 12 18 12 18C12 18 16.9805 18 18.2402 17.6777C18.9141 17.502 19.4707 16.9746 19.6465 16.2715C19.998 15.0117 19.998 12.4043 19.998 12.4043C19.998 12.4043 19.998 9.76758 19.6465 8.53711ZM10.3594 14.7773V10.0312L14.5195 12.4043L10.3594 14.7773Z"
})), YouTubeDuo = /* @__PURE__ */ React.createElement("svg", {
  style: {
    flex: "0 0 100%"
  },
  viewBox: "0 0 24 24"
}, /* @__PURE__ */ React.createElement("rect", {
  x: "8",
  y: "9",
  width: "9",
  height: "7",
  fill: neutral(0)
}), /* @__PURE__ */ React.createElement("path", {
  d: "M19.6465 8.53711C19.4707 7.83398 18.9141 7.27734 18.2402 7.10156C16.9805 6.75 12 6.75 12 6.75C12 6.75 6.99023 6.75 5.73047 7.10156C5.05664 7.27734 4.5 7.83398 4.32422 8.53711C3.97266 9.76758 3.97266 12.4043 3.97266 12.4043C3.97266 12.4043 3.97266 15.0117 4.32422 16.2715C4.5 16.9746 5.05664 17.502 5.73047 17.6777C6.99023 18 12 18 12 18C12 18 16.9805 18 18.2402 17.6777C18.9141 17.502 19.4707 16.9746 19.6465 16.2715C19.998 15.0117 19.998 12.4043 19.998 12.4043C19.998 12.4043 19.998 9.76758 19.6465 8.53711ZM10.3594 14.7773V10.0312L14.5195 12.4043L10.3594 14.7773Z"
})), Facebook = /* @__PURE__ */ React.createElement("svg", {
  style: {
    flex: "0 0 100%"
  },
  viewBox: "0 0 24 24"
}, /* @__PURE__ */ React.createElement("path", {
  d: "M15.4863 13.3125L15.8965 10.6172H13.2891V8.85938C13.2891 8.09766 13.6406 7.39453 14.8125 7.39453H16.0137V5.08008C16.0137 5.08008 14.9297 4.875 13.9043 4.875C11.7656 4.875 10.3594 6.19336 10.3594 8.53711V10.6172H7.95703V13.3125H10.3594V19.875H13.2891V13.3125H15.4863Z"
})), FacebookCircle = /* @__PURE__ */ React.createElement("svg", {
  style: {
    flex: "0 0 100%"
  },
  viewBox: "0 0 24 24"
}, /* @__PURE__ */ React.createElement("path", {
  d: "M19.2656 12.375C19.2656 8.36133 16.0137 5.10938 12 5.10938C7.98633 5.10938 4.73438 8.36133 4.73438 12.375C4.73438 16.0078 7.37109 19.0254 10.8574 19.5527V14.4844H9.01172V12.375H10.8574V10.793C10.8574 8.97656 11.9414 7.95117 13.582 7.95117C14.4023 7.95117 15.2227 8.09766 15.2227 8.09766V9.88477H14.3145C13.4062 9.88477 13.1133 10.4414 13.1133 11.0273V12.375H15.1348L14.8125 14.4844H13.1133V19.5527C16.5996 19.0254 19.2656 16.0078 19.2656 12.375Z"
})), Twitch = /* @__PURE__ */ React.createElement("svg", {
  style: {
    flex: "0 0 100%"
  },
  viewBox: "0 0 24 24"
}, /* @__PURE__ */ React.createElement("path", {
  d: "M16.9551 8.92188H15.8125V12.1445H16.9551V8.92188ZM13.8496 8.89258H12.707V12.1152H13.8496V8.89258ZM9.01562 5.875L6.20312 8.57031V18.209H9.60156V20.875L12.4141 18.209H14.6699L19.7676 13.375V5.875H9.01562ZM18.6543 12.8477L16.3691 14.9863H14.1133L12.1504 16.8613V14.9863H9.60156V6.95898H18.6543V12.8477Z"
})), TwitchDuo = /* @__PURE__ */ React.createElement("svg", {
  style: {
    flex: "0 0 100%"
  },
  viewBox: "0 0 24 24"
}, /* @__PURE__ */ React.createElement("path", {
  d: "M19 6.5H9L8.8125 17.5H13.5L19 13V6.5Z",
  fill: neutral(0)
}), /* @__PURE__ */ React.createElement("path", {
  d: "M16.9551 8.92188H15.8125V12.1445H16.9551V8.92188ZM13.8496 8.89258H12.707V12.1152H13.8496V8.89258ZM9.01562 5.875L6.20312 8.57031V18.209H9.60156V20.875L12.4141 18.209H14.6699L19.7676 13.375V5.875H9.01562ZM18.6543 12.8477L16.3691 14.9863H14.1133L12.1504 16.8613V14.9863H9.60156V6.95898H18.6543V12.8477Z"
})), Twitter = /* @__PURE__ */ React.createElement("svg", {
  style: {
    flex: "0 0 100%"
  },
  viewBox: "0 0 24 24"
}, /* @__PURE__ */ React.createElement("path", {
  d: "M20.6681 7.98749C20.6806 8.16248 20.6806 8.33751 20.6806 8.5125C20.6806 13.85 16.6197 20 9.1976 20C6.91098 20 4.78681 19.3375 3 18.1875C3.32489 18.225 3.63723 18.2375 3.97462 18.2375C5.86136 18.2375 7.59821 17.6 8.98518 16.5125C7.21086 16.475 5.72393 15.3125 5.21162 13.7125C5.46155 13.75 5.71143 13.775 5.97386 13.775C6.33621 13.775 6.69859 13.725 7.03594 13.6375C5.18666 13.2625 3.79966 11.6375 3.79966 9.67499V9.62501C4.33693 9.92501 4.96174 10.1125 5.62393 10.1375C4.53685 9.41247 3.82466 8.17498 3.82466 6.77497C3.82466 6.02499 4.02454 5.33749 4.37443 4.73748C6.36117 7.18748 9.34753 8.78745 12.6962 8.96248C12.6337 8.66248 12.5962 8.35001 12.5962 8.03751C12.5962 5.81248 14.3955 4 16.6322 4C17.7942 4 18.8438 4.4875 19.581 5.275C20.4931 5.10001 21.3678 4.76249 22.1425 4.3C21.8426 5.23752 21.2054 6.02502 20.3682 6.52499C21.1804 6.43753 21.9676 6.21248 22.6923 5.90001C22.1426 6.69998 21.4553 7.41245 20.6681 7.98749Z"
})), LinkedIn = /* @__PURE__ */ React.createElement("svg", {
  style: {
    flex: "0 0 100%"
  },
  viewBox: "0 0 24 24"
}, /* @__PURE__ */ React.createElement("path", {
  d: "M19.2 3H4.8C3.81 3 3.009 3.81 3.009 4.8L3 19.2C3 20.19 3.81 21 4.8 21H19.2C20.19 21 21 20.19 21 19.2V4.8C21 3.81 20.19 3 19.2 3ZM8.4 18.3H5.7V10.2H8.4V18.3ZM7.05 8.679C6.15 8.679 5.421 7.95 5.421 7.05C5.421 6.15 6.15 5.421 7.05 5.421C7.95 5.421 8.679 6.15 8.679 7.05C8.679 7.95 7.95 8.679 7.05 8.679ZM18.3 18.3H15.6V13.53C15.6 12.783 14.997 12.18 14.25 12.18C13.503 12.18 12.9 12.783 12.9 13.53V18.3H10.2V10.2H12.9V11.28C13.368 10.524 14.331 10.02 15.15 10.02C16.887 10.02 18.3 11.433 18.3 13.17V18.3Z"
})), Lightstream = /* @__PURE__ */ React.createElement("svg", {
  style: {
    flex: "0 0 100%"
  },
  viewBox: "0.144 0 27.712 24"
}, /* @__PURE__ */ React.createElement("path", {
  d: "M16.0369 12.1232L14 15.6518L11.5642 11.4335L6.27356 10.6176L14 24L20.4627 12.805L16.0369 12.1232Z"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M9.74033 8.27418L7.37317 4.17409H20.6268L19.0921 6.83194L24.3827 6.01602L27.8558 0H0.144165L5.31453 8.95665L9.74033 8.27418Z"
})), LightstreamWithText = /* @__PURE__ */ React.createElement("svg", {
  style: {
    flex: "0 0 100%"
  },
  viewBox: "0 0 3000 524"
}, /* @__PURE__ */ React.createElement("polygon", {
  points: "330.56 263.5 299.73 316.91 262.86 253.06 182.78 240.71 299.73 443.27 397.55 273.82 330.56 263.5"
}), /* @__PURE__ */ React.createElement("polygon", {
  points: "235.25 205.24 199.42 143.18 400.03 143.18 376.8 183.41 456.88 171.06 509.45 80 90 80 168.26 215.57 235.25 205.24"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M646.32,345.72h94.91v13.73H630V167.26h16.36Z"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M846.24,359.45H830V167.26h16.23Z"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M1091.16,336.61q-8.45,12-26.46,18.74t-40.33,6.73q-22.57,0-40.13-10.82t-27.19-30.62q-9.64-19.8-9.77-45.41V250.95q0-40,20.2-63.16t54.25-23.17q29.69,0,47.78,15.11T1091,221.38h-16.24q-3.56-21.18-17.23-32.11t-35.7-10.92q-26.92,0-42.64,19.15t-15.71,54v22.72q0,21.93,7.46,38.77t21.38,26.09q13.92,9.25,32,9.25,21,0,36-6.6,9.76-4.36,14.52-10.16V282h-51.61V268.24h67.85Z"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M1333.71,359.45h-16.37V278.11H1207.53v81.33h-16.23V167.26h16.23v97.12h109.81V167.26h16.37Z"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M1563.2,181h-65.87V359.45H1481.1V181h-65.73V167.26H1563.2Z"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M1990.75,181h-65.87V359.45h-16.23V181h-65.73V167.26h147.83Z"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M2147.65,279.33h-55.84v80.12h-16.36V167.26h62.43q30.75,0,48,14.9t17.29,41.66a52,52,0,0,1-10.83,32.56q-10.82,14.11-29,19.51l48,81.83v1.72h-17.29Zm-55.84-13.73h49.76q20.45,0,32.86-11.63t12.41-30.14q0-20.36-12.93-31.59T2137.61,181h-45.8Z"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M2407.62,278.11h-89.88v67.61h103.35v13.73H2301.5V167.26h118.92V181H2317.73v83.39h89.88Z"
}), /* @__PURE__ */ React.createElement("polygon", {
  points: "2892.79 183.67 2892.79 183.67 2816.23 326.97 2724.06 154.45 2724.06 189.54 2724.06 359.75 2739.67 359.75 2739.67 218.3 2816.26 359.42 2892.79 218.32 2892.79 359.75 2908.4 359.75 2908.4 189.54 2908.4 154.45 2892.79 183.67"
}), /* @__PURE__ */ React.createElement("polygon", {
  points: "2649.77 359.45 2569.47 154.54 2569.47 154.53 2569.46 154.53 2569.46 154.53 2569.46 154.54 2489.16 359.45 2506.19 359.45 2569.46 194.32 2632.74 359.45 2649.77 359.45"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M1764.57,287q-6.73-10.56-20.06-18.15a131.55,131.55,0,0,0-21.47-9.18l-7.64,13.49q19.65,6.61,28.32,13.77,11.22,9.3,11.22,25.28,0,16.37-13.6,26.26t-36,9.9c-11.35,0-21.05-1.94-29.35-5.51l-7,12.33a94,94,0,0,0,36.33,6.91q29.7,0,47.85-13.73t18.15-36.43Q1771.3,297.55,1764.57,287Z"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M1659.11,250.93c7.28,5.25,18,10.18,32.13,14.79l7.72-13.38q-21-6.41-31.29-14.49Q1655.95,228.61,1656,214q0-15.83,13-25.66t35-9.83c13.12,0,23.78,3.19,32.26,9.21l7.23-12.51c-1.71-1-3.43-2.1-5.3-3q-15.09-7.38-34.18-7.38-28.19,0-46.31,13.76t-18.11,35.77Q1639.62,237,1659.11,250.93Z"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M1744.34,268.78a129.23,129.23,0,0,0-21.68-9.32l-7.79,13.49c13.28,4.44,22.87,9.06,28.68,13.88q11.2,9.29,11.2,25.23,0,16.33-13.57,26.21t-36,9.88c-11.8,0-21.85-2-30.34-5.91l-7.08,12.26.2.1a93.63,93.63,0,0,0,37.22,7.25q29.64,0,47.75-13.7t18.11-36.36q0-14.36-6.72-24.9T1744.34,268.78Z"
})), IconMap = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Facebook,
  FacebookCircle,
  Lightstream,
  LightstreamWithText,
  LinkedIn,
  Twitch,
  TwitchDuo,
  Twitter,
  YouTube,
  YouTubeDuo
}, Symbol.toStringTag, { value: "Module" })), nudge = (a) => {
  if (a.nudgeUp || a.nudgeDown || a.nudgeRight || a.nudgeLeft)
    return {
      position: "relative",
      top: a.nudgeDown,
      left: a.nudgeRight,
      right: a.nudgeLeft,
      bottom: a.nudgeUp
    };
}, SVGWrapper = ({
  children: a,
  width: u,
  height: c,
  color: l,
  colorWeight: v = 0,
  marginLeft: p,
  marginTop: _,
  marginRight: k,
  marginBottom: M,
  className: L,
  ...F
}) => (l && Color[l](v), /* @__PURE__ */ React.createElement("div", {
  className: L,
  style: {
    ...nudge(F),
    display: "flex",
    justifyContent: "center",
    flexBasis: u || "auto",
    flexShrink: 0,
    width: u,
    height: c || u && "fit-content",
    marginLeft: p,
    marginTop: _,
    marginBottom: M,
    marginRight: k
  }
}, a)), Icon = ({
  name: a,
  ...u
}) => /* @__PURE__ */ React.createElement(SVGWrapper, {
  ...u
}, IconMap[a]), Icon$1 = Icon, dragImageSvg = `
  <svg height="75" width="120" viewBox="0 0 120 75" xmlns="http://www.w3.org/2000/svg" style="">
    <rect width="120" height="75" rx="3" style="
      opacity: 0.4;
      stroke: white;
      stroke-width: 3px;
      stroke-opacity: 0.7;
    "/>
  </svg>`;
let dragImage;
const loadDragImage = () => dragImage || (dragImage = new Image(), dragImage.src = URL.createObjectURL(new Blob([dragImageSvg], {
  type: "image/svg+xml"
})), dragImage);
class ErrorBoundary extends React.Component {
  constructor(u) {
    super(u), this.state = {
      error: null
    };
  }
  componentDidCatch(u, c) {
    log.warn(u, c);
  }
  static getDerivedStateFromError() {
    return {
      error: !0
    };
  }
  render() {
    return this.state.error ? null : this.props.children;
  }
}
const onDrop = async (a, u) => {
  const {
    dropNodeId: c,
    dragNodeId: l,
    dropType: v,
    project: p
  } = a;
  if (log.debug("Compositor: Dropping", {
    dropType: v,
    dragNodeId: l,
    dropNodeId: c
  }), c === l)
    return;
  const [_, k, M, L] = await Promise.all([p.compositor.get(l), p.compositor.get(c), p.compositor.getParent(l), p.compositor.getParent(c)]);
  if (v === "layout")
    return M.id === c ? void 0 : CoreContext.Command.moveNode({
      projectId: p.id,
      nodeId: _.id,
      parentId: k.id
    });
  if (M.id !== (L == null ? void 0 : L.id))
    return;
  const F = M.children.map((V) => V.id);
  return CoreContext.Command.reorderNodes({
    projectId: p.id,
    parentId: M.id,
    childIds: swapItems(_.id, k.id, F)
  });
};
let draggingNodeIdRef = null;
const DRAG_DISTANCE_BUFFER = 2, ElementTree = (a) => {
  var H, B, T, D;
  const u = useRef(), c = useRef(!1), l = useRef(), v = useRef(), p = useRef(), [_, k] = useState(), {
    projectId: M,
    interactive: L,
    draggingNodeId: F,
    onElementDoubleClick: V,
    checkDragTarget: X,
    checkDropTarget: oe,
    getNodePresetsOverlay: Y,
    onPresetPreview: ae,
    onPresetSelect: ne,
    setDraggingNodeId: fe
  } = useContext(CompositorContext), {
    nodeId: ie
  } = a, ge = getProject(M), be = ge.compositor.get(ie), Ce = CoreContext.compositor.getElement(be), [Me, Be] = useState({}), Ae = {
    ...be.props,
    ...Me
  }, Z = Ae.layout || "Row", z = (L && (X == null ? void 0 : X(be))) ?? !1, P = (L && (oe == null ? void 0 : oe(be))) ?? !1, S = Y == null ? void 0 : Y(be, ge.props);
  let E = be.children.some((ee) => ee.id === F), I = P && F && !c.current ? {
    onpointerup: (ee) => (log.debug('Compositor: PointerUp "Layout"', be.id), onDrop({
      dropType: "layout",
      dropNodeId: be.id,
      dragNodeId: F,
      project: ge
    })),
    onpointerenter: (ee) => {
      var pe;
      ee.preventDefault(), ee.stopPropagation(), (pe = p.current) == null || pe.toggleAttribute("data-layout-drop-target-active", !0);
    },
    onpointerleave: (ee) => {
      var pe;
      ee.preventDefault(), ee.stopPropagation(), (pe = p.current) == null || pe.toggleAttribute("data-layout-drop-target-active", !1);
    }
  } : {}, N = z ? {
    onpointerdown: (ee) => {
      var ve;
      u.current = {
        x: ee.clientX,
        y: ee.clientY
      };
      let pe = u.current;
      log.debug("Compositor: Dragging", be.id), wrapperEl.toggleAttribute("data-dragging", !0), (ve = p.current) == null || ve.toggleAttribute("data-drag-target-active", !0);
      const Ie = () => {
        c.current && (dragPreviewEl.style.top = pe.y - 20 + "px", dragPreviewEl.style.left = pe.x - 20 + "px", dragPreviewEl.toggleAttribute("data-active", !0), requestAnimationFrame(() => Ie()));
      }, Pe = (Q) => {
        if (!c.current && u.current) {
          const le = Math.abs(Q.clientX - u.current.x) >= DRAG_DISTANCE_BUFFER || Math.abs(Q.clientY - u.current.y) >= DRAG_DISTANCE_BUFFER;
          le && (fe(be.id), c.current = le, Ie());
        }
        pe = {
          x: Q.clientX,
          y: Q.clientY
        };
      };
      Pe(ee);
      const he = (Q) => {
        setTimeout(() => {
          log.debug("Compositor: DragEnd", Q), u.current = void 0, c.current = !1, fe(null), dragPreviewEl.toggleAttribute("data-active", !1), wrapperEl.toggleAttribute("data-dragging", !1), wrapperEl.toggleAttribute("data-drop-target-ready", !1), wrapperEl.querySelectorAll("[data-item]").forEach((le) => {
            le.toggleAttribute("data-drag-target-active", !1), le.toggleAttribute("data-layout-drop-target-active", !1), le.toggleAttribute("data-transform-drop-target-active", !1), le.toggleAttribute("data-transform-drop-self-active", !1);
          });
        }), document.removeEventListener("pointermove", Pe), document.removeEventListener("pointerup", he);
      };
      document.addEventListener("pointermove", Pe), document.addEventListener("pointerup", he);
    },
    onpointerup: (ee) => {
      log.debug('Compositor: PointerUp "Node"', be.id), draggingNodeIdRef && draggingNodeIdRef !== be.id && onDrop({
        dropType: "transform",
        dropNodeId: be.id,
        dragNodeId: draggingNodeIdRef,
        project: ge
      });
    },
    onpointerenter: (ee) => {
      var pe, Ie;
      ee.preventDefault(), ee.stopPropagation(), draggingNodeIdRef && (c.current ? (log.debug("Compositor: Mouseenter self", be.id), (pe = p.current) == null || pe.toggleAttribute("data-transform-drop-self-active", !0)) : (log.debug("Compositor: Mouseenter other", be.id), (Ie = p.current) == null || Ie.toggleAttribute("data-transform-drop-target-active", !0), setTimeout(() => {
        c.current || wrapperEl.toggleAttribute("data-drop-target-ready", !0);
      })));
    },
    onpointerleave: (ee) => {
      var pe, Ie;
      ee.preventDefault(), ee.stopPropagation(), draggingNodeIdRef && ((pe = p.current) == null || pe.toggleAttribute("data-transform-drop-self-active", !1), (Ie = p.current) == null || Ie.toggleAttribute("data-transform-drop-target-active", !1), wrapperEl.toggleAttribute("data-drop-target-ready", !1));
    }
  } : {};
  useEffect(() => {
    v.current && Ce && (v.current.appendChild(Ce.root), Object.assign(v.current.style, {
      width: "100%",
      height: "100%",
      position: "relative",
      overflow: "hidden"
    }), Object.assign(Ce.root.style, {
      pointerEvents: z ? "all" : "none",
      width: "100%",
      height: "100%",
      position: "relative",
      ...Ae.style || {}
    }));
  }, [v.current, Ce]), useEffect(() => {
    const ee = z ? () => V == null ? void 0 : V(be) : () => {
    };
    return l.current && (Object.assign(l.current, N), Object.assign(l.current.style, {
      pointerEvents: z ? "all" : "none"
    }), l.current.addEventListener("dblclick", ee)), () => {
      var pe;
      (pe = l.current) == null || pe.removeEventListener("dblclick", ee);
    };
  }, [l.current]), useEffect(() => {
    p.current && Object.assign(l.current, I);
  }, [p.current]);
  const $ = {
    layout: Z,
    ...Ae.layoutProps ?? {}
  }, U = useMemo(() => (ee) => {
    ee.toggleAttribute("data-preset-drag-target-active", !1), window.clearTimeout(_), Be({}), k(void 0);
  }, [_, Be]);
  return be ? /* @__PURE__ */ React.createElement("div", {
    ref: p,
    "data-id": be.id + "-x",
    "data-source-type": be.props.sourceType,
    "data-item": !0,
    ...z && {
      "data-drag-target": !0
    },
    ...P && {
      "data-drop-target": !0
    },
    style: {
      position: "relative",
      width: ((H = Ae == null ? void 0 : Ae.size) == null ? void 0 : H.x) ?? "100%",
      height: ((B = Ae == null ? void 0 : Ae.size) == null ? void 0 : B.y) ?? "100%",
      pointerEvents: "none"
    }
  }, /* @__PURE__ */ React.createElement("div", {
    className: "layout-preset-zones",
    style: {
      height: "100%",
      width: "100%",
      position: "absolute",
      zIndex: 4,
      pointerEvents: "none",
      transition: "opacity 300ms ease"
    }
  }, S == null ? void 0 : S.map(({
    name: ee,
    position: pe,
    layout: Ie
  }) => /* @__PURE__ */ React.createElement("div", {
    key: ee,
    className: `layout-preset-zone ${Ie}`,
    "data-drag-target": !0,
    style: {
      position: "absolute",
      pointerEvents: E ? "all" : "none",
      opacity: E ? 1 : 0,
      transition: E ? "opacity 500ms ease 200ms, background-color 100ms ease" : "",
      ...pe
    },
    onPointerOver: (Pe) => {
      if (Pe.stopPropagation(), !draggingNodeIdRef)
        return;
      Pe.currentTarget.toggleAttribute("data-preset-drag-target-active", !0);
      const he = window.setTimeout(() => {
        ae == null || ae({
          node: ge.compositor.get(draggingNodeIdRef),
          preset: ee,
          setLocalState: Be
        });
      }, 250);
      k(he);
    },
    onPointerLeave: (Pe) => {
      Pe.stopPropagation(), draggingNodeIdRef && U(Pe.currentTarget);
    },
    onPointerUp: (Pe) => {
      draggingNodeIdRef && (U(Pe.currentTarget), ne == null || ne({
        node: ge.compositor.get(draggingNodeIdRef),
        preset: ee
      }));
    }
  }))), /* @__PURE__ */ React.createElement("div", {
    className: "interactive-overlay",
    ref: l,
    style: {
      width: ((T = be.props) == null ? void 0 : T.isAudioOnly) ?? !1 ? "0%" : "100%",
      height: ((D = be.props) == null ? void 0 : D.isAudioOnly) ?? !1 ? "0%" : "100%",
      position: "absolute",
      zIndex: 2
    }
  }), /* @__PURE__ */ React.createElement("div", {
    className: "item-element",
    style: {
      display: "flex",
      flex: "0 0 auto",
      justifyContent: "center",
      width: "100%",
      height: "100%"
    }
  }, /* @__PURE__ */ React.createElement("div", {
    ref: v
  }), /* @__PURE__ */ React.createElement(ErrorBoundary, null, /* @__PURE__ */ React.createElement("ls-layout", {
    "data-id": be.id + "-x",
    props: JSON.stringify($),
    layout: Z
  }, be.children.map((ee) => /* @__PURE__ */ React.createElement(ElementTree, {
    key: ee.id,
    nodeId: ee.id
  })))))) : null;
}, Root = (a) => {
  const [u, c] = useState(null), {
    projectId: l
  } = useContext(CompositorContext), v = getProject(l);
  return useEffect(() => (c(v.compositor.renderTree()), CoreContext.onInternal("NodeChanged", () => {
    c(v.compositor.renderTree());
  })), []), useEffect(() => {
    const p = v.compositor.getRoot(), {
      x: _
    } = p.props.size, k = () => {
      var Y, ae, ne;
      const {
        bannerStyle: M = "default",
        primaryColor: L = "#ABABAB",
        showNameBanners: F
      } = v.props ?? {}, V = ((Y = v.props) == null ? void 0 : Y.logoPosition) ?? ((ne = (ae = v.props) == null ? void 0 : ae.logo) == null ? void 0 : ne.logoPosition) ?? "top-right";
      if (!M || !L || !V)
        return;
      const X = themes[M](L, F, _ / 1920), oe = themes[V](_ / 1920);
      a.setStyle(`${X} ${oe}` || "");
    };
    return k(), CoreContext.onInternal("ProjectChanged", k);
  }, [v]), u ? /* @__PURE__ */ React.createElement("div", {
    style: {
      userSelect: "none",
      width: `${u.props.size.x + PADDING * 2}px`,
      height: `${u.props.size.y + PADDING * 2}px`,
      margin: PADDING + "px"
    }
  }, /* @__PURE__ */ React.createElement("div", {
    style: {
      width: "100%",
      height: "100%",
      overflow: "hidden"
    }
  }, /* @__PURE__ */ React.createElement(ElementTree, {
    nodeId: u.id
  }))) : null;
};
let dragPreviewEl, wrapperEl, customStyleEl;
const PADDING = 0, render = (a) => {
  const {
    containerEl: u,
    projectId: c,
    interactive: l = !1,
    checkDragTarget: v = scenelessProjectDragCheck,
    checkDropTarget: p = scenelessProjectDropCheck
  } = a, _ = getProject(c);
  if (CoreContext.clients.LayoutApi().subscribeToLayout(_.layoutApi.layoutId), loadDragImage(), !u || !_)
    return;
  if (!u.shadowRoot) {
    u.attachShadow({
      mode: "open"
    }), customStyleEl = document.createElement("style");
    const oe = document.createElement("style");
    oe.textContent = getStyle(), wrapperEl = document.createElement("div"), wrapperEl.id = "compositor-root", Object.assign(wrapperEl.style, {
      width: "100%",
      height: "100%",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      transformOrigin: "center"
    }), dragPreviewEl = document.createElement("div"), dragPreviewEl.id = "drag-preview", u.shadowRoot.appendChild(oe), u.shadowRoot.appendChild(customStyleEl), u.shadowRoot.appendChild(wrapperEl), u.shadowRoot.appendChild(dragPreviewEl), new ResizeObserver((ae) => {
      F();
    }).observe(u);
  }
  const k = _.compositor.getRoot(), {
    x: M,
    y: L
  } = k.props.size, F = () => {
    let {
      width: oe,
      height: Y
    } = u.getBoundingClientRect();
    const ae = oe / Y, ne = M / L;
    let fe;
    oe && Y ? ne > ae ? fe = oe / (M + PADDING * 2) : fe = Y / (L + PADDING * 2) : fe = 1, wrapperEl.style.willChange = "transform", wrapperEl.style.transform = `scale(${fe}) translateZ(0)`, window.__scale = fe, X();
  }, V = createRoot(wrapperEl), X = () => {
    V.render(/* @__PURE__ */ React.createElement(CompositorProvider, {
      interactive: l,
      checkDragTarget: v,
      checkDropTarget: p,
      ...a
    }, /* @__PURE__ */ React.createElement(Root, {
      setStyle: (oe) => {
        customStyleEl.textContent = oe;
      }
    })));
  };
  F();
}, scenelessProjectDragCheck = (a) => a.props.name === "Participant" || a.props.sourceType === "RoomParticipant" || a.props.sourceType === "RTMP" || a.props.sourceType === "Game", scenelessProjectDropCheck = (a) => a.props.name === "Content", CompositorContext = React.createContext(null), CompositorProvider = ({
  children: a,
  ...u
}) => {
  const [c, l] = useState(null);
  return draggingNodeIdRef = c, /* @__PURE__ */ React.createElement(CompositorContext.Provider, {
    value: {
      ...u,
      draggingNodeId: c,
      setDraggingNodeId: l
    }
  }, a);
}, getStyle = () => `
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  font-family: 'Arial';
}

video {
  width: 100%;
  height: 100%;
  object-fit: contain;
}

.NameBanner {
  top: 100%;
  transform: translateY(-100%);
  left: 0;
  height: 30px;
  background: linear-gradient(90deg, rgba(0, 0, 0, 0.5) 50%, rgba(0, 0, 0, 0) 100%);
  padding: 0px 0px 0px 10px;
  color: rgba(255, 255, 255, 0.9);
  font-weight: bold;
  line-height: 30px;
  width: 100%;
  font-size: 28px;
  position: absolute;
}

.item-element {
  transition: opacity 150ms ease;
}

.interactive-overlay .interactive-overlay-hover {
  opacity: 0;
  pointer-events: none;
}

.interactive-overlay:hover .interactive-overlay-hover {
  opacity: 1;
  pointer-events: all;
}

.layout-preset-zone {
  background-color: rgba(0,0,0,0.6);
  outline: 2px solid rgba(255,255,255,0.3);
}

.layout-preset-zone[data-preset-drag-target-active] {
  background-color: rgba(255,255,255,0.3);
}

.layout-preset-zone.Alert[data-preset-drag-target-active] {
  background: rgba(88, 218, 175, 0.75) !important;
}

ls-layout[layout="Presentation"][props*="\\"cover\\"\\:true"] > :first-child .NameBanner {
  top: 0% !important;
  transform: translateY(0%) !important;
}

[layout="Layered"] > [data-item] {
  transform: scale(1.003) !important;
}
[layout="Layered"] > [data-item]:nth-child(2) {
  transform: scale(1.0015) !important;
}
[layout="Layered"] > [data-item]:nth-child(1) {
  transform: scale(1) !important;
}

.logo {
  position: absolute !important;
}

#compositor-root[data-dragging] * {
  cursor: grabbing !important;
}

#drag-preview {
  position: absolute;
  z-index: 2;
  top: 0;
  left: 0;
  width: 100px;
  height: 60px;
  opacity: 0;
  background: rgba(0,0,0,0.2);
  border: 3px solid rgba(255,255,255,0.3);
  pointer-events: none;
}
#drag-preview[data-active] {
  opacity: 1;
}
#compositor-root[data-drop-target-ready] ~ #drag-preview {
  display: none;
}

[data-drag-target] {}
[data-drag-target]:hover:not([data-drag-target-active]) > .interactive-overlay {
  box-shadow: 0 0 0 3px inset rgba(255, 255, 255, 0.5);
  cursor: grab;
}
[data-drop-target] {}
[data-drop-target]:hover {}
[data-drag-target][data-drag-target-active] > .interactive-overlay {
  border: 3px solid #ffff007d;
}
[data-drag-target][data-drag-target-active]:not([data-transform-drop-self-active]) > .interactive-overlay {
  border: 3px dashed #ffff007d;
}
#compositor-root[data-drop-target-ready] [data-drag-target][data-drag-target-active] > .item-element {
  opacity: 0.6;
}
[data-layout-drop-target-active] > .interactive-overlay {
  box-shadow: 0 0 0 3px inset yellow;
}
[data-transform-drop-target-active] > .interactive-overlay {
  box-shadow: 0 0 0 3px inset white;
}
`;
var BannerStyle = /* @__PURE__ */ ((a) => (a.DEFAULT = "default", a.MINIMAL = "minimal", a.BUBBLE = "bubble", a))(BannerStyle || {});
const themes = {
  "top-left": (a = 1280 / 1920) => `
      .wrapper {
       top:0;
       left:0;
    }`,
  "top-right": (a = 1280 / 1920) => `
      .wrapper {
       top:0;
       right:0;
    }`,
  "bottom-left": (a = 1280 / 1920) => `
      .wrapper {
       bottom:0;
       left:0;
    }`,
  "bottom-right": (a = 1280 / 1920) => `
      .wrapper {
       bottom:0;
       right:0;
    }`,
  default: (a = "#ABABAB", u = !0, c = 1280 / 1920) => {
    const l = color(a).lightness() < 0.6 ? "#FFF" : "#000", v = color(a).lightness() < 0.6 ? "#FFF" : "#000", p = color(a).lightness() < 0.6 ? "#000" : "#FFF", _ = (k) => k * c + "px";
    return `
      .ChatOverlay {
        background: ${a} !important;
        margin-bottom: ${_(40)} !important;
        transition: 300ms ease all;
        left: 0;

        /* Default Size 4 */
        font-size: ${_(44)} !important;
        padding: ${_(40)} ${_(100)} !important;
        border-radius: ${_(20)} !important;
      }
      
      .ChatOverlay-badge-icon {
          width:${_(32)};
          height: ${_(32)};
          fill: currentcolor;
          color: ${p};
      }

       .ChatOverlay-badge-container {
          background-color:${v};
          display:flex;
          flex-direction:row;
          padding: ${_(6)} ${_(12)} ${_(6)} ${_(6)};
          border-radius: ${_(10)};
          align-items: center;
          border-bottom-left-radius: 0px !important;
          position: relative;
          border: none;
          cursor: pointer;
       }
      
       .ChatOverlay-badge-username {
          color:${p};
          padding:${_(6)};
          font-size:${_(18)};
          font-weight:700;
          text-transform: capitalize; 
       }
       
       .ChatOverlay-badge-container::before {
          content:"";
          width:15px;
          height:15px;
          background-color:${v};
          position: absolute;
          bottom:-14px;
          left:0;
          clip-path:polygon(0 100%, 12% 87%, 26% 73%, 45% 53%, 59% 40%, 71% 28%, 85% 14%, 100% 0, 0 0);
        }
       

       .ChatOverlay-avatar {
          height: ${_(120)};
          width: ${_(120)};
          left:0;
          right:0;
          top:0;
          bottom:0;
          border-radius:50%;
       }

      .Banner, .NameBanner, .ChatOverlay {
        background: ${a} !important;
        margin-bottom: ${_(40)} !important;
        transition: 300ms ease all;
        left: 0;

        /* Default Size 4 */
        font-size: ${_(44)} !important;
        padding: ${_(40)} ${_(100)} !important;
        border-top-right-radius: ${_(20)} !important;
        border-bottom-right-radius: ${_(20)} !important;
      }

      .Banner-body, .NameBanner-body, .ChatOverlay-body {
        color: ${l} !important;
        font-family: 'Roboto' !important;
        font-style: normal !important;
        font-weight: 700 !important;
        line-height: 120% !important;
      }

      .NameBanner {
        transform-origin: 0 100%;
        margin: 0 !important;
        transform: translateX(-100%);
        opacity: 0 !important;
        white-space: nowrap;
        ${u && `
          opacity: 1 !important;
          transform: translateX(0);
        `}
      }

      .NameBanner[data-size="4"] {
        padding: ${_(40)} ${_(100)} !important;
        font-size: ${_(44)} !important;
        border-top-right-radius: ${_(20)} !important;
        border-bottom-right-radius: ${_(20)} !important;
      }
      .NameBanner[data-size="3"] {
        padding: ${_(12)} ${_(30)} !important;
        font-size: ${_(44)} !important;
        border-top-right-radius: ${_(20)} !important;
        border-bottom-right-radius: ${_(20)} !important;
      }
      .NameBanner[data-size="2"] {
        padding: ${_(12)} ${_(20)} !important;
        font-size: ${_(28)} !important;
        border-top-right-radius: ${_(16)} !important;
        border-bottom-right-radius: ${_(16)} !important;
      }
      .NameBanner[data-size="1"], .NameBanner[data-size="0"] {
        padding: ${_(8)} ${_(8)} !important;
        font-size: ${_(20)} !important;
        border-top-right-radius: ${_(8)} !important;
        border-bottom-right-radius: ${_(8)} !important;
      }
      .NameBanner[data-size="0"] {
        opacity: 0;
        transform: translateX(-100%);
      }
    `;
  },
  minimal: (a = "#ABABAB", u = !0, c = 1280 / 1920) => {
    const l = "white", v = "#fff", p = "#000", _ = (k) => k * c + "px";
    return `

      .ChatOverlay-badge-icon {
          width:${_(32)};
          height: ${_(32)};
          fill: currentcolor;
          color: ${p};
      }

       .ChatOverlay-badge-container {
          background-color:${v};
          display:flex;
          flex-direction:row;
          padding: ${_(6)} ${_(12)} ${_(6)} ${_(6)};
          align-items: center;
          position: relative;
          border: none;
          cursor: pointer;
       }

       .ChatOverlay-badge-username {
          color:${p};
          padding:${_(6)};
          font-size:${_(18)};
          font-weight:700;
          text-transform: capitalize; 
       }

       .ChatOverlay-avatar {
          height: ${_(120)};
          width: ${_(120)};
          left:0;
          right:0;
          top:0;
          bottom:0;
          border-radius:50%;
       }


    .Banner, .NameBanner, .ChatOverlay {
        background: ${color(a).fade(color(a).alpha() * 0.7).toString()} !important;
        padding: ${_(40)} ${_(40)} ${_(40)} ${_(60)} !important;
        position: relative !important;
        margin-bottom: ${_(40)} !important;
        transition: 300ms ease all;
        font-size: ${_(34)} !important;
        left: 0;
      }

      .Banner:before, .NameBanner:before, .ChatOverlay:before {
        z-index: 1;
        content: "";
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.6);
        transition: 300ms ease all;
        opacity: ${color(a).alpha()};
      }
      .Banner:after, .NameBanner:after, .ChatOverlay:after {
        z-index: 1;
        content: "";
        position: absolute;
        left: 0;
        top: 0;
        height: 100%;
        transition: 300ms ease all;
        width: ${_(20)};
        background: ${color(a)};
        opacity: ${color(a).alpha()};
      }
      .Banner-body, .NameBanner-body, .ChatOverlay-body {
        color: ${l} !important;
        font-family: 'Roboto' !important;
        font-style: normal !important;
        font-weight: 700 !important;
        line-height: 120% !important;
        position: relative;
        z-index: 2;
      }
      .Banner-header {
        font-size: ${_(90)};
        position: relative;
        z-index: 2;
      }
      .NameBanner {
        transform-origin: 0 100%;
        margin: 0 !important;
        transform: translateX(-100%);
        opacity: 0 !important;
        white-space: nowrap;
        ${u && `
          opacity: 1 !important;
          transform: translateX(0);
        `}
      }

      .NameBanner[data-size="4"] {
        padding: ${_(40)} ${_(40)} ${_(40)} ${_(60)} !important;
        font-size: ${_(34)} !important;
      }
      .NameBanner[data-size="3"] {
        padding: ${_(16)} ${_(40)} ${_(16)} ${_(60)} !important;
        font-size: ${_(34)} !important;
      }
      .NameBanner[data-size="2"] {
        padding: ${_(12)} ${_(24)} ${_(12)} ${_(44)} !important;
        font-size: ${_(24)} !important;
      }
      .NameBanner[data-size="1"], .NameBanner[data-size="0"] {
        padding: ${_(12)} ${_(16)} ${_(12)} ${_(36)} !important;
        font-size: ${_(18)} !important;
      }
      .NameBanner[data-size="0"] {
        opacity: 0 !important;
        transform: translateX(-100%);
      }
    `;
  },
  bubble: (a = "#ABABAB", u = !0, c = 1280 / 1920) => {
    const l = color(a).lightness() < 0.6 ? "#FFF" : "#000", v = color(a).lightness() < 0.6 ? "#FFF" : "#000", p = color(a).lightness() < 0.6 ? "#000" : "#FFF", _ = (k) => k * c + "px";
    return `
      .ChatOverlay-badge-icon {
          width:${_(32)};
          height: ${_(32)};
          fill: currentcolor;
          color: ${p};
      }


       .ChatOverlay-badge-container {
          background-color:${v};
          display:flex;
          flex-direction:row;
          padding: ${_(6)} ${_(12)} ${_(6)} ${_(6)};
          align-items: center;
          z-index: 1;
          border: none;
          cursor: pointer;
          top: 0;
          margin-bottom: 2px;
          margin-left: -${_(30)};
          border-radius: 30px;
       }

       .ChatOverlay-badge-username {
          color:${p};
          padding:${_(6)};
          font-size:${_(18)};
          font-weight:700;
          text-transform: capitalize; 
       }

       .ChatOverlayAvatar-container {
          height: ${_(120)};
          width: ${_(120)};
          top: 0;
       }
       .ChatOverlay-avatar {
          height: ${_(120)};
          width: ${_(120)};
          left:0;
          right:0;
          top:0;
          bottom:0;
          border-radius:50%;
       }


      .Banner, .ChatOverlay {
        transform: translateX(-50%);
        left: 50%;
        margin-bottom: ${_(40)} !important;
      }

      .Banner, .NameBanner, .ChatOverlay {
        background: ${color(a)} !important;
        color: ${l} !important;
        border-radius: 500px !important;
        transition: 300ms ease all;

        /* Default Style */
        border: 4px solid ${l} !important;
        padding: ${_(40)} ${_(80)} !important;
        font-size: ${_(40)} !important;
      }
      .Banner-body, .NameBanner-body, .ChatOverlay-body {
        color: ${l} !important;
        text-align: center !important;
        font-family: 'Roboto' !important;
        font-style: normal !important;
        font-weight: 700 !important;
        line-height: 120% !important;
      }
      .NameBanner {
        transform-origin: 0% 100%;
        transform: translateX(-100%);
        opacity: 0 !important;
        white-space: nowrap;
        ${u && `
          opacity: 1 !important;
          transform: translateX(0);
        `}
      }

      ls-layout[layout="Presentation"][props*="\\"cover\\"\\:true"] > :first-child .NameBanner {
        top: 0% !important;
        transform: translateY(0%) !important;
        margin: ${_(20)} ${_(20)};
      }


      .NameBanner[data-size="4"] {
        padding: ${_(40)} ${_(80)} ${_(40)} ${_(80)} !important;
        font-size: ${_(40)} !important;
      }
      .NameBanner[data-size="3"] {
        padding: ${_(12)} ${_(30)} ${_(12)} ${_(30)} !important;
        font-size: ${_(40)} !important;
        margin: -${_(20)} ${_(20)};
      }
      .NameBanner[data-size="2"] {
        padding: ${_(12)} ${_(30)} ${_(12)} ${_(30)} !important;
        font-size: ${_(26)} !important;
        margin: -${_(8)} ${_(8)};
      }
      .NameBanner[data-size="1"], .NameBanner[data-size="0"] {
        padding: ${_(8)} ${_(16)} ${_(8)} ${_(16)} !important;
        font-size: ${_(18)} !important;
        border-width: ${_(2)} !important;
        margin: -${_(16)} ${_(8)};
      }
      .NameBanner[data-size="0"] {
        opacity: 0 !important;
        transform: translateX(-100%);
      }
    `;
  }
}, iconStyles = {
  twitch: {
    icon: "Twitch"
  },
  youtube: {
    icon: "YouTube"
  },
  facebook: {
    icon: "Facebook"
  }
}, fixLink = (a) => !a.startsWith("http:") && !a.startsWith("https:") ? `https://${a}` : a, ChatOverlay = {
  name: "LS-ChatOverlay",
  sourceType: "ChatOverlay",
  create({
    onUpdate: a,
    onEvent: u
  }, c) {
    const l = document.createElement("div"), v = getProject(CoreContext.state.activeProjectId), p = v.compositor.getRoot(), {
      x: _
    } = p.props.size, k = (_ ?? 1280) / 1920, M = (ne) => ne * k + "px";
    let L;
    const F = (ne, fe) => {
      const ie = ne.width / fe.width;
      return ne.height / fe.height >= 0.25 && ie >= 0.75 ? 4 : ie >= 0.75 ? 1 : ie >= 0.5 ? -2 : ie > 0.25 ? -3 : -4;
    };
    CoreContext.onInternal("ProjectChanged", () => {
      const {
        bannerStyle: ne
      } = v.props ?? {};
      ne && ae({
        ...L,
        metadata: {
          ...L.metadata,
          bannerStyle: ne
        }
      });
    });
    const V = React.memo((ne) => {
      var fe, ie, ge;
      return (ne == null ? void 0 : ne.type) === "emoticon" && ((fe = ne == null ? void 0 : ne.data) == null ? void 0 : fe.type) === "direct" ? /* @__PURE__ */ React.createElement("img", {
        src: (ie = ne == null ? void 0 : ne.data) == null ? void 0 : ie.url,
        style: {
          height: M(36)
        },
        alt: ne == null ? void 0 : ne.text
      }) : (ne == null ? void 0 : ne.type) === "link" ? /* @__PURE__ */ React.createElement("a", {
        style: {
          color: "#FFF",
          wordBreak: "break-all"
        },
        target: "_blank",
        rel: "noreferrer",
        href: fixLink((ge = ne == null ? void 0 : ne.data) == null ? void 0 : ge.url)
      }, ne == null ? void 0 : ne.text) : /* @__PURE__ */ React.createElement("span", null, ne == null ? void 0 : ne.text);
    }), X = (ne) => {
      const fe = {
        height: `${ne.height}`,
        width: `${ne.width}`,
        background: ne.background || "transparent",
        display: "inline-block",
        verticalAlign: "middle",
        borderRadius: "50%",
        fontSize: `${ne.fontSize}`
      };
      return /* @__PURE__ */ React.createElement("div", {
        style: {
          ...fe,
          position: "relative",
          marginRight: ne == null ? void 0 : ne.marginRight
        }
      }, /* @__PURE__ */ React.createElement("div", {
        style: {
          left: "50%",
          position: "absolute",
          top: "50%",
          transform: "translate(-50%, -50%)"
        }
      }, ne.username.substring(0, 2).toUpperCase()));
    }, oe = (ne) => {
      const {
        message: fe,
        id: ie,
        username: ge,
        metadata: be
      } = ne || {}, [Ce, Me] = useState(0), {
        index: Be,
        platform: Ae,
        avatar: Z,
        bannerStyle: z
      } = be || {}, P = useMemo(() => iconStyles[Ae], [Ae]), S = useRef();
      return useLayoutEffect(() => {
        if (!S.current)
          return;
        const E = () => {
          const N = S.current;
          N && Me(F({
            width: N.clientWidth,
            height: N.clientHeight
          }, {
            width: v.compositor.getRoot().props.size.x,
            height: v.compositor.getRoot().props.size.y
          }));
        }, I = new ResizeObserver((N) => {
          E();
        });
        return E(), I.observe(S.current), () => {
          S != null && S.current && I.unobserve(S == null ? void 0 : S.current);
        };
      }, [S.current, v]), /* @__PURE__ */ React.createElement(APIKitAnimation$1, {
        id: `${ie}_${Be}`,
        type: "chatoverlay",
        enter: APIKitAnimationTypes.SLIDE_IN_LEFT,
        exit: APIKitAnimationTypes.SLIDE_OUT_LEFT,
        duration: 200
      }, /* @__PURE__ */ React.createElement("div", {
        className: "ChatOverlayContainer",
        style: {
          position: "absolute",
          top: 0,
          left: 0,
          width: "100%",
          height: "100%",
          display: "flex",
          flexDirection: "row",
          justifyContent: "flex-start",
          alignItems: "flex-end",
          marginLeft: z !== BannerStyle.BUBBLE ? "5%" : "0px"
        }
      }, z !== BannerStyle.BUBBLE ? (
        /* It's a ternary operator. If the style is not equal to BannerStyle.BUBBLE.toString(), then it will
        render the first div. Otherwise, it will render the second div. */
        /* @__PURE__ */ React.createElement("div", {
          style: {
            width: "100%",
            display: "flex"
          }
        }, Z ? /* @__PURE__ */ React.createElement("span", {
          style: {
            marginRight: "20px"
          }
        }, /* @__PURE__ */ React.createElement("img", {
          src: Z,
          className: "ChatOverlay-avatar"
        })) : /* @__PURE__ */ React.createElement(X, {
          height: M(110),
          width: M(120),
          background: primary(500),
          username: ge,
          marginRight: 20,
          fontSize: M(30)
        }), /* @__PURE__ */ React.createElement("div", {
          style: {
            width: "100%"
          }
        }, ge && /* @__PURE__ */ React.createElement("button", {
          className: "ChatOverlay-badge-container"
        }, (P == null ? void 0 : P.icon) && /* @__PURE__ */ React.createElement(Icon$1, {
          className: "ChatOverlay-badge-icon",
          name: P == null ? void 0 : P.icon
        }), /* @__PURE__ */ React.createElement("div", {
          className: "ChatOverlay-badge-username"
        }, ge)), /* @__PURE__ */ React.createElement("div", {
          className: "ChatOverlay",
          style: {
            padding: 10,
            background: "orange",
            width: "fit-content",
            height: "fit-content",
            maxWidth: "84%",
            position: "relative"
          }
        }, fe && /* @__PURE__ */ React.createElement("div", {
          className: "ChatOverlay-body",
          style: {
            gap: 10,
            display: "flex",
            alignItems: "center",
            flexWrap: "wrap",
            verticalAlign: "middle"
          }
        }, fe.map((E, I) => /* @__PURE__ */ React.createElement(V, {
          key: I,
          ...E
        }))))))
      ) : (
        /* It's a ternary operator. If the style is not equal to BannerStyle.BUBBLE.toString(), then it will
        render the first div. Otherwise, it will render the second div. */
        /* @__PURE__ */ React.createElement("div", {
          style: {
            width: "100%",
            display: "flex"
          }
        }, /* @__PURE__ */ React.createElement("div", {
          className: "ChatOverlay",
          style: {
            padding: 10,
            background: "orange",
            width: "fit-content",
            height: "fit-content",
            maxWidth: "84%",
            position: "relative"
          }
        }, /* @__PURE__ */ React.createElement("div", {
          style: {
            display: "flex",
            marginTop: `-${M(160)}`,
            alignItems: "flex-end",
            padding: `${M(14)} ${M(0)} ${M(14)} ${M(0)}`,
            marginLeft: `${Ce * 10}px`
          }
        }, Z ? /* @__PURE__ */ React.createElement("div", {
          className: "ChatOverlayAvatar-container"
        }, /* @__PURE__ */ React.createElement("img", {
          src: Z,
          className: "ChatOverlay-avatar"
        })) : /* @__PURE__ */ React.createElement("div", {
          className: "ChatOverlayAvatar-container"
        }, /* @__PURE__ */ React.createElement(X, {
          height: M(120),
          width: M(120),
          background: primary(500),
          username: ge,
          fontSize: M(30)
        })), ge && /* @__PURE__ */ React.createElement("button", {
          className: "ChatOverlay-badge-container"
        }, (P == null ? void 0 : P.icon) && /* @__PURE__ */ React.createElement(Icon$1, {
          className: "ChatOverlay-badge-icon",
          name: P == null ? void 0 : P.icon
        }), /* @__PURE__ */ React.createElement("div", {
          className: "ChatOverlay-badge-username"
        }, ge))), fe && /* @__PURE__ */ React.createElement("div", {
          ref: S,
          className: "ChatOverlay-body",
          style: {
            gap: 10,
            alignItems: "center",
            flexWrap: "wrap",
            verticalAlign: "middle"
          }
        }, fe.map((E, I) => /* @__PURE__ */ React.createElement(V, {
          key: I,
          ...E
        })))))
      )));
    }, Y = createRoot(l), ae = (ne) => Y.render(/* @__PURE__ */ React.createElement(oe, {
      ...ne
    }));
    return a((ne) => {
      const {
        bannerStyle: fe = BannerStyle.DEFAULT
      } = v.props ?? {};
      L = {
        ...ne,
        metadata: {
          ...ne.metadata,
          bannerStyle: fe
        }
      }, ae(L);
    }), {
      root: l
    };
  }
}, Element$1 = {
  name: "Element",
  sourceType: "Element",
  create({
    onUpdate: a
  }, {
    tagName: u = "div"
  }) {
    const c = document.createElement(u);
    return a(({
      tagName: l,
      attributes: v = {},
      fields: p = {}
    }) => {
      l === "img" ? (c == null ? void 0 : c.src) !== v.src && Object.keys(v).forEach((_) => {
        c.setAttribute(_, v[_]);
      }) : Object.keys(v).forEach((_) => {
        c.setAttribute(_, v[_]);
      }), Object.keys(p).forEach((_) => {
        try {
          typeof c[_] == "object" ? Object.assign(c[_], p[_]) : c[_] = p[_];
        } catch {
          log.warn("Cannot assign field to element", {
            field: _
          });
        }
      });
    }), {
      root: c
    };
  }
}, OfflineIcon = () => /* @__PURE__ */ React.createElement("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 256 256"
}, /* @__PURE__ */ React.createElement("rect", {
  width: "256",
  height: "256",
  fill: "none"
}), /* @__PURE__ */ React.createElement("line", {
  x1: "80",
  y1: "152",
  x2: "80",
  y2: "200",
  fill: "none",
  stroke: "currentColor",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  "stroke-width": "16"
}), /* @__PURE__ */ React.createElement("line", {
  x1: "40",
  y1: "192",
  x2: "40",
  y2: "200",
  fill: "none",
  stroke: "currentColor",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  "stroke-width": "16"
}), /* @__PURE__ */ React.createElement("line", {
  x1: "48",
  y1: "40",
  x2: "208",
  y2: "216",
  fill: "none",
  stroke: "currentColor",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  "stroke-width": "16"
}), /* @__PURE__ */ React.createElement("line", {
  x1: "160",
  y1: "163.2",
  x2: "160",
  y2: "200",
  fill: "none",
  stroke: "currentColor",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  "stroke-width": "16"
}), /* @__PURE__ */ React.createElement("line", {
  x1: "160",
  y1: "72",
  x2: "160",
  y2: "115.63",
  fill: "none",
  stroke: "currentColor",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  "stroke-width": "16"
}), /* @__PURE__ */ React.createElement("line", {
  x1: "200",
  y1: "32",
  x2: "200",
  y2: "159.63",
  fill: "none",
  stroke: "currentColor",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  "stroke-width": "16"
}), /* @__PURE__ */ React.createElement("line", {
  x1: "120",
  y1: "119.2",
  x2: "120",
  y2: "200",
  fill: "none",
  stroke: "currentColor",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  "stroke-width": "16"
})), GameSource = {
  name: "LS-Game-Source",
  sourceType: "Game",
  props: {},
  useSource(a, u) {
    return a.find((c) => isMatch(c.props, u.sourceProps));
  },
  create({
    onUpdate: a,
    onNewSource: u,
    onRemove: c
  }, l) {
    const v = document.createElement("div"), p = getProject(CoreContext.state.activeProjectId);
    Object.assign(v.style, {
      position: "relative"
    });
    let _, k = l;
    const M = (X, oe) => {
      const Y = X / oe.width;
      return Y >= 0.5 ? 3 : Y > 0.25 ? 2 : Y > 0.15 ? 1 : 0;
    }, L = ({
      props: X,
      source: oe
    }) => {
      var Ce;
      const Y = useRef(), {
        volume: ae = 1,
        isMuted: ne = !1
      } = X || {}, [fe, ie] = useState(0), ge = ne, be = !(X != null && X.isHidden) && ((Ce = oe == null ? void 0 : oe.props) == null ? void 0 : Ce.videoEnabled);
      return useEffect(() => {
        Y.current && (Y.current.play().catch((Me) => {
          document.addEventListener("click", () => {
            var Be;
            return (Be = Y.current) == null ? void 0 : Be.play();
          }, {
            once: !0
          });
        }), oe != null && oe.value && (oe == null ? void 0 : oe.value) !== Y.current.srcObject ? Y.current.srcObject = oe == null ? void 0 : oe.value : oe != null && oe.value || (Y.current.srcObject = null));
      }, [Y.current, oe == null ? void 0 : oe.value]), useEffect(() => {
        !X && Y.current && (Y.current.srcObject = null, Y.current = null);
      }, [X]), useLayoutEffect(() => {
        if (!Y.current)
          return;
        const Me = () => {
          const Ae = Y.current;
          Ae && ie(M(Ae.clientWidth, {
            width: p.compositor.getRoot().props.size.x,
            height: p.compositor.getRoot().props.size.y
          }));
        }, Be = new ResizeObserver((Ae) => {
          Me();
        });
        return Me(), Be == null || Be.observe(Y.current), () => {
          Y.current && (Be == null || Be.unobserve(Y.current), Y.current.srcObject = null);
        };
      }, [Y.current, p]), useEffect(() => {
        Y.current && (Y.current.volume = ae);
      }, [Y.current, ae]), /* @__PURE__ */ React.createElement("div", {
        style: {
          position: "relative",
          display: "flex",
          height: "100%",
          width: "100%"
        }
      }, /* @__PURE__ */ React.createElement("div", {
        style: {
          background: "#222",
          position: "absolute",
          height: "100%",
          width: "100%",
          fontSize: "43px",
          color: "rgba(255,255,255,0.6)",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          opacity: be ? "0" : "1"
        }
      }, !!oe && /* @__PURE__ */ React.createElement("div", {
        style: {
          textTransform: "uppercase",
          fontSize: 20,
          display: "flex",
          flexDirection: "column",
          alignItems: "center",
          justifyContent: "center",
          lineHeight: "1.2em",
          textAlign: "center",
          gap: 10
        }
      }, /* @__PURE__ */ React.createElement("div", {
        style: {
          color: "gray",
          width: 40,
          height: 40
        }
      }, /* @__PURE__ */ React.createElement(OfflineIcon, null)), "Game Source Offline")), /* @__PURE__ */ React.createElement("div", {
        style: {
          position: "relative",
          display: "flex",
          height: "100%",
          width: "100%"
        }
      }, /* @__PURE__ */ React.createElement("video", {
        ref: Y,
        autoPlay: !0,
        muted: ge,
        disablePictureInPicture: !0,
        playsInline: !0,
        style: {
          left: "50%",
          top: "50%",
          position: "relative",
          transform: "translate3d(-50%, -50%, 0)",
          height: "100%",
          opacity: be ? "1" : "0",
          objectFit: "cover",
          background: "rgba(0,0,0,0.6)"
        }
      })));
    }, F = createRoot(v), V = () => F.render(/* @__PURE__ */ React.createElement(L, {
      source: _,
      props: k
    }));
    return a((X) => {
      k = X, V();
    }), u((X) => {
      _ = X, V();
    }), c((X) => {
      k = X, V();
    }), {
      root: v
    };
  }
}, Logo = {
  name: "LS-Logo",
  sourceType: "Logo",
  create({
    onUpdate: a
  }, {
    sourceProps: u
  }) {
    const c = document.createElement("div"), v = getProject(CoreContext.state.activeProjectId).compositor.getRoot(), {
      x: p
    } = v.props.size, _ = (p ?? 1280) / 1920, k = (V) => V * _ + "px", M = ({
      source: V
    }) => {
      var Ce;
      const {
        src: X,
        meta: oe
      } = (V == null ? void 0 : V.sourceProps) || {}, {
        id: Y
      } = V || {}, [ae, ne] = React.useState(!1);
      useEffect(() => {
        ne(!1);
      }, [Y]);
      const {
        offsetX: fe = 40,
        offsetY: ie = 40,
        height: ge = 135,
        width: be = 240
      } = (oe == null ? void 0 : oe.style) || {};
      return /* @__PURE__ */ React.createElement(APIKitAnimation$1, {
        type: "logo",
        id: Y,
        enter: APIKitAnimationTypes.FADE_IN,
        exit: APIKitAnimationTypes.FADE_OUT,
        duration: 400
      }, /* @__PURE__ */ React.createElement("div", {
        style: {
          opacity: ae ? 1 : 0,
          width: "100%",
          height: "100%"
        },
        className: "logo-transition"
      }, X && /* @__PURE__ */ React.createElement("div", {
        className: "logo wrapper",
        style: {
          padding: `${k(ie)} ${k(fe)}`
        }
      }, /* @__PURE__ */ React.createElement("img", {
        style: {
          height: "100%",
          width: "100%",
          maxHeight: ge ? k(ge) : "none",
          maxWidth: be ? k(be) : "none",
          ...(Ce = u == null ? void 0 : u.meta) == null ? void 0 : Ce.style,
          ...oe == null ? void 0 : oe.style
        },
        src: X,
        onLoad: () => ne(!0)
      }))));
    }, L = createRoot(c), F = (V) => L.render(/* @__PURE__ */ React.createElement(M, {
      source: V
    }));
    return a((V) => {
      F({
        ...V
      });
    }), {
      root: c
    };
  }
}, Iframe = ({
  url: a,
  allowFullScreen: u,
  position: c,
  display: l,
  height: v,
  width: p,
  overflow: _,
  styles: k,
  onLoad: M,
  id: L,
  frameBorder: F,
  className: V,
  name: X,
  target: oe,
  iframeRef: Y,
  children: ae,
  src: ne
}) => {
  const fe = Object.assign({
    src: ne || a,
    target: oe || null,
    style: {
      position: c || null,
      display: l || "block",
      overflow: _ || null,
      ...k
    },
    name: X || null,
    className: V || null,
    id: L || null,
    onLoad: M || null,
    height: v || "100%",
    width: p || "100%",
    allow: "autoplay"
  });
  let ie = /* @__PURE__ */ Object.create(null);
  for (let ge of Object.keys(fe))
    fe[ge] != null && (ie[ge] = fe[ge]);
  for (let ge of Object.keys(ie.style))
    ie.style[ge] == null && delete ie.style[ge];
  if (u)
    if ("allow" in ie) {
      const ge = ie.allow.replace("fullscreen", "");
      ie.allow = `fullscreen ${ge.trim()}`.trim();
    } else
      ie.allow = "fullscreen";
  return F >= 0 && (ie.style.hasOwnProperty("border") || (ie.style.border = F)), /* @__PURE__ */ React.createElement(React.Fragment, null, ae ? /* @__PURE__ */ React.createElement("iframe", {
    ref: Y,
    ...ie,
    style: {
      colorScheme: "normal",
      ...ie.style
    }
  }, ae) : /* @__PURE__ */ React.createElement("iframe", {
    ref: Y,
    ...ie,
    style: {
      colorScheme: "normal",
      ...ie.style
    }
  }));
}, Iframe$1 = Iframe, Overlay = {
  name: "LS-Overlay",
  sourceType: "Overlay",
  create({
    onUpdate: a,
    onRemove: u
  }, {
    sourceProps: c
  }) {
    u(() => {
      clearInterval(p);
    });
    const l = document.createElement("div"), v = getProject(CoreContext.state.activeProjectId).role;
    let p;
    const _ = React.memo(({
      source: X,
      setStartAnimation: oe
    }) => {
      const {
        src: Y,
        meta: ae,
        height: ne,
        width: fe
      } = (X == null ? void 0 : X.sourceProps) || {}, ie = React.useRef(null);
      useEffect(() => {
        ie.current && (ie.current.style.removeProperty("transformOrigin"), ie.current.style.removeProperty("transform"));
      }, [Y]);
      const ge = () => {
        if (ie.current) {
          const Ce = getProject(CoreContext.state.activeProjectId).compositor.getRoot(), {
            x: Me,
            y: Be
          } = Ce.props.size;
          let Ae = ie.current.clientWidth, Z = ie.current.clientHeight, z;
          Ae && Z ? z = Math.min(Me / Ae, Be / Z) : z = 1, ie.current.style.willChange = "transform", ie.current.style.transformOrigin = "0 0", ie.current.style.transform = `scale(${z}) translateZ(0)`, oe(!0);
        }
      };
      return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Iframe$1, {
        key: X.id,
        url: Y,
        frameBorder: 0,
        iframeRef: ie,
        height: ne,
        width: fe,
        onLoad: ge,
        styles: {
          ...ae == null ? void 0 : ae.style
        }
      }));
    }), k = React.memo(({
      source: X,
      setStartAnimation: oe
    }) => {
      var z;
      const {
        src: Y,
        type: ae,
        meta: ne,
        loop: fe
      } = (X == null ? void 0 : X.sourceProps) || {}, {
        id: ie,
        sourceType: ge
      } = X || {}, [be, Ce] = React.useState(null), Me = React.useRef(null);
      console.log("Updated current time", (z = Me == null ? void 0 : Me.current) == null ? void 0 : z.currentTime);
      const Be = React.useCallback((P) => {
        Me.current = P, Ce(P ? P.id : null);
      }, []), Ae = React.useCallback(() => {
        Me != null && Me.current && Me.current.play().catch(() => {
          var P;
          Me.current.muted = !0, (P = Me.current) == null || P.play();
        });
      }, [Y]), Z = React.useCallback(() => {
        p && clearInterval(p), hasPermission(v, Permission.UpdateProject) && trigger$1("VideoEnded", {
          id: ie,
          category: ae
        });
      }, [Y]);
      return React.useEffect(() => {
        ne && (Me != null && Me.current) && be && hasPermission(v, Permission.ManageSelf) && ne != null && ne.time && (Me.current.currentTime = Number(ne == null ? void 0 : ne.time));
      }, [ne == null ? void 0 : ne.time, be]), React.useEffect(() => () => {
        p && clearInterval(p);
      }, [ie]), React.useEffect(() => {
        be ? Me.current && (Me.current.src = Y, Me.current.play().catch(() => {
          Me.current.muted = !0, Me.current.play();
        }), hasPermission(v, Permission.UpdateProject) && (p = setInterval(() => {
          if (Me.current.duration) {
            const P = Me.current.duration - Me.current.currentTime;
            trigger$1("VideoTimeUpdate", {
              category: ge,
              id: ie,
              time: Math.floor(P)
            });
          }
        }, 1e3))) : p && clearInterval(p);
      }, [be]), /* @__PURE__ */ React.createElement(React.Fragment, {
        key: ie
      }, Y && /* @__PURE__ */ React.createElement("video", {
        loop: fe,
        id: ie,
        ref: Be,
        style: {
          ...c.meta.style,
          ...ne.style
        },
        onLoadedData: Ae,
        onEnded: Z,
        onCanPlay: () => oe(!0)
      }));
    }), M = React.memo(({
      source: X,
      setStartAnimation: oe
    }) => {
      const {
        src: Y,
        meta: ae
      } = (X == null ? void 0 : X.sourceProps) || {}, {
        id: ne
      } = X || {};
      return /* @__PURE__ */ React.createElement(React.Fragment, {
        key: ne
      }, Y && /* @__PURE__ */ React.createElement("img", {
        style: {
          ...c.meta.style,
          ...ae.style
        },
        src: Y,
        onLoad: () => oe(!0)
      }));
    }), L = React.memo(({
      source: X
    }) => {
      const {
        type: oe
      } = (X == null ? void 0 : X.sourceProps) || {}, {
        id: Y
      } = X || {}, [ae, ne] = React.useState(!1);
      return useEffect(() => {
        ne(!1);
      }, [Y]), /* @__PURE__ */ React.createElement(APIKitAnimation$1, {
        id: Y,
        type: "overlay",
        enter: APIKitAnimationTypes.FADE_IN,
        exit: APIKitAnimationTypes.FADE_OUT,
        duration: 400
      }, /* @__PURE__ */ React.createElement("div", {
        style: {
          opacity: ae ? 1 : 0,
          height: "100%",
          width: "100%"
        },
        className: "overlayContainer overlay-transition"
      }, Y && oe === "image" && /* @__PURE__ */ React.createElement(M, {
        source: X,
        setStartAnimation: ne
      }), Y && oe === "video" && /* @__PURE__ */ React.createElement(k, {
        source: X,
        setStartAnimation: ne
      }), Y && oe === "custom" && /* @__PURE__ */ React.createElement(_, {
        source: X,
        setStartAnimation: ne
      })));
    }), F = createRoot(l), V = (X) => F.render(/* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(L, {
      source: X
    })));
    return a((X) => {
      V({
        ...X
      });
    }), {
      root: l
    };
  }
}, RTMPSource = {
  name: "LS-RTMP-Source",
  sourceType: "RTMP",
  props: {},
  useSource(a, u) {
    return a.find((c) => isMatch(c.props, u.sourceProps));
  },
  create({
    onUpdate: a,
    onNewSource: u,
    onRemove: c
  }, l) {
    const v = document.createElement("div"), p = getProject(CoreContext.state.activeProjectId);
    getProjectRoom(CoreContext.state.activeProjectId), Object.assign(v.style, {
      position: "relative"
    });
    let _, k = l;
    const M = (X, oe) => {
      const Y = X / oe.width;
      return Y >= 0.5 ? 3 : Y > 0.25 ? 2 : Y > 0.15 ? 1 : 0;
    }, L = ({
      props: X,
      source: oe
    }) => {
      var Ce;
      const Y = useRef(), {
        volume: ae = 1,
        isHidden: ne = !1
      } = X || {}, [fe, ie] = useState(0), ge = X == null ? void 0 : X.isMuted, be = !(X != null && X.isHidden) && ((Ce = oe == null ? void 0 : oe.props) == null ? void 0 : Ce.videoEnabled);
      return useEffect(() => {
        Y.current && (Y.current.play().catch((Me) => {
          document.addEventListener("click", () => {
            var Be;
            return (Be = Y.current) == null ? void 0 : Be.play();
          }, {
            once: !0
          });
        }), oe != null && oe.value && (oe == null ? void 0 : oe.value) !== Y.current.srcObject ? Y.current.srcObject = oe == null ? void 0 : oe.value : oe != null && oe.value || (Y.current.srcObject = null));
      }, [Y.current, oe == null ? void 0 : oe.value]), useEffect(() => {
        !X && Y.current && (Y.current.srcObject = null, Y.current = null);
      }, [X]), useLayoutEffect(() => {
        if (!Y.current)
          return;
        const Me = () => {
          const Ae = Y.current;
          Ae && ie(M(Ae.clientWidth, {
            width: p.compositor.getRoot().props.size.x,
            height: p.compositor.getRoot().props.size.y
          }));
        }, Be = new ResizeObserver((Ae) => {
          Me();
        });
        return Me(), Be == null || Be.observe(Y.current), () => {
          Y.current && (Be == null || Be.unobserve(Y.current), Y.current.srcObject = null);
        };
      }, [Y.current, p]), useEffect(() => {
        Y.current && (Y.current.volume = ae);
      }, [Y.current, ae]), /* @__PURE__ */ React.createElement("div", {
        style: {
          position: "relative",
          display: "flex",
          height: "100%",
          width: "100%"
        }
      }, /* @__PURE__ */ React.createElement("div", {
        style: {
          background: "#222",
          position: "absolute",
          height: "100%",
          width: "100%",
          fontSize: "43px",
          color: "rgba(255,255,255,0.6)",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          opacity: be ? "0" : "1"
        }
      }, !!oe && /* @__PURE__ */ React.createElement("div", {
        style: {
          borderRadius: "50%",
          background: "#555",
          width: "70px",
          height: "70px",
          textTransform: "uppercase",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          lineHeight: "1em"
        }
      }, "RTMP")), /* @__PURE__ */ React.createElement("div", {
        style: {
          position: "relative",
          display: "flex",
          height: "100%",
          width: "100%"
        }
      }, /* @__PURE__ */ React.createElement("video", {
        ref: Y,
        autoPlay: !0,
        muted: ge,
        disablePictureInPicture: !0,
        playsInline: !0,
        style: {
          left: "50%",
          top: "50%",
          position: "relative",
          transform: "translate3d(-50%, -50%, 0)",
          height: "100%",
          opacity: be ? "1" : "0",
          objectFit: "cover",
          background: "rgba(0,0,0,0.6)"
        }
      })));
    }, F = createRoot(v), V = () => F.render(/* @__PURE__ */ React.createElement(L, {
      source: _,
      props: k
    }));
    return a((X) => {
      k = X, V();
    }), u((X) => {
      _ = X, V();
    }), c((X) => {
      k = X, V();
    }), {
      root: v
    };
  }
}, RoomParticipant = {
  name: "LS-Room-Participant",
  sourceType: "RoomParticipant",
  props: {
    isMuted: {
      type: Boolean,
      required: !1,
      default: !1
    },
    volume: {
      type: Number,
      required: !1,
      default: 1
    }
  },
  useSource(a, u) {
    return a.find((c) => isMatch(c.props, u.sourceProps));
  },
  create({
    onUpdate: a,
    onNewSource: u,
    onRemove: c
  }, l) {
    const v = document.createElement("div"), p = getProject(CoreContext.state.activeProjectId), _ = getProjectRoom(CoreContext.state.activeProjectId);
    Object.assign(v.style, {
      position: "relative"
    });
    let k, M = l;
    const L = (oe, Y) => {
      const ae = oe / Y.width;
      return ae >= 0.5 ? 3 : ae > 0.25 ? 2 : ae > 0.15 ? 1 : 0;
    }, F = ({
      props: oe,
      source: Y
    }) => {
      var Ae, Z, z;
      const ae = useRef(), {
        volume: ne = 1,
        isHidden: fe = !1,
        isAudioOnly: ie = !1
      } = oe || {}, [ge, be] = useState(0), Me = (Y == null ? void 0 : Y.id) === (_ == null ? void 0 : _.participantId) || ((Ae = Y == null ? void 0 : Y.props) == null ? void 0 : Ae.participantId) === (_ == null ? void 0 : _.participantId) || (Y == null ? void 0 : Y.id.startsWith(_ == null ? void 0 : _.participantId)) || (oe == null ? void 0 : oe.isMuted), Be = !ie && !fe && ((Z = Y == null ? void 0 : Y.props) == null ? void 0 : Z.videoEnabled);
      return useEffect(() => {
        ae.current && (ae.current.play().catch((P) => {
          document.addEventListener("click", () => {
            var S;
            return (S = ae.current) == null ? void 0 : S.play();
          }, {
            once: !0
          });
        }), Y != null && Y.value && (Y == null ? void 0 : Y.value) !== ae.current.srcObject ? ae.current.srcObject = Y == null ? void 0 : Y.value : Y != null && Y.value || (ae.current.srcObject = null));
      }, [ae.current, Y == null ? void 0 : Y.value]), useEffect(() => {
        !oe && ae.current && (ae.current.srcObject = null, ae.current = null);
      }, [oe]), useLayoutEffect(() => {
        if (!ae.current)
          return;
        const P = () => {
          const E = ae.current;
          E && be(L(E.clientWidth, {
            width: p.compositor.getRoot().props.size.x,
            height: p.compositor.getRoot().props.size.y
          }));
        }, S = new ResizeObserver((E) => {
          P();
        });
        return P(), S == null || S.observe(ae.current), () => {
          ae.current && (S == null || S.unobserve(ae.current), ae.current.srcObject = null);
        };
      }, [ae.current, p]), useEffect(() => {
        ae.current && (ae.current.volume = ne);
      }, [ae.current, ne]), /* @__PURE__ */ React.createElement("div", {
        style: {
          position: "relative",
          display: "flex",
          ...ie ? {
            height: "0px",
            width: "0px"
          } : {
            height: "100%",
            width: "100%"
          }
        }
      }, /* @__PURE__ */ React.createElement("div", {
        style: {
          background: "#222",
          position: "absolute",
          height: "100%",
          width: "100%",
          fontSize: "43px",
          color: "rgba(255,255,255,0.6)",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          opacity: Be || ie ? "0" : "1"
        }
      }, (Y == null ? void 0 : Y.props.displayName) && !(oe != null && oe.isAudioOnly) && /* @__PURE__ */ React.createElement("div", {
        style: {
          borderRadius: "50%",
          background: "#555",
          width: "70px",
          height: "70px",
          textTransform: "uppercase",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          lineHeight: "1em"
        }
      }, (Y == null ? void 0 : Y.props.displayName.slice(0, 1)) || "")), /* @__PURE__ */ React.createElement("div", {
        style: {
          position: "relative",
          display: "flex",
          height: "100%",
          width: "100%",
          ...!!((z = Y == null ? void 0 : Y.props) != null && z.mirrored) && {
            transform: "scaleX(-1)"
          }
        }
      }, /* @__PURE__ */ React.createElement("video", {
        ref: ae,
        autoPlay: !0,
        muted: Me,
        disablePictureInPicture: !0,
        playsInline: !0,
        style: {
          left: "50%",
          top: "50%",
          position: "relative",
          transform: "translate3d(-50%, -50%, 0)",
          height: "100%",
          opacity: Be ? "1" : "0",
          objectFit: (Y == null ? void 0 : Y.props.type) === "screen" ? "contain" : "cover",
          background: "rgba(0,0,0,0.6)"
        }
      })), (Y == null ? void 0 : Y.props.displayName) && !ie && /* @__PURE__ */ React.createElement("div", {
        className: "NameBannerContainer",
        style: {
          width: "100%",
          height: "100%",
          position: "absolute"
        }
      }, /* @__PURE__ */ React.createElement("div", {
        className: "NameBanner",
        "data-size": ge,
        style: {
          padding: "12px 30px",
          width: "fit-content",
          height: "fit-content",
          top: "100%",
          transform: "translateY(-100%)",
          left: 0
        }
      }, /* @__PURE__ */ React.createElement("div", {
        className: "NameBanner-body"
      }, Y.props.displayName))));
    }, V = createRoot(v), X = () => V.render(/* @__PURE__ */ React.createElement(F, {
      source: k,
      props: M
    }));
    return a((oe) => {
      M = oe, X();
    }), u((oe) => {
      k = oe, X();
    }), c((oe) => {
      M = oe, X();
    }), {
      root: v
    };
  }
}, Alert = {
  name: "LS-Alert",
  sourceType: "Alert",
  create({
    onUpdate: a
  }) {
    const u = document.createElement("div"), c = ({
      source: p
    }) => {
      const {
        id: _
      } = p || {}, [k, M] = React.useState(!1);
      useEffect(() => {
        M(!1);
      }, [_]);
      const {
        src: L,
        meta: F,
        height: V,
        width: X,
        settings: oe
      } = (p == null ? void 0 : p.sourceProps) || {}, Y = React.useRef(null), ae = React.useMemo(() => Object.entries(oe).map((fe) => fe.join("=")).concat(["mode=engine"]).join("&"), [oe]), ne = React.useCallback(() => {
        Y.current && M(!0);
      }, []);
      return /* @__PURE__ */ React.createElement(APIKitAnimation$1, {
        id: _,
        type: "alert",
        enter: APIKitAnimationTypes.FADE_IN,
        exit: APIKitAnimationTypes.FADE_OUT,
        duration: 400
      }, /* @__PURE__ */ React.createElement("div", {
        style: {
          opacity: k ? 1 : 0
        }
      }, /* @__PURE__ */ React.createElement(Iframe$1, {
        key: p.id,
        url: `${L}?${ae}`,
        frameBorder: 0,
        iframeRef: Y,
        height: V,
        width: X,
        onLoad: ne,
        styles: {
          ...F == null ? void 0 : F.style
        }
      })));
    }, l = createRoot(u), v = (p) => l.render(/* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(c, {
      source: p
    })));
    return a((p) => {
      v({
        ...p
      });
    }), {
      root: u
    };
  }
}, Transforms = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Alert,
  Background,
  Banner,
  ChatOverlay,
  Element: Element$1,
  GameSource,
  Logo,
  Overlay,
  RTMPSource,
  RoomParticipant
}, Symbol.toStringTag, { value: "Module" }));
class EngineWebsocket {
  constructor(u, c) {
    Ft(this, "ws", null);
    Ft(this, "sources", /* @__PURE__ */ new Set());
    this.connectSource = u, this.disconnectSource = c, this.connect = this.connect.bind(this), this.handleMessage = this.handleMessage.bind(this);
  }
  getConnectionString() {
    if (!("apistreamCompositor" in window))
      return "ws://127.0.0.1:8000";
    const {
      eventsConfig: u
    } = window.apistreamCompositor;
    return `ws${u.secure ? "s" : ""}://${u.hostname}:${u.port}${u.token ? `?token=${u.token}` : ""}`;
  }
  connect() {
    const u = this.handleMessage.bind(this);
    this.ws = new WebSocket(this.getConnectionString()), this.ws.addEventListener("message", u), this.ws.addEventListener("error", (c) => {
      console.error("Unable to connect to websocket", c);
    }), this.ws.addEventListener("close", () => {
      var c, l;
      (c = this.ws) == null || c.removeEventListener("message", u);
      try {
        (l = this.ws) == null || l.close(), this.ws = null;
      } catch {
      }
      setTimeout(() => {
        this.connect();
      }, 1e3);
    });
  }
  disconnect() {
    var u, c;
    (u = this.ws) != null && u.OPEN && ((c = this.ws) == null || c.close());
  }
  handleMessage(u) {
    try {
      const c = JSON.parse(u.data);
      if (c.name === "state") {
        this.sources.clear(), console.info("[Engine]: state", c.payload);
        for (const l of c.payload.sources)
          l.connected && (this.sources.has(l.id) || (this.sources.add(l.id), this.connectSource(l.id)));
      } else
        c.name === "source.disconnect" ? (console.info("[Engine]: source disconnect", c.payload.id), this.sources.delete(c.payload.id), this.disconnectSource(c.payload.id)) : c.name === "source.connect" && (console.info("[Engine]: source connect", c.payload.id), this.sources.add(c.payload.id), this.connectSource(c.payload.id));
    } catch (c) {
      console.error("unable to handle message: ", c);
    }
  }
}
const BroadcastPhase = lib$2.LiveApiModel.ProjectBroadcastPhase, {
  trigger,
  triggerInternal
} = CoreContext, EventType = lib$2.LiveApiModel.EventType, EventSubType = lib$2.LiveApiModel.EventSubType;
let engineSocket;
const init = async (a = {}) => {
  prepareInternalEvents();
  const u = a.env || "prod", c = a.logLevel || "Warn";
  log.getLogger("livekit").setLevel(c), log.setLevel(c), log.info("Initializing Studio SDK...");
  const {
    layouts: v = [],
    transforms: p = [],
    sources: _ = [],
    defaultTransforms: k = {},
    useLatestRenderer: M = !1,
    guestToken: L,
    rendererVersion: F
  } = a, V = new lib$2.ApiStream({
    sdkVersion: CoreContext.version,
    env: u,
    logLevel: c
  }), X = config$2(), oe = start({
    dbAdapter: compositorAdapter,
    transformSettings: {
      defaultTransforms: {
        ...k,
        ...X.defaults.transforms
      }
    }
  });
  CoreContext.config = X, CoreContext.clients = V, CoreContext.compositor = oe, CoreContext.logLevel = c, CoreContext.Request = await Promise.resolve().then(() => requests), CoreContext.Command = await Promise.resolve().then(() => commands$1), CoreContext.rendererVersion = M ? "latest-v2" : F || CoreContext.version, window.__StudioKit = {
    ...CoreContext
  }, oe && (oe.registerSource([...Object.values(Sources), ..._]), oe.registerTransform([...Object.values(Transforms), ...p]), oe.registerLayout([...Object.values(Layouts), ...v]));
  const Y = await V.load(L);
  let ae;
  Y && await V.LiveApi().project.getProject({
    ...Y
  }).then((ie) => hydrateProject(ie.project, Y.role)).then(async (ie) => {
    setAppState({
      // As a contributor, `user` refers to the collection
      //  that the project belongs to. This will be referenced
      //  when making requests requiring `collectionId`.
      user: {
        id: Y.collectionId,
        props: {},
        name: null,
        metadata: {}
      },
      // TODO: Populate
      sources: [],
      projects: [ie],
      activeProjectId: null
    }), ie.isInitial = !0, ae = await CoreContext.Command.setActiveProject({
      projectId: ie.id
    });
  }), V.LiveApi().on(EventType.EVENT_TYPE_COLLECTION, (ie, ge) => {
    switch (log.info("Received: Collection event", ge, ie), ge) {
      case EventSubType.EVENT_SUB_TYPE_UPDATE: {
        triggerInternal("UserChanged", ie.update.collection);
        return;
      }
    }
  }), V.LiveApi().on(EventType.EVENT_TYPE_DESTINATION, (ie, ge) => {
    switch (log.info("Received: Destination event", ge, ie), ge) {
      case EventSubType.EVENT_SUB_TYPE_CREATE: {
        const {
          destination: be
        } = ie.create;
        triggerInternal("DestinationAdded", be);
        return;
      }
      case EventSubType.EVENT_SUB_TYPE_UPDATE: {
        const {
          destination: be
        } = ie.update;
        triggerInternal("DestinationChanged", be);
        return;
      }
      case EventSubType.EVENT_SUB_TYPE_DELETE: {
        triggerInternal("DestinationRemoved", ie.delete);
        return;
      }
    }
  }), V.LiveApi().on(EventType.EVENT_TYPE_SOURCE, (ie, ge) => {
    switch (log.info("Received: Source event", ge, ie), ge) {
      case EventSubType.EVENT_SUB_TYPE_CREATE: {
        triggerInternal("SourceAdded", ie.create.source);
        return;
      }
      case EventSubType.EVENT_SUB_TYPE_UPDATE: {
        triggerInternal("SourceChanged", ie.update.source);
        return;
      }
      case EventSubType.EVENT_SUB_TYPE_DELETE: {
        triggerInternal("SourceRemoved", ie.delete.sourceId);
        return;
      }
      case EventSubType.EVENT_SUB_TYPE_ADD: {
        triggerInternal("ProjectSourceAdded", {
          projectId: ie.add.projectId,
          source: ie.add.source
        });
        return;
      }
      case EventSubType.EVENT_SUB_TYPE_REMOVE: {
        triggerInternal("ProjectSourceRemoved", {
          projectId: ie.remove.projectId,
          sourceId: ie.remove.sourceId
        });
        return;
      }
    }
  }), V.LiveApi().on(EventType.EVENT_TYPE_PROJECT, (ie, ge) => {
    var be;
    switch (log.info("Received: Project event", ge, ie), ge) {
      case EventSubType.EVENT_SUB_TYPE_CREATE: {
        const Ce = ie.create.project;
        if (getProject(Ce.projectId))
          return;
        triggerInternal("ProjectAdded", Ce);
        return;
      }
      case EventSubType.EVENT_SUB_TYPE_UPDATE: {
        const {
          project: Ce
        } = ie.update, Me = getProject(Ce.projectId);
        if (!Me)
          return;
        triggerInternal("ProjectChanged", {
          project: Ce,
          phase: Me.videoApi.phase
        });
        return;
      }
      case EventSubType.EVENT_SUB_TYPE_DELETE: {
        triggerInternal("ProjectRemoved", {
          projectId: ie.delete.projectId
        });
        return;
      }
      case EventSubType.EVENT_SUB_TYPE_STATE: {
        const Ce = getProject((be = ie.state) == null ? void 0 : be.projectId);
        if (!Ce)
          return;
        let Me = ie.state.broadcastId;
        if (ie.state.error && trigger("BroadcastError", {
          projectId: Ce.id,
          broadcastId: ie.state.broadcastId,
          error: ie.state.error
        }), ie.state.phase) {
          const Be = ie.state.phase;
          Be === BroadcastPhase.PROJECT_BROADCAST_PHASE_RUNNING ? trigger("BroadcastStarted", {
            projectId: Ce.id,
            broadcastId: ie.state.broadcastId
          }) : Be === BroadcastPhase.PROJECT_BROADCAST_PHASE_STOPPED && (Me = null, trigger("BroadcastStopped", {
            projectId: Ce.id,
            broadcastId: ie.state.broadcastId
          }));
        }
        triggerInternal("ProjectChanged", {
          project: Ce.videoApi.project,
          phase: ie.state.phase,
          broadcastId: Me
        });
        return;
      }
    }
  }), V.LayoutApi().on(lib$2.LayoutApiModel.EventType.EVENT_TYPE_LAYER, (ie, ge) => {
    var be;
    if (ge === lib$2.LayoutApiModel.EventSubType.EVENT_SUB_TYPE_CREATE) {
      log.debug("Received: Node Insert", ie.create);
      const {
        connectionId: Ce,
        layoutId: Me
      } = ie.create.requestMetadata;
      if (CoreContext.connectionId === Ce)
        return;
      const Be = layerToNode(ie.create), Ae = getProjectByLayoutId(Me), Z = [Be, ...Ae.compositor.nodes.map(toDataNode$1)], z = toSceneTree(Z, Be.id);
      Ae.compositor.local.insert(z), triggerInternal("NodeAdded", {
        projectId: Ae.id,
        nodeId: Be.id
      });
    } else if (ge === lib$2.LayoutApiModel.EventSubType.EVENT_SUB_TYPE_UPDATE) {
      log.debug("Received: Node Update", ie.update);
      const {
        connectionId: Ce,
        layoutId: Me,
        updateVersions: Be = {}
      } = ((be = ie.update) == null ? void 0 : be.requestMetadata) || {};
      if (CoreContext.connectionId === Ce)
        return;
      const Ae = layerToNode(ie.update);
      if ((latestUpdateVersion[Ae.id] || 0) > Be[Ae.id])
        return log.info("Ignoring node update - updateID is less than latest.");
      latestUpdateVersion[Ae.id] = Be[Ae.id];
      const z = getProjectByLayoutId(Me);
      z.compositor.local.update(ie.update.id, Ae.props, Ae.childIds), triggerInternal("NodeChanged", {
        projectId: z.id,
        nodeId: Ae.id
      });
    } else if (ge === lib$2.LayoutApiModel.EventSubType.EVENT_SUB_TYPE_DELETE) {
      log.debug("Received: Node Delete", ie.delete);
      const {
        connectionId: Ce,
        layoutId: Me
      } = ie.delete.requestMetadata;
      if (CoreContext.connectionId === Ce)
        return;
      const Be = getProjectByLayoutId(Me);
      Be.compositor.local.remove(ie.delete.id), triggerInternal("NodeRemoved", {
        projectId: Be.id,
        nodeId: ie.delete.id
      });
    } else if (ge === lib$2.LayoutApiModel.EventSubType.EVENT_SUB_TYPE_BATCH) {
      log.debug("Received: Node Batch Update", ie.batch);
      const {
        connectionId: Ce,
        layoutId: Me,
        updateVersions: Be = {}
      } = ie.batch.requestMetadata;
      if (CoreContext.connectionId === Ce)
        return;
      const Ae = getProjectByLayoutId(Me);
      ie.batch.layers.forEach((Z) => {
        try {
          const [z, P] = Object.entries(Z)[0];
          if (z === "create") {
            const S = layerToNode(P);
            Ae.compositor.local.insert(S), triggerInternal("NodeAdded", {
              projectId: Ae.id,
              nodeId: S.id
            });
          } else if (z === "update") {
            const S = layerToNode(P);
            if ((latestUpdateVersion[S.id] || 0) > Be[S.id])
              return log.info("Ignoring node update - updateID is less than latest.");
            latestUpdateVersion[S.id] = Be[S.id], Ae.compositor.local.update(S.id, S.props, S.childIds), triggerInternal("NodeChanged", {
              projectId: Ae.id,
              nodeId: S.id
            });
          } else
            z === "delete" && (Ae.compositor.local.remove(P.id), triggerInternal("NodeRemoved", {
              projectId: Ae.id,
              nodeId: P.id
            }));
        } catch (z) {
          log.warn("Error handling batch item", z, {
            item: Z
          });
        }
      }), Ae && triggerInternal("NodeChanged", {
        projectId: Ae.id,
        nodeId: Ae.compositor.getRoot().id
      });
    }
  });
  const ne = (ie = {}, ge) => {
    const {
      displayName: be,
      role: Ce,
      maxDuration: Me = CoreContext.config.defaults.guestTokenDuration,
      projectId: Be = CoreContext.state.activeProjectId
    } = ie, Ae = getProject(Be), Z = be ? {
      direct: {
        displayName: be
      }
    } : {
      exchange: {
        maxDuration: Me
      }
    };
    return V.LiveApi().authentication.createGuestCode({
      projectId: Be,
      token: Z,
      url: ge,
      collectionId: Ae.videoApi.project.collectionId,
      maxDuration: Me,
      role: Ce || lib$2.LiveApiModel.Role.ROLE_GUEST
    });
  }, fe = (ie = {}, ge) => {
    const {
      displayName: be,
      role: Ce,
      maxDuration: Me = CoreContext.config.defaults.guestTokenDuration,
      projectId: Be = CoreContext.state.activeProjectId
    } = ie, Ae = getProject(Be), Z = be ? {
      direct: {
        displayName: be
      }
    } : {
      exchange: {
        maxDuration: Me
      }
    };
    return V.LiveApi().authentication.createGuestAccessToken({
      projectId: Be,
      token: Z,
      url: ge,
      collectionId: Ae.videoApi.project.collectionId,
      maxDuration: Me,
      role: Ce || lib$2.LiveApiModel.Role.ROLE_GUEST
    });
  };
  return {
    ...omit(CoreContext, ["clients", "config", "connectionId", "Request", "state", "trigger"]),
    createDemoToken: async () => (console.warn("createDemoToken() is currently unavailable."), ""),
    createPreviewLink: async (ie = {}) => {
      const {
        maxDuration: ge,
        projectId: be = CoreContext.state.activeProjectId
      } = ie, Ce = getProject(be), Me = Ce.videoApi.project.composition.studioSdk.rendererUrl;
      return (await V.LiveApi().authentication.createGuestAccessToken({
        projectId: be,
        token: {
          direct: {
            displayName: "Preview"
          }
        },
        url: Me,
        collectionId: Ce.videoApi.project.collectionId,
        maxDuration: ge || CoreContext.config.defaults.previewTokenDuration,
        role: lib$2.LiveApiModel.Role.ROLE_VIEWER
      })).url;
    },
    createGuestLink: async (ie, ge = {}) => (await ne(ge, ie)).guestCode.linkUrl,
    deleteGuestLink: async (ie) => {
      await V.LiveApi().authentication.deleteGuestCode({
        code: ie
      });
    },
    getGuestLinks: async (ie = {}) => {
      const {
        projectId: ge = CoreContext.state.activeProjectId
      } = ie, be = getProject(ge);
      return await V.LiveApi().authentication.getGuestCodes({
        projectId: ge,
        collectionId: be == null ? void 0 : be.videoApi.project.collectionId
      });
    },
    createGuestToken: async (ie = {}) => (await fe(ie)).accessToken,
    initialProject: ae,
    getProject: (ie) => toBaseProject(getProject(ie)),
    load,
    render
  };
};
CoreContext.on("ActiveProjectChanged", ({
  projectId: a
}) => {
  toBaseProject(getProject(a)).role === Role.ROLE_RENDERER && (log.info("Connecting to engine websocket..."), engineSocket && (log.info("Disconnecting existing engine websocket..."), engineSocket.disconnect(), engineSocket = null), engineSocket || (log.info("Creating new engine websocket..."), engineSocket = setupEngineWebsocket(async function(l) {
    triggerInternal("SourceConnected", l);
  }, async function(l) {
    triggerInternal("SourceDisconnected", l);
  }), engineSocket.connect()));
});
function setupEngineWebsocket(a, u) {
  return new EngineWebsocket(a, u);
}
const load = async (a, u) => {
  let c = getBaseUser();
  if (c)
    return log.info("Attempted to load user again - returning existing user"), c;
  if (!a) {
    log.warn("Access token required for load()");
    return;
  }
  log.info("Loading user..."), await CoreContext.clients.load(a);
  const v = await CoreContext.Request.loadUser(u);
  return setAppState({
    user: v.user,
    sources: v.sources,
    projects: v.projects,
    activeProjectId: null
  }), c = getBaseUser(), trigger("UserLoaded", c), c;
};
export {
  commands$1 as Command,
  index as Compositor,
  context as Context,
  events$1 as Events,
  index$1 as Helpers,
  Layouts,
  requests as Request,
  index$2 as Room,
  types$2 as SDK,
  init
};
//# sourceMappingURL=index.js.map
